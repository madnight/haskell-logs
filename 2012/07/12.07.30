00:00:05 <Veinor> right :)
00:00:06 <ddarius> I don't think anyone uses Data.Tree.
00:00:07 <edwardk> make your Monad, Traversable, etc. and you'll find you get a lot of mileage out of them
00:00:24 <edwardk> i just defined lenses for it, does that count? =)
00:00:41 <ddarius> edwardk: No.
00:00:44 <edwardk> =)
00:00:52 <edwardk> ok, one lens and a traversal
00:01:15 <edwardk> root :: Simple Lens (Tree a) a; children :: Simple Traversal (Tree a) (Tree a)
00:01:45 <edwardk> i've been meaning to figure out if a nice multiplate like thing can be build using Simple Traversal a a
00:02:00 <edwardk> e.g. take that, and iterate it to walk into itself
00:02:04 <ddarius> Shouldn't that be roconnor's job?
00:02:12 <edwardk> meh
00:02:18 <edwardk> i tend to steal work from him ;)
00:02:48 <edwardk> i said 'hey roconnor, why don't you maintain my lens library', and then now look at me ;)
00:03:23 <ddarius> You do have a disconcerting fascination with work stealing.
00:03:39 <edwardk> its high performance =)
00:05:34 <shachaf> Does [] count as a tree type?
00:06:12 <latro`a> in the graph theory sense a linked list is a tree
00:06:17 <latro`a> not sure if that's the answer you wanted
00:07:04 <shachaf> latro`a: Even if it's cyclic? :-
00:07:15 <latro`a> what do you mean by cyclic
00:07:21 <latro`a> something like cycle [1,2,3]?
00:07:31 <latro`a> if so, still yes; the identical copies are in different nodes
00:07:54 <latro`a> if you mean a "linked list" where the pointers loop around
00:08:02 <latro`a> then that's not the sort of linked list I meant
00:08:17 <shachaf> latro`a: In cycle [1,2,3] the pointer does loop around.
00:08:20 <shachaf> Not that you can tell.
00:08:31 <shachaf> latro`a: Is there any value in Haskell which you wouldn't count as a tree?
00:08:48 <latro`a> umm
00:08:49 * hackagebot lens 1.1 - Families of Lenses, Folds and Traversals (EdwardKmett)
00:09:13 <latro`a> certain functions can't be encoded as trees, iirc
00:09:33 <latro`a> ah actually no, essentially no functions can
00:10:05 <latro`a> if the graph is "V = domain U codomain, an edge exists between u and v iff f(u)=v"
00:10:16 <latro`a> er, pointing from u to v
00:10:42 <latro`a> then only functions with a single element in the codomain form trees, iirc
00:10:50 <latro`a> (it's 3 am here, so my graph theory will be unusually rusty)
00:12:39 <ddarius> latro`a: That would be the case if the domain and codomain were disjoint.
00:12:47 <latro`a> eh
00:12:48 <latro`a> labeled union
00:13:30 <latro`a> that is, replace A with {(a,A) : a in A} and similar for
00:13:32 <latro`a> B
00:14:04 <mikeplus64> @pl forM_ fs $ \f -> runReaderT (f x) e >>= writeChan o
00:14:04 <lambdabot> forM_ fs ((writeChan o =<<) . flip runReaderT e . ($ x))
00:14:20 <latro`a> that is surprisingly noncomplicated
00:14:52 <ddarius> latro`a: I don't think that's what you want as if A = B then they will produce the same set and still not be disjoint.
00:14:55 <mikeplus64> i'd almost not gag if i saw someone use it
00:15:23 <latro`a> ddarius: there's some referential transparency issues if they're the exact same set
00:15:32 <latro`a> a better way, I guess
00:15:45 <latro`a> replace A with {(a,1) : a in A}, B with {(b,2) : b in B}
00:15:52 <latro`a> or something similar
00:16:02 <latro`a> you know what I meant by labeled union, ofc
00:16:16 <latro`a> I'm literally drawing the graphs you drew when first learning about functions
00:18:49 * hackagebot void 0.5.7 - A Haskell 98 logically uninhabited data type (EdwardKmett)
00:19:17 <latro`a> ...
00:19:19 <latro`a> what
00:19:25 <latro`a> ok now I have to look at this
00:19:28 <edwardk> ?
00:19:42 <edwardk> newtype Void = Void Void
00:19:44 <edwardk> done
00:20:02 <edwardk> absurd (Void a) = absurd a
00:20:22 <latro`a> I'm just surprised that there are versions of that
00:20:35 <mikeplus64> absurd _ = True maybe
00:21:17 <edwardk> dan burton sent me a request to make the absurd function force its argument, so more things will <<<loop>>> than loop forever
00:21:24 <edwardk> so i iterated
00:21:46 <edwardk> it has a couple dependencies, for the instance of Semigroup, etc.
00:22:13 <edwardk> and so when those bump it gets bumped
00:22:59 <edwardk> also the newtype construction was fairly brittle for a while, so on old ghc's that didn't work, and there is a vacuous combinator for mapping over a functor that was added
00:23:18 <edwardk> so overall it is a little microcosm of 'crap you have to deal with as a package maintainer no matter what' ;)
00:24:35 <shachaf> edwardk: Wasn't this the package that let you write unsafeCoerce with type families?
00:24:58 <edwardk> possibly
00:25:35 <edwardk> the functor instance was a lie though ;)
00:25:40 <edwardk> so its not my fault. ;)
00:32:36 <yitz> edwardk: that sounds like a strange request. isn't absurd forcing its argument rather... absurd?
00:33:19 <edwardk> yitz: well, if it doesn't,absurd (error "bottom") will loop forever
00:33:30 <edwardk> but if it does it'll ***Exception: bottom
00:34:00 <edwardk> both are nominally bottoms, but the latter is i suppose a better bottom
00:34:48 <yitz> edwardk: more precisely - isn't absurd just undefined with a more specific type? so that its purpose would be to satisfy the type checker, and you wouldn't expect it ever actually to be called at runtime in a real program. that's not true?
00:35:37 <edwardk> yitz: in theory. but in the horrible case where someone does try to slip one past, it'd be good to deal with it correctly
00:35:56 <yitz> if so, then why should its strictness properties be any different than those of undefined?
00:36:26 <yitz> so then undefined ought to be more strict too?
00:36:30 <shachaf> undefined is strict
00:36:32 <edwardk> absurd x -- does have the strictness properties of undefined
00:36:39 <edwardk> with the change
00:36:43 <edwardk> before it was lazier
00:36:56 <yitz> ah ok.
00:38:46 <yitz> > undefined [1..]
00:38:47 <lambdabot>   *Exception: Prelude.undefined
00:39:04 <shachaf> (const undefined) is also strict
00:39:12 <yitz> > undefined $ fix id
00:39:12 <lambdabot>   *Exception: Prelude.undefined
00:39:19 <yitz> looks lazy to me
00:39:42 <yitz> > undefined $ error "error fired first"
00:39:43 <lambdabot>   *Exception: Prelude.undefined
00:40:02 <shachaf> yitz: No, because all _|_s are equal
00:40:11 <shachaf> "f is strict" just means that f _|_ = _|_
00:40:17 <edwardk> strictness doesn't tell you which bottom you get
00:40:18 <shachaf> It doesn't say anything about which _|_ it is.
00:40:29 <edwardk> just that _|_ -> _|_
00:40:39 <shachaf> I don't think there's a word for the operational idea of "forces its argument".
00:40:55 <shachaf> In almost all cases they're the same.
00:42:01 <yitz> edwardk: but you are distinguishing between looping forever and throwing an exception. those are both _|_. so that seems to be what this discussion is about.
00:43:03 <shachaf> yitz: That's only an operational difference.
00:43:29 <edwardk> the patch makes it so that instead of looping forever i throw out whatever error you fed me. its strictly a better bottom. both are bottoms though.
00:44:04 <shachaf> Betty botter bought a better bottom
00:44:06 <yitz> edwardk: so then shouldn't undefined do the same, if it is strictly better?
00:44:06 <edwardk> one produces more heat from my CPU, i was willing to avoid that side-effect ;)
00:44:18 <edwardk> undefined threw an exception didn't it?
00:44:27 <edwardk> it didn't cause lambdabot to time out
00:44:47 <edwardk> that is the difference
00:44:53 <poucet> hello
00:45:04 <edwardk> heya poucet : long time no see
00:45:08 <poucet> indeed
00:45:17 <shachaf> houcet
00:45:26 <yitz> shachaf: but the better bottom Betty Bottor bought was bitter
00:46:19 <poucet> edwardk: working on a new product these days :)
00:46:28 <poucet> (and as SWE, no longer SRE)
00:46:29 <edwardk> poucet: still in zurich?
00:46:44 <poucet> edwardk: yep
00:47:07 <poucet> What are you up to these days?
00:47:08 <edwardk> you should figure out an excuse to head down to mountain view around gsoc mentor summit time ;)
00:47:28 <poucet> edwardk: when is that precisely?
00:47:30 <yitz> > error $ fix id
00:47:33 <lambdabot>   mueval-core: Time limit exceeded
00:47:38 <poucet> would've been easier in my previous role, tho
00:48:35 <edwardk> working at capital iq. we have a little haskell-like langauge we use. otherwise working on odds and ends. most recently pushed out a pretty nice lens library to hackage that lets you compose things that work like functions, functors, folds, traversals, and functional references with the same combinators
00:49:15 <poucet> Sounds like you're having fun :)
00:49:25 <edwardk> Oct 19-21
00:50:07 <edwardk> otherwise i've been doing a lot of work on near realtime hamiltonian metropolis light transport for graphics, and fiddling with a cheesy little game engine in haskell
00:52:07 <edwardk> oh, and i released a nice library for dealing with capture avoiding substitution in an elegant way. gave a talk on it a couple days back
00:52:44 <edwardk> http://hackage.haskell.org/package/bound http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less
00:53:00 <poucet> love the pun
00:53:20 <edwardk> i beat the pun to death in the slides ;)
00:53:21 <shachaf> edwardk: Is your talk online?
00:53:24 <shachaf> Oh, that's the second link.
00:53:32 <edwardk> shachaf: i captured video but i haven't uploaded it
00:53:48 <edwardk> need to put the video editing software on my laptop
00:54:12 <shachaf> Slides are good.
00:54:29 <edwardk> but you miss by vibrant commentary that way ;)
00:54:32 <edwardk> er my
00:54:41 <shachaf> (Though slideshare.net...)
00:54:43 <shachaf> True!
00:54:48 <shachaf> You should come do the talk in CA.
00:54:53 <edwardk> heh
00:54:55 <edwardk> well
00:55:05 <edwardk> i'm planning on giving a lens talk at hac phi
00:55:22 <edwardk> maybe when i wander down for gsoc, i can justify staying an extra day or so
00:56:00 <shachaf> Oct 19-21?
00:56:05 <edwardk> yeah
00:56:09 <shachaf> bahaskell will be on Oct 17
00:56:14 <edwardk> so it'd probably be the day before or after
00:56:23 <edwardk> ah
00:56:36 <shachaf> (Assuming no unusual schedule changes.)
00:56:41 <edwardk> *nods*
00:56:47 <edwardk> if it was the 18th it'd be an easy sell
00:56:52 <edwardk> ;)
00:57:13 <jfischoff> maybe we will have two
00:57:26 <edwardk> do you have a talk already scheduled?
00:57:44 <shachaf> Not that I know of.
00:57:47 <sopvop> Damn, the monoid instance for maybe in base is broken. Just "a" <> Just "b" should be Just "b" not Just "ab" by default, without Last wrapper. amirite?
00:58:02 <shachaf> You can email Ivan about it -- they're always happy to have speakers.
00:58:08 <jfischoff> shachaf: are we still meeting in sf?
00:58:12 <edwardk> sopvop: nope. it should lift a Semigroup
00:58:13 <edwardk> ;)
00:58:19 * shachaf is not a bahaskell expert!
00:58:23 <sopvop> And that also
00:58:26 <shachaf> jfischoff: It'd be either SF or Mountain View.
00:58:43 <edwardk> shachaf: i'll give you a hint, if it requires overt action on my part, it probably won't happen ;)
00:59:24 <shachaf> edwardk: Hah. I can mention it next time I talk to him. :-)
01:00:55 <sopvop> semigroup for maybe does the same as monoid :( I'm sure there is some law it satisfies, but It's not what I expected from maybe monoid anyway.
01:01:29 <edwardk> sopvop: the semigroup for maybe does the same as the monoid because it has to be compatibl with the monoid
01:02:04 <mikeplus64> > Just 4 <> Just 5
01:02:05 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
01:02:05 <lambdabot>         agains...
01:02:11 <mikeplus64> > Just 4 `mappend` Just 5
01:02:12 <lambdabot>   Ambiguous type variable `t' in the constraints:
01:02:13 <lambdabot>    `Data.Monoid.Monoid t'
01:02:13 <lambdabot>  ...
01:02:33 <sopvop> >Just [1,2,3] `mappend` Just [4,5,6]
01:02:40 <ddarius> instance Semigroup a => Monoid (Maybe a)
01:02:46 <edwardk> the monoid instance for Maybe should be instance Semigroup a => Monoid (Maybe a) where mempty = Nothing, mappend (Just a) (Just b) = Just (a <> b); mappend Nothing Nothing = Nothing; mappend (Just a) _ = Just a; mappend _ (Just b) = Just b
01:03:05 <edwardk> the current version pretends to be that, but requires Monoid instead
01:03:20 <edwardk> so the only way to use it is to make up a 'fake' Monoid
01:03:30 <edwardk> and just let your mempty = undefined
01:03:34 <edwardk> which is pretty horrible
01:03:42 <mikeplus64> > Just (Product 4) `mappend` Just (Product 5)
01:03:43 <lambdabot>   Just (Product {getProduct = 20})
01:04:22 <ddarius> Which I guess means we should make a generalization of free-functors so we can have the free monoid from a semigroup.
01:04:39 <edwardk> sadly semigroup support will just never happen
01:04:42 <edwardk> i've given up
01:04:57 <sopvop> there should be library function like mappendOnLast, so I don't have to define it in every project.
01:05:04 <ddarius> You always have scalaz.
01:05:12 <mikeplus64> sopvop: >> ;)
01:05:17 <xkb> hi
01:05:38 <mikeplus64> > Just "a" >> Just "b"
01:05:38 <sopvop> > Just 1 >> Nothing
01:05:39 <lambdabot>   Just "b"
01:05:40 <lambdabot>   can't find file: L.hs
01:06:27 <sopvop> > Just "a" >> Nothing -- try again
01:06:28 <lambdabot>   Nothing
01:06:31 <ddarius> mikeplus64: Nothing is a zero not a unit for that.
01:06:42 <sopvop> And it should me Just "a", so no worki
01:06:44 <mikeplus64> my bad
01:06:57 <ddarius> > let (<>) = flip (<|>) in Just "a" <> Just "b"
01:06:59 <lambdabot>   Just "b"
01:07:05 <ddarius> > let (<>) = flip (<|>) in Just "a" <> Nothing
01:07:07 <lambdabot>   Just "a"
01:07:14 <sopvop> Just "a" `mplus` Nothing
01:07:45 <xkb> When I try to load a haskell file in emacs using C-c C-l it barfs on imports, whereas :l in a normal ghci works just fine. Any idea what's causing this?
01:08:05 <sopvop> > Just "a" `mplus` Nothing
01:08:07 <lambdabot>   Just "a"
01:08:10 <Ralith> xkb: cwd
01:08:18 <sopvop> > Just "a" `mplus` Just "b"
01:08:19 <lambdabot>   Just "a"
01:08:29 <xkb> Ralith: cad as in :cd ?
01:08:33 <xkb> cwd*
01:08:37 <Ralith> yep
01:08:42 <xkb> I tried that
01:09:10 <Ralith> emacs calls :cd on load
01:15:09 <yitz> > let (<>) = mappend in getFirst $ First (Just "a") <> First (Just "b")
01:15:10 <lambdabot>   Just "a"
01:15:10 <yitz> > let (<>) = mappend in getLast $ Last (Just "a") <> Last (Just "b")
01:15:11 <lambdabot>   Just "b"
01:20:53 <solrize> :info Semigroup
01:21:33 <sopvop> > getLast $ (mappend `on` Last) (Just "a") (Just "b") -- like that
01:21:35 <lambdabot>   Just "b"
01:23:49 <xkb> how does emacs find gchi?
01:25:19 <sopvop> it finds it in $PATH, and in haskell-mode you can customize it to point to ghci you want
01:27:49 <xkb> aha
01:27:53 <xkb> I found out the problem
01:28:11 <xkb> there's a #if_ __GLAS… there
01:28:25 <xkb> emacs ghci integration chokes on this
01:29:20 <yitz> > getLast . mconcat . map Last $ [Just "a". Just "b", Just "c"] -- or like this
01:29:22 <lambdabot>   Couldn't match expected type `a1 -> a'
01:29:22 <lambdabot>         against inferred type `Data....
01:29:54 <xkb> yitz: there's a . there?
01:29:58 <xkb> instead of a ,
01:30:01 <xkb> in the list
01:30:10 <yitz> ah thanks
01:30:15 <yitz> > getLast . mconcat . map Last $ [Just "a", Just "b", Just "c"] -- or like this
01:30:17 <lambdabot>   Just "c"
01:30:21 <xkb> :)
01:31:10 <yitz> lambdabot hid part of the error message. and i guess there was a spot on my glasses.
01:31:59 <shachaf> > ala Last Data.Foldable.foldMap [Just "a", Just "b", Just "c"]
01:32:00 <lambdabot>   Just "c"
01:32:58 <mikeplus64> :t ala
01:32:59 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
01:33:29 <t7> @hoogle Newtype
01:33:29 <lambdabot> keyword newtype
01:33:29 <lambdabot> package newtype
01:33:29 <lambdabot> package newtype-th
01:33:35 <sopvop> I also want a Foldable for (a,a,a,a...,a) :)
01:34:19 <mikeplus64> sopvop: maybe a bit of TH hackery is in order
01:35:09 <shachaf> Or maybe that's a terrible thing to want. :-(
01:35:11 <sopvop> Actually i need only up to 6 a's, so It can be done by hand, but I guess there is a reason why this is not in base
01:36:11 <sopvop> also such zip so (a,a,a) (b,b,b) -> [(a,b), (a,b), (a,b)] :)
01:37:37 <frerich> Just to make sure I'm not off - in something like '(>>=) :: m a -> (a -> m b) -> m b', the "outer" type ("m" in this case) is the same everywhere but the "inner" type may (but doesn't have to) be different, right?
01:38:02 <srhb> frerich: Yes
01:38:03 <shachaf> What's the "inner" type?
01:38:14 <frerich> shachaf: "a" and "b"
01:38:16 <srhb> frerich: Any letter that is the same throughout the type is the same type
01:38:23 <shachaf> Yes, "a" is not the same as "b".
01:38:31 <srhb> frerich: Different letters that are not constrained may or may not be equal
01:38:43 <frerich> shachaf: Yes but that doesn't mean that they *have* to be different, I mean.
01:38:44 <shachaf> This is no different from concatMap:
01:38:46 <shachaf> @ty concatMap
01:38:48 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
01:38:57 <srhb> frerich: Indeed, a could be equal to b.
01:39:00 <shachaf> frerich: Yes, the caller gets to choose what "a" and "b" are.
01:39:09 <shachaf> The callee can't make any assumptions about them.
01:40:12 <frerich> Ok, thanks for the confirmation -that's what I thought. Just every now and then I get a little shaky and wonder whether I understood it right... :-]
01:40:35 <t7> how does unification work with type classes
01:40:48 <t7> thih is a bloated piece of poo
01:40:55 <shachaf> frerich: I recommend using simpler types than (>>=)'s to figure this sort of thing out, though.
01:41:19 <shachaf> The way unification and polymorphism work is very fundamental to Haskell even for much more concrete functions.
01:41:58 <t7> i can understand hindley milner type inference
01:42:17 <t7> but no one has written a basic paper on extending to type classes
01:42:46 <t7> the one by wadler (?) wasnt so helpful last time i read it
01:43:15 <Botje> you mean typing haskell in haskell?
01:44:02 <quicksilver> for the most part type classes are a separate accumulation
01:44:15 <quicksilver> you just collection constraints as you unify
01:44:23 <quicksilver> but you never *do* anything with the constraints
01:44:33 <quicksilver> in particular, the constraints don't themselves inform the inference.
01:44:50 <quicksilver> (there are some rules for simplifying the constraints themselves, though)
01:45:02 <silver> t7, have you seen this https://personal.cis.strath.ac.uk/adam.gundry/pattern-unify/ ?
01:45:33 <silver> oh sorry
01:45:37 <silver> I missread
01:45:54 <silver> nvm
01:46:15 <ksf> time reports a user/wall time of 18.65 seconds, profiling output 11.63 seconds. I can't really believe there's 7 seconds profiling overhead, so what could it be?
01:46:52 <t7> quicksilver: ah
01:47:16 <t7> so just accumulate them ?
01:47:28 <quicksilver> there is some kind of erasure property like "if you removed all the constraints, you'd have a valid H-M inference" but I'm not sure it's *quite* that simple.
01:47:29 <t7> and them at some point check the lower bounds or something
01:49:16 <mysticc> I was reading the fusion in Text .. It mentioned that if you choose a substring from a large string (text) then the large string will not be garbage collected until substring is used .. is it still valid?
01:50:03 <shachaf> mysticc: Yes.
01:50:19 <shachaf> Er, used?
01:50:31 <mysticc> shachaf: I meant in scope ..
01:50:33 <ksf> ...and can't ghc bloody annotate the SCCs of derived instances with their type name?
01:50:59 <shachaf> mysticc: Do you mean the opposite?
01:51:01 <mysticc> shachaf: What happened to his approach of using some thing like finger trees to solve the problem
01:51:22 <shachaf> The substring just has a reference to the entire allocated block of memory.
01:51:27 <mysticc> shachaf: I think both ways is true ?
01:55:28 <mysticc> shachaf: to quote harper "A very small substring may keep a much larger string from
01:55:35 <mysticc> garbage collection."
01:57:04 <ion> sharcharper
01:58:10 <mysticc> We wish to investigate the possibility of using another data structure for the underlying representation of Text. A possible candidate is to use finger trees of arrays to create a fusible rope . This would make the library better suited to manipulating and building strings.
01:58:21 <quicksilver> mysticc: if it's lazy text
01:58:31 <quicksilver> mysticc: then the substring will only keep the chunks it touches in memory
01:58:40 <quicksilver> and there is an operation to force copy
01:58:50 <quicksilver> but it's normally what you want. Less copying, better sharing.
01:59:14 <edwardk> mysticc: lots of us have tried such text variants, sadly the performance hasn't paid off for them for the most part
01:59:25 <edwardk> keep in mind the overhead for every individual text fragment is pretty high
01:59:53 <mysticc> edwardk, quicksilver : thanks
01:59:55 <edwardk> ropes of strict text fragments aren't that bad (i use ropes of bytestrings a lot myself)
02:00:41 <edwardk> and the overhead of pinning down lots of arrays to fiddle with its contents tends to overwhelm the benefits of breaking up the text into small fragments
02:01:11 <mysticc> edwardk: ropes of bytestrings .. where ?
02:01:37 <shachaf> edwardk: Did the UTF8 Text not work out at all, by the way?
02:01:39 <shachaf> (Was that you?)
02:01:42 <quicksilver> edwardk: for building from tiny parts, don't you want a rope together with some magical auto-coalescing threshold?
02:01:47 <edwardk> mysticc: mysticc: keep in mind Text has a
02:01:58 <edwardk> http://hackage.haskell.org/packages/archive/trifecta/0.53/doc/html/Text-Trifecta-Rope.html
02:02:13 <edwardk> shachaf: i was the mentor jasper was the student
02:02:19 <shachaf> Right.
02:02:24 <edwardk> i also came in mentioning a bunch of my rope side-projects
02:02:31 <edwardk> we mostly focused on doing utf-8 right though
02:02:42 <shachaf> And what did the result end up being?
02:02:44 <edwardk> and in the end utf-8 was slightly faster for… encoding/decoding to utf8
02:02:51 <shachaf> And slower for other things?
02:02:54 <edwardk> and a lot slower for everything else
02:02:59 <shachaf> That's weird.
02:03:00 <edwardk> even with his performance tweaks
02:03:09 <edwardk> some of the performance tweaks found their way back in
02:03:11 <shachaf> Even for <128-only text?
02:03:14 <edwardk> yep
02:03:28 <shachaf> Any idea why?
02:03:30 <t7> i cant thih re-implements the state monad... who on earth thought that would be helpful
02:03:35 <edwardk> the 4 way branch was big enough that it just stalled a lot or something
02:03:51 <shachaf> Hmm.
02:03:56 <shachaf> What about using half the memory? :-)
02:04:06 <edwardk> shachaf: its not that big a deal in practice
02:04:17 <edwardk> the startup overhead is so high
02:04:25 <edwardk> its like 70 bytes or something before you store anything
02:04:29 <edwardk> so it takes a lot to break even
02:04:32 <shachaf> That's sad, though.
02:04:46 <shachaf> I like UTF-8 better on principle. :-)
02:04:55 <edwardk> also, the thing that nixed it in the end is that the bindings to 3rd party libraries all die
02:05:10 <shachaf> UTF-16 seems like a "worst of all worlds" encoding for the most part.
02:05:17 <edwardk> utf-8 is great if you are in unix reading and writing to a terminal in utf-8 and its kinda meh overall when talking to libraries
02:05:19 <edwardk> yep
02:05:37 <edwardk> i've actually considered doubling down and writing a ucs4 text variant ;)
02:05:47 <edwardk> just to get fixed sized stepping for all code points
02:06:13 <edwardk> trifecta just used ropes of bytestrings encoded in utf-8 with special logic for the common all < 128 case
02:06:17 * shachaf wonders whether anyone uses UCS-3
02:06:33 <edwardk> well
02:06:40 <edwardk> if you pack them as 21 bits
02:06:45 <edwardk> you can fit 3 in 64 bits
02:06:50 <edwardk> thats better ;)
02:07:09 <edwardk> so if you're going to do ucs-3 do 3-in-64 ;)
02:07:10 <shachaf> But bit-packing is much more of a hassle than using three bytes.
02:07:17 <ion> And you have one bit left for… sign?
02:07:20 <shachaf> Well, maybe not that much more.
02:07:23 <shachaf> ion: Direction!
02:07:30 <shachaf> A new approach to RTL text.
02:07:57 <ion> You get to set the direction with a granularity of three codepoints!
02:08:04 <edwardk> well, the bytepacking takes you off alignment
02:08:07 <hpaste> sopvop pasted “Is this good Idea?” at http://hpaste.org/72335
02:08:09 <edwardk> this keeps alignment
02:08:13 <shachaf> True.
02:08:20 <edwardk> and who cares what you do once you get it into a register thee days
02:08:21 <ion> sopvop: No.
02:08:23 <ion> (Now to open the link)
02:08:28 <sopvop> :)
02:08:38 <shachaf> I guess that's a point.
02:09:39 <shachaf> UCS-2.625
02:09:46 <ion> UCS-e
02:09:50 <edwardk> shachaf: i love it
02:10:10 <edwardk> i've actually wanted to fiddle with that format, but never bothered
02:12:49 <sopvop> How to get from ghc same suggestions as hpaste prints? some kind of -flint flag?
02:12:53 <shachaf> edwardk: That'll definitely be great for "interoperability with any other library"!
02:12:59 <shachaf> sopvop: cabal install hlint
02:13:01 <edwardk> yep!
02:13:22 <shachaf> Is Text all set up for experimenting with other representations easily?
02:13:43 <edwardk> no
02:13:43 <shachaf> That would be a nice result of the SoC project. :-)
02:13:45 <edwardk> not at all
02:13:51 <shachaf> Aw.
02:14:13 <latro`a> is there a program that will *apply* those same suggestions?
02:14:21 <edwardk> one of the things i was wanting to try was swapping back to the rep used by bytestring more or less
02:14:34 <edwardk> because then you don't have to copy all the memory to ffi with it
02:14:51 <edwardk> its kinda sad that Data.Text copies memory like 3 times when it calls text-iconv
02:14:55 <shachaf> Text is different from ByteString?
02:15:00 <edwardk> yes
02:15:05 <edwardk> Text uses Array#
02:15:09 <shachaf> I thought it was pretty much the same thing internally with a Char interface.
02:15:11 <shachaf> Oh.
02:15:13 <edwardk> ByteString sits on a mallocForeignPtr
02:15:23 <shachaf> Why?
02:15:37 <edwardk> the former gets seen by the gc better and puts better pressure on the RTS or something
02:15:42 <edwardk> the latter came first
02:15:51 <edwardk> but also you can pin a byte array
02:15:54 <edwardk> so they ffi nicer
02:16:32 <edwardk> its an interesting dichotomy
02:17:06 <edwardk> i wanted to experiment with the foreignptr model for array, but it is effectlvely a _complete_ rewrite of text
02:17:16 <edwardk> er for text i mean
02:20:50 <shachaf> Is all the code for Jasper's thing available?
02:21:08 <shachaf> Low overhead for trying things out ought to be a design goal for most things. :-(
02:22:57 <edwardk> well, it isn't really a viable option in the case of text
02:23:04 <edwardk> i mean that would be the project in its own right
02:23:27 <edwardk> the foreignptr model used by bytestring was in part eschewed by text because it is so invasive and awful
02:23:48 <edwardk> so rewriting everything to use it would be a big change
02:23:58 <edwardk> i burned out on my try
02:39:53 <hpaste> mbuf pasted “How to convert IO String to String?” at http://hpaste.org/72336
02:40:12 <shachaf> mbuf: See the FAQ:
02:40:13 <shachaf> @where faq
02:40:14 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
02:40:30 <shachaf> The short answer is main = do { a <- readProcess "date" [] []; putStrLn a }
02:40:44 <shachaf> Well, the really short answer is "you don't".
02:40:54 <shachaf> And you should read about how I/O works in Haskell. :-)
02:42:12 <mbuf> shachaf: if I want to do some processing on the returned output 'a', how do I do that?
02:42:23 <quicksilver> you can do whatver you want
02:42:28 <quicksilver> 'a' is just a String now
02:42:36 <quicksilver> so you can do anythung you would normally do with a string
02:42:39 <mbuf> quicksilver: I see
02:42:54 <mbuf> quicksilver: it is just that main has type IO ()
02:43:03 <shachaf> mbuf: You can't convert IO String to String because IO String doesn't contain a String. It's just a recipe for getting one.
02:43:06 <shachaf> @quote /bin/ls
02:43:07 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
02:47:19 <quicksilver> mbuf: yes, indeed.
02:47:27 <quicksilver> mbuf: but you're still writing expressions.
02:47:55 <quicksilver> mbuf: for example, you might write : putStrLn ("The length of " ++ a ++ " is " ++ show (length a) ++ ", isn't it?")
02:48:30 <shachaf> mbuf: (By the way, if all you want to do is get the current date, running the command "date" is probably a bad way to do it.)
02:59:28 <simon_> simon, danr and everyone else that helped me yesterday, thanks to you my brainfuck compiler now works for programs that only do output and no input. if anyone want to see/comment the code its here: https://github.com/Norberg/brainfuck-haskell/blob/master/compiler.hs
03:00:59 <shachaf> I think separating that into "generating some sort of ADT" and "converting that ADT to a string" steps would make that code a lot clearer.
03:05:59 <simon_> shachaf: yes, i think you are correct, i will try to clean it up after implementing support for input
03:06:08 <t7> is blah-able a bad naming convertion for classes?
03:06:16 <t7> convention *
03:06:23 <shachaf> simon_: An intermediate representation also makes it much easier to do optimizations. :-)
03:08:06 <simon_> shachaf: since i use llvm as backend i get most of the opimizations for free
03:08:26 <mcstar> he meant human optimization
03:08:26 <shachaf> Not really...
03:08:40 <mcstar> llvm wont change the algorithm
03:08:45 <shachaf> mcstar: What?
03:08:58 <mcstar> yes
03:11:29 <absence> mm_freak: lmap complains that Wire doesn't have a Profunctor instance, but ^>> (or <<^) does the trick for now, even if the operator precedence is inconvenient when using Category
03:12:28 <simon_> mcstar: no, but neither could my compiler(or any compiler?), or what do you mean?
03:12:50 <mcstar> you could
03:14:10 <simon_> mcstar: how?
03:14:51 <absence> mm_freak: the version 3 signatures of asSoonAs and while make the expression more long-winded than require, but (a -> Bool) would make it quite nice. i assume then i would just write "theEventWire . asSoonAs (>= t1) . while (< t2) . time"?
03:15:22 <mcstar> idk, you are writing the compiler, but it is certainly easier to comprehend the code, when you make a distinction between source tree compilation and printing/debugging
03:15:23 <absence> mm_freak: "more long-winded than using require" i meant to say
03:15:36 <mcstar> whatever those many printfs are about
03:17:36 <mcstar> wait, are those llvm instructions?
03:18:32 <simon_> mcstar: yes its llvm instructions, i now the the compiler itself can be improved alot. i thought you ment the generated code
03:18:48 <mcstar> no, the haskell source
03:19:34 <simon_> ok, then i understand and agree with you
03:20:03 <absence> mm_freak: as for complaints, i don't think i have a firm enough grasp of frp to have any say :) sometimes the prefab wires don't do exactly what i want (like now), but it's hardly a problem to write my own once i understand the problem
03:20:25 <mcstar> also, you ask for the file to compile, but you hardcoded the output file, bit of an asymmetry
03:20:57 <simon_> mcstar: yes, its very much work in progress still
03:21:04 * mcstar would just read/write stdin/out wo opening files
03:22:06 <mcstar> and you could probably make some sort of dsl from the llvm intructions
03:22:17 <mcstar> you could chain those together wo mentioning strings
03:22:46 <mcstar> shachaf: is that what you meant? ^^
03:23:34 <simon_> mcstar: yes, i will try to do that
03:24:47 <shachaf> mcstar: I have no idea.
03:56:14 * morel wished there was a perfect editor.
03:56:41 <ion> ed
03:58:23 <morel> yep, sometimes i think i don't need all those features, sometimes i think i need more features. i dont know.
03:59:56 <t7> ghci isnt reading my {-# LANGUAGE TypeSynonymInstances #-}
04:00:31 <mertsas> does anyone know if haskell-platform is arm friendly?
04:01:38 <morel> mertsas: AFAIK, there's no GHCI for ARM yet. but that *might* have changed recently.
04:01:45 <morel> lemme look up.
04:01:53 <mertsas> ok
04:02:52 <t7> grrr why is ghc ignoring my pragma :(
04:03:01 <t7> oh it goes before module
04:03:12 <morel> mertsas: so, yes, according to http://hackage.haskell.org/trac/ghc/wiki/Platforms there's no ghcI for ARM.
04:03:21 <morel> t7: hehehe
04:03:53 <morel> mertsas: but people are working on it, afaik.
04:04:20 <mertsas> morel: ok, would it be possible to make a ghc cross compiler though? I don't need to compile on the arm itself, as long as I have executables that runs on arm
04:04:25 <mertsas> morel: ok, good to hear:D
04:04:45 <morel> mertsas: you CAN compile on arm.
04:04:50 <morel> there's just no interpreter!
04:05:15 <morel> mertsas: GHC works. GHCi doesn't.
04:05:34 <mertsas> ok, cool
04:06:40 <bitonic> morel: I think ghci works now
04:07:02 <mertsas> bitonic: in the latest haskell-platform package?
04:07:31 <bitonic> mertsas: I'm not sure, but I seem to recall that there were recent developments on that front.
04:07:59 <bitonic> so you might want to take a look.  maybe the changes were in GHC head, I don't know.
04:08:28 <mertsas> ok. thanks
04:09:14 <mertsas> is it possible to turn of demands on OpenGL for haskell-platform btw? not going to be used with opengl, so don't want to add glut just to get haskell-platform working
04:10:50 <bitonic> mertsas: you can install GHC and the packages manually.
04:11:42 <mertsas> bitonic: are you talking precompiled stuff?
04:12:01 <bitonic> mertsas: what?
04:12:50 <mertsas> installing precompiled stuff, or are you talking about first installing ghc, and then the packages we need on the side. Without using haskell-platform
04:13:34 <donri> hm didn't we get ghci for arm in some recent release
04:14:40 <donri> perhaps not
04:16:24 <bitonic> mertsas: the latter
04:16:35 <mertsas> bitonic: ok, thanks. I'll try that then
04:16:38 <t7> @pl \s fs -> free s `Set.union` fs
04:16:38 <lambdabot> (line 1, column 17):
04:16:38 <lambdabot> unexpected "`"
04:16:38 <lambdabot> expecting variable, "(", operator or end of input
04:16:54 <t7> @pl \s fs = free s `Set.union` fs
04:16:54 <lambdabot> (line 1, column 7):
04:16:54 <lambdabot> unexpected "="
04:16:54 <lambdabot> expecting pattern or "->"
04:17:02 <t7> @pl fudge s fs = free s `Set.union` fs
04:17:02 <lambdabot> (line 1, column 21):
04:17:02 <lambdabot> unexpected "`"
04:17:02 <lambdabot> expecting variable, "(", operator or end of input
04:17:05 <Botje> @pl \s fs -> free s `union` fs
04:17:06 <lambdabot> union . free
04:17:21 <t7> @pl \foo s fs = foo s `Set.union` fs
04:17:22 <lambdabot> (line 1, column 11):
04:17:22 <lambdabot> unexpected "="
04:17:22 <lambdabot> expecting pattern or "->"
04:17:28 <t7> @pl \foo s fs -> foo s `Set.union` fs
04:17:28 <lambdabot> (line 1, column 20):
04:17:28 <lambdabot> unexpected "`"
04:17:28 <lambdabot> expecting variable, "(", operator or end of input
04:17:30 <Botje> t7: @pl's parser kind of sucks.
04:17:36 <Botje> t7: it's complaining about Set.union.
04:17:41 <t7> ah
04:17:41 <Botje> 13:16 < Botje> @pl \s fs -> free s `union` fs
04:17:41 <Botje> 13:16 < lambdabot> union . free
04:17:52 <t7> i will pm
04:22:19 <mcstar> too bad, that partially applied prefix-made-infix operators are not possible
04:22:24 <ghorn> is it expected behavior that using -XTemplateHaskell suppresses "Defined but not used" warnings with -Wall?
04:22:36 <mcstar> like: 1 `ifF True` 2
04:31:21 <merijn> mcstar: wat? why wouldn't they be?
04:31:34 <merijn> > let foo = (`elem` [1..10]) in foo 2
04:31:36 <lambdabot>   True
04:31:49 <merijn> ah
04:32:08 <merijn> mcstar: If you want that, why not use where/let to give them a name
04:32:27 <mcstar> merijn: thats a workaround
04:32:36 <mcstar> maybe it woldnt be very useful, idk
04:32:39 <t7> @Hoogle Map a (m b) -> m (Map a b)
04:32:39 <lambdabot> Maybe you meant: google hoogle
04:32:42 <mcstar> just thought about it
04:32:43 <t7> @hoogle Map a (m b) -> m (Map a b)
04:32:44 <lambdabot> No results found
04:32:47 <t7> :(
04:33:04 <merijn> t7: go through fromList toList?
04:33:53 <merijn> "Map a (m b) -> [(a, m b)]", then "[(a, m b)] -> m [(a,b]", then "m [(a, b)] -> m (Map a b)"?
04:34:42 <quicksilver> isn't that traverse, t7?
04:34:43 <mcstar> merijn: it wouldnt work with 'where' since it cant capture in general, the value im partially trying to apply my function
04:34:56 <merijn> The first one already exists, the second one is a bit annoying, but I wrote it several times and the latter is trivial again
04:35:10 <merijn> mcstar: Why not?
04:35:17 <quicksilver> well Data.Traversable.sequenceA
04:35:19 <fmap> looks more like sequenceA than traverse
04:36:18 <mcstar> > let tf = True in let (<%>) a b = if tf then a else b in 1 <%> 2
04:36:19 <lambdabot>   1
04:36:22 <mcstar> this works
04:36:33 <mcstar> but i dont see how you would do that with 'where'
04:36:39 <merijn> t7: Oh, I did the middle one with: "\(a,b) -> liftM (a,) b" (requires TupleSections)
04:37:24 <merijn> mcstar: where tf = True; (<%>) a b = if tf then a else b?
04:37:42 <merijn> mcstar: All definitions in a where clause are in scope of the other where clauses
04:38:35 <mcstar> thats not good
04:38:54 <mcstar> then you will have a <%> operator that is specialized on a give trut value
04:38:55 <mcstar> truth*
04:39:19 <mcstar> what i wrote can be used 'inline'
04:39:33 <mertsas> is there any way to compile ghc without ghc being previously installed?
04:39:41 <mcstar> wo the first let, and just putting the requierd truth value into the definition of <%>
04:39:46 <mcstar> which again, is cumbersome
04:40:17 <merijn> mertsas: You can bootstrap using a very old haskell compiler written in C to compile and old GHC and then iteratively build newer GHC versions, I think
04:40:17 <mcstar> but if you could make infix operators from partially applied prefix ones, the problem would be solved
04:40:30 <merijn> mertsas: Or you could just install a binary GHC
04:40:45 <merijn> I don't think cross-compiling is an option yet
04:40:56 <t7> Data.Traversable has mapM :)
04:41:51 <mertsas> merijn: thing is, I wan't to be able to compile haskell in openembedded, without forcing every developer to have ghc installed. So the thought was something like the first, and compile a minimal ghc with gcc, and then use that to build the rest
04:42:08 <mertsas> probably not working in 7.4.1 though
04:47:57 <mm_freak> absence: ok, apparently i didn't write Profunctor instances in 3.1.0…  i had the instance in the never released 3.1.1
04:48:01 <t7> @pl get >>= \fv -> modify succ >> return fv
04:48:01 <lambdabot> (modify succ >>) . return =<< get
04:49:00 <t7> why dont i have Map.fromSet ?
04:49:46 <t7> is it safe to install version 5 of containers?
04:49:52 <t7> (using haskell platform)
04:51:09 <mm_freak> t7: how would you convert a Set to a Map?
04:51:23 <mm_freak> Set a -> Map a Bool?
04:51:24 <t7> with Map.fromSet
04:51:39 <t7> (a -> b) -> Set a -> Map a b
04:51:54 <mm_freak> i see
04:56:30 <t7> Traversable.sequence $ Map.fromList $ map (, fresh) (Set.toList b)  -- :(
04:56:58 <t7> Traversable.sequence $ Map.fromSet (, fresh) b -- :)
04:57:17 <mun> hi
04:59:05 <mun> when writing a paper, would the following notation/representation for expressing overloading? EX T, T', T'' :: Types, P :: T => bool, c :: T. P(c::T') & ~P(c::T'')
04:59:42 <mun> i just want to say that P is a ad-hoc polyrmorphic predicate, which is true if its argument is of type T' and false if it's of type T''
05:00:24 <cheater> hi
05:00:40 <mm_freak> t7: see Data.Map.fromDistinctAscList
05:00:50 <cheater> has anyone here used gitit? is it possible to use an existing repo as the backend?
05:00:59 <jrajav> Heya. I'm getting really interested in functional programming, so I thought this wouldn't be a terrible place to hang out for a while :)
05:01:24 <jrajav> Just one question for now: Is there a concise, mostly-agreed-upon definition? Is it really *just* referential transparency?
05:01:39 <cheater> is it a good idea to use the repo for my project to also host the gitit?
05:02:10 <deggis> anyone with experiences using eclipsefp with cabal-dev (using sandboxes)?
05:02:38 <mm_freak> jrajav: composition instead of sequencing, data structures with morphisms instead of loops, etc…  but there really isn't a mostly-agreed-upon definition
05:02:47 <mm_freak> jrajav: in any case, welcome to the world of haskell =)
05:03:15 <t7> mm_freak: whats the advantage?
05:03:28 <mm_freak> t7: of what?  fromDistinctAscList?
05:03:29 <hiptobecubic> jrajav, "functions"
05:03:33 <t7> yeah
05:03:38 <jrajav> hiptobecubic: … Thanks
05:03:44 <mm_freak> t7: O(n) instead of O(n * log n)?
05:03:49 <t7> ah ok
05:04:03 <hiptobecubic> jrajav, at least i didn't say 'monads'
05:04:06 <jrajav> mm_freak: Couldn't it be argued that most of those constructs are consequences of avoiding mutable state, etc.?
05:04:09 <mm_freak> t7: if you know the list is sorted, you can generate a Set from it more quickly
05:04:26 <hiptobecubic> jrajav, absolutely. although the consensus is that you are looking at it backwards
05:04:27 <mm_freak> jrajav: yes, totally
05:04:45 <mm_freak> jrajav: but a better way to say it:  they require referential transparency
05:04:51 <jrajav> Ah
05:05:20 <mm_freak> jrajav: but it would be unfair to claim that scheme is not a "functional language", so you really should mention these explicitly
05:05:46 <mm_freak> i think haskell just takes it more seriously =)
05:05:56 <hiptobecubic> that's my impression as well
05:06:38 <jrajav> Man. I majored in pure mathematics for 2 1/2 years and it's still taken me a week or so to start wrapping my head around this
05:06:38 <hiptobecubic> although i appreciate it, because you can't get it anywhere else really. at least not anywhere that's usable day to day
05:07:15 <mm_freak> jrajav: what language did you program in before?
05:07:15 <hiptobecubic> jrajav, nonsense. Everything you did in that entire time was based on the same premises.
05:07:30 <jrajav> mm_freak: Quite a few
05:07:35 <mm_freak> jrajav: name your favorite
05:07:41 <jrajav> mm_freak: Tough :P
05:07:47 <jrajav> RIght now, probably Javascript
05:08:06 <hiptobecubic> that's not even that bad
05:08:12 <jrajav> I know!
05:08:21 <mm_freak> jrajav: i see…  likely your competence in that language stands in your way right now…  your math background should actually come as an advantage =)
05:08:22 <jrajav> Back in the day, when I was 11 or so, I started on C and C++
05:08:40 <jrajav> I've taken C++, Java, and Scheme classes in school
05:08:54 <mm_freak> jrajav: my experience is that non-programmers have a much easier time learning haskell
05:09:01 <jrajav> I've worked in tons of languages as a hobby, and the aforementioned plus C# professionally
05:09:02 <mm_freak> not just a little easier, but /much/ easier
05:09:10 <jrajav> I don't doubt it
05:09:12 <hiptobecubic> jrajav, so far for me, the trick to haskell has been to write the program on paper first as just a math-style definition of the answer i want
05:09:23 <jrajav> That sounds pretty tedious
05:09:28 <hiptobecubic> and keep recursively doing that until magically all my functions appear at the end
05:09:33 <aristid> mm_freak: non-programmers with a mathematical background?
05:10:07 <mm_freak> aristid: nope, in general
05:10:15 <mm_freak> jrajav, aristid:  http://article.gmane.org/gmane.comp.lang.haskell.beginners/9877
05:10:21 <mm_freak> this is my experience
05:10:43 <hiptobecubic> jrajav, it's much better than it sounds. you just have to get used to just demanding what you want from the program, rather than which bits it should be flipping
05:10:45 <jrajav> Okay, right off the bat, he's comparing it to learning C++
05:10:47 <jrajav> That's unfair :P
05:10:55 <jrajav> C++ is terrible for anything, and most especially for learning
05:11:05 <hiptobecubic> jrajav, :D i like you
05:11:12 <jrajav> heh
05:11:12 <mm_freak> jrajav: C++ is an imperative language…  probably as imperative as you can get
05:11:29 <mm_freak> hiptobecubic: that never worked for me…  my best bet was to write real programs
05:11:42 <ParahSailin> 'checking version of ghc... 6.8.3 \\ configure: error: GHC version 6.12 or later is required to compile GHC.'
05:11:43 <mm_freak> jrajav: "he" is me =)
05:11:46 <ParahSailin> fail
05:11:53 <jrajav> Oh ahha
05:12:00 <mm_freak> ParahSailin: GHC 6.8 is about from the stone age =)
05:12:09 <ParahSailin> i have glibc 2.4
05:12:28 <mm_freak> we are at 7.4 now =)
05:12:32 <ParahSailin> was the newest ghc binary that supports stone age glibc
05:12:51 <ParahSailin> trying to build 7.4 using 6.8 bootstrap
05:13:00 <mm_freak> why would you build it yourself?
05:13:13 <hiptobecubic> mm_freak, they are real programs. But first you plan what will produce no? Or do you just open up a buffer and start pounding away? I never could do it that way, I always end up with a mess
05:13:27 <ParahSailin> easier to just install a local copy of glibc 2.7?
05:14:43 <ParahSailin> i cant exactly run the 7.4.2 binary ghc
05:15:04 <bitonic> mm_freak: I think your experience might be warped by the fact that non-programmers want to write little toy programs, while programmers want to write big, featureful things.
05:15:11 <mm_freak> hiptobecubic: i just open a buffer and start =)
05:15:40 <mm_freak> ParahSailin: not sure then, sorry
05:15:54 <hiptobecubic> i think little toy programs are the only ones that come out successful with no planning
05:16:09 <hiptobecubic> otherwise you end up rewriting things four times
05:17:05 <aristid> hiptobecubic: that's not a necessarily invalid approach
05:17:07 <mm_freak> bitonic: i don't think so…  programmers had problems with basic things…  nonprogrammers dealed with infinite data structures and laziness as if they were totally natural things to have in a programming language…  they built up the needed intuition easily
05:17:35 <mm_freak> ParahSailin: there is a GHC mailing list…  check out the homepage and better ask there
05:17:50 <bitonic> mm_freak: but those are not the real problems when you want to do Haskell.  programmers will understand those concepts as well.
05:17:58 <bitonic> maybe they'll be confused at first
05:18:07 <mun> when writing a paper, would the following notation/representation be appropriate for expressing overloading? EX T, T', T'' :: Types, P :: T => bool, c :: T. P(c::T') & ~P(c::T'') ?
05:18:40 <mm_freak> bitonic: they don't as easily as you might think…  it's my experience as a teacher in my haskell workshops
05:18:46 <mm_freak> not an opinion, but an experience
05:19:00 <jrajav> Keep in mind that programmer != that quick of a person
05:19:24 <hape01> > [1,2,3] >>= \x -> []
05:19:25 <lambdabot>   []
05:19:28 <hape01> > [1,2,3] >>= \x -> [x,x]
05:19:29 <lambdabot>   [1,1,2,2,3,3]
05:19:36 <bitonic> mm_freak: well I'm talking out of experience as well.  if they are programmers that have been doing some procedural programming for 15 years, then yes they might be a bit too used to thad
05:19:37 <bitonic> *that
05:19:45 <hape01> > [1,2,3] >>= \x -> [x | x<=2]
05:19:46 <lambdabot>   [1,2]
05:20:07 <jrajav> There are plenty of people who have never programmed or even gotten proficient with a computer who could easily pick up programming concepts, and there are (as we all know) many programmers who barely know how to program, too
05:20:38 <jrajav> I just taught my girlfriend Javascript over the weekend, and she was whizzing around with dynamic typing and first-class functions within the first hour
05:20:44 <mm_freak> bitonic: the advantage a programmer has is that they know how to help themselves…  they will search the internet, etc., but on the bottom line they always needed longer to learn the basics of haskell
05:21:16 <bitonic> mm_freak: I strongly disagree with the "always".  I think it's not even "often".  it's more a "sometimes".
05:21:49 <mm_freak> bitonic: it's "always" for me =)
05:21:54 <mm_freak> anyway, let's not argue about that
05:22:17 <bitonic> and I think most of the novices that learn to write Haskell one-liners would be helpless if they had to write "useful" programs
05:24:00 <hape01> why is this bottom? is it? [1..] >>= \x -> [x*2|x<=5] >>= \y -> [y]
05:24:11 <mauke> > [1..] >>= \x -> [x*2|x<=5] >>= \y -> [y]
05:24:14 <lambdabot>   mueval-core: Time limit exceeded
05:24:32 <mm_freak> bitonic: think of all the programmers asking here how to make a heterogenous list
05:24:33 <mauke> > take 1 $ [1..] >>= \x -> [x*2|x<=5] >>= \y -> [y]
05:24:34 <lambdabot>   [2]
05:24:42 <mauke> hape01: it's not bottom
05:24:44 <hape01> mauke :-)
05:24:48 <mm_freak> bitonic: they tend to write C++ in haskell
05:25:16 <mm_freak> it makes a real program, but it's not really written in haskell…  it just uses a C++ DSL in haskell =)
05:25:17 <bitonic> mm_freak: sure they have to readjust their habits.  and some programmers just like C++ or whatever better.
05:25:20 <hape01> mauke: It is not bottom, when you take 1 of it. without the take 1 is it bottom?
05:25:25 <mauke> hape01: no
05:25:30 <hape01> mauke: no?
05:25:31 * t7 googles heterogenous list
05:25:32 <mauke> that doesn't even make sense
05:25:43 <hape01> mauke: i have to think about this.
05:25:54 <bitonic> > take 20 $ [1..] >>= \x -> [x*2|x<=5] >>= \y -> [y]
05:25:58 <lambdabot>   mueval-core: Time limit exceeded
05:26:04 <t7> ah dirty python style
05:26:05 <mm_freak> t7: data X = forall a. (SomeClass a) => X a;  myHeteroList :: [X]
05:26:08 <mauke> it's 2 : 4 : 6 : 8 : 10 : _|_
05:26:11 <jrajav> Why do we still teach C++ in schools :(
05:26:11 <bitonic> mauke: yes.
05:26:26 <bitonic> it keeps searching for an x <= 5
05:26:32 <jrajav> If you really *have* to teach OOP at least do it with Ruby or Objective C
05:26:34 <t7> jrajav: writing C++ like C but with templates is ok
05:26:41 <t7> and containers etc
05:26:47 <ben> RAII :)))
05:26:48 <mauke> t7: [citation needed]
05:26:48 <bitonic> it's weird that lambdabot does not show the first 5 cells
05:26:51 <jrajav> Templates are horrible
05:26:54 <t7> and use interfaces
05:26:55 <hape01> mauke, bitonic: that means you call it bottom only if it return _!_ directly, 2:4:6:8:_!_ is not buttom
05:27:07 <bitonic> hape01: no, it's not
05:27:22 <mm_freak> it's bottom, if pattern-matching its outermost constructor is bottom
05:27:36 <ben> [tell] me how to write useful haskell programs that don't involve a c++ dsl
05:27:37 <mm_freak> otherwise it's more defined than bottom
05:27:56 <mm_freak> ben: depends on the program
05:28:14 <mm_freak> haskell doesn't follow the "everything is an X" fallacy
05:28:19 <mauke> ben: main = interact id
05:28:40 <t7> why is ghci so fucked in windows :(
05:28:40 <ben> they already wrote cat :(
05:28:45 <t7> only since 7.4
05:29:10 <mm_freak> language inventors seem to try to wrap everything in some sort of "the abstraction to rule them all", like python or ruby
05:29:16 <bitonic> t7: why are you using windows?
05:29:23 <t7> im at work
05:29:37 <Athas> mm_freak: Python is just a hash table with an embedded scripting language.  What's the abstraction in Ruby?
05:29:37 <bitonic> ah.  last time I checked GHC was OK on windows
05:29:44 <t7> ghci *
05:29:56 <mm_freak> Athas: "everything is an object"
05:30:11 <t7> if i write an expression longer than 80 chars in windows it crashes
05:30:23 <t7> but only if i edit it midline
05:30:26 <bitonic> t7: that sounds wrong.  report a bug
05:30:27 <mauke> using ghci or winghci?
05:30:30 <mm_freak> t7: if it's the latest GHC, then report a bug
05:30:44 <t7> you probly have to sign up
05:31:03 <morel> t7: if it's the latest GHC, and there's not already such a bug-report, then report a bug
05:31:19 <mm_freak> ok, could anyone expand that statement further? =P
05:31:24 <morel> :D
05:31:26 <t7> The Glorious Glasgow Haskell Compilation System, version 7.4.1
05:31:37 <bitonic> t7: that's not the last one
05:31:38 <mm_freak> Report A Bug 3.0
05:32:30 <ParahSailin> "everything is math"
05:33:30 <morel> ParahSailin: I am Morel Pisum. our nicks follow the same principle.
05:33:54 <morel> both are anagrams.
05:34:26 <qnikst> hm I have an array of pointer from ffi code (obj**) and I want somehow to use that list in pure code, I don't want to use ForeignPtr as for this task it's better when resource are managed by resourcet. Q: how is it better to deal with that array?
05:34:53 <mm_freak> qnikst: what do you want to do with that array?
05:35:04 <mauke> morel: mole purism?
05:35:11 <mauke> morel: spoiler mum?
05:35:15 <ParahSailin> pisum = peas in the latin?
05:35:16 <qnikst> mm_freak: use values from it in another FFI functions
05:35:22 <morel> mauke: Lorem Ipsum.
05:35:36 <mm_freak> qnikst: you can pass around that list in pure code just well, but you can't peek/poke
05:35:42 <morel> lorem ipsum dolor sit amet…
05:37:04 <mm_freak> qnikst: if the FFI library is inherently impure, but doesn't involve communicating with the world, then you can do what ST does
05:37:22 <mm_freak> withMyFFIArray :: (forall s. MyFFIMonad s a) -> a
05:37:38 <mm_freak> but it will involve some unsafePerformIO to implement it
05:37:40 <qnikst> hm.. will think about  it
05:37:49 <hape01> oops lambdabot won't install on windows.
05:38:53 <mm_freak> rather…
05:39:00 <qnikst> mm_freak: really I have a Ptr (Ptr Obj), or should I some how rewrite definition of FFI function?
05:39:07 <mm_freak> withMyFFIArray :: (forall s. MyFFIArray s Int -> MyFFIMonad s a) -> a
05:40:09 <qnikst> it seems that hiding array inside with will be a second step
05:40:29 <morel> hi augur =)
05:40:33 <mm_freak> qnikst: i'm assuming that you have an FFI library that mutates the array or its elements
05:40:37 <augur> morel: ?
05:40:51 <mm_freak> qnikst: in that case a good first step is to write a low level haskell interface involving IO
05:41:21 <mm_freak> then optinally wrap it up in a nicer ST-like interface, if possible
05:41:30 <qnikst> I see
05:41:34 <mm_freak> if not possible, go with the IO interface and convenience functions
05:42:03 <mm_freak> it's not possible, if the library changes the world
05:42:12 <qnikst> it seems possible but rather difficult
05:42:34 <mm_freak> write the low level interface first
05:42:42 <qnikst> thats what I'm doing
05:42:56 <mm_freak> make direct translations of the FFI functions, then you will have a much clearer picture
05:43:13 <qnikst> and I have obj** getCurrentRaw(size_t n); that will create array of n elements
05:43:54 <qnikst> so I've written foreign import ... :: CSize -> IO (Ptr (Ptr Obj)), is it correct?
05:43:55 <mm_freak> from what?
05:44:10 <mm_freak> that looks correct
05:44:40 <qnikst> ok, now I want to make more haskell like wrapper, and register that pointers in ResourceMonad
05:44:54 <qnikst> so I should somehow iterate over that array
05:45:14 <mm_freak> you're probably stuck with IO…  you can iterate over that array in IO
05:46:11 <mm_freak> you can convert the 'Ptr (Ptr Obj)' to 'Vector (Ptr Obj)' though
05:46:25 <mm_freak> also give 'Ptr Obj' a nicer name, like ObjHandle
05:46:45 <mm_freak> or even simply Obj as i assume that you never actually access the underlying structure implementing the Obj
05:46:58 <quicksilver> does Ptr (Ptr a) even work?
05:46:59 <mm_freak> type Obj = Ptr ObjStruct
05:47:10 <mm_freak> yeah, Ptr a could work as well
05:47:13 <qnikst> Vector is bad as it wants to have a ForeignPtr and use gc to kill resource
05:47:26 <quicksilver> because "Ptr a" isn't actually a C pointer - it's a haskell heap value which contains a C Pointer
05:47:28 <mm_freak> qnikst: no, Vector doesn't have any constraints on the elements
05:47:40 <quicksilver> so Ptr (Ptr a)... oh maybe it works because of the Ptr Storable instance?
05:47:43 * quicksilver has never tried.
05:47:53 <mm_freak> qnikst: you're probably thinking of Data.Vector.Storable
05:47:57 <mm_freak> but i'm thinking of Data.Vector
05:48:01 <qnikst> I loocked at unsafeFromForeignPtr0
05:48:11 <qnikst> from Vector.Storable
05:48:29 <mm_freak> i'd use Ptr Void, btw
05:48:38 <mm_freak> Ptr a could be a little inconvenient
05:49:32 <qnikst> ok
05:50:16 <mm_freak> another possibility if you don't mind RankNTypes:  type Obj = forall a. Ptr a
05:51:49 <qnikst> and what it will give? (sorry I'm not experienced haskell programmer)
05:52:23 <mm_freak> effectively it will require the pointer element type to always be fully polymorphic
05:52:58 <mm_freak> practically that ensures that there is no Storable instance you could use to peek/poke in haskell, unless you cheat by casting the Ptr
05:53:30 <qnikst> seems that I understand
05:55:01 <mm_freak> in any case the following seems to be the safest alternative:
05:55:05 <mm_freak> data ObjStruct
05:55:10 <mm_freak> type Obj = Ptr ObjStruct
05:55:29 <mm_freak> this will give you some type safety, if you use pointers from other libraries as well
05:56:02 <mm_freak> this is haskell 2010 with no extensions
05:56:35 <qnikst> seems I'm actually using such a way
05:56:54 <qnikst> but I don't think that it gives additional safety
05:57:01 <qnikst> don't thought
05:57:36 <mm_freak> it does:  when you allocate a new Ptr with a fully polymorphic element type, then you could pass that to the FFI interface using the RankNTypes solution
05:57:42 <mm_freak> with this one that's not possible
06:00:32 <qnikst> ok
06:01:32 <qnikst> I meant that I've write data Obj ; type PObj = Ptr Obj, but don't thought that it's good
06:01:34 <statusfailed> What's (>~) ?
06:02:10 <statusfailed> (from here: http://www.haskell.org/haskellwiki/Netwire)
06:02:27 <marcot> Hi.  I'm trying to install cabal-install-ghc74 using the cabal-install shipped with debian squeeze.  I'm using ghc-7.4.2.  The package fails to install with the following error:
06:02:34 <marcot> Distribution/Client/PackageIndex.hs:79:9:
06:02:34 <marcot>     Illegal datatype context (use -XDatatypeContexts): Package pkg =>
06:02:45 <mysticc> What is the feasability of a database implemented in haskell ..
06:03:18 <qnikst> mm_freak: next part of question =) so I'm getting Ptr ObjStruct from FFI, and peek/poke it in wrapper, and give resulting value to library users
06:03:20 <marcot> When I unpack the package at .cabal/packages/hackage.haskell.org/cabal-install-ghc74/0.10.4 and build it with ./Setup configure --user && ./Setup build, it works fine.
06:03:37 <marcot> Is it a problem with the old version of cabal-install?
06:03:59 <morel> statusfailed: mm_freak is the maker of netwire.
06:04:16 <mm_freak> statusfailed: it's a type variable
06:04:38 <mm_freak> statusfailed: usually it will be something like Kleisli m for a monad m
06:04:42 <statusfailed> oh, I didn't know you could name them that way :o
06:05:11 <morel> oh, cool, me neither.
06:05:27 <statusfailed> so >~ is the arrow type usually?
06:05:31 <mm_freak> statusfailed: yeah
06:05:54 <statusfailed> oh right, which Kleisli m  is
06:05:55 <statusfailed> heh
06:06:12 <mm_freak> statusfailed: netwire 3 only has one arrow you could use there though
06:06:25 <mm_freak> a family of arrows in fact:  (Monad m) => Kleisli m
06:07:29 <statusfailed> I've really only just come across it from here: http://stackoverflow.com/questions/8419452/are-there-monads-that-can-be-used-like-an-automaton
06:07:33 <statusfailed> so i'm not sure what that would imply yet
06:07:37 <statusfailed> I'll keep it in mind though :)
06:08:10 <mm_freak> statusfailed: netwire provides the wire arrow, which is a generalization of the automaton arrow
06:08:23 <mm_freak> newtype Auto a b = Auto (a -> (b, Auto a b))
06:08:34 <mm_freak> newtype Wire e a b = Wire (a -> (Either e b, Auto a b))
06:09:45 <mm_freak> statusfailed: the primary use case for netwire is FRP, but you can do all kinds of automaton programming with it
06:10:10 <donri> mm_freak: fastirc! release!
06:10:48 <mm_freak> donri: netwire 4 has a higher priority right now…  also i'm working on some snaplets i want to release before that
06:11:05 <mm_freak> donri: fastirc will be based on netwire 4 anyway =)
06:11:39 <statusfailed> mm_freak: I'm really looking to stuff with the signal processing bits, I got here while looking for some nice way to compose functions of type (a -> State s b)
06:11:45 <donri> netwire: yay! snaplets: ney :(
06:11:54 <statusfailed> which led me to arrows and then netwire
06:11:57 <statusfailed> need to read a lot though
06:12:12 <mm_freak> statusfailed: i know that some people use netwire for audio sampling, which is an entirely valid use case
06:12:23 <matthiasgorgens> Is there a way to extract all the dependencies of a package from it's cabal file?
06:12:23 <donri> mm_freak: is there a repo somewhere? i'd like to look at the design (fastirc)
06:12:38 <donri> mm_freak: current fastirc has weird dependencies and uses bytestrings in some possibly awkward places
06:13:11 <donri> i'm curious how it has evolved since then
06:13:37 <mm_freak> donri: i started redesigning fastirc, but abandoned it later…  currently the hackage version is still the latest revision
06:13:47 <donri> aha
06:14:09 <mm_freak> i wanted to make a more sensible session monad, but then i found that IRC is better modelled as a reactive system =)
06:14:15 * hackagebot metadata 0.1.0.2 - metadata library for semantic web. (KatsutoshiItoh)
06:15:05 <aristid> mm_freak: so you wrote netwire for an irc bot? awesome :D
06:15:24 <mm_freak> aristid: nope, not at all, but i wrote netwire for networking applications
06:15:39 <t7> is there a one to many style map
06:15:47 <mm_freak> aristid: on hackage you will find an experimental reactive web framework called webwire…  it's based on a very old version of netwire though, but it worked
06:15:48 <t7> x -> [a, b, c]
06:15:51 <aristid> mm_freak: you know this might be a stupid question. *5 seconds of fear instilling*
06:16:00 <mm_freak> t7: concatMap?  (>>=)?
06:16:01 <donri> t7: Map k [v]
06:16:02 <Peaker> mm_freak, is netwire all arrow-based? Or is it just one of multiple interfaces?
06:16:13 <aristid> mm_freak: can netwire be used as an alternative to pipes/conduits/stuff?
06:16:25 <mm_freak> aristid: not really
06:16:35 <donri> t7: Data.Map has helpers like "insertWith (++)"
06:16:43 <mm_freak> Peaker: one of the multiple interfaces…  it's primarily AFRP, where the "A" stands for "Applicative" =)
06:17:06 <Peaker> ah cool :)
06:17:16 <Peaker> I don't like the "arr"-based Arrows
06:17:56 <t7> aha
06:18:00 <mm_freak> Peaker: the arrow interface is nice for choice (ArrowChoice) and/or feedback (ArrowLoop)
06:18:11 <mm_freak> otherwise i'd mostly use the applicative interface
06:18:14 <statusfailed> mm_freak: oh, I just realised i'm raeding your arrows tutorial as well :D
06:18:16 <donri> aristid: they tried make Pipe an arrow but it wasn't lawful
06:18:22 <mm_freak> statusfailed: hehe
06:18:25 <statusfailed> thanks :)
06:18:56 <mm_freak> statusfailed: i hope it helps =)
06:19:31 <statusfailed> Yes, it's been very clear so far
06:19:57 <qnikst> mm_freak: I finished with 'v     <- forM [0..n-1] (\i -> allocate (ptr `peekElemOff` i) destroy)' where ptr is a result of FFI function, seems it will suite my needs
06:20:00 <qnikst> thans
06:20:02 <qnikst> thanks
06:20:16 <aristid> donri: i read something about it being in a better situation if you look at type pairs instead of types
06:20:33 <donri> anyone know a nice package for ipc? or should i just put some binary/cereal on a unixsocket myself
06:20:37 <Peaker> mm_freak, why not write Applicative classes for those?
06:21:15 <aristid> mm_freak: in netwire, the arrows are about streams of events, no? i mean, what's the fundamental difference to pipes?
06:21:26 <donri> aristid: i thought that was for having a type be both a monad and a category without wrapper types? hadn't read closely though
06:21:28 <qnikst> and another question what type is good for representing CSize on a haskell side?
06:21:29 <mm_freak> qnikst: i still recommend Vector, if you don't mind the conversion…  it will make code much shorter
06:21:49 <aristid> donri: might be that
06:22:02 <aristid> donri: i didn't know arrow had laws other than the category laws :D
06:22:07 <mm_freak> aristid: a wire receives one input per instant and can't ask for more
06:22:16 <mm_freak> a stream processing arrow works differently
06:22:34 <aristid> mm_freak: what if you redefine time in stream terms? :D
06:22:48 <donri> aristid: IIRC the problem was that pipes don't always have both an input and output, or something like that
06:22:51 <mm_freak> i could totally think of a wire-like stream processor, but it won't have any advantage over 'pipes' and probably will be more awkward to use without some very clever design
06:23:21 <mm_freak> any way i tried to write a stream processing wire-like arrow i ended up reinventing coroutines
06:23:41 <mm_freak> and you already have conduits, pipes and monad-coroutine
06:23:58 <aristid> mm_freak: so which network applications is netwire suitable for, then?
06:24:21 <mm_freak> aristid: stateful applications
06:24:38 <mm_freak> like HTTP sessions, like IRC, like XMPP
06:24:52 <mm_freak> anything that benefits from a local state abstraction like the automaton arrow
06:25:00 <qnikst> mm_freak: ok, will think about it, anyway I should traverse over an objects and register them
06:25:21 <mm_freak> aristid: the key word here is "local state"
06:25:46 <aristid> mm_freak: so for HTTP it might make sense to use both netwire and conduit/pipe/...?
06:26:21 <mm_freak> Peaker: i have whenW, ifW, etc.
06:26:33 <mm_freak> you could certainly invent ApplicativeIf, ApplicativeFix, etc.
06:26:38 <quicksilver> mm_freak: in conal-style FRP statefulness isn't a big problem, you just have a "Behaviour MyState" to inform your reactions.
06:26:40 <mm_freak> but i don't like to invent classes
06:26:49 <quicksilver> mm_freak: does that not work with netwire?
06:27:10 <mm_freak> quicksilver: this is how netwire works, too
06:27:24 <mm_freak> where "Behaviour MyState" looks like "Wire a MyState"
06:27:31 <mm_freak> s/Wire/MyWire/
06:27:50 <quicksilver> mm_freak: oh I completely misread you
06:28:03 <quicksilver> mm_freak: thought you were saying netwire was *un*suitable for those things :)
06:28:15 <mm_freak> ah, no…  it's /made/ for those things =)
06:28:24 <donri> aristid: don't claim expertise here but i think pipes could be useful for say, writing the lower-level networking/protocol parsing bits of say an IRC bot, and FRP useful for the "application" on top of that?
06:28:29 <donri> mm_freak: ^ does that make sense?
06:28:47 <mm_freak> donri: yeah
06:29:04 <mm_freak> FRP hides the imperativeness and statefulness of IRC
06:30:02 <quicksilver> to my mind it doesn't really hide those things
06:30:10 <quicksilver> it just gives you a declarative way of solving them
06:30:30 <donri> an elegant solution to an inelegant problem! yay!
06:32:35 <mm_freak> true
06:32:43 <mm_freak> well
06:32:53 <mm_freak> applicative FRP actually /does/ hide the imperativeness
06:33:23 <mm_freak> and it makes the statefulness more managable and readable and, most importantly, localized
06:33:30 <mm_freak> i.e. more composable
06:34:19 <donri> i wonder if applicative is powerful enough for what hxt uses arrows for
06:34:24 <donri> applicative xml parsing could be neat
06:35:04 <aristid> xml parsing isn't all that much about state, is it?
06:35:58 <donri> hxt has state support but i haven't used it myself, not directly anyway
06:36:06 <aristid> donri: do you actually like the way hxt uses arrows?
06:36:18 <donri> yes
06:36:19 <dolio> What does state have to do with anything?
06:36:39 <aristid> dolio: well i thought we were talking about netwire and applicative FRP
06:36:56 <donri> i'm just talking about arrow vs applicative generally
06:37:27 <aristid> donri: isn't hxt's Arrow basically a kleisli arrow?
06:37:42 <Cale> yes it is
06:37:59 <donri> duno what that means, ArrowApply?
06:38:04 <Cale> hxt could just as well be a Monad instance
06:38:15 <hpaste> “Ertugrul Söylemez” pasted “FRP-style IRC (pseudo-code)” at http://hpaste.org/72337
06:38:28 <mm_freak> this is how FRP-style IRC could look like
06:38:33 <donri> i sometimes need apply in hxt, but not always
06:38:50 <mm_freak> nothing applicative there yet, just Category and one application of Alternative
06:39:31 <aristid> mm_freak: can you change it so it looks up the users in the channel and talks to them instead of just the two hard-coded users?
06:39:43 <aristid> mm_freak: i want to see something where there's data flow:)
06:40:02 <allsystemsarego> hi, I believe trace behaves weird, could you guys take a look at this hpaste?
06:40:04 <hpaste> allsystemsarego pasted “Trace behavior” at http://hpaste.org/72338
06:40:44 <mm_freak> aristid: sure…  channelUsers :: IrcWire ChannelName (Map Nickname UserData)
06:41:00 <mm_freak> this is still pseudo-code, but that's likely how it would look like
06:41:29 <mm_freak> aristid: also there is data flow in there
06:41:46 <aristid> mm_freak: how would i actually use that channelUsers wire?
06:42:01 <mm_freak> interactWith . channelUsers
06:42:35 <mm_freak> i'd likely have a chat monad there, which allows you to write chat sessions
06:43:12 <mm_freak> it would pretty much look like monad-coroutine internally
06:43:29 <mm_freak> or even would be monad-coroutine's Coroutine itself
06:43:31 <aristid> mm_freak: a Wire is not a Monad automatically?
06:43:37 <mm_freak> no
06:43:45 <aristid> why not?
06:43:59 <mm_freak> because (>>=) would be O(n), where n is the number of passed instances =)
06:44:06 <fmap> allsystemsarego: what behaviour did you expect?
06:44:10 <mm_freak> s/instances/instants/
06:44:22 * hackagebot cyclotomic 0.3 - A subfield of the complex numbers for exact calculation. (ScottWalck)
06:44:32 <aristid> mm_freak: ok and Applicative doesn't have these performance problems? hmm:)
06:44:44 <mm_freak> aristid: to understand the problem, try to write a Monad instance for ZipStream
06:44:58 <mm_freak> data ZipStream a = ZipStream a (ZipStream a)
06:45:05 <mm_freak> with a ZipList-like Applicative instance
06:45:16 <aristid> mm_freak: that's the one where it's possible with diagonalisation?
06:45:23 <Okasu> hello
06:45:45 <morel> hi Okasu
06:45:48 <Okasu> is it possible to turn 'outof bounds' check in haskell?
06:45:56 <mm_freak> aristid: just write it =)
06:46:00 <mm_freak> it's an eye opener
06:46:01 <Okasu> like out of Int bounds
06:46:07 <mm_freak> but yes, diagonalization is the key word
06:46:23 <mm_freak> the problem with Monad is that (>>=) takes an opaque function as its second argument
06:46:23 <aristid> mm_freak: if you insist :D
06:46:25 <morel> > maxBound :: Int -- Okasu
06:46:26 <lambdabot>   9223372036854775807
06:46:39 <mm_freak> so diagonalization involves actually traversing the stream produced by that function
06:46:48 <mm_freak> at every instant that is
06:47:43 <morel> > let thisFunctionChecksWhetherAnIntegerCanBeConvertedIntoAInt i = i >= (minBound :: Int) && i <= (maxBound :: Int)
06:47:44 <allsystemsarego> fmap, I would expect trace to stop at line 18, after it got to zero, why does the rest of it show up?
06:47:44 <lambdabot>   not an expression: `let thisFunctionChecksWhetherAnIntegerCanBeConvertedInt...
06:47:55 <aristid> mm_freak: haha i'm not even done defining the type ZipStream before i add the first extension. (DeriveFunctor)
06:48:02 <morel> > let thisFunctionChecksWhetherAnIntegerCanBeConvertedIntoAInt i = i >= (minBound :: Int) && i <= (maxBound :: Int) in thisFunctionChecksWhetherAnIntegerCanBeConvertedIntoAInt 1000000000000000000
06:48:03 <lambdabot>   True
06:48:30 <morel> Okasu: ^ :D
06:48:32 <Okasu> morel: thanks
06:48:42 <mm_freak> aristid: i'd have written fmap in terms of foldStream =)
06:49:01 <mm_freak> foldStream :: (a -> b -> b) -> ZipStream a -> b
06:49:25 <fmap> allsystemsarego: so you expect results of `f' calls to be shared
06:49:35 <fmap> i don't think it's so
06:50:26 <allsystemsarego> fmap, I imagined that's how recursion works
06:50:40 <aristid> allsystemsarego: no
06:50:46 <aristid> oh wait, fmap is the nick
06:50:48 <aristid> lol
06:50:56 <aristid> fmap: your nick is confusing at times :P
06:51:08 <fmap> aristid: sorry :[
06:51:18 <mm_freak> fmap is also an unfortunate nick here, because it probably causes a lot of false highlights =)
06:51:22 <allsystemsarego> fmap, I took the example from here: http://en.wikibooks.org/wiki/Haskell/Debugging
06:51:44 <allsystemsarego> fmap, ... and modified it slightly
06:52:34 <mm_freak> `fmap` would be a less noisy nick, though it's still prone to some false highlights =)
06:52:40 <mm_freak> > succ `fmap` [1..10]
06:52:42 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
06:53:15 <donri> maybe your tracing of n-2 as well forces some evaluation that'd otherwise be lazied away
06:53:27 <donri> i kinda suck at recursion and didn't read the code closely though :)
06:54:02 <allsystemsarego> donri, oh, ok, that explains it
06:54:42 <mm_freak> aristid: btw, if you come up with an efficient implementation of (>>=) for ZipStream, please tell me…  i'd love to turn Wire into a monad =)
06:55:06 <donri> try using traceShow on the expressions directly instead
06:55:18 <aristid> mm_freak: :)
06:55:36 <allsystemsarego> donri, thanks, I'll try that
06:56:15 <donri> f (traceShow (n-1) (n-1)) (traceShow (n-2) (n-2)) -- or something
06:56:28 <fmap> allsystemsarego: actually linked example recalculate n == 2 too
06:56:40 <donri> (really, is there no Show a => a -> a trace function?)
06:57:00 <t7> @pl (\v -> TVar v `Equal` f)
06:57:01 <lambdabot> (`Equal` f) . TVar
07:01:47 <aristid> mm_freak: i have an, I think, elegant Monad instance, but I'm not sure if it meets your performance standard
07:02:22 <aristid> mm_freak: the relevant function is: joinZ (ZipStream a x) = ZipStream (headZ a) (joinZ $ tailZ <$> x)
07:02:27 <aristid> the rest is boilerplate:)
07:04:53 <qnikst> mm_freak: and how can I create Ptr CSize on haskell side?
07:05:13 <qnikst> with mallocForeignPtr?
07:08:51 <mm_freak> aristid: that's not a proper Monad instance
07:09:08 <mm_freak> aristid: compare your 'ap' to (<*>)
07:09:19 <mm_freak> qnikst: that's one way
07:09:30 <mm_freak> qnikst: well, malloc
07:10:22 <qnikst> hm.. malloc seem better
07:10:48 <t7> i need set fold with monad :(
07:10:55 <t7> why is life so hard
07:11:17 <Cale> t7: what are you trying to do?
07:11:27 <qnikst> mm_freak: what's better use ForeignPtr, or free value myself, if value lives only inside one function and doesn't exported
07:11:46 <t7> fold over a Set with a monadic computation
07:12:06 <t7> aha Foldable !
07:12:13 <Cale> Yeah, or traversable
07:12:24 <Cale> but you could also just turn it into a list
07:12:44 <Cale> because that's more or less what the Foldable/Traversable instances do
07:12:45 <t7> seems a bit ugly
07:12:49 <aristid> mm_freak: do you have some ZipStreams for me to test this on?
07:12:53 <Cale> Lists are the fundamental unit of iteration
07:13:13 <t7> i like to pretend im working with sets :)
07:13:13 <Eduard_Munteanu> I think Traversable fits better here.
07:13:20 <Cale> If you're iterating over all of a bunch of things in order, there is no better datastructure for them to be in than a list.
07:13:25 <t7> Set doesnt havea  traversable instance
07:13:36 <t7> but it does have foldable
07:14:26 <Cale> oh, hmm!
07:14:46 <Eduard_Munteanu> Lists are a bit overly optimistic wrt fusion in this case, if you want to end up with another Set.
07:15:27 <aristid> mm_freak: my ap gives the same result as my (<*>)
07:15:36 <Eduard_Munteanu> If you don't, then I guess it's ok.
07:15:40 <aristid> mm_freak: at least for the ZipStreams i tested on
07:15:49 <t7> im only using Sets and Maps
07:16:16 <Cale> Well, look at it this way -- unless the function you're mapping over the set is guaranteed to be monotone, you're going to have to rebuild the tree structure anyway
07:16:28 <Eduard_Munteanu> You could try writing a Traversable instance though.
07:16:47 <t7> whats wrong with foldable?
07:16:48 <aristid>  > pure (,) `ap` upFrom 1 `ap` upFrom 2
07:16:50 <aristid> ((1,2) , (2,3) , (3,4))
07:17:06 <Eduard_Munteanu> t7: depends what you need, Foldable doesn't give you sequence
07:17:09 <aristid> mm_freak: that's the correct result, no? (upFrom x is x,x+1,x+2,...)
07:17:15 <Eduard_Munteanu> :t sequence
07:17:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:17:25 <aristid> mm_freak: and my SHow instance only shows the first 3 entries
07:17:25 <Cale> (or mapM, which is what I was assuming you meant you needed)
07:17:36 <Eduard_Munteanu> Yeah...
07:17:38 <Eduard_Munteanu> @src mapM
07:17:38 <lambdabot> mapM f as = sequence (map f as)
07:17:41 <Cale> There is an obvious way to implement Traversable for Set though
07:17:56 <Cale> oh, maybe it doesn't work because of Ord
07:17:57 <t7> foldrM is fine
07:20:51 <mm_freak> aristid: wait…  let me check
07:21:22 <aristid> mm_freak: yes, please
07:22:04 <t7> i need to recurse on the left hand side, eg.   f x = f (g x) ++ x
07:22:09 <t7> is that foldl ?
07:22:28 <mm_freak> aristid: i'm expecting a space leak, but your joinZ actually seems reasonable
07:22:36 <mm_freak> i'm expecting (>>=) to leak
07:22:49 <mm_freak> but not necessarily…  your solution is interesting
07:22:53 <aristid> mm_freak: can you test it?
07:22:59 <mm_freak> i'm implementing it
07:23:01 <aristid> mm_freak: i can give you the full code
07:23:09 <morel> t7: so, "f x = h (f (g x)) x", right?
07:23:25 <aristid> mm_freak: https://gist.github.com/3207306
07:24:53 <aristid> mm_freak: reasoning about space leaks is the hardest part of haskell :)
07:25:32 <marcot> aristid: agreed.
07:26:31 <mm_freak> aristid: i'll turn this into a wire right away…  let me check
07:27:10 <aristid> mm_freak: do you have a testsuite for that kind of stuff?:)
07:28:36 <donri> there's some package that implements things like Set in such a way they can be made instances of stuff
07:28:46 <donri> IIRC
07:29:30 <aristid> donri: reflection?
07:33:20 <schovi> Hello. Just fall in some strange behaviour with HDBC and Time conflict in GHCI. https://gist.github.com/3207349 (when compiled it is OK). Is there any simple solution?
07:35:10 <mm_freak> aristid: i'm not at testing yet, but it seems like monadic wires become impossible
07:35:42 <aristid> mm_freak: what's the problem?
07:38:23 <mm_freak> aristid: i see the space leak now, let me polish it
07:39:36 <parcs`> how does one embed a Type into in a TH quotation? is there a neater way than doing $(pure x) ?
07:40:09 <mm_freak> aristid: the problem is that it will heap-overflow sooner or later
07:40:24 <mm_freak> aristid: think of the tenth stream element
07:40:27 <cinelli> Looking for Arch Linux package haskell-hashed-storage... can't seem to google out of anywhere.. anyone got a link or pkgbuild
07:40:37 <mm_freak> at first it s c, then it becomes tailZ c, then tailZ (tailZ c), etc.
07:40:58 <parcs`> cinelli: cabal install hashed-storage
07:40:59 <mm_freak> this gets larger and larger the more instants you compute
07:41:12 <geekosaur> schovi, per the link log it's loading two versions of the time package (1.4 and 1.4.0.1) hence the symbol collision between them.  you may need to pass -package options to ghci (as cabal does to ghc when compiling to force ghci to load specific versions)
07:41:23 <cinelli> parcs`: thank you.
07:41:50 <mm_freak> aristid: so now it's O(n) space instead of O(n) time, which is probably worse
07:42:01 <schovi> geekosaur: thanks.
07:43:03 <geekosaur> in fact I would say at this point you have a somewhat mangled local package database and need to rebuild stuff being careful to avoid getting multiple versions of the same package mixed in anywhere
07:43:58 <geekosaur> older versions of cabal-install were happy to create such "diamond dependency" issues; the latest one (1.14) does a better job of avoiding it
07:44:25 * hackagebot instant-generics 0.3.5 - Generic programming library with a sum of products view (JosePedroMagalhaes)
07:44:46 <geekosaur> sorry, lib is 1.14, cabal-install is 0.14
07:44:47 <schovi> geekosaur: how to do that? Using cabal just one day :D
07:45:43 <geekosaur> schovi, this somewhat evilly named page describes the problem and how to detect and recover from it.  http://www.vex.net/~trebla/haskell/sicp.xhtml
07:45:47 <mm_freak> aristid: moreover in the monadic case this will actually delay effects until you actually reach that instant, and the effects will be repeated over and over again
07:46:03 <mm_freak> newtype ZipListM m a = ZipListM (m (a, ZipList m a))
07:46:42 <aristid> mm_freak: well i wasn't claiming to write a wire, this is just a ZipStream instance! :)
07:47:01 <mm_freak> yeah, but it has the same O(n) behavior…  just not for time, but for space =)
07:47:37 <mm_freak> well, actually for both
07:47:53 <mm_freak> but i think you see the problem now
07:48:18 <mm_freak> i don't think it's possible to write a sensible Monad instance for ZipStream
07:48:20 <schovi> geekosaur: ty
07:48:23 <geekosaur> I would, before jumping in and trying to fix the packages as described there, upgrade cabal-install.  http://hackage.haskell.org/packages/archive/cabal-install/0.14.0/cabal-install-0.14.0.tar.gz
07:48:46 <mm_freak> again, if anyone comes up with one, i'd be /very/ interested
07:48:57 <geekosaur> (if you just try to do it with cabal-install itself, it still sticks to the old version, I think.  there's a --constraint or something you could use to force it, but manual upgrade is probably easiest)
07:49:02 <mm_freak> this would revolutionize the world of AFRP and turn it into MFRP =)
07:49:53 <mm_freak> i already spent many hours trying to do it with no success
07:50:46 <cheater> love the lambdas: http://mindhacks.com/2010/07/20/the-illusion-of-progress-lights-a-fire/
07:51:48 <sm> geekosaur: cabal install cabal-install-0.14 works, right
07:54:18 <geekosaur> sm, thought it still required an option to make it not say "you didn't really mean that"...
07:54:26 * hackagebot really-simple-xml-parser 0.4.0.0 - A really simple XML parser (KashyapChatamballi)
07:54:40 <geekosaur> (some insanity intended to avoid foot-shooting)
07:57:31 <t7> get yer karma: http://stackoverflow.com/questions/11724023/bottom-up-hindler-milner-type-inference-applying-a-substitution-to-an-implicit
07:59:32 <parcs`> am i crazy or is it impossible to use a TH splice in place of a field name in a record update?
07:59:38 <t7> anyone know where i should ask this question ?
08:01:52 <geekosaur> parcs`, I would not be at all surprised; that's exactly where record update syntax fails to be anything that we expect from Haskell...
08:02:02 <c_wraith> parcs`: that sounds likely to be true
08:02:09 <parcs`> oh right because an expression quotation requires splices to be an expression as well and a field is not an expression in that context
08:03:11 <c_wraith> that exact some token is an expression in other contexts!
08:03:18 <c_wraith> *same
08:03:33 <c_wraith> but yeah, that doesn't mean TH cares
08:03:42 <qnikst> next level in fighting with FFI, how should I correctly define structure in order to be able to access fields?
08:04:26 * hackagebot BlogLiterately 0.5.1 - A tool for posting Haskelly articles to blogs (BrentYorgey)
08:05:26 <parcs`> qnikst: use bindings-DSL + hsc2hs
08:05:37 <geekosaur> qnikst, http://therning.org/magnus/archives/tag/hsc2hs might be helpful.  (or there is c2hs, which does more for you but can go wrong if it makes the wrong assumptions)
08:06:18 <geekosaur> (URL I linked is not for hsc2hs, that comes with ghc.  it's blog articles providing an introduction to using it)
08:06:35 <qnikst> thans
08:06:37 <qnikst> thanks
08:11:15 <Peaker> structs/etc are so painful...  I think it would be better to extract them from debug info to FFI declarations
08:11:50 <Peaker> than to work with the C files, where there's no guarantee the compiler setup and options are identical
08:17:53 <Dybber> Can someone tell me how you would install GHC on a Debian Wheezy? It seems that GHC 7.4.1 requires libgmp in a version that isn't found in Wheezy anymore (libgmp.so.3)
08:18:50 <geekosaur> it's still available but not a default installed package, hold on
08:19:18 <Dybber> I have libgmp.so.10
08:19:46 <geekosaur> yes, that's the standard one.  there is another package, not installed by default, with the older version.
08:19:52 <geekosaur> (unpacking what I already said a bit)
08:20:03 <geekosaur> I am booting the other laptop to see what it[s called
08:20:57 <Dybber> It was called libgmp3c2 on squeeze
08:21:05 <geekosaur> (it's an eeepc netbook so not the fastest thing in existence...)
08:22:59 <geekosaur> libgmp3-dev?
08:28:05 <Dybber> geekosaur: nope, that is an empty package depending on libgmp-dev which again depends on libgmp10, which contains libgmp.so.10.0.5 and libgmp.so.10
08:29:08 <geekosaur> sigh.  I had it installed at one point, but this is an old eeepc and I haven't kept it up to date as a haskell dev environment
08:30:01 <aristid> mm_freak: ok, i can reproduce the time leak. (now that i tried)
08:31:15 <mm_freak> aristid: more like you can't /not/ reproduce it =)
08:31:26 <geekosaur> aaagh.  ok, so libgmp3c2 was it but they blew it away.  this makes things difficult
08:31:54 <aristid> mm_freak: well when the elements i look at have a sufficiently small index, it doesn't matter
08:31:59 <geekosaur> dear debian-haskell folks, please give us our haskell back...
08:33:41 <mm_freak> aristid: of course, but that's really like:  if you never enter your car, you won't crash =)
08:34:04 <mm_freak> netwire easily performs millions of instants per second
08:34:09 <mm_freak> and i aim to keep it that way
08:34:15 <aristid> mm_freak: and it keeps them in a list?
08:34:24 <mm_freak> no, it doesn't keep them
08:35:27 <mm_freak> try this with netwire:  liftA2 (\x y -> printf "%8d %8d %8d" x y (x + y)) (countFrom 0) (countFrom 10)
08:35:37 <aristid> mm_freak: i don't really understand the parallel between ZipStream and Wire :(
08:35:37 <mm_freak> should perform somewhere near the 100 million FPS
08:36:06 <mm_freak> let's talk about Auto instead of Wire
08:36:14 <mm_freak> newtype Auto a b = Auto (a -> (b, Auto a b))
08:36:26 <mm_freak> newtype ZipStream b = ZipStream (b, ZipStream b)
08:36:32 <mm_freak> do you see the parallel?
08:37:42 <aristid> mm_freak: ZipStream = Auto ()?
08:38:04 <Hakkla> Hello. Are foldl and foldr equal when it comes to performance (this is, is one as fast as the other)? I'm asking this because it seems that retrieving elements of a list, right to left, is slower than left to right.
08:38:28 <mm_freak> aristid: more like:  ZipStream = forall a. Auto a
08:38:31 <aristid> Hakkla: no they aren't equal
08:38:47 <aristid> mm_freak: ok:)
08:38:48 <mm_freak> Hakkla: none of those functions does that
08:39:08 <mm_freak> Hakkla: you can understand foldr better by implementing it yourself…  you
08:39:21 <mm_freak> you'll find that it also traverses from head to end
08:39:54 <mm_freak> aristid: now the question is:  how can we compose ZipStreams?  i.e. how can we make one ZipStream dependent on another by individual elements?
08:40:17 <mm_freak> aristid: this is where the function comes in:  newtype DependentZipStream a b = DZS (a -> (b, DependentZipStream a b))
08:40:24 <mm_freak> now DependentZipStream is a Category
08:40:34 <aristid> mm_freak: DZS is Auto, no?
08:40:46 <mm_freak> and because it acts so much like automata, we call it Auto =)
08:41:38 <aristid> @unmtl ReaderT r (State s a)
08:41:38 <lambdabot> Plugin `unmtl' failed with: `ReaderT r (s -> (a, s))' is not applied to enough arguments.
08:41:46 <aristid> @unmtl ReaderT r (State s) a
08:41:47 <lambdabot> r -> s -> (a, s)
08:41:54 <Axman6> Hakkla: they're very different functions really. and one will be faster than the other in some circumstances, and vice versa in others. if you need laziness so you can stop processing half way through the list, then foldr is what you need. if you know you need to accumulate all the values into a single value, then foldl is a better choice because it always traverses the whole list. foldl' is usually a better choice over foldl by itself however.
08:41:56 <aristid> oh nevermind
08:41:58 <mm_freak> now how do we handle events?  classic AFRP says:  we just don't…  events are regular signals and the abstraction doesn't have any notion of events
08:42:14 <mm_freak> this is where Wire comes in
08:42:38 <mm_freak> it makes events part of the system:  newtype Wire a b = Wire (a -> (Maybe b, Wire a b))
08:42:43 <mm_freak> this is /highly/ simplified
08:42:55 <mm_freak> but it's the basic idea
08:43:09 <mm_freak> now it's not just a Category and Applicative, but it's also a proper Alternative
08:43:40 <aristid> mm_freak: so an even _behaves_ like signals that are Nothing most of the time?
08:43:51 <Hakkla> Thanks! I looked at the documentation for foldl and foldr, and I now see that they both seem to go from head to end, the operations are just on a different order.
08:44:07 <Axman6> right
08:44:16 <Peaker> Hakkla, ((((a * b) * c) * ...)   vs:   (a * (b * (c * ( ....   ))))))
08:44:24 <Peaker> (foldl vs foldr)
08:44:31 <mm_freak> aristid: something like that, yes
08:44:50 <aristid> mm_freak: your simplified Wire a b = Auto a (Maybe b)
08:44:56 <mm_freak> aristid: btw, your unmtl business raises another interesting thing
08:45:03 <mm_freak> there is an interesting alternative definition of Auto
08:45:19 <mm_freak> data Auto a b = forall s. Auto s ((a, s) -> (b, s))
08:45:38 <mm_freak> this definition makes much clearer the /local state/ nature of the automaton arrow =)
08:45:48 <mm_freak> aristid: not exactly
08:45:53 <aristid> mm_freak: yes and it's optically much more pleasing
08:45:59 <aristid> it looks almost symmetric \o/
08:46:03 <mm_freak> the Category instance of Wire now knows about the Maybe semantics
08:47:06 <mm_freak> if a wire produces Nothing at one instant, i call that signal inhibition…  when x inhibits, then y . x also inhibits and y is not reached
08:47:18 <mm_freak> now think further:  y . x <|> z
08:47:28 <mm_freak> if x inhibits, then y . x <|> z = z
08:48:20 <mm_freak> with yampa you need switching to handle events…  you actually /handle/ them, thus become somewhat less declarative
08:48:25 <mm_freak> in netwire this handling is implicit
08:48:34 <mm_freak> everything is properly declarative
08:49:51 <aristid> mm_freak: and you use inhibition to know that you don't need to run the inner wire?
08:51:03 <mm_freak> well, the idea is this:  imagine a UI that reads two numbers from two text entry fields 'entry1' and 'entry2'
08:51:20 <mm_freak> it should display the sum for proper numbers, otherwise it should display "parse error" in a label
08:51:55 <mm_freak> label = liftA2 (+) (parseNum . entry1) (parseNum . entry2) <|> pure "parse error"
08:53:26 <aristid> mm_freak: ok?
08:54:04 <mm_freak> now the type of parseNum:  parseNum :: UiWire Text Integer
08:54:13 <mm_freak> if the Text can't be parsed as a number, parseNum inhibits
08:54:38 <mm_freak> lift any of x and y inhibits, then liftA2 f x y inhibits
08:54:49 <mm_freak> in that case the 'pure "parse error"' is reached
08:55:05 <mm_freak> as long as you don't have valid numbers in the entry fields, the label displays "parse error"
08:55:28 <mm_freak> oh, the code is a type error actually
08:55:35 <mm_freak> label = fmap show . liftA2 (+) (parseNum . entry1) (parseNum . entry2) <|> pure "parse error"
08:55:38 <mm_freak> something like that =)
08:57:33 <aristid> mm_freak: the parsing and addition only happens if something is actually entered in the text box?
08:57:52 <mm_freak> depends on parseNum
08:58:36 <aristid> let's say parseNum is pure
08:59:03 <mm_freak> pure "please enter the addends" . (isEmpty . entry1 <|> isEmpty . entry2) <|> fmap show . …
08:59:37 <hpaste> Davesque pasted “Sub Time Total” at http://hpaste.org/72342
08:59:58 <mm_freak> aristid: so far everything is pure
09:00:12 <davesque> can anyone help me figure out that error?  should be a quicky.
09:00:48 <mm_freak> davesque: use fromIntegral
09:00:50 <aristid> mm_freak: entry1 and entry2 are pure?
09:01:07 <mm_freak> aristid: they are wires
09:01:16 <aristid> mm_freak: i thought they read from a friggin UI field!
09:01:26 <mm_freak> they do =)
09:01:36 <aristid> mm_freak: then they are not pure in that sense?!
09:02:15 <davesque> mm_freak: okay, so like -- (fromIntegral h) * 3600 + (fromIntegral m) * 60 + s?
09:02:17 <aristid> mm_freak: there must be a WmGen buried deep inside entry1, no? for how would it get the value from the text box without IO
09:02:19 <mm_freak> aristid: that depends on the UI framework
09:02:39 <mm_freak> aristid: i'm actually thinking in terms of netwire 4, which has a slightly different architecture
09:02:54 <mm_freak> most notably Wire has become an associated type of a new type class Reactive
09:03:09 <aristid> mm_freak: and netwire 4 is not on hackage :P
09:03:21 <mm_freak> yeah, but it's close to its release =)
09:03:31 <mm_freak> davesque: you don't need the parentheses
09:03:38 <aristid> mm_freak: is is on github or so/
09:03:44 <mm_freak> aristid: nope, sorry
09:03:51 <aristid> mm_freak: why not?
09:03:56 <mm_freak> but i can paste the main module, if you wish
09:04:00 <aristid> yeah
09:04:14 <aristid> i still think putting it on a public VCS would be a good idea tho
09:04:28 * hackagebot boomerang 1.3.3 - Library for invertible parsing and printing (JeremyShaw)
09:04:49 <c_wraith> oh, hey.  I've been looking for one of them.
09:05:26 <hpaste> “Ertugrul Söylemez” pasted “Netwire 4 core module” at http://hpaste.org/72343
09:05:27 <aristid> c_wraith: one of whom?
09:05:44 <c_wraith> aristid: a library for invertible parsing and printing
09:05:58 <mm_freak> aristid: i know, i already greated a github account, but haven't started using it yet
09:06:09 <mm_freak> c_wraith: see boomerang
09:06:16 <mm_freak> oh
09:06:17 <mm_freak> lol
09:06:21 <donri> :)
09:06:25 <aristid> mm_freak: oh this new thing also allows for totally pure wires, righto?
09:06:38 <mm_freak> aristid: totally pure wires will be the main thing =)
09:06:57 <c_wraith> mm_freak: :)
09:07:12 <aristid> mm_freak: oh reading the code my question is answered
09:08:27 <aristid> mm_freak: that's quite a bit more elegant than netwire 3 :)
09:08:33 <mm_freak> yeah =)
09:09:25 <mm_freak> aristid: and the great thing is:  almost all wires now only depend on Reactive, not on Effectful
09:09:31 <mm_freak> even wires like 'time' =)
09:09:53 <mm_freak> so most of the time you can use the (->) arrow =)
09:10:12 <aristid> mm_freak: hmm stupid idea: could Wire be an arrow transformer?
09:10:35 <davesque> mm_freak: thanks, that worked!
09:10:42 <mm_freak> aristid: it /is/ an arrow transformer
09:10:46 <mm_freak> aristid: see stepWire
09:11:26 <mm_freak> aristid: although i nowadays prefer to think of those things as "category transformers", because i'm slowly moving away from Arrow =)
09:11:41 <aristid> mm_freak: but no ArrowTransformer instance?
09:12:07 <mm_freak> aristid: not yet…  the library isn't finished
09:12:36 <aristid> mm_freak: and Reactive is a big class? can you trim it down without losing performance?
09:12:54 <mm_freak> i want to reproduce most of the prefab wires and wire transformers and also put some more thought into that to adjust the types
09:12:55 <aristid> mm_freak: also: is there a CategoryTransformer class somewhere?:)
09:13:32 <mm_freak> aristid: the reason Reactive is so big is because i didn't want it to depend on Arrow
09:13:51 <mm_freak> ArrowTransformer is CategoryTransformer
09:13:57 <mm_freak> it's just that Category is younger than Arrow
09:15:15 <aristid> mm_freak: look there's your Auto =) http://hackage.haskell.org/packages/archive/arrows/0.4.1.2/doc/html/Control-Arrow-Transformer-Automaton.html#t:Automaton
09:15:27 <mm_freak> liftC :: (CategoryTransformer (~>) (>~)) => (a >~ b) -> (a ~> b)
09:15:39 <mm_freak> yeah, that's the transformer variant of the Auto i've written above
09:16:00 <mm_freak> uh, wait
09:16:06 <mm_freak> liftC :: (CategoryTransformer (~>) (>~)) => (a >~ b) >~ (a ~> b)
09:16:09 <mm_freak> there you go =)
09:16:49 <aristid> mm_freak: so you'll totally define an ArrowTransformer instance?
09:17:06 <mm_freak> sure, but note how it's not actually needed
09:17:36 <hpaste> hape01 pasted “works but ugly” at http://hpaste.org/72344
09:18:14 <hape01> how would you write this more condensed?  http://hpaste.org/72344
09:18:35 <mm_freak> aristid: 'stepWire' is a better 'lift'
09:18:55 <mm_freak> the point of stepWire is that Kleisli is only used on the type level
09:19:29 <mm_freak> hape01: "do x <- c; y x" is the same as "c >>= y"
09:19:29 * hackagebot sodium 0.5.0.2 - Sodium Reactive Programming (FRP) System (StephenBlackheath)
09:19:30 <jfischoff> hape01: are you trying to print every line?
09:19:42 <hape01> yes i am
09:20:14 <mm_freak> hape01: you can use this at two places in your code
09:20:28 <hape01> mm_freak: ok i try to rewrite it
09:20:42 <hpaste> Peaker annotated “works but ugly” with “works but ugly (annotation)” at http://hpaste.org/72344#a72345
09:21:05 <Peaker> hape01, see my annotation
09:21:09 <Peaker> could use a whileM from somewhere
09:21:14 <mm_freak> hape01: also it needs some improvement…  the main computation should look like:  withFile fileName ReadMode printout
09:21:28 <mm_freak> Peaker: i'd go with explicit recursion here
09:21:48 <mm_freak> what it really could use is an ifM
09:21:49 <donri> hape01: readFile "bla" >>= putStr
09:22:00 <Peaker> mm_freak, I did use explicit recursion
09:22:19 <mm_freak> Peaker: but a whileM-based solution wouldn't
09:22:46 <jfischoff> why not: mapM_ putStrLn =<<  fmap lines =<< readFile "FileRead01-data.hs" ?
09:23:12 <Peaker> mm_freak, yeah, I think it'd be nicer to have:  whileM (not <$> hIsEOF h) $ do
09:23:21 <donri> why not putStr =<< readFile "bla.hs"
09:23:37 <Peaker> yeah, I didn't question that logic :)
09:23:40 <Peaker> I just mechanically translated
09:23:50 <jfischoff> yeah or donri's answer
09:23:58 <Twey> jfischoff: Last I checked, putStrLn "foo" >> putStrLn "bar" was *significantly* slower than putStr "foo\nbar\n"
09:24:12 <Twey> (because syscalls)
09:24:23 <latro`a> you're....binding to an fmap?
09:24:25 <latro`a> what?
09:24:27 <jfischoff> good to know. I assumed he want putStrLn for some reason
09:24:29 <latro`a> @ jfischoff
09:24:50 <jfischoff> yo
09:25:01 <mm_freak> i think hape01 really should continue improving his solution for now
09:25:13 <mm_freak> there are certainly nicer ways to write it, but that doesn't really help him =)
09:25:15 <latro`a> I'm not sure "fmap lines =<< readFile "filename"" does what you want
09:25:25 <hape01> thank you all!
09:25:56 <latro`a> in fact I'm almost certain it doesn't typecheck
09:25:56 <mm_freak> hape01: feel free to paste your improved version
09:26:02 <jfischoff> latro `a : your right
09:26:16 <latro`a> fmap lines $ readFile "filename" works, however
09:26:29 <jfischoff> right
09:26:39 <optimight> With Xmonad windows manager, how much improvement in programmer productivity / speed is expected?
09:27:59 <Twey> I don't think anyone's actually measured the productivity benefit of not having to manually arrange/search for windows.  But it would be an interesting study.
09:28:04 <donri> optimight: -5%
09:28:11 <geekosaur> might be better asked in #xmonad --- but note that that is a very personal thing, and in general *any* change will lead to initial loss of productivity as you become accustomed to the new setuo
09:28:14 <Twey> Heh
09:28:18 <confusing> optimight: there's people who love xmonad. those will claim huge productivity gains
09:28:30 <geekosaur> (also beware of "shiny new toy" syndrome!)
09:29:23 <optimight> yes ...  It seems like shiney new toy
09:29:28 <Twey> ‘Shiny new toy’ syndrome is wonderful.  It's what keeps people from going ‘ugh, new thing’ and never trying anything different.  :þ
09:29:30 * hackagebot tup-functor 0.2 - Homogeneous tuples (BalazsKomuves)
09:29:35 <donri> :)
09:29:50 <Twey> … homogeneous tuples?
09:29:59 <mm_freak> haskell was a shiny new toy a few years ago
09:30:01 <Peaker> I dislike xmonad.. it doesn't have good defaults. Its config DSL/lib is not well designed (very annoying to compose extensions).  It doesn't handle focus stealing well (drives me nuts).  It doesn't behave well with my nvidia-multiple-monitors setup
09:30:07 <mm_freak> now haskell is my way of thinking =)
09:30:17 <donri> FWIW you can configure e.g. gnome-shell to support a lot of keyboard work-flow
09:30:43 <donri> there's even an extension for classic tiled window management
09:30:53 <Twey> Peaker: What do you use?
09:31:38 <mun> if i want to express that there exists a P that is a unary ad-hoc polymorphic predicate that returns true if its argument is of type u but false if it's of type v, could I write "EX t,u,v:: TYPES, P:: t => bool. P(c::u) & ~P(c::v)" ?
09:32:02 <Qtr> ANyone here used the google chart api?
09:32:06 <mun> that is in general logic notation
09:32:18 <Peaker> Twey, ordinary run-of-the-mill WM (metacity) :( I'm not satisfied with it but it does focus stealing well
09:32:30 <donri> Twey: data GayTuple a = GayTuple a a
09:32:53 <mm_freak> mun: if nobody answers here you may want to try ##logic or even #agda
09:32:57 <Qtr> *Sigh* why do guys all the sudden become so helpful when they find out I'm a girl?
09:33:01 <mun> mm_freak, ok
09:33:05 <donri> Peaker: ...is metacity even maintained any more
09:33:06 <Twey> donri: Heh
09:33:12 <donri> Peaker: or are you using mate?
09:33:18 <Qtr> donri: chalmers?
09:33:24 <donri> Qtr: wha?
09:33:26 <Peaker> donri, I don't know, it's what I have in my gnome fallback session in Ubuntu
09:33:33 <Qtr> studying@chalmers?
09:33:34 <Peaker> donri, metacity is what I run
09:33:52 <donri> Peaker: well gnome2 is no more
09:34:05 <confusing> as for "shiny new toy", i can't think of any time where an xmonad update (darcs pull) broke old behavior. linux distros in my experience break quite a bit due to switching to systemd or away from it or whatever
09:34:15 <donri> and gnome2 uses "mutter", a metacity fork
09:34:34 <Peaker> donri, Yeah, I hate Gnome3 and Unity :-(((  I had a chance to use a computer with some very old Ubuntu on it.. it was so much more convenient :(
09:34:39 <donri> Qtr: nope. i'm considering doing it at some point though
09:34:44 <donri> Qtr: you?
09:34:44 <hpaste> hape01 annotated “works but ugly” with “works bug ugly -condensed-” at http://hpaste.org/72344#a72347
09:34:51 <luite> Qtr: i've used it a bit for my site, not too much experience
09:35:02 <luite> i liked chalmers for the 6 months i was there :)
09:35:11 <hape01> mm_freak: is this going into the direction you thought about?
09:35:16 <donri> Peaker: there's "mate" now which is a gnome2 fork... also gnome3 has a shell-free mode too
09:35:43 <mm_freak> hape01: yeah, that looks much nicer…  now get rid of openFile
09:35:49 <mm_freak> :t withFile
09:35:50 <lambdabot> Not in scope: `withFile'
09:35:53 <hape01> yep!
09:35:55 <mm_freak> :t System.IO.withFile
09:35:56 <lambdabot> forall r. FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
09:36:00 <confusing> Peaker: btw, i'm a firm xmonad fan, but you're right about all your criticisms
09:36:28 <mm_freak> hape01: and whenever you're compelled to write "\x -> f x", that's just the same as "f" =)
09:36:55 <Peaker> confusing, the most important one (easy config) should be easy to fix
09:37:03 <Peaker> confusing, just wrap the config API with a sane one
09:37:23 <donri> \x -> flip (`f`) x
09:37:26 <Peaker> confusing, I think exporting (Config->Config) functions and just composing them with (.) could be a simple way to manage most extensions?
09:37:38 <donri> uuh ^_^
09:38:04 <confusing> Peaker: that's true. some extensions do that, but not all of them (not nearly)
09:38:06 <statusfailed> mm_freak: With netwire, are there any easy methods for dealing with 'stateful' wires that might need to be saved/persisted/loaded ?
09:38:16 <confusing> Peaker: i think it's a promising approach
09:38:25 <geekosaur> right, theres some movement in that direction but a lot of existing stuff
09:38:27 <Qtr> donri: nope, other uni, CS though. How old are you? I thought you went to uni since you know Haskell?
09:38:58 <donri> confusing's nick is reflective
09:39:11 <mm_freak> statusfailed: nope…  i tried to implement that once, but failed…  however, there is no cloud haskell, which has an interesting way to serialize functions, so i might give it another try
09:39:13 <donri> Qtr: i haven't finished high school yet :)
09:39:37 <mm_freak> statusfailed: i'm very interested in serializable wires, too, so you can expect me to put some work into that =)
09:39:37 <confusing> donri: "reflective" sounds like a cat looking quizzically into a mirror ...
09:39:47 <Peaker> confusing, config = xfce4config { someCrap = Ext1.f (someCrap xfce4config), otherCrap = Ext1.g ||| (otherCrap xfce4config) }  :-((((((((((
09:39:59 <donri> confusing: :) i meant in the sense "self-descriptive"
09:40:04 <mm_freak> s/no cloud haskell/now cloud haskell/
09:40:29 <luite> donri: do you have to finish high school first or can you still be accepted at some uni with some exam?
09:40:29 <statusfailed> mm_freak: hmm, I guess that is a legit approach, but it seems like a bit of a sledgehammer
09:40:49 <donri> luite: probably need certain grades at least, that i'm lacking
09:40:59 <luite> aw :(
09:41:09 <confusing> donri: i was hoping that people would say things like "confusing: that tutorial is really clear and straightforward" ;)
09:41:17 <confusing> (when i chose the nick)
09:41:17 <Qtr> donri: so when did you start programming and when did you start haskell?
09:42:06 <donri> Qtr: hm, i did some c++ with my teacher's husband at 12 i think... got serious with haskell last year
09:42:45 <mm_freak> statusfailed: yeah, but the opportunities would be amazing
09:43:00 <mm_freak> think of having proper savegames with a single line of code
09:43:11 <mm_freak> or a web framework with persistent user sessions
09:43:41 <bitonic> continuation-based web frameworks are nice
09:43:58 <statusfailed> mm_freak: fair point, that does sound nice... that paper seems to suggest that their serialization exists already?
09:44:03 <statusfailed> Is that as a compiler extension?
09:44:21 <mm_freak> statusfailed: nope, it's entirely library code =)
09:44:30 <mm_freak> see the 'remote' or 'distributed-process' packages
09:44:35 <mm_freak> the Closure type in particular
09:44:51 <mm_freak> this would not only allow persisting, but also distributing wires =)
09:45:02 <mm_freak> x . y, now x can be remote =)
09:45:07 <statusfailed> that's effing magiiic
09:45:29 <mm_freak> bitonic: i'm working on a CPS snaplet, which i'm planning to release this week
09:45:51 <donri> speaking of which; would FP at chalmers still be rewarding if you're not a complete haskell newb?
09:46:12 <donri> or will it be like java in high school all over again; "this is an if statement"
09:46:33 <bitonic> mm_freak: that's cool, but I guess they would not be persistent
09:46:45 <mm_freak> bitonic: that's exactly the main problem
09:46:49 <bitonic> yeah
09:47:14 <mm_freak> in a web framework you can decide how much you want to persist, but in something like FRP you can't really do that
09:47:14 <bitonic> you can't really do that without compiler support unless you're using lisp
09:47:39 <mm_freak> bitonic: it's not that bad, but you need to be explicit about persistence
09:48:01 <bitonic> mm_freak: the problem I was thinking about is persisting functions, at all
09:48:08 <bitonic> how are you going to do that?
09:48:51 <stepcut> mm_freak: did you see this, http://projects.haskell.org/operational/examples/WebSessionState.lhs.html
09:49:12 <Nimatek> donri: Looks like they have three different courses.
09:49:19 <luite> donri: wah you had java in high school?
09:49:31 <Nimatek> http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/Courses
09:49:36 <statusfailed> luite: my thoughts exactly!
09:50:06 <Nimatek> We only had C, as an elective.
09:50:07 <mm_freak> stepcut: i didn't, but that's almost exactly how my code works, although i'm using a Coroutine monad as my basis
09:50:27 <bitonic> we had no programming in high school!
09:50:36 <mm_freak> bitonic: i'm not going to right now…  i'll investigate cloud haskell further to see how it works, then i'll give it a shot
09:50:53 <bitonic> mm_freak: OK.  because that alone opens up a lot of possibilities
09:51:03 <stepcut> mm_freak: neat
09:52:04 <donri> luite: yea. i had never done java before and knew more than the teacher.
09:52:45 <statusfailed> stepcut, bitonic: found this: http://www.haskell.org/pipermail/haskell-cafe/2006-July/016986.html
09:52:47 <luite> donri: still interesting that you did any programming at all
09:52:59 <statusfailed> link leads nowhere though :\
09:53:02 <donri> luite: it was an IT-oriented school
09:53:07 <bitonic> statusfailed: YHC is pretty much dead
09:53:26 <stepcut> I wrote a SWF backend for YHC once :)
09:53:46 <stepcut> it target the actionscript bytecode, not actionscript itself
09:53:47 <donri> luite: i also took classes in networking, which turned out to be a class in active directory... adding users and assigning roles in a windows gui.
09:53:48 <statusfailed> Ah, that explains it. I wonder why the serialization went nowhere though?
09:54:05 <allsystemsarego> @src nub
09:54:05 <lambdabot> nub = nubBy (==)
09:54:06 <mm_freak> statusfailed: the idea in my case is just like cloud haskell:  a closure type that gives functions an internal name…  then you don't need to send functions, just their ids, because you're assuming that the same program runs on both ends
09:54:19 <donri> Nimatek: ah thanks for link :)
09:54:21 <allsystemsarego> @src nubBy
09:54:21 <lambdabot> nubBy eq []             =  []
09:54:21 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:54:32 <mm_freak> this saves traffic and also allows serialization
09:54:32 <statusfailed> mm_freak: right- but how do you "unpack" the closures?
09:54:35 <stepcut> statusfailed: have you seen the paper on mobile Haskell ?
09:54:37 <mm_freak> even of partially applied functions
09:54:39 <statusfailed> stepcut: nope
09:55:01 <luite> donri: ah
09:55:01 <mm_freak> statusfailed: you need an online store of those functions…  i can make this implicit
09:55:18 <statusfailed> mm_freak: An online store? Sorry, you've lost me there :)
09:55:20 <stepcut> statusfailed: "towards mobile haskell" and "implementing mobile haskell" i believe
09:55:27 <statusfailed> cheers
09:55:28 <mm_freak> stepcut: online = in memory
09:55:31 <Nimatek> donri: That's difficult, I tried to assign roles in XP once. As someone who doesn't use Windows, I didn't expect that the XP control panel doesn't actually let you do that.
09:55:34 <mm_freak> uhm
09:55:39 <stepcut> statusfailed: it could pack up partially evaluated thunks and since them around the network
09:55:39 <mm_freak> @ statusfailed, not stepcut
09:55:42 <statusfailed> mm_freak: What about if I were to have a GHCI interpreter class reading in new functions? :)
09:56:02 <mm_freak> statusfailed: that won't work, unless you read the same functions on the other end
09:56:03 <statusfailed> s/class/module ?
09:56:09 <donri> Nimatek: heh; this was win 2k3 server though iirc. loads of advanced tools for that. but not what interested me, personally.
09:56:25 <mm_freak> statusfailed: anyway, all of this is hypothetical…  i haven't really put much thought into it yet
09:56:36 <statusfailed> mm_freak: How would you generate the ids from the functions? I'm guessing this would have to be explicitly handled somewhere? (not that it's a problem)
09:56:53 <mm_freak> statusfailed: handled yes, but not explicitly
09:57:22 <mm_freak> statusfailed: i guess it will be another Reactive arrow
09:57:48 <stepcut> mm_freak: read the 'mobile haskell' papers. :)
09:58:03 <mm_freak> stepcut: ok, thanks =)
09:58:26 <k0ral> hi, is there a an equivalent of MonadError for which the binding operator would break on success and forward the input on error ?
09:58:57 <k0ral> the idea is to write "do this, if it fails, then try this, if it still fails, try that, etc."
09:59:09 <k0ral> without having to write catchError each time
09:59:22 <latro`a> that somewhat resembles a function I wrote recently
09:59:27 <latro`a> except with new tries
09:59:36 <mm_freak> k0ral: you want Alternative
09:59:38 <statusfailed> mm_freak: I'm still not 100% clear on how you'd unpack partially applied functions, but I have to go buy groceries :P
09:59:40 <latro`a> but that uses just Either, so it might be simpler than you want
09:59:44 <latro`a> ah yes, that
09:59:53 <mm_freak> k0ral: a MonadError is likely also an Alternative (or MonadPlus if you wish)
10:00:00 <k0ral> I like being told what I actually want
10:00:09 <latro`a> (the function in question: eitherCycle lf rf m = either (\l -> lf l >> eitherCycle lf rf m) rf =<< m )
10:00:13 <mm_freak> k0ral: i think you want Alternative =)
10:00:15 <hpaste> hape01 annotated “works but ugly” with “using withFile” at http://hpaste.org/72344#a72348
10:00:38 <mm_freak> statusfailed: if the arguments are serializable you can store them along with the closure
10:00:42 <mm_freak> or as part of it actually
10:00:43 <latro`a> (I was using this mostly for user input error loops)
10:00:46 <identity>                 http://hpaste.org/72344#a72348
10:00:49 <identity> eh, sorry.
10:01:07 <k0ral> @hoogle Alternative
10:01:07 <lambdabot> Control.Applicative class Applicative f => Alternative f
10:02:04 <mm_freak> k0ral: a <|> b <|> c
10:02:13 <mm_freak> if a fails, try b, if b fails, try c
10:02:21 <mm_freak> and 'empty' always fails
10:02:32 <k0ral> how does that play with functions in MonadError ?
10:02:40 <parcs`> k0ral: there's also EitherR from the 'errors' package, where >>= is literally catchError
10:02:41 <mm_freak> it doesn't
10:03:12 <mm_freak> > Nothing <|> Just 4 <|> Just 5
10:03:13 <lambdabot>   Just 4
10:03:27 <mm_freak> > empty <|> pure 4 <|> pure 5 :: Maybe Integer
10:03:28 <lambdabot>   Ambiguous occurrence `empty'
10:03:29 <lambdabot>  It could refer to either `Control.Applicative...
10:03:48 <mm_freak> > Control.Applicative.empty <|> pure 4 <|> pure 5 :: Maybe Integer
10:03:50 <k0ral> > throwError 1 <|> throwError 2 <|> 1
10:03:50 <lambdabot>   Just 4
10:03:51 <lambdabot>   No instance for (GHC.Num.Num (f a))
10:03:51 <lambdabot>    arising from a use of `e_1121' at <i...
10:03:58 <k0ral> > throwError 1 <|> throwError 2 <|> return 1
10:03:59 <lambdabot>   No instance for (GHC.Show.Show (f a))
10:03:59 <lambdabot>    arising from a use of `M7011873094...
10:04:12 <mm_freak> :t throwError
10:04:13 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
10:04:18 <mm_freak> k0ral: add a type signature
10:04:28 <mm_freak> > throwError 1 <|> throwError 2 <|> return 1 :: Maybe Integer
10:04:29 <lambdabot>   No instance for (Control.Monad.Error.Class.MonadError
10:04:29 <lambdabot>                     t...
10:04:39 <mm_freak> > throwError 1 <|> throwError 2 <|> return 1 :: Either String Integer
10:04:40 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
10:04:40 <lambdabot>    arising from the literal `...
10:04:50 <mm_freak> > throwError "x" <|> throwError "y" <|> return 1 :: Either String Integer
10:04:51 <lambdabot>   Right 1
10:05:37 <k0ral> hmmmm
10:06:22 <k0ral> > runErrorT $ throwError "x" <|> throwError "y" <|> return 1 :: (MonadError String m) => m Integer
10:06:22 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
10:06:23 <lambdabot>         against inf...
10:06:53 <k0ral> I don't want to have an explicit MonadError
10:10:04 <mm_freak> i think i have never used MonadError
10:10:15 <mekeor> @src MonadError
10:10:16 <lambdabot> class (Monad m) => MonadError e m | m -> e where
10:10:16 <lambdabot>     throwError :: e -> m a
10:10:16 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
10:11:31 <k0ral> well, we can consider I "only" have a MonadPlus
10:12:06 <mm_freak> MonadPlus is somewhat awkward to work with…  i always prefer Alternative over MonadPlus
10:12:44 <MagneticDuck> I recently took a break from learning haskell to learn linux and bash and all that stuff
10:13:08 <k0ral> there's a bridge from MonadPlus to Alternative
10:13:13 <MagneticDuck> (btw brace yourselves because this will be off-topic)
10:13:45 <MagneticDuck> I wonder if it's just me.. but "bash" seems to be a tad disorganized
10:13:58 <MagneticDuck> a bunch of features taped together
10:14:06 <MagneticDuck> I wish it was more like haskell
10:14:08 <mm_freak> MagneticDuck: most shells are like that
10:14:13 <MagneticDuck> yeah I see
10:14:25 <k0ral> MagneticDuck: I used to wish that too, I once started implementing something like a haskell shell
10:14:25 <mm_freak> i'm using zsh…  while it is very useful it suffers from the same syndrome
10:14:45 <mm_freak> that's probably why shell development is so slow
10:14:48 <k0ral> MagneticDuck: I ended up concluding that bash and haskell don't serve the same needs
10:14:59 <MagneticDuck> hmm
10:15:11 <MagneticDuck> well, bash (and the other shells too) are powerful
10:15:19 <MagneticDuck> they serve their purpose more or less
10:15:20 <MagneticDuck> but..
10:15:33 <MagneticDuck> I see so many things that could be made so much more correct
10:15:36 <k0ral> MagneticDuck: when writing a commandline, you want the shortest command possible, and you somewhat expect bash to "do what you mean"
10:15:53 <mcstar> ask any molluscs, they develop shells very slowly
10:15:59 <MagneticDuck> it seems like a bunch of people made something without thinking and then kept adding features until it was powerful enough
10:16:16 <k0ral> MagneticDuck: trying to lift shells to something as clean as Haskell would result in a more verbose (then tedious) shell language
10:16:20 <MagneticDuck> granted, I don't know much about the bash x)
10:16:27 <MagneticDuck> hm
10:16:37 <MagneticDuck> there has to be some way around it
10:17:04 <k0ral> MagneticDuck: if you figure it out, please let me know
10:17:07 <MagneticDuck> okay then
10:17:08 <MagneticDuck> ^^
10:17:15 <k0ral> for example
10:17:41 <k0ral> would you really bear writing quotes around every commandline string ?
10:17:53 <MagneticDuck> well..
10:17:59 <mm_freak> MagneticDuck: that's the duct tape programmer =)
10:18:00 <MagneticDuck> at least in bash, you use a lotta quotes
10:18:10 <mm_freak> shells suck, but they work =)
10:18:11 <MagneticDuck> mm_freak: haha, yeah
10:18:37 <k0ral> MagneticDuck: well, you don't write quotes around every file path, right ?
10:18:38 <mcstar> powershell is based on as400, it is a 'typed' shell so to speak, piping is not pure text, more liek structured data
10:18:40 <confusing> MagneticDuck: i think you're right that it's ridiculous complicated syntax taped together in an adhoc way (i mean seriously, double semicolon? come on). i think for the role of shell scripts, haskell is pretty good, and with a library or two it gets really good. for the role of interactively inputting one line of relatively simple commands, the current shells are sufficient
10:18:41 <MagneticDuck> or how [[ parses better than [, even though they mean to do the same thing, because [[ is a key word
10:18:43 <k0ral> MagneticDuck: in Haskell, you would have to
10:19:31 <confusing> in my experience, shell scripts longer than let's say 10 lines are not worth it, in terms of being unmaintainable and brittle
10:19:39 <MagneticDuck> anyone up to recreating a whole new platform using haskell as a base language? :D
10:19:45 <mcstar> [ is a program
10:19:48 <MagneticDuck> yes
10:19:58 <k0ral> to me, shell are only good at oneliners
10:20:31 <MagneticDuck> I can no longer live without the correctness of haskell in my programs
10:20:33 <confusing> koral: yup, that's basically what i'm saying :)
10:20:37 <MagneticDuck> shell scripts make me flinch
10:20:52 <confusing> MagneticDuck: yup, that's *also* basically what i'm saying :)
10:21:17 <MagneticDuck> confusing: haha, lots of people talking at once, I usually miss a few lines
10:21:46 <EvanR> is there any security risk with the policy of replacing unvalid bytes with some dummy character when decoding utf8 data
10:22:00 <EvanR> i.e. lenientDecode :: OnDecodeError
10:22:10 <confusing> MagneticDuck: no i didn't mean to criticize, i meant to say we are all agreeing vigorously
10:22:11 <mcstar> "PowerShell differs from Unix/Linux in that structured .NET objects are passed between stages in the pipeline instead of typically unstructured text. Using objects eliminates the need to explicitly parse text output to extract data."
10:22:30 <MagneticDuck> anyway.. back to learning bash stuffez
10:22:34 <MagneticDuck> :'(
10:22:45 <MagneticDuck> I feel like I have to learn it
10:22:57 <EvanR> mcstar: so haskell is the algebraic data version of powershell ;)
10:22:59 <mcstar> it is handy to know it
10:23:10 <MagneticDuck> yes it is
10:23:18 <barrucadu> Knowing bash is certainly very useful (and possibly essential for good Linux usage), but once you know it, other shells that have saner behaviour are nicer to use
10:23:23 <MagneticDuck> then.. back to blissful haskell
10:23:35 <MagneticDuck> actually, there's a reason why I stopped programming in haskell for a bit
10:23:49 <MagneticDuck> I was starting to work in eclipseFP
10:24:03 <MagneticDuck> and had a bunch of problems
10:24:13 <MagneticDuck> and realized I didn't know what cabal was..
10:24:14 <confusing> MagneticDuck: i think you really just need to know ctrl-a, -e, -r, -u, -y and -z, and "sudo !!", and maybe "echo !$" :)
10:24:25 <MagneticDuck> and then realized that I didn't know bash...
10:24:28 <MagneticDuck> or how linux worked..
10:24:39 <MagneticDuck> so, here I am a week later learning everything from the ground up
10:24:50 <MagneticDuck> confusing: haha, perhaps
10:25:07 <mcstar> bash is not linux, thats just a shell
10:25:10 <MagneticDuck> yes
10:25:25 <k0ral> mm_freak: Alternative seems great but I can't get it to play with MonadError easily :(
10:25:25 <MagneticDuck> but to learn linux, you might as well learn a shell
10:25:31 <confusing> barrucadu: interesting, what shells are those? i'm kinda looking
10:26:00 <barrucadu> confusing: I like zsh, it doesn't split variables with spaces in in a command line (eg, so you can doo foo $bar rather than foo "$bar")
10:26:02 <mcstar> MagneticDuck: well, i want to make a distinction there, 'to learn linux' means to write kernel stuff for me
10:26:08 <mcstar> write to learn*
10:26:10 <barrucadu> confusing: It also adds arrays so you can get that behaviour
10:26:12 <mcstar> learn to write*
10:26:27 <levi> For an interesting take on a replacement shell for scripting rather than commandline usage, see scsh (the Scheme Shell).
10:26:56 <levi> It's even got an awk-like embedded DSL within it.
10:26:57 <mcstar> isnt scsh unmaintained? and only for 32 bis?
10:26:58 <confusing> barrucadu: right, i've noticed that zsh has, uh, real variables 8-) which don't fall apart spontaneously, if they ever contain something as exotic and terrible as a space ;)
10:27:28 <levi> I'm suggesting to look at it to mine ideas, not necessarily to use it.
10:27:33 <confusing> ... but i didn't feel zsh was that much of an improvement over bash. i tried to write a new completion once with the completion system, and -- oh god
10:28:56 <romm> hi. what's the easiest way to generate a random rational number in some range?
10:29:18 <EvanR> :t randomR
10:29:19 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
10:29:26 <EvanR> use that
10:29:30 <EvanR> heh
10:29:35 <EvanR> :t randomRIO
10:29:36 <lambdabot> forall a. (Random a) => (a, a) -> IO a
10:29:46 <latro`a> for just one, RandomRIO is easier
10:29:57 <EvanR> randomRIO (3%4, 7%8)
10:30:11 <latro`a> > randomRIO (3%4,7%8)
10:30:12 <lambdabot>   No instance for (System.Random.Random (GHC.Real.Ratio t))
10:30:12 <lambdabot>    arising from a...
10:30:15 <latro`a> :|
10:30:21 <romm> by the way, if anyone here is a dev, the library documentation is horrible for beginners.
10:30:27 <romm> like, seriously bad.
10:30:30 <latro`a> guess you'd have to toRational
10:30:31 <S11001001> no running io latro`a
10:30:33 <latro`a> or something
10:30:38 <EvanR> romm: let the types guide you
10:30:41 <latro`a> ah right
10:30:48 <latro`a> but that's not the problem, S11001001
10:30:49 <c_wraith> romm: really? seemed amazingly simple to me.
10:30:52 <latro`a> (in this one case)
10:31:05 <confusing> levi: good tip, i need to check it out
10:31:05 <EvanR> apparently Rational has no Random instance
10:31:16 <latro`a> could make one I guess
10:31:19 <EvanR> heh
10:31:22 <EvanR> good luck
10:31:26 <latro`a> um
10:31:32 <latro`a> you just toRational the Double one
10:31:33 <levi> If nothing else, read the first couple pages of the scsh manual.  It's hilarious.
10:31:39 <romm> wait, you guys mentioned several suggestions
10:31:40 <latro`a> and use fromRational to deal with the ranges
10:31:44 <EvanR> latro`a: if youre ok with the statistical implications of that
10:31:51 <latro`a> true
10:31:53 <latro`a> not wonderful
10:31:57 <k0ral> I can't get text-icu functions to work with ByteString.Lazy, it requires strict version, why is that so ?
10:32:01 <latro`a> but it depends how exactly you want it distributed
10:32:11 <latro`a> you certainly don't want it distributed over Z x Z
10:32:18 <latro`a> followed by division
10:32:20 <latro`a> that's much, much worse
10:32:24 <EvanR> Random class is supposed to be for uniform distribution
10:32:40 <latro`a> yeah but uniform over what
10:32:43 <romm> c_wraith: yes. see http://docs.python.org/library/random.html for how documentation should look like. examples, verbose. user friendly.
10:32:51 <mcstar> haskell has excellent documentation
10:32:53 <EvanR> and a literally random rational number is like choosing a random uniformly distributed natural
10:32:58 <mcstar> ghc/hackage whatever
10:33:07 <latro`a> this is true, this is why I mentioned ranges
10:33:27 <EvanR> latro`a: for rational it doesnt matter what the range is, as long as its length isnt 0
10:33:29 <luite> latro`a: you have a countable infinity of rationals in that interval, so just write an instance first that chooses a natural number uniformly :p
10:33:35 <identity> if I wanted to install a more recent version of the haskell platform on windows, should I remove the old one first or is that something that either doesn't matter or is automatically dealth with?
10:33:37 <mm_freak> k0ral: what's the matter?
10:33:41 <EvanR> luite: good call
10:33:45 <latro`a> the same problem for doubles, EvanR
10:33:54 <EvanR> not the same problem for doubles
10:33:55 <romm> EvanR, so what's your suggestion?
10:33:59 <latro`a> oh wait
10:34:05 <latro`a> because arbitrary precision
10:34:10 <latro`a> I was thinking of Ratio Int for some reason
10:34:19 <latro`a> which doesn't have those problems
10:34:30 <EvanR> romm: choose c) give up because you realize what you want does not make mathematical or logical sense
10:34:46 <EvanR> congratulations you are a wizard
10:35:15 <EvanR> latro`a: well you said rational so i was thinking actual rationals
10:35:16 <EvanR> Q
10:35:33 <confusing> romm: you're absolutely right that haskell's haddock pages are usually poor. that's a drawback for haskell. in general, try to google for the topic you're interested in, and check stackoverflow answers, papers, tutorials, blog posts ... i think the haddocks are often no good for learning something new, only when you already know what you need
10:35:36 <latro`a> I didn't have it lowercase uniformly
10:35:36 <k0ral> mm_freak: I wish there were: (MonadError e m) => Alternative m
10:36:09 <romm> EvanR: okay, then what would you suggest for an integer generator. for instance in the [1,1000] range
10:36:10 <mm_freak> k0ral: oh, i wouldn't wish that =)
10:36:17 <EvanR> latro`a: pick a divisor then get a random numerator between 0 and N-1
10:36:24 <k0ral> mm_freak: why so ?
10:36:30 <EvanR> then multiply or whatever
10:36:35 <latro`a> you don't want to pick a divisor, that has ugly statistics too
10:36:49 <EvanR> romm: randomRIO (0,1000)
10:37:09 <mm_freak> k0ral: because you would be flooded with overlapping instances
10:37:35 <romm> confusing: i'm not trying to flame or anything, but if i need to go to google/irc for someone to tell me randomIO (x,y) then something is bad.
10:37:45 <romm> EvanR: thanks.
10:37:57 <mcstar> you dont have to
10:38:04 <EvanR> or just replace every instance of using your generator with 448
10:38:09 <latro`a> FWIW that much is somewhat clear from the type
10:38:10 <mcstar> i seriously found the documentation very good as a total newbie
10:38:14 <parcs`> romm: yes, bad, but bad on what side? ;)
10:38:18 <latro`a> like
10:38:20 <mm_freak> k0ral: that's why FlexibleInstances is a mistake in most cases
10:38:22 <EvanR> romm: it says it right there in the doc
10:38:32 <statusfailed> mm_freak: (very late reply): Do you mean it's possible to serialize, say, (+1) without having compiler support?
10:38:35 <mm_freak> i feel bad when i have to use FlexibleInstances
10:38:36 <latro`a> almost all the other Random functions pass the generator as a state
10:38:43 <mm_freak> statusfailed: i don't think so
10:38:47 <mm_freak> statusfailed: not implicitly at least
10:38:50 <statusfailed> ah ok
10:38:50 <latro`a> if you don't want to do this, which you don't if you only want one number
10:38:52 <k0ral> mm_freak: what about FlexibleContexts ?
10:38:56 <latro`a> then you want one of the things that just returns IO a
10:38:56 <EvanR> > show "(+1)"
10:38:57 <romm> EvanR: it says exactly this: "A variant of randomR that uses the global random number generator (see Random)."
10:38:58 <lambdabot>   "\"(+1)\""
10:38:59 <latro`a> and there are only two of those
10:39:00 <EvanR> serialized
10:39:00 <mm_freak> k0ral: that one is fine usually
10:39:06 <romm> seriously the most useless explanation.
10:39:12 <statusfailed> EvanR: thanks for that :P
10:39:39 <parcs`> romm: what?
10:39:49 <k0ral> @hoogle Data.ByteString.Lazy -> Data.ByteString
10:39:49 <lambdabot> Parse error:
10:39:49 <lambdabot>   Data.ByteString.Lazy -> Data.ByteString
10:39:49 <lambdabot>       ^
10:39:50 <latro`a> romm--not really, Random is mostly designed around the pseudorandom sequence functions, which are everything except randomIO and randomRIO
10:39:52 <romm> mcstar: possibly. it wasn't clear to me, and maybe i'm in a minority, but i'm not the only one.
10:39:56 <confusing> romm: yeah no worries :) i meant to express sympathy and some tips, and i recognize the problem and plan to work on it. (already have some notes written up)
10:40:09 <latro`a> where I agree with you is that there should be examples
10:40:21 <mcstar> there is ghci
10:40:29 <mcstar> get the types right and it will work
10:40:33 <EvanR> if you arent used to haskells polymorphic return types
10:40:36 <EvanR> it could be confusing
10:40:37 <statusfailed> l
10:40:41 <statusfailed> oops
10:40:41 <parcs`> romm: it says randomRIO is a variant of randomR. did you read the randomR documentation, and did you click on the System.Random hyperlink and read that?
10:40:47 <EvanR> 'how do i get a random Int'
10:40:49 <EvanR> randomIO
10:40:53 <EvanR> 'how do i get a random Float'
10:40:55 <EvanR> randomIO
10:40:56 <EvanR> etc
10:41:00 <jimi_hendrix> is there a haskell debugger so i can set breakpoints and examine variable contents and stuff?
10:41:14 <EvanR> jimi_hendrix: ghci maybe
10:41:24 <parcs`> "Takes a range (lo,hi) and a random number generator g, and returns a random value uniformly distributed in the closed interval [lo,hi], together with a new generator. It is unspecified what happens if lo>hi. For continuous types there is no requirement that the values lo and hi are ever produced, but they may be, depending on the implementation and the interval.
10:41:31 <parcs`> There is a single, implicit, global random number generator of type StdGen, held in some global variable maintained by the IO monad. It is initialised automatically in some system-dependent fashion, for example, by using the time of day, or Linux's kernel random number generator. To get deterministic behaviour, use setStdGen.
10:41:35 <donri> oh ranges, that's what randomR does. i didn't understand the documentation for it before ^_^
10:41:42 <romm> ^
10:42:00 <donri> "lo, hi" yea because "low, high" is too verbose?
10:42:12 <identity> if I wanted to install a more recent version of the haskell platform on windows, should I remove the old one first or is that something that either doesn't matter or is automatically dealth with? Any takers?
10:42:26 <EvanR> 'the documentation sucks' is different from 'i dont understand the documentation'
10:42:28 <romm> parcs`, what's the random generator it returns? why does it return it? how do i use it, and for what?
10:42:49 <latro`a> romm--so that you can get a pseudorandom sequence by passing the new generator to the next call
10:43:07 <mcstar> closed interval [cats,dogs]; cats>dogs => unspecified, you can substitute lo,hi with whatever you want, doesnt change the semantics
10:43:08 <romm> why can't i use the same generator to get a new number?
10:43:10 <EvanR> romm: you just sound like you havent had any experience working with RNGs before
10:43:12 <parcs`> romm: please disambiguate 'it'
10:43:38 <EvanR> RNG needs a state, which changes
10:43:42 <EvanR> in haskell values are immutable
10:43:56 <donri> mcstar: but it makes you think it means something, something meaningful that you don't understand
10:44:03 <EvanR> so state has to be changed via functions of the form s -> (a,s) where a is the answer and s is the type of the state
10:44:20 <romm> EvanR: okay. so here is the core of it. it has nothing to do with my knowledge of RNGs, but my lack of knowledge in haskell.
10:44:20 <donri> mcstar: (which, incidentally, it does)
10:44:35 <jimi_hendrix> EvanR, yeah, but i want to examine stuff in the middle of a function
10:44:40 <romm> i think that there's a point in being a bit more verbose for beginners in these things.
10:44:53 <EvanR> jimi_hendrix: Debug.Trace
10:45:08 <latro`a> romm--for this particular example I don't really see why. What is a bit troubling is that Random somewhat assumes familiarity with the style of State
10:45:19 <mcstar> donri: what i want to say, even if you didnt realize lo,hi meant low,high, the meaning was still clear from the context, they were used as the bounds of an interval
10:45:21 <latro`a> (i.e. Control.Monad.State)
10:45:21 <EvanR> romm: not every library can go and start explainined every aspect of the language
10:45:38 <latro`a> a link to Control.Monad.State wouldn't go amiss, tbh
10:45:47 <donri> mcstar: it's obvious if you already know the answer. -.-
10:46:05 <romm> latro`a, i see. it's my second day with haskell. i see that i basically can't write anything usefull until i know Monads.
10:46:06 <parcs`> romm: the documentation presupposes that you are familiar with the basics of haskell, including handling state
10:46:06 <EvanR> latro`a: System.Random doesnt have much to do with Control.Monad.State
10:46:10 <romm> which is a shame.
10:46:18 <EvanR> romm: System.Random has nothing to do with monads
10:46:20 <parcs`> @where lyah -- romm
10:46:20 <lambdabot> http://www.learnyouahaskell.com/
10:46:26 <EvanR> monads have not much to do with 'state'
10:46:44 <parcs`> look, there's even a whole section dedicated on randomness http://learnyouahaskell.com/input-and-output#randomness
10:46:45 <latro`a> it's not directly related, but it's set up to be convenient to use with State
10:46:58 <romm> sorry. i'm confusing them since i'm not familiar with both.
10:46:59 <EvanR> latro`a: not really
10:47:03 <EvanR> its not convenient
10:47:07 <avpx> ?
10:47:09 <EvanR> latro`a: however theres a MonadRandom
10:47:19 <mcstar> romm: second day? in that case be a little more forgiving to the docs, and learn haskell first, it takes time but it is worthwile
10:47:21 <latro`a> I'm thinking of that, yeah, which is more or less State anyways
10:47:29 <EvanR> yeah it is
10:47:42 <EvanR> but State StdGen would be harder to use
10:48:00 <avpx> System.Random is all about s -> (a,s), which happens to be the sorts of computations State helps you compose
10:48:33 <confusing> EvanR: nobody is demanding that random library pages explain all of the haskell language and idioms. but a few lines of actual example code in the haddocks would go a long way, and i'd argue are standard in good documentation
10:48:49 <EvanR> thats true, an example, which i admitted earlier
10:48:59 <romm> mcstar: that's why i'm trying to be a bit caucious with my criticism here. i only made suggestions. i'm sure there's at least something that can be done to improve.
10:49:09 <avpx> True, the unfortunate part about the haddock docs for most libraries is that they are only useful if you already have a good overview of how to use the library
10:49:15 <romm> for instance, examples. it's the bread and butter of good documentation.
10:49:17 <latro`a> examples, not extensive explanation, are probably for the best
10:49:25 <donri> +1
10:49:29 <c_wraith> I really hate examples.
10:49:32 <EvanR> 'the documentation is really really bad' is more than a suggestion
10:50:04 <mekeor> i'd say it's less actually :P
10:50:16 <latro`a> less meaningful, more critical
10:50:39 <c_wraith> examples are typically a sign of a bad api
10:50:40 <mekeor> agreed.
10:50:46 <confusing> it's an expression of his frustration, which imho is understandable
10:50:55 <romm> EvanR: are you going to pick me apart for that sentence now? i was frustrated.
10:51:14 <EvanR> again, the example isnt for telling you how to use a lib, it would be for people unfamiliar with haskell to understand why stuff even works
10:51:39 <parcs`> should documentation really be written to be understandable by someone who is 2 days in learning haskell?
10:51:45 <EvanR> the polymorphic function and the state update thing
10:52:04 <romm> parcs`, i think so. this is why python is a major player now. a good learning curve.
10:52:17 <donri> i'd say python tends to have more well-written docs than a lot of haskell packages, but haskell docs tend to be more useful once you understand some basics
10:52:25 <EvanR> python is simply similar to all other languages people usually start programming with
10:52:32 <latro`a> advanced python documentation is actually way too dense
10:52:47 <latro`a> erm, dense is the wrong word, extensive
10:52:54 <latro`a> it's hard to find a small thing you want to look up
10:53:03 <latro`a> because there's just endless text and examples
10:53:15 <donri> also true
10:53:18 <mcstar> romm: i think some ppl are just not used to learn a language from a book
10:53:24 <avpx> I'm having trouble getting ghcjs compiled. src/Cabal.hs imports Shelly.Find which is a hidden module of shelly
10:53:26 <EvanR> its hard because all those languages dont have a type system
10:53:29 <mcstar> they are used to 'hack things up' and work like that
10:53:34 <mcstar> haskell is a bit different
10:53:37 <mcstar> like list
10:53:41 <mcstar> lsp
10:53:43 <mcstar> lisp*
10:53:45 <donri> avpx: sounds like a version issue?
10:53:54 * mcstar goes away b4 he fails more
10:54:16 <donri> avpx: try giving cabal --constraint='shelly<0.13'
10:54:27 <avpx> donri: I thought so, but I looked at the various versions of shelly >= 0.9 on Hackage and none of them appear to export Shelly.Find
10:54:29 <romm> EvanR: okay, but i think that at least to some degree, haskell should be "evangelistic". you want people to learn it easily.
10:54:42 <avpx> donri: I'll try that anyway
10:54:54 <monochrom> natural selection implies that those who can learn by multiple ways do better than those who can learn by only one way
10:54:54 <donri> avpx: oh? i see that module for 0.12.*
10:54:56 <confusing> parcs`: there is no value in explaining everything everywhere (or trying to). in my opinion, example code helps someone with 2 days of experience as much as it helps someone with 2 decades
10:55:06 <EvanR> romm: even people who skip all the beginner material?
10:55:11 <avpx> donri: Oh really? My mistake.
10:55:59 <donri> avpx: also seems the same functions are now in Shelly.Pipe. you could also patch ghcjs
10:56:07 <avpx> donri: Yeah, that's a good idea.
10:56:11 <avpx> donri: Thanks a lot
10:56:17 <donri> good luck!
10:56:32 <donri> romm: avoid success at all cost!
10:57:07 <mcstar> thats haskell's motto
10:57:12 <EvanR> romm: since haskell is a lot different from the family of languages like C java js python etc its not going to be 'easily learned' like those, where people learning one already know the others that are basically the same
10:57:42 <latro`a> eh, EvanR, python at least (the language I started with) is easy enough to just pick up even without familiarity in other languages
10:57:42 <EvanR> learning after knowing nothing of programming at all might be easier, really ;)
10:57:50 <romm> EvanR: for instance, learnyouahaskell doesn't mention States etc. in the first 9 chapters.
10:57:53 <EvanR> latro`a: i daresay haskell is too
10:58:01 <EvanR> which is not what were talking abot
10:58:04 <latro`a> erm, I mean pick up from documentation
10:58:12 <latro`a> haskell is really not that hard to pick up from say LYAH
10:58:15 <latro`a> imo
10:58:27 <mcstar> latro`a: you actually have to read LYAH!
10:58:31 <merijn> latro`a: EvanR's point is that if you know python you don't really have to learn Java, ruby, etc.
10:58:32 <EvanR> romm: State the monad isnt really that important to what you were doing
10:58:37 <latro`a> that's true, merijn
10:58:48 <merijn> latro`a: Because they're so similar they're essentially the same, modulo syntax and minor quirks
10:58:55 <mcstar> and api
10:59:03 <merijn> Which often leads people to think that Haskell will be similarly trivial
10:59:07 <latro`a> ...that's...considerably stronger than it should be
10:59:20 <hape01> I think learning haskell from a book is as easy as learning czech from a book :-)
10:59:23 <latro`a> I see where you're coming from, but I'd phrase it much milder
10:59:35 <merijn> I suspect people who've learned something like APL, Forth or Lisp to be better prepared for the required paradigm shift
10:59:51 <EvanR> well the irc channel was really helpful to me
11:00:19 <latro`a> but @ romm, one minor annoying thing about the introductory material is that you really do need to start doing some IO to keep people interested, so a lot of introductory material start doing IO before giving a decent explanation of monads
11:00:24 <EvanR> so im biased against making 'learning using only library references' a thing
11:00:28 <latro`a> iirc even LYAH does this
11:00:30 <merijn> latro`a: It happens quite often that people in here act really confused and confrontational about haskell taking more effort than other languages if people already have a background in Java/C#/Python/Ruby/JS, etc.
11:00:42 <romm> EvanR: i understand it's not vital here, but i didn't understand the point of passing a generator to random etc., it's more of a "background knowledge" that would've helped me understand the docs.
11:00:51 <latro`a> that is true, but "essentially the same" is a very strong statement
11:00:53 <EvanR> latro`a: you dont need to 'undertstand monads' to use IO
11:00:56 <confusing> romm: haskell is exotic, and i can see how that is frustrating (i felt the same). this source of frustration is probably unavoidable. but you're right that another source of frustration is the bad state of most haddocks, and that source would be completely avoidable if haskell's culture were different
11:01:08 <latro`a> no, you don't, but you don't really know what's going on, and don't know why you're restricted
11:01:16 <merijn> latro`a: For given definitions of the same, for example Python and Ruby really are essentially the same.
11:01:23 <latro`a> python and ruby is an extreme example, imo
11:01:34 <latro`a> you mentioned python and C in the same sentence
11:01:48 <merijn> latro`a: That was EvanR, and that is a comparison I personally disagree with
11:01:56 <EvanR> i find the haddocs way easier to understand faster than other docs in other languages
11:02:00 <latro`a> even python and java
11:02:01 <merijn> C#, sure. But C is *really* different from python/riby
11:02:01 <BMeph> I'd also guess that those who already know APL, Forth or Lisp get steered to Haskell more quickly.
11:02:09 <merijn> BMeph: True :p
11:02:26 <mcstar> confusing: i think the point is that you have to think for yourself a bit, if some ppl dont, they get lost, haskell doesnt care
11:03:00 <c_wraith> I think that is why I hate examples.  They encourage copy&paste programming, instead of thinking.
11:03:12 <latro`a> depends on their size
11:03:16 <confusing> mcstar: i disagree, and i don't think that blanket insults ("if you can't think, haskell is not for you") help making haskell better
11:03:34 <romm> you guys have a really arrogant approach, i'm sorry to say.
11:03:36 <latro`a> "to get a single random value, use randomIO, like this:" could be in System.Random without much issue
11:03:57 <mcstar> confusing: it is more about perseverance, than cleverness
11:04:16 <mcstar> eveybody is almost created equal, but some give up earlier than others
11:04:22 <luite> c_wraith: hm, i don't really agree. examples often bring understanding faster than doing things from scratch
11:04:25 <merijn> romm: How so? In my experience most people here are rather helpful and humble, as long as people aren't confrontational (and even then they frequently are more so than other language communities)
11:04:45 <EvanR> mcstar: almost == not ;)
11:05:08 <applicative> romm, dont worry about it.  People get defensive when you seem to be dissing their language. There are only a couple genuine jerks who come through here.
11:05:16 <mcstar> confusing: do you think mathematics should be made easy as pie, just to make ppl happy by they thinking they undestand something which they dont?
11:05:19 <romm> merijn: they indeed helped me quickly.
11:05:48 <applicative> romm, everyone else  just wants to help you
11:05:49 <EvanR> the irc is really good place to resolve confusion
11:06:01 <romm> mcstar: no, but mathematics should be made *approachable*, so that people unfamiliar with it could get their feet wet.
11:06:26 <mcstar> romm: wrt haskell: thats why good books exist, really, just read them
11:06:40 <ReinH> Athas: ping
11:06:57 <merijn> I strongly disagree that mathematics is really that important (or even at all important!) for haskell
11:06:59 <confusing> merijn: how people handled romm and his question was *really* not one of #haskell's finest hours. he basically was frustrated, looking for sympathy and had a basic question. people whipped out the accusations and the arrogance
11:07:23 <mcstar> romm: apparently, you havent been to #lisp, this channel is VERY helpful (compared sometimes to the 'arrogance' of the other)
11:07:39 <EvanR> romm: as a beginner it might be more productive to solve your problems as quickly as you can and move on rather than dwell on possibility of other hypothetical people getting confused and not being able to get as far as you did...
11:07:54 <romm> mcstar, i'm reading learnyouahaskell. i'm in chapter 8 or 9. i thought that after half a book i can already write something useful, but apparently it's a bit too early.
11:08:07 <EvanR> this is definitely dwelling
11:08:17 <Kashyap> loop :: n -> IO ()
11:08:26 <Kashyap> loop 0 = return ()
11:08:30 <hape01> @src loop
11:08:30 <lambdabot> Source not found. It can only be attributed to human error.
11:08:47 <c_wraith> hape01: I'm not aware of any standard function with that name. What are you looking at?
11:08:55 <mekeor> how would you align this function?: http://codepad.org/oPTywaLJ – i really hate my indentation; i find the function so ugly!
11:09:01 <merijn> romm: I agree with you that the time from starting to writing something useful (where useful means with IO), is exceptionally long compared to other languages. But I also think that (in hindsight) it was totally worth it
11:09:05 <romm> EvanR, this is exactly the arrogant approach i mentioned earlier. thank you for subtly suggesting me how to plan my time.
11:09:18 <EvanR> romm: youre trolling
11:09:30 <merijn> romm: There is one quick way to get something useful fairly early on, though
11:09:35 <merijn> :t interact
11:09:36 <lambdabot> (String -> String) -> IO ()
11:09:46 <hape01> c_wraith: i confused that
11:10:02 <mekeor> gotta go… bye
11:10:12 <latro`a> no, EvanR, he's right, that was pushy
11:10:25 <confusing> EvanR: "solve things quickly and move on instead of improving docs" -- i disagree. i'd rather have it explained well, once and for all, instead of 1000 people having to piece together some unnecessary puzzle. (similar to how i'd rather have a function in a library rather than 1000 rolling their own halfbaked reimplementations)
11:10:35 <hpaste> Kashyap pasted “loop” at http://hpaste.org/72350
11:10:52 <merijn> romm: interact is a great function. Basically "main = interact foo" boils down to "treat stdin as one big string, run foo on that string and print it to stdout". Not as advanced as you'd like to write early on, but the easiest you can do without having to grok IO
11:10:53 <mcstar> romm: hey, dont be disappointed, just hang on, you will start confortable with the language, and at some point YOU will help others
11:11:03 <mcstar> start to feel *
11:11:16 <PatrickRobotham> Could anyone here recommend a good introduction to dependent types?
11:11:18 <Kashyap> I was wondering if the loop example I pasted is an example of lazy evaluation or not
11:11:26 <parcs`> romm: the thing is, you're the first to suggest that the System.Random documentation is lacking
11:11:27 <identity> Why does wxHaskell have to be such a pain to get working? :(
11:11:31 <identity> or rather, wxwidgets in general.
11:11:33 <identity> (On windows.)
11:11:59 <parcs`> (for as long as i've been on this channel, at least)
11:12:09 <ssbr-> identity: wxWidgets is hard to get working on any OS :(
11:12:17 <merijn> Kashyap: It's more an example of recursion than lazy evaluation
11:12:23 <latro`a> eh, not quite, parcs`, though I think most others have been like "hey how do I get a single random number easily? I really only need one" and then people say "randomIO or randomRIO" and then they say "oh cool thanks"
11:12:31 <merijn> Kashyap: Why do you ask?
11:12:32 <EvanR> confusing: this particular thing has been explained once, a million times across a variety of blogs logs tutorials and the doc
11:12:34 <donri> PatrickRobotham: i don't know how good they are but you might start here: http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Othertutorials
11:12:34 <latro`a> I've definitely seen that question several times in the last week alone
11:12:46 <mcstar> merijn: that loop example is a bit incomplete
11:12:49 <romm> merijn: i'll look it up, thanks. i don't see how is it different that just working with the ghci though
11:12:55 <PatrickRobotham> donri: Thank you.
11:12:55 <confusing> parcs`: i think it has more to do with people developing an attachment to the status quo, regardless of its drawbacks ...
11:12:56 <EvanR> confusing: some people obviously like to ask anyway
11:13:01 <Kashyap> merihn; I am simply trying to dig out examples where lazy evaluation makes things easy
11:13:11 <monochrom> if you use Richard Bird's book, after chapter 9 you will have written a text-mode rock-paper-scissor game, and understood why foldl (+) causes a stack overflow and how foldl' solves it. I don't know whether that is your idea of "useful". monad, however, comes conveniently right after that, in chapter 10.
11:13:26 <merijn> romm: Well, for one thing you can use it to implement simple unix commands like, wc, grep, cat, etc.
11:13:42 <parcs`> latro`a: but is that because the person didn't understand the module or because the person didn't bother understanding the module or the person didn't know the module existed?
11:13:57 <merijn> mcstar: Why? Looks like a perfectly fine loop to me
11:14:05 <parcs`> confusing: yeah, probably
11:14:14 <mcstar> merijn: btw, i didnt suggest formal mathematics is needed for haskell, i only brought it up as a non-trivial topic
11:14:27 <Kashyap> merijn:  I am simply trying to dig out examples where lazy evaluation makes things easy
11:14:28 <monochrom> I do like to harp my analogy of "if this is a Chinese class, do you expect to write a movie review in Chinese for a Chinese movie after chapter 9"
11:14:31 <latro`a> I think they knew it existed and just wanted to know a "shortcut"
11:14:42 <mcstar> loop :: n -> IO (); loop 0 = return () <= pretty useless
11:14:47 <merijn> Kashyap: Well, there's a nice (useless, but maybe illustrates something neat that hopefully gives you ideas) example
11:14:55 <merijn> mcstar: There's an IO () argument called a in there
11:14:56 <EvanR> language analogy to computer language annoys me though
11:15:26 <latro`a> randomIO, for *probably* being what you would use in a first use of Random, is somewhat hidden
11:15:30 <merijn> > let ones = 1 : ones in ones -- Infinite recursive structure
11:15:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:15:35 <confusing> parcs`: i think you have a point, but still, it'd go a long way if the System.Random page just stated the two lines "ghci> print =<< (randomRIO 0 100)" "42" or whatever the exact syntax is
11:15:50 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
11:15:52 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
11:16:04 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
11:16:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:16:19 <merijn> Kashyap: Laziness lets your data structures refer to themselves, like in those examples
11:17:02 <Kashyap> merijn: right ... and I can certainly use the infinite list in the context of Haskore ... to create an infinite rhythm
11:17:39 <romm> anyway, thanks for the help everyone.
11:17:40 <Kashyap> merijn: How about parsec -- does it depend on lazy evaluation for its elegance or simply higher order functions
11:18:26 <confusing> romm: you're welcome. sorry for people's behavior, this was not #haskell's finest hour. it's much better usually. check back when you hit your next question :)
11:18:27 <mcstar> you need lazy evaluation in haskell for cyclic data structures
11:19:05 <monochrom> it may also be awakening to see how much is really taught in 8 chapters of K&R (it has no chapter 9)
11:19:07 <merijn> Kashyap: I'm not really sure if there is (and if so, what) would be an example of parsec depending on laziness
11:19:24 <monochrom> by the end of K&R chapter 8, you can write part of "ls"
11:19:42 <confusing> monochrom: so you can write "l"? or "s"?
11:19:56 <romm> confusing: nah, it's cool. i deserved some smackin'. not to mention it's the price you pay for help on IRC :)
11:19:59 <Kashyap> merign: that would be good enough :) ... because parsec is "good" and if "good" depends on laziness - its good :)
11:20:00 <monochrom> no, listing a directory
11:20:31 <Kashyap> merijn: I looked up the parsec paper and it appears that it quotes laziness in a number of places
11:20:35 <Kashyap> I'll check it out
11:20:51 <merijn> confusing, romm: In general, it helps to ask questions here when you start getting frustrated, that way your frustration doesn't accendentally become antagonizing behaviour, in turn resulting in nicer answers :)
11:21:32 <monochrom> again, I am not sure what is your minimum threshold for "useful", but K&R chapter 8 does not land you a web server or a web app or a 3D game
11:21:54 <monochrom> I see no reason why another other introductory book is obliged to
11:22:16 <latro`a> also FWIW System.Random is discussed in great detail in chapter 9 of lyah >.>
11:24:04 <parcs`> confusing: yeah, i agree. now that i try to objectively study the documentation i can see how it would be frustrating/opaque to a beginner
11:24:32 <monochrom> P.S. Bird chapter 9 ends at page 323. K&R chapter 8 ends at page 189. LYAH chapter 9 is like, what page 20?
11:24:53 <monochrom> maybe amazon knows
11:25:00 <romm> monochrom, i'm not sure K&R should be your reference textbook in computer languages. anyway, in chapter 8 there you can already copy files.
11:25:02 <latro`a> by book page length standards? probably higher than that
11:25:18 <parcs`> monique_: 169
11:25:21 <parcs`> monocell: *
11:25:31 <parcs`> monochrom: * >_<
11:25:54 <parcs`> well, it ends at page 201
11:26:07 <monochrom> ok that's better
11:26:43 <monochrom> well yeah in Bird chapter 9 you already have a text-mode game
11:26:57 <monochrom> in chapter 7 you already know seq and stack overflow
11:27:40 <parcs`> same in lyah
11:27:54 <parcs`> in chapter 9 you have a "guess the random number" game
11:28:08 <monochrom> well there. K&R doesn't have a game
11:29:31 <parcs`> hmm, you also have a little todo program that can add, read and delete todo entries from a file
11:29:58 <confusing> parcs`: i think you're right, i'm looking at it now as well ... to a beginner's eye, there'd be lots of strange little things. "(see System.Random)", which a link to ... uh, exactly the page in front of me? hm no ...
11:30:03 <romm> parcs`: conclusion: i tried writing stuff one chapter too early :)
11:30:12 <confusing> and what's a continuous type anyway? :-/
11:30:41 <confusing> (i'm writing this down. let's see if i can come up with a documentation patch)
11:31:14 <parcs`> confusing: yeah that looks like a bug in haddock
11:33:36 <latro`a> anotherqmmqmmmmmmmmmmmmmmmb
11:34:51 * hackagebot optparse-applicative 0.3.0 - Utilities and combinators for parsing command line options (PaoloCapriotti)
11:35:02 <donri> yay new optparse-applicative
11:35:59 <applicative> i have to say, I think the standard texts and tutorials go wrong not beginning with IO and compilation.
11:36:33 <monochrom> Hudak's book has IO early
11:36:39 <applicative> I think I was flailing a bit til I came upon stepkut's tutorial, http://learnhaskell.blogspot.com/2007/09/lesson-1-hello-world.html
11:37:01 <applicative> There are some things I still do because of the way he did them.
11:37:20 <mcstar> like?
11:37:26 <monochrom> I also offer my own http://hpaste.org/52480
11:37:41 <applicative> -O2 is my preferred optimization flag for example
11:37:48 <Qtr> Damn it I want to write something usable in Haskell.
11:37:57 <applicative> it was imprinted on me on day 1
11:38:04 <mcstar> haskell takes quite long to compile with -O2
11:38:15 <merijn> Qtr: What's stopping you?
11:38:16 <mcstar> sry, meant to say ghc
11:38:18 <monochrom> really?
11:38:33 <Qtr> Like for Linux. What 1.5K-5K LOC program that all Linux users want isnt made yet(possibly because it is a boring program to write)?
11:38:37 <mcstar> monochrom: well, in comparison with ocaml, like 10 times?
11:38:39 <Qtr> merijn: ideas
11:38:54 <mcstar> monochrom: im not sure about the scaling though
11:39:01 <monochrom> I guess
11:39:06 <Qtr> can you google hackage from here?
11:39:11 <parcs`> Qtr: ideas are the hard part
11:39:12 <Qtr> @hoogle google
11:39:13 <lambdabot> Google rocks!
11:39:13 <lambdabot> package GoogleChart
11:39:13 <lambdabot> package GoogleDirections
11:39:17 <monochrom> well if -O is just right for you, we're all happy
11:39:22 <Qtr> ah just what i wanted, googlechart
11:39:29 <donri> @hoogle hoogle
11:39:29 <lambdabot> Can't think of anything more interesting to search for?
11:39:29 <lambdabot> package hoogle
11:39:41 <mcstar> while testing you dont want optimizations turned on i think
11:39:47 <mcstar> only at the final stage
11:40:00 <merijn> romm: As a (hopefully enlightening?) anecdote: It took me a handful of months to understand haskell, probably at least 2 more to *really* understand IO and then maybe half a year to grok the commonly used libraries for stuff like Applicative, Arrows, etc. Is this worth the time, you might ask.
11:40:19 <mcstar> (or if you are measuring performance and you are profiling you want -O2)
11:41:09 <applicative_> Qtr what kind of thing do you want to make
11:41:21 <monochrom> I am not convinced of not cranking up optimization until the final stage. it sounds way too waterfall
11:41:50 <mcstar> ymmv
11:42:02 <merijn> romm: 2 weeks ago I started rewriting our language runtime (couple hundred files, somewhere around 50k-100k lines of code) from C to haskell. Now I've been working with/on the C runtime for over a year and still changing relatively minor things takes me days, if not weeks. Rewriting in haskell from scratch got me to 70% of the functionality in 2 days and 300 lines of code
11:42:21 <applicative_> mcstar: the longer ghc takes to compile my module, the better I feel about it.  try -fspec-constr-threshold=1000
11:42:30 <luite> merijn: what kind of lang?
11:42:37 <Qtr> applicative: anything that people actually could use. doesnt have to be anything cool. just useful.
11:42:45 <confusing> merijn: yeah haskell gives a lot of bang for the line
11:42:47 <merijn> romm: Also, after benchmarking the unoptimized haskell runtime was about an order of magnitude faster.
11:42:53 <monochrom> if at the final stage, you crank up -O2, and the program is still too slow and uses too much memory, what do you do then?
11:43:10 <mcstar> profile
11:43:25 <confusing> merijn: seems like a very nice success story. do you have a blog? :-)
11:43:27 <parcs`> merijn: sounds like a pretty scary c program
11:43:30 <monochrom> well looking further, you will change your algorithms completely, no?
11:43:55 <monochrom> and if you change the algorithm, you have to test for correctness again, it's back to square one, no?
11:44:11 <merijn> romm: I fully agree and sympathise with the fact that learning how to do useful stuff in haskell takes a *long* time. But after having gone through it I can tell you with some confidence, that after reaching an "ok" skill in haskell will let you write fairly ambitious and complex programs in very little time.
11:44:16 <merijn> confusing: Not yet :p
11:44:21 <monochrom> I mean, how about knowing that your old algorithm is too slow earlier?
11:44:27 <mcstar> monochrom: as i said, when you need performance you turn on optimizations sometiems, but only to see if your program works/is correct, you dont need to turn it off, case it takes too much time
11:44:49 <merijn> parcs`: Academia, so that scary C program was hacked together by bachelor, master and grad students too. Imagine the horrors
11:44:49 <mcstar> cause*
11:44:49 <applicative_> mcstar: you don't turn on optimizations at all, mostly?
11:44:56 <mcstar> no
11:45:59 <merijn> luite: Coordination language for parallel programming
11:46:15 <mcstar> merijn: lol. i just read it, thats really some success story
11:46:30 <mcstar> are you using heavily some libraries?
11:46:48 * applicative_ remembers someone writing in a comment 'every time you compile without optimization someone in ghc hq sheds a tear'
11:46:59 <hpc> heh
11:47:08 <merijn> mcstar: Well, we're still figuring out the scaling. GC doesn't scale as well as the C runtime, but even then its a factor 2-4 faster than the original
11:47:39 <merijn> mcstar: Mostly it's just some ADTs combined with forkIO and MVars :p
11:47:44 <mcstar> merijn: what is increadible is the code size, thats why im asking, if you are bulding on some libs
11:48:10 <luite> merijn: ah
11:48:31 <merijn> mcstar: Well, I expect to double-triple the code size for the remaining 30% of features. But that's still in the order of a few k-lines, not tens of thousands
11:49:40 <merijn> mcstar: I looked at some of the CSP libraries for haskell, but in the end figuring out the API was a bit more cumbersome than implementing the few basic features I needed myself on top of Control.Concurrent
11:53:00 <avpx> luite: Hmm, I've been trying to build ghcjs, but type errors galore with http-conduit 1.5.0.3
11:53:46 <luite> avpx: yeah that's true, it has no version bounds for http-conduit yet and only works with 1.4
11:54:02 <maurer> Does anyone know how to say in a .cabal file "All the code is under license A, but the following list of data files are under license B" ?
11:54:21 <luite> avpx: i've already fixed that but need to dig up the commit
11:54:33 <bitonic> maurer: use the description?
11:54:36 <dcoutts> maurer: no, it's not that expressive. The best you can do is OtherLicense
11:54:45 <maurer> Yeah, I guess
11:54:46 <avpx> luite: I was trying to get it to support 1.5.0.3 but this Control.Monad.Trans.Control.MonadBaseControl stuff is really confusing.
11:54:55 <avpx> I can't figure out how to get the types to work out at all :-\
11:55:13 <luite> avpx: oh that's probably some other conflict between monad-control versions or transformers or something
11:55:30 <luite> avpx: i had the same error, but fixed it
11:55:53 <avpx> luite: Did you have to restrict the transformers version or something?
11:56:27 <confusing> maurer: the LICENSE file seems like the right place to say that stuff ...
11:56:29 <luite> avpx: hm, i forgot actually
11:56:41 <luite> avpx: i'll try to commit it later tonight
11:57:15 <avpx> luite: Okay. I also found that src/Cabal.hs and src/Boot.hs are both importing Shelly.Find, which they shouldn't
11:57:29 <luite> avpx: yeah that's the second thing, also already fixed
11:57:37 <avpx> Okay, good
11:58:57 <maurer> confusing: Yeah, I was wondering about the "OtherLicense" thing for purposes of metadata packaging
11:59:05 <maurer> Like, all the code I'm writing is BSD3
11:59:24 <maurer> but it will need the data dumps from http://community.eveonline.com/community/toolkit.asp to function properly
12:00:35 <avpx> luite: I'm interested to see how you fix the type problems, since I'm completely stumped right now with regards to the monad-control type errors.
12:04:31 <donri> maurer: if the licenses are compatible, you could always list the most restrictive license in cabal
12:05:57 <luite> avpx: ok committed
12:06:31 <luite> avpx: i hope it works, looks like i didn't commit the cabal file
12:06:46 <luite> you need shelly 0.13 and http-conduit 1.5
12:07:19 <latro`a> incidentally, since we were talking about bad documentation earlier
12:07:23 <latro`a> can anyone explain these
12:07:25 <luite> oh i haven't tried the new cabal wrapper yet, it might have bugs now due to changes in shelly
12:07:27 <latro`a> http://hackage.haskell.org/packages/archive/hmatrix/0.14.1.0/doc/html/src/Data-Packed-Internal-Common.html#app1
12:07:55 <the_fco> hi all, I'm learning GADTs and I have two representations of a lambda calculus one with intrinsic types and one without type annotations, I want to convert between the two as in the function tc in http://hpaste.org/72351 do you have any pointers on how to convert a Type value to a type level "Type"?
12:08:48 <avpx> luite: That seems to have fixed it. Thanks!
12:11:05 <luite> sorry for the lazy version ranges in the cabal file, it's a lot of programs and all dependencies have to be specified for all of them :)
12:11:25 <luite> probably means that ghcjs should be split into ghcjs-lib and ghcjs-bin
12:11:36 <plat0> In Data.Time.Calendar.WeekDate we have toWeekDate :: Day -> (Integer, Int, Int)
12:11:43 <plat0> the third component is day number
12:11:46 <plat0> 1 = Monday .. 7 = Sunday
12:11:51 <romm> merijn: interesting anecdote, and basically the reason i'm learning haskell. python is easy and powerful, but a bit too slow. hopefully haskell will allow me to do what i do in python, faster.
12:11:57 <hpc> the_fco: you probably want a type class plus higher ranked type
12:12:13 <plat0> Is there a safe version of this, which returns a type with seven inhabitants, rather than Int, for the day of the week?
12:12:16 <luite> romm: if just runtime speed is what you're after, i wouldn't learn haskell
12:12:29 <avpx> Haskell should be much faster than Python
12:12:32 <hpc> the_fco: or go the whole hog and use data kinds
12:12:34 <the_fco> hpc: thx! do you know of any pointers online to that?
12:13:17 <hpc> data kinds are the more direct approach, in that you dont even need the lifting function
12:13:51 <hpc> you arent really learning GADTs, in any event :P
12:14:23 <the_fco> direct and whole hog sound ok, why am I not learning GADTs? or you mean, just GADTs?
12:14:53 <confusing> plat0: i'm pretty sure what you're describing would be a Good Idea (tm), but i don't know of any existing implementation (not that it'd be much work)
12:14:59 <avpx> luite: I'm still unsure how you figured out you needed to unwrapResumable on the source in order to prevent the "no instance MonadBaseControl IO m" error
12:15:01 <hpc> the_fco: i mean, if you push forward with the problem at hand you get into other things
12:15:19 <avpx> It's this sort of reasoning that's elusive to me
12:15:42 <romm> luite: i don't see why not. if i can replace python with haskell as my "quick thingie" language, i don't see a reason not to.
12:16:04 <the_fco> hpc, that's my intention! the world hardly needs another implementation of stlc :P
12:16:12 <luite> romm: oh that's certainly possible, but i wouldn't expect the result to be always faster
12:16:27 <latro`a> luite: I would, if you're avoiding space leaks
12:16:42 <latro`a> not that that is always nontrivial
12:16:58 <plat0> confusing: any idea why it wasn't done like that in the first place?
12:17:03 <confusing> python as a rule of thumb is faster than haskell ?!
12:17:05 <plat0> I'll go and look at the source ...
12:17:07 <the_fco> with data kinds I'd need to use the "promotion" from types to kinds?
12:17:37 <hpc> the_fco: yeah
12:18:17 <hpc> data kinds has its limits - ghc is not yet a complete dependent type system
12:18:20 <applicative_> confusing: that would be really surprising
12:18:24 <the_fco> hpc: and then the "type preservation" is trivial?
12:18:28 <confusing> plato: i'm discovering that in the past it was like that (package old-time), but that has been superseded by the current thing
12:18:47 <confusing> applicative_: i feel the same, but luite seemed to be claiming things in that direction
12:19:01 <levi> Python is fairly fast if what you're doing is largely glueing C libraries together.
12:19:17 <luite> pypy even makes some python code run quite fast :)
12:19:17 <avpx> That's seldom what you do in Python, though.
12:19:39 <hpc> levi: that is to say... C is fast ;)
12:19:48 <levi> A lot of the core Python libraries are implemented in C, though.
12:19:48 <avpx> Yeah, basically.
12:19:51 <plat0> Well the day of week component is just "fromInteger (mod d 7) + 1", so I'll do an incomplete pattern match and be done with it
12:20:05 <plat0> Strange that this was not done already
12:23:27 <confusing> plat0: yeah, i'm wondering too ...
12:23:30 <jfischoff> is there a version of lines that works for either \n or \r separators?
12:23:35 <luite> confusing: nah i meant that learning haskell just for the performance improvement over python might not be terribly productive, you could instead rewrite some of your performance critical stuff in C, or work on better python compilers
12:24:59 <confusing> luite: ok ... it's just that he mentioned "as my language for quick little thingies", so rewriting performance-critical stuff in c is probably less relevant to him
12:25:26 <luite> confusing: yeah but tbh, quick little thingies often tend to be rather slow in haskell
12:25:49 <levi> It's probably the case that the fastest haskell version of a program will generally be faster than the fastest python version of a program, but as a haskell learner it may be the case that your first version of a program in haskell could end up slower than your first python version.
12:26:12 <the_fco> hpc, thanks for your help, I'll have to update my ghc to have datakinds
12:27:20 * applicative_ wonders what the evidence for luite and levi 's wild claims is.
12:27:23 <EvanR> luite: nah
12:27:49 <EvanR> most of your code for quick little thingies is probably the imports ;)
12:28:34 * applicative_ begins a quick little thingie with 'import qualified Data.Vector.Unboxed as V'
12:29:07 <osaunders> I’d like to write a function that gives you the number of enums in a type. For instance «data Alerts = Red | Green | Blue deriving Enum; main = print (nEnums :: Alerts)» would output 3. Is this possible?
12:29:37 <mauke> osaunders: derive Bounded
12:29:39 <confusing> luite: supposing, in a very hand-wavy way, that i wrote a haskell program in 3 hours. if i rewrite it in c, i'll spend days writing tedious junk like "if (x < 0) { perror(...) }", and then spend weeks debugging, and then at runtime i'm rewarded with savings of 4 seconds. so that's not worth it 8-)
12:29:56 <applicative_> @type maxBound
12:29:57 <lambdabot> forall a. (Bounded a) => a
12:30:09 <applicative_> > length ([minBound ..maxBound] :: [Char])
12:30:10 <lambdabot>   1114112
12:30:26 <applicative_> > length ([minBound ..maxBound] :: [Bool])
12:30:27 <lambdabot>   2
12:30:29 <EvanR> aroudn all Enums bounded
12:30:30 <mauke> > ord maxBound - ord minBound
12:30:32 <lambdabot>   1114111
12:30:35 <EvanR> arent all Enums bounded
12:30:37 <luite> confusing: yes that's possible
12:30:45 <parcs`> > fromEnum maxBound - fromEnum (minBound :: Char)
12:30:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:30:46 <lambdabot>    `GHC.Enum.Bounded a'
12:30:46 <lambdabot>    ...
12:30:56 <mauke> EvanR: Integer
12:31:10 <luite> confusing: but i thought the alternative was python? or would you expect the python version to be unusably slow?
12:31:15 <parcs`> > ((-) `on` fronEnum) (minBound :: Char) maxBound
12:31:17 <lambdabot>   Not in scope: `fronEnum'
12:31:23 <EvanR> fromEnum (100000000000000000000 :: Integer)
12:31:26 <EvanR> > fromEnum (100000000000000000000 :: Integer)
12:31:27 <lambdabot>   7766279631452241920
12:31:30 <EvanR> >_>
12:31:42 <osaunders> mauke: Yes you can say «succ $ fromEnum (maxBound :: Alert)» but what if I want a general function to do this for all bounded enums. You don’t seem to be able to write a definition with type «(Bounded a, Enum a) => Int» because an «a» isn’t taken as an argument
12:31:58 <EvanR> unbounded Enums are thus broken
12:32:06 <EvanR> or Enum is broken
12:32:10 <luite> Enum is broken
12:32:12 <levi> I don't think there's any reason not to learn haskell to write whatever programs you feel like writing. Why try to justify it? It's fun!
12:32:18 <luite> some bounded enums are also broken :)
12:32:19 <Dashkal> Is there a simple way to get something in ghc/cabal to tell me what package is providing a given module?
12:32:30 <parcs`> osaunders: why not take an 'a' as an argument and ignore it?
12:32:39 <mauke> osaunders: take a proxy argument
12:32:41 <applicative_> Dashkal: ghc-pkg find-module
12:32:52 <osaunders> parcs`: Seems kinda silly though
12:33:05 <applicative_> Dashkal: ghc-pkg find-module Data.Vector.Unboxed
12:33:05 <mauke> @hoogle sizeOf
12:33:05 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
12:33:05 <lambdabot> GHC.Constants sIZEOF_CostCentreStack :: Int
12:33:05 <lambdabot> GHC.Constants sIZEOF_generation :: Int
12:33:05 <osaunders> Oh I suppose I could provide undefined
12:33:10 <mauke> it's what sizeOf does
12:33:17 <Dashkal> danke
12:33:34 <jfischoff> is there a common function for getting the just directory path for a file path?
12:33:56 <confusing> luite: you seemed to be saying basically "haskell may not be that fast, and why not use c" :) anyhoo, no worries. gotta run. take care
12:34:02 <luite> confusing: nah that
12:34:06 <luite> 's not what i meant
12:34:27 <luite> but it doesn't really matter anyway
12:34:28 <parcs`> osaunders: it's common practice. even better is taking a 'Proxy a' where 'data Proxy a = Proxy', as mauke suggested. that way you don't have to mess around with undefined
12:35:11 <osaunders> OK
12:35:13 <osaunders> TY
12:35:16 <geekosaur> jfischoff, take a look at the System.FilePath modules
12:35:22 <parcs`> YW
12:35:24 <confusing> luite: right. let's just all agree that haskell is inconceivably great in every regard
12:35:25 <applicative_> jfischoff: have you looked
12:35:32 <applicative_> oh jfischoff what geekosaur said
12:35:33 <jfischoff> geekosaur: thanks
12:35:34 <luite> confusing: yes!
12:35:35 <EvanR> confusing: it is
12:36:29 <parcs`> @faq can haskell be inconceivably great in every regard?
12:36:29 <lambdabot> The answer is: Yes! Haskell can do that.
12:37:16 <EvanR> @faq can haskell do dependent types
12:37:17 <lambdabot> The answer is: Yes! Haskell can do that.
12:37:32 <nand`> @faq Can Haskell do something Haskell can't?
12:37:33 <lambdabot> The answer is: Yes! Haskell can do that.
12:37:33 <latro`a> @faq do you answer every question with yes
12:37:33 <lambdabot> The answer is: Yes! Haskell can do that.
12:37:36 <nand`> There we have it, Haskell is inconsistent
12:37:40 <fuchsto> I declared a type class, say,  Fooable a  , and i want to define a record entry of type Fooable (any Fooable). The goal is to overwrite the Fooable record entry with concrete instances at runtime (like a polymorphic pointer in C++). Is that possible?
12:37:42 <latro`a> @faq do you answer every question with no
12:37:42 <lambdabot> The answer is: Yes! Haskell can do that.
12:37:47 <mgsloan>  @faq are Haskell records beautiful?
12:37:51 <latro`a> great minds apparently nand`
12:38:56 * mgsloan thinks @faq must have a rate limiter
12:39:17 <EvanR> aka a cooldown
12:41:26 <parcs`> fuchsto: i think you're asking for an existential type
12:41:57 <EvanR> which you can also do with partial application
12:42:02 <EvanR> and its great fun
12:42:36 <fuchsto> Hm. I tried to use    data ApplicationContext = ApplicationContext { visual : IORef Visual, ... }
12:42:44 <fuchsto> and GHC is calling me names for doing so.
12:42:54 <EvanR> thats totally value
12:42:57 <EvanR> thats totally valid
12:43:03 <EvanR> except for the :
12:43:05 <parcs`> fuchsto: Visual is a type class?
12:43:06 <EvanR> : -> ::
12:43:10 <fuchsto> I *thought* that IORef Visual *is* partial application.
12:43:25 <EvanR> no IORef Visual is a full type
12:43:35 <fuchsto> parcs`: Visual is defined as   class Visual v where; render :: Foo -> Bla -> IO ()
12:43:38 <fuchsto> etc.
12:43:51 <EvanR> paste code
12:43:53 <EvanR> hpaste
12:44:03 <fuchsto> it's on github, just a sec
12:44:12 <latro`a> I suspect you need a constraint and a variable, if Visual is a class
12:44:34 <EvanR> dont put constraints on the datatype
12:44:40 <latro`a> true
12:44:47 <fuchsto> https://github.com/fuchsto/drool/blob/master/src/Drool/UI/Visuals/Visual.hs
12:44:50 <latro`a> can just make it a variable in general
12:44:56 <EvanR> yeah
12:45:08 <KirinDave> Hey what's the common name for the composition function that uses the reverse order of "." ?
12:45:08 <lambdabot> KirinDave: You have 3 new messages. '/msg lambdabot @messages' to read them.
12:45:18 <latro`a> ok, so where's your ApplicationContext declaration?
12:45:29 <parcs`> KirinDave: ">>>"
12:45:33 <KirinDave> parcs`: ty
12:45:38 <latro`a> or (if you haven't commited it) you can just do:
12:45:42 <fuchsto> I can't really constrain it ... the type 'v' is just any record. Hm, i could postulate some record fields to be defined, though
12:45:53 <latro`a> data ApplicationContext v = ApplicationContext { visual :: IORef v, ...}
12:46:01 <latro`a> and then constrain v in the functions that take these
12:46:39 <fuchsto> latro`a: Nope, won't work. ApplicationContext is something like the global state, a singleton, so to say.
12:46:55 <EvanR> haskell doesnt have a global state environment
12:46:55 <latro`a> um
12:47:15 <latro`a> if you need any instance of Visual to fill that spot
12:47:18 <latro`a> you need a variable
12:47:21 <latro`a> a singleton is not appropriate
12:47:38 <latro`a> if there is only one instance of Visual, then consider making it not be a typeclass
12:47:50 <fuchsto> There are several instances
12:47:56 <latro`a> then a variable is a given
12:48:07 <latro`a> sorry to say that this may change a whole pile of your signatures
12:48:19 <geekosaur> fuchsto, are you trying to use a typeclass as an OO class?  this will only end in tears
12:48:27 <fuchsto> At startup, i define an IORef on an ApplicationContext, and all modules are referencing this IORef.
12:48:50 <fuchsto> geekosaur: I am trying to use a typeclass as a polymorphic contract / interface.
12:49:13 <latro`a> for the *value* to be polymorphic you might need some rank shenanigans
12:49:29 <latro`a> but I'm not really sure what you mean here without more details
12:49:33 <EvanR> fuchsto: a given value of ApplicationContext v can only have one type for v
12:49:34 <fuchsto> latro`a: Errm, rank shenanigans?
12:49:41 <latro`a> RankNTypes or such
12:49:47 <latro`a> and yeah, that
12:50:02 <EvanR> do you really want to suggest using rank n types <_<
12:50:07 <latro`a> I don't, actually
12:50:29 <latro`a> I think there's some mismatch going on in the background
12:50:36 <latro`a> but I don't know what exactly it is
12:50:45 <EvanR> fuchsto: you can make a new data type which wraps the alternative visual types like Data Visual = A VA | B VB | C VC
12:50:47 <fuchsto> EvanR: My problem is actually simple: I have several visualizer implementations, all instances of the same type class. At runtime, i want to switch from one visualizer to another.
12:51:07 <EvanR> then use IORef Visual
12:51:14 <latro`a> ^
12:51:16 <fuchsto> EvanR: Ah! Sure! That's it! I need this kind of data definition anyhow
12:51:23 <EvanR> another alternative is to use a function instead of a Visual data type
12:51:24 <fuchsto> EvanR: Clever, thank you
12:51:25 <latro`a> if you're switching around you need to be passing a type around that can handle being one of several in the first place
12:51:43 <EvanR> whatever all the visuals do, use that as the type
12:51:52 <EvanR> IORef (a -> b)
12:52:10 <EvanR> then you can configure it at runtime
12:52:23 <fuchsto> EvanR: So, a function returning an instance of Visual. I was thinking about that. I could use the definition of newVisual for that.
12:52:36 <EvanR> no, you have the same problem as before
12:52:39 <EvanR> you can only have one 'b'
12:52:52 <EvanR> but you can do this
12:53:09 <EvanR> mkV1 :: Visual1 -> a -> b
12:53:15 <EvanR> mkV2 :: Visual2 -> a -> b
12:53:23 <EvanR> then write mkV1 v1 to the IORef
12:53:27 <EvanR> mkV2 v2 to the IORef
12:53:31 <EvanR> and its well typed
12:54:00 <EvanR> the (a -> b) may instead be IO () or whatever, i dont know what exactly youre doing with these 'Visual' types
12:54:03 <fuchsto> Aaah. Sure, i need a 'complete' type in the first place, then i can switch it
12:54:30 <fuchsto> 'Visual' is just a slim interface to OpenGL renderers
12:54:49 <fuchsto> add a signal, render the new state
12:54:50 <EvanR> fuchsto: well if Visual is one type youre good
12:55:25 <EvanR> if its a variety of implementations of the same api, it can be a record of functions
12:56:18 <fuchsto> EvanR: Hm, like how?
12:56:52 <fuchsto> data VisualComponents = { visual1 :: a -> Visual1, visual2 :: a -> Visual2, ... } ?
12:56:58 <EvanR> no
12:57:34 <latro`a> a single record with a function in it, where the function is different between particular objects
12:57:37 <latro`a> is that what you meant?
12:57:46 <latro`a> @ EvanR
12:58:24 <EvanR> youre talking like Visual is several opaque types, im suggesting that they are a bunch of functions with different implementations
12:58:45 <EvanR> latro`a: i dont know if you have one function or a bunch of functions, but yeah
12:58:56 <Qtr> music apps, torrent apps, movie apps, al that is done. what kind of app do YOU need?
12:59:04 <Peaker> fuchsto, if all the functions in the record have (a ->) in them, just partially apply them all to the "a", and remove it
13:01:32 <fuchsto> EvanR, Peaker, i see
13:01:44 <EvanR> a record of functions lets you make an interface that values of that record type can implement
13:02:03 <EvanR> if some of those function return a value of that type, you have invented mutable object oriented programming ;)
13:02:21 <fuchsto> Using a data as a wrapper works for now:   data VisualComponent = VisualA (Visual A) | VisualB (Visual B)
13:04:01 <fuchsto> EvanR: I'm not sure i understand, sorry. Can you give me an example?
13:04:02 <EvanR> data Obj a = Obj {read :: a -> B, write :: a -> B -> Obj a}
13:04:15 <EvanR> but i think you dont need this, was just rambling
13:04:27 <latro`a> (read will also collide, obviously >.>)
13:04:39 <EvanR> latro`a: its wrong for other reasons
13:04:40 <EvanR> like
13:04:43 <EvanR> read :: B is enough
13:04:46 <fuchsto> it sounds very interesting, i don't care if i need it. Perhaps i will find a way to need it ;)
13:05:15 <EvanR> fuchsto: well VisualA (Visual A) ? is Visual a type constructor?
13:05:21 <EvanR> like Data Visual a = ?
13:05:34 <fuchsto> EvanR, no, its an instance of class Visual
13:06:01 <fuchsto> class Visual v; where; render :: v -> IO ()
13:06:32 <fuchsto> (instance of *type* class)
13:07:20 <fuchsto> GHC is now complaining about circular dependencies -.-
13:09:10 <shapr> fuchsto: create an hs-boot file?
13:09:31 <fuchsto> shapr: I'm trying to avoid those
13:09:50 <fuchsto> someone in here told me they are somehow frowned upon.
13:10:08 * hackagebot Etage 0.1.10 - A general data-flow framework (MitarMilutinovic)
13:12:56 <geekosaur> it'd be more correct to say that circular dependencies are frowned on.
13:17:04 <EvanR> fuchsto: thats what i was looking for!
13:17:10 <EvanR> render :: v -> IO ()
13:17:29 <EvanR> just use the type IO ()
13:18:41 <EvanR> and pass whatever needs it (render1 V1) or (render2 V2) and so on
13:18:43 <fuchsto> EvanR: Errm, and how would i pass my v-parameter to render_
13:18:58 <fuchsto> EvanR: Ouuuuuh, sure :D
13:19:01 <EvanR> there are several renders right, since you would have had class instances
13:19:09 <fuchsto> Right
13:19:43 <fuchsto> Hm, then the type class would not specify the type of v (or even its existance), just the output behaviour
13:19:58 <fuchsto> and the concrete types would specify their expected parameters. Sound legit.
13:20:00 <EvanR> you could have a type calss
13:20:01 <fuchsto> -Sounds
13:20:06 <EvanR> you wouldnt have a type calss
13:20:13 * hackagebot Etage-Graph 0.1.6 - Data-flow based graph algorithms (MitarMilutinovic)
13:20:20 <EvanR> no need for a type class
13:20:54 <fuchsto> So instead of a type class, i would use a record defining functions.
13:21:33 <fuchsto> like   data Visual = { render :: IO (), ... }
13:21:44 <EvanR> defnitely
13:22:06 <fuchsto> and use   render myVisual theVisualParameterFormerlyKnownAs_v
13:23:25 <fuchsto> That's less strict than a type class, as only function names and their output is defined, but not their parameters. Which is pretty awesome, as it gives flexibility in my case.
13:24:01 <fuchsto> And the render engine does not care about parameters anyhow, as it expects a pre-configured (curried) visual thingie.
13:25:04 <fuchsto> EvanR: Thank you very much, that's a really clever idea
13:26:23 <EvanR> fuchsto: it doesnt have to be just the output, it could be functions too
13:26:40 <EvanR> Context -> a -> b -> Output
13:26:44 <EvanR> can be turned into a
13:26:47 <EvanR> a -> b -> Output
13:26:52 <EvanR> with a suitable Context
13:27:06 <fuchsto> EvanR: Sure, sure, i was just referring to my render function
13:27:23 <fuchsto> EvanR: Currying is one thing i did understand ;)
13:27:23 <EvanR> right now youre mainly benefitted by the fact that IO actions in haskell are values, not functions
13:27:49 <EvanR> they dont get executed immediately you can save them for later
13:28:24 <fuchsto> Hm? How am i benefitted by this right now?
13:28:40 <fuchsto> Or: How would i not, if using the record approach?
13:28:48 <b0fh_ua> Hi, simple offtopic - does anybody know how to transform square root of a number into continuous fraction?
13:28:52 <EvanR> you can compute the render IO action and store it without that particular part of the code needing to know about the Visual types
13:30:19 <augur> anyone know of some stuff on simulating non-referential transparecy?
13:44:02 <donri> edwardk: hm not sure what to think of lens 1.1. it was supposed to reduce imports, but now we have containers lenses in different modules with identical names so you'd need qualified imports...
13:45:20 * hackagebot optparse-applicative 0.3.1 - Utilities and combinators for parsing command line options (PaoloCapriotti)
13:46:33 <Qtr> So when someone pushes submit a post request is made right?
13:46:35 <Peaker> why the hate for qualified imports?
13:46:52 <Qtr> qualified imports are the schnitzel
13:46:59 <c_wraith> Qtr: depends on the form, actually. could get GET or POST
13:47:07 <Cale> In my case it's because '.' was the worst possible choice for a module path separator.
13:47:51 <Cale> Composition is very common, and qualified names look bad in the middle of composition chains.
13:48:17 <c_wraith> this would be trivially solved if whitespace was necessary to separate tokens. :)
13:48:24 <Cale> Even so
13:48:27 <donri> i didn't mind the reuse of dot for qualified imports until i noticed pointfree gets confused by it :(
13:48:43 <Cale> Even with correct spacing, it doesn't change the fact that it's typographically bad
13:48:50 <Nereid> A.B.c.D.e
13:49:00 <Nereid> :(
13:49:00 <donri> and it's not *that* bad if you put spaces around composition, but with lenses, I don't
13:49:06 <jamiltron> I agree with Cale that I really wished nearly any other character was used.
13:49:35 <Nereid> don't some people use ; for composition left-to-right?
13:49:42 <Cale> So I end up going out of my way to avoid using qualified names
13:50:02 <Nereid> also
13:50:10 <donri> is ; a valid operator?
13:50:10 <Qtr> pointsfree? you can do ((+) (*)) instead of ((+) . (*)) ?
13:50:24 <Nereid> donri: don't think so
13:50:35 <Cale> In some respects, I actually preferred the old FiniteMap convention of postfixing names with abbreviations of the module name :P
13:50:35 <donri> Qtr: it's not referring to the dot as the points you're free from ;)
13:50:40 <Nereid> yeah it can't be.
13:50:50 <Cale> lookupFM etc.
13:50:57 <Nereid> on a related note, isn't "import ___ as ___" (not qualified) always a bad idea
13:50:57 <Enigmagic> i have a rule that fires whenever someone forgets spaces around the (.) for composition... it sends an email to HR and it goes on their employment record.
13:50:58 <Qtr> > let (;) = (+1) in (;) 5
13:50:59 <lambdabot>   <no location info>: parse error on input `;'
13:51:34 <Qtr> whats so terrible with (D.add . L.sub) ?
13:51:34 <Cale> Qtr: \x -> f (g x) refers to the point x on which the function acts
13:51:42 <Cale> f . g  leaves that point out
13:51:52 <Qtr> oh
13:52:02 <Cale> That's what's meant by "points-free"
13:52:02 <donri> Nereid: it can be used to disambiguate names as needed
13:52:15 <Qtr> f = map (+1) is pointsfree as opposoed to f xs = map (+1) xs ?
13:52:18 <Cale> It's a name given by topologists
13:52:44 <Cale> (and topologists work with functions on "spaces" filled with "points"
13:52:45 <Cale> )
13:53:01 <Cale> Qtr: right
13:53:10 <Cale> @pl f xs = map (+1) xs
13:53:10 <lambdabot> f = map (1 +)
13:53:29 <Cale> That's cute, it knows (+) is commutative, or is that just a bug?
13:53:34 <Peaker> Cale, typographically bad is pretty low on my list of problems.. unqualified imports make a worse mess
13:53:57 <Peaker> @pl f xs = map (/2) xs
13:53:57 <lambdabot> f = map (/ 2)
13:53:57 <Qtr> @pl f xs = map (-1) xs
13:53:58 <lambdabot> f = map -1
13:54:01 <donri> @pl f x = FM.lookup x
13:54:02 <lambdabot> f = FM.lookup
13:54:11 <latro`a> @pl f xs = map (*2) xs
13:54:11 <lambdabot> f = map (2 *)
13:54:13 <latro`a> huh
13:54:25 <donri> @pl f x = (g . FM.lookup) x
13:54:26 <lambdabot> f = g . FM.lookup
13:54:37 <donri> hm i'm sure it confused pointfree for something
13:54:52 <donri> or maybe lambdabot's @pl /= pointfree pckage
13:55:06 <Cale> donri: hm?
13:55:14 <geekosaur> lambdabot's @pl definitely does not understand qualified names
13:55:36 <Cale> geekosaur: are you sure?
13:55:47 <donri> @pl valueAtIx k = to (IxSet.getOne . IxSet.getEQ k)
13:55:48 <lambdabot> valueAtIx = to . (IxSet.getOne .) . IxSet.getEQ
13:55:50 <geekosaur> di dyou recently change it?
13:55:57 <donri> my pointfree executable gets that one wrong
13:56:03 <Cale> geekosaur: no
13:56:12 <donri> $ pointfree 'valueAtIx k = to (IxSet.getOne . IxSet.getEQ k)'
13:56:12 <donri> valueAtIx = to . ((IxSet . getOne . IxSet) .) . getEQ
13:56:39 <geekosaur> it has certianly screwed with my attempts to clean up various expressions destined for monad, with W.name qualification of StackSet-related stuff
13:58:06 <hy[er]> Hello, is it possible to just lift a function such as drop in to the state monad? I'm guessing no as it won't let me compile it but is there any way or is there a better way to use the generic state functions on the underlying state.
13:58:18 <fmap> @pl \x y -> x `M.f` y
13:58:19 <lambdabot> (line 1, column 11):
13:58:19 <lambdabot> unexpected "`"
13:58:19 <lambdabot> expecting variable, "(", operator or end of input
13:58:27 <donri> Cale: ^
13:58:56 <Cale> @pl \x y -> x `f` y
13:58:56 <lambdabot> f
13:59:00 <Cale> okay :)
13:59:27 <donri> not that one, the one i pasted
13:59:42 <jfischoff> hy[er]: are you familiar with modify?
13:59:46 <Cale> hy[er]: What exactly do you mean by 'lift' in this case?
13:59:58 <Cale> What is the type of the function that you'd like to have?
14:00:08 <hy[er]> jfischoff, I am not familiar with modify
14:00:32 <donri> :t modify
14:00:33 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
14:00:39 <Cale> modify f = do x <- get; put (f x)
14:00:50 <hy[er]> Cale, I want to say lift drop in to the monad so that I don't have to wrap this function and others in its own function within the state monad
14:01:27 <Cale> hy[er]: The problem is I don't know what you mean by "lift ... in to the monad"
14:01:35 <donri> > runState (modify (+1)) 2
14:01:35 <jfischoff> hy[er]: do understand Cale's description of modify?
14:01:36 <lambdabot>   ((),3)
14:01:58 <Cale> hy[er]: Do you want drop to act on the state value, which happens to be a list in your case?
14:02:10 <hy[er]> jfischoff, vaguely
14:02:12 <Cale> hy[er]: Or do you want something like  fmap (drop 4)
14:02:27 <hy[er]> Cale, yeah I want drop to act on the state
14:02:27 <Cale> (i.e. acting on the result of a state computation)
14:02:40 <Cale> hy[er]: then modify (drop n) should do
14:02:46 <donri> > runState (modify (drop 2)) [1..10]
14:02:47 <lambdabot>   ((),[3,4,5,6,7,8,9,10])
14:03:12 <latro`a> oh cool
14:03:15 <hy[er]> Cale, ah okay yeah I understand thanks
14:03:19 <latro`a> where's modify defined
14:03:25 <donri> @hgl modify
14:03:25 <lambdabot> Maybe you meant: help pl url
14:03:25 <latro`a> (I know how to write it myself, but still)
14:03:30 <latro`a> @hoogle modify
14:03:31 <donri> @hoogle modify
14:03:31 <lambdabot> System.IO.Error modifyIOError :: (IOError -> IOError) -> IO a -> IO a
14:03:31 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
14:03:31 <lambdabot> Control.Concurrent.MVar modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
14:03:31 <lambdabot> System.IO.Error modifyIOError :: (IOError -> IOError) -> IO a -> IO a
14:03:31 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
14:03:33 <lambdabot> Control.Concurrent.MVar modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
14:03:37 <donri> right, hgl is my cli alias ;)
14:03:39 <latro`a> none of those are the answer
14:03:46 <jfischoff> latro `a: Control.Monad.State
14:03:50 <donri> Control.Monad.State has it
14:03:52 <latro`a> oh?
14:03:54 <donri> duno if it's also in transformers
14:03:57 <latro`a> apparently I fail at reading then
14:04:20 <donri> http://hackage.haskell.org/packages/archive/mtl/2.1.2/doc/html/Control-Monad-State-Lazy.html#v:modify
14:04:22 <latro`a> it's just get >>= put . f, right?
14:04:26 <hy[er]> Hmm, I will have to look at its type.
14:05:42 <donri> yep in transformers too http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-State-Lazy.html#v:modify
14:06:06 <latro`a> slightly surprised they don't use get/put
14:06:21 <latro`a> I guess it's not much savings
14:06:23 <donri> transformers does in the example
14:06:29 <latro`a> ah
14:06:38 <latro`a> I guess this is fewer ops, too
14:06:48 <donri> yea i'd think the difference would be optimized away by ghc, duno
14:06:56 <hy[er]> Is there a way in general to do recursive functions with the state monad so that it catches when the state runs out like you would do when using pattern matching and normal recursion. I.e function []=terminate
14:06:57 <latro`a> probable, yeah
14:08:23 <donri> hy[er]: do st <- get; case st of [] -> return something; ... -> recurse
14:09:11 <latro`a> I think he means a control construct
14:09:28 <fuchsto> EvanR: Another advantage of your proposal is: It solves the circular dependency
14:09:30 <latro`a> but, recursing like that is more idiomatic anyways
14:09:38 <latro`a> (I think)
14:09:48 <hy[er]> donri, yeah that seems a little ugly...
14:09:59 <fuchsto> EvanR: As ApplicationContext only knows about the very vague function record definition
14:10:56 <fuchsto> EvanR: (Currently, ApplicationContext includes VisualImplementationA, VisualImplementationB, and both include ApplicationContext. The function record removes the necessity to import the concrete implementations in ApplicationContext)
14:11:26 <latro`a> hy[er], that depends how big your functions are
14:11:52 <donri> hy[er]: wait for ghc 7.6 and lambdacase then ;)
14:12:43 <hy[er]> Haha, okay, I guess I just like the way pattern matching looks
14:13:13 <donri> hy[er]: or you could wrap your state monad in one that short-circuits with "fail"
14:13:55 <donri> hy[er]: do (x:xs) <- get; handle x; put xs; recurse
14:14:03 <hy[er]> donri, I just want it know that the end of the recursive cases have been reached and finish gracefully
14:14:17 <hy[er]> good call
14:14:20 <donri> of course, people tend to frown upon "fail"
14:14:27 <fuchsto> EvanR: Just if you are interested, this is my plan: https://github.com/fuchsto/drool/blob/master/src/Drool/UI/Visuals.hs
14:14:28 <donri> personally i like it for things like Maybe :)
14:14:48 <hy[er]> yeah
14:14:49 <latro`a> for Maybe it's nice, but the fact that it's actually in Monad is pretty ugly
14:14:56 <donri> agreed
14:15:46 <donri> means there's no static way to disallow fail, so you end up with a default of an IO error instead
14:15:59 <donri> for monads that don't override it
14:16:13 <latro`a> which then crashes everything unless you catch it in the IO monad
14:16:17 <latro`a> which adds IO to your monad stack, which ...
14:16:43 <donri> at least the error has source location annotations IIRC
14:16:58 <donri> which isn't always the case for runtime errors in haskell :(
14:17:05 <latro`a> indeed
14:17:17 <latro`a> not that it always makes sense for it to
14:17:21 <latro`a> due to laziness *everywhere*
14:17:22 <donri> > head []
14:17:23 <lambdabot>   *Exception: Prelude.head: empty list
14:17:25 <latro`a> but yes
14:17:32 <donri> "oh, the error is in Prelude.hs!"
14:17:36 <latro`a> that could certainly not be there
14:17:54 <latro`a> then again that's sorta partial functions just being kludgy in general
14:18:14 <donri> yea, -prof and +RTS -xc is supposed to help, but i never got any useful output from that either :/
14:18:26 <latro`a> for example
14:18:31 <latro`a> head' = listToMaybe
14:18:31 <donri> nothing like say, python stack traces
14:18:33 <latro`a> ^much better
14:18:58 <donri> latro`a: or "GADTs *all* the things!"
14:19:01 <latro`a> lol
14:19:17 <Cale> :t mapException
14:19:18 <lambdabot> Not in scope: `mapException'
14:19:23 <Cale> :t Control.Exception.mapException
14:19:24 <lambdabot> forall e1 e2 a. (GHC.Exception.Exception e1, GHC.Exception.Exception e2) => (e1 -> e2) -> a -> a
14:19:31 <Cale> ^^ that is often useful
14:19:47 <donri> example usage?
14:20:42 <Enigmagic> i just build the evaluation stack in gdb and look at the functions bound to the thunks on top.
14:20:48 <Enigmagic> takes 5-10 minutes
14:22:15 <Cale> > CE.mapException (\(CE.ErrorCall s) -> CE.ErrorCall ("foo! " ++ s)) (head [])
14:22:18 <lambdabot>   *Exception: foo! Prelude.head: empty list
14:22:36 <augur> http://www.reddit.com/r/haskell/comments/xeiic/haskell_and_fibonacci_numbers_beginner/c5lqbzu
14:22:42 <augur> i hope this is helpful to this fellow
14:23:04 <Cale> You can do that in a nested way to get information about the context in which an exception occurs.
14:23:13 <donri> Cale: seems easier to just substitute head for an incomplete pattern match, then
14:23:22 <Cale> Oh sure, in this case.
14:23:34 <donri> ah, i guess it can be useful though
14:23:56 <Cale> But you can make it give pretty elaborate reports when things fail if you're being systematic about it.
14:24:08 <donri> yea
14:26:02 <donri> could even change the exception type to something custom that envelopes the original
14:27:22 <EvanR> fuchsto: yeah, i find type classes are not the first thing to try
14:29:10 <fuchsto> EvanR: btw, this is what my application currently 'does': http://www.youtube.com/watch?v=VT3dlnSP6kM
14:29:55 <slack1256> In erlang threads are processes and they have their own heap (and own GC). Any way to do this in haskell?
14:30:00 <fuchsto> EvanR: This is one of many visualizer implementations (rendering an FFT as a 3D surface), and i want to switch the visualizer module at runtime
14:30:58 <edwardk> donri: back
14:31:11 <edwardk> donri: i'm kind of torn myself, honestly
14:31:18 <edwardk> but i think the new design scales better
14:31:56 <Qtr> <Qtr>
14:31:58 <EvanR> slack1256: you want to manage heap and gc ?
14:32:27 <EvanR> fuchsto: yeah when you want to change behavior of stuff at runtime you typically dont need to change the type
14:32:32 <Qtr> Goodnight.</Qtr>
14:32:45 <slack1256> EvanR: not exactly, I want to know if it is possible to have various haskell processes with their own rts (and GC)
14:32:55 <edwardk> donri: the main problem i was running into was that all you couldn't find any of the combinators for working with a given container
14:32:57 <EvanR> slack1256: how would you be able to tell
14:33:59 <slack1256> EvanR: How would i notice that they are separate entities?
14:34:29 <EvanR> how would you be able to tell the difference betwen that, and normal ghc green threads, if there were any (i dont know if there are)
14:34:31 <slack1256> EvanR: BTW, this is not for work, is just a curiosity.
14:35:11 <fuchsto> EvanR: I have a really, really long history with C++, these are situations where i have to humbly rethink paradigms, and that's why i'm learning haskell in the first place :)
14:35:13 <EvanR> in my experience threads act independently in every way, they crash separately, dont interfere with each other in terms of gc
14:35:15 <merijn> slack1256: You could just start multiple processes and have them communicate using unix domain sockets for example
14:35:38 <merijn> slack1256: Also, there's a paper on Cloud Haskell, which provides some cool stuff for doing Erlang like things
14:35:51 <merijn> Like start processes remotely, that sorta thing
14:36:36 <slack1256> merijn: yeah. that was what triggered my curiosity.
14:36:59 <merijn> It doesn't really make much sense to have multiple processes on the same physical machine, though
14:37:10 <EvanR> yeah if you want the processes so independent they are on different computers you need to use sockets
14:37:14 <merijn> At least, I suspect
14:37:51 <slack1256> my question was related to the thread in haskell-cafe where is detailed a little how the haskell GC works
14:38:25 <EvanR> it would suck if a program with lots of threads had to copy data from one gc to another when communicating with MVars
14:38:29 <merijn> It might cut back on GC synchronisation. But it's hard to tell (and probably application specific) whether that's worht it
14:38:44 <EvanR> not the mention serial/deserial to make it network transparent
14:39:21 <slack1256> we have basically 2 generations a young and an older one, the thread mentions the older one being capable of be collected in parallel.
14:39:23 <Enigmagic> merijn: not just synchronization times, but also pause times.
14:39:45 <slack1256> but the younger one has to stop all the threads and then be collected.
14:39:48 <Enigmagic> merijn: since GHC doesn't do incremental collections, gen1 collections on a 50GB heap are pretty slow
14:40:15 <Enigmagic> or rather, they pause the process for a while
14:40:46 <merijn> Enigmagic: Is there any good papers on GC behaviour in GHC? We've had some pretty lousy scaling due to GC times when increasing the number of worker threads
14:41:13 <slack1256> merijn: http://research.microsoft.com/en-us/people/simonmar/
14:41:41 <Enigmagic> merijn: not really. i just use -qg1 by default and adjust the arena size per app. far from ideal.
14:41:41 <donri> edwardk: duno, isn't that a documentation issue? give them a dedicated section "Lenses for containers"?
14:41:42 <slack1256> simon marlow is the main implementor on GC in GHC. also have good papers on the subject. that the place to look.
14:44:29 <edwardk> donri: perhaps, but it was exploding with lots of crap for containers that were irrelevant to many people
14:47:16 <cg_morton> so, if I do a   mapm Filepath->IOfunction [Filepath]   it will execute all the IO actions, right?
14:47:49 <johnw> Has anyone had success at building 7.4.2 on OpenIndiana?
14:47:55 <cg_morton> or do I need some other -m function to bundle them into one action?
14:48:36 <shachaf> cg_morton: You'll have to clarify.
14:49:03 <shachaf> (Becuase "mapm Filepath->IOfunction [Filepath]" doesn't make much sense.)
14:49:36 <cg_morton> ah sorry
14:50:02 <cg_morton> no i'm screwing this up in my head, it shouldn't be even be a map
14:50:45 <donri> edwardk: maybe put them in one single dedicated module, then? :)
14:51:12 <edwardk> not sure. i'm willing to negotiate the split between qualified/unqualified imports
14:51:21 <edwardk> but some of them clearly need to be elsewhere
14:51:38 <edwardk> and putting them all elsewhere made for a consistent solution
14:51:46 <edwardk> otherwise everyone has to remember all the specialc ases
14:53:13 <roconnor_> edwardk: isn't Backwards already in transformers
14:53:21 <donri> edwardk: shrug, you could have a single module "Stock" for all lenses that aren't generic lens utils
14:53:24 <roconnor_> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Applicative-Backwards.html
14:53:31 <edwardk> there was a Reverse but it didn't work for me, maybe i grabbed the wrong one
14:53:40 <edwardk> ah good
14:53:42 <edwardk> i'll swap to it
14:54:01 <edwardk> the problem is that 'Stock' still has a lot of things that then need to just randomly be renamed out of each other's way
14:54:03 <edwardk> e.g.
14:54:05 <hpaste> romm pasted “parse error on: let” at http://hpaste.org/72357
14:54:19 <edwardk> setmap :: (Ord i, Ord j) => Setter (Set i) (Set j) i j  -- is admissable for Set
14:54:26 <edwardk> should it live in the main module?
14:54:33 <edwardk> i had ixmapped, amapped, etc.
14:54:33 <romm> can anyone give me a hint on what i'm doing terribly wrong here?
14:54:37 <edwardk> i was taking too many names
14:54:58 <edwardk> my main goal is that Control.Lens can be imported unqualified without too much pain
14:55:14 <ion> romm: The “let” should be indented to the same column as “gen <- …”
14:55:23 <edwardk> qualifying or not the auxillary modules is less of a concern to me
14:55:25 <donri> duno but i really preferred what you had in 1.0
14:55:30 <Enigmagic> romm: use spaces not tabs for alignment
14:55:32 <roconnor_> edwardk: I invented Backwards some years ago.  It finaly made it in. :D
14:55:35 <edwardk> *nods* it just didn't scale
14:55:49 <ion> romm: 0) Your text editor may be buggy and use a tab stop width of something else than 8; 1) avoid indenting with tabs altogether.
14:55:58 <edwardk> i may move some of the common ones back in
14:56:02 <edwardk> if i can strike the right balance
14:56:11 <donri> throw more type classes at it! yay!
14:56:14 <edwardk> but it is a lot easier to find your way around the file now
14:56:21 <romm> uh. odd that vim doesn't work out of the box with this. thanks ion, Enigmagic.
14:56:32 <edwardk> the problem is the typeclasses can't solve it in a satisfying way
14:56:36 <ion> romm: Vim certainly should use a tab stop of 8 by default.
14:56:43 <roconnor_> donri: Time to fork!
14:56:44 <edwardk> the TraverseByteString class etc help mitigate things somewhat
14:56:44 <roconnor_> :P
14:56:54 <edwardk> but if i go farther, then type inference will suck
14:57:22 <donri> roconnor_: honestly... i'm considering sticking to 1.0 :P
14:57:39 <roconnor_> donri: There is probably nothing wrong with doing that
14:58:47 <roconnor_> my trackpad buttons aren't working
14:59:08 <roconnor_> in this xsession
14:59:12 <donri> i suppose i could just reuse the qualification name of the actual containers modules, and it's not that bad, except it's really ugly for lens composition
14:59:13 <edwardk> donri: =P
14:59:25 <edwardk> which particular lenses are a pain point? contains/valueAt?
14:59:40 <edwardk> ^.Map.at 3  ;)
14:59:42 <donri> valueAt (now "at") i guess
14:59:45 <donri> yea
15:00:04 <donri> doesn't look that bad but could be confusing
15:00:12 <donri> which dot is composition, which is qualification
15:00:24 <donri> i tend to not put spaces around lens composition
15:00:28 <edwardk> also, if you only use one of those in your code you can bring that in unqualified
15:00:47 <edwardk> which works fine until you mix IntMap and Map
15:01:15 <edwardk> ^.Seq.traverseHead.Seq.traverseTo 4
15:01:21 <donri> hm only Map in what you have but i'm also using hashmap and ixset for which i might define my own lenses, and i'd like to stay consistent with yours :)
15:01:26 <edwardk> develops a cadence all its own ;)
15:01:39 <donri> but guess i'll just define my own Data.*.Lens modules and import those qualified too
15:01:48 <edwardk> *nods*
15:02:07 <edwardk> the main issue is i'm getting to where i'll have a dozen lenses for some types, and i can't just put them all in one grabbag
15:02:18 <donri> guess i should try it before i diss it... i might come back later and complain some more then ;)
15:02:22 <edwardk> i was getting too lost
15:02:42 <edwardk> and the pressure for an end user to just import it qualified because it was pissing all over all names everywhere was mounting
15:02:54 <edwardk> and you don't want someone to have to use Control.Lens qualified. all the good names are infix
15:03:36 <donri> that's for sure
15:03:37 <edwardk> roconnor_: swapped to Backwards
15:04:29 <otters> :t foldl
15:04:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:06:24 <otters> @pl \a b -> Pair a (Lit b)
15:06:24 <lambdabot> (. Lit) . Pair
15:07:04 <edwardk> part way through the writeup for the lens library, deriving the laws for all of these from the functor and traversable laws
15:07:45 <edwardk> so given just those laws and the definition of a function, i can motivate folds, traversals, setters, getters and lenses as lens families
15:08:06 <cg_morton> okay, so if I have an [ IO () ], what do I use to put them all into one IO ()?
15:08:19 <edwardk> :t sequence_
15:08:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:08:32 <cg_morton> cool, thanks
15:09:16 <hpaste> romm pasted “Couldn't match expected type” at http://hpaste.org/72358
15:10:02 <romm> sorry again for a possibly newbie question. i don't understand where does the type expectation come from.
15:11:16 <donri> romm: please paste the error as well
15:11:35 <geekosaur> just from looking at it, take wants an Int, not a Num a => a
15:11:49 <Cale> romm: You've given an incorrect type signature for someFunc
15:12:01 <Cale> romm: remove the type signature and see what GHC infers
15:12:12 <noteventime> romm: newStdGen is an IO operation, no?
15:12:18 <Cale> yes, it is :)
15:12:26 <hpaste> romm pasted “Couldn't match expected type” at http://hpaste.org/72359
15:12:50 <geekosaur> oh dear.
15:13:24 <Cale> It's expecting an action in the function monad, because you explicitly specified that the result of someFunc jumps would be another function n -> n -> n
15:13:32 <Cale> but instead, there is a description of an IO action there
15:15:23 <romm> Cale, the returned type/value is deterministic. you mean that it doesn't matter and i should "tell" haskell that i have side effects?
15:15:56 <romm> pardon the lack of "rigor"... i'm completely new.
15:16:16 <c_wraith> romm: the value is *not* deterministic.  newStdGen uses IO
15:16:54 <romm> c_wraith, but i return \a b -> a + b
15:17:31 <donri> this is what it means that haskell is pure, you can't even fake it by hiding the effects inside a function (except with ugly hacks that we shouldn't teach you ;))
15:17:33 <latro`a> "return" probably doesn't do what you think it does
15:17:39 <latro`a> :t return
15:17:40 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:18:07 <latro`a> this means that the output of your function is an IO (n->n->n)
15:18:10 <donri> romm: it doesn't matter what you "do" if the types don't match
15:18:12 <noteventime> romm: newStdGen gives a value in IO, from which GHC infers that the do-block describes something in IO, meaning you must actually produce an IO value (and someting of the type a -> a -> a isn't)
15:18:14 <donri> > 1 + "2"
15:18:14 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
15:18:15 <lambdabot>    arising from the literal ...
15:18:19 <EvanR> > "'"
15:18:20 <lambdabot>   "'"
15:19:12 <noteventime> romm: What 'return' does though, is make your (a -> a -> a) into an IO (a -> a -> a), which is exactly what you need; but you do not specify it in your type signature, and thus GHC gets confused
15:19:23 <c_wraith> romm: the thing is, the value is not just the function returned. It's the combination of the function returned, and the effects the IO action has.  And newStdGen has effects.
15:19:36 <romm> okay, got it.
15:19:43 <donri> romm: also remember that "do" isn't something special, it just translates to monadic operators and the types of the arguments to those operators must match
15:20:08 <colock> a
15:20:11 <romm> i'm not sure exactly what a monad is, yet.
15:20:27 <latro`a> donri--he's around chapter 9 of LYAH, where they're doing IO and such before introducing monads in full
15:20:35 <donri> @undo do { gen <- newStdGen; let x = take jumps $ randomRs (0, max_range) gen; return (\a b -> a + b) }
15:20:36 <lambdabot>  Parse error at "}" (column 97)
15:20:53 <donri> @undo do gen <- newStdGen; let x = take jumps $ randomRs (0, max_range) gen; return (\a b -> a + b)
15:20:53 <lambdabot>  Parse error at end of input
15:20:55 <donri> :(
15:20:57 <donri> latro`a: ah
15:20:59 <EvanR> > "’ "
15:21:00 <lambdabot>   "\8217 "
15:21:20 <EvanR> > ord "\8217"
15:21:21 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:21:22 <lambdabot>         against inferred type...
15:21:35 <EvanR> > ord '\8217'
15:21:36 <lambdabot>   8217
15:21:59 <romm> really difficult to do anything without complete knowledge of the language :)
15:22:18 <EvanR> romm: do you need help with something specific
15:22:39 <ion> > ord '\&'
15:22:40 <lambdabot>   <no location info>:
15:22:40 <lambdabot>      lexical error in string/character literal at chara...
15:23:19 <latro`a> romm--iirc LYAH tries to get across that once IO is in the picture it basically can't be removed from the picture
15:23:49 <latro`a> this means that if you do some IO in a function, its return type is going to have IO in it
15:24:40 <donri> but note that it doesn't mean you have to sprinkle IO all over your code: you can generally write most of the code pure, and then call those functions from IO code
15:24:45 <latro`a> right
15:24:48 <donri> (just sayin.)
15:24:50 <romm> latro`a: it's okay, i got the whole "tainted as impure" deal, i think.
15:25:04 <EvanR> its pretty easy to explain that if you want to do IO, you have to be a value of or be a function returning type IO something
15:25:27 <latro`a> that is, you use functions with type a->IO b
15:25:32 <merijn> Man, one of these days I should just finish writing an "Haskell IO as first class actions" explanation, doesn't something like that exist already?
15:25:43 <latro`a> to assemble IO actions
15:25:45 <donri> all it really means is there's no function "IO a -> a" (except there is, but few are skilled enough to use it properly)
15:26:33 <EvanR> > const undefined :: IO a -> a
15:26:34 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Types.IO a -> a)
15:26:34 <lambdabot>    arising fr...
15:26:37 <romm> okay, no i've move to "couldn't deduce n ~ Int from context Num n".
15:26:38 <EvanR> ^
15:26:40 <donri> but, this is not a general rule for monads in general. just something to remember.
15:27:05 <Ralith> donri: there are proper ways to use that function?
15:27:13 <ion> ralith: yes
15:27:14 <donri> Ralith: sure
15:27:23 <Ralith> such as?
15:27:25 <merijn> Ralith: Yes, there's some library code that uses it
15:27:30 <latro`a> getStdGen actually uses it
15:27:33 <merijn> Ralith: Also, top level IORef's/MVar's
15:27:43 <merijn> errr
15:27:43 <EvanR> er
15:27:44 <latro`a> (via a top level IORef like merijn mentioned)
15:27:45 <ion> ralith: FFI calls whose only impurity is e.g. memory allocation
15:27:51 <donri> i suspect bytestring uses it
15:27:54 <EvanR> top level IORefs is no
15:27:55 <merijn> Ignore apostrophes. Stupid English grammar
15:28:05 <merijn> EvanR: Why?
15:28:13 <latro`a> eh, maybe not top level IORefs, but yeah
15:28:39 <EvanR> global variables are bad, but even worse in haskell
15:28:41 <latro`a> theStdGen :: IORef StdGen
15:28:42 <latro`a> theStdGen  = unsafePerformIO $ do
15:28:42 <latro`a>    rng <- mkStdRNG 0
15:28:42 <latro`a>    newIORef rng
15:28:49 <donri> and yes ffi, when you know the code behaves purely
15:29:06 <EvanR> you cant control the sequence or timing of IO that is unsafelyPerformed
15:29:36 <MostAwesomeDude> latro`a: Seen the MonadRandom monad?
15:29:48 <latro`a> sure
15:29:57 <ion> evanr: I’m not sure how that statement leads to top-level IORefs being implicitly bad.
15:30:08 <noteventime> romm: It's because max_range defaults to Int
15:30:26 <latro`a> damned monomorphism restriction
15:30:29 <noteventime> Indeed
15:30:32 <EvanR> MostAwesomeDude: MonadRandom is a class
15:30:35 <EvanR> not a monad
15:30:45 <noteventime> romm: Give max_range the explicit type "Num a => a"
15:30:58 <MostAwesomeDude> EvanR: Oh, derp.
15:32:40 <MostAwesomeDude> The monad's called Rand, sorry.
15:33:03 <ion> Ayn
15:33:11 <romm> noteventime: if what you said is true, shouldn't it work if i write 10000 instead of max_range?
15:33:24 <donri> moar liek ayn rant amarite
15:34:51 <startling> I have a labelled rose tree. How should I take a Tree k (Maybe a) and return the paths to the Nothings, [[k]]?
15:35:08 <noteventime> romm: I'd think so
15:35:25 <donri> romm: perhaps better give things more specific types (i.e. Int)
15:35:38 * noteventime suspects donri has been reading too much uncyclopedia
15:36:05 <donri> actually no :)
15:36:32 <noteventime> No, it has to be Random
15:36:44 <noteventime> But why is there defaulting at all then?
15:37:09 <noteventime> If the signature is explicitly made polymorphic?
15:37:44 <merijn> noteventime: There is no explicit polymorphic signature for max_range?
15:38:03 <noteventime> merijn: max_range was replaced by the literal 10000
15:38:04 <romm> i removed max_range. i wrote 10000 instead.
15:38:19 <merijn> ah
15:38:26 <noteventime> Actually actually, since the random values are never used it has nothing to do with the type signature
15:38:34 <merijn> And that still doesn't work?
15:39:10 <hpaste> romm pasted “Could not deduce (n ~ Int)” at http://hpaste.org/72362
15:39:25 <noteventime> romm: The problem is take, take takes an int
15:40:00 <noteventime> romm: and jumps has type n, so GHC figures out n must equal Int, which is more specific than what you've specified
15:40:37 <noteventime> romm: Either give it the type "Int -> IO (Int -> Int -> Int)" or the type "Num n => Int -> IO (n -> n -> n)"
15:40:41 <merijn> romm: In the future could you paste the code and error? The error doesn't seem to be for the code paste I was looking at? (Since you presumably fixed some stuff there)
15:41:07 <romm> merijn: pardon. will do.
15:42:08 <latro`a> random silly question: where's on defined?
15:42:16 <latro`a> or is it specific to lambdabot
15:42:34 <ddarius> @hoogle on
15:42:35 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
15:42:35 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
15:42:35 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
15:42:39 <noteventime> latro`a: Data.Function, I think
15:42:59 <latro`a> oh, hoogle
15:43:02 <latro`a> I tried @where, derp
15:43:08 <latro`a> dumb idea
15:44:15 <romm> noteventime, cool, this fixed it. now it asks me to add a type signature to... "0" in the "randomRs (0, 10000)"
15:44:51 <danharaj> Does anyone know what laws PartialLens needs to obey in the data-lens package?
15:45:14 <donri> romm: if you move out 10000 again and give it the signature Int, you won't get that error
15:45:24 <romm> i'm learning this way, but i have to say it's a bit frustrating.
15:45:47 <romm> donri, why does it need a signature for a literal?
15:45:59 <ddarius> :t 3
15:46:00 <lambdabot> forall t. (Num t) => t
15:46:06 <donri> romm: the literal has a polymorphic type
15:46:22 <merijn> romm: Since you never use the results of random it can't infer which type you wanted (numeric literals are polymorphic)
15:46:37 <donri> :t []
15:46:38 <lambdabot> forall a. [a]
15:46:42 <romm> could i do: (0 :: Int, 10000: Int) ?
15:46:43 <merijn> romm: If you had used the results somewhere the compiler would've inferred the requested type from that use
15:46:54 <donri> romm: sure. only need it for one of them though i think
15:46:56 <danharaj> (0 :: Int, 10000) should be sufficient
15:47:00 <merijn> romm: Yes, although the second would be redundant
15:47:04 <romm> okay, cool.
15:47:19 <donri> which is why it would have worked if you kept your max_range definition and made it an Int
15:47:20 <merijn> romm: Basically this is the problem
15:47:25 <merijn> :t 0
15:47:26 <lambdabot> forall t. (Num t) => t
15:47:39 <romm> merijn: i think i understood.
15:47:49 <merijn> :t (0 :: Int)
15:47:50 <lambdabot> Int
15:47:54 <romm> no type inference when i don't use the stuff...
15:48:13 <danharaj> It is infering a type, the type is just too general.
15:48:26 <donri> polymorphic types have to be specialized at some point
15:49:21 <romm> i thought i knew programming. this is like discovering a new continent.
15:49:24 <merijn> danharaj: I've been informed that data-lens is no longer hip and edwardk's Control.Lens (in the lens package) is superior in pretty much every way, including being compatible with the operators from data-lens
15:49:32 <donri> hehehe
15:49:34 <edwardk> not with data-lens
15:49:40 <edwardk> its compatible with the ones from lens-family
15:49:43 <startling> romm: exciting, right?
15:50:01 <merijn> edwardk: Ah, seems mostly compatible (with at least the basics) of data-lens?
15:50:05 <donri> @remember <romm> i thought i knew programming. this is like discovering a new continent.
15:50:05 <lambdabot> Good to know.
15:50:14 <edwardk> the ideas from data-lens, yes, the types, no
15:50:27 <ion> @remember romm i thought i knew programming. this is like discovering a new continent.
15:50:27 <lambdabot> Nice!
15:50:30 <ion> @forget <romm> i thought i knew programming. this is like discovering a new continent.
15:50:30 <lambdabot> Done.
15:50:36 <danharaj> I guess I can switch to lens from data-lens.
15:50:57 <donri> wasn't sure of the syntax there
15:51:05 <merijn> edwardk: Well, I meant that more in the sense of (^.), (^=), etc. still working. Barring any type signatures it should still work, no?
15:51:06 <romm> startling: i really can't say. i'm "trust falling" here. i'm learning all of this in the hopes that there will be some gain, but it is impossible for me to see that gain from where i'm currently standing.
15:51:21 <edwardk> yeah
15:51:28 <merijn> romm: Well, at the very least you'll look much smarter ;)
15:51:32 <edwardk> ^= got renamed to ^~, otherwise its pretty close
15:51:42 <startling> romm, you'll get there, don't worry. any specific questions/frustrations?
15:51:43 <romm> i have a irritating itch to dump this and go back to my pseudo-functional python, but i'll try to press on.
15:51:46 <edwardk> some shorter names got added
15:51:53 <danharaj> I dislike the ^ in the operator names because I have to reach my finger quite far to use them :P
15:51:57 <edwardk> and you don't need as many lenses because you can compose directly with getter
15:52:01 <solrize> ^~ is pretty hard to type
15:52:02 <romm> merijn: thankfully, i don't need to impress anyone :)
15:52:09 <merijn> danharaj: Same here
15:52:16 <edwardk> ^~ is there because ^= is the state equivalent
15:52:31 <edwardk> unfortunately := and :~ aren't legal operators
15:52:32 <merijn> But at the least I want have to keep doing "import Prelude hiding ((.),id)" any longer
15:52:37 <donri> ^ is easy on swedish layout ^_^
15:53:01 <MostAwesomeDude> edwardk: Hey, is there yet a variant of ^= that returns m () ?
15:53:03 <startling> why aren't (:=) and (:~) legal?
15:53:04 <donri> ^ and ~ are on the same key though
15:53:08 <donri> with different modifiers
15:53:15 <edwardk> startling: those are reserved for constructors
15:53:19 <ion> ^ is annoying in the Finnish layout, but not too bad in the US layout.
15:53:26 <startling> edwardk: ah, right
15:53:36 <romm> amazing, it compiled. thanks guys.
15:53:42 <MostAwesomeDude> I find myself writing _ <- lift $ thing ^= someLens $ something
15:53:44 <merijn> MostAwesomeDude: For StateT?
15:53:50 <donri> > let (=:) = 1 in (=:)
15:53:51 <MostAwesomeDude> merijn: Yeah.
15:53:51 <lambdabot>   1
15:54:04 <danharaj> edwardk: should I consider data-lens obsolete?
15:54:05 <edwardk> MostAwesomeDude: you want Lens a b c d -> (c -> m d) -> a -> m b  ?
15:54:16 <MostAwesomeDude> edwardk: https://github.com/MostAwesomeDude/baskerville/blob/master/Baskerville/Beta/Session.hs#L115
15:54:25 <MostAwesomeDude> Admittedly, this is *not* healthy code.
15:54:27 <edwardk> danharaj: yes
15:54:29 <donri> i suppose =: could be interpreted as %= (:)
15:54:33 <danharaj> okey-dokey.
15:54:38 <MostAwesomeDude> Also I was thinking of ~= not ^=
15:54:40 <edwardk> donri: i thought about =: and ~:
15:54:48 <edwardk> but they break symmetry with all the others
15:54:55 <danharaj> Will there be another lens revolution or are van laarhoven lenses 'the right idea'?
15:55:05 <edwardk> MostAwesomeDude: the name for this lovely operator is 'id'
15:55:26 <McManiaC> I get a "Command terminated" when trying to call a C-function through the FFI, is this a Haskell/FFI error or is the C lib messing up?
15:55:28 <MostAwesomeDude> edwardk: Oh, with new lenses?
15:55:33 <MostAwesomeDude> This is old lenses still.
15:55:37 <edwardk> MostAwesomeDude: if you don't have an Applicative or Functor you can use mapMOf myLens somefun
15:56:01 <MostAwesomeDude> edwardk: This is in Conduit ... ... (StateT MyStateStruct IO)
15:56:04 <edwardk> MostAwesomeDude: then you're SOL ;)
15:56:17 <startling> MostAwesomeDude, heh, Bravo in Haskell?
15:56:20 <MostAwesomeDude> startling: Yes.
15:56:37 <edwardk> you ave to lift $ someLens ^= value $ … or whatever
15:56:54 <MostAwesomeDude> Until somebody invents real protocols in Haskell, I'm just gonna accept that Conduit ... ... (RWST SomeBigassStateStruct IO) is what I want.
15:56:57 <donri> MostAwesomeDude: void $ thing.someLens %= something -- or what are you on about?
15:57:12 <MostAwesomeDude> Er, RWST MyConfigFile MyLogger MyStateStruct IO
15:57:31 <startling> MostAwesomeDude, how's it working for you? I feel like Twisted/Python is natural for this kind of thing; I haven't tried network protocol stuff in haskell at all
15:57:33 <MostAwesomeDude> donri: Yeah, that might be more pleasant.
15:57:39 <edwardk> there should be a function that characterizes a lens by running it over a functor
15:57:57 <MostAwesomeDude> startling: After doing Twisted, I'm convinced that people need to accept protocols as an abstraction, and desire it in all networking libraries forever and ever.
15:58:00 <merijn> startling: I used to think Twisted was awesome, then I realised simple threads were much nicer for networking :p
15:58:10 <edwardk> (^%%=) :: Functor f => Lens a b -> (b -> f b) -> a -> f aSource
15:58:20 <danharaj> failed to build lens-1.1 on GHC 7.4.1 :(
15:58:30 <edwardk> danharaj: ack, what did it miss!?
15:58:31 <startling> MostAwesomeDude: I know, right?
15:58:33 <donri> aww Conduit isn't a MonadState
15:58:45 <danharaj> I'll paste the error.
15:58:49 <edwardk> please
15:59:04 <MostAwesomeDude> Conduit doesn't have instances for any of its inner MTL stuff. I figured that's just 'cause it's hard to get 'em all.
15:59:13 <hpaste> danharaj pasted “lens build fail” at http://hpaste.org/72364
15:59:15 <donri> hm lens-1.1 built fine for me on 7.4.1
15:59:16 <startling> merijn: heh. I think threads make sense in a language like haskell, but I'm not convinced they're useful in languages like python.
15:59:22 <MostAwesomeDude> But it *does* understand MonadIO for its inner workings, usually, which is what matters.
15:59:43 <danharaj> I may have a broken environment. Who knows.
15:59:55 <shapr> Yay Haskell!
15:59:59 <MostAwesomeDude> Yay!
16:00:05 * shapr cheers happily
16:00:08 <merijn> startling: Agreed, but that's because OS threads are a bit dumb for most purposes
16:00:09 <donri> danharaj: maybe you have multiple containers
16:00:14 <startling> merijn: indeed.
16:00:15 <merijn> startling: So are threads with mutable shared state
16:00:23 <startling> merijn, yeah, exactly.
16:00:35 <danharaj> donri: How can I check for that?
16:00:41 <merijn> Once you realise those two ideas multithreading is easy :p
16:00:43 <danharaj> also don't tell me I have to nuke my environment again :[
16:00:45 <donri> danharaj: ghc-pkg list
16:00:54 <donri> danharaj: ghc-pkg list lens, even
16:01:04 <donri> no, you can unregister packages
16:01:17 <donri> uh, not lens, containers
16:01:19 <MostAwesomeDude> merijn: At that point, your concurrency model doesn't actually involve threading.
16:01:38 <danharaj> indeed I do have two containers.
16:01:44 <danharaj> But they are different major versions.
16:02:22 <donri> danharaj: if you're doing "cabal install lens" that tends to be problematic
16:02:34 <donri> works better to depend on it in your own cabal project
16:03:17 <donri> but you could try adding a --constraint or maybe unregistering one of the containers
16:04:25 <edwardk> danharaj: ah it could be the bount on the containers dependency
16:04:34 <edwardk> danharaj: what version of containers are you using?
16:04:42 <danharaj> 0.5.0.0
16:04:54 <danharaj> I just tried hiding my 0.4.2.1 version and that didn't quite work.
16:05:06 <edwardk> which one is in the platform?
16:05:13 <danharaj> Who knows :[
16:05:33 <edwardk> i'm still using that version. i can fix it if i can find when the updateMin call for IntMap changed
16:05:47 <edwardk> i think i'm working on 0.4.2.1
16:05:54 <edwardk> but maybe not on 0.5
16:05:56 <danharaj> ah, hm.
16:06:02 <edwardk> so i'd presume the 0.5 switch over was what broke me
16:06:18 <donri> containers-0.4.2.1 should be platform
16:06:23 <danharaj> it is indeed, just checked.
16:06:41 <danharaj> I don't like keeping in step with platform because of the long release cycles.
16:06:50 <donri> which is what i'm using as well, maybe it doesn't work with 0.5?
16:07:17 <donri> danharaj: try: cabal install lens --constraint="containers<0.5"
16:07:20 <romm> what's the easiest way to take a sublist from indicies a to b in some list L?
16:07:46 <edwardk> adding a MIN_VERSION_containers check to wrap that line
16:08:01 <edwardk> and i'll push it up with 1.1.1
16:08:04 <otters> you can't make left-recursive parsers in parsec, can you
16:08:04 <edwardk> in a few minutes
16:08:15 <donri> romm: probably combining drop and take... but such code is rarely what you want in haskell
16:08:19 <edwardk> otters: nope
16:08:24 <danharaj> This is why I rely on edwardk brand packages :P
16:08:24 <jfischoff> > take 3 .  drop 5 [0..]
16:08:25 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
16:08:25 <lambdabot>    arising from a use...
16:08:53 <jfischoff> > take 3 .  drop 5 [0..] :: [Int]
16:08:54 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:08:54 <lambdabot>         against inferred type ...
16:08:56 <danharaj> > take 3 . drop 5 $ [0..]
16:08:58 <lambdabot>   [5,6,7]
16:09:06 <jfischoff> ;p
16:09:12 <danharaj> remember that juxtaposition binds harder than anything lese
16:09:18 <romm> donri: i have a list representing piecewise densities, and i want to "integrate" over such a range. i can't think of any other approach.
16:09:19 <danharaj> else*
16:10:14 <donri> romm: duno your use case but lists are mainly used as control structures for recursion. if you want arbitrary access something like vector is better.
16:10:25 <edwardk> i really like the traverseArray stuff in the current version
16:10:38 <edwardk> i'll have to add Data.Vector.Lens to vector-instances as well
16:11:33 <EvanR> romm: for matlab style arrays and slicing and stuff use vectors or arrays not lists
16:11:57 <donri> huh, vector isn't in platform
16:12:32 <donri> i think platform should throw out some oldies and introduce some new'uns
16:12:53 <parcs`> romm: drop (a-1) (take b xs)
16:13:30 <parcs`> actually, it's just drop a, not a-1
16:14:35 <donri> parcs`: hm isn't the order you're applying the functions wrong there
16:14:42 <romm> heh. Data.Vector isn't in the docs. thanks for the info!
16:14:51 <donri> @hackage vector
16:14:51 <lambdabot> http://hackage.haskell.org/package/vector
16:14:59 <donri> also http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
16:15:04 <EvanR> each library has its own docs
16:15:49 <parcs`> > let sublist a b xs = drop a (take b xs) in sublist 3 6 [0..10]
16:15:50 <lambdabot>   [3,4,5]
16:16:01 <romm> EvanR, but it comes with ghc no? shouldn't it be in the docs then?
16:16:34 <parcs`> donri: b is an absolute position not a relative one
16:16:35 <EvanR> not sure which docs youre talking about, but System.IO Control.Monad etc all have similar docs
16:16:50 <danharaj> I'm pretty sure vector is in the platform and not bundled directly with ghc
16:18:49 <donri> EvanR: no, vector isn't a core package
16:18:56 <donri> nor a platform package
16:19:03 <donri> uh, that was meant for romm
16:19:15 <donri> romm: you'll have to do "cabal install vector"
16:19:52 <donri> danharaj: nope http://hackage.haskell.org/platform/changelog.html
16:20:04 <danharaj> Weird.
16:20:09 <romm> donri, wait. i haven't heard about "cabal" before, but ghci doesn't complain when i "import Data.Vector"
16:20:16 <edwardk> donri: vector is going into the platform, there has just been a bit of a row over safe haskell support, etc.
16:20:29 <EvanR> cabal is required reading
16:20:56 <romm> it looks like absolutely everything is required reading in haskell :)
16:21:14 <EvanR> if you cant cabal install the libs, you cant use them
16:21:19 <merijn> romm: It's more of an infinite priority queue :p
16:21:37 <merijn> I never read cabal, I just did "cabal install whatever" and so far it worked :p
16:21:39 <donri> weeeeell you can install some libs from linux repos
16:21:53 <danharaj> The most embarassing thing in Haskell is the error you get from a bad Array index.
16:22:00 <donri> sudo yum install ghc-vector  :)
16:22:08 <startling> romm: edwardk will invent several more things before you can understand them
16:22:09 <merijn> romm: Cabal is just the package/dependency manager for haskell packages
16:22:14 <donri> (actually ghc-vector-devel)
16:22:22 <edwardk> =)
16:22:35 <merijn> romm: Compare with easyinstall, pip, that sorta thing
16:23:06 <romm> easyinstall is totally not a required reading in python :P
16:23:30 <donri> romm: oh? how did you get by without it?
16:23:36 <merijn> Like I said, I never read up on cabal and so far "cabal install whatever" and occasional nuking of my local installed libraries was sufficient for me :p
16:23:51 <edwardk> hrmm there need to be lenses for FilePath
16:24:01 <merijn> edwardk: Get coding!
16:24:05 <edwardk> =)
16:24:06 <donri> edwardk: you mean String, or system-filepath?
16:24:14 <edwardk> System.FilePath
16:24:16 <EvanR> romm: like ruby gems
16:24:18 <merijn> Both!
16:24:20 <donri> that's just String
16:24:23 <danharaj> Are you sure you're not just weilding a lens and every data type looks like an ant? :P
16:24:23 <edwardk> yes
16:24:33 <edwardk> but there are filepath'ish ways of manipulating the string
16:24:39 <edwardk> danharaj: i am
16:24:44 <donri> (confusingly, system-filepath is a package that does *not* export System.Filepath)
16:25:13 <edwardk> ok, System.IO.Lens for stuff in System.IO using filepath ;)
16:25:27 <donri> \o/
16:27:24 <donri> romm: i find most docs in python even introduce you to virtualenv (there was even a blog post complaining about that practice)
16:27:56 <edwardk> danharaj: patched
16:28:09 <edwardk> should be showing on hackage when it refreshes
16:28:37 <danharaj> thanks.
16:28:41 <danharaj> Now to grok this lens package.
16:28:53 <danharaj> And hope new technology doesn't appear while I read.
16:29:14 <romm> donri: thankfully i never needed to distribute / depend on dead libraries, so my experiences with virtualenv or easyinstall are very limited.
16:29:14 <donri> romm: http://kev.inburke.com/kevin/virtualenv-is-an-anti-pattern-for-beginners/
16:29:18 <Ralith> this is Haskell
16:29:31 * danharaj fears the edwardk singularity when new concepts will appear faster than they can be absorbed.
16:29:36 <Ralith> by the time you've grokked one lib, three more ones will have appeared that obsolete it
16:29:45 <donri> romm: "dead"? but you do need libraries? at that point you need to know how to install them
16:30:09 <edwardk> danharaj: another fun one is 'bound' ;)
16:30:18 <edwardk> danharaj: in terms of 'random new edwardk technologies'
16:30:33 <danharaj> I don't recall a blog post on it.
16:30:36 <danharaj> Therefore it is not technology yet.
16:30:51 <danharaj> This is seriously how I decide to try a package.
16:30:59 <edwardk> danharaj: i gave a talk, so its dead to me ;)http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less
16:31:02 <romm> donri: virtualenv and easyinstall are depolyment tools. specifically virtualenv is usually used when you need to use some specific version of a library. this has never been the case for me.
16:31:03 <Ralith> edwardk: hey, what do you do for a living?
16:31:26 <edwardk> Ralith: i work for s&p capital iq, basically we make tools for quants
16:31:31 <donri> romm: so when you code in python (not deploy), how do you get libraries to use in your code?
16:31:51 <Ralith> edwardk: sounds fun; NYC?
16:32:01 <edwardk> Ralith: mostly i work on our compiler for a haskell-like language
16:32:03 <edwardk> Boston
16:32:14 <romm> donri: well of course i use setup tools/ easyinstall. but i never used them as a *developer*
16:32:31 <Ralith> why haskell-like, and not haskell proper? Parallel efforts seem wasteful.
16:32:31 <donri> romm: aren't those sentences contradictory?
16:32:59 <edwardk> haskell-like because it includes a bunch of extra stuff for polymorphic kinds, and row types.
16:32:59 <danharaj> iirc edwardk's team's language works in the java vm?
16:33:12 <edwardk> also because we don't really make an effort to comply with the harder to write parts of haskell
16:33:17 <romm> donri: i meant to say, that i do not provide modules through easy install. i'm only a user of that tool.
16:33:18 <edwardk> danharaj: and that
16:33:24 <edwardk> our ffi is entirely JVM focused
16:33:31 <danharaj> edwardk: harder parts of haskell or the harder parts of *ghc*.
16:33:47 <donri> romm: ah, you mean you don't write setup.py files. well, you can do the same with cabal. just "cabal install vector". now you can "import Data.Vector".
16:34:01 <edwardk> haskell. for instance we do fixity declarations differently, which lets us do prefix and postfix operators that work right
16:34:03 <romm> already did.
16:34:10 <edwardk> e.g. you can parse 1 - - 2  correctly in ermine
16:34:29 <danharaj> I don't know if I want to parse that.
16:34:35 <edwardk> 1 - -2
16:34:53 <noteventime> What are row types?
16:35:09 <danharaj> I still don't want to parse that! Ew.
16:35:27 <Ralith> edwardk: I suppose your employer wants it to remain proprietary? I know some people that would love to have a JVMy haskell-like
16:35:32 <edwardk> noteventime: basically they let you talk about structures that have or lack given fields
16:35:52 <edwardk> Ralith: currently. they are slowly coming around on open sourcing, but its a lot of red tape
16:35:58 * hackagebot metadata 0.1.0.3 - metadata library for semantic web. (KatsutoshiItoh)
16:36:00 * hackagebot lens 1.1.1 - Families of Lenses, Folds and Traversals (EdwardKmett)
16:36:02 * hackagebot dropbox-sdk 0.3.1 - A library to access the Dropbox HTTP API. (KannanGoundan)
16:36:10 <danharaj> yesss
16:36:14 <edwardk> and its a bit of implementation effort to split out all the capitaliq specific stuff from the language proper
16:36:31 * Ralith nod
16:36:40 <Ralith> best of luck!
16:36:52 <edwardk> it works pretty well, we get a lot of mileage out of it
16:37:11 <edwardk> i was actually kind of negative about the idea of writing it before i started working here
16:37:33 <edwardk> but less rational heads prevailed, and now we have a pretty neat dev environment ;)
16:37:39 <Ralith> heh
16:37:43 <danharaj> edwardk: successful build.
16:37:44 <noteventime> edwardk: Any good reference? google scholar gives me "The changing skid row scene." from Quarterly Journal of Studies on Alcohol and duckduck gives me touch typing lessons
16:37:55 <romm> yep. it sounds odd that someone would prefer that over "proper" languages.
16:38:01 <edwardk> noteventime: look for mitchell wand, and harper and pierce
16:38:07 <noteventime> Thanks
16:38:25 <edwardk> romm: if you'd written enough scala you'd know why we wanted our own little language ;)
16:38:54 <edwardk> noteventime: we support row types with disjointness constraints which is a bit different than the usual papers
16:39:18 <edwardk> noteventime: so you can say (a <- (b,c)) =>  … to say that the fields of row 'a' can be partitioned into sets b and c
16:39:21 <romm> haskell is my first "top generation" language. i don't know scala, vala, clojure etc. :/
16:40:05 <donri> top generation?
16:40:12 <romm> edwardk, does that mean that everyone else in the field use scala?
16:40:13 <edwardk> noteventime: the usual go to example for us is that we can give a strong type to, say, natural join on a database.
16:40:37 <edwardk> noteventime: join :: (a <- (d,e), b <- (e,f), c <- (d,e,f)) => [..a] -> [..b] -> [..c]
16:40:41 <EvanR> i like structural types, on the surface
16:40:56 <EvanR> but scalas impure strict makes me nervous
16:41:22 <edwardk> it takes two relations each of which can have their fields partitioned partitioned, into local-only (d or f) and common fields (e) and yields a relation with all the fields
16:42:07 <edwardk> [..a] is a database relation parameterized by its row type
16:42:39 <monochrom> hrm, why is it not written [..c] <- [..b] <- [..a] <= (a <- (d,e), b <- (e,f), c <- (d,e,f)) ?
16:42:43 <gnezdo> Hi, I'm trying to define a macro in ghci. I need to get a function of a value in ghci environment computed and included into the result. But I can't seem to do the resolution from String variable name to its value. Any trick I'm missing? Looking at http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/ghci-commands.html
16:42:53 <edwardk> monochrom: =)
16:43:03 <monochrom> hehe
16:43:26 <edwardk> <- was a hole in the grammar ;)
16:43:40 <edwardk> and it was the symbol we wrote on the board a lot when defining partitioning
16:43:41 <gnezdo> I want something like this: :def inc (\v -> show $ (magic v) + 1)
16:43:57 <gnezdo> And then do let m = 3
16:44:01 <gnezdo> :inc m
16:44:08 <gnezdo> and get back a 4
16:44:16 <EvanR> gnezdo: why not use let on that first functions
16:44:18 <gnezdo> So, is there a magic?
16:44:42 <gnezdo> EvanR: the funcion for def is String -> IO String
16:44:52 <gnezdo> I know the name, not the value
16:45:12 <monochrom> what is magic?
16:45:17 <EvanR> a string to get the value from the ghci environment
16:45:25 <gnezdo> that's exactly what I want to know
16:45:26 <EvanR> variable of that name
16:45:49 <monochrom> I see what you mean now
16:45:58 <gnezdo> magic :: String -> a
16:46:02 <noteventime> edwardk: Interesting, while I'm still not completely there, am I correct in that this allows you to do something like typesafe R data frames?
16:46:05 <gnezdo> for all a :)
16:46:32 <geekosaur> gnezdo, possibly you want read, but it would help to have a more specific problem description
16:46:35 <monochrom> String would mean you will enter :inc "m" rather than :inc m
16:46:39 <noteventime> (Seems reasonable if it works for data bases)
16:46:41 <edwardk> noteventime: basically our entire database stack works this way so we can know all the relational data typechecks with few if any annotations
16:46:47 <geekosaur> what problem are you trying to solve, exactly?
16:46:58 <edwardk> we use it for generating reports, etc.
16:47:06 <gnezdo> geekosaur: No, it's not a read, it's a name of a value in ghci environment
16:47:24 <geekosaur> gnezdo, do you know Haskell?  because that answer suggests you don't
16:47:38 <geekosaur> read is a standard function which parses a value out of a String
16:47:42 <EvanR> gnezdo is asking about a ghci trick, not really haskell
16:47:43 <edwardk> also the target mini-language is simple enough that you could run it in js with very little effort
16:47:43 <gnezdo> geekosaur, LOL
16:47:52 <gnezdo> yess, I need a ghci trick
16:48:06 <edwardk> i've seriously considered embedding an interpreter for it in excel
16:48:21 <mroman> gtfo o_O
16:48:22 <geekosaur> last I checked ghci tricks were done with haskell code... still not sure what is being asked for, then
16:48:39 <EvanR> geekosaur: ghci commands arent haskell code
16:48:51 <EvanR> :t etc
16:48:52 <lambdabot> Not in scope: `etc'
16:48:57 <edwardk> mroman: it would actually work really well =)
16:49:08 <gnezdo> OK, the problem is I want to pretty print a proto buffer value. I have an executable from binary proto form to pretty ascii.
16:49:36 <geekosaur> ok, maybe I am misunderstanding the question entirely.  "The command :def name expr defines a new GHCi command :name, implemented by the Haskell expression expr, which must have type String -> IO String. " is what I have been referring to
16:49:52 <EvanR> yeah his question was confusing
16:50:22 <gnezdo> OK, I want String to be the name of a value in ghci environment
16:50:30 <EvanR> he wants ghciLookupHack :: String -> Maybe a
16:50:39 <geekosaur> and, well, a lot of things are best done by :def and not by trying to kung-fu something else, as I understand it
16:50:45 <fuchsto> EvanR: Are you still around?
16:50:51 <EvanR> fuchsto: no, why
16:51:04 <fuchsto> EvanR: Sorry, nevermind then :P
16:51:09 <EvanR> im joking
16:51:22 <fuchsto> EvanR: Just wanted to let you know how AWESOME your proposed solution works
16:51:27 <EvanR> haha
16:51:35 <EvanR> yeah thats a classic trick
16:51:40 <fuchsto> EvanR: I'm pushing it to github now
16:51:57 <EvanR> i think SML, ocaml people had to do that back in the stone age
16:52:02 <monochrom> oh my god, the semantics of :def is subtle. or rather, the semantics of what you define with :def is subtle
16:52:07 <fuchsto> EvanR: Right now i'm passing along a record of functions as a "Interface definition" of the visual component used.
16:52:35 <gnezdo> monochrom: how's :def subtle?
16:52:40 <danharaj> edwardk: what would the thingy be that is like the ix lens over an array except it checks bounds?
16:52:41 <fuchsto> EvanR: The function needing concrete visuals is using the record's "newVisual" function to load a concrete implementation.
16:52:51 <gnezdo> it seems dumb, not subtle from here :)
16:52:57 <edwardk> danharaj: you can make a traversal for it
16:53:02 <edwardk> traverseIx or something
16:53:07 <edwardk> i suppose i could add it
16:53:20 <edwardk> you can't use ^. with that though
16:53:30 <fuchsto> EvanR: I just have to write an article about this concrete solution, it's just amazing. It's dependency injection deluxe double-plus good
16:53:35 <monochrom> try :def inc (\s -> return (s ++ " + 1"))
16:53:52 <edwardk> you can use headOf or ^= on it though
16:53:54 <fuchsto> EvanR: So again, thanks
16:54:06 <EvanR> alrighty
16:54:10 <ParahSailin> how is the performance of parsec?
16:54:11 <danharaj> alright. I'll see what works.
16:54:15 <edwardk> inlike with a map, the usual hack of making a lens that retuens Maybe fails
16:54:23 <danharaj> too bad
16:54:28 <edwardk> ParahSailin: its not terrible, its slower than trifecta or attoparsec, but usable
16:54:37 <gnezdo> monochrom: yeah, that works for simpler cases, but when I need to double pump it, I don't see how. Namely, I need something like eval.
16:54:41 <danharaj> That would work for getting but I don't see how a lens returning a Maybe can satisfy the setting laws.
16:54:44 <EvanR> attoparsec is great
16:54:51 <fuchsto> EvanR: If it's a classic trick: How comes everyone is proposing type classes?
16:54:58 <EvanR> fuchsto: who?
16:55:07 <edwardk> danharaj: with Map you make a lens that returns Maybe v for the value at that position
16:55:16 <edwardk> setting it to Just v' uses insert
16:55:20 <edwardk> setting it to Nothing uses delete
16:55:22 <edwardk> this passes the laws
16:55:33 <edwardk> just like  the contains lens for a Set
16:55:35 <monochrom>  :def eval return
16:55:37 <gnezdo> I need something like :def pretty (\v -> ":! blah " ++ (magic v))
16:55:40 <fuchsto> EvanR: Like here: http://www.haskell.org/haskellwiki/OOP_vs_type_classes
16:55:42 <monochrom>  :eval 4 + 5
16:55:47 <edwardk> contains 2 ^= False $ fromList [1,2,3,4]    = fromList [1,3,4]
16:55:51 <edwardk> er ^~
16:56:03 <fuchsto> EvanR: It's on haskell.org, and it looked like what i wanted yesterday, when i implemented it
16:56:26 <gnezdo> Or rather: :def pretty (\v -> ":! blah " ++ (compute $ magic v))
16:56:34 <fuchsto> EvanR: It worked, too. Until i needed 'abstract' definitions.
16:56:36 <danharaj> I suppose you could do such a thing with arrays by making it contain Maybe's and expanding the array when you set out of bounds.
16:56:40 <EvanR> fuchsto: if you want an interface, you can use type classes. but your issue is that you wanted to swap out values which had different types but the same interface at runtime. at that point some people would suggest existential types. but you can also use partial application to get the same effect
16:56:42 <danharaj> But that's not quite the same idea.
16:56:44 <monochrom> ok, I don't know what blah means and what compute means
16:56:46 <edwardk> danharaj: blech =P
16:56:49 <danharaj> exactly :P
16:57:04 <monochrom> and what pretty means
16:57:11 <fuchsto> EvanR: Where can i learn more about existential types? (apart from googling it)
16:57:23 <EvanR> not sure, i would rather use partial application ;)
16:57:28 <danharaj> I think I'll just use the ix lens and do the bounds checks myself. It seems nicer. My only gripe with (!) is that if I do miss a check it doesn't tell me where it happened.
16:57:31 <fuchsto> EvanR: Nevermind, found an article in the haskell wiki
16:57:37 <gnezdo> blah is an external command
16:57:52 <danharaj> and my code has a weird interaction with ghci where if I try to catch exceptions it doesn't run.
16:57:58 <noteventime> Has anyone actually found a legitimate use for existential types?
16:58:10 <ParahSailin> whats the difference between alex, happy, parsec, etc?
16:58:10 <gnezdo> compute = $ Text.ProtocolBuffers.Basic.uToString $ Text.ProtocolBuffers.Identifiers.fiName $ Text.ProtocolBuffers.Reflections.protobufName $ Text.ProtocolBuffers.Reflections.descName $ Text.ProtocolBuffers.Reflections.reflectDescriptorInfo
16:58:12 <danharaj> wrapping GADTs
16:58:23 <fuchsto> EvanR: I'm pretty amazed by how powerful a clever combination of partial application works, but i don't like not knowing stuff
16:58:41 <noteventime> danharaj: Good point
16:58:50 <gnezdo> compute gives the name of the protocol buffer type given a proto value.
16:59:12 <c_wraith> noteventime: I've used them to implement polymorphic concurrency APIs that share a Chan
16:59:20 <danharaj> imo if you're using pattern matching on existential wrappers, you're probably doing something nice, but if you're using type classes with existential wrappers, you're probably doing something not nice.
16:59:33 <c_wraith> noteventime: the Chan doesn't know what types are being put into it - just that they fit together in a particular way
16:59:34 <monochrom>  :def pretty (\s -> return (":! blah " ++ s))  ?
16:59:50 <noteventime> c_wraith: Sounds clever, have you written anything about it?
17:00:08 <gnezdo> monochrom: I need a function of the value, not the name
17:00:09 <nand`> ah, I can't redefine macros? I was thinking of having some fun with a macro defining itself
17:00:27 <c_wraith> noteventime: nope. not even using that code anymore, either. Nothing wrong with it, just didn't fit the changing requirements of the project
17:00:50 <monochrom> actually I am not sure what is the type of compute
17:01:08 <monochrom> should I learn this Text.ProtocolBuffers.Reflections thing?
17:01:36 <gnezdo> *Main> :t tail . Text.ProtocolBuffers.Basic.uToString . Text.ProtocolBuffers.Identifiers.fiName . Text.ProtocolBuffers.Reflections.protobufName . Text.ProtocolBuffers.Reflections.descName . Text.ProtocolBuffers.Reflections.reflectDescriptorInfo
17:01:40 <gnezdo> tail . Text.ProtocolBuffers.Basic.uToString . Text.ProtocolBuffers.Identifiers.fiName . Text.ProtocolBuffers.Reflections.protobufName . Text.ProtocolBuffers.Reflections.descName . Text.ProtocolBuffers.Reflections.reflectDescriptorInfo
17:01:44 <gnezdo>   :: Text.ProtocolBuffers.Reflections.ReflectDescriptor a =>
17:01:47 <gnezdo>      a -> [Char]
17:02:07 <startling> I'm having a lot of trouble with what should be a simple thing: I want to list the paths to all leafs in a labelled rose tree satisyfing a given predicate.
17:02:11 <startling> How would you all do it?
17:02:21 <ParahSailin> :t go
17:02:23 <lambdabot> Not in scope: `go'
17:02:31 <EvanR>  :t goto
17:02:37 <EvanR> LineNumber -> IO ()
17:02:44 <EvanR> ++
17:03:00 <EvanR> see also BASIC monad
17:04:44 <Nereid> startling: list all paths, and then filter?
17:05:02 <startling> Nereid: oh, that's a nice approach
17:05:28 <Nereid> how else would you do it
17:06:24 <startling> Nereid: hence my question
17:06:31 <Nereid> :v
17:08:50 <mekeor> wow, look at that:
17:08:51 <Nereid> startling: there's probably a more efficient way to do it if, say, the predicate can be determined to be false only by looking at a certain initial segment of the path
17:09:03 <mekeor> @pl foldr f z (x:xs) = f x (foldr f z xs)
17:09:03 <lambdabot> foldr = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . ap ((.) . flip . ((.) .)))
17:09:08 <startling> Nereid: it can't.
17:09:12 <EvanR> lovely
17:09:22 <mekeor> indeed :D
17:09:28 <Nereid> then I guess there isn't.
17:09:30 <JoeyA> :t flip flip
17:09:32 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
17:10:01 <EvanR> mekeor: you just demonstrated how to use point free transformation to produce a random number generator
17:10:52 <JoeyA> > flip flip 4 (-) 5
17:10:54 <lambdabot>   1
17:11:21 <JoeyA> @djinn a -> (a -> b -> c) -> b -> c
17:11:21 <lambdabot> f a b = b a
17:11:22 <monochrom> lambdabot has a generalized flip and generalized . too
17:11:31 <monochrom> :t Prelude.flip
17:11:31 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
17:11:36 <Nereid> :t Prelude.flip Prelude.flip
17:11:38 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
17:12:01 <JoeyA> > flip ($) 5 (-) 4
17:12:03 <lambdabot>   1
17:12:16 <mekeor> EvanR: oh, did i?
17:12:32 <EvanR> no
17:12:35 <EvanR> i was joking
17:12:39 <mekeor> :D
17:13:06 <mekeor> :t flip flip
17:13:07 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
17:13:24 <EvanR> im reading about phantom types
17:13:26 <EvanR> spooky
17:17:54 <monochrom> haha, phantom spooky
17:18:56 <hpc> :t flip flip `asTypeOf` flip ($)
17:18:57 <lambdabot> forall b a. a -> (a -> a -> b) -> a -> b
17:19:01 <hpc> yeeeessss
17:19:20 <hpc> :t flip `asTypeOf` ($)
17:19:21 <lambdabot> forall b a. (a -> a -> b) -> a -> a -> b
17:19:35 <hpc> well that was obvious
17:20:46 <c_wraith> noteventime: http://hpaste.org/72365 is a quick sketch of the same idea
17:28:15 <startling> what's the way to unload a module in ghc?
17:28:24 <dolio> :m -
17:28:26 <c_wraith> noteventime: though, come to think of it.. That same logic could be written without the existential..  typical.
17:28:47 <McManiaC> how can I get this gdb backtrace more informative? I already compiled with -debug http://npaste.de/Db/
17:28:53 <startling> dolio: thanks
17:31:34 <mekeor> the I combinator is id. the K combinator is const. is there a function in the base-package implementing the S combinator?
17:31:52 <dolio> ap
17:31:54 <geekosaur> ap?
17:32:01 <mekeor> :t ap
17:32:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:32:26 <mekeor> can i make lambabot replace "Monad m" with ((->) r) ?
17:32:56 <mekeor> :t let f x y z = x z (y z) in f
17:32:58 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
17:33:31 <Enigmagic> McManiaC: you don't. ghc doesn't emit debugging symbols that gdb could use to unwind the stack. if you're building without the llvm backend you can inspect $rbp and $rsp manually with x/a
17:33:41 <mekeor> geekosaur, dolio: cool. thanks =)
17:33:44 <dolio> One amusement is that the Applicative for (->) r has pure = K and (<*>) = S.
17:34:06 <mekeor> coool
17:36:53 <McManiaC> Enigmagic: x/a ? I'm a gdb noob
17:37:15 <Enigmagic> McManiaC: yeah, like: "x/a $rbp" or "x/40a $rbp"
17:38:28 <McManiaC> Enigmagic: I only get
17:38:28 <McManiaC> 0x0:    Error accessing memory address 0x0: Bad address.
17:38:38 <nand`> :t ap `asAppliedTo` (undefined :: a -> b -> c) -- mekeor
17:38:39 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
17:38:42 <EvanR> null pointer exception in haskell ;)
17:38:51 <EvanR> cant seem to get away from that crap lol
17:38:53 <Enigmagic> McManiaC: if you don't understand assembly level debugging you may want to consider an alternative debugging strategy
17:39:26 <Enigmagic> McManiaC: try running "frame 4" before x/a. with any luck you might get the STG registers back in scope.
17:39:48 <McManiaC> Enigmagic: yeah I have no idea about that actually
17:39:48 <McManiaC> lol
17:40:27 <Enigmagic> McManiaC: well... if you get consistent crashes what i would do is: rebuild libigraph (whatever that is) with debug symbols and set a breakpoint in c_igraph_create
17:40:45 <Enigmagic> then you'll be debugging C code instead
17:40:56 <mekeor> nand`: coool! :D
17:41:27 <mekeor> :t asAppliedTo
17:41:28 <Enigmagic> McManiaC: err, igraph_create not c_igraph_create
17:41:29 <lambdabot> forall t b. (t -> b) -> t -> t -> b
17:41:41 <mekeor> @src asAppliedTo
17:41:41 <lambdabot> Source not found. :(
17:41:50 <ParahSailin> @src "" lines
17:41:50 <lambdabot> Source not found. Wrong!  You cheating scum!
17:42:09 <geekosaur> @src lines
17:42:10 <lambdabot> Source not found. Where did you learn to type?
17:42:20 <mekeor> @type let asAppliedTo' f x = f where y = f x in asAppliedTo'
17:42:21 <lambdabot> forall t t1. (t -> t1) -> t -> t -> t1
17:42:28 <mekeor> that's it!
17:42:57 <mekeor> is asAppliedTo' lazy? i mean, does it eval x?
17:43:20 <nand`> it shouldn't
17:43:43 <mekeor> where's asAppliedTo defined? with @let in lambabot?
17:43:46 <nand`> you could get the same by just providing the type signature manually and defining asAppliedTo = const; I think
17:43:54 <mekeor> *lambdabot
17:44:10 <mekeor> nand`: ah, yea.
17:44:57 <nand`> isn't it defined in terms of asTypeOf or similar? (or was it vice versa?)
17:45:29 <mekeor> can anyone explain the second paragraph of <http://en.wikipedia.org/wiki/Point-free_programming> (beginning with "the key idea…"?
17:46:03 * hackagebot hdevtools 0.1.0.2 - Persistent GHC powered background server for FAST haskell development tools (BitConnor)
17:46:33 <danharaj> Functions on pairs to a domain are in one-to-one-correspondence with functions from the first ordinate of the pair to functions from the second ordinate to the domain.
17:46:56 <danharaj> and basically, the correspondence is entirely syntactic.
17:48:18 <mekeor> what do you mean by one-to-one-correspondence?
17:49:01 <c_wraith> usually, that means injective and surjective
17:49:14 <mekeor> ah
17:49:23 <mekeor> bijective, we call that.
17:49:55 <startling> "one-to-one correspondence" is sometimes given as a definition of bijectivity
17:51:07 <nand`> I'm acquainted with the idea of C^(A×B) being isomorphic to (C^B)^A in CCCs, but what does this have to do with pointless programming?
17:51:50 * mekeor knows "polymorphic" and "monomorphic" but still not "isomorphic"…
17:52:04 <latro`a> isomorphic == "has the same form"
17:52:18 <latro`a> a better definition is "is structurally the same"
17:52:24 <mekeor> ah
17:52:26 <nand`> f : A -> B and g : B -> A form an isomorphism if f∘g = id ∧ g∘f = id
17:52:50 <startling> mekeor: it's a looser definition of equality, basically
17:52:56 <mekeor> so, i can't say "x is isomorphic", right? i have to say something like "x is isomorphic to y".
17:52:59 <latro`a> yeah
17:53:06 <mekeor> fine :)
17:53:08 <latro`a> or "x and y are isomorphic"
17:53:26 <startling> or "there exists an isomorphism between x and y"
17:53:29 <nand`> the key point is that you can convert between the two without losing information
17:53:50 <nand`> in fact, without changing anything at all
17:53:56 <latro`a> still another way to define it is "the same, except for names"
17:54:16 <latro`a> that is, you can re-label the elements of A without changing their relationship amongst themselves and get B
17:54:22 <EvanR> if 'x and y are isomorphic' is ok, then all x in xs are isomorphic is also ok ;)
17:54:28 <EvanR> and xs could have zero or one thing in it
17:54:28 <parcs`> :t ap `asAppliedTo` undefined `asAppliedTo` undefined
17:54:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:54:33 <latro`a> are reciprocally isomorphic
17:54:36 <parcs`> :t ap `asAppliedTo` (undefined `asAppliedTo` undefined)
17:54:38 <lambdabot> forall a b t. (t -> a -> b) -> (t -> a) -> t -> b
17:54:42 <latro`a> is a better phrasing
17:54:47 <EvanR> therefore 'x is isomorphic' is valid! \o/
17:54:48 <latro`a> eh
17:54:52 <latro`a> I guess that's not necessary
17:54:53 <latro`a> also
17:54:55 <latro`a> nope
17:55:00 <mekeor> wait. (x^y)^z = x^(y*z), right? so (X -> Y) -> Z is the same as X -> (Y,Z)? that's probably bullsh**…
17:55:09 <latro`a> for a one element you get x is isomorphic to x
17:55:16 <latro`a> for a zero you get a null statement
17:55:32 <EvanR> for all x in [] money grows on trees
17:55:37 <EvanR> TRUE
17:55:39 <latro`a> indeed
17:55:50 <latro`a> in classical logic, anyways
17:56:00 <latro`a> type theory is intuitionistic so you lose in haskell :p
17:56:21 <EvanR> false
17:56:31 <heatsink> unprovable
17:56:49 <latro`a> yeah unprovable rather than false in intuitionistic logic
17:56:51 <latro`a> also
17:56:55 <latro`a> (X->Y) is Y^X
17:57:04 <mekeor> oh
17:57:04 <latro`a> consider for example X being a singleton
17:57:13 <latro`a> now a function from X to Y is basically just a member of Y
17:57:47 <latro`a> (that is, simply the member of Y conveys all the information conveyed by the whole function, since there's only one value you could feed into the function)
17:57:53 <startling> const x for all x in X.
17:58:21 <mekeor> latro`a: yeah, got it.
17:58:29 <latro`a> that said, you can't do the unpairing because that happens with the other associativity
17:58:30 <EvanR> can i get a finalizer that runs whenever a thread dies, either normally or via an exception
17:58:38 <latro`a> er, s/unpairing/pairing
18:00:35 <mekeor> (x^y)^z = x^(y*z)  <=>   Z->(Y->X) = (Y,Z)->X   which is true. nice.
18:00:59 <latro`a> erm
18:01:02 <heatsink> EvanR, see Control.Exception.finally
18:01:03 <latro`a> why did you flip on the other side
18:01:11 <EvanR> heatsink: what do i put it on
18:01:16 <mekeor> doesn't rly matter…
18:01:21 <JoeyA> I'm working on a size-bounded channel for STM.  That is, write blocks if the total "size" of items in the channel exceeds a given limit.  I have a little API design question.
18:01:40 <heatsink> EvanR, see the documentation http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/Control-Exception.html
18:01:45 <EvanR> ok
18:01:55 <JoeyA> Should I carry the itemSize :: a -> Int function along with the SBChan and make it a parameter to newSBChan, or should I make an ItemSize typeclass?
18:02:36 <JoeyA> The benefit of using a typeclass is that you can figure out what is meant by the "size" of an item by looking at the queue type.
18:02:54 <JoeyA> The drawback is that the size cannot carry dynamic information.
18:03:22 <McManiaC> Enigmagic: error is indeed in the C lib
18:03:32 <JoeyA> (By the way, I'm only going to support Int for item sizes.  It keeps the code simple, and it's good enough for representing in-memory sizes IMHO.)
18:03:50 <Enigmagic> JoeyA: if the size is defined with a typeclass then is there actually a benefit of using that vs a regular bounded queue?
18:04:12 <JoeyA> Enigmagic: The size of each item varies.
18:04:44 <JoeyA> For example, you might have: newtype MyString = MyString ByteString; instance ItemSize MyString where itemSize s = B.length s + 200
18:04:45 <Enigmagic> JoeyA: what do you mean by 'dynamic information' then?
18:05:22 <JoeyA> Maybe you need runtime information to decide how to size up an item for some reason.
18:05:39 <EvanR> 'you aint gonna need it'
18:05:43 <JoeyA> I think I'll just make an ItemSize class.
18:05:52 <JoeyA> Good call.  Thanks
18:06:22 <Enigmagic> JoeyA: you could always make it 'itemSize :: a -> m Int' and restrict it with a 'MonadBase STM m' constraint.
18:06:39 <Enigmagic> if other information is needed..
18:07:11 <JoeyA> Interesting idea.  I won't do it, though ;-)
18:07:30 <JoeyA> (at least not until someone has a compelling use case)
18:08:14 <startling> is there a typeclass of things that I can filter?
18:08:27 <JoeyA> You mean like Maybe a and [a] ?
18:08:30 <JoeyA> :t mfilter
18:08:31 <lambdabot> Not in scope: `mfilter'
18:08:36 <heatsink> :t guard
18:08:37 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:08:57 <JoeyA> > mfilter (<3) [1..10]
18:08:58 <lambdabot>   Not in scope: `mfilter'
18:09:21 <JoeyA> MonadPlus may be too strong, though.
18:09:24 <JoeyA> e.g. won't work for Map
18:09:29 <heatsink> yeah
18:09:30 <MostAwesomeDude> > do { x <- [1..10]; guard (x < 3); return x }
18:09:31 <lambdabot>   [1,2]
18:10:11 <startling> I think Functor and Monoid do it.
18:10:22 <startling> oh, Foldable too
18:10:45 <MostAwesomeDude> startling: I guess it depends on what you want the signature of your operation to look like.
18:10:47 <MostAwesomeDude> :t filter
18:10:48 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
18:10:48 <startling> foldr mappend . fmap predicate
18:11:09 <JoeyA> data Foo a = Foo !a !Int
18:11:18 <JoeyA> Is there any performance benefit to making a type argument strict?
18:11:33 <startling> oh wait, I'd need more than that -- predicate would conditionally return the original or mempty
18:11:34 <JoeyA> Or will that just introduce extra force operations?
18:11:39 <heatsink> You mean a field of a data structure?
18:11:42 <JoeyA> Yes
18:12:01 <JoeyA> Well, a field of a data structure that is a type variable.
18:12:08 <MostAwesomeDude> startling: I'm thinking about this, and MonadPlus seems like the correct generalization.
18:12:12 <mm_freak> JoeyA: extra force operations…  it's the poor man's way of writing proper functions =)
18:12:28 <mm_freak> JoeyA: in other words:  proper placements of 'seq' will always be at least as good
18:12:32 <JoeyA> MostAwesomeDude: Again, MonadPlus is restrictive, even in practice.  Data.Map doesn't have a Monad instance.
18:12:38 <MostAwesomeDude> Yeah, that's true.
18:12:42 <JoeyA> In fact, it can't have a Monad instance, because there's an Ord constraint on values.
18:12:45 <mm_freak> JoeyA: the only exception is when you unbox strict fields
18:13:02 <startling> filter' fn = foldr mappend . fmap (\x -> if fn x then x else mempty)
18:13:06 <MostAwesomeDude> But I don't think you can inhabit (a -> Bool) -> m a -> m a with valid semantics otherwise.
18:13:33 <MostAwesomeDude> :t filter' fn = foldr mappend . fmap (\x -> if fn x then x else mempty)
18:13:33 <lambdabot> parse error on input `='
18:13:35 <JoeyA> mm_freak: Thanks
18:13:39 <MostAwesomeDude> :t \fn -> foldr mappend . fmap (\x -> if fn x then x else mempty)
18:13:39 <lambdabot> forall a (f :: * -> *). (Monoid (f a), Monoid a, Functor f) => (a -> Bool) -> f a -> [f a] -> f a
18:14:09 <EvanR> heatsink: so forkIO (finally cleanUp theWorker)
18:14:19 <startling> you need Data.Foldable.foldr for it to be really general
18:14:20 <heatsink> EvanR, yes
18:14:23 <EvanR> er
18:14:29 <EvanR> finally theWorker cleanUp
18:14:34 <EvanR> er no
18:14:35 <MostAwesomeDude> :t \fn -> Data.Foldable.foldr mappend . fmap (\x -> if fn x then x else mempty)
18:14:35 <lambdabot> forall (t :: * -> *) a (f :: * -> *). (Monoid (f a), Data.Foldable.Foldable t, Monoid a, Functor f) => (a -> Bool) -> f a -> t (f a) -> f a
18:14:50 <mm_freak> EvanR: yes, the latter…  and it's customary to write it as:  forkIO (a `finally` b)
18:14:53 <heatsink> forkIO $ worker `finally` cleanUp
18:14:58 <mm_freak> because that's easier to align vertically
18:15:18 <JoeyA> @hackage async
18:15:18 <lambdabot> http://hackage.haskell.org/package/async
18:15:23 <EvanR> ok
18:15:32 <heatsink> Well, GHC might be smart enough to know that when a strict field is read, it doesn't need to be forced
18:16:02 <EvanR> cool then to end my thread early i can just throw an exception
18:16:08 <startling> anyway, none of this works since I don't have a Monoid. :(
18:16:09 <startling> oh well
18:16:20 * JoeyA gives startling a Monoid.
18:16:29 <mm_freak> EvanR: yes, but i found that some libraries (most notably HDBC) don't like that
18:16:32 <startling> :O
18:16:39 <heatsink> EvanR, you can, but that may be bad from a software engineering perspective
18:16:53 <heatsink> because it's invisible control flow
18:17:16 <mm_freak> EvanR: better be explicit about leaving a thread…  this is actually quite easy to do using STM
18:17:17 <EvanR> its the end of the thread, if it indeed does all the cleanup it needs to do, then thats great
18:17:32 <JoeyA> Another issue is that, if you use any "with" functions, you have to pray that none of them catch all exceptions.  Of course, the same argument applies to using System.Timeout.
18:17:35 <mm_freak> but still, use 'finally' even with explicit exits =)
18:18:19 <EvanR> another thread might kill me at any time, dunno how explicit i can make that ;)
18:18:22 <JoeyA> In any case, avoid asynchronous exceptions like the plague.  It'll drive you nuts if you have to go through all your IO code and wonder if it's exception safe or not.
18:18:55 <JoeyA> EvanR: My two cents: don't worry about it!
18:18:59 <JoeyA> Wait till you're done with your program
18:19:14 <EvanR> just accumulate threads?
18:19:17 <JoeyA> Then you'll know what threads might be killed asynchronously and what won't.
18:19:19 <mm_freak> EvanR: explicit means that your threads have a "graceful exit"
18:20:11 <mm_freak> just don't rely on exceptions to kill a thread
18:20:13 <JoeyA> One exception, though: library code that contains actions likely to block should be exception-safe.
18:20:24 <JoeyA> This way, users can safely use System.Timeout or similar.
18:20:24 <mm_freak> it will fail, and the bugs will be hard to find
18:20:32 <EvanR> uhg
18:20:36 <EvanR> this is getting hard
18:20:54 <mm_freak> EvanR: i'll write an example for you
18:21:15 <EvanR> i want to be able to kill my own thread or safely allow some other thread to kill me
18:21:38 <heatsink> Is the thread executing an event loop?
18:21:48 <heatsink> As in, wait for input, process input, and repeat?
18:21:51 <EvanR> its mainly blocking on input
18:21:57 <EvanR> from a handle
18:22:10 <EvanR> yes
18:22:18 <heatsink> You can make the thread block on (either input or interrupt signal)
18:22:36 <heatsink> There are libraries for that, I'm not familiar with them though
18:22:45 <monochrom> I heard that closing the handle (by another thread) is a good way to let your thread know. catch the exception.
18:22:50 <JoeyA> Control.Concurrent.Async might have something.
18:23:29 <JoeyA> EvanR: Does your program need to work on Windows?
18:23:34 <EvanR> hells no
18:23:39 <heatsink> heh
18:23:42 <JoeyA> Lucky
18:24:24 <JoeyA> One thing you have to worry about on Windows is: if a thread is blocked on recv, and you try to kill it, the thread calling killThread will block too!
18:24:38 <EvanR> ouch
18:24:58 <EvanR> well i dont think im going to try that trick
18:25:17 <Enigmagic> due to the lack of a modern IO manager on GHC/Windows. isn't a fundamental problem with Windows though.
18:25:28 <EvanR> but putting a Either Killed Input in every request is going to require two more threads for each thread
18:25:34 <EvanR> which means i have to worry about killing them :(
18:25:49 <heatsink> Why does it require more threads?
18:26:04 <EvanR> well right now it blocks on hGetSome
18:26:14 <EvanR> how would you allow an external signal
18:26:36 <EvanR> (besides an exception)
18:26:51 <heatsink> Use something that's a wrapper around select()
18:26:57 <EvanR> -_-
18:27:04 <heatsink> So it waits for the first available input from any source
18:27:36 <EvanR> why am i threading at all if im going to select
18:27:40 <heatsink> idk
18:28:09 <EvanR> i have a feeling selecting directly is just the road to C code in haskell
18:28:29 <heatsink> No, you use a wrapper around select
18:28:37 <EvanR> like what
18:28:43 <heatsink> Maybe someone who has done this kind of programming can explain better
18:28:58 <heatsink> Instead of threads, you program with coroutines
18:29:00 <EvanR> ghc io system is the wrapper around select
18:29:25 <EvanR> Control.Concurrent.yield, its already coroutines ;)
18:29:30 <EvanR> (in hugs)
18:30:28 <JoeyA> Come on, just kill the receiving thread with an async exception, and make sure the receiving thread is exception-safe.
18:30:46 <JoeyA> E.g. receive a message, then call an STM callback.
18:30:54 <EvanR> exception safe?
18:31:28 <JoeyA> An "exception-safe" action can safely be interrupted by an exception, asynchronous or otherwise, at any point.
18:31:33 <gtmanfred> 1:03:38
18:31:35 <gtmanfred> 21:03:42
18:31:37 <gtmanfred> 21:03:43
18:31:38 <gtmanfred> ... crap
18:31:59 <EvanR> this threads only external effect is writing to outgoing sockets and updating acid states
18:31:59 <JoeyA> x <- takeMVar x; x' <- doStuffWith x; putMVar mv x'
18:32:00 <heatsink> 21:03:44?
18:32:08 <JoeyA> This is (most likely) not exception safe.
18:32:09 <gtmanfred> i am just going to turn off my touch pad...
18:32:19 <EvanR> JoeyA: using withMVar
18:32:31 <Saizan> modifyMVar is though
18:32:31 <JoeyA> Right, but there's caveats to that, too.
18:32:36 <EvanR> or modifyMVar_
18:32:42 <JoeyA> EvanR: If you're calling
18:32:44 <JoeyA> oops
18:32:46 <JoeyA> http://hackage.haskell.org/trac/ghc/ticket/5870
18:33:16 <JoeyA> There's a case where modifyMVar_ was inappropriate, since it restores the exception mask for the inner code.
18:34:11 <JoeyA> EvanR: If your thread is calling out to third-party code, and your code needs to be thread-safe, then you'd better check the source of the code.
18:34:19 <JoeyA> err, exception safe
18:35:04 <JoeyA> If you can't tell if the third party code is exception safe or not, then spawn a thread that won't be interrupted.
18:35:51 <EvanR> JoeyA: -_-
18:35:55 <hpaste> “Ertugrul Söylemez” pasted “Properly killing a thread” at http://hpaste.org/72368
18:36:00 <mm_freak> EvanR: see the paste
18:36:05 <EvanR> ok
18:36:16 <heatsink> That is an interesting name
18:36:20 <mm_freak> this is how i spawn and kill threads
18:36:28 <ParahSailin> @let Ͼ(°◡°)Ͽ = 'monkey'
18:36:29 <lambdabot>   Improper character constant or misplaced '
18:36:40 <JoeyA> That paste looks like bug fodder.
18:36:50 <startling> @let Ͼ(°◡°)Ͽ = "monkey"
18:36:51 <lambdabot>  <local>:2:0: Not in scope: data constructor `<stderr>: hPutChar: invalid arg...
18:36:56 <mm_freak> JoeyA: how?
18:37:09 <JoeyA> Hmm, nevermind
18:37:19 <JoeyA> I thought I saw fixIO in there.
18:37:30 <mm_freak> what's fixIO?  mfix for IO?
18:37:36 <mm_freak> :t fixIO
18:37:37 <lambdabot> Not in scope: `fixIO'
18:37:42 <mm_freak> @hoogle fixIO
18:37:42 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
18:37:44 <JoeyA> Yes.
18:37:52 <startling> is there a c-- compiler in haskell somewhere? it's eminenently ungoogleable
18:38:01 <EvanR> that is a lovely bit of code there
18:38:07 <startling> reminds me of learning the language io
18:38:10 <JoeyA> Actually, that code looks alright.
18:38:13 <EvanR> mm_freak: why is all this necessary?
18:38:13 <gertc> http://stackoverflow.com/questions/11731941/haskell-facebook-exceptions
18:38:19 <mm_freak> EvanR: "all this"?
18:38:26 <heatsink> startling, it's called cmm in the GHC source
18:38:37 <startling> heatsink, oh, that might help
18:39:02 <geekosaur> cmm is not quite the same as c--, and I don't think you can do much with it as a separate entity
18:39:07 <dolio> startling: http://www.cminusminus.org/
18:39:14 <EvanR> mm_freak: is this to ensure the applied action is exception safe or
18:39:15 <dolio> cmm in GHC is rather different.
18:39:18 <EvanR> just a logging facility
18:39:38 <heatsink> The C-- project is kind of dead, though
18:39:41 <mm_freak> EvanR: this is just an example implementing a concurrent logger so that you can write to stdout from multiple threads
18:39:46 <dolio> yeah.
18:39:58 <mm_freak> EvanR: if you do it directly, the output may get interleaved
18:40:06 <startling> heatsink: is it? darn
18:40:16 <slack1256> "A ComonadApply w is a strong lax symmetric semi-monoidal comonad on the category Hask of Haskell types. "
18:40:20 <startling> well whatever, I need to write a typechecker first.
18:40:20 <EvanR> mm_freak: and withMVar is not enough?
18:40:24 * slack1256 head exploted
18:40:44 <gwern> slack1256: now you're just making shit up
18:40:53 <gwern> 'strong lax'? not even a mathematician could write that
18:40:56 <heatsink> Are you making a language startling?
18:40:57 <slack1256> http://hackage.haskell.org/packages/archive/comonad/3.0.0.1/doc/html/Control-Comonad.html
18:41:02 <mm_freak> EvanR: i'm using STM to gracefully kill the thread easily
18:41:13 <slack1256> And I'm not even joking
18:41:27 <mm_freak> for a simple logger this is sufficient:  forkIO . forever $ takeMVar msgVar >>= putStrLn
18:41:37 <mm_freak> then just putMVar msgVar
18:41:47 <mm_freak> but for a logger thread it's very important to kill it properly
18:41:48 <gwern> (oh for goodness sake)
18:41:53 <slack1256> gwern: the best part is the remark "That it to say that w is a strong lax symmetric semi-monoidal functor on Hask, where both extract and duplicate are symmetric monoidal natural transformations. "
18:42:04 <gwern> slack1256: oh, of course. that makes perfect sense
18:42:32 <EvanR> hahahaha
18:42:48 <EvanR> symmetric semimonoidal functors on hask are the best
18:42:59 <startling> slack1256: naturally
18:43:06 <startling> slack1256: the proof is trivial
18:43:09 <mm_freak> EvanR: withLogger makes sure that all messages are printed and the logger is exited before control is given back to the caller
18:43:10 <gwern> so smooth and symmetric
18:43:19 <mm_freak> so that no messages are lost
18:43:21 <fuchsto> EvanR: There is one problem left, if you have a minute
18:43:35 <mm_freak> because in haskell when the main thread exits, all threads exit with no opportunity to handle exceptions
18:43:55 <EvanR> mm_freak: i guess it would be nice to ensure a logging thread ends last
18:44:02 * heatsink didn't know threads were so complicated
18:44:14 <startling> heatsink: ha
18:44:15 <EvanR> i didnt know haskell threads were so complicated
18:44:21 <mm_freak> EvanR: yes, and that's how you do it:  withLogger . withServer $ myServerAction
18:44:26 <mm_freak> they aren't
18:44:30 <mm_freak> do the same in C++ =)
18:44:44 <heatsink> no.
18:44:50 <EvanR> mm_freak: however i dont have a logging thread right now and thats not what im trying to solve
18:45:03 <mm_freak> also i'm probably the only one doing it manually…  there are probably many libraries on hackage to make this thing more convenient
18:45:07 <heatsink> I mean, I _expect_ C++ threads to be complicated
18:46:17 <geekosaur> POSIX, at least, specifies that behavior for threads.  Haskell threads, in -threaded mode, are multiplexed onto POSIX threads (on POSIX platforms, at least) so are constrained to match theit behavior
18:46:17 <slack1256> gwern: Like in my tests. I'd put 'it's trivial' and let the teacher do the rest.
18:46:35 <heatsink> pffhahaha
18:46:39 <gwern> slack1256: such chutzpah
18:46:53 <EvanR> the proof is left as an exercise for the TA
18:47:11 <startling> "of course he gets an A. it's trivial!"
18:47:24 <heatsink> without loss of generality, I will prove this instead.
18:47:54 <EvanR> hahahahah
18:48:50 <heatsink> So I figured out why I dislike design patterns.
18:49:11 <heatsink> Good code should be derived from the problem specification.
18:49:22 <slack1256> EvanR: the funny thing is that I am a math student and usually when correcting test from younger years they say me that.
18:49:23 <heatsink> But design patterns always seem to be presented like magic formulas
18:49:56 <EvanR> design patterns are reusable code that somehow cant be made into a c++ library
18:50:10 <JoeyA> Or Haskell library, for that matter.
18:50:16 <EvanR> but they assure you its a good idea
18:51:46 <EvanR> so its more like 'rewritable code' ;)
18:51:56 <heatsink> But when explaining a design pattern, why not build it up one component at a time, based on the problem that it solves?
18:53:16 <startling> heatsink, if you could do that, you wouldn't need design patterns
18:53:57 <EvanR> i determined the solution to my problem
18:54:24 <EvanR> before the thread enters its wait for input, it checks an mvar to see if its full, if so, dies
18:54:39 <EvanR> if not, waits for input
18:54:48 <EvanR> ... now it cant be killed if its waiting
18:54:49 <EvanR> dammit
18:55:30 <EvanR> is there a function MVar a -> MVar b -> MVar (Either a b)
18:55:47 <JoeyA> There's STM, which can do stuff like that.
18:56:02 <EvanR> hmm not sure if i want to go there yet
18:56:23 <JoeyA> e.g. (Left <$> takeTMVar a) `orElse` (Right <$> takeTMVar b)
18:56:25 <JoeyA> Why not?
18:57:09 <EvanR> i dont think i want that anyway, and i dont want to rewrite my program
18:57:17 <mm_freak> come on, guys
18:57:27 <Enigmagic> EvanR: you can make it with tryTakeMVar
18:57:27 <mm_freak> we are using many great design patterns in haskell
18:57:37 <mm_freak> they are great, because they don't follow OO and buzzwords
18:57:41 <mm_freak> Monad is a design pattern
18:57:47 <EvanR> Monad is a library
18:57:51 <Enigmagic> i'd personally use STM though
18:57:53 <EvanR> violating my definition of design pattenr ;)
18:57:59 <mm_freak> just like Applicative, Coroutine, STM, concurrency, etc.
18:58:08 <mm_freak> EvanR: Monad is not a library
18:58:15 <EvanR> Control.Monad
18:58:23 <mm_freak> Control.Monad is a module
18:58:25 <startling> a design pattern is just a typeclass in a language without typeclasses
18:58:31 <mm_freak> and that's not the "Monad" i'm talking about
18:58:40 <mm_freak> i'm talking about Control.Monad.Monad
18:58:42 <EvanR> its a library for libraries
18:58:57 <startling> can I use lenses for something like pointer equality?
18:59:09 <mm_freak> it's a design pattern, because it provides a framework for expressing applications/computations
18:59:21 <fuchsto> EvanR: i can transform   data MyRecord v = { render :: v -> IO () }   to   data MyRecord { render :: IO () }   using partial application, but can i get rid of v in    data MyRecord { newFoo :: Something -> IO (v) }  ?
18:59:25 <mm_freak> startling: what is "pointer equality" and how would lenses fit in there?
18:59:25 <EvanR> design patterns from c++ dont have a framework
18:59:31 <heatsink> http://blog.ezyang.com/2010/05/design-patterns-in-haskel/
19:00:30 <EvanR> fuchsto: newFoo?
19:00:49 <fuchsto> EvanR: Then it's not a common interface for any type anymore
19:01:00 <mm_freak> EvanR: every standard or conventional way to express computation is a design pattern
19:01:03 <mm_freak> so is Monad
19:01:09 * hackagebot classy-parallel 0.1.0.0 - Fork of the monad-parallel package using monad-control (SamAnklesaria)
19:01:19 <startling> mm_freak, so I have a space with a value in it. can I use lenses to see if two things have "references" to that same space?
19:01:28 <latro`a> ...I hope that isn't like classy-prelude
19:01:29 <latro`a> *shudder*
19:01:40 <mm_freak> startling: be more concrete, because right now it sounds like you're not programming haskell
19:01:42 <EvanR> mm_freak: ok its just not what the buzzwords are referring to, that douchy periodic table of holy oop design patterns
19:02:03 <EvanR> fuchsto: i dont know what youre trying to accomplish anymore so
19:02:11 <fuchsto> EvanR: Funny thing is, it's okay when i pass it to a function like   display :: IORef (MyRecord v) -> IORef v -> Bla
19:02:13 <mm_freak> EvanR: yeah, OO design patterns suck, because OO (as commonly practiced) sucks
19:02:25 <mm_freak> and i'm talking about C++/java-like OO, not smalltalk
19:02:29 <fuchsto> EvanR: Same thing as before
19:02:31 <EvanR> replacing all types with A or Something or Foo removes stuff i can use to help
19:02:48 <startling> mm_freak: heh. Basically I'm playing around with a block/lexical-scoped progamming language. I'm trying to figure out how I'd resolve variables
19:02:59 <startling> how would I tell whether two variables refer to the same value?
19:03:04 * ddarius should write code right now, but he thinks he'll watch a movie instead.
19:03:09 <JoeyA> "heatsink> http://blog.ezyang.com/2010/05/design-patterns-in-haskel/" That's pretty much debunking Java design patterns as language features or unneeded in Haskell.
19:03:21 <heatsink> yeah
19:03:22 <JoeyA> Haskell has its own design patterns.
19:03:31 <ddarius> JoeyA: Indeed.  Such as monadic style.
19:03:36 <JoeyA> E.g. defining an application-wide monad
19:03:39 <EvanR> startling: sounds like its not referentially transparent
19:03:39 <mm_freak> startling: in the interpreter, no?
19:04:11 <mm_freak> startling: commonly you would carry a map of the currently in scope variables around while interpreting
19:04:13 <EvanR> fuchsto: in code that you didnt want to know about v, you obviously cant use an IO v
19:04:13 <fuchsto> EvanR: Well, the function record currently looks likes this:    data Visual v = Visual { render :: IO (), newVisual :: RenderSettings -> IO (v) }
19:04:38 <mm_freak> startling: interpret :: Map Name Expr -> Expr -> Result
19:04:42 <startling> mm_freak, oh, it's not a dynamic or interpreted language. I'm mostly trying to figure out how to type-check
19:04:46 <mm_freak> or more likely IO Result, if it's an imperative language
19:04:50 <fuchsto> EvanR: Right, but newVisual returns a different Type for every concrete implementation
19:05:01 <mm_freak> startling: then i'm not sure what you mean…  could you paste some code?
19:05:03 <EvanR> fuchsto: why is that in the record?
19:05:17 <EvanR> how is it useful to your generic code
19:05:23 <fuchsto> EvanR: The newVisual function is different for every type
19:05:47 <fuchsto> But it's a common function for every 'type'
19:05:53 <EvanR> what?
19:06:01 <EvanR> lost
19:06:11 * hackagebot cypher 0.8 - Haskell bindings for the neo4j "cypher" query language (SamAnklesaria)
19:06:21 <EvanR> fuchsto: i think you just shouldnt bundle them
19:06:24 <fuchsto> I have, say, to implementations for this function record
19:06:31 <fuchsto> -two implementations
19:06:35 <ddarius> @hackage equivalence
19:06:35 <lambdabot> http://hackage.haskell.org/package/equivalence
19:06:42 <startling> mm_freak, nope, I don't have any yet besides a few designs that I considered and threw away.
19:07:08 <mm_freak> startling: are you trying to implement a domain-specific language for expressions?
19:07:17 <EvanR> fuchsto: lets say you want to load a 'new instance of the visual interface' with IO, you can do this
19:07:18 <ddarius> That might not be the one I want.
19:07:36 <EvanR> fuchsto: Record { render :: IO (), load :: Record }
19:07:50 <startling> mm_freak: no. I'm just playing around with ASTs right now, with a far-off goal of ending up with a compiled language.
19:07:51 <EvanR> fuchsto: but then, you see that it doesnt make sense in this case to bundle load inside a Record
19:07:56 <EvanR> so dont
19:08:01 <fuchsto> EvanR: Ah, nice, in my case, v always is a record
19:08:18 <mm_freak> startling: yes, that's what i mean
19:08:20 <EvanR> er load :: IO Record
19:08:23 <mm_freak> an AST is a DSL, too =)
19:08:24 <fuchsto> so i could use    data Visual = Visual { newVisual :: IO(Record) } ?
19:08:30 <startling> mm_freak: s'true.
19:08:32 <EvanR> dont put parens
19:08:38 <mm_freak> startling: now it highly depends on the kind of language you're implementing…  tell me about it
19:08:39 <fuchsto> sorry, IO Record it is
19:08:59 <EvanR> fuchsto: now that you are omitting parts of this record type, im confused why its a record type
19:09:07 <ddarius> @hackage persistent-equivalence (this one?)
19:09:07 <lambdabot> http://hackage.haskell.org/package/persistent-equivalence (this one?)
19:09:11 <startling> mm_freak: expressions are blocks, variables, and function calls
19:09:19 <startling> (for now)
19:09:19 <EvanR> and now newVisual1 :: IO Visual1, newVisual2 :: IO Visual2
19:09:23 <EvanR> not*
19:09:26 <startling> mm_freak: right now I've got something like
19:09:41 <mm_freak> startling: so an imperative language with action grouping and group-scoped local variables?
19:10:07 <startling> mm_freak: yeah.
19:10:16 <fuchsto> EvanR: Well, every implementation of Visual has an own record type for storing its state
19:10:21 <EvanR> fuchsto: maybe you are grouping stuff into a single record type when it makes no sense to
19:10:36 <EvanR> are you trying to make a graphics output api?
19:10:41 <fuchsto> newVisual returns an initial state. updateVisual expects the current state and returns the next one
19:10:44 <mm_freak> startling: there are a few ways to do it, but for an imperative language you would usually want to use a simple command language and then apply Free to it to get a free monad
19:10:57 <fuchsto> EvanR: Yes, OpenGl
19:11:00 <mm_freak> Free is in the control-monad-free package
19:11:13 * hackagebot records-th 0.1.0.0 - Template Haskell declarations for the records package (SamAnklesaria)
19:11:39 <mm_freak> data Command a = PutLine String a | GetLine (String -> a)
19:11:49 <mm_freak> or rather…
19:11:54 <mm_freak> data CommandF a = PutLine String a | GetLine (String -> a)  deriving (Functor)
19:11:59 <hpaste> startling pasted “block-scoped thing” at http://hpaste.org/72370
19:12:03 <mm_freak> then:  type Command = Free CommandF
19:12:09 <startling> mm_freak: ^ so that's what I've got-ish
19:12:30 <EvanR> fuchsto: loadVisual1 :: Visual, loadVisual2 :: Visual
19:12:35 <EvanR> or IO Visual
19:12:43 <mm_freak> startling: don't even think about concrete syntax now
19:12:52 <mm_freak> implement the abstract syntax independent of the concrete one
19:13:02 <startling> mm_freak: yeah! that's what I'm trying to figure out
19:13:06 <fuchsto> EvanR: I can't use IO Visual because it's not a complete type
19:13:19 <EvanR> why not
19:13:31 <startling> mm_freak: so how do I tell whether a Variable refers to a block-local, or something higher-up?
19:13:38 <fuchsto> Because it depends on the concrete implementation of Visual.
19:13:51 <EvanR> fuchsto: the type doesnt. whats the kind of Visual?
19:13:55 <mm_freak> startling: well, right now you don't have any "actions"
19:13:57 <fuchsto> So i have Visual Cube, Visual Sphere etc.
19:14:01 <nand`> Free was like Mu but with a termination, right?
19:14:05 <mm_freak> startling: an action should really be a separate expression type
19:14:12 <EvanR> fuchsto: no, you eliminated that variable earlier with partial application
19:14:23 <EvanR> now they are all Visual
19:14:23 <fuchsto> EvanR: No, that's the point!
19:14:34 <mm_freak> startling: think of a language like this:  { f(x); { g(y, z); h(v); }; i(n); }
19:14:50 <mm_freak> startling: you have two types in there:  one Block type and one Expr type
19:14:55 <fuchsto> EvanR: I couldn't, because there are return types that depend on it, like    updateVisual :: v -> v    or newVisual :: IO (V)
19:14:58 <mm_freak> the Expr captures the individual statements
19:15:01 <ddarius> data Free f a = Return a | Roll (f (Free f a))
19:15:10 <fuchsto> EvanR: That's what i was talking about before
19:15:29 <EvanR> fuchsto: you arent making sense anymore. ive lost track of what you mean by Visual, v, and V
19:15:44 <fuchsto> only v, the V was a typo
19:15:55 <fuchsto> Visual is the function record
19:16:12 <fuchsto> v is a type variable depending on the concrete implementation
19:16:15 <mm_freak> startling: Expr can be really simple:  data Expr = Call Name [Expr] Expr | Nop
19:16:22 <EvanR> only put functions in there that depend on the contexts that have different types
19:16:32 <mm_freak> startling: you may want to call Expr Command instead
19:16:43 <mm_freak> oh wait
19:16:48 <startling> mm_freak, I think maybe you're misunderstanding my problem
19:16:50 <mm_freak> data Expr = Call Name [Expr] Expr | Nop | Var Name
19:16:54 <EvanR> initialization functions have no place in there
19:17:31 <fuchsto> Okay, hm, and update functions?
19:17:51 <fuchsto> Like    updateState :: v -> v    (old state -> new state)
19:17:51 <EvanR> update functions, so now were back to what i was saying earlier
19:18:19 <fuchsto> i can get rid of the parameter with partial application, but not of the return type
19:19:01 <tertl4> http://www.youtube.com/watch?v=mbFceBSIBow
19:19:03 <fuchsto> I should remove the initializer functions, that's right
19:19:07 <EvanR> PoorMan = PoorMan { state :: A, next_state :: PoorMan }
19:20:02 <fuchsto> EvanR: Yes, but this now depends on A
19:20:12 <fuchsto> EvanR: Which is generic in my case
19:20:16 <EvanR> A has nothing to do with your different types
19:20:21 <EvanR> A is a view of your hidden state
19:20:30 <EvanR> which is common to all instances
19:20:44 <mm_freak> startling:
19:20:45 <mm_freak> data Expr  = Call Name [Expr] | Var Name
19:20:45 <mm_freak> data Block = Block (Set Name) [Expr]
19:20:50 <mm_freak> isn't this sort of what you want?
19:21:22 <fuchsto> EvanR: Not quite, the state is a record in my case, and the record definition is different for every implementation
19:21:27 <nand`> aren't blocks Exprs in his language too?
19:21:28 <mm_freak> blocks have local variable names (perhaps as Map to be initialized properly) and a sequence of expressions
19:21:50 <startling> mm_freak: right
19:21:52 <mm_freak> nand`: i couldn't unify them nicely without thinking more, but it's probably good to keep them separate
19:21:58 <fuchsto> EvanR: E.g. SphereVisual would have a   SphereState { radius :: Float }   and   CubeVisual { side :: Float }
19:22:00 <EvanR> fuchsto: it doesnt matter that its a record, its hidden, it doesnt matter what it is, or that they are different
19:22:23 <EvanR> fuchsto: sure, that is hidden
19:22:27 <mm_freak> nand`: reason is that Call expects arguments as Exprs
19:22:32 <EvanR> fuchsto: you are confusing your hidden state with the common interface
19:22:39 <mm_freak> so an Expr should be something with a result, and i don't know what semantics startling has in mind
19:22:57 <startling> mm_freak, I think I'll have type annotations, too. so once I've got a Block (Map String Type), how do I go through and change each variable reference into something useful?
19:22:57 <EvanR> your hidden state obviously cant be directly used by the common interface
19:23:01 <fuchsto> Probably. I don't seem to understand what you mean by 'hidden'
19:23:22 <EvanR> lets say my api consists of a single value of type A
19:23:31 <mm_freak> startling: change Set Name to Map Name Type
19:23:43 <EvanR> now the question is how i can expose different versions of that A which depend on various types like B and C
19:23:51 <EvanR> here they are
19:24:00 <EvanR> mkA1 :: B -> A
19:24:03 <startling> mm_freak, and then what?
19:24:04 <EvanR> mkA2 :: C -> A
19:24:14 <EvanR> when you have an A, those B and C or whatever are hidden
19:24:30 <EvanR> mkA1 b :: A
19:24:43 <EvanR> whoever has the A has no idea the A depends on different types
19:24:51 <mm_freak> startling: the type language can be similar to haskell's:  data Type = FuncType | Type Name | TypeApp Type Type
19:25:06 <fuchsto> Yes, sure, but i don't see how this helps with the update function
19:25:18 <startling> mm_freak: sure, I've already got that
19:25:22 <fuchsto> Because the A would be different for every concrete implementation in my case
19:25:36 <mm_freak> startling: that's it…  you will come back to it later when you implement the type checker
19:25:40 <EvanR> fuchsto: then its not a common interface is it
19:25:59 <EvanR> you need to figure out whats common that youre trying to expose
19:26:03 <mm_freak> startling: as a side note imperative languages are really much easier to express using a free monad
19:26:21 <EvanR> they can all be drawing with opengl, ok
19:26:28 * ddarius is not sure why mm_freak limits this to imperative languages.
19:26:28 <fuchsto> EvanR: Or circumventing it by not needing to return the next state at all
19:26:35 <fuchsto> EvanR: So, refactor it to be common
19:26:40 <EvanR> they all seem to have a 'nextState' operation which advances them to a new hidden state based on the old one
19:26:52 <EvanR> you can hide the next state
19:26:56 <startling> mm_freak: how so?
19:26:56 <mm_freak> ddarius: because i haven't really tried this on a functional language yet
19:27:06 <mm_freak> ddarius: there i'm still doing explicit nesting
19:27:10 <fuchsto> EvanR: I could hide the next state by storing it in a hidden IORef
19:27:14 <mm_freak> (mostly because of historical reasons)
19:27:21 <startling> mm_freak: oh, right, to throw out the explicit nesting
19:27:23 <EvanR> fuchsto: you dont need that
19:27:25 <fuchsto> EvanR: So, an IORef that is only known to the implementation
19:27:32 <mm_freak> startling: to get do-notation for free
19:27:38 <EvanR> you can have a hidden IORef, but its not necessary
19:27:41 <mm_freak> that's one example
19:27:45 <ddarius> mm_freak: Reasonable answer.
19:27:55 <startling> mm_freak: ah
19:28:14 <mm_freak> startling: hence "free monad" =)
19:28:21 <EvanR> fuchsto: heres an instance of PoorMan updating his state
19:28:32 <startling> yep. you get some other cool stuff for free, too.
19:30:43 <mm_freak> yeah…  it's compelling that the compiler writes the Functor instance and Free writes the monad instance
19:30:50 <mm_freak> you basically get a whole language for free
19:31:52 <ddarius> data Auto a = Auto { get :: a, nextState :: Auto a }; makeAuto :: (x -> x) -> (x -> a) -> x -> Auto a; makeAuto step observe init = Auto (observe init) (makeAuto step observe (step init)); oneZero :: Auto Int; oneZero = makeAuto not fromEnum True; count :: Auto Int; count = makeAuto succ id 0;
19:32:41 <EvanR> ddarius: thanks
19:32:47 <mm_freak> that Auto is really just ZipStream…  if you add an input type, you get composition, too
19:32:59 <mm_freak> newtype Auto a b = Auto (a -> (b, Auto a b))
19:33:10 <mm_freak> and that one is already defined in the 'arrows' library
19:33:33 <startling> so: free monads: how do I have one that refers to itself? do I need a helper type?
19:33:42 <startling> *refers to itself in more than one place
19:33:47 <EvanR> however i have a feeling fuchsto wants something more complex
19:33:54 <mm_freak> startling: nope, you need nothing there
19:34:21 <mm_freak> startling: data CommandF a = Fork a a | PutLine String a
19:34:57 <mm_freak> EvanR: Auto is very powerful
19:35:04 <slack1256> anybody here has used the "rivers' package?
19:35:14 <startling> mm_freak, sure, that's what I meant by "helper type"
19:35:23 <mm_freak> startling: that's not a helper type
19:35:27 <mm_freak> it's the main type
19:35:48 <startling> mm_freak: and then don't you have Free Something CommandF?
19:35:59 <mm_freak> Free CommandF
19:36:09 <startling> mm_freak, which Free are you using?
19:36:17 <mm_freak> the one from control-monad-free
19:36:34 <startling> oh, I had previously used http://hackage.haskell.org/packages/archive/free
19:36:41 <mm_freak> that's probably fine
19:37:26 <mm_freak> yeah, it's the same Free type
19:37:54 <mm_freak> actually now that i read it, i could switch to 'free' instead =)
19:38:52 <startling> mm_freak: so Free CommandF has kind * -> *. what would that other type be?
19:39:18 <fuchsto> EvanR: Actually i thought what i needed was quite straight forward, but it looks like i was wrong
19:39:28 <quintessence> startling: monads have kind * -> *
19:39:36 <EvanR> fuchsto: better figure out all the things you want and if a common interface makes sense
19:40:01 <mm_freak> startling: the result type of the expression…  if there is no sensible in-haskell result, it's probably ()
19:40:08 <fuchsto> EvanR: I have a procedure rendering a screen. One component is 'abstract', the visual.
19:40:11 <startling> mm_freak: ah, I think I understand now
19:40:18 <mm_freak> startling: think of it this way:  interpret :: Command -> IO ()
19:40:25 <mm_freak> uhm
19:40:30 <mm_freak> startling: think of it this way:  interpret :: Command () -> IO ()
19:40:33 <startling> heh
19:40:39 <mm_freak> or perhaps even:  Command a -> IO a
19:40:44 <fuchsto> EvanR: The rendering procedure only calls  newVisual  to get an initial state, updateVisual to get the next one, and render.
19:41:06 <mm_freak> and:  typeCheck :: Command a -> Either String ()
19:41:23 <fuchsto> EvanR: And the implementation of those should be arbitrary (the rendering is agnostic of how this visual component is actually rendering itself)
19:41:27 <EvanR> fuchsto: updateVisual sounds like something that has not much to do with the graphics backend
19:41:51 <EvanR> i guess youre not talking about different backends so
19:41:58 <EvanR> just a little lost
19:42:15 <EvanR> if youre talking about different ways to show something with opengl, then thats easy
19:42:22 <fuchsto> EvanR: No, just different implementations of rendering
19:42:45 <mm_freak> fuchsto: i haven't really followed the discussion, but perhaps you're looking for FRP?
19:42:51 <EvanR> if youre talking about progressions of abstract shapes as running state machines
19:43:00 <fuchsto> EvanR: It's not -that- easy as every rendering loop changes the state of the component
19:43:11 <mm_freak> yes, definitely sounds like FRP
19:43:16 <fuchsto> mm_freak: Perhaps? What's FRP?
19:43:24 <mm_freak> fuchsto: functional reactive programming
19:43:28 <EvanR> well i wouldnt say rendering should change the state of anything
19:44:16 <mm_freak> fuchsto: in particular an AFRP program is a set of interconnected components each with local state, which evolve in individual instants
19:44:19 <fuchsto> EvanR: The 'real' changes happen in the render loop above
19:44:19 <EvanR> frmo what i can decipher, youre trying to have two kinds of data change through time, and drawing the opengl
19:44:30 <mm_freak> fuchsto: where the "A" stands for "applicative"
19:44:50 <fuchsto> mm_freak: That does sound like something i could need
19:45:06 <mm_freak> fuchsto: then see this:  http://www.haskell.org/haskellwiki/Netwire
19:45:15 <fuchsto> EvanR: Only one of those visual components is active at any time (for now)
19:45:28 <EvanR> not really important
19:45:30 <mm_freak> this is my humble AFRP implementation…  it's quite powerful and seems to do exactly what you want
19:45:56 <EvanR> in a single threaded context, only one thing is active at any time at all ;)
19:45:58 <fuchsto> EvanR: I have FFT data, and some features extracted from it, and those are projected to a visual (like a surface, a sphere, a cube, a velociraptor)
19:46:27 <fuchsto> EvanR: Naah, it's multithreaded. Sampling || Transformation || Rendering
19:46:57 <EvanR> up to this point all these didnt sound too separate
19:47:46 <mm_freak> they aren't, but sampling can occur while transforming and rendering can occur while processing the next instant
19:48:31 <EvanR> yeah getting away from this 'render loop' concept is probably good
19:48:33 <EvanR> frp
19:48:33 <fuchsto> EvanR: Well, let me put it in OOP ways: I have an interface for a visual, like    IVisual { void render(); IVisualState update( IVisualState current ); IVisualState initState(); }
19:48:47 <fuchsto> EvanR: And the main rendering loop is using this interface
19:49:08 <fuchsto> EvanR: Well, OpenGL is based on a rendering loop, i can't change that
19:49:22 <EvanR> did you write that loop?
19:49:45 <mm_freak> fuchsto: but you can make the rendering loop disappear…  meet FRP =)
19:50:01 <mm_freak> FRP allows you to express all this in a declarative DSL
19:50:28 <fuchsto> EvanR: Yes and no ... I wrote the loop using functions provided by GtkGlExt for rendering an OpenGL widget
19:50:59 <fuchsto> mm_freak: I will look into it as soon as i can, promised :) Thank you for the hint
19:51:45 <latro`a> I'm not really very familiar with FRP in general and am kinda interested in just fiddling with it, without an application in mind. anyone have a suggestion for a lib to start with?
19:51:46 <mm_freak> fuchsto: you don't need to promise…  i'm trying to help =)
19:51:52 <latro`a> the sheer number of choices is a little daunting
19:52:05 <mm_freak> latro`a: as the author of course i have to recommend netwire =)
19:52:07 <mm_freak> @hackage netwire
19:52:08 <lambdabot> http://hackage.haskell.org/package/netwire
19:52:52 <fuchsto> mm_freak: You are, you are
19:52:58 <mm_freak> there is also a wiki page with the same name, but that one is a little unfortunate, because it introduces only the somewhat awkward Arrow interface
19:53:07 <mm_freak> there is a much nicer applicative interface
19:53:18 <fuchsto> i'm on haskellwiki/Reactive right now
19:53:39 <fuchsto> it's a bit overwhelming for a Haskell newbie, but i can take it
19:53:40 <EvanR> i forgot where i was with my problem...
19:53:44 <mm_freak> currently the two major choices when it comes to FRP are netwire and reactive-banana
19:53:50 <EvanR> after 2 hours of fiddling with Auto ;)
19:53:59 <fuchsto> :)
19:54:10 <mm_freak> reactive-banana is great at doing UI stuff with widgets and such
19:54:29 <mm_freak> netwire is great for high performance applications like games and network applications
19:54:56 <latro`a> I see
19:55:00 <latro`a> any reason why they're listed last, then?
19:55:06 <latro`a> on the FRP page?
19:55:10 <mm_freak> probably because they are the youngest
19:55:12 <latro`a> ah
19:55:32 <mm_freak> most of the libraries are almost ancient and really never passed the experimental stage
19:55:44 <mm_freak> netwire and reactive-banana are ready for production
19:56:17 <fuchsto> mm_freak: Which one would you recommend for starters?
19:57:42 <mm_freak> well, until i find time to write a better wiki tutorial for netwire, reactive-banana is going to be easier to get into
19:58:11 <fuchsto> mm_freak: The problem is gtk
19:58:31 <VitamnP> does anyone know a good way of getting auto-indentation in haskell in vim
19:58:39 <fuchsto> mm_freak: Or perhaps it isn't after all
19:58:45 <mm_freak> well, netwire can be integrated into any kind of loop…  not sure whether reactive-banana is as flexible
19:58:53 <ddarius> VitamnP: set ai
19:59:39 <EvanR> mm_freak: is applicative interface newer?
20:02:01 <mm_freak> EvanR: the instances have been there for a long time, but only recently (that is since about half a year) i have recognized the power of applicative automaton style
20:02:27 <EvanR> applicative automaton style sounds like kung fu
20:02:36 <mm_freak> or rather like a year by now
20:03:05 <mm_freak> i don't remember when the blog article was written that shows how Category+Applicative is as powerful as Arrow
20:03:48 <EvanR> im looking through the hackage for netwire 3.1.0 and im having a hard time finding any significant amount of source code
20:04:06 <EvanR> not much docs
20:04:09 <EvanR> lots of arrows
20:04:58 <mm_freak> it's fully haddock-documented even though haddock doesn't work too well for data families
20:05:30 <mm_freak> the source code is pretty large actually, but the core module is Control.Wire.Types
20:05:32 <EvanR> got it
20:05:37 <EvanR> Control.Wire.Types
20:05:55 <EvanR> i do not know what data families is
20:06:02 <mm_freak> TypeFamilies
20:06:10 <mm_freak> netwire 3 uses a data family for efficiency
20:06:46 <EvanR> does it reduce type safety?
20:08:48 <mm_freak> EvanR: increase
20:09:09 <EvanR> heh i had a feeling youd say that
20:09:45 <EvanR> ctrl A D ing and walking home
20:10:00 <mm_freak> hf =)
20:24:17 <EvanR> enough pondering the meaning of data families, i got work to do
20:24:53 <EvanR> i simple way for a thread to read a socket, kill, or be killed
20:25:00 <EvanR> a*
20:30:45 <fuchsto> EvanR: The most straight forward solution i found until now is hiding the state (which is causing all the trouble) in an IORef
20:31:23 <EvanR> youre not actually trying to hide the state, youre trying to hide the type of the state in your type signatures
20:31:29 <EvanR> which an IORef doesnt help
20:31:37 <fuchsto> EvanR: So i have    render :: IO ()   and   update :: IO ()   instead of   render :: v -> IO ()   and  update :: v -> IO v
20:32:02 <mm_freak> data LocalState a = forall s. LS (s -> (a, s))
20:32:22 <fuchsto> EvanR: It does! The function record does not need a type variable any more
20:32:40 <fuchsto> EvanR: It's just    data Visual = Visual { render :: IO (), update :: IO (), ... }
20:32:52 <EvanR> good
20:33:07 <mm_freak> almost
20:33:08 <fuchsto> EvanR: And for every implementation, there is a function  createVisualX :: Visual
20:33:08 <EvanR> now you have recreated lisp, everything has type IO ()
20:33:10 <EvanR> lol
20:33:13 <mm_freak> data LocalState a = forall s. LS s (s -> (a, s))
20:33:15 <mm_freak> there you go
20:33:38 <EvanR> i mentioned existentials earlier
20:33:42 <mm_freak> Visual :: LocalState (World, Picture)
20:33:49 <mm_freak> but LocalState is not composable
20:34:10 <latro`a> <EvanR> now you have recreated lisp, everything has type IO ()
20:34:11 <mm_freak> data LocalStateA a b = forall s. LSA s ((a, s) -> (b, s))
20:34:12 <latro`a> ^lol
20:34:24 <mm_freak> that one forms a category and an arrow and is composable
20:34:28 <fuchsto> EvanR: With   createVisualX stateIORef = Visual { update = updateX stateIORef, render = renderX stateIORef, ... }
20:34:37 <fuchsto> EvanR: It's not pretty, but it should work
20:34:40 <mm_freak> but once you have committed to LocalStateA you have committed to Auto, because the two are equivalent =)
20:34:58 <latro`a> I still think EvanR had the right idea of making a sum type-like-thing
20:35:20 <EvanR> not really, hes got a lot more going on
20:35:23 <latro`a> ah
20:35:26 <EvanR> than the original question two days ago
20:35:34 <mm_freak> again, use the right tool for the job…  if you find that all your type signatures end in "IO ()", you're just writing C++ in haskell
20:35:36 <EvanR> im leaning toward netwire ;)
20:35:49 <fuchsto> mm_freak: I know :'(
20:35:51 <mm_freak> Auto is the right tool here, and that one naturally leads to FRP
20:36:00 <latro`a> if they *end* in IO () you aren't necessarily
20:36:04 <latro`a> if they *are* IO () you are
20:36:17 <EvanR> hehe yeah if they are all literally IO
20:36:18 <mm_freak> latro`a: if they end in IO () you're performing them for the side effects
20:36:21 <mm_freak> that's C++ programming
20:36:23 <maurer> 9~/win 22
20:36:25 <mm_freak> probably even worse than C++
20:36:26 <maurer> oops, sorry
20:36:28 <latro`a> eh
20:36:39 <latro`a> the putting together of the effects
20:36:45 <latro`a> could still be pretty haskelly
20:36:51 <latro`a> but just literal IO () everywhere isn't
20:36:55 <fuchsto> latro`a: They have side effects anyways, because it's rendering functions
20:36:58 <EvanR> literally all your top level things are IO (), and use global IORefs with unsafePerformIO xD
20:37:02 <latro`a> lol
20:37:04 <EvanR> ive got to see that done
20:37:09 <fuchsto> latro`a: There is no pure OpenGL API
20:37:11 <EvanR> before it die
20:37:11 <mm_freak> fuchsto: your transformation part can be entirely pure
20:37:20 <mm_freak> only the rendering and other I/O can be done in IO
20:37:29 <fuchsto> mm_freak: What do you mean by transformation part? The state increment?
20:37:38 <mm_freak> fuchsto: there is a pure OpenGL API, it's just not really powerful =)
20:37:40 <mm_freak> look at gloss
20:37:51 <latro`a> was gonna mention that actually
20:37:52 <fuchsto> mm_freak: It can't, because when updating the state, i am also changing a global buffer
20:38:05 <mm_freak> fuchsto: get rid of the global buffer
20:38:12 <EvanR> fuchsto: the idea in haskell is to compartmentalize IO so you dont have to look at its ugly ass no matter where in your codebase youre working
20:38:22 <mm_freak> get rid of anything that is "global" and go to the exact opposite
20:38:38 <fuchsto> mm_freak: Errm, like how? I am sampling an audio signal, and 3 threads are operating on those samples
20:38:43 <latro`a> hm, is StateT IO "compartmentalizing"?
20:38:56 <EvanR> not really
20:38:57 <mm_freak> latro`a: that's a kind error
20:38:59 <latro`a> didn't think so
20:39:01 <latro`a> erm
20:39:09 <latro`a> StateT s IO
20:39:11 <latro`a> sorry
20:39:29 <latro`a> (do want type level lambdas btw)
20:39:41 <EvanR> anonymous data plz
20:39:48 <mm_freak> fuchsto: the way i understand it you get an audio signal from some periphery like a microphone
20:39:56 <fuchsto> mm_freak: Right
20:40:11 <fuchsto> mm_freak: The 'global thing' is a sample buffer that is needed to pass samples between threads
20:40:14 <mm_freak> fuchsto: then you have some "machine" that acts on that signal…  that machine computes something from which another machine might compute an image
20:40:30 <mm_freak> correct?
20:40:37 <fuchsto> mm_freak: The problem is concurrency. It's Sampling -> Transformation -> Rendering
20:40:52 <mm_freak> first let me know whether i understood the application
20:40:59 <EvanR> /dev/dsp | program | glviz
20:41:03 <fuchsto> mm_freak: While running a signal transformation, sampling may continue. While running either sampling or transformation, rendering may continue
20:41:31 <mm_freak> fuchsto: this doesn't really sound like you need /anything/ global =)
20:41:59 <mm_freak> three threads:  one samples and pushes the sampled signals along an MVar
20:42:21 <fuchsto> mm_freak: One important thing:
20:42:48 <fuchsto> mm_freak: You can't handle samples one after another. One time you have 1 new sample ready for rendering, another time it's 20
20:43:02 <fuchsto> mm_freak: That's why there is a buffer
20:43:17 <mm_freak> the second thread pulls from the MVar and passes the samples into an FRP-style signal network…  that one produces some description from which you might compute an image…  that description is pushed along another MVar…  finally yet another thread pulls from that MVar
20:43:21 <fuchsto> mm_freak: Between sampling and transformation, i just use a Control.Chan
20:43:29 <fuchsto> mm_freak: So that's non-global
20:43:44 <mm_freak> as long as the buffer is local to the sampling thread, that's fine
20:43:50 <mm_freak> but then it's not global anymore
20:43:54 <johnw> does Scion work with GHC7 yet?
20:44:13 <fuchsto> mm_freak: the transformation thread does his FFT-thing and some feature extraction and the pushed the transformed signal to a buffer
20:44:47 <fuchsto> mm_freak: the buffer is behind an IORef, which is propagated as best practice when communicating with OpenGL
20:44:57 <mm_freak> fuchsto: you think too much in terms of buffers…  this is probably your main problem
20:45:12 <startling> is there a type somewhere like Qualified [a] a | Simple a ?
20:45:28 <mm_freak> startling: looks like a tree
20:45:31 <fuchsto> mm_freak: That's because i need them, probably.
20:45:32 <mm_freak> ah no
20:45:33 <geekosaur> johnw, when I poked at the git repo it appeared to hve support through 7.4.1.  no release has been made yet though
20:45:35 <startling> mm_freak: not at all
20:45:42 <mm_freak> startling: no, just define it
20:45:43 <geekosaur> so the one on hackage doesn't support ghc7
20:45:46 <johnw> ok, I'll give the repo a try
20:45:57 <mm_freak> fuchsto: probably, but only at one spot =)
20:46:12 <startling> yeah, thought it was kind of a shot in the dark, but it'd be handy not to define all these instances. oh well
20:46:28 <mm_freak> startling: 'deriving' doesn't help?
20:46:37 <fuchsto> mm_freak: Yes, between the transformation thread and the rendering, and that's where i use the buffer
20:46:49 <mm_freak> fuchsto: why a buffer?
20:46:56 <mm_freak> why anything mutable?
20:47:01 <startling> mm_freak: of course it does.
20:47:13 <fuchsto> mm_freak: It's possible that the rendering is too slow for rendering one frame for every sample it receives from the transformation thread
20:47:21 <EvanR> a Chan might be considered a buffer
20:47:31 <mm_freak> fuchsto: hence MVar, but you can also use TVar
20:47:53 <fuchsto> mm_freak: I am using an MVar in the rendering thread to wait for at least one new signal
20:48:14 <mm_freak> fuchsto: then where is the buffer?
20:48:15 <fuchsto> mm_freak: But it's possibly 100 new signals since the last rendering iteration
20:48:30 <mm_freak> and the rendering thread should only use the last one?
20:48:34 <fuchsto> mm_freak: That's what i need the buffer for.
20:48:50 <fuchsto> mm_freak: No, it should use every new signal since the last rendering iteration
20:49:04 <mm_freak> i see
20:49:09 <mm_freak> Chan is probably fine then
20:49:16 <fuchsto> mm_freak: Transformation runs a) fast and b) in parallel
20:49:47 <mm_freak> what's the most complicated part from an engineer's perspective?  the transformation thread i assume
20:50:12 <fuchsto> mm_freak: I use Chan between sampling and transformation, but a buffer (IORef [Signal]) between transformation and rendering
20:50:44 <fuchsto> mm_freak: the concurrency itself ... i fiddled around a lot until i had near-optimal latency
20:50:53 <EvanR> IORef >_>
20:51:07 <mm_freak> fuchsto: why IORef?  are you adding to the list as transformation proceeds?
20:51:13 <fuchsto> EvanR: IORef is the common solution for communication between the world and OpenGL
20:51:16 * hackagebot xml-types 0.3.3 - Basic types for representing XML (JohnMillikin)
20:51:21 <fuchsto> mm_freak: Yes, of course
20:51:28 <mm_freak> fuchsto: then IORef is not what you want =)
20:51:36 <mm_freak> use Chan or even TChan
20:51:48 <EvanR> opengl is in a forkOS
20:51:56 <EvanR> what does that mean for Chan
20:52:26 <mm_freak> forkOS = fork and run in bound thread
20:52:49 <mm_freak> that means that FFI calls are ensured to be called in a specific OS thread
20:52:55 <fuchsto> mm_freak: Every iteration in transformation yields one new signal, and consequently one modifyIORef on the buffer. Then, every once in a while, OpenGL enters a new rendering loop iteration (about 30 Hz, transformation could be, e.g. 100 Hz)
20:53:17 <fuchsto> mm_freak: True
20:53:19 <mm_freak> fuchsto: so?
20:53:37 <fuchsto> I don't see what's wrong with using an IORef here
20:53:37 <mm_freak> or wasn't that your reasoning against Chan/TChan?
20:53:48 <fuchsto> mm_freak: No, just explaining what's going on
20:54:23 <mm_freak> well, let me state it this way:  IORef is wrong in almost all cases
20:54:39 <fuchsto> mm_freak: What if i have 10 times writeChan in transformation, and after those 10 writeChan's i do a readChan in the OpenGL thread.
20:54:55 <fuchsto> mm_freak: How many signals would it read? 1 or 10? (because i need it to read 10)
20:55:05 <mm_freak> only one
20:55:13 <mm_freak> that's why you do it repeatedly
20:55:24 <fuchsto> like how?
20:56:14 <mm_freak> well, first of all i'd use TChan
20:56:17 <fuchsto> i would need to know how many new signals there are in the channel, right?
20:56:47 <fuchsto> i can't call readChan recursively, because it would block after reading the last signal
20:57:11 <EvanR> theres a 'would block' function if you really needed it
20:57:13 <EvanR> which i doubt
20:57:15 <mm_freak> not at all:  exhaustTChan c = tryReadTChan c >>= maybe (return []) (\x -> fmap (x:) (exhaustTChan c))
20:57:18 <mm_freak> something like that
20:57:30 <mm_freak> exhaustTChan :: TChan a -> STM [a]
20:58:12 <fuchsto> mm_freak: Ah, another issue: I need the full buffer content
20:58:38 <mm_freak> what do you mean?  all past signals?
20:58:46 <fuchsto> mm_freak: So, if i have a buffer size of 50, i need all 50 signals. Because the rendering is possibly trying to 'look back in time'
20:58:49 <EvanR> if youre processing samples in chunks then use Chan Chunk instead
20:58:56 <mm_freak> oh, i see
20:59:00 <EvanR> only push 50 at a time
20:59:04 <EvanR> and read 50
20:59:10 <EvanR> Chan 50Things
20:59:11 <fuchsto> EvanR: Latency!!!
20:59:17 <EvanR> >_>
20:59:28 <fuchsto> EvanR: I would have to wait for 50 signals
20:59:29 <EvanR> then make it 1Things
20:59:32 <mm_freak> fuchsto: in that case a buffer is probably actually what you want
20:59:39 <mm_freak> fuchsto: however, i wouldn't use []
20:59:58 <fuchsto> mm_freak: I remember that i used Chan in my first solution, and then switched to a buffer because i need to look back in time
21:00:05 <EvanR> im confused how you need 50 things but cant wait for them
21:00:05 <fuchsto> mm_freak: For IIR filters and the like
21:00:34 <mm_freak> in fact i would go back to an MVar and push the signals through a final buffering automaton that produces the last 50 values
21:00:40 <mm_freak> netwire has a predefined wire for that
21:00:51 <fuchsto> EvanR: I only can afford to wait for one signal (minimum latency), but i use the last 50 for some feature extraction
21:00:55 <EvanR> ... but latency
21:01:04 <EvanR> oh
21:01:15 <fuchsto> EvanR: Assuming my transformation yields signals with 30 Hz
21:01:35 <EvanR> yeah so you want a queue
21:01:45 <EvanR> or mm_freak's wires
21:01:47 <fuchsto> EvanR: Exactly!
21:01:57 <fuchsto> EvanR: My buffer is used as a queue
21:02:11 <mm_freak> for the actual buffer i'd probably use a store comonad
21:02:16 <fuchsto> EvanR: New signals are pushed at the front, old signals are dropped from the back
21:02:18 <mm_freak> like a vector with an index
21:02:25 <mm_freak> for the transmission i'd use MVar
21:02:54 <fuchsto> mm_freak: You can just have a look at the code, if you want to, it's not like it's a secret or i was ashamed of my newbie coding
21:03:04 <EvanR> reminds me of ring buffers...
21:03:11 <mm_freak> EvanR: it is one
21:03:22 <mm_freak> fuchsto: before you do that, let me write something up
21:03:22 <fuchsto> EvanR: ... what mm_freak said
21:03:29 <EvanR> i know
21:03:34 <EvanR> but the ones from C ;)
21:05:11 <mm_freak> you have the ones from C in haskell =)
21:05:25 <EvanR> in Vector? or
21:05:28 <mm_freak> yeah
21:05:42 <EvanR> i should check that out
21:06:02 <lpsmith> Can you really {-# UNPACK #-} MVars?
21:06:15 <gongyiliao> hi, I have a rookie question: I have an n by m matrix, I want to get the maximum value of each row, what's the most concise way to do it ?
21:06:16 * hackagebot aeson-smart 0.1.0.0 - Smart derivation of Aeson instances (SamAnklesaria)
21:06:16 <mm_freak> fuchsto: to summarize you have sampling that produces individual samples, you have transformation that takes individual samples and produces a ring buffer of the last 50 transformed samples, and finally you have rendering using that ring buffer…  correct?
21:06:35 <fuchsto> EvanR: The buffer is pure, so i'm fine with it
21:06:35 <fuchsto> EvanR: It's just a plain combination of take and drop
21:06:38 <fuchsto> mm_freak: Sounds right, yes
21:06:39 <EvanR> gongyiliao: matrix?
21:06:39 <lpsmith> I just realized I'm doing it somewhere, that GHC is not warning me it can't unpack it,  but I don't think they are really unpackable.
21:06:51 <gongyiliao> EvanR: yes, a matrix
21:06:57 <mm_freak> gongyiliao: map maximum
21:07:01 <fuchsto> mm_freak: Sampling frequency is, say, 192.000 Hz
21:07:10 <fuchsto> mm_freak: FFT window size is e.g. 9000
21:07:26 <EvanR> gongyiliao: for [[N]] map maximum
21:07:34 <fuchsto> mm_freak: So transformation frequency is 192.000 / 9.000 Hz. You see what i mean.
21:07:39 <mm_freak> lpsmith: they are primitive, so they might actually be
21:07:47 <gongyiliao> EvanR: got it, thanks
21:07:48 <lpsmith> Hmm, tibbe is unpacking some MVars in the IO manager
21:07:52 <lpsmith> So they must really be unpackable
21:08:06 <mm_freak> fuchsto: so the sampler pushes constant size bulks of samples?
21:08:07 * lpsmith scurries off to unpack some more MVars
21:08:53 <fuchsto> mm_freak: quasi-constant. It's soft-realtime, so you can't rely on the frequencies, but it's pushing one new signal per transformation loop iteration
21:08:55 <EvanR> mm_freak: at a very regular time interval im sure ;)
21:08:58 <lpsmith> Though,  how does GHC implement an unpacked MVar, given that multiple structures can reference the same MVar?
21:09:13 <lpsmith> I mean, you can't really unpack the same MVar into multiple structures, for example
21:09:14 <EvanR> 44100
21:09:27 <fuchsto> EvanR: 44100 ?
21:09:33 <EvanR> 48000
21:09:34 <EvanR> ?
21:09:34 <lpsmith> though I suppose nothing is stopping one structure of having a pointer to an unpacked MVar in another structure...
21:09:49 <fuchsto> EvanR: What do you mean by 44100 ?
21:09:58 <EvanR> the sample rate
21:10:07 <fuchsto> EvanR: It's about 192.000
21:10:10 <fuchsto> Hz
21:10:17 <EvanR> 192000
21:10:28 <fuchsto> EvanR: I need a high sampling rate so i get a high rate of FFT samples
21:10:57 <fuchsto> EvanR: I want my FFT window size to be as big as possible, and the update interval as short as possible -> high sampling frequency
21:11:46 <fuchsto> EvanR: I'm just using the maximum frequency PulseAudio allows on my platform
21:12:46 <fuchsto> mm_freak: You mentioned an idea on how to optimize my buffering?
21:12:53 <fuchsto> mm_freak: (Apart from using vector)
21:16:38 <mm_freak> fuchsto: the store comonad?
21:17:18 <fuchsto> mm_freak: Well, so you think i need a buffer in any case?
21:17:35 <mm_freak> fuchsto: yeah, probably
21:17:48 <fuchsto> mm_freak: I'm just not that experience with the Haskell way of things. It looked like a good idea from a C++ point of view
21:18:27 <fuchsto> mm_freak: What would the store comonad do? I would just use a vector along with a read/write index
21:18:40 <mm_freak> yes, that's the store comonad =)
21:18:42 <gongyiliao> another rookie question, in R, we can obtain a 10 x 10 matrix, whose elements are random samples from a standard normal distribution, with ' matrix(rnorm(100), ncol=10) '
21:18:55 <gongyiliao> how can I do the same thing in Haskell ?
21:19:14 <fuchsto> mm_freak: something like the state monad. Push a value and an index, get the new vector and index. Like   :: (Vector,Int) -> (Vector,Int)
21:19:20 <mm_freak> gongyiliao: did you look at hmatrix?
21:19:26 <mm_freak> @hackage hmatrix
21:19:26 <lambdabot> http://hackage.haskell.org/package/hmatrix
21:19:39 <fuchsto> mm_freak: I'll just google the store comonad, i think :)
21:20:04 <mm_freak> fuchsto: newtype VectorStore a = VS Int (Vector a)
21:20:06 <gongyiliao> fuchsto:  let me check this out, thanks
21:20:34 <mm_freak> fuchsto: that type has a nice Comonad instance
21:20:37 <gongyiliao> mm_freak: thanks
21:23:02 <mm_freak> fuchsto: a store might actually also be useful for the transformation itself
21:23:26 <mm_freak> it allows to update a map locally by looking at it globally
21:23:46 <mm_freak> that makes it incredibly easy to implement, say, a blurring filter
21:25:58 <smithw> Hi, is there a way to do this http://hpaste.org/72373 without ArrowChoice/recursion?
21:28:25 <fuchsto> mm_freak: The transformation operates on a single signal only. So, i read |fftWindowSize| samples from the sampling thread, use them to get an FFT, and run some diagnostics on the FFT
21:28:47 <fuchsto> mm_freak: So in my context, a "signal" is a single FFT response
21:29:16 <fuchsto> mm_freak: So i don't think i will have to look at them globally
21:29:36 <fuchsto> mm_freak: Ah, no, of course i do. For feature extraction and some filters.
21:29:50 <mm_freak> smithw: no
21:30:29 <fuchsto> mm_freak: Ah, by "blurring filter" you mean an IIR?
21:30:39 <fuchsto> mm_freak: Yes, yes, absolutely
21:30:52 <mm_freak> smithw: a more sensible way is to define an arrow-specific mapA function
21:31:04 <mm_freak> the generic mapA function will be inefficient
21:33:17 <smithw> mm_freak, I'm experiment with arrows and I'm trying to make some "Arrow Transformers". But then I realized I can't compose a List transformer arrow (newtype LAT a b c =  LA (a b [c])) without an "arrow mapper"...
21:33:32 <mm_freak> fuchsto: about latency:  sending values through an MVar/Chan/Other is an O(1) operation and involves no actual transfer…  it doesn't even involve evaluation
21:33:34 <EvanR> getting lost in comonads, everything else melts away
21:34:04 <smithw> *experimenting
21:34:30 <mm_freak> smithw: start with another arrow…  try ArrowReader
21:34:40 <mm_freak> the function-like arrows are easier to get started with
21:36:08 <fuchsto> mm_freak: I could use a Chan for sending new signals from transformation to rendering and let the render module do the buffering, if they need it
21:36:22 <fuchsto> mm_freak: This way the render modules can decide how many old signals to store
21:36:58 <fuchsto> mm_freak: It just doesn't work for transformation ... some feature extractions have to look way back in time
21:37:15 <smithw> mm_freak, I actually started with an ArrowState transformer it worked out fine. I might be wrong, but I guess a state category (arrow, monad) is a combination of a writer and a reader, right?
21:37:33 <fuchsto> mm_freak: And maintaining two buffers (one in transformation, one in rendering) possibly containing the same data would be kinda uncool.
21:37:38 <mm_freak> fuchsto: all i'm saying is that sending is a lightweight operation and you might find that the values you pass along an MVar/Chan could get evaluated much later and in another thread
21:38:15 <fuchsto> mm_freak: Ah, i see
21:38:24 <fuchsto> mm_freak: I don't know if i want that
21:38:54 <mm_freak> smithw: not really…  a combination of Reader and Writer doesn't allow stateful computations
21:39:03 <fuchsto> "much later" is okay if i need the value much later and an interleaved change on the value is non-critical.
21:39:32 <quintessence> smithw: not really--the State operations may have the signatures of Reader + Writer, but get and put interact in ways you wouldn't expect of ask and tell
21:39:44 <fuchsto> mm_freak: Also, here is the implementation of the first two threads in question: https://github.com/fuchsto/drool/blob/master/src/Drool/Main.hs
21:40:06 <EvanR> smithw: basically a writer doesnt let you get what you wrote back later
21:40:09 <fuchsto> mm_freak: Yesyes, it's ugly and creepy. Hey, it's experimental and my first real world haskell thingie
21:40:30 <fuchsto> mm_freak: And it has not seen a refactoring session yet
21:41:43 <smithw> mm_freak, quintessence, EvanR, you are all right. I forgot about how writer worked, and I only used a reader monad "in the wild" once, so I made a bad assumption.
21:43:09 <mm_freak> you use the reader monad quite a lot, just not the convoluted Reader monad from transformers =)
21:43:10 <edwardk> hrmm, i think im going to add isomorphism families to lens
21:43:19 <edwardk> i wind up needing them a lot in here
21:43:26 <dobblego> yes, good idea
21:43:27 <mm_freak> smithw: (e ->) is also a reader monad =)
21:43:37 <edwardk> data Iso a b c d = Iso (a -> c) (d -> b)
21:43:57 <edwardk> via :: Iso a b c d -> Lens a b c d; via (Iso ac db) cfd a = db <$> cfd (ac a)
21:44:04 <dobblego> yep, then :: Iso a b c d -> LensFamily a b c d
21:44:05 <edwardk> from :: Iso a b c d -> Lens d c b a; from (Iso ac db) bfa d = ac <$> bfa (db d)
21:44:09 <dobblego> zing!
21:44:24 <edwardk> so you can have
21:44:44 <dfeuer> Is there an accepted best way to implement randomized algorithms in Haskell?
21:44:46 <dobblego> wouldn't it be data IsoFamily a b c d
21:45:02 <latro`a> system.random, dfeuer? I probably misunderstand the question
21:45:04 <dobblego> then type Iso a b = IsoFamily a b a b
21:45:07 <EvanR> all ways are kindly accepted
21:45:08 <EvanR> haha
21:45:19 <edwardk> via posix^.to (diffUTCTime somedate)
21:45:20 <edwardk> nah
21:45:24 <edwardk> i swapped the vocabulary
21:45:28 <dobblego> oh ok
21:45:28 <mm_freak> dfeuer: lots of accepted best ways =)
21:45:37 <edwardk> I use Lens a b c d
21:45:38 <edwardk> and
21:45:40 <edwardk> Simple Lens a b
21:45:46 <edwardk> type Simple f a b = f a a b b
21:45:49 <EvanR> dfeuer: roll dice and replace all numbers in your algorithm
21:45:54 <EvanR> ctrl S
21:46:00 <edwardk> Simple Lens, Simple Getter, Simple Setter, Simple Traversal, Simple Fold
21:46:06 <edwardk> and now Simple Iso
21:46:24 <edwardk> everything in Control.Lens is assumed to be a family unless claimed otherwise
21:46:47 <edwardk> it makes a big difference in presentation
21:46:47 <edwardk> and it lets me derive all these things from the laws for functor and traversable almost directly
21:47:06 <edwardk> with the monomorphic version the default you can't motivate them from the functor laws
21:47:31 <dfeuer> latro`a: I'm speaking specifically about, say, a randomized median-finding algorithm, where you want a function (Ord a)=>Array Int a->a
21:47:40 <mm_freak> (as always) there are now two lens family libraries:  lens and lens-family…  which one is the one to use?
21:47:46 <edwardk> lens
21:47:59 <edwardk> and lens and lens-family are compatible if you can't choose ;)
21:47:59 <mm_freak> alright, thanks =)
21:48:07 <mm_freak> yeah, true
21:48:11 <edwardk> you can use lenses from one in the other
21:48:25 <dfeuer> If the median function pulls random numbers from thin air, then it will clearly be "unsafe" (non-deterministic result) in general, but as specialized to built-in numerical types it's perfectly safe...
21:48:27 <edwardk> the only thing that changes is vocabulary, and you get lots of combinators out of lens
21:48:37 <smithw> mm_freak, indeed :p
21:48:48 <mm_freak> that's the indication of a very beautiful concept…  if two unrelated libraries are compatible =)
21:49:23 <edwardk> yeah. you can make lenses in this style without actually importing _either_ library
21:49:24 <latro`a> I'm not seeing the problem dfeuer
21:49:39 <edwardk> sndLens f (a,b) = (,) a <$> f b
21:49:43 <dfeuer> latro`a: how do you pull the random numbers out of thin air? That's the question....
21:49:46 <edwardk> notice the lack of special types?
21:49:47 <latro`a> oh
21:49:51 <latro`a> you can pull out the first one
21:49:53 <latro`a> from thin air
21:49:57 <latro`a> and do the rest deterministically
21:50:01 <mm_freak> edwardk: yeah, i understand the basics of lens families
21:50:05 <edwardk> kk
21:50:05 <latro`a> pulling the first one can be done with IO using System.Random
21:50:21 <latro`a> strictly speaking you could do the whole thing non-deterministically but that's kinda kludgy
21:50:39 <EvanR> :t (<<=)
21:50:40 <lambdabot> Not in scope: `<<='
21:50:40 <dfeuer> latro`a: I don't want to change the type of the median function. I want to use unsafe IO so as to be able to hide the non-purely-functional implementation....
21:50:51 <dfeuer> [unsafe IO or similar]
21:50:52 <latro`a> that...is usually a bad idea
21:50:56 <EvanR> :t extract
21:50:57 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
21:51:04 <EvanR> :t extend
21:51:05 <lambdabot> Not in scope: `extend'
21:51:08 <EvanR> frak no comonads in lambdabot :(
21:52:08 <edwardk> kind of wish i'd held back 'to' for the forward operation of Iso
21:52:16 <edwardk> 'to posix' and 'from posix' are kinda nice
21:52:33 <dfeuer> latro`a: in general, the source of random numbers is not something you want to explicitly pass a randomized algorithm whose /results/ are deterministic. You may want to pass it through some sort of dynamic scope, I suppose, but I'm not seeing the point there...
21:53:17 <Cale> If the result is deterministic, then are you sure you really need a source of random numbers? Won't a source of specific nicely-distributed numbers do?
21:53:18 <dfeuer> latro`a: to put this better, if you're writing a program to use a median function, you really don't want to have to change your program to switch between a deterministic and a non-deterministic median function for performance testing.....
21:53:18 <startling> so I've got two Maybe x. if the first is a Just, I want to return it; if it's Nothing, I want to return the other. is there a construct for that?
21:53:46 <latro`a> dfeuer, then you're consigned to unsafePerformIO, which for this one case is probably not terrible, but is difficult to reason about
21:53:50 <Cale> e.g. you could use a fixed random number generator state as the initial state?
21:53:53 <latro`a> but yes
21:53:55 <latro`a> you could do that
21:54:08 <latro`a> using, say, mkStdGen 0
21:54:08 <latro`a> or suc
21:54:09 <latro`a> h
21:54:31 <Cale> > randomRs (0,100) (mkStdGen 42)
21:54:32 <lambdabot>   [25,87,93,25,28,30,4,74,51,36,62,79,55,81,36,93,83,39,67,7,87,59,36,55,54,3...
21:54:41 <Cale> > randomRs (0,100) (mkStdGen 42)
21:54:42 <lambdabot>   [25,87,93,25,28,30,4,74,51,36,62,79,55,81,36,93,83,39,67,7,87,59,36,55,54,3...
21:54:52 <dfeuer> Cale: No, they won't do. Such an approach will break the usual guarantee a randomized algorithm gives, which is to say that there is a specific bound for the expected execution time for worst case input.
21:55:11 <edwardk> hrmm: traverse._2.by date.to posix  -- if i steal to for 'Iso' in 1.2 i can give 'by' to Getter
21:55:16 <latro`a> fair enough
21:55:17 <latro`a> well
21:55:27 <startling> this feels like a reverse of >>=
21:55:47 <mm_freak> startling: "this"?
21:55:50 <latro`a> I can't really recommend it, but you can unsafePerformIO getStdGen and then run that through Rand
21:55:52 <dfeuer> If a hostile force (think denial of service) constructs their input based on the list of numbers determined from your source code, they can make your algorithm take a long time.
21:55:57 <startling> mm_freak: 23:52 < startling> so I've got two Maybe x. if the first is a Just, I want to return it; if it's Nothing, I want to return the other. is there a construct for that?
21:56:09 <mm_freak> startling: yes
21:56:12 <mm_freak> startling: <|>
21:56:19 <dfeuer> latro`a: how do you actually write that call to unsafePerformIO?
21:56:24 <mm_freak> > Just 3 <|> undefined
21:56:24 <latro`a> as I just did
21:56:25 <lambdabot>   Just 3
21:56:30 <latro`a> afaik, anyway
21:56:33 <mm_freak> > Nothing <|> Just 4
21:56:34 <lambdabot>   Just 4
21:56:36 <startling> mm_freak: ohh nice. was just checking Control.Applicative
21:56:43 <dfeuer> So as to make sure that a new StdGen is cerated for each call to median?
21:56:48 <latro`a> but I am not well-acquainted with the semantics of lazy IO
21:57:09 <latro`a> if you need a new one you may need newStdGen instead
21:57:14 <mm_freak> :t randomsIO
21:57:15 <lambdabot> Not in scope: `randomsIO'
21:57:21 <mm_freak> :t System.Random.randomsIO
21:57:22 <lambdabot> Not in scope: `System.Random.randomsIO'
21:57:35 <latro`a> mm_freak, if he's gonna do the IO lazily, he should probably not do it a whole bunch of times
21:57:42 <Cale> dfeuer: Well, you can write unsafePerformIO newStdGen, but as for whether the compiler will lift your binding to the top level and evaluate it only once per program execution, that's another thing.
21:57:49 <latro`a> exactly
21:58:17 <Cale> dfeuer: You're doing something unsafe which explicitly breaks the compiler's assumptions. Optimisations can affect the behaviour of your code now
21:58:18 <dfeuer> Cale: that's what I was wondering about, mostly. I don't actually know what I need new each time,
21:58:21 <Cale> Have fun :)
21:58:37 <dfeuer> but I definitely need to make sure two calls to median won't (except by chance) use the same list of randoms.
21:59:21 <latro`a> I'm not certain you even *can* make that guarantee without having an IO signature on everything
21:59:36 <latro`a> eh, not "everything", but you know what I meant probably
21:59:41 <mm_freak> doesn't have to be an IO signature
21:59:45 <dfeuer> Cale: the good thing is that when such an algorithm is applied appropriately, with appropriate types, the results will be the same regardless of optimizations--only performance can break....
21:59:54 <Cale> Normally you only want to use unsafePerformIO if a) you're certain that any two executions of the IO action produce the same result and b) any effects carried out by the IO action are ignorable.
22:00:06 <latro`a> both of those *do* apply here, FWIW
22:00:10 <latro`a> except
22:00:11 <dfeuer> Yes.
22:00:17 <latro`a> if you need to get newStdGen to happen more than once
22:00:19 <mm_freak> median :: (Monad m) => (forall a. (Random a) -> m a) -> MedianInputData -> m Median
22:00:22 <latro`a> which I think you do
22:00:26 <latro`a> in which case b) fails
22:00:32 <EvanR> so the comonad for (,) e is basically like Reader e
22:00:50 <mm_freak> EvanR: the two are pretty unrelated
22:01:01 <mm_freak> EvanR: see how Coreader is not a function at all
22:01:08 <dfeuer> Not for Ord types in general (unless the order really is total) but for at least the integral types. I'm not sure about floating point....
22:01:11 <Cale> How does this algorithm work?
22:01:25 <EvanR> no looking at Coreader
22:01:32 <EvanR> im confused by your response
22:01:46 <mm_freak> dfeuer, Cale, latro`a:  see above…  that's how i'd do it
22:02:01 <mm_freak> m can be anything from State StdGen to IO
22:02:02 * dfeuer is working on understanding that type.
22:02:12 <EvanR> playing with (e, , i see i can see e in all my extends but cant change it
22:02:18 <mm_freak> dfeuer: the passed function must be polymorphic on its 'a' type
22:02:21 <latro`a> erm
22:02:25 <latro`a> you have a typo
22:02:30 <latro`a> Random a => m a
22:02:30 <latro`a> not ->
22:02:49 <latro`a> that said, basically all you're allowed to do with the a's is use the Random interface
22:02:50 <mm_freak> EvanR: that's Coreader
22:02:55 <mm_freak> latro`a: indeed, sorry
22:03:12 <mm_freak> latro`a: if "you" are the caller, yes
22:03:15 <latro`a> true
22:03:20 <EvanR> EvanR: ok... well what im saying is they have the same function obviously they have different implementations
22:03:24 <mm_freak> that's the point of the 'forall'
22:03:27 <EvanR> mm_freak: *
22:03:29 <dfeuer> mm_freak: I'm not even seeing Ord in that type, so I don't see how it can do anything.
22:03:40 <EvanR> i was trying to see how that instance could be used
22:03:41 <latro`a> you can add a constraint on top of it
22:03:50 <mm_freak> dfeuer: 'median' chooses 'a'
22:03:58 <edwardk> i wonder if i can actually make Iso just compose directly with a Lens by putting a constraint on the type of the -> between (c -> f d) and (a -> f b) instead of using the -> direclty
22:04:20 <mm_freak> dfeuer: twoRandoms :: (Monad m) => (forall a. (Random a) => m a) -> m (Int, Integer)
22:04:39 <mm_freak> twoRandoms getRandom = liftM2 (,) getRandom getRandom
22:04:54 <edwardk> type Iso a b c d = forall e f. (Dir e, Functor f) => e (c -> f d) (a -> f b)
22:05:17 <latro`a> the important part of what mm_freak just said is that the values you're getting out have different types
22:05:22 <edwardk> or something like that
22:05:26 <EvanR> :t runIdentity
22:05:28 <lambdabot> forall a. Identity a -> a
22:05:33 <latro`a> which isn't possible if the argument isn't polymorphic in a
22:05:42 <mm_freak> dfeuer: the caller of 'twoRandoms' needs to make a promise:  the passed function can handle any type 'a' that is an instance of Random
22:05:50 <edwardk> with the idea being to instantiate e to (->) to get one way, and somehow get the opposite way through other means
22:05:56 <mm_freak> so that the callee (twoRandoms) can choose the type
22:05:58 <latro`a> if the forall is outside, then you might have an m Int or an m Integer but you definitely have one or the other
22:06:24 <mm_freak> hence "forall" (a function that works "for all" types)
22:08:05 <dfeuer> Yeah, I'm in over my head a bit :/
22:08:25 <dfeuer> Also not sure what the Median type is that you referred to in median :: (Monad m) => (forall a. (Random a) -> m a) -> MedianInputData -> m Median
22:08:40 <latro`a> it's a representation only
22:09:10 <latro`a> :t Control.Monad.Random.getRandom
22:09:11 <lambdabot> forall (m :: * -> *) a. (MonadRandom m, Random a) => m a
22:09:11 <dfeuer> I'm still in over my head. Dang.
22:09:19 <latro`a> does that type help, dfeuer ?
22:09:35 <mm_freak> dfeuer: twoTimes :: (forall a. a -> a -> a) -> (Integer, String)
22:09:46 <mm_freak> twoTimes (+) = (3 + 3, "blah" + "blubb")
22:10:00 <mm_freak> twoTimes is a bad name…  historical reasons =)
22:10:02 <Cale> dfeuer: MedianInputData is just whatever stuff your median algorithm needs otherwise, presumably just something like (Ord b) => [b], but you might prefer some other sequence type or maybe your algorithm only works for integer values.
22:10:19 <Cale> dfeuer: and Median is just whatever the type of the result is
22:11:21 <latro`a> using (+) as the function in question is also pretty confusing, mm
22:11:23 <latro`a> ...
22:11:24 <latro`a> mm_freak,
22:11:26 <xencss> Big channel. ^^
22:11:34 <dfeuer> <mm_freak> dfeuer: twoTimes :: (forall a. a -> a -> a) -> (Integer, String)
22:11:35 <mm_freak> latro`a: probably =)
22:11:50 <Cale> I think you'll be unsatisfied by this, because the monadic context is still there. But to be honest, I'm not really sure what to prefer here. It's sort of an awkward case to have a deterministic algorithm which you'd like to silently have nondeterministic input to. I would probably just have it take the randomness as a parameter myself.
22:11:51 <dfeuer> I'm not understanding the existential type
22:12:09 <Cale> That's not existential, it's higher-rank
22:12:13 <mm_freak> i agree with Cale
22:12:19 <dfeuer> OK. Explain that then?
22:12:21 <latro`a> agreed with cale again, yeah
22:12:39 <latro`a> this isn't awkward in an imperative language, but it is awkward in a functional one
22:12:49 <Cale> dfeuer: It's a function which *requires* a polymorphic function as a parameter
22:12:53 <mm_freak> it isn't awkward in a functional language either
22:13:02 <latro`a> it's awkward to have them both have the same type
22:13:02 <Cale> For example, let's say you want to write the following:
22:13:05 <mm_freak> it's conceptionally awkward =)
22:13:07 <latro`a> which is what he wants
22:13:14 <Cale> foo rev = (rev [1,2,3], rev "Hello")
22:13:18 <mm_freak> ("conceptionally" as in "conception")
22:13:18 <dfeuer> mm_freak: how do you deal with the fact that some median algorithms use randomness, some don't, and you may not know which you want until the code using it is already written and you can profile the performance?
22:13:39 <dfeuer> Cale: but (+) doesn't have type a->a->a.
22:13:49 <latro`a> it does in his example; it was a bad name
22:13:56 <latro`a> it should've been some arbitrary name like foo
22:14:13 <dfeuer> Oh.
22:14:14 <latro`a> twoTimes foo = (foo 3 3,foo "bar" "baz")
22:14:15 <Cale> foo rev = (rev [1,2,3], rev "Hello") -- it should be possible to apply this foo to reverse
22:14:17 <dfeuer> Let me look at that again.
22:14:33 <latro`a> now, foo must necessarily be a rather strange function
22:14:38 <Cale> however, in the HM type system, or the Haskell 98 type system
22:14:39 <latro`a> because it has an enormous domain
22:14:42 <Cale> foo doesn't exist
22:14:54 <johnw> Finally got GHC 7.4.2 to build on OpenIndiana, btw
22:14:55 <Cale> > let foo rev = (rev [1,2,3], rev "Hello")
22:14:57 <lambdabot>   not an expression: `let foo rev = (rev [1,2,3], rev "Hello")'
22:14:57 <Cale> > let foo rev = (rev [1,2,3], rev "Hello") in foo
22:14:59 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
22:14:59 <lambdabot>    arising from the literal `1...
22:15:07 <latro`a> const would work, and flip const would work
22:15:12 <mm_freak> dfeuer: well, i'm usually in some kind of application monad, so the issue doesn't really arise
22:15:12 <latro`a> I'm not sure anything else would work
22:15:13 <Cale> It's saying "I don't know how to treat a character as a number"
22:16:16 <dfeuer> I'm still not getting how a median with type
22:16:17 <dfeuer> median :: (Monad m) => (forall a. (Random a) -> m a) -> MedianInputData -> m Median
22:16:18 * hackagebot yesod-test-json 0.1.0.0 - Utility functions for testing JSON web services written in Yesod (SamAnklesaria)
22:16:30 <dfeuer> could actually do anything. Where does the Ord constraint come in.
22:16:32 <dfeuer> ?
22:16:36 <Cale> But we can give this foo a type
22:16:38 <latro`a> it's inside MedianInputData
22:16:51 <latro`a> we really should be writing:
22:16:55 <Cale> foo :: (forall a. [a] -> [a]) -> ([Integer], [Char])
22:16:59 <latro`a> median :: (Monad m) => (forall a. (Random a) => m a) -> MedianInputData -> m Median
22:17:00 <latro`a> btw
22:17:03 <mm_freak> dfeuer: MedianInputData is just a placeholder
22:17:15 <dfeuer> Oh, now I see, somewhat.
22:17:25 <dfeuer> Duh.
22:17:29 <mm_freak> dfeuer: put whatever you want there =)
22:17:42 <Cale> Let's go simpler
22:18:01 <Cale> median :: (Ord a) => StdGen -> [a] -> a
22:18:41 <dfeuer> Yeah, it's been several years since I attempted to understand monads. The attempt was only partially successful then. It's possible that I would understand better now, but I haven't made the attempt this go-round yet.
22:18:58 <dfeuer> [I didn't program at all for a while... trying to get back into it]
22:19:17 <coppro> dfeuer: I suggest looking at Maybe
22:19:24 <coppro> it's easiest to understand in my opinion
22:19:59 <dfeuer> My recollection is that last I tried, I understood IO and ST pretty well, but couldn't make the conceptual connection to Maybe or [].
22:20:17 <coppro> in particular, think about what Maybe does when you instantiate the various Monad functions with it
22:20:25 <Cale> In that case, "running" a list just means picking one of its elements
22:20:27 <dfeuer> And mine eyes glazed over once I started seeing types parametrized over monad types.
22:20:37 <Cale> and Maybe is just like lists of length at most one
22:20:53 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
22:20:54 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
22:21:05 <Cale> It's just like list comprehensions
22:21:25 <johnw> so, when I try to use the github version of scion, pretty much everything fails, for example: Error in process filter: (error Unexpected reply: -1 (:error "ParseError: Unknown server command: thing-at-point"))
22:21:34 <Cale> But we have the advantage which is the purpose of defining anything as a monad, which is that we get all the stuff in Control.Monad (and other libraries) for free
22:21:43 <Cale> > replicateM 3 [0,1]
22:21:45 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
22:21:46 <latro`a> eh, not *anything*
22:22:10 <latro`a> the types and monad laws are in a decent niche where they're restrictive enough to be meaningful but flexible enough to be fairly generic
22:22:34 <Cale> > sequence [[1,2,3], [4,5], [6,7,8]]
22:22:35 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
22:23:12 <dfeuer> <Cale> In that case, "running" a list just means picking one of its elements
22:23:12 <mm_freak> dfeuer: you have some kind of computation type, let's call it 'Comp', where 'Comp a' is a computation that results in an 'a'…  the Comp type is opaque…  now you have a function of type 'Y -> Comp Z'
22:23:25 <Cale> > let dict = [(0,1),(1,2),(2,3)] in do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; return z
22:23:27 <lambdabot>   Just 3
22:23:36 <Cale> > let dict = [(0,1),(1,2),(2,3)] in do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; w <- lookup z dict; return w
22:23:38 <lambdabot>   Nothing
22:24:02 <Cale> (I suspect looking at my examples will be more enlightening than reading that description alone :)
22:24:07 <mm_freak> dfeuer: that function is a computation that depends on some value of type Y, but that value comes from another computation…  how do you connect them?  you need a combinator of type:  Comp Y -> (Y -> Comp Z) -> Comp Z
22:24:19 <mm_freak> because Comp is opaque
22:24:32 <mm_freak> that's what (>>=) does
22:24:33 <dfeuer> Whoa whoa, I'm falling behind this conversation. Tooooo fast. Give me a moment to catch up, please!
22:24:43 <mm_freak> i'll stop =)
22:24:44 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; if x^2 + y^2 == z^2 then return (x,y,z) else []
22:24:45 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
22:25:10 <dfeuer> mm_freak: I don't want you to stop. Just don't expect me to respond till I've finished reading some.
22:25:35 <Cale> Yeah, this channel is probably in too-many-cooks mode :)
22:25:45 <Cale> I should go to bed anyway
22:25:50 <mm_freak> dfeuer: just translate it to Maybe:  you have an Int -> Maybe Double
22:25:59 <mm_freak> but the Int you want to pass it comes from another Maybe Int
22:26:09 <mm_freak> how do you connect the two?
22:26:20 <mm_freak> Maybe Int -> (Int -> Maybe Double) -> Maybe Double
22:26:30 <EvanR> ... and Monoid m => (->) m ... is basially a writer lol
22:26:33 <latro`a> I'll throw in one little thing: making the connection between different monads requires you to figure out what the a -> m b are for your monad
22:26:36 <mm_freak> you can do the same with IO, STM, ST s, etc.
22:26:43 <EvanR> the opposite of the implementations for Reader an Writer in Monad
22:27:12 <mm_freak> dfeuer: that's the essence of Monad as a concept
22:27:24 <latro`a> with Maybe, a -> Maybe b are functions that may or may not return a value; with [], a -> [b] are functions that may return 0 or more values; a -> IO b are functions that return some instructions on how to get a b
22:27:25 <latro`a> etc.
22:27:27 <mm_freak> composing opaque computations
22:28:16 <EvanR> something spooky... (foo,) and bar->  with a monoid thrown in are some sort of magic category theoretical structures?
22:29:08 <EvanR> its late maybe im going insane. probably not the best reading before going to bed
22:29:32 <johnw> geekosaur: Does C-c C-t work for you in Scion?
22:30:05 <mm_freak> EvanR: did you implement 'tell' for (l ->) as a writer?
22:30:41 <EvanR> <> ?
22:30:59 <dfeuer> mm_freak: I think the part of the list monad that gets weird in my head is that although each stage in the computation is handed one value from the last stage,
22:31:15 <dfeuer> in fact all the possible combinations of values are computed.
22:31:19 <latro`a> it isn't
22:31:32 <mm_freak> dfeuer: your assumption is wrong
22:31:44 <mm_freak> all values from the last stage are handed
22:31:56 <mm_freak> for lists (>>=) = flip concatMap
22:31:59 <dfeuer> I probably phrased that wrong.
22:32:02 <latro`a> I may get murdered for this
22:32:04 <latro`a> but
22:32:07 <latro`a> in the context of []
22:32:18 <latro`a> "x <- xs" is very much like "for x in xs"
22:32:22 <latro`a> because of the definition of >>=
22:32:30 <latro`a> as concatMap
22:32:50 <dfeuer> But that doesn't at all explain the relationship between lists and IO.
22:33:02 <dfeuer> (or Maybe, or or or)
22:33:11 <latro`a> bah, I wrote a little thing continuing my remark earlier
22:33:17 <latro`a> now I need to write it again, because it seems appropriate now
22:33:28 <mm_freak> there is no relationship between lists and IO, just between list composition and IO composition
22:33:54 <EvanR> lookinh at (->) m more
22:34:18 <EvanR> mm_freak: anymore ;) IO lists
22:34:22 <latro`a> once you've identified the meaning of (a -> m b), you have to figure out how to make an (m a) give an (a->m b) input
22:34:30 <mm_freak> dfeuer: again you have a function Int -> [Double]
22:34:31 <dfeuer> mm_freak: I understand that in broad principle, but what exactly it is about the composition that makes them similar is still eluding me a bit.
22:34:39 <mm_freak> but the Int argument comes from another list
22:35:01 <mm_freak> so you need a way to connect the source list to the destination function
22:35:11 <mm_freak> [Int] -> (Int -> [Double]) -> [Double]
22:35:22 <mm_freak> voila, (>>=) for lists
22:35:30 <mm_freak> which incidentally is just flip concatMap
22:35:33 <dfeuer> Also, unfortunately, I have to go to bed now, because I have to wake up early to go to the DMV to replace my missing driver's license....
22:35:35 <mm_freak> :t flip concatMap
22:35:36 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
22:35:39 <latro`a> feh
22:35:42 <latro`a> so much progress
22:35:43 <dfeuer> So I must say good night to all you helpful cooks.
22:36:04 <mm_freak> dfeuer: have fun =)
22:36:15 <mm_freak> dfeuer: anyway, just think simple
22:36:33 <mm_freak> the composition style is the common thing between [] and IO
22:36:56 <mm_freak> and Maybe and State s and Coroutine f m and …
22:37:28 <mm_freak> … of course Identity =)
22:37:42 <latro`a> ...
22:37:43 <latro`a> omega + 1
22:37:50 <latro`a> *twitch*
22:37:52 <dfeuer> And how you always take medians inside a monad appropriate for obtaining random numbers.
22:38:11 <dfeuer> omega+1 means what?
22:38:21 <latro`a> that was a math joke relating to the form of mm_freak's last statement
22:38:30 <latro`a> involving an ellipsis with a thing after it
22:38:40 <dfeuer> Oh, yes, now I understand. Ordinals.
22:38:42 <latro`a> yes
22:38:50 <mm_freak> ah lol
22:38:54 <mm_freak> now i understand it, too
22:39:19 <mm_freak> … i think ;)
22:39:48 <latro`a> omega + 1 is basically N U {infinity}
22:40:40 <latro`a> not sure in which sense Identity is bigger than every other monad, but
22:40:43 <latro`a> apparently it is?
22:41:01 <latro`a> or smaller, I guess, if you go in that order
22:41:26 <dfeuer> Speaking of things, I challenge y'all to write a non-comparison-based algorithm for sorting algebraic numbers analogous to a radix sort for integers. It should have sub-n*log n performance where n is the number of algebraic numbers to sort, but of course will depend on the maximum "size" (in some sense) of the numbers to be sorted.
22:42:03 <mauke> what's an algebraic number?
22:42:11 <latro`a> solution to some polynomial with rational coefficients
22:42:24 <dfeuer> [k could be something like the length of the written representation of the shortest polynomial with integer coefficients and with the number as a root)
22:42:38 <latro`a> so it includes rational combinations of radicals, along with a sprinkling of numbers that can't be represented with radicals either
22:42:56 <latro`a> it's presumably important that they're algebraic and not generic real because the algebraic numbers are countable
22:43:00 <mauke> so ... it's a finite list of rationals
22:43:06 <latro`a> not rationals
22:43:09 <latro`a> sqrt(2) is algebraic
22:43:12 <latro`a> pi is not
22:43:20 <Ralith> mauke didn't say they were rationals.
22:43:23 <dfeuer> The algebraic numbers are countable, and Wikipedia says they're actually order-isomorphic to the rationals, which I must admit surprised me.
22:43:26 <Ralith> he said they could be represented with a finite list of rationals.
22:43:43 <mauke> sqrt(2) is [-2, 0, 1]
22:43:45 <latro`a> ah nm
22:43:59 <dfeuer> Yes, or even a finite list of integers, actually.
22:44:12 <dfeuer> [because integer coefficients are sufficient]
22:44:37 <latro`a> indeed, multiply through by lcm $ map denominator rats
22:44:41 <latro`a> :p
22:45:24 <dfeuer> For n>4 (I think that's right), there are roots of nth-degree polynomials that are not expressible in radicals.
22:45:39 <latro`a> correct
22:45:57 <latro`a> n=4 basically doesn't count, though
22:46:03 <latro`a> have you *seen* the quartic formula?
22:46:05 <latro`a> it's a monstrosity
22:46:20 <dfeuer> So writing a sorting routine of any sort for these things is likely to be ... interesting. Writing a non-comparison-based sort is likely to be /quite/ a challenge.
22:46:53 <dfeuer> Yes, I have seen the quartic formula. Well, not all together, because it was written out as a nested structure over a few pages. And I didn't actually try very hard to understand the derivation.
22:47:06 <dfeuer> Yes, it is definitely a monstrosity.
22:48:09 <dfeuer> [also, TBH, I don't remember quite how long it was. But I do remember it wasn't all written out together, but as a "let a=somebigformula and let b=somebigformula and let c=somebigformula ..... in someotherbigformula"
22:48:10 <dfeuer> ]
22:48:57 <latro`a> the cubic formula is at least somewhat manageable
22:49:32 <dfeuer> Yeah. But if I ask  you to compare the third real root of some 7th-degree polynomial with the second real root of some 5th-degree polynomial,
22:49:37 <dfeuer> how exactly would you do that?
22:49:44 <dfeuer> And what if they were close to each other?
22:50:44 <dfeuer> GOOD NIGHT.
22:53:59 <edwardk> dobblego: around?
22:54:00 <edwardk> @hpaste
22:54:00 <lambdabot> Haskell pastebin: http://hpaste.org/
22:54:25 <hpaste> “Edward Kmett” pasted “looking back through a lens” at http://hpaste.org/72374
22:54:40 <edwardk> that lets me make isomorphisms that compose with other lenses
22:54:56 <edwardk> you can just use the isomorphism directly as a lens and compose them with . or id
22:55:30 <edwardk> the caveat is that if you want to compose an isomorphism and have it _remain_ an isomorphism you have to use the Control.Category ((.),id)
22:55:46 <edwardk> but if you just want to compose it as a lens then (.) and id from Prelude works fine
22:56:39 <edwardk> so iso  makes an actual isomorphism, and you can use 'from' to turn an isomorphism around, or just compose it like any other lens
22:56:47 <edwardk> overloaded function application for the win
22:57:31 <edwardk> basically i needed to use the isomorphism between (b -> f b) and (a -> f a) forall functors f.
22:57:44 <edwardk> to recover the functions a -> b and b -> a
22:59:12 <edwardk> but with that i can go through and upgrade all the lenses that are actual isomorphisms
22:59:15 <startling> what's the point of separated (.) and id in Control.Category?
22:59:21 <startling> hysterical raisins?
22:59:33 <edwardk> startling: what do you mean? why are they in category and not in base like that?
22:59:39 <startling> edwardk: correct
22:59:47 <edwardk> hysterical raisins
22:59:50 <startling> alright
22:59:54 <edwardk> category is a recent addition
23:00:01 <startling> I gathered as much. Darn.
23:00:21 <startling> And the Prelude has stayed constant for however long?
23:00:34 <startling> @src (.)
23:00:35 <lambdabot> (f . g) x = f (g x)
23:00:35 <lambdabot> NB: In lambdabot,  (.) = fmap
23:00:54 <Veinor> there's also mumbling that Prelude.id = Category.id would be confusing to newbies
23:01:14 <startling> Veinor: bleh. just like map = fmap would be confusing to newbies?
23:01:32 <latro`a> that I don't think would be confusing, actually
23:01:52 <latro`a> at least, given some of the other fairly confusing primitive names
23:03:10 <Veinor> it's not the names, it'd be the type errors
23:03:29 <latro`a> now *that* is true, yes
23:03:39 <startling> type errors aren't exactly light reading regardless
23:03:45 <latro`a> eh
23:03:51 <latro`a> relative to a lot of errors in other languages
23:03:53 <latro`a> I find that they are
23:04:18 <latro`a> just depends on the type error, though
23:04:42 <startling> yeah. sometimes you get a realy nasty one
23:05:10 <startling> sometimes it's "No instance Functor for (+2)" and you realize you fmap'd backwards or something
23:05:16 <latro`a> the really severe type errors tend to throw multiple
23:05:22 <latro`a> and then you're just going wtfffff
23:05:25 <latro`a> also in monolithic functions
23:05:28 <latro`a> you get a nightmare
23:05:45 <startling> couldn't deduce (x1 ~ x3)
23:05:58 <latro`a> most of those are "comment the damn signature"
23:06:04 <startling> indeed
23:06:05 <latro`a> especially if further down you see "bound type variable"
23:07:21 <startling> so (I can't / it's bad practice to) restrict types for a data constructor?
23:07:34 <startling> even if the type is absolutely nonsense without this restriction?
23:07:39 <latro`a> you mean a constraint, or making it concrete?
23:07:48 <latro`a> making it concrete is smiled upon, slapping a constraint is not
23:08:04 <latro`a> iirc the constraint doesn't wind up doing the right thing anyway
23:08:04 <startling> latro`a, what does "making it concrete" mean?
23:08:06 <latro`a> like
23:08:07 <latro`a> Int
23:08:12 <latro`a> instead of Num a => a
23:08:38 <startling> oh. No, I've got a thing that contains a Data.Map and I'm needing to put an Ord k => everywhere
23:08:41 <latro`a> (making it concrete has its drawbacks too, obviously, but is at least predictable)
23:08:44 <latro`a> ahh
23:08:56 <latro`a> hate that, yeah
23:09:14 <startling> darn. :/
23:09:29 <latro`a> I forget what exactly goes wrong when you constrain the type declaration
23:09:32 <latro`a> but iirc something does
23:09:45 <startling> haha. good to know I guess. :)
23:09:45 <latro`a> specifically iirc you wind up needing it on the functions anyway, but again I forget why
23:10:53 <startling> is there a Language extension for alternate constructors, by the way?
23:11:05 <latro`a> alternate?
23:11:16 <startling> that you could pattern match against, but supply defaut values or whatever
23:11:28 <startling> or just hide the implementation
23:12:35 <startling> like, if I do "type X = Free Whatever Something", it's sort of annoying to need to import Control.Monad.Free everywhere and pattern match against Free and Pure
23:12:53 <quintessence> startling: there are view patterns, but they're not transparent
23:13:10 <quintessence> (i.e. you can tell it's a view pattern and not a regular constructor pattern)
23:13:17 <startling> newtype wouldn't help either -- then I would need to pattern match against NewThing Free and NewThing Pure
23:13:22 <startling> quintessence: hmm, interesting
23:32:05 <merijn> startling: You could reexport Control.Monad.Free from the module where you define type X? Although that doesn't remove the pattern matching
23:32:55 <startling> merijn, yeah, thought about that. but meh. it's a shame you can't even define synonyms for data constructors
23:34:15 <latro`a> erm
23:34:17 <latro`a> what?
23:34:27 <latro`a> @ no synonyms for constructors
23:34:36 <startling> *that can be pattern matched against
23:34:40 <latro`a> oh
23:34:42 <latro`a> right
23:35:24 <latro`a> the obvious TH solution being an abomination unto everything
23:35:58 <startling> indeed
23:46:21 <danharaj> edwardk: The TH module for lens doesn't support generating lenses for sum types. Is this intended? data-lens does it without complaints.
23:46:39 <edwardk> danharaj: not by design, it was the implementation i was supplied
23:46:46 <edwardk> i'll raid the one from data-lens
23:47:12 <edwardk> dan burton released the one used by lens-family and i think russell just copied it into his package
23:47:29 <edwardk> if you want to do the port i'll happily take a patch
23:47:46 <edwardk> i have shiny new isomorphism lenses going in
23:47:49 <edwardk> they work really well
23:47:56 <danharaj> If I ever have time or desire :P
23:48:04 <edwardk> modifiedJulianDay :: Iso Day Integer
23:48:04 <edwardk> modifiedJulianDay = iso toModifiedJulianDay ModifiedJulianDay
23:48:16 <edwardk> given an isomorphism lens you can compose it like any other
23:48:34 <edwardk> and you can flip them with 'from' =)
23:48:47 <edwardk> from modifiedJulianDay . modifiedJulianDay = id
23:49:16 <danharaj> nifty
23:49:24 <startling> is there something like "f a b x = a x . b x"?
23:49:31 <danharaj> oh, I had a question: what are the laws for traversables? They're not in the docs as far as I saw.
23:49:59 <c_wraith> :t \f g x -> f x . g x
23:50:00 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (t -> a -> b) -> (t -> f a) -> t -> f b
23:50:07 <edwardk> they are in my current writeup, but they are a transcription of the ones from the 'essence of the iterator patter' by jeremy gibbons
23:50:35 <edwardk> basically it can't change the number of its targets, and it should behave as a Functor when used as a 'Setter'
23:50:36 <c_wraith> :t liftM2 (.)
23:50:37 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
23:50:53 <c_wraith> look the same to me!
23:50:56 <edwardk> adjust l id = id; adjust l f . adjust l g = adjust l (f . g)
23:51:17 <danharaj> mm
23:51:17 <edwardk> thats why members is a Setter for a Set but not a Traversal
23:51:28 <c_wraith> :t liftM2 (.) `asTypeOf` \f g x -> f x . g x
23:51:28 <lambdabot> forall a b (f :: * -> *) t. (Functor f, Monad ((->) t)) => (t -> a -> b) -> (t -> f a) -> t -> f b
23:51:43 <edwardk> because mapping the elements of a set may remove redundant elements from it
23:52:03 <danharaj> I take it the names in lens are supposed to be suggestive of lenses unifying all those things being named from earlier libraries.
23:52:12 <edwardk> yep
23:52:19 <danharaj> Pretty cool piece of technology.
23:52:32 <danharaj> Maybe in a few years lens tutorials will be all the rage.
23:52:45 <edwardk> so 'Traversal' is to 'Traversable' , 'Fold' is to 'Foldable'  -- Setter is 'Functor'-like, sadly the names don't match ;)
23:52:54 <edwardk> 'Getter' is just a CPSd function
23:53:07 <edwardk> and a Lens is just a Traversable that is also a Getter.
23:53:20 <edwardk> er that can be used as a legal getter
23:54:11 <danharaj> That's a striking pattern. There's 'just functions' and then there's extra stuff in the box.
23:55:45 <edwardk> and finally of course an isomorphism is just a pair of functions
23:55:53 <edwardk> it was tricky as hell getting that to fit the rest
23:56:13 <danharaj> are sections and retracts interesting?
23:57:16 <edwardk> well, lawvere and schanuel think so ;)
23:58:07 <danharaj> :P. one other thing. I feel like the Lens type signatures are really clean when you restrict to type constructors / data families instead of the general lens families. Have you found a useful instance where you need more?
23:58:44 <startling> is there a nice way to turn Just x into Right x, supplying a possible Left value in case of Nothing?
23:58:57 <latro`a> I know the name of the thing
23:59:01 <latro`a> but I don't remember where it is
23:59:03 <latro`a> it's called note
23:59:08 <latro`a> and its inverse is called hush
23:59:19 <latro`a> ("inverse", you know what I mean :p)
23:59:44 <Axman6> @djinn b -> Maybe a -> Either b a
23:59:45 <lambdabot> f a b =
23:59:45 <lambdabot>     case b of
23:59:45 <lambdabot>     Nothing -> Left a
23:59:45 <lambdabot>     Just c -> Right c
