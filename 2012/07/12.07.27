00:00:05 <ion> edwardk: But yeah, a _ prefix is evil for anything else than throwaway variables in patterns IMNSHO.
00:00:32 <edwardk> ion: i'm looking for a less crappy name for fstL and sndL that doesn't involve _, but its damn handy here =)
00:00:36 <shachaf> 3010   LEFT BLACK LENTICULAR BRACKET     [【]
00:00:38 <edwardk> and its largely invisible which i like
00:01:02 <shachaf> Come on, you gotta use lenticular brackets!
00:01:09 <TEttinger> http://graphemica.com/%EA%83%94
00:01:20 <TEttinger> it's a letter!  kinda!
00:01:27 <ion> I don’t really see the problem with fstL, sndL. If i know the context (lenses) they are immediately obvious. _1 and _2 are certainly not.
00:01:46 <shachaf> I would be fine with an _ *suffix*.
00:02:00 <edwardk> ion: well, i got rid of all the name mangling in the rest of the module, those are the last 2
00:02:08 <valentin> you use @src here to see the code. How do you do the same in Haskell environment?
00:02:13 <covi> what are 'lenses'?
00:02:14 <edwardk> i don't like random uppercase letters floating around for no reason
00:02:28 <edwardk> covi: a lens is a functional reference to part of a structure.
00:02:40 <edwardk> covi: you can have (a -> b)  and (a -> b -> a)  as a getter and a setter
00:02:55 <edwardk> those can be composed though, so you can access fields of fields
00:03:10 <shachaf> valentin: You don't.
00:03:15 <edwardk> the lens model i've been talking about today uses a odd looking representation
00:03:17 <ion> valentin: @src is a lambdabot command that uses a hand-written text file containing implementations of certain functions.
00:03:36 <edwardk> Functor f => (b -> f b) -> a -> f a  -- is a lens that knows how to get a 'b' out of an 'a'
00:03:42 <edwardk> and how to put it back in
00:03:45 <valentin> can I ask lambdabot personally?
00:03:50 <ion> valentin: /msg
00:04:07 <edwardk> _2 f (c,a) = (,) c <$> f a
00:04:10 <shachaf> valentin: You can use :i to get some information, like the file a function was defined in. At that point you can look at the file directly.
00:04:18 <edwardk> defines a lens that access the second part of a tuple
00:04:26 <ion> valentin: I usually look up the source by hoogling the function, opening the documentation and clicking the source link.
00:04:38 <edwardk> the fun part is finding an appropriate Functor to pass it to get and set the values you want
00:04:42 * DanBurton does the same thing as ion
00:05:01 <edwardk> if you pass it the Identity functor, you get a way to set or modify the value.
00:05:14 <edwardk> if you pass it the 'Const b' functor you can read it
00:05:49 <sopvop> anyone knows how to auto-complete in emacs ghci buffer with haskell-mode?
00:05:55 <DanBurton> what happens if you give it the (a ->) functor?
00:06:09 <ion> danburton: It works very well with that functor.
00:06:57 <edwardk> you get (b -> e -> b) -> a -> e -> b
00:07:14 <edwardk> when e = a nothing interesting additional happens =)
00:08:14 <ion> > let sndL f (c,a) = (,) c <$> f a in sndL (flip id) (123,123) (reverse . show . succ)
00:08:16 <lambdabot>   (123,"421")
00:08:47 <ion> > let sndL f (c,a) = (,) c <$> f a in sndL (flip id) (123,123) (const "foo")
00:08:49 <lambdabot>   (123,"foo")
00:09:08 <Ippo> do you mind if I ask what's the matter?
00:09:15 <ion> > let fstL f (a,c) = flip (,) c <$> f a in sndL (flip id) (123,123) (const "foo")
00:09:16 <lambdabot>   Not in scope: `sndL'
00:09:19 <ion> > let fstL f (a,c) = flip (,) c <$> f a in fstL (flip id) (123,123) (const "foo")
00:09:21 <lambdabot>   ("foo",123)
00:09:38 <DanBurton> @type flip id
00:09:39 <lambdabot> forall a b. a -> (a -> b) -> b
00:10:06 <edwardk> so other than a few folks griping about _1 and _2 what do folks think of the other names in https://github.com/ekmett/lens/blob/master/src/Control/Lens.hs ?
00:10:33 <shachaf> Oops, I forgot that trailing _ already had a clear meaning in Haskell.
00:10:46 <shachaf> ASCII is so overloaded. :-(
00:12:12 <ion> Both prefix and suffix _ already have a clear meaning.
00:12:28 <DanBurton> edwardk: other names look pretty good to me
00:12:59 <edwardk> swapped traverseKey to traverseValueAt
00:13:02 <DanBurton> yeah prefix _ for ignore makes _1 and _2 not very attractive
00:13:11 <shachaf> λ> data Const b a = Const b deriving (Show)
00:13:11 <shachaf> λ> :t Const
00:13:11 <shachaf> Const :: forall (k :: BOX) b (a :: k). b -> Const k b a
00:13:32 <edwardk> i'm not a huge fan of them, but i like them better that way than fstL,sndL
00:13:41 <edwardk> and they are really nice when used in a lens chain
00:14:03 <edwardk> foo._1._2.traverse.folded
00:14:07 <shachaf> edwardk: Are you really using (`subtract` n)?
00:14:21 <shachaf> That takes a moment to figure out. :-)
00:14:23 <edwardk> shachaf: would you rather i sectioned?
00:14:31 <shachaf> You are sectioning.
00:14:34 <edwardk> er not sectioned i mean put a lambda
00:14:36 <DanBurton> oh hey I'm in the copyright notice :) huzzah for my Template Haskell
00:14:41 <edwardk> heh
00:14:42 <shachaf> I mean (n -).
00:14:50 <edwardk> its the other way
00:14:53 <edwardk> > subtract 2 1
00:14:54 <lambdabot>   -1
00:14:55 <shachaf> > (`subtract` 5) 3
00:14:56 <lambdabot>   2
00:15:00 <shachaf> > (5 -) 3
00:15:00 <lambdabot>   2
00:15:07 <edwardk> ah
00:15:11 <edwardk> good point
00:15:46 <DanBurton> subtract is meant to be partially applied since (- 3) already has a different meaning
00:15:57 <edwardk> thats the wrong logic though
00:16:13 <edwardk> l ^-= n = mapOf l (n -)
00:16:24 <edwardk> that means the opposite of what it should
00:16:31 <shachaf> In that case, is it a bug?
00:16:35 <edwardk> i suppose its just subtract 5 i want there
00:16:36 <edwardk> yeah
00:16:49 <DanBurton> yeah mapOf l (subtract 5)
00:16:52 <DanBurton> yeah mapOf l (subtract n)
00:16:58 <shachaf> Even better!
00:17:35 <shachaf> I think your comments are backwards too.
00:18:02 <shachaf> I mean switched, rather.
00:18:06 <ion> edwardk: Plenty of things use e.g. a M suffix for a monad operation. fstL is consistent with Haskell conventions IMO.
00:18:25 <edwardk> yes, but you also don't tend to mash them in close succession
00:18:36 <edwardk> yeah i noticed i had a couple of methods in the wrong place there
00:18:39 <DanBurton> or we could go the way of Classy Prelude and overload everything /ducks
00:19:02 <shachaf> No, go away.
00:19:14 <shachaf> Classyprelude :-(
00:19:23 <DanBurton> or there's always Modular Prelude for scoped imports :-)
00:19:58 <edwardk> i actually have an unreleased 'classes' package that provides a few classes in haskell 98 style that cover most of the use cases of the classy prelude
00:20:04 <edwardk> these Traversals cover the remaider
00:20:06 <edwardk> er remainder
00:20:26 <edwardk> but i'm an academic hack so what do i know
00:20:30 <DanBurton> or use plain old qualified imports. import qualified Lens as L, then just use L.fst
00:21:11 <edwardk> =P
00:21:14 <DanBurton> edwardk: not even a github repo for it?
00:21:21 <DanBurton> your classes package
00:21:27 <edwardk> nah, its on my local machine somewhere
00:21:37 <edwardk> i have a few too many github repos =)
00:22:02 <edwardk> its kind of annoying because once you cross 100 travis.ci has to be manually configured, etc.
00:22:03 <DanBurton> but posting your pet prelude on github is like a rite of passage
00:22:12 <edwardk> i already wrote a pet prelude years ago
00:22:15 <shachaf> More like a rong of passage.
00:22:18 <edwardk> haha
00:22:24 <DanBurton> lol
00:22:37 <DanBurton> shachaf don't tell me you've never made your own pet prelude
00:23:12 <shachaf> Somehow I've managed to repress the urge.
00:23:24 <edwardk> anyways, i've been thinking about taking _1 and putting it into a class so you can use it and its ilk to access larger tuples
00:23:31 <shachaf> I also try not to put things on Github.
00:23:36 <edwardk> but that gets messy
00:24:00 <edwardk> as i've managed heretofore to avoid mptcs in this
00:24:01 <shachaf> edwardk: Is that really a sensible thing?
00:24:08 <edwardk> nope
00:24:21 <edwardk> it works well for my vector space code
00:24:25 <edwardk> but not so great for tuples
00:24:35 <DanBurton> convenience and carefulness will always be at odds
00:24:39 <edwardk> of course
00:24:51 <shachaf> I think 2D and 3D vectors have a lot more in common than some arbitrary (,) and (,,).
00:25:51 <DanBurton> If you're bundling more than 2 values together, it's almost always worth it to just bite the bullet and make another data type
00:26:35 <ion> edwardk: Could TraverseByteString be made more generic for all types like that, e.g. ByteString “contains” Word8s and Text “contains” Chars?
00:26:40 <DanBurton> it's common to pair things up, less common to triple or quadruple them up
00:26:56 <edwardk> ion: not without breaking my selfimposed rule on avoiding MPTCs/TFs in here
00:27:04 <ion> aye
00:27:17 <edwardk> i can make TraverseText and might if i want to enlarge the dependency list
00:27:18 <shachaf> What's a good solution to something like this? do { (x,y,z) <- atomically $ do { ...; return (x,y,z) }; ... }?
00:27:26 <shachaf> That's a 3-tuple right there.
00:27:45 <edwardk> anyOf traverseText (=='c')
00:27:45 <DanBurton> does hugs not do mptcs/fundeps/tfs at all?
00:27:45 <shachaf> In fact I think I may have done something like that with a 5-tuple.
00:27:55 <edwardk> looks pretty convenient
00:28:59 <DanBurton> shachaf: data MeaningfulName = Foo xty yty zty; do { MeaningfulName x y z <- atomically $ do { ...; return $ MeaningfulName x y z }; ...}
00:29:05 <edwardk> i'm shocked that traverse isn't a member of Data.ByteString though
00:29:16 <edwardk> in its inimitable monomorphic fashion
00:29:21 <edwardk> then i wouldn't have to supply one
00:29:37 <shachaf> DanBurton: But it's not meaningful.
00:29:41 <Enigmagic> shachaf: i just use tuples
00:29:50 <shachaf> Enigmagic: That's what I do too.
00:30:01 <shachaf> It's kind of annoying, though.
00:30:42 <edwardk> i mean i understand the moral objection that it can't be made fast
00:30:43 <edwardk> but still
00:30:50 <Enigmagic> i agree
00:31:12 <ion> shachaf: Perhaps you could teleport values impurely with unsafePerformIO.
00:31:36 <shachaf> thion
00:31:55 <ion> you’re wachaf
00:32:59 <ddarius> DanBurton: I'm pretty sure Hugs does MPTCs and Fundeps and definitely does not do type families.
00:33:07 <ddarius> Hugs would be pretty poorly named otherwise.
00:33:38 <shachaf> I would be impressed if it did fundeps without doing MPTCs.
00:34:01 <ddarius> Hmm, I wonder if Hugs allows ZPTCs.
00:34:59 * ddarius considers attempting to derive Poincare-Steklov operators by applying the theory of Lagrange multipliers.
00:36:36 <shachaf> ddarius: I just tried a ZPTC in Hugs.
00:36:39 <shachaf> It segfaulted.
00:36:52 <ddarius> That sounds like Hugs.
00:39:02 <shachaf> Hmm, it segfaults when there's no instance for the nullary class.
00:39:07 <shachaf> When there is an instance it works fine.
00:42:25 <ddarius> Cool.
00:43:05 * ddarius should patch GHC to accept ZPTCs.
00:45:26 <valentin> how can I see the definition of the instance of Monad []?
00:46:42 <hape01> @type []
00:46:44 <lambdabot> forall a. [a]
00:46:52 <hape01> @src []
00:46:52 <lambdabot> data [] a = [] | a : [a]
00:47:11 <ddarius> @src (>>=) []
00:47:12 <lambdabot> Source not found. It can only be attributed to human error.
00:47:19 <ddarius> @src [] (>>=)
00:47:19 <lambdabot> xs >>= f     = concatMap f xs
00:47:47 <hape01> @list
00:47:47 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:47:58 <hape01> @hoogle []
00:47:58 <lambdabot> Did you mean: [a]
00:47:58 <lambdabot> Prelude undefined :: a
00:47:58 <lambdabot> Data.Function fix :: (a -> a) -> a
00:48:05 <hape01> @hoogle [a]
00:48:05 <lambdabot> GHC.Exts build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
00:48:05 <lambdabot> Prelude repeat :: a -> [a]
00:48:05 <lambdabot> Data.List repeat :: a -> [a]
00:49:07 <hape01> @index []
00:49:08 <lambdabot> bzzt
00:51:58 <TEttinger> What is a good way to represent lisp-like Symbols in haskell code? They behave like strings, but compare like integers, since they are hashed at compile time
00:52:56 <mauke> what would you use symbols for?
00:53:10 <TEttinger> implementing lisp :-)
00:53:19 <mauke> you don't need symbols for that
00:53:30 <DanBurton> do you want arbitrary symbols?
00:53:33 <TEttinger> they are generally useful, especially as keys for associative structures
00:53:37 <DanBurton> or a fixed small set of symbols?
00:53:48 <mauke> TEttinger: I disagree
00:54:29 <TEttinger> DanBurton, not %^&, I mean :alpha :top etc.
00:54:49 <companion_cube> they are kind of interned strings
00:54:53 <TEttinger> yes
00:54:54 <DanBurton> TEttinger: right, but you want arbitrary :foo :bar :baz symbols
00:54:58 <TEttinger> yes
00:55:18 <mauke> why not use strings?
00:55:20 <DanBurton> mauke: I'm curious to hear why you disagree
00:55:31 <shachaf> ddarius: It looks like it has an explicit check against nullary classes.
00:55:38 <shachaf> I wonder what would happen if I just commented that out.
00:56:02 <mauke> DanBurton: because I've never needed them
00:56:19 <TEttinger> mauke, because comparing two strings has a performance penalty with every comparison -- besides, it would be weird to try to port the clojure lib without them
00:56:21 <DanBurton> the motivation for symbols over strings is speed. especially with Haskell strings, where comparison happens one char at a time
00:56:23 * shachaf doesn't really feel like getting GHC to compile, though...
00:56:44 <ddarius> Technically, the Haskell version of "symbols" would be enumerated data constructors (and then derive Eq and Show).
00:57:01 <DanBurton> that was my first thought, too
00:57:02 <TEttinger> thanks, ddarius, I will look them up
00:57:26 <shachaf> ddarius: In implementing a Lisp interpreter.
00:57:38 <shachaf> s/.$/?/
00:57:41 <mauke> TEttinger: is that your bottleneck?
00:58:09 <Ralith> TEttinger: symbols compare like strings; interning is an optimization, which serves little purpose in an interpreter.
00:58:26 <TEttinger> mauke, I just needed a better way to represent some things in the compiler
00:58:31 <ddarius> shachaf: "Symbols" interned at compile-time don't help you implement "symbols" in an interpreter.
00:58:55 <mauke> TEttinger: how about a data type?
00:59:12 <DanBurton> if you are the one implementing symbols, then imho just use a global hashmap of string-to-int
00:59:13 <TEttinger> mauke, yeah I am leaning that way
00:59:48 <shachaf> ddarius: I think TEttinger meant "Lisp compile time", not "Haskell compile time".
00:59:49 <DanBurton> that's all lisps do in the end, isn't it?
00:59:56 <shachaf> s/interpreter/evaluator/, I suppose.
01:00:56 <TEttinger> DanBurton, good point -- I should mention that this is a weird project.  I aim to translate lisp-like code to Lua and run it on LuaJIT, using Haskell (with glorious Parsec) to write the translator
01:01:29 <TEttinger> the translation/lisp-compile-time bit may be trouble
01:02:58 <ddarius> Probably the solution closest to what typical Lisp implementations do to implement symbols in a Lisp evaluator would be to use IORefs (or better wrapped versions of IORefs) and hash the syntactic symbols to IORefs, allocating them as needed.
01:03:05 <ddarius> Then checking is just a pointer compare.
01:03:29 <mauke> using the allocator as a unique name generator?
01:03:35 <ddarius> Yes.
01:04:07 <ddarius> mauke: It also gives you a place to put the string for quick reference.
01:05:10 <ddarius> Actual Lisp implementations would just convert all symbols to pointers to the same/only instance of the string and do pointer equality when comparing.
01:09:50 <solrize> does chris dornan come here?  he put a wrong link in reddit, i think
01:09:54 <ddarius> @google Haskell observable sharing
01:09:56 <lambdabot> http://www.ittc.ku.edu/csdl/fpg/sites/default/files/20090903-hask.pdf
01:16:05 <TEttinger> I am confused here -- do you guys think a lisp-like language, with the lisp compilation process (Reader, Macros, etc.) could be run by a one-time translation to an imperative language (Lua)?  I may have to rethink this
01:16:29 <solrize> tettinger have you seen write yourself a scheme in 48 hours?
01:16:38 <TEttinger> yeah, i am following it, or was
01:16:52 <TEttinger> I got off-track trying to get the parser to play nice
01:17:13 <dmwit> Yes, the lambda calculus and Turing machines are interconvertible.
01:17:14 <solrize> as for lisp to lua, hmm, do you plan to have eval?
01:17:49 <solrize> i don't really know lua but its semantics are mostly sort of lisp-like except that icky number/string conversion crap
01:17:50 <dmwit> Now, whether the translation is pretty is another story. ;-)
01:18:09 <TEttinger> solrize, I think a lisp would need eval, although clojurescript doesn't have it, which is lame
01:18:20 <Ralith> TEttinger: lisp does not need eval.
01:18:26 <Ralith> where did you get that idea?
01:18:44 <TEttinger> Ralith, I think I was thinking a "usable" lisp
01:18:51 <Ralith> all the more reason not to have it.
01:18:56 <solrize> do you mean actual conversion to lua, or lua vm code that you pass to the jit?
01:19:14 <TEttinger> lua source
01:19:22 <solrize> hmm, yuck
01:19:25 <Ralith> there are few circumstances in which calling 'eval' is anything but exactly the wrong thing to do.
01:19:27 <TEttinger> vm code isn't terribly portable
01:20:38 <solrize> lua vm?  hmm
01:20:52 <solrize> i haven't looked at it much, wasn't aware of portability probs
01:20:58 <solrize> why do you want to use it?  just for luajit?
01:21:15 <solrize> why not v8 or the current shiny javascript jit?
01:21:39 <solrize> what do you want to use this lisp for anyway?
01:21:51 <TEttinger> well without access to lisp-compile-time macros, maybe it would be better to just make something that looks haskell-y and does some of the odd tricks I have planned in the works (making a language for a reason)
01:22:00 <spobat> hey :)
01:22:01 <spobat> Can you please like this facebook fanpage of my new game? (will be released tomorrow, screenshots here: http://troubi.com/android-apps.php) http://www.facebook.com/TapTwice
01:22:23 <dmwit> No, and also that's off-topic here.
01:22:24 <dmwit> Scram.
01:22:43 <dmwit> ...unless it happens to be written in Haskell...?
01:23:31 <spobat> okay, sorry. :( No, it's not written in Haskell, but I like Hhaskell :)
01:23:33 <TEttinger> luajit has a great FFI, and it is probably the fastest of the JIT compilers for dynamically-typed languages
01:26:01 <solrize> vcode is probably the fast jit, though not especially dynamic-specific.
01:26:07 <solrize> *fastest
01:27:23 <solrize> i know old-school lisp compilers tended to be very simple, i haven't understood why lua and js jits are so much more complicated
01:27:31 <solrize> i guess type specialization at runtime?
01:27:35 <solrize> by tracing
01:27:53 <solrize> but with lisp depending on coding style, you can do some type inference, you can use annotations, etc
01:28:30 <solrize> stalin does tons of type inference and generates very fast code from scheme (stalin compiler itself is very slow)
01:28:40 <t7> type inference is insane with lisp
01:29:08 <t7> (insane hard)
01:29:09 <TEttinger> http://attractivechaos.github.com/plb/ this is what makes me interested in LuaJIT
01:29:21 <TEttinger> sort by matmul:t (time for matrix multiplication)
01:29:48 <TEttinger> that benchmark is a year old now
01:31:34 <TEttinger> solrize, links to vcode?
01:31:58 <solrize> http://pdos.csail.mit.edu/~engler/pldi96-abstract.html
01:32:19 <TEttinger> I found something http://www.cs.cmu.edu/~scandal/html-papers/javanesl/node11.html mentioning a 120 MHz CPU
01:32:25 <solrize> very dumb but super fast code generation
01:33:08 <TEttinger>  currently runs on the MIPS, SPARC, and Alpha architectures.
01:33:14 <TEttinger> how practical!
01:34:08 <TEttinger> are Alpha processors even produced anymore?
01:34:31 <solrize> it's pretty old ;)
01:34:49 <solrize> i thought i saw something about an x86 port
01:35:04 <TEttinger> solaris port
01:35:38 <mroman> is there a traceM?
01:35:47 <TEttinger> in LuaJIT?
01:36:07 <solrize> there is also gnu lightning
01:36:12 <hpaste> “Boyun Tang” pasted “A bug” at http://hpaste.org/72195
01:36:37 <dmwit> mroman: Just use print/putStrLn.
01:36:38 <solrize> i'm still wondering what you want to do with a jitted lisp
01:36:43 <dmwit> Perhaps with a bit of liftIO.
01:38:45 <TEttinger> solrize, mostly I want to try to make something interesting, sorta a hobby thing, but in this case I was thinking of using lisp syntax with the array manipulation capabilities of J and/or APL, running on something that gives me a decent FFI to C (to call a few libraries I want for an app)
01:39:06 <solrize> http://static.usenix.org/events/vm04/tech/full_papers/ganev/ganev_html/node13.html
01:39:19 <TEttinger> I'm thinking APL without looking like APL
01:39:27 <merijn> So J? :p
01:39:52 <TEttinger> J looks like APL, i. does what dotless i does in APL...
01:40:01 <solrize> i haven't used apl in any serious way but if you care about performance don't you want a gpu library?
01:40:02 <DanBurton> hrm, can't decide which order to run finalizers for my conduit clone
01:40:05 <TEttinger> or was it i: ...
01:40:57 <solrize> i mean if the time is all spent in vector stuff the control interpreter can be pretty slow
01:41:04 <TEttinger> solrize, my interest isn't so much in scientific-computing performance as in experimental-coding productivity
01:41:30 <TEttinger> like what J is actually used for, fiddling with data sets
01:42:43 <solrize> for that purpose i'd say start with a naive interpreter
01:43:11 <TEttinger> yeah, but that doesn't allow the C FFI, does it?
01:43:23 <solrize> and certainly, bringing lisp into it sounds like an impedance mismatch
01:43:29 <TEttinger> good point
01:43:44 <solrize> have a c interface for your interpreter, no big deal
01:44:40 <TEttinger> hm... are there any grammars in parsec that can parse haskell?
01:44:44 <TEttinger> or subsets of it
01:44:58 <TEttinger> (significant subsets...)
01:45:02 <Enigmagic> haskell-src-exts
01:45:06 <TEttinger> thanks
01:45:10 <Enigmagic> not parsec but it'll do the job
01:46:14 <ceti331> talking about making a custom vector processing language?
01:46:40 <TEttinger> ceti331, yes?
01:47:07 <ceti331> thats an itch i have but haven't put any time into it
01:47:23 <Enigmagic> i have one of those for processing time series
01:47:49 <ceti331> i did a scripting language ages ago that included vectors as a type
01:48:06 <ceti331> very simple though
01:51:10 <ceti331> but what i really want is a pure functional language with a syntax more familiar to my c++ head than haskel (. for member acess, usual function call notaion and something else for partial application, etc)
01:51:28 <ceti331> maybe a syntax highlighter will help
01:51:34 <TEttinger> Single Assignment C?
01:51:48 <ceti331> maybe i should look at that..
01:52:01 <TEttinger> https://en.wikipedia.org/wiki/SAC_programming_language
01:52:12 <zomg> Haskell syntax may be a bit odd at first but it's pretty awesome once you learn it properly =)
01:52:19 <zomg> But yeah it will take some time
01:52:40 <ceti331> i think what makes it utterly bewildering is the fact whitespace binds highest
01:52:43 <mjga> What about using Accelerate? I thought that it was a custom vector processing language, implemented in Haskell. I regret that it has mostly CUDA back-end now, not much seems happening on portable front (e.g. OpenCL and Repa)
01:53:21 <ceti331> at least with lisp the structure is instantly visible
01:54:56 <donri> meh syntax, you get used to new ones quickly
01:55:07 <solrize> ceti331, mythryl.org
01:58:08 <ceti331> haskell uses accesor functions for member acess?
01:58:15 <ceti331> record acess
01:59:16 <solrize> ceti331, the haskell record story is pretty weak but yeah it generates access functions
01:59:21 <ehamberg> record syntax is just the creation of a datatype together with accessor functions.
01:59:36 <solrize> data Foo = Foo { blah :: Int, meh :: String }
01:59:51 <solrize> blah (Foo 3 "bar" )  = 3
02:00:02 <solrize> meh (Foo 3 "bar" ) = "bar"
02:00:41 <solrize> (Foo 3 "bar") { blah = 5)  = (Foo 5 "bar")
02:00:57 <solrize> (Foo 3 "bar") { blah = 5 } = (Foo 5 "bar")    -- oops, meant this
02:01:47 <ceti331> a b >>= c d    same as     c d (a b)  , is that right?
02:02:04 <srhb> ceti331: No.
02:02:14 <srhb> @type (>>=)
02:02:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:03:14 <DanBurton> a b >>= c d   same as   join (liftM (c d) (a b))  iinm, though not sure how helpful that is
02:03:15 <solrize> it's the same as     do { x <- a b ;  c d x }
02:03:34 <ceti331> ah, its sequential?
02:03:51 <solrize> erm not necessarily
02:03:55 <DanBurton> yep >>= is "sequential". ish. some monads aren't, but most are.
02:04:02 <ceti331> is it used to pass the modified io state placeholder object along in sequential operations with side effects
02:04:05 <solrize> >>= means sequencing in the i/o monad but other things in other monads
02:04:27 <solrize> you know how some languages have operator overloading?  >>= basically overloads semicolon
02:04:45 <ceti331> oh.
02:04:48 <solrize> > [1,2,3] >>= [4,5,6]
02:04:50 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
02:05:01 <DanBurton> [4,5,6] is not a function
02:05:09 <solrize> oops :)
02:05:10 <DanBurton> > [1,2,3] >> [4,5,6]
02:05:12 <lambdabot>   [4,5,6,4,5,6,4,5,6]
02:05:14 <ceti331> can you actually overload it yourself...
02:05:30 <DanBurton> ceti331: sure, you can provide your own monad instance for your own data types
02:05:57 <DanBurton> then you get to decide what >>= means
02:06:20 <DanBurton> though its recommended that you obey monad laws so as to not shoot yourself in the foot
02:06:27 <ceti331> whats the significance of <- in the do { x <- a b ; c d x }   .. is that just like single assignment x = a b
02:06:49 <srhb> ceti331: http://members.chello.nl/hjgtuyl/tourdemonad.html#(>>=) you should read this bit, it shows you a few instances. :)
02:07:14 <srhb> ceti331: It "unwraps" the monadic value of its Monad, provided you put it back later, if you let the do-expression use its value as its own
02:07:14 <merijn> ceti331: You can think of it as assignment, yes. (In case of the IO monad), or you can think of it of extracting the a out of "m a"
02:07:16 <DanBurton> do { x <- m; rest } is merely syntactic sugar for (m >>= (\x -> rest))
02:07:45 <ceti331> m >> k  =  m >>= \_ -> k
02:07:45 <srhb> > Just 2 >>= return . (+2)
02:07:47 <lambdabot>   Just 4
02:07:47 <ceti331> ?!?!?!?
02:07:48 <lambdabot> Unknown command, try @list
02:07:49 <ceti331> hahaha
02:07:53 <ceti331> \_
02:07:58 <ceti331> its like ascii art
02:07:58 <DanBurton> if we're just talking about the IO monad, then you can think of <- as "perform the side effects and get me the result"
02:08:19 <srhb> ceti331: Note how It is unwrapped by the >>=, then the function (+2) is used on it, and then it is returned to its context in the Maybe monad
02:08:21 <srhb> ie. Just
02:08:33 <merijn> ceti331: _ means "ignore this pattern"
02:08:56 <ceti331> \ is lambda?
02:08:59 <srhb> Right
02:09:00 <DanBurton> every time I see bind return compose, my brain dies a little xD
02:09:00 <merijn> ceti331: Yes
02:09:03 <b52> ceti331: maybe you should read something like http://learnyouahaskell.com
02:09:16 <srhb> DanBurton: It makes it easier to fathom how the operator works though.
02:09:18 <merijn> I second Learn You a Haskell, it is very good
02:09:20 <srhb> Or at least I think so.
02:09:26 <DanBurton> srhb: indeed
02:09:35 <DanBurton> I concur, LYAH is excellent
02:09:38 <DanBurton> twas my gateway drug
02:09:48 <b52> and when your done with lyah, try realworldhaskell
02:10:01 <b52> http://book.realworldhaskell.org/
02:10:04 <srhb> [1,2,3] >>= return . (+2) -- ceti331
02:10:08 <srhb> > [1,2,3] >>= return . (+2) -- ceti331
02:10:10 <lambdabot>   [3,4,5]
02:10:14 * hackagebot ssv 0.2.1 - Comma-separated-value (CSV) read, show and write routines (BartonMassey)
02:10:55 <merijn> > let f = return . (+2) in Just 2 >>= f
02:10:56 <lambdabot>   Just 4
02:11:01 <merijn> > let f = return . (+2) in Nothing >>= f
02:11:03 <lambdabot>   Nothing
02:11:54 <ceti331> return x = x ? nop?
02:12:15 <DanBurton> I just realized I still have conduit-0.2.x on this computer o_O
02:12:20 <b52> ceti331: depends on the monad
02:12:25 <ceti331> oh
02:12:43 <merijn> If you look at the type of (>>=) and specialise it for Maybe then you can see what happens
02:12:45 <b52> each monad defines its own return, >>= etc.
02:12:48 <mietek> Anyone familiar with yesod and/or cabal-dev dependency hell?
02:13:02 <merijn> return :: a -> m a, so for Maybe a return is just Just
02:13:04 <merijn> > return 2
02:13:05 <lambdabot>   No instance for (GHC.Show.Show (m t))
02:13:06 <lambdabot>    arising from a use of `M9849548948...
02:13:08 <merijn> > return 2 :: Maybe Int
02:13:09 <lambdabot>   Just 2
02:13:26 <b52> > return 2 :: [] Int
02:13:28 <lambdabot>   [2]
02:13:36 <DanBurton> the choice of naming "return" was deeply unfortunate, imho
02:13:37 <b52> i like it to write list monad style :D
02:13:43 <mietek> DanBurton: how about "pure"?
02:13:49 <DanBurton> I love "pure" so much better
02:14:04 <merijn> (>>=) :: m a -> (a -> m b) -> m b, or specialised to Maybe: (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
02:14:11 <mietek> I like verbful function names
02:14:23 <mietek> It could at least be "purée"
02:14:54 <merijn> ceti331: It should be (relatively) clear, that given the definition of Maybe and >>= that the only thing it can do when Maybe a is Nothing is return Nothing as final result
02:14:57 <DanBurton> I like writing "pure Nothing"
02:16:32 <merijn> ceti331: As an example, imagine doing multiple lookup inside a map (lookup :: key -> Map key val -> Maybe val), where the second lookup uses the result of the first, the third the result of the second, etc.
02:16:40 <ceti331> i've just looked at the definition of "filterM" .. why does this relate to monads
02:16:47 <ceti331> filter predicate list
02:17:16 <b52> look at the type
02:17:20 <b52> :t filterM
02:17:22 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
02:18:12 <ceti331> i can't read that :(
02:18:13 <DanBurton> mietek: what were you saying earlier about dependency hell?
02:18:17 <merijn> ceti331: You would have to check for errors on every single lookup. Very annoying, right? The solution is to use (I reversed key and map for simplicity here) "lookup map first >>= lookup map >>= lookup map", the >>= will ensure that the entire thing returns Just when there is an answer, or Nothing if any of the lookups return Nothing
02:18:33 <fmap> > filterM (const [True,False]) [1,2,3]
02:18:34 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
02:18:47 <merijn> fmap: Not a very clear example, I think
02:19:16 <DanBurton> a very interesting example, nonetheless
02:19:25 <b52> ceti331: its too bad that you cant read even the type signature, maybe you should get a basic knowledge of haskell first
02:19:34 <merijn> ceti331: A better example for filter, imagine having a list of filenames and wanting to check which exist. Doing file IO is (obviously) IO, right. So I might have a function fileExist :: FilePath -> IO Bool, make sense?
02:19:57 <ceti331> i get map and filter normally
02:20:02 <DanBurton> lambdabot adds kind information and foralls which clutters the type signature a bit
02:20:16 <ceti331> so filterM is just a monad friendly version of filter ?
02:20:21 <merijn> ceti331: Now, I want a function that takes a [FilePath], runs fileExist on each entry, and then filter those that don't exist
02:20:34 <b0fh_ua> Hi all! In theory - is it possible to write a module for Nginx in Haskell?
02:20:47 <mietek> DanBurton: I'm trying to follow the yesod tutorial.  I have a fresh install of HP 2012.2 + yesod-platform + cabal-dev, on both OS X and Ubuntu.  Attempting a cabal-dev install in a freshly initialized yesod site fails horribly: http://hpaste.org/72194
02:20:54 <b52> b0fh_ua: probably
02:20:56 <ceti331> <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
02:20:58 <mietek> Using cabal instead of cabal-dev works.
02:21:00 <ceti331> whats the =>
02:21:07 <bitonic> b0fh_ua: you can call Haskell from C, so yeah
02:21:12 <bitonic> probably not a good idea
02:21:17 <merijn> ceti331: filterM takes my [FilePath], fileExist, runs fileExist on every item, filters those that don't exist and then return the new [FilePath] (inside IO, because I did IO)
02:22:37 <mietek> ceti331: the => separates the typeclass constraints from the function type.  In the example you pasted, it reads like this: "For every typeclass m which is an instance of Monad..."
02:22:38 <merijn> ceti331: The Monad m part in (for example) "return :: (Monad m) => a -> m a", means that "for every m, which is an instance of the monad type class, return has the type "a -> m a""
02:22:49 <DanBurton> mietek: that's unfortunate. I periodically attempt to do the same thing, and almost always run into the same problem, which is quite offputting.
02:23:08 <DanBurton> does cabal-dev have --solver=modular ?
02:23:13 <mietek> No idea.
02:23:23 <DanBurton> try cabal-dev install --solver=modular
02:23:25 <DanBurton> and see what happens
02:23:28 <merijn> ceti331: For example, Maybe and [] are instances of Monad, so that means there is an instance "return :: a -> Maybe a"
02:23:46 <b52> you can think of Monad as an interface
02:24:02 <b52> Maybe e.g. implements the monad interface
02:24:09 <merijn> ceti331: Similarly, filterM works for all values of m that happen to be monads
02:24:15 <b52> meaning that it provides functions for return, bind etc.
02:25:28 <merijn> Make sense so far?
02:26:18 <ceti331> i see theres foldM etc
02:27:16 <merijn> ceti331: Yeah, once you start getting the hang of it, you'll find a lot of code just consists combining a few functions together using the existing combinators like foldM
02:28:02 <ceti331> i like the whole idea of functional programming, map,filter etc instead of iterators...
02:28:48 <ceti331> from having done data-pparallel coding in c where its a mess
02:28:56 <merijn> ceti331: for example, imagine you want to print a list of items. You could imagine doing something like "map print [1..10]" and then having to do "foldl (>>) (return ())" to force it to print everything
02:29:53 <merijn> That's very inconvenient, though. And many people want to run things on lists, so someone wrote a generic "mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]"
02:30:25 <mjga> b0fh_ua: in theory yes - you'd just need to port NGINX API using FFI (c2hs?). But if you want to just write a webapp, then FastCGI should work just fine (and API is already there.)
02:30:31 <knz> btw -- what's the difference between mapM and mapM_ ?
02:30:42 <merijn> As a result you can simply do "mapM print [1..10]" (although, since print returns "IO ()" you'll just end up with a list with ten ()'s in there, not very useful)
02:30:54 <knz> :t mapM
02:30:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:30:57 <knz> :t mapM_
02:30:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:30:59 <Adeon> you don't get the result from other
02:31:05 <amatsu> knz: mapM_ discards the output, useful for IO and other things.
02:31:21 <knz> k
02:35:14 * hackagebot lens 0.4 - Lenses and Lens Families (EdwardKmett)
02:35:30 <shachaf> preflex: seen ddarius
02:35:30 <preflex>  ddarius was last seen on #haskell 1 hour, 25 minutes and 36 seconds ago, saying: @google Haskell observable sharing
02:35:39 <edwardk> now with SafeHaskell support
02:36:34 <shachaf> @tell ddarius Adding ZPTC support to GHC consists of removing one line.
02:36:34 <lambdabot> Consider it noted.
02:37:04 <shachaf> For some reason I expected it would be work.
02:37:16 <shachaf> I'm not sure why the limitation is there in the first place...
02:37:46 <nand`> ZTPC?
02:37:57 <shachaf> Zero-parameter type classes.
02:38:35 <nand`> how would those be used?
02:38:48 <nand`> class Foo where ...; instance Foo where ...; ?
02:39:18 <shachaf> I'm not sure that anything interesting could go in the "where".
02:40:12 <b0fh_ua> mjga: I need to write a simple module
02:40:21 <b0fh_ua> mjga: just don't want to fight with C :)
02:41:21 <nand`> shachaf: I don't see why not
02:41:57 <shachaf> nand`: Well, there could only ever be one instance.
02:42:07 <shachaf> Anyway, /me >>= sleep
02:42:19 <nand`> shachaf: I just don't see a difference between ZPTC and just defining those functions normally
02:42:50 <nand`> but other than that it should work, right? No type variables to mention in the first place
02:43:28 <shachaf> There are no functions.
02:43:39 <shachaf> You can only ever have one instance.
02:45:20 <nand`> perhaps something evil could be done with importing different orphan instances to give a function of type :: MyClass => ...; a different meaning, but I don't see a difference between that and just writing :: (foo -> bar) -> ...; in the first place, where “foo -> bar” is some hypothetical class function
02:52:58 <povman> Is ListT-done-right meant to get into the mtl some time?
02:53:30 <povman> I just realised a huge performance issue is due to the evil standard ListT
03:08:12 <dzhus> Does anyone has experience with adding early termination to attoparsec's Parser monad instead of backtracking?
03:08:25 <LambdaDusk> does anyone know how to express failure in an attoparsec
03:08:34 <LambdaDusk> haha
03:08:41 <dzhus> lolwut
03:08:45 <LambdaDusk> dzhus: Same questions, it seems
03:08:50 <bitonic> povman: so wait, what's the non-evil ListT? [m a]?
03:09:18 <bitonic> I don't see many way you can define ListT
03:10:02 <dzhus> LambdaDusk: where do you need it? I've added lookup table to my parser which is updated as parser goes through the input. I want to make it fail early if unknown symbol is referenced. But `fail` of Parser fails only current parser chunk (to have easy backtracking), and I want it to go all way up to the toplevel Parser
03:10:19 <dzhus> currently I'm using `error` but it's ugly
03:11:03 <LambdaDusk> dzhus: I have a similar problem, as I have a start tag and an end tag and I want to express that they share the same identifier
03:11:22 <LambdaDusk> dzhus: I tried "fail" and "mzero" but it's the problem you stated
03:11:26 <bitonic> dzhus: wait, why don't you just use `fail'?
03:11:34 <dzhus> bitonic: fail is for backtracking
03:11:46 <bitonic> dzhus: is it?  mhm.
03:11:53 <LambdaDusk> bitonic: "fail" still produces a valid output
03:11:58 <dzhus> bitonic: well, it look like it is
03:12:09 <bitonic> dzhus: did you try?
03:12:14 <dzhus> yes
03:12:24 <dzhus> it does not terminate early :(
03:12:36 <LambdaDusk> instead of returning an parser error, it returns the parsed value up to the point when it failed
03:13:22 <dzhus> how come that we have the same problem at the same time? Schumann resonance must have something to do with it
03:13:30 <allsystemsarego> Hi, where is a good place to ask questions about Fay (fay-lang.org) ?
03:13:39 <bitonic> dzhus: OK.  wrap the parser in an error monad
03:13:50 <donri> allsystemsarego: here
03:13:51 <bitonic> allsystemsarego: you can probably ask here, the author is often around
03:13:58 <marcot> Hi.  My program is failing with this error: thread blocked indefinitely in an MVar operation.  How can I debug to at least know which part of the program is related?  I don't use MVars in my code.
03:14:06 <dzhus> bitonic: oh yes, somehow this doesn't help much. I'll post more details
03:14:27 <bitonic> dzhus: what does not help much?  ErrorT will give you early termination
03:14:46 <nand`> @check (==)
03:14:47 <lambdabot>   "OK, passed 500 tests."
03:15:10 <bitonic> marcot: well, what are you using that uses MVars?
03:16:00 <dzhus> I had such error with vector
03:16:06 <LambdaDusk> bitonic: When you use "fail" in parsec, the parser stops and gives a "Left" value in the return of "parse". When you use "fail" in attoparsec, you still get a "Right". So you don't know if that really was the input or if there was a parsing failure
03:16:20 <donri> while we're on the subject of attoparsec... how do you do look-ahead/behind?
03:16:27 <dzhus> donri: `try`
03:16:29 <bitonic> LambdaDusk: well parsec is not backtracking by default
03:16:32 <marcot> bitonic: I'm not sure, I use quite a lot of libraries: base, directory, containers, time, regex-tdfa, parsec, network, HTTP, json, MissingH, tagsoup, hslogger, cmdargs, text, bytestring, iconv, HUnit and random.
03:17:09 <donri> dzhus: try = id for attoparsec, and isn't that sort of the opposite of what i want, hm. parsing confuses me :D
03:17:10 <bitonic> marcot: oh well, good luck
03:17:43 <bitonic> donri: to look ahead just consume and fail
03:18:04 <donri> but i want to succeed without consuming
03:18:16 <Jafet> marcot: the driest way is to use the ghci debugger
03:18:25 <dzhus> donri: are we talking the same try here?
03:18:41 <dzhus> donri: see docs on `manyTill` for the relevant example
03:18:41 <LambdaDusk> donri: In attoparsec, all the parsers are non-consuming
03:18:42 <marcot> Jafet: Hum, thanks, I have never used, I'll read the docs.
03:18:44 <Jafet> That's if you have about zero idea what is wrong
03:19:09 <donri> hmm!
03:19:17 <donri> i'm trying to figure out if i could convert a PEG grammar to attoparsec
03:19:41 <dzhus> #attoparsec here
03:19:52 <bitonic> dzhus: `try' is `id' in attoparsec, because attoparsec will always backtrack
03:20:01 <bitonic> donri: so you'll never need try
03:20:15 <marcot> Jafet: That's unfortunately my case.
03:20:32 <LambdaDusk> donri: And there is the problem I currently have... "fail" means the current parser goes back to the prior without consuming input, so there's no way to express actual parsing failure
03:20:44 <LambdaDusk> except "error" or other unclean stuff
03:21:16 <bitonic> LambdaDusk, dzhus: I don't get while you'd want something like that.  if you have something that parses `a <|> b', why would you want to fail the whole thing in `a'?
03:21:17 <donri> E{ither,rror}T/MaybeT? :)
03:21:43 <dzhus> bitonic: lookup table
03:21:52 <LambdaDusk> bitonic: Because I want to do simple semantic checking
03:22:16 <bitonic> dzhus, LambdaDusk: I don't follow
03:22:42 <hpaste> dzhus pasted “Parser with lookup table” at http://hpaste.org/72202
03:22:47 <LambdaDusk> bitonic: I have something like this: {#bar}bla{/bar}. And I want to check with the parser that the start tag equals the end tag
03:23:02 <LambdaDusk> otherwise it's a parsing error
03:23:08 <bitonic> LambdaDusk: you can do that easily in parec
03:23:11 <bitonic> *attoparsec
03:23:19 <dzhus> bitonic: http://hpaste.org/72202; now if I add extra ErrorT to CSGParser burito, it still doesn't fail early
03:23:35 <LambdaDusk> bitonic: And how?
03:23:50 <bitonic> LambdaDusk: just setup a parser that will match only `{/bar}' when you encounter `{#bar}'
03:24:16 <LambdaDusk> bitonic: Which I am trying to do, but obviously I don't know how
03:24:37 <bitonic> LambdaDusk: well, backtracking is not your problem :)
03:24:53 <bitonic> dzhus: could you condense the code in a few words :P?
03:25:12 <dzhus> bitonic: just see `varName`
03:25:15 <bitonic> I mean why do you need non-backtracking failure
03:25:37 <bitonic> dzhus: OK, why can't you just fail normally?
03:26:03 <hpaste> LambdaDusk pasted “Problematic Parser” at http://hpaste.org/72203
03:27:02 <dzhus> bitonic: then when `geoFile` does `many1 statement` (where every statement does readName under the hood) and when some statement fails to parse due to lookup error, it tries to parse the rest of file with `topLevel`, and fails again; while it should stop already when first statement fails.
03:27:19 <LambdaDusk> bitonic: The offensive code is 41 to 53
03:27:46 <donri> probably being stupid here but, if you have two parsers how do you express that they both should match? it seems <|> expresses that just one needs to match and >> that the first should match and consume
03:27:51 <hpaste> LambdaDusk annotated “Problematic Parser” with “Problematic Parser (annotation)” at http://hpaste.org/72203#a72204
03:28:02 <dzhus> donri: both?
03:28:08 <marcot> I found out the problem, it stops happening when I remove a call to a function I called uLog: uLog pri str x = unsafePerformIO $ sLog pri str >> return x
03:28:24 <donri> dzhus: yes
03:28:25 <dzhus> donri: if you want output from two sequentially succedeing parsers then just use <*>
03:28:32 <LambdaDusk> brb
03:28:33 <bitonic> dzhus: just return a `Maybe something' in `varName', and check
03:28:37 <donri> dzhus: not sequentially
03:28:40 <marcot> Well, sLog is sLog pri str = logM rootLoggerName pri $ show str
03:29:02 <marcot> I thought that a call to logM in unsafePerformIO would be safe.  It seems that I was wrong.
03:29:16 <bitonic> dzhus: if you fail one `varName', you make the whole thing fail.  easy.
03:30:13 <allsystemsarego> I have pastebinned my question about Fay, because it's rather long: http://pastebin.com/raw.php?i=0GEAzeUH Can anyone help?
03:30:15 <mauke> The paste 0GEAzeUH has been copied to http://hpaste.org/72205
03:30:48 <donri> in parsec i think it would be, lookAhead x >> y, or, x >> notFollowedBy y
03:31:20 <bitonic> LambdaDusk: I don't see what the problem is with that, it did not consume any input when the tags don't match
03:31:45 <donri> but there seem to be no such functions in attoparsec, and i'm not sure how to do it
03:31:52 <bitonic> LambdaDusk: just stick an `eof' at the end of the parser to check that the whole thing is parsed
03:32:22 <bitonic> donri: you don't need lookAhead.  you can fail and it will backtrack, as I said before.
03:32:37 <bitonic> donri: maybe if you tell us what you need to do we can help you more effectively
03:32:40 <donri> parsing confuses me. i don't see how that helps?
03:32:49 <bitonic> donri: what do you need to parse?
03:33:13 <donri> ok so parsec, lookAhead x >> y; i want to parse "y" but also assert that it should be an "x"
03:33:36 <LambdaDusk> bitonic: Ah! The eof! Now it works.
03:34:47 <bitonic> donri: why would you do that?
03:35:03 <donri> because i'm converting a 6k lines PEG grammar :P
03:35:11 <donri> and it's defined that way
03:36:45 <bitonic> I don't see why parsing two things in different way would be useful.  and yes that might a bit tricky with attoparsec.
03:37:15 <bitonic> the real solution here is to merge `x' and `y' in one parser :P
03:37:16 <donri> why wouldn't AND be a useful operation?
03:38:06 <donri> well if the solution involves something like that it means hand-rewriting 6k lines of grammar definitions
03:38:47 <donri> (it's for parsing lojban, so possibly the most complicated formally parseable grammar in existence :p)
03:38:52 <bitonic> donri: usually when parsing you're satisfied with one match
03:39:21 <bitonic> donri: but yeah with attoparsec you might have trouble doing that.  I haven't used it extensively, but it looks the case at a cursory glance
03:40:03 <donri> too bad
03:40:38 <bitonic> donri: don't take my word for it.  I might very well be wrong, and I have no time to check properly now
03:41:25 <donri> oh hey it's actually more like 2k lines, wonder where i got the other figure from...
03:41:57 <bitonic> donri: why aren't you using attoparsec anyway?
03:42:01 <bitonic> sorry, parsec
03:42:03 <bitonic> or similar
03:42:09 <donri> parsec is too slow for this grammar
03:42:50 <bitonic> donri: really?  have you benchmarked?
03:43:10 <donri> no, but chrisdone says he tried it on just a subset of the grammar
03:43:30 <donri> and even that was supposedly like actually laggish
03:44:20 <donri> (do you know what lojban is?)
03:44:47 <bitonic> mhm.  I don't know how faster attoparsec will be, if it's a complicated grammar.  attoparsec is good for parsing protocols and stuff like that
03:45:09 <bitonic> donri: yeah I had heard of it before :)
03:45:09 <donri> yea i suspect so too, just wanted to try it
03:46:07 <bitonic> donri: is the language human-readable?
03:46:17 <donri> sure
03:46:18 <bitonic> well, easily?
03:46:28 <bitonic> like could you speak it?
03:46:32 <donri> that's part of what makes the grammar rather complex, the "elidable terminators"
03:46:35 <donri> sure
03:46:59 <bitonic> that's quite remarkable, if you can really be fluent in an unambiguous language
03:47:55 <donri> for example you've been saying a lojban word quite a lot recently ;)
03:48:01 <donri> "donri"
03:48:11 <dzhus> i know only prami
03:48:27 <donri> ui
03:48:37 <bitonic> donri: what does that mean?
03:48:55 <donri> daytime; which in swedish is my real name ("dag")
03:49:28 <bitonic> cool :)
03:49:32 <donri> dzhus's word means love
03:50:15 <fmap> how can you check that 2k lines grammar is unambiguous?
03:50:19 <bitonic> that's swett dzhus.
03:50:27 <bitonic> fmap: peg grammar are unambiguous
03:50:32 <bitonic> well, valid ones
03:50:32 <donri> fmap: there's a java program generated from the peg grammar
03:50:41 <donri> but i want a haskell parser damnit! :D
03:50:56 <donri> http://camxes.lojban.org/
03:51:01 <fmap> aha, thanks
03:51:33 <bitonic> donri: isn't there some Haskell peg library somewhere?
03:52:04 <donri> i've found peggy, but i had some issues with it
03:52:13 <donri> and the author doesn't seem to read the github issues
03:52:16 <bitonic> then you should write a better one!
03:52:39 <donri> or fix peggy, maybe
03:53:21 <bitonic> yeah
03:53:38 <bitonic> I think that writing an efficient PEG grammar is tricky business
03:58:05 <donri> well the plan was to parse the .peg file with attoparsec and generate attoparsec code from that, but guess not :)
03:58:50 * ski . o O ( Dag Prawitz <http://en.wikipedia.org/wiki/Dag_Prawitz> )
03:59:45 <donri> wrong one!
04:00:40 <Algorith> In the pursuit of readable code, what's the advised/canonical way of performing the cross product?
04:00:43 <Algorith> using applicative functors: (,,) <$> [1..3] <*> [4..6] <*> [7..9]
04:00:46 <Algorith> or list comprehensions: [ (x,y,z) | x <- [1..3], y <- [4..6], z <- [7..9] ]
04:00:58 <Algorith> or something else entirely?
04:01:07 <ski> du menar att det finns mer än en svensk som heter Dag ? ;)
04:01:35 <donri> du skojar!
04:01:49 * ski tittar i riktning mot #haskell.se, stirrar sen på donri
04:04:31 <bitonic> Algorith: they're both fine, imo.
04:04:46 <bitonic> maybe lc have a wider audience
04:04:51 <Jafet> Readable code? In mah haskell?
04:05:19 <Jafet> That's a cartesian product, not a cross product
04:05:33 <bitonic> ah, that too :P
04:06:01 <Jafet> > sequence [[1..3], [4..6], [7..9]]
04:06:03 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
04:07:11 <donri> (| ([1..3],[4..6],[7..9]) |)  -- i wonder if 'she' supports this
04:11:31 <Valk> What's the idiomatic Haskell for applying a list of functions to two lists pairwise? I'm just starting to explore Haskell and so far I only came up with myZipWith (f:fs) (a:as) (b:bs) = f a b : myZipWith fs as bs
04:12:24 <marcot> Valk: zipWith ($)
04:13:08 <fmap> `zipWith3 ($)' in this particular case
04:13:51 <Valk> Thanks.
04:13:57 <marcot> fmap: sure.
04:14:36 <Jafet> :t (zipWith ($) .) . zipWith ($)
04:14:38 <lambdabot> forall b b1 b2. [b2 -> b -> b1] -> [b2] -> [b] -> [b1]
04:15:39 <dzhus> turns out `fail` actually does early termination in attoparsec. It was just that I was calling inside burito instead of top layer
04:15:44 <fmap> > getZipList $ ZipList [(+), (*), (^)] <*> ZipList [2..] <*> ZipList [2..]
04:15:45 <lambdabot>   [4,9,256]
04:18:08 <mroman> I hope hlint has a "just fix it" mode
04:18:35 <donri> aww 'she' doesn't support it
04:18:48 <donri> (| (,,) [1..3] [4..6] [7..9] |)  -- works though
04:23:40 <mroman> > let (a:b:c) = [1,2,3] in (a,b,c)
04:23:42 <lambdabot>   (1,2,[3])
04:23:47 <mroman> > let (a:(b:c)) = [1,2,3] in (a,b,c)
04:23:48 <lambdabot>   (1,2,[3])
04:24:05 <Jafet> :i :
04:24:08 <Jafet> Bah
04:24:44 <hpc> heh
04:26:24 <mroman> prettyPrint removes Haskell comments :(
04:27:22 <Jafet> Write pretty comments!
04:30:00 <mroman> a screw it.
04:30:04 <mroman> Who needs comments anyway.
04:30:36 <Jafet> PHP developers
04:30:41 <sopvop> Type annotations are comments!
04:31:50 <mroman> I'm not correcting 100 redundant brackets by hand.
04:33:21 <t7> @djinn (a -> b) -> (c -> d) -> (b -> c) -> a -> d
04:33:22 <lambdabot> f a b c d = b (c (a d))
04:33:51 <hpc> @@ pl djinn (a -> b) -> (c -> d) -> (b -> c) -> a -> d
04:33:51 <lambdabot>  pl djinn (a -> b) -> (c -> d) -> (b -> c) -> a -> d
04:33:56 <hpc> @@ @pl @djinn (a -> b) -> (c -> d) -> (b -> c) -> a -> d
04:33:56 <lambdabot>  f = flip ((.) . (.)) . flip (.)
04:35:01 <sopvop> > mappend ([1],[2]) ([3], [4])
04:35:02 <lambdabot>   ([1,3],[2,4])
04:35:13 <sopvop> awesome, base authors are not lazy!
04:36:18 <schlicht> hey, i'm using parsec. is there anything like parseEverything? im using the between combinator and want anything as string whats between the (), but its not stringLiteral because there are no " around it
04:36:22 <Jafet> @instances Monoid
04:36:23 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
04:36:34 <JoeHazzers> i'll be honest, i switched to here, and i thought "THAT LOOKS LIKE CURRYING!", then i realised what channel i'm in
04:36:41 * JoeHazzers falls on his swort
04:37:09 <Jafet> PARSE ALL THE THINGS
04:37:45 <schlicht> Jafet,  :D
04:38:13 <sopvop> schlicht: like satisfy ( <> '"')?
04:38:49 <sopvop> oh, <> = /=
04:38:59 <t7> Jafet: that is my most hated meme
04:39:10 <schlicht> sry, i dont quite follow sopvop
04:39:36 <schlicht> ahh okay
04:39:47 <schlicht> i will have a look at it :)
04:39:57 <mroman> schlicht: anyChar?
04:40:08 <mroman> specifically: many anyChar
04:40:24 <Jafet> many anyChar is a great way to die and stop parsing
04:40:41 <schlicht> mroman, anychar need '
04:41:04 <mroman> many (noneOf ")") probably
04:41:09 <mroman> if you wan't to terminate on )
04:41:13 <mroman> *want
04:41:49 <t7> but you will want nested braces ...
04:42:57 <mroman> Then parse recursively.
04:43:10 <schlicht> its startes with {| and ends with |} inbetween is everything allowed
04:43:48 <sopvop> between (string "{|") (string "|}")
04:44:30 <schlicht> sopvop, thats what i'm using, but i need the parse for the part between :)
04:44:35 <schlicht> *parser
04:48:58 <fmap> `string "{|" *> manyTill anyChar (try (string "|}"))'?
04:50:07 <fmap> ah, you another parser between
04:51:12 <hpaste> sopvop pasted “works” at http://hpaste.org/72206
04:51:47 <schlicht> looks good :)
04:52:06 <schlicht> thanks!
04:52:11 <schlicht> what does *> do?
04:52:33 <sopvop> It means evaluate left thing, and ignore result.
04:52:43 <schlicht> coll, thanks :)
04:52:47 <sopvop> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Applicative
04:53:25 <sopvop> also http://book.realworldhaskell.org/read/using-parsec.html
04:53:52 <fmap> *> is >> for applicative
04:54:17 <schlicht> i will have a look at it :)
04:54:47 <fmap> applicative has <* too, sadly there is no <<
04:55:36 <sopvop> there is =<< but no <<? I wonder why
04:56:47 <confusing> what is the difference between fmap's code and sopvop's code?
04:57:03 <ski> @hoogle <<
04:57:03 <lambdabot> Control.Category (<<<) :: Category cat => cat b c -> cat a b -> cat a c
04:57:03 <lambdabot> Control.Arrow (<<<) :: Category cat => cat b c -> cat a b -> cat a c
04:57:03 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
04:57:05 <ski> @hoogle+
04:57:05 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
04:57:05 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
04:57:05 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
04:57:10 <ski> @hoogle+
04:57:10 <lambdabot> Text.XHtml.Transitional (<<) :: HTML a => (Html -> b) -> a -> b
04:57:10 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
04:57:11 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
04:57:17 <sopvop> None, I just pasted it to ghci and tried
04:59:05 <merijn> fmap: *> is *not* >> for applicative, as the left hand will never be run
04:59:53 <aristid> @srch (*>)
04:59:53 <lambdabot> (*>) = liftA2 (const id)
05:00:00 <sopvop> Prelude Control.Applicative> putStrLn "foo" *> putStrLn "bar"
05:00:00 <sopvop> foo
05:00:00 <sopvop> bar
05:00:01 <sopvop> lies!
05:00:10 <aristid> merijn: what do you mean, never run?
05:00:56 <hpc> merijn: for all monads that obey the laws, (*>) = (>>)
05:00:57 <schlicht> how do i get a function like mapReaderT but with this type : (m a -> n b -> o c) -> ReaderT r m a -> ReaderT r n b -> ReaderT r o c
05:01:12 <hpc> (*>)
05:01:15 <hpc> liftA2 (const id
05:01:22 <hpc> liftM2 (const id)
05:01:32 <merijn> aristid: Hmm, I guess I'm getting the implementation then
05:01:53 <hpc> \m n -> do {x <- m; y <- n; return (const id x y)}
05:01:57 <schlicht> why const id?
05:02:05 <hpc> \m n -> do {m; y <- n; return y}
05:02:13 <hpc> \m n -> m >> n
05:02:16 <hpc> (>>)
05:02:18 <hpc> QED
05:02:27 <sopvop> :t const id
05:02:28 <lambdabot> forall a b. b -> a -> a
05:03:29 <rata_> hi
05:04:11 <rata_> what haskell library/tool would you use guys for gui development?
05:04:36 <schlicht> gtk2hs with glade rata
05:04:57 <schlicht> sopvop, i dont get it :(
05:04:57 <hpc> if you are feeling extremely silly, you can use happstack
05:05:19 <sopvop> const adds unused parameter to a function
05:05:27 <sopvop> :t id
05:05:28 <lambdabot> forall a. a -> a
05:05:30 <sopvop> :t const id
05:05:32 <lambdabot> forall a b. b -> a -> a
05:05:47 <schlicht> yeah, okay
05:05:48 <sopvop> and id does nothing
05:05:54 <hpc> also, GHC-specific, but (const id) optimizes better than (flip const)
05:05:57 <hpc> :t flip const
05:05:58 <lambdabot> forall b a. a -> b -> b
05:06:07 <hpc> (it used to optimize better, anyway)
05:08:01 <schlicht> mkay
05:13:25 <ski> hpc : s/QED/QEF/ :)
05:14:04 <confusing> ski: quod erat fail?
05:15:28 <ski> confusing : Quod Erat Faciendum
05:15:41 <ski> "which was to be constructed"
05:16:09 <ski> (used by Euclid when constructing things rather than proving properties)
05:16:21 <mauke> euclid spoke latin?
05:16:51 <ski> it's a translation :)
05:17:14 <ski> (Euclid didn't speak english, either)
05:18:02 <rata_> he probably spoke greek
05:18:26 <merijn> rata_: Crazy talk!
05:25:51 <beaky> hello
05:26:33 <beaky> since ghc links to libgmp, does that mean that my ghc-compiled code must be licensed as GPL?
05:27:17 <Adeon> libgmp is LGPL, which means it can be linked to code of any license as long as it is dynamically linked
05:27:33 <Adeon> the idea being that it can be replaced or modified
05:27:37 <mauke> or statically linked
05:28:02 <Adeon> you can't statically link it unless libgmp has an exception for that
05:28:14 <mauke> it doesn't have to, it's LGPL
05:30:03 <merijn> Adeon: LGPL has an exception for all forms of linking
05:30:20 <merijn> Adeon: Otherwise you couldn't compile (for example) any non-GPL software on linux
05:30:26 <merijn> Since GNU libc is LGPL
05:30:53 <Adeon> I thought there has to be a way to replace LGPL'd code which would rule out most forms of static linking
05:31:04 <mauke> why would that rule out static linking?
05:32:32 <Adeon> because it becomes hard to get the freedoms on the LGPL'd part of code
05:32:38 <Adeon> not explictly static linking, it would just be implied
05:33:10 <merijn> Adeon: That just means that you *also* have to provide an unlinked copy of your code
05:33:23 <merijn> It doesn't mean you're not allowed to provide a statically linked one
05:33:37 <merijn> And I'm not even sure that is required
05:33:58 <Adeon> I see
05:37:58 <Adeon> the license is so C centric
05:38:12 <Adeon> I understood a little better after reading the conditions
05:39:28 <Adeon> the executable itself is considered a derivative work but not the source or object files
05:40:52 <Adeon> well it isn't said exactly like that, it says that executable produced by "work that uses the library" is a derivative work
05:42:24 <Jeanne-Kamikaze> is it me, or do licenses in general suck ? I can't even understand them in my native language
05:42:26 <ceti331> quick q: <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:42:35 <ceti331> in that signature, what does the . signify
05:42:39 <Adeon> the GPLs are long and a little complex
05:42:43 <Jeanne-Kamikaze> a simple bullet list saying what you're allowed and not allowed to do would be much better
05:42:44 <mauke> ceti331: the end of the 'forall'
05:43:11 <ceti331> ok; (i had thought that . was function composition, but didn't think it made sense here)
05:43:18 <Jeanne-Kamikaze> and being explicit about what they're talking about instead of saying "work that uses the library" and crap like that
05:43:26 <ceti331> is the * like a wildcard ?
05:43:31 <mauke> no, it's a kind
05:43:34 <ceti331> haha
05:43:42 <ceti331> me and my guessing.  whats a 'kind'
05:43:47 <mauke> the type of a type
05:43:50 <Jeanne-Kamikaze> the type of a type
05:44:00 <mauke> :k Int
05:44:01 <lambdabot> *
05:44:05 <mauke> :k Maybe
05:44:06 <lambdabot> * -> *
05:44:08 <mauke> :k Maybe Int
05:44:10 <lambdabot> *
05:44:20 <mauke> :k Maybe Maybe
05:44:22 <lambdabot>     `Maybe' is not applied to enough type arguments
05:44:22 <lambdabot>     The first argument of `Maybe' should have kind `*',
05:44:22 <lambdabot>     but `Maybe' has kind `* -> *'
05:44:42 <mauke> :k Int Int
05:44:44 <lambdabot>     `Int' is applied to too many type arguments
05:44:44 <lambdabot>     In the type `Int Int'
05:45:05 <ceti331> can anyone recomdend a graphical binding for haskell : just the ability to get 2d out of it
05:45:36 <ceti331> (under linux )
05:45:43 <Adeon> Jeanne-Kamikaze: "work that uses the library" is defined in one paragraph
05:45:52 <Adeon> "A program that contains no derivative of any portion of the Library, but is designed to work with the Library by being compiled or linked with it, is called a "work that uses the Library". Such a work, in isolation, is not a derivative work of the Library, and therefore falls outside the scope of this License. "
05:46:24 <merijn> Adeon: This is probably more a topic for #-blah, though :)
05:46:58 <Adeon> hey, it is part of the answer to the libgmp question!
05:48:18 <ceti331> again in that signature:   i'm familiar with the idea a -> b->c showing arguments & return as partial functions... but what does this mean with m ...  (a -> m b) -> [a] -> m [b]
05:49:14 <mauke> ceti331: do you know Maybe?
05:49:20 <merijn> ceti331: Lambdabot uses some extensions, which cause it to print more verbose signatures. In "id :: a -> a" the a's are type variables, right? i.e. they can be replace with different types
05:49:23 <ceti331> no :(
05:49:39 <mauke> you should start there
05:49:54 <ceti331> ok back to google
05:49:58 <ceti331> thanks for the pointer..
05:50:06 <mauke> what source are you learning haskell from?
05:51:40 <ceti331> i've read bits on the web and tinkered with ghci a tiny amount
05:51:41 <mjga> Adeon: but it is much more convenient to ship software as statically linked binary.
05:52:07 <merijn> ceti331: In that case I recommend Learn You a Haskell, it is a good beginner guide and much more structured than "bits on the web" :)
05:52:17 <merijn> @where lyah
05:52:17 <lambdabot> http://www.learnyouahaskell.com/
05:52:31 * ski . o O ( "GCC Runtime Library Exception Rationale and FAQ" <http://www.gnu.org/licenses/gcc-exception-faq.html> )
06:02:53 * DanBurton is finally finished working on his blog series, for now
06:03:45 <DanBurton> sunk a lot of time into it today, investigating corner cases in pipe finalization and thinking about alternatives and such
06:39:54 * sopvop is bored, and can't find anything funny with google:haskell sucks
06:41:07 <Eduard_Munteanu> sopvop: try uncyclopedia
06:41:14 <t7> go in #python and explain the importance of static typing
06:41:35 <eyebloom> Has anyone come across a paper that discusses defining datatype from with in a domain specific embedded language?
06:42:29 <sopvop> I think what 1/3 of #haskell are more active on #python.
06:44:18 <Eduard_Munteanu> http://uncyclopedia.wikia.com/wiki/Haskell  -- there it is!
06:45:36 <mjga> sopvop: because Python gives a very high level of abstraction (see NumPy, or Python DB API)
06:45:43 <SimonJF> I'd never thought to look up Haskell on Uncyclopedia before; that's hilarious
06:47:00 * sopvop facepalms: zeta-calculs, gonads, go notation
06:47:03 <jfischoff> Eduard_Munteanu: hahahaha
06:47:27 <SimonJF> The Real World and let_in ones cracked me up :P
06:48:30 <sopvop> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
06:48:31 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
06:48:44 <sopvop> wow
06:48:52 <sopvop> better than famous perl one-liner
06:48:54 <aristid> sopvop: the {- thor's mother -} is essential
06:49:07 <yrlnry> That is pretty excellent.
06:49:13 <aristid> > iterate (*2) 1
06:49:15 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
06:49:21 <aristid> golf'd
06:50:15 <mikeplus64> > let thor's _ = error "struck by lightning"; mother = undefined in thor's mother
06:50:17 <lambdabot>   *Exception: struck by lightning
06:50:48 <sopvop> let_in does not parse :(
06:51:46 <HairyDude> System.IO.Unsafe.Really.IMeanIt.reallyReallyAbsurdlyUnsafePerformIOShameOnYou :)
06:53:15 <mauke> sopvop: works here
06:53:29 <mauke> (it's a string)
06:53:51 <byorgey> covi: honestly, I forget
06:54:33 <HairyDude> is it possible to pass an option to ghc when you run cabal build? I tried ghc-options=-ddump-splices but it says "unrecognised flags"
06:56:07 <sopvop> That uncyclopedia article would be much better without dumb-ass "gonads" and the like.
06:57:06 <fmap> HairyDude: --ghc-options=-ddump-splices works for me
06:57:51 * HairyDude facepalms
06:57:56 <HairyDude> I forgot the double hyphen
06:58:04 <aristid> tsk
06:58:11 <mauke> sopvop: https://encyclopediadramatica.se/Haskell (NSFW)
06:59:36 <aristid> mauke: i like the uncyclopedia article better
06:59:37 * merijn clicks it at work anyway
06:59:55 <sopvop> import System; ... I'm not gonna run that
07:00:09 <HairyDude> as usual, conservapedia is overly simplified, uninformative and plain wrong http://www.conservapedia.com/Haskell
07:00:41 <mauke> yeah, but conservapedia is (ostensibly) serious
07:01:00 <quicksilver> mauke: amazingly, so is wikipedia...
07:01:14 <aristid> mauke: i bet that article was written by trolls anyways :P
07:01:24 <aristid> (the conservapedia one)
07:01:28 <sopvop> >(display "hello world\n")
07:01:46 <LordBrain>   i never heard of conservapedia until now
07:02:28 <HairyDude> sopvop: looks more like scheme than haskell
07:02:44 <barrucadu> LordBrain: Consider yourself lucky for avoiding it this long
07:03:04 <LordBrain> Is it real, or a sort of mock site like the onion?
07:03:09 * sopvop fears searching "conservadeia" for "gay" or "atheism"
07:03:14 <ehamberg> > let display = putStr in (display "hello world\n") -- :)
07:03:16 <lambdabot>   <IO ()>
07:03:34 <mauke> LordBrain: somewhere in between
07:03:51 <mauke> LordBrain: the guy who runs it is for real, but he's also crazy
07:04:03 <merijn> mauke: What's NSFW about the ED page?
07:04:06 <mauke> and some of the moderators may or may not be trolls
07:04:34 <mauke> merijn: ED is NSFW in general and it used to have porn ads (I don't see ads so I can't really tell)
07:04:58 <donri> http://www.conservapedia.com/Homosexuality is a must read by any citizen!
07:05:17 <aristid> donri: also, http://www.conservapedia.com/Evolution
07:05:20 <barrucadu> donri: Try the atheism and bestiality page :P
07:06:52 <otters> conservapedia is hilarious
07:06:58 <otters> well, kind of
07:07:02 <otters> it's not executed very well
07:07:26 <mauke> it's not meant to be funny
07:07:32 <otters> really?
07:07:38 <Adeon> conservapedia is serious
07:07:44 <otters> you're kidding
07:07:50 <mauke> the owner of conservapedia is 100$ serious
07:08:14 <aristid> only 100$?
07:08:32 <LordBrain> lol
07:08:34 <donri> http://uncyclopedia.wikia.com/wiki/Java
07:08:35 <wagle> sounds about right
07:09:34 <sopvop> I wonder why coservapedia has twice as long article about homosexuals and three times as long about atheism than Christianity.
07:10:40 <olsner> otters: it's a very good example of Poe's law, I think
07:11:27 * Eduard_Munteanu doesn't get why it matters whether homosexuality is a choice.
07:11:52 <Eduard_Munteanu> "Oh, if it's a choice, we can force our viewpoint on you" or something like that?
07:12:14 <confusing> Eduard_Munteanu: if it's a choice, then if you're harassed and yelled at for long enough, you'll change your mind
07:12:14 <olsner> but I think it's too big to be all parody: I don't think anyone would bother creating that good a parody ... some articles might be though, if it's a good enough parody to pass their moderators
07:12:31 <DarkUnicorn> why does "(+ 2 3)" me an "No instance for (Num (a1 -> a0))"-Error?
07:12:45 <quicksilver> because that's not haskell syntax
07:12:52 <merijn> DarkUnicorn: Because that's illegal haskell?
07:12:56 <mauke> DarkUnicorn: because you're trying to call 2 with 3
07:12:59 <quicksilver> although if you want to understand that exact error, more explanation will be required
07:12:59 <merijn> > ((+) 2 3) -- this works
07:13:00 <scooty-puff> is there anything for semigroupoids comparable to semigroups' Option - something that turns a Semigroupoid into a Category by adding an Id?
07:13:00 <lambdabot>   5
07:13:01 <sopvop> > ((+) 2 3)
07:13:02 <DarkUnicorn> isn't + just a function?
07:13:02 <lambdabot>   5
07:13:07 <scooty-puff> as part of semigroupoids
07:13:13 <mauke> DarkUnicorn: it is, but you're doing (+) (2 3)
07:13:18 <merijn> DarkUnicorn: Operators need to be surrounded with parenthesis to be converted to functions
07:13:19 <quicksilver> DarkUnicorn: yes, it is, but infix operators have a different syntax.
07:13:19 <DarkUnicorn> oh i see
07:13:19 <mauke> DarkUnicorn: and 2 isn't
07:13:26 <DarkUnicorn> thank you!
07:13:27 <olsner> Eduard_Munteanu: if it's a choice you can apply morals and say it's Wrong and Sinful, for example
07:14:21 <Eduard_Munteanu> I guess so.
07:14:24 <merijn> DarkUnicorn: Conversely you can turn any function into an infix operator by surrounding it with `
07:14:33 <Qtr> > (+5) 10
07:14:35 <lambdabot>   15
07:14:42 <scooty-puff> > import Data.Semigroupoid
07:14:43 <lambdabot>   <no location info>: parse error on input `import'
07:14:52 <scooty-puff> :load Data.Semigroupoid
07:14:55 <scooty-puff> bah
07:15:08 <Eduard_Munteanu> You can't do that.
07:15:16 <donri> > 10 `(+)` 5
07:15:16 <lambdabot>   <no location info>: parse error on input `('
07:15:24 <donri> not *any* function :(
07:15:45 <scooty-puff> donri: i wish you could do that.. is there anything like 5 `f 1` 6 that can be done, other than binding in a where or let?
07:15:45 <Eduard_Munteanu> I was referring to what scooty-puff was trying to do.
07:15:47 <merijn> > 1 `elem` [1..10] -- ok, any prefix function, then
07:15:48 <lambdabot>   True
07:16:11 <Qtr> > let shipSoftware = postpone . shipSoftware in shipSoftware "myapp"
07:16:13 <lambdabot>   Not in scope: `postpone'
07:16:31 <otters> @pl shipSoftware = postpone . shipSoftware
07:16:32 <lambdabot> shipSoftware = fix (postpone .)
07:16:36 <otters> heh
07:16:47 <scooty-puff> is there a way to search for all instances of a type class on hackage?
07:16:54 <Qtr> > let addmul = (+1) . (*5) in addmul 10
07:16:56 <lambdabot>   51
07:18:48 <HairyDude> scooty-puff: try Hoogle or Hayoo
07:18:59 <edwardk> preflex: xseen roconnor
07:19:00 <preflex>  roconnor was last seen on freenode/#haskell-blah 2 hours, 54 minutes and 56 seconds ago, saying: nand`: ya that's why I blame the nixos package maintainer
07:19:21 <HairyDude> or lambdabot's @instances, though I don't know how extensive that is
07:19:25 <HairyDude> @instances IsString
07:19:26 <lambdabot> Couldn't find class `IsString'. Try @instances-importing
07:19:27 <sopvop> scooty-puff: Usually instances are either with class or with type, orphaned instances are considered ugly
07:19:35 <HairyDude> @instances-importing IsString
07:19:36 <lambdabot> Couldn't find class `IsString'. Try @instances-importing
07:19:38 <HairyDude> hm
07:19:47 <HairyDude> clearly not very.
07:20:38 <HairyDude> so, cabal build -ddump-splices -ddump-to-file still dumped to stdout, and redirecting stdout to a file didn't work.
07:20:59 <sopvop> HairyDude: Maybe it dumps to stderr?
07:21:00 <c_wraith> @instance-importing Data.String IsString
07:21:01 <lambdabot> [Char]
07:21:08 <HairyDude> sopvop: I redirected stderr too
07:21:14 <c_wraith> @instance-importing Data.String Data.Text IsString
07:21:15 <lambdabot> Text, [Char]
07:21:24 <scooty-puff> sopvop: i expect it to be in the same module as the data definition, just don't know where to look - looking for a Category instance, and hayoo seems to be doing textual match only
07:21:26 <c_wraith> @instance-importing Data.String Data.Text Data.ByteString.Char8 IsString
07:21:26 <lambdabot> ByteString, Text, [Char]
07:21:27 <HairyDude> sopvop: but it should dump to a file with -ddump-to-file
07:22:14 <donri> scooty-puff: 5 `f` 1 $ 6
07:22:18 <HairyDude> ah, I think I got the --ghc-options= syntax wrong.
07:22:32 <HairyDude> ... no, it's still dumping to stdout.
07:22:45 <sopvop> scooty-puff: cabal unpack foo and grep it :)
07:23:22 <HairyDude> cabal unpack? huh, I never noticed that command before
07:23:40 <Qtr> I hate CAPTCHAS, i cant read them, does that make me a bot or an idiot?
07:24:18 <Eduard_Munteanu> Qtr: it just means computers/bots became pretty smart ;)
07:24:44 <merijn> Eduard_Munteanu: Not really, captcha's are not very human friendly
07:25:08 <Eduard_Munteanu> Well, yeah, they need to pose a significant challenge to computers, I meant.
07:25:10 <sopvop> Extra points are granted to computer participating in Turing test, if it makes you admit you are a robot.
07:25:10 <merijn> I read a paper recently discussing the problem and showing a different approach to captcha's that was more human friendly
07:25:12 * HairyDude tries putting -ddump-to-file first
07:25:25 <HairyDude> nope, still dumping to stdout
07:26:10 <edwardk> heya roconnor
07:26:16 <edwardk> been renaming things again ;)
07:35:11 <marcot> If I have a package with several binaries and some auxiliary modules, how can I make each module be built only once?
07:35:22 <hpaste> scooty-puff pasted “WrappedSemigroupoid” at http://hpaste.org/72210
07:35:37 <marcot> I thought that I could make a library for the modules, and make the binaries depend on the library.  Is there a way to do this with only one .cabal?
07:35:37 * sopvop keeps googling for haskell-bashing and wonders why people think haskell is harder than c++ or java
07:36:03 <qwandor|quassel_> hmm, how do I fold over a UArray?
07:36:10 <qwandor|quassel_> it looks like Array is Foldable but not IArray
07:37:21 <quicksilver> Array is a type but IArray is a class, no?
07:37:30 <quicksilver> classes can't be members of other classes.
07:38:07 <scooty-puff> qwandor|quassel: perhaps add an additional constraint where you are using it?
07:38:21 <scooty-puff> (IArray a, Foldable (a i)) => ...?
07:38:23 <quicksilver> anyhow, I'd just use toList or elems or whetveer it's called
07:38:39 <scooty-puff> err, don't recall the IArray typeclass well enough..
07:38:47 <scooty-puff> @info IArray
07:38:47 <lambdabot> IArray
07:38:51 <scooty-puff> woo
07:39:06 <quicksilver> elems, it's called
07:41:42 <qwandor|quassel> what I want to do is use all :: Foldable t => (a -> Bool) -> t a -> Bool on a UArray
07:42:08 <qwandor|quassel> scooty-puff:  I still get an error, "No instance for (Data.Foldable.Foldable (UArray Int))"
07:42:32 <qwandor|quassel> but surely if Array can be Foldable then UArray should also be able to be?
07:42:39 <quicksilver> qwandor|quassel: use elems.
07:43:23 <yitz> quicksilver: do you realize you have been op for several days now?
07:43:30 <quicksilver> yes.
07:43:33 <yitz> quicksilver: ok
07:43:35 <quicksilver> we've had quite a lot of spam this week
07:43:44 <yitz> aha. sorry to hear that.
07:43:59 <yitz> thanks for being on guard.
07:49:08 <scooty-puff> qwandor|quassel: it cannot because foldable has to work for any array element type
07:53:41 <applicative> qwandor|quassel: Data.Vector.Unboxed exports 12 assorted folds :)
07:54:36 <qwandor|quassel> vectors are only 1D right, though? I need a 2D array, so am trying UArray (Int, Int) Int
07:54:54 <qwandor|quassel> s/right, though/though, right/
07:55:22 <Eduard_Munteanu> You can make an nD array from a 1D one pretty straightforwardly.
07:55:44 <Eduard_Munteanu> Or rather, treat it as such.
07:55:46 <scooty-puff> if foldable was instead class Foldable e f | f -> e where ..., you could get away with it.. - maybe define an alternative Foldable', a WrappedFoldable newtype to get to that for any foldable, then define it for UArray?
07:56:10 <applicative> qwandor|quassel: ah i didn't notice about 2d
07:56:10 <scooty-puff> not convenient, and you might as well define the folds yourself i imagine
07:56:36 <qwandor|quassel> applicative: well, to be fair, I did not mention it (-:
07:56:45 <quicksilver> why not just use elems, qwandor|quassel ?
07:56:52 <qwandor|quassel> yeah, I ended up doing that
07:57:23 <quicksilver> it's not necessarily much worse than a hand-written Foldable instance
07:57:31 <scooty-puff> i wonder aif any rewrite rules anyways
07:57:35 <scooty-puff> might be the best option
07:57:39 <quicksilver> since elems will be run 'incrementally' as the fold goes along
07:57:51 <applicative> qwandor|quassel: on the other hand, repa has plenty of folds too :)
07:57:56 <quicksilver> if the list is constructed at all it's only constructed one cell at a time
07:58:00 <qwandor|quassel> yeah, I guess it is fine, just not quite as clean
07:58:12 <quicksilver> and possibly it might fold
07:58:16 <quicksilver> sorry, might fuse :)
07:58:34 <quicksilver> repa has some more advanced tricks for this kind of thing, yes.
07:59:36 <ceti331> I assumed function-overloading would work in haskell at least as in C++; but...
08:00:07 <ceti331> i'm trying to define my own functoin "print" for record ; i'm having to manually qualify it to compile & run :(
08:00:53 <ceti331> print "blahblah"   print MyRecord  <<< DOESN'T WORK      System.IO.print "blahblah"   Main.print MyRecord ...   <<<< DOES WORK
08:00:58 <ceti331> is this usual ?
08:01:05 <c_wraith> ceti331: haskell doesn't have ad-hoc function overloading
08:01:09 <ceti331> is there a better way to do that
08:01:12 <ceti331> AH. ok
08:01:15 <c_wraith> ceti331: it would interfere with type inference
08:01:23 <ceti331> i *thought* pattern matching was the same thing, evidently not
08:01:24 <monochrom> import Prelude hiding (print)
08:01:40 <monochrom> and then:
08:01:52 <monochrom> class Print a where print :: a -> IO ()
08:02:07 <monochrom> then write a lot of instances. then "print" is overloadable
08:02:24 <ceti331> ok.
08:02:40 <applicative> ceti331: you dont want to print "blahblah" you want to putStrLn it
08:02:41 <ceti331> is that maybe analogous to declaring a template then declaring specializations
08:02:59 <ceti331> <<<< sepples coder only
08:02:59 <monochrom> everything is analogous to everything. yes.
08:03:05 <raymank26> hi all. Is there a function like lookup from Data.Map using function on keys?(default lookup use compare)
08:03:44 <EvanR> > print "foo"
08:03:45 <lambdabot>   <IO ()>
08:03:56 <EvanR> > print (Just "foo")
08:03:57 <lambdabot>   <IO ()>
08:04:10 <monochrom> > print "<IO ()>"
08:04:11 <lambdabot>   <IO ()>
08:04:21 <monochrom> the only one that works :)
08:04:22 <EvanR> hax
08:04:41 <EvanR> actually that outputs "<IO ()>"
08:04:41 <applicative> no it's wrong
08:04:45 <EvanR> not <IO ()>
08:04:49 <applicative> like EvanR said
08:04:59 <monochrom> heh
08:05:12 <EvanR> putStrLn "<IO ()>"
08:05:12 <applicative> > putStrLn "<IO ()>"
08:05:13 <lambdabot>   <IO ()>
08:05:23 <ceti331> IO a   in a type signature is tagging the type as being associated with IO?
08:05:35 <merijn> ceti331: Not really
08:05:37 <ceti331> and IO () is just pure IO being returned ?
08:05:43 <applicative> it means its an action that 'returns' an a
08:05:59 <merijn> ceti331: An "IO a" is an action that can be executed, and when executed the result is an a
08:06:01 <ceti331> print :: Vector3 -> IO ()
08:06:19 <ceti331> what does that actually mean then..
08:06:35 <applicative> print is a function from vectors to actions,
08:06:45 <applicative> what action you get depends on the vector
08:06:48 <merijn> ceti331: Print is a function that takes a Vector3 and returns an action. (That action being "printing the vector")
08:07:02 <ceti331> iah ok
08:07:26 <ceti331> so when you chuck that in the 'do' block... the do block is taking this actions and doing something
08:07:33 <merijn> ceti331: You can combine many smaller actions into bigger ones, using >>= (or do notation, which is just syntactic sugar for >>=)
08:07:46 <ceti331> ok let me try >>= ...
08:07:47 <monochrom> no, chuck that under "main" or what main calls, transitively
08:07:55 <hpaste> scooty-puff pasted “Foldable UArray” at http://hpaste.org/72211
08:08:06 <yitz> ceti331: the IO action with the magical name "main" is the one that gets executed when you run your program.
08:08:07 <Qtr> > Just 5 >>= print
08:08:08 <merijn> ceti331: "do {x <- foo; bar x}" is syntactic sugar for "foo >>= \x -> bar x"
08:08:08 <applicative> it''s a convenient way of making a complex description of an action out of previously given actions
08:08:09 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
08:08:09 <lambdabot>         against inferred ...
08:08:10 <scooty-puff> qwandor|quassel: this paste could be improved
08:08:19 <Qtr> > Just 5 >>=\r -> print r
08:08:21 <lambdabot>   <no location info>: parse error on input `->'
08:08:36 <Qtr> > Just 5 >>=\r -> return $ r + 1
08:08:37 <lambdabot>   <no location info>: parse error on input `->'
08:08:44 <ceti331> SIO.print "blahblah" >>= Main.print Vector3 1 2 3    doesn't compile
08:08:49 <ceti331> but do .... does
08:09:01 <merijn> ceti331: So the do notation doesn't actually execute the foo action. Instead it combines the foo action and the bar function (which should return an action!) into a bigger action that will execute both
08:09:17 <yitz> ceti331: SIO.print "blahblah" >> Main.print Vector3 1 2 3
08:09:34 <yitz> except you need some parens there
08:09:41 <EvanR> @hoogle print
08:09:41 <lambdabot> Prelude print :: Show a => a -> IO ()
08:09:41 <lambdabot> System.IO print :: Show a => a -> IO ()
08:09:41 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
08:09:42 <Qtr> > Just 5 >>= \r -> return $ r + 1
08:09:43 <lambdabot>   Just 6
08:09:57 <ceti331> ok tried the parens..
08:10:02 <yitz> @type (>>)
08:10:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:10:03 <monochrom> why are there no parentheses around (Vector3 1 2 3)?
08:10:05 <Qtr> > Nothing >>= \r -> return $ r + 1
08:10:06 <lambdabot>   Nothing
08:10:07 <applicative> > Just 5 >>= \r -> lookup r [(5 ,"hello")]
08:10:08 <lambdabot>   Just "hello"
08:10:11 <merijn> ceti331: Your program will (eventually) consist of one big action (main), that is glued together from smaller actions, using fucntions. Running your program causes the runtime to actually execute your program
08:10:17 <yitz> monochrom: yeah that looks wrong
08:10:23 <ceti331> ok
08:10:46 <EvanR> Qtr: Just 5 >>= return . (+1)
08:10:53 <EvanR> Qtr: fmap (+1) (Just 5)
08:10:55 <applicative> ceti331: SIO.print "blahblah" >> Main.print Vector3 1 2 3
08:11:06 <ceti331> ok; i'll try. Why is it >> and not >>=
08:11:18 <yitz> ceti331: SIO.print "blahblah" >> Main.print (Vector3 1 2 3 )
08:11:20 <applicative> ceti331: you don't have a function on the right
08:11:32 <applicative> SIO.print "blahblah" >>= \x -> Main.print Vector3 1 2 3
08:11:33 <ceti331> ok that works ( i shoved parens around the first for good measure..)
08:11:43 <applicative> ^^^ ceti331 this is equivalent to the >> one
08:11:44 <ceti331> ah
08:11:53 <EvanR> x is ignored
08:11:57 <ceti331> ok its a final thing
08:12:00 <EvanR> so \_ -> Main.print...
08:12:14 <ceti331> there was me thinking haskell just had a placeholder symbol for IO passed along... its very different
08:12:25 <merijn> ceti331: An example would be: "let f = print . map toUpper in readLn >>= f"
08:12:36 <EvanR> IO is just a type constructor of kind * -> *
08:12:44 <EvanR> like Maybe
08:12:47 <ceti331> newiostate = do_someio(oldiostate, params-for-io... )    <<<< haskell doesn't work like this at all
08:12:48 <EvanR> or []
08:12:59 <hpaste> daniel_- pasted “code golf” at http://hpaste.org/72213
08:13:05 <daniel_-> anyone have any suggestion?
08:13:12 <EvanR> ceti331: well IO isnt really about state
08:13:19 <qwandor|quassel> http://hpaste.org/71817 is what I am trying to write, but it is still much slower than it should be
08:13:20 <EvanR> it just supports mutable state
08:13:30 <merijn> ceti331: Which has two parts "f", which is a function that takes a string and prints the uppercase of that string and "readLn" which is an action that reads a string. The result from combining the two using >>= is a new action that reads a String and print it in uppercase
08:13:53 <monochrom> state and I/O could be separate, you know
08:13:58 <merijn> ceti331: Actually reading the String doesn't happen until the runtime tries to run your composed bigger action
08:13:58 <ceti331> i mean i *thought* a functional language would have a variable which represents the 'state' .... and doing something that mutates just returns a new one
08:14:09 <qwandor|quassel> and oddly UArray is about 10% slower than Array
08:14:18 <ceti331> i get the fact its all 'lazy eval'
08:14:58 <EvanR> ceti331: you can do that
08:15:01 <ceti331> my (evidently naive) picture was that a symbol could represent the external state
08:15:04 <merijn> ceti331: Lazy is relatively easy. But noticing that the code you write doesn't run, but instead creates an action (which does get run, when you start the program) is more fundamental
08:15:06 <EvanR> s -> (a, s)
08:15:21 <EvanR> it cant do IO though
08:15:27 <ceti331> ah
08:15:42 <yitz> daniel_-: newPipe = (,,,) <$> newPipe <*> newPipe <*> newPipe <*> newPipe
08:15:44 <EvanR> :t runState
08:15:45 <ceti331> there was me thinking you could have a symbol represent the outside world at a specfic time
08:15:45 <lambdabot> forall s a. State s a -> s -> (a, s)
08:15:46 <merijn> ceti331: The State monad actually works like that
08:16:09 <hpaste> applicative annotated “code golf” with “code golf (annotation)” at http://hpaste.org/72213#a72214
08:16:12 <merijn> ceti331: For IO it's probably best not to think of it that way
08:16:15 <ceti331> lets see if i can just get a vector maths library print some answers first..
08:16:17 <yitz> daniel_-: or : newPipe = liftM4 (,,,) newPipe newPipe newPipe newPipe
08:16:20 <EvanR> data State s a = State {runState :: s -> (a,s)}
08:16:31 <daniel_-> (,,,,) is a function :O
08:16:33 <daniel_-> ?
08:16:45 <ceti331> well i'm getting further today as i'm actually running it now instead of just reading about it and thinking "thats weird.."
08:16:48 <barrucadu> :t (,,,,)
08:16:50 <lambdabot> forall a b c d e. a -> b -> c -> d -> e -> (a, b, c, d, e)
08:16:54 <daniel_-> lol, i love haskell!
08:17:00 <yitz> daniel_-: yes
08:17:47 <ceti331> if i can get as far as writing something in haskell in less time than familiar c++...
08:17:56 <ceti331> then i'll be pleased
08:18:00 <yitz> daniel_-: it could be liftA4 instead of liftM4 theoretically, but Control.Applicative doesn't go up that high, whereas Control.Monad does.
08:18:26 <ceti331> what sort of things do you guys actually write in haskell...
08:18:30 <quicksilver> daniel_-: yitz : (\[a,b,c,d] -> (a,b,c,d)) <$> replicateM4 newPipe
08:18:31 <yitz> ceti331: great that's an important step
08:18:32 <EvanR> > (,) 4 'a'
08:18:33 <lambdabot>   (4,'a')
08:18:48 <quicksilver> saves the repetition of lots of newPipes, perhaps.
08:19:15 <ceti331> <lambdabot> forall s a. State s a -> s -> (a, s)  <<<<< is that a tupple at the end ?
08:19:20 <merijn> ceti331: Right now, a simulator for distributed reference counting behaviour and language runtime for a parallel language.
08:19:23 <EvanR> ceti331: writing faster than in c++ will probably manifest itself first by you not having to back and fix random inexplicable segfaults
08:19:32 <daniel_-> i ended up using liftM4 (,,,)
08:19:34 <EvanR> assuming you can avoid segfaults in haskell ffi libs
08:19:40 <daniel_-> and i could even refactor away the makePipes function
08:19:51 <EvanR> ceti331: im working on a mud
08:19:53 <daniel_-> since it was easier to just put it in that one place i needed it
08:20:05 <ceti331> EvanR ... i love the ideas in haskell... i very much code c++ by writing tests for everything..
08:20:05 <merijn> EvanR: Oh! I got a question for you then!
08:20:16 <ceti331> i like to see individual modules working in isolation
08:20:33 <EvanR> its hard to combine modules in c++
08:20:44 <yitz> EvanR, ceti331: having ghc point out most or all of your bugs at compile time and having the program work the first time it compiles is also a pleasant surprise
08:20:52 <merijn> EvanR: I had something similar to a mud I was designing, but I wasn't sure how to handle clients. I wanted to have one (or more) threads maintaining world state that communicate with handler threads for clients using channels
08:21:17 <merijn> EvanR: But I wasn't sure how to get the handler threads to poll both the channel to world state and the socket at the same time. How do you solve that?
08:21:41 <EvanR> merijn: i understand. what i have is better, but it can probably be improved
08:21:51 <mietek> Has anyone seen transient errors like this?
08:21:51 <mietek> pureMD5-2.1.0.3 failed during the building phase. The exception was: ExitFailure 139
08:21:59 <mietek> Another build attempt fixes it
08:22:14 <merijn> ceti331: In haskell I usually code by first writing type signatures of what I want to do (defining them as "error "not implemented"") and then later once I figure out the outline of my types and how to combine functions, only then will I start writing their implementations
08:22:20 <merijn> EvanR: What's your solution?
08:22:35 <merijn> FRP? :p
08:23:15 <EvanR> merijn: each players connection thread just needs to read the socket then execute IO actions (like sending to other sockets) and modifying world state. a different kind of thread needs to wake up periodically to execute automatic events, which can send directly to handles (not go through any outgoing handler) and modify the world directly
08:23:33 <EvanR> merijn: you can either have the world in an MVar or use acid state, im using acid state
08:23:55 <EvanR> so basically theres no dedicated world thread
08:24:11 <merijn> Right
08:24:22 <EvanR> someone in here suggested a long time ago to put every mob in his own thread, i decided to not
08:24:46 <merijn> That's what I was thinking to, but it makes it impossible to modify the world output based on the state of the client handler, that's a bit sad
08:25:34 <covi> Could not find module `Data.Numbers.Primes':
08:25:35 <Qtr> People who don't know any programming language, but have a strong quantitative background and are familiar with computers
08:25:40 <covi> Isn't this module native?
08:25:43 <Qtr> what is a strong quantitative background?
08:26:17 <merijn> Qtr: Statistics and data analysis, most likely?
08:26:31 <EvanR> merijn: no
08:27:07 <dysoco> what's the correct way to use 'mod' ?
08:27:11 <EvanR> merijn: whatever you need to externally depend on needs to be in the world state
08:27:14 <dysoco> I get "Syntax error on 'mod'"
08:27:22 <applicative> covi cabal install primes
08:27:33 <EvanR> merijn: prompt-state though can be hidden in the connection thread
08:27:35 <applicative> dysoco: backticks
08:27:40 <yitz> @hoogle Data.Numbers.Primes
08:27:40 <lambdabot> package primes
08:27:43 <geekosaur> dysoco, do you perhaps have '' where you need ``?
08:27:46 <EvanR> stuff that no one else can see and gets erased when the server crashes
08:27:54 <dysoco> nope geekosaur
08:27:59 <applicative> > 3 `mod` 2
08:28:00 <lambdabot>   1
08:28:06 <geekosaur> thrn pastebin your code
08:28:07 <dysoco> wait, how do you do that ` ?
08:28:08 <dysoco> ahh
08:28:09 <dysoco> I've '
08:28:10 <applicative> > 3 'mod' 2
08:28:11 <lambdabot>   <no location info>:
08:28:11 <lambdabot>      lexical error in string/character literal at chara...
08:28:17 <yitz> covi: so do cabal install primes first
08:28:37 <covi> applicative:
08:28:40 <covi> applicative: Could not find module `Data.Numbers.Primes':
08:28:42 <covi> yitz: ^
08:28:47 <merijn> dysoco: That's the wrong one
08:29:00 <applicative> covi its in the primes package you need to install it
08:29:02 <barrucadu> dysoco: Depends on your keyboard layout. For a UK keyboard it's to the left of 1
08:29:05 <yitz> covi: right. first install the primes package on your computer.
08:29:07 <merijn> dysoco: What kind of keyboard do you have? Backtick is left of the 1 on US/international keyboards
08:29:23 <dysoco> yes I found it, I've spanish one
08:29:31 <dysoco> I thought it was ' ' and not ` `
08:29:52 <applicative> ah, is it on the keyboard
08:29:53 <EvanR> merijn: example of stuff you dont need in the world state is like a pager buffer, prompt dialog continuation
08:30:30 <EvanR> simple line editor
08:30:44 <merijn> EvanR: Ah, yeah, but here the main difference (I guess) is that I'm not doing a MUD, but really just a multiplayer game
08:30:55 <EvanR> oh
08:30:58 <merijn> But I guess I could just move all player state to world state
08:30:59 <EvanR> well i dunno xD
08:31:03 <merijn> It's worth a try
08:31:05 <dysoco> sum [x | x <- [1..1000], x `mod` 3 == 0 or x `mod` 5 == 0]
08:31:07 <dysoco> what's the error there ?
08:31:12 <EvanR> players are definitely in the world!
08:31:15 <merijn> Anyhoo, it's weekend, time to go :p
08:31:47 <BMeph_> @type or
08:31:48 <lambdabot> [Bool] -> Bool
08:32:09 <savask> dysoco: Use || except of "or"
08:32:13 <EvanR> > or [False,False,False,True,False]
08:32:14 <lambdabot>   True
08:32:19 <covi> How do I import certain constants/functions of a modules?
08:32:29 <EvanR> > [False,False,False,True,False] < cycle True
08:32:30 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
08:32:30 <lambdabot>         against inferred typ...
08:32:41 <EvanR> > [False,False,False,True,False] < (cycle True)
08:32:42 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
08:32:42 <lambdabot>         against inferred typ...
08:32:42 <applicative> import Data.List  (foldl') <- covi
08:32:54 <dysoco> ah OK, now works
08:32:56 <dysoco> thanks!
08:33:03 <covi> applicative: thanks
08:33:03 <EvanR> > [False,False,False,True,False] < repeat True
08:33:04 <lambdabot>   True
08:33:05 <applicative> import Control.Arrow ((***)) <- covi
08:33:09 <BMeph_> dysoco: "or" and "||" (which is likely what you want) are different.
08:33:11 <EvanR> > [False,False,False,True,False] < repeat False
08:33:12 <lambdabot>   False
08:33:43 <EvanR> > [False,False,False,False,False] < repeat False
08:33:44 <lambdabot>   True
08:33:52 <dysoco> well I need to reboot, thanks for the help!
08:35:07 <savask> Is there a way to compile haskell executable statically with glibc only? So other libraries will be still dynamic.
08:35:41 * Clint squints.
08:36:12 <covi> http://hpaste.org/72215 Can someone help me with this code?
08:37:43 <applicative> covi elem n $ will work
08:37:44 <S11001001> covi: you've got two infixes next to each other; use (n `elem`) or elem n instead
08:38:11 <EvanR> > (4 `elem`) [2,3,5,7]
08:38:12 <lambdabot>   False
08:38:15 <fmap> > map (\x -> x ** x) [1..]
08:38:16 <lambdabot>   [1.0,4.0,27.0,256.0,3125.0,46656.0,823543.0,1.6777216e7,3.87420489e8,1.0e10...
08:38:22 <covi> S11001001: two infix?
08:38:23 <Qtr> what was i t i should do about haskell 98 and system when compiling? it asks for system from haskell98
08:38:25 <fmap> doesn't look like squares
08:38:35 <geekosaur> savask, while it might be possible, linking glibc statically causes a number of unfortunate problems in general (not related to Haskell) such as severely restricting the systems the resulting binary will run correctly on.  you sure you want to do that?
08:38:37 <applicative> covi, yes `elem` $
08:38:48 <covi> applicative: '$' is an infix too?
08:38:49 <EvanR> 2 ** 16
08:38:50 <S11001001> covi: iow what does (2 + * 5) mean?
08:38:50 <applicative> are both infix, so its like + *
08:38:54 <EvanR> > 2 ** 16
08:38:54 <lambdabot>   65536.0
08:39:04 <S11001001> applicative: stop reading my mind!
08:39:08 <applicative> covi yeah, it's not punctuation like parentheses
08:39:20 <covi> I see. Thanks guys!
08:39:39 <savask> geekosaur: No, then.
08:39:51 <applicative> $ is a trivial function, its low precedence is why its useful, or a typical use.
08:39:56 <covi> EvanR: No instance for (Floating Int)\
08:39:58 <geekosaur> try linking a small C program statci and note the warning message the linker gives you.
08:40:05 <covi> :t (**)
08:40:07 <lambdabot> forall a. (Floating a) => a -> a -> a
08:40:25 <hpaste> daniel_- pasted “data type design” at http://hpaste.org/72216
08:40:34 <Cale> > map (\x -> x ** 2) [1..]
08:40:35 <lambdabot>   [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0,121.0,144.0,169.0,196.0,22...
08:40:48 <covi> EvanR: So how can I do a map a (^2) to an interger list?
08:40:50 <MHD> What is that paper on LL(1) applicative parsers called?
08:41:10 <fmap> > map (^2) [1..]
08:41:12 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
08:41:13 <geekosaur> (the problem is mostly caused by NSS modules, which are dynamically loaded; if you load them statically they only are guaranteed to work properly on machines with the exact same glibc, and the library contains a check to enforce it)
08:41:19 <covi> fmap: thanks
08:41:24 <monochrom> fmap teaches you how to use map :)
08:42:20 <savask> geekosaur: Well, I compiled a small c program, and I see no warnings at all.
08:42:24 <Cale> > map (\x -> x * x) [1..]
08:42:26 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
08:42:30 <Cale> would also have worked
08:43:01 <covi> Cale: Yeah, I'm now using ^
08:43:01 <applicative> if anyone tells you that Lewis Carroll discovered 'referential transparency' give the hooded man, 300 BC "The Hooded Man: You say that you know your brother. Yet that man who just came in with his head covered is your brother and you did not know him."
08:43:16 <MHD> > map ((uncurry (*)) . (id &&& id)) [1..]
08:43:18 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
08:44:01 <confusing> if anyone says something about lewis carroll and 300 bc, mistrust his statements about referential transparency ;-)
08:44:09 <geekosaur> interesting, wonder if they chanegd that.  used to be a very verbose "static linking glibc will only work on the same version" warning
08:44:38 <applicative> confusing, I believe everything I read on haskell-cafe
08:44:42 <monochrom> perhaps the nsswitch part is not linked in at all
08:44:46 <matthiasgorgens> If I have MaybeT IO a, and I want MonadIO m => MaybeT m a,
08:44:49 <covi> http://hpaste.org/72217 Someone help with 'No instance for (Integral Bool)' error? Does not understand.
08:44:50 <matthiasgorgens> is there a better way then:
08:44:52 <savask> geekosaur: So, there is a way to link glibc statically with haskell code?
08:44:56 <hape01> MHD: That map....... does not compile?
08:44:59 <Qtr> What do I put in blah.cabal under build-deps when using System?
08:45:00 <confusing> applicative: :-D
08:45:05 <matthiasgorgens> lifted = MaybeT . liftIO . runMaybeT . original
08:45:06 <matthiasgorgens> ?
08:45:16 <confusing> qtr: probably just "base"
08:45:23 <Cale> "When I use a word, it means whatever I want it to mean, nothing more and nothing less." ?
08:45:32 <monochrom> no, base doesn't have System
08:45:35 <applicative> covi you are testing a Bool for oddness
08:45:56 <covi> applicative: ahh, so I should use two filter instead?
08:46:00 <MHD> hape01: import Control.Arrow ((&&&))
08:46:23 <Cale> covi: specialSum :: Int -> Bool, but you're applying odd to the result of it
08:46:46 <applicative> covi, i was thinking, filter odd (filter specialSum [1..])
08:46:52 <covi> Cale: I see. So I should use two 'filters'
08:46:54 <hape01> MHD: Now it does :)
08:46:58 <covi> applicative: exacty!
08:47:02 <Cale> covi: Or &&
08:47:04 <confusing> qtr: in general, just try to "cabal build". it will tell you the packages (saying they're hidden)
08:47:12 <applicative> covi: you could combine them as Cale is noting
08:47:12 <confusing> monochrom: :-o
08:47:34 <MHD> hape01: There should be a Control.BigListOfAllUsefulPointfreeCombinators
08:47:34 <applicative> filter (\x -> odd x && specialSum x)
08:47:36 <Cale> But note that the performance ought to be identical whether you combine them or not
08:47:43 <Cale> Because the compiler will do that for you anyway
08:47:54 <Cale> (provided optimisations are on)
08:48:18 <monochrom> base has System.* that split System. you have to find out what the actual code wants
08:48:26 <Cale> filter (liftM2 (&&) odd specialSum) -- if you want to be fancy
08:48:32 <Cale> :t filter (liftM2 (&&) odd specialSum)
08:48:34 <lambdabot> Not in scope: `specialSum'
08:48:38 <Cale> :t filter (liftM2 (&&) odd even)
08:48:40 <lambdabot> forall a. (Integral a) => [a] -> [a]
08:48:41 <Qtr> confusing: yes and ´then it says haskell98 which i dont want to use
08:49:29 <confusing> qtr: ah, sure, monochrom is right of course. "System" is in haskell98. System.IO and all those things are in base
08:50:16 <Cale> Qtr: You have to choose whether you're using base or haskell98, as they are mutually exclusive
08:50:24 <confusing> qtr: base can do pretty much do everything haskell98 does, and more. if you don't want to use haskell98, you can't use the module "System"
08:50:26 <Cale> (from what I understand, anyway)
08:50:45 <Qtr> what do i use instead then?
08:51:03 <monochrom> you have to find out what the actual code wants
08:51:04 <Cale> System.IO etc.
08:51:34 <Clint> is there a saner way of handling a map with ambiguous keys than Map a [b] ?
08:51:37 <Cale> various modules under System.* which are organised a bit more finely than the original System module was
08:51:59 <Cale> Clint: Map a (Set b)?
08:52:05 <MHD> What is the name of that paper on applicative LL(1) parser combinators that are well suited for being made into Arrows?
08:52:22 <Clint> Cale: hmm, thanks
08:52:43 <confusing> qtr: remove the "import System" line and the compiler will tell you all the functions that your program needs. use hoogle or hayoo to find out which module you need to import for those functions. you can of course ask in here if you get stuck :)
08:52:46 <confusing> @where hayoo
08:52:46 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
08:53:07 <covi> Cale: that code is so memory- or whatever- consuming that it crashes my computer.
08:53:23 <covi> Maybe it's because of the two infinite lists that I thought was no problem?
08:53:55 <Cale> covi: which code?
08:54:18 <Cale> wait... what?
08:54:21 <covi> Cale: http://hpaste.org/72217, this one, with odd. specialSum fixed
08:55:17 <Cale> You're taking all primes, and all numbers which are twice a square, adding them together in all possible ways, and trying to decide if n belongs to that infinite list
08:55:27 <Cale> Which will not terminate if n doesn't belong to it
08:56:16 <covi> Cale: I see. That's the problem.
08:56:37 <Cale> also, because they remain in scope, it never gets to garbage collect twiceSquare
08:56:41 <covi> So I need a better way to 'get the first odd number that satisfies this constraint'
08:56:52 <ceti331> http://www.haskell.org/haskellwiki/Performance/Overloading
08:57:03 <ceti331> ^is that true, typeclasses are 'slow' ?
08:57:05 <Cale> (because it'll never get to a prime other than 2, since there are infinitely many elements in twiceSquare)
08:57:13 <monochrom> I would say, a better way to determine that no one satisfies the constraint
08:57:25 <confusing> tangentially, am i the only one who thinks "No instance ... arising from a use of 'odd'" like in that paste would be clearer if ghc printed out the type of odd ...?
08:57:47 <covi> Cale: I'm abusing the concept of lazy evaluation :(
08:57:52 <Cale> ceti331: Typeclass constraints are identical to extra function parameters as far as performance is concerned.
08:58:12 <hpaste> scooty-puff annotated “WrappedSemigroupoid” with “What is the real difference (see unwrapSemigroupoid)? WrappedSemigroupoid (annotation)” at http://hpaste.org/72210#a72218
08:58:25 <Cale> ceti331: If you wouldn't have been worried about adding another function parameter, you don't need to worry about the cost of making something polymorphic.
08:58:31 <Cale> ceti331: Well...
08:58:41 <ceti331> can it do type inference at the level of c++ overloads (sans virtuals)
08:58:58 <Philippa> C++-style overloads mess type inference up pretty badly
08:59:00 <Cale> ceti331: Maybe that's not quite true. There are also optimisations which can be performed when the compiler knows exactly which type something is.
08:59:01 <scooty-puff> nm about the post - the first requires an id, the latter requires that it match the e and x of the second argument
08:59:04 <Philippa> they're not something you want
08:59:27 <Philippa> Cale: right, you're more likely to figure out monotypes and thus evidence statically than you are ordinary function parms
08:59:35 <Cale> (and that's what the SPECIALIZE pragmas are about)
08:59:37 <Philippa> (given that this isn't a dependently-typed language or anything)
08:59:59 <covi> Cale: what are some ways that you think might imporve this program?
09:00:39 <mcstar> i dont get this
09:01:04 <mcstar> ghc compiles the code, why does it need a dictionary to determine what function to call?
09:01:16 <mcstar> why cant this be decided at compilation time?
09:01:37 <Philippa> mcstar: why does an object need a vtable?
09:01:37 <monochrom> usually, it can get rid of the dictionary
09:01:56 <Philippa> where "usually" = when it's a statically-known monomorphic call
09:02:12 <mcstar> give me an example when it cant rid of thta
09:02:19 <mcstar> get rid*
09:02:22 <Philippa> polymorphic recursion can do fun things
09:02:24 <monochrom> we are talking about optimizers. they detect some cases and can't detect some other cases
09:02:35 <Philippa> it can actually force the program to build new dictionaries as it goes
09:03:24 <Philippa> (this is a good thing! You get to infer values based on types even when those types aren't knowable at compile-time!)
09:03:35 <mcstar> i still dont understand, at the moment, my program is compiled, and therefore typechecked, all type variables are instantiated so to speak, whrere is the polimorphis?
09:03:38 <mcstar> m
09:03:38 <ceti331> typeclasses dont default to multiparaam?
09:03:47 <Philippa> mcstar: you've just made an assumption
09:03:55 <Philippa> who says all type variables are instantiated?
09:03:58 <mcstar> feel free to enlighten me
09:04:12 <mcstar> it was a natural assumption on my part
09:04:17 <mcstar> maybe it isnt correct
09:04:22 <Philippa> if Haskell worked like that, we wouldn't actually need polymorphism
09:04:36 <Philippa> the simply-typed lambda calculus (+constraints) would be enough
09:04:41 <mcstar> yes, we would, cause it makes writing code easier
09:04:45 <monochrom> actually, I have a better approach to this "discussion". show us ghc core code that keeps the dictionary. then we'll discuss.
09:04:55 <rofer> ddfsdf
09:05:06 <mcstar> rofer: i agree
09:05:15 <Philippa> monochrom: cba, sorry. Go dig up an example with polymorphic recursion and typeclasses used together, they exist
09:05:51 <rofer> mcstar: Glad to hear! (my terminal froze up)
09:06:03 <monochrom> I know.
09:06:23 <mcstar> i really thought 'something typechecks' meant 'all the type variables took a particular concrete type'
09:06:30 <Philippa> (note: one of the common cases is when you're building a module. Another is when you use a polymorphic function at enough different types that it's not worth the codesplosion to specialise it all because no cache in the world will hold it)
09:06:49 <Saizan> ?type let foo :: Show a => a -> String; foo x = show x ++ foo (x,x) in foo
09:06:50 <lambdabot> forall a. (Show a) => a -> String
09:07:00 <c_wraith> an uncommon case is polymorphic recursion.
09:07:02 <Saizan> that's a dumb one
09:07:08 <Philippa> mcstar: FCVO "type variables" and "concrete type" you're right. Unfortunately the former is meta-level variables and the latter includes object-level variables as bound by forall
09:07:16 <mcstar> fcvo?
09:07:25 <Philippa> For Certain Values Of
09:08:39 <dmwit> mcstar: http://stackoverflow.com/questions/11420126/does-haskell-have-return-type-overloading/11422333#11422333
09:08:40 <Philippa> whenever you see a forall in a type, you can think of that as "I take a type as a parameter and bind it to this type variable"
09:08:47 <c_wraith> :t let printNest :: Show a => Int -> a -> IO () ; printNest 0 x = print x ; printNest n x = printNest (n - 1) [x] in printNest
09:08:49 <Saizan> mcstar: see my foo function, if you call it with (), then you're going to need Show implementations for (), ((),()), (((),()),((),())), ... etc, i.e. an unbounded number of different types
09:08:49 <lambdabot> forall a. (Show a) => Int -> a -> IO ()
09:08:54 <c_wraith> polymorphic recursion
09:09:02 <c_wraith> No way to optimize out the dictionary passing
09:11:49 <ceti331> needing more brackets than i thought you would.. "," for seperating arguments in c/c++ is nice :)
09:12:35 <monochrom> do you know what some mathematicians write?
09:12:39 <monochrom> f(x)(y)(z)
09:14:06 <parcs`> > let (#) = id in concat # map succ [1..10] # reverse [1..10]
09:14:08 <lambdabot>   <no location info>: parse error on input `)'
09:14:12 <mcstar> ill digest, thanks guys
09:14:46 <ceti331> monochrom: thats what i started saying to my C++ head to explain haskells typesignatures ...
09:16:54 <mcstar> Saizan: that example is sort of an eye opener
09:19:09 <parcs`> ceti331: you can remove all brackets used in argument passing with a left-infix version of ($)
09:19:49 <parcs`> > let ($) = id in mappend $ map succ [1..10] $ reverse [1..10]
09:19:50 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,10,9,8,7,6,5,4,3,2,1]
09:20:19 <mcstar> i dont think any lisper has ever seen that many parentheses that i just did
09:20:51 <Cale> covi: What is your program intended to do?
09:24:10 <mcstar> Saizan: so, by providing the explicit parametric type signature of 'foo', you basically, deferred the polymorphism of 'foo' to the polymorpism of 'show', so thats why 'foo' needs access all the particular 'show' functions that the Show typeclass encompasses
09:24:53 <statusfailed> Are there any obvious, simple motivating examples for Rank2 or RankN types?
09:25:04 <statusfailed> I can't think of where i'd need them
09:25:11 <parcs`> @type runST
09:25:12 <lambdabot> forall a. (forall s. ST s a) -> a
09:25:27 <Eduard_Munteanu> @hackage multiplate
09:25:27 <lambdabot> http://hackage.haskell.org/package/multiplate
09:25:56 * Eduard_Munteanu loves the way they say "Multiplate does not require GADTs and does not require multi-parameter type classes. It only requires rank 3 polymorphism. "
09:26:10 <statusfailed> Dangit, I haven't used the ST monad
09:26:16 <mcstar> learning  more and more haskell, makes me wonder, how can some popular languages get away with their type systems...
09:26:17 <statusfailed> wait. is ST a monad? :D
09:26:25 <Eduard_Munteanu> statusfailed: sure
09:27:00 <statusfailed> woah, ST is magic :o
09:27:21 <parcs`> > let foo :: (forall a. Show a => a -> String) -> Int -> Bool -> String; foo f i b = f i ++ f b in foo ((++ "!") . show) 10 True
09:27:23 <lambdabot>   "10!True!"
09:27:35 <covi> Cale: Get the first odd number, that can be represented as a sum of a prime + a square number times two. Problem 46 in Project Euler.
09:28:08 <EvanR> mcstar: popularity is inversely proportional to general quality
09:28:19 <mcstar> head [o|o<-[3,5..], (not $ isPrime o) && (null $ [Nothing | n<-[1..(floor.sqrt.fromIntegral)o], let d = o-2*n^2, isPrime d])]
09:28:21 <EvanR> which is why haskell needs to avoid success at all costs
09:28:23 <confusing> Eduard_Munteanu: damn multiparameter thingamajigs, i hate them
09:28:44 <Cale> covi: Okay, so first of all the prime will have to be an odd prime. 2 obviously won't work, because 2 + 2(n^2) = 2 (1 + n^2)  is even
09:28:47 <merijn> EvanR: So emacs and vim are lousy editors? :p
09:28:55 <parcs`> > let foo :: (Show a => a -> String) -> Int -> Bool -> String; foo f i b = f i ++ f b in foo ((++ "!") . show) 10 True -- statusfailed
09:28:56 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:28:56 <lambdabot>         against inferred type ...
09:29:04 <covi> Cale: all primes except 2 are odd.
09:29:08 <Cale> covi: right
09:29:11 <statusfailed> parcs`: Ooh I get it
09:29:12 <statusfailed> parcs`: thanks
09:30:33 <ceti331> is there a syntax to make a numeric literal float ...
09:31:03 <EvanR> merijn: you mean emacs is an amazing editor xD
09:31:03 <mcstar> what does that mean?
09:31:25 <EvanR> in any case theres a few outliers to my law
09:31:26 <Cale> covi: You'll want to test each odd number, I think, because this gives you a bound on which primes and squares you're interested in
09:31:38 <ceti331> in my overload it seems to think (mul (Vec 0 1 0 )  2.0 ) isn't trying to make a float 2.0 as second arg - "no instance for Mul Vec3 b0 Vec3" ... i can fix it with a wrapper function "makeFloat", but is there a better way?
09:31:54 <Cale> covi: er wait
09:31:54 <EvanR> overloading is not proper haskell jargon
09:31:57 <ceti331> (mul (Vec3 0 1 0)  (makeFloat 2.0) )  <<<< works, but why do i need makeFloat
09:31:59 <mcstar> covi: look at the solution i pasted
09:32:01 <Cale> 3 + 2 * 1^2
09:32:37 <mcstar> ceti331: where is that code from?
09:32:46 <mcstar> whats the sig. of makeFloat?
09:32:46 <merijn> ceti331: Can you paste the definition of mul and the error on hpaste?
09:32:47 <ceti331> i'm writing it...
09:32:47 <covi> mcstar: can you please give me the time of your post?
09:32:47 <confusing> ceti331: i'm not sure, maybe the (Vec 0 1 0) comes out as a Vec of Ints or something? try (0 :: Float) or whatever
09:32:56 <Cale> covi: That's 5, which is an odd number, and it is equal to a prime (3) plus twice the square of 1
09:33:13 <parcs`> ceti331: 2.0 has the type Fractional a => a, not Float
09:33:22 <Cale> ceti331: What is makeFloat?
09:33:23 <mcstar> covi: ~40 lines above
09:33:46 <ceti331> Vec3 is instantiated by me to be  c++ {float vx; float vy; float vz;}
09:33:57 <merijn> parcs`: That shouldn't matter if he writes it as a literal in a place where it expects a Float
09:33:59 <ceti331> makeFloat :: float -> float
09:34:04 <ceti331> makeFloat a = a
09:34:08 <ceti331> that fixes it
09:34:11 <covi> Cale: shit... I misread the problem..
09:34:19 <parcs`> merijn: i think mul is a type class method
09:34:27 <merijn> ceti331: Can you pastebin the code + error on hpaste? That's easier to debug
09:34:30 <ceti331> yes class Mul where .... mul ....
09:34:38 <covi> Cale: the real problem "What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?"
09:34:39 <confusing> @where hpaste -- ceti331, use this
09:34:39 <lambdabot> http://hpaste.org/
09:34:52 <ceti331> ok
09:35:01 <confusing> ceti331: thanks :)
09:35:14 <ceti331> i know you can do this more elegantly with lists.. i'm trying to learn records
09:35:20 <Cale> ceti331: Why not just apply a type signature?
09:35:29 <ceti331> =?
09:35:37 <Cale> ceti331: (2 :: Float)
09:35:41 <parcs`> ceti331: ghc gets confused when trying to infer the proper type class instance to use
09:35:46 <ceti331> AHHH ok
09:35:49 <monochrom> "float" is not "Float". just to be sure
09:35:54 <ceti331> so thats like c++ casting
09:36:00 <parcs`> no
09:36:00 <mcstar> no
09:36:02 <Cale> Except that it's not casting
09:36:09 <ceti331> oh ok
09:36:12 <Cale> It's just telling the compiler the type of the expression.
09:36:24 <ceti331> well it works (2 :: Float)
09:36:26 <Cale> No conversion will be done
09:36:28 <mcstar> there is no type conversion
09:36:33 <Cale> (at runtime)
09:36:41 <mcstar> at runtime
09:36:41 <ceti331> so more like a C++ constructor ?
09:36:50 <monochrom> "works" is right
09:36:54 <covi> Cale: sorry for spending your time... mcstar kindly posts his solution, i'll go take a loo
09:36:56 <ceti331> or just 2.0f <<< ::Float does what f does..
09:36:57 <covi> k
09:37:01 <ski> mcstar : another example `data BalancedTree a = Elements a | Double (BalancedTree (a,a))' with `instance Show a => Show (BalancedTree a) where showsPrec p ta = showParen (p > 10) $ case ta of Elements a -> showString "Elements " . showsPrec 11 a; Double taa -> showString "Double " . showsPrec 11 taa'
09:37:04 <parcs`> ceti331: it's like static_cast
09:37:10 <ceti331> ok
09:37:33 <ski> ceti331 : it's called a "type ascription"
09:37:41 <monochrom> after a while you will find that you can't explain haskell in terms of c++
09:37:44 <mcstar> ski: hey! ill a look
09:37:47 <mcstar> take*
09:37:50 <quicksilver> parcs`: it's not like static_cast.
09:38:08 <rofer> Isn't it like 2f vs. just 2? (in C++)
09:38:17 <parcs`> quicksilver: it's kind of like static_cast
09:38:24 <ceti331> not sure how much time i'll put into this... dont want to stop liking C++
09:38:29 <ceti331> or stop thinking in it..
09:38:45 <confusing> rofer: yeah, seems like it pretty much
09:38:45 <quicksilver> parcs`: you can *actually* apply static cast to a variable of one type and assign the result to a vriable of a different type.
09:38:48 <ceti331> but this is fun ..
09:38:55 <monochrom> oh you can like anything you like, no problem there
09:39:15 <quicksilver> parcs`: a type annotation is a constraint on type inference, there is no "value of one type" and "value of another type"
09:39:19 <ceti331> its shocking for me to be grounded by a language :(
09:39:22 <monochrom> I like ubuntu, but I won't use ubuntu to explain haskell
09:39:42 <ski> mcstar : when you call `show :: Show a => a -> String' with `a' being `BalancedTree b', on a value of that type, it starts with the `Show b' instance, then as it recurses, it needs to compute a `Show (b,b)' instance, a `Show ((b,b),(b,b))' instance, a `Show (((b,b),(b,b)),((b,b),(b,b)))' instamce, &c. until it reaces the `Elements' case, which is when it uses that result
09:40:24 <ski> mcstar : the type `BalancedTree a' is a binary tree that is perfectly balanced : it contains exactly `2 ^ n' elements of type `a', for some natural number `n'
09:40:32 <ski> mcstar : consider the following expressions :
09:40:37 <monochrom> I think you're too used to the comfort zone "every language is like every other, just change syntax"
09:40:45 <ski>   Elements 0 :: BalancedTree Integer
09:40:55 <ski>   Elements (0,1) :: BalancedTree (Integer,Integer)
09:41:05 <ski>   Double (Elements (0,1)) :: BalancedTree Integer
09:41:21 <ski>   Elements ((0,1),(2,3)) :: BalancedTree ((Integer,Integer),(Integer,Integer))
09:41:32 <ski>   Double (Elements ((0,1),(2,3))) :: BalancedTree (Integer,Integer)
09:41:39 <ski>   Double (Double (Elements ((0,1),(2,3))() :: BalancedTree Integer
09:41:43 <mcstar> :)
09:41:45 <mcstar> ok, i get it
09:41:51 <ski> fine :)
09:42:14 <caolanm> I've just started playing with haskell, and I'm finding the types a little confusing when using / or sqrt with an Int
09:42:18 <mcstar> ski: 'it needs to compute a `Show (b,b)' instance'
09:42:25 <ski> (s/\)\(\)/\)\)\)/)
09:42:34 <caolanm> I realise it's going to try and give me back a floating number
09:42:36 <mcstar> ski: thats interesting, so it will generate that 'show' function at runtime?
09:42:36 <confusing> @type id -- quicksilver: seems like a value of one type
09:42:37 <mauke> caolanm: that's easy, you can't use / or sqrt with Ints
09:42:38 <lambdabot> forall a. a -> a
09:42:42 <caolanm> but I'm just going to floor it
09:42:43 <confusing> @type id :: (String -> String) -- value of another type
09:42:45 <lambdabot> String -> String
09:42:46 <ski> mcstar : yes, and it can't know how many times it needs to "double" that, without knowing the depth of the tree
09:42:50 <ski> mcstar : yes
09:42:54 <caolanm> mauke: so how do I convert, I guess
09:42:57 <monochrom> not just give you a floating number, but also want a floating number from you
09:43:00 <mcstar> ski: very interesting, thanks
09:43:09 <monochrom> @quote monochrom fromIntegral
09:43:09 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
09:43:21 <mauke> caolanm: first off, are you talking about / or sqrt?
09:43:35 <caolanm> mauke: let's say sqrt
09:43:38 <ski> mcstar : now, you can make something similar, which is like a list of balanced trees, where the first tree has one element, the next two, the next four, the next eight, &c. doubling the number of elements each time
09:43:51 <caolanm> mauke: I want to convert it from Int to whatever that accepts, then back to an Int with floor
09:43:53 <mauke> caolanm: then what monochrom said
09:43:57 <caolanm> fromIntegral?
09:44:09 <ski> mcstar : then, if you replace those trees with `Maybe' trees, you can suddely express *any* number of elements, in a nice way :)
09:44:50 <covi> mcstar: wow, your solution is quick!
09:45:01 <mcstar> :)
09:45:13 <ski> mcstar : this is related to representing the number of elements as binary numeral : each `0' digit corresponds to a `Nothing' in the list, and each `1' digit corresponds to a `Just tree', where `tree' has `2 ^ i' elements, with `i' being the index in the list
09:45:50 <ski> mcstar : iirc, the book "Purely Functional Data Structures" by Chris Okasaki mentions this idea, and how to exploit it to get efficient data structures
09:46:39 <monochrom> yikes
09:46:54 <monochrom> yes, it mentions polymorphic recursion, I now recall
09:46:54 <mcstar> ski: storing a tree in a list, wo nesting lists?
09:46:55 <ceti331> ew
09:47:12 <mcstar> yeah, well, it can be done alright
09:47:16 <mcstar> but why would you?
09:47:38 <mcstar> you lose fast lookup
09:47:40 <quicksilver> confusing: it may seem so, but it is not ;)
09:47:50 <mcstar> or maybe i dont see something
09:47:51 <monochrom> it says something like "ML doesn't have polymorphic recursion, so we have to do it a less type-safe way" haha
09:47:51 <caolanm> mauke: monochrom: thanks btw :)
09:47:55 <quicksilver> confusing: well, maybe that's unclear.
09:48:00 <ski> mcstar : i don't recall whether it statically makes sure that the `i'th tree (if present) has `2 ^ i' elements, but the point with polymorphic recursion is that it *is* possible to make sure of that, so that anything else would be a type error
09:48:32 <ski> monochrom : yeah, but it has Haskell code in the appendix -- i don't recall what they do in that one
09:48:33 <quicksilver> confusing: but what you can't do is this: let generic_id = id; string_id = (generic_id :: String -> String)
09:49:00 <mcstar> i downloaded Okasaki's dissertation, but it will be a while, until ill read it
09:49:14 <confusing> quicksilver: absolutely. (because of the DMR, right?)
09:49:16 <mcstar> i think the book is an extended version of that
09:49:36 <ski> mcstar : yep
09:49:59 <monochrom> oh it seems to have polymorphic recursive haskell code
09:50:13 <ski> that's nice :)
09:50:19 <quicksilver> confusing: no.
09:50:26 <quicksilver> confusing: because that's not what (::) does.
09:50:42 <monochrom> data BinaryList a = Zero (BinaryList (a,a)) | ...
09:50:48 <quicksilver> it does not cast an existing value to a new type.
09:51:00 <quicksilver> it put a constraint on the inference of type.
09:51:21 <ski> monochrom : is there any mention in the main text or the appendix of using polymorphic recursion to ensure the size invariant statically ?
09:51:39 <monochrom> in the main text yes
09:51:55 <quicksilver> I'm not sure I'm quite right here actually.
09:52:19 <quicksilver> certainly it's bit hard to be clear with polymorphic values because of the funny sense in which polymorphic values are not first class.
09:52:40 <quicksilver> an example where it *is* clear is : let a = 2 :: Int; let b = a :: Float;
09:52:49 <quicksilver> you can't do that. (whereas you can in C++ with static_cast)
09:53:24 <Saizan> generic_id has the same type of id there, so that line should work
09:53:39 <confusing> quicksilver: right, it doesn't create one thing (c++ style, in memory, using a constructor or whatever) and then shoehorns it into another form. but somehow it still feels to me that "a -> a" and "String -> String" are two types, though clearly they are related. so as far as i can see, i guess there's 2 types involved and 1 value
09:53:48 <Saizan> well, unless we are not generalizing lets in this context?
09:55:08 <ski> mcstar : an expression `<expr> :: <type>' can be used to "hint" to the implementation that `<expr>' ought to have type `<type>'
09:55:38 <ski> (it's not really a hint, since if the implementation doesn't agree that `<type>' is already a possible type for `<expr>', you'll get a type-error)
09:56:51 <ski> mcstar : nevertheless, you can use it sometimes to get a more restricted typing for things than otherwise (like how you *can* declare the non-so general `zip :: [a] -> [a] -> [(a,a)]' if you're declaring `zip' -- it's just that that's not the most general type)
09:57:32 <ski> mcstar : and usually, the reason you do this is to avoid some ambiguity that the implementation can't resolve, thereby telling it explicitly how it should be resolved
09:57:48 <ski> ("do this" meaning "add a type ascription")
09:59:14 <ski> > (show . read) "False"
09:59:16 <lambdabot>   "*Exception: Prelude.read: no parse
09:59:30 <ski> > (show . (read :: String -> Bool)) "False"
09:59:31 <lambdabot>   "False"
09:59:38 <ski> > (show . (read :: String -> Int)) "False"
09:59:40 <lambdabot>   "*Exception: Prelude.read: no parse
10:00:01 <ski> in the first case, it actually resolved the ambiguity by defaulting the "middle" type to `()', i think
10:00:07 <ski> > (show . read) "()"  -- checking
10:00:07 <confusing> (er, what "read" is it applying there anyway?)
10:00:09 <lambdabot>   "()"
10:00:15 <confusing> oh, you answered it :)
10:00:21 <monochrom> show (read "False")
10:00:29 <monochrom> err, nevermind
10:00:35 <ski> yeah  -- somewhere there's a `default ()' declaration in scope, i think
10:01:06 <confusing> so i guess without defaulting, "show . read" would be a compile-time error?
10:01:16 <ski> yes, an *ambiguity* error
10:01:23 <monochrom> () is a great type. it's how I can pull this off:
10:01:37 <monochrom> @check \x reverse x == x
10:01:37 <lambdabot>   Parse error at "==" (column 14)
10:01:39 <opqdonut> > [True, read . show $ False]
10:01:42 <lambdabot>   [True,False]
10:01:42 <ski> meaning that the code is possibly ok, but the implementation can't figure out which of potentially several distinct interpretations you want
10:01:45 <monochrom> @check \x -> reverse x == x
10:01:46 <lambdabot>   "OK, passed 500 tests."
10:02:19 <c_wraith> this just in: all lists are palindromes!
10:02:27 <confusing> ski: right, slightly like when you refer to "foo" while two modules are in scope both exporting a "foo"
10:02:31 <ski> confusing : so, ambiguity errors are different from (proper) type errors, which mean that some something is definitely wrong in your code
10:02:37 <ski> yes
10:03:40 <ski> confusing : the problem in the above example is that `show . read :: (Show a,Read a) => String -> String'
10:04:23 <ski> confusing : by looking at what i pass to that function, and by looking at how i use the result, it *still* can't figure out what the type `a' is supposed to be (simply because `a' isn't *mentioned* to the right of `=>' there !)
10:04:26 <mcstar> type-comprehension
10:04:30 <ski> and that's the ambiguity
10:04:45 <confusing> ski: right
10:05:04 <mcstar> every time you see the same type variable in contra and covariant position, an implicit summation over it is assumed
10:05:16 <ski> and it's a *real* ambiguity -- using different types `a' means we use different instances of `Show' and `Read', meaning that `show' and `read' will call different code re the strings
10:05:36 <ski> so picking different types will typically result in different behaviour
10:06:25 <mcstar> also, if all the instances of Show/Read behave according to specification, you can leave show.read out
10:06:37 <confusing> so, oddly, "M.foo" and "foo :: Float" are similar, in the sense they both disambiguate for ghc what code to call
10:07:11 <confusing> suppose there was only one instance of Read at all, that would still have to be a compile-time ambiguity error because of the open-world assumption
10:08:01 <ski> > (show . appEndo (mempty :: Endo Bool) . read) "False"  -- perhaps a slightly nicer way of writing the "middle" type in the pipeline there
10:08:03 <lambdabot>   "False"
10:08:14 <ski> (more symmetric at least)
10:08:30 <ceti331> ok now i'm trying do what i think is called "parametric polymorphism", much like c++ template,
10:08:45 <ceti331> lerp :: a -> a -> b -> a
10:08:45 <ceti331> lerp lo hi f = (add lo (mul f (sub hi lo)))
10:08:47 <mcstar> Endo Bool == Bool -> Bool ?
10:08:54 <mcstar> @t Endo
10:08:54 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:09:02 <ceti331> but my attempt doesn't compile;
10:09:02 <mcstar> @k Endo
10:09:03 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
10:09:07 <matthiasgorgens> @thank lambdabot
10:09:07 <lambdabot> Maybe you meant: thank you thanks
10:09:07 <ski> mcstar : yeah, `show . read' ought to be `id' for total values, imo -- so yeah :) -- it was just a simplistic example
10:09:08 <mcstar> @kind Endo
10:09:09 <lambdabot> * -> *
10:09:22 <confusing> > (show . (id :: Bool -> Bool) . read) "False" -- hurr hurr
10:09:24 <lambdabot>   "False"
10:09:37 <Eduard_Munteanu> ceti331: what are the types of add, mul and sub?
10:09:51 <ski> ceti331> :t add
10:09:53 <ski> ceti331> :t mul
10:09:54 <ceti331> they are instanced from a typeclass
10:09:55 <ski> ceti331> :t sub
10:10:09 <opqdonut> > (show . (id `asTypeOf` not) . read) "False"
10:10:11 <lambdabot>   "False"
10:10:12 <ceti331> can i load my program into ghci to do that..
10:10:21 <opqdonut> yes
10:10:33 <ski> opqdonut : not bad, but doesn't generalize easily :)
10:10:40 <opqdonut> ski: :P
10:11:01 <mcstar> @t asTypeOf
10:11:01 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:11:05 <monochrom> @thankyou
10:11:05 <lambdabot> you are welcome
10:11:05 <mcstar> :t asTypeOf
10:11:07 <lambdabot> forall a. a -> a -> a
10:11:27 <mcstar> why do you need 'id' there?
10:11:30 <ski> @src asTypeOf
10:11:30 <lambdabot> asTypeOf = const
10:11:47 <BMeph_> (show.not.not.read)"False"
10:11:47 <ski> mcstar : `id' passes the result from the right on to the left
10:11:50 <opqdonut> mcstar: well it's just one way to force the types of show and read to have Bool
10:11:58 <opqdonut> just like what BMeph_ did there
10:12:25 <mcstar> > (show . asTypeOf` True . read) "False"
10:12:26 <lambdabot>   <no location info>: parse error on input `.'
10:12:26 <Eduard_Munteanu> :t not
10:12:28 <lambdabot> Bool -> Bool
10:12:34 <mcstar> > (show . asTypeOf True . read) "False"
10:12:37 <lambdabot>   "True"
10:12:42 <opqdonut> heh, right
10:12:57 <mcstar> > (show . (\x -> asTypeOf x True) . read) "False"
10:12:59 <lambdabot>   "False"
10:13:07 <mcstar> ah, ok, needs a flip
10:13:08 <ski> confusing : hehe, the `id :: Bool -> Bool' is bad since i have to write the type twice, duplicating code (DRY principle and all that)
10:13:11 <mcstar> or give it to id
10:13:13 <Veinor> ski: i don't know if i agree that show . read ought to be id
10:13:18 <monochrom> @type asTypeOf
10:13:19 <lambdabot> forall a. a -> a -> a
10:13:39 <Veinor> although, maybe. hm.
10:13:40 <ski> Veinor : how about : for total, finite, values ?
10:14:14 <monochrom> he means (show . read) "False  "
10:14:50 <confusing> ski: right, but it wouldn't be too hard to have a "type F a = a -> a", right
10:14:50 <monochrom> > (show . read) "   (   )     "
10:14:52 <lambdabot>   "()"
10:14:58 <mcstar> you can eliminate unnecessary whitespace from haskell
10:15:09 <monochrom> yes, therefore not id
10:15:12 <ski> confusing : no. that's almost what the `Endo' above did
10:15:27 <ski> monochrom : good point
10:15:28 <Veinor> ski: oh, definitely
10:15:57 <ski> .. and of course we'll only include strings that a valid representations of values of the type in question
10:15:58 <mcstar> monochrom: what i mean, is that it semantically is 'id'
10:16:07 <Veinor> haha
10:16:11 <mcstar> even if it doesnt look that way
10:16:16 <mcstar> because of spaces
10:16:30 <Veinor> wouldn't it be easier to say that read . show is id
10:16:31 <ceti331> i'm trying to do haskel equiv of: template<typename T, typename F> T lerp(const T&a, const T&b, const F) { return (b-a)*f+a;}
10:16:32 <ski> but, let's add a "*normalized*" to the "valid representation" condition
10:16:36 <Eduard_Munteanu> > show . not . not . read $ "False"
10:16:38 <lambdabot>   "False"
10:16:46 <mcstar> > (show . (id `asTypeOf` not) . read) "(False)"
10:16:48 <lambdabot>   "False"
10:17:15 <ceti331> ^const F& f
10:17:17 <Veinor> ceti331: i don't speak C++ templates
10:17:34 <Veinor> @type \a b f -> (b - a) * f + a
10:17:35 <lambdabot> forall a. (Num a) => a -> a -> a -> a
10:17:37 <ski> i suppose a possibly weaker form is saying that `read . show . read' should be `read'
10:17:45 <opqdonut> ceti331: "class Scale t f where lerp :: t -> t -> f -> t"
10:17:46 <monochrom> ceti331, the scientific method demands that you show actual code not vague visions
10:18:01 <mcstar> ski: haha, weak-id
10:18:15 <ski> "weak-id" ?
10:18:22 <mcstar> yeah
10:18:32 <mcstar> what you presented
10:18:35 <applicative> monochrom: ceti331 just started learning haskell; opqdonut seems to have an idea what he means
10:19:08 <ceti331> ii was thinking it would just work with a regular functoin signature. ("parametric polymortphism").. so let me try it as a typeclass
10:19:15 <mcstar> x == x if sqrt(x ^ 2)^2==x
10:19:21 <ceti331> try a class as suggested ok
10:19:26 <mcstar> fail
10:19:28 <BMeph_> ski: Isn't (read.show) id, so that formula has to be true, right?
10:19:31 <monochrom> before starting to learn haskell, let's start learning not making people guess
10:19:42 <Eduard_Munteanu> ceti331: you don't need a typeclass for that
10:19:50 <hpaste> hape01 pasted “Maybe” at http://hpaste.org/72219
10:19:50 <Eduard_Munteanu> In fact you already have one, Num.
10:19:59 <ski> <http://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse>
10:20:14 <mcstar> ski: matrix pseudoinverse?
10:20:15 <hape01> I am sure I can write this shorter somehow without changing functionality ...  http://hpaste.org/72219   ?
10:20:22 <Veinor> actually, Num might not be the right thing
10:20:22 <ski> BMeph_ : consider an infinite binary tree
10:20:43 <Veinor> it doesn't cover the case of, for example, lerping two vectors with a Double
10:20:48 <Eduard_Munteanu> ski: how is that related?
10:20:53 <ski> mcstar : the more general form is that `g' and `f' are pseudo-inverses iff `g . f . g = g' and `f = f . g . f'
10:20:59 <Eduard_Munteanu> Oh.
10:21:03 <BMeph_> ski: Considering...
10:21:59 <applicative> > let  f2 = liftM2 (\x y -> 2*x + y) in f2 (Just 1) (Just 3)
10:22:00 <lambdabot>   Just 5
10:22:06 * Eduard_Munteanu wonders if there's a connection between pseudoinverses and adjunctions
10:22:17 <hape01> applicative: wow
10:22:20 <applicative> hape01: ^^^ I'm not sure you can get it a lot shorter
10:22:35 <hape01> applicative: :-)
10:22:38 <hape01> applicative: :)
10:23:22 <Cale> ceti331: Well, it can't just be straight parametric polymorphism, because that would entail knowing nothing about the type parameters -- in particular, if you have some values which could be *any* type at all, then you have no idea whether it makes sense to add two of them or multiply them.
10:23:24 <ski> BMeph_ : what will `show' give for `let foo n = Node n (foo (2 * n)) (foo (2 * n + 1)) in foo 1' ?
10:23:29 <applicative> > let  f2 = liftM2 ((+) . (2 *) in f2 (Just 1) (Just 3)
10:23:30 <lambdabot>   <no location info>: parse error on input `in'
10:23:40 <applicative> ^^^ hape01 a little debauched there ^^
10:23:48 <mcstar> liftA2, but it isnt shorter
10:23:54 <applicative> > let  f2 = liftM2 ((+) . (2 *)) in f2 (Just 1) (Just 3)
10:23:56 <Cale> ceti331: So a Num constraint will let you add or multiply values which have the same type.
10:23:56 <lambdabot>   Just 5
10:24:09 <ski> BMeph_ : specifically, will the `String' representation include the representation of any number other than powers of two ?
10:24:28 <Veinor> ski: that depends on the implementation of show, doesn't it
10:25:06 <mcstar> applicative: actually, because of your nick, im surprised you suggested liftM2 instead of liftA2
10:25:19 <ski> Veinor : i'm assuming `show' yields (or attempts to yield) a textual representation of a Haskell expression which, when evaluated, results in the original value
10:25:32 <Cale> ceti331: It looks however that you want a bit more than that, you want something like a vector space class. There are libraries which define a class VectorSpace which relates a type of vectors with a type of scalars.
10:25:58 <Veinor> ah
10:26:11 <ski> (also, i'm assuming that textual representation doesn't use any `let',`case' or stuff like calls to `fix', &c.)
10:26:18 <Cale> and you might get something like:  lerp :: (VectorSpace f v) => v -> v -> f -> v
10:26:29 <applicative> How come #haskell doesn't greet me with the slogan "We put the funk in function!" as it once did
10:26:31 <Cale> or: lerp :: (VectorSpace v) => v -> v -> Scalar v -> v
10:26:40 <Cale> Depending on how that class was set up.
10:27:00 <confusing> applicative: we put the moan in monad?
10:27:08 <c_wraith> What's the name of the systems where you have a base type, and then a second type for differences between values of the first?
10:27:20 <Cale> applicative: Because it's more important that people know they need to identify with NickServ :)
10:27:48 <ceti331> Cale: lerp should work on anything that supports + - * ... in my implementaion i'm using named functions;   lerp should also work for scalars Float, Int
10:28:00 <ceti331> ideally..
10:28:09 <Cale> ceti331: In that case, you'll just have:
10:28:33 <Cale> :t let lerp a b f = (b - a) * f + a in lerp
10:28:33 <applicative> Cale, I never had a problem with my nick, this is the only irc channel I ever used.
10:28:35 <lambdabot> forall a. (Num a) => a -> a -> a -> a
10:29:24 <Cale> applicative: It's just we've been getting spammers who are not smart enough to identify, and unidentified clients right now are muted.
10:29:32 <Cale> (aiui)
10:29:52 <applicative> ah i see
10:30:01 <Cale> ceti331: That's how you'd do it for anything which supports - * +
10:30:14 <Cale> ceti331: However, note that * is only defined for values of the same type.
10:30:17 <ceti331> i've just tried it as a class again.... where i've make a concrete(?) instantiatiion   instance (Lerp Vec3 Float) ... but i'd have to write that out for each one i think :(
10:30:45 * hackagebot fay 0.1.2.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
10:30:53 <ceti331> Cale: ok what i've done is used named functions 'add' 'mul' 'sub' - am trying to define interms of those. (i'll pastebin it...)
10:31:00 <Cale> ceti331: That's right. That's why people usually generalise to vector spaces first.
10:31:15 <confusing> ceti331: typeclasses in haskell are much less used than, say, classes in java. often you don't need typeclasses because regular functions are powerful enough
10:31:45 <Cale> ceti331: http://hackage.haskell.org/packages/archive/vector-space/0.8.2/doc/html/Data-VectorSpace.html
10:31:55 <Cale> So using this package...
10:32:13 <ski> Cale : hm, how would `NickServ' be related to that ?
10:32:26 <ceti331> Cale: "note * is onle defined for same type either side" - so it does not allow promotions , (*) :: Double -> Float -> Double ?
10:32:32 <Cale> :t \a b f -> (b ^-^ a) ^* f ^+^ a
10:32:34 <lambdabot> forall v. (VectorSpace v) => v -> v -> Scalar v -> v
10:32:45 <confusing> ski: you need to send a private message to nickserv that contains the password, or something
10:32:51 <Cale> ceti331: Right.
10:32:56 <ski> confusing : i know
10:32:59 <Cale> ceti331: If you want to promote, you use realToFrac
10:33:07 <ceti331> ok i dont mind that
10:33:40 * ski was wondering how that related to a server notice (i think ?) send when joining the channel
10:33:50 <ceti331> Cale: of course a C++ coder would have all sorts of overloads   Vector operator*(Vector&,Float&) {..}
10:34:11 <Cale> ceti331: Implicitly converting between numeric types is often a source of bugs, so we prefer to be explicit about where the conversions happen.
10:34:20 <ceti331> i dont mind doing it with 'add' 'mul' etc.. functions of my own
10:34:34 <ceti331> Cale: i think its ok when its promotion only
10:35:07 <ski> ceti331 : in `lerp :: a -> a -> b -> a; lerp lo hi f = (add lo (mul f (sub hi lo)))', you need to add some constraints on `a' and `b' in your type signature -- which depends on the types of `add',`sub',`mul'
10:35:08 <ceti331> Cale: but i can see the logic behind explicit promotion, i can live with that..
10:35:35 <ceti331> 'add' 'mul' etc are class Add ... where     add :: ....
10:35:45 <ski> more specifically ? :)
10:35:51 <ceti331> class Add a b c where
10:35:51 <ceti331> 	add :: a -> b -> c
10:36:14 <ski> hehe, ok
10:36:34 <ceti331> example: a "3d point" might have x y z and explicit w=1;  "3d vector" x y z, w=0
10:36:48 <ceti331> it then knows "Point3d + Vector3d = Point3d"
10:36:48 <Cale> ceti331: Note that you're probably going to run into a lot of issues with ambiguous types
10:36:53 <Cale> Involving that class
10:36:59 * confusing wonders if that "class Add" is really the right approach ...
10:37:23 <ceti331> i'm trying to acheive what in C++ i get with operator overloading
10:37:45 <ski>   lerp :: (Sub hi lo sub_hi_lo,Mul f sub_hi_lo mul_f_sub_hu_lo,Add lo mul_f_sub_hu_lo add_lo_mul_f_sub_hu_lo) => hi -> lo -> f -> add_lo_mul_f_sub_hu_lo
10:37:48 <Cale> Well, C++ forces you to write the type of everything everywhere anyway
10:37:50 <ceti331> "lerp" might be used for 3d vectors,points,  colour-vectors (just 4d vector with a different type)...
10:37:53 <ski> ceti331 : i think that's it ^
10:37:57 <ceti331> fixed point vectors floats doubles...
10:38:22 <ceti331> ski: i'll try,thanks..
10:38:24 <ski> ceti331 : however, this is ambiguous (the type variables `sub_hi_lo',`mul_f_sub_hu_lo' are not mentioned to the right of `=>')
10:38:56 <ski> confusing : probably not :)
10:39:27 <ceti331> ski: in c++ a start might be template<typename T, int D> Vector { T elem[D]; }  .... then the same maths functions can be used to encode half-precision texture coordinates, colors, etc
10:39:30 <ski> confusing : what are you trying to model with your `add :: Add a b c => a -> b -> c', &c. operations ?
10:39:53 <confusing> ski: nothing much really :) ceti331 is ;)
10:39:59 <ski> er, sorry
10:40:02 <ski> ceti331 ^
10:40:31 <ceti331> <<<< am trying to implement vector maths in haskell but i'm thinking in c++ ...
10:40:54 <ski> so `add' would be addition of two vectors, yielding another vector ?
10:40:58 <ceti331> yes
10:41:08 <ski> why not just `a -> a -> a', then ?
10:41:15 <ceti331> ah..
10:41:20 <ski> that'll remove a lot of the ambiguity
10:41:50 <ceti331> because, i've set it up to deal with 'points' and 'vectors' as seperate entitities.  point+vector=point;  point-point=vector
10:41:54 <confusing> ceti331: folks can give you more precise advice if you share the actual code (via hpaste). it doesn't matter if it's unfinished or just an idea or just a few lines, we're not as fussy as the compiler :)
10:41:58 <confusing> @where hpaste
10:41:58 <lambdabot> http://hpaste.org/
10:42:11 <ski> ceti331 : ah, so you're having affine spaces as well as vector spaces
10:42:30 <ski> ceti331 : ok, so then something like `add :: vector -> point -> point'
10:42:34 <ceti331> yes
10:42:51 <ceti331> mul :: point -> scalar -> ERROR
10:43:03 <ceti331> mul :: vector -> scalar -> vector
10:43:06 <ski> which is somewhat more generaly, but hopefully not so general that you get much ambiguity
10:43:28 <ski> well, why even include `mul :: point -> scalar -> ERROR' ?
10:43:44 <ceti331> i just typed error to indicate it wouldn''t be implmeneted
10:44:18 <ski> ceti331 : since the type signature for `add' here doesn't include `scalar', i think it would be best to put `mul' in a different class
10:44:24 <ceti331> matrix4x4 * point  ...  matrix4x4 * vector   would do differnt things too
10:45:22 <ski> you could have one class which has `point' and `vector' as parameters, and another which has `scalar' and `vector' as parameters
10:45:50 <ceti331> i've even seen people make classes for 'normalized vectors' (e.g. then a 'reflect' functoin can only take an axis known to be normalized..)
10:46:10 <ski> re also having `mul' be able to multiple a vector with a matrix, i'm not sure how easy it would be to do this
10:46:26 <ski> (possibly it works fine, i dunno)
10:46:32 <ceti331> i'm not sure i'll do mul matrix vector - i might say "transform"
10:47:03 <ski> sounds nice
10:47:05 <ceti331> similarly, 'dot :: vector -> vector -> scalar'
10:47:19 <ceti331> not mul :: vector -> vector -> scalar
10:47:38 <ski> you might want two different subtractions : `diff :: point -> point -> vector' and `sub :: point -> vector -> point'
10:48:10 <ski> `diff' computes the difference between two points (the vector that you have to add to the latter to get to the former)
10:48:11 <ceti331> perhaps i should have done this thinking in C first :) but this is teaching me a lot ..
10:48:27 <ceti331> ski: correct
10:48:40 <ski> `sub' computes the point you get if you subtract a vector from another point (which is the same as adding the negation of that vector to the point)
10:49:37 <ski> (btw, i would probably say `mul :: scalar -> vector -> vector' instead of `mul :: vector -> scalar -> vector' -- i know it doesn't matter that much, but the former seems nicer with partial application)
10:51:15 <BMeph_> Speaking of, is there a GA package?
10:51:38 <ceti331> geometric algebra? with mulltivectors?
10:51:47 <ski> ceti331 : you might do something like `class Monoid vector => Foo point vector where add :: vector -> point -> point; diff :: point -> point -> vector; sub :: point -> vector -> point'
10:52:24 <BMeph_> ceti331: Aye.
10:52:25 <ski> ceti331 : then `mempty :: Monoid vector => vector' will be the zero vector, and `mappend :: Monoid vector => vector -> vector -> vector' will be addition of two vectors
10:53:03 * ski isn't quite sure what `Foo' above ought to be called, mathematically
10:53:25 <ceti331> lets see how far i get with what i have now.
10:53:56 <edwardk> preflex: xseen roconnor
10:53:57 <preflex>  roconnor was last seen on freenode/#haskell-blah 6 hours, 29 minutes and 53 seconds ago, saying: nand`: ya that's why I blame the nixos package maintainer
10:54:12 <ski> hm .. well, i suppose we also want to be able to negate vectors (and addition is commutative), so `AdditiveGroup' might be better than `Monoid'
10:54:36 <edwardk> BMeph_: i have geometric "coalgebra" in my algebra package
10:54:43 <ceti331> can you make instantiations of class functions which take *typpes* and return *types*, for reasoning about types
10:55:09 <ceti331> eg Mul Vec3 Float = Vec3
10:55:25 <ski> ceti331 : iiuc what you mean, you can actually do that with associated types (language extension)
10:55:29 <edwardk> certi331: type families
10:55:40 <ceti331> various ways of doing it in c++..
10:55:45 <edwardk> type family Mul3 x y
10:55:48 * hackagebot shelly 0.13.1 - shell-like (systems) programming in Haskell (GregWeber)
10:55:55 <edwardk> type instance Mul3 Vec3 Float = Vec3
10:56:10 <edwardk> but there are type inference woes for the uninitiated ;)
10:56:11 <ski> ceti331 : <http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#assoc-decl>
10:56:19 <ceti331> i bet this would all be 1/4 the code if i just did vector = [....].  zip for dot product, etc..
10:56:37 <edwardk> ceti331: actualy you can make pretty decent vectorspace code once and forall
10:56:52 <edwardk> https://github.com/ekmett/physics/blob/master/Physics/Vector.hs
10:56:57 <edwardk> describes vector/scalar operations
10:57:06 <ceti331> i'm not sure if i should look just yet, its cheating
10:57:20 <mcstar> `diff :: point -> point -> vector' ?
10:57:25 <edwardk> well its a very different way of doing things. i use lenses and representability to do scary things =)
10:57:29 <mcstar> whats a 'point'?
10:57:40 <ski> edwardk : any affine space ?
10:57:44 <ceti331> point is x,y,z,1
10:57:49 <edwardk> ski: i have no affine spaces
10:57:52 <ceti331> vector is x,y,z,0
10:57:56 <edwardk> i live in a projective universe ;)
10:58:04 <mcstar> 1,0?
10:58:08 <ceti331> both are 2 elements of storage, with compile time type info saying what they can do
10:58:12 <ceti331> 3 elem^
10:58:18 <ski> mcstar : a point is a position, a vector is a position difference
10:58:43 <ceti331> i might be best off calling it "offset vector" or something.
10:58:44 <mcstar> ah, no a point actually should be a vector
10:58:51 <mcstar> and you can take differences of vectors
10:58:53 <ceti331> another way to represent it in C++ would be..
10:59:01 <ski> mcstar : vectors have a canonical zero element, not so with points (you can choose an origin point, but it's always an arbitrary choice)
10:59:12 <ski> mcstar : and this matters for programming
10:59:46 <ceti331> template< float W>   class Vector { float x,y,z; public: float getW() { return W;}; float getX() { return x;} etc...}
11:00:02 <ceti331> i.e. a 4 elem vector with compile-time constant W, not store in ram
11:00:25 <ski> mcstar : you can e.g. only rotate around a given point -- rotating around an (arbitrary) zero point isn't much sensible, unless you have already taken pains to "normalize" objects by positioning them so that the "zero point" seems sensible
11:00:31 <ceti331> ski: i dont always go this far in c/c++;  often i do it the plain C way
11:02:01 <ceti331> (have worked on platforms where C++ classes precludes the use of SIMD instructions )
11:02:15 <ski> ceti331 : what's `W' ?
11:03:17 <ski> mcstar : "a point actually should be a vector" -- disagree
11:05:09 <mcstar> i dont see how you can take the difference of two points
11:05:28 <mcstar> you can assign 2 vectors to 2 points of the manifold, and take the difference of those..
11:05:37 <mcstar> ofc i can be wrong
11:05:45 <mcstar> but thats how i see it
11:05:58 <joeyh> getAddrInfo with AI_NUMERICSERV and Nothing for the ServiceName crashes with a null pointer on OSX. (Works on Linux.) The does do say it *must* be a port number.. but this is the first time I've seen bad input segfault haskell code
11:06:02 <ceti331> ski331: compile time W component for X,Y,Z,W
11:06:26 <ceti331> i'm only introducing the name "point" for 3 floats in memory with implicit W=1
11:06:40 <mcstar> when what you have, is only local vector spaces, you cant take difference of 2 points for sure
11:07:05 <ceti331> (x0 y0 z0 1) - (x1 y1 z2 1) = (dx dy dz 0)
11:07:17 <ceti331> point3d   - point3d   = vector3d
11:07:39 <ceti331> in my curent notation.. admitedly it might be better to start with raw vector4d then say "Points and Offsets"
11:08:05 <BMeph_> "The map is not the territory."
11:09:44 <ceti331> a real position in the world would be represented by a point, whreas a velocity would be represetned by my so-called vector :)
11:10:09 <chrisdone> ahoy hoy
11:10:13 <ceti331> heh i've also seen people go all the way with C++ dimension templates, e.g. vector of metres-per second...
11:10:13 <hpaste> int80_h pasted “constraint on a type synonym” at http://hpaste.org/72222
11:10:53 <ceti331> position in space = vector of metres;  incrementing only makes sense when multipling speed*time to get distance
11:13:08 <mcstar> a position in space is represented by a contravariant vector, velocity, being the parametric derivative of a contravariant vector, is a similar vector
11:14:12 <ceti331> the 'w components' comes from rendering with projections; did seem neat though the way w=1 or 0 differentiates between offsets and positions
11:14:22 <ski> mcstar : the difference between two points is the (unique) vector which you need to add to the latter point, to get the former point
11:14:37 <ceti331> ... and it never makes sense to scale a position in space, but it does make sense to scale an offset
11:15:08 <ski> mcstar : given parallel transport, you can define a vector as an equivalence class of pairs of points, e.g.
11:15:12 <ceti331> the real reason for saying w=1 or 0 is what happens when you apply 4x4 transformation matrices
11:15:35 <ceti331> which represent co-ordinate frames
11:15:56 <Refried__> what does the IO monad get you, compared to using the Maybe monad?  Just a hint that it may behave nondeterministically?
11:16:10 <coppro> It lets you perform any sort of non-pure computation
11:16:20 <coppro> Without it, your code must be pure
11:16:31 <ceti331> its used when linking to impure C functoins?
11:16:39 <coppro> that is, its result is determined exclusively by its arguments
11:16:52 <ski> mcstar : the space of points is an affine space, <http://en.wikipedia.org/wiki/Affine_space>
11:16:55 <Refried__> do a lot of functions return IO Maybe a ?  or...
11:16:55 <coppro> getStr may have a different result when called at different times.
11:17:08 <coppro> Refried__: It can be done, but it's unusual
11:17:41 <hape01> Refried__: IO a   or   Maybe a  is more common....
11:17:51 <Refried__> *nod* thanks
11:17:54 <ski> ceti331 : "and it never makes sense to scale a position in space, but it does make sense to scale an offset" -- exactly
11:18:01 <confusing> Refried__: what the IO monad gets you is that you can use all the functions that have type "... -> IO ..."
11:18:03 <confusing> @type print
11:18:04 <lambdabot> forall a. (Show a) => a -> IO ()
11:18:11 <confusing> @type hGetLine
11:18:12 <lambdabot> Not in scope: `hGetLine'
11:18:18 <confusing> @type hGetContents
11:18:19 <lambdabot> Not in scope: `hGetContents'
11:18:27 <confusing> oh great ...
11:18:42 <confusing> well, if you import them you can use them :)
11:18:49 <hape01> @type getLine
11:18:51 <lambdabot> IO String
11:19:01 <mcstar> ski: thats bs, you cannot represent an affine point on a computer other than symbolically
11:19:01 <hape01> @type getContents
11:19:02 <lambdabot> IO String
11:19:04 <ski> Refried__ : the `IO' monad gets you a "hint" that the monadic action describes an interaction with the external world (from the POV of the process)
11:19:13 <mcstar> whenever you need coordinates, you need an origin
11:19:31 <confusing> Refried__: as for "IO Maybe a", you probably mean "IO (Maybe a)". that's not really common, but not really uncommon either
11:19:36 <ski> mcstar : in concrete implementations, we'll have to arbitrarily fix some origin and work relative that, yes
11:19:44 <mcstar> as soon as you can assign coordinates to a 'point' it becomes a 'vector'
11:19:45 <Refried__> ski: how does it combine this with error recovery?  or you do what you can within, but acknowledge that it may crash your whole program when run
11:19:51 <ceti331> probably want compile time constant zeros ... 0 0 0 1   and 0 0 0 0
11:19:59 <ski> mcstar : but the abstract picture, including which operations makes sense for points resp. vectors stays the same
11:20:20 <mcstar> ski: but i dont see any point in mentioning point when you are dealing with coordinates
11:20:25 <Refried__> confusing: are IO Maybe a and IO (Maybe a) both legal syntax and mean different things, or do you just mean that the latter is correct
11:20:26 <mcstar> you can happily take the difference of 2 vectors
11:20:41 <mcstar> anyway, this is pointless, and i disagree, so ill shut up
11:20:48 <ceti331> i think back on the ps2 sony's vector units did v0 = 0 0 0 1 as SIMD register 0 instead of usual risc style r0 = constant zero :)
11:20:49 <ski> mcstar : because you want to distinguish between the conceptually different concepts "point" and "vector"
11:20:52 <c_wraith> Refried__: both are valid syntactically, though the former is a kind error.
11:20:56 <ski> points can't be added, vectors can
11:20:59 <c_wraith> Refried__: and they definitely mean different things
11:21:26 <ceti331> mcstar: its extra 'compile time info' that qualifies what the 3 floats can be used for and where they came from
11:21:27 <ski> if you represent points in the same way as vectors, not distinguishing them, you might accidentally add two points, and nonsense will result
11:21:51 <Refried__> c_wraith: if the first one is an error, what does it mean?  oh it means I think IO takes a type of one argument and a type of 0 arguments.. ?
11:21:55 <ceti331> mcstar: even though they are the same arithmetic entity
11:22:09 <confusing> Refried__: um, for "IO Maybe a" ... well if you hide haskell's IO, define your own thing called IO which takes two type variables, then you might get into a position where you can say "IO Maybe a" :) but really, you mean "IO (Maybe a)"
11:22:12 <confusing> @type IO
11:22:14 <lambdabot> Not in scope: data constructor `IO'
11:22:14 <c_wraith> Refried__: yeah, it means you think the IO type constructor takes two arguments
11:22:23 <Refried__> confusing: *nod* thanks
11:22:26 <Refried__> c_wraith: *nod* thanks
11:22:31 <confusing> what is it with lambdabot today, nothing works ...
11:22:37 <ceti331> mcstar: the main objective here is i'm trying to learn how to move from c++ to haskel types..
11:22:51 <mcstar> ceti331: easy: forget about c++
11:22:54 <mcstar> worked for me
11:22:59 <ski> mcstar : also the rotation example : if you have vectors, you can have standard rotations around the origin -- but if you have points, you have to specify an auxilary point to rotate around
11:23:29 <ski> the types here are different, if for no other reason then for the fact that the latter operation takes an additional argument
11:23:42 <ceti331> graphics programming will always boil down to C at some point .. dealing with timing of io/network streaming and gpus and threading, and allocation of buffers arbitrating between them
11:24:01 <mcstar> ofc, you need to differentiate between vectors which belong to different bases
11:24:06 <ski> the internal choice of origin in the internal *representation* of points doesn't matter (should not matter)
11:24:10 <mcstar> sorry, origin
11:24:22 <Refried__> so suppose i have a function that tries to read an integer from a file that may not exist.  should I be thinking IO Int   or  IO (Maybe Int) ?
11:24:54 <Refried__> or is there a chapter in lyah i should read about crashing
11:25:02 <applicative> IO (Maybe Int) might be a good idea
11:25:03 <ski> mcstar : as long as they are derived as differences of points from the same affine space, the vectors will be of compatible type as well
11:25:09 <ceti331> hah there's a question, can haskell do the type of introspection c++ lacks for convinient serializing?
11:25:12 <confusing> Refried__: both are plausible. the "IO Int" variant would use exceptions
11:25:15 <ski> (because of parallel transport)
11:25:44 <Refried__> confusing / applicative: what would be more idiomatic?  or is there no right answer
11:25:55 <Refried__> no single right answer
11:26:11 <Eduard_Munteanu> ceti331: what exactly do you mean by that?
11:26:13 <ceti331> class Mesh { vector<Point3d> points; vector<Triangle> triangles; }  want to apply a 'serialize' operator to each component...
11:26:27 <Refried__> or maybe... what are some factors I would use in choosing between the two?
11:26:43 <ski> Refried__ : depends on how common you think this case of the file not existing is
11:26:57 <confusing> Refried__: another possibility would be "IO (Either String Int)", where Int is the value you get if things went well and String represents an error message if something went wrong. it's like IO (Maybe Int) but with the possibility to attach an error message
11:26:58 <ceti331> without manually saying apply(f,mes) { apply(f,mesh->points) apply(f, mesh->triangles) ) }
11:27:00 <Refried__> ski: i see
11:27:00 <parcs`> ceti331: you want to turn Mesh into a binary string?
11:27:12 <Eduard_Munteanu> ceti331: Template Haskell might be able to do it, I'm unsure.
11:27:29 <ceti331> yes serialize is the main use - other uses include building UI's
11:27:35 <ski> Refried__ : if you're opening lots of files, and expect several of them to not exist, it would possibly make sense to wrap the exception-catching code for that in a function that gave `IO (Maybe a)' or something similar
11:27:42 <parcs`> ceti331: yes it's possible
11:28:07 <parcs`> the introspection used is called Generics, if you're curious
11:28:22 <ceti331> C-sharp has the best system i've seen. c++ coders get around it by declaring a 'transfer' or 'apply' function or operator() that calls on each component
11:28:32 <Eduard_Munteanu> parcs`: I guess he doesn't want to write boilerplate for it at all
11:28:38 <ceti331> C coders do it with 'x-macros' :) #include-#define abuse
11:28:51 <orzo> how come there's so many vector packages?  I've been using tupples in my project and i'm thinking i'd like to dump that and switch to some vector math library, but i'm not sure which i want.
11:28:56 <ski> ceti331 : what does the C# system do ?
11:29:11 <Eduard_Munteanu> orzo: vectors aren't replacements for tuples
11:29:19 <orzo> i dont mean vector as in array
11:29:23 <orzo> i mean mathy vector
11:29:28 <orzo> linear algebra
11:29:28 <Refried__> ski: so everything not in IO represents everything that can't crash.  Within IO, I still have the same options as in other languages, for determining how safe to be with the operation
11:29:36 <parcs`> Eduard_Munteanu: with the 'cereal' package all you have to do is auto-derive Generic for the data type
11:29:37 <confusing> Refried__: i guess i'd go with IO Int and use exceptions. there's several things that can go wrong (file not found, file present but no permission to access, something was read from the file but it wasn't an Int, ...). the trouble with Maybe in that situation would be you get back a Nothing and you can't tell what exactly the problem was, just one Nothing for all the different error cases
11:29:40 <Eduard_Munteanu> orzo: ah
11:29:43 <ceti331> you declare a serializer object, and you can just say "apply this object to all the members of this class". i can't recal the exact syntax but square brackets are involved
11:29:51 <Refried__> confusing: *nod*
11:29:55 <Eduard_Munteanu> Ah.
11:30:09 <Eduard_Munteanu> parcs`: presumably one of the deriving extensions, no?
11:30:13 <confusing> > 7 / 0 -- Refried__: this is not in IO, but it still crashes (= throws an exception)
11:30:14 <lambdabot>   Infinity
11:30:19 <parcs`> yeah, -XDeriveGeneric
11:30:21 <Refried__> confusing: good point
11:30:29 <confusing> *grrr* lambdabot is out for me
11:30:39 <Refried__> confusing: ah, but it is still deterministic
11:30:43 <ceti331> in C/C++ i've done combination of #defines and templates to get the names across, e.g. to generate JSON
11:30:46 <Cale> 7/0 doesn't crash
11:30:53 <Cale> 7 `div` 0  does
11:30:54 <ceti331> or near enough
11:31:00 <Cale> > 7 `div` 0
11:31:02 <lambdabot>   *Exception: divide by zero
11:31:07 <confusing> Refried__: yes, it's pure and deterministic
11:31:10 <confusing> cale: thanks
11:31:14 <Eduard_Munteanu> ceti331: there you go, what parcs said
11:31:24 <parcs`> ceti331: serialization in haskell is amazingly simple and beautiful
11:31:25 <ceti331> ok
11:31:25 <Refried__> confusing: hehe I can replace every instance of 7 `div` 0 with a crash ;-)
11:31:28 <ceti331> great
11:31:30 <Cale> (Floating point types have an explicit representation of Infinity and NaN)
11:31:42 <ceti331> i probably dont know enough haskell to do it yet
11:31:47 <Cale> Refried__: Or an infinite loop!
11:32:29 <Eduard_Munteanu> ceti331: you might want to take a look at http://www.haskell.org/haskellwiki/Generics
11:32:34 <confusing> @type (/) -- cale: you're right, the problem was the Fractional there
11:32:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
11:32:59 <Refried__> thanks everyone
11:33:00 <ceti331> ok. i've probably got more to learn first but I can try and load sometthing i guess..
11:33:20 <parcs`> ceti331: check out the 'cereal' package
11:33:39 <ceti331> cerealizing? thats baaaad...
11:33:59 <Eduard_Munteanu> @faq Can Haskell be a badass?
11:34:00 <lambdabot> The answer is: Yes! Haskell can do that.
11:34:01 <ceti331> if thats what it is\ ;0
11:34:14 <Eduard_Munteanu> It is :D
11:34:46 <hpaste> ghorn pasted “how to reify [Expr a]?” at http://hpaste.org/72223
11:34:51 <ceti331> so i'll be spitting out .cornflakes ?
11:35:08 <ghorn> anyone know how to data-reify?
11:35:37 <confusing> ceti331: depending on what you want to serialize, Read and Show instances might be enough. you often get them for free by adding "deriving (Read, Show)"
11:35:45 <parcs`> ghorn: have you read the paper that introduces it?
11:35:51 * hackagebot fay 0.2.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
11:35:55 <Veinor> 14:35:25             <parcs`> ghorn: have you read the paper that introduces it?
11:35:58 <Veinor> this is haskell.txt
11:36:09 <int80_h> Chris Done it agin.
11:36:12 <parcs`> hehe
11:36:17 <ghorn> parks`: yes, a lot went over my hear
11:36:22 <ghorn> head
11:37:06 <ghorn> i don't get applicatives
11:39:49 <copumpkin>  /whois ghorn
11:39:55 <copumpkin> aha!
11:40:00 <copumpkin> 'tis Greg Horn!
11:40:03 <ghorn> heh
11:40:23 <copumpkin> don't I follow you on twitter?
11:40:24 <copumpkin> hmm
11:40:37 <copumpkin> maybe I'm confused
11:40:56 <ghorn> heh
11:41:01 * copumpkin goes back to idling
11:41:07 <ghorn> there is a famous greg horn who draws sexy superheros
11:41:18 <ghorn> i'm the other one
11:41:30 <copumpkin> hmm, don't know that one either
11:41:32 <copumpkin> must just be confused
11:41:38 <copumpkin> ignore me!
11:43:10 <parcs`> ghorn: what data type are you trying to reify?
11:43:14 <ceti331> perhaps one could write a haskell functoin to generate C/C++ headers for a haskell datastructure, and serialize to & from that via binary (haskel program to condition data for a c++ engine..)
11:44:10 <ghorn> I want to turn a list of [Expr a] into a graph plus [Int] which tell me which nodes my inputs were
11:44:33 <xvilka> hi! anyone here playing with connecting haskell power to llvm bitcode/IR/engine?
11:44:54 <xvilka> or may be some binary analysis?
11:45:23 <ghorn> I would also like to turn [[Expr a]] into a graph plus [[Int]]
11:45:42 <parcs`> ghorn:
11:47:37 <daniel_-> WTF
11:48:23 <copumpkin> daniel_-: what's up?
11:48:24 <ceti331> is it possible to do the equivalent of templated datastructures,e.g.  template<typename A,typename B > struct Pair { A first; B second }
11:48:27 <hpaste> daniel_- pasted “only matches first” at http://hpaste.org/72224
11:48:32 <daniel_-> it doest matter which i put first
11:48:41 <daniel_-> it ONLY matches if its the first one in the list
11:48:45 <copumpkin> ceti331: data Pair a b = Pair { first :: a, second :: b }
11:48:49 <copumpkin> ceti331: or just use (a, b)
11:49:00 <daniel_-> makes me sad
11:49:07 <daniel_-> and i have import Prelude hiding (lookup)
11:49:42 <copumpkin> daniel_-: don't do explicit recursion
11:49:46 <copumpkin> :t lookupBy
11:49:47 <lambdabot> Not in scope: `lookupBy'
11:49:50 <copumpkin> okay fine
11:49:53 <copumpkin> :t find
11:49:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:50:02 <copumpkin> grr
11:50:03 <copumpkin> :P
11:50:03 <geekosaur> ceti331, data Pair a b = Pair { first :: a; second :: b }
11:50:44 <confusing> daniel_-: in line 12, do you mean "xs s" or "xs q"?
11:50:48 <confusing> (just checking)
11:50:56 <daniel_-> HAH LOL
11:51:02 <daniel_-> thats why
11:51:07 <daniel_-> EHAhehAHEAHEHAHEhae
11:51:14 <daniel_-> sigh
11:51:14 <Taneb> ReaderT is very similar to Kleisli
11:51:25 <daniel_-> i refactored the function yesterday
11:51:34 <Taneb> ReaderT r m a is Kleisli m r a, I think
11:51:39 <daniel_-> and once again i sit and stare at a problem for 30 minutes getting frustrated when its so simple
11:52:38 <confusing> daniel_-: that's pretty normal :) that's why it's so important to confront others with the problem, imho. half the time they can spot it quickly
11:55:03 <confusing> @hoogle trace -- daniel_-: Debug.Trace is helpful as well
11:55:04 <lambdabot> Parse error:
11:55:04 <lambdabot>   trace -- daniel_-: Debug.Trace is helpful as well
11:55:04 <lambdabot>         ^
11:55:15 <Cale> heh
11:55:18 <confusing> oh god. module Debug.Trace, anyway
11:55:26 <IndigenousForce> http://adf.ly/9bebA
11:55:40 --- mode: ChanServ set +o Cale
11:55:41 <IndigenousForce> ^^ Is Website for my cause
11:55:44 <Veinor> 14:51:14              <Taneb> ReaderT r m a is Kleisli m r a, I think
11:55:55 * Veinor . o O (Kleisli Men's Rights Advocates?)
11:56:03 <confusing> i swear, of my last 5 lambdabot commands, exactly none worked
11:56:05 --- mode: Cale set +b *!*@gateway/web/freenode/ip.75.171.102.229
11:56:05 --- kick: IndigenousForce was kicked by Cale (IndigenousForce)
11:56:28 <Taneb> :k Kleisili
11:56:29 <lambdabot>     Not in scope: type constructor or class `Kleisili'
11:56:30 <Veinor> i wonder what that page is
11:56:37 <Taneb> @hoogle Kleisli
11:56:38 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
11:56:38 <lambdabot> Control.Arrow newtype Kleisli m a b
11:56:38 <lambdabot> package Kleislify
11:56:38 <Cale> I'm not even going to check.
11:56:43 <Cale> It's an adf.ly link
11:56:58 <Cale> which means that he gets paid for people to click it
11:57:11 <Cale> (some stupidly small amount, but something nonetheless)
11:57:41 <Cale> :k Kleisli
11:57:42 <lambdabot> (* -> *) -> * -> * -> *
11:57:43 <shachaf> adfly? Is that like medfly?
11:57:46 <Cale> hah
11:58:26 <Cale> It's popular on minecraft forums for mod authors to make some pittance from their mods using adf.ly
11:58:44 <shachaf> That sounds terrible.
11:59:07 <mauke> seems to be a human
11:59:22 <mauke> I just kicked them from #perl; they rejoined; now they're banned
12:11:34 <ceti331> geekosaur: can you then declare a type which is concerte, e.g. IntFloat = Pair Int Float perhaps (i tried that)
12:12:20 <geekosaur> how did you try it?
12:12:49 <geekosaur> you can't reuse Pair /per se/ but you can use atype synomym:  type IntFloat = Pair Int Float
12:13:11 <geekosaur> also, I very strongly suggest you not try to pretend Haskell is C++
12:17:10 <Veinor> 15:12:51          <geekosaur> also, I very strongly suggest you not try to pretend Haskell is C++
12:17:16 <Veinor> agreed
12:27:13 <Taneb> It's fun what you can do with fix
12:27:36 <Taneb> > fix (\r n -> if n == 0 then 1 else n * r (n - 1)) 10
12:27:37 <lambdabot>   3628800
12:27:41 <Taneb> > fix (\r n -> if n == 0 then 1 else n * r (n - 1)) 100
12:27:42 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
12:27:54 <Taneb> > fix (\r n -> if n == 0 then 1 else n * r (n - 1)) 73
12:27:55 <lambdabot>   447011546151268434089125713812505111007680070028290501581908009237042210406...
12:28:52 <Veinor> > fix (\f n -> if n < 2 then 1 else f (n-1) + f (n-2)) 5
12:28:53 <lambdabot>   8
12:29:30 <EvanR> (Int,Float) rather than IntFloat ?
12:32:35 <ParahSailin> :t fix
12:32:37 <lambdabot> forall a. (a -> a) -> a
12:34:23 <Veinor> fix f = let x = f x in x
12:34:38 <Veinor> (which is denotationally equivalent to fix f = f (fix f), but operationally more efficient)
12:35:56 <parcs`> > fix (ap flip) [length, (!!0)+(!!2), 10]
12:35:58 <lambdabot>   [3,13,10]
12:37:16 <EvanR> haskell is dangerous to software industry because it will make people unable to be productive in shitty systems
12:37:37 <EvanR> as if we suddenly had to do all our work in cobol
12:39:48 <danols_work> what do haskell programmers call themselves ? haskarians ?
12:39:57 <HairyDude> haskellers
12:40:13 <danols_work> singular ?
12:40:17 <Taneb> Haskeller
12:40:22 <danols_work> haskeller
12:40:27 <danols_work> thanks Haskellers
12:41:19 <yrlnry> Haskellers in the rathskeller.
12:41:22 * BMeph_ prefers "Haskellier" (has-keh-LEER)
12:41:34 <confusing> haskellite!
12:41:41 <mauke> haskellogg
12:41:45 * mcstar prefers to be called mcstar
12:41:55 <yrlnry> How about "ivory-tower poindexters"?
12:42:03 <Philippa> BMeph: not "has-keh-LEE-ay"?
12:42:04 <mauke> how about "perl programmer"?
12:42:07 <mauke> I like that name
12:42:46 <mcstar> eggheads fits also
12:43:30 <int80_h> I implemented MonadBase in Perl. True story.
12:45:09 <mizu_no_oto> Personally, I like 'Haskell hackers'.  Alliteration always works, right?
12:45:37 <Taneb> Monad men
12:45:42 <confusing> hackellers
12:45:54 <Taneb> And their Comonad Colleagues
12:47:04 <nand`> I hope you meant “Comonad comen”
12:48:07 <Taneb> The colleagues are all comen, yes
12:48:15 <Taneb> They are also colleagues
12:49:59 <mcstar> this is a co'ntrived example
12:52:20 <solrize> the comad colleagues are the dual of the league of monads?
12:52:26 <scooty-puff> i have a function that operates in some unknown monad (constrained to MonadError, Monad<...>, etc.), and wished to use it either either's EitherT - is there a reason MonadError is not defined for it (i see the instance commented out in the source)?
12:52:46 <scooty-puff> *use it either either's -> use it with either's
12:55:20 <orzo> is it possible for me to alias a constructor for some algebraic type to a new name?
12:55:27 <Veinor> what do you mean?
12:55:44 <scooty-puff> nm about my question - it looks like no other mtl type classes are included either
12:56:04 <Veinor> orzo: you can do something like myJust = Just, if that's what you're asking
12:56:05 <orzo> i mean, im using a library that has Vec2F as a constructor but i would like to rename that symbol
12:56:12 <applicative> orzo, no, you can write a function or other appropriate value, e.g.
12:56:25 <quintess`> orzo: no, you can't do that in a way that works with patterns
12:56:27 <applicative> no, its irritating
12:57:18 <applicative> the she preprocessor permits this, even for thing like Either (Either Int Char) Bool, you just rename all the 'constructors'
12:58:10 <orzo> hm
12:58:22 <applicative> and then you can pattern match.
13:19:40 <orzo> how do i exempt some symbols from the "qualified" import so that they can be refered to without qualifier
13:20:15 <mauke> orzo: another import
13:20:27 <orzo> hm, i tried that
13:20:37 <orzo> it's an operator, does that make a difference?
13:21:00 <mauke> if you tried it, what's the problem?
13:22:10 <orzo> i have an operator :. from Data.Vec.  But i imported it qualified as V.  I want to use :. instead of V.:.
13:22:22 <orzo> i added an import Data.Vec ( (:.) )
13:22:31 <orzo> and it didnt remove compiler errors on :.
13:22:32 <Cale> that should work
13:22:35 <Cale> hmm
13:22:40 <Cale> What error are you getting?
13:22:51 <nand`> :. is a type constructor isn't it?
13:23:04 <orzo>     Not in scope: data constructor `:.'
13:23:05 <orzo>     Perhaps you meant `V.:.' (imported from Data.Vec)
13:23:11 <nand`> I'm sure you'd need to import the type name for that
13:23:21 <orzo> oh
13:23:37 <nand`> like import Data.Vec ( TypeName((:.)) ) -- not sure if that works, but TypeName(..) definitely should
13:23:55 <Cale> Oh, good point, hah. I'm not sure how the syntax works exactly in that case, but I would suspect if you want the data constructors, you'd have to write import Data.Vec ((:.)(..)) or something
13:23:56 <nand`> and by ‘type constructor’ I meant ‘data constructor’
13:24:09 <Cale> If (:.) is a type constructor
13:24:14 <Cale> and not a data constructor
13:24:45 <nand`> I just mixed up the names :(
13:24:47 <Cale> (which it appears to be)
13:24:52 <Cale> No, you're right
13:24:55 <Cale> It's a type constructor
13:24:56 <nand`> brilliance from error?
13:25:09 <nand`> I-.. ahem, that's what I meant all along
13:25:27 <Cale> http://hackage.haskell.org/packages/archive/Vec/1.0.1/doc/html/Data-Vec-Base.html#t::.
13:25:41 <Cale> Holy instances Batman
13:26:03 <nand`> import Data.Vec ( (:.)((:.)) ) -- holy parentheses, batman
13:26:24 <Cale> My favourite instance listed is: (~ * (:. a (:. a v)) r, ~ * (:. (:. a (:. a v)) (:. (:. a (:. a v)) vs)) m, ~ * (:. (:. a v) (:. (:. a v) vs_)) m_, ~ * (:. (:. (:. a v) vs_) (:. x y)) mm, Map (:. a (:. a v)) (:. a v) m m_, DropConsec m_ mm, Det' (:. (:. a v) vs_) a, Map (:. (:. a v) vs_) a mm r, Map r a m r, NegateOdds r, Fold r a, Num r, Num a) => Det' (:. (:. a (:. a v)) (:. (:. a (:. a v)) vs)) a
13:26:46 <Cale> Haddock should really stop mangling the stuff it parses.
13:26:57 <nand`> haha
13:27:27 <nand`> where's the source for that?
13:27:52 <ghorn> damn
13:28:17 <Cale> In Data.Vec.LinAlg
13:28:25 <Cale> It's much more readable in the source
13:28:39 <Cale> But it's still prolog :P
13:28:44 <EmilyS> that looks like list
13:28:46 <EmilyS> lisp
13:29:13 <nand`> Cale: ah, found it
13:29:18 <Cale> It's conceptually much more like Prolog code
13:29:34 <Cale> with the results of various operations occurring as parameters to the relations :)
13:30:37 <Cale> http://hackage.haskell.org/packages/archive/Vec/1.0.1/doc/html/src/Data-Vec-LinAlg.html#Det'
13:30:42 <Cale> ^^ see here :)
13:30:44 <Clint> what's the "enclosing context" for readsPrec?
13:31:07 <Cale> Clint: what are you reading?
13:31:38 <Cale> :t readsPrec
13:31:39 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
13:31:47 <Clint> Cale: :: Int  the operator precedence of the enclosing context (a number from 0 to 11). Function application has precedence 10.
13:32:09 <Cale> Yeah, I was about to say it might refer to that Int parameter
13:32:16 <danols_work> blew me away http://www.youtube.com/watch?v=b9FagOVqxmI&feature=player_detailpage#t=2935s
13:32:21 <danols_work> quick check
13:32:26 <Clint> Cale: but i don't understand what that means
13:32:29 <Cale> which is used by some recursive instances of readsPrec to do different things depending on the precedence parsing level
13:32:37 <Cale> Basically you can use that Int for whatever the heck you want
13:32:42 <Cale> if you're writing the instance
13:33:02 <c_wraith> it is used by existing code to do things like control whether something gets parenthesized or not
13:33:15 <Cale> Imagine if you were writing a Read instance for parsing arithmetic expressions
13:33:29 <Clint> ah, great
13:33:34 <Cale> Well, that's what the corresponding Int in showsPrec does :)
13:33:37 <c_wraith> err, yes
13:33:41 <c_wraith> got that backwards
13:33:48 <c_wraith> but it's the same idea :)
13:34:08 <Clint> so i can just define readsPrec _ = if there's no recursion relevant
13:35:36 <ReinH> I'm having trouble making Piece an instance of Arbitrary for QuickCheck: https://gist.github.com/4c729d7c9cf4f5eea3e5
13:35:46 <ReinH> I suspect there's something very simple that hasn't clicked for me yet
13:36:12 * hackagebot lens 0.5 - Lenses and Lens Families (EdwardKmett)
13:38:47 <jfischoff> its hard to keep up with the evolution
13:39:00 <jfischoff> I guess that is a good thing...
13:39:06 <jfischoff> of lenses
13:39:15 <jfischoff> evolution of lenses :p
13:39:22 <ReinH> jfischoff: and their families
13:39:27 <ghorn> cleaned up my question a bit: http://stackoverflow.com/questions/11694997/how-to-reify-a-list-of-data-using-data-reify
13:40:23 <edwardk> =)
13:41:12 * hackagebot fay 0.2.1.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
13:41:37 <veldskoen> is anyone watching the olympic opening ceremony and thinking whatsgoingon?
13:41:52 <Taneb> veldskoen, I'm three minutes behind
13:41:57 <Taneb> No spoilers, please
13:42:40 <hpc> Taneb: harry potter dies
13:43:06 <veldskoen> ha ha ha
13:43:12 <EvanR> rofl
13:44:08 <ReinH> Oh yes, it's quite easy if I first define instances of Arbitrary for PieceType and PieceColor. Then it's just arbitrary = liftM2 arbitrary arbitrary
13:44:11 <ReinH> <3
13:44:20 <EvanR> vader is actually luke skywakers dad
13:44:40 <ReinH> Taneb: also it was his sled.
13:44:52 <Taneb> EvanR, I actually remember when that got spoiled for me
13:45:09 <shapr> Has anyone seen a good tutorial for writing Arbitrary instances?
13:45:36 <ReinH> shapr: I've been able to cobble a bit together from Real World Haskell and etc
13:45:38 <ReinH> but basically no
13:45:47 <qnikst> hello, I need to make a ForeighnPtr, but deallocator has type FunPtr (Ptr a -> IO (Ptr a)) instead on FunPtr (Ptr a -> IO ()), how can I deal with this situation?
13:45:55 <veldskoen> taneb: has the queen jumped out of a helicopter with james bond yet? (you'd think im joking but no...)
13:45:59 <qnikst> I can add a C wrapper but it seems ugly
13:46:08 <BMeph_> Taneb: The entire movie is a dream. :-)
13:46:54 <Taneb> veldskoen, yeah, I've just past the bit where Mary Poppins defeats Voldemort
13:47:01 <scooty-puff> what is the naming convention for monads?  i have a set of functions that makes a few requirements on the monad type, such as MonadRef, MonadError, etc., but does not actually define a monad - the main function is unify, but its in the Control.Monad.Trans.Unifier package - I assume Control.Monad.Unify might be better?
13:47:02 <shapr> ReinH: Have you written something then?
13:47:14 <Taneb> God this sounds like a very bad hallucination
13:47:33 <thetallguy2> anyone know what the new version of gettimeofday is in the new time library?
13:47:46 <parcs`> :t void -- qnikst
13:47:46 <thetallguy2> I'm lost in a twisty maze of outdated module docs
13:47:47 <lambdabot> forall t a. t -> a
13:47:53 <ReinH> shapr: no, I don't know enough. I was just able to answer my own question :)
13:47:59 <parcs`> :t Control.Monad.void
13:48:01 <lambdabot> Not in scope: `Control.Monad.void'
13:48:23 <Taneb> @hoogle void
13:48:24 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:48:24 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
13:48:24 <lambdabot> package void
13:48:30 <thetallguy2> @hoogle time
13:48:30 <lambdabot> System.Timeout module System.Timeout
13:48:30 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
13:48:30 <lambdabot> System.Event type TimeoutCallback = IO ()
13:48:41 <cods> Is there a way to write myCompose f a b = (\x -> f (a x) (b x)) (to use such as in isDigit = myCompose (&&) (>='0') (<='9') ) in a more concise/idiomatic manner? (Learning haskell, not a homework, too old for that)
13:48:43 <qnikst> parcs`, hm..
13:48:45 <thetallguy2> @hoogle timeofday
13:48:45 <lambdabot> Data.Time.LocalTime TimeOfDay :: Int -> Int -> Pico -> TimeOfDay
13:48:45 <lambdabot> Data.Time.LocalTime data TimeOfDay
13:48:45 <lambdabot> Data.Time.LocalTime timeOfDayToDayFraction :: TimeOfDay -> Rational
13:49:11 <qnikst> I've fixed foreign import, will check if it will not break in runtime
13:49:37 <EvanR> @pl (\x -> f (a x) (b x))
13:49:38 <lambdabot> liftM2 f a b
13:49:40 <mauke> @hoogle getTime
13:49:40 <lambdabot> Data.Time.LocalTime getTimeZone :: UTCTime -> IO TimeZone
13:49:42 <EvanR> cods: ^
13:50:03 <cods> impressive
13:50:09 <cods> thanks :)
13:50:10 <thetallguy2> mauke: merci!
13:50:16 <EvanR> you could have invented monads
13:50:31 <EvanR> :t liftM2
13:50:33 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:54:38 <EvanR> > liftM2 (&&) (>='0') (<='9') '4'
13:54:39 <lambdabot>   True
13:54:42 <EvanR> > liftM2 (&&) (>='0') (<='9') 'x'
13:54:43 <lambdabot>   False
13:54:48 <EvanR> > liftM2 (&&) (>='0') (<='9') 'O'
13:54:49 <lambdabot>   False
13:54:58 <EvanR> > liftM2 (&&) (>='0') (<='9') 'I'
13:54:59 <lambdabot>   False
13:55:06 <mauke> > inRange 4 (0, 9)
13:55:08 <lambdabot>   False
13:55:19 <EvanR> haha
13:56:37 <siracusa> @src inRange
13:56:37 <lambdabot> Source not found. Sorry.
13:56:44 <siracusa> @hoogle inRange
13:56:45 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
13:56:47 <cods> I've yet to figure how to use liftM2 (I tried :m Control.Monad but that's look wrong.) But don't tell me.. I'm trying to figure it myself.
13:57:49 <EvanR> import Control.Monad
13:58:15 <mauke> import Control.Monad.Instances
13:58:19 <confusing> thetallguy2: getZonedTime gives the current time. getCurrentTime gives the current UTC time (less useful). there's also stuff to get the unix time (seconds since epoch). importing Data.Time should bring all of the important stuff in scope
13:58:27 <EvanR> ah
13:58:52 <thetallguy2> confusing: thanks, getting pointed at the write module name was enough.
13:59:33 <confusing> thetallguy2: and you're right, everyone is moaning about the time handling being not so great in haskell :-/
14:00:16 <thetallguy2> confusing: I didn't say that.  i've always found it adequate.  It's just that it's all moved around since I last dealt with it.
14:03:02 <confusing> i need it seldomly to do some basic thing like "what is the time an hour from now", and each time i'm completely baffled :) good to hear that you had a different experience; i just find time one of the more confusing corners in haskell
14:03:10 <confusing> thetallguy2: ^^
14:03:51 <EvanR> Data.Time is amazing
14:04:29 <applicative> > (&&) `fmap` (>='0') `ap` (<='9') $ '4'
14:04:30 <lambdabot>   True
14:05:14 <EvanR> an hour from now is addUTCTime 3600 now
14:05:41 <Cale> People who aren't at least 90% as smart as Ashley Yakeley should not be allowed anywhere near code for dealing with times and dates.
14:06:02 * EvanR gets some leap second tables out
14:06:40 <Taneb> How far in advance do they announce leap seconds?
14:06:44 <Cale> (trust me, I'm making some nice money working on such code, and it is ridiculous)
14:07:15 <confusing> EvanR: yes, it usually turns out to be some fairly short thing, but it takes forever to figure out the solution from the haddock, at least for me
14:07:35 <confusing> cale: i think it's largely a documentation problem, not a code problem ...
14:07:35 <EvanR> first follow the types, but sometimes its not enough
14:07:59 <EvanR> confusing: im grateful 'obvious' and wrong avenues are not available
14:08:58 <cods> applicative: nice!
14:09:05 <Cale> confusing: Well, that's probably true. I concur with EvanR that Data.Time is amazing. But yes, it sometimes makes you go through a handful of initially-not-so-obvious steps to do certain things.
14:09:29 <EvanR> for one thing 'what is the time an hour from now' doesnt necessarily mean what you think it does
14:09:31 <Cale> Because many operations which make sense in everyday parlance don't actually make sense if you're being serious about dates and times.
14:09:41 <EvanR> do you mean H:M:S where H = H + 1
14:09:58 <EvanR> or 3600 seconds from now, ignoring leap seconds
14:10:30 <Cale> Hint: if you think "July 6" means something on its own, you are fired.
14:11:01 <Cale> (It could mean a whole bunch of different ranges of times depending on the timezone)
14:11:20 <EvanR> which is why we have a Calendar module
14:11:50 <Cale> (and the year and calendar, of course :)
14:12:23 <EvanR> i dont like how the date and time are combined in basically every time library
14:12:31 <EvanR> standard included ones
14:13:13 <aristid> EvanR: leap seconds are evil though
14:13:24 <EvanR> the calendar is evil
14:13:29 <EvanR> TAI ftw
14:13:34 <Cale> We had a whole bunch of bugs related to the communication between the frontend and backend of this thing splitting up times and dates, not the least of which was a parseDate function which would replace the unparsed parts of the time or date with *the current time*
14:13:35 <EvanR> barycentric
14:13:38 <aristid> EvanR: yes. leap seconds are even more evil
14:13:45 <EvanR> i dont do slippery slopes
14:13:47 <confusing> yes, i don't doubt that timekeeping is complex and subtle. i've studied it a little. i just think that the Data.Time haddock isn't particularly clear. it's not easy for the casual programmer to figure out everyday operations ("what's the time")
14:14:09 <EvanR> we currently have leap seconds so thats the cultural burden we have Data.Time for ;)
14:14:11 <k0ral> hi
14:14:28 <aristid> confusing: getCurrentTime
14:14:32 <confusing> (in fact i've made some notes already. i'm thinking of putting it on the haskell wiki)
14:14:32 <stepkut> confusing: but, "what's the time" can't even be determined until after the fact!
14:14:33 <Cale> getCurrentTime :: IO UTCTime -- bam
14:14:44 <EvanR> wham bam thank you maam
14:14:48 <confusing> aristid, cale: no not really :) getZonedTime
14:14:57 <k0ral> say I have f :: EitherT E IO () and I want to turn it into EitherT E X () with X instance of MonadIO
14:14:59 <Cale> confusing: That *also* gets the current time :)
14:15:08 <k0ral> how can I do ?
14:15:12 <aristid> confusing: you didn't say you want a zoned time. but note that timezones are evil.
14:15:20 <Cale> But usually working with UTC times is better, tbh.
14:15:21 <aristid> confusing: and not constant.
14:15:22 <EvanR> dont worry about zoned time
14:15:26 <EvanR> thats just a display thing
14:15:31 <Cale> Yeah
14:15:36 <EvanR> anyone who works with mysql should know that ;)
14:15:38 <applicative> confusing: a 'Data.Time' cookbook page for the wiki or wherever is an excellent idea.
14:15:40 <Enigmagic> confusing: yeah it was basically useless for me when i was first learning haskell, and it's useless now that i have very complex time handling needs.
14:15:42 <aristid> EvanR: unless you do calendar stuff
14:15:47 <Cale> You add the current locale's timezone for display, and work with UTC times.
14:16:45 <confusing> applicative: many thanks ... (finally someone who agrees with me ;) )
14:16:47 <Cale> Enigmagic: what was?
14:16:49 <applicative> confusing: I will read it whenever I use Data.Time, since I can never remember....
14:16:54 <EvanR> aristid: then do calendar stuff
14:16:57 <EvanR> by itself
14:16:58 <Enigmagic> Cale: the time and old-locale packages
14:17:20 <Cale> Enigmagic: interesting -- what does the time package not do which you need it to do?
14:17:32 <Enigmagic> Cale: work well with lots of timezones at the same time.
14:17:52 <Cale> hmm
14:18:23 <aristid> Enigmagic: http://hackage.haskell.org/package/timezone-series ?
14:18:30 <Enigmagic> it would be convienent to have all times everywhere stored in UTC but most of the data we deal with is in local time and decisions need to be made relative to local time. converting back and forth sucks.
14:18:53 <Cale> I'm not convinced that it really does suck to convert back and forth.
14:18:54 <EvanR> time and date in other stdlibs are 'easier' and more probably used wrongly because of that
14:18:59 <EvanR> adhoc timekeeping
14:19:21 <EvanR> Enigmagic: well you can compare ZonedTime
14:19:37 <Cale> and yeah, you can do some operations on ZonedTimes without converting
14:20:20 <stepkut> to attend 'Haskell Symposium 2012' do I need the ICFP Thursday pass ?
14:20:26 <Enigmagic> EvanR: yep, that doesn't make it good though
14:20:45 <EvanR> eh?
14:21:06 <Cale> stepkut: Whether you need the Thursday or Wednesday pass depends on your local timezone ;)
14:21:17 <Enigmagic> i just deal with UTC instead and have to do lots of conversions everywhere.
14:21:25 <stepkut> Cale: :)
14:21:33 <EvanR> Enigmagic: me too
14:21:42 <Cale> (I have no idea really)
14:21:57 <tdammers> using UTC isn't always the right thing though
14:22:40 <confusing> Enigmagic: you mean you tried to do stuff like "what is 3pm EST in CET?" i dimly remember i tried that once and thought that printing into a string, changing the zone, and parsing it back *really* can't be the way
14:23:15 <EvanR> confusing: you shouldnt need strings at all
14:23:20 <EvanR> until you show it
14:23:38 <confusing> EvanR: yes, as i said, that *really* can't be the way
14:23:52 <Cale> You may want to work mainly in TAI (count of seconds since a particular epoch) if you're doing something really serious, and only convert out to UTC/zoned time for display.
14:24:09 <Cale> but that'll need a leap second table
14:24:26 <Enigmagic> confusing: yes, i have to do a lot of stuff like that for lots of historical data. the timezone-olson/timezone-series packages seem to be the way to do it..
14:24:34 <EvanR> soon it will need a magic number because leap seconds wont be issued anymore xD
14:24:41 <gertc> who has time for this? http://stackoverflow.com/questions/11693379/haskell-no-instances-for-monadthrow
14:26:52 <Cale> For fun try "cal 9 1752" in any unixy system
14:27:44 <confusing> that might be when they changed to gregorian
14:27:45 <EvanR> lol
14:27:48 <geekosaur> exactly
14:27:50 <confusing> uh i should just try it out
14:28:11 <geekosaur> although it's slightly inaccurate since the change happened at different times in different countries
14:28:14 <confusing> cale: how about running that command on a unixy system in russia then? :-)
14:28:15 <Cale> right
14:28:17 <aristid> Cale: damn cal doesn't allow dates before the year 1
14:28:38 <Cale> geekosaur: lol, imagine if it depended on the locale!
14:28:55 <Cale> I don't think it does
14:29:21 <Cale> They just picked an arbitrary point to switch which was after most countries had changed over
14:29:24 <confusing> cale: in some way, it does. russia changed only in 1910 or something like that. their "october revolution" was really in september or november
14:29:45 <EvanR> i was born september 6 1752
14:30:28 <aristid> EvanR: that's a while ago, old man
14:30:35 <EvanR> how do you know
14:30:39 <EvanR> its not on the calendar
14:31:02 <aristid> EvanR: you might be from russia?
14:31:31 <EvanR> with love
14:32:33 <EvanR> when my enemies are enemies, doesnt make either my friend
14:34:38 <applicative> gertc:     e <- liftIO $ fbEmail $ (\(x,y) -> (C.pack x, C.pack y)) a
14:35:25 <gertc> not the liftIO again doh :)
14:35:48 <gertc> thx
14:37:59 <applicative> gertc since you are using OverloadedStrings you could skip  the prvious line and write liftIO $ fbEmail ("code", "test" but I guess in the end you want something  general
14:38:21 <applicative> liftIO $ fbEmail ("code", "test") -- rather
14:38:27 <Cale> confusing: Yes, I know, it's different in most countries -- so it would make some sense for it to depend on the Unix locale, but I don't think it does.
14:38:45 <gertc> yes general pleas my head is already reaching critical mass
14:38:52 <Cale> It might even be a bit fuzzy *inside* countries for some years
14:39:04 <Cale> with some people using one calendar, and some using the other
14:39:18 <applicative> gertc looks pretty good to me there
14:39:30 <JoeyA> Would it be fair to say something violates the Monad laws if this does not hold?  m >> k = m >>= \_ -> k
14:39:47 <c_wraith> JoeyA: no.  That's not a monad law.
14:39:57 <applicative> no it violates the definition of >>
14:40:03 <Cale> Well, it's not a monad law, but maybe it could be said to be a Monad law
14:40:14 <Cale> since the Monad class allows for that to fail
14:40:15 <EvanR> and in haskell, the default definition of >> :)
14:40:20 <gertc> just a sec doing some test again, i have a feeling i need you again :)
14:40:27 <JoeyA> Here's the perpetrator: http://hackage.haskell.org/packages/archive/shelly/latest/doc/html/Shelly-Pipe.html
14:40:36 <applicative> oh i see, we can write our own optimized  >>  .
14:41:02 <JoeyA> In this case, a >>= \_ -> b may execute b N times, while a >> b executes b only once.
14:41:24 <EvanR> > let (>:|) = (*) in 3 (>:|) 7
14:41:25 <lambdabot>   3
14:41:32 <EvanR> >:|
14:41:36 <Cale> JoeyA: wow
14:42:19 <c_wraith> that's definitely a problem
14:42:48 <Cale> Yeah, that'll probably screw up people's expectations about refactoring code.
14:43:02 <gertc> applicative do you have a stackoverflow acount so i can accept your e <- liftIO $ fbEmail $ (\(x,y) -> (C.pack x, C.pack y)) a answer ?
14:43:06 <c_wraith> send a bug report to the maintainer
14:43:11 <applicative> ha
14:43:30 <JoeyA> I think I'll just wait to see how it pans out on Reddit (without my intervention).
14:43:33 <EvanR> Monad methods return and >>= behave like methods for ListT Shelly.Sh, but >> forgets the number of the empty effects. So the last line prints "done" only once.
14:43:41 <applicative> yes gertc
14:44:07 <gertc> it works so you deserve some brouwnie point for this :)
14:45:11 <gertc> done thx
14:45:13 <applicative> still more depraved violations of category, monad, functor and monoid laws by those yesod irrationalists!
14:45:38 <S11001001> applicative: who cares about laws, we need to get stuff done
14:45:53 <c_wraith> that one isn't even a theoretical law for a class they didn't implement...
14:46:16 <EvanR> laws were made to be broken
14:46:28 <stepkut> S11001001: :)
14:47:14 <ceti331> trying it a different way now... i thinkn that means i reached a brickwall
14:47:23 <applicative> there are the  monad laws, but there is also the monad equity  ... which makes good the defect of law that is due to its generality
14:47:52 <Cale> wat
14:48:00 <JoeyA> I think it'd be better to just make a >>| operator for regular Sh
14:48:33 <Cale> JoeyA: Yeah, it's perfectly all right to have another operator with a similar type to >> which doesn't coincide with the Monad >>
14:48:46 <k0ral> I'm looking for f :: (a -> t m b) -> (a -> t m' b)
14:48:55 <Cale> ceti331: What are you trying to do?
14:48:59 <JoeyA> (>>|) :: Monad m => m [a] -> (a -> m b) -> m [b]
14:49:13 <EvanR> @hoogle (a -> t m b) -> (a -> t m' b)
14:49:13 <lambdabot> Test.QuickCheck.Monadic wp :: Monad m => m a -> (a -> PropertyM m b) -> PropertyM m b
14:49:13 <lambdabot> Test.QuickCheck.Monadic forAllM :: (Monad m, Show a) => Gen a -> (a -> PropertyM m b) -> PropertyM m b
14:49:30 <ben> Why's Cale opped? I'm feeling intimidated.
14:49:41 <Cale> ben: oh, because there was a spammer earlier
14:49:45 <ben> :)
14:49:48 <k0ral> EvanR: already tried than
14:49:51 <k0ral> that*
14:49:56 --- mode: Cale set -oo Cale quicksilver
14:50:11 <EvanR> k0ral: how would such a function work?
14:50:11 <Cale> I don't know why mjrosenb is voiced either :P
14:50:13 <k0ral> in my case m is IO and m' is a MonadIO
14:50:27 --- mode: ChanServ set +o Cale
14:50:32 --- mode: Cale set -v mjrosenb
14:50:34 --- mode: Cale set -o Cale
14:50:37 <Cale> there
14:50:42 <JoeyA> k0ral: What is t?
14:50:42 <k0ral> EvanR: I want something like liftIO, but that works on the inner monad when using transformers
14:50:54 <k0ral> t is a monadic transformer
14:50:59 <JoeyA> Look at the mapStateT/mapReaderT/etc. functions.
14:51:31 <EvanR> MonadTrans t, MonadIO m' => (a -> t IO b) -> (a -> t m' b)
14:51:35 <EvanR> ?
14:51:40 <k0ral> yes
14:51:54 <EvanR> @hoogle (MonadTrans t, MonadIO m') => (a -> t IO b) -> (a -> t m' b)
14:51:54 <lambdabot> Did you mean: (MonadTrans t, MonadIO m') => (a -> t (IO a) b) -> a -> t m' b
14:51:55 <lambdabot> Test.QuickCheck.Monadic wp :: Monad m => m a -> (a -> PropertyM m b) -> PropertyM m b
14:51:55 <lambdabot> Test.QuickCheck.Monadic forAllM :: (Monad m, Show a) => Gen a -> (a -> PropertyM m b) -> PropertyM m b
14:52:05 <JoeyA> There's also monad-control, a complicated yet practical library for lifting bracket-like computations through monad transformers.
14:52:29 <EvanR> another reason i try to avoid nested transformers
14:53:26 <zzo38> Can you get a monad from?  data M t x = M0 x | M1 (t (M t) x); join (M1 x) = M1 (x >>= lift);
14:53:27 <lambdabot> zzo38: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:53:52 <k0ral> JoeyA: map<transformer> liftIO would do it ?
14:54:14 <JoeyA> zzo38: That looks almost like a free monad transformer
14:54:31 <JoeyA> k0ral: I think
14:55:05 <zzo38> JoeyA: It is related to a free monad, but this is not a monad transformer it is the wrong kind to be a monad transformer
14:55:41 <JoeyA> Oh, so it's a free monad transformer transformer :-)
14:56:36 <EvanR> foo ++ fix ("transformer " ++)
14:56:37 <k0ral> JoeyA: it seems to be working, thank you
14:56:44 <EvanR> > "foo " ++ fix ("transformer " ++)
14:56:46 <lambdabot>   "foo transformer transformer transformer transformer transformer transforme...
14:57:03 <mauke> > "foo" ++ cycle " transformer"
14:57:04 <hpc> yo dawg, i heard you like functors, so i made a transformer of transformers of free monoids in the category of endofunctors
14:57:05 <lambdabot>   "foo transformer transformer transformer transformer transformer transforme...
14:57:09 <EvanR> fix is leeter
14:57:16 <ceti331> seems like the matching method for setting up vector maths are easier to make with the 'parametric' polymorphism,
14:57:28 <ceti331> but that looks a bit clunky to me sometimes
14:57:31 <zzo38> JoeyA: But, does it make a monad?
14:57:33 <ceti331> i must still be doing this wrong
14:58:11 <JoeyA> zzo38: I don't know.  See if you can implement fmap and return.
14:58:27 <JoeyA> (then you have all the operations needed to form a monad)
14:58:29 <zzo38> JoeyA: Those seem obvious isn't it?
14:58:54 <JoeyA> If they're obvious, then go ahead and write them and see if it compiles.
14:58:59 <zzo38> fmap f (M0 x) = M0 (f x); fmap f (M1 x) = M1 (f <$> x); return = M0;
14:59:14 <zzo38> JoeyA: I already did write them in a file, and it does compile, and I tried a few things too.
14:59:22 <JoeyA> Ah, okay.
14:59:59 <zzo38> And in addition   join (M0 x) = x;   from the monad law
15:00:15 <JoeyA> If this is for Yesod, you're done!  </troll>
15:00:50 <k0ral> JoeyA: hmmm now I have a case where t is EitherT E, and mapEitherT doesn't make it possible to change the innermost monad
15:01:04 <hpaste> scooty-puff pasted “ErrorT.. *sigh*” at http://hpaste.org/72230
15:02:19 <JoeyA> k0ral: Which EitherT package are you using?
15:02:37 <zzo38> Is there more than one EitherT package?
15:02:49 <k0ral> JoeyA: didn't know there were several ones; I'm using Control.Monad.Trans.Either
15:02:56 <scooty-puff> either package?
15:03:03 <k0ral> yes
15:03:05 <JoeyA> Two of em
15:03:11 <JoeyA> EitherT and either
15:03:18 <zzo38> They should put "EitherT" in transformers package.
15:03:19 <scooty-puff> i like the ambiguity here
15:03:25 <scooty-puff> yeah, quoting probably required
15:03:28 <JoeyA> http://hackage.haskell.org/packages/archive/either/latest/doc/html/Control-Monad-Trans-Either.html
15:03:55 <JoeyA> Yeah, that's not a very useful-looking mapEitherT function.
15:04:03 <JoeyA> Err, maybe useful
15:04:05 <zzo38> Does ErrorT do something else?
15:04:13 <JoeyA> But doesn't fit the pattern other map*T functions do.
15:04:20 <zzo38> s/else/similar/
15:05:34 <JoeyA> zzo38: Yes, but it requires that the error type be convertible to a string.
15:05:51 <zzo38> OK.
15:05:56 <JoeyA> mapErrorT :: (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
15:06:02 <JoeyA> But *that* is how you write a map*T function.
15:06:46 <k0ral> basically, map*T should make it possible to change each involved type, right ?
15:07:05 <JoeyA> Yes, that's a good thing.
15:07:16 <JoeyA> k0ral: You can implement your function by unwrapping the EitherT data constructor.
15:07:22 <JoeyA> It's trivial.
15:07:42 <JoeyA> (I think)
15:07:48 <zzo38> JoeyA: Shouldn't they just make EitherT and then define ErrorT to mean: fail = ErrorT . EitherT . return . Left
15:08:02 <k0ral> I think I can handle it, I wish it was already part of the library though
15:09:45 <JoeyA> zzo38: That would be nicer, I think.
15:10:37 <k0ral> do you confirm the type should be: mapEitherT :: Functor m, Functor n => (e -> f) -> (m a -> n b) -> EitherT e m a -> \
15:10:44 <k0ral> EitherT f n b
15:11:05 <aristid> k0ral: why not split that into multiple functions?
15:11:47 <k0ral> aristid: 1/ because it seems all map*T functions are meant to do this 2/ how would you do so ?
15:12:34 <zzo38> Perhaps they should also remove ListT which doesn't even work.
15:12:55 <JoeyA> In my control-monad-loop package, I have: foreach :: Monad m => [a] -> (a -> LoopT c () m c) -> m ()
15:12:58 <zzo38> One possible transformer of a list monad is LogicT
15:13:04 <JoeyA> Somebody sent me a patch to generalize it to any Foldable.
15:13:35 <JoeyA> Should I just replace 'foreach' with the generic version, or do you think I should make it a separate 'genericForeach' instead or something?
15:14:26 <zzo38> Well, my "prelude-generalize" makes everything generalize like that
15:14:58 <JoeyA> The issue with generalizing with type classes is that it can hurt performance.
15:15:24 <JoeyA> And even create memory leaks, if the compiler fails to optimize something important (I think ... ).
15:16:06 <JoeyA> Moreover, if one function has a generic return type, and another function accepts a generic argument, the user might get an ambiguous type.
15:16:42 <JoeyA> So I'm not terribly eager to make things as generic as possible when it introduces type class constraints.
15:16:53 <zzo38> What I used is RULES pragma
15:17:08 <JoeyA> There's also {-# SPECIALIZE #-}
15:17:36 <zzo38> I mean for example, RULES pragma to make convList = maybeToList and convList = listToMaybe
15:18:46 <zzo38> (convList converts any Foldable to any Alternative)
15:19:14 <JoeyA> How is that different from SPECIALIZE ?
15:19:48 <zzo38> Perhaps it depend what kind of compiler optimizations are being performed
15:20:05 <zzo38> If the optimization is enough then it would probably mean the same thing.
15:20:08 <startling> what shouldI use to see if a path is a file or a directory?
15:20:20 <startling> hoogle isn't giving anything promising
15:22:42 <JoeyA> startling: doesFileExist/doesDirectoryExist
15:23:44 <startling> JoeyA: ah. I was looking for isDir and/or isFile
15:24:03 <JoeyA> For more powerful attribute testing, there's System.Posix.getFileStatus and System.Win32.getFileAttributes
15:24:23 <JoeyA> My randfile package uses both.
15:24:57 <startling> I just need to see whether it's a file or directory.
15:25:12 <startling> oh ugh, I can't pattern match against an IO bool, can I
15:25:27 <JoeyA> You can do foo >>= \b -> if b then ... else ...
15:25:38 <startling> yeah
15:25:39 <zzo38> You can still use fmap to pattern match on the boolean
15:25:56 <JoeyA> Or wait till GHC 7.6, which will have lambda-case and multi-way if.
15:26:04 <startling> zzo38, ooh, fmap is a good idea
15:26:12 <nand`> JoeyA: w-w what's this about?
15:26:26 <nand`> JoeyA: where can I see the patch notes? interested in lambda-case
15:26:36 <t7> whats multiway if?
15:26:44 <JoeyA> http://www.reddit.com/r/haskell/comments/wp70x/lambdacase_and_multiway_if_added_to_ghc_head_for/
15:27:50 <JoeyA> The new syntax is summed up here: http://www.reddit.com/r/haskell/comments/wp70x/lambdacase_and_multiway_if_added_to_ghc_head_for/c5fdhdy
15:27:59 <t7> ah cool
15:28:06 * nand` feels like (if then "Haskell" else "Cafe) would be much more cleanly expressed using a built-in ‘bool :: a -> a -> Bool -> a’
15:28:21 <t7> i kinda think the syntax is a bit bloated allready though
15:28:24 <JoeyA> Right
15:28:35 <JoeyA> I don't think multi-way if does that; it's just a more convenient way to do guards
15:28:39 <JoeyA> instead of case () of _ | ...
15:28:57 <nand`> I'm just quoting the description of http://hackage.haskell.org/trac/ghc/ticket/4359#comment:87
15:29:04 <nand`> the original one that is
15:29:06 <JoeyA> doesFileExist path >>= \case False -> ...  True -> ...
15:29:52 <startling> is there a single thing that'll tell me "file", "directory", or "doesn't exist"?
15:30:37 <JoeyA> Nothing convenient that I know of.
15:30:47 <startling> ugh this is like the hardest thing to do in haskell
15:31:15 <JoeyA> The same can be said about copying a file in many other languages.
15:31:24 <JoeyA> But I agree, it is annoying.
15:32:00 <startling> JoeyA: it's a shame, though, because everything in haskell is so *easy* once you sit down and think for a while
15:32:27 <JoeyA> As I said, my randfile package defines this in its own module: data Stat = File | Directory | Other; stat :: FilePath -> IO Stat
15:32:39 <JoeyA> (if the file doesn't exist, it returns Other)
15:32:50 <startling> JoeyA: yeah, that seems like the best way to go
15:33:11 <JoeyA> A better way might be to provide data constructors depending on the OS.
15:33:39 <JoeyA> So for Unix, you'd have File | Directory | Symlink | FIFO | Socket
15:33:44 <JoeyA> (am I forgetting any?)
15:33:55 <nand`> Block device or something?
15:33:59 <JoeyA> And on Windows, you'd have File | Directory, because nobody cares enough about Windows.
15:34:03 <JoeyA> nand`: Ah, that too.
15:34:58 <tgeeky> JoeyA: anyone making a package today will include Symlink, and hopefuly socket
15:35:03 <JoeyA> Doing this helps make compatibility statically checkable.
15:35:38 <JoeyA> On the other hand, is* functions might be safer, to prevent users from _ing other stuff.
15:35:48 <nand`> data Plan9 = File
15:36:05 <JoeyA> e.g. stat path >>= \case File -> "It's a file!" ; _ -> "It's a directory!"
15:36:45 <startling> yeah, I'm just constructing a tree representing the filesystem so I can cordon off IO, so I don't need all this
15:37:11 <startling> I don't think anyone will put sockets or block devices in their blog source directories. :)
15:37:41 <JoeyA> But symlinks are pretty likely.
15:37:56 <JoeyA> If you have a symlink to a parent directory, I think doesDirectoryExist will return True.
15:38:02 <JoeyA> Then you'll get an infinite loop.
15:38:22 * nand` thinks symlinks should be abstracted away at this level
15:38:36 <EmilyS> srhb:  :)
15:38:45 <JoeyA> Indeed, this is the case.
15:39:02 <startling> JoeyA: nah, it's a lazy structure.
15:39:20 <JoeyA> What I mean is, if you traverse it all, you'll get an infinite loop.
15:39:30 <nand`> JoeyA: it's not a problem as long as nobody's around to actually read the blog and force it
15:39:32 <nand`> ;)
15:39:40 <k0ral> I'm having trouble implementing EitherT, https://gist.github.com/3190805
15:39:40 <startling> nand`: ha
15:39:42 <srhb> EmilyS: :>
15:39:45 <JoeyA> startling: You'll need unsafeInterleaveIO for that, right?
15:40:14 <k0ral> how would you insert a do-notation inside another do-notation, but for distinct monads ?
15:40:22 <startling> JoeyA: yep, think so
15:40:29 <shachaf> k0ral: You just do it.
15:40:30 <JoeyA> Don't use setCurrentDirectory in your traversal.
15:40:31 <startling> k0ral, exactly how you think
15:40:37 <startling> JoeyA: yeah, duh
15:40:41 <zzo38> k0ral: You just do... what exactly did you mean?
15:40:52 <shachaf> do-notation just translates one kind of syntax to another.
15:41:00 <JoeyA> foo = do
15:41:04 <JoeyA>     atomically $ do
15:41:07 <JoeyA>         ...
15:41:09 <tdammers> a block of do notation just produces a lazy value of a monadic type
15:41:20 <k0ral> zzo38: cf https://gist.github.com/3190805
15:41:20 <shachaf> "lazy value"?
15:41:30 <shachaf> It doesn't really have anything to do with laziness.
15:41:34 <k0ral> it says "Couldn't match type `n' with `EitherT f n'"
15:41:36 <tdammers> no, you're right
15:41:45 <tdammers> it produces a value
15:41:57 <shachaf> k0ral: Oh, well, you need to lift or something.
15:42:00 <shachaf> This has nothing to do with "do".
15:42:01 <k0ral> shachaf, startling: so the error I'm getting isn't about this conflict ?
15:42:08 <tdammers> but usually, it's lazy-evaluated, so the value isn't actually calculated right away
15:42:39 <tdammers> you don't necessarily need to lift though
15:42:45 <nand`> just a heads up, you can sometimes get weird or unexpected parsing issues when nesting stuff like do blocks
15:42:48 <tdammers> depends on what you want to do with the result of the do block
15:43:21 <startling> k0ral, might be a good idea to stick parens in where you think it might be ambiguous
15:43:24 <shachaf> nand`: Yes, but there's no parsing error here.
15:43:25 <nand`> eg. I think trying to define a multi-line (indented) do block inside a line like “let x = do ...” that's in another do block
15:43:26 <shachaf> It's just a type error.
15:43:38 <nand`> yeah
15:43:40 <nand`> just mentioning it
15:44:19 <latro`a> the function you're passing r to is gonna need to return a value in the same monad as the value "m", with what you wrote
15:44:27 <tdammers> I'd go with explicit {} syntax in such a scenario, if only to keep it unambiguous for a human reader
15:44:34 <latro`a> (I think this is what everyone else is saying, but I'm being explicit)
15:44:49 <shachaf> tdammers: Haskell layout is pretty simple to figure out as a human.
15:45:07 <nand`> tdammers: I'd expect indentation to keep it pretty unambiguous
15:45:39 <monochrom> add some tabs to keep it ambiguous :)
15:45:40 <latro`a> oh wait nvm
15:45:41 <latro`a> derp
15:45:50 <shachaf> monochrom: :-(
15:45:53 <k0ral> latro`a: right, it's more explicit like this :)
15:46:05 <startling> JoeyA, anyway, mind pointing to the source of your `stat`?
15:46:12 <tdammers> heh, 17 years of C apparently left a trace on me...
15:46:41 <startling> tdammers, make sure you stick a couple typedefs in there too. :)
15:46:53 <latro`a> forgot that EitherT was just a constructor, so m :: n (Either f b)
15:46:55 <latro`a> herp
15:47:03 * latro`a goes back to lurking
15:47:45 <LordBrain> i used to like layout... but it is annoying sometimes too. i find myself constantly using set list in vim to see invisible characters.
15:47:56 <MagneticDuck> hey
15:47:57 <latro`a> actually, isn't the mistake that you didn't re-EitherT at the top?
15:48:02 <MagneticDuck> I have a question about IDEs
15:48:05 <MagneticDuck> I love vim
15:48:07 <MagneticDuck> ..but
15:48:14 <MagneticDuck> when making a large project
15:48:20 <MagneticDuck> vim isn't very helpful
15:48:25 <MagneticDuck> I tried Leksah
15:48:30 <MagneticDuck> who here uses Leksah?
15:48:39 <LordBrain> i haven't
15:49:04 <LordBrain> i've used eclipse and visual studio, but neither with haskell
15:49:10 <Enigmagic> MagneticDuck: are you using any vim extensions? i have ghc-mod and a few other things setup and at least get decent completion.
15:49:14 <k0ral> latro`a: I used hoistEither for that
15:49:30 <JoeyA> startling: cabal unpack randfile .  It's in Stat.hs
15:49:34 <latro`a> oh, oh
15:49:35 <MagneticDuck> No, I'm not using any extensions
15:49:45 <latro`a> um
15:49:46 <startling> JoeyA: thanks
15:49:46 <MagneticDuck> I'd like something that could as least show me a list of functions in a file...
15:49:47 <MagneticDuck> etc
15:49:49 <latro`a> couldn't you have hoistEither $
15:49:50 <k0ral> latro`a: to me, m is :: m (Either e a)
15:49:51 <latro`a> at the top
15:49:51 <latro`a> instead
15:49:57 <MagneticDuck> along the lines of visual studio or eclipse
15:49:59 <LordBrain> ghci -ddump-types i think
15:50:00 <latro`a> oh, sorry
15:50:02 <latro`a> yes, it is
15:50:20 <Enigmagic> MagneticDuck: ghc-mod and neco-ghc will get you completion and type information
15:50:22 <latro`a> but that means when you r <- m, EitherT's >>= is not invoked
15:50:32 <latro`a> not sure if that's what you want
15:50:41 <MagneticDuck> any good IDEs iyho?
15:50:42 <Enigmagic> MagneticDuck: https://github.com/eagletmt/ghcmod-vim
15:50:53 <MagneticDuck> I'll try that, thanks
15:51:15 <k0ral> latro`a: do you mean at the top of the "case of" or at the top of the whole function ?
15:51:24 <latro`a> hm?
15:51:26 <MagneticDuck> is Eclipse reccomended?
15:51:28 <latro`a> oh
15:51:30 <MagneticDuck> for haskell?
15:51:41 <latro`a> yeah at the top of the whole thing, I don't think it would make a difference
15:51:41 <ceti331> arghh
15:51:50 <Enigmagic> MagneticDuck: the freely available editors i've tried weren't usable for me. i dislike eclipse a lot so i haven't tried the haskell plugin for it.
15:51:57 <ceti331> how does this polymorphism work:(
15:51:58 <MagneticDuck> hmm
15:52:08 <k0ral> I can't figure out how to extract the value from m without "executing" it in its own monad
15:52:15 <MagneticDuck> I know I'm being a stick in the mud, but I'd really like a good IDE for haskell
15:52:18 <nand`> Haskell programmers exist at the meeting point between laziness and compulsive desires for elegance
15:52:26 <MagneticDuck> Leksah seems to be oriented on a very large-scale
15:52:39 <nand`> MagneticDuck: I use vim
15:52:41 <Enigmagic> MagneticDuck: there are rumors of better editors though, so if you're familiar with vim or emacs it might be worth sticking with plugins for your editor of choice
15:52:55 <startling> MagneticDuck: I use emacs, vim is also good
15:52:56 <ceti331> got it working with typeclasses but then couldn't generalize my helper functoins; or i can write functions on parmeterized types easily, but still no
15:53:01 <MagneticDuck> yes, I use vim
15:53:08 <MagneticDuck> but for large projects...
15:53:15 <MagneticDuck> I feel like a want something graphic
15:53:18 <MagneticDuck> :(
15:53:21 <startling> MagneticDuck, you know about :vsplit et al?
15:53:33 <MagneticDuck> well, I'm a vim beginner
15:53:37 <latro`a> k0ral: EitherT has its own >>=
15:53:38 <MagneticDuck> no, I don't use vsplit
15:53:40 <nand`> Iunno, the largest project I've worked on has been about xmonad-scale
15:53:41 <latro`a> all transformers do
15:53:55 <nand`> I don't use vsplit either
15:53:59 <nand`> I don't like it
15:54:00 <startling> MagneticDuck: use it! it's handy. tabs are nice too, but i forget the invocation
15:54:08 <MagneticDuck> :tabnew
15:54:11 <latro`a> once you deconstruct the EitherT, you are now only using m's >>=
15:54:11 <LordBrain> i know about vsplit, but almost never touch it
15:54:18 <nand`> I don't use tabs either
15:54:38 <startling> nand`, do you just keep a single file open?
15:54:41 <LordBrain> :new is good enough...
15:54:48 <k0ral> latro`a: can't see the point: m >>= \r -> do is exactly the same as do r <- m;
15:54:58 <Enigmagic> i use tabs extensively in macvim
15:55:07 <k0ral> latro`a: the output is still forced to be the same as m
15:55:18 <startling> JoeyA: thanks, this is handy
15:55:31 <JoeyA> No problem
15:55:51 <latro`a> k0ral: I'm not sure what you mean
15:56:11 <k0ral> latro`a: yeah, I figured it out, I expressed it so badly
15:56:13 <latro`a> about being forced to be the same as m
15:56:41 <MagneticDuck> does anyone know is eclipse has a vi mode?
15:56:43 <LordBrain> :new, ctrl-w _ to maximize your current window, ctrl-w j or k or w to move to another window.. ctrl-w = to make them all the same size
15:56:49 <k0ral> once I start using >>=, everything that follows must be signed as x -> m (Either e a)
15:56:51 <latro`a> as is, that's true, but if EitherT is what you want then you probably want to use its >>=, which should actually bypass this case analysis, I *think*
15:57:03 <MagneticDuck> because I don't know all of vim
15:57:09 <latro`a> is that a problem, k0ral ?
15:57:11 <MagneticDuck> but I can't live without the vi commands
15:57:14 <LordBrain> maybe nobody knows all of vim
15:57:46 * ddarius never uses multiple windows in vim unless he's doing a file compare.
15:57:47 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
15:58:18 <nand`> startling: yes
15:58:22 <nand`> startling: I only edit a single file at a time
15:58:33 <ddarius> @ask shachaf So you've made a patch for the GHC folks to apply?
15:58:34 <lambdabot> Consider it noted.
15:58:42 <LordBrain> i cheat using multiple windows to expand the ctrl-p search completion
15:58:53 <parcs`> same. i use multiple buffers with a single window
15:58:55 <shachaf> @massages
15:58:55 <lambdabot> ddarius asked 22s ago: So you've made a patch for the GHC folks to apply?
15:59:03 <startling> nand`, huh, odd. I don't think I could manage like that
15:59:13 <LordBrain> ctrl-p and ctrl-n are your friends in vim if you have no other code completion
15:59:13 <shachaf> ddarius: Nope.
15:59:38 <shachaf> Given that the check is there explicitly, I suspect they wouldn't just apply a patch.
16:00:21 <ddarius> I'm curious what the logic for the check is beyond it catching what is typically a typo (albeit one that will be caught pretty quickly anyway.)
16:00:35 <ddarius> Though I'm not sure if I've ever accidentally made a ZPTC.
16:01:03 <k0ral> latro`a: I'm getting really confused :S
16:02:40 <shachaf> ddarius: http://hackage.haskell.org/trac/ghc/changeset/17985eb4007ae2415a97335b26fabc82fc38521f/ghc/compiler/typecheck/TcClassDcl.lhs is the only patch I can see with a reference to it.
16:03:20 <shachaf> Maybe there's no particular reason behind it.
16:03:36 <shachaf> GHC also doesn't support empty case statements or empty record updates.
16:04:10 <shachaf> (The latter is admittedly completely useless as far as I can tell.)
16:04:33 <ddarius> shachaf: Empty cases would be nice.
16:04:38 <hape01> MagneticDuck: I like EclipseFP 2.3.0 very much
16:04:49 <k0ral> I think it's easier to implement (Functor m, Functor n) => (e -> f) -> (m a -> n b) -> (c -> d) -> EitherT e m c -> EitherT f n d
16:05:05 <ddarius> Empty record updates I can understand since it makes subtle changes between things you'd think would be the same lead to completely different behavior.
16:05:29 <k0ral> if someone has an idea of how to implement (Functor m, Functor n) => (e -> f) -> (m a -> n b) -> EitherT e m a -> EitherT f n b, I'm really interested in
16:05:40 <ddarius> ZPTCs aren't completely useless.
16:06:10 <LordBrain> what is ZPTC?
16:07:00 <latro`a> wait
16:07:06 <latro`a> are you not guaranteed that m and n are monads?
16:07:12 <latro`a> if not, then everything I said was nonsense
16:07:22 <hape01> Zero Parameter Type Classes = ZPTC?
16:07:28 <k0ral> m and n are Functor-s
16:07:30 <ddarius> hape01: Yes.
16:07:44 <hape01> ddarius: I heard of yesterday :-)
16:12:01 <MagneticDuck> I "installed EclipseFP"
16:12:08 <MagneticDuck> now what do I do?
16:12:15 <hape01> perfect. You start creating a new project
16:12:17 <ddarius> Write code.
16:12:25 <MagneticDuck> but it's in java
16:12:26 <hape01> Haskell->HaskellProject (wizzard)
16:12:27 <MagneticDuck> >_<
16:12:35 <hape01> File->New->Other
16:12:39 <MagneticDuck> ahah
16:12:40 <MagneticDuck> phew
16:12:47 <hape01> File->New->Other->Haskell->Haskell Project
16:13:08 * ddarius found this in his draft emails today: http://zreomusic.com/
16:13:37 <hughfdjackson> o.o the mix of eclipse and haskell seems straight up odd to me
16:13:44 <hughfdjackson> :D each to their own, of course, but still
16:14:34 * hughfdjackson may or may not have gotten into the habit of thinking that IDEs exist to 'fix' bad languages, although he knows it isn't (entirely) true
16:16:29 <k0ral> now I have this: https://gist.github.com/3190982
16:16:37 <MagneticDuck> okay, it seems fine
16:16:39 <MagneticDuck> :S
16:16:41 <MagneticDuck> now..
16:16:41 <k0ral> I think I'm close to getting this to work
16:16:49 <MagneticDuck> Y EVERYTHING COMPILING ALWAYS
16:16:53 <MagneticDuck> lol
16:17:04 <MagneticDuck> there's a whole bunch of stuff compiling in the background
16:17:28 <bytes> hello
16:17:32 <MagneticDuck> wiw
16:17:34 <MagneticDuck> *wow
16:17:36 <MagneticDuck> this is awesome
16:17:38 <MagneticDuck> it's...
16:17:40 <MagneticDuck> wow
16:17:44 <MagneticDuck> there's a hoogle tab!!!!!
16:17:48 <MagneticDuck> I'm in heaven
16:18:23 <MagneticDuck> this is awesome
16:18:37 <MagneticDuck> now... how to I make a new module inside the project....
16:18:41 <MagneticDuck> *do
16:19:16 <k0ral> anyone has a clue about https://gist.github.com/3190982 ?
16:19:59 <MagneticDuck> I'm so excited!
16:20:01 <MagneticDuck> it's like haskell
16:20:05 <MagneticDuck> but it has an IDE!!!
16:20:09 <hape01> :-)
16:20:20 <MagneticDuck> I'm never going back
16:20:22 <MagneticDuck> :')
16:20:46 <MagneticDuck> only problem:
16:20:59 <MagneticDuck> if there only was a vi mode......
16:21:35 <latro`a> k0ral: when you get bound variable errors, comment out your signature
16:22:15 <MagneticDuck> ..there's no syntax highlighting?
16:22:58 <Enigmagic> k0ral: you might want it to look more like this: mapEitherT :: (Functor m, Functor n) => (e -> f) -> (forall a . m a -> n a) -> (b -> c) -> E.EitherT e m b -> E.EitherT f n c
16:23:08 <Enigmagic> and run on rank-2 types
16:23:18 <Enigmagic> turn on..
16:23:18 <MagneticDuck> hape01: There's no syntax highlighting?
16:23:30 <hape01> MagneticDuck>: Sure there is...
16:23:44 <hape01> MagneticDuck: did you create a haskell module?
16:23:45 <MagneticDuck> hm.. I don't have any right now
16:23:49 <MagneticDuck> yes I did
16:23:54 <MagneticDuck> I made a new project
16:23:56 <MagneticDuck> and added a module
16:24:00 <hape01> http://4.bp.blogspot.com/-i9Xs4DqzFtI/UANRCEtK5PI/AAAAAAAAAMM/hxyMpkgi_fw/s1600/Vollbildaufzeichnung+16.07.2012+012010.jpg
16:24:22 <k0ral> latro`a: that's a pretty convenient advise :) thank you
16:24:31 <MagneticDuck> yeah
16:24:34 <MagneticDuck> I don't see any though
16:25:55 <k0ral> Enigmagic: right, thank you
16:28:02 <Lingyis> hi
16:28:33 <Lingyis> question about persistent--should one use it to do data migration instead of on the database end?
16:29:10 <MagneticDuck> well g2g
16:29:21 <MagneticDuck> ty for the help
16:30:12 <hape01> np - good n8 - cu
16:30:53 <k0ral> I ended up writing liftEitherT lift (E.EitherT m) = (E.EitherT $ lift m)
16:30:54 <ddarius> "Guten N8"  I don't know why you'd say "n8".
16:31:05 <k0ral> does only the lifting part of mapEitherT
16:32:34 <aristid> ddarius: i don't know if you actually care about this, but "n8" is because the german word for night is "nacht" and the word for 8 is "acht", so n8 = n-acht
16:33:08 <ddarius> aristid: Yes, but "good" isn't a German word to my knowledge.
16:33:37 <aristid> ddarius: right, it isn't.
16:34:00 <gertc> how do you lift a Maybe from Text?
16:34:17 <ddarius> aristid: I meant to have a phrase after my "Guten n8" but I accidentally skipped it and hoped it would be clear enough to understand without it.
16:34:57 <aristid> ddarius: ?
16:35:59 <ddarius> I was responding to "hape01: np - good n8 - cu".  I meant to say "'Guten n8' makes sense, but I don't know why you'd say '(good) n8'".
16:37:54 <aristid> ddarius: oh. yes. except it's "gute" not "guten" :P
17:10:50 <startling> meh, I have a m [(x, m y)]; how do I get it to an m [(x, y)]?
17:12:46 <shachaf> @ty let f ml = do { l <- ml; mapM (\(x,my) -> do { y <- my; return (x,y) }) l } in f
17:12:47 <lambdabot> forall (m :: * -> *) t t1. (Monad m) => m [(t, m t1)] -> m [(t, t1)]
17:12:53 <shachaf> And natural simplifications of that.
17:14:01 <startling> hmm, would it be easier if I had an (m x, m y)?
17:14:56 <shachaf> That was pretty easy.
17:15:03 <shachaf> So who knows.
17:15:25 <nand`> :t sequence . map Data.Traversable.sequence
17:15:26 <lambdabot> forall (m :: * -> *) (t :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => [t (m a)] -> m [t a]
17:15:38 <nand`> shouldn't (,) x be Traversable?
17:17:49 <edwardk> @type Data.Traversable.traverse Data.Traversable.sequence
17:17:50 <lambdabot> forall (t :: * -> *) (f :: * -> *) a (t1 :: * -> *). (Data.Traversable.Traversable t, Monad f, Data.Traversable.Traversable t1, Applicative f) => t1 (t (f a)) -> f (t1 (t a))
17:17:51 <edwardk> yes it should
17:17:58 <edwardk> sadly
17:18:32 <startling> oh, I can just throw out all that code I had before and zipM
17:18:34 <LordBrain> does anyone use ghc-mod wiht vim?
17:18:44 <nand`> nice generalization of sequence . map
17:18:50 <nand`> I never get that one in my head :(
17:19:06 <LordBrain> i just installed it, but i dont see how to get started, vim doesnt seem to know or care that it's there
17:19:10 <nand`> (sequence .: map, rather)
17:19:51 <nand`> why hasn't Data.Traversable been qualified in lambdabot yet? I hate typing that out
17:20:12 <nand`> I have it as ‘Trav’ locally
17:21:01 <gertc> how do i lift Maby from a Maby Text type?
17:22:41 <Veinor> gertc: what do you mean?
17:24:15 <startling> ah, nothing like successfully navigating through some tricky monadic code
17:25:10 <parcs`> nand`: submit a library change proposal
17:26:01 <gertc> Veinor: e <- app gives me a Maybe Text value and i need a Text?
17:26:47 <nand`> (incidentally, I think ‘traverse’ might as well just be unqualified)
17:27:21 <nand`> and since this is Caleskell, ‘sequence’ can just replace the Prelude sequence
17:27:32 <nand`> or is there a good reason not to do that?
17:30:02 <edwardk> if we're going full-on caleskell i'd just as soon import Foldable and Traversable unqualified, and hide the things they shadow in Prelude
17:30:40 <mashed> i tried an expression in ghci and got a bus error
17:30:46 <hpaste> mashed pasted “why does this expression crash?” at http://hpaste.org/72235
17:30:53 <edwardk> well, move the bus and try again
17:31:14 <mashed> edwardk: i didn't realize busses were involved when i entered the expression..
17:31:26 <edwardk> OpenGL and ghci don't play nice for initialization reasons iirc
17:31:47 <mashed> edwardk: that's fine
17:31:58 <mashed> all i was trying to do was ":t vertex $ Vertex3"
17:32:03 <mashed> but that doesn't work either...
17:32:25 <parcs`> are you on a mac?
17:32:49 <mashed> parcs`: why, yes
17:33:47 <startling> mashed: iirc, opengl and sdl crash in ghci no matter what
17:33:52 <parcs`> yeah, many people have reported this problem
17:34:02 <parcs`> startling: not on linux
17:34:15 <startling> parcs`: er yeah, I should append "on o x"
17:34:21 <startling> *os x
17:34:29 <startling> there are tricks to make them compile but they seem complicated and not worth it tbh
17:34:33 <mashed> startling: parcs`: okay, well that's fine... i was just trying to understand the types
17:34:54 <startling> mashed: yeah. :/ kinda sucks
17:35:14 <parcs`> infer the type in your head! :P
17:36:28 * hackagebot lens 0.6 - Lenses and Lens Families (EdwardKmett)
17:37:11 <mashed> parcs`: i'd love to, really, but i'm new :)
17:37:27 <parcs`> mashed: if you want to know the type of an expression prepend the expression with :t
17:37:49 <parcs`> i don't think that requires loading the library, and so you won't get an error
17:38:17 <bazhang_> Subsequent and multiple orgasms
17:38:17 <bazhang_> In contrast to the two-stage model, Kahn (1939) equalized orgasm and ejaculation and stated that several orgasms can occur and that "indeed, some men are capable of following it up with a third and a fourth".[15] Though rare, Kahn's assertion that "some men are capable of following [an orgasm] up with a third and a fourth" is supported by men who have reported having multiple, consecutive orgasms, particularly without ejaculation.
17:38:19 <bazhang_> [15] Males who experience dry orgasms can often produce multiple orgasms, as the refractory period is reduced.[15][21] Some men are able to masturbate for hours at a time, achieving orgasm many times.[21] Many men who began masturbation or other sexual activity prior to puberty report having been able to achieve multiple non-ejaculatory orgasms. Some evidence indicates that orgasms of men before puberty are qualitatively similar t
17:38:24 <bazhang_> o the "normal" female experience of orgasm, suggesting that hormonal changes during puberty have a strong influence on the character of male orgasm.[22] Some men have been multiorgasmic since they can recall, while others have learned to achieve multiple orgasms.[15]
17:38:27 <parcs`> @Where ops
17:38:28 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
17:38:30 <bazhang_> A number of studies have pointed to the hormone prolactin as the likely cause of the male refractory period. Because of this, there is currently an experimental interest in drugs which inhibit prolactin, such as cabergoline (also known as Cabeser, or Dostinex). Anecdotal reports on cabergoline suggest it may be able to eliminate the refractory period altogether, allowing men to experience multiple ejaculatory orgasms in rapid succ
17:38:35 <bazhang_> ession. At least one scientific study supports these claims,[23] although cabergoline is a hormone-altering drug and has many potential side effects. It has not been approved for treating sexual dysfunction.[23] Another possible reason for the lack or absence of a refractory period in men may be an increased infusion of the hormone oxytocin. It is believed that the amount by which oxytocin is increased may affect the length of eac
17:38:40 <bazhang_> h refractory period. A scientific study to successfully document natural, fully ejaculatory, multiple orgasms in an adult man was conducted at Rutgers University in 1995. During the study, six fully ejaculatory orgasms were experienced in 36 minutes, with no apparent refractory period.[24] It can also be said that in some cases, the refractory period can be reduced or even eliminated through the course of puberty and on into adult
17:38:45 <bazhang_> hood. Later, P. Haake et al. observed a single male individual producing multiple orgasms without elevated prolactin response.[25]
17:38:48 <bazhang_> In recent years, a number of books have described various techniques to achieve multiple orgasms. Most multi-orgasmic men (and their partners) report that refraining from ejaculation results in a far more energetic post-orgasm state.[26] One technique for refraining from ejaculation is to put pressure on the perineum, about halfway between the scrotum and the anus, just before ejaculating to prevent ejaculation. This can, however,
17:38:53 <bazhang_>  lead to retrograde ejaculation, i.e., redirecting semen into the urinary bladder rather than through the urethra to the outside. It may also cause long term damage due to the pressure put on the nerves and blood vessels in the perineum, akin to that reported by some males who ride bicycles with narrow seats for extended periods.[27] Men who have had prostate or bladder surgery, for whatever reason, may also experience dry orgasms
17:39:00 <bazhang_>  because of retrograde ejaculation.
17:39:02 <bazhang_> Other techniques are analogous to reports by multi-orgasmic women indicating that they must relax and "let go" to experience multiple orgasms. These techniques involve mental and physical controls over pre-ejaculatory vasocongestion and emissions, rather than ejaculatory contractions or forced retention as above. Anecdotally, successful implementation of these techniques can result in continuous or multiple "full-body" orgasms.[28]
17:39:07 <bazhang_> In females
17:39:07 --- mode: ChanServ set +o mauke
17:39:07 --- mode: mauke set +b *!*@c-68-50-226-254.hsd1.md.comcast.net
17:39:17 --- kick: bazhang_ was kicked by mauke (bazhang_)
17:39:47 --- mode: mauke set -z
17:41:47 --- mode: mauke set -o mauke
17:43:08 <mashed> parcs`: using ":t" with that expression doesn't work either
17:43:39 <mashed> parcs`: doing it without the library loaded just gives a not-in-scope error, as one would expect :P
17:43:44 <mashed> thanks though!
17:44:51 <hpaste> gertc pasted “Couldn't match expected type `Maybe Text' with actual type `Text'” at http://hpaste.org/72236
17:45:46 <parcs`> mashed: you can import the library, it just can't be linked
17:45:58 <parcs`> using :t won't force the library to get linked
17:47:11 <ReinH> I'm wondering if there's a simpler way to write a function that will take a list, an index, and a fuction and return a new list with the function applied to the item at index (https://gist.github.com/c3a1847d39e74e81363d)
17:47:34 <shachaf> ReinH: map f l !! i
17:47:36 <Cale> Thankyou mauke
17:47:52 <latro`a> uh, shachaf, wrong return type
17:47:58 <latro`a> he wants a list with only the ith applied
17:48:23 <shachaf> Oh.
17:48:26 <shachaf> A new list, right.
17:48:33 * geekosaur thinking zip and foldr...
17:48:54 <shachaf> splitAt and a function that maps the head of a list?
17:48:59 <parcs`> ReinH: edwardk's new lens library can do that
17:49:00 <mashed> parcs`: how do i import without linking...
17:49:09 <latro`a> splitAt is probably best, yeah
17:49:37 <ReinH> splitAt could work but tbh I don't see the benefit over recursing once
17:49:39 <mashed> parcs`: is it the * operator? in ":module [+/-] [*]<mod> ..."
17:50:06 <parcs`> mashed: :module should work
17:50:48 <shachaf> ReinH: The other thing is "this is a weird function and it's quite possible that you don't want it in the first place".
17:50:53 <m3ga> what's it called when you have a data type defined just as a type name eg "data MyType" but you don't supply any constructors?
17:50:53 <shachaf> Why do you want it?
17:51:00 <latro`a> what shachaf said, yeah
17:51:10 <ReinH> shachaf: chess board
17:51:14 <latro`a> m3ga: the canonical name for that type is Void
17:51:27 <shachaf> m3ga: Uninhabited?
17:51:30 <ReinH> writing updateBoard
17:51:33 <shachaf> EmptyDataDecls
17:51:34 <latro`a> but the term is uninhabited yeah
17:51:40 <hpaste> mashed pasted “parcs`: using :module doesn't work; i get a scope error” at http://hpaste.org/72237
17:51:48 <m3ga> shachaf: thanks thats the one
17:51:58 <latro`a> um
17:51:59 <m3ga> its a place holder type in a happy parser
17:52:01 <mashed> parcs`: but thanks :)
17:52:01 <shachaf> latro`a: That's like saying the canonical name for "data Foo = Bar | Baz" is "Bool"
17:52:06 <ReinH> board will probably be wrapped up in a state monad eventually and I need a state transform
17:52:06 <parcs`> mashed: that's not a scope error :P
17:52:20 <latro`a> true, shachaf, but there's really only one thing you can do with Void
17:52:23 <parcs`> you didn't fully appyly the Vertex3 constructor
17:52:29 <latro`a> so it's not as problematic
17:52:40 <shachaf> latro`a: Eh. I still don't want to mix two Voids up.
17:52:44 <mashed> parcs`: err, yeah, the scope error was when i didn't import the module
17:52:46 <shachaf> Also you might be using it as a phantom type.
17:52:52 <latro`a> that's true
17:52:56 <latro`a> anyway yeah
17:53:02 <latro`a> :t \x y z -> vertex $ Vertex x y z
17:53:03 <lambdabot> Not in scope: `vertex'
17:53:03 <lambdabot> Not in scope: data constructor `Vertex'
17:53:04 <mashed> parcs`: but still, there's an error (and i don't really know how to interpret it)
17:53:05 <latro`a> is what you want, I think
17:53:49 <mashed> parcs`: why does the constructor need to be applied?
17:53:51 <m3ga> shachaf: i read the haskell wiki about phantom types and it doesn't quite fit my used. un-inhabited does
17:53:59 <latro`a> mashed: if you don't apply it you don't have a Vertex
17:54:02 <mashed> parcs`: i thought the expression should have a type without being applied..
17:54:18 <latro`a> it does, but functions aren't in the Vertex class
17:54:28 <latro`a> which is what that "no instance for" line says
17:55:08 <hpaste> mashed pasted “oh, okay, composition gives the type” at http://hpaste.org/72238
17:55:17 <ReinH> shachaf: so is this a weird thing that I don't want in the first place? https://gist.github.com/3f5553d4e803f5d18175
17:55:23 <latro`a> that is probably not the kind of composition you mean
17:55:24 <ReinH> wondering how this kind of thing is typically done
17:55:47 <shachaf> ReinH: It might be that a list isn't the data structure you want.
17:55:48 <mashed> latro`a: probably..
17:55:49 <latro`a> mashed: that passes only one argument to Vertex3
17:55:56 <latro`a> you probably want a lambda like the one I described
17:56:14 <ReinH> shachaf: may use a Vector instead but I was hoping to stick with a list for a while as I thought it would be conceptually easier
17:56:26 <shachaf> There are also things other than lists and Vectors. :-)
17:56:27 <ReinH> s/Vector/Array
17:56:34 <ReinH> shachaf: go on :)
17:56:37 <shachaf> ReinH: It might also be that you want to use a lens or something into the squares of the chessboard.
17:56:49 <mashed> latro`a: yeah, you're correct
17:56:59 <mashed> latro`a: your lambda gives the sane type
17:57:38 <ReinH> shachaf: this is intended for a beginner-level guide so I want to KISS as much as possible
17:57:53 <hpaste> mashed pasted “sane type” at http://hpaste.org/72240
17:58:23 <mashed> latro`a: parcs`: thanks!
17:58:51 <ReinH> shachaf: although lenses do look appropriate
17:59:18 <shachaf> ReinH: The main thing is probably to keep the implementation of the chessboard abstract enough that you can just go with something. :-)
17:59:30 <ReinH> shachaf: sure, I'd interact with it through a uniform interface
18:00:00 <ReinH> shachaf: I think introducing arrays and then lenses might make for some nice topics later on though
18:00:03 <ReinH> thanks
18:00:17 <ReinH> getSquare and putSquare should be sufficient, I think
18:01:23 <shachaf> Arrays have their own problems, of course.
18:01:36 <ReinH> shachaf: everything has its own problems ;) what are array's problems?
18:01:50 <ReinH> constant access seems like a big win
18:01:54 <shachaf> Well, you have to copy the whole thing to change it.
18:01:57 <shachaf> Since there' sno mutation.
18:02:05 <shachaf> Unless you use mutable arrays, which have their own problems.
18:02:09 <ReinH> right
18:02:17 <ReinH> I'm not planning on using mutable structures
18:02:22 <gertc> http://stackoverflow.com/questions/11697353/haskell-couldnt-match-expected-type-maybe-text-with-actual-type-text
18:03:02 <ReinH> gertc: can you make the example simpler?
18:03:07 <Ralith> shachaf: what are mutable arrays' problems, problems common to all mutable values aside?
18:03:12 <ReinH> that's a lot of code to read for one type mismatch
18:03:18 <shachaf> Ralith: Aren't those enough?!
18:03:45 <Ralith> shachaf: depends on the usecase!
18:04:24 <intrigue> sorry to be slightly off topic - rather new to functional programming, coming from an imperative/oop background.
18:04:36 <intrigue> Does haskell absolutely blow everyone's mind as these concepts click?
18:04:52 <ReinH> intrigue: pretty much
18:04:55 <t7> whats the Data class for?
18:04:55 <shachaf> Some people.
18:05:04 <BMeph> intrigue: Absolutely! :)
18:05:06 <intrigue> I find myself frequently having these moments of like.. "Oh wow"
18:05:38 <Clint> and then you're unable to write any code for years?
18:06:02 <intrigue> i'm still not sure how im going to ever write any meaningful haskell code, but i hope i get there ;)
18:07:57 <ReinH> shachaf: thanks for your help
18:08:25 <ReinH> shachaf: I'm going to try to make a series of live coding videos and I'd appreciate it if you felt like wathing them and then telling me how wrong everything I'm doing it :)
18:08:34 <latro`a> reinH: there is also some advantage to Map
18:08:39 <latro`a> depending on the details
18:08:40 <ReinH> s/it/is
18:08:46 <ReinH> latro`a: right
18:09:16 <ReinH> I think as long as I abstract away from the impl details I'm fine to start with [[Square]]
18:09:32 <gertc> ReinH: let a=maybe "test" print a
18:09:39 <ReinH> it'll be relatively easy to switch to a different type later on when needed
18:10:43 <ReinH> gertc: how would that work?
18:10:50 <ReinH> :t maybe
18:10:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:10:53 <ReinH> :t print
18:10:54 <lambdabot> forall a. (Show a) => a -> IO ()
18:11:38 <ReinH> you need a function a -> b, not a -> IO ()
18:11:40 <latro`a> doesn't that have horrifying recursion?
18:11:51 <latro`a> reinH: IO () is a perfectly valid b
18:11:53 <ReinH> latro`a: well, I was starting with the part where it doesn't even typecheck
18:11:59 <gertc> ReinH it doesn't how do you remove Maybe from a value after it is been created?
18:12:00 <latro`a> his problem is "test" is not IO ()
18:12:10 <ReinH> latro`a: thanks, that's what I meant
18:12:28 <latro`a> maybe (putStrLn "test") print <some maybe val> is fine
18:13:04 <ReinH> gertc: pattern matching is the typical way, since you want to handle Nothing as well
18:13:30 <ReinH> if you're sure it's never Nothing, there's
18:13:33 <ReinH> :t fromMaybe
18:13:34 <lambdabot> forall a. a -> Maybe a -> a
18:13:48 <ReinH> sorry
18:13:51 <ReinH> :t fromJust
18:13:52 <lambdabot> forall a. Maybe a -> a
18:13:57 <Ralith> don't use fromjust
18:14:04 <ReinH> but that errors and is probably not what you want
18:14:19 <shachaf> Please don't use fromJust
18:14:22 <ahkurtz> you're supposed to pattern match?
18:14:22 <gertc> ReinH that why i post the full code because els i get more questions :)
18:14:31 <shachaf> If you're sure it's never Nothing, use "let Just x = ..."
18:14:51 <luite> why is that better than fromJust?
18:15:24 <ReinH> you just get an inexhaustive match error rather than a fromJust error...
18:15:38 <shachaf> luite: It'll give you a nice line number rather than a generic fromJust error.
18:16:12 <ReinH> gertc: I'm pretty sure you want something like putStr $ maybe "test" show
18:16:47 <ReinH> or whatever you use instead of show to get a string from the value inside the Just
18:16:49 <ahkurtz> it's interesting to me how many things in Haskell are there, but you aren't supposed to use
18:17:01 <ReinH> shachaf: that's a good point
18:17:40 <c_wraith> ahkurtz: it comes from haskell's research background.  lots of things were added at one point just to see what would happen
18:17:49 <latro`a> ahkurtz, I think it's mostly just partial functions that people don't like much
18:18:03 <luite> shachaf: hm ah i didn't expect that, still i think it's more a limitation of ghc that fromJust cannot give a call trace with line numbers
18:18:12 <latro`a> er, that they don't like and have a perfectly fine alternative for
18:18:18 <gertc> Reinh i just want to create a Text value form a Maybe Text value putstr is a io value i think ?
18:18:25 <shachaf> luite: Yes, that would be nice.
18:18:31 <ReinH> gertc: then why did you have print in there in the first place?
18:18:43 <latro`a> print != show
18:18:51 <latro`a> to be precise, print = putStrLn . show
18:19:27 <ahkurtz> it's not possible for it to know the line number of a function call at runtime right?
18:19:29 <gertc> ReinH simpler example is somtimes not a good idea :)
18:19:29 <ReinH> I assumed you wanted IO
18:19:43 <ReinH> gertc: simpler example is a good idea when it's correct
18:19:46 <ReinH> incorrect examples never good idea
18:20:21 <ahkurtz> latro`a: people also really hate the record syntax, and fail in Monad
18:20:55 <ahkurtz> among many other things I have only a vague fuzzy rememeberance of
18:20:55 <gertc> ReinH: let a=maybe "test"
18:21:20 <ahkurtz> or the fact that Functor < Applicative Functor but not Applicative < Monad
18:21:28 <ReinH> gertc: you want a to be a partially applied function that takes a function and a maybe value?
18:21:39 <ReinH> gertc: where in the original code are you having this problem?
18:21:50 <gertc> Reinh: let b= a --without maybe
18:21:58 <ReinH> what
18:22:15 <ReinH> ok so a = Just "test" you want b = "test"
18:22:26 <gertc> yes
18:22:56 <ReinH> and what do you want to do if it's Nothing?
18:23:49 <gertc> ReinH: crash :)
18:24:06 <ReinH> b = fromJust a -- *runs away*
18:24:36 <ReinH> case a of Just b
18:24:42 <gertc> thx going to test
18:25:07 <latro`a> I'm not sure how much you could do about record syntax?
18:25:30 <ReinH> gertc: let Just b = a
18:25:33 <ReinH> lots of ways
18:25:39 <ReinH> probably in decreasing order of suck
18:26:39 <edwardk> ReinH: ghci> traverseElement 4 ^+= 12 $ [1,2,3,4,5,6]     ==> [1,2,3,4,17,6]
18:27:09 <ahkurtz> latro`a: there are many alternative proposals that I don't understand myself. I find myself very often under water when trying to follow expert Haskellers who have opinions about the language
18:27:26 <ahkurtz> which probably means I should just ... be very quiet.
18:27:31 <latro`a> heh
18:27:53 <edwardk> ReinH: to apply an arbitrary function use traverseElement n ^%= f $ yourList
18:28:32 <ahkurtz> there's a language extension you can use to get overlapping record field names in different record types
18:28:48 <latro`a> I'm familiar with that one, yeah
18:29:02 <ahkurtz> so that's something you could do?
18:29:16 <latro`a> that doesn't really change much, though
18:29:43 <latro`a> in fact, in the "getter" variant alone, you could already do it
18:29:45 <latro`a> with a typeclass
18:29:49 <latro`a> ugly as sin, but doable
18:30:23 <ahkurtz> but when you define the record you still need to come up with unique names?
18:30:38 <latro`a> true, but they can just be garbage
18:30:43 <latro`a> that you don't use
18:30:58 <latro`a> the extension is nice though, I agree
18:34:01 <gertc> ReinH: Just b = a works thx
18:36:30 <covi> Are Writer and Reader used a lot in real world development?
18:37:55 <Eduard_Munteanu> covi: Reader is pretty common
18:38:39 <Eduard_Munteanu> For example when you want to pass some common environment around.
18:38:57 <Eduard_Munteanu> (e.g. configuration)
18:39:19 <covi> I see. I haven't gained much intuition for Writer yet
18:39:51 <geekosaur> Writer = logging
18:40:07 <Eduard_Munteanu> They also become more important as part of monad transformer stacks.
18:40:11 <notdan> Writer + Reader ~ State
18:40:20 <Eduard_Munteanu> Not really, no.
18:40:38 <notdan> Hm. Yeah, ~ is probably a wrong symbol for this
18:40:46 <notdan> and the + is not defined
18:40:48 <jmcarthur> not they just aren't really the same
18:40:52 <jmcarthur> *no they
18:41:12 <notdan> What is the prime difference?
18:41:22 <jmcarthur> the structure of Reader composed with Writer is the same, but the behavior of the monad is not
18:41:24 <Eduard_Munteanu> notdan: you simply don't have mutable state around
18:41:41 <ReinH> edwardk: traverseElement? hoogle doesn't know anything about it.
18:41:51 <edwardk>  ReinH : its in 'lens'
18:41:58 <jmcarthur> writer composed with reader gives you the ability to read a value and accumulate some monoid, but you don't get to read the results of the accumulation as you go or anything
18:42:00 <edwardk> the package folks mentioned earlier
18:42:03 <ReinH> edwardk: ah
18:42:16 <jmcarthur> also, State doesn't require the state to be a monoid
18:42:20 <geekosaur> if you compose a Writer and a Reader, they each have their own independent state
18:42:37 <notdan> Eduard_Munteanu: yea, what I mean is that if you could use the features of Reader and the features of Writer at the same time we might get something similar to State
18:42:48 <notdan> geekosaur: yeah, I agree
18:42:54 <notdan> even the type would be different
18:43:27 <Eduard_Munteanu> I'd say State is fundamentally different.
18:43:38 <edwardk> notdan: at one point i used to want get to be the same as ask and put to be the same as tell. i got better ;)
18:44:07 <edwardk> since you often use them together in the same monad, its actually really convenient to have them separate rather than having to fudge around with lifting
18:44:08 <ReinH> edwardk: thanks!
18:44:28 <notdan> edwardk: yeah :)
18:49:17 <covi> > runWriter $ Writer (1, '2')
18:49:18 <lambdabot>   Not in scope: data constructor `Writer'
18:50:02 <Eduard_Munteanu> @src Writer
18:50:02 <lambdabot> Source not found. Are you on drugs?
18:50:05 <edwardk> > runWriter $ writer (1, '2')
18:50:06 <lambdabot>   (1,'2')
18:50:15 <edwardk> writer is a smart constructor. there is only WriterT
18:50:18 <edwardk> :t WriterT
18:50:19 <lambdabot> forall (m :: * -> *) a w. m (a, w) -> WriterT w m a
18:50:21 <edwardk> :t writer
18:50:24 <lambdabot> forall a w. (a, w) -> Writer w a
18:50:48 <covi> > runWriter (writer (1, '2')) >>= (\x -> (x^x, 'Exponentiated!'))
18:50:49 <lambdabot>   <no location info>:
18:50:50 <lambdabot>      lexical error in string/character literal at chara...
18:50:55 <covi> > runWriter $ (writer (1, '2')) >>= (\x -> (x^x, 'Exponentiated!'))
18:50:56 <edwardk> (in the current transformers, writer :: Monad m => (a, w) -> WriterT w m a
18:50:56 <lambdabot>   <no location info>:
18:50:57 <lambdabot>      lexical error in string/character literal at chara...
18:51:30 <covi> edwardk: Why isn't the line working
18:51:47 <edwardk> > ([],2) >>= (,) [1]
18:51:47 <lambdabot>   No instance for (GHC.Base.Monad ((,) [a]))
18:51:47 <lambdabot>    arising from a use of `e_121'...
18:51:51 <edwardk> bah that monad is missing
18:51:54 <geekosaur> covi: '' is Char not String
18:52:02 <edwardk> because i don't understand it ;)
18:52:13 <edwardk> 'Exponentiated!' is a really long char ;)
18:52:17 <geekosaur> this is not perl, '' and "" are not just different string delimiters for the same basic type
18:52:26 <edwardk> and x^x is also pretty messed up =)
18:52:27 <geekosaur> (or python)
18:52:28 <Eduard_Munteanu> wchar_t :P
18:52:32 <edwardk> plus its returning a pair, not a writer
18:52:42 <edwardk> once all thats fixed up it'll be closer to working
18:53:01 <edwardk> finally you need something that is both a Num and a Monoid to have that work
18:53:02 <covi> My bad :(
18:53:17 <edwardk> no worries, just answering since you asked ;)
18:53:17 <shachaf> Is there any reason (w,) isn't a Monad?
18:53:21 <covi> Old python habit :(
18:53:22 <edwardk> shachaf: no
18:53:32 <edwardk> shachaf: the only reason would be historical
18:53:35 <edwardk> oh
18:53:36 <edwardk> i remember
18:53:43 <edwardk> the problem is that Data.Monoid isn't in the Prelude
18:53:47 <edwardk> so the instance is an orphan
18:54:03 <shachaf> Ah.
18:54:14 <aristid> edwardk: but the instance is somewhere?
18:54:51 <edwardk> apparently not =(
18:55:08 <aristid> well there's always the beloved Writer type synonym ;)
18:55:23 <aristid> @src Writer
18:55:23 <lambdabot> Source not found. Sorry.
18:56:50 <edwardk> there was a libraries proposal to add them forever ago that i could have sworn was approved
19:21:06 <Cale> - The official name of the language is now OCaml. -- wat
19:22:45 <aristid> Cale: and i was already so used to the name "haskell" :/
19:23:07 <Cale> I'm talking about the release notes for OCaml 4.0 of course :)
19:23:38 <GyorsCsiga> lol
19:23:42 <stepcut>  i think it was O'Caml before?
19:23:48 * stepcut is just guessing
19:24:17 <Cale> yes
19:24:25 <Cale> I wonder what caused them to change it
19:25:13 <Cale> That must have been quite a mailing list thread, lol
19:25:45 <aristid> Cale: the mother of all bikeshedding threads
19:26:05 <luite> hmm, don't they mean that the language has now been named after its main implementation?
19:26:45 <applicative> It was named O'Caml to cash in on the popularity of Irelan
19:26:56 <applicative> Ireland too
19:27:19 <applicative> but now the E.U. is falling apart.
19:31:11 <applicative> "Gadts and (usable) first-class modules! Who says OCaml (official name) isn't a language the cool kids use? "
19:32:00 <Eduard_Munteanu> The cooler stuff is equirecursive types IMO ;)
19:33:40 <Cale> What do you do with equirecursive types that can't be done as well with isorecursive types?
19:34:03 <Eduard_Munteanu> Cale: IDK, but it's a fun CS topic in itself :)
19:34:25 <Eduard_Munteanu> Quite a challenge, I hear.
19:35:20 <Eduard_Munteanu> I wonder if there's any theorem prover that's got them.
19:35:27 <shachaf> OCaml has equirecursive types now?
19:35:42 <dolio> It's had a flag that turns them on for a long time.
19:36:11 <dolio> Anyhow, I'm not sure what's challenging about them.
19:36:16 <Veinor> what exactly is an equirecursive type?
19:36:35 <Eduard_Munteanu> dolio: I recall TAPL saying their semantics aren't quite yet settled.
19:36:36 <dolio> Sorear banged out a type checker for equirecursive types in like a day a few years back.
19:37:31 <Eduard_Munteanu> Veinor: a type that's exactly its expansion, take List a = 1 + a * (List a) for example.
19:38:31 <Cale> It's easy to allow infinite types, but it permits lots of things which ought to be considered type errors to compile
19:38:31 <Eduard_Munteanu> Veinor: in Haskell you have List a just isomorphic to 1 + a * (List a)
19:39:15 <ddarius> It's pretty damn easy to add equirecursive types to a polymorphic language.
19:39:26 <Eduard_Munteanu> Dayum.
19:39:29 <Eduard_Munteanu> ddarius: you're back!
19:39:41 <Veinor> Eduard_Munteanu: okay. i'm not sure I understand what this would look like in a programming language
19:40:18 <Eduard_Munteanu> Veinor: it would be pretty much like defining lists as type synonyms to say so, AFAIU
19:40:27 <Cale> http://www.mail-archive.com/haskell-cafe@haskell.org/msg18345.html
19:41:24 <edwardk> non-binding straw poll, getter/setter or accessor/mutator?
19:41:43 <parcs`> getter setter!
19:42:16 <Veinor> getter/setter
19:42:53 <applicative> getter setter ?
19:43:35 <edwardk> so far the channel seems to weigh in in the same direction as google's ratings of the terms ;)
19:44:10 <applicative> hm,  how about something non-imperative sounding?
19:44:15 <edwardk> the only annoying part of the getter/setter name is that the obvious name 'get' making a getter is taken =(
19:44:32 <applicative> accessor/editor
19:44:33 <edwardk> (1 :+ 2).get magnitude is nice
19:44:44 <edwardk> (1 :+ 2)^.get magnitude
19:44:57 <edwardk> since the usual imperative accessor would be getMagnitude
19:45:01 <Eduard_Munteanu> accessor/constructor ?
19:45:14 <edwardk> right now i'm using 'getting'
19:45:17 <ddarius> fetch/set?
19:45:18 <edwardk> but thats fairly verbose
19:45:26 <applicative> projector/editor
19:45:28 <applicative> no
19:45:32 <edwardk> (1 :+ 2)^.fetch magnitude
19:45:46 <parcs`> edwardk: if someone is using your library + mtl then they would probably wouldn't use 'get' anyway
19:45:49 <edwardk> i thought bout just taking something like 'at'
19:45:50 <Eduard_Munteanu> Assuming you have something like   accessor :: Foo a -> a; constructor :: a -> Foo a
19:45:52 <applicative> not bad, fetch
19:45:54 <dmwit> Veinor: The point is that it sort of doesn't "look like" anything. You just have sums and products like usual, but you don't bother defining new data types for your recursive things.
19:46:09 <edwardk> (1 :+ 2)^.at magnitude
19:46:12 <Veinor> edwardk: gette/sette
19:46:20 <applicative> fetch/morph
19:46:33 <otters> acquire/mutate
19:46:49 <dmwit> So for lists, you just write case xs of L () -> {- nil case -}; R (x,xs') -> {- cons case -}
19:46:51 <parcs`> edwardk: you have an 'access' method that is equivalent to 'get', so why not shadow 'get'
19:47:17 <otters> or rather, retrieve/transfigure
19:47:19 <edwardk> because then people need to remember to qualify or constrain their imports
19:47:31 <edwardk> and there are a _lot_ of combinators in Control.Lens
19:47:46 <applicative> otters, I think you have a competing lens library in you
19:47:54 <applicative> cabal install transfiguration
19:47:58 <edwardk> applicative: =)
19:48:09 <otters> cabal install charms potions defense-against-dark-arts
19:48:38 <Veinor> d-a-d-a can never keep a maintainer for a year :/
19:48:39 <dobblego> cabal install lensbraries
19:49:19 <edwardk> 'as' almost works except for all the shadowing warnings
19:49:33 <edwardk> (0,1 :+ 2)^._2.as magnitude
19:49:47 <parcs`> 'getting' is not bad
19:50:16 <edwardk> i want the combinator for making a getter to be small enough to almost vanish ideally
19:50:18 <Veinor> getting is verbose
19:50:37 <Veinor> just call it g!
19:50:45 <edwardk> =)
19:50:59 <applicative>  (0,1 :+ 2)^._2.out magnitude
19:51:32 * hackagebot monad-parallel 0.7.1.1 - Parallel execution of monadic computations (MarioBlazevic)
19:51:52 <edwardk> from ?
19:51:56 <applicative> in is already taken so in/out wont work
19:51:59 <parcs`> @wn get
19:52:00 <lambdabot> *** "get" wn "WordNet (r) 3.0 (2006)"
19:52:00 <lambdabot> get
19:52:00 <lambdabot>     n 1: a return on a shot that seemed impossible to reach and
19:52:00 <lambdabot>          would normally have resulted in a point for the opponent
19:52:00 <lambdabot>     v 1: come into the possession of something concrete or abstract;
19:52:02 <lambdabot> [123 @more lines]
19:52:10 <applicative> they're not quite right i guess
19:52:13 <parcs`> thesaurus time
19:52:23 <edwardk> yeah i've been camped out in there for 10 minutes =)
19:52:54 <parcs`> seize!
19:53:01 <edwardk> to ?
19:53:13 <edwardk> (0, 1 :+ 2)._2.to magnitude
19:53:27 <edwardk> that meets the small requirement, and isn't a common variable name unlike as
19:53:47 <edwardk> and it gets the direction right unlike from
19:53:49 <byorgey> iq
19:53:57 <parcs`> fetch
19:53:57 <byorgey> at least it's memorable
19:54:05 <Cale> Too bad _ isn't an operator symbol, so that we could have an .___. operator.
19:54:07 <parcs`> oh wait it was mentiouned already
19:54:13 <edwardk> i think to is the winner
19:54:34 <byorgey> iq! iq!
19:54:36 <applicative> it is good  if it can be couple with an appropriate other
19:54:39 <edwardk> hah
19:54:39 <Cale> toComeIntoThePossessionOf
19:54:42 <applicative> iq? iq?
19:54:48 <edwardk> why iq?
19:55:04 <byorgey> I just like the sound of it
19:55:15 <byorgey> pronounced like "ick"
19:55:15 <edwardk> i already did the search and replace for s/getting/to ;)
19:55:21 <Cale> haz
19:55:25 <byorgey> hahaha
19:55:28 <edwardk> hah
19:55:35 <applicative> haz and had
19:57:45 <applicative> push and pull
20:00:43 <edwardk> ok, next couple of names i'm not happy with
20:01:08 <edwardk> i have setting and modifying such that setting . modifying = id, modifying . setting = id, and fmap = modifying traverse
20:01:15 <edwardk> but i'm not keen on the names
20:01:45 <edwardk> 'setting' takes a function ((c -> d) -> a -> b) -> SetterFamily a b c d
20:02:02 <edwardk> and its most common use is setting fmap
20:03:01 <edwardk> ideas for better names for setting and modifying?
20:03:20 <edwardk> i can use 'set' but i'd kind of rather reserve that to the operation that actually sets the value of something ;)
20:03:25 <applicative> SetterFamily &co have to go, why not Setters Lenses etc
20:03:54 <edwardk> have to go?
20:03:54 * applicative donates them to defense-against-the-dark-arts
20:04:09 <edwardk> the Family is too verbose for you?
20:04:12 <edwardk> hrmm
20:04:15 <applicative> yeah
20:04:15 <edwardk> Lens and Lenses?
20:04:34 <applicative> thats what i was thinking, but its too strange
20:04:45 <edwardk> the problem is a GetterFamily isn't really a bunch of Getters
20:04:53 * applicative looks
20:05:05 <edwardk> its really a Getter with two of the variables dangling existentially useless
20:06:09 <edwardk> now, that said, nothing actually takes a Getter, i always deal in GetterFamilies and SetterFamilies, same with Folds,  i do deal with Traversals and TraversalFamilies
20:06:22 <edwardk> er i actually have Setters i guess
20:06:50 <edwardk> i could choose to rename GetterFamily to Getter, and FoldFamily to Fold, but the problem is then there is a consistency issue
20:07:26 <edwardk> traverseByteString :: Traversal ByteString Word8
20:07:31 <edwardk> is an actual Traversal
20:08:03 <edwardk> anyOf traverseByteString (==0x80), etc.
20:09:26 <edwardk> If we had the kind of 'super liberal type synonyms' we have in our compiler here i could have type Simple f a b = f a a b b; and type Lens a b c d, so that Simple Lens a b would be defined.
20:09:40 <edwardk> but alas, ghc's liberal type synonyms aren't as liberal as ours ;)
20:09:56 <edwardk> dolio: hah, found a use for those
20:10:21 <dolio> Do we still have those? I forget.
20:10:26 <edwardk> yeah we do
20:10:47 <edwardk> as long as you saturate all the synonyms at the site where they get expanded it works fine
20:11:27 <edwardk> at least 2 of the modules we have rely on them for making aliases for type Relation a = [..a]  and the like
20:11:40 <edwardk> for the union types, etc.
20:12:05 <dolio> Actually your example just looks like regular liberal type synonyms to me.
20:12:18 <edwardk> would that work?
20:12:19 <edwardk> hrmm
20:14:02 <stepkut> mm_freak: any luck on the CPS web stuff?
20:14:17 <dolio> Our extra liberal synonyms were 'type Foo a b = ... ; type Bar f a = f (Foo a)'.
20:14:40 <dolio> Where as long as bar was applied to an f that expanded to fully apply Foo, it was fine.
20:15:36 <applicative> type Simple f a b = f a a b b  compiles
20:15:37 <Cale> {-# LANGUAGE CommunistTypeSynonyms #-}
20:15:50 <edwardk> applicative can you apply it where f is a type alias though?
20:16:03 <latro`a> ...communist?
20:16:04 <edwardk> an unsaturated type alias
20:16:05 <applicative> oh
20:16:06 <dolio> Yes, that is liberal type synonyms.
20:16:08 * applicative studies
20:16:16 <edwardk> trying to get a toy to typecheck
20:16:30 <edwardk> that may be a decent solution to the naming problem
20:16:55 <applicative> type Lens a b c d = (a -> b) -> (c -> d);  type Simple f a b = f a a b b ; type A a b = Simple Lens a b
20:17:27 <applicative> this compiles.  The extension would be annoying, but otherwise it's much better than X XFamily
20:17:40 <edwardk> ah
20:17:51 <edwardk> it worked, i had a b instead of a d somewhere
20:17:55 <edwardk> interesting
20:18:16 <edwardk> interestingly i didn't have to turn on the extension. odd
20:18:17 <applicative> it's nice since it's exactly what you want
20:18:32 <edwardk> @hpaste
20:18:32 <lambdabot> Haskell pastebin: http://hpaste.org/
20:18:47 <hpaste> edwardk pasted “liberal type synonym” at http://hpaste.org/72241
20:18:47 <hpaste> edwardk pasted “liberal type synonym” at http://hpaste.org/72242
20:18:57 <applicative> hm. without the extension my last synonym fails
20:19:08 <applicative> since Lens isnt saturated
20:19:12 <edwardk> does that check locally for you?
20:19:17 <edwardk> and what version of the compiler are you on?
20:19:24 <dolio> 'type Foo a = a ; type Bar f = f Foo ; type Baz f = f Int ; foo :: Bar Baz -> Int ; foo x = x' GHC bombs on that even with LiberalTypeSynonyms. But we worked.
20:19:50 <applicative> yes, it checks   Im using some ghc-7.5
20:19:55 <edwardk> score
20:20:04 <edwardk> no extension requirement, and i can kill half the names
20:20:07 <edwardk> ;)
20:20:35 <edwardk> strikes me as probably a bug that it didn't need the extension but i'll take it
20:20:41 <parcs`> hmm
20:21:05 <parcs`> if you replace Lens with a non-rank-2 type then it won't compile due to Lens being unsaturated
20:21:14 <edwardk> hahaha
20:21:42 <edwardk> what about with the LiberalTypeSynonyms extension?
20:21:58 <parcs`> then it works
20:22:01 <edwardk> k
20:22:08 <parcs`> silly ghc
20:22:09 <edwardk> then i'll put it in prophylactically
20:23:33 <applicative> yes, with Rank2Types you dont need it ... for rank 2 types, otherwise you need LiberalTypeSynonyms, it seems , with this ghc-7.5
20:23:48 <edwardk> same with 7.4.1
20:25:10 <applicative> if the objections to piling on extensions are not strong, this solution really wins it seems to me
20:25:29 <edwardk> i'm going to test it out
20:25:36 <edwardk> it'll play hell with my haddocks
20:25:45 <edwardk> but it should shorten them quite a bit
20:27:31 <edwardk> of course its kinda funny my first example is
20:27:31 <edwardk>  imaginary :: Simple Lens (Complex a) a
20:32:48 <startling> what's the easiest way to have serializable and unserializable dates? I don't need time zones or leap seconds or all that stuff. I just want something that I can read from a string and sort by easily
20:33:43 <Ralith> seconds since epoch
20:33:48 <parcs`> convert to POSIXTime
20:33:54 <startling> oh, good call
20:34:09 <parcs`> see Data.Time.Clock.POSIX
20:34:23 <startling> is there a strptime thing somewhere?
20:36:16 <startling> bonus if there's a strftime too
20:36:51 <Cale> http://hackage.haskell.org/packages/archive/time/1.4.0.1/doc/html/Data-Time-Format.html
20:38:38 <edwardk> yeah the switch to 'Simple' really cleans up the docs
20:44:00 <amatsu> @version
20:44:00 <lambdabot> lambdabot 4.2.2.1
20:44:00 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:44:38 <applicative> that's awesome edwardk
20:47:53 <ddarius> Cloud Haskell would make CPS web stuff more pleasant.
20:48:47 <scooty-puff> i'm considering making more use of ! in data constructors
20:48:55 <covi> :t tell
20:48:56 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
20:49:11 <scooty-puff> is it fair to take any wrapper type that can't be a newtype (dummy other constructors) and making the primary strict?
20:49:15 <scooty-puff> to closer emulate newtype?
20:49:32 <scooty-puff> i.e. WrappedError e = NoMsg | StrMsg String | Error !e
20:50:02 <ddarius> scooty-puff: Why not?
20:50:31 <scooty-puff> just wondering i guess - i tend to never add anything to do with strictness unless performance problems found
20:50:36 <scooty-puff> or used to at least
20:51:00 <scooty-puff> additional noise in the module i guess?
20:51:35 <ddarius> You should consider the semantics and (coarse-grained) performance sooner rather than later.
20:51:43 <scooty-puff> k
20:51:50 <covi> @hoogle tell
20:51:50 <lambdabot> Control.Monad.Trans.RWS.Lazy tell :: (Monoid w, Monad m) => w -> RWST r w s m ()
20:51:50 <lambdabot> Control.Monad.Trans.RWS.Strict tell :: (Monoid w, Monad m) => w -> RWST r w s m ()
20:51:50 <lambdabot> Control.Monad.Trans.Writer.Lazy tell :: (Monoid w, Monad m) => w -> WriterT w m ()
20:52:09 <scooty-puff> coarse-grained as in the general algorithm?
20:52:16 <ddarius> scooty-puff: Is Error _|_ a meaningful value for your WrappedError type?
20:52:19 <scooty-puff> or datatypes, etc. - vs. seq and $!?
20:52:31 <scooty-puff> i see - that makes it clearer - it is not
20:53:03 <scooty-puff> while for StrMsg String i do not have enough knowledge or its use to know one way or another - so it is left as lazy
20:53:48 <ddarius> scooty-puff: You don't really gain much from making a String field strict.
20:54:16 <dobblego> is there a nicer function than mplus for Maybe and mappend for First?
20:54:24 <ddarius> That said, it's usually easier to make up for too much strictness in Haskell than for too much laziness.
20:54:25 <scooty-puff> yeah, i guess not - but say it was a strict type - say IntMap (i believe?) - would that still be a fair assessment?
20:54:36 <scooty-puff> yeah, just data Box a = Box a
20:55:14 <scooty-puff> i guess by strict, if that isn't used correctly here, i mean where whnf is nearly nf
20:56:38 <ddarius> scooty-puff: Usually the concern you'll have is whether large collections of operations will collect tt will all need to be done at once.
20:56:56 <scooty-puff> k
21:00:26 <ddarius> What you want to avoid are APIs that create performance problems that are impossible for the users to do anything about (short of reimplementing them.)  It's usually easier to think about these problems during design than to attempt to "debug" them later.
21:01:29 <scooty-puff> so basically as strict as possible such that a user would not otherwise be aware, and then strict and lazy versions where they might, i would guess
21:02:01 <ddarius> scooty-puff: No.  There are definitely places where you want to be lazy.
21:02:17 <ddarius> If it would lead to streaming behavior, laziness is usually better.
21:03:46 <scooty-puff> when can you tell if streaming behavior may be possible - i imagine lists, but trees that much?  or would it be when going to or from lists?
21:04:11 <scooty-puff> where generally a single result followed by possibly more is available - is what i mean by list
21:04:36 <ddarius> scooty-puff: The rough rule of thumb is if you are collapsing a large structure to a small one (like summing the elements in a list) you want to be eager, while if you are producing a large structure, you usually want to be lazy.
21:05:05 <hpaste> mashed pasted “on the line defining "points" why must i put (round r) instead of just r?” at http://hpaste.org/72243
21:06:00 <mashed> i have snippet which only compiles with (round r), converting a float to an integral.. but actually, the numbers concerned are a range of integers, so i don't understand why 'round' is necessary to make it compile...
21:06:11 <scooty-puff> ddarius, k
21:07:48 <ddarius> scooty-puff: Usually, if you just unfold a function through some recursions you will see what makes sense.  Usually the strictness choices for data types will be driven by the functions you will use on them.
21:08:49 <ddarius> It will reasonably often be the case that both eager and lazy versions will be useful.
21:09:17 <ddarius> Though it is also often the case where there is one that will make sense for more applications than the other.
21:09:44 <ddarius> For example, head strict lists are probably more useful than the lists we currently have, insofar as the fit the usage patterns better.
21:16:41 <mm_freak> stepcut: yes, but i didn't have time to finish it yet
21:17:13 <ddarius> mm_freak: Are you using Cloud Haskell?
21:17:15 <mm_freak> stepcut: actually i managed to implement it as a snaplet, so you may even find it as a package on hackage
21:17:23 <mm_freak> ddarius: nope, why?
21:17:33 <pharaun> cloud haskell? what that
21:19:14 <ddarius> mm_freak: Serializable continuations would make making a CPS-based web framework a snap.
21:19:53 <mm_freak> yeah, indeed, i should consider it
21:19:57 <mm_freak> pharaun: distributed concurrency
21:20:25 <ddarius> For this, the "cloud" part of Cloud Haskell wouldn't be that important.
21:20:37 <mm_freak> ddarius: will it require a GHC patch or is it in GHC 7.4.2?
21:21:00 <mm_freak> i found the distributed-process library
21:21:35 * hackagebot transformers-free 1.0.0 - Free monad transformers (GabrielGonzalez)
21:23:51 <donri> mm_freak: i think the things that are meant to be compiler-supported are faked with TH at the moment
21:24:20 <ddarius> mm_freak: The compiler changes are in 7.4, though they are fairly simple so presumably they'll be in 7.6, but the paper goes over faking it and that's presumably what distributed-process does.
21:25:03 <donri> ddarius: you mean aren't in 7.4?
21:25:29 <mm_freak> yeah, i just read how Closure works
21:25:44 <mm_freak> because i would find it impossible to make (->) serializable
21:27:16 <ddarius> donri: Yes.
21:27:28 <pharaun> mm_freak: like map reduce kind of distributed
21:27:41 <donri> pharaun: like erlang actors kind of distributed
21:27:45 <pharaun> ah
21:28:01 <mm_freak> pharaun: regular haskell concurrency, so no actual computing abstraction
21:28:29 <ddarius> It would be quite easy to build something like MapReduce on Cloud Haskell.
21:30:06 * ddarius tries to think of the best way to hook an antenna to his radio in a way where it could be changed out relatively easily.
21:30:36 <ddarius> I really just need a F connector to SMA and then solder the actual antenna to some coax.
21:31:10 <pharaun> mm_freak: nice
21:38:53 <johnw> Has anyone build GHC on OpenIndiana?
21:39:00 <johnw> I can't get it to "configure"
21:40:53 <td123> johnw: I'm unfamiliar with openindiana but some error msgs or a log are probably the min to help you :)
21:41:54 <startling> so where should I put tests? Mything.Tests? Data.Whatever.Tests?
21:45:25 <gienah> johnw: maybe the SFE ghc spec file might work, or give some hints: http://pkgbuild.sourceforge.net/spec-files-extra/
21:49:17 <gienah> johnw: you could try bumping it to 7.4.2: http://pkgbuild.svn.sourceforge.net/viewvc/pkgbuild/spec-files-extra/trunk/SFEghc.spec?view=log
21:51:36 * hackagebot pipes 2.2.0 - Compositional pipelines (GabrielGonzalez)
21:53:56 <johnw> gienah: great idea
22:00:35 <johnw> here's why it fails: configure:7954: /usr/bin/gcc -o conftest -g -O2 -fno-stack-protector  -L/usr/gnu/lib -R/usr/gnu/lib -Wl,--hash-size=31 -Wl,--reduce-memory-overheads conftest.c  >&5
22:00:35 <johnw> ld: fatal: unrecognized option '--'
22:00:35 <johnw>  
22:00:43 <johnw> the linker is dying on the options
22:00:58 <johnw> i wonder which linker it's trying to use....
22:01:18 <johnw> yep
22:01:23 <johnw> --with-ld=/usr/bin/ld makes it work
22:02:49 <donri> startling: i put them in test/Mything/Test.hs and such
22:03:05 <donri> module names should be singular ;)
22:11:32 <gienah> johnw: line 145 of SFEghc.spec looks incorrect, you may need to specify the correct location of libgmp.so (or libgmp.so.X where X is some number)
22:12:33 <johnw> i'm using something entirely different to build
22:12:47 <johnw> and the make is still going, so that's a good sign
22:12:58 <johnw> are there many shelly users here?
22:24:39 <hpaste> amatsu pasted “must be a shorter way to express this” at http://hpaste.org/72244
22:25:38 <amatsu> I tried to implement the fizzbuzz party game in Haskell, but this doesn't look very nice to me, is there a better way to express it?
22:27:17 <edwardk> applicative: finally got done converting the module
22:27:21 <edwardk> pushing to github
22:28:56 <MostAwesomeDude> amatsu: a `mod` 15 == 0 -- is a common thing. There's not really any shorter way to do it.
22:29:25 <amatsu> MostAwesomeDude: Ok, thanks.
22:29:31 <startling> donri, test/ is a good call, thanks
22:33:27 <donri> edwardk: so, how much stimulants did you consume before embarking on this lens adventure? :)
22:33:51 <edwardk> donri: very little -- speaking of which i'm very low on caffiene ;)
22:34:08 <edwardk> that explains the headache
22:34:37 <donri> hehe
22:40:33 <donri> edwardk: i think you've got some weird grammar in the haddock for Simple
22:40:43 <edwardk> probably
22:40:44 <edwardk> checking
22:40:52 <edwardk> i was nodding off while scribbling words
22:41:16 <donri> oh nevermind you fixed that
22:41:50 <edwardk> Swapped to -- | A 'Simple Lens', 'Simple Setter', or 'Simple Traversal' can be used instead of a 'Lens' 'Setter' or 'Traversal'‗
22:41:50 <edwardk> -- whenever the type variables don't change upon setting a value.
22:42:20 <donri> do those links actually work?
22:42:26 <donri> don't you need, 'Simple' 'Lens'
22:42:47 <edwardk> they don't work
22:42:49 <edwardk> i do
22:42:57 <MostAwesomeDude> Oh man, am I gonna have to change all my lens-based code? :c
22:43:02 <donri> :)
22:44:32 <startling> @quote obsolete
22:44:32 <lambdabot> lispy says: I think communicating with aliens will make unicode obsolete :(
22:44:35 <startling> @quote obsolete
22:44:35 <lambdabot> lispy says: I think communicating with aliens will make unicode obsolete :(
22:44:45 <startling> aw, I thought there was a different one
22:45:20 <edwardk> MostAwesomeDude: its pretty sweet though =)
22:46:22 <MostAwesomeDude> edwardk: Oh, it always is.
22:47:05 <donri> why is Getter a "family", isn't the polymorphism only useful for setting?
22:47:17 <donri> or is it for sake of composition or something
22:47:48 <edwardk> donri: composition, when i define parallel composition the other two parameters need to float free
22:49:07 <edwardk> i originally had them the way you were thinking
22:49:21 <edwardk> Folds also don't in theory need the polymorphism
22:49:39 <edwardk> here the last two parameters dangle existentially quantified and irrelevant
22:49:56 <edwardk> able to take on any type they need to compose
22:50:17 <edwardk> but in a 'negative position' so that that isn't quantification
22:50:28 <edwardk> er universal quantification =(
22:53:52 <edwardk> overall i'm pretty happy with the new design
22:57:31 <donri> would be nice with some concrete examples of how to use all these power-features
22:57:51 <edwardk> yeah i'm working on a writeup
22:58:03 <edwardk> i mostly wanted to get the api design down before i started that in earnest
22:58:28 <donri> sure, it's looking great :)
22:58:40 <edwardk> but basically almost everything there composes
22:58:51 <edwardk> anyOf (traverse.traverseLeft) :: Traversable t => (c -> Bool) -> t (Either c a) -> Bool
22:59:14 <donri> i'm just not sure i fully understand *how* they compose, like, how do you use "mapped"
22:59:40 <edwardk> ghci> mapped ^+= 1 $ [1,2,3]    => [2,3,4]
22:59:41 <donri> is it like, you compose a lens with mapped and set it to a function?
22:59:51 <edwardk> mapped is a Setter, right?
22:59:56 <donri> yea
22:59:58 <edwardk> Setters can be composed with Lenses and Traversables
23:00:05 <edwardk> and Traversals
23:00:09 <edwardk> and the result is always a Setter
23:00:23 <edwardk> so when you stick 'mapped' in, you 'poison' the mix making it only a Setter
23:00:56 <edwardk> adjust (mapped.traverse)
23:00:56 <edwardk>   :: (Functor f, Traversable t) => (c -> d) -> f (t c) -> f (t d)
23:01:25 <edwardk> attempting to read from mapped will fail, attempting to read from anything composed with mapped will fail
23:01:45 <donri> yea that much is obvious :)
23:02:40 <edwardk> so Setters, Lenses and Traversables compose, with Lenses dumbing down to Traversal when mixed with a Traversal, and everything dumbing down to a Setter when mixed with a Setter
23:02:54 <edwardk> and on the other side we have Lenses, Traversals, Folds, and Getters
23:03:33 <edwardk> if you mix a Getter and a Traversal you get a Fold. Lenses and Getters a Getter, Getters and Folds yields a Fold
23:03:47 <edwardk> Getters and Folds don't mix with Setters
23:06:28 <edwardk> since every lens can be used as a traversal and every traversal or getter can be used as a fold you can use the foldOf-like combinators for almost anything
23:06:38 * hackagebot lens 0.7 - Lenses and Lens Families (EdwardKmett)
23:06:53 <startling> *another* lens package?
23:06:54 <donri> so can you use mapped with ^= or does it only make sense with things like ^+=
23:07:15 <edwardk> ^= works, but it sets all targets
23:07:27 <edwardk> startling: it has a very compelling set of reasons for existing
23:08:02 <edwardk> ghci> mapped ^%= (+1) $ [1,2,3]
23:08:02 <edwardk> [2,3,4]
23:08:17 <edwardk> ghci> mapped ^= () $ [1,2,3]
23:08:17 <edwardk> [(),(),()]
23:08:37 <donri> ah so it's like ^%= const
23:08:45 <edwardk> (^=) mapped = (<$)
23:08:49 <startling> edwardk, how's it different from data-lens?
23:09:23 <edwardk> startling: lenses can do polymorphic updates, you can mix getters, setters, folds and traversals with (.) from the Prelude.
23:09:25 <donri> startling: twan-style polymorphic lenses, lots of combinators, not h98
23:09:35 <edwardk> and a whole crapload of combinators
23:10:01 <edwardk> its haskell 98 + a couple of small extras, but the lenses compose with those from lens-family so if you really want to use those you can
23:10:06 <donri> it's more similar to lens-family, but does more with less imports/packages
23:10:24 <startling> interesting
23:10:49 <edwardk> it also includes a notion of a representable functor, where you represent the functor with its lenses
23:10:54 <edwardk> example
23:11:09 <edwardk> data Pair a = Pair { _x :: a, _y :: a }; makeLenses ''Pair
23:11:21 <edwardk> instance Representable Pair where rep f = Pair (f x) (f y)
23:11:28 <edwardk> then you can get Monad, etc. for free
23:11:42 <edwardk> instance Monad Pair where return = pureRep; (>>=) = bindRep
23:12:13 <edwardk> those are pretty scarily powerful
23:12:55 <edwardk> the stuff in Control.Lens.Representable doesn't extend the import list at all, and is a nice tool to have
23:13:11 <edwardk> i had it before in representable-functors but it sat on top of a monstrous pile of extensions and libraries
23:13:14 <startling> when I do forAll someGen someFn where someFn takes multiple arguments, which argument is someGen used for?
23:13:22 <edwardk> here it depends on nothing but this package and stuff in the platform
23:13:28 <startling> (for quickcheck)
23:13:41 <startling> it doesn't seem like the first one
23:14:24 <edwardk> anyways, i was really down on the thought of writing another lens library until the core tricks for this one started coming together
23:14:36 <edwardk> now i'm really happy i spent the time
23:15:10 <donri> me too!
23:15:12 <solrize> is this a new library or the same one as before?
23:15:25 <hov> hi, i have a problem considering a cabal-installed package, could somebody help me?
23:15:31 <edwardk> this is pretty different than any other lens lib ;)
23:15:37 <edwardk> closest to lens-family
23:15:48 <solrize> edwardk i mean is this the same one you released several weeks ago, or a brand new one
23:15:51 <edwardk> but with lens families by default, and heavy use of multilenses (renamed to traversals here)
23:15:53 <edwardk> oh
23:15:59 <edwardk> i started this 2-3 days ago
23:16:11 <solrize> oh heh
23:16:16 <edwardk> the old on was data-lens and was based on store comonad coalgebras
23:16:26 <edwardk> this one is based on van laarhoven lenses
23:16:37 <edwardk> because they compose better and you can mix and match lenses with lens families
23:17:03 <edwardk> (and with setters, getters, folds, and traversals)
23:17:55 <solrize> do any of these things manage to share structure with the old value whe you do an update?
23:18:13 <edwardk> somewhat, not as much as you'd like
23:18:20 <solrize> ic
23:18:20 <edwardk> traverseHead for instance will share the tail
23:18:47 <edwardk> and the parts of the structure that you didn't touch will of course remain shared
23:19:13 <edwardk> but there are some things like
23:19:20 <edwardk> ghci> traverseElement 0 ^%= (+1) $ [1,2,3]
23:19:30 <edwardk> which will rebuild the entire list
23:21:31 <edwardk> i'm tempted to change that ^ mangling character
23:21:48 <edwardk>   , (%=), (~=), (+=), (-=), (*=), (//=), (||=), (&&=), (|=), (&=)   are taken by the state manipulating actions
23:22:07 <edwardk> but =%=, =-=, =+= =*= =/= .etc are free
23:22:15 <edwardk> and look more symmetrical
23:22:36 <startling> i like =_=
23:22:49 <startling> for all _
23:22:51 <hov> could anybody have a clue as to why ghci cant find Data.IxSet while 'cabal install ixset' says ixset-1.0.5 is already installed? (ixset-1.0.5 isnt present in ~/.cabal/packages/hackage.haskell.org either)
23:22:54 <solrize> ^_^
23:23:13 <donri> edwardk: what about ^. then?
23:23:20 <edwardk> i'll keep that one
23:23:31 <solrize> these things are hard to remember and maybe better just use names
23:23:39 <edwardk> foo^.a.b.c is pretty
23:23:46 <solrize> they end up having to be qualified anyway
23:23:47 <solrize> hmm
23:23:48 <edwardk> i have names for the important ones
23:23:49 <donri> edwardk: yea
23:24:03 <donri> hov: see if ghc-pkg list says you have multiple ixsets installed
23:24:31 <hov> ghc-pkg list doesnt contain ixset either
23:25:28 <donri> hov: hm ok maybe try something like, cabal install ixset --reinstall
23:25:55 <hov> i have already done that twice, doesnt work :(
23:26:02 <edwardk> yeah the =foo= versions are much prettier
23:33:06 <jimi_hendrix> this might be a silly question, but is (+) part of a typeclass and, if so, which one?
23:33:22 <hov> i think it is part of Num
23:33:32 <ParahSailin_> :t (+)
23:33:34 <lambdabot> forall a. (Num a) => a -> a -> a
23:33:54 <donri> jimi_hendrix: :i (+) in ghci
23:33:57 <jimi_hendrix> ah yes it is
23:34:24 <jimi_hendrix> and thanks for that tip donri
23:36:16 <solrize> I can't wait til Lens becomes the new haskell record system and tutorials explaining it start appearing.  it will be even better than monad tutorials.  ;)
23:36:40 <startling> haha
23:36:47 <startling> lenses are like burritos
23:37:54 <ParahSailin_> Lens?
23:37:55 <dmwit> Wait, do we need more lens tutorials?
23:38:10 <dmwit> ParahSailin_: http://twanvl.nl/blog/haskell/overloading-functional-references
23:38:32 <dmwit> The only lens tutorial necessary. =)
23:38:49 <MostAwesomeDude> Oh!
23:39:07 <MostAwesomeDude> In comonads, duplicate is the dual of join. I *get* it.
23:39:19 <otters> finally
23:40:16 <MostAwesomeDude> And extend is kind of like bind, but goes the "other way around."
23:40:27 <dmwit> right =)
23:41:05 <MostAwesomeDude> I don't get what it's useful for (yet), but I understand the types now.
23:43:22 <donri> hey that Ref (->) instance looks like fun, though guess we can't have that with lens :(
23:43:37 <ParahSailin_> it would be cool if one could do everything from within ghci
23:43:53 <dmwit> donri: why not?
23:44:00 <ParahSailin_> when im just messing around i dont like to have to switch to text editor
23:44:02 <donri> dmwit: lenses are already (->) right?
23:44:09 <dmwit> eh?
23:44:12 <ParahSailin_> and load modules
23:44:22 <dmwit> donri: In that article, FRef's are lenses.
23:44:35 <donri> dmwit: "lens" the package
23:44:37 <donri> type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
23:44:44 <dmwit> aha
23:44:51 <dmwit> Yes, not with that type.
23:45:13 <dmwit> I'm actually vaguely surprised that's not a newtype.
23:45:26 <donri> well it means we can compose with Prelude.. for one
23:46:09 <dmwit> okaaaay
23:46:18 <jimi_hendrix> anyway, is it possible to overload + such that I can use it organically? I keep getting ambiguity errors. (I have a vector type and I want to make a function that adds two vectors together. I could always call the function "add," but i feel using + would look nicer)
23:46:24 <dmwit> ParahSailin_: Modern ghci can do everything.
23:46:29 <donri> dmwit: have you read http://www.twanvl.nl/blog/haskell/cps-functional-references
23:46:41 <dmwit> jimi_hendrix: Yes, declare an instance of Num for Vector.
23:47:03 <ParahSailin_> when defining a function, ghci doesnt let me do the :: type definition line
23:47:05 <dmwit> donri: Yes.
23:47:20 <dmwit> ParahSailin_: Like this:
23:47:21 <hov> ParahSailin_: have you tried the combination of emacs + haskell-mode? ive recently started using it and it works surprisingly well - you have a text buffer (for your program) and a ghci buffer, and all you have to do to load your program into ghci is press C-c C-l (ctrl+c ctrl+l)
23:47:30 <dmwit> > let foo :: [a] -> [a]; foo xs = xs ++ xs in foo [1..5]
23:47:32 <lambdabot>   [1,2,3,4,5,1,2,3,4,5]
23:47:42 <ParahSailin_> i only know vim
23:47:50 <dmwit> ParahSailin_: In ghci, you can leave off the "in foo [1..5]" part to make the binding semi-permanent.
23:47:59 <donri> jimi_hendrix: i bet vector is a monoid though?
23:48:00 <startling> hmm, is there a nice way to fold over a (a -> Maybe b) function?
23:48:18 <dmwit> ParahSailin_: (And this particular feature doesn't even require a modern ghci. =)
23:48:27 <dmwit> startling: Define fold.
23:48:34 <donri> jimi_hendrix: so import Data.Monoid and add vectors together with <>
23:48:34 <dmwit> startling: There's lots of facilities for using values of that type.
23:48:48 <ParahSailin_> i dont understand, whats 'in' do
23:49:00 <ParahSailin_> :t in
23:49:01 <lambdabot> parse error on input `in'
23:49:01 <dmwit> It's just syntax. It delimits the edges of a collection of bindings.
23:49:10 <dmwit> "let" on one end, "in" on the other
23:49:46 <ParahSailin_> :t let
23:49:46 <dmwit> Compare:
23:49:47 <lambdabot> <no location info>: not an expression: `let'
23:49:49 <dmwit> ?let x = 3
23:49:51 <lambdabot>  Defined.
23:49:51 <dmwit> > 3
23:49:53 <lambdabot>   3
23:49:54 <startling> I want to foldl fn m ks, where fn :: (a -> b -> Maybe a) and ks :: [b]
23:49:55 <dmwit> > let x = 3 in x
23:49:56 <lambdabot>   3
23:49:57 <donri> edwardk: hey is Prelude.. the only reason Lens isn't a newtype?
23:50:07 <edwardk> no
23:50:11 <dmwit> > let y = 3 in y -- just so as not to confuse this with the previous x
23:50:12 <lambdabot>   3
23:50:23 <dmwit> :t foldM
23:50:24 <ParahSailin_> ?let derp :: a -> a -> a
23:50:25 <lambdabot>  <local>:12:0:
23:50:25 <lambdabot>      The type signature for `derp' lacks an accompanying binding
23:50:25 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
23:50:25 <edwardk> mix and match it with Getters, Setters, Folds and Traversals with a newtype in the mix
23:50:34 <dmwit> startling: ?
23:50:35 <edwardk> you need MPTCs and a whole mess of stuff
23:50:55 <MostAwesomeDude> > let x = 2; y = 3 in x + y
23:50:56 <lambdabot>   5
23:50:57 <startling> dmwit: oh, nice, didn't see that for some reason
23:50:59 <dmwit> ParahSailin_: You need to give the definition. e.g.:
23:50:59 <startling> thanks!
23:51:10 <dmwit> ?let true :: a -> a -> a; true t f = t
23:51:12 <lambdabot>  Defined.
23:51:15 <dmwit> ParahSailin_: Same deal in ghci.
23:51:26 <dmwit> (as I tried to say above, but not clearly, I guess)
23:51:29 <ParahSailin_> oh, so semicolon separates lines
23:51:41 <donri> dmwit: ^ what edwardk said
23:52:03 <dmwit> ParahSailin_: Sort of. Actually, lines are sugar for semicolons, not the other way around. =)
23:52:32 <ParahSailin_> ok and also that indentation matters thing is kinda tricky in ghci
23:52:42 <quintessence`> ParahSailin_: you can alaso use :{ and :} in ghci to type multiline things
23:53:18 <donri> or explicit braces and semicolons
23:58:34 <hov> donri: about my problem, when i try to manually install ixset with runhaskell Setup configure it says: Setup: At least the following dependencies are missing: safecopy -any, syb-with-class >=0.6.1. safecopy does show up in ghc-pkg list, while syb-with-class doesnt (syb does, though) and when i try to cabal install syb-with-class it says i already have syb-with-class-0.6.1.3, any ideas?
