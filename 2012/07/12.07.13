00:00:07 <Cale> So it'll take a bit of work to build it, it's pretty out of date.
00:00:19 <Martin_Vetter> I'm running cabal update now
00:00:31 <Martin_Vetter> to get recent package list
00:00:46 <Cale> you won't just be able to cabal install it, you'll have to cabal fetch the source and edit it
00:00:56 <fmap> kizzo: getMass returns IO ForeignPtr
00:01:00 <Martin_Vetter> hmm....how to do that Cale :)
00:01:19 <Martin_Vetter> It's the only Babylon perfect AI available and I really want to perfect my game :)
00:02:14 <Martin_Vetter> yeah...it won't cabal install it :)
00:02:35 <kizzo> fmap: Yes, I have checked the documentation.  I don't know how to use that though, is what I'm saying..
00:03:03 <kizzo> I'm now thinking this 'Typable' thing (http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable.html) can be used as a way to turn that into the Float that I need (I guess).
00:03:12 <Martin_Vetter> any ideas? :s
00:03:56 <Cale> It's funny that we have a bunch of people asking about this old unmaintained package all of a sudden :)
00:04:08 <Cale> I seem to recall someone talking about this the other day
00:04:28 <Martin_Vetter> I think it's because the game has been rereleased
00:04:42 <Martin_Vetter> maybe that's why people are interested in the perfect AI :)
00:04:46 <kizzo> The struct defined at http://ode-wiki.org/wiki/index.php?title=Manual:_All&printable=yes#Mass_functions is what I need exactly I think, and I think that ForeignPtr is a pointer to that structure.. ok..
00:04:54 <Martin_Vetter> Is it possible to create a standalone .exe file for it?
00:04:56 <kizzo> I guess I have to read about pointers..
00:05:19 <Martin_Vetter> In that way, those interested in the game could play it without haskell knowledge :)
00:05:27 <Cale> Martin_Vetter: yes, if someone can work on it to the point of getting it to build
00:05:50 <Cale> Or at least, an exe together with the wx libraries for windows.
00:06:02 <Martin_Vetter> Will someone be willing to do that :)
00:06:05 <Martin_Vetter> could you do it Cale
00:06:09 <Cale> (I'm not on Windows, so it won't be me)
00:06:23 <Martin_Vetter> I would be willing to pay for the trouble to anyone taking the task :)
00:06:23 <Cale> I could possibly make you a linux binary
00:06:57 <Martin_Vetter> 10$ to anyone who make a windows standalone .exe of http://hackage.haskell.org/package/babylon/
00:07:19 <shachaf> You're better off getting people to do it out of the kindness of their heart.
00:07:19 <Martin_Vetter> Could i run that in windows Cale? :)
00:07:25 <kizzo> What I'm really trying to do is call setMass (http://hackage.haskell.org/packages/archive/HODE/2008.10.27/doc/html/Physics-ODE-Body.html), but you would have to know how to construct a Mass, and that is hard, so far.
00:07:53 <Martin_Vetter> shachaf: I know, but I find it fair to pay people for their time and trouble. :)
00:10:24 <shachaf> I imagine the fair market rate for that amount of time from someone who can do that is much higher than $10. :-)
00:10:37 <shachaf> But people tend to be happy to be helpful for free, under reasonable circumstances.
00:10:38 <Martin_Vetter> Anyone who is able to make a standalone windows .exe of http://hackage.haskell.org/package/babylon/ I'm totally noob but really needs it :)
00:10:55 <Martin_Vetter> <shachaf>: meant as symbolic payment. :)
00:11:41 <wiz> Martin_Vetter, the problem is the package needs older platform or patching the source...
00:12:16 <Martin_Vetter> wiz: hmm...I see...but I think it's a very basic script :)
00:12:52 <Martin_Vetter> wiz: It's just really annoying because it's the only available perfect AI for the game :/
00:13:28 <Martin_Vetter> (And it's a really facinating game, btw.)
00:13:39 <mgsloan> couldn't an old version of the Haskell platform be used?
00:14:34 <wiz> mgsloan, yeah, but someone have to install it.
00:15:17 <mgsloan> isn't it fairly straightforward?
00:15:28 <frerich> I do have ghc 7.0.2 installed here, but I don't have much experience with cabal so if you tell me what to do I can give it a try in a separat console.
00:15:36 <Martin_Vetter> I would be really greatfull to anyone who helps...I have been trying to make this game work for days :/
00:16:42 <frerich> FWIW, a simple 'cabal update' followed by 'cabal install babylon' yields http://hpaste.org/71386 for me.
00:17:56 <frerich> heh, there's actually a stackoverflow.com question for this: http://stackoverflow.com/questions/7375719/cabal-install-dependency-error-base-was-excluded-because-of-the-top-level-de
00:18:56 <Martin_Vetter> Seems like I've put you guys up to the challenge :-)
00:19:09 <frerich> nah, I'm at work, don't have time to really tinker with this.
00:19:19 <frerich> If it would've just started building I could've done it in the background.
00:20:01 <Martin_Vetter> frerich: Thanks for trying anyway
00:20:39 <Martin_Vetter> Anyone else who are able to make a standalone windows .exe of http://hackage.haskell.org/package/babylon/
00:36:45 <Martin_Vetter> Anyone who are able to make a standalone windows .exe of http://hackage.haskell.org/package/babylon/
00:37:47 <shachaf> Martin_Vetter: I think everyone in here has seen your reqeust by now. :-)
00:51:24 * hackagebot egison 2.1.15 - An Interpreter for the Programming Language Egison (SatoshiEgi)
00:54:23 <mm_freak> why isn't there any haddock documentation on digestive-functors?
00:55:27 <mm_freak> neither on hackage, nor when i installed locally
00:55:45 <Nereid> did you tell it to build documentation
00:58:27 <mm_freak> Nereid: of course
00:58:38 <mm_freak> again:  no docs on hackage either
01:27:38 <wiz> Is http://hackage.haskell.org/package/bcrypt-0.0.3 package a good choice for a login-password checking?
01:28:10 <shachaf> bcrypt is a good choice.
01:28:20 <ddfreyne> +1 for bcrypt
01:28:22 <shachaf> If that package binds to bcrypt reasonably, then it's a good choice.
01:29:07 <shachaf> That package looks reasonable.
01:33:48 <roconnor> +1 for scrypt
01:34:29 <shachaf> roconnor: scrypt is good too, though it's not what wiz is using.
01:34:48 <shachaf> I don't think the difference between bcrypt and scrypt matters that much for most purposes. :-)
01:35:11 <cads> Hehe, mathematicians don't bat an eyelash at using the "monad as a monoid in an endofunctor category" notion
01:35:14 <shachaf> You can use scrypt. It'll be good too, possibly somewhat better.
01:35:32 <cads> eg, the second sentence of this : http://nlab.mathforge.org/nlab/show/finitary+monad
01:36:11 <roconnor> scrypt is a bit more risky than bcrypt I guess
01:36:50 <cads> oh yay, finitary monads are equivalent to lawvere theories <3
01:37:10 <cads> hey! this is not #haskell-blah, at all!
01:40:52 <kuribas> I need to have a structure for parameters in my music notation program.  Would it be better to use a search tree, or a very large structure with all parameters?
01:41:09 <wiz> omg bcrypt with level 14 is real slow...
01:41:27 <kuribas> But changing one parameter requires copying the whole structure.
01:42:00 <kuribas> And a search tree doesn't allow the individual parameters to be typed...
01:42:12 <shachaf> There's no general-purpose answer to a question like that, I think.
01:42:26 <shachaf> You should probably abstract this type at any rate.
01:43:01 <hbtt> I'm testing out a prime sieve algorithm I saw and I can't get it to import the Data.Map module properly. What is wrong here: http://pastebin.com/tP0Q6hFA ?
01:43:03 <mauke> The paste tP0Q6hFA has been copied to http://hpaste.org/71388
01:43:26 <shachaf> hbtt: The problem is not with your import Data.Map, it's with everything else.
01:43:38 <quicksilver> kuribas: "changing one parameter requires copying the whole structure" - well, I don't know what you mean by 'structure' but that probably isn't true.
01:43:38 <shachaf> I would say that your indentation is messed up if you had any indentation. :-)
01:43:47 <hbtt> It's the code from the paper, verbatim.
01:43:51 <shachaf> As it is, you should add indentation.
01:44:01 <shachaf> hbtt: Well, it got unindented somewhere along the way.
01:44:07 <kuribas> quicksilver: For example if I put all the parameters in one structure?
01:44:10 <hbtt> Will indenting things make it run?
01:44:14 <quicksilver> kuribas: what's a 'structure'?
01:44:20 <kuribas> quicksilver: datatype
01:44:22 <shachaf> hbtt: Maybe? It'll make it less wrong, at any rate.
01:44:47 <shachaf> quicksilver: Well, if you have a record data Foo = Foo { x1 :: T, ..., x100 :: T }, then changing any value will copy 99 pointers.
01:44:52 <shachaf> I assume that's what kuribas means.
01:44:56 <kuribas> yes
01:45:01 <quicksilver> copying 99 points is incredibly fast
01:45:15 <shachaf> Sure.
01:45:34 <shachaf> I think that a type like this will probably be abstracted anyway, so worrying about it is probably premature optimization.
01:45:52 <quicksilver> if you've written a "music notation program" in which the act of copying 99 pointers when a parameter is changed becomes a CPU bottleneck, I think you have written something very odd :)
01:45:55 <cads> that's just opera
01:46:03 <cads> err, wrong channel :D
01:46:17 <silver> what's wrong with you!
01:46:18 <silver> :P
01:46:21 <quicksilver> cads: I think your comment would be applicable in most channels at most times.
01:46:23 <kuribas> quicksilver: Yes, that could be true...
01:46:27 <hbtt> shachaf: ok, here it is, with indentation http://hpaste.org/71389
01:46:36 <hbtt> I get "parse error: Map.empty"
01:46:45 <cads> quicksilver, ;_
01:46:47 <cads> ;)
01:46:58 <quicksilver> hbtt: you can't use ` in a identifier
01:47:01 <kuribas> shachaf: I wonder how I can make parameters with a different type.
01:47:02 <shachaf> hbtt: You want "sieve'", not "sieve`".
01:47:03 <quicksilver> hbtt: it was probably supposed to be '
01:47:05 <quicksilver> which you can.
01:47:18 <shachaf> hbtt: Don't copy code out of PDFs. :-(
01:47:40 <Botje> kuribas: what kinds of parameters are you talking about?
01:47:57 <Botje> and what types do you  have in mind?
01:48:06 <Botje> because you can create a tuple / record with different types just fine.
01:49:04 <kuribas> For example: different spacings, time signature, ...
01:49:25 <hbtt> shachaf: Changing it to "subsieve" gets "Parse error on subsieve"
01:50:12 <shachaf> hbtt: I don't know! You should find the original code instead of trying to fix code copied-and-pasted from a PDF.
01:50:33 <shachaf> And when you make changes, you should @paste the full change, along with the exact compiler error.
01:50:49 <shachaf> Otherwise people have to go to a lot of trouble to help you, and then they don't end up doing it at all. :-)
01:50:57 <hbtt> OK. What is @paste?
01:50:59 <silver> I know that paper
01:50:59 <kuribas> Botje: For example, I want to lookup the current time signature, it should return (Int, Int).
01:51:13 <Botje> so you want to support multiple time signatures?
01:51:19 <shachaf> hbtt: hpaste.org
01:51:30 <kuribas> Botje: yes
01:51:32 <Botje> then that should be reflected in the sturcture of your data
01:52:08 <Botje> something like type Music = [Part] (with data Part = Part Signature [Note] or somesuch)
01:52:34 <Botje> or maybe you want [Note] to be a Map Instrument [Note] instead
01:52:44 <hbtt> Code: http://hpaste.org/71390 . I get " parse error on input `subsieve'."
01:53:04 <hbtt> Original code is page 6 here: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf .
01:53:13 <shachaf> hbtt: You should add the exact compiler error to your paste in the future.
01:53:23 <shachaf> hbtt: For now, indent using spaces instead of tabs.
01:53:36 <hbtt> shachaf: Ok. Sorry, I'm new to this.
01:55:59 <kuribas> Botje: The time signature can change during the piece too.
01:57:48 <hpaste> “david feng” pasted “a simple program” at http://hpaste.org/71391
01:58:15 <Botje> kuribas: of course. that's why you have multiple parts
01:58:56 <Botje> damn, I wish hpaste had support for google translate.
01:59:36 <Botje> kuribas: as with all projects, try to work out what your data structures will look like first and which attributes belong to what scope
02:00:03 <hpaste> “david feng” annotated “a simple program” with “a simple program (annotation)” at http://hpaste.org/71391#a71392
02:00:56 <frerich> Botje: http://translate.google.com/translate?sl=auto&tl=en&u=http%3A%2F%2Fhpaste.org%2F71391
02:01:12 <kuribas> Botje: I see.  I basicly have to have two large data structures, one for the logical structure of the music, and another to contain the graphical elements, and to work out the constraints on them...
02:01:33 <Botje> kuribas: ideally the graphical elements are derived from the logical structure
02:02:01 <kuribas> Botje: of course they are!
02:02:06 <Botje> kuribas: unless you're talking about annotations like 'crescendo' and those bow-like things that say 'please play these notes together'
02:02:26 <kuribas> slurs
02:02:42 <kuribas> That's what the bow-like are called :)
02:02:47 <Botje> man, i could really go for some slurm right now.
02:03:52 <Botje> kuribas: but yes, separating content from presentation sounds like a very good idea
02:04:01 <Botje> hell, it *is* a very good idea :P
02:04:46 <kuribas> yeah :)  Generating a good layout is quite a complex thing.
02:05:17 <kuribas> Because the computer is 2D, and music layout 3D.
02:06:03 <Botje> 3D because of multiple instruments, or .. ?
02:06:43 <kuribas> multiple voices on a staff, different graphical elements that have to fit together nicely...
02:07:09 <Botje> ah. yeah, those sound tricky :)
02:07:13 <kuribas> (slurs, accidentals, dynamics, annotations, ...)
02:08:30 <kuribas> And then handling line a page breaks, for which I want to use an algorithm like TeX.
02:09:26 <Botje> or you could output tex and be done with it ;)
02:09:37 <Botje> I saw a music-notation thing pass by in my yearly texlive update
02:09:44 <kuribas> MusicTex :)
02:11:11 <kuribas> I have already implemented the TeX algorithm in haskell, using lazyness :)
02:12:24 <kuribas> The main algorithm is only 7 lines :)  I imagine the C implementation is much longer.
02:12:39 <Botje> hehe
02:12:40 <Botje> cool
02:13:47 <kuribas>  http://kuribas.hcoop.net/optimalbreak.hs
02:15:37 <kuribas> It's a large project, I am not sure what's the best way to start...
02:15:56 <kuribas> Maybe I should design the graphical layout structures first...
02:19:45 <ksf> why does readprocess send \ETX via stdin?
02:24:40 <Botje> well, ETX is 'end of text' :)
02:26:25 <t7> has anyone heard of something that can build a graph from constraints?
02:27:35 <t7> i guess its an NP complete problem
02:27:54 <t7> fucking NP
02:30:24 <kuribas> t7: there is a lot of literature on constraint processing, but it is usually done with logic languages...
02:30:49 <b__> what's the most straightforward way to get the directories in a directory, and ONLY the directories
02:31:27 * hackagebot egison 2.1.16 - An Interpreter for the Programming Language Egison (SatoshiEgi)
02:32:41 <simon> is there a function for lists foo so foo i x replaces the ith index of the list with the value x?
02:33:27 <t7> Simon, you probably want an array or vector of some sort
02:33:57 <fmap> there isn't but you can easily define it yourself
02:34:43 <Botje> simon: foo i x xs = let (before, _:after) = splitAt i xs in before ++ (x:after)
02:34:52 <simon> t7, I'm not sure of the difference between an array and a vector.
02:34:56 <companion_cube> t7: give a look at datalog, if your constraints fit the language
02:35:03 <Botje> simon: but Data.Array is very probably a better fit.
02:35:08 <srhb> simon: It's not a very large difference anyway.
02:35:18 <companion_cube> t7: since binary relations can be interpreted as a graph
02:35:26 <Botje> simon: arrays have O(1) access and update, vs O(n) access and update
02:35:47 <srhb> Botje: What? Vectors have O(n) update?
02:36:04 <Botje> srhb: i was talking arrays vs lists
02:36:11 <srhb> Botje: Ah.
02:36:24 <Botje> arrays vs vectors was t7
02:36:29 <kuribas> But that only true for mutable Arrays, right?
02:36:36 <srhb> :-)
02:37:15 <hpaste> “david feng” annotated “a simple program” with “a simple program (annotation) (annotation)” at http://hpaste.org/71391#a71395
02:37:23 <fmap> kuribas: why?
02:37:54 <b__> or is there a library for common operations like finding a list of directories?
02:37:55 <kuribas> Updating a nonmutable array requires copying the whole array...
02:38:15 <fmap> not really
02:38:19 <srhb> b__: As in searching the file system for a number of named directories?
02:38:21 <simon> kuribas, does it? I thought the compiler could do tricks.
02:38:36 <Botje> kuribas: if you can prove there's only one reference to it you can do an in-place update
02:39:12 <Botje> kuribas: likewise, you can layer some 'update nodes' around the array and only copy every 50 updates or somesuch
02:39:29 <b__> srhb: as in getting a list of subdirs of a given dir, excluding files (without doing IO twice; once for dir contents, and another for determining if it is a dir or file)
02:39:51 <srhb> b__: Read directories, catch exceptions if it is not a directory.
02:40:02 <companion_cube> Botje: but is it done in practice with haskell/ghc implementation?
02:40:25 <Botje> no idea.
02:40:27 <srhb> @type doesDirectoryExist
02:40:29 <lambdabot> Not in scope: `doesDirectoryExist'
02:40:34 <kuribas> Botje, simon, I got my information from here: http://www.haskell.org/haskellwiki/Arrays
02:40:37 <srhb> b__: It's in System.Directory
02:40:39 <t7> companion_cube: datalog looks perfect :)
02:40:40 <b__> yeah
02:43:18 <companion_cube> t7: you should be able to find quite efficient implementations on the Internet, and there is a lot of literature about datalog :)
02:44:48 <t7> someone should implement it in javascript so i can try it in the browser
02:45:15 <hpaste> “david feng” annotated “a simple program” with “a simple program (annotation) (annotation) (annotation)” at http://hpaste.org/71391#a71396
02:45:58 * frerich enjoys reverse-engineering the thinking of "David Feng" by reading the annotations.
02:46:35 <companion_cube> t7: there's a lua implementation ^^
02:52:45 <b__> srhb, for the record I was looking for: getSubDirs dir = getDirectoryContents dir >>= filterM (doesDirectoryExist . (dir ++))
02:53:45 <srhb> b__: Really, how does that handle the case of files? fail?
02:54:15 <b__> it just leaves them out
02:54:43 <srhb> I don't understand how that works, but cool. :D
02:55:18 <b__> well doesDirectoryExist returns IO Bool
02:55:32 <srhb> Oh, I thought it would produce an exception given a file, not IO False
02:55:37 <srhb> Then I see, much simpler. :)
03:14:09 <Penetrator> I'm getting "Conflicting definitions of gridSize" in the following:
03:14:12 <Penetrator>  case (m, sh, sv) of
03:14:13 <Penetrator> <Penetrator>                 (_, gridSize, gridSize) -> []
03:14:13 <Penetrator> <Penetrator> i'm getting "conlficting definitions for gridSize"
03:14:13 <Penetrator> <Penetrator> (its defined in the top level
03:14:40 <Penetrator> hmm paste error, let me try again:
03:14:51 <Nereid> Penetrator: well yes, you can't bind two things to gridSize
03:14:52 <Penetrator> case (m, sh, sv) of
03:14:52 <Penetrator>                 (_, gridSize, gridSize) -> []
03:15:13 <Penetrator> Nereid: it's defined in the top level
03:15:18 <Penetrator> gridSize = 2
03:15:31 <Penetrator> I want to match that free variable
03:15:34 <Nereid> well, it's making two new bindings to gridSize
03:15:37 <Nereid> you can't put expressions in patterns.
03:15:53 <Nereid> you'll just have to test if sh and sv equal gridSize.
03:16:17 <Penetrator> hmm so I cant use case statements?
03:16:30 <Nereid> not like that, no
03:16:30 * hackagebot hakyll 3.4.0.0 - A static website compiler library (JasperVanDerJeugt)
03:16:31 * hackagebot mime-types 0.1.0.0 - Basic mime-type handling types and functions (MichaelSnoyman)
03:16:34 * hackagebot wai 1.3.0 - Web Application Interface. (MichaelSnoyman)
03:16:44 <Penetrator> thanks... maybe i can do a nested case statement
03:17:06 <Nereid> or you could use guards
03:17:08 <Nereid> with the case
03:18:03 <Nereid> case (m, sh, sv) of (_, sh, sv) | sh == gridSize && sv == gridSize -> []
03:18:06 <Penetrator> like this (_,l,v) -> |  l == gridSize and v == gridSize?
03:18:10 <Nereid> or so
03:18:11 <Nereid> yeah
03:18:17 <Nereid> &&, not and
03:18:22 <Penetrator> ah yes
03:18:31 <Penetrator> thanks very much! will try that!
03:18:59 <shachaf> You may also be able to use a comma there.
03:19:29 <shachaf> > let f x | x > 2, x < 5 = "yes" | otherwise = "no" in (f 3, f 6)
03:19:30 <lambdabot>   ("yes","no")
03:19:43 <Nereid> ah, yes
03:20:21 <quicksilver> I always forget about commas in guards
03:20:26 <quicksilver> they seem a bit suprising really
03:20:37 <Nereid> is there any semantic difference?
03:20:50 <shachaf> Nereid: With pattern guards, commas are more useful.
03:20:57 <shachaf> With regular guards I think it's equivalent.
03:21:28 <Nereid> ah, I'm not familiar with pattern guards.
03:21:35 * hackagebot wai-app-static 1.3.0 - WAI application for static serving (MichaelSnoyman)
03:21:37 * hackagebot wai-eventsource 1.3.0 - WAI support for server-sent events (MichaelSnoyman)
03:21:39 * hackagebot wai-extra 1.3.0 - Provides some basic WAI handlers and middleware. (MichaelSnoyman)
03:21:41 * hackagebot wai-frontend-monadcgi 1.3.0 - Run CGI apps on WAI. (MichaelSnoyman)
03:21:43 * hackagebot wai-handler-fastcgi 1.3.0 - Wai handler to fastcgi (MichaelSnoyman)
03:21:45 <Nereid> alright.
03:22:52 <Nereid> ok, I can imagine pattern guards being pretty useful.
03:23:28 <shachaf> > let f x y | Just x' <- x, Just y' <- y = show (x',y') | Just x' <- x = show x' | otherwise = "no" in (f (Just 1) (Just 2), f (Just 3) Nothing, f Nothing (Just 4), f Nothing Nothing)
03:23:30 <lambdabot>   ("(1,2)","3","no","no")
03:23:32 <shachaf> Something, I don't know.
03:26:45 * hackagebot suspend 0.1.0.0 - Simple package that allows for long thread suspensions. (PetrPilar)
03:26:47 * hackagebot wai-handler-launch 1.3.0 - Launch a web app in the default browser. (MichaelSnoyman)
03:26:49 * hackagebot wai-handler-scgi 1.3.0 - Wai handler to SCGI (MichaelSnoyman)
03:26:51 * hackagebot wai-test 1.3.0 - Unit test framework (built on HUnit) for WAI applications. (MichaelSnoyman)
03:26:53 * hackagebot wai-websockets 1.3.0 - Provide a bridge betweeen WAI and the websockets package. (MichaelSnoyman)
03:31:56 * hackagebot warp 1.3.0 - A fast, light-weight web server for WAI applications. (MichaelSnoyman)
03:31:58 * hackagebot warp-static 1.3.0 - Static file server based on Warp and wai-app-static (MichaelSnoyman)
03:32:00 * hackagebot warp-tls 1.3.0 - SSL support for Warp via the TLS package (MichaelSnoyman)
03:32:50 <t7> datalog is really cool
03:35:40 <t7> prolog is cool too
03:35:50 <akamaus> Hi, I've downloaded and installed a binary package ghc-7.4.1. Now I'm trying to install packages into it. I get this http://hpaste.org/71397 for cabal-install
03:36:37 <akamaus> I'm on ubuntu lucid, so I can't just install a binary haskell-platform
03:57:40 <Penetrator> @hoogle [a] -> [[a]]
03:57:41 <lambdabot> Data.List inits :: [a] -> [[a]]
03:57:41 <lambdabot> Data.List permutations :: [a] -> [[a]]
03:57:42 <lambdabot> Data.List subsequences :: [a] -> [[a]]
04:00:02 <Penetrator> @hoogle m a -> m (m a)
04:00:03 <lambdabot> Data.Sequence inits :: Seq a -> Seq (Seq a)
04:00:03 <lambdabot> Data.Sequence tails :: Seq a -> Seq (Seq a)
04:00:03 <lambdabot> Data.List inits :: [a] -> [[a]]
04:01:57 <kuribas> Is there a semantic difference between a newtype and a data type, other than a small performance gain?
04:03:15 <kuribas> (and a newtype being less general)
04:03:28 <shachaf> Yes.
04:03:32 <shachaf> @google newtype vs data
04:03:33 <lambdabot> http://stackoverflow.com/questions/2649305/why-is-there-data-and-newtype-in-haskell
04:03:33 <lambdabot> Title: types - Why is there "data" and "newtype" in Haskell? - Stack Overflow
04:04:02 <shachaf> That answer doesn't really answer it...
04:04:10 <shachaf> It should be comparing newtype to a strict data type.
04:04:39 <shachaf> http://www.haskell.org/haskellwiki/Newtype#Examples
04:04:47 <kuribas> It does?
04:06:33 <quicksilver> the semantic difference (one fewer bottom) is somehow not the point, though.
04:06:41 <quicksilver> I think the 'point' is that newtypes are zero-cost
04:06:48 <quicksilver> an illusion known only to the typechecker
04:10:02 <kuribas> quicksilver: But that's just a small performance gain, right?  It doesn't change the complexity of a program.
04:10:27 <quicksilver> it certainly doesn't change the complexity
04:10:40 <mgsloan> right.  But it lets you define a new set of instances for existing data, without overhead
04:10:47 <quicksilver> it's nice to be able ot work purely in the type-checker
04:10:56 <quicksilver> and know you're not affected generated code
04:11:02 <quicksilver> it's basiclaly a "better type rename"
04:11:11 <quicksilver> better than 'type' because it actually creates a new type.
04:12:16 <kuribas> I see.
04:13:07 <Nereid> hence "newtype"
04:17:51 <Nereid> I swear I've asked this once before, but
04:18:08 <Nereid> what's the difference between newtype X = X Y and data X = X !Y
04:18:33 <companion_cube> the ! is for strictness
04:18:36 <Nereid> I know.
04:18:46 <Nereid> newtype also has strictness.
04:19:00 <alpounet> Nereid, the memory representation of X will be the same as Y's
04:19:04 <alpounet> in the former
04:19:14 <Nereid> is there any semantic difference?
04:19:22 <quicksilver> Nereid: that's exactly what we were just discussing.
04:19:27 <Nereid> no
04:19:29 <quicksilver> at least one link was posted.
04:19:39 <Nereid> I'm talking about data with a strict constructor.
04:19:45 <quicksilver> 12:01 < kuribas> Is there a semantic difference between a newtype and a data                  type, other than a small performance gain?
04:19:54 <kuribas> no semantic difference, right?
04:19:56 <quicksilver> 12:03 < shachaf> It should be comparing newtype to a strict data type.
04:20:04 <quicksilver> yes, there is a semantic difference
04:20:20 <Nereid> even with the !
04:20:33 <quicksilver> even with the !.
04:20:40 <quicksilver> case on a newtype is a NOP
04:20:44 <quicksilver> it gets compiled away
04:20:57 <quicksilver> case on a strict data is not a NOP
04:21:37 * hackagebot suspend 0.1.0.1 - Simple package that allows for long thread suspensions. (PetrPilar)
04:21:39 * hackagebot timers 0.1.0.0 - Simple package that implements timers. (PetrPilar)
04:21:53 <Nereid> and how would one see that?
04:21:57 <quicksilver> http://www.haskell.org/haskellwiki/Newtype#Examples
04:22:15 <quicksilver> ^^ I think that has all the different cases (no pun intended)
04:22:21 <kuribas> quicksilver: Couldn't a smart compiler compile away the strict constructor?
04:22:29 <Nereid> ok, I see.
04:22:42 <quicksilver> kuribas: given the semantic difference above, it's not simple to do so.
04:22:58 <quicksilver> I don't think it's technically *impossible* if you translate correctly to accommodate.
04:23:47 <kuribas> Of course when linking with an object file, the compiler must have this information...
04:26:41 * hackagebot wai-app-file-cgi 0.7.0 - File/CGI/Rev Proxy App of WAI (KazuYamamoto)
04:26:43 * hackagebot mighttpd2 2.7.0 - High performance web server on WAI/warp (KazuYamamoto)
04:28:30 <Nereid> oooooooook I understand.
04:28:31 <Nereid> thanks.
04:29:02 <shachaf> quicksilver: Pft, "generated code".
04:29:07 <shachaf> Are you some kind of operationalist?
04:29:28 <beefcube> in practice, can one just ignore "multiple versions of the same package" cabal warnings? I'm tired of fighting with the versions in the cabal file reduce these errors
04:29:28 <quicksilver> shachaf: newtype is just for the operationalists, I think
04:29:41 <beefcube> to* reduce
04:29:55 <quicksilver> shachaf: although GeneralisedNewtypeDeriving is handy, but we can hardly give that as a justification - it's not in the language standard that defines newtype.
04:31:37 * hackagebot timers 0.1.0.1 - Simple package that implements timers. (PetrPilar)
04:33:26 <srhb> What's the tool to visualize threads and cpu usage again?
04:33:32 <srhb> (Or isn't there one for threads?)
04:34:29 <donri> threadscope?
04:34:36 <srhb> That's the one, thanks.
04:35:53 <aristid> well, that was a quick experiment with DataKinds. need to drop it because when loading the module across package boundaries, GHC crashes hard
04:36:25 <donri> supposedly more stable in 7.6
04:36:47 <aristid> donri: yup, i filed a bug on the ghc trac and spj says it's fixed in HEAD
05:00:03 <mgsloan> I just realized why noone wants to use template haskell
05:00:09 <mgsloan> the code for the module has docs
05:00:12 <mgsloan> just not haddocks
05:00:18 <mgsloan> *DOH*
05:02:29 <hpc> maybe if every piece of haskell documentation was cpan style, people could tolerate TH docs
05:02:46 <hpc> but type signatures are just too convenient, even on their own
05:03:13 <mgsloan> Oh yeah, the problem is that TH is mostly data constructors
05:03:17 <mgsloan> none of them documented
05:03:23 <mgsloan> field types help of course
05:03:35 <mgsloan> but there are tons of inline comments, that if you just added a ^ to them
05:03:43 <mgsloan> suddenly the html page would be full of docs
05:03:47 <hpc> heh
05:03:51 <mgsloan> I've been using TH for a half year before realizing this..
05:04:29 <mgsloan> this is what happens when grad students write crucial shit, yo
05:04:44 <hpc> pure speculation on my part, but i think the reason types and field names work so well for documentation is
05:04:58 <hpc> programmers know what THEY would do with a module of that general shape
05:05:12 <hpc> but nobody would ever willingly write template haskell that way
05:05:19 <mgsloan> yeah!  I want to make something that shows you the Hask-graph of a module
05:05:39 <mgsloan> e.g. these are the introductions of the datatypes, these eliminate them, these are combinators on them
05:06:21 <hpc> perhaps with different colored lines for "this returns a pure thing, this has it wrapped in Maybe or something"
05:08:02 <mgsloan> yeah! Or just make those different (yet related nodes)
05:08:18 <mgsloan> /s/nodes)/) nodes
05:08:36 <mgsloan> I'd like to see an IRC client that actually applied those subs :)
05:08:53 <srhb> It was wrong though, so you'd end up being publically humiliated.
05:08:56 <srhb> ;)
05:09:24 <mgsloan> eh, give it some tolerance for error
05:09:28 <srhb> "-)
05:10:31 <hpc> somewhere there is a bot that will print the result of the substitution
05:10:38 <hpc> as applied to the previous line
05:10:40 <srhb> Neat. :P
05:10:58 * hpc saw it on bash.org or similar site
05:27:44 <wiz> :t (||)
05:27:46 <lambdabot> Bool -> Bool -> Bool
05:28:59 <nand`> mgsloan: should be pretty easy to write a script for this in any of the common extendible clients
05:29:01 <nand`> eg. weechat
05:29:22 <nand`> unfortunately, it doesn't offer Haskell scripting. I'd have added it, but I couldn't figure out how to compile a Haskell library
05:29:31 <wiz> icfp 2k12 is a go! http://icfpcontest2012.wordpress.com/task/
05:30:35 <mgsloan> probably so!  But it'd be good to have it default in a number of clients - would lead to an interesting dynamic.
05:30:59 <mgsloan> (potentially an annoying one for those who have clients that don't support it)
05:31:19 <nand`> no more annoying than the current situation
05:32:42 <mgsloan> hahaa
05:32:49 <nand`> wiz: funny
05:33:39 <mgsloan> I heard there was some old chat client that showed what people were typing as they were typing
05:34:05 <nand`> mgsloan: that seems incredibly annoying
05:34:53 <mgsloan> could be, yeah, would lead to a lot more leaked passwords
05:37:39 <mauke> hello from HaL7
05:38:14 <Botje> wasn't that good old chat?
05:39:47 <mgsloan> this is a pretty straightforwardly specified ICFP challenge, might have to give it a swing!  throw some TH at it or someat
05:40:07 <quicksilver> Botje: talk(1) ?
05:40:12 <Botje> or that
05:40:16 <quicksilver> certainly that had the property described.
05:40:27 <quicksilver> mind you, so did google wave :)
05:40:38 <Botje> i vaguely remember early icq also having that property.
05:41:08 <mgsloan> ahh, yeah, it was talk that I'm thinking of - /old/
05:41:28 * quicksilver doesn't remember icq being like that
05:41:33 <srhb> mgsloan: I'm hoping someone will document their efforts and publish afterwards so Haskell noobs can get clever. :D
05:41:39 * hackagebot Hipmunk 5.2.0.9 - A Haskell binding for Chipmunk. (SoenkeHahn)
05:42:49 <frerich> Early ICQ had the "live view" indeed, but you had to start a 'chat' for that (as opposed to sending messages back and forth).
05:43:10 <srhb> Yeah, that was both fun and annoying :P
05:43:12 <Botje> right!
05:43:21 <Botje> i'm not misremembering, yay!
05:43:23 <quicksilver> ah.
05:43:44 <srhb> I still remember my icq number by heart, haven't used it in 15 years or something.
05:43:52 * frerich too
05:43:52 <Botje> 55796362 >:)
05:44:00 <mauke> that's numberwang!
05:44:10 <quicksilver> I think I had a 7 digit one
05:44:10 <applicative> the wikipedia page on lambda lifting begins "Lambda lifting is useless for ICFP Programming Contest participants."
05:44:21 <quicksilver> certainly can't remember it
05:44:30 <Botje> I sadly no longer connect to it because of all the spam and nobody using it anymore.
05:44:47 * frerich hears the "oh-oh!" sound again...
05:44:51 * applicative figures it's true, but the enemy may have planted this disinformation
05:44:53 <frerich> At least it sounded like that when you got a new message.
05:45:10 <nand`> Is  map :: (Functor f, Functor g) => (forall a. f a -> g a) -> Mu f -> Mu g -- used often?
05:45:46 <mgsloan> hmm, so I guess we'll have to find some extensively convoluted way to use lambda lifting in the solution
05:45:48 <nand`> (alternatively, tell me if this type doesn't make sense for generalizing map)
05:46:36 <mgsloan> there ought to be an obfuscated haskell contest
05:46:45 <srhb> I guess the map updating should be dealt with first..
05:49:36 * applicative hadn't realized that he had so often lambda-lifted
05:51:41 * hackagebot async 2.0.1.1 - Run IO operations asynchronously and wait for their results (SimonMarlow)
05:55:02 <mgsloan> debug x = trace (show x) x  -- really needs to be in Debug.Trace or better yet the Prelude.  I've probably typed it in > 100 times
05:56:35 * quicksilver has typed it never.
05:57:38 <nand`> I also use trace_ x = trace x $ return ()
05:58:16 <mgsloan> sometimes this is good:  debug' prefix x = trace (prefix ++ show x) x
05:58:57 <nand`> or possibly debug' name x = trace (name ++ ": " ++ show x) x
05:59:09 <mgsloan> nand`: Ooh, it's a generalized print!
05:59:17 <mgsloan> yup
05:59:44 <mgsloan> s/print/putStrLn/
06:00:19 <scopedTV> me neither, never
06:00:26 <scopedTV> i don't have a need for it that often
06:00:51 <mgsloan> just gotta have your print-based debugging, at least till a decent way of debugging comes along
06:01:06 <srhb> What would be a better way?
06:01:13 <nand`> magic
06:01:14 <scopedTV> REPL + type system
06:01:21 <donri> mgsloan: isn't that traceShow?
06:01:46 <nand`> join traceshow but yeah
06:01:50 <nand`> s/show/Show/
06:02:14 <donri> oh i see
06:02:25 <mgsloan> (and by decent, I don't mean to deride haskell's existing solutions - they're helpful - just as solutions for other languages are helpful)
06:02:42 <mgsloan> yeah, what's nice is that you can jam "debug" into a compositional pipeline and it doesn't upset things
06:02:57 <donri> http://hackage.haskell.org/packages/archive/file-location/0.4.4/doc/html/Debug-FileLocation.html :)
06:03:07 <srhb> mgsloan: I was just curious about what method you'd like to see. :)
06:03:21 <mgsloan> donri: "A version of Debug.Trace.trace that just prints a value. This should be included in Debug.Trace" lol!
06:04:14 <mgsloan> srhb:  Good question.  Partially it's a question of IDE - good depiction of values, relationship between values and the code, yada yada
06:04:32 <srhb> mgsloan: Mkay.
06:04:35 <mgsloan> way of visually associating stack framey things with the code, thunks with the code, etc
06:04:46 <mgsloan> that's just the aesthetic side of things, though
06:05:12 <quicksilver> I find that if I ever have to refactor my code purely to make it easier to debug in the REPL
06:05:31 <quicksilver> i.e to avoid using trace
06:05:42 <mgsloan> the more involved stuff would essentially be the capability to ask things like "where did this value come from?", "where are all the points in the program that mutated this IORef, in reverse chronological order?"
06:05:50 <quicksilver> then I am, in retrospect, glad I made those changes
06:05:53 <nand`> I write most of my code either inside or directly with GHCi
06:05:57 <dada_cetacean> "let larger = [a | a <- xs, a > x]"
06:06:02 <mgsloan> "What would have needed to change for this value to be _this_?"
06:06:11 <dada_cetacean> could someone explain how to parse the quasi-set notation on the RHS?
06:06:12 <nand`> so my code tends to have that property automatically
06:06:16 <mgsloan> (which would then run some suite of solvers orso)
06:06:25 <nand`> (since I'm debugging/testing it in GHCi in the first place)
06:06:29 <mgsloan> nand`: It really depends on what kinds of applications you prefer to write
06:06:40 <nand`> mgsloan: I prefer writing short proof of concepts and algorithms
06:06:47 <quicksilver> dada_cetacean: take elements from 'xs' (call them 'a'), and check if they are > x
06:06:57 <quicksilver> dada_cetacean: and collect those results ('a') which were.
06:06:59 <t7> graphvis is awesome then
06:07:02 <nand`> I also prefer writing libraries over programs, mainly beacuse I am not very creative when it comes to applications of something
06:07:05 <mgsloan> well there you go, perfect for the sort of it-type-checks ---> now it works type dev :)
06:07:18 <dada_cetacean> so "a <- xs" means take elements from xs specifically?
06:07:21 <ClaudiusMaximus> mgsloan: seen "fuzzgrind"?
06:07:33 <quicksilver> dada_cetacean: yes, it means that 'a' gets, in turn, the value of each element of xs
06:07:42 <quicksilver> dada_cetacean: it's like a loop over the elemnets of xs (which must be a list)
06:07:42 <dada_cetacean> quicksilver: thanks
06:07:43 <mgsloan> yeah, I'm not too great at that either.  I'll get around to apps once this programming languages thing works itself out
06:07:51 <srhb> dada_cetacean: You might benefit from learning to desugar list comprehensions and, in turn, do notation.
06:08:00 <mgsloan> ClaudiusMaximus: I haven't!  I take it it's for dysfunctional languages?
06:08:06 <srhb> dada_cetacean: The definitions of >>= and return for the List monad are relevant here :)
06:08:31 <mgsloan> ClaudiusMaximus: Ahh, I think I may have seen papers related to it
06:08:45 <ClaudiusMaximus> mgsloan: it operates on binaries, using a patched valgrind or something
06:10:15 <mgsloan> the idea I saw was roughly building a constraint system for values along related sets of execution paths, and using that abstract interpretation to figure out a clever counterexample input that would cause a new path to be discovered
06:10:30 <nand`> dada_cetacean: it's a bit more complicated since it uses the list monad, but you can just think of it as cartesian set products for now, eg. [(a,b) | a <- xs, b <- ys]; conditions would be akin to intersections: [x | x <- xs, x > 5] is the intersection of (xs) with the set of numbers greater than 5; meanwhile, the first part corresponds to a bijection (from the cartesian product)
06:10:36 <nand`> well, except it's lists and not sets in reality
06:10:58 <dada_cetacean> haha, "<-" even looks like an epsilon
06:11:02 <nand`> (though you'd be pleased to know that the same notation works for actual Sets, with an appropriate GHC extension)
06:12:55 <srhb> What does the constraint actually desugar into? filter?
06:13:05 <MostAwesomeDude> guard, I though.
06:13:08 <MostAwesomeDude> *thought, even.
06:13:15 <srhb> Ah yes, of course
06:15:55 <dada_cetacean> I left my ghci overnight trying to enumerate [1..10000000] and it crashed
06:16:17 <srhb> so xs >>= \a -> guard (a > x) >> return a ?
06:16:39 <MostAwesomeDude> That'd be the list monad version, yes.
06:16:54 <srhb> Does that mean list comprehensions do not always desugar through the list monad?
06:17:25 <wiz> :t guard
06:17:26 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
06:17:57 <MostAwesomeDude> srhb: Actually, I just checked the report; the report desugars LC conditionals with if/then/else.
06:18:04 <srhb> Oh.
06:18:18 <MostAwesomeDude> Yeah, boring. :3
06:19:02 <srhb> :P
06:19:10 <nand`> dada_cetacean: why would it crash? I got to 2729378 when I interrupted it after a few minutes, but it was running in constant memory
06:19:34 <dada_cetacean> I haven't the slightest clue, it just wasn't here when I woke up
06:19:44 <dada_cetacean> maybe I left it running [1..] by accident
06:21:10 <quicksilver> MostAwesomeDude, srhb: LCs actually desugar directly into Core
06:21:19 <quicksilver> in the GHC implementation.
06:21:30 <quicksilver> I think this makes it easier to make sure fusion fires when you want it to.
06:22:27 <MostAwesomeDude> quicksilver: Unsurprising..
06:30:54 <kuribas> Isn't there any work being done on making automatic fusion, for example by partial evaluation?
06:31:47 <quicksilver> I'm not immediately seeing the connection between those two notions, kuribas.
06:31:57 <quicksilver> but partial evaluation certainly plenty of people spend time researching
06:32:02 <quicksilver> and supercompilation which is related
06:32:21 <quicksilver> but I don't think anyone has anything really useful and practical for haskell yet
06:34:48 <kuribas> By partially evaluating expressions, you can eliminate intermediate datatypes...
06:36:28 <quicksilver> oh, I see what you mean.
06:36:49 <quicksilver> Yes, in that sense RULES are sometimes (not always) specific selected partial evaluation
06:37:39 <kuribas> yes
06:40:51 <akamaus> hi
06:40:52 <quicksilver> the trick is working out which bits of partial evaluation are worth doing, I think
06:41:21 <akamaus> does anybody know, if ansi-terminal package works on Windows or not?
06:42:24 <akamaus> I get a bunch of linking errors with ghc-7.4
06:42:56 <aristid> akamaus: oh, it probably doesn't work
06:42:57 <srhb> akamaus: It certainly claims to be Windows compatible.
06:43:04 <aristid> oh? interesting
06:44:13 <aristid> " Compatible with Windows and those Unixes with ANSI terminals, but only GHC is supported as a compiler." indeed
06:44:40 <akamaus> can someone make a quick test? with http://hpaste.org/71400
06:44:58 <donri> akamaus: better post your errors
06:45:09 <mroman> there's a webserver in haskell.
06:45:10 <mroman> nice.
06:45:18 <aristid> mroman: more than one, even.
06:45:22 <donri> also i recommend http://hackage.haskell.org/package/ansi-wl-pprint instead, it uses ansi-terminal itself
06:45:36 <srhb> Works fine on Mac
06:46:18 <aristid> srhb: the package name ansi-terminal is confusing, because i think windows doesn't actually have an ANSI terminal. or does it?
06:47:05 <applicative> akamaus: https://github.com/batterseapower/ansi-terminal/issues/3 ?
06:48:18 <srhb> aristid: I actually have no clue
06:48:41 <mroman> mighttpd seems to lack any useful documentation though.
06:48:53 <aristid> mroman: there's also warp
06:49:47 <akamaus> here is the build log http://hpaste.org/71401
06:49:54 <donri> mighttpd2 uses warp to implement a more traditional webserver
06:51:22 <aristid> akamaus: does that error also happen when you strip out the  ansi-terminal import and function calls from the test?
06:51:30 <mroman> Warp doesn't look like an actual webserver like apache.
06:51:38 <mroman> and I cant seem to find any documentation either.
06:52:00 <donri> mroman: there's a bunch of pdfs for mighttpd, did you see those?
06:52:08 <aristid> mroman: http://hackage.haskell.org/packages/archive/warp/1.2.2/doc/html/Network-Wai-Handler-Warp.html ?
06:52:18 <donri> warp certainly is a webserver, but not like apache no
06:52:27 <aristid> it's for WAI only
06:53:35 <donri> mighttpd basically adds a cgi runner to warp, i think
06:54:23 <aristid> donri: people still use cgi?
06:54:35 <MostAwesomeDude> aristid: Sadly.
06:54:41 <aristid> mroman: if you want a traditional webserver, i think nginx is still hard to beat though
06:54:43 <mroman> I use CGI for my haskell stuff.
06:54:46 <srhb> fastcgi and friends. :) Is fine.
06:54:48 <akamaus> aristid, can you please explain the logic? This way nothing ansi-terminal related remains.
06:54:52 <aristid> mroman: why?
06:55:03 <mroman> Cause a lot of webservers support it
06:55:09 <aristid> akamaus: because the error messages don't seem ansi-terminal related
06:55:38 <mroman> and webframeworks like happstack deliver their own server.
06:55:45 <aristid> mroman: i think most also support FastCGI / SCGI and, even better, reverse proxying
06:56:00 <mroman> Which means I cant use them without internal proxies.
06:56:12 <donri> mroman: well you can use reverse proxying with most webservers
06:56:20 <aristid> warp doesn't depend on internal modules
06:56:43 * hackagebot hspec 1.3.0 - Behavior Driven Development for Haskell (SimonHengel)
06:56:56 <donri> it's much safer and more performant than cgi
06:56:59 <akamaus> aristid, looks like mention of ansi-terminal in cabal file triggers the error
06:57:30 <aristid> akamaus: interesting. i can't really help you, sorry
06:59:38 <cesip> somebody posted "lambada forever" on facebook last night, and i misread "lambda forever"
07:00:08 <srhb> I misread it lambda forever, and then lambda forever again.
07:00:10 <aristid> cesip: probably a typo and he meant lambda
07:00:13 <ment> cesip: i just misread it as "lambda fever"
07:00:14 <applicative> you didn't  misread; it was a typo to begin wit
07:00:22 <applicative> like ment said
07:00:36 <wiz> can't runErrorT catch stuff like 'fromJust Nothing' ?
07:00:41 <applicative> or rather aristid
07:00:46 <wiz> only fail "halt!" ?
07:00:48 <cesip> good to know i'm normal and everyone else is crazy
07:00:52 <wiz> :t runErrorT
07:00:54 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
07:01:06 <wiz> :t error
07:01:07 <lambdabot> forall a. [Char] -> a
07:01:22 <donri> bieber ^W lambda fever!
07:03:08 <mietek> How can I construct a CChar literal?
07:05:08 <applicative> castCharToCChar :: Char -> CChar ?
07:06:59 <zachk1> > '\63'
07:07:01 <lambdabot>   '?'
07:07:08 <mietek> Thanks, missed that
07:07:18 <zachk> @type '\63'
07:07:20 <lambdabot> Char
07:07:40 <zachk> with that and castCharToCChar you should be able to construct whatever you need :)
07:10:32 <zachk> > ['\0'..'\128']
07:10:34 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
07:15:40 <XexonixXexillion> > '\0x3bb'
07:15:42 <lambdabot>   <no location info>:
07:15:42 <lambdabot>      lexical error in string/character literal at chara...
07:16:15 <XexonixXexillion> > '\955'
07:16:17 <lambdabot>   '\955'
07:17:14 <XexonixXexillion> Canhave non ascii characters in a Char
07:17:19 <fmap> > '\x3bb'
07:17:21 <lambdabot>   '\955'
07:17:24 <XexonixXexillion> Can't I have no ascii characters in a char
07:17:42 <XexonixXexillion> non... I seem to fail at keyboard use today
07:18:16 <ment> @type rotate
07:18:17 <lambdabot> forall a. (Bits a) => a -> Int -> a
07:19:43 <mcstar> > putStr "\955"
07:19:45 <lambdabot>   <IO ()>
07:19:54 <hape01> @type Bits
07:19:55 <lambdabot> Not in scope: data constructor `Bits'
07:20:17 <hape01> @src Bits
07:20:18 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:20:50 <hape01> Ypu dont understand what i wish.... ;-)
07:21:32 <hape01> @tellmeabout Bits
07:21:33 <lambdabot> Unknown command, try @list
07:23:06 <fmap> weird, Bool isn't an instance of Bits
07:23:13 <XexonixXexillion> > 'λ'
07:23:14 <lambdabot>   '\955'
07:23:37 <EvanR> XexonixXexillion: Char is any character
07:24:15 <EvanR> not like C
07:25:38 <XexonixXexillion> I know, I'm just surprised that it returns '\955' instead of 'λ'.
07:26:11 <fmap> > 'λ' == '\955'
07:26:12 <lambdabot>   True
07:26:17 <EvanR> > ['λ']
07:26:18 <lambdabot>   "\955"
07:26:22 <EvanR> >_>
07:26:51 <EvanR> > text ['λ']
07:26:52 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:27:31 <XexonixXexillion> I mean, it doesn't return '\97' for 'a', so why not 'λ' for 'λ'
07:28:05 <EvanR> > "λmno"
07:28:06 <lambdabot>   "\955mno"
07:28:33 <zachk> use putChar or friends and it wont in your app
07:28:53 <XexonixXexillion> Silly \955bot :p
07:29:03 <zachk> ha
07:30:10 <quicksilver> XexonixXexillion: it's the Show instance for Char and String
07:30:24 <quicksilver> the Show instance chooses to use escape characters to keep its output 7-bit
07:30:44 <quicksilver> normally you only use Show for debugging not for real output
07:34:10 <XexonixXexillion> Is there any Haskell type equivalent to a single bit bool type? I couldn't find one in Foreign.C.Types, but I have to deal with C code that uses one
07:34:29 <jhance> XexonixXexillion: No such thing exists in C either...
07:35:56 <XexonixXexillion> jhance: sizeof in C returns 1 for this type
07:36:27 <however> XexonixXexillion: i think sizeof returns the size in bytes, not bits
07:36:39 <frerich> XexonixXexillion : sizeof() yields the number of bytes, not bits.
07:37:07 <jhance> XexonixXexillion: sizeof(1) is equivalent to char or CChar, since sizeof(char) is actually defined to _always_ be1
07:37:21 <silver> strictly speaking the dimension is "number of char" not bytes
07:37:28 <scopedTV> although a char is not necessarily 8 bits
07:37:31 <silver> yeah
07:38:00 <hape01> Data.Bool ?
07:38:06 * however has gzip compression enabled on all his bytes, yielding on average 11.6 bits in a byte
07:38:34 <silver> also implementation defines CHAR_BIT in <limits.h>
07:39:17 <silver> as for 1 bit bools
07:39:18 <however> XexonixXexillion: you may also be interested in Word8, Word16 etc., which are unsigned types. Int8, Int16 etc. are the signed equivalents
07:39:18 <silver> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Unboxed.html
07:39:38 <silver> could this stuff be implemented that way?
07:39:43 <silver> I'm not sure though
07:39:45 <EvanR> 9-bit chars ftw
07:39:49 <EvanR> see also utf9
07:40:28 <EvanR> XexonixXexillion: Bool can be represented with one bit
07:40:43 <XexonixXexillion> ... then why do my sizes return 64 for ints... and I *do* know how sizeof works... my brain is just not working today
07:40:45 <EvanR> it just isnt in implementations, unless you use a collection of Bools
07:40:52 <EvanR> and you use a optimized data structure
07:41:01 <jhance> EvanR: He needs the ctype representation though
07:41:04 <mcstar> is Text.Printf.printf an example of GADT?
07:41:07 <EvanR> sizeof int is not 64
07:41:12 <scopedTV> mcstar: not that i know of.
07:41:22 <Junkieman> name a good simple turnbased game to implement in haskell?
07:41:24 <Junkieman> a!
07:41:30 <Junkieman> 3 in a row
07:41:36 <XexonixXexillion> EvanR: yet my code is spitting that out at present, and I have no idea why
07:41:37 <jamiltron> Junkieman: go!
07:41:41 <jamiltron> :P
07:41:41 <scopedTV> Junkieman: Go
07:41:43 <scopedTV> yes
07:41:43 <mcstar> im just curious, how can you implement polimorphism wrt return type?
07:41:43 <sipa> EvanR: doesn't sizeof evaluate to the size in bytes?
07:41:45 <jhance> mcstar: Check its declaration in the source, if it uses "where" then *probably* (I think existiental or something can use the "where" syntax too)
07:41:48 <EvanR> sipa: yes
07:41:51 <scopedTV> or checkers
07:42:01 <Botje> mcstar: overloaded instances.
07:42:03 <sipa> EvanR: in that case, it will certainly not be 64 :p
07:42:11 <EvanR> i know
07:42:18 <EvanR> thats why i said it xD
07:42:21 <jhance> sipa: No, it returns in terms of chars. But usually its the same thing
07:42:31 <EvanR> where 'usually' means 'always'
07:42:32 <Botje> mcstar: http://www.amateurtopologist.com/blog/2010/01/12/variadic-functions-in-haskell/
07:42:43 <Botje> mcstar: and also (shudder) the original blog post by oleg
07:42:45 <however> > 64*8
07:42:47 <lambdabot>   512
07:43:00 <EvanR> 6 + 3 = 9
07:43:09 <however> @hoogle Word512
07:43:09 <lambdabot> No results found
07:43:13 <mcstar> Botje: oleg's posts cant be shuddered
07:43:17 <mcstar> Botje: thanks
07:43:22 <EvanR> theres a Word160 in one of the crypto modules
07:44:50 <mcstar> ofc, scopedTV jhance too
07:45:01 <jamiltron> Are there any complications to watch out for when representing a 2d grid using a UArray of a UArray Int?
07:45:28 <Botje> mcstar: although oleg's post thous have a nice sentance about the "has type" operator terminating a list
07:45:44 <jhance> jamiltron: The ugly API associated with Array's and the lack of stream fusion.
07:46:17 <jamiltron> jhance: Yeah, I was kind of resolved to writing a lot of helper functions to cover the API issue
07:46:45 <mcstar> im using vector atm
07:46:45 <jhance> jamiltron: Any reason why you can't use 'vector's?
07:46:51 <EvanR> as i said before arrays in haskell are klunky to use ;)
07:47:04 <tromp> Junkieman: connect 4
07:47:51 <jamiltron> jhance: None really, other than the fact that I've worked (a bit) with vectors but never with UArrays.
07:48:06 <Botje>   
07:48:25 <jamiltron> jhance: A silly reason, but I at least like dipping my toes in the various libraries.
07:48:58 <Junkieman> l
07:49:13 <jamiltron> jhance: Vector does have an implementation for using unboxed arrays though, right?
07:49:16 <imphasing> I have a function that returns a (String, Int), but when my main function looks like print $ show $ function arg, it only displays an int.. are tuples constrained by show?
07:49:58 <Saizan> jamiltron: for a grid you'd use UArray (Int,Int) Int
07:50:02 <XexonixXexillion> and problem fixed... My result was accidentally being bit shifted... no wonder it made no sense
07:50:36 <mcstar> im olschool, using a 1d vector for a 2d array
07:50:42 <fmap> imphasing: no
07:51:05 <Saizan> ?src print
07:51:05 <XexonixXexillion> and this is why inline assembly when you forget to clear registers is bad
07:51:06 <lambdabot> print x = putStrLn (show x)
07:51:10 <mcstar> print $ show is redundant
07:51:10 <jamiltron> Saizan: is that as performant as a UArray of UArray?
07:51:44 <Saizan> jamiltron: more i imagine
07:51:45 <mcstar> better
07:52:16 <imphasing> ah, I guess if there are no arguments I don't need the $..
07:52:34 <however> jamiltron: if performance turns out to be an issue, implement both variants and find out which is faster
07:52:45 <imphasing> since I guess composition is associative.. this is all new to me :<
07:52:54 <mcstar> imphasing: not the $, you dont need to 'show' before 'print'
07:53:05 <EvanR> @src print
07:53:05 <lambdabot> print x = putStrLn (show x)
07:53:09 <imphasing> oh, right
07:53:12 <XexonixXexillion> sorry that I'm saying stupid things that are plain wrong, that I should know. I haven't slept in 3 days
07:53:13 <imphasing> thanks :)
07:53:27 <jamiltron> Thanks everyone.
07:53:33 <mcstar> XexonixXexillion: now that is plain wrong!
07:53:39 <silver> XexonixXexillion, you should get some sleep!
07:53:42 <silver> like
07:53:43 <silver> now!
07:53:46 <however> > show $ show "something"
07:53:47 <lambdabot>   "\"\\\"something\\\"\""
07:53:58 <\rs> > show "中文"
07:54:00 <lambdabot>   "\"\\20013\\25991\""
07:54:11 <mux> > fix show
07:54:12 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
07:54:17 <EvanR> > (show . show . show . show) "foo"
07:54:19 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"foo\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
07:54:23 <mcstar> jesus
07:54:28 <however> show-offs ...
07:54:32 <EvanR> lol
07:54:35 <jamiltron> What is this, how do I even?
07:54:45 <\rs> however: how to make `show' show literal unicode instead of escaped one?
07:54:45 <tromp> > iterate show "show"
07:54:46 <lambdabot>   ["show","\"show\"","\"\\\"show\\\"\"","\"\\\"\\\\\\\"show\\\\\\\"\\\"\"","\...
07:55:02 <mcstar> i get it, the show must go on?
07:55:03 <EvanR> > text "中文"
07:55:04 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:55:11 <geekosaur> \rs, you don't.  you want unicode, just putStr it
07:55:24 <however> \rs: i'm pretty sure you can't. you need to pass it directly to putStrLn or hPutStrLn
07:57:43 <jhance> \rs: Theres not much use for Show :: String -> String other than to escape everything for serialization/debug so just don't use it...
07:57:46 <latro`a> is there a standard way of taking in user input to get a number, in such a way that if they don't give a number string they get scolded and given another chance?
07:58:43 <EvanR> :t reads
07:58:44 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:59:03 <\rs> jhance: ok, i'll just bear the behavior
07:59:08 <EvanR> > reads "1234" :: [(Int,String)]
07:59:09 <lambdabot>   [(1234,"")]
07:59:17 <EvanR> > reads "abcd" :: [(Int,String)]
07:59:18 <lambdabot>   []
08:00:00 <latro`a> so that avoids throwing an exception
08:00:02 <latro`a> when it's the wrong type
08:00:07 <latro`a> thanks
08:00:08 <EvanR> yeah, wrap that
08:00:28 <danielsmw> Does anybody know the proper way to update/add rows to TreeView widgets in hs2Gtk? I keep getting an unhelpful runtime error.
08:01:07 * ksf wonders whether GADTs can express PEGs
08:01:16 <EvanR> latro`a: also you might want to also check that the remainder is "", otherwise you could get
08:01:26 <EvanR> > reads "1234abcd" :: [(Int,String)]
08:01:27 <lambdabot>   [(1234,"abcd")]
08:01:30 <donri> also check out the packages "safe" and "errors"
08:01:31 <ksf> ...as in capturing the different rule firings in a phantom-typey GADT.
08:01:32 <hpaste> danielsmw pasted “cell layout error” at http://hpaste.org/71403
08:01:32 <latro`a> one other problem
08:01:38 <latro`a> I don't necessarily know the type of the input
08:01:46 <latro`a> will I have to just pick one?
08:01:50 <EvanR> its not String?
08:01:53 <latro`a> not the string
08:01:55 <latro`a> the number
08:02:03 <EvanR> uhm you pick
08:02:09 <latro`a> you can't leave it polymorphic?
08:02:10 <EvanR> youre making the parser
08:02:14 <latro`a> k
08:02:26 <latro`a> that's fine for this purpose
08:02:33 <latro`a> hell I might strip the type variables from this program tbh
08:02:34 <EvanR> is Double not good enough?
08:02:37 <latro`a> it is
08:02:41 <donri> > read "5" :: Num a => a
08:02:42 <lambdabot>   Could not deduce (GHC.Read.Read a) from the context (GHC.Num.Num a)
08:02:43 <lambdabot>    aris...
08:02:43 <XexonixXexillion> latro`a: If it's just a number, could you just do something like Either Integer Double
08:02:48 <EvanR> > reads "1234abcd" :: [(Double,String)]
08:02:49 <lambdabot>   [(1234.0,"abcd")]
08:02:58 <donri> > (read "5" :: Num a => a) :: Int
08:02:59 <lambdabot>   Could not deduce (GHC.Read.Read a) from the context (GHC.Num.Num a)
08:02:59 <lambdabot>    aris...
08:03:10 <latro`a> nah they're definitely either Floating or Integral
08:03:16 <latro`a> I just didn't specify which in the rest of the program
08:03:25 <latro`a> erm
08:03:30 <latro`a> which Floating and which Integral
08:03:37 <EvanR> Double or Integer
08:03:50 <latro`a> Int would be fine for this purpose
08:04:04 <latro`a> the integral type is an array index for a game board
08:04:14 <EvanR> > read "1234567891" :: Int
08:04:15 <donri> if you mean, do you need explicit type signatures, then no, usually not
08:04:16 <lambdabot>   1234567891
08:04:26 <EvanR> > read "12345678912" :: Int
08:04:27 <lambdabot>   12345678912
08:04:37 <EvanR> > read "12345678912345678912345678" :: Int
08:04:37 <donri> it's just there's no information to infer the type from in simple expressions like on ghci/lambdabot
08:04:38 <lambdabot>   -7473169249311730098
08:04:41 <latro`a> I assume I can't just call reads without a signature
08:04:47 <XexonixXexillion> > maxBound :: Int
08:04:49 <lambdabot>   9223372036854775807
08:04:50 <EvanR> latro`a: yes
08:04:51 <donri> > read "5" + 3
08:04:52 <lambdabot>   8
08:04:56 <latro`a> ah
08:04:58 <latro`a> cute
08:05:03 <donri> see, no need for type signatures if the type can be inferred
08:05:06 <latro`a> ok yeah then that'll work
08:05:20 <XexonixXexillion> > read "9223372036854775808" :: Int
08:05:22 <lambdabot>   -9223372036854775808
08:05:26 <MostAwesomeDude> > read "21" + 0 -- I'm a bad person.
08:05:28 <lambdabot>   21
08:05:38 <EvanR> lol
08:05:44 <EvanR> php conversion techniques
08:05:50 <donri> > read "21" ++ "0"
08:05:53 <lambdabot>   "*Exception: Prelude.read: no parse
08:05:55 <donri> \o/
08:06:06 <donri> php error techniques
08:06:09 <EvanR> > read "21" ++ Nothing
08:06:12 <lambdabot>   *Exception: Prelude.read: no parse
08:06:20 <EvanR> > read "21" ++ []
08:06:23 <lambdabot>   *Exception: Prelude.read: no parse
08:06:25 <MostAwesomeDude> > read "Just 21" ++ Nothing
08:06:27 <lambdabot>   *Exception: Prelude.read: no parse
08:06:33 <latro`a> lolwut
08:06:35 <EvanR> lol
08:06:40 <donri> > read "Just 21" `mappend` Nothing
08:06:41 <lambdabot>   *Exception: Prelude.read: no parse
08:06:52 <donri> o...k?
08:07:02 <quicksilver> donri: extended defaulting defaulted Nothing to Maybe ()
08:07:04 <quicksilver> I suspect.
08:07:09 <donri> fun
08:07:19 <quicksilver> at which point, read "Just 21" gives no parse
08:07:19 <imphasing> I'm guessing read won't parse if you give it something already parsed.
08:07:22 <XexonixXexillion> > read "Just 21" :[Nothing]
08:07:23 <lambdabot>   [*Exception: Prelude.read: no parse
08:07:23 <donri> yep
08:07:26 <imphasing> read "21" :: String doesn't work either
08:07:39 <XexonixXexillion> > (read "Just 21" ):[Nothing]
08:07:40 <however> imphasing: right
08:07:41 <lambdabot>   [*Exception: Prelude.read: no parse
08:07:47 <quicksilver> > read "\"21\"" ++ ""
08:07:49 <lambdabot>   "21"
08:07:49 <however> > read "\"21\"" :: String
08:07:51 <lambdabot>   "21"
08:07:53 <XexonixXexillion> > (read "Just 21" ):[Nothing :: Maybe Int]
08:07:55 <lambdabot>   [Just 21,Nothing]
08:08:02 <MostAwesomeDude> > read "Just ()" : [Nothing]
08:08:04 <lambdabot>   [Just (),Nothing]
08:08:09 <donri> (read.read) "\"21\""
08:08:15 <donri> > (read.read) "\"21\""
08:08:17 <lambdabot>   *Exception: Prelude.read: no parse
08:08:23 <hpaste> qrt_junkieman pasted “post request doesnt work but ok response” at http://hpaste.org/71404
08:09:00 <donri> > (read.(read::String->String)) "\"21\""
08:09:02 <lambdabot>   *Exception: Prelude.read: no parse
08:09:03 <donri> ^_^
08:10:07 <XexonixXexillion> > ((read :: String -> Int) . (read :: String -> String)) "\"21\""
08:10:09 <lambdabot>   21
08:10:23 <donri> oh yea
08:10:45 <Junkieman> can someone good with Networkl and hhttp and forms have a look above? im trying to post to hpaste with a program but it doesnt work
08:10:54 <donri> > ((read :: String -> Int) . read) "\"21\""
08:10:57 <lambdabot>   21
08:11:17 <donri> > (read.read) "\"21\"" :: Int
08:11:20 <lambdabot>   21
08:12:48 <donri> Junkieman: you need to send email as an empty parameter
08:12:55 <donri> it's a spam thing
08:13:06 <donri> https://github.com/dag/vim2hs/blob/master/plugin/hpaste.py here's how i do it for vim in python
08:15:23 <mcstar> now, pls supply a version in elisp
08:15:31 <mcstar> :)
08:17:13 <hpaste> Qrt pasted “test” at http://hpaste.org/71407
08:17:24 <Junkieman> woooot!
08:17:26 <Junkieman> ty so much
08:19:20 <mietek> How can I load a static library.a with ghci?
08:19:38 <mietek> For linking
08:19:40 <mietek> With FFI
08:21:13 <mietek> Ah, never mind.  -L. -lvm
08:21:28 <hpaste> danielsmw pasted “TreeView row-adding problem code” at http://hpaste.org/71408
08:21:51 <danielsmw> How can I properly add rows to a treeView in hs2Gtk
08:23:44 <DexterLB> if I have type Foo = Bar String | Baz String, is there a way to make a function that extracts the string from any of these without explicitly coding it for each of them?
08:24:10 <DexterLB> aka the equivalent of f Bar x = x; f Baz x = x
08:24:28 <danielsmw> DexterLB: if you give them a record constructor, you should be able to use it for both
08:24:33 <danielsmw> I think?
08:25:05 <danielsmw> It needs to be a 'data', not a 'type' though.
08:25:13 <codolio> Yes.
08:25:31 <danielsmw> e.g. data Foo = Bar { str :: String } | Baz { str :: String }
08:25:33 <hpaste> Qrt pasted “Qrt needs help” at http://hpaste.org/71409
08:26:19 <DexterLB> danielsmw: yeah, that's what I meant, sorry
08:26:30 <DexterLB> data Foo = Bar String | Baz String
08:26:31 <Junkieman> ^^ any improvements?
08:27:06 <danielsmw> DexterLB: So with the record construction I provided above you should be able to just (str barOrBaz)
08:28:10 <DexterLB> danielsmw: indeed, thanks
08:31:53 <alhazred_> Greetings
08:31:59 <srhb> alhazred_: Hi
08:32:02 <danielsmw> alhazred_: Greetings!
08:32:19 <alhazred_> Is there any connection between continuation style passing and dual spaces?
08:32:44 <alhazred_> To me CPS has a smell of the transpose of a linear map.
08:34:02 <alhazred_> f :: X -> Y  --> f_cps :: X -> (Y -> r) -> r --> regrouping --> f_cps :: (Y -> r) -> X -> r which would be very similar to the transpose if f was a linear map
08:38:19 <codolio> alhazred_: Yes, there is a connection.
08:38:39 <alhazred_> codolio: Is there any gain from it?
08:39:15 <mcstar> first of all, what is the connection?
08:40:59 <codolio> There's a fellow who's not here right now, edwardk, who has an algebra package where the vector stuff revolves around the above treatment.
08:41:24 <codolio> Given a basis B, B -> R is the type of vectors over that basis.
08:41:47 <codolio> Where R is a field or some such. Or if it's just a ring, you get modules.
08:42:18 <codolio> But, there is also a type of covectors, which is (B -> R) -> R, where the second is required to be a linear map.
08:42:39 <codolio> Which is more restricted than arbitrary continuation passing.
08:42:46 <codolio> That is, the second arrow.
08:42:59 <EvanR> haha codolio
08:43:03 <alhazred_> Hm that sounds pretty neat.
08:43:12 <EvanR> can i be EvanCoR
08:43:59 <alhazred_> Is there a more fundamental connection for haskell maybe?
08:44:00 <codolio> Then, you have linear maps of vectors (B -> R) -> (C -> R) which correspond to (arbitrary) maps from basis C to covectors of B, C -> (B -> R) -> R.
08:44:22 <alhazred_> Or can you say that the "transpose" of a function in haskell is the cps function of it?
08:44:36 <alhazred_> Or lets better say the dual.
08:45:33 <mcstar> cps 'turns a function inside out' i dont get what does it have to do with the tranpose of a linear map
08:45:43 <codolio> There's also a bunch of stuff I don't quite recall about how working with covectors is better than working with vectors. And the covector construction over a basis forms a monad, and so on.
08:46:02 <alhazred_> mcstar: The dual space.
08:46:29 <alhazred_> https://en.wikipedia.org/wiki/Dual_space
08:46:47 * hackagebot wai-handler-devel 1.3.0 - WAI server that automatically reloads code after modification. (MichaelSnoyman)
08:46:49 * hackagebot wai-handler-webkit 1.3.0 - Turn WAI applications into standalone GUIs using QtWebkit. (MichaelSnoyman)
08:48:09 <alhazred_> Is there a functor or somesuch in haskell that maps it to its cp style function?
08:48:10 <mcstar> alhazred_: that doesnt answer my questoin
08:48:37 <alhazred_> mcstar: That turns the function inside out part is like what the dual space does.
08:49:35 <mcstar> the dual space of a vector space is the space of linear functionals
08:49:36 <alhazred_> f : V -> W, f* : W* -> V*
08:49:45 <mcstar> wheres the transposition?
08:50:22 <alhazred_> What i am looking for is a further abstraction.
08:50:48 <alhazred_> W* : W -> R, V* : V -> R
08:51:24 <codolio> Yes, (-> R) is a contravariant functor for all R.
08:51:46 <alhazred_> So basically this operation would make the new fuction accept some other function.
08:51:58 <alhazred_> Like in the bilinear map in linear algebra.
08:52:38 <alhazred_> codolio: So there is a way to map any function in haskell to a function that is its cps form?
08:53:32 <codolio> There is a CPS monad. return :: a -> (a -> r) -> r. So if f :: a -> b, then return . f :: a -> (b -> r) -> r.
08:53:35 <codolio> If that's all you want.
08:53:56 <codolio> It won't quite look like that, though.
08:54:11 <codolio> More like 'a -> Cont r a'.
08:54:52 <alhazred_> codolio: Yes thanks.
08:55:24 <alhazred_> If you switch the first and second argument the form looks exactly like the dual.
08:55:45 <quicksilver> alhazred_: no, the dual space is not like turning the function inside out.
08:55:54 <alhazred_> Uh?
08:55:59 <quicksilver> it's more like the double-dual
08:56:18 <alhazred_> Why is it more like the double dual?
08:56:19 <quicksilver> the CPS transform takes A to (A -> R) -> R, not just to (A -> R)
08:56:36 <scopedTV> the dual space is a perverse thing anyway
08:56:43 <alhazred_> quicksilver: Thats why i said its like the dual of a linear map.
08:56:47 * hackagebot natural-numbers 0.1.2.0 - Natural numbers (WolfgangJeltsch)
08:57:03 <quicksilver> CPS is an isomorphism, while duality is not.
08:57:04 <alhazred_> Otherwise it was the dual of a variable.
08:57:09 <alhazred_> Which is a function
08:57:11 <quicksilver> however, double-duality *is* an isomorphism.
08:57:15 <scopedTV> right
08:57:53 <quicksilver> (finite dimension vector spaces happen to be isomorpic to their duals but that's un-natural, and more general spaces are not)
08:57:55 <alhazred_> But the dual of a function looks like the CPS monad
08:58:12 <alhazred_> Its just the argument order that is different.
08:58:42 <alhazred_> The dual of a function maps the codomain of a function to the codomain of a function you pass.
08:58:47 <alhazred_> And thats what CPS does also.
09:01:34 <srhb> What's the difference between the Data.Array.ST and Data.Array.IO mutable arrays? Is one "less unsafe" than the other?
09:01:53 <sipa> srhb: one is used inside IO, one inside ST
09:01:53 <scopedTV> one runs in the IO monad, the other in the ST monad
09:02:01 <srhb> Yes, that bit was obvious.
09:02:01 <scopedTV> the difference is that there exists ST a -> a, but no IO a -> a
09:02:04 <sipa> apart from that, they are identical
09:02:07 <srhb> Ah.
09:02:19 <mizu_no_oto> Suppose I have a [State Foo Bar], and I'd like to intercalate, as it were, some sort of action (e.g. (<* modFoo)) into that list.  That is to say, I have a function (State Foo Bar -> State Foo Bar), and I'd like to apply it to every element *except the last*.  What's the most idiomatic way of doing that?   Should I just make a map' function, or something?
09:02:40 <scopedTV> (rather (forall s. ST s a) -> a or whatever)
09:02:56 <srhb> I have no clue whether that would be a benefit just yet. Hmm.
09:03:04 <scopedTV> if you can, always ST.
09:03:11 <sipa> if you must, always IO
09:03:18 <srhb> :D
09:04:04 <scopedTV> but you cannot use all IO functions in ST, only newSTRef and friends
09:04:14 <aristid> :t stToIo
09:04:15 <scopedTV> so it's useful if you have an "imperative" algorithm that you want to code.
09:04:15 <lambdabot> Not in scope: `stToIo'
09:04:18 <aristid> :t stToIO
09:04:19 <lambdabot> Not in scope: `stToIO'
09:04:25 <aristid> @hoogle stToIO
09:04:25 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
09:04:26 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
09:04:26 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
09:04:27 <jhance> :t unsafeSTtoIO
09:04:28 <lambdabot> Not in scope: `unsafeSTtoIO'
09:04:31 <srhb> Right, I will try my hand at the ST monad first. Thanks for the advice for dummies. ;)
09:04:42 <aristid> no, stToIO is safe in the normal version :)
09:05:07 <aristid> srhb: and the point about stToIO is that if you have ST code, you can directly use it in IO, too
09:05:12 <jhance> aristid: Only with RealWorld. I was just seeing if I could get unsafeSTToIO to appear. IIRC they are different packages now, right?
09:05:25 <aristid> jhance: hoogle says same module
09:05:26 <scopedTV> you can also just runST it.
09:05:51 <aristid> scopedTV: which is sometimes impractical if you want to interlave IO
09:05:56 <mizu_no_oto> Also, State Foo BarMonoid forms a monoid, right?  mappend s1 s2 = s1 >>= \a1 -> s2 >>= \a2 -> return (a1 mappend a2) ; mempty = return mempty
09:06:06 <scopedTV> ack
09:08:25 <srhb> I'm not quite sure how to construct an ST Array though. Are there no helper functions for the mutable kinds?
09:08:47 <srhb> Oh hang on, note at the bottom. :-)
09:09:08 <srhb> I think Hackage may be struggling..
09:10:38 <osa1> does anyone know a way to get multi-line user input from comand line ? I'm using haskeline but seems like it can't do that.
09:14:25 <sm> that's unusual.. is there an existing example of that ?
09:15:23 <sm> hledger's add command collects multi-line data one line at a time, terminated with .
09:15:53 <Axman6> mizu_no_oto: put (a1 `mapped` a2) not return
09:16:05 <Axman6> i think
09:16:09 <Axman6> wait, ignore me
09:19:15 <danielsmw> does anyone have much gtk experience in haskell?
09:20:17 <monochrom> perhaps define "much"
09:20:46 <danielsmw> well
09:20:49 <notrusty> poor lambdabot seems to be bitrotting a little?  (pulling darcs now, is that much better?)
09:20:57 <danielsmw> monochrom: to help me with what seems like a pretty simple problem!
09:21:14 <Junkieman> i use wxHaskell instead
09:21:36 <monochrom> lambdabot is pretty old, yes
09:21:37 <chris2> i have used gtk2hs for some small programs
09:21:47 <danielsmw> hmm.. maybe I should consider that option. i chose gtk for the cairo drawing stuff.
09:21:57 <monochrom> perhaps define "pretty simple problem" but you're now tired of me
09:22:12 <chris2> perhaps you should just ask your actual question :P
09:22:31 <danielsmw> I'm having trouble making a treeView work. every time I try to add a new row it gets upset and throws a runtime error.
09:22:49 <danielsmw> http://hpaste.org/71408
09:22:59 <danielsmw> the error is at the top of that paste.
09:23:24 <danielsmw> i'm basically just updating my listModel and then trying to set the treeView to use that model. are there special steps i'm missing?
09:24:51 <monochrom> I have an example at http://hpaste.org/43235
09:25:14 <ksf_> is peggy known to be dog slow?
09:25:35 <ksf_> I'd hate to port things over to frisby just to discover that it's as slow.
09:26:19 <danielsmw> monochrom: thanks! I'll take a look.
09:27:57 <ksf_> with peggy, linear time feels like exponential constant factor and stack overflows.
09:27:57 <nobdraisentone> How can I split list [a] to [[a]] without Data.List.Split? I.e [1,2,3] → [[1],[2],[3]]
09:28:20 <notrusty> > map (:[]) [1,2,3]
09:28:21 <mux> > map (:[]) [1,2,3]
09:28:21 <lambdabot>   [[1],[2],[3]]
09:28:23 <lambdabot>   [[1],[2],[3]]
09:28:23 <ksf_> > map (:[]) [1,2,3]
09:28:25 <lambdabot>   [[1],[2],[3]]
09:28:27 <mux> lol
09:28:32 <ksf_> dolby 3+0!
09:28:33 <bitonic> the monkey operator
09:28:34 <mux> or map return
09:30:00 <triyo> Is list append operator (++) an O(1) operation?
09:30:05 <bitonic> triyo: no
09:30:08 <ksf_> depends.
09:30:26 <bitonic> triyo: you have to traverse and copy the first list
09:30:34 <notrusty> ksf_, depends?
09:30:38 <triyo> Ok let me say it like this xs noe ys are []
09:30:43 <triyo> `empty`
09:30:55 <srhb> Wow, these types are confusing. If I have newListArray ((1,1),(1,1)) "a" :: ST s (STUArray s (Int,Int) Char) am I supposed to be able to use readArray foo (1,1) on it directly?
09:30:56 <bitonic> wat?
09:31:01 <triyo> [] ++ ys would be o(n) right?
09:31:10 <triyo> oops I mean o(1)
09:31:11 <srhb> o(1)
09:31:11 <bitonic> triyo: no, that's O(1)
09:31:22 <ksf_> notrusty, it depends on what you append in what order.
09:31:37 <ksf_> ...more precisely, whether appending can get fused with consuming.
09:31:53 <Taneb> I've just got through a pdf about the history of Haskell and now I'm bored
09:31:53 <quicksilver> srhb: you're in a monad.
09:32:08 <quicksilver> srhb: you will need to at least "myArr <- newListArray....."
09:32:28 <quicksilver> srhb: and the mutable array read is, itself, a monadic action of course
09:32:37 <srhb> Ah yes, of course..
09:32:52 <srhb> Brainlag. :P
09:34:41 <triyo> So we have O(1) as best case. What about worst case or (++)?
09:34:51 <triyo> *or = on
09:34:55 <srhb> The length of the first list.
09:35:02 <bitonic> triyo: there is one case: O(n), where n is the lenght of the first list
09:35:14 <triyo> Got it. Thanks.
09:35:15 <bitonic> talking about worst or best is misleading
09:35:19 <srhb> True enough
09:35:59 <quicksilver> the best case is where you never evaluate it at all, due to laziness that's O(0).
09:36:10 <triyo> bitonic: could you elaborate a bit please? How is it misleading?
09:36:44 <triyo> quicksilver: I see what you mean.
09:36:54 <uniquenick> is there a trick to be able to do mathy stuff without having to sprinkle fromIntegral and friends all over?
09:37:04 <bitonic> triyo: because you usually talk about worse, avg. and best when the algorithm can perform differently for reasons extraneous to the variables considered in the O
09:37:08 <bitonic> e.g. quicksort
09:37:46 <srhb> The best case is O(n) which is still O(n) in the case of an empty first list, the n is just very small.
09:39:03 <quicksilver> yeah, you usually talk about best/worst cases when the actual time depends on the shape of the data
09:39:12 <Taneb> Can anyone recommend a big PDF that will increase my understanding of functional program, especially Haskell?
09:39:21 <quicksilver> like, runs worst on sorted lists, or runs best when all items the same, etc
09:39:38 <triyo> So its sensitive to structure of the data in question?
09:39:48 <bitonic> triyo: ++ isn't.
09:39:54 <mcstar> Taneb: append a small, really good one several times to itself?
09:40:22 <srhb> triyo: It is O(n) in all cases. Best, worse, average.
09:40:29 <Taneb> mcstar, can you recommend a really good one
09:40:31 <srhb> worst*
09:40:49 <Taneb> That's a decent O
09:40:58 <Taneb> Unless n is a trillion
09:40:59 <mcstar> Taneb: haskell schools of expressions
09:41:14 <mcstar> put that s a word back
09:42:22 <mcstar> no, no ss
09:42:26 <Taneb> One I don't need to pay for?
09:42:41 <mcstar> oh
09:42:44 <mcstar> right
09:42:47 <nand`> mcstar: haskell schools ofs expression?
09:42:50 <nand`> :P
09:43:05 <Taneb> shaskell chool of expressions
09:43:23 <nand`> haskell schools osf expresions
09:43:42 <mcstar> keeps getting funnier
09:43:46 <osfameron> WHO DARES SUMMON THE MIGHT OSF...oh, never mind
09:43:54 * osfameron should look at his irssi /hilights
09:44:03 <mcstar> definitely
09:44:10 <mcstar> highlight on partial matches?
09:44:53 <mcstar> Haskell the craft of functional programming
09:45:00 <srhb> What actually happens if I give newListArray ((3,3),(1,1)) ? It seems no indexes will function at all, but no warning is issued either
09:45:01 <mcstar> Taneb: ^^
09:45:07 <Taneb> Okay
09:45:57 <mcstar> The functinal approach to programming
09:46:06 <mcstar> this is more ocaml-y
09:46:30 <mcstar> Pearls of functional algorithm design
09:46:36 <Taneb> Well, I need to pay for Haskell the craft of functional programming, I think
09:46:43 <mcstar> tyep theory and functional programming
09:46:59 <mcstar> ill /query you
09:47:28 <monochrom> "haskell schools osf expression" is an obscure way to say "haskell for unix"
09:48:02 <DexterLB> can modules import each other? is it wise to do so?
09:48:49 <monochrom> modules can import each other. on ghc, you need to work a bit harder to get it, but it can be done. it is wise iff it is wise.
09:49:11 <monochrom> see the ghc user guide
09:49:55 <mcstar> is there a 'retur' for the Wise monad?
09:50:02 <mcstar> fail n
09:50:15 <Taneb> Have you... tried return?
09:54:52 <LambdaDusk> hello... is there a loader for a common 3d model format in haskell somewhere?
09:56:10 <sclv> yes
09:56:43 <LambdaDusk> good to know
09:56:52 <LambdaDusk> kindly point me to it?
09:57:06 <sclv> http://hackage.haskell.org/package/hogre is one
09:57:11 <sclv> there are many others on hackage
09:57:57 <srhb> sclv: I don't think Ogre parses any kind of 3d model files?
09:58:05 <HugoDaniel> how do i change a Ptr CInt to a Ptr Int32 ?
09:58:17 <jfischoff> there is a collada importer
09:58:27 <HugoDaniel> im doing a c struct ffi wrapper in haskell and im kind of stuck with this
09:58:39 <jfischoff> I don't think it supports the whole format though
09:58:40 <jfischoff> there is also an obj importer
09:58:41 <sclv> http://hackage.haskell.org/package/graphics-formats-collada
09:59:08 <jfischoff> the problem is there really isn''t common 3d model format
09:59:30 <sclv> http://hackage.haskell.org/package/cal3d might also be of use?
10:00:17 <LambdaDusk> sclv, jfischoff: Any that is supported by blender will do
10:01:08 <jfischoff> LambdaDusk: what are you trying to export? Just mesh info? Or material properties, animation, camera, etc ..
10:01:16 <XexonixXexillion> :t castPtr
10:01:17 <lambdabot> Not in scope: `castPtr'
10:01:46 <XexonixXexillion> HugoDaniel: castPtr (from Foreign.Ptr) should do it
10:02:09 <LambdaDusk> jfischoff: I only need mesh and perhaps textures, but probably just the mesh. I want to work it into a template haskell expression for my own format
10:02:28 <zzing_> What is one of the most basic examples of multiparameter monads like the idea of Handler b v a from snap? I want to find something that is relatively easy to understand and something I can reimplement for study.
10:02:46 <jfischoff> LambdaDusk: Does Blender support Obj? Its a very simple text format
10:02:57 <HugoDaniel> XexonixXexillion: thanks :D
10:02:58 <LambdaDusk> jfischoff: Yes it does.
10:03:15 <jfischoff> I think there is a haskell importer, but even if there is not
10:03:22 <jfischoff> I would just look at the file
10:03:36 <jfischoff> it might be the easiest anyway
10:03:50 <Axman6> zzing_: State?
10:04:08 <jfischoff> LambdaDusk: http://hackage.haskell.org/package/obj
10:04:37 <zzing_> Axman6: looks likely
10:05:01 <LambdaDusk> jfischoff: thanks
10:05:01 <jfischoff> LambdaDusk: I sense that package is crap, because it depends on a bunch of packages that are unnecessary
10:05:30 <LambdaDusk> jfischoff: and look at the build failures
10:05:40 <notrusty> https://github.com/DanBurton/lambdabot-remedies  <- helpful
10:05:43 <LambdaDusk> I'll just try to make my own
10:06:00 <LambdaDusk> upload date is nov 2008 ^^
10:06:34 <jfischoff> LambdaDusk: make your own. If you have questions I can help, but you should be fine
10:06:51 <LambdaDusk> jfischoff: Ok, thanks
10:08:48 <danielsmw> monochrom: the code snippet you gave me earlier really helped. thanks again!
10:18:49 <timthelion> You know those ads "Talk to your kid about drugs." ?   I need the Ada talk.
10:20:03 <c_wraith> Who's trying to sell you ada?
10:20:13 <c_wraith> Seems more like they're the one who needs to be talked to
10:20:55 <srhb> Why are these not equivalent.. return . runST $ ... vs. return $ runST $ ...
10:21:26 <aristid> srhb: it probably depends on the "..."?
10:21:44 <timthelion> c_wraith: I got in a conversation with a guy about the claim that "if it compiles ship it" and I explained that in haskell sometimes that's true.  And the guy said it's only true for ada(which I hadn't heard of at the time)
10:21:46 <srhb> And here I thought it didn't. :-)
10:22:13 <aristid> srhb: well who knows which crazy things you're doing!
10:22:21 <copumpkin> srhb: because inferring higher-rank polymorphism doesn't work very well, in general
10:22:22 <c_wraith> srhb: it's because of the type of runST, and a hack that allows it to work with $ when it shouldn't
10:23:23 <aristid> oh, so it's actually just runST's polymorphism
10:23:25 <edwardk> preflex: xseen alhazred_
10:23:25 <preflex>  alhazred_ was last seen on freenode/#haskell 1 hour, 24 minutes and 37 seconds ago, saying: And thats what CPS does also.
10:23:28 <srhb> Hurgh, okay. Confusing!
10:28:40 <ocharles> anyone know where I can find a count of distinct libraries on hackage?
10:28:54 <ocharles> 00-index.tar.gz has multiple versions, so ideally I don't want to have to parse that, but I will if I have to
10:29:50 <parcs`> they both shouldn't work, but 'runST $ ...' is a mad
10:30:19 <User9eB1> You could just add up the numbers from the top of this page: http://hackage.haskell.org/packages/archive/pkg-list.html
10:30:43 <ocharles> User9eB1: no, libraries can belong to multiple categories
10:30:50 <ocharles> i'm just using the 3500 number from the latest community report
10:31:08 <c_wraith> you could just count the number of distinct links with the right format on that page
10:33:00 <aristid> ocharles: tar tf ~/.cabal/packages/hackage.haskell.org/00-index.tar|perl -ne '/(\w+).cabal/ && print "$1\n"'|sort|uniq|wc -l
10:33:21 <srhb> parcs`: what do you mean "is a mad" ?
10:33:36 * MostAwesomeDude is a MAD
10:33:54 <parcs`> srhb: i accidentally pressed enter and then i didn't feel like finishing the sentence :P
10:34:04 <srhb> I see. :P
10:34:24 <parcs`> runST $ do is made an exception to the rule because it is so common
10:34:32 <srhb> Ah.
10:38:39 <parcs`> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg18923.html
10:39:25 <srhb> parcs`: Thank you. It's a little over my head, but I'll read it a few times and hope something seeps in. :-)
10:46:04 <bindy> hi guys, please do you have any advise about this? lets have: data A = A String String, and then f :: [String] -> A. Is there a way how to implement f in Haskell?
10:46:50 <bindy> of course I can do f [a,b] = A a b, but lets say there is many more arguments, lets say 30
10:46:51 * hackagebot authenticate-oauth 1.4.0.0 - Library to authenticate with OAuth for Haskell web applications. (HiromiIshii)
10:47:53 <srhb> bindy: What is it you want to do exactly? I mean, you can concat them all, split them arbitrarily and have them in an A. Or you can just save random Strings. What is it you want?
10:47:55 <otters> bindy: well, you can't make an A out of 30 arguments
10:48:45 <bindy> I mean lets say I have data A = A a b c d e f .... and I need to initialize it from a list
10:48:55 <srhb> Ah.
10:49:02 <bindy> and I don't want all the boilerplate around
10:49:17 <otters> No, you can't pass a list as separate arguments to a function.
10:49:45 <c_wraith> why is it that you have the data as a list in the first place?
10:49:47 <bindy> yeah, that's what I figured. but is there any other way?
10:50:03 <otters> The only thing you can do is f (a:b:c:d:e:_) = A a b c d e
10:50:05 <otters> or similar
10:50:08 <bindy> c_wraith: I read it from a file
10:50:29 <c_wraith> bindy: that doesn't necessarily make it a list.  parse it better?
10:50:39 <bindy> otters: I tried a recursive function but it always ended in an infinite type
10:51:08 <mroman> bindy: Ah, then it's easy
10:51:37 <bindy> c_wraith: hm, interesting, do you have some specific data structure on your mind?
10:52:00 <c_wraith> bindy: just parse it directly into your records
10:54:13 <mroman> if data would work
10:55:11 <bindy> c_wraith: ok, lets say I am parsing it from a format similar to a CSV file. Wouldn't it just moved the boilerplate to the parsing?
10:55:18 <bindy> mroman: speak up, sir! :)
10:56:56 <mroman> bindy: http://codepad.org/XkdVdiDl
10:56:59 <mroman> ^- something like that.
10:57:22 <parcs`> oh god
10:57:27 <mroman> it's ugly
10:57:30 <mroman> but it does the job.
10:57:40 <c_wraith> that's terrifying.
10:57:52 <c_wraith> I thought you were going to use something from Data.Data or Data.Generics instead :)
10:57:56 <mroman> Nah.
10:58:05 <mroman> Good old plain only prelude haskell ;)
10:58:29 <fmap> eeew
10:58:51 <mroman> and it's generic!
10:59:37 <bindy> mroman: Hmmm, nice!
10:59:56 <mcstar> what is a,b,c,d..?
11:00:06 <mcstar> tokens on the lines?
11:00:12 <mcstar> are*
11:00:55 <bindy> mcstar: I have a complex multiline CSV format that I need to parse and work with, most of the fields are Strings, but there are other types
11:01:39 <bindy> but I think mroman's solution is gonna work, I will play with it for a while, thanks a lot for showing me the way!
11:01:54 <mcstar> what im asking, is the elements per line a lot? you want to have a type encompassing each line?
11:02:19 <mroman> http://codepad.org/V8u0wFnx <- somehow like that.
11:03:05 <mroman> bindy: Can't you just have a type Foo [String] ?
11:03:49 <bindy> mcstar: mroman: there is about 40 elements total in the Record. most of them are String but unfortunately not all of them
11:03:51 <mcstar> depends how you want to process it, but a [[String]] could also suffice
11:04:05 <parcs`> type classes to the rescue http://paste.debian.net/178937/
11:04:36 <mcstar> bindy: [[YourType]] where YourType is an elgebraic type of the different things
11:04:51 <bindy> mroman: I had no idea 'read' was that powerful! What does it do actually? I thought there was no 'eval' in Haskell...?
11:05:03 <mroman> read is not eval.
11:05:12 <bindy> mcstar, yeah like SqlValue in HDBC?
11:05:23 <mcstar> idk about that
11:05:46 <mroman> read is like a default parser for data t.
11:06:02 <mroman> > read "3" :: Int
11:06:04 <lambdabot>   3
11:06:08 <mroman> > read "3" :: Double
11:06:10 <lambdabot>   3.0
11:06:19 <mroman> > read "3" :: Char
11:06:21 <lambdabot>   *Exception: Prelude.read: no parse
11:06:29 <bindy> mroman: > read "Maybe [3]" :: Maybe [Int]
11:06:34 <bindy> > read "Maybe [3]" :: Maybe [Int]
11:06:36 <lambdabot>   *Exception: Prelude.read: no parse
11:06:51 <mroman> > read "Just 5" :: Maybe Int
11:06:53 <lambdabot>   Just 5
11:07:01 <mroman> > read "Just [3]" :: Maybe [Int]
11:07:01 <bindy> cool!
11:07:02 <lambdabot>   Just [3]
11:07:24 <mroman> But again, it's not eval, it's parsing.
11:07:43 <mroman> and most people here wouldn't consider it good style using it I guess.
11:07:45 <mroman> but it works.
11:07:53 <bindy> mroman: I see, thank you for explaining! I am gonna read more about this.
11:08:16 <mroman> and it's pretty powerful, yes.
11:08:19 <bindy> I think I understand why but when parsing into a type is what I need, I think this is the way
11:08:39 <mroman> > read "[Just 5, Nothing, Just 1]" :: [Maybe Int]
11:08:40 <lambdabot>   [Just 5,Nothing,Just 1]
11:09:04 <parcs`> there's a better way http://paste.debian.net/178938/
11:09:08 <mcstar> parcs`: fromList takes the constructor of the new type?
11:09:13 <parcs`> yeah
11:09:18 <mcstar> thats how it distinguishes between what to parse?
11:09:24 <mcstar> nice
11:09:30 <mcstar> interesting example
11:09:39 <parcs`> mcstar: that and the explicit type signature
11:10:15 <mroman> Actually (((A "foo") "bar") "zar") should work?
11:10:21 <mroman> (does data support currying?)
11:10:24 <mcstar> yeah
11:10:40 <mcstar> its a simple function, the constructor
11:10:52 <mcstar> the only difference is that it starts with a capital letter
11:10:59 <bindy> wow, this is interesting! I need a bit more time to fully grasp this :)
11:11:49 <mcstar> i think i got hungry from the excitement
11:13:52 <Botje> doesn't take much to make me hungry ;)
11:17:09 <mroman> but constructing
11:17:11 <tew88> Does anyone use Geany for their Haskell hacking? Any tips for setting up a nice Haskell environment? Possible to incorporate GHCi somehow? (Google, alas, appears not to be my friend)
11:17:19 <mroman> (((f a) b) c) is not possible I guess.
11:17:33 <nand`> tew88: tips on setting up a nice haskell environment: install vim; s/vim/emacs/ if you swing that way
11:18:01 <nand`> then install GHCi and use a good terminal emulator for the two
11:18:08 <nand`> that's the best haskell development environment right there
11:18:21 <notrusty> so who maintains lambdabot?  seems like it runs fine if you just use danburton's .cabal and change ShowIO to ShowFun
11:18:52 <monochrom> there are both vim add-on and emacs add-on for ghci interaction
11:18:55 <bindy> parcs`: I don't really understand why it didn't result in an infinite type. Especially what you did at: fromList xs (f x)
11:19:12 <tew88> nand`: It's all a bit subjective, isn't it? ;) I like a mouse! More accurately, I'm not used to working without one
11:19:29 <monochrom> I like the mouse too
11:19:37 <srhb> tew88: Emacs does mouse support nicely, so does graphical Vim afaik
11:19:42 <bindy> parcs`: because there the f changes from (String -> String -> String -> A) to (String -> String -> A)
11:19:53 <nand`> tew88: if you're interested in remidying that, you could try unpluggin the mouse and seeing how long you last :)
11:20:05 <nand`> but if you already know what you want, it's probably a good idea to go for that instead
11:20:11 <tew88> Ha!
11:20:21 <nand`> tew88: my point being; you don't really need more of an IDE than a plain text editor with highlighting + GHCi
11:20:22 <srhb> And yeah, I did not mean to join in the gospel. :-) I just like my Emacs...
11:20:27 <nand`> so use whatever suits you
11:20:44 <tew88> Well yeah, the tips I've received weren't necessarily the ones I was after, but I'm grateful nonetheless and may do some probing =)
11:21:02 <monochrom> this channel is full of mouse-deniers
11:21:04 <nand`> tew88: ah, but get well-acquainted with hoogle and hayoo; they're extremely useful tools
11:21:10 <bindy> parcs`: I guess being an instance of a class behaves differently from just a function
11:21:44 <tew88> nand`: hayoo I've not heard of---ty
11:22:45 <srhb> tew88: It's hoogle, but for all things on Hackage
11:22:45 <parcs`> bindy: that inner call to fromList is a different fromList, essentially. inductive type class instances are amazing like that
11:23:11 <parcs`> bindy: the type inference engine figures out how many recursive calls are needed to full apply the type
11:23:21 <parcs`> so in this case fromList ["why", "hello", "there"] A
11:24:05 <nand`> I don't like hayoo for some reason personally. I don't like the way it presents the functions it finds and I think hoogle finds more relevant results in the extremely limited test cases I've done
11:24:15 <bindy> parcs`: oh my god, this is totally awesome!
11:24:36 <bindy> I think I am not going to bed tonight :)
11:26:29 <monochrom> actually I don't type inference figures out or cares how many recursive calls are needed. unless I misunderstand "how many recursive calls"
11:26:49 <parcs`> in this case fromList ["why","hello","there"] A gets expanded to something like let (a:as) = ["why","hello","there"] in let (b:bs) = as in let (c:cs) = bs in (((A a) b) c)
11:31:52 * hackagebot kure 2.2.0 - Combinators for Strategic Programming (NeilSculthorpe)
11:36:57 <mcstar> mroman: what do you mean? value constructors can be partially applied, they are curriedfunctions
11:37:10 <parcs`> monochrom: feel free to correct. i don't deeply know what i'm talking about
11:37:41 <mdmkolbe> @seen tgeeky
11:37:42 <lambdabot> Unknown command, try @list
11:38:54 <geekosaur> preflex: xseen tgeeky
11:38:54 <preflex>  tgeeky was last seen on freenode/#haskell 2 days, 12 hours, 32 minutes and 18 seconds ago, saying: !!
11:47:08 <ksf_> can someone help me with a type error?
11:47:10 <ksf_> http://hpaste.org/71411
11:48:03 <monochrom> which line is line 146?
11:48:16 <ksf_> cY
11:48:54 <monochrom> there are many lines containing "cY"
11:48:58 <ksf_> oh. I see.
11:49:10 <ksf_> thanks for pointing out that there's actually a telling line number.
11:49:19 <ksf_> the definition of cY
11:49:22 <ksf_> at the very top.
11:49:30 <ksf_> in ybu, it's used as a list parser.
11:49:36 <ksf_> ...but matches is ()
11:50:11 <monochrom> sorry, could you just tell me the whole line 146, verbatim?
11:50:23 <ksf_>     cY <- newRule $ matches cmavo
11:50:27 <ksf_> it's wrong.
11:50:40 <ksf_> it's the last one, and incomplete.
11:51:06 <Nereid> could you just paste the whole file?
11:51:14 <monochrom> what are the types of newRule? matches? convo?
11:51:22 <ksf_> it's a frisby parser.
11:51:32 <ksf_> guys, I'm trying to tell you that the search is over.
11:51:43 <ksf_> ...and that's approximately the whole file.
11:51:50 <monochrom> alright
11:52:28 <ksf_> but it's *extremely* annoying that ghc barfs the whole thing -- twice.
11:53:05 <nand`> that's why I avoid huge definitions
11:53:11 <monochrom> I don't know about that. some people want it. under a different example, of course
11:53:44 <ksf_> nope, it's not helping.
11:54:15 <monochrom> sure, it doesn't help this example. it helps some other example.
11:54:27 <ksf_> http://hpaste.org/71415
11:54:31 <ksf_> that's the whole thing.
11:54:34 <monochrom> at least some people claim so
11:55:09 <monochrom> you are better off voicing in the ghc mailing list saying that you want less
11:55:24 <ksf_> I'm about to file a bug.
12:04:18 <mcstar> some code
12:12:17 <saml> teach me functional programming
12:12:46 <Nereid> @where lyah
12:12:46 <lambdabot> http://www.learnyouahaskell.com/
12:13:38 <saml> i mean conceptually.. something like OOP patterns
12:14:28 <ion> Would it make sense to learn all about OOP patterns without a single example of an actual OOP language?
12:14:31 <Nereid> ^
12:15:46 <mcstar> the two kind of languages solve different problems
12:15:52 <mcstar> so a comparison is of no use
12:16:09 <cesc> what's functional programming optimally suited for?
12:16:21 <nand`> programming functional things
12:16:27 <cesc> :D nice
12:16:32 <saml> help me to understand functional things
12:16:43 <saml> is it only for mathematics ?
12:16:46 <tromp> for writing lambda calculus interpreters
12:16:54 <saml> ah thanks
12:16:56 <copumpkin> saml: you've been around this community way too long to be asking questions like that
12:17:15 <nand`> the reason I love functional programming is because it bases on underlying mathematical intuition
12:17:19 <saml> i'm re-evaluating everything from time to time
12:17:24 <nand`> eg. the concept of a function
12:17:26 <copumpkin> heh, okay
12:17:50 <mcstar> the smart few solve hard problems with functional languages, writing beautiful code, and thinking smart all the time, the OO languages are for drones, who write boilerplate without thinking much
12:18:02 <copumpkin> lol
12:18:08 <copumpkin> EXACTLY
12:18:14 <Philippa> mcstar: y'know, that's not really an attitude I like to encourage
12:18:28 <mcstar> yeah, im j/k
12:18:30 <Philippa> you can be a drone in any language you can just about convince someone you've solved their problem in
12:18:40 <cesc> well, I must say learning Haskell and writing code has really got me thinking more about what the hell I'm doing, which is good. So I second that :D
12:18:40 <mcstar> (thats what people would like to think^^)
12:18:41 <Philippa> yeah, this chan has a bit of a case of Poe's Law on that one
12:18:43 <zachk> saml: that is a standard Eastern Religion/Philosophy technique, you have been studying under a Master for 20+ years and you still ask: how do I meditate from time to time ;)
12:19:00 <nand`> writing Haskell has made me appreciate elegance
12:19:14 <nand`> well, I've been looking for it before, but I've had trouble finding it
12:19:18 <cesc> I hope elegance and performance are compatible
12:19:29 <Philippa> writing Haskell has made me even less tolerant of languages that are shite at embedding
12:19:29 <nand`> cesc: sometimes they are, sometimes they aren't
12:19:32 <aristid> nand`: i think elegance is defined by Perl data structures
12:19:48 <otters> oh boy
12:19:51 <nand`> aristid: I don't know much perl. I've avoided the language as much as I could, what's elegant about its data structures?
12:19:54 <nand`> or was that sarcasm?
12:19:54 <otters> after working with ruby for about 23 minutes
12:20:07 <otters> I realized how much easier it is in Haskell to compose anything you could possibly ever want
12:20:37 <aristid> nand`: i wasn't really serious :)
12:20:41 <cesc> nand`, I will come to my conclusion when I am able to implement a couple (pseudo) random-number generators and see what I gain with respect to fortran/c in terms of performance, debugging, etc :)
12:20:53 <nand`> another thing I like about Haskell is how compact it is: definitions in good code are clear and straightforward
12:20:54 <mcstar> cesc: nothing
12:20:54 <Philippa> mcstar: we do have a genuine problem around here with clashes of attitude about eg Kay's views on OO
12:21:04 <Philippa> (and really, if anybody's allowed a view on the subject...)
12:21:04 <aristid> nand`: although accessing a data structure and seeing it spontaneously build itself can be fun
12:21:15 <nand`> also sum types have redefined the way I think about data structures in programming
12:21:28 <saml> do you start with data and class?
12:21:32 <Philippa> nand`: hah! Suffice to say I've hit the walls past which encoding overhead becomes a PITA again? :-)
12:21:39 <nand`> aristid: how is that any more impressive than laziness?
12:21:40 <saml> it takes a long time for me to come up with proper data
12:21:40 <Philippa> but it sure shows you things can and should be better
12:21:54 <aristid> nand`: it isn't :)
12:21:55 <zachk> I like the type checking, and the real world tradeoffs that are usually made by the ghc team without comprosing the core values (whatever those are)
12:21:57 <saml> with OO, i just create a class and add a bunch of methods.. and refactor
12:21:59 <cesc> mcstar, well, at least one might get the feeling for more robust code in Haskell. I don't mind paying a bit in terms of performance for that.
12:22:26 <Philippa> "what should I be able to do with it?" is still a sensible question in Haskell
12:22:27 <aristid> nand`: i'm not under the impression that the things that are being said now are to be taken overly seriously
12:22:29 <nand`> cesc: in Haskell, your pseudo-random number generator will be an infinite list :)
12:22:34 <nand`> do with it what you want
12:22:54 <cesc> cesc compile error xD
12:23:00 <nand`> aristid: I see. I'm quite tired, and probably bad with these things
12:23:16 <saml> how would you represent  Gates that have input and output ports and connections between ports?
12:23:21 <mcstar> cesc: afaik, random number generators are pretty self-contained, short programs, i dont think you gain particularly much with haskell, and you have to write possible worse looking code than in c/fortran
12:23:37 <nand`> saml: as a function between fixed length vectors?
12:23:38 <mcstar> (for similar performance that is)
12:24:14 <zachk> saml :: Gates :: Bool -> Bool -> Bool , and just pipe them together with whatever your preferred method of composition is
12:24:27 <Philippa> mcstar: write a good high-level bit-munging lib, some rules and let the inliner rip
12:24:30 <saml> nand`, coudl you give me an example?
12:24:56 <Philippa> "high-level" in that anything you find yourself /thinking/ when writing such things should be doable directly rather than having to fill it all out
12:24:58 <saml> zachk, isThereConnection port1  port2   ?
12:25:04 <cesc> mcstar, sure. I just used the PRNG example because it's the main tool for what I usually do (monte carlo simulations). I just wanted to try haskell out and see how comfortable I feel working with it in comparison to c/fortran. Just an experiment for fun.  I'm learning slowly (too few free time), but I'm enjoying every bit of it. Haven't had this fun with programming in a while :) At least there's that to it :)
12:25:12 <nand`> myGateThatDoesLotsOfCoolThings :: (Bool, Bool, Bool) -> (Bool, Bool) -- though currying makes this isomorphic to Bool -> Bool -> Bool -> (Bool, Bool); use whichever one is better for eg. composition
12:25:13 <aristid> nice to see how much the situation with HTTP has improved in the last 3 years: http://www.reddit.com/r/haskell_proposals/comments/7ihq8/improve_http/
12:25:23 <mcstar> cesc: im doing a toy monte carlo atm
12:25:26 <mcstar> :)
12:25:58 <cesc> mcstar, no kidding! it would be great for my education if you could post some code snippets (if the code is not under some crazy license) :)
12:25:58 <nand`> :t randoms -- cesc there's your PRNG
12:25:59 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
12:26:02 <Philippa> mcstar: there's actually a lot you can do in terms of showing motivation and/or explaining correctness in bit-twiddling code, y'know?
12:26:08 <mcstar> (actually, i want to solve a problem for my thesis with MC, we will see)
12:26:15 <zachk> MC?
12:26:19 <nand`> monte carlo
12:26:21 <cesc> nand`, sure, but in the MC business one needs to know the PRNG in and out
12:26:23 <zachk> ahh
12:26:35 <nand`> cesc: that's where your own RandomGen / Random instances come in handy
12:26:36 <cesc> mcstar, you a physicist too?
12:26:40 <mcstar> yes
12:26:49 <cesc> hooray! :D
12:26:50 <otters> @hoogle RandomGen g => g
12:26:50 <mcstar> well, going to be
12:26:50 <lambdabot> Prelude undefined :: a
12:26:50 <lambdabot> Data.Function fix :: (a -> a) -> a
12:26:51 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
12:26:52 <zachk> shouldn't a good mc-algorithm be semi-prng agnostic?
12:27:00 <otters> that hardly helps
12:27:07 <otters> @instances RandomGen
12:27:08 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
12:27:18 <mcstar> zachk: im using the mersenne twister package, dont care about the generator, just be fast
12:27:21 <nand`> http://hackage.haskell.org/packages/archive/random/latest/doc/html/System-Random.html#t:RandomGen
12:27:24 <cesc> nand`, oh thx for the typ
12:27:26 <mcstar> possibly should use gsl
12:27:52 <nand`> cesc: a common pattern in Haskell is that you shouldn't ever really have to duplicate work; since things are so easily generalized due to the powerful type system
12:27:56 <mcstar> i should be doing this on the GPU, but... there are some complications
12:28:17 <nand`> so you just implement your PRNG algorithm and all of the functions dealing with random number generation work as intended
12:28:18 <cesc> mcstar, I'm using (in fortran by now) a combination of two linear PRNGs (simple enough to understand the maths) with a decent period  (10^18 or so).
12:28:44 <nand`> cesc: http://hackage.haskell.org/package/monte-carlo
12:28:47 <cesc> nand`, sure. But this particular part of the code must really be under control. Otherwise stupid mistakes (correlation in data or whatever) easily slip in.
12:28:47 <nand`> maybe this could come in handy
12:29:19 <nand`> cesc: well, if your list-generation algorithm will deviate reasonably from the default ‘randoms’ feel free to implement it, as it will not be duplicating work then
12:29:23 <zachk> cesc: cryptol might be a DSL for you, I think it is commercial though
12:29:26 <nand`> I'm just saying :)
12:29:36 <cesc> what's a DSL?
12:29:42 <zachk> domain specific language
12:30:29 <mcstar> i think he need specific distributions or something
12:30:32 <cesc> oh
12:30:33 <mcstar> needs*
12:30:34 <zachk> cryptol is for modeling crypto algorithms, it is by Galois Theory, iirc linear feedback etc, full under the domain of/are similar to/can be used in : cryptography
12:30:37 <Taneb> Is Haskell On A Horse alive?
12:30:43 <zachk> what does that even mean
12:30:55 <monochrom> yes
12:31:38 <jimmy875> hello
12:31:43 <Taneb> Hey
12:31:44 <zachk> Taneb: yes, but...someone keeps shooting the horse..but no worries, the rider has an infinite stable full of them and teleport through proper lifting of abstract structures
12:31:52 <dgpratt> I have a question regarding this: http://www.haskellforall.com/2012/07/breaking-from-loop.html
12:32:25 <dgpratt> in the example where he uses runEitherT, he also is using 'lift' for the IO actions, but...
12:32:44 <nand`> the horse is riding on another horse, and when one dies, it will just fall off allowing the rider to continue riding on the one below
12:32:48 <nand`> don't worry, it's horses all the way down
12:32:48 <dgpratt> ...not when using runMaybeT
12:32:52 <chrisdone> ksf_: you writing a lojban orthography parser with frisby. did precisely the same some years back, ghc ran out of do (i think 32 or 64) statements
12:33:29 <monochrom> oh great, another Either vs Cont debate
12:33:29 <jhance> dgpratt: MonadIO is kind of similar to MonadTrans but easier to use... so liftIO is generally easier (since IO is almost always the base before any other transformers are applied)
12:33:45 <jhance> dgpratt: If you are questioning the consistency/best practice
12:34:05 <chrisdone> monochrom: Either stop being a bunch of Conts or get out!
12:35:16 <mcstar> cesc: are you there
12:35:18 <mcstar> ?
12:35:42 <zachk> chrisdone: :-D
12:35:47 <chrisdone> ksf_: here's parsec: http://paste.lisp.org/display/66142
12:35:47 <chrisdone> ksf_: but that was too slow, then i did: http://paste.lisp.org/display/66078
12:36:08 <cesc> mcstar, back, was afk.   what happened xD
12:36:22 <mcstar> cesc: i just tried to talk to you in private
12:36:26 <chrisdone> ksf_: if you complete your orth parser, please drop me a line, that's cool!
12:36:29 <cesc> ah! now I see it
12:36:35 <chrisdone> zachk: ;)
12:36:48 <chrisdone> Baughn: hey. how are you?
12:37:04 <dgpratt> jhance: in the case where he is using runMaybeT, I don't see any kind of 'lifting' going on at all; have I overlooked something?
12:37:33 <zachk> chrisdone: MaybeT ? IO don't know
12:38:22 <monochrom> pretty sure it should be "liftIO getLine" for MaybeT too
12:40:05 <chrisdone> monochrom: or lift, i spose
12:40:28 <Baughn> chrisdone: Good
12:40:28 <Baughn> chrisdone: Reading up on appengine (and efforts to port haskell to it), at the moment
12:40:28 <Baughn> chrisdone: ..for the eventual purpose of porting hackage to something less prone to failure.
12:40:28 <Baughn> *Someone* needs to do it. Might as well be me. :P
12:40:28 * Baughn lost several hours of data yesterday because hackage was down. :/
12:41:47 <srhb> Baughn: Do we know _why_ Hackage was down?
12:42:12 <geekosaur> yes, see thread on -cafe
12:42:18 <srhb> Ah, thanks
12:42:55 <geekosaur> someone was hammering the search function and overloaded and crashed it
12:43:02 <Igloo> Baughn: How did you lose data OOI?
12:43:02 <geekosaur> and it took a while to fsck afterward
12:43:03 <srhb> Oh dear.
12:43:04 <chrisdone> Baughn: google app engine?
12:43:34 <srhb> It would probably be easier to run off an Amazon elastic whatever.
12:43:37 <aristid> Baughn: is there public material on the efforts to port app engine to haskell?
12:45:30 <dgpratt> monochrom: supposing that is so, I feel better, thanks
12:46:15 <Qrt> is there some computer science channel?
12:46:34 <monochrom> no
12:46:42 <aristid> monochrom: no?
12:46:53 <shirt> Qrt: maybe ##math
12:47:05 <aristid> freenode has like a million billion channels, and none of them are primarily about CS?
12:47:44 <monochrom> I don't know why. you can try to start one
12:48:53 <monochrom> but if you start now, you're already disadvantaged to stackoverflow
12:49:00 <aristid> monochrom: no, i don't really want to be in a CS channel
12:49:15 <Philippa> yeah, it's a bit general without being general /enough/
12:49:25 <aristid> monochrom: it just seems unlikely to me that there are no CS channels on freenode at all
12:49:44 <monochrom> consider the possibiity that everyone thinks like you
12:49:51 <silver> I'm sure there is a list of channels
12:49:54 <chrisdone> Philippa: i like your quiff :)
12:50:02 <chrisdone> (if you can call it a quiff)
12:50:10 <aristid> monochrom: haha, that would be a weird world. it would grind to halt, too
12:50:25 <chrisdone> maybe a fringe. a friff. a quinge
12:50:43 <monochrom> just in the aspect of not wanting to join a compsci channel anyway
12:50:44 <silver> chrisdone, waffles?
12:51:03 <Philippa> chrisdone: a (non-emo) frullet with a centre parting? :-)
12:51:11 <aristid> monochrom: well, i guess that world wouldn't necessarily grind to a halt
12:51:13 <chrisdone> right :)
12:51:25 <monochrom> I run #compsci. on efnet. no one else is interested
12:51:27 * chrisdone chuckles at the “non-emo”
12:51:46 <Philippa> doesn't entirely fit the twitter pic, I realise :p
12:51:50 <chrisdone> monochrom: forever alO(n)e
12:51:54 <aristid> monochrom: now if everybody thought like you, the world's #compsci channels would be full
12:51:55 <monochrom> before stackoverflow, people joined #compsci, finished school, got real jobs, left #compsci
12:52:09 <silver> heh
12:52:17 <chrisdone> Philippa: i had to look at it closely to figure it out yeah :p
12:52:24 <monochrom> after stackoverflow, there is not even an incentive to try IRC to begin with
12:52:51 <monochrom> no no, i think you got the consequence wrong...
12:53:05 <objectivity> I use IRC. :-(
12:53:06 <monochrom> if everyone thought like me, the world would be full of #compsci channels... XD
12:53:32 <aristid> monochrom: i guess that can't be ruled out :)
12:53:55 <bitrust> @hoogle Word16 -> (Word8,Word8)
12:53:56 <lambdabot> Control.Monad.Trans.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
12:53:56 <lambdabot> Control.Monad.Trans.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
12:53:56 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
12:54:07 <Philippa> so I'm not sure stackoverflow has that effect on me?
12:54:13 <bitrust> @hoogle Bits
12:54:14 <Philippa> but I fucking hate web 2.0 in general
12:54:14 <lambdabot> Data.Bits class Num a => Bits a
12:54:14 <lambdabot> Data.Bits bitSize :: Bits a => a -> Int
12:54:14 <lambdabot> Data.Bits module Data.Bits
12:54:17 <Philippa> it's a UI clusterfuck
12:54:38 <monochrom> I ran #haskell on efnet too, btw. not anymore. no one was ever interested. except wli. but wli was pretty quiet, too
12:55:00 <silver> why use efnet then
12:55:17 <monochrom> I do blame all of you for causing disinterest in my #haskell!
12:55:23 <Philippa> why use effingnet at all?...
12:55:25 <bitrust> > bitSize (4::Word8)
12:55:27 <lambdabot>   8
12:55:32 <bitrust> > bitSize (4::Word16)
12:55:33 <lambdabot>   16
12:55:45 <Philippa> hmmm. Yeah, I really am one of the harsher people in here these days, aren't I?
12:55:54 <monochrom> I started irc on efnet. that's all.
12:55:55 <Philippa> that, or cranky today
12:55:59 <Philippa> *nod*
12:56:14 <Philippa> yeah, if it helps any, one of my early main chans was there too
12:56:29 * silver hugs Philippa 
12:56:53 <Philippa> silver: um. Hugging me when I'm cranky isn't necessarily conducive to your health?
12:57:07 <silver> yes
12:57:18 <Philippa> nothing personal there, the exceptions apply pretty much to people who know me /really/ well
12:57:32 <silver> :-)
12:57:51 <bitrust> > rotateR (321::Word16) (bitsize (321::Word16)
12:57:53 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:57:58 <Philippa> (biblical pun not intended, but what the hell)
12:58:19 <bitrust> > rotateR (321::Word16) (bitSize (321::Word16)
12:58:20 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:58:29 <silver> closing bracket
12:58:32 <bitrust> > rotateR (321::Word16) (bitSize (321::Word16)) -- Aaarrggghhh
12:58:34 <lambdabot>   321
12:58:44 <silver> your lisp eyes failed you!
12:59:16 <bitrust> :). Anyone have any ideas on Word16 -> (Word8, Word8)
12:59:30 <bitrust> Want it to do exactly what you'd expect
12:59:46 <c_wraith> LE or BE?
12:59:56 <mroman> high, lowbytes
12:59:59 <mroman> obviously
13:00:04 <Nereid> why not low,high
13:00:24 <monochrom> neither. odd-indexed bits go to the 2nd, even-indexed bits go to the 1st
13:00:31 <silver> lol
13:01:02 <c_wraith> :t (.&.)
13:01:03 <lambdabot>     Ambiguous occurrence `.&.'
13:01:03 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
13:01:04 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
13:01:08 <c_wraith> ick
13:01:12 <bitrust> Umm... first 8 and second 8
13:01:19 <bitrust> Yes, what I'd expect ;)
13:01:32 <c_wraith> bitrust: that's the opposite of useful.  does "first" mean "low" or "high"?
13:01:32 <silver> shift and xor
13:01:33 <bitrust> Either order too, just something!
13:02:05 <Nereid> > fromIntegral (0x12ff :: Word16) :: Word8
13:02:06 <lambdabot>   255
13:02:08 <aristid> :t (Test.QuickCheck..&.)
13:02:09 <lambdabot> forall prop1 prop2. (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
13:02:10 <Nereid> that gets you the low byte
13:02:17 <Nereid> and then you can shift to get the high byte
13:02:30 <silver> nice
13:02:34 <monochrom> it is time you give a concrete example so we stop mincing what is "first"
13:02:39 <aristid> why does QuickCheck use .&. for that? :/
13:02:54 <monochrom> example: "0 -> (0,0)" :D
13:02:59 <silver> :D
13:03:30 <bitrust> Well it's Word16 input, need to split it into two Word8 presumbly least significant byte firs.t
13:03:40 <aristid> cabal update is really slow over 3G
13:03:59 <Nereid> bitrust: did you see what I did
13:04:01 <monochrom> I'm sorry to hear that you're stuck with 3G
13:04:44 <bitrust> Nereid: Yes, sorry I'm distracted by my surroundings!
13:05:26 <bitrust> @info fromIntegral
13:05:27 <lambdabot> fromIntegral
13:05:35 <silver> @src fromIntegral
13:05:36 <lambdabot> fromIntegral = fromInteger . toInteger
13:05:55 <bitrust> Ah, I just mistyped it in GHCi and was wondering where it was... clearly Prelude.
13:05:57 <silver> @type fromIntegral
13:05:59 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:06:03 <Nereid> > map fromIntegral . iterate (shiftR 8) $ 0x5040302010 :: [Word8]
13:06:05 <lambdabot>   [16,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8,0,8...
13:06:11 <Nereid> oops
13:06:56 * hackagebot digestive-functors 0.5.0.2 - A practical formlet library (JasperVanDerJeugt)
13:07:28 <Nereid> > map fromIntegral . iterate (flip shiftR 8) $ 0x5040302010 :: [Word8]
13:07:31 <lambdabot>   [16,32,48,64,80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
13:08:44 <Nereid> I guess one could represent p-adic numbers by such lists.
13:08:47 <Nereid> obviously.
13:09:16 <bitrust> Ok, got it, slightlyt less distracted. Thanks Nereid.
13:09:16 <aristid> > -1 :: Word8
13:09:17 <lambdabot>   255
13:09:22 <aristid> *giggle*
13:09:32 <Nereid> > map fromIntegral . iterate (flip shiftR 8) $ -1 :: [Word8]
13:09:34 <lambdabot>   [255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,25...
13:09:37 <Nereid> *giggle*
13:09:48 <aristid> Nereid: :)
13:10:26 <aristid> Nereid: that shiftR operates on it as an Integer, right?
13:10:29 <Nereid> yes
13:10:44 <aristid>  > map fromIntegral . iterate (flip shiftR 8) $ (-1 :: Int) :: [Word8]
13:10:58 <Nereid> stray space at the front
13:11:00 <aristid> > map fromIntegral . iterate (flip shiftR 8) $ (-1 :: Int) :: [Word8]
13:11:02 <lambdabot>   [255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,25...
13:11:05 <Nereid> aw.
13:11:08 <aristid> yeah, c&p error :(
13:11:10 <objectivity> Is anyone familiar with Pipes-2.1.0 -- I need a small code review.
13:11:21 <Nereid> I was hoping it was Integer, anyway.
13:11:24 <aristid> > map fromIntegral . iterate (flip shiftR 8) $ (-1 :: Word32) :: [Word8]
13:11:27 <lambdabot>   [255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:11:29 <Nereid> > shiftR (1 :: Integer) 8
13:11:30 <lambdabot>   0
13:11:34 <Nereid> > shiftR (-1 :: Integer) 8
13:11:35 <lambdabot>   -1
13:11:43 <Nereid> > shiftR (-1 :: Int) 8
13:11:45 <lambdabot>   -1
13:11:47 <Nereid> yeah.
13:11:58 <aristid> Nereid: it seems that shiftR pulls in the 1 bits for negative numbers
13:12:04 <aristid> if the type is signed
13:12:32 <Nereid> I guess it's doing a zero extend then.
13:12:42 <Nereid> er sign extend
13:12:50 <aristid> yes
13:12:51 <Nereid> since Int is a signed type or something
13:13:20 <Nereid> > bitSize (undefined :: Int)
13:13:21 <lambdabot>   64
13:13:31 <Nereid> > bitSize (undefined :: Integer)
13:13:33 <lambdabot>   *Exception: Data.Bits.bitSize(Integer)
13:13:35 <aristid> > shiftR (-8) 1
13:13:36 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:13:37 <lambdabot>    `Data.Bits.Bits a'
13:13:37 <lambdabot>      a...
13:13:42 <aristid> > shiftR (-8 :: Integer) 1
13:13:44 <lambdabot>   -4
13:13:47 <srhb> :t bitSize
13:13:48 <lambdabot> forall a. (Bits a) => a -> Int
13:13:49 <aristid> > shiftR (-8 :: Integer) 20
13:13:51 <lambdabot>   -1
13:14:15 <aristid> > bitSize (0 :: Integer)
13:14:16 <lambdabot>   *Exception: Data.Bits.bitSize(Integer)
13:14:20 <Nereid> > shiftR (-1 :: Int) 256
13:14:21 <lambdabot>   -1
13:14:33 <Nereid> bitSize ignores the value.
13:14:41 <Nereid> it's constant for each type
13:14:46 <saml> what are you doing people?
13:15:01 <Nereid> > popCount (-1 :: Int)
13:15:03 <lambdabot>   Not in scope: `popCount'
13:15:05 <saml> where is bitSize defined?
13:15:10 <Nereid> Data.Bits
13:15:13 <aristid> Nereid: did i indicate i didn't know that bitSize is constant? :P
13:15:29 <aristid> Nereid: it's just that it doesn't make sense for Integer, yet Integer has a Bits instance
13:15:39 <Nereid> a lot of the other things work for Integer
13:15:53 <aristid> yeah
13:15:56 <saml> > bitSize 2342374897892893947894537892456234805648628694789562947865378567856347878465746875637534786784637856378583648574637846478834534
13:15:58 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:15:58 <lambdabot>    `Data.Bits.Bits t'
13:15:58 <lambdabot>      a...
13:16:01 <Nereid> > complement 1 :: Integer
13:16:03 <lambdabot>   -2
13:16:14 <saml> it's all broken
13:16:17 <Nereid> > bit 64 :: Integer
13:16:18 <lambdabot>   18446744073709551616
13:16:23 <aristid> Nereid: is complement ever different from negate?
13:16:30 <Nereid> it's always different from negate
13:16:48 <aristid> Nereid: i mean with the addition
13:16:50 <otters> @check (\x -> negate x == complement x)
13:16:53 <lambdabot>   Add a type signature
13:17:02 <otters> @check (\(x :: Integer) -> negate x == complement x)
13:17:02 <lambdabot>   Parse error in pattern at "->" (column 18)
13:17:06 <otters> ugh.
13:17:07 <Nereid> @check (\x -> negate x == complement x - 1 :: Integer)
13:17:08 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
13:17:13 <Nereid> oops
13:17:18 <copumpkin> moar parens
13:17:21 <otters> @check (\x -> negate (x :: Integer) == complement x)
13:17:22 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
13:17:27 <Nereid> @check (\x -> negate x == complement x - 1 :: (Integer -> Bool))
13:17:29 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer
13:17:31 <Nereid> come on.
13:17:35 <otters> @check (\x -> negate (x :: Integer) == complement x + 1)
13:17:37 <lambdabot>   "OK, passed 500 tests."
13:17:43 <Nereid> or that.
13:17:53 <otters> > negate 1 == complement 1 + 1
13:17:55 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:17:55 <lambdabot>    `Data.Bits.Bits t'
13:17:55 <lambdabot>      a...
13:18:02 <otters> > negate (1 :: Integer) == complement 1 + 1
13:18:04 <lambdabot>   True
13:18:09 <otters> > negate (1 :: Integer)
13:18:11 <lambdabot>   -1
13:18:12 <otters> oh wait a second
13:18:15 <Nereid> lol
13:18:19 <otters> complement is applying to (1 + 1
13:18:20 <otters> )
13:18:23 <Nereid> no it's not
13:18:24 <otters> so it should actually be -1
13:18:27 <nand`> > complement 1
13:18:29 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:18:29 <lambdabot>    `Data.Bits.Bits a'
13:18:29 <lambdabot>      a...
13:18:29 <otters> really?
13:18:30 <otters> heh
13:18:32 <nand`> > complement 1 :: Integer
13:18:32 <otters> oh man, I'm silly
13:18:34 <lambdabot>   -2
13:18:54 <nand`> @check \a b -> negate a == complement a + (a :: Integer)
13:18:56 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n()\n"
13:18:59 <Nereid> why doesn't lambdabot know about popCount?
13:19:06 <Nereid> maybe it's new
13:19:09 <copumpkin> it is new
13:19:19 <Nereid> ghci time :)
13:19:56 <MagneticDuck> hey guys, I just discovered how make a vimmer working on a deadline explode
13:20:02 <MagneticDuck> turn on his capslock
13:20:07 <nand`> what capslock
13:20:13 <SimonJF> hahaha :P
13:20:27 <MagneticDuck> well, I guess a lot already have the capslock mapped to the escape key
13:20:27 <hpc> lol
13:20:29 <Nereid> > map popCount [1,-1 :: Integer] -- [1,
13:20:31 <lambdabot>   Not in scope: `popCount'
13:20:51 <nand`> I don't have capslock. I have a new modifier in between tab and left shift
13:21:04 <MagneticDuck> I discovered it by personal experience. I was the vimmer.
13:21:14 <Nereid> I've done that.
13:22:05 <MagneticDuck> yeah, that's the smart way to do it. I have a little light on my caps lock, so if I relabel it to "edit mode" it's would be quite nifty
13:22:22 <MagneticDuck> I'll do that right after I get out from under this deadline
13:22:22 <MagneticDuck> :D
13:22:24 <Nereid> assuming you can control the led
13:22:35 <MagneticDuck> the hardware takes care of that
13:23:03 <Nereid> "edit mode" is capslock, then?
13:23:05 <Nereid> :P
13:23:06 <MagneticDuck> I'm working on a thinkpad btw, so it's a tad different on other computers
13:23:07 <MagneticDuck> yeah
13:23:12 <bitrust> MagneticDuck: You've got a Mac?
13:23:13 <MagneticDuck> that would actually be nice
13:23:16 <MagneticDuck> ARR
13:23:18 <MagneticDuck> nononononono
13:23:21 <Nereid> lol
13:23:30 <MagneticDuck> not.
13:23:32 <MagneticDuck> not.. the mac
13:23:55 <MagneticDuck> well I have to admit that macs are well made
13:24:10 <Nereid> oh, you can control the keyboard LEDs in software. cool
13:24:18 <MagneticDuck> not on a thinkpad
13:24:19 <Qrt> would it b wrong to say that haskell in a sense generalises java in some aspects. like you have functions over all objets instead of binding them to a class?
13:24:22 <MagneticDuck> well I'm not sure
13:24:35 <Nereid> well I'm sure it's done in software.
13:24:42 <MagneticDuck> very low level software
13:24:51 <MagneticDuck> that might not even be tied into the os
13:24:56 <MagneticDuck> :D
13:25:30 <silver> Qrt, sounds false for me
13:25:57 <Nereid> MagneticDuck: setleds(1)
13:25:58 <Nereid> ;)
13:26:01 <MagneticDuck> :O
13:26:04 <nand`> Qrt: I wouldn't think of Haskell as having any connection to Java
13:26:10 <nand`> generlized or otherwise
13:26:13 <nand`> generalized*
13:26:40 <nand`> Haskell is its own thing, designed to be logical. If you see parallels, they're probably coincidental
13:27:17 <MagneticDuck> you could also say haskell is a bit like C because you can pass functions as parameters
13:27:20 <nand`> (it's also older than Java)
13:27:36 <MagneticDuck> except in haskell, it's much more advanced and supported
13:27:42 <silver> yeah, to make such claims you need at least map haskell terminology to java one
13:27:53 <mcstar> we all know, java made lambda's popular by not using them
13:27:59 <silver> lol
13:28:03 <MagneticDuck> yeah
13:28:03 <silver> anonymous classes!
13:28:05 <MagneticDuck> same with C
13:28:29 <MagneticDuck> I hope I never have to use anything that doesn't support a composition function in the base library
13:28:37 <MagneticDuck> :D
13:28:50 <MagneticDuck> "if it's not functional, it's dysfunctional"
13:29:05 <MagneticDuck> btw I was wondering the other day...
13:29:13 <jfischoff> @quote dysfunctional
13:29:13 <lambdabot> Jafet says: The C preprocessor is purely dysfunctional
13:29:23 <jfischoff> @quote dysfunctional
13:29:23 <lambdabot> unknown says: codependent types are useful for dysfunctional programming
13:29:42 <MagneticDuck> values are grouped into non-intersecting sets, called "types"
13:29:51 <MagneticDuck> and also grouped into sets called "type classes"
13:30:04 <MagneticDuck> where all the values in a type class share a few proprieties
13:30:16 <mcstar> you grasped the type system!
13:30:18 <MagneticDuck> arr
13:30:19 <MagneticDuck> dam
13:30:20 <MagneticDuck> no
13:30:29 <MagneticDuck> that's not true
13:30:34 <MagneticDuck> let's try this again
13:30:38 <MagneticDuck> values are grouped into non-intersecting sets, called "types"
13:30:40 <Nereid> it is, depending on what you mean by "properties"
13:30:46 <jfredett> MagneticDuck: sets is probably the wrong word.
13:30:51 <Philippa> type classes have instances, which are associated with tuples of types
13:30:55 <MagneticDuck> and types are grouped inot non-intersecting sets called "kinds"
13:31:07 <MagneticDuck> there are "type classes" to group types
13:31:25 <MagneticDuck> but nothing to group all the values that share a property!
13:31:28 <Qrt> erxplain abstract algebra to the average person
13:31:33 <MagneticDuck> like all the functions that have an inverse
13:31:51 <mcstar> you can make a typeclass for that, cant you?
13:31:54 <MagneticDuck> all the values of a certain type which share a propriety
13:31:56 <silver> Qrt, are you seroius?
13:31:56 <MagneticDuck> no you can't
13:32:08 <MagneticDuck> mcstar: typeclasses group TYPES
13:32:12 <MagneticDuck> not values
13:32:14 <mcstar> MagneticDuck: but a value has to belong a type
13:32:17 <MagneticDuck> oh
13:32:18 <MagneticDuck> >_<
13:32:20 <MagneticDuck> never mind
13:32:20 <MagneticDuck> wait
13:32:23 <MagneticDuck> then what's missing
13:32:28 <MagneticDuck> there's nothing to group types
13:32:30 <MagneticDuck> ahah
13:32:36 <mcstar> wtf
13:32:37 <Qrt> silver: yes, why not?
13:32:48 <mcstar> MagneticDuck: you ate something funny?
13:32:50 <silver> can't read a book?
13:32:54 <Qrt> (about abstract)
13:32:57 <silver> can't you read a book?
13:32:59 <Nereid> abstract algebra is what you take what you see in algebra and abstract it
13:33:01 <MagneticDuck> wait never mind
13:33:04 <Nereid> er
13:33:06 <MagneticDuck> okay forget all of this
13:33:08 <Nereid> what you get when you take what you see
13:33:19 <MagneticDuck> mcstar: nah, I probably just had a bad case of not thinking before hitting enter
13:33:20 <jfredett> MagneticDuck: sure there is -- a type class is a class of types, those types are typically grouped by sharing some common property
13:33:31 <mcstar> MagneticDuck: np, im having fun :)
13:33:48 <MagneticDuck> that's right
13:34:07 <silver> yeah, seems like he wanted to have subtypes in types that can cross borders of types
13:34:08 <silver> :D
13:34:14 <Nereid> Qrt: example, the integers have an addition operation, and there is a special integer 0
13:34:17 <MagneticDuck> ahah
13:34:27 <MagneticDuck> THERE'S NO SUCH THING AS A KINDCLASS!
13:34:30 <MagneticDuck> oh wait
13:34:35 <Nereid> these have certain properties, for instance, 0 is the identity for addition, and addition is commutative and associative
13:34:39 <Nereid> and can be reversed (by subtraction)
13:34:45 <MagneticDuck> I really have to think before hitting enter. Still a newbie on irc
13:34:46 <jfredett> MagneticDuck: for your invertible functions example -- you can have the type of functions from a -> b, and then the class of them which have inverses which go from b->a
13:35:06 <jfredett> MagneticDuck: there are classes of kinds, but AFAIK they aren't supported (at least in the same way) directly
13:35:16 <MagneticDuck> okay
13:35:34 <Nereid> Qrt: abstract algebra is what you get when you axiomatize these properties and,
13:35:37 <MagneticDuck> so, typeclasses, in a way, can both group things in the world of types and in the world of values
13:35:47 <MagneticDuck> btw I'm typing as fast as I'm thinking
13:35:53 <Nereid> say, study "sets with a binary operation which has an identity  and is associative, commutative, and has inverses"
13:35:57 <Nereid> (also known as abelian groups)
13:35:58 <silver> don't see how they group values
13:36:24 <silver> they do, but they group all values of a given collection of types
13:36:30 <silver> isn't it?
13:36:35 <silver> the case
13:36:47 <jfredett> MagneticDuck: they group values trivially
13:36:48 <Nereid> Qrt: so that's the idea, I guess
13:36:56 <jfredett> because types group values, and classes group types
13:37:06 <MagneticDuck> but wait, I can make a typeclass with all the functions that are invertible, but not a typeclass with all the numbers that have exactly 5 factors?
13:37:10 <jfredett> so classes group collections of values (eg, types)
13:37:24 <MagneticDuck> no
13:37:26 <jfredett> MagneticDuck: that would be a type, MagneticDuck (the latter example)
13:37:35 <Nereid> (so would the former)
13:37:37 <silver> MagneticDuck, I wonder if you can with something like dependent types
13:37:41 <MagneticDuck> there's a difference between types in the world of values and typeclasses in the world of types
13:37:46 <MagneticDuck> a big difference
13:37:57 <Nereid> dependent types is what you need if you want such things
13:38:02 <MagneticDuck> values : types :: types :: kinds
13:38:11 <MagneticDuck> value : ? :: types :: typeclasses
13:38:15 <MagneticDuck> that's my question
13:38:18 <silver> oh damn I skip words ;(
13:38:26 <MagneticDuck> I meant: value : ? :: types : typeclasses
13:38:49 <Philippa> MagneticDuck: ? can't exist, you have nowhere for the analogue of methods to live
13:38:49 <shachaf> MagneticDuck: Typeclasses are just weird.
13:39:02 <MagneticDuck> yeah I always reread a conversation and realize everything I missed
13:39:06 <MagneticDuck> really?
13:39:19 <Nereid> I'm going to think out loud here.
13:39:20 <MagneticDuck> so the world of values and the world of types may never have a perfect mapping?
13:39:29 <MagneticDuck> sure, that's what I did, Nereid
13:39:39 <Nereid> typeclasses give you constraints on types, together with operations on the types which satisfy the constraint.
13:40:10 <MagneticDuck> jfredett: All the numbers that have exactly 5 factors would not be a type, because every element contained in it is of another type.
13:40:11 <Nereid> ok let me use a simple example
13:40:18 <Nereid> class Pointed t where point :: t
13:40:55 <nand`> proofs : values :: values : types -- maybe value-classes would contain polymorphic proofs?
13:40:57 <Nereid> I might then think of Pointed as a function that takes a type and returns (for some types) a value of that type.
13:41:02 <MagneticDuck> I'd just say "constraints on types" and leave it at that imho, because the existence of a function is the same thing as a constraint, right?
13:41:11 <Nereid> no
13:41:15 <nand`> (in a theoretical variant of HAskell extended with proofs)
13:41:44 <Nereid> MagneticDuck: typeclasses are more than collections of types.
13:41:55 <Philippa> MagneticDuck: you don't necessarily want that perfect mapping
13:41:58 <Nereid> they give extra structure to the types in the collection.
13:42:08 <Nereid> structure = properties
13:42:12 <Philippa> but type classes are /evidenced/ constraints on types - the methods are the evidence
13:42:36 <Philippa> (if you want to abstract slightly from dictionary-passing you're likely to end up talking about evidence-passing instead, for example)
13:42:55 <MagneticDuck> btw I wonder if all these patterns would continue working higher up the chain, higher abstracted from values
13:43:01 <MagneticDuck> kindsclasses
13:43:04 <MagneticDuck> sorts
13:43:07 <MagneticDuck> :D
13:43:12 <c_wraith> sortclasses
13:43:12 <Nereid> MagneticDuck: you may be interested in learning about dependent types.
13:43:17 <Nereid> in a system with dependent types, types are values.
13:43:35 <codolio> That's not necessarily correct.
13:43:39 <MagneticDuck> that makes sense. But values still are special, right?
13:43:40 <Nereid> well no.
13:43:43 <MagneticDuck> values are like "1"
13:43:50 <zachk> I just say types are types
13:43:51 <Nereid> but it's kind of correct.
13:43:58 <Nereid> not all values are types, no.
13:44:00 <Nereid> lol
13:45:03 <MagneticDuck> Philippa: Why can't the correspondence of typeclasses exist in the world of values?
13:45:13 <MagneticDuck> that is, work the same on values as they can on types?
13:45:38 <zachk> MagneticDuck: to me types are all about what can and can not be passed to functions
13:45:38 <MagneticDuck> could we at least calculate down that line a little bit to see where it goes if something, a valueclass, did exist?
13:45:40 <Nereid> anyway, back to thinking out loud.
13:45:46 <MagneticDuck> okay sure
13:46:02 <Philippa> MagneticDuck: values are special in that they're the bottom of the sort hierarchy
13:46:09 <Nereid> if typeclasses map types to structure (= properties) on those types,
13:46:22 <zachk> so duck what is the type of (+) and (*) ?
13:46:35 <MagneticDuck> zachk: a -> b
13:46:39 <Nereid> (not in a total way, of course)
13:46:42 <MagneticDuck> where a and b are types
13:46:43 <Philippa> if you don't mind not having an equivalent of evidence then the equivalent is, uh, predicates
13:46:44 <zachk> mp
13:46:44 <Nereid> then maybe "value classes" should map values to properties of those values.
13:46:46 <zachk> no
13:46:54 <Nereid> yes, like predicates.
13:46:56 <MagneticDuck> arr, we're messing wth nereid's line of thought
13:46:57 * hackagebot cypher 0.7 - Haskell bindings for the neo4j "cypher" query language (SamAnklesaria)
13:47:11 <Nereid> predicates would probably correspond to typeclasses with no extra structure.
13:47:17 <Philippa> (everything that makes the constraints in typeclasses more specialised than general predicates is a consequence of needing a 1:1 correspondance between type-tuples/predicate parms and evidence)
13:47:18 <Nereid> i.e. with an empty definition
13:47:30 <zachk> does the typeOf (*) == typeOf (+) duck?
13:47:36 <MagneticDuck> no
13:47:42 <MagneticDuck> erm
13:47:48 <MagneticDuck> well sometimes
13:47:55 <MagneticDuck> there are multiple definitions of * and +
13:47:59 <MagneticDuck> in different typeclasses
13:48:05 <zachk> yea but in general, not specifically
13:48:24 <MagneticDuck> let's say we're working with any (Num a) => a
13:48:31 <zachk> sure
13:48:40 <zachk> but whats the type roughly
13:48:47 <MagneticDuck> well okay, the true type of * is a -> a -> a
13:48:48 <zachk> for either, with that constraint
13:48:50 <MagneticDuck> yes...
13:48:56 <zachk> well (*) but right
13:49:02 <zachk> and what is :type (+) ?
13:49:07 <MagneticDuck> the same
13:49:29 <zachk> so can't you just interchange them like lightbulbs, and still have the other functions around them be valid?
13:49:31 <nand`> (*) :: Num a => a -> a -> a; but typeOf (*) is Integer -> Integer -> Integer
13:49:41 <zachk> I mean your math will be wrong, but the types will still work, won't they?
13:49:52 <nand`> zachk: if by valid you mean “type check”, you're right; unless one or the other is locally shadowed
13:49:54 <Nereid> so, to my mind, a typeclass C is a partial function f_C: Types -> Values, where for each type in the domain of f_C, f_C(t) is a value of some type d_C(t).
13:49:54 <MagneticDuck> yes..
13:50:15 <Nereid> where I'd think of d_C(t) as the dictionary.
13:50:16 <nand`> zachk: but functions with certain escape conditions might still be undefined or error after replacing if the math isn't correct
13:50:24 <zachk> MagneticDuck: and what is the identityOf (*) and the identityOf (+) ?
13:50:41 <MagneticDuck> different
13:50:43 <nand`> what's identityOf ?
13:50:51 <MagneticDuck> mempty
13:50:55 <zachk> ?
13:50:58 <zachk> simple math here
13:50:58 <MagneticDuck> where * is mappend
13:51:06 <zachk> no stick to Num atm
13:51:12 <MagneticDuck> well when we say "identityOf" I just think of a monoid
13:51:17 <MagneticDuck> okay
13:51:17 <zachk> right :D
13:51:32 <zachk> but what are they for * and +
13:51:34 <MagneticDuck> well there's nothing we can do because those two functions just have different proprieties
13:51:35 <nand`> MagneticDuck: Num a => a isn't a monoid; those are explicitly separated via types (Sum and Product)
13:51:41 <nand`> so you can't just interchange those
13:51:51 <MagneticDuck> yeah
13:52:11 <MagneticDuck> to answer your question, 1 and 0 respectively...
13:52:30 <MagneticDuck> btw I have to go soon
13:52:31 <nand`> (more pedantically, identityOf should be defined for all unitals :P)
13:52:40 <MagneticDuck> kind of a pity because I wanted to see where this is going to go
13:52:43 <zachk> MagneticDuck: suppose IdentityOf :: (Num a) => (a->a) -> a ; (identityOf (*), identityOf(+)) --evaluates to what
13:52:58 <nand`> zachk: type error
13:53:03 <Nereid> (a->a->a)->a
13:53:04 <Nereid> obviously
13:53:06 <zachk> thats why I said suppose
13:53:08 <zachk> oh sorry
13:53:14 <zachk> ty nand and Nereid
13:53:18 <MagneticDuck> :D
13:53:25 <zachk> but what is the 2-tuple duck
13:53:29 <MagneticDuck> here we're fast to pounce on the small typeerror
13:53:37 <zachk> definitely
13:53:41 <Nereid> obviously we can't implement this function, but suppose we could.
13:53:46 <MagneticDuck> erm.. well I'd like to see how you define identityOf, but (1, 0)
13:53:52 <zachk> there ya go
13:53:54 <nand`> identityOf would have to be pretty magic for that
13:54:20 <MagneticDuck> okay let's think of something more easy to implement
13:54:30 <MagneticDuck> so everybody's not shouting "MAGIC" and stuff
13:54:33 <zachk> MagneticDuck: do you know about foldr and foldl yet?
13:54:49 <Nereid> a -> a -> a is not a very nice type though.
13:54:50 <MagneticDuck> zachk: ._. You underestimate my haskellish power
13:54:56 <MagneticDuck> yes of course I do
13:54:58 <Nereid> we *could* do something nicer for ADTs, probabyl.
13:55:01 <Nereid> probably.
13:55:14 <MagneticDuck> I'm making an irc bot right now actually
13:55:21 <zachk> rolling your own? ;)
13:55:31 <MagneticDuck> erm, well I use that code yes
13:55:35 <MagneticDuck> but that's a small part
13:55:43 <MagneticDuck> that's just the port to the world of irc
13:55:56 <MagneticDuck> the real code is like 400 lines more
13:56:13 <MagneticDuck> excluding the personality file and bot utilities I'll add on in the future
13:56:28 <nand`> MagneticDuck: a few dozen lines back I forgot what this conversation was about
13:56:38 <MagneticDuck> :D
13:56:40 <MagneticDuck> yea
13:56:45 <MagneticDuck> funny how that works
13:56:57 <zachk> MagneticDuck, the way I look at types and functions, are they are like lego's with sometimes, square, round and triangular etc. pegs and holes on the bottom
13:57:06 <nand`> that might have something to do with the fact that I jumped in well after it started
13:57:20 <Nereid> I'm going to jump out.
13:57:21 <MagneticDuck> arrr, could we hold all this for later?
13:57:27 <zachk> sure
13:57:34 <MagneticDuck> sorry to jump out when things are rolling
13:57:38 <MagneticDuck> but my mom's calling me
13:57:51 <MagneticDuck> yes I'm still young enough to take orders from my mom
13:57:54 <MagneticDuck> well aren't we all?
13:57:56 <MagneticDuck> cya later
13:58:34 <hpaste> me pasted “l = [1,2,3]” at http://hpaste.org/71420
13:58:34 <nand`> MagneticDuck: I think most of us started programming at a very young age, it's nothing to be ashamed about :P
13:58:42 * MagneticDuck is away: Getting isopropylene.
13:58:56 <watermind> hi
13:59:03 <zachk> hello watermind
13:59:08 <watermind> hey zachk
13:59:40 <watermind> I was curious about how lists were represented in core, so I compiled to core a simple program with just l=[1,2,3]
13:59:54 <watermind> http://hpaste.org/71420
14:00:10 <watermind> I can kind of make sense out of it, first we got 3 variables with the integers 1,2 and 3
14:00:50 <watermind> and then the list is created using three other auxiliar variables
14:00:58 <watermind> one to wrap 3
14:01:10 <watermind> another that takes this wrapping and adds 2
14:01:18 <watermind> and likewise for the others
14:01:41 <watermind> the lists type seems to be ZMZN
14:01:58 <watermind> or more specifically GHCziTypes.ZMZN
14:02:03 <watermind> what does that stand for?
14:02:12 <watermind> why ZMZN?
14:02:18 <shachaf> preflex: zdec GHCziTypes.ZMZN
14:02:19 <preflex>  GHC.Types.[]
14:02:32 <nand`> watermind: some form of encoding probably
14:02:36 <nand`> since [] are special chars
14:02:46 <shachaf> Yes, it's called Z-encoding.
14:02:51 <shachaf> preflex: Can do it. :-)
14:02:54 <shachaf> s/://
14:02:57 <shachaf> s/C/c/
14:03:06 <zachk> watermind:  do you know how to construct a list from (:) and [] ?
14:03:35 <watermind> well yeah
14:03:38 <watermind> I guess
14:03:45 <watermind> [] : []
14:03:47 <nand`> preflex: zdec integerzmgmp
14:03:47 <preflex>  integer-gmp
14:03:47 <zachk> feed it to lambdabot
14:03:56 <geekosaur> c++ does similar encoding, but that's not suitable for haskell types so ghc uses its own encoding
14:03:57 <zachk> > 2 + 2
14:03:59 <lambdabot>   4
14:04:09 <zachk> > [] : []
14:04:11 <lambdabot>   [[]]
14:04:22 <zachk> > 1:2:3:[]
14:04:23 <watermind> that's a list using only (:) and []
14:04:24 <lambdabot>   [1,2,3]
14:04:40 <Nereid> > 1 : (2 : (3 : [])) -- unnecessary parentheses
14:04:40 <watermind> and that's what you meant, yes of course
14:04:41 <lambdabot>   [1,2,3]
14:04:55 <Nereid> so a3rlU would be 3 : []
14:05:06 <watermind> yes I understand
14:05:34 <watermind> but I was wondering what the ZMZN meant
14:05:36 <zachk> (05:00:29 PM) watermind: and then the list is created using three other auxiliar variables
14:05:37 <zachk> (05:00:36 PM) watermind: one to wrap 3
14:05:37 <zachk> (05:00:49 PM) watermind: another that takes this wrapping and adds 2
14:05:37 <zachk> (05:00:56 PM) watermind: and likewise for the others
14:05:37 <nand`> ‘rl’ doesn't take on any special value in Z-encoding (I'm guessing by the name it only affects z and Z) does it?
14:05:40 <watermind> never heard of Z enconding
14:05:42 <nand`> like, say, ‘:’
14:05:48 <Nereid> watermind: that's probably an encoded []
14:05:52 <Nereid> ZC = :, ZM = [, ZN = ] ?
14:06:08 <shachaf> geekosaur: C++ doesn't do any sort of encoding. :-)
14:06:10 <nand`> and by ‘probably’ you mean ‘actually’, as shachaf demonstrated
14:06:11 * zachk can't wait till #haskell goes "over 9000" 
14:06:15 <gensymv> hello, i am kind of new to haskell, and i would very much like to learn the exact difference between Int and Integer. As far as I understand, Int uses the machine integers and Integer are potentially arbitrary long integers. My question is now, which of them is better practice to use?
14:06:24 <shachaf> Individual C++ compilers do, but that's a different matter.
14:06:25 <nand`> preflex: zdec ZC ZM ZN
14:06:25 <preflex>  : [ ]
14:06:26 <hpc> @src Int
14:06:26 <lambdabot> data Int = I# Int#
14:06:31 <nand`> Nereid:  ^^^
14:06:38 <saml> irc is web scale? can it have more than 50k users per channel?
14:06:46 <zachk> Integer is unbounded and is better for number theory and primes, Int is way, way faster and tighter on memory
14:06:46 <shachaf> gensymv: Using Integers as a default is good because it's one fewer thing to worry about.
14:06:50 <hpc> gensymv: Int is a box around Int#, which is just a word of memory
14:06:52 <geekosaur> actually they switched course on that several years ago, decided it was necessary for interoperability
14:06:52 <hpc> @src Integer
14:06:53 <lambdabot> data Integer = S# Int#
14:06:53 <lambdabot>              | J# Int# ByteArray#
14:06:53 <shachaf> gensymv: A lot of library functions use Int.
14:06:58 <nand`> gensymv: Integer uses Int when it fits
14:07:07 <nand`> gensymv: and only switches to arb precision when necessary
14:07:07 <hpc> Integer is either an Int#, or an array
14:07:09 <Nereid> preflex: zdec ZAZBZCZDZEZFZGZHZIZJZKZLZMZNZOZPZQZRZSZTZUZVZWZXZYZZ
14:07:10 <preflex>  AB:DEFGHIJK([]OPQ)STUVWXYZ
14:07:17 <hpc> and the array is actually raw memory for the gmp library
14:07:37 <gensymv> thanks guys.
14:07:38 <Nereid> preflex: zdec zazbzczdzezfzgzhzizjzkzlzmznzozpzqzrzsztzuzvzwzxzyzz
14:07:39 <preflex>  &|^$=f>#.jk<-!o+'\/*_%wxyz
14:07:39 <hpc> gensymv: this is GHC-specific; haskell itself doesn't specify an implementation of Integer
14:07:42 <watermind> ok ok I'm trying to read everything and getting a bit lost
14:08:05 <geekosaur> mind, I think they cheated and made the exact details part of the platform ABI instead of the C++ standard, but it's still officially spec-ed
14:08:05 <watermind> what is this preflex doing?
14:08:15 <shachaf> @google what is z-encoding in ghc?
14:08:17 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames
14:08:17 <lambdabot> Title: Commentary/Compiler/SymbolNames – GHC
14:08:24 <watermind> thanks! :)
14:08:25 <nand`> gensymv: in practice, you want Integer for things that should be arbitrary; but stuff like list indexing uses Int since you don't ever want to index lists that huge either way
14:08:39 <watermind> preflex: zdec ZM ZN
14:08:39 <preflex>  [ ]
14:08:41 <nand`> (well, unless that's exactly what you want)
14:08:46 <gensymv> that makes sense
14:08:50 <watermind> preflex: zdec ZN
14:08:50 <preflex>  ]
14:08:53 <watermind> ah!
14:09:34 <zachk> gensymv: Data.Time.Calendar fromGregorian :: Integer -> Int -> Int -> Day , which argument to fromGregorian is the year? which ones are the days of the month, and the month? why is it so?
14:09:34 <saml> preflex: zenc hello:world<bro>#include
14:09:34 <preflex>  helloZCworldzlbrozgzhinclude
14:09:36 <Cale> The annoying thing is that if you're not careful, one of those Int operations can cause numbers which *do* need to be large to be Ints as well, and destroy the correctness of your program.
14:09:37 <nand`> looks like z-encoding refers to a pretty specific set of special symbols
14:09:59 <nand`> preflex: zenc ⊆⊇∩∈
14:09:59 <preflex>  z2286Uz2287Uz2229Uz2208U
14:10:03 <gensymv> The question I was building up for, was how to make take play well with Integer without using the genericTake, but the question kinda solved itself now
14:10:07 <nand`> aha
14:10:17 <nand`> so it can handle arbitrary unicode
14:10:43 <Nereid> preflex: zdec z2603U
14:10:43 <preflex>  ☃
14:10:47 <Cale> convert from proleptic Gregorian calendar. First argument is year, second month number (1-12), third day (1-31). Invalid values will be clipped to the correct range, month first, then day.
14:11:04 <nand`> gensymv: genericTake when you want to support >2^31 sized lists. fromIntegral otherwise
14:11:11 <nand`> (or fromInteger, even)
14:11:48 <nand`> but note that if your function doesn't handle arbitrary sizes, it shouldn't have Integer in its type in the first place
14:11:50 <zachk> proleptic?
14:12:08 <watermind> OK but in a3rlU :: (ghczmprim:wGHCziTypes.ZMZN integerzmgmp:GHCziIntegerziType.Integer)
14:12:20 <watermind> ZMZN is a type
14:12:21 <nand`> Cale: convert .. to?
14:12:25 <watermind> so that means the type is []
14:12:35 <gensymv> nand: thanks.
14:12:41 <watermind> shouldn't it be a list of integers?
14:12:42 <Cale> proleptic: Of a calendar, extrapolated to dates prior to its first adoption; of those used to adjust to or from the Julian calendar or Gregorian calendar.
14:12:57 <zachk> Cale: sorry that question was for gensymv :-/ to give and example of when to use Int and Integer
14:12:59 <geekosaur> watermind, [] is a type which takes a parameter
14:13:01 <nand`> watermind: [] is a type constructor
14:13:03 <gensymv> ^^
14:13:05 <Nereid> watermind: the type is [] Integer
14:13:32 <geekosaur> watermind, the parameter is what followws:  integer-gmp:GhC.Integer.Type.Integer
14:13:35 <nand`> watermind: look closely, it says [] Integer
14:13:41 <nand`> :t [] :: [] Integer
14:13:42 <lambdabot> [Integer]
14:13:47 <watermind> oh I see
14:13:53 <nand`> bah, I was slowest :(
14:13:55 <nand`> on all accounts
14:14:06 <nand`> too tired to answer questions I suppose
14:14:16 <zachk> hey cads
14:14:16 <watermind> I thought that integer  was in reference to the 3
14:14:58 <nand`> watermind: in this context they're pretty much the same, due to the type of (:)
14:15:01 <nand`> :t (:)
14:15:02 <lambdabot> forall a. a -> [a] -> [a]
14:15:04 <geekosaur> nope.  lists are syntactically odd both as values and as types; it's normalized to the [] Integer form, just like Maybe Integer or etc.
14:15:16 <nand`> the ‘a’ is Integer everywhere
14:15:48 <nand`> better than ZMIntegerZN :P
14:16:57 <Nereid> that would be gross
14:21:05 <watermind> is this the empty list? a3rlU :: (ghczmprim:wGHCziTypes.ZMZN integerzmgmp:GHCziIntegerziType.Integer)
14:21:24 <chrisdone>  > fromEnum '['
14:21:30 <chrisdone>  > fromEnum ']'
14:21:32 <new_to_haskell> hello coders
14:21:36 <Saizan> preflex: zdec ZMZN
14:21:36 <preflex>  []
14:21:41 <chrisdone> yep
14:21:51 <Saizan> has the right type at least
14:22:32 <watermind> wait sorry wrong paste
14:22:49 <Nereid> watermind: that's the type of a3rlU
14:22:56 <watermind> yes emacs linux, copy paste
14:22:58 <watermind> argh
14:23:06 <Nereid> empty list is (ghczmprim:GHCziTypes.ZMZN @ integerzmgmp:GHCziIntegerziType.Integer)
14:23:15 <watermind> yes that's what I wanted to paste
14:23:50 <Nereid> I know nothing about core but I think this is saying that that is a function [] applied to Integer
14:23:53 <Nereid> (remember [] is polymorphic)
14:24:01 <Nereid> to return the monomorphic value [] :: [Integer]
14:24:20 <monochrom> yes
14:24:31 <watermind> yes but that ZMZN seems to be a type not a value... because it says GHCziTypes
14:24:41 <watermind> that's what I find confusing
14:24:43 <hpc> at the type level, [] is a type function
14:24:47 <hpc> of kind * -> *
14:24:53 <watermind> right
14:25:04 <Nereid> oh ok.
14:25:10 <Nereid> @ is what specializes polymorphic types, I guess.
14:25:11 <monochrom> GHCziTypes is probably just a module name
14:25:18 <watermind> ah
14:25:32 <Nereid> so
14:25:35 <Nereid> ghczmprim:GHCziTypes.ZC @ integerzmgmp:GHCziIntegerziType.Integer
14:25:42 <Nereid> that would also be (:) specialized to Integer
14:26:20 <watermind> monochrom: but GHCziTypes.ZMZN does show up many times to specify the type constructore []
14:26:24 <watermind> constructor *
14:26:39 <monochrom> type constructors and value constructors can have the same name
14:26:58 * hackagebot constraints 0.3.1 - Constraint manipulation (EdwardKmett)
14:27:16 <watermind> nevermind
14:27:21 <watermind> there's an extra w
14:27:33 <hpc> hackagebot: thanks for the link...
14:27:39 <monochrom> the @ operators is always value@type
14:27:40 <Nereid> there's no w anywhere
14:28:18 <Nereid> I assume we should all be reading or have read http://www.haskell.org/ghc/docs/7.2.2/core.pdf
14:29:27 <watermind> you're right no w, I accidently typed it
14:30:07 <watermind> I see so it's also just overloaded in core
14:30:37 <watermind> are there formal semantics for core?
14:31:15 <monochrom> http://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo or something :)
14:31:20 <watermind> I remember SPJ saying once that no formal semantics for haskell made it easier to add new features, on the other hand everything gets translated to core so that should suffice
14:43:28 <herpladee> hey guys i'm trying to install happstack and happstack-fastcgi
14:43:44 <srhb> herpladee: Ok?
14:43:47 <herpladee> but when i do cabal install happstack-fastcgi i get "could not find happstack.server.http.types"
14:43:58 <Taneb> While I was watching Kung Fu Hustle, I thought of what would be a good way to do a GUI library in Haskell
14:44:03 <herpladee> what do i do??
14:44:05 <Taneb> (I know nothing about GUI, btw)
14:44:07 <stepcut> herpladee: happstack-fastcgi is pretty obsolute
14:44:11 <stepcut> obsolete
14:44:12 <herpladee> but
14:44:17 <herpladee> okay
14:44:19 <herpladee> what do i do then?
14:44:30 <herpladee> i want to use happstack on my apache serevr
14:44:43 <herpladee> and i found an article that described how to use happstack on apache through fastcgi
14:44:48 <stepcut> herpladee: the most common solution is reverse proxy
14:44:58 <herpladee> you gotta help me a little there
14:45:01 <silver> monochrom, that's crazy
14:45:04 <herpladee> what's that?
14:45:07 <silver> (buffalo thing)
14:46:07 <stepcut> herpladee: basically, you run your happstack app on a port like, port 8080, and then you tell apache to forward requests from port 80 to port 8080
14:46:53 <Taneb> Like, each window, button, etc, is a description of its appearance plus a bunch of monadic functions that has access to a bunch of things (OS, mouse location) read only, others (size, position, visibility) in a state monad, and access to IO and triggering similar functions elsewhere
14:47:04 <herpladee> but i use apache for a ton of other things on :80
14:47:05 <Taneb> I'm not sure if it'd work in practice
14:47:40 <Nereid> herpladee: so you tell apache to take requests that match a certain pattern
14:47:43 <Nereid> and forward them to happstack
14:48:13 <hpaste> stepcut pasted “apache proxy example” at http://hpaste.org/71424
14:49:02 <stepcut> on the happstack side, you don't have to do anything special.. expect binding to the right port (for example 9028 in that example)
14:49:25 <herpladee> alright
14:49:27 <herpladee> i'll try this then
14:49:28 <herpladee> thanks guys
14:49:42 <wingy> what is the status of https://github.com/ghcjs
14:50:37 <hamishmack> wingy: We could use help :-)
14:51:01 <geekosaur> http://www.haskell.org/haskellwiki/The_JavaScript_Problem might be enlightening
14:51:53 <wingy> hamishmack: is the project as serious as coffeescript and clojurescript?
14:52:03 <wingy> would be nice to have haskell on js as well
14:52:16 <hiptobecubic> Why isn't this in the state monad? Or is it? Or is that just superficial anyway? http://hackage.haskell.org/packages/archive/mersenne-random-pure64/latest/doc/html/System-Random-Mersenne-Pure64.html
14:52:17 <hamishmack> it is kind of different from them
14:52:24 <hiptobecubic> It looks statey
14:52:54 <wingy> hamishmack: in which sense?
14:53:14 <hamishmack> It is a backend for ghc
14:53:23 <hamishmack> so it compiles any haskell code
14:53:49 <hamishmack> but some primatives and most FFI calls will be unresolved in javascript land
14:54:37 <Nereid> hiptobecubic: it looks as statey as any other RandomGen
14:54:43 <wingy> oh i thought it was compiled to js
14:55:02 <hamishmack> Yes it compiles to JS
14:55:18 <wingy> im new to haskell, is there any preferred database and IDE working great with haskell?
14:55:23 <Nereid> hiptobecubic: and there's the MonadRandom package
14:55:25 <hiptobecubic> Nereid, but why is it not explicitly in the state monad? I haven't used the state monad so I don't know what I'm really talking about here.
14:55:48 <Nereid> if you want a monad out of it (or any other RandomGen), use something like MonadRandom
14:56:12 <tdammers> wingy: databases - most db related packages support at least postgresql and sqlite
14:56:52 <hamishmack> wingy: http://leksah.org/ and http://eclipsefp.github.com/
14:56:59 <tdammers> I may be wrong, but I don't think mysql gets much love in the haskell world
14:57:19 <wingy> wow leksah seems cool
14:57:43 <Nereid> hiptobecubic: RandomGen is a bit more general than State.
14:57:54 <wingy> tdammers: yeah .. is it any favored nosql db in haskell world?
14:57:57 <Nereid> uh
14:58:07 <wingy> eg. in node.js land a lot of people are using couchdb/mongodb
14:58:11 <Nereid> actually.
14:58:12 <Nereid> no.
14:58:18 <Nereid> well, I dunno.
14:58:31 <wingy> in clojure some like datomic which is written in clojure
14:58:47 <hiptobecubic> Nereid, Im not saying I want a monad out of it. I'm just asking why it is designed this way if it's not going to be stuck into State
14:58:51 <MostAwesomeDude> I think that most Haskell programmers are more concerned with getting things done.
14:59:01 <tdammers> wingy: don't know, haven't done any serious nosql work yet
14:59:06 <wingy> MostAwesomeDude: that was for me?
14:59:10 <Nereid> hiptobecubic: but it can be.
14:59:35 <MostAwesomeDude> wingy: Not necessarily.
14:59:37 <hiptobecubic> Ok. So it's just written like that to be generic
14:59:45 <Peaker> I spent about a day writing a little pure-Haskell key/value store.. it's a toy though I think with a week or two of work I could  make it a non-toy
15:00:04 <MostAwesomeDude> wingy: When you say "preferred database," I feel like that is massively missing the point of why one would use a database.
15:00:04 <Peaker> so there's a pure Haskell db, sort of :)
15:00:19 <Nereid> hiptobecubic: and so that it's easy to make it a RandomGen.
15:00:40 <Nereid> although you can't split a PureMT. this is sad.
15:01:20 <wingy> MostAwesomeDude: not necessarily .. like i said datomic is a db working extremely great with clojure .. wouldn't and don't have to use another db when im on clj
15:01:47 <wingy> so asking a such question doesn't have to mean there is some point missing
15:02:06 <MostAwesomeDude> wingy: Suppose I wanted a database of facts, Prolog-style; could I use Datomic for that?
15:02:14 <hiptobecubic> Nereid, is that what it means when it says, "This generator may be used with System.Random, however, that is likely to be slower than using it directly." ?  Making it a RandomGen?
15:02:17 <wingy> in fact you can
15:02:23 <wingy> its based on datalog .. everything is a fact :)
15:02:35 <MostAwesomeDude> wingy: Or suppose my boss tells me I have to use Pg or Oracle. Can Datomic be a frontend to those?
15:02:45 <aristid> wingy: i read it's limited to triple facts?
15:02:46 <Nereid> hiptobecubic: I don't know what it means by that.
15:02:50 <hiptobecubic> Nereid, ok
15:02:53 <MostAwesomeDude> Datalog? Okay. Can I form non-terminating (full Prolog) queries?
15:03:07 <wingy> yes you can .. datomic IS a frontend to storage services
15:03:21 <wingy> aristid: quadro
15:03:34 <wingy> time is the forth element
15:03:40 <MostAwesomeDude> Okay, so this is the preferred database *wrapper* for Clojure then. :3
15:03:41 <aristid> wingy: ok, but time is fixed
15:03:46 <aristid> wingy: you can't reuse that one
15:03:51 <companion_cube> pure datalog is terminating
15:03:57 <aristid> wingy: is non-linear time possible?
15:03:59 <hiptobecubic> Nereid, yeah i think it is.  RandomGen is apparently defined in the System.Random package
15:04:09 <Nereid> I guess.
15:04:11 <companion_cube> (even in the presence of negation, if interpreted properly)
15:04:22 <aristid> MostAwesomeDude: i think you can't query an _arbitrary_ PG database with datomic
15:04:27 <Nereid> hiptobecubic: mwc-random claims to be better, though.
15:04:27 <wingy> calm down .. it's in early experience phase :)
15:04:27 <Luke> I'm trying to connect to mssql from HDBC - it works from the GHCI interpreter but not when I cabal install it. It returns a SQL connection error from the underlying ODBC library. Anyone know if there's some special cabal linking i need to do?
15:05:14 <hiptobecubic> Nereid, i'm using that now. But I have some code that the profiler says spends most of its time generating random numbers so I'm shopping for a faster one.
15:05:28 <wingy> aristid: and yes .. you can jump through time however you want
15:05:36 <wingy> and even combine data from different times
15:05:39 <MostAwesomeDude> aristid: Oh.
15:05:46 <wingy> but this wasn't about datomic .. it was just an example
15:06:18 <wingy> MostAwesomeDude: no its not a wrapper :)
15:06:27 <wingy> its a db
15:06:49 <MostAwesomeDude> wingy: Well, either it wraps Oracle or it doesn't. >:3
15:06:52 <MostAwesomeDude> Anyway.
15:07:09 <MostAwesomeDude> Your inquiry about whether there's one DB to rule them all? In Haskell, AFAIK, there isn't.
15:07:13 <herpladee> hey how do i tell ghc where to look for happstack.server when i compile?
15:07:20 <wingy> MostAwesomeDude: well if you wanna know the details you could just ask
15:07:21 <herpladee> it can't find it for some reason
15:07:26 <aristid> wingy: what i mean with non-linear time... consider a git version graph. what if i wanted nodes in such a version DAG as time?
15:07:34 <herpladee> it's like -lHappstack or something?
15:07:36 <wingy> MostAwesomeDude: and no .. i didnt wanna find a one to rule them all db .. please reread my question
15:07:57 <stepcut> herpladee: usually. ghc --make, though long-term it is best to create .cabal file for your project
15:08:13 <herpladee> what about short term?
15:08:20 <herpladee> ghc --make doesn't work
15:08:22 <daniel_-> i find it hard naming things, but coming up with operators which might make a bit sense like regex =~ is god damn impossible
15:08:28 <wingy> perhaps people could stop overreacting and acting like children
15:09:10 <herpladee> like i just want to run happstack so i can see if my apache reverse proxy is working
15:09:44 <daniel_-> is there a list of usable symbols to create operators from?
15:10:30 <aristid> herpladee: .cabal file is fine for the short-term, too
15:10:41 <herpladee> but i don't even know what that is
15:10:51 <herpladee> you got a guide on it?
15:10:59 <aristid> herpladee: cabal init creates one for you
15:11:12 <Nereid> daniel_-: it's in the Report
15:11:35 <Nereid> daniel_-: 2.4 http://www.haskell.org/onlinereport/lexemes.html
15:12:07 <daniel_-> thanks
15:12:12 <herpladee> okay made one but it still doesn't work
15:12:42 <herpladee> do i ghc the setup.hs?
15:12:54 <herpladee> i just get a bunch of linker errors
15:13:53 <Nereid> you runhaskell it
15:14:40 <Nereid> although
15:15:12 <herpladee> runhaskell gives me "no command given"
15:15:12 <Nereid> eurgh
15:15:47 <objectivity> >1
15:15:48 <herpladee> although eurgh indeed
15:15:50 <objectivity> > 1
15:15:52 <lambdabot>   1
15:16:09 <herpladee> configure gives me No Main-Is field found for executable
15:18:57 <stepcut> herpladee: does, runhaskell Main.hs, work ? assuming your happstack apps main function is in Main.hs..
15:19:30 <herpladee> no it's in test.hs
15:19:36 <herpladee> and that didn't work because it can't find happstack.server
15:19:39 <herpladee> which was the original problem
15:19:47 <herpladee> that prompted me to do cabal init and make a .cabal file
15:19:48 <stepcut> herpladee: well.. for one, it is Happstack.Server
15:20:02 <stepcut> case matters
15:20:08 <herpladee> right
15:20:09 <herpladee> that's what it says
15:20:15 <herpladee> i'm just a bit lazy with my typing
15:20:38 <stepcut> well, if runhaskell Main.hs doesn't work.. then I think your installing of happstack-server is wrong
15:20:39 <herpladee> i copy pasted all of my code from the happstack website
15:20:44 <herpladee> alright
15:20:50 <stepcut> how did you install happstack-server?
15:20:56 <herpladee> i did cabal install happstack
15:20:59 <herpladee> and then i think it was installed
15:21:40 <stepcut> what does, ghc-pkg list happstack-server, report?
15:22:15 <herpladee> looks like it found it
15:23:12 <stepcut> herpladee: if you run, ghci
15:23:23 <stepcut> and then do, :set -v
15:23:31 <stepcut> does it report any errors about happstack-server?
15:23:32 <daniel_-> how would i convert a int to NominalDiffTime?
15:23:59 <herpladee> yes
15:24:10 <herpladee> it says that happstack-server is unsuable due to recursive independencies
15:24:17 <herpladee> missing or recursive
15:24:25 <stepcut> then, that is your problem
15:24:34 <herpladee> that sounds very plausible
15:24:36 <stepcut> your installation is screwed up because cabal is like that
15:24:45 <herpladee> can i just reinstall?
15:25:03 <stepcut> herpladee: depends what you mean by reinstal
15:25:11 <herpladee> cabal reinstall happstack
15:25:14 <herpladee> or something similar
15:25:31 <stepcut> herpladee: probably won't help. You need to go in and remove all the broken stuff down to the core, and then reinstall
15:25:40 <herpladee> ... manually?
15:25:44 <stepcut> yes
15:25:47 <herpladee> is there a guide on how to do that?
15:26:01 <stepcut> there is probably some chain of broken packages and you have to ghc-pkg unregister stuff until you have no more broken packages left
15:26:20 <stepcut> or, some people just remove ~/.ghci and ~/.cabal I think to start 'fresh'
15:26:31 <herpladee> i don't mind that
15:26:35 <stepcut> usually things get broken like things when you are installing some libraries via cabal and others via a package manager like apt-get
15:26:44 <stepcut> not sure if that is what happened here or not
15:26:49 <herpladee> it coudl be
15:26:57 <herpladee> i installed some stuff via apt-get
15:27:08 <stepcut> there are tools like cabal-dev that also attempt to solve this problem, but I don't know how to use them
15:27:18 <herpladee> so i simply just delete ~/.ghci and ~/.cabal?
15:27:27 <stepcut> you are best off installing only the basic ghc6 package via apt-get and everything else via cabal
15:27:46 <stepcut> yeah, just delete those.. or rename them if you want to be a bit safer
15:27:53 <Nereid> daniel_-: NominalDiffTime is an instance of NUm
15:27:55 <herpladee> so should i simply uninstall everything haskell related and then start over?
15:28:01 <Nereid> daniel_-: so you can probably use fromIntegral
15:28:04 <herpladee> well i dont' have any big haskell projects so i don't really mind
15:28:21 <herpladee> unless it's going to do some semipermanent damage
15:28:24 <geekosaur> http://www.vex.net/~trebla/haskell/sicp.xhtml detailed instructions for recovery, but the simple version really is to nuke ~/.ghc (~/.cabal is ok to leave)
15:28:32 <Nereid> (what it means to multiply two NominalDiffTimes is a mystery...)
15:28:44 <MostAwesomeDude> herpladee: The easiest thing to do is nuke .ghc and .cabal and then $ cabal update; cabal install --only-dependencies
15:28:48 <stepcut> herpladee: yeah.. you might do, apt-get remove ghc6, and remove ~/.cabal and ~/.ghci, and then, apt-get install ghc6
15:28:57 <MostAwesomeDude> stepcut: Uh.
15:29:00 <stepcut> but not any other libghc-*-prof packages
15:29:10 <stepcut> MostAwesomeDude: what?
15:29:18 <daniel_-> thanks Nereid
15:29:25 <daniel_-> didnt know you could do that :)
15:29:51 <MostAwesomeDude> stepcut: Why would you remove ghc6 in that process?
15:30:00 <herpladee> i'll just start with the smaller one
15:30:07 <herpladee> delete .ghc and .cabal
15:30:14 <stepcut> MostAwesomeDude: to force all the other libghc packages installed by apt-get to be removed
15:30:19 <MostAwesomeDude> stepcut:
15:30:20 <MostAwesomeDude> Er.
15:30:23 <MostAwesomeDude> stepcut: Why?
15:30:40 <MostAwesomeDude> Is there some Debian bug?
15:30:43 <stepcut> MostAwesomeDude: when cabal builds against those packages, and then apt-get update upgrades them, it fucks over your ~/.cabal & ~/.ghci directories.
15:30:44 <geekosaur> MostAwesomeDude, because mixing distribution packages with cabal packages is an easy way to cause this kind of mess
15:30:59 <geekosaur> it's not a debian bug, it's the inevitable result of mixing package systems
15:31:02 <MostAwesomeDude> stepcut, geekosaur : Huh, never seen this. Guess it's a Debian thing.
15:31:02 <stepcut> MostAwesomeDude: you can *either* install cabal packages via apt
15:31:11 <stepcut> MostAwesomeDude: you can *either* install cabal packages via apt-get *or* via cabal, but not both
15:31:23 <geekosaur> no, we recommend not using vendor packages on *any* system
15:31:26 <MostAwesomeDude> stepcut: Well, fortunately I can install from both cabal and yum, so. :3
15:31:41 <stepcut> MostAwesomeDude: nope
15:31:55 <herpladee> okay i'm just going to do the big one then and remove ghc6
15:32:02 <geekosaur> fedora might get away with it if it stays recent enough, but as soon as cabal wants to install a newer version fo something you installed via yum you are asking for trouble
15:32:04 <stepcut> MostAwesomeDude: if you cabal install a package that builds against a yum installed library and you upgrade that yum installed library, the cabal installed one will break
15:32:14 <geekosaur> (less trouble with the new modular solver, but still potential trouble)
15:32:17 <stepcut> MostAwesomeDude: because it will depend on a version of the library that is no longer installed
15:32:17 <rguillebert> hi
15:32:26 <MostAwesomeDude> stepcut: I just don't see this, sorry.
15:32:26 <geekosaur> and that too, the other way around
15:32:36 <stepcut> MostAwesomeDude: you will eventually
15:32:43 <geekosaur> MostAwesomeDude, then you need to red the page I poinbted to a few minutes ago
15:32:43 <MostAwesomeDude> stepcut: IYSS.
15:32:46 <geekosaur> it;s a real problem
15:33:02 <geekosaur> evne if you happen to have been lucky enough to not run into it yet
15:33:27 <rguillebert> how can I express : "Call this function with each line of the file until there's no line anymore"
15:33:38 <MostAwesomeDude> geekosaur: IYSS.
15:33:47 <c_wraith> rguillebert: what's the type of the function?
15:33:53 <Nereid> I wonder if anyone has toyed with the idea of a linux distribution with a modular package system? so, say, there would be a haskell module that gets its package list from cabal and stuff
15:34:08 <rguillebert> c_wraith, it should take a String
15:34:16 <Nereid> then we wouldn't be having these problems
15:34:17 <c_wraith> rguillebert: that's not the important part.
15:34:35 <rguillebert> String -> String
15:34:51 * geekosaur shrugs; "can't happen to me" tends to be self-fixing around here
15:34:52 <c_wraith> what do you want to do with the result strings?
15:35:00 <rguillebert> print it
15:35:17 <Nereid> and, tangentially, has anyone written a package management system in haskell :)
15:35:37 <c_wraith> :t \f -> interact $ unlines . f . lines
15:35:38 <lambdabot> ([String] -> [String]) -> IO ()
15:35:45 <c_wraith> err
15:35:49 <c_wraith> :t \f -> interact $ unlines . map f . lines
15:35:50 <lambdabot> (String -> String) -> IO ()
15:35:57 <herpladee> out of curiousity, why does haskell need to have its own package management system?
15:36:12 <Nereid> it doesn't
15:36:26 <geekosaur> Nereid, http://nixos.org/nix/
15:36:50 <Nereid> also
15:36:51 <geekosaur> herpladee, because haksell packages change more often than distribution packages do.  same reason perl has cpan, php has pear, etc.
15:36:51 <Nereid> what's this http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
15:37:05 <geekosaur> Nereid, read it
15:37:12 <Nereid> ^ this post argues for using the distributions package manager.
15:37:14 <Nereid> I have.
15:37:24 <c_wraith> rguillebert: main = interact $ unlines . map myFunction . lines
15:37:38 <c_wraith> rguillebert: that's very primitive, but it'll do for the use you've described
15:37:39 <geekosaur> yeh.  used ot prefer that but things started evolving too rapidly
15:37:49 <c_wraith> rguillebert: from standard in, not an arbitrary file
15:38:07 <geekosaur> partly yesod's fault, partly release of ghc 7.4.1 with the Num constraints removed that broke a lot of stuff
15:38:21 <rguillebert> c_wraith, I'm trying to understand it :)
15:38:59 <rguillebert> arg ok, all the magic is in interact
15:39:09 <geekosaur> (and I will partly blame Arch for causing its own issues in the wake of that, giving vendor packages a rather bad name for a while.  cabal at least *tries* to stay compatible with what you havem instead of yanking the rug out form under you...)
15:39:22 <geekosaur> interact isn't really magic
15:39:25 <geekosaur> @src interact
15:39:26 <lambdabot> interact f = do s <- getContents; putStr (f s)
15:39:35 <shachaf> geekosaur: Except for the unsafeInterleaveIO bit...
15:39:46 <geekosaur> to the extent thatthere is magic it's getContents, not interact (cf ^^)
15:40:01 <MostAwesomeDude> @src getContents
15:40:01 <lambdabot> getContents = hGetContents stdin
15:40:10 <MostAwesomeDude> @src hGetContents
15:40:10 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:41:44 <MagneticDuck> ah lambdabot
15:43:41 <geekosaur> hGetContents depends on ghc internals.  but it's essentially unsafeInterleaveIO to give you an apparent String that lazily does reads as needed to fill itself.  which is evil in several ways (the simplest being that you can't detect read errors)
15:45:07 <herpladee> woohoo it's working!
15:45:12 <herpladee> thanks for your help!
15:53:24 <Guest38727> with data kinds, is there any good reason against, when using a * -> (-> *)... -> * type constructor, to not instead use '(*, ..., *) -> *?
15:53:43 <Guest38727> guess its the same with currying in general
15:54:02 <Guest38727> perhaps the convenience of only having to specify a single parameter, instead of many, when you don't care about any?
15:54:38 <slack1256> @type forever
15:54:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:55:23 <slack1256> I don't get why the output of 'forever' is 'm b' instead of 'm a'
15:55:29 <slack1256> isn't it defined as
15:55:35 <MostAwesomeDude> @src forever
15:55:35 <lambdabot> Source not found.
15:55:38 <MostAwesomeDude> Pfft.
15:55:41 <slack1256> forever a = a >> forever a
15:55:54 <Guest38727> same as inference for whatever = whatever
15:55:59 <Nereid> slack1256: yes
15:56:05 <Nereid> @type (>>)
15:56:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
15:56:26 <shachaf> slack1256: It can be anything at all.
15:56:28 <MostAwesomeDude> The return type of "forever a" on both sides never specializes beyond "m b".
15:56:31 <shachaf> Since it'll never actually return.
15:56:58 <slack1256> shachaf: oh, that actually make sense.
15:57:35 <Guest38727> this applies to mutual recursion (well, mutually dependent - or strongly connected) groups as well
15:57:45 <Guest38727> i.d. f = g; g = f
15:57:49 <Guest38727> *i.e.
15:57:52 <Guest38727> or e.g.?
15:57:57 <shachaf> e.g.
15:58:22 <shachaf> Except this is a lot more interesting with "m b" than with "b".
15:58:27 <shachaf> Because of the m. :-)
15:58:56 <Nereid> it can be interesting without the m!
15:59:21 <shachaf> Nereid: A value :: b can be interesting?
15:59:33 <Nereid> no, the recursion
15:59:43 <shachaf> I'm talking about forever.
16:01:04 <Nereid> well ok, I guess you can't really do anything interesting with a polymorphic a -> b -> b instead of (>>)
16:01:26 <Guest38727> that is >>
16:01:31 <Guest38727> @info (->)
16:01:32 <lambdabot>  Parse error at "->)" (column 2)
16:01:34 <Guest38727> bah
16:01:39 <Nereid> no, >> is m a -> m b -> m b
16:01:40 <nobdraisentone> Is there some analog of `mkdir -p'? createDirectory looks like `mkdir'
16:01:45 <Guest38727> bleh, i'm wrong there anyways
16:02:06 <Nereid> the only thing of type forall a b. a -> b -> b is const id
16:03:03 <Nereid> (and things less-defined than that, I guess)
16:03:13 <fmap> nobdraisentone: createDirectoryIfMissing True
16:04:06 <nobdraisentone> fmap: nice, thanks
16:04:08 <danielsmw> Does anyone have experience with the Accelerate library? I'm having trouble just implementing matrix multiplication.
16:14:38 <daniel_-> can i patternmatch in instance's?
16:15:12 <MostAwesomeDude> daniel_-: how so?
16:15:29 <daniel_-> made a instance show of some timedelta i wanted
16:15:37 <daniel_-> but dont want to display weeks if they are 0
16:16:00 <daniel_-> should only pop up if weeks > 0
16:17:42 <MostAwesomeDude> Well, yes, when defining the functions inside a type class instance, you can use all the normal syntax available to you.
16:17:45 <MostAwesomeDude> Including pattern matching.
16:19:12 <hpaste> daniel_- pasted “kinda ugly” at http://hpaste.org/71426
16:21:54 <fmap> daniel_-: you could use something like `show (Time w d h m s) = show w ++ "w, " ++ show (Time 0 d h m s)'
16:22:07 <daniel_-> oh
16:22:10 <daniel_-> thats genius
16:32:52 <MostAwesomeDude> Aw, there's no foldrM for Maps?
16:34:29 <fmap> MostAwesomeDude: `Map k' should be an instance of Foldable
16:34:40 <twanvl> is there a strict modifyIORef' function somewhere?
16:35:31 <pqmodn> related question, can Data.Map be an applicative? what key should 'pure x' use to build the map, or can the laws be respected with an arbitraty k-type key?
16:37:31 <pqmodn> maybe it's not possible to make an arbitrary key due to the polymorphic k, would you need another class constraint that the signature of pure doesn't have? (like the problem with Set not being a Functor)
16:37:58 <Mindrust> guys im actually learning programming here. how awesome idea is that online lessons..
16:38:15 <c_wraith> well, you could put the constraint on the definition of Applicative
16:38:25 <twanvl> what would <*> be for Data.Map? The only thing with the right type is intersectionWith
16:38:45 <pqmodn> c_wraith: oh, like (Monoid k, ...) => Applicative (Data.map k)?
16:39:00 <twanvl> that implies that `pure x` should be a map with value x for *every* key
16:39:07 <c_wraith> pqmodn: yeah, something like that.  then the trick is ensuring your implementation actually satisfies the necessary laws
16:39:37 <pqmodn> twanvl: maybe merge the two maps where either the right or left map would "win" for key collisions? i'm not sure if that would violate the laws
16:40:11 <twanvl> pqmodn: that is unionWith
16:40:19 <twanvl> but it has the wrong type
16:40:44 <c_wraith> <*> needs some sort of flavor of function application
16:40:59 <c_wraith> that's nearly a requirement of its type
16:41:30 <c_wraith> so if you have a map of functions and a map of values, how do you combine them?
16:42:28 <pqmodn> yeah, you're right.
16:42:48 <c_wraith> I'm not saying it's impossible.
16:42:51 <c_wraith> It probably is possible
16:42:57 <pqmodn> intersectionWith could maybe work, right?
16:42:59 <twanvl> ?type M.intersectionWith ($)
16:43:01 <lambdabot> forall b b1 k. (Ord k) => M.Map k (b -> b1) -> M.Map k b -> M.Map k b1
16:43:09 <twanvl> ?type (<*>)
16:43:10 <c_wraith> some sort of product might work
16:43:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:43:17 <twanvl> this is the same idea as ZipList
16:43:21 <pqmodn> yeah
16:43:53 <c_wraith> but yeah, that'd make pure a map containing all keys for that type
16:43:59 <c_wraith> which is implausible
16:44:19 <twanvl> you could define a slightly generalized Map type which supports that
16:44:23 <pqmodn> right, since pure for ZipList is cycle...
16:44:30 <c_wraith> isn't it repeat?
16:44:32 <pqmodn> or repeat
16:44:33 <pqmodn> yeah
16:45:04 <c_wraith> by analogy with list, though, you could go with the other instance
16:45:12 <c_wraith> where you put a monoid instance on k
16:45:28 <c_wraith> and combine by doing the product
16:45:41 <c_wraith> each key in the first gets combined with each key in the second
16:45:52 <c_wraith> And the value is applying that function to that value
16:46:13 <c_wraith> But I feel like that has some ambiguous behavior when you end up with colliding keys
16:46:26 <c_wraith> because repetition of keys is not allowed
16:46:29 <pqmodn> yeah, maybe i'll try that out to see if it works
16:47:40 <pqmodn> because it's entirely possible one set of keys (a and b) combine to c, while x and y also combine to form c
16:47:49 <c_wraith> yeah
16:48:17 <pqmodn> is there some other similar algebraic structure that forbids that?
16:48:40 <pqmodn> i don't know enough about rings, groups, etc
16:48:51 <c_wraith> hmm.  I'm not thinking of that offhand - but a multimap wouldn't have that problem
16:49:05 <c_wraith> Because it would just be able to store all the values
16:49:10 <pqmodn> or more generally, where the value is also a monoid?
16:49:35 <c_wraith> that seems like "less generally" to me - but it's also an idea
16:49:49 <c_wraith> I don't know if it'll end up working at the type level
16:49:53 <pqmodn> oh, i meant multimap is like having Data.Map k (Set a) right?
16:50:02 <c_wraith> yeah
16:50:24 <Nereid> I think of Map k v as being like k -> Maybe v
16:50:28 <c_wraith> The thing is, it can't be Set in this case
16:50:31 <Nereid> so...
16:50:47 <c_wraith> it'd need to be a list to have a chance of being sane
16:50:58 <pqmodn> hmm, why's that?
16:51:35 <c_wraith> Because of foo <$> bar <*> baz <*> quux
16:52:11 <c_wraith> You can't assume that a isn't a function
16:52:31 <c_wraith> in fact, a needs to be a function sometimes for longer expressions
16:52:32 <pqmodn> i don't follow. you mean you can't use Set because you need another Eq constraint, and function doesn't have one?
16:52:36 <c_wraith> yeah
16:53:48 <pqmodn> as an aside, that feels like a frustrating technicality with the definition of Monoid. is there some other formulation of Monoid that Set can implement?
16:54:11 <Nereid> what's the goal?
16:54:18 <c_wraith> err..  Set has no trouble with being a Monoid
16:54:57 <Nereid> it better be a commutative monoid
16:55:17 <pqmodn> whoops, you're right. it's Functor that causes the problem
16:55:30 <c_wraith> actually, I think it's Applicative that causes the problem
16:55:34 <c_wraith> I think Functor is fine
16:55:54 <c_wraith> err.  not for Set, for Map
16:56:01 <Nereid> what's the goal?
16:56:08 <pqmodn> you need an Eq constraint like fmap :: Eq b => (a -> b) -> a -> b
16:56:24 <pqmodn> Nereid: to define an instance of Applicative for Data.Map
16:56:33 <Nereid> hmm
16:56:52 <Nereid> you mean for Map k?
16:56:53 <pqmodn> one analagous to ZipList and another analagous to the non-deterministic interpretation of LIst
16:57:08 <pqmodn> yeah
16:57:10 <Nereid> it's not obvious how to define pure
16:57:35 <Nereid> well I think the only possible way to even define pure is by the empty map
16:57:44 <c_wraith> or the map with everything in it. :)
16:57:48 <Nereid> which doesn't exist
16:57:49 <pqmodn> for ZipList you would need something that produces a map for all values of k. analagous to how repeat produces a list for all "indexes" of the list
16:57:56 <c_wraith> Which is tough with the specific implementation of Data.Map
16:58:08 <Nereid> yeah
16:58:43 <pqmodn> i now see the similarity to the pure instance for (-> e)
16:58:48 <c_wraith> indeed
16:58:49 <pqmodn> which is const, right?
16:58:50 <c_wraith> yep
16:58:53 <Nereid> yeah
16:58:55 <c_wraith> that's exactly the same idea
16:58:56 <pqmodn> aha, insight gained!
16:59:00 <Nereid> like I said
16:59:05 <Nereid> if we could treat Map k v as k -> Maybe v
16:59:16 <pqmodn> yeah, now i see your point
16:59:49 <c_wraith> that's the same as the intersectionWith implementation
17:00:02 <Nereid> actually
17:01:17 <Nereid> given any monad m, we could make \v -> (k -> (m v)) a monad no?
17:01:29 <Nereid> yeah sure, that's like ReaderT.
17:02:52 <Nereid> (sorry for abusing lambda notation for types :s)
17:03:15 <fmap> What's the preferable way to add tests to .cabal file? I see some solutions using flags and there was a proposal for "test" section (doesn't work for me though).
17:04:20 <Nereid> fmap: http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
17:04:45 <pqmodn> still scratching my head a bit on that, Nereid. it might be getting too late in the day for me :]
17:05:11 <Nereid> pqmodn: well, there's an obvious function Map k v -> (k -> Maybe v)
17:05:26 <pqmodn> yes
17:05:48 <Nereid> for any monad m, k -> m v is ReaderT k m v
17:05:52 <shachaf> @ty (M.!)
17:05:53 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
17:05:55 <Nereid> and ReaderT k m is a monad
17:05:56 <shachaf> Er.
17:05:58 <Nereid> and in particular, an applicative
17:05:59 <shachaf> @ty M.lookup
17:06:01 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
17:06:07 <fmap> Nereid: thanks
17:06:08 <shachaf> I guess neither of those is it.
17:06:14 <Nereid> so, Map is "almost" a monad, I guess.
17:06:30 <geekosaur> @unmtl ReaderT k m v
17:06:30 <lambdabot> k -> m v
17:06:35 <Nereid> it would be if we could go back from k -> Maybe v to Map k v
17:06:38 <geekosaur> the easy way :)
17:06:48 <mgsloan> Argh, more TH woes.  Is it by-design that quasi-quotes cannot reify things defined in the module they're in?  This severely limits their power
17:06:48 <shachaf> Nereid: It's just the Ord constraint, as usual?
17:07:02 <Nereid> well, more like the implementation of Map
17:07:02 <mgsloan> (splices can, quasi-quotes cannot)
17:07:17 <shachaf> Splices can do that?
17:07:23 <mgsloan> yup
17:07:26 <c_wraith> mgsloan: that's more or less a bug due to splices and quasi-quotes running at different parts of the compilation chain
17:07:37 <geekosaur> I think splices can see what comes before them, qqs can't
17:07:38 <mgsloan> but they can only reify things that come before them in the module
17:07:41 <mgsloan> right
17:07:45 <geekosaur> this was discussed on -cafe at some point
17:07:50 <c_wraith> mgsloan: addressing that is part of the big TH changes being proposed
17:08:16 <mgsloan> c_wraith: yeah, that seems to be it - quasiquotes run in the renamer whereas splices are in the typechecker
17:08:30 <mgsloan> c_wraith - the "New directions for TH" stuff?
17:08:33 <Nereid> shachaf: there's no way to write pure/return for Map k for arbitrary k
17:08:33 <c_wraith> yeah
17:08:48 <shachaf> Nereid: Ah, and that.
17:08:53 <shachaf> Nereid: That's why you should use TMap. :-)
17:09:12 <Nereid> what's TMap?
17:09:20 <pqmodn> i've gotta run, but thanks for the insights c_wraith and Nereid.
17:09:22 <shachaf> @google total-map
17:09:23 <lambdabot> http://en.wikipedia.org/wiki/Map_(mathematics)
17:09:24 <lambdabot> Title: Map (mathematics) - Wikipedia, the free encyclopedia
17:09:26 <shachaf> @google total-map conal
17:09:28 <lambdabot> https://github.com/conal/total-map/
17:09:54 <Nereid> ah yes.
17:10:10 <mgsloan> well, good news  is, there's a fairly straightforward rewrite of QQs to be of the form $(doStuff "blah blah blah" )
17:11:42 <c_wraith> for some definition of "good news" :(
17:12:02 <c_wraith> I mean..  you don't even need to rewrite
17:12:05 <c_wraith> QQs are a record
17:12:14 <mgsloan> :D  What I'm making is already pretty crufty, so it's fine
17:12:25 <c_wraith> you could just go $(accessorIForgot qqName "string")
17:12:44 <c_wraith> Which kind of makes it extra absurd
17:12:57 <Nereid> okay, that's a pretty clever way of doing things.
17:13:43 <mgsloan> yeah.  I'm going to have a pure TH interface, and a haskell-src-exts based interface in a different module.  It's "quoteExp"
17:14:07 <mgsloan> * different package
17:15:58 <jonjon__> hello people
17:16:03 <jonjon__> I am new here
17:16:26 <jonjon__> looking for a powerful free language to migrate to
17:16:49 <shachaf> Haskell is unfortunately not powerful.
17:17:15 <jonjon__> would you say stick to c++?
17:17:36 <Enigmagic> javascript.
17:19:05 <jonjon__> javascript?
17:19:23 <jonjon__> i mean native code applications, not web
17:19:45 <jonjon__> native code for all platforms
17:20:00 <pqmodn> the javascript VM is native
17:21:22 <pqmodn> have you seen nodejs.org?
17:22:06 <c_wraith> question: why is today trolling-day?
17:22:12 <teaurchin> how do I index a mutable vector (from the vector package)?
17:22:17 <shachaf> c_wraith: Every day is trolling-day in #haskell!
17:22:20 <shachaf> :-(
17:23:42 <Enigmagic> jonjon__: well you are in #haskell, i think most people here would recommend it.
17:25:01 <pqmodn> jonjon__: but we might recommend languages besides haskell, too. if you're looking to broaden your horizons, it depends on what your already familiar with
17:26:58 <shachaf> We might recommend alternative spellings for common English words, too. There're a lot of us in here.
17:27:09 <pqmodn> heh
17:27:44 <chessguy> is there an icfp channel?
17:27:51 <shachaf> chessguy: Yes.
17:27:59 <shachaf> Well, there's a contest channel, at least.
17:28:51 <chessguy> what is it?
17:30:02 <shachaf> I don't remember -- I'm not doing the contest. I saw it mentioned, though.
17:30:06 <shachaf> @google icfp contest irc channel
17:30:07 <lambdabot> http://web.cecs.pdx.edu/~sheard/2008IcfpContest/
17:30:07 <lambdabot> Title: ICFP Programming Contest 2008
17:30:31 <chessguy> yep, that's helpful
17:30:47 <shachaf> chessguy: Is it not #icfp-contest?
17:31:05 <chessguy> if i knew what it was, would i be asking?
17:31:46 * shachaf sighs.
17:32:10 <shachaf> chessguy: Yes, it's #icfp-contest.
17:32:16 <chessguy> thanks
17:32:28 <geekosaur> it is kinda an obvious place to check...
17:32:33 * shachaf doesn't get the hostility, man. :-(
17:32:45 <pqmodn> not deserved
17:33:00 <chessguy> sorry, you're right. i didn't mean to come off that way
17:33:09 <chessguy> my bad
17:37:32 <hpaste> Rung pasted “input binding” at http://hpaste.org/71427
17:38:51 <ryan_> incoming stupid newb question: could some benificent Haskellite evaluate my hpaste?
17:39:05 <ryan_> please? and thx
17:39:07 <shachaf> Evaluate as in run or as in comment on?
17:39:23 <ryan_> comment I suppose, this one seems pretty easy
17:39:35 <shachaf> ryan_: You can't have top-level "foo <- bar" statements in a Haskell file.
17:39:49 <shachaf> What you can type in ghci is very different from what you can type into a Haskell program.
17:40:06 <shachaf> main is just main -- it's what gets run when you run the file.
17:40:07 <ryan_> Ya, I'm getting that
17:41:29 <ryan_> oops
17:41:37 <mgsloan> for posterity, my previous complaints about QQ not having reify actually worked out.  I just needed "lookupValueName" and "lookupTypeName" - I only needed qualified versions of names, not full info
17:41:51 <shachaf> ryan_: "main" is the top-level action -- it generally doesn't return anything.
17:41:55 <hpaste> geekosaur annotated “input binding” with “input binding (annotation)” at http://hpaste.org/71427#a71428
17:42:06 <shachaf> You probably want some other askForName action, which main will use.
17:44:45 <ryan_> thanks guys, it's sinking in slowly (very slowly)!
17:44:48 <shaggy2dope> http://hpaste.org/71427
17:59:05 -Snardbafulators(~trainengi@ip68-8-31-14.sd.sd.cox.net)- Tired of niggers? Sick of their monkeyshines? We are too! Join Chimpout Forum!  http://www.chimpout.com/forum At Chimpout we are NOT white supremacists! I myself am a Mexican! Basically, if you are not a NIGGER and you hate NIGGERS, we welcome you with open arms! Join Chimpout Forum today! http://www.chimpout.com/forum
17:59:16 <irene-knapp1> @where ops
17:59:16 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
17:59:24 --- mode: ChanServ set +o copumpkin
17:59:29 --- mode: copumpkin set +b *!~trainengi@ip68-8-31-14.sd.sd.cox.net
17:59:29 --- kick: Snardbafulators was kicked by copumpkin (No.)
17:59:36 --- mode: copumpkin set -o copumpkin
17:59:38 <copumpkin> thanks irene-knapp1
17:59:42 <irene-knapp1> no, thank you
18:04:16 <copumpkin> parcs`: you a cereal master? :P
18:06:27 <parcs`> copumpkin: maybe
18:06:41 <mgsloan> hehe. I love the naming of haskelly things.
18:06:41 <mgsloan> /me makes "th-lift-orphans" package
18:07:45 <copumpkin> parcs`: I have a Get that I need to run on a fixed-length buffer (length determined by an earlier field). I thought I'd use isolate on it, but it seems to do the wrong thing. If instead I do getBytes followed by runGet it seems to not mind
18:09:28 <copumpkin> I suppose I should see if the thing leaves any leftover bytes
18:09:36 <copumpkin> because isolate insists on me consuming all of them (for some reason)
18:11:40 <parcs`> maybe you can do something like 'skip =<< remaining' inside the isolate
18:12:05 <copumpkin> I feel like I must have something wrong in my inner parser and this is telling me
18:12:18 <copumpkin> because it really should be consuming all the inner stuff
18:12:24 <copumpkin> it's simply a many wrapped around a simple parser
18:15:53 <unixRogue> [1,2,3] = (a,b,c)
18:16:40 <copumpkin> parcs`: boo!
18:16:45 <copumpkin> parcs`: so it's confusing
18:19:56 <copumpkin> parcs`: oh, so I think it's a bug
18:20:15 <parcs`> in cereal?
18:20:18 <copumpkin> yeah
18:20:34 <copumpkin> what would you expect this to do: runGet (isolate 5 (many getWord8)) (B.pack [1,2,3,4])
18:20:38 <copumpkin> oh wait
18:20:45 <copumpkin> nevermind :)
18:20:59 <copumpkin> hmm
18:21:01 <zzing_> What would be the best thing to use to pause?
18:24:11 <kallisti> is there any way to calculate the fourier transform of a pure function without sampling it?
18:27:30 <copumpkin> gah, this makes no sense
18:28:14 <siracusa> zzing_: threadDelay?
18:28:23 <zzing_> It appears getline will work
18:32:11 <copumpkin> parcs`: here's my confusion http://hpaste.org/71430
18:32:50 <zzing_> Is there a command to get the current process id? It doesn't seem to be in System.Process
18:37:57 <parcs`> copumpkin: "Which shows that it succeeded in parsing the q," -- it does?
18:38:18 <copumpkin> parcs`: well, the fact that a successful parse shows up in my error message on the stack of labels
18:39:37 <BMeph> zzing_: Short answer, forkIO. ;)
18:44:55 <siracusa> BMeph: Can you elaborate, please? How does this get you the process id?
18:46:47 <copumpkin> parcs`: you see what I mean?
18:48:55 <geekosaur> zzing_, process ID is somewhat system dependent, you need to use System.Posix.Process or System.Win32.Process as appropriare
18:49:30 <geekosaur> BMeph, forkIO is not process, it's thread.  not all problems are solved by using threads, oddly enough
18:53:46 <parcs`> copumpkin: yeah -- really strange. it does look like a bug. try finding out what leftover bytes cereal is complaining about
18:54:34 <copumpkin> parcs`: yeah, if only the internals weren't hidden away so I could replicate the implementation of isolate with a more helpful error message
18:54:39 <copumpkin> (like wtf is in the bytestring)
18:56:16 <parcs`> you can find out by doing something like 'isolate len (do a <- script; rest <- getBytes =<< remaining; traceShow rest (return a))'
18:56:58 <copumpkin> hmm, yeah
18:58:16 <teaurchin> is it safe to unsafePerformIO a read from an IOVector?
18:59:24 <mrotondo> I'm going through LYAH, and I'm mucking about with the Prob monad (here: http://learnyouahaskell.com/for-a-few-monads-more#making-monads). I'd like to make it an instance of MonadPlus so I can use mfilter on it. Is there an easy way to say "just use the MonadPlus instance definition from [], but with the Prob newtype?
18:59:41 <copumpkin> parcs`: wtf, it's way larger than the length of the isolated thing
18:59:48 <copumpkin> the length I pass to isolate is 77
18:59:55 <copumpkin> the length of the leftover bit is 4086
19:01:01 <geekosaur> mrotondo, there isnt in standard Haskell, but one of the common extensions is newtype deriving which lets you kinda pull an underlying instance into your newtype
19:01:31 <mrotondo> geekosaur: sounds great! how do I use it?
19:01:58 <geekosaur> ({-# LANGUAGE NewtypeDeriving #-} then "newtype ... deriving (MonadPlus)"
19:02:18 <Zearen> Is this a proper channel to ask about ghc-pkg debugging, or is there a better one ?
19:02:37 <copumpkin> parcs`: oh well, I'll work with the hack for now and make a note to myself to track down the bug
19:03:16 <geekosaur> Zearen, if you have an actual ghc bug then #ghc might be appropriate, but in general this is prpobably the best channel
19:04:26 <mrotondo> geekosaur: Huh, I'm getting Unsupported extension errors
19:04:42 <geekosaur> hm I may have given the wrong name.
19:05:20 <mrotondo> haha
19:05:21 <mrotondo> Can't make a derived instance of `MonadPlus Prob'
19:05:22 <mrotondo>       (even with cunning newtype deriving):
19:05:22 <mrotondo>       cannot eta-reduce the representation type enough
19:05:31 <mrotondo> (It's GeneralizedNewtypeDeriving, btw)
19:06:40 <geekosaur> sorry, yes.  that sounds like you need to include some extra information in the derivation, which I wasn;t quite sure about
19:07:01 <geekosaur> what does your newtype look like?
19:07:04 <mrotondo> So then I'm back to where I was before, creating my own instance. In that case, is there an easy way to say "(++), but with Prob a instead of [a0]"
19:07:38 <mrotondo> newtype Prob a = Prob { getProb :: [(a,Rational)]}
19:08:03 <Zearen> Okay.  Well my issue as I've come to discover, is the hash following dependencies for different packages is different even for the same version and it's making ghc-pkg think there are unmet dependencies.
19:09:42 <Zearen> This seems to indicate there's something very wrong with my set-up, but I haven't a clue what it could be.
19:12:12 * hackagebot either 3.0.1 - Haskell 98 either monad transformer (EdwardKmett)
19:12:28 <geekosaur> sigh I seem to have stopped braining for the night
19:13:07 <mrotondo> :) absolutely no problemo, thanks for the pointers, I'm on the right track!
19:15:24 <geekosaur> interesting.  MonadPlus fails but Monoid (which is the one you want if you want (++)) works
19:15:51 <geekosaur> actually (++) is not right either, it's <>
19:16:12 <geekosaur> (++) "should" be Monoid but it's too late to fix that
19:17:00 <mrotondo> huh! (looking up <> now, haven't seen it yet)
19:17:06 <geekosaur> it's quite recent
19:17:30 <geekosaur> come to think of it, I'm not sure it made 7.4.1...
19:17:57 <geekosaur> it did
19:18:18 <geekosaur> http://www.haskell.org/ghc/docs/7.4.1/html/libraries/base-4.5.0.0/Data-Monoid.html#v:-60--62-
19:19:27 <mrotondo> cool
19:19:32 <mrotondo> it doesn't even show up in hoogle yet
19:20:15 <mrotondo> so I think i'm stuck using MonadPlus if I want mfilter, which I'm pretty sure I do… what would make Monoid more correct in this case?
19:20:40 <mrotondo> (btw I did get the MonadPlus instance working)
19:22:10 <hpc> :t mfilter
19:22:11 <lambdabot> Not in scope: `mfilter'
19:22:12 <daniel_-> is it just me or has hackage been awfully slow the latest few days?
19:22:16 <hpc> @hoogle mfilter
19:22:17 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
19:22:17 <lambdabot> package bloomfilter
19:22:27 <hpc> mrotondo: traversable
19:22:33 <hpc> probably
19:22:44 <hpc> maybe foldable
19:23:26 <mrotondo> mfilter is here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#v:filterM
19:23:47 <geekosaur> mrotondo, I was going by your mentioning (++)
19:24:18 <mrotondo> yeah, I mentioned that because that's how [] implements mplus
19:24:47 <randomclown> how do one use the "read" typeclass
19:24:54 <mrotondo> reality is starting to blur
19:25:34 <randomclown> say I have 'instance Show MyType where show A = "A", show B = "B"'
19:25:46 <randomclown> how do I write the 'instance Read MyType where ..."
19:26:51 <hpc> randomclown: you have to implement... uh
19:26:55 <hpc> something that isn't read
19:26:57 <hpc> and i forget what
19:27:02 <hpc> not reads either
19:27:35 <Zearen> readsPrec  (Like showsPrec) ?
19:28:38 <randomclown> the hell is readsPrec
19:29:00 <Zearen> randomclown: Does deriving not work ?
19:29:11 <geekosaur> http://www.haskell.org/ghc/docs/7.4.1/html/libraries/base-4.5.0.0/Prelude.html#t:Read
19:29:20 <randomclown> I didn't want the default string representation
19:29:26 <geekosaur> readsPrec documented there.  it is all kinda ugly though
19:29:30 <randomclown> yeah I've seen that and it was less than helpful
19:30:16 <randomclown> Simple example I guess 'instance Show MyType where show A = "AA", show B = "BB"'
19:30:21 <geekosaur> the real foundation is ReadS which is a parser
19:30:23 <randomclown> deriving will get me "A" when I want "AA"
19:30:24 <Zearen> So basically the idea is you return a list of possible parses
19:31:32 <randomclown> zearen: can you write an example for "MyType"
19:31:42 <Zearen> The Prec refers to precedence, and can be ignored in simple applications.
19:32:02 <Zearen> Um... yeah.  Personally I'd use Parsec though.
19:32:31 <Zearen> Just like a simple enumeration ?
19:32:39 <randomclown> yeah
19:37:24 <hpaste> Zearen pasted “Read class example” at http://hpaste.org/71432
19:38:06 <Zearen> Sorry, I type a little slow.
19:39:05 <randomclown> Ah right I see, thanks :zearen
19:41:13 <Zearen> NP.  It get's a lot harder when you start putting other data in there though.
19:47:13 * hackagebot either 3.0.2 - Haskell 98 either monad transformer (EdwardKmett)
19:56:39 <ben> I'm getting headaches from trying to understand Control.Monad.Trans.Control. :(
19:57:25 <monochrom> I thought Control.Monad.Trans was hard enough already :)
19:58:25 <shachaf> Control.Monad.Trans.Monad.Control
19:58:49 <ben> If this joke crosses panama, I'm out of here
19:59:36 <programm1r> hi
19:59:58 <ben> hi
20:15:18 <copumpkin> doesn't IntMap have an operation for removing a given key if it exists and maybe returning the key and the smaller intmap
20:15:20 <copumpkin> ?
20:15:52 <copumpkin> there's one for deleting the min and max
20:15:55 <copumpkin> but not a particular key
20:16:16 <mm_freak> if an existential type variable has no context, then there is no overhead, right?  i.e. 'data X = forall a. X a (a -> a)' has the same overhead as a non-existential variant?
20:16:45 <copumpkin> yeah
20:17:05 <copumpkin> that type wouldn't be very useful though :)
20:17:25 <mm_freak> copumpkin: you can do that with 'split' with reasonable performance
20:17:38 <mm_freak> copumpkin: why?  that one could be useful
20:17:40 <copumpkin> I can? I need to union the two trees
20:17:43 <mm_freak> well, no
20:17:44 <solrize> Map has something like that
20:17:50 <copumpkin> and then union can't assume that they don't overlap
20:17:52 <shachaf> If you had class Foo a where foo :: a -> a, that would be the same as data X = forall a. (Foo a) => X a
20:17:54 <mm_freak> ok, it wouldn't be useful, you're right =)
20:17:56 <copumpkin> even though that knowledge is there
20:18:07 <copumpkin> I'd need a unionOrdered or something
20:18:28 <copumpkin> there's splitLookup that gives me two IntMaps
20:18:28 <shachaf> It would be nice if there was a Set variant that let you supply a first-class comparison function.
20:18:49 <copumpkin> shachaf: and give up unions and such?
20:18:55 <copumpkin> (efficient ones)
20:18:59 <shachaf> copumpkin: It would be nice if you didn't have to. :-)
20:19:14 * shachaf can't think if a reasonable way to do it, though.
20:19:15 <solrize> what's wrong with splitLookup copumpkin ?
20:19:15 <copumpkin> oh, so you want to pass around a proof that the comparison function is the same function on both sides? :P
20:19:22 <copumpkin> solrize: I need a single IntMap
20:19:26 <shachaf> copumpkin: I said "reasonable"!
20:20:12 <copumpkin> solrize: so I need to take the two IntMaps and pass them into union, which then takes O(n + m)
20:20:12 <solrize> copumpkin, you want the smaller one and you get that along with the bigger one.  can't you just throw away the bigger one?  it's lazy evaluation, so it presumably doesn't actually cons it up unless you access it?
20:20:28 <copumpkin> solrize: I want the key and the rest of the IntMap without that key/value
20:20:37 <mm_freak> data RNG = forall g. RNG g (forall a. (Random a) => g -> (a, g))
20:20:41 <mm_freak> that one could be useful =)
20:20:50 <copumpkin> solrize: basically a "dequeue" or "pop" or whatever you want to call it
20:20:58 <solrize> delete?
20:21:14 <copumpkin> yeah, except delete doesn't return the element
20:22:27 <solrize> @hoogle Key -> IntMap a -> (Maybe a, IntMap a)
20:22:27 <lambdabot> Data.IntMap updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a, IntMap a)
20:22:27 <lambdabot> Data.IntMap insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
20:23:08 <copumpkin> hmm, I guess that updateLookupWithKey would do it
20:23:13 <copumpkin> if I return Nothing every time :)
20:23:21 <solrize> that doesn't delete the key
20:23:37 <copumpkin> hmm
20:24:37 <solrize> i'm trying to figure out what "alter" does
20:24:45 <copumpkin> I think updateLookupWithKey does what I want
20:25:22 <copumpkin> oh, hmm
20:25:27 <copumpkin> that mkes no sense
20:25:55 <solrize> well you can write a couple of calls
20:26:03 <copumpkin> sure, was just trying to avoid that :)
20:26:04 <solrize> i think IntMap recently got rewritten for speed
20:26:19 <solrize> you might be able to add a new function and send in the patch
20:26:31 <shachaf> copumpkin: Why doesn't updateLookupWithKey do what you want?
20:26:42 <shachaf> λ> IM.updateLookupWithKey (\k v -> Nothing) 5 $ IM.fromList [(0, 'a'), (5, 'b'), (10, 'c')]
20:26:45 <shachaf> (Just 'b',fromList [(0,'a'),(10,'c')])
20:27:02 <copumpkin> maybe it does!
20:27:37 <shachaf> I'm not sure about it being efficient, though.
20:27:48 <copumpkin> it claims to be pretty efficient
20:28:19 <geekosaur> solrize, alter invokes its function with Nothing if they key doesn;t exist or Just the value associated with it; the function returns Nothing to delete (or not add) the entry or Just the new value
20:28:30 <shachaf> Oh, it looks OK.
20:29:11 <shachaf> I wish all these functions had a way to return something.
20:29:35 <copumpkin> yeah, it all feels kind of ad-hoc
20:29:51 <shachaf> In other languages it would be easy: v = Nothing; updateWithKey (\k v -> v := Just v; Nothing) ...
20:29:54 <shachaf> Or something like that.
20:30:07 <shachaf> It's a bit annoying that in Haskell it all has to be special-cased by the library.
20:32:08 <hpaste> tgekey pasted “deriving segfaults? why?” at http://hpaste.org/71433
20:35:38 <tgeeky_> is there something special about the version of template haskell that comes with GHC builds?
20:35:58 <zachk> shachaf: what do you mean exactly?
20:36:07 <tgeeky_> all of the other packages involved with this crash have versions, but: ghc-prim, integer-gmp, base, and template-haskell don't have associated version numbers
20:38:00 <solrize> oh i didn't see the Maybe in that signature
20:38:18 <solrize> or rather, didn't catch on to what it did
20:44:24 <solrize> @hoogle [a] -> a -> [[a]]
20:44:24 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
20:44:25 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
20:44:25 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
20:44:35 <solrize> @hoogle a -> [a] -> [[a]]
20:44:36 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
20:44:36 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
20:44:36 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
20:45:13 <solrize> is there something like python's string.split?
20:45:21 <shachaf> @google data.list.split haskell
20:45:22 <lambdabot> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
20:45:22 <lambdabot> Title: Data.List.Split
20:45:26 <solrize> thanks
20:53:11 <randomclown> does the ST array have to to be constructed in the ST monad?
20:53:49 <randomclown> is it possible to pass in a pre initalised array into runST?
20:54:01 <solrize> :hoogle freeze
20:54:07 <solrize> @hoogle freeze
20:54:07 <lambdabot> Data.Array.MArray freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
20:54:07 <lambdabot> package safe-freeze
20:54:07 <lambdabot> Data.Text.Array unsafeFreeze :: MArray s -> ST s Array
20:54:12 <solrize> try those
20:55:40 <hbtt> Why does Haskell use lists and not arrays as a fundamental datatype? What advantages do they have over arrays? Many operations seem to take O(n) time on then, where they would be O(1) on arrays.
20:56:04 <randomclown> insertation is O(1)
20:56:05 <shachaf> hbtt: A lot of array operations aren't friendly when you're not using mutation.
20:56:37 <shachaf> You have to copy the whole array in order to change anything about it (because it's actually* contiguous in memory).
20:57:03 <shachaf> randomclown: That's also not really as true in Haskell as it is with mutation. :-)
20:57:24 <shachaf> Except with cons, that is.
20:57:32 <randomclown> I was thinking of cons
20:57:52 <shachaf> OK.
20:57:58 <shachaf> hbtt: Anyway, it depends on how you use lists.
20:57:58 <hbtt> So doesn't the lack of access to arrays slow you down a lot? For instance, I'm implementing quicksort, and the lack of a fixed memory thing (excuse my imprecise terminology) seems to mean a considerable slowdown over, say, a C version.
20:58:15 <shachaf> Yes, quicksort isn't something you'd implement over linked lists, I think.
20:58:16 <applicative> lack of access to arrays?
20:58:26 <shachaf> Haskell *does* have arrays, by the way.
20:58:32 <shachaf> People just prefer lists for a lot of things.
20:58:47 <shachaf> You can write quicksort in Haskell with arrays, though.
20:58:54 <solrize> hbtt for lists you'd probably use merge sort.  arrays are there if you need them, but using them is kind of ugly
20:58:56 <hbtt> Why do they prefer lists, if they are slower? Also wouldn't passing arrays around lose a lot of advantage of using arrays?
20:59:00 <shachaf> @google quicksort in haskell with arrays
20:59:01 <lambdabot> http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
20:59:01 <lambdabot> Title: Things that amuse me
20:59:19 <applicative> hbtt they aren't slower or faster
20:59:20 <shachaf> Bah, that's with augustss's crazy DSL.
20:59:28 <levi> (add-hook 'window-scroll-functions 'my-scroll-to-bottom nil t)
20:59:32 <levi> Heh, oops.
20:59:33 <solrize> lists are more natural in haskell, and (in any language) most parts of most programs don't need micro optimization
21:00:07 <hbtt> I'm doing some ProjectEuler problems, so I care about it a little.
21:00:15 <applicative> what are you sorting hbtt, objects of any Ord type?
21:00:27 <hbtt> Mainly numbers.
21:00:28 <shachaf> hbtt: I don't think there's a single ProjectEuler problem where you care about performance so much that you *need* arrays.
21:00:39 <solrize> hbtt if you have to optimize an euler solution you probably need a better algorithm
21:00:47 <shachaf> hbtt: On the other hand, there are a lot of programs where if you write an array algorithm using linked lists, they'll be really slow. :-)
21:00:54 <shachaf> Use a linked list algorithm for linked list programs.
21:01:06 <applicative> hbtt use Data.Vector.Unboxed it's awesome anyway.
21:01:10 <hbtt> solrize: I like being as precise as possible. It teaches me things.
21:01:38 <hbtt> What is that, applicative?
21:01:43 * zachk <- imprecision'99 
21:01:53 <shachaf> hbtt: It's like arrays for Haskell. But you probably shouldn't use that.
21:02:23 <shachaf> The way you're talking, you're going to gain a lot more from learnin Haskell if you change the way you think than if you write the same programs in a different language.
21:02:26 <applicative> http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial  http://hackage.haskell.org/package/vector <-
21:02:46 <hbtt> Shachaf: So my understanding is that the value of an array is that it is "fixed", but in haskell they get passed around, so that advantage is lost. Is that correct?
21:03:02 <applicative> it's totally wonderful. I think it would be good for a lot of 'project euler' problems where people use lists
21:03:20 <applicative> hbtt  get with laziness
21:03:24 <shachaf> hbtt: I don't understand what you mean so I can't say whether it's correct.
21:03:39 <hbtt> Neither do I, really.
21:03:54 <hbtt> Thanks for that, applicative, I'll check it out.
21:04:17 <shachaf> hbtt: My recommendation is still to understand purely-functional data structures *before* you go back to the familiarity of mutable arrays. :-)
21:04:19 <applicative> hbtt it's the most wonderful item on hackage
21:04:26 <shachaf> Or even immutable arrays.
21:04:37 <applicative> don't use mutable vectors
21:04:58 <applicative> but unboxed is good
21:05:23 <solrize> yeah, mutable arrays in haskell are sort of like dropping to assembler from C :<o
21:05:37 <solrize> hbtt what euler problem are you trying to do with arrays?
21:06:16 <hbtt> Well, I found a way around it, but I think a naive implementation of a prime sieve would be sped up using an array.
21:06:25 <hbtt> I could be wrong. I'm quite new at this.
21:06:51 <shachaf> It probably would be, but not to a degree that matters for ProjectEuler.
21:06:58 <shachaf> @google haskell prime sieve
21:06:59 <lambdabot> http://www.haskell.org/haskellwiki/Prime_numbers
21:06:59 <lambdabot> Title: Prime numbers - HaskellWiki
21:07:01 <applicative> hbtt the arrays in Data.Array are very good for e.g. memoization because they are so simply expanded.
21:07:47 <hbtt> shachaf: Well, if I'm passing around a list of a million elements, isn't that going to have a substantial effect on performance?
21:08:17 <applicative> if the list is fully evaluated it will certainly take more space
21:08:25 <hbtt> It is.
21:08:40 <shachaf> hbtt: How substantial do you mean?
21:08:53 <shachaf> It's not going to copy the million elements every time you "pass around" the list.
21:08:56 <shachaf> It'll just copy a pointer.
21:09:12 <pdxleif> This haddock says there's a Functor instance for Either, but I'm not seeing it defined anywhere... http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
21:09:16 <shachaf> Since there's no mutation, you can do that. :-)
21:09:29 <hbtt> Ok, so let me tell you a bit more.
21:09:43 <shachaf> pdxleif: Control.Monad.Instances
21:10:02 <applicative> hbtt you should just try the same program with Data.List Data.Array.Unboxed and Data.Vector.Unboxed
21:10:12 <randomclown> in this example, http://www.haskell.org/haskellwiki/Arrays#Mutable_arrays_in_ST_monad_.28module_Data.Array.ST.29
21:10:25 <hbtt> The problem is to find the sum of all the primes less than 2 million. The first thing I did was to write a naive recursive sieve that took the first element off, used it to sieve, and then recursively called the sieve function.
21:10:35 <randomclown> ST s (STArray s Int Int)
21:10:43 <randomclown> what's the "s" in the type?
21:10:49 <hbtt> I passed it the list [1..2000000] initially, and it took about 2 minutes on my laptop.
21:10:50 <shachaf> randomclown: Look up "ST"
21:11:03 <shachaf> hbtt: OK, your code is probably just naïve, inefficient code. :-)
21:11:33 <shachaf> Did you see the link from before? I think it had some more inefficient sieves.
21:11:38 <hbtt> The second thing I did was to write a "isPrime" function, and ran it on all 2 million elements. This took about 3 seconds when I compiled with -O2.
21:11:44 <randomclown> "s: the state variable argument for the ST type ' right
21:11:50 <mikeplus64> randomclown: yeah
21:12:27 <applicative> hbtt: so, what primes you had already found didn't help you find whether the next number was prime?
21:12:34 <randomclown> how come it doesn't need to be explicit?
21:12:51 <shachaf> randomclown: No, s is a magic variable used for type safety.
21:12:52 <hbtt> applicative: What do you mean?
21:12:56 <shachaf> randomclown: You should read about how ST works.
21:12:58 <applicative> hbtt: any you are complaining about lists vs arrays?
21:13:30 <hbtt> applicative: Let me compile this with -O2. I previously ran it interpreted, which may be the issue...
21:13:43 <applicative> randomclown: it is totally polymorphic, the s is the magic ST needs
21:14:24 <applicative> randomclown: you don't get to tell it anything about s thats how runST can construe the whole thing as pure
21:17:59 <zzing_> What does this mean? lexical error in string/character literal at character '\n'
21:19:40 <applicative> zzing_: you are missing quotes probably, or the right ones
21:19:50 <zzing_> It appears I was
21:20:57 <tgeeky_> missing quotes? surely not
21:20:58 <tgeeky_> @quote
21:20:58 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
21:21:14 <applicative> the greatest of the @quotes
21:21:31 <tgeeky_> @quote RichardFeynman
21:21:32 <lambdabot> RichardFeynman says: What I cannot create, I do not understand. (on his blackboard when he died in 1988)
21:22:39 <zzing_> I love Debug.Trace
21:23:31 * applicative could use a great leader like Autrijus 
21:23:53 <irene-knapp1> @quote RichardFeynman
21:23:53 <lambdabot> RichardFeynman says: What I cannot create, I do not understand. (on his blackboard when he died in 1988)
21:24:12 <shachaf> @quineman
21:24:12 <lambdabot> Unknown command, try @list
21:24:22 <irene-knapp1> @quote Fuller
21:24:23 <lambdabot> No quotes match.
21:24:38 <tgeeky_> woohoo! AT&T is doing automatic throttling now!
21:24:55 <hbtt> Ok, shachaf, what is the reason for the inefficiency in this code? http://hpaste.org/71434 . It has been 4 minutes so far with no answer. Using a different algorithm gets the answer in less than a second.
21:25:08 <irene-knapp1> @remember RichardBuckminsterFuller When I am working on a problem, I never think about beauty.  But when I have finished, if the solution is not beautiful, I know that it is wrong.
21:25:08 <lambdabot> Okay.
21:26:28 <hbtt> For reference, the other program is a prime generator that runs in about O(n^1.5) time.
21:27:14 <applicative> The writer ought not acknowledge any distinction between beautiful and adequate expression...   If he succeeds in saying entirely what he means, it is beautiful.
21:28:00 <irene-knapp1> well
21:28:06 <irene-knapp1> that's just pushing it back to a level of definition
21:28:16 <irene-knapp1> if it isn't aesthetically pleasing, it probably isn't entirely what he means
21:29:55 <hbtt> So this algorithm appears to be O(n^2/(ln n)^2)... that would explain it.
21:30:05 <hbtt> It's actually worse than naive trial division. Wow.
21:31:17 <hbtt> shachaf, applicative: Do you have any recommendations of what to read as I continue doing project Euler problems to make my programs more efficients?
21:31:24 <hbtt> As in, books or articles?
21:31:41 <shachaf> hbtt: I don't recommend learning Haskell with Project Euler problems. :-)
21:32:00 <shachaf> But if you want to learn about prime sieves, there's always that one page about prime sieves.
21:32:57 <shachaf> hbtt: By the way, I don't think your program will ever terminate.
21:33:45 <hbtt> shachaf: neither do I.
21:34:01 <shachaf> I mean, not even theoretically.
21:34:08 <hbtt> shachaf: why?
21:34:10 <hbtt> It works for small values.
21:34:35 <shachaf> Oh, maybe I misread it.
21:34:41 <mikeplus64> the only way to box a tuple of unboxed values is to pattern match the values and put them into a normal haskell tuple, right?
21:34:46 <shachaf> Yes, OK, it's just inefficient. :-)
21:36:57 <hbtt> shachaf: Extraordinarily so! It's not actually the sieve algorithm, it just looks like it at first glance.
21:37:02 <mikeplus64> also, in GHC.Prim, lazy, inline and seq all have the same definitions (let x = x in x), why not just undefined if the compiler is going to do magic on them to make them work anyway?
21:38:24 <hpc> mikeplus64: what's undefined? :P
21:39:16 <mikeplus64> hpc: a special 'error'?
21:39:41 <hbtt> Thanks for the help everyone.
21:40:06 <mikeplus64> hpc: oh, is 'undefined' not defined at that um module
21:40:23 <hpc> mikeplus64: the definition could also trace back to lazy, inline, seq
21:40:28 <hpc> and then you're fucked :D
21:40:42 <mikeplus64> because there is a lot of let x = x in x in GHC.Prim, I'm guessing these are replaced by the compiler with something magical
21:41:22 <hpc> Prim = "primitive", which rougly implies "can't be defined in-language"
21:41:26 <hpc> so... yeah :D
21:42:17 <mikeplus64> ah right
21:43:59 <haskellnewb> I've been googling for a few hours now
21:44:06 <haskellnewb> I have no idea what I'm doing wrong,
21:44:49 <shachaf> haskellnewb: Change the ` to a ' on line 228.
21:45:03 <haskellnewb> it involves cabal, anyone had any trouble installing something
21:45:04 <haskellnewb> hhaha
21:45:09 <mikeplus64> shachaf: are you pyschic
21:45:31 <haskellnewb> s/anyone/i'm/
21:45:40 <shachaf> mikeplus64: People certainly expect me to be!
21:45:41 <haskellnewb> s/had any/having some/
21:45:54 <mikeplus64> haskellnewb: ask the question, you're more likely to get an answer
21:46:05 <haskellnewb> well
21:46:19 <haskellnewb> I wanted to play around with gtk2hs
21:46:21 <mikeplus64> (but yes many people have and will continue to have trouble installing certain packages due to dependency hell etc)
21:47:10 <haskellnewb> --but http://www.haskell.org/haskellwiki/Gtk2Hs/Linux told me to grab gtk2hs-buildtools first
21:47:50 <haskellnewb> so I go and, just like I'm told I ,"$ sudo cabal install gtk2hs-buildtools
21:47:51 <haskellnewb> "
21:47:59 <mikeplus64> no sudo
21:48:02 <shachaf> haskellnewb: Don't sudo
21:48:08 <haskellnewb> but it doesn't work without sudo?
21:48:09 <mikeplus64> don't install cabal packages globally
21:48:12 <mikeplus64> it does
21:48:19 <mikeplus64> just for your user
21:48:31 <hbtt> I'm trying to do " import qualified Data.Vector.Generic.Mutable as M " and ghc says it can't find the module. Why is this?
21:48:35 <haskellnewb> But when I do it without sudo I get an error, promping me to use sudo
21:48:43 <shachaf> hbtt: It's probably not installed.
21:48:48 <mikeplus64> haskellnewb: and what is the error
21:48:57 <hbtt> shachaf: How do I go about installing it?
21:49:01 <shachaf> @google how do i use data.vector.generic.mutable in haskell
21:49:02 <lambdabot> http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
21:49:02 <lambdabot> Title: Numeric Haskell: A Vector Tutorial - HaskellWiki
21:49:05 <mikeplus64> hbtt: cabal install vector
21:49:05 <shachaf> hbtt: See step 1.1
21:49:11 <haskellnewb> cabal: /home/redacted/.cabal/logs/build.log: permission denied
21:49:29 <shachaf> haskellnewb: Yes, you made a bunch of things in $HOME as root by using sudo.
21:49:53 <shachaf> You could chown -R redacted:redactedgroup "$HOME/.cabal" # Warning: I have no idea whether that'll work
21:50:03 <haskellnewb> it will I've done it before
21:50:08 <applicative> hbtt  `cabal install vector`  import qualified Data.Vector.Unboxed as V ; import qualified Data.Vector.Unboxed.Mutable as M
21:50:18 <haskellnewb> I thought that might have been it
21:50:19 <hbtt> Thanks!
21:50:20 <haskellnewb> thanks
21:50:39 <haskellnewb> actually I think I'll just make my whole ~/ redacted:redactedgroup
21:50:55 <haskellnewb> eh, I shouldn't be so paranoid
21:51:08 <lambdaphi> redacted = lambdaphi
21:51:36 <applicative> hbtt I was just writing a stupid stackoverflow resp at the dentist,  if you want mutable evil  http://stackoverflow.com/questions/11478268/dont-know-where-to-start-with-mutable-vectors
21:51:42 <mikeplus64> if your home directory isn't owned by your user you will have problems like this
21:51:58 <lambdaphi> ah
21:52:33 <lambdaphi> lambda@hp:~$ sudo chown -R lambda:lambda ~/
21:52:43 <applicative> people seem to have mutable arrays on the brain today.   the apocalypse must be near.
21:53:52 <lambdaphi> just did chown -R ~/
21:54:00 <lambdaphi> woops already said that
21:54:40 <hbtt> applicative: What is the vector analogue of replicate for lists? I want a vector of 40000 5's for purposes of testing the running time of this algorithm.
21:55:01 <applicative> V.replicate is like replicate
21:55:36 <shachaf> hbtt: You're seriously worrying about the wrong things. :-(
21:55:45 <applicative> hbtt if you want to initialize a mutable vector V.unfreeze $ V.replicate n m
21:56:05 <hbtt> shachaf: I'm doing a comparison. I want to see if it really matters.
21:56:09 <mikeplus64> is there any sane way to import printf from C's stdio.h as a variable argument function?
21:56:15 <hbtt> shachaf: this is mostly for my curiosity.
21:56:24 <applicative> hbtt this happens in the stackoverflow question -- wait maybe you posted it! -- see the definition of 'initialize'
21:56:36 <shachaf> hbtt: There are so many things you need to know about how efficient Haskell code is written before that comparison will be meaningful, though. :-)
21:56:39 <lambdaphi> shachaf: wow thanks, running cabal install alex happy right now
21:56:53 <hbtt> shachaf: Where could I learn about these things?
21:57:45 <shachaf> hbtt: I wish I had a short answer to give you to that. :-)
21:58:01 <lambdaphi> lambda@hp:~$ cabal install gtk2hs-buildtools
21:58:08 <hbtt> applicative: So I would do V.unfreeze $ V.replicate 40000 5 if I want a vector of 40000 5's? Or do I have the arguments backwards?
21:58:09 <lambdaphi> cabal: The program alex is required but it could not be found.
21:58:14 <lambdaphi> I'm not out of the woods yet
21:58:15 <applicative> hbtt you write them, paste them on hpaste and let shachaf run them  down
21:58:20 <mikeplus64> lambdaphi: cabal install alex
21:58:24 <lambdaphi> I just did cabal install alex
21:58:34 <shachaf> I would say that the first step, given some of your previous questions, is probably to forget about small performance details like this almost entirely and learn about purely-functional data structures.
21:58:58 <shachaf> That'll answer your original question of why people like linked lists so much instead of arrays. :-)
21:59:02 <hbtt> shachaf: There's a book by that title I've heard recommended...
21:59:20 <applicative> V.replicate 40000 5 makes a vector of 400000 places
21:59:38 <hamishmack> lambdaphi: export PATH=/home/yourname/.cabal/bin:$PATH
21:59:53 <lambdaphi> what would that do?
21:59:57 <applicative> hbtt I think in this case you should be thinking about the prime  numbers, really
22:00:06 <shachaf> hbtt: Also what applicative said. :-)
22:00:17 <hbtt> applicative: I already have a sub-second solution. This is purely for my edification.
22:00:55 <lambdaphi> hamishmack What would that do?
22:01:39 <hamishmack> lambdaphi: cabal install adds executables to your ~/.cabal/bin dir
22:01:50 <lambdaphi> --and?
22:02:14 <hamishmack> lambdaphi: it installed alex, but now is looking in your PATH for it
22:02:26 <lambdaphi> ah
22:03:12 <applicative> add ~/.cabal/bin to $PATH as usual
22:04:00 <hbtt> applicative: sorry, I think you gave me code of immutable vectors. I'm working with mutable vectors, and the sqort algorithm I found takes (Vector v a, Ord a) as an argument.
22:04:11 <hbtt> I need one 40000 places long consisting of 5's.
22:04:25 <lambdaphi> hamishmack worked like a char
22:04:27 <lambdaphi> hamishmack worked like a charm
22:05:17 <applicative> hbtt you use both at once V.unsafeThaw $ V.replicate 40000 5
22:06:17 <applicative> hhbtt V.unsafeThaw takes you out of V. and into M. so to speak
22:06:48 <applicative> hbtt: then you 'program' moronic reads and writes
22:07:07 <hbtt> so I have import qualified Data.Vector.Generic.Mutable as M
22:07:15 <hbtt> What do I import as V to get that to work?
22:07:19 <applicative> scrap  generic
22:07:26 <applicative> Unboxed
22:08:02 <applicative> cut and paste import qualified Data.Vector.Unboxed as V ; import qualified Data.Vector.Unboxed.Mutable as M
22:09:29 <applicative> Data.Vector(/Mutable) work for everything; Data.Vector.Unboxed(/.Mutable) work Data.Vector.Storable is some C-interoperation nonsense. The rest dont worry about
22:09:49 <applicative> Data.Vector.Unboxed(/.Mutable) work for unboxed types like Int Char Float Double
22:09:56 <applicative> I meant
22:11:36 <applicative> hbtt: in all three cases -- boxed, unboxed and storable you use the 'pure' and mutable modules together
22:11:46 <hbtt> applicative: Let me just paste this, I think I'm just getting the names mixed up.
22:12:09 <applicative> hbtt: in your case you want unboxed
22:12:16 <hbtt> applicative: Ok, this is what I found online as a "move in place" quicksort. I can't get it to run because I'm getting type errors with the vectors. http://hpaste.org/71435
22:12:56 <hbtt> oh whoops
22:12:58 <hpaste> applicative annotated “hbtt” with “hbtt (annotation)” at http://hpaste.org/71435#a71436
22:13:17 <applicative> ^^^ I just rectified the imports
22:13:43 <hbtt> How do I sum over vectors. Prelude.sum obviously is not going to work...
22:15:22 <mikeplus64> how do you represent const char*? trying to import puts as CString -> IO () causes a segmentation fault
22:20:01 <Eduard_Munteanu> hbtt: Data.Vector.Unboxed.sum?
22:20:45 <Eduard_Munteanu> You've also got folds in there.
22:26:13 <applicative> hbtt: for pure unboxed vectors, V.sum
22:26:21 <applicative> oh as Eduard_Munteanu said
22:27:05 <applicative> my god, mutable arrays ...  char* ... what next
22:27:44 <applicative> I'm telling you we're living in  the End-Times
22:28:57 <hbtt> Ok, so this code uses mutable vectors, not unboxed vectors, and mixing them is causing problems.
22:29:20 <applicative> hbtt both are unboxed
22:29:30 <hbtt> The sort has type iqsort :: (Vector v a, Ord a) => v a -> v a, how do I make a mutable vector to pass to it?
22:29:41 <hbtt> Err sorry. My point is that there are type issues.
22:29:46 <applicative> unboxed / boxed /storable is one dimension; mutable / not is the other
22:29:57 <hbtt> Ok.
22:30:15 <applicative> hbtt: the type is pure; thus if mutable vectors are employed it is in ST
22:31:16 <hbtt> Ok, I'm going to upload code that compiles and that I know works. What I would like to know is how to make a vector to pass to iqsort.
22:31:23 <applicative> in general, when you use Data.Vector.*.Mutable you use Data.Vector.* as well
22:31:52 <applicative> you exit and enter *.Mutable with thaw and freeze
22:32:04 <hbtt> http://hpaste.org/71438
22:32:25 <hbtt> As you can see, right now it just prints "5"...
22:34:11 <Eduard_Munteanu> applicative: yeah, well, I wish GHC could somehow optimize certain stuff and use mutation behind the scenes.
22:34:12 <applicative> hbtt: really you want to understand the signature of 'go', which is (forall s. Mutable v s a -> GHC.ST.ST s ()) -> v a -> v a
22:34:55 <hbtt> How do I make my vector so I can pass it to iqsort though?
22:35:07 <applicative> which  is such a sublime signature
22:35:08 <hbtt> I just want to get this working so I can do the comparison.
22:36:02 <applicative> hbtt it's not so easy; since you abandon laziness, you must use mutation, and thus must figure out the structure of the vector package.
22:36:16 <applicative> I'm sure it'll take you much less time than it did me...
22:36:42 <hbtt> Err, so, I know the code works. I just don't know how to make the vector to pass it.
22:36:48 <hbtt> I think you are misunderstanding me?
22:36:53 <hbtt> Or I am misunderstanding you?
22:37:39 <hbtt> The iqsort function works fine. What I want to know is how to make a vector of 40000 5s I can pass to it.
22:39:47 <hpaste> applicative annotated “hbt” with “hbt (annotation)” at http://hpaste.org/71438#a71439
22:40:22 <applicative> You make a V.Vector  of 40000 5 s by  writing V.replicate 400000 4
22:40:35 <applicative> or 5
22:43:37 <hbtt> applicative should that be M.replicate or G.replicate (using the imports in the paste)?
22:44:42 <applicative> as it stands it must be V.replicate look at the signature of iqsort
22:45:13 <applicative> by the way the vector-algorithms package has a million sorts for vectors
22:45:44 <ninegrid> where can i find it documented what valid function names can be.  for instance, in f# i can have really whacky identifiers if theyre ``named in quotes like this``, i haven't seen anything similar in haskell before, but i do want to know what the limitations are and i'm having trouble finding it with google
22:45:53 <hbtt> applicative V.replicate gives me a "not in scope"
22:47:11 <applicative> because 'V' is not imported qualified?
22:48:00 <applicative> ninegrid: they begin with a lower case letter, or else they're infix with #$%^&
22:48:31 <ninegrid> applicative: i've gathered that much, but i can't have punctuation within the name either?
22:48:49 <applicative> the ones made of letters can be used infix if put in backticks, the ones made of  #$%^&  can be used prefix in ( )
22:49:13 <applicative> you can have some, _ for example
22:49:28 <ninegrid> right... but there is no way to quote them like in F#?
22:50:20 <applicative> I don't know F# but I think you are out of luck...
22:50:22 <hbtt> applicative: So what exactly do I add to make this work?
22:50:27 <ninegrid> its not a big deal, it's just that i've written quite a lot of knuth's AoCP and i had the urge to do it in haskell from scratch and I'll need to pick a different naming convention
22:50:30 <hbtt> applicative: Sorry, I'm confused.
22:50:44 <applicative> hbtt I think the whole thing needs to  be thought  through slowly
22:51:15 <ninegrid> applicative: sure... for instance in F# i can:  let ``1.1E`` = aValidFunctionName,  I suppose in haskell i would have to do:  e1_1 then
22:51:38 <hbtt> applicative: How so?
22:52:04 <applicative> > let e1'1 = 3 in e1'1
22:52:06 <lambdabot>   3
22:52:50 <applicative> > let x1_1E = 3 in x1_1E
22:52:51 <lambdabot>   3
22:53:20 <ninegrid> i think i like the first example
22:53:25 <ninegrid> thanks for your assistance
22:54:23 <applicative> ninegrid: you cant start with a number, that is annoying; and the . has so much  pressure on it, it's out of the question
22:54:58 <applicative> ninegrid: in Agda you can get relief from these irrational constraints :)
22:55:27 <levi> If you want to look for yourself what you can name things in Haskell, see http://www.haskell.org/definition/haskell98-report.pdf
22:55:52 <ninegrid> levi: thanks
22:56:15 <ninegrid> the naming isn't super important, i just want it to correspond in some way in case i show the haskell code to imperative programmers
22:57:50 <levi> "An identifier consists of a letter followed by zero or more letters, digits, underscores, and single quotes. Identifiers are lexically distinguished into two namespaces (Section 1.4): those that begin with a lower-case letter (variable identifiers) and those that begin with an upper-case letter (constructor identifiers)."
22:58:26 <levi> underscore counts as a lowercase letter, also.
22:58:54 <levi> Unless it is all by itself, in which case it's a resreved identifier.
23:00:35 <levi> By convention, though, identifiers that start with underscore represent parameters that you expect to be unused. So it's probably best not to use them for things other than that.
23:03:14 <applicative> hbtt if the argument is a regular 'pure vector' then iqsort will be like so:  runST $ do {mvec <- thaw vec ; ... mutate mvec ...; freeze mvec} where thaw and freeze are the 'unsafeThaw' etc. from the pure module
23:18:08 <akamaus> Hi, I'm trying to implement a search using a Data.Heap. Can you please help me make this typecheck? http://hpaste.org/71442
23:23:38 <Eduard_Munteanu> akamaus: what's the error?
23:24:29 <akamaus> http://hpaste.org/71443
23:24:35 <akamaus> Eduard_Munteanu, something like above
23:25:41 <akamaus> I have a simplier version, where bestFirstSearch and bsf fused together, it compiles
23:25:56 <akamaus> but I wanted to hide the heap from the client
23:25:59 <Eduard_Munteanu> akamaus: ah, right, the type ascription there doesn't take the same 's' as in the type signature for bestFirstSearch
23:26:07 <akamaus> I see :)
23:26:15 <akamaus> but have no idea how to fix it
23:27:27 <teaurchin> is it save to unsafeFreeze a vector, perform some pure operation on it, then unsafeThaw it?
23:27:43 <teaurchin> safe*
23:28:13 <Eduard_Munteanu> akamaus: does it work if you remove that ascription? Otherwise, you could use ScopedTypeVariables
23:28:27 <Eduard_Munteanu> Or...
23:28:32 <Eduard_Munteanu> @hoogle asTypeOf
23:28:33 <lambdabot> Prelude asTypeOf :: a -> a -> a
23:29:05 <Eduard_Munteanu> Since   type MaxPrioHeap prio val = Heap FstMaxPolicy (prio, val)
23:29:21 <akamaus> Eduard_Munteanu, I tried removing, it basically inferred the same, with the same error
23:29:44 <akamaus> asTypeOf? didn't know about it
23:30:02 <randomclown> why do I need this type signature here
23:30:03 <randomclown> "runST $ do starr <- thaw arr :: ST s (STArray s (Int,Int) BoardItem)"
23:30:10 <randomclown> it wont compile otherwise though
23:30:58 <Eduard_Munteanu> Hm, wait, that's not the same thing as HeapItem.
23:31:14 <akamaus> Eduard_Munteanu, ScopedTypeVariables? Can you please be a bit more concrete
23:31:52 <Eduard_Munteanu> akamaus: it's an extension that lets your original ascription work
23:32:15 <Eduard_Munteanu> randomclown: probably the types are ambiguous, what's arr?
23:32:36 <randomclown> arr :: Array (Int,Int) BoardItem
23:32:55 <Eduard_Munteanu> randomclown: pastebin some more code
23:32:56 <akamaus> Eduard_Munteanu,  Oh.. you mean s in bsf inside will be fixed to that of s in top level function?
23:33:11 <Eduard_Munteanu> akamaus: yeah...
23:33:16 <Eduard_Munteanu> @google scopedtypevariables
23:33:19 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/ScopedTypeVariables
23:33:20 <lambdabot> Title: ScopedTypeVariables – Haskell Prime
23:33:20 <akamaus> wow!
23:33:41 <akamaus> will try
23:34:25 <hpaste> randomclown pasted “typesignature” at http://hpaste.org/71449
23:35:35 <randomclown> eduard_munteanu:
23:36:07 <Eduard_Munteanu> thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)     freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
23:36:22 <Eduard_Munteanu> randomclown: looks like it doesn't know what sort of array to make in the middle
23:37:03 <randomclown> but it's in the ST monad surely it'd be ST
23:37:26 <Eduard_Munteanu> randomclown: but it needn't be a STArray
23:37:41 <randomclown> ah fair enough
23:37:47 <akamaus> Eduard_Munteanu, added 'forall s.' suddenly it compiled :)
23:37:52 <Eduard_Munteanu> Even if that was the only option, Haskell doesn't just go pick the sole member that fits a typeclass.
23:37:53 <akamaus> thanks!
23:39:24 <Eduard_Munteanu> akamaus: there might be some way to do it without that extension, but I can't tell right now
23:40:04 <akamaus> Eduard_Munteanu, are any problems with this solution?
23:40:34 <copumpkin> anyone know if there's an easy way to multiplex multiple sources in conduit together?
23:40:44 <Eduard_Munteanu> akamaus: not really
23:41:44 <akamaus> Eduard_Munteanu, if so, I'm perfectly happy. I don't need haskell98 compatibility :)
23:44:11 <copumpkin> looks like that ResumableSource thing is what I need, but the documentation isn't very clear
23:47:12 <copumpkin> I was hoping for something like [Source m a] -> Source m a :P
