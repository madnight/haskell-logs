00:04:11 <Cale> zzing_: 'arising from a use of fetchInit' means that you've made use of fetchInit somewhere, and the instance is not available there
00:04:46 <zzing_> Cale, it is bizarre because this has never happened before and why would I have exposed an internal thing?
00:04:50 <Cale> also, it's quite possible for datatypes to be qualified with the name of the original module they were defined in whenever they show up in error messages
00:05:27 <c_wraith> Also, there's no way to make that an instance of MonadSnap
00:05:33 <c_wraith> So there's something wrong with your code
00:06:05 <c_wraith> Oh, I suppose that's false.
00:06:21 <Cale> Though you're right that it's *very* suspicious
00:06:31 <c_wraith> It'd be the same as a ReaderT instance, more or less
00:07:03 <zzing_> I will ask the mighty byte tomorrow, I have written a second function that doesn't trigger the problem for initialization
00:07:25 <c_wraith> the thing is, if there was an instance for that in scope, it wouldn't show up in the type signature for fetchInit
00:07:40 <c_wraith> much like you don't see type signatures like Num Int => Int -> Int
00:08:01 <zzing_> curious enough, the function I just wrote that is much simpler triggers the problem too
00:08:08 <c_wraith> It's not invalid, it's just redundant because the Num scope for Int is already in scope
00:08:15 <c_wraith> err, Num instance
00:08:55 <Cale> most likely there's a parameter missing
00:08:59 <Cale> somewhere
00:09:01 <c_wraith> yeah, that's what I was thinking
00:09:17 <Cale> What is the error that you get when you remove the (MonadSnap ((->) Fetch)) constraint?
00:09:19 <zzing_> On my module why does a cabal configure take no time at all determining dependencies but a cabal install takes a rather long time
00:09:43 <zzing_> Cale, one sec, I have to reinstall my module on every change, doing this with two different projects
00:09:48 <Cale> because cabal install solves a dependency problem
00:10:19 <Cale> and constructs an installation plan for packages
00:10:26 <zzing_> When I do this: fetchInitWithoutConfigFileTabernac :: (HasHeist b) => FilePath -> FilePath -> String -> SnapletInit b Fetch    it gives me no problem
00:10:37 <Cale> cabal configure just fails if the package requirements aren't already satisfied
00:10:43 <zzing_> I will try it for the other function too
00:11:07 <Cale> I mean removing the constraint from fetchInit
00:11:19 <zzing_> Both functions were causing the same error
00:11:23 <zzing_> I am doing the other now
00:12:14 <zzing_> cale, this is the eror on compiling the module; http://hpaste.org/71251
00:12:27 <zzing_> fetchInit :: (HasHeist b) => SnapletInit b Fetch  is the signature
00:12:30 <zzing_> (right now)
00:12:44 <c_wraith> yeah, you almost certainly forgot an argument to something
00:12:55 <zzing_> So this was the thing that caused me to add the solution it gave
00:13:01 <Cale> What's the type of logErr?
00:13:16 <Cale> Yeah, it's best not to blindly follow that advice
00:13:17 <zzing_> logErr :: MonadIO m       => t -> IO (Maybe a) -> WriterT [t] m (Maybe a)
00:13:34 <zzing_> This code is lifted from another snaplet
00:13:34 <c_wraith> you have a very strange spelling of T.concat
00:13:49 <zzing_> T.concat?
00:13:59 <c_wraith> T.intercalate "" is the same as T.concat
00:14:00 <zzing_> I should say some of the code is lifted :P
00:14:23 <zzing_>  T.intercalate "\n" errs'  came from the original code
00:14:24 <Cale> Oh sorry, what's the type of logError?
00:14:44 <zzing_> logError :: MonadSnap m => ByteString -> m ()
00:14:51 <zzing_> This is my solution to avoid error
00:15:29 <c_wraith> wait, does that line really end with ">> return"?
00:15:44 <zzing_>                Left errs' -> (logError $ TE.encodeUtf8 $ T.intercalate "\n" errs') >> return $ Fetch "" ""
00:15:51 <Cale> hah
00:15:51 <c_wraith> it does
00:15:52 <Cale> yes
00:15:55 <c_wraith> that's the problem
00:16:12 <Cale> $ has lower precedence than >>
00:16:16 <c_wraith> $ is not a blind substitute for "put everything after this in parens"
00:16:19 <Cale> just use do
00:16:40 <Cale> It also has the effect of putting everything before in parens :)
00:16:48 <Cale> which is often useful, too
00:16:53 <Cale> f . g . h $ x
00:16:56 <c_wraith> when you expect it, yes :)
00:17:19 <zzing_>  Could not deduce (MonadSnap (Initializer b Fetch))
00:17:19 <zzing_>       arising from a use of `logError'
00:17:40 <zzing_> Possible fix add (MonadSnap (Initializer b Fetch)) to the context of
00:17:47 <Cale> zzing_: What did you do to the code?
00:17:58 <c_wraith> ah.  that looks sane.
00:18:07 <c_wraith> also, like the code is broken
00:18:15 <c_wraith> you're trying to do handler actions at initialization time
00:18:17 <c_wraith> that doesn't work
00:19:16 <c_wraith> yeah, you can't use logError in an initializer
00:19:31 <zzing_> ok, I will just have to wait to find out how I am supposed to handle this
00:19:39 <c_wraith> MonadSnap means it depends on the context of handling a request in progress
00:19:44 <c_wraith> initializers don't have a request in progress
00:19:58 <zzing_> https://github.com/iaefai/snaplet-fetch/blob/master/src/Snap/Snaplet/Fetch.hs   line 59,60  is what I did to it
00:20:18 <Cale> okay, good
00:20:19 <zzing_> I figure there has to be a way to signal a failure nicely
00:20:37 <Cale> Is SnapletInit an instance of MonadIO?
00:21:04 <zzing_> printInfo :: Text -> Initializer b v ()
00:21:05 <zzing_> here it is
00:21:55 <zzing_> I obviously need to do more work on understanding
00:21:57 <c_wraith> printInfo hardly sounds like logError, in terms of severity...
00:22:13 <c_wraith> this does sound like something worth asking mightybyte about, when he's awake
00:22:14 <zzing_> "Initializers should use this function for all informational or error messages to be displayed to the user. On application startup they will be sent to the console. When executed from the reloader, they will be sent back to the user in the HTTP response. "
00:22:21 <zzing_> definitely
00:22:30 <zzing_> At this point, the whole thing should fail
00:22:48 <zzing_> Maybe that is why the example I stole this from was using error
00:23:08 <zzing_> Is it a bad thing to use 'fail'?
00:23:09 <c_wraith> error certainly makes the whole thing fail - if not in the friendliest way
00:23:45 <c_wraith> most people find 'fail' a little distasteful - but sometimes useful
00:24:07 <zzing_> Similar reasons why I have start to use pure in spots instead of return
00:24:40 <zzing_> Although it does seem a little weird in some ways to be called pure
00:25:29 <zzing_> printInfo does seem to work
00:25:40 <zzing_> :t fail
00:25:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
00:27:33 <zzing_> fail does notthing
00:29:17 <Cale> zzing_: ah, the Initializer monad is an instance of MonadIO
00:29:28 <zzing_> I believe so
00:29:34 <Cale> zzing_: (which is the monad that you're using inside this application of makeSnaplet)
00:29:43 <Cale> So you can just throw an IO exception
00:30:12 <Cale> Or liftIO $ do putStrLn "Ack!"; exitWith (ExitFailure 1)
00:30:14 <zzing_> ok, I will put that as a note
00:30:15 <Cale> or something :)
00:30:22 <zzing_> hmm
00:30:42 <zzing_> i'll try it
00:31:20 <zzing_> I have to figure out where the configuration file is going to be now, I thought it would be under snaplet/fetch/devel.cfg
00:31:44 <zzing_> @hoogle exitWith
00:31:44 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
00:32:27 <zzing_> when I do a few cabal installs on my module, does it just install new ones or does it remove the old one with the same version?
00:33:54 <zzing_> there it exists
00:34:35 <randomclown> is it possible to use something like foldl (\x acc -> (char x) <|> acc) (satisfy False) "nrt\\\""
00:34:55 <randomclown> to construct: char 'n' <|> char 'r' <|> ...
00:37:18 <Axman6> I'd use foldr
00:37:47 <Cale> I'd use choice
00:38:02 <Cale> choice . map char
00:38:19 <randomclown> why foldr
00:38:51 <Cale> because  p <|> q  can try p without evaluating what parser q is
00:39:17 <Axman6> :t foldr1 (<|>) . map char
00:39:19 <lambdabot>     Couldn't match expected type `f a' against inferred type `Doc'
00:39:19 <lambdabot>     In the first argument of `map', namely `char'
00:39:19 <lambdabot>     In the second argument of `(.)', namely `map char'
00:39:24 <Axman6> bleh
00:40:39 <Cale> foldr (<|>) pzero [char 'a', char 'b', char 'c']
00:40:49 <otters> :t pzero
00:40:51 <lambdabot> Not in scope: `pzero'
00:41:04 <Cale> -> char 'a' <|> (foldr (<|>) pzero [char 'b', char 'c'])
00:41:46 <Cale> oh, apparently pzero is the old name
00:41:51 <Cale> you can still use mzero
00:41:54 <Cale> or parserZero
00:42:18 <randomclown> > foldr (<|>) (fmap char "nrt")
00:42:20 <lambdabot>   Overlapping instances for GHC.Show.Show
00:42:20 <lambdabot>                              ([[Tex...
00:42:25 <Nereid> or empty
00:42:30 <Cale> Parsec isn't in scope in lambdabot
00:42:37 <randomclown> ah
00:42:53 <Nereid> :t foldr (<|>) empty
00:42:55 <lambdabot>     Ambiguous occurrence `empty'
00:42:55 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
00:42:55 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
00:43:00 <Nereid> :t foldr (<|>) Control.Applicative.empty
00:43:01 <lambdabot> forall (f :: * -> *) a. (Alternative f) => [f a] -> f a
00:43:07 <Cale> however, lots of other stuff is :)
00:44:28 <randomclown> man, should have done this first, foldr1 (<|>) (fmap char "nrt")
00:44:30 <randomclown> it's so clear now
00:44:49 <randomclown> and use the library function
00:45:08 <Nereid> please don't use foldr1 when unnecessary
00:45:12 <Nereid> well
00:45:19 <Nereid> unless it's guaranteed to work maybe?
00:45:22 <Nereid> D:
00:54:39 * hackagebot paragon 0.1.28 - Paragon (NiklasBroberg)
00:54:45 <zzing_> Is there any way to speed up the linking process?
00:59:46 <whotemp> is there a way to create the fibonacci sequence using list comprehensions?
01:02:28 <zzing_> http://stackoverflow.com/questions/2404156/understanding-haskells-fibonacci
01:02:36 <mikeplus64> what was the name of the package implementing loads of pointfree combinators that used templatehaskell or something to generate them?
01:08:19 * jokar hello all,is haskell development hard?
01:09:00 <liyang> Yes. Let's go shopping.
01:09:19 <jokar> what programming language is need for develop it?
01:09:25 <jokar> which*
01:10:03 <silver_> C--/Haskell
01:10:05 <liyang> Just Haskell is enough…
01:10:23 <jokar> i can develop haskell with haskell?
01:10:30 <silver_> maybe plain C is used in ghc
01:10:32 <silver_> dunno
01:10:36 <silver_> jokar, yes you cna
01:10:55 <liyang> Unless you mean that you want to hack on GHC or another Haskell compiler.
01:11:19 <jokar> wha tis good for? is it a Artificial intelligence language ?
01:11:30 <silver_> no really
01:11:38 <earthy> it is a language for blowing your mind and learning to program better
01:11:50 <nlogax> If you want to work on GHC, this might be a good overview. I have no such aspirations, but found it interesting http://www.aosabook.org/en/ghc.html
01:12:03 <mikeplus64> jokar: it's as good if not better than another general purpose language (and yes, ghc is written in haskell aside from the rts which is c)
01:12:06 <earthy> oh, and it allows writing practical programs as well. ;)
01:12:13 <liyang> (from the questions jokar is asking I don't think he's asking about GHC development.)
01:12:23 <nlogax> And it seems itäs mostly Haskell, except from the (quite large?) C runtime
01:12:37 <jokar> is it like lisp?
01:13:00 <jokar> i didn't know why a user must use haskell? excuse me if it is silly
01:13:01 <silver_> nlogax, oh nice, thank you for the link
01:13:04 <silver_> nlogax++
01:13:06 <earthy> GHC's runtime system is a slightly scary beast: 50,000 lines of C and C-- code, much of which seems at first glance to be completely obscure.
01:13:42 <liyang> Apparently the runtime hasn't grown much (in terms of LoC) in years. It has actually shrunk a little over the years, if I remember that "Architecture of Open Source Projects" article correctly.
01:14:22 * earthy nods
01:14:26 <earthy> still, 50k lines is scary
01:14:28 <nlogax> jokar: I haven't done much Lisp, but I have a book called "Land of Lisp". There is a very relevant section there, let me just screenshot it...
01:14:49 <silver_> jokar, no it's not really like lisp, you should use if it makes your life fun
01:14:56 <jokar> o/ nlogax : thanks
01:15:14 <liyang> (Aforementioned AOS article: http://community.haskell.org/~simonmar/papers/aos.pdf )
01:15:21 <jokar> o/ silver_ : why a user must use haskell?
01:15:30 <earthy> there is no must
01:15:33 <silver_> yeah
01:15:33 <earthy> there is may
01:15:44 <jokar> :)
01:15:50 <liyang> That seems an odd question. You use it if you think it's the right language for you to use.
01:16:10 <jokar> can i write any app with haskell?
01:16:15 <earthy> *or* if you've been tasked with using it in e.g. a university course
01:16:18 <earthy> jokar: yes, you can
01:16:18 <silver_> jokar, I use it because it have some beautiful concepts
01:16:37 <silver_> @faq can i write any app with haskell?
01:16:37 <lambdabot> The answer is: Yes! Haskell can do that.
01:16:46 <earthy> see e.g. xmonad and hayoo and the like
01:16:52 <earthy> silkapp also
01:17:00 <raichoo> darcs
01:17:05 <jokar> good
01:17:19 <juhp> yay - hello.agda compiles to ~9MB :)  -- 4.7MB after stripping ;)
01:17:23 <jokar> it it a script language ?
01:17:27 <silver_> no
01:17:34 <zzing_> jokar, what is it you want to do?
01:17:45 <silver_> it compiles to native code with runtime bundled in
01:18:00 <nlogax> jokar: Here, sorry about the giant shadow, default screenshot thingie is silly. http://imgur.com/a/JzEFq
01:18:02 <jokar> i want learn another programming language
01:18:11 <liyang> jokar: best to just start learning some basics.
01:18:22 <zzing_> jokar, what do you know now and what is your background?
01:18:31 <nlogax> jokar: I included the surrounding text, but annotated the interesting parts
01:18:31 <liyang> jokar: http://learnyouahaskell.com/
01:18:48 <jokar> o/ zzing_: i know C\C++ and python
01:19:02 <nlogax> Bu I mean who *wouldn't* pick the sheep in wolves clothing?
01:19:11 <nlogax> Err, flip that
01:19:33 <zzing_> jokar, do you know them very well or just basics?
01:19:59 <jokar> i want learn it very well like a developer
01:21:14 <isomorphic> what's the right way to handle an ambiguous module name that results from a superseded package, i.e.:
01:21:15 <jokar> i think it is a little hard
01:21:26 <isomorphic>     Ambiguous module name `Control.Monad.Error.Class':
01:21:26 <isomorphic>       it was found in multiple packages: monads-fd-0.2.0.0 mtl-2.0.1.0
01:21:45 <isomorphic> Should I be getting rid of monads-fd?
01:22:00 <zzing_> چقدر خوب می دانید پایتون
01:22:20 <jokar> o/ zzing_ : hehe,not very well but i work with it
01:22:31 <Nereid> isomorphic: ghc-pkg hide?
01:23:12 <zzing_> jokar, there can be some benefits to you knowing haskell. But I would caution you it is a very trickly langauge to pick up. Although we have a wonderful community here.
01:23:25 <nlogax> jokar: In my experience, it's ingrained thought patterns of imperative language, like you mentioned C/Python,that makes it seem hard. It's not inherently difficult. Many things that look like dark magic in the beginning turn out to be just so simple you couldn't imagine it working like that
01:23:33 <Nereid> isomorphic: although if you use cabal, you just specify which package to use
01:23:47 <nlogax> At least that was/is my experience :)
01:24:31 <raichoo> nlogax: +1
01:24:32 <nlogax> And every time you "get" something, a bit of what seemed like complexity falls away and reveals its simplicity
01:24:41 <Ralith> nlogax: +10
01:24:59 <Ralith> learning haskell is worth it just for how much fun you'll have with the eureka moments
01:25:17 <jokar> thanks
01:25:27 <isomorphic> Nereid: Thanks.  I went down the ghc-pkg hide route, but I should probably do it with cabal ;)
01:28:01 <zzing_> Is there a language done in haskell that compiles to javascript and is legitly useful but feels more like haskell - just not as rigid
01:28:03 <nlogax> jokar: I would also add that the things you learn in Haskell-land, many or few, are very usable when you later design software in some other language, even though it doesn't specifically support some Haskell feature
01:28:19 <blackdog> zzing_: roy, perhaps
01:29:06 <jokar> o/ nlogax: why haskell is created ?
01:29:18 <jokar> i think it is like lisp
01:29:32 <zzing_> jokar, combine a lot of the research efforts into a single language
01:29:40 <nlogax> jokar: IIRC, it was created because a bunch of awesome people wanted to... yeah, what zzing_ said.
01:30:10 <zzing_> The biggest areas of academic research (of compilers) are in functional languages and related.
01:30:34 <ciaranm> twenty years ago, maybe
01:31:04 <jokar> can you show me a project that handle with it?
01:31:36 <quicksilver> it's not really like lisp
01:31:46 <ssbr_> it's not like lisp at all.
01:31:47 <quicksilver> it was created by people working with miranda, ML, and lazy ML
01:32:03 <quicksilver> they wanted a standardised lazy functional programming language
01:32:19 <blackdog> ssbr_: it's more like lisp than it's like C
01:32:29 <quicksilver> only slightly.
01:32:33 <ssbr_> ^
01:32:43 <ssbr_> It's as similar to lisp as it is to Python.
01:32:53 <jokar> thank you i think i must more research about it
01:32:56 <nlogax> jokar: Here's my first Haskell project, not much to look at but at least shows you can get stuff done with not-terrible amounts of code https://github.com/nlogax/norby
01:33:14 <zzing_> I wonder - how hard would it be to write a 'miranda' compiler that would run completely inside a webbrowser? (noting the miranda is relatively simple)
01:33:16 <nlogax> Never dared post it anywhere :P
01:34:13 <roconnor> zzing_: have you seen helium?
01:34:25 <zzing_> roconnor, no
01:34:48 <roconnor> zzing_: http://en.wikipedia.org/wiki/Helium_%28Haskell%29
01:34:48 <ssbr_> zzing_: re languages that compile to js, I saw the slides for a language called Roy recently
01:35:03 <ssbr_> zzing_: http://roy.brianmckenna.org/
01:35:05 <zzing_> ssbr_ it was mentioned, and it might be ok
01:35:19 <roconnor> zzing_: wow the wikipedia article isn't very useful
01:35:30 <roconnor> http://www.cs.uu.nl/wiki/Helium
01:36:11 <zzing_> looks dead
01:36:22 <roconnor> zzing_: and miranda isn't :D
01:36:58 <zzing_> roconnor, well I speak of recreating it :P
01:37:37 <isomorphic> zzing_: What about https://github.com/kripken/emscripten/ ?
01:37:46 <roconnor> zzing_: okay.  I was just thinking that if you want a Haskell like language that doesn't have scary error messages, you might consider Helium
01:38:11 <zzing_> roconnor, my main interest is something that can run client side in a browser - think that is possible?
01:38:28 <zzing_> isomorphic, that is scary :P
01:39:01 <roconnor> zzing_: there are / where several projects to compile Haskell to javascript
01:39:16 <zzing_> that could be interesting
01:42:07 <mikeplus64> is there an undefined for types?
01:42:28 <zzing_> mikeplus64, can you elaborate
01:43:10 <mikeplus64> zzing_: say i have type Const x y = x, is there a Const x undefined o- oh yeah existentials
01:43:58 <zzing_> How about Const x _ = x
01:44:25 <zzing_> nvm
01:44:27 <mikeplus64> thats not what i mean, nevermind
01:46:04 <nlogax> Is GHC Core ever written/worked with manually? If that makes sense.. I mean, I read that it's GHC's intermediate language, but I also see it popping up in some other places, where it is manipulated in Core form http://www.ittc.ku.edu/csdlblog/?p=105
01:47:42 <shachaf> nlogax: I'm not sure GHC even has a parser for Core?
01:47:43 <quicksilver> mikeplus64: no, there isn't an undefined for types. The type-level is total.
01:48:03 <shachaf> quicksilver: Not with the right extensions!
01:48:06 <quicksilver> (except in the presence of some extensions like undecidableinstances)
01:48:19 <shachaf> (Some people might call those "the wrong extensions".)
01:48:21 <quicksilver> ...but they still don't give you _|_-type objects
01:48:43 <quicksilver> they give you type-checker non termination, but not a "canonical name for type checker non termination"
01:49:12 <shachaf> What's a "canonical name"?
01:50:04 <quicksilver> well like 'undefined' or 'error'
01:50:11 <nlogax> shachaf: Yeah I can't see one in the sources, so that seems to imply there's no code directly in Core anywhere..?
01:50:28 <quicksilver> nlogax: that's right.
01:50:30 <nlogax> Was curious what it looked like :)
01:50:31 <shachaf> Well, there's Core that GHC generates.
01:50:41 <nlogax> Yeah, but from other source
01:50:47 <shachaf> But otherwise it's just an internal datatype.
01:50:49 <quicksilver> nlogax: there are optimisations in terms of Core, but they're written as chunks of haskell which operate on the Core AST
01:51:02 <quicksilver> nlogax: ...not things which operate on an explicit format in a text file.
01:51:13 <nlogax> quicksilver: I see, yeah. It looks specifically designed for that
01:51:17 <quicksilver> arguably the internal dataype is "real Core"
01:51:28 <quicksilver> and the stuff in the text file is just an externalisation of it for human reading
01:54:39 <nlogax> I wonder if Haskell infects the mind like some sort of virus, and keeps changing it even when you're not using Haskell... must be a year or so since last glancing at GHC source, and not understanding much. Now, after a long time of not writing Haskell, most of it is quite approachable
02:19:45 <zzing_> :t lookup
02:19:46 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
02:20:08 <XexonixXexillion> what versions of GHC are pattern guards supported in?
02:20:35 <mikeplus64> XexonixXexillion: ghc 7.4 + definitely (i use it)
02:21:23 <srhb> 7.2 as well
02:22:04 <XexonixXexillion> nvm, I thought it mightn't be in 6.12 (which is what my university's machines are running), but it turned out that I can't spell
02:22:19 <srhb> Spell | ? :-)
02:24:14 <fmap> XexonixXexillion: 6.12.1 has -XPatternGuards
02:25:25 <XexonixXexillion> fmap: I know that now... apparently I needed to put two 't's in pattern :p
03:50:12 <dada_cetacean> is there a specific reason why binary search is popular versus some n-ary search for arbitrary n?
03:50:51 <scopedTV> it's more complicated to code, and there is no asymptotic benefit, I'd think.
03:51:42 <Botje> dada_cetacean: i vaguely recall binary being better branch-prediction-wise.
03:51:43 <scopedTV> instead of log_2(N) you get log_p(N), but these are asymptotically equal
03:52:25 <scopedTV> also that, maybe that caching or branch prediction gets in the way of good practical performance
03:52:47 <solrize> for disks people usually use fairly wide b-trees
03:53:02 <scopedTV> yeah databases as well
03:53:31 <scopedTV> because the time to fetch a disk page dwarves the computational time
03:54:06 <shachaf> solrize: But people still often search nodes of B-trees with a binary search. :-)
04:05:18 <hpaste> alech pasted “Twitter vs. hoauth” at http://hpaste.org/71254
04:06:34 <alech> anyone with some hoauth experience? The above paste works fine for a GET request with the timeline endpoint, but I cannot tweet using POST.
04:06:53 <alech> (I get back a 401 "Could not authenticate with OAuth")
04:08:48 <nobdraisentone> How can I have `∷ m Bool → m () → m ()'?
04:10:06 <scopedTV> example p m1 m2 = do { p <- b; if p then m1 else m2 }
04:10:11 <scopedTV> errr
04:10:20 <Peaker> @type \p t -> do { x <- p ; when x t }
04:10:21 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
04:10:24 <scopedTV> example p m = do { p <- b; if p then m else return () }
04:12:20 <fmap> @type (flip when) . (>>=)
04:12:22 <lambdabot>     Couldn't match expected type `()' against inferred type `m b'
04:12:22 <lambdabot>       Expected type: m a -> (a -> m b) -> ()
04:12:22 <lambdabot>       Inferred type: m a -> (a -> m b) -> m b
04:12:27 <fmap> @type (. flip when) . (>>=)
04:12:29 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
04:13:10 <Peaker> @let argument = flip (.) ; result = (.)
04:13:11 <lambdabot>  Defined.
04:13:32 <Peaker> @type (result . argument) (flip when) (>>=)
04:13:33 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
04:14:41 <fmap> i wish when was `∷ m () → m Bool → m ()' :(
04:15:10 <fmap> err
04:15:16 <fmap> Bool, not m Bool
04:15:36 <Peaker> ah so you could say:   doThis `when` that ?
04:15:57 <fmap> yeah
04:16:02 <Peaker> however, it's often useful to have the "large action" argument be last, so you can throw a $ do at the end
04:16:34 <Baughn> Otherwise you'll end up throwing flip in everywhere
04:16:51 <hpc> see also, forM vs mapM
04:17:03 <hpc> forM list $ \elem -> do ...
04:17:04 <hpc> vs
04:17:13 <hpc> mapM (\elem -> do ...) list
04:17:44 <Peaker> if $ was left-associative, maybe you could delimit the "do" arg with a $ before and after
04:19:13 <tdammers> isn't being right-associative the whole point of $ ?
04:19:31 <unnali> tdammers: well, sort of, but imagine if it weren't!
04:20:18 <Peaker> tdammers, no, the low precedence is the point...
04:20:34 <Peaker> tdammers, if you want right-associative application, you can just use . and $ instead of $ and $
04:21:15 <Peaker> f . g . h . i $ x     currently is the same as f $ g $ h $ i $ x    and there's no way to say:  (((f g) h) i) x   (for f,g,h,i that need parens) without the parens
04:21:57 <scopedTV> unless you're willing to introduce your own combinator.
04:21:59 <parcs`> with right-associative $ you can do forkIO $ f . g . h $ x
04:22:07 <parcs`> you can't do that with a left-assoc one
04:22:49 <parcs`> ...but you can do forkIO . f
04:23:10 <tdammers> isn't (((f g) h) i) x the same as f g h i x?
04:23:35 <scopedTV> yes, but g might be a more complicated expression
04:23:59 <tdammers> mkay
04:24:33 <tdammers> I guess in that case a let or where would be appropriate
04:24:43 <tdammers> or just f (g) h i x
04:26:23 <scopedTV> i like the associativity of ($) to be reversed
04:29:32 <ksf> @djinn groupEithers ::  [Either a b] -> [Either [a] [b]]
04:29:32 <lambdabot> Cannot parse command
04:29:40 <ksf> @djinn [Either a b] -> [Either [a] [b]]
04:29:40 <lambdabot> Error: Undefined type []
04:29:53 <ksf> anyhow, that's bloody useful.
04:30:00 <scopedTV> really? i've never seen the need
04:30:22 <ksf> well, it's useful if you need that pattern ;)
04:30:23 <scopedTV> you mean [Left 3, Left 4, Right 5, Left 6] -> [Left [3,4], Right [5], Left [6]]
04:30:27 <d-snp> I don't think I've ever found a good place to find a .
04:30:31 <ksf> yep.
04:30:31 <d-snp> I always use $
04:30:51 <scopedTV> d-snp: probably you don't write pointfree enough.
04:30:55 <ksf> d-snp, it's needed for pointless style.
04:30:59 <scopedTV> i use it all the time, probably more than ($)
04:31:31 <scopedTV> > map ((+1) . (*2)) [3,4,5]
04:31:34 <lambdabot>   [7,9,11]
04:31:50 <ksf> scopedTV, I have a list of stuff I need to generate serialisers for, and some of those are blaze writers, some are blaze builders.
04:32:09 <scopedTV>     putStrLn . unlines . map show $ filter (\p -> s p == 0) (take 30000 ps)
04:32:17 <scopedTV> an example from real code ^
04:32:18 <ksf> I wrap the writers into left and builders into right, then groupEither those, and then wrap fromWriter around each sequence of writers.
04:32:32 <scopedTV> i see yeah
04:32:39 <d-snp> what's the difference with putStrLn $ unlines $ map .. ?
04:32:43 <quicksilver> I use (.) about 100 times more than $
04:32:48 <scopedTV> d-snp: nothing, style.
04:32:56 <quicksilver> d-snp: no difference, but it's better :)
04:33:04 <ksf> d-snp, the difference is in the ".." you mentioned.
04:33:07 <quicksilver> it's better because it has more valid subexpresions.
04:33:16 <d-snp> I can't seem to figure out when I can substitute $ with . and when I can't
04:33:25 <quicksilver> (putStrLn . unlines) and (unlines . map show) are valid subexpressions
04:33:33 <quicksilver> which is interesting for refactoring
04:33:48 <quicksilver> and helpful for understanding/using higher-order functions
04:34:15 <ksf> @hoogle [Either a b] -> [Either [a] [b]]
04:34:15 <lambdabot> No results found
04:37:11 * ksf bets there's a categorical name for groupEithers
04:41:34 <quicksilver> ksf: I was thinking of saying something cute about that, but I'm actually not quite sure there is.
04:42:03 <quicksilver> ksf: Either is a bifunctor (right?) but I supect there aren't so many names about -orphisms pushed through bifunctors.
04:42:15 <quicksilver> if only there was an edwardk to tell us.
04:43:00 <quicksilver> also the 'grouping into an outer list' mechanism doesn't seem like a completely free/natural concept.
04:50:45 <edsko> has anyone written some code that generalizes Template Haskell's isInstance to compound types? (as in, it works when asking about Int or Bool, but it doesn't do the right thing for (Int, Bool) )
04:56:43 <ksf> aren't there conversion functions between Word8 and Char8 bytestrings or am I blind?
05:00:43 <quicksilver> ksf: they are secretly the same type.
05:01:01 <quicksilver> ksf: you don't need to do anything to convert - just call the functions from the module you want to treat them the way you want.
05:01:50 <fmap> ksf: iirc there are `w2c' and `c2w' in Data.ByteString.Internal
05:02:01 <quicksilver> yes, but that's Word8 to Char8
05:02:06 <quicksilver> not Word8 Bytestring to Char8 ByteString
05:02:11 <quicksilver> the former are two types
05:02:16 <quicksilver> the latter are two names for one type.
05:02:18 <tdammers> network-fancy fails to install for me, anyone else seen this?
05:02:36 <tdammers> 'Illegal instance declaration for `StringLike String'
05:02:39 <ksf> oh, I thought they had different show instances or something.
05:03:16 <quicksilver> ksf: you can for example do BSW.unpack . BSC.pack
05:03:23 <mm_freak> can i make cabal-dev install the documentation index?
05:03:27 <quicksilver> (if you had imported the modules into those namespaces)
05:03:40 <ksf> well yes but re-packing seems excessive.
05:03:49 <quicksilver> no need to repack anything
05:03:58 <ksf> oh, wait, I read that outside in.
05:04:00 <quicksilver> that was just an example of using functions from different packages on the same bytestring :)
05:04:26 <quicksilver> not a recommended solution to any problem.
05:05:33 <ksf> now a completely different topic: is there a way to get host endianess at CPP-time?
05:06:15 <quicksilver> I imagine there is a predefined symbol for that, but I certainly don't know what it is.
05:07:28 <quicksilver> ksf: jules-macbook:~ jules$ gcc -E -dM - < /dev/null |grep ENDIAN
05:07:29 <quicksilver> #define __LITTLE_ENDIAN__ 1
05:08:05 <quicksilver> I get nothing on linux though
05:08:14 <quicksilver> so it's presumably not standard (gcc)cpp :-)(
05:09:29 <hpaste> mcstar pasted “Haskell Counter-example - ising monte carlo” at http://hpaste.org/71258
05:09:56 * hackagebot egison 2.1.13 - An Interpreter for the Programming Language Egison (SatoshiEgi)
05:10:00 <mcstar> if anyone cares, it is possible to write ugly code in haskell ^^
05:10:03 <johndennington> Hello. I'm looking at monad transformers. What is the difference between StateT, and ST?
05:10:37 <quicksilver> they are completely different, johndennington
05:10:52 <johndennington> quicksilver: doesn't ST stand for state transformer? i'm so confused
05:10:56 <sipa> StateT is the transformer equivalent of State
05:10:56 <quicksilver> no, it doens't
05:11:02 <quicksilver> it's probably a bad name
05:11:16 <sipa> ST is very much like IO
05:11:23 <quicksilver> it stands for 'state thread' I think but it's a subtly (importantly) different use of the word 'state'.
05:11:33 <quicksilver> and it's not a transformer at all.
05:11:52 <johndennington> quicksilver: oh i get it - people use IO where they really just want some state, so it's like IO without the IO bit
05:12:05 <quicksilver> State (and StateT) are ways to use monadic combinators and the 'do' notation to convenient build up functions of type s -> (a,s)
05:12:15 <quicksilver> i.e. functions which thread through an internal 'state' value of type s.
05:12:19 <quicksilver> johndennington: yes.
05:12:25 <sipa> yes, and through clever use of the type system, ST has a referentially transparent 'run' function
05:12:28 <quicksilver> johndennington: ST is the "mutable variable" part of IO
05:12:32 <quicksilver> without the general IO parts of IO.
05:12:50 <parcs`> copumpkin: check out my awesome answer to your so question
05:12:58 <johndennington> thanks all
05:13:16 <quicksilver> so ST gives you newSTRef (so you can create arbitrary new 'cells' of any type you want) and also the STArray stuff (reasonably high performance memory-efficient arrays)
05:20:43 <mcstar> any suggestions wrt my ugly code?
05:21:16 <unnali> mcstar: needs more functions of less lines.
05:21:28 <parcs`> mcstar: type signatures for top-level definitions
05:22:04 <mcstar> that doesnt make it cleaner..
05:22:10 <mcstar> parcs`: ^^
05:22:30 <parcs`> yeah it does
05:22:43 <parcs`> also (`mod` h) <$> abs <$> rand
05:22:45 <parcs`> why
05:23:07 <mcstar> yeah, abs is not necessary
05:23:56 <parcs`> well, i mean why would you use the function instance for Functor like that
05:24:43 <mcstar> uh, i dont want to introduce unnecessary itermediate bindings
05:24:56 <parcs`> why not (`mod` h) . abs <$> rand
05:25:16 <mcstar> is there a difference?
05:25:35 <mcstar> i thought it would compile to the same code
05:25:37 <zachk> @type rand
05:25:39 <lambdabot> Not in scope: `rand'
05:25:46 <mcstar> IO Int
05:27:16 <mcstar> theres this auxiliary function, that taverses the vector and modifies its content, probably i should use some ready-made one
05:29:05 <mcstar> http://i.imgur.com/cnldw.png << this is how it looks
05:30:55 <Botje> mcstar: you can replace some of the tail-recursive loops with forM or sequence . replicate
05:31:31 <mcstar> like, forM action [indices] ?
05:31:50 <Botje> forM [indices] action
05:31:56 <mcstar> ah yeah
05:31:59 <mcstar> its flipped
05:32:49 <mcstar> Botje: and that shouldnt be less efficient than a custom function?
05:33:34 <mm_freak> sequence . replicate = replicateM
05:33:45 <mm_freak> btw, that's a type error
05:33:49 <mm_freak> sequence . replicate n = replicateM n
05:34:02 <Botje> @src forM_
05:34:02 <lambdabot> forM_ = flip mapM_
05:34:28 <Botje> mcstar: no idea about that. it boils down to what you're writing now
05:34:35 <Botje> i'm just optimizing for code prettiness ;)
05:34:46 <mm_freak> mcstar: combinators in haskell normally have the same performance as the explicit recursion
05:34:57 * hackagebot conduit 0.5.2 - Streaming data processing library. (MichaelSnoyman)
05:35:02 <mm_freak> sometimes even better, because rules may apply fusing things together
05:35:08 <mcstar> ok, sounds comforting
05:38:58 <silver_> mcstar, is this haskell-generated picture?
05:39:00 <Botje> mcstar: another thing you can do is pass around the spinvector and only write it at the end
05:39:03 <silver_> http://i.imgur.com/cnldw.png
05:39:11 <Botje> (for loop at ll 34--47)
05:39:18 <mcstar> silver_: no, java
05:39:21 <silver_> aww
05:39:26 <mcstar> i use java when i write haskell
05:39:36 <mcstar> silver_: yes, haskell :)
05:39:37 <silver_> looking for a simple haskell library for easy graphics
05:39:41 <silver_> ohohoh
05:39:44 <Botje> oh wait, sV is just an array :[
05:39:44 <silver_> which library?
05:39:49 <mcstar> gloss
05:40:09 <silver_> yeah! thank you
05:40:13 <silver_> just what I looked for
05:40:15 <mcstar> have fun
05:44:02 <hpaste> mcstar pasted “looking for a seed?” at http://hpaste.org/71260
05:44:23 <mcstar> lol, i downloaded a similar simulation, thats how the guy makes his seed
05:44:57 <Botje> that's an impressively redundant implementation of time()
05:44:59 <d-snp> mcstar: noes :(
05:45:57 <d-snp> it's not random at all, kind of defeating the idea of a seed :P
05:46:19 <d-snp> what's up with the 70 factor? :P
05:46:33 <mcstar> 5 lotto numbers
05:48:13 <hpaste> mcstar annotated “looking for a seed?” with “looking for a seed? (annotation)” at http://hpaste.org/71260#a71261
05:48:24 <mcstar> apparently he made his own prng
05:48:55 <mcstar> so probably thats why he wante to control the seed(wonder what kind of prng needs that kind of seed generation :S)
05:49:09 <mcstar> i didnt know java lacks a good prng, btw
05:50:49 <mcstar> ok, i can imagine one possible scenario, when the above makes sense, if the built-in generator is horrendously slow
06:07:30 <XexonixXexillion> Is there anyway to get the values of C enumerations using the FFI? Or can I only import functions?
06:07:30 <lambdabot> XexonixXexillion: You have 1 new message. '/msg lambdabot @messages' to read it.
06:07:42 <quicksilver> XexonixXexillion: you can only import functions.
06:07:56 <quicksilver> XexonixXexillion: C enumerations are not exported in C .o files or C libraries
06:08:04 <quicksilver> (if you want a technical explanation as to why)
06:08:25 <quicksilver> however there are tools to automate haskell "Wrappers" for C enums.
06:08:54 <Eduard_Munteanu> Enumeration values are just identifiers corresponding to integers.
06:09:08 <Eduard_Munteanu> enums are ints, IOW.
06:10:23 <XexonixXexillion> My problem is that my code relies on an enumeration, that has different numbers for associated values for different versions of the library
06:11:27 <Botje> XexonixXexillion: well, you're screwed :]
06:11:30 <parcs`> actually i think ghc 7.6 has the 'stdcall' calling convention with which you can FFI-import values from header files
06:11:39 * however is rummaging around in his brain how the #{enum} thing fits in the picture ... http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/hsc2hs.html
06:12:20 <XexonixXexillion> Currently I simply have a small c library which rexports them as functions. It works, but it seems a bit too hacky
06:12:47 <drbean> [_] doesn't match the empty list.
06:13:04 <however> drbean: yes. [] matches the empty list
06:13:08 <Botje> drbean: correct, it matches a list of one element
06:13:53 <however> XexonixXexillion: could you put the enum in an .h file and in haskell import that? (i'm probably missing something)
06:14:52 <parcs`> wait no the new calling convention is 'capi'
06:15:07 <quicksilver> XexonixXexillion: that's a reasonable approach, although you might automate the generation of that.
06:15:14 <parcs`> XexonixXexillion: check out hsc2hs and bindings-DSL
06:15:32 <quicksilver> the other approachs amount to various ways of automating it.
06:16:26 <quicksilver> the important point is that the actual integer represented by an enum constant is not present in the library (unless the library specifically provides functions to return them, of course)
06:16:50 <quicksilver> so you either need to write functions to return them, or parse the .h file, or use a program which parses .h files (including, perhaps, a C compiler).
06:17:08 <quicksilver> if they are also present as CPP #defines then a preprocesser may be enough.
06:18:16 <XexonixXexillion> I think I'll just throw some template haskell at the problem and use the c functions I've written
06:19:18 <Eduard_Munteanu> XexonixXexillion: well yeah, you could wrap that C library in a more convenient one of your own.
06:22:15 <XexonixXexillion> On a similar topic, what (if any) problems are caused by a Haskell program and/or library being dynamically linked
06:28:40 <trem> hi. i'm having a problem compiling some code with GHC 7.4.1 (current platform) which compiled fine with 7.0.x (don't remember exactly, was another platform release)
06:28:57 <trem> I do not get any warnings / error messages
06:29:20 <ben> What happens?
06:29:24 <trem> GHC just keeps eating more RAM until it's killed by the OS
06:29:34 <ben> oh dear
06:29:38 <trem> this is on OSX / Linux and I'm currently checking windows
06:29:50 <scopedTV> do you have any extensions enabled?
06:30:02 <scopedTV> did you try compiling with or without optimization?
06:30:21 <trem> scopedTV, everything is here : http://code.google.com/p/bling-raytracer/source/browse/
06:31:09 <trem> scopedTV, basically I'm using some options which are supposed to boost FP performance, which may or may not have any positive effect
06:31:11 <trem> :-)
06:32:25 <trem> GHC struggles on Transform.hs
06:33:11 <trem> (which is the only file importing the Data.Vec stuff, basically because I'm too lazy / dumb to code a matrix inversion myself
06:33:21 <however> wow, no LANGUAGE lines at all :-/ http://code.google.com/p/bling-raytracer/source/browse/src/Graphics/Bling/Transform.hs
06:33:51 <trem> however, is that good or bad or plain interesting?
06:34:59 <trem> Flt is either Double or Float, so I can choose precision at compile time
06:35:02 * hackagebot http-types 0.7.1 - Generic HTTP types for Haskell (for both client and server code). (AristidBreitkreuz)
06:35:16 <trem> the rest is pretty obvious I think
06:36:03 <mcstar> there must be some rule, that is looping
06:36:12 <mcstar> happened to me once too
06:36:32 <mcstar> theres a ghc option, that dumps the rules it is trying to apply
06:36:56 <ksf> term how much ram are we speaking about?
06:36:59 <mcstar> -ddump-rule-firings
06:37:07 <mcstar> trem: compile with that ^^
06:37:10 <ksf> 1G with big sources isn't really rare
06:37:19 <trem> ksf, I't 8 GB for my linux machine
06:37:31 <ksf> nvm, just wanted to check.
06:37:57 <trem> ksf, plus 8 GB swap ... :-)
06:38:01 <however> trem, well i just thought that if a dozen complicated extensions overwhelm ghc, that might be slightly more understandable, but plain haskell ...
06:38:23 <trem> mceier, I'lll try it once the dependencies are installed on the machine I'm currently on, thanks
06:38:39 <mceier> trem: ok
06:38:54 <trem> mcstar, the last message to mceier was for you. sorry, mceier :-)
06:39:03 <mceier> np :D
06:39:05 <mcstar> mceier: hi!, long time no mistake
06:39:11 <mceier> yeah :)
06:40:20 <however> (i love how mceier promptly said he was ok with it)
06:40:38 <trem> ok, so the OOM triggers on windows, too. I'll try to dump the rule firings
06:40:47 <mcstar> however: its not the first time this happens
06:41:07 <HugoDaniel> man, i love c2hs
06:41:54 <HugoDaniel> such a breeze of fresh air from the heavy weight job of doing bindings to C libs
06:42:37 <HugoDaniel> cool paraphernalia of tools to help doing the job right :)
06:43:42 <ben> goddamnit, I wanted to see if this also happened in ghc 7.4.2 and said cabal-dev install like five minutes ago
06:43:47 <ben> and then suddenly my system froze~
06:44:21 <however> ben: linux?
06:44:30 <ben> yeah
06:44:33 <HugoDaniel> oh
06:44:53 <ben> also my touchpad stopped working at the same time
06:45:00 <ben> I do hope that's related and not the hardware finally giving out :V
06:46:30 <however> i've got the same experience. it's sad really. whenever it runs out of swap and memory you have an unusable system. half the time the only thing you can do is power-cycle. linux seems to be easy to freeze in that regard
06:46:51 <trem> ok, I don't know how to redirect stdout to a file on windows. but I can assure the rules do fire
06:46:57 <trem> s/the/that
06:47:24 <trem> s/stdout/stderr
06:47:29 <ben> however: I was able to interrupt it, but it seems like it took firefox with it. Firefox really doesn't deal with running out of system memory well, it seems.
06:47:29 <trem> :-/
06:47:31 <yaxu> hi all, here's a live recording from a performance I did with Haskell http://soundcloud.com/yaxu/live-beam-2012
06:47:44 <ben> trem: 2> doesn't work on windows?
06:48:00 <byorgey> yaxu++
06:48:19 <trem> ben, it does, I'll put it on pastebin, mompl
06:49:18 <trem> so, here are the rules for Transform.hs : http://pastebin.com/xDCU8YAH
06:49:23 <mauke> The paste xDCU8YAH has been copied to http://hpaste.org/71262
06:49:29 <barrucadu> however: The kernel *should* kill the thing that's eating all the memory
06:49:42 <scopedTV> yes i have ulimit -v 3G or something in my bash profile
06:49:55 <ben> I don't think I let it run long enough to exhaust the swap, maybe having 8G swap is a bad plan
06:50:08 <mcstar> no, the kernel should not kill it
06:50:11 <trem> i have to admit that the OOM experience on both OS X and windows is much smoother than what I had on linux.
06:50:15 <scopedTV> i have 12 G memory, quite bad really
06:50:16 <mcstar> in fact, the kernel will kill some random process
06:50:25 <scopedTV> it's not random
06:50:29 <scopedTV> err, 12 G swap*
06:50:50 <mcstar> trem: so, i was right
06:51:09 <however> barrucadu: yeah, depending on those /sys/wherever/oom-killer settings. after it exhausts every last byte of memory, which seems to be 30 mins of disk access ... :-/
06:51:10 <mcstar> does this happen when you decrese optimization level?
06:51:16 <ksf> which process gets killed isn't really random.
06:51:31 <trem> mcstar, replace O3 with O2?
06:51:42 <mcstar> O3 == O2
06:51:46 <mcstar> so make it lower
06:51:49 <scopedTV> ya try -O or -O0
06:52:11 <mcstar> anyway, i can always kill the process
06:52:12 <however> mcstar: there's some heuristic which process the oom-killing machinery is likely to nuke. you can tune it via kernel settings
06:52:34 <mcstar> just switch to a real terminal, and kill it
06:52:35 <mcstar> thats it
06:52:37 <trem> mcstar, O1 does the job, cool
06:53:23 <trem> I already reverted to project euler to satisfy my hacking needs because that project was blocked somehow. :-)
06:53:40 <mcstar> meaning?
06:53:46 <mcstar> what project?
06:54:20 * mcstar is confused
06:54:26 <trem> mcstar, i meant the raytracer which did not compile with O(>1)
06:54:36 <mcstar> i see
06:55:19 <trem> but still, the situation leaves something to be desired, doesn't it?
06:55:20 <mcstar> scopedTV: why would you need 12G swap?
06:55:32 <mcstar> trem: talk to the vendor
06:55:47 <trem> mcstar, that means the GHC bugtracker?
06:55:53 <mcstar> no, it is not a ghc bug
06:56:05 <mcstar> talk to the guy that wrote the package
06:56:10 <scopedTV> mcstar: yeah there's no good reason
06:56:18 <scopedTV> i just accepted the debian defaults, which were out of whack
06:56:34 <mcstar> scopedTV: except if you want to hibernate a loaded system of 12GB ral ram :)
06:56:37 <mcstar> real*
06:56:42 <scopedTV> I only have 4.
06:56:46 <trem> mcstar, which package? you mean the problem is in Transform.hs?
06:56:53 <mcstar> trem: yes
06:57:07 <mcstar> should i say, i suppose
06:57:19 <trem> ok, so I'm the vendor. got it. :-)
06:57:24 <however> is it really expected behavior for ghc -O2/3 to go into an infinite loop?
06:57:33 <mcstar> it didnt
06:57:51 <mcstar> i think the rules just exhausted memory
06:57:52 <scopedTV> no it's a bug.
06:57:57 <mcstar> but it can
06:58:05 * ksf has 55g swap
06:58:19 <mcstar> but still, that seems to me like the responsibility of the rule-maker
06:58:46 <ksf> ...which has more to do with existing disk partitioning than need.
06:59:45 <however> trem: here's the ghc bug tracker http://hackage.haskell.org/trac/ghc/wiki/ReportABug
06:59:46 <trem> can someone suggest me a sensible set of ghc options for FP (with Floats) heavy stuff? I can't afford the memory overhead of doubles, though they are frequently suggested for performance
06:59:58 <quicksilver> well I think it's a well known issue with RULES that they can loop
07:00:05 <quicksilver> more of a design choice than a bug
07:00:25 <mcstar> quicksilver: in this cause they werent looping indefinitely
07:00:28 <quicksilver> the "bug" is in either the system of RULES which loop (inside Data.Vec?) or, it's in GHC if GHC is doing the wrong thing.
07:00:47 <quicksilver> just too much for his memory?
07:00:57 <mcstar> http://hpaste.org/71262
07:01:02 <mcstar> take a look at it yourself
07:01:34 <quicksilver> 800 firings isn't really very many
07:01:48 <quicksilver> can't see that causing memory exhaustion all on its own
07:01:55 <quicksilver> I suspect soemthiing else is hte problem.
07:02:06 <however> i've no clue about rules, but i don't see any obvious loop in that hpaste ...
07:02:13 <quicksilver> I would definitely report it anyhow, it looks like something a developer should look at.
07:03:34 <trem> so would it be reasonable to just report the repository URL / commit hash to the bugtracker? or do they expect a smaller test case? though i doubt i can provide one...
07:04:03 <ClaudiusMaximus> yaxu++ really enjoying this
07:04:11 <quicksilver> they would rather have a smaller test case. But I think they'd rather know about the problem than not know about it.
07:04:27 <trem> quicksilver, wise answer. :-)
07:14:32 <optimight> Testing ...
07:14:59 <mcstar> wth was i listening to?
07:15:02 <copumpkin> parcs`: are you moo?
07:18:39 <jjohnsson> After having used plotList to create a plot in gnuplot from ghci, ghci no longer displays what I'm typing (without restarting ghci). Does anyone know how to fix this? It seems isolated to ghci -- gnuplot's CLI works fine, and after using ctrl+z from ghci I can see what I type again (Mac OS X 10.7).
07:21:44 <mcstar> silly question, but are you sure the terminal is the active window when you type?
07:22:35 <jjohnsson> yes. It doesn't show what I type, but when I hit enter, it shows the result of what I typed.
07:23:16 <mcstar> well, it should spawn a gnuplot process, and return right back
07:23:22 <mcstar> at least thats what it does for me
07:23:50 <Cale> jjohnsson: Try hGetEcho stdin
07:23:52 <jjohnsson> it does show the plot in X11, but then Terminal stops echoing back what I'm typing.
07:23:56 <Cale> What does it respond with?
07:24:10 <Cale> (maybe you'll have to import System.IO)
07:24:40 <jjohnsson> "True"
07:24:53 <Cale> yeah, hmm
07:24:56 <cads> hey guys, trying to deploy the wxc package, but it depends on libwxgtk2.9-dev
07:25:04 * hackagebot cpphs 1.14 - A liberalised re-implementation of cpp, the C pre-processor. (MalcolmWallace)
07:25:07 <Cale> neither of those actually affect ghci's behaviour for me
07:25:08 <cads> debian only has libwxgtk2.8-dev
07:25:21 <mcstar> jjohnsson: maybe this is some osx quirk, did this work as supposed to, before?
07:25:47 <cads> can I tell cabal to use a version of wxc that doesn't require wx widgets 2.9?
07:25:56 <however> jjohnsson: so, ghci does not display a prompt, but when you type "1+1<enter>" it displays "2"?
07:25:59 <jjohnsson> mcstar: I just cabal installed gnuplot.
07:26:05 <however> (without quotes)
07:26:12 <jjohnsson> however: exactly
07:26:19 <mcstar> oh
07:26:25 <mcstar> thats not how i understood it
07:26:43 <jjohnsson> I've tried running ghci in Terminal and in the xterm provided in X11. Same results.
07:26:49 <however> hm, that's surprising ...
07:26:56 <prototrout> cads: It looks like all versions of wxc work with 2.9 only.
07:26:58 <jjohnsson> (Terminal and X11 being Apple-provided apps)
07:27:09 <cads> hmm
07:27:17 <parcs`> copumpkin: yes
07:27:22 <jjohnsson> I guess there could be some compile-time switch that I should have set or something, when compiling gnu plot.
07:27:28 <cads> it seems like haskell might like ununtu better than debian :/
07:27:36 <prototrout> cads (see the earliest version on hackage: http://hackage.haskell.org/package/wxc-0.90 which says "This version works with wxWidgets 2.9 only.")
07:27:42 <nand`> haskell and debian don't mix very well, from my experience
07:28:00 <cads> yeah, I just learned I can find that out using cabal info wxc-0.90
07:28:40 <cads> got a professor at school that swears by the haskell-debian combination
07:29:33 <cads> but then I don't think he tries flashy graphics stuff - he uses it to beat matrices half to death
07:30:22 <however> cads: if you just get ghc by whatever means, and then install all the haskell stuff via cabal, i don't think the distro matters much
07:31:07 <nand`> the problem with haskell+debian in my experience is that haskell packages are usually very up to date; while debian's packages are usually very old - so if you try installing something you'll often come across dependencies on versions newer than what debian has in its repo
07:31:30 <cads> actually except for little hiccups like this, where haskell devs live in some future timezone separate from debian, the haskell platform experience is very pleasant here
07:32:13 <cads> nand`, yeah, it could get to be a real annoying problem :/
07:33:02 <jjohnsson> When quitting ghci by ctrl+d, after using gnuplot, the string "<stdin>: hWaitForInput: end of file" is printed before exiting, instead of "Leaving GHCi". Also, none of the history after, and including, the plotList command can be accessed after restarting ghci.
07:34:38 <mcstar> sounds to me like a readline bug
07:34:50 <mcstar> haskeline that is
07:35:05 * hackagebot aws 0.6.0 - Amazon Web Services (AWS) for Haskell (AristidBreitkreuz)
07:37:30 <mcstar> trem: i cant even build that bling, depends on too many outdated packages
07:38:27 <trem> mcstar, I just recently updated the dependecies to a level where a "cabal install" on a fresh haskell platform release "just works"
07:38:52 <mcstar> trem: i cloned it when you reported the problem
07:38:52 <trem> mcstar, what causes problems for you? i didn't touch bling in some time, and haskell is a fast moving target...
07:39:30 <trem> mcstar, the last commit (where I updated the deps) is from 5 days ago, so that's not the problem
07:39:44 <mcstar> Vec ==0.9.*,
07:40:07 <mcstar> criterion ==0.5.*,
07:40:29 <mcstar> mtl, transformers
07:40:50 <mcstar> trem: there are newer versions installed on my system
07:40:58 <mcstar> *of these packages*
07:41:30 <trem> mcstar, ok, I see, there are some. the problem is that when I bump to the latest versions of all of these, chances are that it won't work with haskell platform any more, right?
07:41:56 <mcstar> im a noob, dont ask me :)
07:42:13 <trem> mcstar, me too. together we're pro. :-D
07:42:23 <mcstar> :)
07:42:25 <hpaste> “Jonathan Fischoff” pasted “Trying to prove (or disprove) Applicative laws” at http://hpaste.org/71264
07:42:27 <jfischoff> ^ I'm trying to prove an instance satisfies the Applicative laws. This my first attempt proving an instance satisfies any laws, so I don't really know what I'm doing. I'm struggling on the composition law for Applicative.
07:43:08 <jfischoff> any help with how to prove instance laws in general or for my specific case would be appreciated
07:43:44 <c_wraith> jfischoff: the standard approach is to just use equational reasoning with your code
07:44:34 <jfischoff> c_wraith: meaning substitution? I have only an informal understand of what equational reasoning means.
07:44:41 <c_wraith> pretty much
07:45:18 <jfischoff> so basically just substitute until things are the same?
07:45:26 <c_wraith> yeah
07:46:14 <jfischoff> which is what I am trying to do…Expand all the definitions and reducing worked for the identity laws
07:46:17 <jfischoff> *law
07:47:04 <jfischoff> but I think maybe I am going down a rat hole with trying to handle the different cases for Maybe
07:49:16 <jfischoff> I also wonder if it would be easier to create my class as the composition of two Applicative instances, and then I would get a valid instance by construction.
07:49:30 <c_wraith> it basically is already
07:49:41 <c_wraith> it's basically ReaderT Maybe a
07:50:00 <c_wraith> So it *is* a valid applicative instance
07:50:07 <jfischoff> great
07:50:08 <c_wraith> The only challenge is actually proving it
07:50:12 <c_wraith> :)
07:50:13 <jfischoff> true
07:50:21 <jfischoff> which I still want as practice
07:51:08 <jjohnsson> mcstar: thanks, I'll look into that.
07:52:21 <ksf> syb appears to become more powerful the longer I use it.
07:55:40 <jfischoff> it would be nice if proofs for instances were in the doc, just so users could get a sense of the process
07:56:04 <Qrt> can i define fold over any type or i define fold for each module?
07:56:40 <jfischoff> can't really fold over a module
07:56:54 <Qrt> generics is using the same algorithm for diferent types right? what is it when you have the same function but perhaps a slightly different algorithm?
07:57:28 <jfischoff> ad-hoc polymorphism I think
07:57:30 <Qrt> fold for each each datastructure(that has its own module probably)
07:58:12 <pqmodn> Qrt: see Data.Foldable
07:58:42 <jfischoff> Qrt: ^ this is probably what you want
07:59:06 <ksf> to me, generics is mostly cutting away the crap traversals.
07:59:31 <ksf> if you want to change something deep in an AST, just say what you want transformed and syb is keeping the rest the same for you.
07:59:50 <ksf> it doesn't really have much advantages if all you have is one, shallow, type.
08:04:06 <jjohnsson> and typing ctrl+d after typing something shows what I have typed, unless I haven't typed anything: then ghci quits.
08:04:14 <jjohnsson> so close to something working. :(
08:04:53 <however> jjohnsson: is it out of the question to just start a second window with another ghci in it?
08:05:25 <ksf> ctrl+d is EOF
08:05:25 <shapr> jjohnsson: Does "echo $TERM" show xterm?
08:05:32 <jjohnsson> however: well, it might work, but I don't think it could be very interactive.
08:05:47 <ksf> that's standard behaviour for command line editors
08:06:04 <ksf> ...they figure that you can't have meant EOF if the line isn't empty.
08:06:07 <jjohnsson> shapr: "echo $TERM" shows "xterm-256color"
08:06:25 <however> ksf, he said earlier that ghci continues to evaluate things (input 1+1 produces output 2, etc.), it just doesn't show a prompt
08:06:44 <cads> hey guys, I'm installing Diagrams via cabal
08:07:12 <ksf> sounds like a fd mixup
08:07:16 <bbick> hi guys, I am trying to build hpaste and I just ran into what looks like a little error, could you advise me on how to proceed? http://hpaste.org/71265
08:07:21 <shapr> ksf: Yah, sounds like it.
08:07:29 <jjohnsson> ksf: fd?
08:07:34 <ksf> file descriptor.
08:07:42 <however> jjohnsson: source-diving into gnuplot to find out what it's doing might give clues (it might be redirecting stdin or some such)
08:07:44 <cads> i'm using the following process - I run cabal install diagrams gtk2hs-buildtools... the build runs untill it hits a missing library
08:07:48 <ksf> stdin, stdout, stderr, whatever files gnuplot uses.
08:07:53 <cads> then I apt-get the missing library
08:08:24 <jjohnsson> however: do you mean gnuplot itself or the hackage package gnu plot?
08:08:27 <cads> so far I've installed libglib2.0-dev libcairo2-dev libpango1.0-dev libgtk2.0-dev in a somewhat tedious process
08:08:37 <shapr> jjohnsson: Did the prompt only disappear after you installed gnuplot?
08:08:44 <cads> is there a better way to slurp these kinds of things?
08:09:03 <jjohnsson> shapr: only after loading the module *and* using plotLine to show a plot.
08:09:07 <however> jjohnsson: the hackage package you're using, but be prepared to have a glance at the c part too :)
08:09:27 <cads> perhaps a way to know what non-haskell libraries a cabal build will need, so I can find all of them in one go?
08:09:35 <shapr> jjohnsson: That does sound like your file handles are getting remapped, but not fixed afterwards.
08:09:47 <however> cads: isn't there some INSTALL file that describes the prerequisites? something on the homepage or .cabal description of gtk2hs?
08:10:17 <shapr> cads: If that exists, I've never been able to find it.
08:10:28 <shapr> Sure would be handy though.
08:11:09 <however> cads: http://www.haskell.org/haskellwiki/Gtk2Hs/Linux
08:11:15 <cads> the "obvious guess" does it usually
08:11:15 <jjohnsson> however: thanks, I'll try. unfortunately I'm a haskell newbie so I'm not sure that I can fix it in a reasonable amount of time.
08:11:38 <jjohnsson> shapr: thanks. I'll try to look into that.
08:12:03 <cads> however, that's awesome
08:13:18 <trem> could somone enlighten me about the "base" and "haskell98" Build-Depends entries for cabal? if I take out either, cabal reports that some module is missing and I should probably put it back in. but when both are specified, it complains about a duplicate Prelude. so?
08:14:24 <ksf> only use one of the two.
08:14:34 <ksf> ...and change the modules you import.
08:14:52 <trem> ksf, which one is recommended?
08:15:03 <however> cads: yeah, well, ideally the description field of gtk2hs-buildtools.cabal would contain that information (or a link to it)
08:15:09 <ksf> trem, depends.
08:15:14 <trem> :-)
08:15:24 <ksf> if you're writing strict haskell98 then haskell98 else the current base.
08:15:43 <ksf> depending on what versions of ghc you want to support, different versions of base.
08:16:16 <trem> ksf, so I'll try to get along with == base 4.* -- sounds reasonable?
08:17:14 <ksf> dunno, is your code compatible with all those?
08:17:38 <cads> however, it might be possible to create an OS specific library-fetching agent :)
08:17:42 <however> trem: maybe add one more digit ...
08:17:42 <ksf> there's been some rampant changes between 4.2 and 4.5
08:18:04 <ksf> you only have api-compability between the same first two digits.
08:18:27 <trem> because it's currently broken anyway, i'll stick in a 4.5 and fix what's coming up?
08:18:31 <bbick> Hi guys, I am pretty new to haskell and I dont mean to bug you with simple questions, but I just finished compiling and install the hpaste source code, but I cannot seem to find an executable anywhere to start the application
08:18:37 <ksf> trem, sounds reasonable.
08:18:43 <ksf> if someone complains, ask for patches.
08:19:01 <trem> ksf, however : thanks, i'll try it
08:19:05 <cads> however, it seems unfair to give the ubuntu/debian instructions, and leave out, eg, gentoo, arch, etc
08:19:23 <ksf> gentoo doesn't have such problems in the first place (in general)
08:19:26 <however> trem: if your goal is supporting a particular release of the platform, check what version of the base package that platform release contains ...
08:19:28 <cads> however, your name is confusing to use :D
08:19:33 <ksf> as "-dev" pakages are installed by default.
08:19:41 <cads> ksf, good point
08:19:58 <cads> gentoo - the true haskell platform?
08:20:21 <trem> however: oh, that sounds great
08:20:23 <ksf> pretty much, though I'm using 6.12.3 system-wide.
08:20:24 <however> cads, yeah, but if you know that the package is called libfoo-dev in debian, it's usually fairly easy to guess the arch linux name
08:20:41 <TK___> Dear Haskell programmers. I am new to programming. Is Haskell the right place to start?
08:20:45 <ksf> yes.
08:20:52 <Qrt> so if i import Data.Foldable it clashes with Prelude because of foldr. inthe class instance def of folder how do i write?
08:20:54 <tippenein> that is debatable
08:21:04 <Qrt> TK__: debatable
08:21:18 <Qrt> TK: Python perhaps?
08:21:18 <however> cads: yeah, well, i felt pretty clever when i chose it. i felt less clever when i realized that the irc window lights up whenever somebody says "blah blah blah however blah blah"
08:21:22 <mauke> Qrt: no
08:21:28 <dada_cetacean> what's the name for the kind of function which just a bunch of nested if operators?
08:21:52 <cads> TK___, heck I started with TI82 Basic on a graphic calculator. I don't think I really programmed till I played with ruby and haskell, though.
08:21:52 <ksf> Qrt, it's not up for debate.
08:22:06 <trem> however, what is the base version for platform 2012.2? here: http://lambda.haskell.org/platform/doc/current/index.html I see versions for most/all packages, but for base it just says "base" without a version suffix
08:22:13 <cads> and then more when I got to haskell
08:22:18 <TK___> Yea i was thinking Python as well. What kind of programs are best suited to be build by haskell and how is haskell different from other programming languages?
08:22:29 <ksf> TK___,  I'd say start with http://learnyouahaskell.com/chapters , and come back if it assumes too much
08:23:03 <ksf> TK___, http://www.haskell.org/haskellwiki/Why_Haskell_matters
08:23:12 <TK___> ksf thanks for the link. I'll check it out.
08:23:49 * cads is tempted to troll with some CT literature. But he'll be good.
08:24:00 <however> TK___: in my opinion haskell is great. in the past, i kept saying "oh i've never written anything in python/ruby/perl/..., i'll learn some python/ruby/...". since i stumbled onto haskell, i don't like to do that anymore. the other languages just feel awkward and lacking
08:24:11 <cads> good luck, TK___. It's a fun language
08:24:15 <jjohnsson> can anyone recommend a package for plotting functions/curves (2D) that can be used easily from ghci? Other than gnuplot. (I can't get gnuplot to work and don't want to put hours into making it work.)
08:24:25 <ksf> lyah doesn't assume much knowledge, but it isn't a programming introduction as such, you may need to do some exercises on the side.
08:24:50 <Qrt> TK: if you ask in haskell people are gonna say haskell. but sure start with it but dont be afraid to try python
08:25:36 <cads> and ruby
08:25:40 <ksf> learning haskell after python will be harder than the other way round.
08:26:26 <Qrt> id say python is better to learn than ruby if you dont have a specific reason to learn ruby.¨
08:26:52 <cads> ksf, otoh, learning haskell after learning universal algebra is easier than the other way aroung ;)
08:26:58 <Qrt> similar labgs, python is used in more domains i think(not just webprogramming) and on the web they are fairly equally used right?
08:27:03 <mauke> Qrt: perl is better than ruby
08:27:17 <mux> that's a bold statement
08:27:21 <hpaste> Qrt pasted “foldable” at http://hpaste.org/71266
08:27:24 <however> Qrt, TK___: imho, the problem with python and similar languages is that they are sneaky and backstabbing. they give you the impression that everything is fine, then hit you with a thousand runtime errors. it's the opposite of helpful
08:27:37 <Qrt> check my paste , how do i do with the foldr?
08:27:48 <cads> mauke, and php is better than that
08:27:54 <mauke> cads: that would be wrong
08:28:06 <Qrt> and brainfuck is better than php
08:28:10 <cads> I mean, as long as we're talking _nonsense_
08:28:14 <mauke> Qrt: debatable
08:28:21 <nsxt> VisualBasic 6?
08:29:00 <nand`> No instance for (Ord Language)
08:29:05 <nand`>   arising from a use of ‘better’
08:29:55 <nand`> Qrt: isn't that a left fold?
08:31:13 <Qrt> jes i guess
08:31:25 <Qrt> but i ahve to implement foldr, how would i do that on a linked list?
08:31:26 * hackagebot hastache 0.4.1 - Haskell implementation of Mustache templates (SergeyLymar)
08:31:34 <DMcGill> I have a value and I want to print it's constructor (but not it's values)
08:31:36 <ksf> Qrt, to remember what's what: a foldr replaces : with f
08:32:04 <ksf> in your case, Node with f
08:32:11 <DMcGill> Show doesn't help unless I attempt some sort of (init . words . show) which is a hack
08:32:19 <DMcGill> is the only thing I can do to pattern match myself?
08:32:27 <DMcGill> s/init/head
08:32:38 <ksf> (also, you can probably derive foldable)
08:34:26 <Qrt> do i always get foldl from foldr?
08:34:43 <ksf> yes
08:34:52 <ksf> @src foldl
08:34:52 <lambdabot> foldl f z []     = z
08:34:53 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:34:53 <quicksilver> DMcGill: yes, pattern match.
08:34:55 <ksf> hmm.
08:35:11 <quicksilver> DMcGill: haskell has no 'reflection' - constructors are not a first-class value which can be extracted
08:35:21 <Qrt> but anyway i get not in scope foldr from the instance declaration, why?
08:35:22 <ksf> Qrt, http://www.haskell.org/haskellwiki/Foldl_as_foldr
08:35:24 <quicksilver> there is no "getConstructor :: a -> Constructor a" type thing.
08:35:32 <trem> mcstar, I just pushed a new version to the repo which uses the latest versions of all dependecies, in case you're still interested may try it out now
08:35:43 <ksf> Qrt, because you import qualified
08:35:48 <quicksilver> there are some metaprogramming typeclasses - Data has compiler support - which have functions which do this kind of thing
08:35:54 <quicksilver> but they are very often not what you want.
08:36:16 <Qrt> ksf: yes but then how do i do?
08:36:19 <DMcGill> yeah, I don't think I'll go that far
08:36:34 <ksf> F.foldr
08:36:51 <Qrt> nope
08:37:17 <ksf> could be that qualified imports just don't work on the lhs in instance declarations
08:37:19 <quicksilver> DMcGill: very occasionally it's useful, for a data type like data T = A Int | B String | C (Int,[Int]) to build a second data type which just represents the constructors. Something like data TConstructor = TC_A | TC_B | TC_C
08:37:23 <saml> how can you make haskell easier?
08:37:25 <ksf> on the lhs in general
08:37:32 <cads> mauke, I didn't really mean `php > perl'. I was just trying to state something as shocking as 'perl > ruby' to me :)
08:37:54 <mcstar> trem: it occurred to me, you can use GT, LT operators on the dependencies, so that it will surely compile on The Platform, while possibly, with newer dependencies also
08:38:24 <Qrt> qualified name in binding position
08:38:43 <ksf> well, import unqualified.
08:39:50 <Qrt> i did
08:39:52 <cads> it seems like ruby might have perl beat as far as 'principle of least surprise goes', and in DSL coding.. don't know that you'd want to design a dsl in perl... perl on the other hand probably beats ruby in string processing and other scripty stuff
08:40:42 <hpaste> qrt pasted “folding” at http://hpaste.org/71269
08:41:14 <Qrt> also, for foldr it is f value initValue right?
08:41:15 <trem> mcstar, maybe that's a better approach for haskell projects. I have a strong maven background with it's "reproducable builds" approach where every dependecy version is fixed
08:42:28 <Qrt> can you implement length with foldr? can you override sum and length in the prelude?
08:42:38 <Qrt> override->polymorphism
08:44:20 <quicksilver> not override in the polymorphism sense, no.
08:44:29 <quicksilver> (and that's a weird kind of polymorphism)
08:44:35 <quicksilver> you can define another function with the same name
08:44:44 <quicksilver> and decide that's the one you'd rather use
08:44:50 <quicksilver> by controlling module visibility.
08:45:09 <however> qrt: you can use foldr to compute the length of a list, and it's a nice excercise to do that. you could possibly write your own functions "length" and "sum" and hide those from Prelude, although it's probably not what you meant or wanted
08:45:33 <mcstar> > let foldr = length in foldr [1..100]
08:45:34 <lambdabot>   100
08:46:01 <however> mcstar: yeah, thanks for making that clear :-)
08:46:37 <mcstar> however: i hope i didnt give much away :)
08:48:26 <Qrt> lol
08:49:44 <Taneb> Why does the name Sundaresh seem familiar?
08:50:52 <Taneb> (reading history of haskell, apparently he cowrote a paper comparing three potential systems for pure functional I/O)
08:51:01 <Qrt> mlen :: List a -> Integer
08:51:01 <Qrt> mlen = foldr (\_ y -> y + 1) 0
08:51:36 <Qrt> Sundaresh -> sounds indian -> idea -> indian food -> yes!
08:51:44 <Taneb> :)
08:52:26 <Taneb> Glad I've prevented someone from having a boring dinner
08:52:37 <eikke> Qrt: foldr (curry $ succ . snd) 0
08:53:08 <however> qrt: yup, looks good :)
08:54:15 <Taneb> Qrt, you could get a curry!
08:56:14 <Taneb> -*
08:59:36 <frigga> Is hackage down?
08:59:36 <otters> too bad you can't write an extractor function for an existentially quantified datatype
09:00:11 <HugoDaniel> argghh hackage.org :(
09:00:36 <HugoDaniel> hackage.haskell.org sorry :)
09:00:39 <HugoDaniel> yeah, seems down
09:18:22 <prototrout> frigga: Hackage seems to be back.
09:18:45 <frigga> Nice, thanks
09:44:24 * hackagebot process-conduit 0.5.0 - Conduits for processes (HideyukiTanaka)
09:49:26 * hackagebot process-conduit 0.5.0.1 - Conduits for processes (HideyukiTanaka)
09:50:53 <mcstar> ive been waiting for 0.5.0.1 for god knows how long
09:51:39 <however> mcstar: 5 minutes 2 seconds if the messages' timestamps are to be trusted
09:51:50 <mcstar> felt like an eternity
09:52:19 <parcs`> 4 minutes 37 seconds says hackage
09:53:29 <however> maybe hackagebot wakes up only once per minute or something. optimization work clearly is needed
09:54:24 * hackagebot event-list 0.1.0.2 - Event lists with relative or absolute time stamps (HenningThielemann)
09:54:47 <byorgey> cads: were you able to get diagrams to compile?
09:54:59 <byorgey> cads: feel free to ask questions in #diagrams too
09:55:01 <cads> byorgey, yep
09:55:05 <byorgey> cool
09:59:24 * hackagebot yaml 0.8.0.1 - Low-level binding to the libyaml C library. (MichaelSnoyman)
09:59:26 * hackagebot yaml 0.7.0.4 - Low-level binding to the libyaml C library. (MichaelSnoyman)
09:59:37 <mcstar> im wondering if its possible to plot continuously with gnuplot
09:59:58 <cads> byorgey, looking forward to playing around with it
10:00:01 <mcstar> or at least when i have new data update the plto
10:00:07 <byorgey> cads: =)
10:00:08 <Baughn> mcstar: Is redoing the plot on every update a big issue?
10:00:30 <mcstar> Baughn: can i keep the same window?
10:00:51 <Baughn> mcstar: I think so. Though I should note, this is #haskell, and I haven't used gnuplot in years.
10:01:07 <mcstar> Baughn: im talking about the haskell gnuplot binding
10:01:47 <mcstar> i dont see immediately a way to hold on to a previous window
10:02:51 <Baughn> mcstar: Some more documentation would be good, but I think maybe Gnuplot.Terminal.X11.persist?
10:03:17 <cads> byorgey, I'd like to visualize a classifcation scheme for billiard balls trajectories in the regular hexagon, which will involve a little group theory and an extension of the field of rational numbers
10:03:39 <mcstar> Baughn: could be, thanks
10:04:43 <byorgey> cads: oooh, sounds awesome!
10:17:00 <daniel_-> if i wanted to implement an REST api for my app how would i do that? spawn a subprocess with webserver mainloop and run it there talking over pipes? or just fork a thread?
10:17:31 <daniel_-> and what webserver could you recommend for a simple rest api over json?
10:18:51 <srhb> daniel_-: Fork is so easy, but you won't be tied down whatever method you choose.
10:19:58 <however> daniel_-: forking child processes is popular, at least on unix. in haskell, threads are very cheap and of course well-isolated, so that's probably the most straightforward way
10:20:32 <however> s/on unix/when using c on unix
10:20:58 <srhb> Yeah, forkIO is a blessing.
10:21:46 <saml> daniel_-, warp  or snap?
10:22:08 <saml> you just want to get json as request body, do stuff and respond with json?
10:22:15 <daniel_-> i dont know, since im not very familiar with either of them or haskell for that matter
10:22:24 <HugoDaniel> happstack then
10:22:29 <saml> why do you want to do that in haskell?
10:22:39 <HugoDaniel> saml: why not ?
10:22:40 <daniel_-> since i want to learn :)
10:22:51 <saml> node.js is webscale and php and python
10:22:51 <HugoDaniel> great json parser, amazing webservers with very good performance :)
10:22:59 <srhb> Haskell is a perfectly good choice for the subject.
10:23:00 <HugoDaniel> oh
10:23:04 <srhb> Haha. Webscale. :-)
10:23:15 <HugoDaniel> node.js ?!
10:23:36 <daniel_-> and i've already written a game server dispatcher, creates cs1.6 servers and connects to pipes, so people can write !timeleft ingame and se how long time they have left on their serverbooking and other nice commands :)
10:23:46 <SegFaultAX|work2> Did someone really just drop "webscale"?
10:23:47 <zeiris> Arbitrary string key-value storage is webscale.
10:23:47 <srhb> daniel_-: Neat. :)
10:23:48 <Philippa> saml: you mean, it can create the kinds of clusterfucks only web companies seem to manage?
10:23:57 <srhb> daniel_-: forkIO and try Warp, it seems to be the standard right now.
10:24:03 <srhb> SegFaultAXIndeed, so funny :P
10:24:20 <srhb> PHP is webscale, fsvo...
10:24:36 <SegFaultAX|work2> C++ is webscale.
10:24:42 <HugoDaniel> i thought php was dead :P
10:24:50 <srhb> HugoDaniel: It's still webscale!
10:24:57 <HugoDaniel> webscaledead
10:25:06 <SegFaultAX|work2> Oh snap.
10:25:15 <srhb> @faq Can Haskell do webscale?
10:25:15 <lambdabot> The answer is: Yes! Haskell can do that.
10:25:20 <srhb> NICE!
10:25:32 <HugoDaniel> the idea of parsing a whole php file in each request is also a very good shit idea
10:25:36 <daniel_-> only feels like if i use warp i might have to learn conduits aswell xD
10:26:15 <frigga> Snap has better support for file uploads.
10:26:22 <HugoDaniel> then people wonder "why is my python code so freaking slow?"
10:26:48 <HugoDaniel> or why is this php page so darn slow with only 10 people on the server ?
10:27:01 <HugoDaniel> and the next phase of denial is "thats probably the database"
10:27:06 <srhb> webscale = TRUE in php.ini
10:27:13 <srhb> People often forget.
10:27:20 <HugoDaniel> yeah
10:27:28 <saml> haskell is so hard for me. i tried to make a web app. ended up staring at the cursor for hours
10:27:38 <SegFaultAX|work2> srhb: Oh, that's how I turn on webscale? TIL.
10:27:41 <HugoDaniel> people like parsing whole php files in each request and blamming the database for the poor performance
10:27:42 <srhb> saml: It is a bit hard to get started because it's so different. :)
10:27:58 <mightybyte> Ooh ooh, is this a node bashing party?
10:28:07 <srhb> mightybyte: Join in, we're having a party.
10:28:07 <HugoDaniel> :D
10:28:12 <HugoDaniel> mightybyte: join !
10:28:17 <HugoDaniel> node.js is pure shit
10:28:18 <saml> srhb, can you make it easier?
10:28:20 <HugoDaniel> there i've said it
10:28:24 <mightybyte> lol
10:28:34 <srhb> saml: Well, hanging around here really is good. I've moved very far in a few months, I feel. :)
10:28:48 <HugoDaniel> i can speak for all #haskell, node.js is shit, there... go write blog posts about how #haskell people think node.js is shit
10:28:50 <srhb> saml: And I've learned techniques I never knew in any language before.
10:28:52 <HugoDaniel> and commonjs also shit
10:29:07 <mightybyte> s/common//
10:29:14 <HugoDaniel> :D
10:29:17 <daniel_-> i cant fathom why people would like to write even more javascript than required
10:29:19 <SegFaultAX|work2> HugoDaniel: Ted Dziuba already did that for us.
10:29:26 <ksf> "hey our language is not expressive enough to write legible code let's write inlegible instead" <-- node.js in a nutshell
10:29:29 <saml> how would you represent a gate with labeled input and outputs?
10:29:49 <ksf> saml, that's a great question.
10:30:08 <ksf> you could have a look at grapefruit, and its records.
10:30:13 <HugoDaniel> it should be renamed to node.jSHIT
10:30:24 <saml> thanks ksf
10:31:42 <daniel_-> what is the haskellers goto logging lib?
10:32:47 <srhb> hslogger maybe? I haven't used it.
10:33:02 <mcstar> node.js is very fast
10:33:13 <srhb> fsvo.
10:33:28 <mcstar> @google fsvo
10:33:31 <lambdabot> http://www.urbandictionary.com/define.php?term=FSVO
10:33:31 <lambdabot> Title: Urban Dictionary: FSVO
10:33:36 <srhb> for some value of..
10:33:51 <mcstar> http://julialang.org/
10:33:58 <mcstar> look at the microbenchmarks
10:34:32 <srhb> node.js can serve fibs very fast?
10:35:11 <mcstar> thats aint a webserver benchmark
10:35:24 <srhb> No, so I see. Hence my question.
10:35:37 <jfischoff> "i don't like this air but that doesn't mean i'll stop breathing it" is how I feel about most web programming tech, including node
10:36:12 <k00mi> v8 is very fast, and thus node is
10:36:28 <srhb> Compared to php, everything is damn fast.
10:36:34 <c_wraith> not ruby
10:36:41 <c_wraith> holy crap, rails is slow in comparison to php
10:36:43 <srhb> Point.
10:36:48 <jfischoff> @quote ruby
10:36:49 <lambdabot> kmc says: you see a lot of Rubyists who associate static typing with C++ lunacy or Java's kingdom of nouns, and thus refuse on principle to have any idea what their programs do before they run
10:36:49 <lambdabot> them
10:37:18 <srhb> @quote node.js
10:37:18 <lambdabot> No quotes match. Do you think like you type?
10:37:20 <srhb> aw.
10:37:39 <zephyrtronium> i think dynamically :c
10:37:58 <srhb> zephyrtronium: First step towards recovery is realization.
10:38:06 <srhb> zephyrtronium: Hang in there. :-)
10:38:54 <daniel_-> @quote python
10:38:54 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
10:39:26 <c_wraith> wow.  Cale is running some old code for lambdabot
10:39:44 <c_wraith> @quote .*python
10:39:44 <lambdabot> saml says: <saml> how can i convert python file to haskell? <mauke> by piping it through a programmer
10:40:01 <saml> haskelll is so yolo
10:40:46 <SegFaultAX|work2> Yolo? Webscale? Seriously?
10:41:16 <Qrt> is there a clas for map like there if Foldabale for foldr?
10:41:17 <raymank26> hi all. I have some type [(String, Maybe String)]. How can I use putStrLn for printing fst and value of snd of this type?
10:41:35 <c_wraith> Qrt: that's what Functor is for
10:41:53 <c_wraith> Qrt: or maybe Traversible, if you need more generality
10:42:48 <mm_freak> is there a way to install only the haddock documentation of a package?  alternatively is there a way to make cabal-dev generate an index file?
10:43:00 <mm_freak> local documentation is extremely inconvenient with cabal-dev
10:43:28 <c_wraith> mm_freak: if you have the package unpacked, you can use "cabal haddock".  Not sure if you don't
10:44:02 <mm_freak> that's gonna be extremely inconvenient for hundreds of packages
10:44:12 <jfischoff> cabal-dev seems to over write the index with the last install. Not sure if that is expected or not, but is annoying
10:44:18 <Qrt> can i stop functions from being usable outside of a module?
10:44:23 <byorgey> raymank26: you need to write a function of type  (String, Maybe String) -> String  which formats it the way you want
10:44:24 <daniel_-> > let a = ("hello", Just "world"); putStrLn $ fst a ++ " " + fromJust snd a
10:44:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:44:29 <daniel_-> wops
10:44:32 <mm_freak> i think i'll just go back to regular cabal-install
10:44:36 <byorgey> raymank26: then use putStrLn to print out that string
10:44:37 <c_wraith> Qrt: yes. You need to put an explicit export list in your module
10:44:38 <SegFaultAX|work2> Qrt: Don't export them from your module.
10:44:39 <daniel_-> > let a = ("hello", Just "world"); putStrLn $ fst a ++ " " ++ (fromJust (snd a))
10:44:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:44:58 <byorgey> explicitly using fst, snd, and fromJust is not the best style though.
10:45:01 <daniel_-> ah nvm but i guess you should use case expression
10:45:09 <c_wraith> Qrt: which looks like:  module Foo (export1, export2, ...) where ...
10:45:11 <mroman> > do{let a = ("hello", Just "world"); putStrLn $ fst a ++ " " ++ (fromJust (snd a))
10:45:13 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:45:24 <mroman> > do{let a = ("hello", Just "world"); putStrLn $ fst a ++ " " ++ (fromJust (snd a)); }
10:45:27 <lambdabot>   <no location info>: parse error on input `;'
10:45:29 <byorgey> formatPair (str, Nothing) = ...;  formatPair (str1, Just str2) = ...
10:45:32 <mroman> ah
10:45:42 <mroman> that's that annoying let bug in {} syntax
10:45:48 <raymank26> byorgey: no problem. But some oneliner will be a good point. My solution is so huge =(
10:46:10 <byorgey> raymank26: did you see what I wrote just above?  formatPair etc.
10:46:20 <raymank26> oh.. one second
10:47:01 <raymank26> :t id
10:47:02 <lambdabot> forall a. a -> a
10:47:07 <raymank26> :t fromJust
10:47:08 <lambdabot> forall a. Maybe a -> a
10:47:21 <raymank26> nice. thanks =)
10:47:31 <Qrt> since you can derive foldl and sum from foldr, wouldnt you also be able to derive size ? I guess it could lead to some ambigousness?
10:48:38 <byorgey> raymank26: nono, do not use fromJust!
10:48:42 <byorgey> > fromJust Nothing
10:48:43 <lambdabot>   *Exception: Maybe.fromJust: Nothing
10:48:46 <byorgey> arrrghh
10:48:53 <srhb> Qrt: Length?
10:48:55 <Qrt> foldr (\_ y -> y + 1) 0 vs  foldr (curry $ succ . snd) 0 // isnt the first one clearer? and speed/mem is the smae?
10:49:02 <Qrt> s/smae/same
10:49:06 <byorgey> raymank26: you need to deal with the case where it could be Nothing
10:50:00 <Qrt> srhb: length isnt derived...
10:50:01 <raymank26> byorgey: yes =( I have already read
10:50:15 <srhb> Qrt: I meant, did you mean length instead of size, or what?
10:52:09 <kallisti> so let's say I make a bounded lattice library
10:52:21 <kallisti> am I bad person if I made bottom = undefined  by default. :P
10:53:21 <Qrt> srhb: yes size as in length although length isnt necessarily a good word for it generally...like length of tree then size is better
10:53:44 <raymank26> byorgey: thanks again. Very nice solution for me.
10:54:14 <srhb> Qrt: Ah, fine. Well, obviously you can derive length from foldr, but foldr cannot necessarily work on your tree structure, and explicitly not if it is encoded as a list (which it should not be) - or am I misunderstanding you?
10:55:05 <Qrt> i meant couldnt it be auto-derived from foldr?
10:55:08 <Qrt> as sum is
10:57:04 <srhb> How is sum auto-derived from foldr?
10:57:06 <srhb> @src sum
10:57:07 <lambdabot> sum = foldl (+) 0
10:57:44 <ppilate> you can also do it with foldr, since (+) is commutative
10:57:51 <ppilate> also, shouldn't it be foldl'?
10:58:26 <otters> no
10:58:31 <otters> 0 is the initial quantity
10:58:35 <srhb> I think it is actually defined recursively in the Prelude.
10:58:44 <srhb> I mean, explicitly.
10:59:47 <srhb> otters: Huh? Did you read foldl1?
10:59:58 <otters> srhb: I sure did
11:00:00 <otters> my bad
11:01:26 <otters> why does it need to be foldl' though?
11:02:46 <Qrt> ' meaqns strict eval right?
11:03:01 <srhb> It's the strict left fold, yes.
11:03:30 <Qrt> is Foldable a type class? is there Mapable?
11:03:32 <hughfdjackson> ' is just part of an identifier; you can postfix ' to any undeclared identifier
11:03:49 <hughfdjackson> so 'means' might be a bit strong ^^
11:04:10 * hughfdjackson waits for his unhaskelly terminology to be corrected :D
11:05:20 <srhb> hughfdjackson: Nothing wrong there, I think. ;)
11:05:45 <srhb> @src foldl'
11:05:45 <lambdabot> foldl' f a []     = a
11:05:45 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:05:54 <ppilate> foldl' uses tail recursion
11:06:00 <byorgey> Qrt: yes, Foldable is a type class.  "mappable" is called Functor.
11:06:01 <ppilate> so it doesnt crash on huge lists
11:06:24 <kkyqqp> what's the best way to get bind to feed to an argument that isn't the last one of a function? for example, to make this work: print . f randomgen $ otherarguments =<< getStdGen
11:06:26 <hughfdjackson> srhb: :D that's a first
11:06:53 <byorgey> ppilate: the reason it doesn't stack overflow isn't tail recursion, it's the extra strictness (the call to `seq`)
11:06:55 <srhb> ppilate: Where's the tail recursion?
11:07:30 <srhb> Or rather, in comparison to foldl.
11:07:51 <byorgey> foldl' *is* actually tail recursive in every sense that matters.
11:08:00 <srhb> But so is foldl
11:08:05 <byorgey> indeed.
11:08:16 <Qrt> what should curry get as input ? i know the type but f from tuple to val and then to other vals?
11:08:23 <Qrt> @src curry
11:08:23 <lambdabot> curry f x y = f (x, y)
11:08:33 <Qrt> :t curry
11:08:34 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:08:38 <ppilate> @src fold
11:08:38 <lambdabot> Source not found. stty: unknown mode: doofus
11:08:41 <ppilate> @src foldl
11:08:41 <lambdabot> foldl f z []     = z
11:08:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:09:15 <byorgey> kkyqqp: use an explicit lambda in order to give the argument a name, so it can be used later
11:09:21 <srhb> Qrt: Given a function that takes two arguments, it produces a function that takes a 2-tuple as argument
11:09:28 * hackagebot errors 1.1.1 - Simplified error-handling (GabrielGonzalez)
11:09:38 <srhb> Qrt: (Roughly speaking, of course, there can be more arguments involved)
11:09:46 <kkyqqp> byorgey: oh, right! thanks
11:09:53 <andares> loll
11:10:00 <ppilate> srhb: argh, of course, s/tail recursive/strict/
11:10:04 <ppilate> sorry for that
11:16:01 <mm_freak> this is weird…  all those edwardk packages have suddenly jumped to version 3.0 causing me quite some headache in dependency hell
11:16:12 <mm_freak> bifunctors, profunctors, comonad, …
11:16:28 <saml> typesystem doesn't help there?
11:17:41 <Qrt> i forgot how to use hackage from the terminal
11:17:45 <c_wraith> the package system is outside of the type system
11:17:51 <MostAwesomeDude> @hoogle Functor f => (a -> b -> b) -> a -> f b -> f b
11:17:52 <lambdabot> Data.IntMap adjustWithKey :: (Key -> a -> a) -> Key -> IntMap a -> IntMap a
11:17:52 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:17:52 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:17:57 <Qrt> something update?
11:18:04 <MostAwesomeDude> Bleh.
11:18:37 <illissius-> mm_freak: afaik he did a big refactor in comonad, and then had to adapt basically every other package and decided to unify the version numbers along the way.
11:18:44 <c_wraith> MostAwesomeDude: what you want is liftA2 - fundamentally, you need Applicative for that
11:18:45 <Peaker> I auto-derive Binary instances for my data model. Sometimes I change the datatypes and therefore the store's format.  It would be nice if I had a derived schema or hash that could tell me the derived instances or serialized types are not the same as they were previously
11:18:56 <mm_freak> illissius-: yeah, i read the commit message
11:19:06 <mm_freak> but it's causing everything else to fail, most notably data-lens
11:19:18 <c_wraith> MostAwesomeDude: wait, nevermind, I misread your type signature
11:19:24 <Qrt> does quickcheck come witht he haskell platform?
11:19:36 <Peaker> I wanted to use the "Copointed" and "Pointed" classes, but then I saw that the "pointed" package depends on about a dozen other much more complicated packages and gave up on using it :(
11:19:38 <c_wraith> :t \f x y -> fmap (f x) y
11:19:39 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (t -> a -> b) -> t -> f a -> f b
11:20:02 <geekosaur> Qrt, yes
11:20:12 <mm_freak> Qrt: if you installed the haskell platform, just type:  cabal list --installed
11:20:19 <mm_freak> that gives you an overview of all installed packages
11:20:31 <MostAwesomeDude> c_wraith: Yeah, but I realized that I'm specialized for Maybe anyway, so I have to just eat it.
11:20:58 <c_wraith> @pl \f x y -> fmap (f x) y
11:20:58 <lambdabot> (fmap .)
11:21:09 <c_wraith> hmm.  that's not terrible
11:21:14 <c_wraith> only slightly opaque :)
11:21:35 <mm_freak> Peaker: pointed isn't that bad…  learn about semigroups and semigroupoids
11:21:47 <mm_freak> actually you don't even have to know them
11:21:53 <Peaker> mm_freak, what about them? I just thought that a pointed package shouldn't depend on so much
11:22:07 <Peaker> mm_freak, I don't want to add dependency hell for a tiny class and some trivial instances
11:22:32 <mm_freak> Peaker: i'm sure the dependencies are for the instances, not the classes
11:22:39 <Peaker> I think the way the package dependencies there are constructed is probably backwards.. comonad package should probably depend on [co]pointed, not the other way around
11:23:03 <MostAwesomeDude> :t fmap .
11:23:04 <lambdabot> parse error (possibly incorrect indentation)
11:23:12 <MostAwesomeDude> :t (fmap .)
11:23:12 <mm_freak> Peaker: indeed…  you can use pointed entirely disregarding the dependencies
11:23:14 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
11:23:29 <Peaker> mm_freak, I can't do that in my cabal package
11:23:58 <illissius-> it would be great if you didn't have to depend on a package just to provide an instance.
11:24:24 <mm_freak> Peaker: the dependencies are really lightweight…  almost every edwardk package depends on them
11:24:37 <mm_freak> and they are pretty closed
11:24:55 <parcs`> i wonder why the GHC.Generic data types don't have a Generic instance themselves
11:25:16 <illissius-> parcs`: I've wondered that too!
11:25:23 <mm_freak> Peaker: also if you use data-lens or comonad, you have them installed anyway =)
11:25:55 <mm_freak> i think you can't do much productive development without having them installed nowadays…  every larger project pulls them in indirectly
11:26:00 <mm_freak> including snap, yesod, etc.
11:26:11 <parcs`> deriving instance Generic (K1 i c p) ==> ghc: panic! (the 'impossible' happened) :)
11:27:11 <parcs`> works in ghc head though
11:29:40 <Peaker> mm_freak, I don't want to add these dependencies to bottle just for Pointed/Copointed classes, though
11:29:54 <Peaker> mm_freak, and again, it seems really backwards for the simple base class package (pointed) to depend on the complex subclass package (comonad and friends)
11:30:22 <mm_freak> Peaker: of course you can always go back to category-extras ;)
11:31:00 <Qrt> data List a = Empty | Node a (List a)
11:31:00 <Qrt>               deriving (Eq, Show)
11:31:08 <Qrt> i cant use QuickCheck to test that?
11:31:24 <Peaker> so, anyone know of a nice way to generate a "schema" alongside the derived Binary/Serialize instances of a set of data-types?
11:31:31 <Qrt> Expecting an ordinary type, but found a type of kind * -> *
11:32:10 <jfischoff> Qrt: you need to special it for a particular a, but that shouldn't cause any problems
11:32:22 <mm_freak> Peaker: like acid-state?
11:32:46 <Peaker> possibly, I don't know what acid-state does
11:33:00 <Qrt> isnt QuickCheck importable as a Module?
11:33:09 <mm_freak> Peaker: well, as its name says…  it basically turns a data type into a database on disk
11:33:19 <mm_freak> with the usual DBMS-like ACID properties
11:34:15 <geekosaur> Qrt, http://hackage.haskell.org/package/QuickCheck
11:34:35 <geekosaur> the package is QuickCheck, the module space is Test.QuickCheck.*
11:38:56 <ksf> Peaker, isn't the adt you derive it from a schema?
11:47:33 <hpaste> “Max S.” pasted “Error!” at http://hpaste.org/71276
11:47:50 <cads> Hey guys, I just posted that
11:48:32 <cads> so I have a prelude in both base and haskell98
11:48:54 <cads> can I disable one of them?
11:48:56 <monochrom> probably INblobs.cabal needs to be updated
11:50:09 <monochrom> I think take away haskell98
11:51:13 <cads> will the appropriate cabal file be somewhere in my ~/.cabal hierarchy, or will I download things somewhere else?
11:52:03 <monochrom> "cabal unpack INblobs" "cd INblobs-0.1.1" edit INblobs.cabal "cabal install"
11:53:36 <xcvii> hey, what do you reckon would be a simple way to write a function that purely transform the textual representation of some haskell function into a string containing external core?
11:53:49 <xcvii> i figured http://hpaste.org/71277, but it also runs the code which i don't want
11:53:59 <xcvii> it to
11:54:32 <Peaker> mm_freak, I don't want to turn a single data type into one big disk thing -- it will mean stuff needs to fit in memory
11:54:41 <Peaker> mm_freak, I have a set of data types with inter-links between them
11:54:54 <Peaker> mm_freak, which basically form a large graph in the database
11:55:03 <Peaker> (and only a tiny part of the graph is in-memory at any given time)
11:58:30 <Enigmagic> Peaker: what do you mean by schema?
11:58:57 <hpaste> cads annotated “Error!” with “Error! (annotation)” at http://hpaste.org/71276#a71279
11:59:14 <cads> monochrom, ^ that is what I get if I remove '98
11:59:59 <hpaste> cads annotated “Error!” with “Error! (annotation) (annotation)” at http://hpaste.org/71276#a71280
12:00:05 <cads> but if I remove base, I get that
12:01:53 <monochrom> I would say, stick with base, edit *.hs files from "import Monad" to "import Control.Monad"
12:01:53 <cads> it's relying on the monad module in haskell98, and System.Exit in base
12:02:57 <monochrom> I mean, clearly, s/Monad/Control.Monad/ is easier and more robust than trying to figure out how to avoid System.Exit
12:03:33 <alanz> cads: you need to remove haskell98, then change the source to import to be Control.Monad, as per the new base
12:03:49 <cads> aye
12:04:34 * hackagebot split-channel 0.1.2.0 - Control.Concurrent.Chan split into sending and receiving halves. (LeonSmith)
12:04:36 * hackagebot hlint 1.8.30 - Source code suggestions (NeilMitchell)
12:07:11 <Peaker> Enigmagic, basically the low-level serialization format/data types
12:07:36 <Peaker> Enigmagic, if I changed the serialized data types in my database, it'd become incompatible and fail to deserialize
12:08:14 <Qrt> a
12:10:07 <Qrt> http://hpaste.org/71281
12:10:30 <Qrt> though i posted to #haskell but i guess not so there^^ it is. what do i need to do?(quickcheck issue)
12:11:09 <shachaf> Qrt: Quickcheck can't just generate values for arbitrary types.
12:11:22 <shachaf> It can only generate values for Arbitrary types. If you take my meaning.
12:11:45 <shachaf> I.e., you need to tell it how to generate random lists by making List an instance of Arbitrary.
12:11:57 <Qrt> ok
12:12:02 <Enigmagic> Peaker: we use protocol buffers for that. i've been toying around with making a version that uses Generics instead of a .proto file to define the schema: http://breaks.for.alienz.org/blog/2012/05/20/generics-and-protocol-buffers/
12:12:18 <Qrt> i though something was magical and shoudlnt work
12:13:24 <___d> is anybody familar with control-monad-exception? I'm trying to figure out if the design of unchecked exceptions is "right".
12:13:33 <Peaker> Enigmagic, cool, thanks, I wonder if it useful for a key/value store serialization scheme
12:14:09 <Enigmagic> Peaker: Riak (a key value store written in Erlang) uses it for precisely that purpose
12:15:06 <Peaker> Enigmagic, I want to serialize on top of a k/v store, not the k/v store itself
12:15:19 <Peaker> (i.e: my serialized values stored as values in the k/v store)
12:15:27 <jfischoff> Qrt: I you get stuck, I wrote an instance for you
12:15:43 <Enigmagic> Peaker: yeah, that's what it does. the values (and i think keys) are protocol buffers messages.
12:15:46 <Peaker> and one of the things I serialize is an "IRef a" which is a key wrapper type that uses the "a" as a phantom type (evidence that the key has an "a" in it)
12:16:08 <jfischoff> Qrt: you might need to return if the size is zero though
12:21:15 <jfischoff> Is there way to pass arguments to Test.Framework defaultMainWithArgs to control which tests are run and which ones are not?
12:21:42 <alanz> cads: are you succeeding on INBlobs? I am trying to build it, and finding similar problems to when I updated Blobs
12:22:49 <cads> alanz, I'm not really a whiz when it comes to this stuff.. I'm going to try using sed to rename instances of Monad, but I have no idea if it'll work
12:22:50 <Qrt> jfischoff: can you give it to me?
12:23:05 <jfischoff> Qrt: I updated your hpaste
12:25:25 <jfischoff> Qrt: I made a small here http://hpaste.org/edit/71281
12:25:38 <mmaruseacph2> mersi
12:25:39 <jfischoff> Qrt: if you have questions let me know
12:25:45 <mmaruseacph2> sorry, wrong window
12:27:09 <alanz> cads: There are two of those, and also List must become Data.List
12:27:26 <alanz> cads: And a bunch of other things
12:28:30 <EvanR> is there a doubly linked list package
12:28:48 <ciaranm> why would you want a doubly linked list?
12:28:56 <EvanR> i wouldnt
12:28:58 <DMcGill> if not, it'd be super easy to make one yourself
12:29:00 <EvanR> just curious
12:29:04 * EvanR listens to DMcGill 
12:29:13 <DMcGill> although zippers could be similar
12:29:42 <otters> a list is basically a linked list
12:29:46 <hpaste> qtr annotated “quickcheck” with “quickcheck (annotation)” at http://hpaste.org/71281#a71285
12:29:53 <Qrt> http://hpaste.org/71281
12:29:54 <otters> [], anyway
12:29:54 <DMcGill> after all isn't DList a = DList {left :: [a], centre :: a, right :: [a]} very similar
12:30:13 <DMcGill> [] is a singly linked list
12:30:21 <byorgey> creating a doubly-linked-list structure in memory using knot-tying is a fun exercise.
12:30:28 <otters> knot tying
12:30:30 <otters> what is that
12:30:40 <Peaker> ciaranm, a doubly-linked list has some nice algorithmic uses/properties
12:30:43 <byorgey> but it will be a read-only list.
12:30:44 <DMcGill> http://www.haskell.org/haskellwiki/Tying_the_Knot
12:31:05 <DMcGill> indeed the top example on that is a doubly-linked list
12:31:19 <EvanR> this sounds interesting
12:31:24 <EvanR> heard of it but never bothered to read
12:31:30 <otters> oh
12:31:39 <otters> I kinda get it but I'm watching LOTR right now
12:31:46 <monochrom> zipper seems like more useful than doubly linked list for immutable list
12:31:54 <hpaste> qrt annotated “quickcheck” with “quickcheck (annotation)” at http://hpaste.org/71281#a71286
12:32:38 <DMcGill> writing game of life on an infinite plane implemented with a zipper was interesting
12:32:59 <Qrt> oops
12:33:00 <EvanR> what was performance like ;)
12:33:02 <monochrom> oh, that sounds fun
12:33:02 <DMcGill> much better than finite arrays or lists of lists too
12:33:06 <DMcGill> no idea, didn't check!
12:33:28 <DMcGill> much worse than a finite (looping) array but better than [[a]] I would imagine
12:33:52 <EvanR> mumbles something about a Map of arrays
12:34:08 <jfischoff> qrt: just remove that line
12:35:03 <jfischoff> Qrt: ^
12:35:36 <Qrt> what line?
12:35:59 <jfischoff> Qrt: when (size == 0) $ return Empty
12:36:00 <Qrt> when...? then it compiles , lets see
12:36:16 <jfischoff> :t when
12:36:18 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:36:23 <jfischoff> oops
12:36:55 <mcstar> Baughn: i couldnt update the plot window with the gnuplot binding, instead im piping data directly to a gnuplot process, its not bad
12:37:55 <hpaste> qrt annotated “quickcheck” with “quickcheck (annotation)” at http://hpaste.org/71281#a71287
12:39:50 <osa1> I have a syntax tree created with GADTs and I'm trying to write unit tests for parser that generates syntax tree, is there an easy way to derive Eq on GADTs or should I manually write it?
12:40:46 <mcstar> i think im going to use ocaml for these numerical stuff
12:41:01 <mcstar> i wish haskell werent so beautiful
12:42:55 <Cale> mcstar: What problems are you having getting it done in Haskell?
12:43:19 <mcstar> not problems per say
12:43:28 <mcstar> i just have to do it all in IO
12:43:38 <Cale> hmm
12:43:42 <zzing_> Is it possible for my application to run as root and then change to a specific user in the same way that a webserver might?
12:43:43 <lambdabot> zzing_: You have 1 new message. '/msg lambdabot @messages' to read it.
12:43:50 <Cale> I'm unconvinced that's actually true, but I'll brb :)
12:44:25 <jfischoff> mcstar: why all in IO?
12:44:48 <mcstar> i have to update an array in-place
12:44:54 <mcstar> thats why
12:44:56 <jfischoff> ST?
12:45:11 <jfischoff> I think it was for that
12:45:19 <geekosaur> zzing_, http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.5.1.1/System-Posix-User.html#g:5
12:45:54 <Cale> mcstar: Is the problem something like the array is larger than half the available memory or something? :)
12:46:00 <zzing_> merci
12:46:10 <Qrt> is a class like an interface(kind of)? defines the type of a method belonging to the class?
12:46:21 <mcstar> Cale: no
12:46:36 <mcstar> quite small actually
12:46:44 <geekosaur> Qrt, do not think of typeclasses as OO, it will just cause problems
12:46:46 <mcstar> http://i.imgur.com/mwdhc.png
12:46:52 <cesc> hi! coming from Fortran, I was wondering what's the most convenient way to perform matrix multiplication in Haskell? In this link http://www.haskell.org/pipermail/haskell-cafe/2011-January/088268.html  they suggest a one liner for a given example:  [foldl (+) 0 $ zipWith (*) x y | x <- m1, y <- transpose m2]        What type are m1 and m2? And, what I've still haven't been able to figure out, how does one read numerical data from columns
12:46:52 <cesc> in ascii files? Any tips/guidelines will be greatly appreciated. In the meantime, I'll follow with the "real world haskell" book. (the learning curve is steep, but I hope it pays off in the long run)
12:47:33 <Philippa> Qrt: they're like interfaces in that they tell you something is (reliably) true about some type. Or perhaps some tuple of types, as in multi-parameter typeclasses. And that something includes some operations you can perform involving those types.
12:47:44 <mcstar> those are most probably [[a]]
12:47:59 <EvanR> cesc: use a matrix lib!
12:48:01 <Cale> mcstar: Hmm, okay... that looks small enough that UArrays or something would be fine.
12:48:13 <cesc> mcstar: oh, I see
12:48:44 <Cale> mcstar: Have you tried writing it in an immutable way?
12:48:52 <saml> do you get merge conflicts in haskell, too? or people don't really collaborate in a large team?
12:48:58 <cesc> EvanR: sure, I just wanted to implement something similar as a little exercise to see whether I can conveniently read in data from ascii files. I usually work with numerical data stored by columns in ascii files
12:49:09 <Qrt> what would be the easiest way to paste to hpaste with a haskell program? what packages?
12:49:24 <EvanR> cesc: words . lines ;)
12:49:30 <mroman> probably network-http
12:49:32 <mcstar> Cale: to throw away a whole vector for an update in 1 place?
12:49:34 <EvanR> :t words . lines
12:49:35 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
12:49:36 <lambdabot>       Expected type: String -> String
12:49:36 <lambdabot>       Inferred type: String -> [String]
12:49:43 <Cale> cesc: Probably for matrices, you'd want to use arrays rather than lists, because otherwise you end up doing lots of transpositions which are not exactly cheap (though you can do that if you don't care about performance)
12:49:48 <EvanR> :t map words . lines
12:49:50 <lambdabot> String -> [[String]]
12:49:54 <EvanR> cesc: ^
12:50:07 <cesc> EvanR: oh, thx.  I'm aware of those (in a n00b sense) :)
12:50:10 <mcstar> cesc: there is a GSL binding
12:50:11 <sm> Qrt: the gist package does it for github, if that helps
12:50:12 <cesc> Cale: ah! shit, I haven't read about arrays yet.
12:50:44 <mroman> Qrt: There are curl bindings too
12:50:48 <EvanR> meh arrays
12:50:58 <Cale> mcstar: What function are you computing? :)
12:51:01 <mcstar> and blas ofc
12:51:11 <mcstar> Cale: what function?
12:51:11 <mroman> @hoogle curlPost
12:51:12 <lambdabot> No results found
12:51:21 <cesc> performance is actually of some concern =) I want to (try to) convince myself that Haskell can keep up with Fortran speed for number crunching.
12:51:24 <mroman> @hoogle curl
12:51:25 <Cale> mcstar: Perhaps there's a way to group a bunch of these one-element updates together so as to do many at the same time?
12:51:25 <lambdabot> package curl
12:51:25 <lambdabot> package download-curl
12:51:25 <lambdabot> package hxt-curl
12:51:38 <cesc> EvanR: why meh? :)
12:51:42 <Cale> mcstar: Is there a more uniform way to describe what's happening?
12:52:02 <EvanR> cesc: to me the haskell interface to arrays is clunky
12:52:11 <EvanR> its not like C
12:52:13 <Cale> I really like the Haskell interface to arrays.
12:52:19 <Cale> Ix is a great idea
12:52:20 <cesc> LOL!
12:52:29 <EvanR> yeah i get it now
12:52:30 <mcstar> Cale: you pick a lattice site, and depending on the values of the nbors, you probabilitically change the value of the site
12:52:46 <EvanR> probabilitically
12:52:49 <Cale> mcstar: Is the matrix boolean?
12:52:52 <mcstar> EvanR: shut up
12:52:58 <Cale> or lattice, rather
12:53:04 <cesc> damn, there should be a haskell tutorial for people coming from fortran :)
12:53:04 <EvanR> no i just appropriated that word for my own purposes
12:53:05 <mcstar> Cale: could be, yeah
12:53:07 <EvanR> i love the internet
12:53:08 <jfischoff> cesc: Its unlikely that Haskell will not keep up with Fortran for straightforward numeric calculations.
12:53:19 <jfischoff> s /will not/will
12:53:22 <mcstar> Cale: easier if its -1, 1 valued
12:53:43 <Cale> If you stored this in a UArray of Bool, then it'll be bit-packed
12:54:21 <Cale> which would make it probably cheap enough that updating one element wouldn't be so bad. Another option for fast updates would be to use a Data.Map, since there are not so many keys here anyway.
12:54:23 <cesc> jfischoff: oh :(  well, for now all I can say is that it's taking quite a lot of thinking to even attempt to write a function. In fortran I was good to go after a few tutorial pages.  But I'm not giving up yet. I want to take Haskell for a spin.
12:54:23 <EvanR> is that because of UArray magic?
12:54:58 <Cale> EvanR: Pretty much. UArray's representation for Boolean elements uses bit fields.
12:54:58 <mcstar> Cale: id like to know, what happens when you update an immutable array/vector? are there any guarantees, that the GC wont delete it, and the update will be in-place?
12:55:14 <Cale> The update will never be in-place
12:55:24 <mcstar> under the hood
12:55:24 <Cale> but if the array is compact enough, maybe that doesn't matter
12:55:44 <EvanR> Cale: oh so it doesnt look at arbitrary data structure of Int, Double, nullary constructors, etc
12:55:46 <mcstar> yeah, well, i dont want that, so that brings us back to IO
12:55:54 <Cale> Have you tried it?
12:56:05 <Cale> Make sure that it's actually a real performance issue first
12:56:09 <Cale> by profiling
12:56:25 <mcstar> the cost of the update is minimal
12:56:31 <Cale> and *then* say oh, maybe I'd better thaw/freeze this thing or use ST or something like that :)
12:56:36 <mcstar> so yes, the runtie will be gc dominated
12:56:57 <mcstar> Cale: why would ST be better than IO?
12:57:10 <jfischoff> cesc: There are two parts to getting something the fast. The first part involves get the algorithm correct, and without bugs. Haskell will help with that. The next part involves optimizing hotspots. Again, Haskell will help because you can focus your time on the parts that are slow.
12:57:26 <Cale> Well, ST, you could wrap up your algorithm into a pure function
12:57:39 <Cale> given that this thing doesn't actually involve any IO
12:57:39 <mcstar> and afaik thaw/freez is not an option, since this isnt some initializatin problem, the update takes place the whole runtime
12:58:09 <Cale> okay...
12:58:20 <Cale> can I see your program? I want to try Data.Map :D
12:58:23 <Qrt> how do you read from stdin?
12:58:37 <otters> getLine
12:58:42 <cesc> jfischoff: sure. So far, once I have gotten a function to compile, it works right away. It just takes some readjusting from the approach I have taken so far. I guess I'll eventually manage .D
12:58:44 <Cale> Qrt: getLine, getContents
12:59:01 <mcstar> Cale: a tree instead of an array?
12:59:02 <mcstar> how?
12:59:12 <Cale> mcstar: Map (Int,Int) Bool
12:59:14 <mcstar> (in this particular example i dont see how)
12:59:14 <Cale> or whatever
12:59:20 <mcstar> ah
12:59:51 <Cale> It might seem a bit wasteful, but it's generally not so bad :)
13:00:43 <hpaste> mcstar pasted “ising” at http://hpaste.org/71288
13:02:25 <Qrt> otters: from commandline. i start a program and it needs to fatch a filename from stdin
13:02:37 <otters> getline should do it
13:03:07 <DMcGill> see also getArgs
13:04:58 <Qrt> how do i say to ghc that Haskpaste.hs is main?
13:05:39 <mcstar> a file cant be main
13:06:18 <hpc> man ghc, search for --main-is
13:06:49 <monochrom> normally, "ghc Haskpaste.hs" already says that main is inside Haskpaste.hs
13:07:06 <hpc> monochrom: think you need --make
13:07:18 <hpc> to get that magic, at least
13:07:21 <monochrom> unless you put a "module Haskpaste" line inside
13:07:26 <hpc> oh yes, that
13:07:38 <monochrom> these days --main is implicit
13:07:50 <monochrom> err, these days --make is implicit
13:08:01 <Qrt> ghc --make haskpaste.hs
13:08:06 <hpc> cool
13:08:09 <monochrom> but even back then, --make was not always necessary
13:09:07 <Qrt> but i dont get an exe
13:09:17 <Qrt> and how would i post to hpaste with haskell?
13:09:40 <mcstar> Cale: for my example, what do you think haskell offers above ocaml? (except bindings/packages)?
13:11:12 <monochrom> I don't understand the question. don't you just copy and paste?
13:11:27 <Qrt> automatically, with a program
13:11:39 <Qrt> like i do M-x hp in emacs and it pastes for me¨
13:12:04 <Cale> mcstar: Well, I don't know. I think if you can get a referentially transparent specification of what this simulation is doing, that's probably progress over mutable update in any language.
13:16:17 <Qrt> so how do i create an exe?`
13:16:43 <Cale> Qrt: by running  ghc --make myfile.hs
13:16:55 <mauke> --make is default
13:16:56 <Cale> (--make might not be required on newer versions of ghc)
13:17:12 <monochrom> works for me
13:17:51 <Cale> Yeah, it's default in 7.4.x at least, I'm unsure about anything before that
13:18:06 <monochrom> since 7.0
13:18:10 <Cale> (well, I'm sure it's not default in 6.x)
13:18:12 <Cale> ah, cool
13:18:14 <Qrt> yeah i removed module Blah where
13:18:31 <Qrt> so what lib can i paste with? like open a website and do a post?
13:18:31 <Cale> Qrt: yeah, the main module doesn't need a module declaration
13:19:02 <Cale> Qrt: the HTTP library will do that sort of thing
13:19:28 <Qrt> isnt there some sort of --| style comment?
13:19:29 <Cale> Network.Browser
13:19:56 <Cale> two hyphens followed by a non-symbol character
13:20:01 <mauke> > x --| y
13:20:02 <lambdabot>   Not in scope: `--|'
13:20:10 <Cale> starts a comment to end of line
13:20:22 <mauke> > x --- y
13:20:25 <lambdabot>   x
13:21:07 <Cale> (you can have infix operators containing two hyphens though, so usually just follow up the -- with a space and you're fine)
13:21:44 <mauke> --+(?![[:punct:]])
13:22:24 <Taneb> Hugs seems to have died?
13:22:40 <monochrom> although that begs the question of whether [:punct:] equals what unicode says about puncts
13:22:42 <ciaranm> hugs still exists?
13:22:51 <hpc> hugs is beyond old
13:22:51 <mauke> Rob D - Hugged to Death
13:22:55 <Taneb> Not since 2006, according to their news page
13:22:55 <ciaranm> monochrom: no it doesn't. it raises the question.
13:23:15 <mauke> ciaranm++
13:23:24 <mauke> I could care less
13:23:29 <hpc> Qrt: "-- |" is a haddock notation
13:23:33 <Cale> I couldn't
13:23:41 <hpc> Qrt: basically, if an infix symbol lexes to "--", it's a line commen
13:23:42 <hpc> t
13:23:44 <Taneb> Cale, unless he actually can care less
13:24:02 <Cale> I assume that's what he means, because that's what he said ;)
13:24:09 <Taneb> :)
13:24:24 <Taneb> Is GHC the only actively developed Haskell compiler now?
13:24:36 <hpc> Taneb: there's another, iirc
13:24:40 <hpc> YHC or something
13:24:40 <monochrom> jhc
13:24:40 <mauke> Cale: I like the cut of your jib
13:24:48 <ciaranm> isn't there an llvm haskell now?
13:24:54 <hpc> ciaranm: -fllvm
13:25:32 <Taneb> Yeah, JHC
13:25:33 <Taneb> Hmm
13:26:59 <hpaste> qrt pasted “arbitrary quickcheck” at http://hpaste.org/71289
13:27:07 <Cale> Taneb: GHC has LLVM support
13:27:18 <Qrt> can someone have a look? i dont understand what i ahev to do...
13:27:26 <Taneb> ^ ciaranm
13:27:31 <applicative> Qrt: http://hpaste.codepad.org/P13qNaYT pasted itself.
13:27:40 <ciaranm> also, llvm is a stupid name
13:27:45 <hpaste> qrt annotated “arbitrary quickcheck” with “arbitrary quickcheck (annotation)” at http://hpaste.org/71289#a71290
13:27:57 <hpc> ciaranm: low level virtual machine
13:27:57 <Qrt> check the last one
13:27:57 <Cale> Qrt: delete the module declaration from LinkedListTest
13:28:09 <ciaranm> hpc: indeed, but that's not what it is any more
13:28:12 <hpc> but yeah, at first i thought it was like LL the grammar
13:28:22 <Qrt> still same error, just running that in ghci anyway
13:28:40 <Cale> Qrt: generally you want the main module to be called Main, and the file it's in doesn't have to be called Main.hs, but can be named the same as what you want to call the binary
13:28:50 <Cale> oh, missed the error message
13:29:49 <Cale> Qrt: errr, weird. Are you sure it's loading the right LinkedList.hs and that everything is saved to disk?
13:30:54 <hpaste> alanz annotated “Error!” with “Error! (annotation)” at http://hpaste.org/71276#a71291
13:32:48 <Qrt> Cale: yes i had my dropbox file open before but im sure it is the C/ file now
13:32:48 <otters> @help
13:32:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:32:53 <otters> @list
13:32:54 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:33:18 <otters> @check (a - b) == (b - a)
13:33:20 <lambdabot>   "Falsifiable, after 0 tests:\n"
13:33:54 <mroman> @check reverse a == reverse . reverse . reverse $ a
13:33:56 <lambdabot>   Couldn't match expected type `[a]'
13:34:06 <Qrt> ok works when i compile
13:34:33 <mroman> @check (reverse a) == (reverse . reverse . reverse $ a)
13:34:35 <lambdabot>   Couldn't match expected type `[a]'
13:35:44 <Qrt> how would you test append with quickCheck?
13:36:52 <shachaf> Figure out what properties you want it to have, write tests for those properties.
13:37:10 <Cale> prop_assocAppend xs ys zs = append (append xs ys) zs == append xs (append ys zs)
13:37:14 <DMcGill> transitivity and identity for example
13:37:38 <Cale> prop_leftIdentityAppend xs = append Empty xs == xs
13:37:39 <DMcGill> associativity of course
13:37:46 <DMcGill> oops
13:37:46 <Cale> prop_rightIdentityAppend xs = append xs Empty == xs
13:38:08 <Cale> oh, your append isn't append though
13:38:11 <Cale> it's cons
13:38:34 <Cale> I guess you do things like this:
13:38:54 <Cale> prop_firstAppend x xs = first (append x xs) == x
13:39:01 <Cale> prop_firstAppend x xs = first (append x xs) == Just x
13:39:03 <Cale> rather :)
13:39:11 <DMcGill> prop_consEq x xs = (x:xs) == (append x xs) if you feel like cheating
13:39:21 <Taneb> isBottom :: a -> Bool; isBottom x = error "Nice try, buster"
13:39:31 <Cale> prop_removeFirstAppend x xs = removeFirst (append x xs) == xs
13:39:44 <shachaf> Taneb: You can do better than that.
13:39:46 <DMcGill> isBottom = error "True"
13:39:51 <Cale> DMcGill: Well, it's cons, but for a different datatype
13:40:15 <shachaf> Your isBottom _ = _|_; but you can say isBottom !x = False, such that isBottom _|_ = _|_; isBottom _ = False
13:40:34 <Cale> Qrt: does that make sense?
13:41:09 <Taneb> shachaf, I think my point was that a working isBottom function that works in finite time is mathematically impossible
13:41:43 <ciaranm> oh i don't know, image processing libraries are getting pretty good nowadays
13:41:44 <shachaf> prop_consEq x xs = (x : fromList xs) == fromList (append x xs)
13:41:48 <Cale> Qrt: We're saying that if we add x to xs, then the list won't be empty and will have first element x, and secondly if we remove the first element after adding x to xs, we get xs back again
13:42:01 <DMcGill> isInfiniteList :: [a] -> Bool
13:42:06 <ciaranm> with an appropriate machine learning algorithm and lots of data, i reckon you could recognise bottoms fairly reliably
13:42:26 <Taneb> Fuzzily, and with mistakes
13:43:01 <ciaranm> you have a fuzzy bottom?
13:43:09 <Taneb> :P
13:44:08 <imphasing> does type M a = Int -> (a, Int) mean that M a is a type that accepts an a and returns a tuple of type (a, Int) or does the comma mean something else magical in a type definition? :/
13:44:31 <shachaf> imphasing: It means a tuple.
13:44:32 <opqdonut> it means that
13:44:37 <imphasing> Okay, thanks
13:44:37 <mcstar> Cale: so, is there anything else? (im off)
13:46:18 <Cale> mcstar: My machine is too un-set-up at the moment (just "upgraded" os in order to get 64 bit, and nothing is installed). I think there should be a pretty way to write this using Maps though.
13:46:53 <mcstar> Cale: maybe ill give that a try some day
13:47:18 <mcstar> k, bb
13:50:55 <Qrt> Cale: what i dont get is how haskll generates the tests, im not supposed to pass any values am I?
13:51:03 <ciaranm> MAGIC
13:51:21 <Cale> Qrt: Arbitrary instances give random generators for various types of parameters
13:51:58 <Cale> Qrt: quickCheck will use the Arbitrary instances to generate random values for the parameters to the function you give it and do repeated tests to try to see if it can find any case where the property fails
13:52:36 <Cale> Qrt: You *can* pass values to the properties, if you want to make unit tests from them.
13:52:56 <Cale> Qrt: but usually you don't, you let the quickCheck function do that for you
13:53:21 <EvanR> functional programs are easier to test
13:53:28 <EvanR> statically typed programs are easier to test
13:53:32 <jfischoff> do most people here write tests?
13:53:46 <EvanR> i test in ghci
13:53:47 <Cale> Sometimes
13:53:51 <Taneb> jfischoff, I write type-correct programs and pray
13:54:02 <otters> I write untestable programs
13:54:04 <ciaranm> if it passes the type checker it's correct
13:54:13 <Cale> Depends on how I'm feeling about the code that I've written. A lot of code is just obviously correct-if-it-compiles
13:54:16 <ciaranm> testing proves nothing!
13:54:26 * jfischoff wonders if writes too many tests
13:54:30 <osfameron> it proves that the only bugs you have are the ones you don't know about
13:54:35 <EvanR> if it compiles its good, if it boots up its perfect
13:54:58 <Cale> Writing QuickCheck tests are a great way to force yourself to think about the algebraic relationships between the things that you've written though.
13:55:09 <EvanR> only use safeFromJust
13:55:13 <Cale> If your QC tests are ugly, your library might be poorly designed. :)
13:55:17 <Qrt> i see
13:55:31 <Taneb> EvanR, isn't safeFromJust id?
13:55:32 <Qrt> but this could be done in any lang right?
13:55:34 <jfischoff> it definitely gives me piece of mind, but unit tests are also a pain to maintain
13:55:38 <Cale> Qrt: Kinda
13:55:40 <EvanR> Taneb: a very safe function
13:55:44 <Taneb> Indeed
13:55:48 <Taneb> The safest
13:55:50 <Qrt> i mean without being hard. just generates test cases randomly to test properties?
13:56:10 <Cale> Qrt: Haskell's typeclasses make it possible to automatically generate values of the right types. In most programming languages, you'd end up being forced to say which generators to use at least.
13:56:18 <Cale> Yeah
13:56:32 <EvanR> Qrt: sure if you are just testing pure functions
13:56:32 <Cale> There's actually some more stuff that QC does once it finds a failing case
13:56:38 <alanz> Shouldn't QuickCheck tests also state and check invariants about the code?
13:56:39 <Qrt> but in haskell propertybased testing is perhaps more sufficient than in python were you dont have static typechecking and purity?
13:56:49 <Taneb> From someone who made a factorial calculator with 12 unsafeCoerces
13:56:58 <Cale> It starts shrinking the inputs in various ways and seeing if it can construct a simpler test which still fails.
13:57:00 <EvanR> write more pure functions in python / php / javascript
13:57:13 <Taneb> Pure functions in brainfuck
13:57:21 <ciaranm> a good type system gives you the equivalent of something like fifteen unit tests per line of code for free
13:57:22 <EvanR> malbolge
13:58:40 <EvanR> note the kind of things cause dynamic programs to crash, unhandled cases, wrong return types, wrong argument types, random NULLs which somehow work until a random time later then fail
13:58:50 <Mortchek> bf doesn't even have local variables, is it even possible to guarantee purity?
13:59:15 <otters> bf doesn't even have variables
13:59:16 <jfischoff> I tend to try to separate my code into the parts that are bidirectional and not, since being a isomorphism is a great invariant to test
13:59:39 <Mortchek> It has global state, which is what I was implying as the opposite of local variables
13:59:47 <jfischoff> but I feel like I need to learn how to use polymorphism more to advantage, and test less
13:59:53 * hackagebot stm-conduit 0.4.2 - Introduces conduits to channels, and promotes using  conduits concurrently. (ClarkGaebel)
14:00:42 <Mortchek> I should have "doesn't have local state"
14:00:45 <Mortchek> +said
14:01:19 <EvanR> what does local state even mean
14:02:18 <Qrt> can quickCheck gen functions? no i assume? like f :: Int -> Int
14:02:25 <Cale> EvanR: I think I might have a fairly general answer to that question, but it's insane
14:02:26 <c_wraith> EvanR: It means it's scoped - the state doesn't escape from some context, and you can have multiple copies
14:02:35 <Cale> Qrt: yes it can
14:02:37 <c_wraith> Qrt: actually, it can - but it's crazy
14:02:42 <Cale> Qrt: That's what coarbitrary is for
14:02:53 <Mortchek> Actually what I just said is wrong too. I'm not thinking about the actual problem properly. :P
14:02:55 <Cale> It's not *that* crazy once you understand how it works :)
14:03:03 <Cale> :t coarbitrary
14:03:05 <lambdabot> forall a c. (CoArbitrary a) => a -> Gen c -> Gen c
14:03:11 <EvanR> c_wraith: if its not visible from the outside, seems like its stateless
14:03:43 <c_wraith> EvanR: local state is always an implementation detail.
14:03:44 <otters> :instance CoArbitrary
14:03:49 <otters> @instances CoArbitrary
14:03:50 <lambdabot> Couldn't find class `CoArbitrary'. Try @instances-importing
14:03:50 <otters> whoops
14:03:52 <Cale> Basically, the idea is that coarbitrary gives a way to tweak an arbitrary random generator based on an input value of type a
14:04:27 <Cale> So the randomised function can use coarbitrary to make its output depend in some way on its input.
14:05:53 <EvanR> are conduits, pipes, and iteratees all basically the same?
14:07:05 <applicative> no
14:07:46 * applicative notes that pipes arent even basically the same as pipes anymore
14:07:55 <c_wraith> They all have the same basic goal, at the very very high level.  Their mechanisms differ significantly
14:08:03 <EvanR> k
14:09:25 <jfischoff> is there a difference between pipes and pipes-core?
14:10:00 <applicative> yes, more and more
14:10:16 <jfischoff> can anyone summarize the differences?
14:10:26 <jfischoff> between cond/pipes/pipes-core
14:10:37 <shachaf> I should make a package called pipe-score
14:11:01 <Qrt> damn if i defined a Foldable and import that file qualified, how do i access foldr?
14:11:13 <otters> lenz-family
14:11:14 <Qrt> Also is there Mapable? What other normal *able are there?
14:11:27 * applicative hasnt yet managed to comprehend the new pipes/frames so he's speechless
14:11:27 <Cale> Qrt: import qualified Data.Foldable as F
14:11:33 <Cale> and then use F.foldr
14:11:38 <Cale> Qrt: That's called Functor
14:11:47 <Cale> class Functor f where
14:11:53 <Cale>   fmap :: (a -> b) -> f a -> f b
14:12:04 <geekosaur> Mapable is actually two concepts, Functor and Traversable
14:13:07 <shachaf> Functor is a much nicer concept, though.
14:13:13 <aristid> shapr: i ended up just sending a long email to a few people who i think use the package btw :)
14:13:21 <applicative> jfischoff: the original pipes  0.1 documentation might be a pretty good guide to whats up with pipes-core and in a way conduit.
14:13:46 <jfischoff> applicative: so pipes is moving a way from the other two?
14:13:50 <applicative> jfischoff: I mean the recent pipe-ish conduit
14:14:21 <shapr> aristid: What about a blog post that you submit to reddit?
14:14:48 <applicative> jfischoff: it is still extremely experimental, I think it must be said. The newer versions are much more complex, but maybe it's just that I haven't had the patience to study them
14:15:05 <aristid> shapr: i don't have a blog, but I guess I could make a self-reddit (once I find my reddit account credentials)
14:15:08 <Qrt> so quickcheck for java, there is soemthing like that. sure you can have static methods in java but most things in java are stateful. but i guess you can still use something like quickcheck for that...?
14:15:31 <jfischoff> applicative: I still need a reason to use them
14:15:46 <applicative> jfischoff: I mean the pipes library is very experimental. It's extremely interesting though.
14:15:57 * jfischoff nods
14:15:59 <applicative> jfischoff: its when you get tired of curiosities of lazy io
14:16:30 <jfischoff> applicative: for my purposes lazy io is working fine
14:17:17 <applicative> jfischoff: lazy io is awesome.
14:17:26 <jfischoff> :)
14:17:42 <applicative> though many will tell you 'its a lie' , that they'd rather write php than use it, etc
14:19:05 <applicative> @quote salt
14:19:05 <lambdabot> quicksilver says: I would rather saw off my own legs with a wooden spoon soaked in salt water than use lazy IO
14:19:28 <applicative> ^^ no fool, this  quicksilver :)
14:20:12 <watermind> is there any name for transversals with an accumulator, the likes of fold' ?
14:20:36 <jfischoff> watermind: Foldable?
14:20:36 <MostAwesomeDude> You mean, Traversable?
14:20:56 <watermind> jfischoff:  folds / catamorphisms are different
14:21:00 <Cale> Do you mean foldAccumL etc?
14:21:11 <watermind> MostAwesomeDude: maybe I have to check
14:21:15 <Cale> watermind: or do you mean real catamorphisms?
14:21:38 <Cale> For catamorphisms, you need to do something funky like expressing your type in terms of an explicit fixed point
14:21:41 <jfischoff> watermind: woah you went all precise on me
14:21:42 <applicative> left folds
14:22:08 <watermind> Cale: well catamorphisms are what we informally designate as folds
14:22:26 <aristid> shapr: http://www.reddit.com/r/haskell/comments/wemoc/aws_package_might_require_ghc_74_in_the_future/ :)
14:22:47 <Cale> watermind: yes, but Foldable isn't quite the same thing, which confuses the matter
14:22:52 <watermind> Wait sorry
14:22:57 <watermind> I said fold'
14:23:01 <watermind> I meant foldl
14:23:03 <Cale> (Foldable should have been called Listable)
14:23:16 <applicative> yes, that was clear watermind
14:23:18 <watermind> ok
14:23:42 <watermind> Cale: Foldable isn't the same as catamorphisms?
14:23:46 <Cale> right
14:23:51 <watermind> OK
14:24:19 <Cale> Foldable is more or less those types which can be converted to lists in a canonical way
14:24:33 <watermind> right
14:24:41 <applicative> it seems clear that there is an idea of a 'fold' for a recursive datatype that left folds don't really meet. But I wonder if they have a name
14:25:14 <shapr> aristid: yay!
14:25:17 <Cale> Catamorphisms in general would act by taking parameters which are replacements for the constructors of your datatype, and recursively replacing the data constructors in a structure with whatever values were provided
14:25:25 <Cale> But it's hard to capture that in a typeclass
14:25:26 <watermind> Cale: also note, I'm not so much looking for the name of a class, but the name of a particular method of a particular class...
14:25:36 <Peaker> I wish there was a utility to find dead code (under a closed-world assumption)
14:25:46 <watermind> although  of course we'd still need a class anyway
14:25:54 <Cale> However, it could be done using associated types I suppose!
14:26:02 <Peaker> (i.e: which export list symbols are never used in a certain project)
14:26:23 <watermind> also it doesn't even have to be implemented anywhere I'm just wondering if there is a name for the concept
14:26:29 <watermind> just like there is the name catamorphios
14:26:32 <watermind> catamorphism
14:27:03 <watermind> and like there is the (generalized) notion of fold
14:27:42 <Cale> I would just call it a left fold
14:27:56 <watermind> Cale: that's weird if you have a tree
14:28:07 <Cale> Well, what would foldl do on a tree?
14:28:07 <popl> cata- means down
14:28:26 * nand` wonders if a generalized left fold would have multiple ‘base cases’, similar to how the generalized right fold's folding function can accept many parameters
14:28:32 <MostAwesomeDude> Are we thinking of paramorphisms?
14:28:32 <Qrt> anyone having exmaples usign Network.Browser?
14:28:45 <watermind> Cale: transverse the tree using an accumulator
14:28:49 <Cale> Really what foldl is, is the catamorphism on snoc lists.
14:28:53 <shapr> Qrt: Maybe manatee-browser? Not that I have any idea myself.
14:29:10 <watermind> Cale: for instance how should you sum all the elements of a tree?
14:29:32 <watermind> MostAwesomeDude: I don't think so, those operate the 'head' with the whole structure rather than the tail
14:29:46 <Cale> watermind: well, there are a lot of ways, what with (+) being both associative and commutative :)
14:30:01 <hpaste> qrt pasted “correct foldr?” at http://hpaste.org/71294
14:30:31 <watermind> Cale: yes true, I'm not implying they should be unique for each structure, just like you can define more than one fold (catamorphism) for trees
14:30:34 <Cale> If you were working with Floats, you may want to preserve the association implied by the tree, which would limit your options to just the tree catamorphism
14:30:43 <Cale> (pretty much)
14:31:10 <Cale> Qrt: that's foldl
14:31:11 <watermind> Cale: yes right, I see what you mean
14:31:30 <Cale> Qrt: you want foldr f z (Node x xs) = f x (foldr f z xs)
14:31:37 <watermind> Cale: you do have a point, there is no 'natural' way to define this on a tree
14:32:05 <Cale> watermind: and for every tree traversal, you can use foldr or foldl or foldl' on the resulting list
14:32:45 <Cale> (I'd usually just use the list foldl' on a traversal if I wanted to accumulate things in a strict way over a tree structure)
14:33:37 <watermind> Cale: indeed but neither of that is really an issue. For clarity my question could be rephrased as, is there a name for the composition of foldl with a flattening operation?
14:33:50 <Cale> not as such
14:33:51 <watermind> Cale: and of course there can be multiple flattenings for each structure
14:34:03 <Cale> probably I'd just call it foldl again, but put it in another module
14:34:05 <watermind> right
14:35:35 <watermind> right now I didn't want in order to define some class/method, it's just so I'd know what to call it when talking about it
14:35:47 <zzing_> Is there any reason why the function at 46 of https://github.com/iaefai/got-it/blob/master/src/Site.hs   would not be able to drop privileges if the whole thing was run under sudo?
14:35:56 <watermind> I always say, recursion with accumulator, transversal with accumulator...
14:36:08 <watermind> always wondered if there was a proper term
14:36:25 <EvanR> traverse, transverse
14:36:30 <EvanR> coinsidence?
14:37:16 <watermind> opss
14:37:51 <EvanR> > topic
14:37:52 <lambdabot>   Not in scope: `topic'
14:37:56 <EvanR> shucks
14:37:56 <jfischoff> watermind: in Foldable, it would be foldMap or fold. The Applicative with Effects paper called them reductions, but not as a formal name
14:38:30 <EvanR> reduce in js, inject somehow in ruby
14:38:32 <watermind> jfischoff: are you sure? it would be really weird if fold corresponded to foldl on lists
14:39:03 <solrize> how normal is it for -N2 to slow down a program by 2x?
14:39:06 <jfischoff> :t fold
14:39:07 <lambdabot> Not in scope: `fold'
14:39:17 <jfischoff> its different then foldl
14:39:25 <jfischoff> fold :: Monoid m => t m -> m
14:39:45 <watermind> jfischoff: but I'm asking for the generalizations of foldl, not fold
14:39:57 <solrize> what's an example of t m ?
14:40:17 <solrize> i first thought that signature looked like msum
14:40:40 <solrize> :t msum
14:40:41 <jfischoff> solrize: Foldable
14:40:42 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
14:40:50 <Cale> :t mconcat
14:40:52 <lambdabot> forall a. (Monoid a) => [a] -> a
14:41:04 <solrize> yeah, mconcat is what i meant
14:41:19 <EvanR> :t mconcat
14:41:20 <lambdabot> forall a. (Monoid a) => [a] -> a
14:41:43 <EvanR> @google fold
14:41:44 <Cale> Set is Foldable
14:41:45 <lambdabot> http://en.wikipedia.org/wiki/Fold_(higher-order_function)
14:41:45 <lambdabot> Title: Fold (higher-order function) - Wikipedia, the free encyclopedia
14:41:47 <EvanR> @hoogle fold
14:41:48 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
14:41:48 <lambdabot> Data.List foldl :: (a -> b -> a) -> a -> [b] -> a
14:41:48 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
14:41:53 <Cale> (Ix i) => Array i
14:42:06 <jfischoff> :t Sum
14:42:07 <Cale> Map k
14:42:08 <lambdabot>     Ambiguous occurrence `Sum'
14:42:08 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
14:42:08 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
14:42:13 <Cale> Maybe
14:42:37 <Cale> Basically anything which can be traversed into a list can have an instance of Foldable
14:47:44 <jfischoff> Cale: do you have a similar test for Traversable?
14:50:13 <Qrt> was my foldr correct?
14:51:56 <Cale> Qrt: did you miss my comment that you'd written foldl?
14:52:37 <Qrt> yes
14:52:52 <Qrt> its not foldl either becuase of arg order
14:53:16 <Cale> yeah, not exactly
14:53:39 <Qrt> so i thought it was foldr
14:53:50 <Qrt> i dont understand foldr i suppose
14:53:56 <Qrt> but i know how to really implement foldl
14:53:59 <Qrt> @src foldr
14:54:00 <lambdabot> foldr f z []     = z
14:54:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:56:52 <squidz> I am taking a algorithms and datastructures course at university now and noticed it all seems to be very OOP-oriented. Could some algorithms/datastructures vary in importance with haskell/functional programming in mind?
14:57:27 <SegFaultAX|work2> squidz: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
14:57:45 <SegFaultAX|work2> squidz: Or if you prefer a real book: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
14:58:51 <shapr> squidz: very much so
14:59:20 <Qrt> @src foldr
14:59:20 <lambdabot> foldr f z []     = z
14:59:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:59:22 <squidz> could it be that functional paradigms 'do it better'
14:59:29 <shapr> I also like Rabhi&LaPalme's "Algorithms : A Purely Functional Programming Approach"
15:00:23 <squidz> since there is apparent multi-core advantages to functional programming, could that be taken advantage of in algorithms, or is that usually happening higher level?
15:00:50 <watermind> shapr: that and Richard Bird's book are my favouritesd
15:01:02 <Qrt> @src foldl
15:01:02 <lambdabot> foldl f z []     = z
15:01:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:01:13 <eikke> anyone knows what causes "Unacceptable result type in foreign declaration"  ?
15:01:16 <SegFaultAX|work2> squidz: I think you answered your own question in your question.
15:01:18 <squidz> watermind: richard birds book?
15:01:35 <shapr> squidz: Yes, you can take advantage of multi-core speedups, but the algorithm must be written with that in mind, and it must be an algorithm that can be parallelized.
15:01:38 <stephenjudkins> squidz: FP doesn't offer any kind of magic that makes "multi-core" easier to take advantage of
15:01:49 <Qrt> weird thing is the wrong implementation of foldr passes this:prop_foldr xs = foldr (-) 0 xs == (F.foldr (-) 0 $ L.insertFrom xs L.Empty) in quicktest where as the right one doesnt
15:01:53 <c_wraith> eikke: Either you chose a type the FFI doesn't know about, or it's old code that depended on a bug that let it not import the definitions of those types
15:02:07 <shapr> stephenjudkins: Although STM is the larval form of that mythical magic :-)
15:02:09 <stephenjudkins> squidz: fact that FP algorithms are referentially transparent is what makes them much easier to parallelize
15:02:09 <eikke> c_wraith: trying to pass a custom newtype around Ptr
15:02:13 <Qrt> @src foldr
15:02:14 <lambdabot> foldr f z []     = z
15:02:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:02:14 <watermind> squidz: http://www.amazon.co.uk/Introduction-Functional-Programming-Prentice-Hall-Computer/dp/0134843460/ref=sr_1_1?ie=UTF8&qid=1342044104&sr=8-1
15:02:30 <c_wraith> eikke: yeah, you can't use newtypes in the foreign declaration.
15:02:53 <stephenjudkins> squidz: basically read up about race conditions and the problems of mutable shared state
15:02:57 <eikke> seriously?! why's that
15:03:15 <stephenjudkins> then realized that these problems disappear for purely functional algorithms
15:03:23 <stephenjudkins> man, I can't type today.
15:03:38 * shapr kickstarts a better keyboard for stephenjudkins
15:04:12 <shapr> Though seriously, sometimes I want to put up a kickstarter project to buy srsly awesome hardware for the Simons :-)
15:04:32 <shapr> Like, buy 'em a 64-bit ARM desktop as soon as they're purchasable...
15:04:53 <zachk> what makes ARM so amazing?
15:04:54 <shapr> stephenjudkins: Do you think STM counts as larval multi-core magic? :-)
15:05:04 <squidz> stephenjudkins: thanks, that's exactly what I was looking for
15:05:25 <stephenjudkins> shapr: i believe STM will probably always be too slow to be practical
15:05:39 <shapr> stephenjudkins: Hm, how so?
15:05:51 <squidz> STM?
15:05:57 <shapr> software transactional memory
15:05:59 <stephenjudkins> i mean, it might be useful, but i doubt it will be faster or easier than just having single thread transforming state
15:06:21 <shapr> squidz: In a nutshell, STM is optimistic database-style locking for program state.
15:06:42 <squidz> optimistic?
15:06:46 <shapr> stephenjudkins: I dunno, the fact that STM programs are safely compositional is the big killer feature.
15:07:09 <stephenjudkins> if you have a state of type a, you can either have a single queue of a -> a (that may farm out work to other cores)
15:07:24 <shapr> squidz: Yah, you have a bunch of cores, if your state is split into chunks you can spawn off threads that do work on a chunk, then when they get back, they check to see if any other thread changed that chunk of state in the meantime.
15:07:33 <stephenjudkins> or you can do the STM dog-and-pony show, which *might* someday be faster
15:07:56 <stephenjudkins> shapr: hmm, will have to read more about that though.
15:08:07 <shapr> Hm, isn't STM already faster for some numbers of cores and state chunks?
15:08:14 <squidz> hm you guys seem to be pretty knowledgable about this stuff
15:08:29 <otters> uh oh
15:08:31 <otters> I use STM
15:08:46 <stephenjudkins> shapr: i am not an expert, but from what I understand most experts have been pretty disappointed by the performance gains
15:08:49 <shapr> squidz: This is a great place to hang out and learn awesome stuff! Haskell is powerful and allows the expression of powerful ideas!
15:09:08 <stephenjudkins> as you start scaling up the number of cores, lock contention starts approaching 100% of your time
15:09:18 <shapr> stephenjudkins: I know the STM in C/C++ implementations from IBM were at least five times slower than running without STM.
15:09:51 <zachk> is that still true if it is spread across 100+ cores though?
15:09:57 <shapr> stephenjudkins: I would only expect that to be true for a number of state chunks that are much smaller than the number of threads.
15:10:04 <shapr> I should go read the STM papers again.
15:10:13 <shapr> Or just work on my GSoC project
15:10:14 <stephenjudkins> otters: is your program correct? does it work fast enough? do you like using STM? then it is the correct tool for you!
15:10:23 <c_wraith> the thing is, STM is an interface, not an implementation
15:10:23 <mgsloan> it was already explained quite well, buut "optimistic" == "let's hope that nothing goes wrong, and forge ahead"
15:10:24 <otters> stephenjudkins: yes
15:10:27 <otters> the nice thing about working with networking is
15:10:31 <shapr> mgsloan: Yes!
15:10:33 <otters> that almost all performance drawbacks are neutralized
15:10:35 <otters> by network latency
15:10:37 <otters> it allows me to be lazy
15:10:44 <c_wraith> The optimistic locking implementation need not be the only STM implementation
15:10:45 <shapr> mgsloan: and then discard all the work done if something went wrong
15:11:06 <stephenjudkins> zachk: yes, amdahl's law and all... the more cores you get, the less each core adds to performance
15:11:08 <mgsloan> yup, which can really be a problem when things get contentious
15:11:18 * shapr looks up stephenjudkins on G+
15:11:32 <mgsloan> it's almost like you need something that can intelligently switch between optimism and pessimism
15:11:33 <stephenjudkins> shapr: i don't do the google+ thing... should get back into it
15:11:41 <stephenjudkins> seems to be a lot of smart nerds writing good stuff!
15:11:43 <shapr> stephenjudkins: Do you have a profile that describes you as a software gnome?
15:11:48 <stephenjudkins> yes
15:11:49 <shapr> stephenjudkins: oh, me me! I write good stuff!
15:11:54 <zachk> there has to be some sort of lower limit depending on the algorithm though
15:12:38 <squidz> wow, less than 10 minutes in the haskell channel and my mind is being blown
15:12:39 * zachk used to actually be referred to by his coworkers at one his jobs as the "furry server gnome" 
15:12:42 <shapr> squidz: See, you should totally hang out with us :-) But be aware I'm biased because I started #haskell !
15:13:31 <squidz> shapr: do you have a github or something
15:13:44 <shapr> er, I do... but it's not that great
15:13:58 <squidz> shapr: I am really in the beginnings of my haskell adventures and I am feeling adventurous
15:13:58 <shapr> https://github.com/shapr
15:14:02 <shapr> squidz: Oh good!
15:14:02 <janua> Hello, i dont understand the signature of the lookup function, can anyone explain the Eq => part?
15:14:13 <otters> Eq a is a class constraint
15:14:27 <otters> lookup has to compare every key to see if it's the right one
15:14:29 <shapr> squidz: Lots of other people on #haskell write more Haskell code than I have
15:14:35 <otters> and it can't compare them if they're not comparable
15:14:46 <otters> (==) is part of the Eq class
15:14:48 <janua> I know what lookup does, but i don't know how i am meant to understand the signature
15:15:00 <otters> it means that a is part of Eq
15:15:05 <otters> do you understand the part after the =>?
15:15:07 <otters> :t lookup
15:15:09 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:15:10 <janua> Yes
15:15:13 <otters> right
15:15:16 <squidz> or do you know some big projects from #haskell regulars
15:15:16 <otters> it means a is an Eq
15:15:20 <janua> I understand after =>... Its => thats throwing me off
15:15:22 <otters> I have a fairly small project
15:15:28 <shapr> squidz: What sort of projects do you want to see?
15:15:35 <otters> janua: everything before => is class constraints, everything after is type signature
15:15:42 <squidz> shapr: any really, I just wanted to see what kind of stuff yall are working on
15:15:49 <janua> Ok, i shall look that up, thanks otters
15:15:53 <otters> squidz: I wrote an IRC proxy
15:16:29 <squidz> otters: is it on a public repository?
15:16:40 <otters> yeah
15:16:44 <otters> github.com/otter/kevin
15:16:49 <otters> otters was already taken by some chump
15:17:06 <otters> YMMV when reading my haskell, it's my first big project
15:18:22 <shapr> squidz: There are *many* things written in Haskell, I'm not even sure where to start.
15:18:27 <squidz> cool thanks, and no worries as far as critque goes. Ill be lucky if i can understand it. I am just getting into learning haskell and kind of got stuck on monads. Rummaging through peoples code I guess is somewhat of a distraction or motivation
15:18:34 <otters> oh, okay
15:18:36 <otters> yeah, I got monads in there
15:18:52 <shapr> squidz: Have you found the free online books?
15:19:20 <squidz> shapr: yes, im reading LYAH right now
15:19:30 <shapr> Excellent! You may also want to try Real World Haskell.
15:19:38 <kallisti> I think it would good to have a book that's exactly like RWH
15:19:39 <squidz> and like I said am slowly working my way through the last of the book
15:19:39 <kallisti> but
15:19:48 <kallisti> instead uses modern libraries to do the same things.
15:19:53 <shapr> kallisti: update it?
15:19:54 <otters> learning haskell is like learning a foreign language
15:20:04 <squidz> does anybody know when real world haskell will have their next edition
15:20:05 <kallisti> shapr: well, no. RWH is good as it stands.
15:20:06 <otters> you kinda have to do a lot of work in it before you really know what's going on
15:20:07 <kallisti> as an introduction
15:20:14 <kallisti> but it would be good to have a "now here's how you'd really do it"  book.
15:20:38 <shapr> so, web world haskell? :-)
15:20:41 <shapr> or server world?
15:20:45 <otters> web scale haskell!
15:20:49 <kallisti> Real Real World Haskell
15:20:56 <shapr> Complex World Haskell?
15:21:02 <otters> RealWorld# Haskell
15:21:05 <shapr> ha
15:21:16 <kallisti> otters++
15:21:27 <squidz> kallisti: I heard that RWH is a little outdated, but are the libraries it uses really no longer primary choices?
15:21:29 <shapr> Hey, is there a style manual for Haskell source code?
15:22:01 <shapr> zachk just asked me for a style manual, and I realized, I've never really seen one.
15:22:20 <tgeeky_> shapr: there's tool: stylish-haskell
15:22:28 <tgeeky_> shapr: there is a github Haskell style manual floating around
15:22:30 <kallisti> squidz: well, JSON parsing for example. RWH creates a custom JSON type and parser
15:22:41 <kallisti> squidz: in an actual program you'd just use Aeson.
15:22:46 <shapr> Yah, Aeson is nice.
15:22:47 <solrize> there is some talk of a second edition of RWH
15:22:57 <solrize> also michael snoyman is working on "mezzo haskell"
15:23:12 <kallisti> which is why I say this book shouldn't be a replacement  of RWH. because it's illustrative to make a custom JSON parser.
15:23:18 <zachk> here is a style manual http://snapframework.com/docs/style-guide '
15:23:39 <zachk> mezzo haskell?
15:24:00 <kallisti> intended to be a intermediate Haskell book. with modern libraries.
15:24:47 <Nafai> https://github.com/tibbe/haskell-style-guide <- this is the one I kind of follow
15:24:48 <geekosaur> of course, by the time it's available, his *own* libraries will have evolved beyond it
15:25:40 * mgsloan roughly follows https://github.com/mgsloan/haskell-style-guide
15:25:46 <squidz> geekosaur: Yeah i guess that is the problem of writing books based strongly on libraries
15:26:01 <mgsloan> main difference is somewhat tighter indentation :)
15:28:27 <solrize> hlint is useful
15:30:34 <squidz> Are haskells Databaes libraries lacking? I come from a java background where I use big ORM libraries for enterprise size stuff and after searching a bit for what haskell offers, I get the feeling that something is missing.
15:31:06 <squidz> it could be though that java is my only language really and any other language besides java would be the same
15:31:41 <shachaf> Unfortunately Haskell is not designed for enterprise size stuff.
15:31:50 <otters> it's not?
15:32:02 <shachaf> Nope.
15:32:08 <otters> what's it designed for?
15:32:13 <squidz> is there an aim to make haskell more like a glue language
15:32:16 <shachaf> ...Also, the state of database libraries is, I *think*, not that great. Which is a seaprate issue.
15:32:23 <shachaf> otters: Avoiding success at all costs.
15:32:37 <otters> Well, it's done that pretty well so far
15:32:47 <shapr> You'd be surprised.
15:33:10 <shapr> When the big financial companies started advertising for Haskell programmers, that's when I knew it was all over.
15:33:33 <shapr> Once Haskell had an O'Reilly book... and now it has, two?
15:34:32 <silver> heh
15:34:51 <baleft> it is all over when industry is hiring? hm?
15:35:11 <solrize> shapr  http://sfbay.craigslist.org/eby/eng/3129386453.html  "mathematician web developer, must be able to lift 30 pounds"
15:35:11 <shapr> Well, at least the avoidance of success is all over at that point.
15:35:31 <zachk> its motto for 20+ years has been: "Avoid Success at all costs!"
15:35:39 <squidz> solrize: be able to life 30 pounds. Thats good
15:35:46 <otters> see plus plus a plus
15:35:56 <otters> haskell has been around for 20 years?
15:36:09 <osfameron> !
15:36:20 <zachk> well the first standard was 98
15:36:29 <zachk> but there was some stuff a bit before that I think
15:36:37 <geekosaur> erm?
15:36:38 <parcs`> squidz: we have a couple of ORM libraries, the most popular one being 'persistent'
15:36:43 <geekosaur> there were earlier standards
15:36:49 <osfameron> gosh, 1990, apparently
15:36:51 <zachk> am I way off if I am slap me with some three day old squid?
15:36:55 <zachk> ok
15:36:59 * zachk rests in peace for a moment 
15:37:02 <otters> 1990
15:37:04 <otters> sweet jesus
15:37:06 <squidz> parcs`: im also not sure if ORM is the best approach with haskell
15:37:09 <osfameron> only 3 years younger than Perl
15:37:13 <Peaker> shachaf, enterprise software is good for enterprise size stuff?
15:37:14 <zachk> ORM?
15:37:15 <geekosaur> cf. http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/
15:37:44 <geekosaur> which from the version number implies earlier versions of the standard :)
15:37:55 <squidz> http://en.wikipedia.org/wiki/Object-relational_mapping
15:38:52 <solrize> enterprise programming = nobody does the real work, it's delegations all the way down ;)
15:39:27 <zzing_> solrize, until it is evaluated
15:39:53 <solrize> that's copied from someone's post about java, comparing it to "turtles all the way down"
15:45:04 * hackagebot fixhs 0.1.4 - FIX (co)parser (ArvinMoezzi)
15:48:52 <solrize> so are cache-oblivious algorithms a new shiny?  they don't seem to fit haskell's approach
15:54:52 <mietek> Does the Haskell Platform include a priority queue package?
15:55:35 <hpc> mietek: you can make one easily
15:55:39 <hpc> IntMap (Chan a)
15:55:53 <hpc> replace Chan with container type of your choice
16:05:26 <Saizan> there are some on hackage
16:06:58 <kqr> can you have let expressions in a do construct? it seems logical to me, but ghc tells me that "the last statement in a do construct must be an expression"
16:07:24 <mauke> what's your code?
16:07:26 <shachaf> kqr: You can have let expressions, yes.
16:07:31 <shachaf> You can also have let statements, but not at the end.
16:07:45 <kqr> mauke, anywhere i can paste the code?
16:07:51 <mauke> kqr: /topic
16:07:57 <kqr> oh right
16:08:54 <solrize> mietek there are some priority queues on hackage, not sure about in platform
16:08:58 <shachaf> mauke: Don't tell people to paste the code into the topic. :-(
16:09:15 <hpaste> kqr pasted “The last statement in a 'do' construct must be an expression” at http://hpaste.org/71299
16:09:30 <mietek> Thanks guys, I know there are some on hackage
16:09:37 <mauke> kqr: remove "in  "
16:09:39 <mietek> I was reading about a proposal for one to get into HP, but I couldn't find it
16:09:57 <shachaf> Remove the "in  " or alternatively indent it. :-)
16:10:01 <shachaf> But removing is best.
16:10:07 <kqr> mauke, why?
16:10:13 <mauke> kqr: to make it compile
16:10:21 <kqr> yeah but i mean what's the semantics behind it?
16:10:40 <kqr> i thought the let construct had the form `let <bindings> in <body>'
16:10:56 <kqr> let expression*
16:11:04 <shachaf> let expressions do have that form.
16:11:21 <shachaf> But what you have there is not being parsed as a let expression.
16:12:29 <kqr> how is the let expression supposed to be indented?
16:13:24 <mauke> the problem is the automatic ';' insertion done by 'do'
16:13:53 <kqr> because i can't get it to compile even if i do remove `in'
16:14:14 <mauke> I didn't say remove `in', I said remove "in  "
16:14:34 <kqr> mauke, oh sorry
16:15:05 <kqr> mauke, i thought it complained on invalid indentation when i tried that, but it was another error (i haven't written one of the functions yet)
16:15:26 <mauke> ah
16:15:27 <kqr> how does let work when there's no `in'?
16:15:51 <shachaf> kqr: You should read about how do-notation works.
16:15:59 <kqr> shachaf, okay
16:18:09 <vodik> what is the attoparsec equivalent of optional? ("optional p optionally parses p and always returns ().")
16:19:58 <jfischoff> vodik: might be optional from Control.Applicative
16:20:05 <vodik> okay
16:20:27 <jfischoff> vodik: would this work: optional :: Alternative f => f a -> f (Maybe a)
16:20:36 <vodik> it does the trick
16:20:38 <vodik> ty
16:20:40 <vodik> hmm
16:20:44 <mauke> kqr: do { let BINDINGS; ... } ==> let BINDINGS in do { ... }
16:24:05 <optimight> What will happen if I kill the process halfway? - optimight@optimight:~$ cabal update
16:24:06 <optimight> Downloading the latest package list from hackage.haskell.org
16:25:36 <applicative> > [c | a <- "abc",  let b = ord a,  c <- show b]
16:25:38 <lambdabot>   "979899"
16:26:49 <noor_> I'm trying to understand what Haskell does when there are more tokens than the type system understands to be necessary for function application, so I typed ':type 1 2' into GHCi and got back '1 2 :: (Num a, Num (a -> t)) => t' can anyone explain simply what this means?
16:27:18 <shachaf> noor_: Numbers are special.
16:27:22 <kallisti> noor_: it means that function application automatically implies that a term is a function
16:27:29 <shachaf> noor_: Try :type 'a' 'b' to get a saner error messages.
16:27:30 <kallisti> and since numeric literals are overloaded
16:27:40 <kallisti> it implies that you're referring to a function.
16:27:49 <kallisti> with a Num instance.
16:28:04 * jfischoff just learned something sort of evil
16:28:09 <noor_> a function can have a Num instance????
16:28:13 <kallisti> yes
16:28:19 <noor_> what?????????
16:28:26 <kallisti> any type can be an instance of Num
16:28:29 <shachaf> noor_: Well, anything can have a Num instance. Type classes are open that way.
16:28:30 <kallisti> just define the operators
16:28:43 <optimight> Will there be any difficulty if I stop the Cabal Update in between?
16:28:59 <shachaf> optimight: I doubt it.
16:29:03 <zachk> can a typeclass have a Num instance?
16:29:09 <shachaf> But, just like adding question marks to the end of a line, it doesn't always mean it's a good idea. :-)
16:29:17 <optimight> shachaf: means?
16:29:19 <shachaf> zachk: Typeclasses can't be instances of things.
16:29:24 <zachk> alright
16:29:26 <shachaf> optimight: It'll be fine.
16:30:24 <noor_> alright that all seems perfectly sensible thank you.
16:30:30 <kqr> mauke, oh, wow, i didn't know that. thanks
16:30:53 <optimight> shachaf: I will go ahead and stop it. I think, it is not at all downloading anything. It is stand still since one hour or so.
16:31:04 <mgsloan> zachk: The idea of typeclasses having instances has been discussed before though, it's usually called "superclass default instances", and it's a pretty useful thing to have, but nothing like it is currently in GHC
16:31:37 <shachaf> mgsloan: That's not really the same thing.
16:31:58 <noor_> I still don't understand why it thinks its perfectly reasonable for a… OH WAIT I get it 1 is ambiguous that makes sense ok
16:32:00 <shachaf> It's instances of one typeclass being instances of another typeclass. :-)
16:32:22 * zachk still is not sure how it could be super useful 
16:32:28 <kallisti> noor_: lambdabot actually does have a num instance for functions defined
16:32:33 <kallisti> > 4 2
16:32:36 <lambdabot>   4
16:32:39 <kallisti> > map 4 [1..]
16:32:39 <shapr> Whoa, I like this experimental haskell-mode feature http://www.youtube.com/watch?v=pu9AGSOySlE 'pretty show'
16:32:41 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
16:32:42 <shachaf> kallisti: Don't confuse the poor_. :-(
16:32:49 <kallisti> shachaf: he just got it. so it's fine.
16:33:16 <noor_> yes, but I don't like it
16:33:19 <kallisti> > abs + 1 $ -3
16:33:21 <lambdabot>   4
16:33:36 <noor_> seems like a thing that should be avoided lest impossible bugs get everywhere
16:33:53 <kallisti> yes, numeric overloading is one of those things that can be easily abused
16:33:59 <jfischoff> shapr: that's very cool
16:34:13 <mgsloan> zachk: it's useful for a few reasons.  One is that it lets you build a new set of typeclasses, but use them with code that only defines instances of the old ones
16:34:16 <kallisti> noor_: but it can also do some very cool tricks.
16:34:19 <kallisti> for example
16:34:30 <kallisti> > map f [a,b,c] :: [Expr]
16:34:32 <lambdabot>   [f a,f b,f c]
16:34:47 <kallisti> er... well
16:34:48 <kallisti> more like
16:34:59 <kallisti> > foldr (+) 0 [a,b,c]
16:35:01 <lambdabot>   a + (b + (c + 0))
16:35:08 <kallisti> the first one doesn't actually use a Num instance for anything
16:35:09 <mgsloan> zachk:  Another useful thing is that you can get common definitions for free.  A definition of Monad implies a "default" definition for Functor / Applicative
16:35:11 <kallisti> this one does.
16:35:20 <noor_> I don't get what you're saying but ok
16:35:48 <noor_> do you not mean foldr 0 0 [a,b,c]
16:35:51 <kallisti> no
16:35:52 <kallisti> noor_: there's an Expr type defined in the simplereflect package that has a Num instance for pretty printing expressions.
16:35:53 <noor_> foldr 0 0 [a,b,c]
16:35:59 <kallisti> a, b, and c are values of this type
16:36:00 <kallisti> :t a
16:36:02 <lambdabot> Expr
16:36:13 <kallisti> > a + b
16:36:15 <lambdabot>   a + b
16:36:22 <noor_> are we not talking about numbers acting as functions?
16:36:32 <kallisti> we're talking about numbers acting as any Num instance.
16:36:35 <navaati> :t f
16:36:37 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:36:37 <noor_> or functions acting as numbers?
16:36:40 <noor_> or something??
16:36:43 <noor_> I am confused
16:36:55 <kallisti> 19:33 < kallisti> yes, numeric overloading is one of those things that can be easily abused
16:37:00 <kallisti> 19:33 < kallisti> noor_: but it can also do some very cool tricks.
16:37:05 <kallisti> there. I showed you one of the cool tricks it can do.
16:37:17 <navaati> > foldl (+) 0 [a,b,c]
16:37:18 <lambdabot>   0 + a + b + c
16:38:22 <noor_> how is that not… um I mean… you're just saying a b and c are instances of Num and you are doing a fold what is special about that?
16:38:34 <mauke> no, a, b, and c are variables
16:38:41 <mgsloan> :t a
16:38:43 <lambdabot> Expr
16:38:43 <mauke> their type is Expr
16:38:45 <noor_> that must be instances of Num
16:38:47 <mauke> Expr is an instance of Num
16:38:54 <mauke> variables can't be instances
16:39:09 <hpc> a = var "a" -- or something like that
16:39:12 <hpc> b = var "b"
16:39:13 <hpc> ...
16:39:34 <kallisti> :t var
16:39:35 <lambdabot> forall a. String -> Sym a
16:39:40 <hpc> :t expr
16:39:42 <lambdabot> Expr -> Expr
16:39:46 <hpc> hmm
16:39:49 <kallisti> > SimpleReflect.var "hello" + 2
16:39:50 <lambdabot>   Not in scope: `SimpleReflect.var'
16:39:52 <noor_> I'm saying if that were anywhere in code the type checker would make sure that they were Num a's and that (+) Int a was defined, no??
16:40:09 <kallisti> noor_: what does (+) Int a  mean
16:40:38 <kallisti> are you suggesting you can add an Expr and an Int with (+)
16:40:44 <kallisti> because you can't.
16:40:52 <hpc> > 0 :: Expr
16:40:54 <lambdabot>   0
16:41:15 <noor_> never mind, but that it knew how to do (+) on the combination to the literal "0" and whatever type a b and c are
16:41:28 <geekosaur> literals are special
16:41:31 <kallisti> right, that's how it knows how to do anything with (+)
16:41:38 <kallisti> so indeed, this is nothing special
16:41:45 <noor_> so what about overloading??
16:41:49 <kallisti> it was just. an example. of a cool thing you can do with overloaded literals.
16:41:54 <kallisti> noor_: what about it?
16:42:07 <noor_> I don't get how what you did is overloading, or what overloading is
16:42:18 <kallisti> 2
16:42:19 <kallisti> is overloaded
16:42:20 <kallisti> :t 2
16:42:22 <lambdabot> forall t. (Num t) => t
16:42:44 <noor_> don't know forall syntax
16:42:52 <mauke> noor_: you can ignore everything before '.'
16:42:52 <kallisti> you can safely ignore it
16:42:54 <geekosaur> the forall is not relevant
16:42:56 <navaati> in this case, ignore it
16:43:28 <kallisti> > x + (2 :: Int)
16:43:29 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
16:43:29 <lambdabot>         against inferred ...
16:43:32 <noor_> can you give me a sentence on what overloading is?
16:43:49 <navaati> is typeclass overloading always resolved at compile-time in haskell (including funky ghc exts) ?
16:44:00 <geekosaur> any numeric literal is translated to a call to fromIntegral or fromRational, depending on what type inference requires of it (that is, if fromIntegral doesn't lead to something that typechecks, fromRational is used)
16:44:05 <shachaf> navaati: What does that mean?
16:44:09 <kallisti> an overloaded values is polymorphic. an overloaded function is polymorphic in its arguments.
16:44:17 <jfischoff> navaati: yes
16:44:21 <mauke> navaati: no
16:44:26 <navaati> :D
16:44:36 <jfischoff> mauke: really?
16:44:38 <jfischoff> which extension?
16:44:39 <shachaf> If you say "module Foo(x) where x :: Num a => a; x = 5", that'll be compiled into a module that exports a polymorphic value.
16:44:39 <sipa> depends on what you mean by 'resolved'
16:44:43 <mauke> jfischoff: Haskell 98
16:44:47 <jfischoff> really
16:44:49 <jfischoff> my bad
16:45:14 <navaati> i mean "we know the actual code (instance) to call at compile time"
16:45:27 <jfischoff> mauke: can you explain
16:45:37 <noor_> so you're saying in '1 2' it overloads '1' to be a function, because….
16:45:49 <sipa> not when a non-specialized version of a typeclass function call on a polymorphic value is built
16:45:51 <mauke> > let foo :: (Show a) => Int -> a -> String; foo 0 x = show x; foo n x = foo (n - 1) (x, ()) in foo 3 'x'
16:45:53 <navaati> ah, in haskell 98 ? i'd have thought about existentials, at least…
16:45:53 <lambdabot>   "((('x',()),()),())"
16:45:54 <kallisti> 1 is already overloaded. it was interpreted to be a function because you used it like one.
16:46:04 <kallisti> similarly.  in 1 + 1
16:46:06 <kallisti> 1 is overloaded
16:46:11 <kallisti> it can be any Num instance.
16:46:29 <kallisti> > 1 + 1 :: Float
16:46:31 <lambdabot>   2.0
16:46:32 <mauke> > let foo :: (Show a) => Int -> a -> String; foo 0 x = show x; foo n x = foo (n - 1) (x, x) in foo 3 'x'
16:46:33 <kallisti> > 1 + 1 :: Int
16:46:34 <lambdabot>   "((('x','x'),('x','x')),(('x','x'),('x','x')))"
16:46:35 <lambdabot>   2
16:47:31 <kallisti> ah. interesting
16:47:37 <kallisti> I'd never considered that..
16:48:03 <noor_> so overloading and treating a literal like a function are not related… or are you saying that when haskell overloads '1' it includes the possibility to be a function because of the definition of "Num'?
16:48:11 <kallisti> recursion of overloaded functions can't resolve instance code at compile-time.
16:48:37 <kallisti> noor_: because of Num being a special case
16:48:41 <navaati> isn't it the stuff called "impredicative" ?
16:49:54 <jfischoff> mauke: interesting
16:49:56 <jfischoff> thanks
16:50:06 <noor_> Well that just spoils the whole beauty of the type system if lNum's can be functions as far as the compiler is concerned
16:50:07 <kallisti> noor_: 1 is overloaded because the standard says so. the fact that it's overloaded means that it can be any type. the fact that you wrote "2 2" implies that you meant "2" was a function. so yes, overloading and treating a function as a literal are related. and when Haskell overloaded '1' is includes the possibility to be a function because instances are open.
16:50:45 <sipa> or in short: function values are not special in any way
16:50:48 <kallisti> 2 implied "Num a => a"    and "2 2" implied that a = b -> c
16:51:22 <noor_> what is different about a [Char] or whatever the name of the type is...
16:51:42 <kallisti> it's just not defined that way. Num is completely special cased. nothing else works like it in Haskell 98 or 2010.
16:52:01 <kallisti> with OverloadedStrings, you can overload string literals in the same way, using the IsString class defined in Data.String.
16:52:03 <noor_> I dont UNDERSTAND..!
16:52:05 <navaati> well, special-cased… not that much…
16:52:26 <kallisti> well yeah, the type inference and all that isn't special cases.
16:52:32 <kallisti> the fact that the syntax 2 is Num a => a
16:52:35 <navaati> literals are of type "Num a ⇒ a", that's all one have to understand
16:52:38 <kallisti> and that by default it will resolve to Integer if its ambiguous
16:52:40 <kallisti> is special to Num
16:52:42 <kallisti> and nothing else.
16:52:47 <noor_> ah so Num's are overloaded to allow multiple implementations and other things are not GOT IT GOT IT GOT IT
16:52:57 <kallisti> numeric literals, specifically.
16:53:07 <kallisti> all typeclasses allow multiple implementations are other things
16:53:07 <navaati> other things are not ? which other things ?
16:53:13 <sipa> numeric literals are overloaded by making them part of the Num type class
16:53:28 <kallisti> let's be clear: numeric literals are syntactic construct
16:53:41 <noor_> I UNDERSTAND OK IF I HAD GIVEN A TYPE TO THE LITERALS THIS WOULD NOT HAVE HAPPENED CORRECT ME WHERE I AM WRONG
16:53:53 <kallisti> if you hadn't written "2 2" this wouldn't have happened
16:53:54 <shachaf> Ouch.
16:54:16 <mauke> noor_: ＷＨＡＴ ＡＩＬＳ ＹＯＵ， ＭＹ ＦＲＩＥＮＤ？
16:54:30 <navaati> i guess in the AST litterals are represented as "fromInteger (2 :: Integer)" ?
16:54:37 <noor_> if you must know paranoid schizophrenia real diagnosis
16:54:47 <kallisti> navaati: more or less.
16:54:49 <navaati> (AST, or Core, or whatever you want)
16:54:50 <kallisti> not sure what it looks like internally
16:54:56 <kallisti> but that's what it means.
16:55:16 <MostAwesomeDude> Hey, how would I write out an image, pixel by pixel? I wish to visualize some maths I'm doing.
16:55:17 <shachaf> navaati: In the AST they're probably represented as literals.
16:55:30 <shachaf> It is, after all, a *syntax* tree.
16:55:44 <navaati> ah, yeah
16:55:51 <shachaf> MostAwesomeDude: PNM
16:55:59 <kallisti> noor_: are you familiar with fromInteger?
16:56:05 <noor_> ish
16:56:07 <kallisti> maybe I assumed too much.
16:56:22 <kallisti> fromInteger is a typeclass method on Num. all instances of Num define their own meaning for "fromInteger"
16:56:33 <kallisti> and when you write "2"  you're actually saying fromInteger (2 :: Integer)
16:56:33 <noor_> I don't care about its implementation too much to be honest but I get what it is for
16:56:49 <kallisti> it has multiple implementations
16:56:52 <kallisti> one for each instance of Num.
16:56:58 <kallisti> which is how the literal overloading works.
16:57:44 <navaati> for example the implementation of fromInteger for the "nums as functions" instance is fromInteger = const
16:58:11 <kallisti> actually it might be fromInteger = const . fromInteger
16:58:15 <noor_> and Int Integer Float etc all have secret definitions hidden deep inside a dark corner of the compiler and I'm assuming the functions contained in fromInterger instances as well
16:58:26 <hpc> @src Int
16:58:27 <lambdabot> data Int = I# Int#
16:58:31 <kallisti> something like that.
16:58:37 <MostAwesomeDude> shachaf: IOW, there's no image library for this? Or it'd be far easier to do PNM?
16:58:45 <navaati> well, Integer's instance is nothing dark, it's id. but otherwise, yes
16:58:47 <shachaf> MostAwesomeDude: There are plenty of image libraries, I'm sure.
16:58:59 <shachaf> MostAwesomeDude: But when you already have an array of pixels, PNM is just so easy. :-)
16:59:03 <MostAwesomeDude> Sure.
16:59:12 <MostAwesomeDude> I don't yet have the array of pixels, but I can generate them point by point.
17:00:06 * hackagebot happstack-server 7.0.3 - Web related tools and services. (JeremyShaw)
17:00:14 <fryguybob> MostAwesomeDude: JuicyPixels?
17:00:33 <navaati> oh, little vicious idea btw : ghc does, in certain cases, constant folding, right ? what if it constant folds (2+2) into 4, but in this particular case 2's definition is "error "lol"", does it explodes at compile-time ? (i guess i got something wrong here)
17:01:03 <mgsloan> navaati: I'm guessing it only does constant folding when the type is known
17:01:21 <shachaf> It's wrong to constant-fold 0.1 + 0.2 into 0.3.
17:01:31 <shachaf> > 0.1 + 0.2
17:01:32 <lambdabot>   0.30000000000000004
17:01:47 <navaati> "known" like "included in a short list harcoded in ghc" ?
17:01:53 <mauke> no, known
17:01:59 <mgsloan> but it's right to constant-fold into that, if you're using Double (or is it Float?)
17:02:13 <navaati> > 0.3
17:02:15 <lambdabot>   0.3
17:03:13 <mgsloan> navaati: Using lambdabot / ghci for this is confusing, because numerics have assumed defaults.  For all other kinds of things, you'd need to give an explicit ":: Double"
17:03:14 <navaati> hum… anyway, good night
17:03:20 <mgsloan> and that's what's meant by "known"
17:05:53 <noor_> ok so '1 2' is not valid haskell as defined in the prelude (or really that you could define) so why didn't the type checker have a problem with '1 2' if there is no instance of Num (a -> b)?
17:06:23 <mauke> noor_: because it is valid Haskell
17:06:30 <mauke> and you can define such an instance
17:06:45 <noor_> huh?
17:06:57 <noor_> '1 2' gave No instance for (Num (a0 -> t0)) etc.
17:07:24 <johny8809> http://www.wix.com/jetomestil/hot-ass-collection
17:08:09 <otters> > 1 2
17:08:11 <lambdabot>   1
17:08:15 <otters> > 2 1
17:08:16 <lambdabot>   2
17:08:18 <otters> okay...
17:08:24 <noor_> GHCi disagrees
17:08:25 <hpc> lambdabot has that instance
17:08:27 <MostAwesomeDude> This is specific to lambdabot.
17:08:29 <hpc> it's not one you want
17:08:34 <otters> :t 1
17:08:36 <lambdabot> forall t. (Num t) => t
17:08:53 <mauke> MostAwesomeDude: not quite
17:09:00 <mauke> you can import that module
17:09:07 <noor_> ok, its fine that lamdabot has it, but the prelude does not, so why didn't the type checker catch it on ghci?
17:10:37 <hpc> it did, unless i am misunderstanding
17:10:54 <jmcarthur> noor_: "'1 2' gave No instance for (Num (a0 -> t0)) etc."  <-- sounds like this type checker caught it to me
17:10:55 <hpc> it sees "1 2", which is "1" applied to a thing
17:11:03 <hpc> and so it expects "1" to be a function
17:11:06 <noor_> Prelude> :type 1 2
17:11:07 <noor_> 1 2 :: (Num a, Num (a -> t)) => t
17:11:12 <hpc> there's no instance of Num that matches, hence the error
17:11:16 <noor_> Prelude> 1 2
17:11:17 <noor_> <interactive>:5:1:
17:11:18 <noor_>     No instance for (Num (a0 -> t0))
17:11:20 <noor_>       arising from the literal `1'
17:11:21 <noor_>     Possible fix: add an instance declaration for (Num (a0 -> t0))
17:11:23 <noor_>     In the expression: 1
17:11:24 <noor_>     In the expression: 1 2
17:11:24 <noor_>     In an equation for `it': it = 1 2
17:11:32 <noor_> see the contradiction?
17:11:37 <jmcarthur> noor_: that could be a valid value if you define an instance for it elsewhere, so it's valid
17:11:53 <jmcarthur> noor_: in fact, if you define an instance after it it's fine
17:12:08 <jmcarthur> noor_: as in... you say "let x = 1 2" then define an instance, then evaluate x
17:12:19 <noor_> but it is not defined anywhere, isn't that the point of the type checker, to check if what you typed is valid as defined elsewhere?
17:12:25 <mgsloan> right
17:12:28 <kallisti> noor_: that's a compile-time error
17:12:32 <kallisti> so yes.
17:12:34 <mgsloan> what we're getting at is that you /can/ define it
17:12:55 <mgsloan> it just doesn't make very much sense to define it
17:13:04 <mauke> I think it makes a lot of sense
17:13:05 <jmcarthur> it's a pretty sensible instance, actually
17:13:20 <noor_> right, but the the type checker should not check to see if what you wrote COULD be defined, it should check to see if what you typed IS defined.
17:13:26 <jmcarthur> > sin + cos $ pi
17:13:28 <lambdabot>   -0.9999999999999999
17:13:40 <kallisti> noor_: and it's not.
17:13:44 <noor_> right
17:13:46 <mauke> noor_: it did
17:13:48 <jmcarthur> noor_: it doesn't allow you to use it... statically
17:13:51 <noor_> no
17:13:54 <mauke> noor_: yes
17:13:56 <hpc> the error message is more than just "this isn't defined"
17:14:02 <jmcarthur> noor_: where did the error come from then?
17:14:07 <hpc> it's "this isn't defined, but it could be if you did this"
17:14:15 <kallisti> noor_: the instance COULD be defined. it wasn't. that's the error.
17:14:23 <shachaf> > 1 2 base 8 which is 10 base 10 and you take away 3 that's 7
17:14:25 <lambdabot>   1
17:14:33 <noor_> I guess i need to think for a second
17:14:35 <jmcarthur> haha
17:14:57 <mgsloan> jmcarthur: right, that one makes sense.  That's (Num a, Num (t -> a)).  This needs to be (Num a, Num (a -> t))
17:15:31 <jmcarthur> mgsloan: you mean Num a => Num (t -> a)?
17:15:43 <mgsloan> I do, using constraint kinds for kicks, though
17:16:06 <shachaf> jmcarthur: Hah, sin + cos $ pi
17:16:30 <jmcarthur> shachaf: it is quite nice :)
17:16:44 <jmcarthur> shachaf: i've also used this instance a lot to do math on record fields
17:16:52 <mgsloan> > (sin + cos $ pi) == (sin + cos $ 0)
17:16:52 <noor_> I guess what I'm saying is before it tells you something has type (Num a, Num (a -> t)) => t it should first check if there is a type instance for that.
17:16:54 <lambdabot>   False
17:16:58 <shachaf> > sin^2 + cos^2 $ pi
17:16:59 <lambdabot>   1.0
17:17:08 <mgsloan> that's pretty awesome
17:17:25 <mauke> > deriv (sin - cos) x
17:17:27 <lambdabot>   1 * cos x + negate (1 * negate (sin x))
17:17:30 <jmcarthur> shachaf: for example: data Foo = Foo { bar :: Int, baz :: Int}; addFields = bar + baz
17:17:32 <kallisti> noor_: that would depend on what's imported. why should the type of an expression depend on that?
17:17:46 <jmcarthur> :t deriv
17:17:48 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
17:17:48 <shachaf> jmcarthur: You can't make that into a lens!
17:17:48 <geekosaur> noor_, typeclasses are open.  it doesn't know whether the instance exists
17:17:53 <noor_> right, make the check on whats imported
17:17:57 <jmcarthur> shachaf: why not?
17:18:04 <jmcarthur> shachaf: can lenses not be applicatives?
17:18:06 <kallisti> what if you're running the type checker through the GHC api. Prelude only?
17:18:17 <jmcarthur> maybe not
17:18:20 <jmcarthur> guess not, actually
17:18:22 <noor_> well then write that differently
17:18:26 <jmcarthur> only works for projections
17:18:32 <mgsloan> When we went over Haskell for 2 weeks in a PL class in undergrad, I had to be the know-it-all that disagreed with the professor that you couldn't write "readLn + readLn :: IO Int"
17:18:45 <geekosaur> heh
17:18:45 <jmcarthur> heh
17:18:54 <hpc> haha
17:19:02 <nude_angel> http://41.228.210.124:8080/
17:19:10 <mauke> any Applicative can be a Num
17:19:14 --- mode: ChanServ set +o mauke
17:19:15 --- kick: nude_angel was kicked by mauke (no)
17:19:16 <kallisti> mgsloan: yeah -- forcing him to write correct code -- shame on you
17:19:17 --- mode: ChanServ set +o jmcarthur
17:19:30 --- mode: jmcarthur set -o jmcarthur
17:19:41 <otters> @pl \f g (x,y) -> (f x, g y)
17:19:41 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
17:19:44 <otters> ugh, dammit
17:19:51 <noor_> how do you quit GHCi????
17:19:56 <jmcarthur> noor_: :q
17:20:05 <Eduard_Munteanu> noor_: or ctrl+d
17:20:05 <otters> or ^D
17:20:10 <otters> there must be an arrow far that!
17:20:15 <otters> :t (***)
17:20:17 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:20:19 * mgsloan likes how both of those are faces
17:20:41 <mgsloan> you either stick your tongue out at it, or look elsewhere, and it quits
17:21:03 <jmcarthur> otters: i'm interpreting correctly that (***) is what you wanted, right?
17:21:09 <noor_> ok off to learns more knowledge THANK YOU
17:21:14 --- mode: mauke set -o mauke
17:21:36 <otters> jmcarthur: actually my code was wrong
17:21:42 <d-snp> does anyone per chance know, https://github.com/bos/aeson/blob/master/Data/Aeson/Parser/Internal.hs <-- where the function 'number' is defined? I went through Data.AttoParsec.Char8 and it wasn't in there
17:21:47 <otters> @pl \f g (x,y) (x',y') -> (f x x', g y y')
17:21:49 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
17:21:55 <otters> goodness me that won't do at all
17:21:56 <jmcarthur> otters: ah, that. i want that often
17:22:08 <jmcarthur> there's some package that has it....
17:23:03 <otters> the type signature would have to be (a -> b -> c) -> (d -> e -> f) -> (a,d) -> (b,e) -> (c,f)
17:23:11 <otters> which hoogle has no results for, amazingly
17:23:14 <geekosaur> d-snp, http://holumbus.fh-wedel.de/hayoo/hayoo.html is useful for such questions
17:23:21 <Eduard_Munteanu> @djinn (a -> b -> c) -> (d -> e -> f) -> (a,d) -> (b,e) -> (c,f)
17:23:21 <lambdabot> f a b (c, d) (e, f) = (a c e, b d f)
17:23:27 <Eduard_Munteanu> Bah :)
17:23:32 <jfischoff> :)
17:23:38 <otters> yeah, that'd be it
17:24:14 <jmcarthur> :t let ($*) = uncurry (***) in \f g xs ys -> (f, g) $* xs $* ys
17:24:15 <lambdabot> forall b b' b1 c b'1 c'. (b -> b1 -> c) -> (b' -> b'1 -> c') -> (b, b') -> (b1, b'1) -> (c, c')
17:24:22 <jfischoff> I bet it has 'co' in name
17:24:38 <otters> christ
17:25:13 <jmcarthur> otters: ^^^ stolen from the typecompose package
17:25:21 <jmcarthur> ($*) is pretty awesome :)
17:25:46 <jmcarthur> and it has basically nothing to do with type composition :\
17:25:49 <otters> > let ($*) = uncurry (***); magic = (\f g xs ys -> (f, g) $* xs $* ys) in join magic (+) $ (1,2) (3,4)
17:25:51 <lambdabot>   Couldn't match expected type `t -> (b, b)'
17:25:51 <lambdabot>         against inferred type `(...
17:26:10 <d-snp> hmm apparently it comes from Data.Attoparsec.Text, but no idea how it gets into the scope
17:26:29 <mgsloan> I've got an operator for your every desire: http://hackage.haskell.org/packages/archive/plumbers/0.0.2/doc/html/Control-Plumbers.html
17:26:31 <jmcarthur> > let ($*) = uncurry (***); magic = (\f g xs ys -> (f, g) $* xs $* ys) in join magic (+) (1,2) (3,4)
17:26:33 <lambdabot>   (4,6)
17:26:43 <otters> silly me
17:26:49 <otters> I ruined everything
17:26:54 <jmcarthur> mgsloan: oh this
17:27:03 <otters> holy crap, that is an awesome number of combinators
17:27:23 <mgsloan> they even follow a reasonable pattern!
17:27:36 <mgsloan> note: I do not actually advocate the usage of plumbers ;)
17:27:56 <otters> now I wonder why my hoogle query couldn't find those
17:28:12 <mgsloan> But I do think it's a fairly reasonable schema, maybe I shoulda left it at arity 2
17:28:33 <jmcarthur> mgsloan: i wonder if there is a combinator approach to constructing them systematically
17:28:39 <jmcarthur> in a syntactically pleasing way
17:29:11 <mgsloan> jmcarthur: certainly, but it's impossible to be this concise that way
17:29:14 <jmcarthur> mgsloan: similar to SECs and such
17:29:33 <mgsloan> yup, that was one of the inspirations for this
17:29:38 <jmcarthur> sure, but it would be more general, at least
17:30:01 <otters> ohwow
17:30:07 <otters> all those operators are defined with template haskell
17:30:13 * otters backs away slowly
17:30:18 <mgsloan> ;)
17:30:23 <jmcarthur> the only sane way, actually
17:30:28 <jmcarthur> who would want to write them all by hand?
17:30:37 <otters> yeah, great question
17:31:26 <mgsloan> It'd be interesting to have a language that allows you to give a grammar for a class of generative operators / instances / datatypes / etc.  (avoiding things like tuple limits and such)
17:31:37 <mgsloan> so that compile time you only build the ones you need
17:32:02 <mm_freak> mgsloan: your favorite dependently typed language does that
17:32:02 <mgsloan> then libraries like this that define an infinite class of combinators could work
17:32:18 <mgsloan> Epigram?
17:32:22 <mgsloan> Coq? Agda?
17:32:27 <mm_freak> mgsloan: yes, yes, yes
17:32:40 <mm_freak> haskell can do it, too, but it won't look pretty
17:32:43 <mm_freak> check out HList
17:33:03 <mgsloan> really?! I knew Coq could do mixfix and such, but I thought that meant it really needed a top-level per operator
17:33:15 <shapr> mgsloan: the link to mgsloan.com is broken, it links to http://hackage.haskell.org/packages/archive/plumbers/0.0.2/doc/html/www.mgsloan.com
17:33:33 <mgsloan> shapr: argh, good catch!
17:33:51 <mm_freak> mgsloan: you need to define your tuples in a different way
17:34:28 <mm_freak> for example in agda you would use the Vec type
17:34:33 <mm_freak> that's your dependent tuple
17:34:44 <mgsloan> right, but you end up using the same operator name, right?
17:34:54 <mm_freak> you write only one operator
17:35:28 <mgsloan> exactly :) so there's no support for an infinite class of operators (probably reasonably so, this is a wonky feature that could make tools / IDEs harder to build)
17:35:46 <mm_freak> mgsloan: you're confusing something
17:35:59 <mm_freak> suppose mapping functions (now back to haskell)
17:36:13 <mm_freak> mapTuple1 :: (a' -> a) -> a' -> a
17:36:27 <mm_freak> mapTuple2 :: (a' -> a) -> (b' -> b) -> (a', b') -> (a, b)
17:36:29 <mm_freak> etc.
17:36:40 <mgsloan> right.  Yeah, you can definitely make that into a class
17:36:52 <mm_freak> there would be an infinite amount of those mapping functions in standard haskell
17:37:02 <mm_freak> in agda there is only one that amounts for all those infinitely many functions
17:37:59 <mm_freak> its type will probably be a bit scary though =)
17:38:11 <applicative> d-snp I think it's from Data.Attoparsec.Char8, note it is one of the few things imported without qualification
17:38:25 <mm_freak> and you will probably pass the tuple as the first argument instead of the last
17:38:33 <mgsloan> So, the thing is is there are some decisions that are not necessitated by the type.  For example, the operator "$^<" yields a function that ignores the first argument, and passes whatever's on the right to the thing on the left
17:38:35 <mrsolo> so pearls keeps referring to foldr fusion rule...
17:39:10 <mm_freak> mgsloan: perhaps you're writing in some context i'm not aware of
17:39:22 <mgsloan> mm_freak: my plumbers combinator library
17:40:13 <mgsloan> using typeclass tricks with it was definitely on the TODO list, but I figure people could use a bit of a break from the inanity of plumbers :)
17:40:48 <mm_freak> you can't really help that with the standard tuple types
17:41:09 <mm_freak> except perhaps with a very ugly type family-based solution
17:41:20 <Eduard_Munteanu> Or TH maybe.
17:41:30 <mm_freak> i never consider TH to be a solution
17:41:46 <applicative> mrsolo: what about fusion rules
17:42:25 <mrsolo> first time read about it
17:42:45 <mgsloan> mm_freak: what about something like TH, that isn't GHC specific and supports decent DSL-specific errors?  (unfortunately this doesn't exist yet)
17:42:57 <mrsolo> just wonder do people use that a lot in practice
17:43:35 <otters> So there's a MonadState instance for MonadState s (ReaderT r m)
17:43:45 <mm_freak> mgsloan: i really started disliking TH, because it makes libraries much harder to understand…  in particular the haddocks hide important information from you, so you have to rely on examples given by the author, etc.
17:43:47 <otters> and I've defined a more specific instance MonadState Foo (ReaderT (TVar Foo) m)
17:43:57 <otters> But Haskell can't figure out which instance I want
17:44:22 <applicative> mrsolo: build foldr 'fusion' is all over ghc
17:44:28 <hpc> TH is sensitive to ordering in the file
17:44:31 <otters> can I either hide that MonadState instance
17:44:32 <mauke> there's no such thing as a "more specific instance"
17:44:35 <hpc> for instance, acid-state
17:44:36 <otters> okay
17:44:44 <mm_freak> otters: your instance is redundant
17:44:50 <otters> I see
17:44:52 <applicative> mrsolo unfoldr  destroy fusion is what makes Data.Text and the Vector package work
17:44:56 <mm_freak> otters: or even wrong
17:44:59 <mm_freak> otters: one or the other
17:45:05 <hpc> if you want to define all your state in a single file, you have a giant stack of data definitions, a giant stack of safecopy definitions, and a giant stack of acidic definitions
17:45:11 <mgsloan> mm_freak: For the example of tuples, it's certainly imaginable that you could create a "NestTuple" class that converts (a, b, c) to (a, (b, (c, ())) (and vice-versa), and then have all of your functions use that
17:45:51 <mm_freak> mgsloan: that will require ugly class instance hacks to work
17:45:58 <otters> well, okay
17:46:01 <otters> so I'm confused
17:46:10 <mgsloan> mm_freak:  Yeah, there are infrastructure problems.  I think that if TH and the like were more embraced, and less derided, and used more, then the infrastructure could improve
17:46:36 <mgsloan> mm_freak: It will?  I'm just suggesting one instance per arity
17:46:50 <otters> I'm trying to write a MonadState instance where the state is in a TVar stored in a ReaderT
17:47:06 <mgsloan> but instead, it languishes, and Haskell's meta-programming ability remains pretty annoying
17:47:07 <mm_freak> otters: that's the wrong way to do it
17:47:17 <otters> heh
17:47:22 <mm_freak> otters: write your own monad
17:47:23 <otters> that's what the guys told me to do last week
17:47:44 <otters> okay
17:47:50 <MostAwesomeDude> Ugh, I need profiling libraries apparently. How do I do this?
17:47:51 <mm_freak> mgsloan: IMO TH simply isn't the solution…  see HList for a way to do this without TH
17:48:14 <mm_freak> mgsloan: TH is always a hack to get convenience, not functionality
17:48:15 <applicative> mrsolo: destroy unfold fusion is done by library writers directly, so you can inspect the way it is done pretty easily.
17:48:20 <hpc> honestly, TH doesn't need metaprogramming
17:48:22 <mm_freak> never implement /functionality/ using TH
17:48:26 <Eduard_Munteanu> MostAwesomeDude: cabal install foo --reinstall -p   should reinstall 'foo' with profiling libs
17:48:39 <MostAwesomeDude> Eduard_Munteanu: Thanks.
17:48:42 <mgsloan> mm_freak: sure, but isn't almost all abstraction a form of convenience?
17:48:46 <mrsolo> applicative, are you referring to this? http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion#destroy.2Funfoldr_4
17:48:49 <blackdog> Eduard_Munteanu: that doesn't do it recursively though, does it?
17:49:06 <Eduard_Munteanu> Not AFAIK.
17:49:09 <applicative> mrsolo: yeah that
17:49:17 <applicative> is the 'stream fusion' variety.
17:49:27 <mm_freak> mgsloan: there is a difference between abstraction and interface…  TH writes code for you
17:49:33 <mgsloan> For example, I have a library called lenq that lets you write [lenq| \(a, _) -> a |] and get out a lens for most of the lens libraries
17:49:33 <Eduard_Munteanu> I'm not sure what's the easiest way if you cabal-installed a lot of stuff.
17:49:40 <mm_freak> in that sense TH is a more convenient interface to a particular non-TH abstraction
17:49:43 <mm_freak> at least that's the idea
17:50:05 <mm_freak> mgsloan: wait, that's not TH
17:50:08 <mm_freak> that's QQ
17:50:12 <mgsloan> mm_freak: lenq has the potential to let you write things that are awful in the applicative style
17:50:30 <mgsloan> true.  In this case here's a straightforward TH translation, though
17:50:48 <mgsloan> $(lenqExp [e| \(a, _) -> a |] )
17:51:16 <mm_freak> yeah, it's a convenient interface to an existing abstraction:  lenses
17:51:24 <d-snp> I don't get how haskell does fixed point numbers at all, how does Data.Fixed work?
17:51:25 <mgsloan> it's all convenience, but it's the sort of convenience that can get people using lenses more, because they aren't a pain
17:51:45 <applicative> mrsolo look in Data.Vector.Fusion.Steam.Monadic where the stream type is introduced and a pile of rules.
17:51:58 <jfischoff> I thought this might be nice for tuple lenses [lens| (3,5,1) |] where the numbers are indices
17:52:10 <hpc> d-snp: empty types (might be unit types) and a type class
17:52:14 <mm_freak> d-snp: what are you confused about?
17:52:24 <mgsloan> jfischoff: the thing I haven't implemented yet for lenq is being able to support function application
17:52:30 <mgsloan> then, it'll be _very_ powerful
17:52:45 <hpc> the logic of (Fixed prec) uses class functions for the type (prec) to determine how many decimal points to go
17:52:53 <mm_freak> mgsloan: data-lens isn't a pain…  i find it very straightforward to use
17:52:57 <mgsloan> you always just write getters, using lenses as if they were functions, and you get setters for free
17:53:00 <mm_freak> without TH that is
17:53:13 <jfischoff> mgsloan: is it on github?
17:53:32 <mm_freak> mgsloan: you may find yourself in a race with lens families =)
17:53:43 <mgsloan> jfischoff: yup.  I haven't publicized it due to the lack of function application support
17:53:46 <d-snp> mm_freak: well Data.Fixed seems to work with a Real number
17:53:52 <jfischoff> cool
17:53:53 <mgsloan> mm_freak: oh? I haven't looked at that yet
17:53:57 <mrsolo> applicative, allright thx
17:53:59 <d-snp> but the only real numbers are lossy numbers like Double right?
17:54:02 <mgsloan> jfischoff: https://github.com/mgsloan/lenq
17:54:06 <mm_freak> d-snp: nah, don't confuse the Real type class with anything resembling real numbers =)
17:54:15 <d-snp> eh oh
17:54:16 <applicative> mrsolo: this is a nice discussion by the author of vector http://unlines.wordpress.com/2009/09/29/squinting-at-fusion/
17:54:53 <mm_freak> d-snp: this is one of the confusing things about the standard type classes…  the Real class is for types, which support a conversion to rational numbers =)
17:54:59 <mm_freak> :t toRational
17:54:59 <randomclown> where is (<<)
17:55:00 <lambdabot> forall a. (Real a) => a -> Rational
17:55:41 <applicative> mrsolo: actually maybe the Data.Text.Fusion.Internal module is a better example, since it's not 'monadic'  Note the all important "Skip" constructor
17:55:58 <mgsloan> mm_freak: data-lens only gives you lenses for datatypes.  I'm mostly focusing on compound lenses.  This also allows you to write lenses while avoiding using records in the first place
17:56:20 <mm_freak> mgsloan: huh?  data-lens is very generic for monomorphic lenses
17:56:41 <d-snp> ah ok.. I guess what I'm looking for is anything that saves 3 integers, the whole, the rational and the power, as a single value I can perform some basic maths on
17:56:50 <mm_freak> mgsloan: (Eq a) => a -> Lens (a -> b) b
17:56:59 <mgsloan> mm_freak: ahhh yeah, I don't know that one.  I'm usually an fc-labels guy
17:56:59 <mm_freak> this is a lens for the result of a function =)
17:57:18 <jfischoff> data-lens is the probably the most simple lens lib
17:57:28 <jfischoff> or straight forward
17:57:32 <mgsloan> mm_freak: right.  I'll be able to write that very nicely :)
17:57:48 <mm_freak> mgsloan: as said, you may find yourself in a race with lens families =)
17:57:54 <mm_freak> lenses without a lens library, basically ;)
17:57:55 <mrsolo> applicative, information overload!  will go through those one by one :-)
17:58:40 <mgsloan> mm_freak: maybe!  I think lens families will just be another target
17:59:15 <mm_freak> mgsloan: with lens families you don't need any library to implement lenses…  you need just Functor
17:59:18 <mgsloan> I haven't worked on lenq in too long, though.. Been distracted with other things..
17:59:40 <applicative> mrsolo: sorry, I was studying it like crazy a few months ago :)
18:00:08 <mm_freak> d-snp: i don't understand…  what representation do you want for your numbers?
18:00:16 <mgsloan> mm_freak: ahh, that's nice!  I'll still be able to target it and avoid munging around with all those combinators, though :)
18:00:35 <mm_freak> mgsloan: what combinators?
18:01:10 <mgsloan> mm_freak: http://hackage.haskell.org/packages/archive/lens-family-core/0.0.0/doc/html/Lens-Family-Stock.html
18:01:26 <mgsloan> or building your own for that matter - you're going to need to write a getter and setter
18:02:53 <mm_freak> mgsloan: what's your problem with the combinators?
18:04:05 <mgsloan> Nothing, they're fine.  I just think it's interesting that you can write translation from a significant subset of Haskell to lenses.  "Bidirectional Haskell" orso
18:04:33 <mm_freak> mgsloan: not sure what you mean
18:04:35 <d-snp> mm_freak: any representation that is not lossy, it's for storing money
18:04:39 <c_wraith> I bet you can build SKI calculus out of it
18:04:41 <mgsloan> and I think that there are plenty of similar designs that have been left undiscovered, partially because of the disdain for TH
18:05:01 <mm_freak> d-snp: every representation is either lossy or memory-unbounded
18:05:10 <mm_freak> d-snp: Rational has that property
18:05:17 <mm_freak> > 1 % 3
18:05:18 <lambdabot>   1 % 3
18:05:19 <d-snp> well, I would lean to memory-unbounded :P
18:05:35 <mm_freak> > (2 % 3) + (1 % 6)
18:05:37 <lambdabot>   5 % 6
18:05:45 <mgsloan> mm_freak: The observation is that the pattern language and the expression language are very similar
18:05:49 <Nereid> > 1%5 - 1%7
18:05:50 <lambdabot>   2 % 35
18:06:14 <Nereid> > 2 % 4
18:06:15 <lambdabot>   1 % 2
18:06:29 <mm_freak> mgsloan: "pattern language"?  "expression language"?
18:06:32 <mgsloan> If you can convert patterns to expressions (other than @ patterns this works), and vice versa, then we can start doing bijection / lens like things
18:07:03 <mgsloan> yeah, Haskell is made up of a number of languages.  The pattern, type, expression, declaration, export, and pragma languages
18:07:15 <mgsloan> they're all very interrelated, sure.  Call them syntactic categories if you prefer
18:07:23 <mm_freak> yeah, but what are you getting at?
18:07:36 <mgsloan> just that this representation is more straightforward than learning an API
18:07:46 <mgsloan> or could be, IMHO
18:07:54 <Nereid> mm_freak: the patterns you can put on the left hand side of an = look similar to the expressions you can put on the right hand side
18:08:03 <Nereid> to some degree
18:08:07 <mm_freak> mgsloan: the API only defines convenience combinators
18:08:12 <mm_freak> in the case of lens families that is
18:08:17 <mgsloan> this subset of Haskell is the lens API to rule them all
18:08:35 <mm_freak> there are no lens-specific types or anything
18:08:36 <mgsloan> mm_freak: right. If you don't use them, though, you need to explicitly write getters and setters for every lens you want to make
18:09:01 <mm_freak> mgsloan: yeah…  but you need to do that anyway in some form
18:09:33 <mgsloan> true, my stuff is not at all a catch-all.  I can't do that function-update lens, for example.
18:10:49 <mgsloan> Haskell is a little bit like a butt-load of syntactic sugar ontop of a turbocharged lisp compiler with static typing.  I like this syntactic sugar a lot.  But saying "this is it, we're done with sugar." is short-sighted
18:11:12 <hpc> mgsloan: it's not on top of lisp
18:11:13 <mgsloan> this type of convenience can be very powerful, and transform how code is written
18:11:24 <mgsloan> hpc: I know. That's why I said "a little"
18:11:52 <mgsloan> maybe I shoulda said system-F with coercions for precision
18:12:40 <mm_freak> mgsloan: i'm not sure i'm following you…  you get convenient yet powerful lenses with no syntactic sugar at all
18:13:11 <mgsloan> Does lens-family do partial lenses?
18:16:29 <jfischoff> I don't see any Maybe's in their but its by the same author
18:16:30 <mgsloan> anyway, imagine writing lenses for the following:
18:16:30 <mgsloan> weigher = [lenq| \x -> case x of { (Just x, _) -> weight (torso x);   (_, (x:xs)) -> weight x + weigher (Nothing, xs) } |]
18:16:46 <sinelaw> Peaker, yo
18:17:00 <mgsloan> argh, I shouldn't have used +
18:17:14 <MostAwesomeDude> Aw, shuffleM is slow. :c
18:17:19 <mgsloan> let's pretend that it's a left-biased plus, e.g. it sets the dude on the left
18:17:20 <MostAwesomeDude> @hoogle shuffle
18:17:20 <lambdabot> package random-shuffle
18:17:43 <mgsloan> point is, if you make complicated lenses easy, I think people will write a lot more bidirectional code
18:17:50 <mgsloan> noone wants to play the puzzle game
18:20:59 <jfischoff> full on bidirectional programming might work best for languages created for that purpose. Like the Pi language and Boomerang. But in haskell would be nice too :)
18:21:32 <hpc> what do you mean by "bidirectional"?
18:21:39 <mgsloan> jfischoff: sure, but it seems like Haskell supports the right machinery for layering in an interpretation of such languages
18:21:48 <sinelaw> unprogramming language?
18:22:02 <mgsloan> hpc: The code that calculates a result can be driven backwards, with the user providing a result
18:22:14 <hpc> ah
18:22:15 <jfischoff> hpc: you can only right isomorphisms
18:22:18 <jfischoff> write
18:22:25 <hpc> like a parser/generator
18:22:25 <mgsloan> and either getting the inputs (bijection), or getting a transformation on inputs (lenses)
18:22:31 <mgsloan> yup
18:22:48 <sinelaw> sounds great for UI
18:23:42 <mgsloan> sinelaw: Yup!  Properties are used a ton in OOP UI frameworks
18:23:43 <sinelaw> if you could tell which inputs cause a certain UI appear
18:23:54 <sinelaw> *appearance
18:24:05 <mgsloan> (and properties are pretty much the OOP equivalent of lenses)
18:24:40 <jfischoff> mgsloan: I hope your right
18:26:18 <jfischoff> However, to really do bidirectional programming well I think you need a different type system from Haskell's
18:26:48 <mgsloan> Interesting! What's missing?
18:27:28 <jfischoff> fractional types. so with lenses a -> (a/b, b)
18:27:38 <jfischoff> a/b * b = a
18:27:52 <jfischoff> it gives you those types of ensurances
18:28:26 <jfischoff> also negative types
18:28:34 <jfischoff> for the a similar reason
18:29:06 <mgsloan> ahh, yeah, I still haven't read the duality of computation paper..  Soon!
18:29:46 <jfischoff> mgsloan: http://twanvl.nl/blog/haskell/isomorphism-lenses
18:34:23 <mgsloan> jfischoff: Ahh, that makes sense.  Interesting!  I wonder if proper residuals can be done with typeclass hackery...  At least for data structure lenses, this could be done by generating a bunch of datatype variants (so, really a "weakness" of the ADT system)
18:34:36 <XexonixXexillion> Is there an easy way to define an instance of Data without deriving it?
18:35:38 <mgsloan> Residual representations could also be useful for partial loading / marking when things are dirty / etc, while encoding what we depend on about the structure in the type
18:36:24 <applicative> XexonixXexillion: why wouldn't  you want to derive it? Just wondering
18:37:40 <XexonixXexillion> applicative: Because the type I have doesn't implement it, and the version of GHC I'm using is too old for StandaloneDeriving
18:37:56 <optimight> how to create package description file?   optimight@optimight:~$ cabal install
18:37:56 <optimight> cabal: No cabal file found.
18:37:57 <optimight> Please create a package description file <pkgname>.cabal
18:38:13 <mgsloan> jfischoff: Have you seen the paper by SPJ 'n such about unifying modules with records to get first class modules for Haskell?  They end up needing to embed references to terms into the types, to get proper skolemization, or something like that.  Seems somewhat relevant to this - you could have an ADT, and embed references to the terms that you've removed into the type.
18:39:32 <mgsloan> But, in summary, some other language might do bidi stuff in a somewhat more appealing way.  But we can do it damn well enough! :)
18:41:38 <optimight> how to create package description file?  While I tried "Cabal install" in the terminal It responded with " cabal: no cabal file found" "Please create a package description file <pkgname>.cabal" - how to do it?
18:41:49 <mauke> with a text editor
18:42:10 <Nereid> or "cabal init" may get you started
18:42:18 <monochrom> consider "cabal init". however, before that, consider the XY Problem
18:42:39 <Nereid> mmm
18:42:40 <optimight> mauke: What to write in the file?
18:42:55 <mauke> it is a mystery
18:43:06 <Nereid> optimight: why are you trying to create a package description file?
18:43:55 <optimight> Nereid: I am trying to run cabal update but not happening
18:44:08 <Nereid> so why are you running cabal install
18:44:44 <optimight> Nereid:  to check what packages are there?
18:44:47 <Nereid> and what do you mean, "not happening"?
18:44:51 <Nereid> yes, that's not what cabal install does
18:45:08 <Nereid> (what it does, surprise surprise, is install a package)
18:45:35 <optimight> Nereid: I mean no update is happening. (I kept monitoring Network traffic)
18:46:02 <monochrom> this is the XY Problem gone really bizarre
18:46:05 <Nereid> quite
18:46:27 <monochrom> for example, why not check the IP stack?
18:46:35 <Nereid> monochrom: I didn't know that had a name, thanks
18:46:37 <Nereid> :)
18:48:02 <optimight> Nereid: Please guide.
18:48:07 <hpaste> scooty-puff pasted “Why does this loop?” at http://hpaste.org/71305
18:48:23 <optimight> mauke: Why it mystery?
18:48:33 <monochrom> trouble-shoot your network first
18:48:43 <Nereid> even better, what does "cabal update" print?
18:48:52 <scooty-puff> i am not sure why this loops - it seems like the ref isn't pattern-matched after being red
18:48:55 <scooty-puff> *read
18:49:11 <optimight> mauke: my network is working excellent. 2 mbps
18:49:18 <monochrom> "cabal update -v3" may print more stuff
18:49:34 <Nereid> actually, is hackage.haskell.org down?
18:49:37 <applicative> optimight: cabal update takes a long time these days.
18:49:58 <optimight> Nereid: cabal update showed: "Downloading the latest package list from hackage.haskell.org
18:49:58 <optimight> "
18:50:02 <monochrom> eh? hackage is not responding here either
18:50:09 <XexonixXexillion> down for me too
18:50:12 <Nereid> well, I think we've found the problem
18:50:23 <monochrom> there goes your 2mbps
18:50:38 <applicative> yeah seems down
18:51:07 <XexonixXexillion> well, since I can't look up the docs on hackage, can someone remind me what the constructor for a Type in template Haskell is?
18:51:29 <optimight> Nereid:  hackage.haskell.org is down , right? I should try later, right?
18:51:29 <applicative> hackage.factisresearch.com has been down for a while too now
18:51:34 <monochrom> blessed are those who have built local haddocks
18:51:51 <applicative> optimight: yeah
18:52:32 <optimight> ahh...I was trying since last 4 hours...
18:52:46 <monochrom> constructors of Type are: ForallT, VarT, ConT, TupleT, ArrowT, AppT, and SigT
18:53:23 <monochrom> actually, ghci can tell you that too. :info Type
18:53:41 <optimight> but ...cabal install" should show me list of packages on my sytem , right?   It is says No cabal file found
18:53:50 <monochrom> does not
18:53:51 <Nereid> no, it should not
18:53:52 <XexonixXexillion> thanks
18:53:59 <Nereid> cabal install, as I said, installs a package
18:54:21 <Nereid> if you want a list of installed packages, ghc-pkg list
18:54:24 <optimight> How can I check the installed packages?
18:54:32 <applicative> ghc-pkg is the allknowing
18:54:44 <optimight> ghc-pkg
18:54:44 <monochrom> note that "cabal list" lies
18:55:27 <Nereid> yeah, that lists all available packages
18:55:34 <optimight> cabal list -  "lies" means?
18:55:39 <Nereid> not just the installed ones
18:55:56 <monochrom> it gives misinformation
18:56:13 <Nereid> nah, it gives correct information, just not the information you may have been expecting
18:56:34 <optimight> okay
18:57:45 <XexonixXexillion> panic! (The impossible happened)
18:57:49 <optimight> ghc-pkg list - Will this be giving correct information?
18:58:04 <monochrom> yes
18:58:28 <optimight> thank you for your guidance.
18:59:00 <JoeyA> Is it possible for a constraint to require an instance of this form?  instance Show a => Show (f a)
18:59:42 <applicative> ?
18:59:53 <scooty-puff> the intention to define a Show instance for everything of kind * -> *, or do you mean f to be a type constructor?
18:59:57 <applicative> what is the instance
19:00:04 <JoeyA> f is a type constructor
19:00:06 <JoeyA> Something like: instance (forall a. Show a => Show (f a)) => Show (Some f)
19:00:44 <hpaste> scooty-puff pasted “This doesn't loop...” at http://hpaste.org/71306
19:00:45 <JoeyA> Where data Some f = forall a. Some (f a)
19:00:52 <monochrom> IIRC, something about "cabal list <package_name>" can tell you which version you have installed, but it only shows one version, not all versions you have installed
19:01:01 * applicative knows the answer, but he doesnt want to hurt anyone
19:01:10 <optimight> monochrom: I just noticed only 3 names are written in different colour - ghc - 7.4.1, haskell2010 - 1.1.0.1 and haskell98 - 2.0.01
19:01:46 <optimight> monochrom: I think these three are only installed, right?
19:01:57 <monochrom> you think too much
19:02:07 <Nereid> base is totally not installed
19:03:17 <JoeyA> applicative: I am Death Incarnate.  What is the answer?
19:03:34 <optimight> Neried : base is totally not installed - means?   Do I need to correct my system?
19:03:44 <applicative> No, of course.  I'm trying to find an authoritative source, but failing
19:04:03 <applicative> JoeyA: so, maybe I'm wrong. It was on -cafe not too long ago.
19:04:28 <XexonixXexillion> I'm getting this error trying to compile some code I've written ghc: ./Foreign/Matlab/Primitives/Types.o: unknown symbol `__stginit_base_ForeignziCziTypes_dyn'
19:04:29 <monochrom> GHC user guide section 4.9 explains ghc-pkg
19:04:56 <XexonixXexillion> does anyone know how to fix it?
19:05:27 <JoeyA> applicative: Thanks anyway.
19:05:38 <applicative> I'm studying
19:06:19 <optimight> monochrom: I will go through the GHC guide. Thanks
19:07:21 <Nereid> optimight: I was being sarcastic
19:08:35 <monochrom> scooty-puff: in your paste and loop problem, the logic is flawed, if I guess the logic correctly
19:08:50 <JoeyA> applicative: Sorry in advance for wasting your time.
19:09:34 <optimight> Neried: No problem. I will become fool for five minutes , when I ask question. But when I get the answer - I no longer remain fool.   I am a learner - I will learn
19:09:35 <scooty-puff> monochrom: to be honest, the only real reason i'm doing it that way is i would like the Ref type to remain the same, but fill in parts as i go, which means this isn't exactly the best way i imagine..
19:09:59 <shlevy> Is hackage down?
19:10:03 <Nereid> yes
19:10:20 <monochrom> the meaning of Control.Monad.ST.Lazy is most likely not what you think. certainly not lazy enough for the way you readSTRef before newSTRef
19:10:38 <scooty-puff> k
19:11:00 <shlevy> OK. Is there an expected resolution or should I just wait until tomorrow?
19:11:21 <JoeyA> Knot-tying?
19:11:54 <scooty-puff> yes
19:12:13 <JoeyA> scooty-puff: Have you seen this?  http://mergeconflict.com/tying-the-knot-redux
19:12:43 <scooty-puff> o, hey, used to have a RecT monad for that
19:13:29 <mork> can anybody explain me what makes a monad different from sequential operations?
19:14:12 <XexonixXexillion> is there any Haskell equivalent type for a single bit that will work with the FFI?
19:14:15 <monochrom> you can't tie the knot at the STRef level. you can tie the knot at the Info level. and you don't need Control.Monad.ST.Lazy for that
19:14:29 <JoeyA> mork: With Monad, a computation can decide what to do next based on the result of a previous computation.
19:14:48 <monochrom> but even that is not an accurate description
19:14:52 <JoeyA> mork: You can sequence computations like this: sequence_ [putStrLn "Herp", putStrLn "Derp"]
19:15:32 <mork> JoeyA: So it does not have to be sequential?
19:16:21 <monochrom> see my http://www.haskell.org/haskellwiki/MonadFix for what fixST means, i.e., mfix. see my http://hpaste.org/69067 for what Control.Monad.ST.Lazy means
19:16:22 <JoeyA> mork: Ultimately, the actions performed are sequential.  But the sequence of actions is not fixed.
19:16:39 <mork> JoeyA: thanks
19:17:02 <JoeyA> e.g. loop = getChar >>= \x -> if isAlpha x then putStrLn "Thanks for the letter!" else putStrLn "Try again" >> loop
19:17:44 <JoeyA> mork: Notice how in this example, if you don't give an alphabetic character, the program will have different side effects.
19:17:52 <JoeyA> Namely, it will call getChar again.
19:18:02 <monochrom> "monad" is general, does not have to be sequential. "the IO monad" is sequential. largely.
19:18:04 <JoeyA> That isn't possible with a simple list of actions.
19:19:44 <mork> JoeyA: I think I get it
19:20:45 <mork> JoeyA: thanks for the help, Haskell is not easy to learn
19:22:07 <JoeyA> mork: No problem.  The good news is, it's quite to get help on IRC, Stack Overflow, etc. for Haskell.
19:22:41 <JoeyA> quite easy*
19:22:57 <mork> JoeyA: :)
19:23:40 <JoeyA> Removing important words from a makes it confusing.
19:26:47 <XexonixXexillion> unsafeInterleaveIO simply leaves execution until the result is evaluated, right?
19:27:39 <JoeyA> XexonixXexillion: Right.
19:27:49 <JoeyA> x <- unsafeInterleaveIO launchMissiles
19:28:04 <JoeyA> That won't cause serious international side effects until...
19:28:08 <JoeyA> x `seq` ...
19:28:28 <JoeyA> is evaluated
19:28:36 <monochrom> hGetContents is implemented by unsafeInterleaveIO, for example
19:28:49 <JoeyA> @quote semi-closed
19:28:49 <lambdabot> No quotes match. Do you think like you type?
19:30:02 <scooty-puff> grr, didn't install transformers with source enabled in docs..
19:30:16 <JoeyA> @quote hGetContents
19:30:16 <lambdabot> dmwit says: <dmwit> hGetContents does not close its handle.  <dmwit> hGetContents semicloses its handle.
19:30:28 <JoeyA> scooty-puff: cabal unpack transformers
19:31:31 <scooty-puff> heh, i like how strict StateT is lazy for mfix - i mean, it makes sense..
19:32:31 <scooty-puff> JoeyA: i didn't even realize it kept the source local..
19:32:42 <scooty-puff> (after compilation anyways)
19:36:45 <mork> is it easy to use Haskell with C?
19:37:28 <monochrom> I think yes
19:37:34 <bgamari> mork: There is a nice FFI to call from Haskell to C
19:37:53 <mork> bgamari: what is it called?
19:38:00 <bgamari> mork: The other direction is possible but I have no experience with this
19:38:03 <JoeyA> foreign import ccall "stdio.h puts" c_puts :: CString -> IO ()
19:38:24 <mork> JoeyA: I'll copy that
19:38:25 <JoeyA> mork: It's provided by the language.  You don't have to go out and get it ;-)
19:39:12 <mork> JoeyA: thanks again
19:39:24 <monochrom> my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml contains some toy examples of haskell calling c calling haskell calling c...
19:40:01 <monochrom> but they are toys useful for showing multithreading behaviour, not exactly useful for whatever you use
19:40:36 <scooty-puff> is there any reason to prefer one type of bottom value over another?  looping vs. error?
19:40:57 <mork> monochrom: thanks for the link
19:41:07 <sinelaw> are you saying bottoms are not created equal? (sorry couldn't resist)
19:41:35 <JoeyA> scooty-puff: Well, an infinite loop has the undesirable side effect of raising the CPU temperature.
19:41:48 <monochrom> hrm, something is wrong with my web page provider
19:41:53 <kallisti> and errors have the undesirable side effect of not being loops
19:41:58 <kallisti> so the answer is: both have difference purposes.
19:42:23 <scooty-puff> so here's the problem (paste coming)
19:42:55 <monochrom> temporary glitch. or it's just my web browser.
19:46:21 <applicative> http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml doesn't work.
19:46:41 <sinelaw> so, yesod or snap?
19:47:12 <hpaste> scooty-puff pasted “Ref, symbol tables, etc.” at http://hpaste.org/71307
19:47:26 <monochrom> keep trying. there seems to be a server glitch. sometimes you get through
19:47:36 <scooty-puff> anyways, hopefully that remotely clear
19:48:03 <Modius> Is hackage down?
19:48:15 <scooty-puff> it is
19:48:20 <applicative> we were thinking so
19:48:37 <applicative> monochrom: safari says its because there are too many hits on your server
19:48:37 <mork> it is down
19:48:51 <monochrom> safari is just guessing
19:48:58 <stepkut> sinelaw: sinelaw: happstack of course
19:49:07 <sinelaw> stepkut, why so?
19:49:11 <dmwit> I have discovered a time where you can write "foo = bar foo" but not "foo = fix bar".
19:49:13 <sinelaw> (i have no opinion yet)
19:49:15 <applicative> monochrom: I know
19:49:40 <applicative> stepkut is a happstack developer sinelaw
19:49:42 <shachaf> dmwit: Is it some weird rank-n types thing or something?
19:49:42 <monochrom> it is a "connection reset" out of the blue at the real level
19:50:00 <dmwit> shachaf: H98
19:50:05 <stepkut> sinelaw: it's well documented and flexible, offers optional support for type-safe urls, various html templating styles and more
19:50:18 <shachaf> dmwit: What is the time?
19:50:43 <dmwit> 22:50
19:50:56 <sinelaw> stepkut, where as the others are not / don't?
19:51:24 <shachaf> dmwit: Ah.
19:51:50 <shachaf> Yes, between 22:45:00 and 22:59:59 Haskell has a lot of trouble with "foo = fix bar".
19:51:57 <shachaf> It's a known bug in the spec.
19:52:09 <dmwit> ...lolwut
19:52:33 <shachaf> 19:48 <dmwit> I have discovered a time where you can write "foo = bar foo" but not "foo = fix bar".
19:52:35 <mietek> Any other place to download Haskell Platform from?
19:52:54 <sinelaw> shachaf, I guess that time would be 19:48
19:53:09 <hpaste> “david feng” pasted “remove first comment in a directory all .h and .c file” at http://hpaste.org/71308
19:53:18 <mietek> Wasn't there a hackage mirror somewhere?
19:53:35 <dmwit> shachaf: hahaha
19:53:38 <dmwit> now I get it =)
19:53:46 <applicative> there was factisresearch.com, on and off for the last several months, mietek, now off
19:53:48 <stepkut> sinelaw: they are all rather similar in many ways. It is mostly the details that are different. For example, if you want type-safe urls, you can use web-routes with Happstack or Snap (or use yesods).. but using it with happstack is going to be better documented and supported since I wrote it (web-routes)
19:53:53 <mietek> Aw.
19:53:57 <shachaf> dmwit: (Is this a puzzle?)
19:54:20 <dmwit> No, I was just hoping somebody would ask me what it was.
19:54:31 <dmwit> It's bar is Branch from my answer here:
19:54:42 <dmwit> http://stackoverflow.com/a/11422333/791604
19:54:42 <shachaf> dmwit: 19:49 <shachaf> dmwit: What is the time?
19:54:43 <sinelaw> stepkut, ok i'll check it out, hopefully soon
19:54:59 <stepkut> sinelaw: personally, I find the snap API to be too barebones.. but the snap people think the Happstack API has too many features.. so it depends on you :)
19:55:04 <dmwit> shachaf: Oh, I thought that was just a non-sequitur. I really need some sleep.
19:55:43 <stepkut> sinelaw: in generally, there is no silver bullet feature that makes one framework clearly superior to the others.. it is largely a matter of taste
19:56:03 <jmcarthur> dmwit: does it have anything to do with polymorphic recursion?
19:56:04 <sinelaw> stepkut, actually i just starting trying yesod, i understand it's a matter of taste
19:56:06 <dmwit> shachaf: In other words, the pattern is when "foo" is polymorphic and "bar" doesn't fit the type scheme "a -> a" very well.
19:56:09 <dmwit> jmcarthur: yes
19:56:12 * jmcarthur can't use his browser at the moment
19:56:16 <jmcarthur> ah
19:56:23 <sinelaw> stepkut, first time I'm doing web stuff in haskell, so we'll see how it goes
19:57:12 <stepkut> sinelaw: right.. for everything in yesod, there is a happstack equivalent.. like yesods type-safe routing system vs web-routes, persistent vs acid-state, hamlet vs HSP. The devil is in the details :)
19:57:34 <solrize> hackage down?
19:57:41 <sinelaw> yeah, hard to tell without trying both out
19:57:45 <stepkut> solrize: sort of
19:58:03 <solrize> tx
19:58:24 <stepkut> solrize: for example, this link works for me, http://hackage.haskell.org/packages/archive/reactive/0.11.5/doc/html/Data-Max.html
19:58:56 <solrize> not for me
19:59:03 <stepkut> yeah, not it is not
19:59:05 <applicative> i think your  browser is somehow storing a copy
19:59:20 <stepkut> applicative: could be
20:00:59 <shachaf> dmwit: What's bar in your example?
20:01:33 <hpaste> “david feng” annotated “remove first comment in a directory all .h and .c file” with “remove first comment in a directory all .h and .c file (annotation)” at http://hpaste.org/71308#a71309
20:02:40 <dmwit> shachaf: Branch
20:02:53 <shachaf> x = Branch x?
20:03:18 <dmwit> right
20:03:23 <shachaf> I don't think that type-checks.
20:03:41 <monochrom> how is Branch defined?
20:03:48 <mm_freak> stepkut, sinelaw:  yesod and snap are very different from each other
20:03:54 <shachaf> data PBT a = Leaf | Branch (PBT (a,a)) deriving (Eq,Ord,Show,Read)
20:04:07 <mm_freak> they have very different ideas about modularity
20:04:09 <monochrom> ooh, that's funky
20:04:16 <shachaf> Anyway, it's similar to the (\f x -> f (f x)) thing, except infinite, which is a bit weird because I'd think it'd require an infinite type.
20:04:18 <dmwit> shachaf: Try giving it a type signature.
20:04:23 <mm_freak> yesod has subsites, snap has snaplets
20:04:47 <shachaf> dmwit: Oh, odd.
20:04:50 <dmwit> yeah =)
20:05:04 <monochrom> yeah, now I can see how fix fails. special type-checking technicalities
20:05:13 <stepkut> mm_freak: go on
20:05:33 <mm_freak> i think that snap is easier to understand, but yesod is more powerful in its static guarantees and what it does out of the box
20:05:33 <shachaf> Ugh, this polymorphism sure is annoying.
20:05:45 <monochrom> polymorphic recursion
20:06:36 <stepkut> mm_freak: I'm not sure I like the use of type classe for sub-sites.. but I can't say why yet
20:06:47 <shachaf> This is almost like rankntypes.
20:06:55 <shachaf> Well, except for the rankn bit. :-)
20:07:08 <shachaf> But annoying in a similar way.
20:07:57 <mm_freak> stepkut: well, subsites are really what their name says, while snaplets are a more general concept…  but snaplets are very dynamic and need some manual glue, while yesod's type class approach to additional features is more opaque and harder to understand
20:08:22 <shachaf> Can you make a special fix that works with Branch?
20:08:35 <stepkut> mm_freak: seems weird to me that things like defaultTemplate come from the type class
20:08:37 <monochrom> wait, x = Branch x gives me a type error too, occurs-check. ghc 7.4.2
20:08:42 <stepkut> well, maybe not weird, but inflexible
20:08:44 <mm_freak> stepkut: it makes sense for yesod
20:08:47 <dmwit> monochrom: Give it a type signature.
20:08:48 <shachaf> monochrom: let x :: PBT a; x = Branch x
20:08:55 <monochrom> ok I see
20:08:57 <mm_freak> stepkut: nah, it's flexible =)
20:09:00 <shachaf> I thought things were supposed to be inferrable in Haskell 98!
20:09:32 <monochrom> haskell 98 explicitly says that polymorphic recursion is supported but you have to hand-type it
20:10:04 <mm_freak> stepkut: bottom line:  if you want to get stuff done without necessarily understanding all of what you're doing, go with yesod…  it really does everything for you…  however, if you like a more compositional style of web development, snap is for you
20:10:09 <shachaf> Ah, yes, I've run into that before, actually.
20:10:19 <stepkut> mm_freak: when is happstack for you?
20:10:31 <mm_freak> stepkut: probably only when you're used to it
20:10:46 <stepkut> mm_freak: oh ?
20:10:53 <mm_freak> snap is a better happstack
20:10:57 <stepkut> mm_freak: go on
20:11:13 * kallisti has used yesod so far and is enjoying it.
20:11:25 <kallisti> I can't compare it to something I know nothing about.
20:11:44 <mm_freak> stepkut: the idea of happstack was the compositional style, which snap adopted and extended by a modularity abstraction
20:12:01 <stepkut> mm_freak: so, snaplets are the primary thing that makes snap better?
20:12:29 <mm_freak> stepkut: snaplets and the mature configuration/deployment options
20:13:10 <sinelaw> kallisti, ignorance is bliss. I'm considering to not even _start_ using it.
20:13:19 <mm_freak> yesod is great
20:13:20 <sinelaw> any of them
20:13:28 <stepkut> mm_freak: you mean, having to put config files in certain directories and stuff?
20:13:55 <mm_freak> but it's really written for productivity, giving up some conceptual elegance
20:13:55 <Ralith> In parsec, I have a stateless parser (currently :: Parser Foo) and I'd like to use it as part of a stateful parser (GenParser Foo Bar Baz)
20:14:15 <Ralith> it seems like this can't be done directly
20:14:30 <mm_freak> stepkut: nah, one perhaps stupid example is this:  commandLineConfig emptyConfig >>= flip serveSnaplet myAppInit
20:14:41 <Ralith> er, those aren't the same Foo
20:14:46 <stepkut> mm_freak: what is great about that ?
20:14:49 <Ralith> and both take Chars as input
20:14:52 <mm_freak> stepkut: that turns the program into a full-blown command line interface =)
20:15:03 <stepkut> mm_freak: ?
20:15:16 <Ralith> can anyone advise how to do this?
20:15:32 <mm_freak> it's just easy to deploy and switch between testing and production, for example
20:15:48 <stepkut> mm_freak: I don't see why
20:16:03 <dmwit> Ralith: Make your stateless one more polymorphic...?
20:16:10 <dmwit> Like, polymorphic over the state type?
20:16:27 <Ralith> dmwit: so just change the type to forall a. GenParser Char a Foo --?
20:16:34 <mm_freak> stepkut: i'm comparing to happstack right now (yesod has something similar, perhaps more powerful, but controlled through cabal instead of the command line)
20:17:06 <dmwit> Sure, why not.
20:17:44 <Ralith> oh hey
20:17:48 <Ralith> that Just Worked
20:17:59 <Ralith> o/
20:18:23 <mm_freak> anyway, summary:  if you want maximum productivity, go with yesod…  if you want high productivity and more beautiful code, go with snap…  if you're used to happstack and perhaps already have some site template, go with that one
20:18:55 <sinelaw> and for minimum productivty and ugly code....
20:19:06 <Ralith> dmwit: I guess I was kind of expecting there to be a type like Parser that's polymorphic over state for the convenience of defining reusable parser bits.
20:19:09 <mm_freak> sinelaw: there is a CGI library on hackage =)
20:19:11 <stepkut> mm_freak: commandLineConfig is just a command-line parser around the Config type, yes?
20:19:53 <mm_freak> stepkut: yeah…  you can make it pass stuff to your application as well (extendedCommandLineConfig)
20:20:29 <stepkut> doesn't really sound that exciting
20:20:38 <stepkut> certainly not hard to add though
20:21:09 <mm_freak> stepkut: it's just convenient…  makes deployment very easy
20:21:24 <stepkut> happstack has a similar parseConfig function...
20:21:27 * applicative considers that acid-state is beautiful
20:22:22 <stepkut> though.. it could use some attention
20:22:58 <mm_freak> stepkut: let me state it this way:  with snap and yesod deployment becomes a single command…  out of the box
20:23:36 <applicative> its a riddle that someone could think that beautiful code could be written with the enumerators package
20:24:26 <stepkut> mm_freak: but.. to add that to happstack, we would just need to add a few extra command-line flags to parseConfig ?
20:24:28 <mm_freak> applicative: you're not really exposed to enumerators
20:24:51 <mm_freak> stepkut: probably
20:25:16 <mm_freak> stepkut: IIRC there is no real application type in happstack, so application configuration may be a bit tricky to combine with that
20:25:18 <stepkut> to deploy an app, you also have all the issues of how it gets started (init scripts), how the assets and other files get installed, etc..
20:26:08 <mm_freak> stepkut: i have assumed that the former is already set up, and the latter is done either by darcs/git/whatever or by the site program itself
20:26:27 <hpaste> monochrom pasted “funky fix” at http://hpaste.org/71310
20:26:56 <monochrom> shachaf, dmwit: that paste :)
20:27:11 <dmwit> monochrom: The type is a bit... specific. =P
20:27:31 <monochrom> yeah, can't help it
20:28:20 * dmwit nods
20:28:23 <stepkut> mm_freak: those seem like much more significant problems than having a few extra command-line flags predefined..
20:29:29 <mm_freak> monochrom: huh?  P appears to be isomorphic to data P = B P
20:29:55 <mm_freak> stepkut: the point is that you can configure the application, not just the port
20:31:12 <dmwit> mm_freak: Just for fun, imagine there's a ... | Leaf a clause.
20:31:46 <monochrom> it is a reduced version of "data P a = Leaf | B (P (a,a))". the Leaf is interesting at the value level but uninteresting at the type level. the paste is about the type level.
20:32:03 <mm_freak> i see
20:32:35 <stepkut> mm_freak: ok, so snap is apparently easier to deploy because it can generate more command-line flags automatically, and it has snaplets.. what else?
20:34:17 <mm_freak> stepkut: other than that it's really just the stuff you find on hackage and some of the predefined snaplets
20:34:28 <mm_freak> authentication, heist, etc.
20:34:57 <mm_freak> interfaces to various DBMSs, acid-state, some web services, etc.
20:35:07 <stepkut> yes.. happstack has all that stuff..
20:35:52 <mm_freak> then go with happstack
20:36:08 <mm_freak> you sound like a happstack developer defending happstack ;)
20:36:20 <mm_freak> and i'm tired of this discussion honestly
20:36:30 <stepkut> mm_freak: no, I am a happstack developer trying to find out what other people's perceptions are
20:36:48 <enjoylife> Is there a hackage mirror up ???
20:37:00 <mm_freak> stepkut: then snaplets are most relevant
20:37:45 <shachaf> monochrom: Yep, that works.
20:38:06 <shachaf> Kind of annoying, in the same way as \f x -> f (f x), but more extreme.
20:38:28 <solrize> does anyone know of acid-state benchmarks?  i agree it is beautiful but i remember a blog post a while back indicating that it bogged down horrifically once the db was above some relatively modest size
20:38:54 <mm_freak> stepkut: apart from that snap isn't that different from happstack…  if you want something with a very different you should have a look at yesod
20:39:10 <mm_freak> it has some unique features like amazing static guarantees
20:39:16 <stepkut> mm_freak: oh ?
20:39:51 <mm_freak> solrize: how fast acid-state is is up to you…  you can't really benchmark it
20:40:15 <mm_freak> solrize: it depends on the size of your transactions, the frequency of checkpoints, etc.
20:40:30 <stepkut> mm_freak: what are some static guarantees it provides that happstack does not?
20:41:09 <mm_freak> stepkut: that question doesn't really make sense
20:41:31 <mm_freak> stepkut: it's like asking what haskell has that brainfuck doesn't have =)
20:41:52 <stepkut> mm_freak: you said that yesod has unique features like amazing static guarantees.. what are these amazing static guarantees?
20:42:12 <stepkut> mm_freak: for example, happstack has had type-safe urls since before yesod existed..
20:42:19 <stepkut> mm_freak: and type safe form processing
20:42:55 <stepkut> mm_freak: the template systems like HSP use types to automatically escape strings
20:43:01 <mm_freak> anyway, to answer your question:  it comes builtin with typesafe URLs, typesafe, XSS-safe templates, a very nice CSS language, type-safe database access, type-safe forms, etc.
20:43:05 <stepkut> mm_freak: jmacro even does syntax checking
20:43:13 <stepkut> yes, happstack has all those things
20:43:22 <mm_freak> really, i'm tired of this discussion
20:43:33 <mm_freak> please just try it out
20:43:42 <stepkut> mm_freak: I have
20:44:02 <mm_freak> yesod brings all that OOTB with very little code
20:44:12 <stepkut> mm_freak: And I see little that it offers over happstack, most of its solutions seem more limited
20:44:37 <mm_freak> stepkut: that's really the same discussion as between ocaml and haskell
20:45:14 <stepkut> mm_freak: sure.. but to claim that all those things are 'unique amazing features of yesod' when happstack has them as well is just wrong
20:45:31 <mdmkolbe> Help! Why is pdflatex using Type 3 fonts when I do "\text{\texfamily \$}"? It doesn't seem to happen for any character other than "\$".  (This code is generated by lhs2TeX.)  My publisher doesn't allow Type 3 fonts.  (It looks like lhs2TeX defines "\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}")
20:46:41 <kfish> stepkut, mm_freak: http://www.urbandictionary.com/thesaurus.php?term=unique
20:46:43 <mm_freak> stepkut: i know that happstach has those, because you can make it have anything you want
20:47:02 <mm_freak> that's why the question wasn't sensible in the first place
20:47:06 <Axman6> mdmkolbe: this is not #latex...
20:47:08 <stepkut> mm_freak: 'make it have' is an understatement though. It has supported, documented solutions for those things
20:47:38 <mdmkolbe> Axman6: oh, sorry, wrong window
20:48:04 <mm_freak> stepkut: in yesod it's the standard way to go and requires no setup…  you would need setup /not/ to have these things
20:48:44 <mm_freak> all the various parts of yesod work well together to support these things
20:49:13 * sinelaw "accidentally" triggered a flamewar
20:49:19 <mm_freak> the widget system is written in a way that the type-safety of URLs and forms is captured in the templates, for example…  again, no extra code
20:49:40 <mm_freak> that's how it's unique in yesod
20:49:48 <mm_freak> it's monolithic
20:50:10 <stepkut> there is much similar integration in happstack.. for example with web-routes and HSP you can do <a href=SomeRoute>some route</a> just like the hamlet+yesod type-safe url approach
20:50:45 <stepkut> but, it is certainly true that yesod presents the 'one true way' to write a yesod web app
20:51:04 <stepkut> where-as happstack usually gives you a few options
20:51:09 <mm_freak> yeah, that's the point…  yesod isn't written for maximum composability and modularity
20:51:34 <trthomps> anyone know an eta on hackage.haskell.org coming back up?
20:51:36 <mm_freak> you're really developing yesod applications
20:51:55 <kallisti> why is cabal suddenly interpreting a lack of version to mean "the newest version"
20:51:59 <stepkut> mm_freak: right.. the more yesod-ish approach exists in clckwrks, which does pick particular solutions and impose specific ways of doing things, plugins (similar to sub-sites), etc
20:52:02 <kallisti> is this a new change?
20:52:23 <kallisti> I've been having all sorts of difficulties getting my yesod package to resolve dependencies
20:53:13 <kallisti> and it seems what's happening is that my package depends on another package without a specified version, cabal tries the newest one, finds that yesod packages depend on older versions, and then gives up.
20:53:26 <kallisti> shouldn't it instead try older version of the packages my package depends on?
20:53:35 <mm_freak> stepkut: i still doubt that you get the same conciseness…  the effect/code ratio is very high in yesod, which is why it's very productive…  particularly if you use 'persistent'
20:53:59 <mm_freak> note:  i stopped using 'persistent' some time ago
20:54:40 <mm_freak> and snap feels better to work with, if you actually do want to have some flexibility
20:54:53 <mm_freak> (in the way you want to do things that is)
20:55:26 <stepkut> mm_freak: so, you would want to see code examples disproving this?
20:55:36 <mm_freak> stepkut: sure
20:56:02 <mm_freak> but please, no TH/QQ code…  that's what i'm trying to get away from =)
20:56:59 <stepkut> mm_freak: well, that is something we do try to minimize in happstack.. limiting QQ to domains where a syntax already exists (such as javascript) and TH to things that are very similar to 'deriving Eq, Ord, etc', such as deriveSafeCopy
20:57:10 <kallisti> uh, so I did cabal info cabal-install
20:57:16 <kallisti> Versions installed: [ Unknown ]
20:57:20 <kallisti> could this be a problem?
20:57:39 <stepkut> mm_freak: but, for type-safe url routing, we prefer to use a composable and extensible combinator language like boomerang instead of a limited QQ like the yesod quasi thing (though, we can offer that too)
20:57:43 <kallisti> $ cabal --version
20:57:43 <kallisti> cabal-install version 0.14.0
20:59:06 <mm_freak> stepkut: i actually liked boomerang, but it seemed to be quite code-heavy without TH
20:59:58 <kallisti> looks like hackage is down?
21:00:12 <ag90> kallisti: For me too.
21:00:13 <mm_freak> it is
21:00:23 <Nereid> has been for a while now
21:00:30 <stepkut> mm_freak: well.. the only TH was for deriving the combinators for the constructors.. which is about as exciting as deriving Eq, Ord, Read, Show, etc, instances by hand.. most of the time the automatic method is fine and very predictable
21:00:45 <mm_freak> i hope that it's back soon…  i'm inclined to try happstack again =)
21:00:58 <stepkut> mm_freak:  :)
21:01:27 <kallisti> are the repos still running?
21:01:44 <mm_freak> stepkut: what about speed?  snap-server and warp seem to have better performance according both to official and my own benchmarks
21:02:11 <mm_freak> and the last time i checked happstack was very String-heavy
21:02:27 <stepkut> mm_freak: the last time I ran benchmarks snap and happstack were on par, and about 2-3x slower than warp
21:02:31 <kallisti> has anyone else has issues with cabal treating -any to mean "newest"?
21:02:35 <kallisti> *had
21:02:52 <mm_freak> stepkut: is it still using String that much?
21:03:24 <stepkut> mm_freak: it does some places. It is far more Text based these days.
21:03:42 <stepkut> mm_freak: Happstack 8 will get a more modern and faster HTTP backend
21:03:54 <stepkut> mm_freak: in theory, based on pipes 3.0.. but only if pipes 3.0 proves up to the job
21:04:08 <stepkut> mm_freak: though when pipes 2.1 gets the parser, we will be doing a test backend
21:04:39 <stepkut> mm_freak: using a pipes-core I wrote a backend that was 2-3x faster than warp.. but did not include timeouts.. which would slow it down a bit
21:04:44 <mm_freak> stepkut: what about modularity?  i really like snaplets
21:06:14 <stepkut> mm_freak: We are working on our modularity solution in clckwrks, and it will be lifted out of that. In clckwrks we have both plugins and themes. plugins are for things like media galleries, bug trackers, or whatever, and themes define how the site looks (a combination of html, css, and Haskell code).
21:06:24 <stepkut> the plugins stuff is based on web-routes, so it is type-safe like yesod subsites
21:06:40 <stepkut> but.. it is not there yet
21:07:04 <stepkut> I would definitely consider clckwrks/happstacks current snaplets/subsites functionality to be behind snap and yesod
21:07:06 <mm_freak> i see…  well, the modularity options were the main reason for me to move away from yesod
21:08:01 <stepkut> fixing that is a pretty high priority thuogh
21:08:29 <mm_freak> when do you expect that to arrive on hackage?
21:08:46 <stepkut> later this year
21:09:08 <mm_freak> are any of the happstack developers using happstack commercially?
21:09:14 <stepkut> yes
21:09:44 <sinelaw> stepkut, examples?
21:09:48 <stepkut> there are also non-happstack developers using it commercially
21:10:19 <ThePro> hey, is there a way to get a time in seconds (like 3,24) using getClockTime?
21:10:33 <mm_freak> i'll give it a try once hackage is back on…  but for now i'll likely stick with snap, until you have a solution for modularity
21:11:11 <stepkut> mm_freak: that is fine
21:11:17 <mm_freak> @hoogle getClockTime
21:11:18 <lambdabot> System.Time getClockTime :: IO ClockTime
21:11:33 <mm_freak> ThePro: i recommend switching to the 'time' package
21:11:59 <ThePro> mm_freak: i am forced to use getClockTime by my professor
21:12:23 <Nereid> ThePro: what if you look inside the ClockTime data type
21:12:27 <mm_freak> ThePro: then just deconstruct ClockTime
21:12:32 <Nereid> ^
21:12:45 <ThePro> mm_freak: he wants the time in seconds with 3 digits after the point
21:13:10 <stepkut> mm_freak: I definitely recommend you check out Happstack 8 when it comes out. That should have the new http backend and the plugin stuff.
21:13:19 <mm_freak> ThePro: one easy but potentially lossy way is to convert ClockTime to a Double and printf it
21:13:36 <ThePro> mm_freak: ok thx i will try
21:13:39 <kallisti> I'm so confused...
21:14:25 <kallisti> (about cabal doing things it's never done before)
21:14:48 <mm_freak> stepkut: ok, great…  but still i think you should be more open when testing yesod…  i have used it for a long time, and it is quite unique when it comes to combining high productivity with static guarantees
21:15:22 <mm_freak> and things like convenient functions do play an important role there, even though here they sound like a minor thing
21:15:47 <bluej774> What's going on with the Hackage website?
21:15:53 <Nereid> ThePro: or, just use the pair of Integers you get directly, writing the decimal point yourself
21:15:55 <monochrom> kallisti: with cabal-install 0.14, -v3 actually outputs useful information
21:16:04 <mm_freak> bluej774: currently down…  check again later
21:16:08 <kfish> kallisti, have you tried cabal-meta?
21:16:23 <bluej774> mm_freak, how long has it been down?
21:16:25 <trthomps> any word on hackage.haskell.org being down?
21:16:53 <mm_freak> bluej774: i've been installing stuff a few hours ago, other than that i can't tell
21:16:54 <bluej774> trthomps, that's why I'm here, too
21:16:55 <kallisti> monochrom: yes. hundreds of lines of very "useful" information
21:17:22 <trthomps> :(
21:17:28 <trthomps> wanted to install xmonad
21:17:29 <trthomps> oh well
21:17:31 <monochrom> well it's useful to me in explaining why it chooses such-and-such version. it's a direct explanation
21:19:18 <kallisti> monochrom: I need a graph output to visualize this thing...
21:19:52 <kallisti> I'm writing a yesod app, so there's literally hundreds of dependencies that cabal is spitting out information on
21:21:37 <donri> mm_freak: happstack is a steeper learning curve than yesod but has similar tradeoffs as learning haskell; it provides way more flexibility and static guarantees than either yesod or snap, and i think in the end it ends up meaning higher productivity
21:22:36 <mm_freak> donri: fair enough, although actually i found happstack easier to learn than yesod
21:22:43 <mm_freak> and snap was the easiest
21:23:18 <mm_freak> donri: if you are experienced in haskell, happstack shouldn't be that difficult to learn
21:23:28 <donri> well "happstack" these days is basically just the server :) but i think learning the whole stack may be more work... unless you're already skilled at haskell, in which case happstack is the most "native"
21:24:32 <donri> if you're somewhat new to haskell but not web programming, yesod and snap will be way more familiar
21:25:44 <mm_freak> depends on your mindset
21:25:54 <donri> yea
21:25:55 <mm_freak> if you like to understand what you're doing yesod will be quite difficult
21:26:00 <solrize> mm_freak, do you think conduit is easier to use than the alternatives?
21:26:07 <mm_freak> it's easy to /use/, but hard to understand
21:26:14 <mm_freak> solrize: yes
21:26:22 <mm_freak> solrize: partly
21:26:25 <bluej774> This may sound like a flame, but it's not intended to be.  Is Haskell development dead?  I haven't heard anything new from the community since early last year.
21:26:39 <solrize> bluej774, wut?
21:26:44 <mm_freak> solrize: i don't know pipes, so i can't judge, but it's definitely easier to use than enumerators
21:26:45 <stepkut> bluej774: say what?
21:26:51 <donri> bluej774: wherefrom do you "hear news"?
21:27:01 <mm_freak> bluej774: then your news source is broken =)
21:27:02 <solrize> @where hcar
21:27:02 <lambdabot> http://www.haskell.org/communities/
21:27:04 <dylukes> Parallel Haskell, all the shit in GHC 7.4, Safe Haskell, pipes/conduits, trifecta, diagrams fleshing out...
21:27:20 <bluej774> Oh, shit.  Parallel haskell exists now?
21:27:20 <mm_freak> bluej774: haskell development is more active than ever before
21:27:22 <donri> lenses
21:27:38 <stepkut> GHC on ARM
21:27:48 <donri> bluej774: oh dear ^_^ even cloud haskell exists
21:27:56 <solrize> i went to alexj's talk about happs before it was happstack... it seemed brilliant ... i don't think it used any enumerators or anything at the time.  i'm not sure about now
21:28:00 <mm_freak> even a haskell-to-javascript compiler exists =)
21:28:14 <mgsloan> even a few different haskell-to-javascript compilers!
21:28:18 <solrize> i guess it just had handwritten io actions running in threads
21:28:20 <bluej774> I was just looking for GHC on ARM just today and all I saw was people talking about wanting it.
21:28:23 <stepkut> solrize: still uses the lazy IO backend.. we are waiting for pipes 3.0 and then we will see what the field looks like
21:28:23 <mgsloan> (at varying levels of completeness)
21:28:36 <mm_freak> solrize: you don't really need to understand those stream processing abstractions to write web apps with any of the "big" frameworks
21:28:38 <solrize> stepkut, hmm
21:28:39 <stepkut> bluej774: I believe GHC on ARM is built-in now
21:29:43 <mm_freak> stepkut: is there a quickstart into happstack for people familiar with both haskell and web development?
21:29:57 <otters> oh, wow
21:29:58 <mm_freak> (that is i don't want a haskell tutorial)
21:30:01 <otters> lambdabot can't find readline again
21:30:16 <otters> why is it that everything else compiles fine with -lreadline
21:30:18 <otters> but lambdabot does not?
21:30:49 <bluej774> Why is OpenGL so stagnant on Haskell then?  That's what I want to do.
21:31:05 <mm_freak> bluej774: OpenGL stagnant?  what exactly about it?
21:31:13 <donri> mm_freak: there are two primary document besides the haddocks; the happstack-lite tutorial and the general crash course
21:31:38 <donri> mm_freak: neither is a haskell tutorial, although they might explain some things when they come up ...
21:33:06 <otters> ooh wait
21:33:10 <otters> maybe it's because I have 32 bit haskell platform
21:33:16 <otters> but libreadline.dylib is built for 64-bit
21:33:39 <bluej774> mm_freak, It seems to be trapped in the 1.1 fixed function pipeline era.  Plus, the depth buffer and double buffer weirdness?
21:33:49 <otters> is that possibly the error?
21:34:12 <anon33233> Hi, is there something wrong with hackage?.  I can't download packages nor go to the site?
21:34:20 <monochrom> yes, hackage is down
21:34:24 <stepkut> mm_freak: so, starting at the very beginning, here is the yesod hello world, http://www.yesodweb.com/book/basics, and here is a similar happstack hello world, http://hpaste.org/71311. One place the yesod version is a bit more concise, is that the mkYesod function automatically generates the equivalent of the route function.. but in Happstack, we are writing it by hand. Is that the type of TH/QQ you are trying to get away from? Or
21:34:24 <stepkut> something you think is ok?
21:34:28 --- mode: ChanServ set +o monochrom
21:34:29 <otters> son of a bitch
21:34:33 <otters> I need to download haskell platform 64-bit
21:34:35 <anon33233> Ok, thank you for the info.
21:34:38 <bluej774> anon33233, hackage is mysteriously down and no one knows why or how to fix it.
21:34:47 --- topic: set to '["hackage is down","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]' by monochrom
21:34:51 <mm_freak> bluej774: according to the documentation the OpenGL package corresponds to OpenGL 3.2
21:34:55 --- mode: monochrom set -o monochrom
21:35:01 * stepkut could certainly add a mkWebRoutes function that generated a routes function, etc
21:35:19 <bluej774> mm_freak, where do you see that?
21:35:24 <anon33233> I see.  Hope it's fixed, soon.
21:35:24 <anon33233> Than you.
21:36:06 <stepkut> also, the happstack version has way more imports
21:36:18 <bluej774> anon33233, It should be fixed sooner than me because I'll never be fixed.
21:36:26 <mm_freak> stepkut: what i don't like about the QQ there is that it names the handler actions for me
21:37:02 <mm_freak> if i write "/ HomeR GET", the handler is called getHomeR, with POST it's called postHomeR…  it gets ugly when i want both
21:37:09 <mm_freak> because usually the two handlers are the same for me
21:37:14 <bluej774> mm_freak, where did you see that about the version of the opengl wrapper?
21:37:17 <mm_freak> causing some redundancy
21:37:24 <mm_freak> bluej774: cabal info OpenGL
21:37:29 <stepkut> mm_freak: yup. In Happstack + web-routes, you have to do that by hand.. which is, of course, a tiny bit longer
21:37:32 <hpaste> donri annotated “hello happstack” with “I like to keep it simple” at http://hpaste.org/71311#a71312
21:38:26 <stepkut> donri: I like the case version better, because I find that sometimes I need to pass extra arguments to the route function that only get passed to some of the routes
21:38:36 <stepkut> and then I end up with a bunch of _ _ _ _
21:38:43 <stepkut> for all the other cases
21:38:47 <donri> stepkut: did you read the comment? :)
21:38:58 <mm_freak> the happstack equivalent doesn't look so bad
21:39:10 <stepkut> donri: I read half of it.. :)
21:39:29 <stepkut> donri: not convinced I would want to use a ReaderT there
21:39:35 <mm_freak> what about RESTfulness?  i like how yesod handles URLs automatically redirecting where sensible
21:39:43 <donri> also, that we're having this discussion at all is something i like about happstack vs others ;)
21:39:54 <mm_freak> this is something i'd have to reinvent in snap
21:40:01 <stepkut> donri: that sort of implies that the extra params get passed to all the routes  (via ReaderT?)
21:40:23 <stepkut> mm_freak: not sure which redirecting you are talking about
21:40:45 <mm_freak> stepkut: if /x/y is a resource, then yesod redirects /x/y/ to /x/y
21:41:03 <mm_freak> instead of serving the same resource by two URLs that is
21:41:04 <donri> stepkut: i guess it depends on what kind of arguments we're talking about... usually such things are things i want in all handlers (of that Site at least), a "runtime and request environment" of sorts
21:42:46 <kini> oh no, hackage is down
21:43:24 <jamiltron> UArrays should pretty much be a drop-in replacement of Arrays, just with a modifid import and type declarations, right?
21:43:53 <mm_freak> jamiltron: from an interface viewpoint yes
21:44:50 <stepkut> donri: if I wanted it in all the handlers then I would use an ReaderT (or something) and modify the 'type App = ...'
21:45:21 <donri> stepkut: yea that's what i'm saying... and should the need arise, it's still easy to refactor into a combination of the two ways
21:45:37 <stepkut> mm_freak: how do you know when that redirect is sensible?
21:45:38 <bluej774> Well, what about those who want OpenGL 4.1 support in Haskell (like me ;)?
21:45:53 <mm_freak> stepkut: when defining the resources
21:46:13 <stepkut> mm_freak: I know the file serving code does some redirects to add missing / when you request a directory.. but I can't remember if we go the other way
21:46:21 <Cale> bluej774: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html :3
21:46:44 <ion> bindings-DSL is awesome for FFI.
21:46:52 <mm_freak> stepkut: which way doesn't really matter…  i'm happy with trailing slash, as long as there is only one URL per resource
21:47:16 <mm_freak> uh
21:47:18 <mm_freak> hackage is back =)
21:47:22 <jamiltron> mm_freak: I'm getting an ambiguous type variable error when trying to do something trivial like 'listArray (0,1) [1,2]', or am I misreading the function?
21:47:28 <mm_freak> was back
21:48:18 <Cale> jamiltron: Probably the issue is that it doesn't know what type of array you want to make, and the MR is turned on or something.
21:48:22 <mm_freak> jamiltron: listArray is very polymorphic
21:48:54 <mm_freak> jamiltron: best give a type signature for one of the versions of the array somewhere…  everything else is then inferred
21:49:33 <stepkut> mm_freak: I am guessing that derivePathInfo does not check if there was a trailing slash or not. If that is wrong, I can fix it :)
21:50:07 <mm_freak> stepkut: ensuring RESTfulness manually is very tiresome…  it would be great if happstack would have that feature
21:52:57 <stepkut> mm_freak: absolutely! That is definitely the type of thing we want to support :)
21:53:33 <mm_freak> great
21:53:36 <donri> both http://www.happstack.com/C/ViewPage/3 and http://www.happstack.com/C/ViewPage/3/ are accepted without redirection it seems
21:54:08 <mm_freak> when implemented correctly you can actually make that a permanent redirection
21:54:28 <mm_freak> the simplest rule is just to disallow trailing slashes
21:55:27 <stepkut> hmm, with out trailing slashes some relative resources are not located properly I believe
21:55:30 <donri> i think it's more consistent to enforce trailing slash, maybe, not sure
21:56:01 <mm_freak> stepkut: any example?
21:56:02 <stepkut> we had to enforce trailing slashes in the file serving code or things got funky
21:56:08 <jamiltron> mm_freak: Thanks, I was being dense :P
21:56:25 <donri> like i think you can't have http://foo.com, it's automatically http://foo.com/, so it's neater to think of each component as "bla/" than "/bla"
21:56:51 <mm_freak> well, that's about the same inconsistency as unix file paths
21:56:55 <mm_freak> there is /
21:57:00 <mm_freak> but there isn't really a /x/
21:57:09 <donri> true
21:57:25 <donri> and people seem to prefer to think of it as an intercalate/intersperse operation
21:57:34 <donri> shrug
21:57:42 <mm_freak> we tend to write x/ to indicate that 'x' is a directory, but that's only an indication and doesn't make any sense for web resources
21:57:46 <stepkut> http://code.google.com/p/happstack/issues/detail?id=224
21:57:50 <stepkut> that is the new bug
21:57:56 <stepkut> one moment on the old one
21:58:25 <stepkut> that is the old one, http://code.google.com/p/happstack/issues/detail?id=93&can=1&q=redirect
21:59:07 <donri> i suppose it's closer to similarity with CSV and such, than unix file paths
21:59:21 <donri> s/to/in/
21:59:33 <donri> s/with/to/? :P
22:00:15 <stepkut> so, with fileServe if you requested /foo/bar and we returned the contents of 'index.html' from that directory, then the browser would think it should make the links relative to /foo not /foo/bar
22:01:07 <mm_freak> well, yeah…  that's true
22:01:09 <stepkut> (imagine that /foo/bar/ contains index.html and style.css and the index.html includes that style.css)
22:01:23 <mgsloan> I'm sure there's been quite enough Hackage-down-oh-god, but shouldn't a better solution be setup?  I'm thinking Amazon S3, or some decent hosting service, maybe with the ability to redirect to cached static versions if something is really borked
22:01:35 <mgsloan> (I guess hackage 1.0 is static anyway)
22:01:58 <stepkut> so.. this is the type of issue I worry about with adding automatic redirects.. though allow both versions of the resource is not really better since one of them should exhibit similar ploblems
22:02:47 <mgsloan> it could at least be hosted elsewhere
22:03:01 <mm_freak> yesod simply autogenerates the URLs properly, but you have a point
22:03:05 <stepkut> mgsloan: the solution is fix the last few issues holding up hackage 2.0.. (I am doing that, btw, but more help would make it quicker)
22:03:14 <donri> stepkut: could also argue that relative paths are broken in general :) and there's a html tag for setting the base
22:03:24 <mgsloan> stepkut: Cool!!  Yeah, that would be the ideal solution
22:03:47 <stepkut> mm_freak: you mean when yesod it generates the urls it generates them with or without the / as required ?
22:04:12 <mm_freak> stepkut: that's configurable…  if you select relative URLs it will still generate correct ones
22:04:25 <mm_freak> stepkut: hamlet is aware of where the current resource is
22:04:38 <mm_freak> (not hamlet itself, but it gets passed a function to handle that)
22:05:01 <mgsloan> ooh, you know what would be nice?  ":t Data.Maybe.*"
22:05:09 <stepkut> not sure if I have ever tried to use relative URLs with web-routes :-/
22:05:17 <mgsloan> would be pretty handy for these hackage-down situations
22:06:02 <stepkut> mgsloan: there is sometimes hackage2 based mirror of hackage running, but it also appears to be down at the moment
22:06:03 <kfish> mgsloan: having a local hoogle install is useful for random doc lookup
22:06:15 <mgsloan> kfish: Yeah, I should definitely get around to that
22:06:18 <stepkut> mgsloan: hackage2 has much better mirroring support though.. another reason for use to get it up
22:06:25 <donri> mm_freak: type safe routing was first in happstack (to be a hipster!) which is to say, we have URLs generated from haskell value representations as well
22:07:00 <kfish> mgsloan: once hackage is backup, do: http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration
22:07:14 <mm_freak> donri: sure, but that's not really the point =)
22:07:32 <mm_freak> yesod was RESTful from the beginning
22:07:50 <mm_freak> so that particular thing was handled from the beginning, which i found very convenient
22:07:56 <mgsloan> kfish: wow!!! Yeah, seriously should have done that.  I do have hoogle, actually, just don't use it due to lack of that sort of convenience
22:09:02 <donri> http://hackage2.uptoisomorphism.net:8080/ ;)
22:09:11 <kfish> mgsloan, i use :ho more than :t, as you don't even need to import the modules first
22:09:22 <mgsloan> donri: woohoo! awesome
22:09:30 <mgsloan> kfish: makes sense!
22:09:42 <stepkut> mm_freak: what are some other things needed to be RESTful out of the box?
22:09:45 <donri> it's not updated since february though and hackage2 mirrors don't have haddocks
22:09:56 <mgsloan> ah
22:10:02 <mgsloan> very speedy, at least
22:10:30 <stepkut> mgsloan: yay for RAM-based NoSQL !
22:11:14 <mm_freak> stepkut: proper handling of the request type
22:11:48 <mm_freak> stepkut: for example a GET request should not mutate anything
22:11:54 <solrize> can we set up some live mirroring for hackage?  i have some vps's i could contribute
22:12:01 <stepkut> mm_freak: meaning, paying attention to the Accept header and returning the correctly typed resource?
22:12:21 <stepkut> mm_freak: does yesod actually enforce no mutation on a GET ?
22:12:36 <donri> mm_freak: surely you can mutate things just fine in a yesod GET handler? isn't it up to you not to?
22:12:37 <stepkut> that seems beyond Haskell's type capabilities
22:12:38 <mm_freak> stepkut: that's also a concern, yes…  but it shouldn't be a different resource for different Accept types…  it should be the same resource in a different representation
22:12:56 <mm_freak> no, yesod doesn't enforce this
22:12:59 <stepkut> mm_freak: right, that is what I meant
22:13:20 <solrize> oh, missed earlier
22:14:07 <mm_freak> but that's one of the reasons why yesod strictly requires two separate handlers for GET and POST (although you can cheat here)
22:14:10 <stepkut> mm_freak: I usually do that by creating a type to represent the all the data that goes into the response and then you can type classes, etc, to create the different representations
22:14:42 <donri> happstack provides the tools to make it kind of easy to do such resty stuff, though i think we could improve the situation
22:14:45 <stepkut> yeah, yesod also does not check that when you POST a form that the URL actually supports POST
22:14:51 <mm_freak> stepkut: yeah, that's what i've done in webwire, and yesod does that, too, but without a type class
22:14:55 <mm_freak> it has ChooseRep
22:15:48 <mm_freak> yeah, yesod unfortunately views HomeR with both GET and POST as the same resource
22:16:18 <mm_freak> i usually underline that by cheating and saying:  postHomeR = getHomeR
22:16:24 <otters> oh dear
22:16:31 <stepkut> yeah, I prototype a solution for web-routes that uses GADTs to enforce GET vs POST.. but you can only enforce it up to a degree
22:16:32 <otters> now I'm never going to remember to upload my package
22:16:55 <stepkut> but, I have also never had a bug where I POSTed to a GET-only resource, so..
22:17:26 <stepkut> so, Happstack should have a help function that makes it easy to extract the accept header and choose the correct representation?
22:17:59 <mm_freak> stepkut: as far as practical web is concerned, a POST resource should always redirect to the corresponding GET resource
22:18:49 <mm_freak> yesod does that with one exception:  when there are validation errors for a POSTed form, no redirection happens to allow the browser to refill the form with the posted data
22:18:55 <stepkut> mm_freak: after the POST has done its thing
22:19:00 <mm_freak> i suppose there are nicer ways to handle that
22:19:48 <mm_freak> stepkut: the problem is that when you don't redirect you again have the same resource under two different locations
22:20:13 <mgsloan> kfish: I've got a nice refinement of the ghci integration:  :def ho \x -> return $ ":!hoogle \"" ++ x ++ "\" | less -FX"
22:20:16 <mm_freak> it's debatable whether this is incorrect wrt REST
22:20:18 <stepkut> mm_freak: yeah, I usually do a redirect after a POST, but it is not automatically enforced
22:20:36 <gseitz> is it the general sentiment in the community that ErrorT is bad and should be replaced (for example by EitherT of the new errors package)?
22:20:50 <mgsloan> The "less -FX" will have the stuff inline if it's less than a screen, otherwise supress it being inline, and use less to page it
22:20:59 <mm_freak> stepkut: in an ideal world you wouldn't have to write the POST handler at all…  you would just give a continuation that processes the posted data
22:21:03 <stepkut> mm_freak: but.. if I didn't do a redirect.. I would probably just have a page that says, "Thing XXX has been successfully updated."
22:21:31 <mm_freak> i like how racket handles this (and i really wonder why no haskell web framework has anything like that)
22:21:46 <mgsloan> err, nvm, it won't supress it interrupting your ghci (but that was already there from tab completion 'n such)
22:21:58 <mm_freak> the idea is this:  serveForm myForm (\postedData -> …)
22:22:09 <mm_freak> and it could be done easily using e.g. monad-coroutine
22:22:21 <mm_freak> the continuation could become part of the session
22:22:44 <mm_freak> and the post URL would be a throwaway URL
22:23:13 <mm_freak> stepkut: not redirecting is problematic, when the user refreshes the page
22:23:26 <stepkut> mm_freak: right, that is why I do a redirect (among other things)
22:23:47 <stepkut> though I am not clear that an automatic redirect to the same location is always the right thing
22:24:54 <stepkut> but.. I could change the type of reform so that the success handler always returns a URL and we redirect to whatever URL they provide
22:27:02 <mm_freak> stepkut: that's what i like about CPS solutions…  there is no reason to enforce any concept on how to handle this =)
22:27:24 <stepkut> mm_freak: with the CPS solution you are forced to keep that thunk around until the session expires?
22:27:27 <mm_freak> but it also means that the form abstraction is tied to the underlying web framework
22:27:38 <mm_freak> stepkut: yeah
22:27:44 <stepkut> mm_freak: also.. it means they always have to come back to the same server  (assuming you have a cluster?)
22:27:58 <stepkut> did you ever use WASH/CGI?
22:28:31 <mm_freak> there may be ways to pass off to another server
22:28:46 <mm_freak> i never got WASH to compile, and when i used CGI i didn't even know haskell =)
22:28:52 <stepkut> :)
22:29:19 <stepkut> WASH/CGI used continuations, but stored the data as hidden fields in the form
22:29:34 <mm_freak> encrypted i suppose?
22:29:40 <stepkut> mm_freak: no
22:30:00 <stepkut> mm_freak: i believe the continuations had to be pure
22:30:07 <mm_freak> well, then i suppose the continuation couldn't be a simple lambda?
22:30:20 <stepkut> so basically it just stored the answers you previously submitted, and then it could get to the current location in the chain by replaying the old answers
22:30:50 <mm_freak> well, personally i'd just keep the suspension value in the session
22:30:53 <stepkut> it was an interesting idea.. but ultimately not that practical
22:31:08 <mm_freak> the memory footprint is very small
22:31:26 <stepkut> mm_freak: I am pretty sure there is a Haskell library somewhere that does that
22:31:33 <mm_freak> yes
22:31:36 <mm_freak> monad-coroutine =)
22:31:50 <stepkut> well, I meant an HTML form library
22:31:59 <mm_freak> ah…  not sure about that one
22:32:19 <mm_freak> the problem here is that to use CPS the form library needs to be aware of the underlying web framework
22:32:21 <stepkut> mm_freak: I have always just done something like, reform (form "/post-url") handleSuccess theForm
22:32:32 <stepkut> where handleSuccess is just a normal function
22:32:42 <stepkut> no special session data stored with it
22:33:00 <stepkut> when does the CPS version become exciting?
22:33:14 <mm_freak> so you have to have the same code in the handler?
22:33:51 <mm_freak> well, in the CPS version the handler can simply assume that the post data is available…  other than that it's just a regular request handler
22:34:04 <mm_freak> also the handler doesn't have any fixed URL
22:35:26 <mm_freak> in fact if you try racket's web framework you will immediately notice that you don't write URLs/routes anywhere…  a link is a closure =)
22:35:42 <mm_freak> URLs are generated on the fly or based on some information in the source code
22:35:47 <stepkut> in the version I posted, the handleSuccess case gets the decoded form data..
22:36:20 <mm_freak> yeah, but handleSuccess is bound to the 'reform' function, isn't it?  i.e. you need the 'reform' in the post handler as well, right?
22:37:10 <stepkut> yes and no
22:37:41 <stepkut> you create a single function that handles both the GET and POST cases
22:37:52 <stepkut> it looks at the request method and decides what to do
22:39:13 <hpaste> “Ertugrul Söylemez” pasted “Pseudocode for a CPS web framework” at http://hpaste.org/71313
22:39:18 <mm_freak> stepkut: see the paste
22:39:25 <stepkut> appTemplate "valid post form" () $  <div><h1>My Form!</h1><% reform (form "/valid") "valid" displayMessage Nothing validPostForm %></div>
22:39:37 <Axman6> > let fibs@(t:fibs') = 1:t:zipWith (+) fibs fibs' in fibs
22:39:38 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:40:01 <stepkut> if it is a GET request, that will just render the form in the page. If it is a POST request, it will attempt to decode the form and if successful, pass the decoded data to displayMessage
22:40:09 <ktklam9> hi, I keep getting this error cabal: <socket: 3>: resource vanished when I try to do "cabal update", why do I keep getting this error?
22:40:39 <stj> is there a function in Data.List like this? count f = length . filter f
22:40:57 <mm_freak> stepkut: in the code the renderForm action suspends using formHandler as the continuation…  when the user submits correct form data, then formHandler is the handler
22:41:10 <mm_freak> it can silently assume that correct form data has been submitted and is available as the argument
22:41:43 <stepkut> mm_freak: this sounds a lot like how 'reform' works, except with out the need for session data
22:41:47 <donri> @hoogle (a -> Bool) -> [a] -> Int
22:41:48 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
22:41:48 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
22:41:48 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
22:41:52 <Nereid> ktklam9: hackage is down
22:42:27 <donri> stj: "length" is usually a bad idea anyway
22:42:33 <mm_freak> stepkut: there is a big difference between the two, which may not be visible in that short code
22:43:18 <mm_freak> stepkut: in particular secondHandler never gets past the renderForm
22:43:19 <stepkut> mm_freak: there is certainly a big implementation difference. I am still not clear what the benefit is
22:43:38 <stj> donri: why is length a bad idea?
22:43:41 <donri> i think continuation based web apps are only now becoming usable due to html5 history api
22:43:47 <mm_freak> stepkut: i think i should write a proof of concept mini-framework to make the benefit visible
22:44:08 <stepkut> mm_freak: yeah.. I would certainly be happy to add something like that to reform
22:44:18 <mm_freak> stepkut: actually the code is bad
22:44:29 <stj> donri: and still, this isn't quite convenient since I have to use convert Maybe Int to the real count of elements that satisfy the condition
22:44:32 <donri> stj: it has to consume the whole list (which may be infinite)
22:44:38 <mm_freak> stepkut: let me try again
22:44:43 <stj> donri: I use only finite lists
22:44:49 <stepkut> mm_freak: ok :)
22:45:00 <Nereid> donri: how else would you count how many elements of a list satisfy f?
22:45:07 <donri> stj: so just compose length and filter as you already did :)
22:45:13 <stepkut> mm_freak: if you can get the proof of concept to work, it should be trivial to integrate it into reform
22:45:29 <donri> Nereid: well, first ask yourself if you really need to?
22:45:30 <stj> donri: okay, I'm just surprised that there isn't such a common function :)
22:45:31 <hpaste> “Ertugrul Söylemez” annotated “Pseudocode for a CPS web framework” with “Pseudocode for a CPS web framework improved” at http://hpaste.org/71313#a71314
22:45:36 <mm_freak> stepkut: see the annotation
22:45:43 <mm_freak> this is possible with CPS-based frameworks
22:45:47 <donri> stj: doesn't seem that common to me
22:46:00 <mm_freak> stepkut: renderForm is now basically something like getLine
22:46:40 <donri> stj: even with finite lists, you still have to walk the whole list
22:46:44 <mm_freak> i had racket in mind, where you don't have coroutine monads, but in haskell this is easily possible =)
22:46:46 <stepkut> mm_freak: so 'link secondHandler' just creates a normal <a href> to the form page?
22:46:54 <mm_freak> stepkut: yes
22:47:29 <stj> donri: sure, so what... I just want to count the number of values that satisfy a condition in a list -> this definition itself assumes the list is infinite, no?
22:47:36 <stepkut> and that uses some default template and generates a page with nothing but a form in it ?
22:47:46 <mm_freak> stepkut: yes, in this simplified case
22:47:51 <stj> donri: it's like saying... but function 'length' is a bad idea since it may not work on infinite lists :)
22:48:04 <Nereid> s/may/does/
22:48:23 <mm_freak> stepkut: notice how there are no URLs at all in the code
22:48:24 <stj> yeah :)
22:48:42 <mm_freak> and notice how secondHandler is basically written like an interactive application
22:48:44 <stepkut> if you changed secondHandler to, renderForm myForm $ \postData -> do doSomethingWith postData ; redirect rootHandler, would be be essentially the same thing?
22:49:00 <stepkut> s/be be/it be/
22:49:03 <mm_freak> stepkut: that's what it compiles to
22:49:08 <donri> stj: length is usually a bad idea, i did say that. :) but now you can first filter the list and then both look at its length and use the filtered list without filtering it again... can't do that with "count"
22:49:28 <mm_freak> stepkut: but the continuation isn't a feature of renderForm, but of the underlying monad (or more likely an arrow in this case)
22:50:07 <stepkut> does each call to 'link secondHandler' generate a new URL ?
22:50:49 <mm_freak> stepkut: if it's a monad, yes, if it's an arrow, no =)
22:51:20 <stepkut> and that new link is unique and has to be stored in some database?
22:51:40 <mm_freak> stepkut: if it's a monad, yes, if it's an arrow, no =)
22:52:24 <stepkut> so every GET request to my page is doing a bunch of updates to my database creating links that probably never be used?
22:52:28 <__dict__> Hi. What's the best way to install Haskell on Windows? The haskell platform site seems to be down.
22:52:42 <mm_freak> stepkut: i gotta go now, but i will create a proof of concept to experiment with this idea
22:52:50 <stepkut> mm_freak: I think that would be a good idea :)
22:52:54 <Nereid> __dict__: hackage is indeed down. wait until it comes back up, unfortunately.
22:52:55 <mm_freak> then i can give clearer answers =)
22:52:58 <stepkut> mm_freak: yeah
22:53:16 <__dict__> Ok, any idea how long that will be?
22:53:34 <stepkut> mm_freak: If you get it working and still find it cool, I would definitely consider adding support for it in reform
22:53:54 <mm_freak> in any case, if this works, it would be great to have in happstack, and then i'd be definitely going with it =)
22:53:54 <Nereid> __dict__: nope
22:54:00 <stepkut> heh
22:54:20 <stepkut> well reform is not dependent on any particular framework or template library
22:54:22 <mm_freak> stepkut: if that works, it will require support by happstack
22:54:32 <__dict__> Ok, well that's unfortunate. Thanks
22:54:37 <stepkut> though, this addition would likely have more specific requirements
22:54:41 <mm_freak> so i'm not sure you can integrate it into reform
22:54:56 <mm_freak> ok, see you
22:55:17 <stepkut> well, there is the core reform package, and then libraries like reform-happstack, reform-blaze, etc that provide the framework/template dependent parts
22:55:26 <Nereid> __dict__: if you can't wait to get started, at least you can download GHC
22:55:53 <stepkut> so.. to support all the frameworks might require re-implementing it 3 times
22:56:04 <Nereid> http://www.haskell.org/ghc/download_ghc_7_4_2
22:56:09 <stepkut> where "all the frameworks" == "just 3 of them"
22:57:06 <__dict__> Nereid: It's for a friend. I was suggesting haskell as his first language to try. Maybe I'll just start him off with Java instead
22:57:31 <Nereid> no comment :)
22:59:20 <__dict__> Has it been down since Dec 1 or is that a different time it was down?
22:59:27 <Nereid> just today
23:00:14 <__dict__> O ok, well that's acceptable. I'll just wait until it comes up again to tell him where to download anything
23:00:16 <mm_freak> __dict__: http://article.gmane.org/gmane.comp.lang.haskell.beginners/9877
23:00:48 <mm_freak> stepkut: i'll implement this on top of wai, if that's not too intimidating, mainly just because i'm familiar with it
23:01:00 <stepkut> mm_freak: sure
23:02:05 <stepkut> mm_freak: there is an experimental wai interface for happstack :)
23:02:26 <stepkut> mm_freak: though, I am leaning towards pipes 3.0 at the moment..
23:02:44 <stepkut> but first.. pipes 3.0 has to be released
23:03:56 <latro`a> I have some pure code such that if I had a certain string available at the top level, my program would just run
23:03:57 <mm_freak> ok
23:04:04 <mm_freak> now finally, i'm gone =)
23:04:06 <latro`a> but I need to get the string with IO
23:04:08 <stepkut> later!
23:04:21 <latro`a> and I unfortunately use the string at top level, not at function level
23:04:28 <otters> latro`a: fmap yourfunc io_action
23:04:43 <latro`a> the yourfunc is unfortunately big-ish, I suspect
23:05:00 <latro`a> and the things that would get fmap'd are pure types at the moment
23:05:16 <latro`a> in short this basically slaps an IO type constructor on half my program :/
23:05:30 <latro`a> at least, if I'm looking at it right
23:05:31 <latro`a> which I doubt
23:06:46 <hpaste> latro`a pasted “IO everywhere” at http://hpaste.org/71315
23:07:15 <latro`a> ^dictionary is where the "string" in question appears, though dictionary is a small transformation on it
23:07:28 <latro`a> that may show why this would be irritating, I dunno
23:08:10 <latro`a> I'm halfway tempted to paste the string into the file, as it's only ~6000 characters, but that is pretty terrible
23:09:10 <Nereid> latro`a: well, you could pass the dictionary as a parameter to each function, but I doubt you want to do that.
23:09:27 <Nereid> you could put all of those other functions in a Reader monad or something
23:09:30 <latro`a> yeah, I knew I could do that already, and was coming here to see if I could bypass that
23:09:59 <latro`a> that would help some, I suppose
23:10:04 <Nereid> or
23:10:37 <Nereid> if it's a static thing, maybe you could just have a submodule dedicated to holding the dictionary? I don't know if people do this kind of thing.
23:10:52 <latro`a> it is in fact static
23:10:57 <latro`a> so I could probably do that
23:11:12 <latro`a> yeah that's probably worthwhile
23:12:01 <latro`a> given that this is all I need to make my program run, that seems reasonable
23:12:05 <latro`a> should give a speed increase, too
23:12:17 <Nereid> sure.
23:12:37 <latro`a> thanks :)
23:12:43 <Nereid> but if you might want to, say, use multiple dictionaries in the future
23:12:58 <Nereid> then something like Reader would probably be the way to go
23:13:02 <latro`a> right
23:24:07 <shachaf> Ha.
23:24:52 <shachaf> I finally have an actual concrete use for zipWith if', which is one of the things I use to explain why functions are nicer than macros when you can have either.
23:24:55 <shachaf> ...But it's in Python.
23:28:17 * mgsloan fumes at TH's naming behaviour
23:29:39 <sjork>  _       _   _
23:29:41 <sjork> (_)     | | | |
23:29:42 <sjork>  _ ___  | |_| |__   ___ _ __ ___
23:29:43 <sjork> | / __| | __| '_ \ / _ \ '__/ _ \
23:29:45 <sjork> | \__ \ | |_| | | |  __/ | |  __/
23:29:47 <sjork> |_|___/  \__|_| |_|\___|_|  \___|
23:29:47 <sjork>                                   
23:29:49 <sjork>                                   
23:29:51 <sjork>                 ___            _ _
23:29:52 <shachaf> @where ops
23:29:52 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:29:55 <sjork>                / _ \          | (_)
23:29:55 <sjork>   __ _ _ __   / /_\ \_   _  __| |_  ___
23:29:55 <sjork>  / _` | '_ \  |  _  | | | |/ _` | |/ _ \
23:29:56 --- mode: ChanServ set +o Cale
23:29:56 <sjork> | (_| | | | | | | | | |_| | (_| | | (_) |
23:29:58 <sjork>  \__,_|_| |_| \_| |_/\__,_|\__,_|_|\___/
23:29:59 --- mode: Cale set +b *!*@static.61.198.47.78.clients.your-server.de
23:29:59 --- kick: sjork was kicked by Cale (sjork)
23:30:07 <shachaf> Cale++
23:30:20 <Cale> This guy needs a k-line
23:30:20 * shachaf wonders if trolls are a secret op plot to gain karma.
23:30:22 <mgsloan> seriously, if I'm doing [d| foo = blah blah |], yes, I do want a declaration named foo. No, I do not want "foo_0".
23:30:34 <Cale> he just spammed the fuck out of ##math
23:30:38 <zomg> haha
23:30:42 <shachaf> mgsloan: "It looks like you're trying to declare a value!)
23:30:43 <zomg> rarely see troll behavior here
23:30:47 <shachaf> s/.$/"/
23:30:47 <MostAwesomeDude> marienz: ^^ ?
23:30:50 <zomg> not like that at least..
23:31:30 <zomg> Oh
23:31:35 <zomg> He's on nodejs now...
23:31:36 <mgsloan> today there's been three or four trolls.. pretty strange
23:32:22 <shachaf> Hey, I heard Haskell is stupid and can't do web apps because it's "pure",
23:32:29 <shachaf> What's the point of a language that can't even do web apps?
23:32:55 <chu> Who knows.
23:33:17 <cesc> Hi. Coming from Fortran/C I was used to having an array of, say, double-precision values and being able to modify the element at a given position i. How should one do these kind of tasks in Haskell? All I've seen involves creating a new list using take and drop from the old list. Is this reasonable? And, more importantly, is this the quickest way to perform such a task?
23:33:20 <tdammers> if it can't do web apps, it's probably not even a language at all
23:33:50 <Cale> cesc: If you need random access, lists are the wrong datastructure
23:33:52 <shachaf> cesc: Usually you want to think at a higher level than "modify this part of the array to be that".
23:34:11 <shachaf> You *can* do that, and there are mutable arrays for it, but often the point is not to do it in the first place. :-)
23:34:12 <cesc> Cale, what should I read into then?
23:34:22 <Cale> cesc: If you want to lookup and modify entries quickly while sticking to immutable structures, start with Data.Map
23:34:32 <roconnor_> ha, "The Great Monomorphism Catastrophe" :D
23:34:33 <tdammers> or Data.Array
23:34:45 <Cale> Data.Array has fast lookup, but updates will build a copy
23:34:56 <shachaf> roconnor_: The Monomorschism?
23:34:56 <tdammers> point taken.
23:35:01 <zomg> lol
23:35:04 <solrize> cesc, what are you trying to do?  if it's actual numerics then yeah, maybe that is one of the places where you do want actual arrays (Data.Vector).  otherwise there are other representations that are more in the Haskell spirit.
23:35:05 <roconnor_> *l*
23:35:10 <zomg> if you say "hep tep rog" that sjork guy will leave the channel
23:35:11 <cesc> shachaf, oh?  Most of what I do is reading in numerical data from an ASCII file into an array, then perform some number crunching on the array (involving multiple indices) and writing it out. I'm having a hard time porting this train of thought to haskell :D
23:35:14 <zomg> No clue why but it works
23:35:15 <zomg> :D
23:35:17 <osa1> hackage is down again?
23:35:49 <cesc> Cale, thx for the Data.Map tip.
23:36:35 <mgsloan> ?remember shachaf roconnor_: The Monomorschism?
23:36:35 <lambdabot> I will never forget.
23:37:25 <Cale> cesc: Yeah, that's probably the simplest thing to start with. There's also Data.IntMap (which is just specialised to Int, and a little faster). You might also want to check out Data.Sequence, which implements immutable sequences which have O(1) access to both ends and O(log(min(k,n-k)) splitting and concatenation (and so the same time to access any element)
23:37:42 <peddie> cesc: if you are doing a lot of numerical operations, you might be interested in the Haskell high-level interface to BLAS/LAPACK/GSL in the hmatrix package
23:37:42 <shachaf> Cale: There are also actual mutable arrays, as in ST. :-)
23:37:59 <solrize> don't forget Data.Accelerate :)
23:38:07 <Cale> cesc: Yes, it's worth noting that there are mutable structures too, if you really need them :)
23:38:23 <cesc> peddie, sure, but first I'd like to know how to perform elementary operations myself
23:38:47 <peddie> cesc, ok -- enjoy :)
23:38:53 <cesc> Cale, ok, so the route I should take this evening is reading into Data.Map and mutable structures from some docu :)
23:39:19 <solrize> cesc if you're thinking of "elementary operations" as stuff like clobbering an element in the middle of a vector, in Haskell that's not elementary, it's kind of messy and complicated and ugly, though sometimes necessary for performance reasons
23:39:20 <donri> @tell stj you might prefer the vector package for your use of lists
23:39:20 <lambdabot> Consider it noted.
23:39:26 <solrize> it's better to start with something like Map
23:39:28 <cesc> my aim for the week is being able to read numerical data from columns in text files, doing some operation on them, and writing them out xD  YES I CAN!
23:39:51 <Cale> cesc: :)
23:39:57 <solrize> cesc you can do that without mutable vectors :)
23:40:28 <cesc> I must say, though, Haskell is pretty time demanding. A n00b can get cracking in much less time in other languages.. But I'm hanging on. :))
23:40:36 <Cale> cesc: Think of lists as the structure you use when you want to iterate in a linear way over something -- they're sort of loops which have been frozen into data structures.
23:40:51 <cesc> solrize, will check 'em out :)
23:41:14 <Cale> Just like a loop will either not run at all or will consist of an iteration followed by another loop, a list is either empty or consists of an element followed by another list.
23:41:31 <cesc> Cale, ah! Yes, that's the feeling one gets anyway.  "how the hell do i change these things?"   I guess the point is just "you don't" :)  you just perform some operation on them and that's it  (?).
23:41:43 <Cale> cesc: right
23:42:03 <Cale> cesc: You'll have to learn to think in terms of larger operations in order for things to become comfortable
23:42:08 <cesc> and (hopefully) this is where "mutable vectors" come in, or I'm totally losing it xD
23:42:11 <Cale> Modifying one element at a time is awkward
23:42:38 <Cale> (with lists, especially)
23:42:55 <cesc> then I've been doing awkward things all my life :D
23:43:42 <cesc> if I ever get the hold of this I will write a little tutorial, smth like "Haskell for Fotran/C number crunchers"
23:44:36 <mgsloan> anyone know why Hayoo doesn't search all of hackage?
23:44:39 <mgsloan> kindof defeats the purpose
23:44:56 <donri> cesc: i didn't follow this conversation but have you seen http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial ?
23:44:56 <mgsloan> if you already knew the name of the package you needed, then you wouldn't need to search for it..
23:45:10 <donri> also http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial
23:45:35 <donri> mgsloan: i think hayoo does, hoogle doesn't
23:45:41 <Cale> cesc: It can take a while to grasp the way in which things are evaluated well enough to easily spot whether something will perform well (because it's different, so your intuitions about things are most likely to be wrong for a while)
23:46:07 <mgsloan> donri: ahh, you're right! Cool :D
23:46:19 <Cale> But if you stick to higher order functions it becomes a little easier to get things that work well, at least.
23:46:34 <cesc> donri, no I haven't (I just started with haskell a few evenings ago).  Thanks a lot for the link. Will definitely go through it when I get back home =)
23:46:44 <wiz> :t void
23:46:45 <lambdabot> Not in scope: `void'
23:47:38 <donri> :t Control.Monad.void
23:47:40 <lambdabot> Not in scope: `Control.Monad.void'
23:47:41 <mgsloan> uh-oh.  Looks like forall quantification breaks hayoo (in the result type, not the search)
23:47:42 <Cale> cesc: It took me about 2 months to feel like I could really program in Haskell and about a year to get comfortable. We have better tutorials now, and I had a full course load on top of that at the time, but yeah, don't feel bad if it's not immediate :)
23:47:48 <donri> @hoogle void
23:47:48 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
23:47:48 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
23:47:48 <lambdabot> package void
23:47:52 <cesc> Cale, uhum. Coming from Fortran and not having done more than number crunching, performance is a bit of a concern. What's the best way to learn? Is it OK every now and then to post some snippets of code and ask for somebody to point out n00b mistakes?
23:48:02 <Cale> sure
23:48:57 <cesc> Cale, yes I'm giving it some time. I Don't wanna quit so soon. I wanted something different, wasn't feeling like learning python or the like :)     oh, ok! Then I guess this is what I'll try :)
23:49:33 <liyang> @where hpaste
23:49:33 <lambdabot> http://hpaste.org/
23:49:56 <liyang> for anything longer than a one-liner. :)
23:50:48 <cesc> liyang, of course =)
23:51:20 <cesc> is there any good haskell forum around?
23:51:44 <liyang> This is it. (And StackOverflow, perhaps.)
23:51:49 <cesc> just as reading material.   I was thinking of something like the arch linux forum, where there's this newcomer section one can actually learn something from
23:51:51 <solrize> usenet, stackoverflow, and reddit all have haskell sections
23:51:52 <mikeplus64> cesc: http://reddit.com/r/haskell
23:51:56 <cesc> oh, ok.
23:52:03 <mikeplus64> cesc: and the haskell cafe
23:52:30 <cesc> sweet!  OK, then I hopefully have enough material to get started. Thanks a bunch for all the help!
23:52:40 <mikeplus64> but there isn't like a vbulletin or whatever forum, although maybe one could be built from the mailing lists (like D's "forums")
23:52:41 <Cale> cesc: I wrote some involved comments on this reddit post the other day showing how to do memoisation to speed up calculation of Levenshtein distances: http://www.reddit.com/r/programming/comments/w4gs6/levenshtein_distance_in_haskell/c5a6jjz
23:52:50 <Cale> cesc: Might be of some interest anyway :)
23:53:32 <cesc> bookmarked it is! :)
23:54:37 <cesc> oki doki, off I go.   Thx and happy haskelling!
23:57:31 <ThomasLocke> is hackage.haskell.org down, or is it just me?
23:57:53 <ThomasLocke> Do they perhaps have a mirror somewhere?
23:57:54 <tdammers> down for me too
23:58:07 <donri> isup.me/hackage.haskell.org
23:58:18 <tdammers> hoogle does work though
23:59:43 <ThomasLocke> yea hoogle is up, but they link to hackage for the actual packages, at least with the ones I'm looking for.
