00:12:14 <tdammers> ThomasLocke: yes they do. The summary is cached though, so you might be able to work with that for now.
00:12:43 <ThomasLocke> tdammers, I can't seem to find the mirror anywhere - I'm guessing it's just me being internet-stupid.
00:12:46 <tdammers> Also, regular google may give you hits outside hackage that aren't down.
00:13:11 * ThomasLocke considers sponsoring a mirror: hackage2.haskell.org
00:14:24 * beefcube would pitch in a few bucks.
00:15:47 <ThomasLocke> Are there any haskell.org people in here, and if so, how much cpu/storage/bandwidth are hackage.haskell.org sucking up on a monthly basis and during spikes?
00:16:57 <shachaf> ThomasLocke: hackage.haskell.org /= haskell.org
00:17:05 <shachaf> Galois would be the people to ask.
00:17:37 <solrize> ThomasLocke, from further up i get the impression that it's partly a software problem, hackage isn't convenient to mirror, and that is being worked on
00:18:21 <solrize> http://gofedora.com/insanely-awesome-web-interface-git-repos/   this looks kind of cool
00:23:39 <pqmodn> @hoogle (a -> b) -> (a -> c) -> (b -> c) -> a -> c
00:23:40 <lambdabot> No results found
00:25:03 <ThomasLocke> solrize, Ahh, so the standard "rsync the entire damn thing to a different domain" solution would not work?
00:25:27 <mercury^> pqmodn: for that you would need c to be a magma.
00:25:53 <solrize> ThomasLocke, i expect htere's databases involved
00:26:11 <solrize> and rsync'ing might not work so well
00:26:18 <pqmodn> mercury^: it's probably not the type i actually need, but i'm curious what's a magma?
00:26:25 <solrize> actual db replication, maybe
00:26:39 <donri> if you're looking to only mirror the packages, rsync might do
00:26:50 <donri> there's #hackage btw
00:27:14 <ThomasLocke> I'm only looking to mirror the packages, so users can get on with their work despite hackage.haskell.org being down.  :o)
00:27:55 <donri> there's a hackage2 mirror synced in february at http://hackage2.uptoisomorphism.net:8080/
00:31:43 <ThomasLocke> donri, There doesn't seem to be any source code available on that mirror.
00:32:01 <nart> hi
00:32:08 <nart> is hackage down only for me ?
00:32:52 <Lamen> nart: nope
00:34:18 <nart> that's unfortunate
00:34:54 <sqrt> If I have two lists xs and ys and I want to map a function f to obtain results f(x,y) for each x,y in xs ys. How do I do that?
00:35:02 <shachaf> sqrt: zipWith
00:35:09 <nart> sqrt: zipWith
00:35:11 <shachaf> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
00:35:12 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
00:35:12 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
00:35:12 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
00:35:30 <shachaf> Assuming you mean "f x y" and not "f (x,y)".
00:36:17 <donri> ThomasLocke: ah yea true
00:37:06 <donri> ThomasLocke: sadly http://hackage.factisresearch.com/ is down too (a more complete hackage2 mirror)
00:37:07 <sqrt> I mean. say I have xs=[1,2] ys=[3,4], f(x,y) = x*y, then I want [[3,6],[4,8]].
00:37:14 <sqrt> or something like that.
00:42:25 <sqrt> Ah, I figured it out, I think.
00:42:43 <dimituri> any news on when's hackage coming back up?
00:44:22 <nart_> sqrt: could you repost what are you trying to achieve ? :)
00:45:13 <sqrt> nart_: I wanted this: [f(x,y) | x <- xs, y <- ys]
00:45:30 <sqrt> nart_: I'm new to the language, so I was uncertain of the syntax.
00:46:31 <donri> map f (zip xs ys)
00:47:00 <donri> unless you meant for f to be curried
00:47:24 <donri> map (uncurry f) (zip xs ys)
00:48:04 <sqrt> no, donri, that would only give me the diagonal, I think.
00:48:28 <donri> yes, it's a good idea to ignore me pre-coffee
00:48:40 <df___> hello
00:48:47 <df___> test
00:49:10 * sqrt brews donri some coffee.
00:51:12 <JackHind> sqrt: map (f . (\[a,b] -> (a,b))
00:51:33 <Cale> > liftM2 (+) [1,2,3,4] [10,20,30,40]
00:51:35 <lambdabot>   [11,21,31,41,12,22,32,42,13,23,33,43,14,24,34,44]
00:51:56 <ion> > (| [1,2,3,4] + [10,20,30,40] |)
00:51:57 <lambdabot>   <no location info>: parse error on input `|'
00:52:45 <nart_> > (+) <$> [1,2,3,4] <*> [10,20,30,40]
00:52:47 <lambdabot>   [11,21,31,41,12,22,32,42,13,23,33,43,14,24,34,44]
00:53:00 <sqrt> JackHind: ah! Thank you! I wasn't aware of the \[a,b] way of writing things.
00:53:06 <donri> > (*) <$> [1,2] <*> [3,4]
00:53:07 <lambdabot>   [3,4,6,8]
00:54:03 <otters> @src (<$>)
00:54:03 <lambdabot> f <$> a = fmap f a
00:54:10 <otters> @src (<*>)
00:54:11 <lambdabot> Source not found. Just try something else.
00:54:36 <donri> @src (>>=)
00:54:37 <lambdabot> Source not found. :(
00:54:37 <Nereid> otters: those are from Control.Applicative
00:54:39 <donri> ;)
00:55:09 <otters> Nereid: I know, I'm just trying to figure out why there are four elemnts in the result list
00:55:25 <LK4D4> <$> from Control.Applicative too
00:55:54 <Nereid> otters: same reason [x * y | x <- xs, y <- ys] does
00:56:14 <otters> right
00:56:16 <donri> basically ( x <*> y) is like (do g <- x; return (g y))
00:56:32 <Nereid> more than "is like"
00:56:45 <otters> oh, I see
00:56:45 <donri> well there's no Monad constraint ;)
00:56:51 <otters> that makes sense then
00:56:58 <Nereid> well yeah, for any monad, that's what it is
00:57:04 <donri> @src ap
00:57:04 <lambdabot> ap = liftM2 id
00:57:56 <Nereid> yeah, (<*>) = ap for monads.
01:00:13 <wiz> hackage down? ):
01:00:21 <donri> myep
01:01:12 <tdammers> see topic
01:10:22 <wiz> routine maintenance or something fubar'd?
01:13:49 <bterry> b.terry@gmx.com
01:16:17 <Cale> bterry was cospamming
01:16:53 <Nereid> lol
01:17:22 <mgsloan> lmao
01:25:03 <liyang> Is that like, dressing up as a Spam tin?
01:26:50 <otters> why is lambdabot so hard to install
01:28:15 <solirc> otters: Because Hackage is down?
01:28:45 <m3ga> makes me sad
01:28:48 <otters> well, it's equally hard when it's up
01:30:03 <raichoo> Cale: +100
01:30:51 <pingao> hello
01:30:53 <mgsloan> otters: that's what she said! *badum-tish*
01:31:21 <otters> ok
01:31:24 <otters> I got it working, though!
01:31:29 <otters> I only had to install 1 duplicate version of readline
01:31:35 <otters> And edit 2 .cabal files
01:31:39 <otters> and there you go
01:31:45 <tdammers> that is annoying
01:31:55 <tdammers> when a package doesn't specify an upper version limit for a dependency
01:32:04 <otters> why tf can't the readline package just use the builtin readline lib that comes with OSX?
01:32:10 <tdammers> and then a new version of the dependency appears that breaks compatibility
01:32:21 <otters> tdammers: actually, the dependencies were too old
01:32:31 <tdammers> hmmm
01:32:35 <otters> directory-1.0.0 or whatever was trying to call a function in System.IO that no longer existed
01:32:38 <otters> so I had to updaet it
01:32:42 <solirc> that way around is actually more common
01:32:54 <tdammers> well, I just ran into two instances of too-new packages
01:33:09 <otters> I think I'm going to find out why readline is so confused and hurt by my builtin libreadline.dylib
01:33:11 <tdammers> something that was written against an older attoparsec
01:33:32 <otters> once hackage is back
01:33:40 <tdammers> newer version doesn't expose many for some reason, so the package build breaks
01:33:59 <tdammers> forcing it into the minimum requirement's major and minor version worked
01:34:10 <otters> :|
01:34:44 <solirc> tdammers: why not just fix the dependent code?
01:38:09 <tdammers> solirc: that's what I did
01:38:19 <tdammers> or rather, I fixed the dependent code's .cabal
01:38:38 <tdammers> but the whole thing didn't work anyway, so I switched to a different lib
01:38:46 <tdammers> that one built flawlessly
01:41:35 <solirc> tdammers: I meant adding an `import Control.Applicative` instead of adapting the cabal file ;)
01:43:27 <tdammers> well, ditching the entire package for a better alternative turned out to be the solution
01:47:34 <chancez> hackage is timing on me on the website and through cabal, anyone have any ideas why?
01:48:17 <shachaf> chancez: See topic.
01:49:05 <chancez> sorry had a lot of users, didnt even see it
01:49:10 <chancez> thanks!
01:50:02 <osfameron> it's not mirrored?
01:52:55 * edsko is crippled without hackage..
01:57:48 <t7> behead those who insult haskell
01:58:12 <Nimatek> eta reduce them!
01:58:16 <silver> yeah it'll be fun for awhile
01:58:41 <tdammers> map tail $ filter insultsHaskell $ those
01:58:51 <t7> behead those who call islam a violent religion
01:59:09 <tdammers> behead those who demand people are beheaded
01:59:13 <tdammers> no wait...
01:59:21 <silver> too late!
01:59:28 <ion> Behead those who use excess ($)s
01:59:38 * silver chopps tdammers' head off
01:59:43 * tdammers is doubly fucked
02:04:57 <mgsloan> alpha rename them as sinners! and eta reduce them in hell!
02:07:15 <yitz> > repeat '$'
02:07:16 <lambdabot>   "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$...
02:07:19 <yitz> oops
02:08:07 <mroman> probably repeat x = cycle [x]
02:08:11 <mroman> @src repeat
02:08:11 <lambdabot> repeat x = xs where xs = x : xs
02:08:17 <mroman> @src cycle
02:08:17 <lambdabot> cycle [] = undefined
02:08:18 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
02:08:32 <mroman> ok. but they're doing the same anyway.
02:31:16 <beaky> I'm learning haskell, and I feel lost :( it's so different from other programming languages
02:31:36 <Botje> beaky: good, huh? :)
02:31:37 <Yrogirg> when will hackage be back?
02:31:46 <Adeon> getting used to functional programming mindset usually doesn't happen instantly
02:31:53 <shachaf> Yrogirg: Probably not within the next 10 hours.
02:31:56 <Botje> beaky: anything in particular we can help you with?
02:32:20 <beaky> nope :D
02:32:29 <srhb> beaky: In fairness, it's not that different from other functional languages. But I guess that distinction doesn't help you much. :-)
02:32:42 <ThomasLocke> shachaf, Yikes! It sounds like you have some inside information, and it doesn't sound too good.
02:32:54 <beaky> the only programming languages I'm familiar with are C and python
02:33:09 <shachaf> ThomasLocke: My inside information is the time zone that Galois is in.
02:33:14 <srhb> beaky: Yeah, big difference then. :)
02:33:20 <shachaf> ThomasLocke: It's a guess that you oughtn't rely on. :-)
02:33:21 <beaky> the only old friend I see in Haskell is map
02:33:29 <mel-> beaky: yeah, it's really like learning programing from the start then
02:33:35 <srhb> beaky: That does get you a long way thoug. ;)
02:34:36 <beaky> is there a 'Haskell for dummies' or 'Learn Haskell in 21 days' text?
02:34:47 <barrucadu> @where lyah
02:34:48 <lambdabot> http://www.learnyouahaskell.com/
02:34:50 <Botje> beaky: 21 years more likely.
02:34:55 <Botje> beaky: LYAH is very good, though.
02:35:10 <beaky> i'm using that
02:35:11 <beaky> :D
02:35:12 <srhb> Seconded. LYAH is a great goto.
02:35:43 <trem> can someone recommend me a way to get a recent ghc up and running on fedora 17? i'm new to fedora, coming from gentoo
02:35:44 <raichoo> Friend of mine is a long time Perl hacker, he loves LYAH and now he is hooked on haskell :)
02:35:47 <mel-> beaky: if there's some kind of showstopper for you, just ask here
02:35:51 <beaky> alright
02:36:05 <srhb> trem: Isn't the Haskell Platform available for Fedora?
02:36:33 <trem> srhb, yes, but some 2011 release as i interpret the yum output
02:36:53 <srhb> trem: That sounds very recent though. Do you explicitly need some new feature?
02:37:25 <ThomasLocke> shachaf, What timezone is Galois in, and is he alone in running the hackage site?
02:38:01 <shachaf> ThomasLocke: Galois is a company, and they're in Pacific time (2:37 right now)
02:38:17 <trem> srhb, i'm frequently running into version conflicts which is a bit frustating, i'm not used to that with using the latest and greatest
02:38:54 <srhb> trem: According to this page, you might want to wait a little while and have it thrown your way. http://fedoraproject.org/wiki/Features/GHC74 -- otherwise just install ghc and cabal from source.
02:40:57 <trem> srhb, fedora has this "rawhide" thingie where ghc 7.4 lives, i guess i'll figure out how to use it. with hackage being currently down i can't do much anyway atm
02:41:01 <trem> srhb, thanks
02:42:17 <trem> are there any plans to set up a hackage mirror? not that it's down often, but as i see now it really hurts when it is...
02:42:30 <srhb> It does hurt a lot.. I haven't heard of any plans.
02:43:02 <shachaf> trem: You should ask ThomasLocke about that!
02:43:28 <trem> maybe hackage 2 will have some support for setting up mirrors. i heard it's about to arrive soon. :-)
02:44:51 <wiz> :t (++)
02:44:52 <lambdabot> forall m. (Monoid m) => m -> m -> m
02:45:17 <srhb> trem: There is, hackage-mirror -- I think that's exactly what it does.
02:45:57 <stwien> cabal update fails with "cabal: does not exist" or "cabal: <socket: 3>: resource vanished". Any pointers?
02:46:42 <srhb> stwien: Hackage is down.
02:46:49 <srhb> That's probably it. :)
02:47:15 <hayashi> I was wondering if it was down or just me =P
02:47:57 <stwien> OMG!!! (I just thought what I did wrong or if it is my connections). Thanks!!
02:48:09 <edsko> does foo :: Monad m => m (a -> m b) -> a -> m b ; foo f x = f >>= ($ x)  have a name?
02:48:42 <beaky> is it true that Haskell makes you go through lots of hoops to accomplish practical things?
02:48:47 <srhb>  beaky: No.
02:49:12 <fmap> :t ap
02:49:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:49:25 <mauke> :t \f -> ap f . return
02:49:26 <beaky> I only know of xmonad as a reasonably complicated project written in haskell. what are some other haskell projects?
02:49:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
02:49:34 <Adeon> do know that it is possible that #haskell is biased
02:49:45 <srhb> It's not only possible, it's guaranteed :P
02:49:46 <mauke> beaky: ghc, darcs
02:49:53 <beaky> lol
02:49:54 <Adeon> but probably less than all those other infidel programming language channels
02:50:01 <mauke> probably some web stuff
02:50:05 <mauke> lambdabot
02:50:19 <beaky> :t 2+2
02:50:21 <lambdabot> forall t. (Num t) => t
02:50:26 <ThomasLocke> I like that the Galois website has this under critical systems: "We build tools that guarantee reliability, availability, safety, and security." I see both reliability and availability in there! Apparently hackage isn't considered critical enough.  :D
02:50:49 <edsko> mauke: hm.
02:50:59 <beaky> haskell seems like a very safe language though
02:51:03 <LambdaDusk> damn hackage is down and I desperately need to know what is the function for vector length in the vector-space package
02:51:22 <Adeon> it's harder to shoot yourself in the foot
02:51:31 <Adeon> I think
02:51:44 <Adeon> you shoot yourself in the foot before the code compiles
02:51:50 <srhb> beaky: Unless you go around doing unsafePerformSomething and ignore compiler warnings, it is very very safe.
02:52:07 <fmap> :t (join .) . ap
02:52:09 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a1 -> m a) -> m a1 -> m a
02:53:28 <mauke> :t (. return) . ap
02:53:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
02:53:40 <edsko> lol
02:53:54 <edsko> yes, I guess that works
02:54:12 <srhb> Sections with (.) hurt my brain. :P
02:54:16 <srhb> I'm just not there yet.
02:54:32 <HalfWayMan> I wonder if Hackage being down is a good excuse to take a day off...
02:54:46 <shachaf> srhb: Fortunately it's not considered good style anyway.
02:54:58 <shachaf> So don't do it, and get rid of code that does it. :-)
02:55:01 <shachaf> Except on IRC, that is.
02:55:02 <fmap> :t (join .) . (. return) . ap
02:55:04 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a1 -> m a) -> a1 -> m a
02:55:07 <shachaf> > nubBy(((>1).).gcd)[2..]
02:55:09 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:55:10 <fmap> finally
02:55:43 <srhb> shachaf: Oh God. :P
02:55:55 <barrucadu> @pl \f x -> f >>= ($ x)
02:55:55 <lambdabot> (. flip id) . (>>=)
02:56:28 <edsko> meh :)
02:57:56 <cocon> what's going on with hackage these days? are there any mirrors?
03:00:04 <m3ga> hackage mirrors are a hackage2 feature. we're still on hackage 1.
03:00:33 <ion> I wonder host costly third-party CDNs are?
03:00:50 <ion> “host”? My tired brain combined “how” and “cost”. :-)
03:01:15 <LambdaDusk> ion: I think there some free ones, like cloudflare
03:02:24 <cocon> is it known why the current one is down...?
03:03:57 <trem> ion, funny thing is my brain parsed it correctly anyway
03:04:36 <trem> i wonder how much traffic hackage causes
03:13:45 <solrize> it should be a torrent
03:14:08 <solrize> so everyone could have their own mirror and seed it at the same time
03:15:53 <osa1> what package contains EitherT ?
03:16:13 <Baughn> "select(5, [3 4], [], NULL, {0, 18446744073709545808}) = -1 EINVAL (Invalid argument)"
03:16:34 <Baughn> Yes, the timeout parameter is obviously broken. The problem is, this call was produced by the RTS...
03:17:12 <mauke> > maxBound :: Word64
03:17:14 <lambdabot>   18446744073709551615
03:17:27 <edsko> osa1: maybe check out ErrorT instead
03:18:49 <osa1> edsko: hmm.. thanks
03:20:14 <fmap> osa1: there are Peaker's EitherT and ekmett's either packages
03:31:15 <Baughn> Hm, hackage down?
03:31:15 <srhb> Yup.
03:31:15 <trem> Baughn, hm hm
03:34:28 <HugoDaniel> haskellwiki is done in what software ?
03:34:45 <HugoDaniel> gitit ?
03:35:32 <bitonic> HugoDaniel: haskellwiki is mediawiki
03:36:10 <Nereid> php on a haskell website :)
03:36:19 <HugoDaniel> oh ok
03:36:23 <osa1> what's wrong with this code? I'm not sure how newtype is working, I got this code from RWH and modified it, but didn't work. I'm getting "Illegal instance declaration for `MonadError TError m'" error
03:36:45 <Nereid> paste?
03:36:52 <fmap> with what code?
03:37:11 <osa1> lol, sorry http://hpaste.org/71323
03:37:44 <Nereid> what
03:37:57 <Nereid> just derive MonadError.
03:38:18 <osa1> still same error
03:38:19 <Nereid> assuming ErrorT TError IO is a MonadError instance.
03:38:48 <Nereid> it doesn't matter that TError is an instance of anything.
03:39:05 <osa1> Nereid: "MonadError' is not a derivable class"
03:39:14 <Nereid> -XGeneralizedNewtypeDeriving ?
03:39:50 <Nereid> you need that
03:40:52 <HugoDaniel> where can i learn about using c2hs to easily bind function pointers ?
03:41:23 <hpaste> “david feng” annotated “remove first comment in a directory all .h and .c file” with “C header file comment remove utility” at http://hpaste.org/71308#a71325
03:42:28 <osa1> Nereid: strange. I was using "type IOThrowsError = ErrorT TError IO" with throwError, but suddenly I got started getting an error like "IOThrowsError is not instance of MonadError" . Could it be related with GADTs? Because I started getting this error after started using GADTs
03:43:54 <Nereid> I don't see how
03:44:24 <osa1> hmm, ErrorT is already instance of MonadError
03:44:38 <Nereid> indeed
03:46:50 <osa1> Nereid: I pasted parts related with errors and the full error message: http://hpaste.org/71326
03:47:38 <hpc> what's TError?
03:47:45 <Nereid> it's defined up top
03:48:32 <hpc> oh
03:49:31 <Nereid> osa1: oh
03:49:35 <Nereid> well, look at your types
03:49:42 <Nereid> @hoogle throwError
03:49:42 <lambdabot> Control.Monad.Trans.Error throwError :: (Monad m, Error e) => e -> ErrorT e m a
03:49:42 <lambdabot> Control.Monad.Error.Class throwError :: MonadError e m => e -> m a
03:49:42 <lambdabot> Control.Monad.Error throwError :: MonadError e m => e -> m a
03:50:26 <Nereid> uh
03:50:51 <osa1> what's wrong? TError is instance of Error
03:51:25 <osa1> wow
03:51:39 <osa1> do I need to import Control.Monad.Trans.Error instead of Control.Monad.Error?
03:51:47 <Nereid> I doubt that's the problem.
03:51:47 <hpc> no
03:51:54 <Nereid> what's our MonadError instance here
03:52:09 <Nereid> MonadError TError (ErrorT TError IO), right?
03:52:10 <osa1> Nereid: ErrorT ?
03:52:43 <Nereid> oh
03:52:51 <Nereid> uh
03:53:01 <Nereid> ok, what's up with this
03:53:35 <Nereid> what's this m0 that ghc is yelling about
03:53:49 <mgsloan> ErrorT: Striking TError into the hearts of men since the mid 1990s
03:54:00 <mgsloan> (except probably more recent I suppose)
03:54:01 <hpc> instance (Monad m, Error e) => MonadError e (ErrorT e m)
03:54:10 <hpc> it should work...
03:54:17 <Nereid> ....
03:54:47 <osa1> wow, that's strange. importing Control.Monad.Trans.Error instead of Control.Monad.Error worked
03:54:58 <Nereid> hmm
03:55:09 <Baughn> Hackage is down, yes. *Why* is hackage down?
03:55:32 <Nereid> osa1: were you importing something that imported Control.Monad.Trans.Error or so?
03:55:40 <hpc> Baughn: hackage goes down, hackage goes up; never a miscommunication
03:55:52 <Baughn> I demand satisfaction!
03:55:54 <hpc> you can't explain that :P
03:56:06 <osa1> Nereid: no.
03:56:15 <Nereid> hmm.
03:56:22 <Nereid> what were your imports, then
03:57:06 <Nereid> (except with hackage down, I couldn't look up docs for them...)
03:57:48 <hpc> Nereid: you can cheat and use hoogle and ghci :info
03:57:49 <osa1> Nereid: parsec, Data.List (intercalate) , System.IO (handle) , Data.IORef
03:57:51 <donri> days like this i'm really glad i use cabal with --enable-documentation :)
03:58:27 <Nereid> nothing unusual, then
03:58:29 <Nereid> weird.
03:59:31 <osa1> Nereid: are we absolutely sure that it isn't related with GADTs ?
03:59:52 <Nereid> what GADTs
04:00:08 <osa1> because as far as I can tell, I started getting this error after started using GADTs. but I didn't compile the code for a while after started writing GADTs, so I'm not sure just where exactly I started getting this error
04:00:22 <osa1> Nereid: language extension, generalized abstract data types
04:00:27 <Nereid> I know what they are
04:00:32 <osa1> ..
04:00:35 <Nereid> but I don't see any GADTs
04:00:48 <osa1> let me paste the full code
04:00:51 <Nereid> sure
04:01:43 <osa1> Nereid: there are lots of testing going on, sorry for the mess: http://hpaste.org/71327
04:02:53 <hpc> osa1: uh...
04:02:53 <Nereid> well
04:03:02 <osa1> ?
04:03:07 <hpc> i just switched the import back to Control.Monad.Error and it worked for me
04:03:20 <Nereid> :V
04:03:39 <osa1> hpc: now it works for me too. wtf
04:03:42 <Nereid> haha.
04:03:43 <hpc> $ ghc -V
04:03:43 <hpc> The Glorious Glasgow Haskell Compilation System, version 7.4.1
04:03:46 <hpc> lol
04:04:05 <hpc> osa1: glad i could help ;)
04:04:31 <osa1> lol. thanks.
04:04:37 <hpc> a reverse heisenbug
04:04:43 <Nereid> lol
04:04:44 <hpc> it doesn't work until somebody observes that it actually does
04:04:47 <osa1> heisenbug?
04:04:52 <osa1> hahah
04:05:00 <hpc> osa1: never read the jargon file?
04:05:15 <hpc> http://www.catb.org/jargon/
04:05:20 <mcstar> why heisenberg?
04:05:44 <Nereid> why not?
04:06:02 <mcstar> you tend to laugh at everything?
04:06:10 <mcstar> wo understanding i mean
04:06:19 <Nereid> what?
04:06:39 <ion> …
04:07:13 <hpc> oh, it's a reverse schroedinbug
04:07:21 <donri> mcstar: reference to heisenberg's uncertainty principle
04:07:29 <srhb> hpc: Yeah, that is more accurate.
04:07:35 <mcstar> why doest make sense, since its the measurement problem
04:07:37 <Nereid> I agree, but it doesn't sound the same
04:07:42 <mcstar> and has to do with the sch's cat
04:07:51 <mcstar> which*
04:08:05 <sqrt> So if I have a list of (x,b) where b is a boolean and I want to throw away all the tuplets where b is false.
04:08:19 <mcstar> anyway, the runtime doesnt print the GC summery information, when i tell it to print it with +RTS -s
04:08:30 <sqrt> I'm guessing there is some more elegant solution rather than if then else?
04:08:43 <Nereid> sqrt: filter
04:08:48 <srhb> filter on..
04:08:51 <sqrt> Thanks, looking it up.
04:09:53 <Botje> :t filter
04:09:55 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:10:14 <Botje> so you need to write a function (x, Bool) -> Bool and plug that into the first argument to filter
04:10:57 <Nereid> (this other function also exists in the Prelude)
04:10:59 <sqrt> no problem.
04:11:44 <sqrt> Thanks!
04:12:48 <ksf> cabal: Error: some packages failed to install:
04:12:48 <ksf> curl-1.3.7 failed while downloading the package. The exception was:
04:12:48 <ksf> connect: does not exist (No route to host)
04:12:59 <barrucadu> Hackage is down.
04:13:01 <Nereid> topic ;)
04:13:05 <mxf> I'm fairly new to Haskell; tried to install Takusen via cabal http://labs.qu.cx/_/takusen.txt i have no idea how to debug this…
04:13:16 <mxf> The Glorious Glasgow Haskell Compilation System, version 7.4.1
04:13:37 <mxf> any pointers?
04:13:38 <ksf> last hackage downtime, we talked about a distributed hackage.
04:13:53 <ksf> we already have a torrent client, the problem is updates, though.
04:14:10 <Nereid> mxf: aha.
04:14:40 <Nereid> mxf: that package doesn't work with the new base
04:14:51 <Nereid> ghc 7.4 removed the dependency of Num on Show/Eq
04:14:53 <ksf> torrents don't really excel when they're too small, but as a quick hack a torrent per .tgz would suffice.
04:15:12 <yitz> @where hackagemirror
04:15:12 <lambdabot> http://hackage.factisresearch.com/
04:15:31 <ksf> yitz, down.
04:15:33 <mietek> *sigh*
04:15:36 <hpc> you could use DHT to get the same peering effects as torrent
04:15:45 <hpc> and write our own protocol on top that can handle updates
04:15:51 <ksf> rss
04:15:57 <mietek> Is the Haskell Platform available from anywhere else?
04:15:59 <zachk-in-spades> is there any sort of well tested distributed file share, other then torrent?
04:16:14 <hpc> zachk: windows homegroup ;)
04:16:21 <mcstar> tribler
04:16:25 <zachk> is it an open standard
04:16:27 <ksf> afs
04:16:29 <mcstar> (not sure about well tested)
04:16:31 <yitz> urg
04:16:32 <zachk> windows homegroup
04:16:52 <hpc> zachk: it actually might be...
04:16:55 <hpc> i haven't checked
04:16:56 <mxf> Nereid, ah, i see. thanks.
04:17:08 <zachk> ms might fund it :-9
04:17:09 <yitz> mietek: what platform?
04:17:27 <ksf> actually, we only need a way to push package index updates.
04:17:46 <hpc> which we have, in the form of cabal
04:18:06 <hpc> the index isn't going to update while hackage is offline
04:18:09 <ksf> the index then includes the torrents... no reason to mess with magnet links, there. include some well-known and stable trackers.
04:18:15 <ksf> (like tracker.ccc.de)
04:18:16 <hpc> oh
04:18:19 <trem> i think a few old school mirrors would be best. if there is a distributed file store, people would start distributing priated stuff over it anyway.
04:18:25 <mietek> yitz: most recent for Linux i386
04:18:40 <Nereid> trem: sign things, then
04:18:55 <Nereid> ??
04:18:58 <zachk> trem: good point
04:19:02 <ksf> why would anyone use cabal to torrent pirated stuff if there's actual torrent clients?
04:19:08 <Nereid> haha
04:19:09 <zachk> they will
04:19:17 <ksf> I don't see why.
04:19:30 <Nereid> someone will just because they can
04:19:53 <however> hackage down again, or still? (heard about it yesterday)
04:19:56 <Nereid> still
04:19:57 <zachk> so signing torrents, then we need a signing authority. etc...
04:20:04 <ksf> and how would they inject that pirated stuff into the package database, without a hackage account?
04:20:11 <trem> because it's possible, and it's somewhat "safe" because it is *not* torrent. there is enough infrastructure to monitor torrent traffic and automatically sue them / whatever
04:20:17 <Nereid> zachk: that would be hackage
04:20:27 <zachk> but what if hackage is down
04:20:28 <mcstar> so, is haskell now a sinking boat?
04:20:35 <Nereid> zachk: then no new things can be signed
04:20:41 <ksf> trem, you're already sharing the internet with piracy. sharing the protocol won't really change stuff.
04:20:47 <Nereid> but everything would still be available
04:20:47 <hpc> mcstar: haskell is like taco bell
04:20:59 <hpc> (full of burritos)
04:21:06 <Nereid> ah yes, burritos
04:21:15 <trem> ksf, tell this the lawyers / isps blocking torrents and so on :-)
04:21:19 <silver> and by buritos I mean monad tutorials
04:21:19 <mcstar> hpc: but wo hackage, haskell just cant go on, will vanish
04:21:29 <ksf> why should anyone block torrents?
04:21:31 <zachk> it was around before hackage
04:21:37 <ksf> sue them for advertising internet but not delivering it.
04:21:40 <trem> i just thought it might become a problem. it has become a problem for all distributed file shares i'm aware of.
04:21:50 <trem> (apart from windows home groups)
04:22:08 <mietek> The ICFP contest starts tomorrow
04:22:14 <mietek> It's really not good that hackage is down
04:22:21 <luite> http://hdiff.luite.com/packages/archive also works as a package mirror
04:22:31 <ksf> eg. the spring project uses torrent nearly exclusively to distribute maps, games etc.
04:22:38 <ksf> it's well established in the floss-world.
04:22:48 <mcstar> whats the connection between RTS not showing the summary information, and spawning a process and writing to it?
04:22:53 <however> luite: thanks! that's handy
04:23:18 <srhb> Yeah, I expect hackage to have quite a lot of traffic from tomorrow.
04:23:45 <trem> luite, can i just plug this url into my cabal config and it will work?
04:24:06 <luite> yeah, the line: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
04:24:13 <yitz> mietek: here, i just uploaded it to my google drive: https://docs.google.com/open?id=0B2xmwgStRt5xR2NyWktIOHgtSU0
04:24:36 <cads> can cabal files run shell commands, process data, run tests, push to repos, and that kind of stuff?
04:24:40 <mcstar> and, when i write the summary into file, -sfile, it is basically empty
04:24:49 <cads> and if no, is there a preferred haskelly solution for that kind of stuff?
04:25:32 <mietek> yitz: thanks!
04:25:34 <cads> I think make can do some of that kind stuff
04:25:57 <luite> trem: you probably need to comment out the hackage.haskell.org line while it's down, and run cabal update first
04:26:00 <however> cads: running tests -- yes. other than that, not that i know of. what you can do is write a Setup.hs (Setup.lhs), which afaik is a full-fledged haskell program
04:26:15 <trem> luite, wow, thanks! this works. maybe this line should be in the channel topic. :-)
04:26:21 <cads> and in the ruby world there is rake, which is more readable and modern feeling than make stuff (to me at least)
04:27:00 <luite> oh the factisresearch one is also down?
04:27:07 <b52> i like scons
04:27:19 <luite> yeah then it would be a good idea to mention this one :)
04:27:21 <srhb> luite: Yeah
04:28:16 * cads is considering using some ruby scaffolding for minor tasks like managing TODOs, writing little commandline scripts, wrapping git, etc.
04:28:16 <cads> that is, in haskell projects
04:28:26 <cads> I don't know how well that'll work
04:29:15 <cads> but I'm not convinced that haskell would do a better job at that kind of stuff than bash script would
04:29:24 <srhb> cads: Have you checked out Shelly?
04:29:29 <yitz> if anyone needs haskell platform 32-bit for mac os x, i also uploaded that to my google drive: https://docs.google.com/open?id=0B2xmwgStRt5xSkE3V0d5dzI2d0k
04:29:48 <cads> and if I'm having to write shell script, might as well do it in a language that can be zen and FPish, like ruby
04:29:58 <cads> srhb, I'll look at that
04:30:08 <yitz> however, i haven't gotten around to updating HP on my windows box yet. if anyone has HP for windows and can upload somewhere, please do, and notify here
04:30:42 <cads> my statements are like a challenge to #haskell - is there something haskllish that is more joyful to use for this task than ruby :)
04:32:00 <yitz> cads: every cabal project contains a file called Setup.hs. usually it's a standard trivial one-liner, but you can put anything there you'd like
04:32:49 <yitz> cads: that said, it's usually not considered a very good idea to pull that kind of trickery. it can mess up some people.
04:33:12 <mm_freak> hackage still down?!
04:33:12 <b52> does "cabal build" use the setup.hs ?
04:33:36 <b52> mm_freak: looks like
04:33:38 <yitz> cads: it's usually used for projects that have special complex build requirements for FFI components in the package.
04:33:52 <luite> mm_freak: hackage mirror: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
04:34:05 <mm_freak> luite: thanks
04:34:16 <yitz> cads: so when you do that, it's probably not going to work for everyone, but at least it will work for some people
04:34:17 <cads> yitz, I guess the publish functionality of the scaffolding could produce a clean cabal project
04:34:24 <however> b52, cads: to activate Setup.hs iirc you need to set an option in the .cabal file. it's called "build-type: Custom" or some such
04:34:29 <yitz> cads: certainly *much* better than using ruby scripting though
04:36:52 <yitz> cads: i'll admint that i have a collection of bash scripts that help my cabal projects interact with mercurial and a few local yackage servers
04:37:42 <cads> yitz, a simple example of the kind of functionality I'm talking about would be something that lets you commit to a file of working notes, to document aspects of your work that don't fit well into the commit messages
04:38:28 <cads> or something that will collect all the TODO entries you might have sprinkled through your files
04:39:53 <cads> I don't know why I should be averse to using haskell for that kind of thing.. lemme try to explain
04:40:07 <srhb> You shouldn't. Both are trivial to implement in Haskell.
04:40:33 <cads> it would feel like using hs for that kind of task would be too much ceremony for a trivial task
04:40:56 <srhb> Try writing it in both, especially the Todo one should be very fast for you, and then compare.
04:41:07 <srhb> The haskell implementation at least is quite unceremonious and fast.
04:41:10 <luite> shelly is kind of slow if you have a huge number of files
04:41:24 <luite> but for smaller trees it should work ok
04:45:39 <cads> I'll try out shelly scripting, and crack open real world haskell to the shell scripting chapter
04:45:39 <cads> and compare my ruby, bash, and hask solutions
04:45:39 <cads> you guys will laugh when you see this: http://pastie.org/4242828
04:45:39 <cads> this is a little changelog script that I use to document changes to my system configuration
04:45:39 <cads> so if I install a package or tweak a config, I press a keyboard shortcut, and up pops a terminal with the changelog file, and a datestamped entry ready to be written
04:45:39 <cads> note that even if I don't save the file the datestamp is still written :)
04:45:40 <cads> and if I accidentally invoke multiple copies, an entry will get lost :D
04:47:06 <srhb> cads: Well, the functionality is good and clever, I might duplicate that!
04:48:07 <cads> it's _awesome_ to grep a date or keyword and know exactly when you did the change
04:48:10 <wiz> cads, can't you just use console twitter client for this? (=
04:48:48 <hpc> you can abstract it out to something like ./changelog "installed this thing from cabal or whatever"
04:49:00 <cads> yeah
04:49:12 <hpc> if you want to be really silly, do it in perl
04:49:18 <hpc> with a __DATA__ or whatever at the end
04:49:20 <cads> I like to write multiple lines
04:49:55 <hpc> write your changelog to the same file as the code that manipulates it
04:49:56 <cads> * installed blobs from cabal
04:50:36 <cads> - installed dependencies: wxwidget2.9-dev, glut2-dev, cairo-dev
04:51:05 <cads> - extensible haskell based graph editor
04:51:50 <cads> I think I might be able to get markdown to display it or something like this
04:51:55 <srhb> I really like this idea of annotating work in that way. I never even thought about it.
04:52:52 <cads> I tried it with paper and pencil - my sysadmin notebook.. all the software installs, config, etc... and it was _really_ useful
04:52:58 <hpc> i generally just use a hand-maintained global todo.txt
04:53:31 <hpc> it's in dropbox so i can edit it anywhere, and opens on my main computer when i do a three-finger press on the touchpad
04:53:37 <cads> but it became unwieldy to summarize things
04:53:42 <cads> hpc nice!
04:54:04 <hpc> for larger tasks
04:54:07 <hpc>   subtasks get indente
04:54:10 <hpc>   d
04:54:11 <cads> when I do super-c, or type changes in the terminal, my log appears
04:54:12 <hpc>   like this
04:55:03 <cads> there's a difference between a log and a todo
04:55:08 <hpc> true
04:55:24 <cads> but maybe the todo items could migrate to the log automatically
04:55:44 <cads> with a prompt for you to annotate with useful info
04:56:18 <cads> you has a task, then you do it, and you write a short line or two saying how you did it
04:56:39 <cads> because nothing is more annoying than having to repeat a task down the line and forgetting that neat trick you used :D
04:57:37 <cads> I'll be interested to see if this history thing is actually useful weeks and months down the line
04:57:50 <hpc> where i work we have an in-house notes website that's basically exactly this
04:58:05 <hpc> it's so good that my boss has a standing offer to work at evernote, whenever he wants
04:58:14 <cads> what's that called?
04:58:18 <hpc> notethat
04:59:44 <JackHind> :t <|>
04:59:46 <lambdabot> parse error on input `<|>'
05:00:00 <hpc> :t (<|>)
05:00:02 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
05:00:20 <cads> hpc, that's nice
05:00:41 <cads> if it's got a commandline interface I'll adopt it :)
05:00:47 <JackHind> hpc: thanks
05:01:12 <cads> wiz, the idea of a commandline twitter client made my day
05:01:13 <hpc> cads: heh, nope
05:01:26 <hpc> plus you would have to buy web hosting first
05:01:30 <cads> wiz, I think that is how to use twitter
05:01:39 <hpc> it's a customer freebie, not a product ;)
05:01:58 <cads> not the website, not tweetdeck, not some desktop social platform
05:01:59 <wiz> cads, yeah. and then it comes to twitter syslog backend.. (:
05:02:24 <cads> wiz, so your system tweets to you?!
05:03:17 <wiz> cads, omg, it's real! http://gyp.blogs.balabit.com/2009/09/make-your-servers-tweet/
05:04:02 <cads> hmm
05:04:21 <cads> sounds like a security risk
05:04:35 <cads> but you could sanitize the messages
05:04:43 <mroman> My ghc tweets every error it encounters, I then check the errors of my programs on twitter.
05:04:46 <cads> heck, make your server tell random jokes from time to time
05:04:47 <mroman> Because I'm so Web 2.0 .
05:05:01 * wiz thinks of a private xmpp room for all my servers to sit there and post cat pics
05:05:29 <Taneb> class Functor' f a b where fmap' :: f (a -> b) -> f a -> f b; instance Functor f => Functor' f a b where fmap' = fmap; instance (Ord a; Ord b) => Functor Set a b where fmap = S.map
05:06:05 <hpc> cads: fortune has a whole database of them
05:06:08 <Nereid> Taneb: that's called Applicative
05:06:19 <Taneb> I meant to keep the type of fmap
05:06:31 <Taneb> Otherwise nothing else would typecheck7
05:07:01 <Nereid> Taneb: what are you doing?
05:07:01 <cads> hpc, yeah, you can tell it to give you 50% serious quotes, and 40% funny quotes, and 10% quotes taged with the "obscene" tag, for example
05:07:06 <Taneb> Thinking outloud
05:07:13 <Nereid> ok :)
05:07:21 <Saizan> Taneb: the two instances you've given overlap though
05:07:29 <Taneb> Set isn't a functor
05:07:30 <Nereid> but not every Functor is an Applicative
05:07:36 <Saizan> Taneb: doesn't matter
05:07:53 <Taneb> So how do they overlap?
05:08:11 <Nereid> wait
05:08:13 <Taneb> They overlap if someone defines a Functor instance for Set, that's how, isn't it?
05:08:14 <Saizan> because the overlapping is decided by only looking at the instance heads, not the constraints
05:08:16 <Nereid> I just noticed the a b dangling
05:08:25 <Saizan> Taneb: no, they already overlap
05:08:38 <Taneb> Oh, huh
05:09:14 <Saizan> Taneb: and the check is like that because instance resolution does the same, and the motivation is to keep it stable in an open-world context
05:09:25 <Taneb> Okay
05:09:53 <Taneb> Hackage is still down
05:11:14 <luite> Taneb: hackage mirror (no haddock unfortunately): remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
05:11:27 <Taneb> I'm after the haddock because I'm really bored
05:11:40 <luite> oh in that case, build it locally :p
05:15:40 <hpc> luite: how large is your mirror?
05:16:15 <luite> hpc: uh, as big a s hackage
05:16:30 <hpc> i mean
05:16:40 <luite> it has all packages and versions
05:16:58 <hpc> would it fit on a flash drive, a hard drive, a NAS?
05:17:09 <luite> oh, it's not that big, a few GB
05:17:14 <hpc> awesome
05:17:33 <hpc> i might make a mirror then
05:17:57 <mietek> yitz: is that file supposed to be just 2.7M?
05:18:17 <Taneb> Would it be possible to create a client-side haddock generator?
05:18:37 <luite> Taneb: cabal can do that
05:18:49 <Taneb> For a browser, I mean
05:19:05 <luite> oh
05:19:07 <luite> uh
05:19:13 <luite> i guess with ghcjs :)
05:22:08 <aristid> so byorgey said on reddit that DataKinds are an unadvertised feature of GHC 7.4. i didn't know that, and isn't the feature rather well-known for being unadvertised? :)
05:25:38 <Taneb> Is it bad that I don't have the latest version of my own package installed?
05:26:44 <Baughn> I neeed hackage! *NEeeeed*!
05:26:56 * Baughn is disappoint.
05:27:07 <Baughn> Anyone got a mirror?
05:27:09 * Taneb is equally disappoint
05:27:19 <mauke> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
05:28:11 <pielgrzym> why is hackage.haskell.org down?? :)
05:28:23 <Taneb> Because everyone keeps asking about it
05:28:54 <yitz> mietek: i think so. the hp package for linux assumes you have the appropriate ghc installed already.
05:29:11 <yitz> mietek: in this case 7.4.1
05:29:27 <yitz> recommended, though it might work ok for something else close to that.
05:30:55 <yitz> mietek: if not, you should either get the right ghc from your os's package system if they have it, or get the generic linux ghc install tarball
05:31:20 <yitz> mietek: (which you probably can't, because ghc's devel site is on the same machine as hackage. :( )
05:31:22 <aristid> yitz: ghc 7.4.2 should work equally well, no? being a bugfix release and all :)
05:32:44 <yitz> aristid: yes it ought to. but there could be minor infelicities you need to fix. and you won't be on *exactly* the same platform as other platform users, fwiw.
05:33:50 <aristid> yitz: right, but then ghc 7.4.2 also fixes bugs in ghc.
05:35:48 <mietek> yitz: I was actually able to get ghc 7.4.1, thanks
05:35:48 <yitz> aristid: right. now that 7.4.2 has been out for a bit and no one has noticed any problems (that i heard of), i'm guessing they'll soon do a minor haskell platform version bump that just upgrades ghc.
05:35:58 <yitz> mietek: great glad to hear
05:36:05 <mietek> Now trying to set up dependencies for HP manually on debian squeeze...
05:37:13 <yitz> oh i see i've got the 7.4.1 tarball for linux. i'll uploaded it.
05:37:20 <yitz> that will take a while though.
05:39:14 <aristid> mietek: do you use a distribution that offers ghc 7.4.x in its native repositories?
05:39:18 <yitz> mietek: where'd you get ghc 7.4.1?
05:40:55 <yitz> aristid: maybe he meant that it's unadvertised that it's unknown. everyone thinks it's known.
05:41:11 <mietek> aristid, yuitz: http://www.haskell.org/ghc/dist/7.4.1/ghc-7.4.1-i386-unknown-linux.tar.bz2
05:41:22 <aristid> yitz: quote "I should also point out that DataKinds was not an "officially advertised" feature of GHC 7.4.x, and in particular the implementation had lots of bugs."
05:41:28 <yitz> luite: wow thanks!
05:42:27 <yitz> mietek: ah, good, it's on the main ghc site, not the developer site. so my (huge) uploaded isn't needed. thanks!
05:42:42 <mietek> I see the organizers of ICFP have now announced they accept packages from Debian wheezy
05:42:45 <mietek> *sigh*
05:42:46 <aristid> haha, there's a haskell history paper with the subtitle "Being lazy with class". with haskell, the puns just write themselves :D
05:43:01 <mietek> So what does that mean?  The base system still has to be Debian squeeze?
05:43:22 <aristid> mietek: well, squeeze is stable, right?
05:43:25 <mietek> Yes
05:43:37 * mgsloan 's workshop proposal is titled "Deriving Class with Instance Templates" ;)
05:43:46 <aristid> mietek: debian's release schedule is painful for those who want to live on the bleeding edge! :)
05:43:53 <mietek> I was looking into how to install packages from wheezy on squeeze, and found out about backports.  HP is not in backports.
05:43:55 <Nereid> fwiw, gentoo has 7.4.1
05:44:07 <aristid> Nereid: why not 7.4.2?
05:44:10 <wiz> Does GHC 7.4 use epoll for IO if it's available? Looks like no, because my happstack crashes with "select id > 1024" error ):
05:44:55 <yitz> wiz: i think it has used epoll for a while already
05:45:09 <Nereid> aristid: that's not in the official repository yet
05:45:22 <yitz> wiz: what platform are you on?
05:45:37 <wiz> um... that one with ghc 7.4
05:45:38 <kosmikus> doesn't it depend on -threaded or not?
05:45:38 <yitz> wiz: could be happstack is using something old
05:49:49 <tdammers> hey, does anyone know of a way to get simpleirc to work with ssl?
05:53:22 <yitz> wiz: no i meant linux, windows, solaris, etc. that last one being problematic, for example.
05:53:37 <wiz> linux
05:54:36 <yitz> kosmikus: you're saying that even on linux we still don't get the new IO system by default?
05:56:39 <mailson> hackage is down. is there any other way to download packages via cabal? setting a mirror or something?
05:57:26 <kosmikus> yitz: yes, I think so
05:59:15 <however> mailson: i think people have been having success with "remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive"
05:59:53 <tdammers> mailson: cabal can also install from a local directory
06:00:08 <tdammers> if you can find the package's source repo, or download a source tarball
06:00:13 <yitz> wiz: so you may need happstack compiled with the ghc option -threaded. if that's not the default in cabal file, you can force it with the cabal option --ghc-option=-threaded
06:00:25 <tdammers> you can just unpack it to ~/foo and then cabal install ~/foo
06:00:42 <wiz> yitz, yes, it hints to it. but performance tooks a nose dive ):
06:00:49 <yitz> wiz: but if happstack doesn't do that by default, it could be that would cause problems.
06:00:56 <donri> -threaded is only for executables
06:00:56 <yitz> ah
06:01:50 <donri> so, it might matter for your executable that uses the happstack server
06:02:00 <donri> but not for the happstack packages
06:02:37 <Jeanne-Kamikaze> is it me or is hackage down ?
06:03:27 <donri> also i think if there is a difference, it's that it's -threaded that doesn't have the epolling IO manager. that claim is made in monad.reader (19 i think?)
06:03:54 <mailson> tdammers: well. it has a lot of dependencies. but if the mirror doesn't work, i'll try this. thanks
06:03:59 <ThomasLocke> Jeanne-Kamikaze, It is down, and has been for quite a while.
06:04:10 <yitz> Jeanne-Kamikaze: down. luite was kind enough to put up a mirror. scroll up.
06:04:40 <mailson> however: should i pass this as an argument to cabal or is there some configuration file?
06:05:05 <yitz> yeah probably will be down until galois' it manager comes in to work on the us west coast today. another couple hours.
06:05:10 <Peaker> hackage is down?
06:05:14 <Peaker> oh, /topic
06:05:41 <mailson> however: found it -> ~/.cabal/config
06:05:47 <mailson> :)
06:07:33 <tdammers> hackage has seen too much downtime for my comfort lately
06:07:41 <luite> Peaker: hackage mirror (no haddock unfortunately): remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
06:07:59 <Peaker> luite, thanks
06:09:27 <donri> hackage2 has some memory issues that are being resolved, we might see it replacing hackage1 in the not too distant future
06:18:39 <MostAwesomeDude> > iterate (2 *) 1
06:18:41 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
06:18:52 <MostAwesomeDude> Ah, I understand now.
06:20:18 <Peaker> > let f = sum . zipWith (*) (iterate (2*) 1) . reverse   in   f [1,1,1,1,0]
06:20:21 <lambdabot>   30
06:20:30 <Peaker> binary decoder
06:20:57 <however> oh nice :)
06:21:25 <Botje> > foldl1 (\a b -> a * 2 + b) [1,1,1,1,0]
06:21:26 <lambdabot>   30
06:21:41 <luite> hpc: wget/1.12-hax ?
06:21:45 <Botje> less macho binary decoder ;)
06:22:15 <Peaker> > foldl1 (\a b -> a * 2 + b) []
06:22:16 <lambdabot>   *Exception: Prelude.foldl1: empty list
06:22:35 <kallisti> uh... hackage is still down. :/
06:22:38 <Peaker> so   foldl' (\a b -> a * 2 + b) 0   probably makes more sense
06:22:45 <Botje> well, yes. replace with foldl ... 0 :)
06:22:57 <luite> kallisti: hackage mirror (no haddock unfortunately): remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
06:23:09 <yitz> > let fromRadix b = foldl ((+) . (* b)) 0 in fromRadix 2 [1,1,1,1,0]
06:23:12 <lambdabot>   30
06:23:27 <kallisti> luite: I might do the same with my own dedicated server. or maybe host the haddock docs instead.
06:23:36 <kallisti> how much storage does it take?
06:24:00 <luite> is my mirror not good enough for you guys ;p
06:24:12 <kallisti> no it's fine. I was speaking about the future.
06:24:26 <yitz> > let toRadix b = reverse . map (`mod` b`) . takeWhile (> 0) . iterate (`div` b) in toRadix 2 30
06:24:27 <luite> heeh, hpc is already wgetting the whole thing i think
06:24:27 <lambdabot>   <no location info>: parse error on input `)'
06:24:36 <luite> kallisti: lemme check
06:24:59 <yitz> > let toRadix b = reverse . map (`mod` b) . takeWhile (> 0) . iterate (`div` b) in toRadix 2 30
06:25:01 <kallisti> can you have multiple remo-repo lines?
06:25:02 <lambdabot>   [1,1,1,1,0]
06:25:34 <yitz> kallisti: yes
06:25:38 <luite> kallisti: 23351 files, 1.6GB
06:25:44 <kallisti> ah that's not bad at all
06:25:59 <yitz> kallisti: they all need to be up and available for cabal update to work though
06:25:59 <kallisti> I could mirror that and host haddocks as well, most likely.
06:26:22 <pielgrzym> luite: would you be so kind and tell me how to use the mirror with cabal-install? arch seems not to provide any manpage with cabal-install package :(
06:26:33 <kallisti> pielgrzym: edit .cabal/config
06:26:39 <kallisti> comment out the existing remote-repo line
06:26:44 <kallisti> replace it with the new one.
06:26:48 <kallisti> then run cabal update
06:26:51 <luite> pielgrzym: add that line to your ~/.cabal/config, then comment out the hackage.haskell.org line (add -- ), run cabal update
06:27:04 <pielgrzym> kallisti: I haven't got this files since I today I couldnt run cabal update :)
06:27:14 <pielgrzym> and it's a fresh install
06:27:31 <kallisti> it should generate a default one if you attempt to do stuff.
06:28:04 <luite> kallisti: i don't have the scripts that generate the haddocks for hackage, and didn't want to mirror them by wgetting
06:28:04 <pielgrzym> tried doing update and this: cabal install git-annex --bindir=$HOME/.haskell_bin
06:28:11 <pielgrzym> still no .config/cabal dir :((
06:28:12 <D-POWER> Hello fellow programmers
06:29:51 <pielgrzym> kallisti, luite sorry :) it's ~/.cabal/config, not ~/.config/cabal
06:29:53 <pielgrzym> dumb me
06:30:35 <kallisti> pielgrzym: no worries. I do more stupid things on a daily basis.
06:30:59 <pielgrzym> :)
06:31:16 <pielgrzym> phew, git-annex on the board, I can get my stuff on new box now :)))) thanks!
06:31:38 <D-POWER> Nothing much is going on around here, where are you Haskell lovers?
06:31:56 <srhb> D-POWER: All around :)
06:32:09 <tdammers> with hackage down, most people are simply idling I guess
06:32:20 <D-POWER> I can't see you :)
06:32:26 <kallisti> in light of this long hackage downage I think cabal could use 2 things:  a "remote-repo-mirror" config option, and official hackage mirrors that come with every default config.
06:32:51 <pielgrzym> D-POWER: Haskell lovers are hacking stuff in their lairs ;) they come out at night ;)
06:33:05 <MostAwesomeDude> It's still night, sort of.
06:33:18 <pielgrzym> MostAwesomeDude: depends on your timezone ;)
06:33:33 <D-POWER> Well its day here in Tunisia
06:34:01 <kallisti> luite: how did you get ahold of a hackage mirror?
06:34:10 <luite> wget :p
06:34:13 <pielgrzym> hehe
06:34:24 <pielgrzym> luite: if this is so easy I'll span my own too
06:34:33 <luite> actually not really, i ahve a script that reads the package list
06:34:34 <pielgrzym> got a spare xen guest dangling in idle
06:34:49 <luite> and it downloads new packages every five minutes or so
06:34:58 <luite> it needs all packages for hdiff
06:35:07 <pielgrzym> luite: cool :) mind sharing? :)
06:35:38 <luite> and i later added some apache rewrite rules to host the files in the hackage layout so that it oculd be used as a mirror
06:36:02 <luite> pielgrzym: https://github.com/luite/hdiff
06:36:30 <pielgrzym> luite: thanks!
06:36:48 <Andrey_> Hello! I'm sorry, can somebody please help me with FFI or linking problem?  http://www.haskell.org/pipermail/haskell-cafe/2012-July/102278.html
06:37:59 <luite> pielgrzym: these scripts check all versions into a git repository for easy diffing
06:38:22 <pielgrzym> luite: fantastic :) I'm a git zealot :)))
06:38:54 <luite> pielgrzym: http://hdiff.luite.com/ has the cgit web interface
06:40:53 <pielgrzym> luite: nice :)
06:41:13 <kallisti> luite: any plans to host docs?
06:42:03 <luite> kallisti: yeah if i have some easy way to get them
06:42:19 <kallisti> why not just generate docs via cabal?
06:42:41 <luite> kallisti: you have to install all packages to do that
06:43:00 <luite> would take a lot of time i guess
06:43:09 <kallisti> ah okay.
06:43:36 <luite> probably not a good idea to do on a production server, but i can use another one and uplaod... but i don't have the scripts
06:43:47 <luite> the regular cabal build stuff also doesn't generate source links
06:44:06 <luite> i don't often use the hackage haddock pages myself though
06:44:32 <luite> since i have a script to build all docs for all locally installed packages with source links, and generate a hoogle index for all of them
06:45:07 <yitz> luite: haskell platform for mac has that built in
06:45:32 <robstewa`> haskell.org is currently down :-( http://hackage.haskell.org/platform/
06:45:34 <luite> yitz: really? even if you cabal install extra packages?
06:45:44 <yitz> luite: maybe help provide that for linux also using your script. or compare with what mzero did.
06:45:48 <aristid> robstewa`: not all of haskell.org, but yes
06:46:01 <aristid> i think this is for about 10-11 hours now?
06:46:03 <yitz> luite: yes extra packages also. it's automatic when you cabal install.
06:46:19 <robstewa`> any download mirrors for the haskell platform ?
06:46:22 <luite> yitz: and it updates a hoogle index?
06:46:29 <yitz> luite: no
06:46:33 <aristid> i remember that shortly before i was going to bed ~11 hours ago, hackage.haskell.org started failing
06:46:34 <yitz> not that i know of
06:46:35 <luite> just source links?
06:46:39 <yitz> yes
06:47:18 <MostAwesomeDude> Hm. Anybody have any clever ideas for producing the sequence [1,2,4,5,8,10,20,40,50,80...] ?
06:47:20 <yitz> luite: if you could upgrade it to be like yours and work also on linux, that would be great.
06:47:29 <yitz> luite: then it comes down to windows.
06:48:07 <luite> yitz: oh mine just unpacks and rebuilds everything again, so it's just a huge mess
06:48:09 <aristid> @oeis 1,2,4,5,8,10,20,40,50,80
06:48:09 <lambdabot>  Sequence not found.
06:48:20 <MostAwesomeDude> aristid: It's a cheap logarithmic progress bar.
06:48:54 <aristid> MostAwesomeDude: i.e. a logistic function?
06:49:17 <MostAwesomeDude> aristid: Well, it never stops growing; the next entry would be 100, then 200, etc.
06:49:29 <aristid> MostAwesomeDude: why not stop growing at 100?
06:49:43 <yitz> > concat $ iterate (map (*10)) [1,2,4,5,6]
06:49:44 <lambdabot>   [1,2,4,5,6,10,20,40,50,60,100,200,400,500,600,1000,2000,4000,5000,6000,1000...
06:49:56 <yitz> MostAwesomeDude: that? ^
06:49:58 <MostAwesomeDude> Imagine that I want to print out a line talking about progress for a CLI app.
06:50:11 <MostAwesomeDude> yitz: Amazing as always, I didn't think to use iterate (again).
06:50:28 <aristid> MostAwesomeDude: but yitz' sequence is different from yours :)
06:50:30 <MostAwesomeDude> aristid: Anyway, this particular app isn't afraid to tell me that there's over half a million things to get done.
06:50:41 <yitz> oops
06:50:48 <yitz> > concat $ iterate (map (*10)) [1,2,4,5,8]
06:50:49 <lambdabot>   [1,2,4,5,8,10,20,40,50,80,100,200,400,500,800,1000,2000,4000,5000,8000,1000...
06:50:49 <MostAwesomeDude> > concat $ iterate (map (10 *)) [1,2,4,5,8]
06:50:51 <lambdabot>   [1,2,4,5,8,10,20,40,50,80,100,200,400,500,800,1000,2000,4000,5000,8000,1000...
06:51:04 <aristid> yitz: ooh, now i actually understand MostAwesomeDude's sequence, lol
06:51:09 <yitz> haha
06:51:28 <yitz> aristid > oeis
06:51:38 <MostAwesomeDude> Yep. The original Python code started with [1,2,4,5,8] and popped the beginning, multiplied by 10, and added it to the end.
06:51:42 <aristid> yitz: yitz > aristid > oeis :P
06:52:52 <younder> Is anyone here for informing Walter Isaacson that writing a book about gauss is just as relevant as Jobbs or Einstein?
06:53:20 <aristid> younder: i think there are books about gauss
06:53:35 <Cale> Surely
06:55:58 <aristid> luite: just if you happen to be bored someday, you could improve the history recreation heuristics ;) http://hdiff.luite.com/cgit/yaml/log/
06:56:18 <younder> Thre are books about .. Water Isaacsons books however are more read
06:56:19 <robstewa`> does anyone have a link to a mirror the haskell-platform-2012 binary download?
06:57:31 <luite> aristid: yeah i know
06:57:35 <yitz> MostAwesomeDude: def seq(): {s = [1,2,4,5,8]; while True: {yield s[0]; s.append(s[0] * 10); s = s[1:] }}
06:57:58 <luite> aristid: i'm not sure what the correct way to handle this is though
06:58:42 <yitz> Cale: since you're already op, would you like to add a link to luite's hackage mirror to the topic?
06:58:51 <aristid> luite: i could imagine just assuming PVP-style versioning
06:58:55 <luite> aristid: it could reorder them in version order, but it wouldn't really be correct though, multiple branches could work
06:58:55 <Cale> okay
06:59:10 <dzhus> When would one want to have strict yet boxed fields in a datatype?
06:59:17 <aristid> luite: well, each version would be a branch i'd think
06:59:47 <byorgey> aristid: re: "isn't the feature rather well-known for being unadvertised" -- well, yes, because the community was quite excited about it, it's hard to keep quiet =)
06:59:51 <aristid> luite: so there'd be a branch for 0.x, a branch for 0.7.x and 0.8.x...
06:59:56 <Cale> (however, I don't know the URL)
06:59:58 <luite> right, but if version 8.0 is released, its branch should be based on the latest 7.x released at that time, right?
07:00:01 <aristid> hi byorgey :)
07:00:12 <byorgey> hi aristid =)
07:00:25 <luite> aristid: sounds good, but at that point i
07:00:39 <luite> 'm probably going to regret doing this with bash scripts :)P
07:00:42 <aristid> luite: i mean it's probably overkill :D
07:00:50 <yitz> Cale: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
07:01:56 --- topic: set to '["hackage is down","hackage mirror - remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues:' by Cale
07:02:14 --- topic: set to '["hackage is down","hackage mirror - remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by Cale
07:02:18 <luite> aristid: you can still compare arbitrary versions by changing the url
07:02:23 <aristid> byorgey: what i'm doing there is quite simple really, i could just as well use * as the kind, and dummy empty types as the inhabitants
07:02:37 <luite> tnx Cale :)
07:02:44 <robstewa`> Cale: no mirror for haskell-platform ?
07:03:23 <byorgey> aristid: sure, and people have done that sort of thing for a long time
07:03:26 <yitz> dzhus: any time you need the contents of the field to be computed strictly and not left as a thunk, whenever the type of the field doesn't happen to be a primitive type that can be store literally without a pointer, like an integer
07:03:43 <Cale> robstewa`: no idea
07:03:53 <byorgey> aristid: at this point, I think you should probably just do that rather than depend on DataKinds
07:04:27 <Andrey_> Direct me, where should I go with my problem? Please tell something. http://www.haskell.org/pipermail/haskell-cafe/2012-July/102278.html
07:04:39 <yitz> robstewa`: see the /topic :)
07:04:50 <yitz> oh platform
07:04:53 <yitz> no
07:04:55 <robstewa`> yes :-)
07:04:59 <robstewa`> ok :-(
07:05:09 <aristid> byorgey: DataKinds just seem the cleaner solution to me, and so far everybody who responded said he wouldn't mind it, but i guess that doesn't mean there's nobody who wouldn't mind
07:05:21 <robstewa`> slightly frustrating. Surprising there's no mirrors set up for it.
07:05:22 <yitz> robstewa`: i uploaded the linux and mac os x tarball for the current haskell platform to my google docs, if you need one of them
07:05:31 <robstewa`> yitz: yes please!
07:05:37 <robstewa`> linux tarball most appreciated
07:05:39 <robstewa`> 32bit?
07:06:01 <yitz> robstewa`: unfortunatey i didn't get around to upgrading my windows box yet so i don't have that one. still looking for someone who does.
07:06:50 <yitz> robstewa`: https://docs.google.com/open?id=0B2xmwgStRt5xR2NyWktIOHgtSU0
07:07:07 <yitz> google *drive
07:07:19 <robstewa`> yitz: thank you very much.
07:07:38 <yitz> robstewa`: i don't think there's any difference between 32 and 64 for linux; it's just the haskell packages.
07:07:49 <byorgey> aristid: sure, it's definitely cleaner
07:07:52 <yitz> robstewa`: for mac os x it includes ghc too, so you have to choose
07:08:00 <aristid> byorgey: maybe i should just create a new branch, try out how it looks with non-DataKind, and compare
07:08:07 <byorgey> aristid: and if you're just doing something that simple depending on 7.4 should be fine (as opposed to waiting for 7.6)
07:08:16 <Cale> robstewa`: What OS are you on?
07:08:23 <robstewa`> Fedora 16.
07:08:48 * robstewa` downloads ghc 7.4
07:08:49 <yitz> robstewa`: you need ghc 7.4.1 already installed. you can get that from the site, that part is still up. or from your distro, if it has it.
07:08:55 <Cale> robstewa`: What I usually just do is download the linux binary of GHC from GHC's own website (which seems up right now?)
07:09:07 <robstewa`> That is indeed what I am doing.
07:09:10 <robstewa`> :-)
07:10:19 <Cale> robstewa`: and then I'll get cabal-install off of hackage, which of course is down at the moment, but: http://hdiff.luite.com/packages/archive/cabal-install/cabal-install-0.14.0.tar.gz
07:10:33 <robstewa`> cheers...
07:11:36 <Cale> oh, haha, of course the bootstrap.sh script in there might choke a bit
07:12:55 <Baughn> What with hackage being down?
07:12:58 <kallisti> we should make a "list of hackage mirrors" on the wiki
07:13:02 * kallisti is going to set up one soon.
07:13:05 <aristid> you could also just use an outdated cabal-install from your linux distribution
07:13:09 <rustycarbon> Nice, robstewa`, thanks for that hackage "mirror" , has what I need right now ;)
07:13:09 <Baughn> We should make hackage multihomed.
07:13:12 <aristid> i think they work just fine with newer ghc's
07:13:29 <EvanR> > let f x = x : unfoldr (\y -> if y == 1 then Nothing else Just (let z = (if even y then y `div` 2 else 3*y+1) in (z,z))) x in f 1000
07:13:30 <lambdabot>   [1000,500,250,125,376,188,94,47,142,71,214,107,322,161,484,242,121,364,182,...
07:13:39 <rustycarbon> +1 to list of mirrors
07:13:42 <Baughn> Why doesn't Hackage run on GCloud or something?
07:13:55 <EvanR> > let f x = x : unfoldr (\y -> if y == 1 then Nothing else Just (let z = (if even y then y `div` 2 else 3*y+1) in (z,z))) x in map (length . f) [1..30]
07:13:58 <lambdabot>   [1,2,8,3,6,9,17,4,20,7,15,10,10,18,18,5,13,21,21,8,8,16,16,11,24,11,112,19,...
07:14:37 <EvanR> @hoogle a -> (a,a)
07:14:37 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
07:14:37 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
07:14:38 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
07:15:02 <aristid> Baughn: i think hackage doesn't require anything beyond a HTTP server, so putting it on S3 or so would actually be possible?
07:15:26 <dada_cetacean> I'm trying to define an alternate list-length function; let newlength [] = 0; let newlength (x:xs) = 1 + newlength xs, but ghci says non-exhaustive pattern
07:15:36 <Baughn> aristid: Or appengine. I would actually prefer appengine; that way, we could be sure it wouldn't go down.
07:15:39 <scopedTV> dada_cetacean: yeah, you shadowed
07:15:47 <rustycarbon> Not for serving the files no, but for generating the doc and package listing.
07:15:48 <Baughn> aristid: Any idea where I can get usage stats, though? ;)
07:15:49 <scopedTV> dada_cetacean: write let { newlength [] = 0; newlength (x:xs) = 1 + newlength xs }
07:15:52 <Nereid> dada_cetacean: don't write let twice
07:15:55 <Nereid> yeah that
07:15:57 <aristid> Baughn: huh? app engine has better uptime than s3?
07:16:07 <dada_cetacean> ahh, thank you
07:16:15 <Baughn> aristid: App engine gives you multihoming for free, S3 doesn't.
07:16:19 <scopedTV> dada_cetacean: what you did is writing newlength [] = 0; and then shadowing that definition by the second one.
07:16:26 <aristid> Baughn: man i'd love to have usage stats of packages, _especially_ which GHC versions people use
07:16:37 <srhb> is runhaskell an interpreter?
07:16:40 <Baughn> aristid: I was thinking more of apache access logs, really.
07:16:40 <aristid> Baughn: you mean multiple regions?
07:16:45 <Baughn> srhb: It pretends to be.
07:16:49 <Baughn> aristid: Yeah
07:16:53 <aristid> Baughn: i think s3 does distribute between data centers, just in the same region
07:17:07 <Baughn> aristid: Which is not good enough. You can set up multiple regions manually, of course.
07:17:16 <rustycarbon> Could we just have something around GitHub? It lets you provide "distributions" doesn't it?
07:17:17 <aristid> Baughn: but usage stats that tell me ghc versions would be EVEN BETTER than access logs :)
07:17:24 <aristid> Baughn: why isn't it good enough?
07:17:30 <Baughn> aristid: THe entire region might go down!
07:17:35 <Baughn> As happened quite recently.
07:17:41 <srhb> Baughn: But really, it compiles and runs?
07:17:43 <LaughingMan> hackage still down?
07:17:49 <Baughn> srhb: Well, to bytecode
07:17:56 <yitz> mirrors of: haskell platform for linux: http://v.gd/0Jtha6 for mac os x: http://v.gd/iz4niD
07:17:56 <Baughn> LaughingMan: Still down.
07:18:01 <aristid> Baughn: it's not supposed to happen :)
07:18:11 <rustycarbon> Aye: http://isitup.org/hackage.haskell.org
07:18:12 <Baughn> aristid: Does anyway.
07:18:24 <srhb> Baughn: Okay.
07:18:28 <Andrey_> Why do I get this result? http://www.haskell.org/pipermail/haskell-cafe/2012-July/102278.html
07:18:52 <aristid> Baughn: well, the architecture would be much simpler with a simple blob storage service than with an application service engine like app engine i think
07:19:08 <aristid> Baughn: but google has a blob storage too, i think they call it google cloud storage
07:19:14 <Baughn> aristid: It's trivial to use appengine as a blob-store, and we'd also have room for adding more interesting stuff
07:19:21 <Baughn> aristid: Like comments, voting and such
07:19:32 * kallisti thinks it would be a better solution to give cabal support for mirrors, and include some official mirrors by default.
07:19:33 <Baughn> aristid: In my copious spare time I'm going to port hackage to appengine.
07:19:44 <kallisti> I believe other package managers do similar things.
07:19:48 <kallisti> (yes cabal is a package manager)
07:19:49 <aristid> Baughn: yay for your copious spare time ;)
07:19:52 <kallisti> *cabal-install
07:19:58 <Baughn> aristid: Check back at christmas.
07:20:25 <aristid> Baughn: i was planning on pinging you every four hours. that okay with you?
07:20:44 <Baughn> aristid: ..I'll admit, part of the reason I'd like to use appengine is that I'm already familiar with its background environment.
07:20:54 <yitz> kallisti: i'm sure your patch would be graciously accepted
07:21:03 <aristid> Baughn: too bad app engine doesn't allow haskell :)
07:21:18 <Baughn> aristid: Mm.
07:21:23 <yitz> aristid: it doesn't
07:21:25 <yitz> ?
07:21:25 <Baughn> But no matter, it's simple enough stuff.
07:21:31 <Baughn> yitz: Doesn't.
07:21:36 <aristid> Baughn: i remember back in the master-slave data store days, there used to be quite a bit of downtime!
07:21:50 <aristid> yitz: python, java, go. the lamest languages you can imagine.
07:21:54 <Baughn> aristid: That was then, this is now. It's been ages since there was any downtime.
07:22:18 <aristid> Baughn: what do you use it for, if i may ask? and which language? :)
07:22:26 <Baughn> aristid: I don't use appengine. :P
07:22:36 <Baughn> aristid: I /do/ use bigtable.
07:22:38 <aristid> Baughn: why are you so familiar with it, then?
07:22:46 <aristid> Baughn: oh you work for the googles
07:22:52 <kallisti> yitz: just seems to make more sense. rather than have the official repo on some cloud thing;  improve the toolset so that it's not reliant on a single repo
07:23:07 <aristid> Baughn: just make "hackage on app engine" a 20% project :P
07:24:09 <Baughn> aristid: I think that'd be hard to justify.
07:24:28 <rustycarbon> HackageDB is down, everyone flocks to #haskell
07:24:38 <aristid> Baughn: too bad :(
07:25:39 <robstewa`> Turning cabal into a fully fledged package management system (not just an installer) `and` moving hackage to Amazon EC2 would be a worthwhile 20% project!
07:25:54 <robstewa`> need to find a passionate haskeller at google to do it.
07:26:16 <aristid> robstewa`: a googler to move it to ec2?
07:26:33 <robstewa`> ah, quite. They're the ones with 20%.
07:26:48 <robstewa`> to app engine, then.
07:27:04 <yitz> aristid: just noticed tibbe - who works at google - hint that it does in an email to the libraries list
07:27:21 <aristid> yitz: hint that it does what?
07:27:32 <yitz> that google app engine supports haskell
07:27:43 <aristid> yitz: but not publicly yet?
07:27:45 <yitz> perhaps
07:27:48 <aristid> man that'd be cool shit
07:29:23 <aristid> yitz: is the libraries@ list public? can't find it on http://www.haskell.org/haskellwiki/Mailing_lists
07:29:35 <kolmodin_> I guess I'm not the first to report that hackage is down. is it planned?
07:29:53 <yitz> kallisti: i agree. there are many ambitious half-baked ideas for moving hackage to the "cloud", whichever particular meaning of that is being discussed at the time. but just simple robust support for mirrors would be an easy and important first step.
07:29:54 <aristid> kolmodin_: planned downtime of 11 hours? i hope not!
07:30:22 --- mode: ChanServ set +o mauke
07:30:23 --- topic: set to '["hackage is down. mirror: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive ","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by mauke
07:30:30 <kolmodin_> aristid: ah, I've only missed it like... 8 hours
07:30:32 <kolmodin_> :)
07:30:33 <rustycarbon> Wait, it hasn't been down for 11 hours? Has it?
07:30:38 <yitz> kolmodin_: when it goes down at the beginning of nighttime on the us west coast, or worse yet, at the beginning of a weekend, there isn't much that can be done for a while.
07:30:47 <aristid> rustycarbon: it has been
07:31:11 <rustycarbon> Ah... well I'll get back to work instead of hoping it might pop back soon!
07:31:16 <kolmodin_> yitz: surely not all admins are at the us west coast?
07:31:23 <yitz> mauke: what did you just change?
07:31:27 <rustycarbon> And also stop being lazy and just use the mirror.
07:31:53 <yitz> kolmodin_: it's on a server at galois. they have an IT staff that works during the day.
07:31:54 <kolmodin_> rustycarbon: mirror?
07:32:10 <kolmodin_> yitz: ahh, right. so a few more hours then
07:32:14 <aristid> yitz: nevermind, i was blind for not finding the "more lists" link
07:32:23 --- mode: mauke set -o mauke
07:32:26 <mauke> yitz: shortened it a bit, added a space after the url
07:32:28 <kolmodin_> yitz: the benefit is that it was not down when haskell.org was down last week :)
07:32:28 <rustycarbon> kolmodin_ see the topic, here: http://hdiff.luite.com/packages/archive/
07:32:43 <Baughn> That's not signed though, is it?
07:32:52 <yitz> mauke: ah ok. i *thought* it looked the same. :)
07:33:21 <rustycarbon> Hmmm... this *is* a perfect excuse not to do work.
07:33:48 <kallisti> yitz: maybe when I have some time I'll look into what would be needed to add mirrors.
07:34:00 * kallisti wonders what kind of traffic a hackage mirror would get.
07:34:12 <Saizan> is it still on a server at galois? i thought they had their own virtual machine elsewhere now
07:34:13 <kallisti> not sure if my dedicated server could handle being a mirror.
07:34:32 <yitz> mauke: if you want you can add the shortened links i mentioned above to mirrors of haskell platform for linux and mac in my google drive.
07:34:49 <yitz> kallisti: depends on whether or not hackage is down.
07:35:41 <Andrey_> If you load this function in ghci, it behaves absolutely the same. How can I create OpenGL context in ghci? http://www.haskell.org/pipermail/haskell-cafe/2012-July/102278.html
07:36:39 <aristid> yitz: what's the title and date of the mail in which tibbe mentioned app engine (internally?) supporting haskell? i want to read it, but can't find it :)
07:43:55 <srhb> What does WHNF mean in respect to IO? I'm confused with predicting when IO actions actually get evaluated, for instance, if they are inside lists. Is it as soon as the IO "constructor" (?) is encountered?
07:44:53 <Botje> yes
07:45:01 <srhb> Hurray, intuition! Thanks.
07:45:17 <Baughn> ..
07:45:20 <Baughn> No!
07:45:21 <Baughn> Never.
07:45:24 <srhb> :(
07:45:26 <trem> really?
07:45:45 <fmapE> srhb: IO actions get evaluated if they are bound as part of the main :: IO value for your program.
07:45:56 <fmapE> so if you have IO [IO ()]
07:46:03 <fmapE> the action producing the list of actions gets evaluated
07:46:04 <trem> using, a mapM to create a [IO ()] felt different than using a mapM_
07:46:05 <fmapE> but the actions dont
07:46:15 <ericmj> hackage is up
07:46:19 <Zugzwang> yup
07:46:22 <EvanR> :t sequence
07:46:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:46:24 <trem> ericmj, hooray! :-)
07:46:27 <fmapE> ericmj YAY
07:46:29 <barrucadu> Everyone pile into the servers and overpower it again!
07:46:35 <barrucadu> *onto
07:46:46 <dada_cetacean> what's the command when writing a source file to designate a type signature for a function?
07:46:54 <byorgey> no, repeat after me: there is a huge difference between IO actions being *evaluated* and being *executed*
07:47:09 <trem> there is a huge difference between IO actions being *evaluated* and being *executed*
07:47:11 <fmapE> byorgey: oops yup
07:47:14 <byorgey> IO actions are evaluated in the same way any other values are evaluated.
07:47:16 <mizu_no_oto> I currently have foo :: [State[Bar, Baz]] -> State[Bar, Baz] ; foo xs = mconcat $ traverse (<* modState) xs.  However, I don't want nested calls to foo (e.g. foo [foo lst, foo lst]) to have the doubled calls to (<* modState) at the end.  What should I do?
07:47:16 <barrucadu> dada_cetacean: You mean "function_name :: type" ?
07:47:21 <srhb> Sorry, I did mean executed.
07:47:25 <srhb> Not evaluated.
07:47:28 <EvanR> there is a huge difference between IO actions being *evaluated* and being *executed*
07:47:33 <dada_cetacean> barrucadu: that's the one, thanks
07:47:43 <srhb> So, when do they get executed?
07:47:58 <EvanR> if they are part of main
07:47:59 <byorgey> but there is no way to "pattern match" on an IO action, so in fact they are not evaluated until they are executed.
07:48:04 <EvanR> via >>=
07:49:00 <srhb> OK, I guess the problem is that my question is nonsensical because [IO Something] is not an IO action.
07:49:00 <srhb>  
07:49:21 <EvanR> yeah but sequence :: [m a] -> m [a] could make it one
07:49:25 <srhb> Sure.
07:49:45 <srhb> but then the answer is self evident, since it is an IO action. :-)
07:49:55 <EvanR> \o/
07:50:13 <EvanR> you can also put IO actions in other structures
07:50:22 <EvanR> MVar, Map, etc
07:50:31 <srhb> Sure. :)
07:50:41 <tromp> @let pents=zip(cycle [1,1,-1,-1])$scanl(+)1$do k<-[1..];[k,2*k+1]
07:50:43 <lambdabot>  Defined.
07:51:06 <MostAwesomeDude> I read that as "pants". Probably because of the "zip".
07:51:19 <EvanR> what do i give my sister for unzipping
07:51:58 <byorgey> mizu_no_oto: I suppose you should use two different functions, foo and something else without the (<* modState)
07:53:35 * byorgey waits expectantly for tromp to define a sweet one-liner for the partition numbers
07:53:53 <tromp> i took it private with lambdabot:(
07:53:59 <byorgey> oh =)
07:54:03 <tromp> but since you want it...
07:54:05 <cads> oh neat
07:54:15 <tromp> @let pn=Memo.integral q where q 0=1;q n=sum.map(\(s,k)->s*pn(n-k))$takeWhile((<=n).snd)pents
07:54:16 <lambdabot>  <local>:10:0:
07:54:16 <lambdabot>      Multiple declarations of `L.pn'
07:54:16 <lambdabot>      Declared at: <local>...
07:54:17 <cads> this commandline twitter client is built in haskell; https://github.com/jgoerzen/twidge
07:54:28 <byorgey> nice, memoized and everything =D
07:55:25 <byorgey> tromp++
07:55:26 <kallisti> > replicate 4 >=> iterate (+1) >>> take 5 >=> replicate 2 >=> iterate (+1) >>> take 3 $ 5
07:55:28 <lambdabot>   [5,6,7,5,6,7,6,7,8,6,7,8,7,8,9,7,8,9,8,9,10,8,9,10,9,10,11,9,10,11,5,6,7,5,...
07:57:04 <byorgey> cads: I should think so
07:57:42 <tromp> tryhaskell.org doesn't let me paste. others have same problem?
07:57:48 <byorgey> cads: jgoerzen = CosmicRay = author of RWH =)
07:58:02 <cads> no kidding!
07:58:22 * cads has that book on his shelf
07:59:50 <yitz> people, please take it easy with hackage for a bit. it's busy re-raiding its file system and other intensive damage recovery tasks. thanks.
08:00:22 <yitz> someone/something has been hitting hackage hard lately. we're not sure what.
08:00:26 * byorgey re-raids his fridge
08:00:32 <EvanR> lol
08:00:48 <cads> I'm sorry, yitz!
08:00:55 * cads feels guilty now
08:01:40 <Saizan> cads: you were crawling hackage?
08:02:24 <cads> naw
08:03:01 <teneen> what's the difference, in representation,  between strict boxed types and their lazy counterparts?
08:03:26 <teneen> data Pair = P Int Int
08:03:36 <teneen> and data Pair = P !Int !Int
08:03:39 <byorgey> in representation? none
08:03:45 <byorgey> it's a difference of semantics
08:04:26 <cads> byorgey, can diagrams be used to design GUIs?
08:04:32 <teneen> byorgey, do the lazy ones contain pointers to pointers (thunks) while the strict ones contain pointers to values?
08:05:05 <byorgey> cads: I mean, I suppose it *could*, but it's not really meant for that
08:05:25 <siracusa> yitz: What happened to hackage then?
08:05:57 <teneen> byorgey, I'm talking about the Int fields
08:06:01 <byorgey> teneen: the lazy ones may contain pointers to either thunks or values.  the strict ones are always pointers to values.
08:06:05 <cads> byorgey, I'm more tempted to use it to make diagrams for latex
08:06:35 <teneen> byorgey, ok I see. Isn't this a difference in representation?
08:06:38 <byorgey> cads: yep, that's one of the things I use it for
08:07:14 <Saizan> teneen: if you add {-# UNBOX #-} in there you'd have the value themselves
08:07:25 <byorgey> teneen: not really.  it's not a different representation at all.  It's just that the way strict fields are implemented, they are always evalulated immediately so they happen to never point to thunks.
08:07:41 <cads> byorgey, but it produces beautiful graphics - if they were interactive it would be very tempting for a graph editor
08:07:56 <byorgey> cads: yeah, interactivity is one of my long-term goals
08:08:04 <byorgey> cads: I want to hook it up with an FRP library or something like that
08:08:19 <yitz> siracusa: not sure. galois IT found it unresponsive when they came in today and needed to reboot.
08:08:46 <byorgey> cads: ClaudiusMaximus has already been using it to make a graph editor of sorts.
08:09:02 <byorgey> for simple stuff you can just regenerate a diagram every frame =)
08:09:17 <yitz> one hyposthesis they have is that it has to do with too many ghc build processes being automatically kicked off at once somehow, or something like that.
08:09:34 <byorgey> cads: see also mgsloan's gtk-toy and gtk-toy-diagrams packages
08:10:28 <teneen> byorgey: Are the thunks, pointed to by the lazy version, indirections?
08:11:42 <byorgey> teneen: we are now getting beyond the limits of my actual knowledge
08:12:06 * siracusa checks the logs for the last uploaded package reported by hackagebot
08:12:14 <teneen> byorgey: ok nevermind, thanks! :)
08:15:12 <yitz> teneen: i don't know if it's the actual representation (probably not), but you can think of every haskell value coming with an extra bit that says whether or not it has been evaluated yet. if the runtime needs to do something where it actually needs to know the value, e.g., write it to disk, it checks that bit. if not evaluated yet, it evaluates the expression that actually produces this value. which, in turn, may force other values to be evaluated.
08:15:47 <yitz> teneen: but that strategy is not built into haskell; it's just the way ghc does things.
08:16:52 <teneen> yitz, this makes sense. Thanks a lot.
08:17:13 <trem> yitz, i thought that this stategy is actually part of haskell's lazy evaluation, isn't it?
08:17:27 <yitz> teneen: and in fact, ghc itself doesn't always follow that strategy. it compiles in the result of more sophisticated analysis that may allow it to do things faster, e.g., evaluate things immediately that it knows it will need.
08:17:56 <tdammers> yitz: it has to adhere to the language spec though
08:18:02 <quicksilver> trem: technically haskell doesn't mandate lazy evaluation
08:18:18 <Baughn> trem: I don't think the haskell spec even guarantees that values, once evaluated, will not be evaluated again
08:18:22 <yitz> trem, tdammers: the language report doesn't require laziness.
08:18:40 <quicksilver> it mandates "non-strict" which means that infinite loops won't take infinite time if not required
08:18:45 <quicksilver> which is quite a lot weaker
08:19:04 <tdammers> true, true
08:19:08 <quicksilver> it permits implementations to do some speculative evaluation as long as they don't spend forever on it.
08:19:28 <quicksilver> the language report does imply laziness in a few places, though
08:19:36 <quicksilver> and the language report is rather unclear about lazy IO
08:19:38 <trem> yitz, quicksilver: oh, didn't know that. always thought haskell = lazy
08:19:40 <tdammers> it's usually transparent though, with everything being pure
08:19:44 <quicksilver> so it's not a paragan of clear explanation.
08:20:10 <tdammers> lazy IO... yeah... that alone isn't even completely lazy
08:20:19 <quicksilver> lazy IO is a poor name
08:20:26 <teneen> Does lazy-evaluation correspond to call-by-name and non-strict corresponds to call-by-need?
08:20:33 <quicksilver> since it's not at all the same as "pure laziness"
08:20:45 <yitz> trem: the point is that semantic coherence makes laziness possible. so good compilers use laziness when they think that is an advantage. ghc does use laziness heavily.
08:20:46 * hackagebot classy-prelude 0.1.0.0 - A typeclass-based Prelude. (MichaelSnoyman)
08:20:47 * hackagebot network-transport-tcp 0.2.0.1 - TCP instantation of Network.Transport (EdskoDeVries)
08:20:49 * hackagebot process-conduit 0.5.0.2 - Conduits for processes (HideyukiTanaka)
08:20:51 * hackagebot bindings-librrd 0.2.0.1 - Low level bindings to RRDtool (MasatakeDaimon)
08:20:54 * hackagebot classy-prelude-conduit 0.1.0.0 - conduit instances for classy-prelude (MichaelSnoyman)
08:21:08 <Taneb> HACKAGE?
08:21:14 <Taneb> ALIVE
08:21:39 <Taneb> Now I can complain about how comonad has changed
08:22:08 <yitz> quicksilver: can you pls take out the hackage down notice from /topic?
08:23:08 --- mode: ChanServ set +o quicksilver
08:23:39 <parcs`> darcs.haskell.org seems to be down, still
08:23:56 <byorgey> parcs`: Works For Me (tm)
08:24:16 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r","Paste code/errors: http://hpaste.org/new/haskell","GHC 7.4.2: http://is.gd/EllZnn","Haskell News: http://reddit.com/r/haskell","The Haskell programming language http://haskell.org","Logs: http://bit.ly/5mwtRQ"]' by quicksilver
08:24:16 <byorgey> well, at least the web server does
08:24:23 <byorgey> I can't ping it
08:24:32 <yitz> parcs`: that's an alias for the same physical machine that hackage is on.
08:24:53 <yitz> parcs`: it might still be slow though as it churns through rebuilding things
08:25:57 <parcs`> why does the web server work yet the machine can't be pinged?
08:26:08 <flux> magic of firewalls?
08:26:20 <tdammers> ping disabled?
08:26:29 <Taneb> Caching?
08:26:34 <bitonic> solar flares?
08:26:39 <trem> the webserver is a great piece of software while the IP stack sucks?
08:26:40 <yitz> quicksilver: thanks!
08:26:41 <tdammers> magoc?
08:26:43 <trem> wait...
08:26:52 <tdammers> s/o/i/
08:28:05 <quicksilver> I would imagine ICMP is disabled
08:28:13 <quicksilver> on the machine or some router in between
08:28:16 <quicksilver> it's fairly common
08:28:29 <aristid> byorgey: i've now tested it, works just fine _without_ DataKinds, but with a yucky kind of *
08:28:39 <byorgey> yep
08:30:28 <byorgey> hackage is still hosted at galois.
08:30:48 <byorgey> oops, I was responding to someone but didn't realize my window was scrolled way back
08:31:56 <mauke> I fixed that problem for me by making the "you're scrolled up" marker in the statusbar bright red
08:33:21 <aristid> mauke: for now. maybe you'll get accustomed to the bright red, and ignore it :D
08:33:39 <mauke> unlikely. it rarely appears
08:36:41 <hpaste> nart pasted “map json encoding” at http://hpaste.org/71338
08:36:57 <nart> what does this error mean ? http://hpaste.org/71338
08:37:13 <mauke> what's encodeJSON?
08:37:17 <yitz> aristid: i think i'll wire mine up to pass a small electric current through my foot
08:37:28 <nart> mauke: http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/Text-JSON-Generic.html#t:Data
08:38:55 <aristid> yitz: sounds like a pragmatic solution
08:42:03 <astry> hi
08:42:10 <Taneb> Hey
08:42:20 <astry> has anyone here used datomic / is it usable with haskell?
08:42:40 <astry> @faq can Haskell integrate with Datomic?
08:42:40 <lambdabot> The answer is: Yes! Haskell can do that.
08:43:06 <mauke> nart: the problem here is that Map doesn't expose its internal structure
08:43:20 <mauke> nart: and if it did, you probably wouldn't want to use it anyway
08:43:34 <Taneb> @faq Can anyone save my baby!?
08:43:34 <lambdabot> The answer is: Yes! Haskell can do that.
08:43:39 <Taneb> O kwl
08:44:58 <srhb> I have a program generating and outputting a very, very large string. If I let it print to console, the memory footprint is very slow. If I let it print to a file, or /dev/null, the memory footprint is very large, but it is very fast. Is this a buffering thing? (I'm just testing various things and trying to understand why it behaves differently in different cases)
08:45:15 <ion> @faq Can Haskell kill my baby?
08:45:16 <lambdabot> The answer is: Yes! Haskell can do that.
08:45:38 <ion> Define very large.
08:45:50 <srhb> Let's say a gigabyte.
08:46:02 <mauke> it's probably both buffering and time spent by the terminal emulator drawing to the screen
08:46:16 <srhb> Oh, yeah, that must be expensive.
08:46:51 <Saizan> try with -M
08:47:25 <srhb> I was contemplating whether putStr (very large string with newlines) or map putStrLn (list of strings) would be better.
08:47:46 <scopedTV> ByteString?
08:47:52 <scopedTV> I'd guess the latter is faster. Not sure.
08:48:36 <mauke> I'd think the former
08:49:10 <scopedTV> it might also depend on the length of your strings
08:49:12 <gwern> @quote
08:49:13 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
08:49:29 <mauke> @unquote
08:49:30 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
08:52:23 <parcs`> @src putStr
08:52:23 <lambdabot> putStr s  = hPutStr stdout s
08:55:00 <Qrt> @src getLine
08:55:01 <lambdabot> getLine = hGetLine stdin
08:55:46 * hackagebot binary 0.5.1.1 - Binary serialisation for Haskell values using lazy ByteStrings (LennartKolmodin)
08:57:52 <stwien> I am trying to install darcs but I get an error regarding curses.h . However I have installed "sudo apt-get install zlib1g-dev libncurses5-dev" in ubuntu.
08:57:57 <stwien> any pointers?
08:58:22 <Qrt> if there is text on stdin then getLine will take it right? i dont have to input it?
08:58:39 <Qrt> also how do i pass text to stdin when starting the program?
08:58:49 <scopedTV> echo "37" | ./program
08:58:53 <Qrt> like: /haskellprogram.exe text
08:59:00 <Qrt> windows?
08:59:11 <scopedTV> no idea
08:59:23 <jfredett> I would look up "Piping text into a windows program" on the googlemachine
08:59:30 <jfredett> that's the term for what scopedTV did
08:59:39 <scopedTV> you can also just enter it on the console, press CTRL+Z to indicate you're done iirc
09:01:01 <bsrkaditya> Hi,
09:01:03 <bsrkaditya>  I have two functions one which return a bool(say f1 :: Bool), and another function which returns a bool in io (say f2 :: IO Bool).
09:01:05 <bsrkaditya>  I want to use && to combine them.
09:01:07 <bsrkaditya>  But, I want f2 to be computed only if f1 is True.
09:01:09 <bsrkaditya>  Hence I cannot use liftM2 (&&) (return f1) f2.
09:01:11 <bsrkaditya>  What should I do?
09:04:43 <trem> bsrkaditya, something like "if f1 then return f1 else f2 :: IO Bool" shoud work (albeit missing the && syntax)
09:05:11 <bsrkaditya> Yes. :-)
09:05:20 <bsrkaditya> I will use that.
09:06:18 <srhb> Why doesn't && short-circuit in this case?
09:06:24 <mauke> it does
09:06:32 <srhb> What's going on then?
09:06:34 <bsrkaditya> It does not.
09:06:40 <mauke> it's short-circuiting constants
09:06:42 <mauke> which is pointless
09:07:11 <dada_cetacean> what's the difference between => and ->?
09:07:12 <srhb> > return . (&&) True =<< undefined :: IO Bool
09:07:13 <however> i think it's short-circuiting on the level of lazyness. the io action is evaluated however
09:07:15 <lambdabot>   <IO Bool>
09:07:15 <mauke> what we want to avoid is the IO effects of f2, not the computation of the Bool result
09:07:19 <srhb> > return . (&&) True =<< undefined :: Maybe Bool
09:07:22 <lambdabot>   *Exception: Prelude.undefined
09:07:36 <srhb> > return . (&&) False =<< undefined :: Maybe Bool
09:07:39 <Nereid> dada_cetacean: a lot
09:07:40 <lambdabot>   *Exception: Prelude.undefined
09:07:49 <Nereid> dada_cetacean: something like the difference between a keyboard and a potato
09:08:05 <srhb> I would expect the last one to be Just False, not undefined
09:08:23 <trem> it sould be "if f1 then f2 else return False" really. or some weird syntax with all your "><=$" and whatnot. :-)
09:08:58 <StaticShock> can someone help me understand why this generates an error?
09:08:59 <StaticShock> https://gist.github.com/3099074
09:09:12 <Nereid> what error? (and use hpaste next time)
09:09:22 <StaticShock> ok
09:09:28 <Nereid> also
09:09:35 <Taneb> StaticShock, you want instance (Show a, Show b) => Show SomeType a b, I think
09:09:37 <quicksilver> StaticShock: dtEntryType and dtLengthType do not appear to be defined
09:09:39 <Nereid> ^
09:09:43 <Nereid> oh, that too
09:09:48 <Nereid> so, a lot of things.
09:09:58 <quicksilver> but if they were, in face, supposed to be the names in the pattern match
09:10:13 <StaticShock> quicksilver: my bad, crappy refactoring
09:10:19 <quicksilver> then the answer would be "the compiler don't knwo there are Show instances it can use - tell it, with a context like Taneb says"
09:10:23 <Nereid> also that ; is unnecessary
09:10:50 <StaticShock> Nereid: i was pasting the whole thing as a block into GHCi, and the semicolon seemed to help there
09:11:09 <StaticShock> Taneb: thanks, trying
09:11:23 <Nereid> StaticShock: it's easier if you write it into a .hs file and :load it in ghci
09:11:39 <StaticShock> Nereid: i'm used to repl testing
09:11:46 <StaticShock> Nereid: running files is more cumbersome
09:11:53 <Nereid> it's easier to edit
09:12:51 <StaticShock> fair
09:13:40 <quicksilver> :r is not very tedious
09:13:42 <StaticShock> okay, i took Taneb's advice and now the declaration survives, but this still throws an error in GHCi: SomeType "a" "b"
09:13:56 <StaticShock> quicksilver: what's :r ?
09:14:02 <quicksilver> reload the last loaded file
09:14:29 <quicksilver> I do lots of testing in the REPL admittedly - but usually based on a loaded file (which contains the data types and basic functions etc)
09:14:39 <StaticShock> makes sense
09:15:08 <quicksilver> you description of that last error message isn't good enough for me to help you :-) Pls paste the exact error. and possibly the source.
09:15:22 <Nereid> onto hpaste
09:15:50 <hpaste> StaticShock pasted “sometype.hs” at http://hpaste.org/71339
09:16:42 <Nereid> do instance declarations even work in ghci?
09:17:06 <mauke> preflex: 8ball do instance declarations even work in ghci?
09:17:06 <preflex>  you may rely on it
09:17:12 <StaticShock> heh
09:17:42 <geekosaur> that is fairly recently added functionality and might well have bugs
09:17:47 <StaticShock> Nereid: yeah, I've had luck before with a simpler one
09:17:59 <Nereid> I guess they do
09:18:12 <StaticShock> e.g., for an unparameterized type
09:18:35 <kallisti> join traceShow:  currently Haskell's best debugging tool
09:19:00 <srhb> > (return undefined :: IO Bool) >>= return . (&&) False
09:19:02 <lambdabot>   <IO Bool>
09:19:05 <srhb> Hrmf.
09:19:30 <kallisti> srhb: should yield a runtime exception, I think?
09:19:35 <however> dada_cetacean: to the right of =>, there's a normal signature that describes the argument(s) and return type. to the left of =>, there's constraints, most often something like "b needs to be of typeclass Integral" -- e.g. "round :: Integral b => a -> b". so the "a -> b" is the basic type of the function round, and "Integral b" is an additional restriction. (and sorry for nereid's unhelpful answer)
09:19:45 <StaticShock> quicksilver: I've provided a paste with specific error messages this time
09:19:47 <kallisti> srhb: well, maybe return isn't strict like other IO actions.
09:19:52 <srhb> kallisti: It doesn't. Can;t figure it out. :P
09:19:59 <Taneb> StaticShock, works for me?
09:20:01 <srhb> Ah yes, that might be it.
09:20:07 <StaticShock> hmm
09:20:13 <kallisti> srhb: you mean in ghci or lambdabot?
09:20:17 <srhb> ghci
09:20:26 <srhb> undefined :: IO Bool does, however.
09:20:37 <kallisti> I guess return isn't strict, whereas most other IO actions are (because they pull data from outside sources)
09:20:40 <dada_cetacean> however: thanks!
09:20:43 <srhb> So I should think it short circuits just fine with a "real" IO Bool? I am not sure.
09:20:46 <StaticShock> Taneb: am i missing an import?
09:20:50 <Taneb> No
09:20:55 <Taneb> Um...
09:21:01 <Taneb> I don't know what's wrong?
09:21:04 <however> dada_cetacean: you're welcome
09:21:07 <kallisti> srhb: what's the desired behavior?
09:21:12 <StaticShock> I'm on windows, running in GHCi 7.4.1
09:21:18 <StaticShock> but that's hopefully not relevant
09:21:54 <hpaste> Taneb pasted “sometype.hs what I have, StaticShock” at http://hpaste.org/71341
09:22:04 <srhb> kallisti: I was just pondering whether it would be possible to short-circuit and avoid evaluating an IO Bool, a different asker was searching for that.
09:22:05 <Taneb> Damn, didn't copy properly
09:22:27 <kallisti> srhb: yes it's possible
09:22:31 <srhb> It seems to work just fine, yeah
09:22:35 <srhb> So I'm curious what the problem was
09:22:39 <quicksilver> StaticShock: not sure. I'd guess it something to do with ghci, either multiline decls or instance decls or redefining functions with the same type
09:22:48 <quicksilver> I'm not sure.
09:22:53 <kallisti> srhb: if you have:  bool f t p | p = t | otherwise = f
09:22:54 <quicksilver> btu what you wrote looks fine.
09:22:57 --- mode: quicksilver set -o quicksilver
09:23:17 <kallisti> srhb: then you can write ifM p t f = p >>= bool f t
09:23:18 <StaticShock> alright. thanks.
09:23:44 <kallisti> srhb: which then allows you write  a <||> b = ifM a (return True) b
09:24:06 <kallisti> srhb: and a <&&> b = ifM a b (return False)
09:24:14 <kallisti> and now you have short-circuiting conditionals in IO
09:24:18 <kallisti> or any monad.
09:24:19 <srhb> Right.
09:25:48 * hackagebot distributed-process 0.2.1 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
09:26:20 <kallisti> looks like hackage is back.
09:27:10 <StaticShock> :load is also not working well for me
09:27:15 <gwern> @quote hackage
09:27:16 <lambdabot> dons says: [on whether a library is wanted] *yes* put it on Hackage!
09:27:50 <StaticShock> Couldn't read "\"C:\\Users\\ss\\Desktop\\data.hs\""as String
09:31:15 <quicksilver> StaticShock: what did you type? did you quote it? (you don't need to)
09:31:20 <quicksilver> just :load data.hs
09:31:24 <quicksilver> if you're in the right dir.
09:31:44 <StaticShock> what if i'm not in the right dir? how do i change dir?
09:32:08 <StaticShock> i quoted it because my original path had spaces in it
09:33:28 <Nereid> change to the right dir and then run ghci
09:33:29 <quicksilver> StaticShock: :cd
09:33:33 <Nereid> oh, or that
09:33:34 <quicksilver> or that :)
09:33:47 <StaticShock> heh, :cd also seems to fail
09:33:50 <sm> stwien: did you get it building ? if not try #darcs
09:33:52 <quicksilver> it's a weird error message that
09:33:55 <StaticShock> because windows paths are "invalid paths", maybe
09:33:56 <srhb> Everything appears to fail with spaces
09:34:09 <StaticShock> *** Exception: SetCurrentDirectory "\"H:\\Dropbox\\Settings\"": invalid argument (The filename, directory name, or volume label syntax is incorrect.)
09:34:15 <srhb> Ah wait, no.
09:34:18 <Nereid> don't quote it then
09:34:19 <srhb> in "" but no \
09:34:22 <srhb> That works
09:34:25 <StaticShock> ah, no quotes
09:34:27 <StaticShock> yes, that worked
09:34:29 <StaticShock> my bad
09:35:14 <quicksilver> StaticShock: given that the GHC is developed by windows users I'd be quite surprised if it didn't like windows paths
09:35:18 <quicksilver> although I've not used windows myself
09:35:36 <StaticShock> good to know
09:35:55 <StaticShock> i'm used to most open source tools investing no time in windows-friendliness
09:35:57 <StaticShock> so i just assumed
09:36:10 <StaticShock> yeah, same code seems to work when loaded from the file
09:36:19 <StaticShock> but not when pasted directly into GHCi
09:36:23 <Taneb> A good proportion of GHC developers seem to be at Microsoft Research
09:36:42 <StaticShock> oh, yeah, i used to know this fact
09:36:56 <Taneb> Which often disturbs me
09:37:31 <StaticShock> well, it must be very nice to have funding
09:38:01 <StaticShock> they probably don't have as much grant-writing pressure as in academia
09:38:38 <triyo> I'm giving HaskellCloud (Remote) library a try. However, I can't seem to get multiple nodes to run on a single physical machine. I've assigned unique ports for each node via `cfgListenPort ` but still get `SYS Process got unhandled exception bind: resource busy (Address already in use)`.
09:38:44 <monochrom> ghci deviates from code in file. deliberately. the purpose is to make life easier. the result is: any deviation makes life harder, at least for those of us cherishing long-term consistency over short-term convenience
09:38:47 <triyo> Anyone played with this?
09:39:19 <monochrom> but yes ghci's deviation does provide some short-term convenience
09:40:05 <StaticShock> monochrom: to make life easier? what's a concrete example of this?
09:40:56 <monochrom> the user guide has an example in "type defaulting in ghci"
09:41:00 <StaticShock> i've generally been satisfied with the way ruby and python handle repl input
09:41:17 <monochrom> there is also an undocumented deviation concerning threads
09:41:26 <StaticShock> it seems possible to repl input in ghci the same way
09:42:11 <StaticShock> funny enough, haskell.org documentation is *blocked* for me at work
09:42:21 <monochrom> python and ruby do not have to worry about types. that makes implementing repl trivial
09:42:33 <StaticShock> makes sense
09:42:36 <however> triyo: try to make it more verbose, maybe it'll show you what resource exactly it's trying to access. or try running one node, checking with netstat, then quit, run the other node, and check netstat again. you should be able to find out if both are listening on the ports that you intended
09:42:58 <monochrom> sml and ocaml do have to worry about types, but their types are still easier than haskell types for repl
09:43:10 <StaticShock> yeah, you're right, if you're doing type inference i guess you need to see the whole file
09:43:42 <monochrom> actually types is not the only obstacle
09:44:30 <trem> "cabal install time" gives "user error (The package requires Cabal library version -any && >=1.6 but no suitable version is installed.)"
09:44:32 <monochrom> python, ruby, sml, ocaml deliberately forbid forward references. haskell deliberately allows forward references. how are you going to repl the future?
09:44:43 <trem> and "cabal install cabal" gives even worse. what do?
09:45:00 <trem> (on pretty much vanilla fedora 17)
09:45:34 <monochrom> at the end, the product of haskell types and forward references is greater than the sum total
09:45:47 <triyo> however: Thanks. I see that there is also a registry server that binds to the address with its own port. It might be that. But I'll get some verbose output going if I can.
09:48:07 <however> trem: i bet that the time package comes with ghc and it already is installed (maybe in a slightly older version, but don't worry about that). same for cabal
09:48:51 <aristid> monochrom: does running ghci with -XNoExtendedDefaultRules work?
09:50:19 <however> (trem: but you're right, it is confusing that cabal seems to be installed and running, but complaining about a missing Cabal library)
09:51:36 <trem> however: cabal dependecy resolution is nothing easy to get a grasp of...
09:53:30 <trem> my .cabal states i need mwc-random >= 0.8 -- upon install cabal complains that mwc-random-0.12 cannot be installed because it depends on time which cannot be installed. and it's the same for several other packages, they all somehow depend on time which refuses to install. damn.
09:53:39 <however> trem: try "ghc-pkg list". on my system there's the basic built-in stuff in /usr/lib/ghc and the stuff i've installed in /home/me/.cabal
09:54:29 <however> trem: for errors like the mwc thing, run it with verbose. it will tell you exactly why it's not considering this or that version
09:55:00 <however> (if you really get stuck, run it with verbose, put its messages on hpaste, and ask in here)
09:56:20 <trem> however: for mwc-random I get http://hpaste.org/71344
09:57:10 <trem> however, and then for cabal http://hpaste.org/71345
09:58:09 <however> trem: find out which version of Cabal you have. use "ghc-pkg list"
09:58:12 <trem> however: the package list looks pretty clean: http://hpaste.org/71346
09:58:41 <however> trem: yeah ... but Cabal isn't in there. i'm not sure what that means
09:58:41 <trem> however, i don't see any cabal in the pkg list. hm
09:59:24 <trem> haskell on fedora is not that enjoyable so far. maybe i should revert for gentoo where i knew how it works...
10:02:13 <Taneb> You know what would be a stupid idea? Allowing values at the type level
10:02:24 <Taneb> Like foo :: SomeType True Int
10:03:21 <Nereid> it's not stupid
10:03:31 <Nereid> some languages do have dependent types
10:03:37 <Taneb> Okay
10:03:41 <Nereid> although those are strict languages...
10:03:56 <Taneb> There'd need to be a notation for it
10:04:04 <Nereid> you just gave it
10:04:05 <Taneb> I'm gonna say angle-brackets?
10:04:20 <Taneb> Nereid, that could be ambiguous of I also said data True
10:04:33 <Nereid> then saying that becomes illegal
10:04:36 <Taneb> so foo :: SomeType <True> Int
10:04:53 <Nereid> no
10:05:00 <however> trem: i have no idea, sorry. i can only guess that the fedora people weirdly split things up, and you installed ghc itself and base, but not the basic packages like "time". maybe poke around if there's more fedora haskell packages that look like you might need them. or go with the haskell platform ...
10:05:09 <jfredett> Taneb: Go have a look at Agda or Idris, both of which have dependent types. They have interesting syntacies. There is even a DT language with 2 dimensional syntax, called Epigram, as I recall
10:05:13 <Nereid> it's not ambiguous as long as you don't allow values and types to have the same name
10:05:25 <Taneb> Nereid, I don't want to force that restriction
10:05:36 <Nereid> but yes, have a look at agda or something
10:05:40 <Taneb> Okay, I will later
10:06:24 <fmapE> Taneb: Interestingly enough, GHC has to deal with that problem when using DataKinds (Lifting types to kinds and data constructors to type constructors)
10:07:16 <saep> trem, check whether you can install the haskell-platform package
10:07:28 <jfredett> I haven't read about DataKinds (I've been away from haskell for a while) -- any good links to some overviews/tutorials for them?
10:07:46 <trem> however, indeed! there are a ton of Cabal-devel and time-devel and such packages... I guess I need these
10:08:00 <jfredett> (and really, anything else interesting since like, 7.0 besides type families?)
10:08:10 <fmapE> Taneb: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html#promotion-syntax
10:08:21 <however> fmapE: he's gone
10:08:38 <trem> saep, there is a haskell-platform package, pulling it in now. guess that was my problem. from gentoo I was not used to have the -devel split, my fault.
10:08:50 * fmapE shouldn't have turned off join/quits
10:08:57 <however> jfredett: i thought people were somewhat excited about constraint kinds ...
10:09:11 <jfredett> however: that sounds neat.
10:10:31 <however> jfredett: check out those status reports http://hackage.haskell.org/trac/ghc/wiki/Status/May12
10:11:21 <jfredett> however: cool.
10:11:35 <jfredett> I forgot about these. It's been a long time. :)
10:12:18 <rustycarbon> Hey! So I want a parametric function that goes over a datatype that is parametric over Word8,Word16,... How would I approach this? Are type families the answer.
10:13:09 <Nereid> you mean type classes?
10:13:26 <Nereid> depends on what you're trying to do, of ocurse
10:14:00 <rustycarbon> Hmm... I could make it a type class with my function and different instances for each.
10:14:24 <rustycarbon> But no my function is independant of which Word* I use.
10:14:33 <rustycarbon> So it's silly to rewrite it for each!
10:15:08 <jfredett> rustycarbon: you could potentially define a type class which is empty, instance it for your types, then define your function outside the type class with a contraint to that class. :)
10:15:11 <Nereid> rustycarbon: is it also independent for each member of the Bits class?
10:15:15 <Nereid> (for instance)
10:15:47 <rustycarbon> Nereid: Hadn't considered that, could be an option.
10:16:01 <rustycarbon> Nereid: The Bits class? I don't know!
10:16:10 <Nereid> i.e. why make a new typeclass when an existing one might do?
10:16:32 <however> rustycarbon: you might want to put your code (or planned code) on hpaste. people will be able to make more concrete suggestions
10:17:04 <rustycarbon> however: I can't :(, licensed code.
10:17:20 <jfredett> is the function you're trying to define complicate, rustycarbon? You might just try writing the function first, then worry about constraints as you go -- as you find out which parts of the function are specific to a given type, you can put those as implementation details in the type class
10:17:23 <Qrt> getTextFromDir :: Monad m => [Char] -> m (IO String) // how do i do print on that? print >>= or =<< doesnt work
10:17:46 <jfredett> eg, "Oh, I need a function numberOfBits :: Wordy a => a -> Int"
10:18:14 <rustycarbon> Will have a look if I can use the Bits class, jredett: it's a large family of (ideally parametric over Word8...) functions.
10:18:36 <jfredett> Qrt: looks like it's two monads deep, you might need to liftM your function
10:18:50 <rustycarbon> Thanks! Will dig some more and come back here if need be ;)
10:19:35 <rustycarbon> "I'm two monads deep and going deeper"
10:19:36 <Qrt> @src liftM
10:19:37 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:19:56 <jfredett> more usefully, Qrt
10:20:00 <jfredett> @type liftM
10:20:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:20:25 <Qrt> actuaslly not :)
10:20:33 <jfredett> well, I was hoping the type would be nicer. :)
10:20:35 <dzhus> zomg it's INCEPTION
10:21:05 <jfredett> Qrt: it basically will shove a function past one layer of monads. you have two layers (the arbitrary `m` and the IO monad after it.
10:21:07 <jfredett> )
10:21:17 <dzhus> we have to go deeper
10:21:45 <jfredett> dzhus: monadception.
10:22:42 <rustycarbon> dzhus: I trust you've seen this http://moviesascode.net/action/inception-3/
10:23:24 <Qrt> how do i get all files in a dir?
10:24:14 <dzhus> rustycarbon: oh, hilarious website
10:24:15 <rguillebert> hi
10:24:22 <c_wraith> Qrt: look at the contents of the System.Directory module
10:24:24 <dzhus> Evening was made.
10:24:29 <srhb> @hoogle FilePath -> [FilePath]
10:24:30 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
10:24:30 <lambdabot> System.FilePath.Posix splitDirectories :: FilePath -> [FilePath]
10:24:30 <lambdabot> System.FilePath.Windows splitPath :: FilePath -> [FilePath]
10:24:41 <srhb> Hm.
10:24:45 <c_wraith> srhb: need an IO in there
10:24:51 <srhb> @hoogle FilePath -> IO [FilePath]
10:24:52 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
10:24:52 <lambdabot> Graphics.UI.GLUT.Initialization initialize :: String -> [String] -> IO [String]
10:24:52 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
10:24:55 <srhb> Ah yes
10:25:09 <rguillebert> what does "(JSON a) =>" mean in "decode :: (JSON a) => String -> Result a" ?
10:25:25 <srhb> rguillebert: It means a is of the type class JSON
10:26:10 <rguillebert> srhb, so should I specify something when I call the function ?
10:26:20 <c_wraith> rguillebert: usually, context suffices
10:26:47 <rguillebert> I'm trying to call it in ghci
10:26:53 <rguillebert> so no context :)
10:26:55 <c_wraith> ah, then yea.
10:27:14 <Qrt> can i foldM? like concat all text in all files in a dir?
10:27:33 <c_wraith> Qrt: you can do that
10:27:51 <mchm> Hi
10:28:11 <srhb> mchm: Hi.
10:28:12 <c_wraith> @hoogle foldM
10:28:13 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
10:28:13 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
10:28:13 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:29:08 <rguillebert> c_wraith, so what can I do ?
10:29:31 <c_wraith> decode "foo" :: Result Value
10:29:58 <mchm> I'm picking up on Haskell, coming from Mathematica. :)
10:30:03 <c_wraith> Value is the "base" instance of JSON - it's what all the rest are defined in terms of, more or less
10:30:09 <srhb> mchm: Welcome, it'll be fun. ;)
10:30:53 <mchm> My only fear is that I'll have problems working with large data files.
10:31:13 <srhb> mchm: Doubtful, but you'll need to learn methods for handling it. :)
10:32:11 <mchm> srhb: how does Haskell handle huge datasets containing both strings and numbers if it cannot work with mixed-type lists?
10:32:45 <srhb> mchm: I don't see how that would be a problem. You just "unmix" the data types.
10:33:56 <mchm> srhb: yeah... I guess I'll work it out. It feels very natural as a language, though. Coming from another functional style language might help
10:34:03 <Cale> Anyone following the lambda case thread?
10:34:10 <c_wraith> mchm: you just create a list of records containing whatever logical unit you're working in
10:34:23 <Cale> Why does everyone like this \case syntax rather than just the obvious case sectioning as originally proposed?
10:34:36 <srhb> Cale: I don't know, and I don't understand it either.
10:35:00 <srhb> Cale: I think the ticket has the relevant discussion, but I gave up on it, because it's such a mess.
10:35:38 <c_wraith> Cale: apparently, simon M felt it was strange to introduce a function without having it look like a function
10:35:42 <mchm> c_wraith: I'll take a loot at records once I'm done with the tutorial.
10:36:03 <c_wraith> Cale: but that makes no sense to me, because in haskell, nearly everything can look like a function
10:36:16 <srhb> mchm: If you're used to FP already, Real World Haskell might be a good read for you.
10:36:40 <Qrt> mathematica is such an amazing software
10:36:44 <srhb> mchm: I did some matlab data file parsing recently and it wasn't a problem (aside from me being a total Haskell noob).
10:37:14 <Cale> c_wraith: yeah
10:37:18 <mchm> @srhb hehe. not alone.
10:37:18 <lambdabot> Source not found. My pet ferret can type better than you!
10:37:44 <srhb> mchm: @ triggers the resident bot. ^^
10:38:06 <mchm> Qrt: If you're interested, there's a new Stack Exchange site dedicated to Mathematica opening in a few days. http://mathematica.stackexchange.com
10:38:28 <mchm> srhb: I haven't been on IRC in a decade. Thanks!
10:38:43 <srhb> mchm: It also varies from channel to channel, so you need to either figure it out or be told :P
10:38:59 <Qrt> how do i lift from IO?
10:39:09 <srhb> Qrt: Are you sure you mean lift?
10:39:39 <Qrt> not sure
10:39:47 <srhb> Qrt: What are you trying to accomplish?
10:39:49 <Qrt> i want to read the text from all files in a dir
10:40:16 <Qrt> something like: foldM (++) "" readFile --Although (++) is perhaps terrible here
10:41:00 <Cale> do fns <- getDirectoryContents "/path/to/dir"; cs <- mapM readFile fns; return cs
10:41:03 <srhb> Qrt: I would suggest starting out with an explicitly recursive version, it's probably easier to understand :)
10:41:46 <Cale> be careful with that code though, because readFile is lazy, and opening lots of files runs the risk of running out of file handles.
10:42:28 <Cale> Of course, you can just write  mapM readFile =<< getDirectoryContents "/path/to/dir"
10:42:45 <kallisti> I've found a use for and created a somewhat odd list function:
10:42:46 <Cale> or if you want to make it into a function:  mapM readFile <=< getDirectoryContents
10:42:52 <kallisti> forceLength :: Int -> [a] -> [Maybe a]
10:44:06 <Cale> :t mapM readFile <=< getDirectoryContents
10:44:07 <hape01> @src (<=<)
10:44:07 <lambdabot> Source not found. Just try something else.
10:44:08 <lambdabot> Not in scope: `getDirectoryContents'
10:44:09 <StaticShock> is there any way to declare a data type that can only be an int in the range, say, 5 to 10?
10:44:15 <Cale> :t mapM readFile <=< System.Directory.getDirectoryContents
10:44:17 <lambdabot> FilePath -> IO [String]
10:44:30 <kallisti> the use case is that I'm extracting Text fields from an HTMl document, where some of the text entires in the document may be entirely missing. so this takes a list, which could be smaller than the list I'm pattern matching, and ensures that it's the same size as the list I'm pattern matching with, while filling in Nothing for empty fields.
10:44:48 <mchm> ghci doesn't like [1,1..5]
10:44:51 <Cale> StaticShock: no, there's no way in general to construct a datatype which is a subtype of another type.
10:45:09 <kallisti> > [1,1..5]
10:45:10 <mchm> or [x,x..y]
10:45:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:45:22 <Cale> StaticShock: however, you can construct a type which just has 5 values in it that you think of as the numbers from 5 to 10
10:45:25 <zachk> > repeat 1
10:45:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:45:31 <Cale> 6 rather :)
10:45:43 <mchm> > repeate 1 == [1,1..5]
10:45:45 <lambdabot>   Not in scope: `repeate'
10:45:49 <Cale> > [1,1..5]
10:45:49 <Qrt> i want foldM: foldM f "" filenames; where f = if (endsWith filename == "hs") then readFile filename else ""
10:45:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:45:57 <mchm> > repeat 1==[1,1..5]
10:45:59 <Cale> mchm: why doesn't it like it?
10:46:01 <StaticShock> Cale: ok
10:46:01 <lambdabot>   mueval-core: Time limit exceeded
10:46:03 <hape01> :t (<=<)
10:46:04 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
10:46:05 <kallisti> a "partialNum" typeclass could be interesting. basically all of the Num operations with Maybe results.
10:46:07 <Qrt> > endsWith "hs" "haskell.hs"
10:46:09 <lambdabot>   Not in scope: `endsWith'
10:46:10 <zachk> mchrm you can't compare them like that
10:46:21 <kallisti> so you can implement out of range conditions by returning Nothing.
10:46:30 <Cale> mchm: Comparing two infinite lists takes a long time if they are equal
10:46:46 <Cale> where by "a long time", I mean "doesn't terminate"
10:46:51 <kallisti> read: forever
10:47:04 <mchm> Cale: oh, it's just that I misunderstood the step. I thought [x,y..z] meant y to z in steps of x
10:47:12 <Cale> I see
10:47:17 <Cale> > [1,3..10]
10:47:19 <lambdabot>   [1,3,5,7,9]
10:47:28 <hape01> :t (<=<)
10:47:30 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
10:47:37 <kallisti> mchm: it's x to z in steps of y-x
10:48:03 <mchm> kallisti: thanks. it wasn't obvious (to me) at first
10:48:15 <Cale> Personally, I think it should be required that no element of [a,b..c] is larger than c, but the instance for Float/Double actually disobeys this
10:48:18 <mchm> It's nice that the bot can evaluate code :)
10:49:01 <kallisti> mchm: it's supposed to mimic sequence notation in mathematics:   1, 3, 5, 7, ... 1001
10:49:10 <Cale> (well, "larger than" when b > a)
10:50:15 <kallisti> one frequent gotcha is that to enumerate downward you have to explicitly provide a step value.  [5 .. 1] is [], but [5, 4 .. 1]  works as expected.
10:50:21 <Nereid> > [1,1.1..2]
10:50:22 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
10:50:26 <kallisti> :_(
10:50:26 <Nereid> > last [1,1.1..2]
10:50:28 <lambdabot>   2.000000000000001
10:50:39 <kallisti> :__(
10:50:48 <mchm> kallisti: hmm
10:50:56 <Cale> > [1, 2 .. 5.9]
10:50:58 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0]
10:51:09 <Nereid> oh that's even worse
10:51:09 <Cale> ^^ that 6 is mildly annoying
10:51:15 <rustycarbon> kallisti: Interesting! Never tried that before!
10:51:42 <Cale> > [1,1.1..2] :: [CReal]
10:51:43 <lambdabot>   [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0]
10:52:09 <StaticShock> i have some data that i'd like to consider as "types" for my purposes, so i was trying to squeeze it into the haskell type system
10:52:13 <byorgey> > [1, 1.1 .. 2] :: [Rational]
10:52:15 <lambdabot>   [1 % 1,11 % 10,6 % 5,13 % 10,7 % 5,3 % 2,8 % 5,17 % 10,9 % 5,19 % 10,2 % 1]
10:52:19 <Cale> > [1,2..5.5]
10:52:21 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0]
10:52:23 <rustycarbon> > [1,1.1,1.11,1.111..2]
10:52:25 <lambdabot>   <no location info>: parse error on input `..'
10:52:28 <Cale> > [1,2..5.5] :: [Rational]
10:52:29 <lambdabot>   [1 % 1,2 % 1,3 % 1,4 % 1,5 % 1,6 % 1]
10:52:33 <mchm> list comprehensions == epiphany
10:52:40 <Cale> > [1,2..5.5] :: [CReal]
10:52:42 <lambdabot>   [1.0,2.0,3.0,4.0,5.0]
10:52:45 <Cale> hehe
10:52:51 <byorgey> oh, hehe
10:52:59 <rustycarbon> > [1,1.1,1.11,1.111 .. 2]
10:53:01 <lambdabot>   <no location info>: parse error on input `..'
10:53:23 <rustycarbon> > [1,1.1,1.11,1.111 .. 2.0]
10:53:24 <lambdabot>   <no location info>: parse error on input `..'
10:53:31 <rustycarbon> :S
10:53:35 <kallisti> someone should make some Ratio newtypes that provide various (correct) enumerations of the rationals.
10:53:36 <StaticShock> is it useful to have a data type with a single parameterless constructor? like, data X = X?
10:53:50 <kallisti> StaticShock: that's what () is
10:53:52 <StaticShock> is this something that comes up?
10:53:54 <byorgey> I guess the Report defines Enum for Rational in the same stupid way.  But CReal is not bound by the Report.
10:53:59 <StaticShock> kallisti: how do you mean?
10:54:00 <Cale> rustycarbon: it only works for things of the form [a..], [a..b], [a,b..] and [a,b..c]
10:54:04 <kallisti> StaticShock: it's typically used to indicate that there's no meaningful value
10:54:11 <kallisti> StaticShock: well, in Pseudo-Haskell:   data () = ();
10:54:13 <kallisti> > ()
10:54:14 <lambdabot>   ()
10:54:15 <kallisti> :t ()
10:54:17 <lambdabot> ()
10:54:31 <StaticShock> > data X = X; X == ()
10:54:33 <lambdabot>   <no location info>: parse error on input `data'
10:54:33 <Cale> StaticShock: It can be useful as a type-level flag
10:54:42 <kallisti> StaticShock: that would be a type error
10:54:49 <StaticShock> Cale: that's what I was thinking
10:54:50 <kallisti> well, no such instance.
10:54:58 <kallisti> if you derived Eq for X, then it would be a type error.
10:55:07 <kallisti> even though they're structurally equivalent, (==) only works on values of the same type.
10:55:10 <kallisti> :t (==)
10:55:12 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:55:16 <StaticShock> Cale: I'm trying to structure a type system from a different domain using haskell as my syntax
10:55:21 <byorgey> StaticShock: if you're just using it as a type-level "value", it's also typical to give it no constructors at all, like   'data X'
10:55:24 <hape01> > 1+1
10:55:26 <lambdabot>   2
10:55:39 <StaticShock> byorgey: oh, thank you. I think this is the info I was looking for.
10:55:56 <Taneb> Is it possible to make an "asAppliedTo" function?
10:56:02 <kallisti> yes
10:56:20 <Cale> It can sometimes still be handy to have a data-level representation of the type level value though :)
10:56:21 <StaticShock> byorgey: so, that way, if someone instantiates this type, they can still do operations on it, but they'd yield the same data for all possible instances
10:56:23 <Taneb> :t let x = (==); _ = x True in x
10:56:25 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:56:27 <byorgey> StaticShock: if you have GHC 7.4 you can also automatically "promote" regular values to be used as types, with the DataKinds extension.  For example  data Foo = X | Y | Z, and now you can use X, Y, Z as types
10:56:49 <byorgey> StaticShock: if you don't give it any constructors they can't instantiate it at all.
10:56:50 <Taneb> Dammit, where was the monomorphism restriction when you need it?
10:56:56 <byorgey> other than using undefined.
10:56:57 <Cale> byorgey: Here's a puzzle for you: why is the ConstraintKinds extension plural?
10:57:05 <StaticShock> byorgey: so data X = X is still different from just data X?
10:57:13 <byorgey> Cale: I have wondered that myself.
10:57:25 <kallisti> StaticShock: "instantiates" is the wrong terminology here. "construct" is the more kosher word.
10:57:30 <kallisti> lest you offend OO haters.
10:57:45 <byorgey> Cale: I seem to recall that when it was discussed, 'ConstraintKinds' was chosen 'in parallel to other plural extension names', though of course this is a false parallel.
10:57:53 <byorgey> StaticShock: yes.
10:58:03 <StaticShock> byorgey: wait, but in data Foo = X | Y | Z, X isn't a value, it's a constructor
10:58:12 <byorgey> StaticShock: it is a constructor, and also a value.
10:58:12 <StaticShock> the value it constructs is of type Foo
10:58:18 <byorgey> right.
10:58:29 <byorgey> constructors are special values.
10:58:30 <StaticShock> oh, but the  constructor itself is a value. i see what you mean
10:58:40 <StaticShock> like first class functions
10:58:55 <kallisti> StaticShock: when you say data X;  you're creating a type with no possible value representation. they're called phantom types, because they can only be created at the type level.
10:59:26 <dmwit> um
10:59:31 <byorgey> technically they are called empty types, and phantom type means something else.  though often empty types are used as phantom types.
10:59:41 <StaticShock> kallisti: what can you do with such a type?
10:59:48 <kallisti> provide extra type safety.
10:59:49 <byorgey> a phantom type is a type parameter which is unused.
11:00:08 <kallisti> also you can use them with typeclasses. provide different instances for different phantom type parameters.
11:00:14 <StaticShock> but if you can't have a value, what is it providing the type safety to?
11:00:34 <StaticShock> it's hard to visualize without an example
11:01:03 <kallisti> byorgey: yeah that's where I commonly see it. but it doesn't make sense that it should only be a "phantom type" when it's used as a parameter.
11:01:11 <mchm> No negative exponents in Haskell?
11:01:18 <kallisti> :t (^^)
11:01:20 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
11:01:34 <jfischoff> StaticShock: phantom types example: http://vimeo.com/12208838
11:01:38 <kallisti> ** and ^^ provide negative exponents.
11:01:38 <dmwit> > 3 ^^ (-7)
11:01:40 <lambdabot>   4.572473708276177e-4
11:01:45 <dmwit> > 3 ^^ (-7) :: Rational
11:01:46 <lambdabot>   1 % 2187
11:02:03 <dmwit> > 3 ^^ (-7/3)
11:02:04 <lambdabot>   Ambiguous type variable `b' in the constraints:
11:02:04 <lambdabot>    `GHC.Real.Fractional b'
11:02:04 <lambdabot> ...
11:02:10 <dmwit> > 3 ** (-7/3)
11:02:11 <lambdabot>   7.704014159451496e-2
11:02:26 <mchm> Thanks!
11:03:23 <dmwit> > 0.0770414159451496 * 12.980246132766677
11:03:24 <lambdabot>   1.0000165413848972
11:03:36 * dmwit squints
11:03:49 <Taneb> > 1/13
11:03:51 <lambdabot>   7.692307692307693e-2
11:03:55 <dmwit> > 0.07704014159451496 * 12.980246132766677
11:03:56 <lambdabot>   1.0
11:03:59 <srhb> Qrt: I poked you privately, I don't know if it was helpful.
11:04:14 <rustycarbon> Ok so looking at my problem again I need something like: type mySynonym = (Bits a) => Something a
11:04:19 <kallisti> but I guess you could use non-empty types as phantom types...
11:04:20 <kallisti> so yeah
11:05:06 <srhb> Qrt: http://hpaste.org/71348 -- and you can just put your check for .hs inside getall
11:05:08 <kallisti> rustycarbon: you need a value which can be any possible Bits instance?
11:05:21 <rustycarbon> kallisti: yes
11:05:27 <kallisti> rustycarbon: do you have a paste I can look at?
11:05:39 <rustycarbon> kallisti: Sorry I'm not allowed to distribute :(
11:06:09 <rustycarbon> kallisti: Would this be in the direction of type families or some other extension?
11:06:24 <kallisti> existential types.
11:06:27 <dmwit> Rank2Types, presumably
11:06:30 <kallisti> or that.
11:06:42 <rustycarbon> Ok will learn about those. Thanks.
11:06:53 <rustycarbon> Sorry can't give out the code otherwise that would be a lot easier ;)
11:07:11 <kallisti> rustycarbon: I have a Bits existential here:
11:07:14 <kallisti> @hoogle cond
11:07:15 <lambdabot> Language.Haskell.TH.Syntax CondE :: Exp -> Exp -> Exp -> Exp
11:07:15 <lambdabot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
11:07:16 <lambdabot> Language.Haskell.TH.Lib condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
11:07:20 <dmwit> Yes, it would, especially since the answer is *probably* "no, you're doing it wrong" rather than "yeah, you need rank-2 or existential types".
11:07:22 <kallisti> @hackage cond
11:07:22 <lambdabot> http://hackage.haskell.org/package/cond
11:07:26 <kallisti> ^ there
11:07:26 <dmwit> It's not for sure.
11:07:41 <kallisti> rustycarbon: in Data.Algebra.Boolean there's a type called Bitwise
11:07:48 <jfischoff> dmwit: took the words out of my mouth
11:08:36 <kallisti> rustycarbon: hm, or are you actually just trying to shorten your code by avoiding a bunch of Bits constraints?
11:08:40 <kallisti> because that's not what an existential does.
11:09:16 <rustycarbon> kallisti: Nope.
11:09:35 <rustycarbon> Doesn
11:09:51 <rustycarbon> Doesn't also help that I'm not *yet* entirely sure which direction I'm going... it's a learning process.
11:10:17 <rustycarbon> Will look at those and come back ;)
11:12:26 <StaticShock> if i use type X = Int to alias Int, how interchangeable are they? Is it possible to pattern match X without also matching Int?
11:12:36 <kallisti> completely interchangeable
11:12:44 <yan_> StaticShock: exactly like a C typedef i believe
11:12:48 <StaticShock> okay
11:12:53 <StaticShock> thanks
11:13:15 <kallisti> X is not an actual-facts new type. it's just a renaming of another type. you can use it in type expressions and it'll show up in some error messages.
11:14:13 <dmwit> StaticShock: You can use newtype to declare a new, distinct type with the same machine representation.
11:14:17 <dmwit> If that's what you want.
11:14:33 <dmwit> ...with the same machine representation as the old type.
11:14:41 <StaticShock> dmwit: oh, interesting, thanks
11:15:04 <dmwit> So, newtype X = X Int -- will be implemented in core as an Int, but can't be passed to Int-only functions
11:15:06 <StaticShock> dmwit: So that would be a distinct type that I can pattern match and create specific type classes for
11:15:12 <dmwit> Yes, exactly.
11:15:14 <StaticShock> dmwit: nice
11:15:59 <kallisti> and, with GHC, an unsafeCoerce from that type to the other and vice versa causes no problems.
11:16:14 <kallisti> (if you're interested in doing evil things)
11:16:35 <Taneb> kallisti, have you seen my obfuscation?
11:16:40 <kallisti> nope.
11:16:50 * kallisti found a legitimate reason to use unsafeCoerce for that purpose.
11:17:05 <Taneb> http://hpaste.org/71201
11:17:08 <kallisti> specially when you have somelike   [Type] -> [Newtype]
11:17:22 <kallisti> map NewtypeWrapper  actually has a performance penalty. unsafeCoerce doesn't.
11:17:30 <dmwit> Yes, when nested, unsafeCoerce can be more efficient.
11:17:52 <dmwit> However, it is also the source of bugs (notably even in GHC itself GeneralizedNewtypeDeriving will use unsafeCoerce in unsafe ways).
11:18:32 <Taneb> My obfuscation's really evil
11:18:38 <Taneb> Also time- and space- inefficient
11:19:41 <dmwit> I put in 10.
11:19:43 <dmwit> It hangs.
11:19:46 <dmwit> What's it supposed to do?
11:20:00 <dmwit> Currently at 60s processor time and counting...
11:20:11 <Taneb> dmwit, try a smaller number, like 7
11:20:30 <dmwit> Up, it finished!
11:20:35 <Taneb> I've never had the patience to time how long it takes to do 10
11:20:36 <dmwit> Factorial, eh?
11:20:37 <Taneb> Yeah
11:21:11 <dmwit> Factorial... in SK calculus? =)
11:21:13 <Taneb> Yes
11:21:26 <dmwit> I suddenly understand why it takes so long. =)
11:21:27 <Taneb> S = (<*>), K = pure, I = unsafeCoerce (which is necessary a lot)
11:21:35 <dmwit> > sum (replicate 3628800 1)
11:21:38 <lambdabot>   *Exception: stack overflow
11:21:49 <pyry`> Having a silly newbie problem with parsec
11:21:49 <dmwit> > foldl' (+) 0 (replicate 3628800 1)
11:21:53 <lambdabot>   3628800
11:22:01 <dmwit> Hm, I was wrong. I still don't know why it takes so long. =P
11:22:05 <pyry`> parse (sepBy (many (oneOf ['a'..'z']++['\n'])) (string "\n\n")) "" "omg\n\nomg\nbbq\n\n"
11:22:11 <Taneb> brb
11:22:26 <pyry`> for some reason i can't get it to split by two newlines
11:22:37 <pyry`> if i take out the newline list, and remove the newline between omg and bbq, everything works
11:22:42 <dmwit> pyry`: Needs some more parentheses, maybe?
11:23:24 <dmwit> But beyond that, yeah, you're going to need a "try" around the ['\n'] bit.
11:23:25 <pyry`> it's fine with the amount it has, with the following
11:23:28 <dmwit> Try something like
11:23:29 <pyry`> parse (sepBy (many (oneOf ['a'..'z'])) (string "\n\n")) "" "omg\n\nomgbbq\n\n"
11:23:30 <pyry`> ahh
11:23:46 <dmwit> (oneOf ['a'..'z'] <|> try (oneOf "\n"))
11:23:52 <pyry`> i mean, to be clear, i want \n to be included in the parse
11:24:00 <pyry`> i'm not trying to split at all newlines, just instances of two of them
11:24:12 <pyry`> e.g., ["omg", "omg\nbbq"]
11:24:18 <kallisti> profmakx: oneOf ['a'..'z'] ++ ['\n']  is actually (oneOf ['a'..'z']) ++ ['\n']
11:24:32 <kallisti> not: oneOf ['a'..'z'] ++ ['\n']  is actually (oneOf ['a'..'z'] ++ ['\n'])
11:24:34 <kallisti> er
11:24:49 <kallisti> not: oneOf (['a'..'z'] ++ ['\n'])
11:25:06 <pyry`> mm
11:25:31 <pyry`> so, more parentheses work, but it still refuses to parse on two newlines
11:25:44 <pyry`> in which case, is it try?
11:25:53 <dmwit> No, try is insufficient.
11:25:57 <dmwit> (Just tested it.)
11:26:07 <kallisti> wouldn't you just want many1 instead of oneOf?
11:26:11 <pyry`> mm
11:26:35 <aristid> i managed to crash ghc with "the 'impossible' happened". do i get a virtual cookie? :)
11:26:38 <kallisti> sepBy (many1 (char '\n'))
11:26:40 <kallisti> or something like that.
11:26:46 <aristid> (i did report the bug, of course)
11:26:48 <dmwit> The problem is that sepBy will let the first parser go as long as it wants.
11:27:01 <kallisti> aristid: check your system logs for segfaults.
11:27:05 <dmwit> So if the first parser parses newlines, the separator is never going to run.
11:27:18 <dmwit> That is, it's doing exactly what you told it to do.
11:27:33 <dmwit> You need to write a grammar that doesn't accept double-newlines as the "separated" part.
11:27:51 <Qrt> hmm the solution for foldM readFile gets a lot of \NUL\NUl hwich i dont want...
11:28:22 <pyry`> dmwit: in which case, lookahead?
11:30:04 <c_wraith> Qrt: that's probably in the files you're reading.
11:30:15 <dmwit> pyry`: try is for lookahead, yes
11:30:44 <aristid> kallisti: nope
11:31:32 <Taneb> dmwit, I don't know why it's slow either
11:32:02 <kallisti> oh cool. you can run (\x -> x x) (\x -> x x)  if you put unsafeCoerce everywhere
11:32:14 <dmwit> pyry`: This works for me: parse (sepBy (many (try (oneOf "\n" <* notFollowedBy (oneOf "\n")) <|> oneOf ['a'..'z'])) (string "\n\n")) "" "omg\n\nomg\nbbq\n\n"
11:32:48 <dmwit> There's probably a better way to parse a single given character than (oneOf "\n"), but I'm too lazy to look it up.
11:33:53 <Nereid> like char '\n'
11:34:17 <dmwit> Sounds plausible.
11:34:54 <pyry`> char would be it ;)
11:35:01 <pyry`> but cool, thanks
11:35:04 <pyry`> i'll stare at it and learn
11:35:04 <pyry`> :)
11:36:56 <daniel_-> if i have file Foo/Main.hs why cant i refer to the Core.hs file in Foo directory in Main.hs like `import Foo.Core`
11:37:08 <dblhelix> does anyone of a package that provides utility functions for state monads where the state is a list? for instance: null' :: State a [Bool], head' :: State [a] a, etc.
11:37:09 <dblhelix> ?
11:37:42 <Qrt> @hoogle String -> Bool
11:37:43 <lambdabot> Network.URI isAbsoluteURI :: String -> Bool
11:37:43 <lambdabot> Network.URI isIPv4address :: String -> Bool
11:37:43 <lambdabot> Network.URI isIPv6address :: String -> Bool
11:37:55 <kallisti> daniel_-: because it treats the current working directory as a library path, not the directory above it
11:37:56 <Botje> daniel_-: did you define a module Foo.Core in Foo/Core.hs ?
11:38:09 <Qrt> @hoogle String -> String -> Bool
11:38:09 <lambdabot> System.FilePath.Windows equalFilePath :: FilePath -> FilePath -> Bool
11:38:10 <lambdabot> System.FilePath.Posix equalFilePath :: FilePath -> FilePath -> Bool
11:38:10 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
11:38:19 <Qrt> is there a endsWith function?
11:38:23 <daniel_-> yes top of Core.hs is `module Foo.Core`
11:38:24 <Botje> dblhelix: null `fmap` ask, head <$> ask, tail `liftM` ask
11:38:36 <Taneb> Wow, my obfuscated program works for 10 in ghci?
11:38:37 <Botje> dblhelix: fmap, <$> and liftM are all equivalent here, btw
11:38:38 <Qrt> endsWith "hs" "sourcefile.hs" -> True
11:39:02 <kallisti> daniel_-: you could either move Main.hs to the directory above, add the directory above Foo to your library path via the -L option, or create a cabal package and let it handle everything for you
11:39:03 <Botje> Qrt: try isSuffixOf
11:39:03 <dmwit> dblhelix: "gets null", "gets head"?
11:39:39 <Qrt> > isSuffixOf "hs" "haskell.hs"
11:39:40 <lambdabot>   True
11:39:44 <Qrt> > isSuffixOf "hs" "haskell.c"
11:39:45 <lambdabot>   False
11:40:15 <dblhelix> Botje: well, of course (although you probably mean get instead of ask)… but I was looking for a package that was defining abbreviations for this
11:40:55 <dmwit> dblhelix: Why define abbreviations when you have higher-order functions?
11:41:24 <dmwit> null' could be damn near anything. gets null is much more specific.
11:41:28 <dblhelix> dmwit: for the simple ones that makes sense, but not for more elaborate ones
11:41:41 <dmwit> What are some elaborate ones?
11:41:47 <Qrt> where is isSuffixOf?
11:41:51 <kallisti> Data.List
11:41:56 <shurikas> @hoogle Int -> Word8
11:41:56 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
11:41:56 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
11:41:56 <lambdabot> Prelude (!!) :: [a] -> Int -> a
11:42:00 <shurikas> any ideas?
11:42:01 <dblhelix> dmwit: getting the head, putting back the tail etc.
11:42:04 <kallisti> @hoogle isSuffixOf
11:42:04 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
11:42:05 <lambdabot> Data.ByteString.Lazy isSuffixOf :: ByteString -> ByteString -> Bool
11:42:05 <lambdabot> Data.ByteString isSuffixOf :: ByteString -> ByteString -> Bool
11:42:06 <kallisti> Qrt: ^
11:42:08 <shurikas> 0-255 range is fine
11:42:24 <MostAwesomeDude> shurikas: fromIntegral can do the "cast" you want.
11:42:31 <shurikas> ah.
11:42:33 <shurikas> I see...
11:42:39 <EvanR> its not a cast
11:42:40 <EvanR> its a conversion
11:42:41 <Botje> dblhelix: you might want to search for something called the supply monad
11:42:47 <dmwit> dblhelix: "gets head", "modify tail", what could be easier?
11:42:51 <Qrt> @hoogle [a] -> Bool
11:42:52 <lambdabot> Prelude null :: [a] -> Bool
11:42:52 <lambdabot> Data.List null :: [a] -> Bool
11:42:52 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
11:42:54 <Botje> which is basically state [a] with consume functions
11:43:01 <EvanR> cast is a word used to imply type safety is switched off
11:43:05 <EvanR> well was
11:43:08 <shurikas> thanks, it works
11:43:15 <EvanR> now php, c# etc use it to mean conversion
11:43:16 <dblhelix> dmwit: sigh… for one thing that's two operations; I'd like to group them together
11:43:23 <dblhelix> Botje: thanks! will check that out
11:44:29 <Qrt> is there a func allTrue = all (== True) and anyTrue = any (== true) ?
11:44:36 <kallisti> Qrt: ^:t (and, or)
11:44:38 <kallisti> er
11:44:40 <kallisti> :t (and, or)
11:44:40 <EvanR> :t all
11:44:42 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:44:42 <lambdabot> ([Bool] -> Bool, [Bool] -> Bool)
11:44:45 <EvanR> :t any
11:44:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:44:51 <dblhelix> Botje: yes, that one seems to suit my needs; thank you!
11:45:14 <kallisti> > and [True, True, False, True]
11:45:16 <lambdabot>   False
11:45:28 <EvanR> > mconcat [True, True, False, True]
11:45:30 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Bool.Bool)
11:45:30 <lambdabot>    arising from a use of...
11:45:58 <dmwit> > mconcat . map All $ [True, True, False, True]
11:46:02 <lambdabot>   All {getAll = False}
11:46:17 <EvanR> > mconcat . map Any $ [True, True, False, True]
11:46:20 <lambdabot>   Any {getAny = True}
11:46:35 <dmwit> :t ala All
11:46:37 <lambdabot> forall b n' o'. (Newtype n' o') => ((Bool -> All) -> b -> n') -> b -> o'
11:46:50 <MostAwesomeDude> :t ala
11:46:51 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
11:47:01 <dmwit> :t ala All (const mconcat)
11:47:02 <lambdabot> forall a o'. (Monoid a, Newtype a o') => [a] -> o'
11:47:09 <dmwit> bleh
11:48:12 <dmwit> :t ala All (\f -> op f . mconcat)
11:48:13 <lambdabot> forall o'. (Newtype Bool o') => [All] -> o'
11:48:19 <dmwit> nooo
11:48:26 <MostAwesomeDude> I don't get it. What's ala do?
11:48:28 <MostAwesomeDude> :src ala
11:48:35 <EvanR> @src ala
11:48:35 <lambdabot> Source not found. That's something I cannot allow to happen.
11:48:59 <kallisti> ala does something really simple with a really weird type so that you can omit parentheses.
11:49:06 * kallisti helpful.
11:49:26 <dmwit> kallisti: How do I do what I want to do.
11:50:10 <kallisti> dunno.
11:50:18 * kallisti helpful.
11:50:32 <johnlap> Hello. I'm having trouble compiling Haskell platform on OS X 10.8. I'm getting type errors in HUnit. Has anyone else been trying this yet?
11:51:00 <dmwit> Oh, wait, maybe I actually got it before.
11:51:13 <dmwit> > ala All (const mconcat) [True, True, False, True]
11:51:14 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Bool.Bool)
11:51:15 <lambdabot>    arising from a use of...
11:52:03 <kallisti> > ala All mconcat [True, True, False, True]
11:52:05 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> Data.Monoid.All'
11:52:05 <lambdabot>         aga...
11:52:21 <Qrt> ok ty i can now fetch all data from files in a dir
11:52:22 <aristid> :t ala All
11:52:24 <lambdabot> forall b n' o'. (Newtype n' o') => ((Bool -> All) -> b -> n') -> b -> o'
11:52:33 <Qrt> so i need to paste to hpaste with Network.Browser
11:52:47 <Qrt> how do I get the fields and paste to them?
11:53:11 <dmwit> > ala All (mconcat . map) [True, True, False, True]
11:53:12 <lambdabot>   Couldn't match expected type `[b -> n']'
11:53:12 <lambdabot>         against inferred type `[GH...
11:53:33 <dmwit> :t under All
11:53:34 <lambdabot> forall n' o'. (Newtype n' o') => (All -> n') -> Bool -> o'
11:53:48 <dmwit> :t underF All
11:53:50 <lambdabot> Not in scope: `underF'
11:54:56 <zzing> Is there any database API that supports stored procedures as a primary means of running queries?(primary interest is postgres)
11:54:59 <kallisti> > ala All (map . mconcat) [True, True, False, True]
11:55:01 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> Data.Monoid.All'
11:55:01 <lambdabot>         aga...
11:56:09 <dmwit> > ala All ((mconcat .) . map) [True, True, False, True]
11:56:12 <lambdabot>   False
11:56:17 <dmwit> > ala Any ((mconcat .) . map) [True, True, False, True]
11:56:19 <lambdabot>   True
11:56:24 <dmwit> That's not much of a shortcut.
11:56:31 <kallisti> right. ala works with higher order functions
11:58:35 <statusfailed> Can I look at the things inside a "let" expression while debugging in GHCi?
11:58:52 <statusfailed> it doesn't seem to work
11:59:12 <Qrt> view-source:http://hpaste.org/ // how would I post a paste to hpaste?
11:59:25 <Qrt> statusfailed: yes
11:59:30 <edwardk> preflex: xseen stepcut
11:59:30 <preflex>  stepcut was last seen on freenode/#haskell-blah 3 days, 23 hours, 1 minute and 59 seconds ago, saying: :)
11:59:39 <edwardk> preflex: xseen alpounet
11:59:39 <preflex>  alpounet was last seen on freenode/#haskell 5 days, 7 minutes and 33 seconds ago, saying: (the first two are mailing lists, just in case you haven't heard about them, which is unlikely but just saying anyway)
12:00:05 <fragamus> hey guys what technologies should I look into for distributed computing in haskell and which is most popular
12:00:06 <hpaste> “Max s” annotated “Error!” with “Error! (annotation) (annotation)” at http://hpaste.org/71276#a71351
12:00:07 <StaticShock> i want to declare a type constraint on "a", but this doesn't seem to work: data Num a => X a b = X a [b]
12:00:14 <stepcut> preflex: xseen stepkut
12:00:14 <preflex>  stepkut was last seen on freenode/#haskell 12 hours, 56 minutes and 6 seconds ago, saying: later!
12:01:59 <statusfailed> Qrt: When I break inside the let expression, it seems to just go to the start of it, and I can't see the variables
12:02:32 <kallisti> Prelude Unsafe.Coerce> (\x -> (2:) (unsafeCoerce x (unsafeCoerce x))) (\x -> (2:) (unsafeCoerce x (unsafeCoerce x)))
12:02:40 <kallisti> fix (2:), untyped lambda calculus style.
12:06:04 <Qrt> anyone used Network.Browser?
12:06:33 <StaticShock> so is newtype a way to "inherit" from a type?
12:07:06 <StaticShock> is it a way to declare a subtype?
12:07:09 <scopedTV> newtype is a way to introduce a type isomorphic to an existing one
12:07:12 <scopedTV> no, Haskell has no subtyping
12:07:16 <aristid> StaticShock: not really, it's a way to create a new type with the same representation as an existing type
12:07:17 <Taneb> StaticShock, newtype is a way to pretend a type isn't itself
12:07:58 <StaticShock> i mean, if there's a type class defined for the original type, will it match the new type, or no?
12:08:02 <scopedTV> no
12:08:05 <StaticShock> okay
12:08:24 <StaticShock> so if i do newtype X = Int, the result is not comparable until i define how to compare them?
12:08:26 <aristid> however, ghc can automatically derive the type class, but only if you ask it to
12:08:27 <scopedTV> if you want that you can write the instance, or use GeneralizedNewtypeDeriving and use deriving
12:08:38 <scopedTV> StaticShock: you need a constructor also
12:08:43 <Taneb> StaticShock, newtype X = X Int
12:08:45 <scopedTV> newtype X = MkX Int, for example
12:08:47 <Taneb> (for example)
12:08:53 <StaticShock> ok
12:08:57 <dmwit> StaticShock: Correct; if you'd like the same instance as for Int, you may write "... deriving Ord".
12:09:03 <EvanR> generalized newtype deriving
12:09:04 <scopedTV> you can then write, instance Eq X where (MkX x) == (MkX y) = x == y
12:09:05 <StaticShock> okay
12:09:14 <scopedTV> you can also write newtype X = MKX Int deriving (Eq)
12:09:37 <dmwit> This "Mk" prefix has always struck me as a bit redundant.
12:10:01 <dmwit> Except for newcomers, as a pedagogical trick to avoid talking about the separate namespaces at the type and term level.
12:10:13 <scopedTV> dmwit: Agreed. I never use it, but to introduce it to newcomers I like to use it.
12:10:19 <scopedTV> exactly
12:10:22 <kallisti> dmwit: that's the only time I've used it, as otherwise they'll invariably get confused by the same names.
12:10:47 <dmwit> Qrt: Yes.
12:10:52 <dmwit> Qrt: Next question.
12:13:23 <Qrt> how do I do a post to hpaste?
12:14:43 <geekosaur> I have no idea if hpaste has an API
12:14:55 <dmwit> Do you know how forms work? Have you done screen scraping before?
12:15:44 <dmwit> Just POST a request to /new with the appropriate form data and you're done.
12:16:01 <Qrt> no screen scraping
12:16:12 <Qrt> no idea how to request to /new
12:16:18 <dmwit> It was a dumb question, anyway. You don't need to do any screen scraping for this.
12:16:35 <dmwit> Perhaps you should read a tutorial on how HTML forms work first.
12:18:05 * eikke feels kinda sad the ICFP registration page is 'register.php' :-P
12:18:21 <scopedTV> maybe somebody is trolling us all
12:18:37 <dmwit> Yes, it should be register.html.
12:18:51 <dmwit> Exposing your implementation language in your extension is a true wart.
12:19:02 <mauke> it should be register
12:19:15 <mauke> exposing "extensions" in your filenames and filenames in your urls, etc
12:19:21 <dmwit> That would be fine, too.
12:19:40 <Nereid> it should be register.exe
12:19:47 <dmwit> Until we have filesystems that store mime-type metadata, I'm resigned to using extensions in my filenames.
12:20:11 <Nereid> and software to support it
12:21:04 <scopedTV> URLs should not map to files directly
12:21:17 <scopedTV> well not in this case at least
12:21:23 <Cale> kallisti: It's worth noting that with a recursive newtype, it's possible to run (\x -> x x) (\x -> x x) by sticking some isomorphisms into it too.
12:21:37 <EvanR> scopedTV: mapping directly to files is very convenient
12:21:40 <Cale> newtype Rec a = In { out :: Rec a -> a }
12:21:40 <Cale> omega = (\x -> out x x) (In (\x -> out x x))
12:21:49 <kallisti> right
12:21:54 <scopedTV> EvanR: it's convenient but wrong
12:22:02 <EvanR> how is it wrong
12:22:03 <dmwit> scopedTV: I never claimed they should, by the way, in case that was a response to me.
12:22:11 <Cale> You can use the same trick to write the Y combinator
12:22:18 <scopedTV> Ok.
12:22:29 <scopedTV> EvanR: it couples your interface with implementation details
12:22:41 <EvanR> depends on what youre trying to accomplish
12:22:51 <EvanR> serving html files is easier that way
12:23:32 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
12:25:09 <fragamus> does anyone here do distributed computing with haskell
12:25:28 <Qrt> B.request $ H.postRequest "http://www.hpaste.org /new"  --how would the postrequest string look?
12:25:53 <hpaste> s pasted “a” at http://hpaste.org/71355
12:25:54 <scopedTV> probably urlencoded
12:26:09 <dmwit> Qrt: Just like that, but without the space. =)
12:26:26 <dmwit> scopedTV: Parameters don't go in the URL for POST requests, I think...
12:26:35 <scopedTV> not in the URL no
12:26:49 <scopedTV> in the request body
12:27:58 <dmwit> You'll probably want postRequestWithBody, though, not postRequest.
12:31:24 <Ragnaroek> hurray, hackage is up again :)
12:35:59 * hackagebot biofasta 0.0.1 - Library for reading fasta sequence files (DanFornika)
12:36:55 <Qrt> postRequestWithBody not in scope
12:38:51 <srhb> @index postRequestWithBody
12:38:51 <lambdabot> bzzt
12:39:10 <aristid> @hoogle postRequestWithBody
12:39:11 <lambdabot> No results found
12:39:15 <aristid> @hoogle postRequest
12:39:15 <lambdabot> Network.HTTP postRequest :: String -> Request_String
12:39:28 <srhb> It's from Network.HTTP. I don't know why lambdabot is being stupid about it.
12:40:58 <srhb> Hoogle finds it just fine. Go figure.
12:41:08 <dmwit> It's available in HTTP-4000.2, but not HTTP-4000.1.
12:41:15 <srhb> Ah
12:41:22 <dmwit> So in 4000.1, you'll have to use the more annoying route of building the request yourself.
12:41:22 <srhb> Well that explains. :-)
12:41:39 <Qrt> i have no idea how¨
12:41:48 * aristid would just use a real HTTP client library :P
12:42:23 <dmwit> Qrt: You can review Network.DGS from the dgs library for some sample code that does POST requests.
12:42:32 <Qrt> B.request $ H.postRequest "http://www.hpaste.org/new={author=qrt ...?
12:42:47 <mauke> this would be so much easier in perl
12:43:48 <aristid> using http-conduit and http-types, it should be quite easy too.
12:43:55 <dmwit> Actually, I use GET, but the way to use POST is the same, just with POST in place of GET in the command. =)
12:44:19 <dmwit> http://hackage.haskell.org/packages/archive/dgs/0.2/doc/html/src/Network-DGS.html#get
12:45:09 <mauke> my $ua = LWP::UserAgent->new; $ua->post("http://hpaste.org/new", { title => "yo", author => "me", paste => $text, ... });
12:45:42 <aristid> mauke: http://hackage.haskell.org/packages/archive/http-types/0.7.1/doc/html/Network-HTTP-Types-URI.html#v:renderQuery
12:45:59 <dmwit> mauke: For comparison, by the time you've copied the source of "get" from above, that's get id "http://hpaste.org/new" [("title", "yo"), ("author", "me"), ("paste", text)]
12:46:02 <dmwit> not so very different
12:47:08 <mauke> dmwit: how do you print the paste url?
12:47:41 <dmwit> I haven't got the faintest idea. What does hpaste give you back, a redirect?
12:48:11 <mauke> I don't know either but my code does $r = $ua->post(...); ... print $r->base;
12:48:18 <dmwit> Anyway, I could probably work it out, but I doubt it's significantly harder than in Perl. Just a matter of knowing the various libraries.
12:48:31 <aristid> indeed
12:48:34 <mauke> yes, but I already know the perl library
12:48:43 <dmwit> Well, that's why it's easier in perl for you. =)
12:48:49 <dmwit> I doubt Qrt knows the perl library. =)
12:50:46 <aristid> dmwit: oh you wrote your own little HTTP library inside a Go Server?
12:51:25 <dmwit> No, this is just a library to access an already-existing HTTP-based go server.
12:52:09 <aristid> dmwit: so it's a client for a go server, and it's just a thin function around the HTTP package stuff
12:52:13 <dmwit> right
12:52:42 <aristid> does the HTTP package support SSL/TLS these days, btw? :P
12:52:49 <aristid> @hackage HTTP
12:52:49 <lambdabot> http://hackage.haskell.org/package/HTTP
12:52:54 <dmwit> I don't think so. =)
12:53:01 <dmwit> But that's okay, because neither does DGS.
12:53:03 <akamaus> dmwit, are you planning to make a go AI player?
12:53:12 <dmwit> I am emphatically not planning that.
12:53:13 <mauke> (LWP does)
12:53:16 <gwern> so... much... spam on hawiki
12:53:22 <aristid> mauke: http-conduit does, too.
12:53:22 <gwern> dammit ashley
12:53:30 <dmwit> Yes, in retrospect HTTP was the wrong choice of backend.
12:53:53 <aristid> dmwit: but not worth the hassle changing it? :)
12:53:59 <dmwit> ...but I learned enough curl once to know I didn't want to do that again. =P
12:54:13 <dmwit> aristid: Well, I'm going to have to update it soon, because DGS just had a major upgrade.
12:54:17 <dmwit> I think I'll switch then. =)
12:54:27 * gwern bugs ashley again
12:54:33 <aristid> dmwit: to what? can i convince you to use http-types/http-conduit? :)
12:55:01 <dmwit> hm
12:55:20 <dmwit> I'm not (yet) convinced that the iteratees/pipes/conduits design space has settled enough to depend on one or the other.
12:55:24 <aristid> dmwit: you don't need to use any conduits there.
12:55:34 <aristid> dmwit: it exposes a nice ByteString interface, too.
12:56:00 * hackagebot biophd 0.0.2 - Library for reading phd sequence files (DanFornika)
12:56:04 <dmwit> The upgrade moved from ad-hoc formats to plain old JSON, though, so that's nice.
12:56:13 <dmwit> I'll get to learn how to do that kind of thing. =)
12:57:16 <aristid> dmwit: whatever you do, don't use curl tho ;)
12:58:08 <dmwit> Yeah, I have to figure out WTF to use.
12:59:43 <aristid> dmwit: also, don't use an inferior package just because you want to avoid the conduit/pipe/iteratee debate altogether.
13:00:03 <dmwit> Oh, heck, the existence of something that automatically does keep-alive is already worlds better than HTTP.
13:00:38 <Qrt> get id "http://hpaste.org/new" [("title", "yo"), ("author", "me"), ("paste", text)] // 9is that suposoed to work?
13:00:44 <mauke> no
13:00:49 <aristid> Qrt: only in the dgs package
13:01:00 <mauke> for one, it's a get, not a post
13:01:01 <srhb> I have a number of functions that do various requests to servers, but they need a token to do so, and this token might expire and require me to fetch a new one (getToken) at any time. How do I deal with this without infesting every function with if tokenTimedout ... ?
13:01:20 <aristid> mauke: maybe hpaste supports GET, too?
13:01:28 <mauke> I hope not
13:01:46 <mauke> otherwise hpaste is going to see a lot of spam in the next days
13:01:49 <Peaker> dmwit, you doing go programming?
13:01:58 <dmwit> No.
13:02:01 <dmwit> Goodness no.
13:02:23 <aristid> mauke: well, it does prepulate a website for you if you do that :D
13:02:23 <dmwit> That is a hole that can swallow way too much of a person's time.
13:02:52 <Peaker> I wonder if a Haskeller could use go voluntarily (not be disgruntled)
13:03:03 <Qrt> im not gonna spam hpaste
13:03:17 <Qrt> just use it as normal, 1-2 times a day, often 0.
13:03:19 <dmwit> Wait, were you asking if I was programming in the language go?
13:03:24 <dmwit> Then the answer is doubly goodness no.
13:03:59 <Peaker> then what was the http server in go thing about?
13:04:01 <srhb> I suppose I can wrap every function in a higher order one that take the specific request one and deals with the token refreshing...
13:04:16 <dmwit> Peaker: No, it's a go server that uses HTTP.
13:04:19 <dmwit> Peaker: go, the game
13:04:22 <Peaker> oh
13:04:25 <Qrt> so noone knpws how to do a simple post request?
13:04:26 <aristid> Peaker: lol, it's a client library for a Go (the game) server with a HTTP interface
13:04:32 <EvanR> lol go programming language
13:04:34 <aristid> Qrt: yes we do
13:04:34 * EvanR shakes head
13:04:46 <EvanR> oh god why.jpg
13:05:59 <Peaker> does anyone believe Rob Pike knows what algebraic data types are, and chose not to implement them, or is Go designed out of ignorance, as usual?
13:06:24 <dmwit> aristid: getBrowserState/setBrowserState? =/
13:06:49 <aristid> dmwit: ?
13:07:01 <newsham> edwardk: around?
13:07:07 <dmwit> Why do those exist? There's already a MonadState BrowserState instance...
13:07:07 <aristid> Peaker: i'd be pretty sure the latter
13:07:19 <EvanR> rob pike wrote some stuff about his design decisions
13:07:28 <aristid> Peaker: but maybe he kind of knows what these things are, but dismisses them as academic complex bullshit
13:07:29 <EvanR> very 'illuminating'
13:07:41 <Peaker> EvanR, where?
13:07:44 <newsham> peaker: I'm guessing he knows what ADTs are
13:07:56 <EvanR> Peaker: someone in here had a link...
13:08:24 <Qrt> B.request $ H.postRequest "http://www.hpaste.org/new" then how do i add the form data?
13:08:28 <newsham> peaker: one of his former esteemed colleagues used haskell to great effect, i know russ cox (one of the golang team) has written about it
13:08:38 <aristid> @hoogle getBrowserState
13:08:38 <lambdabot> Network.Browser getBrowserState :: BrowserAction t (BrowserState t)
13:08:39 <Ragnaroek> hGetLine: illegal operation (handle is not open for reading) with a Handle converted with fdToHandle
13:08:45 <srhb> OK, so.. The design could be something like this: a function request (Request -> Response) which deals with token.. But then I have to wrap every kind of Response into this type. Not sure if that's good. Perhaps it encapulates the design nicely enough.
13:08:47 <Ragnaroek> I don't get it
13:08:50 <aristid> dmwit: i don't know squat about Network.Browser
13:09:05 <EvanR> Peaker: ok heres a youtube
13:09:07 <dmwit> aristid: I'm talking about http-conduit
13:09:10 <Peaker> newsham, it's so weird, would anyone design nullable-everything into a language knowingly?
13:09:19 <EvanR> http://www.youtube.com/watch?v=jgVhBThJdXc&feature=youtu.be
13:09:32 <aristid> dmwit: oh, i never really looked at the .Browser module
13:09:32 <Qrt> "http://www.hpaste.org/new" //should that just be like a html form data string?
13:09:48 <aristid> dmwit: i only use Network.HTTP.Conduit directly :)
13:09:52 <mauke> Qrt: a what?
13:10:01 <aristid> Qrt: it should be a url-encoded form data string
13:10:12 <newsham> peaker: what are the other options?  1) impl generics (they dont want to right now) 2) build maybe into the lang?
13:10:14 <aristid> Qrt: like title=foo%20bar
13:10:42 <aristid> newsham: (1)
13:10:59 <newsham> aristid: they've talked repeatedly about why they are not ready to put generics in.
13:11:01 * hackagebot kevin 0.1.5 - a dAmn  IRC proxy (JoelTaylor)
13:11:07 <Qrt> aristid: can you write the whole string?
13:11:12 <EvanR> newsham: build Either into the language
13:11:18 <Peaker> newsham, either option is far better than nullable everything
13:11:18 <Qrt> "http://www.hpaste.org/new" then after new?
13:11:32 <EvanR> build algebraic data into the language
13:11:41 <newsham> peaker: thats your reckoning.. i guess they figured otherwise?
13:11:44 <dmwit> Qrt: The form data doesn't go in the URL.
13:11:48 <aristid> Qrt: "title=foo%20bar&author=Qrt"
13:11:57 <Qrt> then where does it go?
13:11:57 <Peaker> newsham, or they were ignorant?
13:12:00 <newsham> does anyone know where the web page that had a collection of UM32 implementations (some in haskell) is?
13:12:04 <dmwit> Qrt: In the request body.
13:12:04 <aristid> Qrt: in the request body
13:12:09 <newsham> i think dons compiled it when looking at optimizing haskell
13:12:16 <geekosaur> Qrt, do you know the difference between GET and POST?
13:12:25 <geekosaur> if not, perhaps you need to do some studying first
13:12:27 * dmwit doesn't
13:12:38 <aristid> http://hackage.haskell.org/packages/archive/http-conduit/1.5.0.3/doc/html/Network-HTTP-Conduit.html#v:urlEncodedBody :>
13:12:53 <EvanR> webservers dont ;)
13:13:17 <aristid> EvanR: is this a poke at ignoring idempotence or such things?
13:13:23 <EvanR> yeah
13:13:31 <aristid> :)
13:13:35 <geekosaur> they do... you can't have more than a couple KB in a URL, hence POST
13:13:53 <aristid> geekosaur: EvanR hates you forever now
13:14:02 <hpaste> daniel_- pasted “readprocess error” at http://hpaste.org/71357
13:14:04 <EvanR> firefox on osx totally borks on not even that long urls
13:14:13 <daniel_-> why doesnt it work?
13:14:26 <geekosaur> I havent tried recently to see where browsers blow up with big URLs these days but I used to make firefox dump core a lot trying to force a(n ancient) system to do too much
13:14:42 <kallisti> @hoogle for
13:14:43 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
13:14:43 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
13:14:43 <lambdabot> Foreign module Foreign
13:14:45 <esap> What would be a reasonable finite representation for "Stream Bool" if I also want to determine if all elements of the stream after a given element are True?
13:14:56 <newsham> peaker: perhaps you should ask pike,cox,et al.
13:15:22 <kallisti> esap: a list?
13:15:39 <geekosaur> (I don't even use firefox any more; it's broken in lots of ways on OS X\)
13:15:42 <dmwit> esap: Possibly a finite automata (or perhaps as simple as an explicit graph).
13:15:45 <aristid> esap: an infinite stream?
13:15:47 <yairchu> Peaker: their intention was just to make a language that is better than the state of the art, not necessarily a good language. and state of the art is defined as Java
13:15:47 <dmwit> ...directed graph.
13:16:22 <esap> dmwit: ah that's a good idea, then I could compare the states
13:16:26 <daniel_-> is readProcess not working for anyone else?
13:16:27 <Peaker> yairchu, or C#? which is possibly better than go
13:16:28 <dmwit> If there's a cycle containing only True's reachable from the start state, you know all elements after a given one are True.
13:17:18 <geekosaur> daniel_-, that error makes no sense
13:17:21 <Qrt> so how do i put the form in the reuqest?¨
13:17:23 <daniel_-> i know
13:17:29 <dmwit> ?index readProcess
13:17:29 <lambdabot> bzzt
13:17:33 <geekosaur> it's saying that the directory you ran ghci from no longer exists
13:17:41 <geekosaur> dmwit, System.Process
13:17:46 <daniel_-> OH
13:17:49 <daniel_-> lololol
13:17:54 <daniel_-> its because it doesnt
13:18:09 <geekosaur> ...
13:18:14 <daniel_-> but wth?
13:18:23 <daniel_-> i changed directory name half an hour ago
13:18:34 <daniel_-> but my compiles has still been working/showing updates
13:18:44 <aristid> Qrt: postRequestWithBody
13:18:57 <aristid> Qrt: you might need a sufficiently recent version of the HTTP package
13:18:59 <kallisti> Qrt: typically you send a POST request to what the "action" attribute of the form element points to, with fields in url-encoded style.  arg1=val1&arg2=val2&...
13:19:04 <Qrt> aristid: where is it?
13:19:08 <dmwit> Qrt: Or, in older HTTP versions, use the "form" function.
13:19:18 <aristid> Qrt: in Network.HTTP
13:19:26 <dmwit> err
13:19:31 <dmwit> formToRequest, I mean
13:19:38 <geekosaur> readProcess needs the current directory since it's spawning a new process in a particular way.  if you haven't been doing that, nothing else would be that likely to notice
13:19:43 * kallisti likes the http-conduit interface.
13:20:47 <aristid> kallisti: so do i, although maybe more convenience functions would be nice
13:21:37 <aristid> @hoogle formToRequest
13:21:37 <lambdabot> Network.Browser formToRequest :: Form -> Request_String
13:21:54 <Qrt> bah how do i create an URI?
13:22:07 <Peaker> yairchu, the go presentor in Google IO compares go to C++, java and Python, so I guess they just wanted to improve on those
13:22:18 <Qrt> and is formvar = [(field,value),(field2,value2)] ?
13:22:37 <Qrt> @hoogle Form
13:22:38 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
13:22:38 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
13:22:38 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
13:22:49 <Qrt> lol
13:22:50 <aristid> Qrt: http://hackage.haskell.org/packages/archive/network/2.3.0.11/doc/html/Network-URI.html#g:2
13:22:57 <aristid> Qrt: that's how you parse a URI
13:23:11 <dmwit> I feel like Qrt needs to learn how to read Hackage documentation more than anything else.
13:23:13 <yairchu> Peaker: yep, those were the blessed languages in the Goog (with addition to Javascript etc)
13:23:24 <dmwit> (This is not meant to be an insult. That is a skill that takes a bit of practice.)
13:24:28 <aristid> dmwit: you know you're _really_ browsing hackage documentation when more than half of your browser tabs are to hackage API docs
13:24:31 <ben> Or maybe hackage documentation needs to learn to be more readable
13:25:08 <aristid> ben: the documentation for URI (in Network.URI) isn't that bad
13:25:14 <hpaste> listofoptions pasted “experimental parser/fun with parsec :/” at http://hpaste.org/71358
13:25:52 <Peaker> yairchu, probably ignorance involved too
13:26:25 <dmwit> ben: I think any sufficiently useful documentation will take skill to read.
13:27:11 <ulfdoz> Naja, wenn polige bersetzungen statischer Texte in Anwendungen eine Roundtriptime von 4 Wochen haben, bis wir sie endlich mit einem einzigen Knopfdruck in Sekundenbruchteilen installieren knnen, dann gibt es halt Schmerzen.
13:27:18 <ulfdoz> ewin, sorry
13:28:09 <aristid> ulfdoz: yes, you should get faster translators
13:28:43 <however> ulfdoz: you should insert a p in there
13:28:43 <dmwit> aristid: ugh
13:28:59 <dmwit> aristid: Seems I'll use http-conduit after all.
13:29:06 <kallisti> Warning: Error parsing config file /home/adam/.cabal/config:41:
13:29:08 <aristid> dmwit: don't find an alternative?
13:29:08 <kallisti> Parse of field 'documentation' failed
13:29:09 <kallisti> why
13:29:25 <aristid> dmwit: i think for your purposes the ByteString interface will be fine :)
13:29:30 <dmwit> aristid: HTTP and curl, and I already know both don't work well. =)
13:29:38 <mauke> kallisti: what's line 41?
13:29:44 <kallisti> documentation: True
13:30:04 <dmwit> kallisti: What's lines 1-40?
13:30:10 <mauke> can't be
13:30:20 <kallisti> I literally just uncommented a line from the default config
13:30:23 <kallisti> and cabal is like "nope"
13:30:38 <aristid> kallisti: heh
13:30:39 <however> kallisti: i think whitespace is significant in that file. any chance indentation is messed up?
13:31:16 <StaticShock> is it possible to specify in a data constructor that one of the type parameters should be a list?
13:31:29 <StaticShock> or should i just leave that to be inferred?
13:31:37 <dmwit> kallisti: As however says, look for indented lines *after* the documentation: True line.
13:31:43 <kallisti> http://sprunge.us/dWCV  have a look at it yourself
13:31:49 <dmwit> (Just tested what happens when I indent some things in my config.)
13:31:50 <kallisti> oh...
13:31:50 <kallisti> found it
13:31:53 * kallisti used his eyes.
13:31:56 <nule> I got a simple test case doing exactly what I want, but it seems ugly to me - if anybody would care to comment i'd appreciate it
13:32:00 <hpaste> nule pasted “Idiomatic way to do this” at http://hpaste.org/71361
13:32:34 <kallisti> dmwit: I was looking before. :P  it was after.
13:32:46 <hpaste> qrt pasted “do construct must be” at http://hpaste.org/71362
13:33:02 <however> kallisti: i think "--remote-repo" and "-- remote-repo" might not be the same, but maybe i'm mixing it up
13:33:27 <byorgey> nule: main = putStr . unlines . map (unlines . map show) $ xs
13:33:29 <kallisti> however: I don't think that's messed up. I found the actual problem.
13:33:41 <byorgey> nule: note that  [f x | x <- xs] is the same as  map f xs
13:33:43 <aristid> Qrt: your indentation is slightly off
13:34:20 <nule> byorgey: thanks I'll dig into that
13:34:25 <daniel_-> :t catch
13:34:27 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
13:34:38 <kallisti> daniel_-: there's a better catch in Control.Exception
13:34:56 <byorgey> nule: however, since you're not differentiating the nested lists in the output, you could also just write  putStr . unlines . map show . concat $ xs
13:35:08 <daniel_-> i want something that eithers returns a IO String or logs the error
13:35:14 <dmwit> byorgey: That doesn't make enough newlines, I think.
13:35:21 <dmwit> byorgey: He's got an extra one after each group.
13:35:25 <dada_cetacean> how do I indicate a module's to be loaded in a source file?
13:35:26 <byorgey> oh, hmm, you're right
13:35:26 <nule> byorgey: in the report i'm generating I will have to, so I'm keeping that in mind
13:35:27 <kallisti> daniel_-: what kind of errors?
13:35:34 <kallisti> any kind?
13:35:40 <byorgey> nule: ok, right, then ignore that.
13:35:48 <dmwit> dada_cetacean: "import Foo.Bar.Baz"
13:35:51 <daniel_-> a readProcess, but the readprocess isnt that important so it can be ignored
13:35:54 <dada_cetacean> thanks!
13:36:35 <Qrt> how do i check version of a lib?
13:36:41 <Qrt> like Network.Browser¨
13:36:46 <kallisti> Qrt: locally? cabal info package
13:36:53 <dmwit> ghc-pkg list http
13:36:59 <dmwit> ghc-pkg list HTTP # I mean
13:37:29 <kallisti> daniel_-: import Control.Exception; import Prelude hiding (catch)    logOnError :: IO a -> IO a; logOnError io = io `catch` \(SomeException e) -> do appendFile (show e ++ "\n"); throwIO e
13:37:48 <kallisti> er, missing argument in appendFile.  do appendFile "mylog.txt" (...)
13:38:12 <kallisti> :t appendFile
13:38:14 <lambdabot> FilePath -> String -> IO ()
13:38:16 * kallisti sanity check.
13:39:31 <kallisti> :t Control.Exception.catch
13:39:33 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
13:40:01 <kallisti> daniel_-: the catch function in Prelude only handles IOError, the one in Control.Exception is overloaded on any instance of Exception. one such exception type is called SomeException, which is an existential that catches all types of exceptions.
13:43:52 <Qrt> so i get a damn maybe from parseURI, can i just force it out of maybe unsafeLiftFromMaybe ?
13:44:05 <hpaste> daniel_- pasted “this explains what i want” at http://hpaste.org/71364
13:44:58 <daniel_-> i have no idea how to achieve that :P
13:46:26 <byorgey> Qrt: you can use 'fromMaybe' to specify a default value in case it is Nothing
13:46:33 <dmwit> Qrt: No. http://dmwit.com/unimportant/grumpy.jpg
13:47:01 <byorgey> Qrt: or if you are really really sure it is not Nothing, you can use  fromJust.  But if you do, ceiling cat is watching you.
13:47:14 <dmwit> More helpfully: you can use "maybe", "fromMaybe", or a pattern match to tell what should happen when you get a Nothing.
13:47:19 <jfredett> byorgey: and ceilingcat is a vengeful cat.
13:47:21 <augur> are there any haskell hosting services currently?
13:47:26 <srhb> Qrt: You should pattern match in a case expression or something. Æ=
13:47:48 <byorgey> augur: what do you mean by "haskell hosting service"?
13:47:58 <augur> byorgey: like, web hosting
13:48:14 <augur> using haskell as the language of choice instead of ruby or php
13:48:30 <byorgey> oh. no idea.
13:48:34 <jfredett> augur: iirc, heroku has a buildpack for haskell apps w/ snap or yesod.
13:48:38 <augur> hm.
13:49:09 <jfredett> the packs are hosted on github, too, so they're hackable.
13:49:46 <jfredett> augur: I don't know of anything haskell-specific, in any case. I would imagine most just host on a VPS or w/e
13:49:51 <Qrt> i cant do version because of permision on windows
13:49:53 <Qrt> so i dont have formToRequest and i dont have postRequestWithBody
13:50:21 * dmwit squints at Qrt
13:50:46 <Qrt> @faq squint
13:50:47 <lambdabot> The answer is: Yes! Haskell can do that.
13:50:54 <Qrt> @src squint
13:50:54 <lambdabot> Source not found. Where did you learn to type?
13:51:25 <Qrt> Not in scope: `B.formtoRequest'
13:51:34 <dmwit> It's called formToRequest.
13:52:16 <daniel_-> i guess its off to stackoverflow then :]
13:53:27 <byorgey> daniel_-: what was wrong with kallisti's answer?
13:54:28 <daniel_-> it will not work for me if im not mistaken
13:54:38 <kallisti> why not?
13:54:38 <byorgey> why not?
13:54:50 <jfredett> daniel_-: did you try it?
13:55:03 <jfredett> if so, what was the error? maybe we can help
13:55:11 <daniel_-> i've explained here http://hpaste.org/71364
13:55:23 <daniel_-> i dont want to make the whole main catcheable
13:55:33 <daniel_-> only the return of pgrep'
13:55:38 <byorgey> daniel_-: that does not explain anything. kallisti already said that the catch from Prelude does not do what you want.
13:55:48 <kallisti> so just wrap it in logOnError
13:56:04 <daniel_-> okay
13:56:05 <kallisti> the type IO a -> IO a
13:56:14 <kallisti> will work with any IO
13:56:18 <augur> hm
13:56:38 <augur> im thinking of removing all of my blog posts from wordpress and using raw, hand-managed html
13:57:10 <augur> i feel thats what oleg would do
13:57:30 <kallisti> the great Oleg in the sky.
13:57:46 <dmwit> That's what I do, but it does have a downside: no comments.
13:58:16 <triyo> Anyone have the link to that nice post that test your Haskell proficiency? (It was a one pager; tests how a rookie Haskeller would write it and progressively gets harder...)
13:58:19 <eikke> integrate disqus or something alike
13:58:33 <daniel_-> oh "throwIO e" didnt look further into what it did
13:58:35 <drewr> or consider no comments to be a desirable feature
13:58:45 <eikke> triyo: http://www.willamette.edu/~fruehr/haskell/evolution.html ?
13:59:07 <kallisti> daniel_-: it wouldn't be possible to do IO a -> IO a  without rethrowing an exception or looping infinitely
14:00:34 <triyo> eikke: Thanks, thats the one. (let's see how I do this time :))
14:01:05 <dmwit> I would like everybody to enjoy the following two illusions while they await further questions: http://dmwit.com/unimportant/bulge.jpg http://dmwit.com/unimportant/kayakflick.gif
14:01:36 <hpaste> qrt pasted “post what is not working” at http://hpaste.org/71365
14:01:41 <dmwit> Also possible: hcoop could go down at the exact moment I paste a link to #haskell.
14:02:11 <Qrt> is oleg the haskell program oleg salenko from the 1994 world cup who scored 5 goals against russia?
14:03:59 <Qrt> isnt there an alt syntax to let? main = do { let x = 5; print x } ; let is ugly :)
14:04:24 <dmwit> main = print x where { x = 5 }
14:05:15 <byorgey> dmwit: I don't get the second one.  What is illusive about it?
14:06:24 <dmwit> byorgey: Did you notice that a mountain disappears?
14:06:39 <byorgey> hahaha
14:06:40 <byorgey> nope
14:06:43 <dmwit> =D
14:07:02 <dmwit> You are a victim of change blindness. Congratulations, you're human!
14:07:24 <daniel_-> kallisti man you have saved me quite a few times now, thanks for being such a good guy :)
14:07:32 <byorgey> amazing. And now I can't NOT see it.
14:07:36 <daniel_-> it worked perfectly!
14:07:51 <Qrt> can i quit a program in main like if length args == 0 then exit
14:08:03 <daniel_-> "throwIO e `seq` return Nothing" ftw
14:08:14 <ion> Damn, i read the spoiler before seeing the link.
14:08:20 <kallisti> daniel_-: that won't actually thow anything
14:08:22 <dmwit> sorry =(
14:08:31 <daniel_-> no i dont want to throw anything
14:08:33 <kallisti> the IO action on the left-hand of seq is never executed.
14:08:38 <kallisti> daniel_-: oh. well then just omit the throwIO then
14:08:42 <kallisti> and return Nothing
14:08:45 <daniel_-> ah
14:09:05 <however> dmwit: your pictures are making my brain jumbled
14:09:15 <kallisti> (Just <$> io) `catch` (SomeException e) -> ...; return Nothing
14:09:26 <daniel_-> i just wanted to log in case there was an error and proceed with Nothing :P
14:09:35 <Qrt> sigh
14:09:40 <Qrt> i give up for the night
14:09:44 <kallisti> daniel_-: yeah the throwIO is only if you want to rethrow.
14:09:51 <kallisti> if you wrap everything in Maybe then you can return Nothing.
14:10:12 <Qrt> i added ("language", language) to the form bu still doesnt work
14:10:14 <however> daniel_-: if you're only after logging, you might want trace
14:10:16 <however> @hoogle trace
14:10:17 <lambdabot> Debug.Trace module Debug.Trace
14:10:17 <lambdabot> Debug.Trace trace :: String -> a -> a
14:10:17 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
14:10:48 <kallisti> looks like he's implementing pgrep. so it's already in IO anyway.
14:10:55 <daniel_-> but i had to supress the IOError
14:11:09 <Qrt> what do i get back if i successfully POST?
14:11:29 <kallisti> Qrt: a 4xx response of some kind.
14:11:31 <geekosaur> you might be using the wrong API.  readProcess is a convenience wrapper, there are other ways to do it that don't require you to catch an exception
14:11:37 <however> qrt: i guess "200 ok"
14:11:44 <kallisti> oh wait
14:11:46 <magikeren> Hi...I'm totally new to Haskell and wants to run http://hackage.haskell.org/package/babylon/
14:11:46 <kallisti> 2xx, my bad.
14:11:55 <magikeren> anyone who can walk me through it?
14:11:56 <kallisti> Qrt: often a redirect. or a 200 if there's no page to redirect to
14:12:37 <byorgey> magikeren: you'll want to start by installing the Haskell Platform: http://hackage.haskell.org/platform//
14:12:40 <daniel_-> geekosaur know of any other ways? except for FFI calls?
14:13:04 <daniel_-> FFI calls to something i have to write myself that is
14:13:06 <magikeren> I've installed it :)
14:13:09 <kallisti> daniel_-: he means use a different function from System.Process
14:13:19 <daniel_-> oh
14:14:12 <geekosaur> readProcess is one special case of the extremely general createProcess; there are other intermediate forms as well
14:14:19 <mchm> Quick question: I know how to define which typeclass my function belongs to. What I don't know is how to specify my function's behaviour when the input is a type from another typeclass
14:14:24 <geekosaur> and then you get an exit status instead of an exception
14:14:43 <mchm> Is it possible?
14:14:47 <geekosaur> which, for something like grep, you can probably ignore most of the time (although I'd probably check for something other than 0 or 1)
14:15:15 <geekosaur> mchm, instance TypeClass MyType where myfunc = ...
14:15:20 <geekosaur> or do you mean something else?
14:15:32 <dmwit> magikeren: You'll need to install wx (the C library). You'll probably also need to learn a little bit about cabal: the babylon package depends on both "base" and "haskell98", so it's very unlikely to work with modern GHCs.
14:15:41 <mchm> geekosaur: I haven't encountered instances yet.
14:15:42 <Qrt> 200 OK is a successful post? i got content-length 6745 so seems i pasted something big but the paste isnt showing up...?
14:15:58 <dmwit> magikeren: Luckily, it should be pretty easy to fix: specifically, use "cabal unpack" to get the source, then edit the "*.cabal" file to remove the "haskell98" dependency.
14:16:06 <geekosaur> mchm, then I suggest you keep learning
14:16:22 <dmwit> magikeren: After that, "cabal install" from within the source directory (that you've just modified) should Just Work.
14:16:24 <mchm> geekosaur: I'm writing my own factorial function, but I don't want the compiler to give me an error if I use it on a wrong type
14:16:53 <mchm> geekosaur: so you suggest I read about instances?
14:17:13 <Qrt> http://hpaste.org/71365
14:17:14 <byorgey> mchm: what DO you want the compiler to do if you use factorial on the wrong type?
14:17:24 <Qrt> ^^ what do i do wong?
14:17:50 <mchm> byorgey: at the moment, I'm using it in interactive mode, so I'd like it to print something like "Wrong type"
14:17:59 <magikeren> Dmwit...I'm totally noob here :D
14:18:06 <magikeren> I have installed Haskell
14:18:18 <byorgey> mchm: that's exactly what it already does, except it gives you a much more informative message.
14:18:23 <magikeren> (windows pc)
14:18:36 <tromp> > False  + 1
14:18:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
14:18:38 <lambdabot>    arising from the literal `1'...
14:18:39 <byorgey> mchm: anyway, what you are asking is not possible.
14:18:43 <mchm> byorgey: I know, but I want to have control over what is outputted!
14:18:47 <tromp> there's your "wrong tpye"
14:18:51 <mchm> byorgey ah, thought it was.
14:18:57 <magikeren> and have the babylon tar unpacked
14:19:06 <dmwit> Ah, wonderful.
14:19:25 <magikeren> but I don't know how to proceed
14:19:25 <daniel_-> is mvar for communicating between Parent and Child aswell?
14:19:45 <hpaste> nschoe pasted “cabal sdl-image error” at http://hpaste.org/71366
14:19:46 <dmwit> Do you see the *.cabal file?
14:19:59 <geekosaur> mchm, type errors are compile time errors
14:20:07 <magikeren> yeah...babylon.cabal
14:20:18 <geekosaur> you can;t intercept one at runtime and change the error message
14:20:19 <however> daniel_-: no, mvar works within one process as far as i know
14:20:24 <dmwit> Wonderful. You should open that up and delete the dependency on "haskell98". (Probably.)
14:20:34 <aristid> geekosaur: i think he wants something like a universal type class in which every type is
14:20:58 <aristid> for a quite silly purpose
14:21:01 <magikeren> Build-Depends:  base>= 3 && < 4, haskell98, containers, wx >= 0.11, wxcore >= 0.11, array
14:21:02 <daniel_-> in this case i was referring to threads (maybe im wrong referring to them as parent/childs)
14:21:11 <magikeren> there i should remove haskell98 right?
14:21:16 <mchm> geekosaur: ok. thanks.
14:21:18 <dmwit> Yes, and the comma after it, of course.
14:21:35 <magikeren> done that ;)
14:21:49 <dmwit> Great. Have you installed wxWidgets?
14:21:53 <magikeren> nope
14:22:01 <dmwit> http://www.wxwidgets.org/ or through your package manager if you're on *nix.
14:22:31 <magikeren> Downloading win exe file now
14:22:34 <dmwit> If the latter, be sure to get the -dev versions of the libraries, too.
14:22:35 <dmwit> Okay.
14:23:03 <nschoe> Hi everyone, I am having some difficulties installing sdl-image from cabal. I did install libsdl-image1.2 (I'm trying to do all that under Xubuntu, in a virtual machine, but the same error hapepend on my debian, on a VM too). I can cabal install sdl, but when issueing cabal install sdl-image, here is the output: http://hpaste.org/71366 . Can anyone help me please? It seems weird that the "C compiler cannot create executables" ... isn't it?
14:23:28 <dmwit> magikeren: There are (somewhat involved) instructions here: http://www.haskell.org/haskellwiki/WxHaskell/Windows
14:24:48 <magikeren> I'll try to follow those ;)
14:24:57 <geekosaur> nschoe, it's probably a bug in the haskell wrapper, it does the check wrong and reports that "cannot create executab;les" when what it really means is "you didn't install the -dev package, only the runtime libraries"
14:25:09 <dada_cetacean> I'm trying to define a function that adds together two lists element-wise, but ghci says there's something wrong with my patterns:
14:25:15 <dada_cetacean> listaddition [] [] = []
14:25:15 <dada_cetacean> ; listaddition x:xs y:ys = [x + y] ++ listaddition xs ys
14:25:23 <geekosaur> you need parentheses
14:25:27 <dmwit> dada_cetacean: Close!
14:25:33 <dmwit> dada_cetacean: Just add parentheses around the patterns.
14:25:33 <dada_cetacean> derp, thanks
14:25:34 <nschoe> geekosaur: so basically, I just have to install the libsdl-image1.2-dev ?
14:25:48 <geekosaur> and possibly some other -dev libraries, yes
14:26:03 <dmwit> configure is hard
14:26:03 * geekosaur actually had to track this down for someone a couple weeks ago, and considers it a bug in the sdl bindings
14:26:15 <geekosaur> well, a bug in its configure script
14:26:47 <nschoe> geekosaur: hum, okay. But there is smth that buggs me: when doing "cabal install sdl-image" I get a line: "checking whether C compiler works...no" but when doing "cabal install sdl-ttf" I get the very same line, only it says, "yes", and does indeed install...
14:27:13 <geekosaur> sdl-ttf uses a different configure script; I don't think it has the same bug
14:27:29 <geekosaur> sdl-image, specifically, does the wrong thing
14:28:49 <nschoe> Ho, okay. I installed the -dev lib, and it just works now.
14:28:51 <nschoe> Thanks a lot!
14:29:10 <nschoe> Saved me some head-against-the-wall-boucing ^^
14:29:18 <nschoe> As usual: #haskell is the best ;)
14:29:58 <rustycarbon> @info GlobalPackageDB
14:29:58 <lambdabot> GlobalPackageDB
14:30:32 <rustycarbon> @hoogle GlobalPackageDB
14:30:32 <lambdabot> No results found
14:31:33 <however> rustycarbon: use hayoo, it searches more packages than hoogle. also, lambdabot is available privately :)
14:31:35 <however> @where hayoo
14:31:36 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:31:59 <t7> anyone know any good tech podcasts?
14:33:44 <jamiltron> t7: I like Compucast: http://computersciencepodcast.com/
14:34:00 <t7> cheers
14:34:08 <jamiltron> Episodes vary in quality but they often have at least 1 interesting topic each episode.
14:34:28 <t7> dubstep into lol
14:47:15 <dada_cetacean> how do you construct a boolean that gives true if its input is a certain type?
14:47:27 <shachaf> Booleans don't have input.
14:47:37 <EvanR> a boolean function?
14:47:40 <shachaf> Can you give an example of what you want?
14:47:45 <dada_cetacean> sorry, a function
14:47:49 <EvanR> he wants isInteger
14:47:56 <byorgey> you can't check types at runtime.
14:48:07 <EvanR> :t typeOf
14:48:08 <lambdabot> forall a. (Typeable a) => a -> TypeRep
14:48:08 <dada_cetacean> writing something that gives the norm of a list of numbers, but having trouble with integers and ** (0.5)
14:48:12 <EvanR> ; )
14:48:18 <shachaf> EvanR: Come on. :-(
14:48:31 <shachaf> dada_cetacean: The way people tend to do it is just have that as the type of the function. Then it's guaranteed to always be True. :-)
14:48:37 <EvanR> yeah dada_cetacean just convert using fromIntegral
14:48:51 <shachaf> dada_cetacean: OK, what you want for that is definitely not that.
14:48:52 <dada_cetacean> but then what happens if I have a list of floats :(
14:48:55 <tromp> you can check some types, but you should avoid trying to do so
14:49:20 <Cale> dada_cetacean: What is the type of the function you're trying to write?
14:49:33 <shachaf> dada_cetacean: It'll be helpful to you to know exactly the types that are involved in what you're doing.
14:49:41 <dada_cetacean> just the norm of a vector
14:49:55 <shachaf> dada_cetacean: See Cale's question.
14:49:58 <EvanR> use Double everywhere
14:50:13 <shachaf> EvanR: :-(
14:50:15 <dada_cetacean> oh sorry, read type wrong
14:50:16 <however> dada_cetacean: you might be used to checks like "is this thing an integer" from other languages, but in haskell it's largely done differently (i.e. more smoothly)
14:50:32 <dada_cetacean> yeah, I was trying to splice in an "If this is an integer, do this"
14:51:06 <hpaste> listofoptions annotated “experimental parser/fun with parsec :/” with “experimental parser/fun with parsec :/ (annotation)” at http://hpaste.org/71358#a71367
14:51:15 <Cale> dada_cetacean: The way to do that is by defining a typeclass with a method whose implementation depends on the type of value you have.
14:51:15 <MostAwesomeDude> Sounds like you want a tighter constraint than Num, then.
14:52:04 <however> dada_cetacean: folks can give you more concrete advice if you post some code and describe what you want it to do (use hpaste)
14:52:23 <Cale> dada_cetacean: (you probably really don't want a class defining isInteger)
14:52:46 <shachaf> Cale: Yes, but dada_cetacean probably doesn't actually want to do that.
14:52:59 <EvanR> :t \x -> realToFrac (fromIntegral x) == x
14:53:00 <lambdabot> forall a. (Integral a, Fractional a) => a -> Bool
14:53:06 <EvanR> hm
14:53:23 <Cale> Yeah, quite possibly there's something even simpler than defining your own typeclass -- perhaps just putting in an appropriate pre-existing numerical conversion.
14:53:25 <EvanR> :t \x -> realToFrac (floor x) == x
14:53:26 <lambdabot> forall a. (RealFrac a) => a -> Bool
14:54:09 <dada_cetacean> I'm probably just using a guard incorrectly
14:55:11 <tgeeky_> never call the guards if you're red in a city (like Trinsic)
14:55:28 <EvanR> @pl \x -> realToFrac (floor x) == x
14:55:28 <lambdabot> (==) =<< realToFrac . floor
14:55:48 <EvanR> wow
14:55:57 <MostAwesomeDude> dada_cetacean: We have no way to know what your code is like unless you pastebin it.
14:56:18 <geekosaur> primitive reader monad :)
14:56:35 <tgeeky_> clearly realToFrac is a monad
14:56:42 <however> > ((==) <*> reverse) "radar" -- evanr, here's a related palindrome checker
14:56:43 <EvanR> :t (=<<)
14:56:43 <lambdabot>   True
14:56:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:57:10 <EvanR> however: cool
14:57:18 <however> > ((==) =<< reverse) "radar"
14:57:20 <lambdabot>   True
14:58:58 <EvanR> but RealFracs are a monad?
14:59:29 <MostAwesomeDude> :t realToFrac . floor
14:59:30 <lambdabot> forall b a. (Fractional b, RealFrac a) => a -> b
15:00:03 <Cale> EvanR: no
15:00:11 <however> evanr: no, functions are. (they're also Applicatives.) it's defined in Control.Monad.Instances iirc. and no, i don't know the philosophical implications either :)
15:00:11 <Cale> Functions from a fixed type are a monad
15:00:14 <MostAwesomeDude> Hm. I think it's using the Monad instance of ((->) e).
15:00:25 <however> MostAwesomeDude: yup
15:00:27 <MostAwesomeDude> however: It's the Reader monad.
15:00:43 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
15:00:46 <lambdabot>   ("hello","olleh","HELLO")
15:00:58 <Cale> ^^ that should tell you most of what you need to know about how that monad works :)
15:01:20 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
15:01:22 <lambdabot>   [5,7,10,25,32]
15:01:46 <EvanR> >>= is function application?
15:01:52 <Cale> "running" a function means applying it to the value to which the whole function has been applied
15:02:24 <Cale> So  (x >>= f) k = (let v = x k in f v k)
15:02:32 <Cale> or just f (x k) k
15:04:15 <int80_h> I'm installing haskell-platform via source. Archlinux has ghc 7.4.2 packaged. Do you think there will be a problem installing with 7.4.2 instead of 7.4.1?
15:05:24 <Cale> and return v ought to be the function that when you "run" it always results in v
15:05:39 <Cale> i.e. when you apply it to a value, it always results in v
15:05:44 <Cale> So return = const
15:06:07 <EvanR> id like to see what @pl would say without that monad
15:06:24 <Cale> @pl couldn't duplicate parameters without that monad
15:06:25 <lambdabot> couldn't duplicate parameters without that monad
15:06:27 <monochrom> I think there will be no problem, but I haven't tried. to try, --enable-unsupported-ghc-version
15:06:29 <Cale> lol
15:06:38 <dada_cetacean> here's the attempt at a euclidean norm http://pastebin.com/fLz2qWSg
15:06:40 <mauke> The paste fLz2qWSg has been copied to http://hpaste.org/71368
15:06:52 <int80_h> monochrom: thanks :)
15:07:12 <Cale> listSquare x:xs means (listSquare x) : xs
15:07:25 <Cale> function application binds more tightly than any infix operator
15:07:41 <monochrom> norm y = listSum (listSquare y) ** 0.5
15:08:09 <monochrom> it also covers the [] case
15:08:19 <EvanR> sqrt . listSum . listSquare
15:08:57 <dada_cetacean> oh. That explains it.
15:09:00 <dada_cetacean> It worked!
15:09:44 <nand`> sqrt . sum . map (^2)
15:10:02 <nand`> (for when you don't feel like reimplementing existing functions)
15:10:12 <EvanR> > square 2
15:10:13 <lambdabot>   Not in scope: `square'
15:10:18 <EvanR> fark
15:10:40 <EvanR> > let square x = x * x in square 9
15:10:42 <slack1256> In the line "instance (b ~ c, CanFilterFunc b a)" what does "~" mean?
15:10:42 <lambdabot>   81
15:10:51 <Nereid> slack1256: type equality
15:10:52 <EvanR> nand`: in his case probably (**2)
15:11:00 <dada_cetacean> nand', how are those dots supposed to parse?
15:11:07 <nand`> > let square = join (*) in square 9
15:11:08 <lambdabot>   81
15:11:26 <nand`> EvanR: 2 is a natural number, so ^ works
15:11:37 <EvanR> > 3.145 ^ 2
15:11:38 <lambdabot>   9.891025
15:11:40 <EvanR> oh
15:11:42 <nand`> :t (^)
15:11:44 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:12:01 <EvanR> > 3.145 `xor` 2
15:12:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:12:03 <lambdabot>    `Data.Bits.Bits a'
15:12:03 <lambdabot>      ...
15:12:18 <nand`> dada_cetacean: (.) is function composition
15:12:26 <nand`> dada_cetacean: (f . g) x = f (g x)
15:12:39 <slack1256> Nereid: I can't find any reference on that, it's like a synonym when a name is too long?
15:13:22 <nand`> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/equality-constraints.html slack1256
15:13:24 <Nereid> slack1256: http://www.haskell.org/ghc/docs/latest/html/users_guide/equality-constraints.html
15:13:28 <Nereid> damn
15:13:39 <Cale> slack1256: It's an extension so it'll be documented in the GHC user's guide, as people have linked already :)
15:13:39 <slack1256> thanks
15:13:49 <EvanR> (a . b . c . d . e) x == a (b (c (d (e x))))
15:14:42 <slack1256> Cale: Oh. it's an extension?. I though it was plain haskell 2010. well thanks
15:14:54 <however> that page doesn't seem to mention the extension(s) that allow you to use "~"
15:15:05 <nand`> I just had one of those moments where I realized the way I showed how (.) works is actually a valid Haskell definition for (.)
15:15:18 <nand`> and it was awesome
15:15:19 <Nereid> slack1256: it's an extension to haskell 98
15:15:47 <Nereid> does haskell '10 include type families?
15:15:55 <dmwit> no
15:16:25 <Nereid> ok then
15:16:27 <nand`> however: trying to use one will still mention the appropriate extensions to enable in the error message
15:16:59 <Cale> Haskell 2010 does not make very many changes to Haskell 98
15:17:05 <Cale> at all
15:17:27 <Cale> So usually when people say "Haskell 98" you can assume they also mean "Haskell 2010"
15:17:34 <Nereid> ok
15:17:37 <Nereid> I know nothing about it.
15:17:54 <slack1256> When it's supposed to be released the next haskell standard?
15:17:57 <Nereid> ok, now I know about it.
15:18:05 <Cale> http://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-5000
15:18:17 <Nereid> already there. ;)
15:18:41 <however> nand`: yes, but still ... seems more efficient if the writer puts it in there, instead of 100 readers firing up an editor, typing a minimal test program, opening a terminal, compiling it, noticing they made some silly typo, saving it again ...
15:19:10 <Cale> To be honest, standardisation unfortunately seems to mostly be an obstruction to language progress.
15:19:32 <nand`> however: or just typing :t undefined :: (a ~ b) => a -> b in GHCi
15:19:33 <Nereid> so is backwards compatibility
15:19:36 <nand`> however: but yeah
15:19:59 <kallisti> Cale: see: C
15:20:09 <Cale> Once you write down how things presently work, people start thinking that they're supposed to always be like that forever
15:20:21 <Nereid> I wonder what the statistics are for packages broken by ghc 7.4 due to removing the superclasses of Num.
15:20:39 <Cale> Nereid: A bunch of packages broke, but they were all easy to fix.
15:20:44 <Nereid> of course they are.
15:20:48 <Nereid> but someone needs to fix them.
15:21:07 <Cale> I just fixed them as I bumped into them.
15:21:13 <Cale> But yeah
15:21:21 <Cale> Hopefully most of the maintainers have caught up :)
15:21:36 <kallisti> Cale: I was find the preference of backwards compatability over innovation kind of odd. What's the greater cost: breaking thousands of lines of old code, or writing thousands of lines of code in the future in a unimproved language.
15:21:42 <monochrom> there are also a good number broken by haskell98 and base being mutually exclusive
15:21:44 <kallisti> s/was/always/
15:22:14 <monochrom> we just met one in this channel last night: INblobs
15:23:02 <Nereid> and I think I like the idea of the OGL package, but it hasn't been updated in years.
15:23:31 <dmwit> Heck, you don't even have to go to last night.
15:23:39 <dmwit> Just an hour ago or so somebody asked how to build babylon.
15:24:48 <Cale> The trickiest part are those hanging gardens.
15:25:10 <jamiltron> tip your waitress, etc.
15:25:43 <hpc> Cale: nowadays we give gardens the electric chair
15:26:06 * hackagebot bound 0.4 - Haskell 98/2010 Locally-Nameless Generalized de Bruijn Terms (EdwardKmett)
15:26:07 <Nereid> (no one has a clue what happened to OGL, right)
15:26:32 <Cale> I don't even remember what the difference between OGL and OpenGL was
15:26:39 <Cale> or is
15:26:49 <Cale> oh right
15:26:49 <MostAwesomeDude> One is a trademark that we're not supposed to use.
15:27:16 <Cale> The GL monad
15:27:19 <Nereid> yeah
15:27:23 <however> kallisti: there's sensible well-weighed changes, and there's gratuitous unscrupulous changes
15:27:24 <MostAwesomeDude> Wait, there's a GL monad? That's awesome.
15:27:44 <Nereid> yeah but it hasn't been maintained
15:28:00 <kallisti> however: right. I don't mean to argue in general that any kind of compatability breakage is okay.
15:28:03 <hpc> is GPipe abandoned too?
15:28:13 <Cale> I'm pretty sure GPipe is not abandoned
15:28:28 <Nereid> it was updated a couple weeks ago so no?
15:28:39 <pqmodn> is there a name for "something f g = \x -> f x (g x)"? it looks familiar.
15:28:55 <Nereid> @pl \f g x -> f x (g x)
15:28:55 <lambdabot> ap
15:28:57 <Nereid> ;)
15:29:13 <pqmodn> thanks!
15:29:32 <pqmodn> i should've recognized it... that's a cue i need to study a bit more :)
15:29:34 <Nereid> or <*>
15:30:39 <Cale> It has apparently been quite a while since GPipe's last release on Hackage, but my former coworker Gergely Patai was talking with me about working on it, as well as the LambdaCube engine.
15:32:04 <Peaker_> @type [(<*>), (=<<)]
15:32:06 <lambdabot> forall a b. [(a -> a -> b) -> (a -> a) -> a -> b]
15:33:14 <pqmodn> is (a -> b -> c) -> (a -> b) -> a -> c more general?
15:33:45 <Nereid> yes, it's called <*>
15:33:51 <Nereid> @type (<*>)
15:33:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:34:06 <Nereid> where f = (->) t
15:34:14 <pqmodn> oh, it's the reader monad, right?
15:34:19 <pqmodn> well the reader applicative i guess
15:34:28 <Nereid> every monad is an applicative
15:34:32 <parcs`> i think GPipe could do with a refactoring
15:34:37 <kallisti> pqmodn: yes.
15:34:56 <kallisti> ap and <*> are also known as the S combinator. see "SKI combinator calculus"
15:34:58 <pqmodn> ok, now i see it.
15:35:29 <Nereid> @type pure <*> pure
15:35:31 <lambdabot>     Ambiguous type variable `f' in the constraint:
15:35:31 <lambdabot>       `Applicative f'
15:35:31 <lambdabot>         arising from a use of `pure' at <interactive>:1:9-12
15:35:36 <Nereid> oh
15:36:56 <parcs`> opengl shaders are purely functional and could be modelled with as function Attributes -> (Vertex, Varying)
15:38:26 <parcs`> gpipe has a really weird representation though
15:40:04 <Peaker_> parcs`, what are these 3 things?
15:40:10 <Nereid> @type pure <*> pure :: a -> a
15:40:11 <lambdabot>     Ambiguous type variable `f' in the constraint:
15:40:11 <lambdabot>       `Applicative f'
15:40:11 <lambdabot>         arising from a use of `pure' at <interactive>:1:9-12
15:40:13 <Nereid> aw.
15:40:34 <Nereid> @type (pure :: a -> b -> a) <*> pure
15:40:35 <Peaker_> Attributes, Vertex, Varying?
15:40:36 <lambdabot>     Ambiguous type variable `f' in the constraint:
15:40:36 <lambdabot>       `Applicative f'
15:40:36 <lambdabot>         arising from a use of `pure' at <interactive>:1:26-29
15:40:37 <Nereid> I'll stop.
15:44:14 <parcs`> Peaker_: exactly what they are in opengl: attributes are variables that vary for each vertex, vertex is the position of the vertex that's being outputted and varyings are variables that get passed to the fragment shader
15:44:39 <parcs`> a fragment shader could have type 'Attributes -> Varying -> Color
15:45:13 <pqmodn> @type pure <*> (pure :: Int -> (a -> Int))
15:45:15 <lambdabot> Int -> Int
15:56:02 <cesip> so i seem a bit stuck. the current assigment is to find the max and min values in an NTree (data NTree = NilT | Node Int NTree NTree). I could easily collect all the Ints into a list and go from there, but this seems like it's too much hassle. i can't really come up with an elegant alternative
15:57:24 <Botje> cesip: how is the tree structured, is it a binary tree?
15:57:40 <cesip> yes
15:57:43 <Botje> *binary search tree
15:57:49 <cesip> uh
15:58:26 <Botje> in a binary search tree, all elements in the left subtree are smaller than the current node
15:58:31 <cesip> no
15:58:33 <Botje> and the right subtree is bigger
15:58:39 <cesip> then no
15:58:47 <shachaf> cesip: Well -- first, waht's the type of your function?
15:58:52 <Botje> uh, you just a have a tree of random values?
15:59:23 <cesip> potentially. it's not constrained at all by the assigment how the values in the tree look like
15:59:44 <cesip> shachaf: findMax :: NTree -> Int
16:00:00 <shachaf> cesip: What's findMax NilT?
16:02:07 <cesip> i was thinking maxList [], maxList being itself a recusrive function that'll give me the maximum value from a list of Ints
16:02:16 <cesip> *recursive
16:02:35 <cesip> then in findMax (Node x y z) I actually collect the values
16:02:40 <shachaf> cesip: That's a perfectly reasonable implementation and possibly the one I'd use.
16:02:45 <cesip> and apply maxList
16:02:56 <shachaf> But you asked for something recursing over the structure fo the tree directly, right?
16:03:10 <shachaf> Anyway, you still haven't answered my question. :-)
16:03:12 <cesip> exactly
16:03:25 <pqmodn> yeah, rephrased, what does maxList return for an empty list?
16:04:50 <Cale> Probably findMax NilT is an error
16:05:13 <cesip> hmmmm
16:05:17 <cesip> let me actually write it
16:05:32 <shachaf> Cale: With that type, yes.
16:05:32 <cesip> good question
16:05:48 <shachaf> Cale: My main goal is to get cesip to think about it. :-)
16:13:34 <cesip> ok
16:14:28 <cesip> shachaf: the question was spot on! :D
16:14:32 <cesip> listTree :: NTree -> [Int]
16:14:33 <cesip> listTree NilT =	[]
16:14:34 <cesip> listTree (Node x y z) =	[x] ++ listTree	y ++ listTree z
16:14:34 <cesip> maxList :: [Int] -> Int
16:14:34 <cesip> maxList = foldr1 max
16:14:34 <cesip> maxTree :: NTree -> Int
16:14:35 <cesip> maxTree = maxList . listTree
16:14:59 <cesip> the emply list still generates an error, but that could be fixed via pattern matching in maxList
16:15:40 <shachaf> cesip: No it couldn't. :-)
16:16:12 <pqmodn> if you knew the list was empty, what is the maximum element?
16:17:01 <cesip> well obviously there is none, but how am i supposed to return an Int? i would need to return a 0 in lack of an alternative, or use show to return a String overall
16:17:28 <cesip> other than that i am out of ideas : /
16:19:10 <pqmodn> yeah, now if you could change the definition of NTree you might prevent the construction of an empty tree (one solution)
16:19:44 <pqmodn> or if you could change the types of functions, you might look at "Maybe"
16:20:35 <cesip> yeah i haven't made acquaintance with Maybe yet, i'll look into it. for now and since i think this guy really wants me to work with the given type, I did this
16:21:28 <pqmodn> sure. looks like a reasonable solution to the original problem
16:22:01 <cesip> maxList :: [Int] -> String
16:22:02 <cesip> maxList [] = "There is no maximum. Read more Wittgenstein."
16:22:03 <cesip> maxList xs = show (foldr1 max xs)
16:22:08 <pqmodn> hehe
16:22:13 <EvanR> lol
17:12:47 <hpaste> ishkabible pasted “issue with Parsec” at http://hpaste.org/71374
17:13:46 <ishkabibl> when I call {parse parseNumber "" "10"} in REPL for the snippit above; it says that it expected more input
17:13:52 <ishkabibl> what's the issue?
17:14:26 <Peaker_> ishkabibl, <|> doesn't do back-tracking
17:14:37 <ishkabibl> is there a <|> with backtracking?
17:14:43 <ishkabibl> an 'or' that is
17:14:46 <Peaker_> try a <|> b
17:14:58 <Peaker_> try backtracks
17:15:06 <Peaker_> the idea is to make expensive backtracking explicit
17:15:52 <ishkabibl> 'try' backtracks; I thought you were telling me to to try that expresion :P
17:16:03 <Peaker_> heh
17:16:24 <monochrom> "try parseFloat <|> parseInt"
17:16:38 <ishkabibl> ya, I understand
17:16:50 <ishkabibl> yep; that worked
17:17:07 <ishkabibl> do you know of a way I could write this *without* backtracking?
17:18:43 <monochrom> it seems the only difference we look for is char '.' followed by many1 digit
17:18:55 <ishkabibl> can you peek in the input stream for '.'?
17:19:14 <monochrom> yes, there is some lookAhead thingie
17:19:21 <ishkabibl> hrm
17:20:33 <monochrom> hmm, lookAhead may be non-obvious to use
17:20:51 <ishkabibl> I can't find 'lookAhead'
17:21:21 <Peaker_> ishkabibl, easier to just parse an int, and then see if there's a dot immediately after
17:21:28 <Peaker_> ishkabibl, lookahead probably won't be faster
17:22:12 <ishkabibl> Peaker: how do I check if the next chracter is a '.'?
17:23:25 <Peaker_> ishkabibl, writing an example, sec
17:23:31 <ishkabibl> :)
17:24:09 <monochrom> i <- many1 digit; option (Int (read i)) (do { char '.'; f <- many1 digit; return (Float (read (i ++ "." ++ f)))})
17:25:33 <ishkabibl> the 'option' combonator accepts a default input and a new combonator?
17:25:47 <ishkabibl> that makes sense
17:26:04 <ishkabibl> it's like number -> digit+ ('.' digit+)?
17:27:43 <monochrom> yeah
17:28:10 <monochrom> depending on the rest of the code, I may or may not need a "try" around "char '.'"
17:28:57 <monochrom> oh, I know how to use lookAhead
17:29:28 <ishkabibl> the 'option' solution is perfect actully
17:30:01 <monochrom> i <- many1 digit; b <- lookAhead ((char '.' >> return True) <|> return False); if b then ... else ...
17:31:03 <monochrom> actually also c <- lookAhead anyToken; if c=='.' then ... else ...
17:31:12 * hackagebot system-fileio 0.3.9 - Consistent filesystem interaction across GHC versions (JohnMillikin)
17:34:59 <mietek> WOOP HACKAGE
17:35:10 <ishkabibl> ??
17:35:44 <geekosaur> it was down earlier
17:36:11 <mietek> ICFP contest in 10.5 hours
17:36:14 <mietek> Who's psyched?
17:36:15 <ishkabibl> that would kill me if I had been programing in haskell eariler
17:36:15 <mietek> I'm psyched.
17:36:34 <geekosaur> I threatened to submit a job app to galois just to run hackage etc. but checkened out --- I am no haskell expert etc
17:36:35 <however> anyone know what that system-fileio package is for? the description is not really clear to me
17:38:31 <geekosaur> however, it's for portability.  POSIX does one thing with pathnames, Windows another, and various broken programs (including at least one ghc release) a third.
17:38:51 <geekosaur> system-fileio mostly manages to do the right thing even with that one ghc version
17:39:03 <hpc> however: it makes the OS-specific filesystem packages combined under a single interface
17:39:23 <hpc> and fixes bugs too, heh
17:39:38 <however> hm ... so, should it be merged into the base package, in an ideal world?
17:40:57 <geekosaur> I think things are still shifting a bit, so that's not clear
17:41:15 <hpc> however: there's good technical reasons for keeping base as small as possible
17:41:18 <geekosaur> there recently appeared a bunch of POSIXly correct ByteString interfaces to things as well
17:41:26 <hpc> and base isn't going to abstract over behavior in packages that depend on it
17:42:01 <geekosaur> and, that.  base is not the place for such things; the Platform is
17:42:18 <geekosaur> base is, more or less, the stuff required for the Prelude and the runtime
17:47:56 <ishka_AFK> has anybody here used the LLVM-3.0.1 binding for haskell?
18:02:40 <Enigmagic> ishka_AFK: yes
18:22:48 <aperson_> can this be written in a non-lazy language (relatively easily?): loeb x = fmap ($ loeb x) x
18:22:50 <aperson_> my guess is no
18:23:04 <aperson_> since the only way I could make sense of it was thinking of loeb as being lazy
18:23:38 <hpc> :t let loeb x = fmap ($ loeb x) x in loeb
18:23:40 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
18:24:21 <hpc> aperson_: maybe it could work if the functor was ((->) e)
18:24:34 <hpc> same way fix works for functions but not structural recursion in lisps
18:25:10 <aperson_> the only functor I have seen it used on is lists, though I have been meaning to try and see what it does for other functors
18:25:54 <hpc> @let loeb x = fmap ($ loeb x) x
18:25:57 <lambdabot>  Defined.
18:26:00 <hpc> > loeb []
18:26:04 <lambdabot>   []
18:26:08 <hpc> > loeb [head]
18:26:13 <lambdabot>   mueval-core: Time limit exceeded
18:26:22 <hpc> > loeb [const 5]
18:26:25 <lambdabot>   [5]
18:26:29 <aperson_> > loeb [length, const 2, (!!0), (!!2) + 3]
18:26:31 <lambdabot>   [4,2,4,7]
18:26:39 <hpc> fascinating
18:26:50 <aperson_> it is awesome, right? sigfpe has a blog post about it
18:27:10 <aperson_> http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
18:27:34 <hpc> in my todo.txt
18:27:39 <aperson_> :)
18:27:47 <hpc> configuring NAS atm, but can't wait to read
18:29:41 <siracusa> > loeb [(!! 1) + 1, (!! 0) + 1]
18:29:45 <lambdabot>   [*Exception: stack overflow
18:30:04 <hpc> it occurs to me...
18:30:17 <hpc> you could define let-in syntax in terms of loeb on the [] Functor
18:30:21 <hpc> in a compiler
18:30:28 <hpc> or interpreter rather
18:31:22 <aperson_> hpc: how is that?
18:31:49 <hpc> loeb [\definitions -> defn1, \definitions -> defn2, ...]
18:43:08 <parcs`> > loeb [\[a,b] -> 0 : b, \[a,b] -> 1 : a]
18:43:12 <lambdabot>   [[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
18:51:49 <aristid> well byorgey looks like DataKinds are _not_ stable enough. found a bug in GHC, and could track it down to DataKinds, which is triggered by my code (but only when it's used in a certain way)
18:52:10 <parcs`> @type fix (flip <*>)
18:52:12 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
19:01:12 <monochrom> oohhh, netsplit
19:02:03 <aperson_> so I have read "Why Functional Programming Matters", does anyone happen to have some good "laziness use cases" from personal experience?
19:02:14 <applicative_> what does 'netsplit' mean?
19:02:47 <isomorphic> applicative: IRC is an overlay network between IRC servers.   Netsplit means the overlay network has been split
19:02:48 <hpc> applicative_: lost connection between two freenode servers
19:03:16 <popl> two or more
19:03:21 <applicative_> ah I think I see
19:03:24 <popl> :)
19:03:38 <solrize> aperson_ okasaki's book "purely functional data structures" is really good
19:03:41 <applicative_> aperson_: laziness is pretty pervasive, it's default
19:04:11 <solrize> aperson_ hamming numbers are a cute example
19:04:15 <applicative_> aperson_: so much of what is pleasing is bound up with it; speaking of a 'use case' may be the wrong way to think of it
19:04:25 <aperson_> I mainly mean things that can't be easily done with laziness. Manipulating infinite lists is one, but a lot of languages are incorporating those
19:04:31 <aperson_> I am wondering what they are missing out on
19:04:45 <aperson_> infinite, or very large, game search trees was a pretty cool example from WFPM
19:04:57 <applicative_> aperson_: for example all the fancy combinators that spare us mindless spelling out of recursive definitions
19:05:09 <solrize> aperson_ memo tries are beuatiful and horrifying at the same time :)
19:05:27 <aperson_> solrize: That book is on the todo list for when I have much more time available :)
19:06:00 <aperson_> er, easily done WITHOUT laziness
19:06:02 <aperson_> rather :)
19:06:25 <applicative_> aperson_: see the last or next to last point here and the concession of prof. harper.  this came up a couple days ago here.
19:06:57 <applicative_> uh oh cant do where more points for lazy evaluation
19:07:14 <applicative_> cant do the at in my icfp debian vm
19:07:47 <applicative> @where more points for lazy evaluation
19:07:47 <lambdabot> I know nothing about more.
19:07:54 <applicative> @google more points for lazy evaluation
19:07:55 <lambdabot> http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
19:07:55 <lambdabot> Title: Things that amuse me
19:08:14 <applicative> ^^^ excellent list of 'points' especially the last
19:08:19 <aperson_> applicative: cool, thanks
19:09:00 <applicative> aperson_: it is in response to a series of posts by Robt Harper which were also excellent, though a bit unfair
19:09:47 <applicative> or maybe  quite unfair
19:10:43 <solrize> :t union
19:10:45 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
19:11:03 <solrize> > union [1,3,6] [2,4,6,7]
19:11:05 <lambdabot>   [1,3,6,2,4,7]
19:11:46 <solrize> @where union
19:11:46 <lambdabot> I know nothing about union.
19:12:03 <solrize> > import Data.List.Ordered
19:12:04 <lambdabot>   <no location info>: parse error on input `import'
19:12:15 <however> @hoogle union
19:12:16 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
19:12:16 <lambdabot> Data.List unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:12:16 <lambdabot> Data.IntMap union :: IntMap a -> IntMap a -> IntMap a
19:12:26 <solrize> > {| import Data.List.Ordered |}
19:12:27 <lambdabot>   <no location info>: parse error on input `{'
19:13:12 <geekosaur> do what now?
19:14:41 * applicative wonders what will happen if he tries to install xmonad inside this icfp virtualbox 'appliance'
19:15:50 <randomclown> Why is it I can extract a value from MonadError while in an IO monad
19:16:04 <randomclown> but I can't so the same from the state monad
19:16:39 <shachaf> You can't "extract values from monads".
19:16:45 <c_wraith> randomclown: a state value doesn't contain a value
19:16:58 <c_wraith> a state value is instructions for turning a starting state into a final state and a result
19:17:03 <shachaf> And MonadError isn't a monad, it's a type class.
19:17:31 <solrize> http://www.haskell.org/haskellwiki/Performance/Laziness
19:17:40 <solrize> aperson_, ^^
19:18:39 <however> randomclown: you can access the state while you're inside the State monad, but not from the outside. (it's a little like a private variable in java or a similar language)
19:20:09 <mchm> Hi. I have a question concerning mkbndl installation on OSX. When I try to install it using cabal, I get an error saying "Ambiguous module name `Prelude':". Has it happened to anyone else?
19:20:38 <applicative_> what monads are you working in? ErrorT e IO a and ErrorT e (StateT s Identity) a or something randomclown
19:20:56 <applicative_> this is Haskell98/Haskell2012 or whatever
19:21:16 * hackagebot egison 2.1.14 - An Interpreter for the Programming Language Egison (SatoshiEgi)
19:21:22 <applicative_> mchm, it probably doesnt have to do with os x
19:21:29 * illissius- wonders if loeb has any connection to FRP
19:21:59 <randomclown> I'm following the "write yourself a scheme tutorial"
19:22:17 <applicative_> mchm what package did it break down on? if it hasn't been maintained various changes could be messing it up.
19:22:20 <however> mchm: wow, that's certainly interesting. run "ghc-pkg list" and see if you have the base package installed multiple times. it should be there only once
19:22:22 <mchm> applicative_: Hmm. I'm pretty sure I've set up my system correctly. mkbndl looks a bit old, doesn't it?
19:22:23 <randomclown> and on http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Error_Checking_and_Exceptions, there is this line inside the main function where he does "evaled <- return $ liftM show $ readExpr (args !! 0) >>= eval"
19:23:32 <applicative_> mchm it's not your system it's mkbundl (I think) it requires haskell98 (> 1.0)
19:23:36 <mchm> This is the full error: http://pastebin.com/Lh2B7DD2
19:23:38 <mauke> The paste Lh2B7DD2 has been copied to http://hpaste.org/71375
19:23:50 <however> mchm: ... er sorry, i misread. ignore my earlier comment. you probably just need to remove the "haskell98" thing from the mkbndl.cabal file
19:24:31 <however> (don't change the others right now -- base, directory, filepath)
19:24:38 <mchm> however: base is there only once.
19:24:49 <randomclown> it seems like he is composing a Either with the IO monad
19:24:59 <mchm> So then I have to manually install it
19:25:01 <however> you'll have to re-run "cabal configure" after you changed mkbndl.cabal
19:25:54 <however> mchm: i think you only need to do "cabal unpack mkbndl", go into the directory, and edit the mkbndl.cabal file as i suggested
19:26:06 <mchm> however: doing this right now.
19:26:11 <however> then run "cabal install" while you're still in the directory
19:27:56 <mchm> however: I'm now suggested to _add_ haskell98 to my dependencies ;)
19:28:11 <geekosaur> mchm, it;s alreadu there
19:28:40 <geekosaur> but base changed such that it cannot be used along with haskell98
19:28:56 <mchm> geekosaur: the suggestion was that haskell98 might be the cause of the problem
19:29:03 <mchm> Hmm.
19:29:05 <geekosaur> mchm, that it is
19:29:14 <applicative> mchm: https://github.com/michaelt/mkbndl.git repairs it
19:29:25 <geekosaur> because you have to use either base or haskell98, and most real programs need base
19:29:47 <applicative> however: there were some other trivia, e.g. import System
19:29:50 <however> mchm: bah. i'm not sure now. i *thought* the problem was that base and haskell98 are now mutually exclusive, and removing h98 would fix it. maybe you could put h98 back in, and remove base? i dunno
19:30:23 <however> mchm: ... and yeah, what applicative says :)
19:30:33 <geekosaur> using h98 means you lose access to a lot of libraries; I don't know how many of them you might need
19:30:36 <mchm> applicative: great. so if I just run cabal install inside the unzipped directory, will cabal move the files into another directory?
19:30:51 <applicative> remove haskell 98 from the cabal files, and Main.hs which does 'import System; import Char'
19:31:01 <applicative> yes, inside the dir do 'cabal install
19:31:03 <geekosaur> System.IO and Data.Char
19:31:16 <geekosaur> (the former is a guess but highly likely)
19:31:23 <applicative> geekosaur: in this case System.Environment (getArgs)
19:31:28 <geekosaur> ah
19:31:54 <aperson_> solrize: thanks!
19:32:02 <ishkabible> has anyone used LLVM bindings for Haskell?
19:32:29 <mchm> It's compiling.
19:32:41 <shachaf> ishkabible: I assume the answer is the same as the one Enigmagic gave you last time you asked that question. :-)
19:33:12 <shachaf> ishkabible: Given that the bindings exist, the answer is most likely yes. So if you have a more concrete question about it you should ask that, instead.
19:34:05 <ishkabible> I was afk when he said it :P; I was asking if there are any real issues with it or not
19:34:06 <mchm> Thanks a lot!
19:34:30 <ishkabible> like, are there any issues with it being 3.0 instead of 3.1
19:35:05 <ishkabible> what the caveats were
19:35:37 <applicative> mchm: there is also cabal-macosx which is similar I think (I've used it but not mkbndl)
19:36:14 <mchm> applicative: I've seen it mentioned, but can't find it anymore.
19:36:52 <mchm> my program runs fine
19:36:52 <applicative> http://hackage.haskell.org/package/cabal-macosx -- It has been revised much more recently, if nothing else
19:37:05 <applicative> mchm: just mentioning it
19:37:24 <mchm> applicative: it runs fine with a ./, but I want it to become a .app
19:37:34 <mchm> I'll take a look at cabal-macosx
19:37:44 <mchm> I especially like the "2012"
19:39:21 <applicative> yes, they're both .app-makers.   cabal-macosx has a lot of dependencies even MissingH
19:41:17 * hackagebot biophd 0.0.3 - Library for reading phd sequence files (DanFornika)
19:48:55 <mchm> <_< cabal-macosx hasn't created a symlink
19:58:15 <mchm> The Haskell wiki for OS X suggests to add ~/.cabal/bin to .profile, which is not where it installed on my system. On my computer, it should be ~/Library/Haskell/bin
19:58:49 <mchm> If anyone's up for changing the wiki - supposing I didn't do anything wrong :)
20:07:21 <applicative> mchm: there are examples in the examples directory https://github.com/gimbo/cabal-macosx for somereason they're not on hackage.
20:07:40 <applicative> uh oh
20:09:34 <applicative> @tell mchm enter https://github.com/gimbo/cabal-macosx examples/wxhello  do 'cabal configure' 'cabal build'  . the working app is inside dist/build
20:09:35 <lambdabot> Consider it noted.
20:10:34 <zzing_> What is the best data type for a stack?
20:11:53 <copumpkin> a singly linked list
20:13:08 <zzing_> Can I make a number into a monad action? So quite literally,     do { 1 }  doing something?
20:14:45 <shachaf> Yes.
20:14:52 <shachaf> But if you're asking that question, you most likely shouldn't.
20:16:33 <zzing_> What was the command for lambda bot to expand a do block?
20:19:43 <solrize> @pl do { print "hello"; print "world" }
20:19:44 <lambdabot> (line 1, column 4):
20:19:44 <lambdabot> unexpected "{"
20:19:44 <lambdabot> expecting variable, "(", operator or end of input
20:20:00 <solrize> @pl do ({ print "hello"; print "world" })
20:20:01 <lambdabot> (line 1, column 5):
20:20:01 <lambdabot> unexpected "{"
20:20:01 <lambdabot> expecting lambda abstraction or expression
20:20:02 <Lamen> zzing_: as SPJ mentioned in "tackling the awkward squad", do { e } = e; I guess do {1} is just 1
20:20:06 <solrize> oh well
20:20:12 <Lamen> > :t 1
20:20:14 <lambdabot>   <no location info>: parse error on input `:'
20:20:29 <Lamen> :type 1
20:20:37 <Lamen> (sorry ...)
20:20:43 <zzing_> Lamen, that is assuming you are in the maybe monad
20:21:00 <solrize> > do { 1 }
20:21:01 <lambdabot>   1
20:21:03 <parcs`> > do 1
20:21:05 <lambdabot>   1
20:21:06 <parcs`> > do do do1
20:21:07 <lambdabot>   Not in scope: `do1'
20:21:48 <Lamen> zzing_: no"just 1" is not Just 1
20:21:57 <zzing_> I am in the mood to mess with things and see what I come up with
20:22:08 <Lamen> "Just" is a constructor
20:22:21 <Lamen> "just"  well, is "just" itself
20:22:33 <Lamen> (tested locally)
20:22:35 <zzing_> @src just
20:22:36 <lambdabot> Source not found.
20:22:41 <Lamen> do {1} :: Num a => a
20:22:45 <Lamen> 1 :: Num a => a
20:23:00 <otters> :t do { 1 }
20:23:02 <lambdabot> forall t. (Num t) => t
20:23:10 <otters> huh
20:23:21 <Lamen> take2
20:23:24 <Lamen> :t 1
20:23:26 <lambdabot> forall t. (Num t) => t
20:23:39 <Lamen> (great :D)
20:23:49 <otters> :t (1 .)
20:23:51 <lambdabot> forall a b (f :: * -> *). (Num b, Functor f) => f a -> f b
20:23:56 <Eduard_Munteanu> zzing_: @undo
20:24:03 <otters> @undo do { 1 }
20:24:03 <lambdabot> 1
20:24:11 <otters> @undo do { 1; 2 }
20:24:12 <lambdabot> 1 >> 2
20:24:33 <zachk> > 1 . 2 . 3
20:24:35 <lambdabot>   No instance for (GHC.Show.Show (f b))
20:24:35 <lambdabot>    arising from a use of `M4646911235...
20:24:38 <zachk> :(
20:24:41 <Lamen> ah, there's even an '@undo' command :)
20:24:51 <solrize> > fix error
20:24:53 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
20:25:39 <deech> Hi all, I recently started doing Scala development and noticed that if I reload a file and it errors the old definitions are left around. Is there some reason GHCI doesn't do this?
20:25:40 <Eduard_Munteanu> > 1 . 2 . 3 $ 4
20:25:43 <lambdabot>   1
20:26:37 <zzing_> Is it possible to have a monad where >>= doesn't make sense?
20:27:10 <geekosaur> deech, there is a reason, just not one you'd like much.  (messes with type inference too much, essentially.)
20:27:11 <otters> define doesn't make sense
20:27:54 <zzing_> Is something like do { action; action; action } the same as action >> action >> action?
20:28:06 <geekosaur> you can define a monad whose (>>=) doesn't obey the laws.  it will behave oddly and using do motation with it will probably break in amusing ways
20:28:14 <Eduard_Munteanu> @undo do { action; action; action }
20:28:14 <lambdabot> action >> action >> action
20:28:58 <zzing_> @undo do { 1; 2; add }
20:28:59 <lambdabot> 1 >> 2 >> add
20:29:08 <deech> geekosaur: can you elaborate or point me to some references? I'm interested in how type inference interferes with loading something in the REPL.
20:29:26 <otters> @instances Num
20:29:27 <lambdabot> Double, Float, Int, Integer
20:29:29 <Eduard_Munteanu> @undo do { y <- f x; g y }
20:29:30 <lambdabot> f x >>= \ y -> g y
20:30:07 <hpaste> applicative pasted “MonadEvil” at http://hpaste.org/71376
20:30:16 <zzing_> @undo do { action }
20:30:17 <lambdabot> action
20:30:24 <geekosaur> deech, the problem is with reloading without resetting.  I would suggest thinking about it except that's why you're asking presumably...
20:30:33 <applicative> zzing_: I answer both questions at once ^^^
20:31:30 <geekosaur> reload when types change, what do you do when the types of the stuff you didn't throw out changes? you retain full source and reinterpret it?  what happens when that reinterpretation fails?
20:32:13 <zzing_> I have been thinking about a 'forth' monad. But it appears to be me in too tired of state to think about how it would work.
20:33:25 <zzing_> something like do {1 } I would expect to push 1 onto a stack. But it doesn't seem to make too much sense to me what would end up doing the push
20:34:35 <deech> geekosaur: I see, thanks for the explanation.
20:34:38 <geekosaur> deech, in any case, some of this comes down to what ghc is designed to do; it's not arbitrarily flexible
20:35:12 <ryan__> here's a stupid newb question: I want to make a simple function that prompts the user for any input, and then binds it to a variabl, and returns that variable for use by another function
20:35:24 <geekosaur> and its type engine can be made to go weird just by abusing ghc-api in certain ways (if I interpret some of the questuons to the ghc list correctly) so doing similar things in ghci would also derange it
20:35:52 <ryan__> here's what I got so far:
20:36:10 <geekosaur> zzing_, that sounds to me like something that is an instamce of both Num and Monad, abusing the numeric literals fromIntegral stuff
20:36:25 <ryan__> funk = do x <- getLine
20:36:36 <ryan__> y <- readIO x
20:36:48 <ryan__> return y
20:36:58 <ryan__> funk :: Read a => IO a
20:37:05 <hpaste> applicative annotated “MonadEvil” with “MonadEvil (annotation)” at http://hpaste.org/71376#a71378
20:37:12 <ryan__> obviously it don't work
20:37:21 <applicative> zzing_: ^^^ more debauchery of a similar nature
20:37:23 <geekosaur> "y <- readIO x; return y" is just "readIO x"
20:37:45 <ryan__> right, which i can't do anything with yet so that was a deadend
20:38:32 <ryan__> even a simple program like this would really help
20:38:42 <ryan__> me
20:38:49 <geekosaur> so what "don't work" about it?  it looks reasonable insofar as what it actually does; I imagine that's not what you expect though and you get type errors trying to use it
20:38:58 <ryan__> ya
20:39:12 <ryan__> like I said im a newb
20:40:50 <ryan__> sigh, I'm sure once the world figures out how to do the most basic program in the world (IO) Haskell will catch on...
20:41:54 <zzing_> applicative_, I am not sure who that evil $ do thing works
20:42:36 <ryan__> I mean, newbs like me don't need to understand how it works, we just want a simple way to prompt for a string and return a variable-bound string
20:43:36 <dmwit> I don't understand this latest "lambda-case" thread. Yes, "case of" is clearly better than "\case of"... but nobody was proposing "\case of" to begin with!
20:43:48 <applicative> zzing_: the do block defined an Evil a for any a; an Evil a is a wrapped list of integers; so evil $ do ... gives you the list of integers
20:44:16 <dmwit> ryan__: Why does that obviously not work?
20:44:21 <dmwit> ryan__: That looks like it works fine to me.
20:44:41 <geekosaur> dmwit, \case of was a hijack/bikeshed
20:44:51 <ryan__> parse error on unput <-
20:45:01 <geekosaur> stupid one in my opinion, but..,
20:45:04 <ryan__> *input
20:45:26 <dmwit> ryan__: You probably just screwed up the indentation.
20:45:35 <dmwit> ryan__: Make sure the "y" and "return" line up with the "x" on the first line.
20:45:40 <ryan__> that would be awesome
20:45:42 <ryan__> lol
20:46:42 <ryan__> no, tried that, same error
20:46:55 <dmwit> Well, it works when I type it into my file.
20:47:02 <dmwit> Maybe you'd better paste your exact file (and error).
20:47:03 <dmwit> ?hpaste
20:47:03 <lambdabot> Haskell pastebin: http://hpaste.org/
20:48:05 <applicative> zzing_: similarly in the other one "unlist printUsage2" extracts the list of strings from a "List" do-block
20:48:46 <ryan__> ok, ill start on that...
20:50:02 <hpaste> ryan__ pasted “zo” at http://hpaste.org/71380
20:50:51 <ryan__> thx btw
20:51:47 <hpaste> ryan__ pasted “zo error” at http://hpaste.org/71381
20:52:32 <applicative> ryan__: you forgot the 'do'
20:53:11 <zzing_> thank you all, I must die for eight hours now
20:53:45 <applicative> ryan you can also write this as "fmap read getLine", no?
20:54:07 <ryan__> true, thx but now it's 'parse error on input y'
20:54:35 <dmwit> ryan__: Did you line up the things I told you to line up?
20:54:37 <hpaste> applicative annotated “zo” with “zo (annotation)” at http://hpaste.org/71380#a71382
20:54:40 <ryan__> applicative: I wouldn't know
20:54:54 <ryan__> I'll try it thouigh...
20:55:12 <applicative> its presumably spacing as dmwit says
20:55:17 <ryan__> dmwit: ya
20:55:17 <dmwit> applicative: No, you can't write it that way.
20:55:24 <dmwit> applicative: readIO does exceptions more differently
20:55:32 <dmwit> applicative: But you can write it "readLn". =)
20:56:08 <dmwit> ryan__: You know the drill. Paste the exact file you're trying and the exact error.
20:56:13 <applicative> ah I dont know readIO
20:57:11 <zachk> oooo my finally found something I have been looking for, for quite a few moons, cabal install ansi-terminal, Syste.Console.ANSI yaaaay
20:57:14 <hpaste> ryan__ pasted “zo error2” at http://hpaste.org/71383
20:57:52 <dmwit> ryan__: Did you delete the type annotation for some reason?
20:57:56 <hpaste> ryan__ pasted “zo error2a” at http://hpaste.org/71384
20:57:56 <geekosaur> readIO is just what it says, it makes parse errors trappable as IO exceptions (hence with Prelude's catch)
20:58:45 <dmwit> ryan__: Can not reproduce. That file compiles perfectly fine here.
20:58:56 <dmwit> Perhaps you forgot to save...?
20:59:02 <ryan__> lol, alas no
20:59:17 <dmwit> Or are opening a different file than the one you think you're opening...?
20:59:20 <ryan__> hmm, let me try it with nano or emacs
20:59:25 <applicative> geekosaur: my Prelude doest export catch anymore
20:59:44 <ryan__> no, it's the only one in my path names test.hs
20:59:49 <applicative> geekosaur: get ready for ghc 7.6 i guess
21:04:01 <hpaste> applicative annotated “zo” with “zo now with improve exception handling” at http://hpaste.org/71380#a71385
21:04:32 <solrize> http://queue.acm.org/detail.cfm?id=1454466   interesting looking article about why STM is slow
21:04:58 <applicative> geekosaur dmwit okay, I made proper use of readIO
21:09:50 <ryan__> sigh no luck, oh well I'll continue tomorrow, thanks for trying
22:42:06 <shachaf> http://www.yesodweb.com/blog/2012/07/classy-prelude doesn't really make me confident in Yesod...
22:43:05 <stepcut> shachaf: :)
22:43:55 <stepcut> shachaf: in my opinion.. classy-prelude is very much in line with yesod thinking.. whether you think that is a good or bad thing is up to you
22:57:03 <shachaf> Ugh, mjrosenb just doesn't know when to stop.
22:57:14 <shachaf> It's just annoying at this point.
22:57:47 <Axman6> hmm?
22:58:26 <shachaf> Axman6: He's crazy.
22:58:41 <Axman6> what makes you say that? and who is he?
22:59:03 <shachaf> ...Now he's not going to say anything, and leave me looking like I say bad things about people for no reason.
22:59:35 <shachaf> Axman6: You should ask him!
22:59:46 * Axman6 has no context >____<
23:40:52 <wiz> How unique is UUIDv4? How many items i can generate/store before i should worry about collisions?
23:41:23 * hackagebot dns 0.3.4 - DNS library in Haskell (KazuYamamoto)
23:41:33 <shachaf> As many as you like?
23:41:58 <shachaf> > 2^64
23:41:59 <lambdabot>   18446744073709551616
23:42:08 <shachaf> It's probably less than 2^64 in practice, but still.
23:44:59 <solrize> wiz uuid4 is supposed to be 128 bit random  collision probability is what, exp(-n/2**128) or sth like that
23:45:17 <solrize> exp(-n**2/2**128) i meant
23:45:28 <solrize> that can't be right
23:45:53 <wiz> > (128 ^ 2) / (2 ^ 128)
23:45:54 <lambdabot>   4.81482486096809e-35
23:46:00 <solrize> no that's wrong just a sec
23:46:53 <solrize> probability of no collision is that
23:46:58 <solrize> i may still be off
23:47:18 <wiz> Hmm.. I've run a scotty (wai/warp wrapper) and found that it's still using 2gb of memory and 30% cpu. How to find the issue?
23:47:38 <solrize> anyway thing is that at 2**64 it's about exp(-0.5) or 60% likely you get a collision
23:47:43 <solrize> so you have to start worrying at lower numbers
23:47:56 <solrize> wiz, profile
23:49:00 <wiz> will it point the exact location of the offender?
23:51:39 <Taneb> Is there anything that [Char] is better at than both Text and ByteString?
23:52:22 <otters> not being a dependency
23:52:58 <Taneb> Could you explain what you mean by that? It's quite early, and my brain hasn't caught up with my curiosity yet
23:53:14 <Cale> Taneb: String is in the Prelude
23:53:19 <Taneb> Oh yes.
23:53:22 <Taneb> Is that it?
23:53:37 <Cale> You can apply arbitrary list functions to [Char]
23:53:46 <wiz> Taneb, you can pattern match to [Char]
23:53:53 <Taneb> Heh, yes
23:53:55 <Taneb> Of course
23:54:00 <Taneb> Thanks, otters, Cale, wiz
23:54:02 <wiz> It's more like a control structure than a container.
23:54:37 <Cale> > let f '*' = "* *"; f ' ' = "   " in "*" >>= f >>= f >>= f
23:54:39 <lambdabot>   "* *   * *         * *   * *"
23:55:18 <Taneb> L-systems?
23:55:23 <Nereid> haha cool.
23:55:24 <Cale> Yeah
23:55:30 <Taneb> Cool
23:55:32 <Cale> more or less :)
23:55:32 <Taneb> Sweet
23:55:34 <plat0> Cale is making a Cantor set.
23:55:38 <Taneb> Other adjectives in that regard
23:56:16 <Cale> Since ByteString and Text don't have the list monad as part of their structure, that would be a little more work to do with them.
23:56:44 <Cale> (but not much more, they do have concat and map)
23:57:02 <Cale> Or, I think they have map... does Text have a map function?
23:57:18 <wiz>  > let f '*' = "* *"; f ' ' = "   " in "*" >>= f >>= f >>= f >>= f >>= f
23:57:29 <Taneb> > let f ' ' = " *"; f '*' = "* " in f ' ' >>= f >>= f >>= f >>= f
23:57:31 <lambdabot>   " ** *  **  * ** *  * **  ** *  *"
23:57:32 <Cale> yes, it does
23:57:55 <otters> > let f ' ' = " *"; f '*' = "* " in f ' '
23:57:57 <lambdabot>   " *"
23:58:05 <kizzo> When you do a 'show' on whatever is returned by "Physics.ODE.Body.getMass b" (for some body b), this is shown: 0xb6ffc850
23:58:10 <Taneb> Thue-Morse sequence
23:58:15 <Martin_Vetter> Hi. I've never used Haskell before and I really need to run http://hackage.haskell.org/package/babylon/
23:58:24 <Martin_Vetter> anyone who can help a noob :D
23:58:30 <kizzo> The problem, is that I don't know what to do with that - I was expecting a Float or something.
23:58:38 <kizzo> http://ode-wiki.org/wiki/index.php?title=Manual:_All&printable=yes#Mass_functions
23:58:41 <Taneb> Martin_Vetter, have you installed GHC?
23:58:42 <shachaf> Martin_Vetter: People will be more able to help you if you ask a question.
23:58:54 <kizzo> http://hackage.haskell.org/packages/archive/HODE/2008.10.27/doc/html/Physics-ODE-Types.html#t:Mass
23:59:01 <Martin_Vetter> I have installed Haskell :)
23:59:12 <Cale> That package has a dependency on a really old version of base
23:59:17 <Taneb> Okay, open a command line thingy, Martin_Vetter
23:59:27 <Taneb> And type "cabal install babylon"
23:59:38 <Cale> and it depends on the haskell98 package at the same time
23:59:48 <Cale> which is now mutually exclusive with base
23:59:54 <Taneb> Odd
