00:06:40 * hackagebot lens 0.8 - Families of Lenses, Folds and Traversals (EdwardKmett)
00:10:30 <startling> wow, burning through minor versions pretty quickly
00:11:32 <shachaf> It's not as if 0.9 + 0.1 = 1.0
00:11:40 <shachaf> 0.9 + 0.1 = 0.10, no problem.
00:13:35 <tensorpudding> because it's not decimals, it's some strange positional system
00:14:10 <tdammers> nothing strange about it
00:14:19 <startling> oh, right
00:14:46 <tdammers> only that using a dot as a separator is a bit confusing for those of us who are used to using it as a decimal point
00:14:47 <startling> that always bugged me, though. feels like we should have the prescience to start off with 0.01
00:15:36 <tdammers> and then what happens when you hit minor version 100? Same problem. We should start of with 0.(enough zeroes)1
00:15:58 <startling> tdammers, exactly!
00:16:23 <tdammers> where "enough zeroes" is, say, so many zeroes that you'd have to produce a new minor version every second until the end of our solar system to exhaust them
00:16:26 <startling> version 1 minus point-nine repeating
00:16:28 <tdammers> something like that
00:17:05 <donri> i have a package that's at version 7351
00:17:06 <nexx> I try to use hakyll on windows. When I compile the blog examples I get this error: _site\index.html: commitBuffer: invalid argument (invalid character). This solution https://github.com/jaspervdj/hakyll/issues/71 does not work for me. Has someone an idea how to fix it?
00:17:33 <hov> site/index.html?
00:17:43 <hov> *_site/index.html
00:18:06 <hov> does that work?
00:19:34 <quintessence`> edwardk: is your "bound" talk online by any chance?
00:19:49 <edwardk> quintessence`: not yet. i have the video on my ipad though
00:20:01 <edwardk> the slides are online if you want them
00:20:24 <quintessence`> great!
00:20:34 <nexx> uhm. I'm not sure where to add that. This ist the full output http://pastebin.com/g69zWYYn
00:20:36 <mauke> The paste g69zWYYn has been copied to http://hpaste.org/72246
00:20:40 <nexx> @ hov
00:21:16 <edwardk> http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less
00:22:22 <nexx> This is the example https://github.com/jaspervdj/hakyll-examples/tree/58697bddec8e1483a62a00ddd0009c63fe393546/tagblog
00:22:33 <nexx> I renamed hakyll.hs to site.hs
00:22:38 <levi> Version numbers for TeX and Metafont are increasingly accurate approximations of pi and e, respectively.
00:22:39 <hov> ah
00:23:00 <startling> levi: ha, awesome
00:23:24 <levi> Each version adds a new digit to the end
00:24:55 <nexx> The problem occures when hakyll processes "&hellip;" in the template
00:26:05 <hov> and it doesnt when it is removed?
00:27:05 <nexx> yes. But then it stucks at site.exe: _site\tags/antonius.html: commitBuffer: invalid argument (invalid character)
00:28:38 <hov> it must be the \ in the filepath, perhaps hes using some sort of operator which outputs \ on windows and / on other OSes
00:29:24 <tdammers>  / as a path separator works fine on windows
00:30:00 <hov> yes, but it probably doesnt when combined with \
00:30:09 <tdammers> you reckon?
00:30:27 <hov> yes
00:30:30 <nexx> It does. It start generating the antonius.html file
00:30:44 <tdammers> (stupid me... I just switched to a different workspace to try it out in Windows Explorer, just to realize that I am not on Windows)
00:31:28 <Franciman> hi all
00:31:56 <hov> hi
00:33:19 <nexx> It seems it is about a limitation of Haskell: https://github.com/jgoerzen/twidge/issues/36
00:34:05 <Franciman> guys, I want to implement a stream processor that acts differently according to the element it encounters on the stream
00:34:24 <Franciman> what's the most "functional" and elegant way, to you, in order to implement this in haskell?
00:35:42 <shachaf> That depends on a lot of things, like what "acts" means and what you're actually doing.
00:37:05 <Franciman> an example that comes in mind is like a lexer
00:37:16 <Franciman> *something like
00:39:13 <Franciman> *in my mind
00:39:50 <Franciman> shachaf, it's basically a lexer. Any ideas?
00:40:23 <TEttinger> woah Franciman.  Cheating on Falcon? :-)
00:40:45 <Franciman> TEttinger nope don't worry lol
00:40:53 <TEttinger> zippers sound familiar...
00:41:22 <shachaf> Franciman: Ideas on how to write a lexer in Haskell?
00:41:30 <Franciman> yes lol
00:41:30 <shachaf> That's a kind of vague question.
00:41:36 <shachaf> People have certainly done it before.
00:41:38 <TEttinger> https://en.wikipedia.org/wiki/Zipper_%28data_structure%29
00:41:40 <shachaf> Maybe you can look at one of those.
00:42:42 <Franciman> shachaf no that was an example, i just want a polymorphic stream processor
00:43:24 <shachaf> You keep saying that. I still don't really know what you mean.
00:43:31 <shachaf> @ty map (+1) -- polymorphic stream processor!
00:43:32 <lambdabot> forall a. (Num a) => [a] -> [a]
00:43:53 <quintessence`> Franciman: you mean something like `newtype SP a b = SP (a -> (b, SP a b))`?
00:44:34 <Franciman> yes, but the function into SP has to change according to the input it gets
00:45:19 <quintessence`> that returns a new function along with the output, to be applied to the next input
00:45:38 <quintessence`> or do you mean you want the types to change?
00:46:14 <Franciman> an example of this?
00:46:41 * hackagebot Command 0.0.5 - A replacement for System.Exit and System.Process (TonyMorris)
00:49:19 <Franciman> hmm sorry wrong chat, quintessence` that's great
00:56:41 * hackagebot Command 0.0.6 - A replacement for System.Exit and System.Process (TonyMorris)
01:03:39 <hov> could somebody explain how its possible that when i 'cabal install ixset' it says 'All the requested packages are already installed: ixset-1.0.5', while when i enter 'cabal info ixset' it spits out 'Versions installed: [ Not installed ]'?
01:05:40 <Franciman> quintessence`, so now it's just a matter of few case expressions or do you now any other better way?
01:05:45 <donri> hov: try wiping ~/.cabal and ~/.ghc :P
01:07:45 <Ralith> Franciman: you may be interested in Conduits
01:07:53 <Ralith> which is a complete lib for streams and similar things
01:08:19 <Franciman> Ralith, ok thank you
01:08:49 <Ralith> Franciman: http://hackage.haskell.org/packages/archive/conduit/0.5.2.2/doc/html/Data-Conduit.html
01:10:17 <hov> donri: should i simply delete those directores?
01:10:24 <Enigmagic> hov: run 'ghc-pkg list ixset'
01:10:54 <donri> hov: or rename them so you have them backed up if you want
01:10:56 <Franciman> thanks again
01:11:07 <shachaf> donri: Isn't that a bit extreme?
01:11:15 <donri> probably.
01:11:25 <donri> i just don't want to be held responsible later ;)
01:11:31 <hpaste> quintessence pasted “Stream Processors” at http://hpaste.org/72248
01:11:46 <hov> ghc-pkg list ixset gives "/var/lib/ghc/package.conf.d; /home/hov/.ghc/x86_64-linux-7.4.1/package.conf.d"
01:11:53 <donri> or did you mean that wiping those dirs itself would be extreme?
01:12:03 <donri> because hov's package db seems majorly effed up
01:12:45 <Enigmagic> hov: ok... does 'find /home/hov/.ghc/x86_64-linux-7.4.1/package.conf.d -name "ixset*"' find anything?
01:12:55 <hov> what would be the best way to reinstall all the packages? i.e. start with a clean slate
01:13:11 <k0ral> say you work with 2 monad transformers T1 and T2 over IO in your program, sometimes you define functions that are of type T1 IO (), others that are T2 IO (), and yet other that are T1 (T2 IO) (); is it better to lift all those functions to T1 (T2 IO) () in their definition, or to lift them up each time you call them ?
01:13:38 <donri> hov: is it important to reinstall them all at once?
01:13:39 <shachaf> It's probably better to pick one monad and stick with it.
01:14:02 <donri> you can have any monad you want, as long as it's a... ford?
01:14:07 <hov> Enigmagic: it doesnt return anything
01:14:20 <shachaf> Or make your functions polymorphic, wherever you can.
01:14:26 <k0ral> so you say I should lift some functions that are simple IO () into T1 (T2 IO) () even if they do not need T1 either T2 to work ?
01:14:28 <Enigmagic> k0ral: you can lift multiple calls togther... lift { do func1; func2; func3; etc }
01:14:32 <hov> donri: no that's not really important
01:14:59 <k0ral> Enigmagic: right, but in my code, I end up lifting every single line differently because they all have different signatures
01:15:00 <donri> hov: so if you (re)move those dirs you could do cabal update && cabal install ixset, etc
01:15:04 <k0ral> Enigmagic: it's quite ugly
01:15:17 <Enigmagic> hov: well that's odd. i'd try running "sudo ghc-pkg recache --global; ghc-pkg recache --user;"
01:15:17 <hov> ok, ill try that then
01:15:26 <StringlyTyped> k0ral: I have found that, most of the time, my functions depend on monads being "composed" using certain monad transformers, but they do not depend on the exact order these monad transformers were stacked one upon another.
01:15:42 <quintessence`> k0ral: you can also use the MonadX typeclasses and give things types like (MonadState m, MonadIO m) => m blah
01:16:19 <k0ral> StringlyTyped: so ?
01:16:25 <quintessence`> * MonadState SomeStateType m
01:16:35 <StringlyTyped> k0ral: So you end up having something like what quintessence` said.
01:16:39 <hov> Enigmagic: ive already tried that, didnt help
01:17:33 <Enigmagic> hov: hum... you might have a look at the results from "cabal install -v2 ixset" or maybe -v3 before nuking stuff
01:17:40 <k0ral> quintessence`: I already have made T1 instance of MonadIO, yet I still need to prefix bare IO with liftIO just everywhere, how does that help ?!
01:17:53 <Enigmagic> unless you enjoy rebuilding/upgrading packages..
01:18:58 <hov> Enigmagic: ive already nuked .ghc .cabal but i backed them up
01:19:00 <quintessence> k0ral: if your functions don't mention a specific monad, you can use ones that require T1 IO, T2 IO and T1 (T2 IO) in the same do-block without any lifts
01:19:45 <k0ral> quintessence: O_o that's my dream, but I never figured out how to reach it
01:20:28 <quintessence> you still have to lift things that are IO a into MonadIO m => m a manually though
01:21:18 <k0ral> @hoogle MonadIO
01:21:19 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
01:21:19 <lambdabot> package monadIO
01:36:04 <k0ral> would you have an example piece of code using MonadIO specifically to avoid the use of lifts ?
01:36:42 * hackagebot couchdb-conduit 0.10.0 - Couch DB client library using http-conduit and aeson (AlexanderDorofeev)
01:36:44 <fmap> you can't avoid liftIO
01:37:38 <donri> well you can "lift" to IO via MonadTrans too
01:38:12 <hov> Enigmagic: your approach worked for ixset, thanks ;), however a new problem has arisen: ghci cant find Text.Blaze even though it is installed. i have tried restarting ghci, cabal install --reinstall blaze-html #(--force-reinstalls) for dependent packages
01:38:57 <k0ral> fmap: I want to avoid all other kind of lifts that I actually use to transform T1 IO () into T1 (T2 IO) (), or T2 IO () into T1 (T2 IO) ()
01:40:12 <k0ral> here I have 2 combinations, but say I have n stacked monads, I would have a great number of lift combinations to manage just to get into my most global monad
01:40:37 <k0ral> I just don't want my code to be full of ugly lifts everywhere
01:41:37 <Enigmagic> k0ral: for arbitrary base monads you can look at MonadBase: http://hackage.haskell.org/packages/archive/transformers-base/0.4.1/doc/html/Control-Monad-Base.html
01:41:42 * hackagebot fay 0.2.2.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
01:42:19 <Enigmagic> hov: do you have multiple versions of ghc installed?
01:42:45 <hov> not as far as i know - just v7.4.1
01:43:37 <fmap> k0ral: are you using mtl transformers and T1 ≠ T2?
01:44:43 <fmap> I don't see where you need lifts (except for IO) if it's so.
01:45:06 <Enigmagic> hov: seems very odd. ghc/cabal just look at the package databases... there are typically two, one user and one global.
01:45:42 <Enigmagic> hov: are you installing via cabal-install or also mixing in Setup.hs?
01:45:53 <hov> if it is of any help, im on debian sid
01:46:00 <hov> just cabal-install
01:46:14 <k0ral> fmap: I'm using EitherT and ReaderT
01:46:56 <startling> hi, do you know an "a -> [a -> b] -> [b]" function?
01:47:04 <Enigmagic> hov: well try reinstalling blaze-html with -v2 and check to see where it's writing the package confs
01:47:12 <hov> sequence?
01:47:16 <hov> flip sequence*
01:47:21 <hov> ok
01:47:21 <startling> :t sequence
01:47:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:47:49 <startling> hov, I don't think that's what I want?
01:48:37 <hov> :t flip sequence [odd, even]
01:48:38 <lambdabot> forall a a1. (Integral a1) => [[a1 -> Bool] -> a] -> [a]
01:48:51 <k0ral> fmap: sometimes I have ReaderT actions, I want to lift them into EitherT E (ReaderT ...) ()
01:48:52 <hov> :t sequence [odd,even]
01:48:54 <lambdabot> forall a. (Integral a) => a -> [Bool]
01:48:57 <Enigmagic> f a xs = map ($ a) xs
01:49:00 <k0ral> fmap: I have to write EitherT $ Right <$> f
01:49:06 <k0ral> fmap: that is ugly
01:49:39 <startling> hov: oh, weird. is that because of the list monad, then?
01:49:53 <hov> yes
01:50:01 <startling> :t ((<*>) . (:[]))
01:50:01 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:50:17 <startling> oh heh, that's fmap
01:50:20 <k0ral> fmap: the other way around, I have EitherT E (), I want EitherT E (ReaderT ...) (), I have to write liftEitherT liftIO f
01:50:28 <k0ral> fmap: that is also ugly
01:50:33 <startling> hov: thanks!
01:50:45 <hov> startling: youre welcome
01:51:51 <fmap> k0ral: I assume EitherT is from either package?
01:52:52 <k0ral> fmap: actually from Control.Error, but I believe it exports the either package
01:52:59 <fmap> seems there is no MonadReader for EitherT and no "MonadEither" for ReaderT, hm
01:54:22 <fmap> Control.Error?
01:55:47 <k0ral> package errors
01:56:11 <k0ral> it was uploaded on 7jul
01:56:16 <k0ral> for the first time I mean
01:57:48 <quintessence> oh, that package is using transformers and not mtl
01:58:15 <k0ral> is that bad ?
01:58:56 <fmap> I don't think you can avoid lifts
01:59:00 <quintessence> mtl is the one with the nice typeclasses for everything
02:00:05 <k0ral> quintessence, fmap: I really want to understand how to do it without lifts (except liftIO), so if it means not using errors package, I'm fine
02:00:25 <k0ral> should I contact the maintainer so that he switches from transformers to mtl ?
02:01:09 <dobblego> what's the deal with transformers vs mtl?
02:01:36 <quintessence> I think Tekmo has philsophical objections to the profusion of typeclasses in mtl, but it wouldn't hurt to ask
02:01:43 * hackagebot Command 0.0.7 - A replacement for System.Exit and System.Process (TonyMorris)
02:02:38 <quintessence> k0ral: http://stackoverflow.com/questions/9054731/avoiding-lift-with-monad-transformers is a (not too detailed) description; there was a really great blog post tutorial but I can't find it now
02:03:05 <k0ral> quintessence: thank you, I'm reading it right now
02:03:14 <hov> :t (+ 1) >>= (+)
02:03:15 <lambdabot> forall a. (Num a) => a -> a
02:03:24 <hov> (+ 1) >>= (+) $ 1
02:03:35 <hov> > (+ 1) >>= (+) $ 1
02:03:36 <lambdabot>   3
02:06:05 <k0ral> just a side question: why aren't all IO functions like putStrLn, writeFile and so, written with MonadIO rather than an explicit IO ? Wouldn't that remove the need of using liftIO everywhere ?
02:08:10 <quintessence> well, the IO monad predates monad transfomers
02:08:53 <quintessence> and mtl uses some language extensions (fundeps at least)
02:09:12 <latro`a> mtl has a ton of extensions in certain modules
02:09:26 <latro`a> there's UndecidableInstances in a bunch of places iirc
02:10:59 <k0ral> quintessence: I don't get what you mean by "predates"
02:11:10 <latro`a> the IO monad goes back to haskell 98
02:11:20 <latro`a> mtl is considerably more recent, and isn't valid code in haskell 9
02:11:22 <latro`a> *98
02:11:43 * hackagebot couchdb-conduit 0.10.1 - Couch DB client library using http-conduit and aeson (AlexanderDorofeev)
02:12:27 <k0ral> is anyone planning to rewrite the IO monad with recent concepts as monad transformers ?
02:12:37 <latro`a> very, very unlikely
02:12:52 <latro`a> for one thing the IO monad is pretty intimately linked with the runtime system
02:13:28 <quintessence> someone could make a package that just exports a bunch of things pre-lifted
02:13:37 <latro`a> true
02:13:48 <latro`a> but the IO monad as we know it now isn't going anywhere
02:14:21 <k0ral> good to know
02:14:39 <quintessence> latro`a: it looks like mtl is just fundeps, mptcs and flexible instances actually
02:14:45 <latro`a> looks like it, yeah
02:14:52 <latro`a> well no
02:14:57 <latro`a> undecidable instances is definitely there
02:15:26 <latro`a> cf. hackage.haskell.org/packages/archive/mtl/2.1.2/doc/html/src/Control-Monad-Writer-Class.html for example
02:16:50 <quintessence> oh, I was just looking at the cabal file
02:17:13 <latro`a> not sure why the cabal file doesn't mention this, then
02:17:39 <latro`a> actually I suspect they meant UndecidableInstances
02:17:45 <latro`a> because I don't see FlexibleInstances anywhere (anymore)
02:18:37 <latro`a> also, did fundeps/mptcs become standard?
02:18:39 <latro`a> somehow?
02:18:44 <latro`a> because that's not in any of the pragmas
02:18:49 <latro`a> er, *they're
02:18:54 <latro`a> even where they are used
02:19:01 <donri> latro`a: "cat prose"??
02:19:30 <quintessence> don't extensions in the cabal file go to ghc on the command line?
02:20:24 <latro`a> donri: mi'e latros ji'a
02:20:38 <latro`a> (ros and ro'a both are rafsi for prosa)
02:20:46 <latro`a> (it's an old joke that I decided to make my actual name)
02:20:58 <latro`a> also, derp, touche, quintessence
02:24:31 <donri> :)
02:27:31 <statusfailed> Does anyone have a tutorial on this package? http://hackage.haskell.org/packages/archive/arrows/0.4.1.2/doc/html/Control-Arrow-Transformer-Automaton.html
02:27:39 <statusfailed> Or an explanation? :D
02:28:03 <statusfailed> I want to compose things of type (b -> State s a), which I think are Mealy machines
02:51:21 <DanBurton> back to half an hour ago, mtl uses UndecidableInstances because of things like "instance MonadState s m => MonadState s (MaybeT m) where ..."
02:52:04 <DanBurton> I believe this is because `s` does not appear in `MaybeT m`
02:53:40 <DanBurton> that is all :) bye
02:58:22 <TEttinger> agh...
02:58:49 <TEttinger> I am having a devil of a time porting the Scheme in 48 hours code to use Parsec.Token
02:59:05 <palmfrond> i'm curious what's so tough about text encodings? seems simple to me. a bunch of numbers which associate to a bunch of text characters per the given encoding. 3 in encoding A could mean "C" and in encoding B could mean "ø"
02:59:57 <shachaf> palmfrond: Encoding is usually about bytes, not numbers.
03:00:13 <palmfrond> but those bytes could be interpreted as number datatypes no?
03:00:18 <kallisti> other way around
03:00:21 <shachaf> Sure.
03:00:23 <palmfrond> ?
03:00:24 <kallisti> the numbers can be represented as bytes.
03:00:24 <TEttinger> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing   http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#ParsecToken
03:00:25 <shachaf> In lots of ways.
03:00:54 <palmfrond> kallisti, eh?
03:01:16 <shachaf> kallisti: The numebrs can be represented as bytes, and therefore the bytes can be interpreted as numbers.
03:01:29 <koala_man> palmfrond: what about parts of the texts that should be written right to left? what about combining characters?
03:01:30 <kallisti> I guess it's the same.
03:01:46 <kallisti> but the numbers -> bytes  direction is more important, I feel. :P
03:01:48 <shachaf> koala_man: That's not encoding anymore.
03:01:55 <shachaf> Well, it's not encoding of code points, at least.
03:02:02 <palmfrond> koala_man, i think that's up to what's presenting the text, not complicated as far as the encoding itself goes
03:02:03 <shachaf> kallisti: Either direction on its own is pretty useless.
03:02:21 <TEttinger> I'm really not sure what this error means http://pastebin.com/X0P63xvY -- i will pastebin the code next
03:02:23 <mauke> The paste X0P63xvY has been copied to http://hpaste.org/72249
03:02:53 <palmfrond> it seems insane that it's proven so tough for humans to develop a solid general purpose "text" model/object
03:03:07 <palmfrond> handling writing direction, character joins, etc, should be easy
03:03:22 <shachaf> If it's easy then feel free to do it. :-)
03:03:28 <shachaf> Anyway, that's not an encoding issue.
03:03:34 <palmfrond> i am
03:03:37 <palmfrond> hmm
03:03:42 <TEttinger> source here http://pastebin.com/jvWRZvFL
03:03:48 <mauke> The paste jvWRZvFL has been copied to http://hpaste.org/72250
03:03:48 <shachaf> (Well, it's an encoding issue at a different level.)
03:04:30 <palmfrond> so the encoding associates sequences of bytes to characters, or numbers to characters? i'm curious what an encoding interprets to produce a character
03:04:34 <k0ral> quintessence: your stack overflow link may have just changed my life
03:04:41 <k0ral> quintessence: thank you
03:05:02 <k0ral> I'm rewriting my whole code with Monad* instead of a stack of transformers
03:05:06 <palmfrond> like characters in utf8, are they at given bit patterns, or integers, or?
03:05:12 <kallisti> palmfrond: an encoding is a mapping from characters to bytes. typically you enumerate these characters by natural numbers.
03:05:14 <shachaf> TEttinger: I doubt people are going to feel like digesting a huge chunk of paste like that...
03:05:31 <kallisti> palmfrond: Unicode has a universal mapping from characters to codepoints, which are natural numbers. the encoding maps to a particular bit pattern.
03:05:34 <TEttinger> shachaf, yeah, I am just totally lost here
03:05:50 <shachaf> TEttinger: You should get rid of everything that's not essential in your paste.
03:05:51 <koala_man> palmfrond: typically you have a character set which is numbers to characters or code points, and encodings which are mappings from bytes to numbers
03:06:00 <TEttinger> shachaf, can do
03:06:04 <shachaf> (And hopefully make one paste with the code + the error rather than two pastes.)
03:06:20 <palmfrond> umber to character?
03:06:24 <palmfrond> wtf
03:06:37 <palmfrond> so encoding goes bytes to numbers, and character set goes number to character?
03:06:46 <shachaf> palmfrond: No. What kallisti said, mostly.
03:06:52 <kallisti> that's technically decoding. but "an encoding" specifies both directions.
03:07:04 <palmfrond> i know, i mean these relationships
03:07:05 <shachaf> Except "character" is something distinct from "code point".
03:07:28 <palmfrond> is code point an element of a character? like a grapheme
03:07:41 <k0ral> @hoogle monadEither
03:07:41 <lambdabot> No results found
03:07:54 <k0ral> there is no such thing as monadEither ?!
03:08:01 <shachaf> @google code point
03:08:02 <lambdabot> http://en.wikipedia.org/wiki/Code_point
03:08:02 <lambdabot> Title: Code point - Wikipedia, the free encyclopedia
03:08:05 <srhb> k0ral: What would that do?
03:08:16 <k0ral> srhb: good point
03:08:44 <srhb> k0ral: (It was actually an earnest question, I couldn't figure out what the meaning of monadEither was supposed to be and why you expect it to be there) :-)
03:08:48 <shachaf> srhb: Are you running #haskell in easy mode or something?
03:08:51 <kallisti> if I understand what shachaf is getting at, he's saying that you can choose to display the individual codepoints in whatever way tou want.
03:09:17 <srhb> shachaf: Beg your pardon? :P
03:09:39 <statusfailed> k0ral: could you share the stackoverflow link you mentioned?
03:09:59 <shachaf> kallisti: I'm thinking of e.g. the difference between á and á.
03:10:20 <kallisti> shachaf: is that not a codepoint difference as well.
03:10:31 <kallisti> I can't think of a situation where the same sequence of codepoints results in a different sequence of characters.
03:10:45 <shachaf> kallisti: Yes, one is two codepoints, and one is one codepoint.
03:10:56 <shachaf> But you could say they represent the same character.
03:11:10 <kallisti> oh. maybe.
03:11:50 <shachaf> palmfrond: Anyway, "just use UTF-8".
03:12:21 <k0ral> statusfailed: http://stackoverflow.com/questions/9054731/avoiding-lift-with-monad-transformers
03:12:22 <palmfrond> k but here's my issue, let's say i use utf-8 in my library, but the program library is compiled into uses some crazy foreigner encoding
03:12:36 <palmfrond> how do i detect this? how do i detect which encoding they are using? how do i handle difference in encoding? etc
03:12:44 <shachaf> You can't.
03:12:44 <palmfrond> im learning all i can about the topic now
03:12:48 <palmfrond> ?
03:13:00 <kallisti> palmfrond: a very sophisticated AI.
03:13:01 <shachaf> An encoding is like a type.
03:13:08 <kallisti> unless you only want to handle a few specific cases. poorly.
03:13:15 <shachaf> kallisti: It doesn't matter how sophisticated your AI is, you just can't do it.
03:13:26 <TEttinger> here, cut out, mostly http://pastebin.com/wAachtZ6
03:13:28 <mauke> The paste wAachtZ6 has been copied to http://hpaste.org/72251
03:13:35 <palmfrond> shachaf, is it because encoding doesn't matter to you, you're just given binary ?
03:13:46 <shachaf> palmfrond: The encoding a sequence of bytes is encoded in is part of the metadata you should have about the bytes.
03:14:01 <statusfailed> k0ral: Thanks :)
03:14:04 <shachaf> For example, an HTTP response will have a line like content-type: text/plain; charset=utf-8
03:14:32 <kallisti> shachaf: not in general, no.
03:14:32 <shachaf> Without that information, you can try to guess if you want, but you can't know for sure.
03:14:42 <palmfrond> well when i get some stdio say keyboard input in my C code, how do i know what encoding it is? or be told
03:14:44 <kallisti> shachaf: file does a pretty good job though.
03:14:46 <TEttinger> shachaf, the problems I can think of are noted on the lines with ---------PROBLEM?????????
03:14:57 <palmfrond> (lol)
03:15:38 <k0ral> how do you understand "Could not deduce (m ~ IO) from the context (MonadIO m)" ?
03:15:47 <TEttinger> in particular, I don't know how to get whitespace to play nice with other parsers
03:15:57 <shachaf> palmfrond: Look at your environment variable.
03:16:08 <shachaf> LANG=en_US.utf8 # or something
03:16:29 <kallisti> shachaf: you can, for example, given a binary input and a known set of encodings, determine all of the encodings for which the given sequence of binary is a member of.
03:16:36 <shachaf> kallisti: Sure, sure.
03:16:37 <TEttinger> never mind, I'm an idiot
03:16:45 <shachaf> You can make all sorts of fancy heuristics.
03:16:54 <shachaf> kallisti: Well, actually, you can't do that, because the set of encodings is infinite. :-)
03:17:03 <shachaf> You can figure out all of the *popular* encodings.
03:17:15 <quintessence> k0ral: probably you have an explicit type signature that says you're using some MonadIO m, but then you do something that assumes your monad is just IO
03:17:16 <TEttinger> I defined whitespace as being transformed somehow into m_whitespace (a library thing I can't find docs on)
03:17:29 <TEttinger> and then I called whitespace instead of m_whitespace
03:17:43 <quintessence> so GHC is saying "I can't prove that m is IO from what I know about m (which is that MonadIO m)
03:17:57 <kallisti> shachaf: or a set of /known/ encodings, like I said.
03:17:59 <kallisti> as in, a finite set.
03:18:06 <kallisti> that the program "just knows"
03:18:19 <shachaf> Oh, yes, you did say that.
03:18:28 <palmfrond> so the solution is for everyone to just use utf8 instead of ascii, so we don't have to detect encodings and convert and stuff?
03:18:35 <shachaf> Anyway that's horrible and your program shouldn't do it in most cases.
03:18:36 <palmfrond> like how everything just worked when everything was ascii
03:18:53 <palmfrond> it's like a whole bunch of format standards for "string".
03:18:54 <srhb> palmfrond: Except for everyone outside the US, yes. :P
03:19:00 <shachaf> palmfrond: It's not UTF-8 instead of ASCII.
03:19:02 <palmfrond> yea but they speak english so np
03:19:13 <shachaf> There are lots of other things than UTF-8 and ASCII.
03:19:19 <palmfrond> i know
03:19:22 <shachaf> palmfrond: No, they don't speak English.
03:19:29 <palmfrond> but i mean, modern work is just using utf8 right?
03:19:36 <k0ral> quintessence: right, it's tryIO from Control.Error, I guess I should really get rid of the errors package and redefine its equivalent using mtl
03:19:36 <shachaf> ?
03:19:44 <kallisti> palmfrond: UTF-8 or UTF-16 are the best choices, I'd say. UTF-16 is actually a better encoding for chinese characters. UTF-32 is more efficient for random access lookup than any other encoding, but the overhead is very minimal for the other encodings.
03:19:52 <palmfrond> would anyone make new software with some japanese character set?
03:20:01 <shachaf> kallisti: It's not a "better encoding".
03:20:34 <shachaf> It might be a more compact encoding for Chinese text, but that doesn't mean all *that* much.
03:20:38 <kallisti> shachaf: IIRC correctly it uses fewer codepoints to represent the characters on the upper end of the BMP.
03:20:45 <kallisti> er bytes
03:20:47 <shachaf> "fewer codepoints"?
03:20:49 <shachaf> Ah.
03:20:56 <shachaf> I think it actually turns out to be less compact for HTML+Chinese text.
03:21:00 <kallisti> 6:20 AM. alcohol. etc. :P
03:21:09 <kallisti> shachaf: oh, probably.
03:21:21 <koala_man> palmfrond: absolutely. just think of all the american apps that don't support non-ascii properly.
03:21:35 <quintessence> k0ral: mtl has Control.Monad.Error, which might work for you
03:21:55 <shachaf> kallisti: Anyway the difference is small enough that there are better things to worry about than compactness for UTF-8 vs. UTF-16
03:21:57 <palmfrond> yea but foreign languages are subordinate to english
03:21:59 <shachaf> Even for Chinese text.
03:22:04 <shachaf> You can always gzip it.
03:22:17 <kallisti> true.
03:22:23 <kallisti> you could say UTF-18 is more politically correct. :>
03:22:24 <koala_man> palmfrond: english is a foreign language for the japanese
03:22:28 <kallisti> *16   sheesh
03:22:31 <palmfrond> shachaf, so what's your choice for universal encoding to base new code on?
03:22:39 <shachaf> kallisti: Also, UTF-8 supports random access too.
03:22:41 <palmfrond> koala_man, ha, you funny round eye make joke
03:22:46 <shachaf> Just not by code point index.
03:23:00 <shachaf> palmfrond: Use UTF-8
03:23:05 <palmfrond> k
03:23:14 <shachaf> But internally use whatever data type your language has.
03:23:18 <kallisti> shachaf: by... code unit? that goes without saying. :P
03:23:19 <shachaf> E.g. String or Data.Text in Haskell
03:23:29 <palmfrond> since code points in utf8 are variable length, how does some wad of characters get each one identified?
03:23:45 <palmfrond> 12 understood vs 123 since the wad was 12325325
03:23:59 <shachaf> palmfrond: You should read about how UTF-8 works.
03:24:04 <palmfrond> yea i should
03:24:09 <koala_man> read the specs, it's pretty straight forward
03:24:09 <shachaf> It's pretty neat -- the encoding solves a lot of problems.
03:24:10 <palmfrond> any good urls you'd recommend plz?
03:24:14 <shachaf> @google utf-8
03:24:15 <lambdabot> http://en.wikipedia.org/wiki/UTF-8
03:24:15 <lambdabot> Title: UTF-8 - Wikipedia, the free encyclopedia
03:24:15 <palmfrond> nice, url?
03:24:16 <shachaf> That one is good.
03:24:22 <palmfrond> reading
03:24:23 <nand`> bah, shachaf linked it faster than I could
03:24:35 <kallisti> palmfrond: the way UTF-8 is designed, the smaller bytes only appear at the start of codepoints with a certain length. you only need to backup or move forward a few bytes to figure out where a character starts.
03:25:03 <palmfrond> uh
03:25:09 <palmfrond> vat?
03:25:29 <shachaf> palmfrond: Just read how the encoding works.
03:25:41 <palmfrond> The Internet Engineering Task Force (IETF) requires all Internet protocols to identify the encoding used for character data, and the supported character encodings must include UTF-8
03:25:42 <palmfrond> wow
03:25:50 <koala_man> kallisti: where a code point starts. there could be several code points to a character
03:26:34 <shachaf> palmfrond: Look for something that looks like 0xxxxxxx; 110xxxxx 10xxxxxx; 1110xxxx 10xxxxxx 10xxxxxx; ...
03:27:11 <palmfrond> it uses 4 bytes. so utf8 uses as much as 32 bits of space per codepoint
03:27:15 <palmfrond> shachaf, eh?
03:27:30 <kallisti> koala_man: I was pretty sure that each code point represented a unique character.
03:27:35 <shachaf> palmfrond: So does UTF-16
03:28:19 <palmfrond> shachaf, but utf8 would have a different data format right?
03:28:31 <shachaf> Yes.
03:28:39 <shachaf> You should really read those pages.
03:28:44 <shachaf> @google utf-16
03:28:45 <lambdabot> http://en.wikipedia.org/wiki/UTF-16
03:28:45 <lambdabot> Title: UTF-16 - Wikipedia, the free encyclopedia
03:28:47 <koala_man> kallisti: some of them combine
03:29:05 <palmfrond> im reading them now
03:29:16 <shachaf> palmfrond: The Haskell FAQ links to this article: http://www.joelonsoftware.com/articles/Unicode.html
03:29:38 <koala_man> you can encode a form of ´ and e to get é (even though é is encodable as a single character as well, being so common historically)
03:29:47 <palmfrond> i'm not seeing how codepoints are demarked
03:29:50 <palmfrond> delineated
03:30:06 <palmfrond> wow
03:30:10 <palmfrond> how does that work koala_man ?
03:30:27 * shachaf sighs.
03:30:29 <shachaf> Good night.
03:30:42 <palmfrond> i apologize for learning
03:30:44 <nand`> hmm, continuing the scheme as shown; wouldn't it be logical to also have a 7-byte encoding scheme where the first byte is ‘11111110’ and followed by 6 information bytes each carrying 6 bits, making for a max codepoint of 0xFFFFFFFFF ?
03:32:57 <TEttinger> ok, quick question: how do I implement modulus for floating-point values, doing the dumb thing and taking the floor of both floats before hand?
03:33:15 <TEttinger> right now I have
03:33:17 <TEttinger> (\ qq qr ((floor qq) `mod` (floor qr)))
03:33:25 <TEttinger> which gives a compile error
03:33:30 <palmfrond> nand`, hmm
03:33:44 <palmfrond> why would that be good?
03:33:51 <nand`> or does unicode stop at 32 bits?
03:33:53 <koala_man> palmfrond: you write a combining diacritical mark followed by a character. and instead of showing like "´e", it'll show like "é"
03:34:27 <palmfrond> how do i as a library programmer support that feature?
03:34:32 <palmfrond> or is it left to the UI ppl
03:35:10 <kallisti> nand`: The specification of UTF-32 states that it will always be able to represent every Unicode character.
03:35:15 <quintessence> TEttinger: that should work, though possibly the type is more general than you expect
03:35:22 <quintessence> :t mod `on` floor
03:35:23 <lambdabot> forall b a. (Integral b, RealFrac a) => a -> a -> b
03:35:36 <kallisti> nand`: and I think it's specified to be within the range 0 to 0x10FFFF
03:35:38 <nand`> kallisti: I see
03:35:42 <TEttinger> :t (\ qq qr ((floor qq) `mod` (floor qr)))
03:35:43 <kallisti> so less than 32-bit
03:35:44 <lambdabot> Parse error in pattern
03:35:54 <amatsu> :t (\ qq qr -> ((floor qq) `mod` (floor qr)))
03:35:56 <lambdabot> forall a b a1. (RealFrac a, Integral b, RealFrac a1) => a -> a1 -> b
03:36:00 <palmfrond> so a long would allow you to store a number for each unicode codepoint, right?
03:36:01 <TEttinger> oh, ->
03:36:03 <TEttinger> got it
03:36:06 <palmfrond> in C
03:36:09 <koala_man> palmfrond: it's more for the UI people, though it does mean that you can't split strings arbitrarily
03:36:17 <nand`> kallisti: no, UTF-32 goes up to U+7FFFFFFF
03:36:27 <nand`> which is 31 bits
03:36:36 <palmfrond> koala_man, wow you're right. how do we handle that!?
03:36:42 <nand`> which is same as the largest encoding scheme in UTF-8
03:36:45 <kallisti> nand`: that's UCS-4
03:36:53 <nand`> oh
03:37:02 <nand`> serves me right for skimming through the article
03:38:18 <k0ral> praise the author of mtl
03:39:23 <koala_man> palmfrond: by treating a string as a unit to display or transmit. let the UI people worry about where to linewrap it for example
03:40:04 <palmfrond> koala_man, yea but what if i need to truncate a string to fit it in a buffer? i could truncate to fit, but it'd be missing an essential diacritical
03:40:09 <palmfrond> otherwise it'd be incoherent
03:41:13 <koala_man> palmfrond: you'd probably put the rest of the string in the next buffer?
03:41:26 <palmfrond> hm ya i suppose
03:52:54 <TEttinger> ok, I have a function using the Parsec library, parseInteger.  It needs to return a Parser LispVal , where LispVal is a typeclass that here should be a Number, which is a Double (not an Integer)
03:52:55 <TEttinger> parseInteger :: Parser LispVal
03:53:16 <TEttinger> actual code is one line
03:53:18 <TEttinger> parseInteger = fmap (Number . realToFrac) m_integer
03:54:29 <TEttinger> but that doesn't properly convert the thing to a Double.
03:54:45 <nand`> Can I give operators a fixivity declaration in GHCi?
03:55:22 <TEttinger> m_integer has type CharParser st Integer
03:55:49 <TEttinger> and I don't know how (probably a Monad thing) to change that to CharParser st Double
03:58:27 <nand`> are you sure you want realToFrac and not fromInteger ?
03:58:35 <quintessence> nand`: it seems you can't; let {infixr 0 $$; ($$) = ($)} is accepted but the fixity doesn't stick
03:59:07 <nand`> quintessence: yeah, it seems to be a bug; note how just typing “let infixr 0 $$” complains about lack of an accompanying binding
03:59:33 <nand`> it seems to default to infixl 9 or something
03:59:33 <quintessence> that part at least makes sense, since fixity declarations works like type declarations
03:59:48 <nand`> yeah, but I meant it does seem to respect them
03:59:52 <nand`> ie. doesn't just ignore them
04:00:15 <nand`> doesn't show up in :info either
04:00:15 <quintessence> yeah, it works fine if you use let ... in
04:00:40 <nand`> you're right, it does
04:01:33 <k0ral> is it possible to make (MonadReader S m) => EitherT E m () an instance of MonadReader S ? I'm thinking it's not because if it is Left, there is no state to read, am I right ?
04:01:49 <quintessence> and it works in do-notation, just not at the ghci toplevel--strange.
04:02:03 <nand`> maybe there's a ticket on it somewhere
04:02:07 <nand`> alas I'm too lazy to search
04:21:38 <ceti331>  /join android
04:23:07 <keep_learning> hello all
04:23:31 <srhb`> keep_learning: Hi
04:23:46 <keep_learning> I am trying to run a eden example on my cluster and this is the first time I am trying to run on cluster.
04:23:50 <keep_learning> http://www.mathematik.uni-marburg.de/~eden/?content=build_progs&navi=build
04:24:25 <keep_learning> I am trying to create MPI@<file>
04:25:10 <keep_learning> in this file host1 slots=2 maxslots=4 , what should I write for host1. The IP of host1 or something else ?
04:54:26 <TEttinger> aggggh...   How do I pattern match for a list of a certain type?
04:54:46 <TEttinger> numericBinop :: Real n => (n -> n -> n) -> [LispVal] -> ThrowsError LispVal
04:55:03 <__bob__> Horray!
04:55:09 <TEttinger> I need a numericBinop that takes only MyInteger types of LispVal
04:55:11 <__bob__> I am __un banned__
04:56:12 <TEttinger> I tried
04:56:17 <TEttinger> numericBinop op ([WallInteger] xs) = ........
04:56:38 <TEttinger> well, MyInteger
04:56:53 <srhb> TEttinger: Put the type in the type annotation to specialize your function
04:57:05 <mikeplus64> TEttinger: pat1:pat2:...:xs, or [pat1, pat2 ...]
04:57:23 <mikeplus64> TEttinger:
04:57:31 <mikeplus64> oops
04:57:37 <mikeplus64> my xterm is messing up, sorry
04:57:45 <quintessence> TEttinger: you mean you want to pattern match for MyInteger *constructors* of the LispVal type
04:57:49 <TEttinger> yes
04:57:50 <TEttinger> sorry
04:57:53 <srhb> TEttinger: Oh sorry, MyInteger is a constructor of LispVal?
04:57:57 <TEttinger> yeah, sorry
04:57:58 <srhb> ah
04:58:33 <srhb> TEttinger: You can have patterns like (MyInteger:lvs)
04:58:43 <TEttinger> but a list of MyInteger
04:58:46 <srhb> TEttinger: which only ensures that the first element of the list is a MyInteger
04:59:12 <TEttinger> yeah, it needs to be all...
04:59:13 <TEttinger> hm
04:59:37 <srhb> Then you should probably declare a MyInteger type that is just used as a constructor in LispVal as well
04:59:45 <srhb> That's the easy way out. :-)
04:59:55 <TEttinger> I could use Integer, that's all MyInteger is
05:00:54 <TEttinger> at least I ASSUME that you can use a Integer in a typeclass constructor defined as an Integer
05:01:50 <TEttinger> mikeplus64, what did you mean by pat1:pat2... ?
05:02:27 <srhb> It wasn't relevant for you, you can't use a data constructor as a type, so your function would not have been specialized for a whole list of some data constructor
05:02:38 <TEttinger> ah...
05:02:49 <quintessence> > let f (x:xs) = (x, xs) in f "abc" -- is what he was talking about
05:02:50 <lambdabot>   ('a',"bc")
05:02:52 <TEttinger> but could I do a list of Integer s?
05:02:54 <mikeplus64> TEttinger: if you want to ensure a list all has the same data constructor sort of, then you could do map (\x@(pattern that you want) -> x) xs, which will raise an exception when it reaches something not matching the pattern
05:03:03 <srhb> TEttinger: Yes, Integer is a type
05:03:20 <mikeplus64> or more sanely, concatMap (\x -> case x of pattern -> [x]; _ -> []) xs
05:03:54 <TEttinger> srhb, I mean how would I pattern match for a list of Integers?
05:04:01 <srhb> TEttinger: You would not
05:04:09 <srhb> TEttinger: You would type annotate your function to only work on lists of Integers
05:04:17 <TEttinger> ah...
05:04:19 <srhb> foo :: [Integer] -> blah
05:04:36 <srhb> You don't pattern match on types.
05:04:53 <TEttinger> so then... how would I make a function that can be called on heterogeneous arguments?
05:05:10 <TEttinger> one Double, one Integer, or two integers, or 3 Doubles...
05:05:22 <TEttinger> all Nums
05:06:03 <TEttinger> hm, but it would need to return an Integer when the result is an Integer... agh...
05:06:22 <colock> like (Num a) => a -> a ?
05:06:30 <TEttinger> well, when the result is an Integer AND all parameters were Integers
05:06:33 <TEttinger> yeah
05:06:39 <colock> then like ^^
05:07:03 <TEttinger> colock, what about the integers-return-integers case?
05:07:22 <srhb> Int -> Int
05:07:24 <srhb> ?
05:07:24 <colock> TEttinger: it a is Integer, the function a -> a will take one integer and return one integer
05:07:29 <TEttinger> or will that always just return a Num?
05:07:35 <colock> it will return a
05:07:39 <Franciman> hi all
05:07:43 <colock> a being an instance of Num
05:07:45 <quintessence> TEttinger: you seem to be confused about the different sorts of capitalized things
05:07:46 <TEttinger> oh, so it won't handle Double and Integer
05:07:52 <colock> (i.e. Int is an instance of Num, for example)
05:07:56 <colock> yea
05:08:02 <colock> cause Double is an instance of Num too
05:08:06 <srhb> TEttinger: It will do Double -> Double, Int -> Int, Integer -> Integer
05:08:06 <quintessence> type classes are not types, they're constraints on types
05:08:12 <TEttinger> I am trying to implement a Lisp... so this could be trouble
05:08:23 <mietek> I don't seem to be able to receive account registration confirmation emails from the GHC trac... anyone else?
05:08:33 <colock> TEttinger: better writing a parser then
05:08:54 <TEttinger> I have the parser working, I think
05:09:15 <TEttinger> the trouble is interpreting the case of, say, (+ 12.5 3)
05:09:19 <srhb> TEttinger: But are Lisp lists even homogenous? Why do you want to ensure on the type level that a lists of LispVals is in fact a list of Integers?
05:09:29 <Franciman> TEttinger, and then it's me the cheater ;)
05:09:42 <TEttinger> hi Franciman :-)
05:13:14 <TEttinger> srhb, Lisp lists are heterogeneous.  But, I could just treat all numbers as Doubles and print them differently if they are integral values
05:14:11 <quintessence> TEttinger: you'll want to make a distinction between types-as-seen-from-LISP and types-as-seen-from-Haskell
05:14:14 <srhb> TEttinger: Assuming you have value constructors for each type, you could have mySumList (MyInt a: MyDouble b:vals) = ....
05:14:24 <srhb> If it's a primitive you're implementing, I mean
05:14:39 <quintessence> what LISP calls "types" are runtime tags on values (i.e. data constructors on the Haskell side)
05:14:46 <srhb> Is it a compiler or an interpreter anyway_
05:14:56 <TEttinger> right now, an interpreter
05:15:11 <TEttinger> eventually my goal is to translate to Lua
05:18:21 <TEttinger> quintessence, could you elaborate?
05:19:48 <quintessence> so, the Haskell type of all LISP functions is going to be something like [LispValue] -> LispValue
05:21:43 <quintessence> and to implement a built-in LISP function in Haskell you'll have to pattern match on the list of LISP values in order to extract whatever arguments you need
05:26:07 <TEttinger> quintessence: but I thought you couldn't patern match on data constructors?
05:26:22 <srhb> No, you can only pattern match on data constructors
05:26:28 <srhb> You can't pattern match on _types_
05:28:13 <TEttinger> ok, so to handle stuff like (+ 1.2 3 4.5 7.8 9 10)
05:28:48 <TEttinger> I would do a recursive call on some + primitive, that has a version for every combination of add-able types?
05:28:52 <srhb> That's not really Lisp, is it?
05:29:03 <TEttinger> srhb, it is
05:29:05 <srhb> (+ (1 2 3 4)), isn;t it?
05:29:06 <srhb> Oh
05:29:09 <srhb> I'm rusty I guess
05:29:12 <mroman> He. I was facing the same problem recently.
05:29:45 <TEttinger> (+ (1 2 3 4)) would be an error, trying to "call" the first element of the (1 2 3 4) list
05:29:53 <srhb> I ee.
05:29:55 <srhb> see*
05:30:06 <TEttinger> unless + is a macro, in which case ???
05:30:13 <srhb> :-)
05:30:17 <Adeon> depends on the lisp
05:30:31 <TEttinger> Adeon, true
05:31:20 <srhb> Anyway, you would have to find some way to recursively deal with this, but you'd have something like eval (LispFunc foo : vals) = lispapply foo $ vals
05:31:27 <srhb> But probably dealing with vals in some clever, recursive manner
05:31:54 <srhb> Well actually if you just assume no error, that would suffice
05:32:41 <srhb> Then your lispapply would find the function relevant to foo and apply it to the arguments, returning a fitting LispVal
05:32:56 <hpaste> mroman pasted “sum | wrapped types” at http://hpaste.org/72252
05:32:56 <srhb> (And then you're done.)
05:33:19 <srhb> For instance, here's a simple hardcoded version
05:33:31 <mroman> ^- Could that be written more general/elegant?
05:33:59 <srhb> eval (LispFunction "+" : vals) = LispNumber (sum vals)
05:34:05 <quintessence> TEttinger: yeah, that's basically the idea.  You define some big sum type LispVal with constructors for all LISP types, and the primitives (written in Haskell) have type [LispVal] -> LispVal
05:34:10 <srhb> TEttinger: That's you O'm spamming, by the way. :-)
05:34:16 <srhb> I'm*
05:34:51 <srhb> But of course that sum would have to take LispNumbers..
05:35:09 <mroman> I tried to make it work with other types, but it turned out te be too PITA. So I defined a primitve for addition and use fold.
05:35:58 <TEttinger> mroman, isn't there an apply/map function for that?
05:36:34 <mroman> > foldl1 (+) [1,2,3,4]
05:36:35 <lambdabot>   10
05:36:42 <mroman> ^- You mean this one?
05:37:25 <TEttinger> yes
05:37:25 <mroman> > foldl1 (fmap (+)) [Just 1, Just 2, Just 3]
05:37:26 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
05:37:38 <TEttinger> ah
05:37:40 <mroman> :t fmap
05:37:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:38:08 <mroman> hm.
05:38:43 <mroman> :t fmap2
05:38:44 <lambdabot> Not in scope: `fmap2'
05:38:46 <mroman> :(
05:39:07 --- mode: ChanServ set +o mauke
05:39:07 --- mode: mauke set -b *!*@c-68-50-226-254.hsd1.md.comcast.net
05:39:09 <mroman> > foldl1 (\(Just x) (Just y) -> x + y) [Just 1, Just 2, Just 3]
05:39:10 <lambdabot>   Occurs check: cannot construct the infinite type:
05:39:10 <lambdabot>    t = Data.Maybe.Maybe t
05:39:19 <mroman> > foldl1 (\(Just x) (Just y) -> Just $ x + y) [Just 1, Just 2, Just 3]
05:39:21 <lambdabot>   Just 6
05:40:05 <srhb> > foldl1 (liftM2 (+)) [Just 1, Just 2, Just 3]
05:40:06 <lambdabot>   Just 6
05:40:40 <srhb> Hell yes, that's the first time I recognize and post a liftM2 simplification in #haskell before anyone else
05:40:44 * srhb high-fives herself
05:40:54 <k0ral> arg, again this damned "could not deduce XXX from context" error
05:41:03 <mroman> > foldl1 (liftM2 (+)) [Just 1, Just 2, Just 3]
05:41:04 <lambdabot>   Just 6
05:41:06 <k0ral> it's driving me crazy
05:41:07 --- mode: mauke set -o mauke
05:41:12 <mroman> I should have seen that :)
05:41:24 <srhb> mroman: But you didn't! neener neener!
05:41:26 <srhb> <_<
05:41:28 <srhb> >_>
05:41:52 <mroman> > foldl1 (liftM2 (+)) [Just 1, Just 2, Just 3, Nothing]
05:41:54 <lambdabot>   Nothing
05:41:57 <k0ral> what's the point of using typeclasses if I can't use any specific instance without getting this error ?!
05:41:59 <TEttinger> thanks for your help, everyone, now I need to sleep -- 5:41 AM here
05:42:08 <srhb> TEttinger: Gnight :)
05:42:14 <plat0> Anyone who knows the description of the state monad in terms of operations and equations may be able to help me out with my math.stackexchange question: http://math.stackexchange.com/questions/176174/how-to-prove-a-property-of-the-lawvere-theory-for-global-state
05:43:23 <mroman> srhb: Although that doesn't *just* work without Maybe
05:43:32 <k0ral> I want to call f :: (MonadIO m) => ErrorT E m () within g :: (MonadError E m, MonadIO m) => m ()
05:44:00 <k0ral> it won't allow me as f is a specific instance of MonadError
05:44:05 <srhb> mroman: How so?
05:44:18 <k0ral> s/f/the type of f/
05:44:35 <mroman> Because you usually don't have f a in such a case.
05:44:44 <mroman> http://codepad.org/YG3zJuvY <- like that.
05:45:17 <srhb> mroman: Right, it may be practical to make a helper function to lift functions to work on LispVals
05:46:19 <quintessence> k0ral: you can't be more polymorphic than your dependencies; if f depends on something that requires a specific monad, then f requires that monad too and its type signature needs to say so
05:46:34 <quintessence> er, by f I mean g
05:47:36 <mroman> http://codepad.org/Tq4YYhjS <- like that.
05:47:41 <mroman> srhb: How can one do that?
05:48:24 <mroman> you'd have to write something for every combination of two values.
05:48:25 <k0ral> quintessence: then I can't see how one could ever use MonadError since there is always an underlying non-polymorphic implementation of it that will propagate to all caller functions
05:49:02 <srhb> mroman: Well no, you could make an apply function instead that takes an f argument instead of hardcoding +
05:49:53 <srhb> mroman: foldl1 (binaryApply (+)) [...]
05:50:03 <quintessence> k0ral: there are generic versions in the primitives in the typeclass itself
05:50:47 <srhb> mroman: but you'd still have to do it for each numeric constructor, just like we have to in Haskell.
05:50:54 <quintessence> and you can make callers more specific than callees, just not the other way around
05:50:58 <covi> I don't understand LYAH's section on Control.Monad.State... Someone can help?
05:51:30 <quintessence> so at the top you have some tangle of runBlah . runFoo initialBar ... $ theComputation that decides the concrete type
05:52:16 <k0ral> oh
05:52:46 <mroman> srhb: http://codepad.org/jEoEKCiH <- like that @binaryApply?
05:52:51 <k0ral> I'm trying to use Control.Exception as a particular Error
05:53:01 <srhb> mroman: Exactly
05:53:17 <k0ral> the only way I found is through try, which *specifies* the underlying error handling mechanism as Either
05:53:36 <k0ral> is there a more generic way to do the same ?
05:53:59 <k0ral> :t ErrorT . return
05:54:00 <lambdabot> forall (m :: * -> *) e a. (Monad m) => Either e a -> ErrorT e m a
05:54:23 <quintessence> :t throwError
05:54:25 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
05:54:49 <k0ral> @hoogle forall (m :: * -> *) e a. (Monad m) => Either e a -> ErrorT e m a
05:54:49 <lambdabot> Parse error:
05:54:49 <lambdabot>   forall (m :: * -> *) e a. (Monad m) => Either e a -> ErrorT e m a
05:54:49 <lambdabot>          ^
05:54:56 <k0ral> ?
05:55:26 <parcs`> :t either throwError return
05:55:28 <lambdabot> forall a (m :: * -> *) a1. (MonadError a m) => Either a a1 -> m a1
05:57:01 <k0ral> quintessence: are you suggesting I wrap the existing try with a throwError ? if it's Left x, I throwError x ?
05:59:19 <quintessence> which try is this?
06:00:29 <k0ral> from Control.Exception
06:03:32 <quintessence> yeah, you'll want to turn your either into an error by pattern matching it and using throwError (or parcs` pointfree version) rather than using EitherT
06:05:34 <mmaruseacph2> hello :)
06:05:53 <mmaruseacph2> i have a list of files which I transform into a pipe using sourceList
06:06:12 <mmaruseacph2> now, I want each of them to be fed into another pipe which reads the content of the file
06:06:16 <mmaruseacph2> is it possible?
06:06:56 * hackagebot select 0.2.1 - Give the select(2) POSIX function a simple STM interface (GardSpreemann)
06:07:11 <mmaruseacph2> found it, nevermind
06:16:18 <covi> I don't understand LYAH's section on Control.Monad.State... Someone can help?
06:16:57 * hackagebot database-migrate 0.0.1 - Database versioning and migration (MarkHibberd)
06:17:06 <Franciman> covi, what's the problem?
06:17:55 <covi> Franciman: why wrap a function (s -> (a, s))?
06:19:59 <mroman> As there are no global mutable variables you have to pass the state somehowe else between functions.
06:20:43 <quintessence> covi: so, one way to look at monads is that they give meaning to statements independent of context
06:21:11 <hiptobecubic> quintessence, independent? i would have said dependent on context
06:21:15 <quintessence> a statement in the State monad depends on (and possibly updates) some state, and returns a value
06:21:23 <covi> mroman: I understand this. But, don't you think StateOP { runStateOP :: s -> (a, s)} a better naming?
06:21:31 <hiptobecubic> as opposed to most functions, which are completely referentially transparent
06:21:43 <covi> It is an operation (function) that we wraps, not a 'state' itself
06:21:53 <quintessence> even if you don't know what state you're in, you can represent this as a function from the old state to the new state and the return value
06:21:57 <Franciman> the state is (a, s)
06:22:03 <Franciman> ( the second part )
06:22:13 <mroman> covi: Why?
06:22:28 <hiptobecubic> quintessence, yes ok. the action is independent. i was thinking of the value i guess
06:23:09 <quintessence> hiptobecubic: yeah, a bit of attachment ambiguity there. it gives "(meaning independent of the context) to a statement", but "meaning to a (context-dependent statement)"
06:23:19 <hiptobecubic> Franciman, isn't the state just 's'? that's the part you want to carry with you
06:23:25 <covi> mroman: you got me
06:23:40 <Franciman> hiptobercubic, yes I wrote ( the second part )
06:23:41 <Franciman> lol
06:23:48 <hiptobecubic> oh, :)
06:23:59 <covi> So any example of State values with >>= in play?
06:24:18 <Franciman> covi say you have got a parser
06:24:27 <hiptobecubic> here we go...
06:24:39 <Franciman> number >= letter
06:24:55 <hiptobecubic> what about something simpler
06:24:58 <Franciman> number parses the string s and returns ( aNumber, theRestOfTheString )
06:25:06 <Franciman> now
06:25:14 <Franciman> >= is something like
06:25:22 <hiptobecubic> >>=
06:25:43 <Franciman> :t >>=
06:25:45 <lambdabot> parse error on input `>>='
06:25:50 <Franciman> d'oh
06:25:52 <hiptobecubic> :t (>>=)
06:25:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:26:04 <Franciman> that's not the type, stupid me
06:26:20 <hiptobecubic> @src (>>=)
06:26:20 <lambdabot> Source not found.
06:26:27 <Franciman> however,
06:27:03 <mroman> > execState (modify (5:) >> get >>= (\(c:cs) -> put$ [c*3])) [1]
06:27:05 <lambdabot>   [15]
06:27:41 <mroman> > execState (modify (5:) >> get >>= (\(c:cs) -> put$ (c*3):c:cs)) [1]
06:27:42 <lambdabot>   [15,5,1]
06:28:27 <choi> I have a newbie question about the type signature of runIO from the HSH module
06:29:11 <mroman> covi: Is that what you were looking for?
06:29:43 <covi> mroman: well, I haven't learned execState, modify, get, and put
06:29:59 <mroman> I see.
06:30:02 <covi> Maybe I should read on LYAH first.
06:30:11 <mroman> get gives you the state, put sets the state, modify modifies the state
06:30:16 <mroman> and execState returns the final state.
06:30:59 <covi> by 'get gives you the state', do you mean 'get gives you a function that's called the state'?
06:31:42 <quintessence> :t get
06:31:43 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
06:31:58 <mroman> covi: State is a tupel (result,state)
06:32:09 <mroman> and get sets the result
06:32:20 <mroman> get s = (s,s); put x s = ((),x);
06:32:52 <covi> State is a tuple?!
06:32:53 <mroman> I'm not familiar with the official terminology so I hope somebody else can explain it in correct terms.
06:33:04 <Franciman> covi, no
06:33:09 <mroman> covi: Not really.
06:33:11 <Franciman> it's a function that returns a tuple
06:33:14 <mroman> It 'passes around' a tuple.
06:33:19 <covi> newtype State s a = State { runState :: s -> (a, s) }
06:35:07 <quintessence> covi: when people say "the state" they mean "the value of type s (in a State s a action)"; things of type `State s a` are "State actions" or "State monad values"
06:36:16 <quintessence> so "get", viewed from the pretend-imperative monad world, just returns the value of the shared state of the computation
06:37:34 <covi> quintessence: So, when people say the value of the State monad, do they mean the function or the tuple?
06:37:44 <quintessence> and its actual functional implementation is as "State (\s -> (s, s))", i.e. the State action represented by the function that returns a tuple containing two copies of its input
06:40:15 <quintessence> um, that's a little ambiguous, but usually when people say something like "the value of [some expression of type M a] in the M monad is..." they mean the "a" that's "inside it"
06:42:22 <covi> So the value of 'State $ \x -> (1, x)' is 1?
06:44:07 <quintessence> yeah, from the inside-the-State-monad view
06:44:33 <quintessence> that's the same sense in which the value of get is "the current state"
06:44:35 <hpc> covi: specifically, it is the same as "return 1"
06:46:02 <covi> hpc: then you mean the function '\x -> (1,x)', the thing behind 'State $'
06:46:20 <hpc> covi: no, the whole thing
06:46:35 <hpc> for State, return x = State $ \s -> (x, s)
06:46:37 <covi> oh i see
06:46:57 <covi> ok i see
06:47:16 <hpc> :D
07:03:27 <hape01> which HTTP client library are you using when you want to fetch html data from a web server?
07:03:49 <hape01> i heard HTTP-4000 is not lazy, and mini-http is deprecated...
07:06:24 <parcs`> http-conduit
07:07:10 <hape01> thank you
07:12:20 <k0ral> god I love Monad* typeclasses
07:12:36 <hape01> what is the meaning of *?
07:12:54 <k0ral> {IO,Error,Reader,State}
07:13:04 <hape01> fine
07:13:19 <k0ral> I've just dramatically reduced my overall code size while it performs the same job
07:13:29 <k0ral> I'm so amazed
07:17:23 <hape01> curl library is not got for windows. cant install. i think i go with http-conduit or http-enumerator
07:17:32 <fmap> k0ral: you've moved from errors to mtl?
07:20:26 <covi> I'm a newbie, and I think the do notation is not helping me to learn monads.
07:20:58 <k0ral> fmap: yes
07:21:03 <srhb> covi: Consider using (>>=) instead then.
07:21:07 <hape01> covi:  try (>>) and (>>=) first
07:21:10 <covi> I refuse to think in an intuitive way when facing do. Rather, I translate it into >>= and think about the implementation of >>=
07:21:19 <k0ral> fmap: I'm feed enlightened
07:21:31 <srhb> covi: That's much better anyway, but it becomes natural to think in both ways easily.
07:21:32 <k0ral> s/feed/feeling
07:21:39 <srhb> covi: Better for starting*
07:22:05 <latro`a> the frustrating thing about that on a large scale is that practical monadic code is often a huge mess of lambdas without do notation
07:22:08 <latro`a> *nested lambdas
07:22:50 <latro`a> but yes, your trouble is better than the other likely trouble, which is getting locked into an overly-imperative way of thinking about monads
07:23:34 <covi> locked, exactly the right word
07:25:32 <hpc> uh oh
07:25:33 <hpc> Warning: multiple versions of mtl provide Control.Monad.Reader, choosing the latest.
07:25:47 <hpc> is that bad? got it from "cabal init"
07:27:29 <Wibowit> hi, in learnyouahaskell.com there is a code:
07:27:31 <Wibowit> import Control.Monad.Instances
07:27:33 <Wibowit>   
07:27:35 <Wibowit> addStuff :: Int -> Int
07:27:37 <Wibowit> addStuff = do
07:27:39 <Wibowit>     a <- (*2)
07:27:41 <Wibowit>     b <- (+10)
07:27:43 <Wibowit>     return (a+b)
07:27:47 <Wibowit> how would it look witout do notation? i've tried: ((*2) >>= (\x -> x * 10 >>= (\y -> return (x + y)))) $ 3 but no luck
07:28:30 <Clint> @undo do a <- (*2); b <- (+10); return (a+b)
07:28:30 <lambdabot> (* 2) >>= \ a -> (+ 10) >>= \ b -> return (a + b)
07:28:44 <hpc> Wibowit: try keeping the formatting
07:28:48 <hpc> addStuff =
07:28:58 <hpc>     (* 2) >>= \a ->
07:29:06 <hpc>     (+ 10) >>= \b ->
07:29:13 <hpc>     return (a + b)
07:37:02 <Wibowit> hpc: thanks it worked, i'll now figure what happens by applying functions by hand :)
07:38:18 <covi> Wibowit: Hey man
07:38:41 <statusfailed> Is it generally a bad idea to put functions inside datatypes?
07:38:41 <Wibowit> ?
07:38:42 <covi> Wibowit: I'm also on that section too, trudging through the state monad
07:38:44 <Wibowit> hey
07:39:19 <covi> But my brain just exploded in front of the do notation. Can't read anything more tonight. Be warned
07:39:30 <covi> statusfailed: %
07:39:34 <covi> statusfailed: ^
07:39:47 <statusfailed> covi: eh?
07:39:52 <latro`a> statusfailed, not at all; that's actually rather standard idiom
07:39:59 <hpc> statusfailed: it's so incredibly not a bad idea that it's used just about everywhere
07:40:02 <hpc> @src State
07:40:03 <lambdabot> Source not found. Sorry.
07:40:07 <hpc> @src StateT
07:40:08 <lambdabot> Source not found. You speak an infinite deal of nothing
07:40:10 <hpc> pah
07:40:25 <statusfailed> But it means I can't really use "deriving"
07:40:37 <latro`a> what would you need to derive?
07:40:49 <statusfailed> Read/Show
07:40:50 <statusfailed> for laziness
07:40:52 <latro`a> uh
07:40:56 <latro`a> why?
07:41:11 <statusfailed> so I can look at the whole object in ghci :p
07:41:12 <Taneb> Is (>>) any different from (*>)
07:41:13 <Taneb> ?
07:41:13 <latro`a> neither of those actually make any sense
07:41:27 <latro`a> oh I see, you mean a type that has functions and other stuff
07:41:35 <statusfailed> yeah
07:41:39 <latro`a> some of which can be shown
07:41:42 <statusfailed> right
07:41:43 <latro`a> yeah *that* may not be a good idea
07:42:01 <latro`a> Read still doesn't make sense for a function, though
07:42:01 * hackagebot metadata 0.1.0.0 - metadata library for semantic web. (KatsutoshiItoh)
07:42:03 <Clint> Taneb: the latter is Applicative
07:42:15 <statusfailed> latro`a: sure, I can see that :)
07:42:25 <Taneb> Clint, beyond that. All Monads should be Applicatives too anyway
07:42:41 <Clint> Taneb: then "not really"
07:42:46 <Taneb> Okay
07:44:34 <quintessence> I've often wanted ghci to use something more widely applicable than Show to print values
07:47:01 <parcs`> Taneb: the precedence is different
07:47:22 <covi> can @undo figure out defined actions (functions)?
07:47:27 <Taneb> parcs`, is the effect the same?
07:47:38 <latro`a> covi: pretty sure @undo is purely syntax
07:47:47 <hpc> @undo f x = do {v <- x; v}
07:47:47 <lambdabot> f x = x >>= \ v -> v
07:48:04 <hpc> @undo f do {x; x} = do {v <- x; v}
07:48:04 <lambdabot>  Parse error at "do" (column 3)
07:48:16 <parcs`> Taneb: yeah they are identical
07:48:17 <covi> I mean sth like  do {v <- someAction; v}
07:48:25 <hpc> it's at least partially clever
07:48:39 <Clint> @undo do {v <- someAction; v}
07:48:40 <lambdabot> someAction >>= \ v -> v
07:48:56 <covi> ....
07:48:57 <geekosaur> covi, there doesn;'t really need to be magic to figure that out
07:49:01 <geekosaur> actions are not magic
07:49:05 <parcs`> @@ pl undo do { v <- someAction; v }
07:49:06 <lambdabot>  pl undo do { v <- someAction; v }
07:49:13 <parcs`> @. pl undo do { v <- someAction; v }
07:49:13 <lambdabot> join someAction
07:49:18 <geekosaur> heh
07:49:26 <geekosaur> "you must be doing something clever"
07:50:38 <latro`a> it'll take the name, but it won't know or do anything with it
07:50:45 <latro`a> just a syntactic transformation
07:50:58 <geekosaur>  @undo does purely syntactic transformations, it doesn't optimize the result to remove silliness like that.  arguably @pl's reaction is a bug but I couldn't tell you at what level
07:51:17 <Taneb> @src join
07:51:18 <lambdabot> join x =  x >>= id
07:51:28 <Taneb> @undo do {v <- someAction; v}
07:51:28 <lambdabot> someAction >>= \ v -> v
07:51:34 <geekosaur> (note that "do v <- someAction; v" is just "someAction"
07:51:43 <Taneb> Which goes someAction >>= id; join someAction
07:51:48 <Taneb> Hence I am confused
07:51:50 <latro`a> er, geekosaur
07:51:51 <latro`a> no
07:51:53 <latro`a> very much no
07:52:00 <Clint> return
07:52:00 <latro`a> you need a return for that to be the case
07:52:09 <Taneb> Ahah!
07:52:18 <latro`a> do v <- someAction; return v is someAction; @pl's reaction was correct
07:52:20 <geekosaur> hm, right
07:52:31 <geekosaur> I'm trting to elide an id at the wrong level, sorry
07:53:24 <wi`> @pl \a b -> a b
07:53:24 <lambdabot> id
07:53:30 <wi`> @unpl id
07:53:30 <lambdabot> (\ a -> a)
07:53:39 <MagneticDuck> hiah... I just got started with haskell development in EclipseFP yesterday
07:53:45 <MagneticDuck> pretty cool and suits my needs
07:53:52 <MagneticDuck> however...
07:53:58 <MagneticDuck> syntax highlighting is not working
07:54:07 <MagneticDuck> is this the place to ask this question?
07:54:11 <hpc> MagneticDuck: are you on windows, linux, mac?
07:54:18 <MagneticDuck> hah
07:54:23 <MagneticDuck> forgot that >_<
07:54:27 <MagneticDuck> Ubuntu Linux
07:54:32 <MagneticDuck> 12.04
07:54:32 <Taneb> You need something...
07:54:35 <hpc> ah
07:54:37 <Taneb> I had this problem too
07:54:57 <Taneb> scion-browser?
07:54:58 <hpc> i suggest not using eclipseFP then, since there's better alternatives
07:55:05 <MagneticDuck> there are..?
07:55:12 <hpc> my probably-not-helpful advice would be to take the time to learn vim
07:55:17 <MagneticDuck> nono
07:55:18 <MagneticDuck> I know vim
07:55:21 <hpc> ah
07:55:24 <MagneticDuck> but I wanted something graphical
07:55:29 <MagneticDuck> to manage a big project
07:55:31 <hpc> then.... no idea
07:55:35 <MagneticDuck> I'm using vrapper actually
07:55:43 <parcs`> gvim ;)
07:55:46 <MagneticDuck> heh
07:55:52 <MagneticDuck> I mean something like Eclipse
07:55:53 <hpc> haha
07:55:54 <MagneticDuck> a real IDE
07:56:00 <parcs`> *slap*
07:56:13 <parcs`> but seriously, try emacs
07:56:14 <hpc> i was never able to get eclipseFP to do more than cause crashes
07:56:23 <statusfailed> parcs`: >_>
07:56:25 <MagneticDuck> mm.. it seems to work fine
07:56:25 <parcs`> it has haskell-mode, ghc-mod, etc
07:56:35 <parcs`> magicman: really it's quite nice
07:56:42 <MagneticDuck> hmm
07:56:45 <MagneticDuck> I never really tried it
07:56:50 <statusfailed> Wasn't someone developing a haskell-specific IDE?
07:56:55 <hpc> leksah
07:56:55 <MagneticDuck> does.. it has vi key bindings and modes?
07:57:00 <hpc> it's dead, mostly
07:57:01 <parcs`> nope
07:57:06 <statusfailed> Aw
07:57:09 <Clint> viper
07:57:11 <parcs`> well there are extensions
07:57:15 <MagneticDuck> okay
07:57:22 <MagneticDuck> :|
07:57:25 <MagneticDuck> not sure what to do
07:57:30 <Clint> are haskell-mode and ghc-mod complementary?
07:57:37 <parcs`> yeah
07:57:38 <hpc> honestly, just use a terminal with vim/ghci/cabal/cabal-dev/etc
07:57:51 <MagneticDuck> well that's what I was doing
07:58:22 <Taneb> There's Leksah
07:58:52 <MagneticDuck> okay
07:59:06 <MagneticDuck> what can it do that eclipseFP can't?
07:59:11 <Taneb> I dunno
07:59:14 <Taneb> I use EclipseFP
07:59:20 <Taneb> I remember having that exact problem, too
07:59:26 <MagneticDuck> what was the fix?
07:59:28 <Taneb> Can't remember how I solved it :(
07:59:33 <MagneticDuck> for now, I think I might as well try eclipse
07:59:42 <MagneticDuck> maybe I'll end up using something else in a bit
07:59:45 <Taneb> Try cabal install scion-browser
07:59:46 <MagneticDuck> but I need to see for myself
07:59:49 <MagneticDuck> okay
08:00:11 <MagneticDuck> yeah I got an error
08:00:15 <MagneticDuck> that scion wasn't installed
08:00:32 <MagneticDuck> but it wanted to install it every time I restarted eclipse
08:00:39 <Taneb> That sounds like it?
08:00:44 <MagneticDuck> there was something about going in the preferences...
08:00:52 <Taneb> cabal install scion
08:02:02 * hackagebot certificate 1.2.4 - Certificates and Key Reader/Writer (VincentHanquez)
08:02:12 <MagneticDuck> returns an error
08:02:19 <MagneticDuck> seems like a dependency error
08:02:25 <Taneb> Solve the error and you will have your solution
08:02:51 <MagneticDuck> :|
08:02:59 <geekosaur> would possibly help if you pastebinned the error, and possibly the output of "ghc-pkg list"
08:03:02 <geekosaur> @hpaste
08:03:02 <lambdabot> Haskell pastebin: http://hpaste.org/
08:03:53 <Taneb> :t let f 0 = () in f
08:03:54 <lambdabot> forall t. (Num t) => t -> ()
08:04:27 <hpaste> MagneticDuck pasted “scion install error” at http://hpaste.org/72253
08:04:48 <MagneticDuck> that's the error I get after the command
08:04:55 <MagneticDuck> sudo cabal install scion
08:05:07 <Taneb> You shouldn't sudo cabal
08:05:21 <MagneticDuck> okay
08:05:33 <hpc> or if you do, make sure it's --global
08:05:36 <MagneticDuck> same error w/out su
08:06:06 <MagneticDuck> and after it's installed, where is the executable?
08:06:49 <MagneticDuck> any ideas?
08:06:57 <MagneticDuck> I don't know what I'm looking at
08:06:58 <MagneticDuck> >_<
08:07:04 <covi> Does this post qualify for a clear explanation on monads? http://kawagner.blogspot.com/2007/02/understanding-monads-for-real.html
08:07:38 <hpc> no
08:08:20 <geekosaur> hrm, that looks like compatibility issues
08:08:23 * geekosaur pokes at hackage
08:08:28 <hpc> "a monad is a code transformation" -- this is, if not incorrect, incredibly misleading
08:09:02 <MagneticDuck> a code transformation?
08:09:09 <latro`a> that's really terrible, yeah
08:09:17 <bitonic> yeah that article is funny.  it even goes as far as writing CPP macros to show how it is a code transformation
08:09:20 <parcs`> more people should not blog
08:09:21 <geekosaur> uggggh, you lose
08:09:23 <latro`a> it's a macro in the sense that anything that isn't assembly is a macro >.<
08:09:23 <geekosaur> ghc (≥6.10 & <6.12)
08:09:31 <geekosaur> has scion not been updated?
08:09:34 <bitonic> and lisp macro.  lol
08:09:34 <MagneticDuck> in the same way that a functor is a code transformation of manually implementing fmap right there and then for the type?
08:09:46 <dobblego> that whole article is quite misleading, I hate explanations that are worse than air :(
08:09:57 <bitonic> I think he's explaining do notation, not monads
08:10:06 <covi> hpc: the link is provided here http://www.haskell.org/haskellwiki/Typeclassopedia#Instances_3
08:10:09 <otters> but who the hell knows
08:10:28 <covi> Perhaps you guys should remove the link?
08:10:32 <geekosaur> MagneticDuck, looks like you can't install scion from cabal, it's too old.  the git repo is up to date.  https://github.com/nominolo/scion
08:10:44 <dobblego> bitonic: I think he is confused, but if he is explaining do-notation, then it is very unhelpful to a naive reader
08:11:08 <bitonic> dobblego: I don't think many people will read that anyway.
08:11:15 <hpc> covi: not seeing the link
08:11:34 <covi> hpc:  search for 'Understanding Monads. For real' in the page
08:11:49 <latro`a> the language metaphor is old but OK, though
08:12:02 * geekosaur still likes "you could have invented monads"...
08:12:13 <dobblego> bitonic: "almost as good as air, but not quite" is still worse than air :)
08:12:14 <bitonic> geekosaur: dan piponi!  yeah that's probably the best tutorial
08:12:28 <latro`a> the problem with the language metaphor is that every monadic language has idioms with the same structure
08:12:32 <latro`a> and different underlying semantics
08:12:37 <latro`a> which is how you get all the M functions
08:12:48 <hpc> oh, Cale gave it the seal of approval
08:12:53 <hpc> so it must be doing something right later on
08:13:10 <latro`a> oh dear
08:13:16 <dobblego> I think Cale is just being generous
08:13:21 <hpc> starting with "it's a macro" just put me to sleep though
08:13:32 <latro`a> he rewrites a Maybe do block into an "if null then ... else ... fromJust ..."
08:13:36 <latro`a> /wrists
08:13:43 <hpc> ...ow
08:13:45 <hpc> my brain
08:13:46 <latro`a> eh, s/null/isNothing
08:14:01 <bitonic> hpc: Cale gave it the seal of approval?
08:14:23 <hpc> scroll down to the first comment
08:14:24 <dobblego> http://kawagner.blogspot.com.au/2007/01/real-functional-programming-or-why-io.html
08:14:27 <dobblego> he is clearly very confused
08:15:44 <latro`a> ...ow
08:15:46 <latro`a> my...what
08:15:56 <bitonic> hpc: oh, you're right.  I might have to read the whole thing then :P
08:15:59 <ski> covi,hpc : a monad is not a code transformation. the `do'-notation syntactic sugar for monadic actions in Haskell is -- but that's just a convenience
08:16:03 <latro`a> "let v = getStr" binds v to a different variable at each invocation
08:16:06 <latro`a> kill me now
08:16:09 <hpc> ski: ...i know
08:16:31 <latro`a> he's saying that, say, (>>=) = concatMap is a code transformation
08:16:32 <ski> (you said "if not incorrect, incredibly misleading", which wasn't enough damning :)
08:16:56 <latro`a> which is, again, making everything that isn't assembly (or if you like binary) a code transformation, more or less
08:17:03 <hpc> ski: ah, didn't mean to imply it was correct
08:17:22 <hpc> meant to imply that i hadn't bothered to see if it was making a semi-reasonable point later on
08:17:42 <hpc> "it's either incorrect, or misleading" -- better
08:18:10 <dobblego> semi-reasonable points are the worst kind
08:19:08 <ski> latro`a : i can't see that
08:20:02 <ski> (in none of the cases which `concatMap' appers in that document do they appeat to say that `(>>=) = concatMap' is a code transformation)
08:20:28 <latro`a> um
08:20:49 <latro`a> it's shortly after the isNothing garbage
08:22:02 * hackagebot fay 0.3.1.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
08:22:04 <ben> jesus, that monad article
08:22:08 <ben> clearly we need more tutorials
08:22:45 <luite> wow chrisdone is on a roll :)
08:22:46 <geekosaur> why can't we redirect people into writing lousy compilers instead of lousy monad articles?
08:23:05 <ski> "We could also say 'The maybe monad is an abstraction to represent computations which can fail'." is ok. "True, thats what macros do: Create new abstractions. Without remembering that a monad is just a kind of macro this sentence would sound quite 'arcane'." is nonsense
08:24:04 <hpc> if he did s/macro/abstraction/g
08:24:21 <ski> macros is a way to make *syntactic* (in Lisps, in the sense of abstract syntax) abstractions
08:24:22 <hpc> the article would immediately be better
08:24:31 <quintessence> geekosaur: beats me, I find writing lousy compilers much more tempting than writing lousy monad articles
08:24:35 <ski> the monad abstraction is not a syntactic abstraction
08:24:44 <dobblego> I'm pretty sure you cannot save that article
08:24:51 <ski> the `do'-notation sugar for monadic actions *is* a syntactic abstraction
08:25:16 <latro`a> in an unbelievably convoluted way you could define it as a syntactic abstraction, but if that's the case then the term "syntactic abstraction" becomes so meaningless as to be useless
08:25:21 <ski> so the confusion seems to be because of confusing the monad abstraction with the `do'-notation (syntactic) abstraction
08:25:55 <latro`a> (again, anything that isn't the actual instructions performed by the processor is *TECHNICALLY* a syntactic abstraction, in that the compiler eventually converts it into that syntax)
08:25:56 <hpc> ski: i don't think so, because he goes on to define bind in... C++ i think
08:25:59 <latro`a> (but thinking that way is unhelpful)
08:26:03 <noteventime> latro`a: In the sense that any theory is a syntax for its models?
08:26:10 <latro`a> pretty much, yes, noteventime
08:26:19 <ski> latro`a : "in an unbelievably convoluted way you could define it as a syntactic abstraction" -- "it" being ?
08:26:28 <latro`a> the monad abstraction
08:26:58 <ski> i don't really agree
08:27:18 <latro`a> rather, any given monad abstraction
08:27:20 <latro`a> is that
08:27:30 <ski> hpc : you don't think what ?
08:27:43 <noteventime> I haven't checked the article, but it sounds like one of the usual kind of stupid anti-intellectualism that seems to be common among programmers
08:27:46 <latro`a> the monad abstraction as a whole is then these substitutions in the setting of a common interface, but then interfaces can be treated as just sugar as well
08:28:01 <hpc> ski: i don't even know anymore - my brain is overexposed to that blog post, and turned to mush
08:28:10 <latro`a> once you start calling everything sugar, nothing isn't sugar
08:29:06 <ski> (s/any given monad abstraction/any given monad/ ?)
08:29:15 <latro`a> the abstraction granted by any given monad
08:33:15 <wi`> when i apt-get remove --purge ghc and cabal-install and reinstall them it appears that there are still some packages somewhere because i get conflicts, does anybody know where i could find them so i can delete them and completely start over?
08:33:50 <geekosaur> ~/.ghc
08:34:14 <wi`> already rm -r'ed that
08:34:21 <wi`> as well as .cabal
08:34:53 <Saizan> .ghc
08:35:04 <geekosaur> what does "ghc-pkg check" say, then?
08:35:58 <wi`> nothing at all
08:40:16 <Guest62319> i know with strings you can use a bunch of compose String -> String functions to make building strings from templates more efficient
08:40:20 <Guest62319> what about Text?
08:40:26 <Guest62319> does it work the same way
08:41:15 <mietek> Guest62319: perhaps you'd like to look into Blaze Builder
08:41:56 <noteventime> Blaze is awesome :)
08:42:23 <Guest62319> its bytestrings...
08:42:27 <geekosaur> wi`, so when do you get conflicts then?  installing something?  pastebin the whole error/log from the build attempt
08:43:15 <mietek> Guest62319: well, there's fromText :: Text -> Builder
08:43:20 <wi`> geekosaur: i'll do that
08:44:49 <Guest62319> all the functions in Data.Text say 'subject to fusion'
08:44:59 <Guest62319> im not sure when this applies and when it doesnt
08:45:13 <wi`> geekosaur: http://pastebin.com/KgSJ95Ce
08:45:19 <mauke> The paste KgSJ95Ce has been copied to http://hpaste.org/72254
08:45:22 <Guest62319> i can imagine a single function being optimized, but if a Text operation is defined in terms of several independent functions will there be a fusion optimization?
08:45:46 <wi`> btw, i did try installing the missing dependencies and --reinstalling one of the packages
08:46:30 <geekosaur> rrrgh.  yes, I think debian doesn''t mark package.conf.d as a configuration directory so it doesn't get removed with apt-get purge
08:46:41 <wi`> ahh
08:47:11 <geekosaur> lemme find the correct path to remove manually
08:48:32 <bartavelle> is there a known function that sorts and deduplicate a list ?
08:48:53 <wi`> geekosaur: /usr/lib/ghc/package.conf.d?
08:48:59 <geekosaur> yeh
08:49:02 <sykora> bartavelle: nub . sort?
08:49:08 <bartavelle> ah nub
08:49:09 <bartavelle> thanks
08:49:12 <geekosaur> bartavelle, not both at the same time.  that, or map head . group . sort
08:49:19 <geekosaur> (nub doesn;t sort)
08:50:41 <wi`> cd /var/lib/
08:53:34 <wi`> remove ghc, so there has to be some other directory
08:53:55 <wi`> geekosaur: /usr/lib/ghc and /var/lib/ghc appear to get obliterated when i apt-get
08:53:55 <wi`> remove ghc, so there has to be some other directory
08:56:05 <Clint> what does `ghc-pkg list` tell you?
08:56:06 <geekosaur> interesting.  /var/lib/ghc/package.conf.d and maybe ... oh, did you run cabal as root at some point?  try /root/.ghc
08:56:23 <geekosaur> (that is, see if there are packages under that directory)
08:57:21 <hpaste> asd pasted “asd” at http://hpaste.org/72255
08:57:33 <wi`> thats the output of ghc-pkg list
08:57:39 <wi`> cd /root
08:58:35 <geekosaur> (I would suggest a bug in debian if it's seeing *any* user packages in the dpkg-reconfigure step, even root's, but ghc-pkg has been known to have its own bugs in that arena)
08:58:40 <wi`> hmm, good 1, /root contains its own .cabal and .ghc directories as well
09:00:33 <monochrom> "sudo cabal install" defaults to the user called "root" because the default is --user and "sudo" is user "root"
09:03:03 <monochrom> I think it's time to read my http://www.vex.net/~trebla/haskell/sicp.xhtml to find out all kinds of facts defying your expectations. at least the first half
09:03:37 <wi`> deleting .ghc and .cabal in /root seem to have worked, thanks :)
09:03:46 <covi> What does | mean here : class MonadState m s | m -> s where
09:04:03 <wi`> thats used for a functional dependency
09:04:11 <geekosaur> covi, it's a functional dependency.  "if you know the type of m, you know the type of s"
09:04:19 <geekosaur> (for "you" = "the compiler")
09:04:27 <wi`> the | m -> s indicates that the type of s is uniquely determined by m
09:04:44 <covi> I see
09:04:45 <covi> thanks
09:04:50 <geekosaur> so the compiler can infer types when it sees a MonadState without having to always be told
09:04:50 <ski> covi : it means that for each type `m', there can be at most one type `s' with an instance `MonadState m s'
09:05:03 <wi`> theres an article on haskellwiki explaining the extension
09:05:04 <ski> logically : `forall m. unique s. MonadState m s'
09:05:29 <ski> which is short for `forall m s0 s1. (MonadState m s0,MonadState m s1) => s0 = s1'
09:06:37 <quintessence> the useful effect of this is that if you just know `m`, you can figure out *which instance to use* and what type `s` must be
09:06:37 <covi> ski: what is the 'forall' syntax called? I see it in lambdabot's :t, but not Prelude's
09:06:54 <applicative> Guest62319: the Text functions are of the form f_text = unstream . f_stream . stream , g_text = unstream . g_stream . stream
09:07:00 <wi`> monochrom: thanks for the link, im reading it now
09:07:11 <wi`> it seems to be quite useful
09:07:12 <applicative> Guest62319:  so f_text . g_text = unstream . f_stream . stream . unstream . g_stream . stream = unstream . f_stream . g_stream . stream and so on
09:07:31 <ski> covi : the `forall' is universal quantification. in type signatures it's (usually) used to express that the operation is polymorphic
09:07:37 <applicative> Guest62319: ; we hope the compiler will recognize the second identity via the 'rules'
09:08:09 <ski> covi : consider `take :: Int -> [a] -> [a]' -- this really means that for *any* type `a' you want, `take' can have that type
09:08:38 <Guest62319> applicative: if the length this composition cant be determined at compile time?
09:08:39 <covi> ski: so ghc understands this right?
09:08:54 <ski> covi : e.g. `take :: Int -> [String] -> [String]' in case `a' is `String'; `take :: Int -> [Maybe Double] -> [Maybe Double]', in case `a' is `Double'; &c.
09:08:57 <quintessence> covi: GHCi just leaves it implicit at the top level of a type, while lambdabot prints it out
09:09:09 <quintessence> for instance, try :t Control.Monad.ST.runST
09:09:28 <ski> covi : now, in Haskell 98, in a type signature like `take :: Int -> [a] -> [a]', it is implicit that this is supposed to hold for *every* type `a'
09:09:53 <ski> covi : however, with extensions, it is also possible to write this explicitly, like `take :: forall a. Int -> [a] -> [a]'
09:09:53 <applicative> Guest62319: it is a bit of a labor to make sure the chain isn't broken.  If it really does 'unstream', rather than 'stream . unstream' being deleted, then a new array  must be written
09:10:06 <covi> ski: got it
09:10:56 <ski> covi : now, the ability to write `forall' explicitly gives you more power than you had before, since you can now place the `forall' in other places than "just after the `::'" in type signatures
09:11:11 <Guest62319> applicative: f_text foo . unstream . stream . g_text foo . unstream ... will work?
09:12:05 <applicative> that's a perfectly good function, but you don't want to evalueate it for a Text (an array of some sort) , since the unstream in the middle means "write a new array'
09:12:36 <Guest62319> maybe i mixed it up
09:12:38 <applicative> Guest62319: so the RULES say things like: when you see "unstream . stream" write "id" and go on from there
09:12:43 <ski> covi : anyway, the `take' operation above is *polymorphc*, literally meaning "many shaped", i.e. one can think of `take :: forall a. Int -> [a] -> [a]' as a shorthand for `take :: Int -> [String] -> [String]',`take :: Int -> [Maybe Double] -> [Maybe Double]',&c. for every possibly type which `a' could be
09:13:08 <ski> covi : and that `take' is polymorphic means that the *caller* of `take' decides which type `a' to use in each case
09:13:29 <hpaste> neothemachine pasted “Types” at http://hpaste.org/72256
09:13:34 <ski> covi : however, there are some cases in which one wants the *argument* of a function to be polymorphic -- and then you *need* the `forall' syntax
09:13:38 <Guest62319> how does fusion work anyway, how does it know how much to allocate at the beginning of a fused computation
09:14:05 <neothemachine> hi all, can someone explain my paste? I don't understand the types..
09:14:44 <applicative> Guest62319: the composition of stream operations doesn't require array allocation; streams are like little state machines or something.
09:14:53 <covi> For a function func :: State a b   func = do x <- get; x
09:15:02 <covi> I wonder if x is the value of type a or b
09:15:10 <Guest62319> applicative: oh
09:15:14 <applicative> Guest62319: what you are trying to do is get a bunch of array operations to be stream operations.
09:15:17 <geekosaur> neothemachine, because the Parser type already includes it
09:15:31 <Guest62319> applicative: yes
09:15:33 <ski> covi : well, at least `a'
09:15:36 <latro`a> neothemachine, you definitely get a list at the end, so the result type would be [c]
09:15:52 <covi> ski: at least?
09:15:52 <latro`a> but since the last argument type is (Int,Int), Parser c is valid as well
09:15:57 <ski> covi : though it's more common to name the type variables like `State s a' or `State state a'
09:16:02 <latro`a> because of the right-associativity of (->)
09:16:11 <Guest62319> applicative: im having hard to seeing if my normal looking code will do that
09:16:19 <neothemachine> latro`a: could I write this function in a different way?
09:16:46 <ski> covi : and then `get :: State s s' (the initial `State s' being the monad), and so `x' get's the type of the part after `State s', which is also `s' in this case
09:17:06 <ski> covi : it depends on what you're writing after `x <- get;'
09:17:10 <applicative> Guest62319: there are several reasons for this, among them that the stream operations are unrelentingly non-recursive
09:17:13 <hpc> :t join get
09:17:14 <lambdabot> forall (m :: * -> *) a. (MonadState (m a) m) => m a
09:17:21 <hpc> huh, it actually typechecks
09:17:32 <applicative> Guest62319: , so after the rewrite rules kick in, God willing,  ghc's usiual  optimization machinery can be especially savage.
09:17:37 <ski> covi : normally, one wouldn't just write `x' there -- `return x' would be less strange
09:18:19 <ski> @type (StateT . runStateT) (join get)
09:18:20 <lambdabot> Top level:
09:18:20 <lambdabot>     Occurs check: cannot construct the infinite type: s = StateT s m a
09:18:20 <lambdabot>       Expected type: StateT s m a
09:18:39 <covi> ski: if it gets the type after 'State s', that means the value inside the State s monad, right? And that's the behavior of <- in the do block?
09:20:10 <covi> getAny :: (Random a) => State StdGen a
09:20:12 <covi> getAny = do g      <- get (x,g') <- return $ random g put g' return x
09:20:27 <ski> covi : nitpick, there is no "the value inside the State s monad" -- there may be a value (not really) "inside" an `State s'-*action* (which is a value of type `State s Foo' for some type `Foo'); alternatively, maybe by "the value inside the State s monad" you really meant the *type* `a'/`Foo' in `State s a'/`State s Foo' ?
09:20:32 <covi> This is what I read from haskellwiki. It seems that  g <- get actually gets the state
09:20:35 <neothemachine> latro`a: ah I see, I could also write :: (b -> c) -> Parser b -> (Int,Int) -> [c]
09:20:39 <gertc> what are the numbers for in a error message ? (a0 -> b0) -> b0 why not (a -> b) -> b
09:20:41 <latro`a> correct
09:21:03 <hpc> gertc: it's just how ghc automatically assigns names
09:21:08 <ski> covi : yes, the point of `get' is getting the state
09:21:08 <applicative> Guest62319: unfortunately there doesnt seem to be a good tutorial sort of essay on how to use these fusion libraries, text and vector, and by extension repa
09:21:08 <hpc> when something isn't explicit
09:21:09 <neothemachine> makes sense..
09:21:17 <latro`a> neothemachine, if you used a newtype, this wouldn't happen
09:21:30 <latro`a> that is, (Int,Int) -> [b] and Parser b would not be interchangeable
09:21:35 <latro`a> this may or may not actually be desirable
09:21:43 <hpaste> EvanR pasted “text computations” at http://hpaste.org/72258
09:21:46 <gertc> hpc: is it always 0?
09:21:57 <Guest62319> applicative: ^
09:22:16 <covi> ski: But you said it gets the part after State s, which is the value not the state? I'm confused by <- here :(
09:22:18 <hpc> not always
09:22:25 <neothemachine> latro`a: I see, what could I then use? the original one or the other one?
09:22:45 <hpc> i actually don't know ghc's name generation very well
09:23:04 <Guest62319> applicative: T.concat . concat . map encodeFragment $ frags
09:23:07 <latro`a> if you did that, you'd have to pattern match on your new constructor, and only the (b->c)->Parser b->Parser c type would work
09:23:11 <gertc> hpc: until it reaches z?
09:23:16 <hpc> but i know it generates names for things when one isn't explicitly given, or when there's name shadowing
09:23:24 <nand`> I often see t, t0, t1, t2 etc.
09:23:37 <nand`> it's a bit annoying, I'd prefer GHC assign names like ‘a’ ‘b’ ‘c’
09:23:48 <nand`> until it runs out of letters
09:24:19 <gertc> ok thx
09:24:20 <quintessence> hpc: it's in the "secrets of the ghc inliner" paper.  Basically, when it wants to substitute an `a` into a context where `a` is bound, it tries `a1`, `a2`, ... until it finds one that's free
09:24:32 <hpaste> applicative annotated “text computations” with “text computations with OverloadedStrings” at http://hpaste.org/72258#a72259
09:24:52 <quintessence> but it's true that it'd be nice to do an alpha pass before showing it to the user and end up with nice letters for names
09:24:56 <Guest62319> thanks
09:25:05 <nand`> quintessence: exactly, picking nice names should be the last step
09:26:23 <quintessence> well, ghc actually uses names internally too, and given that they're semi-resonable it's not that bad to just output them
09:26:47 <quintessence> if it used debruijn indices internally they'd have been forced to prettify types when printing them
09:26:51 <applicative> Guest62319: there isn't much scope for fusion here yet.  It would depend how you went on, I think
09:27:36 <applicative> Guest62319: encode = unstream . somestreamunfold . listoperations ...
09:28:08 <ski> covi : "which is the value not the state" -- you mean "which is the value (well, result) *type*, not the state *type*"
09:28:09 <Guest62319> i think im going to replace CText [CFrag] with CText (CFrag -> CFrag)
09:28:38 <ski> covi : the general idea with `<-' is that in `val <- act', if `act :: m a', where `m' is a monad, then `val :: a'
09:29:13 <applicative> so now if you use somefurther Text function foo . encode it'll be  unstream . foo_stream . stream . unstream . somestreamunfold . listoperations ... and stream.unstream can be killed
09:29:24 <ski> covi : in the case of `act' being `get', the type of that in your case was `State s s', so `m' is `State s', and `a' is `s', and so in `x <- get', `x :: s'
09:30:04 <Guest62319> applicative: encode is probably going to be fed finally to a socket
09:30:06 <ski> covi : this is because the type variable `s' in `get :: State s s' is used *both* in "state type position" (the first position), and "monadic result position" (the second position)
09:30:13 <Guest62319> no more computation done with it
09:31:01 <applicative> Guest62319: Yeah, I do think interpolating list things is a bad idea, but I'm not sure it really matters here.  There is still likely a win from Text, since the packed things are tiny com[pred to String
09:31:06 <applicative> compared
09:31:47 <Guest62319> ah yeah, String
09:31:48 <covi> ski: I see. So generally, get returns the first element of the passed tuple. The reason that get gets the state is because \s -> (s, s)
09:33:14 <Guest62319> dont want to use String because part of the data will come from storage in terms of Text
09:33:36 <Guest62319> i guess i could mix it all up
09:34:37 <hpc> covi: not so much that "get" gets the first element of the passed tuple as that it puts that state there
09:34:55 <hpc> the general shape of state actions is (State $ \oldState -> (value, newState))
09:35:11 <hpc> "get" puts the old state into both the value and newState slots
09:36:59 <covi> got the idea  :)
09:37:04 <covi> THanks hpc !
09:38:24 <applicative> Guest62319: This seems good to me, I think a more complete program would make clear if the use of lists was getting in the way, or reciprocally if the use of arrays+streams  is  in the way
09:38:51 <applicative> Guest62319: the trouble, I think, is that there are really good optimizations either way, but they sort of compete.
09:39:46 <Guest62319> working on it ;)
09:39:53 * edwardk waves hello.
09:40:20 <Guest62319> right now im having fun putStrLning the colored text lol
09:40:48 <edwardk> by hand? or are you using terminfo, etc?
09:41:26 <Guest62319> \ESC[30m etc
09:41:42 <edwardk> ah
09:42:18 <aristid> Guest62319: i think there are a couple haskell packages that do this for you
09:43:12 <LnL> Can someone explain why I can't do this?
09:43:12 <LnL> https://gist.github.com/3193958
09:44:08 <ski> covi : .. yes
09:44:08 <Guest62319> is there a standard way to replace ++ with mappend
09:44:12 <nh2> I can't cabal install anything, getting "cabal: Couldn't read cabal file "HUnit/1.2.5.0/HUnit.cabal"". Somebody knows what to do?
09:44:15 <edwardk> what can't you do?
09:44:19 <Guest62319> to redefine ++ as mappend
09:44:25 <edwardk> Guest62319: just use (<>)
09:44:31 <Guest62319> oh
09:44:36 <edwardk> Guest62319: that was why we added it ;)
09:44:40 <Guest62319> > [1,2] <> [3]
09:44:41 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
09:44:41 <lambdabot>         agains...
09:44:46 <Guest62319> wuuuut
09:44:52 <edwardk> lambdabot is from before that was added
09:45:00 <edwardk> its in Data.Monoid
09:45:09 <ski> @type (<>)
09:45:10 <lambdabot> Doc -> Doc -> Doc
09:45:16 <aristid> LnL: what's the error?
09:45:16 <Taneb> @hoogle (<>)
09:45:17 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
09:45:17 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
09:45:17 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
09:45:24 <Taneb> None of those
09:45:27 <edwardk> this is the hughesPJ one, which was part of the bottleneck of getting (<>) accepted
09:45:29 <ski> @type (Data.Monoid.<>)
09:45:30 <lambdabot> Not in scope: `Data.Monoid.<>'
09:45:32 <LnL> aristid: Illegal instance declaration for `Tag [Attribute]'
09:46:07 <aristid> LnL: it probably also suggests that you need FlexibleInstances?
09:46:40 <edwardk> yeah you just need flexible instances
09:46:45 <LnL> aristid: Hmm, yes
09:46:49 <edwardk> or, you can be a little trickier about it
09:46:54 <LnL> what does that mean?
09:46:59 <aristid> LnL: but how about this? instance Tag a => Tag [a]
09:47:00 <edwardk> instance Tag a => Tag [a] where
09:47:13 <edwardk> then you don't need flexible instances and your code can do more
09:47:19 <edwardk> so now [[Attribute]] is a legal Tag
09:47:35 <ski> edwardk : though translated a bit strangely :)
09:47:41 <aristid> it just depends what semantically makes more sense
09:48:11 <edwardk> LnL: the main problem is that the original Haskell 98 required that all instances have the form (Foo a b c d) where only the top level was a constructor and all other things were distinct variables
09:48:18 <edwardk> it makes the instance lookup very easy
09:48:19 <ddarius> Semantics is for the weak.
09:48:38 <ski> LnL : an alternative might be to add just a function `listToHTML :: Tag a => [a] -> String' -- or maybe add it as a method in `Tag'
09:48:41 <edwardk> now, most haskell implementations allow for FlexibleInstances, which basically lets you write mostly anything there
09:49:06 <edwardk> Now, the usual fix would be to realize that we might want to treat lists of lists differently and edit the class so that
09:49:25 <aristid> ddarius: do you propose category theory as the alternative for hard people, then?
09:49:25 <edwardk> class Tag a where toHTML :: a -> String; listToHTML :: [a] -> String
09:49:27 <edwardk> an then
09:49:35 <Guest62319> can i use overloaded strings in ghci
09:49:47 <edwardk> instance Tag a => Tag [a] where toHTML = listToHTML
09:50:01 <edwardk> thats the trick taken by 'Show'
09:50:05 <edwardk> it works pretty well in that
09:50:13 <edwardk> > ["Hello"]
09:50:14 <lambdabot>   ["Hello"]
09:50:19 <LnL> hmm, makes sense I guess
09:50:20 <aristid> edwardk: why not just use FlexibleInstances these days tho?
09:50:22 <edwardk> is using the [[Char]] instance of Tag
09:50:33 <ddarius> aristid: I propose no semantics as the alternative.
09:50:57 <edwardk> aristid: in practice? mostly because its harder to screw up and wind up with overlap ;)
09:51:29 <aristid> edwardk: i think in LnL's case maybe it doesn't even make sense to have both in the same typeclass
09:51:34 <edwardk> probably not
09:51:40 <aristid> because an attribute in itself isn't valid HTML
09:51:46 <edwardk> just giving him a laundry list of solutions
09:52:50 <LnL> As you might have guessed I have almost zero experience with Haskell and am just trying to make something "simple"
09:53:44 <edwardk> LnL then just add  {-# LANGUAGE FlexibleInstances #-} to the top of the file
09:54:40 <LnL> So that's an ok solution, or should I use `Tag a => Tag [a]` ?
09:54:55 <Guest62319> yesss -XOverloadedStrings works in ghci
09:59:21 <ddarius> @let bp p n = case n `quotRem` p of (0,r) -> [r]; (q,r) -> r:bp p q
09:59:23 <lambdabot>  Defined.
09:59:29 <ddarius> > bp 3 9
09:59:31 <lambdabot>   [0,0,1]
09:59:47 <edwardk> either works for your existing code
10:03:31 <ghorn> i may have found a ghc bug
10:03:54 <hpaste> ghorn pasted “ghc parse fail?” at http://hpaste.org/72260
10:03:58 <ddarius> @let vdC p n = map (\i -> sum (zipWith (/) (bp p i) (iterate (p*) p))) [0..n]
10:04:00 <lambdabot>  Defined.
10:04:36 <geekosaur> if you have, #ghc might be more appropriate.  but that doesn't look like a bug to me
10:04:53 <ddarius> > vdC 3 9
10:04:54 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:04:54 <lambdabot>    `GHC.Real.Fractional t'
10:04:54 <lambdabot> ...
10:05:03 <ddarius> :t vdC
10:05:04 <lambdabot> forall a. (Fractional a, Integral a) => a -> a -> [a]
10:05:14 <ghorn> when i load it in ghci it says something about malformed expression then throws an exception
10:05:23 <hpc> ghorn: known issue
10:05:24 <ghorn> will try in #ghc
10:05:27 <ghorn> ah
10:05:43 <hpc> when something wonky happens with a "looks like a type variable" thing
10:05:53 <hpc> in that specific position of a class definition
10:05:57 <ddarius> @undefine
10:06:01 <ddarius> @let bp p n = case n `quotRem` p of (0,r) -> [r]; (q,r) -> r:bp p q
10:06:02 <lambdabot>  Defined.
10:06:10 <ddarius> @let vdC p n = map (\i -> sum (zipWith (/) (fromIntegral $ bp p i) (iterate (p*) p))) [0..n]
10:06:11 <lambdabot>  Defined.
10:06:12 <ddarius> :t vdC
10:06:13 <lambdabot> forall a. (Fractional a, Integral [a], Integral a) => a -> a -> [a]
10:06:18 <ddarius> Doh.
10:06:19 <hpc> oops
10:10:21 <ddarius> > vdC 3 9 :: [Rational]
10:10:24 <lambdabot>   [0 % 1,1 % 3,2 % 3,1 % 9,4 % 9,7 % 9,2 % 9,5 % 9,8 % 9,1 % 27]
10:11:48 <Guest62319> :info Endo a
10:11:58 <Guest62319> @hoogle Endo
10:11:58 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
10:11:59 <lambdabot> Data.Monoid newtype Endo a
10:11:59 <lambdabot> System.Posix.Terminal EndOfFile :: ControlCharacter
10:12:24 <Guest62319> exists o_O
10:12:30 <ddarius> :t EndO'File
10:12:32 <lambdabot> Not in scope: data constructor `EndO'File'
10:12:41 <Guest62319> lol
10:14:15 <hape01> I have an   x :: Network.Stream.Result (Response String)    on the GHCI console.  How can I fetch the "Response String" out of x directly?
10:14:53 <ddarius> Who calls a kd-tree a d-d-tree?
10:17:09 <quintessence> edwardk: can you usefully Scope over something that's not a Monad?
10:17:16 <singpolyma> I have a ForeignPtr that I'm passing the inner Ptr off to a foreign call, and I need to make sure it doesn't get GC'd until the foreign is done with it.  I know at what point in my haskell code that is, and I have kept it in scope to that point, which works, but the moment I use -O with ghc the optomizer seems to figure out I'm not really using it and it gets GC'd again
10:17:30 <edwardk> quintessence: not terribly =)
10:18:19 <applicative> ghorn: it doesn't happen in ghci for ghc-7.5
10:18:43 <quintessence> edwardk: hmm.  I have a call-by-push-value language where variables and lambdas are expressions but lambda bodies, applications, and lets are computations
10:18:56 <ddarius> @hoogle touchForeign
10:18:56 <lambdabot> Foreign.ForeignPtr touchForeignPtr :: ForeignPtr a -> IO ()
10:19:23 <ghorn> i guess the funs over then
10:19:34 <quintessence> edwardk: computations aren't a monad because you can only substitute expressions for variables, but they want to be in a scope because they're lambda bodies
10:19:48 <edwardk> quintessence: it doesn't work for every language design, for instance the launchbury thing that elliot presented right before my talk can't be done with bound very well
10:20:27 <edwardk> you probably just want to make something like your computations into an instance of Bound directly
10:20:38 <singpolyma> ddarius: thanks!
10:20:55 <edwardk> kind of like i do for Alts in my example
10:21:16 <edwardk> you can >>>= to substitute into an Alt, but it isn't a monad
10:21:53 <parcs`> singpolyma: withPtr
10:22:03 <parcs`> @hoogle withForeignPtr
10:22:04 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
10:22:13 <edwardk> so you'd have Expr a as a monad, Comp f a  -- and an instance of Bound Comp. and the references to exp inside comp would probably be wrapped in Scope, not sure though
10:22:36 <Guest62319> `<>' is not a (visible) method of class `Monoid'
10:22:37 <Guest62319> :(
10:22:38 <quintessence> edwardk: is all that recursing through Scope does is give you Bound for free if you're a monad?
10:23:07 <parcs`> Guest62319: why is that worthy of a :(
10:23:07 <edwardk> it gives you Bound and capture avoiding substitution for the new bound variables
10:23:20 <geekosaur> Guest62319, sounds like you have an older ghc.  use `mappend` instead (with the backquotes)
10:23:23 <edwardk> and the combinators
10:23:31 <Guest62319> ill use (<>) = mappend
10:23:34 <zachk> hey edwardk
10:23:35 <Guest62319> in my module
10:23:37 <quintessence> edwardk: right, stuff that has Scope in the type :)
10:23:39 <parcs`> geekosaur: isn't <> an alias defined outside of the Monoid class?
10:23:42 <zachk> @type (<>)
10:23:43 <lambdabot> Doc -> Doc -> Doc
10:23:46 <edwardk> =)
10:24:01 <edwardk> Guest62319: it was added around 7.4
10:24:18 <Guest62319> now it says ambiguous, Data.Monoid.<>
10:24:19 <parcs`> i mean it's defined in Data.Monoid, but not inside the Monoid class
10:24:35 <edwardk> Guest62319: Data.Monoid exports it. did you import Data.Monoid?
10:24:50 <geekosaur> ah, I apparently missed context somewhere
10:24:50 <edwardk> its at the top level in that module, its not in the Monoid class directly
10:24:51 <Guest62319> oh i tried to defined a monoid instance with <> in the lHS
10:24:58 <hpaste> gertc pasted “how do i check a client?” at http://hpaste.org/72261
10:25:07 <edwardk> you need to use mappend when defining, and you can use  (<>) when using
10:25:09 <geekosaur> oh, don't, it's not part of the monoid class, it's just an alias for mappend which is part of it
10:26:02 <quintessence> edwardk: thanks, I'll see how things work out just implementing Bound for computations
10:26:25 <Guest62319> an interesting consequence of using Endo [A] rather than [A] is i cant derive Eq or Ord
10:26:34 <edwardk> i'll be curious to see how it goes. i honestly hadn't considered your usecase
10:26:49 <Guest62319> er Endo A
10:26:53 <edwardk> i was mostly beating on more lambda calculus-like examples
10:26:57 <Guest62319> er Endo [A]
10:27:11 <edwardk> Guest62319: there is a DList type in a package that has those instances
10:27:22 <edwardk> DList a = Endo [a]
10:27:36 <Guest62319> DList eh
10:28:51 <Guest62319> type synonym?
10:29:47 * ddarius retches on "DList".
10:30:34 <Guest62319> i just wont use Eq or Ord
10:30:51 <Guest62319> its a display thingie not a key
10:31:16 <hpaste> applicative annotated “how do i check a client?” with “how do i check a client? (annotation)” at http://hpaste.org/72261#a72262
10:31:17 <edwardk> it should be a newtype
10:33:22 <Guest62319> unlines puts \n... how about \r\n
10:34:57 <geekosaur> that is usually done by the I/O system
10:35:39 <Guest62319> hrm
10:38:57 <Guest62319> in order to type synonym a mwc-random generator i had to import Control.Monad.Primitive and that seems wrong
10:39:02 <edwardk> is text part of the platform? i forget
10:42:21 <donri> edwardk: yes
10:42:23 <donri> http://hackage.haskell.org/platform/changelog.html
10:42:43 <edwardk> k. then i can add lenses for it
10:43:11 <donri> guess that means you won't be adding unordered-containers
10:43:12 <applicative> it's not too hard to write Show and Eq instances for Endo Guest62319 e.g.   instance (Eq x, Monoid x) => Eq (Endo x) where  Endo f == Endo g = f mempty == g mempty
10:43:45 <ssbr-> is it weird to want to be able to write "myfunction (anyconstructor y) = y"
10:43:53 * ssbr- uses tuples instead of ADTs when this comes up
10:44:07 <ssbr-> (i.e. "myfunction (anyconstructor, y) = y")
10:44:37 <donri> ssbr-: hm comonad? :)
10:44:59 <edwardk> donri: sadly, i'm planning on leaving that off
10:45:01 <ddarius> ssbr-: Yes because that requires all constructors to be of the same arity.
10:45:09 <edwardk> one of the things people like is the lack of dependencies
10:45:24 <ddarius> ssbr-: That said, if you name the field of each of the constructors the same thing, you can just use the projection.
10:45:26 <ssbr-> ddarius: fine with me
10:45:32 <edwardk> but its not too bad to roll your own HashSet/HashMap lenses and they are compatible with other lenses anyways
10:45:41 <donri> true
10:45:44 <ssbr-> ddarius: the actual use case is "myfunction (anyconstructor y) = (anyconstructor (foo y))"
10:46:18 <donri> ssbr-: Functor?
10:46:29 <ssbr-> ddarius: which you'd probably write as "myfunction x = case x of { A y -> A (foo y); B y -> B (foo y)}"
10:46:32 <ssbr-> donri: hm, or that :)
10:46:51 * ssbr- isn't used to this typeclass thing
10:46:58 <applicative> ssbr-: why not myfunction = fmap foo
10:47:17 <ssbr-> applicative: because I am dumb
10:47:21 <ssbr-> bedankt!
10:47:29 <donri> you can even derive functor with -XDeriveFunctor
10:48:13 <latro`a> I was about to ask that
10:48:22 <latro`a> that's pretty funny that that's a separate extension
10:48:52 <latro`a> how well does that work, donri?
10:48:55 <latro`a> for examlpe
10:48:57 <latro`a> *example
10:49:11 <latro`a> data MyList a = Nil | NonEmpty a (MyList a) deriving Functor
10:49:15 <latro`a> does that do what it should?
10:49:18 <parcs`> yes
10:49:20 <burbul> Could anyone tell me if there's a cleaner way of writing this?
10:49:20 <burbul> http://hpaste.org/72263
10:49:35 <latro`a> so it "finds all the a's"?
10:49:35 <parcs`> DeriveFunctor works amazingly well
10:49:40 <latro`a> huh
10:49:43 <latro`a> snazzy
10:50:33 <ddarius> It's a pretty mechanical transformation.
10:51:36 <edwardk> you an also DeriveFoldable and DeriveTraversable, both are scarily handy
10:53:00 <ddarius> The order for Foldable is presumably depth-first left-to-right.
10:54:55 <Athas> burbul: your code has a pretty common pattern when using the state monad like that.
10:55:58 <Athas> Sadly, that's pretty much how you have to do it.  You can do minor tweaks like using a monadic if, but it might hurt clarity.
10:57:18 <burbul> Thanks... can you tell me more about the monadic 'if'?
10:57:25 <burbul> I tried looking for ifM, but I couldn't find anything
10:59:11 <nand`> so when are we getting general purpose, no-manual-overhead support for recursive modules in GHC?
10:59:39 <Athas> burbul: You can write it yourself easily enough.  Some package probably exports it as well: ifM c t f = do { c' <- c; if c' then t else f }
10:59:49 <burbul> Hmmm.... see http://www.haskell.org/pipermail/haskell-cafe/2003-February/003972.html
11:00:25 <Athas> Hah, that looks like the ugly hack to get ternary operators.
11:00:44 <parcs`> nand`: when you write the patch
11:01:09 <nand`> parcs`: ah, that must mean ‘never’
11:02:06 <latro`a> um
11:02:08 <latro`a> no return?
11:02:16 <latro`a> depends on the types of t/f I guess
11:02:19 <ddarius> burbul: You can just do: modify (Set.insert r) >> gets (r `member`)
11:02:19 <mroman> > liftM2 (==) (return 5) (return 6 :: IO Int)
11:02:21 <lambdabot>   <IO Bool>
11:02:52 <mroman> > fmap (+5) (return 6 :: IO Int)
11:02:53 <ddarius> It would be nice if Set.insert returned something indicating whether the element was already there.
11:02:54 <lambdabot>   <IO Int>
11:03:38 <Athas> burbul: also, your process_ref is just: process_ref r = if_fresh $ fromMaybe r $ f r
11:04:13 <ddarius> Also this is Haskell not C++.
11:04:14 <burbul> ddarius: doesn't that put the element into the set before checking whether it's an element?
11:04:26 <burbul> C++?
11:04:39 <ddarius> burbul: Yes, sorry.
11:04:58 <ddarius> gets (r `member`) <* modify (Set.insert r)
11:05:02 <burbul> If you mean the underscores, they are in there because I'm using dictation software
11:05:19 <burbul> ah -- thanks!!
11:05:54 <ddarius> Not that this returns a boolean rather than a Maybe, though that's easy to fix by changing what's in the gets.
11:06:07 <Athas> burbul: I think he means that using a state monad is probably not necessary here.
11:06:19 <ddarius> Athas: No, he understood me.
11:06:28 <burbul> Athas: You would do it using direct recursion?
11:06:59 <burbul> I thought the monad was more idiomatic Haskell (whereas direct recursion would be more idiomatic in say ML)
11:07:02 <Athas> burbul: it looks like a folding.
11:07:33 <burbul> Hmmm... where you are folding a pair?
11:07:44 <burbul> (seen, result)
11:07:45 <burbul> ?
11:07:54 <Eduard_Munteanu> burbul: folds and straight recursion are pretty idiomatic in Haskell
11:08:09 <Athas> Yes, exactly.  Make the state explicit.
11:08:10 <ddarius> burbul: The ideal situation is not to use a monad, though if a monad suits the problem, then certainly use a monad.
11:08:16 <burbul> ok
11:08:22 <burbul> That's interesting -- I had completely the opposite impression
11:08:25 <Athas> Monads are very nice, but they have some notational overhead for small-scale use.
11:08:34 <burbul> ok -- thank you very much!
11:08:41 <burbul> [ everyone, that is]
11:08:55 <Eduard_Munteanu> You could do imperative-like programming in Haskell using monads, but that wouldn't be idiomatic if overused.
11:09:46 <edwardk> bah i can't import Text, because its not Trustworthy
11:09:56 <nand`> imperative programming? in my haskell? https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs
11:09:57 * monochrom does not care about idomatic. cares about simple and minimal
11:10:07 <ddarius> burbul: If there are abstract functions that happen to be instances of monadic functions (which happens quite often) then use them.  But writing in monadic style (i.e. with do-notation) is usually less than desirable unless you are explicitly using the "computational effect" of the monad and even then writing in the State monad is like writing in an imperative program with one variable.
11:10:22 <mroman> nand`: Aaargh.
11:10:26 <Eduard_Munteanu> nand`: lol
11:10:38 <ddarius> edwardk: bos is a shady fellow.
11:10:41 <edwardk> hah
11:10:51 <burbul> ddarius what do you mean by ' computational effect'?
11:11:12 <burbul> Here it really is the case that the set of variables that has been seen is changing as one go through the list, and using the state monad seemed like a natural way of capturing that
11:11:19 <burbul> *goes through the list
11:11:25 <ReinH> can HUnit output with color?
11:11:47 <Athas> burbul: right, and in general that is what the state monad is used for, but in this particular case you don't gain any notational convenience.
11:11:59 <burbul> [sorry, have to go afk...]
11:12:01 <nand`> mroman: I think it's a beautiful example of what we mean by “in Haskell you define your own control structures”
11:12:16 <Athas> Remember that many monads, and the state monad in particular, are pretty much syntactical sugar.
11:12:31 <Clint> ReinH: if you run it through hspec
11:12:32 <mroman> People mean that?
11:12:34 <Athas> In this case, since every operation uses the state, you might as well make it explicit.
11:12:38 <ReinH> Clint: oh!
11:12:44 <ReinH> Clint: thanks
11:12:57 <ReinH> what do people think of hSpec? is it widely used?
11:13:21 <ReinH> (I'm a fan of BDD in general, I just didn't realize haskellers did it as much)
11:13:22 <monochrom> "the accumulator is changing as one go through the list" was a motivation for using State to add up a list of numbers
11:13:30 <Clint> it annoyed me in some way that made me switch to test-framework
11:14:13 <Guest62319> type directed design
11:14:37 <Guest62319> if you get all your data straight
11:14:46 <Guest62319> the GUI can then begin to be unraveled
11:14:59 <ReinH> Clint: would you say test-framework is the most widely used testing tool?
11:15:08 <ddarius> Guest53303: See Conal's Tangible Values.
11:15:27 <ReinH> I'm doing some beginner-level haskell videos and I want to use best in breed tools as much as possible
11:15:44 <Guest62319> ddarius: who me
11:16:01 <ddarius> Guest62319: Yes.
11:16:12 <Guest62319> ive watched a few conal videos
11:16:19 <Guest62319> and tried to understand his blogs
11:16:42 <Clint> ReinH: not sure
11:16:44 <Athas> Haskell is not a good community for consensuses.
11:17:04 <ReinH> Athas: that may be so, but programmer interop is useful :)
11:17:05 <Guest62319> a large number of people who argee with each other is frightening
11:17:28 <ReinH> I just want to make sure they'll see tools that are useful and current etc
11:18:10 <ReinH> rather than some niche or poorly supported thing
11:18:12 <ReinH> maybe I'm overthinking it
11:18:21 <Athas> ReinH: indeed, the Haskell community fosters good several ideas and their implementation.  I think hSpec looks mature enough to recommend to a beginner.
11:18:45 <ReinH> Athas: there's a tension between forced consensus and tragedy of the commons :)
11:18:47 <Guest62319> i think haskell is interesting for the actual language being good rather than first being recognized for its IDEs and dev tools
11:18:48 <Athas> There's just rarely an industry-standard for anything (I think QuickCheck may be the only widely used library of its kind, though).
11:18:59 <ReinH> Athas: SmartCheck! :D
11:19:25 <Guest62319> ghci check
11:19:41 <jfischoff> ReinH: have you tried it yet?
11:19:50 <ReinH> jfischoff: tried which?
11:20:00 <jfischoff> ReinH: SmartCheck
11:20:05 <ReinH> jfischoff: I haven't
11:20:11 <ReinH> but my does it look smart ;)
11:20:15 <jfischoff> :)
11:20:45 <ReinH> my plan so far is to try the first video with hUnit, hSpec and Test.Framework to see which one feels the best
11:20:52 <ReinH> then go with that
11:21:00 <ReinH> just wondering if I've left any contenders out
11:21:47 <Athas> You are going to mention QuickCheck at some point, right?
11:21:51 <jfischoff> Test.Framework uses HUnit and QuickCheck (or potentially other libraries)
11:22:03 <ReinH> Athas: definitely
11:22:08 * hackagebot free-functors 0.1.1 - Provides free functors that are adjoint to functors that forget class constraints. (SjoerdVisscher)
11:22:40 <jimi_hendrix> what is the standard indentation for haskell programs? haskell-mode in emacs seems to indent to the second word on the previous line when starting a new function definition (i.e. will indent to b in "foo bar = do"). is that typical?
11:22:49 <ReinH> I think I may go with Test.Framework as up-to-now I've been writing my haskell tests in an ad hoc mixture of hUnit and QuickCheck anyway
11:23:08 <monochrom> even haskell-mode has 3 indentation standards
11:23:10 <Athas> jimi_hendrix: no standard.  And haskell-mode is somewhat inconsistent (I think it gets confused).
11:23:30 <ReinH> jimi_hendrix: as long as you obey layout you'll be technically correct
11:23:34 <ReinH> which is of course the best kind of correct
11:23:34 <jfischoff> ReinH: yeah go with Test.Framework. It works well for mixing HUnit and QuickCheck
11:23:42 <jimi_hendrix> alright
11:23:42 <ReinH> jfischoff: alrighty thanks
11:23:44 <monochrom> actually one of them is an infinite class of standards, by letting you set a variable on "how many spaces"
11:23:46 <jimi_hendrix> is there a better emacs mode then?
11:23:57 <Athas> jimi_hendrix: that behaviour sounds really strange, though.  Isn't that how Emacs indents in text-mode?
11:24:05 * jfischoff is tempted to write a SmartCheck Test.Framework provider
11:24:08 <jimi_hendrix> maybe?
11:24:16 <monochrom> not yet, but when it comes out, it will have 5 standards instead of 3
11:24:29 <Athas> monochrom: technically not infinite, as Emacs Lisp integers have an upper bound!
11:24:36 <jimi_hendrix> i have never really used emacs for normal text editing. at that point i just pop open vim
11:24:55 <ReinH> jimi_hendrix: btw vim is a pretty decent haskell editor
11:25:08 <Guest62319> is emacs more popular than vim for haskell
11:25:13 <ReinH> and vim + screen/tmux makes for a decent "ide"
11:25:24 <monochrom> anyway my point is that looking for "one standard" is futile. looking for "a better emacs mode" based on indentation standard is an XY Problem
11:25:28 <ReinH> I think haskell mode is pretty compelling for emacs
11:25:31 <jimi_hendrix> ReinH, yeah, i just like emacs for the plugins and because i can get ghci running in the same window
11:25:35 <ReinH> but vim is definitely a contender
11:25:51 <ReinH> jimi_hendrix: so can I :)
11:26:03 <MHD> Vim is p okay
11:26:06 <jimi_hendrix> the only place where emacs clearly beats vim that i have found is with lisp
11:26:19 <MHD> Who here other than me uses gedit?
11:26:26 <ReinH> it would be rather sad if it didn't beat vim at its own language :)
11:26:26 <jimi_hendrix> also in being in operating system
11:26:34 <ReinH> I do prefer its tetris as well
11:26:38 <jimi_hendrix> an*
11:27:05 <jimi_hendrix> vim scripting looks painful
11:27:07 <ReinH> jimi_hendrix: my vim + tmux setup for haskell: https://img.skitch.com/20120728-83gm95m8xi7fddndtj7uwpmk5n.jpg
11:27:09 <jimi_hendrix> but i never tried it
11:27:18 <ReinH> jimi_hendrix: vimscript is a terrible, terrible abomination, yes
11:27:19 <ddarius> jimi_hendrix: elisp also looks painful.
11:27:27 <ReinH> fortunately, tpope writes all my vimscript for me
11:27:40 <MHD> Emacs = "we started with a simple idea and then we just kept adding bells and whistles" the text-editor
11:27:55 <MHD> Squeak comes to mind too
11:28:08 <ReinH> elisp is great if you're already a native lisp speaker
11:28:09 <Athas> MHD: Emacs was never a simple idea.
11:28:13 <jimi_hendrix> ReinH, that looks pretty nice. writing a chess ai?
11:28:16 <Guest62319> how about hacs, haskell text editor, program it in haskell
11:28:21 <Athas> It was an integrated environment and programming language from the very beginning.
11:28:26 <ReinH> jimi_hendrix: for an introductory video series, yes
11:28:39 <ddarius> ReinH: elisp is a horrible lisp.
11:28:40 <MHD> Guest62319: Not enough with Leksah and Yi?
11:28:52 <Guest62319> ah never tried those
11:29:00 <jimi_hendrix> ReinH, going to take on kasparov then? :P
11:29:13 <ReinH> jimi_hendrix: I'll be happy if I can get it to make legal moves at all :D
11:29:36 <jimi_hendrix> ReinH, add support for kriegspiel. that will get fun fast
11:29:41 <MHD> I have a continuation based Arrow "data A b c = A (forall d. (c -> d) -> b -> d)" and I need to add an ArrowLoop instance to it. How do I do that?
11:29:45 <ReinH> but the nice thing about the chess engine as a topic as that I can start with very beginner topics and it'll be deep enough to go very deep indeed
11:29:58 <ReinH> s/as/is
11:30:03 <jimi_hendrix> yeah
11:30:32 <ReinH> jimi_hendrix: the first video will just be defining the board and making moves
11:31:42 <ReinH> btw can someone suggest a less-sucky alternative to fromJust here?   show (Piece Black pType) = return $ fromJust $ lookup pType (zip [Pawn .. King] "pnbrqk")
11:31:54 <ReinH> it should be safe as it's fully covered
11:32:04 <ReinH> but it's still probably not a good idea to suggest fromJust in a beginning haskell video
11:32:18 <monochrom> what is the return doing there?
11:32:25 <ReinH> monochrom: lifting Char -> String
11:32:41 <monochrom> I would use [...] for that
11:32:51 <Athas> ReinH: I take it you want to avoid explicit pattern-matching?
11:33:08 <jimi_hendrix> ReinH, what is guard? autocompilation or something?
11:33:21 <ReinH> jimi_hendrix: file watcher, yes
11:33:31 <ReinH> Athas: I wouldn't mind but I was hoping to keep it a one-liner
11:33:47 <Athas> Really, I would use explicit pattern matching for that.  Then you'd also get a warning if the rules for chess were expanded with a new piece (say, a nuclear submarine) and you forgot to expand your show method.
11:34:00 <monochrom> I think the lookup is as short as it gets
11:34:01 <Guest62319> >_>
11:34:25 <Guest62319> definitely need to account for official chess rules changing
11:34:31 <MHD_> In my continuation Arrow I already have something like "loop (A a) = A $ \k b -> a (\(c, d) -> k c) (b, c)" but I cannot figure out something elegant for making the c's be the same thing
11:34:40 <ReinH> Athas: ok, would you just use a where Just pType = pieceChar ?
11:34:55 <Eduard_Munteanu> Yeah, what if somebody wants unicorns? :P
11:34:56 <ReinH> monochrom: use what, sorry?
11:35:12 <Athas> ReinH: no, I'd do pattern matching in the method, one line per case.
11:35:39 <Athas> This is one case where golfing really just makes every more unclear.
11:35:53 <ReinH> Athas: would you be so kind as to show me how you'd write it?
11:35:54 <monochrom> [fromJust (lookup ...)]
11:35:56 <Athas> Also, it's not evident that your one-liner is correct unless one knows the ordering for pieces (which is rather arbitrary).
11:35:58 <ReinH> monochrom: oh
11:36:06 <jimi_hendrix> ReinH, is that a haskell specific program?
11:36:15 <ReinH> Athas: pieces derive Enum
11:36:22 <ReinH> jimi_hendrix: no, it's actually written in Ruby
11:36:30 <ReinH> piece types, sorry
11:36:31 <hpaste> applicative annotated “how do i check a client?” with “how do i check a client? (gertc , right paste)” at http://hpaste.org/72261#a72264
11:36:37 <Athas> ReinH: show (Piece Black Pawn) = "p"; show (Piece Black King) = "k"; etc...
11:36:48 <ReinH> Athas: hmm
11:36:55 <ReinH> Athas: I was going to refator from that into a lookup
11:36:58 <ReinH> but you don't think it's worth it?
11:37:01 <Athas> ReinH: yes, but I'd have to know the explicit ordering to make sure the string "pnbrqk" is correct.
11:37:22 <ReinH> Athas: so there's an implicit ordering dependency, sure
11:37:38 <ReinH> and you think explicity declaring each instance is safer
11:37:43 <ddarius> The general thrust of the Haskell philosophy is to do things in a way where making errors is difficult.
11:37:50 <ReinH> that makes sense
11:38:07 <hmax> hi there
11:38:15 <Athas> I would be somewhat confused if the correctness of the program depended on the order in which the constructors are listed in the data type definition.
11:38:15 <ReinH> I think I may do the refactoring and then point out the cons and go back to the explicit definition
11:38:22 <ReinH> thanks for the advice
11:38:25 <hmax> I'd like to know if there is any lib for working with weighted graphs?
11:38:28 <ReinH> Athas: great point
11:38:44 <hmax> fgl looks a bit outdated and data.graph knows nothing about weighted graphs
11:38:51 <ReinH> the refactoring takes it away from "obviously correct" to "correct if you remember some special non-obvious ordering"
11:38:59 <ReinH> Athas: thanks
11:39:00 <Athas> Exactly.
11:39:00 <jimi_hendrix> also, if i am defining multiple variables in a let expression, am i allowed to use one variable in the definition for another?
11:39:10 <monochrom> yes
11:39:31 <ddarius> > let x = 1:y; y = 2:x in x
11:39:32 <Guest62319> letrec
11:39:32 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
11:39:45 <ReinH> Athas: can I still use this for black pieces?   show (Piece White pType) = map toUpper $ show (Piece Black pType)
11:39:50 <ReinH> er white
11:40:05 <jimi_hendrix> thanks
11:40:16 <Athas> ReinH: sure.
11:40:17 <Guest62319> how about Data Piece = White PType | Black PType
11:40:41 <ReinH> Guest62319: data Piece = Piece { pieceColor :: PieceColor, pieceType :: PieceType }
11:40:48 <parcs`> > head $ fix (ap flip) [(1:).head.tail, (2:).head]
11:40:51 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
11:41:00 <Guest62319> ReinH: i know
11:41:04 <ReinH> ok
11:41:10 <Athas> You should read http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/ - in simple terms, it's about how we should use pattern matching to make correctness "proofs" explicit in our code, rather than rely on implicit correctness.
11:41:13 <ReinH> Guest62319: what benefit do I get from yours?
11:41:20 <Guest62319> see what Athas said
11:41:33 <ReinH> Athas: thanks for the read
11:41:42 <ReinH> Guest62319: Can you help me connect the dots please?
11:42:08 <Guest62319> its an extra place for the compiler to tell you what you wrote made no sense
11:42:34 <ReinH> Guest62319: sorry if I'm a bit obtuse, can you give me an example?
11:42:38 <Guest62319> it will happily take your bool for what it is in any boolean op
11:43:09 <Guest62319> the more things that are valid the harder it is for compiler to tell you what you wrote is wrong
11:43:36 <ReinH> Guest62319: ok, but could you give me a more explicit example?
11:43:40 <Athas> Guest62319: his correct type definition is: data Piece = Piece PColor PType.
11:44:01 <ReinH> Athas: which is what I have plus record syntax
11:44:03 <Guest62319> chess pieces is a good example
11:44:10 <Athas> Your modification is not really that improved, assuming a sensible PColor type.
11:44:22 <ReinH> data PColor = White | Black
11:44:28 <ReinH> since it's composed, I'm not sure what the difference is
11:44:36 <Guest62319> White PType | Black PType is better
11:44:49 <ReinH> Guest62319: instead of saying "better", can you please tell me why it's better?
11:44:59 <Athas> It's completely isomorphic.
11:45:06 <ReinH> as far as I can tell they are exactly the same
11:45:14 <Guest62319> youre the one who posted the boolean blindness paper
11:45:17 <monochrom> I know one way White King is better, and one way Piece White King is better
11:45:18 <ReinH> except that I can now rever to piece colors independently
11:45:22 <Athas> Well, apart from the fact that with ReinH's implementation, the color can be undefined.
11:45:30 <ReinH> s/rever/refer
11:45:32 <ddarius> Athas: Not completely.
11:45:39 <ddarius> Athas: Yes.
11:45:40 <Guest62319> ReinH: if you think thats important then ok, but im not sure it is
11:45:52 <ReinH> ok, ignore that then
11:46:01 <ReinH> I'm really interested in what the difference is
11:46:08 <ReinH> I thought they would be isomorphic as Athas said
11:46:10 <ddarius> Both of the fields should probably be strict.
11:46:17 <Guest62319> the type checker sees them totally different
11:46:35 <Athas> ReinH: with your implementation, 'Piece undefined Pawn' is well-typed.
11:46:49 <monochrom> White King is better because it is less flexible. Piece White King is better because it is more flexible
11:47:22 <ReinH> hmm
11:47:34 <Athas> ReinH: really, in Haskell, it's pretty common to "pretend" that we're not working with lifted types (that is, they cannot be undefined), but it's true that there is a difference.
11:47:55 <monochrom> less flexible is better because fewer cases to check, easier to optimize. more flexible is better because it allows more general algorithms
11:48:27 <Athas> In this case, I would use your original piece type, because the color type seems generally useful.
11:48:34 <hpaste> MHD pasted “Continuation-based ArrowLoop?” at http://hpaste.org/72265
11:48:50 <Guest62319> not sure the color type is useful by itself, its just a neutered bool
11:48:57 <ReinH> Guest62319: rebuttal? :)
11:49:03 <MHD_> ^ A small writeup detailing my current problems.
11:49:21 <ddarius> Athas: If you added the strictness annotation, then they would become isomorphic, but Piece undefined Pawn would still be well-typed.  It just would immediately through an error when you attempted to use the piece at all.
11:49:28 <ReinH> I think I'm going to need a sec to read Boolean Blindness and let that sink in
11:49:56 <ReinH> I really want to fully understand the arguments here
11:50:04 <Guest62319> me too
11:50:05 <Athas> Guest62319: it is a more information-carrying bool, leading to prettier code if you wanted an UI for selecting which colour to play, or whatever.
11:50:25 <Athas> ddarius: that is true.  The best solution is probably the two-argument constructor with strictness annotations.
11:50:26 <ReinH> so let me give you a counterexample, Guest62319
11:50:33 <ReinH> my BoardState will need to maintain whose turn it is
11:50:38 <Guest62319> Athas: doesnt mean such a type needs to be used as part of the piece type
11:50:39 <ReinH> I was planning on using PieceColor for that
11:50:43 * Athas freely admits to very rarely adding strictness annotations for anything but performance grounds.
11:51:00 <ReinH> Guest62319: you'd suggest using a separate type for that?
11:51:34 <ddarius> I would say fields that are "flat" should be strict by default unless you have some explicit reason to make them non-strict.
11:51:39 <ReinH> (GameState is probably a better name)
11:51:43 <Guest62319> well now its denoting a player rather than a color
11:51:53 <monochrom> this is depressing. you design data structures and algorithms together. there is no such thing as "better" data structure isolated from algorithms
11:51:53 <ReinH> Guest62319: are the two not the same?
11:52:05 * ddarius agrees with monochrom completely.
11:52:11 <Guest62319> ReinH: not in general, and not in chess
11:52:20 <ReinH> Guest62319: they just happen to have the same name
11:52:24 <monochrom> actually, there is. if there is no algorithm attached, the best data structure has 0 or 1 value only
11:52:27 <Guest62319> ReinH: not really
11:52:30 <Guest62319> my name isnt white
11:52:38 <Guest62319> many chess programs lets you switch sides
11:52:47 <Guest62319> or switch a player out with a cpu
11:52:48 <Guest62319> or whatever
11:53:01 <ReinH> monochrom, ddarius: in this case my interest is in providing haskell code that is reasonable, reasonably correct, and easy to understand, not in specific performance enhancements related to the algorithms I'll be using later
11:53:20 <ReinH> Guest62319: as far as the game of chess is concerned, it's not a question of the players at all
11:53:22 <quintessence> monochrom: I think you can have some set of values in mind that should be representable without knowing your algorithm yet, in which case you'd (all else equal) want to be able to represent no more than that set
11:53:24 <ReinH> it's a question of the sides
11:53:28 <ReinH> where White and Black are the sides
11:53:44 <ddarius> ReinH: Encouraging beginners to ignore strictness is why so many get into performance problems.
11:53:58 <ddarius> Also having strict fields is simpler.
11:53:58 <ReinH> ddarius: I don't want to encourage beginners to ignore anything that is important
11:54:06 <ddarius> Strictness is pretty damn important.
11:54:12 <ReinH> ddarius: that is, after all, why I'm asking for this discussion :)
11:54:26 <ReinH> ddarius: I'm not taking sides yet
11:54:43 <Athas> There is no doubt that you should make the fields of the Piece type strict, no matter how you choose to represent it.
11:54:44 <ReinH> and btw thanks all for taking the time to discuss this with me
11:54:50 <monochrom> I don't understand how my "algorithm" suddenly becomes "performance"
11:55:09 <ReinH> monochrom: apologies
11:55:45 <ddarius> ReinH: Arguably, by even using Haskell you've already agreed that strictness properties are important.
11:55:45 <ReinH> Is there a good place to read up on the tensions around type strictness?
11:55:48 <monochrom> "algorithm" can also mean "more safe vs less safe", "easier to write vs harder to write", "easier to read vs harder to read" too
11:56:00 <ReinH> monochrom: that's fair, again I apologize
11:56:49 <ReinH> ddarius: basically I want to write code that a beginner would understand and an expert would at least agree is reasonable
11:57:01 <ReinH> if that means making the fields of Piece strict then that is what I will do
11:57:04 <monochrom> if you use "White King" and "Black King", the algorithm for checking valid/invalid moves requires duplicating code, which is more work and more error prone
11:57:31 <ReinH> but I would like to understand the *why* of the decision so I can communicate it to my viewers
11:57:37 <monochrom> however, if you turn on -Wall, you do get the warm and fuzzy assurance of "complete coverage"
11:57:40 <ddarius> monochrom: Since the types are isomorphic that isn't true.
11:57:54 <Guest62319> why will is need duplicate code
11:58:14 <Athas> There's very little code duplication.
11:58:52 <Athas> You define a function 'validMoves :: PieceType -> Position -> [Moves]' and use that.
11:58:58 <ddarius> ReinH: It's easy to motivate having strict fields in this case.  Not only is there a performance advantage, but does Piece undefined undefined have any meaning?  No, so you shouldn't have that be part of your collection of values.
11:59:01 <ReinH> btw I'm basing my code on http://www.haskell.org/haskellwiki/Learning_Haskell_with_Chess, which doesn't use strict fields for Piece
11:59:14 <ReinH> ddarius: that makes sense to me
11:59:19 <ReinH> thanks for the explanation
11:59:32 <Athas> ddarius: out if curiosity, what is the performance advantage of strict fields?  What does GHC do with them?
11:59:38 <monochrom> well it still blows to have to write "f (White t) = g t" and then "f (Black t) = g t" again
12:00:02 <Athas> ReinH: as I said, many Haskell programmers pretend that fields and variables are strict most of the time, particularly when writing example programs.
12:00:12 <ddarius> ReinH: Yes, there is tons of introductory code that completely omits any consideration of strictness v. non-strictness, and as a result stack overflows when people try to actually use it from which beginners get the impression that Haskell is impractical.
12:00:14 <Guest62319> monochrom: f bw = g (getType bw)
12:00:27 <ReinH> ddarius: I'd like to avoid that trap then
12:00:50 <ReinH> ddarius: when I write tutorials in other languages, I don't neglect to write the tests
12:01:00 <ReinH> ddarius: so I don't want to neglect any "best practice" here either
12:01:04 <Guest62319> in what case would A undefined undefined value make sense?
12:01:08 <ddarius> ReinH: Typically you need to stress test to find stack overrflows.
12:01:22 <MHD_> I have never had a haskell program not specifically designed to stackoverflow, do just that
12:01:32 <Guest62319> i have
12:01:41 <MHD_> Is that because I am smart, or because I write too few programs... hmmm...
12:01:41 <Guest62319> when simply reading text files
12:01:42 <ddarius> Guest62319: : When just knowing A would be useful.
12:01:56 <ddarius> MHD_: It's easy to not see the problem as it usually only comes up with larger data.
12:01:57 <ReinH> ddarius: what I mean is: if type strictness here is something that would be considered by an expert, I don't want to ignore it
12:02:01 <Guest62319> ddarius: a producer would put a undefined there?
12:02:09 <MHD_> I think I am just smart, actually
12:02:24 <MHD_> I have done some prettu big files
12:02:32 <Athas> Most of my space leaks cause heap overflows.
12:02:34 <MHD_> and always avoided dangling stuff
12:02:36 <Guest62319> heh 'expert'
12:02:44 <ReinH> ddarius: I may make the point that strictness would provide certain advantages and then still not make the types strict
12:02:55 <ReinH> ddarius: but I don't want to duck important issues just because it's a beginner tutorial
12:02:55 <ddarius> MHD_: Possibly.  Writing decent code that doesn't stack overflow isn't hard to do if you think about it at all and don't pretend that Haskell is an eager language.
12:02:58 <ReinH> ddarius: does that make sense?
12:03:26 <Guest62319> you dont need to cause stuff to 'dangle' to get space leak
12:03:30 <nand`> is it bad that I had to re-read that three times to realize you weren't talking about stackoverflow.com?
12:03:38 <Guest62319> it could just take up a ridiculous amount of space due to laziness
12:03:41 <MHD_> It bothers me that haskell doesn't have a standardized bitvector system for, say, byte set lookup.
12:03:49 <Guest62319> if you had infinite memory that kind of code would be fine
12:03:58 <ddarius> Guest62319: There are cases where it can happen.  In particular, if you are using circular types or also this handles cases where you want to partially consume a structure.
12:04:12 <ddarius> nand`: Yes.
12:04:12 <Guest62319> MHD_: IntMap
12:04:20 <ReinH> ddarius: in particular I might come back later when the engine is more developed and I can talk about strictness in the context of its algorithms and performance
12:04:24 <MHD_> Yeah, but smaller
12:04:30 <MHD_> Like an actual bit-vector
12:04:43 <Athas> MHD_: Integer!
12:04:48 <MHD_> Yeah
12:04:51 <MHD_> hm
12:05:08 <MHD_> that is actually a fun idea
12:05:10 <Guest62319> Integer is an infinite bitvector lol
12:05:15 <MHD_> Yeah
12:05:22 <Athas> Honestly, it's worth seeing what the performance is like.  GMP (which backs Integer) is known to be quite fast.
12:05:39 <ddarius> ReinH: If you talk about strictness at all, you should immediately come to the conclusion that these fields should be strict at which point, since it's only adding two characters, I don't see why you wouldn' keep them strict.  Really, the thing to encourage is for beginners to think about strictness properties.
12:06:11 <ReinH> ddarius: that makes sense. Can you link me to or refer a good introduction to strictness properties?
12:06:20 <ddarius> UArrays of Bools are also bit-packed.
12:06:21 <MHD_> Anyway, are the Category Theorists out atm?
12:06:33 <MHD_> ooh nice
12:07:00 <ReinH> ddarius: my googling efforts have been less than fruitful :(
12:07:00 <Guest62319> just Bools or any A |
12:07:05 <Guest62319> A | B type
12:07:15 <MHD_> UArray Word8 Bool then
12:07:44 <ddarius> ReinH: The StackOverflow page on the wiki and the Foldr/Foldl/Foldl' page on the wiki are good introduction to some of the concerns (and the ones beginners typically run into).
12:08:02 <ReinH> ddarius: thanks much. Do either Real World Haskell or Programming Haskell cover it at all?
12:08:13 <LnL> Any tips on how to make Tag#children optional and just output `startTag`
12:08:14 <LnL> https://gist.github.com/3193958
12:08:38 <MHD_> Is there someone precent who can help me with Arrows? http://hpaste.org/72265
12:09:53 <ReinH> ddarius: looks like RWH covers it a bit under Controller Execution
12:09:55 <ReinH> fyi
12:09:56 <ddarius> ReinH: RWH has a bit of discussion in the performance section.  I've never read Programming Haskell, so I don't know.
12:10:03 <ReinH> *Controlling
12:10:16 <ReinH> ddarius: I really appreciate the advice
12:10:43 <applicative> ReinH look up the tutorials by  tibbe
12:10:52 <ReinH> applicative: thanks
12:11:16 <ddarius> ReinH: I don't find the presentation of the issue in RWH that great though, though it will cover some concerns.
12:11:20 <ReinH> applicative: also lead me to his style guide, which will help
12:11:24 <jimi_hendrix> so, after trying to learn haskell many times over the last couple of years, i think i have finally reached enlightenment
12:11:26 <applicative> ReinH: http://www.slideshare.net/tibbe/highperformance-haskell was the first
12:11:33 <ReinH> applicative: thanks
12:11:55 <peteriserins> Say I have a newtype Fn a = Fn (fn :: a -> a). Is there a way to lift functions on a -> a to functions on Fn a?
12:11:58 <ddarius> Too many people go from one extreme of not having any strictness annotations to the other extreme of believing adding strictness everywhere will make things faster.
12:12:27 <monochrom> they may enjoy foldr' :)
12:12:42 <Athas> peteriserins: isn't that just the Fn constructor?
12:12:43 <applicative> ReinH here is his little case study of designing a data type http://johantibell.com/files/stanford-2011/performance.html#(1)
12:12:49 <MHD_> peteriserins: make it an instance of Functor?  fmap f (Fn g) = FN $ f g
12:12:57 <Athas> Oh, wait, I misread.
12:13:28 <ReinH> applicative: thanks again
12:13:28 <peteriserins> MHD_: thanks, that makes sense
12:13:35 <ReinH> these are all going into my pinboard
12:13:44 <ReinH> applicative: keep 'em coming if you have more :)
12:14:01 <applicative> there is one other, i think it overlaps considerably though
12:14:08 <MHD_> Fucking continuations how do they recursively combinate in place...
12:14:12 <ReinH> applicative: I'm a voracious reader :)
12:14:20 <ReinH> MHD_: probably magnets
12:14:21 <ReinH> or aliens
12:14:31 <MHD_> More like, not
12:14:33 <ReinH> Maybe Magnet
12:14:39 <ReinH> haskell jokes
12:14:43 <MHD_> yeah
12:14:46 <parcs`> Either Magnet Alien
12:14:51 <quintessence> MHD_: so, the regular CPS transform makes things strict
12:14:58 <ReinH> parcs`: type Aien = Nothing
12:15:05 <ReinH> *Alien
12:15:10 <quintessence> MHD_: which is why there's no MonadFix for the continuation monad
12:15:19 <MHD_> quintessence: Oh
12:15:21 <ddarius> quintessence: Yes, there are different CPS transforms for CbV and CbN.
12:15:27 <MHD_> quintessence: So it is impossible?
12:15:53 <Guest62319> Data.Maybe
12:15:58 <Guest62319> Data.Probably
12:16:05 <Guest62319> Data.Impossible
12:16:09 <MHD_> Data.OnTheOffChance
12:16:29 <applicative> ReinH  http://johantibell.com/files/haskell-performance-patterns.html#(1)    http://www.slideshare.net/tibbe/reasoning-about-laziness
12:16:40 <MHD_> Data.Briticism.Perchance
12:16:49 <quintessence> MHD_: well, I'm not sure how that extends to ArrowLoop, and you could see if they CbN version gets you what you want
12:17:10 <MHD_> quintessence: CbN?
12:17:14 <ReinH> applicative, ddarius, Athas, Guest62319: IOU beer
12:17:31 <Guest62319> lol my nick
12:17:47 <ReinH> Guest62319: was unsure at first if troll ;)
12:18:12 <MHD_> What's CbN stand for?
12:18:12 <Guest62319> isNothing :: Maybe Troll -> Bool
12:18:28 <quintessence> MHD_: call by name (as opposed to call by value)
12:18:29 <monochrom> call-by-name
12:18:30 <nand`> data Blind = True | False
12:20:45 <MHD_> On as scale from BellsAndWhistles to Necessity, how useful is the Arrow rec construct in Parser Combinators?
12:21:14 <ddarius> MHD_: Isn't it used for many and co?
12:21:19 <MHD_> shit
12:21:34 <MHD_> So I have to solve this intractible algebraic problem
12:21:45 <Guest62319> [BellsAndWhistles..Necessity]
12:21:50 <MHD_> yeah
12:22:03 <quintessence> MHD_: parser combinators built from arrows?
12:22:27 <MHD_> quintessence: It's a library I am working on. LL(1) Applicative/Arrow thing called MegaParsec
12:23:04 <ReinH> MHD_: And a MegaParsec  is, of course, the time it takes to do the Kessel Run 1000 times?
12:23:28 <ReinH> sorry, 1M times
12:23:29 <MHD_> ReinH: A megaparsec is about 3 million lighyears
12:23:42 <ReinH> MHD_: that was a starwars joke :)
12:23:46 <ddarius> @google 1 megaparsec in lightyears
12:23:47 <lambdabot> 3261636.26 light years
12:23:47 <lambdabot> http://en.wikipedia.org/wiki/Parsec
12:23:47 <lambdabot> Title: Parsec - Wikipedia, the free encyclopedia
12:23:54 <Guest62319> millenium falcon
12:24:07 <Guest62319> what a bucket of bolts
12:24:12 <ddarius> @google 1 megaparsec in smoots
12:24:13 <lambdabot> 1.81318618  10
12:24:13 <lambdabot> http://en.wikipedia.org/wiki/List_of_humorous_units_of_measurement
12:24:13 <lambdabot> Title: List of humorous units of measurement - Wikipedia, the free encyclopedia
12:24:51 <ReinH> Guest62319: I believe the actual quote was "What a piece of junk!"
12:25:08 <ReinH> Guest62319: besides, Han made some "special modifications"
12:26:18 <Saizan> ddarius, MHD_: you can write many with just Applicative, so you shouldn't need ArrowLoop
12:26:31 <Saizan> also, monadic combinators don't use MonadFix for many
12:26:43 <MHD_> Saizan: I take it as an exercise
12:27:00 <MHD_> you never know when the world might throw category theory at you face
12:27:10 <MHD_> And I want to test it for efficiency
12:28:43 <Saizan> ArrowLoop is not really category theory in your face
12:29:33 <Saizan> the whole Arrow hierarchy is pretty much not that
12:30:25 <MHD> internet driver is wonky, what'd i miss?
12:30:40 <t7> i got a raspberry pi but not SD card :(
12:30:57 <Saizan> nothing much
12:32:46 <MHD> Maaaan, I am starting to think this is impossible
12:33:13 <MHD> Isn't there some sort of Type-sig-to-code system that can correctly generate callCC?
12:33:21 <mmos> is there a way in GHC to throw an error that specifies the file and line number? some kind of compile-time access to file and line number. am I making any sense?
12:34:11 <MHD> mmos: like __FILE__ and __LINE__ in C?
12:34:28 <mmos> MHD: I think so. I don't know C that well but I think something like that
12:34:56 <MHD> GHC supports the C preprocessor and thus __LINE__ and __FILE__
12:35:02 <MHD> Also, learn C
12:35:08 <MHD> It will make your Haskell stronger
12:35:28 <MHD> Mainly by letting you use the FFI well
12:35:52 <ReinH> ddarius, Athas, Guest62319, et al: would any of you be interested in taking some time to review the code for my first vid to help me catch any other issues? (The vids will be freely available and CC licensed)
12:35:56 <ReinH> I know that's a big ask
12:35:56 <mmos> do I have to run the C preprocessor explicitly or does it happen automatically withe the --make option to ghc?
12:36:10 <ReinH> but I thought I'd throw it out there anyway
12:36:18 <MHD> mmos: GHC has a flag for it
12:36:48 <ddarius> MHD: Djinn can do that.
12:37:26 <romm> this might be a vary dumb question, but why is "filter notNull [[1,2,34],[],[6,7,8]] where notNull x = not (null x)" problematic for ghci, while adding a "let" in the beginning makes it okay?
12:37:31 <romm> s/vary/very
12:37:47 <mmos> looks like c preprocessor is -cpp
12:37:51 <ddarius> @djinn (Not a -> a) -> a
12:37:51 <lambdabot> -- f cannot be realized.
12:37:56 <mmos> MHD: -ccp
12:38:16 <ddarius> @djinn (Not a -> Not (Not a)) -> Not (Not a)
12:38:16 <lambdabot> f a b = void (a b b)
12:38:31 <ddarius> @djinn a -> Not (Not a)
12:38:32 <lambdabot> f a b = b a
12:39:15 <Veinor> romm: basically, you can imagine everything you type in GHCi as being inside a do-block
12:39:37 <ddarius> romm: where is not an expression form.  It's part of the function(/value) declaration form.
12:39:46 <Veinor> oh, i missed the 'where'
12:40:22 <romm> ddarius, adding a let in the beginning makes this an expression?
12:40:30 <romm> (sorry, first day with haskell)
12:40:33 <ddarius> let filter not Null ... is an error
12:40:53 <ddarius> let x = filter notNull ... would be a declaration of x and that declaration could have a where clause.
12:40:54 <romm> let x = ...
12:41:31 <romm> ddarius, i see. generally speaking i'm defining a function "x" here, so where is okay
12:41:57 <ddarius> x is a value which may be a function, but is not a function in this case.
12:42:24 <romm> i thought haskell sees everything as a function, including constants
12:42:28 <mmos> is there a way to specify comannd line flags in the LANGUAGE pragma?
12:42:34 <ddarius> romm: Why did you think that?
12:42:55 <romm> i might be mistaken, but i think i've read that in learnyouahaskell.com
12:43:21 <ddarius> Either you are mistaken or learnyouahaskell is mistaken.
12:43:22 <geekosaur> OPTIONS_GHC
12:43:35 <geekosaur> mmos: ^^
12:43:37 <ddarius> I think you can agree that a list is not a function.
12:44:45 <Franciman> ddarius [1,2] is a function call ( 3 actually )
12:45:14 <MHD> Franciman: It is optimized to significantly less in the STG
12:45:41 <Franciman> but that's a compiler specific thing
12:45:42 <ddarius> Franciman: That is disconnected from what I said
12:45:54 <Ornedan> mtl and transformers seem to contain the same stuff. Which is the deprecated one?
12:46:14 <quintessence> even if you build a list using functions, the list you get is not itself a function
12:46:17 <c_wraith> they're compatible now.  mtl is the more common interface
12:47:38 <Franciman> hmm maybe i have mi9sunderstood the whole thing, as I read just the last part
12:47:47 <Franciman> *misunderstood
12:48:14 <romm> ddarius, i'm possibly interpreting this wrongly, but learnyouahaskell.com say this: conanO'Brien = "It's a-me, Conan O'Brien!" is a function definition.
12:48:26 <Franciman> yes it is
12:48:38 <Eduard_Munteanu> Ornedan: I think it went like mtl -> transformers -> mtl2 in chronological order
12:48:42 <ddarius> romm: You are not interpreting it incorrectly.  It is just wrong.
12:48:59 <ddarius> A string is not a function.  conanO'Brien is not a function.
12:49:14 <MHD> What are some good references on the Spineless Tagless G machine? Any LLVM implementations?
12:49:22 <Franciman> no it is, it's a function returning a string
12:49:33 <Eduard_Munteanu> MHD: the original paper?
12:49:36 <Eduard_Munteanu> @where stg
12:49:36 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
12:49:47 <ReinH> ls
12:50:02 <ReinH> funny that doesn't seem to work here :/
12:50:16 <Eduard_Munteanu> . ..
12:50:33 <Eduard_Munteanu> $
12:51:14 <ddarius> Franciman: A function is something of type A -> B for some types A and B.  Alternatively, a function is something that can be applied.
12:51:30 <Franciman> yeah actually....
12:51:38 <romm> Franciman, ddarius, doesn't really matter. a more important question for me is what's the reason that i need that "let x"?
12:51:40 <ddarius> Franciman: You can also look it up in the Report.  There is no "function definition" syntax construct.
12:51:46 <ddarius> There are "decls".
12:52:09 <ddarius> romm: I already told you.  where is part of a value declaration.  There are no "where expressions" hence "where clause".
12:52:15 <romm> is it because where has to be a part of an expression?
12:52:27 <romm> and an expression in haskell must return something?
12:52:28 <Franciman> and infact when you call that thing it doesn't get calculated again
12:52:35 <ddarius> romm: No, it has to be part of a declaration.
12:52:36 <Eduard_Munteanu> romm: 'where' binds to a declaration
12:53:15 <romm> okay, i get it now. thanks.
12:54:28 <MHD> romm: Any prior programming experience?
12:54:56 <romm> yep. i just started haskell a couple of hours ago.
12:54:57 <ddarius> Franciman: There is funlhs as a part of a form of decl, but that doesn't match x = "foo".
12:54:59 <romm> looks very nice.
12:55:29 <Franciman> ddarius yess you're right
12:56:10 <MHD> romm: Haskell is tour first language?
12:56:24 <MHD> s/tour/your/
12:56:37 <romm> MHD, no. not at all :)
12:56:54 <romm> MHD, first functional language, though.
12:57:11 * hackagebot murder 1.2 - MUtually Recursive Definitions Explicitly Represented (MarcosViera)
12:57:26 <Franciman> I think I should read the haskell report
12:57:33 <MHD> romm: Then take the Haskell Report and read that. It'll nicely serve you the syntax on a platyter of EBNF
12:57:48 <MHD> s/platyter/platter/
12:58:25 <Franciman> the last report is 2010 right?
12:58:29 <ddarius> The Report is pretty readable.
12:59:02 <ddarius> The Gentle Introduction was designed as a companion to the Report which gives the Gentle Introduction the benefit of being comprehensive (for Haskell 98.)
12:59:03 <MHD> I think so, the 98 is pretty old and there was something about pattern guards becoming mandatory...
12:59:06 <romm> uh, are you guys refering me to a lex file? :P
12:59:17 <ddarius> @where report
12:59:17 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
12:59:44 <MHD> romm: no. We are referring you to the Big Old Report On All Things Neccesary For Calling You Implementation Haskell Proper
13:00:05 <ddarius> There aren't too many differences between Haskell 98 and Haskell 2010.  The big ones are the addition of pattern guards and the removal of n+k patterns.
13:00:12 <MHD> romm: Tutorials become pretty meaningless once you round your tenth language.
13:00:20 <ddarius> Most of the changes were in the libraries.
13:00:58 <MHD> I still don't like how the abstract algebra/category theory stuff is totally muddled in the standard library
13:00:59 <ddarius> MHD: They aren't meaningless, you just use them in a different wawy.
13:01:20 <romm> MHD, maybe. i basically need something to alt-tab to while i solve stuff from projecteuler...
13:01:38 <MHD> ddarius: Hmm, what way? Skipping to the end?
13:01:41 <ReinH> romm: Haskell is a fun language for Euler problems
13:02:07 <applicative> what muddled
13:02:31 <romm> ReinH, yes, and on the other hand project euler is a fun way to learn modern languages
13:02:45 <ddarius> MHD: Seeing the idioms and conventions and any unusual tricks that the particular language allows.
13:02:48 <popl> ReinH: Are you referring to Project Euler?
13:02:54 <ReinH> popl: yes
13:02:58 <MHD> ddarius: ah, yeah
13:03:04 <ReinH> romm: I've used Euler problems as coding tests for interviews before as well
13:03:08 <ddarius> MHD: You will certainly go through it/skip a lot more than if you were still wet behind the ears.
13:03:18 <popl> I saw a solution posted there that someone derived using only a calculator and some paper.
13:03:23 <ReinH> they're interesting in that most problems can be unpacked at multiple levels
13:03:24 <popl> It was pretty cool.
13:03:27 <MHD> ddarius: I can't really think in ordinary-people terms about programming, physics or math anymore :(
13:03:49 <popl> Although someone else offered a proof proving the solution which I did not quite follow.
13:03:54 <ddarius> MHD: Ordinary people don't think about any of those.
13:03:55 <romm> MHD, are you so un-ordinary now? :)
13:04:05 <ReinH> for instance the sum of odd fib numbers  problems becomes much easier when you realize that even / odd fib numbers form a repeating pattern
13:04:22 <ReinH> s/problems/problem
13:04:22 <popl> ReinH: I think this is the problem I was just referring to.
13:04:42 <Nolrai24> Hey can I get some help getting EclipseFP to work?
13:04:53 <popl> One moment, let me see.
13:04:57 <popl> It was really fun.
13:05:12 <ReinH> fib numbers are even, odd, odd, ...
13:05:14 <MHD> romm: IQ of 140-something, and I can read the wikipedia article on the Reimann Manifold Tensor and understand what the frig
13:05:32 <Guest62319> >_>
13:05:33 <ReinH> so since you are summing evens (not odds, sorry), you can calculate three numbers at a time
13:05:47 <ReinH> which improves your constant factor significantly
13:05:48 <popl> ReinH: Oh no, it was 'find the sum of the even-valued terms' of the Fibonacci sequence.
13:05:59 <ReinH> popl: yes that's the one I meant
13:06:10 <parcs`> we're all unique snowflakes
13:06:29 <Guest62319> btw im smarter than all yall
13:06:30 <MHD> Being a genius is hard, it is hard and nobody understand.
13:06:42 <MHD> Smartness isn't magic
13:06:59 <MHD> But people think it is
13:07:02 <Guest62319> sufficiently smart people are indistiguishable from total dicks
13:07:07 <ddarius> Bah, there are popular science books on the Riemann Manifold Tensor.
13:07:20 <MHD> Guest62319: And I happen to know why
13:07:25 * applicative thinks !!?? -blah
13:07:32 <popl> ReinH: The neat solution is offered by RudyPenteado. If you're logged in it's the third comment in the thread for that problem.
13:07:58 <ReinH> popl: it's fun to derive that neat solution in steps from the naive solution
13:08:17 <ReinH> I'm reminded of a much simpler version of the Bird Sudoku solver
13:08:43 <romm> MHD,what's the reimann manifold tensor?
13:08:51 <ReinH> where you have to unpack patterns in the problem space one at a time to get new efficiencies
13:09:07 <MHD> romm: Join me in #haskell-blah
13:10:39 <ceti331> question: what would something like a simple graphics package look like in haskel
13:11:02 <ceti331> would it avoid the languages strengths, would the libraries to do it suck, or would it be elegant..
13:11:53 <Guest62319> check graphics drawing combinators
13:12:22 <Guest62319> drawing graphics is actually a thing which can nicely be made functional
13:13:36 <jimi_hendrix> i want to iterate over a list, but i also want to know the index of the element i am on. is there an easy way to do that?
13:13:57 <Guest62319> zipWith [0..] ?
13:15:13 <ceti331> Guest62319: a lot of more advanced graphics programs kind of are a graphically-edited 'functional language' for graphics, would you literally expose editing of a haskel representation of procedural graphics..
13:15:47 <Guest62319> ceti331: oh are you talking about graphics editor applications
13:16:00 <ceti331> Guest62319: yes.
13:16:22 <Guest62319> > zip [0..] "use the force luke"
13:16:23 <lambdabot>   [(0,'u'),(1,'s'),(2,'e'),(3,' '),(4,'t'),(5,'h'),(6,'e'),(7,' '),(8,'f'),(9...
13:16:34 <ceti331> Guest62319: thats what i really mean about 'would it avoid the languages' strengths' .. e.g. what does UI programming look like in haskell..
13:16:50 <Guest62319> ok UI isnt just about graphics
13:17:06 <popl> it's also about punctuation
13:17:06 <popl> ;P
13:17:07 <ceti331> Guest62319: i've seen 'monadius' so i've seen it used for "interactive - graphics"
13:17:09 <Guest62319> you can use the toolkits directly which is all imperative
13:17:39 <Guest62319> theres also some work in FRP guis
13:17:45 <ceti331> Guest62319: so the flow of UI would just go in some master 'do' block perhaps
13:18:12 <ceti331> Guest62319: or does it send/receive messages to UI threads in C/C++ via FFI
13:18:26 <Guest62319> all toolkits are ffi libs
13:18:46 <popl> ReinH: I've never written a sudoku solver. I always meant to.
13:18:54 <Guest62319> gtk+ seemed to map over pretty directly and is daresay nicer than C
13:19:11 <Guest62319> but its all still imperative and gross
13:19:19 <Guest62319> theres got to be something better
13:19:22 * Guest62319 looks to the stars
13:19:22 <ceti331> Guest62319: right UI programming in C is quite long winded
13:19:39 <ceti331> Guest62319: unless you have some sort of code generation going on..
13:19:51 <Guest62319> which is what compilers do anyway
13:20:09 <ReinH> popl: This is the one I'm referring to http://www.haskell.org/haskellwiki/Sudoku#Sudoku_incrementally.2C_.C3.A0_la_Bird
13:20:39 <ceti331> Guest62319: sometimes kind of like using C as a low level leevl lanugae and sticking another one over the top... (with parts being 'compiled' to C  as intermediate..)
13:20:49 <Guest62319> ceti331: a quick google for haskell frp gui produced this http://www.haskell.org/haskellwiki/Grapefruit
13:21:58 <Guest62319> as far as i can tell everything in this field is experimental
13:22:29 <popl> Thanksf or the link.
13:22:57 <Guest62319> ceti331: you like using low level languages? :)
13:23:07 <popl> I was going to ask ##math about the proof I was uncertain of but I would have to rewrite it LaTeX which is a PITA (especially since the person is skipping things).
13:23:11 <ceti331> Guest62319: 'experimental' ? optimistically i'd hope "no establisshed best method.." could mean 'here's an valid excuse to re-invent the wheel' :)
13:23:35 <Guest62319> is there a best method ever?
13:23:46 <ceti331> Guest62319: my path: BBC Basic->68k ASM->x86-> C/C++
13:24:09 <ceti331> Guest62319: so i'm a lifelong imperative, low-level, procedural programmer
13:24:10 <Guest62319> that destination needs to be redacted
13:24:35 <Guest62319> you can do procedural programming was easier in haskell
13:24:43 <Guest62319> way*
13:25:05 <ceti331> Guest62319: i've never written anything sizeable in a language with garbage collection.
13:25:12 <MHD> "haskell is best language" is true if and only if haskell is best language
13:25:38 <MHD> ceti331: what.
13:25:45 <Guest62319> well manual memory management is so horrible that i try to never dynamically allocate anything in languages without GC
13:26:17 <ceti331> MHD: i've only written serious programs in the C/C++ and ASM as a kid
13:26:29 <MHD> I feel your pain man
13:26:32 <Guest62319> a refugee
13:26:47 <MHD> I can barely return to D after immersing myself thoroughly in haskell
13:26:54 <Guest62319> give this man some water and warm soup
13:27:11 <ceti331> well i sort of want to learn 'another language' but am in 2 minds - i dont want to deskill myself in lowlevel.
13:27:12 * geekosaur has written both, and appreciates garbage collection while noting that the discipline needed to do manual de/allocation can be a good experience
13:27:41 <Guest62319> ceti331: yeah if you learn to drive a car you will forget how to ride a bike ;)
13:27:41 <MHD> ceti331: Learning more languages makes you better in all of them
13:27:44 <MHD> I know 12
13:27:45 <MHD> or so
13:28:03 <jimi_hendrix> manual de/allocation can be useful depending on your speed requirements
13:28:04 <ceti331> What got me interested in haskel was the experience of doing data-parallel stuff in C.. (ILP & threading)
13:28:05 <MHD> and I have only gotten better at stuff from each new one
13:28:16 <shachaf> There are things that will help a lot more with "all languages" than learning new languages.
13:28:27 <ceti331> i can see the 'map' mentality making a lot of sense over iteration..
13:28:27 <MHD> ceti331: What do you expect to need haskell for
13:28:32 <shachaf> Especially new languages that are basically the same as other ones. :-)
13:28:47 <Guest62319> D, Go, etc
13:28:53 <MHD> D is superior
13:29:01 <MHD> to most other C-likes
13:29:02 <ceti331> MHD: i just like the ideas in it, they do make sense, it seems like the furhest point from what i currently know
13:29:03 <Guest62319> its basically the same as c++ and java
13:29:16 <Guest62319> implementations aside
13:29:45 <romm> i thought Rust is the new hype
13:29:45 <MHD> Guest62319: C++ is masochism compared to D. They are roughly identical in power but D is so much more powerful
13:29:59 <Guest62319> power is not a measure of programming languages
13:30:14 <jimi_hendrix> out of curiosity, how does haskell compare to erlang wrt parallel stuff? i know erlang can spawn and deal with a ton of processes fairly easily
13:30:15 <ceti331> i tried writing a basic vector maths implementation yesterday; kind of freaked out that matching didn't quite work the same way i thought it would from c++ overloading; i definitely didn't master typeclasses just yet
13:30:28 <Guest62319> ghc concurrency is really nice
13:30:33 <noteventime> jimi_hendrix: Compare in what respect?
13:30:42 <ceti331> MHD: C++ is used where there is no alterntative
13:30:47 <Guest62319> haskell vs erlang in that department is one of those question marks
13:30:53 <jimi_hendrix> romm, the problem with rust is it is still undergoing major language changes
13:31:09 <MHD> ceti331: yes. if I didn't have better things to do I would dedicate a lot to eliminating those cases
13:31:10 <ceti331> MHD: at some point you need to interface to hardware and you have the chain of convinience : ASM -> C -> C++
13:31:19 <noteventime> Rust looked a lot more interesting than Go, at least.
13:31:36 <romm> ASM is not more convinient than C, ever.
13:31:37 <MHD> ceti331: The FFI in haskell reverses that: ASM -> C -> Haskell
13:31:54 <ceti331> romm: i mean, C is more convinient than ASM, and C++ more convininet than C
13:31:55 <jimi_hendrix> noteventime, number of processes it can manage and such, i guess. i havent really done much parallel work to know what one should really look at
13:31:57 <Guest62319> ceti331: type classes arent like classes in c++, you dont get to them when you want to make a new type
13:32:08 <Guest62319> go to*
13:32:31 <noteventime> jimi_hendrix: Well, Haskell threads are very cheap, and you're "meant" to spawn lots and lots of them
13:32:32 <ceti331> Guest62319: i was told you need to make a typeclass before you can make polymorphic overloads
13:32:56 <romm> ceti331, ah. i don't know. when dealing with actualy hardware stuff, the subset of C++ you use is basically C
13:33:07 <romm> s/actualy/actual
13:33:08 <MHD> ceti331: A little advice on haskelling - Momentarily forget about 'subtyping' and 'overloading' then look at your code like it is algebra
13:33:11 <noteventime> romm: With some templates :)
13:33:21 <ceti331> romm: C++ can wrap things more conviniently, e.g. make wrappers for expresing bitfield operations
13:33:32 <Guest62319> ceti331: lists dont use type classes to work polymorphically
13:33:47 <davesque> i don't understand the instance for (->) r in the Applicative class
13:33:56 <ceti331> romm: C++'s features help with low level more than high level if anything :) C++'s high level features aren't its strength
13:33:59 <Guest62319> ceti331: how often do you need bitfields ??
13:34:13 <nand`> ceti331: my path was roughly QBASIC -> PHP -> C# -> Haskell, not all hope is lost
13:34:13 <nand`> ugh, disconnects
13:34:16 <ceti331> Guest62319: graphics programming = manipulating data in hardware formats
13:34:18 <noteventime> davesque: Do you understand the Monad instance?
13:34:30 <Guest62319> ceti331: thankfully thats not true
13:34:32 <ceti331> Guest62319: example: HALF float type in openGL. make a nice C++ wrapper for that..
13:34:34 <davesque> learn you a haskell gives the example of `(+) <$> (+3) <*> (*100)` or something like that
13:34:45 <MHD> davesque: ((->) r) === type Fn r a = (r -> a) for Fn r
13:35:07 <ceti331> Guest62319: graphics programming == manipulating datastructures, and size , data-layout issues matter. (cache-efficiency of hardware)
13:35:09 <davesque> and they say that giving an argument of 5 to the resulting function evaluates to 508
13:35:25 <ceti331> Guest62319: thats why C++ is the standard for graphics programming
13:35:26 <applicative> > (+) <$> (+3) <*> (*100) $ 5
13:35:27 <lambdabot>   508
13:35:28 <Guest62319> ceti331: youd hope a library exists so you dont have to do that every time you want to make a program that has graphics
13:35:34 <MHD> davesque: so fmap :: (a -> b) -> (r -> a) -> (r -> b)
13:35:46 <Guest62319> ceti331: gtk+ and win32 are C libraries, cocoa is objc
13:35:51 <davesque> right
13:36:01 <MHD> davesque: (<*>) :: (r -> (a -> b)) -> (r -> a) -> (r -> b)
13:36:04 <ceti331> Guest62319: by "graphics programming" i mean "making the library in the first place", "updating the library for new platforms" - not application level GUI graphics
13:36:17 <Guest62319> ceti331: is that what you are most interested in doing?
13:36:35 <davesque> i think <*> for the instance is defined as `f <*> g = (\x -> f x (g x))`, right?
13:36:36 <ceti331> Guest62319: i dont want to "escape" c++ - i want to compliment it.
13:36:49 <MHD> davesque: No idea
13:36:50 <Guest62319> you cant use haskell and c++, i mean you can, but
13:36:55 <applicative> davesque: yes, the so called S combinator
13:36:56 <noteventime> davesque: Think of it as leaving out an argument in each parameter (which is the one you fill in later)
13:36:57 <Guest62319> oh god why
13:37:08 <davesque> hmm
13:37:24 <davesque> wouldn't it mean that f must take two arguments?
13:37:33 <Guest62319> ceti331: you can do all that low level bit twiddling in haskell if you really want
13:37:42 <MHD> davesque: The Functor, Applicative and Monad instances of (->) r are basically related to Combinator Calculus
13:37:46 <Guest62319> Data.Bits
13:37:50 <davesque> okay
13:37:52 <Guest62319> Data.ByteString
13:37:53 <Guest62319> Data.Word
13:38:00 <MHD> Data.Binary
13:38:08 <noteventime> > (++) <$> reverse <*> id $ "test"
13:38:10 <lambdabot>   "tsettest"
13:38:41 <MHD> The (->) r instances are ultimate obfuscation tools of doom
13:38:50 <MHD> pointfree monsters
13:39:00 <noteventime> davesque: If you understand the Reader instance, it's basically the same
13:39:02 <Taneb> MHD, I take it you've seen my factorial program?
13:39:13 <davesque> well, if `f <*> g = \x -> f x (g x)` and `(+) <$> (*3) <*> (*100) $ 5 == 508`, then...
13:39:19 <MHD> the only thing that tops it is that blog post on stack-based argument manipulation
13:39:40 <MHD> Taneb: no, do link
13:39:52 <applicative> in f <*> x both f and x depend on a parameter of type r so to say when you feed f an r you get a function; when you feed x an r you  get the argument
13:40:02 <Taneb> MHD: http://hpaste.org/raw/71201
13:40:11 <davesque> wouldn't that mean that `pure (+) <*> (*3) == \x -> (+) x ((*3) x)` ?
13:40:20 <danr> I'm looking for a function somewhere in hackage... it made specialised `elem` function for :: Char -> [Char] -> Bool by making a little lookup array (or maybe it was Word8 rather than Char)... anyone know which library I am thinking of?
13:40:36 <MHD> Taneb: NO
13:40:45 <MHD> Taneb: OMG
13:40:51 <applicative> @type pure (+) <*> (*3)
13:40:51 <latro`a> oh my word
13:40:51 <lambdabot> forall a. (Num a) => a -> a -> a
13:40:53 <MHD> Taneb: WAT
13:40:57 <latro`a> what the hell is that
13:41:06 <Taneb> Magic, that's what it is
13:41:15 <applicative> @type pure (+) <*> (*3) <*> (+1)
13:41:15 <lambdabot> forall a. (Num a) => a -> a
13:41:19 <danr> Taneb: what does it do? ;)
13:41:27 <applicative> >  pure (+) <*> (*3) <*> (+1) $ 1000
13:41:28 <lambdabot>   4001
13:41:30 <Taneb> danr, try it with a number no bigger than 9
13:41:51 <Taneb> (it takes about a minute to do 10, and crashes for 11)
13:41:56 <danr> ouch, I have to run this on my own computer? those unsafeCoerces look dangerous
13:42:01 <MHD> Taneb: Are you good at combinator calculus?
13:42:07 <Taneb> MHD, decent
13:42:12 <jimi_hendrix> hmm...so i want to return a variable that is not the return value of the last function i call in my function. i tried just putting the variable name on the last line, but ghc seems to think that is an argument to the last function i call. how should i get around that?
13:42:16 <Taneb> Not an expert
13:42:21 <MHD> danr: They convert Char to Ints
13:42:36 <MHD> Taneb: Don't the unsafe stuff conver Chat to Ints?
13:42:40 <MHD> Char
13:42:42 <danr> there's a readLn there
13:42:45 <Taneb> danr, spoiler: it calculates factorials. The unsafeCoerces are for recursion
13:42:48 <Ornedan> jimi_hendrix: return value?
13:42:54 <MHD> oh snap
13:42:58 <Taneb> :t \r -> r r
13:42:59 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:42:59 <lambdabot>     Probable cause: `r' is applied to too many arguments
13:42:59 <lambdabot>     In the expression: r r
13:42:59 <MHD> recursion
13:43:02 <danr> Taneb: yeah I see your SII SII combinators there... nice hack
13:43:06 <applicative> jimi_hendrix: I think a paste will be easier to understand
13:43:07 <Taneb> :t \r -> r (unsafeCoerce r)
13:43:08 <lambdabot> Not in scope: `unsafeCoerce'
13:43:15 <Taneb> Point is, that works
13:43:27 <davesque> did anyone see what i typed out up there?
13:43:38 <MHD> Taneb: I am never using explicit recursion ever again, thanks for the hack
13:44:00 <Taneb> MHD, using "fix" is a lot nicer
13:44:02 <MHD> davesque: yeah
13:44:11 <davesque> does that look right?
13:44:19 <Taneb> > fix (\r n -> if n == 0 then 1 else n * r (n - 1)) 10
13:44:20 <MHD> Taneb: fix is for loosers who don't understand the power of Y
13:44:20 <lambdabot>   3628800
13:44:20 <jimi_hendrix> applicative, nvm for now. i need to do some stuff. i will deal with this later
13:44:45 <Guest62319> i did like fix
13:44:55 <Guest62319> until i realized that i still have to name the recursive function anyway
13:45:03 <Cale> Guest62319: not always
13:45:17 <Taneb> @pl \r n -> if n == 0 then 1 else n * r (n - 1)
13:45:17 <lambdabot> ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)
13:45:34 <Taneb> > fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)) 10
13:45:36 <lambdabot>   Not in scope: `if''
13:45:40 <Cale> > fix ((0:) . scanl (+) 1)
13:45:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:45:53 <Taneb> Ooh, nice one
13:45:56 <Cale> sometimes it's not even a function
13:46:11 <Guest62319> well in 'loops' where i would use explicit recursion
13:46:14 <Guest62319> to loop
13:46:21 <monochrom> my http://www.vex.net/~trebla/haskell/scanl.xhtml explains fix ((0:) . scanl (+) 1)
13:46:48 <Guest62319> xhtml ? heh
13:47:03 <MHD> What happened to all of those packages on obscure Abstract Algebra that circulated a while back?
13:47:14 <monochrom> yes, ie7 or lower not welcome! maybe ie8 too
13:47:43 <nart> hi :D
13:47:52 <applicative> hi nart
13:47:52 <Taneb> Hey
13:47:57 <noteventime> MHD: obscure abstract algebra?
13:48:08 <Cale> monochrom: How did you generate that? I'm assuming you didn't write that code by hand.
13:48:14 <Cale> (I mean the xhtml)
13:48:23 <MHD> noteventime: Semigroups and strange monad-transformer-esque things
13:48:29 <MHD> with tonnes of continuations
13:48:36 <Cale> hmm
13:48:39 <monochrom> hrm, xhtml is that hard to write by hand?!
13:48:54 <Cale> monochrom: I mean, the stuff in that page looks machine generated :)
13:49:02 <Cale> Of course, you might have written it by hand
13:49:07 <noteventime> MHD: monad-transformer-esque == codensity/free monads?
13:49:15 <monochrom> I write about 90% by hand, have a processer to add the rest (boilerplate)
13:49:17 <noteventime> MHD: I wouldn't say semigroups are obscure :P
13:49:26 <Cale> But most people tend not to put spans around every word :)
13:49:29 <applicative> Cale: what makes you think monochrom isn;t a machine?
13:49:29 <monochrom> but perhaps I am a machine, too
13:49:34 <MHD> noteventime: Yeah, those
13:49:39 <applicative> :)
13:49:48 <monochrom> oh oh! those, I'll tell you. long story
13:50:27 * MHD grokked abstract algebra last week and has been eating wikipedia articles for breakfeast
13:50:57 <noteventime> MHD: They were still there, last time I checked :)
13:51:02 <monochrom> the story is essentially at http://www.vex.net/~trebla/portfolio/index.html  search for the part on "xhtml"
13:51:04 <nart> why is it so difficult to install yesod ? damn it, i only get dependencies errors
13:51:54 <applicative> nart, hm, arent there instructions?  (the short answer is that they improve it too quickly)
13:52:10 <Cale> monochrom: cool
13:52:23 <nart> applicative: yes there are, but they aren't working
13:52:37 <neutrino2000> hi
13:52:40 <applicative> nart there is #yesod; don't know if anyone is awake though
13:52:41 <Cale> MHD: I think you're probably looking for the packages by Edward Kmett
13:52:54 <applicative> nart what os are you using
13:53:00 <MHD> Cale: link?
13:53:14 <Cale> http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=Edward+Kmett
13:53:32 <nart> let's see if happstack is any better
13:53:50 <Cale> (he has a lot of packages, but many of them are nicely algebraic)
13:54:36 <Cale> It used to be that I would just point you at category-extras, but that's been split into lots of smaller packages now.
13:54:45 <noteventime> In what sense is the free monad free?
13:55:07 <luite> nart: what errors do you get?
13:55:27 <luite> nart: are you starting with yesod-platform ?
13:55:49 <noteventime> Just as in you get it for free, or is Free actually left adjoint to a forgetful functor (sending a monad to its underlying functor or something like that?)
13:55:49 <Cale> noteventime: In the opposite sense of being forgetful :)
13:56:23 <luite> nart: there's a problem where yesod-platform depends on a different version of HUnit than the latest haskell-platform
13:56:42 <Cale> http://ncatlab.org/nlab/show/free+monad
13:56:57 <luite> nart: workaround can be installing the yesod package intead of yesod-platform, and then when you generate a project, removing the yesod-platform dependency
13:57:05 <nart> luite: i know, i kept rid of yesod-platform dependecy
13:57:10 <nart> then i got
13:57:21 <nart> cabal: The program happy version >=1.18.5 is required but it could not be
13:57:21 <nart> found.
13:57:21 <nart> Failed to install language-javascript-0.5.4
13:57:31 <nart> then i have installed happy
13:57:39 <ceti331> part of me thinks i should stick with something thats designed to extend c++ (embedded) eg. like python
13:57:43 <nart> but language... doesn't want to istall
13:57:56 <luite> nart: you did cabal install yesod again?
13:57:57 <Cale> ceti331: what?
13:58:20 <ceti331> hehe still undecided about if i want to learn haskell or not
13:58:22 <Cale> ceti331: Since when does python have much of anything to do with C++?
13:58:29 <Nolrai24> So scion-browser 0.2.9 and 0.2.8 fail to compile from cabal for me. Is this a known issue?
13:58:32 <luite> nart: can you paste the build error?
13:58:36 <luite> (hpaste)
13:58:43 <ceti331> Cale: there are C/C++ programs with python embedded for exxtending them
13:58:51 <ceti331> such as blender
13:58:52 <Cale> I mean, apart from both being imperative and to varying extents object oriented.
13:58:59 <Cale> hmm
13:59:11 <Cale> It's not like you can't do that with any pair of languages though
13:59:28 <ceti331> Cale: so if you want to contribute to 'blender', you can do so best if you know c++ & python :)
13:59:29 <noteventime> ceti331: I've been told that doing so is something of a pain though
13:59:34 <nart> luite: http://hpaste.org/72266
13:59:45 <k0ral> hello, I'm wondering what will happen if I embed a MonadError inside another MonadError and if I throwError in the innermost one
13:59:48 <ceti331> possibly
13:59:49 <Cale> Is your main goal to work on Blender, or to learn how to program well?
13:59:50 <Clint> some languages don't have ffi support
13:59:55 <nart> luite: ah, i'm using cabal-dev
14:00:04 <zachk> k0ral: you will end up with a monaderror inside of a  monad
14:00:10 <luite> nart: the real error is earlier, where it tries to install language-javascript, can you find that?
14:00:27 <ceti331> Cale: i can program well in c++. my goal is to learn something i dont already know , and possibly that has some chance of being useful
14:00:38 <k0ral> zachk: could you be more specific please ?
14:00:53 <zachk> not really sure myself, just know in general that is what you will get
14:00:59 <zachk> follow the types
14:01:05 <Cale> Python should be pretty easy for you to pick up if you know C++ well.
14:01:10 <k0ral> will the throwError be propagated to the outermost MonadError, interrupting all subsequent actions ?
14:01:11 <nart> luite: nah, sorry, can't do that
14:01:21 <Nolrai24> k0ral, why would you do so?
14:01:34 <zachk> k0ral: personally, I've taught myself not to think of haskell in that way
14:01:42 <neutrino2000> k0ral: try and see!
14:01:43 <ceti331> Cale: i think learning a languge also means associated libraries
14:01:46 <zachk> yeap :D
14:02:03 <zachk> try trace from Debug.Trace or print or putStrLn if you are in the IO monad at all
14:02:21 <k0ral> Nolrai24: I have f :: (MonadError m) => m (); say f calls g in a loop, which is also (MonadError m) => m ()
14:02:26 <nart> luite: i cleared the buffer and deleted the folder, i was too nervous
14:02:31 <luite> nart: ok, well if you want to try again just give me a call :p
14:02:32 <ceti331> Cale: python itself is easy, the question would be learning associated frameworks.. right now if i want to write 'a serious program', i'll get furhest with c++
14:02:38 <zachk> k0ral: whats your loop look like
14:02:40 <Cale> ceti331: Nothing should be too surprising in that regard. I guess if you've never looked at a dynamically typed OO language before there might be a few idioms that you might not be used to.
14:02:57 <k0ral> Nolrai24, zachk: f = forM g
14:03:00 <noteventime> Hmm, I need to grok kan extensions
14:03:07 <zachk> @type forM
14:03:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
14:03:17 <noteventime> They start appearing all over the place
14:03:21 <Cale> But mostly you should be able to read documentation and get up to speed on most things in a few days. The language isn't that different :P
14:03:28 <zachk> k0ral: http://hpaste.org the actual code?
14:03:40 <Cale> Most popular languages are just reskinnings of each other
14:03:40 <nart> luite: ok i'll try again, but this time i'll try with the latest version for github
14:03:51 <k0ral> zachk: if you promise not to say tl;dr
14:04:10 <zachk> whats tl dr mean? im not up on abrrev.s these days
14:04:12 <Cale> While there are semantic differences between C++ and Python, the way that you fundamentally encode programs in them is more or less the same.
14:04:20 <noteventime> zachk: Too long, didn't read
14:04:20 <Cale> zachk: too long, didn't read
14:04:21 <k0ral> zachk: too long; didn't read
14:04:30 <luite> nart: uh, usually installing from hackage gives you a better chance of success
14:04:32 <zachk> o, is it under a hundred lines?
14:04:33 <k0ral> hey, it's a semicolomn guys
14:04:34 <neutrino2000> what is the easiest way to write a 2d bit mask of variable size?
14:04:35 <k0ral> not a comma
14:04:37 <luite> the latest github stuff is yesod 1.1 beta
14:04:42 <Nolrai24> k0ral: I am fairly sure that the code ends up using bind to flaten that into one layer of MonadError. Thats kind of what Monads do.
14:04:45 <luite> with conduit 0.5 and wai 1.3
14:05:00 <nart> luite: well you see, nothing is working right know so
14:05:06 <Cale> k0ral: The semicolon is an abbreviation of the comma, lol.
14:05:06 <k0ral> Nolrai24: so any error in g will interrupt the loop ?
14:05:14 <luite> nart: the problem seems to be with language-javascript
14:05:26 <zachk> k0ral: you might want to use ContT (never done so myself though)
14:05:31 <Nolrai24> k0ral: unless you use a catch, yes.
14:05:35 <luite> nart: so i'd try to fix that before trying an experimental yesod version
14:05:56 <neutrino2000> should i make it a list of lists of Bool?
14:06:07 <Cale> neutrino2000: Probably to use Data.Array.Unboxed
14:06:27 <k0ral> Nolrai24: what if I write f = forM (runErrorT . g) >>= either X Y ?
14:06:31 <neutrino2000> Why would i use an unboxed type?
14:06:53 <Guest62319> ContT, far out
14:07:08 <k0ral> zachk: so ? do you promise ? :)
14:07:23 <zachk> if it is under 100 lines of code, yes :D
14:07:43 <k0ral> 123 lines, including imports, comments and blank lines
14:07:45 <zachk> I will read every line of it, not that I will understand every single line, but I will read every line, I promise, if it is under 100
14:07:46 <nart> luite: ok, i'll retry from hackage, let's wait another 10 minutes waiting for cabal-dev to do its work
14:07:47 <zachk> ok that is fine
14:07:54 <zachk> I will read it
14:07:57 <zachk> hpaste it up
14:07:58 <Nolrai24> @ty ff g = forM (runErrorT . g) >>= either X Y
14:07:59 <lambdabot> parse error on input `='
14:08:02 <k0ral> zachk: dealt
14:08:15 <Nolrai24> @ty \ g -> forM (runErrorT . g) >>= either X Y
14:08:16 <lambdabot> Not in scope: data constructor `X'
14:08:16 <lambdabot> Not in scope: data constructor `Y'
14:08:26 <applicative> nart: what version of ghc are you using
14:08:31 <Nolrai24> @ty \ g x y-> forM (runErrorT . g) >>= either x y
14:08:31 <lambdabot> forall e (m :: * -> *) a b a1 b1. [ErrorT e m a] -> (a1 -> (m (Either e a) -> Either a1 b) -> b1) -> ([b] -> (m (Either e a) -> Either a1 b) -> b1) -> (m (Either e a) -> Either a1 b) -> b1
14:08:34 <nart> applicative: 7.4.2
14:08:35 <Cale> neutrino2000: Because unboxed arrays of Bool get packed as bit fields
14:08:41 <applicative> hmmm
14:08:45 <Cale> neutrino2000: assuming that you really want that representation
14:09:00 <Cale> neutrino2000: Of course, nothing is stopping you from using lists of lists of Bool
14:09:06 <neutrino2000> Cale i don't care what they look like in memory, i just want the functionality of an nxm table of bools.
14:09:13 <neutrino2000> ok
14:09:14 <Cale> neutrino2000: Except that it's really inefficient
14:09:18 <neutrino2000> i think i'll do that then
14:09:19 <Nolrai24> K0ral: is g suposed to be a list of actions?
14:09:21 <Cale> (for most cases)
14:09:28 <k0ral> zachk: https://gist.github.com/3194791
14:09:28 <neutrino2000> inefficiency isn't a problem in this program
14:09:30 <Guest62319> Array (Int,Int) Bool
14:09:42 <Cale> Or yeah, you could just use a normal Array
14:09:57 <nart> what are your thoughts about happstack ?
14:09:59 <Cale> Or even a Map
14:10:10 <neutrino2000> hmm
14:10:14 <Taneb> scanl is backwards induction!?
14:10:18 <Taneb> noitcudni!
14:10:19 <neutrino2000> what's a Map?
14:10:23 <k0ral> zachk: as a summary, it downloads are parses RSS feeds; the idea is that I want the process to continue even if a feed or a particular item fails at being parsed e.g.
14:10:32 <monochrom> scanl is not backwards induction
14:10:44 <Guest62319> Data.Map (Int,Int) Bool
14:10:45 <Cale> Data.Map http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map.html
14:10:46 <monochrom> although I don't know what backwards induction means
14:10:55 <neutrino2000> thanks
14:10:55 <k0ral> any comment on this code is welcome :)
14:10:59 <Cale> Data.Map.Map, actually
14:11:02 <zachk> k0ral: have you thought of using Maybe? or Either?
14:11:14 <Taneb> monochrom, I just saw it and thought "woah, that looks a lot like induction"
14:11:17 <k0ral> zachk: ErrorT uses Either
14:11:17 <Guest62319> oh yeah
14:11:18 <Cale> (though usually I import the type name unqualified)
14:11:26 <zachk> ahhh ok
14:11:29 <neutrino2000> @src scanl
14:11:29 <lambdabot> scanl f q ls = q : case ls of
14:11:29 <lambdabot>     []   -> []
14:11:29 <lambdabot>     x:xs -> scanl f (f q x) xs
14:11:32 <Taneb> It might even be plain ol' induction
14:11:37 <Cale> oh, most of the documentation is in here now: http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Map-Lazy.html
14:11:45 <Cale> neutrino2000: ^^
14:11:46 <k0ral> Nolrai24: g is a sequence of actions, but not a loop, if that was your question
14:11:53 <monochrom> it is the usual induction. f (n+1) = ... n ...
14:11:54 <Guest62319> Taneb: unfoldr
14:11:55 <neutrino2000> thanks Cale
14:12:13 <Taneb> You give it a base case, and a way of "toppling the dominoes", and you get ALL OF THE SEQUENCE
14:12:17 <Nolrai24> k0ral: then use catch on each invidulal item:" f = forM (g `catch` x)" where x does what you want to do on a failure.
14:12:22 <Guest62319> Taneb: yeah thats unfold
14:12:25 <Taneb> > scanl not False
14:12:26 <lambdabot>   Couldn't match expected type `b -> GHC.Bool.Bool'
14:12:26 <lambdabot>         against inferred ...
14:12:30 <Taneb> :t scanl
14:12:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
14:12:36 <Taneb> Is it?
14:12:37 <Taneb> Okay
14:12:41 <Taneb> :t unfoldl
14:12:42 <lambdabot> Not in scope: `unfoldl'
14:12:44 <Taneb> :t unfoldr
14:12:45 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:12:46 <monochrom> I hate the domino analogy
14:12:55 <Guest62319> hater
14:13:00 <Nolrai24> What domino anology?
14:13:01 <Taneb> So do I, I just can't think of the actual word
14:13:04 <Cale> Taneb: Everything which is recursive has a connection to induction :)
14:13:19 <Taneb> Cale, aaaah everything is starting to make sense
14:13:21 <monochrom> I use the wish-granting fairy analogy. my invention.
14:13:32 <Taneb> It's like I'm in a black hole of sense-making
14:13:44 <monochrom> the fairy grants you two wishes. your first wish: receive a gold nugget today
14:14:08 <noteventime> Taneb: Chech out algebraic semantics, if you're interested in the details
14:14:23 <monochrom> your second wish: for every day, if you received a gold nugget the day before, you wish to receive a gold nugget this day
14:14:33 <Nolrai24> I am still having trouble understanding how co-induction to build things. I get how bisimulations work, but I am not sure if that is even related.
14:15:09 <Nolrai24> s/to build/builds/
14:15:49 <Nolrai24> k0ral: was that what you needed?
14:15:50 <noteventime> Nolrai24: Do you understand unfold?
14:16:05 <Nolrai24> @ty unfold
14:16:06 <lambdabot> Not in scope: `unfold'
14:16:12 <applicative> @type unfoldr
14:16:13 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:16:23 <monochrom> anyway, induction justifies recursive definitions
14:16:48 <zachk> k0ral: done reading it... does it work? ;) and line 95 is kinda long, overall it looks like a heavy imperative style, but perfectly valid, and who(or what is) Imm?
14:16:53 <Guest62319> > x = x + 1
14:16:54 <lambdabot>   <no location info>: parse error on input `='
14:17:13 <Guest62319> > let x = x + 1 in x
14:17:15 <applicative> > let x = x + 1 in x
14:17:17 <lambdabot>   mueval-core: Time limit exceeded
14:17:19 <lambdabot>   mueval-core: Time limit exceeded
14:17:35 <Nolrai24> Guest62319: that works if the type of x is co-recursive.
14:17:36 <noteventime> > fix (+1)
14:17:38 <Guest62319> works in every other language ;)
14:17:40 <lambdabot>   mueval-core: Time limit exceeded
14:17:53 <applicative> > let x = 1:x in x
14:17:54 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:18:07 <k0ral> Nolrai24: I'm performing tests, I will let you know how it ends up
14:19:04 <zachk> k0ral: http://hpaste.org/72267 is your code
14:19:12 <zachk> with syntax highlighting
14:19:14 <k0ral> zachk: it compiles and works, yes; imm is here: https://github.com/k0ral/imm
14:19:49 <k0ral> zachk: you could say it's projector from RSS feeds over maildirs
14:20:14 <k0ral> zachk: for each feed entry, it creates a new mail
14:20:25 <k0ral> zachk: that way, I can read my RSS feeds using mutt
14:20:31 <zachk> sounds cool, could be a little spammy though
14:20:32 <nart> luite: ok, again the same error, but how do i find the specific error ?
14:20:41 <k0ral> zachk: definitely
14:21:18 <Nolrai24> Any one have a clue why scion-browser >= 0.2.8 fails to compile?
14:21:25 <k0ral> zachk: so, have you something to suggest apart from Nolrai24's solution ?
14:21:53 <luite> nart: scroll back to where it installs language-javascript
14:22:02 <luite> nart: or just paste the whole thing :)
14:22:23 <Nolrai24> Any one have a clue why scion-browser >= 0.2.7 now.
14:22:24 <zachk> k0ral: not currently, maybe you could abstract a way a little bit
14:22:30 <Nolrai24> grr...
14:22:40 <k0ral> zachk: line 95 is just the type of the function, does it matter how long it is ? :)
14:22:47 <Nolrai24> Never had a Hackage pakege do this to me before.
14:22:57 <zachk> well you were interested in comments, just saying that one seemed a bit too long
14:23:05 <k0ral> zachk: how so ?
14:23:20 <zachk> I had to scroll horizontally to read it all
14:23:35 <k0ral> zachk: I mean: how would you abstract it ?
14:23:38 <nart> luite: damn it, there is too much stuff, i cannot scroll back till the error
14:24:11 <zachk> k0ral: not sure atm, I am a long term neophyte currently, thought it seems most of your types are a -> m b where m is some sort of IO
14:24:36 <zachk> and also alot of them are just a -> m () so they are just "dead" commands in a sense
14:24:38 <Rc43> Hi, guys.
14:24:42 <zachk> hello
14:24:51 <nart> luite: http://hpaste.org/72268
14:25:01 <nart> luite: so i think i should install happy
14:25:15 <k0ral> zachk: well, they are purely-impure functions :)
14:25:20 <luite> nart: yes, cabal cannot install happy automatically since it's a program, not a library
14:25:48 <luite> nart: it comes with the haskell platform, but if you just installed ghc you have to install happy manually
14:25:58 <zachk> k0ral: yeap :-D just saying as it grows, you might want to try to seperate can be made pure from what is impure
14:25:58 <monochrom> the haskell platform has happy
14:26:03 <luite> nart: cabal install happy should do the trick, make sure that it ends up somewhere in your PATH
14:26:14 <parcs`> which could be easily fixed by having happy export a dummy module
14:26:27 <parcs`> (why doesn't it?)
14:27:01 <nart> luite: damn it, it was so simple, i was installing happy before, but using cabal-dev -.-'
14:27:04 <nart> luite: thanks
14:27:04 <monochrom> I don't know. why doesn't cabal-install also export a dummy module?
14:28:31 <parcs`> it should!
14:28:40 <parcs`> so that cabal-dev could list it as a dependency
14:29:05 <luite> parcs`: that wouldn't have helped for nart btw, since cabal-dev would have just installed it in a not-in-PATH location
14:29:09 <monochrom> and cabal-dev also exports a dummy module...
14:29:27 <nart> luite: http://hpaste.org/72269
14:30:37 <luite> nart: do cabal-dev install first in your project dir
14:31:01 <hpaste> nolrai24 pasted “scion-browser error” at http://hpaste.org/72270
14:31:40 <Nolrai24> Any one have a clue how to get scion-browser installed?
14:31:47 <Nolrai24> I did it a few months ago..
14:31:52 <monochrom> unrelated, but do you know the real logical consequences of "sudo cabal install"?
14:31:56 <nart> luite: i did that, it seems linked to this issue https://github.com/yesodweb/yesod/issues/323
14:32:21 <Nolrai24> monochrome: does it mater if I am the only user of the machine?
14:32:33 <luite> nart: oh crap i fixed that in an unreleased branch :(
14:32:38 <Nolrai24> (that is not a retorical question)
14:33:04 <luite> nart: i think its's a bug in cabal-dev, but i had a workaround, let me check
14:33:23 <chrisdone> shapr: seen? http://ignite.io/
14:33:32 <monochrom> I don't know how to answer that question. on most *nix hosts, there are always at least two users, yourself and "root", which is not yourself. two different home directories, can't be the same "user"
14:33:32 <geekosaur> Nolrai24, it matters, yes
14:33:45 <geekosaur> unless you regularly do everything, and I mean everything, as root
14:33:58 <Nolrai24> well sh**
14:34:02 <Nolrai24> hmm.
14:34:25 <Guest62319> sheeeeit
14:34:30 <monochrom> otoh, "sudo cabal install --global" does what you think
14:34:40 <Nolrai24> monochrom: I meant as in human beings.
14:34:47 <Nolrai24> Not 'users'
14:34:56 <luite> nart: can you try cabal-dev configure first or something?
14:34:59 <monochrom> the computer doesn't know there is only one human being
14:35:00 <geekosaur> unix does not know of that, it knows of Unix users
14:35:02 <Nolrai24> (otherwise I wouldn't need to use sudo would I?)
14:35:13 <Guest62319> in a normal two person home there are two users
14:35:17 <geekosaur> you don;t need sudo to do cabal stuff without --global
14:35:30 <Guest62319> root who can do anything and everything, and you the unprivilaged user
14:35:42 <Guest62319> i.e. your wife and you
14:35:47 <chrisdone> cabal-dev 4lyfe
14:35:58 <Peaker> Guest62319, except kill processes stuck in kernel syscalls
14:36:07 <Peaker> and a few other useful things
14:36:08 <Nolrai24> Then why is cabal giving me "permission denied errors"
14:36:09 <nart> luite: done, same error
14:36:20 <luite> nart: sorry i forgot what the exact problem and workaround were, but it involved running something before something else :p
14:36:34 <mel-> hi
14:37:09 <monochrom> my point is "sudo cabal install --user" has something to do with the /root directory. oh you didn't enter "--user"? but that's the default
14:37:41 <Nolrai24> hmm. I just added sudo because it seemed to fix things..
14:37:45 <Nolrai24> >.<
14:37:52 <monochrom> if you didn't enter "--global" then you have entered "--user" by a fine print in the EULA
14:38:07 <geekosaur> it "fixed" something, maybe, but not the way you thionk it did
14:38:09 <monochrom> oh, it fixes some things and breaks some others
14:38:31 <Nolrai24> well oh well.
14:38:32 <geekosaur> maybe you have permissions issues with your ~/.cabal in which case "sudo chown -R $USER ~/.cabal" might help
14:38:43 <monochrom> every programmer is familiar with this phenomenon
14:38:45 <Nolrai24> That I think is what is going on.
14:38:55 <geekosaur> but sudo with cabal and without --global installs stuff in the private area of the Unix root user, and you can't make use of the result
14:39:13 <luite> nart: what does cabal-dev buildopts say?
14:39:39 <geekosaur> unless you do everything else as root also, so you are using root's private area all the time
14:39:48 <k0ral> Nolrai24: you were right all along: forM is expanded directly within the global MonadError
14:39:56 <Nolrai24> That sounds like a bad idea.
14:39:59 <k0ral> Nolrai24: using catchError "fixes" it
14:40:10 <nh2> can somebody explain me cabal?
14:40:13 <nh2> "cabal: The following packages are likely to be broken by the reinstalls:"
14:40:23 <nart> luite: that error, (Warning: cannot determine version of ...
14:40:24 <nh2> how can a _reinstall_ of the _same version_ of a package break something?
14:40:25 <Nolrai24> k0ral: thats what it should do.
14:40:56 <monochrom> ok, time for everyone to read my http://www.vex.net/~trebla/haskell/sicp.xhtml again. it answers all your cabal questions and breaks all your expectations
14:41:06 <nand`> I think I've asked this before, but is GHC/cabal capable of building using multiple threads in general? (For multi-core optimization)
14:41:25 <geekosaur> nh2, the ABI hash differs, so *something* (possibly build options) is different
14:41:43 <k0ral> nh2: as far as I remember, an identical version number doesn't guarantee that there has been no change from last time
14:41:46 <geekosaur> nand`, ghc's internals don't know how to take advantage of multiple threads
14:41:57 <monochrom> inlined code from other packages differ
14:42:14 <luite> nart: hmm, does the package build and install completely with cabal-dev install ?
14:42:49 <nart> luite: yes it does
14:42:51 <Nolrai24> Well getting rid of the sudo changes nothing about what happens when I use cabal to try and install scion-browser.
14:42:52 <nh2> nand`, geekosaur: see last answer to http://stackoverflow.com/questions/7238147/can-i-get-cabal-install-to-use-multiple-cores! yay!
14:43:17 <monochrom> yeah, it's a compiler error, I don't know why that happens
14:43:18 <Nolrai24> It's a good thing I talked to you though..the sudo thing would have confused me to no end.
14:43:33 <geekosaur> nh2, that is only a partial solution though, cabal can parallelize but ghc itself can;t so it's only a partial speedup
14:43:42 <monochrom> presumably the author had tested it but...
14:43:53 <nand`> nh2: interesting. Unfortunately, I'm not interested in cabal-install
14:43:58 <nand`> if plain cabal can do it, that would be cool
14:43:58 <luite> nart: does cabal-dev ghci work?
14:44:06 <nart> luite: no, same error
14:44:19 <geekosaur> and since cabal defers much of the actual build logistics to ghc, that means you don;t get as much as you'd think from just cabal-install being parallelized
14:44:28 <nh2> geekosaur, nand`: doesn't he also say he's working on a wrapper to parallelize ghc --make?
14:44:36 <Nolrai24> monochrome: Thats what I thought..grr. Well is there a way to resolve the dependency issues with 0.2.6?
14:44:44 <geekosaur> yes, and I'm talking based on the discussion of that wrapper on the ghc list
14:44:45 <nand`> nh2: I interpreted that as a wrapper /around/ ghc --make
14:44:58 <nand`> oh, neat
14:45:04 <monochrom> eh? is there any reason you go with 0.2.7 instead of say 0.2.9?
14:45:04 <nand`> nh2: I see what he means now, https://github.com/23Skidoo/ghc-parmake
14:45:23 <luite> nart: bah, it definitely is some cabal-dev problem, but i don't know how to solve it. perhaps you can try virthualenv
14:45:34 <nand`> nh2: it would still be good to get parallelism into plain ghc or plain cabal; since that's what my distro's build system for Haskell uses
14:45:37 <geekosaur> where it was determined that parts of ghc's core can't be shared across threads sanely so you don't get much of a speedup that way and it would take significant changes to ghc's guts to fix it
14:45:39 <nand`> which is the component I am trying to speedu p
14:46:13 <nart> luite: thanks anyway ... does virthualenv work on osx ?
14:46:16 <nand`> geekosaur: I see
14:46:52 <nh2> geekosaur, k0ral: hmm. Actually, I just want to install ghc-mod, but I don't know how to go about this: http://hpaste.org/72271
14:47:15 <luite> nart: don't know. if you use OS X, don't use 64 bit ghc by the way
14:47:20 <nh2> nand`: true
14:47:33 <luite> nart: ghci has some bugs that make lots of stuff, including yesod devel, crash
14:47:36 <monochrom> why do you have containers-0.5.0.0 apart from upgrade whore?
14:47:41 <nart> luite: whoops
14:47:59 <nart> luite: 64bit ghc it's the only to instal wxhaskell
14:48:03 <geekosaur> actually, if I recall details correctly, ghc insists on reloading stuff about included modules every time and there's no way to share it because of the way it does it.  lemme see if I can find the list discussion
14:48:07 <nh2> monochrom: I don't know, should I not have it?
14:48:11 <Nolrai24> monochrome: is that at me?
14:48:32 <nh2> monochrom: or at me? :D
14:48:40 <luite> nart: aie :( OS X is not the greatest platform for haskell at the moment
14:48:57 <redscare> to learn haskell, I am building a simple system monitoring utility that is organized this way: there is a main loop that gets output from functions I import from other modules, then calls itself continually. One of the modules I wrote reads system information from an OS-generated file. The thing is, this file cat be called 'a.txt' or 'b.txt', totally randomly, and changes at random times (please don't ask why :)). I was wondering if
14:48:57 <redscare> there was a way to write the function that reads these files so that, when called by the main loop, it tries to read, for example, 'a.txt'. If an exception occurs, I want the function to read 'b.txt', AND, transparently to the writer of the main loop, store in some sort of global variable that the next time that function calls itself, it should look for 'b.txt'. i.e., if haskell allowed module-wide global variables, I'd have a variable
14:48:57 <redscare> set to the latest file that didn't cause an exception
14:49:05 <nart> luite: awesome :(
14:49:28 <geekosaur> ah, right, and had forgotten abotu this little gem http://haskell.1045720.n5.nabble.com/parallel-build-fixes-for-7-4-2-td5512007.html
14:49:44 <luite> nart: have you tried using wxhaskell from ghci?
14:49:55 <nart> luite: yep, it doesn't work -.-'
14:50:01 <luite> nart: segfaults?
14:50:11 <nart> luite: yep
14:50:15 <luite> right, same bug probably
14:50:31 <nart> i think the best way is to install linux in a vm
14:50:36 <monochrom> containers comes with GHC. general safety procedure regarding packages that come with GHC: do not "upgrade", unless these two conditions are true: you need the upgrade now, and you know everything about packages
14:50:46 <nart> i just wonder what the performance will be
14:50:48 <user___> martin
14:51:05 <luite> nart: works ok for me :)
14:51:13 <luite> ubuntu in a vm
14:51:18 <Peaker> new cabal prevents these "upgrades" mostly
14:51:20 <nart> luite: i have macbook 8gb ram + ssd
14:51:36 <luite> me too, only without ssd
14:52:01 <nart> luite: well, buy that, it's a whole new experience
14:52:11 <supercali> Greetings, enlightened citizens ..
14:52:18 <monochrom> actually, "cabal install --global --dry-run containers" succeeds
14:52:30 <luite> i know, but don't have the cash at the moment
14:52:37 <nart> luite: what do you use to virtualize ?
14:52:43 <luite> vmware fusion
14:52:48 <supercali> i have a question regarding comparing two functions for equality
14:53:01 <Nolrai24> Well I guess I program haskell in windows, cause I can make eclipse-fp work there. (probobly because of when I installed it..or the ghc version, or black magick.) Very disapointing.
14:53:34 <nart> luite: thanks, i'll setup it up :)
14:53:37 <geekosaur> supercali, just ask your question, if someone can answer they will
14:53:47 <Nolrai24> monochrome: just out of curiosity what ide do you use?
14:53:57 <monochrom> emacs most of the time
14:53:57 <supercali> would it be possible to do "f = g", if f and g are functions ?
14:54:14 <jmcarthur> you mean == instead of =, i assume?
14:54:26 <supercali> yes, equality .. basically ..
14:54:33 <monochrom> I used eclipse-fp a bit a long time ago. it was ok but not great. I think it's great now, but I don't have large enough projects to require it
14:54:38 <noteventime> supercali: Not for arbitrary functions
14:54:41 <nh2> monochrom: how can I find out which containers version is the one from ghc? should I remove containers-5.0.0.0 to fix my problem?
14:54:43 <jmcarthur> the only way i know of for that to work is if you have an enumerable domain and you exhaustively check every possible input
14:54:44 <supercali> total ones ?
14:54:52 <Nolrai24> If you define a instance, it will only be computable in a resonable time if thier arguments are of small types.
14:54:58 <parcs`> :t \f g -> map f [minBound..maxBound] == map g [minBound..maxBound]
14:54:59 <lambdabot> forall a b a1. (Bounded a, Enum a, Bounded a1, Enum a1, Eq b) => (a -> b) -> (a1 -> b) -> Bool
14:55:10 <monochrom> well, you will remove containers-0.5.0.0 and everything built upon it...
14:55:41 <nh2> monochrom: is there functionality in cabal that can automatically rebuild those packages against containers-whatever-comes-with-ghc?
14:55:49 <supercali> hmm .. has anyone worked in Isabelle ?
14:55:52 <monochrom> no
14:56:06 <supercali> there you can compare two functions, and prove that they are equal ..
14:56:18 <redscare> is there a way to have module-scoped global variables in haskell? so that the module's functions can work with them, but outside functions don't need to know?
14:56:21 <jmcarthur> supercali: right, but you have to prove it. the language doesn't do it for you
14:56:30 <monochrom> maybe not entirely no. just install things you need on demand
14:56:35 <supercali> yes . i see ..
14:56:51 <monochrom> s/on demand/lazily/
14:57:01 <nh2> monochrom: I will try. By the way: is ghc-pkg unregister still the way to remove packages or is there some "cabal remove" by now?
14:57:14 <monochrom> ghc-pkg unregister
14:57:31 <nh2> monochrom: thanks
14:58:03 <monochrom> ho hum, hackage.haskell.org is being slow
14:58:07 <nilg> is Haskell better than Clean?
14:58:19 <monochrom> maybe
14:58:32 <jimi_hendrix> so i want to return image from the function in the following paste, but if i just put "image" on a new line at the bottom, ghc seems to think it is another argument to zipWith. how do i resolve that
14:58:54 <hpaste> jimi_hendrix pasted “need to return image” at http://hpaste.org/72272
14:58:56 <jmcarthur> "better" is too context-sensitive to answer that question properly
14:59:18 <jimi_hendrix> (i could be doing something horribly wrong, as i am a haskell noob)
14:59:22 <jmcarthur> i think most language are non-comparable, in that sense
14:59:25 <jmcarthur> *languages
14:59:29 <monochrom> but "maybe" is a great answer given the circumstance!
14:59:36 <nh2> Uh. cabal install --reinstall --only-dependencies -> "Use --reinstall if you want to reinstall anyway." What the heck?
15:00:31 <supercali> @monochrom: "it depends" is a safe answer no matter what the circumstance ;) !
15:00:32 <lambdabot> Unknown command, try @list
15:00:56 <parcs`> nh2: --force-reinstallls
15:01:30 <monochrom> "it depends" gives too much information. "maybe" gives less information. and I want to give less information, since the question is even less informative
15:01:41 <supercali> he he..
15:01:41 <nh2> parcs`: like this? "cabal install --only-dependencies --reinstall --force-reinstalls"? still the same
15:02:15 <monochrom> you may also like http://hackage.haskell.org/trac/ghc/ticket/5442
15:02:27 <coderarity> haskell would be an awesome shader language
15:02:31 <parcs`> nh2: *shrug*
15:02:45 <parcs`> coderarity: yes. see GPipe
15:03:43 <monochrom> perhaps "no comment" gives even less information :)
15:03:45 <coderarity> parcs`, that's pretty cool
15:04:10 <supercali> yes, but then you'd work in Haskell PR ;) !
15:04:45 <supercali> btw (off-topic), is there a way to see a "Conversation-View" on IRC ?
15:05:08 <coderarity> supercali, probably depends on your IRC client
15:05:14 <supercali> there are atleast two threads of conversation here, and it is all interleaved .. messy ..
15:05:18 <monochrom> that depends on the software you use. but I don't know what that view looks like
15:05:21 <nh2> more cabal questions: is it safe to use multiple cabal installs at the same time?
15:05:29 <supercali> ah .. i'm just using webchat.freenode ..
15:05:49 <supercali> what's a recommended client?
15:05:57 <jimi_hendrix> supercali, what do you mean by conversation-view?
15:05:58 <latro`a> I use xchat
15:05:59 <monochrom> oh then almost no irc software does it.
15:06:00 <jimi_hendrix> also, i use xchat
15:06:09 <geekosaur> irc has no concept of conversations, sadly
15:06:12 <zachk> the kind that doesn't ask for personal information and only accepts bitcoin or cash, supercali?
15:06:23 <monochrom> haha
15:06:29 <supercali> he he.. nothing of the sort ;) !
15:06:30 * geekosaur has often wished irc had something like zephyr instances
15:06:43 <supercali> yeah ... i was thinking of some column view ..
15:06:52 <supercali> each conversation mapped to a column ..
15:06:53 <zachk> zephyr? isn't that some old emacsing thing?
15:07:08 <jimi_hendrix> well
15:07:11 <jimi_hendrix> that would be cool
15:07:24 <monochrom> I and a few others stubbornly refuse to start sentences with "nickname:". any threading software will have to have some AI algorithm to detect that I'm answering your question, or else just give up
15:07:26 <geekosaur> it's independent of emacs although some places (MIT, parts of CMU) preferentially use emacs-based clients
15:07:29 <jimi_hendrix> but then i would imagine you would have to "join" a conversation
15:07:42 <jimi_hendrix> and then it would just be a channel within a channel
15:07:48 <geekosaur> not really, no, it's just a way to filter things.  by default it's unfiltered
15:07:54 <supercali> channel_ception !
15:07:57 <geekosaur> and just acts as a tag you can see on each message
15:08:10 <supercali> geekosaur: yeah ..
15:08:16 <statusfailed> Is it possible to make a polymorphic list with RankNTypes?
15:08:19 <jimi_hendrix> monochrom, threading software?
15:08:26 <monochrom> yes
15:09:10 <monochrom> like in the above example, I merely enter "yes", and the software is supposed to know that I'm answering the question "threading software?", and group the two messages together
15:09:12 <geekosaur> unforutnately to do it with IRC you would have to replace everyone's IRC clients with versions that included some kind of tag, and then teach everyone to use the tags.  not gonna happen
15:09:31 <geekosaur> (otherwise, well, see what monochrom just said)
15:09:47 <supercali> yeah .. but hashtags took off by storm
15:10:00 <supercali> so it's not like there is not precedent
15:10:11 <geekosaur> yes, but IRC clients dont usually have a convenient way to do anything with them
15:10:24 <statusfailed> Neither did twitter clients, though
15:10:49 <supercali> Where there's a hashtag there's a WAY !
15:10:58 <supercali> like Google+ found out ;) !
15:10:59 <geekosaur> no, what they had was that 99% of then were web pages, so people just did fancier web pages (cf. tweetgrid)
15:11:30 <geekosaur> whereas most IRC users use dedicated clients, and those would have to pave the way. (whereas with twitter they were forced to respond to the original web interface evolving)
15:11:33 <redscare> is there a way to have module-scoped global variables in haskell? so that the module's functions can work with them, but outside functions don't need to know?
15:11:36 <hpaste> jimi_hendrix pasted “zipWith has 5 arguments?” at http://hpaste.org/72273
15:11:52 <geekosaur> redscare, you can include an export list in  a module declaration
15:11:58 <statusfailed> geekosaur: oh, you mean that the "clients" drove the hashtag, rather than the users?
15:12:03 <jimi_hendrix> so why does ghc think that i am passing 5 arguments to zipWith in that above paste?
15:12:24 <geekosaur> statusfailed, not exactly.  the users drove it but the users were mainly using web interfaces, which adapted nimbly to what the users wanted
15:12:38 <geekosaur> good luck getting mIRC to react nimbly, much less all the users using unregistered versions
15:12:47 <Peaker> jimi_hendrix, you seem to be missing a "do"
15:12:50 <statusfailed> haha
15:12:54 <monochrom> wait, no, not because of zipWith
15:12:54 <Peaker> jimi_hendrix, and your indent style is nuts
15:12:58 <statusfailed> well that it seems to be just a question of demand, right?
15:12:59 <parcs`> statusfailed: what's a polymorphic list?
15:13:10 <statusfailed> parcs`: something like [1, "hi"]
15:13:16 <statusfailed> I don't know the proper term
15:13:16 <monochrom> also where is the closing parenthesis?
15:13:26 <Clint> it's after image
15:13:39 <jimi_hendrix> Peaker, 1) last time i pasted that code, hpaste gave me an error about a redundant do 2) yeah i know. haskell-mode in emacs is being weird. i need to fix that
15:13:51 <redscare> geekosaur: maybe i'm not being clear. i have a function 'readfile' that i want to be able to call multiple times from other modules, but 'readfile' might be reading a different file each time it runs (or possibly the same file). But the caller doesn't need to know or care.
15:13:52 <zomg> You could just make a new channel if you want to talk about some specific topic. No reason to keep it a long lasting one =)
15:14:20 <noteventime> statusfailed: I think they're called heterogenous lists
15:14:38 <statusfailed> ah, so they are!
15:14:39 <statusfailed> thanks :)
15:14:43 <monochrom> oh yikes, I find it now. but then why is "return image" aligned with "setPixel"?
15:14:46 <geekosaur> redscare, ummm, you're asking for trouble there I think.  I can think of ways to do it, mostly involving unsafeInterleaveIO or similar
15:14:53 <chrisdone> little 8 minute video of coding in fay. nothing particularly interesting, basically jquery programming, but just to show it *works* and is pretty usable http://www.youtube.com/watch?v=dhFZ8vx9byc&feature=youtu.be
15:15:12 <jimi_hendrix> Peaker, anyway, adding a do doesnt change anything
15:15:17 <parcs`> statusfailed: you can create a heterogeneous list by pretending (,) = (:) and () = []
15:15:34 <parcs`> > (1, ("hi", ()))
15:15:35 <lambdabot>   (1,("hi",()))
15:15:42 <monochrom> the 4th parameter is "return" and the 5th parameter is "image"
15:16:03 <hpaste> Peaker annotated “zipWith has 5 arguments?” with “SANER: zipWith has 5 arguments? (annotation)” at http://hpaste.org/72273#a72274
15:16:05 * chrisdone wonder if i can increase the speed of the video with youtube
15:16:22 <geekosaur> redscare, do remember that as soon as you start thinking in terms of global variables in Haskell, you're getting yourself into trouble
15:16:22 <jimi_hendrix> monochrom, i just put that on the end as a bit of non-permanent experimentation, which is why it isnt indented nicely there.
15:16:37 <noteventime> statusfailed: http://hackage.haskell.org/package/HList <- in case you haven't seen
15:16:42 <jimi_hendrix> monochrom, but why does it think that there are 5 arguments
15:16:46 <statusfailed> parcs`: I was really just interested in the case of how Rank N types help
15:16:46 <jfischoff> chrisdone: how tied to the DOM is fay? I ask because I have to do some javascript automation of Flash, and I'm considering using fay.
15:16:49 <monochrom> I just answered
15:16:50 <Peaker> jimi_hendrix, a multi-line lambda in () is not nice.. split into a where.. a "let" that can be a "where" probably should be
15:16:59 <redscare> geekosaur: well i don't really think i can avoid it. It reads one of two files, I don't want to check for existence every call as the file is unlikely to change, but it can, so if an exception occurs i want to change the file being checked
15:17:01 <statusfailed> parcs`: but that is a good point :)
15:17:14 <jimi_hendrix> Peaker, i see
15:17:22 <redscare> geekosaur: not sure that there's a way around this
15:17:54 <Peaker> jimi_hendrix, btw: the [0..length colors] is superfluous, better just zip with [0..]
15:17:58 <statusfailed> :q
15:17:59 <statusfailed> oops
15:18:04 <quintessence> statusfailed: rank N types lets you put "forall" to the left of a function arrow, but you need ImpredicativeTypes to do something like [id, const undefined] :: [forall a. a -> a]
15:18:15 <Peaker> jimi_hendrix, no need to iterate the list to compute the length, zip truncates to shortest arg anyway
15:18:18 <noteventime> chrisdone: youtube-dl -g URL | xargs vlc/mplayer -whatever-playback-speed-parameter :)
15:18:33 <chrisdone> jfischoff: it's only tied to javascript, it doesn't care about running in a browser or node or w/e. i'd be interested to hear how well it works for flash
15:19:13 <chrisdone> jfischoff: (*everything* to do with the DOM/jQuery in that example is bounded via ffi within the same file: https://github.com/chrisdone/fay/blob/master/docs/home.hs)
15:19:17 <statusfailed> quintessence: It turns out I was thinking of the example with ExistentialQuantification on the "heterogenous collections" page
15:19:31 <statusfailed> but actually yours is also interesting...
15:19:31 <statusfailed> :D
15:19:49 <geekosaur> redscare, I think with sufficient hackery you can do it with unsafeInterleaveIO, but it will be very ugly and possibly prone to weirdness.  as I said, you're already in trouble when you start thinking about such things
15:19:49 <Peaker> jimi_hendrix, Surely "newImage" is impure?
15:20:17 <redscare> geekosaur: thank you. can you think of a 'haskelly' way to get around my problem?
15:21:13 <jimi_hendrix> Peaker, it is. it returns an IO Image
15:21:19 <jfischoff> chrisdone: Great. I have to change our pipeline to generate javascript anyway, so after that Fay could fit in. I'll let you know when I eventually give it a shot ;)
15:21:19 <quintessence> redscare: pass which file to check in as an argument, from a driver that handles exceptions and re-checks the files when its callee fails?
15:21:36 <geekosaur> not as you've phrased it, no.  might want to step back a level or two and look at more haskelly ways to solve the higher level problem instead (you haven't really described that well)
15:22:07 <hpaste> Peaker annotated “zipWith has 5 arguments?” with “Saner still” at http://hpaste.org/72273#a72275
15:22:28 <chrisdone> jfischoff: fwiw the API is still in flux, but if you don't mind living on the edge i will respond to any questions on github
15:22:45 <Peaker> jimi_hendrix, you flatten a list of list and then recover its structure with divMod instead of not losing the structure in the first place
15:23:37 <jfischoff> chrisdone: Welcome to Haskell development :)
15:23:55 <ParahSailin> @let foo' n (x:xs) = (Just x, foo' (n-1) xs)
15:23:57 <lambdabot>  <local>:3:16:
15:23:57 <lambdabot>      Occurs check: cannot construct the infinite type: t = (Ma...
15:24:09 <ParahSailin> what's wrong with that
15:24:20 <Peaker> jimi_hendrix, do you see the newest annotation?
15:24:23 <chrisdone> jfischoff: that's how we role
15:24:30 <chrisdone> and roll
15:24:37 <jimi_hendrix> Peaker, yes
15:24:41 <parcs`> statusfailed: kind of. one way of creating a heterogeneous list is with an existential: 'data Any = forall a. Any a', which is equivalent to 'type Any = forall r. (forall a. a -> r) -> r'. so a heterogeneous list would have the type [forall r. (forall a. a -> r) -> r]
15:24:49 <noteventime> ParahSailin: What type would you like it to have?
15:25:00 <redscare> geekosaur, quintessence: the problem is this: i want to call this function, 'readfile', from an infinite loop. 'readfile' reads a file 'a' or 'b', which rarely change names but can. it would be too expensive to check every call of 'readfile' if the files exist, so i need some way to store the knowledge that 'so far, file 'a' is working'. but 'readfile' is in an external module, and i don't want the user to have to worry about passing
15:25:01 <redscare> 'readfile' any state
15:25:01 <parcs`> your example would look like [\f -> f "hi", \f -> f 1]
15:25:02 <Peaker> jimi_hendrix, all these putPixels aren't nice though
15:25:20 <Peaker> jimi_hendrix, may be nicer to build up the array directly via a function
15:25:27 <ParahSailin> oh nevermind, i need a monad
15:25:28 <Peaker> (rather than setting it)
15:25:47 <mikeplus64> ParahSailin: the reason this won't work is that you're making a potentially infinite stream of tuples, which would mean an infinite type
15:25:52 <mikeplus64> no need for monads
15:27:00 <jimi_hendrix> Peaker, thanks for the help. there is still one type error in there, but i will figure that out later. i need to do some stuff
15:27:10 <statusfailed> parcs`: Hmm.. ok
15:27:46 <quintessence> ParahSailin: the return type there is a tuple whose second element is the same as the return type of foo', i.e. the whole tuple.  Haskell doesn't like this.
15:28:24 <Peaker> hmm.. Data.Vector.Unboxed's Vector is not Unbox'able? Can't have vector of vector?
15:28:37 <hiptobecubic> Peaker, no.
15:29:00 <simon> is there a conditional fold function? one that stops if a predicate is true for the accumulator?
15:29:02 <ParahSailin> im trying to write the splitAt function, but maybe ill just cheat and see how it is implemented
15:29:10 <redscare> quintessence: i'm not familiar with your use of 'driver', is there any resource online i could look at? thanks
15:29:23 <hiptobecubic> Peaker, you could maybe make it an instance? but you're probably better off with a huge array and fancy indexing
15:29:58 <parcs`> simon: use a Maybe accumulator to short-circuit the fold
15:30:08 <Peaker> hiptobecubic, I'm thinking divMod will be expensive
15:30:25 <Peaker> hiptobecubic, whereas multiplication (esp. if constant, would be cheaper)
15:30:39 <ParahSailin> @src take
15:30:40 <lambdabot> take n _      | n <= 0 =  []
15:30:40 <lambdabot> take _ []              =  []
15:30:40 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
15:30:47 <hiptobecubic> Peaker, but you know the size ahead of time if you're using unboxed arrays
15:31:01 <simon> parcs`, I don't need a special version of fold? I just thought it would keep accumulating.
15:31:09 <Peaker> hiptobecubic, ah, need size-indexed vector type then, like in C
15:31:11 <ParahSailin> @src splitAt
15:31:12 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
15:31:23 <hiptobecubic> Peaker, so your 'grid' is predefined and you can index it with just (xlen*y + x)
15:31:23 <ParahSailin> @src drop
15:31:23 <lambdabot> drop n xs     | n <= 0 =  xs
15:31:23 <lambdabot> drop _ []              =  []
15:31:23 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
15:31:34 <Peaker> hiptobecubic, say I want to use "generate" though
15:32:24 <simon> parcs`, what I've got so far is an Either wrapped around my accumulator so I can accumulate until I find something, and then I keep folding without changing the accumulator.
15:32:39 <hiptobecubic> Peaker, you still know the dimension sizes ahead of time no? at least one of them
15:32:40 <peteriserins> does a -> [a] have a monad instance?
15:32:54 <hiptobecubic> peteriserins, isn't tha tjust list?
15:33:18 <parcs`> simon: is this a left fold or a right fold?
15:33:22 <peteriserins> isn't list [a]?
15:34:08 <simon> parcs`, foldr.
15:35:16 <Peaker> hiptobecubic, yeah, I do, just don't want to expensively divMOd
15:35:20 <thanthese> Does anyone know if there's a standard way to convert [IO String] to IO [String]?  Here's my best guess, but it doesn't work.  https://gist.github.com/3195027
15:35:35 <Peaker> @hoogle [IO String] -> IO [String]
15:35:35 <lambdabot> No results found
15:35:45 <Peaker> @hoogle [IO a] -> IO [a]
15:35:46 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:35:46 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:35:46 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
15:35:59 <Peaker> weird that hoogle didnt do that on its own
15:36:31 <thanthese> @Peaker well, I didn't think of it either.  Thanks!
15:36:31 <lambdabot> Unknown command, try @list
15:37:09 <Peaker> thanthese, btw, use pattern matching rather than head/tail
15:37:12 <hiptobecubic> Peaker, why do you need to divMod? unless you are trying to determine the index based on the value and not the other way around?
15:37:22 <Peaker> thanthese, it will make your error there clearer too
15:37:37 <Peaker> hiptobecubic, because of "generate :: Int -> (Int -> a) -> Vector a"
15:37:59 <nule> heh, that's awesome, I just wandered in to ask a question and I see the answer a few lines above, thanks!
15:38:03 <Peaker> hiptobecubic, I want to generate the entire vector via a function from index
15:38:03 <hiptobecubic> ah
15:38:09 <thanthese> peaker, I didn't know pattern matching would give me better errors.  I'll have to try that.  Thanks again!
15:38:17 <hiptobecubic> Peaker, well... profile first. optimize later :)
15:38:27 <hiptobecubic> maybe the divMod won't be the bottleneck anyway
15:38:34 <Peaker> hiptobecubic, it's also ugly :) I think repa might have that though
15:38:43 <hiptobecubic> repa is great
15:39:05 <Peaker> thanthese, it's not that it would give better errors, it's that it would be total rather than crash at runtime and will help you see which data you want to use/look at (nudge you in the right direction)
15:39:29 <thanthese> ah, cool
15:39:37 <Peaker> thanthese, you use "tail" there but not head. When pattern-matching that error will be clearer.
15:40:30 <Peaker> (logic error there, rather than type error)
15:44:32 <redscare> i want to call a function, 'readfile', from an infinite loop. 'readfile' reads a file 'a' or 'b', which rarely change names but can. it would be too expensive to check every call of 'readfile' if the files exist, so i need some way to store the knowledge that 'so far, file 'a' is working'. but 'readfile' is in an external module, and i don't want the caller to have to pass any information to 'readfile'
15:47:51 <geekosaur> yu can do that with a little global state in the module.  given your initial description where you seem to be asking fo reach invoking module to have its own state, you cannot do that without passing *something* to it
15:49:47 <ParahSailin> @let splitGreedy :: Int -> [a] -> [[a]]; splitGreedy n [a] = (take n [a]):(splitGreedy n (drop n [a])); splitGreedy n [] = [[]]
15:49:49 <lambdabot>  Defined.
15:50:03 <ParahSailin> splitGreedy 3 "foobarfoo"
15:50:19 <Taneb> That won't work if the list is more than 1 element?
15:50:32 <Taneb> > splitGreedy 3 "foobarfoo"
15:50:34 <lambdabot>   *Exception: <local>:3:36-121: Non-exhaustive patterns in function splitGreedy
15:50:39 <Peaker> redscare, you can have: newtype ReadfileResult = ReadfileResult (ByteString, IO ReadFileResult)
15:50:48 <Taneb> You're pattern-matching [a]
15:50:52 <Peaker> redscare, readfile :: IO ReadfileResult
15:50:54 <ParahSailin> im retarded i can't figure it out
15:51:00 <Taneb> That's a list with one element, which you're calling a
15:51:07 <ParahSailin> oh
15:51:08 <Peaker> redscare, as one option
15:51:11 <Taneb> Not, as you intend, a list called a
15:51:19 <ParahSailin> whats the pattern from list
15:51:25 <ParahSailin> oh nevermind
15:51:31 <Taneb> splitGready n a = take n a : splitGreedy n (drop n a)
15:51:32 <ParahSailin> totally dumb
15:51:38 <Taneb> Except you want the empty list first
15:52:15 <redscare> Peaker: how would that work?
15:52:33 <Peaker> redscare, it could return the next action to perform after each action
15:53:04 <Peaker> redscare, or you could run the readfile in its own thread, which may make sense (add some useful concurrency)
15:54:12 <redscare> geekosaur: i don't see why i'd have to pass *anything* to it, as the module itself is totally capable of determining it's own state
15:54:17 <redscare> geekosaur: theoretically
15:54:18 <ParahSailin> ok, now i dont want it to make an empty list at the last element
15:54:25 <ParahSailin> do i need a monad now?
15:54:47 <geekosaur> redscare, you initially said per-module which seemed to imply per-*invoking*-module
15:55:14 <redscare> Peaker: i was trying to avoid that. i basically want the caller to be able to do "main = do readfile; someOtherFunction; readfile"
15:55:50 <geekosaur> if that is not what you meant, then the simple but not preferred way is "moduleState = unsafePerformIO (newIORef "a")" and change that with writeIORef as needed
15:56:11 <quintessence> Haskellers generally frown on spooky action at a distance like that
15:56:33 <geekosaur> which is why I suggested stepping back.  yes, it can be done.  no, it is not a good idea for a number of reasons
15:57:38 <redscare> geekosaur: sorry, i misspoke. here is pseudo-code: 'fileToRead = 'a.txt'; readfile = try (tryToReadFile fileToRead) catch (fileToRead = 'b.txt'; readfile)'. does that make sense?
15:57:41 <geekosaur> you also, in the unsafePerformIO case, also need some annotations to prevent inlining and such so the compiler doesn't quietly optimize it into something that fails
15:58:02 <Peaker> redscare, you could do stuff very close to that
15:58:10 <geekosaur> then see what I said above with newIORef
15:58:20 <redscare> geekosaur: i'd be very grateful if you could give me a way to do this 'haskell-like'. i am just doing this to learn. thanks for your help so far
15:58:21 <Peaker> redscare, main = runSomeMonad $ do readfile ; someOther ; readfile
15:58:56 <Peaker> redscare, or: main = do r <- mkFileReader ; readfile r ; someOther ; readfile r
15:59:10 <geekosaur> there is no haskell-like way to do it without passing state (if only implicitly, say via a monad stack of some kind), because haskell-like involves some kind of state.
15:59:26 <Peaker> redscare, why not pass arguments? How are the "readfile"s supposed to be related to one another rather than independent?
15:59:52 <redscare> Peaker: i see, but i'm not sure it would work if i want to do something like this: 'main = do readfile; somethingElse; main'
15:59:53 <geekosaur> you seem to be saying "tell me how to write C-idiom in Haskell and do it Haskell-idiomatically" and the answer is "mu"
16:00:56 <ParahSailin> @let splitBla :: Int -> [a] -> [[a]]; splitBla n [] = [[]]; splitBla n lst = (take n lst):(splitBla n (drop n lst))
16:00:57 <lambdabot>  Defined.
16:00:57 <redscare> Peaker: i guess the reason is I don't want the author of function 'somethingElse' to have to worry about 'readfile' needing state
16:01:07 <ParahSailin> @let isEmpty :: [a] -> Bool; isEmpty [] = True; isEmpty (_:_) = False
16:01:09 <lambdabot>  Defined.
16:01:19 <ParahSailin> filter (not . isEmpty) $ splitBla 3 "Foobarbar"
16:02:33 <geekosaur> redscare, you can route around it, use a custom monad stack with IO at its base to hold and pass the state and "liftIO somethingElse" to invoke that while transparently routing the state you need around it
16:02:45 <ParahSailin> is there a "smarter" way to do that?
16:03:18 <Peaker> redscare, but readfile *has* state, so the author will already need to worry about it
16:03:18 <ParahSailin> :t filter
16:03:20 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:03:33 <ParahSailin> filter (not . isEmpty) ( splitBla 3 "Foobarbar")
16:03:50 <redscare> Peaker: well not the author of 'somethingElse', because it is unrelated to 'readfile'
16:04:00 <ParahSailin> splitBla 3 "Foobarbar"
16:04:01 <redscare> Peaker: apart from being run in the same program
16:04:04 <Peaker> redscare, sure, none of the solutions involve somethingElse
16:04:25 <Peaker> redscare, runSomeMonad $ do ... would probably just "liftIO" somethingElse if that's what you're talking about
16:04:38 <Peaker> redscare, and the simpler arg-passing doesn't touch somethingElse at all
16:04:43 <redscare> Peaker: is there a way to do that automatically?
16:04:54 <Peaker> redscare, the liftIO?
16:05:05 <geekosaur> why do you need to?  is your main loop not under your control somehow?
16:05:22 <redscare> Peaker: yep. so that runSomeMonad $ do readfile; liftIO somethingElse doesn't need to be typed?
16:05:23 <geekosaur> because liftIO somethingElse means somethingElse neitherr knows nor cares what else you do
16:05:24 <Peaker> redscare, there are libs that replace lots of IO  ops with lifted ones in any MonadIO instance.. but probably not a good idea
16:05:38 <Peaker> redscare, what do you mean?
16:05:39 <ParahSailin> @splitBla 3 "Foobarbar"
16:05:40 <lambdabot> Unknown command, try @list
16:05:44 <ParahSailin> @list
16:05:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:06:05 <redscare> geekosaur: is there somewhere I can read about monad stacks, maybe I just don't completely understand the concept yet...
16:06:12 <Peaker> redscare, I'd recommend using the arg to "readfile" it is more composable than a monad
16:06:23 <geekosaur> I'm still trying to figure out what you actually want
16:06:25 <ParahSailin> @run splitBla 3 "Foobarbar"
16:06:27 <redscare> Peaker: so literally just an argument?
16:06:28 <lambdabot>   ["Foo","bar","bar",""]
16:06:45 <ParahSailin> @run filter (not . isEmpty) ( splitBla 3 "Foobarbar")
16:06:46 <lambdabot>   Ambiguous occurrence `isEmpty'
16:06:46 <lambdabot>  It could refer to either `L.isEmpty', defin...
16:06:56 <Peaker> redscare, yeah, an arg to all the "readfile"s that allows them to share state
16:06:56 <redscare> geekosaur: would you mind if i pasted some haskell code on hpaste? i don't want to bother you too much though
16:07:01 <geekosaur> because what you have described so far needs no magic, no hiding stuff, unless all your examples involving main = ... really mean somethingotherThanMain = ...
16:07:12 <geekosaur> redscare, no problem
16:07:16 <ParahSailin> @let isEmpty' :: [a] -> Bool; isEmpty' [] = True; isEmpty' (_:_) = False
16:07:18 <lambdabot>  Defined.
16:07:22 <ParahSailin> @run filter (not . isEmpty') ( splitBla 3 "Foobarbar")
16:07:24 <lambdabot>   ["Foo","bar","bar"]
16:07:47 <ParahSailin> is there a smarter way to do all that business, more idiomatic etc?
16:08:13 <fmap> @check \xs -> isEmpty' xs == null xs
16:08:15 <lambdabot>   "OK, passed 500 tests."
16:08:41 <ParahSailin> whats check
16:08:53 <geekosaur> runs QuickCheck
16:09:06 <geekosaur> the point is, that isEmpty' is already in the Prelude as null
16:10:13 <davesque> @:t 5::Int
16:10:14 <lambdabot> Done.
16:10:21 <davesque> @5::Int
16:10:21 <lambdabot> Unknown command, try @list
16:10:26 <davesque> @list
16:10:26 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:10:30 <geekosaur> :t 5::Int
16:10:32 <lambdabot> Int
16:10:32 <Peaker> isEmpty is a better name, arguably
16:10:39 <Rainb> Hello
16:10:50 <ParahSailin> @undefine splitGreedy
16:10:51 <davesque> just trying to see what it could do
16:10:54 <ParahSailin> null 'a'
16:10:55 <Peaker> null, init, head, tail, are all pretty bad names, imo
16:11:00 <jfischoff> Is anyone aware of zipper like data structures for graphs?
16:11:14 <Rainb> What does Irrefutable pattern failed for pattern a : _ : _
16:11:17 <Rainb> means?
16:11:42 <redscare> geekosaur: here it is: http://hpaste.org/72278. sorry it's a lot, i could trim it down, but I think it's relatively straightforward
16:11:48 <geekosaur> you tried to do a pattern match like that but the list it applied to didn't have at least two elements
16:12:31 <redscare> geekosaur: basically the files in PowerFileList change names randomly
16:12:44 <fmap> ParahSailin: do you know about split package?
16:12:45 <davesque> i'm a bit confused by the following...`:t (+) <$> (*3)` outputs `Integer -> Integer -> Integer`
16:13:02 <ParahSailin> @let splitGreedy' n lst = filter (\x = (length x) == n) (splitBla n lst)
16:13:02 <lambdabot>   Parse error: =
16:13:09 <ParahSailin> @let splitGreedy' n lst = filter (\x = (length x) == n) (splitBla' n lst)
16:13:09 <lambdabot>   Parse error: =
16:13:23 <ParahSailin> @let splitGreedy' n lst = filter (\x -> (length x) == n) (splitBla' n lst)
16:13:24 <lambdabot>  <local>:1:53: Not in scope: `splitBla''
16:13:33 <ParahSailin> @let splitGreedy' n lst = filter (\x -> (length x) == n) (splitBla n lst)
16:13:34 <lambdabot>  <local>:1:53: Not in scope: `splitBla'
16:13:44 <davesque> if `f <*> g == \x f x (g x)`, then i would expect `pure (+) <*> (*3) == \x (+) x ((*3) x)`
16:14:16 <ParahSailin> im just fooling around trying to do simple stuff to learn the language
16:14:31 <davesque> but when i do `:t (\x -> (+) x ((*3) x))` it outputs `Integer -> Integer`
16:14:33 <ParahSailin> id hope this is in the standard lib
16:15:08 <davesque> what am i missing?
16:15:12 <redscare> geekosaur: getBatteryInfo is then called in another module with a main loop: 'main = do info <- getBatteryInfo; linfo <- otherInfo; putStrLn $ prettyPrint info linfo;'
16:15:28 <nobdraisentone> How can I convert `Maybe a` to `IO ()`?
16:15:31 <redscare> geekosaur: sorry, then main calls itself recursively
16:15:45 <fmap> nobdraisentone: const (return ())
16:15:52 <nobdraisentone> fmap: thanks
16:15:53 <BMeph> davesque: For one thing, you're missing that '(+)' is not the same thing as 'pure (+)'...
16:16:11 <shachaf> nobdraisentone: fmap's answer wasn't actually serious.
16:16:20 <davesque> BMeph: ahh, okay...what's the difference?
16:16:23 <shachaf> nobdraisentone: If your question is serious, you'll have to explain more about what you're doing.
16:17:04 <geekosaur> redscare, hm, ideally you give plugins like that some kind of state that you keep per-plugin.
16:17:19 <davesque> BMeph: i suspected that might have been the confusion, but i'm not clear on the difference with regard to my question
16:17:26 <geekosaur> you might want to look at how xmobar does this kind of thing, for example
16:17:28 * hackagebot lens 0.9 - Families of Lenses, Folds and Traversals (EdwardKmett)
16:18:13 <ParahSailin> reading the source of splitEvery
16:18:16 <ParahSailin> :t build
16:18:16 <geekosaur> ( http://github.com/jaor/xmobar )
16:18:17 <lambdabot> Not in scope: `build'
16:18:42 <geekosaur> the not really Haskelly way, on the other hand...
16:18:50 <hpaste> geekosaur annotated “Monitor Needing Global State” with “Monitor Needing Global State (annotation)” at http://hpaste.org/72278#a72279
16:19:07 <davesque> BMeph: can you explain the difference to me?
16:19:33 <geekosaur> :t pure (+)
16:19:34 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f (a -> a -> a)
16:19:36 <BMeph> davesque: For another thing, when you "would expect `pure (+) <*> (*3) == \x (+) x ((*3) x)`", your expectation is in error.
16:20:12 <redscare> geekosaur: thank you very much. do you think i should look into a 'pure' way or do you not see an elegant 'pure' solution?
16:20:23 <davesque> BMeph: yes, i realize that.  how would you correctly write the right side of that conditional?
16:20:28 <BMeph> davesque: I would love to, except...I'm not sure where to start. Not trying to sound pompous, I'm just not sure how far back I need to start, is all. :)
16:20:47 <geekosaur> redscare, I suggested something to look at to see how others have solved the problem of plugins with their own state
16:20:51 <geekosaur> ( http://github.com/jaor/xmobar )
16:20:55 <BMeph> :t (<*>)
16:20:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:21:10 <BMeph> davesque: ^^ Do you understand that part?
16:21:11 <ParahSailin> where would a build function used here be documented http://hackage.haskell.org/packages/archive/split/latest/doc/html/src/Data-List-Split-Internals.html#splitEvery
16:21:30 <davesque> BMeph: well, i suppose i realize that `pure (+)` is technically equal to `(\_ -> (+))`, right?
16:21:32 <broombs> So, remind me: exactly how does one upgrade a package in cabal if 'cabal upgrade' is no longer available but 'cabal install' warns that a long list of other packages would likely break?
16:21:50 <geekosaur> if you have no control whatsoever over the caller then you may have to do it the ugly way, but on the other hand amny of us would argue you should not expect the caller to be completely oblivious
16:22:04 <geekosaur> it smacks of C-think
16:22:32 <davesque> BMeph: since the applicative instance for functions defines pure x as (\_ -> x)
16:22:34 <BMeph> davesque: Technically, no. :)
16:22:36 <redscare> geekosaur: thanks very much. i was more asking you for a qualitative 'is it worth it to go pure' rather than asking you how to do it, you've already helped so much i'd be taking too much of your time
16:23:08 <geekosaur> enh, I'm in my sister's basement, theyran off to something or other and left me here, I have nothing but time at the moment ;}
16:24:04 <redscare> geekosaur: if you could handle one final question then...:) if i were to use a state monad to pass state around in my main loop, is there a general way to only pass certain parts of that state to relevant functions?
16:24:21 <davesque> BMeph: okay, i realize that `:t (<*>)` is saying that <*> should take an applicative with a function of type (a -> b) as its left parameter and an applicative with a type a as its right and return an applicative with a type b as the result.
16:24:31 <BMeph> davesque: But yes, that is a valid definition of 'pure' for functions-as-Applicatives.
16:25:21 <geekosaur> not really, but there are ways for functions to pay attention only to the state they care about and ignore the rest.  for example, your state is a Map of some kind parameterized on the plugin in question, and each plugin only operates on/with the map entry belonging to it
16:25:37 <redscare> geekosaur: i was scared you'd say map :)
16:26:06 <redscare> geekosaur: now i have to guarantee unique keys :( keep in mind this thing is academic so i'm trying to do everything right to the point of being annoying :)
16:26:08 <BMeph> davesque: Short version: '((+) <*> g) x == x + g x'
16:26:14 <geekosaur> http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Util-ExtensibleState.html comes to mind but is not necessarily an implementation you want to use
16:26:20 <redscare> geekosaur: plus are map lookups slow?
16:27:17 <BMeph> redscare: A rule of thumb: if you're pressed for time, you shouldn't be using IRC in the first place. ;)
16:27:27 <broombs> Would someone please help me out?  I've been wrestling with this for a few days now, and I haven't found any webpages that address my question directly.  In particular, having installed cabal, should I not do a 'cabal update' and then 'cabal install cabal-install', and what do I do about all those warnings?
16:27:39 <geekosaur> redscare, maps are quick
16:27:40 <davesque> BMeph: okay, then `(+) <*> (*3) == x + 3 * x`?
16:28:03 <BMeph> davesque: No: '((+) <*> g) x == x + g x'
16:28:10 <geekosaur> the other, ExtensibleState shows one way to uniquify keys
16:28:27 <BMeph> davesque: Rather, '((+) <*> (*3)) x == x + 3 * x'
16:28:31 <davesque> BMeph: `((+) <*> (*3)) x == x + 3 * x`
16:28:35 <geekosaur> there are other ways depending on what exactly you want to do
16:28:43 * BMeph cheers for davesque!
16:28:44 <davesque> BMeph: ahh
16:28:56 <davesque> BMeph: hmm...
16:29:10 <BMeph> davesque: ...hmm? ;)
16:29:39 <davesque> BMeph: just thinking.  i suppose i'll have to spend some time playing around with it to really get it.
16:30:06 <redscare> geekosaur: thank you, i've lots to look at and learn now :)
16:30:44 <davesque> BMeph: but that helps, thanks for your time!
16:31:19 <BMeph> davesque: Are you reading something while you "play around"? I wouldn't recommend it with another person (unless you're reading the Kama Sutra... ;)), bt with larning a programming language, it helps. :)
16:31:46 <BMeph> Er, *but with learning
16:32:05 <BMeph> davesque: You're quite welcome, BTW.
16:32:14 <davesque> BMeph: i've read through learn you a haskell.  lately i've been re-reading parts to try and hammer down my understanding ot things.
16:32:31 <davesque> BMeph: of things...
16:33:03 <Rainb> What does "Irrefutable pattern failed for pattern a : _ : _"   means
16:34:48 <geekosaur> Rainb, I answered that earlier
16:34:57 <geekosaur> you tried to do a pattern match like that but the list it applied to didn't have at least two elements
16:35:19 <geekosaur> but it's a delayed pattern match, as with a let expression
16:35:39 <geekosaur> (irrefutable = the pattern only fails if something tries to actually use it, not immediately)
16:37:06 <geekosaur> Rainb, might help if you showed us what code is giving you that error
16:37:07 <geekosaur> @paste
16:37:08 <lambdabot> Haskell pastebin: http://hpaste.org/
16:38:25 <latro`a> a blunter example
16:38:26 <latro`a> is
16:38:29 <latro`a> > fromJust Nothing
16:38:30 <lambdabot>   *Exception: Maybe.fromJust: Nothing
16:38:36 <geekosaur> heh
16:38:47 <latro`a> oh bah
16:38:50 <geekosaur> > let a : _ : _ = [1] in a
16:38:51 <lambdabot>   *Exception: <interactive>:3:4-18: Irrefutable pattern failed for pattern a ...
16:38:53 <latro`a> it's defined to with error
16:38:59 <latro`a> unlike list pattern match failure
16:39:16 <latro`a> > let myFromJust (Just x) = x in myFromJust Nothing
16:39:17 <lambdabot>   *Exception: <interactive>:3:4-26: Non-exhaustive patterns in function myFro...
16:39:20 <latro`a> there we go
16:40:27 <takemitsu> Hello, has anybody read Wadler's "The essence of functional programming" and can explain me how that Backwards state works?
16:41:46 <parcs`> takemitsu: the reverse state monad?
16:42:29 <takemitsu> parcs`: I guess.
16:43:35 <Rainb> I'm sorry, your reply got lost in the chat. I didn't read it.
16:44:10 <Rainb> Oh found it, thanks.
16:47:12 <davesque> BMeph: hey, are you still there?
16:47:49 <geekosaur> another example of that kind of patterm match failure
16:47:50 <mm_freak> there are only finitely many humans, but paradoxically stupidity seems to be infinite
16:47:52 <ParahSailin> splitEvery :: Int -> [e] -> [[e]]
16:47:53 <ParahSailin> splitEvery i ls = map (take i) (build (splitter ls)) where
16:47:53 <ParahSailin>   splitter :: [e] -> ([e] -> a -> a) -> a -> a
16:47:53 <ParahSailin>   splitter [] _ n = n
16:47:53 <ParahSailin>   splitter l c n  = l `c` splitter (drop i l) c n
16:48:01 <ParahSailin> i dont understand what that c is
16:48:09 <parcs`> takemitsu: it's pretty much a fixed point operator
16:48:12 <geekosaur> hm, no, justt tried to outsmart myself.  oh well
16:48:30 <ParahSailin> i realize it's a function, just it's never defined
16:48:47 <davesque> if `f <*> g = (\x -> f x (g x))`, wouldn't that mean that f must always be a function that takes two arguments?
16:49:38 <parcs`> takemitsu: it computes the fixed point of the computations between a 'get' and a 'put', see http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
16:49:49 <geekosaur> ParahSailin, I think build there is something inside ghc's runtime, and it's supplying c
16:49:56 <davesque> anyone?
16:50:12 <parcs`> in that case computeFibs is equivalent to 'fix ((1:) . cumulativeSums)'
16:50:16 <ParahSailin> so it's not a magical anonymous local function?
16:50:33 <Guest62319> davesque: all functions in haskell take one argument
16:50:50 <latro`a> build is defined
16:51:07 <latro`a> I forget where
16:51:09 <latro`a> but it is defined
16:51:15 <latro`a> it's not that different from (:), iirc
16:51:18 <ParahSailin> ghc.ext
16:51:21 <latro`a> but it has weird inline properties
16:51:24 <latro`a> that make it fast
16:51:27 <ParahSailin> @hoogle build
16:51:27 <lambdabot> GHC.Exts build :: (forall b. (a -> b -> b) -> b -> b) -> [a]
16:51:27 <lambdabot> Data.Graph.Inductive.Internal.Heap build :: Ord a => [(a, b)] -> Heap a b
16:51:27 <lambdabot> Graphics.Rendering.OpenGL.GLU.Mipmapping build1DMipmaps :: TextureTarget -> PixelInternalFormat -> GLsizei -> PixelData a -> IO ()
16:51:44 <latro`a> the former is what I was looking for, I think
16:51:51 <latro`a> maybe not, though, I don't remember it having a funky type
16:52:02 <takemitsu> parcs`: Hm, could you explain what a fixed point operator is?
16:52:14 <fmap> davesque: no
16:52:16 <ParahSailin> build is simply defined as build g = g (:) []
16:52:35 <latro`a> takemitsu: first and foremost, fix f solves the equation x = f(x)
16:52:39 <latro`a> which is a "fixed point equation"
16:52:47 <fmap> > (enumFromThenTo <*> (*3)) 3 15
16:52:48 <lambdabot>   [3,9,15]
16:52:50 <fmap> @type enumFromThenTo
16:52:51 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
16:53:11 <latro`a> every function in haskell has at least one fixed point
16:53:25 <Guest62319> > ord undefined
16:53:26 <lambdabot>   *Exception: Prelude.undefined
16:53:31 <latro`a> ^
16:53:41 <Veinor> latro`a: you mean, every function of type (a -> a) ;)
16:53:45 <latro`a> eh
16:53:47 <latro`a> true
16:53:52 <Guest62319> Veinor: thats every function
16:53:59 <Veinor> no it's not
16:53:59 <Guest62319> oh
16:54:01 <latro`a> no, they can return a different type
16:54:02 <latro`a> yeah
16:54:08 <latro`a> they don't need to be unary, technically
16:54:17 <Guest62319> a -> b can have fixed points?
16:54:18 <Guest62319> heh
16:54:38 <mm_freak> latro`a: every function of type a -> a
16:54:39 <Cale> :t fix
16:54:40 <lambdabot> forall a. (a -> a) -> a
16:54:43 <latro`a> yes, they pointed that out
16:54:45 <davesque> fmap: `(+) <*> (*3) = (\x -> (+) x ((*3) x))`, right?
16:54:48 <latro`a> thanks for the correction
16:54:54 <Veinor> @unpl (+) <*> (*3)
16:54:55 <lambdabot> ((+) <*> \ a -> a * 3)
16:55:02 <Veinor> .. that's not helpful
16:55:12 <latro`a> @pl rarely is
16:55:12 <lambdabot> rarely is
16:55:14 <latro`a> er
16:55:17 <Veinor> > ((+) <*> (*3)) 20
16:55:18 <latro`a> nvm you unpl'd
16:55:18 <lambdabot>   80
16:55:23 <Veinor> it looks so
16:55:31 <fmap> davesque: yes
16:55:38 <latro`a> that said, every function has a fixed point. if the function is strict in its argument, that fixed point is undefined; that is f undefined = undefined
16:56:17 <latro`a> fix is a bit special in that it finds the least-defined one
16:56:20 <mm_freak> hmm, wait a minute
16:56:22 <davesque> fmap: ahh...i think i see where my confusion is...i was confusing <$> with <*>
16:56:24 <Guest62319> f (undefined :: a) = undefined :: b
16:56:31 <mm_freak> i think every function might have a fixed point
16:56:37 <mm_freak> because fix :: (a -> a) -> a
16:56:44 <parcs`> takemitsu: i meant that the gimmick of reversing how the state is sequenced can be viewed as calculating the fixed point of the functions that are operating on the state
16:56:56 <latro`a> you can't try to get a fixed point of an a->b, it's a type error
16:56:57 <mm_freak> ah, no
16:57:04 <latro`a> f :: Int->Double
16:57:05 <mm_freak> > fix (undefined :: a -> b)
16:57:06 <lambdabot>   *Exception: Prelude.undefined
16:57:08 <latro`a> g = fix f
16:57:08 <mm_freak> but
16:57:14 <mm_freak> > fix (undefined :: Int -> Integer)
16:57:16 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:57:16 <lambdabot>         against inferred type ...
16:57:16 <latro`a> will not typecheck
16:57:32 <ParahSailin> oh this function is very tricky
16:57:34 <takemitsu> Wait a minute, you are getting way ahead of me.
16:57:43 <Guest62319> lol
16:57:48 <Guest62319> so much nonsense
16:57:53 <ParahSailin> @src Data.List.Split.splitEvery
16:57:54 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:57:54 <latro`a> takemitsu
16:58:02 <latro`a> have you read http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion already?
16:58:07 <latro`a> it's pretty snazzy
16:58:37 <ParahSailin> @hoogle splitEvery
16:58:37 <lambdabot> No results found
16:58:42 <takemitsu> Okay, I'm reading it now.
17:00:05 <geekosaur> http://hackage.haskell.org/packages/archive/split/0.1.4.3/doc/html/src/Data-List-Split-Internals.html#splitEvery
17:00:09 <geekosaur> ParahSailin, ^^
17:00:19 <ParahSailin> right im reading it
17:00:29 <ParahSailin> thats very interesting how it's done
17:02:28 <davesque> fmap: i was mistakenly thinking that `(+) <$> (*) = (\x -> (+) x ((*3) x))` when, actually `(+) <$> (*3) = (\x -> (\_ -> (+)) x ((*3) x))`
17:03:02 <davesque> fmap: and that is the same as `(\x -> (+) ((*3) x))`
17:03:45 <davesque> fmap: yay!
17:03:49 <mm_freak> it's easy to picture Applicative for (e ->)
17:03:53 <mm_freak> pure is K
17:03:58 <mm_freak> (<*>) is S
17:04:19 <simon> (mindblown)
17:04:38 <mm_freak> > (pure <*> pure) 3
17:04:39 <lambdabot>   Ambiguous type variable `f' in the constraint:
17:04:39 <lambdabot>    `Control.Applicative.Appl...
17:04:48 <mm_freak> > (pure <*> pure) 3 :: Integer
17:04:49 <lambdabot>   Ambiguous type variable `f' in the constraint:
17:04:49 <lambdabot>    `Control.Applicative.Appl...
17:04:54 <davesque> yay, first steps toward understanding functions as applicatives...
17:05:25 <mm_freak> well, pure <*> pure is S K K, which is id…  just add a few type signatures, because haskell is typed =)
17:05:31 <davesque> :t (+) <$> (*)
17:05:33 <lambdabot> forall a. (Num a) => a -> (a -> a) -> a -> a
17:05:51 <davesque> :t (\x -> (\_ -> (+)) x ((*3) x))
17:05:52 <lambdabot> forall a. (Num a) => a -> a -> a
17:06:58 <ParahSailin> :t map
17:06:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:07:14 <davesque> weird, ghci says something different :P
17:11:02 <davesque> thanks to everyone who helped me understand this, catch y'all later
17:11:19 <mm_freak> :t pure <*> (pure :: a -> b -> a)
17:11:20 <lambdabot> forall b. b -> b
17:11:24 <mm_freak> there we go =)
17:11:34 <mm_freak> :t const <*> const
17:11:35 <lambdabot> forall b. b -> b
17:12:12 <davesque> :t (+) <$> (*3)
17:12:12 <lambdabot> forall a. (Num a) => a -> a -> a
17:12:17 <davesque> there we go...
17:12:18 <mm_freak> type-level proof that S K K = I
17:12:23 <davesque> :t (\x -> (\_ -> (+)) x ((*3) x))
17:12:24 <lambdabot> forall a. (Num a) => a -> a -> a
17:12:38 <ParahSailin> the build function in ghc.exts is kinda incomprehensible to me
17:12:51 <ParahSailin> @src GHC.Exts.build
17:12:51 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:13:07 <ParahSailin> @m GHC.Exts
17:13:08 <lambdabot> Maybe you meant: map messages messages? more msg . ? @ v
17:14:44 <ParahSailin> what does build g = g (:) [] mean
17:15:07 <ParahSailin> : g [] doesnt seem like it makes sense
17:15:17 <ParahSailin> whats on the left side
17:15:48 <latro`a> (:) is an argument to g
17:15:58 <latro`a> as a function
17:16:06 <geekosaur> it is in fact the "c" you were looking for earlier
17:16:09 <latro`a> yeah
17:16:52 <ParahSailin> ah, the (:) function is argument of g
17:17:01 <geekosaur> I told you that build was supplying the "c", and that's what it is supplying
17:19:55 <ParahSailin> ah ok its not as crazy as i thought
17:21:51 <takemitsu> Okay, so basically applying a function to its fixed point results in the fixed point?
17:22:08 <mm_freak> yes
17:26:35 <Cale> That is the definition of what it means to be a fixed point.
17:27:56 <Mortchek> Does that mean an untyped id function has every value as its fixed point?
17:28:45 <geekosaur> :t fix id
17:28:46 <lambdabot> forall a. a
17:31:05 <Guest62319> > id 9
17:31:06 <lambdabot>   9
17:31:07 <Guest62319> > id 9
17:31:08 <lambdabot>   9
17:31:10 <Guest62319> > id 9
17:31:11 <lambdabot>   9
17:31:17 <Guest62319> ok
17:31:38 <Guest62319> not going anywhere
17:33:09 <Mortchek> Hmm. Why doesn't fix id terminate?
17:33:10 <Rotaerk_> Guest62319, you might want to try again; it might've changed.
17:33:17 <parcs`> Mortchek: yes but 'fix' gives you the least defined fix point
17:33:30 <Mortchek> What does "least defined" mean?
17:33:48 <mm_freak> Mortchek: a typed id also has every value as its fixed point
17:34:02 <Mortchek> mm_freak, yeah, I understood that from what geekosaur showed.
17:34:28 <mm_freak> least fixed points (as found by 'fix') have little to do with types actually
17:34:34 <Guest62319> its an inside haskell joke, non terminating computations is the punchline
17:34:38 <mm_freak> it's about semantics and really makes only sense in a nonstrict language
17:34:44 <Y0Gi> hi there. I have a function signature `String -> Map.Map String String -> String`, and it'd like to "extract" or "bundle" the type information like `(String k, String v) => k -> Map.Map k v -> v`. is something like that possible? what's the difference to `(Ord k) => ...`, which I've seen here and there?
17:34:54 <Y0Gi> s/id't/I'd/
17:35:10 <mm_freak> Y0Gi: first of all String is a type, not a class like Ord
17:35:11 <Y0Gi> s/it'd/I'd/ even *sigh*
17:35:28 <Y0Gi> mm_freak: so that doesn't work with types?
17:35:38 <mm_freak> not that it doesn't work
17:35:42 <mm_freak> more like it doesn't make sense
17:35:52 <Guest62319> :t GT
17:35:52 <mm_freak> what's your goal?
17:35:53 <lambdabot> Ordering
17:37:02 <Y0Gi> mm_freak: I'd like to extract the type information as well as introduce "type variables" so one can see what refers to what, and each type variable's value is in a single place, easy to change.
17:37:38 <Y0Gi> in my k/v example, the role of each "type variable" is clear regarding the meaning of the value it refers to.
17:37:40 <BMeph> Y0Gi: A better name for what you sound like you're asking for is, "type alias," not "type variable". :)
17:37:41 <mm_freak> Y0Gi: this is possible, but probably not what you really want…  tell me about your application
17:37:57 <mm_freak> BMeph: as i understand it, it's indeed an (existential) type variable =)
17:38:06 <mm_freak> together with a Typeable instance
17:38:13 <Cale> Y0Gi: You could write (k ~ String, v ~ String) => ...
17:38:22 <Cale> Y0Gi: if you turn on enough extensions in GHC
17:38:37 <geekosaur> but the question remains, why would you actually want to?
17:38:54 <mm_freak> Cale: seems not to make any difference to his original type signature
17:39:01 <Y0Gi> mm_freak: especially as a beginner I have to change types on a trial and error basis, and factoring out a function argument's type would make that easier
17:39:14 <mm_freak> oh
17:39:20 <mm_freak> ok, then BMeph is right
17:39:24 <mm_freak> type MyType = String
17:39:25 <Guest62319> Y0Gi: there are type synonyms, alias for types youd rather not keep typing out
17:39:29 <Y0Gi> there's redundancy, and I don't like that
17:39:40 <mm_freak> then MyType and String are the same type
17:40:05 <Cale> String is itself already a type alias for [Char]
17:40:12 <Y0Gi> so I just introduce a custom type? that sounds the right thing to do, but still overkill when used on a per-method basis, isn't it?
17:40:22 <mm_freak> Y0Gi: not at all
17:40:44 <Cale> It's possible for it to be overkill, I think
17:40:46 <mm_freak> but normally you would define application/module/abstraction-specific type synonyms, which then you can change
17:40:55 <mm_freak> type Key = String; type Value = String
17:41:00 <Y0Gi> well, in my case - a custom map lookup function (with special handling depending on the value for the key being found or not) - I would introduce types Key and Value?
17:41:01 * BMeph is now intensely curious as to what Y0Oi is up to...(hint, hint)...
17:41:12 <Y0Gi> aren't those types "global"?
17:41:15 <Cale> Once you start having trouble reading type signatures because working out what all the aliases mean takes effort
17:41:15 <mm_freak> BMeph: i guess it's about debugging and refactoring
17:41:24 * BMeph meant Y0Gi, not Y0Oi. Whoops!
17:41:25 <mm_freak> just change the type synonym instead of the individual type signatures
17:41:33 <c_wraith> I should move all my types to the context.  (a ~ Int, b ~ String) => a -> b
17:41:59 <mm_freak> in that case Cale is also right, if you want to do it on a per type signature basis
17:42:00 <Cale> c_wraith: (f ~ (->), a ~ Int, b ~ String) => f a b
17:42:07 <Guest62319> Y0Gi: types are grouped into modules
17:42:13 <c_wraith> Cale: oops.  good point.
17:42:25 <BMeph> mm_freak: I'd recommend following Alan Key's advice: "Use your intuition to ask questions, not answer them." ;)
17:42:25 <Y0Gi> that ~ thing seems to basically be what I'm looking for, but I'd like to stay with default GHC behaviour.
17:42:33 <mm_freak> ((~>) ~ (->), a ~ Int, b ~ String) => a ~> b
17:42:49 <Y0Gi> however, I'd like that they are local to a function.
17:42:58 <mm_freak> Y0Gi: add {-# LANGUAGE TypeFamilies #-} to the top of your module, then you can use ~
17:43:19 <mm_freak> this enables the TypeFamilies extension, which provides that syntax
17:43:46 <Y0Gi> mm_freak: that sounds the most promising to me, rather than extracting stuff into modules
17:44:21 <Cale> Y0Gi: If you're finding yourself working with types which are awkward to actually type out, then it might be that you need to define some proper datatypes with 'data' rather than simply synonyms though.
17:44:47 <Y0Gi> I'm still surprised I'm already thinking about this even if I wrote just very few functions in Haskell, yet ;)
17:45:13 <mm_freak> Y0Gi: i find that entirely reasonable…  beginning haskell programmers ask the most advanced questions =)
17:45:34 <Cale> Yeah, I'm sure that we'd have more specific advice if you came to us with some actual code which looked like it could use refactoring.
17:46:12 <Y0Gi> Cale: it's not the name of the types here, but there redundancy. also, seeing "String" four times, but referring to just two different arguments without naming those feels harder to grok and maintain to me.
17:46:32 <mm_freak> usually (not in your case though) those questions are about mimicking C++/java/php/…  this is when we ask, "what's your application?"
17:47:09 <Cale> Y0Gi: The really awkward thing is though, that even if you define type aliases for those, it doesn't actually prevent you from providing the wrong String values there.
17:47:20 <mm_freak> in any case, using type families here probably isn't the best idea…  refactoring a single type signature is easy enough with most editors, so i'd just leave the types as is
17:47:26 <mm_freak> this is about readability
17:47:37 <Cale> Y0Gi: So usually if you're really concerned about this, the more correct thing to do is to use newtype to define some actual new datatypes
17:48:05 <mm_freak> note that you can spread a type signature over several lines, if you wish…  this makes sense for long signatures and later also helps, when you start using haddock to document your code
17:48:39 <mm_freak> finally type synonyms can be anything, not just simple aliases
17:48:47 <mm_freak> type MyFunc = String -> Map String String -> String
17:48:51 <mm_freak> myFunc :: MyFunc
17:49:28 <mm_freak> or even:  type MyFunc k v = k -> Map k v -> v
17:49:32 <mm_freak> myFunc :: MyFunc String String
17:49:39 <Nolrai24> So how would "Writer (s -> s)" be differnt then "State s"?
17:49:52 <mm_freak> Nolrai24: that type doesn't work
17:49:59 <mm_freak> (a -> a) is not a Monoid
17:50:11 <Cale> mm_freak: He presumably means under composition
17:50:21 <Cale> So  Writer (Endo s)
17:50:35 <Y0Gi> here is my code: https://gist.github.com/3195482
17:50:57 <mm_freak> @unmtl Writer (Endo s)
17:50:57 <lambdabot> Plugin `unmtl' failed with: `Writer (Endo s)' is not applied to enough arguments, giving `/\A. (A, Endo s)'
17:50:57 <Cale> the difference is that during a State s computation, you have access to a value of type s, and can make the remainder of the computation depend on that value
17:50:57 <mm_freak> @unmtl Writer (Endo s) a
17:50:58 <lambdabot> (a, Endo s)
17:51:30 <Cale> with Writer (Endo s), the same thing will happen every time, independently of the functions which have been composed to that point
17:52:21 <mm_freak> to understand Cale's point better, try to implement 'get' using Writer (Endo s)
17:52:41 <Nolrai24> Oh..I see.
17:52:42 <Cale> The difference is the same as the difference between the types  s -> (a, s) and  (a, s -> s)
17:53:09 <Nolrai24> In the second the a doesn't depend on the input s.
17:53:16 <Cale> (those are isomorphic to State s a and Writer (Endo s) a respectively)
17:53:20 <Cale> right
17:53:22 <Nolrai24> Okay makes sense.
17:54:23 <Nolrai24> Thanks
17:54:28 <Nolrai24> Cale++
17:54:49 <Y0Gi> mm_freak: MyFunc (second example) looks good, but extracting a type for a signature that's used just once doesn't seem appropriate
17:55:15 <mm_freak> Y0Gi: it may be
17:55:24 <mm_freak> f :: String -> String -> String -> String -> String -> Int
17:55:58 <Cale> If you have that many string parameters, you might want to construct a datatype
17:56:32 <Y0Gi> mm_freak: well, that signature might be common, but the way in which arguments are used might be different
17:56:32 <mm_freak> Y0Gi: it's not very common in haskell =)
17:56:32 <Cale> data Person { name :: String, company :: String, email :: String, address :: String }
17:56:41 <Cale> f :: Person -> Int
17:56:46 <Cale> or whatever, you get the idea
17:56:49 <mm_freak> Cale: yeah, but this makes composition more difficult
17:56:56 <mm_freak> may be appropriate, but not always
17:56:58 <Cale> mm_freak: *maybe*
17:57:02 <Cale> It could also make it easier
17:57:45 <Cale> connecting together a function which produces a 4-tuple of strings, and a function String -> String -> String -> String -> Int is going to be more awkward
17:57:55 <Cale> than composing a function which produces a Person with one which takes a Person
17:58:09 <Y0Gi> comparing to other languages I think the point is that those languages bind an arguments name and type in a single place (e.g. `k: Int, v: String` in Scala) while in Haskell, they are defined separately (although close together)
17:58:22 <mm_freak> bottom line:  "it may be" =)
17:58:41 <Cale> You should only form datatypes which make some amount of sense, but often if there are lots of parameters, there are meaningful ways to start bundling those parameters
17:58:49 <Cale> *especially* if they're all Strings
17:58:55 <mm_freak> Y0Gi: that wouldn't really make sense for haskell, because of currying
17:59:28 <Y0Gi> mm_freak: well, yes, I understand the idea behind the `a -> b -> c` thing
17:59:53 <Y0Gi> I guess I'm used to some kind of syntax sugar for stuff that behaves similar ;)
18:00:04 <Nolrai24> mm_freak: Coq does it fine, and it has curring.
18:00:09 <mm_freak> Y0Gi: what you are using in haskell is already syntax sugar =)
18:00:22 <mm_freak> Nolrai24: it's a little different for dependently typed languages
18:00:36 <Nolrai24> mm_freak: why?
18:00:50 <Y0Gi> regarding my code: is there a way to make the lookup method more general? factoring out the key and value arguments is my goal, after all
18:01:08 <Cale> Y0Gi: can you make it genuinely polymorphic?
18:01:17 <Y0Gi> actually, I got the inspiration for my attempt from the code of Data.Map which looks similar
18:01:22 <Cale> Y0Gi: what is the inferred type of the function if you leave off the type signature?
18:01:28 <mm_freak> Nolrai24: because passing of type variables is explicit, and referring to a defined type is equivalent to passing a type
18:01:55 <Y0Gi> Cale: good point, I'll check
18:01:59 <mm_freak> but my point was really that 'f' may look like "f = …"
18:02:16 <mm_freak> instead of "f firstname surname city country = …"
18:02:22 <Y0Gi> Cale: well, it's just the same thing but with [Char] instead of String
18:02:38 <Cale> Y0Gi: ah, so the function does actual String operations then
18:02:59 <Nolrai24> mm_freak: hmm.
18:03:02 <mm_freak> Nolrai24: in a DT language like agda you have this option:  "f : (firstname : String) -> (surname : String) -> …"
18:03:05 <mm_freak> this is not valid in haskell
18:03:06 <Y0Gi> I'm not sure if I can use (Show k) in the signature or something like that
18:03:11 <Cale> Y0Gi: perhaps you'd like to put the code on hpaste.org
18:03:37 <Y0Gi> Cale: I posted the code already, see above
18:03:55 <Y0Gi> 02:50:15 < Y0Gi> here is my code: https://gist.github.com/3195482
18:04:07 <Cale> ah
18:04:35 <ReinH> @pf f x y = g (h x) (h y)
18:04:35 <lambdabot> Maybe you meant: bf pl
18:04:46 <ReinH> @pl f x y = g (h x) (h y)
18:04:46 <lambdabot> f = (. h) . g . h
18:04:54 <ReinH> is there a more readable way to do that?
18:05:00 <Y0Gi> my inspiration was this (from Data.Map): `findWithDefault :: Ord k => a -> k -> Map k a -> a`
18:05:06 <mm_freak> ReinH: not really
18:05:16 <elegantWay> ReinH: Data.Function.on
18:05:42 <mm_freak> :t on
18:05:42 <Y0Gi> (which magically manages to use "type variables" [what's the correct name again?])
18:05:43 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:05:55 <Cale> Y0Gi: that's the correct name
18:05:55 <mikeplus64> ReinH: f x y = g (h x) (h y) is fairly readable :)
18:06:06 <ReinH> mikeplus64: yes but not pointfree ;)
18:06:14 <elegantWay> f = g`on`h
18:06:15 <Cale> Y0Gi: It uses type variables, because the types are really polymorphic -- any type a whatsoever, and any type k which is an instance of Ord will do.
18:06:32 <elegantWay> i think.
18:06:32 <ReinH> elegantWay: let's see if it typechecks
18:06:39 <Y0Gi> Cale: so I basically want to do that, but instead of `Ord` I'd like to be more specific and define a certain type *or* achieve to make the code more general so I can use a type class(?) there
18:06:45 <mikeplus64> ReinH: i wouldn't pursue pointfree-ness over readability
18:06:52 <geekosaur> note also that what that means is that a dictionary mapping types to functions is passed along wit things
18:07:04 <elegantWay> @time mm_freak
18:07:08 <ReinH> mikeplus64: true, which is why I'm not using @pl's suggestion. I was wondering if there was a readable *and* pointfree version :)
18:07:19 <mm_freak> elegantWay: 3:06 AM
18:07:30 <elegantWay> i know ;) :D
18:07:31 <Cale> Y0Gi: You can certainly do that with type equality constraints. It's a bit unusual. You might also just add some structure to your code to make the types more meaningful:
18:07:53 <mm_freak> hehe ok
18:08:07 <mm_freak> i suppose you're not far away then =)
18:08:07 <Cale> newtype Workspace = WS String
18:08:16 <ReinH> elegantWay: g `on` h is quite nice actually :)
18:08:31 <elegantWay> ReinH: it's the elegantWay! ;) :D hehehe
18:08:35 <ReinH> eh
18:08:35 <mm_freak> i'd still write f x y = g (h x) (h y)
18:08:39 <ReinH> *heh
18:08:47 <Cale> newtype WorkspaceNames = WSM (Map Workspace String)
18:08:49 <ReinH> ... for people who know what on is ;)
18:09:00 <Y0Gi> hmm
18:09:07 <Cale> determineWorkspaceName :: WorkspaceNames -> Workspace -> String
18:09:16 <elegantWay> is there actually an elegantWay to apply a function (:: a -> a) to the first element of a list (:: [a]) (if it's not empty)?
18:09:37 <mm_freak> elegantWay: with a lens, yes
18:09:43 <mm_freak> Lens [a] a
18:09:55 <elegantWay> hm…
18:09:55 <Cale> Y0Gi: You might also want  newtype Workspace = WS Integer
18:09:59 <mm_freak> or to be safe:  Lens [a] (Maybe a)
18:10:03 <Y0Gi> Cale: sounds somewhat reasonable, especially the creation of a custom type for the workspace number/suffix mapping.
18:11:06 <Cale> Y0Gi: yeah, it becomes harder to mess things up as you keep adding information to the types like this -- of course you pay the price for it of needing to explicitly apply the data constructors (which I called WS and WSM in my example)
18:11:19 <Y0Gi> Cale: it then comes down to how the values are concatenated. would I add the new types to the Show group then? if so, how?
18:11:23 <aristid> elegantWay: applyFirstElement f [] = []; applyFirstElement f (x:xs) = f x : xs?
18:11:51 <Cale> but that's sort of a way to tell the compiler that you really know what you're doing
18:11:51 <jfischoff> edwardk: I'm confused how to convert a Simple (Lens | Setter) into the first argument of 'focus'?
18:11:51 <Cale> Y0Gi: well, you're ultimately concatenating Strings here, right?
18:12:02 <Cale> Y0Gi: in my example, I left the result of determineWorkspaceName as a String
18:12:26 <Y0Gi> Cale: I actually experienced that it's a good idea to create value types to abstract from their actual implementation though their values *could* basically be represented as some primitive types.
18:12:29 <Cale> Y0Gi: The workspace itself is conceptually abstract, but its name is just a String anyway
18:12:35 * hackagebot shelly 0.13.2 - shell-like (systems) programming in Haskell (GregWeber)
18:13:10 <elegantWay> aristid: yes… but elegant, you know…
18:13:38 <Cale> Y0Gi: absolutely -- think of types as being like differently shaped nubs on Lego blocks -- you can control how people use your library and guide them into building structures which make sense
18:13:38 <Y0Gi> Cale: yeah, my question is how I connect the abstracted type inside the function to the string output I'm looking for
18:13:38 <aristid> elegantWay: i think it is quite elegant.
18:13:56 <elegantWay> i dreamt/thought of a monad-hocus-pocus…
18:14:08 <elegantWay> nevermind.
18:14:08 <Cale> Y0Gi: in this case,  determineWorkspaceName (WS k) (WSM m) = case Map.lookup k m of ...
18:14:19 <Cale> Y0Gi: you just pattern match away the constructors
18:14:20 <Y0Gi> Cale: say the workspace suffix will no longer be based on a String, but a Float (or whatever). what impact would that have on the function and its body?
18:14:33 <Y0Gi> hmm
18:14:52 <Cale> Y0Gi: Note that you can prevent these data constructors from being exported from the module you're writing
18:15:10 <Y0Gi> Cale: how do I do that?
18:15:12 <Cale> Y0Gi: and in that way control the scope of code which is allowed to view Workspace as anything other than abstract
18:15:28 <Y0Gi> Cale: yeah, that sounds like a good idea
18:15:37 <ReinH> elegantWay: I just wrote this in lieu of a Lens https://gist.github.com/f28116cbed110fe20ce7
18:15:48 <Cale> module Workspace (Workspace, WorkspaceMap, determineWorkspaceName, ... other exports ...) where
18:15:59 <Cale> Listing the name of a type will export the type, but not its constructors
18:16:19 <Cale> If you *want* to export the constructors, you can put e.g. Workspace(..)  in the export list
18:16:29 <ReinH> applyFirstElement lst f = updateList f 0
18:16:32 <Cale> which will tell it to export all the constructors of Workspace
18:16:45 <Cale> or you can list them inside the parens instead of putting two dots
18:16:45 <Y0Gi> Cale: ah, I see what you refer to. seen that somewhere.
18:16:46 <elegantWay> ReinH: thank you =), but honestly i won't actually need it anymore… :P
18:16:46 <ReinH> er no but you gt the idea ;)
18:16:54 <aristid> elegantWay: if you really need it pointfree: \f -> uncurry (++) . (f *** id) . splitAt 1
18:16:55 <ReinH> elegantWay: oh well. I still need it though ;)
18:17:10 <elegantWay> aristid: that seems elegant :D
18:17:31 <elegantWay> aristid: cool.
18:17:32 <aristid> elegantWay: i think the pattern matchin version is more elegant.
18:17:33 <Cale> Y0Gi: by the way, when you're designing functions, the order of parameters actually matters a bit more in Haskell than most other settings
18:18:07 <Cale> Y0Gi: you should generally try to arrange them in order of increasing frequency of expected change.
18:18:34 <aristid> elegantWay: actually i had a tiny bug there. it should be \f -> uncurry (++) . (map f *** id) . splitAt 1
18:18:34 <mm_freak> i think the lens version is elegant…  a lens is always great =)
18:18:51 <elegantWay> aristid: oh, yea.
18:19:04 <Cale> Y0Gi: so if you have one parameter which sort of represents "global configuration" of some type, that should be first, and the more specific details should come later
18:19:04 <mm_freak> (element 0 %= f) [1..10] = f 1 : [2..10]
18:19:15 <mm_freak> element :: Int -> Lens [a] a
18:19:17 <Cale> Y0Gi: note how you had to use a lambda in workspaces
18:19:34 <Cale> Y0Gi: if the parameters to determineWorkspaceName were in the other order, you don't need a lambda
18:19:46 <Cale> (you just apply the function to its first parameter)
18:19:46 <aristid> mm_freak: can you do without the numeric index?
18:20:05 <elegantWay> mm_freak: just out of curiosity, do you fast?
18:20:06 <aristid> mm_freak: i suppose a headLens would do the trick?
18:20:37 <Y0Gi> Cale: good observation, I didn't like it either. however, I modeled it after Data.Map.{lookup, findWithDefault} which don't take the map as the first argument (surprisingly)
18:20:48 <mm_freak> elegantWay: i don't understand the question
18:20:55 <Cale> Y0Gi: indeed
18:20:56 <mm_freak> aristid: sure
18:21:08 <Cale> Y0Gi: there have been discussions about that :)
18:21:13 <Y0Gi> I hope so ;)
18:21:24 <mm_freak> if you're brave you can have:  elements :: IntSet -> Lens [a] (Maybe a)
18:21:33 <aristid> mm_freak: build me an element lens built from primitive head and tail lenses!
18:21:39 <Cale> Y0Gi: in a more general setting it's harder to say what's right
18:21:46 <mm_freak> elegantWay: oh, i don't
18:21:54 <elegantWay> ah =)
18:22:13 <Y0Gi> Cale: so, yeah, your suggestion in general makes total sense, but I chose to adhere to that "reference", just so I can blame others for now, and more so as a beginner ;)
18:22:18 <Cale> :)
18:22:19 <aristid> fast as in the thing where you don't eat?
18:22:30 <elegantWay> uhuh. *nod*
18:22:44 <aristid> elegantWay: that's about as off-topic of a question as it gets
18:22:54 <elegantWay> uhuh. *nod*
18:22:54 <GyorsCsiga> Cale, have you made a japanese verb conjugator in haskell yet? :)
18:22:57 <Y0Gi> Cale: let me try to use newtype now
18:23:23 <Y0Gi> Cale: is the constructor name optional?
18:24:20 <Cale> no
18:24:27 <mm_freak> aristid: that doesn't seem to be possible
18:24:41 <aristid> mm_freak: not? :(
18:24:43 <Cale> It is required, because otherwise there would be no way to determine whether values were of the new type or the old one
18:24:53 <mm_freak> aristid: at least not for edwardk-style comonadic lenses =)
18:25:10 <Cale> However, the constructor is a compile-time construct, and you can reasonably expect the compiler to boil it away to nothing.
18:25:23 <aristid> mm_freak: are there monadic lenses, too?:)
18:25:23 <Cale> So it shouldn't have a runtime cost anyway.
18:25:41 <mm_freak> aristid: i don't see how that would be possible
18:25:41 <Cale> (but it makes a difference to the typechecker)
18:25:55 <Cale> GyorsCsiga: nope
18:26:04 <mm_freak> aristid: also the lenses themselves don't form a comonad, but they are based on a Store comonad
18:26:30 <Cale> GyorsCsiga: telling the difference between v1 and v5r would be tricky.
18:26:31 <mm_freak> effectively they are equivalent to:  newtype Lens a b = Lens (a -> (b, b -> a))
18:26:39 <Cale> GyorsCsiga: you'd basically need a dictionary
18:27:42 <aristid> mm_freak: which package?
18:27:53 <GyorsCsiga> Cale, what if you used a latin alphabet then later checked against a dictionary?
18:28:00 <Cale> GyorsCsiga: hm?
18:28:30 <GyorsCsiga> I don't know what 'v1' and 'v5r' is, sorry… I thought it had something to do with charsets
18:28:46 <Cale> The Latin alphabet doesn't expose whether a verb ending in る is an ichidan verb or a godan verb.
18:29:16 <Cale> You just have to know which of the two it is to know how it conjugates.
18:29:29 <aristid> mm_freak: http://hackage.haskell.org/package/lens ?
18:30:17 <GyorsCsiga> Cale, then why not use a dicitonary?
18:30:24 <mm_freak> aristid: data-lens
18:30:25 <GyorsCsiga> it seems like an awesome haskell project :)
18:30:28 <Cale> You absolutely could :)
18:30:42 <aristid> mm_freak: but lens is an edwardk package too! and newer
18:30:47 <Y0Gi> I haven't yet understand how to implement or deal with Show. I did `newtype X = X String deriving (Eq, Show)`, and `show X` returns `X "the-value-is-here"`. but how do I access the value (and so that it doesn't contain the quotation marks)?
18:30:51 <GyorsCsiga> 'Japanese verb conjugator  PS: it was written in haskell'
18:30:55 <mm_freak> aristid: 'lens' implements lens families
18:31:10 <mm_freak> data-lens is for simple monomorphic update lenses
18:31:58 <aristid> mm_freak: uh i don't know what the difference is!
18:32:40 <mm_freak> aristid: a regular lens can't update (Int, Int) to (Double, Int)
18:32:43 <mm_freak> a lens family can
18:33:04 <mm_freak> LensFamily (Int, Int) (Double, Int) Int Double
18:33:24 <aristid> mm_freak: so a regular lens needs to preserve the type?
18:33:30 <mm_freak> aristid: yeah
18:34:09 <aristid> mm_freak: why not always use lens families then?
18:34:26 <mm_freak> aristid: because they've been discovered recently =)
18:34:33 <Nolrai24> @ty foldl
18:34:34 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:35:09 <geekosaur> Y0Gi, you might want to ignore Show and use some prettyprinter function of your own.  Show is not for the kind of use you want
18:36:03 <aristid> mm_freak: omg both isomorphisms and regular lenses are lens families?!
18:36:04 <jfischoff> artisid: also the 'lens' package has breaking changes coming in every few hours. That being said, I'm taking it for a spin.
18:36:36 <mm_freak> aristid: isomorphisms are lenses
18:36:49 <aristid> mm_freak: they are?
18:36:54 <mm_freak> check out the 'iso' function from data-lens
18:36:58 <Y0Gi> geekosaur: thanks
18:37:04 <mm_freak> iso :: (a -> b) -> (b -> a) -> Lens a b
18:37:28 <aristid> mm_freak: oh, just ignoring that parameter?
18:37:30 <mm_freak> for example it allows you to access a complex number in polar representation
18:37:33 <Y0Gi> I guess I basically need to do pattern matching in a custom functions argument list to access the first/single value of my custom type as an argument?
18:37:44 <mm_freak> aristid: what parameter?
18:37:52 <elegantWay> are there something like nested guards? i don't like if-then-else much…
18:38:34 <Y0Gi> ah, I got it :)
18:38:34 <mm_freak> elegantWay: example code?
18:38:39 <colock> mm_freak, aristid: everything is said from the signature
18:38:50 <aristid> mm_freak: if you compare lens and iso
18:38:53 * colock should do more haskell :/
18:39:09 <aristid> mm_freak: then lens has one more parameter in the setter
18:40:13 <hpaste> elegantWay pasted “mm_freak: e.g. like this” at http://hpaste.org/72284
18:41:01 <elegantWay> i like conal.
18:41:21 <mm_freak> aristid: iso polar (uncurry mkPolar)
18:41:28 <mm_freak> RealFloat a => Lens (Complex a) (a, a)
18:42:26 <mm_freak> elegantWay: when i don't care for micro-performance, i just write the outer predicate as a variable
18:42:40 <mm_freak> f | x, a = … | x, b = … where x = …
18:43:04 <elegantWay> mm_freak: x, a???
18:43:11 <elegantWay> did you mean x && a?
18:43:13 <aristid> mm_freak: but if you just want a total isomorphism, there are certainly more specific types for that
18:43:20 <mm_freak> aristid: yes, that's the idea
18:43:29 <aristid> mm_freak: more specific than Lens.
18:43:43 <mm_freak> with 'iso' you can only turn isomorphisms into lenses, so every isomorphism is a lens, but not every lens is an isomorphism
18:44:03 <mm_freak> 'lens' is the most general constructor for lenses
18:44:30 <aristid> mm_freak: right, and when you use an isomorphism as if it was a normal lens, the "old value" just gets ignored, right?
18:44:30 <mm_freak> > let x | True, True = 3 in x
18:44:31 <lambdabot>   3
18:44:34 <mm_freak> @ elegantWay
18:44:39 <mm_freak> ',' means 'and'
18:44:47 <elegantWay> that works? COOL!
18:44:50 <elegantWay> i didn't know that.
18:44:58 <elegantWay> it's syntactic sugar for &&?
18:45:00 <mm_freak> aristid: yeah
18:45:09 <mm_freak> elegantWay: not exactly
18:45:12 <elegantWay> mm_freak: you mixed up "and" and (&&), i think, though.
18:45:12 <mikeplus64> elegantWay: a bit, you can pattern match in guards
18:45:15 <elegantWay> @type and
18:45:16 <lambdabot> [Bool] -> Bool
18:45:20 <mm_freak> elegantWay: with ',' you can introduce a pattern guard, for example
18:45:39 <mm_freak> f | x, Y z <- w = …
18:45:54 <elegantWay> awesome, brilliant.
18:45:57 <mm_freak> i actually use this somewhat often:  x | Left y <- z = …
18:45:58 <mikeplus64> > let f x | Just y <- x, y = "yo"; | otherwise = "potato"
18:45:59 <lambdabot>   <no location info>: parse error on input `|'
18:46:10 <mm_freak> mikeplus64: without ;
18:46:17 <mikeplus64> how do you do single line guards? i don't think i've ever done them before
18:46:19 <mikeplus64> > let f x | Just y <- x, y = "yo" | otherwise = "potato"
18:46:20 <lambdabot>   not an expression: `let f x | Just y <- x, y = "yo" | otherwise = "potato"'
18:46:26 <mikeplus64> > let f x | Just y <- x, y = "yo" | otherwise = "potato" in f (Just 4)
18:46:27 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
18:46:28 <lambdabot>    arising from the literal `4'...
18:46:32 <mikeplus64> > let f x | Just y <- x, y = "yo" | otherwise = "potato" in f (Just True)
18:46:33 <lambdabot>   "yo"
18:46:36 <mikeplus64> ah
18:54:26 <gwern> @quote
18:54:26 <lambdabot> Riastradh says: that's bullcrap, stop speaking nonsense!
18:54:36 <Y0Gi> are there conventions for comments in Haskell, e.g. normal/one-liner comments as opposed to "official"/public function descriptions (like Python docstrings, or JavaDoc blocks)?
18:54:47 <Y0Gi> I've seen some comments starting with `--|`
18:54:55 <Cale> Those are Haddock comments
18:55:09 <Cale> and I believe they have to have a space between -- and | or else that becomes an operator
18:55:25 <Cale> > let x --| y = x^2 - y^2 in 5 --| 7
18:55:26 <lambdabot>   -24
18:55:38 <monochrom> @seen chrisdone
18:55:38 <lambdabot> Unknown command, try @list
18:55:46 <monochrom> preflex: seen chrisdone
18:55:46 <preflex>  chrisdone was last seen on #haskell 3 hours, 31 minutes and 16 seconds ago, saying: and roll
18:56:06 <ReinH> Y0Gi: haddock comment syntax is described in its docs
18:56:12 <Cale> http://www.haskell.org/haddock/doc/html/markup.html
18:56:22 <ReinH> yes those :)
18:56:37 <Y0Gi> thanks
18:56:45 <monochrom> you saw "-- |", with a space there
18:56:59 <monochrom> but you guessed right
18:58:42 <aristid> mm_freak: somehow the lens package is just beautiful :)
18:59:25 <mm_freak> aristid: lens families are beautiful =)
18:59:51 <aristid> mm_freak: and the underlying van laarhoven lenses are cool too
19:00:43 <mm_freak> of course =)
19:01:14 <mm_freak> you can write lenses without depending on the lens library…  only /using/ lenses requires the library =)
19:01:40 <aristid> mm_freak: you can even compose them without the library :D
19:04:34 <aristid> mm_freak: the only nasty thing is that the laws are not part of the type
19:05:18 <mm_freak> i haven't really investigated lens families yet…  so far i get along without them, but when the time comes, i'll learn all that stuff =)
19:07:13 <Y0Gi> Cale: here's what my code evolved to: https://gist.github.com/3195482 - Any suggestions?
19:37:20 <ezyang> I'm not sure if I should be offended that this works. http://hpaste.org/72285
19:37:53 <ezyang> The signature of the folding function really ought to be (forall s'. ST s' a) -> (forall s. ST s [a]) -> (forall s. ST s [a]), but GHC can't unify those two functions.
19:46:54 <ezyang> OK, not offended that it works, but it does mean this example is degenerate. *looks for another example...*
19:50:29 <dobblego> k m m' = do { x <- m; xs <- m'; return (x:xs) }
19:50:33 <dobblego> k = liftA2 (:)
19:50:54 <dobblego> that should work
19:51:16 <ezyang> That's not the interesting bit; the interesting bit is the explicit type signature ;-)
19:51:34 <ezyang> though yes, one could use liftA2 to reduce typing...
20:09:24 <hpaste> startling pasted “reading and writing trees” at http://hpaste.org/72286
20:09:35 <dolio> ezyang: There's no need for the type with three quantifiers.
20:09:41 <startling> hi, anyone see any obvious improvements to this? ^^
20:09:51 <ezyang> dolio: Yep, that's right!
20:09:58 <ezyang> With a scoped type variable, I don't need that second one.
20:10:11 <ezyang> But I was looking for an example where I would need all the quantifiers >.>
20:10:21 <dolio> You can just run the fold at the 's' that is in the return type of sequenceST.
20:14:35 <ddarius> > vdC 3 20
20:14:36 <lambdabot>   Not in scope: `vdC'
20:15:17 <edwardk> fiddling with naming things in lens again. thinking about using +~, etc. for the functional assignments and +=, etc. for the ones that work in MonadState
20:16:05 <ddarius> +~ sure screams assignment to me.
20:16:13 <ezyang> Every time I see someone do type level computation in Haskell, I cry a little.
20:16:33 <ezyang> Not because type level computation is bad, but because we're so far away from it being nice :-(
20:19:41 <ddarius> datakinds help.
20:21:20 <ezyang> Yeah, I bet.
20:22:18 <ddarius> Maybe someday we'll have OverlyLiberalTypeSynonyms.
20:22:42 <ezyang> "Screw that: I want to write functions that take types and values and do reasonable things!"
20:23:06 <startling> TypeSynonymsThatJustDon'tCare
20:25:02 <nand`> =: for assignment?
20:25:29 <ddarius> > let (<~) = undefined in 3 <~ 4
20:25:30 <lambdabot>   *Exception: Prelude.undefined
20:25:37 <nand`> :)
20:25:58 <nand`> that gives me the feeling it's some form of odd flipped ~>
20:26:51 <Ralith> Is it feasible to invoke parsec recursively and forward error messages?
20:27:20 <Ralith> i.e. implement a parser that calls 'parse' and handles an error result cleanly
20:28:14 <startling> Ralith, why in the world?
20:28:50 <Ralith> startling: I want to use parsec to process s-expressions.
20:29:46 <Ralith> i.e. token trees
20:29:56 <Ralith> (as opposed to mere lists)
20:30:49 <startling> Ralith: sexp = parens sexp ?
20:31:00 <Ralith> the fact that the tokens form a tree is the important part.
20:31:16 <Ralith> processing of subtrees is naturally achieved by recursion, so I'm trying to do that.
20:32:46 <startling> Ralith, but parsec's parsers can do their own recursion
20:34:14 <Ralith> startling: I want to write a function :: MyParser -> MyParser which only succeeds on a list whose contents are successfully parsed by its first argument.
20:34:57 <Ralith> startling: how can I do that with parsers that "do their own recursion"?
20:35:31 <startling> Ralith, is `try` what you want?
20:35:45 <Ralith> that has absolutely nothing to do with what I want.
20:36:37 <startling> Ralith, how is that different from an ordinary MyParser?
20:36:56 <Ralith> startling: I have a tree, NOT a list, of tokens. I want to write a function which takes a parser of tokens and returns a parser similar to its argument except that it operates on a subtree.
20:38:08 <startling> Ralith: so you want "dolist myparser [a, b, c]" to only succeed if myparser parses a, b, and c?
20:38:17 <Ralith> yes :D
20:38:47 <Ralith> modulo the precise types
20:39:25 <startling> hmmm, interesting
20:40:02 <startling> I don't think recursively calling parse is the way to go, but I'm not certain what is.
20:41:15 <Ralith> I expect I could write a modified version of parse which does as I want fairly easily.
20:41:44 <geekosaur> parseListOf parser = char '[' >> parseSome parser [] >>= \l -> char ']' >> return l where parseSome p l = p >>= \t -> (char ',' >> parseSome p t) <|> return t -- ?
20:42:16 <geekosaur> I think Parsec at least already has an appropriate primitive, and I'm sure I'm misremembering something and the above doesn't typecheck or something
20:42:19 <Ralith> geekosaur: that's a parser for a list of tokens, which isn't what I want.
20:42:47 <Ralith> also, the primitive is 'between'
20:43:02 <Ralith> and, as discussed above, is not useful for my case.
20:43:04 <geekosaur> perhaps I misunderstood the "dolist" thing above
20:43:48 <geekosaur> or perhaps you are not describing what you actually want very well; how do you describe your tree in a flattened, parseable form?
20:44:02 <Ralith> what do you mean?
20:44:12 <Ralith> flattening the tree would make it no longer a tree, which would entirely miss the point.
20:44:24 <Ralith> parsing a tree of tokens is my objective.
20:44:32 <geekosaur> I mean, text is typically 2 dimensional
20:44:37 <Ralith> yes, I'm not parsing text.
20:44:47 <Ralith> (I think you meant 1)
20:45:42 <geekosaur> I am wondering if you are using "parse" in the same sense Parsec does, then
20:46:04 <geekosaur> since a tree is the *result* of a parse
20:46:23 <ddarius> It sounds like he wants to use Parsec as a tree parser which it is not, though maybe it could be abused to do what he wants if it is simple enough.
20:46:43 <Ralith> I'd hope it sounds that way, given the number of times I've said that :P
20:47:39 <startling> Ralith, what kinds of things are you doing? tree transforms?
20:48:14 <Ralith> basically, yeah
20:48:33 <Ralith> my actual use-case is not that general, but lies within that class.
20:48:38 <startling> Ralith, yeah, that's not really what parsec is for
20:49:03 <Ralith> is there a reason for that? Because it doesn't seem like it would require much to achieve.
20:49:17 <startling> I don't think there's a reason for it
20:49:23 <ddarius> Parsec expects a stream of tokens.
20:49:28 <startling> why isn't there an ometa implementation in haskell yet?
20:49:47 <MostAwesomeDude> Probably because getting the types to line up would be difficult.
20:49:53 <ddarius> startling: There are a lot of Haskell or Haskell related tree transforming systems .
20:49:54 <Ralith> ddarius: it gets one; it's just that some of the tokens are streams of tokens themselves.
20:54:05 <ddarius> Ralith: A tree parser would be able to say things like: match an A followed by a B in the left subtree followed by a C in the left subtree's left subtree or things like the token in the left branch matches the token in the right branch's left branch.  Things like this would not be at all natural/easy to do with a stream of tokens
20:55:34 <Ralith> why not? It's pretty easy to envision with a construct like startling described.
20:56:23 <startling> *assuming rose trees
20:56:39 <Ralith> (which are what I'm using)
20:58:17 <ddarius> Ralith: I'm not sure what startling's "construct" does nor it would express the latter example, for example.
20:58:29 <Ralith> construct?
20:59:20 <Ralith> what is 'startling's "construct"'?
20:59:40 <ddarius> You tell me, you're the one who referred to it.
21:00:35 <Ralith> oh, that's what you meant
21:01:26 <Ralith> it does just what he described: executes a parser on a new token list.
21:03:57 <Ralith> most usefully when that token list is itself a token of the currently-being-parsed list.
21:04:39 <quintessence> you lose backtracking if you run a separate nested parser over the node's children (rather than using combinators to make one bigger parser)
21:06:25 <Ralith> ah. I don't actually need backtracking here, though.
21:07:35 <quintessence> so you basically just want a convenient way to write folds over rose trees?
21:09:02 <Ralith> basically.
21:09:32 <Ralith> folds which do very parsec-y things.
21:14:00 <Ralith> unrelatedly: how the crap do I get haskell-mode to stop forcing inferior-haskell to the wrong root directory :|
21:16:51 <Y0Gi> thanks, guys.
21:16:53 <quintessence> there's an inferior-haskell-find-project-root variable
21:17:46 <Ralith> any idea why it might be screwing up? I looked at its heuristics and they seem like they should work
21:19:02 <quintessence> no idea; I remember it used to not work right for me once upon a time, but it seems to do the right thing now
21:19:39 <Ralith> hm.
21:19:54 <Ralith> well, by hand will do for now, thanks
21:21:33 <startling> what's the best way to deal with an IO (Maybe x)?
21:21:50 <latro`a> MaybeT?
21:21:53 <dobblego> MaybeT IO x — perhaps
21:22:03 <dobblego> startling: what operations are you performing with it?
21:22:29 * elegantWay would use IO (Maybe x) just as it is… oO
21:22:51 <latro`a> depends if you're doing repeated failure checks and such
21:23:01 <latro`a> if so you get the case statement moving across the file problem :p
21:23:09 <dobblego> elegantWay: how would you write IO (Maybe x) -> (x -> IO (Maybe y)) -> IO (Maybe y) ?
21:23:23 <dobblego> or even: IO (Maybe x) -> (x -> y) -> IO (Maybe y) ?
21:23:26 <elegantWay> dobblego: PLEASE wait.
21:23:40 <dobblego> wait?
21:23:40 <startling> well, I have readTree :: FilePath -> IO (Maybe Tree) and writeTree :: FilePath -> Tree -> IO (). what's the best way to sequence them?
21:23:41 <elegantWay> i'll do that, PLEAASE wait! it's a nice exercise for me.
21:23:57 <dobblego> relax, they are just type signatures
21:24:17 <latro`a> ...ish
21:24:27 <latro`a> they are clearly fmap/bind, except the fmap is weirdly flipped
21:24:30 <dobblego> startling: MaybeT allows you combine the behaviour of IO and Maybe, which is probably what you need
21:24:44 <startling> guess it's time to learn Monad transformers. :)
21:24:46 <dobblego> so is bind
21:24:57 <elegantWay> dobblego: that's crappy…
21:24:59 <latro`a> bind is weirdly flipped in general
21:25:01 <dobblego> (weirdly flipped bind, so I did same for fmap)
21:25:07 <dobblego> right
21:25:14 <dobblego> elegantWay: what is crappy?
21:25:23 <elegantWay> writing such a function…
21:25:33 <dobblego> yes I agree, so you would use MaybeT
21:25:43 <dobblego> kittens would be saved
21:25:45 <elegantWay> how does that help?
21:25:53 <latro`a> MaybeT already has functions with those types
21:25:55 <dobblego> because it combines the two monads for you
21:25:56 <latro`a> that do what they should
21:26:08 <elegantWay> dobblego: ah!
21:26:12 <dobblego> (x -> MaybeT IO y) -> MaybeT IO x -> MaybeT IO y
21:26:13 <elegantWay> latro`a: ah!
21:26:37 <dobblego> no need to case it out and fiddle around at the two different levels
21:26:47 <dobblego> MaybeT is a good introduction to monad transformers imo
21:27:21 <elegantWay> is "MaybeT m x" a type-synonym (or similar) for "m (Maybe x)"?
21:27:29 <dobblego> it's a newtype yes
21:27:43 <elegantWay> nice =)
21:27:46 <dobblego> you should write it and then implement Functor, Applicative and Monad as an exercise
21:27:56 <elegantWay> i got it, cool. thanks =)
21:27:58 <elegantWay> dobblego: heh.
21:28:02 <elegantWay> i'll do that.
21:28:11 <dobblego> newtype MaybeT f a = MaybeT (f (Maybe a)); instance Functor f => Functor (Maybe f) where …
21:28:18 <latro`a> what gets kinda weird is the different fmaps, returns, etc.
21:28:19 <latro`a> in the same function
21:28:21 <elegantWay> (… but first i'll debug my current project…)
21:28:21 <dobblego> ok let me know if we can help
21:28:30 <latro`a> like fmap (fmap f) uses two different functor instances
21:28:53 <dobblego> if you write fmap (fmap f), then you probably should be using a transformer (and just one call to fmap)
21:29:03 <latro`a> no, I meant in the definition of a transformer
21:29:09 <dobblego> oh right yes
21:29:23 <dobblego> the Functor instance (and Applicative) will not use any Maybe-specific behaviour
21:29:32 <latro`a> um
21:29:40 <latro`a> ish
21:29:44 <latro`a> the inner fmap f is Maybe's fmap
21:29:50 <dobblego> that is not Maybe-specific
21:29:54 <dobblego> that is Functor
21:30:13 <latro`a> not sure how Maybe's Functor instance isn't specific to it
21:30:18 <dobblego> to be clear, you could implement Functor+Applicative, then change the code by substituting Maybe with a different functor and the code will compile
21:30:27 <latro`a> ah right
21:30:28 <dobblego> I will write it up, sec
21:30:29 <latro`a> that
21:30:35 <latro`a> no, I know what you mean now
21:30:39 <startling> so yeah, this is the kind of problem MaybeT et al were written for?
21:30:39 <dobblego> ok
21:30:44 <latro`a> pretty much
21:30:49 <startling> I see.
21:30:51 <latro`a> m (n a) is nT m a
21:30:54 <dobblego> startling: yes, this is probably what you want based on what you said
21:31:06 <dobblego> latro`a: that is not quite true
21:31:09 <startling> awesome
21:31:11 <latro`a> I know
21:31:12 <latro`a> but
21:31:15 <latro`a> if you have an m (n a)
21:31:20 <latro`a> you should look into nT m a
21:31:24 <startling> always nice seeing that other people have found the same problems I have. :)
21:31:31 <dobblego> No, that is not quite true
21:31:32 <latro`a> oh?
21:31:42 <dobblego> consider ReaderT a f b = a -> f b
21:31:54 <dobblego> the functor appears in covariant position
21:32:05 <dobblego> ReaderT a f b = f (a -> b) would be wrong
21:32:14 <latro`a> hrm
21:32:20 <latro`a> oh, um
21:32:25 <dobblego> State s a = s -> (a, s)
21:32:28 <latro`a> hm
21:32:29 <dobblego> StateT s f a = s -> f (a, s)
21:32:33 <dobblego> etc.
21:32:40 <latro`a> right
21:32:41 * hackagebot plot 0.1.4.1 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk (VivianMcPhail)
21:32:48 <dobblego> MaybeT just has a single value in covariant position
21:32:50 <latro`a> knew that, but wasn't thinking about it
21:32:55 <dobblego> ok :)
21:33:36 <latro`a> (haven't had to write anything nontrivial with transformers yet; I have a little code where I could write StateT code, but it would probably be uglier than the accumulator passing I'm doing now anyways)
21:36:41 <ddarius> Yay, rho represented in three different fonts for three different things.
21:37:43 * hackagebot plot 0.1.4.2 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk (VivianMcPhail)
21:40:23 <dobblego> I am writing a chapter of a book on monad transformers and I like to figure out the best way people learn :)
21:41:14 <MostAwesomeDude> dobblego: Mu.
21:41:27 <shachaf> ddarius: There are probably enough distinguishable fonts that you could write an entire paper using only rhos.
21:41:29 <MostAwesomeDude> People all have massively different learning styles.
21:41:41 <MostAwesomeDude> shachaf: Trying for the quote file? :3
21:41:43 <dobblego> yes, that doesn't mean one should throw their hands in the air though
21:43:06 <shachaf> MostAwesomeDude: No?
21:43:18 <MostAwesomeDude> shachaf: Well, I laughed nonetheless.
21:44:00 <elegantWay> dat moment when you find the bug! AWESOME =)
21:48:58 <JoeyA> What's a concise way to implement this?  (a -> m (Maybe b)) -> [a] -> m (Maybe b)
21:49:05 <JoeyA> Monad m =>
21:49:09 <dobblego> traverse
21:49:26 <JoeyA> Namely, traverse a list, but stop when the callback returns Just.
21:49:36 <JoeyA> return Nothing if the callback returns Nothing for all items in the list.
21:50:11 <dobblego> ah, you can do that with Foldable and Alternative iirc
21:53:27 <dobblego> @type let collapse x = Data.Foldable.foldr (\a b -> pure a <|> b) empty x in collapse
21:53:28 <lambdabot>     Ambiguous occurrence `empty'
21:53:28 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
21:53:28 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
21:53:35 <dobblego> @type let collapse x = Data.Foldable.foldr (\a b -> pure a <|> b) Control.Applicative.empty x in collapse
21:53:36 <lambdabot> forall (t :: * -> *) a (f :: * -> *). (Data.Foldable.Foldable t, Alternative f) => t a -> f a
21:54:18 <dobblego> both Foldable and Alternative composes, so you can collapse from any height
21:56:08 <JoeyA> Thanks.  I think I'll just write the combinator by hand.
21:56:27 <JoeyA> It's easy to get wrong by accident, e.g. traversing the remaining items anyway, or returning the last match instead of the first match.
21:56:29 <dobblego> I might write that code out myself to remind myself if you like anyway
21:56:48 <JoeyA> t's up to you
21:59:11 <dobblego> Control.Compose.(.:) appears to be missing the Alternative instance :(
22:04:07 <blackdog> is there a package for symbolic algebra on Hackage? Looking for something that can simplify simple high-school algebraic expressions
22:05:49 <MostAwesomeDude> > (x + 1) * (x - 2)
22:05:50 <lambdabot>   (x + 1) * (x - 2)
22:05:59 <MostAwesomeDude> Aw, lambdabot doesn't wanna do it.
22:07:34 <jimi_hendrix> when i run my program, it prints "programName: <<loop>>" i assume that is some sort of error meaning an infinite loop?
22:07:43 <kallisti> yep
22:08:28 <mm_freak> jimi_hendrix: some expression is depending on itself
22:08:29 <mm_freak> like x = x + x
22:08:56 <jimi_hendrix> ah
22:09:37 <mm_freak> the strictness makes this loop forever
22:09:46 <jimi_hendrix> it would be nice if that message had the word error in it :P
22:09:48 <mm_freak> and the run-time system recognizes that and aborts with <<loop>>
22:10:06 <mm_freak> probably =)
22:12:18 <ddarius> > error "<<loop>>"
22:12:20 <lambdabot>   *Exception: <<loop>>
22:12:25 <jfischoff> blackdog: This never got very far, but might work: https://github.com/colah/HaskSymb
22:12:40 <jimi_hendrix> is there a debugger or something to give me more info on what is looping?
22:12:49 <jfischoff> blackdog: are you trying to solve for variables or just simplify expressions?
22:13:09 <blackdog> jfischoff: I'm just going through SICP again and trying to do it in Haskell this time
22:13:34 <blackdog> so just solving for variables would be a good start, but eventually i'd like to bake it into the evaluation
22:13:50 <blackdog> ... wait, that was completely incoherent.
22:14:01 <blackdog> let me try again:) simplifying would be a good start.
22:14:11 <jfischoff> I think it can simplify
22:14:20 <kallisti> you need an equation to solve variables.
22:15:41 <jfischoff> blackdog: I'm basing my thoughts on this line: https://github.com/colah/HaskSymb/blob/master/Algebra/HaskSymb/BasicAlgs.hs#L14
22:15:52 <jfischoff> I don't know what it really does :(
22:16:31 <jimi_hendrix> is there a way to get the type of something as a string?
22:16:52 <jfischoff> jimi_hendrix: would Typeable work?
22:17:00 <ddarius> jimi_hendrix: If you compile with profiling you can use the RTS option -xc to get something akin to a stack trace.
22:17:10 <ddarius> (This is true for all uncaught exceptions.)
22:17:35 <jimi_hendrix> jfischoff, well i am just trying to confirm that something is the type that i think it is
22:17:43 <jimi_hendrix> ddarius, rts?
22:17:46 <jfischoff> at runtime?
22:17:50 <ddarius> jimi_hendrix: Though really, if you aren't doing any crazy circular programming stuff, just look for shadowed variables which GHC should tell you about with a suitable warning flag.
22:18:09 <mm_freak> jimi_hendrix: and :t isn't sufficient?
22:18:11 <mm_freak> in GHCi
22:18:16 <mm_freak> :t 3 + 3
22:18:17 <lambdabot> forall t. (Num t) => t
22:18:36 <jfischoff> :t Just 'h'
22:18:37 <lambdabot> Maybe Char
22:18:37 <jimi_hendrix> mm_freak, it is in the middle of a function
22:19:15 <jimi_hendrix> ddarius, ghc shows no warnings with -w
22:19:15 <mm_freak> i think currently you can't ask for the type of a subexpression, but you can always factor it out
22:19:34 <jimi_hendrix> sounds like math homework :P
22:19:56 * shapr boings cheerfully
22:19:56 <mm_freak> the latest haskell-mode for emacs has some nifty inferior mode, so if you're an emacs user, take a look at that
22:20:07 <mm_freak> and no, it's not math homework…  it's the way you write code in haskell =)
22:20:22 <jimi_hendrix> i am, but i dont know if i have the latest haskell-mode
22:20:24 <mm_freak> haskell is a very composable language
22:20:31 <jimi_hendrix> i got it from package-install
22:20:39 <ddarius> jimi_hendrix: -w turns off warnings.
22:20:49 <mm_freak> i just check out the haskell-mode repository
22:21:11 <ddarius> There are several warning flags.
22:22:14 <ddarius> jimi_hendrix: The specific flag you want would be -fwarn-name-shadowing which would be turned on by -Wall.
22:23:58 <jimi_hendrix> ddarius, haha, thanks
22:27:35 <edwardk> preflex: xseen roconnor
22:27:35 <preflex>  roconnor was last seen on freenode/#haskell-blah 15 hours, 1 minute and 13 seconds ago, saying: how does one go about unlocking phones?
22:27:37 <jimi_hendrix> ddarius, i fixed some shadowing issues, but that didnt solve my loop. maybe hlint will catch the issue
22:27:48 <edwardk> heya shapr
22:28:07 <jimi_hendrix> and that didnt work
22:28:15 <jimi_hendrix> just a hell of a lot of redundant brackets
22:28:49 <ddarius> You are looking for things like let x = ... x ... and specifically not things like let f x = ... f x ...
22:28:56 <ddarius> GHC can't solve the halting problem.
22:29:19 <jimi_hendrix> haha
22:30:37 <ddarius> edwardk: What's the difference between Sobol sequences and Halton sequences?
22:30:54 <jimi_hendrix> well i found the line, but no hint of anything that would cause a loop
22:31:16 <jimi_hendrix> in fact, it is an if statement...
22:31:51 <jimi_hendrix> if i replace "if isNothing s then rgb 0 0 0 else rgb 255 255 255"  with something like "rgb 255 0 0", the program runs
22:32:10 <ddarius> Though sounds like you are using this in the definition of s.
22:32:15 <edwardk> They are both low discrepancy sequences, but Halton uses something with prime numbers, and the sobol sequences are generated by some polynomial over GF(2)
22:32:28 <edwardk> i've used Sobol a lot, but not Halton
22:32:53 <ddarius> edwardk: The upshot being Sobol is probably easier to implement efficiently?
22:33:14 <edwardk> yeah, you can do a pretty efficient shuffled sobol sequence generator
22:33:57 <edwardk> joe and kuo have datasets for some ridiculous number of dimensions worth of sobol sequences
22:34:06 <ddarius> edwardk: Besides gsl-random, any good packages for Sobol sequences or low discrepancy sequences on Hackage that you know of?
22:34:09 <jimi_hendrix> ddarius, shouldnt be. i will paste the segment in a second,
22:34:19 <edwardk> not on hackage
22:34:29 <edwardk> let me see if i actually bothered to finish any sobol code
22:34:59 <ddarius> jimi_hendrix: Other than optimizations sometimes making things less transparent, you pretty much -have- to be doing something like let x = ... x ... (maybe less directly than that) for a <<loop>> error to occur.
22:35:24 <edwardk> nope, nothing in haskell. i have a folder, where i started trying to figure out how to do a clean roomish variant on kuo's stuff, but i apparently got bored first
22:35:49 <edwardk> since its a few lines to read their data files, and the kuo c source file ;)
22:36:15 <ddarius> Okay, I'll try gsl-random.  The sequence generation shouldn't be a bottleneck anyway.
22:36:20 <edwardk> k
22:36:21 <hpaste> jimi_hendrix pasted “<<loop>>” at http://hpaste.org/72288
22:36:26 <edwardk> yeah
22:36:34 <edwardk> and the asymptotic gains should more than pay for the cost
22:36:50 <jimi_hendrix> ddarius, unless i am so tired i am not seeing anything, which must be the case, i dont think i am.  see that paste. if you comment out the last line and just throw a constant in there, it works
22:37:22 <kallisti> jimi_hendrix: you're referring to s in its definition.
22:37:23 <ddarius> jimi_hendrix: You'd have to give the definition of findNearestIntersection.
22:37:33 <kallisti> oh nevermind
22:37:35 <kallisti> yeah
22:38:39 <edwardk> i'm finding some of these lens functions to be rather amusing
22:38:44 <jfischoff> edwardk: what's new in world of lenses?
22:38:48 <jfischoff> ah
22:38:50 <edwardk> (%%~) :: Monoid m => Traversal a b c d -> (c -> (m, d)) -> a -> (m, b); (%%~) = id
22:39:02 <jimi_hendrix> ddarius, one second
22:39:20 <edwardk> jfischoff: sitting here cleaning up the docs in prep for a 1.0 release
22:39:28 <edwardk> renamed a lot of stuff, swapped access to 'use'
22:40:04 <jfischoff> I'm playing with it now, confused about the focus functionality, besides that all is well
22:40:10 <ddarius> "Proof: Obvious"
22:40:15 <edwardk> how so?
22:40:36 <jfischoff> let me see..
22:41:03 <edwardk> effectively: focus :: Monad m => Simple Lens a b -> StateT s m b -> StateT s m a
22:41:17 <edwardk> but it can be used with Traversals as well
22:41:19 <edwardk> er
22:41:23 <jfischoff> how about setters?
22:41:28 <jfischoff> Simple Setter
22:41:29 <edwardk> you can't focus a setter
22:41:49 <edwardk> you can use it with += etc
22:42:12 <edwardk>   focus :: Monad m => LensLike (Focusing m c) a a b b -> st b m c -> st a m c
22:42:17 <edwardk> Setter = LensLike Identity
22:42:30 <edwardk> Identity != Focusing m c ;)
22:42:44 <jfischoff> well that answers my question
22:43:01 <jfischoff> how do I wrap a setter with Focusing :)
22:43:07 <hpaste> jimi_hendrix annotated “<<loop>>” with “<<loop>> (annotation)” at http://hpaste.org/72288#a72289
22:43:12 <edwardk> interesting question
22:43:17 <jimi_hendrix> ddarius / kallisti see annotation
22:43:19 <edwardk> i wonder if i can modify focus_ to allow it
22:43:24 <edwardk> i think i can
22:43:27 <edwardk> let me try
22:44:04 <edwardk> i think i can only do that with 'State' not StateT
22:44:14 <edwardk> which makes sense
22:45:38 <edwardk>   setFocus :: Setter a a b b -> st b Identity c -> st a Identity ()
22:45:39 <edwardk> ?
22:45:42 <edwardk> or something liek that
22:45:58 <jfischoff> Yeah I think so
22:46:09 <jfischoff> I'll hpaste my use case
22:46:16 <edwardk> k
22:47:50 <hpaste> “Jonathan Fischoff” pasted “Perhaps Focusing?” at http://hpaste.org/72290
22:47:57 <jimi_hendrix> ddarius, find anything?
22:48:05 <jfischoff> not having it is no big deal, I just thought I should be able to
22:48:15 <jfischoff> I don't even know if that code works
22:48:20 <jfischoff> I'm testing it now
22:49:42 <cads> jfischoff, what kind of 'focusing' is involved there?
22:50:04 <ddarius> jimi_hendrix: Now the problem is either in intersect or objects (though that's probably just a selector) or the definition of whatever scene you are passing in.  I would guess intersect.
22:50:14 <ddarius> Also, never use foldl.
22:50:28 <cads> jfischoff,  not focusing as in linear logic craziness, is it?
22:50:29 <ddarius> And pattern matching is your friend.
22:50:43 <jfischoff> cads: not at all
22:50:49 <jfischoff> or I don't know
22:50:49 <jimi_hendrix> ddarius, yeah, objects is a selector
22:50:52 <ddarius> cads: Do you mean focusing as in abstract logic programming?
22:50:56 <jimi_hendrix> ddarius, what is wrong with foldl?
22:51:06 <jfischoff> because I don't know very much about linear logic :)
22:51:22 <jfischoff> also I'm not sure how well I understand the idea of focusing for lenses either
22:51:39 <edwardk> is Env a state monad?
22:51:48 <ddarius> jimi_hendrix: Read this sometime in the near future: www.haskell.org/haskellwiki/Stack_overflow
22:52:04 <quintessence> jimi_hendrix: foldl is neither strict (like foldl') nor usefully lazy (like foldr)
22:52:16 <cads> heh, jfischoff is there a pun intended in "focusing for lenses"?
22:52:16 <jfischoff> edwardk: its a monad stack with StateT and the MonadState instance
22:52:26 <jfischoff> cads: yeah I think so
22:52:27 <jimi_hendrix> so what should i use instead of a foldl?
22:52:36 <edwardk> then you're out of luck, notice that the monad has stuff other than Identity in it ;)
22:52:37 <ddarius> foldl' typically.
22:52:46 <edwardk> setters are pretty much a glorified map
22:53:32 <ddarius> I don't think I'd consider focus a pun but just a continuation of the analogy.
22:54:22 <hpaste> jimi_hendrix annotated “<<loop>>” with “<<loop>> (annotation) (annotation)” at http://hpaste.org/72288#a72292
22:54:25 <jfischoff> the good thing is version a is fine, the bad thing is I don't understand the significance of either one of your statements :)
22:54:30 <edwardk> hah i apparently never finished writing ReaderT's focus instance either
22:54:35 <edwardk> thanks for making me look ;)
22:54:42 <jimi_hendrix> ddarius, see new annotation
22:54:51 <jimi_hendrix> thanks for all the help btw
22:54:53 <jfischoff> np thanks for writing the code
22:54:55 <edwardk> what is a Setter?
22:54:56 <jimi_hendrix> i love the haskell community
22:55:06 <edwardk> (c -> Identity d) -> a -> Identity b
22:55:29 <edwardk> removing the Identities
22:55:30 <edwardk> (c -> d) - a -> b
22:55:30 <edwardk> its boring
22:55:33 <jfischoff> yeah
22:55:33 <ddarius> jimi_hendrix: What the heck do you think is happening with the definitions of t1 and t0?
22:55:38 <edwardk> its just shaped that way so it composes with all the rest
22:55:56 <jfischoff> right
22:57:26 <edwardk> now
22:57:31 <edwardk> can you use a Traversal instead?
22:57:37 <edwardk> you can do a LOT with traversals
22:57:44 <edwardk> those work like traverse
22:57:51 <edwardk> and you _can_ focus a traversal
22:58:23 <ddarius> edwardk: Does this lens stuff have connections with your reducers package?
22:58:26 <jimi_hendrix> ddarius, i am ensuring t0 is always less than t1. i couldnt think of a side-effect free way of doing that, and the alternative would have added a bunch more if statements
22:58:28 <edwardk> yep
22:58:33 <edwardk> it obviates the need for generators
22:58:59 <edwardk> and it has a connection to the classy prelude
22:59:10 <ddarius> jimi_hendrix: Look at what you actually wrote a bit harder, especially in light of what I said causes <<loop>> errors.
22:59:15 <edwardk> as it obviates the need for a bunch of classes that can't actually be instantiated to do similar operations ;)
22:59:35 <jimi_hendrix> ddarius, oh wow
23:00:16 <jimi_hendrix> oh i get it
23:00:30 <jfischoff> I haven't wrapped my head around Traversal, but I see how it almost looks traverse from Traversable. Besides that I am not sure what to do with it
23:00:45 <ddarius> <<loop>> errors, when you aren't intending to do circular programs, tend to be typo-ish things.
23:00:49 <jimi_hendrix> i didnt look up there because i figured it was fine because the loop didnt occur when i commented out that line in raytrace
23:01:00 <jfischoff> I'm not sure how one would use a Traversable to traverse
23:01:12 <jimi_hendrix> but when i do that, s is never evaluated
23:01:18 <ddarius> jimi_hendrix: Yep.
23:01:19 <jimi_hendrix> so intersect is never called
23:01:50 * ddarius has tuna fish, mayonnaise, peas, egg noodles, and assorted spices.
23:02:50 <quintessence> (jimi_hendrix: as an aside, the versions of those two lines that you intended to write are called `min` and `max`.)
23:03:14 * jfischoff looks at the source code for common traversals
23:03:29 <ddarius> jimi_hendrix: Another tool that can be abused for debugging is hpc.
23:03:40 <cads> jfischoff, it's kinda neat. Apparently we can encode classical and intuitionist logic into linear logic, and then use focusing as a turbo charged proof calculus
23:04:00 <cads> I wonder what focusing means for lenses
23:04:12 <jimi_hendrix> quintessence, thanks
23:04:12 * ddarius is still trying to figure out if cads is referring to "focused proofs".
23:04:19 <jfischoff> cads: its not nearly as cool.
23:04:43 <cads> ddarius, I really don't know, I'm just learning about it: http://www2.tcs.ifi.lmu.de/~vnigam/docs/IJCAR08_Presentation.pdf
23:05:24 <edwardk> anyOf (traverse.traverseLeft._2)
23:05:24 <edwardk>   :: Traversable t => (c -> Bool) -> t (Either (c2, c) c1) -> Bool
23:05:51 <edwardk> there the anyOf combinator which is for Folds has been passed the traversal obtained by composing two traversals and a lens
23:06:11 <edwardk> it'll walk into the t, into the left side of the Either, and down into the 'c's and apply your predicate
23:07:16 <edwardk> and return true if the predicate holds for any of those
23:07:25 <cads> jfischoff, heh, without knowing any of the authors that write about lenses in the CS sense, there's no hope of finding anything about "focusing in lenses"
23:07:25 <edwardk> when you focus a traversal it'll run the state action for every target of the traversal, and stitch together the result, which must be monoidal
23:07:25 <ddarius> cads: Yeah, this looks like focused proofs and the idea applies fairly generally.  Look up "abstract logic programming".
23:07:48 * jfischoff is absorbing
23:08:22 <edwardk> focus traverse  - in, say, State [Int]   would take an action State Int m, where you have a Monoid on m, and run it for every Int in the State, and give you back the monoidal result
23:08:22 <ddarius> cads: Check the references of what you find and also terms like "uniform proofs".
23:08:53 <edwardk> thats pretty powerful stuff =)
23:09:00 <jfischoff> oh
23:09:13 <edwardk> so if you have 5 things in the state that you want to run an action for, you can use a traversal that can find them, and focus it
23:09:44 <jfischoff> part of what I am finding surprising is how much you can do with such simple types
23:09:48 <edwardk> if you give me a lens, then focusing the lens will just 'narrow' your perspective to a smaller state
23:09:53 <edwardk> yeah
23:10:45 <edwardk> i've been refining and polishing for a few days now
23:10:58 <ddarius> cads: Essentially, the concepts behind the early implementations of Prolog don't scale to more complex logics, but "abstract logic programming" is post facto name for techniques that do scale (albeit, unsurprisingly, tend to lead more toward intuitionistic logic.)
23:10:59 <kallisti> edwardk: it should be possible with typeclasses to layer state records on top of each other right?
23:10:59 <ddarius> cads: Though it preceded the term "abstract logic programming" these are the ideas that are used to implement, for example, lambdaProlog.
23:10:59 <edwardk> the power of the simple types is why i've been bothering to include the 4 or so examples of what the types mean when applied to different subtypes of lenses
23:11:14 <edwardk> kallisti: you mean to focus into things that have state nested deeply?
23:11:18 <jfischoff> that's been helpful
23:11:19 <edwardk> or do you mean something else?
23:11:47 <kallisti> yes, or to have different layers of state at different points of execution
23:12:01 <kallisti> but still accessible via the same lens interface, if the lens is "available"
23:12:14 <edwardk> kallisti: yeah, thats focus.
23:12:26 <edwardk> kallisti: the snap guys use it like crazy
23:15:24 <jimi_hendrix> hmm
23:15:47 <jimi_hendrix> printing debug output is a pain since it changes the type signature
23:15:48 <kallisti> jimi_hendrix: try Debug.Trace
23:15:59 <kallisti> it lets you print trace statements in pure code.
23:16:14 <jimi_hendrix> thanks
23:16:21 <kallisti> I use "join traceShow" quite a bit to print out the result of an expression at various oints.
23:16:24 <kallisti> *points
23:17:25 <cads> ddarius, this paper mentions abstract logic programming and uniform proofs
23:17:47 <cads> if this gives a neat (and general) foundation for logic programming, I'm about it
23:18:31 <jfischoff> edwardk: I think I am started to get Traversals, they help you build, um, traversals to use with Traversable. I suppose Fold works with Foldable, right?
23:18:43 <edwardk> yeah
23:18:45 <jfischoff> very cool
23:18:52 <edwardk> basically you can do anything with a Traversal that you could do with a Traversable instance
23:18:59 <edwardk> and you cn o anything with a Fold that you could do with a Foldable
23:19:23 <quintessence> @hoogle (a -> f b) -> g a -> g b
23:19:24 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
23:19:24 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
23:19:24 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
23:19:26 <edwardk> given a Fold, you can use anyOf, toListOf, foldrOf, foldMOf', sumOf, etc.
23:19:33 <donri> edwardk: hm, is focus snap's "with"?
23:20:00 <edwardk> pretty much
23:20:50 <edwardk> the snap guys have a monad that is optimized for working with lenses that i wrote last year at hac phi
23:20:51 <edwardk> they probably have replaced most of it
23:24:21 <edwardk> my favorite combinator from today has to be filtered
23:24:38 <edwardk> filtered takes a Fold (or Lens or Traversal or Getter) and gives you a Fold
23:24:59 <ddarius> cads: That's what abstract logic programming does.
23:25:44 <edwardk> ghci> toListOf (traverse . filtered (>4) traverse) [[1,2,3],[6,7,8],[120]]    => [6,7,8,120]
23:26:32 <donri> are these things difficult to do without lenses?
23:26:50 <donri> or is the point rather that this composes with other lenses
23:26:55 <edwardk> donri: you can write one-off combinators to do everything here
23:27:00 <edwardk> but they are just that
23:27:17 <edwardk> but yeah these operations compose with more conventional lenses
23:27:26 <jimi_hendrix> kallisti, this is odd. adding trace "Test" False to a function changes the signature to require the IO monad
23:27:31 <donri> how would you do the above with just foldable/traversable?
23:27:47 <edwardk> yeesh
23:28:31 <kallisti> jimi_hendrix: it doesn't
23:28:40 <kallisti> something else is requiring IO.
23:29:01 <edwardk> foldMap (filter (>4)) ghci> foldMap (filter (>4)) [[1,2,3],[6,7,8],[120]]
23:29:02 <edwardk> [6,7,8,120]
23:29:13 <edwardk> seems to have the desired effect
23:29:25 <edwardk> of course, had i used something else that'd be a lot harder
23:29:27 <donri> some mispaste there ;)
23:30:20 <cads> hey ddarius, I've been working a bit with a database relational algebra created over a belnap's exotic four valued paraconsistent logic. It's pretty neat - the two extra values represent the cases where an agent might has either no information or contradictory information, and we can use these databases to compute stable models for logic programs.
23:30:32 <edwardk> donri: anyways, an example of where you can't just use foldable/traversable is that these also work for monomorphic containers
23:30:49 <edwardk> you can anyOf traverseText (=='x')
23:31:02 <edwardk> and that will walk into the characters of a Data.Text and look for 'x's
23:31:16 <edwardk> there is of course a one off combinator somehere in Data.Text that'll do that i'd presume
23:31:28 <cads> ddarius,  I'm pretty interested in the idea of taking a logic and transforming it into a well behaved database system, with connectives similar to natural join, selection, union, etc.
23:31:34 <donri> aha, i think i was wanting that recently. specifically i'd like haskell-src-exts' AST to be traversable but it's kind * (is that the right way to say it?)
23:31:44 <edwardk> donri: yep
23:32:04 <edwardk> that is exactly what a Traversal is for
23:32:17 <donri> nice
23:32:21 <jimi_hendrix> kallisti, all i am doing is adding   'trace "foo" 0' at the top of the do block of my function. if i comment it out then the complaint about not matching the expected type m0 b0 goes away
23:32:29 <edwardk> and you can use almost every combinator in that package on a Traversal
23:32:42 <kallisti> jimi_hendrix: oh, yes. in that case it does need to be IO
23:32:43 <edwardk> which is a nice toolbox to get for free
23:33:04 <kallisti> jimi_hendrix: because that's the type expected for "statements" in a do expression
23:33:15 <kallisti> or well, in that particular do expression. ;)
23:33:36 <quintessence> jimi_hendrix: `trace "foo" 0` is pure, so if you want it to run in a do block you have to do something like `let () = trace "foo" ()`
23:34:00 <kallisti> or return $ trace "foo" ()
23:34:09 <ddarius> Neither of those will run anything.
23:34:11 <donri> does let () there even evaluate
23:34:15 <jimi_hendrix> i see
23:34:37 <donri> there's traceIO
23:34:39 <kallisti> at that point  I would ask: why not just use putStrLn ?
23:34:41 <donri> not sure how that's different from putStrLn though?
23:34:44 <ddarius> () <- return $ trace "foo" () should evaluate though, but there are better solutions.
23:34:56 <donri> ah it outputs on stderr
23:35:09 <jimi_hendrix> ddarius, such as?
23:35:21 <cads> ddarius, say we have two predicates p* and q*, and their two extensional relations p and q, containing all tuples that satisfy p* and q*. An interesting analogy is that the relational algebraic natural join of r and q is in fact the relational extension of the conjunction of p* and q*.
23:35:37 <jfischoff> edwardk: why is there no ^= ?
23:35:41 <quintessence> Oh, I thought pattern matching () was strict; it gets even uglier when you have to bang pattern it
23:35:51 <ddarius> traceIO will go to stderr or the event log.
23:35:55 <edwardk> ^= is now for state and ^~ is for the functional version
23:35:58 <edwardk> i renamed them so that
23:36:01 <edwardk> say
23:36:11 <edwardk> += does state assignment and +~ does it for functional values
23:36:26 <ddarius> quintessence: It's not that pattern match () is strict, it's that let is always a irrefutable pattern match (until you add bang patterns.)
23:36:27 <edwardk> ^= ^~
23:36:28 <jfischoff> ah
23:36:42 <edwardk> the =+= was too symmetrical looking
23:36:53 <ddarius> jimi_hendrix: traceIO, putStrLn, hPutStrLn stderr, etc.
23:37:07 <quintessence> ddarius: d'oh, yeah
23:37:07 <edwardk> pull 1.0 i just uploaded it to hackage
23:37:08 * jfischoff nods
23:37:11 <ddarius> Even evaluate (trace "foo" ()) if for some reason you absolutely wanted to use trace.
23:38:06 <edwardk> i'm pretty happy with the current API
23:38:27 <jfischoff> yeah
23:39:06 <edwardk> i can't really think of anything to add to it, nor, more importantly of anything worth removing
23:39:13 <jfischoff> eh hack age hasn't updated yet
23:39:39 <edwardk> it shows on their package list
23:39:43 <jfischoff> hmm
23:39:44 <ddarius> cabal update
23:39:52 <jfischoff> i did ...
23:40:16 <ddarius> Hmm.
23:40:24 <donri> it's on the lens page but not the recent uploads list
23:40:30 <jfischoff> got it
23:40:46 <donri> i think that means it's still uploading?
23:40:52 <donri> or something went wrong during upload
23:40:56 <edwardk> i got a Error: dist/lens-1.0.tar.gz: 500 Internal Server Error
23:41:12 <donri> yea
23:41:12 <edwardk> when i pushed it up
23:41:13 <edwardk> just noticed
23:41:29 <donri> now it's on recent too
23:42:20 <donri> http://hdiff.luite.com/cgit/lens/commit?id=1.0 :)
23:42:45 * hackagebot lens 1.0 - Families of Lenses, Folds and Traversals (EdwardKmett)
23:42:50 * ddarius hates people who use Delta for Del^2.
23:44:23 <edwardk> now, an interesting problem i'd like to solve is how to use something like the Traversal type to make a version of Bound that can deal with multiple variable types
23:44:33 <ddarius> In fact, I'm against using Delta for any continuous differentiation operator.
23:45:08 <jfischoff> edwardk: Something to consider adding to the doc, "use the LiberalTypeSynonyms extension"
23:45:20 <edwardk> only if you want to use Simple
23:45:27 <jfischoff> yes
23:45:31 <edwardk> but yeah, i suppose i can put that in as a comment above Simple
23:45:49 <jfischoff> that's was the first I saw that extension
23:46:13 <donri> doesn't ghc tell you to enable it anyway
23:46:16 <ddarius> jfischoff: It's a very old extension albeit I believe it has silently evolved.
23:46:30 <jfischoff> donri: it didn't
23:47:00 <ddarius> Are we going to see 1.0.0.1?
23:47:25 <edwardk> i might just make SimpleFoo versions of everything instead
23:47:31 <edwardk> ddarius: yeah =)
23:48:29 * ddarius finds edwardk's quest for simultaneously stringent and non-rigorous Haskell 98 conformance quaint and bizarre.
23:49:08 <edwardk> ddarius: =)
23:49:34 <edwardk> i find that adhering to 98 guides a nice ui design and pushes me towards things where inference doesn't break, and polymorphism gives me useful laws
23:49:48 <edwardk> rank n types, i believe in strongly, so i'm willing to break that rule
23:50:05 <hpaste> “Frank Boumphrey” annotated “flazx.us database” with “flazx.us database (annotation)” at http://hpaste.org/72010#a72293
23:50:19 <jfischoff> does rank n break inference?
23:50:23 <ddarius> edwardk: Yeah, I can see why some extensions should be avoided, but others seem pretty reasonable.
23:50:23 <edwardk> here i also need TH, so i can use pretty much anything haskell offers
23:50:32 <ddarius> s/haskell/GHC/
23:51:02 <ddarius> jfischoff: For the most part, only for people defining the functions.
23:51:14 <edwardk> jfischoff: to an extent. if you pass a lens around and want to use it in multiple contexts, say, reading and writing from it with different types, etc. then make sure you've got an explicit signature on your function
23:52:05 <jfischoff> cool
23:52:12 <edwardk> jfischoff: but i consume them all monomorphically, so its really not a problem. there is the 'clone' combinator to clone a lens from a monomorphic type so you can use it polymorphically if you can only pass something LensLike around due to container restrictions, etc.
23:52:32 <edwardk> and in Control.Lens.Representable the Key type is used to pass a Rep in for 'keys'
23:53:07 <ddarius> edwardk: See the free-functor library?
23:53:13 <edwardk> nope
23:53:28 <ddarius> @hackage free-functors
23:53:28 <lambdabot> http://hackage.haskell.org/package/free-functors
23:53:35 <ddarius> It's kind of cute from a brief glance.
23:53:49 <edwardk> oh yeah
23:53:51 <ddarius> You've probably done it before back when constraint kinds were new.
23:53:56 <edwardk> i've been talking to sjoerd as that was being written
23:54:02 <edwardk> didn't know he packaged it
23:54:24 <edwardk> i do love 'type List = Free Monoid'
23:54:30 <edwardk> that pretty much made my week when it happened
23:54:31 <ddarius> Yeah.
23:54:40 * ddarius wonders if Sjoerd's version numbering system is unary.
23:56:13 <TEttinger> any parsec users here?  I am attempting to parse both integers and floating-point numbers, but I seem to only be able to make one or the other work
23:56:22 <ddarius> I might see if I remember my LtU password and post it there.
23:57:12 <ddarius> Bah, Haddock should display kinds.
23:57:13 <jfischoff> TEttinger: hpaste your code. When I have trouble with that in the past it was due to negative numbers not being handled correctly. but we'll see
23:57:19 <edwardk> TEttinger: there is an 'integerOrFloat' combinator
23:57:32 <edwardk> er naturalOrFloat
23:57:40 <edwardk> that probably does what you need,
23:58:01 <edwardk> alternately you can sprinkle a try and some glue logic in to make it work
23:58:01 <TEttinger> yeah, but edwardk would it handle -1 ?
23:58:14 <edwardk> handle the minus sign yourself first
23:58:20 <edwardk> then delegate the rest to it
23:58:55 <edwardk> sign <- optional (…); num <- integerOrDouble; multiply by negative one if the sign parsed as '-'
23:59:09 * jfischoff nods 
23:59:28 <TEttinger> ok, I will try it
