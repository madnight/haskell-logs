00:10:26 <startling> hi, I get "ghc: unable to load package `SDL-0.6.3'" when I try to use execute SDL.init. I'm on os x (snow leopard, ghc 7.4.2).
00:12:15 <startling> oh, the rest of it is Loading package SDL-0.6.3 ... linking ... <interactive>: / unknown symbol `_SDL_HasSSE2'
00:13:02 <Ralith> perhaps your system SDL installation is the wrong version?
00:13:12 <Ralith> mostly just a guess
00:13:24 <startling> sdl-config --version is 1.2.15
00:22:12 <tertl3> is skotish music good to code haskell to
00:22:20 <tertl3> like mogwai
00:23:35 <startling> tertl3: oh god no
00:23:50 <startling> don't do it, you'll be mixing monads and monoids left and right
00:23:50 <tertl3> why
00:23:56 <tertl3> lol
00:24:00 <tertl3> ok
00:24:13 <ion> Nothing wrong with mixing monads and monoids.
00:24:21 <tertl3> this new fedora spin is cool
00:34:59 <povman> geekosaur: I have a feeling my huge memory allocation is due to some other lazy thing being forced by the length calculation
00:35:15 <povman> but the profiler does not specify
00:41:50 <copumpkin> @ask koninkje_away do you think your bytestring-trie would be good with cryptographic hashes as keys? they all tend to have a prefix of a bunch of 0 bits, and then are effectively random after the first bunch
00:41:50 <lambdabot> Consider it noted.
00:42:36 <shachaf> copumpkin: koninkje_away might never see that if he /nicks. :-)
00:43:20 <copumpkin> @ask koninkje do you think your bytestring-trie would be good with cryptographic hashes as keys? they all tend to have a prefix of a bunch of 0 bits, and then are effectively random after the first bunch
00:43:21 <lambdabot> Consider it noted.
00:43:25 <copumpkin> @tell shachaf take that
00:43:25 <lambdabot> Consider it noted.
00:43:54 <shachaf> @ask copumpkin thanks
00:43:54 <lambdabot> Consider it noted.
00:44:15 <copumpkin> @ask shachaf I'm going to sleep :P
00:44:16 <lambdabot> Consider it noted.
00:44:55 <shachaf> @toll copumpkin 5 dola
00:44:55 <lambdabot> Consider it noted.
00:45:54 <copumpkin> :O
00:45:54 <lambdabot> copumpkin: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:45:59 <copumpkin> @messages
00:46:00 <lambdabot> shachaf asked 2m 6s ago: thanks
00:46:00 <lambdabot> shachaf said 1m 5s ago: 5 dola
00:46:07 <shachaf> @massages
00:46:07 <lambdabot> copumpkin said 2m 42s ago: take that
00:46:08 <lambdabot> copumpkin asked 1m 51s ago: I'm going to sleep :P
00:46:59 <povman> quite an inefficient form of communication
00:48:16 <tertl3> he
00:48:28 * hackagebot operational 0.2.1.3 - Implementation of difficult monads made easy  with operational semantics. (HeinrichApfelmus)
01:09:55 <povman> It seems like ByteString.concat uses a lot less memory (with large input lists) when len uses (foldl' (\a b -> a + B.length b) 0) rather than (sum . map B.length)
01:10:49 <shachaf> What about foldl' (+) 0 . map B.length?
01:11:06 <povman> nope, that is still bad
01:11:15 <Nereid> with foldl' ?
01:11:19 <Nereid> (as opposed to foldl)
01:11:25 <povman> yes
01:11:28 <shachaf> Strange. This is all with -O11?
01:11:42 <povman> er i dunno, better check eh :p
01:11:48 <povman> it's with cabal install darcs
01:12:17 <povman> because i copied the definition in and edited it
01:51:18 <timthelion> Is there a "warnMeAtCompileTimeThatThisCodeStillNeedsToBeWritten" function?
01:51:58 <timthelion> a -> a preferably
01:53:38 <ClaudiusMaximus> foo :: a -> a  and add a deprecation pragma ?
01:53:44 <ClaudiusMaximus> foo = undefined
01:53:51 <ClaudiusMaximus> or foo = id
01:55:43 <timthelion> ClaudiusMaximus: will look up deprecation pragmas
01:57:07 <timthelion> Ideally, I'd have GHC generate a nicely formatted TODO list for me, Including line numbers and such
02:06:22 <latro`a> silly question: pros and cons of Map k vs. Array k, where k is Ix?
02:06:33 <latro`a> and where the range is known in advance?
02:06:57 <latro`a> as far as I understand Map updates faster while Array looks up faster
02:08:42 <latro`a> but I may be mistaken about that too, actually
02:08:58 <latro`a> depends on the size of the update relative to the size of the array, in the former case
02:16:03 <shachaf> They're very different. "x is faster" doesn't really capture it.
02:18:09 <Saizan> it's true that bulk updates make more sense for Array, since you have to create a fresh one anyway
02:32:12 <nand`> latro`a: Map k can be sparse
02:32:27 <nand`> consider Map.fromList [(0, "foo"), (1000000000000000, "bar")]
02:33:30 <latro`a> there is that advantage
02:33:40 <latro`a> I'm not sure how much that advantage adds up for my application
02:33:48 <latro`a> I'm dealing with scrabble boards
02:34:07 <latro`a> so the type in question is (currently) Array (Int,Int) (Maybe Char)
02:34:36 <latro`a> initially you have a whole array of Nothing, then it fills in; by the end of the game it's about 40% filled
02:34:58 <latro`a> what I think would be somewhat slow in the Map setting would be the full search
02:35:05 <latro`a> that is necessary to show the whole thing each turn
02:35:55 <latro`a> since lookup is O(logn) each you're looking at O(n^2 log(n^2)) to print the board
02:36:11 <nand`> why are you looking up every element to just print the whole thing?
02:36:21 <nand`> wouldn't it make much more sense to do a traversal, O(n)?
02:36:30 <latro`a> um
02:36:39 <latro`a> you have to look it up because you're showing it as a rectangular array
02:36:43 <latro`a> a hole has to show up in the output
02:36:57 <bitonic> latro`a: how wide is this scrabble board?
02:37:05 <latro`a> variable size
02:37:26 <bitonic> latro`a: my guess is that lists will serve your needs.
02:37:35 <bitonic> and are much simpler to use
02:37:41 <latro`a> lists would be awkward to even use in this setting
02:37:48 <latro`a> keep in mind that I already have code written that uses Array
02:37:55 <bitonic> latro`a: why?
02:38:03 <latro`a> why would they be awkward?
02:38:06 <bitonic> yes
02:38:08 <latro`a> because indexing is clunky
02:38:14 <shachaf> Hah, "O(log(n^2))"
02:38:20 <latro`a> yes yes, but you know what I meant
02:38:29 <bitonic> latro`a: it doesn't matter
02:38:51 <bitonic> 1) the board is going to be small 2) you're programming a scrabble thing.
02:39:01 <bitonic> performance is not your concern
02:39:13 <latro`a> as I said, the Array code is already here, and transforming it to list code would be nontrivial
02:39:22 <bitonic> OK, OK. just sayin.
02:39:28 <bitonic> Array is kinda ugly.
02:39:32 <latro`a> I'd either have [[a]] and have double !!, or I'd have [a] and have to pick a convention of column major/row major
02:39:34 <shachaf> latro`a: The lesson to learn is to make your data type abstract enough that you don't need to worry about it. :-)
02:39:42 <shachaf> ((Char,Char,Char,Char,Char,Char,Char,Char),(Char,Char,Char,Char,Char,Char,Char,Char),(Char,Char,Char,Char,Char,Char,Char,Char),(Char,Char,Char,Char,Char,Char,Char,Char),(Char,Char,Char,Char,Char,Char,Char,Char),(Char,Char,Char,Char,Char,Char,Char,Char),(Char,Char,Char,Char,Char,Char,Char,Char),(Char,Char,Char,Char,Char,Char,Char,Char))
02:39:51 <shachaf> ☝ best data type
02:39:54 <latro`a> oh dear
02:40:01 <bitonic> nice unicode hand
02:40:38 <latro`a> that said, even with abstraction something has to be concrete for the thing to run :p
02:40:58 <latro`a> not necessarily visibly concrete
02:41:01 <latro`a> but concrete internally
02:41:29 <latro`a> anyway, the short version seems to be that Map would be slow to print the board but under reasonable circumstances faster to update the board
02:41:43 <latro`a> where "slow" is still fast, but slower than Array
02:41:45 <nand`> latro`a: due to the way the Ord instance on (a, b) is defined, iterating a Map (a, b) v will iterate each ‘snd’ coordinate in between ‘fst’ coordinates
02:41:49 <mcstar> i dont think it would be slow to show
02:42:07 <shachaf> latro`a: If rewriting your code from Array to [] is a lot of trouble, you probably should add more abstraction. :-)
02:42:14 <nand`> so if you flip x and y, indexing (y, x) instead; this will get you the order you need to print it row-wise
02:42:18 <shachaf> latro`a: Why do you care about "slow to print the board"?
02:42:29 <latro`a> the board gets printed every turn?
02:42:31 <shachaf> (Oh, wait, Scrabble isn't 8×8.)
02:42:36 <shachaf> latro`a: How often do turns happen?
02:42:38 <nand`> printing spaces are no problem, just use some extra logic to see if the iterated coordinate has a ‘skip’ and if so print that many spaces
02:42:42 <nand`> this will still be O(n)
02:42:52 <latro`a> depends how fast the person puts it in
02:42:53 <latro`a> also
02:42:53 <latro`a> what
02:42:56 <latro`a> @ nand`
02:43:05 <shachaf> Are you running on a 1KHz CPU or something?
02:43:15 <latro`a> I know it's not *actually* gonna be slow
02:43:20 <latro`a> I'm not concerned about it actually being slow
02:43:27 <mcstar> haha, its gonna be a game for a hairdryer
02:43:31 <shachaf> OK, so use "anything at all".
02:43:33 <latro`a> I'd just like to learn some things as I work on this
02:43:50 <latro`a> the point of it is not to have a scrabble program at the end but to learn some stuff on the way
02:43:53 <shachaf> latro`a: You're best off learnign some things not working on contrived problems.
02:44:04 <shachaf> Because the answers to your questions depend very much on what you're actually doing.
02:44:19 <latro`a> fair enough
02:44:22 <shachaf> Here, the answer is "it doesn't matter one bit, so use whichever type is nicest to program with".
02:44:33 <mcstar> id say learning how to use a map is more like learning something, than using an array
02:44:43 <mcstar> you used arrays probably in other languages
02:44:52 <mcstar> why dont give map a try in haskell, if its natural?
02:44:53 <shachaf> Probably not Haskell-style arrays.
02:45:05 <latro`a> I know the main utilities of Map, but I wouldn't know how to do what nand` said
02:45:20 <mcstar> traversing the map?
02:45:28 <latro`a> traversing and inserting spaces based on skips
02:45:29 <mcstar> a map is foldable i guess
02:45:39 <mcstar> so you dont need to do anything fancy
02:45:47 <mcstar> f, i meant traversable
02:45:47 <shachaf> What nand` said sounds like a weird case-specific optimization.
02:46:14 <latro`a> agreed, shachaf
02:46:26 <shachaf> Since your case is "it doesn't matter", it doesn't matter. :-)
02:46:29 <shachaf> latro`a: Note that Maps are stored in memory as a sorted tree. Getting the contents of a Map in order is just traversing that tree.
02:46:49 <shachaf> But you really oughtn't be saying things like "O(log(n^2))". :-)
02:46:59 <latro`a> I know where the 2 goes
02:47:04 <latro`a> I'm a mathematician more than a programmer
02:47:20 <mcstar> O(log(n))^2 ifc
02:47:21 <latro`a> it was "mlogm where m = n^2"
02:47:23 <mcstar> ofc*
02:47:34 <latro`a> no >.>
02:47:37 <shachaf> So why are you caring about performance?
02:47:46 <shachaf> log(n^2)^O
02:48:00 <latro`a> mostly just for the future really
02:48:10 <latro`a> obviously this one application would be rather hard to make slow
02:48:38 <mcstar> i have to look up scrabble
02:48:44 <mcstar> dont really know what that is
02:49:32 <mcstar> ah ok, youve got to make intelligable words from letters
02:49:50 * mcstar thought that was called scribble
03:02:29 <moodie> Is there a function like "unwords" but without inserting sperate spaces?
03:02:57 <solrize> > concat ["foo","bar","baz"]
03:02:58 <lambdabot>   "foobarbaz"
03:03:22 <moodie> thanks =)
03:03:22 <solrize> > unwords ["foo","bar","baz"]
03:03:23 <lambdabot>   "foo bar baz"
03:04:04 <solrize> > concatMap reverse ["foo","bar","baz"]
03:04:09 <lambdabot>   "oofrabzab"
03:05:21 <hpaste> nand` pasted “Scrabble proof of concept with O(n) printing” at http://hpaste.org/71879
03:06:16 <venom00ut> hello, could someone tell me why this piece of code has qudratic time complexity? (given f is O(1))
03:06:17 <venom00ut> let { revmap f (x:xs) = (revmap f xs) ++ [(f x)]; revmap f [] = []; }
03:06:33 <nand`> come to think of it, line 18 would be better rewritten as putStr $ replicate (y' - y) '\n'
03:06:45 <hpaste> mcstar pasted “map printing concept” at http://hpaste.org/71880
03:07:38 <solrize> venom00ut, ++ has to linearly scan through the list
03:07:52 <mcstar> nand`: oh, beat me to it
03:08:19 <solrize> why not  revmap f = map f . reverse
03:08:35 <nand`> mcstar: your approach is interesting as well, unioning with an ‘empty’ map
03:08:42 <shachaf> venom00ut: Is this homework? :-)
03:08:46 <venom00ut> solrize, too easy :)
03:08:48 <venom00ut> shachaf, yep
03:08:51 <solrize> oh oops :)
03:08:53 <Algorith> whenever you intensively rely on append you might want to consider using something like a difference list
03:09:09 <shachaf> venom00ut: You should probably mention that when you ask questions like this in general. :-)
03:09:34 <venom00ut> what would be a nice solution? the professor proposed: revmap f = foldl' (\x -> \y -> (f y) : x) []
03:09:41 <venom00ut> shachaf, OK, I'll do it next time ;)
03:09:44 <shachaf> Algorith: In this case the answer is probably just to write reverse the standard way.
03:09:49 <Algorith> true
03:09:53 <shachaf> venom00ut: That works.
03:10:01 <shachaf> venom00ut: "nice solution" is what solrize said.
03:10:06 <shachaf> Keep in mind that reverse is:
03:10:07 <venom00ut> shachaf, OK, but something more similar to my approach?
03:10:10 <shachaf> @src reverse
03:10:10 <lambdabot> reverse = foldl (flip (:)) []
03:10:30 <shachaf> venom00ut: You've proposed two good approaches. What are you looking for?
03:10:41 <shachaf> Er, solrize proposed one of them.
03:10:52 <solrize> venom00ut, do you know about accumulating parameters?
03:10:53 <latro`a> interesting, mcstar/nand`
03:10:59 <shachaf> "too easy" is not a criterion we accept here.
03:11:05 <shachaf> venom00ut: Do you know how foldl works?
03:11:07 <venom00ut> OK, my solution can't be improved then
03:11:31 <shachaf> Not without saying what you don't like about it.
03:11:34 <venom00ut> shachaf, yes, I was just wondering if my solution can be improved to have linear time complexity
03:12:09 <shachaf> venom00ut: Yes -- two ways to do that have already been named. :-)
03:12:27 <venom00ut> OK, got it :P
03:12:32 <shachaf> What counts as "improving your solution" as opposed to "writing a new one"?
03:12:38 <shachaf> You can use an accumulator instead of the ++[x] thing.
03:12:44 <shachaf> Which is what foldl does.
03:13:19 <solrize> venom00ut, how would you add up the numbers from 1 to 100, without using some built-in like sum or foldl?
03:13:55 <venom00ut> solrize, how is that related with revmap?
03:14:10 <shachaf> solrize: It's related.
03:14:16 <shachaf> s/solrize/venom00ut/
03:14:26 <venom00ut> I didn't say it isn't, I asked how :P
03:14:27 <solrize> venom00ut, there's a trick that's the same one you'd use for revmap
03:14:41 <nand`> latro`a: the example I pasted earlier is bugged, line 21 should have the ‘then’ and ‘else’ branches swapped
03:15:10 <shachaf> venom00ut: You should answer the question. :-) You might figure it out.
03:16:23 <nand`> solrize: easy, I would write the “5050” literal :P
03:16:36 <venom00ut> :D
03:16:49 <hpaste> latro`a pasted “Always prints the exception?” at http://hpaste.org/71881
03:17:24 <latro`a> ^for whatever reason this will always print the exception in doubleCheck
03:17:28 <latro`a> and will not if I remove the getChar
03:17:37 <latro`a> maybe I'm missing something obvious
03:17:40 <merijn> Speaking of linear complexity won't "map f . reverse" end up being linear anyway?
03:18:23 <merijn> (Well I guess it's linear anyway, because we ignore constants in big O notation. But I meant traversing only once)
03:18:41 <latro`a> (in my real example, the getChar actually does some other stuff, but even if I delete that other stuff I get this issue)
03:18:47 <shachaf> latro`a: Does that even type-check?
03:19:10 <mcstar> that doesnt make sense
03:19:13 <latro`a> I think, I just hacked it together to show the point
03:19:16 <mcstar> getChar and after that a getLine
03:19:33 <mcstar> drop the getChar
03:19:40 <latro`a> I can't in my actual program
03:19:46 <mcstar> why?
03:19:52 <latro`a> it's a separate prompt
03:19:52 <mcstar> why not 2 getLines?
03:19:55 <shachaf> latro`a: reads gives you [(a,String)]
03:19:58 <nand`> latro`a: line 7 should be [(d, [])]
03:20:00 <shachaf> mcstar: 03:18 <latro`a> (in my real example, the getChar actually does some other stuff, but even if I delete that other stuff I get this issue)
03:20:02 <latro`a> erm
03:20:03 <latro`a> my bad
03:20:07 <latro`a> meant to have a []
03:20:12 <latro`a> around the (d,[])
03:20:31 <latro`a> tired (that problem isn't in the real code)
03:20:36 <shachaf> latro`a: Anyway, just stick a «doubleCheck x = print x >> ...» and see what's going wrong for yourself.
03:20:55 <shachaf> Well, I guess it's probably going to be []. :-)
03:20:59 <nand`> latro`a: works fine for me
03:21:00 <latro`a> oh wait I see
03:21:04 <latro`a> I think?
03:21:15 <latro`a> or maybe not if nand` gets it to work
03:21:29 <shachaf> latro`a: Instead of nand` getting your snippet to work, why don't you? :-)
03:21:48 <latro`a> uh
03:21:53 <hpaste> nand` annotated “Always prints the exception?” with “Always prints the exception? (annotation)” at http://hpaste.org/71881#a71882
03:21:55 <latro`a> I meant that I'm confused that it worked for him
03:22:24 <latro`a> that is with the getChar dropped
03:22:28 <latro`a> but I think I may see the problem?
03:22:37 <shachaf> latro`a: Right, so it'll make people's life much easier if you get a proof-of-concept that they can run.
03:22:52 <latro`a> somehow the char that getChar requests gets slipped into the line that getLine takes in
03:23:10 <nand`> latro`a: oh, I got mixed up: I thought it was working fine *with* the getChar but not working without it
03:23:19 <latro`a> oh no, definitely not
03:23:22 <latro`a> but is that what happens?
03:23:26 <latro`a> that seems counterintuitive as hell
03:23:48 <mcstar> how do you enter the number?
03:23:49 <hpaste> nand` annotated “Always prints the exception?” with “Always prints the exception? (annotation) (annotation)” at http://hpaste.org/71881#a71883
03:23:52 <nand`> still works fine
03:23:54 <mcstar> $3.45
03:23:56 <latro`a> the number takes it fine
03:23:59 <latro`a> er
03:24:01 <latro`a> is taken in fine
03:24:06 <latro`a> but before I type anything to put in the number
03:24:13 <latro`a> it says "You must enter a floating point number."
03:24:59 <mcstar> well, you have to
03:25:05 <mcstar> so its correct XD
03:25:12 <shachaf> You should write an example program that actually works/breaks, and then say "run it with this to make it work, run it with that to make it break", or something.
03:25:20 <shachaf> I think everyone including you is getting confused right now. :-)
03:25:40 * nand` has a creeping suspicion this might just have to do something with windows using \r\n for newlines and thus getChar only eating \r
03:25:42 <mcstar> the program prints the error message before it is given input?
03:25:48 <latro`a> linux machine, nand`
03:25:49 <latro`a> and yes
03:25:51 <latro`a> it does
03:25:57 <latro`a> or at least before I think it is getting input
03:26:02 <shachaf> nand`: Unlikely.
03:26:12 * shachaf sighs.
03:26:18 <latro`a> similar things happen with sequences of getChar, apparently
03:26:30 <shachaf> Debugging-over-IRC is even worse than debugging-over-serial-cable.
03:27:00 <latro`a> I suspect if I just turn these into getLines and work with one-character strings the problem will go away
03:27:02 <mcstar> one-to-many debgging is fun
03:27:10 <shachaf> Good luck.
03:27:23 <nand`> mcstar: better than many-to-many?
03:27:38 <mcstar> never went that far..
03:27:47 <latro`a> goes away
03:27:59 <latro`a> maybe my terminal is doing silly things?
03:28:09 * nand` imagines that what #haskell is in the grand scheme of things
03:28:11 <mcstar> well, do as schlumpi says
03:28:16 <mcstar> erm
03:28:19 <mcstar> shachaf
03:28:45 <shachaf> In the grand scheme of things, #haskell is a stupid waste of time.
03:28:51 <shachaf> I don't know why I even go there. :-(
03:28:56 <mcstar> shachaf: no, thats haskell-blah
03:29:13 <hpaste> latro`a pasted “No Leak” at http://hpaste.org/71884
03:29:35 <timthelion> nand`: please don't!!!  Thinking about the grand scheme of things can cause bodly harm and or property damage!!!
03:29:36 <hpaste> latro`a annotated “No Leak” with “Leak” at http://hpaste.org/71884#a71885
03:29:47 <latro`a> that's the function I'm calling
03:29:52 <shachaf> latro`a: Oh. It's the newlines.
03:30:01 <shachaf> Why didn't you just say so?
03:30:16 <latro`a> mmk
03:30:18 <latro`a> thanks then
03:30:24 <shachaf> All solved?
03:30:28 <latro`a> yeah
03:30:32 <latro`a> ty
03:33:18 <nand`> the second version works fine for me too
03:33:23 * nand` is puzzled over what the actual problem was
03:33:44 <latro`a> somehow or another it looks like my newlines from the getChar were bleeding over into the getLine
03:33:53 <latro`a> I'm not actually sure how this happens
03:34:11 <nand`> what newlines from getChar? getChar just gets a single
03:34:16 <nand`> it doesn't wait for a newline
03:34:24 <nand`> just gets a single character*
03:34:28 <latro`a> that's what I expected it would do originally
03:34:31 <nand`> oh
03:34:33 <latro`a> but oddly it waits for me to press enter
03:34:40 <latro`a> and that presumably is the problem
03:34:54 <nand`> doesn't for me
03:34:58 <shachaf> @google buffering
03:34:59 <lambdabot> http://en.wikipedia.org/wiki/Data_buffer
03:34:59 <lambdabot> Title: Data buffer - Wikipedia, the free encyclopedia
03:35:05 <shachaf> @google buffering terminal
03:35:06 <lambdabot> http://www.pixelbeat.org/programming/stdio_buffering/
03:35:06 <lambdabot> Title: stdio buffering
03:35:10 <shachaf> Something like that.
03:35:16 <nand`> that would explain it
03:36:33 <mcstar> buffering
03:36:55 <mcstar> thats why i said originally to use 2 getLines
03:37:16 <shachaf> The solution isn't "use 2 getLines", it's "understand buffering". :-)
03:37:23 <shachaf> Alternatively, turn buffering off.
03:37:45 <nand`> also ‘understand getChar’, which would have provided hints that buffering is the problem
03:37:50 <latro`a> so it's my terminal being silly-ish
03:37:54 <mcstar> no
03:37:59 <latro`a> eh, not silly, doing what it's told
03:38:12 <latro`a> but what it's told not being what I was expecting
03:38:22 <mcstar> theres a word for that
03:38:52 <mcstar> 'the programmer havent had enough coffee'
03:38:57 <mcstar> quite a long word
03:40:39 <latro`a> probably true
03:40:41 <latro`a> up way too late
03:41:27 <mcstar> i should have some too, my physics isnt working out :(
03:43:21 <ksf> I have 12 Maybe Foo fields in a record, should I convert them to something else?
03:43:51 <ksf> like a list. the problem is, it's not a real copy of the semantics.
03:44:07 <ksf> ordering I don't care about, but duplicates.
03:56:09 <ksf> what do you guys think of http://hackage.haskell.org/package/records ?
03:59:49 <mcstar> cesc: when i decrease the temperature, my fluctuations increase, not a good sign, right? :)
04:14:35 <cesc> mcstar: there's something rotten in Denmark =)
04:14:50 <mcstar> hang on, i have to share something
04:16:41 <mcstar> cesc: http://i.imgur.com/wsxj5.png the length scale is wrong, clearly, but it seems im getting at a hexagonal pattern, which is a solution to the model for a parameter set
04:17:45 <mcstar> got there from there: http://i.imgur.com/Fi3Td.png
04:17:47 <cesc> mcstar: is this your C++ or your haskell code?
04:17:55 <mcstar> c++ ofc
04:17:56 <cesc> huh, nice
04:23:05 <augur> whoa mcstar
04:23:07 <augur> easy there
04:23:24 <augur> some of us have eyeballs you realize
04:23:32 <mcstar> sorry
04:23:36 <augur> :P
04:23:47 <mcstar> (not sure why, but i am)
04:57:12 <nand`> I blame Haskell for making me consider ‘laziness’ as something positive
04:59:45 <Philippa> nand`: yeah? Larry Wall got to me too late already on that one
05:00:05 <Philippa> (and I have a lot more time for Wall than I do for perl: I know that perl was never For Me)
05:01:09 <confusing> perl? doesn't have a nice type system with a lot of inference. next!
05:01:15 <confusing> ;)
05:06:40 <ocharles> nand`: laziness is important for a programmer outside the language too. I hate repeating code, so i'm lazy and make it so I have to write it once
05:06:45 <ocharles> and thus my code is dry-er :)
05:13:28 <nand`> ocharles: exactly. I consider laziness to be a good philosophy when it comes to other things too, for example software development: I'll only develop software that has a purpose / need for it; instead of proactively developing something and then trying to sell it afterwards
05:13:39 <ocharles> indeed
05:13:47 <ocharles> and YAGNI also applies
05:14:50 <nand`> also “don't fix what isn't broken”
05:26:20 <fuchsto> What's the way to go for transforming a ByteString (from which i know it's S32 Floats) to a IOUArray Int Float? I'm a bit lost.
05:26:26 <venom00ut> ?src length
05:26:26 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:26:47 <venom00ut> is there something similar to ?src in ghci?
05:26:56 <srhb> venom00ut: No.
05:27:11 <srhb> venom00ut: But it's quick and easy to go to hoogle and look up the source. :)
05:28:28 <Botje> fuchsto: you could use Data.Binary, no?
05:29:06 <confusing> venom00ut: check the haddocks on hackage. there's "source" links on the right hand side for every function
05:31:44 <Botje> fuchsto: if you know up front how many floats there will be, runGet (replicateM n get) bs :: [Float]
05:33:20 <confusing> here's a bit of a puzzle: how can this file compile? note e.g. the missing indentation in line 26 http://hpaste.org/71886
05:34:18 <confusing> it seems to have DOS line endings (crlf), but apart from that, there seem to be nothing like hidden funky unicode characters
05:34:28 <confusing> seems*
05:34:48 <ocharles> @pl const (cost 5)
05:34:48 <lambdabot> const (cost 5)
05:34:59 <ocharles> @pl \n -> const (const n)
05:34:59 <lambdabot> const . const
05:35:03 <ocharles> duh
05:35:53 <mcstar> confusing: what do you mean 'missing indentation'?
05:36:10 <mcstar> why would you indent main?
05:37:08 <confusing> sorry, i don't mean 26. i mean 27-29. also 47
05:37:50 <mcstar> i dont see a problem, neither does the compiler
05:38:36 <mcstar> the 'do' block would end, if a line would start a bit to the right, from the beginnning of the 'do' block
05:38:56 <mcstar> now the do block ends with where
05:39:07 <confusing> mcstar: don't you normally say "main = do" and in the next line continue with indentation?
05:39:29 <mcstar> since emacs does that, so do i
05:39:35 <mcstar> but thats not necessery
05:40:01 <mcstar> omg, i again interchanged left/right
05:40:17 <mcstar> confusing: the 'do' block would end, if a line would start a bit to the left, from the beginnning of the 'do' block
05:40:52 <mcstar> in the last week, i interchanged left/right 2 times in real life conversation
05:42:25 <mcstar> confusing: if im correct, you could start the definitions after 'where' from the leftmost too
05:43:04 <srhb> confusing: But stylistically I would agree they should be indented to make the relationship with main clear when skimming.
05:43:27 <srhb> skimming? Scanning
05:43:32 * srhb has English issues
05:44:43 <mcstar> interesting
05:44:59 <mcstar> without the 'where' clause, the 'do' block couldnt end
05:45:13 <mcstar> thereby making other top level definitions syntactically invalid
05:45:37 <srhb> Indeed.
05:45:40 <mcstar> so in this regard, while it compiles, i dont consider it correct
05:45:50 <srhb> Well, it can end if it goes to EOF
05:45:57 <mcstar> yes
05:46:06 <mcstar> but thats not what anyone would want, right?
05:46:15 <srhb> No, I agree, it should be indented for several reasons.
05:47:08 <srhb> It is also a little weird that all the remaining definitions are in the where block
05:47:37 <srhb> "But everything is run from main!" :-)
05:48:48 <mcstar> it is possible that the author was limited by what i said above, and thats why he/she put everything in the 'where' clause
05:49:03 <confusing> srhb: yeah, folks uploaded various example xmonad config files like that. i don't think it's great either
05:49:27 <srhb> mcstar: That is probably what happened. "hmm, nothing works, except if I put a where clause here"
05:50:25 <mcstar> indubitably, my dear watson
05:50:44 <confusing> honestly, i don't know how you guys can be so calm about it. to me that's either a ghc bug or very bad style
05:51:15 * mcstar is a zen master
05:51:48 <mcstar> honestly, i dont care :)
05:52:36 <hpaste> timthelion pasted “almost haskell but not quite” at http://hpaste.org/71888
05:53:00 <mcstar> confusing: ok, one thing that annoys me:
05:53:08 <mcstar> { recordfield = some
05:53:12 <mcstar> , someother =
05:53:15 <timthelion> :( Is there a way to customise the syntax that haskell-src-ext recognises?  I am parsing a file that has almost the same syntax as haskell but not quitt
05:53:18 <timthelion> e
05:53:52 <timthelion> (I then transform it into actual haskell...
05:54:32 <timthelion> I *just* need it to recognise << as being the same as =
05:55:00 <byorgey> timthelion: not that I know of
05:55:12 <confusing> timthelion: i guess you could do "cabal unpack haskell-src-ext" and hack around there :-/
05:55:30 <timthelion> :(
05:55:57 <Taneb> Hello
05:56:09 <timthelion> hi
05:56:32 <Taneb> What's the extension that lets you do class Foo a b | a -> b?
05:57:41 <hpc> Taneb: functional dependencies
05:57:48 <Taneb> Thanks
05:58:06 <dzhus> is there any existing solution to measure time spent from the beginning of program run?
05:58:36 <timthelion> dzhus: time?
05:59:08 <timthelion> dzhus: it's a unix command
05:59:15 <confusing> dzhus: the "time" command line utility? other than that, ghc profiling. or you could always insert code that does that, it'll be only a few lines i'd venture
06:00:21 <confusing> (that reminds me) are profiling libraries slower than regular ones? or is there some other downside?
06:00:38 <mcstar> http://sprunge.us/VbGX
06:00:46 <mcstar> dzhus: ^^
06:00:56 <mcstar> import System.CPUTime
06:01:00 <timthelion> confusing: slower, but mainly much larger binary size
06:01:54 <mcstar> it is sometimes tricky to time something in haskell
06:02:14 <mcstar> you have to make sure everything gets evaluated that youre interested in
06:02:50 <augur> ski: http://wellnowwhat.net/Programming/SeqCalcNotes.pdf
06:03:17 <ocharles> is there a better URI type that is easier to manipulate? Network.URI doesn't let me easily add query parameters, without doing uriQuery ++ "&myParam=" escapeEtc...
06:03:19 <ocharles> and that's so buggy
06:03:34 <ocharles> (for example, that's invalid if uriQuery == "")
06:03:57 <silver> mcstar, how does getCPUTime work in threads?
06:04:15 <silver> is is the sum of spent time?
06:04:19 <silver> is it*
06:04:29 <hpc> ocharles: define your own (?), (&), (=:)
06:04:53 <ocharles> hmm, the url package looks like it should do the job
06:05:21 <mcstar> silver: probably
06:05:27 <hpc> with precedences so they parse as (uri expr) ? (((param one) =: (value)) & (param two) =: (value)))
06:05:30 <hpc> or something like that
06:05:40 <mikeplus64> in a record will writing fieldName :: {-# UNPACK #-} unpackable-type-here unpack the value?
06:05:43 <mcstar> i myself never used it in multithreaded context
06:06:23 <dzhus> mcstar: thanks, seems like that's what I need.
06:06:29 <ocharles> hpc: this seems so basic i would have thought someone else would have done it
06:06:41 <ocharles> hpc: that's a nice interface though, sure
06:07:07 <dzhus> I need to measure time between consecutive steps of my program in runtime, thus unix `time` is ruled out. profiling is useless when you use vector.
06:07:13 <confusing> ocharles: in my opinion the internet is a newfangle fad that will soon pass
06:07:23 <ocharles> confusing: i hope not, that's my career!
06:07:49 <mcstar> dzhus: the vector package?
06:08:06 <roconnor> What are the constraints on o required for ((,) o) to be Applicative?
06:08:20 <mcstar> and why? does profiling change the proportions of time spent?
06:09:02 <dzhus> mcstar: yes, by order of magnitude or more.
06:09:26 <mcstar> dzhus: im asking about proportions, not absolute time
06:10:53 <mcstar> ofc the real question is, why do you need to measure pieces
06:11:57 <hpc> dzhus: criterion?
06:12:13 <twanvl> roconnor: I would expect Monoid o, just like for the Monad instance
06:13:06 <patzo> does anyone have an implementation of a shortest-path algorithm I can reference? Hopefully taking something like [(String, String, Int)] as a graph structure?
06:13:27 <patzo> I found a couple but they all seem to have weird bugs
06:13:41 <Botje> did you try fgl?
06:14:05 <Botje> oh, data.Graph is in containers now, nice.
06:14:56 <patzo> hrm, i'll have a squizzie thanks
06:16:00 <Qtr> Can someone explain how to use magic squares to see if there is a winner ina tictactoe game?
06:18:01 <hpc> Qtr: it's not hard to enumerate a 3x3 of tic-tac-toe
06:18:10 <hpc> and use that table to look up winners
06:18:14 <twanvl_> Qtr: my solution would be: you take a magic square and a tic-tac-toe board. Then you completely ignore the magic square, and check for the winner of the board :)
06:18:43 <luite> Qtr: there's a 3x3 magic square where every row, column and diagonal adds up to 15. you just replace the pieces of a player by their value in the magic square and see if any subset of 3 pieces adds up to 15
06:18:48 <patzo> bummer - all this time i was getting confused between directed and undirected graph -_- must be nearing bed time
06:20:10 <patzo> i don't think haskell is forgiving to drunk and/or sleepy coders
06:21:28 <LambdaDusk> I am looking for someone with some Yampa/Animas experience for some specialised questions =/
06:21:29 <hpc> it's not so bad
06:21:47 <hpc> the less able to code you are, the less likely your code is to compile
06:21:54 <Qtr> well right now im only checking the 8 rows/columns/diagonals i need to
06:23:54 <Qtr> wtf something deleted my .emacs
06:23:57 <Qtr> damn you heroku!
06:27:21 <LambdaDusk> qtr: They merely want to encourage the use of a real editor
06:28:00 <mcstar> 'add insult to injury'
06:29:13 <LambdaDusk> my speciality
06:34:38 <fuchsto> What's the way to go for transforming a ByteString (from which i know it's S32 Floats) to a IOUArray Int Float? I'm a bit lost.
06:36:25 <dzhus> can I turn off state hack on per-file basis?
06:36:29 <hpc> fuchsto: i can think of a horrible way to do it
06:36:32 <hpc> @src ByteString
06:36:32 <lambdabot> Source not found. Do you think like you type?
06:36:59 <Qtr> haskell platform doesnt ship haskell mode?
06:36:59 <hpc> fuchsto: horrible way is to look up the sources for ByteString and IOUArray, and see if unsafeCoerce will work
06:37:48 <hpc> i don't know exactly what i would do to convert it the right way
06:38:05 <Botje> fuchsto: you didn't see my earlier advice?
06:38:10 <Botje> fuchsto: if you know up front how many floats there will be, runGet (replicateM n get) bs :: [Float]
06:38:46 <luite> fuchsto: slightly less horrible might be to use storable vectors instead ( Data.Vector.Storable in vector for example )
06:58:32 <Qtr> (load "C:/PROGRA~2/Haskell~1/haskell-mode-2.8.0/haskell-mode")
06:58:37 <Qtr> what should thay be?
07:03:20 <Qtr> how do i make emacs turn haskell-mode on when opening a .hs/.lhs.cabal file?
07:03:25 <dzhus> Can I somehow specify compiler flags with Cabal in per-file basis?
07:03:49 <dzhus> Qtr: (add-to-list 'auto-mode-alist '("\\.hs$" . haskell-mode))
07:04:01 <dzhus> Qtr: but I think this should already be included with haskell-mode
07:05:20 <mcstar> yep
07:05:49 <mcstar> haskell-site-file.el
07:05:53 <mcstar> load that
07:05:54 <Qtr> (setq haskell-program-name "C:/PROGRA~2/Haskell Platform/2011.4.0.0/bin/ghci.exe")
07:06:03 <Qtr> interpreter doesnt start
07:06:09 <Qtr> im using somthing form 2010
07:06:16 <Qtr> should use the github i guess
07:11:52 <newbiehaskeller> I am trying to find the source code of the function IODevice.write but I can't. Any help please?
07:12:34 <hiptobecubic> Has there been any effort to unify all of these different RNG interfaces?
07:13:04 <hiptobecubic> newbiehaskeller, http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-IO-Device.html#write
07:14:04 <newbiehaskeller> hiptobecubic this is GHC.IO.Device not IODevice
07:15:01 <confusing> newbiehaskeller: what are you trying to do?
07:16:52 <newbiehaskeller> confusing: I want to understand how Haskell convert monadic I/O to code. For example putStrLn I found that is transformed in Windows code using _write C function. But I can not find the glue between Haskell and low level code.
07:17:12 <hiptobecubic> newbiehaskeller, iodevice is a class
07:17:27 <hiptobecubic> newbiehaskeller, ah
07:17:57 <newbiehaskeller> hiptobecubic: iodevice class does not support write method
07:19:14 <mcstar> i think thats a misguided attempt
07:19:29 <newbiehaskeller> why?
07:21:09 <jmcarthur> newbiehaskeller: what is IODevice and how is it not the same as GHC.IO.Device?
07:21:48 <newbiehaskeller> jmcarthur: That is my question.
07:21:51 <confusing> newbiehaskeller: you certainly don't need to understand that kind of thing to successfully use haskell. i'm also sure that this knowledge won't help you much learning haskell. but if you really are interested, i think you'd also need to look at the RTS (runtime system) and the io manager
07:21:55 <jmcarthur> newbiehaskeller: oh
07:22:12 <jmcarthur> newbiehaskeller: GHC.IO.Device.IODevice is a type class. it can be implemented in many different ways
07:22:44 <jmcarthur> newbiehaskeller: so in order to know how it works, you have to know the specific type you are using it for
07:23:10 <jmcarthur> newbiehaskeller: and find the instance that implements the IODevice interface for that type
07:24:09 <jmcarthur> also, it looks like RawIO has the write method, not IODevice
07:24:10 <newbiehaskeller> jmcarthur I have found in line 117 of BufferedIO.hs in libraries\base\ghc\io in function writeBuf the use of the function IODevice.write but I can not find this function's source code.
07:24:23 <jmcarthur> newbiehaskeller: for what type is it being used?
07:24:46 <newbiehaskeller> RawIO dev
07:25:27 <jmcarthur> newbiehaskeller: i just found the code. RawIO dev is a constraint, not a type. dev is a polymorphic type. basially what this means is that there is no concrete implementation of write being used here
07:25:54 <confusing> newbiehaskeller: you said earlier you're investigating putStrLn. what about putStrLn is confusing you?
07:25:55 <jmcarthur> newbiehaskeller: so in order to know what it will do you have to look further up, where writeBuf is being used in your particular example
07:26:09 <newbiehaskeller> I give the whole type again: writeBuf :: RawIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)
07:26:20 <jmcarthur> newbiehaskeller: as i just said, dev is not a concrete type
07:26:36 <aristid> the whole classyprelude kerfuffle seems to bring out the worst in some haskellers :/ statements like "That's why I don't use any of your libraries" are just not sensible IMHO
07:26:48 <jmcarthur> newbiehaskeller: there is no implementation to find by looking at a lower level. you have to look at the call site instead
07:27:15 <confusing> aristid: where is the kerfuffle?
07:27:21 <jmcarthur> aristid: agreed. it seems to have been an oddly violent reaction
07:27:27 <aristid> confusing: like here http://www.reddit.com/r/haskell/comments/wn882/clarification_classy_prelude/
07:27:40 <ski> jmcarthur : "dev is a polymorphic type" ?
07:27:41 <confusing> aristid: oh, reddit ...
07:27:42 <aristid> jmcarthur: i don't like the classyprelude myself, but this is an overreaction
07:27:47 <augur> hey ski
07:27:53 <aristid> confusing: also on other communication avenues
07:28:18 <hiptobecubic> I want to profile something, but it wants profiling libraries. If i cabal -p install thelibrary, it says it's "probably" going to break 500 other packages. Is there a way to add profiling libraries without ruining everything?
07:28:24 <jmcarthur> ski: i guess i should have called it a type variable
07:28:29 <ski> yeh augur
07:28:40 <jmcarthur> hiptobecubic: i only wish i knew the answer to that
07:28:43 <mcstar> hiptobecubic: yes, before using cabal ever, add the profiling flag to the config
07:28:49 <jmcarthur> well that's one way
07:29:07 <hiptobecubic> mcstar, that doesn't add libraries. that starts from scratch.
07:29:40 <mcstar> erm
07:29:49 <mcstar> i know it doesnt help you now
07:29:49 <ski> jmcarthur : i was suspecting you were about to say `dev :: * -> *' or somesuch, in which case `dev' would be a function type (or "higher type", maybe), not a polymorphic type (like `O :: forall k0 k1. (k1 -> *) -> (k0 -> k1) -> (k0 -> *)') :)
07:29:53 <mcstar> but thats what you should have done
07:30:25 <jmcarthur> ski: ah, no, it's just a type variable of kind *
07:30:32 <ski> *nod*
07:30:33 <confusing> hiptobecubic: you might be interested in cabal-dev so you can install all the profiled stuff in a new sandboxed sandbox. erm.
07:31:10 <hiptobecubic> I really don't understand why everyone in here acts like cabal is a good tool. I swear it can't do anything that any reasonable person would expect other than irreversibly install something, once.
07:31:25 <augur> ski: did you see the link i sent you to the notes?
07:31:28 <augur> "notes"
07:31:39 <ski> augur : i saw two links, not checked them yet
07:32:29 <confusing> hiptobecubic: it's not helped either by the tendency of ghc packages being so brittle, breaking at lots of ghc updates :(
07:33:06 <jmcarthur> hiptobecubic: it at least beats most distro package managers in that i can actually have multiple versions of a package installed at once. i also think most of the problems come from limitations of ghc-pkg and such
07:33:35 <luite> what problems come from limitations of ghc-pkg?
07:33:35 <confusing> s/mangled grammar/valid grammar/
07:33:52 <augur> ski: ive basically got a nice way of turning sequent rules into diagrammatic rules, and from that getting a term language
07:33:56 <jmcarthur> i find it hard in my mental model to draw a line between cabal and ghc's own package management though
07:34:27 <augur> ski: that makes me quite happy, because it means you can do this for arbitrary sequent based inference systems :)
07:34:38 <confusing> jmcarthur: i've always thought of that as "cabal is the thing you use to get anything into the ghc package repo"
07:35:04 <jmcarthur> confusing: that seems a reasonable characterization of my own intuitions, too
07:35:13 <Saizan> one simple problem of ghc-pkg is that it doesn't support more than one installation of the same version for each package-conf
07:35:33 <luite> Saizan: really? even with a different abi hash?
07:36:04 <confusing> Saizan: ... such as an installation of both something-0.1 and something-0.1-profiling ...?
07:36:08 <Saizan> luite: yeah, unless it changed recently
07:36:31 <Saizan> confusing: no, such as foo-0.1 and foo-0.1 compiled against different dependencies
07:36:47 <luite> Saizan: hmm, that's kind of odd since this seems exactly what the abi hash was invented for
07:36:47 <confusing> yes, that too
07:36:49 <Saizan> luite: you can have one for each package-conf and you have at least 2 package-confs, global and user
07:37:31 <Saizan> confusing: profiling is considered part of the same installation as non-profiling, when you have it
07:37:57 <luite> right that is a limitation that i know of :)
07:38:36 <ski> augur : that's not `\/L'
07:39:18 <confusing> confusing: not sure. i recently tried to profile something (while all previous installed packages were non-profiling variants) and it only told me that "installing this will break 9000 packages". i resorted to cabal-dev ...
07:39:21 <jmcarthur> it would definitely be an improvement if cabal was able to install packages in a purely functional way, never having to replace an old package
07:39:22 <Saizan> as currently implemented the abi-hash spots pontential link-failures early, but yeah it could be used to solve this too
07:39:24 <augur> ski: isnt it?
07:39:39 <ski>   Gamma , A |- C   Gamma , B |- C
07:39:41 <ski>   ------------------------------- \/L
07:39:41 <jmcarthur> the ghc-pkg limitation Saizan mentioned is definitely a blocker on that
07:39:41 <ski>   Gamma , A \/ B |- C
07:39:51 <ski> is how it ought to look like
07:40:02 <augur> ski: that should be what i have
07:40:23 <ski> hm, maybe i need to pull again ..
07:40:25 <augur> ski: oh, you're right, the sequent version is wrong.
07:40:31 <augur> the graph version is correct tho :)
07:40:36 <augur> i noticed i had it wrong and went to correct it
07:40:40 <augur> but didnt fix the sequent
07:40:43 <augur> ahah :)
07:41:42 <Qtr> is jwiegley haskell mode the common used one?
07:42:07 <Saizan> confusing: if your installation of foo-0.1 doesn't include the profiling version it won't be added there, you'll get a new installation which has both non- and -profiling versions (which might overwrite the old one and cause dependent packages to break)
07:42:41 <ski> augur : shouldn't the graph version just be a dual version of `/\R' ?
07:43:13 <ski> (iow, why is `\/E' involved at all with the parasitic formula `C' in the graph ?)
07:43:37 <augur> ski: it actually is, but ive taken a notational convention that obscures the duality for readability's sake
07:44:15 <confusing> Saizan: yeah, that's what happened to me. i think it's somewhat frustrating and not the ideal behavior for cabal
07:44:35 <augur> ski: tho keep in mind that im only using intuitionistic sequents, hence it wont be perfectly dual
07:44:36 <augur> but
07:44:38 <ski> i thought part of the point of the graph notation would be to remove spurious connections between propositions and rules (thereby getting some commutations for free)
07:45:14 <ski> (augur : well, it's possible to have a multiple-conclusion intuitionistic system, iirc ..)
07:45:18 <luite> Saizan: i had to check it, but it looks like you're right :(
07:45:47 <augur> ski: no, intuitionistic logic has at most one conclusion
07:46:03 <ski> in the *usual* presentation, yes
07:46:10 <ski> necessarily, no
07:46:27 <hiptobecubic> I just don't understand how we ended up with such a broken system. The rest of the language seems so thoroughly vetted.
07:46:50 <hiptobecubic> considering ghc basically *is* haskell.
07:46:59 <augur> ski: so the way you get these graphs is you take the two input graphs, put them together, and then add a new node. you then connect all the "diff" propositions to this node in an appropriate fashion (left propositions connect to the bottom, right propositions to the top)
07:47:28 <augur> ski: because this creates a rather nasty tangle, you just split the new node into pieces
07:47:32 <venom00ut> it's hard to understand gonads
07:47:35 <venom00ut> s/g/m/
07:47:41 <Saizan> luite: initially ($pkgname,$ver) was fine as a primary key, then rewrites didn't go all the way :)
07:47:47 <hiptobecubic> venom00ut, :D
07:48:40 <augur> ski: but, keep in mind, my graph for or isnt perfect
07:48:45 <augur> because ive been up for a while XP
07:48:52 <augur> i havent slept since yesterday =x
07:49:48 <Saizan> hiptobecubic: my feeling is that everyone expects packaging to be a solved problem and just work, so there's quite little manpower (both implementation and design-wise) to go on
07:49:52 <Qtr> (setq haskell-program-name "C:/PROGRA~2/Haskell Platform/2011.4.0.0/bin/ghci.exe") //doesnt work because of Haskell<space>Platform but Haskell~1 doesnt work either
07:50:07 <Qtr> i can put it somewhere else obv
07:50:17 <Qtr> but wait
07:50:22 <Qtr> ¨it works for load :
07:50:25 <Qtr> soi it should work in emacs
07:50:33 <ski> "(left propositions connect to the bottom, right propositions to the top)" -- itym vice versa
07:51:05 <Saizan> it's not easy to spot a flaw in a design when it's just one or two people working on it, and there's not enough implementation-time to get enough release-test-fix iterations either
07:52:31 <fexilal> Hello master programmers
07:53:38 <ski> hello journeyman programmer
07:55:12 <augur> ski: no, i meant that. the left propositions connect to the bottom of the new node, and vice versa.
07:55:22 <ski> oh
07:55:35 <ski> iswym
07:55:36 <confusing> fexilal: the masters are not in today. the shop's cats are running the show
07:55:51 <augur> ski: but vL should be completely dual to ^R since, well, the rules arent dual
07:55:53 <ocharles> @pl foo a = (f a) >> g
07:55:53 <lambdabot> foo = (>> g) . f
07:56:01 <ocharles> @pl foo a = f >> (g a)
07:56:01 <lambdabot> foo = (f >>) . g
07:56:02 * mcstar was delighted of being called master
07:56:08 <ocharles> meh, neither of those are clear
07:56:10 <ocharles> do notation it is
07:56:38 <augur> ski: at least in the 0-or-1-on-the-right version
07:59:37 <ski> augur : i also find `=> I' strange-looking with `A' there all alone
08:00:08 <augur> ski: why?
08:00:23 <ski> i want something like the `A' particle turning in time and becoming an anti-`A', which then connects back into the `=> I' box
08:00:33 <augur> ski: well, yes, like i said
08:00:35 <augur> you do that
08:00:49 <augur> but then for convenience you can split the =>I box in two and lift part up
08:01:07 <venom00ut> the last example shows the questions after taking the input: https://en.wikibooks.org/wiki/Haskell/do_Notation
08:01:10 <ski> "why ?" -- how else will we distinguish between the two possible proofs of `|- A => A => A' ?
08:01:20 <venom00ut> What is your first name? And your last name? Pleased to meet you, $FIRST $SECOND!
08:01:31 <venom00ut> am I doing something wrong?
08:01:50 <augur> ski: thats linear order of the boxes left-to-right
08:01:57 <augur> ski: as it is already in the sequent notation
08:02:10 <augur> you need to use exchange to get the two proofs
08:02:24 <Saizan> venom00ut: it's because of I/O buffering
08:02:36 <ski> venom00ut : hm, it appears they forgot to either flush or set no buffering
08:02:55 <Saizan> venom00ut: you need (hFlush stdout) calls after the putStr ones
08:03:27 <Saizan> ski: yeah, they likely tested in ghci
08:03:28 <ski> venom00ut : with `LineBuffering', the stuff which has been sent by `hPutChar' will only actually be flushed from the output buffer when a newline is sent (as with `hPutStrLn')
08:04:15 <augur> ski: the /\ and \/ rules are dual tho if you write them with just one new node
08:04:18 <ski> venom00ut : so, either follow Saizan's advice, just before each time input is expected from the user -- or use `hSetBuffering stdout NoBuffering' once at the start
08:05:07 <ski> augur : hm, so meen to have an explicit notation for exchange in the graph notation ?
08:05:21 <ski> (i'm not sure i understand "thats linear order of the boxes left-to-right")
08:05:38 <augur> ski: yeah, i left out structural rules for convenience. but it's just braiding of lines
08:06:06 <ski> augur : hm, so you're really doing some kind of (presented) planar graphs ?
08:06:08 <venom00ut> ski, all of the "hSetBuffering", "stdout" and "NoBuffering" are out of scope, probably I'm missing some import, I'll look for an example
08:06:39 <ski> @index stdout
08:06:39 <lambdabot> System.IO
08:06:44 <ski> @index hSetBuffering
08:06:44 <lambdabot> System.IO
08:06:48 <ski> @index NoBuffering
08:06:48 <lambdabot> System.IO
08:07:02 <ski> venom00ut ^
08:07:10 <augur> ski: yeah. more or less.
08:07:34 <augur> ski: because the sequent calculus really cares about the linear order of hyps
08:07:37 <ski> @type System.IO.stdout
08:07:39 <venom00ut> ski, thanks, great!
08:07:39 <lambdabot> GHC.IO.Handle.Types.Handle
08:07:42 <ski> @type System.IO.hSetBuffering
08:07:44 <lambdabot> GHC.IO.Handle.Types.Handle -> GHC.IO.Handle.Types.BufferMode -> IO ()
08:07:46 <ski> @type System.IO.NoBuffering
08:07:47 <lambdabot> GHC.IO.Handle.Types.BufferMode
08:08:27 <ski> venom00ut : while you're at it, please update the wiki as well ;)
08:08:54 <ski> augur : "really cares about the linear order of hyps" -- depends
08:09:13 <ski> if doing ordered stuff, then yes. if doing dependent stuff, then possibly yes
08:09:38 <augur> ski: well, the _proofs_ in SC care
08:09:44 <ski> if just doing linear, or intuitionistic, or classical logic, then not necessarily
08:09:46 <venom00ut> ski, I'll add a warning about this, don't think it's a good idea to disable buffering in the middle of some example code
08:10:05 <ski> augur : i don't agree
08:10:25 <ski> venom00ut : no, but you could add `hFlush stdout' calls in there
08:12:45 <ski> venom00ut : an alternative solution could be to change it to use `putStrLn' just before the `getLine' calls
08:13:34 <monochrom> don't disable buffering. just add hFlush
08:13:48 <Qtr> switch-haskell is void
08:13:55 <ski> augur : hm, sorry, when i was talking about `=> L' above, i meant `=> R'
08:13:57 <Qtr> i cant use ghci in emacs
08:14:14 <ski> augur : i think i was confused by you using `=> I' instead of `=> R' in the graph version
08:14:24 <ski> augur : hm, sorry, when i was talking about `=> L' above, i meant `=> R'
08:14:25 <ski> augur : i think i was confused by you using `=> I' instead of `=> R' in the graph version
08:14:28 <hiptobecubic> I can't get the -static flag to work. I should be as easy as   ghc --make -static myfile.hs  right?
08:14:49 <ski> (augur : did you say anything after "<augur> ski: well, the _proofs_ in SC care" ?)
08:14:52 <augur> ski: plausible
08:14:54 <augur> also
08:14:55 <cesc> Hi, n00b question.  I'm trying to install the OpenGL package http://hackage.haskell.org/package/OpenGL/  .    I started with "cabal Setup configure" and it complained about dependencies... is there an automated way to manage packages (search, install, install dependencies, upgrade, etc) ?
08:14:56 <augur> no
08:14:57 * monochrom doesn't understand why people are so polarized on everything. even on buffering. either full buffering or no buffering.
08:15:04 <cesc> *runhaskell
08:15:08 <augur> ski: exchange exists, so SC cares about linear order
08:15:23 <hiptobecubic> cesc, cabal install can download the package and deps and install it all
08:15:29 <ski> monochrom : who is ?
08:15:46 <monochrom> everyone who suggest "disable buffering"
08:16:01 <cesc> hiptobecubic: oh! thx for the tip. It seems to be doing something.
08:16:09 <ski> i suggested it as a possible alternative
08:16:35 <confusing> hiptobecubic: i thought static is the default anyway
08:17:07 <confusing> ski: well then you're possibly alternatively polarizing
08:17:07 <ski> normally, buffering should be an efficiency-tweak -- but when connecting to a tty, the interleaving&synchronizing may matter
08:17:15 <hiptobecubic> confusing, well if it is, it's not working.
08:17:21 <ski> confusing :)
08:17:28 <hiptobecubic> but i don't know what to look for to check
08:19:02 <hiptobecubic> yeah no. it's definitely making dynamic executables
08:19:13 <ski> augur : oh, in fact, i now notice you have `L'- and `R'- rules in the sequents and `E'- and `I'- rules in the graphs -- was this intended ?
08:19:44 <confusing> hiptobecubic: oh wait, the -dynamic vs -static thing was added not too long ago. what's your version? it does accept -static for me, but i have ghc 7.4
08:20:00 <hiptobecubic> 7.4.1
08:20:06 <hiptobecubic> it accepts it, but it doesn't *do* it
08:21:29 <confusing> and yes, the "file" utility does report "dynamically linked" on files that ghc calls "static". i'm not sure ...
08:21:46 <hiptobecubic> confusing, at one point, it did work.
08:21:55 <hiptobecubic> I don't know how though. I have one file here which is actually statically linked
08:22:44 <confusing> i just tried "-dynamic", and it said it can't because i need to install special versions of libraries first
08:23:04 <hiptobecubic> same
08:23:13 <hiptobecubic> is this a bug? It doesn't make any sense
08:23:28 <monochrom> -dynamic and -static only affects how to link in ghc libs. most likely doesn't affect c libs. it is very hard to statically link c libs on some platform
08:23:29 <confusing> so, you have a binary that "file" reports as static?
08:23:40 <hiptobecubic> confusing, yes.
08:23:44 <hiptobecubic> monochrom, is there an option to try?
08:23:55 * hackagebot distributed-process 0.2.1.4 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
08:24:25 <hiptobecubic> that sounds neat
08:24:27 <monochrom> there are a bunch of incantations for -optC and/or -optL etc but I did not take note
08:25:03 <monochrom> but they also seem very fragile
08:25:23 <confusing> monochrom: so does "c lib" apply here to the rts, or just ffi libraries?
08:25:35 <monochrom> my memory says that some people actually say that linux glibc is not designed for static linking
08:25:54 <hiptobecubic> well where did this one come from then
08:25:59 <monochrom> c lib applies to libc.so, libm.so, ...
08:26:00 <Qtr> so no emacs-haskell-mode-gurus here? how do you run your inferior-haskell/ghci in emacs?
08:27:11 <hiptobecubic> aha
08:27:30 <hiptobecubic> -optl "--static" causes everything to explode
08:27:54 <ski> Qtr : you might try to catch chrisdone later
08:28:00 <ski> preflex: xseen chrisdone
08:28:00 <preflex>  chrisdone was last seen on freenode/#haskell 1 day, 18 hours, 26 minutes and 15 seconds ago, saying: rtharper: i'll let you know on that ;) negotiations are under way
08:29:14 <parcs`> hiptobecubic: try -optl-static -threaded
08:29:22 <monochrom> you probably want to search haskell-cafe and/or glasgow-haskell-users. there are horror stories
08:29:36 <hiptobecubic> parcs`, yes, working on that now :)
08:29:53 <hiptobecubic> aha
08:29:59 <confusing> hiptobecubic: what do you need a static thingy for, by the way?
08:30:26 <hiptobecubic> miguided attempt to run it on a different box where i have no control over anything
08:31:29 <k0ral> hi
08:31:36 <ski> hello k0ral
08:31:46 <k0ral> I'm getting familiar with Control.Monad.Error
08:31:49 <hiptobecubic> but i really want to try it out because it's a 48-core Xeon and I want to see how well Repa fares
08:32:00 <mcstar> o.O
08:32:01 <k0ral> but I'm also getting frustrated because of the following issue
08:32:05 <mcstar> big ass cpu
08:32:24 <hiptobecubic> i assume it's 4 * 6 with hyperthreading
08:32:31 <mcstar> :(
08:32:40 <k0ral> I'm using several third party libraries that provide their own error type, that is an instance of MonadError
08:32:45 * mcstar was thinking of 48 cores in on one die
08:32:50 <mcstar> -in
08:33:25 <monochrom> oh, I see the problem now. "warning: Using 'dlopen' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking" Though, it is just a warning, an executable is still produced. just not sure whether it runs well
08:33:27 <k0ral> I would like to write a function in ErrorT (IO (Either ErrorType ReturnType))
08:33:33 <hiptobecubic> 48 cores on a cpu would not work out. too many memory conflicts i would expect?
08:33:49 <mcstar> hiptobecubic: it will work some day
08:33:51 <k0ral> problem is: I have a distinct "ErrorType" for each library I use
08:33:57 <hiptobecubic> monochrom, yes, i also got that error, but it's as close as i can get. We'll see how it does
08:34:18 <mcstar> hiptobecubic: why are using haskell on that machine? just write some mpi code in c++
08:34:49 <monochrom> you will have to move the executable to a mysterious computer with mismatching c lib versions to see. essentially the dlopen call may or may not be hit all at
08:35:11 <monochrom> and we don't know what it wants to open, if it's hit
08:35:12 <hiptobecubic> LOL. :~$ ./foo +RTS -N -sstderr;       FATAL: kernel too old; Segmentation fault
08:35:25 <monochrom> oh, that. ok, it is hit
08:35:26 <hiptobecubic> mcstar, because writing C++ sucks?
08:35:28 <parcs`> why would an executable use dlopen anyway?
08:35:47 <k0ral> how would you guys harmonize various libraries error types ?
08:36:28 <monochrom> dunno. some crucial part of glibc calls dlopen? because it assumes dynamic libs to be present? because to remove that assumption is too hard?
08:36:33 <Qtr> we should make a haskell system like the lispmachines
08:36:49 <mcstar> dlopen is a system call, thats how the binary loads the necessary libs
08:37:08 <monochrom> because it wants to peek around the environment before deciding which lib it needs?
08:37:26 <hiptobecubic> trying again without -fllvm
08:37:33 <monochrom> it's glibc-specific. ask the glibc people
08:38:05 <parcs`> hiptobecubic: how old is that kernel?
08:38:09 <hiptobecubic> I'm not asking about the errors. Just wanted to know -optl-static basically. If it doesn't work it doesn't work. Not worth pursuing.
08:38:33 <geekosaur> glibc uses dlopen because of nsswitch (getuid() and friends)
08:38:53 <mcstar> hiptobecubic: but maybe bring the libs along with the executable?
08:39:10 <Qtr> (require 'inf-haskell) was missing just needed on some systems(windows apparently)
08:39:12 <hiptobecubic> parcs`, Linux 2.6.18-308.8.1.el5 #1 SMP Tue May 29 14:57:25 EDT 2012 x86_64 x86_64 x86_64 GNU/Linux
08:39:35 <geekosaur> it needs to know whether it nees to check LDAP, NIS, etc.
08:40:02 <confusing> koral: i think that's something of an open question. nobody has really figured out a good way that works everywhere. here's some discussion: http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors/ and a followup: http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
08:41:05 <confusing> k0ral: if you have some particular code that you suspect could be less awkward, post it to hpaste and ask in here :) folks often have good ideas how to improve stuff
08:41:08 <confusing> @where hpaste
08:41:09 <lambdabot> http://hpaste.org/
08:43:37 <k0ral> confusing: my code isn't complete yet, but I'll try to write something and paste it
08:43:46 <monochrom> so, nsswitch means reading /etc/nsswitch.conf first, before deciding which libs to link on-the-fly to provide getuid() etc?
08:44:16 <geekosaur> yes
08:44:27 <monochrom> interesting approach
08:44:42 <geekosaur> it may point to LDAP library, NIS, files backend, winbind (!), etc.
08:45:02 <monochrom> yeah, they all need different getuid implementations
08:45:03 <geekosaur> zeroconf too
08:45:08 <confusing> hiptobecubic: there are alternatives to glibc, e.g. with the aim of being smaller/more embeddable. but that's probably cowboy territory
08:45:15 <geekosaur> although thta's not useful for getuid it's useful for hosts
08:45:24 <ski> augur : hm, just fyi, the `=> L' rule in expression-focused form is
08:45:30 <ski>   Gamma |- e0 : A0   Gamma , x1 : A1 |- e' : A'
08:45:33 <ski>   --------------------------------------------- => |-
08:45:34 <ski>   Gamma , x : A0 -> A1 |- e'[x e0/x1] : A'
08:47:22 <ski> augur : using these are nice when writing a proof-search in Prolog which constructs a proof-term -- the substitution there corresponds to keeping a difference-term, instantiating the hole with a new node containing a new hole
08:48:53 <optimight> 123456
08:49:14 <ski>       543210
08:49:37 <mcstar> now i have to change my password :(
08:49:54 * ski stares blankly
08:50:28 <Qtr> why does haskell have some things that are intendation sensitive and how do i get rid of it if i can using maybe {;}?
08:50:44 <Qtr> case board of Just x ->
08:50:44 <Qtr>                Just $ (foldl (\s m -> if m == B.E then s else s+1) 0 $
08:50:44 <Qtr>                B.board x
08:50:44 <Qtr>                              Nothing -> Nothing
08:50:45 <geekosaur> ...
08:50:47 <ocharles> the why is "because it does"
08:50:58 <mcstar> nice ninja-paste there
08:51:00 <Taneb> Does it need to be that indented?
08:51:03 <monochrom> yes you can use {;} instead of indentation
08:51:26 <quuuux> Qtr: define 'get rid of it'. You can re-write anything indent-sensitive using {;}. You can even do this programmatically
08:51:31 <monochrom> as for why, because you can't please everyone
08:51:47 <mcstar> so, in essence, haskell supports intendational programming?
08:52:01 <confusing> Qtr: if you feel those lines have too much indentation, try putting a newline after "of". you can then indent less
08:52:13 <shergill> Qtr: http://en.wikibooks.org/wiki/Haskell/Indentation
08:52:30 <confusing> (but "Nothing" and "Just" still have to be aligned)
08:52:32 <quuuux> I had to actually write a whitespace-to-{;} converter so I could collaborate with a blind colleague. It was only 3 lines and about 100 characters. haskell-source-exts is really, really handy
08:52:52 <monochrom> oh heh
08:52:56 <mcstar> quuuux: you could help someone then
08:53:09 <mcstar> i forgot his nick
08:53:30 <ski> Qtr : i suggest breaking the line before `Just x ->'
08:53:45 <ski> (instead of after)
08:53:56 * hackagebot fay 0.1.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
08:54:04 <ski> Qtr : then, align `Nothing ->' with `Just ->'
08:54:13 <mcstar> how can i search in weechat?
08:54:33 <mcstar> (once i did it accidentally)
08:54:38 <ski> dunno .. maybe ask #weechat ?
08:54:43 <mcstar> c-r
08:54:52 <quuuux> import Language.Haskell.Exts
08:54:52 <quuuux> main = getContents >>= putStr . prettyPrintWithMode (defaultMode {layout = PPSemiColon}) . fromParseResult . parseFileContents
08:54:57 <quuuux> that's literally it
08:54:57 <monochrom> that's probably an emacism
08:55:29 <confusing> quuuux: very nice
08:55:31 <Toheii> Are there any easy 'first programs' you guys can think of for a newb?
08:55:31 <monochrom> does c-s also let you search?
08:55:34 <hpaste> qrt pasted “intendation and pattern guards” at http://hpaste.org/71895
08:55:37 <ski> quuuux : i would probably remove `getContent >>=' and add `=<< getContents' at the end
08:55:46 <Qtr> can i use guards for it instead of case?
08:56:02 <ski> quuuux : or say `main = interact (prettyPrintWithMode (...) . fromParseResult . parseFileContents)'
08:56:27 <monochrom> you can use guards for it but I wouldn't
08:56:47 <mcstar> timthelion: was it
08:56:55 <Qtr> Toheii: some fun ones: a bayesian spamfilter or just a simple count what kinf of words come in spam and what in ham. could be done in 25-50 LOC
08:56:58 <mcstar> timthelion: quuuux might have something for you
08:57:19 <Toheii> Qtr: Thank you I will have a go at that one
08:58:07 <ski> Qtr> :t B.E
08:58:15 <Qtr> Mark
08:58:16 <confusing> Toheii: i suggest you work through a tutorial like LYAH. it has lots of code examples, and you can play around with them, make changes, etc.
08:58:19 <confusing> @where lyah
08:58:20 <lambdabot> http://www.learnyouahaskell.com/
08:58:46 <confusing> Toheii: also, i hear kids these days are all doing the project euler problems ;)
08:58:47 <Qtr> data Mark = X | O | E , E for empty
09:01:24 <applicative> Toheii it is good to have a project though; what sort of thing are you interested in?
09:02:06 <applicative> something like project euler is good for imprinting stupid syntactic peculiarities, the number classes etc.
09:02:16 <hpaste> ski annotated “intendation and pattern guards” with “`fmap'” at http://hpaste.org/71895#a71896
09:02:16 <hpaste> ski annotated “intendation and pattern guards” with “`fmap'” at http://hpaste.org/71895#a71897
09:02:33 <ski> oops -- hpaste.org appeared to not be responding :/
09:02:36 <ski> Qtr ^
09:02:55 <quuuux> Toheii: it might be a little bit dated now, but I really enjoyed working through 'Build Yourself A Scheme In 48 Hours'
09:03:05 <Toheii> applicative: When I started learning c/c++ I made a few small games but due to the high amount of impure code in haskell it didn't seem to make sense to start with them
09:03:15 <applicative> ski something  is odd with hpaste yes
09:04:08 <parcs`> Toheii: do you mean high amount of pure code
09:04:36 <Toheii> parcs`: No with games you have to interact with the user a lot for input and what not
09:04:39 <ski> Qtr : though really, i'd probably full out the `fmap' call in there and put it around the call to `countOccupied2' instead (possibly doing further simplifications then)
09:04:46 <quuuux> Toheii: if you've already got a grip on the tutorial aspect of that, just writing a tiny little lisp or forth could be a fun project
09:05:00 <applicative> (parcs` is right of course)
09:05:28 <monochrom> purely functional game example: http://hpaste.org/52480
09:05:43 <applicative> hpaste is misbehaving
09:05:51 <Taneb> If you have -XOverloadedStrings and -XRebindableSyntax, and your own IsString class, what happens?
09:06:30 <applicative> good luck with your personal IsString class, as opposed to instance
09:06:39 * ski hugs monochrom
09:06:59 <Toheii> Well thanks guys for all the ideas I think I will start with some project euler to get a better grasp of folds/maps and then have a go some little games
09:07:01 <confusing> monochrom: yeah in some sense ... but it does show what Toheii meant. all of the code is in IO
09:07:06 <Qtr> SOLVED
09:07:25 <ski> Qtr ?
09:07:34 <applicative> haha, that was one of  the first haskell programs I wrote, I mean an equivalent.
09:07:40 <Taneb> applicative, I'm really just curious
09:08:27 <monochrom> I can call it purely functional because I use no mutable variables myself. the IO is just for UI
09:08:54 <confusing> Toheii: oh, how about a command line utility? i recall my first haskell program took one name of a binary ("sh" or whatever) and checked in all directories in $PATH if it is present. (so i wrote essentially a duplicate of "which -a", but i didn't know about it at that time and it was still useful to me)
09:09:23 <monochrom> "guess - 1" is purely functional. as opposed to "hi := guess - 1"
09:10:08 <k0ral> so, here it is: https://gist.github.com/3156282
09:10:26 <k0ral> how would you solve that problem guys ? :)
09:10:51 <quuuux> k0ral: f3 :: Either (Either ErrorType1 ErrorType2) ReturnType ?
09:10:57 <ski> monochrom : hm, how about Riastradh's foof-loop ?
09:11:10 <monochrom> I don't know what that is
09:11:17 <quuuux> you have to deal with ErrorType1 somewhere if you're not ignoring it, and that's what the types are saying
09:11:34 <hpaste> applicative pasted “rebindableoverloadedstring” at http://hpaste.org/71898
09:11:35 <ski> monochrom : see e.g. `partition' at <http://mumble.net/~campbell/scheme/foof-loop.txt>
09:11:39 <confusing> k0ral: or you could handle the errorsm (or one of them) right there
09:11:40 <applicative> Taneb: it works; you do seem to need rebindable syntax. Or so it so it seems from this
09:12:11 <k0ral> quuuux: what if I have more than 2 error types ?
09:12:19 <Taneb> applicative, interesting. Not useful at all, but useful
09:12:23 <Taneb> *interesting
09:12:31 <ski> monochrom : `(continue (=> satisfied (cons element satisfied)))' there translates (by a macro) to `(continue (cons element satisfied) unsatisfied)'
09:12:44 <k0ral> confusing: define "right there"
09:12:50 <realitygrill> anyone familiar with problems installing glib on OSX? 'cabal install glib' is killing me
09:12:57 <quuuux> k0ral: ah, now's where it gets interesting. If you can handily enumerate them all ahead of time, you can use an ADT of error types
09:13:04 <applicative> Taneb, this instance is not useful...
09:13:14 <applicative> except maybe for a PHP dsl...
09:13:15 <Qtr> quickCheck when failing returns the item beforer or after you quikcchecked it
09:13:25 <Taneb> applicative, why would anyone want a PHP dsl?
09:13:28 <quuuux> k0ral: if not, you can use the framework from Control.Exception
09:14:29 <confusing> k0ral: i meant in line 12 of your paste :) if there's something useful you can do (retry the call to f1, or print an error message for the user, or ...). if there's nothing you can do and you definitely want to give out both error types, you probably have to do what quuuux suggested (Either (Either ))
09:15:22 <realitygrill> http://hpaste.org/71893
09:15:35 <confusing> (i was using OverloadedString once and i could have sworn that RebindableSyntax was not necessary ...)
09:16:17 <applicative> Taneb: Oh hackage already has one  http://hackage.haskell.org/packages/archive/acme-php/0.0.1/doc/html/src/Prelude-PHP.html
09:16:44 <Taneb> confusing, it isn't. I was just wondering if it was possible
09:16:50 <monochrom> "Please install `gtk2hs-buildtools` first"
09:16:58 <k0ral> quuuux: ADT ?
09:17:01 <monochrom> "and check that the install directory is in your PATH (e.g. HOME/.cabal/bin)."
09:17:11 <applicative> confusing, it isn't in general, Taneb introduced his own IsString class, not Data.String.IsString
09:17:42 <confusing> applicative: oh! i didn't catch that. sorry :-/
09:17:43 <ski> monochrom : iow, on the surface, this appears to be akin to `satisfied := element : satisfied', but actually it is really just passing `element : satisfied' in the `satisfied'-argument-position of the tail-recursive loop call
09:18:47 <monochrom> oh ha, that's a gray area, isn't it
09:18:56 <monochrom> (gray? grey?)
09:18:57 <k0ral> quuuux: I don't get how ADT will fix it, would you be so kind as to give a code sample please ?
09:19:07 <confusing> k0ral: i think he means "data AllThePossibleErrors = E1 ErrorType1 | E2 ErrorType2 | ..."
09:19:22 <ski> monochrom : well, are you british or not ?
09:19:31 <confusing> monochrom: the spelling of the word gray is a grey area
09:19:36 <monochrom> I don't know. that's another grey area!
09:19:48 <hpaste> applicative annotated “rebindableoverloadedstring” with “rebindableoverloadedstring” at http://hpaste.org/71898#a71899
09:19:55 <applicative> confusing: Taneb the class isnt required as one might have predicted ^^^
09:20:25 <raymank26> hi. Tell me please why member function from Data.List.Ordered has O(n) complexity and not using binary search for instance? There is some reason?
09:20:35 <k0ral> confusing: but you still can write "a <- f1" in an "AllThePossibleErrors" monad space
09:20:42 <monochrom> I grew up in British-ruled Hong Kong and fond of British English. I am in Canada and subject to more American English.
09:21:10 <k0ral> confusing: s/can/can't
09:21:12 <confusing> applicative: ah. so you're saying that LANGUAGE RebindableSyntax implicitly imports Data.String or wherever the IsString thingy lives
09:22:18 <MostAwesomeDude> >> instance Num String where
09:22:24 <MostAwesomeDude> Welp, my day has been made.
09:22:27 <applicative> confusing: no I was thinking more like it keeps it out; or thats what Taneb was thinking ?
09:22:28 <confusing> k0ral: no, i meant your function f3 would then have type "Either AllThePossibleErrors ReturnType"
09:22:33 <parcs`> k0ral: see mapErrorT
09:23:05 <k0ral> confusing: I understood that, it's just that I want to use the seamless notation "a <- f1" followed by "b <- f2"
09:23:09 <confusing> monochrom: seems mixed. may i interest you in græy?
09:23:09 <applicative> confusing: all that seems to  matter in that last file is that there is a definition of 'isString' in scope.  It has type [a] -> Int
09:23:14 <k0ral> confusing: and I can't because they're not in the same monad space
09:23:36 <parcs`> k0ral: you can't do that with ErrorT. you can with IO, though
09:24:00 <k0ral> parcs`: how so ?
09:24:26 <monochrom> haha, græy is a nice solution
09:24:31 <irene-knapp> haha
09:24:32 <irene-knapp> so it is
09:24:51 <confusing> k0ral: ah, right. i misunderstood you, sorry
09:25:43 <Tekmo> I have a question: If (f . g) = id, but (g . f) does not necessarily equal id (i.e. f is a retraction and g is a section), is there a name for the pair of them?
09:25:43 <lambdabot> Tekmo: You have 1 new message. '/msg lambdabot @messages' to read it.
09:25:43 <parcs`> k0ral: with the Control.Exception framework
09:25:55 <hpaste> qrt pasted “quickcheck fail” at http://hpaste.org/71900
09:26:13 <twanvl_> Tekmo: f is the left inverse of g
09:26:17 <k0ral> parcs`: I don't really like using IO where I have only pure computation
09:26:20 <Tekmo> Right, I mean
09:26:33 <Tekmo> I mean, is there a corresponding work like "isomorphism", but only one way?
09:26:39 <Tekmo> *word
09:26:45 <k0ral> parcs`: is that a kludgy workaround you're offering or is it really something recommended ?
09:26:56 <Tekmo> The only reason I'm asking is I want to create a dictionary for such a pair of functions
09:27:00 <Tekmo> and just need a name for the dictionary
09:27:06 <ski> monochrom : anyway, i find foof-loop interesting. it was inspired by Olin Shivers' "The Anatomy of a Loop: a story of scope and control" in 2005-09 at <http://www.ccs.neu.edu/home/shivers/papers/loop.pdf>,<http://lambda-the-ultimate.org/node/1014>
09:27:16 <Tekmo> i.e. data ??? a b = ??? { f :: a -> b, g :: b -> a }
09:27:23 <Tekmo> such that f . g = id
09:27:24 <ski>   "In call-by-value functional languages such as ML or Scheme, we typically write loops using tail-recursive function calls. This is actually a terrible way to express program iteration, and it's not hard to see why. As was popularised by Steele, a tail call is essentially a "`goto' that passes arguments." So writing loops with tail calls is just writing them with `goto's."
09:27:26 <monochrom> try "half isomorphism". not an official name though
09:27:29 <ski>   "Yet, it has long been accepted in the programming-language community that `goto' is a low-level and obfuscatory control operator, a position stated by Dijkstra's "`Goto' considered harmful" letter."
09:27:40 <Qtr> when quickcheck fails it returns the item before or after the test?
09:27:42 <parcs`> k0ral: kludgy
09:28:07 <mcstar> ski: you never see goto in practice
09:28:22 <ski> @src foldl
09:28:23 <lambdabot> foldl f z []     = z
09:28:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:28:24 <ski> ^
09:28:25 <mcstar> whats the problem, if some code compiles to goto/tagbody?
09:28:46 <ski> the tail-call is effectively a `goto'
09:28:49 <parcs`> k0ral: i would define 'liftError f =  mapErrorT (fmap (either (Left . f) Right))' and do 'a <- liftError Error1 f1; b <- liftError Error2 f2; ...'
09:28:54 <k0ral> I can't believe there is no elegant solution to this problem
09:29:05 <mcstar> ski: is this supposed to be good or bad? whats your point?
09:29:08 <parcs`> k0ral: with an ADT enumerating all the possible errors
09:29:33 <monochrom> loop is harder to prove correct than recursion. some recursions happen to be goto. this seems paradoxical in light of goto-considered-harmful, yes. there is an explanation
09:29:35 <Tekmo> Wait, can you restate the problem, koral?
09:29:40 <Tekmo> I missed it
09:29:45 <ski> mcstar : bad in general, at least to the extent that you write tail-recursive loops yourself, instead of using combinators like `foldl',`filter',`map', &c.
09:30:33 <mcstar> ski: in most languages you cant afford to use those high level constructs
09:30:36 <monochrom> if you don't attach a specification to a function or a label, then calling that function or jumping to that label does unknown things, yes
09:30:43 <mcstar> haskell is only an exception because it is lazy
09:31:00 <parcs`> Tekmo: k0ral has f1 :: ErrorT Error1 m a and f2 :: ErrorT Error2 m b which he wants to use in the same do block
09:31:07 <monochrom> if you do attach a specification, then you can do an induction or coinduction proof of correctness. this is easy to reason about.
09:31:16 <Tekmo> k0ral:
09:31:16 <k0ral> Tekmo: sorry, didn't highlight on koral
09:31:20 <Tekmo> Check out Data.EitherR
09:31:23 <Tekmo> in the errors package
09:31:31 <Tekmo> You have to work in two separate monads
09:31:33 <ski> mcstar : the basic problem here is that initialization of accumulators is detached in code from the update in the recursive call (making it harder to change the representation of the accumulator) -- also that you have to keep mentioning even the accumulators that aren't updated
09:31:49 <k0ral> Tekmo: but working in 2 separate monads is boilerplate
09:32:00 <Tekmo> You can define a function to wrap that boilerplate
09:32:00 <k0ral> say I'm using N different libraries with N different ErrorTypes
09:32:03 <ski> mcstar : in case of a large function with several recursive calls, you have to check each and every of them to see that "nothing funny" is happening
09:32:08 <Tekmo> Right
09:32:13 <Tekmo> You work in the EitherR monad
09:32:14 <twanvl_> Tekmo: perhaps it is a surjection / epimorphism
09:32:15 <parcs`> k0ral: you don't think my solution is not elegant enough?
09:32:17 <k0ral> I don't want to switch from a monad space to another every time
09:32:22 <Tekmo> Which is polymorphic over the error type
09:32:54 <mcstar> ski: but these higher level operators like fold, are essentially must be written in a tail recursive manner
09:32:56 <ski> mcstar : "in most languages you cant afford to use those high level constructs" -- in the case of foof-loop, it is translated at compile-time (really macro-expansion-time) to an efficient tail-recursive loop
09:32:58 <k0ral> parcs`: still figuring out how your solution works :)
09:33:27 <Tekmo> twanvl_: Well, that's the name for each type individual function, but I want something that describes the pair itself
09:33:49 <mcstar> ski: ok, so your point, is that TR style is bad for the programmer to reason about
09:33:55 <parcs`> :t mapErrorT
09:33:57 <lambdabot> forall (m :: * -> *) e a (n :: * -> *) e' b. (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
09:34:02 <ski> mcstar : "in most languages you cant afford to use those high level constructs" -- also, one can use streams/generators in strict languages, which ameliorates the problem of non-tail-recursive `map',`filter',&c.
09:34:18 <parcs`> :t \f -> mapErrorT (fmap (either (Left . f) Right))
09:34:18 <mcstar> ski: that basically makes them lazy
09:34:20 <lambdabot> forall a b e (m :: * -> *). (Functor m) => (e -> a) -> ErrorT e m b -> ErrorT a m b
09:34:27 <ski> mcstar : yes
09:34:42 <Tekmo> Oh, k0ral
09:34:46 <Tekmo> Also check out the "either" package
09:34:50 <Tekmo> which has mapEitherT
09:34:56 <Tekmo> :t mapEitherT\
09:34:57 <lambdabot> parse error on input `\'
09:35:01 <Tekmo> :t mapEitherT
09:35:03 <lambdabot> Not in scope: `mapEitherT'
09:35:06 <twanvl_> Tekmo: well, I usually call the pair { fw :: a -> b; bw :: b -> a} a bijection or isomorphism (assuming that it is), while technically either fw or bw are the isomorphisms
09:35:08 <Tekmo> mapEitherT :: Functor m => (e -> f) -> (a -> b) -> EitherT e m a -> EitherT f m b
09:35:11 <ski> (just saying that is often an option even in "most languages" -- or at least the more sensible of the imperative ones)
09:35:23 <ski> mcstar : "so your point, is that TR style is bad for the programmer to reason about" -- essentially, yes
09:35:49 <twanvl_> Tekmo: but you can also consider the pair to be a morphism in some other category, the category of {iso,mono,epi}morphisms of the base category Hask
09:35:56 <Tekmo> Yeah, I realized
09:36:00 <Tekmo> That's why I'm using it
09:36:03 <Tekmo> I want to build a category of those pairs
09:36:10 <Tekmo> It's for pipes
09:36:22 <Tekmo> I'm basically formulating each pipe extension as a pair of one-way inverses
09:36:25 <k0ral> ok, so I have to loop through the following proposed solutions: ADT, mapErrorT, EitherR and mapEitherT
09:36:37 <Tekmo> And then using them to automatically extend the category of classic pipes
09:36:48 <mcstar> ski: some time ago i wanted to write something in ocaml, i wrote it with tail recursion, to save stack, turned out my solution wasnt really TR, since used built-in functions that weren TR, i saw yesterday i think, there are TR implementations of non TR standard functions for ocaml, i think from the batteries project(or jane street, i dont remember)
09:37:24 <Tekmo> twanvl_: I think I could just do what you suggested and call it monomorphism, refering to one of the two functions
09:37:30 <mcstar> i mean, its a shame, that there are those combinators, like fold for example, but you cant use them, becauser it means either slow code, or you run out of stack
09:37:32 <ski> mcstar : yeah, in case your stack is artificially limited (wrt the heap), that may be a good idea
09:38:24 <Qtr> but like a function moveWin(move to position that wins you the game id there is such a position) in tictactoe , how would you test that with quickcheck? you need to generate a board where you can win in the next move and some where you cant...
09:38:36 <Tekmo> mapM_ evaluate [ADT, mapErrorT, EitherR, mapEitherT]
09:38:52 <monochrom> all these "while-loop is more well-structured than goto" "goto is lower level" hinges on the assumption that you don't explain your code. but I am against not explaining your code to begin with.
09:38:54 <parcs`> k0ral: ADT and mapErrorT go hand-in-hand, and mapEitherT is like mapErrorT but for the EitherT monad, which is like ErrorT except that ErrorT has a non-partial fail implementation
09:39:08 <monochrom> To me, low-level means you don't explain your code, high-level means you explain your code.
09:39:29 <mcstar> what?
09:39:50 <ski> well, it is true that "single-enter single-exit" makes things easier to reason about
09:40:11 <monochrom> IF the code is undocumented and you have to reverse-engineer it
09:40:26 <k0ral> Tekmo: I can't see how EitherR solves anything, it just flips the logic between the 2 components of Either
09:40:29 <monochrom> which is against my religion
09:40:38 <Tekmo> Yeah, check out mapEitherT instead
09:40:44 <ski> i think the problem here (e.g. with `for'/`while' combined with `break' or `goto' in C) is that one doesn't seem up-front whether the current code has any exceptions to the "common, simple" case
09:40:45 <Tekmo> It's more general since it works over both variables
09:40:56 <Qtr> monochrom: how is high and low level about explaining your code?
09:41:02 <mcstar> from using high level combinators, it doesnt necessarily follow that your code is easy to understand
09:41:05 <k0ral> parcs`: thank you for clarifying :) , I'm looking at that
09:41:07 <confusing> ski: i'm not sure. the standard defense against "multiple exit" is some control variable, but then you have to reason about all the if-else branches
09:41:13 <mcstar> i mean, some explanation is always good
09:41:32 <ski> e.g. if one were required to label the loop to be able to use `break' or `continue', then by not seeing such a label, one can immediately know that those can't happen here
09:41:37 <monochrom> it is true that some constructs are easier to reverse-engineer than others, in the absence of any doc and explanation
09:41:55 <ski> confusing : yes, i didn't claim that "multiple exit" can't be sensible in some cases :)
09:42:23 <alex404> If you have a function foo a b c = a*b + c, will a*b always be recomputed?
09:42:27 <mcstar> we have multiple exits for a reason
09:42:38 <alex404> If, for example, you create foo1 = foo a b
09:42:51 <ski> monochrom : so, i suppose if such labeling were required to use `break' and `continue', one could view that as a kind of compiler-enforced (half-)documentation
09:43:03 <monochrom> Qtr, if I can follow your code, it's high-level. if I can't follow your code, it's low-level. but I can or cannot follow your code depending largely on how you explain it
09:43:08 <Tekmo> alex404: Split it into two functions
09:43:15 <Tekmo> bar a b = a * b
09:43:21 <Tekmo> foo a b c = bar a b + c
09:43:32 <Tekmo> Then I believe that GHC will cache the result of computing bar
09:43:32 <alex404> Is that really necessary though?
09:43:41 <rwbarton> alex404, in GHC with no optimizations enabled, yes
09:43:42 <ski> i think a large part of "lower level" here is when stuff are not composable
09:43:44 <Qtr> monochrom: so comment the code directly or in some doc?
09:43:53 <rwbarton> you can write
09:43:54 <k0ral> @hoogle mapEitherT
09:43:55 <lambdabot> No results found
09:43:58 <monochrom> yes. write specifications. prove correctness
09:44:00 <rwbarton> foo a b = let x = a * b in \c -> x + c
09:44:01 <k0ral> wtf ?!
09:44:11 <confusing> k0ral: use hayoo, hoogle only searches a few packages
09:44:14 <confusing> @where hayoo
09:44:14 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
09:44:20 <alex404> And what if you turn on O2? Will things like this usually be caught?
09:44:35 <rwbarton> Probably.
09:44:42 <rwbarton> It's sometimes better to recompute the value each time anyways.
09:44:44 <k0ral> confusing: oh, nice one, thank you
09:44:49 <alex404> Why's that?
09:45:06 <confusing> k0ral: you're welcome
09:45:11 <ski> mcstar : "from using high level combinators, it doesnt necessarily follow that your code is easy to understand" -- true -- however using `map' instead of a hand-recursion means the reader won't have to check to make sure what s/he thinks is happening (performing for every element) actually is happening
09:45:37 <ski> mcstar : otoh, combinators like `map',`filter',&c. aren't always that composable with each other ..
09:45:48 <rwbarton> If the value is very large (in terms of heap space) the performance cost of storing it can be greater than the cost of recomputing it
09:45:58 <rwbarton> E.g. consider the contrived example foo a b c = [a..b] !! c
09:46:07 <alex404> Right...
09:46:08 <ski> mcstar : this is one thing that foof-loop is meant to improve on (for tail-recursive stuff)
09:46:15 <Qtr> @type mapEitherT
09:46:17 <lambdabot> Not in scope: `mapEitherT'
09:46:24 <alex404> Will O2 figure out good and bad cases to do that kind of thing?
09:46:25 <Qtr> but like a function moveWin(move to position that wins you the game id there is such a position) in tictactoe , how would you test that with quickcheck? you need to generate a board where you can win in the next move and some where you cant...
09:46:41 <Tekmo> You can find mapEitherT here:
09:46:43 <Qtr> arbitrary winnableBoard ?
09:46:44 <Tekmo> http://hackage.haskell.org/packages/archive/either/3.0.2/doc/html/Control-Monad-Trans-Either.html
09:46:54 <confusing> ski: absolutely right. as always, note that "the reader" might well be "myself in 2 weeks"
09:46:58 <alex404> rwbarton: I'm just trying to figure out how much I can ignore this issue and carry on with pretty code...
09:47:24 <Tekmo> Then your best hope is to just trust the GHC developers to read your mind
09:48:08 <Tekmo> which works the vast majority of the time
09:48:24 <alex404> Good to know ;)
09:48:31 <Tekmo> Also, if you are not sure
09:48:43 <Tekmo> just use ghc-core to check if the optimization is happening
09:48:56 <alex404> Yah... i'm slowly breaking into that...
09:49:00 <Tekmo> Yeah, it's tough
09:49:04 <jmcarthur> alex404: i agree with Tekmo, if you need some confirmation
09:49:09 <Tekmo> So use a really simple test case to check it
09:49:24 <Tekmo> Like:
09:49:29 <k0ral> parcs`, Tekmo: I think I got it for mapEitherT, basically you provide the function to translate ErrorType1 into GlobalErrorType as first argument to mapEitherT
09:49:34 <jmcarthur> alex404: you do learn some "defensive" optimization habits after a while, though
09:49:38 <Tekmo> main = replicateM_ 100 $ print $ foo 1 2 3
09:49:44 <alex404> jmcarthur: Such as?
09:50:04 <jmcarthur> proper use of strictness (if you consider that to be an optimization rather than a semantically meaningful thing)
09:50:12 <Tekmo> k0ral: Yeah, the first function is applied to the error value and the second function is applied to the normal value
09:50:19 <Tekmo> k0ral: Check out the source code for it.  It's very simple
09:50:21 <jmcarthur> i also use ghc pragmas sometimes
09:50:21 <alex404> Tekmo: Or maybe criterion?
09:50:27 <jmcarthur> without profiling first
09:50:50 <alex404> Is there a good paper to go to to get an idea of what the compiler is actually doing?
09:50:59 <alex404> I have intuitions about laziness and such, but it's still quite the black box to me
09:51:00 <Tekmo> alex404: Well, criterion only hints at whether the optimization can be taking place by using speed as a proxy
09:51:10 <Tekmo> alex404: The only real proof is studying the core.  Everything else is just a guess
09:51:11 <augur> ski: hey, sorry, i had to go afk for a while there
09:51:18 <k0ral> Tekmo: well, the type was
09:51:19 <jmcarthur> i've never used unboxed types without profiling first, though, as an extreme example of what i would consider "too far" for simply defensive optimization
09:51:20 <alex404> Tekmo: Point noted.
09:51:28 <k0ral> Tekmo: enough to understand what was going on :)
09:52:03 <Tekmo> alex404: One good rule of thumb, though, is to use ghc's profiling tools to see where you actually need to worry about optimization
09:52:09 <jmcarthur> even studying the core is not really enough for a complete picture. both core and profiling can be misleading in various ways
09:52:19 <Tekmo> alex404: Just write the program in whatever style you find comfortable, then profile and see where it actually needs fixing
09:52:32 <jmcarthur> but i've never had to look at a lower level than core before
09:52:37 <Tekmo> alex404: I can't tell you how many times I've guessed where the bottleneck was and I was completely wrong
09:52:37 <jmcarthur> for ghc, at least
09:52:46 <confusing> tekmo++
09:52:49 <alex404> Tekmo: Yah. That's my normal procedure. I was just worried about this case with functions because it's so basic.
09:53:28 <alex404> jmcarthur: Do you know of a good paper/tutorial/whatever which could ease me into core and the workings of the compiler?
09:53:47 <Qtr> is there some sort of inheritance for ADTs? like if i have an ADT Board [Mark] and i want WinnableBoard [Mark] and all the functions that work on Board should work on WinnableBoard?
09:54:07 <jmcarthur> alex404: people often recommend the stg paper for learning about how the runtime works. it's really old and out of date, but it still gives reasonable intuitions
09:54:09 <jmcarthur> @where stg
09:54:10 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
09:54:21 <alex404> jmcarthur: Cheers
09:54:46 <Tekmo> I would recommend just staring at core for a while
09:54:48 <jmcarthur> alex404: as for core... i think ezyang has a series of blog posts showing the compilation of a program from haskell down to assembly along with the various steps. it's not a "how to read core" tutorial, but it's still educational
09:54:52 <jmcarthur> let me find that
09:55:02 <alex404> jmcarthur: That sounds awesome
09:55:03 <confusing> alex404: but honestly, have a look at profiling before you descend into core ...
09:55:18 <alex404> confusing: I'm versed in profiling
09:55:19 <jmcarthur> ah it's only one post: http://blog.ezyang.com/2011/04/tracing-the-compilation-of-hello-factorial/
09:55:29 <Tekmo> alex404: When learning core, start with a really simple program at first and try to see how it works
09:55:33 <alex404> confusing: It usually gets me what I want, indeed.
09:55:34 <confusing> alex404: okay, just wanted to be sure :-/
09:55:37 <Tekmo> alex404: Like, compile "main = return ()"
09:55:44 <alex404> confusing: Cheers :)
09:55:46 <Tekmo> alex404: Get your head around that, then work up a little bit
09:55:54 <alex404> Tekmo: Heh. Roger
09:55:57 <jmcarthur> alex404: that blog post really doesn't explain optimization, either
09:56:40 <Qtr> cant arbitrary be called by itself?
09:57:50 <alex404> Qtr: There's a few different ways to do it, depending on what you want to do. If you can draw a hierarchy of types, then you can create a tree of ADTs with functions operating on different levels of abstraction
09:58:50 <alex404> jmcarthur: Intuitions are more what I care about at the moment, so thanks.
09:59:20 <ski> augur : np, i'm also halfway-here :)
10:00:02 <ski> confusing : was that re my `map' command to mcstar ?
10:00:30 <augur> ski: im probably going to sleep a bit
10:00:38 <confusing> ski: yeah, map vs hand recursion
10:01:03 <mcstar> who woke me?
10:01:12 <mcstar> np, j/k
10:01:13 <Qtr> but like a function moveWin(move to position that wins you the game id there is such a position) in tictactoe , how would you test that with quickcheck? you need to generate a board where you can win in the next move and some where you cant...
10:01:36 <Qtr> seems quickCheck isnt that useful once you REALLY start to test things
10:01:59 <ski> s/command/comment/
10:02:06 <Tekmo> Qtr: See my latest post on purifying impure code for quickcheck: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
10:03:12 <ski> confusing : i'm not sure things like foof-loop or that Shivers' paper are the right way, but they sure are interesting anyway, noting real problems
10:03:27 <hiptobecubic> I was going to ask what about the scala implementation here is making it so much faster than the haskell one, but then i noticed that it was actually signficantly faster than everything but fortran so I guess it's probably not realistic to expect
10:03:31 <hiptobecubic> http://shootout.alioth.debian.org/u64q/performance.php?test=mandelbrot
10:04:16 <confusing> ski: i'll have a look at foof-loop, i just googled it :)
10:04:46 <mcstar> hiptobecubic: wtf, im sure the java version can be made as fast
10:05:09 <ski> confusing : <http://mumble.net/~campbell/scheme/foof-loop.txt> -- also you can ask Riastradh (the author) in #scheme if you have questions
10:05:40 <ski> confusing : the paper : Olin Shivers' "The Anatomy of a Loop: a story of scope and control" in 2005-09 at <http://www.ccs.neu.edu/home/shivers/papers/loop.pdf>,<http://lambda-the-ultimate.org/node/1014>
10:06:03 <mcstar> hiptobecubic: i very much despise on that page the sbcl implementation
10:06:04 <confusing> ski: yup, thanks
10:06:15 <hiptobecubic> mcstar, i'm not trying to troll here. I am just commenting that the haskell version looked pretty good to me, but the scala implementation is skunking C and C++ and Ada as well so, so i assume they are just leaning on a quirk maybe?
10:06:34 <hiptobecubic> mcstar, i don't know sbcl, but i'm sure most of these have a lot of room for improvement
10:06:39 <mcstar> hiptobecubic: i never said you were trollin...
10:06:51 <mcstar> hiptobecubic: the sbcl version is an ugly sob code
10:06:59 <mcstar> and the longest one of all
10:07:10 <hiptobecubic> mcstar, smaller pool of people working on it
10:07:19 <hiptobecubic> which is why i'm surprised at scala ahead of C/C++
10:07:30 <hiptobecubic> by almost 20%
10:07:51 <mcstar> im just saying, then certainly other codes can be rewritten, since scala is usually slower than java itself
10:08:13 <ocharles> baseless-assertion.jpg
10:08:19 <mcstar> hiptobecubic: whats the application that you are developing for the 48 cores?
10:09:22 <ski> > foldr ((:) . (^ 2)) (error "baseless-recursion") [0 ..]
10:09:24 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
10:09:44 <hiptobecubic> mcstar, nothing amazing. Awhile ago I wrote a monte carlo sim and was playing with repa. Then recently i remembered that there was that server sitting at the university....
10:10:09 <mcstar> hiptobecubic: cesc and i are writing MC too
10:13:26 <hiptobecubic> mcstar, i don't think I did a particularly great job. I'm not very experienced and I was intentionally overdoing somethings just to get the hand of using them.
10:13:44 <hiptobecubic> mcstar, are you guys using that MC monad?
10:14:24 <mcstar> sorry to disappoint you, but after a haskell version, i rewrote it in c++
10:15:07 <mcstar> i just added some heavy stencil to it, it became quite slow
10:15:10 <monochrom> sorry, what does the program do?
10:15:28 <mcstar> which one?
10:15:38 <monochrom> the one you rewrote in C++
10:16:11 <mcstar> theres a 2d lattice, of doubles, which represents a discretized scalar field
10:16:20 <mcstar> there is an energy expression for the states
10:16:27 <k0ral> Tekmo: actually, it doesn't fit exactly into what I'm needing
10:16:39 <mcstar> and you draw random numbers, apply the metropolis method, and update the lattice
10:16:50 <mcstar> and compute some statistics sometimes
10:17:01 <monochrom> ah, it's ok in c++ too
10:17:06 <Tekmo> k0ral: So what do you need to be able to do?
10:17:11 <mcstar> in my case, this expression is quite computational heavy
10:17:12 <k0ral> Tekmo: I would like something like mapEitherT but with the third argument being of type (a -> Either f b)
10:17:24 <donri> Tekmo: oh hi, did you miss my question on reddit
10:17:35 <k0ral> Tekmo: I guess I can write it myself, it's easy to implement
10:17:37 <Tekmo> donri: Let me check
10:17:48 <Tekmo> Wait, k0ral
10:17:51 <donri> Tekmo: http://www.reddit.com/r/haskell/comments/wtix3/purify_code_using_free_monads/c5gyzmi
10:17:55 <k0ral> Tekmo: sorry, not the 3rd argument but the 2nd
10:18:02 <mcstar> afk
10:18:04 <hiptobecubic> mcstar, what i'm doing isn't very heavy. I'm actually finding that the RNG eats most of my cpu time.
10:18:18 <mcstar> hiptobecubic: have you tried the gsl binding?
10:18:32 <Tekmo> k0ral: Oh, I see
10:18:33 <mcstar> it is pretty fast, 10M doubles in 1.6secs iirc
10:18:40 <Tekmo> k0ral: Yeah, you could probably just hand-write it
10:18:46 <hiptobecubic> mcstar, i was trying it today, but I don't think i'm doing it efficiently
10:18:58 <Tekmo> donri: Yes, I plan on moving my FreeT to a "transformers-free" package
10:19:08 <mcstar> hiptobecubic: what do you mean?
10:19:24 <Tekmo> There is only one thing I haven't decided
10:19:53 <hiptobecubic> mcstar, well I actually need to write some tests in C to compare. I don't know how fast it *should* be
10:20:01 <Tekmo> which is whether to keep it the way it is or rewrite Free to be : newtype FreeT f m r = FreeT { (r -> m r) -> (f (m r) -> m r) -> m r }
10:20:13 <mcstar> hiptobecubic: unfortunately, you cant request whole arrays of random numbers with gsl, the RNG interface doesnt support it, the QRNG crashes, and probably isnt a good idea
10:20:21 <donri> Tekmo: nice!
10:20:44 <mcstar> hiptobecubic: use gsl lib, or acml or mkl for best results
10:20:45 <hiptobecubic> mcstar, gsl does have that though, doesn't it?
10:20:50 <mcstar> hiptobecubic: yes
10:20:52 <Tekmo> donri: What did you want to use it for?
10:21:04 <nand`> Is ‘seq’ defined in Haskell or GHC-specific?
10:21:10 <donri> Tekmo: nothing specific planned, just seems nice to have
10:21:15 <hiptobecubic> mcstar, the fastest i've found so far has been System.Random.MWC
10:21:30 <donri> Tekmo: any particular reason you don't plan to merge with 'free'?
10:21:44 <Tekmo> So, actually, the goal was to merge with `transformers`
10:21:48 <Tekmo> I've been talking to Ross about it
10:21:53 <donri> ah
10:21:57 <Tekmo> But for now I think the conservative thing is to just keep it separate
10:21:59 <hiptobecubic> mcstar, hayoo doesn't find acml
10:22:06 <hiptobecubic> or mkl
10:22:08 <Tekmo> Ross has been wanting a FreeT-like type
10:22:14 <Tekmo> But his implementation is ugly :(
10:22:34 <mcstar> hiptobecubic: optimized scientific libraries by Amd and Intel
10:22:40 <donri> free's Free is a MonadTrans, but you say it's not lawful?
10:22:45 <Tekmo> That's right
10:22:49 <Tekmo> In fact
10:22:56 <mcstar> hiptobecubic: for your C test, not for haskell
10:22:58 <Tekmo> https://github.com/ekmett/free/issues/3
10:23:04 <Tekmo> That's where I brought up the issue with Edward
10:23:13 <Tekmo> and was the prelude to me creating FreeT
10:23:29 <donri> i see!
10:23:37 <Tekmo> Although, FreeT is not really my creation
10:23:43 <mcstar> hiptobecubic: though, you might be able to build some haskell binding on top of those, for example i could build the Numpy library with acml, instead of lapack
10:23:47 <Tekmo> I think the first popular implementation of it is Mario Blazevic's Coroutine type
10:23:58 <Tekmo> but I thought the scope of that library was too narrow and missed the parallel to Free
10:24:03 <Tekmo> which is why I renamed it and split it off
10:24:09 <k0ral> Tekmo: actually, I will just write f :: (e -> f) -> EitherT e m a -> Either f m a, then I will be able to use (>>=) directly
10:24:19 <k0ral> s/Either/EitherT
10:24:28 <mcstar> hiptobecubic: ill be back in 3/4 hours
10:24:53 <Tekmo> k0ral: Use the `fmapL` function in the errors package for that
10:25:09 <Tekmo> To save a few keystrokes
10:25:36 <Tekmo> Sorry, fmapLT
10:26:03 <parcs`> heh, the pascal implementation of mandelbrot used 8kb of memory
10:26:12 <hiptobecubic> :D
10:26:25 <Tekmo> http://hackage.haskell.org/packages/archive/errors/1.2.1/doc/html/Data-EitherR.html#v:fmapLT
10:27:07 <hiptobecubic> parcs`, no libc
10:27:11 <k0ral> Tekmo, parcs`: right, I think I've now achieved THE elegant solution, thank you for your help
10:27:16 <Tekmo> k0ral: Also, see if you can use the `catchT` or `handleT` functions, which seem to be a little bit close to what you have
10:27:36 <hpaste> timthelion pasted “a rellatively hard problem” at http://hpaste.org/71901
10:27:39 <timthelion> Dificulties arise in strange places sometimes... See paste,  can that function be written more simply?
10:27:43 <Tekmo> http://hackage.haskell.org/packages/archive/errors/1.2.1/doc/html/Data-EitherR.html#v:catchT
10:29:27 <donri> Tekmo: hm any reason to avoid control-monad-free?
10:29:34 <Tekmo> Yeah
10:29:42 <Tekmo> Let me pull up my control-monad-free rant :)
10:30:39 <Tekmo> Bleh, it's really buried in my comment history, but I can briefly sum it up
10:30:53 <Tekmo> So basically, the functional dependencies makes it really difficult to do anything
10:31:04 <Tekmo> If you define any sum functor, like the PipeF functor
10:31:13 <Tekmo> It is really difficult for it to infer the types correctly
10:31:24 <Tekmo> Even if you give it a type signature
10:31:27 <Tekmo> So I would have something like:
10:32:07 <Tekmo> yield :: b -> FreeT (PipeF a b) m r
10:32:22 <Tekmo> yield = liftF (Yield b ())
10:32:27 <Tekmo> And it would still fail to type-check
10:32:32 <Tekmo> So I would end up having to write something like
10:33:09 <confusing> timthelion: i think the MissingH package has functions for that. also the "split" package
10:33:17 <Tekmo> yield = (liftF :: ... ) ((Yield :: ...) b ())
10:33:22 <Tekmo> and with scoped type variables
10:33:25 <Tekmo> just to get it to type-check
10:33:27 <donri> sounds fun!
10:35:05 <GyorsCsiga> my head is borked from haskell :)
10:35:47 <Tekmo> :)
10:36:19 <geekosaur> haskell is definitely a head-expanding experience
10:36:24 <GyorsCsiga> I keep thinking imperatively, me thinks
10:36:43 <confusing> s/expanding/exploding
10:36:46 <GyorsCsiga> my mind wants to visualize things step by step
10:37:14 <nand`> What is meant by “spineless” and “tagless” in the “Spineless, tagless G-machine” ?
10:37:16 <ion> You can certainly think about pure and functional code step by step.
10:37:22 <GyorsCsiga> in a declarative language, is it only important to just know what the outcome should be and not visualze the parsing step by step?
10:37:30 <GyorsCsiga> ion, oh, really? how?
10:37:33 <donri> Tekmo: actually i have a vague idea for something that i want to use FreeT for; a framework for CLI programs. so i was thinking a free monad for programming the IO purely would be nice, but, being able to wrap IO would still be useful for when the free monad isn't enough?
10:37:34 <GyorsCsiga> please show me the way
10:37:58 <hape01> I think Haskell would be much easier for me if I forgot anything about assembler, pascal, java, python, php and sap abap.
10:38:08 <nand`> hape01: yes
10:38:12 <nand`> forget all about imperative languages
10:38:21 <Tekmo> donri: YOu are pretty much foreshadowing my next post on free monads
10:38:21 <ion> Iterate the evaluation of the thing in question step by step in your mind.
10:38:22 <hape01> prolog could help getting faster into haskell..... :-)
10:38:26 <donri> Tekmo: :)
10:38:30 <GyorsCsiga> it's not easy to forget :D
10:38:34 <hape01> :-)
10:38:42 <nand`> go back to drawing on the intuition from mathematics education
10:38:53 <Tekmo> donri: The idea behind FreeT is that it has all the nice algebraic reasoning properties of Free, and it only relies on the underlying monad being a monad
10:39:04 <ski> GyorsCsiga : "my mind wants to visualize things step by step" -- yes, this is an unfortunate consequence of focusing too much on operational details (unfortunate since it doesn't scale well)
10:39:05 <hape01> nand`: i think that is the point. come back to algebra
10:39:10 <Tekmo> donri: Even the monads with no denotation still obey the monad laws
10:39:16 <Tekmo> Therefore, FreeT lets you safely wrap those monads
10:39:25 <timthelion> confusing: I'm sure they do, but some things are just hard without mutability
10:39:36 <jfischoff> I feel like Shellac could use a free monad update : http://hackage.haskell.org/package/Shellac
10:39:42 <GyorsCsiga> ski, so what do you recommend I do to overcome this?
10:39:54 <ion> ski: Figuring out the most significant operational details may be a good thing when beginning.
10:39:56 <ski> GyorsCsiga : "oh, really? how?" -- do you know the `foldr' function ?, `map' ?
10:40:04 <donri> Tekmo: and you could still program code that don't need direct IO access purely and quickcheck test etc
10:40:06 <GyorsCsiga> I know map
10:40:10 <Tekmo> Right
10:40:15 <GyorsCsiga> since I known it from perl
10:40:16 <Tekmo> You would just swap out the base monad with Identity
10:40:19 <ski> ion : yes. only saying focusing too much on it is a mistake
10:40:30 <donri> Tekmo: or Monad m => m, even?
10:40:31 <nand`> GyorsCsiga: the key to thinking about functional algorithms iteratively is to think about them in terms of a sequence of expansion and reductions, one step at a time
10:40:34 <Tekmo> Yeah
10:40:35 <ion> ski: yeah
10:41:00 <Tekmo> The key thing about FreeT is that all the laws are correct as long as the base monad obeys the monad laws
10:41:04 <Tekmo> So you keep all the reasoning power
10:41:40 <confusing> timthelion: how do you mean mutability? i was mentioning MissingH because of your question about splitting a String
10:42:13 <Tekmo> The other nice thing about FreeT
10:42:19 <Tekmo> is that it lets you layer free monads
10:42:34 <Tekmo> It's an alternative to linear types (? I'm not sure that's the right word)
10:42:40 <timthelion> confusing: but even MissingH has to implement the function somehow
10:42:45 <Tekmo> So if you have two base functors you want to access, f and g
10:42:56 <Tekmo> But you already wrapped them in FreeT
10:43:01 <Tekmo> You can just stack the two FreeT's
10:43:07 <Tekmo> FreeT f (FreeT g m) r
10:43:12 <GyorsCsiga> nand`, could you paste me an example of a step by step functional algorithm? could we do it on the map function?
10:43:41 <nand`> let's do it on factorial
10:43:50 <GyorsCsiga> ok
10:43:58 <nand`> fac 0 = 1; fac n = n * fac (n-1) -- naive declaration for demonstrational purposes
10:44:05 <nand`> now if you want to figure out how, say, fac 3 works
10:44:23 <confusing> timthelion: oh i understand :) you wanted to know how to do this sort of thing, not some existing function. hang on.
10:45:21 <nand`> the first step is to expand this in your mind: 3 * fac (3-1)  ⇒  3 * fac 2; then expand again:  3 * (2 * fac 1)  ⇒  3 * (2 * (1 * fac 0))  and notice that fac 0 = 1  ⇒ 3 * (2 * (1 * 1));  now you can start reducing this again: 3 * (2 * 1) ⇒ 3 * 2 ⇒ 6
10:45:57 <Tekmo> GyorsCsiga: The reason functional programming works well is that it's easy to build complex solutions from composing a bunch of simpler solutions
10:46:10 <Tekmo> GyosCsiga: For example, a really simple implementation of factorial is just:
10:46:17 <Tekmo> fac n = product [1..n]
10:46:24 <Tekmo> Here, we've composed two simple solutions
10:46:38 <Tekmo> The first being Haskell's "enumFromTo" (implicit in the [a..b] syntax) and the "product" function
10:46:49 <ski> GyorsCsiga : consider this :
10:46:53 <ski>      take 4 (map (^ 2) [0 ..])
10:47:00 <ski>   =  take 4 (map (^ 2) (0 : [1 ..]))
10:47:03 <donri> Tekmo: how do free monads and gadts relate to one another? are they useful together or do free monads negate the need for gadts when you can have a free monad? excuse my newbiness :)
10:47:05 <ski>   =  take 4 (0 ^ 2 : map (^ 2) [1 ..])
10:47:11 <ski>   =  0 ^ 2 : take 3 (map (^ 2) [1 ..])
10:47:16 <ski>   =  0 : take 3 (map (^ 2) [1 ..])
10:47:18 <donri> Tekmo: they just vaguely make me think of the other
10:47:20 <ski>   =  0 : take 3 (map (^ 2) (1 : [2 ..]))
10:47:28 <ski>   =  0 : take 3 (1 ^ 2 : map (^ 2) [2 ..])
10:47:34 <ski>   =  0 : 1 ^ 2 : take 2 (map (^ 2) [2 ..])
10:47:39 <ski>   =  0 : 1 : take 2 (map (^ 2) [2 ..])
10:47:43 <ski>   =  0 : 1 : take 2 (map (^ 2) (2 : [3 ..]))
10:47:49 <ski>   =  0 : 1 : take 2 (2 ^ 2 : map (^ 2) [3 ..])
10:47:54 <ski>   =  0 : 1 : 2 ^ 2 : take 1 (map (^ 2) [3 ..])
10:47:54 <timthelion> Tekmo: and the reason it works poorly, is that those compositions break every time the smallest change in data type occurs,  see cabal's package version ranges...
10:47:59 <ski>   =  0 : 1 : 4 : take 1 (map (^ 2) [3 ..])
10:48:03 <ski>   =  0 : 1 : 4 : take 1 (map (^ 2) (3 : [4 ..]))
10:48:09 <ski>   =  0 : 1 : 4 : take 1 (3 ^ 2 : map (^ 2) [4 ..])
10:48:23 <ski>   =  0 : 1 : 4 : 3 ^ 2 : take 0 (map (^ 2) [4 ..])
10:48:29 <ski>   =  0 : 1 : 4 : 9 : take 0 (map (^ 2) [4 ..])
10:48:30 <ski>   =  0 : 1 : 4 : 9 : []
10:48:35 <hughfdjackson> what is going on?
10:48:39 <EmilyS> no idea
10:48:42 <hughfdjackson> :p
10:48:42 <timthelion> ski, hpaste?
10:48:43 <ski> which will be pretty-printed as `[0,1,4,9]'
10:48:43 <ocharles> ski is above paste bins, apparently
10:48:50 <Tekmo> donri: I'm a newb, too!  So as far as I can tell, a GADT's main purpose is to implement some form of type-equality and is technically orthogonal to the purpose of a free monad
10:49:01 <EmilyS> pastie.org
10:49:03 <Tekmo> donri: There was a great discussion in the comments section of my GADTs post about the bare minimum that a GADT provides
10:49:28 <Tekmo> donri: and it basically boils down to implementing a way to distinguish type equality
10:49:33 <ski> GyorsCsiga : the idea here is to see how the recursive calls to `take' and `map' gets intereleaved
10:49:51 <donri> Tekmo: i guess they remind me of each other because both are sort of used for defining DSLs in algebraic datatypes
10:49:55 <Tekmo> Oh
10:49:59 <Tekmo> Did you read my GADTs post?
10:50:03 <Tekmo> I basically discuss that relationship
10:50:09 <donri> hm, don't remember...
10:50:15 <GyorsCsiga> ski, interleaved with what each function returns?
10:50:17 <Tekmo> I'll link it
10:50:23 <Tekmo> http://www.haskellforall.com/2012/06/gadts.html
10:50:26 <Tekmo> The basic idea is that
10:50:28 <confusing> @let split needle haystack = filter (\(a, b) -> isJust b) $ zip (inits haystack) $ map (stripPrefix needle) (tails haystack) -- timthelion
10:50:29 <Tekmo> For libraries like
10:50:30 <lambdabot>  Defined.
10:50:33 <Tekmo> `prompt` and `operational`
10:50:37 <confusing> > split "cd" "abcdef"
10:50:39 <lambdabot>   Ambiguous occurrence `split'
10:50:39 <lambdabot>  It could refer to either `L.split', defined a...
10:50:39 <Tekmo> They are basically isomorphic to free monads
10:50:47 <confusing> oh great ... :(
10:50:56 <confusing> @let spli needle haystack = filter (\(a, b) -> isJust b) $ zip (inits haystack) $ map (stripPrefix needle) (tails haystack)
10:50:57 <Tekmo> And the isomorphism (according to Edward) is
10:50:57 <lambdabot>  Defined.
10:51:03 <confusing> > spli "cd" "abcdef"
10:51:04 <Tekmo> Program f = Free (Coyoneda f)
10:51:06 <lambdabot>   [("ab",Just "ef")]
10:51:10 <confusing> > spli "xy" "abcdef"
10:51:12 <lambdabot>   []
10:51:14 <Tekmo> And the post I just linked you shows one direction of the isomorphism
10:51:16 <ski> GyorsCsiga : in a call `take n ...' where `n' is larger than zero, that forces `...' to be evaluated to either `[]' or to `... : ...' form
10:51:21 <nand`> GyorsCsiga: going beyond such verbose ‘example cases’, if I'm writing an algorithm (ie. function) I think about data and how I want to transform it: say, ‘given some list, I first want to square each element, then I want to chop this off after the fourth element’
10:51:28 <confusing> ^^ some output munging required, but you get the idea :)
10:51:36 <nand`> and voila, I have the algorithm ski used as an example: take 4 . map (^2)
10:51:56 <ski> GyorsCsiga : and in the above case, that causes `map (...) ...' to evaluate one "step" -- but first the list `...' here must be evaluated to `[]' or `... : ...' form
10:52:19 <ski> and `[n ..]' evaluates in one step to `n : [n+1 ..]'
10:52:31 <ski> @where stepeval
10:52:31 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
10:52:35 <ski> GyorsCsiga : also see ^
10:53:08 <fexilal> is anyone having trouble accessing haskell.org/platform ?
10:53:16 <nand`> “step _: Not implemented: EnumFrom (Lit (Int 1))”
10:53:25 <confusing> timthelion: hang on. i think i can come up with a better way
10:53:26 <Tekmo> I can access it
10:53:45 <ski> GyorsCsiga : "interleaved with what each function returns?" -- yes, i mean that first the `[n ..]' gets to generate one more element, then the `map' call gets to evaluate one more step, transforming that element, then `take' passes that element through itself
10:54:09 <ski> GyorsCsiga : until `take' decides it doesn't want more elements, at which point the rest of the `map' and `[n ..]' calls are just simply discarded
10:55:34 <Saizan> Tekmo: btw, CoYoneda is as much a GADT as Program is, they both just use existential quantification
10:56:18 <GyorsCsiga> i'm trying that stepeval tool, how do I make a call after I've declared the function?
10:56:45 <GyorsCsiga> and for some reason this fails http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+fac+0+%3D+1%3B+fac+n+%3D+n+*+fac+%28n-1%29%0D%0A
10:56:47 <Saizan> GyorsCsiga: use let .. in ..
10:56:48 <Tekmo> Saizan: Could you elaborate on that?  I just want to understand the relationship between GADts and existential quantification
10:56:57 <GyorsCsiga> ah 'in'
10:57:31 <GyorsCsiga> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+fac+0+%3D+1%3B+fac+n+%3D+n+*+fac+%28n-1%29+in+3%0D%0A this did not provide me any steps, what did I do wrong? :)
10:58:10 <Saizan> Tekmo: it's roughly like GADTs = ExistentialQuantification + type equalities
10:58:15 <Tekmo> Yeah
10:58:24 <Tekmo> My post coered the existentialquantification part
10:58:31 <Tekmo> But I didn't know if that also covered type equality or not
10:58:36 <nand`> GyorsCsiga: I think you meant ‘in fac 3’ not ‘in 3’
10:58:41 <nand`> the former is just a rather verbose way of saying ‘3’
10:58:43 <GyorsCsiga> oops!
10:59:16 <hiptobecubic> mcstar, i guess MWC is pretty fast actually.
10:59:22 <GyorsCsiga> this tool is awesome, what is it powered by?
10:59:31 <Qtr> Anyone here deployed a haskell app at heroku?
10:59:50 <Saizan> Tekmo: your List type uses both features, Program uses only ExistentialQuantification
10:59:51 <GyorsCsiga> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+fac+0+%3D+1%3B+fac+n+%3D+n+*+fac+%28n-1%29+in+fac+3%0D%0A
10:59:52 <hiptobecubic> mcstar, I'm using gsl to compare and I can't beat it in C using any of the rngs that gsl provides
10:59:58 * GyorsCsiga happy
11:00:10 <hiptobecubic> for an equivalent algorithm i mean. I could probably write these loops better
11:00:10 <Tekmo> Saizan: Thanks.  Now I understand.
11:00:15 <nand`> GyorsCsiga: the ‘Source’ link at the top might help :)
11:00:45 <GyorsCsiga> nand` haha
11:00:48 <GyorsCsiga> sorry, I didn't see that
11:00:59 <Tekmo> Saizan: So basically any GADT which is also a Functor is basically only using the ExistentialQuantificaiton aspect, but ones which are not and use the last type parameter as an index are using the type equality aspect, too
11:02:11 <Qtr> can i tell ghc to compile to linux from windows?
11:02:21 <geekosaur> no cross compilation ability, no
11:02:39 <geekosaur> you could run linux with a ghc installation in a vm
11:02:52 <hiptobecubic> mcstar, http://hpaste.org/71906
11:02:56 <Tekmo> Ok, here's a dumb question.  Does the LLVM backend permit cross-compilation?
11:03:02 <Saizan> Tekmo: i don't think that's generally correct, a type could use the first argument as an index (i.e. a parameter which varies between constructors, which is where the type equalities are used) and still have a Functor instance
11:03:03 <jfischoff> Qtr: I haven't deployed to heroku, but I think blackdog was working on a buildpack. I don't know the status
11:03:24 <GyorsCsiga> btw, guys, thanks for all the info, I need to sit with this for a while
11:04:04 <Tekmo> Saizan: Well, I meant only in its capacity to mess with the last type variable
11:04:11 <Saizan> Tekmo: e.g. if the length index comes first for List, then you can have instance Functor (List n) where
11:05:02 <Saizan> Tekmo: ah, maybe that holds then
11:05:23 <Tekmo> Saizan: Yeah, I understand that from Conor McBride's paper, where he makes things functors over the second-to-last type variable
11:05:24 <jfischoff> Tekmo: I know with the iOS patch you can (at least to arm). I vaguely remember someone in #ghc saying there was some work in that direction in HEAD.
11:05:39 <Tekmo> jfischoff: Thanks
11:05:50 <Saizan> Tekmo: which?
11:05:53 <timthelion> confusing: and what is your better way?
11:05:59 <Tekmo> Kleisli Arrows of Outrageous Fortune
11:06:03 <Tekmo> His "IFunctor" class
11:06:20 <jmcarthur> Tekmo: afaik the llvm does not officially support that in any way, but i assume that it would be possible with some work. i think things like the runtime and stuff still have to be ported
11:06:29 <jmcarthur> *the llvm backend
11:12:21 <mcstar> hiptobecubic: im back
11:13:32 <confusing> > let split needle haystack = listToMaybe $ catMaybes $ zipWith (\l r -> case stripPrefix needle r of Just x -> Just (l,x) ; Nothing -> Nothing) (inits haystack) (tails haystack) in split "cd" "abcdef" -- timthelion, sorry, was fiddling with it too much :-/ this might be clearer, or maybe not. feel free to ask questions in here :) i gotta run right now but folks will surely help you
11:13:33 <lambdabot>   Just ("ab","ef")
11:13:54 <confusing> i still think it could be a little smoother
11:14:10 <confusing> anyhoo, see you later
11:14:28 <mcstar> szia GyorsCsiga
11:15:04 <timthelion> confusing: thanks
11:15:30 <confusing> you're welcome
11:15:44 <mcstar> hiptobecubic: gsl_rng_set(gen, i); whats this for?
11:15:57 <shapr> random number generator, set ?
11:16:03 <mcstar> are you seeding the generator each time?
11:16:05 <mcstar> what for?
11:16:37 <mcstar> seeding frequently the generator actually diminishes its properties
11:16:48 <GyorsCsiga> szia
11:18:37 <hiptobecubic> mcstar, because I reset the generator each 365 in the haskell implementation as well, just by the way it's written right now.
11:19:03 <mcstar> thats not a good idea
11:19:04 <hiptobecubic> mcstar, yes, it should and will be changed eventually, but i'm not worried about the statistical properties of the rng at the moment.
11:19:19 <mcstar> ill look at the MWC package
11:21:50 <hiptobecubic> mcstar, i'm working on the best way to approach it. I need strings of usually less than 1000 random variates, but I need maybe 100000 of them in the actual program. I can't use a global rng because it ruins the parallelism. Since most of time is spent computing random numbers, it doesn't help to generate them in serial ahead of time
11:22:16 <jfischoff> idiom brackets QQ: https://github.com/benmachine/applicative-quoters/blob/master/Control/Applicative/QQ/Idiom.hs
11:22:46 <ski> GyorsCsiga :)
11:23:27 <hiptobecubic> so i have a seed which i specify at the beginning that i use to generate random ints, which then serve as seeds themselves later. I haven't yet investigated how that does or does not affect the quality of the variates as a whole
11:23:31 <ski> preflex: xseen vixey
11:23:31 <preflex>  vixey was last seen on freenode/##C 2 years, 46 days, 6 hours and 49 seconds ago, saying: emphasis on 'might' :)
11:23:42 * ski misses vixey ..
11:24:04 <hiptobecubic> :/
11:24:58 <Qtr> QUickCheck    A function like moveWin(move to position that wins you the game if there is such a position) in tictactoe , how would you test that with quickcheck? you need to generate a board where you can win in the next move and some where you cant...
11:25:08 <Tekmo> Qtr: Did you read my blog post?
11:25:26 <Tekmo> http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
11:25:41 <jfischoff> @quote vixey
11:25:42 <lambdabot> vixey says: I've seen haskell by stubborns which is like foo_bar_baz concatMap . filter notNull my_list. it's so awful to read
11:26:04 <copumpkin> ski: she's been around under different nicks since then, but not in at least a year, as far as I know
11:27:09 <hiptobecubic> Tekmo, i read it but i didn't get it :)
11:27:21 <hiptobecubic> I kind of did, but it was a bit strange
11:27:31 <Tekmo> Are you familiar with the Prompt or Operational packages?
11:27:45 <copumpkin> Tekmo on IRC
11:27:46 * copumpkin faints
11:27:49 <hiptobecubic> You are using data types to represent the actions so that they don't "do" until you match them later in the run func?
11:27:50 <Tekmo> Hi!
11:27:54 <Tekmo> Right
11:27:56 * copumpkin has fainted and can't respond
11:27:59 <Tekmo> It's just like prompt/operational
11:28:03 <Tekmo> You encode your behavior as a datatype
11:28:05 <hiptobecubic> I haven't used them
11:28:09 <Tekmo> Oh
11:28:14 <shapr> copumpkin: Who's Tekmo?
11:28:17 <GyorsCsiga> I have a question thats probably silly but functions in haskell are still done FILO, right?
11:28:20 <Tekmo> Me!
11:28:24 * shapr whispers quietly to copumpkin
11:28:28 * copumpkin has fainted and can't respond to shapr either
11:28:30 <shapr> Tekmo: oh hai! I didn't see you there!
11:28:34 <Tekmo> :)
11:28:37 <shapr> Tekmo: Hi! Who are you?
11:28:45 <Tekmo> Gabriel Gonzalez
11:28:47 * copumpkin wakes up
11:28:47 <hiptobecubic> GyorsCsiga, i'm not sure what you mean, but i think ou have a conceptual problem with haskell's evaluation model
11:28:51 <copumpkin> Tekmo is Tekmo!
11:28:58 <copumpkin> (yes, "is" is a reflexive relation)
11:29:01 <shapr> Right, of course.
11:29:07 <Tekmo> I'm just a graduate student
11:29:13 <copumpkin> shapr: pipes and stuff :)
11:29:15 <Tekmo> Yeah
11:29:16 <shapr> Oh, I'm an undergrad!
11:29:22 <otters> Ahh college students
11:29:30 <hiptobecubic> i won't be soon :( i'm getting old
11:29:31 <shapr> otters: Somebody has to love them.
11:29:40 <otters> I'm not in college yet
11:29:50 <Tekmo> hiptobecubic: So the idea behind prompt/operational is pretty powerful
11:29:54 <shapr> hiptobecubic: It's okay, you can be in college AND old! I'm proof!
11:30:16 <hiptobecubic> shapr, studying what and where and how old ? :)
11:30:16 <Tekmo> hiptobecubic: Rather than hard-coding in your effects, you simply specify a data representing the effects, then you can choose whatever backend you want to interpret them
11:30:17 <GyorsCsiga> hiptobecubic, probably so, could you refer me to a URL that might clear things up?
11:30:29 <shapr> hiptobecubic: Computer Science, una.edu, 40
11:30:36 <shapr> hiptobecubic: This is like a/s/l for #haskell, right?
11:30:40 <Tekmo> hiptobecubic: So, for example, you could write a game engine, and then you could write a backend for different platforms, like  GUI or terminal or an xbox
11:30:40 <jfischoff> shapr: your not old
11:30:45 <hiptobecubic> Can someone else point GyorsCsiga to something. I don't know anything about anything.
11:30:48 <jfischoff> :)
11:30:53 <shapr> jfischoff: Ha, thanks
11:30:55 <hiptobecubic> 16/f/cali
11:31:13 <MostAwesomeDude> 17/whatever you want/whereever you want
11:31:16 <hiptobecubic> Is the only acceptable response to a/s/l, i believe.
11:32:08 <shapr> Isn't that what vixen says?
11:32:23 <GyorsCsiga> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+fac+0+%3D+1%3B+fac+n+%3D+n+*+fac+%28n-1%29+in+fac+3%0D%0A looking at the parantheses in 8-11, it gives me the impression that things are done FILO
11:32:46 <Tekmo> GyorsCsiga: One does not simply "do" things in Haskell
11:32:57 <Qtr> shapr: what did you do beforr?
11:32:59 <GyorsCsiga> Tekmo, huh?
11:33:08 <MostAwesomeDude> Tekmo: do { putStrLn "Sure they do!" }
11:33:13 <Tekmo> :)
11:33:17 <MostAwesomeDude> :3
11:33:24 <Tekmo> The point is to throw out your conceptions about evaluation order
11:33:35 <shapr> Qtr: Oh, I had a career and stuff. What about you?
11:33:43 <GyorsCsiga> no evaluation order? :S
11:33:44 <Tekmo> But since Haskell is lazy, it only evaluates the bare minimum necessary to complete an expression
11:34:07 <Tekmo> So technically evaluation is "outside to in"
11:34:08 <Qtr> in university, studying cs, 22 years old. studying haskell on the side
11:34:12 <ksf> somehow introducing another IL to detangle my code seems like an outstanding idea, the only problem is that I've got no idea how that IL could look except slightly reduced versions of the surrounding ILs.
11:34:20 <BMeph> One does not simply foxtrot through Haskell...whatever that means. :)
11:34:23 <shapr> Qtr: I was a self-employed Python/Zope/Plone coder for about seven years, that was fun.
11:34:26 <ksf> ...and what overlap there is seems utterly meaningless on its own.
11:34:41 <hiptobecubic> Tekmo, sounds useful
11:34:53 <Tekmo> hiptobecubic: very much so!
11:35:12 <Tekmo> I wrote an even longer post on free monads here:
11:35:25 <Tekmo> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
11:36:03 <GyorsCsiga> oh well, I think I'll get "it" eventually… I must be diligent :D
11:36:16 <Tekmo> GyorsCsiga: It's important to break things into simpler problems
11:36:30 <Tekmo> Otherwise the code is no easier to write than in an imperative language
11:36:34 <ksf> all in all, every single bleeding addition to the code is a choice between code duplication and yet another variable that overcomplicates the code.
11:36:48 <otters> if you're writing a custom monad for your library, is it good practice to put it in Control.Monad.Libname or Libname.Monad or what?
11:37:00 <Tekmo> Control.Monad.Libname
11:37:10 <Tekmo> I think Hackage actually restricts the set of top-level names
11:37:12 <Qtr> shapr: cool
11:37:12 <GyorsCsiga> so the steps in stepval aren't necessarily in the order of how haskell would evaluate things, it's just for the mere mortals to understand?
11:37:26 <shapr> Qtr: Where are you in uni?
11:37:28 <otters> I see
11:37:47 <Qtr> shapr: finished 1st year
11:38:05 <ksf> in general, it's the generated code that is too bleeding complex.
11:38:09 <Tekmo> GyorsCsiga: The trick is not really worry about evaluation order
11:38:20 <Tekmo> GyorsCsiga: Just ask yourself what you are computing
11:38:24 <Tekmo> and compute it
11:38:30 <shapr> Qtr: Oh that's good. I'm a junior, aka third year. But this is actually my ... seventh or eight year of attending classes.
11:39:17 <GyorsCsiga> Tekmo, ok, gotcha… just think about what it should do and not how it does
11:39:22 <Tekmo> Right
11:39:31 <ksf> hey. I got kicked out in the 9th (of 6) semesters.
11:39:53 <ksf> no, 5.
11:40:40 <ksf> ...what I didn't realise back then was that with all Fs in the courses I never attended or finished, I was still eligible to graduate.
11:40:59 <Qtr> ksf: why were you kicked out?
11:41:16 <ksf> because they didn't want the average study time to raise.
11:41:33 <Qtr> were you being lazy? why didnt you finish?
11:41:46 <ksf> officially, for "administrative reasons" .
11:42:03 <ksf> I attended and had good grades in all the courses that matter.
11:42:47 <ksf> but then there's economy, advanced electronics, fucking access fucking "database", and similar stuff.
11:43:00 <mcstar> hiptobecubic: i get: haskell 3.4s C: 3.8s
11:43:09 <mcstar> linking with gslcblas
11:43:29 <ksf> and having a job while still studying doesn't improve chances to graduate.
11:43:36 <mcstar> probably, the gaussian algorithm is better in MWC than in GSL
11:43:43 <ksf> in the end, it just doesn't matter.
11:43:51 <Tekmo> You'll do fine
11:44:23 <Qtr> how do I give haddock link destionations? for exmaple for Arbitrary, ghc.Show etc.
11:44:35 <Qtr> also can i teel cabal to run haddock after compiling?
11:44:40 <ksf> graduation is for people who a) want a room in the ivory tower or b) can't convince otherwise.
11:44:50 <Tekmo> Qtr: I don't know.  As far as I can tell, module link destinations only work within your project, not for other packages
11:44:58 <hiptobecubic> Tekmo, this is crazy.
11:44:59 <jmcarthur> Tekmo: have you given any thought to transforming pipes with codensity or edwardk's yoneda trick for the speedup?
11:45:06 <Tekmo> Yes, I have
11:45:16 <jmcarthur> seems like it will be tougher with the indexed monad
11:45:25 <Tekmo> I'm actually considering releasing a "transformers-free" package with the codensity version of FreeT and basing pipes on that
11:45:32 <jmcarthur> ah nice
11:45:33 <Tekmo> I also have other speed improvements in the work
11:45:41 <Tekmo> For example, I've found a way to decompose all extensions
11:45:46 <Tekmo> So that for any given application
11:45:50 <Tekmo> You only use the extensions you need
11:45:55 <jmcarthur> you might be interested to know that i've been porting pipes to ocaml
11:45:58 <Tekmo> So you incur no overhead from the other extensions
11:46:02 <Tekmo> Cool!
11:46:06 <Tekmo> Let me just say
11:46:10 <Tekmo> I'm abandoning the indexed monad
11:46:16 <jmcarthur> oh? :(
11:46:17 <Tekmo> I've figured out how to do everything in ordinary monads now
11:46:19 <jmcarthur> oh!
11:46:19 <Tekmo> Including cleanup
11:46:25 <Tekmo> The semantics are quite nice
11:46:39 <Tekmo> It's going to be a really exciting release
11:46:46 <jmcarthur> is it in the public repo yet?
11:46:48 <Tekmo> No
11:46:51 <Tekmo> It's completely in my head
11:46:53 <jmcarthur> ah
11:46:55 <Tekmo> :)
11:47:03 <Tekmo> I usually do all of my coding just days before each release
11:47:10 <jmcarthur> heh, i know how that goes
11:47:13 <Tekmo> the vast majority of the time I just think and type into an empty vi buffer
11:47:27 <Qtr> ksf: i had a guy kind of like you in my class, he was still 1st grade after 3 years, good programmer, now he has a job as programmer instead of graduating :). But i like electronics and economy so i i will finish
11:47:28 <jmcarthur> yeah. most of my more interesting coding projects are also that way
11:47:47 <Tekmo> But if you want to know about cleanup
11:47:51 <Tekmo> The basic idea is quite simple
11:47:59 <jmcarthur> i'd love to
11:48:06 <Tekmo> In addition to transmitting finalizers you also transmit a reinitializer
11:48:11 <jmcarthur> we already have some infrastructure for monads, but indexed monads we do not have yet
11:48:12 <applicative_> Qtr there are a couple of 'documentation' variables in ~/.cabal/config
11:48:20 <Tekmo> Which simply does a check to see if the current pipe has been closed and if so reinitializes it
11:48:34 <Tekmo> So when you "close" a pipe, you're really not closing it permanently
11:48:41 <Tekmo> Instead you close it until you await from it again
11:48:56 <Tekmo> For pipes that cannot be reopened, the reinitializer just yields an exception
11:49:03 <Tekmo> And I've found a way to encode exceptions, too
11:49:06 <Tekmo> using EitherT
11:49:25 <Tekmo> So really, the semantics of close are now just "close until I need you again"
11:49:42 <jmcarthur> i'm pleased about the exceptions news, but my gut reaction to reinitializers is discomfort...
11:49:42 <Tekmo> allowing you to release a resource for a sustained period of time when you don't need it
11:50:10 <Tekmo> So, if you want type-safe finalization
11:50:17 <Tekmo> Then you need the indexed monad
11:50:33 <jmcarthur> i see
11:50:44 <applicative_> Qtr if you have been haddocking from the outset, haddock will find the links or complain; my local /.cabal/doc is completely interconnected
11:50:46 <jmcarthur> so this idea doesn't actually subsume the indexed monad
11:50:52 <Tekmo> The best you can do with an ordinary monad is to simply receive errors if you try to reacquire an unopenable resource
11:51:22 <Tekmo> However, I won't remove Frame from pipes just yet
11:51:34 <Tekmo> My plan is to first build the extension framework on top of pipes
11:51:40 <timthelion> !she
11:51:44 <Tekmo> And if people like it enough, then I can do the exact same extensions for frames, too
11:52:23 <jmcarthur> extensions = the various features offered by pipes?
11:52:24 <Qtr> applicative_: yes but these are for ghc-stuff like Data.Maybe etc, do i have to haddock thsoe first?
11:52:27 <Tekmo> Yes
11:52:30 <Tekmo> Extensions would be things like:
11:52:43 <Tekmo> Parsing, exception handling, folding, resource finalization
11:52:51 <Tekmo> All of those I've already solved and encoded as separate extensions
11:53:38 <jmcarthur> is this the coproduct of functors transformed by free thing, or something else?
11:53:49 <Tekmo> No, it's quite easy
11:53:59 <Tekmo> The basic idea is that every extension is encoded as a monomorphism
11:54:03 <Tekmo> that defines a functor
11:54:06 <Tekmo> I will explain that
11:54:16 <Tekmo> So imagine that I have an existing pipe type
11:54:21 <Tekmo> Not necessarily the base type
11:54:27 <Tekmo> That has some sort of identity and composition:
11:54:30 <Tekmo> idP, <+<
11:54:45 <Tekmo> A monomorphism is a function f that has a left inverse, g, such that:
11:54:49 <Tekmo> g . f = id
11:55:02 <Tekmo> Given a monomorphism, you always get a new category for free
11:55:03 <jmcarthur> okay
11:55:19 <jmcarthur> not sure i see how
11:55:23 <twanvl_> you do?
11:55:24 <Tekmo> I know, I will explain :)
11:55:38 <Tekmo> First, let's use fmap as an example
11:55:41 <Tekmo> The functor laws say that:
11:55:48 <Tekmo> fmap (f . g) = fmap f . fmap g
11:55:50 <Tekmo> fmap id = id
11:55:57 <Tekmo> Now, replace fmap with a monomorphism
11:56:07 <Tekmo> f (p1 <-< p2) = f p1 <+< f p2
11:56:20 <Tekmo> f id? = idP
11:56:32 <Tekmo> If it's a monomorphism, then it's invertible, so we then get
11:56:40 <Tekmo> p1 <-< p2 = g (f p1 <+< f p2)
11:56:45 <Tekmo> id? = g idP
11:56:48 <Tekmo> We get a new category for free
11:56:52 <Tekmo> That is correct by construction
11:57:02 <Tekmo> The derived category satisfies all the category laws if the base category does
11:57:08 <jmcarthur> okay, i follow
11:57:22 <Tekmo> So what I do is encode each of these extensions as a monomorphism
11:57:25 <twanvl_> so f and g are functors?
11:57:26 <timthelion> I'm shocked, that cabal install darcs doesn't just crash with "darcs command not found" ;)
11:57:29 <Tekmo> Not functors
11:57:32 <Tekmo> functions
11:57:34 <mcstar> hiptobecubic: well, MWC generates 10M random doubles in 1.2s, but with acml i can do it in 0.25s
11:57:41 <mcstar> hiptobecubic: so its a no-go
11:57:43 <Tekmo> Here's a simple example
11:57:47 <Tekmo> Where I will use an isomorphism
11:57:53 <Tekmo> f = runEitherT
11:57:57 <Tekmo> g = EitherT
11:58:09 <Tekmo> p1 <-< p2 = EitherT $ runEitherT p1 <+< runEitherT p2
11:58:09 <jmcarthur> mcstar: wow, i always considered mwc to be pretty fast
11:58:12 <coppro> Tekmo: where did you get that definition of a monomorphism?
11:58:19 <Tekmo> Wikipedia
11:58:23 <coppro> it's wrong :/
11:58:29 <Tekmo> What's the correct term?
11:58:32 <Tekmo> section?
11:58:41 <timthelion> mcstar: doesn't the time usually depend on the level of randomnes?
11:58:47 <mcstar> jmcarthur: it seems to be faster than gsl for a normal distribution
11:58:53 <mcstar> but i need uniform, unlike hiptobecubic
11:58:58 <coppro> Tekmo: uh, it's either section or retraction; I mix the two up
11:59:00 <jmcarthur> heh, that *also* surprises me
11:59:04 <Tekmo> Ok, then I'll use section
11:59:09 <coppro> let me check
11:59:09 <Tekmo> That was the other one I saw
11:59:16 <Tekmo> g would be the retraction
11:59:20 <Tekmo> f is the section
11:59:22 <mcstar> jmcarthur: acml is the amd optimized lib for my cpu
11:59:30 <mcstar> jmcarthur: written in fortran
11:59:34 <jmcarthur> oh, i see
11:59:40 <jmcarthur> now i am no longer surprised about that at all
11:59:44 <mcstar> XD
12:00:07 <coppro> Tekmo: a split monomorphism
12:00:12 <Tekmo> Ok
12:00:14 <Tekmo> split monomorphism
12:00:18 <Tekmo> Thanks :)
12:00:22 <Tekmo> I always appreciate corrections
12:00:37 <Tekmo> So anyway, back to the example:
12:00:38 <coppro> if es = 1, then s is a section of e and e is a retraction of s
12:00:40 <Tekmo> p1 <-< p2 = EitherT $ runEitherT p1 <+< runEitherT p2
12:01:04 <Tekmo> In the above code, runEitherT is the section and EitherT is the retraction
12:01:08 <Tekmo> Technically, an isomorphism
12:01:09 <coppro> all split monos are monos, but the reverse is not necessarily true :)
12:01:16 <Tekmo> but all I need is a split monomorphism
12:01:23 <coppro> it's true in the category of sets, but not in posets
12:01:45 <Tekmo> Good, now I won't have to worry about reddit tearing me a new one on terminology in the comments section :)
12:01:45 <coppro> (ok, it Set it's not actually true for monos coming from the empty set)
12:01:49 <coppro> haha
12:02:03 <Qtr> when would you actually use id?
12:02:03 <pcapriotti> I think that should be called a faithful functor, actually
12:02:09 <Tekmo> Paolo!
12:02:12 <pcapriotti> it's the morphism map of a faithful functor
12:02:14 <Tekmo> Yeah
12:02:17 <Tekmo> that's exactly it!
12:02:17 <pcapriotti> Tekmo: hi :)
12:02:21 <Tekmo> However
12:02:27 <Tekmo> I'm actually doing something slightly more general
12:02:30 <Tekmo> than what I just described
12:02:35 <Tekmo> that's just a first approximation
12:02:38 <jmcarthur> my "education" on category theory is so informal anyway that i've be afraid to use new terminology at all in a public place full of haskellers
12:02:49 <Tekmo> So anyway,
12:02:50 <jmcarthur> *i'd
12:03:07 <Tekmo> For error handling, the simple way you can implement it using a split monomorphism
12:03:13 <jfischoff> > all id [True, False, True]
12:03:13 <Tekmo> is to use runEitherT and EitherT
12:03:14 <lambdabot>   False
12:03:23 <hiptobecubic> Tekmo, these pipes feel a lot like generators in python
12:03:30 <hiptobecubic> Tekmo, only more organized...
12:03:31 <Tekmo> They generalize generators
12:04:10 <Tekmo> For example, let's say you want simple folding
12:04:22 <Tekmo> where every pipe yields a Nothing before done
12:04:28 <jmcarthur> brb while the conversation is on generators...
12:04:30 <Tekmo> Then the section is:
12:04:46 <Tekmo> f p = (Just <$> p) <* yield Nothing
12:05:00 <Qtr> what does haddock output?
12:05:02 <Tekmo> And the retraction just unwraps all Justs and discards Nothing
12:05:15 <hiptobecubic> mcstar, ah ok. I'd expect something like acml to be faster for certain. I assume MWC is generic
12:05:17 <Tekmo> This then automatically forms a correct category that lets you intercept upstream termination
12:05:25 <applicative_> > foldr (.) id [(+1), (*3), (+2)]  -- Qtr
12:05:26 <hiptobecubic> mcstar, i don't have acml or mkl though
12:05:27 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
12:05:27 <lambdabot>    arising from a use of `...
12:05:37 <applicative_> grrr
12:05:40 <applicative_> > foldr (.) id [(+1), (*3), (+2)]  3 -- Qtr
12:05:42 <lambdabot>   16
12:06:29 <applicative_> surprising there are overlapping instances for Show (b -> b) rather than none at all....
12:06:37 <Tekmo> Now, two of the extensions that I mentioned don't quite cleanly fit into the split monomorphism formulation I just gave
12:06:47 <Tekmo> They are the finalization and parsing exceptions
12:06:49 <mcstar> hiptobecubic: i think i built acml from sources, it works on intel/amd, mkl is a bit trickier, you can download it after a registration, for an evaluation period or something, but i couldnt get it installed, so i didnt bother(probably overall it is faster than acml)
12:07:07 <Tekmo> First, I'll just write out the derived composition so you can see how it would work:
12:07:11 <jmcarthur> applicative_: i think overlapping instances for instances that shouldn't exist at all is more common precisely because people end up implementing them apart from the class or type definitions, unaware of each other
12:07:31 <pcapriotti> Tekmo: I'm not convinced by the fold example, how's the inverse of f there?
12:07:58 <BluePeppers> I'm wrapping a C function that returns char*, which I then need to free. Looking at the documentation for Foreign.Marshal.Alloc.free, it seems to be only used with Ptrs allocated in haskell. What should I be using to free data allocated using something else in C?
12:08:05 <Tekmo> The inverse recurses over everything except yield
12:08:14 <Tekmo> When it gets to a Yield (Just x) it transforms it to Yield x
12:08:24 <Tekmo> and when it gets to a Yield (Nothing) it just deletes it
12:08:32 <applicative_> Qtr html?
12:08:34 <ski> Tekmo : <http://ncatlab.org/nlab/show/split+monomorphism>
12:08:45 <jmcarthur> Tekmo: deletes it or replaces it with return ()?
12:08:49 <Tekmo> deletes
12:08:53 <Tekmo> Remember that the original function f
12:08:57 <Tekmo> preserves the return value past the yield
12:09:05 <jmcarthur> oh!
12:09:05 * hackagebot singletons 0.8.1 - A framework for generating singleton types (RichardEisenberg)
12:09:13 <Tekmo> Oops
12:09:17 <Tekmo> I wrote it wrong
12:09:19 <Tekmo> It was supposed to be
12:09:38 <Tekmo> f p = (pipe Just <+< p) <* yield Nothing
12:09:43 <pcapriotti> hmm, I remember that we never managed to get guarded pipes working on top of normal pipes, they always fail to be associative
12:09:47 <pcapriotti> why does that work?
12:09:51 <Tekmo> Magic!
12:10:11 <Tekmo> Yeah, I remember that, too
12:10:25 <mcstar> hiptobecubic: btw, im not sure what you want to do, but usually, GPUs are a good fit for these kinds of stuff
12:10:28 <Tekmo> I still haven't wrapped my head around what this "got right"
12:10:33 <Tekmo> But everything I've checked works out
12:10:37 <mcstar> if my damn card were operational, id use that
12:10:38 <jmcarthur> aside: do you two know each other IRL or have you just been doing some sollaboration on irc?
12:10:54 <jmcarthur> *collaboration
12:10:54 <Tekmo> ski: Thanks for the link!  It's good
12:10:56 <mcstar> simple 9400, but so much faster than the cpu for even fft
12:11:32 <Tekmo> So the nice thing about these extensions
12:11:41 <Tekmo> Is that it's easy to compose split monomorphisms
12:11:44 <Tekmo> just using the category instance
12:11:48 <Tekmo> So you can combine extensions easily
12:12:22 <hiptobecubic> mcstar, yes. At the time i didn't have access to any. I'm actually doing my thesis using them now. Haskell has always been an exercise for me. I'm not trying to make anything that will be used anywhere important yet
12:12:47 <ski> Tekmo : also see "Abstract and Concrete Categories -- The Joy of Cats" by Jiŕı Adámek,Horst Herrlich,George E. Strecker in 1990 at <http://katmat.math.uni-bremen.de/acc/>
12:12:59 <pcapriotti> I'll have to dig up that old thread, because I'm pretty sure this doesn't work
12:13:10 <Qtr> who is gabriel gonsalez here?
12:13:14 <Tekmo> Me!
12:13:18 <jmcarthur> him!
12:13:40 * ski points finger
12:13:47 * copumpkin blunts finger
12:13:52 * ion pulls finger
12:14:02 * hiptobecubic farts
12:14:05 * mcstar farts
12:14:05 * hackagebot ncurses 0.2.2 - Modernised bindings to GNU ncurses (JohnMillikin)
12:14:08 <mcstar> shat
12:14:09 <copumpkin> hiptobecubic: unacceptable
12:14:13 <Qtr> ok, tekmo: i dont see how i can purify my already pure code for quicktest. i have a tictactoe-board ADT but i need to generate random boards that you can win in one move from.
12:14:16 <copumpkin> mcstar: definitely unacceptable
12:14:19 * ski rewrites `finger' in pointless style
12:14:20 <jmcarthur> mcstar: you sharted
12:14:26 * hiptobecubic retracts his fart
12:14:29 <copumpkin> jmcarthur: even worse!
12:14:44 * copumpkin proceeds to ban jmcarthur from #haskell
12:14:50 <jmcarthur> :(
12:14:53 <mcstar> i agree
12:14:56 <mcstar> he is a bad influence
12:15:01 <Tekmo> Qtr: Then you have to write an Arbitrary instance for QuickCheck so that it can test random boards
12:15:04 <Qtr> How would you create an Arbitrary winnable board?
12:15:14 <Tekmo> I'm not as much of an expert on that
12:15:26 <Qtr> i already have arbitrary for board but not for a board with 8 amrks on it
12:15:41 <hiptobecubic> Qtr, make a board that has been 'won', and then remove one of the winning marks
12:15:45 * jmcarthur resumes his unsafeCoercing :(
12:16:05 * ski wants resumable exceptions/conditions :(
12:16:14 <Tekmo> Oh, Paolo
12:16:18 <Tekmo> I think I can answer your question
12:16:22 <GyorsCsiga> woot, i think the evaluation is finally clicking
12:16:30 <ski> GyorsCsiga : great :)
12:16:32 <GyorsCsiga> it's all one long chain
12:16:33 <ksf> hmmm. I think I should've started using uuagc two weeks ago.
12:16:34 <pcapriotti> Tekmo: I think I see where the problem is
12:16:39 <Qtr> hiptobecubic: then how do i do that? same problem
12:16:40 <GyorsCsiga> of computations
12:16:45 <ion> qtr: The same way you have e.g. NonZero and Positive. A newtype wrapper which you deconstruct in the property with pattern matching.
12:17:02 <ski> GyorsCsiga : or tree (or rooted directed graph)
12:17:15 <GyorsCsiga> ski, exactly, a tree
12:17:18 <GyorsCsiga> :)
12:17:33 <GyorsCsiga> this is awesome stuffs
12:17:51 * ion looked at the stream and immediately saw a spoiler.
12:17:58 <ion> Whoops, wrong channel.
12:18:01 <GyorsCsiga> I hope to replace the other languages I use with haskell
12:18:04 <ski> GyorsCsiga : consider `let square x = x * x in square (3 + 3)', using call-by-need / laziness, `3 + 3' will only be evaluated once
12:18:06 <Tekmo> Paolo
12:18:09 <timthelion> can ghci tell me which module owns a given function?
12:18:14 <pcapriotti> it seems you can't actually do folds with that definition
12:18:27 <Tekmo> Why not?
12:18:27 <pcapriotti> because you're mapping through 'f' both sides of a composition
12:18:41 <pcapriotti> how do you write a fold?
12:18:50 * ski can see no Paolo in here
12:18:51 <Tekmo> Wait for a Nothing, then return the value
12:18:54 <pcapriotti> you need something of type: Pipe (Maybe a) b
12:18:58 <Tekmo> Right
12:19:05 <Tekmo> Pipe (Maybe a) b m r
12:19:17 <pcapriotti> but then the types don't line up
12:19:23 <Tekmo> Yes they do
12:19:27 <pcapriotti> they do?
12:19:28 <Tekmo> f converts it to
12:19:32 <Tekmo> Pipe (Maybe a) (Maybe b) m r
12:20:13 <GyorsCsiga> ski, how can I witness the laziness? or is it just something I won't be able to see?
12:20:36 <pcapriotti> Tekmo: ah, right... so my original counterexample should apply here, no?
12:20:36 <jmcarthur> GyorsCsiga: check out Debug.Trace
12:20:46 <pcapriotti> http://www.reddit.com/r/haskell/comments/p8g55/guarded_pipes_or_how_to_write_conduitlist/c3nkf22
12:20:51 <Tekmo> Let me try it
12:20:55 <GyorsCsiga> jmcarthur, thanks :)
12:20:56 <jmcarthur> GyorsCsiga: it allows you to attach debug messages to the evaluation of expressions of your choosing
12:21:31 <Tekmo> Ok, in the first example, the "return ()" gets protected by a yield Nothing
12:21:34 <GyorsCsiga> ooo, the platform already haz it :D
12:21:41 <jmcarthur> GyorsCsiga: your earlier question... try :i
12:21:55 <jmcarthur> GyorsCsiga: so if you want to learn more about the map function you say ":i map"
12:21:55 <Tekmo> The id does not pass it on
12:22:00 <Tekmo> That's the key
12:22:11 <Tekmo> Remember that id is transformed, too
12:22:14 <Qtr> hiptobecubic: well youre right, my mistake i can just generate full boards and remove randomly
12:22:21 <Tekmo> idE = retract idP
12:22:29 <Tekmo> So when it receives a Nothing and tries to forward it on
12:22:29 <pcapriotti> that's not the identity, though
12:22:29 <GyorsCsiga> jmcarthur, ok, I did that, :i map…
12:22:30 <jmcarthur> GyorsCsiga: but in some cases (as in the case of map) it will give a non-standard location (in this case, GHC.Base)
12:22:34 <Tekmo> Yes it is
12:22:38 <Tekmo> The identity of folded composition is
12:22:39 <pcapriotti> it's some other pipe that I called id'
12:22:42 <Tekmo> g idP
12:22:48 <nand`> how awful of an idea for an extension would this be? have ‘2x’ parse as ‘(*) 2 x’ instead of ‘2 x’
12:22:49 <pcapriotti> I mean, the one in the counterexample
12:22:53 <Tekmo> Oh yeah
12:22:57 <Tekmo> I keep forgetting
12:22:59 <Tekmo> Ok, let me check again
12:23:06 <jmcarthur> nand`: pretty awful :)
12:23:21 <jmcarthur> nand`: use a quasiquoter if you want though :)
12:23:26 <Tekmo> So when id' receives the Nothing it turns into discard
12:23:37 <zachk> doesn't {(.),id,bunch of a functions} form a monoid?
12:23:39 <Tekmo> return () >|> discard then becomes return ()
12:23:44 <Tekmo> That then gets protected by a Nothing
12:23:58 <Tekmo> So you print "B"
12:24:04 <jmcarthur> zachk: a category, at least. and if you fix the type parameters, you get a monoid
12:24:32 <Tekmo> In the next example
12:24:33 <jmcarthur> zachk: so (id,(.),A->A) is a monoid
12:24:33 <zachk> ahhh
12:24:44 <GyorsCsiga> jmcarthur,  I tried to do something like let sqr x = x * x in 3+3       then did i: sqr…. it said something about not being in scope :S
12:24:46 <Tekmo> Here, let me just code it up
12:24:54 <Tekmo> I just want to run it and see for myself first
12:25:01 <jmcarthur> GyorsCsiga: you mean sqrt?
12:25:05 <jmcarthur> oh
12:25:08 <jmcarthur> your own def
12:25:15 <GyorsCsiga> jmcarthur, yes, just to see
12:25:17 <jmcarthur> i'm never tried :i on somethign i just defined in ghci
12:25:21 <GyorsCsiga> oh
12:25:22 <zachk> I noticed today it seems easier to do a haskell oneliner, then to mess around with bash and sed for a bit
12:25:31 <jmcarthur> GyorsCsiga: i works for me though
12:25:47 <jmcarthur> Prelude> let foo = "bar"\nPrelude> :i foo\nfoo :: [Char] -- Defined at <interactive>:2:5
12:25:58 <rwbarton> "let sqr x = x * x in 3+3" only defines sqr within the scope of the expression 3+3
12:26:04 <jmcarthur> ah that's it
12:26:35 <GyorsCsiga> hm, so with what example might I witness the lazy evaluation with Debug.Trace?
12:27:22 <ski> GyorsCsiga : one way is to see `square (3 + 3)' as evaluating in one step to `(3 + 3) * (3 + 3)', where this really is a `*'-node with two branches pointing to the same `3 + 3' sub-tree/graph. then following one of the branches, we evaluate `3 + 3' one step, replacing it with `6', and then the whole graph is `6 * 6'
12:27:44 <jmcarthur> GyorsCsiga: give this a shot:   let x = trace "2+2" (2 + 2) in trace "x*x" (x * x)
12:28:04 <ski> GyorsCsiga : another way to see it :
12:28:07 <ski>      let square x = x * x in square (3 + 3)
12:28:20 <ski>   =  let x = 3 + 3 in x * x
12:28:43 <ski>   =  let x = 6 in x * x  -- forcing `x' because `*' wants to evaluate its left argument
12:28:54 <ski>   =  let x = 6 in 6 * x  -- gettin the result
12:29:10 <ski>   =  let x = 6 in 6 * 6  -- not having to evaluate `x' again, since it's already evaluated
12:29:14 * jmcarthur has a working completely lazy evaluator :o
12:29:22 <ski>   =  6 * 6  -- garbage-collect
12:29:25 <ski>   =  36
12:29:42 <Toheii> Guys could someone validate my knowledge of monads quickly, it's basically a way to chain functions together that you would otherwise not be able to in order to get a side effect by "lifting" functions so that the functions have the same output type and input type
12:30:14 <jmcarthur> Toheii: there are many intuitions about monads. most of them are both right and wrong
12:30:39 <jmcarthur> Toheii: but if your intuition is about function compositions, you're on a good track
12:30:43 <hpc> Toheii: try expressing that as a function type
12:30:46 <Taneb> Does the data-lens package even need the comonad dependency?
12:30:59 <zachk> Toheii: are monadic (actions) functions?
12:31:01 <jmcarthur> Taneb: doesn't it use Store?
12:31:14 <Taneb> jmcarthur, that's not in comonad, it's in comonad-transformers
12:31:41 <Toheii> zachk: They're a way to modify functions in a way I suppose, which is why they're described as having a side effect
12:31:49 <jmcarthur> Taneb: presumably, though, data-lens uses some functionality from comonad in order to use Store, no?
12:32:00 <Tekmo> Ok, I checked it and it does not work
12:32:06 <Tekmo> Now I need to figure out why
12:32:14 <Taneb> Control.Comonad isn't imported in any of then, jmcarthur
12:32:17 <nand`> monads *are* a way to compose kleisli arrows (eg. functions with side effects), but I'm not sure what that has to do with having “the same input and output type”
12:32:26 <jmcarthur> Taneb: ah, then i guess it's not needed after all
12:32:51 <Qtr> can you create a newType that is the same type?
12:32:51 <pcapriotti> Tekmo: I think because you only showed that it's associative when you start from (regular) pipes and apply f to both sides
12:32:53 <jmcarthur> Toheii: i don't see how they "modify functions"
12:32:53 <zachk> Toheii: but could I compose [ a -> m a] using a regular foldr or foldl ?
12:32:54 <jfischoff> Taneb: I think you could just use a -> (b, b->a) or a get and set function.
12:32:59 <GyorsCsiga> ski, so lazy evaluation is about not evaluating something again if it's already been evaluated
12:33:09 <Toheii> E.g. you take something that outputs a Int and make it output a (Int, String) which it can pass along in function composition without error
12:33:18 <jmcarthur> GyorsCsiga: it's that combined with non-strictness
12:33:20 <pcapriotti> Tekmo: while this example contains a pipe that is not f p for some p
12:33:24 <zachk> GyorsCsiga: lazy is about not evaluating something until you really need the answer
12:33:31 <jmcarthur> GyorsCsiga: call-by-calue has the former property, too
12:33:33 <GyorsCsiga> zachk, ah, ok
12:33:37 <mcstar> GyorsCsiga: no, thats sharing
12:33:45 <jmcarthur> *value
12:33:50 <Tekmo> Wait, no, that doesn't sound right
12:33:56 <GyorsCsiga> hehe
12:33:59 <shapr> Is there a way to have examples optionally built in a cabal file?
12:34:06 <ski> GyorsCsiga : yes. note that the "something" here refers to function arguments and things bound to variables, it doesn't mean that `foo 0 + foo 0' will only evaluate `foo 0' once (that's memoizing)
12:34:24 <jan_> Does anyone know how parse "1. abc 2.  cde 3. fgh" into ["abc","cde","fge"] using Parsec and 'sepBy' combinator? I've been trying to do this for the past 2 hrs...
12:34:25 <Tekmo> It should not matter what the argument pipes are if it's a true retraction
12:34:32 <jmcarthur> call-by-value shares. call-by-name defers evaluation until needed. call-by-need (an example of a lazy evaluation order) does both
12:34:39 <zachk> shapr, make a seperate (sp?) hackage package called yourpackagename-examples
12:34:40 <ski> GyorsCsiga : also note that the Haskell standard doesn't mandate lazy evaluation, it only mandates non-strict evaluation
12:34:51 <zachk> ski: whats the difference?
12:35:01 <pcapriotti> Tekmo: yeah, sorry, that didn't make sense
12:35:09 <GyorsCsiga> jmcarthur, btw, I ran let x = trace "2+2" (2 + 2) in trace "x*x" (x * x) and got simply: x*x;2+2;16       not so sure how this helps me see laziness :S
12:35:10 <jmcarthur> right. call-by-need is strict (so not legal haskell), call-by-name and call-by-need are non-strict
12:35:14 <Tekmo> So I think the issue is more that retraction wasn't an actual retraction
12:35:15 <ski> zachk : it is allowed to recompute `3 + 3' in `square (3 + 3)', e.g.
12:35:17 <Qtr> data TicTacToeBoard = TicTacToeBoard { board :: [Mark] } -- how do i newType that?
12:35:25 <luite> shapr: add a flag examples, and build with -fexamples
12:35:27 <jmcarthur> GyorsCsiga: note that 2+2 was only printed once
12:35:27 <tgeeky_> jmcarthur: try again?
12:35:38 <tgeeky_> "call-by-need" x2 ?
12:35:38 <jmcarthur> tgeeky_: hmm?
12:35:42 <Taneb> Isn't a lens essentially a -> ((b -> a), b)?
12:35:48 <shapr> luite: I'll try that, thanks.
12:35:50 <ski> zachk : and it is allowed to (start) evaluate(ing) foo in `bar && foo', even if `bar' turns out to be `False'
12:35:56 * shapr fixes the scotty hackage
12:35:56 <pcapriotti> Tekmo: yeah, I think that's it
12:35:57 <jmcarthur> woops
12:36:04 <jmcarthur> right. call-by-value is strict (so not legal haskell), call-by-name and call-by-need are non-strict
12:36:06 <zachk> ski: ahhh
12:36:08 <hpc> Taneb: that's a factored form of lenses, yes
12:36:10 <ski> zachk : as long as it can abort the computation of `foo' when it notes it's not needed
12:36:20 <ski> zachk : this is known as "speculative evaluation"
12:36:26 <Taneb> hpc, it's a lot more useful than it looks
12:36:35 <nand`> I guess it's not “strictly lazy”
12:36:36 <luite> shapr: the cabal manual should describe how to use the flag, i think it's something like if(examples) buildable: true
12:36:43 <nand`> (wait, what?)
12:37:06 <ski> zachk : of course, any `error ...' calls invoked by `foo' has to be ignored in case `bar' is `False'
12:37:35 <Toheii> Seems I have a very basic grasp of some uses of some monads but I need to do some more reading/coding thanks for the help
12:37:37 <nand`> ski: how does that play together with unsafePerfomIO?
12:38:15 <jmcarthur> GyorsCsiga: not only was "2+2" only printed once, but it was printed *after* "x*x" was
12:38:20 <ski> nand` : well, considering that the only case in which `unsafePerformIO act' is well-defined is in the case `act' (effectively/observably) behaves as `return val' for some `val' ..
12:38:36 <jmcarthur> GyorsCsiga: so that means it wasn't forced until it was needed, and it was not evaluated more than once
12:38:52 <GyorsCsiga> jmcarthur, ahaaaa, I noticed it being printed after but I'm ignorant…without this laziness how many times would it be printed?
12:39:03 <jmcarthur> twice
12:39:14 <hpc> 2+2;2+2;x*x;16
12:39:19 <hpc> or something like that
12:39:23 <nand`> Toheii: a completely different approach to defining (and perhaps understanding) monads is to consider the functions ‘return’ and ‘join’; a monad is some type that values can be ‘lifted into’ by means of return; and which can have successive levels ‘flattened’ by means of join; consider lists with return = (:[]) :: a -> [a]; join = concat = [[a]] -> [a]
12:39:27 <jmcarthur> yeah, call-by-value would do what hpc said
12:39:44 <jmcarthur> err
12:39:45 <jmcarthur> no
12:40:00 <jmcarthur> heh, okay, here's what would happen with the three most talked about evaluation orders:
12:40:04 <avpx> nand`: fmap is pretty important there too
12:40:06 <nand`> Toheii: not sure if this helps, but you can say that ‘flattening actions’ is at the heart of monads; eg. IO flattens by sequencing
12:40:10 <nand`> avpx: indeed
12:40:11 <jmcarthur> call-by-value:  2+2;x*x;16
12:40:16 <ski> Toheii : monads are a way to express "effects", without the "side" in "side-effects"
12:40:25 <jmcarthur> call-by-name:  x*x;2+2;2+2;16
12:40:30 <jmcarthur> call-by-need:  x*x;2+2;16
12:40:44 <scopedTV> nand`: you'll need fmap as well
12:40:57 <nand`> I should have said ‘a monad is some functor’
12:40:58 <scopedTV> oh that has been mentioned already.
12:41:00 <nand`> instead of ‘some type’
12:41:28 <avpx> Yeah.
12:41:38 <GyorsCsiga> it's pretty amazing how haskell know this before hand
12:41:47 <jmcarthur> before hand?
12:42:02 * ski looks at his fore hand
12:42:04 <tgeeky_> http://hackage.haskell.org/trac/ghc/ticket/7064 <-- nice!
12:42:05 <GyorsCsiga> haha
12:42:19 <GyorsCsiga> i mean, its amazing how it knows when to evaluate
12:42:26 <GyorsCsiga> instead of evaluating everything in one go
12:42:41 <jmcarthur> GyorsCsiga: it's mostly determined dynamically, actually
12:42:51 <GyorsCsiga> oh
12:42:55 <ski> @hackage hood
12:42:56 <lambdabot> http://hackage.haskell.org/package/hood
12:43:02 <nand`> Toheii: so for lists, (>>=) :: [a] -> (a -> [b]) -> [b] -- can be expressed as a combination of ‘map’ and ‘concat’: You first map your list-producing function to get a nested list, then flatten this into one big list
12:43:09 <ski> GyorsCsiga : that ^ might also be interesting as an alternative to `Debug.Trace'
12:43:30 <jmcarthur> GyorsCsiga: ghc's runtime represents an unevaluated value as a thunk, which is just a bit of code that, when run, replaces itself with code that simply returns the final value
12:44:21 <Qtr> data TicTacToeBoard = TicTacToeBoard { board :: [Mark] } -- how do i newType that?
12:44:32 <jmcarthur> Qtr: change data to newtype
12:44:33 <mcstar> simply
12:44:34 <avpx> Qtr: Replace data with newtype. Bam!
12:44:34 <scopedTV> Qtr: write "newtype" instead of "data"
12:44:45 <GyorsCsiga> interesting, i'm going to give hood a go
12:45:02 <nand`> Toheii: in fact, a surprising number of monads can be explained nicely in terms of understanding ‘join’: reader's join passes the same environment to both the outer and the inner computations; IO's join sequences the nested side effects in order; state's join strings the output of one into the input of the other; etc.
12:45:38 <avpx> List's join is just concat, maybe's join is pretty intuitive too
12:45:44 <nand`> indeed
12:45:56 <nand`> writer's join just mappends the monoids
12:46:06 <avpx> Nothing -> Nothing, Just Nothing -> Nothing, Just (Just n) -> Just n
12:46:15 <nand`> (then again, the same can be said for >>=, it just carries a little bit more complexity imo)
12:46:25 <Tekmo> Paolo, I figured it out
12:46:33 <Tekmo> It's because I had it backwards
12:46:40 <Tekmo> I order to automatically form a category, it must be:
12:46:45 * ski again wonders who this Paolo guy is ..
12:46:49 <avpx> nand`: I like cdsmith's article on monads. It explains them as arising from Kleisli arrows, which is another nice way to motivate them.
12:46:53 <Tekmo> p1 <|< p2 = section (retraction p1 <|< retraction p2)
12:47:04 <Tekmo> *<+<
12:47:10 <nand`> avpx: yes
12:47:21 <avpx> I think it's useful to think of monads as dealing with computations of the form a -> m b, and providing a way to compose them.
12:47:32 <nand`> avpx: I think the kleisli arrow explanation is the best way to showcase the IO monad
12:47:37 <ski> avpx : yes
12:47:57 <Tekmo> That also cleanly explains the issue with folding
12:49:05 <Toheii> I think I have a better understanding now, it's a way to control to the composition of functions by making sure it's ordered, or by making sure the functions have the same output/input
12:49:09 <Qtr> data TicTacToeBoard = TicTacToeBoard { board :: [Mark] } // i have to redo that to TicTacToeBoard [Mark] right and then newType that?
12:49:25 <nand`> Toheii: isn't that the same thing you said before?
12:49:39 <ski> Qtr : why ?
12:49:41 <pcapriotti> Tekmo: I'm confused, can you add some types to that?
12:49:51 <Toheii> It's a way to 'control' what each function passes to each in other in composition am I getting closer?
12:50:02 <hpc> Qtr: v
12:50:03 <hpc> 15:44 < Qtr> data TicTacToeBoard = TicTacToeBoard { board :: [Mark] } -- how do i newType that?
12:50:06 <hpc> 15:44 < jmcarthur> Qtr: change data to newtype
12:50:07 <Tekmo> No, it doesn't work out in reverse
12:50:11 <Tekmo> If that's what you are asking
12:50:22 <Tekmo> Well, I mean it does
12:50:23 <scopedTV> Qtr: no, not necessary
12:50:27 <Tekmo> but not in a useful way
12:50:32 <Tekmo> the types work out to:
12:50:35 <Tekmo> Pipe a (Maybe b) m r
12:50:40 <ski> Toheii : in imperative programming, calling a function may do "other stuff" than simply return a single value depending (only) on the parameters
12:50:44 <Tekmo> The point was just to explain why it wasn't associative
12:50:53 <pcapriotti> ah yeah, that makes sense
12:51:06 <Tekmo> That means in order for it to work
12:51:14 <avpx> Anyone know of a good online resource for learning category theory? I have some abstract algebra background and I'd actually like to get some formal background on this stuff.
12:51:16 <Tekmo> If you make "warn" the retraction
12:51:22 <Tekmo> You'd have to ensure the basic invariant
12:51:29 <Tekmo> That a pipe only yields Nothing once and last
12:51:35 <pcapriotti> but that kind of shows the problem with the idea of "pipe extensions": not every feature can be layered on top of the simpler abstraction
12:51:37 <Tekmo> In order to give it a section
12:51:53 <ski> Toheii : e.g. it may mutate some state, it may read a state which can be mutated, it can raise an exception, it may be nondeterministic due to concurrency, it may jump to a continuation, &c. -- we call all these "other stuff" *side-effects* of the function
12:51:55 <nand`> avpx: I started off with wikibooks / HaskellWiki
12:52:04 <nand`> also wikipedia
12:52:09 <nand`> but I'm not sure if that's the best route
12:52:12 <nand`> it certainly is online
12:52:13 <ski> Toheii : the side-effects are the things which you can't see if you're just looking at the signature of the function
12:52:29 <avpx> nand`: I may just bite the bullet and purchase a book. You know, those dead tree things.
12:52:31 <Tekmo> Well, I'm not entirely convinced they can't, but I'll go back to the drawing board
12:52:32 <twanvl> avpx: I learned from http://www.youtube.com/user/TheCatsters
12:52:45 <scopedTV> TheCatsters is awesome
12:52:50 <avpx> That looks cool
12:52:53 <nand`> avpx: I have CT books too, it's not too unusual
12:52:54 <Tekmo> I'm pretty sure parsing and finalization still work
12:53:03 <scopedTV> i'm not sure if they recommend a book
12:53:05 <ski> Toheii : now, monads provides a way to make these side-effects *visible* in the type signature, so that they're no longer *side*-effects, but just *effects*
12:53:40 <Tekmo> And for an indexed pipe type you would be able to create a proper retraction and section for folding
12:53:44 <Qtr> @src any
12:53:44 <lambdabot> any p =  or . map p
12:53:51 <Tekmo> You just have the index guarantee your invariant
12:53:58 <ski> Toheii : so, we have `putStr :: String -> IO ()' instead of `putStr :: String -> ()', where the `IO' signifies that this may interact with the I/O system (i.e. with the rest of the Operating system, and eventually with the rest of the world, including the user)
12:54:03 <Taneb> Every monad is different
12:54:11 <Taneb> Except Maybe and Either ()
12:54:14 <E0F> Hello. I'm new to Haskell and I(m trying to implement a naive primality test, but I have a problem I can't figure out
12:54:19 <Tekmo> Anyway, I need to go get lunch.  I'll try to think of an alternative way to implement folding using the split monomorphism trick
12:54:21 <Qtr> any (== mark) marks // will always execute in order right? like [bool-fun1, bool-fun2] because i want to do fun1 then fun2 but only if fun1 retuns false
12:54:23 <E0F> http://fpaste.org/5O4w/ here's my code and error
12:54:31 <nand`> Taneb: Maybe and Either () can differ in subtle ways
12:54:48 <scopedTV> E0F: you need (ceiling $ sqrt (fromIntegral x))
12:54:49 <E0F> can you please give me a hint ?
12:55:00 <E0F> scopedTV: thank you, i'll try this
12:55:04 <scopedTV> E0F: However, it's far better to write this is a different way.
12:55:05 <coppro> Qtr: any is lazy, yes
12:55:10 <aristid> nand`: and those subtle ways all involve bottom?
12:55:14 <ski> Toheii : and instead of `tickCount :: () -> ()' we can have `tickCount :: () -> State Integer ()' (the `() ->' part isn't really necessary) for a computation that will increment a count "mutable variable"
12:55:15 <nand`> aristid: :)
12:55:19 <Taneb> Nanar, other than Either () not being a MonadPlus?
12:55:24 <nand`> aristid: yes. or unsafePerformIO or error but let's ignore those
12:55:30 <E0F> scopedTV: how would you write it ?
12:55:32 <scopedTV> E0F: instead of [1..j] write takeWhile (\y -> y*y <= x)
12:55:33 <aristid> nand`: error is bottom too
12:55:36 <scopedTV> E0F: instead of [1..j] write takeWhile (\y -> y*y <= x) [1..]
12:55:43 <ski> Toheii : now, one of the most important consequences of using monads to express effects is that we can see which effects are *not* used by a computation
12:55:44 <nand`> Taneb: well, () is either () or ⊥ so it can be used to sneak information in
12:55:45 <scopedTV> E0F: The reason is rounding errors
12:56:10 <ski> Toheii : e.g. we can see that `tickCount' does *not* do any I/O, just by looking at the type signature of it
12:56:47 <Taneb> nand`, is it possible to detect that?
12:56:47 <scopedTV> nand`: How can I observe the difference between () and _|_ ?
12:56:58 <E0F> scopedTV: that's great, thank you very much !
12:57:06 <nand`> scopedTV: pattern match on it. if it's (), your function will terminate. If not, it's ⊥
12:57:17 <Toheii> ski: So IO controls the effects of interacting with IO
12:57:22 <ski> Toheii : the other nice thing with monads is that we can define *custom* effects, like a `Parser'-monad, instead of having to do with the few kinds of side-effects which were set in stone by the designers of the imperative language
12:57:24 <hpc> scopedTV: strictly speaking, you can't
12:57:26 <ski> Toheii : yes
12:57:27 <nand`> scopedTV: not wrap it inside some IO and the user sees a difference :P
12:57:29 <nand`> now*
12:57:31 <hpc> because _|_ can be non-terminating
12:57:50 <ski> Toheii : is there's no `IO' in the type signature (possibly hiding inside a `data' or `newtype'), then the operation can't do I/O
12:57:50 <hpc> in practice, exception handling and other nonsense
12:57:52 <scopedTV> nand`: but that's not a decision algorithm: it does not terminate in some cases
12:58:00 <ski> s/is there's/if there's/
12:58:10 <nand`> scopedTV: yes, that's why I said ‘subtle’
12:58:25 <latro`a> in a way () and _|_ are dual: () carries no information because once you know a value is of type () you know it is (); _|_ carries no information because you can't know anything about a value with a completely generic type
12:58:32 <latro`a> (this is neglecting the exception handling and such aspects of _|_)
12:58:35 <Toheii> ski: Because the type doesn't know how to control the side effects of interacting with IO
12:58:35 <scopedTV> nand`: I prefer to ignore _|_, makes life easier =)
12:58:53 <scopedTV> nand`: so I can say that ((),()) ~= ()
12:58:56 <Taneb> I prefer to avoid it where posible
12:58:58 <avpx> I think that's the general approach.
12:58:58 <nand`> scopedTV: I do too
12:59:02 <nand`> scopedTV: but sometimes it's unavoidable
12:59:13 <nand`> eg. ’why doesn't this seemingly fine function not terminate’
12:59:19 <hpc> it's convenient to pretend that _|_ doesn't exist at times
12:59:22 <nand`> when it turns you you needed an irrefutable pattern match on some tuple
12:59:24 <scopedTV> E0F: the problem was that you tried to apply sqrt to an integral value, that's not possible.
12:59:35 <hpaste> qrt pasted “newtype” at http://hpaste.org/71911
12:59:41 <E0F> Well now I have a parse error at line 5, GHC complains about possible indentation error, but i've checked it and it's correct. What's wrong ?
12:59:47 <ski> Toheii : even people in ordinary imperative languages know it's good to separate the UI aspects of an application from the internal computation aspects. Haskell just enforces this, by the `IO' monad (to the extent one does not simply write everything in `IO')
12:59:48 <nand`> ignore the double negative in my penultimate message
12:59:53 <E0F> scopedTV: oh I seen, I should have thought of that sorry
13:00:07 <ski> Toheii : "Because the type doesn't know how to control the side effects of interacting with IO" -- yes
13:00:11 <scopedTV> E0F: can you paste your code again?
13:00:35 <Qtr> ^^ can anyone explain how to newtype it? i need to create another instance of Arbitrary
13:00:44 <avpx> Toheii: http://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/ <-- should read. is good.
13:00:59 <Toheii> ski: Thank you so, so much, I understand the idea's of monads now, I'm going to go look over some of the implementations to see how they work, but again thank you
13:01:15 <ski> Toheii : now, different monads are for different kinds of effects. there are simple ones like `Maybe',`Either e',`Reader s',`Writer w',`State s',`[]',`Cont o', and more complicated ones like `Parser' and `IO'
13:01:46 <ski> Toheii : the `IO' is sortof a special case here, since it can't be defined in Haskell (but addition on `Double' can't be defined in Haskell either)
13:02:07 <avpx> Yeah, it's important to realize that almost all monads out there are written in pure Haskell.
13:02:09 <ski> Toheii : to better understand monads, it's usually best to ignore `IO' for a while
13:02:20 <avpx> Totally.
13:02:31 <E0F> scopedTV: http://fpaste.org/wyzr/ I haven't changed for takeWhile yet though
13:02:35 <Toheii> ski: Yes I'm going to go look at the maybe/either monad they seem like the simplest
13:02:39 <avpx> Start with Maybe and [], IMO. Then start thinking about State
13:02:53 * nand` still doesn't understand ‘Cont o’
13:02:54 <scopedTV> E0F: You're missing a ) in line 3
13:02:57 <avpx> Maybe is by far the simplest and most intuitive monad.
13:03:00 <Toheii> I'm going to go re-read the LYAH chapter about it
13:03:08 <scopedTV> E0F: Furthermore, you should probably have == [1,x] instead of == [].
13:03:13 <nand`> avpx: personally I think [] is simpler
13:03:35 <nand`> well, not really simpler
13:03:38 <scopedTV> E0F: (Tangentially, writing  " expr == []" is a mistake as well, write "null expr"
13:03:38 <avpx> nand`: [] is sort of a generalized Maybe.
13:03:48 <nand`> [] seems more.. ‘tangible’
13:03:49 <avpx> nand`: I mean, they're very alike.
13:03:54 <pozic_> ski: addition on Double isn't even pure.
13:04:08 <nand`> actually just forget what I said, [] and Maybe are both pretty simple, I don't think I can decide which is simpler
13:04:13 <hpc> pozic_: sure it is
13:04:17 <hpc> it's even total
13:04:21 <avpx> nand`: I like Maybe because it's just a box with one item in it.
13:04:24 <aristid> nand`: i say Maybe is simpler
13:04:31 <ski> Toheii : "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> and "You Could Have Invented Monads! (And Maybe You Already Have.)" by sigfpe (aka dpiponi aka Dan Piponi) in 2006-08-07 at <http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html> might be interesting, if you haven't seen them before
13:04:36 <pozic_> hpc: no, it is not.
13:04:48 <nand`> pozic_: it isn't?
13:04:52 <pozic_> nand`: no, it is not.
13:04:55 <nand`> pozic_: example?
13:04:56 <Taneb> Proxy is the simplest Monad, but its uses are obscure and it's best not to think about it
13:05:02 <E0F> scopedTV: the ( was the problem, thank you :) I've tried the function as is and it worked, i cannot have [1,x] since I'm beginning range at 2 and ending it at ceiling sqrt x + 1 though
13:05:06 <hpc> @hoogle Proxy
13:05:07 <lambdabot> Network.HTTP.Proxy module Network.HTTP.Proxy
13:05:07 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.ColorTable Proxy :: Proxy
13:05:07 <lambdabot> Network.HTTP.Proxy Proxy :: String -> (Maybe Authority) -> Proxy
13:05:09 <pozic_> nand`: no, but you can set rounding modes for the CPU.
13:05:10 <aristid> nand`: Double has an embedded bottom. NaN :)
13:05:14 <ski> nand` : it's probably best to first understand CPS
13:05:21 <E0F> scopedTV: thank you for the 'null' reminder, i'll take care of using this from now on !
13:05:27 <nand`> aristid: NaN is not bottom
13:05:47 <avpx> nand`: I think he meant conceptually.
13:05:52 <nand`> conceptually perhaps
13:06:01 <hpc> pozic_: IEEE doubles have only one rounding mode
13:06:01 * ski suspects his message above got cut off near the end ..
13:06:14 <nand`> but the point of IEEE Doubles is to make them total in the first place, since a processor can't just halt itself because it didn't figure out how to divide by zero
13:06:29 <scopedTV> E0F: "indentation errors" are often due to a forgotten closing parenthesis.
13:06:43 <Taneb> hpc: Data Proxy a = Proxy
13:06:45 <nand`> ski: I don't understand CPS either. This might have something to do with the fact that I don't know what CPS is
13:06:51 <scopedTV> E0F: Identation is significant in Haskell as well, so failing to line up equations might also be problematic.
13:06:52 <ski> `NaN' is more like an embedded exception than an embedded bottom
13:06:54 <avpx> nand`: I think it's crap and requires too many transistors for a number format that is clearly a lie, but that's probably beside the point.
13:06:56 <hpc> Taneb: that has uses?
13:06:57 <nand`> Taneb: Void is the simplest monad
13:06:59 <pozic_> hpc: so?
13:07:05 <ski> nand` : Continuation-Passing-Style
13:07:16 <nand`> ski: I'm familiar with the term. I just don't know what it is
13:07:25 <Taneb> hpc, I think it's used in ixset
13:07:37 <ski> nand` : you know accumulator/state -passing-style, yes ?
13:07:40 <Qtr> newType I = I Int why doesnt that woerk
13:07:42 <nand`> ski: yeah
13:07:51 <Taneb> And for type arithmetic stuff
13:08:00 <E0F> scopedTV: I come from a python background so I already care about indentation :) thank you very much for your help and your patience !
13:08:11 <BMeph> nand`: Learning (Levien's) Io language seems to me to be the best "explanation" for CPS. :)
13:08:17 <ski> nand` : CPS is a style in a similar sense, where you pass "the rest of the computation" as an argument, and call that on your "result" instead of just returning it normally
13:08:24 <ski> @where Io
13:08:24 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:08:27 <ski> er
13:08:35 <pozic_> hpc: http://hackage.haskell.org/packages/archive/altfloat/0.3.1/doc/html/Data-Floating-Environment.html
13:08:41 <BMeph> ski: lol
13:08:42 <pozic_> nand`: http://hackage.haskell.org/packages/archive/altfloat/0.3.1/doc/html/Data-Floating-Environment.html
13:08:53 <nand`> ski: so something like a -> b   ⇒   a -> (b -> c) -> c -- ?
13:09:13 <pozic_> hpc: are you now convinced because someone put it on a website instead of via IRC?
13:09:46 <byorgey> nand`: exactly
13:09:50 <Taneb> We're all just learning Haskell
13:09:58 <ski> someone has overwritten my `Io' entry :(
13:09:59 <Taneb> Does anyone truly know it?
13:10:09 <nand`> :k Cont
13:10:11 <lambdabot> * -> * -> *
13:10:15 <pozic_> Taneb: depends on how you count.
13:10:26 <pozic_> Taneb: Haskell isn't even defined.
13:10:34 <avpx> That's kind of the weird thing about Haskell. It's the only language I've "known" for years, but which still surprises me.
13:10:54 <pozic_> I suppose you know it, if nothing surprises you anymore.
13:11:03 <ski> @where+ Io-Intro http://www.haskell.org/haskellwiki/Introduction_to_IO
13:11:04 <lambdabot> Good to know.
13:11:07 <pozic_> (Which happens to be the case for me. )
13:11:18 * BMeph is actually frightened by those who claim C++ never surprises them...
13:11:35 <ski> @where+ Io Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede'
13:11:35 <avpx> BMeph: C++ surprises me for other reasons
13:11:35 <lambdabot> It is forever etched in my memory.
13:11:40 <ski> there
13:11:42 <pozic_> C++ is merely a big language.
13:11:45 <nand`> Cont o a ≅ (a -> o) -> o -- then?
13:11:55 <ski> @untml Cont o a
13:11:55 <lambdabot> Maybe you meant: unmtl unpl
13:11:58 <ski> @unmtl Cont o a
13:11:59 <lambdabot> (a -> o) -> o
13:12:02 <cesc_> Hey, I just did  "cabal install -fbuildExamples gnuplot".  Reading the docu I see "Examples for using this interface can be found in the Demo module".  Where the hell is it? Can't find it under $HOME/.cabal...  I only found a binary in $HOME/.cabal/bin/gnuplot-demo, but no source example. Any tips?
13:12:16 <pozic_> The language interactions can create surprises, but Haskell has a lot less of those.
13:12:17 <Qtr> noone ever used newType?
13:12:25 <nand`> Qtr: what's newType?
13:12:26 <avpx> Qtr: Calm down, son.
13:12:33 <mcstar> Demo.hs is in the package
13:12:44 <avpx> Qtr: We've all used newtype, it's one of only three fundamental ways to introduce types.
13:12:46 <geekosaur> cabal unpack gnuplot
13:12:46 <ski> @where APLD
13:12:47 <lambdabot> "Advanced Programming Language Design" by Raphael Finkel in 1996 at <http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/>
13:12:52 <ski> @where Amalthea
13:12:53 <lambdabot> Implementation made by Martin Sandin of the (continuation-based) `Io' language at <http://web.archive.org/web/20091106041222/http://www.guldheden.com/~sandin/amalthea.html>
13:12:56 <ski> @where Ganymede
13:12:56 <lambdabot> Implementation by BMeph of the (continuation-based) `Io' language at <http://hackage.haskell.org/package/Ganymede>
13:13:01 <cesc_> mcstar: Demo.hs  is nowhere under .cabal  (according to find) :(
13:13:07 <quuuux> Taneb: oleg knows Haskell. The rest of us are learning, yes.
13:13:10 <BMeph> ski: To be pedantic, Finkel's description is slightly off from Levien's original description. However, Levien's paper is trapped in pay-to-view land, so Fnkel's version is easier to find.
13:13:20 <Taneb> quuuux, where can I find this mysterious oleg
13:13:25 <cesc_> geekosaur: ah!!! thx
13:13:30 <Taneb> And hence get closer to enlightenment
13:13:34 <mcstar> cesc_: just unpack the package
13:13:40 <nand`> ski: thanks for the links
13:13:46 <ski> BMeph : hm, i think i got the paper somewhere -- i.e. "got" -- before by harddisk crashed :/
13:13:46 <avpx> Qtr: You can't say newtype Foo = Int because that's not how newtype works. It's not a type synonym like "type" See: http://www.haskell.org/haskellwiki/Newtype
13:13:52 <geekosaur> I think it's possible for cabal packages to install such things but its currently painful
13:13:58 <BMeph> Taneb: Menterrey, CA. :)
13:14:01 <quuuux> @where oleg
13:14:02 <lambdabot> http://okmij.org/ftp/
13:14:03 <Taneb> CA!?
13:14:04 <Taneb> :(
13:14:04 <geekosaur> and has portability issues
13:14:09 <cesc_> mcstar: I only did the install... now after "cabal unpack gnuplot"  I see the full source. Nice. Thx
13:14:19 <Taneb> That's, like, in Canada or somewhere
13:14:26 <BMeph> ski: I have it on my Google Drive. ;)
13:14:33 <geekosaur> wat?
13:14:34 <Qtr> so can anyone then explain what im doing wrong?
13:14:37 <avpx> Qtr: type is kind of like typedef in C. newtype is like a very limited data, where you have a constructor wrapping around a single type.
13:14:51 <avpx> Qtr: What problem are you experiencing?
13:15:01 <Qtr> http://hpaste.org/71911
13:15:14 <nand`> ski: my problem is, even after an explanation; I'm unsure of what Cont or in general CPS is useful for. How does ‘(a -> o) -> o’ meaningfully differ from ‘a’? (I can extract the underlying ‘a’ by passing it ‘id‘, and I can use normal function application to pass an ‘a’ to an ‘a -> o’, so I don't see what the gain is)
13:15:25 <BMeph> Taneb: No, silly, Cali. Ca./.ca are for Canada. :)
13:15:31 <avpx> Qtr: It's newtype, *not* newType
13:15:34 <hpc> Qtr: that has been answered above
13:15:34 <Taneb> Even so.
13:15:48 <nand`> it's this “not knowing what it's possibly useful for” that's what makes me “not understand / forget” things like these
13:15:50 <Taneb> That's an ocean and a continent westwards, and stupidly far south too
13:15:55 <BMeph> Oh, that should be "Monterrey", BTW. :/
13:16:08 <ski> @let forAll :: [a] -> Cont Bool a; forAll = cont . flip all
13:16:10 <lambdabot>  Defined.
13:16:17 <ski> @let forAny :: [a] -> Cont Bool a; forAny = cont . flip any
13:16:19 <lambdabot>  Defined.
13:16:38 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id)
13:16:40 <lambdabot>  Defined.
13:16:40 <BMeph> Qtr: "it". ;)
13:16:50 <avpx> Qtr: You can just use newtype TicTacToeBoard = TicTacToeBoard { board :: [Mark] } deriving (...)
13:16:52 <ski> @let evalContT :: Monad m => ContT o m o -> m o; evalContT = (`runContT` return)
13:16:53 <lambdabot>  Defined.
13:17:19 <BMeph> Qtr: As in, "You're doing it wrong." :D
13:17:36 <pozic_> BMeph: I am scared of people who write in C++ and are not 100% sure of what their code does.
13:17:43 <ski> > evalCont $ do x <- forAll [2,3,5,7]; y <- forAny [6,21,15]; return (y `mod` x == 0)
13:17:46 <lambdabot>   True
13:17:49 <ski> > evalCont $ do x <- forAll [2,3,5,7]; y <- forAny [6,21]; return (y `mod` x == 0)
13:17:51 <lambdabot>   False
13:17:58 <ski> nand` : ^ is one example
13:19:16 <ski> nand` : another thing is implementing cooperative concurrency (with a timer you can also get preemptive)
13:19:34 <ski> @where composable-continuations
13:19:35 <lambdabot> <http://community.schemewiki.org/?composable-continuations-tutorial>
13:19:51 <ski> ^ has an example of converting internal iteration into external iteration
13:20:17 <ski> nand` : continuations are more or less the ultimate control sledge-hammer :)
13:20:41 <avpx> ski: I haven't used the continuation monad, is it a lot like call/cc in Scheme?
13:20:53 <ski> quite similar, yes
13:21:06 <ski> (though the interactions with `dynamic-wind' in Scheme are not included)
13:21:16 <pozic_> hpc: are you already convinced?
13:21:25 <pozic_> nand`: are you already convinced?
13:22:05 <hpaste> Qrt pasted “newtype using constructors” at http://hpaste.org/71912
13:22:14 <Qtr> ^^ anyone can lead me on?
13:22:34 <nand`> pozic_: I'm still digesting
13:23:23 <BMeph> pozic_: I am scared of people who write in C++ and are 100% sure of what their code does. I'm "sure" they're sure of what they want their code to do, but...c'mon, it's C++! ;)
13:24:06 <mcstar> haskell is a means to an end just like c++
13:24:24 <pozic_> BMeph: if you just read the standard for every new construct you use, you are safe.
13:24:40 <pozic_> BMeph: if however, you accept something based on faith, it's not going to work.
13:24:48 <hiptobecubic> The problem with C++ for me is that it's so enormous.
13:25:35 <jfischoff> Qtr: you need wrap the Marks in a WMark: elements $ map Mark [X, O]
13:25:55 <hiptobecubic> If I need the structure of C++ I prefer just python+C. But then again, I'm not a software engineer so maybe i just have low standards
13:27:37 <Qtr> jfischoff: you mean map WMark ?
13:27:59 <jfischoff> yeah
13:29:22 <hpc> :t randoms
13:29:23 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
13:29:35 <hpc> is it possible to derive Random?
13:30:14 <Taneb> As in, data Foo deriving (Eq, Ord, Random)?
13:30:21 <nand`> since it's possible to derive Enum, it technically should be, shouldn't it?
13:30:49 <succ-quuux> nand`: deriving Enum doesn't really work well
13:31:07 <Taneb> It does for enum-y types
13:31:23 <Taneb> data Foo = A | B | C | D | E | F deriving (Enum, Bounded)
13:31:37 <hpc> eh, nvm
13:31:41 <quuuux> data Foo = A Bool | B Bool doesn't work though
13:31:46 <quuuux> er, deriving Enum on that
13:31:51 <hpc> apparently floating types randomize in the interval of 0, 1
13:32:45 <hiptobecubic> hpc, standard uniform distribution is the usual way to do it. You can get every other distribution from there by inversion
13:33:13 <HairyDude> how do you dispatch on the actual exception type in a SomeException?
13:33:26 <hiptobecubic> hpc, https://en.wikipedia.org/wiki/Inverse_transform_sampling
13:38:10 <nand`> quuuux: ouch, I would totally expect that to write instance Enum Bool => Enum Foo
13:38:20 <ReinH> How do you folks feel about the case () of () idiom in http://www.haskell.org/haskellwiki/Case? I'm not a big fan of similar case statements in other languages and it seems like a slight perversion of guards but it does seem useful and better than the alternatives
13:39:10 <ReinH> I guess it just doesn't seem like a functional idiom
13:39:51 <solrize> they just added lambda case to get rid of that
13:40:12 <solrize> http://hackage.haskell.org/trac/ghc/ticket/4359#comment:87
13:40:21 <nand`> ski: well, I can understand the ‘CPS factorial’ example now, which I suppose is a plus
13:40:33 <solrize> http://www.reddit.com/r/haskell/comments/wp70x/lambdacase_and_multiway_if_added_to_ghc_head_for/
13:40:39 <hpc> i like the infix (?) operator on that wiki page
13:40:47 <hpc> but it still doesn't look very functional
13:40:52 <nand`> ski: not sure how long it'll stick, I'm not at the point where I can look at a problem and think ‘Oh, I can use CPS to implement this!’. But I'm at the point where I can see CPS and follow along
13:42:19 <MagneticDuck> what would be an easy way to extract all the top-level "brackets" from some sort of string?
13:42:46 <MagneticDuck> like extract ["test (hello)", "hi"] from "(test (hello)) (hi)"
13:42:47 <MagneticDuck> ?
13:43:08 <MagneticDuck> any simple functions to do that?
13:43:20 <MagneticDuck> I'd rather not implement a whole string parser
13:43:43 <MagneticDuck> I could do it myself
13:43:54 <MagneticDuck> but I'm wondering if there are any premade functions to that extent
13:44:13 <MagneticDuck> it's a fairly simple problem but I'm probably missing something if I do it with my own code
13:44:35 <MagneticDuck> oh, and how much code would you need to get parsecs to do that kind of thing?
13:44:36 <ReinH> solrize: oh very cool, thanks
13:44:52 <MagneticDuck> I haven't learned parsecs yet, because I wanted to get this project done first
13:45:17 <hpc> well, the grammar you want to parse is
13:45:43 <hpc> one or more balanced paren pairs
13:45:56 <hpc> and inside, you have balanced paren pairs
13:46:05 <MagneticDuck> yes
13:46:05 <hpc> so you can start with a parser for balanced parens
13:46:16 <hpc> which is something like
13:46:24 <ReinH> solrize: now reading http://unknownparallel.wordpress.com/2012/07/09/the-long-and-epic-journey-of-lambdacase-2/
13:46:27 <ReinH> fun history lesson
13:46:32 <hpc> balancedParens = char '(' >> balancedParens >> char ')'
13:46:49 <hpc> probably with some "try" in there
13:47:04 <nand`> more precisely, either that or a non-parens
13:47:15 <MagneticDuck> yes
13:47:21 <quuuux> isn't there a combinator for exactly this? bracket or something
13:47:22 <MagneticDuck> and balancedParens can be null too
13:47:36 <nand`> non-parens is null, I guess
13:47:38 <kopi> Hi.This is almost a haskell question I hope that someone can help me.How would I create a live linux DVD with haskell ghci,  vim and Hoogle(offline) preinstalled.Thanks.:)
13:47:39 <nand`> includes*
13:47:48 <ski> nand` : ok
13:48:03 <MagneticDuck> kopi: .....you already know what a monad is?
13:48:22 <hpc> MagneticDuck: did you misping?
13:48:29 <kopi> ? why that question
13:48:45 <Qtr> nah this sucks
13:48:46 <MagneticDuck> kopi: I'm wondering how much haskell you know
13:48:48 <hpc> kopi: afaik, you just have to install all the junk you want, then do some magic
13:48:49 <nand`> ski: maybe with some more examples of the uses of CPS I'll gain some intuition, I've opened all the links you sent earlier and will look through them later
13:49:13 <hpc> and you have a live CD reflecting your current installation
13:49:14 * JoeHazzers waves to nand` 
13:49:15 <MagneticDuck> hpc: What does misping mean?
13:49:23 <ski> @wn misping
13:49:24 <lambdabot> No match for "misping".
13:49:25 <Qtr> if i generate a board it could obv have several winners and how would i remove until therese is no winner. then i could have several empty spots and noit just one
13:49:29 <hpc> @wn mistype
13:49:29 <lambdabot> No match for "mistype".
13:49:32 <hpc> @wn ping
13:49:33 <lambdabot> *** "ping" wn "WordNet (r) 3.0 (2006)"
13:49:33 <lambdabot> Ping
13:49:33 <lambdabot>     n 1: a river in western Thailand; a major tributary of the Chao
13:49:33 <lambdabot>          Phraya [syn: {Ping}, {Ping River}]
13:49:33 <lambdabot>     2: a sharp high-pitched resonant sound (as of a sonar echo or a
13:49:35 <lambdabot> [12 @more lines]
13:49:36 <hpc> heh
13:49:39 <MagneticDuck> I know what ping is
13:49:44 <MagneticDuck> :P
13:49:52 <MagneticDuck> @more
13:49:53 <lambdabot>        bullet striking metal)
13:49:53 <lambdabot>     v 1: hit with a pinging noise; "The bugs pinged the lamp shade"
13:49:53 <lambdabot>     2: sound like a car engine that is firing too early; "the car
13:49:53 <lambdabot>        pinged when I put in low-octane gasoline"; "The car pinked
13:49:53 <lambdabot>        when the ignition was too far retarded" [syn: {pink}, {ping},
13:49:54 <Qtr> if i generate a board it could obv have several winners and how would i remove until there is is no winner. then i could have several empty spots and not just one so quickcheck DOES FAIL.
13:49:55 <lambdabot> [7 @more lines]
13:49:59 <quuuux> is Mis Ping correct phonotactic Thai?
13:50:07 <MagneticDuck> mis-ping?
13:50:12 <MagneticDuck> @wn mis-ping
13:50:13 <ski> Miss Ping ?
13:50:13 <lambdabot> No match for "mis-ping".
13:50:15 <hpc> kopi: anyhoo, you likely want the haskell platform
13:50:22 <kopi> yes
13:50:24 <kopi> *ghc
13:50:28 <Qtr> i need an algorithm to generate boards with 8 marks and no winners and except for enumerating all states i dont see how to do it
13:50:38 <hpc> and hoogle, you install with "cabal install hoogle --global"
13:50:47 <hpc> and the initial index is "hoogle data"
13:50:56 <kopi> yes I know that but i dont have internet where im going
13:51:14 <MagneticDuck> kopi: oh, sorry, misunderstood the question. ^^
13:51:29 <hpc> kopi: the command-line hoogle doesn't need internet
13:51:33 <MagneticDuck> @wn Mrs. Ping
13:51:34 <lambdabot> *** "mrs." wn "WordNet (r) 3.0 (2006)"
13:51:34 <lambdabot> Mrs.
13:51:34 <lambdabot>     n 1: a form of address for a married woman [syn: {Mrs}, {Mrs.}]
13:51:34 <lambdabot>  
13:51:34 <lambdabot> *** "ping" wn "WordNet (r) 3.0 (2006)"
13:51:35 <lambdabot> [16 @more lines]
13:51:48 <ski> kopi : surely you'll have IRC at least, how could you survive otherwise ?
13:51:56 <kopi> books
13:52:14 <Enigmagic> satellite uplink for #haskell
13:52:15 <byorgey> kopi: see http://rusticcoder.blogspot.com/2012/07/haskell-spin-project.html
13:53:03 <kopi> so Linux Live DVD with GHC Vim Hoogle preinstalled
13:53:49 <hpc> for that part you will want to ask another channel
13:53:49 <kopi> * to simplify the question :P
13:53:51 <hpc> maybe #debian
13:53:53 <nand`> in case I ever find myself in the same predicament, how large would the collective source code of the X most popular hackage packages at their respective newest versions be?
13:54:04 <MagneticDuck> kopi: This sounds like an interesting adventure! :D Going out somewhere where there's no internet, but wanting to program in haskell with everything you'd need
13:54:09 <hpc> nand`: not large
13:54:18 <hpc> nand`: even for all of hackage
13:54:21 <kopi> yeah.:P
13:54:25 <nand`> hpc: approximately?
13:54:33 <hpc> uh... gigs, maybe?
13:54:37 <nand`> hmm
13:54:44 <nand`> that sounds feasible, assuming the number isn't above say 1000 or so
13:54:50 <twanvl_> hackage.tar = 232MB
13:55:08 <MagneticDuck> gosh
13:55:10 <hpc> is there an existing program that can mirror hackage?
13:55:33 <MagneticDuck> download ALL the tarballs!
13:56:00 * ski . o O ( "Gauche Users' Reference: 3.1 Invoking Gosh" <http://practical-scheme.net/gauche/man/gauche-refe_13.html> )
13:56:12 <nand`> ah
13:56:16 <nand`> “archive of just the latest versions of all the packages (250MB tar file)”
13:56:18 <nand`> easy enough
13:56:31 <nand`> I'll be sure to put this on my netbook if I ever do install an OS on it
13:57:26 <luite> all tarballs is around 1.6GB
13:57:53 <nand`> that's uncompressed isn't it?
13:58:05 <luite> i think it's compressed
14:06:32 <kopi> Found the perfect answer
14:06:33 <kopi> http://revisor.fedoraunity.org/
14:06:56 <kopi> I hope that helps someone out too::)
14:07:46 <dmwit> > let n `choose` k = product [n-k+1 .. n] `div` product [1..k] in (9 `choose` 4) * (5 `choose` 4)
14:07:47 <lambdabot>   630
14:08:01 <dmwit> Qtr: Is enumerating all states really that bad? 630 configurations is nothing for a modern computer.
14:09:34 <kopi> and the guide
14:09:34 <kopi> http://www.techotopia.com/index.php/Create_Your_Own_Fedora_Distribution_with_Revisor
14:09:43 <kopi> :)
14:09:53 <kopi> but hoogle will b a problem
14:09:59 <kopi> *be
14:13:00 <EvanR1> know how there sperl poetry
14:13:08 <EvanR1> what about haskell poetry
14:13:41 <byorgey> kopi: you can install hoogle locally
14:13:46 <byorgey> I don't know how difficult it is
14:17:22 <nand`> byorgey: for me it was basically 1. install the package, 2. generate the database with a single command
14:17:32 <nand`> I forgot what the command was but it was something like ‘hoogle default’ or so
14:18:05 <kopi> hmm
14:18:40 <kopi> but how to install in locally :P
14:20:20 <nand`> I guess it depends on your setup. ‘emerge hoogle’ for me, but ‘cabal install hoogle’ was mentioned above
14:25:02 <kopi> http://wiki.gentoo.org/wiki/Haskell
14:25:04 <kopi> beautiful
14:25:15 <kopi> Problem sloved.:)
14:25:26 <kopi> Thanks everyone.:D
14:29:09 * hackagebot git-annex 3.20120721 - manage files with git, without checking their contents into git (JoeyHess)
14:34:22 <mdmkolbe> I remember there being a function called something like "using" that makes writting "sortBy" easier, e.g. "sortyBy (using fst) ...".  Does anyone recall what that is?
14:34:43 <latro`a> comparing
14:34:45 <hpc> @src on
14:34:46 <lambdabot> (*) `on` f = \x y -> f x * f y
14:35:00 <hpc> comparing f = compare `on` f
14:35:09 <mdmkolbe> @info comparing
14:35:09 <lambdabot> comparing
14:35:12 <latro`a> on is the more general function, yeah
14:35:19 <EvanR1> :t comparing
14:35:20 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:35:21 <mdmkolbe> What module is it in?
14:35:25 <latro`a> comparing is in Data.Ord
14:35:29 <mdmkolbe> thanks
14:36:08 <EvanR1> still wondering an easy way to make (Ord a) => Maybe a have Nothing greater than everything else
14:37:14 <Saizan> > Nothing < Just undefined
14:37:16 <lambdabot>   True
14:37:23 <Saizan> flip compare then?
14:37:50 <mzero> presumabely EvanR1 wants     Just 3 < Just 6 < Nothing
14:37:51 <EvanR1> > sort [Just 3, Just 1, Just 0, Nothing]
14:37:52 <lambdabot>   [Nothing,Just 0,Just 1,Just 3]
14:37:59 <EvanR1> want 0 1 3 Nothing
14:38:13 <Saizan> > Just 3 < Just 6
14:38:14 <lambdabot>   True
14:38:47 <Saizan> > sortBy (flip compare) [Just 3, Just 1, Just 0, Nothing]
14:38:49 <lambdabot>   [Just 3,Just 1,Just 0,Nothing]
14:39:01 <Saizan> right
14:39:04 <mzero> Well... the canonical way would be to define a newtype wrapper for this
14:39:09 * hackagebot cmdtheline 0.2.0.0 - Declarative command-line option parsing and documentation library. (EliFrey)
14:39:14 <EvanR1> mzero: yeah, does one exist?
14:39:16 <mzero> similar to First or Last ....
14:39:20 <EvanR1> ah
14:39:21 <mzero> no, I don't know of one
14:40:03 <mzero> newtype SortsNothingLast a = SNL (Maybe a)
14:40:25 <EvanR1> can you redefine just one instance
14:40:25 <mzero> it would relatively easy to define the Ord instance for it
14:40:32 <mzero> no
14:40:36 <EvanR1> blaw
14:40:50 <mzero> what this is a wrapper you put your values in explicitly, perform the sort, then remove 'em
14:41:01 <EvanR1> yes
14:41:04 <EvanR1> oh
14:41:09 <EvanR1> got it
14:41:11 <mzero> in the end, this makes the annomoly more clear than defining a specialized instance for it would
14:41:18 <mzero> (since unsuspecting code elsewhere would see it)
14:41:20 <EvanR1> makse sense
14:41:52 <mzero> The other option is that if you are using Maybe in some idomatic way, say to express wildcarding, then perhaps you shouldn't use Maybe
14:41:58 <EvanR1> funny way to wrangle typeclass library stuff
14:42:14 <EvanR1> wildcarding?
14:42:15 <mzero> data Criteria a = MatchJust a | Wildcard
14:42:45 <mzero> I just mean that if you are using Nothing to really represent something else in your system, something that logically sorts after all the contained values
14:42:53 <mzero> then perhaps a different type than Maybe is called for
14:43:10 <EvanR1> true
14:43:33 <EvanR1> sql sorts NULL first too, annoying
14:44:39 <otters> @pl \a b -> fst a == fst b
14:44:39 <lambdabot> (. fst) . (==) . fst
14:44:57 <otters> @pl \f g a b -> f a == g b
14:44:57 <lambdabot> flip . (((.) . (==)) .)
14:49:37 <shirt> i can't seem to find a summary of which unicode characters are allowed to be used in functions, operators and constructors
14:50:07 <EvanR1> snowman is an operator
14:50:12 <Saizan> @where report
14:50:12 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
14:50:19 <EvanR1> lambda is a alphanumeric
14:50:42 <Saizan> shirt: there's a grammar there with those details ^^^
14:54:48 <monochrom> it also relies on how the unicode standard classifies characters. that means you need to know unicode itself, too
14:54:53 <nand`> Saizan: it just mentions basic descriptions like “any uppercase or titlecase Unicode letter”
14:54:59 <nand`> so you'd have to refer to unicode
14:55:02 <nand`> as monochrom said
14:55:06 <nand`> :t generalCategory
14:55:07 <lambdabot> Char -> GeneralCategory
14:55:08 <nand`> this also works
14:55:37 <monochrom> to use unicode, you must first understand unicode :)
14:55:51 <nand`> > isLetter 'λ'
14:55:53 <lambdabot>   True
14:56:01 <nand`> > isLower 'λ'
14:56:02 <lambdabot>   True
14:56:06 <nand`> ergo, you can use it in function names
14:56:11 <nand`> (including at the start)
14:56:12 <ski> > toUpper 'λ'
14:56:13 <lambdabot>   '\923'
14:56:21 <nand`> > text $ toUpper 'λ'
14:56:23 <lambdabot>   Couldn't match expected type `GHC.Base.String'
14:56:23 <lambdabot>         against inferred typ...
14:56:27 <nand`> > text $ [toUpper 'λ']
14:56:28 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
14:56:40 <startling> > print $ toUpper 'λ'
14:56:41 <lambdabot>   <IO ()>
14:57:01 <monochrom> > '\923' == 'Λ'
14:57:02 <nand`> > toUpper 'λ' == 'Λ'
14:57:02 <lambdabot>   True
14:57:03 <lambdabot>   True
14:57:16 <monochrom> http://www.vex.net/~trebla/symbols/select.html
14:58:26 <monochrom> if you write algorithms for eigenvectors, λ is a cool name
14:58:55 <ski> how about eigenvariables ?
14:59:25 <hpaste> mzero pasted “Sort Nothing Last” at http://hpaste.org/71914
14:59:36 <mzero> just 'cause it was fun to do
15:06:22 <nand`> sortBy (compare $:: SNL ~> SNL ~> id)
15:06:43 <nand`> oh, or sortBy (comparing SNL)
15:06:46 <nand`> even cleaner
15:08:06 <Qtr> so Num is a typeclass and it supports all operations like (+) (-) (*) (/) etc ?
15:08:15 <shirt> what does this line of the grammar mean?
15:08:17 <shirt> dashes 	 → 	 -- {-}
15:08:20 <Qtr> typeclass kind of equal to interface?
15:08:21 <thetallguy1> Qtr: yes
15:08:46 <avpx> Qtr: Pretty much, yeah.
15:09:51 <fmap> Qtr: (/) is not in Num
15:09:52 <thetallguy1> Qtr:  You define an instance of a class for a type.  That defines a dictionary of functions.
15:10:04 <avpx> Qtr: In ghci, type :i Num
15:10:14 <avpx> Qtr: You'll see exactly what it entails.
15:10:42 <thetallguy1> http://nix-tips.blogspot.com/2010/07/hierarchy-of-numeric-typeclasses-in.html
15:11:02 <monochrom> -- {-} means 2 or more -'s
15:11:18 <merijn> Qtr: They're sort of like interfaces, but some key differences are: typeclasses can be polymorphic in return values (i.e. read) and they support polymorphic constants (i.e. bounded)
15:11:51 <merijn> Those two features are very different from interfaces in Java/similar languages
15:12:11 <latro`a> sorry, nitpick: you're fishing for "e.g." not "i.e."
15:12:18 <avpx> merijn: Solid point.
15:12:33 <latro`a> people make that mistake frequently enough that I assume they don't know the difference :(
15:12:35 <merijn> latro`a: I've currently consumed to much alcohol to care
15:12:43 <latro`a> mmk
15:12:47 <avpx> merijn: too*
15:12:51 <avpx> ;)
15:13:07 <latro`a> (that one I wouldn't correct because I know everyone knows the difference :p)
15:13:40 <merijn> avpx: Screw English and its lame phonetically similar words...I've long ago learned that I seem to spell English phonetically, which basically means I'm screwed since there's too many similar words
15:14:28 <merijn> latro`a: I know that e.g. is a small set of examples, i.e. is an exhaustive list/alternative for what you mean. But currently I'll settle for somewhat making sense :p
15:14:58 <startling> merijn, e.g. == "exempli gratia" ~=
15:15:02 <startling> "for example"
15:15:09 <merijn> to/two/too, then/than, you/you're, my mind just keeps getting them wrong :p
15:15:11 <merijn> startling: I know
15:15:12 <latro`a> i.e. == "id est" ~= "that is"
15:15:27 <startling> yep
15:15:41 <latroia> latro`a: ^_^
15:16:02 <latro`a> not at all what my name is from, but cute :)
15:16:19 <copumpkin> not sure you want that to be where your name is from, considering its meaning in italian
15:16:41 <latro`a> I assumed you were going for "la troia", which may have been stupid
15:16:46 <latro`a> but no, neither is where my name is from
15:16:55 <copumpkin> yeah, that is what I meant :P
15:17:16 <latro`a> well, if "la troia" doesn't mean Troy then my head has just slightly exploded
15:17:53 <latro`a> (I know some Latin, essentially no Italian)
15:17:54 <copumpkin> the proper name Troia wouldn't have "la" in front of it, and the colloquial meaning of la troia isn't too pretty
15:18:05 <copumpkin> urban dictionary knows :)
15:18:21 * merijn scribbles this down hastily
15:18:31 <copumpkin> merijn: it's valuable information for any haskeller, indeed
15:18:35 <nand`> I sort of memorize/internalize “i.e.” as “in effect”, is this awfully wrong?
15:18:40 <monochrom> Troia la la la la?
15:18:48 <merijn> I need to know some good Italian profanity for when I'm talking to my italian colleagues ;)
15:19:12 <monochrom> I learn "infatuato" from the opera Don Giovanni
15:19:16 <startling> latro`a, italian is just easy latin
15:19:22 <startling> srsly
15:19:25 <latro`a> heh
15:19:28 <copumpkin> not sure I'd say that
15:19:31 <copumpkin> the grammar is quite different
15:19:33 <monochrom> something about "old geezer"
15:20:00 <hiptobecubic> I'll stick with italian food.
15:20:25 <ski> nand` : "id est" meaning "that is"
15:20:31 <startling> copumpkin, you think so? When I was learning italian I remember making a mapping between latin graphemes and and italian ones
15:20:39 <startling> e.g. latin ct = italian tt
15:20:50 * ski notices latro`a already said this
15:21:12 <copumpkin> startling: sure, the etymology is very clearly linked, but the grammar isn't all that similar. Italian retained much of the verb structure, but all the declension of (pro)nouns and adjectives is gone
15:21:18 <copumpkin> which fundamentally affects the grammar
15:21:29 <startling> copumpkin, s'true
15:21:32 <nand`> ski: I can't remember that
15:21:45 <ski> remember what ?
15:21:50 <nand`> “id est”
15:21:51 <startling> copumpkin, nouns are pretty similar iirc though
15:21:55 <nand`> and by extension “that is”
15:21:59 <copumpkin> startling: definitely
15:22:01 <startling> as is the subjective
15:22:19 <ski> if you're seen it enough, you'll probably learn what it roughly means, even if you can't articulate it
15:22:20 <startling> anyway, it was pretty cool learning latin and then italian
15:22:29 <startling> wish I still remembered some italian, but so it goes
15:22:44 <nobdraisentone> How can I filter [a] → [a] with (a → m Bool) function?
15:22:52 <MostAwesomeDude> :t filterM
15:22:53 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:23:03 <MostAwesomeDude> nobdraisentone: ^^
15:23:47 <nobdraisentone> MostAwesomeDude: thanks
15:23:52 <MostAwesomeDude> Sure.
15:24:01 <ski> @index filterM
15:24:01 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:24:10 <HairyDude> in general, the question "what's the version of function foo where all the result types are wrapped in some monad?" is "fooM"
15:24:22 <ski> @type replicateM
15:24:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:24:40 <HairyDude> and the version that ignores the result type and returns () instead is "fooM_"
15:25:06 <HairyDude> :t mapM
15:25:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:25:29 <startling> HairyDude, oh, that's neat
15:25:34 <startling> never realized that was a rule
15:25:35 <HairyDude> :t forM
15:25:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
15:25:39 <nand`> it's not a rule
15:25:41 <nand`> just a convention
15:25:44 <MostAwesomeDude> Not a rule, just a convention.
15:25:46 <MostAwesomeDude> Dammit!
15:25:46 <startling> well yeah
15:26:01 <HairyDude> :t forM_
15:26:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
15:26:05 <nand`> note that the M_ version doesn't always exist
15:26:11 <nand`> because “void” exists
15:26:19 <startling> just thought of it as "a slightly different fooM" and examined the type signatures for the one I wanted
15:26:34 <copumpkin> nand`: the M_ one is way more efficient than void on mM
15:26:52 <copumpkin> that's why it exists
15:27:03 * ski thinks `void' ought to be called `unit' or `ignore'
15:27:19 <copumpkin> yeah
15:27:23 <ski> (it's `ignore' in the MLs)
15:27:29 <nand`> ‘ignore’ seems reasonable
15:27:42 <hiptobecubic> I'm not grokking functions as applicative functors
15:27:46 <nand`> especially with -fwarn-unused-bind or whatever
15:27:56 <HairyDude> well... "ignore" in ML means "this has a result type but I don't care, I only want the side effects"
15:28:05 <HairyDude> whereas void in C means "this has no result"
15:28:12 <hiptobecubic> > sequenceA [(+3),(+2),(+1)] 3
15:28:12 <lambdabot>   Not in scope: `sequenceA'
15:28:30 <nand`> hmm
15:28:40 <HairyDude> known in older languages like Pascal as a procedure or subroutine
15:28:43 <nand`> come to think of it, why isn't void :: Functor f => f a -> f Void
15:28:55 <ski> HairyDude : yes
15:29:28 <ski> nand` : wouldn't it be `voidF :: Functor f => f Void -> f a', then ?
15:29:38 <ski> @djinn Void -> a
15:29:39 <lambdabot> f = void
15:29:53 <hpc> @src void
15:29:53 <lambdabot> Source not found. My mind is going. I can feel it.
15:29:59 <nand`> ski: not sure what you mean
15:30:01 <ski>   void u = case u of {}
15:30:10 <HairyDude> @src is useless
15:30:10 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:30:11 <ski> cf.
15:30:13 <ski> @type either
15:30:15 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:30:16 <ski> @type maybe
15:30:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:30:28 <HairyDude> @src forM
15:30:28 <nand`> oh
15:30:28 <lambdabot> forM = flip mapM
15:30:33 <nand`> I see what you're saying
15:30:35 <ski> `void' is the nullary counterpart to the binary `either'
15:30:46 <nand`> ski: I meant to replace the current ‘void’, possibly under a different name
15:30:50 <HairyDude> or indeed the unary "Identity"
15:30:53 <nand`> say ignore :: Functor f => f a -> f Void
15:31:09 <ski> nand` : well, the current FFI `void' is for ignoring the result (but still returning)
15:31:26 <ski> nand` : using `Void' there would mean it would not return (assuming no bottoms)
15:31:44 <ski> nand` : i used a `killThread :: SystemM Void' in a cooperative thread thing i made
15:32:06 <nand`> I'm not sure how Void means it wouldn't return. Doesn't Void just mean you can't observe the result?
15:32:25 <ski> (originally i had `killThread :: System ()', which required me to litter my code with `undefined's, so i couldn't be sure if it was correct or not)
15:32:29 <copumpkin> Void has no non-bottom values
15:32:29 <HairyDude> with C I get the impression that a lot of standard functions return int mostly because K&R C didn't have void
15:32:33 <nand`> say you defined main :: IO Void  -- instead of IO (); wouldn't the side effects still be performed?
15:32:42 <copumpkin> sure they would
15:32:46 <geekosaur> K&R C did have void but it was a late addition
15:32:47 <nand`> so where's the problem?
15:32:53 <HairyDude> what is Void here?
15:32:55 <ski> nand` : yes. but you'd have to end by `exitSuccess :: IO Void' or somesuch
15:32:56 <nand`> data Void
15:32:59 <geekosaur> early K&R C didn;t have it, and a lot of APIs were established back at that time
15:33:00 <copumpkin> conceptually, there is no value for it to return
15:33:00 <HairyDude> ah
15:33:16 <nand`> ski: yeah
15:33:23 <nand`> ski: well, in general; changing all instances of IO () to IO Void
15:33:37 <nand`> where we don't actually care about the value
15:33:55 <ski> nand` : the point being that in `foo >> bar' with `foo :: IO Void', `bar' would not be executed (unless `foo' monadically returns a partial value)
15:34:28 <ski> nand` : `IO ()' is for when the computation returns, but with no useful value. while `IO Void' is for when it doesn't return
15:34:43 <ski> nand` : e.g. `setjmp' in C could be typed with a (true) `void'
15:34:56 <ski> er, not `setjmp', `longjmp'
15:34:57 <avpx> Interesting.
15:35:11 <geekosaur> how is this different from forall a. IO a ?
15:35:16 <copumpkin> infinite loops, exit, longjump, etc.
15:35:29 <ski> geekosaur : well, it's not that much different
15:35:40 <hpaste> nand` pasted “IO Void” at http://hpaste.org/71915
15:35:51 <copumpkin> geekosaur: the polymorphic one is just as impossible to return from, but will unify with other types, which might not be what you want
15:35:54 <nand`> ski: see my hpaste
15:36:03 <ski> geekosaur : i suppose `IO Void' is iso to `IO (forall a. a)', from which one can get `forall a. IO a' (but i think not the other direction)
15:36:15 <geekosaur> ah, ok
15:36:16 <copumpkin> nand`: what is your point?
15:36:24 <ski> nand` : `fix id' is not total
15:36:38 <ski> see my "(unless `foo' monadically returns a partial value)
15:36:41 <ski> " clause
15:36:45 <nand`> oh
15:36:54 <nand`> how can any value of ‘Void’ be total?
15:37:01 <ski> it can't
15:37:03 <ski> that's the point
15:37:05 <nand`> so where's the problem?
15:37:06 <copumpkin> that's the point, it can't be, so the only time you'll run into it is with an infinite loop
15:37:15 <copumpkin> or a non-terminating action of some sort
15:37:45 <ski> so, if you require any monadically returned value from `IO Void' to be total, the consequence is that it can't return at all
15:37:51 <copumpkin> nand`: the problem is claiming the action returns something when it doesn't ever return
15:37:59 <copumpkin> nand`: it's a conceptual one
15:38:17 <copumpkin> you can always write void :: Void -> a
15:38:23 <copumpkin> and fmap that onto it if you want geekosaur's version
15:38:26 <ski> and that `void' function *is* total
15:39:18 <ski> for every total value `x', `void x' is total -- for the simple reason that there are no such total values `x' of type `Void'
15:39:21 <nand`> copumpkin: I'm still not sure how any of this relates to what I said
15:39:26 <HairyDude> executeFile :: FilePath -> Bool -> [String] -> Maybe [(String,String)] -> IO (Either IOError Void)
15:39:26 <avpx> What do you mean by `total?'
15:39:41 <copumpkin> nand`: which thing you said? :)
15:39:41 <ski> avpx : roughly "doesn't contain any bottoms"
15:39:47 <avpx> ski: I see.
15:39:56 <HairyDude> or alternatively
15:39:57 * geekosaur was actually thinking more in terms of the alternative version IO (forall a. a), but is slightly brainaddled because they;ve been staining the deck here today and the fumes are strong :/
15:40:08 <HairyDude> executeFile :: forall a. FilePath -> Bool -> [String] -> Maybe [(String,String)] -> IO (Either IOError a)
15:40:09 <nand`> copumpkin: changing roughly all instances of IO () by IO Void; including the required type of ‘main’
15:40:15 <nand`> eg. print :: Show a => a -> IO Void
15:40:20 <copumpkin> nand`: that's not what ski's advocating
15:40:34 <copumpkin> no no
15:40:43 <nand`> copumpkin: what is ski advocating?
15:40:47 <ski> i'm only advocating changing `()' to `Void' when the operation in question does *not* return
15:40:58 <copumpkin> forever :: Monad m => m a -> m Void
15:41:02 <copumpkin> exit :: IO Void
15:41:05 <ski> @hoogle exitWith
15:41:06 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
15:41:08 <copumpkin> crazyJump :: m Void
15:41:09 <nand`> ski: but then it applies. ‘print’ doesn't return anything. It just performs side effects
15:41:10 <copumpkin> something like that
15:41:19 <ski> but having `IO a' there is basically the same
15:41:20 <nand`> it has no meaningful return value
15:41:21 <copumpkin> lol
15:41:37 <copumpkin> nand`: there's a distinction between passing control onto the next "statement" and not doing so
15:41:41 <copumpkin> that's the distinction we're trying to make
15:41:43 <HairyDude> "forall a. IO a" means basically the same as "IO Void"
15:41:52 <HairyDude> the only thing you can return is bottom
15:42:01 <avpx> Yeah, the point is that putStrLn should still have type IO ()
15:42:02 <shachaf> Well, IO (forall a. a) does.
15:42:28 <avpx> Erm, String -> IO ()
15:42:29 <ski> shachaf : hm, on further consideration, i suppose we can go from `forall a. IO a' to `IO Void' by instantiation ..
15:42:54 <copumpkin> nand`: a monadic action returning unit is giving you no information, because unit carries no information. a monadic action "returning" void simply does not return at all
15:42:56 <copumpkin> ever
15:42:58 <nand`> copumpkin: I have no clue what “passing control onto the next statement” means
15:42:59 <copumpkin> MAI
15:43:02 <ski> in any case, what's called `void' in C does in *most* circumstances correspond to `()' in Haskell
15:43:12 <copumpkin> nand`: look at our examples :P we have things that exit the program or loop forever
15:43:15 <HairyDude> thing is, since Haskell is non-strict, the difference between Void and () is moot. You could replace () with Void everywhere and just never inspect the return value (which you can't do anyway since there's no patterns to match)
15:43:18 <ski> but some of them (like `longjmp' and `exit') corresponds to `Void'
15:43:21 <shachaf> ski: I wish you could have values of type "void" in C. :-(
15:43:33 <HairyDude> (modulo seq)
15:43:45 <ski> shachaf : yeah, it's an inconsequence that you can't (iirc you can in some GCC extension ?)
15:43:45 <shachaf> ski: Well, the "void" in longjmp still corresponds to ().
15:43:51 <shachaf> It's just not specialized.
15:43:56 <copumpkin> it's a lie, though
15:44:02 <shachaf> ski: I don't think you can.
15:44:04 <shachaf> s/not //
15:44:11 <copumpkin> just like the cake
15:44:14 <copumpkin> the cake is a lie
15:44:24 <HairyDude> if we had Void, we could distinguish between eager and lazy IO
15:44:38 <HairyDude> ... wait, that doesn't work
15:44:41 <nand`> copumpkin: your example being exitWith?
15:44:56 <copumpkin> nand`: yeah, or forever
15:44:59 <hpaste> laeskblaskefnask pasted “fix intendation so it is clean” at http://hpaste.org/71916
15:44:59 <copumpkin> :t forever
15:45:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:45:05 <copumpkin> that's effectively returning m Void
15:45:12 <copumpkin> but in a way that does unify with other types
15:45:23 <Qtr> ^^ how can i line that function up so it doesnt look like a complete mess?
15:45:30 <Qtr> i get intendation problems wqhen i try to
15:46:01 <ski> shachaf : hm, i suppose i was thinking about zero-length arrays
15:46:04 <copumpkin> :t exitWith
15:46:05 <lambdabot> Not in scope: `exitWith'
15:46:08 <copumpkin> @hoogle exitWith
15:46:09 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
15:46:15 <copumpkin> that's also effectively returning IO Void
15:46:31 <ski>   subst :: Monad m => (var -> m var) -> (m var -> m Void)  -- another example
15:46:36 <copumpkin> the Void thing boils down to making the fact that functions don't return more explicit
15:46:43 <copumpkin> that one's cute
15:46:51 <copumpkin> :t fix . (>=>)
15:46:53 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
15:46:59 <ski> almost, but not quite :)
15:47:03 <copumpkin> boo
15:47:30 <copumpkin> :t In []
15:47:31 <lambdabot> Mu []
15:47:35 <ski> if we have `... -> IO a', with `...' not mentioning `a', then that's basically the same as `... -> IO Void'
15:47:48 <ski> if we have `IO a -> ...', with `...' not mentioning `a', then that's basically the same as `IO () -> ...'
15:48:54 <shachaf> ski: I can't think of a use for "void" as a value in C.
15:49:04 <shachaf> ski: But in C++ it would be quite useful in some circumstances.
15:49:14 <avpx> Exception handling?
15:49:50 <companion_cube> template specialization?
15:50:09 <ski>   void longjmp(jmp_buf env, int val);
15:50:12 <roconnor_> Qtr: do you need the :: String stuff?
15:50:16 <ski>   void longjmp (struct __jmp_buf_tag __env[1], int __val) __THROW __attribute__ ((__noreturn__));
15:50:38 <ski> the `__noreturn__' there is basically saying this returns `Void'
15:50:52 <shachaf> ski: What does fork() return? :-)
15:50:55 <avpx> Is that some GCC attribute?
15:51:11 <ski> shachaf : `pid_t' :)
15:51:15 <ski> avpx : yes
15:51:18 <avpx> shachaf: fork() has a meaningful return value
15:51:44 <avpx> Not to mention that you should be able to sequence actions after it
15:51:47 <shachaf> avpx: Yes. In fact, it has two of them.
15:52:07 <avpx> Heh.
15:52:50 <shirt> i have always found IO () peculiar. There should be two types: IO a, and IOVoid
15:53:14 <shachaf> shirt: putStrLn :: String -> ?
15:53:16 <avpx> IO () makes perfect sense to me.
15:53:24 <shirt> putStrLn :: String -> IOVoid
15:53:26 <hpaste> roconnor annotated “fix intendation so it is clean” with “fix intendation so it is clean (annotation)” at http://hpaste.org/71916#a71917
15:53:30 <ski> `exportML' and `exportFn' in SML/NJ at <http://www.smlnj.org/doc/SMLofNJ/pages/smlnj.html#SIG:SML_OF_NJ.exportML:VAL:SPEC> are also a bit similar to `fork'
15:53:37 <roconnor_> Qtr: ^^
15:53:42 <shirt> IOVoid actions would not be allowed to be followed with >>=
15:53:44 <shachaf> do { x <- putStrLn "hi"; ...x... }
15:53:47 <ski> (especially `exportML')
15:53:56 <shachaf> shirt: That doesn't sound like Monad anymore.
15:54:10 <ski> shachaf : no, it does not have two return values. it *returns* twice
15:54:15 <shirt> shachaf: it's probably not. not sure what it is, but it feels right to me :)
15:54:28 <ski> (and `setjmp' returns at least once, possibly more times)
15:54:37 <avpx> ski: I'm sure he understands the distinction.
15:54:53 <avpx> We're all familiar with fork() here.
15:54:57 <shachaf> shirt: Well, I don't know what it is. :-)
15:55:19 <shachaf> ski: Yes, with two different values!
15:56:20 <ski> shirt : `newtype IO a = MkIO ((a -> IOVoid) -> IOVoid)', `data IOVoid = ExitWith ExitCode | HPutCharBind Handle Char IOVoid | HGetCharBind Handle (Char -> IOVoid) | ...' ?
15:56:43 <hpaste> nand` pasted “IO Void” at http://hpaste.org/71918
15:56:57 <nand`> copumpkin: I don't see what's wrong with ^
15:57:04 <shachaf> ski: Yay, my favourite IO thing.
15:57:43 <ski> nand` : i don't like your `(>>)' -- it should either be the current one, or `(>>) :: Monad m => m () -> m a -> m a'
15:57:46 <roconnor_> ski: that seems efficent
15:58:03 <ski> shachaf :D
15:58:15 <nand`> ski: why?
15:58:34 <ski> <ski> if we have `... -> IO a', with `...' not mentioning `a', then that's basically the same as `... -> IO Void'
15:58:38 <ski> <ski> if we have `IO a -> ...', with `...' not mentioning `a', then that's basically the same as `IO () -> ...'
15:58:41 <shirt> ski: hm...
15:58:41 <ski> nand` ^
15:59:13 <avpx> ski: Maybe I'm not understanding you right, but it doesn't seem to be so.
15:59:13 <shirt> ski: i don't think that's what i'm thinking of
15:59:22 <nand`> I don't understand why one of those examples has () and the other Void
15:59:26 <shirt> ski: getChar should not have anything to do with IOVoid
15:59:32 <nand`> depending on whether it's in the argument or the return type
15:59:38 <avpx> ski: liftM read definitely doesn't return Void
16:00:05 <avpx> I mean, you could *use* IO a as IO Void, but it could mean a whole host of other things (obviously)
16:00:18 <ski> nand` : if you have `IO a' for any `a', you can get `IO Void' by instantiation. if you have `IO Void' you can get `IO a' for any `a', using `void :: forall a. Void -> a' (and the fact that `IO' is a functor)
16:00:23 <elliott__> <ski> shirt : `newtype IO a = MkIO ((a -> IOVoid) -> IOVoid)', `data IOVoid = ExitWith ExitCode | HPutCharBind Handle Char IOVoid | HGetCharBind Handle (Char -> IOVoid) | ...' ?
16:00:29 <elliott__> (That's not really anything to do with IO Void, though.)
16:00:38 <elliott__> (And you can still turn IOVoid into IO () and then put (>>=) after it.)
16:00:39 <roconnor_> forall a. IO a ~~ IO Void         exists a. IO a ~~ IO ()
16:01:18 <elliott__> ski: (But of course, that IO is just Cont. Which is nice!)
16:01:23 <shirt> elliott__: you are supposed to be allowed to turn IOVoid into IO ()
16:01:33 <roconnor_> forall a. a ~~ Void         exists a. a ~~ ()
16:01:43 <ski> what roconnor_ said
16:01:58 <ski> shirt : why ?
16:02:18 <elliott__> ski: are supposed, not are not supposed
16:02:33 <ski> elliott__ : yes, why ?
16:02:46 <HairyDude> transformers provides Control.Monad.Trans, right?
16:03:16 <ski> well, i suppose one can trivially convert `IOVoid' to `IO Void' or `IO a' for any `a', and thus for `()', getting `IO ()'
16:03:24 <ski> shirt : was that what you meant ?
16:03:46 <fmap> HairyDude: no, mtl does
16:04:18 <HairyDude> ah, I see. It provides transformers in separate classes
16:04:18 <fmap> HairyDude: you can check this using ghc-pkg find-module $modulename
16:04:24 <HairyDude> fmap: ooh, handy
16:04:45 <HairyDude> I checked using ghci -hide-all-packages -package base :)
16:06:13 <HairyDude> oh, and the mtl version is in Control.Monad.Reader... confusing
16:06:15 <HairyDude> (but sensible)
16:06:51 <nand`> ski: but if you have forall a. IO a, you can also get IO () by instantiation; and if you have IO () you can also get forall a. IO a via const (fix id)
16:09:22 <kulin> is it possible to compile a ghc program to dynamic link certain libraries so I can create them as plugins?
16:11:00 <shirt> ski: yeah. so you can combine an action such as putChar followed get getChar, and the combined action returns a char
16:11:20 <jhance> Does anyone know of an up-to-date script for generating a Haskell Hierarchial Libraries from all installed libraries
16:11:39 <nand`> there must be something extremely fundamental I'm missing here that after half an hour of back and forth and more than one proof of concept I still have zero clue what's wrong with “IO Void”
16:11:47 <Nereid> nand`: fix id = undefined
16:12:40 <jhance> I have a script but it is broken because the haddock files are now bz2 deflated... I don't know where I got the original either
16:13:27 <ski> nand` : except `fix id' is emphatically not total :)
16:15:14 <nand`> I'm not sure how that's a problem
16:15:30 <ski> nand` : if you have `foo :: IO () -> IO Blah', then you can implement `bar :: IO a -> IO Blah' by `blah act = foo (fmpa (\_ -> ()) act)' -- the other direction is just instantiation
16:15:54 <ski> nand` : `Void' is really only an empty type if we restrict ourselves to total computations
16:16:40 <ski> (while there can be reasons to get into partial computations to get a total result), we've here considering things from a fully total perspective
16:18:05 <E0F> Hello again, this time I'm back because of a problem with GHC's LLVM backend. I'm using GHC 7.0.4 with Fedora 16, and LLVM 2.9 and I can't even compile very simple code pieces such as a Hello World
16:18:11 <ski> if `F' is a functor, then you can go between `forall a. F a' and `F Void' in Agda, but not between `the former and `F Unit'
16:18:11 <Nereid> nand`: what was the original question?
16:18:22 <E0F> here's the output http://fpaste.org/2Gr5/ do you know what's happening ?
16:18:33 <nand`> Nereid: the original question is why we use IO () for functions that “have no return value” instead of IO Void
16:18:40 <Nereid> oh
16:18:40 <nand`> eg. print, main
16:18:54 <nand`> a la http://hpaste.org/71918
16:19:01 <Nereid> because () contains a unique (non-bottom) value
16:19:19 <Nereid> for any type a, there's a unique total function a -> ()
16:19:22 <nand`> my point being that this value makes no sense
16:19:24 <Nereid> so such functions carry no information
16:19:32 <Nereid> it's the same as void return type in C
16:20:11 <Nereid> () is the correct analogue of C void
16:21:21 <nand`> I don't see how () is the analogue of C void. There's no possible value of C type ‘void’; given a function void foo(...); writing void x = foo(...) // is an error
16:21:32 <Nereid> there is exactly one possible value of C type void
16:21:42 <nand`> which is?
16:21:49 <Nereid> and you can't specify it because why would you
16:21:50 <Nereid> there's only one
16:22:22 <ski> nand` : "the original question is why we use IO () for functions that “have no return value” instead of IO Void" -- no
16:22:28 <Nereid> it takes 0 bits to specify a value of a type with 1 value
16:22:28 <ski> nand` : i never suggested doing that
16:22:29 <nand`> ski: yes
16:22:32 <nand`> ski: and?
16:22:34 <nand`> ski: that's what I asked
16:22:54 <Nereid> something total with type IO Void can never return.
16:22:54 <Axman6> E0F: what version of ghc?
16:23:23 <E0F> Axman6: It's GHC 7.0.4. I've googled the issue and it looks like this problem has been fixed in more recent releases
16:23:26 <ski> ok, then the answer is that `()' means "no interesting result", while `Void' means "*no* result" (meaning it can't return (totally))
16:24:05 <Nereid> if we had a strict language (with no bottom), then () would really be the terminal type
16:24:13 <Nereid> (i.e. for any type a, there is a unique function a -> ())
16:24:13 <Axman6> E0F: yeah its worth updating. 7.4 has a lot of nice stuff in it if I remember rightly
16:24:14 <ski> nand` : there is (conceptually) a value of type `void' in C, it takes up 0 bits of memory
16:24:18 <nand`> but Haskell isn't strict, and main doesn't need to be strict
16:24:24 <Nereid> indeed
16:24:35 <nand`> so why would non-strict functions be a problem?
16:24:44 <Nereid> I don't see why they would be.
16:24:47 <nand`> err
16:24:54 <Axman6> E0F: might also consider updating LLVM to v3.0. currently v3.1 causes some problems (which have been fixed for 7.6 I believe)
16:24:59 <ski> nand` : consider `struct empty {} my_void;'
16:25:06 <nand`> replace all instances of “string” by “total”
16:25:11 <nand`> strict, even
16:25:17 <E0F> Axman6: I wish I had 7.4, but my distro's stable packages are still 7.0 and I'd rather use package software to keep it clean, moreover I'm new to Haskell so I assumed I wouldn't need a newer version
16:25:28 <nand`> in my last two statements (not including the one before this) involving that word
16:25:34 <E0F> Axman6: I'm gonna install it from the Haskell distribution
16:25:36 <Nereid> nand`: I'm not sayin you can't do things by returning IO Void instead.
16:25:40 <Nereid> saying
16:25:54 <Nereid> because, sure you can.
16:25:54 <Axman6> the platform?
16:26:04 <nand`> Nereid: so your argument is just “because print (etc.) should be total”, basically?
16:26:05 <Nereid> it's just not conventional.
16:26:24 <ski> nand` : normally, we're only after total values. e.g. when we use `Either A B', it's normally because we either get a total `A' value back, or a total `B' value back
16:26:28 <aristid> Axman6: you mean nice stuff like DataKinds which you're not supposed to use? :)
16:26:37 <Axman6> E0F: as a test, you could try downloading ghc and installing it into your homedir somewhere you can nuke it if it doesn't help
16:26:54 <E0F> Axman6 : Yup, that's what I'm going to do first
16:26:59 <jhance> E0F: This is why I use gentoo. Its package manager tends to have up-to-date GHC :)
16:27:01 <ski> nand` : so, it seems to make sense to use `Void' (only) when the intension is that the operation will not return (since there's no total alternative to return)
16:27:14 <aristid> jhance: that also holds for nixos :)
16:27:19 <Nereid> in a non-strict language like haskell, Void is indeed the terminal type. but it's nice to be able to pretend things are total.
16:27:28 <E0F> jhance: yeah, Fedora is very up to date on most software, but it lacks a good haskell support I think
16:27:28 <Nereid> sometimes.
16:27:43 <nand`> ski: I can understand your argument in total languages like Agda, but I don't see its relevance in partial languages
16:27:56 <ski> nand` : otoh, normally we use `(A,B)' when we want to return both an `A' value and a `B' value, together : i.e. we want to return, and we want to return two conceptually distinct values
16:28:01 <E0F> It's quite disappointing to see Fedora 17 still has GHC 7.0.4 while 7.4.2 is out
16:28:07 <jhance> E0F: I completely agree with you there (I used Fedora until I got into Haskell programming)
16:28:17 <ski> nand` : similarly, normally we use `()' when we want to return *zero* values (but we still want to return)
16:28:26 <nand`> why do we want to return?
16:28:42 <aristid> E0F: well the new haskell platform only came out very recently
16:28:50 <jhance> nand`: Would you rather the expression loop forever?
16:28:50 <ski> otherwise we can't do anything after executing `print 42'
16:28:53 <nand`> if we have nothing meaningful to return, why bother returning in the first place?
16:28:56 <Nereid> nand`: http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
16:28:57 <aristid> E0F: so maybe they stayed on 7.0 because that's what was in the old platform
16:29:01 <E0F> aristid: but GHC 7.4 didn't, did it ?
16:29:20 <ski> if `print 42' wouldn't monadically return, then `print 42 >> getLine' would never execute `getLine'
16:29:30 <jhance> Fedora base themselves on the platform. I don't see much of a use for platform outside of Windows, though, since thats where its handy. In Linux a package manager does the job
16:29:37 <E0F> I think the package maintainer was waiting for the whole 2012 platform to come out
16:29:43 <ski> nand` : "if we have nothing meaningful to return, why bother returning in the first place?" because of the `IO'-effects, e.g.
16:30:00 <copumpkin> nand`: the point is that yes, Haskell may be partial, but we strive to avoid partiality when programming in it
16:30:04 <copumpkin> so the distinction is still meaningful
16:30:06 <E0F> but I agree, platform is good on windows and OS X, but on Linux it's of no use
16:30:08 <copumpkin> even if it isn't statically enforced
16:30:23 <ski> nand` : the relevance is that most of the time, even in partial languages, we're after expressing total computations
16:30:36 <Nereid> relevant paper ^
16:30:39 <nand`> ski: does ‘print 42 >> return (fix id)’ return?
16:30:47 <copumpkin> nand`: I'm not sure why you keep asking about print :P
16:30:52 <ski> nand` : yes, but it doesn't return a total value
16:30:59 <nand`> copumpkin: because it's a good example?
16:31:06 <copumpkin> no, it has nothing to do with what we're talking about
16:31:13 <copumpkin> print returns, but doesn't return an interesting value
16:31:18 <copumpkin> exit doesn't return at all
16:31:29 <aristid> :t exit
16:31:30 <lambdabot> Not in scope: `exit'
16:31:34 <aristid> @hoogle exit
16:31:34 <ski> @hoogle exitWith
16:31:35 <copumpkin> @hoogle exitWith
16:31:35 <lambdabot> System.Exit data ExitCode
16:31:35 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
16:31:35 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
16:31:35 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
16:31:35 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
16:31:41 <copumpkin> lol
16:31:44 <aristid> :)
16:31:53 <aristid> type seems fine
16:31:59 <aristid> it's effectively Void that way
16:31:59 <ski> yes
16:32:01 <copumpkin> nand`: that's a very important distinction, and that's all we're saying :P
16:32:06 <jhance> Return is a confusing notation for Haskell because it really is more like the expression is _evaluated_ and using return this way will just lead you astray when thinking about the Monadic *return* function
16:32:12 <luite> if I have data D = A Text | B Int and want to write a FromJSON instance that converts { type: 'a', val: 'x' }, { type: 'b', val: 0 } as expected, how?
16:32:13 <ski>   exitWith :: ExitCode -> IO Void  -- would also be an acceptable signature
16:32:16 <copumpkin> the distinction between returning a boring value and not returning at all
16:32:57 <nand`> copumpkin: I must be using terminology incorrectly
16:33:02 <nand`> let me try rephrasing
16:33:11 <ski> jhance : yes, there's a distinction here between the expression evaluation returning, and a monadic value execution monadically returning -- i was talking about the latter, above
16:33:18 <copumpkin> in gcc, you have attribute noreturn, for example :) http://www.emerson.emory.edu/services/gcc/html/Function_Attributes.html
16:33:26 <copumpkin> we're trying to represent that knowledge in the type
16:33:50 <nand`> where I meant “doesn't return”, I really meant “returning a non-total value”
16:33:59 <ski> that's different
16:34:08 <nand`> and that's what I'm asking about
16:34:10 <ski> at least in the context of monadically returning
16:34:30 <E0F> OK what now ? the configure script can't determine the current directory, even with --prefix set. What's wrong again...
16:34:42 <ski> (because `return undefined' monadically returns, it just returns a non-total value)
16:34:48 <augur> ski: so
16:34:53 <ski> augur : os
16:35:16 <augur> ski: the duality of these rules is really interesting
16:35:24 <augur> ski: and the non-duality of the semantics is also really interesting
16:35:33 <nand`> ski: that's what I've been meaning all along: Why don't we change ‘print’ etc. to return a non-total value?
16:35:41 <nand`> ie. IO Void
16:35:46 <ski> nand` : anyway, `()' in Haskell is like `void' in C, or `struct empty', defined as `struct empty {};' in GCC. while `Void' in Haskell is like the `noreturn' attribute in GCC
16:36:07 <ski> nand` : why would we do that ?
16:36:16 <ski> it would only be conceptually confusing, afaics
16:36:23 <augur> well i guess the semantics is dual too, actually
16:36:28 <copumpkin> there's nothing wrong with what print returns
16:36:31 <augur> since the dual of necessity is possibility
16:36:42 <nand`> ski: since it makes no sense for print to return () since you'd never want to process the () in any meaningful way
16:36:46 <nand`> it might as well return a non-total value
16:37:06 <copumpkin> huh
16:37:36 <ski> the `IO' monad abstraction isn't really married to non-strictness -- it can be employed in strict languages as well
16:37:48 <copumpkin> nand`: "this building isn't useful for the general public, so I'm going to booby-trap it because nobody should be using it anyway"
16:37:59 <Nereid> nand`: so are you wondering why the type () exists at all?
16:38:21 <Nereid> it sounds like it
16:38:24 <nand`> Nereid: no, I know some uses of ()
16:38:28 <Nereid> like what
16:38:33 <copumpkin> there's never anything useful to do with ()
16:38:41 <copumpkin> it serves as an inhabited type that carries no information
16:38:47 * ski keeps his tounge
16:39:04 <nand`> you can use it as a sort of “trap” by matching on it
16:39:04 * copumpkin steals ski's tongue
16:39:49 <Nereid> what
16:40:02 <ski> one use of `()' is when the context demands a type or a value, but you don't have anything interesting to return, e.g. `putStrLn :: String -> IO ()'
16:40:13 <ski> -- but this is the case where nand` wants to use `Void' instead
16:40:32 <copumpkin> not having anything interesting is not the same as not being able to
16:40:45 <Nereid> nand`: it's nice when all of our functions are total, because then we can reason as though the language itself was total
16:40:47 <Nereid> see the paper
16:40:47 <nand`> Nereid: since () can either be () or ⊥; if you match on it your function will only return if () was indeed ()
16:41:03 * copumpkin sighs
16:41:06 <ski> (an alternative would be to have `IOUnit', with `putStrLn :: String -> IOUnit' -- but this complicates the interface to I/O operations, with little gain)
16:41:19 <nand`> Nereid: that makes sense
16:41:46 <augur> ski: what was the book you mentioned?
16:42:03 <startling> is there a monadic operator that ignores the second argument?
16:42:05 <copumpkin> probably not a good idea to use koninkje_away's tries for my cryptographic hashes, since there will be almost no prefix sharing
16:42:12 <copumpkin> :t (<*)
16:42:14 <Nereid> startling: (<*)
16:42:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
16:42:26 <startling> copumpkin, Nereid: oh nice
16:42:33 <ski> augur : "Multiple-Conclusion Logic" by D. J. Shoesmith & T. J. Smiley in 1978 ?
16:42:34 <nand`> Nereid: I'd be fine with that being the definitive answer to my question: “Using () instead of Void because it allows for total reasoning”
16:42:42 <augur> ski: possibly!
16:42:44 <Nereid> okay :)
16:45:22 <nand`> copumpkin: btw, earlier you mentioned using IO Void to ensure nothing gets sequenced after ‘exit’. Wouldn't it be much more appropriate to have exit :: forall a. a; and use that to short-circuit IO evaluation? That way, truly nothing can be evaluated afterwards because exit >> print 42 will never execute print 42; but foo >> print 42 where foo :: IO Void *can* execute the print 42 as I demonstrated
16:46:02 <Nereid> nand`: that's how it's in fact defined
16:46:05 <Nereid> @type exitSuccess
16:46:07 <lambdabot> Not in scope: `exitSuccess'
16:46:07 <Nereid> er.
16:46:09 <Nereid> @hoogle exitSuccess
16:46:09 <lambdabot> System.Exit ExitSuccess :: ExitCode
16:46:09 <lambdabot> System.Exit exitSuccess :: IO a
16:46:13 <nand`> Nereid: now, it's throwIO
16:46:16 <nand`> no*
16:46:34 <Nereid> ?
16:46:39 <copumpkin> nand`: ski mentioned a type he'd prefer
16:46:46 <copumpkin> nand`: m () -> m a -> m a
16:47:12 <copumpkin> that would prevent you statically (without working for it) from trying to run things after stuff that doesn't return
16:47:25 <nand`> copumpkin: for exit?
16:47:31 <nand`> or for (>>)
16:47:32 <copumpkin> no, for (>>)
16:47:33 <nand`> oh
16:47:39 <copumpkin> you mentioned m Void -> m a -> m a
16:47:43 <copumpkin> but that's exactly what we don't want
16:47:43 <Nereid> as long as our non-returning tyings have type IO Void
16:47:47 <Nereid> thing*
16:47:50 <copumpkin> that's saying "I can run something after something that doesn't return"
16:48:12 <E0F> Time to leave, thank you for your help, bye !
16:48:21 <Nereid> so maybe it's wrong to have a polymorphic exit?
16:48:25 <nand`> but, didn't we establish that m Void does *not* mean “something that doesn't return”, but instead “something that may return, but if it does, returns a non-total value”?
16:48:27 <copumpkin> forever (putStrLn "yes") >> putStrLn "no"
16:48:48 <copumpkin> nand`: no, that's what we keep rejecting :P we're trying to work in a total language, even if haskell doesn't enforce it
16:48:57 <copumpkin> or at least, I keep rejecting it, and I think ski does it
16:48:57 <copumpkin> too
16:49:21 <copumpkin> in a strict or a total language, you wouldn't be able to write return (fix id)
16:49:25 <augur> ski: the graph proofs here look very proof-net-ish
16:49:27 <copumpkin> and we don't want to do that in haskell either
16:49:33 <nand`> In a strict or total language, ‘Void’ doesn't make sense in the first place
16:49:38 <copumpkin> nand`: sure it does
16:49:38 <Nereid> sure it does
16:49:39 <elliott__> What? Ye sit does.
16:49:41 <elliott__> *Yes it
16:49:46 <Nereid> there's a unique function Void -> a for any type a
16:49:46 <nand`> ouch, I'll take that back then
16:49:49 <Nereid> (and it's total)
16:49:55 <elliott__> It is an uninhabited type.
16:50:00 <elliott__> In fact, you still have _|_ in strict languages.
16:50:04 <nand`> hrm, I thought ‘total’ referred to types as well
16:50:06 <copumpkin> nand`: that's precisely the use we want it for. You keep saying you can stick fix id in it, but we consider that an artifact of haskell, and we want to use it as a real empty type
16:50:07 <elliott__> Since a strict language is one for which f _|_ = _|_ for all f.
16:50:30 <nand`> copumpkin: right
16:50:33 <Nereid> elliott__: how about in a total language.
16:50:44 <nand`> copumpkin: it clicked for me with what Nereid said
16:50:44 <copumpkin> a total language doesn't have _|_
16:50:47 <elliott__> Nereid: Then there is simply no well-formed expression with type Void.
16:50:54 <Nereid> of course.
16:50:58 <Nereid> doesn't mean the type is useless.
16:51:03 <elliott__> Anyway, although a type that would otherwise have n inhabitants has n+1 in Haskell, the extra inhabitant is volatile and likes to explode when you look at it.
16:51:10 <elliott__> So, you don't use it to represent something in your data type.
16:51:11 <copumpkin> you can have Void values in absurd contexts
16:51:20 <elliott__> You use it, if at all, for things that live "outside" the data type, so to speak.
16:51:32 <elliott__> So having putStrLn return error "foo" or undefined or fix id isn't really kosher.
16:51:50 <elliott__> Nereid: Well, technically, that's not true, since -- what copumpkin said.
16:52:22 <elliott__> What I mean is there's no Void-typed expression unless you can get ahold of an existing one. Which you can't, unless behind a function arrow.
16:52:24 <nand`> copumpkin: we were arguing past each other. Your point was “We don't want IO Void because working with it requires ‘fix id’ which doesn't exist in total languages”, meanwhile my point was “why do we care about total languages? IO Void / fix id works fine in Haskell, a partial language”
16:53:00 <copumpkin> nah, my point was we do want IO Void, because it represents something useful, but we don't want it for the things you want it for (i.e., print or main)
16:53:14 <nand`> copumpkin: yeah; I meant precisely for main/print
16:53:19 <copumpkin> okay :)
16:53:22 <nand`> (that was implicit in my quote)
16:53:24 <copumpkin> we meant precisely for exitWith and forever
16:53:29 <nand`> yes, I see your point
16:53:32 <copumpkin> cool :)
16:53:32 <elliott__> You want IO Void to represent something which never returns, because you know that the only Void value is "volatile" in the sense that it explodes if you look at it.
16:53:37 * copumpkin goes back to his Agda
16:53:41 <copumpkin> too much partiality for me in here
16:53:47 <Nereid> on a related note
16:53:50 <elliott__> Wait, is there any disagreement actually left?
16:53:52 <Nereid> what *should* the type of main be?
16:53:56 <copumpkin> elliott__: I don't think so
16:54:13 <elliott__> Nereid: IO Void works fine in that you just end with exitSuccess or exitFailure or whatever.
16:54:17 <copumpkin> Nereid: IO (forall a. Not (Not a) -> a)
16:54:21 <elliott__> But IO () is more convenient, because exitSuccess is left implicit.
16:54:23 <Nereid> huh.
16:54:29 <dylukes_> What's the distinction between IO Void and IO ()?
16:54:35 <copumpkin> oh god
16:54:37 <dylukes_> IO Void would only work for exiting right?
16:54:39 * copumpkin flees
16:54:41 <dylukes_> Void has no witnesses.
16:54:44 <Nereid> dylukes_: that's what we were just discussing :)
16:54:52 <elliott__> This is the song that never ends / it goes on and on my friend...
16:54:53 <nand`> elliott__: I don't think so either
16:54:55 * dylukes_ has no backlog
16:55:15 <copumpkin> Some people started singing it not knowing what it was,
16:55:16 <Nereid> dylukes_: IO () is for computations that terminate with no interesting resulting value, IO Void is for computations that don't terminate.
16:55:33 <dylukes_> Right. () has one possible value, Void has 0.
16:56:03 <dylukes> so then what would you possibly use IO Void for other than exitWhatevers?
16:56:09 <Nereid> and forever
16:56:15 <dylukes> Oh, right, forever.
16:56:37 <nand`> dylukes: the question that inspired this was using IO Void to represent “computations that terminated, but with a partial value”, which only works in partial languages
16:56:59 <Nereid> hmm.
16:57:05 <Nereid> might be worth considering what happens in other monads.
16:57:11 <Nereid> Maybe () contains two values, Nothing and Just ()
16:57:17 <Nereid> Maybe Void only contains Nothing
16:57:24 <copumpkin> Nereid: ski's example for substitution was cute, I think
16:57:30 <Nereid> where?
16:57:45 <copumpkin> subst :: Monad m => (a -> m a) -> a -> m c
16:57:56 <copumpkin> very short definition, too
16:58:09 <copumpkin> it could be (a -> m a) -> a -> m Void
16:58:12 <Nereid> what does it do
16:58:23 <copumpkin> it substitutes into your AST until you have no more variables :)
16:58:40 <Nereid> I don't get it.
16:58:43 <copumpkin> say you have data MyAST a = X | Y | Var a
16:59:05 <copumpkin> you can make a Monad instance out of that
16:59:07 <nand`> Nereid: that ‘Maybe’ interaction is interesting. By using ‘Maybe Void’, you also create a “Maybe”-action that has to terminate, because nothing else can possibly succeed when sequenced with it
16:59:11 <nand`> s/terminate/fail/
16:59:26 <Nereid> nand`: right.
17:00:09 <Nereid> nand`: and you can tell that from the type.
17:00:30 <nand`> (again, only in total languages :P)
17:00:31 <copumpkin> Nereid: more concretely, data AST a = Factorial (AST a) | Plus (AST a) (AST a) | Con Int | Var a
17:00:40 <copumpkin> Nereid: an AST Void value is an AST with no free variables in it
17:00:45 <Nereid> copumpkin: right, ok.
17:00:56 <copumpkin> Nereid: fix . (>=>) substitutes until there's nothing left to substitute
17:01:28 <Nereid> @type fix . (>=>)
17:01:29 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
17:02:03 <copumpkin> that a -> m a is basically saying "given a variable, I can give you an AST to substitute into it
17:02:16 <copumpkin> possibly itself containing free variables
17:02:24 <Nereid> I think I get it now.
17:03:57 <Nereid> although subst Var wouldn't work out nicely.
17:04:08 <Nereid> I guess return = Va.
17:04:09 <Nereid> r
17:04:40 <ski> copumpkin : yes, i try to
17:05:43 <jmcarthur> i've never actually tried to work with ASTs structured as a moand
17:05:45 <jmcarthur> *monad
17:06:24 <copumpkin> if you use nested types with Maybe
17:06:30 <copumpkin> or even fancier types
17:06:38 <copumpkin> you can even make it well-scoped or typed without using GADTs
17:06:47 <copumpkin> lots of clever tricks
17:06:48 <ski> elliott__ : "Then there is simply no well-formed expression with type Void." -- there's no *closed* such expression
17:07:07 <elliott__> ski: Right, I corrected myself a few lines down.
17:07:15 * copumpkin pounds elliott__ into the ground
17:07:22 <elliott__> : ' (
17:07:30 * avpx pounds elliott__ out of the ground, hopefully undoing what copumpkin has done
17:07:41 <shachaf> helliott__
17:07:47 <shachaf> whatareyoudoingin#haskelliott__?
17:08:13 <dylukes> http://cl.ly/IFbe
17:08:16 <dylukes> whaaaaa? :0
17:08:35 <dylukes> When was I ever under these restrictions? I never noticed them.
17:09:18 <ski> Nereid,dylukes : note that `killThread :: SystemM Void' is also sensible, despite it not running forever
17:09:54 <ski> Nereid,copumpkin : it was actually `subst :: Monad m => (var -> m var) -> (m var -> m Void)'
17:10:00 <zachk> dylukes: and now they can sell your aggregate data to whomever they want too :-D
17:10:14 <copumpkin> ski: oh yeah
17:10:16 <copumpkin> whoops :)
17:10:20 <Qtr> haskell uses tail call opt right? otherwise you couldnt have endless loops?
17:10:32 <ski> Nereid : consider `data Expr var = Var var | Lit Integer | Add (Expr var) (Expr var)', `Expr' is a monad
17:10:33 <Nereid> ski: oh. that makes more sense.
17:10:33 <copumpkin> ski: although you can get it started anyway
17:10:34 <dylukes> Oh look it's that question!
17:10:40 <startling> the bad thing about using trifecta is that I keep doing stuff and realizing it's already implemented. :/
17:10:42 <dylukes> Qtr: No Haskell is just lazy.
17:11:08 <dylukes> startling: trifecta 0.9 does some huge refactoring. Only the core is in `trifecta;, and everything else is moved to `parsers'
17:11:16 <ski> in `subst :: Monad m => (var -> m var) -> (m var -> m Void)', `Void' acts like a type of variables containing no actual variable names (meaning `subst' gets us a closed expression)
17:11:24 <Nereid> ski: how would you implement that?
17:11:28 <nand`> dylukes: tail call optimization is unrelated to laziness though, isn't it?
17:11:32 <jmcarthur> dylukes: well... strict tail calls are still optimized though
17:11:35 <ski> `subst :: Monad m => (var -> m var) -> (m var -> m otherVar)' also works, for every variable type `otherVar'
17:11:40 <startling> dylukes, yeah, I heard! I look forward to seeing how that works
17:12:00 <ski> Nereid : `subst env expr = do var <- expr; subst env (env var)'
17:12:11 <dylukes> jmcarthur: ^
17:12:12 <dylukes> brb
17:12:59 <ski> Nereid : `var <- expr' means "nondetermistically select each variable `var' in `expr', plugging the rest of the monadic computation in place of that variable in the original `expr'"
17:13:07 <Nereid> ok I get it.
17:13:26 <ski> copumpkin : yes .. assuming you have any variable at all to start from :)
17:13:32 <copumpkin> yup
17:14:07 <elliott__> copumpkin: I remember when AST substitution monads were arcane magic and I surprised people with them.
17:14:11 <elliott__> You are ruining everything. :p
17:14:15 <copumpkin> lol
17:14:23 <copumpkin> it's all ski's fault
17:14:24 <ski> this `subst' looks like a nonterminating expression, but actually works fine :)
17:14:26 <shirt> > (1 Prelude.+ 1, 'a' : ['b'])
17:14:28 <lambdabot>   (2,"ab")
17:14:28 <dylukes> elliott__: You can still surprise me!
17:14:29 <shirt> > 'c' Prelude.: ['d']
17:14:30 <lambdabot>   Not in scope: data constructor `Prelude.:'
17:14:36 <copumpkin> ski: only on some monads, though
17:14:41 <shirt> what's going on with that? ^
17:15:14 <nand`> ski: assuming you have some alphabet other than free variables
17:15:37 <Nereid> ski: well, subst return wouldn't terminate I think
17:15:48 <elliott__> dylukes: data Term a = Var a | Apply (Term a) (Term a) | Abstract (Term (Maybe a))
17:15:57 <nand`> Nereid: that too
17:16:03 <elliott__> Abstract is lambda; (>>=) is substitution, Term Void is a term with no free variables, Term (Maybe Void) is a term with one free variable.
17:16:16 <elliott__> Beta-reduction is really easy but I forget which monadic combinator it corresponds to.
17:16:21 <elliott__> copumpkin probably knows.
17:17:15 <Nereid> elliott__: cool
17:17:39 <hpaste> Qrt pasted “readMVar in submitForm” at http://hpaste.org/71920
17:17:48 <nand`> elliott__: how does that Abstract work? I would have expected Abstract a (Term a)
17:18:11 <elliott__> nand`: id is Abstract Nothing
17:18:16 <elliott__> K combinator is Abstract (Abstract (Just Nothing))
17:18:21 <elliott__> think of it as peano numerals
17:18:25 <elliott__> Nothing = 0, Just = S
17:18:25 <elliott__> er
17:18:28 <elliott__> Abstract (Var Nothing)
17:18:33 <elliott__> Abstract (Abstract (Var (Just Nothing)))
17:18:38 <Nisstyre> why does ghc let you do ``let a @ b = a + b''
17:18:43 <elliott__> so first is \0
17:18:45 <elliott__> second is \\1
17:18:48 <elliott__> think de bruijn indices
17:19:01 <elliott__> Nisstyre: a@b as a pattern means "match against b and call the whole thing a"
17:19:09 <nand`> elliott__: got it
17:19:09 <avpx> Nisstyre: Why shouldn't it?
17:19:11 <elliott__> so xss@(x:xs) matches the input against (x:xs), but also binds the value (x:xs) to xss
17:19:22 <elliott__> so that's the same as let x = x + x
17:19:24 <Nisstyre> avpx: I though it only applied to lists for some reason
17:19:29 <Nisstyre> *thought
17:19:35 <avpx> That what only applied to lists?
17:19:36 <dylukes> elliott__: I need to look into this later when I have the mindshare for it.
17:19:41 <Nisstyre> avpx: @ patterns
17:19:43 <dylukes> Right now I just suddenly got a bunch of work to do.
17:19:48 <dylukes> Mind talking to me about it later?
17:20:05 <elliott__> Sure, if I'm around. It is a pretty simple representation, but very cool.
17:20:06 <nand`> elliott__: would be clearer with something like data N a = Z | S a /me thinks
17:20:20 <avpx> Nisstyre: IIRC you can use those for all kinds of patterns matching constructors
17:20:21 <Nereid> "let a@pat = expr" behaves the same as "let pat = a in expr"
17:20:23 <elliott__> nand`: Sure, you can define Scope a = Top | Down a.
17:20:26 <nand`> perhaps even data Var a = Local | Outer a
17:20:32 <Nereid> er
17:20:39 <elliott__> Maybe is just convenient because it already exists.
17:20:41 <nand`> s/Local/Inner/
17:20:42 <nand`> elliott__: indeed
17:20:51 <Nereid> it makes a lot more sense in functions, I guess
17:20:53 <nand`> elliott__: better than introducing two definitions in one IRC line and needing to digest both
17:21:00 <Nereid> "\a@pat -> expr" -> "\a -> let pat = a in expr"
17:21:20 <jmcarthur> > let f a@b@c@d = a + b + c + d in f 1
17:21:22 <lambdabot>   4
17:22:15 <Nisstyre> Nereid: that makes sense
17:22:24 <Nisstyre> well, it makes more sense with functions
17:22:56 <Nereid> I don't know where else you'd want to use it.
17:23:06 <jmcarthur> let a@b = 5 in a + b
17:23:10 <jmcarthur> > let a@b = 5 in a + b
17:23:11 <lambdabot>   10
17:23:17 <elliott__> Nereid: You can use it for the fibs definition.
17:23:21 <elliott__> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
17:23:26 <elliott__> fibs@(_:xs) = 0 : 1 : zipWith (+) fibs xs
17:23:38 <Nereid> aha.
17:23:40 <elliott__> YMMV as to how much this confuses you.
17:23:47 <Nereid> well, just translate it I guess
17:23:55 <Nisstyre> jmcarthur: so it can let you give something multiple names nicely, that's cool
17:23:59 <jmcarthur> it feels something like an n+k pattern
17:24:05 <jmcarthur> yeah, that
17:24:12 <Nisstyre> I don't think I would ever feel the need to use that in my code though
17:24:17 <Nereid> > let fibs = let (_:xs) = fibs in 0 : 1 : zipWith (+) fibs xs in fibs
17:24:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:24:23 <jmcarthur> elliott__'s example is what i intended to compare to an n+k pattern
17:24:53 <Nereid> > let fibs(_:xs) = 0 : 1 : zipWith (+) fibs xs in fibs
17:24:55 <lambdabot>   Couldn't match expected type `[a]'
17:24:55 <lambdabot>         against inferred type `[t1] -> t'
17:24:56 <Nereid> er
17:24:58 <Nereid> > let fibs@(_:xs) = 0 : 1 : zipWith (+) fibs xs in fibs
17:24:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:25:16 <jmcarthur> Nisstyre: one example might be that you want to use the result of a lookup (which normally returns a maybe) in two ways, one of which includes the Just and the other of which does not... just for example
17:25:32 <Nisstyre> jmcarthur: good point
17:25:41 <Nereid> so @ in let bindings would be useful for recursive ones.
17:25:46 <Tekmo> > let x = x in x
17:25:50 <lambdabot>   mueval-core: Time limit exceeded
17:27:02 <startling> > let x = x ** x in x
17:27:06 <lambdabot>   mueval-core: Time limit exceeded
17:27:25 <startling> > let x = x ** x in (2, x)
17:27:29 <lambdabot>   mueval-core: Time limit exceeded
17:27:35 <startling> oh, let is strict?
17:27:44 <jmcarthur> no
17:27:44 <startling> or is show just trying to evaluate it?
17:27:49 <nand`> startling: that's just lambdabot
17:27:50 <Tekmo> > let x = x in fst (2, x)
17:27:51 <nand`> or rather mueval
17:27:52 <lambdabot>   2
17:28:03 <Nereid> > let x = () : x in x
17:28:04 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
17:28:08 <nand`> startling: it fully evaluates the ‘show’ result
17:28:14 <nand`> before returning
17:28:19 <jmcarthur> well, not that
17:28:19 <startling> right, understood
17:28:21 <nand`> hmm
17:28:23 <Axman6> > let x = x ** x in (2,"                                                                                                                                                                     ",x)
17:28:26 <nand`> well, up to a limit
17:28:27 <Nereid> > let x = x ** x in take 3 $ show (2, x)
17:28:27 <lambdabot>   mueval-core: Time limit exceeded
17:28:28 <jmcarthur> as Nereid's example demonstrates, it is lazy
17:28:28 <lambdabot>   "(2,"
17:28:31 <Axman6> hmm
17:29:05 <Axman6> > let x = x ** x in (2,"                                                                                                                                                                                                         ",x)
17:29:09 <lambdabot>   mueval-core: Time limit exceeded
17:29:13 <Axman6> you suck lambdabot
17:29:45 <jmcarthur> mfix f = let a@(Just b) = f b in a  -- a possible implementation of mfix for Maybe
17:29:48 <Nereid> > let x = x ** x in (2,replicate 2^16 ' ',x)
17:29:49 <lambdabot>   No instance for (GHC.Num.Num [a])
17:29:50 <lambdabot>    arising from a use of `e_12216' at <in...
17:29:52 <avpx> Axman6: I don't see what you expect it to do
17:29:55 <Nereid> > let x = x ** x in (2,replicate (2^16) ' ',x)
17:29:56 <lambdabot>   (2,"                                                                       ...
17:30:01 <Nereid> Axman6: just not long enough ;)
17:30:18 <Axman6> there we go, what Nereid managed to do
17:30:21 <avpx> Ah, I see.
17:30:28 <avpx> Nereid++
17:30:59 <Nereid> I guess it's possible to use this to find out how much of show <expr> it uses internally
17:31:09 <Nisstyre> > let x@(Just y) = Just "foo" in (x,y)
17:31:10 <lambdabot>   can't find file: L.hs
17:31:20 <Nisstyre> o_O
17:31:45 <avpx> Now look what you've done.
17:32:00 <Axman6> hmm, how does one fix that? @unsomething
17:32:05 <Nereid> looks like 1024.
17:32:08 <jmcarthur> @undef
17:32:12 <Axman6> thanks
17:32:15 <jmcarthur> > let x@(Just y) = Just "foo" in (x,y)
17:32:16 <lambdabot>   (Just "foo","foo")
17:32:26 <Nereid> > replicate 1023 ++ undefined
17:32:28 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
17:32:28 <lambdabot>    arising from a use of...
17:32:34 <Nereid> > replicate 1023 'x' ++ undefined
17:32:36 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
17:32:37 <Nereid> > replicate 1022 'x' ++ undefined
17:32:40 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
17:32:44 <Nereid> er
17:32:45 <ski> @let subst :: Monad m => (var -> m var) -> (m var -> m otherVar); subst env expr = do var <- expr; subst env (env var)
17:32:46 <lambdabot>  <local>:1:94:
17:32:46 <lambdabot>      Ambiguous occurrence `subst'
17:32:46 <lambdabot>      It could refer to eithe...
17:32:50 <Nereid> > replicate 1022 'x' ++ fix id
17:32:54 <lambdabot>   mueval-core: Time limit exceeded
17:32:55 <Nereid> > replicate 1023 'x' ++ fix id
17:32:58 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
17:33:00 <Nereid> :)
17:33:10 <ski> @let substM :: Monad m => (var -> m var) -> (m var -> m otherVar); substM env expr = do var <- expr; substM env (env var)
17:33:12 <lambdabot>  Defined.
17:33:14 <ski> > (`substM` return 1) $ \n -> if n > 1000 then Left n else return (2 * n)
17:33:17 <lambdabot>   Left 1024
17:33:24 <ski> copumpkin : like that one e.g.
17:33:34 <nand`> I guess mueval internally strictly evaluates something like “take n (show expr)” for some n
17:33:44 <aristid> :t substM
17:33:45 <lambdabot> forall var (m :: * -> *) otherVar. (Monad m) => (var -> m var) -> m var -> m otherVar
17:33:51 <Nereid> nand`: I guess so.
17:33:52 <Nereid> where n = 1024
17:34:16 <ski> (i was trying for something like `ErrorT [Integer] (StateT Integer [])' at first, but couldn't get it to accept 'ErrorT [Integer]')
17:34:18 * hackagebot th-orphans 0.5.2.0 - Orphan instances for TH datatypes (MichaelSloan)
17:34:49 <jmcarthur> nand`: i don't think so
17:34:53 <Nereid> nand`: if you ask lambdabot in pm it'll give you the whole 1024
17:35:19 <weasels> > let k = const; s = ap; i = id; t = k; f = ki; n = f t in (f n) 3 4
17:35:20 <jmcarthur> nand`: startling's code had to evaluate a strict type. there were simply no partial results to show
17:35:21 <lambdabot>   Not in scope: `ki'
17:35:25 <weasels> > let k = const; s = ap; i = id; t = k; f = k i; n = f t in (f n) 3 4
17:35:26 <lambdabot>   3
17:35:37 <weasels> why does that work for you, lambdabot :|
17:35:45 <jmcarthur> oh, wait
17:35:56 <jmcarthur> :t let x = x ** x in (2, x)
17:35:57 <lambdabot> forall t a. (Floating a, Num t) => (t, a)
17:36:04 <jmcarthur> > let x = x ** x in (2, x)
17:36:08 <lambdabot>   mueval-core: Time limit exceeded
17:36:11 <nand`> jmcarthur: but consider Nereid's example of the same expression but with a take 3 before it
17:36:18 <jmcarthur> that is incorrect, mueval!
17:36:30 <Nereid> jmcarthur: I suspect that when you give it expr,
17:36:38 <jmcarthur> > let x = x ** x in show (2, x)
17:36:41 <Nereid> it uses take 1024 (show expr)
17:36:42 <lambdabot>   mueval-core: Time limit exceeded
17:36:44 <otters> okay
17:36:47 <otters> :t id
17:36:48 <lambdabot> forall a. a -> a
17:36:51 <Nereid> and then puts it into something strict like Text
17:37:00 <jmcarthur> yuck
17:37:10 <Nereid> and then spits it out in irc, trimming it if it's too long for the channel
17:37:19 <nand`> this leaves the obvious question of: why doesn't mueval like partial show output?
17:37:29 <jmcarthur> nand`: Nereid just explained it
17:37:44 <jmcarthur> sounds plausible, at least
17:37:44 <nand`> jmcarthur: I meant on a conceptual level, why it's programmed that way
17:37:49 <jmcarthur> a mistake?
17:38:02 <otters> oh, it's probably because lambdabot has so many bizarre Num instances
17:38:04 <Nisstyre> > show 3
17:38:06 <lambdabot>   "3"
17:38:34 <Nereid> > 1 + id
17:38:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:38:36 <lambdabot>    arising from a use of `...
17:38:41 <Nereid> oh right.
17:38:43 <ski> > (1 + id) 3
17:38:44 <lambdabot>   4
17:38:56 <jmcarthur> i really love that instance, honestly
17:39:01 <otters> I can't get the SKI combinator version of false to work :|
17:39:02 <ski> > (cos ^ 2 + sin ^ 2) (pi / 8)
17:39:03 <nand`> I do too, actually
17:39:04 <lambdabot>   1.0
17:39:06 <otters> what's the deal here
17:39:15 <nand`> In fact, I often miss an Integral a => Integral (b -> a) instance
17:39:27 <Nereid> > (1 + id + id^2) 2
17:39:29 <lambdabot>   7
17:39:33 <jmcarthur> otters: Num b => Num (a -> b)
17:39:41 <nand`> f * b is so much cleaner than (*) <$> f <*> b
17:39:47 <nand`> and that's all it is, really
17:40:05 <otters> > let f = const id; n = f (const id) in (f n) 'c' 'd'
17:40:06 <lambdabot>   Couldn't match expected type `t -> t1'
17:40:06 <lambdabot>         against inferred type `GHC.T...
17:40:27 <otters> > let f = const id; n = f const in (f n) 'c' 'd'
17:40:28 <lambdabot>   Couldn't match expected type `t -> t1'
17:40:28 <lambdabot>         against inferred type `GHC.T...
17:40:43 <otters> wikipedia says not should be postfix
17:43:12 <ski> @check liftM2 (>) (cos ^ 2 + sin ^ 2 - 1) (-0.000000000000001)
17:43:13 <lambdabot>   "OK, passed 500 tests."
17:43:53 <ski> @check liftM2 (<) (abs (cos ^ 2 + sin ^ 2 - 1)) 0.000000000000001
17:43:55 <lambdabot>   "OK, passed 500 tests."
17:45:30 <jmcarthur> > cos^2 + sin^2 <$> [0..10]
17:45:32 <lambdabot>   [1.0,1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0...
17:45:48 <jmcarthur> it just feels good...
17:47:50 <jmcarthur> even taking it to further extremes...
17:47:53 <jmcarthur> > ((*) + (*)) 3 4
17:47:54 <lambdabot>   24
17:50:47 <dylukes> elliott__: Okay… I think I can follow now.
17:51:26 <elliott__> Oh, that's good. I was trying to remember the (>>=) clause for Abstract :p
17:51:39 <dylukes> So what was the monad again?
17:51:46 <dylukes> It looked sort of like a free monad.
17:52:07 <augur> ski: oh wow, i just derived let as syntax for cut without intending to
17:52:09 <augur> hahaha
17:52:26 <elliott__> I don't think it's free.
17:52:41 <jmcarthur> the ast? looked free to me, too
17:52:45 <jmcarthur> Var is return, no?
17:52:48 <elliott__> Maybe it is.
17:52:51 <elliott__> Yeah, Var is return.
17:52:55 <elliott__> Let's see... the clause in question is Term (Scope (Term a)) -> Term a.
17:53:11 <dylukes> I've gotten used to Pure/Wrap as opposed to Return/Roll
17:53:12 <jmcarthur> in fact, all free monads are essentially ASTs, in a sense
17:53:23 <dylukes> something about them still hasn't quite clicked yet ...
17:53:27 <dylukes> but I get the general idea.
17:53:43 <elliott__> Bah, I've forgotten the neat and elegant definition of the monad I had.
17:53:47 <dylukes> data Term a = Var a | Apply (Term a) (Term a) | Abstract (Term (Maybe a))
17:53:51 <elliott__> I blame copumpkin.
17:54:35 <dylukes> I'm trying to grok this atm
17:54:35 <dylukes> http://comonad.com/reader/2008/monads-for-free/
17:54:46 <dylukes> also, I'm wondering what the signature for Term would look like?...
17:54:59 <elliott__> The signature?
17:55:20 <dylukes> the functor you derive the free monad from.
17:55:24 <elliott__> I am really not sure it is a free monad because of that pesky Term (Maybe a).
17:55:31 <ski> augur : heh, i mentioned `let x0 = e0 in e1' is basically cut, yes ?
17:55:32 <elliott__> With just Var and Apply it would be.
17:55:43 <augur> ski: you did, yes
17:55:51 <augur> ski: but i mean, i just did some graph manipulations and got it accidentally
17:55:58 <ski> hehe
17:55:59 <augur> ski: which makes me very happy!
17:56:17 * ski dances the happy dance
17:56:44 <ski> Happy Happy. Joy Joy.
17:57:09 <dylukes> So.
17:57:11 <dylukes> What's a coproduct?
17:57:22 <ski> the dual of a product
17:57:26 <ski> next question ?
17:57:41 <dylukes> What are the implications, practical use cases, etc of coproducts in the domain of Haskell types.
17:57:44 <dylukes> ?*
17:57:45 <lambdabot> Maybe you meant: . ? @ v
17:58:03 <copumpkin> dylukes: Either
17:58:07 <copumpkin> next question?
17:58:11 <ski> coproducts corresponds to stuff like `Either' (at least if we ignore partial elements)
17:58:14 <dylukes> Either isn't just a product?
17:58:24 <ski> no, `(,)' is the product
17:58:30 <copumpkin> *a
17:58:33 <ski> (also ignoring partial stuff)
17:58:37 <dylukes> so… the coproduct is a disjoint union?
17:58:40 <copumpkin> yeah
17:58:44 <dylukes> er, a generalization of it
17:58:57 <dylukes> that's neat that it's dual like that :\
17:58:59 <copumpkin> well, that's a strange way to put it
17:59:10 <copumpkin> min is also a coproduct :)
17:59:29 <Nereid> Either is a coproduct in Hask.
17:59:31 <dylukes> …exsqueeze me? bacon powder?
17:59:34 <copumpkin> min
17:59:37 <copumpkin> max vs. min
17:59:39 <copumpkin> max = product
17:59:43 <copumpkin> min = coprorudt
17:59:47 <Nereid> in a different category, though
17:59:49 <copumpkin> ugh, look at that typo
17:59:55 * dylukes shivers.
17:59:56 <jmcarthur> trying to think of an elegant way to write (\a b -> sin a * sin b) using the tricked out Num instance...
18:00:07 <Nereid> @pl \a b -> sin a * sin b
18:00:07 <lambdabot> (. sin) . (*) . sin
18:00:09 <ski> in abelian groups, the product and coproduct of two groups yield the same group
18:00:09 <copumpkin> jmcarthur: I don't think you can without using curry
18:00:16 <Nereid> me either
18:00:30 <copumpkin> :t (sin . fst) + (sin . snd)
18:00:31 <lambdabot> forall a. (Floating a) => (a, a) -> a
18:00:41 <jmcarthur> :\
18:00:50 <dylukes> I wish I had more time before I left for Greece.
18:00:58 <dylukes> I want to actually finish Conceptual Mathematics.
18:01:07 <copumpkin> > curry (sin . fst + sin . snd) 5 6
18:01:09 <lambdabot>   -1.2383397728620644
18:01:26 <jmcarthur> well, this works, but only because the literals play in my favor:
18:01:28 <ski> @type (const . sin) + (const sin)
18:01:30 <lambdabot> forall a. (Floating a) => a -> a -> a
18:01:35 <jmcarthur> > (sin * const sin) 5 6
18:01:36 <copumpkin> ski: nice
18:01:37 <lambdabot>   0.2679383039400445
18:01:43 <jmcarthur> ooh
18:01:50 <jmcarthur> that's the gist of what i was looking for
18:01:56 <jmcarthur> and i apparently got that other one wrong, wtf
18:02:04 <jmcarthur> oh no i didn't
18:02:07 <ski>  > (sin * const sin) 5 6 :: Expr
18:02:12 <ski> > (sin * const sin) 5 6 :: Expr
18:02:13 <lambdabot>   sin 5 * sin 6
18:02:24 <copumpkin> the sin multiplies
18:02:25 <ski> > ((const . sin) + (const sin)) 5 6 :: Expr
18:02:25 <dylukes> It's very hard for me at first… retractions/sections somehow didn't even sit right haha.
18:02:27 <lambdabot>   sin 5 + sin 6
18:02:28 <copumpkin> repent and be saved
18:02:33 <copumpkin> the end is nigh
18:02:47 <copumpkin> constant sin multiplies
18:02:52 <dylukes> What.
18:02:57 <Nereid> lol
18:03:01 * copumpkin rings his bell and brandishes his sign
18:03:31 <dylukes> copumpkin: ski: jmcarthur: augur: Are you guys the Four Horsemen of the Haskellocalypse?
18:04:24 <Nereid> dylukes: iirc, the terms section/retraction originally come from topology
18:04:38 <Nereid> where section is in the sense of "cross section"
18:04:46 <Nereid> http://en.wikipedia.org/wiki/Section_%28fiber_bundle%29
18:05:26 <jmcarthur> dylukes: not sure who would be which :)
18:05:53 <dylukes> There needs to be a Horseman of Totality...
18:06:05 <dylukes> Not sure about any of the others.
18:07:14 <jmcarthur> @check (liftA2.liftA2) ((liftA2.liftA2) (<) (abs (-)) 0.00000001) (const . sin * const sin) ((cos(-) - cos(+))/2)
18:07:17 <lambdabot>   "OK, passed 500 tests."
18:07:20 <jmcarthur> :D
18:08:07 <jmcarthur> i dislike all the liftA2 stuff
18:09:35 <copumpkin> gotta use idiom brackets
18:09:38 <jmcarthur> i think copumpkin would be the Horseman of Totality, being the agda user that he is
18:09:52 <copumpkin> lol, most of my code isn't actually written in agda, sadly
18:10:03 <jmcarthur> but you write more agda than i do, at least
18:10:09 <copumpkin> probably true :)
18:10:36 <jmcarthur> if i use idiom brackets there's almost no point in the num instance
18:10:49 <copumpkin> yeah
18:12:38 <ski> idiom brackets in Agda ?
18:13:03 <jmcarthur> two conversations mixed into one
18:17:42 <augur> :t liftA2
18:17:44 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
18:17:59 <augur> :t (<$>)
18:18:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:18:25 <copumpkin> :t pure
18:18:26 <augur> hm
18:18:26 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
18:18:37 <copumpkin> countdown!
18:18:37 <augur> i suppose they have different properties?
18:18:42 <augur> lol
18:19:07 <augur> but
18:19:07 <jmcarthur> :t id
18:19:08 <lambdabot> forall a. a -> a
18:19:14 <copumpkin> :t ea
18:19:14 <jmcarthur> no what?!
18:19:16 <lambdabot> Not in scope: `ea'
18:19:20 <jmcarthur> *now
18:19:26 <augur> pure f <*> x   =   f <$> x
18:19:26 <copumpkin> :t is
18:19:27 <lambdabot> Not in scope: `is'
18:19:30 <augur> so im guess
18:19:36 <augur> guessing*
18:20:15 <augur> pure (pure f <*> x) <*> y   =   pure (f <$> x) <*> y   =   f <$> x <$> y   =   liftA2 f x y
18:20:15 <augur> ??
18:20:20 <augur> or is this not true
18:20:23 <jmcarthur> almost
18:20:42 <jmcarthur> :t \f x y -> f <$> x <$> y
18:20:43 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
18:20:49 <jmcarthur> :t liftA2
18:20:50 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
18:21:10 <augur> hm
18:21:23 <jmcarthur> should i offer the real one or let you keep thinking?
18:21:31 <augur> sure, what is it
18:21:42 <jmcarthur> f <$> x <*> y = liftA2 f x y
18:21:52 <augur> ah right, that was my other guess
18:21:54 <copumpkin> now you must figure out how those associate :)
18:22:00 <jmcarthur> ha
18:22:07 <copumpkin> (not really hard at all)
18:22:13 <copumpkin> but can't hurt
18:22:19 <augur> cause i remember maaaaybe seing conor writing   {[ f x y ... ]} = f <$> x <*> y <*> ...
18:23:00 <jmcarthur> @where she
18:23:00 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
18:23:19 <copumpkin> @where is she
18:23:20 <lambdabot> I know nothing about is.
18:23:33 <jmcarthur> :(
18:23:43 <augur> obviously we need a new version of lambdabot
18:23:53 <jmcarthur> is there an agdabot yet?
18:23:53 <augur> that allows for conorian ridiculosity
18:24:01 <augur> jmcarthur: yes, its called agda
18:24:01 <djahandarie> jmcarthur, no, but there should be!
18:24:02 <copumpkin> jmcarthur: nope
18:24:13 <copumpkin> djahandarie: come back! you can stop hiding now
18:24:15 <jmcarthur> i started one once, but lost interest
18:24:23 <augur> let me tell you, i have some lovely conversations with agda
18:24:27 <augur> its the best chat bot i know of
18:24:49 <djahandarie> copumpkin, I'm in hibernation!
18:24:49 <jmcarthur> augur: she says "you're wrong" most of the time, to me
18:25:27 <augur> theres a sexist joke in there somewhere
18:25:45 <jmcarthur> if so, completely unintentional
18:25:54 <augur> indeed
18:25:56 <augur> but funnily
18:26:00 <jollyrancher> hi guys. i'm looking at the function types for foldl and foldr. foldl :: (a -> b -> a) -> a -> [b] -> a;  foldr :: (a -> b -> b) -> b -> [a] -> b. it seems like they are basically the same thing except for the a and b variables being swapped around? is there a reason for this?  is it the same thing?
18:26:09 <augur> i noticed it, drew your attention to it, and thereby got to make the joke
18:26:15 <augur> without being sexist
18:26:15 <jmcarthur> jollyrancher: not the same :)
18:26:27 <jmcarthur> > foldl f z [a,b,c,d,e]
18:26:28 <augur> how convenient is that!
18:26:29 <lambdabot>   f (f (f (f (f z a) b) c) d) e
18:26:31 <jmcarthur> > foldr f z [a,b,c,d,e]
18:26:32 <lambdabot>   f a (f b (f c (f d (f e z))))
18:26:44 <jmcarthur> jollyrancher: ^^
18:27:18 <YayMe> How would anyone here write a function that takes "sii+" and returns the appropriate function, but may also take "skk+" or any other such SKI string?
18:27:47 <jmcarthur> YayMe: returns the appropriate function whose type depends on the input string?
18:27:47 <YayMe> I'm trying, and I keep running into an issue defining the sig since what it returns may be any of a number of functions
18:27:49 <jollyrancher> I know that that foldl starts from the left of the list and foldr starts from the end of the list? but I wouldn't be able to guess that from reading :t foldl and :t foldr :(
18:28:09 <YayMe> jmcarthur: yes... it feels like I should have to do this in a dynamic language
18:28:23 <jollyrancher> let me try to read the type definition for foldl then foldr.
18:28:23 <YayMe> jmcarthur: But It could just be that I don't know haskell well enough
18:28:35 <jmcarthur> YayMe: sounds like a job for dependent types, to me... or you could use Dynamic, if you want to go the dynamic types route
18:28:52 <jmcarthur> (haskell doesn't have dependent types, unfortunately)
18:29:22 <YayMe> jmcarthur: I would like to avoid dynamicism; If I wanted to do it dynamically I could just use lisp or javascript
18:29:31 <jmcarthur> YayMe: if the string is always statically in your code you could perhaps make a quasiquoter or something
18:29:37 <YayMe> jmcarthur: it's just a learning exercise, I came across a problem I don't know how to solve
18:29:38 <jollyrancher> foldl takes a function as a parameter, this function has 2 args, one of type a and another of type b and returns something of type b, foldl takes a 2nd parameter of type a and of type b as a list and returns something of type a
18:29:50 <jollyrancher> am I reading this correctly?
18:30:04 <YayMe> jmcarthur: no no, the string would be read in, like I said, would be any combinator you give it
18:30:22 <YayMe> err any combination of SKI combinators that is
18:30:38 <jmcarthur> yeah, dependent types are really the only way to statically type check that without weakening your types to something like Dynamic
18:30:57 <YayMe> jmcarthur: Ok, so how do those work and how do I use them?
18:31:14 <jmcarthur> haskell doesn't have dependent types :(
18:31:19 <parcs`> heh,that's quite the question
18:31:31 <jmcarthur> it keeps stepping closer to having them, but still doesn't
18:31:55 <startling> sort of disappointing that there aren't any usable languages with dependent types
18:32:02 <jmcarthur> i think agda is pretty usable
18:32:09 <jmcarthur> it just lacks libraries
18:32:25 <startling> is the compiler still kind of iffy?
18:32:30 <jmcarthur> eh, probably
18:32:38 <YayMe> What are dependent types, and where do I find info that describes them that isn't going to use tons of math diagrams with symbols I don't know
18:32:46 <jmcarthur> but what agda developer actually compiles an executable?
18:32:54 <startling> YayMe, they're types that let you have arbitrary values in them
18:32:56 <Eduard_Munteanu> startling: iffy how?
18:32:57 <startling> jmcarthur: exactly!
18:33:09 <jmcarthur> startling: not only that
18:33:09 <YayMe> startling: How is that not dynamic?
18:33:20 <YayMe> startling: Something like an ultra version of algebraic data types?
18:33:25 <startling> YayMe, they're dependent types!
18:33:26 <jmcarthur> YayMe: a dependent type is a type that can depend on runtime values
18:33:34 <Eduard_Munteanu> YayMe: they're basically types that can depend on values
18:33:34 <jmcarthur> YayMe: but it's statically checkable
18:33:54 <startling> Eduard_Munteanu, I remember having tons of trouble getting it to compile
18:34:12 <jmcarthur> (depends on the language, actually, whether it's statically checkable, but most do it that way)
18:34:16 <startling> I'm on OS X though, which could be part of it
18:34:16 <djahandarie> YayMe, your only "Haskell-ish" option is to have a type representing all SKI functions, then an "interpret" function which takes in a value of that type, and a list of input values, and returns an output value.
18:34:30 <djahandarie> YayMe, but if you want to learn dependent types, that's the superior approach. :)
18:34:37 <djahandarie> But also the long and hard path, probably.
18:34:37 <YayMe> djahandarie: I was trying that but couldn't come up with an appropriate implementation trying it
18:34:46 <Eduard_Munteanu> jmcarthur: um, does that make PHP a DT language? :P
18:34:47 <startling> YayMe: anyway, the idea is that you could have types like "a string 5 characters long
18:34:59 <startling> "
18:35:00 <YayMe> djahandarie: But I could, you think?
18:35:01 <jmcarthur> YayMe: using dependent types to solve your problem would involve two steps: write a function to generate the appropriate type given an input string, then write a function that generates a value of that type given the input string
18:35:23 <startling> haskell types don't really exist in the compiled output, do they?
18:35:39 <Eduard_Munteanu> startling: it isn't too hard to compile a Hello World.
18:35:41 <jmcarthur> startling: they do if you use Typeable and such
18:35:42 <djahandarie> YayMe, could what? Write interpret, or learn dependent types?
18:36:01 <Eduard_Munteanu> A bit more trouble is getting sensible do notation and all that, IMO.
18:36:04 <startling> jmcarthur, ah, right
18:36:12 <djahandarie> startling, they're erased, but typeclass dictionaries show up.
18:36:22 <startling> oh, right
18:36:30 <startling> why are typeclasses dictionaries, by the way?
18:36:43 <djahandarie> As opposed to?
18:36:48 <jmcarthur> it's just a nice way to implement them
18:36:49 <YayMe> djahandarie: I mean, is haskell capable of using algebraic data types to represent SKI combined functions in a manner that could be a function output, and then an interpreter that would work
18:37:15 <jmcarthur> YayMe: if you fix the function's output type to a certain kind of function, it's possible
18:37:16 <startling> I feel like "a + b" could be compiled to "int_add a b"
18:37:28 <Eduard_Munteanu> startling: you can already do it with SPECIALIZE pragmas
18:37:45 <djahandarie> YayMe, just have a datatype which represents a SKI function, then an interpreter which takes inputs, and you'll only have a single output type.
18:37:49 <jmcarthur> YayMe: like, you could pretty easily write a function like   foo :: String -> Maybe (Int -> Int)
18:37:52 <djahandarie> startling, doing that everywhere leads to code bloat.
18:37:55 <Eduard_Munteanu> One reason it's not done automatically is code size.
18:38:00 <startling> djahandarie, yeah, that makes sense
18:38:23 <jmcarthur> startling: also, sometimes you can't determine the instance statically
18:39:02 <startling> if you had a Num a => a -> b function, you'd need to create a separate function for each Num that you use, right?
18:39:06 <jmcarthur> startling: e.g. what if you want to show a Foo, where Foo is defined like this:   data Foo = forall a. Show a => Foo a
18:39:29 <YayMe> djahandarie: data SKI x y z = S x -> y -> z -> (x -> z)(y ->z) | K x -> y -> x | I x -> x
18:39:39 <YayMe> Is that about right?
18:39:44 <djahandarie> I would definitely not do it like that.
18:39:50 <YayMe> ok
18:39:51 <YayMe> heh
18:40:08 <djahandarie> SKI should just be a tree of Ss, Ks, and Is.
18:40:23 <djahandarie> The "mapping" into Haskell world would happen in the interpret function.
18:40:41 <YayMe> what would the interpret function return?
18:40:47 <Eduard_Munteanu> YayMe: what do you want to do, translate an SKI term to lambdas?
18:40:47 <jmcarthur> YayMe: to be clear, what djahandarie is advocating is roughly equivalent as far as types are concerned to using Dynamic, except that instead of getting a function as a result you get an abstract syntax tree
18:41:33 <djahandarie> YayMe, that depends on your base terms.
18:41:33 <YayMe> jmcarthur: Ah, yeah I pondered working with an abstract syntax tree, but that seemed arbitrary when you consider SKI is an abstract syntax tree
18:41:43 <ski> YayMe : not sure what you're trying to do, but perhaps `data SKI :: * -> * where S :: SKI ((a -> (b -> c)) -> ((a -> b) -> (a -> c))); K :: SKI (a -> (b -> a)); I :: SKI (a -> a); App :: SKI (a -> b) -> (SKI a -> SKI b)' is what you want ?
18:41:48 <djahandarie> Haha
18:41:56 <jmcarthur> YayMe: with an AST, you would still have to have an interpreter for it, and you would just run into the same issue later. even if you don't end up actually generating a Dynamic, you still need some runtime checks of some sort to ensure that it's being used in the proper way
18:42:05 <djahandarie> I guess we highlighted ski a few too many times.
18:42:18 <Eduard_Munteanu> Hah.
18:42:20 <ski> djahandarie : only you, once
18:42:41 <djahandarie> Ah, by putting it by the start of the line. Guilty as charged :)
18:42:46 <Eduard_Munteanu> But SKI calculus can be untyped too, no?
18:42:51 <ski> yes
18:43:48 <djahandarie> And jmcarthur is correct, you delay the checking to the interpret, but you're inevitably going to have that somewhere with an untyped language
18:44:04 <djahandarie> And I think it's nicer to do it how I said it ;)
18:44:20 * jmcarthur too, for what it's worth
18:44:29 <jmcarthur> i was just skipping intermediate representations in my explanation
18:44:35 <Eduard_Munteanu> I think you can translate SKI to lambda terms pretty much directly.
18:45:17 <jmcarthur> Eduard_Munteanu: but not untyped SKI to typed lambda
18:45:27 <jmcarthur> at least not without some sort of extra checks and stuff
18:45:27 <Eduard_Munteanu> Yeah.
18:45:46 <Eduard_Munteanu> You'd have to translate to an untyped lambda AST.
18:45:57 <djahandarie> Which might as well be SKI ;)
18:46:11 <Eduard_Munteanu> Heh, fair, if you use const and id and... :)
18:46:27 <jmcarthur> my understanding was that YayMe was wanting to ultimately just generate a haskell function out of the string, not an ast
18:46:58 <YayMe> jmcarthur: right, again like I said, SKI is an abstract syntax tree
18:47:30 <ski> SKI isn't really a calculus, though ..
18:48:04 <Eduard_Munteanu> No? I hear "SKI combinator calculus" sometimes :/
18:48:24 * bckw was getting jealous of ski
18:48:31 <YayMe> haha
18:49:08 <djahandarie> Now that's an obscure joke right there
18:50:17 <ski> see <http://lambda-the-ultimate.org/node/533#comment-7712> for the distinction between "algebra" and "calculus"
18:50:24 <jollyrancher> guys, I'm having difficulty deferring things from type signatures of functions??. foldl :: (a -> b -> a) -> a -> [b] -> a       foldr :: (a -> b -> b) -> b -> [a] -> b         I'm focusing on these a and b's they are both of any time, correct?
18:50:28 <bckw> i personally think BCKW makes a lot more sense, honestly
18:50:45 <jollyrancher> and I don't understand how swapping the a and b makes a difference
18:50:48 <Eduard_Munteanu> jollyrancher: yeah, any type
18:50:56 <ski> bckw : i'm somewhat inclined to agree
18:51:02 <Eduard_Munteanu> jollyrancher: the reason is how foldl/foldr associate
18:51:18 <YayMe> I haven't looked into bckw just because ski is complete with less members
18:51:24 <Eduard_Munteanu> The accumulator is either on the left or right of the operator you're folding with.
18:51:49 <YayMe> bckw easier to recognize applications in?
18:51:55 <BMeph_> ...associatively? :-)
18:52:07 <Eduard_Munteanu> > foldl (-) 0 [a,b,c,d]
18:52:08 <lambdabot>   0 - a - b - c - d
18:52:12 <ski>   foldl :: (r -> a -> r) -> r -> [a] -> r
18:52:12 <ski>   foldr :: (a -> r -> r) -> r -> [a] -> r
18:52:14 <bckw> B provides simple compositions, and the other three combinators correspond to the each most-often-talked-about ability you can add or remove when talking about substructural type systems
18:52:14 <Eduard_Munteanu> > foldr (-) 0 [a,b,c,d]
18:52:16 <lambdabot>   a - (b - (c - (d - 0)))
18:52:20 <bckw> *abilities
18:52:28 <ski> jollyrancher : does the naming there ^ make it clearer ?
18:53:03 <ski> jollyrancher : `r' is the "result" type (both the initial value, all the intermediate results, and the final result), while `a' is the list element type
18:53:09 <YayMe> ski: SKI being actually just SK, is BCKW actually less combinators than BCKW?
18:53:16 <elliott__> <YayMe> I haven't looked into bckw just because ski is complete with less members
18:53:22 <elliott__> SK is complete with fewer -- oh, you said that.
18:53:32 * ski not just sk
18:53:43 <Eduard_Munteanu> You don't even need 'SK', a single combinator does it too :D
18:53:46 <bckw> YayMe: binary has fewer symbols than haskell
18:54:18 <EvanR1> if you have just a single combinator you might as well just have balance parenthetical expressions ;)
18:55:02 <ski> YayMe : itym "can `BCKW' actually be expressed with less combinators than `B',`C',`K',`W'" -- and i suspect that (barring silly stuff like "the" `X' combinator), the answer is no
18:55:05 <otters> > foldl (-) [1..10]
18:55:06 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
18:55:07 <lambdabot>    arising from a us...
18:55:12 <otters> > foldl (-) 1 [1..10]
18:55:13 <lambdabot>   -54
18:55:30 <jmcarthur> YayMe: BCKW is minimally complete
18:55:38 <YayMe> bckw: Yes, but I already know binary, I learned it before learning any depth of programming, and I figured to learn SK before learning any depth of the other systems, am I wrong to think BCKW is likely a simpler over SKI?
18:56:04 <jollyrancher> > foldr (\acc -> r+1) 0 [1,2,3]
18:56:05 <lambdabot>   Couldn't match expected type `b -> b'
18:56:05 <lambdabot>         against inferred type `Simple...
18:56:08 <jollyrancher> boo
18:56:20 <djahandarie> What is "r"?
18:56:23 <jmcarthur> YayMe: my point is that you probably don't find reasoning about native machine code in binary form to be as easy as reasoning about nice high level haskell code
18:56:29 <jollyrancher> > foldr (+) 0 [1,2,3]
18:56:31 <lambdabot>   6
18:56:43 <jmcarthur> YayMe: i see BCKW as "higher level" than SK, even though they are both really fundamental sets of combinators
18:56:50 <jollyrancher> > foldr (\acc -> acc+1) 0 [1,2,3]
18:56:51 <lambdabot>   2
18:57:00 <Cale> Is there a complete combinator basis where every term has a completely left-associated form?
18:57:10 <YayMe> jmcarthur: that's what I figured and why I avoided it, I wanted to get comfortable with the lower level combinator system before moving up
18:57:44 <jollyrancher> djahandarie, dunno, I don't know what I'm doing :)
18:57:58 <YayMe> Either way, I'll give it a look as I do understand the SKI combinators ok enough now, granted I couldn't apply them to save my life heh
18:58:16 <YayMe> I saw the Y combinator definition in SKI and about shit myself
18:58:23 <djahandarie> jollyrancher, if you're referring to non-existent variables, I think there are bigger problems at hand :P
18:58:45 <YayMe> I was able to figure out flip on my own however with SKI before reading the definition :D
18:58:45 <djahandarie> jollyrancher, also ignore that the last thing you tried worked, that's just lambdabot being quirky
18:58:58 <djahandarie> jollyrancher, normally that'd be a type error, because you are applying a number to another number, like 3 4
18:59:14 <favonia> > foldr (\acc -> acc+1) 0 [1,2,3 :: Integer]
18:59:15 <lambdabot>   Couldn't match expected type `b -> b'
18:59:15 <lambdabot>         against inferred type `GHC.In...
18:59:16 <jmcarthur> YayMe: BCKW is much less researched, unfortunately, so i doubt you will find as much helpful material on it
18:59:19 <EvanR1> > 3 4
18:59:20 <lambdabot>   3
18:59:24 <jmcarthur> and that's just sad
18:59:30 <favonia> that's the normal error message :)
19:00:07 <jollyrancher> :)
19:00:08 <jmcarthur> @check (liftA2.liftA2) ((liftA2.liftA2) (<) (abs (-)) 0.00000001) (const . sin * const sin) ((cos(-) - cos(+))/2)  -- EvanR1 check this one out that i wrote earlier using that instance!
19:00:10 <lambdabot>   "OK, passed 500 tests."
19:00:30 <povman> @ask dons Where is revision control for ByteString located? The link from http://hackage.haskell.org/package/bytestring is broken.
19:00:30 <lambdabot> Consider it noted.
19:00:47 <jmcarthur> jollyrancher: are you trying to do anything in particular?
19:01:39 <jmcarthur> jollyrancher: here's a template:    foldr (\x acc -> undefined) undefined [1,2,3]
19:01:47 <jmcarthur> jollyrancher: the name "acc" is misleading there, though
19:02:02 <jmcarthur> jollyrancher: because foldr is lazy. acc hasn't been evaluated yet!
19:02:03 <jollyrancher> jmcarthur, I have a few goals tonight, 1. understand type signatures of functions 2. understand why the map implementation with foldl requires ++ and the one for foldr requires cons
19:02:10 <YayMe> BCKW definitely appears simpler
19:02:33 <EvanR1> jmcarthur: eh what
19:03:02 <jollyrancher> I'm working with LYAH
19:03:09 <jmcarthur> EvanR1: it's a check of the trig property:   sin u * sin v == (cos (u-v) - cos (u+v))/2
19:03:25 <jmcarthur> EvanR1: and the abs (-) stuff is to implement approximate equality on floats
19:03:40 <Nereid> @type liftA2.liftA2
19:03:41 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
19:03:43 <jmcarthur> EvanR1: to be read as "the absolute value of the difference"
19:03:57 <Nereid> of course.
19:04:12 <EvanR1> now i get it
19:04:18 <jollyrancher> there are a lot of things in LYAH that aren't clear to me? it's more like 'just do this and don't try to understand it because it works, and that's the way it works'
19:04:25 <jmcarthur> @type liftA2 . liftA2 :: (a -> b -> c) -> (d -> e -> a) -> (d -> e -> b) -> (d -> e -> c)
19:04:26 <lambdabot> forall a b c d e. (a -> b -> c) -> (d -> e -> a) -> (d -> e -> b) -> d -> e -> c
19:04:32 <EvanR1> jmcarthur: what does @check check?
19:04:41 <otters> that the expression is true
19:04:44 <jmcarthur> EvanR1: it uses quickcheck to check properties
19:04:45 <otters> for a reasonably high number of x
19:04:46 <EvanR1> true ok
19:04:47 <otters> or y
19:04:50 <otters> or whatever
19:04:56 <EvanR1> i havented used quickcheck
19:05:14 <jmcarthur> EvanR1: it generates 500 combinations of random inputs for the function i gave it, which expects two parameters
19:05:17 <jollyrancher> is there a more comprehensive book than LYAH?
19:05:35 <jmcarthur> :t (liftA2.liftA2) ((liftA2.liftA2) (<) (abs (-)) 0.00000001) (const . sin * const sin) ((cos(-) - cos(+))/2)
19:05:37 <lambdabot> forall a. (Ord a, Floating a) => a -> a -> Bool
19:05:48 <nand`> I wouldn't call LYAH very comprehensive
19:05:54 <nand`> it's more of a starter
19:06:04 <jmcarthur> jollyrancher: real world haskell is more comprehensive, but even it doesn't go into anything *really* nitty gritty
19:06:12 <jmcarthur> it also already shows its age, despite not being that old
19:06:21 <jollyrancher> :(
19:06:23 <Nereid> needs a 2nd edition? :P
19:06:27 <jmcarthur> indeed
19:06:29 <nand`> there is one in progress
19:06:30 <EvanR1> real two years ago haskell
19:06:31 <nand`> afaik
19:06:46 <monochrom> notably Control.Exception
19:07:18 <EvanR1> the moving target of explaining haskell is great for book business
19:07:19 <Nereid> @type liftA
19:07:21 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
19:07:23 <Eduard_Munteanu> jollyrancher: you could google around for specific stuff. There's also RWH and the Wikibooks stuff.
19:07:26 <jmcarthur> interesting, the school of expression is much older but seems to have withstood the test of time in terms of material, somehow
19:07:37 <jmcarthur> *interestingly
19:07:41 <Eduard_Munteanu> @where rwh
19:07:42 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:07:43 <jmcarthur> at least, that is my observation
19:07:44 <Eduard_Munteanu> @where wikibooks
19:07:45 <lambdabot> I know nothing about wikibooks.
19:07:56 <Eduard_Munteanu> @google Haskell wikibooks
19:07:58 <lambdabot> http://en.wikibooks.org/wiki/Haskell
19:07:58 <lambdabot> Title: Haskell - Wikibooks, open books for an open world
19:08:08 <beekor> there is also Yet Another Haskell Tutorial, that i liked.
19:08:24 <jmcarthur> yeah, that's what i learned with
19:08:31 <jmcarthur> well, that was the first step, at least
19:08:42 <Eduard_Munteanu> I learned by Google I think.
19:08:46 <jollyrancher> thanks guys
19:08:53 * EvanR1 just woke up, gets back to haskell code
19:08:55 <Eduard_Munteanu> And the Gentle Introduction and various other stuff.
19:09:07 <jollyrancher> I forgot that I have RWH, I will read that instead
19:09:08 <jmcarthur> for me it was a complex combination of books, blogs, other google things, and irc
19:09:09 <Cale> jollyrancher: There's always the Report
19:09:26 <jmcarthur> jollyrancher: i think lyah might be a better start for most beginners
19:09:27 <Cale> jollyrancher: Also, "A Gentle Introduction to Haskell"
19:09:33 <jmcarthur> and then once it runs out try something else
19:09:45 <jmcarthur> but it depends on how you like to learn
19:09:49 <Eduard_Munteanu> On that account, the Gentle Introduction is more like an annotated version of the report :D
19:09:49 <nand`> I'm biased towards recommending LYAH because it's the only one I've actually read (fully)
19:09:53 <EvanR1> everything i know about haskell i basically got from the documentations of the libraries and this channel
19:10:00 <geekosaur> gentle my butt...
19:10:01 <jmcarthur> i *personally* would probably have done much worse with lyah than i did with yaht
19:10:20 <YayMe> Are there classes for haskell outside of extremely prominent universities?
19:10:24 <Eduard_Munteanu> It's gentle as a cheatsheet perhaps :D
19:10:29 <jollyrancher> jmcarthur, the problem with LYAH, at least for me is that I have lots of questions that are left unanswered?. it has me doing stuff and not explaining a lot
19:10:56 <nand`> jollyrancher: it's been a while, example?
19:10:57 <jmcarthur> jollyrancher: hang around in irc for such questions :)
19:11:19 <jmcarthur> there are always little gaps in understanding that are really most easily filled by open discussion with other people
19:11:29 <Cale> Yeah, I think for a lot of the deeper stuff, other humans are your best bet for an explanation
19:11:42 <nand`> sometimes it can be helpful to just restart the chapter/book
19:11:45 <jollyrancher> nand`, well it doesn't explain to me why the implementation for map using foldl requires ++ and the one for foldr requires :
19:11:50 <Cale> There are some good papers for specific topics
19:11:55 <nand`> the second reading increases understanding in cases where the first reading was not sufficient
19:12:06 <Cale> There's a gap in the space of books for Haskell though
19:12:15 <Eduard_Munteanu> YayMe: dunno, my university does teach Haskell in a PL-related course
19:12:42 <YayMe> Eduard_Munteanu: I meant outside of universities
19:12:43 <jmcarthur> my university taught me that "Haskell is just weird" and that it's fundamentally an interpreted language and could never be compiled
19:12:44 <Eduard_Munteanu> Not a lot though, they also teach some Lisp and stuff like that alongside, so it's quite a bit to cram in.
19:12:45 <Cale> jollyrancher: Well, it's because you don't want to reverse the list, right?
19:12:47 <YayMe> I have no intent of going to any university
19:12:53 <nand`> if there isn't a Haskell club at my next educational facility I intend to found one :)
19:12:55 <Eduard_Munteanu> Ah.
19:13:15 <Cale> jollyrancher: foldl takes the list apart backwards: http://cale.yi.org/share/Folds.svg
19:13:29 <Cale> (look at the diagram from foldl)
19:13:33 <Nereid> jollyrancher: the foldl implementation requires a way to add an element to the end of a list
19:13:42 <jmcarthur> > foldr (:) [] [a,b,c,d,e]
19:13:44 <lambdabot>   [a,b,c,d,e]
19:13:46 <jmcarthur> > foldr (++) [] [a,b,c,d,e]
19:13:47 <lambdabot>   Couldn't match expected type `[a]'
19:13:48 <lambdabot>         against inferred type `SimpleRef...
19:13:51 <YayMe> jmcarthur: Haha, gotta love how engineers treat things they don't understand..
19:14:10 <Cale> jmcarthur: lol
19:14:10 <Nereid> > foldr (\x -> ++ [x]) [] [a,b,c,d,e]
19:14:12 <lambdabot>   <no location info>: parse error on input `++'
19:14:12 <jmcarthur> YayMe: you nailed it. it was an engineering university more than a computer science university
19:14:15 <Cale> jmcarthur: When was that?
19:14:15 <Nereid> > foldr (\x -> (++ [x])) [] [a,b,c,d,e]
19:14:18 <lambdabot>   [e,d,c,b,a]
19:14:27 <Cale> jmcarthur: There have been compilers for Haskell for so long...
19:14:29 <jollyrancher> Cale, aaaaah
19:14:36 <nand`> jollyrancher: it should become obvious if you look at the way it groups
19:14:42 <nand`> foldl is left associative so you end up with:
19:14:43 <Nereid> ah yes, that's the picture.
19:14:59 <nand`> (((a ++ b) ++ c) ++ d) ++ e
19:15:01 <jmcarthur> Cale: oh i knew at the time about that. i argued with the teacher than said this
19:15:05 <jmcarthur> *that said
19:15:19 <nand`> note how you're appending to the right
19:15:22 <nand`> which is not possible with (:)
19:15:37 <jmcarthur> Cale: i graduated ... i guess it was four years ago or something like that
19:15:39 <jollyrancher> I see now
19:15:41 <nand`> foldr is right associative, so you end up with: a : (b : (c : (d : e)))
19:15:42 <jollyrancher> :D
19:15:43 <jmcarthur> i never remember years of events
19:16:20 <Eduard_Munteanu> jmcarthur: I presume that was the impression Hugs left them with?
19:16:35 <jmcarthur> Eduard_Munteanu: i believe this teacher had never touched haskell in her life
19:17:05 <jmcarthur> Eduard_Munteanu: she even said herself she was not qualified for the course she was teaching, but nobody else wanted to teach it...
19:17:17 <nand`> quality education
19:17:21 <jollyrancher> haha
19:17:22 <jmcarthur> yeah :(
19:17:24 <nand`> tax dollars well spent
19:17:26 <Eduard_Munteanu> Could be. I had teachers throwing around examples of languages that were old as hell in their days :)
19:17:51 <Eduard_Munteanu> Something like "you could achieve that goal in PLs like COBOL" WTF!
19:17:56 <jmcarthur> to be clear, the course of a survey of programming languages
19:18:03 <jmcarthur> *was a
19:18:17 <nand`> to be honest, all this negative talk makes me afraid of going to universities: I don't want to waste years of my life learning about OOP and UML and probably failing in the end
19:18:22 <danbru> search :: (a -> [a]) -> (a -> Bool) -> a -> [a]
19:18:22 <danbru> search next isFound n = n : if isFound n then [] else minimumBy (comparing void) . fmap (search next isFound) . next $ n
19:18:28 <Cale> nand`: Study mathematics
19:18:31 <Cale> It worked for me :)
19:18:34 <copumpkin> nand`: I never learned any of that crap in my CS program :)
19:18:38 <nand`> Cale: I'm considering it :(
19:18:39 <copumpkin> \o/
19:18:41 <Cale> <-- only took 2 CS courses
19:18:42 <jollyrancher> how would I implement my own foldr? just for learning purposes
19:18:43 <danbru> ny search function isnt working for 'search (\x -> [x-1,x+1]) (==2) 3'
19:18:44 <jmcarthur> what cale said. i loved my math courses compared to my engineering/cs courses
19:18:49 <nand`> Cale: I want to get into compiler design, linguistics, type theory etc. though
19:18:50 <EvanR1> copumpkin: you elitists!
19:18:59 <copumpkin> EvanR1: elitist and proud of it!
19:19:01 <copumpkin> >_>
19:19:04 <copumpkin> ^_^
19:19:06 <EvanR1> using your better languages, better currencies, etc
19:19:06 <copumpkin> <_<
19:19:06 <jmcarthur> nand`: guess where type theory comes from :D
19:19:07 <Cale> nand`: type theory = mathematical logic
19:19:11 <EvanR1> its disgusting
19:19:15 <Eduard_Munteanu> jollyrancher: foldl/foldr are pretty straightforward to write
19:19:16 <copumpkin> EvanR1: damn right. Have a bitcoin
19:19:16 <nand`> jollyrancher: foldr f z [] = z; foldr f z (x:xs) = f x (foldr f z xs)
19:19:34 <jollyrancher> sweet!
19:19:36 <nand`> jollyrancher: foldr is basically “rightwards recursion” in the most obvious way
19:19:54 <nand`> you apply f to the first element + the rest of the list folded
19:20:11 <jmcarthur> nand`: you could also look into just doing a math-heavy cs program
19:20:20 <nand`> this is also why foldr can be lazy: if f doesn't consume its right argument, it never gets evaluated
19:20:28 <jmcarthur> g2g eat!
19:20:34 <nand`> jmcarthur: yeah
19:20:42 <Eduard_Munteanu> Also productive if f is.
19:21:06 <nand`> jmcarthur: I've talked with some representatives from the university I'm planning to go to and they definitely told me to go for CS, which is what I'll be doing first. I guess I can retry mathematics if I ever get blocked from studying CS if I fail it
19:21:55 <Cale> nand`: Which university?
19:22:08 <nand`> but apparently the first years of CS will be boring, until I get to the later years / masters, where I'll be able to do in-depth FP
19:22:19 <Cale> Oh, you're in Germany, so I'm unlikely to know it :P
19:22:19 <nand`> Cale: Universität Ulm, Germany
19:22:32 <Eduard_Munteanu> nand`: you could also try doing something completely different if you don't want CS to be spoiled by it :D
19:23:50 <Eduard_Munteanu> I guess it kinda sucks if you're interested in specific stuff and/or want to skip some things.
19:23:55 <nand`> Eduard_Munteanu: problem with that is that my set of interests is very shallow; and I'm not particularly keen on studying something I have no passion for
19:24:26 <Eduard_Munteanu> Yeah, I wasn't interested in my control systems courses either, though some things turned out to be somewhat fun.
19:24:51 <nand`> oh, I thought you meant “completely different” like, say, physics
19:25:34 <Eduard_Munteanu> Not sure what I meant, though math fits.
19:26:08 <nand`> I imagine studying mathematics would go straight above my head
19:26:22 <Cale> nand`: Well, it's supposed to be reasonable
19:26:26 <Eduard_Munteanu> My major was industrial automation / control stuff, although I don't plan in working in such a field.
19:26:33 <Eduard_Munteanu> *plan on
19:27:02 <Cale> nand`: No matter what you study, the courses are supposed to teach you in a reasonable way that you can learn the material.
19:27:15 <nand`> Cale: I am picking mathematics as my ‘extra subject’ I need for the CS course :)
19:27:37 <Eduard_Munteanu> And I sometimes think I would've hated studying some things in CS / PLs, and having to go through it just the way some teacher liked, dunno.
19:27:55 <Eduard_Munteanu> Maybe I would've despised Haskell after all that, who knows :)
19:30:14 <nand`> I think I may have just made a mistake by going down the Haskell path *before* first-year CS education, where under a worst case scenario I'm going to have to go back to Java; it's much harder to do the same in reverse
19:30:39 <nand`> (that is, it's much harder going from Haskell to Java than it is in the opposite direction)
19:31:07 <Cale> In a sense, I agree with that and in another sense I disagree.
19:31:39 <nand`> Cale: about half of that was tongue in cheek
19:32:21 <nand`> it certainly feels horrible going back to ‘unliberated’ languages: ones without laziness, purity and sum types
19:32:35 <Cale> What about functions? :D
19:32:49 <nand`> who cares about functions? it's all about the type system!
19:33:21 <EvanR1> gotta have functions
19:33:31 <YayMe> nand`: Dead wrong. I've been writing imperative languages for years, I'm a senior software engineer writing C#, and haskell kicks my ass. But everyone I ever met who started functional and went imperative afterwards, was great at imperative.
19:33:33 <EvanR1> php, java still struggling to have them
19:33:51 <Cale> YayMe: Yeah, it's just that once you know Haskell, tolerating using Java is hard :P
19:33:57 <nand`> YayMe: going back to C# nowadays feels like I'm constantly running against walls
19:34:03 <YayMe> Cale: No shit, C# is annoying me now haha
19:34:20 <nand`> YayMe: that's more or less what I meant - it's hard in a moral / fun sense
19:34:26 <nand`> not in a “you become a worse programmer” sense
19:34:26 <EvanR1> now i see places whre functions would make so much sense, CSS for example
19:34:36 <YayMe> nand`: BUT- you will be better at it than others with more ease. You will more quickly rise in your career
19:34:47 <nand`> YayMe: I'd rather die than live writing C#
19:34:55 <nand`> (for a living)
19:35:14 <Nereid> every language should have ADTs
19:35:26 <Nereid> well, every language with product types
19:35:30 <Nereid> should have sum types
19:35:35 <ski> yes
19:35:36 <YayMe> nand`: Hah, well it's great money and easy to find work. A lot harder to find work writing functional. Cheers.
19:35:47 <nand`> the main thing I find lacking about most imperative language's type systems are sum types and higher-kind polymorphism
19:35:51 <YayMe> Good luck to you if you can find work in functional though
19:36:02 <EvanR1> languages with types*
19:36:04 <EvanR1> at all
19:36:26 <nand`> it seems trivially obvious to me to allow, say, C#: interface IFunctor<F> { F<B> Map<A,B>(F<A> f) }
19:36:49 <ski> (nand` : itym s/higher-kind polymorphism/higher-kind types/)
19:37:00 <nand`> YayMe: seems like the best way is to enter academia and become a TA / prof / whatever
19:37:13 <ski> nand` : iirc, you can do templates in C++ which take templates as arguments
19:37:47 <EvanR1> yeah c++ is a shitty language with various outboard motor paradigms on it facing various directions ;)
19:38:24 <nand`> ski: you're right, higher-kind types is what I want - polymorphy sits on top of them
19:38:26 <ski> (nand` : you're also missing the function argument)
19:38:26 <startling> hi, anyone know of nice things for generating assembly and assembling it?
19:38:37 <nand`> ski: whoops, yes; Func<A,B> :)
19:39:06 <Cale> startling: harpy?
19:39:18 <Cale> LLVM?
19:39:21 <YayMe> EvanR1: Yeah, single reason I haven't bothered to learn C++ even though in performance terms it's awesome
19:39:26 <nand`> startling: ‘vim’ and ‘yasm’, work
19:39:45 <EvanR1> really performance is a library issue for all these mainstream systems
19:40:02 <EvanR1> rails etc
19:40:04 <ski> nand` : hehe, i try to complain when people talk about e.g. `Maybe' as a "polymorphic type" (it's *not* polymorphic ! having `O :: forall k0 k1. (k1 -> *) -> (k0 -> k1) -> (k0 -> *)' defined by `newtype O g f a = MkO (g (f a))' would be a polymorphic type)
19:40:14 <Cale> People in Java land build these ridiculous layers upon layers of junk.
19:40:19 <Nereid> ski: I want to be able to define O
19:40:20 <Nereid> :(
19:40:37 <Nereid> and why not k2 instead of *
19:40:51 <YayMe> EvanR1: Yeah, but I'm used to C# which is as high performance as you can get in current high level languages I can think of.. outside of functional ones of course
19:41:00 <YayMe> other than C++
19:41:09 <ski> Nereid : because `MkO :: g (f a) -> O g f a', and the two arguments of `->' here has type `*'
19:41:16 <Cale> Where it seems like someone thought to themselves "This library's API is shit, but I'm so opposed to NIH-syndrome that we're using it anyway, and wrapping it in a thin layer."
19:41:17 <Nereid> oh right.
19:41:24 <YayMe> F# can probably beat out C#, as well as haskell can, but unfortunately those aren't options
19:41:38 <nand`> ski: I mentally expanded to “polymorphy of higher-kind-types”; eg. (forall f. f ())
19:41:54 <ski> Nereid : `newtype k (O g f a) = MkO (k (g (f a)))' would get you `O :: forall k0 k1 k2. (k1 -> k2) -> (k0 -> k1) -> (k0 -> k2)'
19:42:10 <nand`> YayMe: there are a few projects floating about in various states of decay about compiling Haskell for the CLR
19:42:16 <nand`> (or JVM)
19:42:36 <Nereid> ski: I'm not sure how that works.
19:42:37 <ski> Nereid : with `MkO :: forall_kind k0 k1 k2. (k :: k2 -> *) (g :: k1 -> k2) (f :: k0 -> k1) (a :: k0). k (g (f a)) -> k (O g f a)'
19:42:54 <Nereid> the left side of the =, I mean
19:43:15 <startling> Cale: ooh, harpy looks nice
19:43:44 <lgandras> hi, anyone who has had the need of using nested transactions with HDBC? http://hackage.haskell.org/packages/archive/HDBC/latest/doc/html/Database-HDBC.html#v:withTransaction such a nice concept, but don't know how to extend it to support subtransactions
19:43:57 <ski> Nereid : the idea is that since `newtype's are represented in the same way as the representation type, we should be able to not only have O(0) conversions between a `newtype' `Abstract' and it's `Representation' type, but also O(0)' conversions between `k Abstract' and `k Representation', for any "context" `k'
19:44:21 <shirt> > 1 Prelude.: [2]
19:44:22 <lambdabot>   Not in scope: data constructor `Prelude.:'
19:44:23 <shirt> why doesn't that work?
19:44:37 <ski> @type (Prelude.:)
19:44:38 <lambdabot> Not in scope: data constructor `Prelude.:'
19:44:39 <YayMe> nand`: Yeah, but the point is most companies won't allow anything to be written in a language or way that 95% of people can't get around
19:44:41 <shirt> > 1 Prelude.+ 2
19:44:43 <lambdabot>   3
19:44:45 <Nereid> ski: ok.
19:44:47 <ski> shirt : i think `:' is a bit magic
19:45:11 <shirt> @type (:)
19:45:12 <lambdabot> forall a. a -> [a] -> [a]
19:45:30 <ski> Nereid : however, to make this sound, we need to make sure `k' (only) appears on the "outside" of the representation type (possibly indirected through more `newtype's)
19:45:59 <nand`> prolly cheaper in the long run to outsource to 5 minimum wage workers constantly repairing your big-bloated-bad-imperative software than pay one or two good haskell programmers to write a beautifully statically-checked type safe version
19:46:21 <EvanR1> nand`: tall order
19:46:36 <EvanR1> if you can actually pull that off, there will be people lining up with money demanding it
19:46:49 <nand`> unless you're writing missile control software
19:46:54 <EvanR1> to me its not clear yet if its actually possible for general business software
19:47:07 <nand`> EvanR1: I'm not sure what “general business software” means
19:47:19 <EvanR1> whatever these assholes want to develop
19:47:27 <Cale> nand`: As far as I can tell, you eventually end up firing the bad programmers and hiring good ones to deal with your mess at a fraction of their potential output anyway
19:47:30 <MostAwesomeDude> Clearly, he's writing software that will make business for him.
19:47:31 <EvanR1> web 2.0 spreadsheet groupware
19:47:32 <nand`> I think every piece of software has a unique purpose, ‘general’ doesn't really fit into a description very well
19:47:39 <zachk> haskell seems amazing for generating/and/or parsing/converting static content
19:47:46 <MostAwesomeDude> It's highly important that this software produce quality business.
19:47:55 <nand`> Cale: then you get to ‘wow, I pay him 3x as much and all he's done is reprogrammed everything we already have?’
19:47:58 <zachk> "build it and they will come"
19:49:08 <nand`> “encryption slows throughput and consumers notice no difference, remove it”
19:49:12 <Cale> nand`: Well, I mean that you have to, because the bad programmers paint themselves into a corner, and write a horrifying pile of bugs, and you need some really smart people to work really hard just to fix some of the bugs or add basic features.
19:49:32 <Cale> If you're lucky, they'll have time to rewrite it
19:49:56 <Cale> But if you have to keep the software in production and keep making advances, they might not
19:50:09 <YayMe> Cale: Often times bad programmers are kept around fixing their bugs and appreciated for all the work they do in that case, and then you end up with code so unmaintainable, every little change takes 10x the time needed
19:50:28 <Nereid> don't hire bad programmers in the first place. :v
19:50:40 <zachk> how can a hiring manager tell?
19:50:47 <YayMe> Cale: Then everyone thinks the devs are great because the work they do sounds so complex since it is complex to add functionality to a complete train wreck
19:50:54 <nand`> how does somebody wi-- yeah, what zachk said
19:50:59 <Nereid> I know there are lots of problems with this.
19:51:09 <YayMe> zachk: ex engineers as managers, that's the only method I've found in companies seems to work.
19:51:31 <EvanR1> im encouraged to hear this channel discussing real world business environment
19:51:35 <zachk> personally, I am better at debugging, refactoring, and merging things then making them from scratch
19:51:39 <jmcarthur> i wish i knew whether i was actually any good at evaluating functional programmers in an interview setting
19:51:41 <nand`> perhaps related
19:51:43 <nand`> http://www.haskell.org/haskellwiki/Haskell_in_industry
19:51:54 <shachaf> jmcarthur: s/functional //, for that matter.
19:51:55 <jmcarthur> i *think* i'm good at it
19:51:57 <nand`> jmcarthur: ask them to write a monad tutorial
19:51:57 <mzero> jmcarthur: ask them to write code in the interview - it is the only way
19:52:05 <mikeplus64> with repa (or vector, or Data.Array), what's the 'standard' way of setting all elements within a certain range (or Ix or Shape) to a value?
19:52:16 <EvanR1> if they respond to 'write a monad tutorial' with 'its just a burrito' they have the job ;)
19:52:33 <jmcarthur> shachaf: yeah the qualification was unnecessary
19:52:36 <nand`> http://ro-che.info/ccc/11.html
19:52:38 <EvanR1> haskell international subversive secret society
19:52:41 <Cale> I've recently been hired for a few months at $40/hr to work on a completely retarded Groovy codebase. It's been good for some laughs, but it takes *at least* 10x longer to get anything done than it ought to.
19:52:41 <zachk> mikeplus64: I'd have to use :hoogle and google
19:52:42 <mzero> or "a train full of jello.... traveling backward in time...."
19:52:43 <YayMe> zachk: Comes with time, the more refactoring you do over time, the more you'll be able to have a problem and automatically come up with some simple designs for it.
19:52:59 <jmcarthur> mzero: i invariably do, but there's also factors like how comfortable they are with the environment i provide them and such
19:53:01 <zachk> EvanR1: dont you remember the first rule of the cabal? Don't talk about the cabal
19:53:09 * zachk get s rubber band and a bowie knife 
19:53:10 <nand`> jmcarthur: ask them to implement the factorial function
19:53:27 <shachaf> mzero: It's possible that "write code" is a necessary requirement for a good programmer interview, but it's certainly not sufficient.
19:53:32 <zachk> in over ten different ways ;)
19:54:07 <jmcarthur> nand`: i try to ask very hard questions in order to determine what it's like to actually interact with the candidate instead of just whether they can write simple code
19:54:16 <nand`> zachk: personally, I'm good at creating proof of concepts for various algorithms then getting bored of writing the actual wrapper program
19:54:17 <YayMe> zachk: More times you refactor bad code the more easily you'll be able to automatically eliminate some of those ways having seen the bad results from other people trying them
19:54:42 <zachk> most of those skills don't transfer over fully yet to haskell
19:54:48 <zachk> :-/
19:54:55 <startling> Cale, wait, people actually use Groovy??
19:55:00 <nand`> zachk: if they implement it using generalized comonadic hylormophisms, reject them immediately
19:55:01 <Cale> startling: lol
19:55:06 <zachk> I see alot of what can go wrong, or what will not work , or what will be a major headache down the line
19:55:06 <nand`> not worth the headaches
19:55:22 <nand`> s/hylor/hylo/
19:55:27 <YayMe> zachk: Good design from the ground up comes from time and practice, and good adherence to SOLID (when not functional)
19:55:27 <Cale> startling: People who started their projects in the 2 months or so before people realised that Groovy was a pile of garbage.
19:55:27 <zachk> nand`: is that haskspeak for imperative style?
19:55:32 <startling> Cale: I always thought it was a bad joke
19:55:34 <zachk> SOLID?
19:55:40 <nand`> zachk: no, it's a reference to http://www.willamette.edu/~fruehr/haskell/evolution.html#continuation
19:55:40 <EvanR1> wth is solid
19:55:42 <nand`> zachk: see the last example
19:55:54 <nand`> ah, here's a direct link http://www.willamette.edu/~fruehr/haskell/evolution.html#comonadic
19:55:55 <YayMe> http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)
19:56:07 <EvanR1> :S
19:56:07 <jmcarthur> nand`: i wouldn't reject somebody immediately for that, although i would ask them if they could reformulate it in a way that other programmers without their background might understand
19:56:30 <nand`> jmcarthur: an interesting challenge
19:56:47 <nand`> jmcarthur: this requires constructing some ‘understandability’ algebra
19:56:57 * jmcarthur sighs
19:57:10 <jmcarthur> believe it or not, i actually think in terms like this when i code
19:57:20 <YayMe> jmcarthur: The math terms?
19:57:23 <nand`> oh, I believe it
19:57:27 <jmcarthur> i just try to keep my presentation sensible
19:57:34 <Cale> If you'd like to see some hilarious Java code: https://svn.codehaus.org/grails-plugins/grails-searchable/trunk/src/java/org/codehaus/groovy/grails/plugins/searchable/compass/config/mapping/
19:57:46 <nand`> jmcarthur: I actually tend to keep my code in a lucid, near-english style
19:58:01 <nand`> not for others but for myself
19:58:01 <YayMe> jmcarthur: I have yet to work with any developers at all who do. I want to, but I have no degree or formal math training
19:58:17 <YayMe> We'll see if I can just figure it out myself..
19:58:58 <popl> nand`: any particular dialect? ;P
19:59:14 <nand`> popl: yes, strict British Queen's English
19:59:16 <jmcarthur> YayMe: yeah, kind of mathy stuff, mostly bits of category theory i've picked up here and there
19:59:17 <nand`> (not really)
19:59:22 <jmcarthur> and algebraic structures
19:59:35 <povman> lol, AbstractSimpleSearchableGrailsDomainClassMappingConfigurator is 90% boilerplate
19:59:44 <YayMe> zachk: If you write imperative code and want to be better at it plus being able to easily eliminate more of those 10 possible ways that immediately come to mind for solving things, learn design principles and get used to recognizing them
20:00:17 <jmcarthur> when i'm writing imperative code i find myself making a functional algorithm in my head and then compiling it manually
20:00:26 <YayMe> zachk: Not to be confused with design patterns
20:00:34 <jmcarthur> (for some primitive, human version of "compiling")
20:00:50 <nand`> jmcarthur: well, I will try to re-use existing concepts where available (eg free monads) that may require domain-specific knowledge to understand; but this should be hidden from any outwards-facing APIs (unless of course you're writing a free-monads package)
20:01:06 <popl> povman: I bet you can't say that classname three times in rapid succession.
20:01:09 <jmcarthur> i don't think it *should* be hidden
20:01:23 <jmcarthur> i think understanding properties like that about the libraries you use help to understand them
20:01:33 <jmcarthur> that was kind of a tautology. woops
20:01:44 <YayMe> jmcarthur: I'm starting to get there, but modularity and maintenance qualities I want to ensure has me still breaking it up a bit more than I would if thinking of it more strictly in a computational sense
20:01:47 <zachk> YayMe: is there an analogous term in the world of FP ?
20:01:49 <jmcarthur> i think understanding properties like that about the libraries you use help you reason about the code you write using the library
20:01:56 <povman> popl: just make an acronym, assgradocmacon
20:02:34 <YayMe> zachk: I don't know enough about FP, I think some principles probably translate naturally and I'm sure FP probably has principles of it's own
20:02:37 <nand`> jmcarthur: I just think it's just important to be sufficiently non-scary, especially when you're trying to write something that's supposed to make Haskell accessible; if you don't hide it outright then perhaps provide ‘ease-of-access’ interfaces to the same concepts
20:02:45 <jmcarthur> YayMe: if anything, it encourages me to maintain modularity
20:03:15 <jmcarthur> nand`: oh i agree. i tend to have a special part of the documentation set aside for the mathy bits, for those interested.
20:03:22 <jmcarthur> but it's not required reading
20:03:26 <nand`> yes
20:03:38 <YayMe> jmcarthur: Yeah it definitely makes my code smaller, one of the biggest things I've taken from the FP side is the value of immutability
20:03:40 <nand`> jmcarthur: it's even better if you document it well, for those readers that are interested but have no knowledge of the concepts
20:03:44 <jmcarthur> one of my coworkers does this far better than i do. i find his documentation to be among the best i've ever read
20:03:58 <povman> Cale: I cannot make myself read java code after looking at haskell for the last 2 days. It actually looks like someone's debug output.
20:04:12 <Cale> povman: That stuff is particularly bad, even for Java
20:04:14 <jmcarthur> although i admit that my other coworkers kind of snicker at his mathy tone, sometimes
20:04:22 <Cale> The identifiers are all 80 characters long and stuff :P
20:04:25 <nand`> povman: -ddump-java
20:04:28 <jmcarthur> but they do understand it as long as they are willing to look up some vocabulary
20:04:35 <Cale> and nearly impossible to visually distinguish
20:04:37 <jmcarthur> the mathy parts, i mean
20:04:44 <jmcarthur> he still separates them from the main documentation
20:04:52 <povman> the signal/noise ratio is very low
20:04:56 <Cale> It would actually be *more* readable to replace all the identifiers with one-letter names
20:05:25 <nand`> I've gotten into the habit of putting { and } on the same lines
20:05:31 <jmcarthur> Cale: it does indeed make sense to give meaningless variables meaningless names ;)
20:06:01 <nand`> I also use ternaries for all my branching, like this: /*if*/ p /*then*/? foo /*else*/: bar
20:06:12 <jmcarthur> o_O
20:06:23 <Cale> nevermind the fact that all of that code is a stupid layer around an existing library which, while shitty, the layer does nothing to make it less shitty
20:06:47 <popl> the length of the identifiers reminds me of working with GTK
20:07:26 <povman> I bet it keeps a family fed though.
20:07:30 <jmcarthur> my first thought when seeing such code is "oh, this guy uses an editor that has autocompletion"
20:08:01 <nand`> Cale: and then you get bit by side effects you didn't even know about, like querying the user's locale settings to decide how to parse a Double; thus causing your application to randomly fail on other user's PCs
20:08:13 <popl> It's more than I can say for any of my code, povman. :)
20:08:27 <Cale> jmcarthur: In all seriousness, I think variable name lengths should be proportional to size of scope, but inversely proportional to frequency of occurrence (so things which are used all the time can have short names even if they're global)
20:08:46 <nand`> ‘s’, ‘k’, ‘y’?
20:08:59 <povman> nand`: frequency of occurence rule
20:09:01 <jmcarthur> Cale: i agree, except s/lengths/specificity/
20:09:41 <jmcarthur> let me restate more accurately to how i mean
20:09:53 <nand`> povman: yes, that's why I brought them up. I was trying to be funny by mentioning those in what seems to be a Java context, the last place on earth you'd expect to find them
20:10:33 <jmcarthur> i think variable name *specificity* should be proportional to the size of scope, but variable name *length* should be inversely proportional to frequency of occurrence. these principles can be at odds with each other, though, so there is a tradeoff
20:10:56 <nand`> jmcarthur: that's actually surprisingly true; back when I use C# and loved HugeCamelCaseNameGenerators, I couldn't imagine how I'd ever be able to write code without autocompletion. I've never wished for auto-completion writing Haskell
20:11:10 <nand`> I even set it up for vim a while ago but ended up never using it (so I removed it again)
20:11:35 <JoeyA> Hmm, what's the longest identifier in base?
20:11:40 <Cale> I also think debuggers are evil
20:11:52 <popl> Cale: Why?
20:11:54 <jmcarthur> Cale: i think repls are nice, though
20:11:57 <Cale> They help people write code which can't be read
20:12:02 <ski> Cale : even declarative debuggers like Buddha ?
20:12:03 <YayMe> nand`: Yeah, in C# i use very explicit names, but in haskell it just doesn't feel right at all
20:12:04 <JoeyA> Anything longer than rtsSupportsBoundThreads or BlockedIndefinitelyOnSTM?
20:12:04 <nand`> ‘putStrLn’ feels like the longest, ‘sequence’ is long too
20:12:06 <nand`> probably longer ones around
20:12:13 <nand`> oh, base; not Prelude
20:12:17 <Eduard_Munteanu> They help people figure out what they mean :P
20:12:18 <Cale> ski: I don't have enough experience with those, but possibly
20:12:26 <ski> @where Buddha
20:12:26 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
20:12:33 <jmcarthur> nand`: unsafeInterleaveIO is one of my least favorites, but is fortunately not common
20:12:46 <JoeyA> unsafeDupableInterleaveIO
20:12:47 <jmcarthur> oh, i hate some of the extensions, too
20:12:49 <Cale> Yeah, I know about them, but I haven't seen much code written by people who were actively using one
20:12:51 <nand`> YayMe: I've actually switched to using one-letter variables in most of my C# code since; with approximately the same naming scheme I'd use in Haskell. I haven't missed hugenames
20:12:53 <zachk> I enjoy semi-long names personally
20:12:58 <jmcarthur> GeneralizedNewtypeDeriving is one i type a lot
20:13:02 <zachk> so when I come back months latter and I go hey what does this do again at a glance
20:13:04 <JoeyA> On a similar note, is there any function in the standard C library whose name is longer than 9 chars?
20:13:12 <jmcarthur> NoMonomorphismRestriction is annoying to type
20:13:18 <zachk> JoeyA: doubtful
20:13:19 <nand`> jmcarthur: GND is quite annoying
20:13:21 <popl> I like debuggers.
20:13:24 <JoeyA> jmcarthur: Yeah.  Defining custom exception types is quite boilerplatey.
20:13:30 <nand`> I've never need NoMonomorphismRestriction
20:13:32 <Cale> Debuggers let people work on code when they don't understand it, and let them get away with making it even harder to understand.
20:13:32 <YayMe> nand`: I think I would miss the names in C# unless I started writing my C# like haskell, which would scare the shit out of my coworkers so wouldn't pass peer review
20:13:32 <nand`> needed*
20:13:37 <JoeyA> I'd be nice if you could just say deriving Exception.
20:13:41 <jmcarthur> nand`: i mostly use it in ghci
20:13:47 <nand`> jmcarthur: I have it on by default in my .ghci
20:13:50 <jmcarthur> i should just add it to my .ghci
20:13:52 <jmcarthur> yes, that
20:13:53 <popl> Cale: Debuggers are good learning tools.
20:13:53 <zachk> Cale: but what if its someone elses code, and you need to get it working quickly
20:13:55 <nand`> jmcarthur: I meant to say ‘I've never needed to type it’
20:13:55 <JoeyA> And have it automatically infer that it should derive Typeable, too.
20:13:59 <popl> s/are/can be/
20:14:02 <nand`> other than once, that is
20:14:02 <ski> popl : depends
20:14:49 <povman> Cale: are you referring to all debuggers or just haskell? C++ without a debugger would be a nightmare.
20:15:31 <ski> zachk : yeah, i sometimes write out full names like `interleaver',`predicate',&c.
20:15:37 <jmcarthur> i don't think C++ without a debugger is inherently a nightmare
20:15:42 <Cale> povman: I think that a lot of the badness of C++ code comes from the culture of debuggers.
20:15:44 <jmcarthur> it depends on how shitty the code you're working with is
20:15:45 <popl> Neither do I, jmcarthur.
20:16:10 <Cale> Programming with a debugger relieves you of the duty of writing code which can be understood without one.
20:16:21 <ski> jmcarthur : i think Cale's argument is that the shitty code is caused by the debugger
20:16:23 <nand`> my C# code post-Haskell has involved significantly less uses of the debugger than my C# code pre-Haskell
20:16:50 <jmcarthur> ski: i'm inclined to agree that debuggers tend to encourage bad habits, but i don't believe that means debuggers are inherently bad
20:17:02 <ski> jmcarthur : i'm not sure of that, either
20:17:17 <Cale> zachk: Don't get me wrong, they're great for getting things done *now*, but you're trading present haste for future difficulty, often.
20:17:24 <jmcarthur> for example, i use gdb a lot to determine the cause of some random crap probably introduced by the compiler (normally not haskell, though)
20:17:30 <zachk> Cale: I agree
20:18:03 <Cale> It lets people who don't properly understand a piece of code dig in there and add things to it in a way which might not actually make sense.
20:18:15 <povman> Cale: for large systems with little visible output they are invaluable.
20:18:45 <povman> e.g. for discovering a defect which has been dormant for 1 year
20:18:50 <jmcarthur> admittedly, the gist of the argument is a little weird. [if it's too convenient to test random hacks, random hacks will infect your code]
20:19:30 <jmcarthur> like... that may be true, but is that really an argument against convenience?
20:19:39 <mzero> I find all these generalizations about debuggers very strange
20:19:55 <jmcarthur> a lot of tools make it easy to shoot yourself in the foot if you allow yourself to get careless
20:19:58 <mzero> it's a tool, not a programming style
20:20:27 <nand`> (in imperative languages) I mainly end up using debuggers when my code throws some exception that shouldn't have been thrown
20:20:28 <povman> mzero: +1. And an incredibly useful tool when the time comes.
20:21:09 <Cale> I never said they weren't useful, of course :)
20:21:10 <mzero> depends on the circumstance ... I don't think I've ever once used the Haskell debugger .... I've used gdb extensively
20:21:10 <jmcarthur> my problem with debuggers is that most of them just suck
20:21:21 <mzero> totally depends on what I'm doing, and the execution environment
20:22:03 <mzero> debuggers are like the weather... everyone talks about it, but never does anything!
20:22:47 <povman> Cale: I feel the rnf of your argument is that humans are bad at getting things right the first time
20:24:38 <parcs`> JoeyA: apparently the longest identifier in base is 'openBinaryTempFileWithDefaultPermissions'
20:24:45 <Cale> povman: maybe. I just think that a lot of the messes which get made couldn't possibly be as large as they sometimes get without the aid of a debugger, while well-written software could still be written without one.
20:25:01 <parcs`> @hoogle openBinaryTempFileWithDefaultPermissions
20:25:02 <lambdabot> System.IO openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
20:25:36 <mewalz> grr...something must already exist already, anyone know what it is called: f : Int -> [a] -> [[a]], s.t. f n list returns all linear combinations of the list that are of length six
20:26:02 <JoeyA> pneumonoultramicroscopicsilicovolcanoconiosis has 5 more letters.
20:26:26 <povman> mewalz: six specifically?
20:26:55 <mewalz> oh no, sorry; e.g. f 2 [1,2,3] would be [[1,2],[2,3],[1,3]]
20:27:05 <JoeyA> > replicateM 3 "01"
20:27:06 <lambdabot>   ["000","001","010","011","100","101","110","111"]
20:27:17 <JoeyA> Oh, that kind of combinations.
20:29:42 <optimight> Is there any specific Keyboard / Keyboard layout most suitable for haskell programming?
20:29:42 <JoeyA> parcs`: Good find.  Going through the index, I found oFFSET_StgAtomicallyFrame_next_invariant_to_check
20:29:54 <JoeyA> It's longer, but I'm not sure it counts.
20:30:03 <hpaste> mewalz pasted “combinations?” at http://hpaste.org/71922
20:30:37 <nand`> optimight: that might be an interesting problem to solve; take a large input domain of Haskell code and generate an algorithm Map Char Integer -> KeyboardLayout
20:31:16 <zachk> why not -> [KeyboardLayout]
20:31:33 <nand`> zachk: all layouts, sorted by optimality? :)
20:32:45 <optimight> I find trouble typing certain tutorials which have examples based mainly on Maths
20:32:48 <nand`> well, I picked -> KeyboardLayout because that's more or less what we're interested in; plus it might be much easier to implement (suppose you have an algorithm that only constructs one unique best solution)
20:33:10 <nand`> optimight: is this about unicode characters like ⊆⊇∩∈∀∃ ?
20:33:22 <optimight> nand: yes
20:33:35 <optimight> nand`: yes
20:33:49 <nand`> optimight: I think the easiest way to input something like that would be eg. via emacs' TeXmode input
20:33:59 <nand`> so you can just write \in for ∈
20:34:27 <nand`> but if you want a global solution, a suitable input engine could do something like that. I just don't know if any exist for that purpose
20:34:51 <orzo> is there an off-the-shelf data type that is like a list, but has O(1) last function?
20:34:52 <nand`> (alternatively, you can map special characters to your keyboard directly, this is what I do personally: You can find my layout at https://raw.github.com/nandykins/gentoo-conf/master/.Xmodmap )
20:34:53 <startling> nand`, how does this emacs thing work?
20:34:58 <optimight> nand`: ok
20:35:07 <nand`> startling: I don't know. I don't use emacs, I just heard of it
20:35:28 <startling> nand`: oh, nvm
20:35:40 <nand`> orzo: Seq from Data.Sequence can do it
20:35:44 <mewalz> I tried using list syntax to get the combinations but without luck, in the code pasted above. The list is about 200,000 elements short.
20:35:46 <startling> it looks like tex-mode is for editing tex source
20:35:52 <nand`> orzo: I don't know if there are better solutions
20:36:34 <nand`> orzo: note that for O(1) observing on both ends it very likely has to be restricted to finite lists
20:36:41 <Eduard_Munteanu> optimight: you can do that in Vim too
20:36:46 <Cale> > let newDeck = [0..51] in length [[a,b,c,d,e] | (a:bs) <- tails newDeck, (b:cs) <- tails bs, (c:ds) <- tails cs, (d:es) <- tails ds, e <- es] -- list comprehensiony way
20:36:48 <orzo> finite is fine
20:36:48 <lambdabot>   2598960
20:36:58 <elliott__> optimight: You don't need any Unicode to use Haskell.
20:36:59 <optimight> Eduard_Munteanu: I am currently using emacs
20:37:09 <elliott__> GHC has a compiler extension for using Unicode symbols in place of the usual ASCII, but it's non-standard.
20:37:25 <elliott__> So you can use whatever keyboard you want; most people don't use the fancy Unicode.
20:37:37 <mewalz> Cale: thanks much clearer
20:37:39 <Eduard_Munteanu> optimight: http://wiki.portal.chalmers.se/agda/agda.php?n=Main.VIMEditing
20:37:56 <Eduard_Munteanu> See "Typing Unicode Characters"
20:38:00 <elliott__> If you want to, then yes, emacs and vim and so on have functionality for doing so. But I wouldn't bother doing so unless you really like Unicode for some reason.
20:38:01 <nand`> optimight: oh yeah, I forgot this is about Haskell - you shouldn't need unicode input for Haskell programming
20:38:08 <Eduard_Munteanu> Not the XCompose way.
20:38:20 <Cale> mewalz: of course, you should write that function which you mentioned
20:38:29 <nand`> Cale: yuck, all that repetition
20:38:52 <Eduard_Munteanu> Oops, I missed that.
20:39:05 <Cale> nand`: yeah, I just wrote it like that to show the idea of using tails. Better to write a general function.
20:39:05 <optimight> I wonder how to go through the examples described with math symbols?
20:39:12 * ski . o O ( `∈' <http://ars.userfriendly.org/cartoons/?id=19990207> )
20:39:17 <nand`> optimight: use different symbols instead
20:39:31 <nand`> optimight: α-equivalence means it shouldn't matter
20:39:35 <optimight> okay...  I should make my own?
20:39:42 <nand`> you can use words too
20:39:43 <Eduard_Munteanu> optimight: Agda's agda-mode covers a lot of symbols
20:40:21 <Cale> mewalz: btw, the problem with your code was that e.g. b' is only the right list to be selecting from when a = 0
20:40:24 <orzo> to get the last of a Seq, i need to compose index and last ?  There's no more direct interface?
20:40:28 <nand`> crikey, 5:40 AM already? /me sleeps
20:40:49 <Eduard_Munteanu> orzo: viewr?
20:40:52 <nand`> orzo: to observe the ends of a Seq you want viewR I think
20:41:20 <ski> nand` : how much of that differs from `xmodmap -pke' ?
20:41:38 <Eduard_Munteanu> viewl/viewr go nicely with ViewPatterns sometimes.
20:41:51 <ski> (nand` : you do know you don't have to state the non-differing parts, yes ?)
20:41:59 <jmcarthur> Cale: "It is one of the advantages of pen and paper that when you start a sentence you should have it ready."  <-- dijkstra quote that seems to say a similar thing as what you say about debuggers
20:42:10 <Cale> jmcarthur: :)
20:42:12 <povman> Does anyone know, in GHC profiler (-pa) what the 'bytes' column refer to? i.e. allocations by that function or is it also allocations by thunks evaluated in that function?
20:42:28 <jmcarthur> it took me a while to find the quote. it was one of the first things i thought of when i read your argument
20:42:40 <orzo> how do i get the head of a ViewR ?
20:42:44 <orzo> heh
20:42:49 <orzo> sorry for asking so much
20:42:54 <elliott__> optimight: what examples are you seeing with mathematical symbols?
20:43:01 <orzo> im not seeing it in the docs
20:43:05 <elliott__> optimight: many haskell papers use a fancier notation that isn't actually present in source files
20:43:09 <jmcarthur> turns out it was in a video, therefore difficult to google
20:43:14 <ski> @type (Data.Sequence.:<)
20:43:16 <lambdabot> forall a. a -> Seq.Seq a -> Seq.ViewL a
20:43:17 <ski> @type (Data.Sequence.:>)
20:43:19 <lambdabot> forall a. Seq.Seq a -> a -> Seq.ViewR a
20:43:20 <elliott__> if you already know haskell it's easy to translate back, but not so much for a newbie...
20:43:23 <ski> orzo : match on those
20:43:33 <povman> jmcarthur: it'll be on google now :)
20:43:40 <ski> @type Data.Sequence.viewl
20:43:41 <ski> @type Data.Sequence.viewr
20:43:41 <lambdabot> forall a. Seq.Seq a -> Seq.ViewL a
20:43:42 <lambdabot> forall a. Seq.Seq a -> Seq.ViewR a
20:44:03 <ski>   foo (viewr -> as :> a) = ..as..a..  -- orzo
20:44:39 <orzo> oh
20:45:09 <ski>   foo (viewl -> a :< as) = ..a..as..  -- for the head and tail
20:45:17 <elliott__> orzo: (equivalently, foo xs = case viewr xs of { as :> a -> ... })
20:46:15 <optimight> elliott__: Yes... must have came across fancier notations that are not present in source files
20:47:20 <optimight> elliott__: I thought since haskell is more near to maths ..will have all math operators (symbols) as fuctions in built
20:47:59 <povman> To answer my own question, the profiling stack is stored in the thunk - so all the information is per thunk, not per function.
20:49:01 <Cale> > let pick s = [(x,xs) | (x:xs) <- tails s] in length (evalStateT (replicateM 5 (StateT pick)) [0..51])
20:49:05 <lambdabot>   mueval-core: Time limit exceeded
20:49:14 <Cale> aw, really?
20:49:56 <Cale> well, that works anyway :P
20:50:20 <Cale> > let pick s = [(x,xs) | (x:xs) <- tails s] in evalStateT (replicateM 3 (StateT pick)) [0..10]
20:50:21 <lambdabot>   [[0,1,2],[0,1,3],[0,1,4],[0,1,5],[0,1,6],[0,1,7],[0,1,8],[0,1,9],[0,1,10],[...
20:50:26 <Cale> > let pick s = [(x,xs) | (x:xs) <- tails s] in evalStateT (replicateM 3 (StateT pick)) [0..5]
20:50:28 <lambdabot>   [[0,1,2],[0,1,3],[0,1,4],[0,1,5],[0,2,3],[0,2,4],[0,2,5],[0,3,4],[0,3,5],[0...
20:51:14 <Cale> mewalz: ^^ might be of some interest :)
20:51:46 <povman> mewalz: I'd be ok with   combinations n xs = filter ((== n) . length) $ subsequences xs
20:51:57 <Cale> nand`: what do you think of that one? :)
20:53:00 <povman> > let combinations n xs = filter ((== n) . length) $ subsequences xs in length $ combinations [0..51]
20:53:01 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:53:01 <lambdabot>         against inferred type ...
20:53:17 <povman> > let combinations n xs = filter ((== n) . length) $ subsequences xs in length $ combinations 3 [0..51]
20:53:20 <lambdabot>   mueval-core: Time limit exceeded
20:53:23 <povman> heh.
20:53:31 <povman> but i'm lazy as, so....
20:53:50 <parcs`> hey orzo do you play tf2?
20:54:25 <Cale> > let combs 0 xs = [[]]; combs n xs = [u:vs | (u:us) <- tails xs, vs <- combs (n-1) us] in combs 3 [1..5]
20:54:26 <lambdabot>   [[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3...
20:54:29 <parcs`> does anybody know whether one can pass command line arguments to hsc2hs via cabal?
20:54:52 <Cale> mewalz: ^^ there's the elementary one
20:55:04 <povman> parcs`: cabal install --hsc2hs-options="…"
20:55:36 <povman> parcs`: it works with a whole lot of programs, run cabal help install
20:55:40 <mewalz> Cale: thanks again.
20:56:05 <EvanR1> @pl \a -> f (g a) x
20:56:05 <lambdabot> flip f x . g
20:56:09 <mewalz> I will probably play around with the last few to find out which one is the fastest
20:56:21 <Cale> (but the StateT one is super cute :)
20:56:37 <parcs`> povman: is it possible to encode that option within the .cabal file?
20:57:12 <copumpkin> is there some way in conduit to make a Source m (Source m a) into a Source m a?
20:57:32 <EvanR1> i think im going to actually use that pl version
20:57:39 <copumpkin> it feels like it should be roughly monadic
20:57:43 <copumpkin> or at least support some similar operations
20:57:51 <otters> join?
20:57:58 <otters> oh, no
20:58:01 <copumpkin> well, the types are wrong
20:58:01 <otters> Source m isn't a monad
20:58:05 <otters> silly me!
20:58:17 <copumpkin> ;)
20:58:59 <povman> parcs`: er, not sure, but you could try putting hsc2hs-options: … in there. It works for ghc-options
20:59:25 * hackagebot mega-sdist 0.2.0.2 - Handles uploading to Hackage from mega repos (MichaelSnoyman)
20:59:36 <orzo> parcs`: nope
21:00:27 <parcs`> orzo: aw. wrong orzo :(
21:01:18 <parcs`> povman: nope, doesn't work. thanks anyway
21:03:13 <EvanR1> > (:[]) 9
21:03:15 <lambdabot>   [9]
21:03:26 <EvanR1> is there an easier name to type for that combinator ;)
21:03:57 <quuuux> return?
21:04:07 <EvanR1> @pl \x -> [f x]
21:04:08 <lambdabot> return . f
21:04:09 <copumpkin> robot monkey
21:04:10 <EvanR1> nice
21:04:40 <zachk> > (\x->[x]) 9
21:04:42 <lambdabot>   [9]
21:05:00 <zachk> some might consider that easier to type
21:05:11 <zachk> though its not the same thing, or is it
21:05:15 <EvanR1> it is
21:05:45 <EvanR1> but i could type (\x -> [f x]) rather than return . f
21:06:02 <ion> pure
21:06:08 <EvanR1> not sure which is easier to read
21:06:24 <mzero> (:[]) is pretty common in haskell code
21:06:37 <avpx> parcs`: TF2 is good times regardless
21:06:44 <EvanR1> mzero: yeah, hard for me to type xD
21:07:08 <copumpkin> > ala ZipList pure 5
21:07:09 <lambdabot>   No instance for (Control.Newtype.Newtype
21:07:09 <lambdabot>                     ([a] -> Contro...
21:07:16 <copumpkin> wtf
21:07:24 <EvanR1> > pure 5 :: [Int]
21:07:25 <lambdabot>   [5]
21:07:33 <otters> @src (.)
21:07:34 <lambdabot> (f . g) x = f (g x)
21:07:34 <lambdabot> NB: In lambdabot,  (.) = fmap
21:07:45 <otters> can you get fixity declarations from lambdabot?
21:08:09 <copumpkin> oh I guess that won't work
21:08:16 <EvanR1> NB?
21:08:24 <copumpkin> nota bene
21:08:25 <parcs`> avpx: indeed
21:08:26 <quuuux> though, be aware pure/return aren't 100% drop-in because the typechecker might not be able to infer that you want List specifically, as opposed to some other instance
21:08:35 <ion> @google define:NB
21:08:36 <lambdabot> http://en.wikipedia.org/wiki/Nota_bene
21:08:36 <lambdabot> Title: Nota bene - Wikipedia, the free encyclopedia
21:08:49 <otters> simple yes/no question
21:10:32 <povman> @lambdabot
21:10:32 <lambdabot> Unknown command, try @list
21:10:40 <povman> @list
21:10:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:10:50 <shirt> what's the biggest pure haskell package on hackage?
21:12:36 <td123> shirt: you mean one that doesn't use monads?
21:13:08 <avpx> Most monads are pure.
21:13:15 <ski> shirt : note that code using `IO' is pure
21:13:30 <avpx> I think shirt means code written entirely in Haskell
21:13:43 <ski> avpx : so not using `Int', then ?
21:13:58 <avpx> ski: Rather than FFI bindings, I guess?
21:14:09 <ski> ok
21:14:19 <avpx> I'm just interpreting here...
21:14:22 <shirt> yeah, i mean no FFI bindings (or crazy extensions)
21:14:25 <elliott__> Maybe it'd be better to ask shirt what they mean than to guess :)
21:14:31 <avpx> elliott__: Heresy!
21:14:42 <ski> elliott__ : it's much more fun to speculate
21:14:48 <EvanR1> is deriving on a newtype like Eq and Ord and Show a standard thing or an extension
21:14:52 <elliott__> Yes, it does seem to be a rather unconventional approach in here :/
21:14:58 <avpx> EvanR1: It's standard.
21:14:59 <ski> EvanR1 : standard
21:15:58 <avpx> EvanR1: See: http://www.haskell.org/onlinereport/decls.html <-- ctrl-f "deriving"
21:20:45 <ski> <http://www.haskell.org/onlinereport/decls.html#derived-decls>
21:20:46 <EvanR1> getting used to this library ixset, its relatively awesome
21:20:51 <EvanR1> good vibrations
21:21:25 <hpaste> povman pasted “ByteString optimisation!” at http://hpaste.org/71923
21:21:47 <povman> Is this a believable optimisation?
21:21:56 <avpx> EvanR1: Interesting.
21:22:11 <povman> yesterday somebody was arguing that ghc should do that automatically. I'm compiling with -O2.
21:22:48 <zachk> test with :set +s in ghci ;)
21:22:54 <copumpkin> povman: I would expect it to
21:23:04 <copumpkin> but I guess not :)
21:23:10 <copumpkin> I'd email a mailing list
21:23:22 <copumpkin> or output core and check if there's any difference
21:23:26 <copumpkin> and run it through criterion
21:23:31 <copumpkin> to get statistically meaningful measurements
21:23:32 <povman> good point copumpkin
21:24:08 <povman> is haskell-cafe a good place to post stuff like this?
21:24:59 <povman> (i can't believe darcs allocates 2Gb of memory to record a 24M file)
21:25:03 <copumpkin> probably
21:26:10 <avpx> Seems like the kind of thing I'd expect to find there
21:27:20 <EvanR1> however acid state is causing me to template haskell safecopy instances for every data type ever
21:27:34 <EvanR1> boilerplating is strong here
21:32:25 <mewalz> is foldl tail optimized?
21:33:00 <ski> `foldl' is tail-recursive
21:33:13 <mauke> what the hell is "tail optimized"?
21:33:57 <Ralith> I expect it is shorthand for "affected by tail-call optimization"
21:33:58 <latro`a> http://en.wikipedia.org/wiki/Tail_call
21:34:01 <latro`a> yeah
21:34:02 <latro`a> that
21:34:13 <copumpkin> just mauke being pedantic :P
21:34:16 <copumpkin> in his friendly manner
21:34:33 <shachaf> It's not just pedantry, in #haskell.
21:34:43 <copumpkin> it's IRC!
21:34:46 <mauke> copumpkin: no, it sounds more like "is it web scale?"
21:34:56 * copumpkin optimizes the tail out of all of humanity
21:34:59 <mauke> you can't just assume people have any idea what they're talking about
21:35:04 <dmwit> /dev/null is web optimized
21:35:19 <copumpkin> mauke: I hear foldl is totally webscale, when run on the cloud
21:35:41 <Axman6> but you need foldl' for web scale 2.0
21:36:19 <startling> but is it good enough for the cloud?
21:36:42 <copumpkin> I think so
21:39:07 <Ralith> just wait till I publish foldl''
21:39:14 <Ralith> it is enterprise-ready
21:39:21 <mauke> prime 2.0
21:40:21 <ski> @quote Yoneda
21:40:22 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
21:40:22 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
21:41:07 <byteasphyxia> Hi, I'm making a program for auto installing software files for my boss at a computer shop. does anyone know how to set or create registry keys properly with System.Win32.Registry? also, how would i go about recursively searching through the keys? thanks
21:41:34 <startling> @remember Ralith just wait till I publish foldl'' / it is enterprise-ready
21:41:34 <lambdabot> Okay.
21:42:14 <ski> "Web Programming and Continuations" by Eli Barzilay at <http://tmp.barzilay.org/cont.txt>
21:42:35 <ski> @src foldl
21:42:36 <lambdabot> foldl f z []     = z
21:42:36 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:43:13 <ski> mauke : `foldl' is tail-recursive because the recursive call is in "tail position" wrt the body of the equation it occurs in
21:43:16 <ski> er
21:43:20 <ski> mewalz ^
21:43:35 <mewalz> thanks, so its enterprise ready?
21:43:44 <Ralith> NOT YET!
21:43:47 <Ralith> :D
21:43:51 <mewalz> will it work on IOS?
21:43:52 <ski> mewalz : no, you need Yoneda for that
21:44:38 <ski> (or maybe `CoYoneda' .. at least if you want to fuse your `fmap's)
21:46:07 <povman> are continuations related to concatenative programming?
21:46:47 <ski> not very, i think
21:50:07 <EvanR1> fmap fusion?
21:50:34 <Ralith> fmap fusion deuterium
21:50:50 <mauke> that's my middle name
21:51:31 <EvanR1> fmap has changed my life, everywhere i look in the world now i see stuff getting fmapped
21:51:51 <startling> haha
21:51:54 <mauke> have you accepted fmap into your heart?
21:52:14 <mauke> "fmap fmap heart"
21:52:23 <startling> monoids are pretty neat like that, too
21:52:23 <EvanR1> ahhhhhhhhh
21:52:37 <EvanR1> monoids are ok
21:52:58 <EvanR1> we can be polytheistic
21:53:02 <startling> it's a shame (<3) can't be an infix operator
21:53:47 <povman> i <3 `you` (!) -- is valid
21:54:07 <EvanR1> every time i hear someone exclaim how impenetrable monads are i direct them to look at Functor first, and fmap
21:54:21 <EvanR1> hasnt been very successful at converting people to haskell i have to say
21:54:26 <mauke> learning about confirmation bias has changed my life, I can see it everywhere now
21:54:35 <startling> mauke: ha
21:56:09 * quuuux defines Num (a -> b) and writes i < 3 you
21:56:29 <quuuux> it's like perl poetry, except it makes less sense
21:57:04 <EvanR1> i brought that up earlier today!
21:57:07 <EvanR1> haskell poetry
21:58:39 <copumpkin> Lemmih: you around?
21:59:50 <EvanR1> so am i doing something wrong... i just started and i already have like 12 data and newtypes all needing safe copy instances for the master type to be made acidic
22:00:21 <elliott__> EvanR1: you need to be able to serialise a data type's components to serialise that data type itself.
22:00:37 <elliott__> SafeCopy is just a versioned serialisation typeclass
22:00:57 <EvanR1> its not that bad right now, but once i start changing the schema...
22:01:04 <EvanR1> im wondering how horrible the code will get
22:02:18 <EvanR1> havent seen many examples floating around
22:03:14 <elliott__> there are a few simple ones on the acid-state site
22:03:49 <EvanR1> none show migrations
22:04:21 <elliott__> there's some info on that in the safecopy docs
22:04:53 <Dodek> hey, how can i make something like unix select() on a list of TChan-s?
22:05:41 <EvanR1> can you multiplex then all into one chan
22:06:18 <Dodek> hm i think i actually can
22:07:33 <shirt> Dodek: use orElse
22:08:49 <ion> λ> do chan0 <- newTChanIO; chan1 <- newTChanIO; forkIO (do threadDelay 1000000; atomically (writeTChan chan0 42)); forkIO (do threadDelay 500000; atomically (writeTChan chan1 43)); atomically (readTChan chan0 `orElse` readTChan chan1)
22:08:51 <ion> 43
22:08:51 <quuuux> won't that lead to starvation if one of the first TChans is consistently full?
22:09:32 <ion> You could be smart about it and rotate the list of TChans every time.
22:09:40 <ion> or something
22:11:24 <parcs`> @tell edwardk you once wrote a function for adding haskell finalizers to a foreignptr.. do you know whether Foreign.Concurrent accomplishes the same thing?
22:11:24 <lambdabot> Consider it noted.
22:11:41 <maurer> Anyone know of good example projects using Database.
22:11:42 <maurer> Persist
22:14:55 <elliott__> parcs`: it works for doing that, yes
22:20:48 <parcs`> elliott__: is it preferred over using a FunPtr?
22:21:37 <elliott__> I don't think you can actually do Haskel lfinalisers with the other UI... I think you're not allowed to call back into Haskell with the stuff it uses
22:21:42 <elliott__> not sure though, I seem to recall running into problems when trying
22:21:51 <elliott__> maybe it's allowed by the standard but breaks in GHC, or something
22:41:44 --- mode: wolfe.freenode.net set +o ChanServ
23:08:19 <Axman6> @src Integer
23:08:19 <lambdabot> data Integer = S# Int#
23:08:20 <lambdabot>              | J# Int# ByteArray#
23:09:24 <copumpkin> gah, does cereal's runGetState make a copy of the BS?
23:09:42 <Axman6> it shouldn't...
23:26:30 <solrize> @pl \x y -> abs(x-y)
23:26:30 <lambdabot> (abs .) . (-)
23:27:59 <MostAwesomeDude> @unpl abs . subtract
23:27:59 <lambdabot> (\ c -> abs (subtract c))
23:28:10 <MostAwesomeDude> :t abs . subtract
23:28:11 <lambdabot> forall a. (Num a) => a -> a -> a
23:28:35 <startling> :t abs . (-)
23:28:36 <lambdabot> forall a. (Num a) => a -> a -> a
23:29:10 <mikeplus64> Axman6: that's very neat (Integer definition)
23:31:31 <EvanR1> thinking out loud... if i store my data in an acid state, theres no hope of any system except haskell of decoding it in the future
23:32:46 <valentin_> when we did (+) <$> (+3) <*> (*100) $ 5, why 5 first got applied to (+3) and (*100), resulting in 8 and 500. Then, + gets called with 8 and 500, resulting in 508. Why 5 was not applied to (+) as well?
23:33:01 <EvanR1> what made me think of this is deciding which data type to use to represent event times... i had Integer at first, then switch to UTCTime
23:33:07 <EvanR1> the latter being haskell only
23:33:24 <solrize> EvanR, acid-state maps pretty directly to xml i thought
23:33:33 <EvanR1> eh?
23:33:57 <EvanR1> which function is that heh
23:43:59 <dmwit> > 524/70
23:44:00 <lambdabot>   7.485714285714286
23:50:32 <dmwit> > (3421-2750)/210
23:50:34 <lambdabot>   3.1952380952380954
23:50:36 <EvanR1> i just pressed control N in vim and it somehow autocomplete deriveSafeCopy correctly
