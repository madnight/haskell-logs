00:15:17 * hackagebot egison 2.1.6 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.6 (SatoshiEgi)
00:20:17 * hackagebot egison 2.1.7 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.7 (SatoshiEgi)
00:30:18 * hackagebot egison 2.1.8 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.8 (SatoshiEgi)
01:07:24 <Kuraitou> Why can't you use runST on a ST monad passed to a function?
01:08:16 <shachaf> You can't "pass a ST monad to a function".
01:08:24 <shachaf> Maybe you should clarify what you're trying to do, though. :-)
01:08:33 <Kuraitou> i.e. http://hpaste.org/70793
01:08:55 <shachaf> That's the whole purpose of the type parameter to ST.
01:09:06 <shachaf> Internally the implementation of STRefs etc. is exactly the same as IORefs.
01:09:26 <hpaste> obk pasted “Enhanced data-lens operators” at http://hpaste.org/70794
01:09:55 <shachaf> But you dont want someone to be able to "newSTRef x", and then later runST that outside of the context of the original runST.
01:10:03 <shachaf> Or am I misreading?
01:10:22 <shachaf> Maybe you just want to give foo the correct type.
01:10:28 <shachaf> @ty runST
01:10:31 <lambdabot> forall a. (forall s. ST s a) -> a
01:10:37 <shachaf> Since foo = runST, it should have that type too.
01:12:28 <fmap> it can be not obvious that (forall s. ST s a) → a ≠ ST s a → a
01:13:11 <shachaf> fmap: Well, the whole point of "s" is that it works that way.
01:16:31 <Kuraitou> I only started learning Haskell a couple weeks ago and am still trying to understand monads; maybe you could better explain to me why this doesn't work in the original context.
01:16:37 <Kuraitou> http://hpaste.org/70795
01:16:48 <Kuraitou> The error is at the bottom
01:18:21 <Kuraitou> Are you suggesting that I make my 'getPiece' function use the same type as runST?
01:19:36 <shachaf> Kuraitou: If you're "still trying to understand monads", you shouldn't be using ST.
01:20:31 <shachaf> Anyway, the point of ST is that your whole thing goes in one big runST block.
01:20:47 <shachaf> Inside the block you can use mutation freely but your result has to be just a value.
01:21:52 <shachaf> I guess pieceOrNo should be :: STBoard s -> Int -> ST s String?
01:21:55 <shachaf> Or something like that?
01:22:52 <shachaf> You seem to be using ST s ... in your other functions so I'm not sure why not there.
01:23:12 <shachaf> However, if you're "tryng to understand monads" and want some state in your program, the monad you should be using is State.
01:23:13 <Kuraitou> I'm not sure why either :P
01:24:05 <Kuraitou> The only reason I decided to go with ST is because I wanted a type with constant access time (which turned out to be either STArray or IOArray)
01:24:30 <shachaf> Kuraitou: Any type will give you constant access time because your board is of size 9.
01:25:07 <Kuraitou> how's that?
01:25:32 <shachaf> Well, OK, not constant, just O(1). :-)
01:28:42 <Ralith> Kuraitou: if your input size is bounded, then the performance charactaristics of things proportional to it are similarly bounded.
01:29:35 <ThePro> > otherwise
01:29:36 <lambdabot>   True
01:31:26 <Kuraitou> Well in any case I'll do some more reading. Thanks.
01:32:14 <ThePro> > let weightChecker weight | weight <= 70 = "you are emo!" | weight >= 80 = "you are fat!" in weightChecker 50
01:32:16 <lambdabot>   "you are emo!"
01:32:22 <ThePro> > let weightChecker weight | weight <= 70 = "you are emo!" | weight >= 80 = "you are fat!" in weightChecker 90
01:32:24 <lambdabot>   "you are fat!"
01:39:46 <ThePro> let funnyFunc p | x == 5 = "yep" | otherwise = "no :(((" where x = p + 1 in x = 4
01:39:53 <ThePro> > let funnyFunc p | x == 5 = "yep" | otherwise = "no :(((" where x = p + 1 in x = 4
01:39:54 <lambdabot>   <no location info>: parse error on input `='
01:40:09 <ThePro> > let funnyFunc p | x == 5 = "yep" | otherwise = "no :(((" where x = p + 1 in funnyFunc 4
01:40:11 <lambdabot>   "yep"
01:40:20 <ThePro> > let funnyFunc p | x == 5 = "yep" | otherwise = "no :(((" where x = p + 1 in funnyFunc 12
01:40:22 <lambdabot>   "no :((("
01:40:56 <mm|swarm> ThePro: try /query lambdabot
01:41:07 <mm|swarm> for a private chat with her :)
01:44:17 <ThePro> k
01:50:56 <Squarism> why does this channel have 900 idlers?
01:51:12 <Squarism> it makes no sense
01:51:34 <Squarism> more used langauges have a fraction of users but 10 times more dialog
01:52:06 <Kukkua> Because no one actually understands haskell
01:52:16 <Kukkua> we all just reads in a vein attempt to try to.
01:52:24 <mm|swarm> for example I have the irssi in a screen
01:52:24 <Kukkua> But we don't.
01:52:30 <Kukkua> Just like with C++.
01:52:31 <mm|swarm> and I read here from time to time
01:52:44 <mm|swarm> to answer questions and such
01:52:56 <mm|swarm> but I'm not always here
01:52:58 <flux> I gather Haskell is a language that interests even more folk, even though they might not be actively using it
01:53:03 <flux> I'm one of those people :)
01:53:08 <mm|swarm> this is the same with other users as well
01:53:25 <Kukkua> flux, do you understand continuations?
01:53:29 <flux> kukkua, yes
01:53:44 <Kukkua> They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
01:54:01 <Kukkua> I understand continuations, but I have yet to get my awesome silver surfboard as I'm not completely sure about monads.
01:54:18 <flux> well, try expressing continuations in terms of monads and you get one view of monads
01:54:31 <Kukkua> Do the reverse
01:54:34 <Kukkua> Then I will understand monads.
01:55:27 <Kukkua> At least, I can use them but every single source tells you a different thing about it. One source says 'monads don't actually exist lol, it's just how Haskell does side effectics without violating referential transparency' the other says 'monadic values are just data types describing side effects'.
01:55:49 <Kukkua> The latter seems to make some sense to me.
01:56:02 <mm|swarm> @remember Kukkua They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
01:56:02 <lambdabot> Good to know.
01:56:24 <mm|swarm> @quote Kukkua
01:56:24 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
01:56:31 <mm|swarm> cool :)
01:56:35 <mm|swarm> another thing mastered
01:57:09 <Kukkua> It's a reference to the silver surfer, where Galactus says 'You will harness boundless strength from the cosmos itself, needing no air to breathe, no food to eat, no water to drink'
01:57:26 <Kukkua> Sounds like a cool deal honestly
01:57:34 <flux> kukkua, well, I have my own explanation of monads in context of IO, and it relates closely to continuations: http://www.reddit.com/r/programming/comments/uzq44/how_can_a_time_function_exist_in_functional/c50fjkg
01:57:37 <Kukkua> Also that part of being able to transmute the elements and heal others as well as yourself.
01:57:52 <Kukkua> Cosmic bolts of awesome power being yours to hurl, sounds like a nice job, being Herald of Galactus.
01:59:18 <Kukkua> flux,  I'm not sure how that relates to coninuations
01:59:28 <Kukkua> i once explained continuations to someone using Primer as an example
01:59:34 <Kukkua> you know, the time travel film with the funky cube.
01:59:48 <Kukkua> It actually makes a lot of sense, once you open the box, you capture a continuation
01:59:56 <flux> ..
02:00:46 <frerich> Kukkua: Sounds exciting, but what I'm interested in: do you smoke everything yourself, or would you be willing to sell a bit?
02:01:22 <Kukkua> Don't need drugs man, I get high on pathological serial killing.
02:01:30 <Kukkua> Live the pure life.
02:07:45 <ski> Kukkua : s/data types describing side effects/data types describing effects/
02:08:05 <hamilyon> How do i fix multiple line  paste in ghci?
02:08:30 <ski> use `:{' and `}:' ?
02:08:47 <ski> er, s/}:/:}/, i.e.
02:08:59 <ski> (should end with a happy grin)
02:10:06 <Kukkua> ski, well yeah, I guess in that case they aren't side effects any more
02:10:07 <Kukkua> I concur.
02:10:20 * hackagebot sexp-show 0.1.0.0 - Produce a s-expression representation of Show values.  http://hackage.haskell.org/package/sexp-show-0.1.0.0 (ChrisDone)
02:10:26 <Kukkua> ski, but honestly, everyone seems to disagree abou what monadic types and values are and every side calls the other side wrong and ignorant
02:10:33 <Kukkua> Ohhh, nice function
02:10:42 <Kukkua> > sexp-show [1,2,3,4,5]
02:10:44 <lambdabot>   Not in scope: `sexp'
02:11:23 <ski> Kukkua : if you understand composable continuations, i suppose you could attempt understanding monads by understanding monadic reflection (see "Representing Monads" and "Representing Layered Monads" by Andrzej Filinski at <http://www.diku.dk/~andrzej/papers/>)
02:12:20 <Kukkua> ski, schweet.
02:12:21 <ski> (monadic reflection turns any (e.g. user-defined) monadic effect into a side-effect)
02:13:50 <ski> also check out "Fun With Linear Implici tParameters" (in The.Monad.Reader, issue 2) by TheHunter at <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters>
02:14:17 <ski> (note that that code is naughty, since it actually introduces *side*-effects into Haskell)
02:14:33 <hamilyon> does not seem to work :{
02:14:33 <hamilyon> let i = 1
02:14:33 <hamilyon> let j = 2
02:14:33 <hamilyon> :}
02:14:58 <hamilyon> <interactive>:1:9: parse error on input `let'
02:15:00 <shachaf> Indeed. That's multiple statements.
02:15:12 <shachaf> You don't need :{ :} for that.
02:15:20 <shachaf> :{:} is for multiline statements.
02:16:13 <hamilyon> Problem that is if i paste multiple statements at once input is garbaged i.e. random part of statements dissapear
02:16:32 * shachaf isn't sure what that means.
02:17:10 <ocharles> is :{ :} new for 7.4?
02:17:16 <ocharles> or have I just never noticed it?
02:17:18 <ski> hmm
02:17:21 <ski> Prelude> :{
02:17:21 <ski> Prelude| let {i = 1
02:17:21 <ski> Prelude|     ;j = 2
02:17:21 <ski> Prelude|     }
02:17:23 <ski> Prelude| :}
02:17:27 <ski> seems to work, at least
02:17:50 <ski> but i would have thought it would work with layout as well -- and i'm not sure why hamilyon's case didn't work
02:18:20 <ski> ocharles : i think it's been present for some while
02:18:31 <Schlurp> Dat flood
02:20:18 <ocharles> ski: ok, so the new feature is being able to type data Foo = ... and keep hitting enter?
02:21:51 <ski> "Such multiline commands can be used with any GHCi command, and the lines between :{ and :} are simply merged into a single line for interpretation. That implies that each such group must form a single valid command when merged, and that no layout rule is used."
02:22:47 <ski> "Apart from the :{ ... :} syntax for multi-line input mentioned above, GHCi also has a multiline mode, enabled by :set +m, in which GHCi detects automatically when the current statement is unfinished and allows further lines to be added. A multi-line input is terminated with an empty line. ... Note that layout is in effect, ..."
02:22:52 <ski> <http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-multiline>
02:23:03 <ski> hamilyon,ocharles ^
02:23:21 <ski> ocharles : not sure what you mean by "and keep hitting enter"
02:24:24 <hpaste> hamilyon pasted “paste multiline” at http://hpaste.org/70796
02:25:01 <ocharles> ski: that +m thing is new, right?
02:25:05 <ocharles> I swear something is new here!
02:25:05 <ocharles> :P
02:25:27 <ski> i've not seen it before
02:25:54 <b0fh_ua> Hi
02:26:12 <b0fh_ua> How do I resolve the problem: mtl-2.1.2 was excluded because regex-base-0.93.2 requires mtl ==2.0.1.0 ?
02:27:07 <ski> hamilyon : strange
02:27:15 <hamilyon> i use ghci 7.0.3
02:27:31 <ski> complain on mailing-list ?
02:28:07 <lillis> if I use "import Data.Maybe", then why cant I simple use the Just x / Nothing constructors in my code? What am I missing regarding import?
02:29:27 <hamilyon> ski: that's a major pain, so i will
02:29:52 <hamilyon> is there a bug tracker?
02:31:09 <fmap> lillis: you should be able to use Just and Nothing, can you paste your code?
02:33:51 <lillis> fmap: I fugged up, think I accidentally used Maybe where I should've used Just and vice versa. Rewrote and now it seems to work
02:35:33 <b0fh_ua> How do I resolve the problem: mtl-2.1.2 was excluded because regex-base-0.93.2 requires mtl ==2.0.1.0 ? Is it possible to override it somehow?
02:37:37 <fmap> b0fh_ua: that's strange since regex-base doesn't require specific mtl version according .cabal file
02:39:00 <merijn> lillis: Just/Nothing should work with just the prelude, even without Data.Maybe
02:39:08 <lillis> I have a more general question regarding the use of Maybe, and the absence of null. I have a feeling that if I start implementing a data type and an algorithm with Maybes, they will propagate through all my functions and turn it into less-clear syntax. What is the general idea regarding how to "stop a Maybe in its tracks"? Does my question even make sense?
02:39:32 <b0fh_ua> fmap: okay, and what should I do about that? )
02:39:44 <Franciman> hi all
02:39:52 <Franciman> can lexing be seen as a fold?
02:40:09 <merijn> lillis: The solution is to not stop them and use either the Maybe monad (short circuits any result to Nothing if you encounter a Nothing somewhere) and/or use things like maybe/fromMaybe
02:40:13 <merijn> :t maybe
02:40:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:40:17 <merijn> :t fromMaybe
02:40:18 <lambdabot> forall a. a -> Maybe a -> a
02:40:47 <merijn> There is also things like
02:40:56 <merijn> > fmap (+1) (Just 5)
02:40:58 <lambdabot>   Just 6
02:41:08 <merijn> > fmap (+1) Nothing
02:41:10 <lambdabot>   Nothing
02:41:12 <lillis> thats nifty
02:41:29 <raichoo> > (+) <$> (Just 1) <*> (Just 2)
02:41:31 <lambdabot>   Just 3
02:41:39 <lillis> i realise that i can get around it but i just wanted to know if there is some general view on how to work with maybes
02:41:57 <lillis> should I avoid them whenever possible? are they seen as 'unclean'?
02:42:00 <merijn> lillis: Ignoring the possibility of a Nothing would crash your code, so generally you don't want to stop tracking them. But as maybe/fromMaybe shows you can replace them with a default value and get rid of the Maybe status like that
02:42:19 <lillis> ah - yes, this default value is something i was after
02:42:26 <merijn> lillis: No, if your computation potentially fails then maybe is perfectly sensible
02:43:01 <merijn> > maybe 0 (+1) (Just 5)
02:43:03 <lambdabot>   6
02:43:08 <merijn> > maybe 0 (+1) Nothing
02:43:10 <lambdabot>   0
02:43:17 <raichoo> lillis: Use Maybe for "partial function", those are functions that are not defined for every input value.
02:43:42 <lillis> one illustration of why i thought of this was that i was creating a small function to retrieve the value from a binary tree node
02:43:52 <lillis> and i had to think about what if val' was fed an empty node
02:44:01 <lillis> and i realised i wanted to "return null" so to speak
02:44:13 <merijn> lillis: Data.Map for example uses "Map k v -> k -> Maybe v"
02:46:45 <lillis> merijn, raichoo: thanks for the help, I think I'm halfway to understanding it, gonna toy with it a bit further
02:48:14 <merijn_> blah, and that's when my wifi cuts out...
02:48:53 <lillis> merijn, raichoo: thanks for the help, I think I'm halfway to understanding it, gonna toy with it a bit further <- :)
02:48:56 <raichoo> lillis: Maybe is a lot better than null. The typesystem forces you to deal with the possibily that a function might not be able to handle the input properly.
02:49:35 <lillis> raichoo: aye, I'm realising this as I'm trying to devise algorithms with it, it really makes me think about the problem up ahead and construct proper ways of handling stuff like this
02:49:52 <raichoo> :)
02:50:23 <osfameron> bless you
02:50:40 <lillis> it really seems like a different way to program from OOP, not just syntax-wise but also how you approach solution design and composition
02:51:26 <raichoo> lillis: It is prepare for a mind changing ride. At least that's what happened to me :)
02:56:19 <ski> lillis : "stop" `Maybe' when that is appropriate (i.e. when/where you can handle it sensibly), otherwise don't
02:57:52 <ski> (but of course you can also process the `a' element in `Maybe a', if any is there, using some function, passing it to `fmap', without being able to actually handle the `Nothing' case at this point)
02:58:32 <ski> (it's basically the same as "handling" `Nothing' by returning `Nothing' again (you may think "re-raise/throw the exception"))
02:59:33 <lillis> ski: is it safe to assume then that in most *general* algorithms/data structures its better to return Nothing than a hard-coded default value?
02:59:48 <lillis> I.e. let the usage of such a generic type define how to handle Nothing
02:59:49 <ski> yes
02:59:57 <ski> in case failure is possible at all
03:00:08 <ski> hard-coded default values are generally bad
03:00:13 <lillis> is Nothing always considered a failure?
03:00:21 <ciaranm> not really
03:00:35 <lillis> i.e. if I feed EmptyNode to getnodeval - am I doing something wrong? should i not have come to that function call in the first place?
03:00:51 <barrucadu> You can think of it as a failed computation or simply a missing value
03:00:56 <ski> you can also treat `Nothing' as "no value specified (yet)", or as "no specific change/configuration passed"
03:01:26 <ski> but if `Nothing' is the return value, it's usually considered as failure, in some sense
03:02:02 <ski> (the "no change/configuation" would usually be `Nothing' as an argument)
03:02:21 <lillis> im getting it even more now - and have to go for lunch
03:02:23 <lillis> thanks a lot!
03:02:32 <ski> lillis : "should i not have come to that function call in the first place?" -- that's a good question to ask
03:02:57 <ski> however, in such cases, the function is often recursive, so that even for non-trivial cases it will tricke down to such calls anyway
03:03:32 <ski> in which case it seems overly complicated to forbid that as bad argument (it complicates the base case(s), for no apparent gain)
03:08:26 <proofit404> Hi everybody. I can't install yi text editor with Gtk2hs front end throw cabal. Have some errors:
03:08:27 <proofit404> $ cabal install --reinstall -fpango yi
03:08:27 <proofit404> Configuring gtk-0.12.3.1...
03:08:27 <proofit404> setup: The pkg-config package gtk+-2.0 is required but it could not be found.
03:08:27 <proofit404> cabal: Error: some packages failed to install:
03:08:27 <proofit404> gtk-0.12.3.1 failed during the configure step. The exception was:
03:08:27 <proofit404> ExitFailure 1
03:08:28 <proofit404> yi-0.6.5.0 depends on gtk-0.12.3.1 which failed to install.
03:08:28 <proofit404> Does anybody know possible fix for my problem?
03:08:59 <fmap> @where hpaste
03:08:59 <lambdabot> http://hpaste.org/
03:09:24 <fmap> proofit404: don't paste ten lines of text in IRC please
03:09:34 <proofit404> sorry
03:10:07 <fmap> proofit404: and you need to install real gtk before haskell bindings to it
03:11:26 <Enigmagic> any suggestions? looking for a function like [m (a -> a)] -> m (a -> a)
03:12:14 <Enigmagic> my brain is fried at this point of the evening :P
03:12:31 <frerich> 'head :-)
03:13:00 <Enigmagic> maybe i'm just missing a Control.Monad.Instances import ...
03:15:16 <proofit404> thanks, stupid me...
03:15:26 <shachaf> fmap (foldr (.) id) . sequence?
03:18:24 <shachaf> JaffaCake++ # parallel/concurrent Haskell slides
03:18:31 <JaffaCake> :)
03:18:36 <Enigmagic> shachaf: yeah that's the one, except that's not actually the function i need. thanks though :)
03:20:05 <Enigmagic> shachaf: actually it is the right one, i was using it in the wrong place :|
03:20:22 <Enigmagic> i think that means i've been coding too long today
03:20:42 <ski> @let compose = foldr (.) id
03:20:44 <lambdabot>  Defined.
03:21:18 <shachaf> @ty compose
03:21:20 <lambdabot> forall b. [b -> b] -> b -> b
03:21:48 <fmap> @type foldr1 (.)
03:21:50 <lambdabot> forall a. [a -> a] -> a -> a
03:22:05 <ski> > foldr1 (.) [] ()
03:22:07 <lambdabot>   *Exception: Prelude.foldr1: empty list
03:22:15 <shachaf> @ty flip (foldr ($))
03:22:17 <lambdabot> forall b. [b -> b] -> b -> b
03:22:24 * ski nods
03:23:05 <Keuken> @quote kukkua
03:23:06 <lambdabot> No quotes match. That's something I cannot allow to happen.
03:23:12 <Keuken> Hmm
03:23:20 <Keuken> @quote keuken
03:23:20 <lambdabot> No quotes match. My brain just exploded
03:23:23 <Keuken> Weird
03:23:42 <Keuken> @quote Kukkua
03:23:42 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
03:23:56 <Keuken> That might be a minor bug, since IRC nicknames as far as I know are not case sensitive.
03:25:22 <ski> @quote sensitive.to
03:25:22 <lambdabot> awick says: The GHC runtime seems to be sensitive to time running backwards
03:28:19 <Keuken> @quote ski
03:28:20 <lambdabot> ski says: death or glory !
03:28:39 <Keuken> Couldn't you have said soemthing like 'BLOOD AND THUNDER, VICTORY AT SEA'
03:28:40 <Keuken> ?
03:29:08 <shachaf> JaffaCake: Are the exercises and other things mentioned in the slides available?
03:36:48 <_flow_> Is there no way to let Data.HashTable.Class the ST Monad? Or is my apporoach wrong: https://gist.github.com/3038959
03:36:58 <ski> Zqrxv : hm, i might have been listening to music (<http://www.nemmelheim.de/cgs_small/index2.php>) from "Death or Glory" <http://hol.abime.net/292>,<http://www.lemonamiga.com/games/details.php?id=3532> at the time ..
03:37:12 <_flow_> oh, I mean "escape the ST Monad"
03:37:45 <JaffaCake> shachaf: exercises are here: http://community.haskell.org/~simonmar/lab-exercises-cadarache.pdf
03:38:22 <shachaf> Ah, thanks.
03:38:41 <shachaf> I didn't know you were writing a book on this -- looking forward to it. :-)
03:38:56 <JaffaCake> thanks :)
03:40:07 <ski> _flow_ : you're using `runST' wrong, yes
03:40:39 <_flow_> ski: should I work with STref instead?
03:40:59 <ski> as you have declared `ht' and `res', there are no state-sequencing-dependencies between these two computations
03:42:45 <ski> an `STRef s',`STArray s',`HashTable s' which is created in an `ST s' state-thread must be fully manipulated and consumed in that state-thread, to get fully defined sequencing between the allocations, reads, and writes
03:43:08 <ski> the `s' type parameter, plus the type of `runST', enforces this
03:43:43 <ski> your code there will be rejected with a type error (something about `s' not being polymorphic enough)
03:43:57 <ski> you need to replace your two `runST' calls with a single `runST' call
03:44:26 <ski> basically, when you have `ST s ...', and want to use `runST' on it, the `...' can't contain the type variable `s'
03:44:59 <_flow_> ski: thanks for pointing me in the right direction
03:45:28 * hackagebot CV 0.3.5.4 - OpenCV based machine vision library  http://hackage.haskell.org/package/CV-0.3.5.4 (VilleTirronen)
03:45:32 <ski> in your case you try to call `runST' on two actions of type `ST s (HashTable s Int String)' respectively `ST s (Maybe String)'
03:46:00 <ski> the first one is a nono, type error, because `s' appears in `HashTable s Int String' (the `...' in our case)
03:46:13 <ski> the second looks like it might be ok, but actually isn't
03:46:25 <ski> to see this, look at the type of `runST' :
03:46:36 <ski>   runST :: (forall s. ST s a) -> a
03:47:22 <ski> (a), because `a' is mentioned outside the scope of `s' here, `a' can't possibly be instantiated to a type mentioning `s' (which explains why `HasHTable s Int String' as value for `a' doesn't work)
03:47:43 <_flow_> but the lookup to (Maybe String) should work?
03:47:47 <ski> (b) the `forall s.' means that the *argument* must be *polymorphic* in `s', i.e. work for *any* choice of `s'
03:49:05 <ski> however, in your `ST s (Maybe String)' case, the code with this type (i.e. `get ht 2') actually depends on a free variable (`ht') with a type (`HashTable s Int String') mentioning `s'
03:49:43 <ski> this means that `get ht 2' doesn't have a type `ST s (Maybe String)' for *any* possible choice of `s' : because the `s' must be the same as the one in the type of `ht'
03:50:36 <ski> _flow_ : these are the technical reasons why you get type errors here -- if you don't understand the well now, don't worry
03:51:28 <ski> _flow_ : the main point we're after is disallowing code which doesn't explicitly sequence all creations, reads, writes of state which live in the state-thread (`ST')
03:52:00 <ski> and i happens that giving `runST' the (maybe strange-looking) type `(forall s. ST s a) -> a' accomplishes exactly this
03:52:12 <ski> er, s/i happens/it happens/ :)
03:53:11 <ski> _flow_ : conclusion : both the creation, the lookup (and any updates) must happen in the same state-thread, having a single `runST' to run it
03:53:47 <ski> _flow_ : btw, instead `get :: (HashTable s Int String) -> ...' you can say `get :: HashTable s Int String -> ...'
03:54:12 <ski> `get ht k = H.lookup ht k' could be simplified to `get = H.lookup', if you wish
03:54:37 <ski> `type HashTable s k v = C.HashTable s k v' could be simplified to `type HashTable = C.HashTable', if you wish
03:55:30 <ski> alternatively, you could add `import Data.HashTable.ST.Cuckoo ( HashTable )', to not import the type `HashTable' qualified
03:56:07 <ski> _flow_ : finally, `putStrLn (show res)' can be simplified to `print res'
03:56:10 <ski> @src print
03:56:11 <lambdabot> print x = putStrLn (show x)
03:56:22 <ski> _flow_ : any questions ?
03:57:16 <_flow_> ski: ty for your explanations. I thought that everthing regarding to the hashtable has to be done within ST
03:57:53 <ski> well, every operation which pertains to the state of the hashtable has to be done within `ST', yes
03:58:00 <ski> within a *single* `runST' call
03:58:38 <ski> however, if you're just passing around the hashtable (possibly storing it in datastructures), then you wouldn't need to use `ST' in those places of the code
03:59:11 <ski> (but any code which when executed may execute code which accesses the state will need to be in `ST', either overtly or covertly)
03:59:54 <_flow_> so if every part of my programm needs to access/modify the hashtable it would have to be run within ST or IO
04:02:05 <_flow_> hmm, some code snippets would be helpfull
04:02:29 <ski> probably not every part of your program will have to do that
04:03:04 <ski> (iow, you should normally strive to not have more parts of your program than necessary in `ST s'/`IO'/ whatever monad you dislike)
04:04:21 <mcstar> ski: as a related question, ST is different from IO, in that you dont need unsafe* trickery to naturally interleave pure code and which changes state?
04:07:26 <ski> mcstar : i wouldn't call it "interleave"
04:08:05 <ski> you can call non-`IO'-code from `IO'-code in a similar way as you can call non-`ST'-code from `ST'-code
04:08:57 <ski> the point is that non-`ST'-code can also call `ST'-code (via `runST') -- but only a *whole* delineated state-thread at a time
04:09:45 <ski> as soon as you use `runST' to "finish" an `ST'-computation, the types will ensure that this state-thread can't communicate via its mutable state to other state-threads
04:11:00 <mcstar> ski: and what i get from a runST call, cant change state again?
04:11:19 <ski> so, each `runST' call introduces a fully sequenced state-thread, which is completely unrestricted wrt sequencing to other state-threads, as far as the state is concerned
04:11:23 <d-snp> how do I alias a type like (a -> b) ?
04:11:28 <ski> mcstar : right
04:12:28 <ski> mcstar : however, because of laziness, it's possible that some of the state-changes in the state-thread hasn't actually occured, operationally, when you get the result from the `runST' call -- but this is an implementation detail
04:12:59 <fmap> d-snp: type F a b = a -> b
04:13:35 <d-snp> ah thanks fmap
04:14:00 <ski> mcstar : see e.g. monochroms "lazy ST example" at <http://hpaste.org/63925>
04:14:09 <fmap> in this specific case type F = (->) would be enough
04:14:52 <mcstar> thx
04:15:44 <ski> mcstar : that runs a state-thread which will (conceptually) do infinitely many state changes -- however by laziness we can see that the result is a cons cell without performing any of the (infinitely many) state changes yet
04:16:23 <ski> then, when we look at the first element of that list, that will force the first `strictToLazyST (...)' chuck to actually modify it's state
04:16:34 <ski> &c. for the next round with the next element
04:17:01 <lillis> this is such a deep rabbit hole
04:17:09 <mcstar> :)
04:17:14 <lillis> but it seems to be beautiful along the way
04:17:15 <lillis> hmm
04:18:08 <ski> mcstar : conceptually, `L.runST main' performs all the state-changes before returning, just like `map (^ 2) [0 ..]' conceptually squares all the numbers in the list before returning
04:18:37 <ski> it's just that because of non-strict evaluation, the actual work is deferred until we actually look at the results
04:19:22 <ski> the same happens with `Control.Monad.ST.Lazy' (but not with `Control.Monad.ST.Strict' -- and not with `IO' either for that matter)
04:20:44 <hpaste> d-snp pasted “streambased IO” at http://hpaste.org/70799
04:21:59 <d-snp> Hey guys, I'm trying to restrict the types to just the classes, but I think its argueing it requires more specific types
04:22:10 <d-snp> can anyone see what I'm doing wrong?
04:22:49 <d-snp> if I remove the type declarations like: eventLoop :: (Action a, Event e, State s) => Handler a e s -> Chan e -> s -> e -> IO()
04:22:53 <d-snp> it works
04:23:17 <d-snp> but then it infers the type EAction for a, instead of the class Action
04:26:44 <mcstar> ski: you will laugh at this question, can 'fix' terminate? (in general)
04:27:30 <ski> d-snp : i suspect DMR
04:27:34 <mcstar> i mean, by its type signature, it seems to me it can never give a value of type 'a' but gives the correct signature
04:27:57 <d-snp> ski: DMR?
04:28:00 <ski> d-snp : try adding `{-# NoMonomorphismRestriction #-}' to the top of the file
04:28:10 <ski> Dreaded Monomorphism Restriction
04:28:33 <ski> mcstar : sure
04:28:55 <mcstar> ski: but it doesnt take a starting value
04:29:29 <ski> > fix id
04:29:33 <lambdabot>   mueval-core: Time limit exceeded
04:29:36 <ski> @. read run fix (const " mueval-core: Time limit exceeded")
04:29:36 <lambdabot>   mueval-core: Time limit exceeded
04:29:41 <ski> > fix (const " mueval-core: Time limit exceeded")
04:29:42 <lambdabot>   " mueval-core: Time limit exceeded"
04:30:07 <ski> `const (...)' is the same as `\_ -> ...'
04:30:12 <mcstar> yes
04:30:34 <ski> > fix (\thisIsReallyFortyTwoButWeCan'tLookAtIt -> 42)
04:30:36 <lambdabot>   42
04:30:59 <ski> > fix (\thisIsReallyFortyTwoButWeCan'tLookAtIt -> case thisIsReallyFortyTwoButWeCan'tLookAtIt of !_ -> 42)  -- looking at it
04:31:03 <lambdabot>   mueval-core: Time limit exceeded
04:31:17 <ski> > fix (0 :)
04:31:18 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
04:31:30 <ski> > fix (\ns -> 0 : ns)
04:31:32 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
04:32:21 <ski> even if we're (initially) not "allowed" to look at `ns', we can still figure out that the function passed to `fix' will return a list starting with `0'
04:32:36 <ski> and then, we know that the input `ns' is a list which starts with `0'
04:32:56 <mcstar> ok, so either the function returns a constant in which case fix returns a constant, or the function returns somehow its parameter, in which case fix doesnt terminate
04:33:16 <ski> so therefore the output is a list which first starts with `0' (because of `0 : ...') and then continues with another `0' (because we knew `ns' started with a `0')
04:33:20 <ski> &c.
04:33:35 <ski> > fix (\ns -> 1 : map (2 *) ns)
04:33:36 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
04:34:58 <morel> can you define `iterate' with `fix'?
04:35:30 <Nereid> you can define any recursive function with fix
04:36:13 <morel> oh, cool.
04:36:15 <Penetrator> its the Y-cominator: http://mvanier.livejournal.com/2897.html
04:36:21 <Nereid> more precisely,
04:36:22 <morel> oh!
04:36:23 <Penetrator> well actually its not
04:36:26 <morel> oh
04:36:31 <Nereid> you can define any recursive function using fix and non-recursive functions
04:36:35 <Nereid> and only those
04:36:46 <Penetrator> fix is recursive itself
04:36:54 <Nereid> yes
04:37:26 <mcstar> you mean simply recursive? or any recursive?
04:37:33 <Nereid> "recursive" was redundant.
04:38:18 <Nereid> anyway, it's quite systematic
04:38:51 <Nereid> > let fact 0 = 1; fact n = n * fact (n-1) in fact 5
04:38:52 <lambdabot>   120
04:39:01 <Nereid> > let fact' f 0 = 1; fact' f n = n * f (n-1) in fix fact' 5
04:39:02 <lambdabot>   120
04:41:22 <mcstar> fibonacci, please
04:41:35 <Nereid> ._.
04:42:08 <Nereid> > let fib = 0 : (zipWith (+) fib (tail fib))
04:42:09 <lambdabot>   not an expression: `let fib = 0 : (zipWith (+) fib (tail fib))'
04:42:11 <Nereid> oops
04:42:15 <Nereid> > let fib = 0 : (zipWith (+) fib (tail fib)) in fib
04:42:19 <lambdabot>   mueval-core: Time limit exceeded
04:42:21 <Nereid> oops.
04:42:23 <Nereid> what did I do.
04:42:34 <ski> > (fix $ \fib n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2)) 12
04:42:36 <lambdabot>   144
04:42:47 <Nereid> well duh.
04:42:48 <mcstar> > let fib' f 0 = 1; fib' f 1 = 1; fib' f n = f (n-1) + f (n-2) in fix fib' 5
04:42:49 <lambdabot>   8
04:42:57 <mcstar> > let fib' f 0 = 1; fib' f 1 = 1; fib' f n = f (n-1) + f (n-2) in fix fib' 12
04:42:59 <lambdabot>   233
04:43:04 <ilya_s> > map fst $ iterate (\(a,b) -> (b,a+b)) (0,1)
04:43:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:43:20 <mcstar> stop this, im interested in defining it with fix
04:43:30 <Peaker> mcstar, defining what?
04:43:32 <mcstar> everyone knows the other versions
04:43:44 <Nereid> well
04:43:47 <Nereid> take your favourite version
04:43:47 <morel> iterate f x = fix (\y -> x : map f y)
04:43:50 <mcstar> Peaker: nothing, it is answered
04:43:53 <Nereid> and transform it in the obvious way
04:45:01 <Peaker> > fix (\y -> 0 : map (+1) y) !! 1000000
04:45:02 <lambdabot>   *Exception: stack overflow
04:45:11 <Peaker> > iterate (+1) 0 !! 1000000
04:45:13 <lambdabot>   *Exception: stack overflow
04:45:23 <morel> how can i define "map" while the only used recursive function is "fix"?
04:45:39 <Nereid> look at the definition of map
04:45:55 <morel> @src map
04:45:56 <lambdabot> map _ []     = []
04:45:56 <lambdabot> map f (x:xs) = f x : map f xs
04:46:01 <morel> Nereid: done. now?
04:46:10 <morel> ah
04:46:11 <mcstar> now reqrite it to use fix
04:46:15 <mcstar> :)
04:46:16 <Nereid> indeed
04:47:24 <Peaker> @src iterate
04:47:24 <lambdabot> iterate f x =  x : iterate f (f x)
04:47:36 <Philonous> morel:  The trick to rewriting a recursive function to using fix is to replace all recursive calls with a function parameter. So foo = 1 : foo becomes fix (\f -> 1 : f)
04:47:40 <mcstar> ski: see my definition of fib with fix, why is that off by 1?
04:47:53 <morel> @let m f (x:xs) = fix (\y -> f x : y)
04:47:55 <lambdabot>  Defined.
04:47:58 <morel> Philonous: cool. thank you!
04:48:13 <morel> > m (^2) [1..5]
04:48:15 <lambdabot>   Ambiguous occurrence `m'
04:48:15 <lambdabot>  It could refer to either `L.m', defined at <local...
04:48:44 <morel> @let morelsMap f (x:xs) = fix (\y -> f x : y)
04:48:45 <lambdabot>  Defined.
04:48:50 <Peaker> mcstar, using "fix" you can do it more straight-forwardly
04:48:50 <morel> > morelsMap (^2) [1..5]
04:48:52 <Peaker> (for iterate)
04:48:53 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:48:59 <Peaker> > let iterate f = fix $ \recurse x -> x : recurse (f x)  in iterate (+1) 0
04:49:00 <morel> hm, erm.
04:49:01 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:49:10 <Nereid> morel: you didn't copy the definition of map well enough ;)
04:49:17 <d-snp> ski that didn't solve the problem, the problem is that I'm misinterpreting the => type thing
04:49:36 <d-snp> from this http://stackoverflow.com/questions/5453514/lists-of-data-types-could-not-deduce-a-sometype-from-the-context-sometype I understand that it makes the function be polymorphic
04:49:48 <d-snp> but I want it to be generic
04:49:52 <Nereid> > let map' g _ [] = []; map' g f (x:xs) = f x : g f xs in fix map' (^2) [1..5]
04:49:54 <lambdabot>   [1,4,9,16,25]
04:49:57 <d-snp> is there a genericity constrain operator in haskell?
04:50:06 <Peaker> > let map f = fix $ \rec l -> case l of [] -> [] ; (x:xs) -> f x : rec xs in map (*100) [1..5]
04:50:07 <lambdabot>   <no location info>: parse error on input `rec'
04:50:18 <Peaker> > let map f = fix $ \recurse l -> case l of [] -> [] ; (x:xs) -> f x : recurse xs in map (*100) [1..5]
04:50:19 <lambdabot>   [100,200,300,400,500]
04:50:47 <Peaker> fix is actually somewhat handy to avoid passing the recursive call the same arguments
04:50:48 <ciaranm> someone should invent a shorthand for \x -> case x of
04:51:04 <Peaker> case \ of ... :)
04:51:07 <Nereid> > let map' _ g [] = []; map' f g (x:xs) = f x : g xs in fix map' (^2) [1..5]
04:51:09 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t] -> [a]
04:51:11 <Nereid> oop
04:51:19 <Nereid> > let map' _ g [] = []; map' f g (x:xs) = f x : g xs in fix (map' (^2)) [1..5]
04:51:21 <lambdabot>   [1,4,9,16,25]
04:51:26 <however> ciaranm: yes please! i recall that it was discussed at times
04:51:38 <flux> ciaranm, ocaml has one ;-). function 4 -> .. | etc
04:51:43 <ilya_s> > take 10 $ fix (\f -> \(a,b) -> (a : f (b,a+b))) (1,1)
04:51:45 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
04:51:59 <Nereid> I like the one that starts with 0.
04:52:00 <Philonous> Peaker:  It's also nice for open recursion
04:52:11 <ilya_s> > take 10 $ fix (\f -> \(a,b) -> (a : f (b,a+b))) (0,1)
04:52:13 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
04:52:22 <Peaker> Philonous, what do you mean? Avoiding an explicit name for the fixed-point?
04:52:54 <Philonous> Peaker:  It's the concept of "self" in OO languages
04:53:08 <Nereid> > let map' _ g [] = []; map' f g (x:xs) = f x : g xs in iterate (map' (^2)) [1..5]
04:53:09 <lambdabot>   Couldn't match expected type `[a] -> [a]'
04:53:09 <lambdabot>         against inferred type `[a...
04:53:14 <Nereid> ah erm
04:53:50 <Peaker> Philonous, oh, that
04:53:54 <ski> d-snp : i don't think there's any difference between "polymorphic" and "generic"
04:53:57 <Peaker> @pl fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
04:53:57 <lambdabot> fibs = fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
04:54:16 <Peaker> @. pl src iterate
04:54:16 <lambdabot> (line 1, column 1):
04:54:16 <lambdabot> unexpected end of input
04:54:16 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
04:54:38 <ski> mcstar : `fib 0' is `0', not `1'
04:54:38 <morel> erm…? wasn't that definition of "fibs" already pointless?
04:55:19 <mcstar> ski: oh, i didnt notice, sorry, irc is distracting..
04:55:35 <Philonous> Peaker:  Meaning you can have inheritance in haskell.
04:55:48 <Peaker> Philonous, Inheritance is a mistake :P
04:56:25 * ski suspects there might be cases where inheritance is better than alternatives
04:56:38 <ski> (or, as the case may be, coinheritance)
04:56:47 <Nereid> > let map' _ [] g = []; map' f (x:xs) g = f x : g in fix (map' (^2) [1..5])
04:56:48 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:56:53 <Nereid> oh erm
04:57:11 <Peaker> ski, Implementation inheritance is usually just a poor encoding of a higher-order function generating a record.. Interface inheritance is a poor encoding of ad-hoc polymorphism
04:57:30 <Peaker> implementation inheritance also messes up the notion of namespaces (though open unqualified imports also do so!)
05:01:14 <hpaste> d-snp pasted “classes together” at http://hpaste.org/70802
05:01:28 <d-snp> I have these two classes that sort of go together
05:01:40 <d-snp> but I can't use the Event class as a type in the Action class
05:01:45 <d-snp> is there a way to do that?
05:01:57 <d-snp> basically an Event type always goes together with an Action type
05:03:00 <morel> is that syntax correct at all? i mean… wait…
05:03:21 <hpaste> mekeor annotated “classes together” with “shouldn't it be like that?” at http://hpaste.org/70802#a70803
05:03:26 <morel> d-snp: ↑
05:04:17 <Nereid> basically, Event e is not a type.
05:04:38 <d-snp> morel: yes...
05:04:44 <Nereid> classes are not types, they are constraints on types.
05:04:45 <morel> d-snp: =)
05:04:46 <merijn> e like that?” at http://hpaste.org/70802#a70803
05:04:46 <merijn> 14:03 < morel> d-snp: ↑
05:04:46 <merijn> 14:03 < Nereid> basically, Event e is not a type.
05:05:01 <merijn> argh
05:05:03 <morel> merijn: oO
05:05:04 <Nereid> or something.
05:05:05 <d-snp> :P
05:05:17 <merijn> I was trying to copy and apparently I can paste with only mouseclicks?
05:05:32 <d-snp> merijn: you can disable right mouse paste in putty's configuration :)
05:05:45 <however> merijn: middle-click on linux is by default pasting the highlighted text
05:05:52 <merijn> That would probably be very helpful if I was using putty or linux
05:06:00 <d-snp> oh lol
05:06:14 <DMcGill> notepad++ 4 lyfe
05:06:57 <merijn> I was pretty sure I disabled that in Terminal, 'cause it pisses me off, but apparently I didn't (at least not correctly)
05:07:04 <totimkopf> textmate > notepad++
05:07:07 <totimkopf> :p
05:07:19 <DMcGill> I'll have a look
05:07:52 <DMcGill> ah, OSX
05:08:01 <totimkopf> I wonder if notepad++ has a haskell package
05:08:03 <Nereid> vim ;)
05:08:09 <ilya_s> > let m _ _ [] = []; m g f (x:xs) = f x:(g f xs) in (fix m) (^2) [1..5]
05:08:11 <lambdabot>   [1,4,9,16,25]
05:08:18 <totimkopf> if it does, I will def use it :)
05:08:33 <merijn> hmm, mouse paste doesn't seem to happen in my normal terminal...maybe it's just irssi
05:08:40 <merijn> oh well
05:08:45 <ilya_s> sublime text 2 is much nicer for haskell editing, I think
05:08:47 <totimkopf> DMcGill, yeah but I was just joking, I'm not an editor/OS/technology biggot, I will use whatever is useful :)
05:08:59 <totimkopf> ilya_s, really, why's that?
05:09:01 <Nereid> vim is useful ;)
05:09:10 <totimkopf> Nereid, yes :)
05:09:20 <Nereid> oh dear I stayed up far too late
05:09:32 <totimkopf> I am still a haskell beginner, so I wouldn't know what's best for haskell editing
05:09:45 <ilya_s> totimkopf, try it and see :-)
05:09:47 <DMcGill> it doesn't look like it has anything other than syntax highlighting, one of these days I'll learn a mouseless editor
05:10:05 <merijn> DMcGill: You should, it's so much nicer
05:10:24 <totimkopf> DMcGill, I think you can rig vim for even code completion and all sorts of things
05:10:24 <d-snp> but morel it results in the same problem, still it thinks handleIO should be a polymorphic method
05:10:35 <d-snp> instead of a generic one
05:10:37 <merijn> I only move my hand to the mouse to browse websites and I plan to change that too once I find a nice keyboard browsing extension
05:10:38 <Philonous> Peaker:  I still think the idea is quite neat: https://lirias.kuleuven.be/bitstream/123456789/257295/1/paper.pdf
05:10:42 <d-snp> I need to get rid of the =>'s
05:10:43 <totimkopf> but I think that's only with the GUI VIM
05:10:50 <DexterLB> is there a better way to use custom tags in Text.Blaze?
05:10:52 <hpaste> DexterLB pasted “defining custom tag in blaze” at http://hpaste.org/70805
05:10:52 <totimkopf> oops, vim :)
05:11:02 <merijn> totimkopf: I have autocompletion in terminal vim...
05:11:09 <Philonous> Peaker:  (That paper is "EffectiveAdvice: Disciplined Advice with Explicit Effects")
05:11:10 <totimkopf> merijn, oh, nice!
05:11:20 <morel> d-snp: handleIO is polymorphic.
05:11:40 <morel> d-snp: i think, what you want is to make Event a data-type. wait…
05:11:45 <totimkopf> is manipulating arrays in haskell really that difficult?
05:11:52 <d-snp> yes, and I don't want it to be, I want it to be of a  specific type
05:11:57 <merijn> totimkopf: Define "that difficult"?
05:12:17 <merijn> totimkopf: Seemed pretty simple to me when I last looked at it?
05:12:29 <totimkopf> merijn, I haven't had a chance to try for myself but according to some blog, that is the only flaw haskell has. It isn't straight forward, in other words?
05:12:32 <hpaste> morel annotated “classes together” with “try this” at http://hpaste.org/70802#a70806
05:12:34 <totimkopf> merijn, :)
05:12:36 <DMcGill> totimkopf: look at the array page on Haskell wiki (mutable arrays are a little more complicated) but it's still not bad
05:12:53 <totimkopf> then people are just whining :)
05:12:54 <however> totimkopf: haskell relies on lists much more than on arrays. lists are very easy to manipulate
05:12:59 <morel> d-snp: you are mixing type classes and data types. do you have an OOP-background?
05:13:14 <ski> Peaker : (implementation) coinheritance is relatively often used in proofs
05:13:20 <ppilate> Hi! I am trying to build a cabal project (it's a scaffolded Yesod site if that matters), but arrive upon the following error, when I try to do `cabal build': <command line>: cannot satisfy -package-id clientsession-0.7.4.3-412f9d0e9716476929b1b1a91e51745c
05:13:21 <Peaker> Philonous, the idea is neat, I just don't think implementation inheritance is useful
05:13:25 <merijn> totimkopf: Arrays are about as easy as Maps, which aren't particularly difficult I think
05:13:25 <Peaker> ski, I don't know what coinheritance is
05:13:28 <ppilate> I tried reinstalling clientsession, but it didn't help
05:13:33 <ski> @where ErikPoll
05:13:34 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
05:13:34 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
05:13:34 <lambdabot> pdf>
05:13:38 <d-snp> I do yes, but I understand the problem
05:13:39 <ski> Peaker ^
05:13:59 <d-snp> I need a sort of combined typeclass, one that defines two types
05:14:04 <however> d-snp: i suggest you step back for a moment and tell us what you are shooting for. people will be able to give you better advice then
05:14:10 <morel> d-snp: so, type classes are a set of types for which a set of certain functions are defined.
05:14:39 <DMcGill> a little like interfaces from OO
05:14:48 <d-snp> yes I understand typeclasses
05:14:58 <ski> Peaker : basically, you have an algebraic data type / variant/sum type, and a function which pattern-matches on it. now you extend the type to a supertype, by adding more constructors, and you now want to generate an extended version of the function, that just adds cases for the new constructors
05:15:22 <Peaker> ski, Ah, why does this relate to inheritance?
05:15:38 <ski> Peaker : in proofs, it's common to say "the proof of the extended system is the same as the proof for the basic system, with these clauses added to the induction : ..."
05:15:53 <ski> Peaker : it's the categorical dual of (implementation) inheritance
05:16:37 <ski> (because variant and record types are dual to each other)
05:17:11 <Peaker> ski, well, I agree sums of sums and products of products are useful, but I don't think that captures the essence of inheritance
05:17:16 <d-snp> I would need a typeclass that defines two types at the same time, or I need to reduce these two types to one, like so: class (Event e, Action a) where handleIO :: a -> IO e
05:17:20 <Peaker> (unless I'm misunderstanding here?)
05:17:22 <d-snp> does that make sense?
05:17:40 <d-snp> do you understand how that is different from handleIO :: Event e => a -> IO e?
05:18:23 <ski> see e.g. "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs and someone else at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf> for more on the duality between variant & record types, induction & coinduction, algebras & coalgebras
05:18:37 <Peaker> ski, the properties of inheritance I'm interested in are the practical ones more than the algebraic ones: A) namespace mangling,  B) name-based dispatch to unknown subclasses  C) uncomposability (single-inheritance) or hairy problems (multiple inheritance),
05:18:49 <d-snp> Multi-parameter type classes
05:18:52 <d-snp> perhaps that's it
05:19:15 <hpaste> merijn annotated “classes together” with “maybe you need something like this?” at http://hpaste.org/70802#a70807
05:19:23 <Peaker> ski, B is better described as: B) lack of explicit interface between super and sub-classes
05:19:26 <ski> Peaker : in the inheritance case, we're adding operations to the interface (the type), and then we have to implement those extra operations in the subclass
05:20:00 <ski> Peaker : in the coinheritance case, we're adding constructors to the type, and then we have to add patten-matching cases for those constructors in the extended version of the function
05:20:08 <merijn> d-snp: Maybe that's what you want? It requires you to explicitly define an ActionEvent instance for each Action/Event combination
05:20:26 <Peaker> ski, we don't even know what operations we can implement though, as the base class calls sub-classes by name and may have default implementations.  You might need to implement sets of operations together or not at all, but there's no easy way to encode that with ordinary OO inheritance
05:20:41 <ski> i think by B) you mean "open recursion", yes ?
05:20:56 <ski> (i'm not sure what you mean by A))
05:21:54 <Peaker> ski, A is essentially the same problem as open unqualified imports -- base class adds new names, things may break (your names collide with base class names) -- though this may be mitigated with annotations on each declaration (which most implementations of inheritance don't mandate)
05:22:39 <ski> ok
05:22:41 <Peaker> ski, By B I mean that when inheriting something, you might need to always define f,g or none at all.  There's no explicit API mentioning this. Maybe documentation.   With the alternate encoding of HOFs generating a record -- you can have two functions, one that takes f,g and one that takes none, to encode this invariant
05:22:41 <DMcGill> regarding the Event/Action thing, note that it also needs MultiParamTypeClasses
05:22:47 <ski> that problem is orthogonal to what i'm talking about
05:22:55 <ski> (the A) one, i.e.)
05:23:42 <Peaker> ski, I understand, it seems to me (I may be wrong) that the papers you link to are describing inheritance's algebraic properties, or what it reduces to, whereas I'm talking about the practical way it is exposed in OOP languages
05:24:35 <ski> (and imo A doesn't have that much to do with inheritance .. you can get similar problems in e.g. Haskell if you import unqualified (one could say that in the OO case, in case of ambiguity, one must disambiguate by `this' or `super', say ..))
05:24:40 <Peaker> ski, And that if we use constructs to more directly model the things inheritance reduces to, we might have useful stuff, but then it's not the typical OOP inheritance anymore, just something that's algebraically similar
05:25:07 <Peaker> ski, in OOP you can disambiguate by mandating "new" and "overrides" annotations to everything
05:25:17 <Peaker> ski, in Haskell I indeed frown upon open unqualified imports
05:25:25 <ciaranm> you appear to be confusing "OOP" and "Java"
05:25:54 <Peaker> ciaranm, well, OOP is ill-defined anyway, so I just define it to be the set of common properties I know of in C++, Java, C#, Python
05:25:59 <ski> Peaker : well, in case you can't instantiate a class unless it's fully concrete, then you can see in the class type which operations must be defined
05:26:05 <Peaker> ciaranm, (properties that are considered part of OOP in those languages)
05:26:10 <ski> (but in presense of overriding, there can still be problems, yes)
05:26:25 <Peaker> ski, but then that's interface inheritance and not implementation inheritance
05:27:08 <ciaranm> there's no difference between the two, unless your type system sucks
05:27:21 <Peaker> ski, or rather, if all overridables *must* be overridden, and that's enforced, even if that's implementation inheritance then there's less of a problem, but it would still be better-encoded by a simple HOF taking these implementations as an argument
05:27:22 <ski> Peaker : yes, the papers talk about the theory (though it's rather coalgebraic properties of inheritance ;)
05:27:40 <d-snp> holy shit guys, I got it working
05:27:47 <d-snp> it's pretty badass
05:27:58 <totimkopf> hehe
05:28:04 <ski> Peaker : i'm not sure what you mean by "constructs"
05:28:13 <totimkopf> d-snp, do you feel high now? :)
05:28:31 <hpaste> d-snp pasted “Using badass language features” at http://hpaste.org/70808
05:28:34 <ski> @where object-oriented
05:28:34 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
05:28:43 <Peaker> ciaranm, if you mandate overrides/new you solve some of the problems, but interface inheritance is also superfluous if you have HOFs and records that can contain functions and a really poor way to encode things type-classes are used for
05:29:06 <d-snp> totimkopf: yes feels pretty good :P I use multiparameter type class and functional dependencies to express my feelings to the world
05:29:36 <ski> Peaker : "but then that's interface inheritance and not implementation inheritance" -- no, i was talking about the implementation variety here (though the other one is also involved, though they need not coincide)
05:29:39 <Peaker> ski, I mean we already have records, HOFs, first-class functions.  The useful parts modeled by OOP/inheritance are directly expressible in these simpler terms of records, HOFs, etc.
05:29:50 <ski> (iow, a subclass need not always be a subtype)
05:29:51 <hpaste> d-snp annotated “Using badass language features” with “How I use it” at http://hpaste.org/70808#a70809
05:29:51 <hpaste> d-snp annotated “Using badass language features” with “How I use it” at http://hpaste.org/70808#a70810
05:29:58 <d-snp> oO
05:30:03 <d-snp> lol I pressed the button twice?
05:30:52 <Peaker> ski, I'm claiming that if you restrict, via discipline, the use of inheritance to a very specific subset, you'll still suffer from multiple-inheritance issues, difficulty of enforcing these rules, and gain no advantage over use of records/etc
05:31:18 <ski> ciaranm : O'Caml solves the "binary method" and the "clone method" problems by allowing a "this" type. this means that the type of an object instantiated from a subclass need not be a subtype of the type of an object instantiated from the superclass
05:32:15 <Peaker> ski, Maybe a simpler way to convey our points here would be via examples.. I'd really like to see an example of useful inheritance -- and discuss pros/cons vs. an alternative encoding with simple HOFs, sums and records
05:33:47 <Peaker> example of inheritance:  class TestBase { virtual void setup(); virtual void run(); virtual void tearDown(); }
05:34:00 <Peaker> class MyTestEnv(TestBase) { implement setUp/tearDown here }
05:34:14 <Peaker> class SomeTest(MyTestEnv) { implement run here }
05:35:10 <ski> Peaker : i'm only claiming that inheritance and coinheritance *might* be the best alternative in some cases (i don't actually claim they are) -- i agree that for very many cases there are better ways to express oneself
05:35:12 <Peaker> this is a typical example of a horrible way to encode the much simpler:   myTestEnv :: IO a -> IO a    (bracket around the given test[s])
05:35:46 <ski> Peaker : "I'm claiming that if you restrict, ..." -- i don't dispute this
05:36:11 <ski> (except possibly the "and gain no advantage over use of records/etc" at the end)
05:36:21 <Peaker> ski, well, I'm open to seeing convincing examples.. But absence of evidence over a long time is somewhat valid evidence of absence, I think
05:36:46 <Peaker> (inconclusive, but suggestive)
05:37:08 <ski> well, i'm taking the presence of use of coinheritance in proofs as a hint that there might be some use
05:37:28 <ski> maybe those proofs could be restructured in better ways, without coinheritance, i'm not sure
05:37:40 <Peaker> I have no idea or claims about coinheritance :)
05:38:06 <ciaranm> i'm wondering whether coinheritance is just upside down inheritance or whether it's fiddlier
05:38:14 <ski> and then i'm reasoning by analogy that if there might be some valid use of coinheritance, then there might be some for inheritance as well
05:38:26 <Peaker> I'm not claiming algebraic things are not useful, just that particular language features are not very useful (and those may reduce to algebraic things in their essence. But not only their essence matters)
05:38:43 <ski> of course, this analogy isn't perfect, since (sadly) our languages aren't fully symmetric wrt this duality between record and variant types
05:38:43 <Peaker> s/algebraic things/these specific algebraic things
05:39:18 <ski> ciaranm : "abstractly" it's just "upside down inheritance", afaiu
05:39:47 <Peaker> ski, I might say: "Haskell records really suck and are not as useful as they could have been" -- and a response could say "Product types are very useful",  but when criticizing records, it's not the idea of products that's being criticized
05:39:49 <ski> concretely (i.e. interpreted in a specific (non-self-dual) category like `Hask', differences might appear that aren't there in the abstract concepts)
05:40:08 <Peaker> ski, similarly, "OOP inheritance really sucks" is not criticizing the algebraic notions nehind it
05:40:26 <ciaranm> the difference is that OOP wasn't built upon algebra
05:40:39 <ski> "but when criticizing records, it's not the idea of products that's being criticized" -- i'm not sure about this
05:41:01 <Peaker> ski, it could be, but not necessarily. I really doubt most people criticizing Haskell records (and there are many) dislike the notion of product types :)
05:41:03 <ciaranm> haskell records are explicitly products (except they changed the * to not look like ML)
05:41:04 <ski> (unless you're talking about concrete or abstract syntax, or limitations in type system, or performance)
05:41:23 <ciaranm> OOP just happens to have people using (co)algebra to figure out what it's supposed to do
05:41:56 <ski> (yeah, i'd preferred it if they'd kept the MLesque `*'s ..)
05:43:14 <Peaker> ski, criticism of records involves their syntactic elements, namespacing, limitations in the type system around them, yeah
05:45:03 <ski> yeah, but here i was talking generally about using them to structure programs
05:45:23 <ski> not about incidental quirks of various languages
05:45:56 <ski> (but i agree the type system aspect is more relevant than the others, for this concern)
05:48:01 <ski> @let infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =     ys; (x:xs) /\/ ys = x : ys /\/ xs in (/\/)
05:48:01 <lambdabot>   Parse error: in
05:48:07 <ski> @let infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =     ys; (x:xs) /\/ ys = x : ys /\/ xs
05:48:08 <lambdabot>  Defined.
05:48:14 <ski> > fix $ \ns -> repeat 0 /\/ map succ ns
05:48:17 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
05:48:23 <ski> > (`map` [1 ..]) . fix $ \loop n -> if odd n then 0 else 1 + loop (n `div` 2)
05:48:26 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
05:48:34 <ski> @let swap :: Arrow ar => ar (a,b) (b,a); swap = arr snd &&& arr fst; mirror :: ArrowChoice ar => ar (Either b a) (Either a b); mirror = arr Right ||| arr Left
05:48:35 <lambdabot>  Defined.
05:48:39 <ski> > fix $ \ns -> (\ ~(~0:ns) -> 0:ns) $ ns /\/ map succ ns
05:48:41 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
05:48:43 <ski> > (`map` [0 ..]) . fix $ \loop n -> if n == 0 then 0 else (uncurry (+) . fmap loop . swap . (`divMod` 2)) n
05:48:45 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
05:51:52 <ski> > fix $ \nss -> [1] : map (\ns -> zipWith (+) ([0] ++ ns) (ns ++ [0])) nss
05:51:54 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
05:52:16 <ski> mcstar,morel,ilya_s : ^ a couple more computations using `fix' ..
05:53:04 <ilya_s> looks like magic..
05:54:08 <Penetrator> @hoodle ~
05:54:08 <lambdabot> keyword ~
05:54:08 <lambdabot> Test.HUnit.Base (~:) :: Testable t => String -> t -> Test
05:54:08 <lambdabot> Test.HUnit.Base (~=?) :: (Eq a, Show a) => a -> a -> Test
05:54:21 <DMcGill> what is hoodle?
05:54:29 <Penetrator> typo
05:54:31 <ski> (it's really just three computations. the first two in pairs, to show a different way to compute the same thing)
05:54:43 <DMcGill> yet lambdabot has it as a synonym?
05:55:00 <Penetrator> must be a common typo :P
05:55:07 <jaxtr> ahh it's a wonderful day
05:55:10 <merijn> DMcGill: lambdabot does levensteihn to determine relevant commands
05:55:18 <mcstar> stop saying that
05:55:21 <ski> > (\(a:as) -> (a,as)) [0,1,2]
05:55:23 <lambdabot>   (0,[1,2])
05:55:27 <ski> > (\(a:as) -> ()) [0,1,2]
05:55:29 <lambdabot>   ()
05:55:30 <however> yeah, it has autocorrection, not so many synonyms
05:55:33 <ski> > (\ ~(a:as) -> (a,as)) [0,1,2]
05:55:35 <lambdabot>   (0,[1,2])
05:55:39 <ski> > (\ ~(a:as) -> ()) [0,1,2]
05:55:41 <lambdabot>   ()
05:55:45 <ski> > (\(a:as) -> (a,as)) []
05:55:45 <merijn> @doodle id
05:55:46 <lambdabot> Maybe you meant: google hoogle
05:55:47 <lambdabot>   *Exception: <interactive>:3:1-17: Non-exhaustive patterns in lambda
05:55:48 <ski> > (\(a:as) -> ()) []
05:55:49 <lambdabot>   *Exception: <interactive>:3:1-13: Non-exhaustive patterns in lambda
05:55:53 <ski> > (\ ~(a:as) -> (a,as)) []
05:55:55 <lambdabot>   (*Exception: <interactive>:3:1-19: Irrefutable pattern failed for pattern (...
05:55:57 <ski> > (\ ~(a:as) -> ()) []
05:55:58 <lambdabot>   ()
05:56:09 <merijn> @hoodde id
05:56:10 <lambdabot> Prelude id :: a -> a
05:56:10 <lambdabot> Data.Function id :: a -> a
05:56:10 <lambdabot> Control.Category id :: Category cat => cat a a
05:56:14 <favonia> @h__gle ==
05:56:15 <lambdabot> Prelude (==) :: Eq a => a -> a -> Bool
05:56:15 <lambdabot> Data.Eq (==) :: Eq a => a -> a -> Bool
05:56:15 <lambdabot> Test.QuickCheck.Property (==>) :: Testable prop => Bool -> prop -> Property
05:56:28 <Penetrator> (\ ~x -> x+1) 1
05:56:29 <ski> Peaker : the `~' in front of a pattern delays the matching of that pattern until one of the variables (if any) in the pattern is forced
05:56:33 <Penetrator> > (\ ~x -> x+1) 1
05:56:34 <lambdabot>   2
05:56:37 <favonia> @h_____ ==
05:56:38 <lambdabot> Unknown command, try @list
05:56:47 <favonia> @h__g__ ==
05:56:47 <lambdabot> Unknown command, try @list
05:57:00 <however> favonia: lambdabot is also available in private windows
05:57:01 <ski> Peaker : note the `(' in front of "*Exception: ...", in the `(\ ~(a:as) -> (a,as)) []' case
05:57:15 <merijn> > (\(x:xs) -> 1) []
05:57:16 <lambdabot>   *Exception: <interactive>:3:1-12: Non-exhaustive patterns in lambda
05:57:20 <merijn> > (\~(x:xs) -> 1) []
05:57:22 <lambdabot>   <no location info>: parse error on input `->'
05:57:30 <ski> need a space
05:57:35 <favonia> however: ah, sorry.
05:57:37 <ski> > (\ ~(x:xs) -> 1) []
05:57:39 <lambdabot>   1
05:57:42 <merijn> my bad
05:57:45 <ski> > (\ ~(x:xs) -> Just x) []
05:57:46 <lambdabot>   Just *Exception: <interactive>:3:1-19: Irrefutable pattern failed for patte...
05:58:46 <ski> another way to write the `(\ ~(~0:ns) -> 0:ns)' above would have been to say `((0 :) . tail)' -- but that didn't emphasize that the element that `tail' discards is actually `0'
05:59:04 <ski> (or rather, it is `0' in case we don't look at it before setting the output element to `0' :)
05:59:24 <ski> > fix $ \ns -> (\ ~(~0:ns) -> 0:ns) $ ns /\/ map succ ns
05:59:26 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
05:59:34 <ski> > fix $ \ns -> (\ ~(n:ns) -> case n of 0 -> 0:ns) $ ns /\/ map succ ns
05:59:38 <lambdabot>   mueval-core: Time limit exceeded
05:59:39 <ski> > fix $ \ns -> (\ ~(n:ns) -> 0 : case n of 0 -> ns) $ ns /\/ map succ ns
05:59:42 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
06:00:27 <ski> > fix $ \ns -> (\ns -> case ns of n:ns -> case n of 0 -> 0:ns) $ ns /\/ map succ ns
06:00:31 <lambdabot>   mueval-core: Time limit exceeded
06:00:36 <ski> > fix $ \ns -> (\ns -> 0 : case ns of n:ns -> case n of 0 -> ns) $ ns /\/ map succ ns
06:00:40 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
06:01:02 <ski> (i suppose i could have used `case ns of 0:ns -> ...' in those)
06:01:23 <ski> > fix $ \ns -> (\ns -> case head ns of 0 -> 0 : tail ns) $ ns /\/ map succ ns
06:01:27 <lambdabot>   mueval-core: Time limit exceeded
06:01:31 <ski> > fix $ \ns -> (\ns -> 0 : case head ns of 0 -> tail ns) $ ns /\/ map succ ns
06:01:33 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
06:01:53 <ski> and of course ..
06:02:07 <ski> > fix $ \ns -> ns /\/ map succ ns  -- .. doesn't work :/
06:02:11 <lambdabot>   mueval-core: Time limit exceeded
06:02:32 <ski> (it needs the `0' element to bootstrap itself, then it can keep running)
06:03:18 <ski> declaratively, `fix $ \ns -> ns /\/ map succ ns'  is the sequence of numbers which is itself interleaved with itself-with-each-element-incremented
06:03:42 <ski> however, that doesn't uniquely determine the first element -- but as soon as we do that, the rest follows
06:04:03 <ski> (ilya_s : all clear ? :)
06:04:31 <ilya_s> > fix (\f (x:xs) -> x : f [n | n <- xs, mod n x /= 0]) [2..]
06:04:32 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
06:04:51 <however> ski: yes?
06:04:57 <however> ;)
06:05:07 <ilya_s> ski, yes, now I finally understand how fix works
06:05:11 <morel> hehe
06:05:14 <ski> however : wha.. hrm. yes ?
06:07:04 <ilya_s> fix allows to write short and elegant solutions, but.. please.. do not use it in real code :)
06:07:33 <noob316> hi
06:08:00 <ciaranm> pfff. were it not for fix i'd have to remember what the library function that makes infinite copies of stuff is
06:08:12 <morel> ilya_s: that's probably why it's not in the prelude.
06:08:16 <morel> noob316: hi :)
06:08:24 <ciaranm> i'd much rather only remember fix, fmap, pure and join
06:08:32 <yitz> > cycle "ciaranm "
06:08:33 <lambdabot>   "ciaranm ciaranm ciaranm ciaranm ciaranm ciaranm ciaranm ciaranm ciaranm ci...
06:08:39 <mcstar> why not use it in real code?
06:08:46 <mcstar> is it slow or something?
06:08:52 <noob316> I am interested in learning haskell
06:09:05 <morel> noob316: nice!
06:09:05 <ciaranm> > fix ("monkeys":)
06:09:07 <lambdabot>   ["monkeys","monkeys","monkeys","monkeys","monkeys","monkeys","monkeys","mon...
06:09:07 <mcstar> noob316: youre a noob, excellent!
06:09:11 <yitz> mcstar: it's usually not the clearest way of expressing things
06:09:17 <morel> noob316: looking for a book?
06:09:19 <ciaranm> much easier than remembering whether it's called "cycle" or "repeat" or whatever!
06:09:26 <noob316> that would be nice
06:09:36 <DMcGill> @where lyah
06:09:36 <lambdabot> http://www.learnyouahaskell.com/
06:09:43 <DMcGill> that's a good one
06:09:48 <ciaranm> and who wants to remember what the [[a]] -> [a] function is called? no-one!
06:09:56 <ciaranm> because it's called "join"
06:09:58 <noob316> thanx
06:10:07 <morel> noob316: try "learn you a haskell". it's totally nice and funny and with pictures &c.
06:10:09 <mcstar> join is like append
06:10:12 <DMcGill> or there's always
06:10:13 <mcstar> not like concat
06:10:17 <DMcGill> @where tryhaskell
06:10:17 <lambdabot> http://tryhaskell.org/
06:10:28 <DMcGill> if you want to just play around with it in your browser
06:10:43 <ciaranm> > join [[1, 2], [3, 4, 5]]
06:10:44 <lambdabot>   [1,2,3,4,5]
06:11:16 <ilya_s> mcstar, because code becomes write-only
06:11:26 <morel> ciaranm: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
06:11:26 <ciaranm> > join (Just (Just "monkey"))
06:11:28 <lambdabot>   Just "monkey"
06:11:39 <ciaranm> see. less to remember!
06:12:20 <noob316> you learn haskell for fun or for work?
06:12:26 <mcstar> yes!
06:12:40 <ski> mcstar : "join is like append" -- like both, i suppose
06:12:41 <morel> noob316: both
06:13:17 <ski> mcstar : at the basic level, it's like `concat', since it collapses two "layers" into one
06:13:18 <ciaranm> also pure and join should be called eta and mu
06:13:35 <mcstar> > join [[1, 2], [3, 4, 5], [6]]
06:13:36 <lambdabot>   [1,2,3,4,5,6]
06:13:55 <morel> ciaranm: did you read that proposal? i think it's what you want.
06:14:05 <mcstar> ski: ok, in mathematica Join is a binary operator, here it seems to be defined on monads?
06:14:22 <ciaranm> morel: i also want monads to be defined in terms of fmap, pure and join, not bind
06:14:50 <ski> mcstar : however, at a higher level, we can say it's a natural transformation `join : [] . [] >---> []' -- and this is sortof like saying it's a binary function taking two "values" of type "list of" (not of type "list of X", for some "X"), and returning a "value" of type "list of"
06:14:50 <yitz> ciaranm: what does this do: fix $ (0 :) . tail . (ap (:) (return . (1 +)) =<<)
06:14:50 <ciaranm> mcstar: join is the m (m a) -> m a bit of a monad
06:15:18 <ski> mcstar : yes, it's the monadic concatenation/flattening/"multiplication" operation
06:15:38 <morel> ciaranm: yea, that proposal proposes that monad is a subclass of applicative. so it's what you want.
06:15:51 <ski> (and then `return : id >---> []' is the unit for this multiplication)
06:16:36 <ciaranm> morel: no, it's still missing the "join instead of bind" bit
06:16:38 * ski . o O ( `class NatTrans f g where eta :: f a -> g a' )
06:16:57 <morel> ciaranm: bind has a default implementation using join :P
06:17:24 <ciaranm> morel: the proposal has it the wrong way around
06:17:32 <ciaranm> oh, it has them both
06:17:38 <morel> yes!
06:17:41 <ciaranm> is that even allowed?
06:17:52 <morel> yes
06:18:15 <ciaranm> is that proposal implemented as an XLanguageThingie?
06:18:29 <morel> i dont think so.
06:18:36 <ciaranm> well you all suck then
06:18:41 <ski> "both" ?
06:18:56 <ski> you mean having both `join' and `(>>=)' in the class ?
06:19:14 <ciaranm> i mean having join with a default implementation using bind, and bind with a default implementation using join
06:19:20 <ski> @src Eq
06:19:20 <lambdabot> class  Eq a  where
06:19:20 <lambdabot>     (==), (/=)   :: a -> a -> Bool
06:19:28 <mcstar> thats usual
06:19:33 <ski>   a0 == a1 = not (a0 /= a1)
06:19:35 <mcstar> so you have to define only one
06:19:37 <ski>   a0 /= a1 = not (a0 == a1)
06:19:54 <ciaranm> ooh, i missed that you could do that
06:19:57 <ski> something similar in `Ord', iirc
06:20:17 <ski> you only have to define one of `compare' and `(<=)', i think
06:20:41 <Penetrator> @t ap
06:20:41 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:20:45 <ski> (however, it's not as nice that we don't get any warning if we don't implement any one in the pair)
06:20:56 <ski> @type ap
06:20:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:21:01 <ski> @type (<*>)
06:21:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:21:15 <Penetrator> thanks
06:21:20 <ski> yw :)
06:21:37 <mcstar> ski: but the result is trivial, isnt it?
06:22:21 <mcstar> it loops, doesnt it?
06:24:50 <ski> result of what ?
06:25:16 <mcstar> i mean, if a function part of a typeclass, has a default implementation, then either it is correct for all types, or it is defined in terms of another such function, so either it works correclty, or theres a mutual recursion
06:25:31 <ski> yes
06:25:50 <ski> and in case you ought to define at least one, but forgot, you'll probably get `_|_'
06:25:50 <hpaste> however pasted “instances-combinator” at http://hpaste.org/70812
06:26:01 <however> ^^ it seems fairly straightforward, but still, i managed to fatally confuse myself over this
06:26:07 <mcstar> ski: thats what i meant by trivial result
06:26:10 <morel> ciaranm: you could use http://www.haskell.org/haskellwiki/The_Other_Prelude
06:26:15 <however> when i had functions of type T.ZonedTime -> String, it worked, but when generalizing to t -> String i got stuck. any advice?
06:26:29 <ski> mcstar : *nod*
06:35:39 * hackagebot async 2.0.1.0 - Run IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/async-2.0.1.0 (SimonMarlow)
06:37:51 <ski> that's strange, i think -- it appears like it ought to be able to see that there's a unique instance to use here (assuming no overlapping instances allowed)
06:38:43 <however> ski: you mean in my paste?
06:38:54 <Peaker> ghci: let f :: Num [Char] => [Char] ; f = "a" + 0      works (with flexible contexts).  Then :t f     fails
06:39:07 <ski> however i wonder whether it doesn't internally expand `HasFormatter t (t -> String)' to `t0 ~ t1 => HasFormatter t0 (t1 -> String)', and then conveniently forgetting to look at the context `t0 ~ t1' when attempting to determine the instance
06:39:38 <dmwit> ski: It does not internally make that transformation.
06:39:41 <dmwit> What's the paste?
06:39:46 <Peaker> interesting it lets you give a type that will then fail type checking/:t
06:39:50 <dmwit> (In fact, making that transformation manually can solve a lot of problems.)
06:40:11 <however> dmwit, http://hpaste.org/70812 the question is how to resolve the 2 compiler errors quoted
06:40:52 <dmwit> however: Make the change that ski suggested.
06:41:13 <dmwit> Change instance HasFormatter t (t -> String) to instance (t ~ t') => HasFormatter t (t' -> String)
06:41:15 <ski> i suggested a change ?
06:41:27 <dmwit> ski: Sort of, by accident. =)
06:41:42 <however> will try. thanks
06:42:11 <dmwit> See also http://stackoverflow.com/a/10777583/791604
06:43:10 <ski> hm, just wondering, is there an `instance HasZone T.ZonedTime' in scope ?
06:43:33 <however> ski: yup, see line 33 of the paste
06:43:40 <Penetrator> is there anyway to use ghci to get the type of a partially applied function?
06:44:08 <Penetrator> eg  :t add (x::Int)
06:44:19 <ski> oh, somehow i missed it
06:44:23 <Penetrator> would give Int -> Int
06:44:36 <however> oy, if you forget the "=>" in "instance (t ~ u) => HasFormatter ...", you get a ghc panic :-/
06:44:37 <dmwit> :t add (undefined :: Int){
06:44:38 <dmwit> :t add (undefined :: Int)
06:44:38 <lambdabot> parse error (possibly incorrect indentation)
06:44:39 <lambdabot> Not in scope: `add'
06:44:45 <dmwit> :t (+) (undefined :: Int)
06:44:46 <lambdabot> Int -> Int
06:44:50 <ski> "It will not specialize a type before making this choice, even if specializing would allow one or more of the available instance heads to match." -- aha
06:44:55 <ski> is this a bug ?
06:44:55 <dmwit> however: Report it as a bug.
06:45:00 <weexplat> rwbarton: if your cat was truly optimized on linux it would just set up a kernel splice, wouldn't it?  so you could probably cat unlimited bytes to /dev/null almost instantly
06:45:03 <dmwit> ski: Not a bug, it's on purpose.
06:45:07 <Penetrator> dmwit: thanks
06:45:15 <dmwit> ski: Doing otherwise violates the open world assumption.
06:45:25 <however> dmwit: will do, i was just proud because it's the first time i saw a panic :)
06:46:20 <dmwit> ski: In however's case, there's nothing stopping him (with the pasted code) from later adding an instance like instance HasFormatter Bool (Int -> String) or so.
06:46:29 <dmwit> ski: If it specialized now, it would be picking the wrong instance when that appeared.
06:46:51 <ski> dmwit : hm, i'd like to see an example of an extra instance which could make a difference in the original code
06:46:52 <dmwit> ski: Once he's made the change, then he can no longer add that instance later, so it's safe to pick the one that's there now.
06:47:20 <dmwit> ski: Oh, sure, just HasFormatter T.ZonedTime (AnythingButT.ZonedTime -> String)
06:47:29 <Phlogistique> heya
06:47:32 <Phlogistique> if I made a t-shirt with a drawing of a ghost saying "GADTs", who would get one?
06:47:42 <ski> dmwit : hm, interesting
06:47:49 <dmwit> That depends how adorable the ghost is. ;-)
06:48:07 <sipa> why a ghost?
06:48:13 <dmwit> phantom types, maybe =)
06:48:19 <Phlogistique> sipa: because phantom types
06:48:24 <sipa> right
06:48:25 <however> unbelievably, it works now. thanks a bunch, dmwit and ski \o/
06:50:07 <ski> dmwit : i wonder how this might change if it could take the context into account when selecting an instance (but of course still guarantee that only one instance could apply)
06:51:20 <dmwit> ski: Well, the original (failing) code didn't even have any contexts...
06:51:51 <ski> yeah, i was talking generally, here :)
06:53:03 <dmwit> I'm not sure what currently failing code you want to suddenly compile.
06:53:48 <dmwit> You want to be able to declare two instances with the same head?
06:53:49 <nand`> A Set isomorphism is just a set bijection, right?
06:53:54 <dmwit> nand`: yes
06:54:52 <ski>   class Frob a
06:54:53 <ski>   instance a ~ Foo => Frob a
06:54:56 <ski>   instance a ~ Bar => Frob a
06:55:02 <ski> would that work ?
06:55:03 <ciaranm> for your next lesson, give three examples of where being bijective isn't enough to be an iso
06:55:21 <dmwit> ski: Currently, no. With your proposed change, possibly.
06:55:39 <nand`> I'm working through the definition of representability; as such: R∈C represents F : C -> Set iff ∀X. F(X) ≅ C(R,X); now since isomorphisms in Set are bijections and two sets have bijections iff they have the same cardinality; I can use this for the following mnemonic: R represents F iff F(X) has the same number of elements as there are arrows from R to X. Sound accurate?
06:55:48 <ski> i'd probably have to think more, to come up with a more sensible case (if any exists)
06:56:34 <dmwit> nand`: Almost.
06:56:47 <dmwit> nand`: There's one more condition than just isomorphism, though: the isomorphism must be natural.
06:56:59 <mcstar> ciaranm: a set doesnt have a structure, so whenever there is, a bijections is not sufficient for isomorhism?
06:57:42 <dmwit> mcstar: That doesn't sound right. I bet I can come up with a structure for which bijection is enough for isomorphism.
06:57:43 <ciaranm> mcstar: "whenever"'s a bit strong... for algebras bijective homs are isos
06:57:59 * ski . o O ( Let's make `Set' concrete over `CABA' )
06:58:11 <dmwit> ski: What's CABA?
06:58:23 <ski> Complete Atomic Boolean Algebras
06:58:27 <nand`> dmwit: by this do you mean that η ∘ F(X) = C(R,X) ∘ η ?
06:58:57 <dmwit> Oh, crap, you called me on it. I used to know what "natural" meant there, but now I'll have to work it out all over again.
06:59:19 <rwbarton> basically it means "F(f) = C(R,f)"
06:59:20 <ski> (you could use `Rel' instead of `CABA')
06:59:38 <rwbarton> for any f : X -> Y
06:59:49 <nand`> oh, right
06:59:57 <nand`> I completely disregarded arrows in my example
07:00:05 <nand`> I feel ashamed
07:00:26 <ciaranm> just pretend you were implying discrete categories everywhere
07:01:21 <nand`> either way; I used this mnemonic to understand why any singleton set represents the identity functor: for a set of cardinality n, there are exactly n ways to map a singleton into it
07:01:22 <rwbarton> also I would say that when we say "R∈C represents F : C -> Set" we usually have a particular isomorphism F(X) ≅ C(R,X) in mind
07:01:27 * dmwit tries to work out what it means despite rwbarton's summary
07:01:54 <rwbarton> which should be thought of as part of the structure of what it means to represent a functor
07:03:39 <mcstar> OT: do you guys know a way of directly inserting unicode characters in KDE apps by their hex code?
07:04:05 <ski> (.. it's a constructive existential)
07:04:07 <rwbarton> nand`, here is a cautionary example
07:04:19 <lillis> I'm having problems with returning a simple Int in a function that's defined as returning Num
07:04:20 <rwbarton> oh wait, hmm
07:04:28 <rwbarton> I need to rethink my example :)
07:04:56 <dmwit> rwbarton: F(f) = C(R,f) seems... funnily typed
07:04:58 <ski> lillis : if you have `foo :: Num a => ... -> a', then you're promising to return a value of type `a' for any numeric type the *caller* of your function `foo' wants to use
07:05:06 <rwbarton> that's why i put it in quotes
07:05:18 <ski> lillis : you (i.e. the code inside `foo') don't get to choose `a', the caller does
07:05:37 <ski> lillis : maybe you wanted to use `fromIntegral myInt' ?
07:05:44 <dmwit> Okay. The precise version is eta . F(f) = C(R,f) . eta?
07:05:59 <lillis> ski: the problem i was having (which seemed weird) was that if I have (Num a) => [a] -> a for example
07:06:06 <lillis> f [] = 0
07:06:08 <lillis> failed
07:06:12 <lillis> but i must have mistyped again
07:06:14 <lillis> because now it works
07:06:16 <ski> well, that shouldn't fail
07:06:18 <lillis> so im just lazy
07:06:31 <rwbarton> right
07:06:34 <ski> since `0' is overloaded to be a value of type `a', for any type `a' such that `Num a'
07:06:36 <lillis> hence my confusion - i'll stop talking now ;)
07:06:52 <ski> lillis : well, laziness is a virtue ;)
07:07:23 <rwbarton> dmwit: but eta is an isomorphism and so usually we think of it as an identification of sets anyways
07:07:32 * dmwit nods
07:08:04 <dmwit> I understand that experienced mathematicians will be imprecise about this stuff because they know how to make it precise. But I'm not experienced enough yet. =)
07:08:19 <nand`> I'm also looking at the example of (ℕ,+,0) representing U : Mon → Set using the same visualization; I can demonstrate it for some monoids eg (ℝ,+,0) or indeed (ℕ,+,0) itself by noting that ∀x∈ℕ there exists a monoid homomorphism (·x) from (ℕ,+,0) into itself, where (0·x + 0·x) = 0 fulfills identity and (a·x + b·x) = (a+b)·x, making it a homomorphism; clearly the number of these mappings
07:08:22 <nand`> is the same as the size of ℕ itself
07:08:22 <rwbarton> I feel like I should be able to construct a counterexample to nand`'s original claim
07:08:36 <merijn> lillis: Just to be a bit pedantic, numeric literals are of type "Num a => a", not Int
07:08:39 <nand`> rwbarton: I'd be interested
07:09:02 <mux> or Fractional a => a
07:09:24 <merijn> mux: For floating points, I guess?
07:09:28 <merijn> :t 1.0
07:09:30 <lambdabot> forall t. (Fractional t) => t
07:09:38 <mux> yeah
07:09:48 <nand`> :t fromRational -- this is how they work
07:09:49 <lambdabot> forall a. (Fractional a) => Rational -> a
07:09:56 <nand`> very silly for some fractions :P
07:11:10 <hpaste> DexterLB pasted “data declaration” at http://hpaste.org/70813
07:11:20 <DexterLB> is there a better way to define this type?
07:11:30 <dmwit> nand`: Here's another way of understanding how (N,+,0) can represent U: the monoid (N,+,0) is generated by the single value 1.
07:11:47 <dmwit> nand`: So the morphisms into other monoids are picking out the generators of the other monoid.
07:12:24 <nand`> ah
07:12:47 <dmwit> That was not quite what I wanted to say. What I meant was, any morphism into another monoid is entirely defined by what it does to 1.
07:12:52 <nand`> yes
07:13:26 <nand`> I can see how that analogy generalizes my example of linear functions; but how does it work for monoids with multiple generators, say (ℤ,+,0)?
07:13:40 <nand`> generators being (1, -1)
07:13:50 <dmwit> Yes, this is why I changed what I said.
07:13:55 <dmwit> It has nothing to do with the generators of the other monoid.
07:14:11 <dmwit> The magic is in the fact that (N,+,0) is the free monoid over ().
07:14:22 <nand`> oh, I think I know what you mean
07:14:45 <nand`> by mapping 1 to any combination of the generators of the other monoid?
07:14:50 <nand`> eg. 1+1+1
07:14:52 <HugoDaniel> is there something like wordpress.com but for some haskell blog system ?
07:14:52 <mcstar> DexterLB: data Option = Bar | Baz | Boo; data MyData = MyData Option String, not particularly better
07:15:14 <dmwit> nand`: There are exactly as many elements of a monoid as there are morphisms from (N,+,0) to that monoid:
07:15:22 <nand`> so the number of arrows from (ℕ,+,0) is the number of combinations of the generators in other monoids?
07:15:28 <dmwit> nand`: Namely, put the morphism f in correspondence with f(1)
07:15:30 <EvanR> what does it mean for a monoid to be 'over' something
07:15:50 <ski> > 0o3.1103755242102643
07:15:51 <lambdabot>   No instance for (GHC.Show.Show (f b))
07:15:51 <lambdabot>    arising from a use of `M5431715731...
07:16:18 <dmwit> EvanR: I'm not sure what it means in general, but the free monoid over X is (finite) lists of X.
07:16:24 <nand`> dmwit: right, that works well with what I said seeing as any element of a monoid is some combination of the generators
07:16:35 <EvanR> ok
07:16:41 <nand`> and explains why it reprenents U
07:16:44 <nand`> represents, even
07:16:49 <dmwit> nand`: Sure, but you don't need to work out what the generators of your other monoid are for this to be true. =)
07:16:54 <nand`> indeed :)
07:17:02 <DexterLB> mcstar: ty
07:17:04 <EvanR> dmwit: i heard talk in here of 'the free monoid'
07:17:09 <nand`> it's just a good way to ‘demonstrate’ it, I suppose
07:17:24 <EvanR> does that mean anything on its own
07:17:38 <dmwit> EvanR: It has just as much meaning as "list". =)
07:17:44 <EvanR> ok
07:17:47 <rwbarton> working out what functor ℤ represents is a good exercise
07:17:56 <EvanR> [] A, without the a ;)
07:18:01 <dmwit> right =)
07:18:13 * EvanR head explode
07:18:37 <nand`> rwbarton: wild guess: the functor that takes each set to a cross product with itself?
07:18:39 <ski> EvanR : "free Foo over Bar" means the free Foo generated from Bar
07:18:54 <rwbarton> not quite
07:18:58 <rwbarton> that would be represented by a different monoid
07:19:12 <nand`> union with itself?
07:19:12 <dmwit> ski: I dare you to reread that sentence.
07:19:22 <nand`> wait
07:19:26 <nand`> that makes no sense :D
07:19:33 <nand`> rwbarton: I'll stop guessing
07:19:44 * ski rethinks
07:21:06 <dmwit> EvanR: The free foo over bar is the structure you get by starting with the elements in "bar", and adding just enough new elements based on "bar" to get the structure demanded by "foo".
07:21:07 <rwbarton> anyways here is a dumb counterexample to your original question -- let C be the category with two objects a and b and two (non-identity) morphisms both from a to b and let R be a
07:21:18 <dmwit> EvanR: For example: monoids have mempty and mappend, right?
07:21:32 <rwbarton> I guess I better name the two morphisms of C, let's call them f and g
07:21:48 <ski> hm, i don't see the difference with what dmwit said right above
07:22:01 <ski> "(N,+,0) is the free monoid over ()" is a free monoid generated from a set
07:22:08 <dmwit> EvanR: So, the free monoid over X has the elements X, plus a brand new element for mempty, plus if "v" and "w" are part of the set so far, we add "mappend v w".
07:22:31 <ski> (i know generating the free *sub*monoid from a particular subset of the carrier of some given monoid is different)
07:22:33 <rwbarton> then the functor F represented by R has F(a) = a one-element set, F(b) = a two-element set and F(f) and F(g) take the element of F(a) to different elements of F(b)
07:23:09 <rwbarton> but there's also a perfectly good functor F' with F'(a) = a one-element set, F'(b) = a two-element set and F'(f) equal to F'(g)
07:23:10 <dmwit> EvanR: After we've iterated that process a few infinity times, we take the equivalence classes, where "equivalence" is "v can be rewritten to w just using the monoid laws".
07:23:31 <rwbarton> its value on any element of C has the same cardinality as that of F
07:23:38 <ski> rwbarton,dmwit : elaborate on where that sentence went wrong ? -- i can't see it atm
07:23:42 <rwbarton> but it can't be represented by a because it is different from F
07:23:45 <zzing> What is the base version I need to use to specify haskell2010 in cabal?
07:24:04 <nand`> rwbarton: should it be accurate if I change my ‘iff’ to an implication instead?
07:24:07 <dmwit> ski: Sorry, what sentence went wrong?
07:24:10 <rwbarton> one direction yes
07:24:21 <nand`> rwbarton: I see, thanks
07:24:23 <ski> dmwit : "\"free Foo over Bar\" means the free Foo generated from Bar"
07:24:43 <dmwit> ski: Oh, it wasn't wrong. It just couldn't possibly be helpful to anybody who didn't already know what "free Foo over Bar" meant.
07:25:11 <dmwit> I mean, changing "over" to "generated from" isn't enlightening.
07:25:24 <ski> dmwit : well, i was about to attempt to explain what i meant more specifically by it, when it appeared you and rwbarton were claiming it was incorrect
07:25:39 <dmwit> Oh, man, I'm really sorry to have interrupted you, then.
07:25:40 <lillis> it seems in haskell a general rule is to avoid parentheses when possible - is this a correct observation?
07:25:45 <nand`> “free Monoid over ∅” for me would mean ({[]}, [], ++), a trivial monoid
07:25:55 <rwbarton> (oh, my "not quite" wasn't directed at you, ski)
07:25:57 <nand`> lillis: not necessarily
07:26:15 <nand`> lillis: sometimes parentheses would be clearer or nicer than their alternatives
07:26:29 <nand`> for example, instead of f $ g . z I like to write f (g . z)
07:26:44 <ski> rwbarton : for confirmation, was "not quite","that would be represented by a different monoid" a reply to "\"free Foo over Bar\" means the free Foo generated from Bar"; and in that case, what's the difference ?
07:26:46 * merijn would actually use the former there
07:26:46 <lillis> i don't know what $ and . mean yet, but i'm sure i'll get there soon..
07:26:51 <lillis> nand` ^
07:26:55 <ski> rwbarton : oh, ok
07:27:09 <nand`> lillis: well, a rule of thumb is “go with what looks the cleanest and is the easiest to understand”
07:27:19 <however> lillis: personally i try to be as clear as possible. often that means removing redundant stuff, but sometimes it also means putting in redundant parens just to be absolutely clear
07:27:31 <dmwit> zzing: base isn't haskell2010; haskell2010 is haskell2010
07:27:33 <lillis> nand`: that's how i feel in general too
07:27:33 <merijn> lillis: Assuming you know the lambda syntax already: "f . g = \x -> f (g x)"
07:27:35 <nand`> sure, if you can put something into some ridiculous point free format that uses zero parentheses that's nice for you but it may be much harder to understand
07:27:48 <nand`> than a simple f x = -(x + 2) or so
07:28:01 <dmwit> zzing: In other words, you should specify one of haskell98, haskell2010, or base as a dependency of your project.
07:28:10 <nand`> or (x + 2)^3 to provide a better example (the former would probably be clearest with ‘negate’ )
07:28:12 <merijn> Or put differently "(f . g) x = f (g x)"
07:28:14 <ski> dmwit : anyway, i see you did take the explanations in the direction i had meant to do, so no big harm :)
07:28:53 <lillis> merijn: I know the lambda syntax, but I'm not sure what the point of the period is - just a quicker/cleaner syntax?
07:28:54 <merijn> lillis: And even simpler "f $ x = f x", the use of this is that function application binds tighter than operators (and $ has the lowest possible operator priority)
07:28:57 <dmwit> I apologize again anyway.
07:29:14 <merijn> lillis: It can make maps look very clean for example
07:29:28 <weexplat> conal: you could iterate a finite map if you can enumerate the domain
07:29:32 <lillis> merijn: so f $ f' x is identical to f (f' x) ?
07:29:33 <nand`> lillis: . is nice when you're composing functions
07:29:38 <nand`> merijn: yes
07:29:39 <merijn> lillis: Yes
07:29:42 <nand`> err
07:29:46 <zzing> dmwit: ok, I was misreading the error output
07:29:49 <lillis> so many names!
07:29:52 <nand`> meant to reply to lillis :(
07:29:56 <halo> halo
07:30:05 <lillis> halo: halo!
07:30:28 <nand`> lillis: for example heapsort = unheapify . heapify; instead of heapsort xs = unheapify (heapify xs)
07:30:28 <mcstar> fragged himself
07:30:52 <lillis> nand`: this seems like some sort of implicit paremeter
07:30:58 <merijn> :t ord
07:30:59 <lillis> reminds me of perl for some reason
07:30:59 <lambdabot> Char -> Int
07:31:06 <lillis> parameter*
07:31:10 <merijn> :t map (negate . ord)
07:31:11 <lambdabot> [Char] -> [Int]
07:31:12 <however> lillis: "." is slightly like a backwards version of "|" in the shell. "cat something | grep" means to take cat's output and shove it into grep. "f . g" means to take g's output and shove it into f
07:31:20 <nand`> lillis: it's nothing of the sort
07:31:25 <nand`> lillis: (.) is a function
07:31:37 <lillis> however: now THAT makes total sense, being a unix user :) thanks
07:31:41 <merijn> lillis: Just ponder it's type for a sec
07:31:45 <merijn> :t (Prelude..)
07:31:46 <dmwit> ?src (.)
07:31:46 <lambdabot> (f . g) x = f (g x)
07:31:46 <lambdabot> NB: In lambdabot,  (.) = fmap
07:31:47 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:31:47 <nand`> lillis: heapsort = (.) unheapify heapify; it's a function that takes two functions and returns a new function, and you define heapsort to be this function
07:32:09 <lillis> and it can be used infix
07:32:10 <lillis> i see
07:32:15 <nand`> lillis: this is a general idea in functional programming - you treat functions as so called “first class values”, values as anything other. There's nothing implicit about transforming functions themselves
07:32:35 <however> lillis: you're welcome. about perl's implicit parameters, it may look similar, but it works differently
07:33:02 <nand`> there's a backwards version of (.), incidentally. It's called (>>>)
07:33:10 <nand`> heapify >>> unheapify = unheapify . heapify
07:33:13 <lillis> "f . g = \x -> f (g x)" <- this confuses me though, in the lambda there's x imput, but in the f . g -- where's the input?
07:33:31 <nand`> lillis: you're defining (.) in this line
07:33:36 <lillis> ooh
07:33:38 <lillis> of course
07:33:41 <lillis> that wasn't a ==
07:33:42 <mcstar> :t (.)
07:33:43 <nand`> (.) f g = -- like any other function
07:33:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:33:45 <nand`> yes
07:33:54 <lillis> RIGHT.
07:33:58 <nand`> well, you could define Eq on some functions if you're funny
07:34:02 <nand`> and then compare functions via == :P
07:34:11 <mcstar> @type (.)
07:34:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:34:13 <nand`> but I don't know of any serious application that uses that
07:34:26 <dmwit> Still, I can't help but wonder if there's a bit of confusion left here.
07:34:29 <lillis> nand`, however, merijn: thanks a lot, i think i do get it now
07:34:30 <EvanR> nand`: ive been looking for that backwards version of .
07:34:36 <dmwit> A thing doesn't need to have a lambda at the front to be a function.
07:34:50 * ski ponders visualizing the reduction steps of merge-sort, "quick"-sort, and heap-sort
07:35:27 <dmwit> Your question, "in the lambda there's x input, but in f . g -- where's the input?", suggests that you haven't (yet) internalized this.
07:35:28 <however> ski: i think there's some animated gifs around for that, possibly on wikipedia ...
07:35:32 <mcstar> when ski suddenly invents the Quick Heap Merge Sort - Ski Sort
07:35:34 <tgeeky> ski: !
07:35:37 <nand`> ski: I think the best way to “visualize” a sorting algorithm is to write a version in Haskell that works on some ADT; it's usually much much less complex than the imperative in-place versions given on wikipedia and such
07:35:42 <nand`> well, this is not visualizing
07:35:43 <nand`> but it helps a lot
07:35:50 <conal> weexplat: are you referring to total-map (following yesterday's conversation)?
07:36:11 <ski> however : hehe, in some Haskell-like syntax (any of Clean,SML,O'Caml,Erlang,Scheme would also work fine) :)
07:36:25 <ski> (,Mercury)
07:36:40 <nand`> wikipedia has some gifs of sorting algorithms floating around, but I don't think they're particularly useful
07:36:50 <nand`> they just show the operation, nice to watch; but hard to understand because they're fast and in-place
07:37:25 <mcstar> i dont think you understand sorting, before you write each one yourself
07:37:36 <nand`> though there are exceptions
07:37:48 <mcstar> (except bogosort, thats trivial)
07:37:49 <nand`> https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif is a nice example of quicksort I think
07:38:05 <nand`> and there's https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif for merge sort
07:38:10 <nand`> ski: there's also a “merge sort dance”
07:38:13 <nand`> quite funny
07:38:21 <ski> nand` : i mean, i think the Craft has some pretty pictures of Haskell expressions (drawn as trees, iirc), showing how merge-sort reduces
07:38:33 <tgeeky> ski: https://github.com/technogeeky/pearl-sorting-with-bialgebras/blob/master/src/Pearl/SWB/Section07.hs
07:39:12 <nand`> mcstar: understanding how a sorting algorithm is defined is much easier than understanding *why* it works (with its given efficiency)
07:39:25 <dmwit> Paws, really?
07:40:05 <tgeeky> dmwit: yes!
07:40:06 * ski now recalls writing sorting visualizations of bubble-sort,insert-sort,swap-sort,shell-sort on a Casio calculator many years ago ..
07:40:11 <tgeeky> dmwit: Pause has too many letters :O
07:40:47 * ski . o O ( `XF86AudioPause' has more of them )
07:40:51 <tgeeky> dmwit: all of those things should be type operators, but I didn't want to do them at the same time
07:40:59 <c_wraith> I liked that the pause button in old lemmings game was an iconographic representation of a paw print
07:41:16 <tgeeky> dmwit: you're very picky when it comes to my cutesey renaming :O
07:41:18 <ski> lemmings :D
07:41:45 <nand`> tgeeky: is this the kind of code that requires knowing what a zygohistomorphic prepromorphism is to understand?
07:41:50 * ski . o O ( "ohno !" )
07:41:53 <tgeeky> nand`: nope!
07:42:05 <tgeeky> nand`: all you need to understand is   apo and para morphisms
07:42:17 <dmwit> tgeeky: Pfft, that's nothing, wait until you hear what I'm thinking about your whitespace.
07:42:17 <nand`> tgeeky: I see. One day I'll get to them :)
07:42:29 <lillis> dmwit: http://hpaste.org/70814
07:42:33 <lillis> dmwit: am i getting it?
07:42:35 <tgeeky> dmwit: that's spacially racist!
07:43:06 <dmwit> lillis: Only you can answer that. =)
07:43:06 <tgeeky> nand`: pretty easy stuff, I thought. paramorphisms give you the ability to signal to recursion to stop
07:43:27 <lillis> dmwit: I think I am, but your comment made me go back and reread what people said, in turn making me realise I wasn't getting it
07:43:30 <dmwit> async looks like just what I wanted in yeganesh.
07:43:31 <lillis> But now I am - so thanks!
07:43:39 <ski> dmwit : what ?! tgeeky's whitespace there is *just fine*, tyvm
07:44:09 <tgeeky> ski: hehe. it's not my worst work, in that sense
07:44:11 <nand`> tgeeky: “A paramorphism is an extension of hte concept of catamorphism to deal with a form which ‘eats its argument and keeps it too’” <- is a Y combinator a paramorphism?
07:44:29 <tgeeky> nand`: bah!
07:44:30 * ski apparently has found a kindred spirit
07:44:31 <tgeeky> i got it backwards!
07:44:41 <mcstar> lillis: it isnt a pipe, it is composition
07:44:49 <dmwit> ski: Line 50 looks especially arbitrary, but otherwise seems reasonable. My biggest complaint is no tabs. ;-)
07:44:57 <tgeeky> ski: paramorphism is the categorical version of haskell's @ pattern
07:45:10 <ski> dmwit : you want tabs ?
07:45:20 * dmwit likes tabs
07:45:36 <tgeeky> i like tabs, but I'm too stupid to make sure I get the right with my current editor setup, so I make them all spaces
07:45:42 * ski will keep tabs on dmwit from now on
07:45:45 <dmwit> But we should maybe take it to #haskell-blah, that topic tends to get a bit... far from Haskell in here3.
07:46:08 <lillis> mcstar: Roger roger
07:46:12 <tgeeky> ski: anyway, paramorphisms are like as patterns:    wholelist@(first:second:third:fourthelement)
07:46:26 <nand`> I don't like tabs, because tabs should always be displayed with 8 spaces and 8 spaces is too much indentation for my puny screen to handle. dmwit: I think Haskell stylistic issues are Haskell-related
07:46:27 <dmwit> mcstar: Pipe, composition, what's the difference?
07:46:35 * ski sometimes uses tabs at the end of a code line, to get comments to align with less effort ..
07:46:39 <ski> .. am i a heathen ?
07:46:50 <dmwit> nand`: In that case... tabs should not be used in places where their size matters.
07:46:59 <dmwit> ski: Yes, that's horrible.
07:47:11 <nand`> dmwit: yes, that is a good philosophy
07:47:15 * ski also uses form feeds to separate sections of code
07:47:32 <nand`> dmwit: what do you think on flexible tabstops (now this is truly getting offtopic)
07:47:36 <dmwit> On that I have no opinion, because I've never even seen it done. Sounds reasonable, though!
07:47:38 <mcstar> dmwit: the direction of the flow
07:47:44 <ski> (.. and of course the whole of the body of the module is indented two spaces)
07:47:49 <dmwit> nand`: The guy who proposed them was on the right track, but didn't take it far enough.
07:48:29 <dmwit> nand`: (Did you mean "elastic tabstops"?)
07:48:31 <ski> nand` : where would they be specified for particular files ?
07:48:42 <dmwit> nand`: (Or is this a new idea?)
07:48:48 <nand`> dmwit: I meant elastic tabstops, yes
07:49:53 <however> dmwit: interesting ... why isn't it far enough?
07:49:56 <nand`> ski: I think the idea is for editors to automatically convert to/from elastic tabstops when loading/saving a file, the file itself having whitespace instead
07:50:10 <tgeeky> nand`: I think the opposite.
07:50:14 <nand`> ski: but I think maybe some unicode markers to control tabstop group separators *might* work.
07:50:42 <dmwit> however: Because, for example, you can't align things two lines apart if the intervening line doesn't have as many tabs.
07:51:02 <tgeeky> this really needs to be in #-blah
07:51:03 * tgeeky goes
07:51:10 <HugoDaniel> my attoparsec parsers are so basic that they make me feel im in 2nd grade again
07:51:22 <however> dmwit: hm right
07:51:51 <dmwit> however: Similarly, two adjacent lines with the same number of tabs will always align, which isn't always right.
07:52:18 <dmwit> You just plain need more control than something automatic can give you.
07:54:12 <ski> nand` : maybe you want one to be able to embed `HTS',`VTS',`TBC' (and not just `TAB' and `VT') in the file, and $EDITOR would DTRT ?
07:54:24 <ski> is that what you mean by "elastic tabstops" ?
07:54:46 <dmwit> ski: -blah
07:55:06 <ski> tgeeky : hm, not sure why you're telling me about paramorphisms :)
07:55:56 <nand`> ski: I think he meant to reply to me, since I (implicitly) asked about them
07:56:08 <eikke> what's my best bet to be able to xor 2 wordN vectors pairwise, and get SIMD-based output? which library to use?
07:56:16 <nand`> eikke: Data.Bits?
07:56:34 <nand`> > 3 xor 7 :: Word8
07:56:35 <lambdabot>   Ambiguous type variable `a' in the constraint:
07:56:35 <lambdabot>    `Data.Bits.Bits a'
07:56:35 <lambdabot>      a...
07:56:46 <eikke> nand`: that's for single values
07:57:03 <tgeeky> ski: the original question/comment was something about visualising heapsort
07:57:04 <nand`> oh, my bad
07:57:09 <nand`> I overlooked ‘vectors’
07:57:34 <tgeeky> ski: since I had just written a heapSort, I figured I'd share.
07:58:13 <eikke> nand`: np :)
07:58:22 <dmwit> eikke: C
07:58:43 <nand`> eikke: or I think you meant wordN ‘bit vectors’
07:58:54 <nand`> I thought*
07:59:20 <eikke> dmwit: ok, too bad
08:00:48 <ski> tgeeky : oh .. i didn't notice that defined a heap-sort
08:00:56 <dmwit> From Google, there seems to be some work going on to get SIMD stuff happening in GHC, but I'm pretty sure it hasn't shipped yet.
08:01:13 <nand`> there's ‘repa’ which currently isn't polymorphic though
08:01:17 <ski> (neither that it used `para')
08:01:17 <nand`> and has a lot of other limitations
08:01:40 <dmwit> I don't believe repa does SIMD.
08:01:59 <nand`> oh, I don't mean repa
08:02:01 <nand`> I meant something else
08:02:09 <eikke> I think there's some repa/simd work in some branch somewhere
08:02:28 <dmwit> DPH doesn't do SIMD, either, which is the other thing you might be thinking of.
08:02:28 <tgeeky> ski: yes. and a quicksort and mergesort in the previous chapter, and insertsort and bubble sort in the previous
08:02:33 <tgeeky> ski: all using the same techniques
08:02:35 <dmwit> There's a GHC branch for SIMD stuff, yes.
08:03:06 <dmwit> Google suggests http://ghc-simd.blogspot.com/2012/04/adding-simd-support-to-data-parallel.html
08:04:04 <eikke> yup, saw that before
08:04:28 <ski> hm, that link turns up blank here
08:06:09 <nand`> dmwit: I was thinking of DPH. I thought DPH does SIMD? xor_word8 :: [:Word8:] -> [:Word8:] -> [:Word8:]; xor_word8 xs ys = [:xor x y | x <- xs | y <- xs:]  -- looks to me like SIMD, or am I misunderstanding how SIMD works?
08:07:49 <dmwit> nand`: You are misunderstanding. Things can happen in parallel without taking advantage of SIMD instructions.
08:07:59 <mcstar> question is whether or not that gets translated to SSEN instructions
08:07:59 <nand`> dmwit: oh, you meant SIMD processor extensions?
08:08:03 <dmwit> yes
08:08:06 <nand`> I see
08:08:13 <dmwit> SIMD stands for single-instruction multiple-data
08:08:13 <nand`> I thought eikke just meant parallel vectors in general
08:08:34 <Axman6> Repa should get a fair amount of SIMD for free once GHC supports LLVM 3.1, which has a basic block vectoriser
08:08:56 <aetoxx> Is there any IDE for Haskell which provides completion based on some GHC API?
08:09:15 <tgeeky> all of them that provide it?
08:09:37 <aetoxx> tgeeky, are you talking to me?
08:09:56 <tgeeky> aetoxx: I think so.
08:10:17 <tgeeky> aetoxx: the GHC API is the obvious way to interface automatically with Haskell
08:10:27 <aetoxx> tgeeky, then I don't understand how you answered my question.
08:10:29 <tgeeky> so check each editor and editor-support-package
08:10:41 <tgeeky> and see if it does this automatically or manually or not at all
08:11:11 <rwbarton> I think the point of asking the question was to not have to do that.
08:11:24 <aetoxx> rwbarton, you get a cookie.
08:11:47 <tgeeky> rwbarton: yes, but I suspected he/she would get no answer
08:11:48 <Axman6> tgeeky: your answer was kind of a non-answer
08:12:11 <aetoxx> Which IDE has completion working out of the box and/or with some very easy modification?
08:12:12 <rwbarton> I'm going to charitably assume tgeeky was focused on the "based on some GHC API" part of your question
08:12:21 <tgeeky> rwbarton: hehe :)
08:12:23 <geekosaur> aetoxx, there are a number of things around, the things most likely to be what you seem to be looking for are the eclipsefp plugin and leksah.  there are various things for emacs and nvi that interface with the ghc-api to provide completion etc. although I dont know their current state
08:12:43 <tgeeky> rwbarton: but by making a snarky comment I did get people involved :o
08:12:45 <tgeeky> perhaps
08:12:58 <rwbarton> perhaps
08:12:58 <eikke> Axman6: good point... should look into what 3.1 and Poly do
08:13:04 <mcstar> what does it mean ghc api here? dont they just look at the source?
08:13:13 <mcstar> or documentation?
08:13:47 <dmwit> The GHC API lets you avoid writing your own code to look at source.
08:13:51 <Axman6> polly is pretty fragile afaik. it's not shipped with LLVM for a reason. a very cool project though
08:13:53 <dmwit> By asking GHC to look at source for you.
08:13:58 <geekosaur> mcstar, that assumes you have source or documentation for your libraries installed.  but if they're usable libraries, the .hi files *are* installed and ghc-api can be used to introspect types etc.
08:14:01 <dmwit> GHC is pretty good at looking at source.
08:14:09 <aetoxx> Looking at source is too slow for interactive use.
08:14:18 <aetoxx> (which is exactly why GHC does it)
08:14:28 <geekosaur> or to compile source to internal form etc., yeh
08:14:49 <mcstar> geekosaur: how does this happen? is there a binary that ghc provides that queries the .hi files?
08:14:56 <eikke> Axman6: this is just looking around, trying to get as close to our hand-rolled C implementation using more high-level constructs only
08:15:10 <dmwit> mcstar: There is a library. It's called the GHC API.
08:15:10 <geekosaur> let's phrase it this way:  do you prefer to have your IDE be its own most-of-a-haskell-compiler, or that it ask the haskell compiler to figure it out?
08:15:18 <geekosaur> ^^
08:15:29 <Axman6> eikke: what're you working on? I haven't been following the discussion
08:15:34 <aetoxx> geekosaur, I don't think anyone cares about that.
08:15:39 <aetoxx> geekosaur, as long as it works.
08:15:50 <geekosaur> if you do ghc-pkg list, you'll find one of the things is a library named ghc.  that's the compiler itself as a library, aka ghc-api
08:15:57 <tgeeky> to find the GHC api: go to haddock, search for "base library" and search in reverse. it'll be the first result.
08:16:17 <geekosaur> aetoxx, they care indirectly, for one reason:  having the compiler do it is the only way that is (a) sane (b) reliable
08:16:30 <eikke> Axman6: there was no prior discussion ;-) Basically, given a vector of bytestrings (or one large vector, or a vector of wordNs, or whatever), xor a random selection of these vectors together into a single output
08:16:41 <tgeeky> geekosaur: not the only way, but it's by lightyears the fastest way
08:16:43 <dmwit> If it works, nobody cares. But the easiest and most correct way to make it work is to call the compiler.
08:16:49 <geekosaur> there *are* IDEs that try to do it other ways to avoid the ghc api.  oddly enough they often fail in the presence of extensions and such, and are therefore not really usable IDEs
08:17:59 <tgeeky> and the other problem with the original question is what they mean by completion (that is, if they mean suggestion instead of word-completion)
08:18:24 <tgeeky> I doubt any of them give auto-suggestion for the next term?
08:18:25 <aetoxx> tgeeky, I am sorry, but everyone but you understood the question.
08:18:30 <eikke> Axman6: foldr1 (\a b -> BS.pack $ BS.zipWith xor a b) (cs :: [ByteString])
08:18:54 <eikke> (that's the basic idea, but very inefficient, obviously, I don't need the list etc)
08:19:04 <tgeeky> aetoxx: I understand it, but I don't think any of the editors I've tried (I've tried all of them except Eclipse + this new stuff), had any of the features like you expect with an OOP langauge
08:19:32 <mcstar> tgeeky: good point, wanted to say myself, with classes and methods, a great deal can be 'completed'
08:19:43 <Axman6> eikke: don't use foldr for that. at the very least you want a foldl, and probably foldl'
08:19:58 <dmwit> eikke: Sorry, what?
08:20:04 <dmwit> eikke: For xor, surely you don't need SIMD.
08:20:14 <dmwit> xor is already data-parallel.
08:20:22 <eikke> Axman6: sure, that's just to show the general idea
08:20:30 <eikke> dmwit: how so?
08:20:50 <Axman6> eikke: have you tried using foldl1'? it might actually not be too bad...
08:20:53 <dmwit> xor :: Word -> Word -> Word *is* the machine-word parallel version of xor :: Word8 -> Word8 -> Word8
08:21:00 <rwbarton> the SIMD registers are bigger though, possibly you can still get more throughput using them
08:21:05 <dmwit> aha
08:21:12 <eikke> rwbarton, dmwit: that's the idea
08:21:15 * rwbarton has never actually tried
08:21:20 <Axman6> does x86(64) have SIMD xor?
08:21:30 <rwbarton> probably?
08:22:14 <Axman6> pxor
08:22:24 <Axman6> according to http://courses.engr.illinois.edu/ece390/books/labmanual/inst-ref-simd.html
08:22:25 <eikke> xorps and pxor
08:22:43 <rwbarton> "Performs a bitwise logical exclusive-OR of the two packed double-precision floating-point values in the source operand (second operand) and the destination operand (first operand)"
08:22:43 <Catnaroek> What C preprocessor does Haskell use by default? :O
08:22:43 <HugoDaniel> the thing with simd is that packing and unpacking can take longer than the actual operations
08:22:49 <HugoDaniel> and be the real overhead
08:22:50 <rwbarton> I think we need to have a talk about types.
08:22:57 <HugoDaniel> sometimes turning slower if not done properly
08:22:59 <Catnaroek> s/Haskell/GHC/
08:23:23 <Axman6> rwbarton: yeah, I cringed. that's awful
08:23:45 <mcstar> geekosaur: i still dont fully understand the mechanism, for exmaple in common lisp, the runtime is loaded, and runs, and the editor is interfaced with the runtime, and can present any number of information for the user, documentation, parametrization, reflection.., how does this work in haskell? does the editor need to 'compile the ghc api' somehow? or ghc provides a binary, that can query the .hi files that
08:23:47 <mcstar> are installed?
08:24:07 <Catnaroek> @pl map (:"")
08:24:07 <lambdabot> map return
08:24:34 <dmwit> mcstar: Usually "binary" means "executable". Thtere is no executable. There is a library.
08:24:35 <Axman6> though I imagine that pxor with 0x8000000000000000 would be a pretty effective way of negating doubles if you don't care about NaNs
08:24:40 <geekosaur> mcstar, there are ways to dump the type information in .hi files, but more common is to use something like scion
08:25:27 <geekosaur> dmwit, scion kinda denies your claim there :p it's an executable that exposes the ghc-api for use by IDEs
08:25:45 <geekosaur> it's the interface used by vim, emacs, and I think eclipsefp
08:25:54 <dmwit> Okay, okay. I claimed the wrong thing.
08:25:57 <mcstar> geekosaur: ok, now it makes sense
08:26:48 <geekosaur> basically there is a library.  an editor could link against the library directly (I think yi is going this way) or it could use a program which is linked against the library (viz. scion)
08:28:02 <Axman6> cabal: cannot configure scion-0.1.0.2. It requires ghc >=6.10 && <6.12
08:28:04 <Axman6> :(
08:28:21 <mcstar> geekosaur: can i link a C object code with one from haskell naively?
08:28:45 <geekosaur> it's easier to call C from Haskell than Haskell from C but both are possible
08:29:16 <Axman6> is it actually easier? I thought you just had to effort the function, assuming it takes take input types
08:29:24 <geekosaur> so, naive haskell from C is not really possible since you need to initialize the IO/thread/event manager etc.
08:29:32 <dmwit> Axman6: You also have to start the GHC runtime.
08:29:44 <Axman6> right
08:29:48 <dmwit> It's an extra function call, that's all.
08:29:56 <Axman6> but that's not much more difficult
08:29:58 <geekosaur> I thought scion was being kept up to date, sorry.  wonder which one I'm thinking of, then; I know at one point htere were several IDE helpers out there
08:29:58 <Axman6> yeah
08:30:36 <mcstar> the clipse plugin needs scion
08:30:39 <mcstar> e
08:30:51 <mcstar> but emacs doesnt afaik
08:31:08 <DMcGill> so the default Show instance for newtypes still prints the name of the newtype right?
08:31:14 <DMcGill> the constructor I mean
08:31:15 <geekosaur> emacs doesn't require it but can use it
08:31:19 <mcstar> also, what emacs provides wrt completion is not extraordinary
08:31:32 <geekosaur> also it looks like the last release on hackage is ancient but the github version is up to date?
08:31:53 <geekosaur> emacs works from the documentation and from emacs' own "parser" by default
08:32:17 <mstrlu> The program used in eclipse-fp is called ``scion-browser''
08:32:20 <geekosaur> the haskell-mode stuff has the ability to use, not enabled by default, in the most recent versions
08:32:42 <bobopacera> lo
08:33:15 <morel> hi bobopacera
08:33:16 <nand`> when I tried it, the hardest part in calling Haskell from C was compiling the Haskell module as a dynamic library
08:45:33 <dmwit> DMcGill: Yes, the rule of thumb for Show instances is that they should produce Haskell code that produces the current value.
08:47:39 <nand`> eval :: Read a => String -> a -- I wonder how well this would fit into that analogy
08:47:43 <nand`> s/analogy/model/
08:47:48 <nand`> s/model/rule of thumb/
08:49:17 <dmwit> Badly.
08:49:27 <dmwit> read doesn't really do evaluation.
08:49:44 <dmwit> e.g. it won't do "3 + 4" or "nub [3..5]" or anything like that.
08:50:20 <dmwit> Only a very small subset of all valid Haskell code can come out of show. =)
08:51:44 <nand`> dmwit: I was half-joking, I think that didn't come across very well
08:52:12 <yitz> dmwit: otoh, unfortunately, due to plenty of Show instances not following the rule of thumb in practice, plenty of non valid Haskell code can come out of show, too.
08:52:34 <dmwit> yitz: Does "in practice" mean "on Hackage"?
08:52:38 <dmwit> (Do you have some examples?)
08:52:41 <yitz> dmwit: i guess so
08:52:41 <nand`> dmwit: I think I rather meant read :: String -> IO (Maybe a)
08:53:30 <yitz> dmwit: not off hand, just dull memories of past pain
08:54:20 <yitz> dmwit: well, here's one: the Show instance for Text only satisfies the rule of thumb in the presence of -XOverloadedStrings.
08:55:01 <MostAwesomeDude> Man, I wish I could break halfway through do blocks. I know I can't, but still.
08:55:16 <yitz> MostAwesomeDude: you can, in the right monad
08:55:24 <Philonous> MostAwesomeDude:  ContT for the win!
08:55:39 <yitz> or, more simply, EitherT.
08:55:44 <nand`> MostAwesomeDude: MonadPlus
08:55:45 * hackagebot Glob 0.7.1 - Globbing library  http://hackage.haskell.org/package/Glob-0.7.1 (MattiNiemenmaa)
08:55:58 <MostAwesomeDude> Well, I'm clearly not in the right monad.
08:56:13 <nand`> mzero >>= f = mzero
08:56:19 <yitz> you can do it in IO, too. (ducks)
08:56:34 <otters> where is the config.log that cabal refers to? :|
08:56:40 <dmwit> yitz: That's a pretty good example.
08:56:51 <MostAwesomeDude> Waait, you can guard and such in IO?
08:56:54 <nand`> dmwit: IO? or Text? :P
08:57:44 <yitz> MostAwesomeDude: no. but you can call exit from System.Exit.
08:57:48 <nand`> MostAwesomeDude: mzero in IO calls error it seems
08:58:01 <MostAwesomeDude> Well, let's avoid that then.
08:58:05 <yitz> nand`: yeah error would do it, too.
08:58:07 <keseldude> you can catch errors
08:58:13 <Philonous> MostAwesomeDude:  IO has exceptions for non-local control flow
08:58:33 <MostAwesomeDude> I mostly just want to be able to "end" a handler early, inside a Pipe. This is fun with conduits.
08:59:12 <dmwit> nand`: eh?
08:59:29 <dmwit> Oh. Text
09:00:12 <dmwit> I'd be tempted to say it's a bug that Text's show instance doesn't have fromString at the beginning.
09:00:25 <yitz> MostAwesomeDude: right, that's a fundamental difference between pipes and conduits. conduits were designed for that.
09:00:44 <dmwit> ?hoogle IsString
09:00:44 <lambdabot> Data.String class IsString a
09:00:44 <lambdabot> GHC.Exts class IsString a
09:00:47 * hackagebot xml-picklers 0.2.1 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.2.1 (PhilippBalzarek)
09:00:50 <yitz> MostAwesomeDude: for pipes, you have to use something like "monadic regions", not sure how that works (and if it even really does in practice).
09:01:24 <MostAwesomeDude> yitz: They are? How would I do this in conduits? AFAICT the closest I can get is to just navigate around calling yield.
09:02:00 <pcapriotti> MostAwesomeDude: which pipes are you using? what's your problem exactly?
09:02:45 <MostAwesomeDude> pcapriotti: I'm using conduits. network-conduits and cereal-conduits. I have a loop wherein I await some data, and then yield zero or more pieces of data in response.
09:03:08 <MostAwesomeDude> pcapriotti: And I'm mostly just bemoaning the fact that I can't just stop halfway through a do block and say "Welp, the client's sent us crap data; I want out."
09:03:26 <yitz> MostAwesomeDude: use exceptions for that, i think
09:03:27 <Guest71591> MostAwesomeDude: you just need the right monad
09:03:41 <Guest71591> ExitT, MaybeT
09:03:47 <Guest71591> or something
09:04:21 <MostAwesomeDude> EvanR: The monad I'm currently carrying around is StateT SessionState IO, where SessionState's just a record.
09:04:41 <nand`> ...wow, I just noticed #haskell's topic is a list. That is quite amusing
09:05:01 <yitz> nand`: a finite one, though, unfortunately
09:05:11 <nand`> damn IRC limitations
09:05:27 <EvanR> MostAwesomeDude: you can add another transformer which lets you cancel early
09:05:34 <Taneb> nand`: #dwarffortress's topic is a legendary artifact
09:05:51 <ClaudiusMaximus> jfischoff: surely it's possible to separate rules from filesystem in shake and thus craete rules that always run - but i've not done it in anger - maybe check the documentation on hackage?
09:06:02 <jfischoff> how about clean
09:06:03 <jfischoff> ?
09:06:10 <jfischoff> that's pretty much what I want
09:06:18 <MostAwesomeDude> EvanR: Well, I need to keep the state around in order to tell everybody who cares about the failure, so I really didn't want to EitherT or MaybeT.
09:06:36 <EvanR> you still have the state
09:06:58 <Taneb> StateT SessionState (EitherT whatevs IO) ?
09:06:59 <mstrlu> MostAwesomeDude: Return the state in Left, perhaps?
09:07:28 <ClaudiusMaximus> jfischoff: the docs suggest """Put all result files in a distinguished directory, for example _make. You can implement a clean command by removing that directory, using removeDirectoryRecursive. """
09:07:32 <MostAwesomeDude> Ow.
09:07:41 <EvanR> type synonym ftw
09:07:52 <MostAwesomeDude> At some point, I'll get comfortable with large stacks. Today's not that day though.
09:07:53 <yitz> MostAwesomeDude: i would ask snoyberg, who works here, but he left already for today. try tomorrow. :) or ask on the web-devel list or #yesod
09:08:04 <dmwit> nand`: Not only that, lambdabot has ?topic-cons and ?topic-snoc commands.
09:08:22 <MostAwesomeDude> yitz: Is he ever actually in here?
09:08:27 <ski> @list topic
09:08:27 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
09:08:37 <dmwit> ?topic-null
09:08:37 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
09:08:43 <dmwit> what
09:08:43 <MostAwesomeDude> Well, actually, he must just be in another part of the world; it's early in the morning here.
09:08:46 <cesip> the hell...
09:08:46 <yitz> MostAwesomeDude: sometimes, but not too often. he's not much of an irc person.
09:09:01 <ski> @help topic-null
09:09:01 <lambdabot>  @topic-null #chan -- Clear out the topic entirely
09:09:05 <dmwit> oh
09:09:14 <nand`> dmwit: neat
09:09:16 <MostAwesomeDude> yitz: Ah, then I just gotta send off an email.
09:09:55 <cesip> i have a simple sorting function that sorts a list of pairs of ints and strings. when sorting a longer testing list, one element disappears. i locate the element that disappears (it occurs 2x in the list), i make a very short list containing 2x this element. the sorting function works.
09:10:06 <cesip> grrr?
09:10:26 <MostAwesomeDude> cesip: Why not use the builtin sorting function?
09:10:55 <cesip> MostAwesomeDude, it's just a programming assignment
09:11:10 <yitz> > sort [(1, "foo"), (1,"bar"), (2,"aaa")]
09:11:12 <lambdabot>   [(1,"bar"),(1,"foo"),(2,"aaa")]
09:11:32 <jfischoff> ClaudiusMaximus: Still doesn't answer my question. How do I make the clean task? Do I use 'want'?
09:12:33 <ClaudiusMaximus> jfischoff: i think the idea is that you don't use shake to clean?  just remove the dir?
09:12:59 <jfischoff> ClaudiusMaximum: you are correct sir. Neil just confirmed that
09:13:02 <jfischoff> via email
09:13:04 <ClaudiusMaximus> cesip: maybe you could try to prove that   length . yoursort = length   for all inputs, and see where your proof breaks
09:13:44 <ClaudiusMaximus> jfischoff: cool (sorry it took so long to reply on irc, but i was asleep)
09:14:04 <jfischoff> ClaudiusMaximus: you bastard! ;)
09:14:56 <ClaudiusMaximus> > sortBy (\_ _ -> GT) "not sure what happens if your comparison is broken"
09:14:58 <lambdabot>   "nekorb si nosirapmoc ruoy fi sneppah tahw erus ton"
09:15:28 <cesip> ClaudiusMaximus: good idea!
09:15:33 <ski> ClaudiusMaximus : presumably the behaviour is unspecified (different implementations are allowed to do different things)
09:15:57 <ClaudiusMaximus> ski: yeah, but it's interesting to poke it to see what actually happens :)
09:16:23 <ski> > sortBy (\c0 c1 -> if c0 == c1 then EQ else GT) "not sure what happens if your comparison is broken"
09:16:25 <lambdabot>   "nekoorb si nosirapmc ruoy fi sneppaahh tw erus ton"
09:16:28 <ski> > sortBy (\c0 c1 -> if c0 == c1 then EQ else LT) "not sure what happens if your comparison is broken"
09:16:29 <lambdabot>   "not sure what happens if your comparison is broken"
09:16:59 <dmwit> cesip: You could also try writing a quickcheck test and asking it to minimize your counterexample.
09:17:33 <ski> (probably nicer to at least pass a `compare' where `forall a0 a1. a0 == a1 = True => compare a0 a1 = EQ')
09:18:08 * ski should probably sleep, has an uptime of more than a circadian rhythm ..
09:18:41 <yitz> > sortBy (\_ _ -> GT) . sortBy (\_ _ -> GT) $ "not sure what happens if your comparison is broken"
09:18:44 <lambdabot>   "not sure what happens if your comparison is broken"
09:20:08 <ClaudiusMaximus> @check \(Blind cmp) xs -> length (sortBy cmp xs) == length (xs :: String)
09:20:10 <lambdabot>   Not in scope: data constructor `Blind'
09:20:12 <yitz> @check \xs ->  sortBy (\_ _ -> GT) xs == reverse xs
09:20:14 <lambdabot>   "OK, passed 500 tests."
09:20:41 <ClaudiusMaximus> @check \(Test.QuickCheck.Blind cmp) xs -> length (sortBy cmp xs) == length (xs :: String)
09:20:43 <lambdabot>   Not in scope: data constructor `Test.QuickCheck.Blind'
09:21:51 <otters> I'm getting http://hpaste.org/68566 when building lambdabot
09:22:01 <nand`> cesip: quickCheck might be able to help you find test cases where it fails; especially with its great reductions feature
09:26:39 <hpaste> squidz pasted “foldr” at http://hpaste.org/70819
09:26:53 <squidz> can anybody tell my why this implementation of foldr doesnt work with the function (:)
09:27:31 <cesip> okay. the proof was an interesting exercise. in that i discovered it was due to an inappropriate function use. my fault for naming all functions in a similar fashion
09:27:35 <Cale> squidz: huh?
09:27:40 <Cale> @src foldr
09:27:41 <lambdabot> foldr f z []     = z
09:27:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:27:59 <nand`> squidz: works fine for me
09:28:14 <squidz> hmm i get this error
09:28:32 <Cale> > foldr (:) [] [1,2,3,4,5]
09:28:34 <lambdabot>   [1,2,3,4,5]
09:28:38 <Cale> > foldr (:) [6,7,8] [1,2,3,4,5]
09:28:40 <lambdabot>   [1,2,3,4,5,6,7,8]
09:28:48 <hpaste> squidz annotated “foldr” with “foldr (annotation)” at http://hpaste.org/70819#a70820
09:29:06 <Cale> squidz: that would be because 1 isn't a list
09:29:06 <nand`> squidz: the last argument has to be of type [a]
09:29:22 <nand`> unifying 1 with [a] would require a Num instance for [a], which is what the error is complaining about
09:29:28 <squidz> when i try to call foldr (:) [] 1
09:29:41 <Clint> yes
09:29:48 <Axman6> squidz: calling that makes no sense, unless you have numbers as lists
09:29:58 <Cale> :t foldr (:)
09:29:59 <lambdabot> forall a. [a] -> [a] -> [a]
09:30:01 <Cale> :t foldr (:) []
09:30:03 <lambdabot> forall a. [a] -> [a]
09:30:07 <Cale> :t foldr (:) [] [1,2,3]
09:30:08 <lambdabot> forall a. (Num a) => [a]
09:30:15 <Cale> :t foldr (:) [] "hello"
09:30:17 <lambdabot> [Char]
09:30:21 <Cale> :t foldr (:) [] 1
09:30:23 <lambdabot> forall a. (Num [a]) => [a]
09:30:45 <Cale> It *would* work, if there was an instance of Num for lists.
09:30:56 <squidz> I see
09:31:08 <Cale> (so that the numeric literal 1 could be interpreted as a list to fold over)
09:31:16 <Axman6> squidz: what do you think foldr (:) [] 1 should do?
09:31:36 <squidz> Axman6: just put the 1 into the list
09:31:46 <Cale> :t foldr (:) [] [1]
09:31:48 <lambdabot> forall a. (Num a) => [a]
09:31:51 <Cale> > foldr (:) [] [1]
09:31:52 <lambdabot>   [1]
09:32:02 <Axman6> also:
09:32:05 <Cale> 1 and [1] are two different things
09:32:13 <Axman6> > foldr (:) [1] [3,4,5]
09:32:15 <lambdabot>   [3,4,5,1]
09:32:56 <Cale> (as are [] and [[]])
09:34:33 <squidz> I see, thanks for the help
09:35:04 <otters> I just want to start over with cabal
09:35:08 <otters> and delete everything
09:35:22 <dmwit> rm ~/.ghc if you've been installing everything locally
09:35:49 <otters> what about ~/.cabal?
09:36:31 <dmwit> You can keep it.
09:36:47 <otters> I did install some packages globally
09:36:54 <Axman6> no!
09:37:07 <dmwit> Reinstall Linux from scratch, it's the only way to be sure.
09:37:13 <otters> say it ain't so
09:37:22 <otters> I like using OSX though
09:37:24 <dmwit> Just kidding, you can just delete the directory GHC keeps libraries in and reinstall GHC. =)
09:51:30 <otters> wowzer, haskell-platform has a lot of dependencies
09:55:18 <morel> i'm writing yet another todo-manager (just for fun). in my todo-manager each task has a list of categories. those categories are a bit like a tree. so, if a tasks category is "haskell", "programming" should also be a category of that task.  furthermore, it should be possible that a category has somehow two parents… so it's actually not really a tree. i mean, when a tasks category is "haskell", "programming" and "inte
09:55:18 <morel> rests" should be also a category of that task.  so, i need to be able to add, remove and change these categories while it's stored in a file.
09:55:59 <nule> hi all - anybody know of a good starter guide to using the built in random functions? the few things I can find are only confusing me more
09:58:05 <nule> aaaand as soon as I ask I find something good, nm
09:58:13 <Axman6> =)
09:58:23 <pl0x> hello. am reading learn you a haskell currently, did not read about monads yet. my main function calls "forever $ interact . myFunc". entering one input works, but then it exits with "illegal operation (handle is closed)" and I don't understand why.
09:58:25 <nule> seems to always work that way
09:58:44 <byorgey> nule: what did you find?
09:58:57 <nule> byorgey: http://www.vex.net/~trebla/haskell/random.xhtml
09:58:58 <Axman6> pl0x: there should be no need to call forever there..
09:59:07 <byorgey> pl0x: interact captures the *entire* input stream
09:59:16 <pl0x> nule: there is a chapter in learn you a haskell which I found interesting
09:59:41 <pl0x> thank you Axman6 and byorgey! somehow forgot about this. will try
09:59:47 <nule> pl0x: cool - I've been digging through that, so I'll take a look
10:00:25 <arrowdodger> Hi guys. I've started to work on Haskell support in KDevelop. Prooflink: https://bitbucket.org/arrowdodger/kdevelop-haskellsupport
10:00:32 <arrowdodger> Everyone who want to help are welcome.
10:03:51 <edwardk> preflex: xseen roconnor_
10:04:39 <edwardk> roconnor_: telescope :: (Functor f, Functor g) => [(g (Cofree g a) -> Store (g (Cofree g a)) (g (Cofree g a))) -> Cofree g a -> Store (g (Cofree g a)) (Cofree g a)] -> (a -> f a) -> Cofree g a -> f (Cofree g a) -- whee
10:09:34 <DMcGill> what kind of laws should Ord instances follow?
10:10:12 <c_wraith> consistency with Eq, and when a total order is possible, transitivity
10:10:44 <DMcGill> so things like:
10:10:54 * hackagebot happstack-clientsession 7.1.1 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.1.1 (JeremyShaw)
10:10:57 <c_wraith> also, self-consistency.  a < b iff b > a
10:11:02 <DMcGill> a >= b ==> a == b or a > b
10:11:20 <c_wraith> that's consistency, again
10:11:33 <c_wraith> transitivity is like a > b, b > c ==> a > c
10:11:47 <DMcGill> yeah I was trying to expand on what you meant, not correct you :)
10:11:54 <roconnor_> edwardk: say again
10:12:45 <DMcGill> the wikipedia page for Total Order has some axioms on it that look right
10:16:04 <pl0x> main = interact $ unlines . map (show . solveRPN) . lines -- why doesn't this print any response when entering strings to be processed by solveRPN? I thought this is the same situation as presented in LYAH
10:16:17 <pl0x> sorry for the beginner's question. :/
10:16:35 <pl0x> solveRPN is String -> Float
10:17:59 <c_wraith> pl0x: does it show output if you close the input stream?
10:18:16 <dmwit> pl0x: Works here, though I implemented solveRPN = id. =)
10:18:19 <Axman6> (type ctrl-d)
10:18:29 <dmwit> Can you describe how you're running this program?
10:19:51 <pl0x> it seems to be komodo's fault (my editor). its command output window doesn't print the response, whereas once run in command line everything works as expected.
10:19:57 <pl0x> thanks for the help guys
10:20:21 <keseldude> idk how I feel about using the interact function...
10:20:41 <pl0x> any reasons not to, keseldude?
10:21:06 <shachaf> pl0x: Yes, but none of them are relevant when you're learning the language.
10:21:11 * byorgey feels warm and fuzzy about using the interact function
10:21:38 * ski purrs
10:21:43 <keseldude> I don't like not having any control over IO
10:21:45 <pl0x> hehe ok. just will go on and find out about it one day ;)
10:21:59 <c_wraith> « interact reverse » is something that can demonstrate a downfall of interact...  But for most beginner use, it's fine
10:22:07 <shachaf> c_wraith: Downfall?
10:22:09 <ski> keseldude : you prefer `IO' controlling you, then ?
10:22:10 <c_wraith> yes.
10:22:16 <shachaf> Why?
10:22:18 <c_wraith> like the the famous movie :)
10:22:21 <shachaf> It works exactly as promised.
10:22:35 <mcstar> remember yesteday's problem? the bioinformatics  one? when i just mapM'd over the strings the putStr function, i didnt get any output from the program
10:22:41 <mcstar> i had to explicitely break up the IO
10:22:53 <c_wraith> mcstar: that's because you were using line buffering
10:23:37 <keseldude> I guess it has its use cases
10:23:46 <mcstar> c_wraith: i dont understand
10:23:58 <mcstar> line buffering would have been ok
10:24:04 <mcstar> afaict
10:24:31 <c_wraith> mcstar: putStr doesn't include a newline. so putStr-only output with line buffering will result in no output
10:24:49 <keseldude> you could have done
10:25:03 <mcstar> c_wraith: so putStrLn explicitely flushes?
10:25:04 <keseldude> \x -> putStr x >> hFlush stdout -- I think
10:25:21 <dysinger> that's right
10:25:23 <c_wraith> mcstar: no. It just includes a newline.  which causes a flush in *line-bufferd* mode
10:25:29 <c_wraith> buffered
10:25:45 <mcstar> c_wraith: there were newlines in the outputted strings
10:26:18 <keseldude> oh really? then that shouldn't have been the issue
10:26:23 <mcstar> buffering notwithstanding, why was the output lost totally?
10:26:41 <c_wraith> Then I guess you were doing something else wrong. but « mapM_ putStr » works fine
10:26:56 <mcstar> ill dig up the code
10:27:06 <mcstar> eating have to wait..
10:27:11 <mcstar> haskell is way more important
10:27:16 <c_wraith> hah
10:27:18 <c_wraith> :)
10:27:33 <pl0x> btw. anyone here on windows and able to recommend an editor/IDE? tried leksah (crashes often), eclipsefp (highlighting fails after update) and now komodo
10:27:38 <pl0x> even considered gvim
10:28:01 <c_wraith> windows is a terrifying jungle that few of us venture into
10:28:08 <parcs`> notepad++ is decent
10:28:16 <mcstar> pl0x: emacs works perfectly on windoes
10:28:17 <parcs`> sublime text is good
10:28:22 <S11001001> I am on windows sometimes, but am unable to recommend an editor/IDE
10:28:29 <c_wraith> the eclipsefp devs do respond pretty quickly to bug reports.
10:28:43 <shachaf> pl0x: People will tell you to use vim or emacs and you shouldn't listen to them unless you want to spend your time learning vim or emacs instead of Haskell.
10:28:54 <shachaf> Pretty much any editor you're used to will work. What do you use for other languages?
10:29:20 <roconnor_> is there a Functor wrapper for Monad?
10:29:46 <shachaf> Wrapper?
10:29:52 <shachaf> As in a newtype that implements fmap with liftM?
10:29:56 <roconnor_> ya
10:30:01 <pl0x> well, for C++ it's mainly Visual Studio with all the fancy highlighting and stuff. as for am: I am able to navigate and edit stuff, but I'm still pretty slow at it
10:30:02 <roconnor_> oh maybe WrappedMonad
10:30:07 <roconnor_> @hoogle WrappedMonad
10:30:08 <lambdabot> Control.Applicative newtype WrappedMonad m a
10:30:23 <pl0x> might have a go at sublime text or try to fix that issue with Komodo
10:30:28 <c_wraith> right.  Applicative is a subclass of Functor
10:30:36 <pl0x> and thanks c_wraith, will consider a bug report
10:30:42 <shachaf> Yep, WrappedMonad.
10:32:04 <roconnor_> 80% of my code is just applying newType constructors and destructors
10:32:24 <roconnor_> focus l m = StateT $ unwrapMonad . getCompose . cl (Compose . WrapMonad . (runStateT m))
10:32:25 <roconnor_>   where
10:32:27 <roconnor_>     cl x = clone l x
10:32:36 <shachaf> I wish newtypes weren't such a hassle. :-(
10:33:32 <hpaste> mcstar pasted “problem?” at http://hpaste.org/70822
10:33:46 <roconnor_> I'm just going to assume that definition of focus is correct since it typechecks.
10:33:46 <mcstar> c_wraith: ^^
10:33:54 <roconnor_> honestly I have no idea
10:34:01 <Cale> shachaf: Perhaps too dwimmy to make them less of a hassle though.
10:34:08 <ski> shachaf : "Restricted type synonyms" from Hugs at <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> would help some ..
10:34:22 <c_wraith> mcstar: hahaha.  there's definitely a bug in there.
10:34:23 <shachaf> ski: Possibly...
10:34:30 <shachaf> I'm not sure if that's the right solution.
10:34:36 <c_wraith> mcstar: if you put a type signature on main, the compiler would tell you what it is
10:34:53 <shachaf> But it's good that people tried something at least. :-) Even if it's only in Hugs.
10:35:18 <shachaf> I just don't like how people do things like "type Username = String".
10:35:37 <mcstar>     Expected type: [a0] -> ()
10:35:37 <jfischoff> @t mapM_
10:35:37 <ski> shachaf : a similar version is allowing one to export type synonyms from a module abstractly (as allowed in SML and O'Caml), so that it appears similar to a `data' or `newtype' with no exported constructors, externally
10:35:37 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:35:39 <mcstar>       Actual type: [a0] -> m0 ()
10:35:42 <mcstar>     Expected type: [a0] -> ()
10:35:44 <mcstar>       Actual type: [a0] -> m0 ()
10:36:05 <jfischoff> :t mapM_
10:36:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:36:22 <c_wraith> more importantly
10:36:26 <c_wraith> :t (<$>)
10:36:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:36:40 <c_wraith> vs...
10:36:44 <c_wraith> :t (=<<)
10:36:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:37:05 <c_wraith> the difference between those two is why your code doesn't output anything
10:37:45 <mcstar> main = C.lines <$> C.getContents >>= (mapM_ doStuff)
10:37:48 <mcstar> ^^ ok
10:38:32 <ski> shachaf : another solution might be something like <http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes#CoercionsandCoercionKinds>
10:39:09 <mcstar> c_wraith: so the action was never executed
10:39:42 <c_wraith> mcstar: you were creating an action to build an action.  The first action was being executed - but the action it was creating wasn't.
10:39:47 <mcstar> why doesnt ghc enforce IO () on main?
10:40:08 <shachaf> Because the Report doesn't.
10:40:09 <c_wraith> it probably should..  But the haskell spec says main must unify with IO a...  Nothing more specific
10:40:25 <shachaf> Presumably because it doesn't use the return value, so why would it enforce it?
10:40:37 <fryguybob> shachaf: runhaskell and ghci do.
10:40:48 <shachaf> fryguybob: Yes, runghc is broken.
10:40:50 <Botje> mcstar: it allows you to write a recursive main, for example
10:41:21 <parcs`> sounds horrible
10:41:32 <Botje> meh
10:41:41 <Botje> main = getLine >>= putStrLn >> main
10:41:49 <dmwit> Doesn't sound horrible to me. I've even done it.
10:42:02 <dmwit> It's a very handy way to write a top-level loop.
10:42:13 <parcs`> Botje: but in that case main can still be IO ()
10:42:19 <shachaf> main = forever (getLine >>= putStrLn)
10:42:25 <shachaf> (But yes.)
10:42:29 <Botje> parcs`: sure. but you'd need an explicit annotation.
10:42:29 <parcs`> Botje: i meant using the return value of main in main
10:42:30 <dmwit> Not all loops run forever.
10:42:50 <c_wraith> Still, I don't think everyone would mind if GHC warned if the type of main wasn't IO () if it isn't specified.
10:43:09 <c_wraith> someone just needs to submit a patch to make GHC warn about that
10:43:23 <parcs`> you wouldn't need an explicit annotation; ghc could infer that it is IO () (if main were constrained)
10:43:24 <c_wraith> err, I don't think anyone would mind
10:43:46 <squidz> can somebody tell me why this seems to be ignoring my reverse implemention when I call it
10:43:49 <hpaste> squidz annotated “foldr” with “foldr (annotation)” at http://hpaste.org/70819#a70823
10:44:31 <Botje> squidz: did you mean reverseAppend instead of reverse?
10:44:43 <Botje> oh, wait
10:45:36 <Botje> squidz: [5..1] doesn't generate what you think it does.
10:45:42 <Botje> > [5..1]
10:45:44 <lambdabot>   []
10:45:48 <Botje> > [5,4..1]
10:45:49 <lambdabot>   [5,4,3,2,1]
10:46:43 <dmwit> concat [x, y] is probably better spelled x ++ y, too.
10:46:57 <dmwit> Though that depends a bit on your aesthetic.
10:47:34 <otters> Do a lot of people have problems installing lambdabot?
10:48:00 <parcs`> a lot of people don't bother installing lambdabot
10:48:09 <squidz> Botje: Botje thanks
10:48:53 <morel> (how) can i just store a variable in a file such that i can read and use it later again?
10:49:08 <parcs`> you mean store a value?
10:49:12 <morel> yea.
10:49:26 <parcs`> using the Show/Read instances or one of the binary serialization libraries
10:49:43 <morel> binary serialization?
10:49:56 <morel> data.binary?
10:51:10 <parcs`> yeah, or Data.Serialize from 'cereal'
10:51:43 <morel> parcs`: the type of the value i want to save is :: [(String,[Int])]. Would it be slow if i just wrote used "print" and "read"?
10:52:18 <mroman> @src forM
10:52:19 <lambdabot> forM = flip mapM
10:53:30 <parcs`> morel: show and read are relatively slow, but they'll most likely be fast enough
10:55:01 <morel> parcs`: thank you! i'll use print/read for now :)
11:01:21 <roconnor_> edwardk: I need names for type aliases for Getter a a b b and Setter a a b b
11:01:48 <edwardk> Getter only needs 2 args at least
11:01:58 <edwardk> Setter needs all 4 i guess
11:02:24 <roconnor_> edwardk: what is the type of (^.)
11:03:59 <edwardk> one sec (in a meeting)
11:04:13 <roconnor_> ah
11:04:22 <roconnor_> no problem, I'm making dinner
11:06:20 <edwardk> (^.) :: a -> ((c -> Getting c d) -> a -> Getting c b) -> c -- works even if the alias for a getter has only two parameters
11:06:44 <edwardk> type Getter a c = forall r d b. (c -> Getting r d) -> a -> Getting r b
11:06:46 <edwardk> is what i was using
11:07:06 <roconnor_> oh I see
11:07:36 <edwardk> i didn't investigate if d and b can be forced to c and a
11:07:45 <roconnor_> I doubt it very much
11:08:47 <edwardk> -- | read-only lenses
11:08:48 <edwardk> type Getter a c = forall r. (c -> Getting r c) -> a -> Getting r a
11:08:49 <edwardk> works find
11:08:51 <edwardk> er fine
11:10:11 <edwardk> ghci> (1 :+ 2, 3) ^. fstLens . getting magnitude    ==> 2.23606797749979
11:11:52 <mroman> @src interact
11:11:53 <lambdabot> interact f = do s <- getContents; putStr (f s)
11:13:02 <morel> mroman: btw, you can also write lambdabot a private message like "/msg lambdabot …".
11:13:42 <mroman> Ic.
11:14:33 <mroman> Pardon me.
11:14:38 <shachaf> morel: It's not really necessary to tell people after a single message...
11:16:06 <mroman> shachaf: He's right though.
11:16:36 <mroman> I didn't consider lambdabot also responds to queries but I should have thought of that :)
11:18:52 <deech> Hi all, which monad transformers package is considered the one to use nowadays? I have some old code that uses "monads-fd".
11:19:16 <monochrom> try mtl first. comes with the haskell platform
11:20:04 <deech> monochrom: I did and some of my functions failed. Is there some reference page that outlines the difference between the packages?
11:20:17 <monochrom> I don't know
11:20:38 <byorgey> deech: if you tell us the error messages, we might be able to suggest fixes
11:21:54 <byorgey> the new mtl is the direct successor of the old monads-fd, but there have been a few changes since then
11:21:58 <otters> why is "bson-0.1.7" an invalid constraint?
11:22:20 <byorgey> otters: try  "bson ==0.1.7" instead
11:22:23 <deech> byorgey: I haven't narrowed it down to a self-contained example, but I was working with some of Oleg's delimited continuation code and the error was: No instance for (MonadIO (CC (PS [Int]) IO))
11:22:27 <deech>       arising from a use of `liftIO'
11:22:34 <deech> Oops
11:22:53 <deech> Changed the package from "mtl" to "monads-fd" and everything worked.
11:23:01 <byorgey> what is CC?
11:24:03 <monochrom> CC is from the CC-delcont package
11:24:26 <deech> monochrom: Yup, I'm hunting down a link to the source now.
11:24:38 <byorgey> this? http://hackage.haskell.org/packages/archive/CC-delcont/0.2/doc/html/Control-Monad-CC.html
11:24:51 <monochrom> but shouldn't it be CCT?
11:25:06 <deech> byorgey: Here's what I have: http://hackage.haskell.org/packages/archive/CC-delcont-cxe/0.1.0.2/doc/html/src/Control-Monad-CC-CCCxe.html
11:25:34 <mm_freak> what's the difference between CC and Cont?  Cont is delimited, as far as i can see
11:25:41 <mm_freak> runCont is the delimiter
11:26:15 <mm_freak> i think one of the most powerful continuation monads is monad-coroutine anyway
11:26:22 <byorgey> yeah, that's a strange error, because  CCT (PS [Int]) IO  *does* have a MonadIO instance
11:26:27 <deech> mm_freak: In the delimited package you have operators like "shift" and "control" act as delimiters.
11:26:33 <monochrom> if you think in terms of that (which I don't recommend), CC-delcont puts delimiters inside delimiters so you can prompt while you prompt
11:26:35 <mm_freak> i see
11:26:47 <monochrom> or shift while you shift
11:27:04 <mm_freak> never ran into a problem where i would have needed this
11:27:17 <mm_freak> (or wanted)
11:27:37 <deech> mm_freak:  I'm exploring it's applications for web programming.
11:28:15 <deech> byorgey: Weirder that it seems to work with monads-fd.
11:28:41 <mm_freak> deech: for scheme-like web programming, where providing a form looks like an interactive command?
11:28:45 <byorgey> deech: can you paste the code somewhere?
11:29:01 <byorgey> deech: or are you saying that just building CC-delcont gives you that error?
11:29:29 <byorgey> oh, or CC-delcont-cxe?
11:30:42 <deech> byorgey: I believe I got it directly from Oleg's site http://okmij.org/ftp/continuations/CCmonad/
11:31:17 <deech> Let me whittle the example down a little bit before posting.
11:31:25 <byorgey> ok.
11:31:38 <byorgey> ping me when you have a whittled-down example
11:31:44 <deech> byorgey: thanks!
11:36:36 <DexterLB> what's the most canonical way of comparing Text to a literal string value? The best I can think of is (someText == pack "a string")
11:37:02 <shachaf> That works.
11:37:16 <DexterLB> is it efficient? :D
11:37:40 <shachaf> Do you care?
11:37:45 <shachaf> It'll probably be reasonably efficient.
11:38:08 <DexterLB> good point
11:38:36 <slack1256> DexterLB: pack is possibly fused away in compilation (possibly keyword here)
11:39:03 <nand`> the term is “constant folding” or so
11:39:05 <DexterLB> slack1256: oh, I see, since the string is literal
11:39:15 <nand`> and yes, it should be
11:39:26 <DexterLB> s/literal/constant
11:39:34 <nand`> DexterLB: with -XOverloadedStrings you can just write "a string"
11:39:49 <DexterLB> ah, sweet
11:40:24 <slack1256> in conduit documentation they say that conduit is a solution to the "streaming data problem"
11:40:55 <slack1256> which is that problem? the one you get trying to use lazy bytestring/Text/string IO with handlers not being closed?
11:41:38 <c_wraith> that's a specific manifestation of it.
11:42:04 <c_wraith> the problem, more broadly, is anything involving generating, consuming, or processing streaming data in an efficient way
11:42:22 <slack1256> I've checked google for "stream data problem" but the only reference I get is from the conduit docs.
11:42:23 <SYNTActiX> i was going to learn lisp, why should i learn haskell instead
11:42:29 <roconnor_> edwardk: can two setters be tensored together?
11:43:00 <edwardk> not sure
11:43:05 <c_wraith> I think I should have said "or transforming a data stream" instead of "or processing"
11:43:05 <roconnor_> SYNTActiX: because you want to use TDD: Type directed development.
11:43:08 <edwardk> you want (***) for Setter?
11:43:21 <roconnor_> edwardk: only if it is possible.
11:43:26 <slack1256> SYNTActiX: Learn lisp, learn haskell, learn real analysis. if you can also learn some philosophy (it will help)
11:43:27 <edwardk> let me check
11:43:56 * roconnor_ 's definition of (***) lacks grace ... and polymorphism.
11:43:57 <edwardk> i think so
11:44:00 <roconnor_> damn
11:44:05 <monochrom> what slack1256 says
11:44:29 <shachaf> SYNTActiX: Go ahead and stick with LISP. It's a useful language and you'll learn plenty.
11:44:41 <nand`> learn lisp, then learn Haskell
11:44:42 <shachaf> And I think they like arguing that their language is the best ever more than #haskell does. :-)
11:44:52 <slack1256> now what I only lack is an "Learn you Real/Complex analysis for the great good"!
11:44:59 <shapr> slack1256: Write it!
11:45:25 <roconnor_> edwardk: I'd be interested in an inhabitant of Functor f => LensFamily f al al' bl bl' -> LensFamily f ar ar' br br' -> LensFamily f (al, ar) (al', ar') (bl, br) (bl', br')
11:45:35 * slack1256 so hilbert spaces are like burritos...
11:45:39 <edwardk> *nods*
11:45:39 <nand`> though if you're new to functional programming I'd possibly even recommend Haskell first, simply because I think it's conceptually more natural than lisp is; you can still appreciate lisp afterwards
11:45:56 <roconnor_> I will think about it myself
11:46:03 <DexterLB> SYNTActiX: if you want to be able to talk to gods, learn lisp. If you want awesome type signatures and laziness learn haskell
11:46:03 <nand`> (and no, this is not a stupid CT pun)
11:46:16 <edwardk> let me give it a shot
11:46:27 <keseldude> I learned a good amount of haskell before scheme, and I had a lot of fun with scheme
11:47:25 <roconnor_> edwardk: when I wrote focus, I just assumed it was correct since I had the right type.  I have no idea how it works.
11:47:34 <nand`> I went through SICP (which deals with scheme) before even stumbling upon Haskell, but I think scheme is a pedagogical tool at best. I wouldn't write any serious applications with it
11:47:39 <edwardk> you probably can't write it that way ,you have two 'f's in there that need to be combined
11:47:45 <edwardk> Functor gives you no tools for that
11:48:16 <roconnor_> oh right
11:48:24 <edwardk> so i think tensoring needs to be done on a per type basis
11:48:31 <roconnor_> math is stupid
11:49:13 <hpaste> Deech pasted “mtl vs. monads-fd” at http://hpaste.org/70827
11:49:26 <deech> byorgey: ^^
11:49:58 <edwardk> @djinn-env
11:49:58 <lambdabot> data () = ()
11:49:58 <lambdabot> data Either a b = Left a | Right b
11:49:58 <lambdabot> data Maybe a = Nothing | Just a
11:49:58 <lambdabot> data Bool = False | True
11:49:58 <lambdabot> data Void
11:50:00 <lambdabot> type Not x = x -> Void
11:50:02 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
11:50:04 <lambdabot> class Eq a where (==) :: a -> a -> Bool
11:50:12 <edwardk> @djinn-add data Identity a = Identity a
11:50:18 <byorgey> deech: and you're saying it works with monads-fd but not mtl?
11:50:41 <edwardk> @djinn-add type Setter a b c d = (c -> Identity d) -> a -> Identity b
11:50:41 <lambdabot> Error: Undefined type Identity
11:50:48 <deech> byorgey: Yup.
11:50:51 <edwardk> @djinn-env
11:50:51 <lambdabot> data () = ()
11:50:52 <lambdabot> data Either a b = Left a | Right b
11:50:52 <lambdabot> data Maybe a = Nothing | Just a
11:50:52 <lambdabot> data Bool = False | True
11:50:52 <lambdabot> data Void
11:50:53 <lambdabot> type Not x = x -> Void
11:50:55 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
11:50:57 <EvanR> spammmm
11:50:57 <lambdabot> class Eq a where (==) :: a -> a -> Bool
11:50:59 <lambdabot> data Identity a = Identity a
11:51:12 <edwardk> odd
11:51:55 <deech> byorgey: In case it isn't clear from the example the output of main should be:"hello world"\n ()
11:52:00 <shachaf> @djinn-add type Foo a = Identity a
11:52:01 <lambdabot> Error: Undefined type Identity
11:52:05 <shachaf> @djinn a -> Identity
11:52:06 <lambdabot> Error: kind error: (KArrow KStar KStar,KStar)
11:52:07 <shachaf> @djinn a -> Identity a
11:52:07 <lambdabot> f = Identity
11:52:20 <byorgey> deech: why do you have ScopedTypeVariables enabled?
11:52:21 <shachaf> I thought djinn could do that.
11:52:31 <shachaf> I mean, it has Not defined in terms of Void.
11:52:34 <edwardk> @djinn ((c -> Identity d) -> a -> Identity b) -> ((g -> Identity h) -> e -> Identity f) -> ((c,g) -> Identity (d,h)) -> (a,e) -> Identity (b,f)
11:52:34 <lambdabot> -- f cannot be realized.
11:53:09 <byorgey> deech: it works fine for me with mtl.
11:53:14 <byorgey> deech: what version of mtl do you have installed?
11:53:17 <edwardk> shachaf: me too
11:53:26 <deech> byorgey: Oops, I just took that out and it does the same thing. mtl-2.1 and monads-fd-0.2.0.0
11:53:39 <edwardk> @djinn ((c -> d) -> a -> b) -> ((g -> h) -> e -> f) -> ((c,g) -> (d,h)) -> (a,e) -> (b,f)
11:53:39 <lambdabot> -- f cannot be realized.
11:53:47 <rwbarton> maybe djinn gets confused by the type constructor/data constructor overloading
11:54:07 <edwardk> interesting
11:54:08 <shachaf> Oh, that's possible.
11:54:25 <edwardk> oh i guess that makes sense
11:54:32 <shachaf> @djinn-add Id a = MkId a
11:54:32 <lambdabot> Cannot parse command
11:54:37 <shachaf> @djinn-add data Id a = MkId a
11:54:49 <shachaf> @djinn-add type Foo a = Id a
11:54:50 <edwardk> roconnor_: guess the answer is no ;)
11:54:50 <lambdabot> Error: Undefined type Id
11:54:53 <byorgey> deech: it works fine for me with mtl-2.1.  Can you paste the precise error message you get when you load that file?
11:54:55 <shachaf> Maybe not!
11:54:58 <rwbarton> hmm
11:55:00 <rwbarton> odd
11:55:02 <roconnor_> edwardk: okay, I feel better now
11:55:18 <edwardk> roconnor_: that is why my 'getter' has that 'r' parameter iirc
11:55:20 <shachaf> I don't see how the type you wrote would work.
11:55:26 <edwardk> shachaf: exactly =)
11:55:32 <roconnor_> @djinn ((c -> c) -> a -> a) -> ((g -> g) -> e -> e) -> ((c,g) -> (c,g)) -> (a,e) -> (a,e)
11:55:33 <lambdabot> f _ a _ (b, c) = (b, a (\ d -> d) c)
11:55:40 <shachaf> You need the g for the (c -> d) and the c for the (g -> h).
11:55:41 <byorgey> deech: note that CCExc imports Control.Monad.Trans too.  Are you modifying that with a package import as well?
11:55:44 <roconnor_> oh right
11:55:46 <edwardk> roconnor_: there its cheating though
11:55:58 <byorgey> getting Control.Monad.Trans from two different packages is a surefire way to get a type mismatch.
11:56:32 <shachaf> @djinn ((q -> w) -> r -> t) -> ((y -> u) -> i -> o) -> ((p,s) -> (d,f)) -> (a,e) -> (a,e)
11:56:33 <lambdabot> f _ _ _ (a, b) = (a, b)
11:56:38 <edwardk> setters don't tensor, and getters tensor when you tensor them as (->)'s before hand
11:57:15 <EvanR> tensor is a verb?
11:57:18 <monochrom> use project.cabal or --hide-package to reliably control package consumption
11:57:27 <hpaste> Deech annotated “mtl vs. monads-fd” with “mtl vs. monads-fd (annotation)” at http://hpaste.org/70827#a70828
11:57:44 <edwardk> http://en.wiktionary.org/wiki/tensor#Verb
11:57:52 <edwardk> yes =)
11:58:02 <byorgey> deech: what happens if you first do   ghc-pkg hide monads-fd ?
11:58:20 <edwardk> english is good at permitting the you to verb nouns. -- like the use of verb in that previous sentence ;)
11:58:53 <edwardk> http://en.wiktionary.org/wiki/verb#Verb
11:59:04 * byorgey is not surprised that tensor is a verb, but is surprised that it is an *intransitive* verb
11:59:36 <Iceland_jack> Would you prefer it transitivitied?
11:59:48 <monochrom> wait, so "Peter tensors" is valid and has a meaning?!
12:00:03 <byorgey> monochrom: I think no.  But edwardk used it as such above =)
12:00:11 <byorgey> "setters don't tensor"
12:00:35 <monochrom> edwardk categories
12:01:05 <edwardk> in that setting i was applying the intransitive tensor meaning 'the tensor of a setter with a setter'
12:01:05 <monochrom> edwardk categories, and oleg continuations :)
12:01:22 <hpaste> Deech annotated “mtl vs. monads-fd” with “mtl vs. monads-fd (annotation) (annotation)” at http://hpaste.org/70827#a70829
12:01:40 <byorgey> my descriptivist half is currently smirking at my prescriptivist half, saying "but you knew exactly what edwardk meant, didn't you?"
12:01:59 <byorgey> (sheepishly) "...yeah, I guess so"
12:02:01 <edwardk> byorgey: =)
12:02:15 <deech> byorgey: Dunno if this is an issue but "ghc-pkg list" has both "mtl-2.0.1.0 and mtl-2.1".
12:02:26 <edwardk> deech: monads-fd is dead. it _is_ the mtl now
12:02:34 <edwardk> ghc-pkg unregister monads-fd
12:02:36 <byorgey> deech: that's probably not an issue.  I'm more worried about it having both mtl and monads-fd.
12:04:23 <hpaste> Deech annotated “mtl vs. monads-fd” with “mtl vs. monads-fd (annotation) (annotation) (annotation)” at http://hpaste.org/70827#a70830
12:04:53 <edwardk> deech: what version of the platform do you have installed? and why is the mtl hidden?
12:06:13 <deech> edwardk: mtl is not hidden according to ghc-pkg list. And I didn't install my environment from platform.
12:06:42 <edwardk> what are you using to build?
12:06:51 <edwardk> if you add -package mtl to the command line what happens?
12:07:22 <aetoxx> Leksah continuously rebuilds things even when there are no changes. Why does it do that?
12:07:25 <deech> edwardk: I am loading it in ghci.
12:07:41 <sarfraz> hi, can someone help me with this http://stackoverflow.com/questions/11311036/using-tls-extra-for-simple-smtp
12:07:48 <deech> edwardk: Let me try to build it with ghc.
12:07:59 <sarfraz> it doesn't seem to interess anyone in SO
12:09:49 <geekosaur> deech, are you using cabal for this?  it hides and unhides packages according to stuff in the *.cabal file; uyou'll need to edit that to switch from monads-fd to mtl2
12:10:01 <geekosaur> (that would explain a few things...)
12:10:20 <deech> edwardk: Just did a "ghc -package mtl test.hs" with the same results.
12:10:41 <deech> geekosaur: This is not a cabal project. Just a couple of files in the same directory.
12:10:50 <edwardk> something is borked in your install
12:11:17 <deech> edwardk: Should I unregister and re-register mtl?
12:11:22 <geekosaur> ok, so if the package is reported as hidden then you have something messed up in your install, or ghc-pkg list is in fact showing it as hiddenand you're not recognizing that
12:11:38 <edwardk> deech: when you go to unregister mtl it'll probably complain about a million packages
12:11:54 <deech> geekosaur: Shouldn't a hidden package show up in parens?
12:11:59 <geekosaur> yes
12:12:09 <edwardk> i'm with geekosaur, something seems odd about the set of claims
12:12:25 <geekosaur> unless it uses color now
12:12:38 <monochrom> it uses colours usually
12:12:49 <SYNTActiX> http://austinfromaustinpredictsbaseball.tumblr.com/
12:12:53 <geekosaur> it uses colors but last time I looked it kept the parens too
12:13:14 <SYNTActiX> trust me guys, im starting a new meme
12:13:18 <monochrom> now it doesn't
12:13:51 <monochrom> SYNTActiX, do you have anything on-topic to say? if not, I suggest you keep your peace.
12:13:58 <deech> geekosaur: Just hid mtl, it showed up in blue (on my xterm) and then exposed it and re-ran the compilation with the same results.
12:14:06 <SYNTActiX> I'm sorry, don't ban me
12:18:50 <deech> byorgey, geekosaur, edwardk: Ugh, I think I just realized what was happening. At some point in the past I edited my local copy of CCExc.hs and had it importing Control.Monad.Trans from "monads-fd", I loaded up my test case and it complained about ambiguous packages "monads-fd" and "mtl" so I added the package qualifier. If it didn't match the edit I had previously made I got the error. Sorry to waste your time.
12:19:10 <edwardk> no worries
12:19:31 <byorgey> hehe, I wondered if it was something like that.  That's why I asked about the Control.Monad.Trans import in CCExc earlier.
12:19:38 <byorgey> Maybe you missed me asking that.
12:19:44 <deech> byorgey: I did.
12:20:53 <deech> But I had another question, is there a reference on the differences between the two packages or why one is superior?
12:22:09 <byorgey> I believe I added a link to the Typeclassopedia, linking to the canonical reference (which is something edwardk wrote on a mailing list)
12:22:26 <byorgey> ah, here it is   http://article.gmane.org/gmane.comp.lang.haskell.libraries/17139
12:22:58 <deech> "In the beginning ...", that's exactly what I need. Thanks!
12:23:04 <monochrom> the only reference I use is one sentence in the haddock of monads-fd. "This package is obsolete: use mtl instead". that does it for me. as for migration tips, I don't know, actually I doubt that any migration tips is needed, currently mtl API looks identical to monads-fd API
12:23:17 <edwardk> deech: the mtl came first, then ross tried to clean things up, and split out transformers, and monads-fd, at the time it was thought that it might be a good idea to make monads-tf, but they f'd up and made monads-tf and monads-fd incompatible with each other AND the mtl
12:24:10 <edwardk> so the fix was in the end to rename monads-fd to mtl, and keep transformers because many consumers only need the concrete data types not the classes, which keeps you in haskell 98
12:24:16 <monochrom> the migration tips needed was from mtl-1 to mtl-2, actually
12:24:46 <edwardk> so transformers is now a haskell 98 package that mtl uses, monads-fd is retired, and monads-tf is a bad idea languishing
12:24:52 <deech> edwardk: Hah! Awesome.
12:25:13 <gardie> SYNTActiX: hello
12:25:22 <rupert> hi
12:25:48 <rupert> how can i implement a version of 'any' using foldr
12:25:51 <edwardk> i wouldn't particularly _mind_ a monads-tf that used different module names so it was possible for library authors to support it and monads-fd, but for now its only effect is to fragment the user base
12:26:02 <rupert> i was successful in doing this with foldl, but now i am stuck
12:26:05 <rupert> with foldr
12:26:08 <SYNTActiX> so guys, i was practicing using iterators in haskell but i got a weird error
12:26:14 <byorgey> rupert: how did you do it with foldl?
12:26:21 <byorgey> SYNTActiX: iterators?
12:26:22 <EvanR> iteratees?
12:26:36 <rupert> anyFoldl p xs = foldl step False xs
12:26:36 <rupert>   where step acc x = acc || (p x)
12:26:59 <SYNTActiX> yah, some iterators. i just couldn't iterate through any arrays
12:27:03 <SYNTActiX> and it angered me
12:27:08 <byorgey> rupert: looks fine.  and why are you stuck with foldr?
12:27:14 <byorgey> it shouldn't be much different, actually.
12:27:18 <SYNTActiX> i heard haskell was similar to java but it i get weird errors
12:27:26 <byorgey> SYNTActiX: you heard wrong.
12:28:03 <SYNTActiX> i mean all of my variables are global and i have no returns or params and it still wont work
12:28:03 <rupert> because the step function is different, it takes an element and the rest of the list, right?
12:28:07 <byorgey> SYNTActiX: in Haskell, to iterate through an array you use hylomorphisms
12:28:17 <byorgey> which is simply the composition of a catamorphism and an anamorphism
12:28:18 <mstrlu> This is probably stupid... but what does *-fd actually stand for in package name
12:28:24 <edwardk> deech: anyways with that change it pretty much fixed the fragmentation. the only fragmentation left at last check was that ghc depends on the old mtl-1.x internally
12:28:39 <byorgey> rupert: right
12:28:43 <edwardk> mstrlu: functional dependencies
12:29:11 <mstrlu> edwardk: Ahhh... thanks
12:29:12 <rwbarton> it takes an element of the list and the foldr result of the rest of the list
12:29:14 <edwardk> mstrlu:in a multiparameter type class like class Foo a b | a -> b     -- the | a -> b is a functional dependency
12:29:30 <byorgey> rupert: oh, right, what rwbarton said
12:29:35 <Eduard_Munteanu> Or fundep :)
12:30:19 <edwardk> so with comonad and comonad-transformers i just have haskell 98 code, while in comonads-fd i have the mtl-like classes that need fundeps.
12:30:20 <deech> edwardk: Great thanks! BTW I believe RWH still teaches the old (concrete data type) way of using monad transformers. There was quite a bit of dissonance caused by that.
12:30:44 <edwardk> deech: yeah. personally i was a fan of keeping both State and StateT
12:30:59 <edwardk> i find from a pedagogical perspective the transformer-only types are awkward to teach
12:31:04 <rupert> ahhh, I got it
12:31:07 <rupert> thanks guys
12:31:11 <monochrom> ghc using an old lib internally is not that bad. you don't usually observe it
12:31:11 <deech> edwardk: I just realized I said "still" as though I expected my dead-tree version to magically update itself.
12:31:22 <Luke> deech: what do you mean by that?
12:31:28 <geekosaur> ...the other way to do it is associated type families, the -tf suffix.  they're supposed to be equivalent functionality but in practice there are issues (some things ghc doesn't implement and won't easily manage, I think
12:31:32 <geekosaur> ?)
12:31:32 <lambdabot> Maybe you meant: . ? @ v
12:31:46 <Luke> deech: "the old (concrete data type) way of using monad Ts"
12:31:46 <edwardk> deech: well, ISTR bos mentioning something about an update to RWH, so maybe they can fix that =)
12:32:15 <edwardk> geekosaur: well, type/data families come with other extras over and above what you can do with fundeps
12:32:42 <edwardk> geekosaur: but there is the awkward side-condition of there being only one working implementation
12:32:49 <deech> Luke: Having an actual "State ..." datatype vs. a "(MonadState m) ..." constraint.
12:33:15 <EvanR> catamorphisms and hylomorphisms and anamorphisms, lol youre going to get java dude on board real fast with that
12:33:39 <Luke> deech: ah you mean they should have talked more about the type classes
12:33:41 <edwardk> luke: in mtl 1.x there was newtype State s a = State (s -> (a, s))    AND newtype StateT s m a = StateT (s -> m (a, s))
12:33:41 <byorgey> EvanR: just a bit of friendly countertrolling. ;)
12:33:46 <amindfv> EvanR: maybe that's the idea
12:33:54 <EvanR> avoid success at all costs
12:33:56 <geekosaur> edwardk, last time I checked the only other working fundeps implementations were so obsolescent as to be not worth the effort (*ahem* hugs)
12:33:58 <edwardk> in mtl 2.x there is only StateT and 'type State s = StateT s Identity
12:33:59 <Luke> edwardk: is there just StateT now?
12:34:04 <Luke> ah
12:34:24 <EvanR> no in all seriousness you dont want to perpetuate the haskell stereotype of elite snob aristocrats
12:34:35 <deech> Luke: I don't know if that package even existed back then. It's just that people (myself included) are using that to learn Haskell development now and it causes some confusion.
12:34:42 <Luke> thanks guys - I was actually confused by that in the past - nice to have some history
12:34:52 <Luke> totally
12:34:55 <amindfv> EvanR: buuut you don't want to perpetuate the idea that Haskell is like Java
12:35:03 <amindfv> although I agree with you
12:35:22 <monochrom> I want people to spend 0 time on trolls
12:35:37 <amindfv> can someone confirm that `cabal install cmath` doesn't work in Mac OS 10.6 or 10.7?
12:37:22 <edwardk> geekosaur: jhc is still usable for some purposes and has fundeps, and there are little typechecking implementations like thih that support MPTCs but nothing stronger
12:37:36 <edwardk> monochrom++
12:38:23 <monochrom> hey, cmath is an interesting lib. binding to C's math lib, for some version of C
12:39:00 <monochrom> a few things like "remainder" and "isinf" are much sought after
12:39:24 <amindfv> monochrom: I don't think it builds anymore, though (on OS X)
12:39:31 <geekosaur> huh, jhc does them now?  I missed an announcement I guess
12:39:44 <mcstar> my friend showed me his latest c++, he is making the binary representation of an int, puts it in array, and later, computes the size of the array, from log2 of the int => memory violation (also, he put a delete [] after a return)
12:39:51 <jfischoff> anyone now a FilePath validator and is more descriptive then FilePath -> Bool? Something like FilePath -> Either String FilePath
12:39:59 <mcstar> (dont worry, im teching his haskell too)
12:40:07 <mcstar> teaching him*
12:40:42 <morel> jfischoff: s/now/know/ # ?
12:40:48 <jfischoff> yes
12:40:52 <amindfv> I emailed dons (the maintainer), but haven't heard anything
12:41:06 <morel> jfischoff: s/and/which/ # ?
12:41:12 <amindfv> it would be awesome if someone could try a cabal-install, to make sure I'm not crazy
12:41:20 <jfischoff> yeah
12:41:30 <jfischoff> amindfv: I will, what package?
12:41:32 <amindfv> although I tried it on 3 systems, including a completely-clean install of 10.7
12:41:33 <morel> jfischoff: what would "Either String FilePath" mean?
12:41:51 <amindfv> jfischoff: cmath. Thanks!
12:41:55 <jfischoff> I want to get a description of what is wrong
12:42:08 <morel> jfischoff: ah.
12:42:54 <jfischoff> amindfv: `cabal install cmath` worked without a hitch. ghc 7.4.1 and cabal 1.15.0
12:43:21 <amindfv> crap crap crap
12:43:24 <jfischoff> amindfv: cmath-0.3 is what was grabbed
12:43:59 <amindfv> I literally tried `cabal install cmath` on a completely new computer, with a fresh version of 10.7, and the nexest haskell platform
12:44:19 <jfischoff> I have 10.7 but not the newest platform
12:44:20 <amindfv> jfischoff: 0.3 is what my cabal is trying also
12:44:40 <edwardk> geekosaur: based solely on the "Functional Dependencies actually lead to run-time savings. each functional dependency transforms into a case statement which may be omitted." comment in the writeup on jhc ;)
12:45:06 <jfischoff> amindfv: what was the error?
12:45:37 <amindfv> jfischoff: I've had this error on all 3 computers I tried it on: http://www.haskell.org/pipermail/beginners/2012-January/009358.html
12:46:31 <byorgey> do macs have a different version of cmath than linux?
12:46:52 <byorgey> just idle speculation, I really have no idea
12:47:20 <jfischoff> byorgey: I bet it is an issue with the cmath header being different.
12:47:59 <amindfv> byorgey: I don't know, but some of the math.h files that come with OS X are missing definitions for several of the functions that cmath (the haskell package) has an FFI for
12:48:12 <byorgey> weird
12:48:19 <jfischoff> amindfv: my guess is that when I brew installed something
12:48:21 <raichoo> Is there a nice way to apply an argument to a function twice? I mean something better than \x -> f x x or f <$> id <*> id?
12:48:26 <jfischoff> it gave me a different math.h
12:48:43 <jfischoff> that works, but the standard one might not. Or vis-a-versa
12:48:47 <amindfv> jfischoff: that makes sense.
12:49:00 <byorgey> raichoo: what counts as "nice"?
12:49:10 <raichoo> byorgey: surprise me :D
12:49:24 <parcs`> join f
12:49:24 <morel> raichoo: join, i think.
12:49:25 <byorgey> raichoo: why not define your own function  applyTwice f x = f x x  and then write  applyTwice f ?
12:49:40 <morel> > join (+1) 0
12:49:41 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
12:49:43 <jfischoff> amindfv: I take that back
12:49:44 <amindfv> If I can find more people whose clean systems fail on `cabal install cmath`, what's the next step forward?
12:49:59 <amindfv> update the package, to have fewer definitions?
12:50:00 <morel> > join (+) 1
12:50:02 <raichoo> byorgey: I'm just searching for a funky combinator to do that stuff. It's just pure curiosity :)
12:50:02 <lambdabot>   2
12:50:15 <byorgey> ok, in that case, join =)
12:50:25 <byorgey> > join (+) 1
12:50:27 <lambdabot>   2
12:50:29 <raichoo> nice :D
12:50:32 <byorgey> oh, morel already did that =)
12:50:37 <morel> byorgey: just did that… yea… :D
12:50:59 <raichoo> thanks ^^
12:51:01 <shevy> hmm why is the haskell compiler so huge?
12:51:20 <byorgey> shevy: compared to what?
12:51:56 <morel> shevy: GHC implements a lot more than just haskell. it has a lot of extensions etc.
12:52:05 <amindfv> shevy: it's 50% more glorious than standard compilers
12:52:48 <parcs`> shevy: because it's really awesome and featureful
12:53:12 <raichoo> And it's got very big ba… oh nevermind
12:53:16 <parcs`> shevy: http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
12:54:04 <jfischoff> amindfv: I see gamma defined in /usr/include/architecture/i386/math.h, do you?
12:54:13 <shevy> ok
12:54:25 <jfischoff> amindfv: did you install the command line tools from XCode?
12:54:31 <raichoo> shevy: Anyway, why bother?
12:55:03 <amindfv> jfischoff: yes to the second one; I'll look into the first
12:55:34 <mroman> The real question is, why it takes 24h to compile ghc ;)
12:55:35 <shevy> raichoo: I keep backups of all software I use, so big releases add substantially to what I have to backup
12:56:01 <raichoo> shevy: ah ok
12:57:25 <amindfv> jfischoff: you're right! on this machine (the clean Lion install), "gamma" is defined... hmm...
12:57:36 <raichoo> mroman: You are kidding right? O_o
12:57:46 <amindfv> is "undeclared" different from "undefined"?
12:57:53 <roconnor_> shevy: how long do you keep your backups?
12:58:34 <nand`> why not just back up the source code? it can probably be compressed much better and you won't get all of the redundant linkings
12:58:56 <jfischoff> amindfv: I'm pretty sure the error means it can't find a declaration.
12:59:03 <nand`> -rw-rw-r--  1 portage portage  26M Jun  6 22:22 ghc-7.4.2-src.tar.bz2
12:59:13 <mroman> raichoo: I wish.
12:59:29 <raichoo> mroman: I build ghc in about an hour on my laptop…
12:59:43 <jfischoff> amindfv: If it was just undefined it would be a linker I think
13:00:05 <shevy> roconnor_: earliest backups reach back to 2006
13:00:36 <amindfv> jfiscoff: that's so strange. Why would it not find the definition for gamma, yet (I'm assuming) find most other definitions in the math.h file?
13:00:56 <mroman> raichoo: I can build it on a ~2Ghz computer in roughly 2 hours.
13:01:02 <jfischoff> amindfv: you might have another math.h that it finds first?
13:01:08 <mroman> Now scale that down to 600 Mhz ;)
13:01:21 <raichoo> mroman: ouch
13:01:42 <raichoo> mroman: Why not crosscompile it for the small box?
13:02:13 <jfischoff> amindfv: I trying installing and specify the include directory to be /usr/include
13:02:40 <amindfv> jfischoff: how?
13:04:05 <jfischoff> amindfv: `cabal install cmath --extra-include-dirs=/usr/include` although that might just take the dir onto the end, not look there first :(
13:04:59 <amindfv> jfischoff: yeah, it still fails
13:05:31 <amindfv> I've been coming back to this problem since January, actually
13:05:32 <amindfv> haha
13:06:19 <JoeyA> In Elm, a Signal represents a value that changes over time.  How would Elm represent a stream of messages (e.g. queued up keypresses) ?
13:06:31 <JoeyA> I'm not using Elm itself, but looking for a nice way to model a concurrent program.
13:07:18 <jfischoff> amindfv: try `cabal install --verbose=3` and see if you can figure out where it is grabbing math.h
13:09:10 <JoeyA> (this is more of a conceptual question)
13:10:15 <JoeyA> I suppose one possible encoding would be: type Chan a = Signal (Maybe (a, Chan a))
13:10:50 <amindfv> jfischoff: it doesn't make any reference to math.h. Should I put the result in hpaste?
13:10:58 <JoeyA> The idea is, the availability of the next item changes over time, but when it becomes available, it becomes Just instead.
13:11:27 <jfischoff> amindfv: maybe… let me take a look at few things first
13:12:34 <JoeyA> Hmm, perhaps just "Signal Message" would do, and use foldp to accumulate messages.
13:13:36 <JoeyA> and corresponding state, too
13:15:48 <amindfv> jfischoff: thanks.
13:15:56 <bgamari> Is there any easy way to make ghc-core play nicely with cabal-dev?
13:16:47 <JoeyA> Exercise (for myself): write an Elm program that converts keypresses to text output.  For bonus points, make adding subsequent characters O(1), rather than creating the whole text node from scratch each time.
13:17:41 <EvanR> elm...
13:20:15 <JoeyA> EvanR: What about it?
13:21:55 <hpaste> “Jonathan Fischoff” pasted “cmath dump” at http://hpaste.org/70832
13:21:57 <jfischoff> amindfv: ^ there mine. You could diff them.
13:22:38 <JoeyA> @src foldr1
13:22:39 <lambdabot> foldr1 _ [x]    = x
13:22:39 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
13:22:39 <lambdabot> foldr1 _ []     = undefined
13:22:52 <JoeyA> > foldr1 (:) [1,2,3]
13:22:54 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
13:24:09 <ski> JoeyA : deson't that allow changing from `Just ...' back to `Nothing' as well ?
13:24:42 <JoeyA> ski: It does...
13:26:11 <ski> hm, maybe one could use `Signal (Queue a)' for a queue of keypresses ..
13:26:39 <ski> (of course the queue could also change arbitrarily, but it appears more benign than the other)
13:28:54 <shachaf> JaffaCake: Have you considered mentioning the Control.Concurrent.Spawn API as well as Control.Concurrent.Async?
13:29:14 <hpaste> amindfv pasted “cmath dump 2” at http://hpaste.org/70833
13:29:37 <amindfv> jfischoff: there's mine. Couple differences:
13:30:16 <amindfv> 1) cabal can't find a few things: cpphs, hpc, and hscolour
13:30:48 <amindfv> 2) it can't find a bunch of stuff in my path, as visible in 175-196, and line 288
13:31:00 <jfischoff> amindfv: if it is using cpphs by default that could be it maybe, but I don't think cabal does that
13:31:19 <amindfv> I know I already said it, but this is a completely clean system. so my path should be correct.
13:35:27 <nobdraisentone> What is `.' means in lambda calculus? It's just a delimeter between variables and function statement? Or this symbol have some real meaning?
13:36:18 <jfischoff> amindfv: do you have a 32 bit version of ghc?
13:36:26 <danr> nobdraisentone: it's part of the syntax
13:36:45 <Cale> nobdraisentone: you mean in something like λx.xx ?
13:36:58 <danr> nobdraisentone: "\ x . e", here the . separates the bound variable x and the expression e that it is bound in
13:37:04 <amindfv> jfischoff: yes. Haskell Platform 2011.4.0.0, 32-bit
13:37:06 <Cale> it's just a delimiter
13:37:08 <shachaf> I think "." is syntactically a bit like $
13:37:27 <danr> shachaf: even in lambda calculus?
13:37:30 <shachaf> ($ Haskell, that is.)
13:37:30 <Cale> um
13:37:33 <shachaf> (Not . in Haskell.)
13:37:41 <jfischoff> amindfv: thats another difference
13:37:50 <nobdraisentone> So, it's just a syntax symbol without any sense?
13:37:53 <shachaf> At least, someone said that once and it made sense at the time.
13:37:56 <Cale> In lambda calculus it's not even required, it's just there as punctuation to separate things to be a bit more readable
13:38:03 <shachaf> nobdraisentone: It's like -> in Haskell.
13:38:20 <nobdraisentone> shachaf: ok
13:38:22 <amindfv> jfischoff: yours is 64-bit?
13:38:32 <Cale> Well, I guess in typed lambda calculi where you're forced to write the type of the bound variable, it makes more sense
13:38:32 <amindfv> I guess I could try the 64-bit version
13:38:35 <shachaf> I think in the original lambda syntax you could say "\x(xx)" just as well.
13:38:36 <jfischoff> amindfv: yes
13:38:45 <monochrom> Dijkstra used "." for function application. I think Backhouse too.
13:38:57 <shachaf> Cale: The same . is used in forall even in non-lambda contexts.
13:39:06 <Cale> yes
13:39:23 <shachaf> I'm told that it's called "Church's dot".
13:39:24 <Cale> λ was originally thought of as a kind of quantifier
13:39:28 <nobdraisentone> I just wondering because `.' is really strange symbol that lambda-calculus guys have chosen for →
13:39:31 <shachaf> Though I can't find any references to that now.
13:39:35 <Cale> like exists and forall
13:39:57 <Cale> nobdraisentone: That syntax is from back when most of modern mathematical notation didn't exist yet
13:40:19 <amindfv> jfischoff: installing 64-bit version now
13:40:59 <nobdraisentone> Okay, thanks for explanaitions
13:41:55 <Cale> You'll now see something like x ⟼ y instead of λx.y in most mathematical contexts.
13:42:16 <Cale> But lambda calculi specifically have kept the more quantifier-like syntax.
13:43:02 <nand`> what about λx → y
13:43:03 <amindfv> jfischoff: holy... it works!
13:43:05 <monochrom> that is a really long ↦ :)
13:43:06 <amindfv> wtf?
13:43:33 <EvanR> size matters
13:43:39 <amindfv> yeah, it builds fine with 64-bit HP
13:44:12 <amindfv> that's... very weird
13:44:13 <monochrom> I actually view lambda expression as quantified expression too, syntax-wise. also, it is the root of all other quantified expressions
13:45:13 <jfischoff> amindfv: I have a theory, but its not that great. cmath was setting defines that were leading to a default math.h that was wrong because you were trying to build a 32bit thing for x686 arch. But I'm just guessing really
13:45:22 <amindfv> jfischoff: hey, whatever the reason - thanks so much for the help! this has been a long time coming
13:45:47 <jfischoff> amindfv: np maybe one day we will no what was actually wrong :)
13:46:08 <monochrom> in HOL, (∀x. blah) is syntax sugar for ∀(λx. blah). in general, you can write just ∀p where p has the right type.
13:46:13 <amindfv> jfischoff: haha not holding my breath.
13:46:19 <jfischoff> :)
13:46:32 <amindfv> oh, this is great, though! I can finally use cmath and hsc3
13:46:46 <monochrom> it is very nice to have one single local-variable-introduction construct and build on it
13:47:35 <mcstar> y
13:47:41 <mcstar> λ
13:47:50 <mcstar> why didnt i notice this before
13:49:09 <geekosaur> because that only works if you have the right font?
13:49:20 <mcstar> exactly
13:49:29 * mcstar gives away cookie
13:50:25 <vraid> geekosaur:  γ λ, greek letters
13:50:40 <vraid> should sort of work independendtly of font
13:51:07 <monochrom> yes, but we are talking about y and λ looking like rotations of each other
13:51:24 <mcstar> id say mirror image
13:51:36 <monochrom> sorry, mirror image
13:55:45 <ski> nand` : i often use ⌜λ x ↦ y⌝,  (with ⌜↦⌝, not ⌜→⌝)
13:56:25 <shachaf> ski: That's just excessive.
13:57:23 <ski> shachaf : why ? ⌜↦⌝ is the "maps-to" arrow, not ⌜→⌝
13:57:53 <ski> it's either ⌜λ x ↦ y⌝ or ⌜λ x . y⌝, if i'm to use a lambda at all
13:58:26 <shachaf> ski: Wouldn't it just be ⌜x ↦ y⌝?
13:58:41 <ski> (and yes, `UnicodeSyntax' ought to support `↦' there)
13:58:49 <ski> shachaf : that's acceptable as well
14:00:43 <ski> often i use ⌜x ↦ y⌝ for morphisms, and ⌜λ x ↦ y⌝ for elements of exponential object
14:01:10 <mcstar> im reading the curry-howard correspondence on wiki, it goes like this: the parameters are the premises, the return time is the theorem, and it says, the proof can be run, but i dont see how the function body has any relevance here, why does it matter?
14:01:45 <shachaf> mcstar: The whole thing is the theorem, not just the return type.
14:01:54 <shachaf> The function body is the proof of the theorem.
14:02:05 <mcstar> why not just the types?
14:02:13 <shachaf> What?
14:02:46 <mcstar> well, a function body is composed of smaller types, probably with some atomic types, why does the actual code matter?
14:02:55 <mcstar> smaller functions*
14:03:14 <shachaf> What?
14:04:39 <ski> (we basically have ⌜λ : (Γ , τ₀ ⊢ τ₁) → (Γ ⊢ τ₀ → τ₁)⌝ as one of the natural constructions mediating the adjunction)
14:05:36 <mcstar> ah
14:05:53 <ski> (iow, ⌜λ x ↦ y⌝ is really ⌜λ (x ↦ y)⌝, then)
14:06:55 <JoshTriplett> The documentation for Foreign.ForeignPtr.touchForeignPtr explicitly says not to use it to express dependencies between foreign pointers.  What *can* I use to express such dependencies?  I'm building a wrapper for a C library that requires freeing its allocated objects before its main library object.
14:07:29 <JoshTriplett> How do I make sure that a FooX and a FooY get destroyed before the Foo they correspond to?
14:09:05 <JoshTriplett> Or rather, how do I make sure that the user can't call any functions that access a FooX after the underlying Foo got destroyed?
14:11:38 * hackagebot puppetresources 0.1.1 - A program that displays the puppet resources associated to a node given .pp files.  http://hackage.haskell.org/package/puppetresources-0.1.1 (SimonMarechal)
14:12:04 <geekosaur> is this the sort of thing where an existential wrapper would be useful?  something like a custom ST monad?  (or see the monadic regions package for a concrete example)
14:12:52 <Peaker> given a Ptr Word8, how would I write a sequence of bytes (e.g: a strict byte string) to that address?
14:13:06 <Peaker> a bunch of pokes sound like a bad way to do it
14:13:28 <ClaudiusMaximus> @hoogle copyBytes
14:13:29 <lambdabot> Foreign.Marshal.Utils copyBytes :: Ptr a -> Ptr a -> Int -> IO ()
14:14:31 <JoshTriplett> geekosaur: What do you mean by an "existential wrapper"?
14:14:33 <Peaker> ClaudiusMaximus, thanks
14:14:35 * JoshTriplett looks at monadic regions.
14:14:49 <Peaker> and one is supposed to use ByteString.Internal to convert BS to/from Ptrs?
14:15:02 <ClaudiusMaximus> @hoogle useAsCStringLen
14:15:02 <lambdabot> Data.ByteString useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
14:15:02 <lambdabot> Data.ByteString.Char8 useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
14:15:03 <lambdabot> Data.ByteString.Unsafe unsafeUseAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
14:15:15 <Peaker> ClaudiusMaximus, thanks :)
14:15:21 <ClaudiusMaximus> :)
14:16:02 <nand`> is the ‘hoogle’ executable used by @hoogle part of http://hackage.haskell.org/package/hoogle ?
14:16:09 <mm_freak> JoshTriplett: normally you would use region-based I/O for that
14:16:30 <mm_freak> it can statically guarantee that resources can only be used where valid and are freed in the correct order
14:17:39 <mm_freak> that's the basic idea:  withFile :: FilePath -> (forall s. Handle s -> Region s a) -> IO a
14:17:59 <mm_freak> oh, it's already answered =)
14:18:33 <JoshTriplett> mm_freak: Currently trying to wrap my head around that.  To what extent does that force me to make every function passing around such handles monadic?
14:18:45 <JoshTriplett> Because I'd like to manipulate data structures containing the handles in pure code.
14:20:23 <geekosaur> JoshTriplett, do you know how ST works?  it's an existential wrapper which is passed through internal computations; any attempt to pass stuff back out of those triggers a type error because the eistential can't be assigned a type, thus producing static guarantees that something can't escape.  it's the brute force way to keep from leaking infromation.  regions are the finer control way to do it
14:20:43 <JoshTriplett> geekosaur: I have a reasonable idea about how ST works, yes.
14:20:43 <mm_freak> JoshTriplett: you can
14:21:09 <JoshTriplett> So, concrete details: I'm trying to write a Haskellish wrapper around libgit2.
14:21:24 <JoshTriplett> Which requires you to open a git_repository first, and then do various operations on the objects in that repository.
14:21:45 <Peaker> geekosaur, Is the terminology there "existential" or "rigid type variable"?
14:22:15 <geekosaur> Peaker, rigid type variable is the internal type machinery enforcing the existential type
14:22:48 <Peaker> geekosaur, so every positive (covariant) type variable is OK to consider existential, and every negative (contravariant) is universal?
14:23:09 <Peaker> I remember being corrected about using terminology like that
14:23:22 <geekosaur> as I understand it, at least.  existential type is the general concept, rigid type variables are part of how they show up in actual types.  but, I'm no type theorist, so you just spewed nonsense at me
14:24:18 <mcstar> ski: λ : (Γ , τ₀ ⊢ τ₁) → (Γ ⊢ τ₀ → τ₁) do i understand this right? λ is the proof, Γ denotes the axioms, τ₀ ⊢ τ₁ means τ₁ is derivable from τ₀(premises), so the proof states, given the axioms and the premises, it is implied, that τ₀ implies τ₁ si derivable from the axioms?
14:24:42 <fragamus> I have a question.  In a "do" construct I want to conditionally execute    x:xs <- foo based on a condition.
14:25:21 <monochrom> if condition then do { x:xs <- foo } else return ()
14:25:43 <Peaker> error: <- not allowed in last "do" statement
14:26:00 <monochrom> oh, yikes
14:26:11 <monochrom> if condition then do { x:xs <- foo; return () } else return ()
14:26:21 <Peaker> :-) sorry
14:26:38 <monochrom> there ought to be a language extension to allow that!
14:26:43 <fragamus> thanx ill try it
14:26:48 <JoshTriplett> But note that the binding won't exist in the outer scope.
14:26:49 <EvanR> implicit effects!
14:27:04 <JoshTriplett> Which makes such an extension rather pointless. :)
14:27:07 <Peaker> I really hate pattern matching in <-    "fail" sucks.. if you intend to match irrefutably (1 constructor) you get a runtime error if you ever add a second constructor
14:27:36 <JoshTriplett> Peaker: I hate it in IO; it can make sense in Maybe or List.
14:27:53 <EvanR> what does fail in IO do?
14:28:01 <monochrom> the pointless answer is intentional, in context of a poor question
14:28:03 <JoshTriplett> throw an exception.
14:28:17 <EvanR> meh
14:28:28 <JoshTriplett> EvanR: exactly.
14:28:45 <nand`> except it doesn't make sense in Either String
14:28:49 <roconnor_> @type first
14:28:50 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
14:28:50 <nand`> where it's error
14:35:50 <mcstar> ski in the sky
14:38:11 <scb> Hello. I am writing a simple interpreter in Haskell which needs to have a "read" from standard I/O instruction. I am unsure on how to do this in haskell considering the IO monad and all of that.
14:38:53 <scb> What is the best way to get the value out of a IO(String), for example? Is my only play here to use unsafeperformIO? Or I am doing it completely wrong (this is most likely)?
14:39:21 <mcstar> shachaf: im going to read this http://www.thenewsh.com/~newsham/formal/curryhoward/ , maybe i can ask better questions after that
14:39:24 <geekosaur> an interpreter almost certainly should be a monad stack with IO at its base; a pure interpreter can't actually do much of anything
14:39:34 <mm_freak> scb: the latter
14:39:41 <geekosaur> if nothing else, there is presumably some internal state
14:39:44 <shachaf> scb: There is no value in an IO String.
14:39:46 <shachaf> @quote /bin/ls
14:39:46 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:39:59 <mm_freak> scb: IO String is not a "wrapped string" or something like that
14:40:01 <geekosaur> ^^ that
14:40:02 <mm_freak> it's an action
14:40:03 <shachaf> scb: You should stop and read about how I/O works in Haskell.
14:40:09 <shachaf> @google introduction to io in haskell
14:40:12 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
14:40:12 <lambdabot> Title: Introduction to IO - HaskellWiki
14:40:16 <shachaf> Read that.
14:40:32 <shachaf> scb: See also the FAQ:
14:40:33 <shachaf> @where faq
14:40:34 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:45:12 <Peaker> treating a (Ptr a) as a mutable array does the sensible thing, right? (multiplies index by size)
14:45:33 <mm_freak> Peaker: see Storable
14:45:42 <weexplat> whoa, people talking about both kinds of indexed monads
14:45:49 <weexplat> who is using them?
14:46:08 <mm_freak> what's an indexed monad?
14:46:23 <Peaker> oh wait, Ptr isn't an instance of MArray
14:47:04 <mm_freak> would be pretty weird to have an MArray instance for Ptr
14:47:17 <Peaker> why?
14:47:26 <Peaker> very C like
14:47:27 <mm_freak> how would you implement getBounds?
14:47:41 <mm_freak> Storable does exactly what C does
14:47:47 <Peaker> ah, right, arrays are safe
14:47:50 <shachaf> "Array" in Haskell is a different thing from "array" in C.
14:48:01 <shachaf> For that matter, in C, foo[bar] isn't an array operation at all. :-)
14:48:04 <Peaker> any way to make an IOUArray from a (Ptr a) and a size?
14:48:07 <shachaf> (As mauke tends to point out, I think.)
14:48:23 <mm_freak> Peaker: no, for that better use Vector
14:48:38 <mm_freak> in particular see Data.Vector.Storable
14:49:00 <Peaker> is it an instance of MArray or does it have its own classes?
14:49:19 <mm_freak> has its own interface independent of IArray/MArray
14:49:41 <Peaker> is the duplication meant to deprecate arrays?
14:50:04 <mm_freak> i think the two are simply unrelated…  the interface is based on PrimMonad
14:50:11 <clsmith> hey. this might be a stupid question, but what is the ghc core 'zh' suffix all about?
14:51:07 <clsmith> ah, i should have searched better. apparently it's to encode hashes, e.g. Int#
14:51:18 * clsmith answers own question...
14:52:21 <danr> yes, the z-encoding
14:52:56 <shachaf> mauke: seen preflex
14:53:48 <shachaf> Peaker: Foreign.Storable will let you do peeks and pokes at offsets from a Ptr.
14:53:49 <Peaker> easy way to convert (Ptr a) to (ForeignPtr a)?  newForeignPtr wants a FunPtr finalizer.. can it be given nullPtr therE?
14:54:26 <Peaker> shachaf, I would rather work with the ptr via an array interface
14:54:50 <Peaker> (it will point at an unboxed array of Word64's)
14:54:52 <shachaf> With bounds checking?
14:54:54 <mm_freak> Peaker: why Ptr anyway?
14:54:59 <Peaker> bounds checking is ok
14:55:07 <Peaker> mm_freak, because I get it from mmap
14:55:18 <mm_freak> Peaker: the you should really use Data.Vector.Storable
14:55:24 <Peaker> mm_freak, I will
14:55:27 <mm_freak> it's an array interface to Ptr
14:55:30 <mm_freak> basically
14:55:32 <Peaker> it wants a ForeignPtr
14:55:55 <shachaf> Peaker: Oh, Data.Array.Storable?
14:56:12 <nobdraisentone> What is the point in Church numerals? For example, `0 := λf → λx → x'. It's actually looks like `f _ x = x'. Where is a 0 came from?
14:56:26 <shachaf> nobdraisentone: It's a definition.
14:56:29 <Peaker> shachaf, I'm trying to understand the difference between that and the equivalent Vector.Storable?
14:56:31 <nand`> nobdraisentone: the number represents how many times ‘f’ gets applied to the second argument
14:56:40 <nand`> nobdraisentone: that's why ‘f’ is ignored for 0
14:56:53 <Peaker> is Vector for fusion purposes?
14:57:13 <raek> is it possible to have something like "instance (Functor f, Show a, Show (f a)) => Show (Foo f a) where" without -XFlexibleContexts?
14:57:16 <Peaker> if that's the case I think array is simpler/less over-designed for my purposes
14:57:22 <nand`> nobdraisentone: but for example 2 is defined as 2 := λf → λx → f (f x)
14:57:58 <raek> or is situations like these simply what -XFlexibleContexts was made for?
14:57:58 <nobdraisentone> nand`: er, is it usable?
14:58:05 <nand`> nobdraisentone: they're just given in the common format to make it easier to compare them; sure 0 = const and 1 = id and 2 = join (.) or whatever
14:58:06 <monochrom> "getLine :: IO String" means that in "getLine >>= \s -> ...", in the "..." you have s referring to the input string. in other words, look at "getLine >>=" as a whole. "getLine >>= callback" calls your callback with the input string as parameter.
14:58:10 <nand`> nobdraisentone: church numerals? they can be
14:58:33 <mm_freak> Peaker: file:///usr/share/doc/ghc/html/libraries/base-4.5.1.0/Foreign-ForeignPtr-Safe.html
14:58:36 <mm_freak> uhm
14:58:42 <mm_freak> yeah, see that module in your docs =)
14:58:48 <shachaf> raek: I don't think so.
14:58:54 <mm_freak> it's easy to construct a ForeignPtr from a Ptr
14:58:58 <nand`> nobdraisentone: for example they can be used to represent numbers in abstract models of computation in which you don't have ‘types’ like Int
14:59:04 <nand`> or ‘values’ like 1
14:59:08 <nand`> but just functions / combinators
14:59:15 <mm_freak> the finalizer is there to allow cleanup, like stopping the mmap
15:00:04 <Peaker> mm_freak, thanks
15:00:16 <Peaker> mm_freak, why Vector.Storable and not Array.Storable, btw?
15:00:33 <Peaker> array seems simpler and a lighter dependency?
15:01:15 <mm_freak> Peaker: i didn't even know that Data.Array.Storable exists =)
15:01:33 <Peaker> ah ok, me neither :)
15:01:34 <mm_freak> personally i'd still go with vectors, because the interface is much more convenient
15:01:49 <Peaker> all I need is readArray/writeArray
15:03:56 <mm_freak> Peaker: all you need is lambda abstraction, application and variables for that matter =)
15:05:08 <Peaker> heh
15:05:20 <Peaker> what extra convenience do you enjoy in vector?
15:06:54 <monochrom> the vector package adds a lot of fusion rules etc, i.e., you may write functionally and still get fast code
15:07:48 <monochrom> API-wise, it does limit you to 0..n-1 indexes of type Int
15:09:30 <raek> is it a common convention to name record fields like "getFoo" when you want to export accessor functions, but not the constructors?
15:09:40 <raek> or is just "foo" more common?
15:09:54 <raek> (I've seen "runFoo" too)
15:10:31 <shachaf> runFoo is often used for monads or other things that are "runnable".
15:10:51 <Philippa> if you just want to export it as an accessor, you can wrap foo as getFoo anyway
15:11:09 <Philippa> but get isn't so common unless it's actually an action of sorts
15:12:22 <raek> so a function that extracts the "foo" part of a value is more commonly named just "foo"?
15:13:02 <shachaf> That depends on the purpose.
15:13:14 <shachaf> An accessor could be a lot of things.
15:17:48 <roconnor_> @tell edwardk setters are conal's semenatic edit combinators
15:17:48 <lambdabot> Consider it noted.
15:18:30 <conal> roconnor_: which setters? from the name i wouldn't expect them to be the same.
15:18:32 <mm_freak> raek: in haskell commonly verbs are associated with monads
15:18:37 <mm_freak> getFoo :: A -> Foo
15:18:39 <mm_freak> uhm
15:18:43 <mm_freak> getFoo :: A -> Monad Foo
15:18:50 <mm_freak> while:  foo :: A -> Foo
15:19:17 <conal> mm_freak: i haven't noticed a correlation between verbs & monads. maybe verbs & imperative stuff.
15:19:21 <mm_freak> usually imperative monads like IO or State
15:19:34 <roconnor_> conal: setters are perhaps a bad name.  they are "Modifiers" from http://comonad.com/reader/2012/mirrored-lenses/
15:19:58 <roconnor_> ... maybe I'll renamed them to "Editors"
15:20:16 <conal> roconnor_: "modifiers" does sound closer. though SECs are combinators *on* modifiers/editors.
15:20:25 <mm_freak> conal: yeah, sure…  and mostly imperative implies monadic
15:20:47 <roconnor_> conal: okay, then "setters" or "modifiers" are the things that your combinators act on
15:20:47 <conal> mm_freak: and mostly not the other way around.
15:21:06 <roconnor_> naming is hard
15:21:23 <conal> roconnor_: yeah, it is!
15:21:23 <roconnor_> conal: er
15:21:29 <roconnor_> conal: I don't know
15:21:42 <roconnor_> conal: whatever the type (b -> b') -> a -> a' things are
15:21:50 <tgeeky> jfischoff: second derivatives?
15:21:53 <tgeeky> err
15:21:56 <tgeeky> roconnor_: second derivatives?
15:21:58 * roconnor_ is a little lost in the higherorderness
15:22:27 <conal> roconnor_: if a (b -> b') is the editor, then a (b -> b') -> (a -> a') is an editor combinator
15:22:35 <tgeeky> jfischoff: I can't compile #pee anymore, because I'm on Windows and readline support evidently doesn't work
15:22:45 <conal> roconnor_: that was my thinking behind "editor combinator".
15:23:06 <jfischoff> tgeeky: it should be using haskeline
15:23:10 <conal> and "semantic" is to distinguish from the usual syntactic notion of editing
15:23:19 <jfischoff> tgeeky: if there are readline deps remove them
15:23:40 <roconnor_> conal: okay, the the Modifiers are edit combinators
15:23:44 <roconnor_> *then the
15:24:51 <conal> roconnor_: oh, okay. though perhaps "modifier modifiers" would be clearer (more specific), since they're not arbitrary modifiers.
15:25:11 <tgeeky> conal: that's why I said second derivative :)
15:25:24 <roconnor_> conal: I don't think there is anything clear about "modfier modifiers"
15:25:47 <conal> roconnor_: :)
15:26:29 <conal> roconnor_: it has the benefit of being a more accurately specific/restrictive.
15:26:50 <conal> roconnor_: since they don't modify any old thing. but they modify modifiers of any old thing.
15:26:50 <jfischoff> tgeeky: I'll remove the readline stuff if you have any trouble with it
15:27:25 <conal> roconnor_: not a serious suggestion. i'd go with "semantic editor combinator" .
15:28:26 <tgeeky> jfischoff: i was just informing you that it didn't automatically compile. not that you need to do anything (yet) :o
15:32:09 <solrize> hey conal
15:32:15 <ski> twinkle twinkle little mcstar
15:32:18 <conal> solrize: hi
15:32:20 <ski> mcstar : in ⌜Γ , τ₀ ⊢ τ₁⌝,  ⌜Γ , τ₀⌝ is the premises
15:32:22 <solrize> your memotrie library is about 2x as fast as memocombinators
15:32:23 <shachaf> hi conal
15:32:35 <conal> shachaf: howdy
15:32:41 <mcstar> ski: ah, ok
15:32:44 <ski> mcstar : if you replace "axioms" by "premises", then what you said sounds more or less right
15:32:59 <solrize> i stilll have not figured out where the differences come from
15:37:25 <solrize> is dons ever around any more?  i wish he could look at this
15:38:46 <kallisti> anyone here familiar with FC++ ?
15:38:59 * kallisti might try it out soon.
15:40:12 <raek> ok, I see. thanks, mm_freak and shachaf!
15:41:42 <raek> I made a pair of types to abstract away mutual recursion from environments in my toy language interpreter: https://gist.github.com/3043816
15:43:46 <dylukes> pipes-core has an extra implementation of pipes called "PutbackPipe" that lets data be reinserted in the input stream...
15:43:58 <dylukes> Can anyone think of a way to cheat and do this with pipes 2?
15:44:08 <dylukes> (specifically with Frames)
15:44:50 <JoshTriplett> In c2hs, if I have a function with a typedefd_struct **outparam, how do I declare that?
15:45:15 <JoshTriplett> I need to have spacefor a typedefd_struct *, pass a pointer to that pointer, then return the pointer.
15:45:18 <pcapriotti> dylukes: use StateT [a] (Pipe a b m)
15:45:32 <dylukes> pcapriotti: Ohey.
15:45:38 <dylukes> I'm not using Pipe, I'm using Frame.
15:45:50 <dylukes> Gonzalez went ahead and DID reimplement it all with restricted indexed monads.
15:46:00 <pcapriotti> right, s/Pipe/Frame/
15:46:21 <dylukes> That'd complexify the whole stack though :\.
15:46:32 <solrize> are restricted indexed monads something different than the "m x y a" monads used in various places?
15:46:35 <dylukes> I'd ideally like to keep takeChunk :: Int -> Frame ByteString IO (M ByteString) (M ByteString) ()
15:46:36 <pcapriotti> just use it where you need leftovers
15:47:02 <dylukes> I'm writing a frame that behaves like a blocking take. That is, it "rechunks" the input Bytestring stream.
15:47:21 <dylukes> solrize: m i j a, yeah
15:47:25 <pcapriotti> yeah, you can't do that
15:47:32 <dylukes> or in this case they're written: m (a := j) i
15:47:40 <kallisti> JoshTriplett: Ptr (Ptr dStruct )
15:47:44 <kallisti> *DStruct
15:47:46 <pcapriotti> or, you can, but it won't be composable with other Frames
15:47:49 <kallisti> where DStruct is an instance of Storable
15:48:02 <solrize> ic  thanks
15:48:06 <dylukes> pcapriotti: Do you mean you *can't*, or there's not an easy/feasible solution?
15:48:30 <JoshTriplett> kallisti: That would be the type in FFI, but in c2hs I've declared an opaque {#pointer ... #} type for it.
15:48:33 <pcapriotti> the only solution that I know of is to add a StateT
15:48:42 <JoshTriplett> kallisti: And I'd like to end up with that opaque type.
15:48:51 <dylukes> If you could capture the continuation of the stack/pipeline, you could yield the leftovers into the rest.
15:48:59 <pcapriotti> then you can write a new composition function for StateT Pipes
15:49:02 <kallisti> JoshTriplett: is that a new feature of c2hs? I'm not familiar with it.
15:49:17 <JoshTriplett> kallisti: http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/implementing.html#id315561
15:49:35 <pcapriotti> the problem is that pipes-with-leftovers do not have a general associative composition
15:49:57 <pcapriotti> the best you can do is compose a leftover-pipe upstream with a non-leftover-pipe downstream
15:50:13 <pcapriotti> conduit works like that too
15:50:20 <pcapriotti> but the StateT is implicit
15:50:28 <JoshTriplett> kallisti: I'm trying to write the {#fun ... #} line for the function that creates one of these objects.
15:52:08 <kallisti> JoshTriplett: and you want the **outparam to be an opaque user-facing type?
15:52:29 <dylukes> hrm
15:53:30 <JoshTriplett> kallisti: A pointer to one, yeah.  Specifically, I want to translate the C function signature "int func(opaque **, char *)" into the Haskell type String -> Opaque.  (The int represents an error code that I'll handle separately, and Opaque corresponds to opaque* in C.)
15:53:43 <JoshTriplett> Sorry, that should be String -> IO Opaque. :)
15:53:46 <dylukes> pcapriotti: I'm wondering if there's a way to sort of build up a "resevoir" of leftovers... I guess that's what the StateT means.
15:54:00 <kallisti> JoshTriplett: is func referentially transparent?
15:54:02 <JoshTriplett> kallisti: Does that make sense?
15:54:05 <JoshTriplett> No, not even close.
15:54:11 <JoshTriplett> Hence the IO.
15:54:13 <kallisti> oh right. you corrected yourself.
15:54:37 <kallisti> yes that makes sense, but I don't think the pointer pragma will do that for you.
15:54:46 <kallisti> you might just have to an explicit newtype.
15:54:54 <JoshTriplett> kallisti: That would kinda suck.
15:55:01 <kallisti> newtype Opaque = Opaque (Ptr (Ptr Opaque))
15:55:03 <kallisti> there. I did it for you.
15:55:08 <JoshTriplett> That's the wrong type.
15:55:16 <kallisti> it is?
15:55:26 <JoshTriplett> Every other function in the API uses "opaque *" as an input parameter.
15:55:39 <JoshTriplett> The functions that *create* an opaque* use an opaque** as an out parameter.
15:55:47 <kallisti> ah I see.
15:55:50 <JoshTriplett> So I want the Haskell type to correspond to opaque*, not opaque**.
15:55:54 <pcapriotti> dylukes: yep
15:56:18 <dylukes> so really, I could dodge the StateT and just use a locally bound function with an extra argument for leftovers, and recurse maybe
15:56:22 <JoshTriplett> kallisti: Sorry, I guess I should have made that more clear from the start.
15:56:23 <kallisti> JoshTriplett: you'll want an FFI binding and then a higher level wrapping that peeks at the ptr and extracts the inner pointer.
15:56:56 <JoshTriplett> kallisti: {# pointer opaque as ^ newtype #} produces the correct newtype declaration: newtype Opaque = Opaque (Ptr (Opaque))
15:56:59 <kallisti> oh, and newtype wraps it.
15:57:06 <kallisti> right
15:57:25 <pcapriotti> dylukes: sure, you can do that, that would be equivalent to unwrapping the StateT immediately
15:57:29 <JoshTriplett> kallisti: So, I have to explicitly write a peek function to pull an Opaque out of a Ptr Opaque?
15:57:34 <JoshTriplett> kallisti: Shouldn't that exist already?
15:57:43 <kallisti> so you'd import the raw FFI binding:  Ptr Opaque -> CString -> IO Int
15:57:45 <dylukes> which is basically what I want.
15:57:48 <pcapriotti> dylukes: but then you can't actually make use of the leftovers outside that pipe
15:57:57 <kallisti> then allocate some space
15:57:57 <dylukes> Well I'm not trying to...
15:58:07 <dylukes> Think of it as a thinning of a river.
15:58:23 <dylukes> The bytestrings are coming through in chunks and I just want to stop it off and trickle out blocks of some sie.
15:58:24 <kallisti> then pass that into the FFI binding, and then Opaque <$> peek myOpaquePtrPtr
15:58:31 <JoshTriplett> kallisti: I'd hoped I could write that parameter with c2hs as something like: alloca- `Opaque` somethingGoesHere*
15:58:37 <JoshTriplett> Er, `Opaque'
15:58:45 <pcapriotti> well, if you want to implement `take`, you need to keep track of the leftovers after take terminates
15:58:50 <JoshTriplett> I just don't know what somethingGoesHere is. :)
15:58:59 <pcapriotti> for example, I guess you want take n >> take m == take (n + m)
15:59:00 <kallisti> JoshTriplett: oh. I'm unfamiliar with all these new c2hs features.
15:59:32 <JoshTriplett> c2hs is trying to provide marshallers.
15:59:46 <JoshTriplett> Kinda seems like the point of using c2hs. :)
15:59:56 <JoshTriplett> I don't know what older versions of c2hs did.
16:00:04 <kallisti> the actual code to implement what I'm suggesting isn't very difficult.
16:00:23 <kallisti> however I think you'd want a ForeignPtr so you can free memory on finalization.
16:00:32 <kallisti> unless you need it to hang around in the C code.
16:00:34 <dylukes> pcapriotti: That's true :\.
16:00:47 <JoshTriplett> kallisti: I haven't gotten to that point yet. :)
16:00:54 <pcapriotti> dylukes: one thing you can do, however, is return the unconsumed portion
16:01:12 <dylukes> Right, I can do that, but then what do I do with it?
16:01:14 <kallisti> JoshTriplett: is it okay if the memory is freed when the opaque type is garbage collected? or will that break C code?
16:01:33 <kallisti> if so, then you can just use a ForeignPtr
16:01:37 <pcapriotti> dylukes: then you have to thread it manually when you use `take` inside the monad
16:01:41 <JoshTriplett> kallisti: In theory, it's OK, except for various ordering requirements for when you can destruct things.
16:01:53 <dylukes> This is in the context of unpacking packets from a byte stream.
16:02:05 <kallisti> hm, okay. sometimes the ordering can be masked by clever library interface.
16:02:15 <kallisti> so that you can only access things in a specific order.
16:02:22 <kallisti> but anyway.
16:02:35 <JoshTriplett> kallisti: Yeah, I *think* the ordering requirements go away because anything that would depend on the top-level type still existing requires a parameter of that type. :)
16:03:18 <JoshTriplett> But in any case, I'd like to get it working first, and then worry about how to handle the memory reclamation sensibly.
16:03:19 <kallisti> JoshTriplett: yes, or has a mutable reference to it.
16:03:25 <kallisti> JoshTriplett: which is garbage collected properly.
16:03:41 <JoshTriplett> kallisti: I meant that any C function using that object has a parameter of that type, I think.
16:03:43 <kallisti> I'd need to read through this documentation to really provide good answers on how to leverage c2hs. I can easily explain the bruteforce Haskell approach though.
16:04:04 <JoshTriplett> kallisti: I understand the brute-force Haskell approach pretty well; that's a large motivation for wanting to use c2hs. :)
16:04:04 <kallisti> JoshTriplett: oh. that's not really an indication that it's safe to deallocate.
16:05:08 <JoshTriplett> kallisti: Oh, I think I figured out how to handle this.
16:05:09 <kallisti> you'd need to follow the documentation of that C library. usually it would specify any gotchas regarding deallocation.
16:05:10 <JoshTriplett> Let me check...
16:05:17 <JoshTriplett> kallisti: It does, extensively. :)
16:05:23 <JoshTriplett> kallisti: Though not very clearly.
16:06:42 <kallisti> a ForeignPtr would be safe, if, at any moment when your function releases the Opaque type "in the wild", there is no reference to it in any C code.
16:07:04 <JoshTriplett> kallisti: That's my concern, yeah.
16:08:23 <kallisti> JoshTriplett: is there online docs for this library?
16:08:39 <JoshTriplett> kallisti: http://libgit2.github.com/libgit2/
16:08:57 <kallisti> oh...
16:09:17 <JoshTriplett> kallisti: (I've already looked at the HGit2 bindings, and found them fairly incomplete, as well as not very idiomatic.)
16:09:29 <JoshTriplett> Plus, I figured it would be a good opportunity to learn c2hs.
16:10:51 <JoshTriplett> kallisti: The reclamation requirements appear to amount to "you can destroy the objects either before or after the repository they belong to, but don't try to access anything interesting about the objects if you've destroyed their repository".
16:11:19 <kallisti> JoshTriplett: one nice way to deal with allocation/deallocation is via with* functions
16:11:24 <JoshTriplett> kallisti: Planning on it.
16:11:26 <JoshTriplett> withRepository ...
16:11:40 <kallisti> yes, but even better, you can have your own monad wrapper.
16:11:41 <JoshTriplett> But I still need to write the underlying binding. :)
16:11:54 <JoshTriplett> kallisti: Someone pointed me at monadic regions, yeah.  I'll have to look into those further.
16:12:55 <kallisti> basically you just have a newtype wrapper over IO (or some monad transformer that would be useful for you to have), and then your outward facing API is defined in this monad, so that your bindings can only execute within a runMyMonad call.
16:13:34 <JoshTriplett> Ah, I see.  Sure, I could have withRepository provide a GitT monad or similar.
16:13:37 <kallisti> but it sounds like you'll need to do something trickier than that unless you want to end up with a lot of with* stuff
16:13:45 <JoshTriplett> Yeah.
16:13:48 <kallisti> JoshTriplett: just "Git" since it has an IO base.
16:13:58 <JoshTriplett> I suspect that "something trickier" amounts to monadic-regions.
16:16:21 <kallisti> JoshTriplett: ah I see, so c2hs now lets you call C functions without explicit FFI imports.
16:16:30 <kallisti> and it will generate them for you.
16:16:30 <JoshTriplett> Right.
16:16:43 <JoshTriplett> And generate the marshalling code for you too.
16:19:01 <JoshTriplett> kallisti: I don't know if I have this correct yet, but I *think* I need to declare the Repository type separately so that I can make the opaque type itself an instance of Storable.
16:19:20 <JoshTriplett> kallisti: And then I can use {#pointer *repository as ^ newtype nocode #}.
16:19:26 <kallisti> what is opaque actually?
16:19:51 <JoshTriplett> git_repository.
16:20:11 <JoshTriplett> kallisti: http://libgit2.github.com/libgit2/#HEAD/group/repository/git_repository_open
16:20:20 <JoshTriplett> kallisti: I want to call that, with type String -> IO Repository.
16:20:33 <JoshTriplett> And I *think* I've gotten it right, but I need to test it.
16:23:34 <kallisti> JoshTriplett: even while using #fun it looks like you need to provide marshaling functions for your opaque type.
16:24:01 <JoshTriplett> kallisti: True, but Storable provided the ones I needed.
16:24:28 <kallisti> ah right, you just need to remove the double indirection
16:24:33 <JoshTriplett> kallisti: {# fun repository_open as ^ { alloca- `Repository' peek*, `String' } -> `()' #}
16:26:26 <JoshTriplett> kallisti: I still need to figure out how I want to handle GC, but otherwise this seems to work.
16:26:36 <kallisti> oh, yeah that will work.
16:27:27 <JoshTriplett> And for another function that takes a git_repository *, I can do this: {# fun repository_path as ^ { id `Repository' } -> `String' #}
16:27:41 <JoshTriplett> Having to explicitly provide a marshaller of "id" seems like a hack, but oh well. :)
16:34:07 <kallisti> JoshTriplett: I don't know, I'd honestly prefer the regular Haskell code in this case.
16:34:22 <JoshTriplett> kallisti: For a half-dozen functions, I agree.  For a hundred...
16:34:27 <kallisti> but mainly because I don't fully understand what's going on with these c2hs pragmas.
16:34:42 <JoshTriplett> You can pretty easily read the code they translate to.
16:35:55 * JoshTriplett pulls up hpaste.]
16:36:22 <hpaste> JoshTriplett pasted “c2hs output” at http://hpaste.org/70842
16:36:28 <JoshTriplett> kallisti: ^
16:37:33 <kallisti> hm, okay.
16:38:04 <JoshTriplett> kallisti: It's a very mechanical translation.
16:38:18 <kallisti> repositoryPath is a #get yes?
16:38:34 <kallisti> oh no another #fun
16:38:54 <JoshTriplett> kallisti: Right.  git_repository is an opaque struct, and there exists a git_repository_path function.
16:39:11 <JoshTriplett> const char *git_repository_path(git_repository *)
16:39:16 <kallisti> right.
16:39:41 <JoshTriplett> There exist very few non-opaque structures in libgit2, though at the moment I'm poking at one of them (git_error).
16:41:33 <kallisti> JoshTriplett: while opaque structs are good practice, a non-opaque struct would make it easier to pass around repositories as records and have referentially transparent accessors
16:41:54 <JoshTriplett> kallisti: Granted, but it would also make the library API less stable.
16:41:59 <kallisti> yes.
16:42:20 <JoshTriplett> And I don't mind that all of the functions here live in IO.
16:43:17 <kallisti> JoshTriplett: I think if you use a newtype'd monad then you'd be free to use a ForeignPtr for repositories
16:43:35 <JoshTriplett> kallisti: I may still do that.
16:43:55 <kallisti> actually you may not need the newtype.
16:44:54 <kallisti> yeah it looks to me like if you call all the proper C finalizers then you'll have no issues.
16:45:24 <JoshTriplett> kallisti: Possibly.  Not completely confident that I'll end up with a sensible result, but I plan to try that. :)
16:47:04 <kallisti> JoshTriplett: well you won't end up with Haskell code attempting to use memory that doesn't exist anymore.
16:47:25 <JoshTriplett> kallisti: I agree with *that* statement.  I might end up with C code attempting to use memory that doesn't exist anymore. :)
16:48:26 <kallisti> not with repositories at least. assume that it's the "top level" struct in the system.
16:48:29 <kallisti> (assuming
16:49:10 <kallisti> also assuming that no other structs have access to it, but that's not a given I guess.
16:49:30 <JoshTriplett> kallisti: That's my concern, yeah.  I don't know for sure that other structs don't keep internal references to their repository.
16:49:57 <kallisti> ah. here's an idea: for structs that have references to other structs, you can represent them as records with fields that point to other records. Externally they appear as opaque type.
16:50:27 <JoshTriplett> Mirroring the internal C references?
16:50:31 <kallisti> yes.
16:50:31 <JoshTriplett> That makes sense.
16:50:37 <JoshTriplett> Assuming I figure out that such references exist. :)
16:53:24 <JoshTriplett> kallisti: Rather impressed that this worked: str <- {# call giterr_last #} >>= {# get git_error->message #} >>= peekCString
16:54:45 <Bytter> does anyone know of a paper that explores the relation between an unfold and the state monad?
16:58:20 <kallisti> JoshTriplett: going for typed IO exceptions?
16:58:38 <JoshTriplett> kallisti: Extensible exceptions, but yeah.
16:58:52 <kallisti> some C errors are better represented as things like Maybe and Either, and others as exceptions.
16:59:02 <kallisti> the things you'd commonly check should be Maybe or Either most likely.
16:59:09 <JoshTriplett> kallisti: Agreed.
16:59:17 <JoshTriplett> kallisti: But in this case, most errors will be fatal.
16:59:32 <JoshTriplett> kallisti: (Or at least, fatal to the high-level operation I want to do, such as "go find this file in a repository".)
16:59:42 * kallisti isn't familiar with extensible-exceptions
16:59:52 <JoshTriplett> kallisti: Control.Exception.
17:00:07 <kallisti> oh. nevermind.
17:03:59 <JoshTriplett> kallisti: Well, thanks for the help.
17:44:23 <dylukes> pcapriotti: btw does Gabriel go on IRC at all?
17:49:34 <byorgey> preflex: xseen Cale
17:49:35 <preflex>  Cale was last seen on freenode/#haskell 1 day, 1 hour, 10 minutes and 15 seconds ago, saying: It's a convenient choice that we've made into a fact by definition :)
17:50:02 <byorgey> @ask Cale is http://code.haskell.org/lambdabot/ still the canonical repo?
17:50:02 <lambdabot> Consider it noted.
17:59:48 <hpc> byorgey: it might actually be github now
18:11:23 <weexplat> @hoagie Int -> [a] -> a
18:11:24 <lambdabot> Prelude (!!) :: [a] -> Int -> a
18:11:24 <lambdabot> Data.List (!!) :: [a] -> Int -> a
18:11:24 <lambdabot> Prelude drop :: Int -> [a] -> [a]
18:12:56 <byorgey> hoagie hehe
18:16:56 <heatsink> @boggle (a -> Bool) -> [a] -> [a]
18:16:56 <lambdabot> Maybe you meant: google hoogle
18:16:58 <heatsink> darn
18:17:27 <Boney> hoagie reminds me of an actors name.
18:17:32 <Boney> Paul Hogan.
18:17:50 <Boney> *bad memories*
18:23:21 <solrize> http://hpaste.org/70844   why does hlint say to reduce duplication at line 182?
18:24:47 <MostAwesomeDude> solrize: Click and see.
18:24:58 <MostAwesomeDude> solrize: It recommends somehow unifying with line 204.
18:25:42 <shachaf> I didn't know it did that.
18:26:01 <solrize> oh i didn't know that link was clickable.  but, those expressions have different types...
18:26:07 <hpc> huh, i didn't realize it collapses hlint
18:26:09 <hpc> <3 noscript
18:30:24 <kuhrt> For a few months I've been trying to get a handle on the haskell web develop scene, options, packages, etc. but when I came across meteor.com it seemed to be something new that haskell has no answer to (yet) where as Rails/Django/etc have general equivilants in haskell... snap, yesod, etc
18:31:01 <kuhrt> so my question would be to know the thoughts of anyone who is a haskeller and seen meteor
18:31:21 * MostAwesomeDude checks
18:31:48 <hpc> it looks horrific
18:32:04 <hpc> it's impossible to make the site work in ff+noscript
18:32:07 <kuhrt> the fact that there is no defacto haskell-to-js compiler complicates things from my pov
18:32:11 <hpc> it triggers too many exploit heuristics
18:33:21 <kuhrt> hpc: i'm not sure what you mean, i'm not sure if meteor is targeted to a noscript context
18:34:12 <hpc> kuhrt: then it isn't targetting blind people, screen readers, browsers like silk that do server-side processing, ...
18:34:21 <shergill> kuhrt: the question you have to ask yourself is: do you _want_ to write in js?
18:34:29 <mightybyte_> kuhrt: Yeah, anything entirely javascript sounds generally horrible to me too.
18:34:33 <blackdog> kuhrt: I acutally kinda like it.
18:34:45 <dmwit> There are several packages for generating Javascript on Hackage.
18:34:47 <kuhrt> hpc: i guess you're getting ahead of me, its not what i'm interested in knowing at this stage
18:35:07 <dmwit> meteor.com seems to be big on hype on small on tech descriptions, though, so it's kind of hard to say what features you want.
18:35:11 <blackdog> for what it does, it's pretty nice. my biggest beef with it is that authentication & authorization seem a bit tacked on - the guys at Bridge seem to have thought about it more deeply.
18:35:22 <hpc> my point is, you would never write a website in that framework and expect it to be something the general public would be able to use
18:35:30 <mightybyte_> kuhrt: Have you seen http://elm-lang.org/ ?
18:35:35 <kuhrt> shergill: to refine my question, how close can I match their dev experience with current haskell tools
18:36:03 <blackdog> hpc: you're explicitly cutting out a section of the public in the interests of quickly building something that can be used by 75% of people
18:36:12 <shergill> kuhrt: what aspect of their experience?
18:36:16 <solrize> meteor.com shows a background image with rocket ships, nothing else.  am i missing something?
18:36:37 <shergill> solrize: js
18:36:47 <blackdog> kuhrt: you can't. you'd need to write the js layer yourself, or write an adaptor. they do have a protocol called DDP or something similar, but it's not terribly well documented.
18:37:50 <kuhrt> mightybyte_: I think I have. I would prefer to write all my back-end/front-end in haskell if possible
18:38:14 <solrize> shrergill i see it downloaded a 100k file of obfuscated js but it didn't seem to put anything on the screen
18:38:17 <solrize> shergill
18:38:38 <shergill> kuhrt: yesod + elm might be something you may want to check out
18:38:47 <shergill> kuhrt: it's still a wip
18:39:07 <solrize> if you're looking for a pointy headed FPL that does stuff with javascript, try ur
18:39:12 <shergill> solrize: hmm no idea. after temporarily allowing it in noscript it worked fine here
18:39:13 <mightybyte_> You should be able to use elm with any of the three frameworks without too much trouble.
18:39:14 <solrize> impredicative.com
18:39:16 <MostAwesomeDude> kuhrt: From what I can tell, Meteor just looks like yet another JS wankery system.
18:39:22 <kuhrt> shergill: maybe the video would be more informative than me, but the front-end database API and deployment ease are nice for example
18:39:30 <solrize> http://impredicative.com/ur/
18:40:28 <startling> "I'm going to /wrists if I have to keep writing web applications the old stupid way for much longer."
18:40:31 <startling> ugh what
18:40:45 <solrize> oh there's a video?  flash?  no wonder i didn't see it, i don't have the plugin
18:41:12 <kuhrt> shergill: it also takes care of binding between views and model, rather well it seems, and the framework has a pretty sweet way of packing code for client or server or both, it kind of feels like coding one thing instead of two... but ya i'm not the best person to make a clear case or feature description
18:41:17 <hpc> startling: i read that as "i don't know how to make a website without joomla" :P
18:41:38 <startling> hpc: "and also i'm in seventh grade"
18:42:29 <hpc> i am starting to be a big fan of compiled websites
18:42:45 <hpc> either the happstack way or just in the making lots of cgi binaries way
18:43:25 <shergill> kuhrt: don't have flash here =/ but some of what you're describing is easily done in yesod eg. the binding between views and model. the only thing missing with yesod is clientside stuff which elm is targeting
18:43:27 <solrize> hpc, okws.org sort of has the right approach, wrong language
18:44:00 <blackdog> I'm a bit surprised by all the JS hate here. This is something that it's currently pretty hard to do on a Haskell stack.
18:44:05 <kuhrt> shergill: and there's nothing in the haskell community now (or wip) that would do what elm does?
18:44:36 <dmwit> Doesn't elm do what elm does?
18:44:38 <solrize> what does elm do?  and blackdog, do you mean meteor?  could someone describe what it does?
18:44:54 <shergill> kuhrt: elm *is* the wip you refer to. in case you mean other than elm, i think there have been other ideas but don't knowthere name off the top of my head
18:44:56 <blackdog> solrize: it's a js framework for doing realtime things.
18:45:00 <startling> solrize, it's a functional language that compiles to js
18:45:10 <startling> solrize: (elm is)
18:45:20 <solrize> http://net.tutsplus.com/tutorials/javascript-ajax/whats-this-meteor-thing/
18:45:25 <blackdog> (for some value of realtime:) giving comms between browsers for web chat, games, etc)
18:46:02 <kuhrt> elm is little more than i'm asking for too, it's replacing not just js but css and html
18:46:33 <mightybyte_> kuhrt: meteor looks pretty young as far as frameworks go
18:46:52 <kuhrt> mightybyte_: definetely
18:47:50 <mightybyte_> snap, yesod, and happstack have all been around significantly longer
18:48:20 <solrize> realtime things?  something like frp in javascript?
18:48:34 <solrize> i'm looking at that page, wall of buzzwords so far
18:48:36 <kuhrt> mightybyte_: but those are back-end centric
18:49:03 <kuhrt> mightybyte_: meteor is a full stack from server all the way to deployment (they have a <your-project>.meteor.com free hosting)
18:49:03 <solrize> i see, it propagates a mongodb from the server to the js
18:49:16 <mightybyte_> Yeah, backend is the natural thing to do in Haskell.
18:49:34 <solrize> kuhrt do you know about urweb?  i put the url further up
18:49:56 <mightybyte_> A Haskell to javascript is a highly non-trivial undertaking, although I agree that it would be the ideal approach.
18:50:23 <kuhrt> mightybyte_: right, and my question is, given existing but wip haskell-to-js compilers, how close can haskell be a great full stack platform like meteor
18:50:52 <solrize> @faq can haskell be a great full stack platform like meteor
18:50:53 <lambdabot> The answer is: Yes! Haskell can do that.
18:50:58 <blackdog> kuhrt: it's kind of a category error. haskell isn't the same sort of thing.
18:51:05 <solrize> kuhrt, haskell is a language
18:51:08 <solrize> it's not a platform
18:51:24 <blackdog> if you want something haskellish today on the front end, i would look at brian mckenna's Roy
18:51:33 <kuhrt> solrize: thanks, i've heard of it and seen it referenced in haskell talk before (blogs, docs? can't remember exactly)
18:51:55 <solrize> compiling haskell to js sounds ugly because of the eval semantics... there is agda to js
18:51:56 <blackdog> compiles to JS, hindley-milner typed, aims at trying to produce reasonably readable js. most of the haskell->js compilers tend to produce a big runtime as well.
18:52:05 <solrize> ML to js might make more sense than haskell to JS
18:52:39 <solrize> kuhrt, yeah, ezyang has written a compile blog posts about his urweb/haskell/coq thing for teaching sequent calculus
18:52:41 <kuhrt> solrize: again something meteor offers is an extremely simplified code-base due to the code-sharing between back/front end, if I toss in another language (haskell on back, ur in front) it may well rock, but isn't the thing I was hoping for (again i'm not closed to it per se)
18:52:47 <wagle> sigh..  cabal imploded on me again
18:53:25 <solrize> kuhrt meteor sounds like a bunch of clever code packaging, nice i guess, but i dunno what the big deal is from a PL perspective
18:53:55 <mightybyte_> The ideal thing for this would be a more suitable browser-based bytecode virtual machine
18:54:16 <arbn> I feel like Elm will probably be the language of choice for compiling a Haskell-like language to JabaScript.
18:54:19 <blackdog> mightybyte_: heh. you wanna wait around for that? :)
18:54:30 <arbn> JavaScript*
18:54:31 <mightybyte_> One can always wish
18:55:03 <kuhrt> mightybyte_: totally, isn't there some work among browser vendors to that end? not sure
18:55:04 <startling> yeah, a more general browser vm would be wonderful
18:55:07 <solrize> if you had a strict-evaluation with a haskell-like type system, compiling it to js would be pretty simple, i think.  just transmogrify the syntax and erase the types?
18:55:15 <blackdog> solrize: it isn't about languages at all, really. it's analogous to rails in a way - there's nothing revolutionary, it's just a collection of practices that make it very quick to try out ideas.
18:55:22 <mightybyte_> kuhrt: No idea.  I wish there were.
18:55:35 <startling> there was NaCl, but it was pretty meh
18:55:49 <kuhrt> startling: right, what happened to that?
18:55:55 <blackdog> solrize: http://roy.brianmckenna.org/ :)
18:56:03 <solrize> oh yeah i saw the thing about roy, that looked good
18:56:05 <shergill> mightybyte_: as long as it's llvm i'm on board
18:56:06 <kuhrt> startlings: sounds slike it was never going to be good enough anyway?
18:56:10 <solrize> opalang.org also looked interesting
18:56:19 <solrize> i know a guy who works on nacl, i will ask him what's up
18:57:06 <arbn> http://elm-lang.org/
18:57:07 <kuhrt> solrize: fancy
18:57:14 <startling> kuhrt: no idea. seems like people just stopped talking about it
18:57:47 <startling> I think x86 was the wrong decision there. a simpler architecture (maybe a stack machine?) with judicious optimization would be better, imo
18:58:07 <blackdog> startling: it's pretty sweet, but there are still people running IE. restricting your app to just Chrome is not really all that attractive.
18:58:44 <kuhrt> solrize: opa seems kind of like meteor in that its a "complete" all-in-one solution
18:58:51 <startling> blackdog, firefox too. :)
18:59:18 <startling> that is, "there are still people using firefox, too"
18:59:24 <blackdog> startling: i don't think it's officially supported, is it?
18:59:35 <blackdog> oh, right. thought you meant FF supported NaCL
19:01:39 <kuhrt> so after stirring up the hornets nest a bit
19:02:24 <kuhrt> it would be interesting to know if there is interest in the haskell community to do something like opa but in haskell
19:02:37 <wagle> ff has bookmark tags, qed
19:03:07 <blackdog> kuhrt: i'd be interested in using it, but it's a pretty huge task
19:03:40 <kuhrt> blackdog: ya absolutely
19:04:24 <blackdog> kuhrt: seen getbridge.com? also pretty interesting, but the server component isn't open source
19:04:36 <mightybyte_> kuhrt: I'd definitely be interested.
19:04:41 <blackdog> would be interesting to see if you could sub in a haskell backend
19:05:51 <kuhrt> thanks all for the links etc =) I'll continue with meteor for now and spend some more time looking into ur, elm etc.
19:06:41 <mightybyte_> kuhrt: jmacro is a pretty interesting solution if you're just talking about doing javascript from Haskell.
19:13:11 <solrize> startling, x86's is what people actually use for browsers, at least when nacl started
19:13:35 <MostAwesomeDude> Okay! So, AFAICT, the *only* way to get an MVar into a forkIO'd thread is to carry it in with the initial computation that I pass, right?
19:13:54 <damncabbage> My Solaris box running IceWeasel says otherwise.
19:14:00 <solrize> um, you could pass it through another mvar
19:14:07 <solrize> Mvar (Mvar a)
19:14:19 <MostAwesomeDude> solrize: Ah, but how do I get *that* MVar into the thread? :3
19:14:29 <solrize> that's not what you asked at first
19:14:35 <MostAwesomeDude> Yeah, fair enough.
19:14:43 <MostAwesomeDude> I'm just confirming that there's no way to CAF an MVar.
19:15:09 <solrize> unsafePerformIO (newMVar 0)
19:15:27 <solrize> :(
19:15:40 <solrize> i do see that sometimes
19:15:50 <solrize> actually more frequently with ioref
19:16:30 <blackdog> MostAwesomeDude: what's your objection to passing the mvar in? keeps things nice and scoped...
19:19:53 <MostAwesomeDude> blackdog: None at all; I'm not the caller of the forkIO and I'm just debating whether to run around his code in order to get my MVar in there.
19:21:11 <solrize> how does the thread communicate with the rest of the program as it is?
19:28:05 <fragamus> Main: Prelude.(!!): index too large
19:28:31 <fragamus> How can I debug this thing when all I get is that ^^^^
19:29:44 <MostAwesomeDude> solrize: It's encapsulated by a conduit thingy.
19:31:41 <shachaf> fragamus: Sometimes you can get more information when you compile with profiling.
19:31:44 <shachaf> @where rts-xc
19:31:45 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
19:32:11 <shachaf> Otherwise, uh... Don't use (!!)? :-) I don't know, it's unfortunate.
19:33:33 <solrize> MostAwesomeDude, hmm, the python/erlang approach is to have something like a Chan open to each thread, so you can pass random crap through it such as your mvar.  i dunno if you want to add that to the stuff in this conduit.
19:34:49 <MostAwesomeDude> solrize: Yeah, I'm gonna glare at it more closely and see how I could do this.
19:54:51 <startling> is there an alternative to (!!) that returns a Maybe?
19:55:03 <startling> @hoogle [a] -> Integer -> Maybe a
19:55:04 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
19:55:04 <lambdabot> Prelude const :: a -> b -> a
19:55:04 <lambdabot> Data.Function const :: a -> b -> a
19:55:11 <gurrag> what does this error mean from cabal: `configure: error: C compiler cannot create executables`
19:55:16 <gurrag> I'm trying to install SDL-image
19:56:16 <XexonixXexillion> @hoogle [a] -> Int -> Maybe a
19:56:16 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:56:16 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:56:16 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
19:57:34 <startling> weird, seems like that would be pretty useful
20:01:17 <solrize> @hoogle safeIndex
20:01:17 <lambdabot> Data.Text.Array unsafeIndex :: Array -> Int -> Word16
20:01:17 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
20:01:35 <XexonixXexillion> startling: How often do you get items from a list by index? In my experience it's a relatively rare thing
20:01:45 <solrize> :t listToMaybe . take 1 . drop n
20:01:46 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
20:01:46 <lambdabot>     In the first argument of `drop', namely `n'
20:01:46 <lambdabot>     In the second argument of `(.)', namely `drop n'
20:01:52 <solrize> :t listToMaybe . take 1 . drop 8
20:01:53 <lambdabot> forall a. [a] -> Maybe a
20:01:57 <solrize> there ya go
20:02:14 <startling> XexonixXexillion: almost never; just asking because of fragamus' question above
20:02:15 <solrize> :t (\n -> listToMaybe . take 1 . drop n)
20:02:16 <lambdabot> forall a. Int -> [a] -> Maybe a
20:02:29 <solrize> i mean there
20:02:50 <solrize> > listToMaybe . take 1 . drop 8 $ [1, 2, 3, 4]
20:02:52 <lambdabot>   Nothing
20:02:55 <solrize> > listToMaybe . take 1 . drop 2 $ [1, 2, 3, 4]
20:02:57 <lambdabot>   Just 3
20:03:15 <parcs`> gurrag: do you have sdl-image and its headers installed?
20:03:31 <gurrag> oh! one second, I'll check [I probably don't]
20:05:13 <gurrag> parcs`: thank you, that solves the issue
20:05:27 <parcs`> yay
20:06:07 <gurrag> Could not find module `Maybe'  oh no
20:06:21 <gurrag> [I'm trying to compile RainCat]
20:11:30 <gurrag> oh dear what have I done
20:11:48 <gurrag> ghci fails with `attempting to use module `Prelude' (./Prelude.hs) which is not loaded`
20:12:15 <gurrag> time to nuke everything and start over?
20:12:31 <parcs`> what's raincat?
20:13:44 <gurrag> it's a game written in Haskell with the SDL bindings
20:15:29 <parcs`> it's probably old
20:16:23 <parcs`> the Maybe module existed back when ghc had no hierarchical modules
20:16:27 <bbrittain> anyone around here have experience with Euterpea/HSoM?
20:16:28 <parcs`> now it's Data.Maybe
20:23:01 <gurrag> I think I broke my entire haskell setup either way though, since ghci now won't load
20:23:13 <gurrag> probably because I ran `cabal install haskell98`
20:23:25 <shachaf> gurrag: That might do it. :-)
20:23:41 <shachaf> Maybe try ghc-pkg {hide|unregister|something} haskell98?
20:23:47 <shachaf> (That might make things even worse, though...)
20:24:24 <gurrag> still fails on not finding the Prelude
20:24:33 <gurrag> should I rm -rf ~/.cabal ?
20:24:39 <gurrag> or will that not be enough
20:25:11 <shachaf> Probably .cabal and .ghc
20:25:18 <shachaf> Instead of rming, you could mv them. :-)
20:25:23 <gurrag> good point
20:25:26 <shachaf> mkdir ~/GHC-OLD; mv ~/.ghc ~/.cabal ~/GHC-OLD
20:25:57 <gurrag> and we're back!
20:26:14 <gurrag> thank you, I'll avoid trying to reinstall core parts of the language again
20:26:40 <shachaf> As long as you're starting over, make sure to library-profiling: True
20:26:44 <shachaf> In your ~/.cabal/config
20:27:34 <gurrag> what does that option do?
20:28:49 <shachaf> Builds profiling versions of libraries as you install them.
20:29:15 <shachaf> It might not seem useful now, but the way cabal works, if you ever want profiling you'll have to chase down all your dependencies by hand.
20:29:18 <shachaf> Which is annoying.
20:35:18 <parcs`> might as well toggle 'shared' too
20:38:53 <fragamus> I have some code that creates a lot of data structures but they go out of scope at the end of the function.  Is Haskell GC optimized to use this hint?
20:47:46 <JoeyA> How can I write a QuickCheck property that limits the domain of inputs?
20:48:09 <JoeyA> I have a function digitCount :: Int -> Int for which valid inputs are [1..999999999].
20:48:22 * hackagebot simple-actors 0.2.0 - A library for more structured concurrent programming, based  on the Actor Model  http://hackage.haskell.org/package/simple-actors-0.2.0 (BrandonSimmons)
20:48:34 <shachaf> You can add a constraint, or write more specific generating code, I guess.
20:48:56 <JoeyA> "You can add a constraint"  That's what I need to find out how to do.
20:49:13 <shachaf> @check \x -> even x ==> (x `div` 2) * 2 == x
20:49:14 <lambdabot>   Not in scope: `==>'
20:49:21 <shachaf> @check \x -> even x --> (x `div` 2) * 2 == x
20:49:23 <lambdabot>   Not in scope: `-->'
20:49:24 <shachaf> Well, something like that.
20:49:59 <shachaf> I guess lambdabot doesn't have it imported.
20:50:03 <shachaf> It used to work.
20:50:04 <parcs`> what is it called when f (f x) == x?
20:50:14 <rwbarton> involution
20:50:27 <parcs`> cool word
20:50:49 <Clint> bro
20:51:18 <parcs`> @wn involution
20:51:19 <lambdabot> *** "involution" wn "WordNet (r) 3.0 (2006)"
20:51:19 <lambdabot> involution
20:51:19 <lambdabot>     n 1: reduction in size of an organ or part (as in the return of
20:51:19 <lambdabot>          the uterus to normal size after childbirth)
20:51:19 <lambdabot>     2: a long and intricate and complicated grammatical construction
20:51:19 <bcw> where are the configuration options for cabal-install documented?
20:51:21 <lambdabot> [11 @more lines]
20:51:33 <parcs`> @more
20:51:34 <lambdabot>     3: marked by elaborately complex detail [syn: {elaborateness},
20:51:34 <lambdabot>        {elaboration}, {intricacy}, {involution}]
20:51:34 <lambdabot>     4: the act of sharing in the activities of a group; "the teacher
20:51:34 <lambdabot>        tried to increase his students' engagement in class
20:51:34 <lambdabot>        activities" [syn: {engagement}, {participation},
20:51:36 <lambdabot> [6 @more lines]
20:52:18 <oscarvarto> HI! Just starting with Haskell. Do you recommend some IDE or editor for Haskell?
20:52:28 <shachaf> oscarvarto: Whatever editor you're used to.
20:52:34 <shachaf> You don't need a special one for Haskell.
20:52:46 <oscarvarto> What about Leksah?
20:52:54 <oscarvarto> Is that a good choice?
20:53:06 <shachaf> That's what we call, to use the technical term, "a special one for Haskell".
20:53:12 <shachaf> You can use it and it'll probably be great.
20:53:23 <parcs`> oscarvarto: you don't really need an ide (as much as other languages) because you have ghci
20:53:23 <shachaf> But you can also use almost any other editor and it'll work well too.
20:53:29 <LegendaryQ> :< i don't know any mac editors...
20:53:49 <shachaf> Nice things to have are syntax highlighting and something that turns tabs to spaces.
20:53:49 <LegendaryQ> though i'd imagine even the normal textedit would work
20:53:52 <oscarvarto> I'm using Mac OSX Lion
20:53:56 <oscarvarto> by the way
20:54:26 <LegendaryQ> my knowledge with macs is unfortunately pretty limited
20:54:27 <shachaf> oscarvarto: I've heard that "TextWrangler" is good.
20:54:31 <parcs`> try sublime text 2
20:55:15 <shachaf> I think you have to pay money for that one.
20:55:29 <shachaf> Of course, you're using OS X, so you're probably usd to that. :-)
20:56:05 <blackdog> oscarvarto: my impression is that most people use emacs or vim, but that might be a self-selecting sample.
20:57:00 <parcs`> sublime text has an unlimited trial version
20:57:25 <oscarvarto> I like emacs. But having used Eclipse for Scala/Java I wondered if Haskell has a good IDE
20:57:46 <LegendaryQ> i'm sure someone has made one for it?
20:58:04 <geekosaur> leksah
20:58:12 <c_wraith> you can use eclipse.
20:58:18 <geekosaur> also manatee but its maintainer is not maintaining currently
20:58:23 <blackdog> oscarvarto: you can buff emacs up with ghc-mod
20:58:35 <blackdog> you get in-editor typechecking, and a  few other neat features.
20:58:59 <shachaf> oscarvarto: If you know how to use Emacs, just use Emacs.
20:59:09 <shachaf> You don't need an IDE; really.
20:59:12 <shachaf> Haskell is not Java.
20:59:20 <zalzane> Kuraitou hi
20:59:28 <zachk> leksah is decent if you can get it working
21:00:58 <parcs`> that's a nice /part message
21:01:04 <LegendaryQ> ...yeah i was gonna say
21:08:14 <XexonixXexillion> if I have a monad (which is pretty much the identity monad) and define fmap f (SomeConstructor x) = x `par` (SomeConstructor $ f x), and define >>= in terms of fmap and join, will "(+) <$> a <*> b" evaluate a and b in parallel?
21:13:03 <JoeyA> Ah, found the answer to my QuickCheck question: prop_digitCount = forAll (choose (1, 999999999)) $ \n -> digitCount n == (length . show) n
21:13:27 <JoeyA> I was using (n >= 1 && n <= 999999999) ==> ..., but QuickCheck was giving up because it was discarding too many cases.
21:13:58 <JoeyA> (the question was how to limit the domain when testing a function)
21:20:30 <JoeyA> Actually, turns out that random generation strategy is pretty bad for digitCount, since most cases have the same number of digits.
21:20:41 <JoeyA> that this*
21:21:51 <raymank26> hello, i have a some trouble with the StateT and guard function. When I run a following code i get an exception "user error(mzero)". My code is here http://pastebin.com/DyGaCVzR
21:21:53 <mauke> The paste DyGaCVzR has been copied to http://hpaste.org/70864
21:23:08 <raymank26> by the way, when I change guard with if else clauses this code works
21:23:38 <JoeyA> raymank26: What do you expect it to do?
21:23:52 <JoeyA> Here's the relevant instance of StateT: MonadPlus m => MonadPlus (StateT s m)
21:23:59 <JoeyA> So guard here is just guard in the IO monad.
21:24:14 <JoeyA> hmm, which doesn't have a MonadPlus instance.
21:24:42 <raymank26> ghc talks me about this
21:25:22 <raymank26> i would like to read a lines from file and check StateT =)
21:27:15 <JoeyA> raymank26: Ah, so it's recursive.
21:27:22 <raymank26> yep
21:27:31 <JoeyA> First of all, why not replace evalStateT with execStateT, and drop the get/return at the end of readGraph?
21:27:58 <JoeyA> To make it tail recursive.
21:28:25 <raymank26> i trying it
21:28:44 <JoeyA> So you want to abort the computation when you reach EOF, right?
21:28:53 <raymank26> but i have a problem with recursive call readGraph
21:28:58 <raymank26> yes
21:29:17 <JoeyA> The guard is just going to produce an exception.
21:29:29 <raymank26> yes, but why?
21:29:48 <JoeyA> I don't know where that MonadPlus instance for IO is coming from.
21:30:02 <raymank26> hmm
21:30:06 <raymank26> ok
21:30:25 <JoeyA> raymank26: guard causes the monadic computation to "fail" (yield mzero) if the condition is false.
21:30:25 <raymank26> how can I change this function to tail recursive?
21:30:37 <raymank26> how to make a call of function inside a function?
21:30:49 <raymank26> aha!
21:31:22 <JoeyA> > do {x <- [1..10]; guard (x < 3); return x}
21:31:24 <lambdabot>   [1,2]
21:31:50 <JoeyA> > do {x <- [1..]; guard (x < 3); return x}
21:31:54 <lambdabot>   mueval-core: Time limit exceeded
21:32:05 <LegendaryQ> ...nice
21:32:05 <raymank26> wow
21:32:19 <JoeyA> What?
21:32:36 <JoeyA> That shouldn't be surprising.
21:32:54 <JoeyA> It's like saying filter (< 3) [1..]
21:33:16 <JoeyA> filter doesn't know what the rest of the list contains, it just traverses the whole thing looking for matching items.
21:33:53 <raymank26> yes, i understand this. Give me a minute, i trying to replace my function
21:34:26 <tgeeky> does anyone know where "Debug.Trace.Utils" might be?
21:35:40 <geekosaur> huh.  hayoo never heard of it, apparently
21:36:04 <tgeeky> yeah. nor google or elsewhere. It must be local to one of my co-developers
21:36:26 <tgeeky> no problem; comment import, set imported functions to undefined; compile!
21:37:55 <LegendaryQ> JoeyA: i was going wow at the bot
21:38:16 <LegendaryQ> or rather nice
21:38:20 <LegendaryQ> *shrug*
21:38:38 <JoeyA> Hmm, will the defer-type-errors extension support building with missing imports?
21:38:51 <JoeyA> (replacing with holes as is done for type errors)
21:38:58 <JoeyA> Err, option, not extension.
21:45:46 <JoeyA> A developer is someone who solves problems and writes code.  What would a co-developer be, a set of accessor functions abstracting over a carrier type of a developer's coalgebra?
21:46:11 <JoeyA> (that's pretty much copy-paste from a paper on codata; I'm not that smart)
21:47:16 <hpaste> “Jonathan Fischoff” pasted “Error/Warning Reporting” at http://hpaste.org/70867
21:48:07 <jfischoff> ^ I'm looking for feedback on the design tack I'm taking for an Error/Warning logging setup. Any thoughts appreciated.
21:48:29 <JoeyA> jfischoff: First of all, did you forget to log the error as well?
21:48:45 <JoeyA> Or will it be caught and handled upstairs?
21:49:42 <yitz> jfischoff: so this is logging that only works in a monadic context then
21:50:16 <jfischoff> JoeyA: throwError should abort, but I guess it can get caught.
21:50:22 <jfischoff> yitz: yes
21:50:43 <jfischoff> yitz: if there is an alternative I'm interested
21:50:45 <JoeyA> Second, the MonadError and MonadWriter constraints restrict the set of monads you can use report in, due to their functional dependencies.
21:51:07 <jfischoff> JoeyA: Ah are there equivalent alternatives?
21:51:07 <yitz> jfischoff: well sure there is.
21:51:15 <jfischoff> or analogous
21:52:06 <JoeyA> jfischoff: I'd make a typeclass providing the throwError and tell capabilities (e.g. class ErrorReport b m)
21:53:44 <JoeyA> Also, might want to say class Monad m => ErrorConfig b m, unless you can think of a compelling case where m isn't a monad.
21:53:55 <jfischoff> JoeyA: yeah true
21:54:04 <jfischoff> good point with the constraint
21:54:12 <yitz> jfischoff: for example: i have a large application designed as a composable pure processing pipeline. there are data types that are passed from one component to the next, some of them rather large. i have standard ways of including a pure logging type in those data types.
21:54:40 <jfischoff> yitz: why not use a monadic context?
21:54:59 <yitz> jfischoff: why should i complicate my application with that when not needed?
21:55:45 <yitz> jfischoff: monads are powerful where needed. but composable pure functions are even more powerful.
21:55:58 <jfischoff> JoeyA: I am pretty naive when it comes to alternatives to mtl/transformers builtins. Am I wrong that I would have to "roll my own instances" so to speak?
21:56:25 <JoeyA> jfischoff: The way I see it, instances of monad constraints are an implementation detail.
21:56:49 <JoeyA> Monad constraints can be mixed and matched, making it easy to specify what your application logic needs.
21:56:57 <jfischoff> yitz: True, but if you have a reader, a writer and an error handling a monad seems like a good option, but seriously what do I know.
21:57:43 <jfischoff> JoeyA: So as see it, I am conflating concerns by making my design dependent on mtl etc
21:57:43 <JoeyA> Now to implement the needed capabilities, you can say: newtype MyMonad a = MyMonad (StateT Foo (ReaderT Bar (...)) deriving (Functor m, Applicative m, Monad m);
21:57:58 <jfischoff> s /so as see/so as you see
21:58:33 <JoeyA> Then implement ErrorConfig and ErrorReport instances for MyMonad that do the necessary lifts and asks.
21:58:40 <JoeyA> jfischoff: Right.
21:58:52 <jfischoff> JoeyA: right that makes sense. that's a good point
21:59:05 <JoeyA> One thing I should stress is that, unless your code does a wide variety of IO, keep IO out of your application logic.
21:59:42 <JoeyA> A lot of Haskell code being written is a big stack of transformers on top of IO.  (I've written my share, too)
22:00:06 <jfischoff> yitz: I guess when it comes to monads the question is do you want to pass around data explicitly or implicitly (with the price being monadic complexity)
22:00:28 <jfischoff> yitz: I guess it is a application specific thing
22:00:31 <JoeyA> Consider something like (ErrorReport b m, Serve m) => Request -> m Response
22:00:56 <JoeyA> Now m might end up being some IO-based monad.
22:01:14 <JoeyA> But for the function whose signature is forall b m. (ErrorReport b m, Serve m) => Request -> m Response
22:01:48 <JoeyA> It is not allowed to perform arbitrary IO, since it must work for every monad m satisfying the constraints.
22:01:57 <yitz> jfischoff: right. in this large application, i do use monads in many places. but i don't want to limit things by forcing the entire application to be inside one gigantic global monad.
22:02:23 <yitz> jfischoff: passing around data isn't a big deal, if you design the types corectly.
22:02:25 <jfischoff> yitz: Yeah totally agree. It really starts to take over like cancer too.
22:02:58 <jfischoff> JoeyA: I wouldn't have predicted that
22:03:29 <jfischoff> I would thought "any" monad is fine
22:03:44 <yitz> jfischoff: and since logging is global in nature, i'd rather it not force me to be in a monad. even though it's true that there is something natural about a monad for logging.
22:03:53 <JoeyA> Well, you can call serve in the IO monad, provided you come up with ErrorReport and Serve instances for IO.
22:04:07 <JoeyA> But serve *itself* is not contaminated.
22:05:00 <JoeyA> The code that implements serve should not have to worry about scary IO stuff like async exceptions.  That's the job of your application's glue code.
22:05:35 <jfischoff> JoeyA: Okay, I see, so I am putting too many unnecessary constraints on my function
22:05:35 <yitz> jfischoff: so that's why i would define things like isError and shouldLog as pure. well, technically you have them pure, but the higher kind will cause a lot of messiness.
22:05:47 <jfischoff> JoeyA; that's where you are going?
22:05:55 <yitz> jfischoff: that gives you the choice of doing the logging in a monad or not.
22:06:58 <jfischoff> yitz: Yeah worth trying.
22:07:24 <yitz> JoeyA: you would use something in MonadIO, not raw IO.
22:07:31 <jfischoff> JoeyA: I felt like I was losing the connection, was I off there?
22:08:05 <JoeyA> jfischoff: Maybe.  report :: ErrorReport i m => i -> m () would be fine.  What I'm saying is to use monad classes to introduce capabilities to application logic, but defer implementation details to application code.
22:09:02 <JoeyA> err
22:09:06 <jfischoff> JoeyA: For better or worse was my goal. Anyway, I'll make the changes you guess discussed and hurry back
22:09:10 <JoeyA> defer implementation details to somewhere else
22:09:34 <JoeyA> But yitz has a good point too.  isError doesn't need to be monadic.
22:10:00 <JoeyA> class LogMessage msg where isError :: msg -> Bool; shouldLog :: msg -> Bool
22:10:14 <jfischoff> totally
22:10:19 <JoeyA> Though an ADT might avoid some overlap.
22:10:40 <JoeyA> data MsgAction = Throw | Log | DoNothing
22:10:42 <jfischoff> err well
22:10:46 <JoeyA> On the other hand...
22:11:02 <JoeyA> Making it pure means you can't ask the corresponding monad (or whatever) for the current configuration.
22:11:05 <JoeyA> I forgot about that.
22:11:13 <jfischoff> right
22:11:59 <jfischoff> I want to layer ErrorConfig on top of my monad. But maybe it should still be pure somehow
22:12:33 <JoeyA> isError should probably be pure.  Making the choice to throw an error or keep going a configuration parameter seems like madness.  Maybe it's sensible for your application.
22:13:22 <jfischoff> Some warning can be errors
22:13:48 <JoeyA> Why not just: class Monad m => MonadReport i m where report :: i -> m ()
22:13:49 <jfischoff> I am totally following the madness part I guess
22:14:09 <JoeyA> Let the monad decide how to deal with the issue.
22:14:50 <jfischoff> Sure, that could work. I guess my thinking was that when it did decide, it would come up with the two functions in ErrorConfig
22:14:59 <jfischoff> So that is the base
22:15:10 <jfischoff> and I guess I'm skipping to the next step
22:15:25 <jfischoff> But starting there might be best
22:15:42 <JoeyA> Now unless you want to make the choice of whether to throw an error or not be configurable, you could have two methods in MonadReport
22:15:50 <JoeyA> reportError :: e -> m a
22:15:59 <jfischoff> I definitely want it configurable
22:16:03 <JoeyA> reportMessage :: msg -> m ()
22:16:45 <jfischoff> The idea is that the most of code doesn't know if it is calling an error or warning
22:16:52 <jfischoff> that is decided else where
22:16:58 <jfischoff> so I wouldn't want to expose that
22:17:02 <JoeyA> This would provide better types (to signify that reportError does not return), but would require knowing if e is supposed to throw an exception to be known at compile time.
22:17:18 <jfischoff> yeah I don't know that in most cases
22:20:29 <JoeyA> Now this definition of MonadReport definitely constrains error-reporting code to a monad.
22:28:18 <tgeeky> jfischoff: working on #pee?
22:28:24 <jfischoff> yeah
22:28:26 <tgeeky> jfischoff: I actually got much of the deps and stuff up to date
22:28:46 <arbn> Damn. I *love* reactive-banana + Gtk2Hs. This is a much, much better way to do GUI programming than the mess of delegates used in the Microsoft world.
22:28:47 <jfischoff> cool I have issue with doctest now ;P
22:29:01 <tgeeky> jfischoff: ->
22:35:10 <startling> are there like, 2-dimensional functors?
22:35:20 <startling> with a mappend in each direction?
22:36:46 <copumpkin> functors don't have a mappend :o
22:37:04 <copumpkin> you might be thinking of a bifunctor though
22:37:12 <copumpkin> which can be any combination of directions
22:37:26 <copumpkin> well, there are four combinations :)
22:37:28 <startling> errrrr monoid
22:37:29 <startling> wow
22:37:40 <startling> interesting. thanks
22:43:25 * hackagebot palindromes 0.3.1 - Finding palindromes in strings  http://hackage.haskell.org/package/palindromes-0.3.1 (JohanJeuring)
22:43:48 <rwbarton> pipes have a definite 2-dimensional feel to them
22:44:18 <carter> copumpkin: my plan to take over the world is in progress!
22:45:38 <startling> is there an indexable typeclass?
22:46:20 <jfischoff> JoeyA: here's what I'm thinking. I make a typeclass called MonadReport with the report :: i -> m () function. I provide a helper for implementing the monad report if you have a then all the other stuff I need before. Does that make sense?
22:47:56 <JoeyA> Error parsing at "if you have a then all"
22:49:06 <jfischoff> s /then/them i.e the various MonadError, MonadWriter, etc typeclasses
22:51:07 <JoeyA> Maybe something like: instance (ErrorConfig i m, MonadError i m, MonadWriter i m) => MonadReport i m
22:51:17 <JoeyA> Though this is an undecidable instance, I think.
22:51:43 <JoeyA> So instead, you could do: instance (ErrorConfig i m, MonadError i m, MonadWriter i m) => MonadReport i (ReportT m)
22:52:04 <jfischoff> True
23:03:30 <Zqrxv> @quote Kukkua
23:03:31 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
23:12:32 <JoeyA> Well, then you have to learn about arrows.  Then monads (again).  Then FRP.
23:55:45 <teaurchin> anyone have any idea how I can use the parsec combinators to parse a line of text (manyTill anyChar newline) but also getting rid of trailing whitespace?
23:56:32 <teaurchin> so I'd want "foo bar  \n" to parse as "foo bar"
23:59:09 <startling> stick a skipMany space in there, maybe
23:59:14 <tdammers> teaurchin: just parse and then remove whitespace?
23:59:19 <startling> I forget whether space parses "\t" or not
23:59:25 <startling> er, s/t/n
