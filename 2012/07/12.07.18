00:00:34 <augur> but eta isnt really used for computation, so im ok with having it separate like that
00:01:08 <ski> well, you need eta to reason about your computations (refactoring, &c.)
00:01:41 <augur> yeah
00:02:13 <augur> im tempted to add a section on extended versions of the LC, like having primitive naturals, etc.
00:02:31 <augur> should i? i dunno
00:02:40 <ski> well, the correspondence isn't as clear there
00:02:56 <ski> universal and existential might be nice to add, maybe
00:03:29 <augur> for types or terms?
00:03:45 <ski> for types/propositions, i meant
00:03:50 <ski> (BHK)
00:04:32 <augur> so you mean /\t.M : forall t.X and ... i dont know what the one for exists is
00:05:01 <augur> i guess (t,M) : exists t.X
00:05:03 <ski> a proof of `forall a. Phi[a]' is a function/construction that given an individual `a' constructs a proof of `Phi[a]'
00:05:20 <augur> well yres but i mean
00:05:24 <augur> ok
00:05:25 <augur> so
00:05:37 <augur> do you mean forall/exists as in parametric types
00:05:38 <ski> <http://en.wikipedia.org/wiki/BHK_interpretation>
00:05:43 <augur> or as in dependent types
00:05:57 <ski> well, dependent really, i think
00:06:15 <augur> thats really tricky
00:06:19 <ski> possibly it's too big a complication to introduce it in this paper
00:06:33 <ski> mayhaps you could mention it in passing that it is possible to do
00:06:40 <augur> because i'd need to either explain how predicates combine with terms to form types
00:06:50 <augur> which is a whole lot of new crap
00:07:07 <augur> or i'd have to give an explanation of how Type is just a type
00:07:12 <augur> well, a kind, but
00:07:23 <ski> you should probably mention BHK somewhere
00:07:28 <augur> maybe maybe
00:07:32 <augur> ill figure out someone nice to add it
00:07:37 <ski> "If one takes lambda calculus as defining the notion of a function, then the BHK interpretation describes the correspondence between natural deduction and functions."
00:08:13 * ski nods
00:09:05 <augur> well no, i guess i could do something on dependent types.. i dunno
00:09:18 <augur> its just, you need to have rules for how P x is formed
00:09:29 <augur> you dont want to just be able to form P x and P x y and P x y z and ...
00:09:34 <augur> you want P to be "typed" in a sense
00:10:07 <augur> so you need either kind signatures with kind typing rules, or you need a type of types
00:10:08 <ski> hm, i see you have the term "local soundness" in the "Harmony" section -- do you have any kind of explanation of it somewhere ?
00:10:42 <ski> augur : *nod*. seems like a lot of noise
00:10:43 <augur> no, i just mention pfennings intro. tho i should add a ref to that earlier
00:12:04 <ski> hm, i'm not sure what you mean by "Other well known expansions/equivalences from the \lambda calculus are simply combinations of simplification rules with demonstrations of local completeness."
00:13:45 <augur> ill try to clarify that
00:13:46 <augur> but basically
00:14:18 <augur> local completeness for -> says f ==> \x.f x
00:14:28 <augur> which is the expansion direction of eta conversion
00:14:57 <augur> while   \x.f x ==> f   is just a simplification rule
00:15:25 <ski> well, i think of it as just `f = \x. f x' (extensionality)
00:15:57 <augur> well but
00:16:05 <augur> if we're thinking of these things as actual terms
00:16:08 <ski> (perhaps there's some point in distinguishing between the two directions here, which is useful)
00:16:08 <augur> then f /= \x. f x
00:16:15 * ski nods
00:16:17 <augur> because f is a different proof than \x. f x
00:16:20 <augur> but they're equivalent
00:16:36 <augur> if we're viewing lambda terms as equivalence classes (which we're not) then [f] = [\x. f x]
00:16:39 <ski> if we're talking about reduction, then the direction would matter, of course
00:16:50 <augur> and if we're viewing lambda terms as denoting meanings, the [[f]] = [[\x. f x]]
00:17:03 <augur> but in terms of actual _terms_ or _proof objects_
00:17:27 <ski> i think systems often eta-expand to be able to (conservatively) compare equality
00:17:29 <augur> then eta conversion is bidirectional. in the forward direction, f => \x.f x   its just local completeness for ->
00:17:43 <augur> in the other direction its a simplification rule
00:17:52 * ski nods
00:18:01 <augur> so eta _conversion_ is local completeless + simplification
00:18:18 <ski> ok
00:18:22 <augur> similarly for the pair rule
00:18:42 <ski> i suppose i'm not sure why only one direction is called "local completeness"
00:18:55 <augur> well
00:19:01 <augur> local completeness means something specific, right
00:19:16 <ski> i presume so, yes
00:19:19 <augur> local completeness says that if you have a proof P
00:20:04 <augur> you can always prove the same things, no matter how you eliminate
00:20:17 <ski> (perhaps i should check Pfenning's notes there)
00:20:27 <augur> so if you have a proof P, you can use it, together with eliminations, and never loose the ability to prove the thing P proved
00:20:32 <ski> hm, so it's then some kind of coherency result ?
00:20:33 <augur> pfennings notes are really good, yeah
00:21:03 <ski> (or maybe confluence is a more accurate term)
00:21:20 <augur> no, it's just a completeness property
00:21:28 <augur> as in, you can prove true things
00:21:36 <augur> but not true globally
00:21:38 <ski> ok
00:21:47 <augur> known to be true locally somewhere in a proof
00:21:50 <augur> heres what pfenning says:
00:21:54 <augur> Local soundness shows that the elimination rules are not too strong: no matter how we apply elimination rules to the result of an introduction we cannot gain any new information. We demonstrate this by showing that we can find a more direct proof of the conclusion of an elimination than one that first introduces and then eliminates the connective in question. This is witnessed by a local reduction of the given introduction a
00:21:54 <augur> nd the subsequent elimination.
00:22:11 <augur> Local completeness shows that the elimination rules are not too weak: there is always a way to apply elimination rules so that we can reconsti- tute a proof of the original proposition from the results by applying intro- duction rules. This is witnessed by a local expansion of an arbitrary given derivation into one that introduces the primary connective.
00:22:47 <ski> yeah
00:23:04 <augur> im really into this verificationist perspective
00:23:36 <ski> e.g. in linear logic, the fact that you can only use one conjunct in an additive conjunction means that you can "use" the same resource when proving both conjuncts
00:23:39 <augur> i wrote this little tutorial almost immediately after reading pfennings notes, because once i understood local soundness/completeness the whole thing just fell into place
00:23:42 <augur> it was beautiful
00:23:54 <ski> it also means that something like `foo * not foo' isn't necessarily inconsistent
00:24:06 <augur> i wonder if linear logic is locally sound and complete
00:24:07 <augur> hmm
00:24:24 <ski> (thus having some tangent to paraconsistent logics)
00:24:24 <augur> well, foo * not foo is inconsistent
00:24:28 <augur> but foo & not foo isnt
00:24:49 <ski> yea, i was using `*' for additive and `(*)' for multiplicative conjunction
00:24:56 <augur> ah ok
00:25:10 <augur> yes well, &/* isn't exactly ^ as we know it
00:25:11 <augur> so
00:25:19 <ski> so, when we weaken the elimination, we get a corresponding strengthening of the introduction
00:27:13 <solrize> hey augur that tutorial looks really cool thanks for posting it
00:27:31 <ski> i think one can probably relate the local soundness and completeness to the categorical view of defining connectives via adjunctions
00:27:32 <solrize> i've seen other more technical articles that i didn't have the background to read
00:27:59 <augur> solrize: :)
00:28:00 <ski> perhaps a note on Curry-Howard-Lambek will be forthcoming :)
00:28:09 <solrize> this is readable
00:28:50 <augur> solrize: i try. mostly because im a dope and write for my own dopey thought process.
00:28:58 <augur> solrize: lemme know if there's anything that isn't entirely clear.
00:29:10 <solrize> ok :)
00:29:21 <augur> or if im presupposing something that isn't necessarily something a programming would know
00:29:36 <augur> (im assuming, of course, that they know some aspects of the lambda calculus :p)
00:30:12 <ski> iirc, it is possible to state an eta-conversion for `_|_' ..
00:30:42 <augur> maybe!
00:31:18 <augur> im tempted to try and write a little program that will list harmonic inference rules
00:31:44 <augur> but i dont quite have enough of an understanding of harmony yet
00:31:50 <augur> the disjunction rule, for instance is mysterious
00:32:12 <augur> im still working on figuring out what the formal characteristic of the harmonic rewrites are
00:32:42 <ski> yeah, disjunction is problematic in ND (due to the "parasitic formula" as mentioned earlier by Girard, i think)
00:32:51 <ski> let's see
00:32:59 <ski> conjunction, beta
00:33:11 <ski>   fst (e0,e1) = e0
00:33:17 <ski>   snd (e0,e1) = e1
00:33:21 <ski> conjunction, eta
00:33:23 <augur> ski: parasitic formula?
00:33:31 <ski>   e = (fst e,snd e)
00:33:43 <augur> yeah, see, conjunction eta is simplification + completeness
00:33:50 <ski> disjunction, beta
00:33:55 <augur> beta = soundness, eta = simplification + completeness
00:34:09 <augur> well, simplification + soundness
00:34:30 <ski>   case Left e0 of Left x0 -> ..x0..; Right x1 -> ..x1..  =  ..x0..[x0 |-> e0]
00:34:39 <ski>   case Right e1 of Left x0 -> ..x0..; Right x1 -> ..x1..  =  ..x1..[x1 |-> e1]
00:34:44 <augur> really, i guess, its more   beta = soundness \subseteq simplification
00:34:53 <ski> disjunction, eta
00:35:05 <augur> eta = completeness + some simplification
00:35:20 <ski>   e  =  case e of Left x0 -> Left x0; Right x1 -> Right x1
00:35:47 <ski> the surprising thing in eta for disjunction is that the `case' is still the outer construction
00:36:09 <solrize> at the end it would be nice to say what you mean by harmony
00:36:22 <ski> ok, so for `_|_', eta then becomes
00:36:30 <solrize> and the whole thing is STLC and propositional calculus, which leaves me a little bit hungry ;)
00:36:32 <ski>   e  =  case e of {}
00:36:38 <ski> (where `e' have type `_|_')
00:37:15 <augur> which is \bot-elim e in my notation
00:37:46 <ski> well, `case e of {}' is that, yes
00:37:50 <augur> yeah
00:37:56 <augur> its pfenning mentions this actually
00:38:08 <ski> the nice thing is that we can even state the eta rule (knowing that we have no intro rule)
00:38:11 <augur> i left it out because it doesnt really add anything interesting to the discussion
00:38:22 <augur> and i figured that would clutter the tutorial
00:38:32 <augur> since really most people wont be familiar with \bot anyway
00:38:33 <ski> however, Bart Jacobs in "Categorical Logic and Type Theory" have slightly more general (at least in form) versions of these eta-rules
00:38:42 <augur> much less so than * and + i think
00:38:48 <augur> oh got jacobs
00:38:50 <augur> that book
00:38:52 <ski> hehe
00:38:53 <augur> sooooo complicated
00:38:59 <augur> no examples
00:39:01 <ski> ;)
00:39:01 <augur> horrible
00:39:11 <ski> well, some examples but not that much
00:39:14 <augur> that book is one of the reasons i wrote this tutorial the way i did
00:39:20 <augur> no no when i say examples
00:39:26 <augur> i mean hand-holding baby steps examples
00:39:36 <augur> not "X is a fibered category. proof left as an exercise"
00:39:37 <augur> but rather
00:39:58 <ski>   e'[x |-> e]  =  case e of Left x0 -> e'[x |-> Left x0]; Right x1 -> e'[x |-> Right x1]
00:40:03 <augur> "incredibly simple thing X is a fibered category. here's an excruciatingly explicit proof of why, with pictures"
00:40:09 <ski>   e'[x |-> e]  =  case e of {}
00:40:46 <augur> fst can be seen as a special variant of case, i guess
00:41:04 <augur> case p of { (x,_) -> e }
00:41:23 <augur> but thats a different inference rule
00:41:27 <ski> yeah, you could use the multiplicative-style `case e of (x0,x1) -> ..x0..x1..' instead of the additive-style `fst e' and `snd e'
00:41:29 <augur> thats one with a hypothetical proof
00:41:56 <ski> then you also get
00:42:08 <ski>   case () of () -> ...  =  ...
00:42:09 <augur> and i figure, if local soundness/completeness are reasonable, you should be able to give a general formal description of them regardless of style
00:42:19 <ski>   e  =  case e of () -> ()
00:42:23 <ski> or, the more general-style
00:42:26 <augur> should i replace tt with <>?
00:42:35 <ski>   e'[x |-> e]  =  case e of () -> e'[x |-> ()]
00:42:52 <augur> what do you think? should i?! :|
00:43:02 <augur> i think i will
00:43:11 <augur> im also tempted to replace \x.M with \x -> M
00:43:21 <augur> but that'll lengthen terms and im not sure i want to do that
00:44:15 <ski> <augur> should i replace tt with <>?
00:44:17 <ski> go for it !
00:44:18 <augur> its not like i show any proofs with tt
00:44:37 <ski> i'd rather use `\x |-> M' than `\x -> M'
00:45:04 <ski>   λx ↦ M
00:45:16 <augur> so lets see
00:45:23 <augur> for conjunction we have
00:45:25 <isomorphic> Is there cabal syntax for depending a build on something within an external folder, within a project?
00:45:27 <startling> I wish keyboards were friendlier for math
00:47:19 <augur> local soundness: for each constructor C/n and x_i : A_i, we have C(x_0,...,x_n) : A_0 * ... * A_n followed by projections p_i(C(x_0, ..., x_n)) : A_i
00:47:25 <augur> and this should simplify to x_i
00:48:06 <ski> aye
00:48:08 <augur> "projections" being eliminators i guess
00:48:23 <ski> naturally
00:48:56 <augur> for conjunction its   (,)/2   with   proj_0 (x, y) = x; proj_1 (x, y) = y
00:50:32 <augur> ahh but see
00:50:43 <augur> for functions, the eliminator isn't unary, right
00:51:26 <augur> so i guess we need to describe that as p_i(C(x_0, ..., x_n), a_0, ... a_m) : A_i
00:51:54 <hpaste> “Malik Elfath” pasted “searching in sorted Indexes of tuple list ” at http://hpaste.org/71677
00:52:16 <ski> (btw, this "parasiticness" in the disjunction elimination cause lots of trouble in several areas -- e.g. in partial evaluation it's a bit nontrivial to have information from outside a `case' flow into the branches of it .. and in normalization-by-evaluation, one needs delimited continuations (or nqCPS) to implement reflection for disjunction)
00:53:03 <augur> so for functions we have the constructor   lam/1   and the eliminator app/2   with the equation   app(lam[x](m), a) => m[a/x]
00:53:36 <augur> so i suppose for conjunction we also have a similar statement about hypotheticals but its trivial because there are not
00:53:36 <ski> yeah, though lam/1 is a binder
00:53:49 <augur> ^
00:53:49 <augur> :)
00:54:06 <augur> case is a binder too, so that makes sense
00:54:13 <augur> fst is a binder that binds nothing
00:54:28 <ski> (at least simple) binders are nice to do with HOAS
00:54:29 <augur> case for * is a binder
00:54:50 <augur> true! but proof trees arent higher order :)
00:54:54 <augur> not in ND anyway
00:55:13 <augur> well i guess they are in some sense, actually
00:55:49 <ski> (see the section on "arities" in the start of "Programming in Martin-Löf’s Type Theory" at <http://intuitionistic.wordpress.com/works-on-martin-lofs-type-theory/>)
00:56:06 <augur> in that   G |- m : P   is basically a meta-lambda with unordered arguments
00:56:19 <ski> *nod*
00:56:20 <augur> also its |G|-adic
00:56:29 <augur> i hear theres such a thing as nested sequents
00:56:37 <augur> but i dont know anything about them
00:56:45 <ski>   app : 0 * 0 -> 0
00:56:50 <augur> i wonder if they're things like   G |- (D |- m : P)
00:56:50 <ski>   lam : (0 -> 0) -> 0
00:57:21 <augur> but with that, you really want to distinguish between meta */-> and propositional */->
00:57:25 <ski> augur : not in normal logics
00:57:57 <ski> iirc some "strict implication" (lucasiewizc or something) has been interpreted as an attempt to do that
00:58:05 <augur> thats what i find so interesting about writing this --- ive had to come very clearly to grips with the distinction between object-language */-> and meta-language */-> etc
00:58:16 <ski> `[]' in provability logic is possibly related
00:58:36 <augur> modalities are functors! :D
00:58:48 <ski> indeed, and that distinction is very subtly, and not that easy to note initially
00:58:53 <augur> specifically, [], i think it is, is an applicative functors
00:59:11 <ski> augur : well, they are not necessarily functors :)
00:59:26 <ski> sure, they have `(<*>)', but usually not `pure'
00:59:32 <augur> sure they do!
00:59:35 <ski> no
00:59:38 <augur> its the K rule. or is it S... i dont remember
00:59:44 <augur> rule schema maybe.
00:59:46 <ski>   |- Phi  =>  |- [] Phi
00:59:51 <ski> is very different from
00:59:52 <augur> yeah that
00:59:58 <ski>   |- Phi -> [] Phi
00:59:58 <augur> yeah
01:00:01 <augur> thats true
01:00:22 <augur> but if you have hypotheticals, |- Phi -> [] Phi is a theorem
01:00:30 <ski> (meta vs. object, again)
01:00:46 <ski> what do you mean by "hypotheticals" ?
01:00:47 <augur> well actually, wait
01:00:52 <augur> no i guess not, huh
01:00:55 <augur> because its |- Phi
01:00:58 <augur> not G |- Phi
01:01:02 <ski> yeah, no premises
01:01:05 <ski> in fact, i think
01:01:15 <ski>   [] Gamma |- Phi  =>  [] Gamma |- [] Phi
01:01:17 * hackagebot acid-state 0.6.5 - Add ACID guarantees to any serializable Haskell data structure. (DavidHimmelstrup)
01:01:20 <ski> is a nicer version of this
01:01:31 <ski> makes it more clear that this is something comonady :)
01:01:36 <augur> but, all applicative functors are modalities, maybe?
01:02:01 <augur> yeah
01:02:03 <ski> augur : sounds fine
01:02:26 <augur> cause   |- Phi -> [] Phi   |- Phi   ==MP==>   |- [] Phi
01:02:38 <ski> (and of course this comonady thing is an adjunction)
01:02:49 <augur> so all applicative functors are modalities
01:03:01 <ski> *nod*
01:03:32 <augur> the [] -> distribution law is <*> of course
01:03:44 <augur> [] (A -> B) -> [] A -> [] B
01:03:52 <ski> you can see this as going from `|- Phi -> [] Phi' to `|- Phi  =>  |- [] Phi'
01:04:19 <ski> note the similarity with `|-' there and `[]´ in `|- [] (A -> B) -> ([] A -> [] B)'
01:04:57 <augur> its odd how the functor laws look aaaaalmost like []
01:05:10 <ski> the laws ?
01:05:17 <augur> well, the typing "law"
01:05:20 <augur> laws
01:05:26 <ski> oh, the signature
01:05:32 <augur> F (f : A -> B) : F A -> F B
01:06:26 <ski> (btw, in modal logic, we don't generally want `[] B' to follow from `A -> B' and `[] A' -- consider the case when `[]' means "foobert knows")
01:06:49 <augur> (A -> B) -> [] A -> [] B   <--- is this an axiom? or is it a theorem? i dont remember.
01:07:00 <augur> well then
01:07:02 <ski>   fmap_F : (A -> B) -> (F A -> F B)
01:07:03 <augur> that answers that :)
01:07:39 <augur> aaanyway
01:07:43 <augur> back to logics
01:07:44 <ski> (:
01:07:56 * ski thought modal logic was a kind of logic
01:08:04 <augur> reading about, i mean :p
01:08:13 <augur> or, if you ask quine, its almost not logic, if you go beyond propositional!
01:08:24 <augur> tho quine was crazy
01:09:03 <ski> well, istr some strange/interesting stuff re Barcan formulae when mixing modalities and quantifiers
01:09:07 <startling> augur: there are quine books in my library dedicated to the unabomber
01:09:10 <startling> proof!
01:09:17 <augur> lolwut
01:09:37 <augur> ski: the barcan formula is .. weird
01:09:50 <augur> i took a class on modal logic
01:09:52 <augur> it was really fun
01:09:56 <augur> but when we got to barcan, man
01:10:18 <augur> or maybe it wasnt barcan but something equivalent
01:10:20 <augur> i dont know
01:10:36 <ski> see "de re vs. de dicto" at <http://plato.stanford.edu/entries/prop-attitude-reports/dere.html> (unread)
01:10:42 <augur> oh man
01:10:47 <augur> barcan died in february
01:10:47 <augur> :(
01:10:49 <startling> augur: Ted Kacyzinski was a mathematician. Quine taught him a class on Logic. I happen to live in the town where Ted grew up. Turns out a lot of unfortunate things happened to him as a youth; his therapist donated some books to the library in his name
01:11:38 <ski> ):
01:11:48 <augur> ski: where/how should i mention BHK?
01:11:57 <ski> i'm not sure
01:12:14 <augur> hm
01:12:25 <ski> i'm not exactly sure myself of it's relation to CH -- it only seems to me there's some clear connection
01:13:00 <ski> (i would hesitate to say they're basically the same idea, since then why would we need both names :)
01:13:04 <augur> well, the connection seems to be that the formatives just constitute the algebra operators in BHK
01:13:18 <augur> *I == (,)
01:13:29 <augur> almost
01:13:47 <augur> its not quite an algebra operation but you know what i mean
01:14:00 <augur> i dont know.
01:14:02 <augur> anyway.
01:14:16 <augur> the signature operations
01:14:19 <augur> thats what i mean
01:14:34 <ski> BHK have been elaborated as the realizability interpretation, which is about interpreting every proof as a primitive recursive function
01:14:34 <augur> anyway anyway
01:14:50 <ski> (which doesn't mean that BHK necessarily is only about that)
01:14:54 <Cale> http://faculty.valpo.edu/lpudwell/papers/mm005281.pdf -- see footnote 1
01:15:10 <startling> Cale: is that "famous for his other work"?
01:15:26 <Cale> "Better known for other work."
01:15:52 <augur> hmm
01:15:55 <startling> yep, that's the one. heh
01:15:59 <ski> (the realizability interpretation is related to the Markov Russian school of recursive mathematics, in which every mathematical object can be coded as a natural number)
01:16:26 <augur> ski: i think i have a feeling for the soundness reductions from a formal standpoint
01:16:34 <ski> ok ?
01:17:38 <augur> you have   Elim[xs] (Intro[ys] Ps) Qs  ==>  substitutions for xs and/or ys
01:17:53 <augur> im not sure if xs/ys can both be non-empty tho
01:17:54 <augur> like
01:18:25 <ski> hm, i suspect maybe
01:18:55 <ski> i was pondering some variant of `W x : A. P[x]'
01:18:57 <augur> Elim[x] (Intro[y] ([y : Q] ... P) P') ([x : P'] ... Q) ==> P' ... Q ... P
01:20:11 <augur> Cale: oh man thats great
01:20:15 <ski> the intro rule takes an `A' (named `v' say), and an `P[v] |- W x : A. P[x]', and constructs an `W x : A. P[x]'
01:21:06 <augur> i dont like sequent rules that use substitution like that
01:21:10 <ski> `A' can be seen as a type of questions, and `P[x]' is a type of answers for the particular question `x'
01:21:48 <augur> it makes it hard to state the natural deduction equivalents
01:22:05 <ski> then `W x : A. P[x]' is a strategy for (the asker in) a game
01:22:33 <augur> the way i described CH in my tutorial, i tried to make it really bare bones, so that a prof   G ...p... A is literally just written   G |- p : A
01:22:37 <ski> however, it would be nicer if the type of the next question could also depend on the answer to the last question
01:22:50 <augur> so its hard to write the proof tree for something like   G[x/y] |- p : A
01:23:37 <ski> well, `G[x/y]' there is a meta-operation
01:23:43 <augur> yeah
01:23:46 <augur> this is why i dont like it
01:23:50 <ski> in any concrete case, the `[x/y]' part wouldn't appear
01:23:57 <augur> because i want my ND trees to be just concrete trees
01:24:02 <augur> i mean
01:24:09 <ski> well, the rules are rule schemas
01:24:10 <augur> ig you have a meta-rule   G[x/y] |- p : A
01:24:16 <augur> what is the equivalent ND rule?
01:24:32 <augur> its hard to say, because the rule would have to make reference to more than just the premises
01:24:36 <ski>   G[x/y] ..p.. A
01:24:37 <ski> ?
01:24:46 <augur> something like that, yeah
01:25:14 <augur> you also, of course, have to figure out how to represent G[x/y] as a tree
01:25:18 <augur> i dont even know how you'd do that
01:25:37 <ski> well, it's not a tree, it's the (non-discharged) leaves of a tree
01:25:49 <ski> (`p' is the tree)
01:25:53 <augur> M[x/y] isnt a lambda term, as such, either
01:25:57 <augur> its a whole slew of trees
01:26:12 <augur> i wonder if this goes away if you have explicit substitution
01:26:20 <augur> and what would explicit substitution be in ND?
01:26:28 <augur> what propositions would it produce
01:26:29 <ski> given a concrete lambda-term `M', `M[x/y]' is a concrete lambda-term
01:26:29 <augur> curious
01:26:42 <augur> well
01:26:51 <augur> M[x/y] is a concrete lambda term, yes
01:26:57 <augur> but given M[x/y]
01:27:03 <ski> <augur> and what would explicit substitution be in ND?
01:27:05 <augur> which is the issue.
01:27:11 <ski> do you mean a substitution rule, or what ?
01:28:00 <augur> what is that question in reference to
01:28:11 <ski> your statement, which i quoted
01:28:40 <augur> oh, i just mean
01:28:57 <augur> you have this explicit substitution formative in some variants of the LC
01:29:11 <ski> oh ?
01:29:18 <ski> do you mean `let x = M in N' ?
01:29:34 <augur> T  ::=  variable  |  T T  |  \variable.T  |  T[T/variable]
01:29:48 <augur> so that M[x/y] is an actual term, not a metarule
01:29:52 <augur> well, meta object
01:29:54 <ski> oh -- i think that's a bit strange
01:30:04 <augur> yeah, but it apparently makes normalization really fast or something
01:30:17 <augur> because substitution can be made lazy, i think
01:30:26 <augur> http://en.wikipedia.org/wiki/Explicit_substitution
01:30:39 <ski> hm
01:30:57 <ski> something a bit similar can be used for reduction contexts (felleisen contexts)
01:31:50 <augur> i think explicit substitutions are sort of like carrying around environments
01:31:56 <augur> but in little pieces here and there
01:32:03 <augur> instead of in one big map
01:32:14 <ski> hm, yes
01:32:25 <augur> i bet you could show equivalence
01:32:41 <ski> well, with environments, you distribute, which is that that WP link shows is done
01:32:47 <augur> build up the substitution map, and only reduce it at variables
01:33:18 <augur> x @ <M/y, N/x>  ==>  x @ <N/x>  ==>  N
01:33:26 <ski>   ap (Reader env_f) (Reader env_x) = Reader (\env -> (env_f env) (env_x env))
01:33:31 <augur> no thats not what i mean
01:33:32 <augur> what i mean is
01:33:42 <augur> an environment is like a big list of <M/x>'s
01:33:58 <augur> whereas in explicit substitution, you just have individual <M/x>'s
01:34:03 <augur> scattered here and there
01:34:20 <ski> ok
01:35:33 <ski> Paul Taylor's "Practical Foundations of Mathematics" goes some into substitutions and weakenings in some beginning chapter
01:36:35 <ski> <http://www.cs.man.ac.uk/~pt/Practical-Foundations/html/s11.html> (figures may be broken in HTML)
01:57:39 <augur> ski: hmm
01:57:40 <augur> curous
01:57:58 <augur> its hard to translate \x.\y.x into a proof tree
01:58:30 <augur> at least, if the ->I rule makes reference to hypotheses
01:58:37 <augur> i should remove the hypotheses
01:59:02 <augur> but that would make it hard to state the sequent rule
01:59:34 <edsko> does Martin Grabmueller hang round here?
01:59:39 <augur> i suppose a proof "tree" could just have some just floating around, but that wouldnt be fun
02:00:01 <augur> edsko: never heard of him, but who knows
02:01:03 <ski>                     - x
02:01:06 <ski>                     A
02:01:10 <ski>        [y : A] ------ ->I
02:01:15 <ski>                B -> A
02:01:18 <ski>   [x : A] ----------- ->I
02:01:21 <ski>           A -> B -> A
02:01:29 <augur> yeeah, exept thats not how i have it defined :p
02:01:33 <ski> (oops, s/y : A/y : B/)
02:01:57 <ski> mutatis mutandis, &c. &c.
02:02:24 <augur> that also makes it difficult to relate to sequent rules
02:02:58 <ski> just move the introduction of `x' and `y' over to a superscript on `->I', and use `[A]^x' instead ?
02:03:12 <augur> because the way im trying to set this up, the hypotheses in G |- ... are just the hypotheses in a proof tree
02:03:48 <ski> well, the hypotheses in `G' are the ones which are *allowed* to occur (freely) in the the proof tree
02:03:50 <augur> what you have there is only one hypothesis: -x A
02:04:05 <augur> hm
02:04:05 <ski> each such hypothesis may occur zero times, one time, or more times
02:04:23 <ski> cf. proof of `|- A -> A /\ A'
02:04:26 <augur> i suppose i can state this somewhere and then handwave my way out of this :)
02:06:02 <augur> i suppose i could also add a D in those places where extra hyps can appear
02:06:14 <augur> or use some notation like G^+
02:06:17 <ski> where would that be ?
02:06:21 * hackagebot svm-simple 0.2.7.1 - Medium level, simplified, bindings to libsvm (VilleTirronen)
02:06:26 <augur> most rules, really
02:06:34 <ski> well, i suppose you could say
02:06:44 <augur> i want to be able to talk about _the_ hyps in a tree
02:06:51 <ski>   ------------------
02:06:52 <ski>   G , x : A |- x : A
02:07:07 <ski> (which i think is the most common thing to do, i type systems)
02:07:19 <augur> i guess that works
02:07:37 <ski> then you could use
02:08:12 <ski>   G |- p : A   G |- q : B
02:08:18 <ski>   ----------------------- /\I
02:08:19 <ski>   G |- (p,q) : A * B
02:08:26 <ski> but perhaps you don't want that ?
02:08:34 <augur> i think thats fine
02:08:46 <augur> im more concerned about the obviousness of the translation into sequents
02:08:56 <ski> (but that way of writing rules with multiple premises goes well with the above way of writing rules with zero premises)
02:08:58 <augur> as it is now, the sequents are literally nothing more than notation for actual proofs
02:09:14 <augur> they dont "mean" anything, they just _are_ proof objects in ND
02:09:23 <augur> more or less
02:09:38 <augur> well, no i guess they're judgements
02:09:44 <augur> so its ok if the judgement has more crap than the proof
02:09:45 <augur> yeah ok
02:09:46 <augur> :)
02:10:02 <ski> ok, then i suppose having no `G' in the axiom, and using union in the multiple-premise rules could be nicer
02:10:12 <ski> hm, ok
02:11:08 <ski> (they are judgements which are meant to reflect the structure of the derivation in the object logic considered, if i understood your point correctly)
02:12:02 <augur> yeah
02:12:46 <augur> but i do suppose that its valid to say that a proof of P can be said to proceed from starting assumptions
02:12:54 <ski> (though i tend to just view it as basically the same logic written in a Gentzen-style ND instead of a Prawitz-style ND)
02:13:11 <augur> so we might have some starting assumptions x, y, z
02:13:23 <augur> but then the proof of P might only make use of one assumption
02:13:27 <augur> so the tree only has one
02:13:34 <augur> but we still started out assuming x, y, and z
02:13:46 <augur> so in some sense assumptions and hypothesis nodes are not quite the same thing
02:13:47 <ski> well, it's as least as common to start from the conclusions and try to see how to justify it from some plausible premises (found on the way)
02:13:47 <augur> hmm
02:13:52 <ski> (rationalization and all that)
02:14:39 <ski> but sure, we could take a view when we start with both the premises and the conclusion (i.e. the sequent we want to prove)
02:29:40 <rtharper> there's still no way to make ghc's --make parallel, right?
02:33:05 <ClaudiusMaximus> rtharper: ghc -M and make -j might work?
02:33:26 <ClaudiusMaximus> rtharper: (but i've never tried it)
02:33:32 <rtharper> ah, -M generates a Makefile?
02:34:04 <ClaudiusMaximus> rtharper: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#makefile-dependencies
02:34:12 <mmaruseacph2> afaik it only generates the dependencies
02:34:17 <rtharper> thanks
02:35:00 <mmaruseacph2> my bad
02:36:34 <ClaudiusMaximus> mmaruseacph2: i think you're right, the section before has some rules to use
02:36:40 <Eduard_Munteanu> I guess it still doesn't let you build that dependency graph in a parallel fashion.
02:37:27 <Eduard_Munteanu> E.g. if A depends on B depends on etc. they'll all end up as a single ghc invocation / process.
02:37:50 <Eduard_Munteanu> But I'm not sure either.
02:38:35 <mmaruseacph2> i don't have ghc on this station and I cannot install it
02:38:40 <mmaruseacph2> but it is worth a try
02:42:46 <Eduard_Munteanu> mmaruseacph2: btw, hey, I heard Giumale has retired, did anyone take over his functional programming-related courses?
02:44:52 <mmaruseacph2> Eduard_Munteanu: it's still fuzzy
02:45:08 <mmaruseacph2> it is possible that I'll have the type systems lab
02:45:25 <mmaruseacph2> but we'll know in september
02:45:33 <Eduard_Munteanu> Nice, I didn't know there was a course for that. Is that a masters lab?
02:45:53 <mmaruseacph2> Matei and Mihnea and Andrei Mogos for paradigms
02:45:59 <mmaruseacph2> yes, at the AI master
02:51:20 <mentus> hi everybody
02:52:34 <Eduard_Munteanu> mentus: hi
02:57:40 <mentus> learning haskell
02:58:01 <mentus> i was wondering if one can use infix notation with backquotes with curried functions
02:58:13 <zomg> mentus: sure, should work
02:58:23 <mentus> like e.g. 1 `fn 2` 2
02:58:30 <mentus> fn accepts three arguments
02:58:53 <fmap> no
02:59:01 <zomg> Not with that syntax I don't think
02:59:07 <mentus> ok..
02:59:16 <mentus> yes, i am indeed getting an error
02:59:30 <mentus> but i thought might be some way to do it in haskell
02:59:56 <fmap> you can use (1 `fn` 2) 2
03:00:13 <Nereid> let g = fn 2 in 1 `g` 2
03:00:22 <Nereid> I think he wants something that means this
03:00:44 <mentus> Nereid: yes
03:01:26 * hackagebot Hipmunk 5.2.0.10 - A Haskell binding for Chipmunk. (SoenkeHahn)
03:01:28 * hackagebot morfette 0.3.5 - A tool for supervised learning of morphology (GrzegorzChrupala)
03:02:28 <Nereid> anyway, the answer is no
03:02:35 <mentus> ok, thanks
03:03:08 <augur> ski: the original papers on the LC were ... well, lets say not the LC we all know and love
03:03:43 <ski> augur : hm ?
03:03:52 <augur> ski: i just read church's original paper
03:04:01 <augur> its almost unrecognizable
03:04:05 <ski> the calculi of lambda-conversion ?
03:04:42 <augur> basically, church's original lambda stuff was frege with variable binding by lambda
03:04:43 <augur> thats it
03:05:18 <augur> like, there were formatives for things like & and forall
03:05:25 <augur> not in the type world, there were no types
03:05:27 <ski> frege had some variable-binding stuff as well (even macros)
03:05:30 <augur> in the lambda term world
03:05:38 * ski nods
03:05:39 <augur> "&" was a lambda term
03:05:45 <augur> "forall" was a lambda term
03:05:49 <Nereid> mentus: if you read the report, there will be something that tells you that operators like `g` can only be variable/constructor names (possibly qualified), not expressions
03:05:51 <Nereid> section 3.2
03:05:55 <ski> yeah, that was Church's original motivation, iiuc
03:05:58 <augur> so you could do things like "&(&,&)"
03:06:00 <augur> etc
03:06:32 <augur> or, well, in church's notation, "{{&}(&)}(&)" which we would write as &&&
03:06:39 <mentus> Nereid: ok, thanks. good to know
03:06:51 <augur> ski: i think he had some reductions as well
03:06:56 <ski> who ?
03:07:00 <augur> church
03:07:18 <augur> axiomatic reductions for things beyond just lambda
03:07:32 <ski> yeah, delta ..
03:07:40 <augur> but crucially, also, he said weird things like "when F is meaningful"
03:08:13 <augur> i wonder if his & and forall can be viewed as the &I and forallI constructors ...
03:08:15 <ski> iirc, he explicitly allows functions whose domain include the same function
03:08:24 <augur> i should try to go through this paper in more detail
03:08:55 * ski has only browsed it a little
03:09:12 <augur> i imagine what he means by "when F is meaningful" is roughly what we would use to mean "when F type checks"
03:09:38 <ski> well, at least well-formedness is a part, i think
03:09:44 <augur> no it cant be
03:09:49 <augur> he says "&" is well formed
03:09:52 <augur> and "forall" is well formed
03:10:07 <augur> i mean, quantification is not
03:10:09 <augur> forall x. P
03:10:10 <augur> its
03:10:22 <ski>   Pi (\x. P)
03:10:23 <augur> forall(\x.P)
03:10:28 * ski nods
03:10:32 <augur> its an actual function
03:10:39 <ski> of course
03:10:42 <augur> we'd say something like (X -> Bool) -> Bool
03:10:42 <ski> it's HOAS
03:10:56 <augur> its not quite HOAS tho
03:11:12 <augur> i mean, it uses internal functions not external functions
03:11:18 <ski> well, we don't have it on the object level, true
03:11:29 <augur> but yeah, its the higher order version of things
03:11:57 <augur> but its also sort of ... i dont know
03:12:12 <augur> i mean, if we want to view these things as terms not propositions
03:12:15 <augur> assuming we distinguish them
03:12:34 <ski>   &  =  \p. \q. Pi (\r. (p -> q -> r) -> r)  ; Church-style encoding
03:13:07 <augur> then i think we have semntics like [[Pi]] = f |-> true iff forall x. f x is true
03:13:46 <ski> *nod*, cf. `Pi_A : Omega^A >---> Omega' in topoi
03:14:18 <ski> (and with `Sierpinski' in place of `Omega' in topological spaces, where `A' is a compact space)
03:14:25 <augur> but i think the original stuff didnt really distinguish propositions from proofs
03:14:45 <augur> so you have like... Pi A B is also the proposition
03:14:54 <augur> not just the term that proves it
03:14:55 <ski> i'm not sure to what extent it treats proofs at all (but i've only skimmed the paper)
03:14:58 <augur> which is hard to really understan
03:15:20 <augur> im never sure which side of : these things belong on
03:15:39 <mroman> Can I influence the randomness of quickcheck testcases?
03:15:40 <augur> i feel left, because we wouldnt want \x.M to be on the right
03:15:42 <ski> in my limited understanding, i suspect it's solely the type-side of `:'
03:15:52 <augur> :)
03:16:12 <augur> i cant see it as being on the type side
03:16:19 <augur> Pi, &, and \x.M arent types
03:16:24 <ski> why not ?
03:16:30 <Eduard_Munteanu> augur: I think Pi A B should be just the proposition, not the term
03:16:37 <augur> ski: how are they types?
03:16:42 <ski>   newtype Pi p = MkPi (forall a. p a)
03:16:49 <ski>   Pi :: (* -> *) -> *
03:16:58 <augur> well yes but i mean
03:17:02 <augur> sure Pi can appear in a type
03:17:04 <ski>   Pi :: forall k. (k -> *) -> *  -- with polymorphism
03:17:05 <augur> but by itself its not a type
03:17:10 <augur> its a type function
03:17:22 <ski> well, it's not a *concrete* type, no
03:17:36 <Eduard_Munteanu> Isn't Pi just a dependent (->) that comes with a binder?
03:17:36 <augur> thats what i mean
03:17:37 <ski> imo a type function is a type, just as a value function is a value
03:17:47 <augur> well, what i mean ski
03:17:48 <augur> is
03:17:56 <nand`> dmwit: my software works :) http://sadpanda.us/images/1087586-KH5JE2S.png
03:17:57 <augur> Pi cant appear on the right of :
03:17:58 <augur> as in
03:18:01 <augur> you cant have ... : Pi
03:18:06 <ski> so ?
03:18:25 <augur> so im not sure it qualifies as a type!
03:18:28 <ski> if we're going to skip `<term> : <type>' altogether, and only focus on `<type>', it doesn't matter
03:18:32 <augur> if by type we mean things that appear there
03:18:45 <augur> well yes, i mean, this whole thing is devoid of :
03:18:51 <ski>   <type> ::= <type> <type> | \<tyvar>. <type> | <tyvar> | ...
03:18:54 <augur> im just saying, im not sure if its better to view these as types or terms
03:18:55 <augur> or both
03:18:56 <augur> or neither
03:19:13 * Eduard_Munteanu means like   Pi (x : A) (<something that may mention 'x'>)
03:19:13 <ski> well, s/types/propositions/ then, better ?
03:19:22 <Eduard_Munteanu> Though that's heavily influenced by my Agda :/
03:19:28 <augur> ski: whatever :p
03:19:32 <augur> propositions, sure
03:19:33 <augur> anyway
03:19:34 <ski> Eduard_Munteanu : well, here it'd be `Pi A (\x. ..x..)'
03:19:45 <augur> i guess in this system propositions and terms are almost the same?
03:19:56 <Eduard_Munteanu> Yeah, makes sense.
03:19:56 <ski> (but i think the `A' possibly wasn't there in Church's version)
03:20:01 <augur> propositions being the meaningful terms that produce booleans i guess
03:20:03 <nand`> dmwit: the interesting thing is, I checked with a very color blind person I know and he doesn't see a difference between the leftmost and the rightmost images unless he concentrates really hard (and then only the tshirt)
03:20:18 <Eduard_Munteanu> (By analogy to Σ, say.)
03:20:36 <dmwit> nand`: \o/
03:20:40 <ski> augur : well, i suppose in `Pi (\x. ..x..)', `x' wouldn't have to stand for a proposition
03:20:48 <augur> right
03:20:50 <augur> but it could
03:20:54 <ski> yes
03:21:08 <ski> (see the definition of `&' above)
03:21:09 <nand`> dmwit: and his descriptions of the middlemost image confirm my project's goal: simulating colorblindness for a colorblind person :)
03:21:10 <augur> i feel like if these things are on the left of : its easy to understand
03:21:29 <augur> Pi : forall (k -> *) -> *
03:21:33 <augur> & : * -> * -> *
03:21:34 <ski>   Pi_A : (A -> *) -> *
03:21:42 <Eduard_Munteanu> k?
03:21:48 <ski> itym
03:21:56 <augur> forall k. (k -> *) -> *
03:21:57 <ski>   Pi : forall k. (k -> *) -> *
03:22:02 <dmwit> Simulating colorblindness for a *colorblind* person?
03:22:03 <augur> typo, gosh
03:22:05 <ski> or, if you insist
03:22:15 <ski>   Pi : Pi (\k. (k -> *) -> *)
03:22:20 <ski> :)
03:22:28 <augur> well, i was thinking
03:22:32 <Eduard_Munteanu> Does that paper limit Pi to types, and not kinds etc.?
03:22:37 <augur> if we use : to encode church's "is meaningful"
03:22:50 <ski> Eduard_Munteanu : i don't think it really talks much about types at all
03:22:56 <augur> we'd have Pi vs. the meta-formative forall
03:23:00 <ski> i.e. it's more or less typeless
03:23:14 <augur> and then the whole thing does make sense as terms
03:23:21 <nand`> dmwit: yes. The person is red/green color blind. So what I did was I transformed the RGB image into an opponent model colorspace and zeroed that difference channel, then converted back to RGB. That produces the right image, aka what he sees. Then I did the same thing but I zeroed the *other* opponent channel (yellow/blue), producing the middle image. He perceives the middle one as monochrome as compared to
03:23:24 <nand`> the right one. Now he knows how much he's missing :P
03:23:28 <ski> (but has propositions, which you can view as "types" in some sense -- only i think there's no "values" for them mentioned, iirc)
03:23:36 <Eduard_Munteanu> AFAIU, Pi is simply a combinator that introduces foralls, just like Σ introduces existentials in a sense.
03:24:14 <augur> Eduard_Munteanu: yes, but thats not the issue
03:24:14 <nand`> (there are actually yellow/blue color blind people too but the condition is very rare)
03:24:30 <augur> the issue is whether or not these things should be seen as terms, propositions, types, or what
03:24:41 <however> nand`: nice software. sounds awesome
03:24:51 <nand`> however: I imagine it's useful for web designers et al.
03:25:07 <augur> i think, ski, that church was making a different equation than we normally make. he was doing propositions = terms, meaning = types
03:25:15 <augur> only without being explicit about meaning = types
03:25:18 <Eduard_Munteanu> augur: normally I'd say types, but if types can be first-class terms too, then that goes too.
03:25:44 <augur> ski: in a sense, he was describe a term language for encoding propositions, i think
03:25:52 <augur> not a term language for encoding proofs of propositions
03:25:56 <ski> augur : however .. in Martin-Löf, he doesn't really have `Pi : forall k. (k -> *) -> *' (instead `Pi'/`Forall' is a higher-order syntax)
03:26:09 <jacobian> <augur> i imagine what he means by "when F is meaningful" is roughly what we would use to mean "when F type checks"
03:26:31 <jacobian> If you say meaningful you get to have late binding for your choice of type checker :)
03:26:34 <augur> its interesting that the term language for propositions in church's sense, and the term language for proofs in our sense, are so similar
03:26:45 <augur> i guess this isn't a surprise
03:26:57 <Eduard_Munteanu> Therefore an encoding for types, you could say?
03:27:00 <ski> augur : i'm not sure about the "meaning = types" part
03:27:19 <ski> from the parts is skimmed, he appeared to have a basically typeless perspective
03:27:21 <augur> ski: well, contemporarily, we use types to sort of ensure meaningfulness of our terms
03:27:32 <ski> s/is/i/
03:27:42 <hpaste> nand` pasted “Colorblindness simulations” at http://hpaste.org/71681
03:27:43 <augur> that is, we _could_ think of (+), say, as ranging over _everything_
03:27:45 <augur> not just numbers
03:27:48 <augur> but haave it be partial
03:27:51 <augur> defined only for numbers
03:28:04 <augur> so that tree + dog is undefined
03:28:07 <augur> ie meaningless
03:28:11 <augur> but 1 + 2 is defined, ie meaningful
03:28:17 <francoccc> I will chime in only to paste this http://spl.smugmug.com/Humor/Lambdacats/i-dVj9xxz/0/O/recurcat.gif
03:28:34 <ski> <augur> ski: well, contemporarily, we use types to sort of ensure meaningfulness of our terms
03:28:36 <augur> in which says the meaningful uses of (+) are the ones where we have something like   x : Num, y : Num,   x + y
03:28:38 <augur> : Num
03:28:57 <ski> yes, but i don't recall reading Church explaining that in the paper
03:29:01 <augur> and we just immediately rule out the meaningless uses of (+) by saying they dont type check
03:29:09 <augur> thats my understanding of the purposes of types, anyway
03:29:34 <ski> i'm not sure if the role of types was that well-understood at the time
03:29:38 <however> francoccc: very nice, thank you :)
03:29:43 <augur> but if thats what meaningfulness is really about, which i think is what church was getting at --- definedness --- then types encode meaning
03:29:49 <augur> ski: i agree
03:29:57 <francoccc> ehehe however , we need a laugh now and then :)
03:30:13 <augur> ski: but people seemed to think church's LC made sense, so it cant be just nonsense that happened to look good
03:30:24 <augur> ski: and somehow people took it and derived the modern LC
03:30:31 <ski> i vaguely recall reading Church saying that the *same* `id' function can be applied to any (meaningfully defined value) (e.g. it can be applied to itself)
03:31:01 <augur> so i think the connection is fairly straight forward -- people imposed types to encode meaningfulness, and put church's gadgets on the left
03:31:03 <ski> and i interpreted that as him wanting to get something like universal polymorphism -- however getting it by dynamic typing instead
03:31:07 <augur> as encodings of propositions
03:31:16 <dmwit> > fix not
03:31:20 <lambdabot>   mueval-core: Time limit exceeded
03:31:24 <ski> (so the domain of `id' really includes `id', instead of it being a polymorphic function in our sense)
03:31:26 <augur> and then someone probably noticed that typing rules are awfully similar to proofs of propositions
03:31:51 <Nereid> so, how much of a stretch would it to make (->) have kind forall k. k -> k?
03:31:57 <Nereid> er, k -> k -> k
03:31:59 <Eduard_Munteanu> Is that older than the CH correspondence?
03:32:00 <Nereid> instead of * -> * -> *
03:32:17 <augur> ski: well, you just need to have a single domain U of everything, including terms
03:32:20 <dmwit> Nereid: What would you do if it had that kind?
03:32:25 <Nereid> example
03:32:31 <ski> <augur> that is, we _could_ think of (+), say, as ranging over _everything_
03:32:33 <ski> <augur> not just numbers
03:32:40 <Nereid> if X and Y had kind * -> *
03:32:51 <Nereid> then I'd define X -> Y :: * -> *
03:32:59 <Nereid> where (X -> Y) a = X a -> Y a
03:33:16 <ski> Frege does almost the same thing, except he doesn't like partiality, so he defines the negation of the `Truth' to be the `Falsity', and the negation of everything else to be the `Truth'
03:33:41 <Nereid> (hmm, does this make sense?)
03:33:41 <ski> (also, to Frege a function is *not* a value, but that's another thing)
03:33:46 <augur> ski: weird. church explicit mentions partiality somewhere
03:33:49 <augur> lesse...
03:33:58 <dmwit> Nereid: When you say "I'd define ...", at what level does the definition live? User code? GHC source?
03:34:02 <Nereid> I don't know.
03:34:10 <Eduard_Munteanu> Nereid: that'd be weird
03:34:18 <Nereid> I just want to be able to write X -> Y.
03:34:19 <dmwit> Sounds like a bit of a stretch. =)
03:34:23 <\rs> must i define a phantom type data A a = A to execute IO actions for each node in a Data.HashMap.Strict.HashMap
03:34:42 <\rs> to use its traverseWithKey
03:34:47 <Eduard_Munteanu> How about a newtype wrapper Nat instead?
03:34:55 <however> nand`: i just randomly thought that someone should turn this into a tool that filters your screen, so you see it as someone colorblind would. like how redshift "makes your screen red" http://jonls.dk/redshift/ but i imagine it'd be quite some effort to get it hacked into the x server or graphics driver or whatever :)
03:34:55 <Eduard_Munteanu> If you know where I'm going with this :)
03:35:00 <dmwit> You can already write data MyArrow f g a = MyArrow (f a -> g a) or even data MyArrow f g = MyArrow (forall a. f a -> g a)
03:35:05 <augur> yeah, ski, so he says that we allow that if we have a function F, and a value X, F(X) might be neither true nor false but undefined
03:35:08 <Nereid> yes, but here's the reason:
03:35:24 <Nereid> we have a class Functor (f :: *)
03:35:26 <ski> <augur> so i think the connection is fairly straight forward -- people imposed types to encode meaningfulness, and put church's gadgets on the left
03:35:30 <ski> you may be right, there
03:35:35 <Nereid> where fmap :: (a -> b) -> f a -> f b
03:35:39 <\rs> if not, what's the idiom to traverse a HashMap
03:35:47 <ski> <augur> and then someone probably noticed that typing rules are awfully similar to proofs of propositions
03:35:51 <Nereid> er, f :: * -> *
03:35:57 <ski> Church,Howard,Griffith, &c. :)
03:36:06 <Nereid> but "fmap :: (a -> b) -> f a -> f b" would then make sense even if f had any kind of the form k -> *
03:36:16 <Nereid> er, * -> k
03:36:33 <dmwit> FSVO "make sense"
03:36:34 <augur> ski: tho he also says this:   For such a value X of the independent variable we supposed that F(X) is undefined and represents nothing, and we use a system of logical symbols capable of dealing with propositional functions whose range of definition are limited.
03:36:35 <ski> (well, possibly Church was mentioned there in a more of an honorary sense, not sure)
03:36:40 <Nereid> so then
03:37:01 <nand`> however: afaik the x server just allows per-channel gamma ramps, whereas my calculations rely heavily on cross-channel interactions
03:37:06 <Nereid> if I wanted something like a Functor, except with kind * -> (* -> *)
03:37:30 <ski> Nereid : hm, not `forall k. k -> k -> *' ?
03:37:37 <augur> ski: i feel like the LC we know and love is in large part due to people other than church.
03:37:51 <Eduard_Munteanu> Nereid: you can define (exo)functors already though, it just has to involve other stuff
03:37:54 <ski> <augur> ski: well, you just need to have a single domain U of everything, including terms
03:37:55 <Nereid> I wouldn't have to write an extra class definition like class Functor1 f t where fmap1 :: (a -> b) -> f t a -> f t b
03:38:00 <Nereid> (or something like that?)
03:38:04 <ski> yes, which is the typeful way to explain the typeless view
03:38:04 <however> nand`: right, it's clearly not as simple as adjusting 3 gamma values
03:38:25 <Eduard_Munteanu> I once did something like...
03:38:26 <Eduard_Munteanu> class (Category c, Category c') => GFunctor c c' f | f -> c c' where gfmap :: c a b -> c' (f a) (f b)
03:38:54 <ski> <augur> yeah, ski, so he says that we allow that if we have a function F, and a value X, F(X) might be neither true nor false but undefined
03:39:00 <Nereid> ok I don't think that last line was right.
03:39:04 <ski> even if `F' and `X' are well-defined, right ?
03:39:13 <augur> ski: yes
03:39:24 <Nereid> oh.
03:39:25 <Nereid> I meant
03:39:26 <Eduard_Munteanu> And that's pretty much a functor between arbitrary categories.
03:39:36 <Eduard_Munteanu> Not just Hask -> Something.
03:39:45 <Nereid> fmap1 :: (a t -> b t) -> f (a t) -> f (b t)
03:40:07 <Nereid> wait.
03:40:10 <Nereid> I haven't thought this through.
03:40:21 <ski> Nereid : yeah, i'm not sure what's the nicest solution to what you want (i've been pondering it myself)
03:40:39 <Nereid> I mean
03:40:49 <Nereid> the idea came up when I was looking at index-core.
03:40:55 <augur> ski: its odd tho. im not sure, for instance, what this would mean: Pi x y z
03:40:59 <augur> oh but i guess
03:41:05 <augur> that would be one of those undefined terms?
03:41:16 <augur> man, how crazy
03:41:30 <Nereid> which defines IFunctor and IMonad, which are exactly analogous to Functor and Monad except for the different kind.
03:41:34 <augur> church's LC has a HUGE number of meaningless things
03:41:37 <augur> i dont like that at all
03:41:37 <ski> some kind of auto-natural-transformogrification or something ..
03:41:38 <Eduard_Munteanu> augur: maybe (Pi x y) with 'z' filled for the 'x'?
03:41:59 <augur> thats very disgusting, to have a huge abundance of terms which have no meaning
03:42:07 <augur> Eduard_Munteanu: no no thats not it at all
03:42:25 <Nereid> and then with -XRebindableSyntax it lets us use do notation for IMonads, but then
03:42:25 <ski> augur : do you prefer Frege's way which has lots of silly stuff like `not(4) = Truth' ? ;)
03:42:34 <Nereid> as far as I can tell, we lose the ability to use the same notation for ordinary Monads.
03:42:37 <augur> Eduard_Munteanu: for church, Pi F G basically encodes forall x. F x -> G x
03:42:43 <Eduard_Munteanu> Seriously, that sounds like PHP :P
03:42:49 <Eduard_Munteanu> Ouch.
03:42:50 <augur> ski: no, i prefer the type theoretic way :)
03:43:02 <Nereid> and instead you have to use this U thing.
03:43:05 <ski> (types reappear in Frege, to describe functions (which are not values))
03:43:06 <augur> just make it impossible to say nonsensical things
03:43:37 <augur> maybe these things really are "partial" functions
03:43:44 <augur> but we cant talk about the partial aspect
03:43:45 <ski> (and that is more or less the same thing as arities as mentioned in the start of the "Programming in Martin-Löf’s Type Theory" book i mentioned)
03:43:48 <Nereid> anyway, I'll think about this some more.
03:44:03 <augur> maybe "Pi x y z" really is "fine" in some grander sense, but we're not allowed to mention it
03:44:04 <Nereid> I admit I don't know much about anything. but I just think this would be nice to have.
03:44:08 <augur> its taboo
03:44:26 <augur> ski: yeah, the arities thing is very frege-like to me.
03:44:36 <augur> its also very grammar-y
03:44:41 <ski> yes, it's a grammatically incorrect utterance
03:44:59 <ski> *1) "Pi x y z"
03:45:07 <augur> ya
03:45:21 <augur> so the concept of applying Pi x y to z isnt a non-concept
03:45:27 <augur> it exists as a concept, we just cant mention it
03:45:31 <augur> so to speak
03:45:42 <augur> and not only that, but there is no meaning behind the concept
03:45:52 <ski> yeah, the fregean functions is really more about the grammar itself, than about types in the "traditional" sense
03:46:16 <augur> sort of like the concept of the largest triangle and the concenpt of the the smallest number not describable in under a hundred words
03:46:20 <ski> a fregean function is an expression with a hole in it
03:46:38 <augur> i feel like in some sense, types are exactly about grammar tho
03:46:39 <augur> but not entirely
03:46:44 <Nereid> oh.
03:46:44 <ski> to it corresponds a value, called its "course-of-values", which is its extension
03:46:46 <augur> they're grammar + meaning
03:46:52 <Nereid> you're right, I did mean (->) :: k -> k -> *
03:47:08 <augur> ski: frege doesnt even have functions, he just has unsaturated concepts
03:47:10 <Nereid> where, say for X, Y :: * -> *, X -> Y = forall a. X a -> Y a
03:47:27 <ski> Nereid : cf. `Hom_C : Ob(C) * Ob(C) -> Set'
03:47:39 <Nereid> heh yeah
03:47:58 <ski> (which was why i suggested that in the first place)
03:48:30 <Nereid> I knew what I wanted, I just should have thought it through before saying anything.
03:49:01 <ski> augur : well, he calls them "functions" :)
03:49:53 <augur> aha, ski, here we go:   The undefined terms of a formal system have, as we have explained, no meaning except in connection with a particular application of the system. But for the formal system which we are engaged in constructing we have in mind a particular application, which constitutes, in fact, the motive for constructing it, and we give here the meanings which our undefined terms are to have in this intended applicatio
03:49:54 <augur> n.
03:50:15 <Nereid> I will think about that GFunctor idea though.
03:50:22 <augur> he then says that if A is a value for which F is defined, then F(A) represents the value of the function at A
03:50:33 <augur> ski: does he? im pretty sure he says concept
03:50:35 <Nereid> maybe it's possible to make things work out without anything fancy and new.
03:50:37 <augur> well either way.
03:51:27 <augur> ski: so it seems that church almost defined types right there:   F is defined for the X's and produces Y's,  A is an X,  so F(X) is a Y
03:51:38 * hackagebot hslogger-template 2.0.1 - Automatic generation of hslogger functions (BrianLewis)
03:51:46 <augur> thats basically what he said, but without saying "X" and "Y"
03:52:24 <ski> augur : hm, i can't find it right now, but it's in one of his later writings (not "Begriffschrift"), iirc
03:52:33 <augur> ah
03:52:46 <augur> im mostly familiar with the grundlagen/grundgesetz
03:52:55 <ski> yeah, not that either
03:53:05 <ski> (i only have seen the first of those two)
03:54:58 <ski> augur : "From Frege to Gödel : a Source Book in Mathematical Logic, 1879-1931" compiled by J. van Heijenoort has Begriffschrift, and several other interesting papers by Skolem, Peano, Herbrand, Hilbert, Brouwer, &c.
03:55:05 <augur> also, ski, he goes on the say    If M is any formula containing the variable x, then \x[M] is a symbol for the function whose values are those given by the formula. That is, \x[M] represents a function, whose value for a value L of the independent variable is equal to the result S^x_L M | of substituting L for x throughout M, whenever S^x_L M | turns out to have a meaning, and whos value is in any other case undefined.
03:55:19 <augur> now i need to look at the details for substitution
03:55:57 <Nereid> aha, yeah.
03:56:03 <Nereid> even his suggestion runs into the same trouble
03:56:11 <Nereid> Category is defined as
03:56:15 <ski> <augur> ski: so it seems that church almost defined types right there:   F is defined for the X's and produces Y's,  A is an X,  so F(X) is a Y
03:56:20 <Nereid> class Category cat :: * -> * -> * where ...
03:56:24 <augur> no he doesnt explain substitution
03:56:25 <Nereid> not k -> k -> *
03:56:27 <ski> except it only seemed to me he was talking about dynamic typing
03:56:28 <augur> shame
03:57:18 <augur> ski: i suspect that church's initial formulation might be ultimately bad, in that you cant find a semantics for it in a model-theoretic sense, but good as a starting point
03:57:24 <ski> augur : that quote's from Church, yes ?
03:58:12 <ski> Nereid : yeah, need polymorphic classes
03:58:15 <augur> ski: i agree, he's dynamic/duck typed, but he makes these hand-waving gestures to informal typing. so i think its really all duck typed
03:58:19 <Nereid> exactly
03:58:26 <augur> also yeah, ski, its all church im quoting
03:58:33 <Nereid> I wonder if -XPolyKinds gives us enough. I haven't played with that.
03:58:36 <ski> Nereid : iiuc, `Typable' is now / will soon be polymorphic, in GHC
04:00:04 <augur> ski: the problem i have with giving things like this is that  [[ S[x/y] ]]  cant be derived compositionally from  S  and  x  i dont think
04:00:40 <ski> hm, elaborate on what you mean ?
04:00:44 <augur> you cant say   [[ S[x/y] ]] = [[ S ]]([[ x ]])   because S by itself has free variables
04:01:07 <augur> i guess maybe you could see it as a function term
04:01:22 <augur> so that S with free variables is sortof like a sequent
04:01:32 <augur> and we have internal functions and external functions
04:01:57 <augur> S is an arrow in the category, while Pi is an element of an exponential object
04:01:57 <ski> yeah, so you need to start with `[[rho |-> S]]', then, where `rho' enumerates the free variables which may occur in `S'
04:02:33 <augur> perhaps thats whats needed -- if we can give a semantics to terms with free variables, church's calculus has a semantics
04:03:10 <augur> so i think it really is just the untyped LC as usual (with Omega == Omega^Omega as the only type/object in the category)
04:03:22 <ski> well, rename `rho' to `x,...', and say :  [[x,... |-> S]] = \rho |-> [[S]][x := rho.x,...]
04:03:40 <augur> and with some extra pre-defined arrows  Pi : Omega * Omega -> Omega
04:03:49 <ski> hum, i suppose just
04:03:53 <ski>   [[x,... |-> S]] = \rho |-> [[S]][x := rho.x,...]
04:03:54 <ski> er
04:04:03 <ski> hm
04:04:10 <augur> im not sure what you mean by   x , ... |-> S
04:04:25 <augur> the problem is with terms like F(x)
04:04:39 <augur> what is   [[ F(x) ]]
04:04:39 <ski> i mean, don't start with a term, start with a pair of a term and a list of variables which may occur free in it
04:05:30 <ski> then we can take the meaning of this to be a function which maps a record indexed by the variable names (i.e. an environment) to the value of the term
04:05:53 <augur> i think it can only be   [[ F(x) ]] : Omega^|FV(F(x))| -> Omega
04:06:15 <ski> so then `[[S]]' in `[[ S[x/y] ]]' will be a function from such an environment
04:06:18 <augur> ski: ahh. i i guess that makes sense. :)
04:06:41 <augur> thats basically the ND -> Sequent transformation i was suggestion earlier
04:06:44 <augur> i think
04:07:02 <augur> where we start with some variables that we _might_ use, and then define a proof term form them
04:07:11 <augur> from*
04:07:24 <ski> i.e., it'll really be `[[x,...,y |-> S]]' from `[[x,... |-> S[x/y] ]]', i think
04:07:38 <augur> assuming x is there
04:07:52 <ski> er, sorry, different `x'
04:08:00 <augur> i think its more   [[y, ... |-> S]]   =>   [[x, ... |-> S]]
04:08:08 <augur> hmm hmm
04:08:18 <ski> `[[x,...,y |-> S]]' from `[[x,... |-> S[T/y] ]]'
04:09:58 <ski>   [[x,... |-> S[T/y] ]]  =  \rho |-> [[x,...,y |-> S]](rho,y |-> [[x,... |-> T]])
04:10:02 <ski> something like that
04:10:39 <ski>   [[x,... |-> S[T/y] ]]  =  \rho |-> [[x,...,y |-> S]](rho,y |-> [[x,... |-> T]](rho))
04:17:28 <dsyang> Anyone work with Parsec before?
04:17:49 <merijn> dsyang: Plenty of pepople, probably. You're better of just asking
04:19:04 <dsyang> how do I parse a reserved name when using TokenParser?
04:19:36 <dsyang> that is, Text.Parsec.Token.TokenParser
04:20:42 <dsyang> I thought use the reserved function, but the docs say that reserved checks to make sure the string is _not_ a reserved name
04:22:03 <however> so, when cabal-install'ing a library with profiling turned on -- will the profiling library replace the regular one? or can cabal manage both?
04:22:11 <augur> ski: interestingly, if you start from the view that you have some variables up at the top, distinct from the hyps in your proof object, you can get the categorical-logic stuff relatively easy, i think
04:22:18 <however> (it's telling me "already installed, use --reinstall")
04:22:36 <augur> because you have at the top/left   G = x : A, y : B, ...
04:23:16 <augur> and you can just say  [[x]] = pi0 : A*B*... -> A,  [[y]] = pi1 : A*B*... -> B,  ...
04:23:46 <augur> where we understand that this is x in the context G
04:24:31 <augur> which is the basis of an algebraic theory!
04:24:35 <fmap> however: iirc cabal-install will build 2 libraries
04:24:59 <augur> iinm an algebraic theory is a category with that structure guaranteed, plus maybe some other structure on it
04:25:02 <fmap> with and without profiling
04:25:14 <augur> well, the algebraic version just has one type
04:25:25 <augur> oh man, its all falling together now
04:25:26 <augur> :)
04:26:15 <however> fmap: hm ...
04:26:43 * hackagebot graph-rewriting 0.7.3 - Monadic graph rewriting of hypergraphs with ports and multiedges (JanRochel)
04:32:52 <augur> oh man, ski: http://www.cs.cmu.edu/~fp/courses/15816-s10/lectures/
04:36:44 * hackagebot graph-rewriting-ww 0.3.1 - Interactive reduction of lambda-calculus with explicit sharing (JanRochel)
04:36:46 * hackagebot HUnit 1.2.5.0 - A unit testing framework for Haskell (RichardGiraud)
04:41:15 <Nereid> cool, I might have something
04:43:14 <Nereid> :r
04:43:15 <Nereid> oops
04:45:18 <Nereid> :r
04:45:20 <Nereid> ugh.
04:45:22 * Nereid closes this
05:00:10 <hpaste> Nereid pasted “kind-polymorphic functor class” at http://hpaste.org/71683
05:00:37 <Nereid> I'm stuck here.
05:02:54 <Nereid> I already have an instance declaration for (Category (k -> *) ((:->) k))
05:02:58 <Nereid> or so I think. why doesn't it see it?
05:03:40 <Nereid> I remove the GFunctor (:->) instance, and :i (:->) tells me:
05:03:44 <Nereid> newtype (:->) k a b = Arr1 {unArr1 :: forall (i :: k). a i -> b i}
05:03:44 <Nereid> instance Category (AnyK -> *) ((:->) AnyK)
05:03:54 <Nereid> what's AnyK?
05:06:04 <Nereid> http://hackage.haskell.org/trac/ghc/ticket/5935 -- this looks related. I wonder if that fixes this too
05:10:16 <Nereid> I guess everyone's gone to bed/lunch/whatever. I should go to bed.
05:49:38 <yitz> preflex: xseen Cale
05:49:38 <preflex>  Cale was last seen on freenode/#haskell 4 hours, 34 minutes and 12 seconds ago, saying: "Better known for other work."
05:52:11 <yitz> @tell Cale in case you didn't see it, you were mentioned in a cafe post without cc'ing you: http://www.haskell.org/pipermail/haskell-cafe/2012-July/102390.html
05:52:11 <lambdabot> Consider it noted.
05:54:41 <ksf_> PREMATURE OPTIMISATION
05:55:27 <ksf_> x11 requests and reply pack the first word8, if it exists, into the header, between opcode and length
05:56:21 <ksf_> "first one" being "if a word8 is the first one". there's actually requests and replies having word8 fields in them that don't have them as first field, so the byte in the header becomes padding.
05:56:34 <ksf_> I cannot fathom the mind that thought of that.
05:57:20 <ksf_> then, of course, the whole thing only applies to core replies and requests, not to extensions.
05:57:45 <ksf_> it's almost as if someone thought "well, we don't have enough exceptions from the rule, yet"
05:58:03 <nobdraisentone> yitz: is Cale == Cale Gibbard == <cgibbard@gmail.com> ?
05:58:08 <augur> yes
05:58:30 <ksf_> kale is tasty.
05:59:20 <ksf_> and especially good in helping you digest fat saussages and much kassler.
06:00:08 <aristid> ksf_: haha, nice anecdote
06:01:24 <ksf_> and then have a look at such replies as for ListExtensions. 24 bleeding bytes of padding.
06:17:57 <Digit> learn you a haskell, says intersperse works in ghci, but my ghci is saying nu-uh. not in scope. http://learnyouahaskell.com/modules#data-list
06:18:32 <ciaranm> Digit: did you import it?
06:18:32 <Axman6> you need to import Data.List
06:19:08 <Digit> ah, thnx.
06:19:40 <Digit> oh i see it goes on about that... must page-downed by accident
06:19:44 <Tomsik_> What extensions are enough to typecheck Y combinator?
06:19:51 <Tomsik_> Or any other fixed-point combinator
06:19:55 <edwardk> Tomsik_: there aren't any
06:20:09 <edwardk> Tomsik_: you'd need to kill the occurs check, then EVERYTHING typechecks
06:20:14 <edwardk> its bad ;)
06:20:14 <quicksilver> well, you can typecheck inside a suitable type
06:20:22 <quicksilver> like newtype L = L (L -> L)
06:20:27 <edwardk> anyways the y combinator does type check
06:20:30 <quicksilver> then it gets the type 'L' of course.
06:20:39 <quicksilver> (what else could it be....)
06:20:50 <edwardk> > (unsafeCoerce <*> unsafeCoerce) (unsafeCoerce <*> unsafeCoerce) -- well, thats SII (SII)
06:20:51 <lambdabot>   Not in scope: `unsafeCoerce'Not in scope: `unsafeCoerce'Not in scope: `unsa...
06:20:52 <Axman6> L -> L?
06:21:06 <quicksilver> it's a model of the untyped lambda calculus, Axman6
06:21:08 <Tomsik_> Well, I've seen this newtype, but perhaps some higher-rank magic together with something else?
06:21:08 <quicksilver> kind of.
06:21:25 <scooty-puff> is it possible to write a quasiquoter for something that is syntactically the same as haskell without using haskell-src-exts or haskell-src-meta?
06:21:29 <edwardk> Tomsik_: no, the point of higher rank magic is that it prevents you from doing this while still adding functionality
06:21:51 <edwardk> scooty-puff: yes but you're just reimplementing them at that point ;)
06:22:07 <Axman6> quicksilver: i meant could it not have that type? I'm quite sleeper so I'm probably wrong =)
06:22:19 <scooty-puff> bah, so a parser has to be written, rather than template-haskell providing one..
06:22:22 <scooty-puff> ok
06:22:29 <saml> dmwit, i ended up  using actual distance. (rectangle is (w,h) in RxR)
06:22:51 <quicksilver> Axman6: yes, it could. L->L is isomorphic to L of course.
06:22:59 <Axman6> right =)
06:23:03 <saml> i might modify with cos(theta)  since pi/4 should have lower distance
06:23:05 <Tomsik_> In what nontrivial typesystem, which might be not implemented anywhere, does a fixed-point combinator typechecks?
06:23:25 <Axman6> quicksilver: just better matches my mental type for the Y combinator
06:23:40 <edwardk> Tomsik_: you can build a type system with equirecursion, but many type system extensions aren't compatible
06:23:59 <edwardk> Tomsik_: read TAPL, they do equirecursion at some point
06:24:32 <filkr> Hello, I'm trying to do regular expression matching in Haskell. The tutorials teach me to to match my string of form "key=value", but how can I use () to extract just the value like I would in other languages? i.e. with regex "key=(.*)"
06:25:09 <saml> filkr, do you know key before hand?
06:25:11 <Botje> filkr: probably inspecting the match value you get back
06:25:13 <ciaranm> speaking of books, what's like Universal Algebra for Computer Scientists but not either out of print or illegal?
06:25:14 <saml> is key constant?
06:25:35 <filkr> saml: The key changes with each call to the function, but I remake the regex string
06:25:58 <saml> usually, you split at first =  and get both key and val
06:26:05 <saml> instead of using regex.
06:26:13 <Botje> filkr: for example, Text.Regex.matchRegex returns a Maybe [String], which will contain all the captures.
06:26:15 <filkr> saml: Oh, okay. I can do that easily enough. Thanks.
06:26:24 <Botje> filkr: or, indeed, you split on = and create a Map which you can then query
06:26:26 <filkr> Botje: Thanks as well.
06:26:29 <tsou> ciaranm: the sankappanavar book is sth you considered i suppose?
06:26:51 <saml> how do I split a String or Text?
06:27:39 <ciaranm> tsou: i said not out of print!
06:27:49 <tsou> ciaranm: if you print it it's not out of print..
06:28:01 <ciaranm> i'm fairly sure that's cheating
06:28:06 <Axman6> it's out of printer!
06:28:08 <tsou> ciaranm: no it's legal
06:28:30 <tsou> at least if i remember correctly the "license" msg that came along with the book
06:28:37 <simplx> saml, not sure about Text, but there's a nice package 'split' for strings iirc
06:29:14 <ciaranm> i can get out of print etc books easily enough. i just want to own one rather than having to screw around with ILLs
06:29:59 <saml> > let kv s = (takeWhile (/='=') s, tail $ dropWhile (/='=') s) in kv "foo=bar"
06:30:00 <lambdabot>   ("foo","bar")
06:30:05 <saml> is there a better way for that?
06:30:18 <saml> it's iterating s twice
06:30:37 <saml> oh there's span
06:31:10 <tsou> ciaranm: if i understand what you mean, you just want to spend money in something that is being printed by a publisher, instead of printing it on your own, legally, for free
06:31:20 <tsou> ciaranm: not aware of an alternative to that book i'm afraid..
06:31:26 <saml> > let kv s = let (k,v) = span (/='=') s in (k, tail v) in kv "foo=bar"
06:31:27 <ciaranm> tsou: i want something in a nice convenient dead tree form, not stapled together!
06:31:27 <lambdabot>   ("foo","bar")
06:32:24 <tsou> ciaranm: where i live you pay 6-8 euro for a kickass book-binding, superior than most bindings i've seen by big publishers..
06:32:36 <tsou> anyway..
06:32:44 <ciaranm> yes, but i'd have to go outside and walk to get that done
06:32:46 <ciaranm> and it's raining
06:33:30 <tsou> yes you won't have it right now, but unless you expected an answer of the form "yes, it's that book lying on your desk that you hadn't noticed so far"
06:33:38 <tsou> ..you wouldn't be having it right now either ;)
06:34:06 <ciaranm> i can get to the library without being rained upon!
06:34:20 <ciaranm> more or less...
06:34:25 <tsou> ok ok :)
06:34:39 <ciaranm> i can also get amazoned without being rained upon
06:35:13 <Botje> just opt-in for the less wet type of rain
06:35:20 <tsou> you said "now", you can't get "amazoned" "now"
06:35:33 <ciaranm> it'll be raining for at least the next week
06:35:34 <tsou> let's move past this? :P
06:38:04 <finnaly> Can you pass more then two functions to map function
06:38:05 <finnaly> map (*2) (filter (>5) [10,2,16,9,4])
06:38:17 <finnaly> like map (*3 )(*2) (filter (>5) [10,2,16,9,4])
06:38:17 <Botje> finnaly: how would they interact?
06:38:25 <finnaly> i dunno
06:38:32 <Botje> finnaly: you can use the (.) operator to compose functions
06:38:42 <Botje> > map ((*3) . (*2)) [1..5]
06:38:44 <finnaly> its the last lesson in try haskell
06:38:45 <lambdabot>   [6,12,18,24,30]
06:39:03 <Botje> finnaly: or you can write it out by hand: \x -> x * 3 * 2
06:39:19 <ciaranm> > (*3) . (*2) . [1, 2, 3, 4, 5]
06:39:21 <lambdabot>   [6,12,18,24,30]
06:39:37 <Botje> you and your clever fmap tricks :]
06:39:44 <finnaly> whats the (.) operator
06:39:55 <Botje> it composes functions
06:39:57 <ciaranm> composition, unless you lambdabot, in which case it's fmap instead
06:39:57 <Botje> @src (.)
06:39:58 <lambdabot> (f . g) x = f (g x)
06:39:58 <lambdabot> NB: In lambdabot,  (.) = fmap
06:40:15 <finnaly> ah ok.Thanks.)
06:40:17 <finnaly> :)
06:40:29 <mroman> so
06:40:47 <mroman> Functions are functors
06:41:07 <ciaranm> a-> is a functor
06:41:35 <mroman> > (+2) `fmap` (+3) $ 5
06:41:37 <lambdabot>   10
06:41:50 <ciaranm> as is ->a for that matter, although that doesn't seem to be so popular around here
06:42:10 <mroman> that needs more instances
06:42:28 <mroman> @hoogle instance Functor (a ->)
06:42:29 <lambdabot> Parse error:
06:42:29 <lambdabot>   instance Functor (a ->)
06:42:29 <lambdabot>                         ^
06:42:34 <mroman> @hoogle instance Functor
06:42:35 <lambdabot> No results found
06:42:48 <mroman> @info (a->)
06:42:49 <lambdabot>  Parse error at "->)" (column 3)
06:43:16 <geekosaur> there's also no @info
06:43:52 <ciaranm> it's not called (a->). it's called ((->) a)
06:43:55 <nand`> there's no @info command
06:43:57 <nand`> and the correct notation for that is ((->) a), but in GHCi you want: :i (->) for the instance
06:44:44 <sykora> @instances Functor
06:44:44 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
06:44:49 <mroman> @hoogle ((->)a)
06:44:49 <lambdabot> Prelude undefined :: a
06:44:50 <lambdabot> Data.Function fix :: (a -> a) -> a
06:44:50 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
06:45:02 <mroman> sykora: Yeah, but in which cabal package is that instance
06:45:19 <sykora> mroman: which one?
06:45:59 <Botje> mroman: Control.Monad.Instances contains the ((->) a monad instance
06:45:59 <mroman> (->a) and (a->)
06:46:13 <mroman> Functor (->a) and Functor (a->)
06:46:14 <Botje> and that's part of base, so no cabal package needed
06:46:32 <Botje> yep, also in C.M.I
06:48:34 <applicative> hm, in ghc-7.5 the instance for (->) r is exported by the Prelude
06:50:05 <bitrust> I'm at it again, any tips for something like: [Bool] -> Word8 (or even [Word8] or other Word)
06:50:30 <bitrust> Big endian.
06:50:34 <applicative> mroman, isnt the other a 'contrafunctor' rather than a Functor?
06:50:47 <ciaranm> they're both functors
06:51:15 <mroman> bitrust: You could use Data.Bits
06:51:17 <applicative> i'm in a muddle grrr. wait
06:51:35 <ciaranm> "composition" goes backwards on one of them
06:51:51 <ciaranm> one of them is the representable and one of them is the corepresentable
06:51:57 <bitrust> mroman: Looking into it...
06:52:05 <mroman> You can go through every element of the list
06:52:14 <mroman> and keep the index somewhere
06:52:19 <mroman> then use bit to set that bit
06:52:22 <mroman> and or those all together
06:53:02 <bitrust> mroman: And left shift every time, that *could* do.
06:53:41 <bitrust> mroman: Although [Bool] -> [Word8] would be more practical, that could be a higher level map...
06:53:56 <Cale> yitz: I told some guy that I'm not the maintainer of Lambdabot and that for all I care he can upload another version of the package :)
06:53:56 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
06:54:54 <Botje> bitrust: Data.List.Split.chunk
06:56:33 <hpaste> applicative pasted “functor” at http://hpaste.org/71692
06:56:53 * hackagebot network-metrics 0.1.6 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
06:56:57 <applicative> ciaranm: you mean like this ^^^
06:57:20 <ciaranm> applicative: yes
06:57:30 <mroman> bitrust: let bitm xs = foldl1 (.|.) $ map (\(b,a) -> if b then bit a else 0) (zip xs [0..])
06:57:34 <mroman> out of the box
06:57:46 <ciaranm> applicative: the first one is the corepresentable, and the second one is the representable. or possibly the other way around.
06:58:26 <bitrust> @t bitm xs = foldl1 (.|.) $ map (\(b,a) -> if b then bit a else 0) (zip xs [0..])
06:58:26 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:58:34 <mroman> bitm (reverse [True,False,False,False,False,False,False,False]) :: Int
06:58:35 <mroman> 128
06:58:47 <bitrust> How do you do type on lamdabot?
06:58:53 <mroman> bitm (reverse [True,False,False,False,False,False,True,False]) :: Int
06:58:53 <mroman> 130
06:58:59 <geekosaur> @type or :t
06:59:00 <lambdabot>     Couldn't match expected type `[[Bool] -> Bool]'
06:59:01 <lambdabot>            against inferred type `Expr'
06:59:01 <lambdabot>     In the second argument of `(:)', namely `t'
06:59:07 <bitrust> @type bitm xs = foldl1 (.|.) $ map (\(b,a) -> if b then bit a else 0) (zip xs [0..])
06:59:08 <geekosaur> hush you :p
06:59:08 <lambdabot> parse error on input `='
06:59:24 <HairyDude> :t pack
06:59:25 <lambdabot> forall o n. (Newtype n o) => o -> n
06:59:31 <Cale> @type let bitm xs = foldl1 (.|.) $ map (\(b,a) -> if b then bit a else 0) (zip xs [0..]) in bitm
06:59:31 <bitrust> @type let bitm xs = foldl1 (.|.) $ map (\(b,a) -> if b then bit a else 0) (zip xs [0..])
06:59:31 <lambdabot> forall a. (Bits a) => [Bool] -> a
06:59:32 <lambdabot> <no location info>:
06:59:32 <lambdabot>     not an expression: `let bitm xs = foldl1 (.|.) $ map (\(b,a) -> if b then bit a else 0) (zip xs [0..])'
06:59:32 <HairyDude> huh
06:59:35 <geekosaur> expression, not binding
06:59:41 <hpaste> applicative annotated “functor” with “functor (annotation)” at http://hpaste.org/71692#a71693
06:59:41 <HairyDude> :t Data.ByteString.pack
06:59:42 <lambdabot> [Word8] -> BSC.ByteString
06:59:50 <HairyDude> @hoogle String -> ByteString
06:59:50 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
06:59:51 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
06:59:51 <lambdabot> Data.String fromString :: IsString a => String -> a
06:59:52 <Cale> Declarations don't have types
06:59:54 <Cale> only expressions do
07:00:00 <applicative> ciaranm: but this is the one that typechecks ^^^
07:00:07 <mroman> @hoogle (Num a) => [Bool] -> a
07:00:07 <lambdabot> Data.List genericLength :: Num i => [b] -> i
07:00:08 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
07:00:08 <lambdabot> Prelude product :: Num a => [a] -> a
07:00:23 <mroman> hm well.
07:00:38 <mroman> My method works at least for (Bits a) => [Bool] -> a
07:00:43 <ciaranm> applicative: find your favourite proof of the yoneda lemma and steal!
07:00:47 <mroman> probably not the most elegant way thogh.
07:00:50 <mroman> *though
07:00:58 <ciaranm> applicative: i always end up having to draw the pictures if i want to work out what the answer is...
07:01:26 <mroman> Also I wan't a class Boolean
07:01:43 <mroman> class Boolean a where high :: a -> Bool; low :: a -> Bool
07:02:48 <mroman> bitrust: You can chain setBit calls too
07:02:51 <bitrust> mroman: Ok that works nicely, except its little endian.
07:02:52 <mroman> that's probably more elegant.
07:03:01 <mroman> bitrust: reverse the list
07:03:11 <mroman> depending on what endian you want.
07:03:11 <bitrust> duh!
07:03:21 <nand`> @type foldr (.|.) 0 $ zipWith (flip shiftL . fromIntegral) [0..]
07:03:22 <lambdabot>     Couldn't match expected type `[a]'
07:03:22 <lambdabot>            against inferred type `[b] -> [b]'
07:03:22 <lambdabot>     In the second argument of `($)', namely
07:03:30 <nand`> @type foldr (.|.) 0 . zipWith (flip shiftL . fromIntegral) [0..]
07:03:31 <lambdabot> forall b. (Bits b) => [b] -> b
07:03:40 <nand`> oh
07:03:56 <nand`> @type \xs -> foldr (.|.) 0 . zipWith (shiftL . fromIntegral) xs [0..]
07:03:57 <lambdabot> forall a a1. (Bits a, Bits [a], Integral a1) => [a1] -> [a]
07:04:00 <bitrust> mroman: Well, cheers!
07:04:03 <nand`> not quite D:
07:04:17 <nand`> @type \xs -> foldr (.|.) 0 $ zipWith (shiftL . fromIntegral) xs [0..]
07:04:18 <lambdabot> forall a a1. (Bits a, Integral a1) => [a1] -> a
07:04:21 <nand`> hooray
07:04:45 <nand`> s/fromIntegral/fromEnum/
07:05:05 <nand`> or fromIntegral . fromEnum
07:06:05 <optimight> I am writing a .hs (haskell) file through emacs and loading it with 'load file' (C-c C-l).
07:06:05 <optimight> For testing the functions, I switchover to Main Prompt Window (C-x o), where I need to type complete function name. I am sure there must be a way to get the function names through auto-completion, but I don't know how to do it?
07:06:35 <bitrust> Botje: Can't find that Chunk you mentioned
07:06:59 <HairyDude> sigh. Data.ByteString.UTF8 doesn't implement the whole ByteString API
07:07:04 <HairyDude> e.g. there's no concat
07:07:32 <aristid> HairyDude: it's the same ByteString type
07:07:39 <aristid> HairyDude: just import Data.ByteString
07:07:45 <HairyDude> ah
07:08:05 <aristid> there are just two ByteString types
07:08:07 * ksf_ needs help with conduit
07:08:08 <aristid> strict and lazy
07:08:10 <ksf_> http://hpaste.org/71694
07:08:22 <ksf_> sourceList is working, sourceIO not.
07:08:28 <HairyDude> aristid: I guess it overrides the functions that need overriding to work properly with utf8?
07:08:42 <ksf_> and yes, the item is read off the chan and fed into IOOpen.
07:12:28 <ksf_> hmm how do I flush the stream? there's a data constructor, but it doesn't fit anywhere
07:13:09 <aristid> ksf_: the code isn't clear
07:13:46 <mroman> bitrust: http://codepad.org/5lAZQbXD
07:13:53 <mroman> ^- That's probably more elegant.
07:14:18 <ksf_> aristid, well, it's the product of hasty refactoring.
07:14:23 <mroman> if you wan't [Bool] -> [Word8] you just need to split the list into 8-length chunks
07:14:30 <triyo> Has anyone done the "Purely Functional Data Structures" book exercises in Haskell?
07:14:38 <mroman> if I interpret [Bool] -> [Word8] correctly.
07:16:51 <ksf_> ooooh. flush is provided by blaze-builder-conduit.
07:17:14 <triyo> I've just kicked off yesterday and find it a bit tricky here and there regarding mapping the ML terminology onto Haskell.
07:18:08 <ksf_> ...but conduit-network doesn't understand it.
07:23:43 <triyo> To make the matters worse functors in ML don't even closely resemble real functors... Wondering if I shouldn't just learn ML a bit more and do the PFDS exercises in ML instead.
07:24:28 <mroman> the Num a is unecessary though.
07:25:40 <ksf_> there. I need to flush the Builder.
07:25:51 <mroman> @hoogle Endian
07:25:51 <lambdabot> package data-endian
07:25:52 <lambdabot> package storable-endian
07:26:42 <ksf_> System.Byteorder?
07:27:40 <astory> Is there a better way to remove duplicate elements from a list than Data.Set.fromList . Data.Set.toList ?
07:27:56 <EvanR> > nub [1,2,3,3,5,1,2,1]
07:27:58 <lambdabot>   [1,2,3,5]
07:28:27 <geekosaur> map head . group . sort ?  (works better if you have larger lists and the type is Ord)
07:28:32 <twanvl> nub is slower than going via Data.Set
07:28:50 <EvanR> alright im back, trying to get my haskell shit in a working state on osx again
07:29:03 <tromp> > nubBy(((>1).).gcd)[2..]
07:29:05 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:29:44 <tazjin> EvanR: What happened to it?
07:29:54 <astory> huh, I wonder why nub didn't come up when I searched hoogle for [a] -> [a]
07:29:55 <EvanR> well i just upgraded ghc with brew
07:30:05 <filkr> Can anyone help me makes some sense of "No instance for (IArray a0 Int) arising from a use of `accumArray'"
07:30:24 <tromp> your index needs to be in cxlass Ix
07:30:29 <astory> but yeah, that's O(n^2) and using a set is O(n log n)
07:30:35 <astory> because it requires ord
07:30:40 <tazjin> EvanR: Why do you use brew to install GHC? I feel like it'd throw many things in the wrong places and cause a mess
07:31:10 <fmap> astory: note that `Data.Set.toList . Data.Set.fromList' would change the order of elements
07:31:15 <astory> ok, then, is there a reason to use Set.elems vs Set.toList ?
07:31:21 <EvanR> tazjin: whats the real way then?
07:31:33 <astory> fmap: that doesn't matter to me, I want to treat this as a set but the other functions I'm using are list functions
07:31:36 <EvanR> i wouldnt know what the right place is
07:31:52 <tazjin> EvanR: The Haskell platform is probably the best way, it comes with a default .pkg installer
07:32:19 <EvanR> i think i installed that......
07:32:20 <EvanR> blah
07:32:27 <EvanR> can i start over?
07:33:05 <fmap> astory: ok
07:33:15 <fmap> astory: Set.elems ≡ Set.toList
07:33:30 <tazjin> EvanR: Depends on how much you've already done, I'll query you
07:33:37 <astory> fmap: ok, that wasn't clear from the docs
07:33:41 <astory> thanks :D
07:34:02 <fmap> astory: yeah, you can check the sources though
07:34:13 <astory> oh, of course!  I should have thought of that
07:36:51 <mroman> @hoogle Word8
07:36:51 <lambdabot> Data.Word data Word8
07:36:52 <lambdabot> GHC.IO.Buffer readWord8Buf :: RawBuffer Word8 -> Int -> IO Word8
07:36:52 <lambdabot> GHC.IO.Buffer writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
07:38:38 <filkr> Would anyone be willing to look at a 4 line pastebin post and see if there's anything obviously wrong? I'm getting a weird "No instance for (IArray a1 Int)" bug that I can't really understand. http://pastebin.com/KgZX9Rk9
07:38:44 <mauke> The paste KgZX9Rk9 has been copied to http://hpaste.org/71696
07:39:16 <byorgey> filkr: without looking at the code, I can tell you that error means type inference can't figure out what sort of array you want to use
07:39:18 <mroman> http://codepad.org/fC6e1Fcv
07:39:27 <mroman> ^- That would be a useful extension for Data.Bits
07:39:51 <filkr> byorgey :: Can I tell it with a :: type annotation at the end, or is that a hack?
07:39:57 <byorgey> filkr: it can be solved either by giving an explicit type annotation, or just going ahead and using the result of the accumArray in some context which fixes its type
07:39:58 <mroman> or maybe some other Package.
07:40:05 <byorgey> filkr: sure, go ahead, that's not a hack
07:40:12 <mroman> somebody should make a package for that.
07:40:13 <byorgey> filkr: in fact that's quite common with arrays, for exactly this reason
07:40:30 <filkr> byorgey: Thank you
07:41:03 <filkr> byorgey: That stomped my bug
07:43:35 <n-dolio> byorgey: I'm not sure how you figured that out without looking at the code, because it wouldn't be my first guess for that error. :)
07:44:22 <byorgey> I've seen it enough times.
07:45:41 <byorgey> and more generally, I've found that errors of the sort "No instance for ... something involving a type variable with a numeric suffix ..." usually indicate that type inference doesn't have enough information to work out what's happening with some function with a type-class-polymorphic return type
07:45:46 <simplx> Static linking sure takes a lot of space.
07:48:01 <EvanR> tazjin: thanks that should do it, in 58 minutes ;)
07:48:09 <n-dolio> Yeah, I would expect something with the word "ambiguous" in it. And the above error message to be when someone annotates a polymorphic return type without the associated constraint.
07:48:22 <n-dolio> But I don't use the built-in array libraries much anymore.
07:48:51 <n-dolio> And I always put signatures at the top level, so I probably don't see that much.
07:50:02 <byorgey> right, I always put sgnatures at the top level too, except for with diagrams, which is the other place I see that sort of error.
07:50:10 <n-dolio> Heh.
07:52:55 <mroman> bitrust: https://github.com/FMNSSun/hs-experiments/blob/master/bits.hs <- there you go
07:53:10 <mroman> If you find a better/more ways I'd be happy to hear about them :)
07:56:13 <Saizan> n-dolio, byorgey: http://hackage.haskell.org/trac/ghc/ticket/4921 has been given low priority
07:56:38 <ksf_> TIL -XRecordWildCards
07:56:44 <ksf_> why didn't anybody tell me before?
07:56:57 <byorgey> Saizan: ah, interesting
07:57:20 <byorgey> ksf_: I tried to tell you four times, but you wouldn't listen
07:57:45 <applicative> n-dolio i was defending honor of vector-algorithms introsort the other day
07:58:11 <n-dolio> What about it?
07:58:23 <applicative> somewhat spoiling it at the end with characteristic lapse
07:58:38 <applicative> someone was saying it could never be faster than stuarrays
07:58:44 <applicative> that vector couldn't
07:59:20 <n-dolio> Pretty sure that's not true.
07:59:45 <n-dolio> I forget what it is exactly about STUArrays, but GHC fails to specialize them all the way.
07:59:48 <n-dolio> Or it did at some point.
08:00:05 <applicative> it seemed counterintuitive, but I don't have much experience with struarrays, which is why I was following it .
08:00:47 <applicative> it's not worth reading, but its stackoverflow.com/questions/11481675 the d. fischer response
08:01:46 <applicative> whoops wrong number
08:03:37 <applicative> no that's right, I'm deprived of cut and paste in this icfp debian thing...
08:04:26 <merijn> How hard is it to call back to the haskell RTS from C? i.e. I call a C function using the FFI and it in turn needs to call a haskell function?
08:05:30 <n-dolio> applicative: I haven't done anything with vector-algorithms in a bit, so it's entirely possible that a GHC version or two has broken something optimization wise.
08:05:36 <n-dolio> It's quite fragile.
08:05:51 <quicksilver> merijn: not particularly hard.
08:05:56 <Drakeson> Is there a sane way to get syntactic sugar for filesystem paths? E.g., #/usr/share ++ #/man ==> #/usr/share/man
08:06:39 <byorgey> Drakeson: not sure what you mean by syntactic sugar, but see http://hackage.haskell.org/package/filepath
08:07:13 <merijn> quicksilver: ok, I can just figure it out from whatever FFI tutorial or is there something specific I need to know?
08:07:17 <byorgey> "/usr/share" </> "man" ==> "/usr/share/man"
08:07:25 <applicative> n-dolio I don't know. It turned out pretty well.  He was able to get stuarrays to be more or less equivalent, but the whole discussion was about unboxed ints so specialization problems might not have arisen.
08:07:27 <byorgey> and it Does The Right Thing on Windows too
08:07:56 <quicksilver> merijn: takea  look at http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
08:08:19 <n-dolio> Maybe GHC got better at optimizing STArrays, too.
08:08:19 <Drakeson> byorgey: Yes, almost that, just without string quotes.
08:08:34 <n-dolio> It doesn't really matter to me, because vector is a better API.
08:08:43 <applicative> n-dolio: the pleasing part was he crossed out the sentence ''I've never observed vectors to be faster than starrays' (he is evidently superknowledgeble)
08:09:09 <applicative> n-dolio: yes, everything about vector is wonderful to use
08:10:16 <mroman> so... naive quicksort is fast
08:10:43 <Drakeson> byorgey: Essentially, I want to treat paths as their own type, not exactly strings. (And tighter checkings could ensue)
08:10:43 <merijn> quicksilver: ok, thanks :)
08:10:45 <mroman> or mutable stuff in haskell is slower than expected.
08:11:51 <donri> when are lists better suited than vectors?
08:11:56 <Cale> mroman: It's not *that* fast, but it's reasonable.
08:12:06 <Cale> donri: When you intend to iterate through the data in order
08:12:27 <donri> aha, and vectors are better when you need random access?
08:12:28 <tromp> lists are better if you dont have random access
08:12:29 <Drakeson> Is it possible at all to define "reader macros" or somesuch in Haskell?
08:12:35 <mroman> according to the data shown on stackoverflow it's faster than the rest.
08:12:43 <Cale> Drakeson: you can write preprocessors
08:12:59 <yitz> applicative, n-dolio: daniel usually makes his observations about speed based on actual profiling. but you did say he ended up crossing that out, so i don't know.
08:13:03 <mroman> up until 3*10^6 with random data
08:13:19 <Cale> Drakeson: there's also TH's quasiquoting
08:13:41 <applicative> yitz, oh yes, thats why I was studying it.  He's good.
08:14:10 <Cale> mroman: The rest of what? Naive quicksort ought to be worse than Data.List.sort, which is a mergesort.
08:14:15 <applicative> yitz, I had been talking to the guy who posted on here first trying to explain how to use vector
08:15:27 <applicative> yitz the profiling got off to a bad start because it started with an example from another response that was on reflection misguided
08:16:42 <mroman> Cale: http://stackoverflow.com/questions/11481675/using-vectors-for-performance-improvement-in-haskell
08:17:12 <mroman> one answer includes measurements.
08:18:42 <applicative> mroman: a lot of the impressive looking results in there are due to peculiarities of the test that slowly emerged, I think.
08:19:19 <applicative> note that d fisher stops discussing Data.List.sort and the 'naive quicksort' pretty quickly
08:19:29 <Cale> mroman: interesting
08:19:35 <applicative> it took too long to wait for them to finish
08:20:53 <n-dolio> > sort [1..10000000]
08:20:58 <lambdabot>   mueval-core: Time limit exceeded
08:22:03 <applicative> mroman: if you look at the last bunch of times in daniel f's response you'll see they leave the list sorts in the dust utterly. nb this is all about Ints
08:22:36 <Cale> Yeah, I found it a little odd that his sorts are not polymorphic
08:23:49 <applicative> Cale, yes, the first response  specialized everything to Int
08:24:56 <hpaste> Aune pasted “Conduit-Bot” at http://hpaste.org/71698
08:25:07 <tsousa> what would be a nice project for a relative new user do?
08:25:48 <applicative> tsousa it probably depends what kind of thing you are interested in
08:26:32 <Aune> Im kind of stuck with my above paste, I want to get a Conduit based IRC-bot working, but I am unsure where to go from there. How do I use sinkFile?
08:27:13 <Drakeson> Cale: Quasiquoting looks interesting. Thanks :)
08:28:27 <tsousa> applicative, now just learning
08:29:34 * applicative is happy to notice that so called programmers also have segfaulting ghci's on os x
08:29:49 <applicative> so called *real* programmers rather
08:30:07 <ion> Is SugarHaskell installable or just a paper at the moment?
08:31:14 <ksf_> should I make my monad a transformer or not?
08:31:42 <ion> Is Megan Fox involved?
08:31:47 <ksf_> no
08:32:04 <ilya> ion, :)
08:32:34 <ksf_> as transformer users can use it as, well, transformer, but it's also introducing MonadIO m => constraints all over the place.
08:33:41 <EvanR> applicative: how do you trigger that?
08:35:26 <applicative> EvanR it seems to be a bug with the 64 bit version
08:35:32 <EvanR> ok
08:35:37 <ion> A complex programmer consists of a real programmer and an imaginary one.
08:35:37 <EvanR> 32 all the way baby
08:36:13 <donri> am i reading the stackoverflow linked above correctly, that naive qsort is faster than Data.List.sort?
08:36:14 <applicative> EvanR: It seems so, but homebrew is sort 64 bit oriented, so I dont know
08:36:28 <EvanR> really?
08:36:35 <HairyDude> is this ok? ghc claims it fails the coverage condition: instance MonadReader r m => MonadReader r (ResourceT m) where ...
08:36:43 <EvanR> well i was just told to stop using homebrew for haskell stuff
08:37:14 <HairyDude> seems to me that assuming the coverage condition holds for m's instance, it also holds for this one
08:37:22 <donri> or could it be that the benchmarks didn't actually compile the base package with -O2?
08:37:24 <HairyDude> (even if that's not obvious from the syntax)
08:40:30 <n-dolio> HairyDude: That's why mtl has UndecidableInstances turned on, I believe.
08:40:36 <HairyDude> ah.
08:46:05 <applicative> donri you can try the sorts yourself eg github.com/michaelt/stu-vs-vector-sort
08:48:56 <applicative> I wonder if this jnowak character on reddit.com/r/haskell is right that the old 'first class modules for haskell' paper was a mere hopeless hack etc.
08:49:24 <applicative> maybe just an ML snob
08:51:21 <applicative> we cant really have modules in haskell, since we don't have dependent types;  'which is how ML modules are typically modeled', suggesting they dont exist in ML either
08:52:00 <HairyDude> @hoogle Data.ByteString.Lazy.ByteString -> Data.ByteString.ByteString
08:52:01 <lambdabot> Parse error:
08:52:01 <lambdabot>   Data.ByteString.Lazy.ByteString -> Data.ByteString.ByteString
08:52:01 <lambdabot>       ^
08:52:06 <HairyDude> sigh.
08:52:10 <n-dolio> You don't need dependent types.
08:52:29 <n-dolio> But, just throwing existentials in the language and expecting everything to work out isn't great, either.
08:53:07 <applicative> yes, I was wondering if that was a good point.  I would like to try these records before speaking though...
08:53:19 <zachk> morning
08:53:29 <applicative> morning zachk
08:53:44 <n-dolio> You definitely don't need dependent types, though.
08:54:38 <HairyDude> so how do you turn a lazy bytestring into a strict one? (assuming it fits in memory)
08:54:39 * zachk does forget the lay definition of dependent types 
08:54:40 <applicative> yes, the sentence seems to confuse what you might use in 'modeling' something, with what must exist in the language modeled, that was the paradox I was first baffled by
08:54:57 <n-dolio> HairyDude: concat . toChunks, I think.
08:55:03 <zachk> HairyDude: try using the strict version of the bytstring modules, and the strict version of stateT if you are using that
08:56:10 <applicative> zachk: you can have Foo True and Foo False as types and Bar 1 , Bar 2 ... so Foo has kind :: Bool -> * or Bool -> Set or whatever, and Bar:: Number -> * or whatever
08:56:10 <HairyDude> zachk: a lazy bytestring is returned from a library function
08:56:42 <quicksilver> HairyDude: concat . toChunks
08:56:44 <applicative> HairyDude: ByteString.Lazy has toStrict
08:56:52 <quicksilver> (is how you turn a lazy into a strict)
08:56:57 <quicksilver> oh, maybe there is a neater way now
08:56:58 <HairyDude> applicative: ahh, that's what I wanted, thanks :)
08:56:59 <applicative> and fromStrict
08:57:23 <applicative> yeah, I think it's new, n-dolio is right about the way you used to. I just noticed it yesterday
08:57:55 <HairyDude> toStrictByteString
08:57:59 <HairyDude> :t toStrictByteString
08:58:02 <lambdabot> Not in scope: `toStrictByteString'
08:58:07 <applicative> so it maybe be ultranew bytestring-0.10 is what I was using
08:58:46 <HairyDude> it's in the bytestring-class package apparently
08:59:30 <applicative> oh yeah, it seems not to be in the ByteString on hackage
08:59:45 <applicative> it came with ghc-head which doesn't segfault on osx
08:59:52 <HairyDude> huh
09:00:06 <applicative> sorry, that was confusing.
09:00:40 <HairyDude> well it looks like bytestring-class failed to build on recent ghc, so concat . toChunks it is
09:00:50 <applicative> I think the answer is, do what n-dolio said; the new bytestring will follow Data.Text.Lazy with a fromStrict and toStrict
09:02:42 * applicative verifies that fromStrict and toStrict are in bytestring-0.10 but not bytestring-9.*
09:03:59 <HairyDude> when is this new bytestring coming out?
09:04:33 <HairyDude> I mean, on hackage
09:07:20 <ksf_> oh noes. the code I want to write wants data, not type families but haddock still doesn't grok them.
09:07:46 <applicative> HairyDude: I don't know, I came upon it without thinking I was using such a shiny bytestring .  The definition is different from B.concat . BL.toChunks
09:07:58 <HairyDude> interesting
09:08:48 <hpaste> “dons et al” pasted “Data.ByteString.Lazy” at http://hpaste.org/71701
09:09:09 <applicative> here's the new lazy bytestring ^^^
09:09:38 <applicative> bytestring innards are so hideous, I wish this vector-bytestring scheme worked....
09:10:14 * applicative wants to scrap ByteString and Text and just use Data.Vector.Unboxed.Vector  Word8 and Char
09:10:16 <eikke> doesn't it?
09:10:43 <ksf_> char should be rather awkward to unbox.
09:10:47 <applicative> eikke: I thought there were suppose to be some objections
09:11:06 <quicksilver> applicative: a vector of Chars would be twice the size of text for most unicode text
09:11:28 <eikke> funnily in my xor'ing benchmarks, Storable vectors of Word8 perform better than the Unboxed variant
09:11:33 <applicative> instance Unbox Char holds
09:11:41 <quicksilver> bos (I think) did quite a lot of discussion, testing, and profiling before choosing that representation
09:11:57 <applicative> quicksilver: I know
09:12:00 * hackagebot plist 0.0.3 - Generate and parse Mac OX property list format (YurasShumovich)
09:13:36 <eikke> hmh, the hlint output of that bytestring paste linked before mentions "Redundant $!"
09:13:43 <eikke> wouldnt removing those change semantics?
09:14:50 <applicative> eikke: yeah thats suprising, why is it so opinionated
09:16:03 <applicative> quicksilver: try e.g. V.unfoldr B.uncons <$> B.readFile x and you'll see that the lucidity gain is overwhelming
09:16:25 <quicksilver> eikke: well, in line 407, for example, you have return $! applied to a (,) constructor
09:16:37 <quicksilver> eikke: that is, indeed, redundant.
09:16:48 <eikke> oh
09:16:59 <quicksilver> in fact both of the cases it complains about are of that form
09:17:04 <quicksilver> I would say hlint is right this time
09:17:08 <applicative> hlint is right
09:17:23 <quicksilver> applicative: I don't understand. lucidity gain?
09:17:27 <applicative> excellent point hlint, quicksilver
09:17:29 <nand`> switching from [Char] to Text has reduced memory usage of libmpd/vimus quite considerably; I imagine something similar applies to Vector Char
09:18:03 <quicksilver> nand`: an unboxed vector of chars would be much better than [Char], certainly, but approx 2x the size of Text for BMP unicode
09:18:38 <applicative> quicksilver: maybe it's just that I'm more familiar with vector, it's just a million times clearer than bytestring land.  In exactly the way String is clearer
09:18:40 <quicksilver> that's not what I meant.
09:19:04 <quicksilver> applicative: OK. Yes. That's just that how we understand and design vector (in the generic sense) APIs has improved.
09:19:13 <quicksilver> bytestring shows its age
09:19:41 <applicative> quicksilver: maybe that's part of it.  I just find the whole thing unpleasant, however much necessary, etc
09:20:34 <quicksilver> I was right, i did mean BMP. I just find unicode terminology confusing :)
09:22:00 * hackagebot cabal2nix 1.38 - Convert Cabal files into Nix build instructions (PeterSimons)
09:23:36 <applicative> also vector and text are ideal haskell in some sense because the optimization rests on such pleasing ideas, rather than thinking like a machine, so to speak
09:25:05 <jfischoff> Anyone every parsed javascript with Haskell? Any recommendation on libraries? Also how easily would it be read a bunch of code and output a new version adding a function prologue and epilogue (for profiling)
09:26:09 <Clint> i haven't used it directly, but language-javascript
09:31:10 <applicative> the new js-good-parts library acts on the other end, jfischoff, I wonder if it could be of use in your scheme
09:31:31 <EvanR> should i put the typeclass constraints on the all the operations on the data type or on the data type definition
09:31:40 <applicative> the former.
09:31:53 <applicative> or are you using a GADT?
09:31:55 <EvanR> thats a lot of typing
09:32:00 <EvanR> i dont think its gadt
09:32:02 <marcot> Hi.  Is there a function or package to convert special characters to simple ones, like f 'á' = 'a' and so on?
09:32:27 <applicative> EvanR: I think you will a warning nowadays if you put a constraint on the data type.
09:33:11 * applicative remembers marcot 's question coming up before; he has a dim memory of disappointment, not sure....
09:34:15 <quicksilver> iconv to ascii, perhaps/
09:34:16 <quicksilver> ?
09:34:19 <quicksilver> no idea, really
09:34:24 <applicative> marcot: I  wonder if you can do it indirectly via text-icu
09:34:54 <marcot> quicksilver: iconv from shell doesn't work like that, unfortunatelly.
09:35:43 <geekosaur> ascii//translit with gnu iconv, I think
09:35:56 <applicative> marcot: but see the iconv haskell bindings, maybe libiconv has some such facility
09:36:06 <applicative> oh geekosaur has a view
09:36:57 <marcot> geekosaur: Thanks, translit works fine!
09:37:47 <marcot> It seems to be convertFuzzy on iconv package.
09:38:22 <applicative> ah convertFuzzy rings a bell
09:40:55 <applicative> all the stackoverflow questions about this are from php users, marcot.  maybe this isnt a good sign
09:42:46 <marcot> Sorry, connection problems here.  It works!  I just have to convert from String to ByteString now.
09:45:59 <applicative> /usr/bin/iconv --f UTF-8 -t ASCII//TRANSLIT sort of works marcot
09:46:13 <marcot> applicative: yes, this one does.
09:46:23 <EvanR> having a hard time compiling something that uses ixset...
09:46:34 <marcot> applicative: But I could not make it to work with iconv convertFuzzy yet.
09:46:55 <marcot> Prelude Codec.Text.IConv Data.ByteString.Lazy.Char8> convertFuzzy Transliterate "UTF-8" "ASCII" (pack "não")
09:46:55 <marcot> Chunk "no" Empty
09:47:02 <EvanR> my record is Entry a b
09:47:11 <applicative> you can convert a haskell string to a bytestring with the encode functions in Data.Text.Encoding, for example
09:47:27 <applicative> maybe that's the poor mans and womans route?
09:47:47 <EvanR> and i tried a basic ixFun in empty but got
09:47:55 <EvanR> No instances for (Ord a, Typeable a)
09:48:01 <EvanR> No instances for (Ord b, Typeable b)
09:48:27 <EvanR> i think i need constraints somewhere
09:48:53 <applicative> sounds like (Ord a, Typeable a) => is in order ....
09:49:00 <EvanR> where?
09:50:16 <applicative> at the head of the signatures its complaining about?
09:50:26 <hatds> :t fmap
09:50:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:50:40 <EvanR> applicative: its not complaining about signatures
09:50:46 <EvanR> there arent any right now
09:50:58 <EvanR> put a signature for empty?
09:51:30 <EvanR> basically i need to put :: somewhere
09:52:30 <applicative> which 'empty' is this?
09:52:52 <EvanR> Indexable
09:52:54 <EvanR> ixFun :: forall a b. (Ord b, Typeable b) => (a -> [b]) -> Ix a
09:53:08 <EvanR> this already has a constraint so the checker knows that a and b have to be like that
09:53:12 <EvanR> well b
09:53:24 <EvanR> so its complaining that a and b dont have instances
09:53:31 <EvanR> but they cant, they are not specific types
09:54:12 <EvanR> ill paste the instance
09:55:02 <EvanR> i get one such error for each ixFun
09:55:29 <EvanR> http://hpaste.org/71704
09:59:00 <hpaste> EvanR pasted “hmm-error” at http://hpaste.org/71705
09:59:50 <hpaste> hatds pasted “Data.Set and multiple Ord instances” at http://hpaste.org/71706
10:00:26 <EvanR> :(
10:00:33 <hatds> does the above program in the hpaste print what I think it does?
10:02:35 <applicative> set9 is a Set Int not a Set MyInt
10:02:49 <hatds> oops, add a map MyInt then
10:05:46 <applicative> Main is importing both of the conflicting Ord instances. Yipe
10:07:07 <hatds> applicative: yep, but Main doesn't call any functions with an Ord => constraint, so that it legal!
10:07:19 <ocharles> Hmmm. I'm writing a type class to represent a generic backend (ie, PostgreSQL, flat file, whatever). One of the methods will require implementers lock an entry, but I obviously want to keep that lock as short as possible
10:07:48 <ocharles> I have something like inspectFoo :: backend -> m Foo at the moment, but I guess I need some sort of callback to let inspectFoo bracket with a lock
10:08:12 <ocharles> If I do inspectFoo :: backend -> (Foo -> m ()) -> m () then I don't have a guarantee that implementors will actually call that callback though
10:08:33 <ocharles> is there a better way to express what I want, guaranteeing that implementors have to retrieve a Foo and that my continuation will always be called?
10:09:44 <hpaste> EvanR pasted “polymorphic Indexable instance that does not check” at http://hpaste.org/71707
10:09:51 <hatds> \quit
10:10:24 <EvanR> helpppppp
10:11:56 <c_wraith> EvanR: it'd help a lot to know what the error is
10:12:13 <EvanR> i pasted that too
10:12:28 <EvanR> EvanR pasted “hmm-error” at http://hpaste.org/71705
10:12:51 <c_wraith> Oh.
10:13:04 <c_wraith> You need to put those constraints on the instance
10:13:05 <EvanR> ok
10:13:12 <EvanR> i figured i need to put it somewhere
10:13:36 <EvanR> instance Indexable ((Ord a, Ord b ... ) => YEntry a b) ?
10:13:40 <ocharles> actually, I might go with: inspectFoo :: backend -> m (Foo, Foo -> m ()) -- so it returns a 'Foo', but also returns a callback to remove the lock
10:13:48 <c_wraith> no
10:13:58 <ocharles> or maybe just m (Foo, m ()) and let the client deal with keeping track of Foo
10:14:01 <c_wraith> instance (Ord a, Ord b, ..) => Indexable (YEntry ..)
10:14:17 <EvanR> oh
10:14:48 <EvanR> IT WORKSSSSSSSS
10:16:27 <hatds> I'm still wondering: does this program http://hpaste.org/71706 print what I think it does?
10:17:22 <hpaste> hatds annotated “Data.Set and multiple Ord instances” with “Data.Set and multiple Ord instances (annotation)” at http://hpaste.org/71706#a71708
10:17:38 <c_wraith> hatds: it should be a compile error
10:18:14 <hatds> c_wraith: set9 had an incorrect definition you mean?
10:18:46 <c_wraith> hatds: no. I mean that having two conflicting instances in scope, ever, should result in a compile error
10:19:07 <c_wraith> hatds: and Main imports both instances, so it should result in a compile error
10:19:09 <hatds> c_wraith: is that only if an Ord instance is used though?
10:20:08 <c_wraith> I'm pretty sure it should happen regardless of whether the instance is used in that scope
10:20:08 <c_wraith> Just because of what you demonstrated
10:20:09 <c_wraith> there are potential soundness errors if it doesn't
10:21:26 <hatds> c_wraith: Be clear.  Does the program compile and print what I think it does?
10:22:03 <c_wraith> hatds: I really hope not. I haven't checked. (If it does, it's almost certainly something that would be considered a bug)
10:23:37 <fmap> shouldn't `Set MyInt' in `set9' and `Set MyInt' in `insert10' be treated as different types since Ord instances are different?
10:23:59 <hatds> fmap: they are the same type
10:25:04 <c_wraith> fmap: that's one approach. People generally refer to that as indexing the type by its instances
10:25:28 <c_wraith> fmap: it's something that isn't supported in Haskell, but you can do things equivalent to it in Agda
10:26:13 <MrFenix> anyone here into algebra? I was wondering about the connection of heyting algebra and rings - which led me to something strange..
10:26:30 <EvanR> so for an ixset, you have to have different types for every index
10:26:36 <EvanR> or is acts weird
10:26:38 <EvanR> is that right
10:26:47 <EvanR> it acts weird*
10:27:41 <geekosaur> this is one of the reasons newtype exists
10:27:50 <EvanR> yeah i see how to get around it
10:27:53 <EvanR> with new types
10:29:02 <hatds> so does anyone know the language rules here?  My memory was conflicting instances can be imported.  It is only a type error to attempt to use an overloaded function with two instances in scope.
10:29:47 <MrFenix> hatds: have you tried import qualified?
10:30:35 <hatds> MrFrenix: qualified has no effect on instances! :)
10:30:48 <mgsloan> I don't think that conflicting instances can be imported.  You're probably remembering overlapping instances for the check on the function call
10:31:32 <mgsloan> (the issue is that the module needs to be able to export a list of all of the instances it imports)
10:31:44 <hatds> mgsloan: I would find that suprising if conflicting instances can't be imported.
10:33:46 <c_wraith> hatds: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
10:33:53 <c_wraith> hatds: section 4.3.2
10:34:05 <c_wraith> hatds: "A type may not be declared as an instance of a particular class more than once in the program. "
10:34:07 <mgsloan> yeah, it's counterintuitive at first
10:35:38 <hatds> is anyone able to check a simple program to see if it compiles?
10:36:14 <hatds> (with conflicting instances defined in separate modules that is)
10:36:15 <c_wraith> hatds: you probably are
10:36:37 <hatds> c_wraith: I don't have access to a compiler
10:37:46 <BMeph_> Is there a way to programmatically find the next-least fixed point?
10:38:10 <c_wraith> hatds: anyway, it's illegal according to the haskell specification. If it compiles, it's a compiler bug that introduces soundness errors - hopefully, no compiler version with a bug like that makes it into the wild
10:38:53 <hatds> c_wraith: it's not a soundness error if overloaded functions are not resolved in a context where conflicting instances are in scope
10:39:19 <c_wraith> hatds: it *is*, and your code demonstrated it.
10:39:43 <c_wraith> hatds: the correctness of the code in Data.Set depends on only ever having one instance of Ord for a given type
10:39:57 <c_wraith> hatds: If there can be multiple instances, it makes the code in Data.Set unsound
10:40:01 <hatds> c_wraith: hogwash, you can make "invariant breaking" Sets very easily using the internal functions
10:40:46 <hatds> c_wraith: I agree it makes Data.Set's API unsound, but I think that is a narrower issue
10:40:53 <c_wraith> hatds: then remove those functions
10:41:01 <c_wraith> hatds: that removes your argument, but doesn't change mine
10:41:18 <hatds> c_wraith: the external API calls the internal functions, you need them somewhere no?
10:41:29 <c_wraith> hatds: no, you don't
10:41:55 <marcot> Well, I made it work, but I'm not very happy with the solution:
10:41:57 <marcot> canonicate str = T.unpack $ TE.decodeUtf8 $ B.concat $ BL.toChunks $ convertFuzzy Transliterate "UTF-8" "ASCII" $ BL.fromChunks [TE.encodeUtf8 $ T.pack str]
10:42:28 <marcot> Can you see a way of improving it?
10:42:29 <MrFenix> replace $ by .
10:42:59 <marcot> MrFenix: I don't see how this would be an improvement.
10:43:01 <hatds> I was hoping someone would be able to give a clear answer if it compiles or not
10:43:35 <c_wraith> hatds: it doesn't.
10:43:35 <c_wraith> hatds: how much more clear can I be?
10:43:35 <hatds> thanks
10:43:35 <c_wraith> hatds: if it compiles, it's a compiler bug
10:43:46 <MrFenix> canonicate = T.unpack . TE.decodeUtf8 . B.concat . BL.toChunks . convertFuzzy Transliterate "UTF-8" "ASCII" . BL.fromChunks . (:[]) . TE.encodeUtf8 . T.pack
10:44:04 <hatds> c_wraith: I'm not asking because it compiled on my machine, I just wanted to try it themselves
10:44:16 <hatds> *wanted someone
10:44:17 <c_wraith> hatds: why do you ignore the language spec?
10:44:26 <marcot> MrFenix: Yes, I can see, but why is this better than what I sent?
10:44:32 <hatds> c_wraith: because I want to know if it compiles?
10:44:45 <c_wraith> hatds: if it's against the language spec, it's a bug for it to compile
10:44:57 <MrFenix> marcot: matter of taste.. pointfree
10:45:09 <c_wraith> hatds: especially when it's something the spec *so explicitly* says is incorrect
10:45:33 <hatds> c_wraith: you checked it though right and it doesn't compile?
10:45:41 <MrFenix> marcot: can you tell me what T, B, BL and so on are?
10:46:07 <MrFenix> Text,..?
10:46:14 <marcot> T is Data.Text; B, Data.ByteString; BL, Data.ByteString.Lazy; and TE, Data.Text.Encoding
10:46:33 <c_wraith> hatds: no. I read the language spec. (And I understand the soundness violation that would exist if the spec didn't forbid it.)
10:46:42 <hatds> c_wraith: blah
10:47:00 <c_wraith> hatds: why don't you believe the language spec?
10:47:05 <hatds> c_wraith: why don't *you* care if it compiles or not? :) that was the whole point of checking it
10:47:28 <hatds> c_wraith: "eh, maybe ghc has a bug or not, who cares?" obviously we do! :)
10:47:29 <c_wraith> hatds: I know it doesn't compile. It's like asking me if I checked if "module Main where n80bt6208fgt6082f645" compiles
10:47:55 <hatds> c_wraith: well ok, you can ignore my odd request then
10:48:03 <hatds> maybe others find it interesting though
10:48:34 <c_wraith> The interesting part is why it doesn't work.
10:48:43 <c_wraith> Which, despite demonstrating, you don't seem to care about.
10:48:51 * byorgey was going to check, just so this silly conversation would be ended, but found it too annoying to save portions of the paste into four separate modules
10:49:10 <hatds> I wouldn't have brought it up if I didn't think it was important
10:49:50 <mcstar> i dont think you need the different modules
10:49:52 <hatds> I think you are right about what the language defintion says, I had only remembered something different earlier
10:49:53 <mcstar> i read the code
10:50:32 <MrFenix> marcot: is there a reason for the "BL.fromChunks . (:[])" part?
10:50:47 <mcstar> it would be pretty bad if you could make MyInt twice the instance of Ord
10:50:48 <MrFenix> TE.encodeUtf8 is Text -> ByteString
10:50:59 <marcot> MrFenix: It's needed to convert from Lazy to Strict bytestring.
10:51:01 <c_wraith> hatds: I think you were remembering the rules for name clashes, rather than instance clashes. Name clashes are only a compile error if used
10:51:24 <hatds> c_wraith: Yes, most likely that is how I misremembered.
10:51:33 <mcstar> (ofc you can, but not in the same code)
10:51:57 <mcstar> hatds: how come you dont have access to a compiler?
10:52:23 <hatds> mcstar: I'm on a trip and only have access to library computers.
10:52:46 <c_wraith> MrFenix: can you simplify things by converting through lazy Text instead of Strict? Or does that not help at all?
10:54:44 <MrFenix> c_wraith: It only was about TE.encodeUtf8 :: Text -> Bytestring, and BL.fromChunks . (:[]) :: ByteString -> ByteString which confused me
10:55:23 <c_wraith> MrFenix: yeah, but there'd be less code if there was a way to convert between lazy text and lazy bytestrings directly
10:56:11 <c_wraith> MrFenix: because then you could use lazy text's pack and unpack, and avoid strict <-> lazy conversions
10:56:34 <c_wraith> MrFenix: plus, it would allow it to work more lazily, as the whole pipeline would work on lazy types
10:56:59 <c_wraith> MrFenix: However, I don't recall if the text encoding stuff has support for that.
10:57:07 <hatds> I'd like to tell myself I didn't just waste 90 minutes on #haskell without getting a definitive answer -- does ghc actually check if conflicting instances are in scope?  or does ghc only check if there is a conflicting *resolution*?
10:57:19 <mcstar>     Duplicate instance declarations:
10:57:21 <mcstar>       instance Ord MyInt -- Defined at hatds.hs:5:10
10:57:23 <mcstar>       instance Ord MyInt -- Defined at hatds.hs:8:10
10:57:28 <mcstar> hatds: ^^ for your convenience
10:57:41 <hatds> mcstar: Thanks.  Were they in separate modules?
10:57:46 <mcstar> hatds: you GOT a definitive answer from c_wraith
10:58:28 <hatds> mcstar: c_wraith didn't check it, he clarified what the report says the correct behavoir was.
10:58:47 <c_wraith> MrFenix: ah. There's a seperate Data.Text.Lazy.Encoding module
10:58:53 <MrFenix> yeah
10:58:59 <MrFenix> I was about to write that :)
10:59:14 <c_wraith> I think going through it would result in a couple less conversions.
10:59:25 <MrFenix> it has encodeUTF8 directly going to Lazy Bytestring
10:59:43 <c_wraith> sounds like exactly what you want.
10:59:51 <BMeph_> They compile, and it works, like hatds projected.
11:00:05 <hatds> BMeph_: Thanks!  Interesting!
11:00:11 <c_wraith> yay compiler bug!
11:00:27 <MrFenix> reproduceable here..
11:00:39 <mcstar> i removed the modules
11:01:41 <MrFenix> reproduceable here: Base.hs containing data Foo = Foo String; Instance1.hs containing instance Show Foo where show (Foo s) = s; and Instance2.hs containing instance Show Foo where show (Foo s) = "Foo " ++ s
11:01:43 <hatds> I feel like this issue must have been discovered before.  I'm trying to find discussions to no avail.
11:02:42 <BMeph_> So, can one use 'fix' to get a fixpoint for a strict function?
11:02:45 <MrFenix> if I import Instance1 and Instance2 in User.hs, User.hs compiles in ghci 7.4.1 and complains about overlapping instances whenever I use show on a Foo
11:03:15 <ksf_> http://hpaste.org/71713
11:03:24 * ksf_ seems to be unable to grok conduit, atm.
11:03:47 <MrFenix> BMeph: yes, fix from Data.Function should do the trick
11:03:47 <hatds> MrFenix: Right, that's to be expected.  GHC must report an error if it needs to resolve a Show instance and conflicting ones are in scope.
11:03:50 <ksf_> all I want to do is sink a socket into an sinkIO
11:03:54 <ksf_> (in a thread)
11:04:27 <MrFenix> http://www.haskell.org/haskellwiki/Multiple_instances
11:05:32 <MrFenix> http://www.haskell.org/haskellwiki/Orphan_instance
11:05:37 <MrFenix> that is the right one..
11:06:02 <hatds> MrFenix: see, most webpages on conflicting and orphan instances don't talk about language definitions.  Just good practices.
11:06:14 <ksf_> orphran instance warnings are there so it's less likely that one ends up in your situation
11:06:45 <mcstar> hatds: ghci loads it, main is executed
11:07:33 <hatds> The example was insidiously constructed, but the point is that programmers might accidently create conflicting instances.  Someone imports those two modules but doesn't care about resolving instances in their module.
11:07:55 <ksf_> yep, that happens.
11:08:11 <ksf_> hence the orphran instances warning, so it doesn't happen so often.
11:08:58 <ksf_> typeclass instances are supposed to be program-global, if you have two different instances something is just plain *wrong*.
11:09:13 <ksf_> ie. there's only one way to show an int.
11:09:33 <mcstar> yeah, -Wall gives a warning
11:09:44 <hatds> ksf_: it makes perfect sense from the compilers point of view to have conflicting instances.  If the overloaded functions are only ever resolved in places where there is a single instance.
11:10:00 <ksf_> and it works, in that case.
11:10:20 <ksf_> but note that once you import a module, you have all its instances, there's no way around that.
11:10:22 <BMeph_> ksf_: The operative word being "supposed". :)
11:10:23 <c_wraith> hatds: it may make sense as an explanation for why the bug exists - but it's a bug.
11:10:51 <MrFenix> maybe the bug is on purpose
11:10:56 <mcstar> btw, can 2 types, identically created in 2 different modules, and later used interchangably?
11:11:01 <MrFenix> overlapping instances can be desired
11:11:04 <ksf_> mcstar, nope.
11:11:15 <c_wraith> MrFenix: overlapping, yes. these aren't overlapping, they're the same
11:11:27 <ksf_> ...as long as you don't use -XIncoherentInstaces...
11:11:45 <hatds> mcstar: in that case you have 2 completely distinct types.  You can have them in the same module, but you have to refer to them qualified.
11:12:16 <ksf_> which is why haskell programs tend to have one, usually rather gigantic, "Types" module.
11:12:24 <MrFenix> c_wraith: being the same is a special case of overlapping
11:12:41 <hatds> c_wraith: Like I said, I feel like this must have been discussed before.  It is possible the behavoir is intentional, and it is possible they didn't consider examples like this.
11:12:49 <Veinor> ksf_: i like to think of it as the haskell equivalent of a .h
11:12:50 <ksf_> it's a case of overlapping that leaves no non-overlaps.
11:12:52 <c_wraith> MrFenix: special in that it's not one allowed by the extension
11:13:36 <ksf_> let's argue the other way round: which instance should be chosen?
11:13:53 <MrFenix> c_wraith: maybe for the ghc internals it was necessary to treat them the same..
11:15:32 <oo_miguel> hi
11:16:07 <ksf_> http://hpaste.org/71713
11:16:08 <Toheii_> Newb question here, but I'm reading LYAH and I'm having trouble understand binary trees I was wondering whether it would hurt if I went back and took a better look when I understood a bit more haskell or if there was a really good tutorial on them
11:16:13 <ksf_> anyone fluent in conduits?
11:16:46 <MrFenix> nevertheless I think, that the current behaviour - bug or not is fine
11:16:53 <ksf_> Toheii_, did you ever search a name in a telephone book?
11:17:00 <ksf_> divide and conquer?
11:17:04 <ksf_> that's what binary trees are.
11:17:12 <MrFenix> if a module creates an instance conflict it is better to be able to use the parts which are not broken, than to use non
11:17:34 <nand`> binary trees are trees where every non-leaf element has exactly two branches
11:17:38 <nand`> if that makes sense
11:17:39 <Toheii_> ksf_ I understand their purpose, but I don't get how to use them
11:17:42 <nand`> what you use them for varies greatly
11:17:49 <ksf_> for the general state of haskell libraries, it's probably better if it's an error in every case.
11:18:44 <hatds> MrFenix: It's fine in one sense, but not so fine in another.  You can have stronger APIs if you know multiple instances won't exist in the program.
11:18:56 <mcstar> from a node, you can always choose a left or right branch, until you hit a leaf, thats how they work
11:19:12 <mcstar> (a more interesting tree is a balanced btree)
11:19:41 <MrFenix> hatds: that could be done by compiler flag
11:19:55 <MrFenix> hatds: -Wall -Werror or something like that..
11:20:45 <MrFenix> I know that it is more clean to not have multiple instances at all
11:21:15 <MrFenix> but sometimes works trumps clean ;)
11:22:06 <MrFenix> and this sort of thing can result from the f***ed up default instances in Prelude & Base
11:22:24 <LambdaDusk> is there any way in haskell to install a timed callback? you know "execute this every 0.2 seconds" or something?
11:22:41 <EvanR> ksf_: reading that tulsa telephone book can drive a guy insane
11:22:48 <c_wraith> LambdaDusk: easiest is forkIO and threadDelay
11:22:50 <EvanR> ksf_: especially if that girl youre looking for has no last name
11:23:09 <MrFenix> LambdaDusk: maybe http://www.haskell.org/haskellwiki/Functional_Reactive_Programming
11:24:06 <LambdaDusk> MrFenix: I am working on an adaption of SDL for Yampa and need some way to fire an event for a new frame
11:24:25 <Cale> Is SDL even thread-safe?
11:25:16 <EvanR> not really
11:25:27 <LambdaDusk> cale: I don't think so - afaik that is why the timer callback have been stripped from the haskell bindings
11:25:56 <EvanR> the timer callback, the thread stuff obviously, and some of the event functions are thread safe
11:26:02 <EvanR> but not the graphics
11:26:12 <EvanR> especially not opengl
11:26:17 <MrFenix> LambdaDusk: http://hackage.haskell.org/packages/archive/Yampa/0.9.3/doc/html/FRP-Yampa-Task.html .. Could timeOut be right?
11:26:39 <LambdaDusk> But I tried GLUT and GLFW and both don't open on my computer because of something with a framebuffer I couldn't find out
11:26:45 <MrFenix> oh ok.. not
11:26:48 <MrFenix> forget about timeOut
11:27:14 <MrFenix> but sleepT
11:28:13 <LambdaDusk> MrFenix: This doesn't quite work out...
11:28:22 <ksf_> ARGH DAMN TYPE INFERENCE
11:29:02 <Cale> ksf_: ?
11:29:08 <ksf_> ...another case of "actual error is on exactly the other side of the program than the displayed error"
11:29:13 <LambdaDusk> so you guys say I use threadDelay?
11:29:24 <ksf_> combined with "confusing type flow so you don't know left from up"
11:30:06 <mcstar> LambdaDusk: why didnt glut work?
11:30:29 <MrFenix> LambdaDusk: afterEachCat?
11:31:16 <LambdaDusk> mcstar: It worked fine on my laptop, but when I tried it on my desktop, the window did not open
11:31:19 <MrFenix> LambdaDusk.. or just repeatedly :: Time -> b -> SF a (Event b)
11:31:53 <LambdaDusk> MrFenix: ... where is that defined?? I never saw it!
11:32:04 <MrFenix> http://hackage.haskell.org/packages/archive/Yampa/0.9.3/doc/html/FRP-Yampa.html
11:32:55 <MrFenix> LambdaDusk: the source contains more documentation.. Somehow haddock does not show it
11:33:18 <LambdaDusk> MrFenix: Because the package creator only used -- instead of -- | comments
11:33:45 <EvanR> glfw ftw
11:33:47 <aalevy> is there an equivalent to "read" that returns Maybe a instead of throwing an exception?
11:34:07 <LambdaDusk> EvanR: My current glfw implementation doesn't open a window either
11:34:29 <EvanR> you have problems
11:35:25 <LambdaDusk> EvanR: I don't get an error message from glfw at all, it's only a boolean function
11:36:06 <mcstar> you said 'something with a framebuffer', where does that come from?
11:36:18 <LambdaDusk> mcstar: From GLUT
11:36:31 <mcstar> whats the exact message?
11:36:57 <MrFenix> aalevy: try reads to get a list of possible results
11:38:07 <MrFenix> aalevy: fmap fst . listToMaybe . readS
11:38:27 <LambdaDusk> mcstar: Trying to find out, takes a moment to re-go in the git tree
11:38:56 <aalevy> MrFenix: cool, thanks
11:39:56 <MrFenix> aalevy: that is reads and not readS ^^
11:40:15 <aalevy> MrFenix: yeah I caught that :) thanks that's exactly what I needed
11:40:17 <LambdaDusk> mcstar: "freeglut (<interactive>):  ERROR:  Internal error <FBConfig with necessary capabilities not found> in function fgOpenWindow"
11:40:52 <LambdaDusk> or completely: http://pastie.org/4279375
11:41:28 <mcstar> LambdaDusk: can you even run glxinfo/glxgears?
11:41:42 <mcstar> they are mesa utilities
11:42:01 <LambdaDusk> mcstar: Both run fine
11:42:20 <mcstar> can you paste the output of glxinfo?
11:42:56 <LambdaDusk> mcstar: http://pastie.org/private/imcojppm93xijm3xtbnjw
11:42:56 <baxter001> I'm throwing together a ray tracer but can't think of any better way to scan the scene than mapping a function over [(x,y)| x<-[0..10],y<-[0..10]] any anyone advise any better ways to approach it?
11:43:29 <adimit> STM Question: I have a thread t_cons, and one t_prod. t_cons reads from TChan t what t_prod writes to it. After t_prod has written all its data, it wants to wait for t_cons to finish. (Both threads are IO actions.) So I write something like do { r <- tryPeekTChan c; unless (otherThreadIsDone r) retry; } to check whether the other thread has written back a sentinel. But what happens if t_cons dies (async
11:43:31 <adimit> exception?) Then I'm in a deadlock, and the application crashes because STM detects that.
11:43:32 <LambdaDusk> the fun part is I asked for help on this on dedicated channels and no one never cared, but on the Haskell channel someone does
11:44:30 <adimit> So my question is: how can I avoid that? What's the best way to check whether the other thread has died?
11:45:49 <mcstar> LambdaDusk: any reason for using freeglut, and not glut?
11:45:53 <adimit> (since I'm doing the check with tryPeek etc. in STM, I can't do any IO actions within it. I'd have to do an IO action within the retry block.)
11:46:08 <LambdaDusk> mcstar: "leaveMainLoop" is only implemented in freeglut
11:46:22 <mcstar> what does it do?
11:46:37 <mcstar> closes the event loop?
11:46:57 <LambdaDusk> mcstar: Exactly that.
11:47:10 <ClaudiusMaximus> baxter001: lists and parBuffer are fine i guess (but maybe also use 'range' from Ix instead of list comprehensions), also might be worth a look at repa (though i think that works better for regular workloads than stuff where some parts potentially need more calculations than others)
11:48:32 <mcstar> LambdaDusk: what is the situation that you need to resort to that?
11:48:48 <baxter001> Ok, I'll have a poke around hackage, thanks.
11:49:56 <LambdaDusk> mcstar: Yampa-Glut fires events from the glut-callbacks. In order to end the program, it has to leave the mainLoop in some way
11:51:21 <EvanR> can i import qualified in ghci
11:51:47 <LambdaDusk> mcstar: In not-freeglut, how can one leave the mainLoop at all without terminating the process alltogether?
11:52:04 <mchm> Hi. I want to learn how to use the csv-conduit package. How can I use it interactively in GHCi? Should I import modules and files _from_ GHCi, or should I instead load a haskell file that does the import?
11:52:10 <ClaudiusMaximus> EvanR: yes, at least in ghci-7.4.2
11:52:23 <mcstar> LambdaDusk: i assume, you destroy the window when you are done with everything
11:52:41 <mcstar> LambdaDusk: still, it is possible to push the rendering to another thread
11:53:10 <ClaudiusMaximus> @hoogle exit
11:53:11 <lambdabot> System.Exit data ExitCode
11:53:11 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
11:53:11 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
11:53:24 <mcstar> though, im not talking about in haskell's context now, im a newbie to haskell, but thinking in c++ terms
11:53:32 <LambdaDusk> mcstar: I don't think the issue is freeglut-specific, because GLFW doesn't open a window either
11:55:03 <mcstar> do you have anything special in xorg.conf?
11:55:09 <ClaudiusMaximus> LambdaDusk: random guess: i got bizarro GL errors when updating my sytem without rebooting and reinstalling the proprietary drivers
11:55:22 <mcstar> that could possibly mess with how X handles opengl
11:55:39 <mcstar> definitely reboot
11:55:58 <mcstar> at least kill X
11:55:59 <ClaudiusMaximus> mcstar: why?  i've got jobs running that aren't finished yet
11:56:06 <ClaudiusMaximus> mcstar: i found a workaround
11:56:08 <LambdaDusk> mcstar: standard ubuntu installation, and I am sure I booted a hundred dozen times since installation
11:56:18 <mcstar> ClaudiusMaximus: not you
11:57:27 <LambdaDusk> could it be an actual hardware problem?
11:57:53 <LambdaDusk> never had opengl troubles on this machine, running games fine
11:58:27 <mcstar> probably not
11:59:36 <LambdaDusk> or just a missing flag in the openWindow thingie
11:59:55 <mcstar> have you tried example programs?
12:00:05 <mcstar> im compiling the freeglut stuff right now
12:00:24 <mcstar> there are some programs under ./progs
12:01:16 <mcstar> it is working
12:01:48 <mchm> Sorry for asking this again in a short while: I want to learn how to use the csv-conduit package. How can I use it interactively in GHCi? Should I import modules and files _from_ GHCi, or should I instead load a haskell file that does the import? Is there any documentation on it available that I'm not aware of? (Read the readme).
12:01:56 <mcstar> i have opengl 2.1.2
12:03:05 <jhance> mchm: Uhh normally you can do either but if you want to learn it with interactive experimentation I would just use the GHCi without any haskell files, if possible. I would generally use a haskell file if you have any longer functions you want to test out...
12:04:03 <LambdaDusk> mchm: You can import modules with ":m" in ghci, but it's recommended to use a file
12:04:32 <LambdaDusk> mcstar: Which example programs?
12:04:45 <mcstar> LambdaDusk: that come with freeglut
12:04:47 <mchm> jhance, LambdaDusk: Haha! Back to square one ;)
12:07:57 <LambdaDusk> mcstar: I found some blog post that suggests that setting "GLUT_RGB" instead of "GLUT_RGBA" can cause this problem
12:08:23 <mcstar> i worked for me w/ wo A
12:08:29 <mcstar> yesterday-ish
12:08:34 <mcstar> but thats simple glut
12:08:50 <mcstar> anyway, good luck, i dont think i can help
12:10:14 <LambdaDusk> mcstar: I thank you anyway for your help
12:10:54 <MrFenix> heyting algebra is freaking me out
12:11:54 <MrFenix> I was just looking for a connection between heyting algebras and rings - which share almost every property using join and meet as + and *
12:12:56 <mchm> Has anyone actually used csv-conduit?
12:13:03 <MrFenix> but it gets confusing around ¬a = (a => 0) which would in a ring ammount to a + ¬a = 0 <=> a U (a => 0) = 0 and in the interpretation of boolean algebra a or not a = false ...
12:13:50 <Clint> mchm: i have
12:14:22 <mchm> Clint: Have you learned how it worked from its documentation, or by experimenting in GHCi?
12:14:26 <ParahSailin> does lazy execution mean ghc runtime will choose the optimal data structure for what i want it to solve?
12:14:37 <mauke> ParahSailin: no
12:14:47 <jhance> mchm: Do you have any experience with conduit itself? That comes first...
12:14:55 <Clint> mchm: docs, i suppose. possibly both.
12:15:03 <mchm> jhance: not at _all_.
12:15:24 <jhance> mchm: If you learn how to use `conduit' your life will be a lot easier with _any_ conduit-based package
12:16:03 <Clint> you don't actually need to know about conduits if you just want to use it to parse a csv file
12:16:47 <jhance> Clint: True, I guess. mchm: It looks like `readCSVFile` will do the job wihtout any real compilications...
12:17:49 <ParahSailin> so what do i use for an immutable hash map
12:18:18 <mauke> ParahSailin: Map
12:18:27 <jhance> mchm: Just be aware that if you do use any of the functions that abstract away conduit the result is probably strict... So you would have to load the entire CSV file into memory wiht readCSVFile which might not be desirable
12:19:18 <mchm> jhance: I've tried using readCSVFile defCSVSettings "/path/" - didn't work.
12:19:52 <jhance> mchm: In what way did it not work? You'll need to use runResourceT with that too, probably.
12:19:55 <mchm> jhance: at the moment, I'm just working with a one line, multiple columns CSV file, just to work out how it works.
12:20:45 <mchm> jhance: even with runResourceT $ command, it doesn't load.
12:20:58 <jhance> mchm: What happens? Infinite loop? [] response?
12:21:03 <mchm> I'll try defining a name in a HS file, and then loading it.
12:21:21 <mchm> jhance: No instance for (CSV Data.ByteString.Internal.ByteString a0)
12:22:04 <ski> augur :)
12:22:16 <jhance> mchm: You should try typing the final result to `[Row ByteString]` then
12:22:20 <ski> Tomsik_ : but see roconnor's "Y Combinator in Haskell" at <http://r6.ca/blog/20060919T084800Z.html>
12:22:25 <ski> edwardk : "you'd need to kill the occurs check, then EVERYTHING typechecks" -- nope :) just try `ocaml -rectypes'
12:22:53 <jhance> mchm: Which means that the result of the whole expression should be (runResourceT $ ...) :: IO [Row ByteString]
12:23:08 <mchm> jhance: will try that.
12:23:23 <jhance> mchm: String ByteString by the way
12:23:28 <jhance> mchm: Strict*
12:25:10 <Tomsik_> ski, I was interested about the solution without constructors
12:26:56 <mchm> jhance: ByteString not in scope.
12:27:19 <jhance> mchm: :m + Data.ByteString
12:28:21 <ski> > ocaml -rectypes Objective Caml version 3.11.2
12:28:21 <ski> # let fix f = (fun t -> t t) (fun g x -> f (g g) x);;
12:28:21 <ski> val fix : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = <fun>
12:28:21 <ski> # fix (fun fib -> function 0 -> 0 | 1 -> 1 | n -> fib (n - 2) + fib (n - 1)) 12;;
12:28:22 <lambdabot>   Not in scope: `ocaml'Not in scope: `rectypes'Not in scope: data constructor...
12:28:24 <ski> - : int = 144
12:28:26 <ski> Tomsik_ ^
12:29:08 <mchm> jhance: thanks. I wrote it all in a file, defining a test function that loads my CSV. At first I defined my function's type as test :: IO () but it wouldn't compile
12:29:23 <mchm> then I used your hint, and it works.
12:29:33 <ski> (.. for some reason the "Objective ..." line got merged with the command line above)
12:30:32 <ski> (netjoin ?)
12:31:08 <monochrom> net-forkIO and net-waitMVar. or something
12:31:15 <jfischoff> how do I make readFile not be lazy? I'm writing a simple munger, so I need read and write to same file.
12:31:50 <SegFaultAX|work2> jfischoff: Is writing to a temporary and renaming not an option?
12:31:51 <monochrom> net-atomically { x <- readTVar v; when (x>0) retry; ... }
12:32:20 <jfischoff> SegFaultAX|work2: yes, but I would rather just learn how to avoid that
12:32:28 <monochrom> use readFile from System.IO.Strict or something. package name "strict-io"
12:32:46 <jfischoff> yeah just saw that
12:32:47 <jfischoff> ok
12:33:32 <jhance> mchm: OK, good
12:33:42 <monochrom> if you use Bytestring or Text anyway, they already have non-lazy readFile
12:34:17 <MrFenix_> jfischoff: evaluate the structure that you have hread
12:34:25 <jhance> jfischoff: Why do you need string readFile
12:34:27 <monochrom> apparently, there is a competing package "strict" :)
12:34:28 <MrFenix_> $! will do that for you if it is flat
12:34:30 <jhance> jfischoff: strict*
12:35:13 <SegFaultAX|work2> Freenode is having a hard time right now.
12:35:49 <monochrom> star topology has cut points and cut edges
12:36:09 <jfischoff> I don't "need" it be string, it just a very simple script, and I find string the easiest to work with
12:37:38 <MrFenix_> jfischoff: x <- readFile foo; let x' = id $! x; and you might be done
12:38:01 <c_wraith> uh
12:38:05 <jfischoff> the strict package worked
12:38:07 <monochrom> done if the file length is 0 or 1 or 2
12:38:18 <mchm> MrFenix: but what happens if your file contains a lot of segmented data?
12:38:20 <c_wraith> id $! x  does nothing
12:38:33 <monochrom> oh wait, what c_wraith says
12:38:40 <jfischoff> ^ yes
12:38:45 <jhance> id $! x is similar to x `seq` x, correct?
12:38:49 <c_wraith> yep
12:38:56 <mchm> as in experimentala data?
12:38:58 <Cale> and x `seq` x is the same thing as x
12:38:59 <c_wraith> it's exactly the same
12:39:16 <MrFenix_> then map (id $!) x should do the trick
12:39:24 <jhance> yeah so just use strict-io... or go to strict bytestring/text :)
12:39:39 <MrFenix_> or.. wait..
12:39:41 <monochrom> the point is "let" doesn't do anything
12:40:49 <MrFenix_> agrg it is hard to escape lazyness ^^
12:41:07 <jhance> MrFenix_: With a String, deepseq is probably the easiest way...
12:41:39 * mchm is confused, will work it out in due time.
12:42:15 <jhance> MrFenix_: Also its not desirable to do lazy readFile and then strictify the result because of the ramifications of using unsafeInterleaveIO and not closing file handles, I believe. It is better to use something that will guarantee the closing of the FH.
12:43:15 <MrFenix_> jhance: but for simple scripts which should not depend on fancy stuff this might not be nice
12:43:56 <astory> If I have [IO (Bool)] and I want to produce just one IO(Bool) from them using or, is there a way to lift the function in the right way?
12:44:29 <mauke> :t liftM or . sequence
12:44:30 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
12:44:34 <MrFenix_> or . sequence?
12:44:48 <MrFenix_> or <$> sequence that is
12:44:52 <astory> liftM looks like what I want, thanks!
12:45:27 <astory> ...also sequence.  that might be more appropriate
12:45:44 <jhance> astory: Its all one expression; you need all of it
12:46:14 <astory> jhance: yeah, but I really just needed to know the function existed.
12:46:28 <Eduard_Munteanu> liftM isn't particularly special here.
12:46:31 <Eduard_Munteanu> :t liftM
12:46:32 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:46:58 <MrFenix_> alternatives to liftM are fmap or the infix version <$>
12:47:08 <MrFenix_> :t fmap
12:47:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:47:13 <MrFenix_> :t (<$>)
12:47:13 <ParahSailin> :t (<$>)
12:47:14 <Eduard_Munteanu> The trick was first getting IO [Bool] from [IO Bool] via sequence, I'd say.
12:47:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:47:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:47:24 <monochrom> @type foldM
12:47:25 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:47:45 <Eduard_Munteanu> :t sequence
12:47:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:47:54 <edwardk> ski: i gave up the ability to reason about ocaml types a long time ago ;)
12:48:14 <astory> well, my whole problem is that I have [IO t] (for this particular t), t -> Bool, and I want to take (or) over the entire list
12:48:24 <astory> so putting these bits together in a sane way is interesting
12:48:46 <ski> edwardk : the real problem with cyclic types is that it hides many would-be type errors as strange cyclic types
12:49:21 <latro`a> why does foldM exist
12:50:09 <monochrom> is that a philosophical question?
12:50:14 <latro`a> sort of
12:50:20 <latro`a> to me it just looks like type constrained foldr
12:50:24 <latro`a> unless I'm missing something
12:50:32 <monochrom> then I don't know. perhaps nothing exists.
12:50:51 <latro`a> wait, I think I am in fact missing something
12:50:53 <latro`a> :t foldr
12:50:54 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:50:57 <latro`a> ah
12:51:16 <latro`a> er, wait, what
12:51:28 <latro`a> erm, woops
12:51:31 <latro`a> :t foldl
12:51:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:51:39 <latro`a> that was the "ah" I was looking for
12:51:54 <MrFenix_> foldlM is just foldl lifted to Monads
12:51:58 <MrFenix_> nothing special about it..
12:52:00 <latro`a> but it's actually lifted
12:52:04 <latro`a> not just type constrained
12:52:28 <latro`a> because foldl's first argument and third argument have the same type
12:52:35 <latro`a> err
12:52:43 <latro`a> foldl's first argument's first argument and third argument have the same type
12:54:03 <MrFenix_> latro`a: with apropriate monoid instances you can skip foldM and foldl from prelude
12:54:56 <chrisdone> pretty sure this is possible; there's a way in a .cabal file to have a program have a dependency which is the library of the current cabal file. right?
12:55:42 <Clint> yes
12:55:48 <Clint> you use the name of the library
12:56:11 <eden_> Hi. I'm trying to write a function allM :: Monad m => (a -> m Bool) -> [a] -> m Bool. The best I've found is allM f = foldr (liftM2 (&&) . f) (return True). Is there any way of lifting the ordinary "all" function to do the same?
12:56:21 <monochrom> @src foldM
12:56:21 <lambdabot> foldM _ a []     = return a
12:56:21 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:56:57 <monochrom> I think that's a foldr
12:57:16 <MrFenix_> all <$> mapM ?
12:57:27 <MrFenix_> :t all <$> mapM
12:57:29 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m [b]'
12:57:29 <lambdabot>       Expected type: (a -> m b) -> [a] -> Bool
12:57:29 <lambdabot>       Inferred type: (a -> m b) -> [a] -> m [b]
12:57:30 <chrisdone> thought so
12:57:53 <MrFenix_> :t \f -> all <$> mapM f
12:57:54 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[b]'
12:57:55 <lambdabot>       Expected type: [a1] -> a -> Bool
12:57:55 <lambdabot>       Inferred type: [a1] -> a -> [b]
13:00:43 <eden_> Well, allM f = liftM and . mapM f has the right type, and even works but I'm leery of the use of sequence in mapM, as it seems to want to collect all the values before handing them over, and I'd rather it return false as soon as a False value is encountered.
13:01:47 <MrFenix_> eden_: allM f x = (mapM f x) >>= (return . and)
13:03:00 <eden_> MrFenix : same sequence issue, unless I'm badly mistaken.
13:03:07 <MrFenix_> y.. sry
13:03:45 <MrFenix_> eden_: what about foldM ?
13:08:27 <eden_> MrFenix : foldM works like foldl, from left to right, but I think it needs to be right associative to to the early termination. I have spent quite some time thinking about these different options...
13:08:51 <eden_> to to the -> to do the
13:10:19 <zhulikas> @type ()
13:10:19 <lambdabot> ()
13:10:22 <zhulikas> what the hell is ()?
13:10:26 <mauke> @src ()
13:10:27 <lambdabot> data () = ()
13:10:41 <MrFenix_> eden_: have you tried to do it by hand?
13:10:42 <zhulikas> I see...
13:11:26 <MrFenix_> eden_: you could just implement what you need with manual recursion
13:11:46 <MrFenix_> eden_: then you go for sure, that everything is evaluated the right way
13:13:20 <eden_> MrFenix : I did do it by hand, with ordinary recusrion, which led to the foldr (liftM2 (&&) . f) (return True) solution. Seems heavyweight, so I thought I'd ask and find out if anybody could do better
13:15:35 <mroman> Can one use type variables in ::
13:15:36 <mroman> like
13:15:39 <mroman> foo :: a -> a
13:15:49 <mroman> foo b = 0 :: a
13:16:29 <geekosaur> mroman, with an extension and slightly modified syntax
13:17:11 <mroman> bitSize needs a dummy argument
13:17:23 <geekosaur> LANGUAGE ScopedTypeVariables; then you need to explicitly "declare" the type variables which should have scope beyond the declarator, with forall
13:17:29 <mroman> and I need a dummy argument to supply bitSize with a dummy argument
13:17:39 <geekosaur> there's also `asTypeOf` which you can use in some cases
13:17:48 <mroman> else I would use bitSize (0 :: a)
13:17:53 <mroman> but it's still ugly.
13:18:00 <mroman> because that'd require Num :(
13:18:42 <parcs`> @hoogle bitSize
13:18:42 <lambdabot> Data.Bits bitSize :: Bits a => a -> Int
13:19:01 <parcs`> :t let foo a = bitSize 0 `asTypeOf` foo 0 in foo
13:19:02 <lambdabot>     Ambiguous type variable `t' in the constraint:
13:19:02 <lambdabot>       `Bits t' arising from a use of `bitSize' at <interactive>:1:12-20
13:19:02 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
13:19:43 <geekosaur> that seems a little too recursive to me
13:19:49 <mroman> https://github.com/FMNSSun/hs-experiments/blob/master/bits.hs#L40
13:19:58 <parcs`> :t let foo a = let z = 0 in bitSize z `asTypeOf` foo z in foo
13:19:59 <lambdabot>     Ambiguous type variable `a' in the constraint:
13:19:59 <lambdabot>       `Bits a' arising from a use of `bitSize' at <interactive>:1:25-33
13:19:59 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
13:20:02 <mroman> ^- a is just needed as a dummy argument.
13:21:04 <parcs`> :t let foo a = bitSize (0 `asTypeOf` foo 0) in foo
13:21:05 <lambdabot> forall t. (Num t) => t -> Int
13:21:24 <mroman> The Num t restriction is not an option.
13:21:39 <mroman> or wait
13:21:44 <mroman> ok it is.
13:21:48 <parcs`> it's not a restriction
13:21:58 <mroman> Bits already requires Num.
13:22:00 <parcs`> well, depending on how you look at it
13:22:04 <EvanR> whats more efficient comparing short bytestrings or comparing Integer
13:23:34 <geekosaur> short bytestrings, I imagine, but this sounds a little premature-optimization-ey
13:23:47 <geekosaur> which one's more convenient to work with?
13:23:57 <mroman> parcs`: I always look at => as a restriction ;)
13:24:02 <EvanR> they both have Ord and Eq so
13:24:21 <EvanR> i just need something to use as a indexable id
13:24:24 <mroman> If it's not forall it is restricted to some types.
13:24:35 <parcs`> mroman: yeah but the alternative is to add a type signature or restrict it further
13:24:58 <mroman> Bits implies/requires Num so that's not a problem.
13:26:34 <eden_> Ah well, I'll live with what I've written.
13:27:22 <MrFenix_> eden_: y.. seems the best option
13:27:29 <dmwit> EvanR: I think you need to profile. I can't really imagine really convincing reasons either ByteString or Integer comparisons would be significantly faster.
13:27:38 <EvanR> yeah
13:27:48 <dmwit> But I agree with geekosaur that this sounds a little fishy.
13:28:12 <EvanR> well im just gonna put a type Key = ByteString for now
13:29:18 <timthelion> I am not at all sold on using a parser library like parsec... the parsec example code I've looked at has been hard to read/understand and it seems easy to parse in haskell without a library...  so why is using such a library so popular?
13:29:22 <mchm> How do I force cabal to install when it gives me "Ambiguous occurence 'function'" errors?
13:29:40 <mroman> timthelion: From my point of view
13:29:45 <byorgey> timthelion: because it's not easy to parse in haskell without a library.
13:29:47 <mroman> It's easier to use than write it otherwise.
13:29:58 <zomg> timthelion: obviously something like parsec might be better for non trivial syntaxes
13:30:06 <geekosaur> mchm:  pastebin the actual full error.  what package?
13:30:14 <mchm> geekosaur:ssv
13:30:34 <mroman> but maybe that's just me beeing to dump to parse non-trivial stuff without a library
13:30:39 <mchm> http://pastebin.com/uXnPyujr
13:30:42 <mauke> The paste uXnPyujr has been copied to http://hpaste.org/71715
13:30:51 <mroman> -e
13:30:59 <mroman> *b
13:31:37 <byorgey> looks like the ssv package has not been updated to work with more recent versions of the containers package.
13:31:46 <mchm> bleh...
13:31:50 <timthelion> byorgey, I have no trouble recursively eating strings and parsing them that way myself
13:31:51 <byorgey> mchm: there's no way to "force" it, you would have to fix the package
13:32:04 <byorgey> mchm: fortunately that looks like it wouldn't be that hard to do
13:32:11 <mchm> Why is Haskell not wanting to let me play with CSV files? I'm having a real tough time with it.
13:32:21 <mchm> byorgey: depends who does it ;)
13:32:32 <byorgey> timthelion: then you are braver than most, or only parsing particularly simple grammars, or both
13:32:33 <dmwit> Recursive descent is easy when it works, but it only works on a very small subset of the interesting grammars.
13:32:36 <MrFenix_> timthelion: try getting into Control.Applicate
13:32:47 <MrFenix_> that will make parsec easier to understand
13:33:04 <timthelion> MrFenix_: ok, will look
13:33:16 <MrFenix_> timthelion: try getting into Control.Applicative
13:33:22 <MrFenix_> typo..
13:33:27 <byorgey> mchm: have you tried the 'csv' package?  I've had good luck with that one in the past
13:33:30 <mroman> mchm: Maybe hide one foldr?
13:34:03 <mchm> byorgey: I've tried it, but I can't work out how to extract one row, or one column, from my CSV file. I can import it fine, but then...
13:34:55 <mchm> mroman: I've been using Haskell for a week now, so.. I wouldn't want to mess things up so quickly.
13:35:07 <byorgey> mchm: well, you use something like parseCSVFromFile, which gives you an Either ParseError CSV
13:35:17 <mchm> mroman: meaning, if it doesn't install properly right now, I'll try something else xD
13:35:23 <byorgey> you pattern-match on that, and do something appropriate if it's an error, otherwise you have a value of type CSV
13:35:36 <byorgey> which is really just a synonym for [[String]]
13:35:38 <MrFenix_> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
13:35:55 <monochrom> where CSV is a list of lists of strings. like [["1", "2"], ["3", "4"]]. that's your lines and fields
13:36:37 <EvanR> heh the show instance for [[String]] is basically equivalent to a csv format ;)
13:36:41 <byorgey> extracting one row can be done by extracting one element of the CSV list.  extracting a column can be done by first using 'transpose' to flpi it
13:36:47 <MrFenix_> it is quite a lot to read.. but once you are into <$>, <|>, <*> and co parsec is fine :)
13:36:48 <byorgey> *flip
13:36:48 <EvanR> and read is parser
13:37:43 <mchm> MrFenix_: is that a reading suggestion for me?
13:38:13 <mchm> monochrom, byorgey: I can load my file, but then I can't "printCSV" on it
13:38:43 <MrFenix_> mchm: no.. it was for timthelion
13:38:49 <mchm> Ok.
13:39:01 <byorgey> mchm: can you paste your code and the error message on hpaste.org ?
13:39:02 <carter_> mchm: this isn't helpful right now, but i should real soon™ be releasing a lib for better manipulation of tabular data in haskell :)
13:39:10 <carter_> likely around or after hackphi
13:39:19 <byorgey> mchm: do you know how to work with IO ?
13:39:46 <mchm> byorgey: only what I've learned from LYAH
13:40:01 <mchm> what I understood* from what I learned from LYAH
13:40:11 <monochrom> and do you know Either?
13:40:18 <mchm> carter_: good :)
13:40:29 <mchm> monochrom: No, but I guess it's self-explanatory>?
13:40:38 <monochrom> learn Either
13:40:39 <byorgey> @src Either
13:40:40 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:40:46 <carter> mchm: as long as you have no objection to a bsd4 style license :)
13:40:56 <monochrom> I don't know what is self-explanatory. subjective.
13:40:56 <byorgey> data Either a b = Left a | Right b   -- mchm
13:42:14 <monochrom> printCSV (parseCSVFromFile "x") is an obvious type error because, clearly, "IO (Either blahblah CSV)" is not "CSV". learn types.
13:42:22 <mchm> carter: no problemo
13:42:52 <ski>   do ...
13:43:00 <ski>      blah <- parseCSVFromFile "x"
13:43:05 <ski>      case blah of
13:43:15 <ski>        Left blahblah -> ...
13:43:22 <carter> mchm: good, I"ve a few enterprise customers wanting it and a few other tools i'm rolling out soon... and bsd4 is the best way to ensure they're talking with me so I can support building awesome tools :)
13:43:27 <ski>        Right csv -> do
13:43:32 <carter> while allowing everyone else to use the stuff freely
13:43:33 <ski>          printCSV csv
13:43:46 <monochrom> what ski says. good sample code with holes
13:44:00 <mchm> ski: great
13:44:01 <tomboy64> gute nacht
13:44:09 <ski> auf wiedersehn
13:44:31 <monochrom> in "do ...", I would just delete "..."
13:44:40 <mchm> monochrom: I figured xD
13:44:49 <ski> yeah, depends on how much else you want to do here
13:46:22 <monochrom> to understand recursion, you must first understand recursion
13:46:28 <mchm> monochrom: lol
13:46:44 <monochrom> to understand a haskell library, you must first understand haskell. this one is not so circular
13:47:40 <monochrom> many people don't realize how much they don't understand haskell itself, when their surface symptom is having difficulties with a haskell library
13:48:12 <mchm> monochrom: I'm not illusioned.
13:48:17 <monochrom> this is because "if you know one language, you know all other languages, just change syntax" is falsehood
13:48:36 <ski> @quote blub
13:48:37 <lambdabot> dons says: C++: creating blub programmers since 1985
13:48:40 <hpc> it's true for (C, 90% of languages)
13:48:57 <monochrom> yes, that's true
13:49:35 <jfischoff> monochrome: I ran into this with a coworker trying to explain Agda today.
13:49:44 <nand`> if the only substantial difference between languages is their syntax they might as well be the same language (or dialects of the same)
13:49:53 <mcstar> monochrom: i have to disagree, newbies learn much by using the library
13:50:02 <augur> ski: why did you smile at me D:
13:50:05 <monochrom> if you have 70 years C experience, you can honestly do and testify: "I started learning python yesterday, today I'm already using 10 python libraries to do stuff"
13:50:18 <ski> mcstar : yes, they do. that doesn't detract from what monochrom said
13:50:30 <mcstar> yes it does
13:50:38 <MrFenix_> monochrom: If you are used to c you won't use any python libs
13:50:40 <mcstar> he says its a symptom that they 'expect' to understand it
13:51:09 <augur> ski: i think i have some ideas tho about intros/elims being locally sound, from formal considerations alone
13:51:12 <MrFenix_> monochrom: batteries included will make you use standard stuff only ;)
13:51:27 <mcstar> lol just installed it
13:51:34 <mcstar> as well as janestreet core
13:51:58 <monochrom> the same 70 years of C experience stops you from using Haskell within one day of learning
13:52:01 <ski> mcstar : a symptom of what ?
13:52:03 <EvanR> so for a Door data structure, youre saying i should not have an open :: Bool field, but rather put every other field ABC in a Open ABC | Close ABC ? to avoid boolean blindness
13:52:25 <mcstar> ski: read what he said, his words
13:52:35 <monochrom> instead, if you're a 12-year-old, no prior experience, you may actually get very far into Haskell (or C, or brainfuck) in one day, yes
13:52:55 <ski> augur : as a reply to the categorical logic connection with simply typed lambda calculus, propositional logic
13:52:57 <EvanR> with proper brainfuck documentation yeah
13:53:21 <monochrom> (or if you're Gauss with 70 years experience in all sorts of abstractions and reasoning and learning)
13:53:45 <mchm> monochrom: I'm not a computer scientist nor am I a mathematician - I'm a chemistry trying to learn Haskell to write computational chemistry software. Until now, it's been manageable, but it _is_ a difficult language. I can't just sit and read tutorials, I need hands on experience - hence why I want to play around with CSV files.
13:54:00 <mcstar> chemist*
13:54:08 <mchm> chemist* yes
13:54:10 <nand`> arguably, he's a chemistry too
13:54:10 <mchm> woops.
13:54:24 <monochrom> a chemist also agrees that "I'm a chemistry" is a true statement :)
13:54:27 <nand`> I'm not sure how overloaded that word is
13:54:45 <mcstar> a chemistry somehow implies to me as if were several chemistries
13:54:53 <mcstar> which sounds silly
13:54:57 <geekosaur> o/` chemicals in the bloodstream ...
13:55:06 <mcstar> alcohol?
13:55:12 <mcstar> oh, thats not a riddle
13:55:16 <mcstar> sry
13:55:18 <mchm> to have chemists you first need chemistry, so I guess definining myself as being "chemistry" is either preposterous or way too general.
13:55:19 <ski> mcstar : oh sorry. missed that sentence when i looked back. still, i think learning much (about Haskell and about the library) when trying to use the library doesn't detract from monochrom's statement of difficulties with libraries often being caused by not understanding some aspect of Haskell
13:55:30 <nand`> as opposed to chemicals everywhere else in the body? :P
13:56:23 <ski> EvanR : probably depends
13:56:23 <nand`> hmm, I guess I thought the word ‘chemistry’ could be used to mean ‘a system involving chemicals’, I guess I was wrong
13:56:30 <mcstar> ski: ok, i dont totally disagree, i just want to say, that i would explicitely tell someone, come on, dont try to understand the languaeg per say, but look at the libs, try to use them, it will all fit soon
13:56:42 <mcstar> (not that it happened to me, im just saying)
13:56:43 <EvanR> ski: ah im interested in hearing what you have to say about this
13:57:13 <monochrom> suppose a library has a function of type "String -> CSV". you can use it immediately for practice, yes. but this library gives you "... -> IO (Either ParseError CSV)". now you have to figure out IO and Either first
13:57:19 <ozataman> mchm: I think you'll need to take an iterative approach that involves both tutorials and hands on practice. it would be hard to learn haskell by just playing around with it if you don't have prior functional programming experience..
13:57:22 <ski> mcstar : yes, there's some merit to that (one doesn't have to learn it all at once). but there's also merit to trying to understand the basics of the type system, up-front
13:57:38 <mchm> ozataman: I use Mathematica daily.
13:57:57 <mcstar> mchm: and nightly i presume
13:58:00 <mchm> ozataman: But as some of you may know, there's quite a difference between both.
13:58:10 <mcstar> mma sweet mma
13:58:16 <mchm> monochrom: absolutely.
13:58:19 <mcstar> mixed martial arts
13:58:21 <ozataman> mchm: not knowing mathematica to its full extent, I doubt that'll be enough background to pick up haskell without tutorials/some kind of reference
13:58:38 <mcstar> mma is lisp not haskell
13:59:08 <ski> EvanR : let's say you also want to keep track of whether the door is locked or not (for simplicity, you can assume an open door can be locked) -- now what ?
13:59:11 <MrFenix_> ski: the basics of the haskell type system?
13:59:14 <EvanR> ski: right
13:59:15 * nand` just read through LYAH and it (well, at least the basics that would be involved in using a CSV parser) all started making sense from there on
13:59:19 <ski> MrFenix_ : yes
13:59:21 <MrFenix_> ski: are you sure you want that?!
13:59:37 <EvanR> ski: you can only extract one of the fields like this
13:59:48 <monochrom> I am in fact a bit more inclined to parseCSV :: FilePath -> String -> Either ParseError CSV. you only need to figure out Either there.
13:59:59 <EvanR> unless you want a combinatorial explosion of constructors
14:00:03 <ski> MrFenix_ : yes. you start to learn such basic by reading LYAH or some other book
14:00:16 <MrFenix_> ski: ahh .. those basics
14:00:18 <mchm> nand: I'm reading through LYAH, but I'm getting tired of not being able to do anything interesting with data YET
14:00:19 <ski> MrFenix_ : .. or by hanging around on mailing lists ior here and asking lots of questions :)
14:00:44 <MrFenix_> ski: from your combinator name I thought you were talking about the real type system basics
14:00:46 <hpaste> anonymous pasted “Random generator” at http://hpaste.org/71717
14:00:46 <ski> (though it's best to combine both approaches, imo)
14:01:01 <mchm> and from a non-CS/math major, this _can_ be annoying.
14:01:05 <mchm> to*
14:01:08 <MrFenix_> ski: like in Gamma |- \ x -> y : sigma -> tau
14:01:12 <hpaste> anonymous pasted “Random generator” at http://hpaste.org/71718
14:01:43 <nand`> mchm: I'm not sure how to solve that problem. For me, learning how Haskell works was the interesting motivation; I almost never think ‘this sounds cool, how can I use it in practice?’
14:02:29 <ski> (monochrom : "inclined to" -- to what ?)
14:02:32 <EvanR> hmmmm
14:02:54 <monochrom> to start with
14:03:23 <ski> are you sure you wanted  `FilePath' in there ?
14:03:30 <nand`> monochrom: I can't say I understand how that function is supposed to work from the type signature. It takes a FilePath but doesn't work in IO?
14:03:39 <MrFenix_> I don't think anyone wants to learn the type-theoretical stuff about haskell (if he/she is not inclined to do generic programming or compiler hacking)
14:03:46 <nand`> maybe the FilePath is only there to annotate errors but the ‘String’ is the actual contents
14:03:51 <mchm> monochrom: what nand said is the reason why I haven't tried it yet.
14:03:53 <ski> MrFenix_ : oh :)
14:04:02 <monochrom> the FilePath is just for parser error messages in ParseError
14:04:23 <ski> MrFenix_ : well, to some degree you'll start to learn (implicitly) the basics of that, as you learn (how to use) the type system of Haskell ;)
14:04:27 <ski> ah
14:04:30 <monochrom> "Given a file name (used only for error messages)" on the doc page
14:04:57 * ski hasn't actually looked at the library page
14:05:35 <ski> augur : ok ?
14:05:43 <nand`> I'm still not entirely convinced that should be the job of the function. If you want to annotate parse errors with context, shouldn't that be the calling function's job?
14:05:55 <nand`> I would write parseCSV :: String -> Either ParseError CSV
14:05:56 <mchm> MrFenix_: everything in its right place (and time) - I have absolutely no problem learning _anything_, really. Meanwhile, I DO have a limited brain capacity, and that means I have to choose what to learn and when.
14:06:04 <augur> ski: nothing i can tell you about yet, but im close, maybe :)
14:06:17 <EvanR> you have a limited brain capacity, until your head explodes
14:06:25 <EvanR> because youre learning haskell  lol
14:06:32 <nand`> EvanR: and then you refactor to avoid existentials
14:06:46 <EvanR> partial application ftw
14:06:48 <EvanR> haha
14:07:53 <monochrom> nand`, it's a parsec style thing
14:09:03 <hpaste> Nereid annotated “kind-polymorphic functor class” with “kind-polymorphic functor class (annotation)” at http://hpaste.org/71683#a71720
14:09:26 <Nereid> ^ I posted this last night when the channel was asleep
14:09:45 <Nereid> I don't see why this shouldn't work.
14:10:19 <Nereid> that AnyK thing is suspicious, and I guess there are some related bug reports. I should see if it's fixed in 7.5.whatever
14:11:03 <mchm> Got to go, will be back later. Thanks a lot for your help! I'd have dumped Haskell if this channel didn't exist... :)
14:11:20 <ski> augur : ok, np
14:12:21 <Nereid> but as it is, I have to write a separate instance for (->) and (:->) and so on. I wonder if type families or something could clean that up.
14:12:22 <chrisdone> 25 test cases for my compiler
14:12:33 <chrisdone> this is definitely stable now¡
14:13:53 <ski> Nereid : is that assuming the same definitions ?
14:13:58 <ParahSailin> :t (>>=)
14:13:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:14:03 <Nereid> ski: for what?
14:14:15 <ski> your annotation
14:14:17 <Nereid> yes
14:14:18 <ParahSailin> what does the "m a" mean-- is that function m applied to a?
14:14:30 <Nereid> ParahSailin: it's the type constructor m applied to a
14:14:44 <ParahSailin> ah.
14:14:45 <EvanR> will getCurrentTime :: IO UTCTime fail in 2038 or whatever
14:14:46 <ski> ParahSailin : consider `[Integer]', which is the type of lists of integers
14:14:59 <Nereid> also written [] Integer
14:15:03 <chrisdone> hey Peaker :)
14:15:04 <ParahSailin> type constructor, gotcha
14:15:06 <Nereid> [] is a type constructor, applied to the type Integer.
14:15:08 <ski> ParahSailin : this is really sugar for `[] Integer', where `[]' here can be pronounced as "list of"
14:15:10 <Nereid> similar.
14:15:43 <ski> ParahSailin : you can also have a value of type `Maybe Integer' meaning that you either `Nothing', or `Just n' where `n' is an `Integer'
14:15:55 <Nereid> ParahSailin: so in fact [] is a Monad, so specializing to m = [] would give (>>=) the type [a] -> (a -> [b]) -> [b].
14:16:01 <ski> ParahSailin : and there's `Either MyErrorMessage Integer', `IO Integer', &c.
14:16:03 <Nereid> etc.
14:16:25 <gspr> I'm a bit confused when it comes to FFI callbacks to Haskell code. Here's a (probably too complex) scenario that's concerning me: Suppose I have some C code that produces some data, say in the form of lots of chars. The C code can be passed a function pointer to a function taking a char*. After the C code has produced its data, it calls this function with the data as the argument, and never touches the data again afterwards. Is it possible for 
14:16:28 <ski> ParahSailin : the `m' above can be `IO', it can be `Maybe', it can be `Either MyErrorMessage', it can be `[]'
14:16:29 <ParahSailin> so "m a" is something that has been constructed as a monad
14:16:39 <Nereid> well, m is the monad. :P
14:16:51 <ski> `m a' is the type that you get when you pass the type `a' to the type function `m'
14:17:11 <ParahSailin> ah
14:17:16 <ski> `[]', i.e. "list of" is a type function that converts types like `Integer' to types like `[Integer]'
14:17:18 <chrisdone> (note: “type function” and “type constructor” tend to be used interchangeably)
14:17:32 <gspr> ugh, that came out even more confused than I had thought...
14:17:44 <ski> ParahSailin : generally, in `m a', `m' doesn't have to be a monad, just a type function. in the above case it must be a monad because of the `Monad m'
14:17:56 <Nereid> gspr: it also got cut off, after "Is it possible for"
14:17:59 <Eduard_Munteanu> gspr: your previous message got cutoff at "Is it possible for"
14:18:01 <ski> chrisdone : hehe, i don't approve of that :)
14:18:05 <gspr> Ah, sorry
14:18:11 <Eduard_Munteanu> *cut off
14:18:13 <gspr> here's the rest: Is it possible for me to, in Haskell, write a function foo :: TChan (ByteString  Char) -> Ptr Char -> IO ()  that (unsafely) makes a ByteString Char from the Ptr Char *and* insert
14:18:21 <gspr> it  into the TChan, and can I pass this function (partially applied to the TChan) to C using FFI?
14:18:26 <gspr> *inserts it
14:19:01 <gspr> Here's an attempt to shorten and de-confuse it all, though: Can I pass functions of type Something -> IO () to C?
14:19:15 <ski> i suppose `foo' would need to contain a call to `atomically', to be able to access the bytestring
14:19:21 <gspr> ski: Yes
14:19:27 <ski> gspr : iirc, yes
14:19:53 <gspr> OK -- very good news.
14:20:26 <ParahSailin> :t putStr
14:20:28 <lambdabot> String -> IO ()
14:20:33 <chrisdone> gspr: yeah… i did that recently, let me see if i had to do anything weird
14:20:41 <gspr> chrisdone: Interesting! Thanks.
14:20:46 <ParahSailin> where is the type constructor turning putStr into a monad
14:21:05 <Nereid> ParahSailin: the monad there is IO.
14:21:28 <Nereid> so, example
14:21:30 <Nereid> :t getStrLn
14:21:31 <lambdabot> Not in scope: `getStrLn'
14:21:33 <Nereid> oh.
14:21:36 <Eduard_Munteanu> The monad is the type constructor.
14:21:50 <ski> gspr : i think you'll want to use `foreign import ccall "wrapper" ...'
14:21:51 <ParahSailin> :t (>>=) putStr
14:21:53 <lambdabot> forall b. (IO () -> String -> b) -> String -> b
14:22:08 <Nereid> :t (>>= putStr)
14:22:09 <lambdabot> IO String -> IO ()
14:22:10 <gspr> ski: wrap, you mean?
14:22:14 <ski> no
14:22:30 <gspr> ski: Oooh.. there's a wrap *and* a wrapper?
14:22:32 <chrisdone> gspr: right, here: https://github.com/chrisdone/freenect/blob/master/src/Freenect/FFI.hs#L59
14:22:41 <ski>   foreign import ccall "wrapper" mkCallback :: IO () -> IO (FunPtr (IO ()))
14:22:43 <Nereid> oh here.
14:22:43 <ski> is their example
14:22:45 <Nereid> :t readLn
14:22:45 <lambdabot> forall a. (Read a) => IO a
14:22:47 <hpaste> hiptobecubic pasted “Monadic Dice” at http://hpaste.org/71721
14:22:56 <hiptobecubic> Can someone tell me if that makes sense
14:23:03 <Nereid> ParahSailin: so let's have a look at "readLn >>= putStr"
14:23:03 <chrisdone> gspr: so you make an ffi that produces a function pointer, and then you can pass the FunPtr (X -> Y -> IO Z) to C functions
14:23:04 <ski> this turns the haskell action there into a C function pointer
14:23:20 <Nereid> ParahSailin: for the types to work, we have readLn :: IO String, and putStr :: String -> IO ()
14:23:25 <hiptobecubic> Or is there a better way to dit
14:23:27 <Nereid> ParahSailin: so in
14:23:27 <ski> but i think it'll also work if you replace `IO ()' with `Blah -> IO Bleh'
14:23:28 <hiptobecubic> do it*
14:23:29 <Nereid> :t (>>=)
14:23:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:23:40 <Nereid> ParahSailin: here, we specialize to m = IO, a = String, b = ()
14:23:54 <Nereid> so (>>=) :: IO String -> (String -> IO ()) -> IO ()
14:24:02 <ski> gspr : so, you use the automatically constructed wrapped function to export Haskell actions/function as C function pointers
14:24:03 <Nereid> which is just the right type for readLn >>= putStr to work.
14:24:26 <Nereid> (I'd use putStrLn instead of putStr but the types are the same.)
14:24:43 <gspr> ski: Yeah, sorry, I misread the wiki. I'd heard about wrapper afterall :)
14:24:51 <ParahSailin> ok im gonna play around with that for a bit
14:25:02 <gspr> Right, thanks guys... I'm still a bit confused by what happens when the Haskell function returns IO () though
14:25:04 <Nereid> and readLn >>= putStr is the same as, in do notation,
14:25:06 <gspr> on the C side I mean
14:25:11 <Nereid> do { x <- readLn; putStr x }
14:25:18 <gspr> chrisdone: Your code is doing *exactly* what I'm trying to do, so thanks a lot for that!
14:25:33 <Nereid> (of course, do notation is defined in terms of >>=)
14:25:34 <chrisdone> excellent, thought it might!
14:25:38 <ParahSailin> i dont what to pay attention to the do notation until i understand what the functions are
14:26:34 <gspr> chrisdone: Just one question (which I guess I can figure out by looking around in your repo): On the C side, what's the type of the function pointer?
14:26:48 <gspr> What I'm getting at is what does C think of IO ()?
14:27:01 <gspr> All the Wiki examples I've seen wrap pure functions
14:27:21 <ski> gspr : see "Dynamic wrapper" under "Standard C Calls" at <http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1620008.5.1>
14:28:05 <Nereid> ParahSailin: might not be a bad idea :)
14:28:14 <gspr> chrisdone: I'm guessing it's a pointer to a function that takes something like shorts and ints (that part doesn't matter) and returns what... void?
14:28:24 <hiptobecubic> ParahSailin, I'm working through this right now. I think it's pretty good. It doesn't seem as retarded as most of them. http://en.labs.wikimedia.org/wiki/Haskell/Understanding_monads
14:28:43 <Nereid> gspr: () is void
14:28:44 <chrisdone> gspr: Ptr DeviceStruct -> Ptr Word16 -> Word32 -> IO () versus
14:28:45 <chrisdone> gspr: typedef void(* freenect_video_cb)(freenect_device *dev, void *video, uint32_t timestamp)
14:29:05 <chrisdone> gspr: yeah, returns void
14:29:10 <gspr> Alright, perfect!
14:29:13 <gspr> Thanks a bunch
14:29:18 <gspr> think I grasp it then
14:29:26 <shachaf> hiptobecubic: That looks pretty terrible. :-(
14:29:29 <EvanR> i love the time lib so much
14:29:30 <ski> gspr : per the table a little bit down on that page, C will think `FunPtr a' is `(void (⋆)(void))'
14:29:41 <hiptobecubic> shachaf, what about it looks terrible?
14:29:41 <EvanR> personifies everything that is right with haskell
14:29:44 <gspr> ski: Ah, right! Should've been able to see that myself :)
14:29:47 <gspr> ski: Thanks!
14:30:31 <timthelion> Does haskell-src-exts parse Haskell 2010 or only 98?  haskell-src only parses 98 :(
14:30:33 <chrisdone> gspr: yeah it's quite reasonable but indeed nice to see a real example and the actual concrete corresponding C code
14:30:48 <chrisdone> timthelion: parses 2010 and more
14:30:55 <Nereid> hence "-exts"
14:31:01 <timthelion> good :)
14:31:03 <geekosaur> it should support all but the most recent ghc extensions, I think
14:31:04 <shachaf> hiptobecubic: E.g. IO as (State World), "nuclear waste" analogy, "monads as containers"
14:31:19 <shachaf> "This page is undergoing a major rewrite."
14:31:30 <EvanR> lol nuclear waste analogy?
14:31:32 <hiptobecubic> shachaf, i'm not actually there yet. I was just working through the building blocks part in the beginning
14:31:35 <gspr> chrisdone: Now that I have you here and it's clear that you've been doing some FFI stuff lately, I'll ask for advice: When interfacing with C libraries, you often have rather big structs floating around. Do you tend to write Storable instances for these and use them entirely in Haskell? So far I've found myself writing "simplifying functions" in C that take standard types (or smaller structs) and deal with the massive structs the libraries requ
14:31:36 <Nereid> I don't think any one article is going to be enough to understand monads.
14:31:44 <ski> gspr : of course, if you have `FunPtr (Int32 -> IO Int32)' you should cast from `(void (⋆)(void))' to `(int32_t (*)(int32_t))' asap
14:31:44 <shachaf> hiptobecubic: That part doesn't look so great either.
14:31:46 <gspr> chrisdone: Do you have any thoughts with regards to that?
14:31:52 <Nereid> I had to see them from several different angles and just play with them for them to make sense.
14:32:04 <Eduard_Munteanu> gspr: cut off at "the libraries requ"
14:32:09 <gspr> sorry
14:32:10 <shachaf> Nereid: But many articles can have a worse-than-nothing effect.
14:32:24 <gspr> "massive structs the libraries require without bothering Haskell"
14:32:27 <gspr> (was the end of it)
14:32:53 <ski> gspr : it's just that C guarantees that all function pointers can be cast between different function pointer types and back with no UB, being identity, and `(void (*)(void))' is a common canonical representative of a "generic" function pointer type
14:33:20 <gspr> ski: I see. Makes sense.
14:33:24 <hiptobecubic> shachaf, well based on the several hours of explanation people have given me in here, it doesn't seem to have any horrible lies in it like the turds-in-a-spacesuit or whatever other crazy thing. It just reinvents System.Random
14:33:30 <ParahSailin> is IO () kinda like a tuple with a null value with some sort of state data?
14:33:43 <EvanR> lol
14:33:48 <scopedTV> no, ParahSailin is an action that, when performed, does some IO and then returns a value of type ().
14:33:51 <Eduard_Munteanu> ParahSailin: you shouldn't actually care
14:34:01 <ski> ParahSailin : `()' is like a null-tuple, yes
14:34:13 <ParahSailin> IO is a type constructor of the ()?
14:34:19 <Eduard_Munteanu> No.
14:34:20 <scopedTV> ParahSailin: no.
14:34:21 <EvanR> > ()
14:34:22 <lambdabot>   ()
14:34:26 <EvanR> > () + ()
14:34:27 <ParahSailin> applied to it i mean
14:34:27 <lambdabot>   No instance for (GHC.Num.Num ())
14:34:27 <lambdabot>    arising from a use of `GHC.Num.+' at <i...
14:34:29 <shachaf> hiptobecubic: It's full of horrible lies. :-(
14:34:35 <scopedTV> ParahSailin: IO is a type constructor, yes
14:34:39 <scopedTV> ParahSailin: IO () is a type
14:34:42 <ski> ParahSailin : the `IO' part means that this is an I/O-action that (when *executed*) can interact with your computer Operating System before yielding a result of type `()'
14:34:47 <Eduard_Munteanu> ParahSailin: data Foo a = Bar | Baz a    -- Foo is a type constructor, Bar and Baz are data constructors
14:35:04 <hiptobecubic> shachaf, pre "Input/Output needs bind" ?
14:35:09 <ski> ParahSailin : the `()' here is really used as "uninteresting result", similarly to `void' in C,C++,Java,C#
14:36:04 <shachaf> hiptobecubic: Yes. :-(
14:36:07 <shachaf> But oh well.
14:36:13 <hiptobecubic> shachaf, well can you clarify?
14:36:36 <Nereid> any recommendations on having multiple installed versions of GHC? e.g. a stable one and HEAD
14:36:49 <shachaf> Nereid: It should "just work".
14:36:54 <ParahSailin> :t (>>=) readLn putStr
14:36:56 <lambdabot> IO ()
14:36:56 <Nereid> cool, I'll try it out.
14:37:04 <ski> gspr : "What I'm getting at is what does C think of IO ()?" -- on the C side, `IO' disappears, since all functions may be side-effectful
14:37:07 <ParahSailin> easier for me to understand without the infixing
14:37:09 <chrisdone> gspr: in this case i just wrote a cbits module as you described: https://github.com/chrisdone/freenect/blob/master/cbits/freenect-helpers.c didn't see a way to access structs reliably from haskell, was happy enough writing straight c
14:37:31 <mekkz> ParahSailin, have you read LYAH?
14:37:44 <ParahSailin> i didnt like that one
14:37:55 <Nereid> I thought it was cute.
14:38:05 <geekosaur> chrisdone, structs are doable via hsc2hs or c2hs
14:38:12 <mekkz> What about it didn't you like?
14:38:17 <hiptobecubic> I thought it was good too, but it was only half done when I went through it
14:38:32 <mekkz> I thought it gave me a great explanation of monads.
14:39:00 <ParahSailin> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html this was the most helpful for me
14:39:02 <EvanR> to understand monads, open the interpreter and use >> and >>= on a few things and see what happens
14:39:07 <EvanR> not IO
14:39:22 <chrisdone> geekosaur: that stuff autogenerates the c accessors right?
14:39:38 <Eduard_Munteanu> Eventually you might want to look at and implement your own Reader, State etc. monads
14:39:51 <geekosaur> c2hs does.  hsc2hs gives you tools to write them yourself
14:39:59 <ParahSailin> the type of main should be IO (), correct?
14:40:06 <Nereid> I love "you could have invented ..." articles
14:40:10 <Nereid> You could have invented spectral sequences!
14:40:13 <Nereid> (...no probably not)
14:40:30 <EvanR> you could have invented holomorphic encryption
14:40:38 <Nereid> homomorphic?
14:40:50 <mekkz> Yes, Parah
14:40:56 <EvanR> that too
14:41:20 <Eduard_Munteanu> Holo is hip now.
14:41:32 <mekkz> Do you know about any other monads, Parah? Like Maybe or [] ?
14:41:55 <MrFenix_> let f x = you could have invented x in f f
14:42:00 <ski> ParahSailin : i also like "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>
14:42:06 <Eduard_Munteanu> And yeah, Maybe is a good way to start.
14:42:30 <Nereid> Eduard_Munteanu: did you see my paste earlier? I tried your idea of a GFunctor thing, but I had to make a kind-polymorphic category class, and then I still ran into kind errors.
14:42:50 <Nereid> I suspect a bug. http://hpaste.org/71683
14:42:57 <Eduard_Munteanu> ski: courses, lectures, monads, *research*... all the wrong words in that URL to introduce a basic language idiom :P
14:43:24 <ski> Eduard_Munteanu : well, it *is* possibly the *first* monad tutorial ..
14:43:42 <Eduard_Munteanu> Ah, heh, so that's the one.
14:43:53 <Eduard_Munteanu> Nereid: mm, no, *looking*
14:44:10 <chrisdone> amusingly, the original monad paper is actually a great 'tutorial'
14:44:10 <mchm> Can The Answer to Life, The Universe And Everything be computed in Haskell?
14:44:18 <Nereid> it would still be nice to be able to make one declaration for every kind though
14:44:24 <ski> (you can see it's somewhat dated by it stating "Online Tutorial" -- still i think it's quite nice, and to the point)
14:44:25 <Eduard_Munteanu> Nereid: actually, I'll look tommorow, I'm a bit tired right now.
14:44:29 <Nereid> sure.
14:45:13 <chrisdone> what's great about read 'the original paper' of anything is the de-mysticism effect
14:45:42 <EvanR> but you can use the monad mysticism to your advantage
14:45:42 <chrisdone> you've got smart people who invented it saying "we're pretty sure this is good, and it might sound weird, but what if we did…"
14:45:49 <EvanR> by confusing and bewildering the audience
14:45:52 <byorgey> wadler's original paper about using monads for structuring functional programs is great for that
14:45:56 <EvanR> avoiding success at all costs
14:46:05 <chrisdone> byorgey: exactly what i'm talkin' about, great
14:46:08 <ski> ParahSailin : well, iirc, `main' can actually have type `IO Foo' for any type `Foo' you like (result is ignored) -- the common case is `IO ()', though
14:46:53 <ski> @faq Can The Answer to Life, The Universe And Everything be computed in Haskell?
14:46:53 <lambdabot> The answer is: Yes! Haskell can do that.
14:46:56 <ParahSailin> ski: gotcha
14:46:57 <Eduard_Munteanu> I remember something similar to what ski mentioned.
14:47:00 <ski> wb mchm
14:47:27 <byorgey> http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps  -- highly recommended
14:47:31 <chrisdone> unsafePerformOpenBeerBottleWithKnife
14:47:37 <shapr> chrisdone: Are you doing that?
14:47:47 <chrisdone> shapr: DID it :)
14:47:49 <byorgey> > 6*7
14:47:50 <lambdabot>   42
14:47:51 <shapr> yay!
14:47:54 <ski> byorgey : for ParahSailin ?
14:48:17 <byorgey> for anyone.
14:48:25 <ski> but yes, Wadler is recommended
14:48:40 <ski> (if for nothing else, then for his paper titles)
14:49:44 <byorgey> he does have good paper titles =)
14:50:11 <Nereid> :)
14:50:45 <ski> "How to add Laziness to a Strict Language, without even Being Odd" by Philip Wadler,Walid Taha,David MacQueen in 1998-09  at <http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#lazyinstrict>
14:50:49 <ski> e.g.
14:52:10 <mchm> Is that paper (about functional programming) recommended even for a newbie?
14:52:21 <mchm> I mean, a Haskell newbie
14:52:24 <chrisdone> also the orig. type-classes paper too, is fab
14:52:24 <Nereid> ah, no wonder ghc was failing to compile, my gcc was broken.
14:53:48 <chrisdone> shapr: i took a pic of what i'm drinking presently https://dl.dropbox.com/u/62227452/Photos/valmiermuiza.png
14:53:49 <EvanR> whats the diff between lazy and string RWS
14:53:54 <chrisdone> shapr: delicious latvian beer
14:54:22 <byorgey> mchm: sure
14:55:45 <ski> mchm : i recommend browsing through Wadlers papers, trying to read them (that's more or less how i learned to read papers)
14:55:49 <chrisdone> ski: yeah the 'online' prefix is a 90s give-away :p
14:56:20 <ski> mchm : also Simon Peyton-Jones and some others
14:56:51 <ski> mchm : if some thing in a paper appears hard to grasp, you can just skip it for the time being
14:57:44 <ski> mchm : note that that even-odd paper uses SML syntax (not Haskell), also SML is strict
14:57:48 <augur> ski: so i think the general pattern for local soundness is this:
14:58:03 <augur> you have some introduction step, which uses inputs I, I', ...
14:58:24 <timthelion> haskell-src-ext's parseModule is so close to perfect for my use.  It breaks the file into PatBinds.  But it does too much parsing,  I need the PatBinds as strings of source which I can then parse myself.  So I dug in the source to see if there wasn't some intermediate function.  And I sure hope that what I found was autogenerated... http://hackage.haskell.org/packages/archive/haskell-src-exts/1.9.6/doc/html/src/Language-Haskell-Exts-Interna
14:58:37 <ski> mchm : `:' in SML is `::' in Haskell. and in types `foo list' is `[Foo]' in Haskell
14:58:48 <augur> followed immediately by an elimination step which uses inputs   E (the thing being eliminated) and A, A', ... (some auxiliary proofs)
14:58:56 <ski> mchm : so `foo susp' would be `Susp Foo'
14:59:00 <chrisdone> timthelion: are you trying to extend haskell?
14:59:24 <augur> ski: such that Elim(Intro(I, I', ...), A, A', ...) : P
14:59:28 <mchm> ski: thanks
14:59:46 <augur> ski: and such that Intro(I, I', ...) : EP
14:59:46 <ski> mchm : also, the MLs prefix type variables with an appostrophe
15:00:00 <timthelion> chris, no, just writing a languge that includes snippets of haskell code...
15:00:17 <augur> ski: and it should be possible to produce some new proof   Simp(I, I', ..., A, A', ...) : P   that doesn't have EP in it
15:00:32 <augur> that is to say, the templat for Simpl doesn't have EP (but the args for it might)
15:00:34 <ski> mchm : if you haven't seen the "divides line" in that paper before, it means : if all the stuff above the line is true, then the stuff below is also true
15:00:48 <ski> (this is common notation when talking about type systems)
15:01:06 <mchm> ski: ok. This is all new to me.
15:01:11 <timthelion> a language who's syntax would preferably share a lot with haskell...
15:01:31 <mchm> And not having studied CS before makes it quite challenging - comprehensible, but exhausting.
15:02:03 <ski> mchm : yeah -- most of what i know about type systems, i've learned by attempting to read such papers ;)
15:02:11 <timthelion> chrisdone: that was in response to you
15:02:54 <Nereid> timthelion: looks like it was generated with happy
15:02:56 <ski> timthelion : possible cut off
15:03:13 <Nereid> yeah the url was cut off at the end
15:03:35 <timthelion> sorry http://hackage.haskell.org/packages/archive/haskell-src-exts/1.9.6/doc/html/src/Language-Haskell-Exts-InternalParser.html
15:03:51 <mchm> ski: Wait, "The essence of functional programming" was published in a CS journal?
15:04:24 <ski> augur : yes
15:04:45 <mchm> Oh, at a conference.
15:05:26 <mchm> The style is different from what I'm used to. I feel like the author's talking to me, lol.
15:05:28 <EvanR> is there a newtype wrapper for Maybe a where a has Ord and makes Nothing greater than any Just
15:05:52 <Nereid> EvanR: Maybe already has that
15:06:03 <Nereid> > Nothing < Just ()
15:06:04 <EvanR> Nothing is less than any Just
15:06:04 <lambdabot>   True
15:06:17 <ski> mchm : yeah, it's great :)
15:06:22 <HairyDude> how on earth do you get a concrete exception out of a SomeException?
15:06:23 <Nereid> oh.
15:06:24 <Nereid> misread
15:06:45 <timthelion> does this mean that I cannot reuse GHC's work? I'd just like to keep the same symbol syntax and support both indented and curly bracket styles...
15:07:13 * geekosaur is thinking the Dual newtype that will show up officially soon?
15:07:15 <Nereid> timthelion: maybe you can have a look at SrcLoc?
15:07:34 <timthelion> Nereid, will do
15:07:48 <EvanR> :k Dual
15:07:49 <lambdabot> * -> *
15:07:56 <Nereid> hmm.
15:08:14 <HairyDude> :t fromException
15:08:16 <lambdabot> Not in scope: `fromException'
15:08:18 <Nereid> hmmmm.
15:08:23 <EvanR> > Dual (Just 4) < Dual (Nothing)
15:08:24 <lambdabot>   False
15:08:35 <EvanR> > Just 4 < Nothing
15:08:36 <lambdabot>   False
15:08:56 * geekosaur wonders if that has anything to do with the ghc internal he's thinking of
15:09:03 <Nereid> > Dual (Just 3) < Dual (Just 2)
15:09:04 <lambdabot>   False
15:09:10 <Nereid> oh neat.
15:09:15 <Nereid> wait.
15:09:18 <Nereid> yes that's right.
15:09:25 <EvanR> lol
15:09:58 <HairyDude> is this right: fromException someException :: Maybe MyException returns Just myException if it's the type you want, else it's Nothing
15:10:09 <Nereid> wait.
15:10:11 <Nereid> yeah no.
15:10:15 <Nereid> haha
15:10:42 <Nereid> HairyDude: looks like it.
15:11:04 <HairyDude> never played with existentials before
15:11:24 <ski> > getDual (Dual "abc" ++ Dual "def")
15:11:26 <lambdabot>   "defabc"
15:11:53 <Nereid> EvanR: you can always write your own newtype wrapper. :)
15:11:59 <EvanR> yeah
15:12:15 <ski> geekosaur : hm, i suppose there possibly should be an `Opposite' wrapper for turning an order on its tail
15:12:25 <dmwit> EvanR: Yes, there's MinPriority and MaxPriority in the monoids package.
15:12:30 <Nereid> ski: yes, but we still want 2 < 3
15:12:43 <ski> > (map (fmap getDual . getDual) . sort . map (Dual . fmap Dual)) [Just 2,Nothing,Just 3]
15:12:46 <lambdabot>   [Nothing,Just 2,Just 3]
15:12:47 <EvanR> :t MaxPriority
15:12:48 <ski> except with `Opposite' instead
15:12:48 <lambdabot> Not in scope: data constructor `MaxPriority'
15:12:52 <ski> Nereid ^
15:13:10 <Nereid> ski: that didn't do anything
15:13:15 <Nereid> we want Nothing to be largest.
15:13:21 <ski> Nereid : because `Dual' is not `Opposite'
15:13:25 <Nereid> of course.
15:13:35 <geekosaur> maybe you missed the discussion on the libraries list that just ended a day or so ago
15:13:36 <edwardk> i need to make the new monoids package rely on reducers for most of its plumbing
15:13:37 <EvanR> im just going to put the whole thing in a module and hide the special code
15:13:42 <edwardk> hrmm
15:13:54 <dmwit> edwardk: Yes, where did Min/MaxPriority end up in reducers?
15:13:59 <edwardk> they didn't
15:14:03 <edwardk> since they are monoids =)
15:14:10 <dmwit> Then why is monoids deprecated?
15:14:12 <edwardk> there is a Min and Max in reducers
15:14:23 <edwardk> since those form nice semigroups
15:14:39 <edwardk> i'm thinking about undeprecating monoids and stripping it of the redundant content
15:14:42 <EvanR> > Max Nothing < Max (Just 3)
15:14:44 <lambdabot>   Not in scope: data constructor `Max'Not in scope: data constructor `Max'
15:14:46 <edwardk> and just leaving the actual monoids in there
15:14:56 <edwardk> Max is in Data.Semigroup
15:15:03 <ski> if we had `newtype Opposite a = MakeOpposite {getOpposite :: a}' with `instance Ord a => Ord (Opposite a) where compare (MakeOpposite a0) (MakeOpposite a1) = case compare a0 a1 of LT -> GT; EQ -> EQ; GT -> LT', then it'd work
15:15:09 <dmwit> Max does not provide the same functionality.
15:15:20 <ski> edwardk : perchance you already have an `Opposite' ?
15:15:22 <edwardk> you can use Option (Max a)
15:15:31 <dmwit> aha
15:15:38 <edwardk> that was the intention
15:15:47 <dmwit> Wait, no, that still doesn't work.
15:15:48 <edwardk> since Option lifts a semigroup correctly
15:15:57 <dmwit> Option (Max a) and Option (Min a) can't both have the right Ord instance.
15:16:41 <edwardk> Option makes Nothing into the unit for the monoid
15:16:54 <dmwit> I'm not interested in the monoidal structure. I want the Ord instance.
15:17:06 <edwardk> so for Option (Min a) its infinity, and Option (Max a) its negative infinity
15:17:11 <dmwit> (I mean, I am interested, since I use it, but EvanR isn't.)
15:17:23 <edwardk> i just tuned in, so i didn't see what he was doing
15:17:41 <shapr> chrisdone: Oh hey, I can't get bdo to work for whatever reason.
15:17:49 <edwardk> anyways, i'd be willing to undeprecate monoids and push a few monoids into it.
15:17:57 <edwardk> i seem to recall wanting to keep its generators around anywaysy
15:18:07 <edwardk> and then kill the rest
15:18:16 <chrisdone> shapr: lies!
15:18:17 <edwardk> Data.Monoid.Ord is usable enough to keep around
15:18:18 <dmwit> =)
15:18:20 <shapr> chrisdone: ha
15:18:24 <chrisdone> shapr: what doesn't work?
15:18:24 <coppro> edwardk: get rid of Data.Monoid?
15:18:50 <shapr> chrisdone: Oh hey, I was totally unconvinced that C-left and C-right were more useful than the emacs-native meanings for those keybindings, but I'm beginning to see the light.
15:19:04 <edwardk> coppro: no, its just that I deprecated the 'monoids' package after i wrote 'reducers'
15:19:08 <coppro> ah
15:19:09 <shapr> chrisdone: Also, is there some way to get the haskell-process to show up on the left instead of the right when I hit C-` ?
15:19:14 <edwardk> but i didn't replicate a few bits of its functionality
15:19:44 <shapr> chrisdone: I don't remember bdo details, I'll have to try it again.
15:20:19 <ski> shapr : for `backward-word' and `forward-word' ?
15:20:45 <ski> hm, no
15:21:14 * ski can't recall what `<C-left>' is bound to per default
15:21:17 <shapr> ski: Yes, that's the default binding, and what I'm used to happening when I hit C-left and C-right.
15:21:44 * ski mostly uses `M-b' and `M-f'
15:21:55 <EvanR> what combinator am i missing
15:22:04 <EvanR> if expr then Just foo else Nothing
15:22:05 <Nereid> okay cool, that kind error is fixed in 7.5.20120711
15:22:06 <Nereid> :D
15:22:08 <shapr> Though chrisdone has it bound to haskell-move-nested 1 and -1
15:22:14 <ski> shapr : so, what did chrisdone change those chords to, and in what mode ?
15:22:16 <chrisdone> shapr: C-left and C-right?
15:22:32 <shapr> chrisdone: now bound to haskell-move-nested 1 and -1
15:22:33 <chrisdone> ah. you mean for haskell-move-nested?
15:22:35 <chrisdone> right
15:22:44 <ski> shapr : hm, is that like `C-M-f' and `C-M-b' for sexprs (also cf. paredit-mode) ?
15:23:07 <shapr> I believe the hierarchy is C-f, M-f and C-M-f
15:23:14 <chrisdone> yeah, i use M-left/right which seems to do everything that C-left/right do, so C-left/right were free for me
15:23:54 <ski> are we talking about `haskell-mode' here ?
15:24:00 <chrisdone> ski: it re-indents all the lines following the current line which are indented past the current column
15:24:05 <chrisdone> yeah
15:24:08 <byorgey> EvanR: foo <$ guard expr
15:24:11 <shapr> Yes, chrisdone has made lots of changes, most of which I wildly support :-)
15:24:21 <EvanR> byorgey: nice
15:24:36 <shapr> I'm a big fan of the integration of hlint and haskell-stylish, for example.
15:24:40 <ski> chrisdone : oh
15:24:49 <shapr> Oh, I found a bug with one of those...
15:24:50 * shapr digs around
15:25:09 <chrisdone> shapr: regarding the interactive mode appearing on the left, i can write some elisp to do that, though i think it might be configurable in some deep emacs customization magic
15:25:45 <shapr> I have my 25" monitor on the left, and my 17" on the right, so I prefer to have my source code in the center.
15:25:53 <EvanR> > 45 <$ guard True :: Maybe Int
15:25:55 <lambdabot>   Just 45
15:26:02 <EvanR> > 45 <$ guard False :: Maybe Int
15:26:03 <lambdabot>   Nothing
15:26:13 <EvanR> :t (<$)
15:26:14 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
15:26:22 <EvanR> :t guard
15:26:24 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:26:56 <shapr> I should really file these bugs with patches included :-)
15:27:31 <chrisdone> shapr: also C-M-k is pretty neat. i never use it, though. but it uses the code from move-nested to kill the nested region a la C-k
15:27:48 <shapr> er.... huh?
15:27:49 * shapr tries
15:28:25 <shapr> kill-sexp?
15:28:31 * chrisdone wonders whether he put that in the example config
15:28:37 <shapr> I don't see it.
15:28:46 <chrisdone> ah, seems i didn't
15:28:53 <shapr> I'm certainly in favor of new toys though!
15:29:03 <chrisdone> (define-key haskell-mode-map (kbd "C-M-k") 'haskell-kill-nested)
15:29:58 <shapr> chrisdone: Oh, so haskell-check shouldn't save haskell-check-command, or it should have some %s or something for "current file name", because "hlint Main.hs" doesn't work when I've just switched to Display.hs and hit C-c C-v again.
15:30:12 <EvanR> hmm a data structure with fast dequeuing ----> list
15:30:33 <EvanR> a data structure with fast dequeueing and inserting somewhere in the middle?
15:30:49 <c_wraith> Data.Sequence
15:31:14 <ski> chrisdone : hm, i was wondering -- i note `RET' (same as `C-m') sends `haskell-newline-and-indent' instead of `newline', while `C-j' still sends `newline-and-indent'
15:31:35 <EvanR> c_wraith: how do you insert into a data.sequence
15:31:49 <ski> chrisdone : this is a bit awkward if i want to end a line and get to home column with no extra indentation cruft
15:31:52 <chrisdone> shapr: ah i didn't implement that hlint stuff. i will probs re-implement that for my interactive mode and put it in that buffer like a normal ghc error. no idea what stuff you're talking about. phil weaver's the one to assign the ticket to
15:32:18 <shapr> Ah, I see.
15:32:44 <c_wraith> he goes by Philip, though. :)
15:33:00 <chrisdone> ski: that's just my example bindings, though, right?
15:33:02 <ski> chrisdone : i'd suggest either having `C-m' send `newline', or (not as good imo) have `C-j' send `newline' (one could possibly have a configuration option here)
15:33:12 <shapr> c_wraith: Do you know him?
15:33:17 <c_wraith> shapr: he's a co-worker
15:33:20 <shapr> oh, neat
15:33:23 <ski> chrisdone : yes, i'm talking about the standard bindings
15:33:25 <chrisdone> c_wraith: yeah, i wondered about that. i call him phil (my dad is philip/phil) and i wondered if i was bugging him :p
15:33:30 <EvanR> c_wraith: concat splitAt ?
15:33:44 <c_wraith> EvanR: hmm, looks like that is the best you can manage
15:34:04 <c_wraith> EvanR: I think it's still better than the equivalent on a list
15:34:13 <chrisdone> ski: "standard bindings"? the bindings of emacs/haskell-mode/my examples/init.el?
15:34:24 <EvanR> a mutable linked list would be nice right about now ;)
15:34:42 <zhulikas> do type constructors need to be exported in a different way than functions?
15:34:47 <c_wraith> EvanR: no one says you can't have a list of IORefs
15:34:56 <coppro> zhulikas: Type(constructor list)
15:34:58 <EvanR> haha
15:35:01 <zhulikas> aaaa
15:35:01 <coppro> or Type(..) for all constructors
15:35:03 <zhulikas> thank you!
15:35:04 <zhulikas> :)
15:35:16 <EvanR> c_wraith: you mean deeply nested IORef (IORef (IORef ...
15:35:19 <ski> chrisdone : um, not sure ? i'm talking about what i get with a standard installation of `haskell-mode' in Debian -- possibly you aren't involved in what bindings i get there ?
15:35:38 <chrisdone> ski: at least for haskell-newline-and-indent, if you hit RET twice you will get a newline at colum 0 the second time, this was under the assumption that you'd only want to be on home for a new top-level declaration (and ofc all top-level declarations should be two-line separated…)
15:35:48 <c_wraith> EvanR: depends on if you want the links or values to be mutable, but I suppose you do mean the links.
15:35:54 <EvanR> yeah
15:36:03 <chrisdone> ski: ahhhh
15:36:54 <ski> chrisdone : "if you hit RET twice you will get a newline at colum 0 the second time" doesn't happen for me in v2.7.0, do i need a later version ?
15:37:01 <EvanR> c_wraith: so with a list, it will have to reallocate the left side each time you insert
15:37:04 <augur> aha, so ski:   you need to give a tree T such that, given   Elim(Intro(I, I', ...), A, A', ...) : P   you have   T[I/i, I'/i', ..., A/a, A'/a', ...] : P   and where T does not contain an occurance of EP (where Intro(I, I' ,...) : EP)
15:37:26 <EvanR> c_wraith: so if the list isnt that big, or you most of the time insert near the left, youre ok?
15:37:27 <c_wraith> EvanR: well, re-allocate the prefix.  (I prefer not to think about lists as left/right)
15:37:36 <EvanR> yes but thats how we write it
15:37:41 <c_wraith> EvanR: but yes, that's correct
15:37:57 <EvanR> interesting
15:38:05 <chrisdone> ski: no, sorry, i thought you were using my example bindings but as you said you're on vanilla haskell-mode from debian. i think that may depend on the indentation mode you're using, i don't see anything in haskell-mode.el that binds <return>
15:38:39 <ski> chrisdone : hm, ok. afaik i haven't changed anything here
15:38:44 <shapr> Although if you load both the vanilla haskell-mode and chrisdone's version, weird things happen.
15:39:11 <chrisdone> ski: looking in haskell-indentation.el, i see: (define-key keymap [?\r] 'haskell-newline-and-indent) so i guess you're probably on that
15:39:34 <ski> chrisdone : btw, maybe it's relevant that i indent the body of a module two spaces here ..
15:39:50 <ski> .. hm, no, if i don't do that, i get the same behaviour with `RET RET'
15:40:21 <EvanR> > span (<4) [1,2,3,4,5,6,7,8]
15:40:23 <lambdabot>   ([1,2,3],[4,5,6,7,8])
15:40:32 <chrisdone> ski: yeah, disregard the RET RET comment, that's just my personal binding for RET which i put in simple-indent.el
15:41:00 <EvanR> > (\(a,b) -> a ++ [39] ++ b) (span (<4) [1,2,3,4,5,6,7,8])
15:41:02 <ski> chrisdone : oh, sorry. i was assuming the vanilla version was your version (or at least an enough recent update of it was yours)
15:41:02 <lambdabot>   [1,2,3,39,4,5,6,7,8]
15:41:02 <chrisdone> ski: (but all the stuff me and shapr are discussing is on the github version, the debian paackage i imagine is very old)
15:41:19 <chrisdone> brb
15:41:51 <EvanR> is that sufficiently lazy
15:42:27 <EvanR> > (\(a,b) -> a ++ (39:b)) (span (<4) [1,2,3,4,5,6,7,8])
15:42:30 <lambdabot>   [1,2,3,39,4,5,6,7,8]
15:43:32 <EvanR> im always surprised when lazy evaluation results in nice list computations
15:43:36 <EvanR> maybe i shouldnt be
15:43:49 <EvanR> @src span
15:43:49 <lambdabot> span _ xs@[]                     =  (xs, xs)
15:43:50 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
15:43:50 <lambdabot>                   | otherwise    =  ([],xs)
15:43:55 <Nereid> okay, so I can't use GeneralizedNewtypeDeriving to derive a kind-polymorphic class it seems
15:44:09 <ski> EvanR : s/a ++ (39:b)/a ++ 39 : b/
15:44:16 <EvanR> ok
15:44:21 <ski> (style)
15:44:29 <c_wraith> Nereid: doesn't surprise me at all that the intersection of those is untested
15:44:31 <augur> ski: i wonder how to get recursion to be locally sound
15:44:36 <Nereid> indeed
15:44:44 <ski> @src partition
15:44:45 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
15:44:45 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
15:44:45 <lambdabot>                               | otherwise = (ts, x:fs)
15:44:58 <ski> EvanR : for fun, figure out why there's a `~' ^
15:45:19 <henux> how suitable is haskell and other functional languages for GUI programming? whats your opinion?
15:45:49 <chrisdone> henux: apparently it's kind of awful on windows but quite acceptable on linux
15:45:59 <henux> hows that?
15:46:07 <chrisdone> well the support just isn't there on windows
15:46:17 <chrisdone> for gtk+, wx, qt and such
15:46:45 <henux> but how suitable is the functional paradigm to GUI as compared to say OOP?
15:46:49 <ski> chrisdone : i was actually semi-recently trying to pull together a quick hack for changing the behaviour of `C-j' and `C-m' in `haskell-mode' (my first non-trivial emacs hack)
15:47:44 <ski> (i.e. making a semi-principled way of changing between the current behaviour and the one i prefer, and back, by calling an interactive function to toggle)
15:47:45 <Nereid> yes, simply turning on PolyKinds breaks everything.
15:48:01 <Nereid> time to file a ticket.
15:48:13 <tgeeky_> Nereid: just add explicit kind annotations
15:48:14 <chrisdone> ski: right
15:48:21 <Nereid> to what?
15:48:36 <Nereid> oh
15:48:40 <Nereid> no
15:48:47 <ski> (i'm sure there's a better way to do it, making a configuration option somehow -- but one's gotta start somewhere)
15:48:47 <tgeeky_> ask ghc for the types and kinds of things with polykinds off, and then explicitly put the kinds in
15:48:56 <Nereid> tgeeky_: that works if I don't want my class to be kind-polymorphic
15:49:47 <Nereid> which I do
15:49:55 <tgeeky_> i am always unsure of this, does kind polymorphic mean: *, * -> *, * -> * -> *, ... ?
15:49:59 <tgeeky_> all of those things?
15:50:04 <Nereid> yes
15:50:09 <chrisdone> ski: one typical way is to make a local binding of 'newline and 'newline-and-indent. the more modern way that nobody uses is to use the “advice” (defadvice) aspect-oriented approach and give advice to newline of what to do, but i don't think these simple functions support it so they just end up being rebound instead
15:50:57 <otters> do compiled binaries work on a system that doesn't have Haskell?
15:50:58 <chrisdone> ski: e.g. if you see in haskell-indentation.el there is: (set (make-local-variable 'indent-line-function) 'haskell-indentation-indent-line) -- this is their way of customizing
15:51:12 <chrisdone> otters: yup
15:51:15 <otters> neato
15:52:30 <ski> chrisdone : i've heard #emacs utter that advice is the work of the devil
15:52:35 <chrisdone> lol
15:52:39 <levi> henux: Functional reactive programming is how a lot of functional GUI stuff works.
15:53:16 <henux> whats 'reactive'?
15:53:20 <MagneticDuck> question:
15:53:31 <MagneticDuck> how would one make an application that "pressed keys" on the keyboard
15:53:32 <MagneticDuck> or
15:53:33 <ski> chrisdone : "this is their way of customizing" -- "their" being ?
15:53:35 <MagneticDuck> some other action
15:53:38 <MagneticDuck> like moving the cursor
15:53:44 <MagneticDuck> and sending out clicks
15:53:54 <MagneticDuck> is there any easy way of doing that?
15:53:58 <geekosaur> on what platform?  and with which toolkit?
15:54:00 <MagneticDuck> sending out actions?
15:54:06 <MagneticDuck> geekosaur: using linux
15:54:11 <geekosaur> but in general it's not that easy because there are significant security implications to it
15:54:14 <chrisdone> ski: authors of most of the modes i've seen in emacs
15:54:18 <Nereid> nah I won't file a bug yet.
15:54:25 <shapr> I rather like advice.
15:54:26 <geekosaur> in particular browsers and many other programs ignore synthetic events
15:54:36 * shapr asks chrisdone for haskell-mode advice :-)
15:54:45 <chrisdone> :)
15:54:45 <geekosaur> (which, for security reasons, have the sendEvent flag set in them)
15:54:56 <MagneticDuck> okay
15:55:05 <MagneticDuck> there's no good way of doing it?
15:55:18 <MagneticDuck> but the os always trusts a driver!
15:55:26 <ski> chrisdone : and `make-local-variable' is non-`defadvice' ?
15:55:27 <MagneticDuck> can't I just add a virtual "driver" that acts as a keyboard
15:55:31 <levi> henux: I don't know FRP well enough to explain it, but I know it forms the basis of several functional web-gui things and possibly some OS-specific GUI things as well.
15:55:32 <geekosaur> X11 has an extension (XTest) which lets you send events without the synthetic flag, and have a bit more control over mouse motion events and such
15:55:33 <MagneticDuck> or something else
15:55:39 <MagneticDuck> X11?
15:55:41 <geekosaur> I don;t know of a Haskell binding for it
15:55:46 <MagneticDuck> aw
15:55:55 <MagneticDuck> moving away from haskell...
15:55:55 <geekosaur> X11 is the basic window / graphics system on linux and *bsd
15:56:03 <hpaste> int80_h pasted “type class kind error” at http://hpaste.org/71736
15:56:03 <chrisdone> ski: right. defadvice is like giving before/during/after callbacks to standard functions
15:56:05 <MagneticDuck> on linux, is there any simple way of doing that with scripts?
15:56:19 <henux> levi: web gui is probably pretty hand with functional since it just outputs html
15:56:20 <chrisdone> ski: (kind of CLOSy i suppose…)
15:56:23 <ski> MagneticDuck : maybe use `screen' ? -- istr there's something called `expect' as well
15:56:25 <henux> handy
15:56:30 <geekosaur> not really; I was talking not ao much about Haskell as in general
15:56:42 <geekosaur> it's not *supposed* to be easy for random programs to simulate keyclicks and such
15:56:53 <MagneticDuck> okay
15:57:00 <geekosaur> think about what a malicious browser javascript could do with that ability
15:57:05 <MagneticDuck> yeah
15:57:24 <chrisdone> ski: most if not all modes i've seen consist of a function that clears all local variables of the buffer and then binds its own make-local-variable's for variables and functions that standard commands and keybindings use/call
15:57:24 <MagneticDuck> but if you had to do it
15:57:25 <geekosaur> (they already * can* do it to some extent but only within the browser)
15:57:29 <MagneticDuck> how would you?
15:57:50 <geekosaur> I already told you
15:57:51 <levi> henux: That's not how they work, though.  It generally involves javascript and asynchronous events.
15:57:55 <MagneticDuck> X11
15:57:56 <MagneticDuck> okay
15:58:09 <geekosaur> you recorded the least interesting and informative part of it
15:58:16 <MagneticDuck> >_<
15:58:18 <geekosaur> perhaps you should not be thinking about doing this
15:58:18 <MagneticDuck> lol
15:58:23 <geekosaur> XTest extension
15:58:25 <geekosaur> XSendEvent()
15:58:30 <MagneticDuck> okay
15:58:33 <ski> chrisdone : ok. so far i've only peeked a bit at the source of modes, not understanding much
15:58:47 <enigmuri_> what's the most concise way to have a function loop through a procedure a set number of times no matter what the arguments are?
15:58:49 <MagneticDuck> well, XTest is from X11
15:58:56 <MagneticDuck> that's kind of what I meant
15:59:32 <MagneticDuck> ski: "screen"? Where how what?
15:59:58 <chrisdone> (the emacs manual feels a bit mysterious about it to me, it's quick to encourage you to use mode generating helper macros and derive from other modes rather than explaining in concrete terms what a mode function should do)
16:00:19 <ski> MagneticDuck : GNU Screen <http://www.gnu.org/software/screen/> ?
16:00:33 <ski> very useful program, for what it does
16:00:46 <chrisdone> enigmuri_: in a hurry i'll start with forM_ [i..x] $ \i -> hello foo bar zot
16:00:50 <levi> henux: http://www.haskell.org/haskellwiki/Functional_Reactive_Programming
16:01:14 <ski> i was mentioning it above because it's not very hard to send characters to a program programmatically (but also be able to interact with the program yourself)
16:01:23 <ski> not sure if it helps for what you want to do
16:02:22 <ski> chrisdone : ok. i suppose you should probably be someone like Olin Shivers, or at least ask him, before attempting it
16:02:28 <chrisdone> ski: i'm sure once you've done that you will be writing more and more elisp to scratch your itches :p
16:02:59 <enigmuri_> say i want to find to some of (Int^i)/(i!) for i = 1 -> 1000. i feel like there's a one-line way to do that but i'm very new to haskell. any ideas?
16:03:00 <ski> chrisdone : yeah, i'm hoping so -- but initially it's a bit hard to get started, finding ways to progress
16:03:08 <geekosaur> note that screen/tmux only works for terminalbased programs
16:04:19 <levi> enigmuri_: Looks like a list comprehension
16:04:23 <ski> enigmuri_ : you want to compute `n^i / i!' for each `i' between `1' and `1000' ?
16:04:38 <enigmuri_> yeah
16:04:57 <enigmuri_> i was thinking of mapping it to a list i generated with [1..1000]
16:05:07 <levi> [ (your equation) | i <- [1..1000] ]
16:05:42 <Anpheus_> Dear #Haskell: If I am parsing an input stream from a conduit, and I want to carry some state over from one "chunk" to the next in the conduit or delay processing a bit at the end because I need more information before I send that on to downstream, how do I do that in the current version of Conduit?
16:05:46 <nand`> > let fac n = product [1..n] in map ((n^) / fac) [1..1000]
16:05:48 <lambdabot>   [n * recip (1 * 1),n * n * recip (1 * 1 * 2),n * n * n * recip (1 * 1 * 2 *...
16:05:52 <nand`> oh
16:05:55 <ski> > let factorial n = product [1 .. n] in [3^i / fromIntegral (factorial i) | i <- [1 .. 1000]]
16:05:57 <lambdabot>   [3.0,4.5,4.5,3.375,2.025,1.0125,0.43392857142857144,0.1627232142857143,5.42...
16:06:01 <nand`> > let fac n = product [1..n]; n = 5 in map ((n^) / fac) [1..1000]
16:06:02 <lambdabot>   Ambiguous type variable `b' in the constraints:
16:06:02 <lambdabot>    `GHC.Real.Integral b'
16:06:02 <lambdabot>   ...
16:06:15 <nand`> > let fac n = product [1..n]; n = 5 in map ((n**) / fac) [1..1000]
16:06:16 <lambdabot>   [5.0,12.5,20.833333333333332,26.041666666666664,26.041666666666668,21.70138...
16:06:28 <enigmuri_> thanks
16:07:38 <Anpheus_> I know in Conduit 0.3 it was fairly easy using the State helpers but I'm kind of at a loss with ResourceT in Conduit 0.4
16:07:47 <ski> enigmuri_ : you can also use `map', yes
16:08:01 <ski> > let factorial n = product [1 .. n] in map (\i -> 3^i / fromIntegral (factorial i)) [1 .. 1000]
16:08:04 <lambdabot>   [3.0,4.5,4.5,3.375,2.025,1.0125,0.43392857142857144,0.1627232142857143,5.42...
16:08:26 <ski> > let factorial n = product [1 .. n]; myFunction i = 3^i / fromIntegral (factorial i) in map myFunction [1 .. 1000]
16:08:26 <henux> levi: thanks for that link
16:08:27 <chrisdone> > let (!) = product . enumFromTo 1 in (4!) -- :-)
16:08:27 <lambdabot>   [3.0,4.5,4.5,3.375,2.025,1.0125,0.43392857142857144,0.1627232142857143,5.42...
16:08:29 <lambdabot>   24
16:08:38 <nand`> so why isn't factorial in the Prelude yet?
16:08:39 <ski> (:
16:08:48 <nand`> or at least in lambdabot
16:09:21 <nand`> chrisdone: lambdabot has -XPostfixOperators?
16:09:26 <enigmuri_> http://bpaste.net/show/BvBsOic0uQ9IPciAuA1M/
16:09:32 <ski> we'd have to use some other example when explaining recursion to newbies, then
16:09:37 <enigmuri_> ski, what about that code is invalid?
16:09:42 <nand`> enigmuri_: Int is not a value
16:09:45 <chrisdone> nand`: yup
16:09:56 <ski> @hpaste
16:09:56 <nand`> it's not a valid variable either
16:09:56 <lambdabot> Haskell pastebin: http://hpaste.org/
16:10:04 <enigmuri_> nand', what do i use to rever to the argument?
16:10:15 <nand`> enigmuri_: you should be fine if you just change the ‘I’ to an ‘i’
16:10:33 <ski> enigmuri_ : just fyi, if you use that nice paste site here, it'll auto-announce the paste URL, you'll get syntax highlighting, and `hint' will run and comment on some style things
16:10:39 <enigmuri_> oh, so i can use any arbitrary name to refer to the variable?
16:10:48 <ski> yes
16:10:55 <nand`> enigmuri_: more or less, there are rules on just how arbitrary this can be
16:11:15 <ski> enigmuri_ : though variable names have to start with a lower case letter (or `_')
16:11:17 <nand`> eg. must start with a lower case character or _
16:11:17 <enigmuri_> nice, thanks
16:11:31 <enigmuri_> i love haskell :P it's my third day with it, but i really really like it
16:12:01 <ski> enigmuri_ : you also need to replace `(factorial i)' with `fromIntegral (factorial i)', to convert from `Int' to `Double'
16:12:01 <nand`> enigmuri_: I'm just detecting some possible confusion here with the way you used ‘Int’, which is a type -- the type of something doesn't have to be given in the name, the type signature at the top already tells you what type that argument has to be
16:12:29 <ski> enigmuri_ : yeah, Haskell is great fun :)
16:12:46 <nand`> it's not like some notations where you have to do λ(x:Int) → ...
16:13:35 <hpaste> enigmuri_ pasted “eExponent” at http://hpaste.org/71738
16:14:04 <enigmuri_> i'm having trouble returning a Double
16:14:09 <enigmuri_> ah, thanks ski
16:14:11 <nand`> :t fromIntegral
16:14:12 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:16:35 <hpaste> enigmuri_ pasted “eExponent” at http://hpaste.org/71739
16:16:45 <enigmuri_> still getting a type error with the Double
16:16:50 <hpaste> ski annotated “eExponent” with “using `fromIntegral'” at http://hpaste.org/71738#a71740
16:16:54 <ski> enigmuri_ ^
16:17:42 <ski> enigmuri_ : i changed the input to `eExponent' from `Int' to `Double', so now `n' is a `Double'
16:17:47 <nand`> :t (^)
16:17:48 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
16:18:02 <ski> then in `n ^ i', `i' is still an `Int', while the whole is a `Double'
16:18:03 <nand`> of course you could just put fromIntegral on both sides
16:18:09 <ski> yes
16:18:18 <nand`> :t (^^)
16:18:20 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
16:18:24 <nand`> :t (**)
16:18:25 <lambdabot> forall a. (Floating a) => a -> a -> a
16:19:07 <ParahSailin> is it possible to create data types in ghci?
16:19:15 <ski> `n ^ i' is for when `i' is "nonnegative", `n ^^ i' allows negative exponent (and requires division by `n'), `n ** i' allows fractional `i'
16:19:32 <ski> ParahSailin : in very recent versions, yes
16:19:50 <nand`> 7.4.x and above iirc
16:20:07 <ParahSailin> i have to use old version because glibc version is only 2.5
16:20:25 <ParahSailin> whats the minimal way to define a type and load it?
16:20:35 <enigmuri_> i'm getting a parse error on the | now
16:21:44 <nand`> ParahSailin: define it in a file and :l that in GHCi
16:21:47 <ski> ParahSailin : write a file `Foo.hs' containing `data Blah = ...', and `:load Foo' ?
16:22:36 <ski> enigmuri_ : how does your list comprehension look like now ?
16:22:54 <ski> oh, i just noticed another problem in the paste :)
16:23:16 * ski will wait for enigmuri_ to respond
16:23:48 <hpaste> enigmuri_ annotated “eExponent” with “eExponent (annotation)” at http://hpaste.org/71738#a71742
16:24:02 <nand`> enigmuri_: you forgot the outer brackets
16:24:08 <enigmuri_> oh, i removed them
16:24:20 <enigmuri_> because it was giving me some error about redundant brackets
16:24:32 <nand`> well not those
16:24:34 <enigmuri_> oh, are they only supposed to be around the expression on the right?
16:24:38 <ski> enigmuri_ : the problem i noted was : the latter clause for `eExponent' is returning a list, but the former isn't
16:24:41 <enigmuri_> yeah, hold on
16:24:49 <nand`> a list comprehension always has this form: [ x | y ]
16:24:50 <ski> enigmuri_ : do you want to return a list of numbers, or a single number (which ?) ?
16:24:59 <enigmuri_> a single number
16:25:23 <ski> so, what do you want to do with the list of numbers `x^i / i!' for each `i' between `1' and `1000' ?
16:25:26 <ski> sum them ?
16:25:27 <enigmuri_> the sum of (x^i)/(i!) for all i's 1 -> 1000
16:25:30 <ski> ok
16:25:33 <nand`> enigmuri_: so add a ‘sum’
16:25:35 <nand`> :P
16:25:43 <ski>   eExponent n = sum [... | ...]
16:25:45 <nand`> sum [ foo | i <- [1..1000]]
16:26:11 <enigmuri_> thanks, that's what i had though, i believe
16:26:19 <enigmuri_> i'll put everything back the way it was and check
16:28:53 <ski> enigmuri_ : also, are you sure you don't want to start at `0' instead of `1' ?
16:29:08 <hpaste> enigmuri_ annotated “eExponent” with “eExponent (annotation) (annotation)” at http://hpaste.org/71738#a71743
16:29:20 <ski> enigmuri_ : if you do that, then you can remove the `eExponent 0 = 1' line (since the other line will compute the same result)
16:29:30 <enigmuri_> oh, that's a good point
16:29:41 <ski> > let factorial n = product [1 .. n] in sum [3^i / fromIntegral (factorial i) | i <- [1 .. 10]]
16:29:42 <lambdabot>   19.079665178571425
16:29:42 <enigmuri_> the above code is getting a type error
16:29:45 <ski> > exp 3
16:29:46 <lambdabot>   20.085536923187668
16:29:49 <ski> > let factorial n = product [1 .. n] in sum [3^i / fromIntegral (factorial i) | i <- [0 .. 10]]
16:29:50 <lambdabot>   20.079665178571425
16:30:01 <ski> it seems to me that you probably want to start at `0'
16:30:04 <ski> > let factorial n = product [1 .. n] in sum [0^i / fromIntegral (factorial i) | i <- [0 .. 10]]
16:30:05 <lambdabot>   1.0
16:30:36 <ski> enigmuri_ : type error in that paste because you forgot to write `sum' before the list comprehension
16:31:09 <augur> ski: i wonder if its possible to be locally sound even if you use the eliminated propositon but in a deeper place
16:31:11 <enigmuri_> by the way, pretty cool equation, right? it calculates an exponent of e using only real number exponents and factorials
16:31:26 <enigmuri_> DOH
16:31:32 <enigmuri_> what a stupid mistake lol
16:31:32 <augur> ski: i bet tere are conditions for it being locally sound, e.g. passing agda's termination checker
16:32:57 <ski> augur : "you need to give a tree T such that, ..." -- sounds ok
16:33:04 <ski> "i wonder how to get recursion to be locally sound" -- not sure
16:33:36 <ski> not sure what you mean by "use the eliminated propositon but in a deeper place"
16:34:02 <ski> enigmuri_ : also,i think you'll find that you'll easily get `NaN' if you don't lower `1000' somewhat
16:34:13 <ski> > product [1 .. 1000]
16:34:14 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
16:34:24 <enigmuri_> ski: not if the function works properly (it isn't at the moment)
16:34:29 <ski> > let factorial n = product [1 .. n] in sum [3^i / fromIntegral (factorial i) | i <- [0 .. 1000]]
16:34:30 <lambdabot>   NaN
16:34:46 <ski> > length (show (product [1 .. 1000]))
16:34:47 <enigmuri_> the idea is that as i increases, the marginal value decreases
16:34:47 <lambdabot>   2568
16:34:52 <ski> yes
16:35:03 <ski> but the factorials get larger
16:35:04 <enigmuri_> so at the moment the function's logic is somehow wrong
16:35:10 <ski> (and quickly !)
16:35:10 <enigmuri_> ski, exactly
16:35:12 <augur> ski: well, like consider a rule like fix:   [A]x ... A ===fix[x] A
16:35:19 <enigmuri_> https://github.com/plsql/Python-Snippets/blob/master/EExponents.py
16:35:24 <ski> enigmuri_ : possibly you could factor in some way
16:35:29 <enigmuri_> thats the corresponding python code ^
16:35:41 <augur> ski: that takes a hypothetical proof of A from the hypothesis x : A, and proves A by binding x
16:35:53 <augur> ski: thats the intro rule, anyway.
16:36:04 <ski> enigmuri_ : "the function's logic is somehow wrong" -- do you mean getting `NaN' ?
16:36:36 <ski> augur : where `fix[x] A' is a proposition ?
16:36:37 <Nereid> my head is exploding
16:37:00 <augur> ski: no, where fix[x] is the inference rule. its just like ->I[x] only it doesnt change the type
16:37:40 <enigmuri_> ski: i mean that e^4 does not equal Infinity, so the math is somehow off
16:37:47 <augur> ski: we should also have an elimination rule   [A]x ...D... A ===fix[x] A ===unfix A   =>   [A]x ...D... A ===fix[x] ...D... A
16:38:03 <ski> @ghc
16:38:03 <lambdabot> ghc says: Ambiguous constraint
16:38:08 <ski> @ghc
16:38:08 <lambdabot> ghc says: Duplicate instance declarations
16:38:12 <augur> ski: essentially this is just   fix f = f (fix f)   but using hypothetical proofs instead
16:38:15 <ski> @quote head.explo
16:38:16 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
16:38:37 <ski> hm, i thought there were some GHC error message re that
16:38:52 <zhulikas> any library with implemented bezier curves?
16:39:17 <ski> enigmuri_ : yes, i suspect that's more or less ordinary floating-point rounding errors
16:39:18 <zhulikas> I mean algorithms for it.
16:39:26 <ski> s/yes/well/
16:39:44 <augur> ski: we could make it HOAS-y using the intro    A -> A ===fix A   and the elim   [A -> A]f ... A ===unfix A
16:40:09 <BMeph> How do you find the next-to-least fixed point of an equation? ;)
16:40:18 <augur> er, no sorry, just   A ===unfix A   i think
16:40:30 <ski> augur : shouldn't `unfix' take two `A's ?
16:40:52 <augur> ski: no, its just a wrapper, right
16:41:12 <ski> afaiu, you're wanting to have something like `D = D -> D'
16:41:16 <augur> like   data Fix a = Fix {unFix :: a -> a}
16:41:30 <ski> so from `[D]^x ... D' you can derive `D'
16:41:32 <ski> yes
16:41:41 <ski> well, almost
16:41:47 <augur> yeah, almost
16:41:48 <augur> not quite
16:41:52 <ski> there `Fix a' is the proposition, not `a'
16:42:03 <ski>   data D = In {out :: D -> D}
16:42:08 <ski>   out :: D -> D -> D
16:42:29 <augur> we'd have the simplification    ...D... A -> A ===fix A ===unfix A   =>   (...D... A -> A) (...D... A -> A ===fix A) ===->E A
16:42:37 <ski> and you're just claiming this in fact works for *any* proposition `A'
16:42:38 <augur> which is more precisely what fix in haskell does
16:42:47 <ski> (which of course makes the logic inconsistent, but what the heck)
16:42:48 <augur> or maybe there wouldn't even be an unfix
16:42:54 <augur> you'd just have a simplification rule straight off
16:42:55 <augur> i dunno
16:43:21 <augur> ...D... A -> A ===fix A   =>   (...D... A -> A) (...D... A -> A ===fix A) ===->E A
16:43:35 <ski> hm, i suppose if you're after a fixed-point combinator thing, then there wouldn't be an intro rule, not an elim rule
16:43:52 <ski> (just a single rule, which is neither intro nor elim)
16:44:09 <augur> yeah, thats sort of why im avoiding I and E on fix here :)
16:44:13 <augur> i dont really know what this gadget is
16:44:21 <ski> BMeph : yeah, i'd like to know that as well :)
16:44:36 <augur> but is this kind of thing locally sound? i suspect it is if it passes agdas termination checker
16:44:36 <ski> BMeph : also, finding minimal values would be nice
16:44:53 <EvanR> > return 3 :: Id Int
16:44:54 <lambdabot>   Not in scope: type constructor or class `Id'
16:44:58 <augur> but there might be other cases where its locally sound too
16:44:59 <EvanR> > return 3 :: Identity Int
16:45:01 <lambdabot>   No instance for (GHC.Show.Show
16:45:01 <lambdabot>                     (Data.Functor.Identity.I...
16:45:24 <ski> augur : i'm not sure what "locally sound" would mean here
16:45:32 <augur> ski: well, same thing it always means!
16:45:50 <augur> that you cant conclude more USING fix than you could without using fix
16:46:01 <ski> well, but you *can*
16:46:11 <augur> if the proofs can be infinitely long, sure
16:46:14 <ski> (at least in the absense of some other inconsistent rules)
16:46:26 <augur> but if proofs must be finite then fix should always be removable
16:46:39 <ski> hmph, i suppose with infinite proofs, it might work
16:46:41 <augur> well
16:46:48 <coppro> if you have infinite proofs, you get a lot more nice things
16:47:05 <coppro> like completeness
16:47:07 <ski> are we talking infinitely wide or infintely deep, here ?
16:47:11 <augur> removable if the simplification is decreasing in size, right
16:47:14 <hpaste> enigmuri_ annotated “eExponent” with “eExponent (annotation) (annotation) (annotation)” at http://hpaste.org/71738#a71746
16:47:16 <augur> ski: infinitely deep
16:47:23 <mm_freak> what is an infinite proof?  corecursion?
16:47:30 <mm_freak> (coinduction)
16:47:31 <enigmuri_> i hate to keep asking, but can anyone tell me what's wrong with that?
16:47:41 <augur> if the proof is decreasing in size, then it should be ok to use fix
16:47:48 <ski> enigmuri_ : i still think you ought to start at `0' instead of `1'
16:47:50 <enigmuri_> it seems like what i'm looking for, but it returns NaN for 0 and Infinity for everything else
16:48:00 <enigmuri_> ski, you're right
16:48:12 <enigmuri_> that should make the value lower, though, not Infinity
16:48:13 <ski> enigmuri_ : also, as i said, i think `1000' might be too large
16:48:33 <ski> enigmuri_ : it might be nice if one could adjust the upper bound depending on `n' ..
16:48:34 <mm_freak> eExponent n = sum [ (n^i)/fromIntegral(factorial i) | i <- [1..1000] ]
16:48:41 <mm_freak> of what order is 'n' here?
16:48:44 <Nereid> aaaaaaaaaaa
16:48:56 <Nereid> why can't I have partially applied type synonym constructors
16:48:59 <enigmuri_> ski: the whole idea is that it adds everything from one to infinity
16:49:06 <mm_freak> because even with n = 2 that will quickly exhaust the precision of Double
16:49:18 <ski> augur : i don't see how to remove `fix' in finite proofs
16:49:21 <mm_freak> especially with (^) instead of (**)
16:49:40 <mm_freak> Nereid: you can, but not everywhere, particularly not in instances
16:49:47 <Nereid> yes, I really want them in instances.
16:49:57 <enigmuri_> ski: the equation is e^n = sum ( (n^i)/(i!) ) for i = 0 -> Infinity
16:50:07 <mm_freak> Nereid: thought so…  that's impossible, because it would give you real type functions
16:50:22 <ski> Nereid : "why can't I ..." -- the direct reason is to avoid nontermination in the type checker
16:50:37 <ski> Nereid : it might be possible to alleviate that restriction somewhat, though
16:50:41 <enigmuri_> so if i Really wanted to make the equation accurate, I would make it i <- [0..Infinity], or as close to that as possible
16:50:58 <ski> enigmuri_ : yes, i know
16:51:00 <mm_freak> enigmuri_: no, that would actually be worse
16:51:20 <mm_freak> enigmuri_: perhaps Double is not what you want
16:51:26 <augur> ski: well, it would happen because of how other rules simplify, right
16:51:29 <Nereid> I'm stuck in a situation where I can't use newtypes.
16:51:36 <enigmuri_> mm_freak: the values decrease asymptotically toward zero as i increases
16:51:39 <Nereid> let's paste things.
16:51:46 <mm_freak> Nereid: you can always use newtypes…  just paste =)
16:51:56 <ski> > sum [3 ^ i / fromIntegral (product [1 .. i]) | i <- [0 ..]] :: CReal  -- :)
16:52:00 <lambdabot>   mueval-core: Time limit exceeded
16:52:01 <mm_freak> enigmuri_: the problem is the n^i term
16:52:05 <enigmuri_> mm_freak: what datatype would I want? exponents of e are almost always floats
16:52:09 <augur> ski: like, if you have a n or-elim and the fix only occurs in one branch, then as the proof simplifies, you might end up taken the non-recursive branch so the whole fix recurrence vanishes in simplification
16:52:18 <enigmuri_> mm_freak: how so?
16:52:41 <mm_freak> enigmuri_: i'm sure you want Double, but you'll want to avoid exponentiations of that order…  and at least use (**), not (^), because (^) is in fact implemented by square-and-multiply
16:52:46 <augur> ski: think of factorial using fix -- it terminates because eventually the base case is chosen
16:53:09 <EvanR> if i have a bunch of newtypes wrapping the same type X, how do i easily get them to share a common show instance for X
16:53:28 <mm_freak> enigmuri_: try to find a more numerically stable formula
16:53:39 <ski> augur : yes
16:53:57 <ski> but i don't see the general case
16:54:06 <mm_freak> EvanR: instance Show T1 where show = myShow . getT1
16:54:15 <mm_freak> same for T2, T3 and so on
16:54:24 <augur> ski: oh i dont think it will work in general
16:54:28 <EvanR> heh...
16:54:29 <mm_freak> EvanR: or, if possible, use deriving
16:54:33 * BMeph prefers the "numerically stable" formula of: [1; 2n, 1]
16:54:42 <EvanR> mm_freak: well X doesnt have a show instance by default
16:54:54 <mm_freak> EvanR: and it doesn't make sense to write one?
16:54:59 <enigmuri_> mm_freak: changing ^ to ** gave me a type error
16:55:09 <mm_freak> enigmuri_: look at the type of (**)
16:55:12 <mm_freak> :t (**)
16:55:15 <lambdabot> forall a. (Floating a) => a -> a -> a
16:55:19 <EvanR> mm_freak: it does for me
16:55:24 <augur> ski: what i mean is, i think if you can prove that all proofs using fix have this property of simplifying to finite proofs, then fix is locally sound
16:55:27 * BMeph meant that he prefers the continued fraction representation of [1; 0, 1, 1, 2, 1, 1, 4, 1, 1, 6, 1,..]
16:55:29 <EvanR> because i want to show all these new types the same way
16:55:45 <EvanR> which is not the default for X, which is nothing
16:55:57 <enigmuri_> mm_freak: if it returns an int, why would I want to use it?
16:56:29 <augur> ski: i doubt there are any models for that tho. i would wager that what you need is more like proving also that if a proof is infinite then it's equivalent to \bot
16:56:33 <ski>   n^0 / 0! + n^1 / 1! + n^2 / 2! + n^3 / 3! + ...  =  1 + n / 1 * (1 + n / 2 * (1 + n / 3 * (1 + ...)))
16:56:53 <ski> enigmuri_ : mayhaps a rewriting like ^ could be useful to avoid overflow or bad rounding, not sure
16:57:39 <mm_freak> enigmuri_: (**) uses the actual machine instruction to perform exponentiation, whereas (^) uses repeated multiplication
16:57:47 <mm_freak> so (**) is about as stable as you can get with Double
16:58:06 <enigmuri_> hmm
16:58:13 <enigmuri_> im getting sick of this :P
16:58:28 <mm_freak> welcome to the wonderful world of floating point calculation =)
16:58:33 <hpaste> Nereid pasted “what do I do” at http://hpaste.org/71748
16:58:35 <Nereid> ^
16:58:37 <ski> EvanR : "if i have a bunch of newtypes wrapping the same type X, how do i easily get them to share a common show instance for X" -- this is arguably evil
16:58:53 <enigmuri_> writing the simplest little program as a newb leads to this bottomless fractal of bugs that I don't even understand and am therefore helpless in solving
16:59:11 <EvanR> ski: why?
16:59:19 <ski> BMeph : heh, was going to ask whether that was a spectral fraction
16:59:19 <mm_freak> newtype I cat a b = I { unI :: forall i. cat (a i) (b i) }
16:59:21 <mm_freak> huh?
16:59:24 <Nereid> yeah
16:59:28 <mm_freak> Nereid: what's that supposed to be?
16:59:40 <Nereid> I (->) a b is isomorphic to forall i. a i -> b i
16:59:45 <ski> EvanR : because (imo) `show' is for constructing a Haskell expression that will evaluate to the given value
17:00:00 <EvanR> ok, then a common 'print function'
17:00:06 <mm_freak> Nereid: got that, but what's the point?
17:00:33 <EvanR> X -> String
17:00:36 <ski> EvanR : you could easily define your own `displayFoo' or `printFoo' function, possibly with a little custom type class, if you want to
17:00:38 <mm_freak> enigmuri_: the bugs aren't related to haskell…  you would have run into them in every other language
17:00:47 <mm_freak> with this formula that is
17:00:52 <Nereid> mm_freak: well.
17:00:53 <EvanR> ski: yeah but not easily have it apply to all the new types over X
17:01:05 <Nereid> I dunno, I'm just playing around.
17:01:10 <Nereid> but I mean
17:01:13 <enigmuri_> mm_freak, i n a way they are, because I wrote this with little to no issue in Pytho
17:01:14 <enigmuri_> n
17:01:14 <ski> enigmuri_ : if you want to change to `**', you'll have to change `n ^ i' to `n *
17:01:17 <ski> er
17:01:18 <mm_freak> Nereid: the type doesn't appear to be useful
17:01:20 <ski> enigmuri_ : if you want to change to `**', you'll have to change `n ^ i' to `n ** fromIntegral i'
17:01:26 <Nereid> mm_freak: but it is, look at index-core
17:01:35 <enigmuri_> https://github.com/plsql/Python-Snippets/blob/master/EExponents.py << same functions, mm_freak
17:01:54 <ski> @where floating-point
17:01:55 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
17:01:55 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
17:01:59 <mm_freak> Nereid: ok, what's the problem there?  i don't see any type synonyms
17:02:11 <Nereid> I can't turn those newtypes into types.
17:02:12 <mm_freak> enigmuri_: again, this is most likely related to (^)
17:02:22 <mm_freak> enigmuri_: (^) may not be what you expect
17:02:31 <Nereid> because then I can't make any instances for I cat or L f
17:02:34 <enigmuri_> ski: do i have to do that even if I'm already using fromIntegral in the list generator
17:02:36 <enigmuri_> ?
17:02:38 <mm_freak> it's the generic square and multiply algorithm, which is very unstable for Double
17:03:02 <mm_freak> enigmuri_: yes
17:03:22 <mm_freak> you apply fromIntegral to the result of factorial, not to 'i' itself
17:03:34 <mm_freak> 'i' is used as an integer for factorial, then used as a Double for (^)
17:03:46 <mm_freak> let it be an integer and fromIntegral it
17:03:51 <mm_freak> for (**)
17:03:52 <Nereid> mm_freak: now to me, f (a i) and L f a i are "the same type", so in the bottom instance, fmap f and g should be "the same"
17:03:59 <ski> EvanR : perhaps there'd be a case for an operation in `Show' which is like `show' except it doesn't show `newtype' constructors
17:04:37 <mm_freak> Nereid: note that the notion of "the same" is up to isomorphism in haskell
17:04:40 <EvanR> ski: showing the newtype would be fine
17:04:48 <EvanR> but X has no show instance
17:04:51 <Nereid> I mean they have the same internal representation.,
17:04:55 <mm_freak> and you can write an instance for X, but not for Y, even though X and Y are "the same"
17:04:56 <EvanR> deriving show would work
17:05:08 <EvanR> wouldnt
17:05:12 <ski> EvanR : i thought what you wanted to avoid was showing the `newtype' constructors
17:05:21 <ski> EvanR : oh, ok
17:05:24 <EvanR> no i just want something to show
17:05:39 <ski> EvanR : is it possible to have an `Show X' instance ?
17:05:45 <enigmuri_> still same issue after the ** change
17:05:49 <EvanR> yeah but it wouldnt make sense for X in general
17:05:56 <enigmuri_> giving me NaN for 0 and Infinity for everything else
17:06:07 <EvanR> i guess i could newtype X first to Y
17:06:12 <EvanR> then all my newtypes would wrap Y
17:06:17 <EvanR> and have a show for just Y?
17:06:36 <BMeph> " If I were king, programmers would be required to pass a class on numerical analysis before being allowed to use floats." (Brian Hurt, enfranchisedmind.com) -- preaching to the Choir, dude.
17:06:37 <mm_freak> Nereid: evne though you can make the type system turing-complete you can't write an instance for partially applied type synonyms…  this would be difficult to implement and turn the type system into a full-blown programming language
17:06:37 <EvanR> getting the value out would be two unwraps
17:06:47 <Nereid> sure, fine
17:06:57 <Nereid> but can I get g from fmap f?
17:06:58 <levi> enigmuri_: If you leave off the 'sum', you'll see what the values look like. They get very small, then become 0.0, then become NaN.
17:06:59 <Nereid> somehow?
17:07:05 <EvanR> now im hungry for burritos
17:07:16 <EvanR> newtype burritos
17:07:18 <enigmuri_> levi: ah, thanks
17:07:27 <Nereid> I can't even cheat with unsafeCoerce because that gives me a kind error
17:07:27 <enigmuri_> so if i prune out the NaNs should it work?
17:08:06 <mm_freak> > 0 + 0/0
17:08:08 <lambdabot>   NaN
17:08:24 <mm_freak> enigmuri_: likely
17:08:29 <mm_freak> > isNaN (0/0)
17:08:30 <lambdabot>   True
17:08:47 <ski> EvanR : if you have `newtype T1 = MkT1 X', then you can say `instance Show T1 where showsPrec p (MkT1 x) = showParen (p >= 10) $ showString "MkT1 " . myShowX_1 x'
17:09:01 <mm_freak> :t sum . filter (not . isNaN)
17:09:02 <lambdabot> forall a. (RealFloat a) => [a] -> a
17:09:14 <mm_freak> @ enigmuri_
17:09:16 <EvanR> ski: copy pasta for all the new types?
17:09:38 <ski> EvanR : where `myShowX_1 :: X -> ShowS' is your function for showing an `X' in your first way -- you can pass `p' to it as well, if you need to
17:09:51 <ski> EvanR : aye
17:09:55 <EvanR> blarg
17:09:59 <EvanR> i mean i knew that was possible ;)
17:11:22 <enigmuri_> having to prune those out ruins the algorithm though :/
17:11:29 <enigmuri_> well, not that much i guess
17:11:54 <enigmuri_> but part of the point of writing these is to emulate the logic of fast and elegant algorithms
17:11:57 <Nereid> now if I had maps like L :: cat (f (a i)) -> cat (L f a i), I could do this
17:12:55 <Nereid> er
17:12:58 <ski> mm_freak : "note that the notion of \"the same\" is up to isomorphism in haskell" -- problems appear when the `newtype' has a different instance
17:13:01 <Nereid> L :: cat (f (a i)) (L f a i)
17:13:02 <levi> enigmuri_: You can do takeWhile (> 0.0), since there's no point in continuing once you hit the limit of precision.
17:13:27 <levi> enigmuri_: You can then also change i <- [0..1000] to i <- [0..]
17:13:34 <mm_freak> Nereid: unfortunately your code is too abstract to me right now…  so i can't really give useful hints
17:13:38 <Nereid> :
17:13:38 <Nereid> :V
17:13:49 <Nereid> I have an idea.
17:13:54 <Nereid> let me see if it works.
17:14:08 <ski> EvanR : "i guess i could newtype X first to Y","then all my newtypes would wrap Y","and have a show for just Y?" -- i thought you wanted different behaviour for each of the instances of `Show for' `T1',`T2',&c.
17:14:14 <augur> ski: i think local completeness is similarly formal
17:14:26 <mm_freak> ski: right now the newtype is the only thing that has an instance in Nereid's cae
17:14:29 <EvanR> ski: no, i want generally the same behavior, X -> String
17:14:29 <mm_freak> case
17:14:40 <EvanR> if theres a new type around that String, fine whatever
17:15:20 <augur> ski: if you have a proof D : P, you want to give a proof template T that has the rough shape   Intro(Elim(P, A, A', ...), I', ...) : P
17:15:50 <levi> enigmuri_: It still has the issue of hitting Infinity if you give it a moderately sized input, though.
17:15:53 <EvanR> id rather not have two layers of newtypes wrappers though :(
17:16:06 <augur> ski: also, pfenning mentions that defining simplifications in terms of other inference rules is risking nasty interactions, so that's also easy to describe formally
17:16:10 <enigmuri_> levi: thanks for that. where exactly would i insert the takeWhile?
17:16:16 <ski> Nereid : hm, possibly you can start with the identity `cat (f (a i)) (f (a i))', and then manage to rewrite the `f (a i)' there to `L f a i'
17:16:31 <Nereid> I'm trying :V
17:16:57 <mm_freak> enigmuri_: the thing is that python is cheating, which comes to your advantage here
17:17:03 <mm_freak> python:
17:17:05 <mm_freak> >>> 2**100000 / 2**100000
17:17:05 <mm_freak> 1.0
17:17:17 <Nereid> well, I'm trying to make a typeclass for a category that gives me cat (f (a i)) (L f a i) and its inverse.
17:17:19 <mm_freak> haskell:
17:17:24 <mm_freak> > > 2 ** 100000 / 2 ** 100000
17:17:26 <Nereid> and instances for I cat
17:17:26 <lambdabot>   <no location info>: parse error on input `>'
17:17:28 <mm_freak> > 2 ** 100000 / 2 ** 100000
17:17:31 <lambdabot>   mueval-core: Time limit exceeded
17:17:35 <mm_freak> huh?
17:17:41 <mm_freak> well, the result is NaN
17:17:44 <augur> actually, ski, i dont think it has to be of the form Intro(Elim), it can be any use of Intro and Elim, maybe
17:17:56 <MostAwesomeDude> > let x = 2 ^^ 100000 in x / x
17:17:57 <augur> because for disjunction, its not Intro(Elim)
17:17:57 <lambdabot>   NaN
17:18:03 <augur> its still Elim(Intro)
17:18:08 <MostAwesomeDude> > let x = 2 ^ 100000 in x / x
17:18:09 <lambdabot>   NaN
17:18:10 <Nereid> I actually don't know of any uses for anything other than (->) and I (->)
17:18:12 <MostAwesomeDude> Really.
17:18:16 <parcs`> > sizeOf 'a'
17:18:17 <mm_freak> enigmuri_: in your case you can replace the NaNs by 1.0
17:18:17 <lambdabot>   Not in scope: `sizeOf'
17:18:21 <Nereid> and I can easily write instances for everything for just those two.
17:18:49 <MostAwesomeDude> mm_freak: Sorry, Python doesn't give "1.0" for me, it gives 1.
17:19:03 <mm_freak> % python --version
17:19:03 <mm_freak> Python 3.2.3
17:19:10 <MostAwesomeDude> That'd be why.
17:19:26 <MostAwesomeDude> Did you want integer division? >>> x = 2 ** 100000; print x // x
17:19:35 <enigmuri_> yeah this is slightly harrowing for me. Haskell seemed so easy and clean. Maybe this was just a bad choice for a first script to write
17:19:43 <mm_freak> MostAwesomeDude: no, i actually wanted Double
17:19:59 <mm_freak> enigmuri_: haskell conforms to some IEEE standard for floating point
17:20:06 <mm_freak> it's expected behavior
17:20:20 <enigmuri_> that doesn't make this any less of a pain in the ass :p
17:20:20 <mm_freak> doesn't help you of course =)
17:20:24 <enigmuri_> i understand
17:20:35 <ski> Nereid : maybe one can use <http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC> somehow ..
17:20:35 <enigmuri_> but still, the python method was so clean and intuitive
17:21:04 <mm_freak> enigmuri_: well, haskell believes in giving NaN instead of messed up results, which may not be much of a problem in your particular case
17:21:10 <Nereid> ski: hmm!
17:22:14 <mm_freak> enigmuri_: in any case, you have to beware of very large or very small floating point numbers in every language…  some languages silently give /some/ result (python), while other languages give an exceptional result (haskell)
17:22:23 <enigmuri_> understood
17:22:45 <Nereid> ski: I'll think about that in a moment.
17:23:32 <hpc> if you're very lucky, your language gives you extra types for more precision
17:23:41 <hpc> > 1 / 100000000000000000000000000000000000000000 :: Rational
17:23:43 <lambdabot>   1 % 100000000000000000000000000000000000000000
17:23:58 <hpc> > pi :: CReal
17:23:59 <lambdabot>   3.1415926535897932384626433832795028841972
17:24:14 * hackagebot simple-actors 0.2.1 - A library for more structured concurrent programming, based  on the Actor Model (BrandonSimmons)
17:24:15 <hpc> (that one goes out forever)
17:24:27 <Nereid> ok I'm stuck, so let's have a look.
17:25:00 <mm_freak> Rational is going to be very slow for this calculation =)
17:25:23 <mm_freak> the problem can be solved by refactoring the algorithm
17:27:00 <mm_freak> > 2**10000 / 2**10000
17:27:01 <lambdabot>   NaN
17:27:08 <mm_freak> > 2**(10000 - 10000)
17:27:09 <lambdabot>   1.0
17:27:49 <mm_freak> in particular there is a 'logfloat' package that represents floating point numbers as exponents
17:28:13 <mm_freak> this is very useful for large calculations like this one
17:29:38 <ski> Nereid : <http://hackage.haskell.org/trac/ghc/ticket/1496> might also be interesting
17:32:13 <ski> Nereid : iirc, one can also do something like `class Equal a b where cast :: c a -> c b', `instance Equal a a where cast = id' and do `newtype L f a i = MkL (f (a i)) deriving Equal (f a i)' (i can't find the message describing this atm)
17:34:24 <ski> augur : "if you have a proof D : P, ..." -- yes
17:34:37 <ski> augur : elaborate on "pfenning mentions that defining simplifications in terms of ..." ?
17:34:58 <ski> *nod* re dijunction
17:35:21 <levi> enigmuri_: The python version doesn't actually work very well, either.
17:35:24 <Nereid> ski: what's c in cast :: c a -> c b?
17:35:43 <ski> augur : in sequent calculus, it becomes more uniform
17:36:17 <enigmuri_> levi: yeah, you may be right. I just did cursory testing with low real number exponents
17:36:18 <ski> > showCReal 1000 pi
17:36:20 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
17:36:39 <enigmuri_> well, i've learned to way on the floating point thing until I get a little better acquainted with Haskell :P
17:36:45 <Nereid> > 2**10000 / 2**10000 :: CReal
17:36:48 <lambdabot>   mueval-core: Time limit exceeded
17:36:52 <Nereid> oops
17:37:02 <c_wraith> CReal is *slow*
17:37:11 <Nereid> of course
17:37:12 <ski> Nereid : "I actually don't know of any uses for anything other than (->) and I (->)" -- possibly `Kleisli m', with `m' a monad
17:37:21 <enigmuri_> good news is I can write simple functions like factorials, and data type declarations, correctly on the first try. which is decent for being three days in
17:37:40 <enigmuri_> well, i'm out. time to go run.
17:37:51 <Nereid> ski: ok, but that still has kind * -> * -> *
17:38:04 <Nereid> so, things of that kind, and I's of them.
17:38:10 <enigmuri_> thanks for all the help everyone. this is a great community. and thanks to anyone who worked on Real World Haskell, it's an awesome book
17:38:32 <mm_freak> enigmuri_: well, your factorial function is correct, but not good =)
17:38:37 <ski> Nereid : "what's c in cast :: c a -> c b?" -- any type -- so that we can convert from `c a' to `c b' if we know `a' is equal to `b' -- e.g. convert from `cat (f (a i)) (f (a i))' to `cat (f (a i)) (L f a i)'
17:38:38 <levi> enigmuri_: It doesn't even work on 3 in my testing. :)
17:38:51 <Nereid> ski: oh, I see.
17:39:19 <ski> Nereid : you'll probably have to do `newtype Temp cat f a i x = T (cat (f (a i)) x)', and then set `c' to `Temp cat f a i' for this
17:39:24 <Nereid> I could try to implement that, but I have a feeling I'm going to run into kind errors like I have been.
17:39:33 <mm_freak> enigmuri_: a good factorial function is a one-liner and works with lists…  an even better factorial function has about 7-8 lines and is very fast even for large inputs
17:39:43 <enigmuri_> yeah, it doesn't work at all
17:39:58 <enigmuri_> hypothetically it kind of should, but it doesn't mesh with the nuances of floating point
17:40:11 <enigmuri_> oh right, that function
17:40:24 <enigmuri_> i wrote it again when i got frusterated with this
17:40:40 <enigmuri_> the one i have now works, that one got modified
17:40:40 <ski> <enigmuri_> well, i'm out. time to go run.
17:40:43 <ski> well, have fun ! :)
17:40:53 <Nereid> actually, hmm.
17:41:03 <Nereid> I need to think about what kinds my things have.
17:41:10 <Nereid> this is too abstract.
17:41:18 <augur> ski: well as for what pfenning says,   if you define things in the HOAS way, for example, you're defining something in terms of ->
17:41:43 <mm_freak> enigmuri_: in expense of some speed you can use a logfloat representation, which will be much more stable even for gigantic inputs like n = 10000
17:42:03 <Nereid> I wonder if this values/types/kinds hierarchy could be extended up to infinity.
17:42:15 <Nereid> and if anyone would care.
17:42:37 <ski> augur : what's "simplifications in terms of other inference rules is risking nasty interactions" ?
17:42:50 <augur> ski: eg.   (a : A   b : B   ===&I   A&B)   f : A -> B -> C   ===&E   C       becomes       (f a) b : C
17:42:54 <ski> augur : "defining something in terms of ->" is very vague :)
17:43:31 <ski> Nereid : well, if it simplifies things and gives forward extensibility, go for it
17:43:41 <augur> and that tree   f a b   =   (f : A -> B -> C   a : A   ===->E   B -> C)   ===->E   C
17:43:47 <augur> is defined with intermediate use of ->
17:44:40 <ski> Nereid : we've already had people wanting `forall f g. (Functor f,Functor g) => (forall a. f a -> g a) -> (t f -> t g)' and `forall f g. (Functor f,Functor g) => (forall a. f a -> g a) -> (forall a. t f a -> t g a)' for given `t's
17:45:15 <Nereid> ski: I wonder if, if we had such a thing, and could lift things up, if we'd get some approximation to dependent types or something.
17:47:07 <ski> augur : itym s/f : A -> B -> C   ===&E/[A]^x [B]^y ... C   ===&E^{x,y}/, maybe ?
17:47:38 <ski> augur : in any case, there's a big difference between the object logic connective `->', and a meta `->' used to express HOAS
17:48:45 <ski> Nereid : well, this seems more like making the parametric ("second-order") stuff more general and nice, than dependent types per se
17:48:46 <augur> ski: no, i mean exactly what i wrote :)
17:49:16 <ski> augur : yeah, but having the object `->' in the rule for `&E' is silly and stupid (which possibly was your point)
17:49:17 <augur> ski: if you use substitution, it's not really HOAS, since you're just treating a function as a hypothetical proof
17:49:20 <Nereid> ski: sure, but being able to lift data types to kinds seems lika first approximation to dependent types
17:49:26 <Nereid> like a*
17:50:46 <augur> ski: my point is that if you use HOAS stuff genuinely, you dont want to use substitution at all
17:50:59 <augur> ski: otherwise there's no point in having the higher-order type at the bottom
17:51:14 <augur> ski: like, why do this:   A & B   A -> B -> C   ===&E   C
17:51:35 <augur> if you're just going to substitute into the A -> B -> C proof?
17:51:52 <augur> besides, i dont think yo can simplify that to eliminate &
17:52:00 <augur> since you dont have a proof that leads to C
17:52:15 <ski> augur : i'm thinking about something like `data Prop = And Prop Prop | Impl Prop Prop | ...' and `data Proof :: Prop -> * where AndI :: Proof a -> Proof b -> Proof (And a b); AndE :: (Proof a -> Proof b -> Proof c) -> (Proof (And a b) -> Proof c); ImplI :: (Proof a -> Proof b) -> Proof (Impl a b); ImplE :: Proof (Impl a b) -> (Proof a -> Proof b); ...'
17:52:20 <augur> oh, well i guess you would simplify like i did, actually
17:52:40 <augur> ski: sure thats true HOAS
17:52:48 <ski> your `&E' was basically `Proof (And a b) -> Proog (Impl a (Impl b c)) -> Proof c'
17:52:52 <augur> ski: what i meant by HOAS-like is if you used _internal_ ->
17:53:02 <ski> s/Proog/Proof/
17:53:32 <ski> Nereid : yeah, but i'm not sure whether the lifting data types to kinds is really relevant here
17:53:53 <ski> (being able to define datakinds can be relevant, though; but i'm not sure about the lifting itself)
17:54:04 <Nereid> well whatever.
17:54:08 <augur> where, using your type, you have AndE :: Proof (A & B) -> Proof (Impl A (Impl B C)) -> Proof C
17:54:11 <Nereid> back to thinking about this other thing.
17:54:43 <augur> with   simpl (AndE (AndI a b) f) = ImplE (ImplE f a) b
17:55:03 <ski> augur : "my point is that if you use HOAS stuff genuinely, you dont want to use substitution at all" -- i'm not sure where the talk about substitution comes into this
17:55:08 <augur> that sort of internal almost-HOAS stuff is what i meant by "defined in terms of other stuff"
17:55:14 <augur> well, one example
17:55:34 <augur> another example would ofcourse be simplifying & to ~ and or
17:55:46 <ski> augur : "why do this:   A & B   A -> B -> C   ===&E   C" -- yeah, i'm not sure why one would want to do that :)
17:55:54 <augur> ski: substitution comes into it because you used substitution earlier! :P
17:56:10 <bitonic> can I link to modules on Haddock?
17:56:15 <augur> which in HOAS becomes external fun app
17:56:28 <ski> augur : hm, just a few hours ago, or earlier ?
17:56:42 <augur> ski: well, there IS a reason you would want to do that: it avoids the need for hypotheticals and binders other than \
17:56:49 <augur> ski: no, just a few minutes earlier :P
17:56:51 <augur> nevermind, it doesnt matter
17:56:54 <ski> where ?
17:57:09 * ski minds
17:57:22 <augur> ski: maybe you didnt
17:57:27 <augur> anyway, its not important
17:57:34 <ski> if you say so
17:58:14 <augur> the point is, there are reasons to want to use the internal HOAS stuff
17:58:20 <augur> it means you only have one binder: \
17:58:42 <augur> for instance, in Agda, \Sigma is not primitive, it's defined like that
17:59:08 <augur> well, the eliminator is probably like that, maybe
17:59:58 <ski> well, it depends on whether you want to embed the system you're defining in the host system, or manipulate it from there
18:00:11 <augur> but \Sigma itself is not primitive.   its not like   ...a...A   ...p...Pa   ===[EI_x]   Exists x. P x
18:01:13 <ski> "well, there IS a reason you would want to do that: it avoids the need for hypotheticals and binders other than \" -- yeah, but the solution is that `\' isn't the binder either :)
18:01:25 <augur> its defined as just   Exists : (A : Prop) -> (A -> Prop) -> Prop
18:01:59 <augur> so its just function application to introduce it
18:02:11 <augur> ski: well sure it is a binder
18:02:30 <augur> you would still have   [A]x ... B ===[->Ix] A -> B
18:02:43 <augur> btu thats the only place you'd use a hypothetical
18:03:10 <otters> for fuck's sake
18:03:15 <otters> what is the version of floor . (/2) that typechecks
18:03:32 <copumpkin> `div` 2
18:03:35 <copumpkin> >_>
18:03:35 <augur> lol
18:03:39 <augur> :t floor
18:03:39 <ski>   ExistsI : (a : Proof A) -> Proof (P a) -> Proof (Exists A (\a -> P a))
18:03:40 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:03:43 <augur> :t (/2)
18:03:45 <lambdabot> forall a. (Fractional a) => a -> a
18:03:54 <copumpkin> :t (`div` 2)
18:03:56 <lambdabot> forall a. (Integral a) => a -> a
18:04:00 <augur> :t \x -> floor (x / 2)
18:04:02 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:04:19 <augur> :t floor . (/2)
18:04:20 <lambdabot> forall b a. (RealFrac a, Integral b) => a -> b
18:04:28 <copumpkin> :t floor . (/2) . fromIntegral
18:04:29 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
18:04:35 <augur> it seems, otters, that   floot . (/2)   is the version that type checks :)
18:04:40 <ski> possibly otters wanted the input to be integrals as well
18:04:44 <otters> silly me
18:04:48 <copumpkin> yeah, mine does that
18:04:49 <otters> div is really what I wanted
18:04:51 <otters> integer division
18:04:53 <copumpkin> yay!
18:04:53 <augur> ski: right, you can do that for ExistsI
18:04:57 * copumpkin high-fives himself
18:05:01 <augur> ski: but my point is that in agda, you dont have that
18:05:22 <ski> ?
18:05:23 <augur> ski: there is no ExistsI, because Exists is just a function
18:05:53 <ski> which definition of `Exists' are you using ?
18:06:05 <augur> ski: defined primitively via records, making it essential an axiom:   ===axiom |- Exists : (A : Prop) -> (A -> Prop) -> Prop
18:06:13 * ski low-fours copumpkin
18:06:25 * copumpkin middle-threes ski
18:06:47 <ski> touché
18:07:08 * BMeph chants, "Hey Diddle Diddle, straight up the middle!"
18:07:25 <augur> ski: thats a valid definition of Exists, so that ExistsI is literally nothing more than function application:
18:07:37 <ski> augur : surely one can construct a record which has type `Exists A (\a -> P a)', then ?
18:07:50 <ski> or are you doing Church-encoding tricks ?
18:07:51 <augur> ski: i dont follow
18:08:02 * ski doesn't follow
18:08:16 <augur> in agda:   record Exists (A : Set) (P : A -> Set) : Set where ...
18:08:26 <augur> so that   Exists : (A : Set) -> (P : A -> Set) -> Set
18:08:53 <ski> yeah, but presumably there's some syntax for constructing such a record
18:09:00 <augur> oh, yes, but that's not my point
18:09:05 <ski> ok ?
18:09:38 <augur> my point is that Exists is not a primitive syncategorematic formative
18:09:57 <ski> i still don't see "ExistsI is literally nothing more than function application"
18:10:00 <augur> its a primitive substantive
18:10:05 <augur> there is no ExistsI!
18:10:21 <ski> that was a quote from you :)
18:10:30 <augur> i know, thats what i was trying to say there
18:10:46 <augur> there is no actual ExistsI rule in agda's type system
18:10:50 <augur> whereby that i mean
18:11:13 <ski> if there's specific syntax for forming records (presumably not using function application), then i don't see how `ExistsT' can be literally nothing but function application
18:11:21 <ski> er, s/ExistsT/ExistsI/
18:11:28 <augur> actually, no, im mixing levels
18:11:30 <augur> agh
18:11:32 <augur> whatever
18:11:35 <ski> (:
18:11:36 <augur> anyway
18:11:37 <augur> :P
18:11:38 <augur> point is!
18:11:40 <otters> :t curry $ sum . map snd . filter (odd . fst) . takeWhile ((> 0) . fst) . iterate (flip div 2 *** (*2))
18:11:41 <lambdabot> forall a b. (Num b, Integral a) => a -> b -> b
18:11:45 <augur> the real point
18:11:45 <MostAwesomeDude> Is there anything relatively simple that I've overlooked for turning ["20", "a5", ..] into [0x20, 0xa5, ...] ?
18:12:03 <augur> you could eliminate some primitive inference rules and use -> instead
18:12:05 <ski> otters : congrats
18:12:08 <otters> MostAwesomeDude: read . ("0x" ++)
18:12:08 <augur> i mean, this is what hilbert did, right
18:12:19 <augur> he just had -> (and \bot)
18:12:24 <Nereid> oh hmm, this might get me somewhere
18:12:24 <otters> ski: thx
18:12:32 <ski> @index readHex
18:12:32 <lambdabot> Numeric
18:12:35 <ski> @hoogle readHex
18:12:36 <lambdabot> Numeric readHex :: Num a => ReadS a
18:12:36 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
18:12:37 <Nereid> the kind of an associated type can depend on the kind of the class parameter, it seems
18:12:44 <ski> MostAwesomeDude : try that ?
18:13:09 <augur> ski: so its not unreasonable to imagine that you might want to have "admissible" rules that use -> instead of hypothetical proofs
18:13:35 <ski> > map readHex ["20", "a5"]
18:13:36 <lambdabot>   [[(32,"")],[(165,"")]]
18:13:39 <augur> admissible rules with "admissible" operators
18:13:46 <ski> > [0x20, 0xa5]
18:13:47 <lambdabot>   [32,165]
18:14:03 <MostAwesomeDude> ski: Tricky, nice.
18:14:04 <augur> which i guess is essentially just a way of saying & and &I and &E are just macros, in a sense
18:14:10 <EvanR> alright im playing with acid state for real, finally. poking my test state to see what i can do. i added a field to my state, and now it no longer loads the state when i run the program :)
18:14:19 * EvanR reads safeCopy documentation again
18:14:26 <MostAwesomeDude> > map (snd . readHex) ["20", "a5"]
18:14:27 <lambdabot>   Couldn't match expected type `(a, b)'
18:14:27 <lambdabot>         against inferred type `[(a1, ...
18:14:37 <ski> MostAwesomeDude : `readHex' is just like `reads' for handling parse error, and for getting the rest of the input
18:14:53 <MostAwesomeDude> > map (snd . head . readHex) ["20", "a5"]
18:14:56 <lambdabot>   mueval-core: Time limit exceeded
18:15:00 <MostAwesomeDude> ski: I see...
18:15:04 <otters> map \(a,_):_ -> ...
18:15:07 <otters> will probably work
18:15:29 <MostAwesomeDude> This is for a cheap script; I kind of was hoping I could just let it crash and burn if there was invalid input.
18:15:46 <augur> ski: or you could just chose to simplify into something else, either way: take the substitutive version of &E for instance
18:16:43 <ski> > map (\s0 -> case [n | (n,s1) <- readHex s0 , ("","") <- lex s1] of [n] -> n; _ -> error "sorry") ["20", "a5"]
18:16:44 <lambdabot>   [32,165]
18:17:07 <augur> ski:    simpl (&E (&I a b) (x:A y:B ...m... C)  =  m[a/x, b/y] : C
18:17:17 <augur> ski: instead of doing that, you could do
18:17:28 <ski> otters : i'd probably say  (`div` 2)  instead of  flip div 2
18:17:37 * MostAwesomeDude takes off glasses
18:17:39 <MostAwesomeDude> My god.
18:17:54 <augur> ski:    simple (&E (&I a b) (x:A y:B ...m... C))  =  App (App (\x.\y.m) a) b : C
18:18:16 <otters> yeah maybe
18:18:28 <dmwit> ~d~.
18:18:37 <augur> ski: that makes it not HOAS-y but still in terms of ->
18:18:38 <ski> MostAwesomeDude : `lex' just checks to make sure the rest of the input is empty, except for possibly whitespace and comments -- you probably don't need that
18:19:06 <ski> > map (\s -> case readHex s of [(n,"")] -> n; _ -> error "sorry") ["20", "a5"]
18:19:07 <lambdabot>   [32,165]
18:19:52 <Nereid> I just realized.
18:20:03 <Nereid> the L that I want is just type function composition.
18:20:12 <ski> MostAwesomeDude : if you start with something like `"20,a5"', it might be nicer to define a `ReadS' thing directly for that, instead of first splitting
18:20:30 <Nereid> because I want it to have kind (k1 -> k2) -> (k0 -> k1) -> k0 -> k2
18:20:37 <nule> quick question if anybody can spare a few cycles - trying out a single function but passing a few different lambda abstractions to it
18:20:52 <nule> some lambda abstractions may do IO, some may not
18:21:00 <nule> am I out of my mind to think that's possible?
18:21:17 <Nereid> nule: can you be more specific?
18:21:33 <ski> augur : "you could eliminate some primitive inference rules and use -> instead","i mean, this is what hilbert did, right","he just had -> (and \bot)" -- yeah, and it's a PITA :)
18:21:47 <augur> ski: i guess if you can define something like that --- rewrite in terms of some other connectives --- what you're doing is showing entailment?
18:21:53 <ski> augur : "so its not unreasonable to imagine that you might want to have "admissible" rules that use -> instead of hypothetical proofs","admissible rules with \"admissible\" operators" -- hrm ..
18:22:00 <nule> sure - i have a function that's basically doing filtering, some tests I can perform using very simple logic, but I'd like to try one that uses HashTables, which means the return value is going to include IO
18:22:06 <augur> ski: well yeah, its a pain, but its possible! and some people might do that! who knows!
18:22:20 <augur> ski: its important enough that pfenning points it out
18:23:07 <ski> augur : "which i guess is essentially just a way of saying & and &I and &E are just macros, in a sense" *nod*
18:23:10 <nule> Nereid: if that question doesn't make sense I'll write a quick test case and stick it on hpaste
18:23:43 <ski> augur : "that makes it not HOAS-y but still in terms of ->" *nod*
18:24:01 <ski> Nereid :)
18:24:32 <Nereid> except I'm having a hell of a time making instances of this class.
18:24:32 <Nereid> :S
18:24:38 <Nereid> in a bad way.
18:24:41 <ski> Nereid : i've several times wanted to be able to say stuff like `newtype k (L f a i) = L (k (f a i))'
18:24:58 <ski> s/= L/= MkL/
18:25:05 <mm_freak> is IORef with atomicModifyIORef faster than MVar?
18:25:42 <ski>   MkL :: forall_kind k0 k1 k2. forall (k :: k2 -> *) (f :: k1 -> k2) (a :: k0 -> k1) (i :: k0). k (f (a i)) -> k (L f a i)
18:25:57 <Nereid> mm_freak: probably, but the docs say you should use MVar if you're using more than one.
18:26:11 <ski> mm_freak : i suspect it does a TAS
18:26:42 <mm_freak> it's a library…  i can't really make any educated assumptions on the total number of MVars/IORefs in the application
18:26:46 <mm_freak> ski: TAS?
18:26:48 <coppro> ski: a tool-assisted speed run?
18:26:54 <ski> test-and-set/swap iirc
18:27:21 <ski> <http://en.wikipedia.org/wiki/Test-and-set>
18:27:55 <mm_freak> so i'd expect IORef to be faster in general
18:28:23 <ski> nule : seems to make sense, i think
18:28:41 <ski> (though we'd need more details to tell)
18:28:56 <nule> ski - thanks, writing a minimal sample right now for hpaste
18:29:10 <ski> "a single function but passing a few different lambda abstractions to it","some lambda abstractions may do IO, some may not" -- should be possible
18:29:13 <Nereid> mm_freak: I'd expect so too, but I don't know by how much.
18:29:33 <ski> coppro : hehe
18:30:14 <ski> augur : "i guess if you can define something like that ... what you're doing is showing entailment?" -- hmm ?
18:30:38 <ski> "well yeah, its a pain, but its possible! and some people might do that! who knows!
18:30:46 <ski> er
18:30:57 <ski> "well yeah, its a pain, but .." :)
18:31:00 <Nereid> ok, I'm running into kind errors again :D
18:31:05 <Nereid> let's see if I can make a minimal example
18:31:32 <ski> kind errors are errors of a kind
18:31:34 <mm_freak> i'm not doing any fancy transactional stuff…  it's really just a mutable state variable accessed by multiple threads
18:31:52 <ski> mm_freak : sounds ok, imio
18:32:29 <dmwit> atomicModifyIORef may be faster in some cases, but you miss out on a lot of great stuff: single-wakeup, efficient contention, fair scheduling...
18:32:53 <mm_freak> i guess i'll just go with MVar
18:33:06 <mm_freak> my conclusion is that IORef is something for programs, not libraries
18:33:10 <ski> "single-wakeup" ?
18:33:28 <dmwit> Yes; writing to an MVar only wakes up one thread, even if many are waiting to read from it.
18:33:46 <ski> yeah, i'm just not sure how it relates to `atomicModifyIORef'
18:33:55 <geekosaur> see :thundering herd problem"
18:34:09 <ski> hm, i suppose if you want to use an `IORef' as an `MVar' rather than as a `SampleVar'
18:34:15 <Refried__> why is unit called unit and bind called bind?
18:34:42 <ski> Refried__ : unit is the unit of the monadic "multiplication" operation, `join'
18:35:04 <Cale> itym "why is unit called return" :)
18:35:22 <ski> Refried__ : i think Wadler named it "bind" because it's usually used to bind the result of executing a monadic action to a name, like in `getLine >>= \l -> putStrLn (reverse l)'
18:35:34 <EvanR> anyone have an example of how youd use safecopy to migrate changes to an acidstate?
18:35:44 <EvanR> including the templatehaskell
18:35:49 * ski . o O ( "why is eta called `return' ?" )
18:35:55 <Refried__> ski: binding the output of getLine to l ?
18:35:59 <ski> yes
18:36:05 <Refried__> that makes sense
18:36:12 <Refried__> i still didn't understand 'unit' though
18:36:25 <ski> Refried__ : and then the `do'-notation sugar was invented, so we can write `do l <- getLine; putStr (reverse l)'
18:36:34 <ski> @undo do l <- getLine; putStr (reverse l)
18:36:35 <lambdabot> getLine >>= \ l -> putStr (reverse l)
18:37:03 <ski> Refried__ : it's possibly easier to see if you consider `(>=>)'
18:37:05 <Cale> Refried__: okay, do you happen to know what a monoid is from mathematics?
18:37:12 <Refried__> Cale: yes
18:37:24 <dmwit> For binary operations, there are sometimes values that have a special property: the binary operation makes them disappear. That is, u * x = x or x * u = x. Such values u are called unit.
18:37:38 <Refried__> ski: where can i find `(>=>)`?
18:37:51 <dmwit> Now, the only remaining question is which unit you're asking about; then we can tell you what binary operation makes it disappear.
18:37:53 <ski>   (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
18:37:53 <ski>   (amb >=> bmc) a = amb a >>= bmc
18:37:56 <ski> @index >=>
18:37:57 <lambdabot> bzzt
18:38:01 <ski> bah
18:38:03 <Refried__> dmwit: i thought they were called identity
18:38:11 <dmwit> Identity is another word for these, yep.
18:38:12 <ski> @hoogle (>=>)
18:38:13 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
18:38:39 <Cale> Okay, so if we take the idea of a monoid, and try to generalise it by removing the sets from its description and only leaving the functions (so that we can take that pattern of function arrows and transplant it into other categories), we end up with something like this:
18:38:51 <ski> Refried__ : then, two of the monad laws can be stated as `return >=> amb = amb' and `amb >=> return = amb' (where `return' is "unit")
18:38:59 <Dodek> hey, do you have any suggestions on what tools should i use for fast prototyping of concurrent network application in haskell? is STM a good choice for this? is there any kind of networking framework in haskell, or do i have to use plain blocking reads in forkIOs?
18:39:12 <Lajla> evanR, my love.
18:39:15 <Lajla> It has been too long
18:39:19 <ski> the third law is then `(amb >=> bmc) >=> cmd = amb >=> (bmc >=> cmd)'
18:39:32 <dmwit> Dodek: You phrased it wrong. You *get* to use plain blocking reads in forkIOs, not you *have* to. =)
18:39:43 <EvanR> Lajla: i see you lurking, and i dont know what to think
18:39:46 <ski> Refried__ : note how this is similar to `1 * x = x', `x * 1 = x', and `(x * y) * z = x * (y * z)'
18:39:50 <Dodek> dmwit: haha. so this is way to go?
18:39:52 <Cale> A monoid is an object M together with a function η: 1 -> M (where 1 is a one-element set, making this the same as picking an element of M, the unit), and a function μ: M x M -> M, the multiplication
18:39:56 <dmwit> Dodek: yes
18:39:57 <Lajla> EvanR, explain, my love.
18:39:59 <EvanR> no
18:40:03 <EvanR> i need help with my program
18:40:03 <Cale> and these have to satisfy some laws
18:40:06 <Dodek> dmwit: and what about the concurrency?
18:40:10 <ski> Refried__ : `1' is the unit/identity element of `*', and `return'/"unit" is the unit/identity element of `>=>'
18:40:19 <dmwit> Dodek: What about it? forkIO gives you concurrency.
18:40:21 <Refried__> I did not understand any of that.  But.  'unit' is the identity for `bind` ?
18:40:32 <Refried__> and unit is another term for identity in math?
18:40:32 <Dodek> dmwit: yeah, i should have said "synchronization"
18:40:32 <ski> Refried__ : it's the "identity" for it, yes
18:40:42 <Refried__> ski *nod* thanks
18:40:46 <Refried__> thanks cale and dmwit
18:40:52 <Cale> Refried__: unit is another term for identity, and in this case, it's the identity for *join*
18:40:53 <ski> Refried__ : it's not quite "identity" in the normal sense, if you state it in terms of `>>=' instead of `>=>'
18:41:06 <ski> Refried__ : but it still amounts to the same thing, in practice
18:41:06 <dmwit> Dodek: Depends what you need. We've got dozens of abstractions, pick the one that matches your goals.
18:41:17 <Cale> There's something which *very abstractly* resembles multiplication going on with join and return
18:41:22 <Cale> return :: a -> M a
18:41:28 <Cale> join :: M (M a) -> M a
18:41:37 <Refried__> ski: ok, trying to read/understand >=>
18:41:41 <Cale> where in the case of normal monoids in Set,
18:41:44 <Cale> you have
18:41:47 <Dodek> dmwit: that's the whole problem -- i don't know which one matches my goals :) suppose i'm trying to create a backend for multiplayer game.
18:41:48 <Cale> unit :: 1 -> M
18:41:49 <dmwit> MVar, Chan, TVar, TChan, atomicModifyIORef as somebody mentioned above, various things for parallelism (probably not useful for networking stuff), etc.
18:41:56 <Cale> and multiply :: M x M -> M
18:42:17 <ski> Refried__ : for completeness, the way to state the laws in terms of `join' instead is : `join . return = id', `join . liftM return = id', `join . join = join . liftM join'
18:42:24 <Dodek> dmwit: i used MVars in the past and i'd like to try STM, but i wonder if it's a good idea for this sort of stuff
18:42:43 <dmwit> Dodek: STM is probably going to be great for you.
18:42:44 <mm_freak> Dodek: just an experience report:  in most cases i really just use STM or the stuff from Control.Concurrent
18:42:45 <ski> Refried__ : read `>=>' like a "monadic composition", so `f >=> g' is a bit like `g . f', except "monadic"
18:42:49 <dmwit> You should definitely learn it.
18:43:01 <mm_freak> Dodek: the other abstractions are convenience wrappers around those
18:43:09 <Cale> I prefer to talk about (<=<)
18:43:10 <Dodek> thanks!
18:43:35 <mm_freak> Dodek: and to answer your question, it's never wrong to use STM…  if you don't use transactions, then the performance is about the same as the regular concurrency tools
18:43:36 <Refried__> ski: what might a type for f/g be?
18:43:45 <hpaste> nule pasted “Passing different tests to a function (mixing IO and non-IO)” at http://hpaste.org/71752
18:43:58 <nule> There's a quick example that shows the problem that I'm having
18:43:59 <Cale> :t (<=<)
18:44:00 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
18:44:09 <Dodek> the thing i love about haskell is that stuff seems so well-thought and solid, probably because it is.
18:44:10 <nule> if anybody can give a hint, thanks :)
18:44:14 <mm_freak> where "not using transactions" means that you don't use (>>=) or (<|>) in the STM monad =)
18:44:22 <mm_freak> Dodek: it is =)
18:44:29 <Cale> :t mapM readFile <=< getDirectoryContents
18:44:30 <lambdabot> Not in scope: `getDirectoryContents'
18:44:48 <ski> Refried__ : `f :: String -> IO Int', `g :: Int -> IO [Double]' e.g.
18:44:56 <Cale> :t mapM readFile <=< System.Directory.getDirectoryContents
18:44:57 <lambdabot> FilePath -> IO [String]
18:45:00 <ski> Refried__ : then `f >=> g :: String -> IO [Double]'
18:45:03 <mm_freak> Dodek: when you get used to haskell's STM you will hate concurrency in most other languages =)
18:45:05 <Dodek> after haskell everything else seems so sketchy or hairy, because of a lack of thought or historical circumstances
18:45:52 <ski> Refried__ : `<=<' is the same as `>=>', except the arguments is in the other order (so `<=<' is more similar to the usual function composition `.')
18:45:58 <Cale> Refried__: return (a.k.a. unit) is also the unit in the category implied by (<=<)
18:46:07 <ski> Dodek :)
18:46:23 <Refried__> my battery's going to die soon, sorry in advance when i disconnect without saying thanks or goodbye
18:46:23 <Cale> (due to polymorphism, it's all the identity arrows)
18:46:25 <Dodek> mm_freak: yeah, i've been driving a linux device driver for classes recently, and i couldn't convince even myself that the concurrency in it is correct, let alone the grader
18:46:34 <Dodek> s/driving/writing/
18:46:42 <Dodek> i have no idea why i just wrote this
18:47:28 <mm_freak> =)
18:48:09 <Cale> I've been driving a drive device driver for drives recently, and I couldn't drive even myself that the driving in it was driven, let alone the driver.
18:48:11 <Dodek> anyway, thanks, guys
18:48:24 <Dodek> Cale: haha
18:48:40 * ski chuckles
18:49:14 <dmwit> ah have a tahpahng ahmpahdahmahnt
18:49:20 <mm_freak> philosophical question:  GHC does the type checking on the haskell level, and the core type checker is really just insurance…  what if the core language were dependently typed?
18:50:26 <dmwit> I think part of the point of the current setup is that there's still a clear erasure semantics for types.
18:50:42 <Cale> mm_freak: It would be funny that despite the external type language having no features which require runtime type information, the core language might introduce the need for it
18:51:02 <Cale> But yeah, that would start to open up the potential for adding such features, I guess.
18:51:03 <mm_freak> Cale: how?  dependent types don't need RTTI
18:51:14 <dmwit> Yes, they do.
18:51:23 <mm_freak> when?
18:51:52 <mm_freak> consider a language as simple as pisigma
18:52:03 <mm_freak> the only additional requirement is a full-blown interpreter for the type-checker
18:52:06 <dmwit> When, for example, you write a structural recursion over proofs that the string you have is valid XML.
18:52:46 <dmwit> That proof is type information.
18:53:19 <mm_freak> dmwit: yes, but then you could say that in haskell ExistentialQuantification with contexts is also a kind of RTTI
18:53:23 <ski> is the proof implicit in the source ?
18:54:16 <dmwit> ExistentialQuantification is a kind of runtime type information, yes: you keep a dictionary of type-specific operations around somewhere in memory.
18:54:28 <Cale> mm_freak: Yeah, I guess you could say that we're already passing type information around in the form of equality constraints and typeclass dictionaries.
18:54:46 <mm_freak> ok, but that is explicit…  i don't really think that it deserves the name "RTTI"
18:55:15 <mm_freak> the language itself doesn't create it, but the programmer does
18:55:42 <dmwit> I could imagine GHC eventually using something like ICC*, which has two kinds of types (eraseable and non-eraseable ones).
18:56:27 <mm_freak> in particular if you use Pi and Sigma only in a non-dependent fashion the result should really be the same as whatever the current core would produce
18:56:31 <ski> dmwit : were you thinking about setups which distinguish between proofs in a `Prop' and ones in a type/set ?
18:56:46 <Nereid> ok, I think my problem boils down to this:
18:57:05 <Nereid> I want to make a typeclass whose members have types not necessarily of kind *
18:57:11 <dmwit> Hm, I'm not sure.
18:57:37 <ski> yes, a polymorphic type class
18:57:40 <Cale> Nereid: using PolyKinds?
18:57:43 <Nereid> yes
18:57:50 <Nereid> wait, that might not be my only problem.
18:58:01 <solrize> are there any haskellwiki admins here?
18:58:29 <Cale> http://hackage.haskell.org/trac/ghc/ticket/5717 -- awesome
18:58:38 <Cale> (that this is fixed)
18:58:52 <mm_freak> Nereid: the members will always have kind *, even with PolyKinds
18:58:57 <Cale> That bug was basically making PolyKinds unusable to me
18:59:03 <Nereid> mm_freak: I'm aware of that.
18:59:13 <Nereid> and I don't like it.
18:59:16 <Nereid> :(
18:59:28 <Nereid> wait.
18:59:31 <Nereid> wait a sec.
18:59:34 <Nereid> no that's not what I want.
18:59:35 <mm_freak> Nereid: what don't you like about it?  it doesn't really make sense for class members to have another kind
18:59:35 <Cale> Nereid: What are the types of the methods?
18:59:42 <Nereid> not at all.
18:59:46 <Nereid> hang on. :)
19:00:05 <mm_freak> unless you're talking about associated types, of course
19:00:29 <Cale> Nereid: (I guess I can kind of imagine a class where the way that the type parameter shows up in the methods allows it to be kind-polymorphic, but I have trouble imagining non-silly cases for that)
19:00:41 <Nereid> hang on. :)
19:01:17 <ski> mm_freak : `Typable IORef' makes sense, i think
19:01:49 <ski> (or `Typable (* -> *) IORef', if the kind argument was explicit)
19:01:57 <Cale> Oh, yeah, for something like Typeable it would be useful of course.
19:02:20 <ski> i thought `Typable' was one of the main motivations for getting polymorphic classes
19:03:07 <Nereid> let me try isolating my problem again.
19:04:10 <dmwit> ski: Doesn't the current setup require you to use Typeable1 for that?
19:04:16 <ski> yes
19:04:41 <dmwit> ...and even the poly-kinded thing would still have *-kinded class members, no?
19:05:14 <dmwit> typeOf :: Typeable a => Proxy a -> TypeRep -- typeOf is still classified by a type of kind *
19:05:20 <Cale> By way of Proxy, I think?
19:05:21 <Cale> yeah
19:05:58 <tgeeky_> sort level numbers: coming to a haskell near you
19:06:31 <dmwit> Yeah, Haskell sort of mucked up the "0,1,many" thing.
19:06:41 <augur> ski: i have a minor formal characterization of what is required for something to be locally sound/locally complete, maybe
19:06:50 <dmwit> We went all the way up to 4.
19:07:19 <ski> dmwit : <http://hackage.haskell.org/trac/ghc/wiki/GhcKinds>, see the `PolyTypeable' subpage
19:07:23 <augur> ski: so for local soundness all of the examples i can think of or find in pfenning have the form   Intro-Elim   which is then removed
19:07:40 <ski> of course we also need
19:07:47 <ski>   Proxy :: forall k. k -> *
19:08:12 <augur> ski: for local completeness, they all have the form   P   becomes   P-Elim + intro not above P
19:08:14 <dmwit> ski: typeRep (the only class method) is still classified by a type of kind *
19:08:57 <ski> dmwit : when you say "*-kinded class members" are you talking about the class methods or the class parameters ?
19:09:04 <augur> ski: well, Intro not above Elim
19:09:08 <ski> (i think Nereid was talking about the latter)
19:09:22 <augur> ski: that leads me to wonder if for soundness, you could say instead   Intro + Elim not above Intro
19:09:29 <dmwit> ski: I didn't say members. I said methods every time.
19:09:37 <augur> since this is also a pattern
19:09:46 <Nereid> oh I meant methods when I said that, but that still wasn't it at all.
19:10:01 <dmwit> ah
19:10:04 <dmwit> I did say class members.
19:10:07 <dmwit> That was a mistake.
19:10:18 <augur> actually for completeness its not Intro not above Elim, sorry
19:10:27 <augur> hmm
19:10:31 <dmwit> Anyway, yes, I meant methods.
19:10:35 <ski> dmwit : "...and even the poly-kinded thing would still have *-kinded class members, no?" -- naturally, since all types with values have kind `*'
19:10:44 <ski> (at least values in the ordinary sense)
19:10:49 <dmwit> We all know and love many higher-kinded type classes that don't require polykinds, e.g. Functor and Monad. =)
19:11:21 <dmwit> ski: Yes, I think this was mm_freak's original point.
19:11:49 <dmwit> We are violently agreeing, all three of us.
19:12:07 <ski> augur : hm, not sure -- i'd compare with sequent calculus, if i were you :)
19:13:08 <dmwit> I don't understand how to use chainl.
19:14:36 <aristid> @hoogle chainl
19:14:36 <lambdabot> Text.ParserCombinators.ReadP chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
19:14:36 <lambdabot> Text.ParserCombinators.ReadP chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
19:14:36 <lambdabot> Text.Parsec.Combinator chainl :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a
19:15:20 <otters> so I need to set ARGV from ghci
19:15:33 <ski> dmwit :)
19:15:44 <aristid> dmwit: seems pretty intuitive to me :P
19:15:52 <otters> can I do that somehow?
19:16:01 <aristid> @hoogle getArgs
19:16:02 <lambdabot> System.Environment getArgs :: IO [String]
19:16:02 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
19:16:07 <aristid> otters: ^
19:16:17 <otters> no, I mean, setArgs
19:16:20 <otters> something like that
19:16:27 <aristid> otters: sorry, i read "get"
19:16:29 <otters> because my project takes a port to listen on argument
19:16:34 <otters> oh, okay
19:16:45 <hpaste> Nereid pasted “not kind-polymorphic enough” at http://hpaste.org/71753
19:17:01 <ski> dmwit : `chainl parseItem parseSeparator initialValue' ?
19:17:07 <dmwit> I've got a grammar like this (simplified a bit): E -> P | E ' ' P; P -> '(' ')' | V. Can I write this in a straightforward way with chainl, or do I need to left-factor it myself?
19:17:11 <Nereid> so yeah, here's my problem.
19:17:33 <aristid> otters: do you want to spawn a new process with the argument?
19:17:47 <aristid> otters: i don't really see the point of changing the argument list of a running program
19:17:54 <Nereid> wait.
19:17:56 <ski> otters : `:set args foo bar ...'
19:17:57 <dmwit> Sorry, that's not right.
19:18:04 <dmwit> I mean E -> V | E ' ' P
19:18:06 <otters> aristid: no, it's not a running program
19:18:14 <otters> I use cabal-dev ghci to load it and main to run it
19:18:19 <ski> otters : also see `:main foo bar ...'
19:18:25 <dmwit> So, some sequence of V's, separated by exactly one whitespace, followed by either a V or a ().
19:18:31 <otters> ski: holy crud that's it
19:18:43 <Nereid> yeah.
19:18:50 <ski> otters : a quick `:?' showed it :)
19:18:55 <Nereid> ski: ^
19:19:22 <ski> (of course i already knew there was something like that in there :)
19:19:24 <dmwit> I can't use ' ' as the "op" part of the chainl, because when parsing a "foo ()", it will see the space and think it should look for a further V, when really it should reach the "end" and look for a "()".
19:20:57 <Nereid> the error disappears if I make T a type synonym instead of a newtype, but then I run into the problem where I can't make instances out of partially applyed type synonyms
19:21:27 <ski> yes, `T :: * -> *'
19:21:52 <dmwit> aristid: Okay, cocky guy, what's your intuition say now that I've got the real question on the table? =)
19:22:37 <ski> dmwit : hm, `parseE = chainl1 parseP parseSep' ?
19:23:15 <dmwit> ski: As I say above, that doesn't work because parseSep succeeds to often.
19:23:25 <ski> hm, ok
19:23:40 <dmwit> err
19:23:50 <dmwit> Oh, no, what you said would work, but is too permissive.
19:24:00 <dmwit> It parses the wrong grammar I wrote first, not the right grammar. =P
19:24:16 <dmwit> E -> V | E ' ' P; P -> '(' ')' | V
19:24:18 <ski>   parseE = chainl parseP parseSep =<< parseV  -- just noticed "E -> V | E ' ' P"
19:24:27 <dmwit> V -> 'v' for completeness if you want a simple example
19:24:35 <ski> hm, no
19:24:45 <dmwit> Right, that one doesn't work because the first part is too eager. =)
19:24:56 <dmwit> too eager to consume bits of the string ,I mean
19:25:02 <Nereid> so how do I get out of this trap D:
19:25:11 <ski> i had a sequence of `P's with an initial `V' there
19:26:00 <ski> "I can't use ' ' as ..." -- mayhaps some `try' trick would work ?
19:26:05 <aristid> dmwit: let me read it
19:26:22 <dmwit> ski: Yes, try would work...
19:26:42 <ski> Nereid : presumably you want `c :: k -> *' in `C c' ?
19:26:43 <dmwit> It's a bit unfortunate to use arbitrary lookahead for this, though. If it comes to that, I'll left-factor the grammar by hand instead.
19:27:03 <Nereid> ski: yeah
19:27:32 <Nereid> removing the x method in the class removes the error
19:27:33 <ski> Nereid : it's a bit hard for me to see what you're trying to achieve in this very-simplified example ;)
19:27:42 <Nereid> sure, I'll paste the full thing I have.
19:27:48 <Nereid> well, without the irrelevant bits
19:27:52 <ski> i saw earlier pastes :)
19:27:56 <ski> hehe
19:28:01 <Nereid> yeah but I changed things.
19:28:10 <Nereid> the class I'm having issues with is not one I've pasted before.
19:28:14 <aristid> dmwit: maybe chainl is just not the right function :)
19:28:22 <dmwit> Wouldn't surprise me.
19:28:37 <dmwit> It was the one that claimed to deal with left-recursion, though.
19:28:48 <ski> @hoogle sepBy
19:28:49 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
19:28:49 <lambdabot> Text.ParserCombinators.ReadP sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
19:28:49 <lambdabot> Text.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
19:30:17 <dmwit> sepBy is eager in the same unfortunate way
19:31:19 <aristid> dmwit: i wonder if there's a good parser combinator library that doesn't force you to decide on the greediness yourself
19:31:20 <augur> so yeah, ski, this is my remaining question:   can you have a connective # with the following rules:
19:32:14 <dmwit> aristid: No hits for "earley" on Hackage. =/
19:32:29 * ski . o O ( "eager cat is eager" <http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/1/960526205_PhQo8> )
19:32:30 <aristid> dmwit: how about using something like try (char ' ' >> parseP)
19:32:47 <ski> ("earley" ?)
19:32:53 <aristid> well you know what i mean
19:33:01 <dmwit> http://en.wikipedia.org/wiki/Earley_parsing
19:33:01 <JoeyA> What's a good way to add a "test mode" to a package?  Use cpp-options: -DTEST and #ifdef TEST ?  Or is there a nicer way?
19:33:03 <augur> ski:    P Q R ===#I P#Q   and some elim rule with the following property   P Q (... ===#E) ===#IL P
19:33:04 <aristid> i don't mean parseP. :D
19:33:14 <augur> i dont think so. i dont think this is a possible thing
19:33:17 <augur> but who knows
19:33:32 <dmwit> aristid: What do you mean?
19:34:04 <JoeyA> By "test mode", I mean add sanity checks at runtime that I don't want to keep in production.
19:34:10 <augur> er no sorry
19:34:17 <ski> augur : what's `#IL' ?
19:34:17 <EvanR1> i definitely prefer earley parsing to late parsin
19:34:36 <augur> ski: i mistyped. i meant:    P Q (... ===#E R) ===#I P#Q
19:34:37 <aristid> dmwit: i mean try (char ' ' >> char 'V')
19:34:53 <aristid> dmwit: as a block
19:35:10 <dmwit> ski: The benefits of Earley parsing are that it works for any grammar (left-recursion? right-recursion? don't care!), and gives you all parses when the language is ambiguous.
19:35:20 <aristid> dmwit: i'm fairly tired though, so maybe i'm not making sense oO
19:35:23 * ski . o O ( mealy : moore :: earley : oore ? )
19:35:28 <augur> ski: but that answers my question i think :)
19:36:10 <EvanR1> . o O (play doom or develop an safecopying acid mud)
19:36:17 * dmwit gets back to coding
19:36:35 <ski> dmwit : that's nice
19:37:40 <ski> augur : where does `R' go ?
19:37:56 <hpaste> Nereid annotated “what do I do” with “what do I do (annotation)” at http://hpaste.org/71748#a71754
19:38:13 <Nereid> uh
19:38:17 <Nereid> yeah, that's what I'm trying to do.
19:38:36 <ski> augur : also, i assume you mean `R' can be an arbitrary formula, rather than only a specific constant like `Nat' or `_|_' or something ..
19:40:13 <Nereid> well, the main error is the first one.
19:40:38 <nule> I asked a question about an hour ago and then lost power, so if someone replied I wasn't being rude and thank you :)
19:42:00 <ski> Nereid : i suspect maybe `LiftO' isn't polymorphic
19:42:29 <Nereid> ski: yes, because of the methods.
19:42:39 <Nereid> LiftO isn't polymorphic because O isn't
19:42:53 <Nereid> if I remove the methods then it compiles.
19:43:25 <avpx> Is it possible to define the S combinator in Haskell? I wrote "s f x y = f y $ f x" but this doesn't type check because it constructs an infinite type.
19:43:54 <Nereid> avpx: s f g x = (f x) (g x)
19:44:09 <ski> Nereid : afaics, `liftMkO :: forall_kind k0 k1. forall (f :: k1 -> k2) (a :: k0 -> k1) (i :: k0). cat (f (a i)) (O f a i)' ought to be possible with `cat :: k2 -> k2 -> *'
19:44:13 <otters> :pl s f g x = (f x) (g x)
19:44:20 <otters> @pl s f g x = (f x) (g x)
19:44:20 <lambdabot> s = ap
19:44:31 <ski> hm
19:44:34 <otters> ap is the S combinator?
19:44:36 <otters> :O
19:44:45 <ski> sure
19:44:48 <Nereid> ski: afaics everything should be possible, as long as O :: (k -> k') -> (* -> k) -> * -> k'
19:44:51 <augur> ski: R might not go anywhere. its an auxiliary proof. tho i bet its type probably actually needs to be included in the # somewhere
19:44:58 <ski> > ap (+) (^2) 3
19:44:59 <lambdabot>   12
19:45:37 <avpx> That's a surprising result (to me)
19:46:00 <ski> Nereid : hm, yea, i see with the current code, you can at best hope for `O :: forall k0 k1. (k1 -> *) -> (k0 -> k1) -> (k0 -> *)'
19:46:18 <ski> which fixes `k2' at `*' above
19:46:23 <Nereid> well right now, the compiler makes it (* -> *) -> (* -> *) -> (* -> *)
19:46:27 <Nereid> anyway,
19:46:39 <Nereid> if I replace O with a type synonym, then everything is fine until I try to define the instance on line 41
19:47:56 <ski> > ap (+) sin 3 :: Expr
19:47:57 <lambdabot>   3 + sin 3
19:48:32 <avpx> Ah, I see, I just messed up the definition of S. That's embarassing.
19:48:43 <ski> > (=<<) (+) sin 3 :: Expr
19:48:44 <lambdabot>   sin 3 + 3
19:48:59 <hpaste> BMeph pasted “How do I not repeat myself so much here?” at http://hpaste.org/71755
19:49:57 <BMeph> Anyone? :)
19:51:01 <ski> > fix $ \ ~(_:bits) -> 0 : 1 : [y | x <- bits , y <- [x,x + 1]]
19:51:02 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
19:51:19 <ski> BMeph : not sure what repetition you're thinking about
19:51:36 <ski> (that is a nice example of left-recursion, though)
19:52:21 <BMeph> Eh, when I started writing it, instead of the '0:1:' part, I wrote 'f 0 ++'. It seemed like a good idea at the time. :)
19:53:23 <ski> hm, ok
19:53:30 <BMeph> Oh, no - we've gone shapr-less! ;)
19:53:32 <ski> that doesn't work ?
19:53:57 <Cale> > fix ((0:) . (1:) . concatMap (\x -> [x,x+1]) . tail)
19:53:59 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
19:54:04 <ski> we have to invoke lodr shapr
19:54:12 <ski> @get-shapr
19:54:12 <lambdabot> shapr!!
19:54:29 <ski> now, with some luck, he should return after a small while
19:54:29 <BMeph> ski: Oh, it woks, it just feels like I shouldn't be doing so many cartwheels to get it in that form, is all.
19:55:37 <ski> > 0 : fix (\bits -> 1 : [y | x <- bits , y <- [x,x + 1]])  -- ho hum
19:55:38 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
19:56:25 <BMeph> It just irks me that the beginning part itself fits the function the concatMap uses to produce more of the list.
19:57:52 <BMeph> Er, it matches the result of applying the function.
19:58:25 <ski> @let infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =     ys; (x:xs) /\/ ys = x : ys /\/ xs
19:58:27 <lambdabot>  Defined.
19:59:18 <Nereid> I wonder if I can make this even worse by using data families or something.
19:59:51 <ski> > fix $ \ns -> ((0 :) . (\(0:ns) -> ns)) (ns /\/ map (1 +) ns)
19:59:54 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
20:00:36 <ski> > fix (\bits -> ((0 :) . (\(0:ns) -> ns)) [y | x <- bits , y <- [x,x + 1]])
20:00:39 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
20:00:52 <ski> BMeph : better ?
20:00:55 <BMeph> ski: Yes, it's very self-referrential. :)
20:01:25 <ski> the first element will become `0', if i don't look at it before i've set it
20:01:29 <Cale> > map (`mod` 2) . fix $ (0:) . (1:) . concatMap (\x -> [x,x+1]) . tail
20:01:31 <BMeph> ski: Better, though...meh.
20:01:31 <ski> but i still need to set it
20:01:31 <lambdabot>   [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,...
20:01:38 <ski> > fix (\bits -> ((0 :) . (\(!0:ns) -> ns)) [y | x <- bits , y <- [x,x + 1]])
20:01:41 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
20:01:45 <ski> hm
20:02:03 <ski> > fix (\bits -> 0 : case [y | x <- bits , y <- [x,x + 1]] of 0:ns -> ns)
20:02:05 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
20:02:15 <ski> oh, right
20:04:21 <ski> something like `expectHead :: Eq a => a -> [a] -> ((),[a]); expectHead a0 ~(a1:as) = (case a0 == a1 of True -> (),a0:as)' might be useful
20:04:40 <BMeph> ski, Cale: Thanks; I guess 'fix (\bits -> 0 : tail [y | x <- bits , y <- [x,x + 1]])' is as good as it gets.
20:04:56 <ski> yes
20:05:18 <Cale> hmm
20:05:21 <otters> > (\(0:ns) -> ns) [1..10
20:05:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:05:24 <otters> > (\(0:ns) -> ns) [1..10]
20:05:25 <lambdabot>   *Exception: <interactive>:3:1-13: Non-exhaustive patterns in lambda
20:05:52 <ski> BMeph : i didn't recognize it before, but when i rewrote in terms of `/\/', i recalled pondering this before, and deciding that i need something like `tail' there to ignore the initial `0' to be able to set it to that
20:06:12 <BMeph> Cale: What, you're actually Pondering?!? :)
20:06:13 <ski> BMeph : an alternative might be to use something like conal's `unamb'
20:06:52 <BMeph> ski: Except, as I wrote, 'tail' seems to work just fine there. :)
20:06:56 <ski> > fix (\bits -> (0:undefined) `unamb` [y | x <- bits , y <- [x,x + 1]])  -- or something like that
20:06:57 <lambdabot>   Not in scope: `unamb'
20:07:06 <ski> BMeph : sure, but using `tail' is ugly :)
20:07:16 <ski> it looks like you're forgetting one element
20:07:18 <Cale> > fix ((0 :) . tail . concatMap (\x -> [x,x + 1]))
20:07:20 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
20:07:27 <ski> but in fact the forgotten element is (or will be) `0'
20:07:48 <ski> (i.e. i mean using `tail' for this purpose is semantically ugly)
20:07:49 <BMeph> I mean, it looks like 'tail' so why not just put 'tail' there directly? At least, it's down to a one-element pump-priming, now. :)
20:08:52 <ski> BMeph : anyway, thanks for bringing the relationship between `/\/' and `concatMap' used in this way to my attention :)
20:09:00 <Cale> ^^ I just translated away the list comprehension from ski's version
20:09:47 <BMeph> > fix ((0 :) . tail . (>>= (\x -> [x,x + 1])))
20:09:49 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
20:09:58 <BMeph> cale: ... ;)
20:10:04 <ski> (redundant brackets spotted)
20:10:11 <Cale> Indeed, I had that version before I had the one with concatMap even :P
20:10:12 <BMeph> Er, Cale, rather. :)
20:10:21 <dmwit> ?pl \x -> [x,x+1]
20:10:21 <lambdabot> ap (:) (return . (1 +))
20:10:26 <dmwit> wow
20:10:32 <dmwit> That was... prettier than I expected.
20:11:04 <ski> s/return/(:[])/
20:12:53 <ski> @palomer
20:12:53 <lambdabot> Scalliwags!
20:13:04 <augur> hmm, so ski, i feel like local soundness and local completeness arent quite as dual to one another as i was expected
20:13:26 <ski> augur : did you check the sequent calculus formulation, yet ?
20:14:16 <ski> "R might not go anywhere. its an auxiliary proof. tho i bet its type probably actually needs to be included in the # somewhere" -- hm, ok (which you didn't write)
20:14:26 <augur> ski: but i think the pattern is this:    for soundness, if you have a proof   p : P   with some intros then elims you can always get p' : P without the intros and elims
20:15:19 <augur> and for completeness, if you have   p : P   you can always form a proof   p' : P   that follows p immediately with an elim
20:15:26 <ski> yeah, where you had the elims "following" the intros
20:15:34 <augur> ski: no, i havent seen the sequent version
20:15:35 <ski> (and vice versa for completeness)
20:15:35 <augur> where is it?
20:15:52 <ski> oh, i was thinking you might want to construct it yourself :)
20:16:06 <augur> oh
20:16:10 <augur> no :)
20:16:20 <augur> i really just want an answer to this, i'd rather not waste time if ones out there
20:17:05 <ski> in sequent calculus, the local soundness becomes cut elimination, and the local completeness becomes "id introduction", i think
20:17:43 <ski> no idea if there's an answer out there (though i wouldn't be surprised (i might have read one, and forgot about having done so))
20:17:45 <Nereid> hmm, I don't even know how I'd write the LiftO instance for (I cat)
20:17:53 <augur> ski: hmm. interesting. see, in ND, local soundness is shown, ideally, by making use of cut (ie substitution)
20:17:57 <Nereid> so maybe this is all completely misguided
20:18:11 <augur> ski: im not sure about the local completeness stuff tho
20:18:14 <ski> Nereid : did you try the `Equal' and `GeneralizedNewtypeDeriving' trick ?
20:18:33 <Nereid> remind me what that was?
20:18:59 <Nereid> oh that thing
20:19:10 <augur> ski: i think ideally what i'd like to have is a program that can enumerate connectives with their logically sound and complete inference rules
20:19:24 <augur> er, logcally*
20:19:28 <augur> :|
20:19:30 <augur> locally*
20:19:53 <ski> <ski> Nereid : iirc, one can also do something like `class Equal a b where cast :: c a -> c b', `instance Equal a a where cast = id' and do `newtype L f a i = MkL (f (a i)) deriving Equal (f a i)' (i can't find the message describing this atm)
20:19:57 <ski> <ski> Nereid : you'll probably have to do `newtype Temp cat f a i x = T (cat (f (a i)) x)', and then set `c' to `Temp cat f a i' for this
20:20:46 <ski> augur : heh, enumerate how ? :)
20:20:55 <ski> enumerate all possible connectives ?
20:21:38 <otters> sounds like a job for TH
20:22:07 <ski> or possibly lambdaProlog or Twelf
20:22:57 <Nereid> ski: I don't understand how to make the deriving work.
20:23:00 <ski> otters : no relation to the Otter theorem prover, yes ?
20:23:49 <otters> not that I know of
20:24:35 <ski> Nereid : the idea above is that we already know `Equal (f (a i)) (f (a i))' (it's an instance of the general instance, *cough*), and then we can use `GeneralizedNewtypeDeriving' to derive `Equal (f (a i))' on `L f a i', getting an `Equal (f (a i)) (L f a i)' instance which basically uses the same dictionary
20:24:52 <Nereid> ski: yes, I understand that. but it spits out an error when I try to derive it.
20:25:03 <Nereid> wait.
20:25:13 <Nereid> yeah.
20:25:20 <ski> the error is ?
20:25:47 <Nereid> Cannot derive well-kinded instance of form `Equal * (f (a i)) (O ...)'
20:25:48 <Nereid>       Class `Equal' expects an argument of kind `k'
20:25:50 <ski> (note that i didn't try this myself, i only read a message on the mailing list (i think) which explained it -- it might not work any longer)
20:26:35 <ski> hm, perhaps that is the `PolyKinds' thing not being fully done yet
20:26:40 <Nereid> perhaps
20:26:48 <ski> you could try asking on the mailing list, i suppose
20:27:09 <Nereid> mailing lists scary.
20:27:12 <ski> (:
20:27:54 <ski> nule : `filterM' ?
20:27:59 <dobie_gillis> i have libsdl installed with macports, how do i tell cabal where to look for those libraries?
20:28:23 <ski> @hoogle filterM
20:28:23 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
20:28:23 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
20:29:02 <ski> nule : the general answer is : make your high-order function polymorphic in any monad, like `filterM' is
20:29:49 <ski> nule : then, if you want to use it with some non-monadic stuff, use the `Identity' monad
20:30:11 <dobie_gillis> nm i found what i'm looking for in ~/.cabal/config
20:34:34 <augur> ski:    for  Elim_i(Intro_j(Ps, As), Bs) : Q   there is a template T_{i,j} without the connective s.t. T_{i,}(Ps, As, Bs) : Q   (local soundness)
20:35:22 <augur> for   D : P   Elim_i   and   As   there is a template T_i s.t.   T_i(Elim_i(D, As)) : P
20:35:30 <augur> i think thats correct
20:36:01 <augur> for elimination, T_{i,j} would ideally use only substitution
20:36:10 <augur> er, sorry, for soundness
20:36:20 <augur> and for completeness, T_i would use only the connective
20:42:32 <nule> ski: thanks - I'll try to process what you're suggesting
20:54:04 <hpaste> mchm pasted “wx” at http://hpaste.org/71757
20:54:56 <mchm> Hi. I've followed these instructions: http://en.wikibooks.org/wiki/Haskell/GUI    to generate a simple GUI, but it doesn't work. I get the above error when compiling.
20:55:26 <mchm> I'm under OSX 10.6.8 with GHC 7.4.1
20:57:25 <hpaste> ski annotated “Passing different tests to a function (mixing IO and non-IO)” with “making it polymorphic in any monad (untested)” at http://hpaste.org/71752#a71758
20:57:39 <mchm> Surprisingly (to me), I can run ghci -package wx   alright.
20:57:56 <mchm> But then when I load the basic program and execute it, GHC crashes.
21:12:38 <dmwit> mchm: That's a pretty well-known Mac problem, I think. Did you Google around a bit for information on iconv+ghc+osx?
21:15:13 <mchm> dmwit: yes, but the workarounds didn't work yet.
21:16:21 <dmwit> ah, bad news
21:17:20 <mchm> I'm going to try installing it with Homebrew
21:17:30 <mchm> instead of MPorts, seems like that's the problem.
21:18:01 <mchm> Now if _that_ doesn't work... I'll have no choice but to fall back to Python.
21:18:09 * mchm crosses fingers
21:33:36 <esato> @pl
21:33:37 <lambdabot> (line 1, column 1):
21:33:37 <lambdabot> unexpected end of input
21:33:37 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
21:33:56 <esato> @pl take 10 [1..100]
21:33:56 <lambdabot> take 10 [1..100]
21:37:23 <esato> ]
21:39:35 <c_wraith> > fix $ (0:) . scanl (+) 1
21:39:37 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:47:23 <dmwit> > foldl f z [a,b,c]
21:47:24 <lambdabot>   f (f (f z a) b) c
21:47:54 <dmwit> > foldr f z [a,b,c]
21:47:55 <lambdabot>   f a (f b (f c z))
21:48:19 <dmwit> > foldl1 f ([a,b,c] ++ [z])
21:48:21 <lambdabot>   f (f (f a b) c) z
21:49:48 <mchm> dmwit: still getting an error when installed from Homebrew, albeit a different one. No luck.
21:51:41 <dmwit> And you've pointed the appropriate tools away from the iconv that ships with OSX and towards the one you installed with HomeBrew/MacPorts?
21:51:55 * dmwit cargo cults his suggestions from memory
21:52:17 <kallisti_> > (())
21:52:18 <lambdabot>   ()
21:55:34 <mchm> dmwit: I've done my homework.
21:55:56 <mchm> I even removed MacPorts entirely.
22:05:24 <pqmodn> @pl x /= 0 && x /= 1
22:05:25 <lambdabot> x /= 0 && x /= 1
22:05:37 <coppro> what is /=?
22:05:45 <pqmodn> not equals
22:05:56 <coppro> !=
22:06:00 <coppro> isn't it?
22:06:06 <coppro> or am I confusing languages again
22:06:07 <Nereid> != isn't a valid operator name in haskell
22:06:07 <pqmodn> right, in Haskell it's written /=
22:06:12 <coppro> derp
22:06:14 <coppro> ok
22:06:36 <Nereid> oh wait, it is
22:06:38 <Nereid> oh well
22:06:42 <coppro> pqmodn: the answer is flip map [0,1] . (/=)
22:06:56 <coppro> no wait
22:07:08 <coppro> and . flip map [0,1] . (/=)
22:07:13 <coppro> that's one solution
22:07:16 <coppro> I think there's a better one
22:07:32 <Nereid> @pl \x -> x /= 0 && x /= 1
22:07:32 <lambdabot> liftM2 (&&) (0 /=) (1 /=)
22:07:42 <startling> edwardk: ping
22:07:50 <edwardk> pong-ish
22:08:08 <startling> edwardk: http://ekmett.github.com/trifecta/ is linked to from https://github.com/ekmett/trifecta, doesn't appear to exist
22:08:14 <Nereid> oh of course, ! can go in operator names. I saw one like that the other day.
22:08:31 <edwardk> ah, i think the gh-pages site got eaten a while back
22:08:46 <edwardk> i originally linked there because there were problems with the hackage docs
22:08:46 <augur> ski: i now have a type in agda that represents the ND proof system
22:08:49 <augur> in the abstract
22:08:53 <edwardk> they have since fixed those
22:08:59 <startling> edwardk: ah. anyway, figured you might want to know
22:09:01 <edwardk> i should probably just flip the doc link over to hackage
22:09:04 <edwardk> much obliged
22:10:07 <Nereid> I should actually learn how to use git one day. I'm used to hg so I'm sure it wouldn't take too long though.
22:11:54 <startling> edwardk, by the by, do you have a simple trifecta example up somewhere?
22:12:35 <edwardk> startling: not publicly available, i suppose dylukes 'winchester stg' is probably the most available
22:12:44 <dylukes> Wut?
22:12:53 <dylukes> It's not quite "simple"
22:13:01 <dylukes> it's more of an intermediate example, but yeah.
22:13:08 <edwardk> https://github.com/DylanLukes/Winchester-STG-Compiler/blob/master/WSC/Parser.hs
22:14:09 <startling> edwardk, dylukes: that'll do nicely, thanks
22:14:28 <startling> just wasn't really sure where to get started in the docs, what to import, etc
22:14:41 <dylukes> Depends what you're using.
22:14:45 <dylukes> edwardk: Did you fix that bug in semi?
22:14:49 <startling> -- This is annoying. Make sure edwardk fixes it...
22:14:51 <dylukes> (it not being a lexeme parser)
22:14:57 <dylukes> Yeah that hahaha.
22:15:08 <edwardk> dylukes: don't recall the bug =)
22:15:13 <dylukes> "semi = lexeme Trifecta.semi"
22:15:18 <dylukes> I had to add that.
22:15:30 <edwardk> oh, then that should be alright
22:15:42 <edwardk> the new trifecta is a bit different in that regard
22:17:28 <ski> nule : did you see my paste above ?
22:17:54 <ski> (i had/have some connection trouble atm, apparently)
22:18:41 <ski> nule : i forgot to show how your `testFunc' in this case is basically the same as `filterM', but i hope you can see it anyway
22:20:14 <ski> @type let (!=) = (/=) in (!=)
22:20:16 <lambdabot> forall a. (Eq a) => a -> a -> Bool
22:21:01 <ski> augur : hm, ok
22:22:00 <ski> (the paper appears not to have changed yet)
22:29:31 <startling> is there a way I can see where something was imported from in ghci?
22:30:43 <augur> ski: oh no i dont mean in the CH paper
22:30:43 <startling> ah, :info
22:30:57 <augur> ski: i mean for experimenting with logicality
22:31:45 <ski> startling : you can also use `:browse ModuleName' to see what's brought into scope by that module
22:31:59 * ski nods
22:40:36 <dylukes> I think honestly the Language parser is too specific to be very useful edwardk.
22:40:42 <edwardk> i agree
22:40:47 <edwardk> thats why its not in trifecta 0.9 ;)
22:41:15 <dylukes> 0.9?
22:41:22 <dylukes> Skipping over 0.54-0.8?
22:41:26 <edwardk> 0.90 on github is my working branch
22:41:32 <edwardk> its a big change
22:41:42 <edwardk> and its my test branch for 1.0
22:42:09 <edwardk> i wanted to leave enough major version numbers between 0.54 and that test branch
22:42:09 <startling> edwardk, so what do I do with a parse function? do you have a thing like parsec's testParse for playing around in ghci?
22:42:20 <dylukes> 0.9 seems...
22:42:22 <dylukes> really slimmed down.
22:42:26 <dylukes> In a good way.
22:42:29 <edwardk> dylukes: =)
22:42:37 <edwardk> startling: yes
22:42:47 <edwardk> check Text.Trifecta.Parser.ByteString
22:42:58 <edwardk> dylukes: most of the heavy lifting is delegated to parsers
22:43:08 <edwardk> which provides all the classes
22:43:24 <edwardk> i plan to make support packages to re-export the missing functionality for layout, etc.
22:43:39 <dylukes> Wait... is it supposed to have no subdirectories under Text/Trifecta except Util?
22:43:48 <dylukes> there's no other branches...
22:44:05 <edwardk> but i wanted to separate the 'soup of parsing combinators' that parsers provides and the actual parsing functionality
22:44:06 <edwardk> yes
22:44:07 <dylukes> Oh, parsers.
22:44:08 <dylukes> I see.
22:44:18 <dylukes> So Trifecta is the features, excellent.
22:44:26 <edwardk> so parsers makes the combinators work, and trifecta is just the clang-style diagnostic support
22:44:37 <startling> edwardk: thanks
22:44:51 <dylukes> not naming it trifecta-parsers?
22:45:31 <edwardk> dylukes: well, its 'trifecta' still, it just uses parsers, whereas i'll export parsers-attoparsec and parsers-parsec soon enough to let them take advantage of the combinators
22:45:55 <edwardk> renaming the package is awkward for users and brittle
22:46:15 <dylukes> True...
22:46:21 <edwardk> since you get all the 'multiple packages export this module' errors
22:46:42 <edwardk> and people have to use ghc-pkg hiding manually
22:46:46 <edwardk> or use cabal
22:47:10 <dylukes> or just ghc-pkg unregister the old one...
22:47:23 <edwardk> just an awkward process to expect of an end user
22:47:47 <edwardk> given the number of complaints i've had about it in the past i'm not prone to do it again, also, here it really is the 'trifecta' package
22:47:59 <edwardk> and the foo-parsers packages are a bad design anyways
22:48:05 <edwardk> the instances are forced to be orphans
22:48:11 <edwardk> i hate orphan instance packages
22:48:22 <startling> orphan instance packages?
22:48:40 <edwardk> startling: when you make a package just to hold onto orphan instances =)
22:49:05 <edwardk> an orphan instance is when the instance is defined in a module that defines neither the class nor the data type
22:49:12 <startling> edwardk: ah
22:49:49 <edwardk> there is nothing preventing someone else from making a simialr but different orphan instance in another package or module and then having you import both in another module, causing everything to blow up
22:49:51 <edwardk> orphans are bad
22:50:03 <edwardk> (apologies to any actual orphans in the audience)
22:52:52 <startling> edwardk: understood
23:05:39 <hpaste> tgeeky pasted “is this isom actually possible to implement in some domain?” at http://hpaste.org/71761
23:06:03 * tgeeky_ thinks that's pretty clever, if it works :o
23:07:36 <Tukeke> http://goo.gl/gEcDi
23:07:38 <Tukeke> xD
23:08:30 <Peaker> tgeeky, what the heck are those names? :)
23:08:56 <Peaker> [(...)] is a bit funny
23:09:11 <shachaf> Peaker: Colors, maybe?
23:09:48 <Peaker> ORGB/CMYI is probably Opacity/RGB and CMY/index? but no idea what dddz ddk, etc are
23:09:51 <tgeeky_> d can stand for default or derivative
23:09:55 <tgeeky_> depending on how you see it
23:10:02 <shachaf> What's ZRGB?
23:10:21 <tgeeky_> RGB, with explicit annotation of the fact that the colors R G and B are additive starting from a least fixed point
23:10:33 <tgeeky_> whereas CMYK is subtractive from a greatest
23:10:39 <shachaf> *Is* that actually isomorphic to CMYK?
23:10:58 <shachaf> ("fixed point"? Of what?)
23:11:17 <tgeeky_> shachaf: both good questions
23:12:17 <tgeeky_> shachaf: the "fixed point" is the pair (zero,one)
23:12:35 <tgeeky_> it should define a pair of (wave)length scales
23:12:48 <dmwit> What is the function that (zero,one) is a fixed point of?
23:19:28 <Enigmagic> is there a metric typeclass somewhere that i should be using before i go make another one? i need to generalize some code for measuring distance that currently uses doubles.
23:20:20 <Peaker> Enigmagic, why type-class?
23:20:25 <Peaker> Enigmagic, why not a newtype?
23:20:36 <Enigmagic> Peaker: a newtype of what?
23:21:09 <Peaker> Enigmagic, Double, or parameterized? newtype Metric a = Metric { inMeters :: a } deriving (Num)
23:21:33 <Peaker> or if you're willing to commit to Double: newtype Metric = Metric { inMeters :: Double }
23:21:34 <Nereid> I imagine something like class Num n => MetricSpace a n where dist :: a -> a -> n
23:21:35 <Nereid> ?
23:21:41 <Nereid> I dunno
23:21:46 <Enigmagic> Peaker: i have complicated structures and i need to measure the distance between them
23:21:48 <Peaker> that sounds much more general than metric
23:21:59 <Peaker> Unless you just means "measurable"?
23:22:04 <Enigmagic> Peaker: http://en.wikipedia.org/wiki/Metric_(mathematics)
23:22:11 <Nereid> ^ I'm just copying that.
23:22:21 <Peaker> Enigmagic, oh :)
23:22:57 <Peaker> Enigmagic, what kind of methods do you have in the class? I think edwardk has some classes for some kinds of measurements
23:23:23 <tgeeky_> dmwit: I'm not really sure. The point is to pick a set of colors from both spaces (where a color corresponds is a range of wavelengths), pick some small patches from each of these colors (which are small areas, or points), and try to find both an inner and outer product
23:24:11 <Peaker> Enigmagic, http://www.reddit.com/r/haskell/comments/wn882/clarification_classy_prelude/c5ewsyc <-- might be relevant
23:24:52 <tgeeky_> maybe better stated: try to find a set of points in both spaces which allow you to: reference the space locally (in this case, in the visible spectrum) but also project out the IR and UV fixed points
23:25:25 <tgeeky_> dmwit: in that case, I mean the fixed points are cutoffs...
23:25:45 <Nereid> tgeeky_: I haven't been able to make sense of anything you've said so far.
23:25:46 <tgeeky_> but I'm not sure if that's the same thing I mean by fix point for the pair (zero,one)
23:26:01 <Grahack> hi all, could someone explain a bit the *Main> idiom in literate Haskell, and maybe a link to some doc?
23:26:05 <tgeeky_> Nereid: ok, you know that you can assign a wavelength to every color of light, yes?
23:26:34 <Nereid> well, you can't, but go on
23:26:44 <tgeeky_> well, the inverse relationship is already defined
23:26:51 <Enigmagic> Peaker: not quite what i want. i'll just make a new type class..
23:26:52 <tgeeky_> and you can change the gauge from underneath the length scale
23:26:58 <Nereid> still not making sense :)
23:27:06 <tgeeky_> Do you have any physics training?
23:27:10 <Nereid> I have a degree in it
23:27:15 <tgeeky_> what kind?
23:27:18 <Nereid> physics
23:27:27 <tgeeky_> ... what kind of degree
23:27:36 <Nereid> B.Sc.
23:27:50 <Nereid> I don't see how that's relevant though
23:29:00 <tgeeky_> Ok, so you don't agree that you can design a short algorithim to give you a color, given a wavelength?
23:29:08 <Nereid> I'm sure you could.
23:29:47 <shachaf> Grahack: It's not a literate Haskell thing, it's a ghci thing.
23:29:50 <Nereid> but some colours can't be obtained with light of a single wavelength.
23:29:56 <Nereid> e.g. white
23:30:01 <tgeeky_> white isn't a color
23:30:11 <shachaf> tgeeky_: A color isn't the same thing as a wavelength.
23:30:13 <Nereid> this is nwes to me
23:30:15 <Nereid> news
23:30:20 <shachaf> Ah, you just said that.
23:30:35 <tgeeky_> white isn't listed in my list of colors either
23:30:40 <edwardk> tgeeky_: you can't get pure tristimulus responses from a given wavelength is i think his concern ;)
23:30:41 <tgeeky_> and I'm quotienting out what "black" and "white" are
23:30:48 <Nereid> first words of a wikipedia article
23:30:49 <Nereid> "White is a color"
23:31:10 <shachaf> Yay, arguments about words.
23:31:12 <Grahack> shachaf: I guess it's used to emulate ghci sessions but I can't find any doc about that
23:31:14 <tgeeky_> White isn't a wavelength of photon
23:31:21 <Nereid> yes, and colours aren't wavelengths
23:31:25 <shachaf> Grahack: It doesn't mean anything to GHC.
23:31:32 <tgeeky_> Right, so by the definition I'm using, white isn't a color
23:31:34 <shachaf> It's just a comment, in a literate Haskell file.
23:31:36 <shachaf> Just like everything else.
23:31:45 <coppro> is literate haskell common?
23:31:49 <shachaf> tgeeky_: There's already a word for "wavelength".
23:31:52 <shachaf> It's "wavelength".
23:31:55 <coppro> and how does it interact with haddock
23:31:56 <coppro> ?
23:31:57 <edwardk> shachaf++
23:31:59 <edwardk> =)
23:32:16 <tgeeky_> shachaf: I'm not directly mentioning wavelength
23:32:23 <tgeeky_> I'm only doing that to explain
23:32:23 <Nereid> here's a picture for you http://en.wikipedia.org/wiki/File:CIExy1931.png
23:32:38 <pqmodn> @hoogle Applicative f => f Bool -> f a -> f a -> f a
23:32:39 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
23:32:39 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
23:32:39 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
23:33:01 <tgeeky_> Nereid: the whole point of this color system is to make white and black relative
23:33:01 <edwardk> i need to finish up and release my colorimetry package
23:33:12 <Nereid> since when was black relative
23:33:34 <edwardk> black is fine as an absolute. for any given color space you pick a white point
23:34:14 <tgeeky_> edwardk: I'm aware of each color space by itself.
23:34:17 <edwardk> tgeeky_: what is it you are trying to do?
23:34:26 <tgeeky_> edwardk: model the structure of a group
23:34:29 <tgeeky_> Rudvalis
23:34:31 <Nereid> :(
23:34:51 <tgeeky_> Nereid: you must not have taken very advanced physics.
23:34:55 <tgeeky_> "Black" would correspond to zero temperature
23:34:57 <tgeeky_> which doesn't exist
23:35:04 <Nereid> it corresponds to no light
23:35:06 <edwardk> so why are you working with r g and b in the first place?
23:35:06 <tgeeky_> White would correspond to infinite temperature, which doesn't exist
23:35:10 <tgeeky_> No, it doesn't
23:35:17 <Nereid> white does not correspond to infinite temperature, either
23:35:18 <tgeeky_> the blackest things in the universe emit radiation
23:35:33 <tgeeky_> Nereid: no, it doesn't, technically, because we have eyes and we have naming conventions.
23:35:42 <edwardk> just take a bunch of wavelengths, and track those, that way you can deal with the differences in how they combine when you have reflected or direct light, etc.
23:36:04 <Nereid> no, look
23:36:12 <Nereid> black things are black because they absorb all radiation.
23:36:34 <edwardk> Nereid: his point is that background radiation exists, which is technically correct but largely irrelevant ;)
23:36:35 <tgeeky_> except that definition totally fails at the quantum level
23:36:46 <tgeeky_> edwardk: it's not irrelevant if you actually care about the physics :)
23:37:06 <Nereid> tgeeky_: uh, no, not really.
23:37:12 <edwardk> lets just say that nobody who models visible wavelength is doing so at a granularity where background radiation is a relevant effect =P
23:37:12 <Nereid> I'm not interested in continuing this conversation though.
23:37:18 <mroman> @hoogle Boolean
23:37:18 <lambdabot> package Boolean
23:37:18 <lambdabot> package AC-Boolean
23:37:18 <lambdabot> package Vec-Boolean
23:38:37 <shachaf> tgeeky_: I don't think "R G B" and "quantum level" ever ought to appear in the same conversation about light.
23:38:54 <edwardk> just like how nobody who is concerned with colorimetry, which is a function of perceptual response, lumens, and all perfectly good physically measurable quantities is concerned with an infinite amount of energy coverying all wavelengths
23:38:56 <tgeeky_> shachaf: I told you, these are just index names for the structure of a group
23:39:06 <edwardk> what group?
23:39:06 <pqmodn> @hoogle Bool -> a -> a -> a
23:39:07 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
23:39:07 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
23:39:07 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
23:39:10 <tgeeky_> Rudvalis
23:39:22 <Nereid> who knows why that has anything to do with RGB.
23:39:48 <edwardk> what does the rudvalis group have to do with rgb?
23:40:19 <tgeeky_> edwardk: it doesn't! I just chose suggestive names!
23:40:29 <Nereid> so why are you talking about wavelengths of light.
23:40:36 <edwardk> ok, then what does it have to do with light?
23:40:51 <edwardk> since rgb is a crappy abstraction over light in the first place ;)
23:41:04 <tgeeky_> because I want to try and model a bijection between color spaces using the model
23:41:21 <Nereid> sounds silly at best
23:41:23 <tgeeky_> s/model/group/
23:41:32 <tgeeky_> Nereid: I didn't seek your approval
23:41:51 <Ralith_> tgeeky_: if you want a fully general concept of colors, you should handle them as continuous distributions of intensity over wavelengths
23:41:52 <Nereid> so what, I said it anyway
23:42:02 <edwardk> erm, how/why? rudvalis has a finite number of dimensions, no?
23:42:15 <Nereid> it's a finite group
23:42:18 <edwardk> yeah
23:42:20 <tgeeky_> edwardk: all representations do
23:42:59 <tgeeky_> Ralith_: I want a discrete concept of color
23:43:15 <edwardk> i'm not seeing how you can connect this to mapping between different quotients over the set of visible wavelengths
23:43:28 <Ralith_> tgeeky_: no such thing exists
23:43:36 <tgeeky_> uhh
23:43:39 <tgeeky_> [red,green,blue]
23:43:53 <edwardk> [red,green,blue] aren't even tristimulus responses
23:43:55 <tgeeky_> not very comprehensive, but it is discrete
23:44:08 <mroman> How does undecidable instances work?
23:44:21 <Ralith_> so by "discrete" you just mean "has multiple parts"?
23:44:25 <mroman> if I have an instance (Num a) => Foo
23:44:35 <mroman> and instance Foo String
23:44:47 <mroman> it can't decide no more which to use even String clearly is not Num?
23:44:55 <shachaf> mroman: String is not clearly not Num.
23:44:58 <edwardk> there is no finite basis that covers the entire color gamut without including virtual colors, so any [r,g,b] basis is necessarily going to include a number of non-existent colors
23:45:02 <shachaf> instance Num String -- what now?
23:45:03 <Nereid> what if you defined a Num instance for String?
23:45:19 <mroman> shachaf: That's an other case then.
23:45:21 <shachaf> (Well, other than than fact that you can't do that.)
23:45:31 <shachaf> mroman: No, that's your case. Someone else might define that instance.
23:45:39 <mroman> Yes. So?
23:45:46 <mroman> As long as no instance String exists?
23:45:51 <shachaf> So it would break your code.
23:45:52 <Nereid> so ghc doesn't assume that no one will define such an instance
23:45:52 <shachaf> There's this rule that someone else defining an instance shouldn't break existing code.
23:45:55 <mroman> (and it is possible with flexible instances)
23:46:12 <shachaf> It's a good rule.
23:46:13 <Nereid> I think you mean OverlappingInstances.
23:46:21 <tgeeky_> edwardk: yes, that is a real problem. I was hoping that there is some magical cancellation (that is, I am hoping that you can always remove the nonexistant colors from one of the two spaces)
23:46:32 <shachaf> What's Foo, anyway? It's probably something you shouldn't be doing. :-(
23:46:53 <edwardk> tgeeky_: the problem is both spaces have different non-representable colors, and when mapping between spaces what you should do is very VERY application specific
23:47:09 <tgeeky_> edwardk: yeah, but I'm hoping that's already taken care of :)
23:47:41 <edwardk> by the color fairy?
23:47:54 <tgeeky_> edwardk: by the bizzare group structure
23:48:12 <mroman> shachaf: https://github.com/FMNSSun/hs-experiments/blob/master/bits.hs#L16
23:48:14 <edwardk> i don't see how this group does anything magic here
23:48:15 <Nereid> why that group, and not some other finite group?
23:48:21 <mroman> I thought it might be useful to make that an instance
23:48:26 <edwardk> its just a big finite group
23:48:34 <mroman> so it *could* work for more than just Bits a =>
23:49:03 <ski> tgeeky_ : why is `ZRGB o r g b' avariant in `o' and `CMYK y m c i' avariant in `i' ?
23:49:20 <Nereid> why everything
23:49:58 <ski> (Peaker : .. i might rename the data constructor from `Metric' to `Meters')
23:50:50 <edwardk> mind you i'd love to be proven wrong here, but only because i can see no sane way in which you can connect this stuff ;)
23:50:53 <mroman> Else I'd have to create an istance for every type that has a Bits instance
23:50:57 <mroman> und that'd suck.
23:51:08 <edwardk> mroman: you have to create an instance for every type that has a bits instance =P
23:51:12 <mroman> Codesize wise, effort wise and compatibility wise.
23:51:15 <edwardk> mroman: the alternative is actually worse
23:51:27 <mroman> If he updates Bits, then I have to update mine.
23:51:33 <mroman> => not cool
23:51:41 <edwardk> yep
23:52:00 <edwardk> honestly i just want the Num dep on bits to go away so we can make a Bits instance for Bool and be done with it =P
23:52:18 <edwardk> now
23:52:30 <edwardk> you can ease the pain
23:52:48 <edwardk> you can make a fromBoolsDefault :: Bits a => Endianness -> [Bool] -> a
23:52:51 <mroman> I'd write me a little code generater for that.
23:52:54 <edwardk> and toBoolsDefault ...
23:53:00 <edwardk> and you can use default signatures
23:53:22 <mroman> So.. my class has toBools and toBoolsDefault?
23:53:23 <edwardk> default fromBools :: Bits a => Endianness -> [Bool] -> a; fromBools = fromBoolsDefault; ...
23:53:26 <edwardk> n
23:53:28 <edwardk> er no
23:53:35 <edwardk> just put the toBoolsDefault outside the class
23:53:44 <edwardk> then you can make people instantiate it for Bits types with
23:53:53 <mroman> Ah.
23:53:58 <mroman> I get what you mean.
23:54:04 <edwardk> instance BoolBits Int where fromBools = fromBoolsDefault; toBools = toBoolsDefault
23:54:05 <shachaf> data Endianness = Big | Little | Dep
23:54:06 <tgeeky_> Nereid: your antagonism isn't really necessary. And when you go on to study more advanced theory in physics (though not too advanced), and you try simple black hole split emission/absorption, you'll learn about there being no such thing as "black", why that's the same thing as there being no zero temperature, and why black holes' temperature <=> mass relationship is the opposite of what you might expect
23:54:22 <edwardk> and with DefaultSignatures you can go one step further
23:54:28 <Nereid> I don't pretend to know anything about black holes.
23:54:38 <edwardk> tgeeky: i think everyone involved in this discussion knows about background radiation
23:55:03 <edwardk> tgeeky: but it still doesn't answer why the rudvalis group helps here =)
23:55:14 <tgeeky_> edwardk: of course it doesn't. hehe.
23:55:15 <shachaf> tgeeky_: As far as I can tell you're being rather more hostile here...
23:55:28 <tgeeky_> I have a group, I translated part of its structure into this thing you see here
23:55:31 <edwardk> with DefaultSignatures the overhead is reduced to 'instance BoolBits Int'
23:55:32 <shachaf> And no one is even appreciating my pun!
23:55:49 <edwardk> shachaf: =P
23:55:55 <mroman> That is an extension @DefaultSignature?
23:56:00 <edwardk> mroman: yeah
23:56:19 <edwardk> what thing i see here?
23:56:26 <tgeeky_> shachaf: I'm not being hostile. I originally asked about physics background because it's incorrect for me to assume any.
23:56:28 <edwardk> DefaultSignatures
23:56:49 <edwardk> and he answered that he had a b.s. in it, and you proceeded to make up a new definition for color ;)
23:57:47 <edwardk> while getting hung up on an irrelevant detail about background radiation ;)
23:58:30 <edwardk> unless the existence of background radiation ties into how you plan to abuse the rudvalis group
23:58:46 <edwardk> but i still see no connection between that group and light/wavelength/color
23:58:47 <tgeeky_> edwardk: background radiation just proves that there is no such thing as black
23:58:54 <tgeeky_> edwardk: that's it
23:59:11 <tgeeky_> black and zero temperature are ill defined concepts
