00:00:21 <Enigmagic> JoeyA: and it makes it obvious that it's a normal/expected case
00:00:41 <JoeyA> But I can knock out a mask_, forkIOWithUnmask, and onException if I assume it's okay to let BlockedIndefinitelyOnMVar happen.
00:00:58 <shachaf> Enigmagic: Is it any exceptions?
00:01:14 <shachaf> I thought it was only specific ones like killThread and BlockedIndefinitelyOnMVar
00:01:22 <Enigmagic> shachaf: it's all exceptions
00:03:03 <shachaf> Odd.
00:03:11 <Digit> head, tail, drop and take, dont count from zero, but suffixing a "!!n" does.  :/  that'll get annoying.  ^_^ methinks i'd make a new function out of take and drop, so i can have a consistent counting method.  really starting to love haskell the more i learn.
00:03:39 <shachaf> Digit: They all count from 0.
00:03:46 <shachaf> Well, except for head and tail, which don't count at all.
00:03:53 <JoeyA> Enigmagic: No, it prints other exceptions, I'm pretty sure.
00:03:58 <Digit> oh yeah.  ^_^
00:03:58 * JoeyA puts together a simple test.
00:04:12 <Veinor> programs only start from zero when it comes to ordinals. the parameter in take/drop is a cardinal.
00:04:14 <shachaf> Digit: Also, get in the habit of not using functions like !! at all.
00:04:21 <Digit> but no, take and drop dont seem to.  they seem to count from 1.  if i drop 3, it drops 3.
00:04:31 <shachaf> Right.
00:04:35 <shachaf> And if you drop 0, it drops 0.
00:04:38 <shachaf> That's counting from 0.
00:04:49 <Digit> oh right.  ^_^  ok.
00:05:09 <shachaf> People don't zero-index lists because it makes things subtly awkward and off-by-1. They zero-index lists because it works out more nicely.
00:06:22 <JoeyA> Enigmagic: Oh, you're right.  It is all exceptions, apparently.
00:06:28 <JoeyA> Except the main thread.
00:08:32 <Enigmagic> JoeyA: ask me how i know ;)
00:09:02 <Enigmagic> that's why all of our apps setup an unhandled exception handler that raises SIGABRT and core dumps
00:09:59 <JoeyA> Thanks for pointing that out.
00:11:19 <shachaf> Enigmagic: I guess you do that by replacing forkIO?
00:11:27 <Digit> in ghci, how can i see the definition of an existing function?
00:11:33 <shachaf> Digit: You can't.
00:12:20 <shachaf> What do you do about libraries that forkIO directly?
00:12:37 <Enigmagic> shachaf: nope, GHC.Conc.setUncaughtExceptionHandler here's the code: https://gist.github.com/97540a0ae42860ef953b
00:13:39 <shachaf> Ah, neat.
00:13:41 <Digit> is there a way to see the definition of existing functions at all??
00:14:08 <JoeyA> So setUncaughtExceptionHandler applies globally?
00:14:14 <Enigmagic> JoeyA: yes
00:14:17 <kallisti> Digit: look them up the source code.
00:14:24 <shachaf> SomeException NoException
00:14:39 <JoeyA> Aight, then I have to spam concurrency/exception stuff to implement my forkSetup function correctly.
00:15:07 <Enigmagic> shachaf: yeah well, better than undefined ... even though I only use that for debugging cores
00:15:18 <JoeyA> I still don't have a clear answer as to whether it's safe to say mask $ \restore -> forkIO $ foo restore
00:15:38 <JoeyA> Rather than requiring base 4.4 and using forkIOWithUnmask
00:16:02 <Enigmagic> i don't think that's safe since the masking is done on the thread
00:16:28 <shachaf> Having stepped through some GHC-generated code in gdb, I still find it a bit miraculous that you manage to extract useful information from core dumps. :-)
00:17:31 <Enigmagic> shachaf: having line numbers helps a lot even without local symbols
00:17:55 <Enigmagic> remember we have hacked up ghc, not vanilla ghc :)
00:18:15 <kallisti> it would be nice to have a tool like valgrind, for low-level debugging.
00:18:15 <shachaf> I suppose enough hacking up can get even GHC into debuggable shape.
00:18:36 <Enigmagic> yeah, my 7.4.1 ghc even has debug symbols
00:19:07 <Enigmagic> nothing like watching the linker use 15 gigs of ram :\
00:21:06 <Enigmagic> kallisti: it's definitely possible, though not many people seem interested enough in low level debugging and performance optimization... at least not yet
00:21:09 <JoeyA> Wait a minute... if I killThread the worker thread for not being able to access the MVar, I still get an uncaught exception.
00:21:13 <dmwit> Isn't valgrind for detecting un-freed memory? GC sort of eliminates the need for that.
00:21:25 <kallisti> Enigmagic: what kinds of bugs could we catch wih a valgrind-like tool?
00:21:36 <kallisti> dmwit: valgrind can do a lot of things
00:21:47 <JoeyA> Since the chances of the setup action failing are so remote, and the consequences so small, I'd prefer to just let BlockedIndefinitelyOnMVar happen.
00:21:49 <kallisti> it translates the code into an intermediate representation, that various backends can then manipulate.
00:21:54 <dmwit> okay =)
00:22:09 <kallisti> one such backend adds tracking statements around memory allocation stuff.
00:22:51 <kallisti> I'm wonder what we could monitor more effectively using this kind of tool.
00:22:53 <kallisti> *wondering
00:23:04 <Enigmagic> kallisti: i'd like to see a runtime strictness analyzer
00:23:26 <Enigmagic> to find overly lazy values in optimized code
00:24:54 <Enigmagic> i've found Instruments (part of XCode) to be useful for finding leaks in code using ffi
00:25:46 <\rs> how to pronounce the word 'homoiconic'?
00:26:11 <kallisti> homo-iconic.  iconic as in "icon"
00:26:27 <shachaf> homoïconic
00:26:49 <Enigmagic> it'd also be nice if there was a way to track resource leaks that would happen if an exception was thrown
00:27:56 <kallisti> we actually just need a regular debugger.
00:28:08 <Digit> http://ww2.cs.mu.oz.au/172/Haskell/tourofprelude.html ahh, just the page i need.
00:28:28 <kallisti> oh nevermind looks like ghci has one of those.
00:28:38 <Enigmagic> kallisti: lol no, no it does not.
00:28:52 <kallisti> well it has step
00:29:01 <Enigmagic> through interpreted code
00:29:15 <kallisti> right, this is sufficient for catching logic errors.
00:29:30 <kallisti> obviously it's not for performance tuning.
00:29:32 <Enigmagic> in small applications that don't use any/many libraries
00:30:27 <Enigmagic> unpacking random libraries so they can be loaded into ghci isn't exactly user friendly
00:30:42 <kallisti> why do you need to do that?
00:30:46 <Enigmagic> it's also fun to try to figure out what libraries to unpack
00:31:11 <kallisti> I guess if you want to debug /other peoples'/ code.
00:31:29 <Enigmagic> right, i call that "debugging".
00:33:41 <kallisti> that's something that would need to change with the way code is distributed.
00:34:07 <Enigmagic> or the way that debugging works...
00:34:23 <Enigmagic> aka: proper debug symbols.
00:34:38 <kallisti> Enigmagic: I'm not familiar with how those work so I can't say much
00:34:51 <kallisti> would it be possible to embed accurate Haskell debugging symbols into a binary?
00:34:59 <Enigmagic> compile with -g and hook up your favorite debugger
00:35:28 <kallisti> ghc has no -g
00:35:43 <Enigmagic> definitely. our patched compiler pulls up fairly accurate source file and line numbers in gdb
00:35:58 <kallisti> oh. awesome.
00:36:03 <Enigmagic> and it tracks STG registers (but not haskell values)
00:36:44 <Enigmagic> and i have some ghetto python extensions for lldb to decode values and types
00:36:47 <shachaf> Enigmagic: Are you planning to get that merged into regular GHC?
00:37:24 <Axman6> I'd love to have lldb support debugging haskell programs
00:38:19 <kallisti> Enigmagic: is there a better way to track values, local variables, etc, than via a bytecode interpreter?
00:38:27 <Enigmagic> shachaf: peter wortmann has been driving most of the work and he's keeping it pretty up to date with GHC head... but i don't think there are immediate plans to merge it into master
00:39:00 <Enigmagic> shachaf: he's integrated some of my changes so that's about as close as it'll get for a while i think
00:39:30 <Enigmagic> kallisti: in general, sure. modify the compiler to track them and emit into the debug symbols.. sounds easy right? :)
00:39:38 <kallisti> uh, no.
00:40:12 <Enigmagic> shachaf: https://github.com/scpmw/ghc/commits/profiling
00:42:55 <Enigmagic> kallisti: i also proved that it's possible to walk the evaluation stack in gdb https://plus.google.com/118432899194915702514/posts/bPF9X3s3iM3
00:43:48 <kallisti> Enigmagic: if ghci could easily load the source code of modules as unpacked by cabal, then it would be pretty easy to debug other people's code.
00:44:28 <kallisti> open source code, that is.
00:45:10 <Enigmagic> kallisti: it's not just the source code, ghci needs to compile the source into bytecode
00:45:22 <Enigmagic> which means dealing with compiler flags
00:45:28 <Enigmagic> the pre-processor
00:45:41 <kallisti> can't it already do that in general?
00:46:03 <Enigmagic> ghci doesn't parse .cabal files afaik
00:46:14 <kallisti> ah, right.
00:47:32 <kallisti> having a user-friendly dynamic debugger would require changes to multiple different tools.
00:49:00 <Enigmagic> unless all the debugging info was stored in debug symbols
00:50:28 <Enigmagic> then it just requires changing all the tools..
00:50:45 <kallisti> heh
00:50:50 <kallisti> but probably in a better way!
00:51:49 <Enigmagic> yeah. maybe one day we'll have ghci that takes LLDB and adds LLVM JIT target to GHC...
01:20:49 <timthelion> do we not have a non blocking takeMVarIfFilled :: MVar a -> IO (Maybe a)
01:21:46 <ClaudiusMaximus> timthelion: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-MVar.html#v:tryTakeMVar
01:22:17 <timthelion> thanks
01:28:55 <archeyDevil> Can a darcs repo be pushed to a server that is only running sftp? i.e darcs push, merges with a folder on a server?
01:37:18 <merijn> So...I find myself facing a paper of category theory and comonads, so it seems I can no longer put off reading up on category theory...Any good intro books/papers?
01:38:18 <Nereid> merijn: how does something like http://en.wikibooks.org/wiki/Haskell/Category_theory  look
01:39:11 <Nereid> just as a quick thing, anyway
01:39:19 <mel-> merijn: there's a rather standard book on the topic: Categories for the working Mathematician.
01:39:26 <mel-> It basically covers everything.
01:39:35 <Nereid> Mac Lane, yes.
01:39:38 <mel-> (by Maclane or something)
01:39:45 <merijn> mel-: How much math background do I need for that one? (If any)
01:39:46 <Nereid> it covers too much. :P
01:40:02 <Nereid> although it's aimed at mathematicians, so it has a bunch of examples from mathematics
01:40:15 <Nereid> and not computer stuff
01:40:16 <mel-> merijn: that's not hard to answer.
01:40:21 <mel-> because....
01:41:28 <mel-> it doesn't really require that you have taken a lot of math courses. you don't need to know about specific technical details or something. but you kind of need to understand math from a certain abstract point of view.
01:41:38 <mel-> (i hope i'm making sense)
01:41:59 <mel-> so, it's an introductory book, but it's not a beginners book, I'd say.
01:42:00 <mel-> :)
01:42:10 <ciaranm> Awodey's a better bet
01:42:17 <mel-> okay
01:42:22 <mel-> don't know that
01:42:24 <ciaranm> then look up monads in Mac Lane afterwards
01:42:40 <ciaranm> Mac Lane also has some rather old fashioned bits...
01:43:24 <merijn> mel-: I just wanted to know whether I'd need a real math background or whether I could just get by with the algebra stuff I learned during CS :p
01:43:52 <ParahSailin__> learning this stuff is really blowing my mind
01:44:17 <merijn> ParahSailin__: That's a common reaction, yes :p
01:44:17 <ciaranm> if you don't have a proper maths background, it'll be hard to find examples of things like adjoint functors that aren't just free/forget
01:44:30 <ciaranm> meaning you'll sort of miss the point of monads
01:44:45 <mel-> merijn: you really need a background when it comes to the way mathematical statements are proven. you don't need a background which e.g. tells you how to solve differential equations.
01:45:06 <ParahSailin__> i realize that a lot of the stuff i was using in python was functional stuff
01:45:36 <merijn> My favorite quote in that regard has to be "Cale: I like how you conveniently gloss over the part where your head explodes."
01:45:50 <merijn> Also, lambdabot is down? :(
01:45:51 <ParahSailin__> still not sure what a monad is, that word keeps popping up
01:46:41 <ciaranm> a monad is just a monoid in the category of endofunctors. what's the problem?
01:46:47 <frerich> ParahSailin_: Don't worry, a quick Google query (or some question in here) will give plenty of explanations which are short, easy to understand, and wrong.
01:46:50 <merijn> ParahSailin__: Don't worry about it, people blow it out of proportion. Mentally just replace it with "an abstraction that provides a convenient interface for many generic programming combinators"
01:48:13 <merijn> ParahSailin__: Function composition combines functions together, monads lets you combine things that can't quite be modelled by just functions
01:48:56 <aleator_> Help! What am I doing wrong here: https://gist.github.com/3128134 ?
01:49:15 <aleator_> I'm obviously benchmarking something else than what I think.
01:49:35 <merijn> My advice, ignore the term and the tutorials, read up on Maybe, lists and Either and typeclasses, then meditate on the type signature of Monad functions and Maybe/[]/Either and enlightenment should be achieved.
01:50:53 <mel-> merijn: i like that advice :)
01:50:53 <merijn> ciaranm: I dislike the "monoid in the category of endofunctors" quote, it scares and confuses newbies needlessly into thinking monads are in any shape or form complex
01:50:54 <ciaranm> my advice, get a pure maths degree
01:51:05 <mikeplus64> ParahSailin__: the literal definition, as far as ghc cares, is that Monad is a typeclass with return, binding and sequencing functions
01:51:16 <ciaranm> merijn: but if you don't know what all those words mean, you don't understand monads
01:51:23 <ciaranm> mikeplus64: bad! bad! bad!
01:51:32 <merijn> ciaranm: I call bullshit
01:51:40 <ciaranm> mikeplus64: you missed the important part: they have to follow certain laws
01:52:16 <mikeplus64> ciaranm: they don't have to and there are widely used monad instances that unfortunately do not
01:52:27 <ciaranm> mikeplus64: ...which are broken
01:52:28 <Nereid> but they should
01:52:39 <mikeplus64> they should definitely
01:52:43 <ciaranm> mikeplus64: >>= doesn't make sense if your monad isn't a monad
01:53:00 <mikeplus64> ciaranm: they (blaze htlm only comes to mind) do it for do notation
01:53:14 <mikeplus64> html*
01:53:18 <ciaranm> yet another reason do notation should be abolished
01:53:33 <ParahSailin__> i dont know most of those impressive terms used in the definition of monad
01:53:43 <ciaranm> ParahSailin__: it's worth learning
01:53:46 <mikeplus64> i don't know about that but just using Data.Monoid's <> would be nicer
01:54:28 <Nereid> well the terms aren't too hard to figure out. an "endofunctor (on Hask)" is a Functor.
01:54:31 <Nereid> so say we have one, called m
01:54:42 <merijn> ParahSailin__: Don't worry, I don't understand many of those either and those I do I understand vaguely
01:54:51 <mikeplus64> if haskell had some kind of dependant typing to enforce the monad, monoid etc. laws it would be very very neat
01:54:57 <ParahSailin__> endofunctor...
01:54:58 <mikeplus64> but i don't think that's possible
01:55:11 <ciaranm> ParahSailin__: an endofunctor is a functor from a category to itself
01:55:19 <ParahSailin__> functor...
01:55:21 <Nereid> it being a monoid means you have natural transformations 1 -> m and m . m -> m
01:55:23 <merijn> ciaranm: You are completely not helping
01:55:36 <Nereid> i.e. functions forall a. a -> m a, and forall a. m (m a) -> m a
01:55:37 <boccato> What does an exclamation mark mean on a 'data' declaration? (ex: data Value = Object !Object)
01:55:41 <ciaranm> merijn: this is how maths is taught
01:55:49 <mikeplus64> boccato: strictness
01:56:10 <Nereid> we normally call these return and join, respectively
01:56:10 <merijn> ciaranm: Except that ParahSailin__ wants to learn haskell, not math. Also, the majority of all math professors are freaking terrible
01:56:12 <Nereid> in haskell, anyway
01:56:42 <boccato> mikeplus64: Got any pointers for me to grasp the syntax and meaning?
01:56:43 <Nereid> return and join have to satisfy certain laws to form a monoid
01:56:48 <Nereid> those are just the monad laws.
01:57:17 <Lamen> I recommend this video: http://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads
01:57:18 <ciaranm> merijn: careful. next you'll be claiming that cs is elitist and that the way to learn haskell is to sit and copy examples from a book like how python is taught now
01:57:19 <mroman> boccato: Strictness
01:57:30 <mikeplus64> boccato: for strictness? you prefix something with a ! and it will ensure that it is evaluated, basically, like let !x = [1..1000] or data X = X !Int !Int
01:57:54 <mroman> boccato: They're called bang patterns
01:58:04 <mroman> In code
01:58:13 <mikeplus64> boccato: strictness just means that something has to be evaluated (ie "bypassing" laziness)
01:58:29 <mroman> on Data it's strictness afaik
01:58:42 <Nereid> so if we wrote Value = Object !Object
01:58:44 <Nereid> well
01:58:46 <Nereid> ok.
01:58:47 <merijn> ParahSailin__: The basic notion is that mathematicians had some useful notions of mathematical objects (i.e. structure + operations on said structure) and it happens that some of these structures map neatly to programming problems, haskell uses the names from maths for these and that's pretty much it. However, this channel tends to have quite a few academics who get all upset if you ignore the math background (which you in fact, easily *c
01:59:12 <Nereid> boccato: so say we have to data declarations
01:59:23 <Nereid> data Lazy a = Lazy a
01:59:26 <Nereid> data Strict a = Strict !a
01:59:35 <merijn> ciaranm: I'm doing nothing of the sort, I like math and CS. I just think most math education I've encountered was quite frankly terrible, so saying that some explanation is "the way math is taught" is hardly an argument in favor of said explanation
01:59:49 <mroman> http://www.haskell.org/onlinereport/decls.html#strictness-flags
01:59:52 <Nereid> these work almost the same way, except for bottom
01:59:53 <Nereid> so
01:59:56 <merijn> ciaranm: Especially when it is overcomplicating simple things for new people who have enough complexity to deal with as-is
02:00:16 <ParahSailin__> merijn, your line was cut off i think
02:00:18 <mel-> I also don't like how maths is taught nowadays.
02:00:21 <Nereid> uh
02:00:23 <Nereid> blah
02:00:24 <ciaranm> merijn: has your exposure to "math education" gone to the point where you've been taught by people who know what they're doing?
02:00:28 <merijn> ParahSailin__: What's the last thing you read?
02:00:38 <ParahSailin__> (which you in fact, easily *
02:00:51 <ciaranm> if i based my view of CS education from what i was taught at school, i'd have a rather poor view of the field...
02:00:52 <boccato> thanks all for the answers, now things are making sense again :)
02:01:01 <merijn> ParahSailin__: Oh, all it said afterwards was "easily can ignore"
02:01:04 <mel-> merijn: it stopped after 'easily *c'
02:01:08 <boccato> Are bang patterns GHC only?
02:01:26 <mikeplus64> doubt it
02:01:28 <ciaranm> boccato: they're nonstandard but widely supported
02:01:37 <boccato> got i
02:01:41 <boccato> it*
02:02:10 <Nereid> well, strictness annotations in data types are standard
02:02:16 <Nereid> I think
02:02:32 <merijn> ciaranm: Define "know what they're doing", I have no clue exactly where our math department stands on the international quality ranking, but they're probably not bad as far as math departments go?
02:03:02 <Nereid> yeah, it's in haskell 98.
02:03:07 <Nereid> bang patterns are when you do stuff like
02:03:16 <mel-> merijn: which city?
02:03:20 <Nereid> well, pattern matching on things like !pat
02:03:27 <Nereid> which is different
02:04:00 <merijn> ParahSailin__: If you just focus on learning haskell and the type system a lot of things like monads consist of understanding the type + a handful of (completely obvious) laws and you can ignore all the math terminology
02:04:08 <mikeplus64> ParahSailin__: learn types and typeclasses and you'll suddenly know what a monad is :)
02:04:35 <ParahSailin__> ok that makes sense
02:04:52 <merijn> mel-: Amsterdam (ha! That doesn't help since we have two universities ;), Vrije Universiteit (although I think they want to be called VU University now in English? God awful name)
02:05:26 <ciaranm> cities that have more than one university usually only have one university that matters
02:05:41 <Enigmagic> yeah, like boston.
02:05:43 <ciaranm> i say that as a glaswegian
02:05:52 <mel-> merijn: ah, i see.
02:06:27 <merijn> ciaranm: Not here, I'd say its about a toss-up between the two
02:09:40 * hackagebot egison 2.2.3 - An Interpreter for the Programming Language Egison (SatoshiEgi)
02:09:45 <rfw> > let 2 = 3 in 2
02:09:46 <kappabot>   2
02:10:03 <ciaranm> > let 2 + 2 = 5 in 2 + 2
02:10:04 <kappabot>   5
02:10:07 <rfw> shouldn't 2 = 3 fail the pattern match?
02:10:35 <merijn> Why?
02:10:41 <merijn> It's not pattern matching
02:10:41 <mroman> what pattern?
02:10:51 <rfw> ah, i get what you mean
02:11:01 <rfw> my bad
02:11:31 <rfw> i must have confused it with erlang's =
02:15:52 <Axman6> > let a@2 = 3 in a
02:15:53 <kappabot>   *Exception: <interactive>:3:5-11: Irrefutable pattern failed for pattern a@2
02:16:06 <Axman6> the pattern match only fails when the result is demanded
02:16:23 <Nereid> > let a@2 = 3 in 5
02:16:24 <kappabot>   5
02:16:54 <Nereid> > let !2 = 3 in 5
02:16:55 <kappabot>   *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
02:17:40 <shachaf> > let lеt = lеt in lеt
02:17:44 <kappabot>   mueval-core: Time limit exceeded
02:18:41 <shachaf> > let lеt = іn in lеt
02:18:43 <kappabot>   oops
02:20:13 <Axman6> :t (.)
02:20:15 <kappabot> forall (cat :: * -> * -> *) b c a. Category cat => cat b c -> cat a b -> cat a c
02:20:22 <Axman6> who are you!
02:21:04 <shachaf> Wait, what?
02:21:40 <mroman> :t (.)
02:21:42 <kappabot> forall (cat :: * -> * -> *) b c a. Category cat => cat b c -> cat a b -> cat a c
02:21:46 <shachaf> Huh, I guess I added that.
02:21:47 <mroman> @type (.)
02:21:48 <kappabot> forall (cat :: * -> * -> *) b c a. Category cat => cat b c -> cat a b -> cat a c
02:21:52 <shachaf> goodthinkingachaf
02:22:01 <mroman> Lambdabot died :(
02:22:11 <shachaf> rwbarton: Justice is restored!
02:22:36 <mroman> :t (+)
02:22:38 <kappabot> forall a. Num a => a -> a -> a
02:22:40 <GyorsCsiga> i want to quit my job doing PHP :(
02:22:41 <ParahSailin__> :t (:)
02:22:43 <kappabot> forall a. a -> [a] -> [a]
02:22:50 <GyorsCsiga> oops wrong channel
02:23:10 <tazjin> GyorsCsiga: We understand your feelings though ;P
02:23:33 <ParahSailin__> :t (:t)
02:23:34 <kappabot>     Couldn't match expected type `[a0]' with actual type `Expr'
02:23:35 <kappabot>     In the second argument of `(:)', namely `t'
02:23:35 <kappabot>     In the expression: (: t)
02:23:47 <mroman> :t reload
02:23:48 <kappabot> Not in scope: `reload'
02:23:53 <GyorsCsiga> tazjin, do you? :(
02:24:01 <mroman> ^- lately I always type that in ghci instead of :reload
02:24:11 <shachaf> Just type :r
02:24:12 <GyorsCsiga> tajin, it's hard for me to debug PHP… i thought maybe it was because i'm a retard
02:24:13 <mroman> And it pisses me off every single time.
02:24:16 <frerich> Actually, that reminds me - another team in this company is working on a PHP project (a PITA as you can imagine). I was wondering - are there examples of using Haskell to wrap some dynamically-typed language like PHP to avoid certain classes of errors? Maybe a Haskell DSL which looks similiar to PHP - and running the program generates actual PHP code?
02:24:19 <tazjin> GyorsCsiga: Well, I use Haskell at work but I can imagine how bad it would be having to use PHP
02:24:38 <frerich> I assume similiar things would be useful for, say, JavaScript.
02:24:40 <GyorsCsiga> especially if the code is spaghetti
02:24:50 <mroman> Why would you wan't to generate PHP code then?
02:24:54 <mroman> -'
02:25:13 <GyorsCsiga> yeah, whats the point of using PHP
02:25:14 <frerich> mroman: The software is deployed as PHP source code.
02:25:23 <frerich> (internally)
02:25:25 <GyorsCsiga> make the switch instead :D
02:25:28 <tazjin> frerich: There's HJScript as an EDSL for JS
02:25:29 <GyorsCsiga> port it all to haskell!
02:25:31 <GyorsCsiga> MUAHAH
02:25:45 <GyorsCsiga> lets kill PHP with a blunt knife
02:25:47 <frerich> tazjin: Thanks for the pointer, I'll read up a bit.
02:25:47 <shachaf> Take it to #phph8rs or something.
02:25:56 <mroman> You meant to say it *has to be* deployed as PHP source code?
02:26:10 <frerich> mroman: Right ;-)
02:26:18 <GyorsCsiga> shachaf, i'm there but nobody else is there
02:26:19 <GyorsCsiga> :(
02:26:25 <mroman> Aren't there static PHP code analysis tools?
02:26:36 <shachaf> GyorsCsiga: I guess you're the only php h8r!
02:27:01 <GyorsCsiga> tazjin, what sort of stuff do you do with haskell at your job?
02:27:14 <shachaf> mroman: There's a tool written in Haskell to manipulate PHP code.
02:27:34 <mroman> Does it support static error checking?
02:27:44 <frerich> shachaf: Yeah, I read about that (the Facebook tool) - unfortunately, I requires to be fairly familiar with Haskell. It parses PHP and the manipulates the AST.
02:28:04 <frerich> I'd like to reap some benefits of a strong type system without having all the PHP guys learn a totally new language.
02:28:25 <mroman> Although the better way would be to use a better language
02:28:37 <mroman> instead of working around stuff in a broken language just for the sake of using a broken language.
02:28:44 <shachaf> frerich: You can probably get PHP lookalike code embedded in Haskell somehow, but the syntax isn't the interesting part here.
02:29:07 <frerich> shachaf: It is intersting part if you want it to be adopted by the PHP people.
02:29:31 <frerich> mroman: The issue is that if you already pay a dozen monthly salaries for PHP programmers (which I cannot change) then you'd like to get as much out of them as possible.
02:29:47 <frerich> Of *course* it would b better to not use PHP in the first place, and everybody should be a programming rockstar :-}
02:30:48 <frerich> In fact, I could imagine that having such a Haskell EDSL as an intermediate step might trigger more interest in Haskell - once they got the taste of it.
02:32:13 <mroman> I doubt that.
02:32:30 <aleator_> How likely would it be that 'mapReduceWith getAny (==x)' from Reducers package is as fast as 'Data.ByteString.any (==x)'?
02:32:34 <mroman> Usually people stick to their IDE like a sticky melting ice in hell.
02:32:51 <mroman> And you'd have to debug the generated code?
02:33:06 <mroman> instead of the code you've written.
02:33:08 <frerich> mroman: Not around here. Actually, mostly vim/emacs/notepad++ (ugh) here.
02:33:19 <mroman> frerich: Oh. Perfect :D
02:33:41 <shachaf> @karma vim/emacs/notepad
02:33:41 <kappabot> vim/emacs/notepad has a karma of 1
02:33:48 <shachaf> Sadly that will never make it into lambdabot.
02:34:10 <frerich> mroman: Right, having PHP (or Apache, or whatever they use) yield errors in the generated code requires being able to trace that back into the EDSL
02:34:27 <frerich> I'm sure it's tricky, that's why I wonder whether other people did this already (and HJScript looks very interesting)
02:34:58 <mroman> @karma karma
02:34:58 <kappabot> karma has a karma of 1
02:35:12 <mroman> @karma @karma
02:35:12 <kappabot>  @karma has a karma of 0
02:35:20 <mroman> Ic.
02:35:21 <frerich> mroman: I hear there's a guy using Netbeans, ah well... ;-)
02:39:40 <mroman> I don't mind people using IDEs, but I don't like getting told which IDE to use just because someone else uses it.
02:39:56 <ParahSailin__> ah so the reason for the weird a -> a -> a -> a -> a notation for parameters and return is currying?
02:40:12 <mroman> I don't share their religious beleive in their IDE :)
02:44:39 <Digit> mroman: but haskell-mode in emacs is so great for haskell, you just HAVE TO use it.
02:44:40 <Digit> jk
02:45:36 <shachaf> Digit: These tired flame-inviting jokes are not funny even if you write "jk" after them. :-(
02:45:55 <Digit> o right, sry.
02:47:26 <fmap> ParahSailin__: weird?
02:47:40 <Digit> honestly thought that was lighthearted, innocent and good-taste at the time.
02:48:09 <ParahSailin__> fmap, makes sense when told the reason, but wasnt told the reason until way after the syntax was introduced
02:48:33 <mroman> I don't even know the abbreviaton 'jk'.
02:49:01 <t7> is (Either a) a monad now? (without importing monad.instances)
02:49:15 <shachaf> t7: No, not in the Prelude.
02:49:23 <shachaf> The Prelude is specified in the report, after all. :-)
02:49:35 <shachaf> It would break anything that defined its own instance if the Prelude had it.
02:51:05 <Digit> mroman: jk = joke, or just kidding.  added to make sure it's not to be taken seriously/litterally
02:58:28 <mtg> @help
02:58:28 <kappabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:59:25 <mtg> list
03:00:21 <mtg> @type map
03:00:24 <kappabot> forall a b. (a -> b) -> [a] -> [b]
03:00:43 <mtg> @list
03:00:43 <kappabot> http://code.haskell.org/lambdabot/COMMANDS
03:01:02 <aristid> mtg: you can also use lambdabot in a query, by the way
03:01:47 <mtg> thanks aristid
03:01:53 <mtg> hello #haskell
03:02:08 <mtg> i have a question regarding Text.XML.Cursor
03:02:46 <aristid> mtg: oh, maybe i can help you with the cursors :)
03:03:12 <mtg> i have a datatype: data Metric = Metric {name :: Text, value :: Text}
03:03:22 <mtg> thanks aristid that would be much appreciated
03:03:44 <mtg> it might turn out to be a question more about Monad or Applicative
03:03:52 <mtg> so i have that datatype
03:04:29 <mtg> and i have some XML which is like <foo><metric name="bar value="baz">...more metrics...</foo>
03:05:10 <mtg> I can write a function Cursor -> [Text] fine, which extracts one attribute like so
03:05:37 <mtg> child cursor >>= element "threshold_value" >>= attribute "name"
03:06:05 <mtg> but my question is, how to turn that into a function Cursor -> [Metric]
03:06:10 <mtg> ?
03:06:26 <aristid> mtg: one second :)
03:06:38 <mtg> ie: it will need to call attribute "name" AND attribute "value"
03:07:37 <aristid> mtg: cursor $/ element "metric" &| decodeMetric is the idiom i'd go for, there
03:07:56 <mtg> ahah
03:08:28 <mtg> great
03:08:37 <mtg> that looks like it will do the job
03:09:05 <mtg> am just gonna write that and see what happens
03:09:31 <aristid> mtg: sequence, force and forceM are also usefule functions for this.
03:10:34 <aristid> :t sequence
03:10:36 <kappabot> forall (m :: * -> *) a. Monad m => [m a] -> m [a]
03:10:47 <Axman6> @hoogle ($/)
03:10:47 <kappabot> A Hoogle error occurred.
03:10:58 <aristid> Axman6: it's from Text.XML.Cursor (xml-conduit)
03:11:03 <Axman6> where's Lambdabot >_<
03:11:29 <shachaf> Axman6: Complain to Cale.
03:11:32 <shachaf> Calemplain.
03:12:30 <aristid> oh, i didn't even notice this was kappabot
03:12:48 <Axman6> kappabot: who are you, where have you taken lambdabot?
03:13:50 <aristid> mtg: so the spirit of the xml cursors is to imitate XPath as much as reasonable, that's why you have "/" for child, and "//" for descendant
03:15:39 <mtg> aristid: thanks
03:15:52 <mtg> What type should decodeMetric have?
03:15:52 <aristid> mtg: it works?
03:15:56 <aristid> oh
03:15:57 <mtg> not quite
03:16:09 <mtg> decodeMetric :: Cursor -> Metric
03:16:14 <aristid> well is there some failure monad which you're using?
03:16:26 <mtg> decodeMetric c = Metric $ (attribute "name" c) $ (attribute "value" c)
03:16:39 <mtg> it doesn't compile
03:16:43 <aristid> no, that doesn't work because attribute can fail
03:16:52 <mtg> The first argument of ($) takes one argument, but its type `[T.Text]' has none
03:17:33 <aristid> or rather, attribute returns a list
03:17:36 <aristid> but the list can be empty
03:17:49 <aristid> so you need an approach to handle failure. just using Maybe is fine
03:18:10 <mtg> so it's either a single item list or empty, i guess?
03:18:21 <mtg> assuming valid XML
03:18:44 <aristid> yes, should be
03:18:48 <mtg> cool
03:19:00 <mtg> it's starting to make sense now!
03:19:18 <mtg> so I should use some kind of safe head function?
03:19:33 <mtg> like [a] -> Maybe a
03:19:39 <aristid> so the easiest thing to do is probably this: listToMaybe $ Metric <$> attribute "name" c <*> attribute "value" c
03:19:45 <aristid> :t listToMaybe
03:19:46 <kappabot> forall a. [a] -> Maybe a
03:20:13 <mtg> right, got it!
03:20:46 <mtg> i thought that the applicative stuff would come in here somewhere
03:21:01 <aristid> it does :)
03:21:27 <mtg> in this case, the <$> and <*> are from []'s applicative instance, correct?
03:21:28 <aristid> i mean, the fundamental axis combinator is (>=>), from Control.Monad, and it's all just functions on lists
03:21:33 <aristid> yup
03:21:35 <xkb> What exactly is an orphan instance?
03:21:48 <aristid> xkb: an instance in a different module than the type it is on
03:21:53 <xkb> aha
03:21:57 <mtg> right hang on a sec, I'm gonna try that now
03:22:21 <tazjin> aristid: * in a different module than the type and the class are in, I think
03:22:24 <xkb> I'm using a yesod scaffold site, and added my instance declarations in model/nameofmodel.hs
03:22:34 <aristid> tazjin: right, forgot that case :)
03:22:35 <xkb> so I guess my real model is in a different package
03:22:53 <mtg> @hoogle listToMaybe
03:22:53 <kappabot> A Hoogle error occurred.
03:23:20 <tazjin> xkb: instances for which class? A self defined one? Or something like Aeson's ToJSON class?
03:23:25 <aristid> mtg: Data.Maybe
03:23:36 <xkb> tazjin: ToJSON
03:24:02 <aristid> xkb: right, if you want to avoid that warning, put your ToJSON instances right where the data types are
03:24:18 <xkb> aristid: I think they are generated from a models text file
03:24:45 <tazjin> Or put {-# OPTIONS_GHC -fno-warn-orphans #-} at the top of the file
03:25:48 <t7> whats the cabal command to unpack a package?
03:25:48 <tazjin> xkb: They are generated from the models file but inserted in Model.hs
03:25:53 <xkb> tazjin:  They are also not used, so I guess I have to move them to the Model.hs
03:27:31 <xkb> aristid: Is it good practice to define ToJSON etc in Model.hs?
03:27:42 <t7> ah unpack lol
03:28:59 <mtg> aristid: awesome, that worked perfectly!
03:29:08 <mtg> aristid++
03:30:15 <timthelion> There are so many useless functions in haskell :/  getChar for example :/ :/
03:30:24 <mtg> needed to sprinkle a bit of dubious fromJust-ing
03:30:53 <mtg> but i will remove that and roll it all into higher-level Either that is dealing with other errors
03:31:04 <mtg> thanks a billion!
03:31:55 <mel-> timthelion: why is it useless?
03:32:13 <shachaf> I would say that getChar isn't a function, but apparently the report disagrees.
03:33:01 <Botje> timthelion: you can use it to prevent your program for closing, for one.
03:33:32 <timthelion> mel-: It's behavior is "Get the first char of the last unprocessed line input by the user.  For example pressing 'f' doesn't get the char 'f' you must type "f<newline>" the next call to getChar gets the newline character :D :D
03:34:13 <mel-> timthelion: I thought one can frob the buffering mode of the terminal in order to make getchar work as expected.
03:34:24 <timthelion> mel-: ?
03:34:25 <frerich> shachaf: Maybe the reasoning is that since it's in IO, the function takes 'implicit' input.
03:34:35 <merijn> timthelion: getChar works fine if you disable buffering on stdin
03:34:37 <mel-> timthelion: by default terminals use line buffering.
03:34:38 <timthelion> mel-: is it documented?
03:34:51 <timthelion> merijn: so it's broken on gnome-terminal?
03:34:52 <mel-> timthelion: you should be able to change the buffering.
03:34:55 <merijn> timthelion: This is the default behaviour in every language I have ever used
03:35:00 <mel-> timthelion: no, that's not broken.
03:35:10 <mel-> timthelion: it's expected behaviour. usually you want buffering.
03:35:15 <merijn> timthelion: Did you use hSetBuffering to make stdin unbuffered?
03:35:21 <mel-> but, of course, for certain cases buffering is not a good idea.
03:35:29 <timthelion> merijn: C also uses unsafe pointers, does that mean we should copy that too?
03:35:36 <timthelion> merijn: Aha,
03:35:44 <mel-> timthelion: that's a silly argument.
03:35:45 <merijn> timthelion: Yes, because in this case it is the sensible default
03:35:51 <shachaf> frerich: That would be terrible reasoning, because IO actions don't take an implicit input.
03:35:55 <shachaf> I think it's just lazy phrasing.
03:36:13 <merijn> If someone types "foo^H^H^Hbar" most people want to read "bar" when using getLine, not "foo^H^H^Hbar"
03:36:24 <merijn> (^H being backspace)
03:36:38 <timthelion> merijn: yes, but we're talking about getChar here...
03:36:53 <mel-> timthelion: try it without buffering -- simple.
03:36:54 <frerich> shachaf: Or it's not the same definition of function as in the "->" sense
03:37:10 <merijn> timthelion: You cannot have a file unbuffered for one of the two without making it unbuffered for both
03:38:10 <merijn> Or you have to reset the buffering every call, which is A) expensive (one or two system calls extra for each call and disables user space buffering), B) behaves differently from every existing language ever
03:38:11 <timthelion> merijn: yes you can "hsetBuffering forGetChar; foo<-getChar; hSetBuffering backToForLineMode; return foo"
03:38:35 <shachaf> timthelion: No, that doesn't work.
03:38:45 <timthelion> shachaf: why not?
03:39:05 <merijn> timthelion: Because the buffering of typed characeters will already have happened
03:39:47 <merijn> Retroactively disabling buffering will not change the buffered status of input that has already arrived
03:40:10 <merijn> Also, as I just noted: very expensive due to the number of system calls this requires
03:40:38 <timthelion> merijn: Well it means that getLine is usefull for getting a character, but getChar just gives bad data when called repeatedly...
03:41:10 <MasseR> timthelion: Really, why can't you just change the buffering when you want per character input?
03:41:19 <MasseR> One call at the beginning and that's it
03:41:33 <mel-> also, this has little to do with Haskell
03:41:52 <mel-> it's basically the same everywhere
03:42:53 <timthelion> mel-: that doesn't mean it's not broken everywhere.
03:43:12 * mel- doesn't get it
03:43:17 <mel-> it's USEFUL to have buffering
03:43:20 <Nereid> nothing is broken anywhere
03:43:21 <MasseR> timthelion: Nope. There are drawbacks to either side. This solution has less drawbacks
03:43:26 <mel-> and sometimes it's USEFUL to disable it.
03:43:38 <mel-> there's not the ONE solutation which is perfect for every situation.
03:43:38 <Nereid> at least, not on the computer side
03:43:58 <mel-> so, read about buffering in POSIX or something and then go for the mode which suits you
03:44:39 <mel-> (or come up with a new idea, which (1) performs well and (2) is flexible enough for different kinds of keyboard-driven applications)
03:46:17 <timthelion> mel-: that idea already exists.  It's that you have a read/readline opperation that reads from stdIn, and a getChar that simply pulls a keypress event before it even reaches stdIn...
03:47:18 <merijn> timthelion: Impossible
03:47:29 <timthelion> merijn: it's not impossible, ncurses does this.
03:47:33 <merijn> You cannot "get a keypress before it reaches stdin"
03:47:39 <merijn> ncurses does *not* do that
03:47:47 <mel-> I am very sure that ncurses simply disable buffering
03:47:49 <merijn> ncurses runs in unbuffered mode and does it's own internal buffering
03:47:52 <mel-> and does everything on it's own
03:48:20 <mel-> timthelion: AGAIN: this is nothing really on the application level. read some posix.
03:48:20 <merijn> Buffering is done by the kernel, you cannot simply "get something before it reaches the buffer"
03:49:09 * mel- feels very d'accord with merijn
03:49:27 <Nereid> if you don't like how the buffering is done for you, turn off buffering and do it yourself
03:49:47 <MasseR> Well you could, but you'd need to go to kernel level, right?
03:50:04 <Nereid> instead of reading from stdin? perhaps
03:50:20 <mel-> well, i think it's an interaction between system calls and the c library
03:50:50 <mel-> e.g., for the whole FILE* interface, buffering is also done in the libc
03:50:53 <Nereid> whatever you'd do to accomplish that would probably be at least all of hard, unecessary, and unportable
03:51:19 <Nereid> and perhaps even buggy
03:53:05 <aristid> mtg: if you put it all into an Either, you can also change the decodeMetric function to use Either and force instead of listToMaybe
03:54:21 <Nereid> I should write some code.
03:54:30 <Nereid> I haven't written any haskell in a while.
03:59:12 <merijn> Nereid: Naah, if you turn of buffering on stdin you can implement it yourself portably (at least for all POSIX platforms), no need to go to the kernel
03:59:24 <merijn> Nereid: But it will be hard an unnecessary, yes
03:59:59 <Nereid> merijn: I was talking about the kernel stuff.
04:00:11 <Nereid> I could understand wanting to handle buffering stdin yourself though.
04:05:43 <Nereid> I disagree with the naming of Data.Semigroupoid.
04:05:48 <Nereid> things are supposed to be invertible in groupoids.
04:06:10 <Nereid> oh wait.
04:06:11 <mtg> @type force
04:06:13 <kappabot> Not in scope: `force'
04:06:19 <Nereid> I guess it comes from semigroup.
04:06:23 <Nereid> not groupoid.
04:06:25 <mtg> @hoogle force
04:06:25 <kappabot> A Hoogle error occurred.
04:06:52 <Nereid> I don't like the name semigroup either.
04:15:03 <mroman> How can I make a type synonym again?
04:15:50 <hpc> type Synonym = Thing
04:19:01 <hpaste> marcot pasted “hslogger outputting to stderr” at http://hpaste.org/71632
04:19:37 <marcot> Hi.  How can i avoid hslogger from outputting to stderr and make it output only to the file I specified?
04:20:36 <hpc> in bash, you can redirect stderr to file with "cmd 2> file"
04:20:48 <hpc> or redirect it to stdout with "cmd 2>&1"
04:21:00 <hpc> or something like that
04:21:08 <Axman6> yeah that's it
04:21:33 <marcot> hpc: I want to make the file handler be the only handler on hslogger.  Is it impossible to make it not output to stderr?
04:21:37 <hpc> don't know hslogger, so can't say as to how that works
04:22:07 <hpc> hmm
04:22:13 <hpc> not sure if i am reading this right, but
04:22:15 <hpc> fileHandler "log" DEBUG
04:22:23 <hpc> does that mean it only handles debug messages?
04:23:09 <marcot> hpc: No, It means it handles all debug messages, starting from Priority DEBUG.
04:25:42 <hpc> hmm
04:29:46 * hackagebot current-locale 0.1.0.1 - Get the current system locale in System.Locale format (AlexeyKotlyarov)
04:30:26 <Nereid> aw man.
04:30:47 <Nereid> I was so ready to use the pipes package and everything, since the idea of Frames sounded really awesome.
04:30:53 <Nereid> but then everyone else seems to use pipes-core instead.
04:34:46 <nand`> dmwit: can I use cairo to flip images by scaling by negative factors? I tried ‘scale (-1) 1’, but now I can't see the image anymore, not even if I ‘translate 200 0’ (under the assumption that it was moved offscreen)
04:35:00 <nand`> oh, nvm; it works if I translate *before* scaling
04:35:02 <nand`> odd
04:37:46 <hpc> nand`: try translating by -200
04:37:51 <hpc> after scaling
04:38:04 <Nereid> then again, the pipes package looks like it's evolving fairly rapidly.
04:38:06 <nand`> yes, that works too
04:38:11 <hpc> funky
04:38:30 <nand`> I guess the translation coefficients are in ‘inverted’ space, ie. the view is moved by X, not the object
04:38:43 <hpc> sounds about right
04:38:48 <d-old> patternmatching works on values that don't instance Eq? :P
04:38:58 <d-old> eh types
04:39:08 <hpc> d-old: yes
04:39:25 <hpc> for instance, a list of type [Int -> Int]
04:39:41 <hpc> you can't compare two of those lists for equality, because you can't compare functions
04:39:48 <hpc> but you can match on the list and get many functions out of it
04:40:33 <Axman6> @instance Functor
04:40:33 <kappabot> Maybe you meant: instances instances-importing
04:40:56 <Axman6> @instances Functor
04:40:57 <kappabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
04:43:18 <ksf> hmmm. If I write in CPS, I can use implicit parameters to implement state, can't I?
04:44:53 <ParahSailin__> @instances Monad
04:44:54 <kappabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
04:45:26 <ksf> but then I guess forcing CPS on everything is as annoying as that damn state monad.
04:45:55 <ksf> I'd use unsafePerformIO, but last time I tried it was annoyingly referentially transparent.
04:46:13 <shachaf> ?
04:46:22 <ksf> I just need uniques.
04:46:32 <Cale> So which version of LambdaCase made it into HEAD?
04:46:36 <shachaf> Uniques?
04:46:39 <shachaf> Cale!
04:46:41 <shachaf> lambdabot is down.
04:46:44 <Cale> oic
04:46:47 <ksf> unique integers.
04:46:53 <ksf> to generate unique identifiers.
04:47:04 <shachaf> ksf: Didn't edwardk do something to make that nice?
04:47:29 <shachaf> @google ekmett unique
04:47:30 <kappabot> https://github.com/ekmett/concurrent-supply/
04:47:36 <lambdabot> https://github.com/ekmett/concurrent-supply/
04:47:38 <shachaf> Well, maybe that's very different from what you're after. :-)
04:47:43 <shachaf> kappabot: @quit forever
04:48:13 <shachaf> vim/emacs/notepad++
04:48:26 <shachaf> Cale: thale
04:48:31 <ksf> well, that needs splitting.
04:48:38 <shachaf> Cale: You should set up some way to automatically restart lambdabot.
04:49:09 <Cale> It does automatically restart, just not always in a timely fashion, and never when my screen session gets killed.
04:49:26 <shachaf> You should set up something that works. :-)
04:49:33 <Nereid> make a cron job
04:49:34 <Cale> If it gets disconnected, it takes an inordinately long time to realise that it's disconnected.
04:49:37 <shachaf> Run your screen session in a screen session.
04:49:39 <Nereid> that runs screen
04:49:39 <shachaf> "just in case"
04:49:41 <Nereid> lol
04:49:48 <ciaranm> inception!
04:49:54 <shachaf> ciaranm: No.
04:49:59 <Cale> screenception
04:50:19 <NadiaYvette> The -e option is helpful for that.
04:50:21 <shachaf> Inscription
04:50:43 <Nereid> this must be doable right? tell screen to make a new, detached screen
04:50:47 <NadiaYvette> How does disconnection detection work in it?
04:50:49 <Nereid> (assuming it doesn't exist)
04:51:02 <shachaf> NadiaYvette: I think the issue is that it doesn't. :-)
04:51:08 <Nereid> ah yeah -d
04:51:16 <ciaranm> screen -d is very handy
04:51:33 <NadiaYvette> What does the code do that attempts to detect disconnection?
04:51:37 <ciaranm> wuth ssh -f
04:51:52 <Cale> NadiaYvette: No idea
04:52:03 <Nereid> or with cron
04:52:16 <ciaranm> cron still exists?
04:53:15 <ParahSailin__> :t (->)
04:53:17 <mroman> of course.
04:53:18 <lambdabot> parse error on input `->'
04:53:26 <Nereid> :i (->)
04:53:32 <nand`> why does http://hackage.haskell.org/packages/archive/gloss-raster/1.7.4.4/doc/html/Graphics-Gloss-Raster-Field.html have animateField and playField but not displayField?
04:53:38 <Nereid> @info (->)
04:53:38 <lambdabot>  Parse error at "->)" (column 2)
04:54:35 <mroman> Somebody might point me to a source what Haskell considers to be an operator and what not?
04:54:59 <Nereid> mroman: what characters, you mean? it's in the report
04:55:00 <mroman> > let f (:=) a = a f in id (:=) id
04:55:02 <lambdabot>   Not in scope: data constructor `:='Not in scope: data constructor `:='
04:55:10 <mroman> := seems to be not allowed as an operator.
04:55:18 <Cale> mroman: Colon is "uppercase"
04:55:27 <Cale> It's allowed to be an infix data constructor
04:55:36 <ParahSailin__> :t (<-)
04:55:38 <lambdabot> parse error on input `<-'
04:55:46 <mroman> > let f (:=a) a = a f in id (:=a) id
04:55:48 <lambdabot>   <no location info>: Parse error in pattern
04:55:54 <mroman> that seems to be recognized as a pattern.
04:56:01 <Nereid> it really isn't
04:56:03 <ksf> anyone here that has experience with unsafeperformio?
04:56:21 <ksf> I'd need a guarantee that an action is repeated.
04:56:32 <Cale> There's also the problem that you're not allowed to section an infix data constructor in a pattern like that
04:56:34 <ciaranm> > let x =:= y = x in 42 =:= 100
04:56:35 <lambdabot>   42
04:56:35 <ksf> I don't care when, but I care that.
04:56:48 <Nereid> mroman: http://www.haskell.org/onlinereport/lexemes.html#sect2.4
04:56:53 <Cale> (:= a) looks like an operator section
04:57:01 <Cale> of an infix data constructor
04:57:04 <shachaf> ksf: No guarantees with unsafePerformIO.
04:57:10 <shachaf> Especially not when you use it that way.
04:57:10 <Nereid> valid operator names are varsym
04:57:21 <Nereid> consym is for constructors
04:57:30 <shachaf> I mean, once a thunk is created, the code won't be run over and over again.
04:57:31 <Cale> oh, also you're not allowed to repeat a variable amongst the variables bound on the lhs of an =
04:57:32 <ParahSailin__> :t (=<<)
04:57:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
04:57:42 <shachaf> You might have some success with foo () = unsafePerformIO ...
04:57:43 <ksf> what about unsafePerformIO . forkIO . return . unsafeDupablePerformIO?
04:57:50 <shachaf> But it's very fragile.
04:57:59 <mroman> so.
04:58:05 <mroman> > Just.id $ 5
04:58:07 <lambdabot>   Not in scope: `Just.id'
04:58:11 <mroman> has to be written as
04:58:16 <mroman> > (Just.)id $ 5
04:58:20 <lambdabot>   mueval-core: Time limit exceeded
04:58:25 <Nereid> > Just . id $ 5
04:58:25 <mroman> or not.
04:58:27 <Cale> > Just . id $ 5
04:58:28 <lambdabot>   Just 5
04:58:29 <lambdabot>   Just 5
04:58:33 <mmaruseacph2> :)
04:58:36 <Nereid> else it thinks you're using the id function from the Just module.
04:58:48 <mroman> well
04:58:58 <mroman> (Just.)id$5 should work too.
04:59:08 <mroman> Prelude> (Just.)id $ 5
04:59:08 <mroman> Just 5
04:59:17 <Nereid> > (Just.)id $ 5
04:59:18 <ksf> shachaf, that's exactly how you'd do it in disciple.
04:59:20 <lambdabot>   Just 5
04:59:26 <Nereid> lambdabot does weird things sometimes
04:59:49 <ksf> maybe therading through the FFI works?
05:00:05 <ParahSailin__> :t ($)
05:00:07 <lambdabot> forall a b. (a -> b) -> a -> b
05:00:10 <Nereid> > Just. id $ 5
05:00:11 <ksf> -> being able to carry effects is darn useful.
05:00:12 <lambdabot>   Just 5
05:00:14 <Nereid> > Just .id $ 5
05:00:16 <lambdabot>   Just 5
05:02:13 <Nereid> spaces are nicer than parentheses though.
05:07:00 <edsko> any http-conduit experts in the house?
05:15:49 <ksf> there's no trie for Data.Text?
05:21:56 <edsko> is there any library that allows me to make HTTP requests over SSL which supports client certificates?
05:22:02 <edsko> http-conduit doesn't seem to do that :-(
05:22:36 <ksf> last I heard people put apache in front of their server to get ssl.
05:22:51 <ksf> but you really should wait for an answer of a web guy
05:23:04 <edsko> ah, I'm not writing a server, just a client
05:23:17 <ksf> oh, no idea.
05:29:50 * hackagebot distributed-process-simplelocalnet 0.2.0.3 - Simple zero-configuration backend for Cloud Haskell (EdskoDeVries)
05:29:53 <srhb> edsko: Have you seen the tls package?
05:30:30 <edsko> srhb: yes, TLS can parse and load X509 certificates, but I need something on top of that to do HTTP requests, no?
05:31:17 <srhb> Ah, yes, so the problem is making eg. http-conduit and tls work together..
05:31:33 <edsko> srhb: in fact, http-conduit already relies on tls
05:31:41 <edsko> which had me hopeful that it *would* support client certificates
05:31:50 <edsko> but if it does, I don't see it in the API
05:32:48 <srhb> edsko: Hm yes, conduits "secure" doesn't look like it does...
05:33:27 <edsko> yeah, it talks about server certs, but not client certs
05:33:48 <Jafet> You're probably supposed to write and upload this bit
05:35:32 <edsko> Jafet: was that in response to me?
05:35:37 <edsko> if so, I don't understand :)
05:36:09 <Jafet> Most hackages work this way
05:38:12 <Jafet> If you need foo, chances are the library doesn't have it, so you write foo
05:38:40 <edsko> yes, if I have to do that, I have to do that, but I'd rather avoid it
05:54:51 * hackagebot pugs-compat 0.0.6.20120717.204800 - Portable Haskell/POSIX layer for Pugs (AudreyTang)
05:54:53 * hackagebot pugs-DrIFT 2.2.3.20120717 - DrIFT with pugs-specific rules. (AudreyTang)
05:54:55 * hackagebot HsParrot 0.0.2.20120717 - Haskell integration with Parrot virtual machine (AudreyTang)
06:14:52 * hackagebot Pugs 6.2.13.20120717 - A Perl 6 Implementation (AudreyTang)
06:22:55 <optimight> @hoogle set
06:22:57 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
06:22:57 <lambdabot> Control.OldException setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
06:22:57 <lambdabot> Data.Set module Data.Set
06:25:00 <tazjin> Just read about the new multi-way if, is it the guard-like syntax SPJ suggested in a comment on the lambda case thread?
06:25:27 <tazjin> And if yes, does it remove the old if statement? (i.e., is it a breaking change?)
06:25:54 <geekosaur> I would be very surprisedif it broke the standard if
06:26:01 <scopedTV> tazjin: can you link me? i'd like to read more
06:26:27 <tazjin> scopedTV: http://hackage.haskell.org/trac/ghc/ticket/4359#comment:87
06:26:33 <scopedTV> tazjin: thank you
06:28:39 <scopedTV> i love some of these suggestions
06:28:53 * scopedTV is tired of writing \x -> case x of
06:29:27 <tazjin> Well, it's going to be in 7.6 now. Cool, I think
06:29:39 <guest____> I'm getting the following compilation error on Hackage: Test/QuickCheck/All.hs:15:1:     Bad interface file: /usr/local/tmp/archive/install/lib/template-haskell-2.6.0.0/ghc-7.4.1/Language/Haskell/TH.hi         Something is amiss; requested module  template-haskell-2.6.0.0:Language.Haskell.TH differs from name found in the interface file template-haskell:Language.Haskell.TH
06:29:53 <guest____> Anyone knows why this might be?
06:30:09 <guest____> The full log is at: http://hackage.haskell.org/packages/archive/sbv/2.2/logs/failure/ghc-7.4
06:30:32 <guest____> Search for "Something is amiss" in it
06:31:57 <tgeeky_> guest____: something with the GHC installation on hackage might be broken
06:32:05 <geekosaur> guest____, something is indeed amiss, that loks like something is trying to install template haskell from hackage which is always a no-no (it's built into the compiler and cannot be upgraded independently)
06:32:42 <tgeeky_> geekosaur: I mentioned to a GHC dev that GHC HEAD was still compiling against t-h-2.6.0.0
06:34:18 <guest____> geekosaur: The package I've uploaded (sbv) has no direct template-haskell dependency; and neither does QuickCheck 2.5 as far as I can tell.
06:34:47 <guest____> geekosaur: any idea which package might be the culprit?
06:34:50 <geekosaur> guest____, that may be, but the pathname is from a template haskell imstall
06:35:41 <fmap> guest____: QuickCheck depends on th if templateHaskell flag is set
06:35:51 <fmap> (which is by default)
06:36:08 <geekosaur> hm, suppose it could be a name from a package manager build instead though.
06:36:10 <geekosaur> hm, suppose it could be a name from a package manager build instead though.
06:36:12 <geekosaur> (aaaa, notwork dropping every couple minutes)
06:37:07 <wiz> :t xor
06:37:08 <lambdabot> forall a. (Bits a) => a -> a -> a
06:37:18 <tgeeky_> geekosaur: QuickCheck does depend on TH. Language.QuickCheck.ALl
06:37:21 <wiz> :t not
06:37:23 <lambdabot> Bool -> Bool
06:37:50 <scopedTV> :t complement
06:37:52 <lambdabot> forall a. (Bits a) => a -> a
06:37:55 <scopedTV> wiz: ^
06:38:06 <wiz> scopedTV, thnx
06:38:07 <scopedTV> > complement 2 :: Word32
06:38:09 <lambdabot>   4294967293
06:39:24 <wiz> mm.. how about boolean xor?
06:39:44 <scopedTV> oh, never used that really
06:39:56 <guest____> geekosaur: tgeeky_: even then, I don't understand the why the compile is failing
06:40:04 <scopedTV> not sure if that is in the prelude
06:40:09 <scopedTV> @hoogle Bool -> Bool -> Bool
06:40:10 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
06:40:10 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
06:40:10 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
06:40:44 <scopedTV> wiz: of course you can define (^^) :: Bool -> Bool -> Bool   True ^^ True = False; False ^^ False = False; _ ^^ _ = True
06:41:35 * wiz expected to have such things in Prelude..
06:41:57 <scopedTV> wiz: as I said, I use this very seldomly
06:42:05 <geekosaur> guest____, there isn;t quite enough information there, but when ghc starts griping about interface versions or otherwise mentioning package version numbers like that, it's an indication that ghc has two versions of the same package in scope and has become confused.  how exactly that happens ... well, we need more detail about what it did.  possibly rerun the install with -v3
06:42:20 <scopedTV> wiz: but yeah, I can see why one would expect it
06:42:31 <geekosaur> erm, isn't that (/=)?
06:42:41 <scopedTV> wiz: it's an associative, commutative operator, so it's not "ugly" in that sense
06:43:18 <scopedTV> geekosaur: yeah (/=)
06:43:22 <scopedTV> whoops
06:43:34 * scopedTV = an idiot
06:44:51 <guest____> geekosaur: thanks.. though, how do I tell hackage to run install with -v3; is that something I can specify in my own cabal file?
06:45:15 <wiz> geekosaur, most obvious things are most overlooked...
06:46:18 <geekosaur> guest____, cabal install -v3 package...
06:47:06 <guest____> geekosaur: but the failure happens on a hackage upload.. (builds fine on my dev box)
06:47:33 <hughfdjackson> is the next version of haskell really called Haskell'?
06:48:05 <ciaranm> hughfdjackson: it was that or haskell++
06:48:07 <geekosaur> oh, I missed that part, sorry.  that suggests to me that you have a missing version constraint perhaps (you require a particular TH, you need to constrain to the compiler that supports that version?(
06:48:20 <geekosaur> hughfdjackson, haskell' is more of a process than a version
06:48:23 <hughfdjackson> ciaranm: :D it's not bad, it just tickles me
06:48:27 <scopedTV> hughfdjackson: Haskell' is always "the current haskell version + 1"
06:48:32 <hughfdjackson> geekosaur: i realised this just a moment ago ;)
06:48:33 <geekosaur> but yes, expect the math jokes :)
06:48:42 <hughfdjackson> :D
06:48:48 <scopedTV> hughfdjackson: so Haskell2010 was once "Haskell'"
06:48:56 <hughfdjackson> i've gotcha
06:48:59 <ciaranm> i was assured earlier that there would be no maths
06:49:12 <mux> you've been tricked
06:49:18 <scopedTV> I guess we do this to avoid jokes like "C++0x, well this can be C++0A as well."
06:49:49 <ciaranm> to be fair, c++0x ending up as 0a only happened because ISO is sloooow
06:51:26 <Qrt> why use things like !,#,& for operations if they dont actually hae that meaning generally. like if i defined (!) = (+1), instead of doing inc = (+1) ?
06:51:51 <ciaranm> because squiggly things look nice
06:52:13 <Botje> scopedTV: isn't it C++0B ?
06:52:18 <aristid> Qrt: (!) would be associated with array lookup. at least by me
06:52:39 <scopedTV> Botje: it actually is, yes, the joke is older than before that was clear though :)
06:52:43 <HairyDude> haskell++? that looks like a section, only without the parens :)
06:53:08 <scopedTV> Qrt: because we want to use infix notation for some things
06:53:55 <Qrt> > let add = (+) in 5 add 7
06:53:57 <lambdabot>   5
06:54:01 <Qrt> > let add = (+) in 5 `add` 7
06:54:03 <lambdabot>   12
06:54:07 <scopedTV> Caleskell, lol
06:54:20 <scopedTV> Qrt: yes, that would be the alternative
06:54:20 <HairyDude> how did it manage to interpret 5 as a function?
06:54:33 <aristid> HairyDude: instance Num (->)
06:54:33 <ciaranm> vector spaces!
06:54:34 <Nereid> it didn't
06:54:36 <scopedTV> HairyDude: there is a Num b => Num (a -> b) instance
06:54:38 <Nereid> or
06:54:41 <Nereid> that
06:54:42 <HairyDude> weird
06:54:45 <scopedTV> HairyDude: in lambdabot
06:55:22 <scopedTV> HairyDude: there are more of these things in \bot, some of them i like, this one i don't like
06:55:24 <HairyDude> > 2 5
06:55:26 <lambdabot>   2
06:55:27 <scopedTV> :t (.)
06:55:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:55:37 <HairyDude> so what does this Num instance mean?
06:55:39 <scopedTV> ^ this one i like
06:55:48 <ciaranm> > 2 2.0
06:55:50 <lambdabot>   2
06:55:53 <Qrt> su do haskellers like sushi?
06:55:58 <Nereid> > (^2) + (^3) $ 2
06:56:00 <lambdabot>   12
06:56:05 <scopedTV> HairyDude: pointwise addition
06:56:13 <Nereid> pointwise everything
06:56:19 <scopedTV> yeah
06:56:26 <guest____> geekosaur: Ah that's interesting. Looks like there's template haskell 2.7.0.0; but ghc picks 2.6.0.0. I think that's what tgeeky_ was trying to say.
06:56:42 <HairyDude> > (2^2)+(2^3)
06:56:43 <lambdabot>   12
06:56:45 <HairyDude> right
06:56:51 <scopedTV> and fromInteger = const
06:57:10 <aristid> > (2 + sin) 0
06:57:11 <lambdabot>   2.0
06:57:26 <guest____> geekosaur: I actually don't need the templateHaskell dependent QuickCheck in my own package. Is there a way I can pass flags to other packages in my own cabal file?
06:57:37 <Nereid> > map (cos^2 + sin^2) [0..5]
06:57:38 <lambdabot>   [1.0,1.0,1.0,0.9999999999999999,1.0,0.9999999999999999]
06:57:42 <HairyDude> scopedTV: what do you mean by \bot? (I know the symbol, just not what it refers to in this context)
06:57:48 <scopedTV> HairyDude: lambdabot
06:57:49 <Nereid> bottom
06:57:56 <HairyDude> oh, \ meaning lambda
06:57:59 <scopedTV> yeah
06:58:00 <Nereid> oh.
06:58:05 <scopedTV> _|_ is bottom
06:58:07 <Nereid> I was reading that as TeX.
06:58:10 <HairyDude> same here
06:58:19 <scopedTV> oh.
06:58:36 <ilya> > let haskellers f = f True; erlangers = False; like = (&&); sushi = False in do haskellers like sushi
06:58:37 <lambdabot>   False
06:59:43 <Botje> ilya: lies!
07:00:47 <ilya> Botje, :)
07:01:57 <HairyDude> @hoogle Bool -> Bool -> Bool
07:01:57 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
07:01:57 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
07:01:57 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
07:02:45 <HairyDude> no => ? I guess you just do not x || y
07:03:52 <nand`> if sushi is False and like is (&&) then I can conclude that nobody likes sushi
07:04:08 <ciaranm> not without rank n fishing you can't
07:06:03 <scopedTV> HairyDude: => is not a valid function name
07:06:11 <scopedTV> HairyDude: it's used for type classes and stuff
07:06:16 <HairyDude> scopedTV: well, something like ==> then
07:06:30 <HairyDude> I know QuickCheck has a ==> but I think it has a different meaning
07:06:36 <scopedTV> QuickCheck has such an operator, although it means something else
07:06:37 <scopedTV> yeah
07:06:47 <scopedTV> it's related though
07:07:29 <HairyDude> if a test case fails the LHS it doesn't attempt the test, instead of automatically passing it
07:08:02 <edsko> HairyDude: use <= :)
07:08:37 <HairyDude> edsko: oh god, that's confusing :)
07:09:02 <HairyDude> > (False <= False, False <= True, True <= False, True <= True)
07:09:04 <lambdabot>   (True,True,False,True)
07:09:26 <edsko> there you go :)
07:09:58 <HairyDude> that's just too confusing to actually use
07:10:09 <rofer> heh
07:10:28 <ciaranm> you sound like someone who's never had to work with continuous logic
07:11:27 <HairyDude> I sound like someone who's writing code he wants to be able to understand next time he looks at it
07:11:45 <ilya> HairyDude, +1
07:11:56 <ilya> noj, +10000
07:12:02 <sykora> How do I check the source for the outlandish typeclass instantiations that lambdabot understands? I want to know how it interprets `sin` as Num.
07:12:03 <ciaranm> if you can understand it, the minimum wage programmer in herpaderpastan they hire to replace you can understand it too
07:12:07 <ciaranm> job security!
07:12:19 <HairyDude> @instance Num
07:12:20 <lambdabot> Maybe you meant: instances instances-importing
07:12:23 <HairyDude> @instances Num
07:12:24 <lambdabot> Double, Float, Int, Integer
07:12:30 <HairyDude> lies!
07:12:43 <sykora> that can't be right
07:12:44 <scopedTV> ciaranm: I'm not sure if that is public knowledge.
07:13:01 <scopedTV> :t sin
07:13:03 <lambdabot> forall a. (Floating a) => a -> a
07:13:09 <sykora> :t 1 + sin
07:13:10 <lambdabot> forall a. (Floating a) => a -> a
07:13:20 <sykora> ...and that weirds me out
07:13:22 <scopedTV> there is a   Floating a => Floating (b -> a)  instance
07:13:32 <sykora> @instances Floating
07:13:32 <however> i think there's some more instances in Data.Bits and stuff
07:13:33 <lambdabot> Double, Float
07:13:39 <EvanR> anything can be anythinged, period ;)
07:13:43 <HairyDude> oh, *that's* why fromIntegral is const
07:13:44 <however> (for Word8 and suff)
07:13:46 <scopedTV> apparently that looks through Hoogle.
07:14:06 <EvanR> the more stuff that isnt invalid, the less likely the compiler will be able to tell you what you wrote doesnt make sense
07:14:11 <sykora> is there an :info command for lambdabot?
07:14:24 <HairyDude> :info sin
07:14:29 <scopedTV> EvanR: right; more general code means that more nonsense gets accepted
07:14:32 <HairyDude> @info Maybe
07:14:32 <lambdabot> Maybe
07:14:37 <Qrt> how do i split [1,2,3,4,5,6,7,8,9] into [[1,2,3],[4,5,6],[7,8,9]] ?
07:14:40 <HairyDude> answer: yes, but it's useless :)
07:14:42 <nand`> sykora: you want http://hackage.haskell.org/package/NumInstances
07:14:50 <nand`> more specifically http://hackage.haskell.org/packages/archive/NumInstances/1.0/doc/html/src/Data-NumInstances.html
07:15:35 <sykora> nand`: that's exactly what I was looking for
07:15:44 <scopedTV> :t fix (\f xs -> if null xs then [] else let (h,t) = splitAt 3 xs in h : f t)
07:15:46 <lambdabot> forall a. [a] -> [[a]]
07:15:57 <scopedTV> @define splits3 = fix (\f xs -> if null xs then [] else let (h,t) = splitAt 3 xs in h : f t)
07:16:05 <scopedTV> @def splits3 = fix (\f xs -> if null xs then [] else let (h,t) = splitAt 3 xs in h : f t)
07:16:05 <lambdabot> Maybe you meant: bf do let
07:16:07 <EvanR> is ixset not type safe because it uses typeable? or
07:16:11 <scopedTV> @let splits3 = fix (\f xs -> if null xs then [] else let (h,t) = splitAt 3 xs in h : f t)
07:16:12 <lambdabot>  Defined.
07:16:14 <mm_freak> test
07:16:17 <scopedTV> > splits3 [1..9]
07:16:20 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
07:16:23 <scopedTV> Qrt: ^
07:16:28 <nand`> :t splitEvery
07:16:30 <lambdabot> Not in scope: `splitEvery'
07:16:32 <nand`> :(
07:16:35 <nand`> Data.List.Split.splitEvery
07:16:42 <mm_freak> huh?  what an ugly solution
07:16:55 <HairyDude> > unfoldr (\ns -> if null ns then Nothing else Just (splitAt 3 ns)) [1..9]
07:16:56 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
07:17:05 <mm_freak> > let splits n = takeWhile (not . null) . map (take n) . iterate (drop n) in splits 3 [1..9]
07:17:07 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
07:17:19 <HairyDude> I prefer unfoldr
07:17:41 <mm_freak> i don't, because it takes longer to understand
07:18:12 <t7> 'function programming' is not called perative
07:18:15 <t7> now*
07:18:27 <t7> imperative -> perative
07:18:43 <mm_freak> yeah, and comathematicians turn cotheorems into ffee
07:18:57 <morel> :D
07:19:22 <Orphi> What's the whole obsession with prefixing everything with "co" anyway?
07:19:43 <EvanR> is there a data structure like Data.Map but supports efficient 'which keys have value x' ?
07:19:48 <EvanR> besides ixset
07:19:50 <mm_freak> Orphi: categorical duals
07:19:52 <scopedTV> EvanR: bimap maybe?
07:19:54 <however> Orphi: it shows that we're like mathematically inclined and educated and stuff
07:19:55 <HairyDude> Orphi: in category theory, the prefix co- indicates a dual concept
07:19:59 <EvanR> scopedTV: its not bijective
07:20:04 <HairyDude> Orphi: which means "reverse all the arrows"
07:20:07 <ciaranm> Orphi: once you prove something, you get a whole other thing for free
07:20:15 <mm_freak> EvanR: well, IxSet is fine for that
07:20:25 <EvanR> yeah, but is there a more specialized
07:20:36 <Qrt> i just need to split for a 9item list into a 3*3 matrix...nothing general is needed
07:20:46 <mm_freak> EvanR: i don't think so, but you can attack that information yourself
07:20:54 <mm_freak> EvanR: in any case, you'll find that you just reinvent IxSet
07:21:03 <Orphi> So, for example, what the heck is codata?
07:21:06 <mm_freak> s/attack/attach/
07:21:12 <ciaranm> Orphi: the categorical dual of data
07:21:16 <mm_freak> Orphi: every recursive type in haskell is codata
07:21:23 <EvanR> mm_freak: what about type safety
07:21:25 <HairyDude> mm_freak: unless it's strict
07:21:31 <Qrt> show isnt to be used as prettyprint right?
07:21:32 <mm_freak> HairyDude: right
07:21:45 <Qrt> just show 'as-is''
07:21:47 <mm_freak> EvanR: IxSet is just as type-safe as Map
07:22:09 <mm_freak> EvanR: IxSet is really just a table with indices, but typed =)
07:22:10 <Orphi> ...ok, so data *is* codata? That's weird.
07:22:16 <mm_freak> Orphi: no
07:22:25 <mm_freak> Orphi: data is consumed, codata is produced
07:22:34 <mm_freak> Orphi: see recursion vs. corecursion
07:22:42 * ksf facepalms
07:22:45 <mm_freak> this is corecursion:
07:22:48 <Orphi> mm_freak: That was going to be my next question.
07:23:02 <mm_freak> > let nums n = n : nums (n + 1) in nums 10
07:23:03 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34...
07:23:03 <HairyDude> finite lists are data, infinite streams are codata
07:23:05 <ksf> ...I manage to generate unambigious end-user visible names, so when I need uniques, I could just use those.
07:23:14 <Qrt> uh i realized something, how do i upate a list?
07:23:15 <HairyDude> it just so happens that Haskell's type system conflates them
07:23:16 <ksf> now, otoh, everything's already infested by a monad.
07:23:26 <HairyDude> due to non-strict semantics
07:23:26 <mm_freak> Qrt: you don't
07:23:46 <ski> Orphi : "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs and someone else at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf> might be interesting
07:23:53 <Qrt> set 3 5 [1,2,3,4] -> [1,2,3,5]
07:24:07 <mm_freak> Orphi: the data/codata property isn't actually attached to values in memory, but to the way you use the underlying data structure in source code
07:24:14 <mm_freak> Qrt: impossible
07:24:20 <mm_freak> Qrt: well, not impossible
07:24:28 <mm_freak> but your 'set' creates a new list =)
07:24:46 <mm_freak> which is very likely what you actually want
07:24:49 <Qrt> so how do i do? i have a tictactoeboard as [Empty,X,O,Empty,...]
07:24:50 <Orphi> ski: Thanks, I'll take a look.
07:24:51 <geekosaur> also, in general if you want to update things in a list you don;t really want a list
07:25:06 <mm_freak> Qrt: write the base case of 'set' first
07:25:13 <geekosaur> in many ways a list is more of a control structure (a loop) than a data structure in haskell-think
07:25:16 <HairyDude> lists are not a good choice for updatable structures, because the update operation will be O(n)
07:25:27 <mm_freak> set 0 x1 (_:xs) = …?
07:25:28 <Qrt> yes but for a size 9 list it doenst matter
07:25:48 <mm_freak> when you figured that one out write the recursive case
07:26:00 <mm_freak> set n x1 (x0:xs) = …?
07:26:25 <ski> @let (!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]; (as !!<- i) f = front ++ f a : back where (front,a:back) = genericSplitAt i as
07:26:26 <lambdabot>  Defined.
07:26:29 <EvanR> take n xs ++ x ++ drop (9-n-1) xs
07:26:45 <EvanR> er no
07:26:49 <mm_freak> come on, guys, let him figure that one out
07:27:06 <mm_freak> understanding recursive algorithms is really a good idea in haskell
07:27:10 <HairyDude> I'd use an array for a noughts and crosses board personally
07:27:21 <ski> > let ass = [[],[0],[1,2],[3,4,5],[6,7,8,9]] in (ass !!<- 3) $ \as -> (as !!<- 1) $ \a -> a*a
07:27:23 <lambdabot>   [[],[0],[1,2],[3,16,5],[6,7,8,9]]
07:27:40 <ski> Qrt : how about that one ?
07:27:50 <EvanR> let ass = (_|_)
07:28:06 <HairyDude> what he hell is !!<- ?
07:28:15 <ski> update at index
07:28:19 <mm_freak> HairyDude: an operator
07:28:20 <however> HairyDude: he just defined it
07:28:28 <HairyDude> doh, I missed that part
07:28:35 * HairyDude blames the cold
07:28:42 * ski blames the sun
07:29:53 <Qrt> i casn do it easily, just wondered if there was something available
07:30:03 <ski> i don't think so
07:30:16 <ski> if you want to fiddle with indices, then you usually don't want to use lists
07:30:37 <EvanR> use a 3x3 array
07:30:55 <ski> of course, if you juse want to "update" *every* element of a list, in "the same way", then there's `map'
07:30:57 <EvanR> indexes (0,0) to (2,2)
07:30:59 <hpaste> francoccc pasted “setPosition (Parsec)” at http://hpaste.org/71637
07:31:22 <francoccc> ^--- little parsec problem (don't know how to make setPosition work)
07:31:39 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix body = array ix [(i,body i) | i <- range ix]
07:31:41 <lambdabot>  Defined.
07:32:06 <ski> > tabulate ((0,0),(2,2)) $ \(i,j) -> 100 * i + j
07:32:08 <lambdabot>   array ((0,0),(2,2)) [((0,0),0),((0,1),1),((0,2),2),((1,0),100),((1,1),101),...
07:32:15 <EvanR> mm_freak: maybe i can make a module for my code which is CoolMap a b and implement it with ixset in a generic way?
07:32:59 <mm_freak> EvanR: sure, but why would you want to do that?
07:33:10 <mm_freak> IxSet is convenient enough and provides the type-safety by itself
07:33:26 <frerich> Does anybody here happen to be working on some sort of card game, board game, strategy game - something like that? I've implemented a few smaller games (just the engine) so far, I'd like to work on some project with other people. Haskell beginners/amateurs would be fine, I'm still rather new myself.
07:33:30 <mm_freak> in fact IxSet even keeps you from mixing up the indices
07:34:01 <EvanR> mm_freak: to but down on boilerplate, im going to have several of these CoolMap A B, C D and E F
07:34:05 <EvanR> to cut down*
07:34:17 <ski> frerich : i suppose you could try in #haskell-game as well
07:34:18 <EvanR> the indexes are just the values
07:34:24 <EvanR> nothing fancy
07:34:55 <mm_freak> EvanR: anything wrong with that?
07:35:09 <EvanR> what? i was answering your question
07:35:18 <mm_freak> instance Indexable (Whatever a b) where …
07:35:43 <mm_freak> perhaps with Ord on 'a' and 'b'
07:35:43 <EvanR> that doesnt make sense
07:35:59 <mm_freak> why not?
07:36:00 <EvanR> whatever a b is my proposed wrapper for IxSet
07:36:04 <EvanR> not a value
07:36:06 <EvanR> or key
07:36:08 <mm_freak> yes, i get that
07:36:11 <mm_freak> Whatever is the map =)
07:36:22 <EvanR> why an indexable instance then?
07:36:49 <mm_freak> EvanR: the Indexable class has an 'empty' function, which generates an empty IxSet of the given type
07:37:08 <mm_freak> with the indices you want
07:37:21 <EvanR> oh
07:37:28 <mm_freak> you should probably check out how IxSet works =)
07:37:33 <mm_freak> anyway, i'm off
07:37:34 <mm_freak> see you
07:37:40 <EvanR> ive been reading, and im still confused why its called empty
07:37:58 <frerich> ski: thanks for the pointer
07:38:14 <however> a shell, similar to bash, written in haskell. i'm guessing there have been attempts at that. were they any good?
07:39:22 <geekosaur> I don't think anyone has tried to write an actual shell, vs. provide stuff to be used *from* a shell (via runhaskell or ghc -e)
07:39:23 <EvanR> ah
07:39:25 <EvanR> got it
07:44:51 <francoccc> the manual states "setPosition pos : sets the current source position to pos.", so I am pretty sure I am doing the right thing :S
07:45:45 <Qrt> @hoogle [a] -> [a] -> [a]
07:45:46 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
07:45:46 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
07:45:46 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:49:33 <ski> Qrt : looking for anything in particular ?
07:50:02 <ski> @hoogle+
07:50:02 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:50:02 <lambdabot> Data.List unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:50:02 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
07:50:16 <Qrt> (++) for got it somehow lol
07:50:43 <Qrt> am i the only one that prefer case x of blah instead of if-then-else?
07:50:58 <scopedTV> they are very different
07:51:51 <EvanR> for ixset am i required to make a bunch of newtypes to wrap the components of my record?
08:00:36 <byorgey> Come to Hac phi!  registration closes on Friday! =)  http://www.haskell.org/haskellwiki/Hac_%cf%86
08:01:50 <Qrt> hmm lets say i have updateBoard :: Int -> Mark -> Board -> Board and if the index is already marked i just return the board else update the board with Mark . but i want to differ the return result from when it successfully updates the board and when it doesnt. is that when you use Left and Right?
08:02:26 <byorgey> sure
08:02:40 <byorgey> updateBoard :: Int -> Mark -> Board -> Either Board Board
08:03:07 <byorgey> better yet, make your own type:   data NewBoard = Same Board | Updated Board
08:03:15 <byorgey> then updateBoard :: Int -> Mark -> Board -> NewBoard
08:03:51 <byorgey> with 'Left' and 'Right' it would be easy to get confused with which was which
08:04:14 * frerich memorizes it as "Right" is "right- correct".
08:04:15 <EvanR> you already have the same board if it doesnt work
08:04:20 <EvanR> -> Maybe Board
08:04:42 <Qrt> frerich: fascist
08:04:53 <EvanR> right is right
08:05:06 <Qrt> evanR: but i dont have Nothing when i fail.
08:05:20 <Qrt> then i need the old value again which i perhaps always can get though
08:05:35 <EvanR> you have it, you used it in the application of the mark function
08:06:02 <acowley> Yeah, I'd use Maybe in that situation
08:12:27 <Qrt> i ahve a list of 9 items, i want to prints it on 3 rows, 3 items on each
08:13:36 <EvanR> > chunk 3 [1,2,3,4,5,6,7,8,9]
08:13:37 <lambdabot>   Not in scope: `chunk'
08:14:18 <ski> > unfoldr (\as -> guard (not (null as)) >> Just (splitAt 3 as)) [1,2,3,4,5,6,7,8,9]
08:14:20 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
08:14:23 <EvanR> > Data.List.Split.chunk 3 [1,2,3,4,5,6]
08:14:24 <lambdabot>   Not in scope: `Data.List.Split.chunk'
08:15:03 <acowley> I was going to do ski's version but less sexily :/
08:15:10 <EvanR> chunk n xs = y1 : chunk n y2 where (y1,y2) = splitAt n xs
08:15:13 <Qrt> [(),(),()] i get those in the last line when using mapM print xs
08:15:26 <ski> Qrt : use `mapM_'
08:15:38 <Cale> Qrt: That's because ghc prints the result of the IO action that it just executed
08:15:42 <Cale> in addition to executing it
08:16:19 <Cale> (it never used to do this, but at some point someone decided it would be a good idea -- I think it's kind of awkward myself)
08:16:50 <Cale> But yeah, mapM collects a list of the results of each of the IO actions that it executed
08:16:57 <Cale> :t mapM
08:16:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:17:17 <EvanR> see also forM_
08:17:28 <Cale> So if you pass it something like  print :: Integer -> IO ()
08:17:35 <Cale> and [Integer]
08:17:47 <Cale> then you'll get an  IO [()]
08:18:03 <edsko> anybody here with any experience with the TLS package?
08:18:18 <Cale> Since the results are uninteresting in this case, you can take ski's advice and use mapM_ which discards the results
08:24:58 * hackagebot network-metrics 0.1.4 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
08:25:36 <gwern> @quote
08:25:37 <lambdabot> <mreh> says: type T = T T <monochrom> type T = T_T
08:27:45 <ocharles> http://ocharles.org.uk/index2.html ahhh, that's looking better than my old Perl version :)
08:28:32 <tsinaip> hello
08:29:03 <danielsmw> ocharles: I like it!
08:29:13 <tsinaip> is it true that all the functions take one argument in haskell, and func 1 just returns a function?
08:29:54 <tsinaip> but how does haskell then now when we passed plenty of arguments?
08:29:59 <tsinaip> know
08:30:01 <Qrt> what is tydy corein emacs mode?
08:30:16 <danielsmw> tsinaip: are you talking about currying / partial function completion?
08:30:23 <danielsmw> if not, that might be what you want to look up
08:30:23 <tsinaip> danielsmw yes
08:30:37 <Qrt> and is there some way to automatically write all functions types to the file(infer and write to file?)
08:30:46 <Qrt> load tidy mode
08:30:49 <tsinaip> how does haskell know we passed enough arguments to a function, when all functions just take a single argument
08:30:50 <Qrt> load tidy core
08:30:52 <danielsmw> tsinaip: then, yes, in that sense, that's true.
08:31:19 <ocharles> danielsmw: there, a little more sexy now. I better get back to earning money though :)
08:31:31 <danielsmw> ocharles: money's good! :)
08:31:32 <S11001001> tsinaip: what is "enough"?
08:32:11 <barrucadu> tsinaip: If you pass one argument to a function "a -> a -> a", you get a function "a -> a"
08:32:27 <however> tsinaip: no, not really. functions can have as many arguments as you like. you *can* view every function as having only one arg, but that view is not very helpful imho
08:32:29 <tsinaip> S11001001: enough so that the function is actually called, instead of just returning another function
08:32:31 <barrucadu> If you try to use that in a context where "a -> a" is expected, that's fine. If you try to use it where "a" is expected, that's a type error
08:32:38 <Qrt> if i have data Mark = O | X and data Board { board :: [Mark] } . Can quickCheck, if i declare it as an Arbitrary, generate random boards for me?
08:32:50 <S11001001> tsinaip: functions are useful results too
08:33:33 <quicksilver> you need to write an abitrary instance for Mark, which isn't hard to do.
08:33:36 <ocharles> Qrt: of course, just define an instance of Arbitrary Board
08:33:41 <quicksilver> and Board.
08:33:48 <S11001001> :t (+) 42 -- here is a 42-adder value
08:33:49 <lambdabot> forall t. (Num t) => t -> t
08:33:53 <ocharles> you don't have to write an Arbitrary instance for Mark, you can just sample O and X inside the board instance
08:34:08 <ocharles> iirc
08:34:44 <quicksilver> well that's true.
08:34:58 <quicksilver> but if you write an Abirtrary instance for Mark then you can use the normal arbitrary instance for [Mark]
08:35:04 <quicksilver> and just wrap that up into Board
08:35:11 <quicksilver> which is more systematic/normal
08:35:47 <S11001001> tsinaip: given the type a -> b -> c for some a, b, and c, you can't generally tell that useful work isn't being done just by passing the a
08:36:13 <tsinaip> however that's what tutorial i was reading a while ago said, that every haskell function takes just one argument
08:36:52 <S11001001> :t (M.!) (M.fromList [(1,2),(3,4)]) -- observe, one arg being passed to !
08:36:54 <lambdabot> forall t t1. (Num t, Num t1, Ord t) => t -> t1
08:37:00 <barrucadu> tsinaip: It does, but you can tell by the type of the function how many arguments it takes "in total"
08:37:11 <however> tsinaip: yes, you *can* view it like that, but ...
08:37:12 <McManiaC> hey, is there a way to do this? http://npaste.de/hz/
08:37:20 <barrucadu> tsinaip: Eg, "a -> b" takes 1, "a -> b -> c" takes 2
08:37:21 <however> tsinaip: which tutorial are you reading?
08:37:23 <S11001001> :t (M.!) (M.fromList [(1,succ),(3,prec)]) -- still, one arg being passed to !
08:37:24 <lambdabot> Not in scope: `prec'
08:37:35 <S11001001> :t (M.!) (M.fromList [(1,succ),(3,pred)]) -- still, one arg being passed to !
08:37:37 <lambdabot> forall t a. (Num t, Enum a, Ord t) => t -> a -> a
08:37:42 <copumpkin> McManiaC: you need a witnes
08:37:49 <copumpkin> or make it a data family
08:38:00 <S11001001> tsinaip: note that the "arity" of the result changed depending on the value I passed as the first arg to !
08:38:01 <copumpkin> also, data type constraints are deprecated
08:38:15 <McManiaC> copumpkin: witness?
08:38:37 <copumpkin> data GraphDirection d => Graph d a = Graph { graphEdges :: !(InternalEdgeRep d) }
08:38:38 <McManiaC> copumpkin: I tried to do something like "empty :: d -> IER d" and call it with undefined, but nope
08:38:44 <copumpkin> data GraphDirection d => Graph d a = Graph { witness :: d, graphEdges :: !(InternalEdgeRep d) }
08:38:46 <copumpkin> that will work
08:38:54 <McManiaC> copumpkin: ah okay
08:38:59 <copumpkin> but I'd kill the GraphDirection d class constraint there
08:39:17 <McManiaC> on the graph class?
08:39:24 <copumpkin> on the Graph type
08:39:42 <McManiaC> err yeah
08:39:59 <copumpkin> the class is also broken
08:40:01 <copumpkin> for the same reason
08:40:26 <copumpkin> the easiest option is probably to make your type InternalEdgeRep d into data InternalEdgeRep d
08:40:36 <copumpkin> then everything will work as planned
08:42:40 <McManiaC> copumpkin: cool, thanks
08:43:00 <copumpkin> the basic idea is that type families are not necessarily injective
08:43:05 <copumpkin> they're functions at the type level
08:43:18 <copumpkin> you're trying to have it infer the output without giving it the input
08:43:51 <copumpkin> you could also see it as making it need to figure out the input given the output, which isn't possible
08:43:51 <McManiaC> i see
08:44:19 <copumpkin> since I can write type InternalEdgeRep Bool = Int; type internalEdgeRep Float = Int
08:44:32 <copumpkin> now if I need to unify InternalEdgeRep x and Int
08:44:42 <copumpkin> so I can look up which instance to use based on x
08:44:53 <copumpkin> x could be either Bool or Float, or any future instance you will define
08:46:08 <daniel_-> anyone got binary-generic working on ghc7.4?
08:46:35 <tsinaip> S11001001:  yeah I got it
08:46:40 <tsinaip> however learnyouahaskell
08:47:49 <Digit> i'm trying to create a function, the equivalent of gnu's "yes", in that it recursively prints a word to screen... the closest i've come is printing an infinite list: print [1,1..], but i couldnt figure how to replace the numbers with a string.
08:48:19 <copumpkin> :t forever . putStrLn
08:48:20 <lambdabot> forall b. String -> IO b
08:48:31 <copumpkin> try that
08:48:32 <djahandarie> Hmm, Hac Phi is soon huh? Is registration still open?
08:48:40 <copumpkin> djahandarie: closes on friday
08:48:47 <djahandarie> Oh damn, cutting it close
08:48:48 <however> :t cycle -- digit, you may be interested in this function
08:48:50 <lambdabot> forall a. [a] -> [a]
08:49:24 <djahandarie> Hmm, I should figure out where to sleep
08:49:38 <copumpkin> I'm sure there's a good bridge
08:49:39 <copumpkin> bridj?
08:49:48 <copumpkin> bridjahandarie
08:50:00 <djahandarie> That's my sister
08:50:21 <Digit> thanks guys.  :)
08:50:45 <Jafet> > cycle "nyan "
08:50:46 <lambdabot>   "nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan nyan...
08:50:53 <djahandarie> Hmm, I should theoretically be able to pawn a room off ccasin
08:52:58 <dmwit> It's "meow".
08:53:04 <dmwit> I don't know how everybody keeps mishearing this song.
08:53:36 <however> dmwit: i've listened to the 18-hour version of the song and never once heard meow
08:53:51 * jfredett sets himself up to be trolled
08:53:57 <jfredett> is it any different after 18 hours?
08:55:10 <Qrt> > print 5
08:55:12 <lambdabot>   <IO ()>
08:55:36 <dmwit> however: how?
08:55:36 <however> jfredett: the out-of-body experience starts around hour 11. talking in tongues, hour 14. seeing the light, hour 16
08:55:54 <dmwit> It's pretty much the blatantly most obvious sound that a cat could make (for an English speaker).
08:56:34 <jfredett> however: ah. I've never made it past the "<expletive> no." mark. which occurs around 0.5ms
08:56:41 <Jafet> Clearly it is not a meow, as no cat meows for 18 hours
08:56:49 <jfredett> Jafet: mine does
08:56:55 <jfredett> but slower, and with less rhythm
08:56:58 <however> jafet: may i introduce you to nyancat?
08:57:12 <Jafet> So that's where it comes from.
08:58:36 <morel> i've got a crappy hangover.
08:59:12 <Qrt> > printWord [] = return ()
08:59:12 <Qrt> printWord w  = do
08:59:12 <Qrt>   print $ w !! 0
08:59:12 <Qrt>   printWord $ drop 1 w
08:59:13 <lambdabot>   <no location info>: parse error on input `='
08:59:30 <however> dmwit: but seriously, i'm told that "nyan" is the japanese word for "meow". so no wonder the two words sound similar. both are a human-language approximation of the same cat-talk
08:59:58 <MostAwesomeDude> "Nya" is the sound, "nyan" is a kitten.
09:00:14 <Cale> wat
09:00:22 <djahandarie> That's not right low
09:00:24 <djahandarie> lol*
09:00:40 <djahandarie> nyanko is kitty
09:00:41 <RogueShadow> Onomatopoeia  :D
09:00:47 <djahandarie> But both nya and nyan are the sound
09:00:52 <MostAwesomeDude> Oh. Okay.
09:00:52 <dmwit> Yes, my theory is that some Japanese-speaker named the song, and then English-speakers suffered the McGurk effect from there on forever after.
09:00:53 <Cale> kitten is 子猫
09:00:54 <djahandarie> And what the hell? RogueShadow? What are you doing here
09:00:59 <Cale> koneko
09:01:05 <RogueShadow> Can't I hang out here :D
09:01:18 <djahandarie> Yes, just surprised :P
09:01:35 <dmwit> ...or the other effect, actually, can't remember the name, where you hear what somebody suggests you should hear rather than what is actually there.
09:01:43 <dmwit> Very similar to McGurk but not quite identical.
09:01:47 <RogueShadow> I felt the need to hang out here, purely because I told somebody else they should learn haskell when they asked on twitter what to learn next.
09:02:11 <djahandarie> lol
09:04:45 <djahandarie> So, who here likes monads?
09:04:59 * hackagebot sundown 0.4.2 - Bindings to the sundown markdown library (FrancescoMazzoli)
09:05:03 <S11001001> djahandarie: whats?
09:05:10 <morel> guys, is it possible/stupid to save a function (of type :: MyOwnDataType -> Bool) in a database?
09:05:19 <however> djahandarie: i like the monad tutorials better than the monads
09:05:22 <morel> a haskell-function, i mean.
09:05:47 <byorgey> morel: not possible in general.  There's no way to serialize functions.
09:05:51 <geekosaur> moreel:  haskell is compiled.  you were expecting to save machine code somehow?
09:05:57 <acowley> morel: is the database an in-memory pure Haskell thing?
09:05:59 <Jafet> If MyOwnDataType is Bounded
09:06:01 <morel> byorgey: bummer. ok.
09:06:12 <Qrt> can i redefine IO Player as Winner somehow?
09:06:14 <morel> geekosaur: yea, i think so.
09:06:20 <acowley> Jafet makes a good point
09:06:30 <morel> acowley: it's just sqlite3.
09:06:33 <Qrt> newType?
09:06:39 <byorgey> djahandarie: coming to hac phi? =)
09:06:51 <djahandarie> Yes, just need to figure out where I'm staying
09:07:03 <geekosaur> morel:  that does not make as much sense as you seem to think it does
09:07:04 <acowley> Write a function: (Bounded a, Serializable a, Serializable b) => (a -> b) -> SqlTable a b
09:07:05 <byorgey> djahandarie: cool, don't forget to register
09:07:25 <acowley> (I just made up most of the types and classes there)
09:07:49 <acowley> Qrt: Redefine for what purpose?
09:07:49 <djahandarie> byorgey, well, I want to make sure I can find something in my budget first :P
09:08:08 <byorgey> djahandarie: fair enough =)
09:08:17 <morel> yea, actually those functions are only something like "f x = g x y" where g is one of [(<),(>),(<=),(>=),(==)] and y is a value… -- so i was also considering just saving y and g in the database.
09:08:53 <byorgey> djahandarie: you could check and see if you could crash with someone who lives here, like dmwit or ccasin or vilhelm
09:09:11 <djahandarie> Yes, that's probably a good idea
09:09:17 <morel> acowley: so i save the whole table of values, you mean?
09:09:31 <kstt> sno
09:09:34 <kstt> oops
09:09:38 <acowley> Or you could stay with me in Jersey, but you'd have to share a room with my mother in law… so, that might be awkward :/
09:09:43 <acowley> morel: Yeah
09:09:46 <byorgey> djahandarie: I'd offer to let you stay with me but with a 10-month-old I think it would be easier to not have someone stay with us this time around.
09:09:57 <morel> acowley: whuut?
09:09:59 * hackagebot network-metrics 0.1.5 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
09:10:02 <byorgey> hahaha
09:10:03 <djahandarie> Haha
09:10:09 <djahandarie> Mother in law vs 10-month-old
09:10:15 <djahandarie> What to pick, what to pick...
09:10:16 <acowley> morel: If the output values aren't too big when serialized, it could be okay
09:10:23 <acowley> morel: sorry, that was for djahandarie
09:10:27 <morel> okay.
09:10:28 <morel> :D
09:11:04 <RogueShadow> bring a tent, camp on the lawn :D
09:11:47 <acowley> Yes, West Philly is known for its accommodating street corners and back alleys. I'm sure you'll be fine!
09:12:26 <djahandarie> I think I'd just pick hiding somewhere in the building at night given those options
09:13:29 <Jafet> db2fun = fromJust . flip lookup [("<=", (<=)), (">=", (>=)), ("<", (<)), (">", (>)), ("==", (==))]
09:13:39 <Qrt> acowley: just asking
09:13:48 <Qrt> how do you do newType skill Int?
09:14:47 <Jafet> I skill Int in dungeons and dragons
09:14:58 <morel> Jafet: you'd save the string? i was considering using Ordering.
09:15:24 <byorgey> djahandarie: you wouldn't even really have to hide, people are sometimes in the building all night anyway.  You would be welcome to sleep under my desk.
09:15:56 <acowley> Qrt: You generally only want to define a newtype if you want to make something more opaque to client code, or you want to define instances that would otherwise cause trouble (due to overlapping, etc.).
09:15:58 <djahandarie> Haha. I'll bug chris first and see if he has any space for me
09:16:13 <Jafet> Strictly speaking I'd not do anything, as this isn't my program
09:16:56 <morel> Jafet: yea, strictly speaking. anyway, what do you think about using Ordering?
09:17:30 <Jafet> It doesn't have five values
09:18:44 <Jafet> But if you really want then [("LT", (<)), ("GT", (>)), ("EQ", (==))]
09:27:01 <Qrt> can Computer {strategy :: B.TicTacToeBoard -> B.TicTacToeBoard } be case x of matched with?
09:27:11 <quicksilver> yes
09:27:24 <quicksilver> case x of Computer f -> .... do something with f ....
09:27:42 <quicksilver> or, case x of Computer {strategy = f} -> ... do somethign with f ...
09:27:45 <quicksilver> if you like that notation.
09:28:22 <ParahSailin> im confused, is "do" bad, because it looks imperative to me
09:30:08 <Eduard_Munteanu> ParahSailin: it's not "bad", it's useful in quite a few cases.
09:30:31 <however> ParahSailin: do seems fine to me. people advise that you don't put all your functions in IO, but rather try to separate them into pure ones and IO ones. but i don't see how anything is fundamentally wrong with do
09:31:12 <Qrt> it seems my printBoard prints twice even though it only prints once!?
09:31:30 <Veinor> Qrt: pastebin your code?
09:32:40 <Qrt> hmm my paste program doesnt work anymore
09:32:57 <Cale> ParahSailin: It's good notation.
09:33:06 <morel> ParahSailin: "do" is just syntactic sugar for (>>=).
09:33:18 <mcstar> not really
09:33:19 <Cale> ParahSailin: Try writing the same things with >>= and you'll see why it's reasonable
09:34:16 <morel> mcstar: then correct me.
09:34:46 <mcstar> what you said is not complete, why dont you explain the whole story to the OP
09:36:10 <morel> im lazy
09:36:50 * Veinor forces morel
09:37:15 <however> mcstar: i don't see anything wrong with what morel said
09:38:01 <mcstar> however: do cannot stand for >>= in itself, you have to explain that there are 2 approaches when dealing with monads
09:38:18 <mcstar> one with regular functions, and one with so called 'syntactic sugar'
09:38:42 <Jafet> Oh boy, monads.
09:39:02 <mcstar> sry, warm fuzzy things?
09:39:05 <Cale> mcstar: what?
09:39:25 <Cale> do notation translates into applications of >>=
09:39:38 <mcstar> he said 'do'
09:39:42 <mcstar> not do notation
09:39:46 <Cale> do { v <- x; <stmts> } = x >>= \v -> do { <stmts> }
09:40:04 <Qrt> so weird my main = do is in scope but not the other functions in my file
09:40:22 <astory> I'm looking for a graph library analogous to pythons NetworkX, with lots of generators and algorithms (shortest path, spanning tree, etc.).  Data.Graph doesn't seem complete enough.  Should I be looking anywhere else?
09:40:32 <Cale> Qrt: is there a .o file hanging around?
09:40:46 <Cale> Qrt: ghci will tend to load compiled objects if they are available
09:40:48 <byorgey> astory: http://hackage.haskell.org/package/fgl
09:40:57 <Cale> Qrt: and only the things exported from the module will be accessible if it loads them
09:41:45 <astory> byorgey: Joy!  thanks!
09:41:57 <hpaste> qrt pasted “prints twice” at http://hpaste.org/71642
09:42:17 <Qrt> Cale: aha, thanks!
09:42:45 <Qrt> Cale: so can i make it not to?
09:42:52 <Veinor> Qrt: just fyi, you can do printBoard makeBoard
09:44:45 <francoccc> do you have to be subscribed to, let's say, beginner haskell mailing list to post in there_
09:44:49 <francoccc> *?
09:45:55 <hpaste> daniel_- pasted “how can i improve this?” at http://hpaste.org/71643
09:46:16 <francoccc> because it seems my post isn't there http://www.haskell.org/pipermail/beginners/2012-July/thread.html
09:46:53 <daniel_-> it feels kinda wrong to convert them to strings and read them back
09:47:45 <daniel_-> and they get padded with quite a few \NUL
09:48:00 <daniel_-> Chunk "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\n2012-07-17\NUL\NUL\NUL\NUL\NUL\NUL\NUL\DC430132529849 % 500000" Empty
09:48:21 <Qrt> how would i def an arbitrary so that it can randomize boards: Board { board :: [Mark] } and Mark = X | O | E. board is always size 9.
09:48:36 <Qrt> but why does print print twice?
09:48:37 <Cale> Qrt: just delete the .o
09:48:44 <Qrt> Cale: no...
09:48:46 <Cale> Qrt: It'll be recreated when you compile again anyway
09:51:04 <daniel_-> just realized i dont need to show the DiffTime since rational is already defined Binary instance
09:53:53 <mcstar> i dont understand, how can you use 'show' when you make something an instance of binary? i dont think i get it
09:54:11 <Veinor> Qrt: does it print twice in test?
09:54:14 <Veinor> or just in main
09:56:02 <however> daniel_-: yes, converting Day to String is probably not necessary. Day consists of one Integer value, and you could use that directly. but it's a debugging convenience
09:56:34 <ski> Qrt : `arbitrary = elements [X,O,E]' for `Mark' ?
09:57:20 <mcstar> however: isnt Binary about binary serialization? how does that happen in daniel's code? show/read work in ascii mode, dont they?
09:57:49 <however> daniel_-: i don't know where the NULs come from, but a cheap way to find that out might be to "put" some Char, 'O' or whatever, and see where it ends up in the output
09:58:39 <hpaste> Cale pasted “Qrt” at http://hpaste.org/71644
09:59:16 <Cale> Could also have written  arbitrary = fmap Board (vector 9)  for the second instance
09:59:30 <Qrt> @src foldl
09:59:31 <lambdabot> foldl f z []     = z
09:59:31 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:00:01 * hackagebot BNFC 2.4.2.1 - A compiler front-end generator. (AndreasAbel)
10:00:36 * ski tries to recall how to do `coarbitrary'
10:01:59 <DMcGill> I'm looking for a smallish package that's hosted in a Darcs repo and has a (correct) .cabal file
10:02:22 <DMcGill> doesn't matter what, I'm testing my build bot. Any suggestions?
10:02:29 <hpaste> Cale annotated “Qrt” with “Qrt (annotation)” at http://hpaste.org/71644#a71645
10:02:44 <Cale> ski: ^^
10:03:06 <Cale> Also Qrt ^^ :)
10:04:14 <jfischoff> Cale: could you explain the value of CoArbitrary in that case?
10:04:37 <ski> yeah, i just looked up `variant'
10:04:41 <hpaste> daniel_- annotated “how can i improve this?” with “how can i improve this? (annotation)” at http://hpaste.org/71643#a71646
10:04:49 <Cale> jfischoff: It lets you use QuickCheck to test properties which take functions of a parameter of type Board/Mark
10:04:53 <edwardk> coarbitrary makes it so you can quickcheck functions that take that type as an argument
10:04:55 <jfischoff> ah
10:05:10 <ski> jfischoff : if you want to generate random functions of type `Mark -> Foo', you need instances `CoArbitrary Mark' and `Arbitrary Foo'
10:05:53 <however> mcstar: show converts haskell data into a String, which is a bunch of unicode characters (so it's not quite ascii). the binary conversion is going on inside the "put" function (provided by the package binary)
10:06:30 <mcstar> however: from examples on the wiki, i see funtions like putNBytes...
10:06:44 <mcstar> syr, putWord16, or something  like that
10:06:48 <ski> Qrt,Cale : `coarbitrary = coarbitraryEnum' would also work, if `deriving Enum' is added
10:08:27 <saml> how do you group by anagrams  given [String] ?
10:08:33 <saml> [String] -> [[String]]
10:08:45 <ski> clarify the question ?
10:08:49 <saml> how do you test if l1  is a permutation of l2 ?
10:09:15 <saml> isPermute l1 l2 = length l1 == length l2  &&
10:09:20 <morel> saml: maybe sort, then (==)?
10:09:25 <ski> > "abc" \\ "cab"
10:09:26 <lambdabot>   ""
10:09:28 <ski> > "abcc" \\ "cab"
10:09:29 <lambdabot>   "c"
10:09:32 <saml> what
10:09:35 <saml> what's \\ ?
10:09:36 <ski> > "abc" \\ "cabb"
10:09:38 <lambdabot>   ""
10:09:48 <saml> Data.List.(\\), right?
10:09:49 <ski> `(\\)' is "set" difference
10:09:49 <morel> isPermute l1 l2 = null (l1 \\ l2)
10:10:04 <ski> @type (Data.List.\\)
10:10:05 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:10:16 <ski> @src (\\)
10:10:16 <lambdabot> (\\) = foldl (flip delete)
10:10:17 <djahandarie> > [1..] \\ [1..]
10:10:20 <lambdabot>   mueval-core: Time limit exceeded
10:10:31 <djahandarie> > [1,2,3] \\ [1..]
10:10:34 <lambdabot>   mueval-core: Time limit exceeded
10:10:39 <djahandarie> Weak
10:10:47 <djahandarie> > [1..] \\ [1]
10:10:48 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
10:10:54 <djahandarie> Oh, at least it can do it that way
10:11:07 <morel> makes sense.
10:11:35 <however> mcstar: http://hackage.haskell.org/packages/archive/binary/0.5.1.1/doc/html/Data-Binary.html that discusses the "put" function. the code on hpaste calls "put $ show ...", so it's calling put on a String. if i'm not mistaken, that will go to the "[]" instance for put and the Char instance for put
10:11:36 <ski> yeah, probably can't do better than that, for (possibly) infinite stuff
10:11:48 <saml> > groupBy (\a b -> null (a \\ b)) ["abc", "cab"]
10:11:49 <lambdabot>   [["abc","cab"]]
10:12:02 <saml> that was interview question. it took 1 hour and i could not come up with that
10:12:07 <saml> i'm a horrible programmer
10:12:39 <ski> saml : note that (afaiu) the semantics of `groupBy' isn't guaranteed, unless you pass an equivalence relation
10:12:43 <morel> no, you're just not a genius like ski.
10:12:47 <DMcGill> does fizzbuzz take you longer than 1 minute to type up?
10:12:57 * ski is not a genius
10:12:58 <saml> ski, what do you mean?
10:13:05 <saml> what does equivalence relation mean?
10:13:09 <mroman> > groupBy ( (.sort).(==).sort) ) $ ["abc","cab"]
10:13:11 <lambdabot>   <no location info>: parse error on input `)'
10:13:20 <ski> saml : `a \\ b' can be empty even if `b \\ a' isn't empty
10:13:36 <mroman> > groupBy ( (.sort).(==).sort ) $ ["abc","cab"]
10:13:38 <lambdabot>   [["abc","cab"]]
10:13:48 <saml> how is that possible?
10:14:09 <morel> mroman: that's what i suggested, right? =) :p
10:14:20 <saml> show me quick check that shows \\ isn't equivalence relation
10:14:22 <DMcGill> > "abcd" \\ "abc" == "abd" \\ "abcd"
10:14:23 <mroman> "ab" \\ "b" -> a | "b" \\ "ab" -> empty
10:14:23 <lambdabot>   False
10:14:57 <keseldude> you're subtracting the second list from the first list
10:15:01 <ski> saml : an equivalence relation `r' is a relation which is (a) reflexive `forall a. r a a = True'; (b) symmetric `forall a b. r a b = True => r b a = True'; and (c) transitive `forall a b c. r a b = True /\ r b c = True => r a c = True'
10:15:06 <saml> so,  Set.fromList "ab" \\ Set.fromList "b"  ?
10:15:26 <saml> ski, now i have jackie chan face
10:15:36 <ski> <saml> show me quick check that shows \\ isn't equivalence relation
10:15:39 <ski> > "aaabbc" \\ "abc"
10:15:41 <lambdabot>   "aab"
10:15:44 <ski> > "abc" \\ "aaabbc"
10:15:45 <lambdabot>   ""
10:15:47 <mroman> > let a = [1,2,3], b = [3] in a \\ b == b \\ a
10:15:48 <lambdabot>   <no location info>: parse error on input `,'
10:15:50 <saml> oh i meant using QuickCheck
10:16:08 <saml> i just thought this kind of bugs could be caught using QuickCheck
10:16:10 <morel> ski: but if "length l1 == length l2", it's an equivalence relation, isn't it?
10:16:29 <mauke> @check \a b -> a \\ b == b \\ a
10:16:31 <lambdabot>   "Falsifiable, after 3 tests:\n[(),(),()]\n[]\n"
10:16:37 <ski> > "aab" \\ "abc"
10:16:37 <ski> > "abc" \\ "aab"
10:16:38 <lambdabot>   "a"
10:16:39 <lambdabot>   can't find file: L.hs
10:16:41 <ski> morel : nope
10:16:46 <ski> > "abc" \\ "aab"
10:16:47 <lambdabot>   "c"
10:16:53 <ski> @botsmack
10:16:54 <lambdabot> :)
10:17:01 <mauke> @check \a b -> a \\ b == b \\ (a :: Char)
10:17:02 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:17:04 <mcstar> if it was a real set, maybe
10:17:06 <mauke> @check \a b -> a \\ b == b \\ (a :: [Char])
10:17:07 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\725008\"\n\"\\734040\\188922\"\n"
10:17:07 <morel> > "aab" \\ "abc" --- ooh, now i got it, i think.
10:17:08 <lambdabot>   "a"
10:17:23 <ski> @check \a b -> a \\ b == b \\ (a :: [Bool])
10:17:24 <lambdabot>   "Falsifiable, after 0 tests:\n[True]\n[]\n"
10:17:28 <mcstar> no
10:17:47 <mcstar> :t (\\)
10:17:48 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:18:28 <mcstar> hah
10:18:37 <mcstar> \\ doesnt behave like it should, does it?
10:18:44 <ski> saml : the idea with equivalence relations is that they should "measure" whether two things are "alike" in some sense
10:18:46 <mcstar> i mean it doesnt setify, only listify
10:19:05 <saml> ski, ah thanks that makes more sense
10:19:10 <mroman> @check \u v -> let x a b = (a || (not b)) && ((not a) || b) in x u v == x v u
10:19:11 <lambdabot>   "OK, passed 500 tests."
10:19:12 <ski> (like same length, same color, same father, same mother tongue, &c.)
10:19:22 <mcstar> "aab" \\ "abc" should be equivalent to: "ab" \\ "abc"
10:19:27 <mcstar> > "aab" \\ "abc"
10:19:28 <lambdabot>   "a"
10:19:32 <mcstar> > "ab" \\ "abc"
10:19:33 <lambdabot>   ""
10:19:37 <mroman> It generates a lot more tests then necessary
10:19:51 <Jafet> @check \xs -> xs == reverse xs
10:19:52 <lambdabot>   "OK, passed 500 tests."
10:20:31 <mcstar> logic breaks down
10:20:32 <ski> saml : so : reflexivity is "everyone is alike themselves"; symmetry is "if i'm alike you, then you're alike me"; transitivity is "if i'm alike you, and you're alike that gentle(wo)man over there; then i'm alike that gentle(wo)man over there"
10:20:48 <ski> @check \xs -> xs == reverse (xs :: [()])
10:20:50 <lambdabot>   "OK, passed 500 tests."
10:20:53 <ski> @check \xs -> xs == reverse (xs :: [Bool])
10:20:55 <lambdabot>   "Falsifiable, after 8 tests:\n[True,True,False,True]\n"
10:21:17 <mcstar> so what happens in the first one?
10:21:31 <ski> it defaulted to a list of `()'s
10:21:37 <mcstar> ehh
10:21:48 <ski> @check \x -> x == x
10:21:49 <lambdabot>   "OK, passed 500 tests."
10:22:20 <Jafet> @check \xs -> xs == length xs `replicate` ()
10:22:21 <lambdabot>   "OK, passed 500 tests."
10:22:58 <mroman> @check \a f = f a
10:22:59 <lambdabot>   Parse error at "=" (column 6)
10:23:03 <mroman> @check \a f -> f a
10:23:04 <lambdabot>   Overlapping instances for GHC.Show.Show (t1 -> t)
10:23:04 <lambdabot>    arising from a use of ...
10:23:24 <mroman> Can quickcheck create random functions?
10:23:26 <ski> yes
10:23:29 <mcstar> @check \x -> x + 1 == x - 1
10:23:30 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
10:23:35 <mcstar> yay
10:23:40 <ski> (using the `CoArbitrary' class)
10:24:00 <mroman> @check \a f -> f a == f (f (a))
10:24:01 <ski> however, lambdabot has conflicting instances of `Show' for functions in scope, so it can't print them atm
10:24:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:24:01 <lambdabot>    arising from a use of `...
10:24:45 <ski> @check \as bs -> length (as ++ bs) == length as + length bs
10:24:48 <lambdabot>   "OK, passed 500 tests."
10:25:05 <ski> @check \as -> length (reverse as) == length as
10:25:07 <lambdabot>   "OK, passed 500 tests."
10:25:32 <mroman> @check \f a -> f a == f a
10:25:33 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
10:25:33 <lambdabot>    arising from a use of `...
10:25:36 <mroman> Ok. I see.
10:26:22 <Jafet> apply auto... oh wait
10:26:36 <mroman> @check \a b -> ((a,a) == (b,b)) == ((a,b) == (b,a))
10:26:38 <lambdabot>   "OK, passed 500 tests."
10:26:46 <ski>  Matching instances:
10:26:53 <ski>    instance (Test.SmallCheck.Serial a,GHC.Show.Show a,GHC.Show.Show b) => GHC.Show.Show (a -> b)
10:26:57 <ski>      -- Defined in smallcheck-0.4:Test.SmallCheck
10:27:01 <ski>    instance GHC.Show.Show (a -> b)
10:27:02 <ski>      -- Defined in vector-space-0.7.2:Data.NumInstances
10:27:24 <Jafet> vector-space is an epic troll
10:27:34 <Jafet> Who wrote that package?
10:27:46 <saml> ski, you should tweet those
10:27:52 <saml> can i tweet
10:27:58 <ski> tweak what ?
10:28:11 <saml> tweet analogy for reflexivity and others
10:28:18 <mcstar> he thinks he is a bird
10:28:31 <saml> i'll include #yolo and #FP
10:28:59 <mcstar> saml: was the interview for a haskell job?
10:30:19 <ski> @where mockingbird
10:30:20 <lambdabot> "To mock a mockingbird : and other logic puzzles including an amazing adventure in combinatory logic" by R. M. Smullyan, "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with
10:30:20 <lambdabot> Animated Reduction" at <http://dkeenan.com/Lambda/> by David C. Keenan. Also see `smullyan'
10:30:36 <ksf> is there a particular reason conduit doesn't have functions to get Word16s and Word32s?
10:30:38 <ski> ^ there's some birds
10:30:46 <ksf> like, nudging me to use attoparsec or such?
10:31:27 * ski would assume the author just haven't yet had a use for those ..
10:32:26 <saml> mcstar, for ocaml
10:33:12 <mcstar> oh
10:33:20 <mcstar> saml: what country?
10:33:21 <ski> saml : if you're asking for permission to quote me, go ahead (no need to ask about that in a public channel)
10:33:33 <saml> mcstar, usa
10:33:55 <saml> ski, thanks
10:34:13 <ski> hm, there doesn't appear to be a #yolo channel here ..
10:34:32 <mcstar> hah
10:34:37 <mcstar> i used to play that too
10:36:47 <Qrt> well quickchecking toctactoe doesnt seem that appropriate...? i probably dont want random boards since i cant control whats in them.
10:37:11 <Qrt> lets say i want to test with a random index instead like Index Int
10:38:13 <jfischoff> Qrt:is the problem with random boards that they might be invalid?
10:40:32 <Cale> Qrt: It depends on what functions you're quickchecking. You could ensure that the boards generated by the arbitrary instance are actually valid game states if you want.
10:40:49 <ski> Qrt : you can add more control on the randomness, if you want/need to
10:41:29 <mroman> @check \xs -> length((>>=((\(c,n)->show n++[c]).(head&&&length))).group$xs) >= (length xs)
10:41:31 <lambdabot>   "OK, passed 500 tests."
10:41:44 <taylanub> reading the haskell intro; what does "syntax based on layout" mean ?
10:41:59 <mcstar> whitespace matters
10:42:07 <taylanub> just that ?
10:42:08 <mauke> code formatting/indentation determines what the code means
10:42:20 <mroman> like python, only less pythonish.
10:42:21 <ski> taylanub : it means indentation is important, not just for readbility of the code by humans, but also for the sake of the compiler
10:42:44 <taylanub> heh, ok.  was expecting something complicated.  thanks
10:42:51 <Qrt> Cale: how?
10:44:05 <Qrt> ski: in a 'do' you mean?
10:45:08 <mcstar> no
10:45:24 <mauke> Qrt: in do/where/of/let
10:46:07 <saml> how come reflexivity, symetricity, and transitiveness occur frequently?
10:46:48 <Qrt> seems more like a unittest thing, tictactoe. i dont see how to quickcheck with much value¨
10:48:13 <matthiasgorgens> saml: that's just an equality relation?
10:48:18 <ski> Qrt : possibly with `do', possibly without
10:48:39 <saml> matthiasgorgens, yes.  what's equality relation for integers?
10:48:45 <ski> there are many of them
10:48:49 <SegFaultAX|work2> Why do I have to be registered to read the Understanding Arrows page on haskell wiki?
10:48:51 <mcstar> its like asking: why does 'implication' matter? why do we need symbols?
10:49:35 <mcstar> equivalence relation, not equality relation
10:49:38 <ski> e.g. "is same integer", "both are even or both are odd", "have same last digit in decimal", "have same least prime factor", "have same sign" &c.
10:50:02 <mcstar> are they part of the same ideal?
10:50:04 <mauke> SegFaultAX|work2: you do?
10:50:05 <mauke> what url?
10:50:16 <ski> mcstar : sorry ?
10:50:16 <SegFaultAX|work2> mauke: Can you access this? http://www.haskell.org/haskellwiki/index.php?title=Understanding_arrows&action=edit
10:50:27 <mcstar> ski: a further example
10:50:30 <mauke> SegFaultAX|work2: no
10:50:36 <mauke> SegFaultAX|work2: that's the Edit page
10:50:37 <SegFaultAX|work2> mauke: Oh, edit action in url.
10:50:48 <mauke> did you mean: http://www.haskell.org/arrows/  http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
10:50:52 <SegFaultAX|work2> mauke: Apparently that page doesn't exist, so the page I was on linked to a dead page.
10:51:07 <SegFaultAX|work2> mauke: Check section 4: http://www.haskell.org/haskellwiki/Lifting
10:51:14 <SegFaultAX|work2> mauke: Someone should perhaps fix that link?
10:51:28 <ski> mcstar : all those are examples of equivalence relations on the integers -- there's many more of them
10:51:44 <mcstar> ski: i added a further example...
10:52:14 <ski> mcstar : oh .. but ideals don't partition the integers
10:52:34 <ski> (i first thought you meant to say "idea" rather than "ideal")
10:52:35 <mcstar> how come?
10:52:40 <mcstar> they do, afaik
10:52:54 <ski> take `3 * |Z' and `5 * |Z'
10:53:11 <ski> these have a non-empty intersection (namely `15 * |Z'), but they are not equal
10:53:16 <mcstar> that just an example that have common elements
10:53:27 <mcstar> ideals can form an equivalence realtion
10:53:55 <ski> in a partition, the equivalence classes must partition the set -- i.e. only overlap if the classes are the same class
10:54:30 <mcstar> there are numbers, that generate the same ideals
10:54:35 <ski> but sure, if you take e.g. `3 * |Z', you could say it generates the partition with the equivalence classes `3 * |Z',`3 * |Z + 1',`3 * |Z + 2'
10:54:51 <ski> but, afaiu the terminology, the latter two wouldn't be termed "ideals"
10:55:02 <mcstar> hm
10:55:10 <ski> Cale : yes ?
10:56:00 <saml> SegFaultAX|work2, the link is grey, meaning it's a placeholder page
10:56:18 <SegFaultAX|work2> saml: Oh, I didn't realize there was a color coding to links. :)
10:56:45 <ski> SyntaxNinja : as soon as someone creates the page, it'll lead to it -- otherwise it'll lead to the corresponding edit page, waiting for someone to create it
10:56:53 <SegFaultAX|work2> What does `a b c' mean in the type for arr: arr :: (b -> c) -> a b c
10:57:15 <ski> s/SyntaxNinja/SegFaultAX|work2/
10:57:29 <SegFaultAX|work2> ski: Oh, neat!
10:57:51 <ski> SegFaultAX|work2 : consider the case when `a = (->)', then we get `arr :: (b -> c) -> (->) b c', which is just `arr :: (b -> c) -> (b -> c)'
10:58:07 <drspin> \quit
10:58:25 <mcstar> what do you call 'a'? higher kinded type?
10:58:34 <SegFaultAX|work2> ski: Ok, that makes sense. I've never seen 3 type variables together without some other separator though. What does that indicate?
10:58:35 <ski> another example is `a = Kleisli []', then we get `arr :: (b -> c) -> Kleisli [] b c', which is one step from `arr :: (b -> c) -> (b -> [c])'
10:58:40 <mcstar> probably not that sounds awful
10:58:46 <MostAwesomeDude> SegFaultAX|work2: You haven't seen, say, Either?
10:58:53 <geekosaur> it's a type constructor, a thing you can apply a type to to make another type
10:58:56 <SegFaultAX|work2> MostAwesomeDude: Ohh.
10:58:57 <ski> mcstar : "type function (variable)" ?
10:59:00 <SegFaultAX|work2> Derp.
10:59:14 * ski would not say `a' is a type constructor
10:59:24 <SegFaultAX|work2> So is it basically a type a of kind * -> * -> *?
10:59:28 <ski> yes
10:59:35 <SegFaultAX|work2> Lightbulb.
10:59:37 <Cale> ski: right, they're cosets of the ideal 3Z
10:59:37 <SegFaultAX|work2> Thanks guys :D
10:59:57 <ski> Cale : right, i was waiting to ask if they were called cosets in ring/ideal theory :)
11:00:06 <ski> mcstar ^
11:00:22 <mcstar> k, dont know cosets
11:00:46 <ski> it's just a word which is used to describe the equivalence classes generated from the ideal here
11:02:29 <Qrt> so whats a coarbitrary
11:02:30 <ski> ideals play a somewhat similar role in ring theory as normal subgroups play in group theory
11:03:08 <ski> Qrt : it's a means to generate random functions, so that one can then pass them as randomized input to higher-order functions, when testing them
11:03:24 <Qrt> Cale: whats your job? PhD?
11:04:18 <saml> my job is java monkey Qrt
11:04:36 <Qrt> im just a monkey
11:04:44 <ski> Qrt : if we have `instance CoAbitrary Mark where coarbitrary = Enum' and `instance Arbitrary Foo where arbitrary = ...', then we'll automatically get an instance `Arbitrary (Mark -> Foo)', so that we can then test functions of types like `(Mark -> Foo) -> Bar'
11:05:54 <Qrt> anyone i just figured the print twice issue it is obv from the computermove lol
11:06:48 <mcstar> try some punctuations, will you?
11:07:30 <ski> Qrt : is this perchance re some paste of yours ?
11:08:16 <marcot> What's the most used library for parsing command line arguments?  cmdargs?
11:08:55 <Eduard_Munteanu> @hoogle getopt
11:08:56 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
11:08:56 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
11:08:56 <lambdabot> System.Console.GetOpt module System.Console.GetOpt
11:09:11 <saml> marcot, http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/System-Console-GetOpt.html
11:09:38 <saml> Stability	experimental
11:10:58 <mroman> Error: Use q! to override
11:11:12 <byorgey> marcot: I would say cmdargs.
11:11:26 <marcot> byorgey: Thanks.
11:12:01 <djahandarie> Another newer option is the "options" package
11:12:08 <byorgey> marcot: cmdargs is fairly easy to get started with.  Though some people don't like the fact that the default interface makes use of some impure tricks.
11:12:50 <ski> (`unsafePerformIO getArgs' ?)
11:13:25 <byorgey> ski: no, much worse than that =)
11:13:53 <mroman> return $ unsafePerformIO getArgs ?
11:14:51 <djahandarie> thisIsDefinitelyNotUnsafe :: IO a -> IO a; thisIsDefinitelyNotUnsafe = return . unsafePerformIO
11:14:53 <byorgey> you define a set of options by writing a record like   opts = MyOptions { field1 = value &= help "Help text" &= otherOptions, field2 = ... }
11:15:27 <djahandarie> {-# LANGUAGE Trusthworthy #-}
11:15:38 <byorgey> where '&= help ...', '&= otherOptions ...' etc. are semantically the identity but collect information via some unsafePerformIO'd IORefs or something like that
11:15:47 <ski> djahandarie : that appears similar to `unsafeInterleaveIO' -- also, i'm not sure i believe it's not unsafe
11:16:03 <mroman> you mean safeUnsafePerformIO
11:16:04 <marcot> Well, I can live with that. =)
11:16:12 <ski> (your `thisIsDefinitelyNotUnsafe', i.e. -- `unsafeInterleaveIO' is perfectly safe, imo)
11:16:15 <mroman> and it's little brother unsafeSafeUnsafePerformIO
11:17:21 <marcot> I was looking at cmdlib, but it seems a little bit undocumented.
11:17:39 <MostAwesomeDude> unsafeInterleaveIO changes the order of evaluation in the IO monad. That's why it's unsafe.
11:17:46 <ski> byorgey : hm, sounds naughty ..
11:18:04 <ski> MostAwesomeDude : so does `forkIO'
11:18:05 <byorgey> ski: yep
11:18:13 <MostAwesomeDude> ski: Hmm.
11:18:50 <byorgey> marcot: (for the record, I don't particularly have a problem with cmdargs =)
11:19:04 <ski> (note that "safe" and "predictable" isn't the same thing)
11:19:16 <marcot> byorgey: I'll try to use it.
11:20:03 <ski> (.. the point being that the unpredictability of `unsafeInterleaveIO' stays in the `IO' monad, and can be blamed on it -- unlike `unsafeInterleaveST', which really *is* unsafe)
11:21:20 <ski> (i.e., unsafe in the "breaks purity" sense, not in the "invokes undefined behaviour" sense)
11:22:57 <djahandarie> Well, I'd say unsafeInterleaveIO is more unsafe, in some sense, than forkIO. It causes IO actions to happen implicitly due to evaluation of a pure computation.
11:23:34 <djahandarie> It's still pure in the weakest sense of the word, but I wouldn't say it's as pure as any good old haskell function
11:28:45 <ski> since we can blame `IO', i'd say it's as pure as any good old haskell function (like `putStr' e.g.)
11:29:39 <ski> probably it would be better if we used more specific terms here than "unsafe" and "safe"
11:30:02 <ski> @where purely-functional
11:30:02 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
11:30:13 <merijn> Anyone got an indent file that does neat layout like trying to line up the | under = in data declarations and dealing with record syntax nicely? The one I got from haskell-mode for vim is a bit meh
11:34:55 <fragamus> Is there a commonly used idiom for finding the "champion" in a list of competing entries
11:35:07 <fragamus> I suspect it would use monadPlus
11:35:24 <merijn> fragamus: sounds like a fold to me?
11:35:56 <ski> @type maximumBy
11:35:57 <fragamus> I suppose so
11:35:58 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
11:36:15 <fragamus> oh thanx
11:36:20 <ski> @type maximum
11:36:21 <lambdabot> forall a. (Ord a) => [a] -> a
11:39:50 <EvanR> :t compare
11:39:52 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
11:44:05 <Qrt> can i restrict a type to certain values?
11:44:18 <ski> how do you mean ?
11:44:19 <Qrt> whats a good 1-char description of one?
11:44:37 <Qrt> data Boolean = Zero | One  is better i guess
11:44:37 <EvanR> > '1'
11:44:39 <lambdabot>   '1'
11:44:44 <Qrt> yeah well not 1
11:44:52 <EvanR> >_>
11:45:05 <ski> > _ <
11:45:07 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:45:10 <dmwit> data Bit = O | I
11:45:21 <dmwit> data Bool = False | True -- is pretty good for most cases, though
11:45:29 * EvanR presses the button labeled O|I
11:45:32 <ski> Qrt : no refinement types in Haskell, sorry
11:46:00 <dmwit> A googleable term for a workaround is "smart constructor".
11:46:11 <merijn> Newtype without an exported constructor and then use a smart constructor?
11:47:15 * ski . o O ( `OI' <http://www.haskell.org/haskellwiki/TV#IO> )
11:48:09 <EvanR> CoIO
11:48:28 <ski> private types as in O'Caml <http://caml.inria.fr/pub/docs/manual-ocaml/manual021.html#toc76> would be nice to have in Haskell
11:48:55 <mcstar> first class patterns?
11:49:20 <ski> not that
11:50:10 <dmwit> So, what do you do when the person listed as "maintainer" on Hackage doesn't reply to your mails?
11:50:13 <ski> you can pattern-match and use field projection on private types, but you can't construct values of them, except inside the module they're private to
11:50:25 <mcstar> nono, im asking if haskell would benefit from them
11:50:42 <ski> in effect, this means that the constructor(s) of the type is (semantically) partial
11:50:43 <dmwit> ?hackage first-class-patterns
11:50:43 <lambdabot> http://hackage.haskell.org/package/first-class-patterns
11:50:55 <mcstar> like, a symbol wouldnt bind the argument, but it would evaluate on it, and decide whether to match or not
11:50:59 <ski> mcstar : depends on what you mean by "first-class"
11:51:05 <mcstar> ^^
11:51:35 <ski> i don't understand what you mean
11:51:49 <nand`> ski: I imagine something similar could be done via view patterns that project onto a type with public constructors
11:51:49 <ski> maybe invent an example ?
11:51:59 <nand`> (or tuples or whatever)
11:52:09 <ski> nand` : yes (see `viewl' and `viewr')
11:52:52 <mcstar> dmwit: seems awesome
11:53:02 <jfischoff> they seem related to partial lenses
11:53:25 <dmwit> First-class patterns are not inherently bidirectional.
11:53:34 <dmwit> They only need to go in one direction. =)
11:53:59 <mcstar> so, one day they will fall of the earth?
11:54:10 <mcstar> off of*
11:57:13 <mcstar> i think what i originally meant, cannot be implemented this way
11:57:14 <dmwit> Don't worry, their speed decreases exponentially in the distance they've gone; they'll never quite escape. =)
11:57:22 <mcstar> only by changing haskell itself
11:57:24 <Qrt> is isPowerOf n p ?
11:57:48 <dmwit> Yes, isPowerOf n p is.
11:57:56 <dmwit> (...what?)
11:58:06 <nand`> no, isPowerOf n p is not
11:58:25 <dmwit> isPowerOf n p is p, give $1 mill. plox
11:58:32 <mcstar> he asks if some has turned the power off, no problem
11:59:22 <mcstar> ah, he asks if such a function exists
12:00:12 <dmwit> :t \n p -> p ** logBase p n == n
12:00:12 <lambdabot> forall a. (Floating a) => a -> a -> Bool
12:00:29 <dmwit> :t \n p -> p ^ floor (logBase p n) == n
12:00:30 <lambdabot> forall a. (Floating a, RealFrac a) => a -> a -> Bool
12:00:45 <dmwit> Oh, even better:
12:00:55 <nand`> I parsed that as either “is <isPowerOf n p> (true) ?”, “is isPowerOf <n> p” (n is some form of operator eg. greater than), or “is <isPowerOf n> p” (ie. is (isPowerOf n) == p))
12:00:56 <dmwit> :t \n p -> let x = logBase p n in floor x == x
12:00:57 <lambdabot> forall a. (Floating a, RealFrac a, Integral a) => a -> a -> Bool
12:01:36 <dmwit> (Floating a, Integral a) -- ?
12:01:47 <dmwit> :t \n p -> let x = logBase p n in fromInteger (floor x) == x -- oh
12:01:48 <lambdabot> forall a. (Floating a, RealFrac a) => a -> a -> Bool
12:01:49 <nand`> :t \n p -> let x = logBase p n in fromIntegral (floor x) == x
12:01:50 <lambdabot> forall a. (Floating a, RealFrac a) => a -> a -> Bool
12:01:52 <nand`> :(
12:02:41 <ski> @check \n p -> let x = logBase p n in fromIntegral (floor x) == x
12:02:42 <lambdabot>   "Falsifiable, after 0 tests:\n0.0\n0.0\n"
12:03:48 <mcstar> let isPowerOf n p = any [p^k == n | k <- [1..n]] in isPowerOf 512 2
12:03:49 <ski> > (==) `join` (logBase `join` 0.0)
12:03:50 <lambdabot>   False
12:03:54 <mcstar> wtf
12:04:20 <dmwit> mcstar: needs more "> "
12:04:29 <mcstar> > let isPowerOf n p = any [p^k == n | k <- [1..n]] in isPowerOf 512 2
12:04:30 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:04:30 <lambdabot>         against inferred ...
12:04:42 <nand`> :t ((== 0) . snd . properFraction) .: logBase
12:04:44 <lambdabot> forall b. (Floating b, RealFrac b) => b -> b -> Bool
12:05:04 <nand`> > let isPowerOf = ((== 0) . snd . properFraction) .: logBase in 512 `isPowerOf` 2
12:05:06 <DMcGill_> :info .:
12:05:07 <lambdabot>   False
12:05:09 <nand`> :(
12:05:16 <DMcGill_> @info (.:)
12:05:17 <lambdabot> (.:)
12:05:24 <nand`> > logBase 2 512
12:05:26 <lambdabot>   9.0
12:05:30 <dmwit> nand`: flip logBase
12:05:37 <nand`> > let isPowerOf = ((== 0) . snd . properFraction) .: flip logBase in 512 `isPowerOf` 2
12:05:38 <DMcGill_> which library is .: in? I've always just defined it myself
12:05:40 <lambdabot>   True
12:05:41 <nand`> :)
12:05:51 <nand`> DMcGill_: nowhere
12:05:53 <dmwit> DMcGill_: ?info doesn't exist
12:06:01 <ski> @help info
12:06:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:06:04 <mcstar> > let isPowerOf n p = any (\k -> p^k == n) [1..n] in isPowerOf 512 2
12:06:05 <lambdabot>   True
12:06:07 <dmwit> ?help undo
12:06:07 <lambdabot> undo <expr>
12:06:07 <lambdabot> Translate do notation to Monad operators.
12:06:17 <dmwit> ?info do { x <- y; return z }
12:06:17 <lambdabot> y >>= \ x -> return z
12:06:31 <DMcGill_> you just used it nand`, is it defined locally in lambdabot?
12:06:35 <ski> yes
12:06:36 <nand`> DMcGill_: yes
12:06:39 <ski> @where L.hs
12:06:40 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
12:06:41 <ski> ^
12:06:42 <nand`> .: = fmap fmap fmap
12:06:55 <dmwit> It's also defined in one of the point-free combinator packages on Hackage.
12:07:06 <ski>   infixr9 .:; (.:) = (.) . (.)  -- is my original definition
12:07:06 <nand`> dmwit: which one?
12:07:12 <mcstar> i wonder how costly logBase is
12:07:19 <dmwit> You're going to make me look it up...?
12:07:22 <ski> but lambdabot has `(.) = fmap', which gives the more general one nand` mentioned above
12:07:25 <nand`> mcstar: probably log n / log b
12:08:00 <mcstar> max(log n, log b) maybe?
12:08:31 <nand`> I don't know how costly ‘log’ is in the first place
12:08:31 <dmwit> pointless-fun has it, though it wasn't the library I was thinking of
12:08:32 <mcstar> whatever, testing the powers is probably lame
12:08:49 <mcstar> (i mean my listy solution)
12:11:46 <dmwit> composition also has it, and is the one I was thinking of
12:12:28 <dmwit> It really missed out on defining compose0 :: a -> a, though. =P
12:13:17 <nand`> dmwit: I managed to use a silly trick to get cairo to do what I wanted it to do, btw
12:13:24 <dmwit> Wonderful!
12:13:31 <dmwit> And also, horrible, probably. =P
12:14:09 <nobdraisentone> Are there any maintainers of lambdabot hackage package? 4.2.3.2 version is broken, there is only one line need to be added to cabal file to make it installable with 7.4.1.
12:14:15 <nand`> dmwit: I carefully constructed my image so that flipping it horizontally and recombining it gave me the mixtures I wanted :P
12:14:35 <dmwit> =(
12:14:47 <nand`> unfortunately, this technique doesn't let me generalize it to all images, which is what I originally wanted
12:14:50 <dmwit> Surely just two images would be cleaner?
12:15:01 <nand`> dmwit: hmm. I hadn't thought of that
12:15:15 <nand`> the point stands
12:15:41 * dmwit nods agreeably
12:15:42 <nand`> (then I found out the person I wanted to make it for can't run it in the first place because he doesn't have Gtk on his silly operating system. Then I wrote up a quick .NET version :P)
12:16:46 <dmwit> huh
12:17:00 <dmwit> "Termination combinators for forcing non-terminating algorithms to terminate"
12:17:09 <nand`> but anyhow, now I need to move on to the next step: given a conversion function (f :: Color -> Color), I want to transform an image and output it again; this should be a command line tool so no silly GUIs are needed. I'm just wondering which image library would be most suited
12:17:54 <dmwit> JuicyPixels, DevIL, GD
12:18:14 <nand`> ah, I remember working with one of those. I think it was JuicyPixels
12:21:55 <EvanR> hmmmm. how to delete everything with a certain index in an ixset
12:22:12 <EvanR> theres no set minus
12:24:14 <EvanR> there no 'not' operation
12:25:17 <Qrt> \n p -> p ** logBase p n == n is wrong
12:25:35 <Qrt> i make my own
12:26:10 <ski> nobdraisentone : Cale might know
12:26:11 <mcstar> nand`: what language did you use with .net?
12:26:33 <Qrt> can you define an anonymous recursive function?
12:26:42 <ski> yes, use `fix'
12:26:46 <Qrt> or a function within a function
12:26:52 <Qrt> oh really i as gonna add ofc not
12:27:06 <nand`> mcstar: C#, the only .NET language I know
12:27:11 <zaphix> 'cabal install --reinstall' is giving me an error about one of the executables already existing in the install dir: has anyone seen this before?  The error happens even if I remove the previous executable first =/
12:27:24 <ski> > fix (\fib n -> case n of 0 -> 0; 1 -> 1; n -> fib (n - 2) + fib (n - 1)) 12
12:27:26 <lambdabot>   144
12:27:28 <mcstar> nand`: are you linnux or windows?
12:27:29 <ski> Qrt ^
12:27:38 <mcstar> (probably win, but never hurts to ask)
12:27:38 <nand`> mcstar:  Linux, but he was on Windows
12:27:42 <mcstar> oh
12:27:54 <ski> Qrt : depending, it might look nicer with a `where' or a `let'
12:29:14 <Qrt> @type fix
12:29:16 <lambdabot> forall a. (a -> a) -> a
12:29:18 <Qrt> @hoogle fix
12:29:18 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
12:29:18 <lambdabot> Data.Fixed module Data.Fixed
12:29:18 <lambdabot> Data.Function fix :: (a -> a) -> a
12:29:25 <ski> @index fix
12:29:26 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
12:29:50 <ski> `Data.Function' is probably easiest here, if you just want `fix'
12:29:59 <mcstar> ski: well, in fix, there is a let, so the function can refer to itself via fix
12:30:16 <ski>   fix f = x
12:30:18 <ski>     where
12:30:20 <ski>     x = f x
12:30:27 <ski> is how i prefer to define `fix'
12:30:36 <ski> (reads nicer imho than the version with `let')
12:30:40 <identity> is there some way to import a module from a parent directory? I would like to use a module that includes some math stuff I commonly use, that is in my main haskell directory
12:30:46 <mcstar> if you could truly not refer to a lambda function in any way, and could use it only by applying it, then you could not build recursion, right?
12:30:49 <identity> and I'd rather prefer not to manage several copies of it
12:31:26 <mauke> mcstar: you mean like in lambda calculus?
12:31:31 <mcstar> aham
12:31:50 <mcstar> if my understanding is close to the truth, im very shallow there
12:31:55 <ski> mcstar : also see roconnor's "Y Combinator in Haskell" in 2006-09-19 at <http://r6.ca/blog/20060919T084800Z.html>
12:32:43 * nand` likes defining Y like this: http://hpaste.org/71570
12:33:06 <zaphix> Anyone have an idea why cabal-install would be attempting to install an executable twice? (It gives an error that the file already exists after it creates it, it seems)
12:33:44 <astory> is there a way to (in functional graph library) make a graph that doesn't use node labels?  All the type classes and concrete implementation seem to force a label
12:33:54 <ski> your `z' is the S combinator (aka `ap'/`(<*>)' in Haskell)
12:35:06 <Qrt> whats it called when you use | cond = blah ?
12:35:22 <EvanR> guard
12:36:10 <mcstar> En garde!
12:36:27 * mcstar leaps forward to EvanR
12:36:42 * EvanR opens the cdrom drive to block mcstar 
12:36:53 * ski . o O ( "En passant" )
12:36:59 * mcstar uses a portal to get behind EvanR
12:37:00 <EvanR> sorry that move was from 1999
12:37:18 <Qrt> syntax has changed since 2009
12:37:33 <mcstar> syntax defeated mcstar
12:37:39 * mcstar bleads out
12:37:54 <augur> http://www.reddit.com/r/haskell/comments/wpu3e/a_tutorial_on_the_curryhoward_correspondence/c5fdyg8 opinions plox
12:38:32 <ski> @quote that.syntax
12:38:32 <lambdabot> kmc says: because uninformed people believe that syntax is the hardest part of learning a language
12:38:52 <mcstar> well, i tried J
12:39:06 <mcstar> anyone cares for APL?
12:39:37 <ski> possibly Iverson ?
12:44:17 <merijn> I take it conduits have pretty much dethroned enumerators as preferred deterministic lazy IO tool?
12:45:52 <EvanR> what about iteratees
12:45:57 <EvanR> is that so last month
12:46:32 <merijn> iteratees where pretty tied together with enumerators I thought?
12:46:41 <mcstar> haskell's motto: "you can never deprecate a package too quickly"
12:47:22 <ski> augur : "involve employ". i'm not sure i like "below which is a single proof" (i'd prefer s/proof/judgement/ (or "formula" or "proposition" instead of "judgement", if you insist, though "judgement" is more correct)
12:48:24 <augur> ski: ahh yeah, that wasnt a good way of working it
12:48:33 <augur> i probably meant proposition, too
12:48:36 <ion> augur: “involve employ explanations”
12:48:43 <identity> If I wanted to generate permutations for a list, possibly lexicographically(though not necessarily, I can sort them afterwards), is there an efficient algorithm or data-structure to do this in haskell? I don't ahve to write any code to figure out that using lists would be pretty inefficient.
12:49:16 <augur> i dont want to use "judgment" just because im sticking to pure ND, tho I do like the whole judgment methodology
12:49:19 <ski> augur : note that the things above and below the inference stroke are really judgements, here of the form `Phi is true' -- but commonly we elide the "is true" part
12:49:41 <ski> augur : yes, i understand not wanting to bring this distinction into it at this point
12:49:50 <mauke> :t permutations
12:49:51 <lambdabot> forall a. [a] -> [[a]]
12:50:01 <augur> plus, most logicians, including pre-Martin-Lof logicians like Church, didn't use judgments
12:50:05 <identity> mauke: huh.
12:50:07 <mcstar> perm = foldl' (flip $ concatMap . extend) [[]]
12:50:08 <identity> I did not know that.
12:50:15 <ski> augur : "but some one use one class". you might want to mention the word "discharge" near "active"
12:51:01 <augur> ski: ok
12:51:05 <ski> augur : well arguably, if they used inference rules, they used judgements (even if they weren't aware of doing so)
12:51:34 <ski> augur : oh sorry, i now see you mentioned "discharged"
12:52:41 <augur> ski: well i agree they "used judgments" in some sense, but in terms of what they wrote down :p
12:53:15 * ski . o O ( "In natural deduction presentations of logics (and hence, via the Curry-Howard correspondence, in typed lambda calculi), commuting conversions occur when logical rules (usually eliminations) have what Girard (1989) calls a `parasitic formula', a typical case being that of the sum." )
12:53:23 * ski nods
12:53:59 <augur> wossat
12:54:10 <ski> oh, just a quote from a paper i had open
12:54:16 <augur> lol
12:55:36 <ski> hm, apparently it was "Exceptional Syntax" (page 5) by Nick Benton and Andrew Kennedy in 2000(?) at <http://research.microsoft.com/pubs/64038/exceptionalsyntax.pdf>
12:55:55 <augur> ah
12:55:58 <ski> (good paper, imo)
12:57:14 <augur> do you really think i should mention stuff about judgements? it would certainly make it easier if i wanted to add some stuff later, or follow up, about higher logics/type systems
12:57:53 <ski> no, i don't really think you need to, in this kind of cursory paper
12:58:03 <augur> ok
12:58:09 <ski> if you wanted to, you could add it in a note or something near the end
12:58:38 <augur> that seems reasonable
12:58:59 <ski> hm, well
12:59:37 <ski> i suppose by the time you introduce `Gamma |- p : Phi', it might be nice to mention it
12:59:41 <augur> AHHHH
12:59:56 <ski> (since that's a different kind of judgement)
13:00:14 <augur> ski: true. ok, ill stick in a footnote or something
13:00:34 <ski> (a hypothetical one, and one which states that a proof/expression is a proof of a proposition / has a certain type)
13:01:11 <Qrt> so i cant define and for both: and :: Boolean -> Boolean -> Boolean , and :: [Boolean] -> Boolean
13:01:19 <ski> correct
13:01:38 <ski> (well, possibly it's possible with some type class hacks, but i wouldn't recommend it)
13:01:48 <ski> @type (&&)
13:01:49 <lambdabot> Bool -> Bool -> Bool
13:01:49 <ski> @type and
13:01:51 <lambdabot> [Bool] -> Bool
13:01:56 <ski> @type (+)
13:01:58 <lambdabot> forall a. (Num a) => a -> a -> a
13:01:58 <ski> @type asum
13:02:00 <lambdabot> Not in scope: `asum'
13:02:00 <ski> @type sum
13:02:02 <lambdabot> forall a. (Num a) => [a] -> a
13:02:10 <ski> @type max
13:02:11 <ski> @type maximum
13:02:11 <lambdabot> forall a. (Ord a) => a -> a -> a
13:02:11 <ion> augur: What’s the C in the “⊤ has no elimination rules” part?
13:02:12 <lambdabot> forall a. (Ord a) => [a] -> a
13:02:14 <ski> &c.
13:02:33 <Qrt> apply :: ([Boolean] -> [Boolean]) -> BitField -> BitField
13:02:34 <Qrt> apply f (BitField bf) = BitField $ f bf
13:02:36 <Qrt> is that fmap?
13:02:43 <ski> ion : it stands for an arbitrary formula, just like `A' and `B' above
13:02:53 <ski> and `A',`B',`C' in the (later) `\/E' rule
13:03:43 <ion> ski: Ah! I misread the thing above the line as ⊤, but it was ⊥. This makes more sense. :-)
13:03:53 <ski> Qrt : no, it's not `fmap'
13:04:11 <ski> Qrt : i might call that function `onBits'
13:04:46 <augur> ion: ey?
13:05:04 <ski> (cf. `onLines :: ([String] -> [String]) -> (String -> String)' and `perLine :: (String -> String) -> (String -> String)' at conal's <http://www.haskell.org/haskellwiki/TV#IO>)
13:05:50 <ski> ion : are you standing on your head or suspended from the ceiling upside-down ?
13:06:08 <ion> ski: Nah, just tired. :-P
13:07:21 <augur> ski: im waffling about the notation for hypotheses
13:07:22 <ski> Qrt : fyi `fmap' is always a *polymorphic* function
13:07:36 <ski> augur : that's fun
13:07:42 <Qrt> that really kind of s***s that you cant overload functions
13:07:43 <augur> should i use [P]^x or should i use ---x P
13:08:03 <ski> Qrt : you can overload, but only in a principled way
13:08:25 <ski> Qrt : the real problem with ad-hoc overloading (which is what you wanted) is that it makes type inference much harder
13:08:34 <augur> or should i use   ---hyp^x P
13:08:55 <augur> ---hyp^x P definitely mirrors Var "x" in a haskellian representation
13:09:01 <augur> i think i'll do that
13:09:09 <ski> i'd use `[P]^x' or `--- x' (with `P' below, of course)
13:09:15 <Qrt> but then i have to do xor B B -> B, xor_list [B] -> B and xor_bf BitField BitField -> BitField for example
13:09:50 <augur> ski: ok
13:09:56 <ski> augur : in the latter style, in effect, a local hypothesis is a new, locally scoped, inference rule (an axiom, since there's no premises)
13:11:10 <ski> augur : instead of `---- ->I^x' i've also seen `[x] ---- ->I' alt. `[x : P] ---- ->I' (in the Alfa structural editor for Agda1)
13:11:51 <augur> what do you mean [x] ---- ->I?
13:12:06 <augur> [x] to the left of the bar?
13:12:08 <ski> Qrt : you can use a typeclass for the `B -> B -> B' and `BitField -> BitField -> BitField' ones
13:12:13 <ski> augur : yes
13:12:30 <augur> huh...
13:12:31 <augur> interesting
13:12:41 <augur> i prefer to keep it as a superfix tho
13:12:48 <augur> er
13:12:49 <augur> superscript
13:12:51 <ski> @hoogle Bits b => b -> b -> b
13:12:52 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
13:12:52 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
13:12:52 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
13:13:01 <augur> or a subscript, because it makes the connection to \x so much clearer
13:13:02 <ski> Qrt ^
13:13:21 <augur> i suppose if i use inference rules on the _left_ of the bars, it'd be EVEN clearer
13:13:25 <augur> i should try to do that
13:13:29 <ski> augur : i think i've seen subscripts (usually numbers) more common than superscripts
13:13:38 <ski> augur : how do you mean ?
13:13:43 <augur> like
13:13:44 <ski> s/common/commonly/
13:14:07 <augur> instead of   P  Q ---- &I P&Q
13:14:08 <augur> yo have
13:14:18 <augur> P  Q &I---- P&Q
13:14:24 <augur> the CoS people do this a lot
13:14:29 <augur> CoS is really pretty, btw
13:16:46 <saml> how can I show ieee754 as hex or binary string?
13:17:08 <Qrt> whats a ageneral name for adning, oring etc? like a functionnthat takes to bitfields and a function as inputs and applies the function to each paiir
13:17:33 <Qrt> ski: typeclass, how?
13:17:57 * ski . o O ( CoS,"Church of Selene",<http://modarchive.org/index.php?request=view_artist_modules&query=68853>,<http://www.soundlift.com/band/music.php?id=102108>,<http://www.youtube.com/playlist?list=PL91C75E0C2B6B04EC> )
13:18:02 <ski> Qrt : like `Bits' above
13:18:27 <Qrt> dont really get that
13:18:50 <ski> see <http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/Data-Bits.html> for more info about `Bits'
13:20:18 <ski> Qrt : the basic point is that `B -> B -> B' and `BitField -> BitField -> BitField' have the same basic general "shape", namely `b -> b -> b', and since the two operations conceptually do "the same thing (on respectively different types)", we think it's ok to use the same name `xor' to refer to either of them
13:20:19 <augur> ski: Calculus of Structures :p
13:20:46 <saml> what's .xm ?
13:21:44 <hpaste> zaphix pasted “cabal-install woes” at http://hpaste.org/71652
13:22:46 <Qrt> if i import Prelude hiding(and, or, not) how can names collide/be ambiguous
13:23:07 <jfischoff> zaphix: that is just a diagnostic message its not an error (almost positive)
13:23:18 <ski> augur : well, i'm not sure i've seen that -- however often when i'm writing a sequent calculus proof, like "Proof attempt of `(A /\ ~B) \/ (~A /\ B) -||- ~(A <-> B)' in a variant of LK with "multiplicative"-style rules (especially for `<->')" at <http://paste.lisp.org/display/130351>, i write to the left for the left-intro rules, and to the right for the right-intro rules
13:23:26 <zaphix> jfischoff: I thought so too, but it returns an error code and is causing a make process to fail =(
13:23:29 <ski> saml : eXtended Module
13:23:35 <jfischoff> zaphix: oh
13:24:01 <jfischoff> zaphix: run cabal with verbose turned all the way up.
13:24:08 <saml> sounds like xml
13:24:09 <augur> ski: weirdo
13:24:22 <ski> saml : Xmms (via libmikmod) and MikMod (and i think other players as well) can play it. on windows, try WinAMP. dunno about OS X
13:24:29 <zaphix> jfischoff: did that too, and it gets to the invocation of ghc-pkg update, but provides no information about what's being passed to it, and then dies without further info
13:24:30 <ski> augur : ty :)
13:24:38 <zaphix> jfischoff: but thank you for the suggestion =)
13:25:05 <ski> augur : i think it's nice in that you can then nicely apply both a left-rule and a right-rule at the same time, if they commute
13:25:43 <augur> ski: i guess the best analogy would be prefix vs. suffix
13:25:56 <jfischoff> zaphix: are you using a custom Setup.hs?
13:26:10 <augur> < (x >) ~ (< x) >
13:26:13 <zaphix> jfischoff: nope
13:26:39 <ski> saml : Module/tracker music <http://en.wikipedia.org/wiki/Module_file> is older than XML
13:26:48 <zaphix> i thought it was a --reinstall problem initially, but i can reproduce the error with ghc-pkg unregister & cabal install without the reinstall flag
13:27:40 <zaphix> jfischoff: hehe, I think I'm just going to invoke it as 'cabal install || true' for now =/
13:27:41 <ski> Qrt : could you state the whole error message ?
13:27:46 <DMcGill_> what is the simplest way to copy a directory? System.Directory doesn't seem to be able to do it, only copy files
13:27:54 <zaphix> jfischoff: since it doesn't seem to actually be failing at all
13:28:17 * ski str kallisti was working recently on directory traversals ..
13:29:01 <jfischoff> zaphix: yeah I don't think that would be that bad. I wonder if something is up with your package database?
13:29:04 <kallisti> oh hai
13:29:21 <kallisti> DMcGill_: Shelly has a nice interface for recursive copies
13:29:41 <kallisti> you could try my directory-trees library but it's pending a pretty substantial interface change.
13:29:46 <kallisti> er *filesystem-trees
13:29:48 <zaphix> jfischoff: hrm, perhaps, although ghc-pkg check doesn't complain
13:30:13 <kallisti> DMcGill_: there's also a function in the Cabal package for recursive copy, it's called installsomethingsomething
13:30:39 <ski> augur : not sure what you mean re "the best analogy would be prefix vs. suffi"
13:30:41 * hackagebot aws 0.6.1 - Amazon Web Services (AWS) for Haskell (AristidBreitkreuz)
13:30:54 <DMcGill_> installDirectoryContents
13:31:15 <DMcGill_> that seems to be the easiest way given that I'm already using some functions from cabal
13:31:16 <DMcGill_> thanks!
13:31:44 <augur> ski: well, in terms of notations, if you have a rule on the left, its like prefix function app, on the right its like suffix
13:31:56 <Qrt> goodnight
13:31:59 <jfischoff> zaphix: haste your cabal file
13:32:06 <jfischoff> *hpaste
13:33:24 <zaphix> jfischoff: ok, one sec
13:34:06 <hpaste> zaphix annotated “cabal-install woes” with “cabal-install woes (annotation)” at http://hpaste.org/71652#a71653
13:34:54 <zaphix> jfischoff: oops, the executable also has a dep on Proj
13:34:54 <moisan> Hi, I'm a bit new to haskell and I'm in a case where I want to set multiple variables inside an if (but can't). What should I do to get a similar result?
13:35:08 <ski> saml : if you like it, here's some other module music (remixed into mp3 here) <http://www.lynnemusic.com/revive.html> (i especially like Space Deleria)
13:35:26 <ski> augur : ah, i see. could be a nice idea, yes
13:35:39 <DMcGill_> let (var1, var2) = if x then (1,2) else (2,1)
13:35:57 <DMcGill_> moisan: that's for really simple cases
13:36:15 <DMcGill_> if you actually want mutable variables over your program, then you need to use state
13:36:33 <moisan> DMcGill_ : mmmm kk I'll look into that
13:36:43 <ski>   (var1, var2)
13:36:47 <ski>     | x         = (1,2)
13:36:47 <ski>     | otherwise = (2,1)
13:36:52 <moisan> cause right now I want to set different variables depending on the outcome of the if condition
13:37:32 <ski> setting difference variables sounds awkward : what should happen if it tries to get the value of a variable which hasn't been set ?
13:37:37 <DMcGill_> look into the function either
13:37:38 <ski> maybe you want to use `Maybe' or `Either' ?
13:37:41 <DMcGill_> :t either
13:37:43 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:37:45 <ski> @type maybe
13:37:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:37:56 <DMcGill_> > either (+1) (+2) (Left 1)
13:37:58 <lambdabot>   2
13:38:06 <DMcGill_> > either (+1) (+2) (Right 1)
13:38:08 <lambdabot>   3
13:38:34 <ski> > map (maybe "Sorry" show) [Just 0,Nothing,Just 2]
13:38:35 <moisan> ski : you're right but in my case, those are variables that have been set in the 'let' at the beginning of the function.
13:38:35 <lambdabot>   ["0","Sorry","2"]
13:38:48 <jfischoff> zaphix: I don't see anything wrong :(
13:38:58 <zaphix> jfischoff: cool, thank you for the confirmation =)
13:39:05 <ski> moisan : each time you use `let' or `where' to define a variable, it defines a *new* variable
13:39:08 <fightthepower> import Prelude hiding(and, or, not)
13:39:11 <fightthepower> doesnt work i n ghci
13:39:21 <jfischoff> zaphix: I'm out of ideas though ...
13:39:31 <zaphix> moisan: and it might help not to think of them as variables -- think instead of names that are associated with certain values/expressions
13:39:54 <moisan> zaphix , ski : alright, I had the wrong mindset then :P
13:39:54 <ski> zaphix : .. which of course is what a variable is ;)
13:40:08 <zaphix> ski: well, right, but i meant in the mutation sense from imperative langs etc ;P
13:40:17 * ski nods sagely
13:40:36 <zaphix> hehe
13:42:11 <cads> does any here know about lenses?
13:42:21 <cads> jfischoff?
13:42:36 <DMcGill_> moisan: if you put your code into hpaste, perhaps we could give more specific help
13:42:42 <jfischoff> cads: oh hey, do I know about lenses?
13:42:49 <cads> yeah
13:43:13 <moisan> DMcGill_ : thanks but I'm only halfway done with it so it's pretty messy, we can't see what I try to do with it :P
13:43:27 <hpaste> scooty-puff pasted “Which?” at http://hpaste.org/71654
13:44:17 <jfischoff> cads: some, I use them. I have used the new lens family version yet, but it looks really cool. Are you interested in theory or the practical aspects?
13:44:45 <DMcGill_> scooty-puff: is each Monad object meant to represent a specific monad instance? If so, the former
13:44:51 <cads> jfischoff, a bit of both
13:45:28 <cads> I have a simple problem and i'm wondering if it can be a simple example of how lenses can be used
13:45:38 <jfischoff> cads: Sure what is it?
13:46:17 <cads> I have a changelog that consists of a string file. But it may as well be a list of structured entries
13:46:51 <scooty-puff> DMcGill_: can you see any reason why the fact the the Monad constraint is not required for the former may be useful?
13:46:53 <merijn> cads: Me, kinda?
13:47:01 <jfischoff> cads: is there anything polymorphic about it?
13:47:09 <scooty-puff> nothing in particular comes to mind for me - emulating scoped instances i guess?
13:47:18 <cads> jfischoff, no, in fact it's literally a text file right now
13:47:39 <merijn> jfischoff: How's lens family compare with data-lens?
13:47:45 <cads> but I'm thinking it may help me conceptualize how a lens would work
13:48:29 <jfischoff> cads: have seen ek's video?
13:48:58 <cads> so I'm imagining a function which would pull out the nth log entry, and a corresponding function that would let you write a modified/correct/expanded/etc. version of the log entry back into the log
13:49:16 <DMcGill_> scooty-puff: hmm, I suppose if you want to make an instance that doesn't follow the monad laws
13:49:18 <jfischoff> merijn: haven't had time to really explore lens family yet, but the big deal is it can handle polymorphic updates.
13:49:26 <DMcGill_> although you can do that with Prelude.Monad anyway
13:49:34 <cads> jfischoff, I haven't
13:49:53 <augur> ski: i should try to get this into the monad reader :x
13:50:12 <jfischoff> cads: I recommend them http://www.youtube.com/watch?v=efv0SQNde5Q first of five
13:50:18 <augur> then i can pretend like ive published something
13:50:32 <cads> I'm thinking the first function is like the view function of a lens, except it's indexed according to some query you can make on the log listing
13:50:51 <augur> hey look, its edwardk!
13:51:06 <ski> (s/published/peer-reviewedly published/ ?)
13:51:18 <cads> you might want to view the nth log entry, say, or the the log listings from a range of days
13:51:45 <augur> ski: citeably published
13:51:47 <cads> and then if you modify this view data, you'd like to put it back into the log
13:51:49 <augur> :x
13:52:00 <augur> link-on-website-ably publish
13:52:02 <augur> ed
13:52:06 <cads> but your update function might want to additionally do some magic such as saving the old version of the log
13:52:20 <cads> so, jfischoff, is this the kind of thing lenses would be useful for?
13:52:34 <jfischoff> cads: yeah it sounds like what you are doing is creating a new lens with each index. But they are partial lenses. look at headLens: http://hackage.haskell.org/packages/archive/data-lens/2.10.0/doc/html/Data-Lens-Partial-Common.html
13:53:33 * ski . o O ( <http://www.nuchem.se/allan/PUBL.HTM> )
13:53:35 <cads> cool
13:53:37 <jfischoff> jfischoff: there might be also be way to make lens for any 'ol index, not sure, but it would be a partial lens
13:53:41 <jfischoff> either way
13:54:18 <jfischoff> unless it modified the list like the mapLens does
13:54:24 <augur> ski: wossat
13:54:31 <augur> and why are you linking it :D
13:54:35 <ski> just something i found
13:55:14 <cads> hmm, it seems like you can apply a few lenses in a row
13:55:38 <jfischoff> cads: yeah they're a category
13:56:03 * jfischoff realizes cads probably knew that
13:56:11 * ski resumes reviewing
13:57:25 <cads> jfischoff, I guessed they might be, but I don't know exactly how they compose yet
13:57:40 <cads> should be easy to work out
13:59:12 <cads> this is kind of cool, you can apply one partial lens to' zoom in' to some data, then apply a few more to really get 'microscopic' :)
13:59:54 <jfischoff> cads: I use them for all my types. I find them very useful.
14:03:19 <HairyDude> @hoogle Show a => a -> Bytestring
14:03:20 <lambdabot> Did you mean: Show a => a -> ByteString
14:03:20 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
14:03:20 <lambdabot> Prelude id :: a -> a
14:03:29 <jfischoff> cads: That being said I have been using my own slightly different version of partial lenses to get better error messages, but I think I could do the same thing with partial-lens, or even better, lens-family.
14:03:31 <HairyDude> @hoogle Show a => a -> ByteString
14:03:31 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
14:03:31 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
14:03:31 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
14:03:40 <HairyDude> hm.
14:03:44 <jfischoff> hmm underline?
14:04:36 <HairyDude> @hoogle Integer -> ByteString
14:04:37 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
14:04:37 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
14:04:37 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
14:05:20 <JoeyA> (a -> Maybe (Word8, a)) is isomorphic to Integer, no?
14:05:56 <JoeyA> Hmm, maybe not, since you need to feed it an 'a' to get started.
14:06:07 <JoeyA> HairyDude: Looking to serialize an Integer?
14:07:21 <saml> hey, given a (Int,Int)  and [(Int,Int)],  how would you select the best matching (Int,Int) from the list?  it's (width,height)
14:07:24 <HairyDude> JoeyA: I guess so
14:07:40 <saml> what does it mean to find best matching rectangle?
14:08:01 <ski> augur : "for describe". (mayhaps s/maybe/mayhaps/ in some places.) s/But whatever they are/Regardless/ ?
14:08:06 <saml> maybe area of the rectangle?
14:08:43 <JoeyA> HairyDude: You could use the cereal package to serialize it.
14:08:44 <augur> i dont use mayhaps
14:08:46 <augur> you're a weirdo
14:08:47 <jfischoff> saml: yeah you need a way to measure distance
14:09:00 <saml> what is an intuitive way? difference between area?
14:09:10 <HairyDude> seems overkill for what I'm doing
14:09:18 <saml> plus aspect ratio.. hrm
14:10:07 <daniel_-> > encode (1 :: Int)
14:10:08 <augur> saml: you need a metric on how close they are
14:10:08 <lambdabot>   Not in scope: `encode'
14:10:11 <jfischoff> saml: sum of the distances between each corner?  So d = (p0 - p0') ^ 2 + ...
14:10:14 <augur> then you can sort by that
14:10:37 <daniel_-> HairyDude maybe take a look at Data.Binary with encode/decode
14:10:41 <augur> saml: so you need   m : Rect -> Rect -> Real
14:10:49 <augur> whatever your rep of reals s
14:11:06 <jfischoff> saml: it depends if you interesting in rotation, translation, etc
14:11:11 <jfischoff> interested
14:11:12 <saml> yah.. but i'm not so artsy.. not sure what it means to have two similar rectangles  visually
14:11:14 <JoeyA> HairyDude: There are multiple ways you could convert Integer to ByteString.  What are you trying to do?
14:11:20 <ski> augur : when talking about meta-rules to reason about a logic, you might want to mention the magic phrase "logical framework" (and maybe HOAS). i'd s/if_left/left/,s/if_right/right/. it might be nice to mention that if you remove the proof objects from your "meta-rules", you get Gentzen-style natural deduction (which is more akin to the sequent calculus in that premises/hypotheses are explicit in each judgement)
14:11:35 <HairyDude> JoeyA: use an Integer in a get parameter
14:11:35 <saml> basically, this html document has a spot for 200x300 image.. and given a list of images, i need to find the best matching one
14:11:42 <ski> augur : ok, how about `perchance', then ?
14:11:55 * ski nods to being a weirdo
14:11:58 <augur> saml: then you do   map (\x -> (x, m r x) xs   sort this by the second element, then pull off fst . head
14:12:01 <saml> jfischoff, all rectangles are assumed to start at (0,0) with no rotation
14:12:13 <saml> augur, what's m ?
14:12:19 <JoeyA> HairyDude: HTTP GET, you mean?
14:12:37 <augur> i said before,   m :: Rect -> Rect -> Real   is your metric on similarity
14:12:46 <augur> ski: perchance? what is this, a shakespear play?
14:12:51 <augur> ski: IM NOT CONOR MCBRIDE
14:12:53 <augur> unfortunately :(
14:12:56 <Catnaroek> Hello. Is it possible to define my own "polymorphic values"?
14:13:01 <JoeyA> You could convert it to text, then to ByteString: Data.ByteString.Char8.pack . show .  Be warned that the 'show' is quite slow.
14:13:08 <Catnaroek> I mean, just as "2" is a "(Num t) => t"
14:13:32 <Catnaroek> I would like to do something like "class A a where b :: String"
14:13:42 <dmwit> augur: I thought the question was "what's a good metric", not "how do I pick a rectangle once I know a good metric".
14:13:55 <augur> dmwit: o
14:13:58 <ski> (also "varietas delectat")
14:13:59 <augur> dmwit: maybe!
14:14:03 <JoeyA> Catnaroek: As in, your own literal type?
14:14:04 <augur> ski: wat
14:14:27 <Catnaroek> JoeyA: Not necessarily my own literal type.
14:14:37 <ski> (apparently it's "Variety is the spice of life" in english)
14:14:46 <dmwit> I think my metric of choice would put heavy weight on aspect ratio, and a secondary weight on scaling factor.
14:14:48 <augur> dmwit, saml: in that case, i think maybe something like   diff height + diff width
14:14:54 <HairyDude> JoeyA: yes
14:15:02 <dmwit> augur: That doesn't seem like a good metric to me.
14:15:17 <Catnaroek> JoeyA: Something like "class Animal a where sound :: String" and "instance Animal Dog where sound = "barf"
14:15:17 <augur> dmwit: maybe not
14:15:30 <augur> tho if you REALLY want to figure out the correct way to find the best similarity metric for human purposes, you should run a study!
14:15:51 <JoeyA> HairyDude: You could use bytestring-show: http://hackage.haskell.org/packages/archive/bytestring-show/latest/doc/html/Text-Show-ByteString.html
14:15:52 <dmwit> My high-resolution 3000x2000 image that looks good scaled down is going to lose to your 300x2000 image. =P
14:16:10 <JoeyA> Which depends on binary...
14:16:16 <ski> Catnaroek : the problem is that the signature of `sound' doesn't mention `a', so how would it figure out which instance to use, knowing only that you want to use `sound' with type `String'
14:16:27 <augur> dmwit: i guess it depends on what the purpose of the scaling is
14:16:32 <JoeyA> HairyDude: But how is binary/cereal overkill?
14:16:52 <Catnaroek> ski: By forcing me to explicitly specify it?
14:17:38 <ski> Catnaroek : doesn't work
14:17:40 <HairyDude> JoeyA: at this point performance is not critical... it's effectively interactive, the number of Integers being serialized is small, and I'd rather not depend on things I don't need to depend on
14:17:56 <Catnaroek> ski: What exactly breaks it?
14:18:22 <ski> Catnaroek : a common workaround is to say `sound :: a -> String', and then never look at the argument -- using `sound :: Proxy a -> String' with `Proxy' from <http://hackage.haskell.org/packages/archive/tagged/0.4.2.1/doc/html/Data-Proxy.html> is probably better, though
14:18:39 <hpaste> hiptobecubic pasted “xmonad.hs” at http://hpaste.org/71657
14:18:44 <levi> I'd calculate the difference in area between the target rectangle and candidate rectangle after scaling the dimensions of the candidate such that one of its dimensions is equal to one of the target dimensions.
14:18:51 <hiptobecubic> balls, wrong channel. please ignore :)
14:19:18 <JoeyA> HairyDude: Okay.  If you don't plan to serialize other stuff, then the pack . show approach seems reasonable.
14:19:36 <shapr> I think the proper swear word on #haskell is "mutators".
14:19:50 <augur> hiptobecubic: Huey Lewis and the News in 3D!
14:19:53 <HairyDude> JoeyA: I may well end up using cereal anyway, just not yet :)
14:20:39 <ski> Catnaroek : how would you specify that you want to use the `Animal Cuproeline' instance rather than the `Animal Cuprarum' one for a use of `sound' ?
14:20:40 <JoeyA> I should get around to listing some design patterns I've encountered in Haskell.
14:20:51 <levi> You might want to only consider down-scaling as well, since it's typically better at preserving image quality than up-scaling.
14:21:02 <JoeyA> Googling "design patterns in Haskell", the first result just debunks a bunch of Java patterns.
14:21:12 <HairyDude> sound (undefined :: Cuproeline)
14:21:18 <ski> Catnaroek : saying `blah ... = ..(sound :: String)..' doesn't help
14:21:20 <JoeyA> One very common design pattern in Haskell is, believe it or not, object-oriented programming.
14:21:32 <ski> HairyDude : yeah, see `Proxy'
14:21:38 <JoeyA> Examples: IORef, Handle, Map
14:21:41 <Catnaroek> ski: Oh.
14:22:20 <HairyDude> I don't see that Map qualifies as OO
14:22:26 <Catnaroek> ski: What I would like to be able to do is pass the *type* as an argument, if something like that can be done.
14:22:29 <JoeyA> Minor variations in how the pattern is applied, but what these have in common is: an abstract type, and a bunch of accessors centered around that type.
14:22:37 <HairyDude> or IORef, for that matter
14:22:40 <Catnaroek> ski: I guess the closest equivalent to that would be explicitly passing the vtable.
14:22:42 <ski> Catnaroek : yeah, see the workarounds i mentioned above
14:22:47 <JoeyA> Why not IORef?
14:22:56 <HairyDude> it's just a variable
14:22:58 <Catnaroek> ski: Yeah, I am doing that, thanks!
14:23:05 <HairyDude> (in the imperative sense)
14:23:05 <JoeyA> Data.IORef is an object type.
14:23:16 <JoeyA> And there are abstract accessors to it.
14:23:27 <JoeyA> Granted, it's primitive, but it has an interface reminiscent of an OO class.
14:23:33 <codolio> Abstraction was invented in conjunction with object oriented languages?
14:23:38 <levi> JoeyA: That's Abstract Data Type programming, not OO programming.
14:23:45 <HairyDude> what levi said
14:23:50 <ski> Catnaroek : the `sound (undefined :: Cuproeline)' one which HairyDude is the traditional one, used in e.g. `typeOf' -- the `Proxy' one is nicer though, if you don't mind the extra dependency
14:23:50 <JoeyA> How are they different?
14:23:54 <ski> @type typeOf
14:23:55 <lambdabot> forall a. (Typeable a) => a -> TypeRep
14:24:17 <Catnaroek> @src Typeable
14:24:17 <lambdabot> Source not found. You speak an infinite deal of nothing
14:24:28 <levi> OO typically embodies some sort of subclass inheritance mechanism, but it's not really very precisely defined.
14:24:34 <ski> JoeyA : OO bundles the operations with the object state. ADTs doesn't insist on this (and usually doesn't)
14:24:44 <Catnaroek> Finally I see a use for undefined!
14:24:48 <JoeyA> levi: Not necessarily.
14:25:00 <JoeyA> ski: That's why I called it a "design pattern" in Haskell.  You mimic the bundling with modules.
14:25:09 <JoeyA> And most of the accessors take the object as the first argument.
14:25:16 <HairyDude> JoeyA: tbh, defining anything in Haskell as "object-oriented" requires you first to define "object-oriented", which is itself contentious.
14:25:31 <levi> Abstract Data Types are typically bundled in modules as well.
14:25:31 <JoeyA> Though in the case of Map, it's frequently the last argument, for point-free-ness.
14:25:41 <ski> ADTs can usually handle binary operations in a nicer way (think of merging two bags/maps where the keys have custom comparision)
14:26:05 <JoeyA> HairyDude: I did define it.  "<JoeyA> ... an abstract type, and a bunch of accessors centered around that type."
14:26:28 <Catnaroek> JoeyA: That seems more like encapsulation.
14:26:29 <HairyDude> JoeyA: I would call that an abstract data type, not an object
14:26:35 <JoeyA> ski: Right.  That's something OO often wishes it could do.
14:26:45 <ski> JoeyA : the order of the arguments is a red herring here
14:27:26 <ski> ADTs also naturally handles more than one abstract type, related to each other by the operations
14:27:34 <ski> (cf. "friends" in C++)
14:27:42 <JoeyA> To quote scripture (Wikipedia): Object-oriented programming (OOP) is a programming paradigm using "objects" – data structures consisting of data fields and methods together with their interactions – to design applications and computer programs.
14:28:13 <JoeyA> Granted, the "data fields" part doesn't apply much to IORef, but it sure does to Handle.
14:28:32 <HairyDude> JoeyA: the term "object oriented" is poorly defined, IMO, and wikipedia is not scripture.
14:28:34 <ski> the "data structures consisting of ... methods together with their interaction" is the crucial part, as compared to ADTs
14:28:41 <ski> @where object-oriented
14:28:42 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
14:29:24 <HairyDude> what ski said
14:30:09 <ski> i suppose `Handle' in some sense is OO, in that the OS will run different code depending on what kind of file handle it is (regular file, pipe, socket, device, fifo, &c.)
14:30:34 <JoeyA> So to sum up the feedback: the term "object-oriented" is not well-defined, so it wouldn't be a good name for a "design pattern".
14:30:59 <codolio> Go ahead and pitch your idea to Bob Harper.
14:31:02 <codolio> Or any ML programmer.
14:31:06 <ski> specific ideas originating in the OO community could be good names, though
14:31:29 <JoeyA> But I nonetheless assert that there's a "pattern", rather than rigid language feature, that IORef and Handle have in common.
14:31:46 <ski> i'm not sure why you bring `IORef' into this
14:32:06 <JoeyA> Because it has an abstract type, and a set of accessors.
14:32:19 <ski> i don't see in what sense it carries it's methods/operations inside it
14:32:39 <ski> just being an abstract type, and a set of operations doesn't make it OO, imo
14:32:40 <Nereid> what data does carry its methods/operations inside it
14:32:41 <Nereid> ?
14:32:44 <JoeyA> They don't have to be inside.  C++ methods (other than virtual methods) aren't "inside" the object except syntactically.
14:33:44 <JoeyA> But for IORef, there's a pattern followed manually: *IORef accesses (or in the case of newIORef, creates) IORefs.
14:33:45 <ski> JoeyA : yeah, and i don't think the non-virtual ones there are "really OO" (vague, i know)
14:33:47 <HairyDude> they are in python, for exampel
14:34:01 <c_wraith> There is a known haskell pattern that involves creating a record of functions - and sometimes those functions return new records of the same type.  That is what most people mean if they say something about "OO in haskell"
14:34:13 <Nereid> ^ what ski said.
14:34:23 <HairyDude> c_wraith: like xmonad's config type?
14:34:38 <ski> what c_wraith said
14:34:38 <c_wraith> HairyDude: I don't actually know that much about xmonad
14:34:39 <shachaf> c_wraith: We should come with a name for that!
14:35:03 <c_wraith> shachaf: Let's call it SLOOBNAOOSTNDCA Haskell.
14:35:27 <shachaf> c_wraith: No, we need a nice name like "The Visitor Pattern" or "The Observer Pattern"
14:35:39 <levi> There are, it seems to me, two general classes of systems when people talk about object-oriented systems.  They're the C++/Java style systems that heavily emphasize abstract data types with subtype polymorphism and then Smalltalk-style systems that emphasize message passing, encapsulation, and late-binding.
14:35:51 <HairyDude> the "record of functions some of which return a record of functions" pattern
14:36:45 <JoeyA> levi: Right.  The way I see it, message passing is usually asynchronous, while method calls are synchronous.  Or are Smalltalk messages synchronous and value-returning?
14:37:22 <levi> JoeyA: Smalltalk messages are synchronous, but they're late-bound.
14:37:33 <HairyDude> to be honest, OO seems to be just imperative-style abstract data types with knobs on, and it depends on your choice of language as to which knobs are mandatory
14:37:35 <JoeyA> ah
14:38:11 <levi> Asynchronous messages are more like Actors, Erlang, the origins of Scheme, etc.
14:38:33 <levi> Kind of the same roots, but went in a different direction before the term 'Object Oriented' got coined.
14:38:59 <HairyDude> dunno about smalltalk, but I hear objc is based on it and objc's messages return values.
14:39:26 <ski> @wiki OOP vs type classes
14:39:27 <lambdabot> http://www.haskell.org/haskellwiki/OOP_vs_type_classes
14:39:32 <JoeyA> The point of design patterns is to identify ways to structure programs that tend to work well.
14:40:10 <JoeyA> And each programming language has its own set of design patterns that work well.
14:40:23 <levi> Yes, they return values, but you can send any messages to any objects you want, and it's up to the particular object to decide how to handle a message and what to send in response.
14:41:01 <ski> i think Cale also had a page with some small game example -- can't find it atm, though
14:41:06 <ski> Cale ?
14:41:26 <JoeyA> A good list of Haskell design patterns would help people avoid, for example, writing a huge pile of functions in the same module that all share a bunch of arguments in common.
14:41:32 <JoeyA> (I've done this)
14:42:03 <HairyDude> that one would be solved by a Reader.
14:42:19 <JoeyA> Well, what if some context comes and goes?
14:42:35 <ski> HairyDude : SmallTalk and Simula are the original OO languages
14:42:39 <JoeyA> For example, you're setting up a connection, but you're waiting for the server to send you some configuration you'll use forever.
14:43:16 <JoeyA> Plus, it's not immediately obvious that using Reader is better than just marshaling the arguments by hand.
14:43:18 <ski> levi : the "it's up to the particular object to decide how to handle a message and what to send in response." is late binding
14:43:23 <levi> Simula was one of the inspirations to Smalltalk; Alan Kay (who designed Smalltalk) coined the term Object Oriented, but it's rarely used these days as he intended it.
14:43:33 <levi> ski: Yes
14:43:45 <ski> (just attempting to clarify)
14:44:01 <HairyDude> ski: yeah, I just haven't studied smalltalk at all, and I know even less about simula
14:44:09 <ski> JoeyA : did you look at the two links i provided above, yet ?
14:44:16 <levi> I had said late binding explicitly before, but I rephrased it to clarify as well. ;)
14:44:38 <ski> HairyDude : Simula is interesting in that instead of you calling `super', it "calls you"
14:44:56 <levi> Smalltalk even allows one to implement a 'doesNotUnderstand' method that handles received messages that don't correspond to any existing selectors.
14:45:01 <HairyDude> ski: I have a vague idea that simula influenced c++ and by extension java, while smalltalk influenced objc and javascript.
14:45:42 <ski> levi : for a statically checked system which implements something like "duck typing", see the OO system of O'Caml
14:46:17 <ski> (iow, no need to inherit from a specific class to be able to pass an object, the important thing is that the messages supported, and their types, match)
14:46:34 <JoeyA> ski: Yes, I skimmed them.
14:46:40 <ski> ok
14:46:57 <levi> ski: Go has a similar thing as well.
14:47:14 * ski hasn't looked at Go yet
14:48:02 <cads> @hoogle (a->b) ->(a-> c) -> (a -> (b, c))
14:48:03 <lambdabot> No results found
14:48:05 <ski> @quote Alan.Kay
14:48:05 <lambdabot> psykotic says: monochrom, I'm reminded me of that Alan Kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
14:48:09 <JoeyA> I might call this the "abstract monad pattern": http://hackage.haskell.org/packages/archive/criterion/latest/doc/html/src/Criterion-Monad.html
14:48:14 <mauke> :t (&&&)
14:48:15 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:48:32 <ski> damn mauke and his fast fingers ;)
14:48:53 <levi> Anyway, I think a collection of common Haskell idioms has a lot of value to it, especially for newcomers to the language.
14:49:55 <cads> Given f : a -> b and g : a -> c we have a function <f, g> : a -> (b, c). And given h: a -> c and i : b -> d we have (h, i) : (a,b) -> (c,d)
14:50:10 <JoeyA> The advantage of making the Criterion monad abstract is that its underlying representation can be changed without having to add a bunch of 'lift's everywhere.
14:50:11 <ski> cads : what mauke said
14:50:12 <levi> 'Tutorial Haskell' often bears little resemblance to the code snippets that are tossed around here, which I think is mostly a matter of a lot of #haskell people being well versed in the more advanced idioms of the language.
14:50:14 <cads> the first is sometiems called the fork of f and g
14:50:17 <ski> @type (***)
14:50:19 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:50:22 <ski> is the latter one
14:50:33 <cads> what is that called?
14:50:47 <ski> JoeyA : seems to me to be an ordinary ADT thing
14:51:23 <cads> and did I use the right notation ( <f, g> is what I've seen for fork in certain category theory contexts, and I think I've seen (h, i) in those same contexts)
14:51:36 <JoeyA> ski: Well, it's not immediately obvious that defining an abstract monad is a useful abstraction technique.
14:51:52 <JoeyA> An alternative might be to use ReaderT explicitly everywhere.
14:51:58 <levi> ski: Scala also has structural type annotations for its type system.  But it's not really late binding if it's statically typed.
14:52:45 <levi> Smalltalk objects (in many implementations, at least) can 'become' instances of different classes at runtime.
14:52:51 <ski> cads : sometimes i've seen the latter called "cross" (due to your `(h, i) : (a,b) -> (c,d)' often being written `h × i : a × b → c × d')
14:53:34 <cads> ah, that reminds me that i've seen the latter notation more often
14:53:37 <Nereid> well, h × i there would indeed be the product of h and i in the appropriate category
14:53:37 <saml> dmwit, how would you calculate distance between two aspect ratios (of rectangle) ?
14:53:51 <Nereid> I might writeh f ×_a g instead of <f,g> too
14:54:04 <Nereid> write
14:54:07 <saml> abs (ratio1 - ratio2)   sounds silly
14:54:10 <ski> levi : i'm not sure why it wouldn't be late binding. the code (the method) to run in response to a message is still determined at run-time
14:54:51 <ski> levi : i view the classes cruft as a bit orthogonal to the message passing stuff
14:54:53 <levi> ski: You're right, I guess it does qualify as late binding.
14:55:13 <realitygrill> did guard syntax change?
14:55:21 <realitygrill> i can't seem to write them without a parse error
14:55:22 <ski> (note that a subclass doesn't necessarily yield a subtype (even ignoring LSP))
14:55:34 <ski> realitygrill : hpaste ?
14:56:52 <hpaste> realitygrill pasted “parse error” at http://hpaste.org/71658
14:56:57 <ski> Nereid : hm, not `f ×_a g' for a pullback thingie, then ?
14:57:24 <Nereid> ski: oh, I guess that's it.
14:57:27 <Nereid> but haskell doesn't have pullback types :)
14:58:07 <c_wraith> realitygrill: I have no clue about the parse error you're talking about, but you definitely have a type error there.
14:58:21 <ski> well, i suspect it'd need subtyping (or row polymorphism, mayhaps) first
14:58:22 <levi> But I think that static type systems are somewhat antithetical to the 'worldview' of Alan Kay-style OOP.  His analogy is to compare the objects in a computer system to the hosts on the Internet.
14:58:26 <c_wraith> realitygrill: since a and b aren't functions
14:59:01 <realitygrill> c_wraith: I guess I don't see..
14:59:11 <ski> levi : i don't dispute that he seems to prefer dynamic typing
14:59:26 <realitygrill> c_wraith: no type error raised, it just hits parse error first :/
14:59:30 <Nereid> realitygrill: uh
14:59:43 <Nereid> I don't get a parse error.
14:59:48 <c_wraith> realitygrill: in the definitions of first and second, you have « a b » and « b c » after a $.
14:59:52 <Nereid> but you're applying a to b.
14:59:54 <Nereid> and b to c.
15:00:20 <ski> realitygrill : maybe you meant s/./.:/ ..
15:00:29 <Nereid> or better yet, alignVectors $ constructVector a b
15:00:40 <ski> realitygrill : i'd just write `alignVectors (constructVector a b)', though
15:00:41 <Nereid> and .: alone wouldn't fix it
15:01:02 <realitygrill> hmm
15:01:11 <Nereid> anyway, no parse errors here
15:01:37 <realitygrill> very odd
15:02:08 <ski> mayhaps you have a parse error above that code ?
15:02:19 <realitygrill> oh. that's possible..
15:03:35 <ski> levi : .. anyway the hosts-analogy seems to suggest (to a large part) asynchronous actors
15:04:34 <levi> ski: It does, and I don't think synchrony is fundamental to his view, but I think his emphasis was meant to be on autonomy.  Each object is conceptually its own full computing system.
15:04:36 <HairyDude> I could never quite grok pullbacks
15:04:38 <ski> i suppose your point might be that he includes stuff like revokation(sp ?) and failure to bind at run-time into the core model
15:04:52 <HairyDude> I mean, I understand them on an abstract level, but not what they're useful for
15:05:10 <ski> levi : i'm not sure how that is really in opposition to static checking, though
15:05:23 <Nereid> HairyDude: how about equalizers?
15:05:40 <ski> HairyDude : multiple (implementation) inheritance ?
15:05:47 <codolio> HairyDude: You know how when you compose two morphisms, the domain of one has to match the codomain of the other?
15:06:13 <HairyDude> ski: ah, yes.
15:06:22 <ski> HairyDude : also : implement module `A'. then `B' and `C' extends the functionality of `A', then `D' combines the functionality of both `B' and `C'
15:06:46 <realitygrill> didn't close a parens above. lame. thanks
15:06:48 <levi> I don't think it's necessarily in opposition to static checking of properties, as long as that static checking doesn't interfere with what he considers to be more fundamentally important.  Of course this is all very imprecise and messy, but I think that's the part of the point.
15:07:07 <HairyDude> codolio: I understand limits in general, but I only understand the uses of a handful (e.g. products)
15:07:26 <Nereid> I sometimes wish haskell had pullback types. but I don't see how they'd be possible without dependent types or somesuch
15:07:57 <codolio> HairyDude: When you do internal categories (category objects inside a category), the usual way is to have composition work on the pullback.
15:09:04 <codolio> D is the object of morphisms, so you require composition to work on the pullback of D with D over C (the object of objects), where one of the maps from D to C is codomain, and the other is domain.
15:09:18 <codolio> That pullback has pairs of morphisms where the inside objects match.
15:09:20 <Nereid> well, even in an ordinary (say, small) category, you have two functions s, t: Mor(C) -> Obj(C)
15:09:40 <Nereid> composition is then defined as a function (pull back of s and t) -> Mor(C)
15:10:01 <codolio> (f, g) where cod f = dom g
15:10:19 <codolio> Or whatever.
15:10:19 <Nereid> s(f) = dom f, and t(f) = cod f, yes.
15:10:35 <Nereid> (source and target)
15:10:40 <HairyDude> that's a pullback, not an equalizer?
15:10:50 <Nereid> well, pullbacks are equalizers of products
15:11:03 <Nereid> and equalizers are a special case of pullbacks, so
15:11:17 <Nereid> (as are products)
15:11:31 <Nereid> I mean
15:11:38 <HairyDude> in category theory there are infinitely many things that are special cases of other things...
15:11:45 <HairyDude> often in both directions
15:12:00 <codolio> HairyDude: In this particular case, you're looking to create the slimmed down product object.
15:12:05 <Nereid> if you have two things f: A -> C and g: B -> C, the pullback of f and g is the equalizer of the two induced maps A x B -> C
15:12:09 <codolio> So it's probably more natural as a pullback.
15:12:21 <Nereid> but yeah, the pullback gives it to you in one step.
15:12:36 <Nereid> also
15:12:41 <Nereid> a special case:
15:13:00 <ski> HairyDude : "An introduction to Category Theory for Software Engineers" (slides) by Steve Easterbrook in 1999 at <http://www.cs.toronto.edu/~sme/presentations/cat101.pdf> might be interesting
15:13:08 <Nereid> say we're in like the category of sets. if f: A -> C and g: B -> C, and g is an inclusion.
15:13:31 <Nereid> then the pullback is the inclusion of f^-1(B) into A.
15:13:37 <Nereid> er
15:13:43 <ski> HairyDude : there's also a book "Categories for Software Engineering" by Jose Fiadero
15:13:47 <Nereid> the pullback is f^-1(B), with one of the maps being that inclusion.
15:14:02 <Nereid> (and the other being a restriction of f)
15:14:43 <HairyDude> ski: Fiadero's book was the course book for a seminar on category theory I attended a few years ago... I didn't find it particularly enlightening
15:14:53 <Nereid> (sometimes you see phrases like "pullback of g along f" in situations like this)
15:15:23 <codolio> HairyDude: Basically, whenever you want something like a product of A and B, but only want the pairs (x, y) where some relation between x and y holds, that's probably doable as a pullback.
15:15:33 <ski> Nereid : the restricted case of pullbacks of record types along some canonical (multi-) projection could work with subtyping or row polymorphism, i think
15:15:54 <Nereid> what do you mean?
15:17:14 <ski> HairyDude : ok. i mentioned it because it's the only book in that vein i know of
15:19:21 <ski> (.. in `Set', pullbacks are for constructing subobjects of the form `{(x,y) : A * B | f x = g y}')
15:20:10 <Nereid> well, that is how you construct pullbacks in Set.
15:20:55 <HairyDude> oh, so f and g might establish an equivalence relation, which is realised by the pullback object
15:21:07 <shapr> Foo, haskell-platform failed to build on my Raspberry Pi :-(
15:21:18 <hpc> shapr: who cares, if you have ghc
15:21:24 <hpc> and cabal
15:21:28 <Nereid> HairyDude: well, not necessarily an equivalence relation
15:21:29 <shapr> I don't have cabal.
15:21:32 <hpc> oh
15:21:36 <shapr> That's where I'm going :-)
15:21:40 <HairyDude> Nereid: hence "might" :)
15:21:46 <HairyDude> Nereid: it's an example
15:22:19 <shapr> hpc: Is there an easier to install cabal than via haskell-platform?
15:22:28 <nand`> ‘cabal install cabal’
15:22:30 <nand`> wait..
15:22:33 * shapr grins
15:22:34 <hpc> shapr: you can build it yourself
15:22:39 <hpc> uh
15:22:45 <HairyDude> cabal comes with ghc
15:22:51 <Nereid> cabal comes with ghc, cabal-install doesn't
15:23:03 <shapr> Right, it's cabal-install I want.
15:23:03 <hpc> er, yeah cabal-install
15:23:10 <hpc> it's not hard to build
15:23:15 <hpc> doesn't even have extra depends
15:23:21 <HairyDude> so you install cabal-install via the build script in the cabal-install tarball
15:23:24 <shapr> I think it needs HTTP, zlib and something else.
15:23:31 <hpc> at worst, it's a few extra lines to get darcs
15:23:32 <hpc> apt-get install zlibg1-dev
15:23:32 <hpc> apt-get install zlibc
15:23:59 <hpc> oh yes, it does need zlib to extract hackage gzips
15:24:00 <HairyDude> even apt-get install ghc-zlib or something similar
15:24:38 <ski> Nereid : i mean we start with a record type `A' with some fields. make record types `B' and `C' which are defined as supertypes of `A', adding fields. and then we want to construct the pullback type which is the product of `B' and `C', where the respective `A'-fields in each agree
15:25:16 <Nereid> sure, ok.
15:25:40 <shapr> 700MHz Raspberry Pi with 256mb of RAM, (192mb for main memory) is very slow for compiling Haskell.
15:25:44 <cads> another use of pullbacks is composing spans, which can be used to represent partial functions, or ordinary relations
15:25:51 <Nereid> also dually I'd be interested in quotient types.
15:26:01 <Nereid> :P
15:26:11 <codolio> Miranda had low-rent quotient types.
15:26:13 <ski> yeah, (real) quotient types would be very nice
15:26:30 <edwardk> those baked in smart constructors?
15:26:33 <codolio> Yeah.
15:26:37 <ski> (of course ADTs often serve the purpose of implementing a quotient type, a subtype, or both at the same time)
15:26:43 <edwardk> i so want those for haskell =)
15:26:57 <ski> the problem is how do you check definitions are coherent :)
15:27:01 <cads> Nereid, I checked that the h x i really is a product. It's the product of h and i in the arrow category where objects are arrows and morphisms are commuting squares :)
15:27:12 <Nereid> yes.
15:27:15 <codolio> It's a little surprising no one ever pushed for them.
15:27:24 <Nereid> pullbacks are also products in an appropriate category
15:28:07 <edwardk> ski: well, with the miranda ones you just specified a few signatures like Foo (Bar a) = Bar a      and those got used during constructor application
15:28:51 <codolio> Yeah, they're not really quotient types.
15:29:16 <ski> `data Foo a = ... | forall b. FMap (b -> a) (Foo b) where forall foo. foo = FMap id foo; forall f g foo. FMap f (FMap g foo) = FMap (f . g) foo' would be a nice sugar for wrapping with `CoYoneda'
15:29:47 <ski> codolio : well, they're a special case
15:30:17 <Nereid> then again
15:30:43 <cads> Nereid, why do you suggest the f _a g notation for <f,g>. Doesn't that conflict with the usual notation of f _a g as the pullback object of f : b -> d, g: c -> d?
15:30:58 <Nereid> cads: yes, I noted that later.
15:31:20 <ski> so, for each definition `blah ... = ...; blah (FMap f foo) = ..f..foo..', the last clause would be run exactly once
15:31:21 <cads> ah, I thought there might be a deeper reason why those should be the same :)
15:33:47 * ski . o O ( "dual cat is dual" <http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/965006928_cXDUV> )
15:33:58 <codolio> ski: Those rules are probably a little dicey.
15:34:09 <ski> elaborate ?
15:34:20 <codolio> They could easily not terminate.
15:34:28 <cads> Nereid, in what category are pullbacks an example of products?
15:34:38 <codolio> They're not working toward normal forms.
15:34:55 <Nereid> cads: the pullback of f: A -> C and g: B -> C is a product in the category of "arrows over C"
15:35:00 <Nereid> er
15:35:02 <Nereid> "objects over C"
15:35:05 <ski> codolio : they're working towards exactly one `FMap' wrapping each "real" `Foo a'-thing
15:35:29 <Nereid> whose objects are arrows into C
15:35:35 <cads> Nereid, cool, I'll verify that
15:35:38 <ski> codolio : cf. `type Foo = CoYoneda RealFoo; data RealFoo a = ...'
15:36:04 <Nereid> i.e. a slice category
15:36:11 <codolio> 'foo = FMap id foo' alone can spin forever unless you give it a reason to stop.
15:36:23 <ski> with `data CoYoneda f a = forall b. FMapIncl (b -> a) (f b)'
15:37:19 <ski> codolio : yeah, the idea would be that that in combination with the other rule would stabilize it at one `FMap' wrapper
15:37:32 <Nereid> ski: oh my, thanks for the cats
15:37:33 <Nereid> :v
15:37:33 <ski> the question is of course how to achieve this, with general machinery
15:38:25 <ski> (iow, this is just a half-baked idea)
15:38:48 <codolio> When you add the two rules together, they can spin forever without running you out of memory. :)
15:38:57 <codolio> Even worse.
15:39:10 <ski> yes, but `id . f = f = f . id'
15:39:14 <coshapr> Did you know that conal used to just be named Nal ?
15:39:30 <coshapr> Then he got on the comonads wagon with the codolio, copumpkin and the rest of us.
15:39:37 <EvanR> lol
15:39:47 <ski> codolio : was that when he lived on the cosphere ?
15:39:52 <coshapr> Right!
15:40:58 <ski> (hm, would that be a hyperbolic plane, or mayhaps something else entirely ?)
15:42:38 <n-dolio> You should be ∞-shapr
15:42:45 <shapr> infinite shapr?
15:42:53 <shapr> I dunno, I can't talk quite that much.
15:43:11 <n-dolio> shaprs all the way down.
15:44:43 <shachaf> n-dolio: You should be -2-dolio
15:45:27 <n-dolio> Looks like ∞ doesn't work in nicks.
15:46:02 <n-dolio> Neither does -2-dolio.
15:46:12 * ski . o O ( "Crocheting the Hyperbolic Plane" by David W. Henderson,Daina Taimiða in 2001 (spring) at <http://www.math.cornell.edu/~dwh/papers/crochet/crochet.html> )
15:53:01 <Nereid> ski: neat
16:32:48 <Melvar> Why is the standard Comonad variable “w”?
16:34:33 <copumpkin> it's m upside-down
16:34:49 <jairavax> Favorite web framework?
16:34:55 <Melvar> No, that’s “ɯ”.
16:34:56 <c_wraith> also, w clearly stands for comonad
16:35:14 <shachaf> c0wmonad
16:35:21 <hpc> clearly, comonads should be "Monad" upside down
16:35:22 <copumpkin> jairavax: favorite insurance company?
16:35:27 <hpc> or rotated, as ∀∃
16:35:32 <hpc> peuoW
16:35:46 <hpc> (depending on how your font renders 'a')
16:35:54 <shachaf> Mine renders an upside-down 'e'.
16:36:24 <mauke> pɐuoɯ
16:36:39 <hpc> https://dl.dropbox.com/u/37707/Untitled.png
16:37:23 <tazjin> Dɪᴅ sᴏᴍᴇʙᴏᴅʏ sᴀʏ Mᴏɴᴀᴅ?
16:37:39 <mauke> ｙｅｓ
16:39:03 <Melvar> pɐuoꟽ
16:39:56 <mauke> ... I need more fonts
16:42:04 <hpc> i just need putty to render fallbacks
16:42:12 <tazjin> mauke: afaik there's old German letters somewhere in Unicode as well
16:42:15 <mm_freak> does anyone have a font that renders unicode's "pile of poo" character properly?
16:42:21 <hpc> mm_freak: unifont?
16:42:57 <tazjin> mm_freak: The default font on OS X > 10.7
16:43:01 <tazjin> ᙢᗢﬡᗩᖙᔕ?
16:44:43 <otters> unifont!
16:45:38 <Melvar> 💩
16:46:00 <pt> te
16:46:13 <pt> :info head
16:46:43 <mm_freak> unifont doesn't seem to contain it
16:46:58 <Melvar> “Symbola” font is used by my char picker for PILE OF POO.
16:48:43 <mm_freak> ok, i'll stop searching for shit
16:53:14 <EvanR> Melvar: how did you do that o_O
16:53:36 <Melvar> EvanR: Do what?
16:57:23 <monochrom> is it a monad or an applicative? it's both! http://www.vex.net/~trebla/photo/unorganized/burrito-salad.jpg
16:57:41 <hpc> lol
16:58:42 <nand`> ‘Applicatives are just like salads’
16:59:26 <dolio> That thing in the picture is clearly not a burrito.
17:00:20 <shachaf> dolio: The thing in the picture is clearly both a burrito and a salad.
17:00:25 <shachaf> Didn't you read it?
17:00:34 <dolio> I read it. The sign is lying.
17:00:37 <dolio> It's just not a burrito.
17:01:00 <tazjin> What does the thing need to implement to be considered a proper instance of the burrito class?
17:02:05 <dolio> Burritos have an outer tortilla shell. The pictured objects is some food in an aluminum pan.
17:02:40 <shachaf> Perhaps it's an aluminium tortilla.
17:03:01 <dolio> Wait, unless, upon a closer look, there are actually burritos in that pan.
17:03:29 <dolio> It looked like a bunch of insides in the pan at first, but maybe it's a burrito surrounded with lettuce.
17:04:39 <monochrom> my cell phone has a very low-res camera, and it is the only camera I carry around daily
17:05:27 <monochrom> my cell phone is one of those old Nokia 6103 or something. you know, "recharge every week instead of every day" :)
17:06:01 <dolio> My phone doesn't even have a camera.
17:08:58 <tazjin> This seems to be a close up picture: http://eatdrinktoronto.net/wp-content/uploads/2012/01/Z-teca-salad.jpg
17:09:11 <tazjin> it's from the same company and also called a "burrito salad", so that should be it
17:09:29 <monochrom> ah, yes, I agree, also the "toronto" part
17:10:12 <tazjin> Unfortunately their website doesn't explain it further ( http://www.z-teca.com/ )
17:11:32 <dolio> Yeah, you can't really tell from that picture, either.
17:12:18 <dolio> Although you can tell that it doesn't look very appetizing.
17:12:40 <Eduard_Munteanu> dolio: what phone is that, a 3410? oO
17:13:09 <dolio> I don't even know. It says Samsung on it.
17:13:10 <shachaf> dolio: Searching Google for "is it a burrito or is it a salad", it suggests the search "is a burrito a sandwich judge says no".
17:13:21 <shachaf> So I guess the criteria are pretty strict.
17:13:33 <dolio> Judge as in court of law?
17:13:43 <dolio> Or judge as in official burrito/sandwich judge.
17:13:52 <dolio> Like, of a sandwich contest.
17:14:11 <shachaf> Court of law, it seems.
17:14:19 <shachaf> "Massachusetts Judge Settles Dispute by Ruling Burrito is Not a Sandwich"
17:14:38 <Eduard_Munteanu> Good, we needed to know that.
17:14:38 <tazjin> Sounds a bit like the whole pizza == vegetable thing
17:14:48 <dolio> I'm glad we're getting that nailed down over here.
17:15:25 <Eduard_Munteanu> Yeah, I wish pizza was a healthy, vitamin-y snack! :D
17:17:57 <dolio> I wonder where he got the official legislation on what constitutes a sandwich.
17:19:10 <shachaf> Well, now there's precedent.
17:19:36 <tazjin> The only link I can find on that topic leads to Fox News
17:19:58 <dolio> The question is: are quesadillas sandwiches?
17:20:07 <tazjin> Ah: http://www2.courthousenews.com/onpoint/burrito.pdf
17:21:01 <Eduard_Munteanu> At least people can't make a monad<->sandwich analogy now.
17:21:13 <tazjin> The important part is the last paragraph on page 5
17:25:50 <dolio> See? I bet Qdoba sells lots of quesadillas.
17:25:56 <dolio> They should have hired me as a legal advisor.
17:34:40 <slack1256> how is opensuse with it's haskell packages?
17:34:44 <slack1256> are they up to date?
17:38:27 <c_wraith> what version of ghc does it have packaged?
18:03:26 <enigmuriatic> http://bpaste.net/show/efRtF3t945ve9Rfx14Hy/
18:03:34 <enigmuriatic> can someone tell me why that doesn't work?
18:03:40 <enigmuriatic> something to do with the null, right?
18:03:44 <copumpkin> null is a function
18:03:55 <enigmuriatic> i'm very new to haskell. very interesting stuff though :D
18:03:57 <copumpkin> you have to return something
18:03:59 <Rung> greetings from a haskell newb
18:04:01 <enigmuriatic> so what do I return in that case?
18:04:11 <copumpkin> enigmuriatic: a value of the correct type :P
18:04:19 <copumpkin> you have [a] -> a
18:04:24 <enigmuriatic> it's supposed to return the second to last item in a list
18:04:33 <copumpkin> yeah, so what if that item isn't there?
18:04:35 <enigmuriatic> but if there are none or one items in a list...
18:04:40 <enigmuriatic> exactly
18:04:52 <copumpkin> so that seems like a flaw in the basic question :)
18:05:00 <Rung> got a question if someone might take a sec; how do I print an integer and a string together onscreen?
18:05:02 <copumpkin> you need to handle those cases
18:05:19 <JoeyA> Rung: print (123, "abc")  ?
18:05:28 <JoeyA> Or do you mean without the intervening syntax?
18:05:36 <JoeyA> putStrLn $ show n ++ " " ++ s
18:05:48 <JoeyA> show s would display it in quotes.
18:06:01 <copumpkin> enigmuriatic: the secret is generally to use Maybe
18:06:12 <copumpkin> enigmuriatic: Maybe indicates that there's the possibility of not returning a value
18:06:14 <Rung> huh, ok I thought I tried that...
18:06:19 <Rung> let me run it again
18:06:23 <copumpkin> unlike most languages, haskell tries to avoid having null in every type
18:06:32 <copumpkin> at least the kind of null you're used to
18:06:46 <enigmuriatic> copumpkin: i see... i vaguely remember that from the Google Tech Talk video i watched
18:06:48 <shachaf> copumpkin: C doesn't have null in every type.
18:06:56 <shachaf> Would be nice if they did. :-(
18:07:10 <enigmuriatic> i'll try to reformat it
18:07:41 <JoeyA> shachaf: Nor do Java or C#, as far as I know
18:07:45 <enigmuriatic> when using maybe, what do I use as the return value?
18:08:13 <JoeyA> safeHead :: [a] -> Maybe a
18:09:01 <enigmuriatic> ah
18:09:09 <enigmuriatic> so i don't need the if statement anymore?
18:09:25 <copumpkin> enigmuriatic: you return Nothing
18:09:31 <copumpkin> and if you do have a value, you wrap it in Just
18:09:33 <enigmuriatic> ah, thanks
18:09:36 <copumpkin> > Just True
18:09:37 <lambdabot>   Just True
18:09:38 <copumpkin> > Nothing
18:09:39 <lambdabot>   Nothing
18:09:52 <rofer> > Just Nothing
18:09:52 <lambdabot>   Just Nothing
18:10:08 <copumpkin> > Just Just
18:10:09 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> Data.Maybe.Maybe a)
18:10:09 <lambdabot>    arisin...
18:10:17 <copumpkin> > Just Just :: Maybe (a -> Maybe a)
18:10:18 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> Data.Maybe.Maybe a)
18:10:18 <lambdabot>    arisin...
18:10:24 <copumpkin> pfft
18:10:35 <copumpkin> > isJust $ Just Just
18:10:36 <lambdabot>   True
18:11:14 <otters> what do you call it when x = some computation and repeatedly using x doesn't re-invoke the computation?
18:11:18 <shachaf> data Moral a = Just a | Unjust
18:11:34 <shachaf> copumpkin: "spoon" should clearly be called "bringJustice" or something.
18:11:39 <copumpkin> lol
18:12:00 <JoeyA> otters: Like this?  xs = "AA" ++ xs
18:12:22 <otters> JoeyA: no, I just mean let x = reverse [1..10] in { multiple uses of x }
18:12:32 <enigmuriatic> http://bpaste.net/show/sO5OdxZlHYFCtV5BMqYR/     It's still telling me that the pattern in non-exhaustive
18:12:33 <otters> I could've sworn there was a defined term for it on the wiki somewhere
18:12:36 <JoeyA> Ah, I think "memoization" is the word you're looking for.
18:12:40 <otters> yeah
18:12:47 <otters> Okay, so is the same true for IO actions?
18:13:08 <JoeyA> The IO action itself is probably memoized, but I wouldn't bet my life on it.
18:13:46 <otters> I'm using regex-pcre and I've defined a list of regexes I'm using to filter an input string
18:13:52 <otters> but it has to be in IO because regex-pcre uses the FFI
18:13:54 <otters> I think
18:13:57 <otters> anyway, it has to be in IO
18:14:04 <otters> and I want to make sure that the list of regexes isn't re-computed every time
18:14:25 <otters> since regexen :: IO [(Regex, [String] -> String)]
18:14:33 <enigmuriatic> can anyone help me out with that? I've included all advice up to this point but the function is still non-exhaustive
18:14:53 <JoeyA> otters: Well, if you bind the result of regexen to something, that something won't recompute it, of course.
18:15:13 <JoeyA> But if you keep calling regexen over and over, it'll be recomputed over and over.
18:15:36 <hpaste> Rung pasted “agePredictor” at http://hpaste.org/71663
18:15:47 <JoeyA> You can say this: {-# NOINLINE regexen #-}   regexen :: [(Regex, [String] -> String)]; regexen = unsafePerformIO $ do ...
18:15:50 <JoeyA> And that'll be memoized.
18:16:07 <saml> enigmuriatic, what do you mean?
18:16:10 <otters> Oh, that's what I wnt!
18:16:13 <otters> NOINLINE
18:16:29 <saml> enigmuriatic, you need a case for empty list
18:16:39 <otters> Although to be fair, regexReplace also uses unsafePerformIO
18:16:49 <enigmuriatic> saml: the function i posted above ( http://bpaste.net/show/sO5OdxZlHYFCtV5BMqYR/ ) loads fine, but when i attempt to use it the compiler says that it is non-exhaustive
18:16:56 <Rung> I almost have a grasp on basic IO, could someone check my hpaste and let me know what's happening plz?
18:17:04 <otters> should I noinline regexReplace too?
18:17:16 <saml> enigmuriatic, try to call  lastButOne []
18:17:54 <enigmuriatic> no matter what i put in it's nonexhaustive, saml
18:18:02 <enigmuriatic> and therefore doesn't execute
18:18:14 <JoeyA> Rung: Tabs vs spaces.
18:18:34 <enigmuriatic> the nonexhaustive thing is a compiler error that gets passed before it gets executed
18:18:37 <Rung> hmmm, how so?
18:18:39 <JoeyA> The last line is at a different indentation level according to the compiler.
18:18:44 <Rung> thx btw
18:18:47 <JoeyA> print age2 is tab-indented
18:18:49 <saml> enigmuriatic, replace [a]  with l
18:18:50 <JoeyA> but the last line isn't.
18:19:15 <Rung> weird
18:19:16 <enigmuriatic> thanks, saml. what's the significane of that change?
18:19:32 <JoeyA> Rung: I recommend you configure your editor to indent with spaces instead of tabs, to avoid hidden surprises like this.
18:19:49 <Rung> wow, that's a strange one -- will do
18:20:04 <saml> enigmuriatic, l  will match [], [a], [a,b], ...etc
18:20:04 <Rung> I would never have figured that out on my own...
18:20:08 <saml> [a]  will only match [a]
18:20:24 <c_wraith> I wish tabs were a lexical error.  That'd fix so many problems.
18:20:31 <JoeyA> Rung: Nobody can agree on the One True tab width, so the Haskell compiler treats a tab as one space (right?)
18:20:46 <Rung> really?
18:20:55 <JoeyA> GHC should throw a compile-time error if it detects any files on your hard drive with tabs.
18:21:07 <c_wraith> no, they're specified as moving to the next tab stop, which are 8 spaces apart
18:21:20 <JoeyA> c_wraith: Ah, okay.  Thanks for the clarification.
18:21:34 <JoeyA> c_wraith: Then shouldn't Rung's code work, then?
18:21:58 <c_wraith> I don't know why it's broken, actually.
18:22:07 <c_wraith> I mean, the tab is the problem
18:22:11 <c_wraith> But I don't know why
18:23:14 <Rung> I wonder in how many other ways my Haskell tutorial has been affected by this bug...
18:23:14 <enigmuriatic> saml: is this what you had in mind? because it won't let me load it anymore: http://bpaste.net/show/hMooEL5KAsAqWKGtSXZk/
18:23:57 <saml> enigmuriatic, is this a homework?
18:24:15 <enigmuriatic> no, it's from Real World Haskell
18:24:27 <enigmuriatic> do you know how I can fix that function?
18:24:45 <saml> remove the first line
18:24:56 <saml> ::  thing is not needed
18:25:25 <Rung> thx again guys
18:25:33 <saml> no problem
18:27:59 <enigmuriatic> it's odd how it prepends the return value with "Just ". What's the significance of that?
18:30:39 <Veinor> enigmuriatic: because a value of type Maybe Int, for example
18:30:46 <Nimatek> @src Maybe
18:30:49 <Veinor> is either Nothing or Just 2, or Just 8, or Just (some other integer)
18:30:54 <lambdabot> data Maybe a = Nothing | Just a
18:31:05 <enigmuriatic> Veinor, doesn't that introduce complications when you use that value elsewhere, though
18:31:15 <Veinor> depends
18:31:26 <Veinor> > (* 2) . (+ 5) <$> Just 10
18:31:33 <lambdabot>   Just 30
18:31:38 <JoeyA> @info Maybe
18:31:38 <lambdabot> Maybe
18:31:46 <saml> Maybe is like Java Object
18:31:52 <Veinor> that's
18:31:54 <JoeyA> :i Maybe
18:31:54 <JoeyA> pah
18:31:54 <JoeyA> data Maybe a = Nothing | Just a
18:31:54 <JoeyA> :t Just
18:31:54 <JoeyA> enigmuriatic: 'Just' is a data constructor.  It acts like a function a -> Maybe a, and is needed to lift a value to Maybe.
18:31:54 <lambdabot> forall a. a -> Maybe a
18:31:54 <JoeyA> Otherwise, you'll get a type error because 'a' and 'Just a' aren't compatible.
18:31:56 <enigmuriatic> like if I have a function that takes Int, would it freak out if I gave it a Maybe Int?
18:31:57 <Veinor> not a helpful analogy at all
18:32:08 <Veinor> enigmuriatic: yes, because Int and Maybe Int aren't the same type
18:32:23 <enigmuriatic> isn't that kind of complicating and inconvenient, though?
18:32:30 <Veinor> fortunately, Maybe is what's called a Functor
18:32:33 <enigmuriatic> i guess it's necessary though, now that i think of it
18:32:39 <Veinor> and LYAH covers Functors eventually
18:32:52 <shachaf> enigmuriatic: Yes, it would.
18:32:58 <Veinor> also, yeah. what's Nothing + 1?
18:32:59 <shachaf> enigmuriatic: A Maybe Int *might* have an Int in it, or it might not.
18:33:00 <shachaf> You have to check, and think about what should happen in the case that it doesn't.
18:33:41 <shachaf> It is. :-)
18:33:42 <shachaf> But the alternative is worse.
18:33:42 <shachaf> enigmuriatic: The alternative is that you *could* pass a Maybe Int to something that expected an Int.
18:33:44 <shachaf> Then that thing would either (a) have to check or (b) crash.
18:34:14 <BMeph> ..."because 'a' and 'Maybe a' aren't the same type," I'd say. ;)
18:34:31 <Nimatek> > do { a <- Just 2; b <- Just 3; return (a+b) }
18:34:36 <Veinor> what if a = Mu Maybe, huh???
18:34:39 <Nimatek> > do { a <- Just 2; b <- Nothing; return (a+b) }
18:34:51 <shachaf> The nice thing about Maybe is that you *have* to check in some places, but in places where there isn't a Maybe, you don't have to check. You don't even have to think about it.
18:34:53 <shachaf> As opposed to "null", which you sort-of have to worry about everywhere.
18:35:11 <Nimatek> lambdabot is being slow.
18:35:15 <shachaf> Veinor: That's why we don't have equirecursive types!
18:35:17 <enigmuriatic> starting to get the hang of this Haskell thing. :D thanks
18:35:28 <Veinor> equirecursive meaning
18:35:30 <lambdabot>   Just 5
18:35:30 <lambdabot>   can't find file: L.hs
18:35:47 <shachaf> Anyway, y'all should stop confusing poor enigmuriatic with "do" and "Functor".
18:35:56 <favonia> > do { a <- Just 2; b <- Nothing; return (a+b) }
18:36:02 * hackagebot kevin 0.1.5.1 - a dAmn  IRC proxy (JoelTaylor)
18:36:06 <shachaf> Maybe is a perfectly sensible concrete data type that you ought to understand all on its own before getting into those things.
18:36:24 <shachaf> Veinor: Meaning that Maybe *is* = Mu Maybe.
18:36:24 <shachaf> Which it isn't in Haskell.
18:36:28 <shachaf> You can't have the type a = Maybe a.
18:36:28 <dmwit> saml: The size of the symmetric difference between two unit rectangles of the two aspect ratios seems like a sane metric.
18:36:32 <Nimatek> lambdabot needs a coffee.
18:37:01 <saml> dmwit, what's symmetric difference   and unit rectangles?  let me google
18:37:18 <lambdabot>   Nothing
18:37:50 <dmwit> (Call a rectangle a "unit rectangle" when its short side has length 1.)
18:38:12 <dmwit> saml: I just made up the term unit rectangle, so Google won't help there.
18:38:38 * saml is trying to picture
18:39:10 <saml> so, from r1 and r2, i get aspectRatio1 and aspectRatio2.. and from there, i get unit rectangles.. and i calculate symmetric difference
18:40:44 <dmwit> Symmetric difference means the area outside one or the other of the two rectangles.
18:40:53 <dmwit> Think of it as being "xor" for sets.
18:40:53 <dmwit> x \in xor(A,B) iff xor(x \in A,x \in B)
18:41:14 <shachaf> dmwit: Similarly, y \in yor(A,B) iff yor(y \in A,y \in B)
18:43:56 <dmwit> saml: Yeah, just a bit of algebra.
18:44:06 <dmwit> shachaf: Looks like the natural generalization. =D
18:44:56 <dmwit> saml: I think I've changed my mind about whether that's a sane way to do it, though.
18:45:10 <saml> :P
18:45:47 <dmwit> hehe
18:55:57 * hackagebot egison 2.3.0 - An Interpreter for the Programming Language Egison (SatoshiEgi)
19:07:20 <Guest43465> im having trouble with cabal on osx
19:07:47 <Guest43465> cabal update works
19:07:51 <startling> Guest43465, what kind of trouble? which version of os x? how did you install cabal?
19:09:07 <Guest43465> cabal install ixset
19:09:11 <Guest43465> does not work, error message:
19:09:59 <Guest43465> cabal: Couldn't read cabal file "ixset/1.0.3/ixset.cabal"
19:10:58 <Guest43465> :(
19:11:04 <Guest43465> i installed it with homebrew
19:11:10 <Guest43465> haskell platform
19:12:08 <EvanR> startling: lion
19:15:03 <EvanR> i successfully installed drawing combinators though
19:15:08 <EvanR> wtf is wrong with ixset
19:21:11 <rofer> Any idea why I can't load up Text.Regex.Posix? GHCi can't seem to find it.
19:21:42 <otters> install it
19:21:46 <rofer> It's version 7.4.1 and I'm on Debian linux 64
19:21:51 <rofer> Ah, it's not standard?
19:22:08 <EvanR> how am i supposed to install it on osx?
19:22:11 <startling> EvanR, no idea, sorry.
19:22:32 <otters> EvanR, what are you installing?
19:22:35 <otters> Lemme see if I can help
19:22:38 <EvanR> ixset
19:23:16 <EvanR> cabal install ixset
19:23:21 <otters> oh, huh
19:23:25 <otters> I just installed it successfully
19:23:35 <EvanR> what version of ghc / cabal do you have
19:23:39 <EvanR> how do you install that
19:23:50 <otters> ghc 7.4.1
19:24:00 <EvanR> i have 7.0.4
19:24:01 <otters> cabal 0.14.0 using Cabal 1.14.0
19:24:04 <otters> oh
19:24:06 <EvanR> can i upgrade
19:24:18 <otters> probably
19:24:24 <EvanR> what should i use to upgrade / reinstall
19:24:28 <EvanR> to do it right this time
19:24:34 <startling> EvanR, probably homebrew
19:24:46 <EvanR> thats what i used the first time...
19:25:01 <startling> EvanR, oh. then just brew update and brew upgrade
19:25:09 <EvanR> brew update fails
19:25:35 <startling> EvanR, would be helpful to know how it fails
19:25:44 <hpaste> EvanR pasted “fuck this” at http://hpaste.org/71664
19:26:24 <startling> EvanR, what is that file? is it important?
19:26:28 <otters> you edited the voldemort formula
19:26:35 <EvanR> i did not
19:26:41 <startling> EvanR, someone did
19:26:43 <EvanR> no idea what that is
19:26:45 <otters> then remove Library/Formula/voldemort.rb
19:26:46 <otters> and you'll be fine
19:26:47 <EvanR> ok
19:27:08 <startling> EvanR, it's trying to git pull the new formulas and it's finding a conflict
19:27:32 <EvanR> uhm where is Library/Formula
19:27:45 <startling> /usr/local/Cellar usually, I think
19:28:02 <startling> er just /usr/local rather
19:28:11 <startling> Cellar is a different homebrew thing
19:28:19 <EvanR> i ok
19:28:21 <EvanR> ok
19:28:25 <EvanR> trying again
19:28:41 <EvanR> done
19:28:47 <EvanR> now brew upgrade?
19:28:50 <EvanR> im scared...
19:29:04 <startling> EvanR: brew upgrade ghc if you don't want to wait forever
19:29:04 <EvanR> warning you have Xcode 4.1 which is outdated
19:29:05 <EvanR> fuck
19:30:37 <EvanR> upgrading ghc anyway
19:30:40 <EvanR> hopefully
19:36:42 <EvanR> well i did it
19:37:33 <EvanR> same error message
19:37:37 <EvanR> cabal install ixset
19:37:44 <EvanR> cabal: Couldn't read cabal file "ixset/1.0.3/ixset.cabal"
19:39:20 <EvanR> well no more time tonight for this
19:50:15 <iox22c1p> http://pastebin.com/8781164R
19:50:18 <mauke> The paste 8781164R has been copied to http://hpaste.org/71665
19:50:23 <iox22c1p> I need help, please
19:50:40 <iox22c1p> It doesn't work correctly on windows
19:51:16 <iox22c1p> It's supposed to update the content in-line, but prints out new lines instead
19:51:57 <Cale> er, why are you using putStr "\r" ?
19:52:15 <Cale> \n should be a proper newline, no matter what platform you're on
19:53:18 <iox22c1p> Didn't know that, so I need to take out "\r" ?
19:53:27 <Cale> yeah, if you want a newline, just use \n
19:53:42 <tertl9> HEY
19:53:52 <tertl9> agda is in haskell?
19:54:00 <iox22c1p> But it's not supposed to print newlines
19:54:01 <tertl9> is agda a language or a tool?
19:54:06 <Cale> The text IO in Windows will exchange \n for \r\n on windows
19:54:11 <Cale> tertl9: both?
19:54:18 <iox22c1p> It's supposed to update the current line
19:54:24 <tertl9> can you make a GUI with AGDA/
19:54:26 <Cale> tertl9: It's a programming language which is also a theorem prover.
19:54:43 <Ralith> tertl9: are languages not tools?
19:54:46 <tertl9> Cale fully funcitonal?
19:54:55 <tertl9> no
19:54:58 <Cale> tertl9: I don't know if there are any GUI libraries for Agda but there's nothing conceptually worrying about that.
19:54:58 <tertl9> nmaybe
19:55:15 <tertl9> ok thanks you
19:55:49 <Cale> Agda right now is maybe where Haskell was 10 or 12 years ago as far as userbase is concerned.
19:56:04 <Cale> So there is not a whole lot of library support yet.
19:56:23 <shachaf> Cale: Haskell had so few users in 2000?
19:57:09 <tertl9> cool
19:57:36 <tertl9> shopuld I adopt agda in place of haskel so i can be an uber hipster/
19:57:39 <tertl9> ?
19:57:48 <startling> agda is pretty coolb but I can't imagine using it for anything real
19:57:57 <startling> which is how I used to think about haskell, so meh
19:58:05 <tertl9> heh
19:58:06 <jmcarthur> i can imagine it, but i don't do it
19:58:16 <tertl9> startling u did that yo yourself
19:58:29 <tertl9> is it pragmatic?
19:58:37 <tertl9> does it make sense?
19:58:38 <startling> tertl9: I did what yo myself?
19:58:58 <tertl9> <startling>agda is pretty coolb but I can't imagine using it for anything real
19:58:58 <tertl9> <startling>which is how I used to think about haskell, so meh
19:59:13 <tertl9> you juxtaposed yourself
19:59:35 <jmcarthur> i am confused
19:59:45 <Cale> tertl9: Agda makes sense and as a language looks reasonably decent, but it would be a very un-pragmatic choice of language to make for a real-world project at the moment, not by any fault of the language, but for the fact that there's just not a lot of libraries yet.
19:59:58 <jmcarthur> i agree with that
20:00:02 <Cale> So if you want to do real stuff in Agda you're going to have to write it yourself mostly.
20:00:04 <tertl9> Cale i feel ya
20:00:09 <hpaste> dstcruz pasted “config.nix” at http://hpaste.org/71666
20:00:54 <dstcruz> hello all, I'm trying to follow the section on "local use via nixpkgs config" from this page: http://nixos.org/wiki/Haskell
20:00:54 <jmcarthur> also, i haven't seen any evidence that the compiled results are at all reliable or efficient, but that may just be because i've looked in the wrong places (and have never tried to build a working program with agda, myself)
20:01:19 <jmcarthur> i mostly just write little agda modules to help me write my haskell code
20:01:31 <dstcruz> ooops, wrong channel. my bad.
20:01:37 <jmcarthur> since agda-mode is pretty awesome
20:02:01 <jmcarthur> but then i'm disappointed when i can't quite express the same things in haskell that i just wrote in agda
20:02:11 <jmcarthur> at least, not without unsafeCoerce
20:02:29 <jmcarthur> or odd trickery i often don't discover
20:04:25 <startling> agda-mode is kind of cludgy for me
20:04:42 <startling> though maybe it doesn't work in emacs 24? I have no syntax highlighting, notably
20:05:00 <tertl9> ok
20:05:02 <ParahSailin__> seems haskell would be good for HDL
20:05:03 <tertl9> i was just asking
20:05:15 <tertl9> I had a bookmark for learn you an agda
20:06:08 <tertl9> does anyone here use haskell for everything and refuse to use anything else?
20:06:13 <jmcarthur> startling: i have recently had a similar problem. it only affects the first agda file you load during a run of emacs. if you close the file and reopen it, it will highlight
20:06:41 <jmcarthur> that said, it's pretty annoying
20:07:17 <Cale> tertl9: I'm not going to say I'd refuse to use anything else, but if I was starting a new project, I'd probably prefer Haskell for most things.
20:07:22 <jmcarthur> tertl9: i do, except at work (where i use ocaml) and when i use agda (which, as i said, is really just to help me write haskell code anyway)
20:07:35 <startling> jmcarthur, not for me. :/
20:07:43 <Ralith> what does agda-mode give you?
20:07:47 <jmcarthur> well, and i also don't hesitate to use C for the FFI and stuff
20:07:47 <Cale> tertl9: There are a lot of features that Haskell has which it's just not easy to give up once you're used to them.
20:07:51 <jmcarthur> startling: weird
20:07:56 <shachaf> Ralith: So much.
20:08:31 <Ralith> go on
20:08:36 <jmcarthur> Ralith: agda-mode lets you put holes in your code and helps you fill them in by taking advantage of its knowledge about types
20:08:50 <shachaf> jmcarthur: GHC 7.6 supports holes!
20:09:19 <Ralith> anything else?
20:09:22 <jmcarthur> Ralith: typically about 50% of my agda code (apart from data type definitions and type signatures) is actually written by agda-mode
20:09:30 <startling> shachaf: oh nice
20:09:46 <jmcarthur> shachaf: to what extent? does it provide type information similar to what agda does?
20:10:01 <Ralith> jmcarthur: that is impressive
20:10:06 <Ralith> where can I find some examples?
20:10:08 <jmcarthur> shachaf: or are you just talking about that optionally dynamic typing feature?
20:10:47 <shachaf> jmcarthur: No, it has Agda-style holes, I hear.
20:11:14 <jmcarthur> cool!
20:11:20 <jmcarthur> if true, i can't wait
20:11:48 <shachaf> http://hackage.haskell.org/trac/ghc/wiki/Holes
20:12:13 <jmcarthur> Ralith: i've never watched this before, but it looks like it might be a decent demonstration http://www.youtube.com/watch?v=pP7ynVdVY9A
20:12:45 <Ralith> cool, thanks
20:13:01 <shachaf> Holes in terms. Thijs Alkemade and Sean Leather have been working on another variant of deferred error messages, that would allow you to write a program that contains as-yet-unwritten sub-terms, or "holes" and have GHC report a fairly precise type for the hole. The idea is inspired by Agda's interactive programming environment, which has a facility of this kind. The more complicated the types get, the more useful this is! Details on their wiki page 
20:13:13 <jmcarthur> Ralith: i never feel like i can trust others to demonstrate features of agda-mode quite the way i would though
20:13:43 <Cale> GHC 7.6 has case sections, but the implementor chose the worst option for the concrete syntax of those :P
20:14:05 <shachaf> Cale: What syntax?
20:14:14 <Cale> \case of { ... }
20:14:30 <Cale> ^-- why is that lambda necessary at all?
20:15:40 <shachaf> > case оf of оf | оf -> оf
20:15:42 <lambdabot>   True
20:15:45 <jmcarthur> shachaf: that looks like a nice extension indeed
20:15:45 <shachaf> That's a weird syntax.
20:17:40 <geekosaur> of isn;t a keyword?  I guess the lambda does make sense then
20:17:46 <geekosaur> sadly
20:17:51 <shachaf> of is a keyword.
20:17:52 <Cale> http://www.smbc-comics.com/ -- haha
20:17:55 <geekosaur> because boy is that crap syntax
20:18:00 <shachaf> Cale: Indeed.
20:18:00 <Ralith> jmcarthur: I can understand that. I'm loosely familiar with holes from my just-beginning study of Idris; it seems remarkable that you could produce so much code from them.
20:18:15 <geekosaur> [18 03:15] <shachaf> > case оf of оf | оf -> оf
20:18:30 <shachaf> geekosaur: If of wasn't a keyword, that would be terribly ambiguous.
20:18:34 <shachaf> > "case оf of оf | оf -> оf"
20:18:35 <lambdabot>   "case \1086f of \1086f | \1086f -> \1086f"
20:18:49 <geekosaur> yoy did notice that LB didn;t throw a syntax error?
20:19:00 <geekosaur> it took of as a binding name where appropriate
20:19:04 <geekosaur> case closed
20:19:16 * shachaf doesn't have the heart to toy with #haskell people this way anymore.
20:19:30 <geekosaur> or were yoy playing bot games?
20:19:35 <shachaf> 20:18 <shachaf> > "case оf of оf | оf -> оf"
20:19:56 <geekosaur> [18 03:15] <shachaf> > case оf of оf | оf -> оf
20:19:56 <geekosaur> [18 03:15] <lambdabot>   True
20:19:59 <geekosaur> rthis is a bot game?
20:20:01 <shachaf> 20:18 <lambdabot>   "case \1086f of \1086f | \1086f -> \1086f"
20:20:09 <Cale> hint: Unicode
20:20:17 <geekosaur> oy
20:20:33 <shachaf> > "aλ9" -- hooray for \&!
20:20:34 <Cale> о = CYRILLIC SMALL LETTER O
20:20:35 <lambdabot>   "a\955\&9"
20:21:15 <jmcarthur> Ralith: it depends on how constraining your types are (and also on how good you are at writing types that are still easy to work with, which turns out to be pretty tricky)
20:22:17 <jmcarthur> Ralith: the main reason that 50% isn't higher is that my types often are *not* constraining enough, so i have to give it a lot of hints in the right direction
20:22:17 <adu> heh
20:22:34 <Ralith> you'd expect it to be higher? o.O
20:23:28 <jmcarthur> Ralith: by, for example, offering the function i intend to fill the current hole in with and then using C-c C-r to replace the hole with that function and the appropriate number of arguments as holes. after that, it may again be able to fill the holes in for me
20:24:24 <ParahSailin__> it is confusing which ones are keywords and which are functions
20:24:42 <jmcarthur> it's kind of like guiding a car. it requires some control, but at least you don't have to walk
20:26:01 <copumpkin> I love walking!
20:30:51 <dmwit> Cale: Um, are you sure?
20:31:02 <dmwit> The original patch, and the thing agreed upon in the ticket, uses "\case".
20:31:07 <dmwit> Not "\case of".
20:31:18 <Cale> oh is it just \case { ... }?
20:31:20 <dmwit> yes
20:31:21 <Cale> without of?
20:31:24 <dmwit> yes
20:31:28 <Cale> oh, that's even weirder
20:31:39 <dmwit> I agree, but it's not as horrible as "\case of".
20:31:40 <Cale> is \case a layout keyword then?
20:31:44 <dmwit> Yes.
20:32:11 <Cale> what about \ case ?
20:32:23 <dmwit> This confusion explains your email to the mailing list, too, I guess, which looked like it came out of left field to me.
20:32:46 <dmwit> I haven't tested.
20:32:57 <dmwit> I'd be surprised if that was any different than \case, though.
20:32:58 <Cale> I really just prefer the original syntax that was put in the ticket
20:33:19 <dmwit> Yes, well, lots of people had lots of opinions. Somebody had to lose.
20:33:20 <Cale> There's no reason for a lambda to be around without a bound variable
20:33:21 <dmwit> I lost, too.
20:34:51 <Cale> hmm, what if someone were to submit another patch for the other syntax? :)
20:36:02 <dmwit> The Simons have decided.
20:38:25 <dmwit> http://hackage.haskell.org/trac/ghc/ticket/4359#comment:69
20:51:43 <ion> “case of …” > “\case …” :-P
20:52:47 <Veinor> they went with \case?
20:52:59 <tgeeky_> sigh
20:53:26 <Veinor> annoying, but it's better than nothing
21:03:46 <dmwit> I'd say that about 75% of the people involved don't like "\case".
21:04:03 <dmwit> Unfortunately, for each alternative A, about 75% of the people involved don't like A either.
21:04:52 <shachaf> dmwit: "at least 75%", please.
21:07:45 <fragamus> hey I want to find a function that determines the position of an element in a list
21:08:32 <shachaf> fragamus: (a) What would its type be?
21:08:36 <shachaf> (b) @hoogle
21:08:43 * shachaf saves day.
21:08:58 <fragamus> yeah that's what I wanted
21:08:58 <ion> (c) ???
21:09:05 <ion> (d) PROFIT
21:09:09 <shachaf> (c) 2012 shachaf
21:09:10 <fragamus> haha
21:09:56 <fragamus> [a] -> Integral @hoogle
21:10:03 <shachaf> fragamus: What?
21:10:07 <shachaf> That's not a type. :-(
21:10:22 <dmwit> ?hoogle [a] -> [Int]
21:10:22 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
21:10:23 <lambdabot> Prelude cycle :: [a] -> [a]
21:10:23 <lambdabot> Data.List cycle :: [a] -> [a]
21:10:50 <shachaf> fragamus: I advise figuring out the type first. It'll be a good exercise.
21:10:52 <fragamus> oops
21:10:57 <fragamus> yeah
21:10:57 <dmwit> oops
21:11:06 <dmwit> spoiled the exercise =(
21:11:23 <shachaf> dmwit: Fortuantely that's not the type that fragamus was after.
21:11:26 * dmwit loves exercises
21:11:41 <fragamus> findIndices :: (a -> Bool) -> [a] -> [Int]
21:11:45 <dmwit> I think it was, he just doesn't know it yet.
21:12:05 <shachaf> dmwit: I think fragmaus was after REDACTED.
21:12:15 <ion> shachaf: I agree.
21:12:17 <dmwit> Oh yeah? Well I think *you're* REDACTED!
21:12:23 <shachaf> Ouch. :-(
21:12:29 <fragamus> I'm after findIndices :: (a -> Bool) -> [a] -> [Int]
21:12:49 <shachaf> fragamus: You're sure you're not after blah :: Eq a => a -> [a] -> Maybe Int?
21:13:00 <fragamus> but I was also after learning that way of looking up on hoolge
21:13:07 <fragamus> hoogle even
21:13:09 <dmwit> Laziness means there's no good reason to prefer Maybe for the result type.
21:13:19 <shachaf> dmwit: Sure there is.
21:13:22 <shachaf> Maybe is a handy type.
21:13:38 <shachaf> Also, Eq vs. a predicate.
21:13:39 <latro`a> Maybe would be great for findIndex, not so great for findIndices
21:13:45 <dmwit> Sorry, there's one good reason: you plan to feed it into some other function that's too monomorphic.
21:13:51 <dmwit> The Eq thing I can probably get on board with.
21:13:57 <shachaf> dmwit: Like "maybe" or "fromMaybe"?
21:14:02 <fragamus> yeah I'm after that too
21:14:03 <shachaf> Or your computations in the "Maybe monad"?
21:14:04 <dmwit> Yes, like maybe or fromMaybe.
21:14:07 <dmwit> Yes.
21:14:15 <fragamus> but in this case findIndices :: (a -> Bool) -> [a] -> [Int] is better
21:14:18 <mchm> Hi. How do I check which GHC version I'm running? And can I update it using cabal? (I've searched the web prior to coming here)
21:14:18 <shachaf> Monomorphism is good.
21:14:21 <shachaf> ghc --version
21:14:24 <shachaf> Nope.
21:14:27 <zachk> which is the latest base for hackage?
21:14:39 <zachk> mchm: ghc --version ?
21:14:43 <Veinor> zachk: what do you mean?
21:15:00 <mchm> zachk: thanks. Can cabal update it?
21:15:11 <Veinor> mchm: nope
21:15:12 <zachk> mchm: not sure
21:15:30 <dmwit> base is not installable from Hackage. The latest ghc uses base-4.5.1.0, whose docs are available from Hackage.
21:16:05 <mchm> ok
21:16:17 <zachk> is there an easy way to display jpegs using haskell?
21:16:21 <dmwit> zachk: Not sure whether that answers your question or not.
21:16:25 <zachk> gloss-devil seems out of date
21:16:45 <dmwit> It's pretty easy with gtk. =)
21:16:49 <zachk> dmwit: to the extent of it poorly formed to begin with, yes it did answer it, thank you dmwit
21:16:57 <zachk> I need it to run on windows, easily
21:17:00 <mchm> hmm.. I am running 7.4.1 but LLVM won't install - fails at llvm-base-3.0.1.0
21:17:09 <zachk> and mac, easily
21:17:19 <shachaf> mchm: "won't install" and "fails" aren't very helpful.
21:17:30 * zachk thinks that gloss will allow this....but is unsure
21:17:58 <xvilka> hi
21:18:02 <mchm> shachaf: I know, that's why I'm asking here! It's the information I get from cabal.
21:18:17 <dmwit> I bet you get more information than that.
21:18:18 <shachaf> mchm: That's the entirety of what cabal prints?
21:18:24 <shachaf> $ cabal install llvm
21:18:29 <xvilka> anyone know more advanced examples for FFI than on haskell doc?
21:18:29 <shachaf> fails at llvm-base-3.0.1.0
21:18:39 <shachaf> "i h8 u" - dcoutts
21:18:48 <dmwit> xvilka: There's lots of examples on Hackage.
21:19:33 <mchm> shachaf: here http://pastebin.com/BQNDktzm
21:19:36 <mauke> The paste BQNDktzm has been copied to http://hpaste.org/71670
21:19:45 <shachaf> Don't tell me, man! Tell the channel.
21:19:51 <shachaf> checking for llvm-config... no
21:19:58 <shachaf> Sounds like you should get llvm-config installed.
21:20:05 <shachaf> configure: error: could not find LLVM C bindings
21:20:15 <shachaf> Rather, sounds like you should get LLVM C bindings installed.
21:20:44 <mchm> question is... why aren't they installed with a "cabal install llvm"?
21:20:58 <shachaf> Because that's a Haskell package that binds to LLVM.
21:21:02 <shachaf> You install LLVM separately.
21:21:03 <dmwit> Because cabal-install is for Haskell stuff, not C stuff.
21:21:14 <mchm> I thought I could use -fllvm with ghc out of the box :/
21:21:18 <dmwit> You can.
21:21:22 <shachaf> GHC doesn't use the LLVM C bindings.
21:21:25 <dmwit> Though I'm not sure how that's related.
21:22:13 <dmwit> Well, you can, if you have llvm installed. So I guess the situation is vaguely related. =P
21:22:43 <mchm> heh
21:25:09 <imrobert> I downloaded the haskell-platform tar.gz from the site and ghc 7.4.2 from the Arch repo. The haskell platform says it's for 7.4.1. Is there an updated one somewhere that just hasn't been put on that site yet?
21:25:28 <mchm> Weird. I can use -fllvm fine. I can't use it as proposed here though : http://stackoverflow.com/a/6964760/1142160
21:26:11 <mchm> when compiling my file, ghc --make -fllvm -O2 -fforce-recomp file.hs produces an error telling me to install LLVM.
21:26:40 <mchm> but ghc --make -fllvm -O2 file.hs works fine.
21:28:44 <dmwit> imrobert: No, but you can just cabal-install the packages provided by the platform.
21:29:06 <dmwit> Or you can skip installing GHC-7.4.2.
21:29:16 <dmwit> The platform ships with a copy of GHC.
21:29:49 <imrobert> Oh, the site is a little confusing then: "Get and install GHC 7.4.1 prior to building the platform"
21:30:02 <dmwit> mchm: Remove test.o and test.hi and tell me if anything changes.
21:30:14 <dmwit> or whatever, file.o and file.hi
21:30:27 <dmwit> imrobert: You shouldn't be building the platform, only installing it.
21:31:05 <mchm> dmwit: just tried that. turns out I can't use -fllvm
21:31:08 <mchm> gneh
21:31:38 <imrobert> dmwit: So just run make install?
21:32:27 <dmwit> I've never used the platform, but if it has a Makefile, then that would probably do it, yep.
21:32:35 <mchm> imrobert: depends on what you have downloaded
21:32:42 <mchm> under Arch, probably
21:32:49 <imrobert> http://hackage.haskell.org/platform/linux.html
21:32:59 <imrobert> "Build from source"
21:33:03 <imrobert> the tar.gz
21:33:12 <imrobert> The link to the Arch package is broken
21:33:17 <imrobert> I couldn't find another.
21:33:29 <mchm> imrobert: well, then the instructions are there. You need to build, and then install, yes.
21:34:06 <imrobert> mchm: dmwit just told me I wasn't supposed to be building it
21:34:16 <mchm> I'm glad to be under OS X - no need to build :)
21:34:34 <mchm> imrobert: well, if you downloaded the source, you need to build it prior to installing.
21:35:07 <imrobert> mchm: Yeah, which brings me back to my original question. What's up with the versions?
21:35:27 <imrobert> It says I need 7.4.1 but I have 7.4.2
21:35:56 <mchm> imrobert: I'm new to Haskell too - I'd go the safe way at first, just download 7.4.1 and then upgrade if necessary
21:36:18 <imrobert> mchm: Yeah, that sounds like a good idea.
21:36:47 <xvilka> hm. about FFI - which Haskell type i need use for C "void *" ptr? Ptr CChar?
21:37:18 <dmwit> imrobert: Oh, if the package for your distribution doesn't work, then you need to build it yourself, yes.
21:37:33 <dmwit> It is probably fine to use GHC 7.4.2 instead of 7.4.1 to build from source.
21:37:54 <dmwit> Point releases generally fix bugs and don't introduce breaking changes.
21:39:21 <dmwit> xvilka: Ptr, StablePtr, or FunPtr, depending on how you plan to use it, yes.
21:39:55 <dmwit> Generally speaking, the void * bits of C are there to accommodate the lack of closures, though, so it's generally unnecessary to translate the void * bits.
21:40:27 <startling> unions too, since c union types can't be added to
21:40:48 <xvilka> hm
21:40:55 <dmwit> Unpacking that a bit: one common place for void * in C is to give some auxiliary data for callbacks to use.
21:41:21 <dmwit> When translating this pattern into Haskell, the idiomatic thing to do is instead to just hand over a callback that has already captured the necessary data.
21:41:38 <xvilka> dmwit: not all the time, for example malloc() function
21:41:54 <dmwit> Yes, I agree, this is not the only place in C where void * is used.
21:42:04 <dmwit> And I tried to word my language to avoid making that claim.
21:42:18 <dmwit> (However, I think it would be a bit odd to write a binding to malloc.)
21:42:51 <xvilka> dmwit: thx for explanation. Can't imagine purpose of hs binding to malloc too, just example
21:46:12 <xvilka> btw, is it better to use same names for functions as in C library?
21:47:03 <dmwit> It's common, yes; what's nice about it is that any documentation that exists for the C library is ever-so-slightly more useful.
21:47:30 <dmwit> Or at least have a very predictable translation between the two names.
21:47:30 <geekosaur> similar but different is best, actually; you can get into trouble with the symbol names ending up being the same
21:47:59 <geekosaur> although I guess the type should be encoded into the mangled haskell functuon name ideally
21:48:17 <mm_freak> xvilka: Ptr a
21:48:55 <mm_freak> (or ForeignPtr or StablePtr…  the point is the polymorphic element type)
21:50:24 <mm_freak> if you /want/ to disallow dereferencing, then there are two ways…  1. use whatever type you want with no storable instance
21:50:59 <mm_freak> 2. use RankNTypes, which is safer, because it disallows writing a Storable instance:  withWhateverPtr :: (forall a. Ptr a -> IO b) -> IO b
21:51:15 <mchm> Still getting this error http://hpaste.org/71670 when trying to cabal install llvm on OSX 10.6.8 with LLVM-3.1 installed.
21:52:14 <dmwit> Are the LLVM C libraries installed?
21:52:47 <mchm> dmwit: I've just installed LLVM-3.1 using MacPorts
21:52:59 <mchm> dmwit: so they should
21:53:20 <geekosaur> you probably need to add a pointer to /opt/local to the cabal file
21:53:33 <geekosaur> but note that you will probably fail later with an iconv error
21:53:39 <xvilka> mm_freak: thanks for hints!
21:53:52 <dmwit> If you were on Linux, I would ask if you had the -dev versions of the llvm libraries installed.
21:54:01 <dmwit> I don't know what the equivalent question for MacPorts is.
21:54:12 <mchm> -devel
21:54:23 <mchm> I don't, but sure I'll port install that.
21:54:24 <mchm> brb
21:54:40 <geekosaur> um
21:55:04 <geekosaur> macports has no such distinction since until very recently it was only build from source
21:55:23 <geekosaur> so all packages had (and in manu cases still have) to be what linux calls a dev package
21:55:34 <dmwit> I see.
21:55:39 <dmwit> No, I don't see.
21:55:44 <geekosaur> -devel in macports means someone's alpha or beta release
21:55:56 <dmwit> Just because you have the source doesn't mean you install the headers and whatnot in the right (global) place, does it?
21:56:20 <dmwit> I guess there's no reason not to if you're building from source, though.
21:56:24 <dmwit> okay
21:56:35 <mchm> geekosaur: ah ok
21:56:41 <geekosaur> dmwit, llvm is not very useful without those headers, especially if something else builds from source and depends on it
21:57:16 <geekosaur> you would have to install most packages as linux-style-dev packages, so nobody bothers to separate them out
21:57:38 <mchm> no luck anyway -- the -devel port is obsolete.
21:57:54 <geekosaur> yeh, that's also not unusual
21:58:32 <dmwit> Darn, there go the easy problems. =P
21:58:56 <geekosaur> what it comes down to usully is nothing looks under /opt/local for stuff by default, so you need to point configure to it to find libraries there
22:00:02 <mchm> geekosaur: point configure?
22:00:36 <geekosaur> in this case configure is being run by cabal so something needs to be put in the cabal file to tell it to tell configure to look under /opt/local
22:00:53 <mchm> ok
22:01:15 <geekosaur> but I think you jusrt demonstrated that I owuld have to dig ut the hard drive and the inverter and work out the correct invocation for you...
22:01:40 * geekosaur is absolutely not in any position to track this stuff down for people right now
22:02:16 <mchm> geekosaur: no. that was enough information to get me started. thanks
22:03:21 <geekosaur> I don;t get it, I already said that befpre just not with the internal details
22:03:52 <mchm> unh?
22:11:41 <dmwit> It's my fault. I distracted mchm with my -dev talk.
22:17:41 <startling> Say I have a map-like structure of a -> b, and an almost-isomorphic map-like structure of a. Is there a typeclass for applying these (with a default a -> b)?. it's *almost* applicative, but not quite
22:18:51 <shachaf> ?
22:20:04 <startling> hm, another example: halfApply x (Just (+ 1)) (Just 12) = Just 13; halfApply x Nothing (Just 12) = Just $ x 12
22:20:59 <startling> A more concise way to say it would be "applicative with a default"
22:21:04 * hackagebot google-html5-slide 2011.0 - Google HTML5 Slide generator (HideyukiTanaka)
22:21:46 <latro`a> any reason for the output to be in Maybe, when you're supplying a default?
22:21:58 <latro`a> I guess the last argument could be Nothing
22:22:11 <startling> latro`a: right
22:22:54 <startling> specifically I have a weird labelled tree that I need to do this kind of thing on. I've already written the class and instances for Map (which I use in my tree thing) and my tree thing
22:22:58 <dmwit> :t \x mf mv -> liftM2 ($) (mf <|> Just x) mv
22:22:59 <lambdabot> forall a2 b. (a2 -> b) -> Maybe (a2 -> b) -> Maybe a2 -> Maybe b
22:23:15 <latro`a> :t <|>
22:23:16 <lambdabot> parse error on input `<|>'
22:23:16 <startling> I'm just wondering if there's a typeclass that defines this kind of behavior out there already
22:23:21 <latro`a> :t (<|>)
22:23:22 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
22:23:34 <dmwit> :t \x mf v -> fromMaybe x mf v
22:23:35 <lambdabot> forall t t1. (t -> t1) -> Maybe (t -> t1) -> t -> t1
22:23:57 <latro`a> yeah it is sort of a fromMaybe when you allow for currying
22:24:07 <latro`a> that is it's fromMaybe in the first two arguments
22:24:28 <dmwit> My first proposal has the right type and behavior; my second proposal points out that you only showed us what it should do when the final argument is a Just.
22:24:33 <latro`a> and then the third argument is a first argument
22:24:45 <latro`a> ...mostly
22:24:49 <latro`a> minus the last argument being Nothing
22:25:09 <startling> dmwit, doesn't really matter to me. I'm not looking for an implementation
22:25:26 <startling> well, I'm not asking how to write an implementation
22:25:33 <dmwit> :t \x mf -> (fromMaybe x mf <$>)
22:25:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> Maybe (a -> b) -> f a -> f b
22:26:08 <dmwit> :t \x mf -> ((mf <|> pure x) <*>)
22:26:09 <lambdabot> forall (f :: * -> *) a b. (Alternative f) => (a -> b) -> f (a -> b) -> f a -> f b
22:26:26 <dmwit> ...that's a provocative type, actually.
22:26:32 <startling> I can't rely on Applicative, since Applicative is stronger than what I'm thinking about
22:26:52 <dmwit> Since f (a -> b) -> f a -> f b is supposed to be exactly what you can't do.
22:26:56 <startling> e.g, what would be pure for Data.Map's instance?
22:27:01 <dmwit> Oh, wait, no, I'm an idiot.
22:27:37 <tgeeky> that first one... (a -> b) -> Maybe (a -> b) -> {- natural transformation -}
22:27:47 <tgeeky> shouldn't that first part look weird??
22:28:02 <tgeeky> i mean, if you have an (a -> b), do you need to wrap it in a maybe?
22:28:21 <dmwit> :t \x mf -> (maybe (pure x) mf <*>)
22:28:22 <lambdabot> forall b a a1. b -> (a1 -> a -> b) -> (Maybe a1 -> a) -> Maybe a1 -> b
22:28:29 <startling> tgeeky: I don't understand
22:28:53 <dmwit> :t maybe
22:28:54 <tgeeky> startling: i'm asking dmwit,  for my own understanding
22:28:54 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:29:08 <startling> tgeeky: oh, thought that was aimed atme
22:29:10 <startling> my mistake
22:29:26 <dmwit> :t \x mf -> maybe (pure x <$>) (<*>) mf
22:29:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => b -> Maybe (f (a -> b)) -> f a -> f b
22:29:32 <dmwit> bleh
22:29:46 <hpaste> startling pasted “HalfApplicative” at http://hpaste.org/71673
22:30:00 <startling> ^ that's my implementation so far. any suggestions?
22:30:01 <dmwit> tgeeky: Sorry, what?
22:30:17 <dmwit> tgeeky: We're not wrapping an (a -> b) in a Maybe, we're turning an a -> b into a Maybe a -> Maybe b.
22:30:39 <dmwit> :t \x mf -> maybe (x <$>) (<*>) mf
22:30:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (a -> b) -> Maybe (f (a -> b)) -> f a -> f b
22:30:49 <latro`a> what the
22:30:50 <coppro> dmwit: I don't think that's quite right either
22:30:55 <dmwit> No, it's very not right.
22:30:56 <latro`a> Monoid m => HalfApplicative a =>
22:30:59 <latro`a> wtf
22:31:13 <coppro> startling: is it roughly equivalent to having a [Maybe (a -> b)] and wanting to apply them over your structure?
22:31:19 <startling> latro`a: what's wrong with that?
22:31:26 <startling> coppro: sooort of
22:31:30 <tgeeky> startling: for the theory on applicative functors, see Ralf Hinze's Lifting Lemmas and Laws
22:31:40 <coppro> startling: what is not right?
22:31:42 <latro`a> I didn't even know you were allowed to do that, but given that you can, why would you anyway
22:31:53 <latro`a> when you can do (Monoid m,HalfApplicative m) =>
22:31:57 <startling> latro`a: oh, right
22:32:00 <latro`a> (insert whitespace as desired
22:32:01 <latro`a> )
22:32:15 <startling> coppro, Data.Map can't have infinite Nothings
22:32:21 <startling> oh wait, yes it can
22:32:27 <startling> (it already does)
22:32:38 <tgeeky> startling: there are 3 known versions of applicative: the normal one (with k combinators), a weaker one (without i (id), c (.), b (flip), and s combinators), and a linear version
22:33:00 <dmwit> Semantically speaking, I'm pretty sure you just want Alternative.
22:33:20 <startling> dmwit: Alternative is a subclass of Applicative, yes?
22:33:20 <dmwit> I agree that it's a shame that Haskell doesn't allow you to make Map k an Alternative even though semantically speaking it's clear how it should behave.
22:33:25 <latro`a> it is indeed
22:34:05 <startling> oh, I think I understand
22:34:22 <tgeeky> startling: also, checkout 'unfoldable'. the Unfoldable class is a further subclass of Alternative
22:34:35 <otters> TIL you can do boolean logic in the SKI combinator calculus
22:34:46 <startling> otters: birds that do logic
22:34:54 <dmwit> My advice would be to pull the constrained-monad trick, but with Applicative/Alternative, and make Map an instance of that class.
22:34:57 <otters> I love SKIing
22:35:09 <latro`a> *groan*
22:36:12 <dmwit> Alternately, you might consider making a newtype which wraps up a (Map k v, v) (where the v is to be viewed as a default value).
22:36:22 <dmwit> It seems plausible that this could be made an instance of Alternative.
22:36:24 <startling> dmwit: ooh
22:36:30 <latro`a> cute
22:36:56 <coppro> really, it sounds like a zipWith
22:37:10 <dmwit> Yes, Applicative is for types that have n-ary zips for all n.
22:37:20 <coppro> specifically, with maybe . id
22:37:26 <dmwit> pure is 0-ary zip, and (<*>) is 2-ary zip, from which all other n can be derived.
22:38:00 <tgeeky> even though I know that he's right, I still don't believe it :o
22:38:52 <coppro> I suppose
22:38:59 <coppro> actually wait, yeah, that makes sense
22:39:14 <dmwit> The analogy can be a bit of a stretch; e.g. the list monad's Applicative instance.
22:39:17 <coppro> I don't think this is necessarily an Altenrative though?
22:40:24 <startling> alternatively, I could map something across the difference in keys between the data tree and the function tree
22:41:57 <coppro> startling: really, it sounds like (maybe . id) <$> foo <*> bar is the way to go
22:42:29 <dmwit> In any case, I think this HalfApplicative is not a good idea.
22:43:10 <startling> what does "maybe" do?
22:43:12 <coppro> I agree; it's just an Applicative where one of the things is a Maybe and should probably be represented as such
22:43:16 <coppro> @src maybe
22:43:16 <lambdabot> maybe n _ Nothing  = n
22:43:16 <lambdabot> maybe _ f (Just x) = f x
22:43:34 <coppro> hmm wait, got it backwards
22:43:39 <coppro> @src fromMaybe
22:43:40 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
22:43:43 <coppro> that's the one
22:43:46 <startling> coppro: yep, makes a lot of sense that way
22:43:54 <coppro> fromMaybe id <$> foo <*> bar
22:43:56 <startling> coppro: oh, right
22:44:04 <tgeeky> hehe, it's a new fangled case pattern :o
22:44:09 <coppro> just replace all the Nothings with id and then apply them liberally!
22:44:16 <startling> anyway, thanks a bunch, everyone!
22:44:31 <coppro> startling: actually
22:44:34 <coppro> that will probably fail
22:44:40 <coppro> given how you define Applicative
22:44:51 <startling> coppro: hm?
22:45:00 <coppro> but (map (fromMaybe id) fntree) <*> argtree
22:45:40 <startling> coppro, map/fmap doesn't reach the empty items of the Map, though
22:46:02 <startling> (fmap (fromMaybe id) fntree) is equivalent to fntree
22:46:16 <startling> I'd need to compose with lookup, right?
22:46:25 <coppro> startling: aaahhhh
22:46:40 <coppro> startling: I'd fix that
22:46:52 <startling> coppro: hm?
22:46:53 <coppro> oh wait, I see what you're sayign...
22:47:03 * coppro understands the problem now
22:47:09 <startling> so a lookupWithDefault seems like the way to go
22:47:43 <coppro> startling: just define <*> not to do anything to objects with no corresponding function
22:47:52 <coppro> hmm wait, you can't do that :/
22:48:09 <coppro> startling: wait
22:48:14 <coppro> how does that Functor instance even work?
22:48:27 <coppro> I am going to call your type XTree for lack of a better name
22:48:27 <startling> what functor instance?
22:48:33 <coppro> on XTree
22:49:01 <startling> sec
22:49:44 <hpaste> startling pasted “LabelTrees” at http://hpaste.org/71674
22:50:54 <coppro> startling: now you have a LabelTree (a -> a) and a LabelTree a and you want to apply the first to the second where they match?
22:52:01 <startling> a LabelTree (a -> b) and a LabelTree a
22:52:17 <startling> P.S. is there a real name for this data structure?
22:52:35 <tgeeky> Functor?
22:53:01 <coppro> startling: you can't do that
22:53:10 <tgeeky> F (a -> b) -> F a -> ..
22:53:13 <solrize> @last dons
22:53:13 <lambdabot> No module "dons" loaded
22:53:21 <coppro> startling: at least, not without some a -> b to apply where your labels don't match
22:53:21 <solrize> @seen dons
22:53:22 <lambdabot> Unknown command, try @list
22:53:26 <tgeeky> @xseen dons
22:53:27 <lambdabot> Unknown command, try @list
22:53:48 <startling> coppro: exactly!
22:54:26 <coppro> startling: perhaps have a LabelTreeDefaultFn or something helper type
22:54:46 <coppro> hmm... wait, no, that doesn't work
22:54:54 <startling> well, mempty could work
22:55:04 <startling> const mempty, that is
22:55:04 <coppro> your type certainly isn't an Applicative
22:55:04 <tgeeky> startling: oh. I have an idea. Check out transformers-0.3.0.0 . There's a class to add an alternate Pure to an Applicative
22:55:07 <coppro> it's waker
22:55:12 <tgeeky> startling: that's exactly what you want, I think
22:55:24 <coppro> startling: yes, that would work if you have the Monoid requirement
22:56:02 <startling> coppro, how isn't it applicative?
22:56:11 <startling> tgeeky, what's it called?
22:56:29 <startling> oh, I could probably leverage >>= for this
22:56:40 <tgeeky> startling: http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Applicative-Lift.html
22:57:11 <tgeeky> use the pure like you're currently using pure, and use Other (f a) as the default when you don't have a function
22:58:05 <coppro> startling: Because you have no way to actually get to b when you have no corresponding a
22:58:16 <coppro> (unless you accept a Monoid requirement on b, in which case it works)
22:58:35 <startling> coppro, yep.
22:59:15 <tgeeky> startling: what kind of structure are you actually dealing with, any? If it's almost-isomorphic, do you have a pair of almost bijective homomorphisms?
23:00:37 <coppro> startling: although it's a shame that you can't put the requirement only on the destination type
23:00:55 <coppro> since really, the requirement is on <*>, not your tree type
23:02:33 <startling> tgeeky, I want a neat way to specify creating a directory of files from an existing directory of files
23:02:51 <dmwit> startling: Again, your Tree l c is semantically a partial function [l] -> c. If you turn it into a total function (for example, by storing a top-level default c or a default c for each prefix), it's clear how to make this an Applicative.
23:03:09 <dmwit> Alternative is maybe a tad less clear from the semantic interpretation, but more clear from the operational one.
23:03:19 <coppro> yeah
23:03:33 <startling> dmwit: yep! understood
23:03:46 <coppro> I'd go with that.
23:04:26 <dmwit> ...and then the function you want is something like (treeOfFunctions <|> pure defaultFunction) <*> treeOfValues
23:04:28 <Nereid> and even a Monad.
23:05:55 <dmwit> Actually, I'd like to amend my above statement: the Applicative instance is clear even for partial functions. It's the representation that's hard without a bit of extra data like a default value.
23:06:16 <Nereid> because you're restricted to partial functions with finite domain
23:06:29 <startling> I guess I don't understand what I would have for (<|>) in the Alternative instance
23:07:37 * dmwit reviews the Alternative laws
23:08:51 <coppro> dmwit: why is Alternative not just the intersection of Applicative and Monoid?
23:09:32 <Nereid> I wonder why I haven't seen some notion of applicative functors in mathematics.
23:09:56 <Nereid> I guess a lot of things people care about are actually monads.
23:10:20 <dolio> They're lax monoidal functors.
23:10:31 <Nereid> I've heard that term.
23:10:41 <dolio> But you need sufficient closed structure to get the applicative interface.
23:10:49 <Nereid> sure.
23:12:59 <dmwit> coppro: Well, for one thing, empty is more polymorphic than mempty.
23:13:33 <dmwit> That is to say, you might wonder about the difference between instance Monoid (f a) and instance Alternative f; then the above sentence is part of the answer.
23:13:46 <dmwit> bleh
23:13:48 <dmwit> terrible explanation
23:14:01 <dmwit> The thing about Monoid is it doesn't force you to write instances for all types.
23:14:16 <dmwit> You might write something like instance Monoid e => Monoid (f e)
23:14:27 <dmwit> whereas Alternative requires you to not do that
23:15:46 <dolio> Alternative f is effectively (forall a. Monoid (f a)), but you can't write the latter, it's illegal.
23:15:47 <coppro> dmwit: ah right
23:16:02 <dolio> Also it's supposed to interact with Applicative f in sensible ways.
23:16:26 <solrize> wut, there's a web framework called "sml on stilts"?  :>O
23:16:50 <Nereid> @type \x y -> (,) <$> x <*> y
23:16:51 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
23:16:53 <copumpkin> is there Dart on Dialysis?
23:16:57 <solrize> lol
23:16:59 <Nereid> oh duh
23:17:21 <geekosaur> http://coboloncogs.org :p
23:17:41 * dmwit feels enlightened
23:17:56 <dmwit> partial functions are the composition of the (e ->) and Maybe functors.
23:18:10 <dmwit> Therefore of course they're Applicative and Alternative.
23:18:35 <copumpkin> Maybe (a -> _) ^_^
23:19:37 <Nereid> @type liftA2 (,)
23:19:38 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
23:20:32 <Nereid> @type let h = liftA2 (,) in \f x -> ($) <$> h f x
23:20:33 <lambdabot>     Couldn't match expected type `a -> b'
23:20:33 <lambdabot>            against inferred type `(a1, b1)'
23:20:33 <lambdabot>       Expected type: f (a -> b)
23:20:40 <Nereid> oops.
23:20:50 <Nereid> @type let h = uncurry $ liftA2 (,) in \f x -> ($) <$> h f x
23:20:50 <lambdabot> forall a b t a1. (Applicative ((->) t)) => (t -> a1, t -> a -> b) -> t -> (a1, a -> b)
23:20:57 <Nereid> oh, what happened there.
23:21:15 <Nereid> no that's not what I want.
23:21:26 <Nereid> @type let h = liftA2 (,) in \f x -> uncurry ($) <$> h f x
23:21:27 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
23:22:05 <Nereid> :>
23:24:12 <hpaste> dmwit pasted “using the semantic instance to guide the implementation of the efficient instance” at http://hpaste.org/71675
23:24:30 <Nereid> @type uncurry id
23:24:30 <lambdabot> forall b c. (b -> c, b) -> c
23:24:42 <dmwit> Oops, forgot Alternative.
23:24:44 <dmwit> dang
23:25:51 <dmwit> Ah, which points out that I got the above bits wrong!
23:25:52 <dmwit> dmwit--
23:40:33 <juhp> can someone recommend a darcs2git tool?
23:44:01 <hpaste> dmwit annotated “using the semantic instance to guide the implementation of the efficient instance” with “semantics blah blah, take 2” at http://hpaste.org/71675#a71676
23:44:09 <dmwit> startling: Something like that.
23:45:11 <dmwit> ooo, and now maybe that Maybe can become an f like the above stuff
23:46:31 <dmwit> Ah, no, we use mapMaybe.
23:47:02 <dmwit> Anyway, something similar should be possible for your Tree type.
23:47:11 <dmwit> Bundle it up with a Maybe c and be on your way.
23:47:34 <startling> dmwit: very nice.
23:51:11 * hackagebot lambdabot 4.2.3.3 - Lambdabot is a development tool and advanced IRC bot (DmitryMalikov)
23:54:59 <augur> ski: i think ive finished it
23:55:19 <augur> http://wellnowwhat.net/Programming/Curry-Howard.pdf << with bib, and fancy links :D
23:56:35 <ski> meep
23:57:24 <ski> augur : i noticed you didn't mention the eta-rules ..
23:57:50 <augur> ski: i added discussion of that in the harmony section
23:58:04 <augur> because eta arises, in part, from local completeness
23:59:50 * ski nods
