00:02:29 <roconnor> (you can say do {x ~= 0; forM [1..0] $ \i -> do x += i } if x is a lens :)
00:02:57 <roconnor> s/[1..0]/[1..10]
00:03:47 <wiz> ´In computer science, imperative programming is a programming paradigm that describes computation in terms of statements that change a program state.ª -- not that far from [one of] monad use cases...
00:05:44 <shachaf> roconnor: Sure.
00:05:46 <shachaf> But wiz's point seemed to be that CLRS was "Haskell-like", with the evidence that "<-" was used in both. :-)
00:05:52 <roconnor> ah
00:05:55 <o-_-o> byorgey: hello
00:06:05 <roconnor> ya, often people use <- to mean ~=
00:06:07 <roconnor> :P
00:10:51 * digitteknohippie settles down to watch the haskell videos for graham hancock's programming in haskell
00:11:48 <wiz> digitteknohippie, url?
00:12:32 <shachaf> Hutton?
00:12:53 <digitteknohippie> lemme see if i can find it in my logs...  downloaded over last night...
00:13:59 <digitteknohippie> http://www.cs.nott.ac.uk/~gmh/book.html#videos
00:15:10 <m3ga> digitteknohippie: thats graham hutton :-)
00:15:20 <xkb> hi
00:15:32 * dmwit waves vaguely
00:15:37 <digitteknohippie> oops, lol, thnx.  fingers are so much more used to writing graham hancock. lol
00:15:48 <xkb> I'm looking for some example code on using OAuth with Scotty. Any tips?
00:15:58 <xkb> Or anything with Authentication headers
00:16:02 <liyang> There was a Hancock at Nottingham.
00:16:28 <m3ga> i've never heard of graham hancock, but graham hutton is rather well known around here
00:17:08 <wiz> xkb, what's your issue with headers? i've made a basic auth for scotty in no time.
00:17:33 <liyang> (They're both Scottish, so I guess there'd be a Graham Hancock out there somewhere.)
00:17:38 <xkb> wiz: getting the headers from the request is somewhat unclear to me at the moment
00:18:20 * hackagebot markdown 0.1.0.1 - Convert Markdown to HTML, with XSS protection (MichaelSnoyman)
00:19:53 <wiz> xkb, check this out https://gist.github.com/3121322
00:20:19 <xkb> wiz: thanks
00:20:30 <xkb> wiz: Is that WAI Request type that you are using?
00:20:47 <wiz> yes. it's provided by scotty as-is
00:21:02 <xkb> Aha.
00:21:16 <xkb> I was looking for a function along the line of param
00:21:28 <xkb> like headers "name" or something related
00:21:57 * wiz were looking for it too
00:22:18 <xkb> anyway, this will get me going. Thanks again
00:24:54 <wiz> xkb, f5 it. i've added a snippet to set an "unathorized" response with executes right after the "unless" line from the previous handler
00:26:36 <wiz> xkb, are you planning to build a provider side of oauth?
00:27:22 <xkb> I build a small app that should be used on mobile devices (basically HTML5 + JS + REST/JSON) and I want to expose it to multiple users
00:27:34 <xkb> so OAuth seems the best approach for this
00:27:52 <xkb> That's why I'm checking out the various existing OAuth implementations
00:28:05 <xkb> most seem client side though
00:28:31 <xkb> I might end up writing the provider side
00:29:47 <wiz> i think i want to do the same thing after my main code is ready...
00:29:57 <xkb> ah cool
00:30:03 <xkb> I really like Scotty thusfar
00:31:36 * wiz jumped to it recently from happstack - app code now is much more cleaner and readable...
00:32:36 <xkb> I have a similar experience
00:32:50 <xkb> especially for REST interfaces it's quite clean
00:33:01 <xkb> had to get used to the monad stacking though :P
00:40:39 <Khorvo> so Text.XML.Light is baffling me
00:40:55 <Khorvo> ParseXMLDoc returns a Maybe Element
00:41:06 <Khorvo> but findElements only takes Element
00:41:18 <Khorvo> how do I get the Element out of the Maybe Element?
00:43:13 <Axman6> pattern match on it
00:43:37 <Khorvo> so like
00:43:55 <fmap> Khorvo: do you know about Maybe monad?
00:43:58 <Khorvo> how do I pattern match it out of a Maybe?
00:44:09 <Khorvo> fmap, probably not as much as I should
00:44:54 <tomboy64> make a function that takes element
00:45:02 <tomboy64> another function that takes nothing
00:45:16 <tomboy64> same name, call them with your result
00:45:41 <frerich> Is there any point in (or name for) a programming style in which each function only actualls calls the functions passed as arguments, instead of relying on global functions?
00:45:50 <tomboy64> and you've got error case and program progress separate
00:45:52 <tomboy64> d
00:46:09 <Khorvo> tomboy64, hmmm... Ok i'll try that
00:47:29 <tomboy64> frerich: i'd say that's the essence of functional programming as opposed to imperative programming?
00:48:45 <Khorvo> tomboy64, its telling me I have multiple declarations of "getVal"
00:48:53 <Khorvo> maybe I misunderstood what you're saying
00:49:17 <Khorvo> so I defined two functions
00:49:20 <Khorvo> one is this:
00:49:26 <Khorvo> getVal :: Nothing -> Nothing
00:49:33 <Khorvo> getVal a = a
00:49:37 <Khorvo> and then
00:49:46 <Khorvo> getVal :: Element -> Element
00:49:52 <Khorvo> getVal a = a
00:50:14 <frerich> tomboy64: Yes, but I mean - explicitely passing even functions like "fst" instead ofusing it directly, so that e.g. "f y = 2 + fst y" becomes "f y fst' = 2 + fst' y". this clearly gets cumbersome of course (and you could argue that (+) or so should be passed as well), but I wonder whether there's a place for explicitely seeing the dependencies of a function in its signature like that.
00:51:50 <shachaf> frerich: Are you allowing foo = \x -> (\y -> x)?
00:52:32 <tomboy64> Khorvo: getVal :: Maybe Element -> Element
00:52:41 <tomboy64> getVal Element = ...
00:52:48 <tomboy64> getVal Nothing = ...
00:53:00 <Khorvo> oh, i see now
00:53:25 <Axman6> tomboy64: that's not right...
00:53:26 <shachaf> Khorvo: The point of (Maybe Element) is that there might not *be* an element.
00:53:28 <frerich> shachaf: I guess you'd have to draw a line somewhere.
00:53:30 <shachaf> So you ahve to think about what to do in that case.
00:54:33 <Khorvo> shachaf, Yeah but I can't pass the Maybe value into the rest of the functions of the Text.XML.Light library
00:54:44 <Axman6> Khorvo: getElem :: Maybe Element -> Element; getElem Nothing = defaultElementValue; getElem (Just e) = e
00:54:48 <shachaf> Khorvo: ...Right. Because there might not *be* an element.
00:55:13 <shachaf> Axman6: I think it's a little hasty to assume that there's a default element value at all. :-)
00:55:27 <shachaf> Maybe the correct response to there not being an element is to die with an error.
00:55:35 <shachaf> The point is that you have to think about it.
00:56:10 <Axman6> Khorvo: Maybe is kind of like NULL in other languages. Nothing is sort of equivalent to NULL, and Just x is sort of the same as a pointer to x instead of a NULL pointer. this isn't a great analogy, but hopefully you can see that they're is not always an element inside a value of type Maybe Element
00:56:20 <Khorvo> shachaf, so it's forcing me to make a pattern-match function that throws an error if it's Nothing?
00:56:41 <Axman6> Khorvo: it's forcing you to handle the case where there may not be an element when you've asked for one
00:56:46 <shachaf> Khorvo: It's not forcing you to do anything.
00:56:56 <shachaf> Except think about what's going on and what should happen.
00:57:03 <shachaf> This is a good habit to get into regardless of language. :-)
00:57:05 <Axman6> Khorvo: if throwing an error is the only reasonable action, then do that, if there's some alternative, you can do that too
00:57:29 <shachaf> You certainly don't need to "make a pattern-match function".
00:57:39 <newsham> haskell: forcing thought since 1990
00:57:56 <shachaf> And "throwing an error" is just begging the question in this case, since the main way to do that is something equivalent to returning a Maybe. :-)
00:58:00 <newsham> (or i guess it was a thunk in 1990)
00:58:02 <Khorvo> shachaf, I don't mean that in a derogatory sense; I'm just saying that the only Input function of the library returns a Maybe and then the parse functions only take a pure Element value. So it's essentially saying "you have to have a middle-man to use the library"
00:58:24 <Khorvo> shachaf, Or rather, a Nothing catcher
00:59:11 <wiz> I have a chain of IO actions in a monad. How do i guard against pure and io conditions and stop execution of a following code?
00:59:17 <shachaf> Well, the issue is that one place gives you one sort of value, and another place takes another sort of value, and your job is to make those places work with each other.
00:59:42 <newsham> > fmap (+1) (Just 5)
00:59:43 <Axman6> Khorvo: i think you need to go and look at how most other askell code deals with things of type Maybe a
00:59:43 <lambdabot>   Just 6
00:59:44 <shachaf> This would be your job even with, say, an implicit "null" -- except that you would find that out rudely, at runtime, or maybe never.
00:59:46 <Axman6> H*
01:00:01 <newsham> > maybe (+1) 0 (Just 8)
01:00:02 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
01:00:03 <lambdabot>    arising from a use of `...
01:00:12 <newsham> > maybe 0 (+1) (Just 8)
01:00:14 <lambdabot>   9
01:02:06 <newsham> y = (x != null) ? f(y) : defval;
02:00:47 <wiz> http://stackoverflow.com/a/2277763/208545 -- ugly hack or legit code?
02:03:21 <amatsu>  /set beep_msg_level MSGS NOTICES INVITES DCC DCCMSGS HILIGHT
02:05:33 <Botje> wiz: no, that's pretty common.
02:05:45 <quicksilver> wiz: case () of () is quite legitimate but I must admit I find it ugly enough that I try to avoid it
02:06:15 <Botje> wiz: you could hide that pattern using cond :: [(Bool,a)] -> a -> a
02:06:29 <wiz> :t cond
02:06:31 <lambdabot> Not in scope: `cond'
02:06:34 <DarkUnicorn> is that simulating just the case with guards?
02:06:36 <Botje> well, you'd have to write it yourself :)
02:06:53 <Botje> but it's basically taking the first (True, x) tuple and returning x
02:07:01 <Botje> or returning the argument 'a' if none of the Bools are true
02:08:46 <mm_freak> Polarina: yes, there is‚Ä¶  firstly the fully polymorphic variant is better for catching errors, secondly it allows you to work with combinators more easily
02:08:58 <mm_freak> Polarina: liftA2 (+) w1 w2
02:09:28 <mm_freak> where w1 takes input and w2 doesn't
02:09:40 <mm_freak> works if w2's input type is polymorphic
02:10:20 <quicksilver> > let (===>) = (,); infixl 0 ===>; cond = snd . head . filter fst in cond [ 5 > 6 ===> "blue", 5 < 6 ===> "green" ]
02:10:22 <lambdabot>   "green"
02:10:51 <quicksilver> ^^ you should probably write a slightly more robust cond which doesn't just give "error: Prelude.head" when nothing matches, but...
02:13:51 <Botje> quicksilver: you could append (True, <default case>) at the end
02:14:54 <Botje> cond cs def = head [ x | (True, x) <- cs ++ [(True, def)] ]
02:15:00 <hpaste> nand` pasted ‚ÄúY combinator with cofunctors‚Äù at http://hpaste.org/71570
02:32:08 <isomorphic> I'm going through the example at http://www.yesodweb.com/blog/2012/01/http-conduit
02:33:08 <evocallaghan> G'day, Fairly new to Haskell however I know Category theory fairly ok. Anyone around that can help me with a typeclass I am trying to do?
02:33:13 <isomorphic> The first example given on the page fails giving me the error No instance for (Control.Monad.Trans.Control.MonadBaseControl IO m0)
02:33:39 <mikeplus64> isomorphic: this isn't very helpful for you but you might want to also ask in #yesod
02:34:00 <isomorphic> Thanks mikeplus64 :)
02:34:10 <evocallaghan> http://hpaste.org/71571 I am trying to write this class Rank hand typeclass that can filter on a given hand (a list of cards)
02:34:58 <evocallaghan> I think I have the right idea, just not use to the type system yet..
02:35:05 <isomorphic> I'm not quite sure what instance I'm supposed to write to get rid of the error :/
02:35:16 <Nereid> evocallaghan: why are you making a typeclass at all?
02:35:36 <isomorphic> any ideas?
02:36:06 <Nereid> as opposed to just writing functions like rank :: Hand -> Kind
02:37:51 <frerich> evocallaghan: I agree with Nereid, I think a plain old function would be just fine here.
02:38:27 * hackagebot distributed-process 0.2.1.1 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
02:38:45 <Nereid> typeclasses are what you use when you have several different types that you want to give some common behaviour.
02:39:04 <evocallaghan> Because I plan to do a lot more than just compare two hands later.. and I will have some common behaviour
02:39:13 <Nereid> with different types?
02:40:04 <evocallaghan> Do you know Texas hold'em ?
02:40:18 <Nereid> not really
02:41:16 <evocallaghan> Ah ok, so basically; you have some hands, each with assending strength based on various conditions, and given two equal hands they have order too based on various conditions.
02:42:04 <evocallaghan> so you have sub constraints when you have equal hands.
02:43:36 <evocallaghan> I wanted to pattern match on these subconstraints with filter and friends however bunch them up into hand rank.
02:45:53 <frerich> evocallaghan: I don't see the connection between type classes and pattern matching on those subconstraints, to be honest.
02:46:50 <frerich> evocallaghan: You can already pattern match on your Kind type, and instead of having the 'Rank' typeclass you could just pass a function 'a -> Kind' to those functions which need it
02:47:35 <frerich> evocallaghan: I think a good rule of thumb is that when you think type classes are the solution to your problem, they aren't. :-) Very often, plain arithmetic data types and functions work just as well (or better).
02:47:51 <Saizan> *algebraic
02:47:56 <frerich> err right
02:48:25 <evocallaghan> Maybe I am thinking more along the lines of a Monad? Since, what I essentially am trying to do is create a ordered list of types (rank) where each type has been endowed with a bunch of conditions to determine it. Its like a theory or algebra glued to each type.
02:48:43 <Nereid> sounds not like a monad at all.
02:48:45 <evocallaghan> frerich: I def could do it with simpler stuff sure.
02:48:54 <Nereid> simple is best
02:50:11 <evocallaghan> Sometimes, however I have something particular in mind. Although I don't think I am explaing it very well or perhaps I am missing things rather silly.
02:50:44 <frerich> evocallaghan: Sorry if I'm being dense, but - you are trying to model a Rank as a type instead of a value, did I get that right?
02:50:56 * frerich should use his dictionary to figure out what 'Rank' means in terms of card games...
02:51:13 <evocallaghan> In simple terms yes
02:52:04 <evocallaghan> Hope this helps frerich http://boardgames.about.com/cs/poker/a/poker_hands.htm
02:52:43 <Saizan> evocallaghan: which other instances of Rank are you thinking of using?
02:52:57 <Saizan> frerich: more like hands as types
02:59:44 <frerich> I may be missing something, but wouldn't an implementation of 'Ord' for 'Hand' be sufficient? You could have a function 'Hand -> Kind' to get the kind of a hand and use that in your 'compare' definition. If the kinds are different, you just use the Ord instance of 'Kind'. If they are equal, you have different definitions (using pattern matching) of compare
02:59:59 <ocharles> hmm, what's edward kmett's irc handle again?
03:00:17 <ocharles> actually, I think I need to ping roconnor, but he's not on either
03:00:18 <ocharles> darn and blast
03:05:52 <Taneb> Hello
03:06:16 <Saizan> frerich: yeah, that'd make quite a bit of sense
03:08:25 <edsko> anyone with any experience weith the libssh2 bindings?
03:11:17 <frerich> evocallaghan: Something like http://hpaste.org/71572 is what I mean
03:11:24 <frerich> Oh, he is gone...
03:12:57 <Nereid> although his ordering for Kind is probably abckwards
03:13:04 <Nereid> sdrawkcab
03:13:08 <Nereid> I can type.
03:13:11 <akamaus> hi, Can I somehow define some functions of class instance in one module and some in another?
03:13:19 <Nereid> no, why?
03:14:27 <Saizan> the instance has to be all in one place, you can define the implementations as plain functions separately though
03:14:58 <Nereid> indeed
03:15:06 <Saizan> e.g. define eqFoo :: Foo -> Foo -> Bool in module A and then do instance Eq Foo where (==) = eqFoo in module B
03:15:22 <Nereid> if you really wanted to have different parts of an instance in different modules,
03:15:36 <Nereid> first you should rethink whether this is really what you need, but
03:15:56 <Nereid> you could split up the typeclass itself
03:15:58 <Nereid> or something
03:20:00 <evocallaghan> Hi, sorry. This connection screwed up. Is there a log?
03:20:16 <shachaf> Yep.
03:20:18 <shachaf> @google haskell irc log
03:20:18 <morphles> Anyone using haskell with tcl/tk?
03:20:19 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
03:20:19 <lambdabot> Title: IRC channel - HaskellWiki
03:21:17 <frerich> evocallaghan: Welcome back - I just pasted some code sketch to illustrate my idea (in fact, I annotated my code sketch a bit so it's a little prettier - see http://hpaste.org/71573 )
03:21:49 <evocallaghan> thanks frerich lambdabot
03:22:28 <demute_> I am playing around with the IO monad and have some problems with the laziness. I read a file with "contents <- getContents handle", then close the file and then to a "return contents" as a last thing. That results in an empty string, but if I print the content before closing the file the return string correct. How do I solve this?
03:24:33 <evocallaghan> frerich: Thanks! Just thinking, I am rather new (days)
03:24:52 <hpc> demute_: first, i think you mean hGetContents?
03:25:10 <hpc> second, you can't do anything to a handle after you hGetContents it
03:25:20 <demute_> hpc: you are right, hGetContents it is
03:25:43 <shachaf> demute_: Lazy I/O in Haskell is sort of a mess.
03:25:53 <hpc> hGetContents leaves the handle "semi-closed"
03:26:07 <demute_> hpc: the only thing I do afterwards is hClose.
03:26:09 <hpc> it will close when you evaluate the entirety of contents
03:26:34 <Saizan> demute_: hGetContents delays the reading to when the contents is actually demanded
03:26:36 <hpc> if you close the handle before consuming all the contents, the handle is closed
03:26:53 <Saizan> demute_: if you hClose the Handle first the reading won't find anything to read
03:27:01 <hpc> it does what Saizan said, so at the time when the contents /really/ get read, it's closed and you get ""
03:28:52 <demute_> aah, now it works, I just removed my "hClose handle"-line. Will it be closed correctly after the file is read?
03:29:05 <evocallaghan> frerich: This looks orginally like what I was thinking. I think the problem is that you end up with huge amounts of deplication of conditions and corner cases.
03:29:19 <edsko> demute_: you should have a look at pipes.
03:29:31 <shachaf> demute_: Yes, when you reach EOF the file will be closed.
03:29:46 <shachaf> But lazy I/O is a mess. :-(
03:30:17 <edsko> demute_: http://hackage.haskell.org/package/pipes-core
03:30:29 <evocallaghan> frerich: Because working out the kind is not such a trivial function
03:31:09 <evocallaghan> That's where my idea of modeling the kind with a typeclass stemed from.
03:32:34 <evocallaghan> Maybe I should just get it done this way (first) since I am so new and rewrite it after? With retrospective advice from here.
03:32:35 <ksf> ahhhh quex has what it calls anti-patterns, negated regexen.
03:33:01 <Saizan> evocallaghan: while computing the Kind you could also return the highest card or whatever is used to differentiate between hands of that card
03:33:42 <Saizan> evocallaghan: so then you just compare those when the kind is the same (which is what the Ord instance for tuples would do, btw)
03:34:05 <Saizan> *between hands of that kind, i meant
03:34:28 <evocallaghan> sure.
03:37:29 * evocallaghan is really starting to confuse himself with too many ideas. :/
03:42:23 <Digit> i think i need to go try some mensa iq tests... the one's split up to determine apptitudes in certain areas...  to check to see if i even have a chance of sussing haskell.  i'll likely find that all my inteligence is built for other things, and for haskell, i'm as good as forrest gump
03:43:00 <Nereid> I think you're more likely to find that it doesn't actually test anything.
03:43:43 <Digit> well, if i did find that, then that'd be contradicting previous experiences.
03:44:35 <Digit> first test i took coroborated that i've a strong aptitude for visual stuff (>180), and... not so much for the wordy stuff... i dont recall how i did for the maths stuff.
03:45:07 <wagle> how do i lift a list into the IO monad:  do print ; a <- [1,2,3] ; process
03:45:16 <Saizan> most people experience the need for brain rewiring when coming to Haskell from imperative langs
03:45:19 <Botje> wagle: use mapM or forM
03:45:30 <Botje> wagle: (or mapM_ / forM_ if you're not interested in the result)
03:45:48 <Dtgr> Saizan: :)
03:46:12 <Digit> yeah, i skipped all the other languages.  from following examples of haskell, it seems to flow more like thought, than the painful contortions and mental gymnastics i experience when i try to follow C.
03:46:20 <wagle> Botje: will ponder that, thanks!
03:47:23 <evocallaghan> btw, I don't know if anyone is interested however I wrote some notes on learning category theory: still a WIP however most of the content of what I wanted is included. https://github.com/victoredwardocallaghan/openware
03:48:44 <Eduard_Munteanu> evocallaghan: there's ##categorytheory in case you don't know it :)
03:49:51 <beefcube> evocallaghan: I would spend money on a dumbed down catagory based haskell manual, I think it's the only way that I figured monads out
03:49:53 <silver_> evocallaghan, thank you, I'll take a look
03:50:49 <Eduard_Munteanu> beefcube: oh, you don't really need to know CT to figure monads out, as far as Haskell's concerned.
03:51:37 <PatrickRobotham> What's the categorical definition of a monad?
03:51:57 <PatrickRobotham> evocallaghan: Thanks for the notes :)
03:52:07 <silver_> kleisli triple?
03:52:23 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition
03:52:23 <hpc> PatrickRobotham: iirc, a monad M is defined as (M, return, join)
03:53:00 <Eduard_Munteanu> Where Œ∑ = return, ¬µ = join
03:54:34 <Saizan> http://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition
03:55:04 <Eduard_Munteanu> ^^
03:55:08 <PatrickRobotham> Cheers :)
03:56:22 <PatrickRobotham> Well I think I see how that works.
03:56:48 <PatrickRobotham> We're talking about Monads on Hask for ordinary monads like IO and List.
03:58:26 <Eduard_Munteanu> PatrickRobotham: yeah, they're endofunctors Hask -> Hask for ordinary Haskell monads.
03:59:27 <PatrickRobotham> Eduard_Munteanu: Well, according to that definition a monad must be an endofunctor equipped with natural transformations.
03:59:28 <timthelion> if I just need to wait for something in another thread, and don't need to pass a value, is there something lower level than the MVar?
03:59:51 <Eduard_Munteanu> PatrickRobotham: those are exactly return and join
04:00:04 <PatrickRobotham> Right.
04:00:33 <Nereid> exercise: write >>= in terms of fmap/return/join
04:00:39 <PatrickRobotham> Presumably the commutative diagrams correspond to the monad laws.
04:00:57 <hpc> timthelion: can't think of anything off the top of my head
04:01:06 <evocallaghan> thanks guys :)
04:01:17 <hpc> depending on what you mean by "wait for something", you could try cooperative multithreading, maaaaaybe
04:01:23 <PatrickRobotham> :t join
04:01:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:01:38 <Eduard_Munteanu> PatrickRobotham: yeah
04:02:23 <Eduard_Munteanu> Also, real monads imply functor.
04:02:45 <Eduard_Munteanu> So it should actually be    class (Functor m) => Monad m where ...
04:03:00 <Peaker> class Applicative m => Monad m where ...
04:03:04 <timthelion> hpc: thanks, I'll google it
04:03:53 <PatrickRobotham> Nereid: I got (>>=) f m = join (fmap f ma)
04:04:12 <Nereid> something like that.
04:04:16 <Nereid> it was an easy exercise.
04:06:57 <Nereid> @type \m f -> join (fmap f m)
04:06:59 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => m a -> (a -> m a1) -> m a1
04:08:23 <wagle> how do i lift a list into the IO monad: process foo = do print foo ; foo' <- [1,2,3] ; process foo'
04:08:26 <wagle> tried
04:08:31 <wagle> this:
04:09:02 <Botje> forM_ [1,2,3] (\foo' -> process foo')
04:09:07 <Botje> or just forM_ [1,2,3] process
04:09:13 * Digit falls over screaming and starts to cry at his complete inability to follow wtf ghci and the exercises from Programming in Haskell are on about
04:09:40 <Peaker> mapM_ process [1..3]
04:09:41 <wagle> ah, forgot the _, and got an infinite type
04:09:45 <Peaker> (in Prelude)
04:09:48 <Botje> Digit: welcome to the gently sloping learning curve of haskell!
04:10:09 <Botje> forM isn't prelude? boo.
04:10:13 <Botje> then mapM_, yeah
04:10:26 <Peaker> wagle, I don't see how mapM_ would work and mapM would be a type error, unless you use the result in a funny way
04:10:28 <evocallaghan> frerich: So its wrong to think like this: "A kind is some ordered types, each goverened by conditions to make them into that type. So, each instance of the typeclass Kind is a function that goes and checks the corresponding conditions to make it that type of Kind."
04:10:31 <Digit> thnx Botje.  i shall persist
04:10:57 <Botje> Digit: if you have specific questions (philosophical or not) we can try to answer them
04:11:18 <wagle> Peaker, but its true
04:11:23 <wagle> 8/
04:11:24 <evocallaghan> Such confusing terms poker O_o <- poker face.
04:11:40 <Digit> well, since #haskell is the nicest place on irc, i shouldnt fear asking my stupid questions...
04:11:49 <Peaker> wagle, can you paste that?
04:12:43 <Digit> ok, so, um... not even sure where to start with my question.  lets say i want to use "sum" in ghci... do i need to define it first?  how do i do that?  it seems using "=" as it's written in the book doesnt make ghci happy...
04:12:45 <hpaste> wagle pasted ‚Äútepl‚Äù at http://hpaste.org/71575
04:12:46 <evocallaghan> Digit: In mathematics it is really important to relax and take your time. Its not your first lang.. Its not that its complex, it just takes time to do..
04:13:34 <Digit> it is my first lang (not counting bash n html), and yeah... patience, and inner calm... must maintain them.
04:13:59 <wagle> Peaker: ^^^
04:14:26 <evocallaghan> Digit: product and coproduct (sum) are basically two structures. You maybe have to define them in Haskell if you are doing something abstract like taking the sum of two tree types perhaps?
04:14:28 <Eduard_Munteanu> Digit: well, bash counts too, actually, depends what you used it for
04:14:36 <Peaker> wagle, no type signature on tepl?
04:14:40 <Peaker> wagle, how is tepl used?
04:14:40 <Eduard_Munteanu> And bash can be quite functional too.
04:14:54 <wagle> in the IO monad, by main
04:15:01 <Eduard_Munteanu> Piping stuff around is akin to function composition.
04:15:04 <Botje> Digit: as it happens, sum is already defined by default
04:15:09 <Peaker> wagle, btw, "map show" there should probably be fused into your lambda
04:15:17 <Botje> Digit: if you want to define stuff in ghci itself, you need to put a let in front
04:15:21 <Digit> still a noob in bash, but i have got up to the point where i can define and call a function without referring to manuals n searches.
04:15:24 <Peaker> wagle, forM_ contains a "map" in it anyway
04:15:29 <Botje> Digit: but the suggested way of working is to put your definitions in a file and loading that
04:15:43 <Botje> so put your sum definition in a file called mysum.hs
04:15:47 * Digit takes his time and reads the error feedback more carefully
04:15:51 <Botje> and then :l mysum.hs in ghci
04:16:00 <wagle> yeah, was just getting it to "work".  but it repeats the same command over and over, apparently
04:16:06 <Botje> if you make changes you can reload the file with :r or :l mysum again
04:16:20 <wagle> but it type checks, so it must really be working
04:16:21 <Peaker> wagle, ah, you recurse into tepl there.. if it's the IO monad, this code is probably wrong
04:16:23 <wagle> 8)
04:16:51 <evocallaghan> Digit: "let" in mathematics is like " 'let' this be true and do the following.." Kind of like temp varibles in the scope of a function in C.. I assume this is exactly the same in Haskell.
04:17:00 <Peaker> wagle, it will recurse into "U" repeatedly, forever
04:17:09 <Peaker> wagle, the infinite type there is because you infinitely recurse
04:18:06 <merijn> So...I find myself facing a paper of category theory and comonads, so it seems I can no longer put off reading up on category theory...Any good intro books/papers?
04:18:20 <wagle> trying to iterate through a list monad while in the IO monad, without REALLY knowing what i;m doing
04:18:59 <Nereid> wagle: what are you trying to accomplish?
04:19:35 <merijn> Digit: You can define temporary functions in ghci using let, but I (personally) find it easier to define them in a file and load the file into ghci
04:19:41 <Botje> wagle: you're just using lists, no list monad in sight.
04:19:51 <merijn> Digit: Oh, I just saw someone already mentioned that, nvm :p
04:20:42 <Digit> thnx anyways merijn.  it helps getting it worded different ways, since my brain is still fighting this.
04:21:02 <hpaste> wagle pasted ‚Äúrepl‚Äù at http://hpaste.org/71576
04:21:48 <wagle> yeah, i havent had a chance to sit and stare at it yet
04:21:56 <Penetrator> I'm the in situation where i really need to debug a function... I need values printed out, from bottom of my recursion stacks (where things are evaluated), up to the top
04:21:56 <Peaker> wagle, you want to try out all options?
04:22:09 <merijn> Penetrator: Debug.Trace?
04:22:20 <Peaker> wagle, your previous code did so but in a DFS, and a DFS on a tree whose branches are all infinite will just explore a single branch
04:22:20 <wagle> those are the four commands I can enter
04:22:27 <Penetrator> merijn: Thanks, I'll try that
04:22:48 <merijn> Penetrator: It's not "safe" for real code, but lets your print strings to stdout whenever an expression is evaluated
04:23:11 <wagle> it backtracks on U, but it doesnt notice
04:23:15 <merijn> :t Debug.Trace.trace
04:23:17 <lambdabot> forall a. String -> a -> a
04:23:44 <quicksilver> Debug.Trace can be pretty confusing if you don't have a good understanding of haskell expression evaluation order
04:24:02 <quicksilver> arguably it can be a good tool for *learning* about expression evaluation order though :)
04:24:11 <Peaker> wagle, The tree of options involving the directions is infinite in all branches, isn't it?
04:24:12 <wagle> someone asked to see it
04:24:47 <wagle> to see why i was getting infinite type without the _
04:24:55 <Penetrator> maybe you guys can help me with a function I cant seem to get correct
04:25:03 <merijn> Digit: Generally you want a file (name ending in ".hs") which starts with "module Main where" (basically saying that everything that follows is part of the new Main module you're creating). Loading it into ghci with :l then lets you run all the code you write in the file
04:25:12 <Penetrator> select :: [a] -> [a]
04:25:31 <HugoDaniel> hi
04:25:36 <Penetrator> select (x:y:ys) = (max x y) :select (y:ys)
04:25:54 <wagle> i'm not terminating correctly the end of a dfs branch
04:26:12 <Penetrator> I cant figure out the base conditions, because when I have a list of 2 values I want to pass them unchanged
04:26:31 <Nereid> Penetrator: what's the function supposed to do?
04:26:32 <Peaker> Penetrator, select other = other  ?
04:26:35 <Digit> re: "*.hs"; well, there's something i at least am familiar with from my use of xmonad (and xmonad.hs).  ^_^ yay.  phew.  i at least know something!   XD
04:26:44 <merijn> Penetrator: That should probably be "select (x:y:[]) = [x,y]; select (x:y:ys) = whatever"?
04:26:45 <Penetrator> scratch that, I dont actually want to do that i just realized :P
04:27:05 <merijn> Penetrator: Also, you probably want "select :: Ord a => [a] -> [a]"?
04:27:29 <Penetrator> merijn: the problem with that is when you recurse through a list of length >3, you wont do the comparison
04:27:32 <Peaker> @type zipWith max `ap` tail
04:27:34 <lambdabot> forall a. (Ord a) => [a] -> [a]
04:27:48 <merijn> Penetrator: What do you mean?
04:27:49 <Peaker> but this will make the list shorter by 1
04:27:49 <Penetrator> peaker... hmm... didnt think of that
04:27:58 <Peaker> > zipWith max `ap` tail $ [1..5]
04:28:00 <Penetrator> yes! i want it short by 1
04:28:00 <lambdabot>   [2,3,4,5]
04:28:05 <merijn> Penetrator: Lists longer than 3 won't match the first clause in my example
04:28:05 <Digit> thnx merijn.  that module Main where tip is helpful.  :)
04:28:12 <wagle> ah yes, I'm not tracking the tree with the call stack (which WAS tail recursive)
04:28:45 <Penetrator> merijn: i'm starting to think I've made some other mistake in my function
04:28:46 <merijn> Digit: That's really easy to gloss over. GHC expects you to give it a module name for your code, even when it's just one file
04:29:19 <quicksilver> merijn: not sure what the point of that is
04:29:20 <Digit> that "Main"... i presume that could be anything (starting with a capital of course)
04:29:22 <merijn> Penetrator: Maybe pastebin the entire thing and descibe A) what you want it to do (in terms of input/output examples) and B) what it is actually doing?
04:29:27 <quicksilver> it's fine to omit 'module Main where'
04:29:33 <merijn> Digit: Yes
04:29:37 <quicksilver> I don't think I've ever bothered to write it
04:29:52 <Digit> i'll try it with and without, see how it :ls
04:30:03 <merijn> quicksilver: It is? I seem to recall it not working otherwise, but I might be completely wrong
04:30:26 <Penetrator> merijn: ok. it's my solution to project Euler problem 18... simple solution but i've got it wrong somehow
04:31:16 <merijn> quicksilver: It seems you're right and I've been cargo culting that line >.>
04:33:05 <Botje> somebody set you up the wooden bomb.
04:33:27 <merijn> I'll save so many keystrokes now!
04:34:16 <wagle> i FEEEXED it!  now it goes down up indefinitely
04:35:15 <Botje> yay!
04:36:04 <hpaste> Penetrator pasted ‚ÄúMax path though triangle‚Äù at http://hpaste.org/71578
04:36:08 <Digit> hrmmm... am i to take it that lines like "nameoffunc x :: Int -> Num" (or whatever) are not actually part of a function definition, and are just there for illustration?  cos when i removed that line, ghci accepted loading my first function.
04:36:59 <Penetrator> merijn: http://hpaste.org/71578
04:37:59 <merijn> Digit: "::" means "has the type", so "nameoffunc :: Int -> Int" means "nameoffunc has the type 'Int -> Int'". The compiler will make sure that it actually *has* that type, if you write the wrong type (or the wrong function, depending how you look at it) it will complain and not accept it
04:38:32 <Botje> Digit: it's good practice to write out the types for functions you define yourself.
04:38:35 <merijn> Digit: Your example has "nameoffunc x ::", which looks like you are giving an argument to the function, that is a syntax error
04:38:38 <srhb> Penetrator: Should you not check for a one-element list in select
04:38:42 <srhb> Arf.. irc dc
04:39:26 <evocallaghan> How do you import everything into the namespace? The Main module is complaining that the bits of Card are not in scope
04:39:42 <Penetrator> srhb:  i'll try that...
04:39:49 <hpc> evocallaghan: how are you importing now?
04:40:06 <srhb> Penetrator: The warnings should tell you that that case has not been covered. :)
04:40:25 <merijn> Digit: If you leave out the type signature the compiler will try detect which type it has. So if you write a "working" function with a wrong type it wil produce an error, removing the signature (as you did) will certainly cause it to compile, but maybe not do what you want
04:40:46 <Penetrator> srhb: yes they do, but i didnt thing that case could occur
04:41:12 <Digit> yeah, excuse those errors in my example.  wasnt like that in my actual file.  did have "dbl :: Num -> Num" as the first line, but ghci expected one more argument.
04:41:15 <srhb> Penetrator: Consider the very first list in your list of lists.
04:41:17 <Penetrator> srhb: the function is not valid for a list of one, it needs >2 elts
04:41:22 <evocallaghan> hpc: http://hpaste.org/71579
04:41:29 <Digit> ... Num can be floating or integer, right?  i seem to recall learning from real world
04:41:39 <srhb> Penetrator: select [x] = [x] ?
04:42:00 <merijn> Digit: Num is not actually a type, it is a typeclass (which might be a bit confusing to explain with your current understanding of haskell?)
04:42:07 <hpc> evocallaghan: yeah, you have to add whatever is missing to the export list in PlayingCards
04:42:22 <hpc> you can't import something that the module chose not to expose
04:42:37 <merijn> Digit: In your case it should probably be "dbl :: Num a => a -> a" which says that dbl has type "a -> a" for all a's which are an instance of the typeclass Num
04:42:53 <Penetrator> srhb: it compiles, but now my function does work properly lol
04:43:10 <srhb> Penetrator: At least, it seems logical to me that the maximum of a list of one element is that one element, not an error.
04:43:19 <Digit> oh right, thnx, i think i get that merijn
04:43:21 <merijn> Digit: If you're reading Real World Haskell right now, you might want to switch to Learn You a Haskell, it has a slightly slower pace at the start, making things easier to follow
04:43:24 <srhb> Penetrator: does work properly? :-)
04:43:33 <evocallaghan> hpc: Is there a better way to write this a bit?
04:44:16 <evocallaghan> Should Value and Suit be "type" not "data" ?
04:44:24 <hpc> evocallaghan: simplest way is to just replace it with "module PlayingCards where ..."
04:44:27 <Digit> my real world haskell has been gathering dust for a few months.  i've got a pdf of Programming in Haskell that i'm starting to work through.  ... have gone through LearnYouAHaskell for a few chapters at least, not that i think it stuck all that well.
04:44:58 <Digit> actually this weekend is the first time i've tuched haskell in about a year.
04:45:06 <Digit> touched*
04:45:09 <Penetrator> srhb: it compiles...
04:45:16 <Penetrator> srhb: something else it wrong somewhere else i think
04:45:17 <merijn> Digit: It's a matter of trying until things click and then it suddenly becomes obvious. If it's been a year it might be worth going over those basics again
04:45:24 <evocallaghan> hpc: Ta! I see now its explicit rather than export everything..
04:45:27 <hpc> Digit: i think you will find LYAH will make the most sense
04:45:28 <srhb> Penetrator: I think so too :-) I think your maxPath is needlessly complicated.
04:45:53 <srhb> Penetrator: (Assuming any number can be chosen from the next line at all times)
04:46:05 <Penetrator> srhb: i works on pen and paper...
04:46:47 <Penetrator> srhb: I just cant seem to get it right in haskell lol... and I think my select function is wrong
04:47:07 <srhb> Penetrator: You're jsut trying to find the one maximal element with select, right?
04:47:08 <Nereid> why don't you test your select function then
04:47:10 <Penetrator> srhb: just doesnt seem possible to do it recursively... I think i need to go imperative
04:47:13 <Penetrator> srhb no
04:47:16 <srhb> Oh.
04:47:34 <Penetrator> srhb: http://projecteuler.net/problem=18
04:47:52 <Digit> ooh, Float can be Integers cant they?
04:47:52 <edsko> does Nick Rudnick frequent this channel?
04:47:59 <Penetrator> Nereid: test... not sure what you mean
04:48:37 <Penetrator> Nereid: although I now know about debug . trace
04:48:43 <evocallaghan> catch you later guys, thanks heaps.
04:49:07 <Digit> sweet.  the haskell love is growing.
04:50:02 <Digit> aw.  pi is there, but no phi or e.  ^_^
04:50:03 <Nereid> Penetrator: you sound unsure about whether select is wrong or not.
04:50:10 <Nereid> so, try applying it to some thing
04:50:11 <Nereid> things
04:50:17 <Botje> Digit: e is just exp 1 :)
04:50:18 <Nereid> and see if what comes out is what you expect
04:50:25 <Penetrator> Nered: yes
04:50:32 <Nereid> "yes"?
04:50:44 <merijn> Digit: phi and e might be defined in some math library
04:50:48 <Nereid> who needs phi
04:50:50 <Penetrator> Nereid:  yes i am ansure if ite wrong, but i have been apply it and it works
04:51:07 <Nereid> Penetrator: so if it seems to work, then look elsewhere for problems
04:51:11 <Penetrator> Nereid:  actually I have changed my code so much that I'm unsure now lol
04:51:14 <Digit> i could do with phi for a music album i'm making.   would be great to geek it up with some haskellism.  ^_^
04:51:19 <Nereid> Penetrator: then testit again
04:51:22 <Digit> anyways, back to the exercises.
04:51:25 <Nereid> Digit: write your own phi.
04:51:26 <srhb> Penetrator: I think your approach is entirely wrong, though. :)
04:51:44 <Penetrator> srhb: it works on pen and paper
04:52:22 <Penetrator> srhb:  just cant express it recursively... perhaps my maxPath function is worng.... *sigh*
04:52:37 <robstewa`> A while ago, someone posted this to hpaste and wondered with the "elso do" notation is not parsed by hlint. Here's the example: http://hpaste.org/63873
04:52:54 <robstewa`> why is "else do" not understood by hlint ?
04:53:16 <Digit> hehe, maybe in a little while once i've cultivated a better understanding of how to write haskell.  i've a reasonable idea in my head how to construct phi, but translating that to haskell... that's at least a couple days away at this pace yet methinks.
04:53:17 <srhb> robstewa`: The problem is with the "then", I think]
04:53:39 <frerich> robstewa: I think both 'then' and 'else' might need a bit of indentation.
04:53:39 <Penetrator> Neried: okay I now know select is worng :P
04:53:50 <robstewa`> oh.
04:53:52 <srhb> Indeed, it's just not valid syntax as it is
04:53:56 <merijn> robstewa`: That doesn't look like the right paste to me...
04:53:56 * robstewa` indents.
04:54:10 <Botje> Digit: are you following a tutorial?
04:54:11 <Nereid> Penetrator: we still don't know what select is supposed to do
04:54:16 <merijn> robstewa`: Oh wait, missed a 3 while copying
04:54:21 <Penetrator> Nereid: aw damn, it's right after all *sigh*, somewhere else
04:54:33 * merijn was extremely confused for a sec there
04:55:04 <Penetrator> Neried: every element, compare with its neighour, and replace with the max of the two. repeast for next element and ITs neighbour
04:55:30 <merijn> robstewa`: btw, I (strongly) prefer to have the do on the same line as the then/else
04:56:04 <merijn> Penetrator: Your function is not comparing with both neighbours, just one of the two
04:56:13 <Digit> Botje: kinda.  i'm on 1.7 Exercises of Programming in Haskell, and just poking around the sides of those first two, with some other search results too.
04:56:26 <merijn> x:y:z:zs y has two neighbours here!
04:56:36 <Penetrator> merijn: perhaps I should have said "next element"
04:56:43 <Nereid> Penetrator: so like
04:56:48 <robstewa`> yep, it was an indentation issue (though it was accepted by ghc). Thanks.
04:56:49 <Nereid> [x,y,z] -> [max x y, max y z]?
04:56:56 <Penetrator> yes!
04:57:29 <Botje> Digit: "learn you a haskell" might also be a good place to sniff around
04:57:34 <Botje> it's a free book
04:57:35 <Nereid> > (\xs -> zipWith max xs (tail xs)) [1,3,5,2,4,3]
04:57:36 <lambdabot>   [3,5,5,4,4]
04:58:28 <Penetrator> Neried: ah yes!
04:58:33 <Digit> Botje: thnx, yeah.  had a look through it a chunk in the past.  might get it open in another window here
04:59:27 <Nereid> > (\xs -> zipWith max xs (tail xs)) [a,b,c,de]
04:59:28 <lambdabot>   Not in scope: `de'
04:59:29 <Nereid> oops.
04:59:31 <Nereid> > (\xs -> zipWith max xs (tail xs)) [a,b,c,d]
04:59:32 <lambdabot>   [max a b,max b c,max c d]
04:59:35 <Nereid> heh
05:00:37 <Nereid> I should remember to make use of those Exprs.
05:01:24 <Penetrator> Neried: thanks for that.  It seems my maxPath function is the wrong one.
05:03:35 * hackagebot protocol-buffers 2.0.11 - Parse Google Protocol Buffer specifications (ChrisKuklewicz)
05:08:37 * hackagebot protocol-buffers-descriptor 2.0.11 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification (ChrisKuklewicz)
05:08:39 * hackagebot hprotoc 2.0.11 - Parse Google Protocol Buffer specifications (ChrisKuklewicz)
05:12:27 <Penetrator> srhb, Nereid, merijn: thanks very much for your advice.  I found the problem... very simple.
05:12:30 <wiz> How to choose which flavor of Control.Monad.Trans.RWST to use? Strict or lazy?
05:14:44 <Cale> It probably doesn't matter, but it depends on what you're doing. Lazy works in some cases where strict doesn't (and perhaps vice versa), but in most cases, the distinction isn't so crucial.
05:14:49 <saep> @hoogle (a -> b) -> (a -> c) -> [a] -> ([b],[c])
05:14:50 <lambdabot> No results found
05:16:14 <Cale> The difference is in how the tuple which carries the results and state of the first action in the definition of >>= is bound. With Lazy, it's bound by let, and with Strict, it's bound by case
05:18:03 <wiz> :t partitionEithers
05:18:04 <lambdabot> forall a b. [Either a b] -> ([a], [b])
05:18:10 <wiz> saep, --^
05:18:49 <nand`> :t \f g -> map f &&& map g
05:18:51 <lambdabot> forall a b b1. (a -> b) -> (a -> b1) -> [a] -> ([b], [b1])
05:18:59 <nand`> I think this is more what saep was looking for
05:19:16 <\rs> anyone knows the alternative O(n) palindrome-detecting algorithm (the other is Manacher's algorithm): http://johanjeuring.blogspot.com/2007/08/finding-palindromes.html
05:19:58 <saep> oh, the arrows
05:20:29 <wiz> nand`, nice
05:21:18 <wiz> :t \f g h -> map f &&& map g && map h
05:21:19 <lambdabot>     Couldn't match expected type `Bool'
05:21:20 <lambdabot>            against inferred type `[a] -> [b]'
05:21:20 <lambdabot>     In the first argument of `(&&)', namely `map g'
05:21:25 <wiz> :t \f g h -> map f &&& map g &&& map h
05:21:27 <lambdabot> forall a b b1 b2. (a -> b) -> (a -> b1) -> (a -> b2) -> [a] -> ([b], ([b1], [b2]))
05:21:32 <Penetrator> is it normal to feel you're not smart enough for haskell?
05:21:37 <nand`> yes
05:21:40 <nand`> it will pass
05:21:40 <wiz> Penetrator, it shall pass
05:21:49 <Penetrator> ah great :P
05:21:58 <Penetrator> i'm on track to mastery then
05:22:44 <wiz> once you decide strongly to stick with haskell, it will take no longer than seven lives to attain the mastery.
05:24:05 <\rs> wiz: your words deserve to be added in next weekly news...
05:24:11 <however> seven lazy lives, that is
05:24:55 <Penetrator> or short lives...
05:25:26 <wiz> :t last
05:25:28 <lambdabot> forall a. [a] -> a
05:25:35 <wiz> > last [1..]
05:25:39 <lambdabot>   mueval-core: Time limit exceeded
05:26:26 <wiz> import qualified Chunk.Norris as CN (last) -- he can take the last item of infinite list in O(1) time
05:26:38 <Digit> ... and what if we liveour lives pure...
05:26:46 <Digit> live our *
05:27:00 <saep> > (head . reverse) [1..]
05:27:05 <lambdabot>   mueval-core: Time limit exceeded
05:27:09 <wiz> saep, you cheater! (8
05:27:29 <nand`> last [1..] = fix succ
05:27:31 <nand`> any questions?
05:27:48 <nand`> (actually, that's not true)
05:28:09 <nand`> > last [1..] :: Word8
05:28:12 <lambdabot>   255
05:28:16 <nand`> what do I win?
05:28:36 * hackagebot network-metrics 0.1.0 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
05:28:49 <wiz> nand`, calculating infinity - achievment unlocked!
05:30:00 <ion> > fix suck
05:30:03 <lambdabot>   ok, fixed
05:30:10 <merijn> > fix error
05:30:11 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:30:18 <nand`> > fix breakage
05:30:19 <lambdabot>   Not in scope: `breakage'
05:30:24 <nand`> ah, that one disappeared :(
05:30:43 <nand`> used to be ("No. " ++)
05:32:17 <Tomsik> > fix id
05:32:21 <lambdabot>   mueval-core: Time limit exceeded
05:32:55 <ion> fix ego
05:33:05 <Tomsik> > fix `my` car where { my = ($) ; car = error }
05:33:07 <lambdabot>   <no location info>: parse error on input `where'
05:33:12 <Tomsik> boo
05:33:36 * hackagebot hscurses 1.4.1.1 - NCurses bindings for Haskell (DinoMorelli)
05:35:20 <wiz> > fix car
05:35:22 <lambdabot>   Not in scope: `car'
05:35:56 <Dtgr> :t fix
05:35:58 <lambdabot> forall a. (a -> a) -> a
05:37:44 <nand`> > last [1..] :: Int
05:37:48 <lambdabot>   mueval-core: Time limit exceeded
05:37:59 <wiz> > last [1..] :: Integer
05:38:03 <lambdabot>   mueval-core: Time limit exceeded
05:38:08 <wiz> h,
05:38:27 <nand`> > length ([1..] :: Int)
05:38:28 <wiz> isn't one of those supposed to be limited by machine word size?
05:38:29 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:38:29 <lambdabot>         against inferred type ...
05:38:33 <nand`> > length ([1..] :: [Int])
05:38:36 * hackagebot network-transport 0.2.0.1 - Network abstraction layer (EdskoDeVries)
05:38:37 <lambdabot>   mueval-core: Time limit exceeded
05:38:42 <nand`> hmm
05:38:44 <Cale> > maxBound :: Int
05:38:46 <lambdabot>   9223372036854775807
05:38:54 <nand`> I wonder if that one's bugged or just takes that long to count that many
05:38:57 * nand` tests it in local GHCi
05:39:00 <Cale> computing that length is still going to take a long time
05:39:01 <wiz> last [1.. maxBound]
05:39:03 <wiz> > last [1.. maxBound]
05:39:05 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:39:05 <lambdabot>    `GHC.Enum.Enum a'
05:39:05 <lambdabot>      a...
05:39:12 <wiz> > last [1.. maxBound] :: Int
05:39:16 <lambdabot>   mueval-core: Time limit exceeded
05:39:23 <quicksilver> nand`: counting up to 2^64 takes a long time, you know
05:40:19 <quicksilver> for example, if you can count 1 item per nanosecond, (or 3 cycles, on a 3Ghz processor) it will take nearly 600 years.
05:40:21 <Cale> wiz: That list might be finite, but it's a decent approximation of an infinite list.
05:40:42 <quicksilver> I'd at least need to get a coffee while waiting, personally
05:42:44 <frerich> I wonder when I'll finally manage to do some "big" Haskell projects as opposed to a few dozen games (just the engines, no GUI, of course...) and replacements for shell scripts.
05:43:38 * hackagebot network-metrics 0.1.1 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
05:44:42 <however> i think replacements for shell scripts are very interesting. it's an important quality of a language, and many don't have it
06:02:21 <wiz> :t RWST
06:02:22 <lambdabot> forall r s (m :: * -> *) a w. (r -> s -> m (a, s, w)) -> RWST r w s m a
06:03:07 <wiz> :t RWST (Int, String) [] Map
06:03:09 <lambdabot> Not in scope: data constructor `Int'
06:03:09 <lambdabot> Not in scope: data constructor `String'
06:03:09 <lambdabot> Not in scope: data constructor `Map'
06:07:43 <wiz> can someone give an example of RWST + IO () type? can't google it out ):
06:08:06 <mroman> RWST?
06:08:25 <bitonic> mroman: reader writer state
06:08:28 <bitonic> transformer.
06:08:38 <bitonic> wiz: what difficulties are you having?
06:09:00 <wiz> middleware :: RWST R.Connection [Int] FM.Request IO ()
06:09:00 <wiz> middleware = return ()
06:09:25 <wiz> Couldn't match expected type `(->) t0' with actual type `IO'
06:10:46 <Saizan> that should work, the error is probably somewhere else
06:11:22 <stevewien> Hello! I am writing a short installation tutorial for a library. During the installation I had to add "shared: True" to the file '~/.cabal/config' and then I had to reinstall every haskell package with force. Is there a method to instlal the haskellplattform with 'shared: True' enabled by default?
06:11:27 <bitonic> wiz: works for me
06:12:47 <stevewien> E.g. Is there a flag when running './configure' or do I simply edit the file '~/.cabal/config' prior to installing the haskell platform?
06:13:25 <however> wiz: i think that means inside that monad, you can read (but not change) an R.Connection, you can write into a list of Ints (but not read from it). this could be logging output, current speed in byte per second or something like that. an FM.Request is the state part, i.e. it's updatable from within the monad. it's stacked onto IO, and it will ultimately yield a ()
06:14:11 <wiz> yup. the type is correct. the problem was in extra [] parameter for execRWST
06:14:35 * wiz thought it gets an initial value for writer part, but it isn't
06:16:34 <wiz> That's the good thing of GHC - it's actually does helpful suggestions in error messages. Unfortunately it's up to programmer to read them carefuly...
06:18:06 <donri> FSVO helpful. "I see that you're trying to do some crazy type-level hackery, maybe you should enable these insane language extensions?" \o/
06:19:41 <Botje> -fwarn-above=200 # unit = milliOlegs
06:20:51 <however> "i see you are attempting crazy ill-advised hackery, and failing profoundly. may i suggest some reading material? (1) my first monad (2) types for dummies (3) learn php in 24 hours"
06:21:42 <Cale> (4) A McDonald's job application form
06:22:07 <jfredett> Cale: buurn.
06:23:06 <Digit> mmmm, haskell-mode in emacs is so nice.
06:23:10 <Cale> There was apparently an early version of GHC with a bug wherein under certain circumstances, a type error in your code could cause GHC to delete the corresponding source file.
06:23:36 <copumpkin> pure code ftw
06:23:57 <mroman> The cake is a lie.
06:24:07 <silver_> ... waffles
06:24:08 <however> "i have put your code on hpaste and asked in #haskell for critique. (1) you are not using enough monads (2) there is a hackage package for that (3) read oleg's paper from 1996"
06:24:20 <silver_> loool
06:25:12 <donri> (4) give up and throw more MVars at it
06:26:23 <spobat> hey
06:28:39 * hackagebot network-metrics 0.1.2 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
06:31:01 <wiz> hmm.. is there a execRWST analog to evaluate not one but many of RWST-types passing original r, merging w and handling resulting s as an input to next one in a series?
06:31:26 <wiz> i think i can construct it myself, but maybe there's one already...
06:32:17 <Botje> wiz: execRWST ... (sequence [one, two, three])
06:33:28 <Botje> uh, wait
06:33:29 <quicksilver> wiz: the short answer is "you don't need anythign special, that's exactly the point of the monad"
06:33:47 <wiz> Botje, wouldn't it be passing the original state and writer to each of elements?
06:33:55 <quicksilver> you simply combine the actions with >>
06:33:56 <quicksilver> wiz: no.
06:34:08 <Botje> wiz: no, it will combine them.
06:34:08 <quicksilver> and sequence is just a bunch of (>>) and collecting the results.
06:34:32 <Botje> wiz: since you're using execRWST it seems you're not interested in the value produced by the RWST ... a
06:34:36 <Botje> so sequence will ignore those.
06:34:44 <Botje> maybe sequence_ is even better, then.
06:35:06 <wiz> yup, the result i want is (s, w)
06:35:31 <Botje> then execRWST ... (sequence_ ...) is the way to go.
06:48:28 <t7> wow c# has type constraints
06:49:11 <t7> go-lang cant even instantiate types (i think that's the correct terminology
06:49:55 <wiz> so, execMany ms r s = execRWST (sequence_ ms) r s -- Just "Works!"
06:50:14 <t7> specify types?
06:51:01 <aristid> @hoogle execRWST
06:51:02 <lambdabot> Control.Monad.Trans.RWS.Lazy execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
06:51:02 <lambdabot> Control.Monad.Trans.RWS.Strict execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
06:51:02 <lambdabot> Control.Monad.RWS.Lazy execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
06:54:36 <Botje> wiz: hooray!
06:55:54 <Digit> ‚â§  ... what the... how does one normally type such a thing?!  (besides copy n paste)  ... it seems to matter.   or so suggests this exersize
06:56:23 <mroman> Xcompose
06:56:35 <quicksilver> wiz: or, execMany ms = execRWST (sequence_ ms) or, even simpler, execMany = execRWST . sequence_
06:56:38 <mroman> quite easy done with compose keys
06:56:46 <Saizan> Digit: that's probably a fancy way to print <=
06:57:07 <Digit> nope, doesnt seem to be.
06:57:23 <Saizan> ?type (<=)
06:57:25 <lambdabot> forall a. (Ord a) => a -> a -> Bool
06:57:29 <however> digit, if you're on linux, you might have a compose sequence for it. on my system it's: compose key, _, <
06:57:32 <wiz> quicksilver, that's my mantra for haskell coding time - "it's all about composition and application".
06:57:44 <Saizan> (‚â§) is not defined in the stdlib
07:00:29 <however> Digit: what it means is of course "less than or equal". in math, you will usually write it as ‚â§. in code, usually <=. but someone made a unicode-symbols package, which defines things like ‚â§ as an other name for <=
07:02:21 <PatrickRobotham> Digit: What exercises are you looking at?
07:03:16 <Digit> oh right.  so, is that the same jist as the one in "dbl :: Num a => a -> a"  or is it specifically different in such cases?
07:03:40 * hackagebot network-transport 0.2.0.2 - Network abstraction layer (EdskoDeVries)
07:03:42 * hackagebot network-transport-tcp 0.2.0.2 - TCP instantation of Network.Transport (EdskoDeVries)
07:03:43 <Digit> PatrickRobotham: 5. of 1.7 in Programming in Haskell
07:03:44 * hackagebot distributed-process 0.2.1.2 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
07:04:25 <wiz> :t guard
07:04:26 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:05:23 <smithw> Hi there, I'm trying to find what would be the best way to implement a generic "interactive prompt" in Haskell. What I have so far is that it needs to maintain a state of the "Context" (a Data.Map.Map String ([String] -> IO Context)), which is a map of command names to functions that take command names and produce an effectful action, returning a new Context to replace the old one. I'm not sure though how I would implement it.
07:06:01 <smithw> The Circuit arrow seems vaguely appropriate, but I'm not sure how I would adapt it to work with Kleisli IO arrows (or even if I should, at all). Any ideas?
07:08:14 <EvanR> ive actually been thinking of a prompt monad for a mud
07:08:33 <EvanR> non IO
07:08:45 * hackagebot distributed-process-simplelocalnet 0.2.0.2 - Simple zero-configuration backend for Cloud Haskell (EdskoDeVries)
07:08:48 * hackagebot network-metrics 0.1.3 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
07:09:27 <smithw> EvanR: non IO as is not allowing the functions to perform side-effects?
07:09:31 <geekosaur> http://hackage.haskell.org/package/MonadPrompt ?
07:10:49 <merijn> EvanR: I was thinking of something similar, thinking of something like a continuation based approach where every action would return a result + handler for the next action
07:11:02 <merijn> In the end I thought the straight-up IO code was simpler/more readable
07:11:43 <smithw> geekosaur: thanks, that may be very well what I'm looking for.
07:13:01 <Cale> smithw: Are you specifically looking to do something fancy, or are you just trying to get the thing done? :)
07:13:06 <wiz> hmm... how is MonadPlus instance for RWST implemented? I've tried to do "guard False" and it crashed with "user error (mzero)".
07:13:34 <smithw> I like this MonadPrompt in that it has the option of performing side-effects within the context functions (via the Lift data structure) if needed (I might need to read some files)
07:13:45 <Cale> smithw: While arrow-based approaches are certainly possible, there's nothing wrong with a simple recursive loop in IO :)
07:14:14 <smithw> Cale: both :p I'm writing a simple text-based game for fun and learning, and I'd like to have a generic implementation of a Haskell prompt for it
07:14:50 <Cale> (especially if most of the work of that loop is farmed out to pure stuff)
07:15:17 <smithw> Cale: most of the work will probably pure, but I might need to read and/or write some files too
07:15:29 <smithw> *be
07:16:00 <EvanR> smithw: no it just doesnt use the IO type
07:16:11 <Cale> e.g. write a pure parser and stuff for working on a pure representation of your game state, and just have the very top-level loop in IO
07:16:34 * EvanR reads
07:16:53 <Cale> which reads user input and does the appropriate parsing. You also have an easy place there to do other I/O-related file operations in the case that the input demands it.
07:17:59 <EvanR> a recursive loop in IO that passes the next parser to the next loop seems simple...
07:18:24 <EvanR> but something like answer <- prompt "the prompt> " seems cool
07:18:33 <smithw> Cale: while that would be the fastest way to implement it, I'm trying also to learn a bit more about advanced features is Haskell, so for that reason alone I tend to favor arrow-based approaches :p
07:18:43 <Cale> All right :)
07:18:45 <smithw> *in Haskell
07:19:55 <smithw> what I can't figure out yet is how I would do the "wiring" of state and IO
07:21:00 * wiz changed sequence_ in execMany to msum - it compiles, but still crashes with "user error (mzero)" 7:
07:21:04 <Cale> You'll pretty much always have some top-level component which says how to capture and provide input to the arrow-based system and display stuff based on its output.
07:21:42 <Cale> In Yampa for example, this is usually done with "reactimate".
07:22:05 <Cale> http://www.haskell.org/haskellwiki/Yampa/reactimate
07:23:40 * hackagebot dvda 0.2.2 - Efficient automatic differentiation (GregHorn)
07:23:47 <smithw> Cale: that looks very complicated, I'll read it carefully to understand
07:24:14 <EvanR> in muds you sometimes have a sequence of questions, the next question depends on a function of the answer to the previous question
07:24:23 <EvanR> seems like a monad
07:24:46 <Cale> smithw: Well, it's basically providing you with a way to fill in the details of how the input to the arrow is obtained (using IO), and what to do with the output of the arrow that you're running.
07:25:13 * wiz noticed that with msum it correctly ejects at "guard False", continuing to next middleware in a list, and throwing that "mzero" error only after execMany(?)...
07:25:21 <EvanR> seems similar to a 'supply' monad where the supply is the answers
07:27:07 <Cale> smithw: and it'll basically be that top-level game loop that I described before, only with the arrow plugged in for all the processing.
07:27:08 <smithw> Cale: I see. It's even more general than what I thought, that could very well be used to capture input from GUIs too.
07:27:34 <Cale> sure
07:28:34 <smithw> EvanR: that's exactly what I was trying to approach with the Context I mentioned; each function would return a "Context" containing allowed commands
07:31:14 <wiz> found the definition: instance MonadPlus IO where \n mzero = ioError (userError "mzero")
07:31:14 <wiz> but how to provide the correct value for this not to crash?
07:34:58 <EvanR> wiz: correct value not to crash? looks like mzero always crashes IO
07:35:22 <wiz> so, msum wouldn't work with IO monads?
07:36:52 <Botje> wiz: RWST just takes the MonadPlus instance of the underlying monad, in this case IO.
07:37:11 <wiz> no chance to use "guard"s?
07:37:49 <imphasing> Does haskell automatically create a show :: MyType -> String function when I make a type constrained by Show? I guess I can just implement my own show :: MyType -> String function if I want to change the behavoir?
07:38:15 <geekosaur> ...what?
07:38:40 <imphasing> how does the show function know how to print my type?
07:38:47 <imphasing> I'm bad at haskell, forgive the confusion :<
07:38:51 <srhb> imphasing: It uses the instance defined in the Show type class
07:38:55 <Botje> wiz: you could stack your own monad transformer in there that has the right MonadPlus instance
07:39:00 <srhb> imphasing: *for the Show type class
07:39:00 <Nereid> so I'm looking at the enumerator package
07:39:04 <imphasing> Ah..
07:39:11 <Nereid> is it just me or does it try to do the same thing as conduits
07:39:32 <srhb> imphasing: If you derive Show for your type, it constructs a default Show instance.
07:40:15 <hdev> i'm trying to resolve a dependency problem and it appears installed version is greater than expected, so it won't just install an old one (i guess). Is there any way to force that? even cabal-dev doesn't seem to start with a clean install
07:40:47 <srhb> imphasing: That's also what the type signature means. show :: Show a => a -> String -- One argument, a, which has an instance of Show...
07:40:49 <imphasing> Ah I see, so it's only to be used as the reverse of read I guess, you're not supposed to be using it for other purposes, it'll always return syntactically valid haskell
07:41:19 <srhb> imphasing: You're not supposed to use it for anything else, no, read and show should be inverse.
07:41:43 <srhb> imphasing: It doesn't have to return syntactically valid Haskell, though.
07:42:01 <srhb> imphasing: (Since Read is just another type class, it could parse whatever you like, but it should still be the inverse of show)
07:42:19 <imphasing> Ah, I see. thanks :)
07:42:43 <adimit> I need to import System.Locale for defaultTimeLocale in order to use Data.Time.Format.formatTime (which requests a TimeLocale object.) However, System.Locale belongs to old-locale, which itself recommends using the library 'locale' instead. But there is no library locale ‚Äî not on hackage, nor on haskell-platform.
07:42:44 <srhb> imphasing: It's not enforced, mind, so you can shoot yourself in the foot and provoke the anger of many users of your library. :-)
07:42:47 <adimit> What do I do?
07:42:55 <adimit> Just use old-locale and (new-)time?
07:43:14 <smithw> I guess I figured out what I was not understanding. I guess I'm looking for an "ArrowTransform" so I could have an Arrow that is both a Circuit *and* a Kleisli arrow.
07:44:40 <srhb> adimit: There's no new locale library, as you suspect. You can indeed do as you propose.
07:45:27 <adimit> srhb: but something should be done about the confusing documentation for old-locale then, no? Or is it just that new-locale just isn't done yet?
07:45:29 <wiz> Botje, can i just catch this "mzero" error and go on with my stuff or it wouldn't return me a nice (s, w) after such recovery?
07:45:59 <srhb> adimit: Yes and no - new locale seems to have been stalled for ages.
07:47:34 <adimit> srhb: :-\ well, that's sad. But thanks for your help anyway.
07:47:47 <srhb> adimit: I still suggest you write the maintainer about the confusing message though :)
07:47:57 <adimit> yeah, that seems like a good idea.
07:49:36 <tgeeky_> anyone know why/where a currently un-installed package would be adding -package Cabal-1.15.0 to the command line "for me?"
07:49:48 <tgeeky_> i only have Cabal-1.14 installed. :/
07:50:08 <merijn> imphasing: You can ask GHC to automatically create a show instance for you by using "deriving (Show)" with your datatype declaration. If you want to do something custom you can just create your own instance of the Show typeclass if you want
07:50:33 <merijn> imphasing: i.e. "instance Show MyType where show x = {- whatever implementation I want -}"
07:51:26 <imphasing> Oh sweet, that's simpler than I thought.. I haven't gotten around to implementing typeclasses in lyah yet :D
07:51:28 <merijn> (With the sidenote that GHC can only derive Show instances for datatypes that only contain showable parameters
07:51:37 <imphasing> Makes sense.
07:52:48 <merijn> imphasing: There's a bunch of others you can automatically derive too (not sure whether this list is exhaustive, probably not) such as Eq (equality), Ord (ordering), Read, Enum (enumerable), Bounded (bounded datatypes)
07:53:07 <tgeeky_> answered my own question: because cabal clean was suffering the same problem (it depended on Caba1-1.15.0), it didn't clean dist/, and that caused everything to fial
07:53:44 <imphasing> I guess when you derive Enum, it combines the enumeration information from the types making up your custom type to figure out how to enumerate your new type?
07:54:15 <merijn> With the obvious caveat that the data type's parameters should allow GHC to derive it
07:54:53 <merijn> imphasing: For datatypes consisting of only constructors (data Colour = Red | Blue | Green) it will just use the constructor order, not entirely sure for more complex cases
07:55:34 <Luke> I'm trying to use HDBC and queries work from the GHCI interpreter but don't from the cabal-based binary I build. Is there anything special I need to put in the cabal file to correctly use HDBC?
07:55:55 <mauke> what do you mean by "don't work"?
07:56:11 <Luke> the ODBC layer is throwing sql exceptions
07:56:15 <Luke> says it can't find the DB
07:56:35 <smithw> Thanks to everyone who helped.
07:56:48 <Luke> "Unable to connect: Adaptive Server is unavailable or does not exist" specifically
07:56:56 <Luke> though the same code from GHCI works just fine
07:58:42 * hackagebot spreadsheet 0.1.3.2 - Read and write spreadsheets from and to CSV files in a lazy way (HenningThielemann)
07:59:15 <Luke> mauke: do you have experience with HDBC?
07:59:25 <Luke> or you were just clarifying?
07:59:53 <mauke> just clarifying
08:00:03 <mauke> especially whether it's a build failure or a runtime error
08:00:24 <Luke> yeah it's a runtime failure which looks like it's coming from the C binary HDBC wraps
08:00:32 <merijn> imphasing: The exact details are in the standard, but in general it works as you expect and when it doesn't the compiler error is usually specific enough to fix it when you try to derive
08:01:10 <hpaste> Luke pasted ‚ÄúHDBC fail‚Äù at http://hpaste.org/71586
08:01:16 <Luke> ^^ There's the full error
08:01:58 <Luke> I want non-haskell coders to be able to use this binary so it's extremely prohibitive to use it only from GHCI
08:12:24 <hpaste> qrt pasted ‚Äúyesod install-contradictions in the house‚Äù at http://hpaste.org/71587
08:12:47 <Qrt> ^^ isnt that a tad contradictory ?
08:13:00 <Qrt> @Cale do you ever sleep?
08:13:01 <lambdabot> Unknown command, try @list
08:13:14 <Cale> Qrt: sure
08:13:25 <Qrt> @faq Can Haskell give you eternal life without sleep?
08:13:25 <lambdabot> The answer is: Yes! Haskell can do that.
08:13:28 <Qrt> wow
08:14:07 <mauke> Qrt: http://www.vex.net/~trebla/haskell/sicp.xhtml
08:14:08 <Cale> Qrt: I slept most of yesterday, and woke up around midnight EDT.
08:31:16 <Qrt> so i got happstack working and want to make my tictactoe a webapp. any suggestions on how to do the board in html?
08:34:35 <Cale> Qrt: Is that an HTML question, or a question about how to generate HTML from Haskell?
08:34:50 <jacobian> "Main: Internal Happy error"
08:34:55 <jacobian> yarg!  what an annoying error
08:35:03 <quicksilver> personally I'm glad it's happy about it though
08:35:15 <Cale> heh
08:35:23 <jacobian> it might be happy, I am not
08:35:31 <Cale> I wonder what can cause Happy to fail like that.
08:37:51 <mauke> http://images.codingforcharity.org/dmp/20101126/Happy-Cat_20101126043601_reg.png
08:38:43 * hackagebot bindings-bfd 1.2.0.0 - Bindings for libbfd, a library of the GNU `binutils' (MichaelNelson)
08:38:49 <jacobian> thanks mauke :)
08:39:53 <hpaste> t7 pasted ‚Äúsilly thing‚Äù at http://hpaste.org/71588
08:41:55 <t7> actually i should restrict sum types to Nil or A
08:48:09 <osa1> I was testing my app with runhaskell and everything was fine but after creating cabal package, cabal build gives me errors like "use EmptyDataDecls, use DoAndIfThenElse" etc. any ideas why?
08:53:11 <illissius> @hoogle (a -> b -> c) -> (d -> b -> e) -> ((a, d) -> b -> (c, e))
08:53:12 <lambdabot> No results found
08:54:27 <illissius> @pl \f g (a, b) c -> (f a c, g b c)
08:54:28 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . liftM2 (,)) .)
08:54:31 <illissius> okay.
08:54:34 <however> illissius: maybe flip together with (***) or something ...
08:55:21 <jfredett> @type (***)
08:55:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:55:25 <illissius> however: yeah (***) was what sprang to my mind too but it's not an immediate fit
08:55:39 <illissius> maybe I just have to stare at it some more
08:56:07 <illissius> hmm
08:56:39 <illissius> think I'll need &&& too
08:56:41 <however> osa1: maybe you have started runhaskell with options like -XEmptyDataDecls? you can put those in the source code, at the top of the file, as {-# LANGUAGE EmptyDataDecls #-}
08:57:31 <however> > (succ *** pred) (42,17) -- jfredett
08:57:33 <lambdabot>   (43,16)
08:57:59 <donri> osa1: maybe add to cabal, default-language: Haskell2010
08:58:12 <donri> under library/executable
08:58:40 <osa1> donri: let me try
08:59:51 <osa1> donri: that worked. thanks.
08:59:55 <Qrt> when you do advanced html how do you actually layout your site? like you dotn sit and handcode html by hand i assume
08:59:57 <osa1> donri: is it latest haskell standard?
08:59:58 <donri> \o/
09:00:01 <donri> osa1: yes
09:00:05 <Qrt> use some program that generates html?
09:00:32 <donri> Qrt: i use hsx
09:00:49 <donri> it's really powerful and can cause severe headaches before you understand how it works
09:01:13 <donri> other good options are blaze-html, hamlet, heist
09:01:20 <osa1> are there any compiler optimization parameters I should use like gcc's -O3 ?
09:01:40 <donri> osa1: there's up to -O2
09:01:51 <donri> osa1: http://www.haskell.org/ghc/docs/latest/html/users_guide/faster.html
09:01:59 <osa1> thanks
09:02:27 <Qrt> ah blaze is included in happstack so imguess i use that
09:02:53 <donri> Qrt: yes, although hsx is the best supported in happstack once you start to do interesting things
09:03:31 <donri> like web-routes, jmacro, i18n
09:08:47 * hackagebot authenticate-oauth 1.4.0.1 - Library to authenticate with OAuth for Haskell web applications. (HiromiIshii)
09:14:04 <dmwit> Is there a way to ask ghci if an equality is provable from the current assumptions?
09:14:18 <dmwit> I tried "let x :: a ~ b => Int; x = 3" and it succeeded. =/
09:16:13 <geekosaur> shouldn't it have warned that the type vars weren't used?
09:16:23 <geekosaur> (possibly even thrown an error)
09:16:24 <flux> hmm, I don't think ghc can prove anything about values?
09:16:38 <dmwit> It didn't warn.
09:16:44 <dmwit> I'm not asking GHC to prove anything about values.
09:18:48 * hackagebot egison 2.2.2 - An Interpreter for the Programming Language Egison (SatoshiEgi)
09:18:52 <dmwit> Oh, I understand why it succeeded.
09:18:54 <dmwit> hm
09:18:59 <however> > 42 :: (a~b => Int)
09:19:00 <lambdabot>   42
09:19:04 <however> > 42 :: (Eq a => Int)
09:19:06 <lambdabot>   Ambiguous constraint `GHC.Classes.Eq a'
09:19:06 <lambdabot>      At least one of the forall'd t...
09:19:35 <however> continues: "... forall'd type variables must be reachable from the type after =>"
09:19:51 <dmwit> > 42 :: (forall a b. a ~ b => Int)
09:19:52 <lambdabot>   42
09:19:56 <dmwit> lies
09:20:10 <dmwit> > 42 :: (forall a b. Int)
09:20:11 <lambdabot>   42
09:20:17 <dmwit> damned lies
09:20:23 <dmwit> (but not statistics =)
09:20:53 <nand`> but it says ‚Äúambiguous constraint‚Äù, not ‚Äúambiguous quantification‚Äù :P
09:21:32 <dmwit> a ~ b is a constraint.
09:23:46 <however> i guess it's a compiler error bug. it'd mean that a simple typo in a constraint could cause hours of pulling your hair out
09:30:25 <steve20> a quick question: I just run "ghc-pkg check" and it lists a lot of packages that are borken. Is there a way to unregister all the listed packages?
09:33:11 <nand`> ghc-pkg unregister $(ghc-pkg check)  # I have no idea if this will actually work
09:34:18 <however> steve20: you might try something like "ghc-pkg check|xargs echo ghc-pkg unregister". if you like the command line you see, remove the "echo" and re-run
09:34:33 <however> (i have no clue if this will actually work)
09:37:54 <owst> however: I've not seen that trick with echo before, nice!
09:38:17 <however> owst, you're welcome :)
09:38:44 <mcstar> what does it do?
09:38:56 <owst> prints out the command that would be executed
09:39:09 <mcstar> and still executes it?
09:39:11 <owst> nope
09:39:13 <mcstar> ah
09:39:17 <mcstar> then i understand
09:40:36 <nand`> What would be a good GUI framework I could look at to create something like the following: a window displaying an image and a slider above it that will transform the image in certain ways (as per some function I write :: Float -> Image -> Image  that takes the slider position from 0-1 and the initial image and transforms it) ?
09:40:41 <steve20> however: thank you for the tip. unfortunately it did not work on my system (I think the pipe dosn't work). I just copied now the list in emacs and wrote a keyboard markro that adds the cabal command to each line.
09:40:47 <nand`> I really have no idea how the whole GUI stuff works, since I usually stick to terminals
09:40:58 <dmwit> nand`: tangible values
09:41:36 <dmwit> wait
09:42:58 <dmwit> nand`: http://conal.net/papers/Eros/
09:43:03 <nand`> (if anybody's interested, I'm going to be exploring color blindness simulations, and I want to vary these parameters)
09:43:26 <dmwit> The example GUIs he designs are like... basically exactly what you just described.
09:43:32 <nand`> yes, they look very similar
09:43:38 <geekosaur> I suspect it writes errors to stderr instead of stdout like most programs
09:43:47 <geekosaur> ... 2>&1 | ...
09:43:59 <geekosaur> (but there's likely extra stuff in there too)
09:45:20 <nand`> dmwit: is there a practical implementation somewhere that I can just install and plug my functions into?
09:46:38 <dmwit> nand`: The wiki page (seems to) discuss installation.
09:46:44 <nand`> hmm
09:46:49 <dmwit> No idea whether the discussion has bitrotted or not. =)
09:46:58 <nand`> the distribution link on there is a 404 and it mentions an .exe, I hope this isn't windows-only
09:47:01 <nand`> or something
09:47:05 <dmwit> oh, bummer
09:47:31 <dmwit> ?get-conal
09:47:31 <lambdabot> Unknown command, try @list
09:47:34 <dmwit> conal!!!
09:47:35 <nand`> the description sounds basically exactly like what I want, mind
09:47:36 <dmwit> =)
09:47:38 <conal> dmwit: hi
09:47:41 <nand`> conal: eros
09:47:54 <nand`> is it maintained / can I install it like right here right now and it will work?
09:47:55 <dmwit> oh man, it worked
09:48:15 <nand`> (also where do I get it?)
09:48:51 <nand`> http://www.haskell.org/haskellwiki/TV sounds neat too, incidentally
09:48:54 <conal> i've been circling back around to eros via functional-to-gpu compilation. got stuck for a long time on broken low-level underlying GUI libs.
09:49:08 <conal> nand`: Eros is built on TV
09:49:12 <nand`> I saw
09:49:31 <nand`> but I was meaning in a sense of ‚ÄúI may not need the full-fledged Eros suite for this particular use case I have in mind‚Äù
09:49:42 <Qrt> hmm happstack seems pretty good
09:49:54 <conal> nand`: agreed. something like GuiTV would be enough.
09:50:13 <nand`> plus I can actually find it on hackage
09:50:43 <Qrt> so i got happstack working and want to make my tictactoe a webapp. any suggestions on how to do the board in html? like how would i draw lines or soemthing to make a board?
09:52:35 <Botje> Qrt: a table is the easiest ;)
09:52:35 <dmwit> <table>
09:52:54 <nand`> heh, 6 packages so far have not been available in my repository and as such are not maintained, let's hope this works
09:53:31 <nand`> oh wow, it needs reactive <0.6
09:54:25 <conal> nand`: yeah. GuiTV is broken now. i think it's fixable now that wxhaskell is in better shape (very recent development)
09:54:34 <nand`> I see
09:54:40 <nand`> what about non-GuiTV?
09:54:43 <conal> nand`: and without reactive. i have a simpler scheme now.
09:54:44 <nand`> non-Gui TV*
09:55:17 <nand`> if you do ever get round to fixing it up be sure to tell me
09:55:19 <conal> nand`: non-gui TV works fine last i checked.
09:55:27 <conal> nand`: k
09:55:42 <nand`> tv builds fine for me
09:56:26 <conal> nand`: when i have a new gui version of TV, i'll post something on haskell-cafe.
09:57:58 <nand`> and http://hackage.haskell.org/package/GtkTV ?
09:58:59 <conal> nand`: it might work for you already. i've never been able to get gtk2hs working with native widgets & look&feel on the mac.
09:59:24 <nand`> GtkTV builds fine
09:59:33 <conal> with OpenGL, which i need.
10:00:19 <nand`> oh my
10:00:22 <nand`> it works perfectly
10:00:23 <conal> this sort of library breakage is why i gave up on functional guis & graphics until conditions improve.
10:00:27 <conal> nand`: cool. :)
10:00:44 <nand`> can GtkTV support working with some form of (easily accessible) image format?
10:00:53 <nand`> since I'm trying to model image transformations here :P
10:01:13 <Qrt> how do i do if i have "1" inside a string?
10:01:28 <nand`> using ‚Äòdo‚Äô
10:02:02 <Qrt> "blah="1""
10:02:12 <Qrt> > "blah="1""
10:02:14 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
10:02:14 <lambdabot>         against inferred type ...
10:02:48 <MagneticDuck> I have an "indentation error"
10:02:52 <hpaste> MagneticDuck pasted ‚Äúindentation error in case statement‚Äù at http://hpaste.org/71592
10:02:58 <mauke> > "blah=\"1\""
10:02:58 <nand`> > "blah=\"1\""
10:02:59 <lambdabot>   "blah=\"1\""
10:02:59 <lambdabot>   can't find file: L.hs
10:03:01 <MagneticDuck> what's doing on?
10:03:22 <MagneticDuck> ...?
10:03:26 <nand`> now to figure out which one of our evaluations made it through
10:03:33 <mauke> MagneticDuck: line 9 is not indented enough
10:03:50 <MagneticDuck> oh wait..
10:03:50 <MagneticDuck> lol
10:03:58 <MagneticDuck> in the editor (vim) it was indented perfectly
10:04:07 <mauke> MagneticDuck: then you've got mixed spaces and tabs
10:04:10 <mauke> bad idea
10:04:11 <MagneticDuck> ah
10:04:14 <MagneticDuck> okay
10:04:26 <MagneticDuck> what's the command for making tabs into spaces...
10:04:28 <MagneticDuck> expandtabs?
10:04:29 <mauke> for haskell I recommend something like: :set et sts=4 sw=4
10:04:37 <MagneticDuck> okay
10:04:41 <MagneticDuck> that's what I have
10:04:44 <mauke> and then :retab! if you already have borken code
10:04:48 <MagneticDuck> I guess I just didn't retab
10:04:49 <MagneticDuck> okay
10:04:52 <MagneticDuck> ty
10:08:00 <finnaly>  When I type in sort [42,13,22] in GHCi i get this error :
10:08:02 <finnaly> <interactive>:4:1:     Not in scope: `sort'     Perhaps you meant `sqrt' (imported from Prelude)
10:08:55 <mauke> import Data.List
10:09:01 <finnaly> Thanks
10:11:18 <MagneticDuck> if I have a IO [String] and I want to get [IO String], I use sequence right?
10:11:22 <MagneticDuck> @type sequence
10:11:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:11:29 <MagneticDuck> erm
10:11:37 <MagneticDuck> I need the inverse of sequence
10:11:41 <mauke> impossible
10:11:43 <MagneticDuck> @src sequence
10:11:43 <lambdabot> sequence []     = return []
10:11:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:11:43 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
10:11:51 <MagneticDuck> ..
10:12:08 <MagneticDuck> really?
10:12:13 <mauke> MagneticDuck: imagine I have an action that randomly returns 0, 1, or 2 strings
10:12:20 <mauke> it can do that randomly because it's in IO
10:12:29 <MagneticDuck> ah okay
10:12:33 <MagneticDuck> yeah
10:12:39 <mauke> if we had your inverseSequence, we could get a pure list
10:13:04 <mauke> but we would have to look into the future to determine how many elements that list would have
10:13:11 <MagneticDuck> alright
10:13:17 <nand`> MagneticDuck: I think IO [String] -> [IO String] could be used to break the type system.  ...somehow
10:13:37 <Nereid> @type (>>= sequence)
10:13:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [m a] -> m [a]
10:13:43 <Nereid> oops.
10:13:46 <nand`> actually wait nvm I think that's only an issue for polymorphic *performIO
10:14:02 <MagneticDuck> yeah
10:14:07 <MagneticDuck> well it's impossible
10:14:11 <MagneticDuck> alright got it
10:14:13 <finnaly> If you use a value more then once is it called currying, if I remember correctly.:)
10:14:22 <imphasing> Does it make sense to think of polymomrphic constants as zero-argument functions, but since functions are referentially transparent, it always returns the same value, and is therefore constant?
10:14:23 <MagneticDuck> hm?
10:14:27 <imphasing> Or should I not think of them as functions?
10:14:38 <Qrt> anyone used table in Blaze?
10:14:45 <Tomsik> Functions are values too
10:14:49 <Nereid> imphasing: sure, but that has nothing to do with polymorphism
10:14:50 <mauke> imphasing: you probably shouldn't think of them as functions
10:14:52 <MagneticDuck> yeah
10:15:00 <MagneticDuck> functions are just values with a degree of flexibility
10:15:06 <MagneticDuck> ..kind of..
10:15:36 <Tomsik> A value is something that is already computed for some definition of "already computed"
10:15:50 <Tomsik> In Haskell it means weak head normal form  I think
10:16:27 <byorgey> people actually use the word 'value' to mean several different things.
10:17:03 <Qrt> u can be a value
10:17:46 <nand`> imphasing: I think a few theoretical models consider values of type ‚Äòa‚Äô to be functions of type ‚Äò() -> a¬±
10:17:53 <nand`> s/¬±/‚Äô/
10:18:44 <nand`> hmm
10:18:53 <nand`> one possible interpretation of value: something that can be pattern matched on
10:19:01 <nand`> since you can't pattern match on abstractions
10:19:44 <herpladee> hey guys i am having problems with happstack. under ghc 6.12.1 i cannot install web-routes-boomerang (which i want for my happstack) but it installs fine under 7.4.1 ... but under 7.4.1 i cannot install happstack but that works fine under 6.12.1
10:19:48 <Tomsik> I'm not sure that a is isomorphic to () -> a in Haskell. () -> undefined and undefined are both of type () -> a, but a has only one undefined
10:19:50 <Nereid> nand`: so functions aren't values?
10:19:55 <imphasing> interesting.. I'm reading the typeclass portion of lyah and I see numbers are of type (Num a) => a, so they take the type of any Num, and the signature looks a lot like a function so it was kind of confusing
10:19:57 <nand`> Nereid: by this definition, no
10:19:57 <herpladee> please advice
10:19:58 <Nereid> or
10:20:06 <Nereid> well that's a pretty terrible definition then
10:20:12 <nand`> Nereid: then again, that sort of falls against the idea of first class functions
10:20:27 <Tomsik> Uh, generally "functional programming" says that functions are "first class" and can be values
10:20:34 <nand`> but it's a good way to distinguish ‚Äúhard values‚Äù from ‚Äúfunction values‚Äù, if you know what I mean
10:20:35 <jfischoff> herpladee: what is the error with happstack?
10:21:54 <byorgey> imphasing: well, something of type  (Num a) => a  can be thought of as a function which takes a dictionary (record) of Num operations for a certain type as input, and produces a number as output.
10:21:58 <Tomsik> nand`, you mean datatypes, that's what you can pattern-match on
10:22:05 <Qrt>  table $ span $ text "foo" // where does text come from? what module?
10:22:10 <byorgey> imphasing: but that's unrelated to whether constants are considered as "0-argument functions" or not.
10:22:26 <scooty-puff> my memory may be off here, but i thought ghc did some sort of optimization on functions that return sum types, where if they are immediately pattern-matched, instead of return the sum type, the function will take functions for each match, or something similar - does this sound familiar to anyone?
10:22:28 <byorgey> (for the record, in my opinion thinking of constants as "0-argument functions" is not very useful in Haskell.)
10:23:02 <byorgey> Qrt: you'll have to give more context.  There are quite a few packages that define a function called 'text'.
10:23:09 <imphasing> Okay, thanks for the help :)
10:23:15 <scooty-puff> (i am considering writing a function that accepts functions for what really is a particular case, and think it may be easier to work with if a sum type representing each possible result is instead returned)
10:23:38 <mcstar> i think it is, a function is a value, a partially applied function is a value too, when you fully apply a function, it again becomes a value, so...
10:23:52 * hackagebot errors 1.2.1 - Simplified error-handling (GabrielGonzalez)
10:23:55 <Qrt> http://hackage.haskell.org/packages/archive/blaze-html/0.5.0.0/doc/html/Text-Blaze-Html4-Strict.html
10:24:07 <mcstar> so basically, there are no functions, hm, the opposite i wanted to prove
10:24:12 <Qrt> ^^ table $ span $ text "foo"
10:24:30 <Nereid> everything is a value
10:24:49 <imphasing> So I probably shouldn't be trying to think of everything as a function ;D
10:24:56 <imphasing> Makes more sense.
10:24:58 <Nereid> only the functions are functions
10:25:08 <mcstar> no, they are values!
10:25:13 <Nereid> they are also values
10:25:30 <aristid> imphasing: it also isn't hard to recognize functions. just look out for the -> in the type ;)
10:26:00 <nand`> aristid: that doesn't cover newtyped-wrapped or polymorphic types
10:26:20 <nand`> (or type aliased)
10:26:35 <Nereid> newtyped things aren't functions, I'd say.
10:26:48 <Tomsik> Yeah, type synonyms are problematic though
10:27:01 <nand`> is :: Arrow a => a i i -- a function?
10:27:05 <Nereid> type synonyms are not problematic at all.
10:27:14 <Tomsik> nand`, not always
10:27:21 <Tomsik> there are arrows that are not functions
10:27:29 <nand`> Tomsik: but sometimes it is
10:27:36 <aristid> nand`: newtype wrapped isn't a function any longer to me :)
10:27:36 <nand`> yet there's no -> in the signature, is what I'm saying
10:27:45 <mcstar> there are CAFs and non-CAFs, thats it, but all are values
10:27:55 <nand`> CAF?
10:28:10 <donri> Qrt: looks like outdated docs, you want "toHtml" from Text.Blaze.Html
10:28:11 <mcstar> complex applied flux
10:28:14 <mcstar> oh no
10:28:14 <aristid> nand`: and sure, if you have a polymorphic a, it can also be a function.
10:28:21 <mcstar> constant applicative form
10:28:22 <Nereid> nand`: I'd say it's not a function
10:29:07 <nand`> so say f is my Arrow a => a i i; I can apply this function to things just fine: (f 3, f 'a')
10:29:19 <donri> Qrt: if you enable OverloadedStrings you can just write "foo" in that case, although that extension can cause some confusion
10:29:24 <Nereid> nand`: depends on what f is
10:29:27 <nand`> or ‚Äúquasifunction‚Äù or whatever
10:29:41 <Nereid> oh, that f.
10:29:43 <imphasing> nand`: where does the type parameter i come from in that? :/
10:29:44 <Nereid> you should say what f is.
10:29:48 <frerich_> Is there some conventional name for 'flip (.)'? I just noticed that this function (I call it "then") makes some things look nice because you can read from left to right.
10:29:53 <Tomsik> nand`, arrows are arrows. That's it. :)
10:29:56 <nand`> imphasing: f :: forall a i. Arrow a => a i i
10:29:59 <Qrt> @type flip
10:30:00 <donri> Qrt: also you should join #happs for questions relevant to happstack, this channel is a bit noisy :)
10:30:01 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:30:17 <donri> :t Prelude.flip
10:30:19 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
10:30:42 <nand`> Tomsik: point is, it's not limited to arrows - in theory any sufficiently polymorphic type could match functions, it would just place the appropriate constraint on them. so it's not suitable to just ‚Äúlook for ->‚Äù in the type of something to figure out if something is a ‚Äôfunction‚Äô or not
10:30:42 <Qrt> instead of text i want toHtml?
10:31:01 <mcstar> aham, so a function, which is a lambda abstraction, is a non-CAF, while a partially applied function is
10:31:06 <donri> frerich_: Control.Category.>>>, i've also seen (&) used
10:31:11 <mcstar> http://www.haskell.org/haskellwiki/Constant_applicative_form
10:31:11 <Nereid> nand`: I'd say it is.
10:31:11 <nand`> Nereid: I did. ‚Äúso say f is my Arrow a => a i i‚Äù
10:31:15 <Nereid> and go ahead and say that f is not a function.
10:31:22 <donri> Qrt: yea
10:31:32 <Tomsik> nand`, why would you care if it's a function, anyway?
10:31:38 <Nereid> if I wrote f' :: a -> a; f' = f, then I'd say f' is a function.
10:31:48 <nand`> Tomsik: I wouldn't, that's my point
10:31:49 <Nereid> because it's a member of a function type.
10:32:00 <Tomsik> :t (>$>)
10:32:02 <lambdabot> Not in scope: `>$>'
10:32:08 <frerich_> donri: Excellent, thanks for the pointers!
10:32:29 <nand`> just because application is a primitive doesn't mean functions are magical, the primitive just enforces a type like anything other :P
10:32:38 <Tomsik> frerich_ Just remember that there's a (.) in Control.Category
10:32:56 <Tomsik> so either you hide it/version from prelude or import qualified
10:33:53 <nand`> mcstar: what about functions that are not lambda abstractions? :P
10:34:34 <mcstar> .....erh...um...does not compute....~~~~smoke
10:34:47 <nand`> :t let f = f; f :: Int -> Int in f
10:34:49 <lambdabot> Int -> Int
10:35:20 <Nereid> that's a function too.
10:35:26 <Nereid> although nobody cares.
10:37:33 * frerich_ calls this function "normalize" and thinks this is admitting defeat.
10:38:07 <mhitza> is there a place where I can download a snapshot of all the hackage packages?
10:40:01 <mcstar> also, it was nice to be here, and witness the downfall of functional programming
10:40:14 <aristid> mhitza: you could use the index in your ~/.cabal/packages/hackage.haskell.org/00-index.tar and use cabal fetch
10:40:33 <mcstar> even praticioners of the act, cant agree on what a function is and what isnt
10:40:51 <mhitza> aristid, thanks for the tip
10:41:29 <scopedTV> mcstar: a function is a value that has a type of the form a -> b
10:41:38 <nand`> mcstar: I've noticed similar difficulties in defining what exactly ‚Äúfunctional programming‚Äù is
10:41:41 <scopedTV> mcstar: are there people that disagree with this definition?
10:41:54 <mcstar> scopedTV: ^^^^^^^^^
10:42:04 <t7> id has the type a -> a
10:42:24 <scopedTV> yeah a -> b, a and b are "meta-variables"
10:42:25 <nand`> id is a function
10:42:36 <scopedTV> i don't mean forall a b. a -> b
10:42:45 <nand`> scopedTV: I think I can agree with that. Though I'd focus less on the ‚Äútype‚Äù and more on the property: a function is something that can be applied
10:42:49 * mcstar goes, and learns OO design patterns
10:43:07 <avpx> No don't!
10:43:09 <scopedTV> mcstar: make sure to learn Strategy especially well ;)
10:43:18 <mcstar> No, i wont! XD
10:43:21 <Tomsik> Too much philosophy, not enough denotational semantics
10:43:32 <nand`> ‚Äòf‚Äô is a function if ‚Äòf undefined‚Äô type checks
10:43:45 <nand`> maybe this works
10:43:56 <mcstar> > 1 undefined
10:43:57 <lambdabot>   1
10:44:01 <nand`> 1 is a function, mind
10:44:04 <scopedTV> mcstar: yeah this is caleskell.
10:44:07 <mcstar> :)
10:44:16 <Tomsik> :t 1 1
10:44:18 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
10:44:21 <Tomsik> Maaagic
10:44:21 <mcstar> nand`: i know, lame counterexample
10:44:24 <scopedTV> mcstar: integer literals are overloaded
10:44:28 <nand`> :t 'a' undefined
10:44:30 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `Char'
10:44:30 <lambdabot>     In the expression: 'a' undefined
10:44:33 <Tomsik> It's because of Num
10:44:35 <scopedTV> :t () undefined
10:44:36 <lambdabot>     Couldn't match expected type `a -> t' against inferred type `()'
10:44:36 <lambdabot>     In the expression: () undefined
10:44:40 <Tomsik> and implicity fromIntegers
10:44:42 <mcstar> haha
10:44:46 <mcstar> full circle
10:44:52 <mcstar> so now, we dont have non-functions
10:44:53 <Tomsik> 1 means fromInteger 1
10:45:01 <nand`> :t 1 undefined -- mind
10:45:03 <lambdabot> forall t a. (Num (a -> t)) => t
10:45:03 <scopedTV> mcstar: () is a value which is not a function
10:45:10 <scopedTV> mcstar: Just 37 as well
10:45:13 <mcstar> > () undefined
10:45:14 <lambdabot>   Couldn't match expected type `a -> t' against inferred type `()'
10:45:28 <nand`> let me improve my formulation
10:45:38 <nand`> actually let me not
10:45:51 <nand`> the problem is that ‚Äòis‚Äô sometimes should be ‚Äòcan be‚Äô for certain polymorphic types
10:45:53 <Tomsik> It all depends on how you look at it. You can church-encode datatypes and they'll be functions then too
10:46:33 <scopedTV> Tomsik: that's like saying "everything is a function because a is isomoprhic to () -> a" (don't think about bottom for a second)
10:46:55 <scopedTV> of course you can turn "non-functions" into functions, nobody denies that
10:47:09 <nand`> dmwit: hmm, seems like the newer GtkTV doesn't support textures anymore (support was dropped past 0.1.9 which fails to build due to opengl-bitmap not building, shame)
10:47:11 <Tomsik> Neither am I. nand is trying to be a philosopher. :P
10:47:17 <nand`> dmwit: so now I need a new suggestion :P
10:47:43 <nand`> Tomsik: eh, the philosopher would say ‚Äúeverything is a function and functions are everything‚Äù
10:48:01 <scopedTV> so deep, and so shallow at the same time.
10:48:03 <nand`> I'm trying to take a more ‚Äúpractical‚Äù stance
10:48:07 <Tomsik> There is an interpretation where it's true
10:48:24 <Tomsik> nand`, practical stance is "if you can apply arguments to it, it's a function"
10:48:26 <mcstar> but, my question is, does every function has a function?
10:48:30 <nand`> Tomsik: exactly
10:48:30 <Tomsik> what
10:48:33 <scopedTV> mcstar: uh?
10:48:34 <mcstar> have*
10:48:44 <dmwit> nand`: Hm, bummer. =P
10:48:48 <scopedTV> you're overloading the word "function" here, i hope
10:48:54 <nand`> mcstar: if a function has no function, it wouldn't have been written
10:48:56 <scopedTV> otherwise i don't understand what you're saying
10:48:59 <mcstar> scopedTV: it takes time to understand, dont worry, it will come to you
10:49:03 <scopedTV> mcstar: good.
10:49:17 <dmwit> nand`: How much does efficiency concern you?
10:49:32 <nand`> the moment you try constructing a trivial function to give an example of a function with no function, you gave it a function
10:49:34 <nand`> QED
10:49:52 <dmwit> (Can you just put a slider and a canvas in a vbox and re-render the entire damn thing every time the slider changes?)
10:49:52 <silver> awesome
10:49:56 <nand`> dmwit: little. It should be usable within a human lifetime, ideally
10:50:01 <scopedTV> consider the smallest (lexicographically) function which has no function
10:50:04 <Tomsik> I'll just head somewhere else now. Hrm.
10:50:04 <scopedTV> than that has a function
10:50:06 <nand`> dmwit: that could work
10:50:11 <scopedTV> contradiction; therefore all functions have a function.
10:50:18 <dmwit> nand`: Seems like plain old Gtk (or wx or Qt if you know those better) would be fine.
10:50:24 <nand`> dmwit: the operations I'm performing are pixel-wise, if it helps
10:50:39 <nand`> hmm
10:50:47 <nand`> this would be a perfect job for a pixel shader
10:50:55 <nand`> maybe I could explore gpipe or whatever that fancy thing is called
10:50:55 <dmwit> =)
10:51:22 <nand`> parametric pixel shaders operating on texture samplers in render-to-texture mode should do the trick
10:51:58 <nand`> dmwit: should all else fail I'm willing to devolve to ‚Äòfoo 0.7 < in.png > out.png‚Äô
10:52:12 <nand`> it just makes finding the right parameters more guesswork
10:53:25 <dmwit> That should really not be necessary.
10:53:49 <mcstar> demonstrating a functional paradox: "this function doesnt serve a function"
10:54:27 <mcstar> oh, scopedtv had something like that
10:55:02 <hpaste> MagneticDuck annotated ‚Äúindentation error in case statement‚Äù with ‚Äúindentation error in case statement FIXED‚Äù at http://hpaste.org/71592#a71594
10:55:06 <scopedTV> mcstar: it's a play on the theorem "all natural numbers are interesting."
10:55:17 <nand`> hehe
10:58:06 <nand`> dmwit: is there an example that I could look at or modify for implementing something like this? I'm more interested in the image transformations than the GUI around them :)
10:58:28 <mcstar> nand`: its very easy to write a gui you need
10:58:56 <mcstar> have you tried reactive banana with wxhaskell?
10:59:01 <nand`> I have not
10:59:01 <mcstar> (no you havent, but do)
10:59:33 <mcstar> or
10:59:37 <mcstar> with even gloss
10:59:47 <mcstar> if you dont need a gui feeling gui
10:59:48 <anannie> Hi does anyone over here do practical ML?
11:00:04 <nand`> I'd use gloss but I'm not sure how to best handle input in gloss
11:00:04 <mcstar> just like a line with some marker, you can actually just paint it on the screen
11:00:12 <mcstar> nand`: super duper easy
11:00:18 <nand`> I'm pretty firmly stuck to the idea of a numerical slider
11:00:29 <anannie> I need some help to understand a system
11:00:43 <mcstar> nand`: like, with ticks and labels?
11:01:15 <nand`> I'd want a label giving me the numerical value at any given time; this possible also being editable. Ticks should not be necessary, but some form of indication would not be wasted
11:01:40 <nand`> if possible, these values should be easily copy/pasteable too
11:02:16 <nand`> I'll have a look at reactive-banana
11:02:26 <jedai> nand`: Ok, so no gloss for you
11:06:11 <adnauseam> if >>= is bind, what should i call >> ?
11:06:22 <Botje> I call it 'and-then'
11:06:22 <c_wraith> "then"?
11:06:35 <adnauseam> works for me! thanks guys
11:11:23 <nand`> mcstar: reactive-banana-wx has a dependency on cabal-macosx. Is this intended?
11:11:35 <mcstar> o.O
11:11:42 <mcstar> are  you on osx?
11:11:46 <nand`> I am not
11:11:51 <mcstar> neither am i
11:12:06 <mcstar> i never heard of cabal-macosx
11:12:28 <mcstar> nand`: i dowloaded the package, can build the files, and such
11:12:36 <mcstar> wo noticing cabal-macosx
11:12:48 <nand`> oh
11:12:51 <nand`> Note: You need to install the (platform independent) cabal-macosx library before you can configure/build and install this library.
11:13:32 <mcstar> Versions installed: 0.2.2
11:13:40 <mcstar> i have it installed
11:14:13 <nand`> I.. what
11:14:22 <nand`> this wants to pull in media-libs/gstreamer
11:18:41 <nand`> I think I will use Gtk2Hs
11:26:33 <tew88> I'm having some conceptual difficulty with the following code: http://hpaste.org/71596 -- can someone explain how paths is being constructed? Was I naive to expect to see an occurence of : or ++ here?
11:26:38 <tew88> (Line 11)
11:28:23 <Botje> tew88: concat :: [[FilePath]] -> [FilePath]
11:28:48 <geekosaur> tew88, x </> y does x ++ "/" ++ y on unix, x ++ "\\" ++ y on windows
11:28:55 <Botje> tew88: the forM applies that \name -> ... lambda to each element of properNames
11:29:08 <Botje> tew88: and the results (in this case lines 15 or 16) are gathered
11:29:10 <geekosaur> and if we had instances for other OSes it could do other things
11:29:38 <byorgey> this is amusing, Botje and geekosaur seem to have fundamentally different interpretations of tew88's question =)
11:29:45 <Botje> :t forM_
11:29:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
11:29:47 <Botje> :t forM
11:29:48 <geekosaur> probably
11:29:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
11:29:50 <Botje> tew88: ^^
11:29:50 <tew88> Haha
11:29:52 * byorgey has no idea which one tew88 actually meant
11:30:03 <tew88> That'll be the path vs. path*s* naming
11:30:17 <tew88> Botje appears to be on point
11:30:34 <tew88> Thanks though, geekosaur
11:32:16 <tew88> Botje: My trouble is... I don't understand how it's being applied recursively. I'm probably not going to articulate this at all well, but my presumption was that names <- [someList] applied multiple times should need some list constructor operation going on
11:32:43 <tew88> But this is no doubt just a lack of understanding on my behalf at this present moment -- I probably just need to stare at it some more!
11:33:45 <Botje> tew88: in this specific instance, the entire forM ... expression has type IO [[FilePath]]
11:34:03 <Botje> tew88: forM has the type lambdabot gave above
11:34:19 <tew88> Right, thanks for the pointer
11:34:30 <Botje> tew88: it's being applied recursively because line 15 calles getRecursiveContents
11:34:50 <Botje> and whatever that returns for the subdirectory is gathered in paths as well
11:35:02 <tew88> That bit ^^!
11:35:10 <tew88> *How* is it gathered?
11:35:16 <Botje> it's what forM does
11:35:24 <Botje> forM is just mapM with the arguments flipped
11:35:30 <Botje> so, do you know mapM? :)
11:35:48 <tew88> I'd have answered 'yes' before this example stumped me!
11:36:13 <tew88> Ohhhhhhhhhhhhhhh
11:36:37 <tew88> All of the recursion goes on inside the lambda!
11:36:40 <tew88> Sort of
11:36:49 <Botje> pretty much.
11:37:20 <c_wraith> in particular, it's true that all the binding has to happen before the first list constructor is even produced
11:37:25 <Botje> the lambda has type FilePath -> IO [FilePath]
11:38:29 <tew88> Thanks =)
11:39:57 <hpaste> dmwit pasted ‚Äútemplate for slider+image‚Äù at http://hpaste.org/71598
11:40:13 <dmwit> nand`: It turned out to be a bit more annoying and gross than I had predicted.
11:40:15 <dmwit> But there you go.
11:40:28 <dmwit> Whoops, left a debugging print in. Anyway.
11:40:58 <dmwit> Lines 28-30 are the bits you'd change.
11:41:17 <dmwit> 26 and 27, too, I guess, unless you only want to change the 10x10 square in the top left =)
11:44:41 <nand`> dmwit: that helps an immense amount, thanks
11:44:48 <nand`> I was still figuring out how to create a slider
11:44:56 <nand`> you weren't kidding about performance, it seems
11:45:51 <dmwit> It shouldn't be that inefficient.
11:46:25 <nand`> it does take about a second or so to update
11:46:28 <dmwit> I mean, it just copies each pixel from the original to the copy on each slider change.
11:46:31 <dmwit> Wow, what?
11:46:54 <dmwit> How big is your picture/how exciting is your transformation function?
11:46:55 <nand`> or maybe it just seems that way. Wait, how do I make it parametric based on the new value of the scale?
11:47:29 <nand`> it's 800x600 and I've preserved the code you had but removed the print and changed the ranges to 0..799 and 0..599 appropriately
11:47:45 <dmwit> nand`: get rangeValue scale :: IO Double
11:48:09 <dmwit> or maybe get scale rangeValue
11:48:10 <dmwit> I dunno
11:48:21 <dmwit> Anyway, you can read the docs, once I've given you the pointers. =P
11:49:12 <dmwit> Wow, that is really slow.
11:49:17 <dmwit> I wonder what's up with that.
11:51:03 <schlicht> why does the vim haskelmode sometimes need all my cpu, when it trys to display a type a function (i use gvim and that happens if i hover over the name)?
11:52:12 <nand`> dmwit: yes, it needs about 2 seconds to update
11:52:15 <nand`> (for the entire image)
11:52:21 <dmwit> Yeah, that's horrible, I agree.
11:52:25 <nand`> this time I'm using a somewhat more complicated function
11:52:33 <nand`> http://bpaste.net/show/35319/
11:52:41 <nand`> emphasis on ‚Äúsomewhat‚Äù
11:53:28 <dmwit> I can't really spend much more time on this right now, I'm afraid.
11:53:35 <nand`> dmwit: that's fine, I appreciate the help
11:53:45 <dmwit> But one thing to try might be switching to cairo and using compositing effects instead of munging the bits directly.
11:53:45 <nand`> I would need much longer to dig the appropriate amounts of information out of the documentation
11:54:01 <dmwit> If that's possible, it will likely be much faster, though I don't really know why reading and writing the bits directly is so darn slow.
11:54:49 <dmwit> Relevant docs for that are here: http://hackage.haskell.org/packages/archive/cairo/0.12.3.1/doc/html/Graphics-Rendering-Cairo.html#g:9
11:54:57 <nand`> dmwit: thanks
11:57:59 <tew88> Botje: Am I on the right lines? I'm not actually constructing a new list as such, I'm mapping (with forM) over the existing properNames list?
11:58:05 <tew88> I think that was the source of my confusion
12:04:09 <tgeeky> dmwit: woohoo! I get to further annoy UPenn students, but *in* *person* this time!
12:04:30 <dmwit> oh?
12:04:59 <tgeeky> dmwit: hac phi registration :o
12:05:03 <tgeeky> it's not permenant, don't worry
12:06:03 <dmwit> Oh, yes. =)
12:06:09 <dmwit> Can't wait to be annoyed.
12:07:10 <tgeeky> i assume the deadline is almost here? perhaps time to send out one last reminder?
12:07:44 <nand`> dmwit: I'm having a bit of trouble understanding how cairo is meant to be used. Do I get rid of Pixbuf and switch to Surface; or do I keep the Pixbuf and just modify its contents using cairo somehow? In the former case, how do I actually draw the cairo surface onto the window?
12:08:10 <dmwit> You switch to Surface, and then you don't use the getSurfaceData (spelling?) function.
12:08:33 <dmwit> Surfaces can be set as sources.
12:10:13 <dmwit> ...I was about to write a long extra thing, but I think the best next step would rather be a cairo tutorial than a long IRC message. =P
12:10:53 <nand`> probably
12:11:21 <dmwit> For the final rendering, you'd use renderWithDrawable to send all the cairo commands to a widget's drawing area.
12:16:26 <nand`> hmm
12:17:22 <nand`> ‚ÄúliftIO . renderWithDrawable w $ setSourceSurface original 0 0‚Äù <- original is my Surface
12:17:35 <nand`> this seems correct, but apparently doesn't actually do anything
12:18:17 <dmwit> Right, setting a source doesn't do anything visible.
12:18:27 <dmwit> You have to do drawing operations to "put down ink" on the target.
12:18:37 <dmwit> The source just says what color (and opacity) ink to use when drawing.
12:18:40 <nand`> I see
12:19:03 <dmwit> And the Operator tells how to combine ink with any other ink that was already there.
12:20:06 <nand`> I added a >> paint; this seems much faster
12:20:09 <nand`> I notice no delay when updating
12:20:17 <nand`> but it doesn't actually do anything yet so I can't tell for sure
12:20:38 <Luke> does anyone know how to reset the "cursor state" for an ODBC connection via HDBC?
12:20:45 <Luke> or allow multiple reads from the same table?
12:21:07 <nand`> would it be possible to implement ‚ÄúpaintWith :: (Color -> Color) -> Render ()‚Äù ?
12:21:23 <nand`> or am I thinking about this the wrong way
12:22:57 <dmwit> I don't think so (though I'm not 100% sure), hence the huge "switch to compositing if that's possible" caveat above. =)
12:23:29 <dmwit> Many Color -> Color operations are easily expressed as compositing operations that are already offered, though I'm not sure that all are.
12:24:53 <nand`> I'm not sure what compositing operations you're referring to
12:25:18 <nand`> I'm looking in Graphics.Rendering.Cairo; is this wrong?
12:25:27 <nand`> all I see is stuff about patterns, strokes, paths and translations
12:26:01 <fredflinstone> Hello everyone... I am talking a course on Haskell and I don't understand what a couple of dashes "-" means within a function. I tried to google but I cannot get an answer
12:26:13 <mauke> fredflinstone: "--" starts a comment
12:26:14 <nand`> a pair of dashes is a comment
12:26:27 <fredflinstone> no it isn't a comment though
12:26:33 <mauke> show me
12:26:43 <fredflinstone> I'll type the function and give a link one sec
12:26:50 <dmwit> nand`: http://hackage.haskell.org/packages/archive/cairo/0.12.3.1/doc/html/Graphics-Rendering-Cairo.html#t:Operator
12:27:01 <nand`> dmwit: ah
12:27:57 <fredflinstone> http://codepad.org/OX5AWEY9
12:28:09 <avpx> fredflinstone: Those are supposed to be underscores: _
12:28:17 <MagneticDuck> you put two spaces
12:28:23 <MagneticDuck> *one space
12:28:28 <MagneticDuck> between the slashes
12:28:32 <avpx> fredflinstone: Underscores signify placeholders in pattern matching.
12:28:41 <fredflinstone> oh I see
12:29:00 <fredflinstone> why are the underscores spaced differently?
12:29:05 <MagneticDuck> ?
12:29:08 <fredflinstone> does the white space matter
12:29:12 <avpx> fredflinstone: The underscores aren't significant there.
12:29:13 <mauke> fredflinstone: to make them line up with the previous line
12:29:15 <MagneticDuck> no
12:29:19 <MagneticDuck> well you don't have to
12:29:19 <mauke> avpx: yes, they are
12:29:31 <avpx> mauke: Not semantically.
12:29:34 <mauke> avpx: yes, they are
12:29:37 <dmwit> The *whitespace* isn't significant there.
12:29:42 <dmwit> The underscores are significant.
12:29:46 <avpx> Woops
12:29:51 <MagneticDuck> you can just type : zipWith _ _ _ = []
12:29:57 <fredflinstone> oh
12:29:59 <avpx> I was pretty sure I said spaces, not underscores.
12:30:02 <avpx> My bad.
12:30:23 <MagneticDuck> yes, yes it was >:|
12:30:31 <mauke> fredflinstone: http://codepad.org/yvOFTjpe - this is what it's supposed to look like
12:30:40 <avpx> MagneticDuck: I'm truly a terrible person, I know.
12:31:07 <fredflinstone> ya my professor wrote it that way and didn't explain.. i was confused because white space is significant in haskell
12:31:16 <mauke> only sometimes
12:31:18 <fredflinstone> thanks guys
12:31:23 <avpx> fredflinstone: The whitespace in this case is insignificant, but it is significant in determining indentation level, so watch out.
12:31:28 <MagneticDuck> lol avpx. Making terrible errors like that, I'd imagine. YOU ALMOST KILLED SOMEBODY THERE!!
12:31:36 <MagneticDuck> yeah
12:31:54 <MagneticDuck> indentation is where it matters
12:31:55 <mcstar> putting the _ under ys is misleadig
12:32:15 <MagneticDuck> _ takes the place of (y:ys)
12:32:22 <MagneticDuck> in case you're confused
12:32:24 <avpx> I'm pretty jealous that you are taking a class that teaches Haskell.
12:32:28 <MagneticDuck> heh
12:32:31 <MagneticDuck> I'm just teaching myself
12:32:36 <mcstar> not me ofc, i said it is misleading
12:32:38 <avpx> I meant fredflinstone, not you, MagneticDuck
12:32:44 <mcstar> not that i am mislead
12:33:00 <mcstar> and i definitely dont miss lead
12:33:01 <fredflinstone> well it goes through a bunch of functional languages avpx
12:33:10 <MagneticDuck> there are a lot of awesome tutorials out there, so it's not too hard to teach yourself
12:33:11 <nand`> dmwit: there, got it to work
12:33:15 <fredflinstone> now we are doing prolog
12:33:24 <MagneticDuck> woah
12:33:28 <MagneticDuck> zipping through pretty fast
12:33:32 <nand`> dmwit: I have OperatorMultiply and OperatorAdd, something tells me that this should be able to express every possible computation
12:33:39 <MagneticDuck> they didn't learn haskell in a week you know!
12:33:47 <silver> avpx, oh don't be, bad class can kill interested to an awesomest topic
12:33:54 <MagneticDuck> true
12:33:58 <silver> s/interested/interest
12:34:01 <MagneticDuck> I'd rather learn alone than in a class
12:34:04 <avpx> Our intro CS courses have all been in C++. *groan*
12:34:06 <MagneticDuck> I can pick my own projects
12:34:08 <fredflinstone> ya it's pretty insane... I have a midterm in haskell in 2 days :/
12:34:28 <MagneticDuck> okay none of us are jealous anymore
12:34:35 <MagneticDuck> o.o
12:34:37 <avpx> I never get to take midterms anymore :-\
12:34:42 <MagneticDuck> lol
12:34:53 <dmwit> nand`: Hm. =)
12:35:06 <dmwit> Not sure that applies when the operations are clipped. =)
12:35:16 <MagneticDuck> I'm not a big fan of school
12:35:44 <fredflinstone> ya haha we went over monads in the 2nd week
12:35:55 <MagneticDuck> I like learning by doing
12:36:04 <MagneticDuck> not by tests
12:36:09 <avpx> fredflinstone: How comfortable are you with monads, out of curiosity?
12:36:14 <MagneticDuck> because in real life, you don't take tests. You do things.
12:36:18 <MagneticDuck> school makes no sense
12:36:19 <nand`> dmwit: oh. hum.,
12:36:33 <fredflinstone> avpx ask me after I pull an all nighter tonight
12:36:39 <avpx> fredflinstone: Can I recommend a resource?
12:36:51 <MagneticDuck> tests don't even map to the problems you encounter in reality
12:36:54 <fredflinstone> sure, I've been using learn you a haskell
12:37:19 <avpx> fredflinstone: http://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/ <-- someone in the channel showed me this and I think it's a nice overview
12:37:42 <avpx> fredflinstone: Real World Haskell is pretty complete and can be read online. I recommend it.
12:38:00 <avpx> MagneticDuck: It's true. Besides, when I write a Haskell program, I go through many iterations of trying to make it type check. That's not something you can do on a test.
12:38:10 <fredflinstone> ya it looks interesting coming from a java background
12:38:14 <nand`> dmwit: now I just have to figure out how to express my color computation in this clipped-ring calculus :)
12:38:24 <dmwit> right =)
12:39:03 * hackagebot test-simple 0.1.4 - Simple Perl inspired testing (BorisSukholitko)
12:39:11 <fredflinstone> I really like the idea of lamda functions
12:39:24 <nand`> not to be confused with lama functions
12:39:40 <nand`> or llama. However that word is spelled
12:39:45 <MagneticDuck> school should basically be like #haskell
12:39:50 <MagneticDuck> but you're required to make an irc bot
12:39:58 <MagneticDuck> and BAM you learned haskell
12:40:00 <MagneticDuck> it works
12:40:11 <fredflinstone> well I have to do a haskell project by the end of the semester ...
12:40:14 <fredflinstone> with a ui
12:40:19 <fredflinstone> which are the best libraries?
12:40:22 <avpx> Oh boy.
12:40:24 <MagneticDuck> gtk2hs
12:40:26 <MagneticDuck> BAM
12:40:27 <nand`> I was about to say ‚Äúconsider yourself lucky‚Äù, then I saw ‚Äúwith a ui‚Äù
12:40:32 <avpx> nand`: Same here.
12:40:34 <MagneticDuck> yeah
12:40:47 <dmwit> As the gtk2hs maintainer, I'm a bit biased, but... gtk2hs. =P
12:41:06 <nand`> dmwit: how long until we get gtk-3? :P
12:41:09 <MagneticDuck> I actually haven't even made an ui yet
12:41:10 <MagneticDuck> x
12:41:11 <MagneticDuck> xD
12:41:15 <avpx> There is a hugely diverse set of UI libraries in Haskell. Some are very ambitious and try to fit UI into a pure functional framework. Others are more like wrappers around C functions in the IO monad. What I'm saying is, there is quite a spectrum.
12:41:17 <nand`> (admittedly, the reason I wanted gtk-3 has now disappeared)
12:41:25 <dmwit> nand`: Peter Davies is working on it, and I've scheduled some time this week to try and iron out the infelicities in his patches.
12:41:48 <nand`> sounds promising
12:41:52 <dmwit> Then again, schedules...
12:41:55 <MagneticDuck> heh
12:42:02 <fredflinstone> there is a joke in the class that we will all hand in c programs wrapped in haskell
12:42:08 <MagneticDuck> btw what's up with that "haskell notebook" thing we were talking about?
12:42:11 <MagneticDuck> that sounds really cool
12:42:21 <MagneticDuck> like mathematica or SAGE but based in haskell
12:42:26 <MagneticDuck> what's that called?
12:43:23 <aristid> MagneticDuck: maybe you mean this? http://tryhaskell.org/
12:43:26 <luite> MagneticDuck: it's stalled a bit, but it probably will get finished
12:43:32 <MagneticDuck> aristid: nono
12:43:35 <MagneticDuck> that's just ghci
12:43:39 <MagneticDuck> except underpowered
12:43:52 <MagneticDuck> I mean something that adds graphics and animations to everything
12:44:00 <aristid> more animations!
12:44:03 <MagneticDuck> that you can use as a CAS and stuff
12:44:07 <MagneticDuck> like mathematica
12:44:07 <aristid> hmm
12:44:11 <MagneticDuck> you've worked with mathematica right?
12:44:32 <MagneticDuck> I'm sure to start that it won't be as powerful as mathematica but it will still be pretty awesome
12:44:36 <MagneticDuck> there's nothing like it out yet
12:44:49 <MagneticDuck> when it comes out, I'll officially break my mathematica addiction
12:45:01 <MagneticDuck> :D
12:45:17 <MagneticDuck> luite: What's it going to be called
12:45:25 <MagneticDuck> or at least what's it referred to now?
12:45:40 <luite> MagneticDuck: my own project is called wolfgang
12:46:05 <MagneticDuck> ah. What does wolfgang do?
12:46:13 <luite> MagneticDuck: which basically does that (a wiki first, local version later)
12:46:19 <luite> haskell notebook interface with graphics
12:46:25 <MagneticDuck> okay
12:46:31 <nand`> dmwit: ah, excellent; scaleSetDigits scale 2 makes it much smoother (and still very responsive)
12:46:58 <MagneticDuck> btw what kind of graphics libraries are used in gtk2hs?
12:47:04 <MagneticDuck> erm
12:47:05 <nand`> dmwit: would it be possible, in principle, to have the whole thing top-aligned somehow? right now, the entire scale takes up half the window vertically, with the image squished into the bottom portion
12:47:08 <MagneticDuck> let me state that better
12:47:35 <MagneticDuck> how do I draw vector graphics to an image widget in gtk2hs?
12:47:44 <luite> use cairo
12:47:48 <MagneticDuck> okay
12:47:51 <MagneticDuck> vector?
12:48:02 <luite> well, there are vector graphics libs on top
12:48:03 <MagneticDuck> they're vector graphics I mean?
12:48:06 <luite> like diagrams
12:48:12 <MagneticDuck> okay
12:48:19 <luite> perhaps gloss, i'm not sure about that one
12:48:21 <MagneticDuck> cario is the rasterization
12:48:25 <MagneticDuck> gloss?
12:48:36 <luite> wolfang is webbased, so it uses svg and webgl for gfx
12:48:37 <dmwit> MagneticDuck: cairo operations are vector operations; it's only rasterized at the moment you render to screen
12:48:52 <dmwit> nand`: Yes, just set the sizeRequest of the drawing area to be bigger.
12:48:57 <luite> MagneticDuck: cairo can rasterize to screen, but also output to pdf or svg if you want
12:49:05 <dmwit> nand`: As for scaleSetDigits scale 2, you might as well just pick a different scale when the thing is created...
12:49:10 <MagneticDuck> wait, like if I want to make a game, what do I use to draw the game image?
12:49:21 <MagneticDuck> who here has made a game?
12:49:25 * dmwit
12:49:34 <MagneticDuck> alright I'll listen to you
12:49:59 <MagneticDuck> btw right after I finish my roboduck I'll plough right into gtk2hs
12:50:05 <MagneticDuck> don't have the time right now though
12:50:10 <nand`> dmwit: you mean like hScaleNewWithRange ? that one explicitly mentions using scaleSetDigits to set the precision, doesn't it?
12:50:35 <dmwit> nand`: I mean adjustmentNew
12:52:23 <nand`> dmwit: which parameter am I supposed to be changing? pageSize? I obviously can't change the first three (default, min, max) and the only two others (step increment) don't seem to affect the precision; even with a stepincrement of 0.001 or 0 the precision is set to one digit
12:52:46 <Digit> :)
12:54:01 <dmwit> nand`: You're right, and also I'm an idiot.
12:54:25 * tgeeky_ sends dmwit his membership card
12:54:41 <dmwit> \o/
12:57:57 <nand`> dmwit: where can I find documentation for the Operators?
12:59:19 <dmwit> dunno lol
12:59:36 <nand`> I'm having difficulties thinking of ways I can have different color channels interact with eachother: I need to transform my RGB triple into an opposite color model; do transformations within these and then transform it back to RGB
13:00:40 <nand`> maybe if I can manage to ‚Äòcopy‚Äô one channel to another channel I can come up with a contrived stack-based solution
13:01:08 <dmwit> This just seems wrong.
13:01:19 <dmwit> If you're doing that many contortions, this is not the right way to solve the problem.
13:01:27 <timthelion> is there a way to poll if a thread exists?  AKA isRunning :: ThreadId -> IO Bool
13:01:27 <nand`> but I see ‚ÄòOperatorHslHue‚Äô, -Saturation, -Color and -Luminosity; I'm thinking I can make use of these to do what I want
13:01:54 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Conc-Sync.html#v:threadStatus
13:02:08 <timthelion> dmwit: thanks
13:02:20 <nand`> dmwit: there's always the direct memory access ‚Äòsolution‚Äô, but yeah; performance
13:02:36 <dmwit> http://cairographics.org/operators/ maybe
13:02:57 <nand`> that might be useful
13:03:06 <nejucomo> Where can I find the possible values or string descriptions of IOErrors?
13:03:07 <nand`> I've forgotten how to search for documentation of things not on hackage
13:06:31 <nand`> dmwit: ah, the HSL_ operators do sound useful
13:24:03 <astory> Hi, I want to read from a pipe (I have a handle to its stdout) until the process on the other end terminates.  Is there a convenient way of doing this?
13:25:18 <DanBurton> astory: just use the regular read functions I would guess; presumably you'll hit the EOF when it terminates (?)
13:25:48 <however> astory: you might want getContents or hGetContents
13:26:01 <astory> DanBurton: I'm wondering if I can just read until the process handle tells me termination, but yeah, that makes sense
13:27:38 <astory> however: and that'll just keep me waiting until EOF gets passed through?
13:28:05 <dmwit> No, it's lazy.
13:28:09 <barrucadu> astory: When the other process closes the stream, EOF is signalled
13:29:03 <astory> dmwit: well, yeah, but the computation that depends on it will wait
13:29:52 <jfischoff> astory: not all of it
13:29:54 <dmwit> astory: No, it's lazy.
13:30:45 <however> :t getContents
13:30:46 <lambdabot> IO String
13:31:41 <however> astory: ^^ it involves some kind of lazy witchcraft, but the end result is that you get a String of everything that showed up on stdin. end of the String means EOF
13:34:13 <DanBurton> indeed, due to laziness you could start processing the results before it is entirely finished
13:34:18 <singpolyma> Is there a good wiki page or article somewhere on pros/cons for Parsec vs Attoparsec?
13:34:46 <DanBurton> Not sure if there are enough differences to merit a wiki page
13:34:53 <timthelion> is there a good way to block for MVar a OR b AKA wait for one to be filled?  Making MVar c(type Either a b) occurs to me.  fork twice, first fork waits for MVar a and put MVar c Left a, second fork takes MVar b and puts c and parent blocks on c, but this is quite ineficient.
13:34:59 <DanBurton> use Parsec unless you really want speed, then use Attoparsec
13:36:17 <singpolyma> DanBurton: Yeah?  Is Attoparsec a lot faster, or just somewhat?  I assume you lose some sort of flexebility for that speed
13:36:32 <shachaf> timthelion: You could use STM.
13:37:06 <c_wraith> singpolyma: the main thing you lose is the ability to parse things other than sequences of bytes
13:37:15 <simukis> Good evening
13:37:16 <timthelion> shachaf: I'll look at it, thanks.
13:37:22 <MostAwesomeDude> singpolyma: There's a thing called "parsers" on Hackage that provides combinators which can build either Parsec or Attoparsec parsers.
13:37:25 <singpolyma> c_wraith: Attoparsec supports Data.Text, which is what I would use
13:37:47 <c_wraith> I couldn't remember if that was folded in to attoparsec itself
13:37:53 <however> timthelion: are the two MVars a given? could you get rid of them? i think there's ways to safely have two writers and one reader on a single MVar
13:37:59 <simukis> (I'm still a newbie) Trying to do :m +Data.Fraction fails with Could not find module `Data.Fraction'. How should I get that module?
13:38:04 <c_wraith> But parsec is much more general.  It can handle parsing streams of anything
13:38:15 <Cale> SearchableClassPropertySearchableGrailsDomainClassMappingConfigurator.java -- lol
13:38:40 <singpolyma> c_wraith: right, ok, that makes sense.  in this case, I'm parsing text
13:38:42 <timthelion> however: It would be possible, but unfortunately it would mess up the typing to do it that way :(
13:38:52 <byorgey> singpolyma: perhaps you want Data.Ratio ?
13:39:06 <byorgey> sorry, I mean simukis, not singpolyma
13:39:09 <shachaf> timthelion: I would also say that the two-thread solution might not be *that* bad.
13:39:18 <timthelion> however: with the method I gave, you wouldn't have to rewrite the code that writes to the MVars, just the code that reads them.
13:39:28 <byorgey> simukis: I've never heard of a module called Data.Fraction, why do you think you need/want that module?
13:40:09 <timthelion> shachaf: it seems that constantly creating MVar c and destroying it is a waste of time, and keeping it arround feels a bit like reusing a pointer in C
13:40:23 <however> cale: Data/SemiAbelian/Dual/Paralipomenon/Dual/Confuzzloid/Chi.hs
13:40:40 <Cale> however: Does that actually exist?
13:40:49 <timthelion> and how long does it take/how much memory does it take, to create those threads?
13:40:51 <Cale> because mine does: https://svn.codehaus.org/grails-plugins/grails-searchable/trunk/src/java/org/codehaus/groovy/grails/plugins/searchable/compass/config/mapping/
13:41:04 <hpaste> identity pasted ‚Äúcriterion dependency issue‚Äù at http://hpaste.org/71603
13:41:19 <identity> ANyone mind taking a look? How do I get out of this dep hell?
13:41:33 <however> cale: either it is in one of ekmett's 400 packages, or he's working on it
13:41:41 <simukis> byorgey: Just found it here: http://hackage.haskell.org/packages/archive/fraction/0.0.1.0/doc/html/Data-Fraction.html
13:41:47 <hpc> timthelion: the allocation of mvars isnt significantly more than a regular value
13:42:02 <simukis> byorgey: by searching for `haskell fraction`. Seems that ratio is what I need. Thanks
13:42:23 <timthelion> hpc: and the wastefullness of creating two threads with a life span of one and a half system calls?
13:42:26 <byorgey> simukis: oh, that is in the 'fraction' package on Hackage
13:42:36 <byorgey> simukis: also, it's an old version
13:42:45 <Cale> however: All of Ed's stuff you can look up in math books though. People invent the Java insanity on the fly and half of it is internal undocumented stuff :)
13:42:52 <hpc> timthelion: also low
13:42:57 <byorgey> simukis: in the future, try searching with Hoogle instead of Google: http://www.haskell.org/hoogle/
13:43:06 <nobdraisentone> Did anyone know what is wrong with lambdabot? http://pastebin.com/raw.php?i=xM7p5sMf
13:43:10 <mauke> The paste xM7p5sMf has been copied to http://hpaste.org/71604
13:43:41 <however> cale: good point. also, i was kidding, if that wasn't apparent 8-)
13:43:52 <timthelion> hpc: Just to calabrate your personal idea of what "low" is, do you think that Javascript + C is not a preformance issue since the slow parts can always be profiled?
13:44:03 <timthelion> ;)
13:44:11 <hpc> nobdraisentone: yes
13:44:22 <hpc> nobdraisentone: sec to get link, i am on a phone
13:44:43 <hpc> http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13
13:45:36 <hpc> the changes in that post would be in darcs too, but i cant find the maintainer
13:46:23 <simukis> byorgey: Thanks. (and it's ddg not google)
13:46:36 <identity>  identity pasted "criterion dependency issue" at
13:46:36 <identity>                 http://hpaste.org/71603
13:46:43 <identity> Any takers? :)
13:46:57 <tromp> is there a better alternative to take n list in Perl than @list[0..$n-1] ?
13:46:57 <hpc> timthelion: it's low in the sense that you can have a hundred thousand threads running at once
13:47:04 <byorgey> simukis: fair enough.  the point is, any general search engine is likely to give you links to out-of-date documentation and such
13:47:25 <hpc> tromp: sub take($@) ...
13:47:38 <hpc> take 5, @blah
13:47:55 <timthelion> hpc: I'm somewhat concerned about preformance right now, since I'm expecting my programs to eventually be compilable on the raspberri pi...
13:47:56 <hpc> define it yourself
13:48:17 <hpc> timthelion: wait and see if it is slow on a pi
13:48:33 <timthelion> hpc: OK, will do
13:48:40 <nobdraisentone> hpc: so cabal package is unbuildable with ghc-7.4.1?
13:48:43 <hpc> threads in ghc are light enough to be nearly noops
13:49:00 * timthelion sufferes from memorexia and sometimes fasts when he doesn't have to.
13:49:30 <hpc> nobdraisentone: dont think so
13:49:51 <hpc> my post was written for the darcs repo
13:50:12 * hpc -> away
13:51:11 <tgeeky_> hm. can I get some template haskell help? I am trying to get "ZeroTH" to work again, and I am pretty close, but I'm confused about why/how it's failing. Basically, there is a file it must preprocess and compile, and in that file is:
13:51:23 <tgeeky_> two of these: $(derive makeMonoid ''TempFlags)
13:51:33 <dmwit> simukis: ddg has !hoogle, for what it's worth
13:51:59 <tgeeky_> the problem is, it compiles (further) if I take away $( .. )
13:52:06 <tgeeky_> but I don't understand why :/
13:56:36 <hpaste> tgeeky pasted ‚Äútemplate haskell‚Äù at http://hpaste.org/71606
13:56:40 <tgeeky_> ok
13:56:44 <tgeeky_> I think all relevant details are in there
13:57:46 <tgeeky_> at issue here, is that ZeroTH was designed back when Decl had TyCon:  SpliceDecl SrcLoc Splice
13:57:53 <tgeeky_> but now it has TyCon: SpliceDecl SrcLoc Exp
13:59:08 <tgeeky_> (for what it's worth, SpliceExp used to have argument Splice, and now it has Exp again
14:03:02 <luite> tgeeky_: do you know if there's any way to run the expression quasiquoter from th?
14:03:18 <gks> is learn you a haskell still relevent to start from?
14:03:27 <mikeplus64> gks: definitely
14:03:38 <tgeeky_> luite: you mean, just wrap something in [e| .. |]?
14:03:40 <mgsloan>  luite - well, you can use the GHC API :)
14:03:48 <tgeeky_> mgsloan: ooh you're here!
14:03:49 <gks> mikeplus64: great! thanks. just updating to 2012.2. about to get started. :)
14:03:55 <tgeeky_> mgsloan: can you help me debug getting ZeroTH working? :O
14:04:36 <mgsloan> Maybe!  I've got one that at least compiles on my github (but rather irresponsibly, I haven't tested it)
14:04:53 <tgeeky_> oh really? then you must have already fixed this :o
14:04:54 <luite> mgsloan: have you tried that? is it easy to get something actually referring to local names (outside the splice) for example?
14:05:09 <gks> out of curiosity, a compiled haskell application will run on the platform it was compiled for without any libraries?
14:05:50 <MostAwesomeDude> gks: Close enough.
14:05:51 <mikeplus64> gks: should do, ghc statically links by default
14:06:05 <mikeplus64> (but you can pass the -dynamic flag to get dynamic linking)
14:06:06 <gks> sweet. so it works much like a C/C++ app in that respect
14:06:09 <MostAwesomeDude> gks: (Do you need libc when running your C programs?)
14:06:10 <gks> not a Java app
14:06:10 <mgsloan> luite - I haven't tried it, but I've thought about it a little bit.  I wish it was built in / you could yield splice / QQ containing code from TH..  The solution I came up with was to query TH for the current source location, take the source upto that location, and run it through the interpreter
14:06:42 <tgeeky_> eww
14:08:04 <luite> mgsloan: that sounds terrible :p
14:08:23 <mgsloan> luite: It might be more practical to just extract the imports, and set up a ghc context from that.  Even better would be to use an activehs like approach, and have the interpreter running in a different thread, and only reload the context when necessary.  This is the same as the limitations TH puts on QQ reification
14:09:10 <tgeeky_> turn all splices into invertible computation?
14:09:39 <tgeeky_> and then just track the growth/shrinking of code as the splice expands or contracts the source files
14:11:35 <tgeeky_> mgsloan: you must have just used their manually-generated version of GetOpt
14:14:12 <tgeeky_> mgsloan: yep, that is what you are doing. I think the fact that my version on github doesn't work, proves that ZeroTH doesn't work
14:14:57 <mgsloan> tgeeky_: The code also looks waay more complicated than the task.  There's gotta be a simple way to do it
14:15:11 <tgeeky_> mgsloan: yeah, but I wanted ... you know ... a working version to compare to the new one :o
14:15:19 <mgsloan> aye
14:15:25 <tgeeky_> mgsloan: I think I have it partially working, see the hpaste output
14:16:02 <tgeeky_> the very last output (when I didn't use $(..)), has the right functions and definitions
14:16:10 <tgeeky_> http://hpaste.org/71606
14:18:39 <MagneticDuck> okay, I have another newbie problem...
14:18:44 <MagneticDuck> why doesn't the program:
14:18:53 <MagneticDuck> main = getContents >>= putStrLn . reverse
14:18:55 <MagneticDuck> do anything?
14:18:57 <MagneticDuck> >:|
14:19:13 <c_wraith> because you're not closing stdin?
14:19:19 <c_wraith> so you never reach the end of input
14:19:24 <MagneticDuck> ...oh
14:19:26 <MagneticDuck> >_<
14:19:27 <MagneticDuck> ty
14:22:23 <kallisti> how should I go about randomly generating passwords?
14:23:10 <povman> mash keyboard
14:23:41 <MagneticDuck> lol
14:23:43 <MagneticDuck> no
14:23:48 <MagneticDuck> get a dictionary of words
14:23:49 <c_wraith> kallisti: more precisely, what do you mean?
14:23:56 <MagneticDuck> and just make a list of random words
14:23:59 <MagneticDuck> easy to remember
14:24:00 <MagneticDuck> ^^
14:24:02 <kallisti> eh, I'll just roll my own
14:24:15 <kallisti> I was looking for a library to generate passwords. maybe UUID or something.
14:24:18 <dmwit> kallisti: https://www.random.org/passwords/
14:24:19 <MagneticDuck> oh
14:24:38 <tgeeky_> mgsloan: at least i know where it's failing ... at the last where clause in zeroTHinternal
14:25:17 <dmwit> UUIDs are not really good passwords.
14:25:32 <tgeeky_> they're great if you're a robut
14:25:40 <c_wraith> kallisti: what are you actually *doing*
14:25:50 <MostAwesomeDude> kallisti: $ pwgen
14:25:51 <c_wraith> tgeeky_: actually, they have really low entropy
14:26:04 <mgsloan> do you have the current state of the code up on github?
14:26:26 <aristid> c_wraith: the random-number based UUIDs have low entropy? oO
14:26:39 <tgeeky_> mgsloan: yep! and I even merged the two deps that were by the same author
14:27:04 <c_wraith> aristid: only a tiny chunk is random. most is things that are supposed to be unique, like the machine's MAC address and the current time
14:27:08 <aristid> MostAwesomeDude: the entropy of pwgen passwords isn't stellar though :)
14:27:17 <c_wraith> aristid: the main goal of a UUID is *uniqueness*, not unguessability
14:27:21 <aristid> c_wraith: i thought there are multiple kinds of UUID
14:27:39 <tgeeky_> aristid: true, but only if there are multiple kinds of universe
14:27:41 <aristid> c_wraith: one is based on MAC address and time and stuff, and another is purely random, except for the tag bits which denote the kind
14:27:45 <MostAwesomeDude> aristid: Well, ask a stupid question, etc.
14:27:45 <tgeeky_> aristid: so you have to be a string theorirst
14:27:55 <dmwit> aristid: If there are 100 kinds of UUIDs, that's less than an extra byte of entropy.
14:28:13 <aristid> dmwit: that's not at all my point
14:28:24 <aristid> my point is that only one kind of UUID works like c_wraith claims
14:28:59 <aristid> http://en.wikipedia.org/wiki/UUID#Version_4_.28random.29
14:29:32 <aristid> i think c_wraith is thinking of Version 1 UUIDs
14:29:40 <dmwit> Those allow pseudorandom strings.
14:29:57 <dmwit> Pseudorandom is kind of... not a good idea for passwords.
14:30:08 <zachk> > head.tail.reverse(cake)
14:30:09 <tgeeky_> perfect for psuedopasswords, though
14:30:10 <lambdabot>   "hnrnnoldwnnhnnwwnnwininlnaiuiiiiiownhnohnn"
14:30:25 <MostAwesomeDude> > cake
14:30:29 <lambdabot>   mueval-core: Time limit exceeded
14:30:40 <tgeeky_> > show cake
14:30:43 <lambdabot>   "[\"One 18.25 ounce package chocolate cake mix.\",\"One can prepared coconu...
14:30:45 <dmwit> > map (head . tail) (reverse cake)
14:30:47 <lambdabot>   "hnrnnoldwnnhnnwwnnwininlnaiuiiiiiownhnohnn"
14:30:48 <MostAwesomeDude> Aha.
14:30:54 <aristid> dmwit: i'm not claiming that UUIDs are good for passwords. i guess pseudorandom strings don't have a lot of "real" entropy
14:30:58 <tgeeky_> > length cake
14:31:00 <lambdabot>   42
14:31:01 <zachk> waht did ysomeon do to the cake?
14:32:02 <MostAwesomeDude> > show . reverse $ cake
14:32:04 <lambdabot>   "[\"That will deodorize and preserve putrid tissue.\",\"And it contains pro...
14:32:16 <zachk> > cake
14:32:19 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:32:20 <aristid> MostAwesomeDude: what was your thing with the stupid question btw? which question was stupid?
14:32:46 <mgsloan> tgeeky_: So, the funky rediculous thing is that zeroth seems to try to bootstrap itself
14:32:52 <mgsloan> or something along that line
14:32:53 <MostAwesomeDude> aristid: Well, he asked how to randomly generate passwords. With no further information, pwgen's probably the best answer.
14:33:16 <tgeeky_> mgsloan: yeah, but if the bootstrapping doesn't work, then ZeroTH doesn't work
14:33:20 <mgsloan> tgeeky_ I didn't see how this was useful, so I think made a best effort to remove that from my version of it
14:33:30 <aristid> MostAwesomeDude: asking how to generate passwords is not a stupid question oO
14:33:45 <tgeeky_> mgsloan: it's not useful, but if it zeroTH can't eliminate two toplevel $(..) splices, then it can't do much of anything
14:33:57 <mgsloan> fair point
14:34:15 <tgeeky_> mgsloan: it looks like the function "reattach" is broken
14:34:20 <mgsloan> tgeeky_ the problem is that it wants to do it at configure time
14:34:34 <tgeeky_> yeah, that part works for me.
14:34:37 <tgeeky_> It gets all the way through
14:34:44 <mgsloan> so it doesn't even do proper checking of packages and such
14:34:50 <tgeeky_> until it tries to expand the TH splices. It successfully expands the CPP slices!
14:35:04 <MostAwesomeDude> aristid: Do you know the saying, "Ask a stupid question and get a stupid answer?" It means that explicit context is required to get correct results.
14:35:25 <MostAwesomeDude> The question wasn't stupid, but it was very general and so a very general answer was provided.
14:35:52 <aristid> MostAwesomeDude: no i don't know the saying, and i don't like it :)
14:36:07 <MostAwesomeDude> aristid: Okay.
14:37:23 <tgeeky_> mgsloan: it is really annoying/a bit scary to have cabal clean compile and run files :O
14:42:43 <tgeeky_> mgsloan: oh. I think I know what's going on.  It used to be there was:  data Splice = IdSplice String | ParenSplice Exp ;  data Decl = ... | SpliceDecl SrcLoc Splice   ; data Exp = ... | SpliceExp Splice
14:42:52 <tgeeky_> but now, SpliceDecl has a Exp argument, instead
14:43:18 <tgeeky_> all of this internal code is expecting to get a bunch of Splices back to work with
14:43:58 <tgeeky_> which is why it partially works when you only use a toplevel splice (because that *is* a Decl, not an expression)
14:44:14 <tgeeky_> that is, it works with derive blah ''Blah, but not $(derive blah ''Blah)
14:44:33 <tgeeky_> humbug.
14:44:46 <tgeeky_> mgsloan: thanks for looking. stashing again for now.
15:23:15 <Digit> tomorrow is another day [for haskellings]  ^_^  ni ni #haskell
15:24:57 <adimit> So‚Ä¶ this is a long shot. Maybe SO would be a better place, but: I'm using HDBC-mysql and I can't seem to get autocommit to switch off (which would be very nice.) I tried global variables in my.conf, SET autocommit=0; etc. There's a note in RWH on hdbc-mysql not supporting non-autocommit on non-innoDB tables, but I *am* using innoDB tables.
15:25:18 <adimit> What I'm asking is: is there a way to disable autocommit using HDBC-mysql?
15:26:21 <hpc> my information is likely to be completely out of date, but hdbc-mysql doesn't support transactions yet
15:26:50 <hpc> perhaps
15:28:32 <adimit> hpc: but see this file: http://hackage.haskell.org/packages/archive/HDBC-mysql/0.6.6.0/doc/html/src/Database-HDBC-MySQL-Connection.html#MySQLConnectInfo (CTRL-F autocommit); it seems that hdbc is *trying* to switch off atocommit, but it doesn't seem like it's successful.
15:30:11 <adimit> it'd be pretty sad if that weren't possible, because it *really* slows down performance to use incremental commits. is there a haskell‚Üê‚ÜíMySQL binding that does support transactions?
15:30:27 <hpc> i might actually be wrong
15:30:42 <hpc> my information on that is 2 years old at this point
15:31:09 <hpc> see what the docs say
15:31:40 <hpc> or wait for someone who knows more
15:31:58 <adimit> hpc: thanks for your information anyway :-) (the docs say that it does have transaction support.)
15:32:42 <adimit> maybe I'll have to go to SO after all. But asking an SO question properly always takes time :-P
15:33:24 <hopsa> Hi. I have a lot of data manipulation to do (mostly consisting of comparing big datasets for missing/doubled information) and I have been directed to Haskell as a language to learn for the job. However, I'm not very impressed (for the moment) by the documentation available on how to use it for such work. I've hacked through some tutorials (still am), but I couldn't write a decent prototype yet. My data comes in CSV format (and potential
15:33:25 <hopsa> XLS). Am I venturin in a dead end?
15:34:19 <jfischoff> hopsa: what are you trying to do?
15:34:51 <jfischoff> read a csv file and do what with it?
15:35:05 <hopsa> jfischoff: Nothing too fancy: compare three files for missing or duplicate or corrupted data.
15:36:14 <jfischoff> just to help me understand the requirements more why would diff not work?
15:37:06 <jfischoff> as in the diff command line executable
15:37:41 <hopsa> jfischoff: because I have to write the program.
15:38:03 <hopsa> diff _could_ be used for part of the work, but the program needs to have a GUI.
15:38:47 <hopsa> I also need to sort the data.
15:40:16 <however> hopsa, you said you hacked through some tutorials -- you should be aware of lyah, which is very good. also, rwh has 1-2 chapters that deal with writing a simple csv parser
15:40:18 <however> @where lyah
15:40:19 <lambdabot> http://www.learnyouahaskell.com/
15:40:21 <however> @where rwh
15:40:21 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:40:32 <however> (both books are available free of charge)
15:40:50 <hopsa> however: I'm currently reading the first source.
15:41:01 <hopsa> haven't encountered lyah yet.
15:41:30 <pqmodn> hopsa: to understand how diff works you'll want to read http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
15:41:38 <hopsa> however: lol nevermind
15:42:47 <hopsa> So, the task I'm looking to perform is feasible in Haskell.
15:42:49 <however> hopsa, just a little warning: do not try to learn new things from the haddocks (the api documentation). you can pretty much understand it if you know it already and use it only for reference. this is different from e.g. javadocs
15:43:08 <hopsa> however: I've figured that already.... xD
15:43:25 <however> er, an "only" is missing there :-/
15:45:54 <pqmodn> hopsa: the task you're trying to perform is feasible in any language, assuming it has some sort of GUI bindings and you're familiar enough with the language
15:47:33 <hopsa> pqmodn: indeed, but I was a bit frustrated that most information I got from Google was outdated. Lots of blog posts from pre-2010 That's why I came here.
15:47:55 <jfischoff> hopsa: the gdiff package is helpful, but probably overkill http://hackage.haskell.org/packages/archive/gdiff/1.0/doc/html/Data-Generic-Diff.html
15:48:41 <jfischoff> how much data do you have?
15:49:08 <jfischoff> actually gdiff is probably a fine way to go
15:49:17 <adimit> hpc: to update your knowledge: hdbc-mysql *does* support transactions, but only on InnoDB tables, and it doesn't report a failure if you're trying to use them on a non-innodb table. Which I figured out I was doing. I believed the default was to create innodb tables, but you have to add the ENGINE=InnoDB directive to CREATE TABLE. Poo on mysql. Sorry for wasting your time :-)
15:49:22 <pqmodn> depending on what you were searching for, pre-2010 information might still be current. you're always welcome to paste a link here and ask around for more current info
15:50:23 <hopsa> jfischoff: currently about 50 MB
15:50:26 <OlegYch|h> adimit: innodb is default on mysql 5.5
15:50:39 <hpc> adimit: hardly a waste
15:51:01 <hopsa> pwmodn: I cracked when I read these: http://techguyinmidtown.com/2008/07/14/csv-parsing-haskell-versus-python/
15:51:16 <hopsa> http://techguyinmidtown.com/2008/07/15/followup-csv-parsing-in-haskell-and-python/
15:51:45 <pqmodn> jfischoff: neat. i needed something similar in Scala but ended up implementing it myself. it was a fun project anyway :]
15:51:56 <adimit> OlegYch|h: indeed. But I was using 5.1 *and* assuming it would be recent enough for the innodb default. I was wrong! Thanks for the info about 5.5; I might upgrade, if i can find .debs.
15:52:21 <pqmodn> i'll have to compare what i came up with with Data.Diff.Generic; i'm sure mine wasn't as nice of a solution
15:52:24 <hpc> adimit: debian testing has it
15:52:48 <hpc> mysql  Ver 14.14 Distrib 5.5.24, for debian-linux-gnu (i686) using readline 6.2
15:53:06 <hpc> mysqld  Ver 5.5.24-4 for debian-linux-gnu on i686 ((Debian))
15:53:10 <adimit> weird, I am on debian testing. I guess I installed the wrong package.
15:53:22 <hpc> update, perhaps?
15:53:47 <adimit> I do, religiously. I think there's probably multiple packages.
15:53:49 <adimit> yup.
15:53:50 <jfischoff> pqmodn: It is kinda a pain to setup but is very cool. Also not beginner haskell
15:54:11 <jfischoff> so maybe it was a bad recommendation, I don't know
15:55:16 <adimit> hpc: the default virtual package for mysql-server still shows 5.1 among other versions, including 5.5. Weird. I think I'm just gonna upgrade. Thanks again, OlegYch|h you :-)
15:55:37 <hopsa> jfischoff: well, I'm reading the docs... I'll see what I get out of them.
15:55:45 <hpc> adimit: hmm
15:56:06 <Clint> i imagine csv-conduit performs better
15:56:26 <hopsa> Clint: will check it out.
15:56:53 <jfischoff> hopsa: its performing a type safe diff which is very cool, and probably not as important for your problem.
15:57:12 <jfischoff> hopsa: the actually amount of code you would have to write is small.
15:58:18 <hopsa> See, I've liked Haskell from day 1 - I find it intuitive. Only problem is it's hard for a newcomer to get to work quickly - learning the syntax is not difficult, but getting to know which extensions to use etc is more complex. There seems to be too many different packages that do the same thing.
15:58:45 <hopsa> jfischoff: that's exactly why I want the program to be written in Haskell.
15:59:03 <jfischoff> hopsa: well then you are in luck :)
16:00:01 <hpc> hopsa: shameless plug, but one way to make it a wee bit easier is http://hackage.haskell.org/package/ghc-man-completion
16:00:48 <jfischoff> hopsa: are you reading the gdiff or diff doc?
16:01:43 <jfischoff> well assuming it is gdiff, the first step is parsing your data into some datatype. Then you create a some boiler plate derived from that for gdiff. I can help you with the second part.
16:02:38 <pqmodn> hopsa: reading the links, it seems he was able to read 160K lines of CSV in 7.5 seconds. you might emulate the code he wrote for paring and see how it performs. it might be just fine
16:03:27 <pqmodn> hopsa: i think one of the commenters said he profile the code and found the slow part was the sort
16:03:30 <hopsa> hpc: make what easier?
16:03:39 <hopsa> jfischoff: gdiff
16:04:04 <hpc> hopsa: the "which extensions are which" bit
16:04:25 <hpc> and similarly, which other compiler flags, like -fllvm
16:04:27 <pqmodn> hpc: i think he meant libraries (not GHC extentions)
16:04:31 <hpc> oh
16:05:10 <pqmodn> hpc: but, i'll be using ghc-man now :)
16:05:16 <hopsa> pwmodn: yeah well the fact is I thought about Python before choosing Haskell, so the post was a bit demoralising hehe
16:05:21 <pqmodn> er, ghc-man-completion rather
16:05:35 <hopsa> hpc: ok. will look at that.
16:06:14 <hopsa> pqmodn: I did, but in time I'll have a look at it.
16:07:11 <hopsa> jfischoff: what Type do you suggest? I've read that ByteString should be used for such work.
16:07:38 <hpc> i wouldn't use ByteString
16:07:42 <pqmodn> hopsa: you might also look at attoparsec, *when* you run into performance problems, but parsec is better documented in RWH and elsewhere https://github.com/bos/attoparsec
16:07:43 <hpc> semantically, CSV is text
16:07:47 <hpc> so Text
16:07:57 <hpc> it would be a wee bit slower though
16:08:05 <hpc> but still faster than String
16:08:42 <pqmodn> and if you're just picking up Haskell, i'd suggest using String anyway. rewrite it with Text/ByteString when you're more familiar with the language
16:08:58 <jfischoff> hopsa: I know very little about performance haskell, never having had any performance problems. Honestly I would worry about it. You can change it later.
16:09:15 <hpc> here's a hilarious thought:
16:09:28 <hpc> read the whole file at once and have a separate thread parse each line
16:09:32 <hopsa> jfischoff, pqmodn: sure. that would be wisest.
16:09:49 <hpc> (don't know how CSV escapes newlines, so might not work)
16:10:36 <jfischoff> hpc: I can't even imagine what would happen with all those green threads.
16:11:33 <hopsa> Thanks a lot!
16:12:34 <jfischoff> hopsa: good luck!
16:14:33 <hopsa> jfischoff: thanks. the way I feel learning Haskell is quite like learning to play the guitar. I can play "Mission Impossible" with single string notes, but I can also play it using chords - and then it sounds much better. (hope that made sense)
16:15:27 <jfischoff> hopsa: I still feel like that :)
16:19:16 * hackagebot monad-supply 0.3 - Stateful supply monad. (GeoffHulette)
16:19:23 <jfischoff> hopsa: one of the things I like about Haskell is it is the easiest way I know to apply theoretical results from the worlds of precise rational thinking, so there is always more to learn.
16:20:14 <hopsa> jfischoff: what field do you work in?
16:20:23 <hopsa> or, what do you use Haskell for?
16:20:25 <jfischoff> hopsa: iOS games
16:20:39 <jfischoff> hopsa: I manage a data pipeline for games
16:21:02 <jfischoff> with haskell (when possible)
16:21:36 <ozataman_> hopsa: note csv-conduit uses attoparsec behind the scenes
16:22:54 <coppro> jfischoff: the category theorists are probably still miffed that someone found a practical application for monads :P
16:23:30 <hopsa> jfischoff: o.O
16:23:44 <jfischoff> coppro: hehe
16:23:48 <hopsa> ozataman_: what's the difference between attoparsec and parsec?
16:24:05 <ozataman_> hopsa: attoparsec can parse an incremental stream
16:24:25 <ozataman_> parsec won't return until the whole parsing has been completed (or stream exhausted)
16:24:26 <ion> Parsec has better error messages.
16:25:17 <ozataman_> you couldn't use parsec to do constant-space CSV processing - unless you separately chunk on newlines and repeatedly call parsec
16:25:30 <ion> IIRC Trifecta has incremental parsing *and* good error messages.
16:25:58 <jfischoff> ozataman_: Lazy IO won't help there?
16:26:00 <ozataman_> never had the chance to use it, but I bet it's pretty good given it's author :)
16:26:33 <hopsa> ok
16:26:35 <ozataman_> jfischoff: has nothing to do with lazy IO. parsec simply won't return until it has exhausted its input or its parsing is done
16:27:01 <jfischoff> good to know
16:29:37 <hopsa> ozataman_: currently installing your package. Thanks.
16:34:38 <otters> @pl \a b -> if a == b then Just b else Nothing
16:34:38 <lambdabot> flip flip Nothing . (`ap` Just) . (if' .) . (==)
16:34:53 <otters> well jeez, that seems excessive
16:36:26 <Peaker> @type flip flip
16:36:28 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
16:36:39 <Peaker> damn Caleskell :(
16:37:04 <c_wraith> :t flip Prelude.flip
16:37:05 <lambdabot> forall a a1 c. a1 -> (a -> a1 -> c) -> a -> c
16:37:17 <hopsa> got to go. Thanks all.
16:37:17 <jmcarthur> @pl \x y -> bool (Just y) Nothing (x == y)
16:37:17 <lambdabot> ap (flip bool Nothing . Just) . (==)
16:37:23 <hopsa> :quit
16:37:29 <jmcarthur> @pl \y -> bool (Just y) Nothing (x == y)
16:37:29 <lambdabot> ap (flip bool Nothing . Just) (x ==)
16:37:33 <jmcarthur> meh
17:00:33 <mk12> is it expensive to pass around million-element lists? I'm talking about the argument passing, not the inefficiency of lists
17:00:48 <c_wraith> it's just copying one pointer
17:01:15 <mk12> as in would it be significantly more expensive to pass a huge list to a function which converts it to a byte string, rather than doing the conversion itself in the function?
17:01:25 <mk12> c_wraith: Ok, that's what I was hoping
17:01:27 <c_wraith> no difference
17:01:30 <mauke> you have a weird mental model
17:02:01 <aristid> mauke: maybe the mental model is "call by value by means of copying everything", like c++?
17:03:27 <mk12> mauke: I just have no idea what kind of optimizations ghc makes, and i didn't have a clear idea about how parameters are passed either
17:03:39 <mauke> no optimizations are involved
17:04:20 <mk12> what if it was passed to two functions and they both modify it? I guess it decides to make a copy then?
17:04:32 <c_wraith> fortunately, you don't actually modify values in haskell
17:04:39 <mauke> mk12: you can't modify in haskell
17:04:43 <c_wraith> prevents entire classes of problems
17:05:01 <mk12> well create a new list based on the old one is what I meant
17:05:11 <c_wraith> but it doesn't modify the old list.
17:05:20 <c_wraith> The old one is still perfectly intact for anything referring to it
17:05:22 <mk12> actually yeah that is kind of obvious I guess.. I should have though t about it a bit mroe
17:05:23 <shachaf> mauke: Copying pointers is an optimization on copying entire values. :-)
17:05:35 <mk12> *more
17:05:39 <mauke> shachaf: the entire value is a pointer
17:05:59 <mauke> you can't struct foo { int x; struct foo y; }; in C
17:06:35 <mauke> ^ that would be expensive to pass by value but its size would also be infinite
17:56:16 <agam> Hi, I'm trying to install taffybar, I got its dependencies, I ran 'cabal install gtk2hs-buildtools', and got an error:cabal: The program alex is required but it could not be found. Then I ran 'cabal install alex' and saw ghc: unrecognised flags: -rtsopts
17:56:38 <agam> What does this ghc error mean ?
17:57:14 <EvanR1> if i have a Map ThingId Thing, should i put the corresponding ThingId in the Thing data structure
17:58:27 <Veinor> agam: what version of ghc are you using?
17:58:39 <Veinor> iirc --rts-opts was introduced in 7.0
17:58:48 <EvanR1> is Text more appropriate when expecting to be going back and forth to ByteString than String is ?
17:58:54 <agam> ghc -V
17:58:55 <agam> The Glorious Glasgow Haskell Compilation System, version 6.12.1
17:58:59 <Veinor> yeah
17:59:16 <Veinor> --rts-opts was introduced in 7.0 to fix some security stuff
17:59:57 <Veinor> try installing alex-2.3.5; or, if you can, install ghc 7.4
17:59:59 <agam> hmm got it ... so ubuntu has an older version, and I should get a ghc version built from source to build these cabal packages, correct ?
18:00:27 <hpc> or a binary
18:01:20 <Veinor> or the haskell platform ubuntu repository
18:02:21 <agam> thanks!
18:03:27 <EvanR1> hmmmm acid state without template haskell seems rather gnarly
18:03:30 <EvanR1> :(
18:06:53 <donri> EvanR1: oh? not that bad, i don't think
18:07:19 <EvanR1> every different query or update to the state needs a new datatype?
18:07:50 <Atticusmas> Hey, I'm an aspiring programmer. Is this a good language to start with?
18:07:55 <mauke> sure
18:08:29 <Rotaerk> Atticusmas, just prepare to be disappointed when you move away from this language to others
18:08:42 <donri> EvanR1: which is why we use TH :)
18:09:07 <Atticusmas> Eh, I know some JS and Java but not very much at all
18:09:20 <donri> it's certainly boilerplate, but my point is that it's not some deep, dark incomprehensible magic
18:09:51 <EvanR1> yeah
18:10:00 <EvanR1> i just wish there were a way with just the language
18:10:18 <EvanR1> i mean, a macro which produces source is somehow like a function
18:10:22 <donri> agreed
18:10:47 <EvanR1> im always confused why a macro system ontop of a functional language needs to exist
18:11:11 <donri> it should never be needed, it's just convenient
18:11:34 <mauke> because functions are limited to values
18:11:35 <EvanR1> i mean why the same convenience can be the effect of just the languages functional support
18:12:35 <EvanR1> code cant be a value? xD
18:12:59 <mauke> if it can, you're probably looking at a macro system
18:14:13 <donri> EvanR1: it would be easy to have acid-state without TH and little boilerplate, but it would probably not be as type safe
18:14:25 <donri> it's a trade-off
18:14:37 <EvanR1> whats the role of type families in acid state
18:14:49 <EvanR1> i think i dont really understand the haskell code for the NoTH version
18:14:52 <EvanR1> of hello world
18:15:15 <EvanR1> instance IsAcidic is using type families?
18:15:27 <donri> type families are used so you can't for example query a handle with an event not supported for that state
18:16:16 <EvanR1> uhm whats a handle and an event in acidstate context/
18:16:27 <donri> the type families are in the Method class i think
18:16:39 <donri> handle as in what you got with openLocalState or whatever
18:16:48 <donri> the AcidState type
18:16:49 <EvanR1> ok
18:18:03 <EvanR1> i see instances of SafeCopy all over the place
18:18:16 <EvanR1> what does SafeCopy mean
18:19:06 <donri> it's an extension to cereal, used for data [de]serialization, adding version migrations to that so you can change the definition of stored types and have it work on live servers
18:19:35 <EvanR1> ah
18:20:01 <EvanR1> seems like putCopy getCopy are all the same?
18:20:21 <EvanR1> contain $ return something or contain $ safePut/Get something
18:21:09 <donri> yes, since instances are provided for a lot of existing types, so if your type is just wrapping other types ...
18:22:34 <EvanR1> since im expecting a pretty mean state datatype and lots of query/updates, im leaning toward TH
18:23:13 <sinelaw> Peaker, night shift?
18:23:16 <sinelaw> ;)
18:23:19 <EvanR1> how does safecopy work? i just recompile and my loaded state will 'just work' ? or do i need to go through a migration step
18:24:05 <donri> if you change types and have a live server deployed with the old version stored, you can leverage safecopy to make the transition easier
18:24:25 <donri> but it's not completely automatic
18:24:33 <EvanR1> hmm
18:24:34 <donri> see http://hackage.haskell.org/packages/archive/safecopy/0.6.1/doc/html/Data-SafeCopy.html
18:25:40 <donri> you can generate SafeCopy instances with TH, but not Migrate instances
18:25:50 * EvanR1 remembers using python pickle and thinking it was so great
18:26:05 <donri> pickle is great until it's not ;)
18:26:07 <EvanR1> not sure how it would stand up against this changing database schema thing
18:26:09 <sinelaw> ya me too
18:28:14 <donri> EvanR1: if you just want pickle, you could use binary or cereal directly.
18:29:12 <dmwit> Who has a good intro to using equality constraints?
18:29:13 <donri> but, that'll be a pain once you run into the need to migrate data, and you'll either get no acid properties or would need to ensure them yourself ;)
18:29:35 <EvanR1> no i want acid
18:29:45 <EvanR1> but then i realize im going to want to append new kinds of data
18:29:50 <EvanR1> later
18:29:57 * EvanR1 doesnt delete
18:30:22 <donri> zodb provides the acid for pickle, but not the migrations... sometimes a changed type will "just work" with zodb but then again sometimes it won't and you can't even tell the two versions apart. :p
18:30:56 <EvanR1> maybe i need to learn cereal first
18:30:59 <EvanR1> then safecopy
18:31:02 <EvanR1> then acidstate
18:31:06 <donri> doesn't hurt, but isn't required
18:31:07 <EvanR1> bahh
18:31:39 <donri> if you just accept TH into your heart as your lord and savior, acid-state is really easy to use :)
18:32:14 <EvanR1> do i need to worry about safecopy instances for all the types nested in my main state type
18:32:23 <EvanR1> if i edit the schema later
18:34:19 <donri> EvanR1: no, that's sort of the point to safecopy. the migrations are "recursive", so to speak
18:34:55 <EvanR1> does deriving (SafeCopy) work ;)
18:35:09 <donri> the version is stored with the data, so it can transparently read any version
18:35:21 <donri> that works for newtypes with -XGeneralizedNewtypeDeriving
18:35:22 <EvanR1> i guess i dont need to worry about that, just the instance for the main type
18:35:38 <donri> you do see there's TH for it though?
18:35:43 <EvanR1> yes
18:35:46 <donri> deriveSafeCopy
18:36:06 <EvanR1> probably the first time ever i dont want to look at the code for something ;)
18:36:12 <EvanR1> in haskell at least
18:37:07 <donri> do you mean for the TH or the libraries in general?
18:37:29 <EvanR1> deriveSafeCopy
18:38:41 <sinelaw> why is it Data.Text "better" than String?
18:38:45 <Veinor> more efficient
18:38:46 <donri> can always use -ddump-splices to see what it generates for you
18:38:51 <donri> or ghc-mod in vim or emacs
18:39:29 <EvanR1> so question about data structure... if i have a Map of Zones, and rooms have exactly one zone, should i just have the Zone in the room record because they will all share the common zone?
18:40:02 <EvanR1> so i dont need to have a god awful zone id?
18:40:24 <donri> sinelaw: it is "packed", internally stored as a coherent bytestring (in utf16), whereas with String each Char is separate. so text is more space and time efficient
18:40:54 <sinelaw> how is String stored? as a list?
18:40:54 <donri> sinelaw: (that's the TLDR and the AFAIU version)
18:41:00 <donri> yep
18:41:03 <sinelaw> i see
18:41:04 <donri> type String = [Char]
18:41:04 <sinelaw> why?
18:41:08 <sinelaw> oh
18:41:22 <donri> it's also problematic because it means String isn't a distinct type
18:41:32 <donri> so you need ugly hacks for things like Show
18:41:44 <Veinor> EvanR1: you could do that
18:41:48 <donri> to not show a string as ['a','b','c']
18:42:02 <sinelaw> donri, i see
18:42:08 <EvanR1> Veinor: i was hoping someone was going to say that
18:42:08 <mauke> it's a fairly harmless hack, though
18:42:13 <sinelaw> donri, thanks
18:42:49 <donri> EvanR1: don't quite understand the question
18:43:21 <EvanR1> if it were a sql database for example, querying a rooms zone would involve a join and a zone id
18:43:38 <EvanR1> but (zone r) would be nicer
18:43:42 <donri> EvanR1: you could use ixset or somesuch
18:43:58 <EvanR1> i looked at ixset before
18:44:03 <EvanR1> its kind of limiting
18:44:09 <EvanR1> like no joins
18:44:35 <donri> not sure what you need joins for
18:44:38 <donri> just define the indices you need?
18:44:47 <EvanR1> if i had rooms and zones in separate sets for example
18:45:35 <donri> i usually have an ixset somewhere at the top, and data structures like Map and Set inside it, then i can define indices on deep structures contained within the ixset
18:46:01 <EvanR1> hmm
18:46:52 <EvanR1> youre right i might need to search
18:47:18 <EvanR1> i hope ixset isnt as hard to set up as acidstate ;)
18:48:06 <donri> ixset is easy in part because it lacks type safety :P
18:49:06 <EvanR1> blaw
18:50:39 <donri> HiggsSet is more type safe, but has some oddities to its API and no TH to hide it
18:50:59 <EvanR1> is there a type for like fixed size vector
18:51:11 <EvanR1> Char(40) ;)
18:51:33 <donri> tuples? :)
18:51:43 <EvanR1> would 40 even work
18:51:45 <donri> there is a vector package, it might provide that
18:51:57 <donri> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
18:51:58 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
18:51:58 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109
18:51:59 <lambdabot> t110 t111 t112 t113 t114 t115 t116 t117 t118 t119 t120 t121 t122 t123 t124 t125 t126 t127 t128 t129 t130 t131 t132 t133 t134 t135 t136 t137 t138 t139 t140 t141 t142 t143 t144 t145 t146 t147 t148
18:51:59 <lambdabot> t149 t150 t151 t152 t153 t154 t155 t156 t157 t158 t159 t160 t161 t162 t163 t164 t165 t166 t167 t168 t169 t170 t171 t172 t173 t174 t175 t176. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -
18:51:59 <lambdabot> > m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 ->
18:52:00 <lambdabot> [10 @more lines]
18:52:01 <donri> oh dear
18:52:15 <shachaf> thonri
18:52:23 <mauke> ... t28?
18:52:35 <donri> yea ok that was ... abit... excessive
18:52:36 <EvanR1> lol
18:52:41 <Veinor> mauke: ... you're right, that's weird
18:52:50 <donri> it looked smaller in my proportional font input box!
18:52:52 <shachaf> mauke: Perhaps t1 is the type of the whole thing, or something.
18:52:52 <Veinor> i'd expect t27
18:53:04 <Veinor> oh that makes sense
18:53:14 <EvanR1> t1000
18:55:47 <EvanR1> well i just want a vector of bytes
18:55:52 <EvanR1> so ByteString will work
18:56:07 <mauke> donri: bonus points if you can make :t time out
18:56:17 <tgeeky_> hehe
18:57:18 <donri> :t let f = f in f
18:57:19 <lambdabot> forall t. t
18:57:34 <Jafet> :t let f x = (x, x) in f$f$f$f$f$f$f$f$f$f$f undefined
18:57:36 <lambdabot> forall a. (((((((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a,
18:57:36 <lambdabot>  a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
18:57:36 <lambdabot> a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a,
18:57:36 <lambdabot> a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))), (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
18:57:36 <lambdabot>  a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), (
18:57:38 <lambdabot> [47 @more lines]
18:58:01 <rofer> Is the best way to get lambdabot directly from the darcs repo?
18:58:16 <tgeeky_> rofer: there is no easy way, and that's probably best yes
18:58:20 <Jafet> I think the best way is from irc.
18:58:25 <donri> :t let f x = f in f
18:58:26 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
18:58:26 <lambdabot>     Probable cause: `f' is applied to too few arguments
18:58:26 <lambdabot>     In the expression: f
18:59:06 <Veinor> :t let f x = (x, x, x); g x = f $ f $ f x in g $ g $ g $ g $ g $ g $ g $ g $ g undefined
18:59:15 <Veinor> oh no
18:59:16 <rofer> tgeeky_: Getting it from darcs can't be too bad though, right?
18:59:18 <Veinor> oh noooooooooo
18:59:30 <Veinor> > 1 + 1
18:59:38 <EvanR1> maybe instead of mobs in rooms, items in rooms/mobs/items, rooms in zones, etc i want a generic containment graph structure with fancy searching
18:59:41 <tgeeky_> rofer: I haven't done it lately
18:59:48 <lambdabot> thread killed
18:59:51 <Veinor> whew
19:00:12 <Veinor> @botsnack
19:01:15 <EvanR1> zipper...
19:01:16 <lambdabot>   thread killed
19:01:17 <lambdabot> :)
19:01:39 <Veinor> > 1 + 1
19:01:49 <EvanR1> you broke it
19:01:51 <Veinor> :(
19:02:00 <mauke> @localtime
19:02:02 <sinelaw>   thread killed
19:02:12 <Veinor> sinelaw: tease
19:02:27 <sinelaw> :)
19:03:08 <MostAwesomeDude> @src map
19:03:12 <MostAwesomeDude> :c
19:03:16 <Veinor> i'm sorry ;_;
19:04:05 <Veinor> @botsnack
19:06:58 <Veinor> oh nooooo
19:07:35 <EvanR1> ... can monadic values be serialized
19:07:47 <Veinor> sure
19:07:54 <Veinor> > show (return 2 :: [Int])
19:07:58 <Veinor> ... oh
19:08:12 <EvanR1> ah
19:08:15 <Veinor> Prelude> show (return 2 :: [Int])
19:08:18 <Veinor> "[2]"
19:08:18 <EvanR1> youre so right
19:08:21 <sinelaw> He's dead, Jim
19:09:44 <EvanR1> im guessing if my data makes use of sharing i will not get that sharing in a serialized form
19:10:04 <EvanR1> and it wont be shared when i deserialize
19:10:13 <Veinor> not unless you make the sharing observable
19:10:23 <Veinor> http://ittc.ku.edu/~andygill/papers/reifyGraph.pdf
19:12:22 <Veinor> or you can use stablenames or something
19:12:39 <EvanR1> blahhh since i started haskell i realized how many things we take for granted really deserves a friggin research paper
19:13:39 <Veinor> i mean
19:14:28 <EvanR1> stable names frightens me
19:14:43 <Veinor> do the things you're serializing have some sensible way to do equality testing and hashing?
19:14:54 <EvanR1> yeah
19:14:57 <EvanR1> no functions
19:15:37 <Veinor> and i assume you want to serialize a list of these things?
19:15:43 <EvanR1> im thinking of a monad for writing simple AI for mobs
19:16:04 <EvanR1> continuation or something
19:16:06 <Veinor> you can always use HashMap or something
19:16:30 <EvanR1> so i was going to nest the things into things
19:16:34 <Veinor> ah
19:16:39 <EvanR1> and serialize the map or collection of those
19:16:46 <Veinor> sharing is difficult in general
19:16:54 <Veinor> like, this isn't a haskell-specific problem
19:17:11 <Veinor> the first question is: do you actually need sharing?
19:17:15 <EvanR1> no
19:17:19 <EvanR1> its a space optimization
19:17:24 <Veinor> well
19:17:31 <Veinor> are you prematurely optimizing, in that case?
19:17:33 <EvanR1> except for infinite data
19:17:42 <EvanR1> which im not expecting to deal with
19:17:52 <EvanR1> yeah its premature
19:17:58 <Veinor> so don't worry about it, imo
19:27:28 <mk12> If i am rendering a several-million-pixel image, would rendering directly to a [Colour] intermediately before converting to ByteString defeat the purpose of using ByteString, efficiency-wise?
19:28:35 <EvanR1> sometimes using [] results in a loop-like behavior than an actual data structure being generated
19:28:45 <EvanR1> rather than
19:29:00 <mk12> oh, because of laziness
19:30:58 <donri> mk12: repa might be better
19:31:26 <EvanR1> mk12: and such an effect would probably be already written for you in the various folds and iterators provided by bytestring?
19:32:04 <mk12> donri: never heard of that, what is repa?
19:32:38 <shachaf> Cale: lambdabot :-(
19:32:45 <mk12> EvanR1: Maybe, I was going to use Data.Binary but now I think I'm going to use blaze-builder
19:33:16 <mk12> Or maybe the plain lazy ByteString module is enough for this, I don't know
19:33:49 <mk12> I posted a question on stack overflow http://stackoverflow.com/questions/11512313/bytestrings-in-haskell-should-i-use-put-or-builder , and a couple of people suggested blaze-builder
19:34:55 <donri> mk12: a package
19:35:10 <donri> http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial
19:35:40 <mrotondo> is there a way to get the left identity of an arbitrary type? I'm folding a list of tuples and all I know is that the second element will be a Rational, so I want to accumulate the Rational while ignoring the first value in the tuples, but I need an initial value for my accumulator
19:35:59 <shachaf> mrotondo: Left identity of a type? What does that mean?
19:36:17 <shachaf> An identity is a thing that an operation/function has, not a type.
19:36:37 <mrotondo> from the prelude definition of foldl (sorry if I'm mis-using terms): foldl, applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right
19:36:44 <mrotondo> sorry, that's right
19:36:55 <mrotondo> I just want an unused value of some type
19:37:00 <shachaf> You should most likely use foldl', by the way, not foldl.
19:37:11 <shachaf> Types don't have "unused values". Maybe you're looking for Maybe?
19:37:36 <shachaf> I think you'd be best off saying what you're actually trying to do. :-)
19:39:29 <EvanR1> question about ixset, do i need to recalculate the index every time i update the ixset
19:39:37 <EvanR1> or is it automatic and or incremental
19:40:25 <mrotondo> I'm trying to fold over a [(a, Rational)], such that the accumulator gets the a from each tuple (I don't care about that value, so I just plug each one in as I get it), and adds together the Rationals. I just need a starting value for the accumulator
19:40:53 <tgeeky_> mrotondo: !
19:41:02 <tgeeky_> oh. I misread that horribly. nevermind.
19:41:07 <mrotondo> haha, thanks though
19:41:23 <mrotondo> something like this: Prelude.foldl (\(_, pAccum) (x, p) -> (x, pAccum + p)) (<unused value here>, 0%1) xs
19:41:23 <mauke> mrotondo: I don't understand "so I just plug each one in as I get it"
19:41:29 <tgeeky_> mrotondo: typically, one chooses something that one knows isn't going to be there normally
19:41:44 <mauke> mrotondo: sum . map snd
19:41:53 <mrotondo> ah makes sense
19:42:05 <mrotondo> thanks!
19:42:36 <shachaf> Also, foldl' (\s (_,x) -> s + x)
19:42:48 <shachaf> (And 0 as the identity.)
19:42:58 <mauke> :t foldl' (\s (_,x) -> s + x) 0
19:43:07 * tgeeky_ makes mauke a sandwhich
19:43:14 * tgeeky_ takes back the empty plate
19:43:28 * tgeeky_ solves world peace
19:43:31 <daniel_-> GAH, i need some way for my app to communicate between spawned processes and i have no idea how to do it in a good way? i guess i would like to use the type system as much as i want. Should i just make read/show instances of the types i send over the pipes?
19:43:42 <shachaf> @ty foldl' (\s (_,x) -> s + x) 0
19:43:45 <kappabot> forall a t. Num a => [(t, a)] -> a
19:44:05 <geekosaur> Binary might be preferable
19:44:18 <sinelaw> does anyone know how to debug yesod routing issues?
19:44:20 <geekosaur> (either the binary or cereal pacakeg)
19:45:01 <daniel_-> thanks, felt that i just needed a general direction to look at
19:45:03 <Veinor> shachaf: ty
19:45:05 * BMeph sighs; so many "premature ejaculations" lately... :/
19:45:21 <mauke> > x
19:45:25 <kappabot>   x
19:46:03 <edwardk> o.O
19:46:40 <kappabot> hedwardk
19:46:47 <edwardk> happabot
19:46:59 <MostAwesomeDude> I miss lambdabot. :c
19:47:33 <BMeph> edwardk: As in, "X-Y" problems galore. Not...um...hmm, I should have probably used a different word for that. :)
19:48:10 <BMeph> edwardk: Unless you were boggling over something else, then never mind.
19:48:14 <edwardk> =)
19:48:28 <edwardk> nah it was the obvious cheap shot
19:51:34 <sinelaw> edwardk, hi, long time
19:51:44 <edwardk> how goes?
19:51:49 <sinelaw> great
19:51:52 <edwardk> been a busy couple of weeks
19:52:06 <sinelaw> busy couple of quarters for me
19:53:46 <sinelaw> edwardk, did you see the "paper" app (by '53') for iPad?
19:53:56 <edwardk> "paper"?
19:54:16 <Nevin> a drawing app
19:54:21 <sinelaw> right
19:54:44 <edwardk> installing it now, my wife will probably play with it
19:54:51 <sinelaw> edwardk, i was wondering what sort of curve smoothing they're using there. looks like standard bezier
19:54:57 <edwardk> she uses the sketchbook one fairly regularly
19:55:10 <edwardk> then it probably is =)
19:55:42 <sinelaw> i've been trying to emulate the nice curves they draw to no avail
19:56:33 <edwardk> not getting nice second derivatives?
19:57:16 <Nereid> I'm reading about pipes now
19:57:18 <Nereid> I like what I see :o
19:58:05 <sinelaw> edwardk, i don't know really
19:58:44 <Nereid> it turns me on a little actually
19:59:21 <sinelaw> uh oh
19:59:40 <sinelaw> Nereid, maybe you can discuss it with BMeph then
19:59:47 <edwardk> they seem to have a nice brush weight model
20:00:07 <EvanR1> why is the method for Indexable called empty >_<
20:00:27 <sinelaw> edwardk, i was thinking weight = log(speed)
20:00:31 <sinelaw> or something like that
20:00:41 <edwardk> its probably a bit scarier than that =)
20:01:34 <sinelaw> edwardk, sure, i meant O(log(speed))
20:01:54 <EvanR1> shouldnt it be called singleton or something
20:01:57 <sinelaw> or something of the sort
20:03:20 <edwardk> start here: http://nis-lab.is.s.u-tokyo.ac.jp/nis/cdrom/brush.pdf
20:03:32 <EvanR1> and the types in ixset are not helping :(
20:03:39 <EvanR1> everything is a -> b
20:05:40 <edwardk> anyways that is a fairly ancient paper so you probably want to move to a nicer curve type, but it'd get you started
20:06:18 <sinelaw> edwardk, also, it involves "reading"
20:06:22 <tgeeky_> heh
20:06:30 <edwardk> its good for you ;)
20:06:46 <edwardk> like broccoli
20:06:51 <tgeeky_> edwardk: can you take a look at uhhh... the slide labeled "the (linear) CoSpan (bi-) category" in here: http://www.cs.le.ac.uk/people/pt95/leicester2009.pdf
20:07:06 <sinelaw> tgeeky, you should be ashamed of yourself
20:07:24 <sinelaw> edwardk, thanks though! I will definitely look
20:07:28 <tgeeky_> and let me know what kind of categorical things I'd need to write this signature in haskell
20:07:31 <sinelaw> and read
20:07:42 <edwardk> tgeeky_: reaction shot: http://www.youtube.com/watch?v=Ccoj5lhLmSQ
20:07:57 <tgeeky_> (the composition one) ... and also, isn't there a pullback centered on B (in addition to the pushout, centered on C?) there?
20:08:16 <tgeeky_> edwardk: yeah, me too, i'm at that stage :O
20:09:08 <edwardk> i've got nothing so far
20:09:23 <edwardk> i'd need to rewind too much to get context to be much use here
20:09:42 <tgeeky_> do you recognize the arrows that look like they have butts on them?
20:10:31 <tgeeky_> A >--> B <-- C >--> D --> E
20:10:52 <coppro> tgeeky_: monomorphism
20:11:04 <coppro> (epimorphisms have double heads)
20:11:06 <tgeeky_> edwardk: I was just proud to have what I assume is a full-on math paper talking about kleisi categories
20:14:07 <edwardk> i'm so used to mono being that hook arrow from short exact sequences
20:14:31 <tgeeky_> edwardk: i actually thought this diagram was a short exact sequence when I saw it
20:15:41 <coppro> edwardk: apparently awodey uses the hooked arrow for insertion map
20:15:48 <edwardk> ah
20:16:25 <tgeeky_> i have his book. I wonder if there's an encyclopedia of category theory diagrams somewherees
20:16:30 <edwardk> http://math.stackexchange.com/questions/20015/special-arrows-for-notation-of-morphisms talks a bit about various arrow notations
20:16:31 <coppro> there really should be
20:16:32 <tgeeky_> really just the arrows
20:16:43 <coppro> tgeeky_: it would be good to have a handy reference for various properties
20:17:02 <coppro> e.g. "an equalizer given f and g is Q and q with u universal"
20:17:06 <tgeeky_> there is a great reference for monodial categories specifically, but this is evidently more general (gs-monodial)
20:19:27 * hackagebot biofasta 0.0.2 - Library for reading fasta sequence files (DanFornika)
20:27:20 <Onionnion> how does something like [3,2,1] > [2,10,100] return True ?
20:27:38 <Onionnion> if just the first element is bigger it's True?
20:27:44 <shachaf> There's an instance Ord a => Ord [a]
20:27:56 <shachaf> I would guess that yes. And then if they're the same, the second element, and so on.
20:28:05 <shachaf> But you can look it up if you want to know. :-)
20:28:18 <Onionnion> ah, so it compares each element until there's a difference?
20:28:31 <shachaf> I have no idea.
20:28:36 <shachaf> You should look it up.
20:28:42 <Onionnion> lol
20:28:48 <shachaf> It's probably specified in the report.
20:28:55 <shachaf> No, I'm serious.
20:29:24 <daniel_-> anyone know where i can find http://darcs.haskell.org/binary/tools/derive/BinaryDerive.hs
20:29:52 <shachaf> Right there?
20:29:58 <daniel_-> 404
20:29:59 <shachaf> Are you looking for a Hackage link, or what?
20:30:02 <shachaf> Oh.
20:30:02 <daniel_-> yeeeeeee
20:30:07 <shachaf> @google hackage binary derive
20:30:09 <kappabot> http://hackage.haskell.org/package/binary-derive
20:30:09 <kappabot> Title: HackageDB: binary-derive-0.1.0
20:30:31 <kallisti> using haskell-mode, and the autosave causes horrible freezing lasting multiple seconds.
20:30:34 <kallisti> anyone else experience this?
20:31:38 <hpaste> ‚ÄúJoey Adams‚Äù pasted ‚ÄúThe Ord [a] instance from ghc-prim‚Äù at http://hpaste.org/71617
20:32:22 <shachaf> JoeyA: I was hoping to be helpful in the "teach a person to figure things out" sort of way.
20:32:28 <Nereid> oh man, frames. this gets better and better
20:32:37 <JoeyA> shachaf: Ah, okay.
20:32:38 <shachaf> Also, the ghc-prim implementation is not a guarantee. If you want guarantees you'll have to look to the report. :-)
20:33:22 <Nereid> I should take the time to understand indexed monads/etc. one day.
20:33:58 <JoeyA> shachaf: How is it not a guarantee?
20:34:17 <Nereid> er, indexed types
20:35:10 <JoeyA> Ever since the Eq/Show/Num split-up in GHC, I'm not eager to think of the Haskell 2010 report as the most reliable source.
20:35:11 <shachaf> JoeyA: Because maybe you'll be using another implementation?
20:35:23 <JoeyA> (for those primarily using GHC)
20:58:08 <xvilka> hi! I remember that i've seen page on haskell site about writing modules in C, but can't find it (google return mostly calling haskell from C). Found also c2hs utility - is it still can produce valid code (looks like development stalled)?
20:58:38 <shachaf> Writing modules in C?
20:58:43 <shachaf> As in, calling C code from Haskell?
20:58:43 <xvilka> yes
20:59:25 <xvilka> or may be some ffi library more usable here?
20:59:39 <shachaf> FFI is pretty easy in Haskell.
20:59:46 <shachaf> @google ghc ffi
20:59:47 <kappabot> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI
20:59:48 <kappabot> Title: GHC/Using the FFI - HaskellWiki
21:00:14 <shachaf> Just look for anything that says "foreign import".
21:00:21 <xvilka> shachaf: thx!
21:01:28 <kallisti> @hoogle Show x => x -> Text
21:01:28 <kappabot> A Hoogle error occurred.
21:01:36 <kallisti> gasp
21:01:50 <shachaf> kallisti: No, I'm not going to install Hoogle.
21:03:02 <ion> xvilka: I‚Äôve found bindings-DSL awesome with FFI.
21:04:29 * hackagebot biophd 0.0.4 - Library for reading phd sequence files (DanFornika)
21:05:36 <kallisti> shachaf: where's lambdabot?
21:05:42 <shachaf> kallisti: Ask Cale.
21:05:58 <shachaf> When lambdabot comes back, someone should @quit kappabot
21:06:02 <shachaf> @admin + Cale
21:20:07 <Nereid> I wonder, are there any ideas/proposals about something like
21:20:17 <Nereid> typeclasses which are polymorphic in the *kind* of a type?
21:21:11 <c_wraith> yes
21:21:22 <c_wraith> .. sort of, anyway
21:21:29 <Veinor> like what?
21:21:30 <Nereid> like, for any kinds k1 and k2, there ought to be a way to have a single class declaration for functors f :: k1 -> k2
21:21:38 <Nereid> k1 = k2 = * would be a regular Functor, etc
21:21:59 <c_wraith> There's the PolyKinds extension in ghc 7.4
21:22:11 <c_wraith> But it's still limited by the fact that values have the kind *
21:22:32 <c_wraith> well.  values have types with kind *
21:22:44 <Nereid> but it makes just as much sense to have, say, functors * -> (* -> *) or (* ->*) -> (* -> *), for instance.
21:22:59 <c_wraith> well, not really
21:23:19 <Nereid> why not?
21:23:51 <c_wraith> because values (you know, the things passed to and returned from functions) must have types with kind *
21:23:59 <dolio> UHC has kind polymorphism, too.
21:24:04 <Nereid> but
21:24:14 <Nereid> replace "function" with "natural transformation" then.
21:25:51 <Nereid> if I had two types X, Y :: * -> *, then f :: X -> Y would mean f :: forall a. X a -> Y a
21:26:49 <twb> Is jgm / John MacFarlane around?  I just got a bounce email from Berkely to an email I wrote in Mar 2011, which seems to indicate that his/berkeley's mail system is buggered
21:26:53 <Nereid> I better go, though.
21:27:19 <twb> (I don't care about my mail anymore, but maybe he is missing more important emails too)
21:27:21 <Clint> impressive
21:32:04 <optimight> How in haskell we store relationship between two entities?
21:33:42 <optimight> In haskell, how do we store relationship between two entities?
21:34:39 <shachaf> optimight: That's more grammatical, but I still doubt anyone has any idea what your question means. :-)
21:35:14 <tgeeky_> if you mean "relation", like, binary relation, then the package "relation" will suffice
21:35:58 <shachaf> tgeeky_: And maybe a two-argument funciton will also suffice!
21:36:02 <shachaf> We have no idea.
21:36:03 <optimight> shachaf: I wanted to set a relation of person type as father and son
21:36:24 <shachaf> Or maybe a database package will suffice.
21:36:29 <tgeeky_> hehe
21:37:31 <optimight> tgeeky: I come from Object Oriented Paradigm and learning Functional Programming Paradigm
21:38:03 <optimight> @hoogle database
21:38:04 <kappabot> A Hoogle error occurred.
21:38:07 <shachaf> The eternal question, "what are you actually trying to do?", might be relevant here.
21:41:17 <optimight> shachaf: I will try to explain.    In my application there are N persons, they have relationship between them  - like father-son, mother-son, daughter-father etc....    I think, creating a tuple for each relationship will be the solution - e.g. (Person A, Person B, Father-son)
21:41:58 <optimight> Is it correct or is there any better way?
21:42:20 <shachaf> I still don't know what you're trying to do, unfortunately. :-)
21:42:34 <shachaf> Maybe someone else in here will.
21:42:47 <Iceland_jack> You could possibly use maps?
21:43:06 <optimight> shachaf: Okay...   I will rephrase my question and ask later
21:43:07 <shachaf> optimight: I think the answer to whatever question you're asking is going to be way higher-level than that, though.
21:44:01 <optimight> shachaf: yes ..  I expect some higher-level philoshopy or strategy
21:44:13 <Iceland_jack> optimight: in Python syntax, are you looking for something like: father['John'] = ['Roger', 'Alice'] ?
21:44:34 <shachaf> optimight: But for that you might have to ask a higher-level question.
21:45:00 <Iceland_jack> It sounds like you're looking for something similar to logic programming like Prolog or Core.Logic in Clojure though
21:45:06 <Iceland_jack> *closer
21:45:09 <optimight> Iceland_jack: yes, map can be an alternative
21:45:56 <Iceland_jack> http://stackoverflow.com/questions/9712530/clojure-core-logic-minikanren this looks similar to what you're asking about
21:46:34 <optimight> shachaf: yes
21:46:41 <Iceland_jack> Or rather this: http://objectcommando.com/blog/2011/11/04/the-magical-island-of-kanren-core-logic-intro-part-1/ I'm not sure whether there is a similar module in Haskell
21:47:15 <Iceland_jack> (run* [q] (parent q 'Michael)) ‚áí (Vito Carmela)
21:48:52 <shachaf> "Use a Prolog thing" is very likely not an answer that is helpful in practice. :-)
21:49:19 <Iceland_jack> I'm trying to answer his question, not to be helpful :)
21:49:43 <optimight> Iceland_jack: I am reading the contents of the links
21:51:50 <Iceland_jack> good luck optimight, I'm heading for bed
21:53:45 <optimight> Good Night
21:54:06 <optimight> Actually the second link explains my motive
21:55:53 <optimight> Iceland_jack: Good Night, the objectcommando link explains what I want to do.   Using haskell, how?
22:45:20 <Veinor> when using hscurses, is there a reason my simple example using getCh is using about 2.0% cpu? looks like there's a lot of SIGVTALRMs going off
22:46:19 <yitz> optimight: it looks like cflp does some of that. but it's really designed to be part of a bigger system that does something else. you might be able to build a kanren-like system on top if it.
22:46:24 <yitz> @hackage cflp
22:46:24 <kappabot> http://hackage.haskell.org/package/cflp
22:47:11 <yitz> optimight: if i'm right, then kanren probably needs a pretty powerful and complex system underlying it to be able to do much.
22:47:35 <yitz> optimight: if i'm wrong, then please go ahead and write it and let us know!
22:48:42 <optimight> yitz:  I am strong in Object Oriented Paradigm ...but absolute beginner for Functional Programming ... but yes kanren is somthing in line ..I am thinking about
22:48:44 <yitz> Veinor: hmm that doesn't sound right.
22:51:20 <yitz> optimight: after you spend a little time learning how to completely forget OO-style thinking, the higher-order skills you developed to become strong in OO will help you become an excellent functional programmer.
22:52:32 <optimight> yitz:  thanks ...   I strongly believe so...
22:53:17 <Anpheus_> I have documented my Yesod / Conduit / Wai error here if anyone could please reply or suggest a solution, it includes a handler that errors every time (run time error). https://groups.google.com/forum/?fromgroups#!topic/yesodweb/HR96yuyZZ78
22:53:38 <yitz> Veinor: a few years ago i wrote some simple hscurses-based programs. i don't remember anything like that happening - though i didn't really check.
22:53:54 <yitz> Veinor: do have any ncurses experience outside of hscurses (i don't)
22:53:57 <yitz> ?
22:54:30 <Veinor> i don't either, no
22:56:15 <yitz> Anpheus_: hmm let me ask snoyberg (works here)
22:56:32 <Anpheus_> What time zone is he in?
22:56:35 <Anpheus_> Slash, you
22:58:34 <Veinor> lskdfjsldkfj
22:58:37 <Veinor> whoops
22:59:03 <copumpkin> Veinor: unforgivable!
22:59:38 <kappabot> lskdfjsldkfj
22:59:44 <shachaf> Uh-oh.
22:59:55 <yitz> Anpheus_: he told me he's already working on it. hang in there.
23:00:24 <yitz> Anpheus_: UTC+2, +1 for summer time
23:00:58 <optimight> yitz: Where can I find more details , documentation etc for minikanren core logic and something equivalent in haskell?
23:02:09 <mrotondo> okay, well. I'm pretty confused! "Could not deduce (f ~ Prob)"
23:02:27 <yitz> optimight: don't know. the only thing i found on hackage that sounded close was what i mentioned above. otoh, there are many university logic courses that use haskell for expressing things, so i'm guessing there's a lot more out there. try googling.
23:02:43 <mrotondo> how do I use hpaste?
23:03:03 <optimight> yitz: okay... thanks
23:03:46 <JoeyA> mrotondo: The ~ means type equality, FYI
23:03:55 <mrotondo> okay, that's helpful, thanks
23:04:01 <yitz> Anpheus_: he's guessing that you need to use a "more global" connection manager than withManager (whatever that means). he's testing now.
23:04:22 <yitz> @hpaste
23:04:22 <kappabot> Haskell pastebin: http://hpaste.org/
23:04:45 <yitz> huh? kappabot?
23:05:29 <shachaf> yitz: lambdabot is down but this channel was going into withdrawal, so I put up an alternative.
23:05:39 <yitz> shachaf: oh, thanks!
23:06:15 <wiz> Is it possible to build a haddock docs in cabal-dev for executables that build-depend on a library from a same package?
23:06:33 <Anpheus_> yitz: please let Michael know I appreciate his quick response and efforts to make Haskell easier to use for us plebes, Alas, it is UTC-6 here and I must sleep!
23:07:19 <hpaste> mrotondo pasted ‚ÄúAttempting to create Traversable instance‚Äù at http://hpaste.org/71621
23:07:42 <mrotondo> If anyone wants to take a peek at that, I'm in way over my head :)
23:07:48 <yitz> Anpheus_: ok :) my guess is he'll have a complete answer for you within 5 min. from now. but you can read it on the mailing list in the morning.
23:08:39 <mrotondo> (in pretty shallow water, I'm guessing)
23:08:47 <Veinor> yitz: well, whatever it is it goes away with -O2
23:08:53 <Veinor> so i'm going to just assume it's something i don't care about
23:09:32 * hackagebot sbv 2.2 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving. (LeventErkok)
23:10:03 <yitz> Veinor: ah ok, great. right, nothing to do with curses then, and nothing you care about.
23:10:17 <Veinor> yeah
23:16:21 <yitz> mrotondo: func <$> probs has the wrong type
23:17:05 <yitz> mrotondo: it's not as simple as that. you have to tell it how to traverse. in this case, you'll have to use the underlying type of the newtype somehow.
23:17:06 <Veinor> i feel like there's a shorter way to write (a, b) +. (c, d) = (a + c, b + d)
23:17:09 <Veinor> but i can't tell what it is
23:17:51 <mrotondo> well, so my fmap defines that I thought...
23:17:52 <yitz> Veinor: (+.) = (+) *** (+)
23:18:01 <yitz> @type (***)
23:18:02 <kappabot> forall (a :: * -> * -> *) b c b' c'. Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
23:18:41 <yitz> @type (+) *** (+)
23:18:43 <kappabot> forall b b'. (Num b', Num b) => (b, b') -> (b -> b, b' -> b')
23:18:50 <yitz> oh no not quite
23:19:10 <Veinor> @type (***)
23:19:11 <kappabot> forall (a :: * -> * -> *) b c b' c'. Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
23:19:17 <shachaf> "Your Linode, linodexxxxxx, has exceeded the notification threshold (1000) for disk io rate by averaging 1973.84 for the last 2 hours"
23:19:30 <shachaf> Maybe someone else should run lambdabot?
23:19:33 <shachaf> Cale: Beep boop.
23:19:49 <yitz> shachaf: it's kinda late for Cale.
23:19:52 <Veinor> shachaf: why is \bot hitting disk?
23:20:48 <shachaf> Veinor: I have no idea.
23:21:53 <yitz> @type uncurry (***) . (+) *** (+)
23:21:58 <shachaf> yitz: Sorry. :-(
23:22:03 <shachaf> Hmm, maybe I'll run a ramdisk.
23:22:05 <yitz> awww
23:22:12 <shachaf> Veinor: Apparently every action modifies State/abunchofthings?
23:22:44 <Veinor> weird
23:22:51 <shachaf> shachaf@helium:~/lb/lambdabot-4.2.3.2/State$ echo $(stat * | grep Modify | grep 12-07)
23:22:54 <shachaf> Modify: 2012-07-16 23:20:31.000000000 -0700 Modify: 2012-07-16 23:20:31.000000000 -0700 Modify: 2012-07-16 23:20:31.000000000 -0700 Modify: 2012-07-16 23:20:31.000000000 -0700 Modify: 2012-07-16 23:20:31.000000000 -0700 Modify: 2012-07-16 23:20:31.000000000 -0700 Modify: 2012-07-16 23:20:31.000000000 -0700 Modify: 2012-07-16 23:20:31.000000000 -0700 Modify: 2012-07-16 23:20:31.000000000 -0700 Modify: 2012-07-16 23:20:31.000000000 -0700
23:23:06 <shachaf> Not sure how that's justified...
23:23:21 <yitz> Prelude Control.Arrow> :t uncurry (***) . ((+) *** (+))
23:23:21 <yitz> uncurry (***) . ((+) *** (+)) :: (Num c', Num c) => (c, c') -> (c, c') -> (c, c')
23:23:28 <yitz> Veinor: there you go
23:23:38 <Veinor> haha
23:23:58 <yitz> Veinor: simple as pie
23:24:23 <Veinor> alternatively, uncurry (***) . join (***) (+)
23:24:41 <yitz> Veinor: if the bot were up, we could now @pl it. that would probably combine the doubling of (+) and (***) using ap and/or join.
23:24:48 <shachaf> OK, no one do anything annoying, please. :-)
23:24:54 <mrotondo> haha
23:24:54 <yitz> ah right
23:25:07 <shachaf> Running on a ramdisk now, so in theory it should be OK.
23:25:10 <Veinor> @pl \(a, b) (c, d) -> (a + c, b + d)
23:25:10 <kappabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
23:25:14 <yitz> shachaf: thanks!
23:25:15 <Veinor> ... well.
23:25:29 <yitz> Veinor: see? even simpler
23:25:35 <shachaf> @pl \f (a, b) (c, d) -> (f a c, f b d)
23:25:36 <kappabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
23:25:51 <shachaf> This is one of the weak spots of point-free code in Haskell.
23:25:59 <shachaf> Maybe there should be a library function added for it.
23:26:04 <coppro> shachaf: what? I was going to use that in my code!
23:27:31 <mrotondo> yitz: so, I'm not quite understanding this. What should the return type of traverse be?
23:28:02 <yitz> @type traverse
23:28:03 <kappabot> Not in scope: `traverse'
23:28:23 <yitz> ok. well, it's traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
23:29:02 <yitz> mrotondo: you end up with t (f b). backwards.
23:29:48 <mrotondo> okay, that helps i think :) thanks!
23:32:14 <Axman6> is there a good explanation somewhere for what Traversable is for and how it's used? It's not something I've ever really looked into
23:32:42 <copumpkin> it's basically mapMable
23:32:47 <copumpkin> if that clarifies things :P
23:32:59 <yitz> mapM-able
23:33:12 <copumpkin> note that mapM_able is different
23:33:18 * yitz was trying to figure out what a mable is
23:33:22 <copumpkin> :)
23:33:23 <copumpkin> sorry
23:33:46 * Axman6 was to
23:33:55 <Axman6> poor Mabel :(
23:33:58 <yitz> copumpkin: actually mapA-able
23:34:14 <Axman6> does it allow you to change the shape of the structure?
23:34:18 <yitz> no
23:34:19 <copumpkin> no
23:34:31 <Axman6> hmm, ok. so what's it useful for?
23:34:47 <copumpkin> say you want to run an effectful action over each element of a collection
23:34:55 <yitz> Axman6: like copumpkin said. think of mapM.
23:34:56 <Axman6> i was thinking it might be something you could use to optimise an AST
23:35:05 <copumpkin> one clever thing is
23:35:10 <Axman6> what would be useful for that?
23:35:25 <copumpkin> > getZipList . Data.Traversable.traverse ZipList $ [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
23:35:26 <kappabot>   [[1,4,7,10],[2,5,8,11],[3,6,9,12]]
23:35:30 <copumpkin> tada!
23:35:54 <copumpkin> the world's most succinct definition of transpose
23:38:44 <mrotondo> so maybe I should back up a bit. My monad (from LYAH) is this: newtype Prob a = Prob { getProb :: [(a,Rational)]} deriving Show
23:39:34 <mrotondo> I want to collapse a value of that monad down such that there is only one entry for each value of a (unique it, that is, while adding up the Rationals for each redundant value)
23:40:54 <dmwit> mrotondo: Sounds good so far.
23:40:59 <mrotondo> would mapM-ing the top-level value with a function that filters the list held within and sums the values be the right thing? e.g. I have Prob [(False, 1%2), (False, 1%4), (True, 1%4)], I want [(False,3%4), (True, 1%4)]
23:41:24 <dmwit> mapM?
23:41:34 <dmwit> I don't think mapM is what you want.
23:41:43 <yitz> mrotondo: mapM will keep the same number of list elements
23:41:53 <yitz> mrotondo: it's like map, except with monadic values
23:41:53 <mrotondo> okay, then it's not what I want. Cool.
23:42:06 <startling> mrotondo, maybe a fold?
23:42:18 <mrotondo> yeah, that makes sense. I thought maybe the side-effects that it makes possible included blocking values
23:42:24 <dmwit> This is a primitive for your monad. This operation doesn't make sense with other monads; therefore, you will not be able to use any of the generic monad functions when implementing it.
23:42:37 <mrotondo> okay, that's a good way to think about it
23:42:49 <startling> but Foldable could get you part of the way there
23:43:08 <dmwit> It is easy to write without any high-power abstractions. =)
23:43:31 <dmwit> :t sortBy
23:43:33 <kappabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
23:43:34 <dmwit> :t groupBy
23:43:35 <kappabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
23:43:43 <mrotondo> yeah, i'm trying to be very conventional? This is the first haskell I've ever written, and I'm trying to give myself a tour
23:43:46 <dmwit> ...kappabot? =P
23:43:58 <c_wraith> :t \f -> catMaybes . map f
23:44:00 <kappabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
23:44:33 <c_wraith> ah.  entirely irrelevant.
23:48:08 <shachaf> mrotondo: As far as people using your monad are concerned, those two lists are exactly equivalent, probably.
23:48:38 <dmwit> For efficiency reasons, it can make a really, really big difference.
23:48:48 <shachaf> Sure.
23:48:55 <shachaf> It might be reasonable to set things up such that you can never construct an invalid list like that.
23:49:04 <shachaf> For example, use (Map a Prob)
23:49:05 <dmwit> It's not possible, given Monad's interface.
23:49:12 <shachaf> Oh, I suppose.
23:49:16 <dmwit> (which is too polymorphic)
23:49:16 <shachaf> Bah, Monad. :-(
23:50:26 <dmwit> Incidentally, there's a wonderful blog post somewhere that characterizes this monad as WriterT (Product Rational) [].
23:50:29 <dmwit> Isn't that beautiful?
23:51:02 <shachaf> Hmm, makes sense.
23:51:28 <shachaf> You can turn it into [] by repeating each value the right number of times.
23:51:41 <mrotondo> I'd like to see that
23:51:52 <mrotondo> all I'm finding are irc logs of Cale talking about how great it is
23:51:59 <dmwit> That seems... inefficient.
23:52:02 <shachaf> How great what is?
23:52:15 <shachaf> dmwit: That's the second time you've said that.
23:52:17 <mrotondo> WriterT (Product Rational) []
23:52:19 <shachaf> Are you some kind of operationalist?
23:52:39 <dmwit> =)
23:53:08 <shachaf> "Haskell programmers (other than dmwit) know the value of everything and the cost of nothing"
23:53:18 <shachaf> "Haskell programmers (other than dmwit) indent their code with spaces"
23:54:01 <dmwit> mrotondo: Hm, was that a request for a link to the blog post?
23:54:11 <dmwit> If so, you already saw the punch line, nothing left to read.
23:54:19 <dmwit> But... http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions
23:54:21 <mrotondo> Except I don't get it :(
23:54:28 <mrotondo> <--- total nub, remember
23:54:31 <mrotondo> thanks!
23:54:47 <JoeyA> Would it be bad practice to deliberately let a thread be BlockedIndefinitelyOnMVar, or should I go out of my way to kill it so this doesn't happen?
23:55:16 <JoeyA> Namely, I'm spawning a worker thread.  The first thing it does is wait on an MVar, so the main thread can perform some setup (which depends on the ThreadID of the worker).
23:55:29 <JoeyA> If the setup action fails, the MVar will never get filled.
23:55:45 <shachaf> JoeyA: I think that's considered a normal part of GC?
23:55:55 <JoeyA> shachaf: To my knowledge.
23:55:59 <shachaf> I.e., collecting threads along with the MVars they were blocking on.
23:57:03 <Enigmagic> i dunno, i have an uncaught exception handler setup that core dumps... so i just fix those bugs or setup an explicit exception handler if it's really expected.
23:57:56 <Enigmagic> i think the default behavior of silently catching exceptions on forked threads is terrible
23:58:03 <JoeyA> Actually, now that I think about it some more, letting the RTS garbage collect here lets me get rid of a mask around the thread construction, I think.
23:58:47 <JoeyA> Enigmagic: Good point.  If in the future, it prints an error message, having an exception handler might make my code a little more future-proof.
