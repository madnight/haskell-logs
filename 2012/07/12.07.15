00:00:29 <Anpheus_> otters: Well I'm trying to work with what's on the internet, not my own generated output :)
00:00:51 <otters> ouchies, why would you want to work with the real world
00:01:28 <shachaf> obiwahn: No, I don't know Vixen's format. But from what I know about Vixen working with it is a bad idea.
00:01:31 <SoupEvil> ^^
00:01:39 <Anpheus_> otters: the "I reject your reality and substitute my own" philosophy
00:01:48 * hackagebot th-orphans 0.5.1.3 - Orphan instances for TH datatypes (MichaelSloan)
00:02:04 <SoupEvil> i hate the internet, on the web site with this creepy websites
00:02:30 <SoupEvil> parsing creepy sites isnt fun
00:06:09 <Anpheus_> well
00:06:17 <Anpheus_> I'm just testing parsing like, google.com, reddit.com, etc
00:06:20 <Anpheus_> Nothing creepy tet :P
00:06:23 <Anpheus_> yet
00:06:31 <yitz> dada_cetacean: yes. but as shachaf implies, the construction let...in... can be used in any expression, anywhere inside the expression; not just as the RHS of a function definition.
00:08:39 <SoupEvil> Anpheus_: these are the nice parts of the web, i guess 90% isnt that nice :D
00:09:21 <SoupEvil> often its like a 2000 loc class in java
00:10:15 <Anpheus_> SoupEvil: Sadly not :(
00:10:50 <Anpheus_> SoupEvil - Could we exchange email information, since your prof is the HXT developer?
00:11:12 <Anpheus_> There are no, to my knowledge, no HTML5 parser / combinator libraries, none support producing HTML5
00:11:59 <Anpheus_> Tagsoup may support reading it, but using hxt-tagsoup doesn't make it capable of writing it correctly, at least as near as I can tell
00:14:25 <SoupEvil> Anpheus_: sure, dcc me, i will give you my address
00:15:25 <SoupEvil> i will suggest it to my prof, i hope he will call out some work for bored students :D
00:16:33 * hayashi wonders if there's an XML equivalent to Aeson, as in an XML parser/emitter that can automatically work out XML representations for anything that has a GHC.Generics.Generic instance
00:17:31 <Anpheus_> HTML is so messy as a markup language, I'm not sure how well something like that might work
00:18:47 <hayashi> If not, it's probably for the best.  JSON does everything I could possibly want from a text-based serialisation/markup medium anyway, really.
00:19:25 <Anpheus_> yes, except it doesn't parse web pages :D
00:21:46 <SoupEvil> html is like php, it wasnt designed for todays usage
00:23:03 <SoupEvil> its like pure C, you can programm object orientated, but it is not designed for it
00:28:34 <zzing_> Does anyone happen to have any snap experience to know why snap might take 200+ ms to transfer a file that apache takes about 4 to do?
00:29:26 <shachaf> Maybe the Snap IRC channel would know.
00:29:29 <zzing_> oops nevermind, it was a 302 I was getting for apache, that would explain it all
00:29:46 <zzing_> shachaf, snap irc channel is periodic
00:30:07 <shachaf> #s.n.a.p.f.r.a.m.e.w.o.r.k
00:32:38 <zzing_> very nice :p
00:34:02 <SoupEvil> what? the snap irc channel or the unredirected response time? :D
00:35:33 <hayashi> gah, undecidable instances
00:40:40 <cesc> damn it, the LYAH site is down :D
00:41:49 <hayashi> this class Foo a, it'd be absolutely smashing if it could have an instance (Show a) => Foo a, but completely impractical.  I'd set up a default implementation for its function for when (Show a), but I've already got a default implementation using generics
00:44:34 <hayashi> instead at the moment I've just got a huge array of instances for every Show-able item I can think of.  To be honest it's probably for the best that there isn't a catchall Show instance, because then that'd start overlapping with the generic instances anyway
00:44:42 <ClaudiusMaximus> hayashi: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/type-class-extensions.html#class-default-signatures ?
00:44:49 <hayashi> It's just a bit tedious to keep writing out v_v;;
00:45:20 <hayashi> ClaudiusMaximus: already using that, but for a different constraint~
00:45:27 <ClaudiusMaximus> heh, ok
00:45:40 <ClaudiusMaximus> and it doesn't solve the "writing 9001 instances" problem
00:45:56 <hayashi> Oh well, I'm making mountains out of molehills, it's still a lot less code than I'd have had to write in most other programming languages I figure
00:47:06 <hayashi> oh there's a point
00:47:27 <ClaudiusMaximus> is it possible with template-haskell to get a list of things that are in scope?
00:48:00 <hayashi> I can just write an external function (Show a) => a :: (target type of class function) and in there massage the result of show into the required type.
00:48:05 <hayashi> er
00:48:09 <hayashi> *:: (Show a) => a ->
00:48:16 <hayashi> what's wrong with my notation today...~
00:49:02 <hayashi> Doesn't help with recursive structures though
00:51:40 <hayashi> I've never used TH before ;_;
01:15:31 <Digit> http://www.youtube.com/watch?v=iSmkqocn0oQ :O  spj ... haskell is useless??  i must click n watch this.  XD
01:23:34 <zzing_> Digit, ltu discussion: http://lambda-the-ultimate.org/node/2356
01:24:41 <Ke> Digit: liek silverlight
01:25:09 <Ke> ah youtube link
01:27:34 <Digit> well, it's all very interesting.  i only just came across it looking for dislexic-friendly tutorials for haskell (hence the youtube)... since i'm still completely incompetent with haskell after all this time.
01:27:53 <Ke> up, I just clicked on the wrong link
01:28:58 <zzing_> Digit, interesting how he says it is useless - I really do wonder if he meant haskell in the whole or the original conception because he goes into how they figured out how to do input/output isolating effects drawing up into useful
01:30:04 <Digit> i'd pass comment myself, but after reading your comment, i'd only be showing how out of my depth i am.  ^_^
01:33:01 <zzing_> Digit, how long have you been doing haskell and what problems do you still encounter?
01:34:47 <Digit> first started getting into haskell along with xmonad, sometime around early 2008 (iirc), and main 2 interelated problem i have is: maintaining motivation and persisting with trying to learn, and, being able to do anything (not counting copy & paste of working code).
01:35:26 <zzing_> motivation can always be difficult
01:36:19 <levi> spj is a funny guy.
01:36:39 <Digit> so far all i've done is maaaany variations on a handful of xmonad configs, and a few variations of the basic haskell bot i made following a tutorial.  i called it "daskeb"
01:37:31 <Digit> when i try to sit down and write something in haskell from scratch, i realise, i still dont have the first clue how to begin.
01:38:05 <zzing_> Digit, writing what from scratch?
01:38:10 <Digit> i can poke ghci n do some painfully simple stuff (and usually only after quickly reminding myself by skim reading early parts of learnyouahaskell)
01:38:49 <levi> That just means you need more practice writing stuff in haskell.
01:39:08 <Digit> anything.  like, just earlier, i thought i'd write a hello world to play around with n see how i could expand it n test my skills...  then i realised i didnt even know how to do that.  lol.  oh dear o dear.
01:39:44 <zzing_> Digit, after a week of playing around with snap, I can go write a web application, and I am still iffy on type signatures in the deeply monadic cases (like snaplets are)
01:40:33 <zzing_> Digit, if I asked you to write a number guessing game, would you be able to?
01:41:09 <Digit> yeah, that's still way beyond me.  i'd like to get up to using stuff like yesod, but it seems so far away still.   ... but i keep holding on to hope that at some point soon, a few key pieces of information and syntax will stick, and it will all suddenly *click* and make sense.
01:41:31 <levi> You could always work through "99 Haskell Problems"
01:41:42 <Digit> zzing_ ok, lets assume you've just asked...   i'll go see what i can do...
01:42:10 <zzing_> Digit, without looking it up, what does the return function do?
01:42:35 * Digit stares blankly, like a dog asked what's the capital of france
01:43:02 <zzing_> :t return
01:43:03 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
01:43:11 <zzing_> Does that tell you anything?
01:43:30 <Digit> it tells me i still dont even have a clue when it's all layed out to me.
01:43:42 <Digit> well, maybe half a clue.
01:43:50 <zzing_> The important part is this:  (Monad m) => a -> m a
01:44:00 <zzing_> More specifically:  a -> m a
01:44:37 <zzing_> The function is probably better named inject, or by some people's reckoning pure
01:44:38 <zzing_> :t pure
01:44:40 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
01:45:01 <zzing_> Basically, it takes the thing you give it and attaches it to the monad
01:45:12 <zzing_> Sort of injecting it into the context of whatever it is you are computing with
01:45:18 <Digit> methinks i need to print out some haskell cheatsheets so i can at least start imprinting some of the syntax of these elaborations into my neuropathways
01:45:43 <zzing_> Digit, have you been doing haskell since 2008, or just on and off?
01:45:53 <Digit> on n off, vastly more off.
01:46:01 <zzing_> ok, me too
01:46:15 <zzing_> In my case it probably totals no more than 3 months in the last decade
01:46:17 <Digit> i read about half of real world haskell, and a chunk of learn you a haskell too.
01:46:29 <zzing_> Those books are probably the greatest thing ever
01:46:55 <Digit> though i still kinda feel like i'm struggling to grab the first wrung of the ladder.
01:47:04 <zzing_> I am getting that impression
01:47:07 <levi> Programming in Haskell is pretty good, too.
01:47:10 <zzing_> For me, little pieces have been retained
01:47:21 <zzing_> levi, that the green thin book?
01:47:39 <zzing_> oh yes, the hutton book. I have that
01:47:47 <zzing_> Decent, could be better
01:47:53 <Digit> thin book!  that sounds like it'd do me well!  XD   (dislexic friendly, is a BIG boon for me)
01:48:10 <zzing_> http://www.cs.nott.ac.uk/~gmh/book.html#slides
01:48:18 <zzing_> and videos there apparently
01:48:21 <levi> zzing_: What don't you like about it?
01:50:04 <zzing_> levi, I cannot remember entirely. I think it was a certain direction it went when I wanted to go in another. At the time I wanted more practical tasks, but it dealt with first principle related stuff - in retrospect stuff that was needed no doubt.
01:51:14 <zzing_> In my current CS studentness, it would likely be the best book for a first course on haskell. But my school doesn't do haskell - it does about a month equivalent on miranda.
01:51:23 <levi> Yeah, it does take a little while to get to practical matters, but that's a good thing when you're learning a language that's quite a bit different than what you're used to.
01:52:09 <zzing_> At the level where I am, I can do a lot of the practical, but still missing a bit as mightybyte can probably attest to with some of the questions I have asked about s n a p
01:52:28 <levi> Chapter 5 has a cool little program that breaks the Caesar cipher.
01:52:58 <levi> And then Chapter 8 develops monadic parsing combinators.
01:53:03 <zzing_> I must go now
01:53:12 <zzing_> levi, i should probably do chapter eight then
01:53:16 <zzing_> :P
01:53:21 <zzing_> Sleep awaits
01:53:26 <Digit> oh, another thing i think slowed down my haskell learning... it's the first programming language i ever tried to learn.
01:53:26 <levi> Seeya.
01:53:39 <Digit> thnx zzing_
01:53:46 <levi> Digit: That could be to your advantage!
01:53:47 <zzing_> Digit, I will be around in about 12 hours
01:54:01 <zzing_> My first thought is - oh dear! :P
01:54:08 <zzing_> Hutton might be a good book, until later.
01:54:16 <levi> It means you don't have a lot of stuff to un-learn.
01:55:06 <Digit> levi, i know, sorta.  not having to "re-learn" to do things in haskell's more unique way... but still, for ages, i didnt really even have a clue what "functions" and "variables" meant.
01:55:43 <levi> You probably needed a book like Programming in Haskell, then.
01:56:38 <Digit> i've got a little bit of bash skills now, and was about to start trying ot learn lisp (now that i use emacs and clfswm)... but then it hit me, that i should give haskell more dedication, for all the reasons i wanted to learn it in the first place.
01:57:16 <mroman> I wouldn't want haskell to be my first programming language.
01:57:42 <mroman> Or if it were, you'd still have to learn other languages as well.
01:58:28 <levi> One issue I'm having with it, though, is that it develops these monadic parsers without introducing how to make your Parser an instance of Monad, and also without introducing the module system so you can hide the Prelude definitions of return and >>=.
02:00:35 <levi> Learn haskell, then learn C.  Heh.
02:07:17 <Digit> tried learning C.  it does my head in.  the mental gymnastics involved... i dont think my neuropathways bend like that.  XD  haskell seems to flow much more akin to natural flows of thought
02:07:40 <Digit> says me who can't code haskell to save his life.  ^_^
02:13:37 <Vq> Digit: C is really a quite simple language. It's hard to write programs in though.
02:14:06 <ment> at least it doesn't need 4MB runtime
02:15:02 <Ke> 1.7M	/lib/libc-2.15.so
02:15:06 <Ke> !
02:15:35 <Ke> obciously glibc has loads of extra stuff
02:16:37 <saep> feel free to use assembler
02:16:53 <ment> glibc is gnu (=> bloated) and library (not a runtime, that would be /usr/lib/gcc/*/crt*)
02:17:03 <mroman> @djiin (\ e n -> g (\ q -> h (e q)) (f n))
02:17:04 <lambdabot> Cannot parse command
02:17:14 <mroman> oh... wait
02:17:24 <mroman> :t (\ e n -> g (\ q -> h (e q)) (f n))
02:17:26 <lambdabot> forall t t1 t2 t3 t4 t5. (SimpleReflect.FromExpr (t2 -> t3), SimpleReflect.FromExpr (t -> t4), Show (t1 -> t3), SimpleReflect.FromExpr (t4 -> t5)) => (t1 -> t2) -> t -> t5
02:21:37 <mroman> that Type looks really weird.
02:22:32 <mroman> @pl (\ e n -> g (\ q -> h (e q)) (f n))
02:22:33 <lambdabot> (. f) . g . (h .)
02:23:13 <Ke> ment: glibc provides to utilities you need to interact with the system
02:23:38 <Ke> otherwise it's system calls with asm
02:24:22 <Ke> I don't think runtime size is that relevant but all the abusive traits
02:28:23 * Digit feels hopeful, as he downloads all the http://www.cs.nott.ac.uk/~gmh/book.html#videos
02:29:01 <ppilate> > .wmv
02:29:02 <ppilate> :(
02:29:02 <lambdabot>   <no location info>: parse error on input `.'
02:29:04 <Digit> hrmmm, that's going to take all day.  methinks i'll put haskell learnings on hold until then.
02:29:23 <Digit> ppilate: yeah.  what can ya do.  :/  not everyone's savvy to .ogv
02:29:33 <ppilate> Digit: oh why, you can start skimming through Learn You a Haskell
02:29:37 <ppilate> http://learnyouahaskell.com/
02:31:53 * hackagebot mime-mail-ses 0.2.0.3 - Send mime-mail messages via Amazon SES (MichaelSnoyman)
02:32:16 <levi> You can find the videos elsewhere in streaming form.
02:32:29 <ppilate> Yeah, on Channel9, to be concrete
02:32:37 <obiwahn> Digit: http://video.s-inf.de/#FP.2005-SS-Giesl.%28COt%29.HD_Videoaufzeichnung
02:33:47 <levi> http://goo.gl/lcqLX
02:34:14 <levi> ^- shortened form of the really long Channel9 URL
02:37:09 <obiwahn> Digit: http://www.se-radio.net/2008/08/episode-108-simon-peyton-jones-on-functional-programming-and-haskell/
02:37:42 <obiwahn> i think both links are very good
02:42:42 <Digit> ppilate: i've more than skimmed loads of it many a time.  reading doesnt fit my learning type too well, not to mention mildly dislexic on top of that.   besides, i welcome the break.
03:01:53 * hackagebot markdown 0.1.0 - Convert Markdown to HTML, with XSS protection (MichaelSnoyman)
03:04:48 <nand`> Does a gödel numbering system have to be an isomorphism or is an injection of (equivalent) terms okay too?
03:05:39 <nand`> case in point: SK calculus, where every possible term has a number of other distinguishable but semantically equivalent forms
03:05:48 <nand`> (trivially true via identity)
03:09:51 <Taneb> Okay, Data.FamilyTree.addPerson etc have the result the wrong way round for Control.Monad.State
03:09:59 <Taneb> Anyone mind if I change it?
03:10:18 <shachaf> If anyone else uses that code, then presumably yes.
03:10:24 <shachaf> That's not a good reason to break an API.
03:10:28 <Taneb> I don't think anyone does
03:10:49 <shachaf> If it's your code which no one else uses, you can do whatever you like with it.
03:10:57 <Taneb> And it's still marked as unstable
03:11:15 <Taneb> It's on Hackage, but I don't know if anyone other than me has downloaded it
03:12:14 <shachaf> Well, asking in #haskell at 03:11 PT (or any other time) is probably not a good way to find out if anyone in the world uses your library.
03:15:11 <ThePro> > 42 / pi
03:15:12 <lambdabot>   13.36901521971921
03:15:33 <ThePro> 1337
03:15:50 <ThePro> > printf("test")
03:15:51 <lambdabot>   Ambiguous type variable `r' in the constraints:
03:15:51 <lambdabot>    `Text.Printf.PrintfType ...
03:16:05 <ThePro> > printf "test"
03:16:06 <lambdabot>   Ambiguous type variable `r' in the constraints:
03:16:06 <lambdabot>    `Text.Printf.PrintfType ...
03:16:30 <ThePro> > printf "%s" "test"
03:16:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
03:16:32 <lambdabot>    `GHC.Show.Show a'
03:16:32 <lambdabot>      a...
03:21:12 <fmap> ThePro: `printf' function return value can be either `String' or `IO a' so you need to help lambdabot to figure it out
03:21:25 <fmap> > printf "%s" "test" :: String
03:21:27 <lambdabot>   "test"
03:21:39 <ThePro> oh
03:21:48 <ThePro> k thx
03:23:31 <ThePro> > printf ("%f" pi) :: String
03:23:32 <lambdabot>   Couldn't match expected type `t -> GHC.Base.String'
03:23:32 <lambdabot>         against inferre...
03:23:54 <ThePro> > (printf "%f" pi) :: String
03:23:55 <lambdabot>   "3.141592653589793"
03:23:57 <ThePro> :)
03:35:37 <nand`> personally I would have kept ‘printf’ as IO and used ‘sprintf’ for the String version
03:38:57 <ThePro> > :t 3
03:38:58 <lambdabot>   <no location info>: parse error on input `:'
03:39:03 <ThePro> >:t 3
03:39:08 <nand`> :t 3
03:39:08 <ThePro> :(
03:39:09 <lambdabot> forall t. (Num t) => t
03:39:11 <ThePro> oh
03:39:18 <ThePro> thx
03:39:21 <nand`> ‘>’ has nothing to do with GHCi, btw
03:39:25 <nand`> but ‘:t’ does
03:40:16 <ThePro> :t printf "%.2f" n
03:40:17 <lambdabot> forall t. (PrintfType (Expr -> t)) => t
03:40:51 <ThePro> hm, that doesent work on query
03:40:55 <ThePro> for some reason
03:41:12 <nand`> probably because you don't have ‘n’ defined
03:41:57 <ThePro> ye maybe
03:42:02 <ThePro> :t printf "%.2f" 3
03:42:03 <lambdabot> forall t t1. (Num t, PrintfType (t -> t1)) => t1
03:42:19 <ThePro> no
03:42:24 <ThePro> on query this still doesent work
03:42:49 <nand`> maybe you don't have “printf” defined either
03:42:59 <ThePro> it is
03:43:17 <ThePro>  > (printf "%.2f" (42 / pi) ) :: String
03:43:24 <ThePro> > (printf "%.2f" (42 / pi) ) :: String
03:43:26 <lambdabot>   "13.37"
03:44:11 <bourbaki> Is there any way to make haskell compile with unicode characters?
03:44:37 <nand`> bourbaki: you'll need to be more specific; Haskell supports unicode characters out of the box
03:44:52 <nand`> > let α = 3 in α * 2
03:44:54 <lambdabot>   6
03:45:09 <bourbaki> Well i tried to use the partial differential symbol as a function name
03:45:31 <nand`> there are limitations on what names can consist of
03:45:43 <bourbaki> Is there any way around this?
03:45:52 <nand`> I don't know for sure without seeing the use case
03:45:57 <bourbaki> Or is there any specific reason for that?
03:46:17 <nand`> (for example, you can't start a function name with Ω because it counts as a capital letter and therefore a type constructor)
03:46:25 <bourbaki> ∂ :: Int -> Int
03:46:42 <nand`> > generalCategory '∂'
03:46:44 <lambdabot>   MathSymbol
03:46:50 <nand`> I think it has to be an operator for that
03:46:54 <nand`> > generalCategory '+'
03:46:56 <lambdabot>   MathSymbol
03:47:03 <bourbaki> Hm ...
03:47:16 <nand`> > let (∂) = (*2) in map (∂) [1..5]
03:47:18 <lambdabot>   [2,4,6,8,10]
03:48:02 <bourbaki> Thats a pitty though.
03:48:02 <nand`> I think there was some Haskell extension that lets you use prefix/postfix operators (in limited ways) that might be able to help make this cleaner
03:48:49 <bourbaki> I mean partial differentiation is an operator but of an arity of one.
03:49:14 <nand`> oh, there's -XPostfixOperators but none for prefix
03:49:18 <nand`> shame
03:49:42 <bourbaki> I guess problems like that are rather low on the list right?
03:49:46 <nand`> I suppose so
03:49:48 <bourbaki> Its not a problem even perse.
03:49:56 <nand`> the advantage is being able to keep language simplicity
03:50:05 <bourbaki> But it would make math oriented code much more readable.
03:50:21 <nand`> look at the problems - causes already
03:50:40 <bourbaki> Like what?
03:51:21 <nand`> (3 -) works like (3 +) but (- 3) is (negate 3) and not (subtract 3)
03:51:23 <nand`> because - is special
03:51:28 <nand`> it's sometimes an operator and sometimes a prefix negation
03:51:56 <nand`> (though I guess that's just the fault of using the same symbol twice)
03:52:12 <nand`> honestly I'm not sure how complicated it would be to extend Haskell to allow prefix/postfix operators
03:52:25 <bourbaki> Yeah well :) the remedy would be unicode and then have two different -.
03:52:43 <nand`> (the -XPostfixOperators extension is somewhat of a hack, it just makes (a +) parse as ((+) a) instead of (\y -> a + y))
03:52:43 <bourbaki> Or using brackets.
03:53:01 <Cale> Or what we currently have
03:53:12 <Cale> ;)
03:53:14 <bourbaki> :)
03:53:18 <Cale> :t subtract
03:53:20 <lambdabot> forall a. (Num a) => a -> a -> a
03:53:24 <Cale> :t negate
03:53:26 <lambdabot> forall a. (Num a) => a -> a
03:53:35 <nand`> bourbaki: most people frown on unicode names in Haskell, btw
03:53:50 <bourbaki> Hm hm hm
03:54:04 <Cale> Yeah, I can type a wide range of unicode characters in my setup, and I still don't really like them in source code.'
03:54:09 <bourbaki> But i still think that it makes math oriented problems a lot more readable.
03:54:30 <nand`> same, though I use λ a lot when I want to make my names unique (and they're for the lambda calculus)
03:54:36 <bourbaki> Main problem is that you dont want to learn the unicode characters i guess.
03:54:52 <nand`> Problem is that it's too hard for people to type them
03:54:52 <bourbaki> But you can have snippets and the like for that.
03:54:56 <Cale> It's more keystrokes to type them
03:55:01 <bourbaki> nand`: Thats what i ment.
03:55:31 <Cale> The SCIM latex extension lets me type most mathematical symbols in unicode.
03:55:35 <bourbaki> I dont know yet how of if eclipse and emacs handles that but in Visual Studio you can have snippets.
03:55:36 <nand`> Cale: in my setup they're generally actually less
03:55:38 <Nereid> nand`: what's the difference between ((+) a) and (\y -> a + y))
03:55:49 <bitonic> Nereid: no difference
03:55:52 <bourbaki> Then the name will be replaced with a string.
03:55:57 <Nereid> that's what I thought
03:56:02 <nand`> for example ∧ is one keystroke (with one modifier), but && is two (with one modifier)
03:56:03 <Nereid> so what's nand` saying
03:56:23 <nand`> :t ?f ()
03:56:24 <Nereid> Cale: scim latex? this is new to me :o
03:56:25 <lambdabot> forall t. (?f::() -> t) => t
03:56:32 <nand`> :t \y -> ?f () y
03:56:34 <lambdabot> forall t t1. (?f::() -> t -> t1) => t -> t1
03:56:38 <nand`> observe the inferred type of f
03:56:46 <Cale> I can type \int to get ∫ and \in to get ∈
03:56:53 <Nereid> nand`: ah right.
03:57:01 <bourbaki> Cale: Ah.
03:57:02 <Cale> (after hitting Ctrl-space)
03:57:10 <nand`> Nereid: basically, \y -> a + y means (+) has to have an arity of at least two
03:57:11 <bourbaki> Cale: What ide?
03:57:14 <Nereid> I get it now.
03:57:15 <Cale> Not an IDE
03:57:19 <nand`> :)
03:57:26 <Cale> It's an input method
03:57:26 <nand`> bourbaki: SCIM is an input engine
03:57:35 <nand`> works everywhere (or most everywhere) that has text input
03:57:36 <bitonic> you can get the same with emacs
03:57:46 <bourbaki> I see.
03:57:47 <bitonic> with the TeX input moe
03:57:48 * nand` just has them all bound to various keys + modifiers
03:57:49 <Nereid> but emacs only works in emacs
03:57:49 <bitonic> *mode
03:57:59 <bitonic> Nereid: yes. but what else do you need apart from emacs?
03:58:10 <bourbaki> Ok that sounds pretty cool.
03:58:10 <nand`> vim!
03:58:12 <Nereid> emacs is the only program you run that takes text input?
03:58:20 <Cale> I also have my left windows key remapped to switch my layout into Greek while held
03:58:27 <nand`> Nereid: for some people, it is :)
03:58:29 <Cale> αβγδε
03:58:29 <bourbaki> Now haskell just needs to support unicode ;)
03:58:31 <bitonic> Nereid: I only run emacs and a browser really. and some terminals occasionally :)
03:58:36 <Nereid> see, a browser
03:58:40 <Cale> bourbaki: It does
03:58:45 <bitonic> I don't type much in the browser.
03:58:46 <bourbaki> Cale: With what driver?
03:58:51 <Cale> driver?
03:58:55 <Cale> It just does. :P
03:59:02 <bourbaki> The windows key to greek symbol thingy.
03:59:16 <nand`> Cale: not bad, I have greek letters on Alt Gr + my normal letters (with some exceptions), for example I have ℤℚℝℕ on ZrRN since I don't need those greek letters
03:59:17 <Nereid> Cale: does scim do that too?
03:59:32 <Nereid> or is it something else.
03:59:50 <nand`> I also have ⊥ on B, ⊤ on T, ⇔ on b, → on h and ⇒ on H
04:00:00 <Cale> I added the Greek layout under Gnome's Keyboard Preferences, and then in Options, I have Keys to Change Layout -> Left Win (while pressed)
04:00:35 <bitonic> emacs agda2-mode has good shortcuts to the symbols, I think that somebody in #agda ported it to scim
04:00:43 <Nereid> why aren't your arrows on hjkl
04:00:51 <Nereid> ←↓↑→
04:01:26 <nand`> Nereid: I only need →, which is on h for hom(omorphism), and H is just ⇒ because it's a “thicker h”. l is λ and k is already ō. (j is unused)
04:01:36 <Nereid> how do you type eta
04:01:48 <nand`> similarly, ⇔ is on b for bijection
04:01:52 <nand`> Nereid: eta? is that η ?
04:01:57 <Nereid> yes
04:02:02 <nand`> I have that on ‘n’ because it looks like one :P
04:02:06 <Nereid> how do you type nu
04:02:07 <bourbaki> :)
04:02:08 <lambdaphi> nand` where's phi?
04:02:40 <nand`> Nereid: renders the same as N and v for me so I didn't bother mapping it
04:02:47 <Nereid> but nu is not v
04:02:54 <Cale> ν and v are different
04:02:56 <Nereid> and should render differently
04:03:01 <Nereid> ν
04:03:08 <nand`> I see those all the same
04:03:14 <nand`> lambdaphi: I don't have it mapped :P
04:03:16 <Nereid> get better fonts :P
04:03:24 <lambdaphi> awwe, then you can't say my name then
04:03:36 <nand`> indeed I can't, not without copy/paste
04:03:41 <Cale> λφ
04:03:45 <nand`> lambdaphi: if it makes you happy and you can come up with a good place to map it to, I could
04:03:59 <lambdaphi> p ?
04:04:00 <Nereid> I don't have anything fancy like you guys, but my japanese IME lets me type some special symbols so that's good enough for me.
04:04:02 <Nereid> ☃
04:04:09 <nand`> p is ö already (don't ask)
04:04:14 <Cale> f
04:04:15 <nand`> and I can't change that because it's muscle memory
04:04:17 <lambdaphi> g ?
04:04:20 <nand`> oh
04:04:22 <nand`> f is φ
04:04:22 <lambdaphi> G for golden ratio
04:04:23 <lambdaphi> ?
04:04:24 <nand`> so I do havei t
04:04:27 <Nereid> lol
04:04:29 <lambdaphi> oh hahaha
04:04:36 <bourbaki> f like fhi :)
04:04:44 <nand`> λφ <- shows you how much I use these greek letters, the only ones I really type are λ ω η μ
04:04:50 <Nereid> φ
04:05:04 <Cale> ζξ
04:05:10 <nand`> lambdaphi: gG is γΓ
04:05:13 <lambdaphi> Is there anyway someone could hack the haskell compiler to allow for greek letters?
04:05:20 <Nereid> it already does
04:05:22 <nand`> lambdaphi: it does allow them
04:05:24 <Cale> lambdaphi: It already allows for them
04:05:26 <lambdaphi> o.o
04:05:37 <Nereid> and many other unicode characters
04:05:53 <lambdaphi> hahah i'm going to start programming with unicode characters
04:06:06 <nand`> I have ⊆⊇∩∈ ⊂⊃♂∃ ⊈⊉∪∉ ⊄⊅♀∄ on F1-F4 (plus modifiers) :P
04:06:12 <nand`> €¥£¤//€¥¤¥
04:06:14 <Nereid> sometimes I think greek letters would be nice for type variables or so.
04:06:15 <nand`> oops
04:06:20 <lambdaphi> Yeah
04:06:27 <nand`> that was F9-F12
04:07:10 <Nereid> ↷
04:07:12 <lambdaphi> I'm sure there's some that would like to do λa->a^2 rather than \a->a^2
04:07:20 <Nereid> ⤴
04:07:27 <nand`> ∧∨∀≅¹²³⁴⁵⁶⁷⁸‘’±×÷≈«»⟨⟩⁺π¬∅∘·≥≤≠  <- more various useful things I map
04:07:36 <nand`> lambdaphi: λa → a²
04:07:38 <Nereid> why not λa→a^2
04:07:57 <lambdaphi> maybe I could write a little perl or haskell script to go and do that.
04:08:37 <lambdaphi> so I could do parseintolegalhaskell myprogram.hs > compilable.hs
04:08:40 <nand`> lambdaphi: extend -XUnicodeSyntax
04:08:49 <lambdaphi> ah
04:08:54 <nand`> make sure to add ² ³ etc. for ^2 ^3 :P
04:09:06 <lambdaphi> Oh wow I could actually do that couldn't I?
04:09:23 <nand`> → for -> (would work in case too)
04:09:42 <lambdaphi> What about a not even having unicode text
04:09:52 <Nereid> ★
04:10:03 <lambdaphi> and having a special gui that deals with equasions and makes them look pretty
04:10:18 <bourbaki> laksah does that already
04:10:26 <nand`> a transformation from ¬ to the word “not” could be interesting
04:10:43 <bourbaki> And the unicode - to negate ;)
04:10:48 <Nereid> ∀∃
04:11:14 <nand`> while you can define ¬ in haskell already it'll be an operator so you can't use it prefix, but a blind transformation could allow you to write ¬(¬ x)
04:11:15 <bourbaki> What is that XUnicodeSyntax good for?
04:11:26 <nand`> bourbaki: nothing really
04:11:31 <nand`> Nereid: ≤≥
04:11:32 <lambdaphi> pretty
04:11:40 <lambdaphi> That's what it's useful for
04:11:41 <Cale> I can type ☆ and ★ by using Japanese input and typing ほし and then converting :)
04:11:44 <nand`> (∘) = (.)
04:11:55 <lambdaphi> People program more when it looks nice
04:12:04 <nand`> Cale: yeah, it was pretty amusing when I first discovered that
04:12:12 <nand`> Cale: there are a few others too iirc
04:12:16 <Cale> yeah
04:12:36 <Cale> ◯ = まる
04:12:42 <nand`> -XUnicodeSyntax already allows → as -> btw
04:12:45 <nand`> and ⇒ as =>
04:13:10 <bourbaki> Where is XUnicodeSyntax documented?
04:13:14 <nand`> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
04:13:38 <nand`> I also want ∧ ∨ as && ||
04:13:48 <Cale> ■,◇ and variations,　しかく
04:14:20 <lambdaphi> Yeah a lot could be done
04:14:39 <bourbaki> Why cant you just extend the map on your own?
04:15:36 <nand`> where would I look at the source of -XUnicodeSyntax in GHC's source code?
04:15:42 <nand`> I want to see how an extension like that is written
04:15:59 <Cale> インテグラル and 積分 don't convert to ∫ though
04:16:02 <lambdaphi> I would love to implement something like this
04:16:45 <bourbaki> Would it be possible with some trick to get something like Γ as a function name also?
04:17:28 <Cale> Γ is uppercase, so it's a data constructor
04:17:40 <bourbaki> Why is there this constraint?
04:17:50 <nand`> http://darcs.haskell.org/cgi-bin/gitweb.cgi?p=ghc.git;a=blob;f=compiler/parser/Lexer.x;h=ad56090fc389ae07996a9b87b46ac62780a79a5e;hb=dff3e914fbc8cff76b0475e4431fa831c804209a <- ah, foudn it
04:18:00 <bourbaki> Id like to use Gamma for the Christoffel symbols.
04:18:14 <Cale> Because in patterns, you have to be able to syntactically distinguish between data constructors to be pattern matched and variables to be bound.
04:18:46 <bourbaki> Ah ok. Meh though.
04:19:23 <bourbaki> Maybe theres a unicode character thats alomost invisible and small that i can prepend.
04:19:49 <nand`> > let _Γ = negate in _Γ 4
04:19:51 <lambdabot>   -4
04:19:54 <nand`> okay that looks silly
04:19:58 <Cale> Or of course you could just use lowercase γ
04:20:41 <bourbaki> Sure but that wont pop to your eye as a Christoffel symbol then :)
04:20:50 <nand`> as if Γ will :P
04:21:10 <Cale> christoffelΓ
04:21:12 <Cale> lol
04:21:16 <bourbaki> Sure cause thats the symbol usually used.
04:21:37 <Cale> Worst of both worlds!
04:21:39 <mcstar> ⟂ℏ∀⟂∫ ℳℏ∀⟂ ∫ℏ∃ ∫∀ιδ
04:21:43 <bourbaki> :))
04:22:07 <nand`> if I don't know what a christoffel symbol is (I don't), and I see “christoffel”, I can search for it. If I just see ‘Γ’, I'll have a hard time finding what I want
04:22:47 <bourbaki> Thats what comments are good for :)
04:28:29 <Cale> bourbaki: So how are you intending to do differential geometry in Haskell anyway?
04:28:46 <hayashi> gah, why can't I seemingly lazily split a lazy bytestring by newlines, feed the resulting list to a function [ByteString]->IO [ByteString], and then print the resulting lines back out
04:29:12 <Cale> hayashi: ?
04:29:19 <bourbaki> Cale: I just do it for a limited domain.
04:29:26 <Peaker> hayashi, liftM LBS.unlines . mapM f . LBS.lines ?
04:29:40 <Peaker> (after import qualified Data.ByteString.Lazy as LBS)
04:29:55 <bourbaki> I have a function d(x) = 2x^3 - 3x^2 + 1 and then have points within a 2 Manifold.
04:29:58 <Cale> possibly without the mapM
04:30:15 <bourbaki> Then i take the distance of these point in the manifold and plug that into d.
04:30:19 <Peaker> oh, right :)
04:30:37 <bourbaki> D can be derived two times so i can get all the interesting features like the Christoffel symbols for example.
04:31:07 <Cale> hmm
04:31:19 <bourbaki> So basically i can map this to any two manifold.
04:31:20 <Peaker> hayashi, "lines" is not in Data.ByteString.Lazy, though, only in Data.ByteString.Lazy.Char8 or Data.ByteString.Lazy.UTF8
04:31:33 <bourbaki> Its just a height map on a two manifold if you want to look at it like that.
04:31:58 <bourbaki> I did a very simple and slow particle based fluid solver with it.
04:32:56 <bourbaki> At least i get non numeric solutions in this setup :).
04:34:57 <mannycalavera> hi all
04:35:09 <mannycalavera> I've tried to download the haskell platform for windows but it failed ... twice
04:35:21 <mannycalavera> the first time yesterday, the last right now...
04:35:32 <hayashi> currently I've got a function :: ( [C.ByteString] -> IO [C.ByteString] ) -> IO () which is supposed to work a bit like interact but with the passed function returning an IO action (where C => Data.ByteString.Lazy.Char8)
04:35:39 <mannycalavera> network error after downloading 99.6MB .... :-/
04:35:48 <hayashi> and, currently, the definition of that function is f = ( >>= C.putStr . C.unlines ) . ( ( fmap C.lines $ C.getContents ) >>= )
04:36:02 <mcstar> wget -c
04:36:39 <hayashi> which checks out type-wise but otherwise doesn't appear to be working at all in practice
04:37:09 <mcstar> hayashi: you like golf, eh?
04:37:14 <Peaker> hayashi, try not to mix >>= and (.). Instead, use (=<<) so the flow is in one direction
04:38:24 <Peaker> hayashi, for example: inLines f =  C.putStr . C.unlines =<< f . C.lines =<< C.getContents
04:39:20 <Cale> hayashi: do you know how to write this with do-notation?
04:40:41 <mannycalavera> ok, success on third try ... sorry for the noise
04:41:48 <hayashi> something along the lines of do {in <- C.getContents; let inLines = C.lines in; outLines <- f inLines; let out = C.unlines outLines; C.putStr out} I assume
04:44:00 <Cale> Yeah, if you're having trouble figuring out what's happening with the combinators, I recommend just writing it in do-notation first and then seeing what combinators you can use. For example, I would probably go straight to using fmap to apply the lines function. I'd also probably not define 'out' separately there, since it's only used in one place.
04:44:39 <Cale> Of course, you can simplify things further from there, but at that point it'll be pretty reasonable.
04:45:24 <hayashi> the function is now in the form Peaker suggested, but the problem of the it not working still exists =P
04:45:37 <Peaker> hayashi, what do you mean by "not working"? does not type check?
04:46:57 <Nereid> <Cale> インテグラル and 積分 don't convert to ∫ though <- google IME gives me this.
04:46:59 <Nereid> ∫
04:47:00 <hayashi> It type-checks fine, but whenever I've tried to use it with an inner function (even one as simple as mapM return, it quite literally does nothing on stdin.
04:47:10 <hayashi> No output ever gets produced
04:47:24 <Peaker> hayashi, probably a matter of buffering?
04:47:50 <Peaker> hayashi, did you try running it non-interactively?  echo hello | ./program ?
04:48:25 <hayashi> actually, come to think of it, I've been stung by buffering before in similar circumstances, and I obviously forgot to check that
04:49:00 <mcstar> hayashi: does your main have an explicite type signature?
04:49:08 <hayashi> Yeah, IO ()
04:49:14 <mcstar> ok, nvm
04:49:38 <mcstar> just was wandering, if you give back an IO (IO a)
04:49:50 <mcstar> (happened to me once..)
04:53:33 <hayashi> right, adding hSetBuffering stdout NoBuffering >> hSetBuffering stdin NoBuffering >> to the top of the function didn't help.
04:54:41 <mikeplus64> hayashi: can you paste the code somewhere?
04:54:51 <hayashi> This is probably the point where I should just start reading about conduits.
04:55:23 <bourbaki> How about this ⅎΓ for functions with uppercase greek letters :) ?
04:58:27 <hpaste> hayashi pasted “bytestring list fun” at http://hpaste.org/71527
04:59:03 <hayashi> A similar thing that doesn't split at newlines works absolutely fine
05:00:12 <hayashi> and when playing around in ghci I think I managed to do C.lines on an infinite list perfectly fine, so I assume the problem probably isn't there
05:00:46 <luite> is there some existing ordered map structure, where values can be looked up by key, with operations like: insert (k,v) after k0,  get first (k1,v1) after k0 ?
05:02:10 <Eduard_Munteanu> luite: doesn't Map come with an Ord constraint for keys?
05:02:51 <luite> Eduard_Munteanu: yes, but that's an implicit order, it's fixed by the Ord instance, i want an explicit one
05:03:50 <Eduard_Munteanu> Ah.
05:03:58 <hughfdjackson> in game making in the mutable world, it's common to subscribe to events, or use timers that simply delay mutation
05:04:46 <hughfdjackson> i was thinking the most direct way to solve the same problem immutably is to have a descriptive event bus, and part of the 'calculate next step' would be to deal with that
05:05:01 <hughfdjackson> is that the right basic idea?
05:05:12 <hayashi> mikeplus64: apologies if you noticed it already, but that hpaste up there (http://hpaste.org/71527) is the offending code.
05:07:40 <mcstar> hayashi: if f = return it works
05:08:21 <hayashi> so it does!
05:08:35 <mcstar> though im not sure why would you want to apply it on a list of bytestrings
05:08:45 <mcstar> dont you want to map it on them or something?
05:09:04 <mcstar> is there a reason, why f returns IO?
05:09:27 <Peaker> hayashi, why do you shun "do" notation and use >> repeatedly?
05:09:56 <Peaker> hayashi, what "f" did you use that did not work?
05:10:10 <mikeplus64> hayashi: that is some funky code ( C.putStrLn =<< ) . ( =<< C.getContents )
05:10:15 <hayashi> mcstar: basically because the operation on the input may need to affect or read external state, otherwise I'd have just used C.interact
05:10:47 <mcstar> ok, there is a reason
05:11:11 <mcstar> btw, why would you use NoBuffering?
05:11:12 <hayashi> Peaker: mapM f, but I've just checked ahead on google and realised that the mapM is almost certainly where the problem is!
05:11:19 <mcstar> i think LineBuffering would be sufficient
05:11:24 <Peaker> hayashi, can you show the entire program with the problem?
05:12:06 <Peaker> mikeplus64, the funky code is more readable point-ful, but formatted that way it is pretty clear that it is: putStrLn after, getContents before
05:12:09 * hackagebot egison 2.2.1 - An Interpreter for the Programming Language Egison (SatoshiEgi)
05:12:51 <mcstar> f = mapM return also works
05:13:22 <mikeplus64> Peaker: i'd much prefer just lbsFilter f = getContents >>= f >>= putStrLn
05:13:29 <mcstar> lets reverse the list
05:13:42 <Peaker> mikeplus64, I agree, though I prefer =<< over >>=
05:13:42 <hayashi> mapM return isn't working for me (on lbsListFilter, in ghci)
05:13:53 <mikeplus64> i mean C.getContents and C.putStrLn though
05:14:08 <mcstar> ooops, works too
05:14:21 <mcstar> ghci?
05:14:30 <mcstar> what do  you mean ghci?
05:14:37 <mcstar> no ghci
05:14:39 <mcstar> compile it
05:14:49 <mcstar> and pipe some text to the starving programmmmmmee
05:15:35 <hayashi> well, I was hoping to get this working interactively... apparently sequence doesn't take kindly to infinite lists though, which is probably my problem
05:15:41 <mcstar>  (mapM (return . C.reverse))
05:15:46 <mcstar> try this to see some effect
05:16:14 <mcstar> how do you feed text to the filter?
05:16:52 <mcstar> if you do getContents in ghci, it can possible mess up something
05:16:59 <mcstar> im not sure, but wouldnt be surprised
05:17:00 <hayashi> well, I've been running the module in ghci and typing straight into stdin, which works for the non-list version but not for the list one
05:17:09 * hackagebot dvda 0.2.0 - Efficient automatic differentiation (GregHorn)
05:17:16 <hayashi> I'm beginning to assume http://stackoverflow.com/questions/3270255/is-haskells-mapm-not-lazy is why I'm getting nowhere quickly
05:17:34 <mcstar> getContents doesnt even work in ghci
05:17:46 <mcstar> it returns immediately
05:17:52 <hpc> hah
05:17:56 <mcstar> on the next call, it generates an exception
05:18:43 <hayashi> given that (I assume) interactive stdin would be effectively an infinite list, or at least one with the potential to be infinite.  (I don't really fully get infinite lists and related consequences of lazy evaluation yet, I'll admit)
05:19:11 <mcstar> it has nothing to do with that
05:19:22 <mcstar> it has to do with the way redirection is set up
05:19:24 <mcstar> and all that
05:20:09 <mcstar> getContent probably opens ghci's original stdin
05:20:21 <mcstar> the one you type in, is a subprocess
05:20:25 <mcstar> with its own stdin
05:20:27 <mikeplus64> hayashi: could you simply use forever (getLine >>= f >>= putStr) ?
05:20:51 <mikeplus64> (i mean C.getLine and C.putStr)
05:21:23 <bourbaki> Who says what char in unicode is small or big and what an operator is in haskell and how do i determine that?
05:21:26 <mcstar> i guess compiling a program is out of the question....
05:22:22 <obiwahn> > let f= \test -> (+) test where f 4 5
05:22:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:23:04 <hayashi> well, I did compile a program that used this earlier, which is how I noticed that it wasn't working~
05:23:13 <hayashi> though I did use that one interactively, I'll go and pipe something to it
05:23:45 <obiwahn> > let f= \test -> (+) test where { f 4 5 }
05:23:46 <lambdabot>   <no location info>: parse error on input `}'
05:23:55 <bourbaki> nand`: How did you determine that partial differential was an operator?
05:23:56 <Azel> obiwahn: Perhaps you should replace the where by a in
05:24:04 <mcstar> obiwahn: in
05:24:11 <obiwahn> > let f= \test -> (+) test in f 4 5
05:24:12 <lambdabot>   9
05:24:17 <obiwahn> yeahy:)
05:24:18 <nand`> bourbaki: you mean the symbol?
05:24:29 <bourbaki> nand`: Yes.
05:24:34 <nand`> :t generalCategory
05:24:36 <lambdabot> Char -> GeneralCategory
05:24:37 <nand`> with this function
05:24:47 <hayashi> mcstar: yes, piping works fine, whereas running the compiled program interactively doesn't
05:24:50 <nand`> it comes out as ‘MathSymbol’, which is what operators are
05:25:03 <Nereid> > generalCategory '☃'
05:25:04 <lambdabot>   OtherSymbol
05:25:11 <mcstar> hayashi: running the compiled program interactively < what does that mean?
05:25:12 <bourbaki> Ah ok
05:25:27 <hayashi> as in, not piping to it but instead using a terminal as stdin
05:25:43 <mcstar> im still lost
05:25:46 <bourbaki> > generalCategory '❂'
05:25:47 <lambdabot>   OtherSymbol
05:25:53 <mcstar> how do you run it 'interactively'
05:25:57 <mcstar> if its compiled
05:26:14 <bourbaki> The is no good emptyspacy looking char that you can use it seems ...
05:26:39 <mcstar> bourbaki: do you just run it, wo piping some text to it?
05:26:40 <Nereid> > generalCategory '　'
05:26:41 <lambdabot>   Space
05:27:01 <hayashi> what I meant is that I've run the compiled program in the terminal, but instead of piping something to it (eg 'echo "1" | ./foo', which works), I've just launched './foo' without piping, and thus it's taking standard input from the terminal I launched it in
05:27:13 <hayashi> in a kind-of interactive session on the program... or something like that...
05:27:28 <mcstar> ok, you just run it
05:27:31 <mcstar> i get it
05:27:44 <bourbaki> mcstar: I am searching a unicode character to prepend to uppercase letters so i can use them for functions.
05:28:01 <bourbaki> Eg Γ cant be used as a function name.
05:28:05 <mcstar> bourbaki: im happy for you
05:30:10 <mcstar> hayashi: it works for me
05:30:25 <mcstar> ofc, you have to change NoBuffering to LineBuffering as  i suggested
05:30:48 <mcstar> (and press ^D on the end of the input)
05:31:38 <Qrt> lets say a website has different sections like http://en.wikipedia.org/wiki/Tic-tac-toe. how do i write so that if you open the site in your browser you get to Strategy automatically?
05:32:08 <pqmodn> http://en.wikipedia.org/wiki/Tic-tac-toe#Strategy
05:32:13 <mroman> http://en.wikipedia.org/wiki/Tic-tac-toe#Strategy
05:32:34 <mroman> Although that has nothing to do with sections.
05:32:58 <mcstar> you copy the link from the top of the page, called Contents or something
05:36:48 <Qrt> does haskell have multimethods? can it without having classes?
05:38:02 <Eduard_Munteanu> Qrt: what's a multimethod?
05:38:42 <herpladee> hey eguys
05:38:47 <herpladee> i just did cabal install boomerang
05:38:50 <herpladee> but i get an error
05:38:56 <herpladee> ExitFailure 1
05:39:00 <herpladee> how do i fix that?
05:39:13 <hpc> scroll up to where the error occurs
05:39:55 <herpladee> happens in text/boomerang/strings.hs
05:40:00 * mcstar <3 generic functions
05:40:31 <hpc> is there any notable error message?
05:40:41 <mroman> Eduard_Munteanu: He means function overloading.
05:40:49 <hpc> er rather, what is the error message
05:41:32 <Eduard_Munteanu> Qrt: then no, you don't really get ad-hoc polymorphism.
05:41:46 <herpladee> no it just looks like type errors
05:41:47 <mroman> Seems like a clojure term. Never heard it before.
05:41:53 <mcstar> mroman: multimethods support dispatching on every argument
05:42:03 <herpladee> couldn't match expected type
05:42:03 <mcstar> mroman: argh, not clojure
05:42:07 <herpladee> it has two of those
05:42:09 * hackagebot dvda 0.2.1 - Efficient automatic differentiation (GregHorn)
05:42:11 <herpladee> and then i get exitfailure
05:42:22 <hpc> hmm, let me try this
05:43:21 <Nereid> Eduard_Munteanu: you can with typeclasses
05:43:22 <hpc> hackage claims it is able to compile just fine
05:44:03 <Eduard_Munteanu> Nereid: yeah, though it's not quite ad-hoc
05:44:10 <herpladee> but
05:44:10 <hpc> yeah, it compiles for me
05:44:16 <herpladee> i just reinstalled ghc and cabal
05:44:18 <herpladee> yesterday
05:44:27 <Eduard_Munteanu> As in you don't just go define another function with the same name.
05:44:29 <herpladee> why am i getting an error?
05:44:32 <herpladee> i just did cabal update
05:44:33 <herpladee> but i still get it
05:44:38 <herpladee> is there anything i can do?
05:44:49 <hpc> hmm
05:44:49 <Cale> The main difference between typeclass polymorphism and ad-hoc polymorphism is that you can define typeclass polymorphic things just by using other polymorphic things.
05:44:49 <Nereid> Eduard_Munteanu: well yeah, you have to write an instance for each type.
05:45:02 <hpc> herpladee: can you hpaste the entire cabal output?
05:45:23 <herpladee> yes
05:45:24 <herpladee> just one second
05:45:28 <herpladee> where is hpaste?
05:45:32 <hpc> @where hpaste
05:45:32 <lambdabot> http://hpaste.org/
05:45:33 <Nereid> http://hpaste.org
05:45:37 <hpc> heh
05:45:49 <Cale> for example   square x = x * x   doesn't need to be defined separately for each of the types which support multiplication.
05:46:30 <mcstar> i guess if you have a type hierarchy, you can do the same
05:47:00 <mcstar> in Julia, you can dispatch on abstract types
05:47:07 <mcstar> im not sure about CL
05:47:08 <Cale> Also, multimethods according to wikipedia refers to dynamic dispatch based on the run-time types of arguments. So it sounds like something we might use Typeable to do.
05:47:20 <Cale> (and perhaps existentials)
05:47:52 <hpaste> herpladee pasted “boomerang” at http://hpaste.org/71529
05:48:16 <herpladee> there it is
05:48:41 <hpc> hmm
05:50:32 <hpc> well
05:51:16 <hpc> i have no idea why it would be doing that
05:51:23 <hpc> so i suggest "turning it off and on again"
05:51:32 <herpladee> my computer?
05:51:41 <hpc> wget http://hackage.haskell.org/packages/archive/boomerang/1.3.2/boomerang-1.3.2.tar.gz | tar x
05:51:58 <herpladee> hmm
05:52:01 <Axman6> herpladee: did you remove your ~/.ghc and ~/.cabal directories?
05:52:01 <hpc> basically, redownload and try again
05:52:08 <herpladee> Axman6, i did yesterday
05:52:13 <herpladee> but i reinstalled cabal and ghc after that
05:52:24 <herpladee> because i had some problems with dependencies
05:52:29 <herpladee> 'cause i used apt-get for some packages
05:52:42 <herpladee> i don't really want to do that again though
05:52:53 <herpladee> can't i make cabal redownload boomerage?
05:52:56 <herpladee> boomerang*
05:53:41 <mcstar> boomerage is beginning to sound more appropriate :)
05:53:55 <herpladee> yea freudian slip
05:57:00 <nus> luis, something like this? http://hackage.haskell.org/packages/archive/gmap/0.1/doc/html/Data-GMap.html#t:OrderedMap
05:57:06 <nus> err luite ^^^
06:01:47 <zhulikas> is there a way to call a map function with a time delay?
06:01:48 <boccato> if I do this: let a = Array $ fromList []
06:01:56 <boccato> how do I get my vector back?
06:02:06 <zhulikas> I have a list of values which I want to apply to a function with delay of 10ms after every application
06:02:18 <boccato> using Data.Aeson, btw :)
06:05:31 <zachk> whats aeson?
06:05:36 <luite> nus: hmm, not sure, it still uses a fixed compareKey, while my order doesn't really have anything to do with the keys, order of two keys can be changed
06:05:53 <luite> nus: if the user removes a key and then inserts it in a different location
06:06:35 <boccato> zachk: it is a library for dealing with JSON data
06:06:36 <luite> nus: the docs say that compareKey shouldn't eval the map a argument, so that leaves just the keys, which is not enough
06:06:58 <hape01_> EclipseFP has an Mylyn integration - I found out 10 minutes ago! I can focus on tasks and Mylyn opens automatically any related Sourcefile (and only these!) - that is like christmas and easter at the same day.... :-)
06:07:35 <zachk> would it be wise to: implement key/val store as [(k,v)] and implementing update rollback over it? I found a way a while back and updates were O(1) as far as I could tell
06:07:38 <hayashi> ok, after all that, I've realised that the problem all along with the bytestring experiment is that I've been passing the _lists_ to the wrapped function
06:07:40 <hayashi> when, in actual fact
06:07:46 <hayashi> the use case only needs it to process one line.
06:08:11 <hayashi> that simplifies things to the point where everything works perfectly.
06:08:55 <Taneb> Hmm
06:09:18 <Taneb> Should I recommend people use StateT IO or IORef?
06:09:38 <ksf> meh she doesn't know about (| foo ++ bar ++ baz |)
06:10:35 <zachk> Taneb: depends, sometimes IORef can be faster if you know what you are doing or want really fine grain contro, I have seen SPJ use it in posts, though StateT is way more elegant in general
06:11:10 <Taneb> zachk, there should be only one thing in the state, so IORef seems a bit ott?
06:11:43 <zachk> ott?
06:11:48 <hayashi> over the top?
06:11:49 <Taneb> Over-the-top
06:12:23 <zachk> ahh, its up to you, do you need to actually update the value after it is set?
06:12:42 <Taneb> Both can do that?
06:13:30 <zachk> as far as I know, use a modify
06:13:45 <zachk> you could also maybe do the same thing with function definition inside a function
06:14:05 <zachk> depends on what you need
06:14:37 <Taneb> But if we're using StateT, I'd want s -> (a, s), and with IORef, s -> (s, a)
06:14:45 <Taneb> :t state
06:14:47 <lambdabot> forall s a. (s -> (a, s)) -> State s a
06:14:59 <Taneb> :t atomicModifyIORef
06:15:01 <lambdabot> Not in scope: `atomicModifyIORef'
06:15:05 <Taneb> @hoogle atomicModifyIORef
06:15:06 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
06:16:06 <zhulikas> I wonder if Haskell mutable variables are slower than those in other languages
06:16:19 <zhulikas> it looks like a pain to handle mutable states in Haskell
06:17:22 <zachk> zhulikas: there is no mutation in haskell
06:17:25 <Taneb> If I do it with StateT, I can avoid IO where possible
06:17:44 <Qrt> anyone know if C++ has a quickCheck lib?
06:17:56 <mcstar> zachk: do you think haskell has variables?
06:18:06 <zachk> sort of
06:18:16 <mcstar> :(
06:18:18 <mcstar> nvm
06:18:22 <pqmodn> Qrt: wikipedia says http://software.legiasoft.com/quickcheck/
06:18:23 <Taneb> zhulikas, there is mutation in Haskell, but it's highly recommended you avoid it wherever possible to preserve functionny stuff
06:18:41 <zachk> I look at alot of things as s cascading spreadsheet, if its single threaded and deterministic it works good
06:19:23 <zachk> all the variables at the top and one of them is time, it starts at 0, and then it gets updated and so does everything else, sometimes the update is just   (a->a) though
06:21:11 <Taneb> zhulikas, if you want to do actual mutation outside of IO or ST, you're probably doing it wrong
06:21:27 <zhulikas> I don't want to do that, I just wonder :)
06:22:03 <Taneb> State s a is just a wrapper around s -> (a, s)
06:22:10 <mcstar> zachk: change 'gets updated' to 'get rebound' and i agree
06:22:21 <Taneb> There isn't actually any mutation
06:22:37 <zachk> s/updated/rebound/g ;)
06:22:39 <zachk> semantics
06:22:50 <mcstar> lol, damn semantics!
06:23:11 <hpaste> zhulikas pasted “this must be wrong” at http://hpaste.org/71530
06:23:21 <zhulikas> I get all of them printed at once
06:23:26 <zachk> if the compiler knows what it is completely doing, sometmes in the actual machine code the variable could possibly be a register, so it might actually get updated
06:24:23 <mcstar> zachk: under the we hope it will be 'update' ofc, but im talking about the high level model of computation
06:24:27 <mcstar> the hood*
06:24:36 <zachk> ofc? of course?
06:24:44 <mcstar> ofc
06:25:13 <zachk> ofa ofc lost to the larger school
06:26:42 <zachk> ofa="O..*burg Free Academy"
06:26:44 <mcstar> you getting offc
06:26:58 <mcstar> (off course)
06:28:39 <zachk> urspitfuchsmbocwuxps?
06:28:50 <zachk> and I already forgot what that means, in totallity
06:28:53 <Qrt> how useful is quickcheck for non-pure languages? does it make sense to quickcheck nonpure functions?
06:29:09 <zachk> mcstar: i would say #haskell-blah but I need to get going ;)
06:31:36 <roide> Hello, I have two lists.
06:31:54 <roide> List1 contains positions like[2,4,6]
06:32:14 <roide> based on the positions i want to removes those elements from list2
06:32:25 <roide> which is a work
06:32:32 <roide> I am not getting how to do that
06:34:34 <Saizan> Qrt: yep, as long as the properties you want don't get too hard to check
06:34:51 <roide> s/work/word
06:42:13 <zhulikas> > let removeAt li word = map fst $ filter (\(a, b) -> not $ elem b li) $ zip word [1..] in removeAt [1,2,4] "asdfg"
06:42:14 <lambdabot>   "dg"
06:42:20 <zhulikas> roide, maybe something like this
06:43:22 <zhulikas> but its gets slower with longer index lists
06:43:38 <roide> zhulikas: thanks. Let me analyze this. I am quite new to haskell.
06:44:17 <roide> I have small lists.
06:44:19 <zhulikas> so can anyone tell me how to do something like this properly? <hpaste> zhulikas pasted “this must be wrong” at http://hpaste.org/71530
06:47:14 <ClaudiusMaximus> zhulikas: you probably want more 000
06:48:53 <nand`> roide: if the list of positions is sorted you can probably do it in O(n) complexity via recursion
06:49:22 <hpaste> mcstar pasted “remIfPos - roide” at http://hpaste.org/71531
06:50:25 <nand`> what mcstar pasted
06:50:36 <ClaudiusMaximus> zhulikas: (like i did, when i miscopied the past url to my browser..)
06:51:16 <roide> nand`: thanks.
06:51:20 <mikeplus64> zhulikas: remember threadDelay is in microseconds, so you're delaying it 1000/1000000 of a second, also try hSetBuffering stdout LineBuffering (or NoBuffering)
06:52:19 * hackagebot monad-logger 0.2.0 - A class of monads which can log messages. (MichaelSnoyman)
06:52:55 <nand`> but note that for example remIfPos "foobar" [3,1,2] is "fooar", not "far"
06:53:04 <mikeplus64> zhulikas: (so you're delaying it only 0.001 of a second)
06:54:32 <mcstar> nand's restriction applies, get the list sorted before passing to go, if it isnt already
06:55:52 <roide> Its not sorted actually.
06:56:03 <roide> its more like
06:56:08 <mcstar> > sort "ufhgfigierwdisfgog"
06:56:10 <lambdabot>   "defffgggghiiiorsuw"
06:56:33 <zhulikas> oh shit
06:56:39 <zhulikas> it seriously is MICROseconds
06:56:42 <zhulikas> I misread it as mili
06:56:43 <zhulikas> thanks :D
06:57:19 <mikeplus64> ~eval scanl (flip insert) [] "hi #haskell"
06:57:23 <mikeplus64> derp
06:57:29 <mikeplus64> > scanl (flip insert) [] "hi #haskell"
06:57:32 <lambdabot>   ["","h","hi"," hi"," #hi"," #hhi"," #ahhi"," #ahhis"," #ahhiks"," #aehhiks"...
06:58:54 <roide> mcstar: its more like
06:58:54 <roide> list1 = [("s", 6),("a", 3),("c",4)], list2 = "hello world is not working"
06:58:55 <roide> then based on the values 6, 3,4
06:59:08 <roide> I want to extract first 6 characters
06:59:16 <roide> then next 3
06:59:25 <roide> and then next 4
06:59:44 <mcstar> roide: im sure you can do that if you understand the code i pasted
07:00:02 <roide> mcstar: trying :)
07:00:22 * mcstar has a segfault to debug
07:01:28 * roide will try to figure out
07:02:26 <zhulikas> I like mcstars solution
07:02:44 <zhulikas> I kinda had it in mind but wasnt able to write it down :D
07:04:23 <Saizan> roide: splitAt should also help, or take and drop
07:05:23 <roide> Saizan: I m ver new to haskell. 2 days old :)
07:05:38 <roide> Actually what i am not able to understand is
07:05:52 <roide> how to iterate the list and at the same time apply splitAt
07:12:00 <Saizan> can you rephrase your problem? it's not clear to me from what i've found in the backlog
07:12:51 <ksf> do we have a regex library supporting things like negation of parsers?
07:12:51 <Saizan> anyhow, you could do something like foo (x:xs) ys = let (a,b) = splitAt x ys in f a (foo xs b), for some suitable f
07:13:53 <roide> Saizan: yes. I can try that.
07:14:08 <roide> i think this will be very close the solution i am looking for
07:14:24 <Saizan> > let foo [] ys = [ys]; foo (x:xs) = let (a,b) = splitAt x ys in (a,foo xs b); in foo [2,1,3] "foobarbaz"
07:14:25 <lambdabot>   Not in scope: `ys'
07:14:35 <Saizan> > let foo [] ys = [ys]; foo (x:xs) ys = let (a,b) = splitAt x ys in (a,foo xs b); in foo [2,1,3] "foobarbaz"
07:14:37 <lambdabot>   Couldn't match expected type `[[a]]'
07:14:37 <lambdabot>         against inferred type `([a], [...
07:14:42 <Saizan> doh
07:14:48 <roide> just a sec
07:14:53 <Saizan> > let foo [] ys = [ys]; foo (x:xs) ys = let (a,b) = splitAt x ys in a : foo xs b; in foo [2,1,3] "foobarbaz"
07:14:54 <lambdabot>   ["fo","o","bar","baz"]
07:15:01 <bourbaki> Im trying to install the scion-browser cabal package and get the following error. http://nopaste.info/194eab5193.html
07:15:15 <bourbaki> Can i circumvent this problem?
07:15:21 <roide> Saizan: amazing man :)
07:15:43 <Saizan> bourbaki: have you installed the ncurses headers?
07:15:57 <bourbaki> Saizan: Wouldnt cabal do that?
07:16:21 <Saizan> bourbaki: no, because this is a C lib
07:16:54 <bourbaki> Do you happen to know the apt package name?
07:17:07 <pqmodn> bourbaki: $ apt-cache search ncurses | grep dev
07:17:10 <Saizan> something like libncurses-dev
07:17:20 <bourbaki> Thanks
07:19:30 <PaulVisschers> Im looking for nice libraries that implement geometric vectors with type-indexed length and algebra with stuff like Abelian groups and rings and such, what packages would you recommend?
07:20:09 <mm_freak> PaulVisschers: write your own indexed vector type and give it instances for the vector-space package
07:20:44 <mm_freak> that package is specifically for vector spaces though
07:22:51 <PaulVisschers> mm_freak: Ive actually already written both myself, but feel like maybe using a more standard approach would be better in the long term
07:24:42 <mm_freak> "more standard"?
07:25:24 <PaulVisschers> mm_freak: I just mean a widely used and supported package instead of my own custom made stuff
07:25:45 <Philonous> PaulVisschers: Put you custom made stuff in a package and upload it to hackage. Problem solved.
07:25:48 <mm_freak> well, you could write a package that connects vector-space with HList
07:26:13 <mm_freak> or go without HList and write your own vector type
07:26:13 <peterjoel> hi, anyone know where I can send comments about this page? http://www.haskell.org/haskellwiki/Gtk2Hs/Mac
07:27:24 <PaulVisschers> Philonous: but if there is already one or several available that will just make a mess of hackage (which arguably it already is)
07:28:06 <Philonous> PaulVisschers:  It will increase pressure to make a better hackage.
07:28:37 <PaulVisschers> Philonous: :)
07:29:10 <PaulVisschers> Philonous, mm_freak: thanks, I guess Ill just keep using my own code for now
07:36:26 <obiwahn> peterjoel: register with the site and wirte it in discussion tab
07:37:20 * hackagebot simple-sendfile 0.2.5 - Cross platform library for the sendfile system call (KazuYamamoto)
07:38:17 <peterjoel> thanks obiwahn
07:38:32 <bourbaki> Hm i installed the scion-browser but hoogle still doesnt work in eclipse, any advise?
07:57:32 <zhulikas> @hoogle a -> IO ()
07:57:33 <lambdabot> Control.Concurrent.SampleVar writeSampleVar :: SampleVar a -> a -> IO ()
07:57:33 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
07:57:33 <lambdabot> Data.IORef writeIORef :: IORef a -> a -> IO ()
07:58:08 <zhulikas> if I do a map of (Int -> IO ()) over a [Int]
07:58:24 <zhulikas> and have main :: IO ()
07:58:34 <zhulikas> how can I execute the functions in this map?
07:58:45 <zhulikas> I am definitely missing a variant of map which does that
07:58:46 <hpc> zhulikas: let's follow the types
07:58:57 <zhulikas> I just want to execute things in the function
07:58:57 <hpc> we have an [Int]
07:59:01 <hpc> and (Int -> IO ())
07:59:05 <hpc> and want to get IO ()
07:59:07 <zhulikas> oh, and its all in a do block
07:59:20 <hpc> @hoogle [Int] -> (Int -> IO ()) -> IO ()
07:59:20 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
07:59:21 <zhulikas> and latter function actually returns IO ()
07:59:21 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
07:59:21 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
07:59:30 <hpc> you want forM_
07:59:36 <zhulikas> oh, purrfect
07:59:37 <zhulikas> thanks
07:59:50 <zhulikas> exactly what I needed
08:00:07 <hpc> also, a stylistic note
08:00:39 <hpc> there's mapM and forM, which both do the same thing
08:00:42 <hpc> with flipped argument order
08:00:59 <hpc> (mapM func list) vs (forM list func)
08:01:07 <hpc> the advantage of forM is you can do
08:01:13 <hpc> forM list $ \elem -> do
08:01:15 <hpc>   ...
08:02:04 <hpc> you typically use mapM when your action is short, or if the expression should "look like a list with side effects"
08:02:16 <hpc> as opposed to "an action run multiple times"
08:03:38 <zhulikas> I see...
08:03:46 <zhulikas> @hoogle for
08:03:47 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
08:03:47 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
08:03:47 <lambdabot> Foreign module Foreign
08:04:02 <zhulikas> I was wondering about a regular for
08:04:07 <zhulikas> but that's not important
08:04:08 <hpc> doesn't exist ;)
08:04:48 <zhulikas> for = flip map
08:05:14 <hpc> ironically, python's 'for' has the same argument order as infixed `map`
08:05:22 <hpc> [action for list]
08:05:27 <hpc> (action `map` list)
08:05:30 <hpc> (map action list)
08:14:27 <EmilyS> hmm, I am trying to create a function which performs a set of operations and returns a touple of results, but I need to store intermediate results, how would I do that?
08:15:16 <pqmodn> EmilyS: let intermediateResult = subcalculation in outerCalculation
08:15:31 <pqmodn> or similarly, use a 'where' clause
08:15:36 <pqmodn> > x + 3 where x = 10
08:15:38 <lambdabot>   <no location info>: parse error on input `where'
08:15:58 <pqmodn> let f = x + 3 where x = 10 in f
08:16:13 <pqmodn> nevermind lambdabot.
08:16:21 <pqmodn> > let x = 3 in x + 10
08:16:23 <lambdabot>   13
08:17:13 <obiwahn> @leave
08:17:13 <lambdabot> Not enough privileges
08:17:35 <EmilyS> thats a weird way of doing it
08:18:12 <EmilyS> can't i just declare "let temp = n * 2
08:18:15 <EmilyS> "
08:18:18 <pqmodn> maybe i misunderstood your question. do you need to return the intermediate results to the caller?
08:18:19 <obiwahn> my bot gives me the following error: Plugin `system' failed with: Prelude.last: empty list
08:18:38 <obiwahn> is Prelude.last a custom file?
08:19:00 <bitonic> obiwahn: Prelude.last is a function
08:19:02 <bitonic> > last []
08:19:04 <lambdabot>   *Exception: Prelude.last: empty list
08:19:28 <hpaste> cesc pasted “vocabulary trainer attempt” at http://hpaste.org/71537
08:19:29 <cesc> Hi! In the pasted code I attempt to implement a little vocabulary trainer: the code should load a list of words from a file (language A in even lines, language B in odd lines), and then randomly pick entries and check whether the user enters them correctly. The question I have is:  can I somehow loop over the infinite list of random numbers (rands) and apply the "tormentTheUser contents" function for each element of rands? A map is not
08:19:30 <cesc>  quite what I need, I think. Any tips?
08:19:50 <obiwahn> ah so he just wants to know which channels to leave
08:20:03 <obiwahn> @babel de en rucksack
08:20:03 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
08:20:25 <obiwahn> and that just says the the dict list is empty:)
08:20:32 <pqmodn> EmilyS: usually you'll find something like "f x = something using temp; where temp = x * 2". i'm not sure if you can use "let" without "let ... in ..." except inside do notation
08:20:33 <cesc> obiwahn, sure, it's just as an exercise for n00b me :))
08:20:41 <EmilyS> pqmodn: I need to use them in a later calculation, but I want to avoid doing the same partial result over and over as part of the set of operations
08:21:53 <pqmodn> EmilyS: let and where are similar constructs. other ways of doing that are by creating helper functions that take the intermediate results as parameters
08:25:29 <pqmodn> e.g f x = x * 3 - x * x, then you later call f someCalculation
08:29:10 <obiwahn> oh the babel plugin is really old
08:42:22 * hackagebot Pup-Events-PQueue 1.0 - A networked event handling framework for hooking  into other programs. (DanielWilson)
08:42:24 * hackagebot Pup-Events-Client 1.0 - A networked event handling framework for hooking  into other programs. (DanielWilson)
08:42:26 * hackagebot Pup-Events-Server 1.0 - A networked event handling framework for hooking  into other programs. (DanielWilson)
08:42:28 * hackagebot Pup-Events-Demo 1.0 - A networked event handling framework for hooking  into other programs. (DanielWilson)
08:42:31 * hackagebot Pup-Events 1.0 - A networked event handling framework for hooking  into other programs. (DanielWilson)
08:44:20 <yitz> preflex: seen quicksilver
08:44:20 <preflex>  quicksilver was last seen on #haskell 1 day, 23 hours, 4 minutes and 59 seconds ago, saying: like, runs worst on sorted lists, or runs best when all items the same, etc
08:47:48 <Qrt> would it even be possible to make a functional efficient low-level language with no gc?
08:49:09 <Cale> You could avoid doing GC by having region inference.
08:49:43 <dmwit> Qrt: Check out "Guru".
08:50:34 <yitz> Cale: do you share my dislike of the idea of "classy-prelude"?
08:50:34 <dmwit> "The approach enables efficient, type-safe programming with mutable and aliased data structures, with explicit deallocation (not garbage collection)."
08:50:50 <dmwit> www.divms.uiowa.edu/~astump/papers/plpv10.pdf
08:51:03 <Cale> yitz: yes
08:51:16 <Cale> It's a silly idea
08:51:39 <Cale> why, are people seriously talking about it?
08:51:52 <yitz> Cale: i'm going to have to discourage someone at work who is gung-ho about it. can you pls help me design a strategy for that?
08:52:25 <Cale> I guess you could implement it and give it to them to try.
08:52:29 <Cale> heh
08:53:01 <yitz> Cale: my problem is that it seems so ridiculous and so against basic good haskell style that i can't really imagine in advance why they want to do this, and how to express why it's wrong
08:53:27 <dmwit> Is it really so ridiculous as all that?
08:53:46 <yitz> Cale: it's already a package on hackage. it's derived from previous work that the person at work has been using for several applications already.
08:53:57 <yitz> Cale: whatever shall i do?
08:54:01 <Cale> oh, wow
08:54:07 <dmwit> If it's so ridiculous, how come there's been so many attempts at similar things? Like edison for example.
08:54:36 <yitz> dmwit: at least edison doesn't fry the prelude
08:54:51 <dmwit> I mean, the Prelude isn't magical.
08:54:57 <Cale> If it's the same thing I've heard about, it should result in lots of ambiguous types and insanely constrained polymorphic things.
08:55:01 <yitz> dmwit: i think everyone thinks of trying to do this in their early years of haskell programming.
08:55:02 <dmwit> It was designed by people, too, and who's to say they didn't make a few mistakes?
08:55:16 <Cale> I don't think the Prelude is perfect
08:55:47 <Cale> But polymorphism without abstraction is bad.
08:56:02 <Qrt> hmm, do you play tic-tac-toe with 3 buttons each or you put circls and crosses until the board is full and then it is over?
08:56:30 <dmwit> Is this Haskell related?
08:56:39 <dmwit> Is there really no description of tic-tac-toe on Google?
08:56:47 <Cale> Oh, maybe this is slightly saner than I thought it was. I don't like the naming though.
08:56:53 <yitz> my general policy is if i think i need a type class, think again. and again. be really sure that this is exactly the abstraction i need and is worth the trouble over all the good alternatives, which always exist.
08:57:09 <yitz> dmwit: noughts and crosses?
08:57:27 <yitz> or is it *naughts
08:57:31 <Cale> I also don't like the design of any of the classes that it adds
08:57:44 <Cale> They're way too general to be meaningful.
08:57:45 <wrtg> Is there a Haskell library / Haskell Google API? I only could find something concerning Java / NET / Php ... at https://developers.google.com/youtube/code
08:58:59 <Cale> wrtg: Isn't it just HTTP and Atom?
08:59:05 <yitz> dmwit: the earliest full solution to the game i know of is in Winning Ways for your Mathematical Plays. byorgey wrote a series of posts with a haskell-based solution.
08:59:26 <wrtg> Cale: What is Atom?
08:59:43 <Cale> The file format that the data comes back in.
08:59:44 <dmwit> yitz: Why are you telling me this?
08:59:45 <yitz> Cale: i think they *want them to be as general as possible. they obviously think that's useful. i can't figure out why.
08:59:56 <yitz> dmwit: you asked about tic-tac-toe
09:00:04 <dmwit> Qrt asked about tic-tac-toe, not me.
09:00:11 <yitz> oh oops
09:00:53 <yitz> Qrt: see my msgs above about tic-tac-toe, mistakenly sent to dmwit
09:01:08 <yitz> dmwit: sorry. oh, you were answering Qrt, i see.
09:08:21 <nand`> wait
09:08:31 <nand`> what's the difference between ClassyPrelude and base Prelude?
09:08:44 <nand`> I scrolled through it but didn't see any substantial changes
09:09:03 <nand`> oh, nvm
09:09:06 <ocharles>  the difference is that ClassyPrelude uses type classes for all functions, instead of restricting the types
09:09:08 <nand`> I'm looking at the wrong documentation it seems
09:09:31 <nand`> ocharles: examples?
09:09:56 <Cale> wrtg: It looks like there's a lot of code out there for specific APIs, but not much of it is on hackage somehow
09:10:09 <ocharles> err, class CanHead c where head :: c a -> a
09:10:10 <ocharles> I guess
09:10:14 <ocharles> stuff like that
09:10:43 <nand`> that one isn't even listed on http://hackage.haskell.org/packages/archive/ClassyPrelude/0.1/doc/html/Prelude-Classy.html
09:11:00 <ocharles> ok, i was just making an example up
09:11:02 <Cale> wrtg: Actually, no, most of it is, it's just spread out a bunch :P
09:11:04 <ocharles> i don't use ClassyPrelude
09:11:09 <ocharles> but that's the idea behind ti
09:12:00 <ocharles> oh wait, I'm thinking of something different
09:12:09 <nand`> I swear, I'm going mad
09:12:26 <ocharles> I was thinking of http://www.yesodweb.com/blog/2012/07/classy-prelude
09:12:36 <ocharles> so yea, we now have classy-prelude and ClassyPrelude
09:12:37 <ocharles> great
09:12:40 <nand`> oh
09:12:42 <nand`> no wonder
09:12:47 <Cale> wrtg: https://www.google.com/search?q=Google+API+site%3Ahackage.haskell.org%2Fpackage
09:12:50 <nand`> I read through the ClassyPrelude doc like 3 times
09:12:59 <nand`> and tried to find a single function that had abnormal typeclass constraints on it :P
09:13:13 <Cale> (if you flip through the first few pages there)
09:13:19 <dmwit> nand`: (++)
09:13:59 <nand`> dmwit: but that's the thing, ClassyPrelude doesn't even have ++
09:14:02 <dmwit> Wait, there's ClassyPrelude and classy-prelude?
09:14:04 <dmwit> WTF
09:14:06 <ocharles> yep
09:14:37 <Cale> The idea that lists are bad is silly.
09:14:50 <dmwit> nand`: Basically everything here: http://hackage.haskell.org/packages/archive/classy-prelude/0.1.0.0/doc/html/ClassyPrelude-Classes.html
09:14:55 <nobdraisentone> Can someone explain how haskell packages is installing in nixos? For example, I've installed split but can't import it in ghci : http://pastebin.com/raw.php?i=gtpCw8pY
09:14:58 <mauke> The paste gtpCw8pY has been copied to http://hpaste.org/71541
09:15:02 <nand`> the only use of list typeclasses I see are overloading [] syntax for Set and Map
09:15:04 <yitz> oh interesting. Cale - i was talking about classy-prelude, not ClassyPrelude. was that clear?
09:15:10 <Cale> There are a lot of cases where lists are exactly the right thing to be using in almost every program.
09:15:12 <nand`> so you can type [1,2,3,4] to mean the set Set.fromList [1,2,4,5]
09:15:14 <nand`> 3,4 even
09:15:20 <Cale> yitz: yeah
09:15:29 <Cale> yitz: Well, it wasn't clear, but I didn't know about the other one
09:15:39 <yitz> Cale: heh. ok, good.
09:15:48 * nand` is to blame for the confusion
09:15:51 <Cale> The other one looks more reasonable to me
09:15:53 <nand`> I searched “classy prelude” on hoogle and that was the only result
09:16:00 <Cale> But still kinda sad
09:16:27 <nand`> isn't ++ mplus and not mappend btw? I thought <> was more common for mappend
09:16:43 <mcstar> so
09:16:44 <yitz> @type (++)
09:16:46 <lambdabot> forall m. (Monoid m) => m -> m -> m
09:16:47 <Cale> I think I like ++ for mappend
09:16:48 <nand`> oh
09:16:53 <nand`> @type (<>)
09:16:55 <lambdabot> Doc -> Doc -> Doc
09:16:57 <Cale> ^^ that's just in Lambdabot
09:16:58 <mcstar> i need to make a function, that returns, before it executes its body
09:17:04 <dmwit> mplus is just higher-kinded mappend anyway =)
09:17:10 <nand`> yeah, ++ is [] in prelude either way
09:17:24 * hackagebot confsolve 0.3.2 - A command line tool for resolving conflicts of file synchronizers. (DanielTrstenjak)
09:17:36 <Cale> mcstar: What does that mean?
09:17:36 * hayashi can't seem to wrap his noodle around using GHC.Generics to construct values in types deriving Generic from other values
09:17:47 <nand`> how does a function “return” and how does it execute its body?
09:17:54 <Cale> mcstar: First of all, what does it mean for a function to "return", yeah
09:18:04 <hayashi> going the other way is easy enough to understand, going from value to representation and then traversing the representation structure
09:18:10 * yitz heads for supper
09:18:20 <mcstar> im going to kill this first
09:18:39 <yitz> Cale: if you could keep me in mind, and come up with some ideas on how to approach this issue, i would really appreciate it
09:18:53 <mcstar> this fly*
09:19:02 <Cale> yitz: I think it might just come down to good/bad taste in libraries :P
09:19:12 <yitz> Cale: that's what i'm afraid of
09:19:22 <nand`> from the classy-prelude page “4. Try to find where you were in the code.” <- am I the only one that thinks this person doesn't know how to use their editor?
09:19:41 <yitz> Cale: i'm going to have to be working on this code in the near future.
09:19:45 <Cale> yitz: This classy-prelude is a bit more conservative than I thought it was. It's mostly just ugly rather than completely bad.
09:19:57 <mcstar> so, i need a function, that produces a result, before it has touched its arguments
09:20:11 <mcstar> if there was such a function, programming would be so easy
09:20:19 <nand`> also personally I just write <$> and then add the import when the compile fails
09:20:45 <nand`> f _ _ = ()
09:20:52 <nand`> produces a result before it touches its arguments
09:20:59 <yitz> Cale: interesting that you call it conservative. it warps just about every prelude function into a class method, leaving no stone unturned.
09:21:35 <Cale> yitz: It leaves Bool alone, oddly
09:21:49 <nand`> odd, I've wanted an overloaded Bool type in the past
09:22:11 <Cale> Yeah, that would be one of the first things I'd generalise, if I was going to start generalising everything.
09:22:21 <Cale> Have a Lattice hierarchy.
09:22:29 <Cale> But it's foolish to do that yet.
09:22:41 <Cale> Well, maybe not with the very latest extensions
09:23:00 <nand`> what I want to fix up is the functor hierarchy and the algebra hierarchy
09:23:45 <McManiaC> hi, is this somehow possible? http://npaste.de/Xw/
09:23:58 <Cale> What algebra hierarchy? :)
09:24:12 <nand`> Cale: Magma, Semigroup, Monoid, Group; etc.
09:24:30 <nand`> they should inherit their common functions
09:24:42 <nand`> possibly also add Unital, Loop, Quasigroup etc.
09:24:53 <Cale> McManiaC: iirc, ImpredicativeTypes were in some kind of disrepair? I'm not sure.
09:25:07 <Cale> nand`: mmm, maybe :)
09:25:08 <McManiaC> Cale: disrepair?
09:25:23 <McManiaC> oh nvm
09:25:42 <McManiaC> so it's kind of "deprecated"?
09:25:51 <Cale> McManiaC: At least, when GHC first switched to InsideOut(X), they were completely broken
09:26:51 <b52> hey fellas, is there a way to automate this: https://github.com/b52/projecteuler/blob/master/src/Euler/Problems.hs ?
09:26:54 <copumpkin> OutsideIn!
09:26:56 <McManiaC> Cale: is my example somehow possible without that extension?
09:26:58 <Cale> I don't know what their status is at present.
09:26:58 <Cale> er, OutsideIn(X) rather ;)
09:27:24 <nobdraisentone> b52: TH?
09:27:34 <b52> nobdraisentone: no idea what you mean
09:27:48 <McManiaC> template haskell b52
09:27:53 <McManiaC> but that's probably overkill
09:27:54 <b52> McManiaC: haha :D
09:28:00 <McManiaC> even haskell needs some bloat sometimes…
09:28:07 <b52> nah
09:28:16 <dmwit> Yes, SPJ has said that ImpredicativeTypes complicated GHC too much to be worth the payoff, and is awaiting a solid use-case before trying to fix them.
09:28:28 <b52> considering pe has about 300 problems ... that would be much bloat
09:28:38 <McManiaC> Cale: tl;dr on the OutsideIn thing?
09:28:43 <Cale> McManiaC: Why not just pre-apply the void method?
09:28:53 <Cale> I just had a 30+ second lag spike
09:29:18 <dmwit> b52: In my project euler file, I just have a function of type Integer -> Integer, and implement all of the answers in one module. =P
09:29:43 <dmwit> (The function is rather partial, in no small part because I'm terrible at PE problems.)
09:29:43 <nand`> () -> Int doesn't seem like an awfully useful function type to me
09:29:45 <Cale> McManiaC: I mean, I don't know what you're doing, but if all you know about these things is that they belong to a class whose sole method turns them into ()'s, then why not just use ()?
09:29:48 <McManiaC> Cale: well, because my "Test" class might have some more informations, but the end results should always be the same
09:30:19 <b52> nand`: i need to perform reasonable benchmarking
09:30:21 <Cale> McManiaC: In general, you could usually replace the Test class with a record of pre-applied methods
09:30:36 <optimight> #Emacs
09:30:55 <Cale> McManiaC: Or for example, if it were Show instead of Test, you could just use String
09:31:01 <mornfall> There's no Windows x64 platform?
09:31:47 <McManiaC> Cale: my application of this would be a "module" system for a small app I've written: http://npaste.de/hZmk/
09:33:27 <dmwit> Can't you use plain old existential types instead of impredicative types?
09:33:33 <McManiaC> theoretically I should be able to run the ModuleM's with "map (\m -> runReaderT (runModule m) (moduleState m)) modules"
09:33:54 <dmwit> data SomeModule where SomeModule :: Module s => s -> SomeModule
09:33:55 <McManiaC> dmwit: how do you mean?
09:34:15 <dmwit> or data SomeModule = forall s. Module s => SomeModule s -- if you prefer non-GADT syntax
09:34:34 <dmwit> and then modules :: [SomeModule]
09:34:56 <McManiaC> hmmm will try
09:35:35 <Cale> Or:  data Module st = Module { moduleName :: ModuleName, moduleState :: Maybe st, onNickChange :: Maybe (Username -> Nickname -> ModuleM st ()), runModule :: ModuleM st () }
09:35:44 <Cale> ^^ why not just do that?
09:35:56 <dmwit> You still can't store modules with different state types in a list with that, Cale.
09:36:02 <McManiaC> Cale: because you cant store multiple modules that way
09:36:06 <McManiaC> yeah
09:36:45 <Cale> Oh, you could just drop the state and have the methods return another module
09:36:53 <Cale> Good ol' functional programming
09:37:06 <dmwit> Yeah, that's not a bad idea.
09:37:11 <Cale> data Module = Module { moduleName :: ModuleName, onNickChange :: Maybe (Username -> Nickname -> ModuleM st Module), runModule :: ModuleM st Module }
09:37:23 <dmwit> Saving state between sessions is a bit harder, then, though.
09:37:42 <Cale> Yeah, but without further assumptions, it's already going to be hard
09:37:43 <dmwit> I guess you just add a "saveState" field to the record.
09:37:45 <dmwit> Yeah, I like that.
09:38:28 <Cale> oops, shouldn't have left in the st there
09:38:42 <nand`> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
09:38:46 <Cale> but you get the idea
09:38:50 <McManiaC> hmmm
09:39:04 <pqmodn> ah, i was thinking about that link also
09:39:10 <fabs_> Hello, i'm new to haskell, and i can't success to install last version of hledger-web with cabal : Depedencies issues
09:39:27 <McManiaC> Cale: where would I store the state there
09:39:37 <Cale> McManiaC: In parameters to a function which builds a Module
09:39:38 <McManiaC> the state is defined by the module, not the main lib
09:39:44 <McManiaC> oh
09:39:45 <Cale> McManiaC: (a recursive function)
09:39:46 <fabs_> is someone can show me the way to resolve my issue ?
09:40:26 <McManiaC> Cale: yeah i see
09:40:42 <fabs_> here what i've get when i try :
09:40:42 <fabs_> http://pastebin.com/nTqjMXgh
09:40:44 <mauke> The paste nTqjMXgh has been copied to http://hpaste.org/71542
09:41:39 <Cale> fabs_: hmmm...
09:41:57 <chrisdone> anyone know how to regexp-encode an arbitrary string in bash/unix commands? off-topic but it's for a cool haskell tool >_>
09:42:00 <wrtg> cale: thanks for hint! I'm especially interested in communicating with youtube, unfortunately I couldn't find anything on your searchpage
09:43:03 <chrisdone> hm, maybe grep -F
09:44:16 <chrisdone> nice, it works. grep -F '$' works as expected
09:46:14 <Kaidelong> http://hackage.haskell.org/packages/archive/sodium/0.5.0.1/doc/html/FRP-Sodium.html this looks quite promising, has anyone used it?
09:46:33 <McManiaC> but I think the existential typing works too, dmwit
09:47:07 <fabs_> Cale, : I've success to install fast-logger-0.2.0 and wai-logger-0.2.0 independently
09:52:38 <Kaidelong> oh wonderful
09:52:41 <Kaidelong> it doesn't build
10:02:29 * hackagebot histogram-fill 0.7.0.0 - Library for histograms creation. (AlexeyKhudyakov)
10:02:32 <stobix> hi! Is it possible to make a function foo so that foo [val,some,other,funs] mean funs$some$other$val?
10:02:57 <stobix> ehm. funs$other$some val, I mean
10:03:19 <ben> What's the type of that list?
10:03:27 <optimight> Is there any haskeller using emacs?  I have baby.hs in one window and another window has Main> prompt , How to change focus between two active windows?
10:03:56 <stobix> ben: exactly. That's where the problem lies. Functions of any arity, including 0? :)
10:04:16 <sepp2k> optimight: C-x o
10:04:20 <ben> I don't see it workin :) maybe foo [some,other,funs] val?
10:04:46 <stobix> ben: wouldn't that require the functions to have the same types, though?
10:04:50 <stobix> I guess the Real Question is "can I write haskell in a sort of rpn-ish way?"
10:04:51 <ben> yeah
10:05:11 <optimight> sepp2k: <o> is zero or 'O'
10:05:38 <stobix> 9<o> is also a guy with his arms around his head0
10:05:42 <pqmodn> stobix: this may be of interest https://github.com/leonidas/codeblog/blob/master/2012/2012-02-17-concatenative-haskell.md
10:05:49 <stobix> ( s/9/( etc )
10:06:11 <stobix> pqmodn: ooh! The title sounds promising
10:06:14 <optimight> sepp2k: Both of them are not working for me
10:06:16 <sepp2k> optimight: It's the lower case letter.
10:07:13 <optimight> sepp2k: Not working here    ..with lower case 'o'
10:07:53 <mcstar> C-x o changes focus between buffers
10:07:55 <mcstar> not windows
10:08:06 <mcstar> if the emacs is split
10:08:51 <optimight> mcstar: Yes , my emacs is split between two windows - want to switch between them
10:08:54 <sepp2k> mcstar: If emacs is split into two windows, C-x o will switch between them - independently of whether those windows display different buffers or not.
10:09:25 <mcstar> sepp2k: erm, you can split an emacs X window, between several bufffers
10:09:32 <mcstar> cxo cycles between those
10:09:45 <sepp2k> mcstar: I think you mean Frame when you say Window.
10:09:48 <mcstar> i guess he means switching between X windows
10:10:01 <optimight> sepp2k: This is not happening : "If emacs is split into two windows, C-x o will switch between them - independently of whether those windows display different buffers or not."
10:10:22 <sepp2k> optimight: When you say Windows, do you mean X windows (frames) or emacs windows?
10:11:11 <optimight> I have a baby.hs  and then I loaded it which splits my computer screen and opens up
10:11:31 <sepp2k> optimight: Okay, then I understood you correctly.
10:11:51 <optimight> sepp2k: those are windows , right?
10:12:00 <sepp2k> Unless you modified your keybindings, C-x o should do what you want then.
10:12:12 <sepp2k> Yes, they're what Emacs calls Windows.
10:13:13 <sepp2k> Note that C-x o  means "press x while holding down Ctrl, then press o (without holding Ctrl)". Are you doing that?
10:13:16 <optimight> sepp2k: I just installed emacs ..  nothing else  .. but the combination of keypress which you suggested is not working here,    I am ploughing through emacs.pdf but not finding any solution
10:15:17 <Kaidelong> so I'm not familiar with git ettiquite
10:15:32 <Kaidelong> I am pretty sure I could fix sodium very easily
10:15:32 <optimight> sepp2k: Yes .. found my mistake - I was pressing all the three keys parallel...     Now able to switch..   Thanks a lot
10:15:38 <Kaidelong> should I fork it?
10:15:54 <Kaidelong> can the fork be recombined when sodium itself is fixed?
10:16:41 <Saizan> afaik, you fork and then ask them to pull from your fork
10:17:18 <optimight> sepp2k: but still it goes via the region below - where commands can be given
10:18:27 <eviltwin_b> optimight: soubnds like you have a command that's partially complete.  c-x o to the minibuffer area then c-g to abort the pending command (or else finish it)
10:18:59 <mcstar> C-g is the first thing they teach you
10:19:04 <sepp2k> optimight: That shouldn't be open unless you've previously hit M-x or have a command that's waiting for input. Hit C-g to close it.
10:19:17 <mcstar> i guess you didnt take the advice of going through an emacs tutorial
10:19:33 <ocharles> ummmm. I'm trying to install `errors`, which depends on `either`. But for some reason, it's linking against `EitherT`
10:19:36 <ocharles> any idea wtf is going on?
10:19:54 <bobry> anyone using 'persisten' with MongoDB here?
10:20:23 <bobry> I wonder if it's possible to check if a value is in an array using 'persistent' filters
10:20:28 <optimight> mcstar: Sir, I have emacs.pdf open in front of me ... 595 pages ...  going through it ...
10:20:32 <c_wraith> ocharles: the very first version of errors used EitherT - are you installing an old version?
10:21:16 <mcstar> optimight: you dont need 595 pages to use emacs, but you might want to print a cheat sheet of the most frequent commands
10:21:59 <ocharles> c_wraith: i did have 1.0.0 installed, i just did a cabal update and reinstalled to 1.1
10:22:01 <optimight> mcstar: Sir, Where will I get that cheat sheet?  Please suggest.
10:22:01 <ocharles> maybe it was that
10:22:50 <ocharles> so if I have something that is act :: m (Maybe a), how do I get to EitherT e m a ?
10:23:06 <mhitza> if Haskell has homogenous lists, why is this possible?
10:23:08 <mhitza> :t [[],[[1]],[1]]
10:23:09 <lambdabot> forall t. (Num t, Num [t]) => [[[t]]]
10:23:15 <mcstar> optimight: 3rd result in google
10:23:17 <nand`> because [] and [1] can have coinciding tytpes
10:23:18 <nand`> types*
10:23:22 <Saizan> :t 1
10:23:24 <nand`> wait
10:23:25 <lambdabot> forall t. (Num t) => t
10:23:28 <mcstar> GNU Emacs Reference Card
10:23:30 <optimight> mcstar: yes ..sir downloaded it
10:23:34 <nand`> :t [[1], 1]
10:23:36 <lambdabot> forall t. (Num t, Num [t]) => [[t]]
10:23:40 <mcstar> optimight: pls, stop calling me sir
10:23:48 <nand`> mhitza: because ‘1’ is polymorphic
10:24:04 <nand`> mhitza: ‘1’ can match [1]; it just needs a (Num t, Num [t]) constraint like the one shown
10:24:08 <mhitza> nand`, I don't understand what that implies
10:24:17 <nand`> try it with something else
10:24:19 <mhitza> :t [[],[[2]],[2]]
10:24:20 <lambdabot> forall t. (Num t, Num [t]) => [[[t]]]
10:24:24 <nand`> :t [[], [['a']], ['b']]
10:24:26 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Char'
10:24:26 <lambdabot>     In the expression: 'b'
10:24:26 <lambdabot>     In the expression: ['b']
10:24:31 <Eduard_Munteanu> > [1] + [2]
10:24:32 <lambdabot>   No instance for (GHC.Num.Num [t])
10:24:33 <lambdabot>    arising from a use of `e_112' at <inte...
10:24:33 <optimight> mcstar: Will follow your instruction..
10:24:56 <Kaidelong> if you have a way to turn 1 into a list (it's an instance of Num) then it'd work
10:25:06 <nand`> mhitza: ‘1’ can mean any number type, including lists - if lists were numbers
10:25:16 <Kaidelong> hence why the type has that (Num [t], Num t) => in front of it
10:25:31 <nand`> if you actually try evaluating it, it fails
10:25:31 <Eduard_Munteanu> > [[],[[1]],[1]]
10:25:32 <mhitza> but is that valid for any instance of Num ?
10:25:33 <lambdabot>   No instance for (GHC.Num.Num [t])
10:25:34 <lambdabot>    arising from a use of `e_111' at <inte...
10:25:38 <nand`> > [[], [[1]], [1]]
10:25:40 <lambdabot>   No instance for (GHC.Num.Num [t])
10:25:41 <lambdabot>    arising from a use of `e_111' at <inte...
10:25:49 <Eduard_Munteanu> :t [1] + [2]
10:25:51 <lambdabot> forall t. (Num t, Num [t]) => [t]
10:26:02 <ocharles> noteT "Fail" (lift (getQueryParam "response_type") >>= liftMaybe) -- urgh, there must be a cleaner way of expressing that
10:26:02 <Taneb> > [1] + [2]
10:26:04 <lambdabot>   No instance for (GHC.Num.Num [t])
10:26:04 <lambdabot>    arising from a use of `e_112' at <inte...
10:26:10 <Taneb> :(
10:26:20 <ocharles> That's to turn a : m (Maybe a) -> EitherT e m a
10:27:24 <mhitza> ok then another question I have; can you explain ->
10:27:31 <mhitza> > ['a'..'z']
10:27:32 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
10:27:33 <mhitza> > ['a'..'Z']
10:27:35 <lambdabot>   ""
10:27:38 <mhitza> > ['A'..'z']
10:27:39 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
10:27:46 <Kaidelong> > 'Z' > 'a'
10:27:47 <lambdabot>   False
10:28:14 <Kaidelong> > 'z' < 'A'
10:28:15 <lambdabot>   False
10:28:20 <tgeeky_> mdmkolbe: ping?
10:28:49 <supercali> hi everyone .. just got exposed to Hoare logic and  the verification of loops ( that seems like a visit to the dentist )
10:29:17 <supercali> so I'm ready to convinced that a language with good denotational semantics is the way to go
10:29:34 <supercali> The thing is, I want to understand ... What's the catch ?
10:29:54 <dmwit> mhitza: .. counts up by ones by default unless you specify something otherwise.
10:29:56 <dmwit> mhitza: compare:
10:30:07 <dmwit> > ['a','`'..'Z']
10:30:08 <lambdabot>   "a`_^]\\[Z"
10:30:43 <dmwit> supercali: "catch"?
10:30:53 <supercali> What stops a Haskell runtime from addressing all usecases from system programming to web development ?
10:31:08 <dmwit> nothing?
10:31:12 <supercali> I basically want to understand the limits ..
10:31:14 <tgeeky_> that seems like a stretch from the first three lines, but nothing
10:31:38 <Kaidelong> the limits are mainly in terms of learning resources and libraries
10:31:45 <Kaidelong> the language and compiler are powerful enough
10:32:03 <supercali> i see .. hmm ..
10:32:05 <Kaidelong> the other hurdle is the level of abstraction
10:32:27 <ciaranm> the other other hurdle is that haskell uses megalots of ram
10:32:37 <Kaidelong> sometimes stuff is garbage collected by you're frequently working with C libraries
10:32:58 <Kaidelong> but*
10:33:08 <supercali> the level of abstraction is the most amazing thing for me actually ..
10:33:16 <Kaidelong> and there's no runtime type information like you have on something like .NET
10:33:35 <supercali> Kaidelong: and how does that hurt ?
10:33:36 <dmwit> There's runtime type information precisely when you ask for it.
10:33:44 <dmwit> Most of the time, you don't ask for it.
10:34:09 <Kaidelong> supercali: debugging and extending programs while they are running
10:34:12 <Kaidelong> of course
10:34:17 <Kaidelong> you could implement all that in haskell
10:34:35 <supercali> yeah .. that sounds like a problem for certain longrunning services ..
10:35:40 <Kaidelong> mm, don't really see how it would be
10:35:40 <supercali> that just sparked a new question .. how do you do Eclipse style plugin functionality then in Haskell ?
10:35:51 <ciaranm> huh?
10:36:05 <supercali> you don't know the final configuration of the system until you actually bring it up ..
10:36:17 <Kaidelong> you implement it. People have done that a lot already. GHCi has something like that I guess
10:36:26 <supercali> I see .. didn't know that ..
10:36:27 <dmwit> There's a few approaches.
10:36:33 <ciaranm> or you go the crazy xmonad approach
10:36:37 <dmwit> You can use the GHC API to interpret code in your currently running process.
10:36:50 <hpaste> ocharles pasted “error handling feels overly complicated” at http://hpaste.org/71543
10:36:51 <dmwit> You can compile a brand new executable and exec it (this is what xmonad and dyre do).
10:37:00 <supercali> that sounds like startup would be long.
10:37:07 <dmwit> You can use hsplugins; I'm not sure how that works but it's a bit old-fashioned now.
10:37:08 <ocharles> alright, that's what I ended up with. if anyone has experience with eithert, maybet, or errors, I'd love to hear your feedback
10:37:10 <dmwit> I don't know why.
10:37:14 <dmwit> lambdabot uses this approach.
10:37:15 <ocharles> (http://hpaste.org/71543)
10:37:26 <dmwit> supercali: hm?
10:37:31 <dmwit> "startup would be long"?
10:37:45 <Kaidelong> supercali: compiling a brand new executable and running it is basically how things like java work anyway
10:37:50 <supercali> yeah .. if you wait for something to compile
10:37:52 <Kaidelong> compiling doesn't have to take long
10:38:02 <supercali> no .. in Java you can load the bytecode, right ?
10:38:06 <dmwit> Only the new bits need to be compiled.
10:38:09 <Kaidelong> which gets JITed
10:38:12 <dmwit> Bytecode is the output of a compiler.
10:38:50 <supercali> hmm .. yeah, but I could atleast have a first run of non-JITed code , right ?
10:39:20 <Kaidelong> can you? Not familiar with javac's AoT features enough
10:39:23 <supercali> hotspot detection is a runtime optimization, right ?
10:39:29 <Kaidelong> yes
10:39:33 <Taneb> Is it possible to do qualified re-exports?
10:39:39 <Kaidelong> although
10:39:43 <dmwit> Taneb: no
10:40:28 <Kaidelong> hotspot detection is something a programmer can do by sampling users for profiling data, or running tests
10:40:37 <Qrt> what does it mean to do fixed point mathematics with regard to computer graphics?
10:40:42 <Taneb> dmwit, :(
10:41:23 <Saizan> Qrt: that you do arithmethic with a fixed number of decimals
10:41:34 <dmwit> Oh, that kind of fixed point.
10:41:52 <nand`> dmwit: so I wasn't the only one that thought it was about fixed point recursion?
10:42:10 <dmwit> nope =)
10:42:20 <supercali> Kaidelong: yeah ..
10:42:21 <Saizan> Qrt: Data.Fixed is an example in haskell
10:42:31 * hackagebot mainland-pretty 0.2.1 - Pretty printing designed for printing source code. (GeoffreyMainland)
10:42:53 <Kaidelong> supercali: Anyway if you are looking for a replacement to something like .NET or Python for the stuff that only those sorts of things can really do, Haskell isn't it. Haskell is pretty much good at anything you'd like to use C for though, and most of what application developers actually do
10:43:07 <Kaidelong> or it would be with a more robust ecosystem and with something nicer than cabal
10:43:30 <supercali> Kaidelong: interesting ..
10:43:35 <Kaidelong> and with a proper development environment
10:44:27 <supercali> are there some "recommended libraries" lists ?
10:44:31 <Kaidelong> essentially I guess it could be seen as being like D
10:44:36 <Kaidelong> a better C++
10:44:41 <supercali> hm .. true ..
10:44:49 <Kaidelong> although
10:45:02 <Kaidelong> that's not really true because there is a runtime and you do get memory management
10:45:11 <supercali> sure ..
10:45:32 <Kaidelong> also supercali there is the haskell platform but it is rather bare
10:45:41 <Kaidelong> there is hackage and github
10:45:58 <supercali> yeah .. but its like an unlimited buffet ;) !
10:46:00 <Kaidelong> but usually the only way to know what to use is ask around and hope some other people have already done it
10:46:14 <supercali> yeah .. i guess that's what #haskell is for ..
10:46:22 <supercali> :)
10:46:32 <Kaidelong> well you'd probably be better off with the mailing list
10:47:13 <supercali> Cool .. gotta go now, was a nice chat ! Enjoy the rest of the weekend, y'all :) !!
10:47:50 <monochrom> begin with the haskell platform anyway
11:23:48 <optimight> I am not able to find out the blog or article, but it was suggesting that .hs in which I am writing functions can also have integrated test mechanism in it, If somebody knows such source please suggest.
11:28:19 <akamaus> Hi. I need some quick serialization for Data.Map. What do you suggest?
11:28:25 <mauke> show
11:28:36 <replcated> What is the diffence between the 'x <- someThing' syntax and 'let x = ...'?
11:28:42 <akamaus> quick = performant
11:28:57 <mauke> replcated: 'let' simply binds a name to a value
11:28:58 <akamaus> better binary format
11:29:07 <srhb> replcated: It has to do with monads and do syntax. x <- foo is equivalent to foo >>= \x -> ...
11:29:16 <mauke> replcated: 'do { x <- someThing; ...}' is syntactic sugar for 'someThing >>= (\x -> do ...)'
11:29:44 <mauke> that is, this 'x' is actually a function parameter and the meaning of the whole thing depends on what >>= does
11:30:16 <srhb> replcated: Which varies based on the specific monad you're dealing with.
11:30:18 <nand`> do { let x = someThing; ... } is just let x = someThing in do { ... } right?
11:30:26 <srhb> > Just 1 >>= return . (+1)
11:30:30 <lambdabot>   mueval-core: Time limit exceeded
11:30:36 <srhb> > [1,2,3] >>= return . (+1)
11:30:38 <nand`> unless there's something deeper about recursive do blocks etc. I'm missing here
11:30:39 <lambdabot>   [2,3,4]
11:30:41 <srhb> > Just 1 >>= return . (+1)
11:30:45 <lambdabot>   Just 2
11:31:00 <mauke> nand`: you can always check with @undo
11:31:12 <nand`> @undo { let x = (); return x }
11:31:13 <lambdabot>  Parse error at "{" (column 1)
11:31:18 <nand`> @undo do { let x = (); return x }
11:31:19 <lambdabot>  Parse error at "}" (column 27)
11:31:23 <nand`> @undo do { let x = (); return x; }
11:31:23 <lambdabot>  Parse error at ";" (column 26)
11:31:26 <nand`> hmm
11:31:35 <mauke> @undo do let { x = () }; return x
11:31:36 <lambdabot> let { x = ()} in return x
11:31:37 <srhb> @undo do { let x = (); return x }
11:31:37 <lambdabot>  Parse error at "}" (column 27)
11:31:41 <srhb> urr.
11:31:46 <applicative> akamaus: cereal has an instance for Map, for starters
11:31:48 * mauke wins. fatality.
11:31:53 <srhb> mauke: ++
11:32:30 <akamaus> applicative, how does it compares to binary it terms of performance?
11:34:36 <applicative> dunno, have you tried binary?
11:35:05 <replcated> Thanks all. That helps.
11:36:07 <akamaus> applicative, I haven't yet. But I tried cereal. Profiling shows It's a main cpu consumer.
11:41:54 <applicative> putMapOf pk pa = putListOf (putTwoOf  pk pa) . toAscList doesn't seem too good akamaus :(
11:42:13 <janiczek> @help minus
11:42:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:42:23 <janiczek> @list
11:42:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:42:38 <applicative> akamaus: what are keys and things in the Map?
11:43:05 <janiczek> @src minus
11:43:06 <lambdabot> Source not found. I feel much better now.
11:43:18 <Eduard_Munteanu> @src Num
11:43:18 <lambdabot> class  (Eq a, Show a) => Num a  where
11:43:18 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:43:18 <lambdabot>     negate, abs, signum     :: a -> a
11:43:18 <lambdabot>     fromInteger             :: Integer -> a
11:43:48 <janiczek> @hoogle minus
11:43:49 <lambdabot> Foreign.Ptr minusPtr :: Ptr a -> Ptr b -> Int
11:43:49 <lambdabot> Foreign.C.Error throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
11:43:49 <lambdabot> Foreign.C.Error throwErrnoIfMinus1_ :: Num a => String -> IO a -> IO ()
11:44:05 <akamaus> applicative, do you mean cereals? Keys are values of type Point !Int !Int, values are of type with about ten constructors. Most of them are nullary.
11:44:56 <applicative> akamaus, I meant the map you are cereal-izing
11:44:58 <applicative> grr
11:45:16 <akamaus> applicative, yeah, I told you about it
11:45:29 <akamaus> applicative, I asked about the code you posted
11:49:48 <applicative> akamaus: sorry, that was the instance for Map from cereal. It looks like a loser to begin with because of the mediation by the list  type
11:50:50 <akamaus> applicative, can you tell, if instance from binary is any better?
11:51:49 <ksf> how am I supposed to (naturally) write parsers of the form "a, unless it matches b" in one of the frameworks?
11:52:10 <ksf> packrat parsers come with that combinator by default, but I'm sceptical about them
11:52:18 <ksf> (for one, peggy seems dog slow)
11:52:36 <akamaus> applicative, instance (Ord k, Binary k, Binary e) => Binary (Map.Map k e) where
11:52:36 <akamaus>     put m = put (Map.size m) >> mapM_ put (Map.toAscList m)
11:52:36 <akamaus>     get   = liftM Map.fromDistinctAscList get
11:52:58 <akamaus> I guess it has the same problem, hasn't it?
11:54:09 <applicative> akamaus: yes, I'm not sure it's a problem, but it seems likely
11:54:30 <akamaus> applicative, can you give some hints how to write more efficient version?
11:55:06 <akamaus> actually, I need this to implement hashing
11:55:27 <akamaus> so decoding is not needed :)
11:57:19 <Qrt> How is Haskell good for anything that C is? how can that possibly be correct? you want to program an OS in Haskell or program numerical stuff or heavy data processing?
11:57:54 <Qrt> would it even be possible to make a functional efficient low-level language with no gc?
11:58:49 <simon> I may be doing something wrong, but can I do something similar to pattern matching x:xs out of a Data.Set? (acknowledging the operation might be O(lg n) rather than O(1)).
11:58:59 <ksf> there's actually an OS implemented in haskell.
11:59:18 <Qrt> i know but would u use it?
11:59:19 <ksf> Qrt, and to the gc thing, probably yes.
11:59:38 <ksf> woudl you use *any* of the gazillion proof of concept OSs around?
11:59:42 <Qrt> hard realtime embedded systems?
11:59:47 <ksf> be they written in C or whatnot?
12:00:05 <ksf> haskell's propably the wrong answer, there, functional programming is still the right one, though.
12:00:20 <ksf> have a look at e.g. timber, disciple or even plain old ocaml.
12:00:33 <simon> what I've got now is: let (x, xs) = (head (Set.fromList s), tail (Set.fromList s))
12:00:40 <Kaidelong> Qrt: the proof of concept is out there anyway
12:01:06 <Qrt> functional programming without gc, how would that work?
12:01:35 <Qrt> garbage collection and hard realtime dont go well mtogether, do they?
12:01:41 <McManiaC> is there a type inequality thing? the opposite of for example "Monad m, Monad n, m ~ n => ..."
12:01:48 <ClaudiusMaximus> @hoogle minView
12:01:49 <lambdabot> Data.IntMap minView :: IntMap a -> Maybe (a, IntMap a)
12:01:49 <lambdabot> Data.IntSet minView :: IntSet -> Maybe (Int, IntSet)
12:01:49 <lambdabot> Data.Map minView :: Map k a -> Maybe (a, Map k a)
12:02:06 <Kaidelong> you can make garbage collectors that work relatively well latency wise but the general solution does seem to be not to use garbage collection
12:02:08 <simon> Qrt, I suppose GC could be handled by a coprocessor.
12:02:37 <ksf> or you could use regions.
12:02:41 <Kaidelong> monadic regions would be one such an approach
12:02:47 <Kaidelong> what ksf said
12:03:45 <ksf> disciple is probably going to have regions, it'd be a shame not to do it given its low-level focus and the fact that it already has regions for other reasons.
12:04:20 <Kaidelong> wasn't there a haskell compiler that already used them?
12:04:22 <Kaidelong> JHC?
12:05:47 <ksf> quick puzzle: I have parsers for CVCCV as well as CVC, CCV and CVV. I want to parse all possible sequencences of the latter three but never match CVCCV while doing that, and have to end with a V.
12:06:20 <ksf> e.g. CVC CVC would match CVCCV, too, so it's forbidden.
12:07:23 <applicative> simon, you can't pattern match on Set, you can use functions like ClaudiusMaximus was suggestion
12:08:28 <applicative> e.g. let (x,xm) = deleteFindMax mymap
12:08:51 <JoeyA> ksf: Are you parsing a string directly, or using a parser combinator library?
12:09:48 <ksf> I'm using uulib, right now.
12:09:55 <JoeyA> I'm thinking you could write a takeUntil :: String -> String -> Maybe String function that lazily consumes input, and rejects it if it sees "CVCCV".
12:10:09 <JoeyA> But that might not work out for a parser generator.
12:10:15 <ksf> yeah I'm quite sure that it's implementable, too :)
12:10:51 <JoeyA> An automaton that rejects any occurrence of CVCCV could be implemented using finite space.
12:11:06 <ksf> it's especially annoying as I think all I want to do is strictly regular, and regular grammars are closed under negation.
12:11:16 <ksf> inversion?
12:11:21 <ksf> no idea what's the right term.
12:11:41 <JoeyA> And the automaton matching ("CVC" | "CCV" | "CVV")* would take finite space, as it's a regular expression too.
12:12:09 <JoeyA> And since running both automata in parallel would take finite space too, this should be a regular expression.
12:12:24 <ksf> so far everything I wrote is non-loopy appplicative, so the chances it's all regular are excelent.
12:13:59 <stwien> could someone perhaps help with a cabal error regarding the reinstallation of package enable-shared?
12:14:16 <stwien> its the error "Perhaps you haven't installed the "dyn" libraries for package"?
12:14:51 <JoeyA> ksf: So in general, the question is how to compose two regular expressions such that the string must match both.
12:15:15 <JoeyA> Thus, it's not "sum" in that either can match, and it's not "product" in the usual way (sequence).  It's just "and".
12:15:44 <ksf> composing the automata is easy.
12:15:59 <ksf> ...but the automata aren't the expression.
12:16:04 <stwien> I have tried to use the ubuntu package 'ghc-dynamic', but is it possible to install the haskell platform manually with shared/dynamic support?
12:17:03 <ksf> you take two dfas, insert an epsilon -> start1 and epsilon -> start2 node, then reduce your NFA to a DFA, again.
12:17:52 <JoeyA> Wouldn't that be an OR relationship instead of AND?
12:18:03 <ksf> oh, yes.
12:19:53 <JoeyA> Perhaps it would help to form the inverse of .*CVCCV.* as a regular expression.
12:20:22 <Cale> Construct a DFA on the product of the vertices of the original DFA with the transition function delta((x,y),a) = (delta(x,a), delta(y,a)) (where the deltas are in the new DFA, and the two old ones respectively)
12:20:25 <JoeyA> Then maybe it will turn out easy to "zip" the resulting regex with the original.
12:20:28 <ksf> de morgan's laww.
12:20:53 <ksf> l /\ k = not (not l \/ not k)
12:21:07 <Cale> and the set of accept states are the set of pairs of accepting states in the original DFAs
12:21:36 <Cale> and of course, the start state is just the pair of start states
12:22:22 <Cale> then if a word is accepted by this new DFA, it would have been accepted by both of the original ones
12:22:33 <dmwit> Qrt: I answered you last time you asked that. Did you miss the answer, or are you willfully ignoring it?
12:22:50 <Cale> JoeyA: make sense?
12:23:00 <dmwit> (re: "functional programming without gc, how would that work?")
12:23:07 <Cale> product of the vertices of the original DFAs*
12:23:14 * JoeyA redirects to ksf
12:23:19 <Cale> i.e. Q_1 x Q_2
12:23:32 <Qrt> does finite state machines have anything to do with regexps?
12:23:34 <Cale> Oh, is it ksf asking?
12:23:38 <Cale> Qrt: yes
12:23:48 <Cale> Qrt: They are essentially the same thing
12:23:56 <ksf> the eeriest DFA transformation is minimise == determise . reverse . determise . reverse
12:24:15 <Qrt> A dude at my college was extremely condescending towards me for suggesting it...
12:24:24 <Cale> Regular languages are those languages matched by deterministic finite automata and are also exactly those described by regular expressions
12:24:44 <ksf> Cale, I'm not so much asking as complaining about the lack of a library that provides regular language combinators.
12:24:49 <Cale> oh
12:24:58 <Cale> In that case, I have to agree with you completely
12:25:00 <ksf> once tried to write one, but got stuck in the syntax.
12:25:00 <Qrt> automata=state machines?
12:25:07 <ksf> yep.
12:25:10 <ksf> DFA and NFAs
12:25:15 <Cale> Traditional syntax for regular expressions leaves out so many useful operations on regular languages.
12:25:31 <JoeyA> Maybe he was thinking of those obfuscated things people call "regex" that parse HTML and tell you if it's a valid email address consisting solely of prime numbers.
12:25:48 <ksf> threading <*> through the transformations is daunting.
12:26:04 <dmwit> The magic of regexp libraries is that they happen to conflate the alphabet of the language they're matching against and the alphabet used to describe the regex.
12:26:14 <ksf> and applicative is, strictly speaking, way too powerful.
12:26:22 <ksf> need to forbid at least open recursion.
12:26:50 <dada_cetacean> is init defined as reverse tail reverse xs?
12:27:03 <Cale> dada_cetacean: It's not, but it might as well be.
12:27:15 <Cale> Actually, no
12:27:22 <Cale> That would have different semantics
12:27:24 <Cale> on infinite lists
12:27:27 <Cale> > init [1..]
12:27:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:27:35 * hackagebot hoogle 4.2.12 - Haskell API Search (NeilMitchell)
12:27:37 <Cale> > reverse . tail . reverse $ [1..]
12:27:41 <lambdabot>   mueval-core: Time limit exceeded
12:27:43 <dada_cetacean> :(
12:27:58 <Cale> init [x] = []
12:28:05 <JoeyA> > filter (<10) [1..] -- Haskell is not magic.
12:28:06 <Cale> init (x:xs) = x : init xs
12:28:09 <lambdabot>   mueval-core: Time limit exceeded
12:28:11 <Qrt> JoeyA: what is that?
12:28:43 <Qrt> im talking about regexps as found in most programming languages hwere you can match according to some pattern for example python has a module called re (i think it has)
12:28:51 <Cale> > take 9 . filter (< 10) $ [1..]
12:28:53 <lambdabot>   [1,2,3,4,5,6,7,8,9]
12:29:03 <Qrt> or perl
12:29:18 <Cale> Qrt: perl's extensions to regexps have made them non-regular
12:29:21 <JoeyA> Qrt: I was being tongue-in-cheek with the prime number rant.
12:29:36 <Cale> So they shouldn't be called regular expressions anymore, they should be called parsing expressions or something
12:29:54 <Qrt> ok, but you could still use FSMs to model them?
12:29:59 <Cale> no
12:30:06 <eviltwin_b> perl calls them, regex and notes that they are in fact no longer truly regular expressions
12:30:15 <Qrt> what is a regular expression then?
12:30:16 <Cale> The extensions also give up the efficient implementation
12:30:43 <Cale> Perl's implementation of regular expressions is exponentially slower on some inputs than a DFA implementation would be
12:31:03 <Qrt> but they can what, match more things than regexps?
12:31:09 <Willfarb> Hullo there; I have an enum type " data Fruit = Apple | Pear | Durian deriving (Show) " and a function that returns a Fruit. I would like to use guards to compare a returned Fruit with an in-line one "... | aFruit == Durian = result, | aFruit == Pear = result..." - but I cannot. Equals is not defined on my Fruit type. What's the simplest/shortest/most idiomatic way to solve this?
12:31:24 <JoeyA> Qrt: Regular expressions can match exactly the same things as a finite state machine.
12:31:36 <Qrt> ok, which in turn is?
12:31:48 <Mortchek> Willfarb, just derive Eq
12:31:56 <ksf> Qrt, all regular languages.
12:32:32 <ksf> languages constructable by union, sequence and kleene-star (*)
12:32:34 <Qrt> an email is a regular langauge?
12:32:38 <ksf> ...*without* recursion.
12:32:45 <eviltwin_b> Willfarb: change deriving (Show) to deriving (Show, Eq)
12:32:52 <jedai> Qrt: http://en.wikipedia.org/wiki/Regular_language
12:32:54 <Willfarb> Mortchek++
12:33:07 <Willfarb> Thanks guys, it works, how do I do the rep ++ thing?
12:33:16 <eviltwin_b> we don't, mostly
12:33:38 <JoeyA> data Regex a = EmptyString | Singleton a | Regex a :+ Regex a | Regex a :* Regex a | Star (Regex a)
12:33:46 <jedai> Qrt: That don't make much sense ? _An_ email isn't a language
12:34:00 <JoeyA> Where :+ means union (a|b in traditional syntax)
12:34:09 <JoeyA> and :* means concatenation (ab)
12:34:22 <Qrt> jedai: but could emails be expressed in one?
12:34:25 <Cale> A regular expression consists formally of one of the following cases (though often another notation is adopted, I'm going to give the mathematically pretty version): 0 (matches nothing), 1 (matches the empty string), any symbol character x in the pre-determined alphabet, and where u and v are regular expressions: u + v (matches if either u or v matches), uv (matches strings which consist of a string matched by u concat
12:34:25 <Cale> enated to a string matched by v), and u* (matches zero or more concatenated strings matched by u)
12:34:29 <jedai> Qrt: Do you mean pop/smtp/email adress ?
12:34:59 <Cale> (sometimes 0 is left off, like JoeyA did)
12:35:02 <Qrt> name.lastname@domain.com
12:35:09 <JoeyA> Cale: Indeed.  I was about t say that.
12:35:09 <ksf> Cale, that's nice. now thread an applicative through that.
12:35:19 <JoeyA> to*
12:35:26 <ksf> TBH, I probably should just read up on grouping.
12:35:28 <jedai> Qrt: Ok, so adress then, the answer would be yes
12:36:09 <Qrt> so perl regexes can match more things than real regular expression?
12:36:17 <ksf> yep
12:36:21 <jedai> Qrt: Though the specification is often more complicated than what you would believe at first sight
12:36:33 <ksf> real regexes always match in linear time and constant space.
12:36:46 <Cale> The *actual* syntax of email addresses is way more complicated than people usually realise
12:36:51 <jedai> Qrt: perl regex are turing complete since you can include arbitrary perl code in them
12:36:53 <Qrt> am i an idiont for suggesting perl-ish regexes could have something to do with finite state machines?
12:36:53 <ksf> or, well, space linear in the number of states, not in the number of input symbol.
12:37:04 <dmwit> So, is aeson the de-facto standard for JSON stuff? Are there other options?
12:37:09 <Cale> It's just that 99.9% of everyone has an email address which fits into a much simpler syntax
12:37:11 <ksf> Qrt, well, historically they have.
12:37:27 <jedai> Qrt: even omitting this feature, you still have much more power than normal regular expressions
12:37:50 <JoeyA> For those who were enrolled in the Compilers course on Coursera, I described the + and * analogy of regular expressions here: https://class.coursera.org/compilers/forum/thread?thread_id=187
12:38:07 <Cale> Qrt: perl regexes have a feature called backreferences which can't really be implemented using finite state machines
12:38:29 <jedai> And that's only the beginning !
12:39:40 <McManiaC> is there any way to make sure two type variables are NOT equal?
12:39:42 <Cale> Of course, as a finite state machine myself, I have trouble implementing them.
12:39:47 <jedai> But I believe extending regexes with warts as Perl did isn't a good idea (and I say that as a Perl fan).
12:40:08 <Cale> McManiaC: I'm going to go with no on that one
12:40:46 <Cale> Oleg might be able to do it?
12:41:03 <mcstar> oleg already did it
12:41:14 * mcstar kids
12:41:51 <mauke> backreferences aren't a perl invention, and that alone makes regexes very irregular
12:42:07 <jedai> Couldn't it be done with overlapping instances ?
12:42:56 <Cale> http://homepages.cwi.nl/~ralf/HList/paper.pdf he discusses it in this paper
12:42:57 <mcstar> or just by making up dijoint typeclasses?
12:43:05 <dmwit> Cale: But you have some paper, so you're capable of irregularity, too. =)
12:43:17 <byorgey> McManiaC: Oleg has indeed described a way to dispatch on type class instances, which involves checking inequality of types
12:43:23 <jedai> mcstar: You can't do that : there is no Not in constraint
12:43:32 <byorgey> I'm not sure if it's quite the same thing though.
12:44:47 <dmwit> Actually, I guess there's rather a lot of JSON packages on Hackage. So that's fun.
12:44:49 <mcstar> jedai: his original example was: Monad m, Monad n, n != m; couldnt this be done with A n, B m, (Monad m, Monad n, A n, B m) =>    ?
12:45:19 <mcstar> if it doesnt make sense, pardon me
12:45:45 <Cale> What are A and B? Nothing about that seems to imply that n and m are unequal
12:46:12 <mcstar> A and B are typeclasses, but A has n as an instance, and B has m,
12:46:18 <mcstar> so they are disjoint in this sense
12:46:27 <Cale> A m could have an instance in a future module
12:46:42 <jedai> mcstar: I'm not sure I follow you, you could only have monad that have an instance of A and monad that have an instance of B, you could partition your space but that the best you could do and A and B would have an awful lot of instances
12:47:17 <jedai> And of course any "new monad" wouldn't have the right instances
13:04:04 <RogueShadow> Go me, I recommended haskell to somebody who asked what to learn next. And i'm totally useless with it! :D
13:04:52 <shapr> RogueShadow: You can get better here :-)
13:04:58 <RogueShadow> I also mentioned that. :D
13:05:51 <mroman> I always recommend haskell and make fun of my professors not knowing haskell ;)
13:06:33 <RogueShadow> It's amazing how many people teach things, because they can't find/pay better teachers to do it. And still charge an arm and a leg (almost literally) to take thier class.
13:06:36 <shapr> I recommend Haskell, but making fun of my professors never works out well for me.
13:07:10 <ment> i recommend cobol
13:07:35 <mroman> shapr: How so?
13:07:36 <schlicht> how many of you actually pay the bills with haskell?
13:07:46 <unlink> yo
13:07:56 <shapr> schlicht: I'm making money writing Haskell for GSoC, does that count?
13:08:03 <RogueShadow> heh, I'd be happy to pay the bills with anything tech related.
13:08:11 <shapr> mroman: Eh, my professors get upset when I tease them, so I stay quiet mostly.
13:08:16 <ment> RogueShadow: even cobol?
13:08:51 <schlicht> shapr, i think so :) care to tell me a little bit about your work?
13:08:51 <RogueShadow> It would be a start, don't diss the start. :D
13:09:04 <mroman> If a professor states incorrect facts I correct them.
13:09:09 <chidy> if I have to write a line of cobol, i'll retire
13:09:11 <mroman> No matter the consequences.
13:09:12 <shapr> schlicht: read the blog? http://ghclive.wordpress.com/
13:09:25 <schlicht> cool thank
13:09:27 <schlicht> s
13:10:11 <shapr> Though right now I'm trying to figure out cross origin resource sharing.
13:10:12 <mroman> Although that is not actually making fun of them.
13:10:52 <mroman> But I made fun of my UML professor for not even knowing the functional paradigm :)
13:11:53 <schlicht> hehe Apfelmus
13:12:42 <Qrt> hmm i like organizing my code as functions over structures rather than functions belonging to structures, is that inherintly functional? I mean you do that in C too basicaly and C sure isnt functional. I just dont see why i have to stick functions to a particular object.
13:13:27 <shapr> Qrt: It's certainly close to FP than OOP
13:13:42 <nand`> I wouldn't say FP disagrees with that
13:13:43 <shapr> closer*
13:14:25 <nand`> I think the spirit of FP is tangential to whether or not you have first class functions in your data, since even non-functional languages can do that
13:14:40 <RogueShadow> Last time I corrected my boss, or tried to. He hung up on me, twice. :D Forget telephone. And it wasn't tech related, at all.
13:14:43 <nand`> it's more about the properties your functions have
13:20:31 <jedai> There's different point of view on FP, I would say that any language that reduce to a form of lambda calculus even with extensions
13:20:49 <jedai> can be claimed to be functional without much doubt
13:22:30 <jedai> Haskell try to be purely functional though and thus has to present much stronger properties (or rather has to reduce to a pure lambda calculusulus without too much rearrangement)
13:22:51 <nand`> to me, the tenets of FP are referential transparency; and using application/abstraction to build up your control structures
13:22:59 <nand`> instead of relying on underlying semantics
13:23:11 <jedai> nand`: I would call that the tenets of pure FP
13:23:33 <nand`> jedai: I don't have an awful lot of respect for non-pure languages
13:23:53 <jedai> Though I think pure FP is much more interesting than compromised FP languages
13:24:26 <nand`> jedai: the problem is that if you broaden the definition then you can probably classify pretty much every common language as “functional” even though they're entirely different in nature
13:24:40 <jedai> nand`: I can have respect for them as long as they don't pretend to be pure
13:25:20 <jedai> nand`:  Well I was talking in practice reduced to an equivalent of \calculus, not just in theory
13:25:34 <nand`> well, I can appreciate if a language is designed with a certain purpose in mind - but I'd consider them more or less esoteric. Some languages may have been necessary at the time, but that doesn't mean we should continue using them today
13:25:50 <jedai> Cobol... ;)
13:25:59 <nand`> ...and some languages never had a purpose
13:26:18 <mroman> Argh. Cobol.
13:26:19 <mroman> Shh.
13:26:46 <jedai> Well Brainfuck had a purpose... though writing program in it was never part of it
13:26:48 <Qrt> python hads first clss functions but sure isnt functional although you can choose to write ina very functional style
13:26:54 <mroman> In my culture speaking of the devil is not something one should do.
13:27:04 <nand`> jedai: exactly. that's why it's an esolang :P
13:27:13 <mroman> Qrt: There are functools.
13:27:27 <mroman> And using function decorators you can get pretty much everything from functional programming.
13:27:28 <jedai> Qrt: Right, Python isn't reduced to anything close to lambda-calculus, I wouldn't classify it as FP in anyway
13:28:10 <jedai> mroman: Sure but it's just elements of FP added to a fundamentally imperative language
13:28:16 <mroman> It's not beautiful, but it'll work.
13:28:23 <mroman> jedai: Agreed.
13:28:37 <jedai> mroman: I don't have anything against Python by the way
13:29:14 <donri> are there any other filename extensions used besides .hs, .lhs, .hsc and .hsx?
13:29:16 <mroman> jedai: I wouldn't mind if you had ;)
13:29:25 <mroman> I only use python for golfing.
13:29:35 <mroman> And to 99% I only use haskell for golfing.
13:29:49 <zzing_> What is the correct way to do something like ceil(sqrt(n))   where n is an Int? (original function came from C).
13:29:49 <herpladee> hey guys i have a problem, i get an error when i try to cabal install boomerang
13:29:54 <nand`> jedai: I'd say referential transparency captures the “essence” that is functions for me because it introduces the equivalence classes at the heart of defining objects mathematically: if the definition is interchangeable with the result, then the object is interchangeable with its program
13:29:57 <jedai> Just trying not to enter a language debate
13:29:57 <herpladee> and i'm unsure what to do about this
13:30:03 <herpladee> http://hpaste.org/71529
13:30:05 <herpladee> this is the error i get
13:30:13 <herpladee> does anybody have a clue?
13:30:19 <herpladee> i reinstalled ghc and cabal just yesterday
13:30:24 <nand`> zzing_: ceiling . sqrt
13:30:25 <herpladee> removed .ghc and .cabal
13:30:26 <mroman> jedai: Ah. Precautious.
13:30:40 <jedai> nand`: I completely agree with that, equational reasoning is at the heart of what makes FP powerful in my opinion
13:30:41 <mcstar> ceiling . sqrt . fromIntegral
13:31:42 <zzing_> :t ceiling . sqrt . fromIntegral
13:31:44 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
13:31:55 <zzing_> oh I like that, thank you
13:37:38 * hackagebot pandoc-unlit 0.1.0 - Literate Haskell support for GitHub's Markdown flavor (SimonHengel)
13:40:00 <dmwit> herpladee: Not much for it; you'll just have to open up the source and try to spot the problem.
13:40:18 <zzing_> Concerning primes, what can be done with this (short) code to make it not look like crap? http://hpaste.org/71550     I converted it from C.
13:40:19 <herpladee> dmwit, but other people can do it
13:40:25 <herpladee> some other guy tried cabal install boomerang
13:40:27 <herpladee> and it worked for him
13:41:18 <monochrom> it builds fine for me. ghc 7.4.2
13:41:20 <applicative> herpladee: what ghc version are you using
13:41:25 <herpladee> i don't know
13:41:26 <dmwit> Ask him his GHC version and the versions of all libraries in the boomerang dependency chain.
13:41:29 <dmwit> Then duplicate that.
13:41:35 <herpladee> 6.12.1
13:41:35 <applicative> ghc -V
13:41:38 <applicative> aha
13:41:46 <applicative> hm, what operating system?
13:41:50 <herpladee> linux/ubuntu
13:42:30 <dmwit> If you don't want to duplicate his setup... well, then, open up the source and try to spot the problem.
13:42:31 <monochrom> I can test 6.12.1 here too
13:42:59 <herpladee> dmwit, that's not an option
13:43:11 <herpladee> since i am pretty terrible at haskell
13:43:16 <herpladee> monochrom, that would be nice thanks
13:43:26 <herpladee> do i want to upgrade ghc?
13:43:48 <otters> what's the biggest weak point of haskell?
13:43:55 <otters> things that are easiest in other languages I mean
13:44:40 <mroman> Mutable arrays :D?
13:44:59 <mroman> Library version compatibility?
13:45:30 <monochrom> well, it will take a while because I first have to build recent versions of mtl and text
13:47:55 <monochrom> yeah ghc 6.12.1 has a compiler error on boomerang file 8
13:48:59 <herpladee> meh
13:49:00 <applicative> it's a fairly recent library, I think he may never have contemplated ghc-6*
13:49:03 <herpladee> what do i do about that?
13:49:44 <nand`> jedai: btw, earlier you said functional languages are one that reduce to the/a lambda calculus; what if I came up with a simple imperative language with no I/O or concurrency but with an implicit mutable state (containing variables). I can reduce this to a functional state-passing form and encode that in the lambda calculus using suitably picked church dictionaries (eg. church lists of church pairs of church
13:49:46 <nand`> numerals); would that count as reducing to lambda calculus?
13:49:51 <herpladee> do i get ghc7?
13:50:21 <dmwit> Isn't that what I've been suggesting all along?
13:50:53 <herpladee> ... to me?
13:50:59 <dmwit> yes
13:51:01 <herpladee> alright!
13:51:14 <herpladee> will that give me 99 other problems?
13:51:18 <herpladee> or is ghc7 relatively stable?
13:51:42 <dmwit> GHC is pretty stable.
13:51:45 <nand`> I as a principle upgrade GHC as soon as the new version comes out, it's just nicer that way since basically the entire rest of the world upgrades their packages too
13:51:51 <herpladee> do i want to uninstall cabal and .cabal and .ghc before installing ghc7?
13:51:52 <jedai> nand`: Basically every language could be reduced to a lambda calculus (since they're turing equivalent) but I said that I counted as FPP  those that were so in practice
13:51:57 <EmilyS> wait so, | has a special meaning?
13:52:01 <herpladee> can i install ghc7 with apt-get?
13:52:02 <dmwit> herpladee: That's not necessary, no.
13:52:09 <EmilyS> I am so bad at this!
13:52:31 <dmwit> EmilyS: Yes, | is one of the few things that sort of looks like an operator but isn't. =)
13:52:43 <dmwit> Along with = -> -- ::
13:52:46 <EmilyS> i see it used to make blocks?
13:52:55 <dmwit> | doesn't start a block, no.
13:53:14 <dmwit> Though it's common to indent things as if it did for aesthetic reasons.
13:53:21 <EmilyS> I'm not sure if haskell has significant indentation
13:53:27 <dmwit> Yes, it does.
13:53:44 <jedai> nand`: and in a "real" implementation, that is only an heuristic of course but all languages that are treated like this in practical implementation are what others would call FP for other reasons, so it's enough for me
13:54:15 <nand`> jedai: perhaps languages that are formalized in terms of a LC-derivative?
13:54:27 <jedai> nand`: Right
13:55:01 <jedai> nand`: though sometimes the "formalization" isn't very formal or has some large holes so...
13:56:18 <nand`> it's a bit curious to be so passionate about functional programming yet having a very hard time defining what functional programming actually is :P
13:57:25 <jedai> What I'm really interested in is pure FP and as you said this is more about referencial transparency
13:57:59 <ksf> how come theorists always ignore the interesting problems?
13:58:34 <jedai> ksf: interesting by which criteria ?
13:58:40 <ksf> for implementors.
13:59:00 <ksf> you can find tons of stuff about regexen and automata, but near nothing about grouping.
13:59:17 <jedai> grouping ?
13:59:26 <ksf> capturing.
14:00:00 <gensymv> you mean pattern matching?
14:00:11 <ksf> call it what you bloody want.
14:00:30 <jedai> ksf: You mean capture in a regex ?
14:00:30 <ksf> (foo)bar(baz) would return foo and baz.
14:00:31 <EmilyS> grouping is easy
14:00:36 <ksf> yep.
14:00:57 <EmilyS> look-ahead/look-behind is something that I can never keep in my brain
14:00:58 <gensymv> a simple yes, would have sufficed ^^
14:01:22 <ksf> EmilyS, I'm talking about implementing, not using :)
14:01:41 <EmilyS> ksf: uh, you will need to read up on regular language theory
14:01:44 <jedai> I seems to remember some papers that talked about this
14:01:48 <EmilyS> which is, as I recall.... super hard
14:02:00 <EmilyS> also, super dry ._.
14:02:01 <jedai> EmilyS: No it's not
14:02:26 <EmilyS> oh? I could never quite get into regular language theory
14:02:27 <jedai> EmilyS: It's as soon as you want to go beyond that you start to have problems...
14:02:31 <ksf> it's the simplest computational model around.
14:03:16 <EmilyS> ksf: in that case, do you have any resources that teach it well?
14:03:31 <gensymv> Hopcroft, Ullman, Motwani.
14:03:36 <jedai> ksf: Pretty sure that I read some good papers on implementation of practical regexp with capture, pretty recently too
14:03:52 <ksf> hmm. capturing does seem to be closed under reversal, and probably also negation, iff you don't throw stuff away. better to not count negation in, though.
14:04:13 <ksf> well, google scholar isn't particularly helpful.
14:04:36 <ksf> all three keywords are too widely used in other papers.
14:05:07 <ksf> and everything I read about the theory didn't come with discussions of capturing.
14:05:12 <rguillebert> hi
14:05:32 <zzing_> What is the operator for integer division?
14:05:32 <ksf> alternation, now that's interesting.
14:05:45 <jedai> ksf: You have to go into papers apparently, most theoretical text don't enter into the subject
14:05:47 <rguillebert> can haskell's type system enforce things such as "an integer between 0 and 10" ?
14:05:58 <mauke> rguillebert: not easily
14:06:01 <herpladee> zzing_, `div`
14:06:02 <jedai> rguillebert: No
14:07:25 <jedai> rguillebert: Though you can easily create an abstract type whose constructor are hidden and thus guarantee that it will never contains an integer out of this range, with a smart constructor
14:07:43 <herpladee> who is casting finals?
14:07:58 <herpladee> bitterdam?
14:08:21 <nand`> rguillebert: of course it can! data Int10 = Zero | One | Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten deriving (Show, Read, Eq, Ord, Enum)
14:08:24 <nand`> :P
14:08:49 <monochrom> use TH to write the Num instance
14:08:55 <rguillebert> nand`, that's really easy to use ! :)
14:09:07 <jedai> rguillebert:  (In fact you can do it but it requires type level numbers and your "numbers" wouldn't all have the same type
14:09:25 <tmiw> there's that one guy I saw on r/programming that implemented numbers as functions
14:09:30 <jedai> except for nand` solution of course !!
14:09:32 <tmiw> but that was ruby
14:09:52 <jedai> tmiw: Sounds like church numbers
14:10:18 <jedai> tmiw: You can do that in Haskell too
14:10:50 <tmiw> jedai: http://experthuman.com/programming-with-nothing
14:10:55 <tmiw> jedai: yeah
14:10:58 <rguillebert> I realize it's hard to enforce that statically
14:12:33 <jedai> tmiw: Well that's classic lambda-calculus stuff... but in ruby o_O
14:14:47 <zzing_> If I have a tree structure (such as Factor 120 (Prime 2) (Factor 60 (Prime 2) (Factor 30 (Prime 2) (Factor 15 (Prime 3) (Prime 5)))))   What is the best means of counting how many Primes there are individually, such that I have 3 x Prime 2, 1 x Prime 3, 1 x Prime 5?
14:15:14 <tmiw> jedai: yep
14:15:42 <jedai> zzing_: Use a Map (or a MultiSet if hackage doesn't scare you)
14:15:55 <Ralith> rguillebert: you probably want dependent typing
14:16:25 <Ralith> What lib should I be using for a simple queue to which I'll be doing lots of appends and pops?
14:16:30 <Ralith> (but no other operations)
14:16:47 <Ralith> (well, checking for emptiness too I suppose)
14:17:20 <jedai> Ralith: You could write it yourself (there's an O(1) amortized solutions that's awfully simple) or looks into collections
14:18:21 <Ralith> I'm generally a fan of not writing things myself
14:18:29 <ocharles> If I want to combine EitherT and ReaderT, to provide a static environment to a computation that can fail, do I want ReaderT EitherT, or EitherT ReaderT ?
14:18:36 <ocharles> it feels like I want the latter
14:18:44 <jedai> Ralith: Well collections seems to be old and not maintained
14:18:49 <Ralith> :/
14:19:00 <jedai> Ralith: You could use Data.Sequence as a queue
14:19:06 <Ralith> would that be wasteful?
14:19:48 <jedai> Ralith: I'm pretty sure it would still be O(1) amortized by operation but the constants may be a bit annoying, you would have to benchmark (but do you need performances ?)
14:20:32 <Ralith> I need not-terrible performance, but getting the absolute best perf shouldn't be necessary
14:20:50 <Ralith> of course, that's just conjecture
14:21:17 <Saizan> Ralith: i'd go with Data.Sequence
14:21:30 <jedai> Ralith: well there's queuelike on hackage that doesn't seem too awful but at this point you may as well type !ackage queu in google and see for yourself
14:21:42 <jedai> !hackage queue
14:22:30 <jedai> Ralith: If that's your requirement, I would start with Data.Sequence, at least you wouldn't be adding dependencies
14:22:55 <Ralith> kk, thanks
14:23:08 <jedai> And Data.Sequence is pretty awesome (read the paper if you have time)
14:24:03 <dmwit> ksf: Hm.
14:24:35 <dmwit> ksf: I vaguely recall a paper about converting regex matches from one regex to another (when they match intersecting languages).
14:24:41 <dmwit> Perhaps that's relevant...
14:25:33 <dmwit> Lasse Nielsen and Fritz Henglein
14:26:02 <dmwit> Then again, maybe not. =P
14:26:33 <dmwit> No, it's definitely relevant.
14:26:51 <jedai> ocharles: I would say EitherT ReaderT too, but I'm not sure it would make a real difference in this particular case
14:26:58 <dmwit> "Regular expression parsing is the problem of producing a parse tree of a string for a given regular expression. We show that a compact bit representation of a parse tree can be produced efficiently..."
14:27:43 <simon> Fritz is one of my professors.
14:27:45 <Qrt> hmm, if someone plays optimal tic-tac-toe you can never win right?
14:27:54 <Qrt> no
14:29:02 <nus> luite, perhaps what you're after is something more concrete then maps, they're just collections of pairs, after all
14:29:19 <simon> I've thought about doing my bachelor's project in some relation to bit-representation of regexes.
14:29:33 <simon> (but I think it might be too difficult for me)
14:30:40 <ocharles> jedai: cool. i got it working with EitherT Reader, and realised my problem was trying to use runReaderT, when I just wanted runReader
14:31:29 <luite> nus: oh i'm already implementing it
14:32:01 <nus> luite, graphs?
14:32:34 <luite> nus: nah a map where the values are a linked list
14:32:43 <Qrt> when using cabal, does buld-depends have to have base?
14:34:58 <eviltwin_b> yes
14:35:28 <eviltwin_b> the alternatives are haskell98 and haskell2010, plus there are versions (effectively, a version on base declares which compiler versions are compatible)
14:35:46 <eviltwin_b> (althought he version numbers are not in sync, so base 4.5.0.0 is ghc 7.4.1...)
14:36:59 <dmwit> Qrt: Only if you use things from base.
14:37:10 <dmwit> It's pretty darn hard not to, though.
14:39:27 <Qrt> can i define a TicTacToe board that is a 3*3 list? [[1,2,3],[4,5,6],[7,8,9]]. ie it can only be a 3*3 list?
14:40:26 <dmwit> data Triple a = Triple a a a; data Cell = X | O | Empty; type TicTacToeBoard = Triple (Triple Cell)
14:41:08 <Liskni_si> And then you might as well use 9-tuples.
14:41:10 <dmwit> or data TicTacToe = TicTacToe Cell Cell Cell Cell Cell Cell Cell Cell Cell if that's your cup of tea
14:41:31 <jedai> dmwit: Well except if you specify NoImplicitPrelude there's at least one module that will needs base/haskell98/haskell2010 no ? ?
14:42:00 <dmwit> jedai: Like I said, it's hard. NoImplicitPrelude everywhere is the only way.
14:43:00 <Qrt> going from C++ to haskell really makes you appreciate haskells expressive power
14:43:05 <jedai> Qrt: You could use an array
14:43:30 <dmwit> None of the above lines are hard to do in C++.
14:43:37 <Qrt> not hard
14:43:50 <Qrt> but its a few-liner in haskell
14:46:01 <dmwit> enum { X, O, Empty } Cell; struct Triple<T> { T a, b, c; }; typedef Triple<Triple<Cell>> TicTacToe; // ?
14:46:12 <dmwit> My C++ is a bit rusty, but it doesn't even look that much longer to my eyes.
14:46:32 <dmwit> C++ doesn't start losing until you try to translate a sum type from Haskell there.
14:47:04 <jedai> dmwit: Well a sum of product type
14:47:26 <dmwit> A sum type that's not a simple enumeration, yes.
14:47:28 <jedai> Or okay, I guess a sum of singleton
14:48:20 <jedai> Well C++ can be pretty good, it's just very very easy to shoot yourself in the foot
14:48:36 <Qrt> i was talking more about the algorithms(yes simple ones)
14:49:15 <ksf> frisby's error handling is *atrocious*
14:49:51 <Qrt> TicTacToeBoard { board :: [[Mark]] }
14:49:53 <dmwit> ksf: (Did you see my literature suggestion above?)
14:49:57 <Qrt> how do i create a type like that?
14:50:20 <dmwit> data TicTacToeBoard = TicTacToeBoard { board :: [[Mark]] }
14:50:22 <dmwit> or:
14:50:27 <dmwit> s/data/newtype/
14:50:29 <ksf> <dmwit> Lasse Nielsen and Fritz Henglein ?
14:50:33 <dmwit> yes
14:50:52 <dmwit> They have a paper on quickly producing (bit-packed) parse trees of regular expression matches.
14:52:24 <Qrt> ¨dmwit: i meant create an instance
14:52:37 <Qrt> like makeBoard :: TicTacToeBoard
14:52:51 <dmwit> TicTacToeBoard { board = [{- blah blah blah -}] }
14:52:56 <dmwit> or
14:53:03 <dmwit> TicTacToeBoard [{- blah blah blah -}]
14:53:45 <McManiaC> which exception gets raised if I hit ^C ?
14:53:49 <Qrt> > TicTacToeBoard { board = replicate 3 Couldn't match expected type `TicTacToeBoard'
14:53:49 <Qrt>                 with actual type `[[Mark]] -> TicTacToeBoard'
14:53:51 <lambdabot>   <no location info>: parse error on input `type'
14:53:54 <McManiaC> async something?
14:53:55 <Axman6> TicTacToeBoard [[X,C,O],]
14:53:56 <Qrt> let b = TicTacToeBoard (replicate 3 $ replicate 3 Empty)
14:54:49 <dmwit> Your paste got garbled. Could you use hpaste or similar?
14:55:03 <dmwit> That way you can include the supporting definitions, as well.
14:56:38 <ksf> hmmm. actually, I want the whole parse tree. bugger generality.
14:56:43 <ksf> @quote premature
14:56:44 <lambdabot> vincenz says: strict evaluation is premature optimization
14:56:46 <ksf> @quote premature
14:56:47 <lambdabot> Knuth says: We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.
14:56:50 <ksf> @quote ksf premature
14:56:51 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
14:57:10 <dmwit> What's more general than the whole parse tree?
14:57:29 <ksf> a framework that doesn't make you walk the tree
14:57:41 <ksf> general as in application, not as in theory.
14:58:16 <dmwit> If you can produce the whole parse tree, it shouldn't be hard to pick out interesting bits of the tree as a post-processing step. =)
14:58:16 <MagneticDuck> erm, I'm a newbie having trouble with ghc
14:58:25 <MagneticDuck> I compile a module A..
14:58:47 <MagneticDuck> then how do I compile a module B that imports module A?
14:58:49 <MagneticDuck> >_<
14:59:18 <MagneticDuck> It keep saying that it can't find the first module
14:59:20 <efrey> You compile them together
14:59:27 <MagneticDuck> oh
14:59:31 <efrey> or just
14:59:36 <efrey> ghc --mave moduleB
14:59:41 <efrey> *make
14:59:49 <MagneticDuck> I did that
14:59:52 <Qrt> what the eff, is haspaste down?
14:59:56 <MagneticDuck> :O
15:00:08 <efrey> are they in seperate directories?
15:00:10 <MagneticDuck> but efrey: I did exactly that
15:00:11 <MagneticDuck> no
15:00:20 <MagneticDuck> same directory, the filename is the module name
15:00:26 <eviltwin_b> hpaste.org looks up to me
15:00:28 <MagneticDuck> (added the .hs)
15:00:37 <dmwit> MagneticDuck: eh, just "ghc -c B.hs" works here
15:00:38 <MagneticDuck> same here
15:00:40 <hpaste> qrt pasted “typeish” at http://hpaste.org/71553
15:00:47 <MagneticDuck> oh
15:00:49 <efrey> are the files that contain them named <modulename>.hs?
15:00:49 <dmwit> Oh, --make is default these days.
15:00:58 <MagneticDuck> wait, what exactly does -c do?
15:01:01 <dmwit> So that's probably why.
15:01:13 <dmwit> MagneticDuck: It stops after compilation (i.e. after producing a .o).
15:01:20 <MagneticDuck> okay
15:01:40 <jedai> Without a -c it would search for a Main.main
15:01:41 <MagneticDuck> still having that problem
15:01:47 <MagneticDuck> I'm using --make
15:01:53 <MagneticDuck> I do the following:
15:02:02 <applicative> what are your trying the makeBoard from Qrt
15:02:03 <MagneticDuck> :! ghc --make -c RoboDuck.Sentence.hs
15:02:05 <MagneticDuck> that compiles
15:02:08 <MagneticDuck> then:
15:02:18 <MagneticDuck> :! ghc --make -c RoboDuck.BotResponse,hs
15:02:22 <Qrt> ^^ ,y paste
15:02:27 <MagneticDuck> and that can't find the first module
15:02:31 <jedai> MagneticDuck:  Hierarchical modules works with directories
15:02:44 <dmwit> MagneticDuck: module Foo.Bar should go in Foo/Bar.hs
15:02:47 <MagneticDuck> oh
15:02:48 <MagneticDuck> okay
15:02:57 <MagneticDuck> even if they're on the same level?
15:02:57 <efrey> Yeah, jhc works how you are doing, but GHC does not
15:03:01 <MagneticDuck> I'm going to have that problem?
15:03:02 <Qrt> so i have [[Mark]] -> nevermind
15:03:13 <MagneticDuck> wait, how does that work...
15:03:15 <MagneticDuck> ah well
15:03:23 <dmwit> MagneticDuck: You would compile both from the directory above, or add the directory above to the module search path.
15:03:31 <MagneticDuck> okay
15:03:45 <jedai> AFAIK if you import RoboDuck.Stuff, it search in the Roboduck directories, not a RoboDuck.Stuuf.hs in the current directory
15:04:34 <dmwit> Qrt: Did you work out what was wrong? =)
15:05:05 <hpaste> applicative annotated “typeish” with “typeish (annotation)” at http://hpaste.org/71553#a71554
15:06:16 <dmwit> "any (== True)" is better written "or"
15:06:45 <Qrt> is there some monad thingie for doing: transpose TTTBoard where TTTBoard is TTTBoard { board :: [[Int]] } ?
15:06:58 <dmwit> :t transpose
15:06:59 <lambdabot> forall a. [[a]] -> [[a]]
15:07:04 <dmwit> ?
15:07:18 <dmwit> I'm not sure I understand the question, actually.
15:07:42 <hpaste> DMcGill pasted “Problems with MVector and ST” at http://hpaste.org/71555
15:07:53 <DMcGill> any ideas?
15:08:30 <Qrt> like instead of hvaing to take the board out of the type and reapplying it can i define some THING for this other than a normal function like: apply f tttboard = TTTBoard (f $ board tttboard)
15:08:43 <otters> Qrt: you could use a lens :3
15:08:54 <dmwit> DMcGill: First question is whether you understand the error.
15:08:55 <dmwit> =)
15:09:04 <MagneticDuck> ..more problems
15:09:14 <MagneticDuck> I'm in /a/
15:09:19 <dmwit> Qrt: That looks like a good function definition to me, you should add it to your source file. =)
15:09:20 <Qrt> otters: fail to parse joke
15:09:26 <otters> it's not a joke
15:09:35 <DMcGill> surely there should only be one s, I don't know why it's expecting a s and an s1
15:09:36 <MagneticDuck> and try doing $ ghc --make -c b/A.hs
15:09:39 <MagneticDuck> and it doesn't work
15:09:44 <MagneticDuck> even though b/A.hs exists
15:09:48 <dmwit> DMcGill: Okay. So here's what's happening there.
15:09:49 <MagneticDuck> it says it can't find the file
15:10:05 <otters> Qrt: data-lens
15:10:07 <otters> hoogle it
15:10:09 <dmwit> DMcGill: Box demands that its argument can have *any* instantiation of s.
15:10:09 <otters> wait, no
15:10:11 <otters> @hoogle data-lens
15:10:12 <lambdabot> package data-lens
15:10:12 <lambdabot> package data-lens-fd
15:10:12 <lambdabot> package data-lens-template
15:10:15 <otters> yeah, eh
15:10:17 <dmwit> DMcGill: That is, that its argument is 100% polymorphic.
15:10:41 <dmwit> DMcGill: Now look at the type of singletonV.
15:11:15 <dmwit> DMcGill: Once we've fixed an s telling which "ST s" monad we're using, the MVector we return is no longer polymorphic!
15:11:23 <dmwit> DMcGill: It's monomorphic, specifically, to the type "s".
15:11:50 <DMcGill> should I give Box a type param?
15:11:59 <dmwit> That would be one fix, yep.
15:12:06 <dmwit> Not much point to have the Box type at all in that case, though.
15:12:24 <otters> @hoogle (^%=)
15:12:25 <lambdabot> No results found
15:12:32 <DMcGill> in the real program, Box has lots of other members too
15:12:48 <Qrt> isnt that fmap?
15:12:49 <DMcGill> you said "one fix", what would be others?
15:13:13 <efrey> MagicDuck: why do you want to compile these files separately?
15:13:24 <dmwit> I think that's the most workable fix.
15:13:27 <MagneticDuck> efrey: It's not possible?
15:13:28 <MagneticDuck> ._.
15:13:37 <MagneticDuck> lol I was just trying to see if it's possible
15:13:49 <dmwit> You could imagine making the forall an existential, which would fix the problem locally, but then you'd have a big problem globally: you'd never be able to use a Box. =)
15:13:51 <efrey> I don't know, but it's a work flow I've never seen before
15:13:56 <MagneticDuck> so, the idea is you have to compile all the files you want compiled first in a block
15:14:26 <Qrt> dmwit isnt ##### apply :: ([[Mark]] -> [[Mark]]) -> TicTacToeBoard -> TicTacToeBoard
15:14:26 <Qrt> apply f tttboard = TicTacToeBoard $ f $ board tttboard ###### some sort of fmap?
15:14:33 <DMcGill> dmwit: thanks for your help
15:14:33 <MagneticDuck> and then do you have to have them loaded in the scope to compile interactive / interpreted files?
15:14:35 <MagneticDuck> no right?
15:14:37 <dmwit> MagneticDuck: Wait, what's the problem?
15:14:37 <Qrt> @type fmap
15:14:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:14:47 <dmwit> GHC supports separate compilation, so let's figure out what's going wrong.
15:15:22 <MagneticDuck> dmwit: I'm compiling two files in order, the second importing the first, and it keeps on not being able to find the other module
15:15:33 <dmwit> Qrt: Unfortunately not; fmap is more polymorphic. You need to be able to contain any type (not just Mark's) to have an fmap, and even then you can't change the structure of the container during an fmap.
15:15:44 <otters> Qrt: you could make TicTacToeBoard an instance of Functor
15:16:06 <dmwit> MagneticDuck: What are the file names/module names? I'll try to reproduce the problem locally.
15:16:13 <MagneticDuck> oh wait
15:16:42 <MagneticDuck> if I'm doing separate compilation, should I use the -c flag?
15:17:04 * osfameron wonders if he met MagneticDuck last week... ah no, that was an Atomic Duck.  Pesky ducks all look the same on the internet :-(
15:17:10 <eviltwin_b> yes
15:17:11 <MagneticDuck> :D
15:17:12 <MagneticDuck> dem ducks
15:17:16 <dmwit> MagneticDuck: You should use -c when you haven't reached "main" yet.
15:17:17 <MagneticDuck> btw I'm not magic duck
15:17:20 <MagneticDuck> I'm MAGNETICDUCK
15:17:21 <MagneticDuck> sheesh
15:17:26 <MagneticDuck> okay
15:17:27 <eviltwin_b> (and I think --make is only useful when linking)
15:17:35 <dmwit> MagneticDuck: And when you aren't ready to link.
15:17:35 <MagneticDuck> what's the other way?
15:17:41 <MagneticDuck> link meaning what?
15:17:57 <efrey> linking the .o files together
15:18:00 <MagneticDuck> I read about it and then forgot it
15:18:03 <dmwit> link meaning... call ld? put together a bunch of .o and .so files into a binary?
15:18:08 <MagneticDuck> oh
15:18:09 <MagneticDuck> I see
15:18:20 <MagneticDuck> so it returns all the modules in one big .o file?
15:18:37 <dmwit> No, each module has its own .o (and own .hi) file.
15:18:43 <MagneticDuck> okay..
15:18:52 <Qrt> otters, doesnt that contradict what dmwit said?
15:18:56 <efrey> all those .o files get linked together into the executable
15:19:07 <dmwit> Are we talking about building a program or a library here?
15:19:12 <MagneticDuck> a library
15:19:14 <MagneticDuck> I'm not at main yet
15:19:17 <otters> Qrt: oh, you are absolutely right
15:19:19 <dmwit> Okay, that explains a bit of your confusion, then. =P
15:19:20 <otters> Qrt: I would use a lens
15:19:32 <dmwit> So, yes, it packages them into one big ".o file".
15:19:34 <otters> or if you don't want to have a dependency on that package, just write an accessor yourself
15:19:42 <dmwit> That's scare quotes because it's not an ".o", it's another format.
15:19:48 <MagneticDuck> well I managed to compile them both at once
15:19:52 <dmwit> But it's close enough to the truth to be useful for understanding what happens.
15:19:53 <otters> onBoard f t = t { board = f (board t) }
15:20:04 <MagneticDuck> okay
15:20:14 <MagneticDuck> it's a program
15:20:17 <MagneticDuck> alright
15:20:18 <MagneticDuck> wait
15:20:32 <MagneticDuck> but you say to use -c when you're making a library or not?
15:20:43 <dmwit> irrelevant
15:21:02 <dmwit> -c is for when you don't want to do linking, whether your end goal is a library or a program.
15:21:08 <MagneticDuck> alright
15:21:13 <MagneticDuck> I won't add it then
15:21:28 <dmwit> s/don't want to do linking/don't want to do linking *yet*/
15:21:48 <MagneticDuck> okay
15:22:13 <MagneticDuck> should I be able to load a compiled module by saying ":l A" no matter where A.hs is?
15:22:16 <MagneticDuck> or
15:22:24 <dmwit> No.
15:22:28 <MagneticDuck> as long as the prefix corresponds with its file location?
15:22:42 <dmwit> The default search path for loading is "."; there are command-line options for changing that.
15:22:54 <MagneticDuck> Like RoboDuck.Sentence will be found in RoboDuck/Sentence.hs??
15:23:02 <dmwit> If you want to be able to get it via ":m +" or "import" in a file, then you need to create and install a package containing the module.
15:23:11 <MagneticDuck> yeah
15:23:15 <mcstar> prob = sscanf(argv[1], "%f", &prob);
15:23:20 <mcstar> thank you HASKELL ^^
15:23:55 <MagneticDuck> oh
15:23:57 <MagneticDuck> I got it
15:23:59 <MagneticDuck> >_<
15:24:12 <MagneticDuck> I had "RoboDuck.Sentence" IN the folder RoboDuck
15:24:27 <MagneticDuck> and expected it to be thought of as "RoboDuck.Sentence"
15:25:25 <DMcGill> dmwit: I'm having the same problem again: Given a `ST s (Box s)', I'm finished with my state and want to use runST but I get the same error about s and s1 for the same reason
15:26:23 <DMcGill> although it would leave me with a type of Box s which makes no sense
15:27:06 <dmwit> Yes, you can't return a thing with mutable bits in to an immutable context.
15:27:23 <dmwit> You'll need an immutable counterpart to your mutable data structure, and freeze it.
15:27:33 <DMcGill> hmm, ok
15:28:13 <MagneticDuck> working like a charm now
15:28:14 <MagneticDuck> ty
15:28:16 <MagneticDuck> :D
15:28:22 <MagneticDuck> this is one of my first projects
15:28:56 <otters> haskell is fun
15:29:09 <MagneticDuck> weeeeeeee
15:29:12 <dmwit> MagneticDuck: (Is there a reason you're not just using --make on your top-level file and/or cabal?)
15:29:21 <MagneticDuck> oh
15:29:23 <MagneticDuck> I can do that?
15:29:26 <MagneticDuck> O.O
15:29:29 <MagneticDuck> lol
15:29:31 <MagneticDuck> here I go
15:29:32 <MagneticDuck> weeee
15:29:45 <MagneticDuck> wait
15:29:49 <MagneticDuck> how do I do that?
15:30:03 <efrey> ghc --mave toplevel.hs
15:30:05 <dmwit> ghc --make MagneticDucksMostExcellentHaskellProject.hs
15:30:11 <MagneticDuck> oh
15:30:15 <MagneticDuck> well I haven't got there yet
15:30:25 <MagneticDuck> oh
15:30:27 <MagneticDuck> I see
15:30:28 <MagneticDuck> wow
15:30:29 <MagneticDuck> yay
15:30:42 <MagneticDuck> okay I'll stop spamming and start working
15:30:42 <MagneticDuck> :D
15:32:02 <DMcGill> dmwit: what about boxToVector box = create (unBox <$> box)
15:32:19 <DMcGill> I would have thought that would have type ST s (Box s) -> Vector Char
15:32:42 <dmwit> I don't know anything about vectors, sorry.
15:33:03 <DMcGill> but instead it throws the error because create is for all types and a Box has an specific type
15:33:11 <DMcGill> @hoogle create
15:33:11 <lambdabot> System.Posix.Files createDevice :: FilePath -> FileMode -> DeviceID -> IO ()
15:33:11 <lambdabot> System.Directory createDirectory :: FilePath -> IO ()
15:33:11 <lambdabot> System.Posix.Directory createDirectory :: FilePath -> FileMode -> IO ()
15:33:18 <Qrt> how does lens work?
15:33:25 <DMcGill> create :: (forall s. ST s (MVector s a)) -> Vector a
15:33:35 <dmwit> Qrt: http://twanvl.nl/blog/haskell/overloading-functional-references
15:35:11 <dmwit> ?ask aristid Holy !$*# I just looked at the dependency list for http-conduit. I don't relish tracking this down; do you happen to know if unix is in the transitive closure of the dependencies? (I'd prefer to be cross-platform without Cygwin.)
15:35:11 <lambdabot> Consider it noted.
15:37:23 <Peaker> dmwit, cabal install --constraint "unix < 0" or such can help?
15:37:36 <dmwit> not a bad tip
15:37:44 * hackagebot errors 1.2.0 - Simplified error-handling (GabrielGonzalez)
15:39:13 <dmwit> Peaker: Strange; it complains that unix is a dependency of network, but Hackage does not agree.
15:39:31 <Peaker> dmwit, maybe it's a flag dependent dependency
15:39:51 <dmwit> seems to be
15:40:21 <Peaker> https://github.com/haskell/network/blob/stable/network.cabal
15:40:26 <dmwit> Makes it hard to tell whether it will work on Windows, though.
15:40:34 <Peaker> if !os(windows) build-depends: unix >= 2 && < 3
15:40:36 <dmwit> Since I doubt I can ask cabal to print *all* the dependency conflicts.
15:40:50 <dmwit> (As far as it's concerned, one conflict is enough to make things unworkable.)
15:42:00 <Qrt> whoStarts = do {r <- R.randomRIO (0::Int, 1); return $ [Computer, Human] !! r } //// redo with >>= plz
15:43:01 <Qrt> ah!
15:43:07 <Qrt> whoStarts = R.randomRIO (0::Int, 1) >>= \r -> return $ [Computer, Human] !! r
15:43:18 <eviltwin_b> if you derive Enum, might be even simpler?
15:44:01 <Peaker> Qrt, there's a random choice from list
15:44:12 <Qrt> how?
15:44:12 <Peaker> Qrt, don't use partial functions like (!!) if you don't have to
15:44:19 <Qrt> partial?
15:44:24 <Qrt> @type (!!)
15:44:26 <lambdabot> forall a. [a] -> Int -> a
15:44:43 <Peaker> > [1,2]!!2
15:44:45 <lambdabot>   *Exception: Prelude.(!!): index too large
15:45:23 <d-old_> hey, why does Prelude.map only work on lists?
15:45:24 <Peaker> Hmm.. I confused System.Random with QuickCheck's Gen... you can still derive a Random instance for your Player type?
15:45:26 <eviltwin_b> Enum and Bounded, in fact
15:45:32 <however> ^^ you may get exceptions like that, and they don't even include a line number (bad luck if you have several thousand lines of code with hundreds of (!!) and no clue where to start)
15:45:36 <Peaker> d-old_, for "newbie friendliness"
15:45:42 <dmwit> d-old_: More monomorphic types give better error messages.
15:46:09 <dmwit> Peaker: There's no deriving Random, I'm afraid.
15:46:13 <d-old_> oh that is peculiar
15:47:33 <d-old_> what is bad about: 'wrong type in second argument of map, second argument is of type a and is not of class Enumerable' ?
15:48:20 <dmwit> You know what's easier for beginners to understand than Haskell? Haskell without type classes.
15:48:40 <dmwit> You know what's even easier than that? Haskell without polymorphism.
15:48:57 <d-old_> you know what's even easier than that? Haskell without functions
15:49:04 <d-old_> oh wait.. did I say functions, I meant features >_>
15:49:06 <dmwit> For this reason, it's common for introductory courses or tutorials to begin with the monomorphic fragment of Haskell, then add parametric polymorphism, then add ad-hoc polymorphism.
15:49:41 * dmwit shrugs in resignation in d-old_'s general direction
15:49:48 <dmwit> What do you want out of us?
15:50:07 <d-old_> well.. I just don't think it's a very good reason
15:50:08 <d-old_> :P
15:50:12 <dmwit> Make a Haskell' proposal if you want the Prelude to change, or get in the habit of using fmap if you want something more polymorphic right now.
15:50:12 <Peaker> there's the Gen monad.. nicer than Random lib
15:50:15 <d-old_> type classes are not that hard
15:50:28 <d-old_> easier than understanding the do syntax imo :P
15:50:30 <dmwit> You are asking us why. We are telling you. Whether you agree with the reason or not seems sort of immaterial.
15:50:44 <eviltwin_b> d-old_: the argument has bween made before, and failed before, sadly
15:50:47 <d-old_> true true, I'm just looking for an argument :P
15:50:58 <Peaker> d-old_, Functor, not Enumerable
15:51:29 <however> d-old_: the main thing is that a newbie would rather read a message about "[a]" than about "f0 a". the earlier is pretty clear, also by analogy from other languages. the latter requires knowledge of (1) typeclasses (2) a typeclass from base with the goofy name Functor (3) the instances that base offers for Functor
15:52:06 <dmwit> (4) higher-kinded type variables
15:52:23 <dmwit> Even monomorphic higher kinds are pretty surprising for beginners.
15:53:40 <however> i guess you could only ever use fmap and hide map completely, if you like ...
15:55:31 <however> d-old_: anyway, i don't think making things clear requires some special justification :)
15:56:44 <Qrt> how do i readLine to an int?
15:56:56 <Peaker> @type readLn
15:56:58 <lambdabot> forall a. (Read a) => IO a
15:58:23 <dmwit> d-old_: A more interesting question might be "why do people use map instead of fmap"?
15:58:24 <MagneticDuck> Qrt: fmap read . readLn
15:58:43 <MagneticDuck> given that you're specifying it as an Int
15:58:48 <however> dmwit: whopping 25% of keystroke savings :)
15:58:52 <dmwit> One answer to that one is that wetware type inference is spotty at best, and any hints you can give are welcome. =)
16:00:48 <Qrt> > read "5"
16:00:50 <lambdabot>   *Exception: Prelude.read: no parse
16:00:53 <however> > (succ <$> negate) 8
16:00:55 <lambdabot>   -7
16:00:57 <dmwit> > read "5" :: Integer
16:00:58 <lambdabot>   5
16:01:02 <Qrt> > read ("5"::Int)
16:01:04 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:01:04 <lambdabot>         against inferred type ...
16:01:08 <Qrt> > read "5"::Int
16:01:10 <lambdabot>   5
16:01:23 <dmwit> > (read ("5"::String)) :: Integer
16:01:24 <lambdabot>   5
16:01:58 <Qrt> Int vs Integer again?
16:02:12 <mgsloan> wetware is hard to train, especially on opaque models.  Currently learning Haskell types is kinda like learning a blackbox via reinforcement learning
16:02:13 <dmwit> No, not at all.
16:02:17 <dmwit> > read "5" :: Int
16:02:18 <lambdabot>   5
16:02:48 <hpc> mgsloan: parts of the type system are extremely easy to learn
16:03:12 <hpc> it's just that those are also the parts that generalize the most
16:03:12 <mgsloan> hpc: Sure, it's easy to teach the principle, but the practice takes time
16:03:23 <MagneticDuck> urm, what's a function that gets the contents of a file from a filepath?
16:03:33 <hpc> MagneticDuck: readFile
16:03:37 <mgsloan> ((+1) .) . (. (*3)), for example
16:03:38 <MagneticDuck> ty
16:03:52 <Qrt> readLn doesnt return a String
16:04:02 <MagneticDuck> btw is ghci on acid recommended?
16:04:05 <mgsloan> I'm convinced you need to literally program a bit of your brain to understand types, in order for that to make clear sense
16:04:07 <hpc> MagneticDuck: you might want to write it yourself with the Handle primitives though, because if you don't consume the whole file, it leaks
16:04:24 <MagneticDuck> leaks?
16:04:40 <mgsloan> it'd be fun to do a brainscan comparison of different programming languages
16:04:45 <hpc> MagneticDuck: it leaks the same way handles leak when you don't close them
16:04:49 <mgsloan> maybe you could locate the "typechecking cortex"
16:05:12 <jedai> Qrt: readLn already does the "reading"
16:05:31 <jedai> Qrt:  you just do "n :: Int <- readLn"
16:05:56 <hpc> jedai: oh man, that's one hell of a confusing string
16:06:06 <Qrt> Illegal signature in pattern: Integer
16:06:06 <Qrt>         Use -XScopedTypeVariables to permit it
16:06:18 <hpc> i parsed it as n :: (Int <- readLn) and was very confused
16:06:40 <mgsloan> yeah, definitely put parenthesis around pattern signatures
16:06:46 <jedai> Qrt: I like ScopedTypeVariable but you may not need to specify the ::Int part, if your context is already enough to infer it
16:07:11 <hpc> ScopedTypeVariables also allows some other neat tricks
16:07:56 <jedai> hpc: Well in a function I would agree but in a binding action ? The part left of <- is always an unit (almost always,)
16:09:00 <Peaker> jedai, unfortunately, there's no way to enforce that at compile-time (if you mean single-constructor)
16:09:20 <Peaker> jedai, which is annoying, so I always do "case .. of" separately from <-
16:09:38 <jedai> i just meant syntaxically :) see hpc confusion
16:10:39 <Qrt> how do i pick randomly from a list?
16:11:01 <hpc> first you need a PRNG
16:11:07 <hpc> @hoogle StdGen
16:11:08 <lambdabot> System.Random data StdGen
16:11:08 <lambdabot> System.Random getStdGen :: IO StdGen
16:11:08 <lambdabot> System.Random mkStdGen :: Int -> StdGen
16:11:27 <hpc> start from System.Random, and figure out how you want to seed your RNG
16:11:59 <hpc> from there, it shouldn't be too hard to implement
16:12:24 <hpc> also, if it ends up running slowly, switch from [] to Array or something
16:12:29 <aristid> dmwit: sorry i don't know off-hand what the transitive closure of http-conduit dependencies is, and i don't use windows
16:12:29 <lambdabot> aristid: You have 1 new message. '/msg lambdabot @messages' to read it.
16:12:34 <hpc> so you don't have O(n) lookup
16:13:15 <dmwit> aristid: okaaaay
16:13:29 <Qrt> you cant overload functions like: hasWinner :: Board -> Bool and hasWinner :: Board -> Mark -> Bool right?
16:13:33 <jedai> dmwit: At least in the past version, http-conduit worked on Windows (I tested)
16:13:41 <dmwit> aristid: I'm going to blame you in my head because you're the messenger, hope you're cool with that. ;-)
16:13:50 <dmwit> jedai: Awesome, thanks!
16:13:59 <jedai> dmwit: I don't think it needs unix on Windows, network probably use it only on an Unix
16:14:12 <hpc> Qrt: short answer, you can't
16:14:22 <hpc> Qrt: long answer, see how it's done for printf, then run away screaming
16:14:25 <hpc> :t printf
16:14:27 <lambdabot> forall r. (PrintfType r) => String -> r
16:14:40 <dmwit> Actually, that particular case doesn't look that hard.
16:14:51 <dmwit> Printf is as horrible as it is in part because it tries really hard to stay H98.
16:15:08 <hpc> if printf doesn't scare you away, there's also (=~)
16:15:10 <hpc> :t (=~)
16:15:12 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
16:15:18 <dmwit> class Winner a where hasWinner :: Board -> a; instance Winner Bool; instance Winner (Mark -> Bool)
16:15:49 <jedai> hpc: But that's different, it's "just" straighforward return type overloading like read (and arguments too...)
16:15:53 <Qrt> goodnight
16:16:08 <hpc> jedai: so is what Qrt wants
16:16:18 <hpc> you overload the return type to Bool and (Mark -> Bool)
16:16:19 <jedai> hpc: True
16:17:18 <jedai> But =~  never change arity (at least I don't believe there's a functional instance for RegexContext)
16:17:59 <aristid> dmwit: blame microsoft, not me :P
17:08:45 <zzing_> If I have a tree of factors with leaves of primes, is a zipper the right thing I want to take an account of the primes?
17:09:18 <hpc> zzing_: oooooooh
17:09:29 <hpc> quite probably, yes
17:09:39 <zzing_> I know nothing about them :p
17:09:42 <zzing_> I am just reading http://learnyouahaskell.com/zippers now
17:09:52 <zzing_> I am implementing my C assignment in haskell before writing it in C :P
17:11:53 <hpc> zzing_: i have to say, "If I have a tree of factors with leaves of primes" is a fantastic way to begin a question
17:12:09 <zzing_> I appreciate that :P
17:21:24 <otters> are all instances always exported?
17:21:29 <otters> from a module
17:24:41 <otters> yes, yes they are.
17:24:43 <otters> dammit
17:26:29 <mgsloan> I can't believe that hackage still doesn't document orphans
17:26:51 <mgsloan> it's absolutely absurd - those're almost the most important thing to document about a module!
17:27:18 <mgsloan> s/hackage/haddock/
17:30:20 <Anpheus_> Anyone know the best way to reach Snoyman on a yesod question?
17:30:29 <otters> @pl qs (x:xs) = (qs $ filter (< x) xs) ++ [x] ++ (qs $ filter (>= x) xs)
17:30:31 <lambdabot> qs = fix ((`ap` tail) . (. head) . ap (ap . (liftM2 (++) .) . (. (filter . flip (<))) . (.)) (liftM2 (.) (:) . (. (filter . flip (>=))) . (.)))
17:30:42 <Anpheus_> Still playing with that quicksort, eh?
17:30:47 <otters> just a bit
17:31:02 <shachaf> Don't call it quicksort. :-(
17:31:04 <otters> Console lambdabot can't even solve that
17:31:09 <otters> shachaf: it technically is simple quicksort
17:31:13 <shachaf> It's not quick.
17:31:22 <Anpheus_> Eventualsort
17:31:27 <Anpheus_> You can thank me for the name later.
17:31:33 <megajosh2> otters: Oh my god
17:31:50 <otters> It's beautiful to be sure
17:32:31 <Anpheus_> Any Yesod experts here? Anyone who could possibly get me contact info for Snoyman?
17:32:44 <shachaf> Anpheus_: There's a channel for it.
17:32:45 <luite> Anpheus_: the yesod mailing list will usually help
17:32:49 <shachaf> You could probably just email him.
17:32:56 <luite> unless you need to reach him personally, then you can mail him
17:32:57 <Anpheus_> Well I need his email address for that :)
17:33:10 <luite> but if there's something that others can discuss about, the list
17:33:46 <luite> yesodweb@googlegroups.com
17:33:55 <luite> and michael@snoyman.com
17:33:56 <shachaf> If you have a general-purpose Yesod question, it's probably kind of rude to personally send an email to the one person who started the project.
17:34:16 <luite> yeah
17:34:22 <Anpheus_> Thank you luite, I'll check IRC, the mailing list and ask him in that order if I can.
17:35:11 <Anpheus_> It's not rude if it's a technical question like why a handler is blowing up and returning no data and also spitting out an exception to the console when using one of the Yesod library functions, no?
17:36:13 <luite> Anpheus_: the mailing list is still a better place to ask those things
17:36:27 <luite> many other yesod users or contributors may have seen the problem
17:36:43 <shachaf> Anpheus_: A technical question that has nothing to do with him is exactly the situation where you shouldn't be emailing him personally. :-)
17:36:51 <isomorphic> I'm trying to update the paypal-api package to use Network.HTTP.Conduit instead of Network.HTTP.Enumerator, but I'm having trouble with types still
17:37:18 <isomorphic> I have an old function httpRedirect - httpRedirect :: MonadIO m => Request m -> (Status -> ResponseHeaders -> Iteratee ByteString m a) -> Manager -> Iteratee ByteString m a
17:37:24 <isomorphic> It occurs in the code I want to update
17:37:37 <isomorphic> I have a candidate replacement -  httpLbs :: (MonadBaseControl IO m, MonadResource m) => Request m -> Manager -> m (Response ByteString))
17:37:52 * hackagebot couchdb-conduit 0.9.0 - Couch DB client library using http-conduit and aeson (AlexanderDorofeev)
17:38:35 <isomorphic> I can see much of it matches, but I don't have much in the way of an intuition for how to, for example, get rid of the Iteratee
17:38:50 <isomorphic> Could anybody suggest a starting point in ghci?
17:43:10 <MagneticDuck> hey, I have a little style problem
17:43:15 <MagneticDuck> I'll try to explain my problem
17:43:27 <MagneticDuck> I'm writing an irc bot
17:44:00 <MagneticDuck> I have a data type that represents what the bot will do after the user says something that matches a certain pattern
17:44:45 <MagneticDuck> data BotAction = Silence | Quits | Speaks (UserAction -> TaggedVars -> IO String)| DoesIO (UserAction -> TaggedVars -> IO ())
17:44:45 <MagneticDuck>  
17:45:03 <MagneticDuck> UserAction is the full thing the user said and the user's user name
17:45:15 <MagneticDuck> TaggedVars is a list of variables extracted from the text
17:45:50 <MagneticDuck> oh wait
17:46:05 <MagneticDuck> forget this
17:46:21 <MagneticDuck> lol. by typing it out I solved the problem.
17:46:23 <MagneticDuck> I
17:46:58 <MagneticDuck> I'll just explain my problem to myself in the future before going on #haskell
17:47:06 <MagneticDuck> lol sry
17:49:28 <MagneticDuck> okay, what's would you call something that has space for parameters vs something that already has the parameters filled?
17:49:36 <MagneticDuck> trying to think of a good name...
17:51:03 <isomorphic> MagneticDuck: is it a Maybe Parameter list?
17:51:13 <MagneticDuck> hm?
17:51:14 <MagneticDuck> no
17:51:27 <MagneticDuck> just a simple data type containing (a -> b -> c)
17:51:36 <MagneticDuck> and I'm also going to have one containing just c
17:51:48 <MagneticDuck> which is calculated from a data of the former
17:52:04 <MagneticDuck> what type of vocabulary should I use to distinguish the two?
17:56:37 <MagneticDuck> any ideas?
17:56:41 <MagneticDuck> "curried"?
18:00:15 <Eduard_Munteanu> MagneticDuck: (partially) applied, perhaps
18:00:40 <gigahurt> MagneticDuck: sort of sounds like memoization to me
18:07:53 * hackagebot wai-middleware-route 0.7.1 - Wai dispatch middleware (AlexanderDorofeev)
18:07:55 * hackagebot wai-middleware-catch 0.3.4 - Wai error catching middleware (AlexanderDorofeev)
18:08:29 <zzing_> For some reason I am getting an overlapping pattern in my function 'allPrimes', and I am not sure how to resolve it: http://hpaste.org/71560
18:08:47 <zzing_> allPrimes $ (Factor 120 (Prime 2) (Factor 60 (Prime 2) (Factor 30 (Prime 2) (Factor 15 (Prime 3) (Prime 5)))))  = [2,2,2,3*** Exception: main.hs:(35,1)-(36,53): Non-exhaustive patterns in function allPrimes
18:09:44 <Eduard_Munteanu> zzing_: you could have some other stuff in there besides (Prime l)
18:09:52 <shachaf> Overlapping or nonexhaustive?
18:09:57 <pqmodn> eg (Factor _ (Factor ...) (Factor ...))
18:10:03 <Eduard_Munteanu> Also, -Wall should tell you about it.
18:10:05 <zzing_> oh sorry, not exhaustive
18:10:29 <shachaf> zzing_: First step is to compile with -Wall. :-)
18:10:39 <zzing_> Can I pass -Wall to ghci?
18:10:49 <Eduard_Munteanu> Yeah, should work.
18:11:18 <Eduard_Munteanu> But you might need -fforce-recomp too
18:11:26 <Eduard_Munteanu> (if you didn't alter the file)
18:11:56 <BMeph> zzing_: Mostly, it's telling you that r and (Prime r) are not mutually exclusive possibilities, especially since you have the more general choice first.
18:12:43 <zzing_> ok, it was a matter of ordering the most specific first
18:13:01 <hpaste> BMeph annotated “pattern overlap” with “pattern overlap (annotation)” at http://hpaste.org/71560#a71561
18:13:02 <zzing_> In practice the tree will always have primes on the left until the end
18:13:15 <wagle> @hoogle [Maybe a] -> Int
18:13:15 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
18:13:16 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
18:13:16 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
18:13:36 <zzing_> ok, that works
18:13:36 <Eduard_Munteanu> :t length
18:13:38 <lambdabot> forall a. [a] -> Int
18:14:08 <BMeph> zzing_: Note: This is still not exhaustive, but it's "less non-exhaustive" than the prior form. ;)
18:14:13 <Eduard_Munteanu> zzing_: if that's all you change, you're still not handling all cases
18:14:21 <Eduard_Munteanu> *changed
18:14:25 <wagle> @hoogle [Maybe a] -> Maybe Int
18:14:25 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
18:14:26 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
18:14:26 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
18:14:32 <shachaf> zzing_: If it always has primes on the left, it's not really a tree.
18:14:39 <shachaf> I mean, it's a tree, but in particular it's a linked list.
18:14:48 <zzing_> shachaf, I suppose linked list is more accurate.
18:15:05 <zzing_> That is how I am going to implement it in C anyways.
18:15:09 <wagle> @hoogle [Maybe a] -> [Int]
18:15:10 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
18:15:10 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
18:15:10 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
18:15:16 <shachaf> If you use the type [] it'll probably solve several of your headaches. :-)
18:15:26 <JoeyA> > []
18:15:26 <zzing_> This is for a class in C, I just rather prototype in a sane language :P
18:15:28 <lambdabot>   []
18:15:39 <JoeyA> It's gone!  Thanks!
18:15:49 <hpaste> BMeph annotated “pattern overlap” with “pattern overlap (a "better" version)” at http://hpaste.org/71560#a71562
18:16:38 <zzing_> oh I like that
18:16:41 <zzing_> thank you BMeph
18:17:09 <zzing_> What would be the easiest way to do [2,2,2,3,5]  and turn it into [(2,3), (3,1), (5,1)] (that is, number and instances)
18:17:48 <shachaf> map (head &&& length) . group
18:17:58 <BMeph> > map (head &&& length) . group $ [2,2,2,3,5]
18:18:01 <lambdabot>   [(2,3),(3,1),(5,1)]
18:18:05 <zzing_> holy
18:18:09 <zzing_> What does &&& do
18:18:17 <jedai> @þype (&&&)
18:18:17 <BMeph> zzing_: shachaf's way. ;)
18:18:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:18:22 <jedai> @type (&&&)
18:18:24 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:18:36 <aristid> jedai: clearly lambdabot needs a þype command
18:18:46 <BMeph> zzing_: (f &&& g) x == (f x, g x)
18:19:14 <zzing_> @src (&&&)
18:19:14 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
18:19:27 <jedai> aristid: Well it seems to have worked anyway ??
18:19:30 <aristid> @src (***)
18:19:30 <lambdabot> f *** g = first f >>> second g
18:19:47 <BMeph> I.e., (f *** g) (x,y) = (f x,g y)
18:19:48 <shachaf> There should be a module like Control.Arrow except only for (->).
18:19:48 <aristid> jedai: maybe it's a common typo? :)
18:20:07 <zzing_> merci all
18:20:23 <megajosh2> Everybody has a thorn on their keyboard
18:20:28 <BMeph> shachaf: But, why? It works for (->), and you can always instantiate it so if you need it.
18:20:38 <aristid> shachaf: yeah, that'd make error messages simpelr i guess
18:20:38 <jedai> aristid: probably a casefold egality or something like that (I got þ by using AltGr + t though I don't know what this symbol is)
18:21:00 <shachaf> BMeph: Because it confuses people and has annoying error messages.
18:21:04 <megajosh2> It's how the earlier Anglo-Saxons used to type th
18:21:05 * BMeph sings: "Every 'board has its thorn,..."
18:21:07 <shachaf> And nobody ever uses it for anything except (->).
18:21:15 <shachaf> And I don't like Arrow much.
18:21:44 <Eduard_Munteanu> :þ ... I guess that's one use for it
18:22:17 <Eduard_Munteanu> @thype (&&&)
18:22:19 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:22:44 <aristid> shachaf: i think i've seen that for some things, arrow can be beneficial :)
18:22:50 <Eduard_Munteanu> @pype (&&&)
18:22:51 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:22:53 * hackagebot wai-middleware-cache 0.3.4 - Caching middleware for WAI. (AlexanderDorofeev)
18:22:55 <aristid> shachaf: maybe there's an even better solution
18:23:01 <BMeph> @hype (&&&)
18:23:02 <aristid> @emype (&&&)
18:23:03 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:23:03 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:23:10 <Eduard_Munteanu> @skype (&&&)
18:23:12 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:23:16 <jedai> @pe (&&&)
18:23:16 <lambdabot> (&&&)
18:23:28 <jedai> @ype (&&&)
18:23:29 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:23:32 <aristid> @e (&&&)
18:23:32 <lambdabot> Maybe you meant: easton echo elements elite eval . ? @ v
18:23:45 <aristid> ah, i guess it uses edit distance?
18:23:58 <Eduard_Munteanu> Same reason @vixen still works.
18:23:59 <jedai> @anywayype (&&&)
18:23:59 <lambdabot> Unknown command, try @list
18:24:05 <Eduard_Munteanu> @vixen
18:24:06 <lambdabot> Finishing second in the Olympics gets you silver. Finishing second in politics gets you oblivion.
18:24:09 <aristid> Eduard_Munteanu: which reason?
18:24:15 * BMeph warns: DOn't believe the @hype! ;þ
18:24:19 <Eduard_Munteanu> aristid: it autocorrects to @nixon
18:24:25 <aristid> @bmephype (&&&)
18:24:25 <lambdabot> Unknown command, try @list
18:24:34 <aristid> @bmepype (&&&)
18:24:35 <lambdabot> Unknown command, try @list
18:24:38 <aristid> @bmeype (&&&)
18:24:38 <lambdabot> Unknown command, try @list
18:24:43 <aristid> @bmype (&&&)
18:24:44 <shachaf> #lambdabot-abuse
18:24:44 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:24:52 <aristid> ok sorry
18:24:53 <BMeph> aristid: Distance two, already.
18:24:53 <Eduard_Munteanu> Looks like Levenstein distance, I guess.
18:25:13 <aristid> Eduard_Munteanu: and why was @vixen removed?
18:25:24 <shachaf> Protests.
18:25:32 <Eduard_Munteanu> Some people complained she was offensive.
18:25:36 <aristid> what did vixen do again? i forgot
18:25:41 <shachaf> Protests.
18:25:42 <Eduard_Munteanu> Though @nixon is pretty offensive too, at times.
18:25:48 <Polarina> Is it in any way possible to serialize the current state of a wire in netwire?
18:25:48 <jedai> @tale (&&&)
18:25:49 <lambdabot> Maybe you meant: tell time type
18:26:16 <Eduard_Munteanu> aristid: elisa-like bot, she's a 19 yo horny girl from California. :P
18:26:24 <aristid> Eduard_Munteanu: hahaah
18:26:58 <Eduard_Munteanu> @google vixen asl
18:26:59 <lambdabot> http://www.vex.net/~trebla/vixen.txt
18:27:01 <aristid> well, she matured into a 1970s republican
18:27:29 <Eduard_Munteanu> aristid: actually I think that's the story of her removal
18:27:32 <Eduard_Munteanu> ^^
18:28:28 <hpaste> “Perry Wagle” pasted “name foo” at http://hpaste.org/71563
18:28:51 <aristid> Eduard_Munteanu: seems like it
18:34:09 <aristid> @nixon
18:34:09 <lambdabot> A man is not finished when he is defeated. He is finished when he quits.
18:37:53 * hackagebot wai-middleware-cache-redis 0.4.1 - Redis backend for wai-middleware-cache (AlexanderDorofeev)
18:40:00 <Ralith> I'm having trouble writing helper functions inside ST
18:40:28 <Eduard_Munteanu> Ralith: why?
18:41:07 <Ralith> I have code that's basically runST $ do { arr <- newArray ...; let helper :: Foo -> ST s Bar; helper foo = ...; helper baz; }
18:41:25 <Ralith> and I'm getting errors to the effect of     No instance for (MArray (STUArray s) Word8 (ST s1))
18:41:39 <isomorphic> Why does cabal warn about packages that might be broken by reinstalls?  Ie: Why can't it keep multiple versions alongside one another?
18:41:53 <wagle> what do you do if some invariant is violated, like 2 or 0 robots on map>
18:41:57 <wagle> ?
18:43:01 <JoeyA> That's one annoying thing about the array ST API.  You have to learn about typeclass ambiguity and rank-2 types to deal with problems like these.
18:43:05 <wagle> oops
18:43:39 <JoeyA> Ralith: Could you paste a full example?  In particular, what does your newArray line(s) look like?
18:43:39 <Ralith> JoeyA: so .. how do I do that?
18:43:43 <Ralith> alright
18:44:00 <Ralith> https://gist.github.com/3119759
18:44:48 <dmwit> Are there any Unicode experts around that happen to know a sequence of bytes that aren't valid UTF-8?
18:44:51 <dmwit> (Are there any?)
18:44:57 <irene-knapp> there are many
18:45:13 <JoeyA> @wikipedia UTF-8
18:45:13 <lambdabot> Unknown command, try @list
18:45:16 <irene-knapp> but preoccupied now, the Wikipedia UTF8 page describes - right
18:45:28 <JoeyA> http://en.wikipedia.org/wiki/UTF-8#Description
18:45:39 <dmwit> I'm writing a message trying to outline just how insane this scheme is: http://www.dragongoserver.net/forum/read.php?forum=10&thread=27755#29511
18:45:53 <JoeyA> That's a nice explanation of valid UTF-8 sequences.
18:46:00 <dmwit> JoeyA: Perfect, thanks.
18:46:04 <JoeyA> In short: if the first bit starts with 0, treat it as ASCII.
18:46:31 <JoeyA> Otherwise, the number of leading bits set to 1 is the length of the UTF-8 sequence.
18:46:31 <irene-knapp> we don't have an account there, but.
18:46:45 <dmwit> Oh, do you need an account? Sorry.
18:46:50 <irene-knapp> np, what's the gist?
18:46:50 <dmwit> Anyway, trust me, it's insane.
18:46:53 <irene-knapp> I believe you :)
18:46:53 <dmwit> The gist is this:
18:47:00 <JoeyA> The maximum length of a UTF-8 char is currently 4.
18:47:04 <Ralith> dmwit: the utf8 seqs which encode the surrogate codepoints are also illegal
18:47:07 <dmwit> 1. the database stores uninterpreted bytes (whatever the browser sends in any encoding is squirreled away)
18:47:19 <dmwit> 2. the JSON-serializer interprets the bytes as UTF8
18:47:21 <Ralith> JoeyA: did you get my paste?
18:47:26 <dmwit> 3. then it recodes them in UTF16
18:47:37 <dmwit> 4. then it barfs on any surrogate pairs
18:47:40 <irene-knapp> ><
18:47:49 <irene-knapp> w t f
18:47:49 <JoeyA> Ralith: Yes.  I'll be with you in a moment.
18:48:05 <Ralith> kk
18:48:08 <dmwit> There's literally nothing a client can do to properly recover the bytes the original user sent to the server.
18:48:57 <irene-knapp> agreed, ouch
18:49:14 <dmwit> And even if they did, they can never turn that into text properly.
18:49:28 <irene-knapp> it sounds like someone freaking doesn't understand the issue at all
18:49:31 <irene-knapp> you need to not try to help them
18:49:33 <irene-knapp> just go elsewhere
18:49:35 <JoeyA> First of all, I want to say this: if you're using JSON, make sure you're working with Unicode (and not some encoding that has codepoints that aren't in Unicode).
18:49:53 <JoeyA> Otherwise, you're stuck with a dilemma due to JSON's support for Unicode escape sequences.
18:50:46 <dmwit> JoeyA: Hm, so the single byte 0x80 should already be invalid UTF8, right?
18:51:59 <dmwit> oh yes, "0x80" is not "\x80"
18:52:03 <JoeyA> dmwit: That link is dead to me.
18:52:11 <dmwit> JoeyA: Yeah, sorry about that.
18:52:12 <JoeyA> Right.
18:52:21 <dmwit> There's a guest account, but it's probably not worth it. I gave the gist of it above.
18:53:09 <JoeyA> Assuming the input is valid UTF-8, the scheme described shouldn't be a problem.
18:53:31 <dmwit> The assumption is faulty, and the conclusion is wrong anyway.
18:53:59 <dmwit> Because the decoder turns anything that's represented in UTF16 as a surrogate pair into either the empty string or invalid JSON, depending on whether the wind is blowing north or not.
18:54:26 <JoeyA> Then the right thing, in my opinion, would be to ascertain the purported charset of input (look in the HTTP headers or whatever), and store that alongside the raw data.
18:54:39 <irene-knapp> or else transcode it
18:54:40 <dmwit> sprintf('\u%04s', $utf16bytes)
18:54:47 <irene-knapp> but the real right thing to do is to refuse to help these people
18:54:54 <dmwit> JoeyA: Different users of this site send data in different encodings.
18:54:55 <irene-knapp> they don't deserve it
18:54:59 <dmwit> It's really, really broken.
18:55:03 <dmwit> Like not just a little bit.
18:56:10 <JoeyA> JSON's Unicode escapes map to UTF-16.
18:57:03 <JoeyA> To encode a higher codepoint in JSON, you use a surrogate pair, e.g. "\uD834\uDD1E"
18:57:11 <JoeyA> For U+1D11E (G clef)
18:58:25 <dmwit> Yes, I know. I read the spec, unlike the people writing this code.
18:58:58 <ParahSailin> its pretty easy to express event loopy io stuff in haskell?
18:59:36 <aristid> ParahSailin: yes
18:59:41 <dmwit> Event loops are usually not necessary because Haskell has good threading.
19:00:10 <JoeyA> My two cents: 1) When storing input, gather as much as you can, and don't try to convert stuff before storage.  This means store the input raw, and record the user's declared encoding, if available.  2) Nobody (but JSON pedants) cares if surrogate pairs are broken.
19:00:21 <ParahSailin> for stuff that epoll would be used for in c?
19:00:30 <JoeyA> Granted, I'm exaggerating a bit on (2), but see http://programmers.stackexchange.com/q/102205/3650
19:00:49 <JoeyA> (lots of programs don't handle U+1XXXX correctly)
19:04:07 <JoeyA> ParahSailin: GHC 7.0+ has epoll/kqueue support built-in.  However, this IO paradise is currently not available for Windows.
19:04:48 <ParahSailin> how small of binaries can ghc make?
19:05:04 <ParahSailin> im thinking embedded scale of hardware
19:05:43 <JoeyA> I'd say typical sizes are 2MB-15MB, depending on how many libraries you use.
19:06:07 <JoeyA> When you're using static linking, that is.
19:06:11 <JoeyA> Ralith: Still alive?
19:06:16 <Enigmagic> JoeyA: i'd keep going up from there, our typical sizes are 700-200MB :|
19:06:32 <Ralith> JoeyA: yeah, though scoped type variables seem to have suppressed the issue
19:06:47 <ParahSailin> 200 MB footprint?
19:07:14 <Enigmagic> yeah, we have a couple projects that weigh in around 200MB
19:07:33 <JoeyA> Ralith: The issue is that the helper function closes over variables, meaning the signature you gave is not accurate.
19:07:45 <JoeyA> helper :: PSQ Location Int -> ST s (Maybe [Direction]) says that helper works for *all* s.
19:07:59 <Ralith> right
19:08:07 <Ralith> but the same error arises if I use no sig
19:08:32 <JoeyA> However, cameFrom and closed constrain s to whatever s findPath was called with.
19:09:56 <JoeyA> Ralith: What if you take the signature off of helper, but keep the signatures on the newArray calls?
19:11:11 <Ralith> findPath calls runST itself. Removing the signature from helper has the same issue.
19:11:45 <Ralith> or wait no it doesn't
19:11:46 <Ralith> well then.
19:12:16 <nohonor> can someone point me to the code of the IO monad
19:12:24 <nohonor> i'm tired of looking at it as a black box
19:13:52 <SonicvanaJr> Does anyone know the reasoning as to why pattern matching against records is funcX Obj {recordField = boundVariable} = show boundVariable instead of {boundVariable = recordField}, which seems to make more sense to me?
19:13:53 <JoeyA> I'm so sick of {-# OPTIONS_HADDOCK --hide #-} ...
19:14:02 <mgsloan> nohonor: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/base/src/GHC-IO.html
19:14:27 <Ralith> SonicvanaJr: because it's pattern matching, not assignment, I assume.
19:14:37 <dmwit> SonicvanaJr: The pattern {recordField = pat} matches how you construct a value with {recordField = value}.
19:15:00 <SonicvanaJr> dmwit: Ah, that makes sense. Thanks.
19:15:14 <mgsloan> nohonor: Actually, this might be better: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/base/src/GHC-Base.html
19:15:38 <nohonor> mgsloan, danke sehr!
19:15:55 <mgsloan> welkommen!
19:16:45 <JoeyA> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
19:16:48 <JoeyA> (I think)
19:17:18 <JoeyA> This may be insightful as well ;-)  http://hackage.haskell.org/packages/archive/acme-realworld/latest/doc/html/Acme-RealWorld.html
19:18:46 <geekosaur> @src IO
19:18:47 <lambdabot> Source not found. Wrong!  You cheating scum!
19:18:51 <geekosaur> ah well
19:31:02 <nohonor> but... it doesn't do anything
19:33:06 <Enigmagic> nohonor: what would you want it to do?
19:33:23 <dmwit> Magical, isn't it?
19:33:29 <pqmodn> where's the code that executes the monad?
19:33:40 <dmwit> In the runtime.
19:33:44 <Enigmagic> pqmodn: in the rts
19:34:12 <pqmodn> oh, perhaps i'd find that in the github ghc
19:35:16 <pqmodn> nohonor: i too was expecting to find something substantial, in unsafePerformIO or something
19:35:17 <nohonor> Enigmagic, i was expecting something low level to occur somewhere in "bind"
19:35:42 <nohonor> yeah :-)
19:37:09 <nohonor> so it's just function composition
19:37:24 <nohonor> what exactly is the purpose of the "state" parameters
19:37:53 <dmwit> It introduces an artificial data dependency.
19:38:14 <Enigmagic> to force ordering of operations
19:55:43 <nohonor> makes sense
19:56:29 <nohonor> so is it then that Main.main is applied to a state argument that is then threaded through the monad
20:07:05 <nohonor> ok, i guess the answers are much simpler than i imagined
20:07:09 <nohonor> back to rwh...
20:08:34 <djahandarie> Does anyone know how the memory efficiency is on IntSet?
20:09:33 <dmwit> What kind of answer are you looking for?
20:09:38 <dmwit> data Answer = Good | Bad
20:09:41 <dmwit> "good"
20:09:57 <djahandarie> Overhead percentage
20:09:58 <copumpkin> we need a decision procedure on algorithms
20:10:09 <copumpkin> decide :: Algorithm -> Answer
20:10:22 <copumpkin> maybe even a dependent one
20:10:22 <dmwit> decide _ = Bad
20:10:28 <copumpkin> (A : Algorithm) -> Answer A
20:10:38 <copumpkin> dmwit: pre-empted you!
20:10:41 <djahandarie> #agda is ->
20:10:43 <copumpkin> now you can't lie no mo'
20:10:47 <dmwit> awww
20:10:55 * copumpkin cackles evilly
20:11:35 <dmwit> djahandarie: I doubt anybody knows off the top of their heads, but maybe you could... measure it?
20:11:46 <djahandarie> I sure could
20:12:10 <djahandarie> But that would involve more effort than asking in here, duh
20:12:16 * dmwit nods sadly
20:14:40 <nohonor> a stupid question: wouldn't the monadic binding operator work the same if it were right-associative
20:15:19 <nohonor> or should i just try it out for myself :-D
20:15:47 <dmwit> Depends which bind operator you mean.
20:15:54 <dmwit> If you mean (>=>) or (<=<), then yes.
20:16:03 <dmwit> If you mean (>>=) or (=<<), then no: look at its type.
20:16:38 <dmwit> (In fact, the former is a monad law: (a >=> b) >=> c = a >=> (b >=> c).)
20:18:09 <serialhex> quick Q for anyone interested:  theres no archlinux-arm package for cabal-install, how is the best way to get cabal-install on my rasp-pi???
20:18:21 <nohonor> dmwit, surprisingly enough, yes, that was what i was asking
20:18:23 <nohonor> thanks
20:19:03 <dmwit> serialhex: Ubuntu/Debian for ARM has a GHC package.
20:19:13 <dmwit> ...at least according to a recent haskell@ thread.
20:19:59 <serialhex> yeah, i like arch though...  the debian image is cluttered with X and i dont want to have to uninstall all that junk  -_-
20:20:49 <dmwit> Hm, I wonder if you can install dpkg on an Arch system and actually use it.
20:21:11 <serialhex> hmm...  there might be a way...
20:21:35 <dmwit> The only question is which is harder: bootstrapping GHC or melding pacman and apt. =)
20:21:56 <serialhex> well GHC is there, i just need cabal-install
20:22:02 <dmwit> ah
20:22:13 <dmwit> Can't you just use bootstrap.sh from cabal-install's tar file?
20:22:24 <serialhex> ...though not really *need* it would be helpful
20:22:46 <dmwit> Grab the tar from Hackage, untar, source bootstrap.sh.
20:23:11 <serialhex> hmm.... i guess i dont need to have it install system-wide
20:23:27 <dmwit> You can still install system-wide with bootstrap.
20:23:50 <serialhex> oh?  ok...
20:23:57 <dmwit> ...I think
20:24:00 <dmwit> Let's take a look.
20:24:41 <dmwit> SCOPE_OF_INSTALLATION="--user" <- looks mungible
20:24:50 <serialhex> :)
20:24:57 <dmwit> ./bootstrap.sh --global should Just Work
20:25:30 <serialhex> some days i wonder why i ask Q's when i'
20:25:37 <serialhex> m tired and not thinking right
20:25:51 <serialhex> ...and unable to *not* press enter with my pinky :P
20:26:43 <serialhex> thank you again dmwit!!!
20:26:57 <dmwit> cheers!
20:35:04 <meiji11> so, if I declare a typeclass with a functional dependency.. how is the compiler supposed to make sense of the dependency, just given a statement like ".. | c -> e"? Seems crazy.
20:35:30 <mauke> why crazy?
20:36:03 <dmwit> There's a paper answering this question, I'm sure...
20:36:05 <meiji11> well, the example given in the haskell wikibook is that c could have type [a], and then e would have to be a.. I don't know, the process of how it ought to extract that information is unclear.
20:36:20 <mauke> huh?
20:36:38 <mauke> given "c -> e" the compiler knows that c determines e
20:36:44 <dmwit> meiji11: There are more details in the example, I'm sure.
20:36:47 <mauke> no more, no less
20:36:59 <dmwit> Certainly c ~ [a] and the functional dependency c -> e on their own don't determine that e ~ a.
20:37:36 <pqmodn> i believe you specify that with instance declarations
20:37:36 <meiji11> dmwit: well, the paper gives that as an 'intuitive' example, ie. not rigorous
20:37:40 <dmwit> Those two facts together with an instance where c ~ [a] and e ~ a would determine that e ~ a, though.
20:37:44 <meiji11> dmwit: err, the wikibook, not a paper..
20:38:35 <meiji11> so c and e are the type parameters, and it's up to the programmer to ensure that e depends on c?
20:38:45 <dmwit> For comparison, the existence of an instance where c ~ [a] and e ~ a, but without a functional dependency, would not result in c ~ [a] implying that e ~ a.
20:38:52 <mauke> meiji11: no
20:38:55 <dmwit> No, the compiler can check that.
20:39:01 <mauke> meiji11: e doesn't depend on c
20:39:22 <dmwit> e doesn't depend on c, and also the user is not required to ensure anything.
20:39:49 <meiji11> then what role does "c -> e" have in the declaration "class Collection c e | c -> e where .. "?
20:39:57 <mauke> example time
20:39:59 <mauke> class C a b | a -> b
20:40:09 <mauke> instance C Int ()
20:40:25 <mauke> instance C Int Char  -- <- this instance is invalid
20:40:27 <dmwit> meiji11: It has the role of informing the compiler that if it knows c, it knows e, too.
20:40:55 <mauke> why? because the class says that a uniquely determines b, so there can be at most one instance where a = Int
20:40:58 <dmwit> (and to complain if the user tries to write an instance that makes that untrue)
20:42:03 <meiji11> mauke: so it defaults to () for Int? or in general for any type that has no parameters?
20:42:16 <mauke> uh. defaults?
20:42:21 <mauke> what
20:42:38 <mauke> you're imagining more magic than there is
20:42:46 <pqmodn> the second instance is invalid because one has already been declared for "C Int ..."
20:42:55 <meiji11> I mean that if you take a = Int, in your example, we must have b = () ?
20:43:00 <meiji11> it will complain if b is specified as anything else.
20:43:09 <mauke> specified how/where?
20:43:27 <mauke> are you talking about declaring instances or typechecking code or what?
20:43:31 <meiji11> well, in your example you gave instance C Int Char as invalid code..
20:43:49 <meiji11> declaring instances.
20:43:49 <mauke> meiji11: yes, because I already declared another instance
20:44:28 <meiji11> mauke: ok, so you declared C Int () and now.. C Int t is invalid for any non-unit t?
20:44:47 <mauke> and now you can't declare any instance C Int t for any t
20:44:57 <mauke> not even unit, because that instance already exists
20:45:35 <meiji11> so the 'dependency' is determined by the programmer and then enforced by the compiler, and otherwise it's arbitrary?
20:45:58 <mauke> yes, if I understand you correctly
20:46:43 <mauke> let's see. what would be a slightly more practical example?
20:46:44 <meiji11> mauke: I mean that I can define a and b as anything, and then any further instance declaration of that type involving my initial choice of a will not work.
20:46:55 <mauke> meiji11: correct
20:47:03 <meiji11> ok, cool. that's simple.
20:47:33 <meiji11> boy, did this entry give me the wrong idea.
20:47:35 <mauke> class Sequence e a | a -> e where { head :: a -> e }
20:47:50 <mauke> instance Sequence a [a] where { head (x : _) = x }
20:48:11 <mauke> instance Sequence Word8 S.ByteString where { head s = S.head s }
20:48:49 <mauke> "Sequence" is a multiparameter typeclass for sequences with a first element. which can be extracted with 'head'.
20:49:12 <mauke> I made instances for any list type and ByteString
20:49:52 <mauke> the functional dependency "a -> e" is there because otherwise (head "hello") is ambiguous
20:50:22 <mauke> why? because someone could theoretically add an instance Sequence Double [Char] or whatever
20:50:35 <meiji11> ah, I see.
20:50:45 <meiji11> that makes total sense.
20:51:17 <mauke> with a -> e the compiler knows the exact instance we're using and can compute head "hello" :: Char
20:52:20 <meiji11> right.
20:52:30 <meiji11> thanks, mauke.
20:53:00 * hackagebot conduit 0.5.2.2 - Streaming data processing library. (MichaelSnoyman)
21:00:23 <Polarina> Is it in any way possible to serialize the current state of a wire in netwire?
21:18:08 <optimight> I remain permanently logged into #haskell, but I think during 24 hr cycle for one time the the past messages disapper and messages start afresh.  Is it a feature of #haskell or maybe of my irc client smuxi?
21:18:53 <Cale> optimight: #haskell itself doesn't retain messages, they just pass through it
21:19:10 <Cale> optimight: any illusion that messages stay here is provided by your IRC client
21:19:19 <pqmodn> your client might log messages on a daily basis, clearing the screen at the start of a new day
21:23:55 <optimight> Cale: okay... so I have to check with my IRC client
21:24:25 <Cale> O
21:24:27 <Cale> er
21:24:52 <Cale> I'm using XChat, and it has a nice option to fill the buffer with the previous log of the channel when you load it
21:25:22 <optimight> Cale: I was just about to ask for the IRC client suggestion
21:25:33 <optimight> Cale: Thank you
21:29:01 <GyorsCsiga> nobody has made a CMS in haskell yet? :O
21:29:12 <Polarina> mm_freak, is there any particular reason that input to wires, that ignore its input, are fully polymorphic? I would've imagined that enforcing on the type-level that the input be () would avoid programmer mistakes.
21:31:22 <GyorsCsiga> oh there is the yesodcms
21:33:20 <Cale> Polarina: Enforcing that things are fully polymorphic also avoids programmer mistakes
21:33:45 <Cale> (but I don't know about this specific instance)
22:22:15 <isomorphic> Cale: Regarding your IRC comment above - do you mean it takes whatever Xchat last logged, and fills the buffer with that?
22:23:48 <dmwit> "errors: fever_vault - login quota exceeded"
22:23:59 <dmwit> what a colorful name
22:24:44 <dmwit> The other errors are so boring. "not_logged_in - user is not logged in" and "mysql_query_failed - database query failed" and such.
22:25:54 <dmwit> isomorphic: That is how xchat behaved when I was using it a few years ago, yes.
22:26:27 <Cale> isomorphic: yes
22:26:35 <isomorphic> dmwit, Cale: I was going to suggest znc if you would prefer the immediate log from before you attached
22:26:44 <dmwit> I just use screen+irssi.
22:26:53 <dmwit> And leave it always logged in.
22:27:22 <Cale> I would do that too if I ever wanted to access IRC from a machine other than this one
22:27:27 <isomorphic> dmwit: Ah - yes, that's an option, but hard to use on a mobile ;)
22:27:38 <dmwit> I still have a dumb phone.
22:27:53 <dmwit> It keeps threatening to fall apart and then not delivering.
22:28:03 <isomorphic> muhahaha
22:56:00 <mietek> ghc: panic! (the 'impossible' happened)
22:56:29 <mietek> I think I feel a new motto for the ICFP contest coming up...
23:02:43 <dmwit> always exciting to see that
23:02:52 <dmwit> makes you feel like a hacker =)
23:08:17 <copumpkin> hax0r
23:42:40 <cesip> what's the general public's opinion on the o'reilly "in a nutshell" books for CS studies preparation
23:45:36 <c_wraith> cesip: is there a CS book? the language-specific ones really aren't about CS - they're about teaching a language.
23:46:07 <dmwit> The general public?
23:46:15 <dmwit> "the _what_ books?"
23:46:20 <c_wraith> that's me.  I'm the general public. :)
23:47:04 <beefcube> cesip: Java in a Nutshell (This is CS according to my university anyway) s/c
23:47:36 <cesip> i just tend to mistrust anything that has "in seven days", "in a nutshell" or "for lazy people" on its cover
23:47:40 <dmwit> Heck, I'm in the field of CS, and that was *my* reaction.
23:48:27 <shachaf> dmwit is a PhD student in Counter-Strike.
23:48:50 <dmwit> 720 noscope bunny-hopper
23:49:28 <wiz> "learn yourself \-calculus in 24 centuries"
23:49:56 <wiz> *teach
23:50:03 <dmwit> hehe
23:51:31 <wiz> Also, this [http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844] covers a ton of stuff that one can encounter in uni and practice.
23:51:50 <cesip> neat, i was meaning to get that
23:52:19 <wiz> the first thing i've noticed is that pseudocode examples are quite haskellish
23:52:48 <shachaf> Really?
23:52:53 <shachaf> They aren't completely imperative code?
23:53:16 <wiz> yeah, and they do look exactly like monad do-notation (:
23:53:27 <wiz> with <- and stuff
23:54:02 <shachaf> The <- isn't the important part of do notation.
23:54:22 <shachaf> The part where the thing to the left of the <- isn't a variable is a whole lot more important, for example.
23:55:09 <shachaf> You can't say "x <- 0; for i from 1 to 10 { x <- x + i }", even disregarding the rest of that syntax.
23:55:18 <shachaf> It's just not a variable.
23:55:54 <gibiskus> sup all. who are can speak russian?
23:56:08 <shachaf> (And do-notation isn't really "imperative", either.)
23:57:15 <shachaf> gibiskus: There's a #haskell.ru but I think it's pretty empty.
23:58:07 <wiz> there also xmpp:haskell@conference.jabber.ru
