00:00:24 <Axman6> but it seems like something that'd only work in a few rare situations, that it's not worth adding
00:03:38 <bcw> osa1, are you talking about this kind of pattern matching? http://xahlee.info/ocaml/pattern_matching.html  -- if so, you should look into case expressions: "case list of [] -> []; (x:xs) -> xs"
00:04:53 <osa1> bcw: no, I'm talking about multiple patterns having same body. see second code in "alternatives" section in that page
00:04:57 <Axman6> i can;t see anything there that looks like mathcing multiple patterns at once...
00:05:23 <liyang> match 4 with 3 | 4 | 5 -> 6;;
00:05:25 <osa1> Axman6: go read Okasaki's RB-tree implementation, it's super useful in that kind of jobs
00:05:30 <osa1> liyang: yeah, that one
00:05:51 <bcw> osa1, ok. sorry then
00:05:52 <zzing_> Ocaml uses match? That must be why I occassionally start typing it
00:06:07 <Axman6> well, apart from that, but that's trivial with guards| case x of _ | x `elem` [3,4,5] -> body
00:06:47 <Axman6> which is strictly more powerful than OCaml's match I think (since you can use any predicate you like)
00:09:31 <bcw> Axman6, that's a good hack, but a little ugly.  and what if the elements are not in Eq class?  (i forget, but i think haskell can pattern match against things not in Eq, no?)
00:10:27 <liyang> bcw: that's one of pattern guards' intended uses I believe.
00:12:04 <liyang> You can match against any constructor, whether its type has an Eq instance or otherwise.
00:12:37 <shachaf> I don't think that helps with bcw's case, though?
00:13:11 <bcw> that's what i thought, but elem needs an Eq a
00:16:00 <dmwit> Axman6: Your translation misses the point of OCaml's multiple-match, because the example that osa1 gave happens not to bind any variables.
00:16:56 <zzing_> Can anyone recommend a solution to my cabal warning? http://hpaste.org/70973
00:18:44 <bcw> zzing, can you use pandoc-1.9.4.2 instead of 1.9.4.1?
00:18:59 <zzing_> certainly
00:19:04 <zzing_> I wasn't aware of something newer
00:19:33 <bcw> (i actually am installing pandoc right now :))
00:19:37 <wagle> i rip cabal out of the wall every so often and reinstall from scratch, often solves these problems
00:19:45 <zzing_> I am not sure where that highlighting-kate thing came from
00:20:01 <dmwit> The usual thing is to add some constraints and see why it complains.
00:20:04 <wagle> pandoc or gitit uses it
00:20:13 <zzing_> I installed gitit
00:20:39 <dmwit> Oh, I didn't look at the link.
00:20:43 <dmwit> The solution for that is a bit trickier.
00:20:44 <wagle> dmwit's approach is superior to mine
00:21:20 <dmwit> But basically you should reinstall either pandoc and highlighting-kate with --constraint blaze-html-0.5.0.0 or xmlhtml and heist with --constraint blaze-html-0.4.3.4.
00:21:54 <zzing_> ok
00:22:05 <zzing_> pandoc is a beast :-)
00:22:08 <bcw> zzing, i'm looking at the hackage page right now though, and even the latest pandoc requires blaze-html < 0.5
00:22:50 <bcw> so my suggestion won't help.  maybe constraints will
00:23:20 * dmwit disappears
00:23:53 <zzing_> I will install from git then
00:24:32 <bcw> dmwit, i didn't mean to ignore your same suggestion and make you vanish, if that's what you mean... i meant to second your suggestion
00:24:59 <dmwit> no, no, I'm just leaving
00:25:02 <dmwit> nothing to do with you =)
00:25:07 <bcw> oh, ok. sorry :)
00:25:14 <bcw> good night/day
00:25:16 <zzing_> cabal install highlighting-kate --constraint blaze-html-0.5.0.0   prints dependency expected
00:27:21 <wagle> bcw..  pandoc's constraints are very complicated
00:28:24 <bcw> wagle, so i've noticed.  i actually installed the latest Haskell Platform from source (my distro doesn't have it packaged yet) just so I could use the latest pandoc :)
00:29:26 <zzing_> I wish there was a platform that was more server oriented as opposed to needing gui stuff :-)
00:36:03 <dmwit> zzing_: Oh, the syntax is probably something like --constraint "blaze-html == 0.5.0.0".
00:36:34 <zzing_> yes it is, figured it out, and building now
00:36:42 <zzing_> a stack overflow post lead me there
00:36:49 <wagle> oh cool..
00:39:23 <bcw> ack, i didn't read the long list of pandoc's dependencies well enough.  it IS possible to build pandoc with blaze-html 0.5, it's just not the first alternative in the dependency list
00:40:43 <bcw> or at least it should be possible, if the dependency list is accurate
00:40:44 <wagle> i seem to have done it by starting out with a fresh install
00:43:05 <bcw> wagle, that's what i usually do.  i usually don't try messing with constraints on packages, i just delete ~/.cabal and ~/.ghc and start over
00:43:27 <bcw> or install a new platform if one is needed and available
00:44:19 <wagle> yeah..  mastering constraints seems more likely to get people who understand it enough to actually FIX THE DARNED THING, though..  8)
00:44:49 <wagle> i did the new platform too
00:47:53 <zzing_> For a new project is something like  base > 4.5, base < 5  appropriate?
00:59:34 <bcw> zzing, as you can see from http://hackage.haskell.org/platform/changelog.html -- base 4.5 is included in the 2012 platform, but not earlier.  so the answer to your question depends on whether or not you care that people who are still using older versions won't be able to use your project
01:03:22 <walt0r> How does x(y@(a,b):ys) match a list ?
01:04:54 <danr> walt0r: it matches a list where the first element is the tuple (a,b), and the rest is ys
01:05:13 <danr> walt0r: and further, y is bound to (a,b), and x is the name of the function
01:05:31 <danr> which makes me think that you look at obfuscated code :p
01:06:35 <bcw> walt0r, the y@(a,b) is called an "as pattern", by the way.
01:06:46 <bcw> if you want to look it up
01:07:20 <walt0r> danr: thanks! x is name of which function ? 
01:07:22 <plmday> Hi, guys, I have a question about output characters.  How can I output control characters?  I want mimic the behavior of getLine.  When I call getLine, I can press for example the left arrow button, and I get ^[[D echoed.
01:07:52 <danr> walt0r: well if the line starts x(y@(a,b):ys) = some expression, then this defines the function x
01:09:03 <danr> walt0r: however, x@(y@(a,b):ys) is a valid pattern, and the story is the same as above, plus that x binds the entire list
01:09:58 * walt0r danr:  here is the define   helper x (y@(a,b):ys)
01:09:58 * walt0r         | x == b    = (1+a,x):ys
01:09:59 * walt0r         | otherwise = (1,x):y:ys
01:11:13 <danr> walt0r: right, it defines the function `helper', taking two arguments, x, and a list, which binds y,a,b,ys as described above
01:11:19 <bcw> walt0r, that's a different use of x than when you just put it next to the parens with no spaces or other context.
01:11:24 <merijn> plmday: You need to change the input mode from cooked mode to raw mode
01:11:49 <walt0r> merijn: got it. thx
01:11:59 <merijn> plmday: in cooked mode the OS deals with backspaces, arrows, etc. in raw mode all keypresses will be forwarded directly to your program
01:12:24 <walt0r> danr:  I understand. thanks!
01:12:44 <danr> walt0r: great :) (protip: next time paste your code at hpaste.org)
01:13:07 <walt0r> danr: yeah.
01:13:59 <plmday> merijn: thanks for the hint, how can I change the mode.  I cannot find any option to adapt the behavior of, say, putChar or putStr
01:15:02 <merijn> plmday: hSetBuffering
01:15:12 <merijn> :t hSetBuffering
01:15:14 <lambdabot> Not in scope: `hSetBuffering'
01:15:17 <merijn> hmm
01:15:27 <merijn> It's in System.IO
01:15:42 <merijn> Same as the handles for stdin, stdout and stderr
01:17:05 <danr> hSetBuffering stdout NoBuf
01:17:10 <merijn> You can also google for terminal modes, there should be plenty of explanations as haskell just follows the usual C/*nix behaviour
01:17:15 <danr> ouch, NoBuffering, sorry
01:17:30 <merijn> Oh, wait
01:17:34 <merijn> I might have misparsed
01:17:56 <merijn> Outputting those characters I don't think has an existing solution
01:18:24 <merijn> You'd probably need to implement/write that yourself as the resulting key combination depends on your terminal, afaik
01:20:25 <plmday> merijn: It seems to me the BufferMode type is not what I want
01:21:55 <merijn> plmday: No, it's not. I misunderstood your initial question
01:22:25 <plmday> merijn: Hmm, I have to do it myself...  But apparently getLine has already done the job well, do you have any clue how it is achieved?
01:22:27 <bcw> i'm not an expert on terminals (or much else :)), but I think the ^[[D is being generated BY the terminal, and you'll get something different from getLine if you're using an incompatible terminal
01:22:54 <plmday> bcw: Ah, that is possible.
01:24:29 <bcw> the terminfo package might be useful here, i think...
01:25:12 <bcw> but i haven't used it myself, so i dunno
01:25:21 <merijn> plmday: It's not done by getLine, it's done by your terminal
01:26:09 <plmday> merijn: OK, I see. Thanks
01:26:19 <plmday> bcw: Thanks. I will look into it.
01:26:28 <bcw> plmday, yw :)
02:37:54 <t7> whats the state of compiling to arm?
02:38:25 <t7> (I just got a nice new quad core phone)
02:39:54 <shachaf> Compiling to ARM /= compiling to Android.
02:40:00 <shachaf> (I have no idea whether your phone runs Android.)
02:44:42 <t7> yes
02:44:46 <t7> and debian
02:46:08 <bitonic> t7: arm support got a lot better recently, afaik
02:46:37 <tertl6> what is an atom?
02:47:48 <bitonic> tertl6: uhm. Haskell, the language, does not have anything named "atom". maybe you were looking for prolog :)
02:48:01 <tertl6> no
02:48:18 <tertl6> data LispVal = Atom String
02:48:35 <bitonic> tertl6: where are you reading that?
02:48:38 <tertl6> atom is a lisp word?
02:48:48 <tertl6> its a lisp REPL in haskell
02:48:52 <tertl6> scheme actually
02:48:56 <bitonic> Atom is the name of the constructor
02:49:18 <tertl6> ok so this is a haskell constructor
02:49:52 <bitonic> tertl6: yes. You may want to read
02:49:53 <wagle> lisp atom is a element of a list thats not a cons cell..  term atom was deprecated 20 years ago I thought
02:49:56 <bitonic> @where LYAH
02:49:57 <lambdabot> http://www.learnyouahaskell.com/
02:50:25 <tertl6> i know bitonic I am reading that but this looked like more funn
02:50:46 <bitonic> tertl6: well it'll be hard to read haskell code knowing *nothing* about haskell :)
02:51:12 <wagle> in that definition, atom is an symbol...
02:51:21 * tertl6 back to the drawing board
02:51:29 <wagle> symbols have names
02:51:45 <tertl6> so its a symbol or constructor?
02:51:57 <wagle> (apple pear peach) is a list of 3 symbols (atoms)
02:52:12 <tertl6> ah ok
02:52:26 <bitonic> tertl6: Atom in the code you posted is a constructor of the LispVal datatype
02:52:32 <wagle> in your code, Atom is a constructor
02:52:33 <tertl6> bitonic btw, this book argues that it can learn you a haskell
02:52:39 <bitonic> it can
02:53:06 <tertl6> i can just look up stuff as needed, no?
02:53:54 <tertl6> but anyways, an atom is a lisp type
02:53:57 <tertl6> correct?
02:54:14 <wagle> old lisp..  deprecated term in scheme
02:54:25 <wagle> but yest
02:54:27 <wagle> yes
02:54:28 <Adeon> I think the term still exists in common lisp, it just doesn't come up often
02:54:43 <Adeon> some other languages have a concept of atom that may have various meanings
02:56:01 <Adeon> and haskell doesn't have it as far as I can tell
02:56:02 <wagle> its usually something without recursive destructors
02:56:28 <wagle> nullary constructor?
02:56:52 <Adeon> are we talking about an atom in lisp
02:57:21 <wagle> 120706 03:06:27 <tertl6> data LispVal = Atom String
02:57:45 <wagle> apparently..  thought the conversation is bouncing around
02:57:59 <Adeon> hehehe
02:58:15 <tertl6> so it is infact, not a scheme keyword?
02:58:30 <tertl6> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
02:58:34 <wagle> not a scheme keyword
02:59:15 <wagle> only 4 scheme keywords: if lambda set! quote
02:59:41 <wagle> unless they changed that in the past 10 years
03:00:29 <tertl6> well what gives
03:00:30 <solrize> def-syntax
03:00:57 <tertl6> maybe its just a dialect of schemish origins?
03:01:13 <Adeon> I have trouble following this conversation
03:01:24 <wagle> oic..  what he is calling a atom is a symbol..  </pedantic>
03:01:59 <Adeon> aren't anything not a cons an atom
03:02:05 <tertl6> meanwhile Adeon scratches his head
03:02:06 <wagle> same difference though...
03:02:14 * Adeon scratches his head
03:02:27 <tertl6> ok I think I go tit
03:02:28 <wagle> Adeon: is nil an atom?  is a vector?
03:02:38 <tertl6> Atom is arbitrary here
03:03:00 <wagle> he named his constructor Atom
03:03:06 <tertl6> ah ok
03:03:16 <wagle> so yes, arbitrary
03:03:22 <tertl6> so now its all nice and wavy again
03:03:36 <Adeon> hmmmm
03:03:38 * tertl6 back to work
03:03:45 <Adeon> in common lisp atom is defined as (not cons) so they should be
03:03:51 <Adeon> but maybe that's just common lisp
03:03:55 <tertl6> yeah
03:04:09 <tertl6> he said scheme doesnt have it in 10 years
03:04:13 <tertl6> past*
03:04:49 <tertl6> interpreter is so fun: learning 2 languages at once
03:05:00 <tertl6> its like language threesome
03:05:02 <wagle> deprecated..  might still have it for compatibility or something
03:05:39 <wagle> at indiana it was "banned" from all right thinking scheme programs
03:05:56 <Adeon> the word "atom" doesn't appear in R6RS
03:06:16 <Adeon> poor atoms :-(
03:07:29 <tertl6> wagle and thats only Indiana, you shoulda seen it in Topeka
03:07:49 * tertl6 kidding sorry :\
03:08:07 <wagle> http://www.ccs.neu.edu/home/matthias/BTSS/preface.html has some discussion of atom?
03:08:21 <t7> i was really disappointed with the r6rs
03:08:28 <t7> as i was with the others
03:08:44 <wagle> isnt r7rs out recently or something?
03:09:23 <Adeon> not yet, it seems
03:09:34 <Adeon> weren't they going to split the language or something
03:10:44 <wagle> small and large (library ridden)
03:11:07 <wagle> small academic and large industrial strength?
03:11:25 <t7> webscale
03:11:25 <Adeon> we shall see
03:11:26 <wagle> i dunno..  i dont pay much attention
03:12:26 <wagle> its haskell for me these days except when writing scheme interpreters instead of helloworlds in new languages
03:13:09 <wagle> scheme is so small, you can write an interpreter for it in a sitting or three
03:14:02 <t7> does scheme have macros ?
03:14:22 <wagle> yes..
03:14:28 <t7> in the standard?
03:14:46 <wagle> i would imagine, but would have to check
03:14:50 <Adeon> yes
03:15:09 <Adeon> IIRC they aren't all-powerful though
03:15:17 <wagle> scheme isnt much without macros, OCD or not
03:15:57 * wagle was the first victim of OCD macros
03:16:14 <wagle> s/OCD/hygienic/g
03:16:33 <wagle> destroyed my project
03:16:45 <Adeon> oh, yeah, they were hygienic by default
03:17:39 <bitonic> Adeon: how aren't they all-powerful?
03:17:59 <Adeon> unless I'm mistaken, you can't use arbitrary code in macros to generate new code
03:18:02 <wagle> hygienic arent all powerful..  nonOCD are
03:18:29 <Adeon> whereas, for example, in common lisp you can use any lisp code to generate the new code
03:18:36 * Adeon is a common lisp weenie and looks down on little schemers
03:18:54 <wagle> you cant create a lexical scope with hygiene
03:19:02 <t7> static types or go home
03:19:18 <bitonic> wagle: everything you can do with non-hygienic macros you can with hygienic macros
03:19:59 <bitonic> maybe non in the exact same way - e.g. if you're relying on the macro to produce some specific symbol - but that's the wrong way of doing things
03:20:03 <wagle> metaml can't input the string "\x.x" from the keyboard and output the identity function
03:20:13 <wagle> bitonic: not in my experience
03:20:21 <Adeon> there are uses of those macros
03:20:26 <Adeon> I think they were called anaphoric or something similar
03:20:35 <bitonic> wagle: it's not about "experience"
03:20:42 <bitonic> they're functionally equivalent
03:20:52 <wagle> bitonic: no they are not
03:21:06 <wagle> i just told you the difference
03:21:14 <bitonic> wagle: well you can't do things in the exact same way
03:21:48 <bitonic> wagle: the comment about lexical scope? I don't get what you're saying with that
03:21:56 <wagle> i qualified "my experience" because its decades old..
03:22:16 <bitonic> wagle: let me find you a link.
03:23:02 <wagle> if you are just going to say "they are equivalent, period", then I will not believe you from that experience
03:23:19 <bitonic> wagle: well I still don't have a counterexample
03:23:44 <bitonic> but wait I'm looking for a source more reliable than me
03:23:49 <Adeon> can you do anaphoric lambda in hygienic macros
03:23:55 <Adeon> (alambda () (self))
03:23:57 <Adeon> self refers to lambda itself
03:24:18 <Adeon> so that would be a function that just calls itself
03:24:31 <wagle> fact: Tim Sheard agreed that I couldn't take the string "\x.x" typed in from the keyboard and output the identity function because of hygiene
03:24:51 <mm_freak> Adeon: that's fix id, isn't it?
03:24:54 <wagle> in metaml
03:25:20 <Adeon> yeah, I suppose
03:25:25 <bitonic> Adeon: well you'd have to bind the "self" symbol manually, e.g. (alambda () self (self))
03:25:25 <Adeon> just an example
03:25:32 <tertl6> does leksah have 'go to definition'?
03:25:49 <wagle> ok..  i know nothing about alambda
03:26:00 <mm_freak> > fix id
03:26:05 <lambdabot>   mueval-core: Time limit exceeded
03:26:37 <Adeon> I read about alambda in a macro book that targeted common lisp
03:26:44 <mm_freak> why doesn't GHCi detect the loop in 'fix id'?
03:26:53 <Adeon> it had a chapter about all these anaphoric macros that introduce symbols to code
03:27:03 <bitonic> mm_freak: ghci does not detect loops like GHC
03:27:09 <wagle> i did cast doubt in Kent Dybvig's mind, so maybe there's something his group produced, after my time
03:27:19 <mikeplus64> is there a binary/cereal package that works with containers 0.5.0.0 (latest) instead of 0.4.2.1?
03:28:12 <wagle> i  keep meaning to write "Hygiene Considered a Misnomer", but then I'd have to read all the current literature
03:28:52 <wagle> which i havent done yet..  not enught rainy days and such
03:29:31 <bitonic> wagle: I'm asking in #racket, since google does not yield
03:29:34 <wagle> i do collect the literature when i stumble on it, so please do send it my way
03:29:54 <bitonic> wagle: if you have a counterexample, that would end the dispute
03:29:57 <wagle> racket's a good place to look, i imagine
03:31:00 <wagle> my experience was with hygiene for the first 3-4 years, then I gave up..  hygeiene is probably more complicated now
03:31:25 <wagle> but i did give you the \x.x example twice
03:31:41 <wagle> and that's only 10 years old
03:31:44 <bitonic> wagle: can you elaborate on that example then? I don't get what you're saying
03:31:54 <bitonic> ah
03:32:07 <bitonic> why wouldn't you be able to do that?
03:32:14 <bitonic> (with hygienic macros)
03:32:32 <wagle> you can't create a variable and stick it into its own scope
03:32:52 <wagle> dynamically create a variable
03:32:56 <bitonic> wagle: but you can build your own "symbol table" with the symbols in the string
03:33:21 <bitonic> you won't get (lambda (x) x) but you can still transform the string to (lambda (something) something), no?
03:33:41 <wagle> thinking
03:34:24 <bitonic> admittedly it'll be more immediate without hygiene - you're just going to get the symbols directly out of the string
03:35:48 <bitonic> I mean non-hygienic macros are much simpler, conceptually
03:36:15 <bitonic> I probably like them more as well in a way, but they're dangerous :P
03:36:40 <wagle> i cant evaluate whether that works or not, I'm too tired, and I dont know modern macrology
03:38:03 <wagle> i dont think it works, because eugene's original algorithm produced (lambda (something) something) where the somethings were different
03:38:38 <wagle> but Kent told dme it was thought to be broken..  but I never saw the fix
03:39:06 <bitonic> wagle: I'll try to do it in racket in a bit :)
03:39:06 <wagle> but TIm said that you couldnt do it in metaml
03:39:12 <bitonic> a lambda calculus macro
03:39:18 <bitonic> ah. never used metaml.
03:39:31 <wagle> racket is in boston, 6:40 am
03:39:39 <bitonic> what?
03:40:02 <wagle> isnt racket a NEU (Boston) thing?
03:40:22 <Adeon> I thought it is a lisp
03:40:24 <bitonic> @where racket
03:40:25 <lambdabot> I know nothing about racket.
03:40:36 <bitonic> @where+ racket http://racket-lang.org/
03:40:36 <lambdabot> Done.
03:40:40 <bitonic> @where racket
03:40:40 <lambdabot> http://racket-lang.org/
03:40:44 <bitonic> wagle: there :)
03:41:06 <bitonic> it's a scheme that grew out of scheme and has more stuff than CL in it now :D
03:41:42 <wagle> neu is northeastern university, where matthias, etal are
03:41:50 <bitonic> ah, OK.
03:41:57 <wagle> i thought they wrote racket
03:42:09 <bitonic> I think they did, I remember a Matthias.
03:42:26 <bitonic> still, hopefully they're not the only people in #racket :)
03:43:38 <eikke> is it 'done' to lift FFI IO actions (without side-effects except for mutating an STVector) into ST using unsafeIOToST?
03:44:38 <shachaf> If they're safe, then that's what unsafeIOToST is for, presumably.
03:45:51 <bitonic> eikke: if you have ref. transparent FFI calls, just wrap them into unsafePerformIO
03:46:18 <bitonic> that's one of the few legitimate uses of `unsafePerformIO'
03:46:29 <eikke> bitonic: it'll mutate a mutable vector, so no, it's not ref.transparent :)
03:46:32 <bitonic> ah no. you're modifying the vector. sorry
03:48:06 <wagle> in my case, I'd written a compiler for a DSL with macros..  scheme called the DSL, and the DSL called scheme..  lexical scopes were carefully set up to avoid inadvertant capture..  eval propagated  up and off the top of the repl..  dynamic scopes in the DSL were ALL lexical now..  hygiene was turned on one day, and the thing because undebuggable
03:48:23 <wagle> s/because/became/
03:48:56 <bitonic> wagle: well yeah you can't just "turn on" hygiene and expect things to work :)
03:49:52 <wagle> (2) they wouldnt turn off hygiene thereafter..  leaving me with my project permanently broken
03:50:18 <wagle> hygiene is good!  non-hygeine is bad!
03:50:20 <bitonic> yeah that was not nice of them.
03:52:01 <solrize> "turned on the hygiene one day"???????
03:52:30 <solrize> how does one turn hygiene on and off?
03:53:03 <wagle> took me 4 days to isolate the creation of (lamba(x) x) as NOT using the same symbol x
03:54:02 <wagle> solrize: easy, you invent OCD (aka hygiene), then you turn it loose on the whole department, without telling anyone
03:54:53 <wagle> sorry, I still have a bad attitudde about the whole affair, but I'll try to make it funny
03:55:15 <bitonic> no scheme I no has a "turn on the hygiene" flag :P
03:57:55 <tertl6> how do yuo make the command line pause?
03:58:05 <wagle> there once was a scheme that existed before OCD was invented..  One day, Eugene invented it, and put it in, mandatorially and without the ability to turn it off..  my project was destroyed.  15 years later I trounced someone in an internet go game who turned out to be eugene.  so I am avenged
03:58:23 <wagle> fix gc
03:58:49 <fmap> tertl6: what do you mean?
03:59:22 <tertl6> so it doesnt disappeat after printing Hello world etc...
04:00:58 <wagle> tertl6: how are  you running your program?
04:01:11 <tertl6> compiling it
04:01:19 <tertl6> and getting this goofy error,
04:01:31 <tertl6> dont know why I went back to hello world
04:01:31 <fmap> are you on windows?
04:01:37 <tertl6> yes
04:01:51 <tertl6> but uts giving an error when I run it
04:01:55 <wagle> its 4am.  time for sleep.  gnite
04:02:07 <fmap> ah, i see, can't help much though, sorry
04:02:32 <tertl6> ah neverminf
04:02:38 <tertl6> i was doing it wrong
04:02:38 <bitonic> wagle: night
04:02:53 <tertl6> it wanted my name right after exe
04:03:01 <tertl6> derp
04:22:05 * hackagebot base-unicode-symbols 0.2.2.4 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.2.4 (RoelVanDijk)
04:22:07 * hackagebot containers-unicode-symbols 0.3.0.7 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/containers-unicode-symbols-0.3.0.7 (RoelVanDijk)
04:32:11 <frerich> Is anybody aware of other interesting uses of (&&&) with arrows other than (->)? I like how it shortens \f g x -> (f x, g x)
04:32:28 <frerich> to 'f &&& g', but are there other uses?
04:33:49 <frerich> Like, I woner whether sections of (&&&) would be useful for something...
04:33:59 <bitonic> frerich: processing streams?
04:38:37 <frerich> @hoogle Arrow a => a b x -> a b y -> a b z -> a b (x, y, z)
04:38:38 <lambdabot> No results found
04:39:56 <unnali> :t first
04:39:58 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
04:40:30 <unnali> @djinn Arrow a => a b x -> a b y -> a b z -> a b (x, y, z)
04:40:31 <lambdabot> Error: Class not found: Arrow
04:40:38 <unnali> @djinn Control.Arrow.Arrow a => a b x -> a b y -> a b z -> a b (x, y, z)
04:40:38 <lambdabot> Error: Class not found: Control.Arrow.Arrow
04:40:41 <unnali> pah!
04:42:06 * hackagebot symbol 0.1.3 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.1.3 (GeoffreyMainland)
04:48:16 <hpaste> b52 pasted “benchmark constant functions” at http://hpaste.org/70980
04:48:43 <b52> how can i meassure how long it takes for the app to calculate the const functions?
04:50:47 <parcs`> b52: those aren't constant functions, they're just constants
04:50:57 <b52> my bad
04:51:01 <parcs`> you can use the criterion package
04:51:25 <b52> yeah, i know, but how can i tell it that it should reevaluate each call?
04:51:43 <b52> i mean i dont know when ghc actually computes e.g. euler001
04:54:37 <parcs`> good point
04:56:19 <parcs`> looks like you'll have to turn those constants into a function () -> Int or IO Int if you want to use criterion on them
04:56:33 <bitonic> b52: you can use ghc-core to check what's going on in excruciating detail
04:57:33 <Goatflakes> o hai
04:59:32 <Goatflakes> :<
04:59:42 <b52> bitonic: ?
05:01:05 <frerich> b52: I'm not familiar, but if criterion wants functions then maybe you could feed it `const euler001 ()' or so?
05:01:18 <bitonic> b52: http://hackage.haskell.org/package/ghc-core will show you the core in a nice formatted way
05:02:32 <Goatflakes> what is core? I'm guessing it's the bit of ghc that isn't written in haskell?
05:03:20 <bitonic> Goatflakes: no, Core is the representation used internally in GHC that Haskell is derugared to
05:03:42 <Goatflakes> and by that i mean it might be writen in haskell, but is compiled or whatnot
05:03:44 <Goatflakes> o
05:03:59 <Goatflakes> what's derugared? o.o
05:04:04 <mauke> desugared
05:04:08 <Goatflakes> o
05:04:23 <mauke> as in, remove the syntactic sugar
05:04:34 <Goatflakes> intermediate representation language in compiler construction talk?
05:04:54 <Goatflakes> yeah i know what desugared is
05:04:56 <mauke> I think so
05:04:58 <sipa> Goatflakes: yes, quite so
05:05:02 <Goatflakes> thanks
05:05:34 <mauke> I think the pipeline goes roughly like Haskell -> Core -> C-- -> machine code but I'm very fuzzy on details
05:05:47 <bitonic> Goatflakes: desugar in this context means removing a lot of syntactic sugar, "flattening" case expressions, make types explicit
05:05:54 <Goatflakes> yep
05:06:01 <bitonic> mauke: there's STG between Core and C--
05:06:07 <Goatflakes> i get it
05:06:09 <Goatflakes> wait
05:06:11 <Goatflakes> STG?
05:06:26 <bitonic> spineless tagless g machine
05:06:28 <Goatflakes> and c-- haven't heard of that for a while :p
05:06:36 <mauke> but I thought ghc used tags
05:06:45 <bitonic> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain
05:07:10 <bitonic> http://hackage.haskell.org/trac/ghc/attachment/wiki/Commentary/Compiler/HscPipe/HscPipe2.png
05:07:56 <bitonic> the cool thing is that Core can (and is) typechecked as well
05:08:06 <Goatflakes> i kind of feel at the moment like i did when i first came to unix. like i have gotten on a horse and ridden off in several directions at once :p
05:08:33 <irene-knapp> this happens
05:09:11 <bitonic> Goatflakes: yeah if you're a beginner, don't worry about that :)
05:09:12 <Goatflakes> back to the salt mines. later :D
05:09:59 <bitonic> but Core is very cool, I mean it's so simple: http://hackage.haskell.org/trac/ghc/browser/compiler/coreSyn/CoreSyn.lhs#L262
05:11:37 <sipa> type is an expression in core?
05:12:07 * hackagebot paragon 0.1.25 - Paragon  http://hackage.haskell.org/package/paragon-0.1.25 (NiklasBroberg)
05:12:25 <bitonic> sipa: yeah types are passed explicitly
05:21:57 <mel-> i understand that ghc generates C-- code -- but what is the name of the program which compiles C-- code into machine code?
05:22:29 <sipa> mel-: according to that linked image, there are 3 backends
05:22:50 <MagneticDuck> yo, how do I concatenate two (IO String) s?
05:22:54 <MagneticDuck> with do notation it's easy
05:23:00 <MagneticDuck> what's a pl method?
05:23:11 <unnali> MagneticDuck: to get one IO String, you mean?
05:23:21 <MagneticDuck> unnali: Yes.
05:23:22 <hpaste> b52 pasted “criterion profiling” at http://hpaste.org/70983
05:23:25 <Saizan> liftM2 (++)
05:23:28 <b52> whats teh matter?
05:23:28 <MagneticDuck> ty
05:23:33 <unnali> @type liftM2 (++)
05:23:35 <lambdabot> forall a1 (m :: * -> *). (Monoid a1, Monad m) => m a1 -> m a1 -> m a1
05:23:47 <MagneticDuck> ah okay
05:23:55 <MagneticDuck> forgot
05:23:56 <MagneticDuck> ty
05:24:58 <MagneticDuck> and to concatenate a string and an IO String is just "fmap . (++)" right?
05:25:06 <MagneticDuck> @type fmap . (++)
05:25:07 <lambdabot> forall b (f :: * -> *). (Functor f, Monoid b) => b -> f b -> f b
05:25:14 <MagneticDuck> yeah of course
05:25:16 <unnali> :) should do the trick, going by that.
05:25:31 <MagneticDuck> okay
05:26:02 <MagneticDuck> my understanding of monads (and all the utility functions like liftM) isn't that polished
05:26:11 <MagneticDuck> right now I'm just trying to get something done!
05:26:54 <unnali> MagneticDuck: expect a lot of magic and hand waving in the short-term future then ;-) but I think that'll actually help build the foundations for gaining an intuition and more solid understanding soon.
05:27:52 <MagneticDuck> unnali: That is, I understand what a monad is completely, but I haven't worked with them enough to have fresh in my brain what liftM does
05:28:02 <MagneticDuck> heh
05:28:03 <sipa> :t liftM
05:28:04 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
05:28:08 <unnali> MagneticDuck: well, fmap ~ liftM, just functors v. monads.
05:28:11 <Nereid> :t fmap
05:28:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:28:18 <unnali> MagneticDuck: but that's probably not a helpful thing to say at this stage.
05:28:22 <MagneticDuck> oh...
05:28:30 <MagneticDuck> wait
05:28:32 <sipa> MagneticDuck: takes an operation on values, and returns an operations that does the same on the value produced by a monad
05:28:36 <Nereid> every monad is a functor, where fmap = liftM
05:28:43 <MagneticDuck> but I can't always use fmap instead of liftM
05:28:53 <unnali> MagneticDuck: correct, but you can do the other way around.
05:28:54 <Nereid> you should be able to
05:29:03 <MagneticDuck> interesting
05:29:08 <unnali> wait
05:29:10 <Nereid> every Monad instance should also be a Functor instance
05:29:10 <unnali> I'm so wrong
05:29:14 <unnali> I had that completely ass-backwards
05:29:15 <MagneticDuck> yeah
05:29:16 <sipa> everywhere you use liftM, you can use fmap too, if the monad is well-behaved
05:29:23 <MagneticDuck> ah okay
05:29:35 <MagneticDuck> but of course not all functors are monads
05:29:41 <sipa> indeed
05:29:41 <MagneticDuck> wait, what functors aren't monads...
05:29:53 <MagneticDuck> I'm trying to think of a functor that isn't also a monad
05:30:20 <MagneticDuck> any hints?
05:30:22 <MagneticDuck> I can't think of any
05:30:23 <unnali> MagneticDuck: you could make one yourself pretty quickly :3
05:30:27 <MagneticDuck> heh
05:30:28 <MagneticDuck> yeah
05:30:35 <Nereid> MagneticDuck: how about pairs
05:30:41 <MagneticDuck> but I would also probably be able to define it as a monad
05:30:41 <MagneticDuck> ah
05:30:49 <MagneticDuck> well
05:30:53 <MagneticDuck> writer is a monad
05:30:57 <Nereid> type Pair a = (a,a)
05:30:59 <MagneticDuck> so pairs are monads sometimes
05:31:13 <Nereid> well, data Pair a = Pair a a
05:31:19 <Nereid> that's easily made into a functor
05:31:20 <MagneticDuck> well they aren't monads because they can be a monad in two different ways
05:31:23 <Nereid> but not a monad
05:31:57 <MagneticDuck> well in writer you have the monoid restraint on the first value
05:32:07 * hackagebot egison 2.1.11 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.11 (SatoshiEgi)
05:32:10 <MagneticDuck> well you can make just about anything a monad
05:32:21 <Nereid> you actually can't make Pair a monad.
05:32:21 <MagneticDuck> if you're not concerned about actually using it
05:32:26 <MagneticDuck> you can't?
05:32:31 <Nereid> not one that satisfies the moand laws, anyway, and is compatible with the obvious Functor instance.
05:32:39 <unnali> ooh, monad laws, good call
05:33:03 <sipa> you can make (GivenType,a) into a monad though
05:33:08 <sipa> wait, no
05:33:08 <Nereid> sure.
05:33:10 <Nereid> you can.
05:33:23 <Nereid> or wait.
05:33:26 <sipa> how would you implement return?
05:33:28 <Nereid> no, never mind.
05:33:33 <Nereid> that's a comonad.
05:33:43 <Nereid> so sure, that's another example.
05:33:49 <MagneticDuck> (a, b) >>= (\f -> let (a', b') = f (a, b) in (a', b'))
05:33:58 <MagneticDuck> that doesn't satisfy which law?
05:34:05 <MagneticDuck> oh
05:34:06 <MagneticDuck> return
05:34:07 <MagneticDuck> yeah
05:34:09 <Nereid> that doesn't compile
05:34:15 <MagneticDuck> yeah yeah
05:34:34 <MagneticDuck> pair >>= (\f -> let (a', b') = f pair in (a', b'))
05:34:40 <MagneticDuck> well it still doesn't
05:34:49 <MagneticDuck> I'm making an affirmation, not a declaration
05:35:13 <Nereid> what
05:35:14 <MagneticDuck> okay
05:35:26 <Nereid> you wrote an expression.
05:35:30 <Nereid> what about it.
05:35:51 <MagneticDuck> I'm saying something about >>= in my definition for (Monad pair)
05:36:01 <Nereid> not really.
05:36:13 <MagneticDuck> ..?
05:36:32 <Nereid> you aren't saying anything is equal to anything.
05:36:35 <MagneticDuck> anyhow I understand why you can't make a pair a monad now
05:36:40 <Nereid> ok
05:36:40 <MagneticDuck> oh
05:36:43 <MagneticDuck> >_<
05:37:08 <MagneticDuck> pair >>= f = let (a', b') = f pair in (a', b')
05:37:32 <unnali> but 'f' is "a -> Pair b"
05:37:32 <Nereid> pair >>= f = f pair?
05:37:35 <Nereid> ^
05:37:37 <mauke> that doesn't typecheck
05:37:38 <MagneticDuck> yeah
05:37:40 <MagneticDuck> jfkdjs
05:37:47 <MagneticDuck> pair >>= f = f pair
05:37:52 <Nereid> uh no.
05:37:54 <unnali> as above!
05:38:00 <MagneticDuck> yes
05:38:04 <Nereid> when you say pair >>= f
05:38:06 <sipa> :t (>>=)
05:38:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:38:11 <Nereid> where pair :: Pair a
05:38:15 <Nereid> you must have f :: a -> Pair b
05:38:16 <unnali> pair :: Pair a; f :: a -> Pair b
05:38:18 <MagneticDuck> jkdsfj
05:38:21 <Nereid> and then "f pair" doesn't typecheck
05:38:26 <MagneticDuck> pair >>= f $ fst pair = f pair
05:38:29 <MagneticDuck> HAPPY NOW?
05:38:32 <MagneticDuck> :P
05:38:41 <MagneticDuck> jdklfjs
05:38:45 <Nereid> not really
05:38:46 <Nereid> :P
05:38:49 <unnali> :D!
05:38:52 <MagneticDuck> pair >>= f = f . fst $ pair
05:38:56 <MagneticDuck> NOW???
05:39:06 <MagneticDuck> oh sigh
05:39:08 <MagneticDuck> wow
05:39:14 <MagneticDuck> how many tries did it take to get that one?
05:39:14 <Nereid> uh sure
05:39:14 <mauke> snd, maybe
05:39:19 <Nereid> but it doesn't matter
05:39:20 <MagneticDuck> but anyway
05:39:23 <Nereid> it won't satisfy the laws
05:39:25 <MagneticDuck> I understand why
05:39:26 <unnali> ^
05:39:26 <MagneticDuck> yeah
05:39:28 <MagneticDuck> okay
05:39:35 <MagneticDuck> aaahhh
05:39:49 <MagneticDuck> forget this
05:39:51 <hpaste> b52 pasted “installing Chart under win” at http://hpaste.org/70984
05:39:55 <b52> an idea?
05:40:02 <Nereid> like
05:40:10 <Nereid> the only possible thing return could be is
05:40:12 <Nereid> return x = (x,x)
05:40:13 <unnali> MagneticDuck: I enjoyed that
05:40:21 <Nereid> and there's no way you'll have pair >>= return = pair
05:40:33 <MagneticDuck> yeah
05:40:56 <MagneticDuck> maybe if I get a monad law tee-shirt I won't forget them
05:41:13 <MagneticDuck> *buys tee-shirt from haskell.org*
05:41:35 <mauke> instance (Monoid a) => Monad (a, b) where { return x = (mempty, x); (a, x) >>= f = let (b, y) = f x in (mappend a b, y) }
05:41:38 <Nereid> or "a monad is a monoid object in the monoidal category of endofunctors (of Hask)" :s
05:42:02 <MagneticDuck> endofunctors?
05:42:05 <MagneticDuck> functors are nice
05:42:08 * hackagebot paragon 0.1.26 - Paragon  http://hackage.haskell.org/package/paragon-0.1.26 (NiklasBroberg)
05:42:09 <MagneticDuck> applicative functors are getter
05:42:14 <MagneticDuck> WE DON'T NEED NO ENDOFUNCTORS!
05:42:26 <Cale> huh?
05:42:30 <Nereid> huh
05:42:32 <MagneticDuck> huh
05:42:34 <sipa> WE DON'T NEED NO FLOW CONTROL
05:42:51 <Nereid> don't worry I'm just speaking abstract nonsense.
05:42:56 <MagneticDuck> me too
05:42:59 <MagneticDuck> back to work now
05:43:00 <Cale> Every instance of the Haskell Functor typeclass is an endofunctor.
05:43:02 <Nereid> in the technical sense.
05:43:04 <Nereid> ^
05:43:07 <Cale> (every correct instance anyway)
05:43:37 <MagneticDuck> is there an endofunctor typeclass in haskell?
05:43:43 <Nereid> yes, it's called Functor
05:43:45 <Cale> Yes, it's called Functor
05:43:46 <Cale> heh
05:43:53 <MagneticDuck> >_<
05:44:29 <Cale> It's harder to encode functors which go between different categories in Haskell.
05:44:51 <Nereid> that first requires defining "different categories".
05:44:54 <Cale> yes
05:45:14 <fmap> mauke: shouldn't it be `Monad ((,) a)' instead of `Monad (a,b)'?
05:45:19 <mauke> yes
05:45:42 <mauke> I was thinking GADTs for some reason
05:46:47 <Nereid> I wonder if it would be easier to remember the monad laws written in terms of join instead of bind
05:47:09 * hackagebot http-conduit 1.5.0.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.5.0.1 (MichaelSnoyman)
05:47:22 <Nereid> (and fmap of course)
05:47:27 <Nereid> what would they be
05:48:04 <jaxtr> ahh it's a wonderful day
05:49:14 <Nereid> hmm:
05:49:32 <Nereid> join . return = id, join . fmap return = id, and join . fmap join = join . join, or something?
05:49:35 <Nereid> lol
05:50:05 <Nereid> better to draw the commutative diagrams.
05:50:55 <MagneticDuck> I was just wondering.. is there any utility function like "foldl1 liftM2"?
05:51:26 <fmap> @type foldl1 liftM2
05:51:27 <lambdabot>     Occurs check: cannot construct the infinite type: a2 = a2 -> r
05:51:28 <lambdabot>       Expected type: a2 -> r
05:51:28 <lambdabot>       Inferred type: (a2 -> r) -> a2
05:51:30 <Nereid> I don't know what "foldl1 liftM2" is supposed to be. what are you trying to do?
05:51:35 <MagneticDuck> ar
05:51:37 <MagneticDuck> wait
05:51:54 <MagneticDuck> I was just wondering.. is there any utility function like "foldl1 . (liftM2 mappend)"?
05:52:07 <sipa> :t foldl1 . (liftM2 mappend)
05:52:08 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = a1 -> a1
05:52:08 <lambdabot>       Expected type: (a1 -> a1) -> a1 -> a1 -> a1
05:52:09 <lambdabot>       Inferred type: (a1 -> a1) -> (a1 -> a1) -> a1 -> a1
05:52:12 <Nereid> :t mappend
05:52:12 <MagneticDuck> arr
05:52:13 <lambdabot> forall a. (Monoid a) => a -> a -> a
05:52:36 <Nereid> :t foldl1 (liftM2 mappend)
05:52:37 <lambdabot> forall a1 (m :: * -> *). (Monoid a1, Monad m) => [m a1] -> m a1
05:52:53 <MagneticDuck> I'm trying in my problem to get a function like [IO String] -> IO String
05:53:03 <Nereid> if that's what you mean, then yes--it's called foldl1 (liftM2 mappend)
05:53:14 <Nereid> :s
05:53:15 <MagneticDuck> okay
05:53:18 <Nereid> uh
05:53:21 <Nereid> there's also
05:53:23 <Nereid> what was it
05:53:25 <LaughingMan> why can't I make 'ms' a binary infix operator?
05:53:26 <Nereid> :t sequence
05:53:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:53:32 <Nereid> right, so
05:53:38 <MagneticDuck> okay I'm just poking around
05:53:47 <Nereid> you could use
05:53:53 <Nereid> sequence :: [IO String] -> IO [String]
05:54:02 <fmap> @type fmap mconcat . sequence
05:54:04 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f, Monad f) => [f a] -> f a
05:54:04 <MagneticDuck> I guess concatenating a list of monads containing monoids isn't a very much used function
05:54:07 <Nereid> and then join :: [String] -> String
05:54:08 <Nereid> with fmap
05:54:25 <MagneticDuck> Ah
05:54:39 <MagneticDuck> @type sequence
05:54:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:54:48 <Nereid> @src sequence
05:54:48 <lambdabot> sequence []     = return []
05:54:48 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:54:48 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
05:55:14 <MagneticDuck> brain loading...
05:55:20 <Nereid> or yeah
05:55:33 <MagneticDuck> well the OR is obviously more easy to read
05:55:56 <MagneticDuck> @type liftM2
05:55:58 <Nereid> well, fmap mconcat . sequence = foldr (liftM2 mappend) (return mempty)
05:55:58 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:56:02 <Nereid> I think
05:56:20 <MagneticDuck> huh?
05:56:44 <MagneticDuck> @type return mempty
05:56:45 <lambdabot> forall a (m :: * -> *). (Monoid a, Monad m) => m a
05:57:02 <Nereid> mempty = "", for strings.
05:57:07 <MagneticDuck> yeah
05:57:14 <Nereid> anyway.
05:57:27 <Nereid> maybe I should rewrite that equation as
05:57:44 <Nereid> liftM (foldr mappend mempty) . sequence = foldr (liftM2 mappend) (return mempty)
05:57:47 <Nereid> I hope this is true.
05:58:23 <Nereid> just expanding out the definition of mconcat.
05:58:46 <Nereid> also, avoid stuff like foldl1 when possible, since that's not total
05:58:52 <Nereid> (error when given an empty list)
05:58:59 <MagneticDuck> yeah
05:59:23 <Nereid> whoops it's 6am already, night
05:59:32 <MagneticDuck> o.o
05:59:49 <MagneticDuck> you're on a nocturnal schedule?
06:00:14 <MagneticDuck> anyway thanks for the help
06:07:10 * hackagebot authenticate 1.3.0.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.0.1 (MichaelSnoyman)
06:37:47 <spobat> ;
06:52:14 * hackagebot hdbc-postgresql-hstore 0.0.1.1 - Manipulate data in PostgreSQL "hstore" columns.  http://hackage.haskell.org/package/hdbc-postgresql-hstore-0.0.1.1 (AlexanderBondarenko)
06:56:03 <nkuttler> is http://learnyouahaskell.com a good place to start?
06:57:17 <barrucadu> nkuttler: Yes
06:57:34 <nkuttler> barrucadu: ok, thanks
06:58:22 <nschoe> Hi everyone, I am not sure it is the right channel to post in, but I'll try anyway. I have managed to install SDL on my mac, and successfully installed sdl and sdl-image wth cabal. But when I try to run even the simplest haskell application, here is the error I get: http://pastebin.com/1hhB2S25 . Is there anyone who can help me?
06:58:24 <mauke> The paste 1hhB2S25 has been copied to http://hpaste.org/70990
06:59:01 <nschoe> I mean... I have never succeeded in making Haskell/SDL applications run un on my mac. I am beginning to wonder if that's even possible.
07:07:15 * hackagebot HDBC-postgresql-hstore 0.0.1.2 - Manipulate data in PostgreSQL "hstore" columns.  http://hackage.haskell.org/package/HDBC-postgresql-hstore-0.0.1.2 (AlexanderBondarenko)
07:12:38 <nschoe> Any idea? Any fix? Please.
07:21:19 <bitonic> nschoe: post on the ML if nobody answers here
07:21:32 <nschoe> "ML" ?
07:21:39 <bitonic> mailing list
07:21:43 <bitonic> @where haskell-cafe
07:21:44 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
07:21:57 <nschoe> hum, ok. Thanks for the tip
07:21:57 <bitonic> I'd help you if I had a mac.
07:22:13 <bitonic> I can give you a more general advice: don't use mac os x
07:22:21 <nschoe> Yeah, well I usually don't dev' on the mac. But I have no choice for now
07:33:59 <EvanR> dont use mac? lol
07:35:53 <nschoe> EvanR: Do you use mac? And if yes... SDL too? ^^
07:35:54 <fmap> i don't get why (.) is infixr 9 but (<=<) is infixr 1. this doesn't make sense
07:36:26 <EvanR> i use mac and know a lot about sdl 1.2
07:36:38 <EvanR> but not sdl on mac
07:36:58 <nschoe> erf.
07:37:03 <nschoe> Too bad :/
07:37:12 <EvanR> common question in #sdl is how the hell to make it work on mac
07:38:37 <nschoe> How ok, so it's not just me.
07:39:01 <EvanR> haskell bindings only gonna make it more complex ;)
07:39:04 <nschoe> How come it is so tough to make it work on mac? Isn't it suposed to be cross-plateform? Who is to blame here, mac or SDL devs?
07:39:11 <nschoe> Yes I bet they would.
07:39:13 <EvanR> it works on mac
07:39:22 <sipa> or the sdl binding devs?
07:39:22 <EvanR> building the program isnt crossplatform though
07:39:45 <EvanR> you need a different build setup on each platform
07:40:21 <EvanR> and any gui stuff on mac needs some objective c code, i think
07:40:59 <ksf> dang. compiling, in my case, probably in general, mirrors what shake does.
07:41:18 <nschoe> "it works on mac" -> does it? I mean, I could install it, but no run any SDL program.
07:41:18 <ksf> that is, the in-file dependencies and getting them compiled do.
07:41:41 <EvanR> nschoe: well people typically like to bundle sdl with their mac app
07:41:56 <EvanR> so you wouldnt need to install any dev libs
07:42:07 <nschoe> EvanR: hum I read about this... it means create a .app mac application that works on its own, right?
07:42:13 <EvanR> yes
07:42:16 * hackagebot language-puppet 0.1.5 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.1.5 (SimonMarechal)
07:42:35 <EvanR> im not sure what the state of the art is as far as getting a program like that to work mac written in haskell
07:42:42 <nschoe> Okay, but I suppose it is hard work, just for making it work.
07:43:01 <ksf> it's probably trivial if you know what you're doing.
07:43:03 <EvanR> mac has a reputation for being WTF for developers
07:44:46 <nschoe> Hum, I hope somebody will be able to help me on the mailing list, because I suppose people in #sdl won't be able to help me, since it deal with Haskell.
07:45:04 <ksf> the problems should be the same as with C.
07:45:42 <ksf> ghc does nothing more than saying -lsdl when compiling, the rest is stardard .so handling of the os.
07:48:13 <nschoe> Hum, ok. So I might get answers on #sdl?
07:48:23 <parcs`> EvanR: which puzzles me as to why so many developers use it
07:49:38 <nschoe> parcs`: Are there that many devs using macs ?
07:52:43 <parcs`> nschoe: i'm not sure. it seems so, at least
07:53:05 <nschoe> Hum, always wondered, too.
07:53:07 <EvanR> nschoe: in SDL most people know C
07:53:09 <tdammers> I know quite a few people who swear by macs
07:53:26 <nschoe> tdammers: Yeah well, I guess we all know some...
07:53:38 <tdammers> you do get a pretty GUI *and* Unix, have to give them that much credit
07:54:00 <nschoe> EvanR: yeah, so? They are most likely to make me edit some .h or .c SDL file, won't they?
07:54:01 <tdammers> and the hardware is of decent quality - not stellar, but you know what you get
07:54:16 <EvanR> nschoe: you dont need to edit any source files lol
07:54:17 <nschoe> tdammers: True. They should improve their compatibility, though.
07:54:31 <tdammers> compatibility with what?
07:54:40 <nschoe> EvanR: really? So, how are they going to hlep me then?
07:54:48 <nschoe> tdammers: Well with SDL for a starter^^
07:54:55 <tdammers> hehe
07:55:00 <EvanR> nschoe: i didnt say they would be able to
07:55:14 <tdammers> it's kind of the other way around though
07:55:28 <tdammers> SDL lacks proper support for OS X
07:55:47 <tdammers> apple dropping support for X11 applications doesn't really help though
07:55:50 <nschoe> tdammers: Well, I don't understand: is't OS X based on Unix? And isn't SDL Unix-compatible?
07:56:01 <EvanR> SDL's osx driver uses quartz
07:56:02 <nschoe> tdammers: one more compatibility issue: X11
07:56:04 <EvanR> not x11
07:56:16 <EvanR> though its x11 driver SHOULD work on osx if you have x11
07:56:31 <EvanR> getting that to work is left as an exercise to the reader
07:56:35 <nschoe> EvanR: well, that's out of my league: I am not able to follow the conversation any further :/
07:56:44 <nschoe> Well yes I believe x11 is installed on my system.
07:56:55 <EvanR> its not installed on everyones osx though
07:56:56 <nschoe> Well actually I know it is: Caml light uses it.
07:57:03 <tdammers> OS X is based on a mach kernel, which comes from NexT; on top of that, it runs a few services, one of them being a POSIX API, and the standard setup includes a BSD userland
07:57:07 <nschoe> EvanR: so is there a way to make SDL work with x11?
07:57:17 <EvanR> ask #sdl
07:57:27 <EvanR> x11 is how it works on linux
07:57:31 <EvanR> and bsd
07:57:37 <tdammers> so it's not *based* on UNIX, but for practical purposes, it *is* a UNIX, about as much as GNU/Linux
07:57:51 <nschoe> tdammers: Hum, I am sure what you said must make sense, but again: out of my league. I am no specialist, in any of that, unfortunaltey.
07:58:06 <tdammers> it's quite simple
07:58:13 <nschoe> EvanR: I will ask them, then.
07:58:35 <tdammers> an OS consists of three parts - kernel, userland, graphical environment. Roughly speaking that is.
07:58:48 <EvanR> none of this has to do with the video backends
07:58:52 <EvanR> unix has no gui
07:59:09 <tdammers> unix *can* have a GUI, but you're right, it's not mandatory
07:59:29 <nschoe> tdammers: well I don't know what "mach" is, nor "NexT". I know what an API is and what the POSIX norm is, but the meaning of your "one of them being a POSIX API" doesn't make sense to me, and at last: I don't know the difference between UNIX, Linux and BSD, so... no, it is not quite simple, to me at least ^^
07:59:38 <EvanR> none of this has to do with the video backends
07:59:40 <geekosaur> x11 has been part of OS X default install since Leopard, fwiw.  leopard installed manually did not have it by default, but snow leopard and up do include it by default on manual installs
07:59:46 <EvanR> ah geekosaur
08:00:05 <Taneb> I love it when you go on hayoo for something, and there's exactly one thing for what you want
08:00:19 <nschoe> tdammers: okay, I follow you until here...
08:00:24 <tdammers> ok. You have a kernel, a userland (command line programs and a shell), and optionally a graphical environment
08:00:49 <tdammers> GNU/Linux systems usually have a linux kernel, GNU userland, and X11 graphical environment
08:00:55 <mcstar> what are 'free monads'?
08:01:08 <nschoe> Okay, I got that.
08:01:25 <tdammers> BSD systems have a BSD kernel, BSD userland, and X11 graphical environment (again, usually)
08:01:34 <bartavelle> mcstar, monads from GPL libraries
08:01:42 <tdammers> OS X has a Mach kernel, BSD userland, and its own graphical environment
08:01:47 <mcstar> now seriously
08:02:01 <EvanR> mcstar: its when you where boxers instead of briefs
08:02:05 <EvanR> wear*
08:02:13 <tdammers> and on top of OS X's graphical environment, you can run X11 applications, but it's an additional layer of indirection
08:02:33 <tdammers> the X11 api doesn't talk to the hardware directly, it goes through OS X's native GUI
08:02:53 <nschoe> tdammers: Okay, I begin to understand. (Could you name one or two more graphical environement aside from x!!? Just for me to make connections between what I "know" or "have heard of" please?)
08:03:08 <mcstar> weyland
08:03:10 <nschoe> tdammers: So basically, the whole X11, in OS X is just another common program?
08:03:20 <tdammers> kind of
08:03:21 <bartavelle> saying that x is a "graphical environment" is generous
08:03:31 <sipa> nschoe: X11 is "just another common program" on basically every system
08:03:39 <EvanR> nschoe: 'quartz'
08:03:47 <mcstar> ok, let me rephrase my question: what are 'free monads'?
08:04:08 <nschoe> sipa: Yeah, but a program that talk to the graphics card directly, no ? I mean, not every ordinary program can do that, can they?
08:04:09 <tdammers> bartavelle: OK then, X11 and whatever desktop environment you run on top of it
08:04:23 <EvanR> nschoe: yeah it can
08:04:23 <nschoe> EvanR: okay, thx
08:04:35 <EvanR> it goes through drivers
08:05:02 <tdammers> X11 on Linux/UNIX pretty much takes over the graphics card
08:05:16 <mcstar> what about direct rendering?
08:05:19 <nschoe> tdammers: but not in OS X, ok.
08:05:49 <geekosaur> non-X11 GUIs:  Wayland, Display PostScript (NeXT and an old Sun GUI), Display PDF (which is actually somewhere at the bottom of the OS X APIs)
08:06:04 <mcstar> framebuffer...
08:06:12 <Ke> Y windows
08:06:14 <EvanR> 'direct rendering'
08:06:16 <EvanR> heh
08:06:17 <sipa> if you run an X11 server on windows, it doesn't talk to the hardware directly either
08:06:17 <Ke> nitpicker
08:06:20 <mcstar> there are even tiling wms for fb
08:06:39 <nschoe> Okay, but on OS X, where does the SDL problem come from?
08:06:41 <EvanR> framebuffer is a thing of the past
08:06:50 <tomboy64> how can i clear the screen in ghci?
08:06:50 <mcstar> haha, it isnt
08:07:02 <EvanR> some handheld devices still have a real framebuffer
08:07:04 <mcstar> tomboy64: ^D
08:07:06 <tdammers> windows is probably a bad example
08:07:16 <parcs`> tomaw: ^L
08:07:17 <tomboy64> mcstar: that exits ghci :-/
08:07:20 <EvanR> mostly its emulated through modern insane pipelines
08:07:22 <tdammers> it kind of muddles kernel, userland, and GUI together into one clump
08:07:24 <tomboy64> ahh, thanks parcs`
08:07:30 <mcstar> tomboy64: im busted.... XD
08:07:36 <tomboy64> ^^
08:08:12 <nschoe> What's the difference between a framebuffer and a graphical environment?
08:08:39 <mcstar> nothing
08:08:40 <EvanR> nschoe: people in #sdl know a lot more about hardware and graphics software i think
08:09:14 <nschoe> Yeah but I'm a total noob: I don't see how I can walk in the room and as about such basic stuffs :/
08:09:19 <bartavelle> nschoe, X also handles inputs, and gives you all kind of primitives
08:10:06 <bartavelle> a framebuffer is just something you set pixels colors in
08:10:16 <EvanR> almost all video backends are integrated with input
08:10:32 <EvanR> unfortunately
08:10:59 <Ke> KMS doesn't provide any inputs!
08:11:02 <nschoe> bartavelle: thanks. So that means a framebuffer is like a graphical environment, only that it is much more limited: by only wrting in the graphical card's memory?
08:11:11 <geekosaur> nschoe, a framebuffer is a particular hardware implementation, designed for the main CPU to do graphics operations.  Modern systems have dedicated display devices with their own GPUs; their memory can be mapped for the main CPU to access, but generally not raw access to the display bits like a frbmebuffer does
08:11:35 <geekosaur> it's much lower level than graphical environments;
08:11:44 <EvanR> nschoe: you are grossly underequipped to understand graphics hardware these days. theres no actual framebuffer in the video card that you can write to
08:11:45 <sipa> i really wouldn't call X11 a graphical environment
08:11:51 <bartavelle> sipa, same
08:12:02 <EvanR> its almost too far gone and secretive to undertstand now
08:12:09 <geekosaur> ^^
08:12:10 <nschoe> geekosaur: okay, thanks for that! But if it is low-level, I suppose it is necessary. So why is it smth of an ancient time?
08:12:28 <tdammers> EvanR: there is a framebuffer, but you can't write to it directly
08:12:42 <nschoe> EvanR: Yeah... I feel lost, indeed. Any arficle/paper I can read to document on that?
08:12:49 <mcstar> search for 'linux graphics stack' in google images, youll have some diagrams
08:12:49 <tdammers> after all, the GPU has to keep the final pixel data *somewhere*
08:13:10 <geekosaur> at some very low level a framebuffer exists.  modern graphics systems keep it internally under control of the GPU, and you must communicate with the GPU to do things with it instead of simply blitting to it
08:13:15 <EvanR> nschoe: your best bet at this point would be the application notes that comes with sufficiently open graphics hardware
08:13:25 <EvanR> nschoe: which excludes nvidia, ati, etc
08:14:00 <nschoe> EvanR: ah ok. So.. basically it is impossible to learn. Yet you guys know a lot about all this. How can one "get in"?
08:14:18 <mcstar> wait.... isnt this OT?
08:14:32 <mcstar> by a large margin?
08:14:43 <tdammers> I'd say so
08:14:50 <geekosaur> yeh
08:15:25 <tdammers> there's always #haskell-blah...
08:15:34 <mcstar> so, if some folk has any idea, what people mean by 'free monads' and doesnt feel it necessarly to answere me in jest, then pls, answer me
08:16:58 <nschoe> mcstar: Ot = Ouf of Topic?
08:17:11 <sipa> off-topic
08:17:12 <mcstar> almost
08:17:41 <geekosaur> mcstar, http://www.haskell.org/haskellwiki/Free_structure (monads being one such structure)
08:17:59 <mcstar> geekosaur: thank you
08:18:23 <nschoe> Yeah, well sorry. I suppose it's my fault. But there was not many conversations going on here, so when I had a chance to get some intel, I could not resist. I did not feel like I was disturbing ongoing convs'. Sorry for that
08:18:51 <mcstar> nschoe: it wasnt directed at you
08:19:27 <EvanR> nschoe: ask somebody who knows about it, theres people in #sdl who know
08:20:14 <nschoe> Well, there are too much I ignore in this. I think I'll just ask them how can I make it work on OS X. And try to find intel/info of all that graphics stuff we talked about.
08:31:07 <mcstar> where is (*>) useful?
08:31:16 <mcstar> or when
08:31:36 <augur> edwardk: hey
08:31:41 <edwardk> heya
08:31:42 <S11001001> mcstar: you don't need the left result, but you need its action
08:32:01 <mcstar> S11001001: oh, its action
08:32:02 <edwardk> mcstar: foo = char '(' *> term <* char ')'
08:32:20 <edwardk> the arrows point right at what you want
08:32:23 <augur> edwardk: you know anything about wordnet?
08:32:27 <mcstar> edwardk: thats some parsing example right?
08:32:33 <edwardk> mcstar: yes
08:32:47 <edwardk> augur: i do, but i need to get to work
08:33:26 <augur> edwardk: ok. if at some point in the near future you could point me to some references on how to use it, i'd be grateful :)
08:33:56 <edwardk> kk
08:35:54 <ppilate> What does it mean for typed \-calculus to be decidable?
08:36:10 <ppilate> Does it mean that we always can get a normal form of a \-expression?
08:36:18 <augur> ppilate: it means that you can always type check in finite time
08:36:33 <augur> thats on the type side, anyway
08:36:46 <augur> on the term side, yes, it means all computations terminate
08:37:05 <ppilate> Ah, so you can always check when given syntactical typed lamda-expression is semantically well-typed, right?
08:37:27 <augur> yes, if what you mean by your question was about the types being decidable
08:37:54 <rwbarton> another way to say it is that you can decide equality of terms
08:38:39 <ppilate> Ah, I guess that's what they ment in this book, rwbarton
08:38:42 <ppilate> thanks rwbarton, augur
08:42:22 * hackagebot hslogger 1.2.0 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.2.0 (JohnGoerzen)
08:42:27 <parcs`> mcstar: if you're comparing it with >>, *> is useful because of its precedence
08:45:09 <mcstar> parcs`: also, i dont find a corresponding <<
08:45:36 <mcstar> probably, that doesnt make sense
08:46:19 <parcs`> yeah that too
08:49:35 <jfischoff> Is there a good resource for learning how to work with multi-parameter typeclasses? My current strategy of trial and error with functional deps seems less then optimal.
09:07:23 * hackagebot liblastfm 0.0.3.2 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.3.2 (MatveyAksenov)
09:23:58 <Philippa> has anyone here read through the SugarHaskell paper yet?
09:27:05 <sclv> yes
09:27:11 <sclv> skimmed, at least
09:32:24 * hackagebot liblastfm 0.0.3.3 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.3.3 (MatveyAksenov)
09:33:15 <silver> what's that?
09:33:28 <silver> user defined syntax?
09:34:23 <silver> woah
09:37:35 <ion> Ooh, that looks nice.
09:38:04 <ion> I’d love banana brackets for Applicative and an Erlang-inspired bit string syntax.
09:38:24 <ion> (without an external preprocessor)
09:44:13 <Lajjla> Philippa, are you like Prince Philip, Duke of Edinburg?
09:44:55 <bryanvick> Newbie here: is this a proper place to ask for criticism of one of my first Haskell functions?  Semantics/readability etc?
09:45:01 <Philippa> I'd like to think I'm slightly less of an arsehole than he is
09:45:09 <zomg> bryanvick: sure
09:45:52 <Philippa> sclv: oops, got distracted a little. Did you pick up what kind of syntactic model they're working with? I had a toy project in the same ballpark and I should probably figure out if it's worth a few more nights' hacking but digesting the paper adequately has a similar cost
09:46:05 <Philippa> (I saw they've got tooling, which is cool)
09:48:31 * roconnor wonders if it is possible to have a compiler that complies polymorphic parameters to universal elements.
09:49:37 <hpaste> bryanvick pasted “First haskell function” at http://hpaste.org/71002
09:51:12 <Philippa> roconnor: which reminds me it's been a long time since I saw franka around
09:52:19 <bryanvick> re: http://hpaste.org/71002  It seems like long guard conditions plus medium sized definition bodies will result in a whole bunch of wrapping.  Is that the norm in Haskell?  Are there wrapping conventions?
09:54:31 <roconnor> bryanvick: You can put long guard conditions in to a where clause
09:55:24 <monochrom> our wrapping convention is "know the layout rules" and then "go with your heart"
10:00:01 <Philippa> *nod*
10:00:17 <Philippa> you also have some flexibility with where you place separators
10:00:30 <hpaste> bryanvick pasted “Long guard condition example” at http://hpaste.org/71003
10:00:41 <Philippa> (I try to stick within 80 columns still because one of these days I may be stuck coding on a netbook, so I play with layout a fair amount)
10:01:41 <mcstar> i find including the typing with those restrictions a bit distracting
10:02:05 <mcstar> the compiler will infer whatever it wants, and the unrestricted type of the function is too simple to cause problems
10:02:17 <bryanvick> rconnor: re: http://hpaste.org/71003  Stupid example, but am I understanding what you said?
10:02:57 <mcstar> longGuard == True is equivalent to longGuard
10:03:51 <mcstar> also, im not convinced about the usefulness of many error massages, furthermore, those which depend on variables
10:04:02 <roconnor> what mcstar said about longGuard
10:04:12 <Philippa> bryanvick: give or take the name of longGuard, that looks like excellent style to me
10:04:44 <Philippa> mcstar: sometimes that's essentially a problem domain/spec thing
10:04:49 <bryanvick> mcstar: Thanks for the input.  That's how I would have done it, coming from Python, but Learn you a Haskell has got me writing type definitions for all functions.
10:04:49 <roconnor> bryanvick: I personly indent my "where" by one space, and then start a new line indenting with 2 spaces.
10:04:54 <Philippa> heck, some tasks are as much about error reporting
10:05:24 <Philippa> I often line up my definitions after the keyword that starts the block unless I'm short on columns, but it's all a matter of taste
10:05:30 <Philippa> (I'll happily do like roconnor)
10:06:37 <mcstar> i think emacs places 'where' aligned with the guard |
10:07:12 <roconnor> bryanvick: you can, at you choice, write a long conjuction as (and [5 >= 6, 4 < 3, 3 > 10])
10:07:21 <roconnor> > and [5 >= 6, 4 < 3, 3 > 10]
10:07:22 <lambdabot>   False
10:07:31 <mcstar> also, && binds tighter than ||
10:09:35 <bryanvick> roconnor: Ah I like that, and as a function.  I have a crush on s-expr syntax right now.
10:10:06 <bryanvick>  Trying to learn fuctional prg.  So far toyed w/ Clojure and CL, Haskell is my current squeeze
10:10:39 <roconnor> > getAll . mconcat . map All $[5 >= 6, 4 < 3, 3 > 10]
10:10:42 <lambdabot>   False
10:11:40 <roconnor> did connor's ily function get packaged?
10:12:18 <roconnor> he'd write something like Might `ily` crush $ [5 >= 6, 4 < 3, 3 > 10]
10:21:10 <aristid> preflex: seen Peaker
10:21:10 <preflex>  Peaker was last seen on #haskell 21 hours, 47 minutes and 41 seconds ago, saying: it should be: ?topic (nth 6) tail
10:27:26 * hackagebot Vec 1.0 - Fixed-length lists and low-dimensional linear algebra.  http://hackage.haskell.org/package/Vec-1.0 (ScottDillard)
10:28:51 <MagneticDuck> hey, I'm having trouble with the syntax for the pl version of, say, (\f -> f x y)
10:29:03 <MagneticDuck> Why doesn't ($ x $ y) work?
10:29:20 <MagneticDuck> @type ($ 1 $ 2)
10:29:22 <lambdabot> forall b b1. (Num b1) => (b1 -> b) -> b
10:29:23 <roconnor> MagneticDuck: it is a little sad
10:29:26 <MagneticDuck> yeah, it should work
10:29:29 <mauke> because that's either a syntax error or equivalent to ($ x y)
10:29:33 <MagneticDuck> okay
10:29:55 <tomboy64> how do i have a function return nothing?
10:29:58 <mm|swarm> @pl \f -> f x y
10:29:58 <lambdabot> flip ($ x) y
10:30:00 <mauke> tomboy64: no
10:30:00 <MagneticDuck> it's like writing foldl $ (+) $ list $ 0
10:30:06 <MagneticDuck> tomboy: undefined
10:30:13 <MagneticDuck> @type undefined
10:30:14 <lambdabot> forall a. a
10:30:15 <tomboy64> thx
10:30:17 <MagneticDuck> >:}
10:30:31 <MagneticDuck> an evil little value, undefined is
10:31:46 <mroman> undefined is like Medusa.
10:31:51 <mroman> Just don't look at her.
10:31:54 <MagneticDuck> > map ($ 1 2) [(+), (*), (/), (-)]
10:31:56 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:31:56 <lambdabot>    arising from a use of `...
10:32:06 <MagneticDuck> ..huh?
10:32:14 <MagneticDuck> > map ($ 1 2) [(+), (*), (/), (-)] :: Real
10:32:16 <lambdabot>   Class `GHC.Real.Real' used as a type
10:32:20 <MagneticDuck> jkdsljf
10:32:22 <roconnor> http://www.haskellers.com/jobs/14
10:32:24 <mcstar> cant show functions
10:32:27 * hackagebot lens-family-core 0.0.0 - Haskell 98 Lens Families  http://hackage.haskell.org/package/lens-family-core-0.0.0 (RussellOConnor)
10:32:29 * hackagebot lens-family 0.0.0 - Lens Families  http://hackage.haskell.org/package/lens-family-0.0.0 (RussellOConnor)
10:32:59 <MagneticDuck> > ($ 1 2) (+)
10:33:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:33:01 <lambdabot>    arising from a use of `...
10:33:05 <MagneticDuck> ...
10:33:09 <mauke> you still can't show functions
10:33:09 <MagneticDuck> > 1 + 2
10:33:11 <lambdabot>   3
10:33:20 <MagneticDuck> > (+) $ 1 2
10:33:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:33:22 <lambdabot>    arising from a use of `...
10:33:28 <MagneticDuck> > (+) 1 2
10:33:30 <lambdabot>   3
10:33:31 <MagneticDuck> -_-
10:33:42 <fmap> :t ($ 1 2)
10:33:44 <lambdabot> forall a b. (Num a) => (a -> b) -> b
10:33:45 <mauke> > (+) (1 2)
10:33:46 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:33:46 <lambdabot>    arising from a use of `...
10:33:52 <mauke> > (+) (1 2) 10
10:33:53 <lambdabot>   11
10:33:54 <mroman> > ((+) $ 1) $ 2
10:33:55 <lambdabot>   3
10:33:58 <mauke> > 1 2
10:33:59 <lambdabot>   1
10:34:10 <MagneticDuck> ??
10:34:13 <MagneticDuck> > 1 2
10:34:14 <mroman> (+) $ 1 2 is
10:34:14 <lambdabot>   1
10:34:17 <MagneticDuck> how does that even work
10:34:21 <mroman> ((+) $ (1 2)
10:34:27 <MagneticDuck> I'm a tad confused
10:34:34 <mroman> 1 is not a function.
10:34:37 <MagneticDuck> sigh
10:34:46 <mauke> 1 is a function
10:34:47 <MagneticDuck> (+) $ 1 $ 1
10:34:51 <roconnor> > 1 5
10:34:53 <lambdabot>   1
10:34:57 <mauke> it's as easy as ...
10:34:58 <mauke> > 1 2 3
10:34:59 <lambdabot>   1
10:35:04 <MagneticDuck> lambdabot seems to think 1 IS  function
10:35:11 <MagneticDuck> s//a
10:35:11 <roconnor> > 1 "CALE!!!!"
10:35:13 <lambdabot>   1
10:35:14 <mroman> mauke: I thought so too.
10:35:15 <dschoepe> functions can be made an instance of Num, so 1 can be seen as function
10:35:16 <MagneticDuck> lol
10:35:20 <MagneticDuck> you've called the cale
10:35:22 <mroman> Until lately I got beat up here for saying exactly that.
10:35:28 <Catnaroek> What did people do to 1?
10:35:36 <mroman> > 2 foobar
10:35:38 <lambdabot>   Not in scope: `foobar'
10:35:40 <Catnaroek> People made some additional instance of Num or what?
10:35:41 <mroman> > 1 foobar
10:35:42 <MagneticDuck> okay
10:35:42 <lambdabot>   Not in scope: `foobar'
10:35:45 <MagneticDuck> waitwaitwaitwait
10:35:48 <roconnor> Catnaroek: made it the unit for the ring of functions.
10:35:50 <MagneticDuck> great
10:35:55 <MagneticDuck> that's specific to lambdabot right?
10:36:01 <mauke> MagneticDuck: no
10:36:01 <Catnaroek> Oh.
10:36:07 <mauke> it's a module on hackage
10:36:13 <MagneticDuck> :O
10:36:19 <MagneticDuck> what's it called?
10:36:20 <mroman> it's probably an instance Num (a -> b)
10:36:28 <mauke> MagneticDuck: NumInstances IIRC
10:36:34 <Catnaroek> > 2 "a"
10:36:35 <lambdabot>   2
10:36:45 <MagneticDuck> "newbieMixeruper"
10:36:53 <MagneticDuck> listen, I get that
10:36:58 <MagneticDuck> @type 2
10:37:00 <lambdabot> forall t. (Num t) => t
10:37:05 <mauke> > deriv (2 * sin) x
10:37:06 <lambdabot>   2 * (1 * cos x)
10:37:12 <Catnaroek> Wow, amazing.
10:37:13 <MagneticDuck> > 2 $ 1
10:37:15 <lambdabot>   2
10:37:19 <Catnaroek> 2 $ 5
10:37:20 <MagneticDuck> > (2 :: Int) $ 1
10:37:21 <Catnaroek> > 2 $ 5
10:37:22 <lambdabot>   Couldn't match expected type `a -> b'
10:37:22 <lambdabot>         against inferred type `GHC.Ty...
10:37:23 <lambdabot>   2
10:37:25 <MagneticDuck> -_-
10:37:35 <Catnaroek> > 2 . 5
10:37:36 <lambdabot>   No instance for (GHC.Show.Show (f b))
10:37:36 <lambdabot>    arising from a use of `M1592415417...
10:37:40 <MagneticDuck> I hate you, you, NumInstances IIRC
10:37:50 <rwbarton> IMRC
10:37:54 <mroman> How does that work?
10:37:55 <mroman> > 4 5
10:37:57 <lambdabot>   4
10:38:00 <MagneticDuck> lol guys
10:38:18 <MagneticDuck> we've been sitting around typing stuff like "1 2" all day now
10:38:26 <MagneticDuck> just to see if other people weren't cheating
10:38:28 <MagneticDuck> :D
10:38:29 * Catnaroek understands not, what going on is.
10:38:35 <MagneticDuck> me neither
10:38:39 <MagneticDuck> I'm all mixed up
10:38:44 <ion> instance Num (a -> a) where fromIntegral = const
10:38:47 <roconnor> Catnaroek: given a ring R, the functions A -> R form a ring.
10:38:53 <mauke> Catnaroek: instance (Num a) => Num (e -> a)
10:38:59 <mauke> that is all
10:39:00 <mroman> ion: Thanks.
10:39:10 <Catnaroek> roconnor: Sorry, what were the axioms for a ring?
10:39:38 <MagneticDuck> aaarrrggh
10:39:41 <MagneticDuck> all I wanted to know
10:39:41 <roconnor> Catnaroek: an abelian group and a monoid and distribution
10:40:07 <MagneticDuck> is why ($ 1 $ 2) doesn't work as a (Int -> Int -> Int) -> Int
10:40:09 <Catnaroek> Abelian addition, monoid multiplication, and distribution of multiplication over addition, right?
10:40:17 <roconnor> Catnaroek: yes
10:40:20 <mauke> MagneticDuck: because 1 $ 2 is either an error or 1
10:40:39 <Catnaroek> With the abelian identity being sortof a null element for the monoid?
10:40:42 <Catnaroek> Or that is not required?
10:40:44 <mauke> MagneticDuck: and the $ is misleading because what you wrote is ($ (1 2))
10:41:01 <roconnor> MagneticDuck: for some reason you cannot build sections with other operators in it.
10:41:09 <MagneticDuck> >_o
10:41:10 <Catnaroek> (I mean, as in 0 * anything = 0, because 0 is the Abelian identity of +.)
10:41:10 <MagneticDuck> okay
10:41:16 <mauke> roconnor: yes, you can
10:41:18 <mcstar> > map (($ 2) . ($3)) [(+), (*), (/), (-)]
10:41:20 <lambdabot>   [5.0,6.0,1.5,1.0]
10:41:22 <mcstar> MagneticDuck: ^^
10:41:27 <roconnor> ... that was poorly worded
10:41:27 <MagneticDuck> so I have to say something like "flip ($ 1) 2"?
10:41:34 <b0fh_ua> Hi all! With SQLite it returns me UTF8 strings from database, but I want them as ByteStrings. How do I convert UTf8 string to ByteString?
10:42:02 <mauke> b0fh_ua: what's a UTF8 string?
10:42:14 <rwbarton> @type flip ($ 1) 2
10:42:14 <MagneticDuck> ah
10:42:16 <lambdabot> forall a b a1. (Num a1, Num a) => (a1 -> a -> b) -> b
10:42:22 <MagneticDuck> (($ a) . ($ b))
10:42:30 <MagneticDuck> dat $ operator
10:43:05 <rwbarton> at some point a simple (\f -> f 1 2) seems preferable
10:43:36 <b0fh_ua> mauke: String
10:43:45 <b0fh_ua> I believe that it is unicode somehow
10:43:50 <mcstar> rwbarton: i didnt mean to encourage that style
10:43:57 <mcstar> for that im eternally sorry
10:44:17 <rwbarton> (($ 2) . ($ 3)) isn't that bad
10:44:24 <rwbarton> certainly much better than flip ($ 1) 2
10:44:33 <mauke> b0fh_ua: yes, String is unicode. and not UTF-8
10:44:49 <mroman> @pl (\f -> 1 `f` 2)
10:44:49 <lambdabot> flip ($ 1) 2
10:45:30 <MagneticDuck> the only thing with the (($ a) . ($ b)) style is that (($ a) . ($ b)) == (\f -> f b a)
10:45:31 <MagneticDuck> :/
10:45:35 <MagneticDuck> can mix people up
10:45:37 <rwbarton> yes
10:46:03 <MagneticDuck> and the problem with (\f -> f a b)
10:46:10 <MagneticDuck> is that it's too easy for newbies to understand
10:46:11 <MagneticDuck> :/
10:46:24 <MagneticDuck> or at least that's how some people I know think
10:46:47 <b0fh_ua> mauke: what is the best way to convert String into ByteString?
10:47:16 <mauke> b0fh_ua: no
10:47:31 <mauke> b0fh_ua: why do you want bytestrings?
10:48:00 <mcstar> @pl \a b -> (($ a) . ($ b)) f
10:48:00 <lambdabot> flip flip f . flip (flip . flip id)
10:48:17 <b0fh_ua> mauke: in general I want to have some sort of binary data and not worry about encoding. E.g if the data is in unicode format - okay, store it as unicode in file, if it is latin1 or some another encoding - then store it as is.
10:48:34 <b0fh_ua> trying to make my app encoding-agnostic :)
10:48:51 <mcstar> > zipWith3 (flip flip f . flip (flip . flip id)) [1..] [10..] [(+), (*), (/), (-)]
10:48:52 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
10:48:52 <lambdabot>    arising from a use...
10:48:59 <roconnor> Catnaroek: 0 = 0 * a - 0 * a  = (0 + 0) * a - 0 * a = 0 * a + 0 * a - 0 * a = 0 * a
10:49:02 <roconnor> Catnaroek: therefore 0 = 0 * a
10:49:09 <newsham> the bytestring package has pack and unpack functions
10:49:17 <newsham> ?type BS.pack
10:49:18 <lambdabot> [Word8] -> BSC.ByteString
10:49:19 <mcstar> @pl \a b f -> (($ a) . ($ b)) f
10:49:19 <lambdabot> flip (flip . flip id)
10:49:32 <mauke> b0fh_ua: unicode is not an encoding
10:49:56 <mcstar> > zipWith3 (flip (flip . flip id)) [1..] [10..] [(+), (*), (/), (-)]
10:49:56 <mauke> b0fh_ua: if you have arbitary binary data, why not use a blob?
10:49:58 <lambdabot>   [11.0,22.0,4.0,9.0]
10:50:03 <newsham> but probably what you want is to not read a String in the first place, and read it directly as a bytestring
10:50:30 <roconnor> Catnaroek: I had to look up that proof at : http://en.wikipedia.org/wiki/Proofs_of_elementary_ring_properties
10:51:11 <rwbarton> morally the axiom 0 * x = 0 is parallel to (a + b) * x = a * x + b * x and might as well be included anyways
10:51:29 <roconnor> this is true
10:52:11 <Catnaroek> :O
10:52:12 <rwbarton> (or you can make the axiom (a_1 + ... + a_n) * x = a_1 * x + ... + a_n * x for any n >= 0)
10:52:57 <newsham> ?type BSC.pack
10:52:58 <lambdabot> String -> BSC.ByteString
10:55:36 <mcstar> "Ability to write JavaScript code" <- that pretty much rules me out
10:57:35 <b0fh_ua> mauke: well, SQLite returns String, so I need to deal with it somehow
10:57:51 <mauke> b0fh_ua: not for blobs
10:58:19 <b0fh_ua> mauke: sorry, but if result set contains Strings - how can I convert them to blob?
10:58:25 <mauke> wat
10:58:38 <mauke> you're doing this backwards
10:58:55 <mauke> if your database already contains strings, you're done. String is encoding-agnostic.
10:59:03 <b0fh_ua> mauke: in result there is the field named "text_something" and it's content is String. I need to get just set of bytes from the string.
10:59:16 <mauke> Strings don't consist of bytes
11:00:51 <b0fh_ua> weird
11:08:55 <mcstar> wait, and clouds arent made of cotton candy? :)
11:12:10 <clsmith> hey all. not a haskell question, but it seems like something you guys might know. ;p i'm reading about lambda in terms of rewrite systems, and it says application is of arity '00', and abstraction '1'. i've seen this kind of notation before, but it hasn't made much sense. does the 0 or 1 mean the number of variables bound, and the number of digits the number of args?
11:13:21 <joeyh> c
11:13:26 <joeyh> pardon
11:14:27 <mpwd> clsmith: Can you give a source?
11:15:18 <clsmith> mpwd: hmm, it's in a book
11:15:26 <mpwd> title?
11:15:45 <clsmith> "the optimal implementation of functional programming languages" :p
11:16:53 <clsmith> ah, found a paper which uses it on the web
11:17:41 <mpwd> Okay, I don't think this is a pure lambda calculus question.  There's no notion of arity at all in the old fashioned Church style system.
11:17:57 <clsmith> no, i think it's particularly about the rewriting
11:18:35 <mpwd> (Basic) Lambda calculus is all aboutt rewriting, until you get up into Scott models
11:20:01 <clsmith> well, i meant in terms of, say, second-order term rewriting systems
11:20:39 <clsmith> but googling pulls up an awful lot of the author's works, so maybe it's just him :p
11:21:58 <mpwd> Researchers make up notions all the time.  Do you have a page number of this book where you are confused?
11:22:12 <mpwd> (googling around, I found a full copy online)
11:23:08 <clsmith> ah, one sec
11:25:18 <clsmith> one case is on p343, "arity 1 and 01"
11:25:58 <clsmith> and 332, "arity 00", "arity 1"
11:26:27 <kaka> hello
11:26:48 <kaka> haskell sucks
11:27:03 <mauke> kaka: can we help you?
11:27:15 --- mode: ChanServ set +o mauke
11:27:29 <mauke> o_O
11:28:09 <mcstar> the number means the number of bound variables
11:28:17 <mcstar> in that argument position
11:28:30 * clsmith nods
11:28:40 <mcstar> just read the introduction of the chapter
11:28:44 <mcstar> 11.1
11:28:55 <clsmith> oh, they tell you? i should stop skimming ^^;
11:28:56 <mpwd> mcstar: Beet me to it
11:28:58 <clsmith> thanks :)
11:31:19 <ben12> I'm curious if anyone has examples of using the LLVM bindings for code generation.  The only one I've found so far requires using GADTs and a good deal of machinery to get the types of the language being compiled reflected in Haskell.  It seems like more effort than I want (at the moment) since I'm just playing around.  On the other hand, I've looked at the FFI bindings in llvm-base and thoes seem painful too...
11:31:21 <mcstar> smug lispers ^^
11:36:51 <jfischoff> ben12: maybe this http://augustss.blogspot.com/2009/06/more-llvm-recently-someone-asked-me-on.html
11:42:17 <ben12> jfischoff: Hmm, that was the one I was looking at that used the GADTs to create a type-safe AST.  Guess I'll just have to go that route.  Thanks for looking!
11:42:25 <MagneticDuck> yo, I have a 247 lined completely pure source file
11:42:30 <MagneticDuck> I'm a newbie
11:42:36 <MagneticDuck> would anyone be willing to critique it?
11:42:46 <MagneticDuck> I put in lots of comments
11:42:49 <MagneticDuck> explaining everything
11:43:05 <MagneticDuck> it's a sentence parser
11:43:18 <jfischoff> ben12: oh sorry about that. I didn't see a GADT at the beginning. That being said GADTs aren't that bad
11:43:24 <MagneticDuck> I use it for my irc bot
11:43:38 <MagneticDuck> so it can understand some english more or less
11:44:00 <MagneticDuck> anyone?
11:44:14 <mroman> Paste it on hpaste?
11:44:21 <mroman> And if people want to look at it, they will.
11:44:37 <MagneticDuck> it's 247 lines
11:44:41 <MagneticDuck> but okay
11:44:50 <mroman> hpaste has no problem with 247 lines.
11:44:55 <MagneticDuck> okay
11:44:56 <mroman> http://hpaste.org that is.
11:44:57 <tippenein> Why don't you just get a github and post a link to that
11:45:21 <tippenein> if you're worried about loc
11:45:29 <ben12> jfischoff: Yeah, I scanned it and it didn't look too bad.  I guess I was just trying to jump past type checking (for now)... but its probably better to not skip that step.
11:46:12 <jfischoff> ben12: there are other examples on the blog that use LLVM in simpler ways, which might be applicable
11:46:19 <hpaste> MagneticDuck pasted “RoboDuck.Sentence” at http://hpaste.org/71009
11:46:24 <MagneticDuck> done
11:46:49 <MagneticDuck> okay then, pm me if you have any comments
11:47:04 <MagneticDuck> going afk
11:48:51 <mroman> hlint already has suggestions :)
11:48:55 <ben12> jfischoff: Most of the other examples show creating code for specific functions (eg, Fib) that can use essentially hard-coded types in the Haskell embedding.  The difficulty comes when trying to handle generalized types... if you have multiple cases in a pattern match (eg, String and Integer constants), it started running into problems, which is (I'm guessing) where having the GADT typed stuff would help...  other than that article, do
11:48:56 <ben12> you have any suggestions for articles/tutorials to learn GADTs from?
11:49:18 <tertl6> dear HAskell, I leksah you
11:51:06 <jfischoff> ben12:http://vimeo.com/12208838
11:52:40 <ben12> jfischoff: Cool, thanks!
11:53:19 <jfischoff> ben12: that's the simplest intro I have seen. I'll try to think of any more that aren't on the haskell.org wiki
11:59:02 <MagneticDuckling> Anyone with any comments on my code, please private message me
11:59:09 <mcstar> anyone reading MagneticDuck 's paste, couldnt that be done more elegantly with some regexp-fu? it seems a bit involved, and i suspect a lot of duplication of effert(low reuse of existing solutions)
11:59:10 <MagneticDuckling> Not the other account
11:59:25 <MagneticDuckling> Ah
11:59:43 <MagneticDuckling> Well I'm still learning Haskell
11:59:47 <mcstar> (unfortunately i dont know anything about regexp or parsing or text manipulation, so just asking)
12:00:06 <MagneticDuckling> And I wanted to do as much work as possible
12:00:10 <MagneticDuckling> ;P
12:00:27 <mcstar> MagneticDuckling: in that regard, you possibly succeeded :)
12:01:00 <MagneticDuckling> But what do you think of the style?
12:01:26 <mcstar> the layout is sometimes bad
12:01:36 <mcstar> let
12:01:39 <mcstar> isTagged phrase =
12:01:41 <mcstar> erm
12:01:46 <mcstar>                 isTagged phrase =
12:01:55 <mcstar> so this looks horrible, sry
12:02:00 <Taneb> The number of comments is a lot better than my code :)
12:02:06 <dmwit> MagneticDuckling: Have you tried writing down a grammar for your language?
12:02:28 <dmwit> It seems like you're doing rather a lot of ad-hoc String munging.
12:02:34 <MagneticDuckling> What do you mean
12:02:59 <MagneticDuckling> By the way yes LOL I made those comments for you guys
12:03:35 <dmwit> I mean, is the language you're parsing context-free? Have you tried getting some EBNF down on paper?
12:04:06 <MagneticDuckling> Ebnf?
12:04:25 <dmwit> That's just one handy way of specifying a context-free grammar. But any that you're familiar with is fine.
12:04:40 <copumpkin> nominolo: you around?
12:04:47 <dmwit> Or a non-context-free grammar, if you prefer. I'm just asking whether you've tried to specify the language before you started hacking a parser together.
12:05:08 <MagneticDuckling> All I'm trying to do there is parse a sentence
12:05:17 <dmwit> Doing so is usually a pretty good exercise. It will make extensions (like predicates that you mentioned at the end) easier to handle, too.
12:05:38 <MagneticDuckling>  no I didn't really
12:05:49 <dmwit> Well, it shows. =)
12:05:50 <MagneticDuckling> Hmm
12:06:49 <tippenein> after installing hlint with cabal successfully is there a reason I can't use it from the cmdline?
12:06:51 <mcstar> --a utility function BECAUSE I COULDN'T FIND IT ANYWHERE. >:|
12:06:58 <MagneticDuckling> LOL yes
12:07:05 <MagneticDuckling> I couldn't!
12:07:16 <MagneticDuckling> x-(
12:07:23 <mcstar> well, lists are supposed to be handles revursively, not like arrays
12:07:41 <mcstar> hanfled*
12:07:43 <ben12> EBNF is a mechanism for expressing your grammar -- the structure of what you're parsing -- by explicitly stating how different constructs fit together.  that specification is often useful as documentation for all the parsing code, and as a way to structure that code.  Also, there are many tools that exist for creating/expressing those grammers very succinctly (eg, Parsec, Happy, etc.)
12:08:01 <c_wraith> tippenein: how is it unuseable?  Is it not in your path?
12:09:24 <timthelion> Is it possible to do curried programming in C?  I'm trying to implement morseKeyOnOrOff:: Char -> Int ; morseKeyOnOrOff char time = blah ; --and later on-- onOrOff=morseKeyOnOrOff 'a', such that onOrOff becomes a function of time...
12:09:38 <tippenein> well, it must not be since 'command not found' but I would think the install would do that.
12:09:51 <MagneticDuckling> By the way my goal wasn't to write it fast, it was to write it learning Haskell
12:09:52 <timthelion> I presume the only way to do this is to have a struct that I return from morseKeyOnOrOff and then pass to another function?
12:10:48 <tomboy64> how do i conditionally print out a debug statement in a loop, without affecting the rest of the program?
12:11:02 * timthelion and they said learning haskell would make me a *better* C coder :(
12:11:16 <tomboy64> something like if x `mod` 10000 == 0 then print x else do nothing
12:11:40 <mcstar> tomboy64: if you are in IO you can do that
12:11:55 <timthelion> mcstar: he can debug with unsafePreformIO as well :)
12:12:05 <mcstar> well, i suppose
12:12:13 <tomboy64> well, i have Debug.trace imported
12:12:24 <timthelion> tomboy64: try a case statment where case x 'mod' 10000 of 0 -> show x ; _ -> ""
12:12:33 <tomboy64> but trace (my if clause) (my loop) doesn't work :(
12:12:51 <timthelion> tomboy64: and then trace that string, or print that string or whatever.
12:13:20 <mcstar> tomboy64: you could give Trace a conditional string
12:13:21 <Taneb> Are mutually recursive modules Bad(tm)?
12:13:21 <tomboy64> hmm
12:13:32 <tomboy64> mcstar: i tried to do exactly that.
12:13:37 <tomboy64> wait, imma paste my prog
12:13:46 <timthelion> Taneb: no their great, but haskell doesn't support them :(
12:14:22 <MagneticDuckling> Has anyone found any problems with my algorithm?
12:14:26 <timthelion> s/their/ they're
12:14:34 <tomboy64> http://bpaste.net/show/33722/
12:14:36 <favonia384> timthelion: it's GHC that doesn't (fully) support them
12:14:49 <nule> tippenein, i looked at my ~/.cabal/config for "bin" then found hlint where the bin dir was
12:15:04 <nule> (cont.) in my case ~/Library/Haskell/bin
12:15:13 <Taneb> timthelion, awww
12:15:26 <tippenein> nule: thanks. then you put it in /usr/bin ?
12:15:27 <MagneticDuckling> By the way keep in mind that this is, my first real program
12:15:53 <timthelion> tomboy64: what doesn't work there?
12:15:58 <nule> tippenein: i just added an alias to my .bash_rc
12:15:59 <MagneticDuckling> Would appreciate help
12:16:09 <nule> i try not to mess with system dirs
12:16:12 <mcstar> tomboy64: not the most idiomatic use of Trace
12:16:15 <tomboy64> problem_008.hs:18:7: parse error on input `if'
12:16:39 <mcstar> checkSize :: Integer -> Bool
12:16:41 <mcstar>       if someNumber > aThousandDigits
12:16:49 <mcstar> you give the body after a type annotation
12:16:55 <mcstar> thats a no-no
12:16:56 <tomboy64> ugh
12:17:07 <tomboy64> i think i deleted a line :(
12:17:09 <tomboy64> :$
12:18:09 <mcstar> the 'if' in checkSize is totally unnecessary
12:19:10 <favonia384> Taneb: the Haskell stardard allows it, but it's not fully supported; for GHC you can check this: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
12:21:13 <EvanR> ruby has sort of the Maybe data structure and associated tools because of the nil 'value', anyone know if theres a library for something like Either?
12:21:16 <dmwit> timthelion: eh? Haskell supports them just fine
12:21:21 <Taneb> favonia384, thanks for the link
12:21:27 <dmwit> Taneb: They're not bad. They're quite useful for what they're good for.
12:21:51 <dmwit> Why are people saying they're not supported? GHC supports them just fine.
12:22:34 <favonia384> Taneb: I found this page more informative: http://www.haskell.org/haskellwiki/Mutually_recursive_modules :)
12:22:39 <dmwit> timthelion: You can return function pointers in C. But it's a bit hard and annoying.
12:22:52 <timthelion> dmwit: that's just plain not true.  If I have file/module A.lhs with import B and B.lhs with import A it giives me an error.
12:22:59 <dmwit> timthelion: Better to just implement a scheme in your C and use that for currying instead. =)
12:23:03 <tomboy64> -.-
12:23:05 <dmwit> timthelion: That means nothing.
12:23:11 <Cale> You can return function pointers in C, but it's not the same as returning functions
12:23:11 <byorgey> timthelion: you have to create a boot file.
12:23:14 <shachaf> Returning function pointers is hard?
12:23:15 <Taneb> Right, they're not what I want.
12:23:18 <dmwit> timthelion: You just need to add a .hs-boot file.
12:23:20 <Taneb> Thanks, everyone
12:23:25 <tomboy64> how do i make Debug.Trace.trace not print a \n with a ""? ^^
12:23:27 <shachaf> The annoying part is the data, not the function. :-)
12:23:31 <shachaf> Or, rather, the combination.
12:23:40 <timthelion> dmwit: ;) I was hoping there was some magic bit that I didn't know about.
12:23:47 <favonia384> dmwit: well I don't count that as full support w.r.t. the stardard.
12:23:55 <Cale> Functions carry with them the values of all the variables in their body
12:24:03 <favonia384> timthelion: there are implementations that do tha magic...
12:24:35 <timthelion> favonia384: implementations of C or libraries for C?
12:24:36 <dmwit> shachaf: I meant currying by returning function pointers is a bit hard and annoying, not that the actual return statement was hard and annoying.
12:24:43 <Cale> I suppose in C you could construct appropriate machine code and return a pointer to it, but that's certainly not first-class or easy.
12:24:57 <favonia384> timthelion: oh I meant mutually recursive modules
12:24:57 <shachaf> Cale: Nor valid C. :-)
12:25:16 <timthelion> favonia384: heh :D two conversations at once.
12:25:39 <timthelion> Cale: any way to do that and make it platform independent?
12:25:44 <Cale> timthelion: closures
12:25:54 <Cale> Implementing closures by hand
12:26:28 <dmwit> Right. Implement a scheme and use that. =)
12:26:29 <timthelion> Perhaps I should just find a purely functional language that compiles to C.   Haskell used to do that eh :D
12:26:38 <Cale> which is honestly nicer than the solution I proposed :P
12:26:40 <c_wraith> jhc compiles to C
12:26:59 <c_wraith> and produces pretty good code.  It just supports way fewer extensions than ghc
12:27:06 <dmwit> Is there a reason there needs to be C code in the pipeline?
12:27:15 <Taneb> timthelion, GHC can compile to C if you compile it with a specific option
12:27:18 <mauke> does jhc collect garbage?
12:27:21 <timthelion> dmwit: it's a module of a driver written in C?
12:27:22 <geekosaur> ghc still compiles to C, just produces lousy code
12:27:34 <dmwit> Taneb: I thought that feature disappeared from modern GHCs.
12:27:39 <c_wraith> I'm pretty sure ghc doesn't support producing C anymore
12:27:39 <dmwit> geekosaur: really?
12:27:47 <mcstar> tomboy64: you can make the execution of the whole trace conditional
12:27:52 <nand`> Cale: I see the distinction differently. Returning a function pointer is, for all intents and purposes, the same as returning that function: the difference being that in, say, Haskell; you can construct *new* functions, whereas in C you can only return existing ones (which is exactly what closures give you - the ability to construct new, distinct functions instead)
12:27:54 <geekosaur> there were 2 C-producing paths, registerized and unregisterized
12:27:58 <tomboy64> yeah
12:28:06 <geekosaur> the former is dead.  the latter is still necessary for bootstrapping a new platform
12:28:12 <c_wraith> ah
12:28:13 <tomboy64> that's what i did, introducing another auxiliary function :x
12:28:23 <geekosaur> it produces really bad code, because it's only intended for initial bootstrapping
12:28:25 <Cale> nand`: I guess. It's very different in any case.
12:28:36 <dmwit> geekosaur++ for trouncing us all
12:29:01 <dmwit> Except Taneb, I guess. So Taneb++ too
12:29:09 <nand`> (this is also the distinction I'd use to define first class functions: being able to manipulate functions like any other data type - not just return them)
12:29:10 <Taneb> :)
12:29:25 <Cale> I wonder if you could bootstrap via LLVM
12:29:39 <mcstar> tomboy64: nick me, or i might lose the thread
12:29:53 <Taneb> I knew reading about a quarter of the GHC docs would come in handy one day
12:30:03 <tomboy64> mcstar: that's what i did, introducing another auxiliary function :)
12:30:03 <mcstar> tomboy64: new paste?
12:30:09 <tomboy64> sure, sec
12:30:23 <nand`> Taneb: what about the other three?
12:30:41 <Taneb> I dunno, never came in handy
12:30:55 <Taneb> FFI is in there, and I need to learn that some day
12:31:24 <nand`> Does GHC still use C-- as intermediate language? Can't you get a C-- representation of GHC itself and use existing C-- compilers on it? (I don't know an awful lot about how C-- works)
12:31:37 <geekosaur> it uses cmm, which IIRC is not *quite* C--
12:31:42 <copumpkin> yeah, it isn't
12:31:47 <copumpkin> you can ask for the cmm output
12:31:57 <tomboy64> mcstar: http://bpaste.net/show/33726/
12:32:01 <nand`> is it useful (for cross-platform bootstrapping)?
12:32:03 <copumpkin> but I don't think anything much will know what to do with it
12:32:09 <copumpkin> not really
12:32:17 <copumpkin> first of all because a lot of constants are baked in by that point
12:32:21 <copumpkin> platform-specific ones
12:32:25 <nand`> oh
12:32:40 <copumpkin> well, maybe things have changed
12:32:49 <mcstar> tomboy64: and whats the problem with that one?
12:32:58 <copumpkin> actually, I think the cmm might be okay, and just reference a header file with the constants in it
12:33:01 <tomboy64> mcstar: it takes too long to finish :p
12:33:04 <copumpkin> it's the C output that's a pain
12:33:09 * copumpkin shrugs
12:33:10 <tomboy64> mcstar: but apart from that it works fine
12:33:30 <tomboy64> mcstar: btw, it's problem 8 from project Euler
12:35:08 * timthelion ponders how to implement closures in C...
12:35:24 <EvanR> dont ;)
12:35:36 <timthelion> EvanR: :(
12:35:46 <mcstar> there are more scheme implementations that compile to C than monad tutorials
12:35:49 <mcstar> why not choose one?
12:36:22 <mcstar> or, is C still considered a research language?
12:37:06 <timthelion> mcstar: the thing is, that I'm not really sure how I would use a language that comples to C to write a C module(that is, a c file that compiles to a linkable object and provides certain functions to(in this case the brltty braille server)
12:37:55 * timthelion feels like a newb for not knowing the correct vocabulary to describe this.
12:38:20 <mcstar> you want to link against some code that a scheme compiler would output?
12:38:26 <zachk> try getting one of those scheme compilers working quickly and cross platformly :( reason I moved to haskell
12:38:28 <timthelion> mcstar: yes.
12:38:35 <mcstar> timthelion: thats piece of cake
12:39:06 <mcstar> im confident that you can figure it out
12:40:28 <timthelion> mcstar: can you name such a compiler off the top of your head?
12:40:57 <mcstar> tomboy64: does the problem go like this: you have to find the biggest product of 5 consecutive number in that big one?
12:41:09 <tomboy64> mcstar:
12:41:12 <tomboy64> mcstar: yes
12:41:24 <timthelion> mcstar: like is there a defacto scheme to C compiler?
12:42:01 <hpaste> mcstar pasted “PE8” at http://hpaste.org/71012
12:42:40 <mcstar> timthelion: http://www.call-cc.org/
12:43:02 <timthelion> mcstar: thanks, I'll try it out.
12:43:44 <mcstar> tomboy64: *istring* contains that big number as a string
12:44:11 <tomboy64> mcstar: i beg your pardon?
12:44:24 <mcstar> tomboy64: see my paste
12:44:47 <mcstar> tomboy64: replicate that solution in haskell
12:45:51 <roconnor> edwardk: it is done
12:45:56 <tomboy64> ugh
12:46:07 <tomboy64> i haven't done scheme in like 10+ years :-/
12:46:16 <tomboy64> mcstar: i haven't done scheme in like 10+ years :-/
12:46:24 <tomboy64> mcstar: never done any common lisp
12:47:01 <mcstar> i can teach you :)
12:47:12 <mcstar> really, just read it like english
12:47:39 <timthelion> mcstar: so the car runs into the lambda because the driver was looking at a map.
12:48:17 <mcstar> you think thats funny?
12:48:23 <mcstar> XD
12:49:32 <timthelion> mcstar: why did the chicken cross the road?  Because he wanted the car to fall into the C :D
12:50:44 <timthelion> mcstar: I was just reading it like English :) :)
12:51:45 <Goatflakes> hi
12:52:19 <timthelion> Goatflakes: hi
12:53:06 <Goatflakes> stupid question: haskell functions have only one argument right? anything is just currying or pairs?
12:53:21 <Goatflakes> timthelion: o hai :p
12:53:25 <monochrom> yes
12:53:42 <monochrom> @quote monochrom 17-ary
12:53:42 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
12:54:00 <Catnaroek> s/pairs/multiparameter data constructors/
12:54:08 <Goatflakes> ^anything else is just
12:54:17 <Goatflakes> ugh
12:54:19 <Goatflakes> them
12:54:36 <Goatflakes> trying to learn how to separate them from application in my head now
12:54:40 <Goatflakes> derp
12:54:49 <Goatflakes> uppercase initials?
12:55:07 <Catnaroek> When they are alphanumeric identifiers, yes.
12:55:14 <Goatflakes> cool
12:55:30 <Goatflakes> u can have symbol ones?
12:55:32 <Goatflakes> weird
12:55:33 <Quantumplation_> data Influence = Force (Position, Magnitude, Direction) | Source (Position, Rate) | Compound (Influence, Influence), shouldn't DataKinds let me write Compound (Force, Source) instead?
12:55:34 <Catnaroek> Infix data constructors always begin with :
12:55:48 <Catnaroek> (For example, the : used to construct lists)
12:55:50 <Goatflakes> orite
12:55:53 <Goatflakes> thanks
12:56:00 <Catnaroek> :)
12:56:02 <Catnaroek> yw
12:56:12 <roconnor> :) is another infix operator
12:56:14 <Goatflakes> has anyone used that to make a bnf parser? i bet they have
12:56:16 <roconnor> (not really)
12:56:19 <Goatflakes> lol
12:57:33 <Goatflakes> thanks everyone
12:57:48 <HugoDaniel> here: http://hpaste.org/71013
12:58:02 <HugoDaniel> you gotta love "real world programming" :(
12:58:12 <dmwit> timthelion: Write your function in Haskell and export it to C via the FFI, why not.
12:59:10 <Goatflakes> dafaq is that HugoDaniel?
12:59:23 <hpaste> mcstar pasted “PE8” at http://hpaste.org/71014
12:59:25 <Goatflakes> spanish postcode lookereruperer?
12:59:40 <mcstar> tomboy64: ^^
12:59:57 <nand`> am I the only one that thinks Paises is defined a bit.. clumsily?
13:00:15 <HugoDaniel> nand` vim functions on csv files
13:00:29 <HugoDaniel> nand` how would you do it ?
13:00:30 <dmwit> Quantumplation_: I don't think so. But you might be able to write Compound (Force (p, m, d), Source (p', r)). But I doubt it does what you want it to do.
13:00:39 <nand`> HugoDaniel: I don't know
13:01:05 <dmwit> (for some concrete p, m, d, p', and r of kind Position, Magnitude, Direction, etc.)
13:01:08 <tomboy64> mcstar: i'm attempting to decipher it
13:01:20 <HugoDaniel> the names and numbers must match those already in a existing "real world" database
13:01:26 <mcstar> tomboy64: you dont need to, i made one in haskell
13:01:30 <nand`> can't you use something like TH to generate these definitions (instead of third party tools like vim)? Disclaimer: I know nothing about TH
13:01:31 <HugoDaniel> that loads of people use
13:01:36 <Quantumplation_> I want to constrain the compound to only ever be a tuple of 1 Force and 1 Source, in that order.
13:01:37 <tomboy64> mcstar: is there a function reference of common lisp?
13:01:39 <tomboy64> -.-
13:01:47 <mcstar> @clhs
13:01:47 <lambdabot> Unknown command, try @list
13:01:48 <tomboy64> looking at it
13:01:53 <favonia384> hmm
13:02:06 <HugoDaniel> fsck /dev/world
13:02:32 <Goatflakes> kthnxbai
13:02:48 <favonia384> @let pe8 = maximum . foldl (zipWith (*)) (repeat 1) . flip map [0..4] . flip drop
13:02:49 <lambdabot>  Defined.
13:02:54 <byorgey> Quantumplation_: I would write   data Force = Force Position Magnitude Direction;  data Source = Source Position Rate; data Influence = IForce Force | ISource Source | ICompound Force Source
13:02:58 <favonia384> > pe8 [1,1,1,1,8,1,1]
13:03:01 <lambdabot>   8
13:03:03 <byorgey> or something like that
13:03:25 <Quantumplation_> Byorgey: Hrm, that might work
13:03:34 <tomboy64> mcstar: yuck that's too much list-magic for me yet :$
13:04:05 <mcstar> tomboy64: just matching more than 1 constructor, plus naming a sub-pattern
13:04:47 <dmwit> HugoDaniel: Yeah, this seems like a case for TH. I mean, you're already even using it, no? (With those derivePersistField commands and such?)
13:05:08 <HugoDaniel> dmwit: yes, its yesod, not actually me
13:05:15 <HugoDaniel> yesod uses quite a lot of th
13:05:51 <HugoDaniel> dmwit: thing is
13:06:00 <favonia384> tomboy64: it's more like pattern-matching-magic
13:06:00 <HugoDaniel> the strings must match and numbers also
13:06:08 <HugoDaniel> i would have to do a csv parser in th, or something like that
13:06:15 <HugoDaniel> that could read a csv file and generate haskell code
13:06:28 <dmwit> Why?
13:06:39 <dmwit> That "show" instance looks 100% mechanical.
13:06:48 <HugoDaniel> this is to be inserted in an existing database
13:06:53 <HugoDaniel> it is :)
13:07:06 <HugoDaniel> it was based on the (String, Int) pair from the csv file
13:07:08 <dmwit> Those Read instances look 100% mechanical, too.
13:07:13 <HugoDaniel> they are
13:07:17 <HugoDaniel> vim functions
13:07:20 <byorgey> "do a csv parser in TH" <-- huh?
13:07:23 <HugoDaniel> generated those
13:07:28 <dmwit> Yeah, I'm confused by that, too.
13:07:37 <byorgey> you mean you need to use TH to generate code which implements a CSV parser?
13:07:41 <dmwit> You have the data type defined. Let TH generate your Show and Read instances from that.
13:07:44 <HugoDaniel> i dont need
13:07:52 <HugoDaniel> i did the simplest most effortless approach for that
13:08:02 <byorgey> or you mean you need a CSV parser in order to parse some data which will then be used to generate some code?
13:08:10 <HugoDaniel> which was define some quick and dirty vim macros and pump them to produce that haskell code
13:08:24 <HugoDaniel> the TH was your idea, not mine
13:08:32 <HugoDaniel> im not an expert in TH
13:08:52 <HugoDaniel> this was produced by appying vim macros to several csv files
13:09:08 <byorgey> Right, I see.  You can just use an existing CSV parser.
13:09:11 <HugoDaniel> still it was a 1h30m work (defining the macros and writing the code)
13:09:19 <byorgey> The fact that you would then use the resulting data to generate some code makes no difference.
13:09:36 <HugoDaniel> ?
13:09:59 <tomboy64> mcstar: i really don't get this pattern: (a:xs@(b:c:d:e:_))
13:10:00 <HugoDaniel> i actually need this to be compiled...
13:10:11 <byorgey> You don't need to "do a CSV parser in TH".  You just use a CSV parser.  Then write some TH code that uses the data it produces.
13:10:15 <tomboy64> a:xs i get - but what does the @ do?
13:10:20 <dmwit> At the very least, you can write your Read instances as tryParse [(show x, x) | x <- [minBound .. maxBound]]. ;-)
13:10:22 <mcstar> tomboy64: (a:b:c:d:e:_) do you get this?
13:10:49 <geekosaur> bleh, why's that sysadmin job gotta require javascript experience? :/
13:10:56 <HugoDaniel> really ? i thought parsing a CSV in runtime would be incoherent to using TH in preprocessor time
13:11:13 <dmwit> HugoDaniel: TH doesn't happen at runtime.
13:11:15 <tomboy64> mcstar: you take a list with at least 5 elements and grab out the first 5 of them
13:11:22 <HugoDaniel> dmwit: CSV parsing does ;)
13:11:26 <byorgey> HugoDaniel: well, I mean the CSV parser would run at compile time, along with the TH.
13:11:31 <tomboy64> mcstar: assigning them to a..d
13:11:33 <dmwit> HugoDaniel: ...not if your TH is the bit parsing the CSV.
13:11:34 <byorgey> but why is that a problem?
13:11:44 <mcstar> tomboy64: ok, now (a:(b:c:d:e:_)) ?
13:12:04 <HugoDaniel> dmwit: how does that differ from a CSV parser in TH ?
13:12:14 <dmwit> geekosaur: Eh, just tell 'em you've got the experience.
13:12:23 <dmwit> geekosaur: You're pretty smart, you'll pick up JS in no time.
13:12:37 <dmwit> HugoDaniel: It doesn't.
13:12:46 <mcstar> thats not the problem, he doest want to write JS
13:12:46 <HugoDaniel> ok :)
13:12:52 <byorgey> HugoDaniel: By "do a CSV parser in TH" I thought you meant you would need to write a CSV parser using some sort of special TH magic (which is not true).
13:12:58 <tomboy64> mcstar: sorry, never seen nested patterns before
13:13:02 <timthelion> does jhc compile on the latest 7.4.2 ghc?
13:13:09 <byorgey> Perhaps you just mean you are worried about a CSV parser running at TH time?
13:13:15 <mcstar> tomboy64: thats not nested, its the exact same pattern
13:13:15 <byorgey> but in that case I don't understand why you are worried.
13:13:23 <mcstar> tomboy64: i just put some parens there
13:13:24 <dmwit> HugoDaniel: But you know TH is just Haskell code, right? You can just import any CSV parser from Hackage and Just Use It.
13:13:37 <tomboy64> mcstar: ok.
13:13:44 <mcstar> tomboy64: 3+(3*4)
13:13:45 <HugoDaniel> oh ok, i wasn't aware of that
13:13:45 <HugoDaniel> cool
13:13:52 <Quantumplation_> how can I make an instance declaration of Num (Float, Float)?
13:13:53 <HugoDaniel> thanks
13:13:53 <mcstar> tomboy64: you dont need the parens there, also
13:14:07 <tomboy64> mcstar: that i get.
13:14:07 <HugoDaniel> still vim macros seem a faster approach :/
13:14:24 <tomboy64> mcstar: what's the @ then for?
13:14:28 <mcstar> tomboy64: (a:xs@(b:c:d:e:_)) xs@ just names that pattern in the parens as xs
13:14:29 <dmwit> It may be faster to get a first version, but I doubt it will be faster in the long run. =)
13:14:48 <mcstar> tomboy64: it is called as-pattern
13:14:53 <dmwit> tomboy64: x@pattern binds all the names pattern does, and additionally binds x to the entire value that matches pattern.
13:15:07 <tomboy64> ahhhh
13:15:08 <tomboy64> ok
13:15:13 <HugoDaniel> :) true
13:15:15 <byorgey> > let xs@[y,z] = [1,2] in  (xs,y,z)
13:15:16 <lambdabot>   ([1,2],1,2)
13:15:23 <mcstar> dmwit: do you know the Prime Directive?
13:15:38 <dmwit> something something something pre-warp societies?
13:15:38 <mcstar> dmwit: you dont interfere with someone elses diciple....
13:16:12 * dmwit butts out
13:16:12 <byorgey> uh, that happens all the time on #haskell. Get used to it.
13:17:03 <timthelion> byorgey: Hm?
13:17:06 <mcstar> byorgey: i thought by now everyone acknowledged me as a funny guy, joking 80 percent of the time
13:17:26 <copumpkin> disciple is just a couple of letters away from discipline
13:17:42 <jfischoff> so if I am understanding correctly with as patterns you can pattern match more then once, correct?
13:17:43 <nand`> who would have guessed?
13:17:45 <timthelion> mcstar: I thought that in real life.  But lately people have started to tell me, that just never knew when I was telling the truth...
13:17:47 <mcstar> ah, disciple, i was trying to type
13:17:58 <byorgey> mcstar: it is extremely hard to tell when people are joking in text-only chat.
13:18:05 <zachk> mcstar: have you ever used the discplined disciple?
13:18:15 <dmwit> some stunning misinformation available here, no extra charge: http://stackoverflow.com/q/11367844/791604
13:18:29 <byorgey> jfischoff: no, you can only bind extra names
13:18:30 <timthelion> byorgey: that's why we have the ";)" marker :) :)
13:18:38 <byorgey> timthelion: indeed =)
13:18:39 <zachk> and :9 and D:
13:18:58 <dmwit> jfischoff: Not quite. It's not as general as pattern@pattern; *only* a single name can go before the @ sign.
13:19:40 <jfischoff> Yeah that's what I thought before today. The a:xs part looks like pattern matching to me. What I getting wrong there?
13:19:52 <byorgey> matching multiple patterns at once could be cool
13:20:11 <dmwit> jfischoff: a:xs doesn't have an @ sign...?
13:20:22 <fuchsto> Are operations on IORefs (write, read, modify) possible to introduce latency when i, say, sample with 50 Hz and push/pop a IORef [] for every new sample?
13:20:41 <dmwit> oh, I see what you mean
13:20:45 <byorgey> you can do it with http://hackage.haskell.org/package/first%2Dclass%2Dpatterns
13:20:45 <jfischoff> dmwit:  (a:xs@(b:c:d:e:_))
13:20:57 <dmwit> jfischoff: It's a:(xs@(b:c:d:e:_)))
13:21:08 <dmwit> however many closing parentheses
13:21:08 <jfischoff> yeah I see now
13:21:12 <jfischoff> cool
13:21:38 <geekosaur> fuchsto, I think IORefs are cheap, at the price of no atomicity or other guarantees
13:21:41 <mcstar> dmwit: what should i be looking for in thart SO article?
13:21:49 <jfischoff> byorgey: multiple as patterns => ass patterns
13:22:00 <bitonic`> geekosaur: you have atomicity with IORefs
13:22:01 <jfischoff> might be a hard sell
13:22:13 <dmwit> mcstar: All kinds of wrong things. People misunderstanding entropy, randomness, guessing the wrong problem with the "indexing into pi" compression scheme...
13:22:32 <timthelion> dmwit: why did I need to be stuningly misinformed for free?  Don't I pay >100$ a month so that cable news can do that to me in HD?
13:22:35 <geekosaur> bitonic, only if you request it specifically (atomicModifyIORef), no?
13:22:43 <fuchsto> geekosaur: Hmmmmm. I'm experiencing strange things here and thought it could possibly be to many IORef operations.
13:22:59 <bitonic> geekosaur: sure, but there is some mechanism in place to allow that.
13:23:11 * roconnor stores all his files in pi
13:23:41 <mcstar> roconnor: i store yours and mine as well, my Pi is better
13:23:41 <dmwit> For example, "if a string never contains 20 zeros in a row, it isn't random". WRONG
13:23:43 * timthelion steals roconnor's files by sequencing pi with his free CPU cycles.
13:23:52 <byorgey> someone should implement a pifs
13:24:08 <mcstar> dmwit: theres a guy on the internet, who proved, Pi is 3.125
13:24:25 <dmwit> "pi isn't random, therefore it can't contain all bitstrings" what?
13:24:44 <Lemon> Algorithm W keeps composing substitutions together
13:25:12 <Lemon> but never prunes them of mappings that are no longer relevant
13:25:24 <Lemon> so in my implementation, after type checking
13:25:32 <bitonic> Lemon: path compression!
13:25:42 <Lemon> I always get this giant substitution full of variables that do not appear in the checked term
13:25:52 <jfischoff> dmwit: and thus "counting isn't random, therefore it can't contain all bitstrings"
13:25:55 <Lemon> is that normal?
13:26:39 <mcstar> guy doest realize how big his number would be which does the indexing into pi
13:26:39 <tomboy64> mcstar: what are you doing there? \c -> ord c - ord '0'  --- you convert all the digits from digits to ints - but then you subtract 0 from them? why?
13:26:42 <bitonic> Lemon: well it is normal to end with long chains that don't matter anymore if you don't do path compression, yes.
13:26:47 <timthelion> jfischoff: counting IS random.  You don't just see people walking down the streat counting to a million.  If you saw that, they would be, like, a crazy person or something, crazy people are crazy random!
13:26:52 <dmwit> mcstar: exactly
13:27:17 <dmwit> Lemon: I think it's pretty normal, yeah.
13:27:18 <roconnor> dmwit: if we take the algorithmic definition of randomness, is it true that it is impossible to find an offset efficently?
13:27:22 <Lemon> what is path compression?
13:27:33 <mcstar> tomboy64: im subtracting the position of '0' from the position of the numerals in the given codetable
13:27:39 <dmwit> Path compression is important, but not really related to pruning unused variables.
13:27:44 <dmwit> from your substitution state
13:27:49 <mcstar> tomboy64: that effectively gives back the character numeral as number
13:28:03 <dmwit> Path compression is noticing that you have a chain of substitutions like a = b = c = d and just turning it into a = d, b = d, c = d
13:28:05 <tomboy64> ahhh!
13:28:14 <Lemon> oh
13:28:19 <tomboy64> mcstar: couldn't you just have used read for that?
13:28:22 <Lemon> also
13:28:39 <Lemon> I'm trying to make it so that my type checker annotates every subterm with its type
13:28:41 <dmwit> roconnor: What's the algorithmic definition of randomness?
13:28:44 <mcstar> tomboy64: probably would be much slower, and read needs a string as input, not character
13:28:49 <Lemon> instead of just returning one type for the entire term
13:28:58 <tomboy64> i see. ok, thanks.
13:29:04 <Lemon> are there any papers that tell me how to do this?
13:29:07 <bitonic> Lemon: well but you have to remove things that go out of scope, so I'm not sure what you mean by "unused variables"
13:29:43 <roconnor> dmwit: it says that a string is random if the shortest perl program that can print the string is longer than the string.
13:29:44 <Lemon> because sometimes I end up with subterms that are annotated with single type variables when their types should really have more information
13:29:57 <timthelion> mcstar: Sooo... What if we take the length of the Data, and the length of the data's adress in Pi, and then we compair the two, and use the shorter one.  Would the average space savings be equal to or less than one bit?
13:30:07 <Lemon> it's like I have to apply the returned substitution into the types of the term I just did type inference on
13:30:19 <jfischoff> roconnor: are you referring to kolmogorov complexity?
13:30:21 <dmwit> roconnor: hahaha
13:30:27 <Lemon> but I have no idea where to do this and to what "depth"
13:30:28 <bitonic> Lemon: well but that's part of the W algorithm, if I understand what you are saying
13:30:52 <roconnor> jfischoff: oh I'm not sure.  I wonder if I need a self-deliminting language
13:31:03 <roconnor> is perl self-delimiting?
13:31:21 <roconnor> Maybe it is a stupdi questing since parsing perl is undecidable.
13:31:22 <timthelion> roconnor: but that's NOT the deffinition of RANDOM, "aaa" is just as random as "azy"
13:31:24 <Lemon> bitonic, really?
13:31:29 <jfischoff> roconnor: I don't know what self-delimiting means
13:31:36 <mcstar> people need to understand that in one way or another entropy is conserved in information, much like energy is in physics
13:31:49 <bitonic> Lemon: well you should get a "self-contained" type at the end
13:32:09 <roconnor> jfischoff: a self-delimiting language is a language (that is a set of strings) such that no word in the language is the prefix of another word.
13:32:11 <bitonic> something that looks like an haskell98 type
13:32:15 <Lemon> bitonic, yes but the subterms would have to be annotated with something
13:32:19 <mcstar> timthelion: if you want some really strange thing, try looking up the Collatz conjecture
13:32:19 <jfischoff> ah
13:32:24 <dmwit> timthelion: That depends on what distribution you're drawing from. =)
13:32:29 <roconnor> jfischoff: this means that when you've reached the end of the word, you know it!
13:32:29 <Lemon> and that something seems to require lexically-scoped type variables
13:32:56 <Lemon> and I can't even figure out what design for those I should use in my language
13:33:01 <dmwit> Also, it depends very much on what "just as random as" means.
13:33:24 <jfischoff> roconnor: its like a "huffman" language
13:33:35 <bitonic> Lemon: wait do you have dynamically scoped type variables :P?
13:33:42 <Lemon> bitonic, no
13:33:52 <Lemon> but, say I have a simple identity function
13:33:56 <Lemon> \x -> x
13:33:59 <roconnor> timthelion: I'm pretty sure it is the algorithmic definition of random (upto whether perl needs to be self-delimiting or not).
13:34:06 <Lemon> it would have type
13:34:06 <roconnor> timthelion: there are other definitions of random
13:34:12 <Lemon> (\x -> x) :: forall a. a -> a
13:34:21 <bitonic> Lemon: so what's wrong?
13:34:23 <Lemon> but if I want to annotate both of those xes
13:34:27 <Lemon> what do I put?
13:34:37 <Lemon> (\x :: a -> x :: a) :: forall a. a -> a
13:34:38 <Lemon> ?
13:34:50 <bitonic> if you derived `forall a. a -> a', you know that `x : a'
13:34:57 <bitonic> yes
13:34:57 <dmwit> (/\a :: *. \x :: a -> x :: a), yes
13:35:15 <Lemon> but the forall keeps the 'a' inside the type of the function
13:35:17 <timthelion> roconnor: Are you sure that's not called "diversity" and not "randomness"?
13:35:18 <Lemon> which is closed
13:35:29 <Lemon> where does the a for the things inside come from?
13:35:30 <bitonic> Lemon: it is in scope in the body of the function
13:35:34 <dmwit> Lemon: Notice the capital lambda in my version. =)
13:35:40 <Lemon> dmwit, oh
13:35:42 <Lemon> like in System F
13:35:45 <dmwit> right
13:36:20 <bitonic> Lemon: yeah the quantification is outside the arrow type, so the `a' has been already "passed in"
13:36:51 <dmwit> This is why System F is the calculus that GHC compiles to (well, it used to, before it got the really cool features).
13:36:57 <timthelion> roconnor: I'm just trying to distinguish this definition from the more widely understood idea of randomness as relating to an unpredictable event in time(as per quantum phisics)
13:36:58 <mcstar> also, it would be ineteresting to decode the digits of pi, using it as the basis of some image format, and finding the mugshot of God
13:37:21 <EvanR> :|
13:37:25 <olsner> hmm, isn't that what they do in Contact?
13:37:34 <mcstar> i dont think so
13:37:47 <EvanR> yeah its hitler
13:37:47 <mcstar> oh, btw im atheist
13:37:52 <dmwit> Maybe you're thinking of the movie Pi. =)
13:37:53 <mcstar> sort of
13:37:56 <dmwit> (aptly named)
13:38:02 <roconnor> timthelion: oh algorithmic randomness is quite distinct from probabilistic randomness; though algorithmic randomness (almost) obeys the same axioms, hence the name.
13:38:05 <mcstar> dmwit: excellent movie
13:38:07 <timthelion> mcstar: I sequenced my DNA and found a high def PNG of the flying spaghetti monster, tomatoe sauce and all.
13:38:12 <pnkbst> mcstar: hi athiest
13:38:16 <dmwit> mcstar: We're going to have to disagree there. It's terrible.
13:38:17 <mcstar> dmwit: though, that deals with the koran
13:38:24 <dmwit> Literally the worst movie I've watched.
13:38:39 <mcstar> dmwit: have you seen Primer?
13:38:39 <EvanR> timthelion: i got a mostly nude pinup of kate upton
13:38:46 <dmwit> Primer was pretty fun.
13:38:51 <jfischoff> roconnor: I think they connect somehow too (vaguely remember reading something to that affect)
13:38:51 <mcstar> that was terrible
13:38:53 <roconnor> I sequenced my DNA and I found a bitmap of an alien crashlanded in a dutch farm field.
13:38:54 <zachk> #haskell-blah ? ;-9
13:38:57 <EvanR> primer is awesome
13:39:00 <dmwit> EvanR: Conclusion: Kate Upton is God.
13:39:21 <sclv> primer and kate-upton belong in blah
13:39:25 <EvanR> lol
13:39:34 <mcstar> lets bring this to -blah indeed
13:40:07 <mk12> when you have a long list of function parameters and need to start the body on a new line, do you put the equals sign at the end of the first or the beginning of the second?
13:40:56 <applicative> mk12: either
13:40:59 <Lemon> I am gonna go read the lexically scoped type variable paper
13:41:02 <Lemon> and then ask my questions
13:41:12 <applicative> not the  very beginning
13:41:29 <dmwit> mk12: I prefer it on the beginning of the second line.
13:41:40 <dmwit> applicative: I think(?) this is a style question, not a syntax question.
13:41:55 <mk12> applicative: I know either works, but is there a convention? haskell style seems to be pretty consistent
13:42:03 <mk12> yes I'm just wondering about style
13:42:25 <dmwit> Then I line up my = and . and $ =)
13:42:39 <mk12> dmwit: yeah I was thinking that too
13:42:52 * applicative secretly prefers the initial line, even for 'where', where possible
13:43:50 * EvanR wonders how to do acid state without template haskell
13:44:15 <dmwit> For short lines, yes, put everything up to where on one line.
13:44:21 <EvanR> HelloWorldNoTH.hs ahhh
13:44:32 * applicative point to the ...noTH.hs files in the /examples folders
13:44:33 <favonia384> mk12: I'll put something in the end of the first line, like "do", "bracket" etc and then go to the second line if the body is tooooo large.
13:44:49 <applicative> EvanR: ah you found them
13:45:39 <mk12> favonia384: yes I do that too (for layout keywords like of, do, etc.) but I more talking about operators
13:47:07 <nand`> the other day I came up with a nice software versioning system to replace the usual ‘a.b.c’: ω^a + ω*b + c
13:47:35 <zachk> nand`: what is it?
13:47:42 <dmwit> w^2*a + w*b + c seems more normal to me
13:47:43 <nand`> and by “I came up with” I mean “they've existed for ages”
13:47:45 <applicative> nand`, i hope it isn't the decimal expansion of pi
13:47:46 <dmwit> and more extensible, too
13:47:51 <nand`> dmwit: exactly
13:47:57 <nand`> zachk: basically, using ordinals
13:48:03 <nand`> for the exact purpose they're good for..
13:48:25 <dmwit> a.b.c.d is just a base-w number ;-)
13:48:41 <nand`> dmwit: re: w²·a, yes; that's what I meant
13:49:06 <barrucadu> applicative: Decimal expansions of irrational numbers are the best versioning systems
13:49:42 <applicative> barrucadu: are there others beside TeX?
13:49:56 <applicative> If that one, then many others I guess
13:50:00 <barrucadu> I think Metafont also uses an irrational number
13:50:03 <nand`> applicative: there's one for e
13:50:05 <nand`> yes
13:50:06 <nand`> metafont
13:51:16 <favonia384> time to have something v1.618
13:53:14 <dmwit> irrationality seems like the wrong property
13:53:23 <nand`> defining ... x₃.x₂.x₁.x₀ ≅ ... ω³x₃ + ω²x₂ + ωx₁ + x₀; the ability gained is that you can express, say, ω²3 without having to write “3.0.0”; and easily comparable too. Have a dependency on program > ω²·3
13:54:28 <dmwit> (rationals seem fine too, so long as their denominator is coprime to 10 or some such thing)
13:55:00 <hiptobecubic> just use the expansion of 1/3
13:55:15 <zachk> why not surreal numbers?
13:55:25 <favonia> nand`: and -any = ω^ω
13:55:45 <pnkbst> are those related to quantum numbers?
13:55:46 <nand`> favonia: I would do ≥ 0 for that
13:55:55 <favonia> oh I meant the upper bound
13:55:57 <applicative> hah
13:56:25 <nand`> favonia: upper bound is ε₀ !
13:57:00 <nand`> or actually ω₁
13:57:13 <otters> I love those letters
13:57:15 <otters> they're so pretty
13:57:18 <applicative> the lower bound of proofs of consistency of arithmetic
13:57:43 <dmwit> Epsilon is a sideways omega!
13:57:48 <tomboy64> mcstar: actually, i solved a completely different problem than you did.
13:57:52 <favonia> nand`: wait... you're allowing ω^{ω^ω} ?! lol
13:58:00 * applicative scratches his chin
13:58:01 <tomboy64> mcstar: and i'm afraid, you solved the right one :$
13:58:05 <homie> ω \sub 1
13:58:09 <homie> hmmm
13:58:16 <dmwit> correct versioning requires a solution to the continuum hypothesis
13:58:28 <nand`> favonia: the programmer should be able to use any countable ordinal as program version
13:58:31 <dmwit> ?keal
13:58:32 <lambdabot> the [nsa] even make light green both ways once
13:59:23 <favonia> hmmm
13:59:25 <homie> ω₁, how do you get the lower index here ?
13:59:25 <applicative> what is ?keal
13:59:35 <zachk> @keel
13:59:36 <lambdabot> how do i search for someone saying 'Keal' in mirc
13:59:38 <nand`> homie: by pressing Alt Gr + Shift + 1
13:59:44 <homie> oh
13:59:48 <dmwit> ?keal
13:59:49 <lambdabot> are you saying i am MegaMonad?
13:59:58 <homie> ω¡
13:59:59 <dmwit> applicative: It's ?quote keal, but before ?quote existed.
14:00:03 <homie> nope
14:00:15 <applicative> ?dmwit
14:00:15 <lambdabot> Unknown command, try @list
14:00:18 <applicative> ha
14:00:23 <homie> ω¹ ok but that upper
14:00:35 <dmwit> There is a very fine quote in there somewhere about showing how to spell triangles with only five numbers...
14:00:47 <mcstar> tomboy64: lucky me :)
14:01:07 <favonia> nand`: then it's easy. all the old version numbers are bounded by ω^ω. let's enourage people to write something bigger
14:01:39 <dmwit> ?keal
14:01:40 <lambdabot> can GMP support KealDigit? I invent KealDigit
14:02:17 <nand`> ?quote keal.*triangle
14:02:18 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
14:02:25 <Adeon> I what
14:02:29 <zachk> @keel
14:02:30 <Adeon> wait
14:02:30 <lambdabot> i aint running that on my puter
14:02:32 <Adeon> nevermind
14:02:38 <nand`> ?quote keal triangle
14:02:39 <lambdabot> No quotes for this person. My brain just exploded
14:02:41 * nand` gives up
14:02:54 * hackagebot test-simple 0.1.2 - Simple Perl inspired testing  http://hackage.haskell.org/package/test-simple-0.1.2 (BorisSukholitko)
14:02:56 * hackagebot luka 2012.7.7 - Simple ObjectiveC runtime binding  http://hackage.haskell.org/package/luka-2012.7.7 (JinjingWang)
14:03:14 <nand`> dmwit: I take it ?keal has its own, separate, database of quotes?
14:04:03 <dmwit> nand`: Yes.
14:04:31 <nand`> I see. “It's ?quote keal” threw me off
14:05:07 <dmwit> ...but before ?quote existed. =)
14:05:51 <favonia> homie: http://www.alanwood.net/unicode/superscripts_and_subscripts.html
14:06:36 <applicative> i show how spell triangle in less than three corners using darkmanifold
14:06:46 <mizu_no_oto> Suppose I have a case class Foo, and in object Foo I define an implicit conversion to Monoid[Foo].  In the same file, in object Bar I have a helper method that has an implicit Monoid parameter.  When I call that helper method (from another method in Bar), the compiler complains about not being able to find the implicit value conversion.  What's going on?  The conversion should be in scope, right?
14:07:08 * applicative likes this keal character
14:07:19 <mizu_no_oto> gah
14:07:25 <mizu_no_oto> meant to post that in #scala
14:07:41 <nand`> dmwit: I interpreted that as “the ?quote database was around for some reason, but the command itself didn't exist yet” :)
14:07:55 * hackagebot paragon 0.1.27 - Paragon  http://hackage.haskell.org/package/paragon-0.1.27 (NiklasBroberg)
14:08:13 * Cale remembers the HaskellIRCQuotesPage
14:09:01 <Cale> Or maybe it was just QuotesPage
14:09:04 <RaphaelJ> Hello, what could make a program running with the -hc profiling option a lot faster and requiring 10 times less memory ?
14:09:10 <applicative> " tomorrow i share next mathematical secrety"  "all i know is i have experienced my own death unhappening..." "what the hell does Prelude > mean?"
14:09:33 * applicative wants this keal character back
14:09:50 <otters> means the Prelude is more valuable than whatever crap you write at the prompt
14:10:07 <Cale> http://web.archive.org/web/20070609061216/http://www.haskell.org/hawiki/QuotesPage
14:10:56 <applicative> otters, that's my experience, yes
14:14:03 <daniel_-> how do i take this "IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)" and make a new  type of it? with newtype or with data?
14:14:30 <applicative> daniel_-: it can be a newtype
14:14:51 <Lemon> aight
14:14:58 <daniel_-> okay
14:15:06 <Lemon> so I just read the lexically scoped typpe variables paper
14:15:07 <daniel_-> im just really unsure about ADT's
14:15:08 <applicative> newtype Daniel_ = Daniel {unDaniel:: IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)}
14:15:31 <Lemon> and they mentioned two approaches
14:15:42 <mel-> hi
14:15:53 <applicative> do you really need to isolate this type other than by "IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)"
14:16:00 <Lemon> one was as dmwit suggested: use System F style capital lambdas for type variables
14:16:04 <applicative> hi mel-
14:16:22 <Lemon> the other is the Haskell way of simply using variables in annotations as placeholders for types
14:16:34 <Lemon> I'm kind of leaning toward the former approach
14:16:44 <Lemon> but then they gave this example:
14:17:05 <daniel_-> well i have an app i want to build in haskell which creates processes and create pipes of stdin,out,err and (i guess) creates threads which manages them and monitor them and etc
14:17:11 <Lemon> data Ap = forall a. Ap [a] ([a] -> Int)
14:17:31 <daniel_-> i just thought it might be nice to wrap it into a ADT since i would pass it to something else later
14:17:53 <dmwit> nand`: Anyway, what I said was sort of intentionally misleading. I got a few seconds of smug self-satisfaction out of it, but it was probably pretty annoying for you. So... sorry about that.
14:17:59 <dmwit> Seems I'm not a mature adult yet after all.
14:19:52 <daniel_-> but i guess when i do "new <- CreateProcess ps" i can just have pattern matching in the function which i later pass new to
14:20:11 <dmwit> Cale: amazing
14:20:42 <applicative> daniel_-:  why not a record with fields Daniel {stdin :: Maybe Handle, stdout :: Maybe Handle etc.}  I don't think you should include the IO bit
14:21:08 <nand`> dmwit: don't sweat it, I used two experiments to deduce the true nature of your expression and all comments that proceeded afterwards were beating the dead horse more or less
14:22:02 <daniel_-> oh i guess the IO monad threw me off a bit, thanks for the help applicative :)
14:22:36 <dmwit> ?quote esap
14:22:36 <lambdabot> No quotes match. My brain just exploded
14:22:46 <dmwit> ?remember esap I think the way to get stuff done is by doing it.
14:22:46 <lambdabot> It is forever etched in my memory.
14:23:28 <bitonic> relevant: http://productiveblog.tumblr.com
14:24:03 <dmwit> true =(
14:24:29 <dmwit> ?quote ddarius morons
14:24:30 <lambdabot> ddarius says: [re: a40a15cb.0304160038.585f3e8@posting.google.com ] The best thing to get out of this, I guess,is that Haskell IS becoming more mainstream and even morons have heard of it.
14:24:52 <bitonic> that is *so* elitist. You should all be ashamed!
14:25:08 <jfischoff> @quote wadler xml
14:25:09 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
14:25:16 <jfischoff> @quote wadler
14:25:16 <lambdabot> wadler says: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
14:25:28 <dmwit> ?quote wadler essence
14:25:29 <lambdabot> No quotes match. Take a stress pill and think things over.
14:25:41 <mcstar> lol
14:25:50 <mcstar> what i run into with c# the other day
14:26:35 <mcstar> guy was parsing a double from a string, but because of the locale settings, the parser returned it interpreted as an integer converted to a double
14:26:49 <mcstar> 23.4545445 => 234545445,00
14:27:14 <mcstar> (i was helping someone)
14:27:46 <jfischoff> @remember Wadler says: So, the essence of XML is this: the problem it solves is not hard, and
14:27:46 <lambdabot> Done.
14:27:47 <jfischoff> it does not solve the problem well.
14:27:50 <hpaste> keep_learning pasted “Getting error in Eden moduble” at http://hpaste.org/71015
14:27:53 <jfischoff> crap
14:28:10 <keep_learning> hello all
14:28:15 <jfischoff> @quote Wadler xml
14:28:15 <lambdabot> Wadler says: says: So, the essence of XML is this: the problem it solves is not hard, and
14:28:18 <keep_learning> I am trying to run eden module
14:28:26 <jfischoff> @forget Wadler xml
14:28:27 <lambdabot> No match.
14:28:29 <keep_learning> but getting compiler error
14:28:55 <mcstar> keep_learning: -XSupportModuble
14:28:57 <dmwit> ?forget Wadler says: So, the essence of XML is this: the problem it solves is not hard, and
14:28:57 <lambdabot> Done.
14:29:07 <jfischoff> thanks
14:29:35 <jfischoff> @quote Wadler says: So, the essence of XML is this: the problem it solves is not hard, and it does not solve the problem well.
14:29:36 <lambdabot> No quotes match. Take a stress pill and think things over.
14:29:52 <mcstar> jfischoff: remember to use remember
14:30:13 <jfischoff> @remember Wadler says: So, the essence of XML is this: the problem it solves is not hard, and it does not solve the problem well.
14:30:13 <lambdabot> It is stored.
14:30:18 <jfischoff> amazing!
14:30:40 <dmwit> You failed, again.
14:30:56 <dmwit> ?forget Wadler says: So\, the essence of XML is this: the problem it solves is not hard, and it does not solve the problem well.
14:30:57 <lambdabot> No match.
14:31:06 <dmwit> ?forget Wadler says: So, the essence of XML is this: the problem it solves is not hard, and it does not solve the problem well.
14:31:06 <lambdabot> Done.
14:31:20 <dmwit> ?remember Wadler So, the essence of XML is this: the problem it solves is not hard, and it does not solve the problem well.
14:31:21 <lambdabot> Okay.
14:31:28 <hpaste> keep_learning annotated “Getting error in Eden moduble” with “Getting error in Eden moduble (annotation)” at http://hpaste.org/71015#a71016
14:32:04 <keep_learning> mcstar, it says unrecognized flag
14:32:30 <mcstar> keep_learning: that was a joke on you misspelling Module, sry
14:33:05 <keep_learning> mcstar, I tried -XSupportModule
14:33:30 <DanBurton> random question: I'm trying to put some example code in my .cabal file that includes curly braces, and apparently cabal doesn't like that
14:33:41 <DanBurton> what do I do?
14:33:45 <mcstar> keep_learning: j/k, disregard my advice entirely
14:33:55 <geekosaur> keep_learning, the whole response was a (poorly advised) joke, there was no answer there
14:34:06 <dmwit> DanBurton: Is it prefaced with "> "?
14:34:41 <DanBurton> dmwit: nope I was using @ to enclose the code block
14:35:16 <geekosaur> keep_learning, hackage is telling me the missing module is not from edenmodules package but edenskel package
14:35:51 <geekosaur> http://hackage.haskell.org/package/edenskel
14:35:56 <dmwit> ?quote RTS
14:35:57 <lambdabot> luite says: safe languages are just like that sports car with great suspension, good noise isolation, electronic stability control, it just doesn't feel as fast
14:36:05 <dmwit> ?quote rts.fail
14:36:06 <lambdabot> No quotes match. My brain just exploded
14:36:08 <merijn> ?seen Peaker
14:36:08 <lambdabot> Unknown command, try @list
14:36:17 <merijn> Hmm, what was the command for preflex?
14:36:26 <dmwit> preflex: seen Peaker
14:36:26 <preflex>  Peaker was last seen on #haskell 1 day, 2 hours, 2 minutes and 57 seconds ago, saying: it should be: ?topic (nth 6) tail
14:36:36 <merijn> dmwit: Thanks
14:37:50 <jfischoff> I'm getting "ld: library not found for -lcrt0.o" when I try to build an executable with  -static -optl-pthread -optl-static on OSX. Any ideas?
14:38:00 <Cale> <autrijus> Perl: "Easy things are easy, hard things are possible"
14:38:00 <Cale> <autrijus> Haskell: "Hard things are easy, the impossible just happened"
14:38:33 <keep_learning> geekosaur, Thank you
14:38:45 <merijn> Cale: Carefully note how it doesn't mention the difficulty of easy things in haskell ;)
14:39:12 <Cale> yes
14:39:14 <hpaste> DanBurton pasted “weird cabal error” at http://hpaste.org/71017
14:39:40 <DanBurton> I'm getting this message when I try to cabal clean: cabal: lens-family-th.cabal:24: unexpected span: ") `fmap` (f (fieldName a))"
14:40:00 <applicative> jfischoff: http://appliedprocrastination.blogspot.com/2008/12/dread-lcrt0o-error-on-mac-os-x.html strange
14:40:03 <geekosaur> jfischoff, I'm not sure static is supported on OS X.  in particular libc is only available as a dylib (and is a stub for libSystem.dylib)
14:40:13 <DanBurton> if I remove the line it is referring to, the problem goes away
14:40:35 <DanBurton> which is: > lensName f a = (\ x -> a { fieldName = x } ) `fmap` (f (fieldName a))
14:41:18 <merijn> geekosaur: I'm pretty damn sure I compile static binaries on OSX all the time and while I'm not 100% sure because I didn't check I don't see why libc wouldn't be included?
14:42:10 <jfischoff> Is there a way to just make the haskell parts static? I just want the executable to run other OSX machines (same version as mine) without haskell
14:42:22 <applicative> "This option will not work on Mac OS X unless all libraries (including libgcc.a) have also been compiled with -static."
14:43:03 <applicative> jfischoff: have you seen the cabal-macosx package?
14:43:13 <jfischoff> nope
14:43:29 <geekosaur> merijn, I just doublechecked my installed Xcode and there is no static libc or crt support included, at least for the Lion SDK.  none whatsoever.  you may build *something* static but the system linkage is only dynamic
14:43:31 <DanBurton> oohh looks like I stumbled on a cabal bug. "the following should never happen ... unexpected span" http://hackage.haskell.org/packages/archive/Cabal/1.14.0/doc/html/src/Distribution-ParseUtils.html
14:43:41 <applicative> jfischoff: I haven't used it for a while, but it collects what is needed to make a little 'app'
14:44:12 <jfischoff> applicative: so it will include the necessary shared libs ghc needs?
14:44:51 <applicative> jfischoff: you can set various levels of library inclusion so to speak
14:44:55 <applicative> jfischoff: if I remember
14:44:59 <Catnaroek> Hello, folks. I am downloading xmonad from cabal. It is stuck downloading syb-0.3.7. How big is that package?
14:45:39 <applicative> jfischoff: it's really meant for .app bundles.
14:45:46 <applicative> Catnaroek: tiny
14:46:01 <jfischoff> applicative: yeah I see the ChaseDeps setting
14:46:06 <jfischoff> applicative: cool thanks
14:46:15 <Catnaroek> applicative: It is safe to interrupt cabal (e.g., ^C)?
14:46:32 <Catnaroek> It is like 5 minutes stuck with that.
14:46:34 <dmwit> xmonad depends on syb?
14:46:51 <Catnaroek> dmwit: Well, apparently!
14:47:13 <geekosaur> um
14:47:16 <Catnaroek> So... Is it safe to interrupt cabal?
14:47:27 <dmwit> Oh, what. X11 depends on syb?
14:47:42 <dmwit> That doesn't make sense.
14:48:50 <Catnaroek> What is syb exactly?
14:49:14 <Catnaroek> Oh, a client-side HTTP library.
14:49:43 <dmwit> what
14:50:33 <Catnaroek> Well, pacman -Ss haskell-syb says "A library for client-side HTTP"
14:50:39 <applicative> jfischoff:  this might be of use as an example for  a non- .app command line thing; a little installer that when the user installs puts it in /usr/bin or wherever https://github.com/jgm/pandoc/blob/master/make_osx_package.sh
14:51:00 <dmwit> Catnaroek: Well, that's just plain wrong.
14:51:12 <Catnaroek> dmwit: Then what would be right? :O
14:51:14 <dmwit> Scrap Your Boilerplate is for generic programming.
14:51:22 <dmwit> Also, seems like a bug that X11 depends on syb.
14:51:23 <Catnaroek> Oh.
14:51:24 <applicative> bizarre,  scrap your client side http
14:51:36 <dmwit> Let's see what happens if I just remove a few things here...
14:51:42 <jfischoff> haha
14:52:12 <Catnaroek> I am just trying to replace all my Haskell Arch packages with cabal ones (except the ghc package itself).
14:52:50 <Catnaroek> Fortunately, things are not as painful as they were when I was a Debian user... so far.
14:53:00 <applicative> Catnaroek: does ghc-pkg check suggest anything is wrong
14:53:09 <shachaf> Catnaroek: WHy are you installing global packages?
14:53:15 <shachaf> Just get GHC and put everything in ~
14:53:31 <Catnaroek> applicative: ?
14:53:39 <Catnaroek> shachaf: ?
14:53:50 <applicative> the command "ghc-pkg check" will tell you if something is broken
14:54:06 <shachaf> Catnaroek: There's not a whole lot of benefit to installing GHC packages globally.
14:54:07 <Catnaroek> applicative: Nope, nothing is broken.
14:54:25 <applicative> hm
14:54:29 <Catnaroek> shachaf: So I should install them in my personal directory?
14:54:40 <shachaf> That's what cabal-install does by default.
14:54:49 <shachaf> ~/.cabal and ~/.ghc
14:55:06 <daniel_-> @src ProcessHandle
14:55:07 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:55:16 <applicative> Catnaroek: the things you want to build xmonad should be in your local .cabal or whatever (for easy future destruction :) )
14:55:38 <Catnaroek> Well, right now I do not have any cabal packages installed.
14:55:53 <Catnaroek> I deleted both ~/.cabal and ~/.ghc/x86_64blarg
14:56:00 <applicative> but Catnaroek , 'cabal install syb' just by itself freaks out?
14:56:06 <Catnaroek> applicative: Let me see.
14:56:34 <Catnaroek> Well, since I deleted .cabal, I have to re-run cabal update. :S
14:57:02 <applicative> does ghc-pkg list show any curiosities?  I guess it would be stuff that pacman installed
14:57:20 <dmwit> Seems to compile just fine without syb. =)
14:57:25 <Catnaroek> applicative: Yeah, quite a lot of stuff.
14:58:16 <Catnaroek> applicative: What should "ghc-pkg list" display in a minimal GHC install?
14:58:43 <Catnaroek> applicative: Well, syb alone installed correctly.
14:59:05 <hpaste> applicative pasted “libs” at http://hpaste.org/71019
14:59:14 <applicative> Catnaroek: here is what I get building ghc-head   ^^
14:59:34 <applicative> I forget what they are called. boot  libraries?
14:59:41 <Catnaroek> lemme see
15:00:32 <dmwit> Catnaroek: The git repository of X11 no longer depends on syb, in case you care.
15:01:11 <hpaste> applicative annotated “libs” with “libs (annotation)” at http://hpaste.org/71019#a71020
15:01:32 <applicative> Catnaroek: here is what I get with  the os x haskell platform  ^^
15:01:38 <Catnaroek> :O
15:02:05 <Catnaroek> applicative: I get the same packages as you, with plus extensible-exceptions
15:02:14 <Catnaroek> applicative: Also, some of my packages are a little outdated.
15:02:19 <applicative> well that seems good then
15:02:33 <applicative> Catnaroek: what version of  ghc?
15:02:39 <Catnaroek> 7.4.2
15:03:09 <applicative> they cant be too outdated ...
15:03:19 <Catnaroek> dmwit: But the cabal package still depends on it, right?
15:03:39 <Catnaroek> applicative: Yeah, not terribly outdated, yeah.
15:03:56 <applicative> I think Cabal depends on syb somehow
15:04:00 <Catnaroek> applicative: Where did you install GHC from?
15:04:06 <dmwit> I think the question you meant to ask was whether the latest release on Hackage depends on it, and the answer to that is still yes.
15:04:16 <dmwit> However, the cabal package available from git does not depend on it.
15:04:21 <dmwit> ...to answer your exact question.
15:04:24 <Catnaroek> Ah!
15:04:59 <Catnaroek> So, well... finally xmonad installed.
15:05:30 <Catnaroek> So I finally have a distro-package-free xmonad. :D
15:05:34 <Catnaroek> ty ppls
15:05:50 <nand`> (let a' = inverse of a), is a'·b' = (a·b)' for all groups? I can prove it for abelian groups: a·b·a'·b' = a·a'·b·b' = 1·1 = 1; but what about without commutativity?
15:06:36 <dmwit> No, (ab)' = b'a'
15:06:41 <applicative> youd think a'.b' = (b.a)'
15:07:00 <dmwit> For most groups, b'a' /= a'b'.
15:08:06 <nand`> dmwit: I see, thanks
15:08:29 <nand`> and yeah, makes sense
15:12:27 <hpaste> daniel_ pasted “how do i make this skip the unpack createProcess to pack it into Proc directly” at http://hpaste.org/71021
15:12:52 <daniel_-> pretty much sums it up
15:13:36 <dmwit> That's probably the clearest way to write that function.
15:13:45 <daniel_-> okay
15:14:15 <daniel_-> but i just thought since createprocess return with (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle) is my datatype Proc
15:14:27 <jfischoff> maybe with a Newtype instance and pack <$> createProcess ps?
15:15:17 <daniel_-> ok not possible to do something like
15:15:24 <daniel_-> process :: Proc
15:15:30 <daniel_-> process <- createProcess ps
15:15:54 <dmwit> There are about two dozen tweaks you can do.
15:15:59 <monochrom> unsafeCoerce may work correctly for this...
15:16:09 <dmwit> They will be of very nearly equal readability.
15:16:20 <dmwit> Instead of trying them each in turn, you should move on and write some real code.
15:16:27 <daniel_-> i dont care that it is actually defined as it is right now, i think its pretty clear
15:16:49 <daniel_-> just thought i did an extra step since they where basicly the same datatype except that Proc has accessors or what they are called
15:17:04 <dmwit> Yes, it's an extra step.
15:17:06 <dmwit> So?
15:17:55 <daniel_-> no problem for me, just wondered if there was some way to do it better :)
15:18:00 * hackagebot luka 2012.7.7.1 - Simple ObjectiveC runtime binding  http://hackage.haskell.org/package/luka-2012.7.7.1 (JinjingWang)
15:18:16 <Twey> In Pandoc, how can I make writeMarkdown disallow raw HTML?
15:19:18 <hpc> Twey: you can make it escape it, i think
15:20:28 <dmwit> ?quote timesheet
15:20:29 <lambdabot> No quotes match. Just what do you think you're doing Dave?
15:21:08 <dmwit> ?remember lispy Me> "I worked 80 hours today";; TimeBot> "Timesheet updated."
15:21:09 <lambdabot> Done.
15:22:38 <mcstar> "But I don't _want_ functional programming!"
15:22:40 <mcstar> -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
15:22:52 <dmwit> ?quote greenpeace
15:22:52 <lambdabot> No quotes match. Where did you learn to type?
15:22:54 <Twey> Haha
15:23:08 <Twey> hpc: How?  I'm searching the documentation but coming up blank
15:23:16 <dmwit> ?remember ncalexan Getting fed up with Haskell and picking up another language is like swapping your Greenpeace spouse for an abusive tyrant.  Boy, does vegan sound good after beatings.
15:23:17 <lambdabot> Good to know.
15:23:47 <JoeyA> Would it be insane to use ContT () to implement a looping construct like this: foreach :: [a] -> M a.  Yes, I do want side effects occurring in previous iterations to be visible in the current one.
15:23:47 <lambdabot> JoeyA: You have 1 new message. '/msg lambdabot @messages' to read it.
15:24:30 <hpaste> beefcube pasted “parsec run” at http://hpaste.org/71022
15:24:35 <beefcube> this example from the parsec manual is now not compiling, not sure why, it was working prior to installing and unregistering a number of parsec packages, clue please?
15:25:42 <zachk> JoeyA: I am curious as to which M's you would like
15:26:18 <dmwit> beefcube: Change the type to mention Text instead of String, or import the String interface to Parsec instead of the Text one.
15:26:26 <JoeyA> e.g. total <- lift $ newIORef 0; x <- foreach [1..10]; lift $ modifyIORef total (+ x)
15:26:27 <geekosaur> you sure?  why request the Text variant and then pass it strings?
15:26:31 <monochrom> perhaps s/import Text.Parsec.Text/import Text.Parsec.String/
15:26:34 <geekosaur> or, what dmwit said
15:27:23 <JoeyA> I'm wondering if something about this violates monadic laws or something.
15:27:24 <dmwit> (Also, I believe you're lying.)
15:27:34 <dmwit> (Perhaps not on purpose.)
15:28:00 <geekosaur> that'd be the "you sure?" part
15:28:08 <dmwit> right
15:28:18 <beefcube> monochrom: ya, I need to stop making this sort of mistake
15:29:25 <dmwit> JoeyA: Only brand new instances can violate monad laws.
15:29:38 <dmwit> Once you've proven them, they're proved. No backsies.
15:29:48 <JoeyA> dmwit: According to the docs of ListT, it can violate monad laws when used with IO.
15:29:56 <JoeyA> err, with a non-commutative monad
15:29:58 <dmwit> ListT is not a monad transformer.
15:30:02 <JoeyA> (which I'm pretty sure IO is)
15:30:12 <dmwit> But ContT is. =)
15:30:16 <JoeyA> But I'm not using ListT, but ContT
15:30:26 <JoeyA> So ContT is completely safe w.r.t. monad laws?
15:30:30 <bjchambers> ben12
15:30:31 * geekosaur thought ListT was known broken anyway
15:30:43 <dmwit> Yes, ContT doesn't even require the type you pass it to be a monad. =)
15:30:49 <dmwit> geekosaur: ListT is pretty broken, yeah.
15:31:10 <hpc> ListT requires a commutative monad
15:31:52 <JoeyA> zachk: To answer your question, it's problem-specific monad that tracks state across iterations, and has a control structure supporting escaping as well.
15:32:12 <dmwit> I'm not really sure why ListT came into the discussion at all, though.
15:32:27 <JoeyA> I'm doing something ListT-like.
15:33:05 <dmwit> I see.
15:33:12 <zachk> JoeyA: do you have any `workin code yet?
15:33:23 <JoeyA> I'm working on it.
15:35:45 <JoeyA> Hmm, if I defined foreach :: [a] -> M a instead of foreach :: [a] -> (a -> M ()) -> M (), I wonder if there's a way to perform computation after the foreach.  That is, to run a nested computation that keeps the foreach from spilling out.
15:41:14 <mrsolo> is there a more elegant way to do this?   'quote':"hi":["quote"]  ?
15:41:45 <mcstar> > 'quote':"hi":["quote"]
15:41:46 <lambdabot>   <no location info>:
15:41:46 <lambdabot>      lexical error in string/character literal at chara...
15:41:53 <MostAwesomeDude> mrsolo: What did you want?
15:41:56 <mcstar> so yes, '12'
15:42:01 <mcstar> > '12'
15:42:02 <lambdabot>   <no location info>:
15:42:02 <lambdabot>      lexical error in string/character literal at chara...
15:42:06 <MostAwesomeDude> > "quote":"hi":["quote"]
15:42:07 <lambdabot>   ["quote","hi","quote"]
15:43:01 * hackagebot lens-family-th 0.1.0.0 - Template Haskell to generate lenses for  lens-family and lens-family-core  http://hackage.haskell.org/package/lens-family-th-0.1.0.0 (DanBurton)
15:44:09 <mrsolo> yes but that is what i have.. essentially i just want prepend and append a string
15:46:18 <MostAwesomeDude> > let wrap s inner = [s, inner, s] in wrap "wrapper" "wrapped"
15:46:19 <lambdabot>   ["wrapper","wrapped","wrapper"]
15:46:42 <MostAwesomeDude> > let wrap s inner = s ++ inner ++ s in wrap " *** " "wrapped"
15:46:44 <lambdabot>   " *** wrapped *** "
15:46:53 <MostAwesomeDude> mrsolo: ^^ either of these?
15:48:21 <mrsolo> sure i can right a function.. so i assume there isn't an existing one; i though i hoggle fu wasn't strong enough
15:48:29 <mrsolo> but thanks anyway :-)
15:49:40 <MostAwesomeDude> Sure.
15:50:16 <merijn> @tell Peaker I'm trying to build Bottle on OSX but the final linking step crashes on some missing symbols related to (it looks like) iconv. I didn't see any messages about missing dependencies/C libraries...did I miss something?
15:50:17 <lambdabot> Consider it noted.
15:53:21 <Lemon> my typechecker right now outputs the following:
15:53:48 <Lemon> > lambda {f x: f x}
15:53:48 <Lemon> parsed = lambda {f x: f x}
15:53:48 <Lemon> sub = fromList [("a",b -> d),("c",b)]
15:53:48 <Lemon> inferred = (lambda {(f :: b -> d) (x :: b): (f :: b -> d) (x :: b) :: d}) :: forall b d: (b -> d) -> b -> d
15:53:49 <lambdabot>   <no location info>: parse error on input `x'
15:54:14 <Lemon> how does Haskell keep its type variables "low"
15:54:36 <Lemon> ?
15:55:08 <Lemon> like, instead of 'b' and 'd' it's just 'a' and 'b'
15:55:27 <Peaker> merijn, can you try cabal update + clean + re-configure ?
15:55:28 <lambdabot> Peaker: You have 3 new messages. '/msg lambdabot @messages' to read them.
15:56:08 <theadmin> Lemon: That's just the definitions -- take a look at the type of "printf" for instance.
15:56:27 <theadmin> Lemon: Meaning to say, they're not always "a" and such, it just depends on how people define stuff :P
15:56:33 <Lemon> :t printf
15:56:34 <lambdabot> forall r. (PrintfType r) => String -> r
15:56:42 <Lemon> ?
15:56:56 <rwbarton> @type \f x -> f x
15:56:57 <lambdabot> forall t t1. (t -> t1) -> t -> t1
15:57:02 <mm_freak> Lemon: http://namebinding.wordpress.com/2009/10/14/i-am-not-a-number-im-a-free-variable/
15:57:38 <geekosaur> Lemon, it uses the types from the actual definition whenever possible, otherwise the type variables it generates itself are ... well, see rwbarton's example
15:58:05 <rwbarton> @type \f g h i -> (f . g, h . i)
15:58:06 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f a -> (a1 -> b1) -> f1 a1 -> (f b, f1 b1)
15:58:30 <theadmin> Lemon: See, "r". Is that what you mean? Like the naming scheme?
15:58:35 <Lemon> oh
15:59:16 <rwbarton> that r comes from an explicit type signature, I think the question is about how GHC assigns type variables to an expression without an explicit type signature
15:59:23 <mm_freak> Lemon: in GHC the original syntax form information is kept, so generated names are somewhat related
15:59:53 <mm_freak> but other than that variables don't necessarily have "names" in the common sense
16:00:24 <theadmin> It's just "something very short" most of the time, for convinience and readability of type sigs
16:00:37 <mm_freak> Lemon: in any case, when implementing typed lambda calculus, see the article i mentioned…  it will save you a lot of work
16:01:58 <Lemon> okay mm_freak thanks
16:02:01 <mm_freak> for example in my type checker i completely remove any name information, but i keep source code position information, so when you get type mismatches, you get reasonable names along with a source code pointer, which proved to be useful
16:02:52 <mm_freak> in my language well-formed expressions never have free variables, which makes this somewhat more reasonable
16:02:54 <theadmin> Speaking of printf, it looks like a function that takes a variable number of arguments... Just how?
16:03:06 <bitonic`> theadmin: type classes, and unsafety
16:03:13 <mm_freak> theadmin: PrintfArg a => String -> a
16:03:17 <mm_freak> 'a' can be a function type
16:03:22 <bitonic`> well, the unsafety is not because of the multiple arguments
16:04:06 <mm_freak> theadmin: you can easily implement a statically typed version of printf using RankNTypes or ExistentialQuantification
16:04:24 <theadmin> mm_freak: Those sound like extensions, are they?
16:04:28 <mm_freak> yes
16:05:03 <Lemon> mm_freak,
16:05:04 <Lemon> > F you
16:05:05 <lambdabot>   Not in scope: data constructor `F'Not in scope: `you'
16:05:16 <Lemon> quite the informal paper, this is
16:05:22 <Peaker> merijn, does a clean re-build have the same result?
16:05:28 <mm_freak> Lemon: ?
16:05:34 <Lemon> mm_freak, the code examples
16:05:38 <Lemon> in the thing you linked
16:06:05 <Twey> hpc: Oh, apparently Yesod provides yesod-markdown for just such an occasion
16:06:11 <mm_freak> Lemon: huh?
16:06:32 <mm_freak> Lemon: i don't know where you got the code sample from, but the article links to this paper:  http://strictlypositive.org/notanum.ps.gz
16:06:32 <Lemon> nevermind
16:06:35 <merijn> Peaker: Lemme go check
16:06:37 <theadmin> Also, I'm looking around ways to define types, I find "data", "type" and "newtype". But how are types like Int defined? They don't seem to have constructors or anything
16:06:59 <Twey> But I have a problem with cabal: installing yesod-markdown for some reason requires a bunch of reinstalls, which breaks a bunch of packages; reinstalling those packages breaks yesod-markdown; reinstalling yesod-markdown breaks them again.  I suspect I don't really understand cabal.
16:07:02 <mm_freak> theadmin:
16:07:04 <mm_freak> @src Int
16:07:05 <lambdabot> data Int = I# Int#
16:07:09 <mm_freak> Int# is a primitive type
16:07:11 <Lemon> mm_freak, the code examples in the paper have "F you" and "B this" and "B that"
16:07:19 <Lemon> which I think is intentional
16:07:23 <geekosaur> theadmin, Int has constructors, you just dont see them normally because of an evil trick (numeric constants are secretly function calls!  specifically fromIntegral or fromRational)
16:07:25 <mm_freak> you can think of it like:  data Int# = 0# | 1# | 2# | 3# | …
16:07:51 <ben> mm_freak: ok, how is Double# defined? :)
16:08:04 <mm_freak> Lemon: ah, yes, but i doubt that that was intentional =)
16:08:04 * ski . o O ( `data Int# :: # = 0# | 1# | 2# | 3# | …' )
16:08:12 <Peaker> Radix, Mantissa?
16:08:16 <merijn> ben: Well, that's finite so you could enumerate it in theory... :p
16:08:27 <geekosaur> @src Double
16:08:28 <lambdabot> data Double = D# Double#
16:08:32 <theadmin> mm_freak: That'd be Word :P Int is more of like ... -999, -998, -997, -996, ..., 0, 1, 2, 3, ... But I see, I get the point.
16:08:35 <ben> I suppose :V
16:08:53 <geekosaur> also note
16:08:55 <geekosaur> @src Integer
16:08:56 <lambdabot> data Integer = S# Int#
16:08:56 <lambdabot>              | J# Int# ByteArray#
16:08:56 <Tomsik> data Integer# = #0 | #1 | ... | #omega
16:09:04 <mm_freak> ben: data Double# = (# IntX#, IntY# #) | NaN# | PlusInf# | MinusInf# | …
16:09:04 <theadmin> ...omega?
16:09:15 <parcs`> i think it's more reasonable to say that Int# is opaque
16:09:24 <geekosaur> they should all be considered opaque
16:09:29 <mm_freak> anyway, that's just a mental model
16:09:42 <Tomsik> theadmin, the ordinal number
16:09:46 <mm_freak> in actuality the primitive types are defined by the primitive operations on them
16:09:51 <geekosaur> see Integer above; the J# bigint type is an opaque bytearray with a size
16:10:03 <mm_freak> and pattern-matching is implemented by primitive equality
16:10:09 <geekosaur> best not to worry about any of it, let the compiler deal, that's its job :)
16:10:24 <bitonic`> the least infinite ordinal? anyway not really Integer is bounded as well!
16:11:40 <bitonic> every number on a finite computer will be bounded anyway. annoying.
16:11:45 <merijn> Peaker: Ah, now it fails on keyvaluehash being missing and that it can't install due to constraints on base. Joy!
16:12:02 <Peaker> merijn, oooh, sorry about that, let me check
16:12:26 <merijn> Maybe one of the old dependencies of the previous attempt messing up the constraints?
16:12:32 <ski> ben : perhaps something like `data Double# :: # = D# {sign# :: Word1#,mantissa# :: Word52#,exponent# :: Int11#}' ?
16:13:03 <ben> :D
16:13:28 <bitonic> I like Word1
16:13:52 <Peaker> merijn, how I hate the PVP
16:14:15 <Peaker> merijn, and it encouraging me to put a strict limit on my base dependency
16:14:23 <mm_freak> bitonic: Integer isn't bounded, but the machine may not be able to execute the program
16:14:25 <Peaker> (which is virtually always too strict)
16:14:28 <merijn> Peaker: :p
16:14:42 <Peaker> merijn, try to cabal-update
16:14:46 <geekosaur> Peaker, it used to be that people were encouraged to not put limits on their packages
16:14:53 <Peaker> merijn, and clean/config/reinstall
16:14:59 <ski> bitonic : yeah, but not inherently bounded. just bounded by available resources (and the implementation)
16:15:00 <geekosaur> Peaker, then came bytestring in base and the whole ****ing world broke badly
16:15:06 <bitonic> mm_freak: it is
16:15:37 <geekosaur> you can still see workarounds for this in lots of packages, and suddenly setting upper limits on base was a Thing because major version changes were demonstrated to be potentially quite fatal
16:15:43 <Peaker> geekosaur, if we had the constraints, they'd be just as ***'d, but with a less suggestive cabal err
16:15:49 <bitonic> at least, Integer as it is in GHC (gmp)
16:16:02 <Peaker> geekosaur, you can't have multiple base versions installed anyway
16:16:09 <geekosaur> yes you can, in some cases
16:16:14 <Peaker> geekosaur, how?
16:16:19 <geekosaur> at least one ghc version came with multiple versions of base
16:16:24 <mm_freak> bitonic: by definition Integer either works or crashes the machine because it runs out of resources…  put differently, the possible number of GMP limbs will always be greater than the amount of memory the machine could possibly provide
16:16:28 <geekosaur> it's up to the *compiler* to do it, though
16:16:36 <geekosaur> *you* cannot do it
16:16:39 <Peaker> geekosaur, ah, still, it is much easier to fix an import issue than an opaque version err from cabal
16:17:18 <Peaker> geekosaur, every time cabal fails the simple fix is to remove upper constraints
16:17:27 <mm_freak> bitonic: in other words, Integer will never deliver wrong results…  it's not bounded in the same sense as Int or Word
16:17:42 <merijn> Peaker: Lots of compile text seems to be flying by, so that's a good sign
16:18:11 <Peaker> merijn, yay, removed more PVP baggage
16:18:16 <bitonic> mm_freak: sorry, I disconnected. I only got the conclusion
16:18:22 <Lemon> should polymorphic types and monomorphic types have different kinds?
16:18:32 <ski> bitonic : well, that's just an implementation fault then (not an error, a fault)
16:18:34 <Lemon> are there any systems in which that's a thing?
16:19:06 <bitonic> ski: well but it turns out that it's very hard to implement truly unbounded bignums, I forgot the details
16:19:08 <geekosaur> Peaker: there are in fact good reasons why not only cabal but just about every other packaging system in existence (except possibly stuff like homebrew which similarly knows that Everyone Else Is Wrong(tm)) has a versioning policy similar to the PVP
16:19:10 <merijn> Peaker: Aww...still dies
16:19:12 <geekosaur> really.  go look
16:19:22 <palmfrond> is "is" a verb?
16:19:26 <geekosaur> I'd wait but you'll just tell me how Everyone Else Is Wrong too
16:19:38 <hpaste> merijn pasted “Link error” at http://hpaste.org/71026
16:19:53 <Peaker> geekosaur, apt-cache show xchat (random pkg) shows no upper constraints
16:19:55 <geekosaur> the haskell community used to think like you do, that Everyone Else Is Wrong
16:19:56 <mm_freak> bitonic: by definition Integer either works or crashes the machine because it runs out of resources…  put differently, the possible number of GMP limbs will always be greater than the amount of memory the machine could possibly provide
16:20:05 <mm_freak> that was the reasoning
16:20:12 <Peaker> geekosaur, everything has only lower version constraints
16:20:27 <Peaker> merijn, what's the exact error?
16:20:34 <bitonic> mm_freak: that's fair enough, ok. but it is theoretically bounded
16:20:39 <merijn> Peaker: Just pasted it: http://hpaste.org/71026
16:20:52 <mm_freak> bitonic: exactly the opposite…  it's practically bounded
16:20:55 <geekosaur> Peaker, most of the limits there are on the way shared objects work, you probably can't see those but they're partly enforced by ld-linux.so
16:21:15 <geekosaur> in particular:  major number MUST match, minor must be >=
16:21:19 <bitonic> mm_freak: no I mean, there is a bound on the numbers that GMP can store. But that bound will not be reached in practice
16:21:36 <mm_freak> bitonic: yeah, and that bound is an implementation detail
16:21:45 <mm_freak> it must never be exposed as an actual bound
16:21:51 <bitonic> yeah.
16:22:06 <ski>   "Any Prolog implementation should support at least 16-bit integers.  C Prolog's 29 bits has proven adequate for most purposes so far, and the same is true of Prolog-X's and NIP's 24 bits.  However, when bignums (indistinguishable from small integers) are not available, integer overflow should be signalled as a fault."
16:22:11 <ski>   "(Not as an @i<error>, the program has a perfectly good meaning, but as a @i<fault>, the implementation isn't good enough to run the program.)"
16:22:15 <ski>   -- "Draft Prolog standard" by Richard A. O'Keefe in 1984-07-23 at <http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/doc/standard/okeefe.txt>
16:22:19 <mm_freak> when that happens i wouldn't even call it an overflow…  i'd call it a bug
16:22:28 <Peaker> geekosaur, I think the version number stuff is in general a hack (the right thing  is signature based) and breakage due to build err is actually preferrable to opaque version err.. also the vast majority of potentially-breaking changes do not break
16:22:34 * geekosaur not going to discuss it any more, go argue it with the world.  or learn some history
16:22:43 <ski> bitonic ^
16:22:59 <Peaker> geekosaur, and of course you will find examples of breakage due to these changes -- but the dep. hell everyone experiences with cabal-install is a stronger data point
16:23:06 * hackagebot keyvaluehash 0.3.0.1 - Pure Haskell key/value store implementation  http://hackage.haskell.org/package/keyvaluehash-0.3.0.1 (EyalLotem)
16:23:19 <Peaker> if the PVP worked well, that'd be one thing. But it works horribly
16:23:40 <bitonic> ski: OK. All I was saying is that there is a theoretical bound for GMP, which I find amusing.
16:23:49 <mm_freak> btw, for debugging purposes isn't there something better than printf?
16:24:05 <Peaker> merijn, weird, I don't know what these symbols are or how they get used
16:24:28 <mm_freak> is Doc suitably lightweight to be useful for debugging?  i'm sick of writing those type signatures for printf
16:24:35 <Peaker> mm_freak, I use some convenience wrappers around Debug.Trace
16:24:45 <mm_freak> ah, no…  it should actually have IO semantics
16:24:58 <Peaker> oh, what do you mean by "debugging"?
16:25:00 <geekosaur> merijn, do you have macports installed on your system?
16:25:02 <Peaker> logging?
16:25:11 <merijn> geekosaur: Yes
16:25:28 <mm_freak> Peaker: in my FRP implementation i have a testWire function that runs the reactive system and continuously prints its result in one line
16:25:29 <geekosaur> the ghc runtie depends on iconv, and macports' iconv is not compatible with Apple's (because Apple's is ancient)
16:25:41 <Peaker> geekosaur, also, it's fine if you prefer not to discuss something.. but to me you came across as condescending/patronizing while you did so
16:25:54 <mm_freak> Peaker: testWire takes a reactive system that outputs a String signal
16:25:58 <geekosaur> you may need to move macports out of the way temporarily or find a way to make it see the system one first
16:26:20 <ski> Peaker : iiuc, the important part here is noting somehow when you make backward-incompatible changes
16:26:24 <paulh_> Consider the definition: type Nat = forall a. (a -> a) -> ( a -> a). How would you prove/argue that every "well-behaved" member of Nat is an iteration?
16:26:26 <geekosaur> Peaker, had it occurred to you that a "I know better, why are you forcing this stuff on me?" might possibly also be considered condescending?
16:26:40 <mm_freak> i like the tangible values approach
16:26:46 <merijn> geekosaur: Wouldn't I need to know which cabal package is actually linking it in?
16:26:57 <Peaker> ski, the problem is backwards-incompatible changes are a relation between 2 packages rather than a change in a single one. most potentially breaking changes will not cause breakage
16:27:03 <merijn> Also, I haven't had any compile errors before...
16:27:09 <geekosaur> merijn, it's not a cabal package.  the error references libHSbase which is the GHC runtime
16:27:16 <Peaker> geekosaur, I attacked the concept, you attacked me personally
16:27:33 <ski> Peaker : yes. i suppose normally one thinks of it as breakage between previous version and next version
16:27:40 <merijn> geekosaur: Shouldn't that stop all my haskell code from linkin succesfully?
16:27:56 <Peaker> ski, no, I mean that if you change one rarely used definition out of 10000 it is potentially breaking
16:28:06 <Peaker> ski, but maybe 1% of your dependents use that definition
16:28:39 <geekosaur> merijn, often it does.  I don't know what specifically drags in the dependency
16:29:04 <ski> Peaker : yes, of course it would be nice to have a more fine-grained system, which can check that among the features you actually *use*, whether there's any backward-incompatible changes, when switching to the next version
16:29:09 <Peaker> ski, also, the overly-zealos constraints bring breakage too in practice (conflicting constraints when trying to build a composition), butterfly issues, etc..
16:29:17 <geekosaur> merijn, libHSbase is not a monolith that is 100% linked into every program, it is an archive from which entries are linked as needed.  some things pull in the iconv part, some don't
16:29:33 <ski> Peaker : and then there's the complication of bug-fixes, bug-work-arounds, and things depending on the bug
16:29:34 <Peaker> ski, yeah, until there is, I think the every-potential-breakage-is-breakage assumption is more harm than good
16:29:41 <merijn> geekosaur: So how would I temporarily move the one from macports without breaking everything?
16:30:37 <Peaker> ski, because IME the majority of small backwards-incompatible changes are not troublesome or cause little trouble (e.g: fixing an import name) whereas the conflicting version constraints are hellish to work through
16:30:38 <ski> Peaker : possibly. i don't have enough experience to judge
16:31:29 <geekosaur> tbh I'm not sure how to do it properly.  I have simply done a "sudo mv /opt/{local,hold}; ghc ... ; sudo mv /opt/{hold,local}" when necessary, but that isn't always enough (since it may then load the wrong iconv library at runtime)
16:31:53 * merijn is sad
16:32:03 <geekosaur> better would be to find where the -liconv is done and make it use a full path to the system one
16:32:24 <ski> Peaker : maybe you should talk to dcoutts (or whoever thought up the PVP)
16:32:38 * geekosaur rather wishes macports had found a better solution to -liconv since it's one of the things that *always* causes issues like this :(
16:34:09 <Peaker> ski, I did.. he thinks that version refusals (false negs) are far better than build failures (false pos) and we simply disagree on that
16:34:37 <ski> in the general case, i'd agree with that
16:34:39 <Peaker> ski, but we all agree something more elaborate than version ranges would be awesome
16:35:01 <Peaker> ski, for end users that might be. I think for bleeding edge developers, false positives are far better
16:35:15 <ski> in case the vast majority of signalled breakage is no actual breakage -- perhaps not, in the short term (until we get something better)
16:35:19 <merijn> How can I tell cabal/ghc which library to use? Finding the system library is simple
16:35:56 <Peaker> ski, IME since disabling upper constraints fixes almost all of the breakage I encounter with cabal, I'd say that's the case (most breakage is not actual)
16:37:09 <ski> Peaker : i'd think the worry here is that doing this, you might forget to look into cases which actually cause breakage, and you might not notice yourself
16:37:28 <ski> (i have no idea how common this would be)
16:38:25 <Peaker> another really helpful possibility: specify version ranges after-the-fact
16:38:55 <Peaker> so users can report their successes/failures with various versions and build reliable information
16:39:17 <ski> aye
16:39:46 <geekosaur> merijn, the iconv dependency is in the package.conf entry for base; I'm not sure how you change it exactly though if you want to substitute a full path
16:39:58 <ski> (but it would need some way of assigning blame, so that the right package is blamed)
16:41:44 <geekosaur> looks a lot like a cabal file, in fact, so I suspect the cabal documentatuin is where to look
16:42:05 <geekosaur> I may get to find out directly at some point but right now my ability to build software is somewhat impaired
16:42:53 <Twey> http://hpaste.org/71027 — I don't understand this error.  Why is cabal trying to reinstall all these packages, and why would reinstalling them break things?
16:43:07 <Twey> I just want to install yesod-markdown :þ
16:43:15 <hpc> Twey: you install bar, it depends on foo 1.1
16:43:19 <startling> can I use hex escapes somehow in strings?
16:43:21 <hpc> you install baz, depends on foo 1.2
16:43:32 <hpc> now you need quux, which depends on bar and baz
16:43:42 <hpc> you now depend on foo 1.1 and foo 1.2
16:43:57 <mm_freak> Twey: my personal recommendation is to depend on pandoc directly…  yesod-markdown is convenient, but also caused me quite some headache
16:44:10 <merijn> Peaker: oh well, I'll wrestle with the iconv linking tomorrow and let you know what happens. Right now it's time for bed
16:44:11 <Twey> hpc: Oh… so it's a package issue?
16:44:19 <hpc> @where sicp
16:44:20 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
16:44:20 <lambdabot> classes/6.001/abelson-sussman-lectures/>
16:44:20 <Peaker> merijn, thanks, night!
16:44:22 <Twey> mm_freak: And reimplement yesod-markdown?  (or bundle it?)
16:44:24 <hpc> hmm
16:44:36 <mm_freak> Twey: reimplement it…  it's not a lot of work
16:44:50 <hpc> Twey: it's an "it won't likely work if you force it" issue
16:45:01 <Twey> hpc: I forced it.  It didn't work.  :þ
16:45:04 <hpc> because you get code from two different versions of the same package interfering with each other
16:45:38 <Twey> Hmm
16:45:47 <Twey> I wonder if it actually does depend on that
16:45:51 <monochrom> Twey, see my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon for why cabal-install sometimes rebuilds existing packages and what's wrong with it. in fact, read the whole article
16:46:31 <hpc> monochrom: oh, that's the link
16:46:36 <hpc> is that in @where?
16:46:39 <Twey> I don't see why Pandoc doesn't just allow me to tell the reader or writer to ignore/escape raw HTML
16:46:43 <Twey> Thanks
16:47:18 <geekosaur> Twey, perhaps because it's being strict about the markdown spec?  which says that HTML is passed through
16:47:33 <monochrom> in fact, precisely that section was the last straw that caused the current cabal-install to stop and give a warning. previous versions just went ahead breaking things
16:49:01 <donri> Twey: sundown package can do that for markdown
16:49:40 <monochrom> interesting, "blaze-html-0.5.0.0 -> 0.4.3.4", something is being downgraded!
16:49:42 <Twey> geekosaur: It's not — it makes lots of extensions to Markdown
16:49:46 <Twey> donri: Ooh
16:49:50 <mm_freak> Twey: it does
16:50:01 <mm_freak> Twey: IIRC that's the stateParseRaw option
16:50:07 <mm_freak> see ParserState
16:50:26 <Twey> mm_freak: Ah!
16:50:30 <Twey> It's in the ParserState!
16:50:51 <mm_freak> yeah, it's a bit unfortunately names as it also includes parser configuration along with the parser state
16:51:36 <mm_freak> all the command line flags that the 'pandoc' binary takes can be found in ParserState and WriterOptions
16:51:42 <Twey> Alright then!  That makes everything easier :þ
16:51:55 <mm_freak> names → named
16:56:16 <kallisti> test
16:56:27 <kallisti> test
16:56:41 <monochrom> passed
16:56:43 <monochrom> passed
16:56:48 <pnkbst> hearing an echo in here
16:56:50 <pnkbst> hearing an echo in here
16:57:02 <kallisti> test
16:57:09 <MostAwesomeDude> ...
16:57:15 <monochrom> use @botsnack for a real test
16:57:27 <Tomsik> @botsnack
16:57:27 <lambdabot> :)
17:02:06 <Twey> mm_freak: Hmph… unfortunately it doesn't seem to do anything.  A <script> in my form is still passed through to the page, even if I set stateParseRaw = False.  Maybe True just means that Pandoc converts *known* HTML tags into Pandoc tags.
17:02:34 <Twey> I don't want to use sundown… it's a C library ☹
17:08:26 <mm_freak> Twey: i see…  well, then i'm afraid the best you can do is to sanitize the resulting HTML
17:08:47 <mm_freak> or get in touch with the pandoc developers…  i'd love that feature, too
17:09:29 <Twey> Sanitizing the resulting HTML doesn't work because that will escape all the Markdown formatting
17:09:35 <Twey> I think sanitizing the *input* is the way to go
17:09:49 <Twey> Then passing the HTML through raw
17:09:53 <mm_freak> yesod has this nic editor form field, which automatically santizies HTML to include only a limited set of allowed elements
17:09:58 <mm_freak> just see how it does that
17:10:12 <Twey> There's a package xss-sanitize that should do the job
17:10:22 <Twey> I just didn't want to add the extra pass :-\
17:10:59 <mm_freak> i totally understand…  should be a feature request (or perhaps even a bug report) for pandoc
17:12:05 <mm_freak> this is odd though…  i'm very sure that i have already done that with pandoc
17:12:48 <Twey> I'm surprised that stateParseRaw exists if it does what I think it does — it doesn't seem very useful
17:22:17 <shapr> kallisti: or use @echo
17:22:40 <kallisti> hi
17:22:49 <shapr> HI KALLISTI
17:22:54 * shapr has energies
17:24:29 <kallisti> I'm currently working on a irssi script for logging raws.
17:24:40 <megajosh2> Hey, has anybody ever gotten the curl package to work on Windows?
17:24:51 <megajosh2> I tried last year or so and gave up out of frustration
17:25:01 <megajosh2> and I'm just wondering if there's a living soul who's ever accomplished it
17:27:04 <m3ga> megajosh2: is there anything the curl package can do that can't be done by http-conduit?
17:27:40 <megajosh2> Wel, it can keep me from using like 15 different packages when I only want to make... a single request once in a while in my application
17:28:00 <megajosh2> but other than that I guess not
17:28:01 <megajosh2> Oh
17:28:08 <megajosh2> and tls doesn't work fully on Windows
17:28:14 <megajosh2> Which is what http-conduit uses
17:29:10 <m3ga> oh, ok. some time ago i tried the curl bindings and found them a real pain to use. i now use http-conduit instead, but i'm on linux.
17:29:19 <megajosh2> yeah
17:29:32 <megajosh2> the curl package even necessitates running a configure script
17:29:45 <megajosh2> Seems pretty Unix dependent indeed
17:29:45 <m3ga> is there an open bug somewhere for the tls windows issue?
17:29:59 <megajosh2> I'm not sure, but the package maker has fully acknowledged it
17:30:06 <shapr> megajosh2: What about cygwin?
17:30:21 <megajosh2> Oh I used MS-SYS to try and install it
17:30:35 <HugoDaniel> hi
17:30:42 <megajosh2> Which I assume will allow me to do it just the same
17:31:08 <megajosh2> Maybe I should try again with Cygwin instead or something?
17:31:46 <saml> hi HugoDaniel
17:39:14 <Twey> mm_freak: https://github.com/jgm/pandoc/issues/556
17:41:11 <saml> hey, for fizzbuzz, do I do   data Number = Just Int | Fizz | Buzz | FizzBuzz ?
17:41:25 <saml> how can I write proofs for Number so that it's fizzbuzz complete?
17:41:36 <saml> do i need GADT?
17:48:05 <whittle> I know that if I have (f :: a -> Maybe a) and (v :: Maybe String), I can (v >>= f). But how can I bind (f' :: m a -> m (Maybe a)) with (v' :: m (Maybe String))?
17:49:08 <saml> fmap?
17:49:57 <BMeph> sequenceA? :)
17:52:18 <whittle> BMeph: I don’t see how I would use sequenceA.
17:53:10 <BMeph> whittle: Okay, traverse, then.
17:55:59 <BMeph> 'fmap join' should work, as well. :)
17:56:07 <BMeph> :t fmap join
17:56:08 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f) => f (m (m a)) -> f (m a)
17:57:16 <BMeph> Where m is Maybe, and f is m...er, so-to-speak. :)
17:59:47 <rwbarton> i would guess whittle meant f :: String -> Maybe String though
18:00:14 <whittle> rwbarton: No, f has a type variable.
18:00:26 <rwbarton> so which is it, f = Just or f = const Nothing :P
18:00:35 <rwbarton> use that to simplify
18:00:50 <rwbarton> anyways my point is there are two ways you can combine your original f and v
18:01:38 <rwbarton> join (f v) vs. v >>= f
18:01:52 <rwbarton> if f is really polymorphic, they are the same by parametricity
18:02:10 <whittle> :t join
18:02:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:02:21 <rwbarton> do you intend to use f with a = String or with a = Maybe String?
18:02:33 <rwbarton> String I guess because you wrote v >>= f
18:02:37 <whittle> a :: String
18:02:40 <whittle> rwbarton: Yes.
18:02:59 <rwbarton> fmap join (f' v') is using f' with a = Maybe String though
18:03:19 <rwbarton> so I think that is not what you want
18:03:56 <whittle> It seems like I want something like mapM from Data.Traversable.
18:04:14 <rwbarton> @type Data.Traversable.mapM
18:04:16 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
18:08:36 <whittle> BMeph: I think I don’t understand your fmap join solution well enough to implement it.
18:08:58 <whittle> How would I get something of type f (m (m a))?
18:12:06 <BMeph> whittle: v' >>= f'
18:13:11 * hackagebot dvi-processing 0.3 - Read/write DVI and TFM file  http://hackage.haskell.org/package/dvi-processing-0.3 (AaronBlack)
18:15:44 <whittle> v' >>= f' gives a mismatched type error.
18:15:45 <rwbarton> I think you can't do this at all, at least not in the way you intend
18:15:52 <whittle> rwbarton: Okay.
18:16:10 <whittle> Am I trying to break monads?
18:16:18 <rwbarton> like even if you just try to write it by hand, there's no sensible thing to do
18:16:24 * zachk wants to see what whittle is trying to do
18:17:05 <rwbarton> unless you plan on just passing f' an m-action of the form "return x"
18:17:18 <whittle> My original question was: I know that if I have (f :: a -> Maybe a) and (v :: Maybe String), I can (v >>= f). But how can I bind (f' :: m a -> m (Maybe a)) with (v' :: m (Maybe String))?
18:18:08 <rwbarton> I think you're focusing too much on the types and not thinking enough about what you actually want to do... this is a frequent thing I see
18:18:16 <whittle> Okay.
18:18:43 <BMeph> whittle: Yes, my bad. It's just f' v' :: m (Maybe (Maybe a))
18:19:22 <rwbarton> ^ yes and you can still do this, with a = Maybe string
18:19:23 <rwbarton> *String
18:20:03 <rwbarton> (that is f's "a", BMeph's "a" is String)
18:20:06 <BMeph> whittle, Specifically, fmap join (f' v')
18:20:20 <whittle> BMeph: Yes, thank you. I got that to compile.
18:21:15 <cocon> hmmm, under my emacs 'haskell-hoogle' used to open a web browser. now it just gives me a buffer with a list of types :(
18:22:22 <whittle> BMeph: In your solution, fmap lifts over m, and join collapses the Maybes?
18:23:02 <BMeph> whittle: Exactly. :)
18:25:10 <whittle> BMeph, rwbarton: Thank you for your help. I keep thinking that I’m starting to grasp functors and monads, but combining more than one of them still makes my head spin.
18:25:46 <shachaf> So don't do it.
18:25:54 <shachaf> Just write everything out explicitly.
18:26:02 <shachaf> You can abstract it into monad operations later.
18:27:33 <whittle> shachaf: I don’t really know what you mean by writing everything out explicitly. I don’t know how to handle a monad inside a functor more explicitly.
18:27:44 <whittle> shachaf: Do you mean by doing more pattern-matching?
18:27:50 <shachaf> Sure.
18:27:59 <shachaf> You have a Maybe. That's a concrete thing. Pattern-match on the Maybe.
18:28:22 * zachk recollects a college text titled: "Concrete Abstractions"
18:28:28 <shachaf> You have "m foo -> m bar". You can concretely write out the function using do-notation, make it work, and then see what the patterns that you can abstract are.
18:29:01 <whittle> Ah. I think that’s what rwbarton suggested earlier, but I was too dense to understand it.
18:33:50 <whittle> Speaking of patterns, I keep writing functions that look like "do { a <- f; b <- g; return $ C a b }". Is that common enough to have a simpler form?
18:34:42 <whittle> I feel like the answer involves Arrows, which I am still working up to.
18:34:47 <Tomsik> :t do { a <- f; b <- g; return $ C a b }
18:34:49 <lambdabot> Not in scope: data constructor `C'
18:34:59 <Tomsik> :t \h -> do { a <- f; b <- g; return $ h a b }
18:35:00 <lambdabot> forall t t1 a (m :: * -> *). (SimpleReflect.FromExpr (m t), Monad m, SimpleReflect.FromExpr (m t1)) => (t -> t1 -> a) -> m a
18:35:13 <Tomsik> err
18:35:58 <Tomsik> :t (&&&)
18:36:00 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:36:17 <Tomsik> actually, isn't that something along lines
18:36:23 <Tomsik> :t fmap uncarry
18:36:25 <lambdabot> Not in scope: `uncarry'
18:36:28 <Tomsik> :t fmap uncurry
18:36:29 <lambdabot> forall a b c (f :: * -> *). (Functor f) => f (a -> b -> c) -> f ((a, b) -> c)
18:36:51 <Tomsik> :t \f g -> fmap uncurry <*> (f,g)
18:36:53 <lambdabot>     Couldn't match expected type `(a1 -> a -> b -> c) -> a1'
18:36:53 <lambdabot>            against inferred type `(t, t1)'
18:36:53 <lambdabot>     In the second argument of `(<*>)', namely `(f, g)'
18:37:09 <Tomsik> :t \f g -> (fmap uncurry) <*> (f,g)
18:37:11 <lambdabot>     Couldn't match expected type `(a1 -> a -> b -> c) -> a1'
18:37:11 <lambdabot>            against inferred type `(t, t1)'
18:37:11 <lambdabot>     In the second argument of `(<*>)', namely `(f, g)'
18:37:57 <Tomsik> :t (<*>)
18:37:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:38:16 <Tomsik> :t \f g -> (fmap uncurry) <*> return (f, g)
18:38:18 <lambdabot> forall a b c t t1. t -> t1 -> ((t, t1) -> a -> b -> c) -> (a, b) -> c
18:39:06 <Tomsik> I feel that I've just spammed the channel for nothing. Sorry about that.
18:39:31 <applicative> whittle, liftM2 C f g
18:39:50 <applicative> or C <$> f <*> g
18:40:00 <Tomsik> ;_;
18:40:09 <whittle> applicative: You’re as good as your name.
18:40:47 <applicative> name  is better
18:41:15 <applicative> or use MonadComprehensions for true madness
18:47:12 <whittle> Thank you all very much. I have a great deal to learn.
18:58:01 <Nereid> MonadComprehensions is new to me. cool.
19:01:31 * BMeph quips: Haskell - where everything old is new again!
19:02:22 <Axman6> GHC 7.8: now with n+k patterns!
19:04:49 <sully> n+k patterns came back?
19:04:53 <sully> oh, no, it is a joke
19:30:05 <tippenein> getting Warning: haddock-interfaces: /usr/share/doc/haskell... blah blah when trying to get haskell-src-exts   -- anyone have this problem or should I ask somewhere else?
19:30:52 <tippenein> it's complaining that the file doesn't exist or isn't a directory.. but seems to break every haskell package I try to get
19:31:04 <tippenein> might be a package manager error though
19:32:17 <monochrom> that should be a non-error warning and can be ignored unless you want docs
19:32:53 <monochrom> certainly doesn't affect compiling and executing
20:00:21 <zachk> shake it jellybaby1 shake it :D
20:01:04 <Lemon> oh man check it out
20:01:05 <Lemon> https://gist.github.com/3064098
20:01:18 <Lemon> two questions:
20:01:49 <Lemon> getting rid of extraneous substitutions, by removing mappings from variables that aren't free in the environment, won't mess up the algorithm elsewhere, right?
20:02:57 <Lemon> should the type annotation for the left term in a function application be kept polymorphic, or should its polymorphic variables be "lifted" outwards into the type of the entire term?
20:05:10 <favonia> Hi I have a question about strictness analyness and FFI... shouldn't the function imported by "#foreign import" be strict in every argument?
20:06:19 <favonia> dumped the interface files and I found lots of L's (lazy) in strictness...
20:15:05 <parcs`> favonia: i don't see the point. all the arguments are going to get serialized (forced) right away anyway
20:19:32 <favonia> parcs`: but GHC could potentially avoid the overhead of "thunk" in some cases from the very beginning. Yes all arguments will be serialized, and so the strictness analyzer failed in this case.
20:21:41 <parcs`> ah okay
20:22:10 <parcs`> that sounds like a good question for the ghc-users mailing list
20:22:22 <parcs`> er, glasgow-haskell-users
20:23:51 <favonia> parcs`: I am not sure where to go so I am asking here. let me start the thread. :)
20:25:13 <favonia> (actually I was thinking of a feature request on trac)
20:35:21 <parcs`> favonia: hmm, are the ffi calls marked safe or unsafe?
20:35:40 <parcs`> er, ffi bindings
20:35:47 <favonia> they're marked safe in my usage
20:36:18 <favonia> I dare not try the danger zone (yet) ;)
20:36:30 <parcs`> maybe that has something to do with it
20:36:34 <favonia> hmm
20:40:49 <realitygrill> at what point do you become an intermediate haskeller?
20:40:52 <realitygrill> seems so far away..
20:41:02 <favonia> parcs`: that doesn't seem to help (if I am testing it correctly)
20:42:28 <favonia> parcs`: for "foreign import ccall unsafe "sin" sin' :: CDouble -> CDouble" I still get "Strictness: U(L)"
20:44:55 <parcs`> favonia: how do you dump the interface file with strictness?
20:45:19 <favonia> parcs`: ghc --show-iface FFIStrict.hi
20:47:09 <mikeplus64> talking with someone, does ghc have "a GC with real time guarantees"
20:47:13 <mikeplus64> ?
20:52:59 <parcs`> favonia: what does U(L) mean?
20:53:19 <favonia> parcs`: Unpackable(Lazy)
20:53:53 <amop> is there an acid-state or ixset channel on this server?
20:55:03 <donri> amop: #happs works
20:55:14 <CSWookie> I forget, did I say something about needing help understanding indentation?  If I didn't, I do.
20:55:16 <donri> or #haskell for that matter
20:55:19 <amop> ixset question: i've built a couple indexes using ixFun, but my queries using @= are only using the first one.
20:55:34 <donri> CSWookie: shoot
20:55:45 <donri> amop: show code
20:55:46 <donri> @hpaste
20:55:47 <lambdabot> Haskell pastebin: http://hpaste.org/
20:57:24 <donri> CSWookie: please ask in the channel rather than in private
20:57:27 <favonia> parcs`: http://www.haskell.org/ghc/docs/latest/html/users_guide/faster.html
20:57:34 <donri> CSWookie: you can indent function arguments just fine
20:58:39 <CSWookie> pardon, donri.  I just started using the webchat and thought red meant private.
20:58:58 <donri> nope :) it means someone mentioned your nickname
21:02:12 <hpaste> CSWookie pasted “indent help” at http://hpaste.org/71032
21:02:12 <hpaste> CSWookie pasted “indent help” at http://hpaste.org/71033
21:03:06 <palmfrond> anyone else from hawaii? (oahu)
21:03:13 <CSWookie> Wow.  I've evidently done a lot to offend the linter...
21:03:59 <blackdog> palmfrond: dysinger is
21:04:10 <blackdog> oh, he doesn't hang out here, that's right.
21:04:16 <palmfrond> which chan is he in?
21:04:27 <blackdog> @dysinger on twitter.
21:04:27 <lambdabot> Unknown command, try @list
21:04:37 <donri> CSWookie: the indentation doesn't make the lines into separate arguments though, so add appropriate parenthesis
21:04:47 <blackdog> he'd be chuffed to know there are other hawaiian haskellers tohugh :)
21:05:15 <CSWookie> blackdog: Is chuffed good or bad?
21:05:36 <palmfrond> nah i'm interested in irc hawaiians
21:06:28 <blackdog> CSWookie: chuffed is bonza.
21:06:44 * blackdog is unhelpful :)
21:07:20 <blackdog> but yes, chuffed = pleased
21:07:22 <CSWookie> blackdog: The only person I've ever heard say bonza was Monterey Jack.
21:07:35 <CSWookie> He say it like it was a good thing.
21:07:43 <blackdog> it is a good thing
21:07:49 <blackdog> old australian slang.
21:08:01 <blackdog> too right mate, stone the crows etc
21:08:48 <CSWookie> I wish Hoosiers had cool slang :(
21:14:05 <amop> hpaste.org/71034
21:16:02 <blackdog> CSWookie: the problem with american slang is that everyone with a tv or internet access has heard it already.
21:16:19 <MostAwesomeDude> blackdog: Not necessarily.
21:16:32 <MostAwesomeDude> I was having fun explaining to some British pals what "ghost riding the whip" is.
21:16:49 <blackdog> i thought ghost riding was getting out of a moving car...
21:17:07 <blackdog> i almost don't want to know what it actually means, it's beautiful in its inscrutability
21:18:56 <CSWookie> Maybe it's what the guy that tells the guy who gives a political party it's marching orders does.
21:19:07 <CSWookie> Is that what it is MostAwesomeDude ?
21:20:45 <edwardk> preflex: xseen roconnor
21:20:45 <preflex>  roconnor was last seen on freenode/#haskell 7 hours, 41 minutes and 52 seconds ago, saying: I sequenced my DNA and I found a bitmap of an alien crashlanded in a dutch farm field.
21:21:33 <Gavilan> Does anyone has any idea/suggestion of an interesting, complex and difficult software design problem (or domain) to solve/model as an exercise/example? yet small in scope? which uses only "common" knowledge?
21:27:38 <CSWookie> Huh.  I've put it all on one line and it still complains
21:27:58 <CSWookie> ghci does fine with it.
21:29:53 <hpaste> CSWookie pasted “indent help 2” at http://hpaste.org/71035
21:34:44 <hpaste> donri annotated “indent help 2” with “indent help 2 (annotation)” at http://hpaste.org/71035#a71036
21:36:30 <donri> CSWookie: also, you realize takeWhile (<1000) [1..] == [1..999]?
21:37:31 <donri> uh, ignore me, sleep deprived ^_^
21:42:26 <CSWookie> When I tried using union infix, first it complained about union being out of scope.  I changed it to List.union, and I got I huge mess of error.
21:46:02 <edwardk> @ask roconnor why is there a separate mkLenses for Lens.Family2? to get the type alias in the signature?
21:46:03 <lambdabot> Consider it noted.
21:48:06 <donri> edwardk: mkLenses isn't roconnor's code
21:48:19 <edwardk> donri: in Lens.Family2.TH
21:48:30 <donri> yea, that's dan burton
21:48:38 <geekosaur> at a guess, you didn't parenthesize enough when you tried to infix.  I must also point out that "List" is an obsolete module; it should be Data.List,
21:48:57 <edwardk> ah
21:50:55 <edwardk> ok, the question still stands then ;)
21:51:02 <CSWookie> geekosaur: It seems like I've got about everything in there parenthesized...  Is there a better way to get all the multiples of 3 than using map the way I am?
21:51:15 <CSWookie> It's awfully verbose.
21:51:40 <CSWookie> Or maybe...  crusty...
21:51:54 <CSWookie> Although that's not a technical term
21:52:30 <shachaf> http://hackage.haskell.org/packages/archive/lens-family-th/0.1.0.0/doc/html/src/Lens-Family-TH.html , http://hackage.haskell.org/packages/archive/lens-family-th/0.1.0.0/doc/html/src/Lens-Family2-TH.html
21:52:41 <shachaf> Those are remarkably similar.
21:57:12 <geekosaur> CSWookie, I can think of a numbre of things.  firstly, (\x -> x < N) is better written (< N).  secondly, takeWhile (\num -> num < 1000) (map (*5) [1..])) should be the same as map (*5) [1..1000 `div` 5 - 1]
21:57:42 <geekosaur> (and of course that last is a constant you can precompute; I'm just showing how you derive it)
21:58:01 <geekosaur> > 1000 `div` 5 - 1
21:58:02 <lambdabot>   199
22:37:11 <ssbr__> Where should I read about the exact _actual_ semantics of typeclasses? More than just this vague understanding of overloaded functions in the style of CLOS.
22:37:33 <startling> ssbr__: the haskell report!
22:37:35 <Nereid> ^
22:37:35 <ssbr__> I'd also heard that typeclasses compile to regular HM polymorphism -- It'd be pretty nice to see that explained as well :(
22:37:43 <ssbr__> startling: is it readable? will I die
22:37:59 <startling> ssbr__: http://www.haskell.org/onlinereport/basic.html
22:38:13 <geekosaur> it's not going to drown you in higher math, no
22:39:19 <ssbr__> Math is fine, I'm more worried about PL theory. :(
22:40:03 <geekosaur> none of that there either
22:42:00 <ssbr__> startling: I didn't see anything explanatory there, but after a bit I just started skimming
22:42:21 <ssbr__> 4.1.4 maybe?
22:42:56 <startling> ssbr__: oh oops, wrong place
22:43:03 <startling> yeah, 4.xish is right
22:44:01 <ssbr__> it references "P. Wadler and S. Blott., How to make ad hoc polymorphism less ad hoc" without giving real details itself
22:44:06 <ssbr__> so maybe I should read that.
22:44:29 <c_wraith> yes, that's the main source on type classes
22:44:39 <ssbr__> apparently that's the paper that introduced and defined typeclasses, so woo
22:45:22 <Nereid> I like wadler's papers' titles.
22:45:56 <ssbr__> it does seem appropriate, doesn't it? :)
22:50:52 <geekosaur> aaaactually, looking at the core produced by ghc might be enough of an answer for you.  (see the ghc-core package on hackage)  the short version is that typeclass constraints on functions compile into dictionaries passed to those functions; in the GHC core output (a sort of "austere Haskell" which is much simpler than real Haskell) the dictionaries are explicit
23:10:34 <ssbr__> geekosaur: yeah, I got that from the paper before I came back here :P
23:10:43 <ssbr__> I was like, "oh, crap, that was actually pretty simple"
23:16:30 <gienah> @tell edwardk adjunctions 3.0 on hackage would be neat (wondering if you just forgot to push it)
23:16:30 <lambdabot> Consider it noted.
23:16:40 <edwardk> woops
23:16:41 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
23:16:56 <edwardk> pushed
23:17:05 <gienah> edwardk: neat, that was fast :]
23:17:10 <edwardk> =)
23:18:20 * hackagebot adjunctions 3.0 - Adjunctions  http://hackage.haskell.org/package/adjunctions-3.0 (EdwardKmett)
23:43:44 <m3ga> i can;t find it on the wiki atm, how do i tell ghc to keep all temporary files?
23:46:12 <ion> See the ghc man page.
23:47:20 <startling> is there a way to turn a two-dimensional (two-tuple indexed) IArray into a list of lists?
23:48:08 <AfC> m3ga: -keep-tmp-files
23:48:18 <m3ga> AfC: thanks!
23:48:56 <startling> hm, what's the best way to display a map of
23:49:02 <AfC> m3ga: it looks like. I discovered that file:///usr/share/doc/ghc-doc/html/users_guide/separate-compilation.html is installed which == http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/separate-compilation.html
23:50:31 <ion> afc: Teach a man to fish/give a man a fish :-P
23:52:55 <AfC> Oh for god's sakes
23:54:29 <AfC> I mean, not only was your answer unhelpful, but it happens that numerous options in this area are missing from the man page, e.g. -dep-makefile which is what Erik helped me find the other day.
23:55:49 <ion> I’m pretty sure the man page knows about -keep-tmp-files.
23:58:39 <m3ga> 'ghc --help' wasn't all that helpful. the man page does indeed mention --keep-tmp-files
