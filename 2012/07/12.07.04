00:05:53 <tmiw> am I missing something here? this looks like it'll finish executing but it seemingly never does
00:05:56 <tmiw> http://pastebin.com/E5cg1ftU
00:05:58 <mauke> The paste E5cg1ftU has been copied to http://hpaste.org/70874
00:08:33 <roconnor_> > magnitue (3 :+ 4)
00:08:35 <lambdabot>   Not in scope: `magnitue'
00:08:40 <roconnor_> > abs (3 :+ 4)
00:08:41 <lambdabot>   5.0 :+ 0.0
00:11:34 <teaurchin> tdammers: I was trying to avoid having to use "trim"
00:12:27 <fmap> tmiw: if middle is minimum in a then aright ≡ a
00:13:28 * hackagebot iproute 1.2.7 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.7 (KazuYamamoto)
00:14:17 <tdammers> teaurchin: do you need to preserve the inner whitespace exactly?
00:14:35 <tdammers> otherwise, you can just parse words until you hit a newline, and then concatenate them back together
00:15:16 <teaurchin> tdammers: yes, I need to preserve the inner whitespace
00:16:29 <teaurchin> this seems to work: manyTill anyChar (try $ spaces >> newline)
00:16:30 <tmiw> fmap: hm, yeah. so it should probably be >middle, not >=middle
00:16:44 <tdammers> yeah, you definitely need the try there
00:16:46 <tmiw> yep, that works
00:17:21 <tdammers> I'm just wondering if trimming wouldn't be more efficient after all
00:17:26 <tmiw> the one on haskell.org always pivots on the first element, which is probably faster anyway due to how lists work in haskell
00:17:45 <teaurchin> tdammers: I'm wondering that also; try is in a bad place there
00:21:39 <tdammers> where else would you put it? you need it right there, because the only way to know you need to discard the spaces is after you have parsed them
00:22:33 <teaurchin> I don't think there is a better place to put it, I just meant that having a try in the second argument of manyTill is bad
00:23:09 <tdammers> oh, that. yeah, probably.
00:23:23 <tdammers> it'll go through the try for each character it parses
00:23:41 <teaurchin> yeah
00:23:43 <tdammers> here's another idea:
00:24:35 <tdammers> manyTill (try $ spaces >> manyOf anyChar) (spaces >> newline)
00:24:41 <tdammers> not exactly this, but the rough idea
00:25:06 <tdammers> or even more elaborate
00:39:57 <roconnor_> edwardk: focus l m = StateT $ unwrapMonad . getCompose . l (Compose . WrapMonad . (runStateT m))
00:40:30 <roconnor_> edwardk: for once the wrongly definined State has actually been helpful.
00:40:31 <edwardk> sounds good. i'll check it when i get my machine set back up
00:40:31 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:40:35 <edwardk> hah
00:41:13 <edwardk> and yeah the semantic editor combinator connection makes sense
00:41:39 <edwardk> great next i'll start liking SECs ;)
00:41:56 <roconnor_> edwardk: you alread do apparently
00:41:59 <roconnor_> *already
00:42:01 <edwardk> hah
00:49:18 <teaurchin> tdammers: in case you're curious, the trim version turns out to be faster on large inputs (50+ MB)
00:49:42 <tdammers> that's what I suspected
00:49:53 <tdammers> if the input is short, it probably doesn't matter much either way
00:50:19 <tdammers> but speculatively parsing long runs of whitespace is bound to have an impact
01:52:46 <antoras> @pl \n xs -> concat $ replicate n xs
01:52:46 <lambdabot> (join .) . replicate
01:58:24 <antoras> @type map
01:58:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:58:50 <antoras> @help
01:58:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:58:57 <antoras> @list
01:58:57 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:59:46 <antoras> @run map (+1) [1..10]
01:59:48 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
02:01:27 <Zqrxv> lambdabot, if you were XML, you would totally write <command />
02:02:25 <antoras> @help run
02:02:26 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
02:02:42 <Zqrxv> no IO
02:02:45 <Zqrxv> in MY lambdabot?
02:03:07 <Zqrxv> > (+ 4)
02:03:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
02:03:08 <lambdabot>    arising from a use of `...
02:03:22 <Zqrxv> Does it always do that for unshowables?
02:03:53 <Zqrxv> > putStrLn "Can you display a random IO () my buddy?"
02:03:55 <lambdabot>   <IO ()>
02:03:59 <Zqrxv> Hmm
02:04:26 <antoras> @help pl
02:04:26 <lambdabot> pointless <expr>. Play with pointfree code.
02:04:47 <antoras> @pl map (\(y, z) -> y + z) (zip x (tail x))
02:04:48 <lambdabot> zipWith (+) x (tail x)
02:05:15 <tdammers> pl is an awesome feature
02:05:41 <antoras> Yes it is
02:05:44 <tdammers> kinda like automated refactoring
02:06:00 <tdammers> "here lambdabot, take this mess and clean it up for me kthx"
02:06:22 <frerich> Sometimes "clean it up" turns out to be "create a bigger mess" though.
02:06:42 <tdammers> heh, yeah
02:07:02 <tdammers> some things aren't meant to be expressed point-free
02:07:18 <antoras> I don't know, do lambdabot requests bother someone?
02:07:35 <Fulax> @help pointful
02:07:36 <lambdabot> pointful <expr>. Make code pointier.
02:07:36 <antoras> maybe it is better to send them directly to lambdabot?
02:08:35 <antoras> @run import Control.Applicative; let foo = zipWith (+) <*> tail
02:08:37 <lambdabot>   <no location info>: parse error on input `import'
02:09:06 <tdammers> pointful is kind of trivial though
02:09:17 <tdammers> just wrap the expression in a lambda
02:09:22 <tdammers> @pointful map
02:09:23 <lambdabot> map
02:09:32 <tdammers> @pointful map . concat
02:09:33 <lambdabot> (\ c -> map (concat c))
02:09:44 <tdammers> @pointful map . concat . zipWith (+)
02:09:45 <lambdabot> (\ c -> map (concat (zipWith (+) c)))
02:09:47 <merijn> antoras: You can privmsg lambdabot if you're worried about spam
02:10:01 <antoras> merijn: ok
02:10:13 <Nereid> but if it's not obstructing other discussion it's probably fine ;)
02:10:35 <tdammers> I don't know, sometimes I find people's lambdabot sessions entertaining
02:11:19 <merijn> tdammers: Sure, I usually restrict lambdabot questions to things I hope others here will have a better suggestion for than lambdabot/otherwise interesting/educative
02:11:34 <merijn> Just quick small things I prefer to privmsg to avoid spamming too much
02:14:30 <antoras> @run zipWith (+) <*> tail $ [1..10]
02:14:31 <lambdabot>   [3,5,7,9,11,13,15,17,19]
02:14:40 <antoras> @pointful zipWith (+) <*> tail $ [1..10]
02:14:41 <lambdabot> (((zipWith (+)) <*> tail) ([1 .. 10]))
02:15:11 <antoras> @pl zipWith (+) <*> tail $ [1..10]
02:15:12 <lambdabot> (zipWith (+) <*> tail) [1..10]
02:15:27 <shachaf> Don't expect to get the results you're after from @pf.
02:15:58 <shachaf> foo <*> bar $ x = foo x (bar x)
02:16:38 <antoras> ok
02:19:34 <antoras> @pl zipWith (+) [1..10] (tail [1..10])
02:19:35 <lambdabot> zipWith (+) [1..10] (tail [1..10])
02:20:18 <sipa> @pl \n -> zipWith (+) [1..n] (tail [1..n])
02:20:18 <lambdabot> ap (zipWith (+) . enumFromTo 1) (tail . enumFromTo 1)
02:36:24 <antoras> > take 20 $ [1..] >>= (`replicateM` "a1")
02:36:25 <lambdabot>   ["a","1","aa","a1","1a","11","aaa","aa1","a1a","a11","1aa","1a1","11a","111...
02:36:49 <antoras> @pf take 20 $ [1..] >>= (`replicateM` "a1")
02:36:49 <lambdabot> Maybe you meant: bf pl
02:36:55 <antoras> @pointful take 20 $ [1..] >>= (`replicateM` "a1")
02:36:55 <lambdabot> (take 20 (([1 ..]) >>= \ a -> replicateM a "a1"))
02:40:54 <antoras> @pf take 10 $ concatMap (\x -> replicateM x "a1") [1..]
02:40:55 <lambdabot> Maybe you meant: bf pl
02:41:16 <antoras> @pl take 10 $ concatMap (\x -> replicateM x "a1") [1..]
02:41:17 <lambdabot> take 10 (flip replicateM "a1" =<< [1..])
02:43:38 <antoras> @help source
02:43:38 <lambdabot> source <lib>. Lookup the url of fptools libraries
02:44:15 <antoras> @help hoogle
02:44:16 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
02:44:29 <antoras> @hoogle Char -> Int
02:44:30 <lambdabot> Data.Char digitToInt :: Char -> Int
02:44:30 <lambdabot> Data.Char ord :: Char -> Int
02:44:30 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
02:44:33 <roconnor> was ((,) a) a functor in Haskell 98?
02:48:52 <antoras> @pointful (,) <$> 4 <*> 3
02:48:52 <lambdabot> ((((,)) <$> 4) <*> 3)
02:49:04 <antoras> @pointful (,) <$> Just 4 <*> Just 3
02:49:04 <lambdabot> ((((,)) <$> (Just 4)) <*> (Just 3))
03:04:18 <\rs> would you resort to RWS when you need two in Reader, Writer and State
03:06:33 <antoras> @help bf
03:06:33 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
03:08:27 <antoras> @bf >++++++>++[<->-]<[<].
03:08:27 <lambdabot>  Done.
03:08:55 <antoras> @bf >++++++>++[<->-]<<
03:08:55 <lambdabot>  Done.
03:09:04 <blackdog> that's a bit unsatisfying
03:09:34 <barrucadu> @bf +[+]
03:09:34 <lambdabot>  Done.
03:09:42 <antoras> yeah, it is ;(
03:11:43 <antoras> @help unlambda
03:11:44 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
03:12:24 <mauke> @unlambda ``SKK
03:12:24 <lambdabot>   unlambda: Unknown operator 'S'
03:13:09 <mroman> @unlambda ``skk
03:13:09 <lambdabot>  Done.
03:13:42 <antoras> @unlambda (\x . x+1) 5
03:13:42 <lambdabot>   unlambda: Unknown operator '('
03:14:00 <mroman> antoras: Unlambda is a programming language.
03:14:19 <mroman> It doesn't do what you thought ;)
03:15:25 <antoras> oh, yeah. found it on google now
03:15:41 <antoras> what is the lambda calculus interpreter?
03:16:55 <antoras> @help eval
03:16:56 <lambdabot> eval. Do nothing (perversely)
03:18:37 <antoras> @lambda
03:18:38 <lambdabot>   unlambda: Parse error at end of file
03:19:53 <antoras> @lambda ```s``s``sii`ki`k.*``s``s`ks``s`k`s`ks``s``s`ks``s`k`s`kr``s`k`sikk`k``s`ksk
03:19:53 <lambdabot>   *
03:19:53 <lambdabot>   *
03:19:53 <lambdabot>   **
03:19:53 <lambdabot>   ***
03:19:53 <lambdabot>   *****
03:20:14 <antoras> ;)
03:21:34 <antoras> @spell
03:21:34 <lambdabot> No word to spell.
03:21:42 <antoras> @spell hello
03:21:57 <antoras> @help spell
03:21:58 <lambdabot> spell <word>. Show spelling of word
03:22:28 <antoras> @spell helllo
03:22:54 <antoras> @translate
03:22:54 <lambdabot> Unknown command, try @list
03:23:24 <antoras> @help tell
03:23:25 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
03:23:42 <tdammers> heh, good old unlambda
03:25:05 <antoras> @todo
03:25:05 <lambdabot> 0. SamB: A way to get multiple results from a google search
03:25:05 <lambdabot> 1. dons: improve formatting of @dict
03:25:05 <lambdabot> 2. dons: write Haskell Manifesto
03:25:05 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
03:25:05 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
03:25:07 <lambdabot> [32 @more lines]
03:25:18 <antoras> @help more
03:25:18 <lambdabot>  @more. Return more output from the bot buffer.
03:26:24 <antoras> @help dict
03:26:24 <lambdabot> I perform dictionary lookups via the following 13 commands:
03:26:24 <lambdabot> all-dicts ... Query all databases on dict.org
03:26:25 <lambdabot> devils ...... The Devil's Dictionary
03:26:25 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
03:26:25 <lambdabot> elements .... Elements database
03:26:26 <lambdabot> [9 @more lines]
03:27:02 <tdammers> @devils pray
03:27:05 <lambdabot> Error: 550 invalid database, use SHOW DB for list
03:27:21 <tdammers> @dict devils pray
03:27:21 <lambdabot> Supported dictionary-lookup commands:
03:27:21 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
03:27:23 <lambdabot> Use "dict-help [cmd...]" for more.
03:33:38 * hackagebot wxc 0.90.0.4 - wxHaskell C++ wrapper  http://hackage.haskell.org/package/wxc-0.90.0.4 (JeremyODonoghue)
03:38:39 * hackagebot wxcore 0.90.0.3 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.90.0.3 (JeremyODonoghue)
03:38:41 * hackagebot egison 2.1.9 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.1.9 (SatoshiEgi)
03:43:44 <antoras> @help slap
03:43:44 <lambdabot> slap <nick>. Slap someone amusingly.
03:43:53 <antoras> @slap lambdabot
03:43:54 * lambdabot hits lambdabot with a hammer, so they breaks into a thousand pieces
03:44:09 <tdammers> lambdabot fails at grammar
03:44:16 <tdammers> @slap lambdabot
03:44:16 * lambdabot slaps lambdabot with a slab of concrete
03:44:55 <mm_freak> '(Monoid e) => Either e' should be an Alternative
03:45:04 <mm_freak> it's a very useful one
03:45:35 <antoras> @help compose
03:45:36 <lambdabot> . <cmd1> <cmd2> [args].
03:45:36 <lambdabot> . [or compose] is the composition of two plugins
03:45:36 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
03:46:09 <antoras> @compose slap slap
03:46:10 * lambdabot smacks *SMACK*, *SLAM*, take that !
03:46:10 <lambdabot>  about with a large trout
03:46:27 <antoras> @compose slap slap lambdabot
03:46:27 * lambdabot jabs /me is overcome by a sudden desire to hurt lambdabot
03:46:28 <lambdabot>  with a C pointer
03:46:44 <MostAwesomeDude> @compose unpl pl \a b c d = (c d) (a b)
03:46:44 <lambdabot> (line 1, column 10) : unexpected "=" expecting pattern or "->"
03:46:51 <MostAwesomeDude> @compose unpl pl \a b c d -> (c d) (a b)
03:46:51 <lambdabot> (\ g j c f -> c f (g j))
03:47:44 <antoras> @babel en de hello
03:47:45 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
03:48:02 <antoras> @slap lambdabot
03:48:03 <lambdabot> I'd rather not; lambdabot looks rather dangerous.
03:48:36 <antoras> @karma
03:48:36 <lambdabot> You have a karma of 0
03:48:47 <antoras> @karma+
03:48:47 <lambdabot> usage @karma(+|-) nick
03:48:51 <antoras> @karma+ antoras
03:48:52 <lambdabot> You can't change your own karma, silly.
03:49:00 <antoras> @karma+ lambdabot
03:49:01 <lambdabot> lambdabot's karma raised to 5.
03:49:15 <antoras> @karma+ lambdabot
03:49:16 <lambdabot> lambdabot's karma raised to 6.
03:49:35 <tdammers> @compose slap karma lambdabot
03:49:35 * lambdabot pulls lambdabot has a karma of 6
03:49:35 <lambdabot>  through the Evil Mangler
03:50:54 <antoras> @elite
03:50:55 <lambdabot> Say again?
03:51:02 <antoras> @help elite
03:51:02 <lambdabot> elite <phrase>. Translate English to elitespeak
03:51:11 <antoras> @elite hello
03:51:12 <lambdabot> h3l1o
03:51:18 <antoras> nice
03:51:25 <antoras> @elite leet
03:51:26 <lambdabot> |E3t
03:51:32 <sipa> @elite there are 1337 apples in the elite box
03:51:32 <lambdabot> +|-|eR3 Are 1337 apPl35 in tHE e1I+3 8OX
03:52:06 <antoras> @help learn
03:52:07 <lambdabot> learn. The learning page url
03:52:21 <antoras> @learn what
03:52:22 <lambdabot> http://www.haskell.org/learning.html
03:52:45 <antoras> @bug
03:52:46 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
03:53:09 <MostAwesomeDude> @compose elite slap script kiddies
03:53:09 <lambdabot> //\/\3 pox3z0rz 5(rIpt kidDI3$ iN THe eY3
03:53:47 <bitonic> @kiddies
03:53:47 <lambdabot> Unknown command, try @list
03:53:53 <bitonic> @script kiddies
03:53:53 <lambdabot> Unknown command, try @list
03:53:57 <bitonic> ah.
03:54:27 <antoras> @paste 1+2
03:54:27 <lambdabot> Haskell pastebin: http://hpaste.org/
03:54:37 <antoras> @map
03:54:38 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
03:54:44 <shachaf> Y'all know you can /msg lambdabot, right?
03:54:57 <MostAwesomeDude> Yes.
03:55:08 <antoras> of course^^
03:55:09 <MostAwesomeDude> And also people can run their own lambdabots.
04:10:09 <Jafet> Hello, I'm learning monads.
04:10:33 <ilya_s> good to know
04:11:50 <Jafet> Can someone link to lambdabot's L.hs? Lost my old .ghci
04:12:23 <tgeeky_> file://c/home/tgeeky/lambdabot/L.hs
04:12:51 <nobdraisentone> tgeeky_: thanks
04:13:14 <Jafet> Thanks, this remains the most helpful channel ever
04:13:40 <HugoDaniel> :)
04:14:34 <shachaf> @where l.hs
04:14:35 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
04:15:01 <Jafet> Thank you. But what happened to the old shachaf?
04:15:43 <shachaf> Jafet: I think he's left with the old Jafet.
04:15:47 <shachaf> Wherever that person is.
04:26:26 <solrize> hey shachaf
04:26:41 <solrize> why are you awake?
04:27:06 <shachaf> Why not?
04:27:24 <solrize> heh
04:27:33 <shachaf> (Any context?)
04:29:03 <shachaf> solrize: Oh, did you see the SO question?
04:29:17 * shachaf should probably go vote on that or something.
04:29:30 <shachaf> Ah, you commented on it.
04:30:09 <shachaf> The "missed optimization" is kind of irrelevant because the question is why GHC isn't ending up with the same code, not how to compute that number most efficiently. :-)
04:31:24 <HugoDaniel> i keep writing these big functions in haskell: http://hpaste.org/70881
04:31:42 <Botje> what the ..
04:31:49 <however> if it's efficient enough, people are willing to compromise on correctness (proof: c is a popular language. qed.) </trollery>
04:32:22 <HugoDaniel> these usually get the input from a html form
04:32:37 <HugoDaniel> im such a bad coder that sometimes i have problem sleeping at night
04:33:38 <however> HugoDaniel: have you thought about passing in a single list with all of those values? or maybe Data.Map or even records could help
04:33:46 * hackagebot stm 2.4 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.4 (SimonMarlow)
04:34:10 <Jafet> You need a helper that computes the right number of "?". Otherwise it is bueno.
04:34:11 <fmap> HugoDaniel: have you consider using data keyword?
04:34:12 <HugoDaniel> however the values are usually of different types
04:34:55 <HugoDaniel> Jafet: i have a vim function somewhere that does it
04:35:21 <HugoDaniel> fmap: using the data keyword would introduce more boilerplate
04:35:30 <HugoDaniel> in the end im calling a plpgsql function :/
04:35:44 <Jafet> vim functions? No wonder you're writing big functions.
04:36:12 <HugoDaniel> yeah, i use vim a lot,
04:36:20 <HugoDaniel> functions, macros, folds, u name it :/
04:36:25 <HugoDaniel> it helps me with the boilerplate
04:36:26 <HugoDaniel> brb
04:37:02 <niez> hi, is there a tutorial/book about gtk2hs and database using gtk model/view?
04:37:24 <however> HugoDaniel: yes, but you eventually give a single list into quickQuery'. you could maybe create this list earlier and pass it to your function in a finished state, instead of passing tons of individual elements (just a thought)
04:37:44 <Peaker> replicateM[_], when, unless, forever, should all have been in Prelude, I think
04:38:10 <shachaf> Peaker: forever wasn't even in Control.Monad a few years ago.
04:38:21 <Peaker> really?
04:38:35 <Peaker> what's a good alternative to ScopedTypeVariables, when you are return-type-polymorphic on a Storable instance, and want to use the sizeOf of that?
04:39:23 <shachaf> Example?
04:39:51 <solrize> shachaf, yeah, i only commented on that division thing because it looked like someone might make some gcc improvements to lift out the log calculation
04:40:06 <however> i'd like <$> and the Data.Maybe stuff in Prelude (fromMaybe ...). also, at the risk of being yelled at, a function split
04:40:16 <however> and ponies
04:40:33 <mux> Peaker: I've had a similar case and couldn't find any alternative
04:42:05 <Peaker> mux, I have a bad alternative, not a good one..   for example: f :: Storable b => a -> IO (Foo b)   ;  you can write:   asTypeIn :: IO (Foo a) -> a -> a ; asTypeIn = const id ;    then:  sizeOf (asTypeIn myResult undefined)   (where myResult is defined to be the action result of the whole function)
04:42:23 <Peaker> though this hack is probably more Haskell 2010 compatible
04:44:01 <ClaudiusMaximus> yep that kind of hackery is what i used when i needed something similar (i seem to recall not being able to add type annotations in instances making ScopedTypeVariables awkward)
04:46:18 <however> so ... haskell.org is down? http://www.downforeveryoneorjustme.com/haskell.org
04:46:56 <barrucadu> The server monkeys must have escaped
04:51:15 <Bytter_> Does someone know of a paper/blog that explores the connection of an unfold, and the State monad over Maybe?
04:54:28 <roconnor> @hoogle accumL
04:54:28 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
04:54:28 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
04:54:28 <lambdabot> Data.Text mapAccumL :: (a -> Char -> (a, Char)) -> a -> Text -> (a, Text)
04:54:38 <roconnor> :/
04:55:29 <zzing_> Is there a nice pdf of the typeclassopedia?
04:56:54 <however> zzing_: it was a pdf originally. the wiki page is an updated version. not sure if that's close enough
05:09:17 <MagneticDuck> if I have [(a -> a)] like [a, b, c, d], making a . b. c . d is just foldl (.) id [a, b, c, d] right?
05:09:43 <MagneticDuck> in my program it doesn't seem to work...
05:09:52 <MagneticDuck> probably another bug though
05:12:04 <fmap> > foldr (.) id [(+1), (*2), (+1), (*2)] 1
05:12:06 <lambdabot>   7
05:12:22 <fmap> seems so
05:12:58 <however> > foldl1 (.) [succ, (*2)] 4 -- small simplification
05:13:01 <lambdabot>   9
05:13:40 <ion> > foldl1 (.) [] 4
05:13:42 <lambdabot>   *Exception: Prelude.foldl1: empty list
05:13:50 <ion> > foldr (.) id [] 4
05:13:52 <lambdabot>   4
05:15:09 <MagneticDuck> yeah
05:15:10 <however> ion, yeah ... he sounded like he knew specifically he'd have 4 (not 0) functions on the list
05:15:18 <MagneticDuck> that's why I use id as the init value
05:15:29 <MagneticDuck> okay I found the bug
05:15:43 <MagneticDuck> for the record, it was because I forgot to take the tail of a list
05:16:44 <DexterLB> what's the best way to check if a list contains a certain value?
05:16:49 <MagneticDuck> elem
05:16:53 <MagneticDuck> from Data.List
05:17:03 <MagneticDuck> > 1 `elem` [2, 3, 1, 4]
05:17:04 <however> > 42 `elem` [40..50] -- DexterLB
05:17:05 <lambdabot>   True
05:17:06 <lambdabot>   True
05:17:09 <MagneticDuck> :P
05:17:16 <DexterLB> thanks :)
05:17:26 <MagneticDuck> we sure pounce on these easy questions
05:17:26 <MagneticDuck> :D
05:17:55 <MagneticDuck> btw I'm almost done with my first real programmish-thing
05:18:06 <MagneticDuck> well my first big programmish-thing
05:18:11 <however> ... which is a good thing for sure. in the good old days, we'd pounce on the easy newbies, which was quite more dubious
05:18:18 <MagneticDuck> just a pure algorithm
05:18:45 <MagneticDuck> would any kind soles be kind enough some day to look over the code and tell me just how horrid I am as a haskell programmer?
05:18:47 * hackagebot paragon 0.1.22 - Paragon  http://hackage.haskell.org/package/paragon-0.1.22 (NiklasBroberg)
05:19:24 <however> MagneticDuck: yes, pouncingly
05:19:47 <MagneticDuck> okay then
05:19:48 <MagneticDuck> :P
05:20:19 <MagneticDuck> I'll post it when I'm done and the bugs are for the most part if not fixed sweeped under the rug
05:22:16 <MagneticDuck> it is my great pleasure to use crazy and while correct unnecessarily complicated grammar that to some make pause to think about the sentence written and question its correctness BTW
05:22:20 <ilya_s> > let chainBy l f = foldl f id l in [succ,(*2)] `chainBy` (.) $ 2
05:22:22 <lambdabot>   5
05:23:49 <UrsFromTheWoods> Is there a way to have dynamic types in Haskell
05:24:09 <UrsFromTheWoods> Like in scripting languages
05:24:11 <MagneticDuck> a variable that can take on multiple types?
05:24:18 <UrsFromTheWoods> Yes
05:24:20 <hpaste> sarfarz pasted “ssl connect” at http://hpaste.org/70882
05:24:29 <Botje> there's a Data.Dynamic.
05:24:31 <MagneticDuck> I'm pretty sure that there are a few ways
05:24:32 <MagneticDuck> yeah
05:24:42 <MagneticDuck> but where do you need them?
05:24:45 <sarfraz> hello, can someone tell me what this "No instance for" means
05:24:46 <merijn> UrsFromTheWoods: Why do you (think) you need them?
05:24:49 <sarfraz> ?
05:24:55 <MagneticDuck> I don't think many people like using them for normal coding
05:25:03 <nominolo_> Hm, haskell.org seems down.
05:25:15 <zzing_> however, it would be enough if it was available :-)
05:25:19 <merijn> sarfraz: It means your trying to use a typeclass instance that does not exist. Can you pastebin the entire error and code on hpaste.org?
05:25:29 <ion> ursfromthewoods: Usually you’ll want to use something like sum types instead.
05:25:34 <UrsFromTheWoods> It would be needed for generating interfaces dynamically from ask or similar
05:25:40 <ion> sarfraz: Do you know what type classes are?
05:25:45 <UrsFromTheWoods> Sdl
05:25:59 <UrsFromTheWoods> Yes
05:26:32 <sarfraz> I read aboout it briefly, the code: http://hpaste.org/70882
05:27:08 <ion> sarfraz: Btw, “loop” is also known as Control.Monad.forever
05:27:16 <however> zzing_: google "typeclassopedia pdf", it's gotta be still around. if you absolutely don't find it, it was originally published in the monad reader. that issue is definitely still around (it'll be like 42 pages with typeclassopedia being p. 32-38 or whatever)
05:28:11 <ion> sarfraz: That error means that an implementation of the CryptoRandomGen class hasn’t been imported (or doesn’t exist) for ByteString.
05:28:35 <sarfraz> ahh I see
05:28:47 <ion> sarfraz: Are you supposed to get a value from newGenIO and then pass that to newGen?
05:29:34 <ion> sarfraz: What are the types of newGenIO, newGen and connectionClient?
05:29:42 <sarfraz> well i am trying to create the g in: connectionClient :: CryptoRandomGen g => String -> String -> TLSParams -> g -> IO (TLSCtx Handle)
05:30:11 <sarfraz> newGenIO :: IO g
05:30:18 <sarfraz> newGen :: ByteString -> Either GenError g
05:30:45 <ion> Doesn’t the result value of newGenIO match the type connectionClient wants?
05:30:52 <sarfraz> ok so the newGen call is not relevant
05:31:04 <sarfraz> yeah just thought soi
05:36:09 <zzing_> ok, thank you
05:37:55 <zzing_> Are there any other seminal works on aspects of haskell that I should look at?
05:43:56 <lisporu> I did not understand last 2 lines of this analysis of algorithm: http://pastebin.com/dMYrf0KX
05:43:58 <mauke> The paste dMYrf0KX has been copied to http://hpaste.org/70883
05:46:24 <however> so what's people's opinion on http://hackage.haskell.org/packages/archive/time-lens/0.3/doc/html/Data-Time-Lens.html ? seems quite a nice idea if you ask me
05:47:00 <ion> I hate it with all my heart and hope it dies in a fire!
05:48:08 <MagneticDuck> why?
05:48:31 <hpc> that looks not particularly readable
05:48:36 <ion> Disclaimer: the above may not have been a serious opinion.
05:48:55 <however> ion: at least you have a clear, colorful opinion. no waffling around :)
05:49:03 <hpc> i like the hours/minutes/seconds lenses though
05:49:19 <hpc> modL, setL, getL need nicer names
05:49:57 <ion> hpc: I can’t see the unreadability of, say, modL minutes (+5). But i guess i’m already used to the name modL.
05:50:14 <however> hpc: you mean the "fromGregorian" stuff isn't too readable? that seems to come from the standard lib ... but yeah
05:50:31 <mcstar> pasting the same problem to #lisp and #haskell, yet not related to either of them?
05:50:35 <hpc> however: yeah, it's better but still not up to my readability standards :P
05:50:40 <ion> The Data.Time API could use some love indeed.
05:50:47 * hpc is incredibly picky
05:51:30 <ion> Data.Time.Lens looks fine, i suppose Data.Lens *could* be better, Data.Time could certainly be better. But the latter two are a separate issue from Data.Time.Lens. :-)
05:51:45 <hpc> honestly, what i would do is steal the MonadState namespace
05:51:50 <hpc> and use set, get, modify
05:51:55 <merijn> ion: By some love you mean the rough kind of love involving beatings, right?
05:52:02 <fmap> If I have `#define SMTH' in module A, can I import that define in module B somehow?
05:52:13 <hpc> my first reading of the docs made me think modL == modulo lens
05:52:34 <however> in my experience Data.Time is something you use about 2x per year for some pretty simple thing, and each time you're completely baffled :-/
05:52:48 <hpc> however: yeah
05:53:05 <hpc> you write wrappers for exactly the subset you happen to need, then forget about it entirely until the next time
05:56:45 <lisporu> mcstar: may be I thought I can find someone intelligent enough to explain that
05:57:17 <lisporu> mcstar: or someone courageous enough to give a better method of analysis
05:58:14 <zzing_> If I had  something like   do { s <- function1; t <- function2;   n <- function3 t s; … }  Can >>= be used in such a way to determine the order that t and s are used in function3?
05:58:52 <hpc> zzing_: no
05:59:03 <hpc> (>>=) determines the order of function1, function2, function3
05:59:11 <hpc> (which aren't necessarily functions)
05:59:21 <zzing_> Are there things that you need the do syntax for?
05:59:30 <sipa> no
05:59:39 <hpc> do-notation is never required
05:59:40 <sipa> it's purely syntactic sugar
05:59:49 <hpc> your code can be rewritten as
05:59:52 <ion> join (flip action3 <$> action1 <*> action2)  -- i wouldn’t use this, though.
06:00:17 <hpc> function1 >>= \s -> function2 >>= \t -> function3 t s >>= \n -> ...
06:00:38 <hpc> in fact, that's the exact translation from do-notation
06:01:31 <zzing_> So creating a series of lambdas that are fed on to the next one?
06:01:35 <hpc> yes
06:01:52 <zzing_> Is ion's code an equivalent/
06:01:55 <hpc> in fact, let's rename these actions and play with it a bit
06:01:57 <hpc> zzing_: yes
06:02:01 <ion> @undo do { s <- action1; t <- action2; action3 t s }
06:02:01 <lambdabot> action1 >>= \ s -> action2 >>= \ t -> action3 t s
06:02:05 <ppilate> Is there anything like length, but which returns Integer, as opposed to Int
06:02:07 <hpc> action1 >>= \a -> action2 >>=
06:02:12 <hpc> action1 >>= \a -> action2 >>= \b -> ...
06:02:15 <hpc> is actually
06:02:23 <zzing_> I better get out my notebook
06:02:29 <hpc> action1 >>= (\a -> action2 >>= \b -> ...)
06:02:37 <sipa> ppilate: genericLength
06:02:40 <merijn> ppilate: There's genericLength
06:02:48 <hpc> but it doesn't matter which way we parenthesize; im just doing it this way for explanation
06:02:49 <DexterLB> is there any reason in any case that I would prefer String over Text?
06:02:56 <ppilate> tanks
06:02:57 <ppilate> thanks*
06:02:59 <hpc> so we have action1 >>= function
06:03:07 <ion> zzing: The only difference is that my code requires the type of the actions to implement Applicative as well. If that is a problem, one could use join (liftM2 (flip action3) action1 action2). But i wouldn’t use that form either.
06:03:42 <hpc> and in the function, (\a -> ...), the parameter 'a' is the "result of the previous action", which (>>=) passes to the function as part of its definition
06:04:26 <zzing_> ion, aren't all monads applicative too?
06:04:35 <sipa> they should be
06:04:49 <ion> zzing: They *should* be, but due to a historical accident that’s not required by the type classes.
06:05:18 <hpc> there's several proposals to fix that
06:05:36 <hpc> with varying degrees of breakage when applied to historical code
06:05:37 <mcstar> functor < applicative < monad < arrow isnt this the hierarchy?
06:05:49 <hpc> mcstar: minus arrow
06:05:58 <hpc> it has a different kind than the others
06:06:02 <zzing_> Has anyone just redone prelude and associated libraries, to fix the errors, that anyone uses?
06:06:14 <hpc> yes
06:06:25 <hpc> you probably don't want them though
06:06:27 <zzing_> I know of some preludes, not sure how encompassing they are
06:06:34 <mcstar> hpc: but then, why would be all monads applicative? what i said, implies all applicatives are monads, not vice versa
06:06:35 <hpc> the stuff they fix isn't particularly painful
06:06:37 <zzing_> I bet probably not too
06:07:30 <zzing_> So when we have action1 >>= \s -> action2 >>= \t -> action3 t s      Is action3 and action2 in the same lambda?
06:07:33 <DexterLB> how do I load several modules at a time in ghci?
06:07:50 <hpc> import Foo
06:07:52 <hpc> import Bar
06:07:54 <hpc> ...
06:07:59 <Botje> :m +Foo Bar Baz
06:08:24 <ppilate> http://hpaste.org/70886 Can anybody please give any comment on my code? It's an algorithm for counting inversions in a list using merge sort algorithm
06:08:34 <zzing_> :t (<*>)
06:08:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:08:46 <zzing_> :t (<$>)
06:08:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:08:50 * hackagebot syb 0.3.7 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.3.7 (JosePedroMagalhaes)
06:09:11 <hpc> zzing_: not sure how to answer that; there's two levels of lambdas, and the associativity law says it can really be "yes" or "no"
06:09:22 <zzing_> ok
06:09:22 <hpc> really, the interesting thing is (>>=), not the actions and lambdas
06:10:17 <hpc> get your brain fully wrapped around the fact that there is one of those between every single "statement" in a do block, and work through some of the easier definitions
06:10:36 <zzing_> ion, going back to your nicer looking code, you have <$> - but isn't action3 going to be an a -> b -> f c
06:10:42 <hpc> http://learnyouahaskell.com/a-fistful-of-monads#getting-our-feet-wet-with-maybe
06:10:54 <zzing_> For reference, flip action3 <$> action1 <*> action2
06:10:58 <DexterLB> hpc, Botje: I mean loading from files, like :l
06:11:32 <waynr> howdy folks
06:11:45 <zzing_> :t flip
06:11:46 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:11:49 <waynr> i am having difficulty installing a package using cabal
06:12:01 <mcstar> DexterLB: start ghci with -i path , path to your files containing the modules
06:12:13 <DexterLB> mcstar: thanks
06:12:42 <hpc> waynr: which package?
06:12:46 <waynr> hakyll
06:12:47 <mcstar> DexterLB: you still need to import them, like they said, either into ghci, or indirectly from a file
06:13:30 <waynr> $cabal install hakyll
06:13:30 <waynr> Resolving dependencies...
06:13:31 <waynr> cabal: dependencies conflict: base-3.0.3.2 requires syb ==0.1.0.2 however
06:13:31 <waynr> syb-0.1.0.2 was excluded because json-0.5 requires syb >=0.3.3
06:13:51 <MagneticDuck> yo, I have a little pl question. If I have two functions, (a -> Bool) and (a -> Bool), how do I construct a function a  -> Bool, where both of the predicates are satisfied?
06:14:24 <hpc> waynr: get a more recent ghc
06:14:25 <waynr> what seems to be happening is that hakyll requires base > 3.0.3.2
06:14:30 <waynr> hmm
06:14:34 <MagneticDuck> (\a -> f a && g a)
06:14:39 <hpc> base 3 is beyond ancient
06:14:42 <merijn> MagneticDuck: Either &&& or ***, forget which
06:14:45 <however> > flip (/) 5 2 -- zzing_, i think that's clearer than trying to understand flip's type. note also Prelude's flip has a different type than lambdabot's flip
06:14:48 <lambdabot>   0.4
06:14:49 <merijn> :t (&&&)
06:14:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:14:55 <waynr> well i have base 4.2.0.0 installed
06:14:59 <merijn> :t ***
06:15:00 <lambdabot> parse error on input `***'
06:15:04 <merijn> :t (***)
06:15:05 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:15:11 <waynr> when i type "cabal info base" it shows that 4.2.0.0 is installed
06:15:23 <clsmith> hm, is haskell.org down?
06:15:34 <however> clsmith: yes, seems so
06:15:36 <MagneticDuck> how do I use &&&?
06:15:39 <MagneticDuck> f &&& g?
06:15:44 <ion> zzing: It is indeed.
06:15:45 <clsmith> hm :/
06:15:50 <zzing_> I am familiar with flip
06:15:55 <hpc> > (f &&& g) x
06:15:55 <waynr> clsmith, i am also not able to get to haskell.org even using its ip address 78.46.100.180
06:15:55 <ion> zzing: Thus the “join” around the expression.
06:15:56 <lambdabot>   Ambiguous type variable `c' in the constraints:
06:15:56 <lambdabot>    `GHC.Show.Show c'
06:15:57 <lambdabot>      a...
06:15:58 <merijn> :t uncurry (&&) (f &&&g) -- this I guess
06:16:00 <lambdabot>     Couldn't match expected type `Bool' against inferred type `(c, c')'
06:16:00 <lambdabot>       Expected type: (Bool, Bool)
06:16:00 <lambdabot>       Inferred type: (Bool, (c, c'))
06:16:02 <hpc> > (f &&& g) x :: Expr
06:16:04 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
06:16:04 <lambdabot>         against inferred ...
06:16:10 <MagneticDuck> ty
06:16:11 * mcstar plugs in his backup of the internets
06:16:12 <MagneticDuck> I got it
06:16:14 <hpc> > (f :: Expr -> Expr &&& g) x
06:16:16 <lambdabot>   Could not deduce (SimpleReflect.FromExpr
06:16:16 <lambdabot>                      ((&&&) Simple...
06:16:19 <sarfraz> ion: re, after removing the line it gives me a type error, I reread about types but cannot figure it out
06:16:24 <hpc> > ((f :: Expr -> Expr) &&& g) x
06:16:24 <clsmith> without hoogle i am a fraction of the haskell programmer i normally claim to be <.<;
06:16:26 <lambdabot>   Ambiguous type variable `c'' in the constraints:
06:16:26 <MagneticDuck> it's (\x -> f x && g x)
06:16:26 <lambdabot>    `GHC.Show.Show c''
06:16:26 <lambdabot>     ...
06:16:29 <sarfraz> http://hpaste.org/70887
06:16:31 * hpc gives up
06:16:40 <waynr> hpc, i have base 4.2.0.0 installed, not 3.0.whatever
06:16:50 <MagneticDuck> ty all
06:16:51 <ion> zzing: It would be nice to have something like “bind2 a b c = join (liftM2 a b c)” etc. in Control.Monad.
06:16:55 <zzing_> I have only seen join reference before, not actually seen it
06:17:00 <zzing_> :t join
06:17:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:17:26 <clsmith> hm, does/could ghci have an inbuilt hoogle-like search-namespace-for-type-pattern command? that would be sweet.
06:17:51 <zzing_> ok, I think I should come up with something very contrived and go through code for both ion's join expression and hpc's explanation. Beautiful stuff
06:17:59 <hpc> hmm, hoogle isn't responding
06:18:14 <clsmith> yeah, haskell.org seems down
06:18:29 <ion> sarfraz: Ok, it seems you have to tell it the specific type you want from newGenIO because neither it or connectionClient specify it.
06:19:46 <ion> sarfraz: Try … <- newGenIO :: IO SystemRandom. I don’t know if that’s right, but the documentation says there’s a CryptoRandomGen SystemRandom instance.
06:20:37 <sarfraz> ion: cool!
06:21:03 <sarfraz> I didn't know you could append a type
06:21:06 <ion> sarfraz: Oh, the module seems to have getSystemGen which also does that.
06:21:30 <ion> sarfraz: getSystemGen :: IO SystemRandom already, so you don’t need to specialize anything manually.
06:21:53 <ion> sarfraz: Sorry, scratch that. That action isn’t exported.
06:22:13 <sarfraz> ion: ok, will use that, thanks! I was ready to bang my head
06:22:15 <ion> “… <- newGenIO :: IO SystemRandom” it is then.
06:25:08 <sarfraz> ion: just to know, how did you find getSystemGen? I looked but it's not in the hackage page
06:25:48 <ion> sarfraz: I skimmed through the source of the module. There’s a source link on top of the documentation page.
06:26:47 <sarfraz> oh I should remember that
06:27:46 <however> do the lens operators make sense to anyone? and what's with those "!" variants? http://hackage.haskell.org/packages/archive/data-lens/2.10.0/doc/html/Data-Lens-Common.html#g:3
06:28:29 <hpc> however: the "!" variants are strict
06:28:58 <however> ah wait, the mnemonic for (^.) is probably how you use . to access a member in c or java
06:29:06 <however> hpc: oh i see
06:33:04 <MagneticDuck> hoogle is down!!
06:33:08 <MagneticDuck> aaaaaaa
06:33:22 <adimit> MagneticDuck: use the command line version or hayoo :-)
06:33:24 <Fulax> @hoogle hoogle
06:33:24 <MagneticDuck> what's the package for isJust?
06:33:24 <lambdabot> Can't think of anything more interesting to search for?
06:33:25 <lambdabot> package hoogle
06:33:30 <MagneticDuck> hayoo?
06:33:41 <however> @where hayoo
06:33:42 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
06:33:43 <adimit> http://holumbus.fh-wedel.de/hayoo/hayoo.html
06:33:46 <adimit> :-\
06:34:34 <MagneticDuck> @hoogle isJust
06:34:34 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
06:35:03 * adimit usually prefers to use hayoo because it seems to index (and search in) a greater subset of hackage.
06:35:30 * bitonic prefers hoogle because it's more old school.
06:35:45 <MagneticDuck> heh, I have a funny little thing
06:35:46 <osfameron> hayoo?
06:36:15 <MagneticDuck> if I have a list of Maybe a, and I want to find the first Just entry, and if there isn't any, return Nothing...
06:36:33 <MagneticDuck> what's that concat thing for monads called?
06:36:39 <MagneticDuck> I forget
06:36:39 <adimit> MagneticDuck: dropWhile (not . isJust)
06:36:46 <MagneticDuck> I know
06:36:50 <MagneticDuck> but that returns a list
06:36:52 <MagneticDuck> I want a Maybe
06:36:57 <MagneticDuck> it's easy
06:37:07 <adimit> MagneticDuck: listToMaybe . dropWhile (not . isJust)
06:37:11 <MagneticDuck> I just forgot the function Maybe a -> Maybe a -> Maybe a
06:37:16 <MagneticDuck> listToMaybe?
06:37:18 <MagneticDuck> ah
06:37:20 <MagneticDuck> nice function there
06:37:34 <MagneticDuck> ar
06:37:42 <ion> @type mappend `asAppliedTo` (undefined :: Maybe a)
06:37:43 <MagneticDuck> I mean the function (Maybe Maybe a -> Maybe a)
06:37:43 <lambdabot> forall a. (Monoid a) => Maybe a -> Maybe a -> Maybe a
06:37:45 <ion> @type (<|>) `asAppliedTo` (undefined :: Maybe a)
06:37:47 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
06:38:03 <ion> @type join `asAppliedTo` (undefined :: Maybe (Maybe a))
06:38:05 <lambdabot> forall a. Maybe (Maybe a) -> Maybe a
06:39:08 <Baughn> @hoogle rnf
06:39:09 <lambdabot> Control.DeepSeq rnf :: NFData a => a -> ()
06:40:12 <MagneticDuck> @hoogle (Monad m) => m (m a) -> m a
06:40:13 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
06:40:13 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
06:40:13 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
06:40:18 <MagneticDuck> JOIN
06:40:19 <MagneticDuck> yes
06:41:30 <MagneticDuck> @hoogle Maybe a -> a
06:41:31 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
06:41:31 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
06:41:31 <lambdabot> Data.Monoid First :: Maybe a -> First a
06:41:45 <ion> fromJust is evil.
06:41:49 <MagneticDuck> yeah
06:41:56 <MagneticDuck> wait
06:41:59 <MagneticDuck> how is it written?
06:42:07 <ion> fromJust (Just a) = a
06:42:08 <MagneticDuck> it returns an error in the case of a Nothing?
06:42:12 <ion> yes
06:42:17 <MagneticDuck> EEEVVVILL
06:42:17 <cesip> guys, i know it's a n00b question, but seems like i am having trouble with this:
06:42:23 <however> yes, it crashes the program
06:42:28 <MagneticDuck> s/n00b/newbie
06:42:37 <cesip> showString :: [Int] -> String
06:42:37 <cesip> showString = foldr1 (\x y -> x ++ ", " ++ y) . concat . map show
06:42:42 <cesip> what is wrong with this?
06:43:12 <ion> showString [] is bottom
06:43:16 <waynr> i am having trouble building ghc-7.4 (not even sure if this is the version i should use though since haskell.org is down)
06:43:35 <ion> concat returns a string, not a list of strings.
06:44:04 <cesip> right, but that is what i want, and ghci throw an error already at map show for some reason
06:44:18 <MagneticDuck> @hoogle join
06:44:18 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
06:44:19 <lambdabot> package join
06:44:19 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
06:44:27 <cesip>     Couldn't match expected type `String' with actual type `Char'
06:44:27 <merijn> cesip: Can you pastebin the error at hpaste.org?
06:44:29 <waynr> i am attempting to use the github mirror (since haskell.org is down) and when i run `./sync-all get` i get an error:== running git clone https://github.com/ghc/packages-cabal-1.14.git libraries/Cabal
06:44:30 <waynr> Cloning into libraries/Cabal...
06:44:30 <waynr> fatal: https://github.com/ghc/packages-cabal-1.14.git/info/refs not found: did you run git update-server-info on the server?
06:44:30 <waynr> git failed: 32768 at ./sync-all line 145.
06:44:41 <merijn> :t concat
06:44:42 <lambdabot> forall a. [[a]] -> [a]
06:44:51 <ion> Drop the concat.
06:44:53 <however> waynr: usually everyone uses the binary ghc packages. i think almost no-one needs a custom-built ghc. also, for errors >1 line, please use hpaste
06:44:56 <however> @where hpaste
06:44:57 <lambdabot> http://hpaste.org/
06:45:14 <fmap> cesip: you probably want an `intercalate' from Data.List instead of foldr1 (..) thing
06:45:19 <merijn> cesip: You're giving the foldr1 a [Char] as input, not a [String] (i.e. [[Char]])
06:45:21 <waynr>  okay however, but where can i get the ghc binary when haskell.org is down?
06:45:39 <merijn> cesip: And using ++ on a char is a type error
06:45:40 <tdammers> waynr: what OS?
06:45:46 <fmap> > intercalate ", " $ map show [1..10]
06:45:48 <lambdabot>   "1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
06:45:50 <waynr> tdammers, debian6
06:46:02 <tdammers> aptitude install haskell-platform
06:46:07 <cesip> arrrrrrrrrr makes sense!
06:46:13 <tdammers> or just ghc
06:46:13 <cesip> ok, i dropped the concat
06:46:14 <cesip> neat
06:46:42 <mcstar> > show [1..10]
06:46:43 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10]"
06:47:23 <cesip> of course, i needed a list of strings, not a list of chars
06:47:24 <waynr> tdammers, i already have ghc installed, the problem is that i cannot `cabal install hakyll` ...someone here told me to get a newer version of ghc
06:47:35 <tomboy64> what's up with haskell.org?
06:47:36 <MagneticDuck> yo, what's a function to split a list on elements with a certain value?
06:47:37 <tomboy64> it's down for me
06:47:42 <MagneticDuck> [a] -> a -> [[a]]
06:47:47 <nand`> debian's ghc package is probably outdated so I guess you'll have to wait for haskell.org
06:47:50 <Botje> check the Data.List.Split package.
06:47:51 <tomboy64> The connection to www.haskell.org (78.46.100.180) could not be established.
06:47:58 <MagneticDuck> @hoogle [a] -> a -> [[a]]
06:47:59 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
06:47:59 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
06:48:00 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
06:48:01 <waynr> sadface
06:48:20 <tdammers> maybe try backports?
06:49:02 <MagneticDuck> tomboy: it's a UNIVERSAL CRISIS! hoogle is of course down too!! :0
06:49:06 <tdammers> or if you're feeling adventurous, switch to wheezy
06:49:27 <waynr> tdammers, i don't think ghc is in backports
06:49:30 <however> MagneticDuck: there is no standard function for that. there's one in the missingh package, and there's the split package
06:49:43 <however> (or you could use Prelude's break function to write one yourself ...)
06:50:10 <waynr> yeah i have been thinking about just moving to wheezy and maybe keeping this root filesystem in a small corner of my drive just-in-case
06:50:55 <tdammers> you're right, it's not
06:51:00 <mcstar> MagneticDuck: on bytestrings, you can do splitWith
06:51:02 <nand`> wheezy has ghc 7.4.1, which is not quite the latest stable ghc either but should suffice
06:51:25 <tdammers> ...which means you can, in theory, bake your own backport
06:51:41 <nand`> (and this is OT but I would strongly recommend switching to wheezy since squeeze is highly outdated and therefore harmful to development work)
06:52:46 <waynr> thanks, i think i will do that...
06:56:40 <chris2> is there a nicer way to write  if0 <$> eval a <*> pure 1 <*> pure 0
06:56:51 <chris2> (i use applicative to pass the env for eval around)
06:57:39 <Botje> liftA3 if0 (eval a) ... ... ?
06:57:53 <chris2> i still need the pure no?
06:57:57 <nand`> yes
06:58:00 <chris2> liftA3 lifts all arguments?
06:58:27 <nand`> liftA3 f a b c = f <$> a <*> b <*> c
06:58:31 <chris2> yep
06:58:37 <chris2> i just want to avoid the pure perhaps
06:58:51 <chris2> i could curry them in if i reorder the arguments of course
07:03:56 <however> chris2: i once wrote little helper functions that have the pure built in ... "if0 <$> eval a >*< 1 >*< 0" ... something like this. may or may not help
07:04:05 <chris2> yep
07:04:08 <chris2> considering that
07:04:32 <chris2> truth' <$> ((<)  <$> eval a <*> eval b)
07:04:42 <chris2> the outer () are annoying here too :/
07:06:12 <Botje> liftA2 to the rescue again :P
07:08:56 <cocon> hmmm, lamda.haskell.org seems to be down...
07:09:05 <chris2> haskell.org has been weird all day
07:09:54 <Itkovian> Just in case somebody's interested in working at Ghent University:  http://t.co/6773P6ls
07:21:52 * chris2 wonders if he should have used a monad :P
07:27:34 <DexterLB> is haskell.org down?
07:27:41 <DexterLB> oh, just read scrollback :P
07:28:23 <byorgey> downforeveryoneorjustme.com concurs
07:29:22 <DexterLB> how do I join path strings? there appears to be System.FilePath, am I on the right track?
07:29:27 <DexterLB> can't read docs :/
07:31:58 <byorgey> yes, you're on the right path =)
07:32:02 <byorgey> </>
07:33:31 <DexterLB> how do I find out which package that is in, without reading the docs? :D
07:34:45 <fmap> @hoogle (</>)
07:34:46 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
07:34:46 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
07:34:52 <rwbarton> ghc-pkg list --global and then guess it's probably the 'filepath' package I suppose
07:35:08 <rwbarton> must be a way to have ghc-pkg look up a package by module name as well
07:35:13 <byorgey> DexterLB: it's in System.FilePath
07:35:28 <byorgey> note that if you just import System.FilePath you get whichever version (Windows or Posix) is appropriate
07:35:39 <DexterLB> byorgey: smartass :P
07:36:48 <mcstar> cant people find out stuff offline anymore?
07:37:20 <rwbarton> next you're going to ask us to multiply four-digit numbers by hand
07:37:24 <mcstar> i recommend the 'hoogle' utility, usable from the shell
07:37:34 <mcstar> rwbarton: id ask you to do it in you head
07:37:37 <mcstar> its faster
07:37:48 <rwbarton> yes, if you've already installed it from hackage.haskell.org :P
07:38:16 <mcstar> rwbarton: do you want me to pastebin it?
07:38:25 * mcstar distributes rootkits
07:38:43 <mcstar> nah, i dont
07:39:53 <byorgey> multiplying four-digit numbers in ones head, sounds like a fun challenge =D
07:43:49 <zachk> byorgey: 3737*91623 ;)
07:43:54 <zachk> oops
07:44:10 <zachk> 3713 * 9173 there ya go byorgey
07:51:14 <byorgey> 33059349?
07:51:42 <byorgey> whoops, missed a carry
07:51:45 <byorgey> well, I was close =D
07:54:01 <mcstar> 34050349
07:54:05 <mcstar> ?
07:54:12 <mcstar> > 3737*91623
07:54:14 <lambdabot>   342395151
07:55:28 <mcstar> numbers: tripping men up since peano
07:55:57 <mcstar> damn
07:56:05 <mcstar> > 3713 * 9173
07:56:06 <lambdabot>   34059349
07:56:14 <mcstar> hay, i got it right
07:56:27 <mcstar> no
07:58:54 * hackagebot type-eq 0.1.2 - Type equality evidence you can carry around  http://hackage.haskell.org/package/type-eq-0.1.2 (GaborLehel)
08:00:53 <cocon> in a .cabal file is there any way to share e.g. default-extensions between an executable and a library section?
08:10:57 <Peaker> Haskell.org still down? :(
08:11:09 <Taneb> Looks it :(
08:11:49 <Clint> tragic
08:12:17 <Peaker> hackage.haskell.org seems up at least :)
08:12:44 <Peaker> doh, the download links still go to haskell.org
08:14:40 <fryguybob> byorgey: Art Benjamin has some tips for you.
08:17:00 <zachk> .ghci in ~ with :def hoogle ftw
08:18:06 <kallisti> is HTTP thread safe?
08:18:32 <kallisti> in other words, if I send multiple requests via the HTTP package from different threads will it block correctly?
08:19:04 <kallisti> er wait, nevermind. there's no state between requests. so yes.
08:19:09 <mm|swarm> it is afair
08:19:57 <mcstar> re ghci, try this prompt: :set prompt "▼/%s\\\n"
08:21:22 <tdammers> kallisti: if you use some kind of persistence that is not thread-safe, you may run into trouble
08:21:22 <mcstar> btw, i recommend putting a linebreak at the end of PS1 too
08:21:46 <tdammers> nm, you're talking about the client, right?
08:23:21 <MrFenix> probably (maximum [1..]) people have asked it.. but: is haskell.org down?
08:23:46 <xarch> looks like it is
08:23:50 <ion> http://www.isup.me/haskell.org
08:23:54 * hackagebot http-conduit 1.5.0 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.5.0 (MichaelSnoyman)
08:25:34 <MrFenix> hackage still works
08:31:36 <MagneticDuck> what's the function for splitting a list on elements of a certain value?
08:31:40 <byorgey> fryguybob: hehe, I bet he does =)
08:32:02 <zachk> MagneticDuck: splitOn?
08:32:04 <byorgey> @package split
08:32:04 <lambdabot> http://hackage.haskell.org/package/split
08:32:08 <byorgey> MagneticDuck: ^^^
08:32:23 <MagneticDuck> [2, 3, 4, 1, 2, 3, 1, 2] -> [[2, 3, 4], [2, 3], [2]]?
08:32:46 <MagneticDuck> okay
08:32:47 <MagneticDuck> ty
08:35:27 <byorgey> MagneticDuck: you could do that with   splitWhen (==1)
08:37:39 <MagneticDuck> or splitAt [1]
08:37:47 <MagneticDuck> right..?
08:38:05 <zachk> MagneticDuck: you could splice together takewhile and dropwhile
08:38:39 <byorgey> MagneticDuck: splitOn [1]
08:38:45 <MagneticDuck> ah
08:38:48 <MagneticDuck> new to this package
08:38:49 <byorgey> MagneticDuck: splitAt is from Data.List, it takes an index
08:38:54 * hackagebot authenticate 1.3.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.0 (MichaelSnoyman)
08:48:55 * hackagebot mega-sdist 0.2 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.2 (MichaelSnoyman)
08:52:05 <alhazred_> is there anything like a visual frontend for cabal for windows? at best integrated in an ide.
08:58:47 <yitz> alhazred_: there are a few different ides, none specifically for windows, and none of which is very advanced yet. most people use either emacs or vim, which do have excellent integration. but they're not what windows people would usually call "visual".
08:59:09 <alhazred_> ok
08:59:33 <alhazred_> im inclined to learn emacs, but there is still quite a barrier for me to dare the jump :)
08:59:46 <navaati> yitz: isn't there a plugin to visual studio ? this would be "specifically for windows"
09:00:11 <yitz> alhazred_: yes, there is a learning curve.
09:00:20 <yitz> navaati: is there?
09:00:40 <navaati> not sure it's still maintained, tho
09:00:57 <yitz> i guess being for "visual studio" would qualify it as being "visual", too. at least in name.
09:01:29 <harrison> eep
09:01:37 <navaati> what do you call visual ? if it means "have a GUI creator", well, that's kinda unrelated to the programming language you use
09:02:33 <alhazred_> what i want is somethine like leksah but i bit more polished
09:03:19 <navaati> ah, "a visual frontend for cabal" (I should have read the logs before speaking)
09:03:25 <alhazred_> something to manage the plugins, some integration of the repl, and a bit better support for the panes
09:03:32 <navaati> well, the haskell plugin for eclipse does that
09:03:49 <alhazred_> ah cool, ill check that out then
09:04:09 <alhazred_> does the eclipse plugin also have syntax highlighting?
09:04:15 <navaati> maybe it's more polished than leksah (i can't tell, both have bugs that prevent me from using them)
09:04:18 <navaati> yes, sure
09:04:33 <navaati> the eclipse plugin is called eclipseFP
09:04:35 <alhazred_> also for hoogle etc?
09:04:40 <alhazred_> let me check it out
09:05:09 <navaati> if you don't want to do crazy stuff in your cabal file, it should be fine
09:05:31 <navaati> (but,you know, you should *really* write you cabal file by hand, at the beginning)
09:06:51 <alhazred_> ah you mean the cabal file i want to publish my package with?
09:08:45 <navaati> well, haven't you just said that you want a visual frontend to cabal ?
09:09:17 <meretrix> Hi. Does Haskell have a data type similar to R's data.frame (basically a 2-dimensional matrix with named,  heterogeneous columns that allows for easy subsetting)?
09:10:04 <byorgey> meretrix: nope, but I know someone who is working on such a thing
09:11:00 <meretrix> byorgey: Does he have a repository anywhere?
09:11:55 <noctux> hello, I've got a little problem with Haskell (I'm really a complete newbie so the question might seem a bit stupid, I'm afraid)... I'm trying to write a binary Tree (code http://paste.xinu.at/6E5x/)... my question is: In the function remove, I use l == Empty, and right == Empty... I know this in wrong syntax. Is it possible to write the code that way (I know I could do that with pattern matiching, but that
09:11:57 <noctux> would mean more thinking or more likely, more writing). Can I check somehow, if l was instanciated using the data contructor Empty?
09:12:30 <byorgey> meretrix: https://github.com/cartazio/Cashew
09:12:43 <byorgey> not sure how far he's gotten
09:13:09 <meretrix> byorgey: Thanks. I'll check it out.
09:13:17 <alhazred_> does either of you know if there is a package that implements geometric algebra?
09:13:39 <zachk> alhazred_: if hackage is up use its package search
09:13:46 <zachk> http://hackage.haskell.org iirc
09:14:16 <byorgey> noctux: It's not wrong syntax.  Are you getting an error?
09:14:25 <noctux> byorgey: yes
09:14:37 <noctux> Could not deduce (Eq (Tree a)) arising from a use of `=='
09:15:07 <hc> you have to add deriving (Eq), i think, to the declaration of data Tree
09:15:08 <byorgey> noctux: aha, I see.  That's not a syntax error.  The problem is that to compare things for equality using == there needs to be an instance of the type class Eq
09:15:31 <byorgey> noctux: on line 1 you can add    deriving (Eq)    to the end
09:15:31 <noctux> byorgey: I thought ord already includes Eq
09:15:45 <byorgey> noctux: it does.  But you need an Eq instance for (Tree a), not just for a
09:15:46 <noctux> byorgey: ok, gonna try that...
09:15:52 <noctux> byorgey: ah, I see
09:16:01 <byorgey> noctux: however, I would strongly advise you to do this with pattern-matching rather than ==
09:16:17 <byorgey> noctux: "I don't want to do X because it would involve thinking" is not a very good argument ;)
09:16:24 <byorgey> in fact, that is a great argument *for* doing X =)
09:16:31 <noctux> byorgey: ^^
09:16:52 <noctux> byorgey: well, ok, you convinced me...
09:16:56 <noctux> ;)
09:18:56 * hackagebot boomerang 1.3.2 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.3.2 (JeremyShaw)
09:19:23 <zacstewart> Anyone know where I can find a haskell mirror?
09:19:34 <zacstewart> The official site is not responding
09:19:53 <nand`> what's the canonical type to use for finite, polymorphic matrices/vectors? I need O(1) indexing anywhere and be able to retrieve and update individual rows/cols (by giving their y/x coordinate, respectively)
09:20:26 <navaati> nand`: Array ?
09:20:49 <DMcGill> nand`: Array (or MArray if you want mutable) or if you really care about performance look at the repa package
09:20:55 <nand`> navaati: you mean Array (Array a) ? or just one long array with proper arithmetic to transform (x,y) ⇔ i ?
09:21:11 <navaati> ah, well, Repa then
09:21:25 <navaati> (especially their lovely new version)
09:21:30 <yitz> zacstewart: yeah haskell.org looks down
09:21:46 <nand`> I don't particularly care about performance too much, I mainly want convenience. I would go for [[a]] otherwise, since it gives me row/col for free (by means of !! and transpose)
09:21:47 <DMcGill> note that both Array and repa support an arbitrary number of dimensions
09:21:59 <yitz> zacstewart: there is a hackage mirror somewhere, i forget where
09:22:02 <DMcGill> Array is easier to use than repa
09:22:03 <zacstewart> yitz: I know. On the one day I actually decide i want to experiment with haskell, i can't find a place to download it
09:22:06 <yitz> @where mirror
09:22:07 <lambdabot> I know nothing about mirror.
09:22:09 <nand`> http://hackage.haskell.org/package/repa <- hackage is up
09:22:31 <yitz> zacstewart: oh you want to download the haskell platform? that's something else.
09:22:56 <byorgey> zacstewart: what OS do you use?
09:22:56 <yitz> nand`: ok could be. i was trying to get to the ghc wiki page
09:23:20 <zacstewart> nand`: hackage links to lambda.haskell for the actual download. Which is also down :(
09:23:52 <byorgey> zacstewart: I ask because your OS may already have a haskell platform package
09:24:09 <yitz> @where hackagemirror
09:24:10 <lambdabot> http://hackage.factisresearch.com/
09:24:26 <nand`> oh great, the repa tutorials (on haskell.org) are down :(
09:24:27 <yitz> for the next time
09:24:43 <zacstewart> byorgey: OSX
09:24:47 <noctux> byorgey: ok, so trying to pattern match, I've got a problem: is that somehow possible: remove (Node Empty n r) n = r meaning, that the two n's should be equal for the pattern to match
09:25:15 <byorgey> noctux: no, you can't repeat variables in a pattern like that
09:25:36 <byorgey> noctux: use a guard instead:  remove (Node Empty n r) x | n == x = r
09:25:46 <yitz> hmm community also down. must be the hetzner server.
09:26:12 <noctux> byorgey: ^^ ok, than my initial statement was false =)... It can't be done with pattern matching easily...
09:26:15 <noctux> byorgey: thanks
09:26:43 <yitz> zacstewart: i recently downloaded the mac os x installer for the haskell platform. it would take me a while to upload it, though, and i don't really have a good place to upload it to.
09:27:23 <DexterLB> I have a function: f :: X -> Maybe Y, and I want to define the function g :: X -> Maybe Z, that takes the result from f and returns Nothing if it's nothing, or returns Just Z if it's Just Y, transforming it in the process
09:27:29 <yitz> zacstewart: i would say megauploads, but unfortunately...
09:27:34 <zacstewart> Haha
09:27:43 <DexterLB> is there an easier way to do that than a let expression with pattern matching or a separate function?
09:28:04 <DexterLB> sorry if my description is unclear, couldn't think of how to say it
09:28:04 <byorgey> DexterLB: yes.  Do you know about Functor?
09:28:09 <ski> DexterLB : how do you get from `Y' to `Z' ?
09:28:18 <byorgey> DexterLB: your description is quite clear.
09:28:20 <hpc> DexterLB: suppose you had h :: Y -> Z
09:28:21 <DexterLB> byorgey: nope, noob here
09:28:22 <ski> DexterLB : assuming `h :: Y -> Z', then `g = fmap h . f'
09:28:30 <hpc> g x = fmap h (f x)
09:28:36 <hpc> or h <$> f x
09:28:55 <ski> DexterLB : if instead you have `h :: Y -> Maybe Z', then `g = h <=< f'
09:28:59 <DexterLB> I want to avoid defining h, and do the stuff that h does inside g
09:29:15 <hpc> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
09:29:24 <byorgey> well, then just substitute the definition of h into the definition of g
09:29:30 <ski> DexterLB : instead of saying `h' you can say `\y -> ..y..', where `..y..' computes your `z'
09:29:36 <byorgey> like  g = fmap (\x -> ...) . f
09:29:46 <DexterLB> lambda, yeah, ok, that makes sense
09:30:27 <byorgey> DexterLB: note in this case that fmap is doing the bit about "return Nothing if it's Nothing or apply the function inside the Just"
09:30:41 <DexterLB> byorgey: that's exactly what I needed :)
09:30:43 <DexterLB> thanks
09:30:51 <merijn> :t Prelude.fmap
09:30:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:31:05 <byorgey> here f = Maybe
09:31:15 <merijn> Maybe is an instance of Functor, so you can replace f with Maybe there
09:31:30 <ski> @src Maybe fmap
09:31:31 <lambdabot> fmap _ Nothing       = Nothing
09:31:31 <lambdabot> fmap f (Just a)      = Just (f a)
09:32:45 <merijn> yitz: Dropbox if you have that installed?
09:33:05 <merijn> (for sharing the OSX installer)
09:34:26 <merijn> DexterLB: Depending on how far you are with haskell it might be good to occasionally revisit the Functor, Applicative and Monad parts of LYAH, because those typeclasses are so common and useful :)
09:34:32 <noctux> byorgey: 2nd correction: With haskell, you can do it if you really try xD
09:34:39 <byorgey> noctux: =)
09:34:47 <mm_freak> is there a tutorial on writing a cabal library with some C code?
09:34:54 <DexterLB> byorgey: well, you were right, that's not _exactly_ what I needed :D
09:35:22 <DexterLB> I do need something that doesn't apply the function inside the Just
09:35:36 <DexterLB> fmap' _ Nothing = Nothing
09:35:47 <DexterLB> fmap' f (Just a) = f a
09:35:49 <DexterLB> like this
09:35:58 <DexterLB> is it already defined by some clever name?
09:36:07 <yitz> merijn: i just dragged it into my google drive folder. but this will take quite a while via the wrong direction of adsl.
09:36:09 <merijn> DexterLB: That's a type error
09:36:18 <merijn> DexterLB: unless f returns Maybe a
09:36:18 <fmap> @src Maybe (>>=)
09:36:18 <lambdabot> (Just x) >>= k      = k x
09:36:19 <lambdabot> Nothing  >>= _      = Nothing
09:36:25 <DexterLB> meretrix: yes, it does
09:36:29 <merijn> In which case, you just want the monad instance
09:36:34 <merijn> :t (>>=)
09:36:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:36:47 <merijn> Replace m with Maybe there :p
09:37:37 <navaati> mm_freak: just add a line "c-sources: src/cbits/my_c_code.c"
09:38:01 <navaati> cabal will take care of the rest
09:38:04 <merijn> > Just 5 >>= \x -> Just (x+1)
09:38:05 <lambdabot>   Just 6
09:38:19 <merijn> > Nothing >>= \x -> Just (x+1)
09:38:20 <lambdabot>   Nothing
09:38:24 <DexterLB> sweet
09:38:38 <byorgey> DexterLB: so let me make sure I understand, you have a function  f :: a -> Maybe b, and also a function  b -> Maybe c, and you want to combine them into a function  a -> Maybe c ?
09:38:58 <DexterLB> yeah, precisely
09:39:01 <byorgey> DexterLB: if so, you want (<=<)
09:39:09 <byorgey> @type (<=<)
09:39:10 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
09:39:20 <mm_freak> navaati: great, thanks
09:39:30 <byorgey> or (>=>) if you want to write it the other way around
09:39:32 <merijn> Oh, yeah
09:39:53 <byorgey> @type (>=>)
09:39:54 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:39:56 <navaati> fish operator FTW
09:39:58 <Bytter_> comonads?
09:40:03 <byorgey> so something like  f >=> (\x -> ...)
09:40:22 <byorgey> Bytter_: hmm?
09:41:04 <DexterLB> also, is there a reverse variant of >>=?
09:41:15 <Taneb> :t (=<<)
09:41:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:41:21 <DexterLB> right.
09:41:51 <merijn> DexterLB: Anyhoo, like I mentioned earlier, reading the Functor/Applicative/Monad section of LYAH will probably be helpful for you :)
09:42:13 <merijn> DexterLB: It describes several operators like these
09:42:21 <Taneb> I use (=<<) a lot with shorter functions
09:42:46 <navaati> (or reading the typeclassopedia)
09:43:22 <zzing> Does anyone know of a way to embedd html inside of the markdown pandoc processes?
09:44:54 <byorgey> zzing: you mean you want to include html in the markdown, and then have pandoc read it?
09:45:17 <zzing> byorgey: Something like that. Basically for pandoc to ignore it and just output it with the html
09:45:37 <zzing> I am trying to replace a website with markdown formatted stuff, but there are some things that markdown can't handle that must be html
09:45:42 <byorgey> zzing: that ought to Just Work.  Markdown explicitly allows inclusion of HTML.  Do you have a particular example where it doesn't work?
09:46:07 <zzing> I did, let me take another look
09:46:35 <byorgey> usually if the pandoc parser encounters HTML it just turns it into a RawBlock
09:47:09 <zzing> byorgey: the problem was with it being indented, I copied it striaght from the exsting html
09:47:23 <yitz> well, i can't get to the ghc docs for 7.4. is there some new handling of orphan instances there?
09:47:36 <byorgey> zzing: ah, yeah, if it's indented it's interpreted as a code block
09:47:40 <zzing> I actually have to do a bit of modification on some markdown that worked on daringfireball's tester, that isn't so good on pandoc's.
09:47:55 <zzing> I think I have a fix for the problems
09:48:14 <yitz> i am using attoparsec for text, and i can't convince ghc to recognize bos's orphan instance for IsString (Parser Text).
09:48:39 <bos> yitz: what kind of problem?
09:48:52 <zzing> Specifically, df's site accepted paragraphs inside an ordered list that were indented to the same level as the title. pandoc wants it to be 4 or multiples of 4
09:49:11 <yitz> bos: instance for IsString (Parser Text). But you put it there, really, I see it!
09:49:13 <alhazred_> has anyone of you experienced problems with eclipsefp also in debian?
09:49:22 <yitz> bos: *no* instance
09:49:33 <bos> yitz: how odd
09:49:58 <zzing> looks like it is going ok, until it is gets down about 30% of the way, it no like large file :P
09:50:00 <obk> What would be the best choice for a short strict array? There's Data.Array, Data.Vector, rolling my own some strict List-like type... actually if there was a Data.Strict.List it would have been ideal. The arrays will be pretty short (< 10 elements, say), but size will be determined at run-time.
09:50:01 <yitz> i've tried also importing D.A.Types, Data.String, a few other things. no go.
09:50:15 <rwbarton> maybe the Parser in the instance isn't the Parser you're looking for
09:50:27 <rwbarton> or Text for that matter
09:51:29 <yitz> rwbarton: it's true that there is a bit of confusion. Parser a is a type alias for Types.Parser a b. the instance is in the module that defines the type alias, and uses that.
09:51:38 <rwbarton> try loading your module in ghci and :i IsString ?
09:51:52 <yitz> rwbarton: and it's an orphan instance to boot. but in the past, it always worked.
09:53:09 <zzing> pandoc works great now
09:53:23 <DexterLB> how about a function f :: Maybe a -> Maybe b that returns Nothing if Nothing or performs h :: a -> b and returns Just b if Just a?
09:53:40 <Botje> DexterLB: also known as fmap
09:53:46 <rwbarton> that was your first question :)
09:54:17 <byorgey> well, in particular,  fmap h
09:54:36 <rwbarton> or, part of it was
09:54:36 <DexterLB> was it? ah well
09:54:40 * DexterLB goes for a coffee
09:54:43 <yitz> rwbarton: didn't load (using cabal-dev ghci, since this is in a cabal-dev sandbox)
09:54:44 <rwbarton> I mean part of your first question was this
09:54:58 <byorgey> zzing: oh good =)
09:55:12 <rwbarton> yitz: oh. can you undefined out the offending bit of code, just wondering what happens with :i IsString and your particular set of imports
09:55:58 <zzing> byorgey: those definition lists - how can I get those work in the middle of a series of lists?
09:56:12 <zzing> Right now I am donig **definition** text
09:56:19 <byorgey> zzing: not sure, I don't think I've ever used definition lists
09:56:49 <yitz> rwbarton: reports instances for [Char} and Text only.
09:57:03 <rwbarton> interesting
09:57:15 <yitz> [Char]
09:57:39 <zzing> It looks like the : has to be at the begnning of the line
10:00:10 <zzing> It looks like some work has to be done on this. It looks like it is just finicky to get the structure right, then later on I can mess with CSS
10:05:09 <rwbarton> yitz: I experimented a bit and instances for types that aren't in scope don't show up in :i output
10:05:38 <rwbarton> so it is still possible that you have either the wrong Parser or the wrong Text type
10:06:27 <zzing> Is it easy to extend pandoc's features if I needed to?
10:06:48 <alhazred_> what am i doing if i encounter dependency problems like this in cabal ?
10:06:49 <alhazred_> http://nopaste.info/5839029a7b.html
10:06:51 <yitz> rwbarton: i did :m +Data.Attoparsec.Types, and then yes, it shows up in :i
10:06:55 <ocharles> Hmmm, neither HUnit or test-framework let you run a single test, out of a test suite
10:07:00 <ocharles> am I correct with that?
10:07:40 <ocharles> ie, I have "createFile" and "deleteFile" tests, and I want to focus on just getting "createFile" to pass, I have no option but to manually filter my [Test], neither of the frameworks can do that for me
10:07:49 <yitz> rwbarton: but i already tried importing Types qualified. it didn't help. i need the instance for the type alias.
10:08:11 <rwbarton> well an instance for a type alias is just an instance for the real type
10:08:46 <yitz> rwbarton: that would certainly make sense
10:08:47 <PaulVisschers> Is it just me or is haskell.org down?
10:08:59 <yitz> PaulVisschers: down
10:09:05 <rwbarton> let me look at the actual module .... oh right I can't be cause haskell.org is down
10:09:24 <yitz> rwbarton: could be hackage is up though
10:09:32 <yitz> rwbarton: or the mirror at least
10:09:33 <rwbarton> oh right
10:09:39 <rwbarton> I am always lazy and just use hoogle to get to hackage
10:09:52 <rwbarton> @hackage attoparsec
10:09:52 <lambdabot> http://hackage.haskell.org/package/attoparsec
10:10:22 <yitz> @hackage dont-be-so-lazy-rwbarton
10:10:22 <rwbarton> Data.Attoparsec.Internal.Types, very funny.
10:10:23 <lambdabot> http://hackage.haskell.org/package/dont-be-so-lazy-rwbarton
10:10:28 <ski> PaulVisschers : <http://www.downforeveryoneorjustme.com/haskell.org>
10:10:59 <yitz> rwbarton: yeah, that's another complicating factor
10:12:44 <rwbarton> where's this instance defined?
10:13:09 <PaulVisschers> ski: :)
10:13:55 * ski . o O ( <http://www.downforeveryoneorjustme.com/www.downforeveryoneorjustme.com> )
10:13:58 * hackagebot sexp-show 0.1.1.0 - Produce a s-expression representation of Show values.  http://hackage.haskell.org/package/sexp-show-0.1.1.0 (ChrisDone)
10:14:14 <rwbarton> oh never mind, new in 0.10.2
10:14:35 <yitz> rwbarton: yeah. and in Data.Attoparsec.Text.
10:15:04 <rwbarton> you're using the strict Text type?
10:15:32 <PaulVisschers> cool, a library with the word sex in it
10:16:05 <yitz> rwbarton: yes, strict Text.
10:16:54 <PaulVisschers> ski: is there also a site that lets you know that a site is back up?
10:17:41 <byorgey> ski: hehe, "If you can see this page and still think we're down, it's just you."
10:18:33 <rwbarton> yitz: what's the output of :i Parser for you
10:19:03 <yitz> rwbarton: hmm. setting -XOverloadedStrings, it finds the instance when I spell out the fully qualified name of the type. but ghci doesn't recognize the name unqualified, even though the module is in scope.
10:19:42 <yitz> rwbarton: not in scope. even though really it is.
10:19:43 <ski> byorgey :)
10:20:36 <rwbarton> this is particularly confusing because Data.Attoparsec.Text.Internal.Parser = Data.Attoparsec.Internal.Types.Parser Text
10:21:04 <yitz> rwbarton: right
10:21:15 <rwbarton> you imported Data.Attoparsec.Text? and ghci thinks Parser is not in scope?
10:21:29 <yitz> rwbarton: it used to be only me who was confused, but now it seems to be also ghc.
10:21:37 <ski> (there is apparently also <http://downfor.me>)
10:21:48 <yitz> rwbarton: right. D.A.T shows at the prompt as in scope.
10:22:07 <yitz> rwbarton: and yes, i checked that it loaded the correct version of attoparsec at the beginning. :)
10:23:27 <rwbarton> well as Data.Attoparsec.Text exports Parser this is rather baffling
10:23:44 <yitz> yes
10:30:40 <roconnor_> edwardk: does this make sense: mkIsoLens :: (a -> b) -> (b' -> a') -> LensFamily a a' b b' and if so what does it mean?
10:30:59 <edwardk> roconnor_: yes.
10:31:04 <edwardk> i have that as well
10:31:09 <roconnor_> what are the laws?
10:31:11 <mm_freak> i have an IntSet which is created once, never modified and only folded (it's a set of indices)…  the construction function ensures that no value is added twice…  does it make sense to use IntSet at all?  i feel that Vector Int would be a better option
10:31:12 <edwardk> if you use the indexed family view of a lens it still makes sense
10:31:24 <mm_freak> (yes, speed is a concern…  the main concern in fact)
10:31:50 <edwardk> remember a b and a' b' aren't completely independent
10:32:02 <roconnor_> right
10:32:28 <roconnor_> (o x -> i x) and (i x' -> o x')
10:32:34 <edwardk> they are more of iso :: (Outer s i -> Inner s i) -> (Inner s j -> Outer s i) -> LensFamily …
10:32:35 <edwardk> yeah
10:33:06 <roconnor_> so what are the laws for an isomorphism family?
10:33:15 <edwardk> so it is a natural isomorphism between outer and inner
10:33:22 <edwardk> naturality
10:33:44 <edwardk> we just can't actually state the index given the type system
10:33:53 <roconnor_> naturality is free in haskell
10:34:02 <roconnor_> so it is just that they compose to the identity
10:34:04 <roconnor_> in both ways
10:34:06 <roconnor_> as usual
10:34:07 <edwardk> yes
10:34:13 <yitz> mm_freak: even a list should be faster if it's only folded. or if it's not too big.
10:34:22 <edwardk> the only unenforceable condition is the indexed family but
10:34:23 <edwardk> er bit
10:34:32 <edwardk> so the laws you have to enforce are exactly the same as before
10:34:56 <edwardk> this is why i went out of my way to call the families rather than 'polymorphic lenses' since they aren't freely polymorphic
10:35:02 <roconnor_> yep
10:35:05 <mm_freak> yitz: alright…  i'll go with Vector Int then
10:35:14 <ski> edwardk : "outer" and "inner" ? -- related to inner and outer automorphism (group) ?
10:35:15 <edwardk> and to describe the laws you really do need to constantly think about these indices
10:35:28 <mm_freak> yitz: besides speed space is also a concern, because there are lots of those sets and they can get pretty large =)
10:35:33 <edwardk> ski: nah related to the outer and inner structure you are manipulating with a lens
10:35:39 <ski> ok
10:35:55 <edwardk> outer -> (inner, inner -> outer)
10:35:55 <edwardk> with a lens family those would ideally pick up an indexing parameter
10:35:58 <yitz> mm_freak: vectors sound like a better idea, given all that
10:36:04 <edwardk> outer i -> (inner i, inner j -> outer j)
10:36:25 <edwardk> but that can't be implemented in haskell correctly
10:36:38 <edwardk> it can in agda, but its tedious ;)
10:36:39 <ski> with `i' and `j' describing some kind of current state ?
10:36:51 <edwardk> think tuples for instance
10:37:04 <roconnor_> edwardk: you can write the equations for the laws without thinking about the families
10:37:11 <edwardk> (a,b) -> (a, c -> (c, b))
10:37:11 <roconnor_> edwardk: they just appear to make no sense.
10:37:12 <DMcGill> is there a way to write something like: newtype Int2 = Int2 Int deriving (..)
10:37:13 <startling> is there a way to disable relative imports? on OSX, hakyll.hs and Hakyll.hs are the same file, so "import Hakyll" tries to import itself
10:37:14 <edwardk> yeah
10:37:26 <DMcGill> and then have Int2 derive all of Int's type classes?
10:37:27 <edwardk> here i is a and j is c
10:37:33 <ski> ah, nice
10:37:48 <yitz> DMcGill: use GeneralizedNewtypeDeriving
10:38:14 <yitz> DMcGill: you still do have to mention all of the classes you want to derive, though.
10:38:16 <edwardk> so that is a lens family for Outer i = (i, b) and Inner i = i
10:38:18 <ski> edwardk : does this generalize to manipulating all of the `a's in a structure, thus being able to change them to `b', all in one go ?
10:38:29 <c_wraith> you rarely would need more than Num and Integral, though
10:38:39 <c_wraith> (well, Eq, Ord, the other normal ones)
10:38:49 <edwardk> ski: only in limited circumstances (where there is a fixed number, etc)
10:38:58 <ski> (e.g. all the `value's in a `FiniteMap key value')
10:39:01 <edwardk> but the index can be pretty complicated
10:39:19 <edwardk> to manipulate all the values in a FiniteMap you need to use a 'setter', which isn't a full lens
10:39:30 <ski> (ideally we'd also like the transformation of `value's here to depend on the current `key' ..)
10:39:31 <edwardk> but which composes with them
10:39:32 <yitz> DMcGill: yeah i assume you must have some weird non-standard instances of Int of your own that you want to derive
10:40:06 <yitz> ok gotta run thanks for the help folks, especially rwbarton and bos !!
10:40:19 <DMcGill> well I knew about GeneralisedNewTypeDeriving, I was just looking for a little more code conciseness
10:40:38 <DMcGill> literally writing "deriving (..)" rather than "deriving (Eq, Ord, ...)"
10:40:45 <DMcGill> but I guess its not possible
10:40:51 <DMcGill> it's*
10:42:08 <yitz> zacstewart: ok try this:
10:42:08 <yitz> Share link via:
10:42:13 <yitz> oops
10:43:27 <yitz> zacstewart: ok trying again: https://docs.google.com/open?id=0B2xmwgStRt5xSkE3V0d5dzI2d0k
10:43:30 <yitz> there we go
10:43:36 <parcs`> edwardk: why is there both an outer and inner function? why not just an inner?
10:44:18 <yitz> that's haskell platform 32 bit for mac os x. temporary, while the regular download link is down.
10:44:21 <parcs`> edwardk: er, rather why not just an outer function?
10:44:33 <yitz> ok gotta go.
10:45:05 <edwardk> i'm not always fully polymorphic in the i in Inner
10:45:10 <edwardk> Lens (a,b,c) (a,b)
10:45:35 <edwardk> Lens (Cofree f a) (f (Cofree f a))
10:46:35 <alnix> Hello, I can not go on haskell.org. Do you know why?
10:46:44 <Taneb> alnix, it's down
10:46:48 <edwardk> and composability is more complicated/impossible, this is why its implemented with just the 4 type parameters
10:48:04 <alnix> Taneb: thx You have an idea of how long it'll take up ?
10:48:12 <Taneb> No idea
10:48:18 <Taneb> What do you need?
10:48:28 <alnix> read doc :)
10:48:29 <parcs`> edwardk: what would Lens (a,b,c) (a,b) look like in your outer/inner type function formulation?
10:48:43 <Taneb> What OS are you on?
10:48:45 <edwardk> parcs: the i and j would have kind (*,*)
10:49:03 * hackagebot yesod-core 1.0.1.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.0.1.3 (MichaelSnoyman)
10:49:06 <alnix> Taneb: i try to install ghc-docs on archlinux put it dwl on haskell.org
10:49:11 <Taneb> :(
10:49:12 <edwardk> i'm not saying it can be implemented, i'm saying it is a conceptual tool for thinking about the four parameters in the lens family
10:49:15 <Taneb> That won't work then
10:49:20 <MostAwesomeDude> Urgh. Is it normal for syb to cause banging of heads against keyboards?
10:49:40 <alnix> Cabal.html.tar.bz2
10:49:40 <Taneb> alnix, try http://hackage.haskell.org/package/base/
10:49:51 <alnix> ok cool
10:50:01 <alnix> Taneb: thanks
10:50:19 <Taneb> (depends what you want the docs for, that's just base. If you want, say array or comonad-transformers, you'll need to navigate hackage)
10:50:22 <Taneb> You're welcome
10:52:50 <ski> edwardk : i wish we had product kinds :(
10:53:00 <edwardk> we do
10:53:14 <ski> hm ?
10:53:23 <ski> is this with the new automatic lifting stuff ?
10:54:32 <edwardk> yes
10:55:03 <irene-knapp> http://www.downforeveryoneorjustme.com/haskell.org
11:10:52 <mcstar> my contribution to the community:
11:10:54 <mcstar> http://i.imgur.com/rOake.jpg
11:11:25 <irene-knapp> haha
11:14:26 <MostAwesomeDude> Hm. STM stuff like TChan doesn't have Show instances; should I define an orphan instance just to get my stuff working, or should I code up custom Show instances for each data type?
11:15:37 <ski> i don't see how `TChan' could have a `Show' instance (except a silly one)
11:16:04 <MostAwesomeDude> "TChan (...)" would be sufficient.
11:16:20 <MostAwesomeDude> I don't care about what's inside, but I'd like to be able to Show some records that hold TChans.
11:16:22 <ski> (well, i suppose it could print some kind of opaque reference -- but i'm not sure how useful that'd be, and how portable it'd be)
11:16:52 <ski> MostAwesomeDude : yeah, i count that among the silly ones (fails reading back with `read')
11:17:11 <ski> if you just want this for debugging purposes, go ahead
11:17:17 <MostAwesomeDude> Yeah, this is purely for debugging.
11:17:33 <ski> (but i'd prefer to not have any such instance in code which isn't just for supporting debugging)
11:19:02 <mm_freak> does repa have a noticable performance impact, if you don't use parallelization?
11:20:21 <ski> MostAwesomeDude : as to your original question, i suppose if it's for private debugging, defining an orphan instance would be ok. if it's for a debugging package which might be used with other debugging packages, it's better to avoid doing it (i.e. it's better to have such in a specific package everyone could refer to)
11:21:38 <MostAwesomeDude> ski: This is for bootstrapping, largely; as the codebase gets more mature, most of this debugging code should die.
11:21:47 <MostAwesomeDude> This is stuff like printing out network activity packet-at-a-time.
11:21:49 <DMcGill> > (proc a -> returnA -< a) 3
11:21:50 <lambdabot>   Pattern syntax in expression context: proc a -> returnA -< a
11:22:10 <ski> MostAwesomeDude : sounds fine, then
11:22:43 <ski> @type proc a -> returnA -< a
11:22:44 <lambdabot> parse error on input `->'
11:22:46 <DMcGill> how do I play with a custom arrow type in GHCi?
11:22:55 <ski> @type (proc a -> returnA -< a)
11:22:56 <lambdabot>     Pattern syntax in expression context: proc a -> returnA -< a
11:23:04 <DMcGill> callung "(proc a -> returnA -< a) 3" worked fine
11:23:10 <DMcGill> as the arrow just defaulted to (->)
11:23:11 <ski> presumably it parses the latter as a view pattern
11:23:22 <ski> DMcGill : i don't think lambdabot has `ArrowSyntax' enabled
11:24:34 <ski> DMcGill : ooc, does `($ 3) proc a -> returnA -< a' work ?
11:25:24 <ski> (s/ArrowSyntax/Arrows/)
11:25:34 <DMcGill> ski: yes
11:25:41 <DMcGill> but it doesn't for my custom arrow
11:26:03 <ski> nice that you don't need to say `... $ proc a -> ..a..', with the `$', then :)
11:26:32 * ski would prefer it if we could also say `forM_ (...) \a -> ..a..', skipping the `$' before the `\'
11:26:38 <DMcGill> ha
11:27:32 <ski> (i'm looking for ways to cut down on the few `$'s i have left littering my code)
11:28:14 <shawng> Hello
11:28:21 <byorgey> hi shawng
11:28:22 <ski> (ideally `runBlah foo do ...' would also work)
11:28:34 <shawng> I have a problem relating to list comprehension
11:28:40 <shawng> can anyone help?
11:28:46 <ski> what is the problem ?
11:28:54 <DMcGill> I guess there's no way to turn an arrow into a function in general right? Hence why Kleisli comes with runKleisli
11:28:58 <shawng> {-| PROBLEM!:
11:28:59 <shawng> when we take the `elem` function with a right operand = string literal AND a left operand that is a list of string literal elements whose character literal composition includes uppercase and lowercase characters in ASCII as well as whitespace charcters checking for a string literal of the same composition is problematic. But why?
11:29:03 <shawng> a. are we ignoring the predicate?
11:29:20 <ski> (whether anyone can help remains to be seen. it's better to state your problem at the start, instead of asking of anyone/someone can help)
11:29:31 <MostAwesomeDude> This sounds like homework.
11:29:32 <ski> DMcGill : *nod*
11:29:37 <byorgey> DMcGill: right, there's not
11:29:58 <mcstar> its even better tp provide code, than describe it in english
11:30:06 <pcavs> haskell.org down for anyone else?
11:30:09 <shawng> ok
11:30:10 <byorgey> shawng: is this a homework problem for a class?
11:30:29 <byorgey> pcavs: yes.
11:30:33 <alanz> pcavs: yes
11:30:33 <pcavs> =(
11:30:42 <shawng> byorgey: no im crazy enough to embrace Haskell as my professional language
11:31:00 <mcstar> he didnt mean it like that...
11:31:02 <alanz> pcavs:my traceroute terminates in hetzner.de
11:31:04 <shawng> ummm
11:31:04 <MostAwesomeDude> shawng: Okay. When you say "problematic," what is the problem, precisely?
11:31:19 <shawng> so what is the appropriate way to post my code?
11:31:24 <ski> @where hpaste
11:31:24 <lambdabot> http://hpaste.org/
11:31:46 <shawng> ok one sec thank you
11:32:03 <MostAwesomeDude> Ugh, why is naming things hard? data UnnamedType = Airborne | Grounded -- what should I call this type?
11:32:39 <mcstar> AngleOrMan
11:32:39 <Iceland_jack> MostAwesomeDude: Aloft?
11:33:03 <Taneb> IsAirborne?
11:33:05 <byorgey> MostAwesomeDude: PlaneStatus? TeenagerWhoTendsToDriveWayTooFastStatus?
11:33:12 <MostAwesomeDude> byorgey: Ha!
11:33:18 <Taneb> Bool?
11:33:24 <MostAwesomeDude> This is for telling whether a person is in the air, or not in the air.
11:33:36 <MostAwesomeDude> Taneb: Well, yes, but as its own type. For safety.
11:33:42 <Taneb> Okay
11:33:43 <ski> `LocalDimension' ?
11:33:51 <Taneb> I'm sticking with IsAirborne
11:34:20 <MostAwesomeDude> I really dig the feel of "aloft." It's such a peaceful word for the concept of a player having jumped off a cliff.
11:34:38 <byorgey> PersonOrientationVisAVisAir
11:34:55 <startling> seconding aloft
11:35:26 <byorgey> replacing Airborne with Aloft sounds good.  Not so sure about Aloft as a name for that type.
11:36:24 <MostAwesomeDude> I think I'm gonna go with data Airborne = Grounded | Aloft -- thanks!
11:36:44 <ski> `AlowOrAloft' ?
11:37:19 <eikke> has anyone ever heard about type-level (statical) alignment-information for Vectors?
11:37:39 <ski> <http://en.wiktionary.org/wiki/alow>
11:37:52 <rwbarton> Altitude?
11:37:59 <mcstar> UnnamedType#678
11:38:03 <rwbarton> sort of suggests more specificity
11:38:27 <ski> mayhaps `QualitativeAltitude'
11:39:08 <ski> instead of `Grounded' or `Alow', `Earthbound' could work
11:39:58 <startling> airborne/earthbound are nice together
11:40:15 * ski . o O ( <http://en.wikipedia.org/wiki/EarthBound> )
11:40:17 <jackdawjack> does anyone know anything about haskell.org being down?
11:40:21 <ski> yes
11:41:03 <MostAwesomeDude> Ha, "QualitativeAltitude" is too good. Kind of a pain to type constantly though.
11:41:06 <hpaste> Shawn pasted “sorting dinosaur tokens” at http://hpaste.org/70899
11:41:29 <ski> emacs has `M-/'
11:41:34 <startling> QuantumAltitude
11:41:41 <shawng> ok
11:42:11 <shawng> ready or not voilà: http://hpaste.org/70899
11:42:35 <ClaudiusMaximus> Qualtitude
11:43:53 <ski> shawng : i would replace  [y|y <- lcd, cd `elem` lcd]  with  [y|cd `elem` lcd, y <- lcd]  -- better to fail fast
11:43:57 <shawng> *correction: i.e. <str_lit> `elem` <list_of_string_lit>, left operand != a list
11:44:14 <ski> @type elem
11:44:15 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:44:19 <mcstar> elem searches for a match in a list
11:44:47 <mcstar> > "ab" `elem` ["cd","ab","ef"]
11:44:49 <lambdabot>   True
11:45:42 <mcstar> shawng: the left operand is, technically a list, but doesnt matter
11:45:53 <ski> shawng : you have repetition in `colored_dino_list' -- is that intended ?
11:46:58 <mcstar> [x++y++z|x <- xs, y <- ys, z <- zs] is like a cartesian product
11:47:31 <hpaste> “Mark Amber” pasted “Yesod Install” at http://hpaste.org/70900
11:48:07 <markamber> http://hpaste.org/70900 I am getting an error installing with a new yesod scaffold
11:48:13 <ski> shawng : also, s/Tyrannasaurus/Tyrannosaurus/ and s/Terradactyle/Pterodactyl/ (or maybe "Pterosaur") ?
11:48:37 <nand`> :t liftA3 ((++) .: (++))
11:48:39 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a -> f a -> f a -> f a
11:48:55 <MostAwesomeDude> ski: "Teradaktil" :3
11:49:30 <nand`> > liftA3 ((++) .: (++)) ["red","green","blue"] [" "] ["dinosaur","kitten","dog"]
11:49:32 <lambdabot>   ["red dinosaur","red kitten","red dog","green dinosaur","green kitten","gre...
11:49:34 <mcstar> played much with dinos?
11:49:41 <DMcGill> so going back to my earlier question about arrows
11:50:08 <DMcGill> you can't in general turn an arrow into a function. However, all of the arrow examples I've seen so far have been very function-like
11:50:18 <DMcGill> what are some arrows that aren't similar to functions?
11:52:35 <c_wraith> DMcGill: you can't have arrows that are not some kind of wrapper around functions, due to the requirements of the arr function
11:52:53 <c_wraith> :t arr
11:52:54 <MostAwesomeDude> Huh, so Hackage is up, but h.org itself is down? Weird.
11:52:55 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
11:53:19 <byorgey> c_wraith: that's not how I would interpret arr.  arr just means that some *subset* of any arrow type must correspond to wrappers around functions.
11:53:35 <byorgey> c_wraith: but there can certainly be richer structure which doesn't allow you to turn an arrow back into a function in general.
11:54:01 <byorgey> DMcGill: how about the Automaton arrow?  http://hackage.haskell.org/packages/archive/arrows/0.4.1.2/doc/html/Control-Arrow-Transformer-Automaton.html
11:54:07 <c_wraith> I suppose that's true..  But I'd still argue that it means that the type must be pretty similar to a function
11:54:17 <c_wraith> If it must be able to encode arbitrary functions
11:56:39 <rwbarton> @src Arrow
11:56:39 <lambdabot> class Arrow a where
11:56:39 <lambdabot>     arr, pure   :: (b -> c) -> a b c
11:56:39 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
11:56:39 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
11:56:39 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
11:56:41 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
11:56:43 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
11:56:59 <startling> hm, do arrows make a better fit for parser-combinators than monads?
11:57:13 <ski> MostAwesomeDude : Banjo-Tooie ?
11:57:45 <MostAwesomeDude> ski: Oh, I didn't even think of that. That's a nostalgia trip right there.
11:57:47 <weexplat> dylukes: where are you looking at these indexed monads in pipes?  is there a post or a webpage somewhere?
11:58:04 <ski> MostAwesomeDude : i suppose maybe Chrono Trigger as well
11:58:09 <startling> in functional pearls: monadic parsing in haskell, they use a monad that just wraps a function. doesn't an arrow make sense there?
11:58:18 <ski> MostAwesomeDude : which one did you had in mind ?
11:58:40 <MostAwesomeDude> ski: Neither, I was just thinking of a phonetic spelling for that word.
11:58:46 <MostAwesomeDude> I miss Chrono Trigger.
11:58:54 <ski> startling : "hm, do arrows make a better fit for parser-combinators than monads?" -- well, that's only the reason they were invented, so ..
11:59:57 <startling> ski: o rly
12:00:06 <startling> awesome. thanks
12:01:11 <ski> startling : read the original paper "Deterministic, Error-Correcting Combinator Parsers" by S. Doaitse Swierstra & Luc Duponcheel in 1996 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.2760>
12:02:46 <startling> ski: very interesting. thanks
12:04:27 <strager> ski: Is there a modern implementation?
12:04:40 <hpaste> Shawn pasted “sorting dinosaur tokens: to ski” at http://hpaste.org/70901
12:04:40 <strager> of a parser combinator library using arrows
12:04:54 <shawng> http://hpaste.org/70901
12:04:56 <ski> startling : also see the other references at <http://www.haskell.org/arrows/biblio.html> (since <haskell.org> is currently down, try <http://webcache.googleusercontent.com/search?q=cache:dyrzyuV1aTQJ:http://www.haskell.org/arrows/biblio.html> in the meantime)
12:05:09 <rwbarton> it looks like newtype I b c = I Int; then (up to newtype (un)wrapping) arr _ = 0; pure _ = 0; (>>>) = (+); first = id; second = id; (***) = (+); (&&&) = (+) ought to be a valid Arrow instance
12:05:16 <shawng> i.e. learning from ski >> http://hpaste.org/70901
12:05:33 <ski> shawng : yeah, i've only seen that link three times now :)
12:05:52 <ski> (note hpaste pasted it for you above, just as it did with the previous paste)
12:06:09 <shawng> ski: click it
12:06:12 <rwbarton> should work for any monoid
12:06:36 <shawng> ski: you can see my style of thinking
12:06:56 <ski> shawng : next time, *annotate* the original paste (using the "Annotate" button at the top) with related pastes, instead of creating completely new paste pages
12:06:58 <shawng> ski: it's important to know if you think I can be clear in English
12:06:58 <startling> ski: btw, do you like combinatory logic or racing down mountains on slats of wood?
12:07:03 <JoshTriplett> Does any kind of abstraction exist over things like lazy ByteString, strict ByteString, String, Text, etc, that would allow me to generically write an FFI interface to cover all of them?  In other words, a typeclass with functions like peekCStringLen and withCStringLen?
12:07:20 <ski> startling : the former is the reason for the nick, yes
12:07:30 <shawng> ski: sure thing
12:07:43 * byorgey likes both
12:07:46 <byorgey> though not at the same time
12:08:37 <nand`> what's all the hubbub about SKI? I thought it's equivalent to the simpler SK
12:08:56 <ski> shawng : the "predicate" there is usually called a "guard", and the "drawing/binding procedure" is usually called a "generator"
12:09:27 <ski> shawng : regarding  cd `elem` lcd  note that this doesn't use `y' which is bound by  y <- lcd
12:09:34 <JoshTriplett> nand`: True, in that you can write I in terms of S and K.
12:09:39 <shawng> ski: thank you ski
12:09:47 <nand`> so why ‘ski’ and not ‘sk’
12:09:50 <nand`> or was ‘sk’ taken
12:09:59 <JoshTriplett> nand`: I exists for much the same reason that + does in regexes: convenience.
12:10:11 <ski> shawng : in a list comprehension, it starts by "computing" the first thing after the `|', then the next, &c., and finally the thing before the `|'
12:10:58 <ski> nand` : at the time i started using IRC long ago, i was reading some articles and papers pertaining to "SKI combinators"
12:11:47 <ski> shawng : now, actually for each possible value of `y' in  y <- lcd  it will "compute" all the things after  y <- lcd
12:12:20 <ski> shawng : so, in your version, for each possible value of `y', it checked the guard (even though the guard didn't actually depend on `y')
12:12:52 <ski> shawng : while in my version, i check the guard once at the start, and then (if it succeeds) do i select each `y' from `lcd'
12:13:21 <ski> shawng : iow, your version recomputes the guard as many times as there are elements of `lcd', while mine computes the guard exactly once
12:14:12 <ski> shawng : however, declaratively, the two versions are basically the same
12:14:29 <ski> (there's a slight difference in case the guard is bottom)
12:14:57 <ski> (JoshTriplett : s/I exists/I exist/)
12:15:30 <rwbarton> nice philosophy
12:15:30 <JoshTriplett> ski: :P
12:15:41 <ski> {:
12:16:03 <DexterLB> if I have a couple of maybes, one superior to the other, how can I extract the more superior Just value? (or Nothing if both maybes are Nothing)
12:16:24 <rwbarton> define "superior"?
12:16:27 <shawng> pardon but im losing focus. I'm away for 10 min. I'm copying and pasting what you say ski
12:18:03 <DexterLB> rwbarton: if the superior maybe is Just X, return it, regardless of the inferior one. If the superior maybe is Nothing, return the inferior maybe
12:18:19 <DexterLB> sorry I'm not explaining myself correctly
12:18:30 <rwbarton> can I replace "superior" by "first" and "inferior" by "second"
12:18:30 <DexterLB> that must be a common task, aka there should be a function to do it
12:18:42 <ski> should "superior" be "preceding" ?
12:18:54 <DexterLB> probably
12:18:56 <rwbarton> if so it's called mplus
12:19:02 <rwbarton> I think
12:19:04 <rwbarton> @type mplus
12:19:05 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
12:19:11 <MostAwesomeDude> > Just 1 `mplus` Just 2
12:19:12 <lambdabot>   Just 1
12:19:19 <ski> > Nothing `mplus` Just False
12:19:19 <MostAwesomeDude> > Nothing `mplus` Just 2
12:19:20 <lambdabot>   Just False
12:19:20 <lambdabot>   can't find file: L.hs
12:19:29 <JoshTriplett> That's a fascinating race.
12:19:35 <ski> > Nothing `mplus` Nothing
12:19:36 <lambdabot>   Nothing
12:19:43 <ski> > Just () `mplus` Nothing
12:19:44 <lambdabot>   Just ()
12:19:58 <ski> @src Maybe mplus
12:19:58 <lambdabot> Nothing `mplus` ys = ys
12:19:58 <lambdabot> xs      `mplus` ys = xs
12:20:08 <MostAwesomeDude> Just 1 `mplus` Nothing `mplus` Just 3
12:20:11 <MostAwesomeDude> > Just 1 `mplus` Nothing `mplus` Just 3
12:20:12 <lambdabot>   Just 1
12:20:19 <shawng> lost focus there ski, the predicate is called?
12:20:22 <ski> > mconcat [Just 1,Nothing,Just 3]
12:20:24 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:20:24 <lambdabot>    `Data.Monoid.Monoid t'
12:20:25 <lambdabot>  ...
12:20:39 <JoshTriplett> o_O
12:20:40 <hpaste> “Jonathan Fischoff” pasted “Configurable Error Reporting: Take 2” at http://hpaste.org/70902
12:20:43 <shawng> attention span is literally 10 seconds right now
12:20:50 <nand`> > Just 1 ++ Just 2
12:20:52 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:20:52 <lambdabot>    `Data.Monoid.Monoid t'
12:20:53 <lambdabot>  ...
12:20:59 <ski> oh, right, should use `msum'
12:21:05 <ski> > msum [Just 1,Nothing,Just 3]
12:21:06 <lambdabot>   Just 1
12:21:08 <JoshTriplett> Ah, true.
12:21:08 <jfischoff> @tell JoeyA: let me know what you think of my updated version http://hpaste.org/70902
12:21:09 <lambdabot> Consider it noted.
12:21:15 * ski always confuses those ..
12:21:28 <DexterLB> yep, mplus is what I was looking for
12:21:29 <DexterLB> thanks
12:21:30 <shawng> ski: so the predicate is called?
12:21:38 <ski> DexterLB : and `msum', if you have many of them
12:21:45 <rwbarton> that's why it took me about a minute to remember which function DexterLB wanted
12:21:46 <ski> shawng : "guard"
12:22:15 * ski goes to make some tea
12:22:15 <shawng> ski: thx bro. you don't mind if I 'bro' you do you? haha!
12:22:19 <ski> shawng : would you like some tea too ?
12:22:25 <jfischoff> if anyone has any suggestions on how to make my configurable error reporting setup design better, I would appreciate it http://hpaste.org/70902
12:22:43 <shawng> ski: haha, I knew it was you
12:23:04 * ski prefers "foo" to "bro"
12:23:33 <jfischoff> is there a way to automatically update your cabal dependencies from your imports?
12:23:36 <ski> ("I knew it was you" -- meaning ?)
12:26:23 <nand`> > getFirst . mconcat . map First $ [Just 1, Nothing, Just 3]
12:26:25 <lambdabot>   Just 1
12:27:32 <copumpkin> > msum [Just 1, Nothing, Just 3]
12:27:33 <lambdabot>   Just 1
12:28:41 <startling> @hoogle (a -> b) -> (a, c) -> (b, c)
12:28:41 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
12:28:42 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
12:28:42 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
12:29:00 <copumpkin> startling: the other side is just fmap
12:30:10 <jfischoff> is there a way to create cabal dependencies that are shared between the library, executable, and tests?
12:30:14 <startling> copumpkin: oh, neat
12:30:21 <startling> any reason it's the second and not the first?
12:30:40 <ski> > ala First (mconcat .: map) [Just 1, Nothing, Just 3]
12:30:42 <lambdabot>   Just 1
12:30:43 <ski> > ala First Data.Foldable.foldMap [Just 1, Nothing, Just 3]
12:30:45 <lambdabot>   Just 1
12:31:15 <ski> startling : because the second is the last type argument of `(,)'
12:31:31 <startling> ski: ah
12:31:47 <rwbarton> @type first -- there's also this, was it already mentioned?
12:31:48 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
12:32:00 <ski> startling : you can say `instance Functor ((,) a)' (meaning basically `instance Functor (a,)'), but you can't say `instance Functor (\a -> (a,b))' (meaning `instance Functor (,b)')
12:32:04 <startling> is there a way I can import a class and all its methods?
12:32:07 <startling> ski: right, yeah
12:32:14 <startling> *typeclass
12:32:14 <ski> `second' and `fmap' differ subtly
12:32:23 <rwbarton> @type first `asTypeOf` (undefined :: a -> b)
12:32:24 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
12:32:31 <rwbarton> oh oops
12:32:41 <ski> @src (->) second
12:32:41 <lambdabot> second f = id *** f
12:32:45 <ski> @src (->) (***)
12:32:45 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
12:32:50 <ski> meaning
12:33:02 <ski>   second f ~(x,y) = (x,f y)
12:33:04 <ski> while
12:33:06 <ski> @src (,) fmap
12:33:06 <lambdabot> fmap f (x,y) = (x, f y)
12:33:53 <ski> @type \f x -> second f x  -- eta-expand is simpler
12:33:55 <lambdabot> forall b c d. (b -> c) -> (d, b) -> (d, c)
12:34:10 <copumpkin> > case fmap (+1) undefined of (x, y) -> 5
12:34:12 <lambdabot>   *Exception: Prelude.undefined
12:34:16 <copumpkin> > case second (+1) undefined of (x, y) -> 5
12:34:18 <lambdabot>   5
12:34:52 <strager> Interesting.
12:34:58 <startling> anyway, I'm trying to define first and second for a type.
12:35:01 <ski> (and `fmap' has to be defined as above, to make `fmap id = id' even for partially defined values)
12:35:06 <startling> so I cant really use those. :)
12:35:47 <ski> (and iitc `(***)' also have to be defined that way for functions ..)
12:35:56 <ski> startling : which type ?
12:36:13 <startling> ski, just a dumb little function container
12:36:19 <startling> i'm playing with arrows
12:36:53 <ski> shawng : you say "checking for a string literal in the list of the same composition is problematic." -- but i'm not sure what the problem you're seeing is
12:37:04 <JoshTriplett> Does any typeclass exist to abstract over Foreign.C.String.peekCStringLen, Data.Bytestring.packCStringLen, and so on?
12:37:24 <Axman6> A poem for the parallel programmer: http://insidehpc.com/2012/07/04/the-raving-with-a-nod-to-eap/
12:45:13 <illissius> JoshTriplett: not that I know of
12:45:25 <JoshTriplett> illissius: Oh well.  I've written one myself now. :/
12:45:55 <illissius> JoshTriplett: that's what I was going to suggest :)
12:46:07 <illissius> JoshTriplett: out of curiosity, does it have any instances besides String and ByteString?
12:46:17 <JoshTriplett> illissius: FilePath.
12:46:26 <illissius> FilePath is just String last I checked.
12:46:31 <JoshTriplett> illissius: system-filepath
12:46:35 <illissius> ah
12:46:38 <JoshTriplett> illissius: http://hackage.haskell.org/package/system-filepath-0.4.6
12:51:07 <user317> is there any way to pass XFlexibleInstances to cabal install?
12:51:39 <ski> hm, that poem reminds me of <http://blogg.passagen.se/anne-sofie2/entry/p_class_msonormal_style_margin10> (warning : in swedish) (also at <http://hack.org/mc/writings/hackerdom/hacket.text> with broken "åäö")
12:52:06 <irene-knapp> hm
12:52:54 <JoshTriplett> user317: If a cabal project needs FlexibleInstances, it should be declaring that itself.
12:53:03 <JoshTriplett> @type fromIntegral
12:53:05 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:53:16 <user317> ugh...
12:53:29 <jfischoff> maybe with --configure-option ?
12:55:13 <beefcube> haskell.org is unresponsive
12:55:19 <ski> yes
12:55:40 <JoshTriplett> Has been for a little while now.
12:55:47 <JoshTriplett> Fortunately hackage works.
12:56:08 <JoshTriplett> @hoogle Num n => n -> Int
12:56:08 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
12:56:09 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
12:56:09 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
12:56:17 <JoshTriplett> OK, stupid question: how do I write that?
12:56:47 <JoshTriplett> @type fromIntegral
12:56:49 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:57:04 <JoshTriplett> That gets me Int -> n; how do I convert n -> Int?
12:57:22 <JoshTriplett> @type tOint
12:57:23 <rwbarton> you can't write that
12:57:24 <lambdabot> Not in scope: `tOint'
12:57:27 <JoshTriplett> @type toInt
12:57:28 <lambdabot> Not in scope: `toInt'
12:57:53 <JoshTriplett> rwbarton: OK, skipping past that part...
12:58:11 <JoshTriplett> rwbarton: Let me ask the higher-level question.
12:59:07 <JoshTriplett> Given a function peekCStringLen :: Stringable s => (CString, Int) -> IO s, how do I write peekCStringLenNum :: (Stringable s, Num n) => (CString, n) -> IO s?
12:59:12 <nand`> you can write some *similar* functions on less-general typeclasses like Integral or RealFrac
12:59:23 <rwbarton> you still can't, with Num
12:59:28 <rwbarton> Num has instances like Complex Double
12:59:37 <nand`> or functions
12:59:39 <JoshTriplett> rwbarton: I have no problem with a partial function, but fine.
12:59:40 <rwbarton> yes
12:59:44 <illissius> JoshTriplett: you can do it with Integral n
12:59:51 <JoshTriplett> Integral might suffice.
12:59:52 <illissius> is there a particular reason you need Num?
13:00:14 <JoshTriplett> Not particularly, other than that the symmetric function for withCStringLen worked with Num.
13:00:20 <nand`> I would write: peekCStringLenGeneric :: (Stringable s, Integral n) => (CString, n) -> IO s
13:00:25 <nand`> following a trend set by some Prelude functions
13:00:27 <nand`> :t genericLength
13:00:29 <lambdabot> forall b i. (Num i) => [b] -> i
13:00:35 <JoshTriplett> Generic sounds like a handy suffix; thanks.
13:00:36 <nand`> uh
13:00:43 <nand`> that one is actually Num, bad example
13:00:45 <fmap> can i somehow output a newline in #define macro?
13:00:47 <rwbarton> genericPeekCStringLen? :)
13:00:51 <illissius> hm
13:01:01 <nand`> :t genericDrop
13:01:02 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
13:01:18 <JoshTriplett> Does this type signature still make sense, or should it use Integral as well: withCStringLenNum :: (Stringable s, Num n) => s -> ((FCS.CString, n) -> IO a) -> IO a
13:01:19 <JoshTriplett> ?
13:02:04 <rwbarton> it makes sense in that you can implement it
13:02:05 <illissius> oh right. Num is okay if you only output a number (fromInteger), you need Integral if you want one as input (toInteger)
13:02:19 <JoshTriplett> rwbarton: Yeah, that much I knew, having implemented it. :)
13:02:29 <JoshTriplett> illissius: OK, fair enough.
13:02:44 <JoshTriplett> @hoogle Integral i => i -> Int
13:02:45 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
13:02:45 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
13:02:45 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
13:03:00 <nand`> I think that function is redundant, looks like you could instead do: getCStringLen :: (Stringable s, Num n) => s -> IO (FCS.CString, n); and use >>= or >=> to get a (FCS.CString, n) -> IO a after it
13:03:05 <JoshTriplett> Could I get a (h)Int please? :)
13:03:15 <nand`> :t fromIntegral
13:03:17 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:03:33 <JoshTriplett> Oh, right. :)
13:03:50 <rwbarton> withCString frees the C string afterwards I expect
13:04:07 <JoshTriplett> rwbarton: Yup.
13:04:21 <rwbarton> in general adding type class polymorphism everywhere just because you can is not good
13:04:28 <nand`> I see
13:04:37 <JoshTriplett> rwbarton: Granted, but in this case I actually do need it.
13:04:48 <rwbarton> really
13:05:12 <JoshTriplett> rwbarton: Specifically, I'm writing FFI bindings, and CStringLen uses Int but I need CUInt and similar.
13:05:18 <JoshTriplett> Or CULong, or CSize...
13:05:32 <rwbarton> well you clearly don't *need* it, you can just insert toIntegral wherever
13:05:39 <nand`> those are all Integral, right?
13:06:02 <JoshTriplett> nand`: Yes.
13:06:09 <ski> @type genericTake
13:06:10 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
13:06:17 <ski> nand` : how about that ^ one ?
13:06:23 <rwbarton> inserting toIntegral is preferable IMO because it may make you think about whether the conversion is really okay each time you use it
13:06:23 <JoshTriplett> rwbarton: Not quite.  c2hs doesn't allow arbitrary expressions in its marshallers, so I need a function wrapper.
13:06:32 <startling> is this the best way to do this? https://gist.github.com/b20d72980882c2242816 it seems unwieldy
13:06:35 <nand`> ski: same type as genericDrop :P
13:06:50 <ski> nand` : oh, missed you already said `genericDrop'
13:08:42 <nand`> startling: why not Route { read :: m ByteString, write :: ByteString -> m () }; and then routeFile a b = Route (readFile a) (writeFile b)
13:08:56 <startling> nand`, oh nice
13:09:00 <startling> nand`: didn't think of that
13:13:08 <JoshTriplett> @hoogle toIntegral
13:13:09 <lambdabot> No results found
13:13:15 <JoshTriplett> @hoogle Integral
13:13:16 <lambdabot> Prelude class (Real a, Enum a) => Integral a
13:13:16 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
13:13:16 <lambdabot> Data.Data mkIntegralConstr :: Integral a => DataType -> a -> Constr
13:13:50 <nand`> (what type is toIntegral supposed to have?)
13:14:20 * hackagebot test-simple 0.1.1 - Simple Perl inspired testing  http://hackage.haskell.org/package/test-simple-0.1.1 (BorisSukholitko)
13:14:25 <nand`> (we've established that Num n, Integral i => n -> i  isn't possible)
13:15:29 <JoshTriplett> nand`: More that I wondered why I was using fromIntegral to produce an Integral. :)
13:15:46 <JoshTriplett> Yay for superclasses.
13:16:17 <nand`> let coerceIntegral = fromIntegral :: (Integral a, Integral b) => a -> b -- happy?
13:16:43 <JoshTriplett> nand`: No, fromIntegral makes sense; I just had to think about it for a minute. :)
13:24:05 <Enalicho> If I have a function with type "Person -> [Person] -> Person", and I want my function to return Null, should I just create a Null Person?
13:24:25 <DMcGill> Enalicho: Use the Maybe type
13:24:40 <DMcGill> so you'd either return (Just person) or Nothing
13:24:49 <Enalicho> Hot, that's what I'm after
13:24:51 <Enalicho> thanks
13:24:51 <Enalicho> :)
13:24:55 <DMcGill> `Nothing' in this case would be the same as null
13:25:13 <donri> also, what does the function do?
13:25:24 <DMcGill> if you find yourself checking for Nothing and if there is a person then do something
13:25:39 <DMcGill> look at functions like fmap and >>= and so on, they abstract all that away
13:30:07 <roconnor_> I need a name for a module that says: if you abuse the preconditions of these functions you will get unexpected results, but doesn't say it might wipe your harddisk.
13:31:00 <kallisti> are there any plans to have GHC properly recompile modules with TH that refers to external resources?
13:31:01 <Axman6> Data.UnsafeReadTheDocsOrYoullBeSorry.foo
13:31:06 <startling> is there a way I can turn a Text.Blaze.HTML into a [Node]from here: http://hackage.haskell.org/packages/archive/xmlhtml/0.2.0.2/doc/html/Text-XmlHtml.html#t:Node
13:31:09 <startling> ?
13:31:17 <kallisti> similar to what the yesod command line utility currently does?
13:31:50 <kallisti> or are there any workarounds for the time being?
13:32:06 <donri> kallisti: it already does that?
13:32:13 <kallisti> oh.
13:32:18 <kallisti> so then yesod docs are out of date?
13:33:14 <donri> kallisti: http://hackage.haskell.org/packages/archive/template-haskell/2.7.0.0/doc/html/Language-Haskell-TH-Syntax.html#v:addDependentFile
13:33:35 <kallisti> aha
13:33:48 <donri> it's what yesod stuff use too
13:34:59 <donri> new in 2.7 though, looks like
13:35:11 <jfischoff> roconnor_: Brittle?
13:35:46 <kallisti> donri: yes I recall reading somewhere in the yesod book that the yesod CLI had to check modification times for external files as a workaround to that problem.
13:36:16 <kallisti> good to see it's fixed.
13:36:40 <Leprechankh> @quote Kukkua
13:36:41 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
13:38:22 <startling> oh awesome, it's in xmlhtml already: http://hackage.haskell.org/packages/archive/xmlhtml/0.2.0.2/doc/html/Text-Blaze-Renderer-XmlHtml.html
13:39:03 <donri> roconnor_: "Weak", as in "weak guarantees", though not sure i like it myself :p
13:39:09 <cesip> has anyone in their newbie days had problems understanding why curry and uncurry are defined as they are and not, uhm, the other way around?
13:39:12 <cesip> because i do
13:39:42 <kallisti> so I was considering using QuickCheck to generate proper testcases for my webdriver library. I realized it would probably be nice to be able to generate arbitrary XPath expressions, CSS paths, ID attributes, name attributes, and CSS class names  from a given HTML document.
13:39:45 <nand`> curry takes an uncurried function and curries it
13:39:47 <kallisti> is this something that's already been done?
13:39:50 <nand`> uncurry takes a curried function and uncurries it
13:39:55 <cesip> yes, that much i understand
13:40:00 <cesip> but, say,
13:40:05 <cesip> curry :: (a,b) -> c) -> (a -> b -> c)
13:40:05 <cesip> curry g x y = g (x,y)
13:40:12 <kallisti> does it warrant a library for it? I was thinking it should be pretty easy to make a ADT with an Arbitrary instance.
13:40:13 <cesip> i would naively expect it to be exactly the other way roun d
13:40:20 <cesip> *round
13:40:46 <nand`> I don't see why
13:40:54 <donri> cesip: "g" is a function that expects a tuple
13:41:55 <cesip> aaaaaaah, that was the hint i needed
13:42:04 <donri> note that, curry :: ((a, b) -> c) -> a -> b -> c, those added parenthesis in yours might serve to confuse you
13:42:15 <zacstewart> why oh why couldn't haskell.org just have a magnet link download
13:42:20 <nand`> perhaps more clearly written as curry g = \x y -> g (x,y)
13:42:20 <djhworld_> is haskell.org down for anyone else? getting request timeouts here
13:42:32 <zacstewart> Yes
13:42:36 <cesip> right, right
13:42:38 <donri> g :: (a,b) -> c; x :: a; y :: b
13:42:38 <cesip> now i get it
13:42:41 <djhworld_> damnit
13:42:44 <donri> \o/
13:42:45 <cesip> the parentheses were the confusing part
13:42:52 <nand`> or indeed curry g = g . (,)
13:43:08 <illissius> roconnor_: would it break referential transparency? if so I would still go with Unsafe. if not, I don't know :) Data.ROConnor.BeCareful? UnenforcedPreconditions?
13:43:32 <donri> cesip: the trick is that if you don't pass in the "a" and "b" parameters, you're left with, curry g :: a -> b -> c
13:45:28 <cesip> ha, i love this channel. i was staring at the definitions in darkness two minutes ago
13:45:37 <donri> :)
13:47:25 <donri> also, a -> b -> c -> d  ==  (a -> (b -> (c -> d))), or for that matter, a -> (b -> (c -> d)), or a -> (b -> c -> d)...
13:47:32 <donri> (thus, currying.)
13:47:49 <mcstar> you could have said -> is right associative
13:48:25 <donri> not if by "you" you meant me :) i can never remember which you call right and which you call left associative (either makes as much sense for me)
13:48:54 <mcstar> donri: you just gave an example of it
13:49:21 <mcstar> i mean, from that it is clear, what kind of associativity it has
13:49:23 <donri> sure, but to me you might as well call that left associative :p
13:50:09 <startling> urgh, what's the difference between blaze-html-0.4.3.4:Text.Blaze.Internal.Html and Text.Blaze.Html.Html?
13:50:36 <Clint> how well you've imported it, probably
13:50:45 <donri> startling: there shouldn't be any, but you might have multiple versions installed if you're having problems?
13:50:54 <aib> sequence :: [m a] -> m [a] -- looks like it could be more 'monadic'? something like n m a -> m n a maybe? does that even make sense? (Monad m, Monad n)
13:51:15 <startling> yeah, I'm getting Couldn't match expected type `blaze-html-0.4.3.4:Text.Blaze.Internal.Html' with actual type `Text.Blaze.Html.Html'
13:51:53 <rwbarton> [m a] -> m [a] is an instance of n (m a) -> m (n a)
13:51:57 <donri> startling: try ghc-pkg unregister blaze-html or something like that
13:52:02 <rwbarton> @type Data.Traversable.sequence
13:52:03 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
13:52:14 <startling> oh, yup, i've got two versions of blaze-html
13:52:16 <roconnor_> illissius: ya, the module is, unfortunately, perfectly safe.
13:52:25 <roconnor_> illissius: I'm using the name Unchecked at the moment
13:52:59 <donri> Unenforced?
13:53:06 <donri> Deforced!
13:53:10 <aib> rwbarton: ah, there is already such a version. thanks :)
13:55:40 <startling> donri, upgrading xmlhtml fixed it, fwiw. presumably the new version uses the newer blaze-html
13:55:57 <donri> oh, there's heist for blaze-html 0.5 now?
13:56:10 <donri> stepcut: ^
13:56:43 <stepcut> heist has had a some basic blaze-html integration for a while
13:57:19 <stepcut> I forget the specifics but basically it just renders html as a string and sticks that as pre-escaped html into something else
13:57:28 <donri> stepcut: i meant because someone had problems with happstack-heist recently because of blaze
13:57:37 <stepcut> oh
13:57:41 <stepcut> hmm
13:57:48 <stepcut> need scoutess now
13:57:51 <donri> :)
13:58:16 <donri> looking at hackage, i'd expect things to work now though
13:58:48 <startling> yeah, heist says blaze-html (≥0.4 & <0.6)
13:58:50 <startling> thankfully
13:59:36 <donri> that's new since jun 17 though :)
13:59:52 <startling> I feel like 80% of my haskell code is glue code trying to connect 3 or more libraries
13:59:57 <startling> about 20% is clever/fun stuff
14:00:09 <donri> startling: you need more happstack!
14:00:33 <startling> donri: this is for statically generating html. :(
14:02:38 <donri> ah, i misinterpreted anyway
14:05:18 <virkony> haskell.org is down?
14:05:43 <donri> parts of it seems to be, yes
14:09:25 * hackagebot uuid 1.2.7 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.7 (AntoineLatter)
14:10:41 <roconnor_> is there an easy way to only spell check lines beginning with -- ?
14:10:55 <tertl6> write a spell checker that does that
14:11:25 <tertl6> or just add if (contains "--"
14:11:30 <tertl6> spellcheck
14:11:38 <virkony> quick question: is there any way to build haskel cabalized package with multiple cores loaded? I found ghc-parmake, but can't find anything about merging into Cabal and any option that can turn that on
14:11:50 <tertl6> there is an entire course on this type of stuff roconnor_
14:11:56 <tertl6> CS101 in coursera
14:12:10 <tertl6> i've yet to complete it but its there for the grabbins
14:12:58 <ski> aib : also note that it doesn't really require a monad, only an applicative functor
14:13:02 <ski> @type Data.Traversable.sequenceA
14:13:04 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
14:13:05 <ski> @type Data.Traversable.traverse
14:13:07 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:13:19 <ski> @type Data.Traversable.mapM
14:13:20 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
14:13:23 <donri> roconnor_: vim should do that with :set spell
14:14:20 <aib> ski: why is Maybe Traversable and Either not?
14:14:41 <aib> wow, that would read very badly if not for the capitalization
14:15:06 <DMcGill> aib: welcome to Haskell. Trying to talk about the Maybe type out loud is pretty unfun
14:15:23 <startling> saying "monad" within earshot of a muggle is pretty funny
14:15:41 <ski> aib : `Either e' ought to be `Traversable' as well, for every type `e'
14:15:55 <blackdog> startling: i find it kinda frustrating, actually
14:16:04 <blackdog> it's like a signal to shut your brain off
14:16:16 <ski> @wn muggle
14:16:16 <lambdabot> No match for "muggle".
14:16:30 <blackdog> ski: it's from one of bos's posts
14:16:56 <startling> oh, is it? I just use it to mean "normal people" I guess
14:16:56 <jfischoff> @remember startling: saying "monad" within earshot of a muggle is pretty funny
14:16:57 <lambdabot> It is stored.
14:17:00 <ski> aib : fwiw, i try to consistently quote code snippets like `Maybe' and `Either e'
14:17:06 <aib> I see. I'm still trying to wrap my head around monad/applicative/etc. It seems I've got my head around them, though not yet the relationship between them. I should really read that type category page
14:18:07 <ski> aib : monads are applicative functors `i' that supports a `join :: forall. i (i a) -> i a' operation
14:18:17 <solrize> aib have you read the typeclassopedia?
14:18:56 <ski> aib : expressed differently, the "shape" of the computation in monads can *depend* on the value computed by an earlier part of the monadic computation -- not so with the applicative functor operations
14:19:00 <aib> ski: I'm just happy syntax means a lot to programmers and we're, generally, [.',-etc] using types. wow, I can't believe I forgot the word for the '"-., stuff.
14:19:08 <DMcGill> seconding typeclassopedia, it's really good
14:19:13 <DMcGill> @where typeclassopedia
14:19:13 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:19:31 <aib> solrize: yeah, but not enough times. I figured I'd try again now that I've got my head over Monads
14:19:42 <aib> around*
14:19:49 <solrize> aib how about the category theory wikibook module?
14:20:13 <ski> blackdog : ooc, do you know which ?
14:20:16 <aib> same thing. stuff like that, I keep going back to and rereading as my knowledge increases
14:20:22 <aib> only haskell.org seems to be down right now...
14:20:30 <ski> yes :/
14:20:33 <solrize> that module is really good
14:20:53 <mm_freak> luckily hackage works
14:21:02 <solrize> it demystified monads for me
14:21:08 <startling> me too!
14:21:11 <mm_freak> i'm always very lost, when hackage is down =)
14:21:22 <ski> aib : try <http://webcache.googleusercontent.com/search?hl=en&q=cache:Qj5vVyw6g90J:http://www.haskell.org/haskellwiki/Typeclassopedia> in the meantime
14:21:48 <solrize> http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf
14:21:52 <mm_freak> trying to learn CT to understand monads made my head hurt more…  i found it easier to understand in programming terms, but then of course i still have little clue about CT
14:21:54 <solrize> oh oops
14:21:57 <blackdog> ski: http://twitter.com/johtib/statuses/187569948829302784
14:22:16 <solrize> mm_freak, http://en.wikibooks.org/wiki/Haskell/Category_theory
14:22:24 <mm_freak> solrize: tried it
14:22:28 <solrize> hmm ok
14:22:30 <startling> mm_freak, some basic abstract algebra has helped me a lot
14:22:36 * ski thought blackdog meant some blag post
14:22:42 <aib> punctuation. damnit. "punctuation" was the work I was looking for.
14:22:43 <yoilbu> Is haskell.org offline?
14:22:44 <blackdog> ski: sorry, i misspoke.
14:22:45 <mm_freak> CT is very dry…  i have a hard time opening my brain for it
14:22:48 <yoilbu> I want to install the haskell platform
14:22:55 <yoilbu> is it mirrored anywhere?
14:23:06 <mm_freak> for example i never had problems with group theory, because it's not just a language…  i can actually /do/ stuff with GT
14:23:07 <ski> (that bleep^Wtweet still doesn't explain what the work "muggle" means ..)
14:23:15 <blackdog> ski: whoops. it's a harry potter reference
14:23:29 <ski> ok, ty
14:23:30 <mm_freak> but my impression is that CT is a language and stays one until very late
14:23:32 <blackdog> sorry, thought that was common knowledge - it refers to people who don't know/can't do magic
14:23:50 <mm_freak> yoilbu: which OS?
14:23:56 <yoilbu> mm_freak: mac
14:23:59 <silver> mm_freak, price for being abstract
14:24:01 <solrize> the wikibook treatment is very rudimentary, it doesn't go into any of the messy stuff, but yeah it helps to have seen some abstract algebra first
14:24:04 <yoilbu> 64 bit
14:24:07 <yoilbu> intel
14:24:10 <mm_freak> ok, then no idea, sorry
14:24:30 <yoilbu> thanks anyway, any info on when the site will be back up?
14:24:32 <mm_freak> silver: GT is abstract, too
14:24:33 <startling> yoilbu: what substrate?
14:24:36 <startling> yoilbu: how many qubits?
14:24:40 <ski> mm_freak : yes, CT is mostly a language to talk about and relate different branches of math (and CS and logic) to each other
14:24:52 <silver> and physics...
14:24:58 <ski> mm_freak : how about `LT' ?
14:25:02 <silver> and topology?
14:25:02 <yoilbu> startling: 0qbits silicon von neumann architecture
14:25:16 <solrize> well i'd say the Hask category is just a particular graph labelled by types and functions
14:25:22 <mm_freak> LT is GT^(-1)
14:25:35 <startling> yoilbu, does your model have nociception or not?
14:25:46 <ski> aib : ah (re punctuation)
14:26:10 <yoilbu> startling: yes
14:26:21 <startling> yoilbu: oh. no idea, sorry
14:26:22 <yoilbu> startling: it's marketed to sadists
14:26:23 <aib> my brain does that, occasionally. I once forgot the word for "window" in my native language
14:26:56 <Axman6> yoilbu: modern intel CPUs are kinda of a hybrid Von Neuman/Harvard architecture in a way (separate instruction and data caches) :P
14:27:15 <Axman6> -a
14:27:55 <Clint> what's (a -> m a) -> m a -> m a ?
14:28:04 <aib> ski: ah, your earlier thing about "shape" made sense. I think. thanks. :)
14:28:12 <ski> Clint : an instance of `(=<<)'
14:28:13 <parcs`> Clint: bind
14:28:13 <Axman6> Clint: a type
14:28:19 <Clint> ah, thanks
14:28:33 <ski> .. could be other things, as well
14:28:50 <ski> @type \ama ma -> ma >>= ama >>= ama
14:28:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m a) -> m a -> m a
14:29:07 <parcs`> @type const id `asTypeOf` (=<<)
14:29:09 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b -> m b
14:29:31 <mm_freak> it's also the type of iterateM_, but a better type for that one would be:  iterateM_ :: a -> (a -> m a) -> m b
14:29:43 <mm_freak> swap the arguments, if you will
14:31:59 <roconnor_> almost done this lens family package
14:32:21 <donri> roconnor_: twanvl lenses?
14:32:31 <roconnor_> yes
14:32:37 <donri> cool, looking forward to it
14:32:40 <jfischoff> roconnor_: is it on github?
14:33:18 <roconnor_> donri: preview it at darcs get http://r6.ca/lens-family
14:33:18 <ski> mm_freak : `subst :: Monad m => (var -> m var) -> (m var -> m any)' is related to that ..
14:33:39 <mm_freak> uh
14:34:16 <DMcGill> @hoogle asTypeOf
14:34:17 <lambdabot> Prelude asTypeOf :: a -> a -> a
14:34:27 <DMcGill> @src asTypeOf
14:34:27 <lambdabot> asTypeOf = const
14:34:44 <DMcGill> I should use that more
14:35:00 <donri> roconnor_: 403
14:35:12 <ski> mm_freak : e.g. with `data Expr var = Var var | Lit Integer | Add (Expr var) (Expr var) | Mult (Expr var) (Expr var)', `Expr' is a monad, and `subst' will (repeatedly) substitute all the variables in an expression, given a substitution
14:35:18 <jfischoff> roconnor_: got a getSymbolicLinkStatus: does not exist (No such file or directory) when I did a darcs get
14:35:27 <bael> Is haskell.org down?
14:35:32 <jfischoff> it finished getting though
14:35:44 <roconnor_> weird
14:35:46 <roconnor_> let me try
14:35:51 <ski> mm_freak : in this monad, `do var <- expr; ..var..' means : traverse to each variable `var' in `expr', and replace it by `..var..'
14:35:51 <roconnor_> donri: requires darcs
14:36:07 <mm_freak> ski: yeah, i remember that function
14:36:09 <ski> mm_freak : this is a weird kind of nondeterminism monad, cf. the list monad
14:36:16 <mm_freak> i used to use it when working without locally nameless
14:36:30 <ski> "without locally nameless" )
14:36:48 <ski> s/\)/?/
14:37:09 <mm_freak> yeah, the "locally nameless" paradigm…  i started with variable names, then switched to indices, then switched to locally nameless
14:37:35 <roconnor_> jfischoff: darcs 2.4.4 gives me no error
14:37:36 <ski> i'm not sure what "indices" and "locally nameless" means in this context
14:37:41 <roconnor_> but anyhow
14:37:54 <mm_freak> ski: ah yes, you don't have abstraction, so it's not really relevant
14:37:59 <jfischoff> got 2.8.1
14:38:00 <donri> roconnor_: worked fine with darcs 2.8.1
14:38:13 <jfischoff> donri: what os do you have?
14:38:31 <donri> fedora 17 (haskell stuff from 18)
14:38:31 <bael> http://www.downforeveryoneorjustme.com/haskell.org
14:38:33 <ski> mm_freak : .. i'm still curious as to what you were thinking about
14:38:39 <mm_freak> ski:  data Expr = Lam Scope | App Expr Expr | Bound Index | Free Name;  newtype Scope = Scope Expr
14:38:43 <mm_freak> that's locally nameless
14:38:49 <jfischoff> hmm could be osx thing
14:39:03 <mm_freak> you then have two functions as the interface to scopes:  open :: Expr -> Scope -> Expr
14:39:11 <mm_freak> and close :: Name -> Expr -> Scope
14:39:29 <mm_freak> they "open" and "close" the topmost index
14:39:54 <mm_freak> http://namebinding.wordpress.com/category/locally-nameless/
14:39:57 <ski> mm_freak : this is some de Bruijn variant ?
14:40:02 <ski> (ty for the link)
14:40:37 <mm_freak> http://namebinding.wordpress.com/2009/10/14/i-am-not-a-number-im-a-free-variable/
14:40:40 <mm_freak> this one actually
14:41:11 <mm_freak> this is a combination of de bruijn with local names
14:41:32 <mm_freak> it has the advantages of indices as well as the ease of use of names
14:42:01 <ski> mm_freak : but what is the `Name' type there ?
14:42:06 <ski> something like `String' ?
14:42:20 <mm_freak> whatever you want…  in this paradigm you don't actually choose names, but generate them
14:42:34 <mm_freak> the paper linked from that article uses [(String, Int)]
14:42:37 <mm_freak> i use just Int
14:42:49 <ski> the nice thing with `Expr var' is that you can use whatever name type you like, including ones only containing a few distinct names (or even zero)
14:43:13 * ski isn't very fond of generating names ..
14:43:44 <startling> is there a name for a Category with a second operation on it in the same way that a Ring is a Group with a second operation on it?
14:43:50 <mm_freak> names don't play the same role as in actual lambda calculus here…  a proper expression has no free variables at all
14:43:57 <ski> HOAS with proper L-lambda matching as in lambdaProlog or Twelf is much nicer to use (at least if you don't need to keep track of any actual name strings written by the user)
14:44:48 <mm_freak> ski: i recommend reading the paper linked from the article…  a proper expression in this DSL has no free variables
14:44:49 <ski> (with that, you get substitution and equality upto alpha-conversion for free)
14:45:11 <mm_freak> you get that in locally nameless, too =)
14:45:22 <ski> mm_freak : "proper" meaning "closed" ? or do you mean that no sub-expression has any free variables, as well ?
14:46:12 <ski> (MetaML also implements L-lambda matching on code expressions)
14:46:21 <mm_freak> ski: if you have something like builtin functions, then you would have a separate constructor for that
14:46:35 <mm_freak> like data Expr = Builtin BuiltinName | ...
14:46:47 <ski> mm_freak : hm, i assume they use a monad or applicative functor (or something similar) for generating fresh names ?
14:47:06 <mm_freak> ski: the article uses a concept called agencies to create names
14:47:15 <mm_freak> you get hierarchial names
14:47:23 <mm_freak> hence [(String, Int)]
14:47:32 <mm_freak> i chose to just generate names using a state monad for simplicity
14:47:53 <ski> anything which resembles a monad or an applicative functor for generating fresh names is not that good, imo
14:48:16 <startling> is it bad practice to use a do block for a non-monad?
14:48:18 <mm_freak> just plain functions (if you ignore the monad instance on ((->) Name))
14:48:18 <ski> (in the L-lambda HOAS approach, there are no fresh names to generate, it does without such things)
14:48:32 <mm_freak> startling: yeah, because it's confusing
14:48:32 <yoilbu> startling: Does that even work?
14:48:35 <hpc> startling: it's pointless, more than "bad"
14:48:36 <mm_freak> yoilbu: yes
14:48:37 <merijn> startling: Eh, how would that work?
14:48:37 <ski> > do ()
14:48:38 <lambdabot>   ()
14:48:41 <donri> roconnor_: darcs sent you a small doc fix
14:48:54 <rwbarton> it's not totally pointless but it is confusing
14:48:54 <yoilbu> > do {()}
14:48:55 <lambdabot>   ()
14:48:59 <yoilbu> > do {(); ()}
14:49:01 <lambdabot>   Couldn't match expected type `m a' against inferred type `()'
14:49:06 <mm_freak> ski: could you link me to that?
14:49:09 <rwbarton> it is pretty close to pointless
14:49:18 <merijn> startling: Can you explain what you'd expect to type in a non-monadic do block?
14:49:26 <mm_freak> yoilbu: as long as you don't use ';' it's fine
14:49:32 <mm_freak> uhm
14:49:38 <mm_freak> ';' meaning (>>) or (>>=)
14:49:53 <mm_freak> > do let {x = 3}; x
14:49:55 <lambdabot>   3
14:49:59 <yoilbu> then what's the point?
14:50:05 <yoilbu> Is it just like a bonus keyword?
14:50:11 <yoilbu> like please in intercal
14:50:11 <mm_freak> the point is that 'let' syntax can be nicer in do-blocks
14:50:15 <yoilbu> oh
14:50:28 <rwbarton> it's not a very good point
14:50:31 <ski> > do let be be = do be - 3 in do be (do 5) ^ 2
14:50:33 <lambdabot>   4
14:50:40 <startling> yeah, let is what I would use it for
14:50:46 <startling> dumb example: https://gist.github.com/1229adc365b1f829c035
14:50:46 <mm_freak> notice that there is no 'in'
14:50:51 <yoilbu> > do do do do do do do 4
14:50:52 <lambdabot>   4
14:50:59 <hpc> > do do that voodoo that you do so well
14:50:59 <mm_freak> but anyway, it's really confusing, especially if you don't write type signatures
14:51:00 <lambdabot>   <no location info>: parse error on input `do'
14:51:12 <startling> mm_freak: k
14:51:13 <hpc> ski: lol, do be do be do
14:51:16 <merijn> startling: You realise you can use let anywhere you can use an expression, right? (Although that needs an 'in')
14:51:31 <startling> merijn: um, could you give me an example?
14:51:33 <mm_freak> if you want a nice syntax for 'let', just don't use it, but use 'where' instead =)
14:51:41 <rwbarton> yeah, where would be best in that example
14:51:47 <merijn> > (let foo = 2 + 2 in foo) + 5
14:51:47 <startling> oh, where would work well
14:51:48 <lambdabot>   9
14:52:08 <tomboy64> uhm
14:52:13 <merijn> or
14:52:14 <yoilbu> let do = do do in do do do
14:52:18 <yoilbu> > let do = do do in do do do
14:52:19 <lambdabot>   <no location info>: Empty 'do' construct
14:52:21 <merijn> > let foo = 2+2 in foo + 5
14:52:23 <lambdabot>   can't find file: L.hs
14:52:35 <yoilbu> that is a terrible error message
14:52:43 <tomboy64> ok, i think i got map and currying. but how do i return a function?
14:52:55 <hpc> tomboy64: same way you return a value
14:52:55 <startling> tomboy64, same way you return anything else
14:52:57 <mm_freak> :t do id first
14:52:58 <merijn> startling: As for functions I (like others) prefer where clauses
14:52:58 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
14:53:01 <mm_freak> :t do id last
14:53:03 <lambdabot> forall a. [a] -> a
14:53:07 <hpc> (spoiler alert: functions are values)
14:53:12 <mm_freak> :t do id forever
14:53:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:53:23 <merijn> hpc: You ruined the ending for me...
14:53:26 <startling> merijn: yeah, I didn't think of using where
14:53:48 <yoilbu> tomboy64: To construct an inline lambda function use backslash: myfunc = (\x y -> x + y)
14:53:50 <rwbarton> where is the most common way of introducing non-top level bindings
14:53:52 <tomboy64> but but but -.-
14:53:53 <merijn> startling: Makes more sense for binding names, tbh
14:53:57 <yoilbu> tomboy64: is equivalent to myfunc = (+)
14:54:09 <tomboy64> uhm
14:54:16 <tomboy64> i don't know how to express it
14:54:48 <mm_freak> > do forever Nothing
14:54:50 <lambdabot>   Nothing
14:55:37 <merijn> tomboy64: Can you describe what you'd want/like to do maybe?
14:55:41 <yoilbu> > do forever [1, 2]
14:55:43 <lambdabot>   *Exception: stack overflow
14:55:44 <donri> > forever alone where alone = ()
14:55:46 <lambdabot>   <no location info>: parse error on input `where'
14:56:12 <yoilbu> > { 5 } where 2
14:56:13 <lambdabot>   <no location info>: parse error on input `{'
14:56:46 <tomboy64> map ( map ((\x y z -> if x == y then z else y) x) [y]) [z]
14:56:49 <yoilbu> I like languages where every string is a valid program
14:56:56 <tomboy64> is that comprehensible? ^^
14:57:22 <startling> tomboy64, um, not very
14:57:25 <yoilbu> Have the Haskell standards developers every considered making every string a valid program?
14:57:39 <merijn> tomboy64: So you want to map a function over a list, returning a list of functions and then apply all those functions to a new list?
14:57:42 <mcstar> what?
14:57:58 <yoilbu> tomboy64: that doesn't make any sense. x y and z are used when they aren't in scope
14:58:13 <merijn> tomboy64: Do you want to apply the first function to the first item, second function to the second item, etc. or do you want to apply each function to each item in the second list?
14:58:17 <mcstar> yoilbu: making every string a valid program doesnt make any sense
14:58:21 <mcstar> what doyou mean?
14:58:39 <yoilbu> mcstar: yes it does, you would just define semantics for every possible string
14:58:41 <Azel> yoilbu: Apart from Brainfuck and possibly Befunge, is there even a language where every string is a valid program ?
14:58:58 <tomboy64> merijn: i want to apply the function to each item in the first list, then all of the return functions over the second list.
14:59:00 <mcstar> yoilbu: you mean a term rewriting system like Pure?
14:59:55 <yoilbu> mcstar: no, it would just be nice if I could mash my keyboard and run it
15:00:00 <rwbarton> you could just define the semantics of currently invalid programs to be that of "main = return ()"
15:00:14 <yoilbu> rwbarton: yeah but that wouldn't be very interesting
15:00:27 <startling> where should the "where" block go here? https://gist.github.com/26bdc8aae624cdd8557d
15:00:29 <mcstar> yoilbu: every string has meaning doesnt mean it will run
15:00:29 <yoilbu> the compiler should calculate the most syntatically similar possible program
15:00:43 <donri> sounds like maybe list applicative?
15:00:49 <rwbarton> well i didn't think this was a serious suggestion because... Haskell is sort of known for the fact that it rejects many programs?
15:01:13 <yoilbu> yeah I'm just bored because haskell.org is down
15:01:47 <hpc> yoilbu: there's always cpan ;)
15:01:52 <mcstar> in a statically typed language, most of the programs wouldnt compile, in a dynamically typed one, you will have a hard time getting one, which doesnt throw runtime errors
15:02:07 <donri> startling: you need let...in
15:02:09 <mcstar> yoilbu: but this topic is sort of related to genetic programmming
15:02:57 <Azel> hpc: Or Brainfuck
15:03:05 <donri> startling: if you move 'where' to be syntactically valid, 'x' won't be in scope
15:03:06 <tomboy64> :(
15:03:16 <yoilbu> random SKI trees
15:03:28 <startling> donri: yeah, that's the other problem I was having
15:03:36 <JoshTriplett> Does a UTF-8 equivalent to Data.Text exist?
15:03:36 <yoilbu> I is actually redundant
15:03:38 <mcstar> why not use let?
15:03:39 <yoilbu> SK trees
15:03:42 <startling> how does "let ... in" work?
15:03:48 <donri> startling: if you use 'let', you can solve both problems
15:04:01 <hpc> JoshTriplett: no
15:04:02 <startling> donri: I believe you, but I don't see it
15:04:08 <JoshTriplett> hpc: Sigh.
15:04:09 <startling> and haskell.org is down
15:04:17 <hpc> it shouldn't matter though, because when you care about binary formats you still have to specify what is output
15:04:17 <tomboy64> or is there a function in prelude like "filter" that doesn't return the filtered item but its index in the list?
15:04:27 <tomboy64> or the index of its first occurence?
15:04:30 <JoshTriplett> hpc: Not what I mean.
15:05:01 <mcstar> let a = f x; b = g $ snd a in (mappend (fst a) (fst b), snd b)
15:05:16 <JoshTriplett> hpc: Obviously if I want something other than UTF-8, I'd have to encode/decode, but it would work efficiently for UTF-8.  Just like Text does for UTF-16.
15:05:35 <JoshTriplett> I could use ByteString, but having an explicit encoding in the type system saying "This is UTF-8!" is handy.
15:06:11 <donri> startling: something like, https://gist.github.com/6aae1d45c8faa807c2b3
15:06:39 <startling> donri: oh, wonderful
15:06:43 <hpaste> merijn pasted “tomboy64 example” at http://hpaste.org/70910
15:06:48 <startling> dunno why it wasn't clicking for me
15:06:51 <startling> donri: thanks a bunch
15:06:58 <mcstar> startling: thats exatly what i wrote
15:07:07 <merijn> tomboy64: Not extremely clear (and I'm not sure it does what you *want*, but it certainly does what you described)
15:07:13 <donri> oops there's a ) in the wrong place in my paste there
15:07:24 <merijn> Could probably also be cleaner, but I couldn't quickly figure out how
15:07:39 <merijn> Probably something using applicative/list monad
15:10:32 <startling> mcstar: oops, did I miss it somewhere?
15:11:26 <mcstar> probably, i didnt put your nick in it
15:11:47 <HugoDaniel> any mirrors to download haskell platform ?
15:11:49 <startling> mcstar: oh, yep. thanks anyway!
15:11:52 <HugoDaniel> or ghc ?
15:12:02 <hpc> @where mirrors
15:12:03 <lambdabot> I know nothing about mirrors.
15:12:06 <hpc> @where mirror
15:12:06 <HugoDaniel> i need the ghc windows binary
15:12:07 <lambdabot> I know nothing about mirror.
15:12:09 <hpc> :(
15:12:13 <HugoDaniel> :(
15:12:15 <HugoDaniel> ouch
15:12:28 <hpc> HugoDaniel: install binary? specific version / bytewidth?
15:12:29 <tomboy64> merijn: are you pasting something? i didn't see anything
15:12:35 <hpc> i might still have mine
15:12:43 <HugoDaniel> hpc, ghc 7.4.2 stable, win32
15:12:45 <merijn> tomboy64: http://hpaste.org/70910
15:12:51 <hpc> oh, nope
15:12:57 <jfischoff> roconnor_: fyi, even with the error I was able to install everything without a hitch
15:13:34 <HugoDaniel> can anyone pass me the ghc 7.4.2 windows binary ?
15:14:55 <osa1> can anyone help me, I just started to get "Could not find module `IO' It is a member of the hidden package `haskell98-2.0.0.1'" error, how can I expose this "haskell98" package?
15:15:10 <shachaf> osa1: What you do is not import "IO".
15:15:25 <tomboy64> thanks merijn - that helps a lot.
15:15:28 <MostAwesomeDude> osa1: Are you working with somebody's copy-pasted code?
15:15:34 <yoilbu> Fine, I'll pull ghc from source and build it myself
15:15:44 <yoilbu> darcs.haskell.org is still up
15:15:51 <osa1> MostAwesomeDude: nope, the code is mine, I think I started to get this error after some updates from my distros package manager
15:15:57 <osa1> (some ghc updates)
15:16:08 <merijn> tomboy64: Good, I have to run but I assume someone else can answer any questions you have about the example
15:16:25 <tomboy64> :) i think i'll be fine with that
15:17:08 <shachaf> osa1: "IO" is an old name for a module.
15:17:22 <osa1> shachaf: then what is it's new name?
15:17:30 <shachaf> That depends on what you were using from it.
15:17:34 <shachaf> Maybe System.IO.
15:17:38 <osa1> oh
15:18:26 <yoilbu> osa1: they just want you to upgrade
15:18:53 <yoilbu> yoilbu: you can expose the package by using the cabal package manager and adding it as a dependancy
15:19:06 <yoilbu> osa1: I meant to ping you that time
15:20:09 <yoilbu> osa1: you can also compile with the option -package 'haskell98-2.0.0.1'
15:20:32 <yoilbu> that way you can continue to use obsolete features!
15:21:11 <osa1> yoilbu: thanks. seems like ghc 7.0.4's IO package is moved to System.IO in newer versions
15:21:26 <osa1> is hoogle down?
15:22:09 <startling> osa1: parts of haskell.org are, so yes
15:22:14 <startling> you can still @hoogle, though
15:22:27 <yoilbu> @hoogle return
15:22:27 <lambdabot> Prelude return :: Monad m => a -> m a
15:22:27 <lambdabot> Control.Monad return :: Monad m => a -> m a
15:22:27 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
15:22:39 <osa1> @hoogle extractValue
15:22:39 <lambdabot> No results found
15:22:42 <startling> @src Monad
15:22:42 <lambdabot> class  Monad m  where
15:22:42 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:22:42 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:22:42 <lambdabot>     return      :: a -> m a
15:22:42 <lambdabot>     fail        :: String -> m a
15:22:44 <rtharper> ALL the returns
15:25:42 <yoilbu> The instructions say to run ./sync-all
15:25:49 <yoilbu> but there is no such file
15:26:16 <Mortchek> Why is `forall` shown there? Isn't that usually implied?
15:27:43 <hpc> the output of @src is hand-written
15:29:06 <yoilbu> oh, how embarrassing, I forgot to cd to the directory
15:56:56 <optimight> I am unable to access www.haskell.org since last 4-5 hours. Every time I try it shows me server timed out.
15:57:41 <Axman6> the server's down
15:58:05 <optimight> ohh...  So when can we expect it to be up?
15:59:41 <yoilbu> it's down forever, haskell was a bust so they're closing shop
16:00:16 <yoilbu> it turns out OOP really is superior
16:00:36 <optimight> yoilbu : I think you joking, is it?
16:01:29 <optimight> I come from OOP background and recently studying haskell... seems quite interesting to me!!!
16:02:23 <jfischoff> Is there a type class for performing set-wise boolean operations?
16:02:34 <Iceland_jack> optimight: He is joking
16:02:48 <jfischoff> and, or, and not etc
16:02:56 <blackdog> Axman6: who's an op, anyway? might be an idea to chuck it in the topic.
16:03:24 <Axman6>  @where ops knows /pm lambdabot @where ops
16:03:25 <optimight> Iceland_jack: thanks. I am relieved
16:04:06 <Eduard_Munteanu> Also, check #haskell-ops
16:04:11 <Axman6> and with that, I should go to sleep. fell asleep at the girlfriend's place for like three hours last night, woke up, haven't been able to get back to sleep since
16:04:23 <blackdog> Axman6: i was wondering why you were awake :)
16:04:35 <Leprechankh> optimight, are you an Islamic scholar?
16:05:39 <optimight> @Leprechank : nope...   but I am absolutely new here
16:05:40 <blackdog> jfischoff: i don't think there's a widely implemented one. do you mean for operations on maps, sets etc?
16:05:40 <lambdabot> Unknown command, try @list
16:06:23 <jfischoff> blackdog: yes
16:08:34 --- mode: ChanServ set +o mauke
16:08:34 --- topic: set to '["haskell.org is down","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]' by mauke
16:08:52 <blackdog> mauke: cheers :)
16:10:34 --- mode: mauke set -o mauke
16:23:02 <HugoDaniel> i can setup a haskell.org mirror in my university :/
16:23:29 <aib> ski: oh lol, I just saw the NATIVE_LANGUAGE request. hmm, I should configure this client to make CTCPs more visible.
16:23:45 <aib> anyway, Turkish
16:24:22 <yoilbu> are there any existing haskell.org mirrors?
16:27:00 <yoilbu> bootstrapping ghc from source isn't as easy as I thought
16:36:48 <ski> aib : ok, just curious
16:42:32 <ski> optimight : fyi, the traditional IRC way to direct a message to someone is to just to start the message with their name, commonly followed by `:' or `,' -- if you prefix the name with `@', then lambdabot will believe you're attempting to send a command to it (which adds needless noise)
16:43:18 <optimight> ski: okay. Thanks
16:43:22 <jfischoff> yoiblu: what's your problem with building ghc?
16:43:37 <optimight> ski: Is it correct, now?
16:43:48 <ski> aye, that's fine
16:45:03 <jfischoff> yoilbu: that is
16:45:09 <ski> it's also common for IRC clients to implement "tab completion" : i didn't type your full nickname above, i just typed the first few characters of it, and then pressed the tab-completion key (which is the `<Tab>' in my IRC client)
16:46:19 <optimight> ski: yes, tried it successfully. Where can I learn more?
16:46:53 <ski> (optimight : many IRC clients highlight the message ior the channel if someone sends a message with the selected nickname first -- so this is a good way to get someone's attention (if they're at the computer at all, and can see when the IRC client is yelling for attention))
16:47:55 <ski> optimight : hm, not quite sure (i assume there are IRC tutorials floating around the net) -- i learned most stuff here and there on IRC, by seeing other people use ior explain features
16:48:00 <optimight> -- ski : is this the way?
16:48:19 <ski> that didn't highlight me, if that's what you were asking about
16:48:23 <bcw> optimight, since it's a feature of the IRC client, one place you could go is your client's homepage.  however, tab completion is also a feature in many other *nix systems, so you can probably find out more info on wikipedia too
16:48:58 <optimight> ski : -- how to highlight then?
16:49:01 <ski> (some IRC clients are configured to also highlight if their nicknames appear anywhere in a message (or anywhere as a separate word in a message) -- however mine currently doesn't do that)
16:49:10 <ski> optimight : that worked just fine
16:49:22 <optimight> okay
16:49:36 <ski> optimight : but your "ski: okay. Thanks" from above was ok as well
16:49:59 <weexplat> @compose elite slap xplat
16:49:59 <lambdabot> /ME $lapS Xp1AT
16:51:12 <MostAwesomeDude> @compose slap elite weexplat
16:51:12 * lambdabot hits W3eXp1a+
16:51:12 <lambdabot>  with an assortment of kitchen utensils
16:51:21 <Quantumplation> Anyone know where I can find a mirror of the Haskell platform? the download link seems to be down atm.
16:51:54 <bcw> lambdabot has 1337 text generator? that's odd...
16:55:35 <ski> optimight : btw, IRC commands normally start with the `/' character. useful commands are `/join <channel>',`/part <channel>',`/me <action>',`/msg (<channel> | <nick>) <message>',`/whois <nick>',`/whois <nick> <nick>',`/whowas <nick>',`/topic [<channel>]',`/names [<channel>]',`/ping <nick>',`/ctcp <nick> version',`/ctcp <nick> time'
16:55:57 * ski is here using a command of the form `/me is here using ...'
16:57:01 <aristid> > fix (\s -> "/me is here using a command of the form `" ++ s ++ "'")
16:57:03 <lambdabot>   "/me is here using a command of the form `/me is here using a command of th...
16:57:12 <aristid> scnr
16:57:50 <ski> optimight : in case you don't know, `[...]' above means an optional part, and `(... | ...)' means one of the `...' alternatives should be used. `<channel>' is a channel name (normally starting with `#'), `<nick>' is a nick name, `<action>' and `<message>' is any message you like
16:58:29 <optimight> ski: yes
16:59:05 <ski> optimight : the `/whois optimight optimight' version is like `/whois optimight', except it also lists idle time
16:59:44 <ski> optimight : i think these are the most basic and useful commands
17:00:18 <optimight> ski: I'm on irchelp.org now
17:00:50 <optimight> ski: trying to learn more commands
17:02:11 <ski> optimight : e.g. try writing (without the wrapping single-quotes) `/msg lambdabot > (unwords . map (\(c:cs) -> toUpper c : cs) . words) "hello there"' -- this will send a private message to the nick `lambdabot', in this case lambdabot will answer by evaluating the given expression
17:02:52 <ski> optimight : many IRC clients will then open a new tab/window where you can talk privately with lambdabot without having to prefix every message with `/msg lambdabot '
17:03:56 * ski can't recall whether Smuxi will automatically open a new tab in this case or not ..
17:04:39 <optimight> @ski: /MSG
17:04:40 <lambdabot> Unknown command, try @list
17:04:56 <optimight> @list
17:04:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:05:14 <ski> now you started a message with `@' again -- don't do that, unless you want to send a command to the bot lambdabot
17:05:39 <ski> optimight : you have to say `/msg ski some message here' to send me a private message
17:05:40 <optimight> I was tring to open a private coversation
17:06:09 <bcw> which characters can be used to start a lambdabot command? i've seen @ and >, apparently without rhyme or reason
17:06:39 <startling> ">" means "run this haskell code"
17:06:58 <sipa> typically, @
17:06:59 <startling> "@" is "do some predefined command"
17:07:17 <bcw> ok
17:07:19 <bcw> thanks
17:08:04 <sipa> "> " seems a shortcut for @run
17:08:26 <bcw> actually, i think i've seen ":" too, but i think i know what that means.  ghci command, right?
17:08:45 <sipa> ":t" is a shortcut for @type
17:08:54 <ski> optimight : there's also a `/query <nick>' command which directs all further messages (until further notice) to `<nick>' instead of to the current channel/nick. some clients will open a new tab when you use this, others will reuse the existing one; in the latter case, use `/unquery <nick>' to go back to talking to the previous channel/nick
17:08:57 <eviltwin_b> only :t (type of expression) and :k (kind of expression, @kind)
17:09:05 <ski> sipa : yes, it's `run'
17:09:21 <bcw> ok, good to know.  again, thanks
17:09:27 <ski> (for some reason `:t' doesn't work in private queries -- why, i don't know)
17:10:11 <sipa> :k is @kind
17:10:12 <lambdabot> parse error on input `@'
17:11:20 <optimight> ski: I am want to / trying to learn parsing of html pages
17:15:21 <ski> e.g. you can use `run' like :
17:15:25 <ski> @. read run (\s -> s ++ show s) "@. read run (\\s -> s ++ show s) "
17:15:28 <lambdabot>  @. read run (\s -> s ++ show s) "@. read run (\\s -> s ++ show s) "
17:16:00 <ski> optimight : parsing of HTML is hard
17:17:13 <optimight> ski: I just need to extract words and frequency of words used
17:18:58 <jfischoff> Is there a typeclass for combining two key-value containers where, if the a key is present in the both you choose the first, and otherwise you take the union?
17:19:43 <optimight> ski: at the most with the location like e.g. <head> the word and its frequency here. Count the words. </head>  the 1, word 1, and 1,   ...
17:25:38 <hpc> jfischoff: a tuple of Maps, with lookup k (a, b) = lookup k a <|> lookup k b
17:25:51 <hpc> jfischoff: or rather, tuple of whatever container
17:26:20 <jfischoff> ah Alternative
17:31:35 <Quantumplation> >< anyone know anything about when haskell.org is going to be back up? it seems to be down for me.
17:31:46 <startling> :t (><)
17:31:48 <lambdabot> forall a. (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
17:31:52 <startling> :S
17:32:03 <startling> :t :S
17:32:04 <lambdabot> parse error on input `:'
17:32:13 <hpc> :t (:S)
17:32:14 <lambdabot> Not in scope: data constructor `S'
17:32:37 <bcw> Quantumplation, i was wondering the same thing.  it's down for everybody, apparently (see topic)
17:33:36 <Quantumplation> :-S Anyone know where I can find a mirror of the haskell platform or ghci? I need DataKinds and apparently they're not supported in 7.0.4
17:36:37 <optimight> Which will be better 'regex' or 'html parsing' to extract the words and its frequency from a particular html tag?
17:36:57 <bcw> optimight, html parsing.  you can't parse html with regexen
17:38:13 <optimight> bcw: can you suggest any haskell module /package for that?
17:38:13 <donri> optimight: http://adit.io/posts/2012-03-10-building_a_concurrent_web_scraper_with_haskell.html
17:38:35 <startling> optimight, xmlhtml seems decent
17:38:59 <startling> optimight: but yes, theoretically impossible to parse (x|ht)ml with regex.
17:39:14 <donri> optimight: xmlhtml is build specifically for heist, not really the best option outside of that
17:39:15 <startling> in practice, you can do some stuff, but it's tricky and dumb and slow and ugly
17:39:16 <optimight> okay ..I will go through xmlhtml
17:39:27 <startling> oh, then don't use xmlhtml
17:40:12 <optimight> donri: thanks
17:40:45 <optimight> startling: why you suggested not to use xmlhtml?
17:41:26 <donri> i've also seen people use http://hackage.haskell.org/package/tagsoup saying it's simpler than hxt, though it seems underdocumented...
17:41:46 <startling> optimight, donri said "xmlhtml is build specifically for heist, not really the best option outside of that"
17:42:01 <startling> i've only ever used it for heist, so I dunno how well it would do for anything other than that
17:42:55 <optimight> startling: okay...
17:46:29 <donri> i guess tagsoup is better if what you have is "tag soup", because that package doesn't even pretend there's any structure to such documents... you could also use hxt-tagsoup, but then you can't use tagsoup's inexact search functions.
17:47:36 <optimight> donri: yes ..I had already referred to TagSoup ...and I think it suits my requirement
17:48:37 <optimight> donri: I need to extract the details mainly form unknown webpages
17:48:44 <donri> on the other hand, if your document is somewhat well-formed, parsing it into a structured tree gives you more information and power
17:49:42 <optimight> donri: I will be entering the keyword ...search engine will give urls , I will scrap those urls for words used and the frequency
17:50:09 <donri> i think most websites these days are "somewhat well-formed" in their markup, but it might just be that i browse niche sites :p
17:50:20 <optimight> Want statistics of word location (tag) , frequency, thats all
17:54:32 <cbm80> duh, haskell.org is down, i should have followed the log earlier
17:59:43 <optimight> "xmlhtml is build specifically for heist, what does 'heist' mean here?
17:59:53 <bitonic> optimight: the templating system
18:01:21 <optimight> bitonic: okay
18:07:47 <robinbb> @hoogle lift
18:07:48 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
18:07:48 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
18:07:48 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:08:01 <robinbb> @hoogle liftIO
18:08:02 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
18:08:02 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
18:08:02 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
18:10:27 <SegFaultAX> Is haskell.org down?
18:11:52 <shachaf> /topic
18:12:03 <SegFaultAX> Derp. :)
18:12:03 <heatsink> /topic
18:12:44 <bcw> for 2 hours, at least, now
18:13:46 <heatsink> Is there a name for the relationship between a value-level integer and the corresponding type-level integer?
18:15:35 <heatsink> (::) relates values to types, but we can't say that 1 :: 1
18:16:17 <shachaf> If you were using Agda they'd be the same thing. :-)
18:16:22 <jfischoff> I think that generally going from the type to value is called reflection. Could easily be wrong though.
18:16:25 <shachaf> They're still pretty close to the same thing, just on a different level.
18:16:42 <bcw> isomorphism?
18:18:24 <heatsink> GHC calls going from the value to the type "promotion"
18:20:23 <parcs`> how many packages does hackage have?
18:20:31 <heatsink> a lot
18:21:03 <sipa> 1 lot? 2 lot? ...?
18:21:10 <parcs`> looks like 6000
18:21:11 <heatsink> http://haskellwebnews.wordpress.com/2011/03/16/hackage-stats-the-past-year/
18:21:24 <parcs`> that is pretty damn impressive
18:21:59 <pdxleif> haskell.org is down!  Why?  WHY? :(
18:22:05 <parcs`> time
18:22:20 <heatsink> @time
18:22:21 <lambdabot> Local time for heatsink is Wed Jul  4 20:22:00
18:22:58 <heatsink> @time parcs`
18:23:00 <lambdabot> Local time for parcs` is Wed Jul  4 21:21:37 2012
18:23:03 <shachaf> Who runs haskell.org, anyway?
18:24:41 * hackagebot hylolib 1.4.0 - Tools for hybrid logics related programs  http://hackage.haskell.org/package/hylolib-1.4.0 (GuillaumeHoffmann)
18:25:45 <Kaidelong> I cannot get directory 1.1.0.2 to build on this system
18:25:50 <Kaidelong> 1.1.0.0 seems to work
18:26:06 <Kaidelong> but pngload wants 1.1.0.2
18:26:32 <bcw> shachaf, apparently, Yale University Computer Science Department's Haskell Group.  http://reports.internic.net/cgi/whois?whois_nic=haskell.org&type=domain
18:27:04 <jfischoff> seems to working now
18:27:41 <jfischoff> not entirely though ….
18:27:45 <ohbewonkanahbe> Looks like lambda.haskell.org is still down
18:28:09 <jfischoff> haskell.org is still down
18:28:18 <jfischoff> hackage seems to work
18:28:20 <bcw> here too
18:30:46 <bcw> ... but the admin and tech support contact is galois, inc.  so maybe i should say they run it
18:31:23 <daniel_-> whats the other option except for hoogle now again?
18:31:28 <daniel_-> since hoogle seems to be down?
18:31:38 <jfischoff> hayoo
18:32:42 <zzing_> What should I look at for parameter parsing on my app?
18:32:53 <Kaidelong> oh
18:33:00 <pdxleif> Command-line parameters?
18:33:04 <parcs`> zzing: System.Console.GetOpt
18:33:08 <Kaidelong> somehow cabal built everything okay now
18:33:09 <Kaidelong> what
18:33:12 <Kaidelong> nevermind
18:33:57 <jfischoff> zzing_: I used this and it worked out well http://hackage.haskell.org/package/optparse-applicative-0.0.1
18:34:23 <zzing_> jfischoff, it has a sample so it gets a few more points :-)
18:34:31 <donri> parcs`: http://packdeps.haskellers.com/reverse/base looks like ~4800
18:34:49 <jfischoff> zzing_: also http://hackage.haskell.org/package/cmdargs/
18:34:56 <parcs`> donri: nice
18:35:35 <donri> zzing_: depends. would you like generated man pages or bash completions, or don't you need either?
18:36:02 <pdxleif> Is there an implementation of "The Other Prelude"? Is that going to go anywhere?
18:36:28 <jfischoff> pdxleif: there are a few. I doubt they're going anywhere
18:36:33 <zzing_> Don't need anything, this is a basic app that only needs to take stuff like -c …path-to-config…  but might want to add stuff later
18:37:40 <shachaf> bcw: DIdn't that change a couple of years ago?
18:37:52 <donri> zzing_: would you prefer if no extra packages are needed?
18:38:13 <zzing_> I am already going to use a few dozen in this app I suspect, what is another :-)
18:39:41 * hackagebot hylotab 1.2.1 - Tableau based theorem prover for hybrid logics  http://hackage.haskell.org/package/hylotab-1.2.1 (GuillaumeHoffmann)
18:40:30 <donri> zzing_: perhaps optparse-applicative. it's simple and sane, but doesn't do anything fancy like man pages or shell completions.
18:44:42 * hackagebot hgen 1.4.0 - Random generation of modal and hybrid logic formulas  http://hackage.haskell.org/package/hgen-1.4.0 (GuillaumeHoffmann)
18:59:42 * hackagebot HTab 1.6.1 - Tableau based theorem prover for hybrid logics  http://hackage.haskell.org/package/HTab-1.6.1 (GuillaumeHoffmann)
18:59:46 <bcw> shachaf, maybe.  all i know is that the current domain registration has galois, inc. listed as admin and tech contact, yale listed as (initial) registrant.  it says it was last updated in 2010.
19:00:59 <shachaf> bcw: I think it moved from being hosted by Yale to being hosted by someone else in 2010.
19:01:05 <shachaf> Possibly Galois. Galois hosts hackage., at least.
19:01:17 <shachaf> It's being hosted by Hetzner in .de.
19:02:14 <bcw> shachaf, yes, that fits with what i'm reading.  as i said, galois seems to be the current admin/tech contact
19:02:36 <shachaf> Well, it's unlikely to be back before tomorrow, in that case. :-)
19:02:41 <bcw> heh
19:02:42 <Quantumplation> (f . p) x is the same as f(p(x))? or does it get swapped around?
19:03:08 <shachaf> @src (.)
19:03:09 <lambdabot> (f . g) x = f (g x)
19:03:09 <lambdabot> NB: In lambdabot,  (.) = fmap
19:03:18 <Quantumplation> thanks :)
19:03:34 <shachaf> Quantumplation: Haskell style is to write application with spaces rather than parentheses. Parentheses are mostly for grouping.
19:03:43 <shachaf> So "f x", "f (g x)", etc.
19:03:56 <Quantumplation> *nods* I come from a math background, so it's hard to break the habit. =P
19:04:01 <Quantumplation> math/c++, rather
19:04:28 <shachaf> Oh boy, just wait until kmc hears that.
19:05:26 <bcw> Quantumplation, the same thing is done often in math.  For example, we write "sin x" rather than "sin(x)"
19:05:42 <shachaf> bcw: It's kind of uncommon except in some contexts.
19:05:54 <Quantumplation> it occurs, it's just not as common
19:05:59 <bcw> hmm
19:06:01 <bcw> ok
19:06:05 * shachaf thinks the overloading of parentheses in mahtematics and programming languages alike is kind of horrible.
19:06:53 <Quantumplation> shachaf: it makes it quite a bit clearer, in any case :P with spaces, I sometimes get confused as what ends up being a parameter to what (it's getting better, but still)
19:07:30 <Quantumplation> :D I just got injection working in my fluid simulator.  Just 3 more steps to go: Diffusion, Projection, and Advection
19:07:43 <bcw> it's not clearer, it's just what you're used to :P
19:08:14 <shachaf> Quantumplation: The simple rule to reading Haskell expressions is that function application binds tigher than almost anything.
19:08:29 <shachaf> So "f x + g y" is *always* "(f x) + (g y)", not matter what the operator is.
19:09:24 <bcw> likewise, something that trips a lot of people who expect parens up: "f x + y" is "(f x) + y", not "f (x + y)"
19:09:38 <Quantumplation> well, then why does something like, f Maybe 10 x y z think you're passing 5 parameters to f? shouldn't the Maybe function application bind tighter to the 10 than the f application does?
19:10:02 <shachaf> "Maybe" isn't a function, first of all. :-)
19:10:14 <shachaf> And nope, it's always left-associative, no matter what the function is.
19:10:14 <Quantumplation> it's a constructor, which is essentially a function
19:10:27 <shachaf> Maybe isn't a constructor either, unless you mean type constructor.
19:10:32 <shachaf> The constructors are Just and Nothing. :-)
19:10:48 <shachaf> "a b c d e" is *always* "((((a b) c) d) e)"
19:10:49 <SegFaultAX> shachaf: Aren't type constructors functions?
19:10:50 <Quantumplation> oh right XD
19:11:02 <geekosaur> Quantumplation, had it occured to you that, in a *functional* languagew, it is natural to pass around *functions*?
19:11:06 <shachaf> SegFaultAX: They're type functions, sort of (though not very interesting ones).
19:11:30 <ski> SegFaultAX : type constructors are functions on the *type* level, but not on the value level. and when we say "function" we normally are talking about the value level
19:12:02 <Quantumplation> geekosaur: sure, i do it all the time, but if function application binds tightly, you'd think the inner function application would bind tightly as well
19:12:15 <Quantumplation> i dunno, just something I have to get used to
19:12:22 <shachaf> Quantumplation: GHC is no mind-reader, nor does it try to be.
19:12:35 <shachaf> The left-associative rule is really simple, which is a good thing.
19:13:29 <ski> there's three (i think) exceptions to the left-associative rule, two of them only occuring in patterns
19:13:58 <ski> if you write `foo xs0@(x:xs) = ...', that means `foo (xs0@(x:xs)) = ...'
19:14:01 <startling> how does (,) work for bigger-than-two-tuples? magic?
19:14:22 <ski> if you write `foo ~(x:xs) = ...', that means `foo (~(x:xs)) = ...'
19:14:42 * hackagebot hyloutils 1.0 - Very small programs for hybrid logics  http://hackage.haskell.org/package/hyloutils-1.0 (GuillaumeHoffmann)
19:14:43 <joeyh> (,,)
19:14:52 <ski> if you write `foo bar {x = baz}', that means `foo (bar {x = baz})' (both in patterns and in expressions)
19:14:54 <startling> joeyh: yeah, I know
19:15:08 <geekosaur> :t (,)
19:15:09 <lambdabot> forall a b. a -> b -> (a, b)
19:15:10 <startling> but when I do (a, b, c) I'm using (,), right?
19:15:14 <geekosaur> no
19:15:22 <ski> startling : no, you're using `(,,)'
19:15:23 <Quantumplation> ?? what's ~?
19:15:23 <lambdabot> Plugin `compose' failed with: Unknown command: ""
19:15:32 <ski>   (,,) :: a -> b -> c -> (a,b,c)
19:15:34 <startling> can user-defined functions do that?
19:15:38 <geekosaur> tuples are actually syntax, so (,,) and such are slightly magic
19:15:40 <shachaf> ski: foo {bar = baz} is actually two different cases.
19:15:42 <startling> right, okay
19:15:45 <startling> hence "magic?"
19:16:01 <otters> the only thing similar about (a, b) and (a, b, c) is that they both have commas
19:16:11 <startling> otters: yes, okay
19:16:23 <geekosaur> Quantumplation, ~ makes a pattern lazy / irrefutable.  if it doesnt match, you find out only when the valus is required, not immediately as usual
19:16:30 <shachaf> @ty Nothing {}
19:16:32 <lambdabot> forall a. Maybe a
19:16:32 <shachaf> @ty (Nothing) {}
19:16:34 <lambdabot> Empty record update
19:16:47 <Quantumplation> It'd be cool if you could define ternary operators in haskell
19:16:53 <geekosaur> you sort of can
19:16:58 <ski> Quantumplation : lazy ("irrefutable") pattern -- when you match a value with `~(...)' it will not actually match right now, but always succeeds -- then later when you force any variable bound by the pattern `...' it will actually match the value with `...' at that time (and give a run-time error in case of match failure)
19:17:19 <Quantumplation> ski: ah, ok
19:17:23 <ski> > id Node {rootLabel = (),subForest = []}
19:17:24 <lambdabot>   Node {rootLabel = (), subForest = []}
19:17:55 <optimight_> ski: I got disconneced
19:18:15 <coppro> Quantumplation: (??) = (,); (True, t) ?: _ = t; (False, _) ?: f = f
19:18:57 <optimight_> ski: /msg
19:19:34 <ski> Quantumplation : this is mostly useful (a) in cases where the value must always be of the form of the pattern (unless it hangs or gives an error), and you don't want to compute the value right now; ior (b) when you already know the value "must" (unless you have a bug) have this shape, but you can't actually "look" at the value yet, because that would cause a recursive cycle to hang, to cause inefficiencies
19:19:55 <Quantumplation> *nods*
19:20:39 <SegFaultAX> ski: That's a pretty neat feature. I hadn't read about that yet.
19:23:48 <zzing_> Has anyone made a 'forth' monad, and if not, may I assume it is possible?
19:24:24 <geekosaur> stack evaluation?  think its been done
19:24:45 <zzing_> yeah, I believe the monad would 'hide' the stack
19:24:58 <zzing_> I think I might even have an idea of how to do it
19:26:53 <geekosaur> proper forth would be nested stack monads :) StackT ForthData (StackT ForthControl IO a) or some such
19:28:35 <zzing_> Why would proper forth need that?
19:30:33 <MostAwesomeDude> Heh, "proper" Forth.
19:30:49 <zzing_> :t try
19:30:51 <lambdabot> Not in scope: `try'
19:38:23 <zzing_> What was the way of telling ghc to do an extension either in source or cabal?
19:39:38 <ski> SegFaultAX : hm, which feature ?
19:40:03 <startling> what's that fast matrix library everyone likes?
19:40:21 <Quantumplation> startling: Repa?
19:40:35 <startling> maybe it's called "vector"?
19:40:52 <Quantumplation> related note, what happens if I accidentally access (-1,-1,-1) in a Repa array?
19:40:59 <ski> SegFaultAX : hm, i suppose you mean lazy patterns
19:43:56 <weexplat> startling: you might mean a rig category or an additive category
19:56:36 <zachk> hey edwardk
19:56:45 <edwardk> HEYA
19:56:53 <edwardk> er heya =)
20:00:54 <startling> is there a way fromString can fail?
20:01:02 <startling> with OverloadedStrings
20:01:11 <coppro> It could be undefined
20:01:14 <coppro> or otherwise bottom
20:01:18 <startling> oh, true
20:01:43 <startling> would be nice if I could get away with using OverloadedStrings with html/css hex colors
20:02:06 <coppro> sure
20:02:15 <coppro> you could do that
20:02:19 <coppro> although it's probably a bad idea
20:02:24 <coppro> (you could have it be an error)
20:02:32 <zzing_> :t (<*>)
20:02:33 <jfischoff> a quasiquoter is probably better
20:02:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
20:02:47 <zzing_> :t (>>=)
20:02:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:03:07 <zzing_> :t (liftM)
20:03:09 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:03:24 <zzing_> @src liftM
20:03:25 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:04:15 <ski> startling : infinite strings
20:04:41 <ski> hm, though i suppose that wouldn't be a problem with string literals with `OverloadedStrings' :)
20:05:06 <ski> (which also applies to the "bottom" objection)
20:06:00 <zzing_> Can anyone suggest improvements to this code? http://hpaste.org/70916   Eventually, it is going to start a webserver (next step)
20:10:43 <SegFaultAX> Would it be possible to implement the do keyword in pure haskell?
20:12:00 <mm_freak> SegFaultAX: no, but you get quite close to it by using the combinators in a similar style
20:12:13 <mm_freak> just that you will bind to the right instead of to the left
20:12:38 <SegFaultAX> mm_freak: So is do implemented in C, then? At least for GHC.
20:13:08 <shachaf> You're confusing two different things here.
20:13:17 <mm_freak> zzing_: by a quick skim-through my initial impression is that the code is fairly reasonable
20:13:25 <mm_freak> SegFaultAX: GHC is not implemented in C, but in haskell
20:13:35 <mm_freak> 'do' is just syntactic sugar
20:13:46 <SegFaultAX> mm_freak: Oh, I see.
20:13:50 <mm_freak> it is translated to combinator form
20:13:55 <SegFaultAX> mm_freak: So it's more like a preprocessor directive or something?
20:14:01 <SegFaultAX> I see.
20:14:33 <mm_freak> well, it's not exactly preprocessing, but it's a reasonable interpretation
20:14:40 <zzing_> mm_freak,ok good. One thing I was wondering is if it is possible to flatten out the case on line 41. The stuff on the Right side is going to be expended, and I much prefer to not do nesting. Alternatively of course I could start another function
20:14:59 <SegFaultAX> mm_freak: So one thing that I missed from LYAH is.. wtf actually is (<-)?
20:15:04 <SegFaultAX> Is it a normal operator?
20:15:06 <mm_freak> zzing_: why?  the case is fine
20:15:13 <mm_freak> zzing_: it's very readable
20:15:27 <mm_freak> SegFaultAX: no, it's part of do-notation
20:15:29 <ski> zzing_ : some style comments :
20:15:34 <ski> zzing_ : s/(show options)/show options/ and s/(show port)/show port/
20:15:41 <ski> (zzing_ : and also replace `(show (lookup config (T.pack "port")))' by `show (lookup config (T.pack "port"))' or `(show . lookup config . T.pack) "port"')
20:15:49 <ski> zzing_ : i'd also say replace `Left $ show err' and `loadConfig $ configFile options' with `Left (show err)' and `loadConfig (configFile options)' -- others might disagree here
20:15:51 <mm_freak> SegFaultAX: "do x <- c; f x x" is translated to "c >>= \x -> f x x"
20:15:59 <ski> zzing_ : `putStrLn $ ("Error: " ++ error)' ought to be either `putStrLn ("Error: " ++ error)' or `putStrLn $ "Error: " ++ error' -- i prefer the former variant
20:16:05 <ski> zzing_ : since you have `ScopedTypeVariables', i think you probably can replace `port <- require config (T.pack "port") :: IO Int' by `port :: Int <- require config (T.pack "port")', which is more to the point
20:16:18 <ski> @undo do x <- c; f x x
20:16:18 <lambdabot> c >>= \ x -> f x x
20:17:13 <mm_freak> haskell.org still down?
20:17:20 <SegFaultAX> mm_freak: Seems like it.
20:17:29 <bcw> yes, here too
20:17:38 <mm_freak> bad…  it should be hosted somewhere more reliable
20:18:39 <ski> SegFaultAX : `do' is (at least conceptually) implemented as sugar, meaning that there's a well-defined source-to-source transformation (independent of types and variable scoping) which "translates away" the `do'-notation, translating it into calls of `>>=',`fail' (and `mfix', if you use the `rec' keyword with the `RecursiveDo' or `DoRec' language extension (i forget which is which))
20:18:44 <SegFaultAX> So the compiler scans the source for certain keywords (eg do and (<-)) and runs some conversions before subsequent compilation phases?
20:19:18 <MostAwesomeDude> Actually, GHC does type checking before most other things. It's kinda ridiculous, but it helps people figure out type problems.
20:19:30 <MostAwesomeDude> But yeah, if you didn't care about that, you'd desugar.
20:19:39 <SegFaultAX> Ah, I see.
20:19:41 <ski> SegFaultAX : in Scheme (and other Lisps, and probably Prolog as well), due to their homoiconicity (basically their very regular syntax), it's possible to define something like the `do'-notation in the language, using macros
20:20:05 <SegFaultAX> So erm, what does [ e | e <- xs ] get desugared to, exactly?
20:20:06 <zzing_> ski, thank you, those seem to work nicer
20:20:10 <ski> SegFaultAX : there's also Template Haskell which possibly could be used to implement the functionality of `do'-notation -- though with a bit uglier concrete syntax
20:20:41 <mm_freak> ski: RecursiveDo is mdo
20:20:54 <mm_freak> DoRec is the way to go and introduces the 'rec' keyword
20:21:23 <mm_freak> MostAwesomeDude: i think type checking doesn't happen in haskell land, but in core land
20:21:36 <mm_freak> so when type checking all the source transformations will have happened already
20:21:52 <ski> zzing_ : btw, note that when you paste Haskell code on hpaste, it'll automatically run `hint' which will attempt to automatically give style suggestions (it sometimes says "error" for what is really just a strong suggestion) -- see below your paste on that page
20:22:03 <mm_freak> with some notable exceptions like TH/QQ, where the meta-code is type-checked separately
20:22:09 <blackdog> mm_freak: i think that's right, yes - there's a link back to the original source so you can give decent error messages
20:22:19 <ski> mm_freak : yeah, i recalled `rec' is meant to replace `mdo', i just couldn't recall which extension was which :)
20:22:21 <SegFaultAX> mm_freak: Is it possible to get haskell to dump out the transformed source that would be otherwise handed to core compilation sequence?
20:22:33 <mm_freak> SegFaultAX: see the ghc-core package on hackage
20:22:39 <zzing_> ski, nice to know
20:23:00 <mm_freak> ski: "DoRec" has an intuitive name…  just read it like "do rec" =)
20:23:33 <mm_freak> btw, DoRec also introduces 'rec' for arrow do-notation
20:23:40 <mm_freak> i.e. ArrowLoop
20:23:46 * ski nods
20:24:06 <SegFaultAX> What's DoRec do?
20:24:15 <SegFaultAX> Err, what does*
20:24:24 <edwardk> SegFaultAX: it provides 'do rec' ;)
20:24:31 <SegFaultAX> edwardk: Go on...
20:24:42 <edwardk> SegFaultAX: have you ever seen mdo?
20:24:53 <SegFaultAX> edwardk: I only just finished LYAH
20:25:00 <edwardk> do rec a <- foo a
20:25:19 <mm_freak> SegFaultAX: i recommend not worring about DoRec for now =)
20:25:25 <edwardk> basically a rec block will use mfix automatically on the variables named in it
20:25:33 <SegFaultAX> mm_freak: Ok.
20:25:42 <SegFaultAX> edwardk: I got basically none of that. Haha.
20:25:43 <edwardk> mfix is used to feed the output of a monadic action back into it as its input
20:26:03 <SegFaultAX> Oh, I see.
20:26:04 <edwardk> are you familiar with fix?
20:26:06 <mm_freak> SegFaultAX: DoRec allows a computation to depend on its own result, which is a somewhat weird idea, when you're not used to laziness
20:26:08 <SegFaultAX> Nope.
20:26:08 <edwardk> > fix (1:)
20:26:10 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:26:31 <edwardk> > fix f = x where x = f x
20:26:32 <lambdabot>   <no location info>: parse error on input `='
20:26:32 <ski> SegFaultAX : have you ever used `IORef' or `MVar' or similar to construct mutable cells ?
20:26:38 <edwardk> er didn't mean to > that
20:26:45 <edwardk> mfix is the monadic version of fix
20:26:47 <edwardk> :t mfix
20:26:48 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
20:27:00 <edwardk> but you need to implement it specifically for each monad type
20:27:03 <mm_freak> mfix isn't really "the monadic version"…  it's actually very different
20:27:05 <bcw> :t fix
20:27:07 <SegFaultAX> ski: I've read about IORef on the wiki, that's about all.
20:27:07 <lambdabot> forall a. (a -> a) -> a
20:27:33 <SegFaultAX> Ah, so MonadFix is a typeclass I'm assuming?
20:27:40 <mm_freak> yes, it is
20:27:44 <edwardk> (interestingly the comonadic version can be defined once and for all)
20:28:04 <SegFaultAX> And what functions does it define?
20:28:08 <edwardk> mfix =)
20:28:14 <SegFaultAX> Oh, that's all?
20:28:23 <mm_freak> SegFaultAX: that's a very large "all" =)
20:28:34 <SegFaultAX> mfix has a similar type to (>>=)
20:28:47 <ski> SegFaultAX : well, if you want to construct a cyclic structure with `IORef's, either you can (a) first put a dummy value in one `IORef', and then later update it to the correct value; or you can use recursive `do' to "get the later value now, before you've constructed it", so that you can initialize with the correct value directly, not needing to patch later
20:28:58 <edwardk> sure but it feeds its own output back into itself in a manner peculiar to the individual monad
20:29:00 <mm_freak> mfix is very useful and mind-bending, when you understand it, but a brainfuck until then =)
20:29:21 <SegFaultAX> ski: As in "I need an IORef now, but I don't have the actual value for it just yet"
20:29:37 <mm_freak> edwardk: comfix :: (Comonad w) => (w a -> a) -> w a?
20:29:42 <mm_freak> or w a -> w a -> a?
20:29:48 <SegFaultAX> What's a comonad?
20:29:50 <edwardk> there are two useful forms
20:30:08 <ski> SegFaultAX : if you're working with something which is similar to `IORef' or `MVar' or `TVar' (i.e. which is allocated monadically), but which doesn't allow changing the value later, then recursive `do' (or the equivalent `mfix') is the only option (apart from more specialized cycle-building primitives the library may or may not provide)
20:30:12 <coppro> SegFaultAX: It's the dual of a monad
20:30:27 <mm_freak> SegFaultAX: i REALLY recommend not bothing for now…  learn the basics first =)
20:30:28 <edwardk> wfix :: Comonad w => w (w a -> a) -> a
20:30:30 <coppro> SegFaultAX: it's what you get by flipping the direction of all the arrows in the rules for monads
20:30:39 <SegFaultAX> mm_freak: I should learn to stop asking questions.
20:30:52 <mm_freak> SegFaultAX: no, asking questions is fine, but that's my honest answer 0)
20:30:53 <mm_freak> =)
20:30:59 <SegFaultAX> coppro: Although I've heard the term, I don't really know what you mean by arrows.
20:31:17 <SegFaultAX> ski: I'm not sure I know what allocated monadically means.
20:31:36 <ski> SegFaultAX : e.g. for `IORef', one such specialized cycle-building primitive might be `newCyclicIORef :: (IORef a -> a) -> IO (IORef a)' -- but this only handles the case when you have a simple cycle, not when you need to build several interlocked cycles at the same time
20:31:39 <coppro> SegFaultAX: grab a book on category theory
20:31:41 <mm_freak> SegFaultAX: do you come from the imperative world?
20:31:51 <edwardk> cfix :: Comonad w => (w a -> a) -> w a; cfix f = fix (extend f) -- is also quite useful
20:31:55 <mm_freak> /are you coming/
20:32:01 <SegFaultAX> mm_freak: Yes, yes I do.
20:32:06 <ski> (also, i don't think there is any `newCyclicIORef' in a library on Hackage -- i just took it as an example, since that primitive exists in Mercury)
20:32:41 <mm_freak> SegFaultAX: these are advanced concepts not found in other languages…  of course i totally understand your curiosity, but before understanding the basics you'll be lost quickly
20:32:50 <SegFaultAX> mm_freak: Haskell is slowly undoing what the last decade and a half of imperative programming has done to my brain :)
20:33:01 <mm_freak> great =)
20:33:03 <mm_freak> keep it slow
20:33:21 <SegFaultAX> mm_freak: The problem is, now that functional programming is my hammer, I want to use it everywhere.
20:33:32 <mm_freak> edwardk: intuitively i'd expect w a -> w a -> a, but i really don't know what such a function would do
20:33:44 <mm_freak> SegFaultAX: you will, but give it time
20:33:50 <SegFaultAX> mm_freak: I find myself "borrowing" (read: stealing) ideas from haskell and re-implementing them in Python or Lua or whatever.
20:34:02 <edwardk> just take the two kleisli arrows in mfix and flip them
20:34:16 <edwardk> (a -> m a) -> m a    and you get w (w a -> a) -> a
20:34:16 <ski> SegFaultAX : e.g. for immutable data, we can say that `Data.Map.empty :: Map key value' *is* *the* empty finite map
20:34:49 <mm_freak> SegFaultAX: i'm programming haskell for four years now and still learning…  haskell introduces you to a vast number of new worlds you've never seen before
20:35:05 <ski> SegFaultAX : but if we want mutable data, this doesn't work, in that case we want to *allocate* a new piece of state which *initially* is set to be the "empty foo" (or filled with some starting value or whatever)
20:35:13 <mm_freak> edwardk: ah, that makes sense
20:35:22 <zzing_> hmm, this mdo stuff looks interesting, what can it do for you
20:35:45 <mm_freak> edwardk: then what's that about cfix?  it looks a lot like cojoin
20:36:25 <SegFaultAX> ski: And will be later updated to an actually meaningful value other than the default or sentinel value?
20:36:35 <edwardk> mm_freak: cfix is useful for stream code, wfix is more useful in more complicated scenarios
20:36:36 <mm_freak> zzing_: use 'do rec' instead of mdo…  honestly i've seldomly used it in monads
20:36:49 <zzing_> mm_freak, I don't even know what mdo does :-)
20:36:58 <SegFaultAX> coppro: Do you have an ISBN for me? (Or just a title, for that matter)
20:37:04 <mm_freak> zzing_: it allows a monadic computation to refer to its own result
20:37:08 <edwardk> mm_freak: as for cojoin/duplicate duplicate = extend id rather than cfix f = fix (extend f)
20:37:37 <mm_freak> zzing_: stupid example:  do rec ref <- newIORef 0 >> modifyIORef ref succ
20:37:59 <ski> SegFaultAX : e.g. in the case of `Data.Array.MArray.newArray :: Ix index => (index,index) -> element -> IO (IOArray index element)', you can think of the actual mutable array as carried around inside the `IO' monad, and the `IOArray index element' that you get back can be thought of as basically an index/key into a large list/map/array of all allocated arrays which is carried around inside the `IO' monad
20:38:15 <coppro> SegFaultAX: ftp://sumin.in.ua/Books/DVD-021/Awodey_S._Category_Theory(en)(305s).pdf is good
20:38:27 <mm_freak> edwardk: you make me wonder whether there is comonadic FRP
20:38:52 <edwardk> mm_freak: there is sort of
20:39:02 <mm_freak> like a behavior that captures the current time instant
20:39:04 <ski> SegFaultAX : so, in a sense, an `IOArray index element' (or an `IORef a') doesn't *contain* the elements (/ value) at all, it just contains a kind of index, and to get at the element at that index, you also need to look at the state (meaning : you must "be in" the `IO' monad)
20:39:26 <edwardk> mm_freak: i spent time kicking it around with conal here a few years back, but you have to give up the monoid on segments to make them comonadic
20:39:30 <edwardk> otherwise extract mempty :: a
20:39:49 <edwardk> which isn't that bad of a trade-off to me
20:39:54 <mm_freak> edwardk: i was rather thinking of a more stream-like monad
20:40:00 <edwardk> *nods*
20:40:05 <edwardk> you've just reinvented data flow programming =)
20:40:07 <ski> SegFaultAX : this is (one way to explain) why there is no `IORef a -> a' or `IOArray index element -> index -> Maybe element' operation -- the data you're looking for simply "isn't contained inside the `IORef' or the `IOArray'", since those are (conceptually) just indices
20:40:11 <edwardk> which has comonadic semantics
20:40:15 <mm_freak> //comonad/
20:40:20 <mm_freak> yeah
20:40:26 <SegFaultAX> ski: You've completely lost me.
20:40:31 <mm_freak> the more i use it, the more i'm questioning the arrow approach
20:40:54 <mm_freak> using Applicative instead of Arrow has helped much, but doesn't solve all problems
20:41:08 <mm_freak> in particular it appears like comonads can solve the explicit input type dilemma
20:41:12 <ski> SegFaultAX : in the actual implementation in GHC (and i think most if not all other implementations), this "index" is really a memory address, and the allocation of an `IOArray' or an `IORef' works in much the same way as in other languages
20:41:32 <edwardk> @hpaste
20:41:32 <lambdabot> Haskell pastebin: http://hpaste.org/
20:41:38 <SegFaultAX> ski: So like, an array of pointers?
20:41:44 <kallisti> under what conditions does hindley milner type inference become unusuable?
20:41:54 <hpaste> edwardk pasted “data flow comonads” at http://hpaste.org/70917
20:42:15 <ski> SegFaultAX : yes, the whole of the internal memory (RAM and ROM) of your computer can be thought of as a big array, with memory addresses being the indices
20:42:58 <mm_freak> hmm
20:43:01 <mm_freak> let me try something
20:43:08 <edwardk> fibo d = fst $ wfix $ d $> fby (0, 1) . fmap (uncurry (+))
20:43:11 <edwardk> is probably cleaner
20:43:14 <ski> SegFaultAX : my main point above was that, in a sense, an `IORef a' or `IOArray index element' value *doesn't* contain the value/elements at all -- they just contain an index (a pointer)
20:44:04 <ski> SegFaultAX : to get at the value/elements, you really need to be able to take a look at the "array" (the memory heap) into which they point -- and you can only do that when you're using `IO'-operations (or operations in similar monads)
20:44:13 <kallisti> SegFaultAX: are you familiar with mutable variables in other languages?
20:44:33 <kallisti> an IORef is that.
20:44:38 <SegFaultAX> ski: Ok, I think that makes sense.
20:45:59 <ski> SegFaultAX : this is why we can easily compare two `IORef's or `IOArray's : we just compare the "indices" -- however this doesn't compare the "contents" of them (since that's not available to use here, since `(==) :: Eq a => a -> a -> Bool' has no `IO' in the result type) -- so, we're only comparing whether they are the *same* "indices"/pointers, we're not comparing the contents
20:46:30 <edwardk> i mostly use strong lax symmetric semimonoidal comonads in lieu of monad transformers when i just want to accumulate some meta-info in a parser or type checker
20:47:03 <ski> (compare for equality, i.e. -- comparing for ordering is another thing, and is not supported for `IORef' and `IOArray' -- mainly to allow the GC to be more efficient by moving allocated objects around in the memory, possibly changing order)
20:47:30 <edwardk> i also find comonads to be nice in little evaluators to get rid of the ugly map based environment lookups
20:47:45 <kallisti> I'd imagination there are also conceptual reasons. the semantics of a "mutable reference" shouldn't be associated with its implementation details.
20:47:52 <ski> edwardk : elaborate ?
20:48:18 <ski> kallisti : conceptual reasons for not allowing ordering ?
20:48:23 <edwardk> ski: instead of eval :: Map a Val -> Exp a -> Val -- you can use eval :: Exp Val -> Val
20:48:26 <kallisti> ski: yes.
20:48:40 <edwardk> or infer :: Exp (Typed a) -> Type
20:48:59 <edwardk> where Typed is a product comonad that carries an extra Type parameter
20:49:23 <ski> kallisti : i suppose that conceptually we just allocate "new" pieces of state, with no inherent ordering of any kind (not even a partial order) imposed on the values (except data dependency order, and even that can be circumvented by back-patching, or using `mfix' / `do rec')
20:49:31 <edwardk> then you can detect closure of the term before you go to evaluate it, and you perform the map lookups once
20:49:54 <tgeeky> this is insane. haskell.org down
20:50:02 <tgeeky> whose programming languages go down? :o
20:50:15 <tgeeky> at least I have hackage
20:50:23 <Adeon> did they try to evaluate bottom
20:50:33 <tgeeky> they can evaluate my bottom!
20:51:05 <edwardk> Adeon: thats the problem with bottom you usually can't tell when you're evaluating it ;)
20:51:53 <ski> SegFaultAX : anyway, there's *two* reasons why `IORef' and `IOArray' allocation has to be in a monad (or similar) : the first is (a) to support mutability; the second is (b) because each such allocation allocates a *new* thing which is unequal to anything allocated before, and to keep track of not getting clashes (and not getting the same thing repeatedly), we need to keep track of what's already been allocated
20:51:53 <kallisti> ski: without being very precise, I don't think it makes sense for mutable variables to have any ordering with respect to one another
20:51:57 <kallisti> basically.
20:52:06 <startling> wow, lenses are really cool
20:52:20 <ski> kallisti : yes, i thought that was the gist of that i said, too :)
20:52:27 <jnoah1984> Any idea when haskell.org will be back up?
20:52:28 <edwardk> startling: =)
20:52:28 <kallisti> yep.
20:53:01 <kallisti> ski: data dependency order is an interesting idea though. not sure how that would work.
20:53:04 <SegFaultAX> ski: How could a clash occur?
20:53:40 <ski> SegFaultAX : e.g., for navigating around an (immutable) (possibly cyclic) graph, it could still be useful to have the "is this the same node as that ?"-operation -- and to do this, we still need to have *allocation* in a monad (or similar) -- even though *access* of the value in a node don't have to be in the monad (since the value can't change)
20:55:13 <mm_freak> edwardk: in what way can you use comonads in evaluators?  they can fail with "not in scope"
20:55:51 <mm_freak> do you have a failable "seek" operation?
20:56:23 <ski> SegFaultAX : try implementing operations `newIntCell :: Int -> MyMonad IntCell', `readIntCell :: IntCell -> Int', `instance Eq IntCell' -- you'll find that to be able to allocate new cells each time, you really `MyMonad' there in `newIntCell' (otherwise two different calls `newIntCell 42' will always return the same cell, instead of returning two different (as measured by `(/=)') cells)
20:56:24 <startling> edwardk: are you the author?
20:56:29 <edwardk> mm_freak: the 'not in scope' errors can be ruled out before you start evaluation or normalization by evaluation
20:56:39 <mm_freak> i see
20:56:40 <edwardk> startling: the original author of data-lens
20:56:47 <startling> edwardk: thanks!
20:57:05 <edwardk> if you speak scala: http://www.youtube.com/watch?v=efv0SQNde5Q is a good overview of them
20:57:11 <mm_freak> data-lens is amazing…  much more amazing than OOP fields =)
20:57:18 <ski> SegFaultAX : trying this exercise is a good way to better understand `IO',`IORef',`IOArray' and `ST',`STRef',`STArray'
20:57:31 <edwardk> and http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285 dives into the different lens implementations out there
20:57:47 <edwardk> mm_freak: wait until lens-family is packaged up =)
20:57:49 <SegFaultAX> ski: I only have the most basic, cursory understanding of those things.
20:57:54 <startling> is there a lens thing for arrays?
20:57:54 <BMeph> Isn't 'wfix' the same as 'loeb'?
20:57:56 <ski> SegFaultAX : if you want to allow mutable cells, try replacing `readIntCell :: IntCell -> Int' with `readIntCell :: IntCell -> MyMonad Int', and also include `writeIntCell :: IntCell -> Int -> MyMonad ()'
20:57:58 <edwardk> mm_freak: now we have lenses you don't even need to import a package to use
20:58:01 <mm_freak> edwardk: so far i haven't needed polymorphic lenses
20:58:09 <zachk> edwardk: lens are in what ?
20:58:11 <mm_freak> edwardk: huh?
20:58:16 <zachk> is 7.4.4 out?
20:58:19 <ski> SegFaultAX : of course, you'll also have to define `MyMonad', and declare a proper `instance Monad MyMonad'
20:58:32 <edwardk> mm_freak: well, to define a van laarhoven lens you don't need to import any lens package
20:58:54 <zzing_> Is there anything for monoids that is shorter to say than mappend?
20:58:58 <ski> SegFaultAX : ok, then you can wait with this exercise until you better understand the `State' monad (different from (and simpler than) `IO' and `ST')
20:59:02 <edwardk> extracting :: Functor f => (a -> f a) -> Cofree g a -> f (Cofree g a); extracting f (a :< as) = (:< as) <$> f a
20:59:08 <kallisti> ski: oh, I just realized MyMonad doesn't really need to be IO.
20:59:16 <mm_freak> edwardk: in what sense?  after all i don't need data-lens for lenses either
20:59:19 <kallisti> which you probably already realized.
20:59:20 <ski> kallisti : of course, that's the point :)
20:59:30 <SegFaultAX> ski: From LYAH I think I have a reasonably good foundation with the State monad.
20:59:40 <kallisti> ski: you just increment a number on each allocation. simple. :P
20:59:42 <edwardk> mm_freak: what i mean is that you can have a random library that has lenses in it that are compatible with lens-family without having to list lens-family as a dependency
20:59:55 <edwardk> mm_freak: so there isn't a good reason _not_ to include the lenses
20:59:58 <ski> SegFaultAX : sorry, i forgot that you should also be able to have an operation `runMyMonad :: MyMonad String -> String' (say)
20:59:59 <mm_freak> ah, that's interesting
21:00:09 <edwardk> the usual complaint is that you need another dep that others may not want
21:00:16 <edwardk> but that doesn't hold here
21:00:18 <mm_freak> so lens-family is only for /using/ lenses?
21:00:21 <startling> man. that's like one of the top things I would want lenses for. maybe they're not called lenses?
21:00:22 <edwardk> yep
21:00:32 <edwardk> you can define them directly using just Functor
21:00:32 <startling> (lenses for arrays, that is)
21:00:40 <zachk> edwardk: how?
21:00:41 <mm_freak> and the interface is as convenient as data-lens?
21:00:57 <edwardk> startling: you want a lens to access an element of an array?
21:00:58 <ski> kallisti : yeah :), the thing that `ST' (and `IO') adds (apart from efficient implementation) is that you can allocate new cells of any type
21:01:02 <kallisti> ski: hm, you couldn't just increment a number though. otherwise you could get incorrect results when you take 2 references allocated by 2 different "runs" of MyMonad
21:01:04 <edwardk> mm_freak: yep
21:01:16 <startling> edwardk: yep
21:01:17 <kallisti> ski: right, you would need to do the ST type parameter thing (I'm not actually sure how that works)
21:01:22 <startling> and set it, possibly
21:01:23 <randomclown> how would one generate a 10 pairs of random number 2nd number is bigger than the first
21:01:27 <edwardk> mm_freak: with the addition of getters and setters, and polymorphic updates
21:01:28 <mm_freak> interesting…  yet another lens concept to learn =)
21:01:30 <randomclown> a list of*
21:01:44 <randomclown> how would one generate a list of 10 pairs of random numbers where 2nd number is bigger than the first*
21:01:54 <ski> kallisti : yes, that's a basic problem -- you can check this and give an `error' (or use `Maybe') for this case, and write in the documentation that it's the user's obligation to not do this
21:01:54 <edwardk> startling: in data-lens there is a good example of a lens for accessing a Map
21:02:04 <ski> (kallisti : but yes, it allows spoofing)
21:02:05 <mm_freak> randomclown: write a function that generates an individual pair, then use replicateM
21:02:10 <randomclown> sequence $ replicate 10 $ randomRIO (0, 20) >>= (\x -> randomRIO(0, 20) >>= \y -> return (x, x + y))
21:02:21 <randomclown> mm_freak here is what I had
21:02:22 <zachk> randomclown: sort . listOfrandoms
21:02:28 <mm_freak> randomclown: sequence . replicate n = replicateM n
21:02:31 <edwardk> startling: it has type Ord k => k -> Lens (Map k a) (Maybe a)
21:02:54 <ski> kallisti : yes, the `s'-thing in `ST s' would also work (i'm not sure how easy it is to define something like this yourself without using unsafe hacks or deferring to `ST')
21:02:57 <mm_freak> randomclown: well, if you want the ranges to be equal and selection to be fair you need to do slightly more
21:03:09 <edwardk> startling: there you can read from the lens and it'll tell you if the element is in the map, and if so what its value is, but you can write to it and it'll set it if you put in Just a, and delete the entry if you put in Nothing
21:03:21 <edwardk> startling: when you talk about an array, if we had stronger types this becomes easy
21:03:28 <randomclown> is there a more elegant way of doing what I had?
21:03:32 <mm_freak> randomclown: replicateM 10 $ do x <- randomRIO (0, 19); y <- randomRIO (x + 1, 19); return (x, y)
21:03:55 <edwardk> you can make a forall (n : Nat). Fin n -> Lens (Vec n a) a   lens into a vector with a known length that is guaranteed safe
21:04:07 <ski> kallisti : conceptually, an `IORef' or an `IOArray' really *is* "just an index/key" :)
21:04:11 <randomclown> aha ok I suppose do notation is better
21:04:13 <randomclown> and replicateM
21:04:24 <mm_freak> randomclown: the important part is not the do-notation
21:04:31 <mm_freak> randomclown: have a closer look
21:04:41 <kallisti> ski: yes, which is what Vault actually does.
21:04:52 * ski doesn't know what "Vault" is
21:05:04 <kallisti> @hackage vault
21:05:05 <lambdabot> http://hackage.haskell.org/package/vault
21:05:09 <randomclown> Oh yeah strict bounds
21:05:15 <edwardk> you can also make an (IArray a e, Ix i) => i -> Lens (a i e) e -- but its less safe, because its only a lens if the index i is within the range of the array
21:06:04 <mm_freak> randomclown: but that's unfair selection…  for fair selection you'll want to do something like this:  replicateM 10 (fmap sort (replicateM 2 (randomRIO (0, 19))))
21:06:13 <mm_freak> randomclown: but that may result in pairs of equal numbers
21:07:03 <kallisti> ski: hm, I don't think the implementation is visible from that page.
21:08:04 <randomclown> mm_freak: right
21:08:38 <kallisti> ski: https://github.com/HeinrichApfelmus/vault/blob/master/src/Data/Vault/ST_Pure.hs  here's the easy to understand implementation. there's a GHC-specific one as well for better performance.
21:09:08 <ski> edwardk : hm `Lens (a i e) e' can't be `a i e -> (e,e -> a i e)' here, right ?
21:09:56 <mm_freak> you can't really construct a proper lens for arrays, unless you allow some dirty trickery
21:10:48 <ski> edwardk : sorry, i was thinking about `MArray'
21:10:57 <augur> edwardk: im going to embark on a mini-computational study! :O
21:11:03 <augur> ok, not really. im just using wordnet.
21:11:05 <augur> but still!
21:12:30 <edwardk> hah, next we'll get you to use statistics ;)
21:13:03 <zachk> augur: wordnet?
21:13:18 <augur> edwardk: i dont mind using statistics as a tool, i just dont think its explanatory!
21:13:27 <augur> zachk: a giant word database
21:15:21 <zachk> augur: is there a haskell module for it?
21:15:22 <ski> for `MArray a e m', i suppose we want something like `(e -> m (e,a)) -> a i e -> m a', though we'd like to make sure that the given callback doesn't attempt to change the element at index `i' in the given array, somehow
21:15:26 <ski> (though it can happily change state pointed to at by (possibly parts of) that element, as long as it doesn't try to change that specific element in that array)
21:15:32 <augur> zachk: no idea. what i really what is a prolog module tho
21:15:38 <augur> or a nice GUI
21:15:42 <ski> (.. consider the case when `e' contains (or is) another mutable array)
21:16:08 <augur> its so poorly designed, afaict, that they cant even explain how to start using it without writing a huge essay
21:16:54 <augur> i mean, the "manual" for it is just a bunch of man pages
21:16:57 <augur> there isnt even a tutorial
21:18:56 <zachk> augur: just seems like old'skool software documentation to me
21:19:08 <augur> maybe, except the year is 2012
21:19:08 <zachk> trying to be all flowery and stuff, pre-Im culture basically
21:19:14 <zzing_> What is the traditional way of converting a string to a bytestring?
21:19:42 <augur> and there is one thing that is a universal truth: man pages are the worst ways to learn something
21:20:03 <zzing_> augur, I use a manpage if I need to learn something, and I usually do.
21:20:14 <augur> im sure you do
21:20:49 <startling> man pages rule for C
21:20:54 <startling> and suck for everything else
21:20:55 <augur> the fact that you can use man pages to learn something doesn't mean they're the best way, or even a good way
21:21:00 <augur> they're just _a_ way.
21:21:54 <zzing_> augur, how else are you going to look up arcane rsync parameters?
21:21:58 <augur> apparently there is indeed a prolog version of wordnet. thats good!
21:21:58 <startling> hm, is there a nice way to make getters and setters for record syntax that doesn't use the state monad
21:22:01 <startling> ?
21:22:08 <augur> zzing_: i said learn, not look up arcane info
21:22:25 <zzing_> I find myself learning it all the time :-)
21:22:28 <augur> man pages are probably ideal if you're experienced and need a reference
21:22:42 <augur> but they're horrible if you need to learn from scratch
21:22:54 <otters> tell that to
21:22:56 <otters> everybody
21:23:12 <zzing_> Would you rather use gnu info?
21:23:16 <startling> I want "data Coords = Coords { x :: Integer, y :: Integer }" and then "setX (Coords 1 2) 9" -> "Coords 9 2"
21:23:29 <Lemon> how would I go about asking SPJ a question about one of his papers?
21:23:34 <augur> no, i'd rather use a nice PDF with good prose
21:24:48 <scutigera> *Lemon* if it's of general haskell interest please post to the haskell mailing list so that we can all learn.
21:25:13 <kallisti> startling: yes. use lenses.
21:25:17 <otters> who is spj?
21:25:22 <kallisti> @hacakge data-lens
21:25:22 <lambdabot> http://hackage.haskell.org/package/data-lens
21:25:32 <kallisti> otters: Simon Peyton Jones.
21:25:52 <startling> kallisti, I don't think I want the state monad, though
21:25:55 <startling> or am I confused?
21:26:01 <otters> Oh, okay
21:26:06 <kallisti> startling: you are. you don't need to use the state monad.
21:26:55 <startling> oh, I just want Data.Lens.Common
21:27:03 <startling> makes sense. thanks!
21:28:03 <kallisti> data Coords = Coords Integer Integer;  x = lens (\(Coord x _) -> x) (\(Coord _ y) x -> Coord x y); ...
21:28:55 <kallisti> modL x (+2) (Coord 2 2)   -- => Coord 4 2
21:30:11 <kallisti> startling: combined with type classes, you get something like properties in OO.
21:30:43 <startling> kallisti: yeah, I see
21:31:05 <startling> that's actually how I thought they worked, but then I looked at Data.Lens.Lazy and was confused. :|
21:32:42 <otters> ohhhh
21:34:04 <otters> infix functions with 3 arguments really don't work too well :|
21:34:27 <kallisti> sure they do.
21:34:34 <kallisti> (f . g) x = f (g x)
21:36:17 <kallisti> maybe not what you had in mind though.
21:36:20 <otters> oh, I guess ^%= and ^!%= are supposed to be partially applied
21:37:26 <zzing_> Monoids are nice
21:37:29 <otters> wow, ^!+=
21:37:32 <kallisti> they don't have to be, but most likely. one of the reasons you'd want to use lenses in the first place is because you can leverage partial application.
21:37:40 <otters> somebody has been throwing chopsticks at their keyboard
21:38:01 <kallisti> but you could do:  x ^%= (+1) $ Coord 4 16
21:38:08 <startling> $#*@!
21:38:12 <otters> yeah
21:38:45 <kallisti> another reason is that they compose.
21:38:59 <startling> ==><==
21:39:09 <startling> i call it "the monadic seatbelt"
21:39:18 <MostAwesomeDude> Pfft.
21:39:43 <MostAwesomeDude> ==[@]== -- What about the monadic belt buckle?
21:40:51 <kallisti> it would be nice if data-lens came with some lenses for base types.
21:41:08 <zzing_> How does this sample line work when the parameter calls for a ByteString? route [ ("foo/bar/quux", fooBarQuux) ]
21:41:13 <startling> >>-()-> -- william tell composition
21:41:14 <MostAwesomeDude> kallisti: Like what? There's a couple in there already...
21:41:35 <kallisti> zzing_: OverloadedStrings most likely
21:42:06 <zzing_> kallisti, if I enable that will it clobber any other String usage I have?
21:42:21 <kallisti> no
21:42:38 <startling> zzing_: nope, it infers it from type
21:42:42 <kallisti> not if the expected type is just String.
21:42:43 <startling> zzing_: sort of like numbers
21:42:47 <zzing_> sweet
21:42:58 <kallisti> if you're passing Strings to something polymorphic it might become ambiguous.
21:43:15 <startling> does it default to String, or does it error?
21:43:46 <kallisti> I think it defaults to String, but I've had ambiguous types come up from OverloadedStrings, so maybe not?
21:43:59 <kallisti> specifically when dealing with Aeson. things like:  "key" .= "value"
21:44:10 <kallisti> it doesn't know which ToJSON instance you want for "value"
21:44:46 <startling> what's the way to turn an integer into hexadecimal?
21:44:46 <kallisti> but then   show "hello"  works fine.
21:45:03 <kallisti> @hoogle showHex
21:45:03 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
21:45:13 <kallisti> > showHex 1000 ""
21:45:14 <lambdabot>   "3e8"
21:45:31 <kallisti> > showHex 50 ""
21:45:32 <lambdabot>   "32"
21:46:00 <startling> can I make it always use two digits?
21:46:14 <shachaf> Even for a three-digit number?
21:46:15 <startling> (when it can, I guess)
21:46:17 <kallisti> I'm not sure what that means.
21:46:22 <kallisti> it could handle that in very different ways
21:46:32 <startling> I want leading zeroes padding up to two digits
21:46:39 <startling> this is a Word8, so it can't overflow
21:46:53 <kallisti> > showHex (maxBound :: Word8) ""
21:46:55 <lambdabot>   "ff"
21:47:13 <startling> kallisti: yep!
21:47:16 <startling> but
21:47:18 <ski> zzing_ : .. `info' is in some ways nicer than `man'
21:47:26 <startling> > showHex (1 :: Word8)
21:47:28 <lambdabot>   Overlapping instances for GHC.Show.Show
21:47:28 <lambdabot>                              (GHC.B...
21:47:34 <startling> > showHex (1 :: Word8) ""
21:47:35 <lambdabot>   "1"
21:47:49 <startling> I'd like that to be 01.
21:47:53 <zzing_> ski, if you are into masochism
21:48:16 <ski> > "0x" ++ showHex 0xbad ""
21:48:18 <lambdabot>   "0xbad"
21:48:40 <ski> > read "0xbad" :: Integer
21:48:41 <lambdabot>   2989
21:49:22 <startling> > read "bad" :: Integer
21:49:24 <lambdabot>   *Exception: Prelude.read: no parse
21:49:25 <shachaf> case foo of [x] -> ['0',x]; xs -> xs
21:49:33 <ski> zzing_ : i mean it has subsections, and you can search across sections, and there a "back button"
21:49:53 <zzing_> ski, using an interface from the seventies
21:50:09 <startling> I could just do "take 2 $ '0':showHex x" but meh
21:50:23 <ski> yes, it's from before HyperText (or at least from before it became wide-spread, i'm not sure)
21:50:28 <startling> > take 2 $ '0':showHex 1
21:50:28 <pdxleif> What's wrong with the seventies?
21:50:30 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
21:50:30 <lambdabot>         against inferred ty...
21:50:40 <startling> > take 2 $ '0':(showHex 1)
21:50:42 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
21:50:42 <lambdabot>         against inferred ty...
21:51:33 <kallisti> startling: import Control.Conditional; myShow n = n > 9 .? ('0':) . showHex n $ ""
21:51:45 <kallisti> er...
21:51:56 <kallisti> startling: import Control.Conditional; myShow n = n < 10 .? ('0':) . showHex n $ ""
21:52:14 * kallisti shameless plug
21:53:10 <kallisti> also n < 16
21:53:15 <ski> (there are also apparently other Info readers than `info' : `pinfo' and `tkinfo' (probably graphical) -- i wouldn't be surprised if some browsers support viewing Info, as well)
21:53:16 <kallisti> because hexadecimal. :|
21:54:10 <zzing_> pdxleif, there are some things from the seventies that force you to take a razor blade to your eyes to prevent you from having to interact with them.
21:54:56 <kallisti> startling: also it's ?.  not .?
21:54:59 <kallisti> I'm tired. >_>
21:56:07 <kallisti> interestingly in this case you could also do   n < 16 ?<> "0" <> showHex n ""
21:56:31 <ski> hm, it appears Konqueror supports Info ..
21:58:12 <ski> "Actually GNU info is one of the first hypertext browsing systems, developed well before HTML and the WWW. It may be showing its age now, but it's hardly a case of re-inventing the wheel. The info wheel was there first."
21:58:26 <shachaf> > reverse . take 2 . (++repeat '0') . reverse . (`showHex`"") $ 8
21:58:29 <lambdabot>   "08"
21:58:30 <shachaf> > reverse . take 2 . (++repeat '0') . reverse . (`showHex`"") $ 17
21:58:32 <lambdabot>   "11"
21:58:33 <ski> apparently it's `info:/...' in Konqueror
21:59:06 <kallisti> startling: from Control.Conditional:  c .? f   is f when p is True, and id otherwise.   c ?<> m   is m when c is True, and mempty otherwise.
21:59:11 <kallisti> *?.
22:03:15 <startling> kallisti: I appreciate the help! unfortunately I decided to just show them in decimal. :/
22:03:28 <kallisti> lol, no problem.
22:03:47 <startling> sort of annoying that haskell doesn't have a built-in printf alternative
22:04:07 <zzing_> Well, almost there to a server. Time for sleep now.
22:04:11 <zzing_> Good knight
22:04:21 <kallisti> startling: I'm assuming you know about printf?
22:04:24 <kallisti> :t printf
22:04:25 <lambdabot> forall r. (PrintfType r) => String -> r
22:04:43 <startling> oh what
22:04:47 <kallisti> it's bad for you though
22:04:49 <kallisti> use something esle.
22:05:13 <startling> I can't do "%02x" though?
22:05:27 <liyang> What's wrong with printf?
22:05:30 <shachaf> > map (printf "%02x") [0,12,17] :: [String]
22:05:32 <lambdabot>   ["00","0c","11"]
22:05:40 <shachaf> liyang: No type checking?
22:05:48 <shachaf> It's not really worse than printf in C.
22:05:54 <kallisti> liyang: another source of runtime errors
22:06:11 <liyang> shachaf: price of convenience.
22:06:18 <shachaf> liyang: Not really...
22:06:25 <shachaf> I mean, you could make a type-checked printf pretty easilly.
22:06:31 <shachaf> s/ll/l/
22:06:34 <startling> yeah, weird that that doesn't exist
22:06:45 <startling> you could also make a "printer" type with overloaded strings
22:06:48 <kallisti> there's also nothing stopping someone from implementing the formatting options directly (I wouldn't be surprised if such a thing already exists)
22:07:11 <jfischoff> there is TH type safe printf
22:07:16 <shachaf> Yep.
22:08:44 <zzing_> We have a printf?
22:09:00 <jfischoff> somewheres
22:09:11 <startling> pretty sure you don't need template haskell for that
22:09:13 <kallisti> > printf "%s indeed" "yes" :: String
22:09:14 <lambdabot>   "yes indeed"
22:09:22 <zzing_> Anyone ever made an equivalent to cout from c++ that can do formatting and automatic conversion with show?
22:09:34 <favonia> hi, does anyone know why "check" in STM has type "Bool -> STM a" instad of "Bool -> STM ()" ?
22:09:50 <zzing_> @src check
22:09:51 <lambdabot> Source not found. My mind is going. I can feel it.
22:09:59 * hackagebot kevin 0.1.3 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.1.3 (JoelTaylor)
22:10:21 <favonia> zzing_: it returns undefined if the input is True
22:10:39 <favonia> any retry if False
22:10:53 <zzing_> favonia, well it is an STM action
22:11:23 <favonia> zzing_: right. but shouldn't that be of type "Bool -> STM ()"?
22:11:29 <liyang> http://hackage.haskell.org/package/Printf-TH and http://hackage.haskell.org/package/xformat
22:11:49 <jfischoff> @t x << y = x ++ show y
22:11:50 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
22:12:06 <startling> @?
22:12:16 <jfischoff> :t  x << y = x ++ show y
22:12:17 <jfischoff> eh
22:12:18 <lambdabot> parse error on input `='
22:12:23 <tgeeky> @t x << y = x ++ show y
22:12:24 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
22:12:52 <MostAwesomeDude> @ty x << y = x ++ show y
22:12:53 <lambdabot> parse error on input `='
22:12:57 <tgeeky> type, but it won't typecheck because of the =
22:12:58 <MostAwesomeDude> @ty x ++ show y
22:12:59 <lambdabot>     Couldn't match expected type `Expr' against inferred type `String'
22:13:00 <lambdabot>     In the second argument of `(++)', namely `show y'
22:13:00 <lambdabot>     In the expression: x ++ show y
22:13:24 <tgeeky> @@type (\x y => x ++ show y)
22:13:27 <tgeeky> @type (\x y => x ++ show y)
22:13:28 <lambdabot> parse error on input `=>'
22:13:32 <tgeeky> @type (\x y -> x ++ show y)
22:13:33 <lambdabot> forall a. (Show a) => String -> a -> String
22:13:41 <MostAwesomeDude> Urgh. Whatever. The type is (Show y) => String -> y -> String
22:13:47 <tgeeky> hehe :)
22:13:48 <MostAwesomeDude> Yeah, what she said.
22:14:48 <tgeeky> anyone have any inside information on ETA till GHC 7.6 RC1?
22:16:34 <favonia> in all my usages of "Control.Monad.STM.check", the output is always ignored. actually it needs to be ignored since the function returns "undefined" when it succeeds. Also, GHC complains if I didn't write "_ <- check x" or "void $ check x"
22:17:32 <favonia> for these reasons I feel "check" should have type "Bool -> STM ()" and return () when the checking is passed?
22:21:50 <Kashyap_> Hi folks ... is Haskell.org down?
22:22:18 <bcw> since at least 4pm PST
22:22:19 <startling> so I've got Materials (stone, oak, flesh), Species (wall, door, human), and Items (data Item = Item Species). Is there a way I can have an "instantiatable" typeclass with a method "a" so I can do both "a human" and "a stone wall"? :S
22:22:30 <startling> I guess I could have a madeOf operator
22:22:42 <startling> "a wall `madeOf` stone"
22:26:11 <bcw> 4pm PDT*
22:27:12 <fryguybob> favonia: http://stackoverflow.com/questions/8364903/haskell-stm-check-function-returning-undefined
22:27:19 <kallisti> startling: a wall made of flesh
22:27:27 <kallisti> human made of oak.
22:27:29 <startling> kallisti: indeed
22:27:35 <startling> kallisti: transmutation yo
22:28:00 <bcw> doom2 had walls made of flesh...
22:28:01 <fryguybob> favonia: That answer does not make much sense to me.
22:28:05 <startling> bcw: so did nethack!
22:28:33 <startling> you just need to know stone to flesh
22:28:51 <startling> also handy for un-petrifying things
22:29:57 <bcw> yeah, i was thinking also some final fantasy games had petrified people.
22:30:03 <fryguybob> favonia: It looks like in the comments that they acknowledge that the answer has little to do with the actual question.
22:30:05 <shachaf> startling: You probably don't want a typeclass.
22:30:17 <startling> shachaf, yeah
22:30:42 <favonia> fryguybob: cool! thanks for the information.
22:32:18 <favonia> fryguybob: I was so frustrated and confused by the 'STM.check'. Glad to know that I am not the only one.
22:32:55 <fryguybob> favonia: My guess is that not fixing it to () allows some use along the lines of  check b `orElse` ...  where when the condition does not hold you want the thread to be blocked indefinately and cleaned up by the GC.
22:33:24 <fryguybob> I will have to search for some use along those lines.
22:36:13 <favonia> fryguybob: I don't understand. if you want to be blocked, shouldn't you avoid 'orElse' which only provides more alternatives?
22:43:36 <fryguybob> favonia: As in handle some alternatives until some condition happens.
22:55:47 <enjoylife> Does the standard ghc download contain docs? If so, where is the default location??
22:57:03 <dmwit> I'm not sure, but the GHC manual is online.
22:57:11 <dmwit> ...when the server isn't dead. =P
22:58:09 <enjoylife> Ive only ever used the online docs, which is what sparked the question.
22:59:20 <favonia> fryguybob: hi, I guess "check b `orElse` m" can be written as "if b then (fail) else m" right?
23:01:28 <fryguybob> favonia: I think those have slightly different meanings.
23:03:13 <enjoylife> nvm on doc location.  greped it.  /usr/share/doc/ghc/html
23:04:51 <shachaf> What a weird place to put documentation.
23:05:05 * hackagebot mime-mail-ses 0.2.0.2 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.2.0.2 (MichaelSnoyman)
23:06:09 <favonia> fryguybob: I guess so. but I feel they are equivalent---that is, every possible result, done by some serialization of transactions of the first program, can be achieved by the second, and vice versa.
23:08:39 <fryguybob> favonia: In the case where b is some constant probably so, but when it is some value computed by reading some TVar then in the first case  m  can also retry and the check can happen again, but in the second case the check happens once first.
23:12:59 <favonia> fryguybob: in the second case, if m does retry then the whole transaction will be rolled back and in the next time b will be checked again. STM is composable.
23:19:10 <startling> is there a nice thing for outputting color to a terminal? specifically I want 256 colors, which System.Console.ANSI  doesn't do
23:19:59 <solrize> anybody interested in a haskell.org mirror?  i have several unused vps's and could offer one for the purpose
23:20:05 <fryguybob> favonia: I think in the case of  orElse  m could be re-attempted without looking at b again.
23:22:26 <tim-m89> What caused haskell.org to be down?
23:22:41 <dmwit> lemmings
23:23:12 <startling> tim-m89, turns out strongly-typed almost-purely-functional programming doesn't work
23:23:19 <startling> they pulled it down in shame
23:23:39 <startling> pretty sure it has to do with the higgs boson
23:23:49 <tim-m89> lol
23:24:13 <startling> no, we don't know either
23:24:17 <favonia> fryguybob: I agree. however I don't think that would change the set of all possible results (as long as STM is "fair" enough??). to me it sounds like a tuning to the fairness of STM.
23:24:32 <tim-m89> Here's a theory: haskell.org was funded by stephen hawking. He just spent his last $100 on a bet
23:24:39 <fryguybob> favonia: They should be semantically equivalent, but operationally there might be some edge case.
23:25:58 * geekosaur thinks whoever's currently managing haskell.org (galois?)'s cleaning crew tends to turn stuff off that "isn't in use"
23:28:25 <favonia> fryguybob: ok. but even in this case, I prefer "check b >> return undefined". Just want to avoid run-time errors unless I explicitly do something suspicious in my code.
23:29:56 <startling> k, guess I'll just output linux-term control codes myself
23:31:24 <fryguybob> favonia: Yeah, I can't find a use case that needs the more general type and would be clear :D
23:31:40 <__nishanth__> I type "collatz :: Int -> Int" in ghci on Ubuntu and get "Not in scope: `collatz'
23:32:16 <geekosaur> ghci is not a top level
23:32:34 <__nishanth__> what should I use
23:32:39 <geekosaur> let { collatz :: Int -> Int; collatz = ... }
23:32:39 <favonia> fryguybob: :D let me send an email to the mailing list and see other's opinions
23:32:52 <__nishanth__> for interactively trying haskell
23:33:10 <__nishanth__> Thanks
23:33:12 <favonia> fryguybob: oh stm 7.4 was just released
23:33:40 <__nishanth__> what if the same code was inside a file and executed using ghc. Would it work
23:34:08 <startling> __nishanth__: yep
23:34:13 <shachaf> Nope.
23:34:22 <startling> __nishanth__: welllll, depends where you put it
23:34:27 <shachaf> ghci is for evaluating Haskell expressions and executing ghci statements.
23:34:35 <shachaf> Haskell files contain Haskell code, which is not the same thing.
23:34:56 <__nishanth__> which command should I use to run a .hs file
23:34:59 <__nishanth__> on Ubuntu
23:35:03 <startling> __nishanth__: runhaskell
23:35:09 <startling> __nishanth__: or ghci, if you want to play around
23:35:36 <__nishanth__> so ghci makes the variables in .hs file available for the session
23:35:42 <__nishanth__> is it?
23:36:07 <startling> __nishanth__: soooort of
23:36:27 <favonia> startling: hey I found this http://hackage.haskell.org/packages/archive/terminfo/latest/doc/html/System-Console-Terminfo-Color.html#v:ColorNumber
23:37:04 <startling> favonia: oh nice
23:37:22 <Lemon> I have sent a question to haskell-cafe but no one is answering me
23:37:24 <startling> ColorNumber is a bit cryptic, but i suspect that's a terminfo thing
23:37:37 <Lemon> also good lord that's a lot of underscores
23:37:43 <fryguybob> favonia: It looks like it has been that way since 2004:  https://github.com/ghc/packages-stm/commit/bd112968ef0e809f20be632e337969386fca7d3e
23:37:49 <startling> he's a special method in python
23:37:52 <startling> no big deal
23:39:08 <fryguybob> favonia: But Beautiful concurrency (2007) has it as  check :: Bool -> STM ()
23:39:19 <__nishanth__> I'm a pythonista trying to learn haskell
23:39:25 <__nishanth__> Hence the confusion
23:39:35 <startling> __nishanth__: cool! that's how I came to haskell
23:39:41 <favonia> fryguybob: haha so it's ugly (by definition)
23:39:58 <favonia> fryguybob: and also that's the only undocumented function in Control.Monad.STM
23:39:58 <startling> __nishanth__: do you have any more specific questions? do you want recommendations towards learning materials?
23:40:03 <__nishanth__> startling: Can you pont
23:40:08 <__nishanth__> startling: exactly
23:40:15 <startling> @where lyah
23:40:16 <lambdabot> http://www.learnyouahaskell.com/
23:40:19 <__nishanth__> startling: I was about to ask for links
23:40:23 <startling> ^ learn you a haskell is great
23:40:30 <startling> @where gentle guide
23:40:30 <lambdabot> http://www.haskell.org/tutorial/
23:40:44 <favonia> this is currently down I believe
23:40:48 <startling> ^ is good but probably more dense. it's good once you've got ahandle on things, though
23:40:52 <startling> favonia: oh, that's true
23:41:40 <__nishanth__> Ya the gentle guide link is down
23:42:11 <__nishanth__> atleast in my part of the world :-)
23:42:45 <startling> haskell.org is down for all of use, I believe
23:43:44 <Nisstyre> does lambdabot cache hoogle results?
23:45:04 <startling> @hoogle a -> a -> a -> (a -> b) -> [b]
23:45:05 <lambdabot> No results found
23:45:54 <favonia> @hoogle id
23:45:54 <lambdabot> Prelude id :: a -> a
23:45:54 <lambdabot> Data.Function id :: a -> a
23:45:54 <lambdabot> Control.Category id :: Category cat => cat a a
23:45:58 <Nisstyre> @hoogle Int -> [a] -> [a]
23:45:59 <lambdabot> Prelude drop :: Int -> [a] -> [a]
23:45:59 <lambdabot> Data.List drop :: Int -> [a] -> [a]
23:45:59 <lambdabot> Prelude take :: Int -> [a] -> [a]
23:46:06 <bourbaki> is it possible that the haskell servers encounter some problems?
23:46:20 <Dtgr> the leap second? :)
23:46:30 <bourbaki> yesterday i wasnt able to browse some of them and now i cant download the haskell platform package
23:46:44 <startling> bourbaki: correct
23:46:47 <startling> haskell.org is down
23:47:04 <bourbaki> is there an alternate link where i could get the platform from?
23:47:13 <Nisstyre> does hoogle do unification?
23:47:27 <Nisstyre> I'm assuming yes
23:47:53 <shachaf> It does some weird heuristic thing.
23:48:44 <favonia> bourbaki: your distro (if Linux) might have haskell-platform as a package
23:49:12 <Nisstyre> I know Arch does
23:49:34 <__nishanth__> quit
23:49:36 <startling> @hoodle Ord b => [a] -> (a -> b) -> a
23:49:37 <lambdabot> GHC.Exts sortWith :: Ord b => (a -> b) -> [a] -> [a]
23:49:37 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
23:49:37 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
23:50:02 <startling> is there something like sortWith that returns just the largest?
23:50:17 <startling> oh, I can use a fold and a "larger" function, can't I
23:50:23 <Nisstyre> startling: maximumBy ?
23:50:36 <Nisstyre> maximumBy :: (a -> a -> Ordering) -> [a] -> a
23:50:47 <startling> ooh, that works
23:50:55 <Nisstyre> it's in Data.List
23:51:00 <startling> Nisstyre: thanks
23:53:26 <startling> :r
23:53:30 <startling> oh heh
23:57:51 <gatlin> Does anyone here have emscripten experience? I wrote a simple program (main = do putStrLn "Hello, World!") and emscripten compiles it but the binary simply outputs nothing (no warnings, errors, etc). 32-bit Ubuntu 12.04 haskell platform
23:57:52 <lambdabot> gatlin: You have 1 new message. '/msg lambdabot @messages' to read it.
23:58:17 <gatlin> hdtns-thdns-
23:58:26 <gatlin> sorry, cleaned my keyboard with this window up
23:58:36 <Nisstyre> gatlin: FYI, you don't need the "do"
23:59:13 <gatlin> Nisstyre: excellent point. 'twas muscle memory
23:59:45 <shachaf> gatlin: They have a channel on irc.mozilla.org
23:59:53 <shachaf> Perhaps they'll know.
