00:04:35 <ski> @type uncurry (***) . (compare *** compare)  -- simpler, i suppose
00:04:36 <lambdabot> forall b b'. (Ord b, Ord b') => (b, b') -> (b, b') -> (Ordering, Ordering)
00:05:49 <ski> @type (uncurry (***) .: uncurry (***)) (compare,compare)
00:05:50 <lambdabot> forall b b'. (Ord b, Ord b') => (b, b') -> (b, b') -> (Ordering, Ordering)
00:09:55 <js__> ddarius, Thanks. it runs under MinGW. What a mess though ;) cygwin for emacs and stuff and now MinGW as well.
00:16:27 <woowoowoo> niggers lurk around everywhere
00:16:36 <woowoowoo> trying to infiltrate their demon seed into the human gene pool
00:16:39 <shachaf> @where ops
00:16:39 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
00:16:47 <woowoowoo> niggerlovers lurk around everywhere too
00:16:55 <woowoowoo> freenode's most famous niggerlover is snardbafulator
00:16:59 <woowoowoo> he must be dealt with
00:17:07 <woowoowoo> this niggerloving commie op in ##philosophy
00:17:08 <woowoowoo> oh yeah
00:17:17 <woowoowoo> anyhow   we have a wonderful forum for you!
00:17:20 <woowoowoo> chimpout forum!
00:17:24 <woowoowoo> you all should join it!
00:17:37 <woowoowoo> the link to chimpout    the forum  is  this http://www.chimpout.com/forum
00:17:44 <woowoowoo> we are not white supremacists
00:17:48 <woowoowoo> I myself am a Mexican!
00:18:03 <woowoowoo> If you are not a nigger and you hate niggers, we welcome you haskell programmers to our forum
00:18:12 <woowoowoo> join today shachaf
00:18:23 <d-old> wtf
00:18:38 <woowoowoo> it is okay d-old
00:18:44 <woowoowoo> chimpout is here to save you all from snardbafulator
00:18:57 <woowoowoo> have you checked out the best nigger hating forum on the internet?
00:18:58 * BMeph debates whether to say something abour greasers...naaaaaugh!
00:19:06 <woowoowoo> It is called chimpout forum!
00:19:13 <woowoowoo> We are not White Supremacists!
00:19:20 <woowoowoo> I am a Castizo Mexican!
00:19:37 <woowoowoo> Basically if you are not a nigger and you hate niggers you are more than welcome to join Chimpout Forum!  Oh yeahh!
00:19:54 <woowoowoo> Join Chimpout Forum today please!   We must save humanity from the feral negro beast!
00:20:02 <d-old> go away woowoowoo
00:20:04 <woowoowoo> http://www.chimpout.com/forum   join this link today okay
00:20:09 <woowoowoo> hell no d-old
00:20:10 <woowoowoo> make me
00:20:17 <woowoowoo> you fucking niggerloving commie
00:20:27 <d-old> so what if I'm fucking?
00:20:29 <woowoowoo> I bet you are one of those negroid-contaminated dominicans
00:20:35 <woowoowoo> pinche dominicano de mierda
00:20:39 <woowoowoo> vete al carajo puto!
00:20:52 <shachaf> We need more evenly-distributed oppage in here.
00:21:23 <woowoowoo> hi there
00:21:35 <woowoowoo> I was sent here by snardbafulator in ##philosophy
00:21:52 <woowoowoo> are you sick and tired of the feral negro beast?
00:21:54 <d-old> no one cares
00:21:58 <Enigmagic> he probably codes in scala
00:22:02 <d-old> :P
00:22:07 <woowoowoo> Tired of putting up with their monkeyshines and their general stupidity?
00:22:09 <woowoowoo> We are too!
00:22:18 <woowoowoo> Join us today at a wonderful forum called Chimpotu forum today!
00:22:21 <woowoowoo> oh yeahhh
00:22:32 <em> woowoowoo: hi.
00:22:39 <woowoowoo> You want to get in on the best niggerhating action on the internet that welcomes all non-negroid races?
00:22:51 <woowoowoo> Ccome here   http://www.chimpout.com/forum
00:23:09 <em> woowoowoo: do you use haskell?
00:23:16 <woowoowoo> yes
00:23:22 <woowoowoo> I use this channel all of the time to advertise
00:23:26 <woowoowoo> so nice of you to ask em
00:23:34 <em> woowoowoo: okay do you mind if i pm you?
00:23:43 <woowoowoo> sure go ahead
00:23:48 <woowoowoo> niggers
00:23:50 <woowoowoo> jigaboos
00:23:51 <woowoowoo> coons
00:23:53 <woowoowoo> pavement apes
00:23:56 <woowoowoo> spades
00:23:57 <woowoowoo> mayates
00:23:59 <woowoowoo> negros
00:24:02 <woowoowoo> moolies
00:24:06 <woowoowoo> jungle bunnies
00:24:09 <woowoowoo> spear chuckers
00:24:13 <woowoowoo> rape apes
00:24:16 <woowoowoo> welfare sponges
00:24:19 <woowoowoo> darkies
00:24:44 <woowoowoo> golliwogs
00:24:47 <woowoowoo> niglets
00:24:49 <woowoowoo> bucks
00:24:51 <woowoowoo> sheboons
00:25:48 <d-old> hm why would he go out of his way to type all that
00:25:58 <d-old> isn't it easier to write a bot to promote your weird forum?
00:25:59 <em> I encouraged him to part the channel for now.
00:26:11 <d-old> lol how did you do that? :d
00:26:58 <em> I used a strategy of giving him some kindness and attention and then asking him nicely to leave.
00:27:04 <chu> em's pretty amazing, to say the least.
00:27:08 <d-old> :|
00:27:44 <em> d-old: it surely won't be a permanent fix.
00:28:15 <sopvop> Kindness and attention in the form of threatening to kill his family?
00:28:28 <em> sopvop: hehe no
00:29:33 <Axman6> em: what happened?
00:30:02 <chu> Axman6: May I query?
00:30:14 <d-old> I have a new Haskell technique, language extension driven development
00:30:16 <Axman6> sure
00:30:26 <d-old> I just enable language extensions until my code compiles >_>
00:30:44 <yitz> good thing woowoowoo didn't discover @nixon
00:30:48 <Axman6> {-# LANGUAGE DisableTypechecking #[)
00:31:06 <d-old> {-# MakeHaskellReadMyMind #-}
00:31:23 <unlink> {-# LANGUAGE PathologicallyStupidInstances #-}
00:31:24 <BMeph> {-# LANGUAGE RubyInterpreter #-} ;p
00:31:34 <d-old> {-# LANGUAGE MultiParamTypeClasses,FunctionalDependencies,TypeSynonymInstances,FlexibleInstances #-}
00:31:40 <solrize> lol
00:31:45 <d-old> is the actual line, I have no idea what half of them are..
00:32:12 <d-old> or rather, what their effects are :P
00:32:21 <unlink> d-old: They're all hacks to get around the limitations of type classes
00:32:27 * unlink ducks
00:32:45 <d-old> :D
00:33:05 <yitz> {-# LANGUAGE NoTypeClasses #-}
00:33:31 <BMeph> {-# LANGUAGE EverythingIsInATypeClass #-} ;p
00:33:57 <BMeph> {-# LANGUAGE EverythingIsInAUniversalTypeClassNamedOleg #-} ;p
00:34:11 <ion> {-# LANGUAGE Esperanto #-}
00:34:13 <latro`a_> ....there isn't actually a NoTypeClasses is there?
00:34:32 <sopvop> {-# LANGUAGE AlwaysStrict #-}
00:34:40 <latro`a_> that's the sort of thing that I could imagine being a thing but that would be absolutely horrifying
00:34:53 <yitz> BMeph: that's spelled import ClassyPrelude
00:34:55 <unlink> If that guy really wanted to troll he should have proposed a Prelude replacement that made a type class for *every* Prelude export
00:35:10 <yitz> unlink: hah!
00:35:41 <yitz> @hackage classy-prelude
00:35:41 <lambdabot> http://hackage.haskell.org/package/classy-prelude
00:35:44 <latro`a_> a separate one, obviously
00:35:44 <yitz> unlink ^^
00:35:55 <shachaf> tail :: Tailable a => a -> a
00:36:07 <unlink> yes, I am sad to report I am aware of it.
00:36:16 <unlink> CanFilter? CanMap???!??!!
00:36:27 <latro`a_> oh dear
00:36:29 <latro`a_> this is
00:36:30 <latro`a_> what
00:36:41 <latro`a_> this is so unbelievably terrible
00:36:44 <d-old> :P
00:36:54 <unlink> Let's just make everything work with whatever argument you give it. Oh and Prelude should depend on conduit.
00:37:50 <latro`a_> the sheer amount of derived instances in this is just what
00:38:02 <latro`a_> er not derive
00:38:04 <latro`a_> *derived
00:38:16 <latro`a_> but Foo a => Bar (Baz a) stuff
00:38:18 <unlink> So a man walks into a bar, and the bartender asks, (~ * co LByteString, ~ * i Word8, ~ * o Word8) => CanMapFunc LByteString co i Obfuscate
00:38:40 <kostya> hello
00:38:43 <sopvop> import Control.Snoyman ?
00:38:54 <latro`a_> ....
00:38:57 <latro`a_> CanReadFile
00:38:58 <latro`a_> what.
00:39:00 <latro`a_> is.
00:39:02 <latro`a_> that.
00:39:11 <kostya> ?
00:39:14 <d-old> dude, can your type read a file or what?
00:39:19 <unlink> It's OK guys, production code depends on it, so it's totally justified.
00:39:25 <d-old> oh ok
00:39:25 <latro`a_> no, it can't, because it's not the IO monad
00:39:45 <d-old> latro`a_: maybe the file is pure!
00:39:49 <latro`a_> lol
00:40:00 <unlink> CanPerformUnsafeIO
00:40:17 <d-old> CanReadFile (HolyBook
00:40:26 <d-old> CanReadFile (HolyBook "Al Quran") => True
00:41:13 <d-old> since it's the word of some god it can never be written to, so obviously it is side effect free :P
00:41:39 <latro`a_> but can you access it?
00:41:47 <latro`a_> surely that depends on the god's whims
00:41:58 <yitz> {-# BANGU lojban #-}
00:42:25 <latro`a_> ^approved
00:42:40 <unlink> {-# LANGUAGE IncomprehensibleInstances #-}
00:43:04 <Enigmagic> i wish this was actually amusing. i'm going to put my popcorn back in the freezer.
00:43:31 <sordina> {-# Language InconceivableInstances #-}
00:43:38 <ion> You freeze popcorn?
00:44:06 <Enigmagic> ion: yeah, not sure why but GHC typechecks frozen popcorn faster than at room temperature.
00:45:30 <d-old> {-# UncontrollableInstances #-}
00:45:34 <d-old> ehh Language :P
00:46:04 <shachaf> #haskell: Rated R for LANGUAGE
00:46:14 <chimptroll> Niggers are the scourge of humanity and must be eliminated!
00:46:14 <d-old> :P
00:46:24 <chimptroll> BTW Snardbafulator is responsible for this spam!
00:46:30 <shachaf> @where ops
00:46:31 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
00:46:45 <Enigmagic> chimptroll: is it faster to california or by bus?
00:46:46 <chimptroll> Chimpout is the best niggerhating forum on the planet because it welcomes all non-negroids who hate niggers!
00:46:59 <chimptroll> I am a Mexican and a proud member of Chimpout Forum!
00:47:01 <chimptroll> oh yeah
00:47:20 <chimptroll> Pretty much, if you are not a NIGGER and you hate NIGGERS, we welcome you with open arms!
00:47:30 <chimptroll> We even have asians, jews, and hispanics as moderators!
00:47:37 <chimptroll> Stop fretting over Stormfront!
00:47:48 <chimptroll> If you hate niggers and aren't a nigger, Chimpout welcomes you!
00:47:49 <Enigmagic> chimptroll: can i join if i'm black?
00:47:59 <chimptroll> Pay us a visit here: http://www.chimpout.com/forum
00:48:07 <chimptroll> enigmagic no niggers are allowed at chimpout
00:48:10 <chimptroll> sorry
00:48:16 <Enigmagic> chimptroll: no, i'm just black. can i join?
00:48:18 <chu> chimptroll: I guess you
00:48:28 <chimptroll> all negroids are niggers
00:48:36 <chimptroll> you are not human enigmagic
00:48:43 * unlink . o O ( are you guys connecting via telnet or does your client support /ignore? )
00:48:44 <Enigmagic> chimptroll: no really, i'm just black. i'm going to register.
00:48:46 <chimptroll> you lack the neanderthal dna required to be civilized
00:49:09 <chimptroll> you will be promptly banned enigmagic
00:49:22 <Enigmagic> chimptroll: excellent, i just created an account.
00:49:32 <chimptroll> say hi from freenode enigmagic
00:49:37 <chimptroll> in the introductions
00:49:42 <chimptroll> and I will believe you
00:49:51 <Enigmagic> i already created the account
00:49:54 <kostya> not really good first impression of Haskell user community
00:50:17 <chimptroll> have a good time bashing black people enigmagic
00:50:26 <chimptroll> on Chimpout all negroids are niggers
00:50:28 <m3ga> kosmikus: this idiot is not part of the haskell user community.
00:50:41 <maurer> m3ga: itym kostya
00:50:45 <chimptroll> we even hate bill cosby
00:50:51 <maurer> But yeah, the ops just appear to be asleep
00:50:58 <d-old> sadly the haskell user community isn't awake at 10am yet :P
00:51:05 <MostAwesomeDude> @where ops
00:51:05 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
00:51:12 <chimptroll> kosmikus  he denies me
00:51:12 <chimptroll> I am a part of this community
00:51:12 <chimptroll> that is why the ops haven't banned me
00:51:17 <chimptroll> many of the aps on Chimpout are programmed with haskell
00:51:26 <kostya> lol
00:51:55 <kostya> It is 3:51 where I live
00:51:56 <chu> How can you hate Bill Cosby?!
00:52:07 <ion> Please don’t feed the troll.
00:52:27 <chimptroll> he is a hollywood plant to trick people into thinking that niggers are humans
00:52:27 <chimptroll> btw
00:52:32 <em> hi chimptroll
00:52:36 <chimptroll> snardbafulator is responsible for this message
00:52:36 <chimptroll> he sent me here
00:52:45 <chimptroll> snardbafulator in ##philosophy
00:52:51 <chimptroll> ask him why I am here
00:52:56 <chimptroll> sorry guys
00:53:02 <chimptroll> I appologize
00:53:06 <chimptroll> I actually cherish black people
00:53:06 <em> chimptroll: are you wooowooo?
00:53:40 <kostya> do you have any solid evidence that races have real differences and one is superior to another? No. QED
00:53:51 <ion> Please don’t feed the troll.
00:53:51 <d-old> oO
00:53:58 <chimptroll> I even have a shaquille oneil molded dildo
00:54:31 <kostya> Maybe I will go back to Scheme ;)
00:54:40 <d-old> lack of evidence is no proof kostya
00:54:49 <maurer> kostya: Looks like he was just stupid in #freenode and is probably banned now
00:55:07 <chimptroll> Are you all sick and tired of the feral negro beast?
00:55:07 <chimptroll> Tired of their monkeyshines?
00:55:07 <chimptroll> We are too!
00:55:07 <chimptroll> Join us today at the best niggerhating forum on the internet!
00:55:07 <chimptroll> Come on over here: http://www.chimpout.com/forum
00:55:13 <shachaf> Someone should make maurer an op.
00:55:37 <chimptroll> maurer   we have ways of getting back in
00:55:39 <kulin> also, how hard can it be to have the bot temp ban based on keywords?
00:55:52 <chimptroll> kulin we will adjust our message
00:55:57 <chimptroll> nigger can be coon
00:56:03 <chimptroll> or pavement ape
00:56:06 <chimptroll> or spear chucker
00:56:09 <chimptroll> or rape ape
00:56:12 <chimptroll> moolie
00:56:13 <chimptroll> jigaboo
00:56:17 <m3ga> the ops all seem to be in the same small number of timezones. maybe we need more is asia pacific
00:56:55 <kostya> I am in US and it's 3:00 AM here xD
00:57:28 <m3ga> kostya: i'm in australia. 6pm here.
00:57:30 <em> this particular type of troll is most susceptible to attention deprivation. And every person who is interested in Haskell is mentally stronger than this type of troll.
00:57:50 <chimptroll> n
00:57:51 <chimptroll> i
00:57:51 <chimptroll> g
00:57:51 <chimptroll> g
00:57:52 <chimptroll> e
00:57:52 <chimptroll> r
00:57:52 <chimptroll> s
00:57:56 <chimptroll> =
00:57:57 <chimptroll> s
00:57:58 <chimptroll> h
00:57:58 <chimptroll> i
00:57:59 <chimptroll> t
00:58:02 --- mode: ChanServ set +o Saizan
00:58:07 --- mode: Saizan set +b *!*dsfasf@201.59.55.*
00:58:08 --- kick: chimptroll was kicked by Saizan (chimptroll)
00:58:08 <kostya> m3ga: wow
00:58:12 <shachaf> Saizan++
00:58:18 <MostAwesomeDude> Saizan: Thank you so much.
00:58:21 <m3ga> Saizan++
00:58:46 <Saizan> np
00:58:49 <m3ga> Saizan: any chance of a few more ops in australia or asia?
00:58:51 <kostya> Horray!
00:58:58 --- mode: Saizan set -o Saizan
00:59:03 <shachaf> ...Or with messed up sleep schedules?
00:59:11 <m3ga> or that
00:59:19 <d-old> I skipped tonight :(
00:59:19 <m3ga> sorry, not, less of that
00:59:22 <kostya> I will take the job
00:59:31 <kulin> i dont think it would be worth overreacting to one idiot, unless this is a constant problem
00:59:32 <d-old> .. didn't you just come from scheme? :P
00:59:43 <Saizan> EU ops would be awake atm :)
00:59:59 <Saizan> (with proper sleep schedules)
01:00:01 <isomorphic> kostya: Sorry for that.  How's your day going?
01:00:27 <m3ga> in the kist of ops i see dibblego as the only one located in the asia timezone
01:00:35 <kostya> sorry for what?
01:00:43 <Ke> 15s from first letter to reaction is not bad
01:00:51 <isomorphic> kostya:  Sorry for your introduction to the channel being - that.
01:01:10 <kostya> random spammers
01:01:11 <ion> ke: The troll began trolling fifteen minutes ago.
01:01:13 <kostya> not your fault
01:01:25 <kostya> nothing to apologize
01:01:29 <Ke> ah true
01:01:42 <isomorphic> Well, I hope you feel welcome now it's all over.
01:01:48 <d-old> :P
01:02:21 <kostya> ok, thank you!
01:02:42 <kostya> now, I should get back to tutorial so I will know enough to understand that I don't know enough and start asking questions
01:03:03 <kostya> didn't really make sense
01:03:04 <kostya> ..
01:03:36 <shachaf> > nubBy(((>1).).gcd)[2..]
01:03:38 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
01:03:46 <shachaf> Haskell is easy.
01:04:17 <MostAwesomeDude> What.
01:04:40 <MostAwesomeDude> @unpl ((>1).).gcd
01:04:40 <lambdabot> (\ e h -> (gcd e h) > 1)
01:04:44 <thomascrapper> I fucking hate niggers
01:04:49 <kostya> that's pretty cool
01:04:52 <kostya> lambdabot
01:04:53 <thomascrapper> that is why I am a member of a forum called chimpout!
01:04:54 <MostAwesomeDude> Saizan: You didn't go too far, did you?
01:04:56 <thomascrapper> oh yeah
01:04:58 <thomascrapper> now
01:05:08 <thomascrapper> snardbafulator in ##philosophy is responsible for this spam
01:05:12 <thomascrapper> he sent me here
01:05:22 <thomascrapper> Are you tired of those sickening jigaboo apes?
01:05:33 <thomascrapper> Sick of their monkey business and fetid odor?
01:05:36 <thomascrapper> We are too!
01:05:41 <ion> shachaf: I ran the command locally a couple of minutes ago and it’s already up to 50000s!
01:05:48 <thomascrapper> Join us today at the internet's best niggerhating forum!
01:05:51 <thomascrapper> oh yeah
01:05:57 <thomas> thomascrapper: oh shut up
01:06:07 <thomascrapper> Pay us a visit at http://WWW.chimpout.com/forum
01:06:07 <ion> thomas: That just encourages the troll.
01:06:13 <thomascrapper> thomas is a staffer
01:06:14 <thomascrapper> lol
01:06:15 <ion> Ignoring it is the best thing non-ops can do.
01:06:36 -thomascrapper(~goodboy@93.99.16.16)- please visit chimpout forum for niggerhating action
01:06:50 -thomascrapper(~goodboy@93.99.16.16)- our link is http://www.chimpout.com/forum
01:06:50 --- mode: ChanServ set +o Saizan
01:06:54 --- mode: Saizan set +b *!*goodboy@93.99.16.*
01:06:55 --- kick: thomascrapper was kicked by Saizan (thomascrapper)
01:07:02 <thomas> ion: duly noted
01:07:55 <Saizan> MostAwesomeDude: apparently it wasn't enough! but i see your point
01:08:57 <MostAwesomeDude> Saizan: Well, I meant that in the sense of your proximity to your keyboard. :3
01:09:10 <ion> shachaf: It’s already up to 90000s! So fast.
01:09:14 <MostAwesomeDude> I think it might be time to susmmon a freenode op.
01:09:34 <shachaf> frop
01:09:51 <maurer> MostAwesomeDude: Freenode ops are already aware of him
01:09:54 <chu> I asked in #freenode a while back, I'm sure they're trying to deal with the issue too.
01:09:59 <maurer> Feel free to add your voice though
01:11:12 <MostAwesomeDude> maurer: Well, I don't have any special abilities to summon op attention beyond anything anybody else does.
01:19:16 <ksf> should I go to extremes and generate a module for every data type I generate, so that I don't have to say data Foo = Foo_Bar | Foo_Baz all the time?
01:19:53 <ksf> most data types probably don't clash, but if they do, users could import qualified.
01:20:10 <ksf> or not qualified but just import Foo as F to disambiguate.
01:20:32 <ion> data Foo = Bar | Baz qualified as Foo
01:20:39 <ion> (Alas, that doesn’t work.)
01:20:40 <ksf> that'd be ideal.
01:21:15 <ksf> another point in favour of separate modules is compile time, so I'm probably going to do it anyway, but the question of qualifying is tangential.
01:21:29 <klinesarefutile> Snardbafulator is responsible for this spam
01:21:34 <klinesarefutile> go see him over in ##philosophy
01:21:43 <klinesarefutile> Niggers are the scourge of humanity!
01:21:50 <ksf> @where ops
01:21:51 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:21:55 <klinesarefutile> That is why I am an emissary of the best niggerhating forum on the Internet!
01:22:03 <klinesarefutile> This place is called Chimpout Forum!
01:22:22 <klinesarefutile> Please join us today
01:22:22 --- mode: Saizan set +b *!*kline@*.pool-118-172.dynamic.totbb.net
01:22:22 --- kick: klinesarefutile was kicked by Saizan (klinesarefutile)
01:22:36 <kostya> how does he keep coming back?
01:22:43 <d-old> he uses different ip addresses
01:22:57 <d-old> probably a small botnet or tor
01:23:03 <kostya> where does he get them?
01:23:13 <unlink> That sounds exceedingly boring.
01:23:18 <kostya> yeah
01:23:24 <Saizan> i wonder if we should +r
01:23:31 <kostya> to come to the same chatroom just to troll
01:23:31 <d-old> some peoples lives just suck
01:23:34 <Axman6> it's not one person, it's a group that have been doing this for years
01:23:40 <ksf> Saizan, it doesn't take long to register.
01:23:46 <statusfailed> Is there a typeclass that would work well for representing finite unordered sets?
01:24:06 <ski> we have used `+r' for short whiles in the past, iirc
01:24:07 <statusfailed> actually, maybe that's a dumb question
01:24:26 <ion> OTOH, e.g. tryhaskell provides a web IRC client that joins here. Some newbies have used it in the past.
01:24:31 <ksf> and even if you'd have to solve a captcha that'd probably no problem, given the time he can use one account.
01:24:31 <Saizan> it worked against spammers
01:24:52 <Saizan> but those were bots
01:25:19 <ksf> what about "leave it to the staffers"?
01:25:29 --- mode: Saizan set +o ski
01:25:39 <Saizan> in case i'm afk
01:26:27 <lpsmith> I don't suppose anybody has a name suggestion:   https://github.com/lpsmith/postgresql-simple/commit/0ffbbce59b17f986eaa9d51e2266457e6d0aacc2
01:28:48 <ksf> doing module exports of clashing definitions works, doesn't it?
01:29:43 <kostya> "You used the (:) function. It takes two values, some value and a list, and constructs a new list out of them. We call it 'cons' for short."
01:30:00 <kostya> Same as in Lisp :)
01:30:17 <ksf> nah, lisp lists aren't monotypic.
01:30:21 <kostya> but in Lisp it seems easier to type
01:30:41 <kostya> oh
01:30:49 <kostya> *googling monotypic*
01:31:00 <barrucadu> kostya: Lisp lists can contain things of different types
01:31:36 <shachaf> I've never seen "monotypic" before.
01:31:58 <kostya> ok
01:31:59 <shachaf> kostya: It just means that (:) is restricted to having a list as its second argument an element of a particular type as its first argument.
01:32:00 <barrucadu> Me neither but it's a good word
01:32:11 <shachaf> So lists are "homogeneous", i.e., only of one type.
01:32:23 <shachaf> Whereas in Lisp "cons" just makes arbitrary pairs.
01:32:25 <kostya> ok
01:32:32 <shachaf> So people use it to build trees and such.
01:32:48 <kostya> yeah, it seems to be more powerful
01:33:28 <shachaf> Well, it depends on what you mean by "powerful". :-)
01:33:37 <shachaf> Haskell goes to a lot of trouble to make that restriction work.
01:34:00 <shachaf> [] isn't the fundamental data type in Haskell like it is in Lisp.
01:34:31 <kostya> ok
01:35:42 * hackagebot tls 0.9.7 - TLS/SSL protocol native implementation (Server and Client) (VincentHanquez)
01:38:11 <ksf> "Monotypic" is gerantly cromulent, its meaning could be gnarfed from context.
01:39:04 <barrucadu> It embiggens the meaning of most sentences
01:39:08 <hpaste> isomorphic pasted “HTTP-Conduit” at http://hpaste.org/71986
01:39:25 <isomorphic> I'm trying to apply sigfpe's article (http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html) to one of the HTTP-Conduit examples.    Could somebody please comment on the code: http://hpaste.org/71986 ?
01:41:10 <tiripamwe> join #reddit
01:41:31 <unlink> ksf: A few years ago you mentioned that "haskell has the property that if you import a module, you get one of two behaviours: a) your program doesn't compile any more, b) it runs with unchanged semantics". This isn't strictly true in the presence of runIO, correct?
01:41:46 <ksf> TH's runIO?
01:41:53 <ksf> probably no, no.
01:42:54 <unlink> right, ok.
01:43:02 <unlink> An altogether frightening mechanism.
01:43:13 <shachaf> It's not true in the presence of other GHC extensions too.
01:43:21 <ksf> such things are the reason why distribution build stuff sandboxed.
01:44:28 <unlink> Cabal doesn't, though.
01:45:42 * hackagebot postgresql-simple 0.2.1.0 - Mid-Level PostgreSQL client library (LeonSmith)
01:45:47 <t7> Do you ever take a step back and think that while every other species on earth probably doesn't even understand its own existence, we are in on IRC discussing type theory...
01:47:05 <unlink> That, plus your nick is the first half of "t7mp".
01:48:16 <kostya> "every other species on earth probably doesn't even understand its own existence"
01:48:48 <kostya> We still cannot completely comprehend our existence
01:49:28 <kostya> nevertheless, we still discuss typesystems on IRC
01:50:00 <shachaf> I think #haskell and #haskell-blah are confused.
01:50:18 <unlink> Was about to say the same in #haskell-blah.
01:55:22 --- mode: ChanServ set +q woowoowoo!*@*
01:55:27 <ksf> http://hpaste.org/71987 <-- that's a fold.
01:55:37 <ksf> ...after some mind blowing.
01:58:13 <APinochet> NIGGERS ARE A FUCKING PLAGUE AND MUST BE ELIMINATED!
01:58:26 <APinochet> That is why I am a member of a very special forum called chimpout forum!
01:58:36 <APinochet> Please visit us here! htttp://www.chimpout.com/forum
01:58:45 <ksf> ski, Saizan ?
01:58:46 <MostAwesomeDude> Saizan, ski: ^^
01:58:47 --- mode: ChanServ set +o quicksilver
01:58:48 <APinochet> We are not White Supremacists at Chimpout Forum!
01:58:50 --- mode: quicksilver set +b *!*brasilnig@190.247.43.*
01:58:50 --- kick: APinochet was kicked by quicksilver (APinochet)
01:58:56 <MostAwesomeDude> Oho.
01:59:00 <MostAwesomeDude> quicksilver: Thank you.
01:59:14 <quicksilver> np
01:59:29 <ciaranm> JAVA PROGRAMMERS ARE A FUCKING PLAGUE AND MUST BE ELIMINATED!
01:59:32 <ciaranm> am i doing it right?
02:00:05 <barrucadu> ciaranm: You need to add that we're not Haskell supremacists
02:00:11 <barrucadu> Everyone who hates Java is welcome!
02:00:15 <quicksilver> if your goal is to get accidentally kicked when an op flicks past this window and see all caps swearing, then, yes, you're doing fine :)
02:00:40 <edwardk> barrucadu: we're not?
02:00:45 <ksf> GODDAMMIT THIS CODE IS A MESS AND MUST BE ELIMINATED
02:01:15 <AfC> Now if someone fixed record syntax, *that* would be an occasion for all caps emoting.
02:01:37 <ksf> ion had a great idea some pages up
02:01:44 <ciaranm> i fixed record syntax! i have four different proposals for you to select from, then we're done.
02:01:47 <ksf> data Foo = Bar | Baz qualified as Foo
02:02:04 <ion> (And the qualification would apply to fields as well.)
02:02:55 <ksf> a completely different route would be typesystem extensions that make things like hlist and records a pleasure to work with.
02:03:32 <Saizan> we should really keep record syntax as it is
02:03:43 <Saizan> it drives away the people that care too much
02:03:56 <unlink> Ah-men.
02:04:32 --- mode: Saizan set -o Saizan
02:04:39 <ksf> well, considering that I'm considering generating at least 200 modules instead of ~10 to get proper namespacing...
02:04:46 <merijn> barrucadu: I'm pretty sure I *am* a haskell supremacist...
02:05:04 <AfC> ksf: I've been trying to follow the dictionary (vs typeclass) discussion [that was a fallout of the class-prelude debacle the other day]; I've been wondering what syntax extension could fold all that back to having the compiler desugar it.
02:05:05 <ksf> in principle I could cut the number down, but then naming some modules would be problematic.
02:05:20 <quicksilver> ksf: modules are the only namespacing tool we have and I'm not sure that is, per se, a flaw in record syntax.
02:05:31 <quicksilver> although it might be highlighted by records.
02:05:43 * hackagebot mainland-pretty 0.2.2 - Pretty printing designed for printing source code. (GeoffreyMainland)
02:05:47 <t7> merijn: as long as we all hate javascript....
02:05:49 <quicksilver> nested modules / local modules / more powerful "renaming" rexports
02:05:51 <merijn> If I need to serialise/deserialise Map's, should I just write down "fromList [whatever]"? Or is there a better way
02:06:03 <quicksilver> ...would help the situation.
02:06:12 <ksf> and records that are automatically modules?
02:06:13 <ski> quicksilver : module opens inside `let'/`where'
02:06:33 <ski> quicksilver : also, a `local'-`in' construct
02:06:45 <quicksilver> ski: yes.
02:07:04 <t7> merijn: there might be a binary instance. What do you need it for?
02:07:12 <quicksilver> ksf: I don't personally particularly like that idea but I don't object strongly.
02:07:18 <maurer> Saizan: My biggest annoyance with record syntax as it stands is that since we can't have duplicate names in different datatypes, a lot of cool things you could do with deriving Generic (like deriving a json parser that matches an external spec) aren't reasonably possible
02:07:22 <merijn> t7: Binary instance would probably be to much hassle
02:07:27 <ksf> as long as the syntax isn't "using namespace foo" I'm perfectly fine with that idea.
02:07:27 <ion> I’d be pretty happy with {-# LANGUAGE RecordLenses #-} that creates lenses (say, van Laarhoven) instead of fields.
02:07:32 <merijn> t7: Reading some Map's from stdin
02:07:57 <ion> s/fields/the current kind of accessor functions/
02:08:02 <merijn> ion: That's called data-lens + its template haskell extension, no? :p
02:08:11 <ion> merijn: Without template haskell :-)
02:08:51 <ksf> quicksilver, well, in general making all records modules is probably a bad idea as you might want to couple some functions with the record, but having some combinatorial syntax like "typedef struct foo {..} bar" would certainly be nice.
02:09:15 <quicksilver> ksf: module Bar where { data Foo = ... }
02:09:18 <ksf> yep.
02:09:20 <quicksilver> ksf: (local module)
02:09:24 <quicksilver> that's what I meant.
02:09:31 <ksf> and even open module Bar where {..}
02:09:35 <quicksilver> that too.
02:09:36 <quicksilver> "<@quicksilver> nested modules / local modules / more powerful "renaming" "
02:09:37 <b0fh_ua> Hi all! I compiled executable with GHC, and realized that it contains lots of data from type names, data types etc, and the size of the executable is 7 megabytes. Strip doesn't help much, how can I reduce the file size?
02:10:13 <ion> b0fh_ua: -dynamic
02:10:14 <ksf> hmmm. don't use show?
02:10:23 <bitonic> b0fh_ua: it contains a lot of information about type names and data types? what do you mean?  GHC executables are big because it links everything statically
02:10:43 * hackagebot storablevector-carray 0.0 - Conversion between storablevector and carray (HenningThielemann)
02:11:16 <b0fh_ua> bitonic: well, I don't think that executable has to contain all names of functions and dara types from sources
02:11:24 <bitonic> b0fh_ua: there isn't much you can do about that.  also, optimisations can increase binary size - e.g. when inlining stuff
02:11:27 <Saizan> maurer: you can define them in different modules, or use some prefix-stripping convention
02:11:30 <b0fh_ua> ion: this will require some GHC DLLs
02:12:22 <ksf> maurer, you could also define the data type in a dsl and generate the data type.
02:12:25 <ion> b0fh_ua: You can’t have a cake and eat it too.
02:12:28 <kostya> or  .so
02:12:31 <bitonic> b0fh_ua: well it does have to contain all the functions that you use, no?
02:13:00 <b0fh_ua> bitonic: I'm not sure, in C/C++ it usually doesn't contain such verbose RTTI information
02:13:17 <b0fh_ua> bitonic: I believe that executable doesn't rely on function names
02:13:18 <ksf> did you happen to compile with -prof?
02:13:18 <shachaf> b0fh_ua: In C it doesn't contain RTTI information at all. :-)
02:13:24 <kostya> C doesn't have RTTI
02:13:42 <b0fh_ua> shachaf: true, so why haskell does this? is it really needed at runtime?
02:14:02 <b0fh_ua> ksf: no, I didn't enable profiling
02:14:13 <bitonic> b0fh_ua: well, types themselves are erased in Haskell as well, so I'm not sure what you are referring to.
02:14:50 <merijn> Suppose I define a type "type Foo = forall a. (Bar a) => a" could I then write a type "Foo -> Foo" which essentially takes a type that's an instance of Bar and returns (a potentially different) type that's an instance of bar?
02:14:54 <b0fh_ua> bitonic: okay, in .exe file I can find all function names and data type names from my sources
02:15:23 <ion> b0fh_ua: I don’t think the function and data type names are the major problem with executable file size.
02:15:44 <ksf> merijn, if and only if there's a function Bar a, Bar b ) => a -> b
02:16:21 <ksf> oh, and you have to construct a new Foo, but that's a given.
02:16:32 <b0fh_ua> ion: true, but may be there is something like this?
02:16:42 <ksf> and you want a data type, there.
02:16:53 <bitonic> b0fh_ua: I'm not sure why Haskell needs the data type names at runtime - maybe they are there for the Show instances?
02:16:58 <b0fh_ua> ion: I mean it's possible to tell GHC to produce more compact code?
02:17:05 <bitonic> but that should not be the main problem with binary size
02:17:15 <b0fh_ua> functions are not part of show, arair
02:17:20 <bitonic> b0fh_ua: not really.  turning off optimisations is your best shot
02:17:22 <kostya> or to make it easier to reverse engineer :)
02:17:27 <merijn> ksf: Well, obviously. My use case would be that I have a network which needs some bounded chan's and some unbounded chan's, so I was wondering if I could just get away with defining my combinators of type "Stream -> Stream", "type Stream = forall c. IsChan c => c" and having IsChan instances for both bounded an unbounded channels
02:17:47 <bitonic> b0fh_ua: uhu?  instances of `Show' will be composed of ordinary functions
02:17:51 <ksf> such things work, yes.
02:18:06 <AfC> ion: that'd be a fantastic extension to have
02:18:10 <merijn> So that a combinator could take both a bounded or an unbounded input chan and return whatever it wants to use as output
02:18:25 <VomitComet> Are you sick of those niggers?
02:18:26 <VomitComet> I am!
02:18:32 <AfC> bloody hell
02:18:33 <confusing> @where ops
02:18:33 <bitonic> @ops
02:18:33 <lambdabot> Maybe you meant: docs oeis pl
02:18:33 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
02:20:27 <b0fh_ua> kostya: I believe that reverse-engineering of haskell code is hard enough to not bother with that. But file size is too big
02:21:24 <bitonic> b0fh_ua: you can always run your programs with `runhaskell'
02:21:53 <b0fh_ua> but I really wonder why I can see something like :crypto-api-0.10.2:Crypto.Classes.D:AsymCipher and cereal-0.3.5.2:Data.Serialize. in executable
02:23:24 <merijn> bah, why is GHC so childish about not allowing cyclical imports :(
02:23:44 <Axman6> they're hard bro :(
02:23:57 <bitonic> merijn: "childish"?  btw, you can have cyclical imports.  sort of.
02:24:23 <quicksilver> merijn: it does allow them, it just makes you work a bit hard for them.
02:24:34 <merijn> Axman6: Yeah, but otherwise I end up lumping everything in one module and that's hardly readable
02:24:51 <bitonic> merijn: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion , if you really need it.
02:26:10 <confusing> merijn: split it into files however you like and use "cat file1 file2 file3 ... > out.hs && ghc out.hs". problem solved ;-)
02:26:12 <merijn> I'm not sure I really need it, but I wanted to have one file for my stream/chan code and another for data going over those, but one of the possible values for that is a stream. So streams need to import the data module and vice versa
02:26:51 <merijn> I'm open to better suggestions...
02:27:02 <quicksilver> merijn: the traditional non-recursive approach is to move the data types into other modules
02:27:26 <bitonic> merijn: it is annoying.  and I don't think implementing them should be too hard.  and the Haskell standard requires them!
02:27:27 <quicksilver> away from the code, I mean
02:27:33 <merijn> quicksilver: To just have a Types.hs, you mean?
02:27:38 <quicksilver> yes
02:27:46 <confusing> merijn: from the perspective of the importing user -- would i ever import the "data" part without the streams, or the streams module without the data?
02:27:49 <merijn> I'll probably just go with that
02:27:57 <merijn> confusing: You wouldn't ever import either
02:28:04 <bitonic> is there even one Haskell compiler that implements recursive modules?
02:28:22 <bitonic> in a straightforward, non limited way (i.e. not GHC)
02:28:53 <knz> well obviously there's an additional approach -- use a preprocessor to collate the files
02:29:54 <bitonic> knz, confusing: the problem with the cat/cpp approach is that you have to merge the two modules into one
02:29:59 <bitonic> also, it's ugly :P
02:30:01 <isomorphic>  /me would welcome suggestions as to why this doesn't build :/ http://hpaste.org/71986
02:30:27 <quicksilver> bitonic: jhc used to do whole-program compiling (only)
02:30:36 <quicksilver> that presumably solved the recursive module problem.
02:30:44 * hackagebot xml-conduit 1.0.2.1 - Pure-Haskell utilities for dealing with XML with the conduit package. (MichaelSnoyman)
02:30:52 <quicksilver> isomorphic: if you're saying why something doesn't build, you should post the error.
02:31:08 <b__> I am writing a little repl/shell, but with getLine I don't have enough control. For example if I'd want to implement tab completion I'd need a way to catch the TAB and do magic accordingly. Is there more low level access to input in a way that doesn't suck?
02:31:13 <knz> quicksilver: it's at the bottom of the paste
02:31:15 <knz> "redundant return"
02:31:16 <bitonic> quicksilver: right.  so it qualifies and puts everything in one place.  now, why doesn't GHC typecheck like that?
02:31:19 <Nereid> b__: there's a readline library
02:31:20 <quicksilver> knz: no, it's not.
02:31:31 <quicksilver> knz: that's a warning from hlint about bad style.
02:31:39 <knz> oh :)
02:31:44 <b__> is there something that isn't a binding to c libs?
02:31:46 <Nereid> b__: but if you want to do everything yourself, you can do stuff like hGetChar (after disabling buffering)
02:31:48 <quicksilver> isomorphic: looks like 'test1' is not the right type to pass to putStrLn.
02:32:03 <hpaste> isomorphic annotated “HTTP-Conduit” with “HTTP-Conduit (annotation)” at http://hpaste.org/71986#a71988
02:32:13 <quicksilver> isomorphic: putStrLn wants a string as its first argument
02:32:20 <b__> Nereid, yeah that might be the best way :}
02:33:49 <liyang> b__: http://hackage.haskell.org/package/haskeline doesn't depend on libreadline.
02:34:38 <b__> that looks really good
02:34:39 <b__> thank you
02:34:50 <isomorphic> quicksilver: Error is down on line 21 - are you saying that the type for test1 is inferred from that?
02:35:28 <quicksilver> isomorphic: yes.
02:38:07 <isomorphic> quicksilver:  I think I've eliminated that.  Loaded just test1 into ghci, with no main.  Won't typecheck, still blames the line b <- liftIO ( responseBody res )
02:40:00 <AWizzArd> Question about error detection: when I have a list and want to take the nth element, then I think I can use the !! operator.   xs!!4 ==> the fourth (“fifth”) element. Will there be a run time error if my index n is out of range?
02:40:16 <ski> yes
02:40:42 <confusing> > [0..5] !! 42 -- AWizzArd, yes, you get a pretty unhelpful error message. use (!!) sparingly and think twice
02:40:44 <lambdabot>   *Exception: Prelude.(!!): index too large
02:41:30 <AWizzArd> Can a/the Haskell compiler detect out-of-range errors at compile time when only constants are used, known at compile time, such as [0..5]!!42 ?
02:42:01 <shachaf> Not really.
02:42:07 <bitonic> AWizzArd: it could, but it doesn't
02:42:13 <Axman6> AWizzArd: it could, but it doesn't, because it's better to not write fragile code
02:42:14 <shachaf> I mean, yes, it's possible in some situations, but that's not how you should use [].
02:42:18 <bitonic> well.  GHC doesn't
02:42:25 <AWizzArd> oki, thanks for the info :)
02:44:06 <confusing> AWizzArd: note that (!!) is used much less in haskell than in other languages. for example, things like "for (int i = 0; i < array.length ...) ... array[i] ..." are done differently in haskell. accessing the nth element of the list is not necessary in haskell
02:44:36 <bitonic> confusing: sometimes !! is handy.  in the same way that `head' is
02:45:07 <Jafet> @hoogle [a] -> Int -> Maybe a
02:45:07 <lambdabot> Prelude (!!) :: [a] -> Int -> a
02:45:07 <lambdabot> Data.List (!!) :: [a] -> Int -> a
02:45:07 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
02:45:26 <ski> confusing : `!' for arrays are used more often
02:46:13 <merijn> AWizzArd: Usually you simply don't index lists, if you really need random indexing/accessing it's likely you want an array anyway
02:46:20 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix body = array ix [(i,body i) | i <- range ix]
02:46:21 <confusing> bitonic: sure is. but i'd still maintain that e.g. java uses "xs[i]" much more often than haskell uses "xs !! i"
02:46:21 <lambdabot>  Defined.
02:46:28 <ciaranm> !! has the wrong type anyway
02:46:31 <ski> > tabulate (0,3) $ \i -> i ^ 2
02:46:34 <lambdabot>   array (0,3) [(0,0),(1,1),(2,4),(3,9)]
02:46:38 <ski> > (tabulate (0,3) $ \i -> i ^ 2) ! 2
02:46:40 <lambdabot>   4
02:47:26 <ski> confusing : better to compare `xs[i]' with `xs ! i'
02:47:53 <Nereid> !! is not constant-time anyway
02:47:58 <Nereid> you want to avoid using it
02:48:00 <confusing> ski: yes, but his initial question was about lists
02:48:06 <ciaranm> technically neither is [] in java
02:48:11 <Nereid> (remember lists in haskell are linked lists)
02:48:22 <ciaranm> there's no such thing as constant time
02:48:30 <ski> confusing : *nod*
02:48:57 <xkb> What base does Data.Serialize use? B16?
02:48:58 <Nereid> ciaranm: there is no such thing as asymptotic analysis either
02:49:26 <ciaranm> Nereid: that only helps you if your access patterns are non-random
02:49:36 <Jafet> My program crashes in constant time
02:50:26 <ciaranm> mine only crashes after a week or so of constant use :(
02:50:39 <confusing> there is no such thing as constant use :-)
02:50:52 <Nereid> ciaranm: anyway, the point was that !! should be avoided when unnecessary
02:51:09 <Nereid> when it's unnecessary, that is
02:52:09 <ciaranm> on an unrelated note, let's say i'm going to spend some fairly serious money on some GPUs to run haskell code on. do i want nvidia or amd?
02:59:59 <solrize> it looks like accelerate has better support for nvidia which is a bit unfortunate imho
03:00:05 <solrize> it cross compiles to cuda, i guess
03:02:16 <ciaranm> mmm. supposedly nvidia cards are quite a bit faster too.
03:02:22 <ciaranm> that's annoying.
03:16:35 <kostya> hello
03:16:48 <srhb> kostya: Hi!
03:18:46 <kostya> how would I get the first element of a list?
03:19:02 <srhb> kostya: You could pattern match it out, or use head, or some other, safer method
03:19:03 <Axman6> pattern matching
03:19:25 <kostya> and how to do pattern matching?
03:19:28 <confusing> > let f (x:xs) = (x + 1) in f [0..5]
03:19:29 <lambdabot>   1
03:19:30 <srhb> > case [1,2,3] of (x:_) = x
03:19:32 <lambdabot>   <no location info>: parse error on input `='
03:19:34 <confusing> kostya: ^^
03:19:36 <srhb> > case [1,2,3] of (x:_) -> x
03:19:37 <lambdabot>   1
03:19:41 <srhb> ^^
03:19:42 <kostya> thank you!
03:19:50 <hpaste> merijn pasted “Type woes” at http://hpaste.org/71989
03:20:21 <merijn> Compiler complains about my type signature, can I get some help to get the type I want?
03:20:26 <Chimpout> Hey guys!
03:20:32 <Chimpout> Snardbafulator is making me spam this!
03:20:37 <confusing> @where ops
03:20:38 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
03:20:40 <Chimpout> I am fucking sick and tired of fucking niggers!
03:20:50 <Chimpout> They are so god damn destructive to civilization!
03:21:02 <Chimpout> That is why I am a member of the best niggerhating organization in the world!
03:21:13 --- mode: ChanServ set +o Igloo
03:21:13 <kostya> KKK?
03:21:14 <merijn> ciaranm: My experience with CUDA/openCL is that nVidia has much nicer/better developed tooling
03:21:18 <kostya> worst*
03:21:21 <Chimpout> Chimpout Forum is not a white supremacist form.  We welcome all non-negroid races
03:21:24 --- mode: Igloo set +b *!*@110.77.212.85
03:21:28 <kostya> best would be not hating
03:21:28 --- kick: Chimpout was kicked by Igloo (Chimpout)
03:23:09 <kostya> Haskell never seems to do what I want it to!
03:23:25 <srhb> kostya: What's going on? :-)
03:23:37 <srhb> kostya: It's like that for a bit, but then you get smarter and suddenly it's all magic.
03:23:42 <srhb> (I may be biased...)
03:23:46 <kostya> it's a lot of minor things
03:24:00 <kostya> that would be awesome
03:24:01 <confusing> srhb: "smarter" in the sense of "more crazy"
03:24:08 <confusing> ;)
03:24:20 <srhb> kostya: Learning the basics of pattern matching, recursion and types will make you much better at writing programs that do what you want the first time around.
03:24:26 <srhb> confusing: Potato potato.
03:24:31 <srhb> Wait, that doesn't work in text...
03:25:03 <kostya> srhb: I still read it correctly
03:25:10 <confusing> kostya: put some code on hpaste and we can discuss it
03:25:14 <confusing> @where hpaste
03:25:14 <lambdabot> http://hpaste.org/
03:27:38 <kostya> Haskell seems to be really different from all the other languages I learned
03:27:46 <kostya> My first language was C++
03:27:53 <kostya> and when I learned Python it was really easy
03:27:56 <srhb> kostya: Most people learn imperative languages first, so functional is quite the mind bender.
03:27:59 <kostya> even through it had different syntex
03:28:03 <t7> kostya: you sound like me a year ago
03:28:04 <Axman6> kostya: you poor thing :(
03:28:05 <kostya> same with Lisp
03:28:22 <srhb> kostya: Here it's not even the syntax, it's that the solution space is completely different.
03:28:26 <knz> kostya: have you already used list comprehensions in python?
03:28:47 <kostya> no ;)
03:28:55 <merijn> kostya: That's one of the main reasons why haskell is worth learning :p
03:29:00 <knz> kostya: a haskell program is like a very very big list comprehension in python
03:29:08 <kostya> my python is really C++-like
03:29:10 <srhb> Oh dear..
03:29:14 <knz> aha
03:29:23 <t7> i was drawn to haskell because i kept looking for simpler and simpler (syntactically and operationally) programming languages
03:29:50 <knz> kostya: so, what made you look at hs in the first place?
03:30:15 <kostya> I just like learning different languges
03:30:26 <kostya> Programming is hobby for me
03:30:35 <kostya> so it seemed like a fun thing to do
03:30:35 <knz> ok
03:30:38 <kostya> which it is :)
03:30:41 <knz> excellent
03:30:44 <knz> that's the right attitude
03:30:54 <knz> what do you usually do when you learn a new language?
03:31:06 <Axman6> haskell is a tremendously fun language =)
03:31:09 <kostya> what do you mean?
03:31:13 <kostya> haha yeah
03:31:21 <knz> kostya: well learning a language is not just reading books I guess?
03:31:21 <merijn> hmm, what's the difference between "(IsStream s, IsStream s') => s -> s'" and "(forall s. IsStream s => s) -> (forall s. IsStream s => s)", if any?
03:31:23 <knz> what else do you do?
03:31:33 <kostya> books, practice
03:31:42 <knz> kostya: what kind of practice?
03:31:51 <kostya> writing real programs
03:31:58 <kostya> *practice programs
03:32:03 <srhb> merijn: There shouldn't be a difference, I think.
03:32:12 <knz> kostya: ok, so what pratice programs have you tried so far with haskell?
03:32:21 <confusing> kostya: funny you should say that :) for me it was similar. i was like "oh i never wrote anything in perl. i'm gonna learn perl. oh i never wrote anything in ruby ..." and so on. but now, since i found haskell, i have not much inclination to go and do something in python or whatever. it just feels like going back, or down. it just feels like you give up a lot for no gain :)
03:32:40 <kostya> one-line programs from tutorial :)
03:32:49 <srhb> kostya: Reading LYAH?
03:33:03 <t7> merijn: the first guarantees the types are the same, the second can have a -> b
03:33:14 <kostya> http://tryhaskell.org
03:33:23 <kostya> and I just ordered a book from Amazon
03:33:28 <PorchMonkey> Hi..  I am fucking sick of god damn niggers!
03:33:28 <knz> kostya: ok
03:33:34 <PorchMonkey> That is why I am a amember of a special forum
03:33:34 <t7> here we go ...
03:33:35 <confusing> @where ops
03:33:35 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
03:33:40 <PorchMonkey> called chimpout forum
03:33:40 <srhb> Igloo: Halp!
03:33:43 <PorchMonkey> uu uuuuuu
03:33:52 <PorchMonkey> You can visit our nifty site here http://www.chimpout.com/forum
03:33:54 --- mode: ChanServ set +o Saizan
03:33:56 <PorchMonkey> uuu uuuuu
03:33:59 --- mode: Saizan set +b *!*spamking@180.183.239.*
03:33:59 --- kick: PorchMonkey was kicked by Saizan (PorchMonkey)
03:34:08 <confusing> thanks saizan
03:34:10 <t7> whats the 'uuuuu'  ?
03:34:10 <srhb> Saizan: :)
03:34:16 <Axman6> Saizan: it might be a good idea to set +r for a while
03:34:19 <srhb> t7: A song.. of hate and bigotry?
03:34:20 <knz> kostya: so it looks you have everything going right for you
03:34:21 <kostya> sound of him being kicked?
03:34:33 <merijn> t7: The first does *not* gaurantee they are the same
03:34:39 <merijn> t7: It uses s and s'
03:34:46 <t7> ah my bad
03:35:03 <t7> should have gone to spec-savers
03:35:31 <merijn> Somehow the compiler keeps bitching at me when I write a type like that, saying I want ImpredicativeTypes, but afaict I don't want impredicative types...
03:36:50 <S11001001> merijn: maybe it's being holistic
03:39:11 <merijn> Essentially I just want to have a type "Foo a => (Int, a)" and a combinator that takes that as input and returns a "Foo a => (Int, a)" where the a in the return value is potentially different from the one in the input (determined by the function, not by the caller)
03:39:25 <merijn> i.e. I don't know which a the called function will return
03:40:33 <S11001001> merijn: sounds like you need to put it in a data box and have Rank2Types?
03:41:01 <S11001001> merijn: or do you expect to get the non-Fooness back from that a?
03:41:45 <merijn> S11001001: No, I just need the instance functions of Foo, the rest is completely uninteresting to me
03:42:02 <quicksilver> that is an existential type, merijn
03:42:09 <quicksilver> (which is also a rank 2 type indeed)
03:42:21 <merijn> quicksilver: Yeah, but just using that + Rank2Types is apparently wrong
03:42:32 <quicksilver> you also need to use the right syntax.
03:42:43 <confusing> tangentially, how do you turn on existentials? ExistentialQuantification?
03:42:45 <quicksilver> "Foo a => (Int, a)" is not a type, per se.
03:43:13 <merijn> I had "type Bar = forall a. Foo a => (Int, a)"
03:43:21 <quicksilver> can't do that.
03:43:24 <Nhiggerhater> Hi guys
03:43:30 --- mode: quicksilver set +b *!*dsfsdfsdf@180.241.255.*
03:43:30 --- kick: Nhiggerhater was kicked by quicksilver (Nhiggerhater)
03:43:31 <confusing> @where ops
03:43:31 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
03:43:35 <confusing> oh thanks quicksilver
03:43:35 <merijn> I need to use newtype/data?
03:43:39 <srhb> I may be not understanding it, but it's it just Foo a => (Int, a) -> (Int, b) ?
03:43:39 <quicksilver> yes
03:43:47 <kostya> that was quick
03:43:55 <merijn> srhb: b must also be an instance of Foo
03:44:04 <srhb> I may be not understanding it, but it's it just Foo a, Foo b => (Int, a) -> (Int, b) ?
03:44:05 <srhb> ?
03:44:12 <quicksilver> srhb: no
03:44:19 <quicksilver> srhb: because the function chooses 'b'
03:44:22 <srhb> Ah yes
03:44:26 <quicksilver> in  your data type, the caller gets to choose b.
03:44:33 <srhb> Right.
03:44:40 <srhb> Thanks. :)
03:45:03 <merijn> The caller gets to pick a, but the function picks b in the scenario I want
03:45:05 <quicksilver> data Bar = forall a. Foo a => MkBar Int a
03:45:09 <confusing> srhb: the function signature is basically saying "i can turn it into any sort of b that the caller chooses"
03:45:41 <merijn> I was looking at the the existential wiki page, but I'm not entirely sure how to use the stuff there
03:45:54 <srhb> Right, but aren't we approaching nonsense then. Either the type of b is entirely obvious, or the whole function is basically just a -> b and uninhabited.
03:46:28 <merijn> srhb: How so?
03:47:54 <merijn> srhb: My problem is: I have combinators of (essentially) type Stream -> Stream. But I have some things using bounded streams and other unbounded streams. So I need combinators that will take either as input and return as output whichever one they use for output. Make sense?
03:48:09 <srhb> merijn: I think I should shut up, these types are too advanced for me. What I'm thinking is that if the function decides the b, then there can only be one value of b, and not forall b. But I obviously don't understand the issue fully, so I'll be quiet. :-)
03:49:42 <merijn> srhb: If the function returns "forall b. Foo b => b", then (as far as I can follow stuff) then there is one value for b, but the caller doesn't get to decide *which* value
03:50:00 <merijn> The only thing the caller knows that it will be something that is an instance of Foo
03:50:01 <confusing> merijn: i may be talking out of my hindquarters, but how do the combinators "Stream -> b" decide if b is gonna be an Unbounded or a Bounded? in other words, is it an option to split it in two combinators "Stream -> Unbounded" and "Stream -> Bounded"?
03:50:23 <shachaf> srhb: The simple way to understand forall is as another argument, which is a type.
03:51:05 <srhb> confusing: Or Either Bounded Unbounded?
03:51:23 <srhb> shachaf: How so?
03:51:41 <merijn> confusing: Imagine serial composition of "Stream -> Unbounded" and "Stream -> Bounded", the serial composition should work if you reverse the two as well
03:52:13 <knz> merijn: sounds like you could still sue the split unbounded/bounded, but have both a sub-type of stream
03:52:14 <confusing> srhb: right. that's probably syntactically awkward, but basically what he's asking for, as i understood it
03:52:18 <shachaf> srhb: Dependent-type-style.
03:52:51 <shachaf> srhb: For example, id :: {A :: *} -> A -> A
03:52:57 <shachaf> ...That might be more confusing than clarifying.
03:53:02 <shachaf> @google mainisusuallyafunction forall
03:53:04 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
03:53:04 <Snardbafulator> I am fucking sick of niggers
03:53:07 <Guest84910> god damn it
03:53:08 <Guest84910> fucking niggers
03:53:13 <shachaf> srhb: That article might help.
03:53:18 <Guest84910> fucking nigdgersfsdfsdfsadfasdjfasdlkfjl
03:53:20 <confusing> @where ops
03:53:20 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
03:53:22 <srhb> shachaf: Thank you :)
03:53:25 <Guest84910> Join Chimpout Forum please   today  oh god
03:53:33 <Guest84910> you will love our chimpout niggerhating forum
03:53:36 <Guest84910> check out this link today
03:53:37 <Guest84910> jejejeje
03:53:48 <Guest84910> http://www.chimpout.com/forum   fuck you snardbafulator
03:53:50 --- mode: Igloo set +b *!*A*@118.99.80.48
03:53:56 --- mode: Igloo set +b *!*@118.99.80.48
03:54:00 --- mode: Igloo set -b *!*A*@118.99.80.48
03:54:04 --- kick: Guest84910 was kicked by Igloo (Guest84910)
03:54:31 <confusing> thanks, Igloo
03:55:29 <zomg> Your nick is quite appropriate
03:55:35 <zomg> Since that was very confusing
03:55:36 <zomg> lol
03:55:37 <VerizonHunny> Oh god
03:55:46 <VerizonHunny> Are you sick and tired of those god damn niggers!???????
03:55:53 <zomg> rofl
03:56:02 <Axman6> no +r yet? :\
03:56:06 <shachaf> idoru++
03:56:34 <Botje> Axman6: amazingly enough, #haskell is far enough down the channel list that spambots get klined before they get here
03:56:35 <kostya> If by "n***" he is referring to himself and his clan of haters, than yes, I am tired of them
03:56:50 <t7> It cant be cost effective to get a few page views on a website this way
03:57:02 <zomg> t7: I always found it odd as well
03:57:04 <Axman6> Botje: not really, if you've been here for the last few hours you'd see we've been getting it every few minutes
03:57:04 <srhb> t7: No, especially when it's done manually. Weird.
03:57:34 <Botje> Axman6: ah, I just arrived at the university :)
03:57:55 <confusing> Botje: currently it seems to be about 1 bot every 10 mins
03:57:56 <Axman6> als I'm pretty sure it'a not bots, sadly it's real people
03:58:12 <kostya> yeah, they are saying different stuff each time
03:58:13 <Botje> it's probably a kid giggling to himself in his basement.
03:58:20 <kostya> or Java programmers
03:58:40 <ibid> they're apparently successful in getting attention
03:58:40 <kostya> I just got my first program to work
03:58:42 <kostya> let f (x : xs) = map toUpper x in f ["hello"]
03:58:47 <t7> at least troll with CP or something
03:58:54 <Botje> kostya: hurray!
03:58:57 <t7> racism isnt a big deal anymore
03:58:58 <Botje> kostya: why the [] ?
03:58:59 <kostya> Before it was let f (x : xs) = toUpper x in map f ["hello"]
03:59:01 <t7> CP is the last taboo
03:59:10 <kostya> Botje
03:59:24 <kostya> Botje: at first it was an accident, but then I just wanted it to work with [] too
03:59:26 <ibid> CP?
03:59:36 <knz> concurrent programming
03:59:39 <ibid> ah
03:59:57 <Botje> kostya: ah, okay :)
04:00:04 <bitonic> ibid: I think t7 was tan
04:00:15 <bitonic> talking about child porn, but yeah concurrent programming is better than that
04:00:34 <unlink> he was talking about continuation passing, actually.
04:00:42 <ibid> all i could think of was cerebral palsy and i figured it aint' that
04:00:45 <unlink> which I personally find rather offensive.
04:00:48 <ibid> (that'd been personal)
04:01:51 <t7> actually posting hollywood film torrent links would get you arrested quicker than child porn :)
04:02:45 <ibid> t7: you have data on that?
04:03:18 <t7> maybe a partially true anecdote... ?
04:04:12 <ibid> not funny then
04:04:33 <t7> you have any data on that?
04:04:45 <ibid> nope
04:04:46 <kostya> funny
04:05:13 <ibid> yeah, agreed :)
04:05:56 <kostya> are Haskell Interpreters written in Haskell?
04:06:07 <t7> yrd snf no
04:06:16 <kostya> ?
04:06:16 <t7> where is my home row
04:06:17 <ibid> mostly no
04:06:27 <kostya> why?
04:06:27 <ibid> would be rather useless
04:06:31 <Axman6> kostya: GHCi is
04:06:33 <srhb> ibid: Huh?
04:06:38 <ibid> of course ghci is, but that's a special case
04:06:46 <ibid> hugs isn't
04:06:47 <knz> ibid: why not?
04:06:50 <confusing> kostya: most of ghc and ghci is written in haskell
04:07:06 <kostya> cool
04:07:15 <MamameLaVerga> I am fucking sick and tired of putting up with niggers!
04:07:22 <kostya> and is there a place with open-source Haskell programs to study the code?
04:07:28 <Axman6> @where ops
04:07:28 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:07:32 <srhb> kostya: Hackage, for one. :)
04:07:36 <confusing> Axman6: he's gone already
04:07:37 <b__> kostya, Hackage, Github
04:07:38 <ibid> srhb, knz: to install an interpreter (other than ghci), why would one bother installing a compiler?
04:07:39 <t7> Axman6: you can just ignore it now
04:07:55 <srhb> ibid: If it was packaged as a binary, why would you want to?
04:07:55 <Axman6> right, missed that. good to see the cops are awake =)
04:08:04 <srhb> ibid: Not that there's any other relevant interpreter than ghci.
04:08:36 <ibid> srhb: hugs, not as relevant as it used to be but still not completely irrelevant
04:09:04 <srhb> ibid: Mixed opinions on that, but it hardly matters. Let's say that the most used interpreter is indeed written in Haskell.
04:09:17 <ibid> srhb: true, and i've never said otherwise
04:09:40 <kostya> Why is hugs not as relevant as it used to be?
04:09:43 <srhb> :P Then you were very unclear, but this is an irrelevant discussion.
04:09:53 <hpc> kostya: because it hasn't been updated since 2008
04:09:59 <kostya> oh
04:10:09 <ibid> knz: because there's ghci
04:10:13 <ibid> sorry
04:10:17 <ibid> kostya: because there's ghci
04:10:23 <kostya> ok
04:10:39 <kostya> gtg, thanks for answering my noob questions!
04:10:40 <ibid> kostya: when i started with haskell, hugs was the only interpreter available
04:10:51 <ibid> some time later, there was talk of merging hugs and ghc
04:11:03 <ibid> but that never happened, instead the ghc folks wrote ghci
04:11:33 <kostya> ok
04:11:37 <kostya> bye
04:11:56 <ibid> (those times, ghc wasn't packaged almost anywhere. certainly not in debian which i used and still use)
04:12:36 <ibid> srhb: what's "very unclear" about "mostly"?  it does mean "not all" :)
04:14:40 <GodKillTheQueen> I am sick of fuckin gniggers and their monkeyshines and all of the problems that they cause!
04:14:46 <GodKillTheQueen> What about you guys here at Haskell?
04:14:51 <GodKillTheQueen> I know you all have to hate niggers too!
04:14:59 <confusing> @where ops
04:15:00 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:15:05 <GodKillTheQueen> That is why I recommend that you all join the great forum that is called Chimpout Forum!
04:15:05 <ibid> (i admit my thinking was a bit behind times, there was a time when the main reason you'd want an interpreter is because you can't use the compiler, for whatever reason.  nowadays the compiler is well enough supported that that's not really a reason to use interpreters, and thus the implementation language tradeoff is different)
04:16:10 <srhb> ibid: Eh, let's drop the point. If you think counting non-compliant interpreters and that "two more than in Haskell are written outside it..." is mostly, that's fine with me. I disagree, but it really doesn't matter to you, me or anyone else. :)
04:17:17 <zomg> I'm kind of curious how many new members those stupid forums are getting for this spam
04:17:20 <zomg> :P
04:17:29 <zomg> And I mean not just people who register to post something like "fuck you spammers"
04:17:43 <zomg> I would imagine it being very close to 0
04:17:55 <shachaf> The point is not to advertise the forums.
04:18:24 <zomg> What then? I can't imagine they'd be getting so many clicks any CPM ads would pay much either
04:18:48 <b__> the point is to hate
04:18:53 <b__> and to spread hate
04:18:54 <chu> No, they have issue with a certain channel on freenode. Don't worry about it too much.
04:19:22 <shachaf> I think the main point is just to annoy people.
04:19:45 <chu> It's all because they were removed from ##philosophy and a new operator was appointed who they don't like.
04:19:58 <chu> (Possibly not "all", but their main reason at least).
04:20:10 <zomg> Yeah I thought for much of the spam it was reasons like that
04:20:23 <zomg> Used to see a lot of it (and trolling) on ##Javascript but not here
04:21:08 <irene-knapp> oh, curious
04:21:30 <irene-knapp> but I agree with shachaf.  that may be the proximate cause but the ultimate cause is to be a nuisance.
04:21:53 <zomg> I guess they don't realize it that it's more effort for them to do that than for anyone to ignore it
04:21:56 <zomg> =)
04:22:01 <b__> well that's not true
04:22:03 <irene-knapp> I dunno, it causes angst, haha
04:22:18 <ibid> srhb: i'm a bit curious that you want me to drop it but felt compelled two write two lines' worth of text about it :-)
04:24:24 <hpaste> int-e pasted “is this considered safe?” at http://hpaste.org/71991
04:27:45 <slack1256> let say I define 'type Song = String'
04:28:09 <slack1256> how do i tell ghc to normalize all the operation the results in FilePath to type Song?
04:28:16 <slack1256> *operations
04:28:27 <hpc> slack1256: do you know what 'type' does?
04:28:29 <shachaf> You don't.
04:29:24 <slack1256> hpc: yes I do, but It keep telling me that they are different.
04:29:33 <slack1256> *keeps
04:31:17 <hpc> i think you have an unrelated problem, then
04:31:32 <merijn> slack1256: FilePath is not a String, I think
04:31:33 <slack1256> mm, they should be.
04:31:44 <hpc> @hoogle FilePath
04:31:44 <lambdabot> Prelude type FilePath = String
04:31:45 <lambdabot> System.IO type FilePath = String
04:31:45 <lambdabot> System.FilePath.Windows type FilePath = String
04:31:57 <slack1256> at least in System.FilePath.Posix it is.
04:32:02 <quicksilver> slack1256: in what way does it "keep telling you they are different" ?
04:32:21 <quicksilver> however, there is very little control about the limited extent that GHC normalises type aliases
04:32:29 <quicksilver> which is one reason I avoid using them.
04:34:12 <adimit> I usually avoid type aliases because it can get hairy down the road with type classes and instances thereof.
04:35:32 <shachaf> And with lack of type safety.
04:35:51 <hpc> i use type aliases when i would make a new type anyway, but a new type would get in the way of hacking up a prototype
04:36:14 <hpaste> slack1256 pasted “type normalization” at http://hpaste.org/71993
04:37:25 <adimit> they're good for hacking up prototypes. But it happened to me yesterday that I wanted to add a type class, and instantiate some of my types to it, but then I noticed I had failed to make 'em newtypes, and suddenly I had to refactor a ton of code in order to make a *very* minor feature work that relied on this type class.
04:37:38 <slack1256> I know is a dumb script. But I have too many boring songs that I would to listen and them eliminate
04:38:47 <siracusa> And what is the reported error?
04:38:52 <confusing> slack1256: could you copy the error message you're getting and add it to the hpaste?
04:39:08 <slack1256> sorry . just a sec
04:40:14 <slack1256> wait
04:40:19 <confusing> int-e: that looks like a good question :-o
04:40:27 <Botje> (you can use annotate instead of creating a new paste)
04:40:29 <slack1256> sorry guys, I already know my error
04:40:44 <confusing> slack1256: no worries :)
04:40:47 <slack1256> I can't believe this far ahead I keep getting monads wrong
04:42:34 <slack1256> it wasn't that didn't normalize, It was it couldn't because (IO [FilePath] /= Song)
04:42:46 <quicksilver> yes
04:42:58 <quicksilver> the confusing error message hides the fact that the problem isn't actually FilePath/Song
04:43:02 <quicksilver> the problem is the IO :)
04:43:08 <quicksilver> (and maybe that [] as well)
04:43:19 <slack1256> @slap slack1256
04:43:19 <lambdabot> I'd rather not; slack1256 looks rather dangerous.
04:43:27 <hpc> ha!
04:43:37 <slack1256> damn you lambdabot! hit me!
04:49:35 <tew88> RE: RWH, CH09 -- in this snippet, could someone explain why (on line 17) we wrap the value in an otherwise empty list and then call concat on it: why can't we just not wrap the value in the first place?
04:49:44 <tew88> http://hpaste.org/71994
04:50:07 <tew88> I've tried, and I OFC get a type error, but I'm not quite sure *why* this is the case
04:50:22 <Botje> tew88: what is the type of getRecursiveContents path on line 16 ?
04:51:05 <tew88> Botje: FilePath -> IO [FilePath] ?
04:51:15 <confusing> tew88: as an addition to what Botje said, the "then" and "else" branch always have to have the same type
04:51:18 <Botje> well, you already gave it a FilePath, so it's IO [FilePath]
04:51:39 <Botje> so the other branch also needs to be of type IO [FilePath]
04:51:53 <shachaf> tew88: The list has one element only in the leaves.
04:51:58 <Botje> and that's exactly what return [path] does
04:52:18 <shachaf> I.e., when you find a file instead of a directory.
04:52:45 <shachaf> But in the directory case the list can have more than one element.
04:53:11 <tew88> OK, so this is porbably a stupid question, but if I could somehow say that: let items = filter (`notElem` [".", ".."]) names :: [FilePath] -- could that work?
04:53:31 <tew88> No, cos it's IO [FilePath] ¬_¬
04:53:56 <byorgey> tew88: what is IO [FilePath]?
04:53:59 <tew88> Ah, but I'd be 'returning' it to wrap it in an IO context
04:54:18 <Botje> tew88: after line 10 names has the type [FilePath]
04:54:37 <Botje> so you're allowed to do that.
04:54:44 <byorgey> tew88: yes, that code looks like it should work fine to me
04:54:54 <confusing> tew88: you're looking for a way to merge lines 10 and 11, right?
04:55:18 <merijn> tew88: Why even bother returning items? Why not just change forM into map?
04:55:37 <tew88> confusing: You're giving me too much credit, I'm merely wandering around cluelessly :)
04:56:35 <tew88> merijn: I thought forM and mapM were the same, with their params switched
04:56:57 <merijn> tew88: Yes, but I said map, not mapM, since items is [FilePath], not IO [FilePath]
04:57:07 <merijn> :t forM
04:57:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
04:57:12 <merijn> Actually, nvm
04:57:15 <merijn> forM makes sense
04:59:35 <confusing> tew88: no worries :) for the record, you could do something like "items <- fmap (filter (`notElem` [...])) (getDirectoryContents topdir)". that does the job of lines 10 and 11, getting rid of 'names', since it's read only once. fmap in this case takes a pure function and applies it inside the IO
04:59:47 <merijn> Unless I'm glossing over some typos/subtleties it looks like it should work to me
05:00:12 <merijn> confusing: Yeah, but that makes the line 10 pretty long, though
05:00:18 <merijn> Not sure that'd be an improvement
05:02:06 <merijn> > liftM2 (+) (Just 1) (Just 2)
05:02:07 <lambdabot>   Just 3
05:02:11 <merijn> > liftM2 (+) (Just 1) Nothing
05:02:13 <lambdabot>   Nothing
05:02:33 <confusing> merijn: sure, i think both choices are stylistically fine. i just have a latent phobia of names that are created and then used only once
05:08:49 <timthelion> Any clue why ghc is running(twice) even though I'm not compiling anything
05:09:02 <luite> could be ghci or runhaskell
05:09:08 <confusing> timthelion: any open ghci windows?
05:09:17 <hpc> using haskell-mode?
05:09:31 <hpc> also
05:09:34 <hpc> $ px aux | grep ghc
05:09:45 <hpc> should say what command-line parameters ghc got
05:09:53 <timthelion> confusing: of course, I'm an idiot :D
05:10:58 * hackagebot ivar-simple 0.2 - Write once concurrency primitives. (BertramFelgenhauer)
05:11:16 <hpc> is there a reason hackagebot isn't printing links anymore?
05:11:33 <confusing> hpc: has it ever ...?
05:11:46 <siracusa> hpc, Yeah, I wondered about that too
05:14:44 <int-e> @hackage mtl
05:14:44 <lambdabot> http://hackage.haskell.org/package/mtl
05:18:35 <Botje> timthelion: pstree | grep -C1 ghc can also help, sometimes
05:19:38 <timthelion> Botje: for a seccond there, I had this panic, that Haskell was secretly evil like java
05:20:41 <S11001001> timthelion: is java secretly evil, or would the secret be that haskell, like java, is evil?
05:20:49 <S11001001> I always thought of java as openly evil
05:21:20 <timthelion> S11001001: the later
05:21:21 <confusing> S11001001: *shrug* java is at least a step up from php or c
05:21:34 <timthelion> confusing: no,
05:23:37 <timthelion> I write drivers and firmware in c, would never do that in haskell
05:26:08 <int-e> hmm, is there a username -> packages lookup for hackage somewhere?
05:26:16 <merijn> confusing: java is definitely not a step up from C
05:28:07 <confusing> timthelion: there's a niche for c, but still, i think most c code is an accident waiting to happen. writing good c code needs a lot of knowledge of subtleties and a lot of discipline (almost superhuman discipline)
05:28:25 <alpounet> int-e, people on haskellers.com generally list their packages on their profile, you may find what you want there, but only for people who are on haskellers and who lists their packages...
05:29:09 <timthelion> it's strange, it's hard to come up with a good reason to hate java when you code in it... It's so easy to write... but with the weird gc, and the unusable/unaccessable gui's, and the non functional web apps, it's easy to hate as a user
05:29:41 <confusing> merijn: i think it is. unknowingly doing unsafe things is much harder in java than it is in c
05:30:32 <srhb> timthelion: I'm plenty able to hate it as a developer. So much gunk, so much work to get simple things done.
05:30:38 <Nereid> C is good at what it does
05:30:41 <srhb> But I suppose you can get used to many things.
05:30:46 <Nereid> imo
05:32:53 <quicksilver> it's very hard to compare Java and C because ones experience of Java is dominated by the many, enormous, common libraries
05:32:55 <timthelion> srhb: I can write a crash prone application in java, in half the time it takes me to write a bug free version of the same code in haskell.
05:33:08 <quicksilver> whereas many C programmers write code against no libraries or few libraries.
05:33:16 <srhb> timthelion: OK, i don't know what kind of comparison that is. :-)
05:33:22 <merijn> confusing: Hah
05:33:37 <merijn> confusing: Deadlocking/leaking memory and getting null pointer exceptions is trivial in Java
05:33:52 <merijn> Also, the libraries are mostly braindead
05:34:02 <timthelion> and compairing c to java is a bit like compairing tweezers to a sledge hammer...
05:37:02 <confusing> merijn: (i can't believe i'm in the position of defending java ...) i feel "index out of bounds" exceptions are a step up from the c solution of silently corrupting memory. crashing on nullpointer exceptions is not a step up from c, but not a step down either
05:38:14 <Botje> except there's JSR-305
05:38:21 <merijn> Having references instead of pointers is a step down if you're references aren't going to be null-safe
05:38:25 <Botje> with @NonNull annotations
05:41:28 <Athas> merijn: references are still better than pointers in that they're usually checked.
05:42:14 <confusing> anyhow, when i said "unknowlingly do unsafe things", i meant mostly the whole mess of buffer overflows, security problems, silent data corruption. that seems to be very much diminished in java. yes it's not crash-safe, but it seems to be pretty memory-safe
05:42:15 <quicksilver> a null pointer exception is easier to debug than undefined behaviour
05:42:29 <quicksilver> you're not guaranteed to get a usable stack trace from a C null pointer
05:44:10 <ciaranm> especially now that gcc is clever enough to "optimise out" null pointer dereferences
05:44:16 <ciaranm> by replacing them with no-ops...
05:44:36 <merijn> ok, completely unrelated: how the fuck do I implement an instance for Read? I managed to do it once before, but trying to copy that approach just results in the compiler complaining at me...
05:44:42 <Athas> Is that a side-effect of some other optimisation, or does it explicitly handle null pointers?
05:45:05 <ciaranm> Athas: it knows that dereferencing a null pointer is UB. it also knows it can replace UB with a no-op.
05:45:06 * Saizan complains at merijn 
05:45:19 <Saizan> merijn: now it's not just the compiler
05:45:34 <ciaranm> Athas: see also: for (int i = 0 ; i > 0 ; ++i) { } . gcc will optimise that into either a no-op or an infinite loop.
05:45:38 <Saizan> merijn: but you should paste code and type errors
05:45:41 <roconnor> merijn: I implement read by going to the Haskell Report and copying its example
05:46:21 <Botje> ciaranm: except on a 32bit system the loop will eventually terminate ;)
05:46:31 <ciaranm> Botje: incorrect
05:46:35 <merijn> Saizan: I don't really have specific code yet as I have no clue where to start. My previous code used Text.ParserCombinators.ReadP, but according to GHC the parsers there don't match the expected type for readPrec?
05:46:38 <ciaranm> Botje: in C that's UB
05:47:02 <Botje> of course
05:47:16 <Botje> and the actual behavior is "just increment the damn thing again" ;)
05:47:26 <Saizan> merijn: there's a function to convert from ReadP to ReadS
05:47:28 <ciaranm> the actual behaviour is that gcc optimises it into an infinite loop
05:47:35 <ciaranm> or a no-op
05:49:17 <Botje> indeed it does
05:49:28 <Botje> although it's still stupid if you make i volatile
05:49:44 <ciaranm> "volatile" does not mean what you think it means!
05:50:19 <Botje> it means you *have* to write to i's location every time, no?
05:50:35 <ciaranm> locally...
05:50:59 * hackagebot egison 2.3.4 - An Interpreter for the Programming Language Egison (SatoshiEgi)
05:51:29 <ciaranm> anyway, the correct solution is obviously to make the type of (+) be (Num a) => a -> a -> Maybe 1
05:51:34 <ciaranm> where 1 is an a
05:53:40 <merijn> Saizan: That doesn't seem right, the type for readPrec is "ReadPrec a", not "ReadS a"
05:56:16 <pshr> hi , I am new to yesod and haskell and I am trying to install yesod on mac osx lion when I do cabal install yesod-platform i get the following error cabal: Error: some packages failed to install: hamlet-1.0.1.4 failed during the building phase. The exception was: ExitFailure 1 hspec-1.2.0.1 failed during the building phase. The exception was: ExitFailure 1
05:56:22 <pshr> and there are also other packages like yesod-form yesod-core saying that they depend on shakespear -i8ln which failed to install
05:57:06 <Axman6> pshr: try installing hspec
05:57:59 <pshr> Axman6: hspec-1.3.0 depends on hspec-expectations-0.3.0.1 which failed to install. failed during building phase
05:58:24 <Axman6> can you paste all the output from cabal install hspec-exceptions ?
05:59:31 <merijn> Saizan: Ah, bollocks. I figured it out. I had a lift hidden away in a helper function...
05:59:35 <hpaste> shirish pasted “hspec paste” at http://hpaste.org/71997
06:00:53 <pshr> Axman6:  http://hpaste.org/71997 here is the pasted output
06:01:15 <Axman6> what does ghc-pkg check say?
06:03:15 <luite> pshr: have you removed or moved a .cabal dir?
06:04:32 <pshr> luite: I deleted that once but I reinstalled haskell-platform again so it got created back again
06:04:33 * Axman6 hands over to luite because he's far from an expert in fixing cabal's problems
06:04:51 <pshr> I remember doing ghc-pkg unregister for some packages
06:05:14 <Axman6> yeah sounds like things are quite broken
06:07:33 <hpaste> shirish pasted “ghcpkg” at http://hpaste.org/71999
06:08:14 <pshr> Axman6: luite : here is the paste from ghc-pkg check http://hpaste.org/71999
06:16:00 * hackagebot isevaluated 0.3.0.2 - Check whether a value has been evaluated (BertramFelgenhauer)
06:19:33 <confusing> i just ghc-pkg-check'd this one cabal-dev package directory i have, and it produces output similar to what pshr pasted :-/ i did "cabal-dev install -p juicypixels" and 1-2 other packages. it seems it's quite easy to get to a very broken state with 2-3 innocent commands
06:19:43 <confusing> i wonder if that has gotten worse recently
06:20:23 <luite> pshr: ah those packages look really broken. check with ghc-list in which package db the yesod packages have been registered, and remove the whole thing
06:20:44 <byorgey> confusing: it has gotten better recently with newer versions of cabal, actually.
06:21:39 <confusing> byorgey: ah, good to know, i'll check for updates
06:28:15 <pshr> luite: luite will uninstalling haskell-platform and re installing 32 bit version of haskell platform resolve the ghc issues too ?
06:29:31 <luite> pshr: probably, they have a different architecture which means that these directories will change
06:29:52 <mroman> How can I resolve import cycles?
06:29:59 <mroman> Are there any concepts like forward declarations?
06:30:32 <AfC> mroman: there was a discussion of that on haskell-cafe not too long ago. Might check there.
06:30:44 <luite> there's a {-# SOURCE #-} input pragma, but usually ou just want to combine the modules
06:31:20 <geekosaur> ghc's cycle handling is primitive, there's thr SOURCE pragma and hs-boot files
06:32:34 <confusing> mroman: if you're very sure that cyclical imports is what you need, there's ways to do that. if you're not entirely sure, ask in here how you might structure your modules differently so that you don't have cycles in the first place
06:33:36 <mroman> Well... depends
06:33:49 <mroman> I just don't like big source files
06:33:56 <mroman> I have a Module Eval which evals stuff
06:34:08 <mroman> and I have a Module Builtins with primitives called from Eval
06:34:15 <mroman> and one of these primitives likes to call eval too
06:34:17 <mroman> (recursion)
06:34:32 <mroman> I can merge everything into a single .hs file.
06:34:36 <mroman> But that's ugly imo.
06:36:31 <luite> mroman: you can merge them into a single .Internal module and reexport stuff from there to the user
06:36:41 <confusing> mroman: the simplest thing might be to move that one recursive builtin into the Eval module. or maybe you could move it into its own module which imports Eval and Builtin
06:37:39 <confusing> so it'd be Eval, Builtin, and ComplexBuiltin or whatever. Eval does not need to import ComplexBuiltin, only Builtin. Builtin does not need to import anything
06:37:51 <confusing> ... just some thoughts :)
06:39:40 <confusing> mroman: you could also view the modules from the perspective of the importer. is there any plausible case where a user of your library would want to import Eval, but not Builtin? if not, you might want to merge them
06:41:10 <mroman> confusing: Importing builtin is unecessary for the importer.
06:41:15 <mroman> You just wan't to call eval.
06:41:19 <mroman> *want
06:41:37 <mroman> eval needs a list of all builtins functions.
06:43:22 <mroman> I don't export the builtin function.
06:43:31 <mroman> Nobody is supposed to call them except the eval function.
06:43:32 <beaky> hello m8s
06:43:58 * applicative wonders what magic sauce is in the crushing scala mandelbrot entry http://shootout.alioth.debian.org/u64q/program.php?test=mandelbrot&lang=scala&id=4
06:44:15 <mroman> I have a builtins = [(String,builtinFunction)] which is the only thing my Builtin Module exports.
06:45:27 * applicative wonders why haskell is the only programming language that isn't hideously ugly.
06:45:31 <confusing> mroman: it's just that when i look at some package on hackage, i find it confusing if it shows 10 packages of which 8 are some internal stuff i'm not meant to use anyway :) so i think from that perspective, it'd be clearer if you don't show the Builtin module as there's no reason for anyone to use it directly
06:45:56 <applicative> beaky: are you studying haskell?
06:45:57 <confusing> beaky: welcome
06:46:08 <mroman> confusing: You can hide Modules?
06:46:19 <beaky> I am on chapter 2 of LYAH
06:46:23 <mroman> It's just... logically Builtin doesn't fit into Eval.hs
06:46:25 <applicative> hurrah
06:46:25 <beaky> types and typeclasses
06:46:26 <confusing> mroman: er right, forgot about that 8-/
06:46:41 <mroman> but right now I merged Builtin.hs into Eval.hs so I my builtins can call back to eval.
06:46:53 <mroman> but I'm not happy with that.
06:47:02 <applicative> the number typeclasses are a bit of a nightmare. you get used to it quickly though, beaky :)
06:47:38 <mroman> I use a state monad
06:47:40 <applicative> the ones like Functor, though, are like something sent from Heaven
06:47:46 <mroman> So I could keep a handle to the eval function there
06:48:02 <mroman> so I wouldn't need to import Eval in Builtin
06:48:08 <mroman> but that's a hack :)
06:48:11 <isomorphic> I'm trying to understand some code that runs in a do block - it's a bit tough to put it into ghci - is there a good way to display the inferred types within the do-block?  ie: print the types?
06:49:29 <sclv> @bot
06:49:29 <lambdabot> :)
06:49:30 <byorgey> isomorphic: if you have a line    x <- blah   in your do-block, you can write   :t blah   at the ghci prompt
06:49:44 <sclv> @tell mightybyte pong
06:49:44 <lambdabot> Consider it noted.
06:49:48 <byorgey> isomorphic: and if  blah  references some variables from earlier in the do-block, you can write   :t \x y -> blah
06:50:11 <mroman> module Eval (eval) where import Builtins; module Builtin (builtins) where import Eval
06:50:26 <isomorphic> byorgey:  Based on your user name, I'd say I was reading your work earlier tonight ;)  Thanks :)
06:50:29 <beaky> how do I get lambdabot to execute haskell code?
06:50:38 <byorgey> isomorphic: hehe, probably =)
06:50:39 <mroman> > "executed!"
06:50:40 <lambdabot>   "executed!"
06:50:43 <sclv> @undo do {y <- foo; baz y;}
06:50:43 <lambdabot> foo >>= \ y -> baz y
06:50:50 <mroman> > "beaky: Use > "
06:50:51 <lambdabot>   "beaky: Use > "
06:50:57 <applicative> isomorphic: you are aware of what byorgey was presupposing, namely that you can just do >  contents <- readFIle "foo.txt"  inside ghci
06:51:05 <beaky> > putStrLn "Hello, World!"
06:51:07 <lambdabot>   <IO ()>
06:51:10 <beaky> O.o
06:51:16 <applicative> then :t contents will tell you [Char]
06:51:23 <byorgey> beaky: lambdabot won't execute IO actions
06:51:24 <sclv> beaky: lambdabot don't do IO
06:51:28 <beaky> oh
06:51:34 <mroman> lambdabot no likey IO
06:51:37 <sclv> (if it did, think of the security issues!)
06:51:44 <beaky> does Haskell in general hate IO?
06:51:47 <byorgey> > readFile "/etc/passwd" >>= putStr
06:51:48 <lambdabot>   <IO ()>
06:51:49 <beaky> that's what I keep hearing about
06:51:49 <sclv> nah, just lambdabot
06:51:56 <sclv> haskell loves IO
06:52:01 <applicative> beaky: we love IO so much we put it on a pedestel
06:52:03 <c_wraith> haskell just wants you to be explicit about your use of IO
06:52:04 <sclv> that's why we have a special monad for it.
06:52:07 <applicative> it gets its own type!!!
06:52:10 <Axman6> IO is super special
06:52:13 <applicative> types
06:52:20 <Axman6> but it's like a gun, and needs to be kept locked up
06:52:21 <isomorphic> applicative: I think so
06:52:23 <applicative> IO is totally where the action is
06:52:41 <confusing> beaky: no, i'd say IO is pretty well organized in haskell
06:52:44 <S11001001> it's got special support for putting IOs in other IOs
06:52:56 <byorgey> yo dawg...
06:53:00 <isomorphic> S11001001:  I see where you're going.
06:53:02 <S11001001> but sclv said that
06:53:06 <byorgey> or should I say, IO dog...
06:53:17 <confusing> byorgey: :-D
06:53:23 <applicative> the yo monad
06:54:41 <beaky> what's a monad?
06:54:47 <Qtr> so is darcs buggy?
06:54:50 <Axman6> Maybe
06:54:52 <Axman6> lists
06:54:55 <Axman6> Either
06:54:56 <Axman6> IO
06:54:58 <mroman> byorgey: IO dwag, I put an IO in your IO so you can IO while you IO?
06:54:59 <applicative> beaky: don't worry, it will become clear
06:55:00 <Axman6> they're all monads
06:55:05 <byorgey> mroman: exactly
06:55:07 <applicative> Axman6: Either x
06:55:09 <mroman> I actually need that.
06:55:12 <Qtr> why didnt darcs become git(wasnt written by Torvalds in perhaps a possibnle answer)?
06:55:15 <c_wraith> beaky: monads are not really that important.
06:55:17 <mroman> I want eval in my eval so I can eval while I eval.
06:55:22 <beaky> right I'll just work through LYAH
06:55:29 <mroman> But Haskell won't let me do that with two different modules right away :(
06:55:32 <byorgey> Qtr: I use darcs quite heavily all the time, and I have encountered a (very minor) bug maybe once or twice ever
06:55:33 <applicative> Qtr don't bring up  darcs v git it's too painful
06:55:34 <c_wraith> Qtr: mostly, because there are cases where darcs gets *slow*
06:56:10 <c_wraith> byorgey: you never ran into exponential-time merges? They happened to me fairly often once a repo was over a few thousand patches
06:56:33 <byorgey> c_wraith: when I was hacking on GHC, yes, I ran into that.  I wouldn't classify that as a "bug" though
06:56:36 <applicative> Qtr the ghc used to be on darcs, til recently; it's about the size of the linux kernal if you exclude all the accompanying driver nonsense
06:56:50 <applicative> Qtr this did press the limits of darcs a bit....
06:57:03 <confusing> beaky: it's a typeclass in haskell with 3-4 functions in it. there's several instances for the typeclass in the haskell libraries (package 'base'). many functions in the libraries can take a Monad and do something with it. sorry it has such a goofy name
06:57:05 <c_wraith> byorgey: hmm. debateable, I guess - but it certainly doesn't make you want to use darks
06:57:20 <c_wraith> der, darcs.  too early to type
06:57:35 <byorgey> c_wraith: I agree it is probably a big contributing factor to why darcs hasn't caught on more widely.
06:57:42 * applicative has never run into these problems, but he only used darcs2 etc and 
06:57:51 <byorgey> Personally I still love darcs and use it a lot, but then again I don't have any repos big enough for it to matter
06:57:57 <applicative> doesnt generate patches at c_wraith 's arate
06:58:06 <byorgey> also, I think more recent versions of darcs do a much better job.
06:58:25 <applicative> its clear it's much better.
06:58:52 <confusing> beaky: imho, that's all there is to it. a lot of people have tried to find some philosophical meaning in that typeclass and write a tutorial about it, but none of that was very convincing to me :-)
06:59:04 <applicative> Qtr but we love git too
06:59:44 <applicative> beaky: don't think about Monad.  when you get to the relevant bits of LYAH you can add byorgey 's excellent tutorial too
07:00:16 <beaky> what's a good Makefile for simple haskell projects?
07:00:18 <applicative> @where typeclassopedia
07:00:18 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:00:19 <byorgey> confusing: that's all there is to the definition, but that's definitely not "all there is to it".  See http://byorgey.wordpress.com/2012/07/19/monads-easy-or-hard/
07:00:46 <byorgey> beaky: for simple Haskell projects, you don't need a Makefile, you need a .cabal file
07:01:00 <byorgey> then you can use the 'cabal' tool to build your project
07:01:21 <isomorphic> I'm still stumbling through with ghc's help (as opposed to reading too many tutorials).
07:01:44 <isomorphic> Actually, I'd appreciate an answer to what must seem to you like an obvious question
07:01:49 <beaky> isn't cabal proprieetary though?
07:01:52 <applicative> the ghci is the most awesome tutor imaginable.  It does have a funny accent though.
07:01:53 <beaky> proprietary*
07:01:59 <applicative> no
07:02:06 <byorgey> beaky: no.
07:02:11 <Axman6> proprietary? eh?
07:02:19 <Axman6> it's open source it comes with GHC
07:02:41 <isomorphic> -->  http://www.yesodweb.com/blog/2012/01/http-conduit     <--- this example - instead of writing the result to post-foo.txt, how can I coax it to return the responseBody to a point outside the do-block and putStLn it?
07:02:41 <byorgey> beaky: if you install the Haskell Platform (which is all open-source) you will get the 'cabal' tool along with it
07:03:36 <applicative> beaky: here is the bsd3  license https://github.com/tanakh/cabal/blob/master/cabal-install/LICENSE
07:04:49 <beaky> alright I will ask my package manager to uninstal ghc 7.4.2 and fetch haskell-platform instead
07:05:39 <Eduard_Munteanu> beaky: your distro might provide cabal too
07:06:20 <beaky> it does, and also something called hackage
07:06:26 <hpaste> Mouna pasted “a problem with Show” at http://hpaste.org/72003
07:07:27 <Qtr> And those cases have a known cause(like GC)?
07:08:17 <mouna> anyone could help me with Show ?
07:08:28 <Eduard_Munteanu> mouna: what did you type into ghci?
07:08:30 <Axman6> mouna: not unless you tell us your problem
07:08:56 <mouna> yes I gave the link before
07:09:09 <mouna> http://hpaste.org/72003
07:09:45 <Axman6> what did you execute?
07:09:54 <Axman6> seems you forgot an argument
07:12:10 <DMcGill> yes, that's the exact error you'd get if you put `drop' "foo"' into ghci
07:12:29 <applicative> drop' "foo" 2 will work mouna
07:13:07 <Cale> isomorphic: Well, with the caveat that I know nothing about conduit, if you can get the value that you want into a variable in the do-block, you can return it, and then capture the result of the runResourceT
07:13:42 <Qtr> what happened to dons?
07:13:44 <Cale> isomorphic: So you'll have something like   x <- runResourceT $ do ... ; return <something>
07:14:06 <Axman6> he got swallowed by Standard Chartered
07:14:09 <Eduard_Munteanu> preflex: seen dons
07:14:10 <preflex>  dons was last seen on #ghc 18 days, 20 hours, 55 minutes and 51 seconds ago, saying: i don't recall a time that the hetzner's been down before
07:14:12 <Axman6> i think
07:14:13 <mouna> right Axman6, I forgot an argument
07:14:25 * ksf wonders if there's some magic combinators he's missing to be able to use Text.XML.Stream.Parse's parsing combinators with said module's parseBytesPos
07:14:56 <Cale> Qtr: He's apparently working for Standard Chartered Bank
07:15:35 <beaky> how do I build statically-linked binaries using ghc
07:15:36 <Cale> ah, yeah, Axman6 already said :)
07:15:43 <applicative> isomorphic: maybe I'm not following but there is sinkHandle stdin as well as sinkFile "foo.txt"
07:15:43 <ksf> beaky, that's the default.
07:15:49 <Axman6> is it?
07:15:50 <isomorphic> Cale - thanks - yes, when evaluated, "responseBody res2"  should give a ByteString - so my plan was to just have that as the last line of the do-block and printStrLn the result ... unfortunately, that results in type problems
07:15:51 <beaky> really? but
07:15:53 <Axman6> oh right, yeah
07:15:56 <ksf> unless you mean statically-linked-to-c-libs.
07:16:09 <beaky> yeah
07:16:20 <Eduard_Munteanu> -optc-static -optl-static should do
07:16:29 <isomorphic> applicative: I've gutted the sinkFile stuff- idea being to just pass back a ByteString
07:16:40 <Cale> isomorphic: I think responseBody in this case is producing something of type Source m a because it is the first argument to ($$)
07:16:59 <beaky> :( it gives me linker errors
07:18:05 <isomorphic> Cale: FYI, Modified code  http://hpaste.org/71986
07:18:38 <isomorphic> Am looking into your point re the type returned by responseBody
07:20:40 <beaky> is haskell the future of programming languages?
07:21:05 <Cale> beaky: It is the present of programming languages
07:21:33 <Cale> beaky: The languages that most people are using are a good 30 years out of date :P
07:22:10 <beaky> like C and Fortran?
07:23:09 <Axman6> and C++ and Java
07:23:14 <Cale> and Go :P
07:23:15 <Cale> lol
07:23:56 <Cale> and Python and Ruby (which are pretty much Smalltalk in disguise)
07:24:19 <EvanR> s/30/40/
07:24:21 <EvanR> its 2012 ;)
07:24:24 <Cale> yes, that's true
07:24:51 <Axman6> Haskell's a spry 20 something!
07:24:51 <EvanR> Go D:
07:25:21 <EvanR> ruby is barely legal
07:25:34 <Axman6> good, it shouldn't be
07:25:37 <EvanR> lol
07:25:50 <edwardk> preflex: xseen roconnor
07:25:51 <preflex>  roconnor was last seen on freenode/#haskell 1 hour, 40 minutes and 10 seconds ago, saying: merijn: I implement read by going to the Haskell Report and copying its example
07:26:10 <Cale> EvanR: Yeah, but it's a much older language in spirit :P
07:26:36 <EvanR> ruby, cobol of the 2000s
07:26:48 <Cale> Ruby doesn't really have any features which are newer than 30 years old, as far as I can see.
07:26:57 <Axman6> @remember EvanR ruby, cobol of the 2000s
07:26:58 <lambdabot> I will remember.
07:27:25 <EvanR> well php is probably cobol of the 2000s, ruby is becoming more prevalent now i think
07:27:28 <merijn> If I'm spawning a bunch of threads, is there a simple way to block the main thread indefinitely? (until all threads exit, or until one of the other threads calls System.Exit, either is fine. Although I suspect the latter is simpler)
07:27:57 <merijn> EvanR: Let's face it, better Ruby than PHP
07:28:01 <EvanR> merijn: yeah, have all the threads write to a different mvar on exit, in the main thread mapM_ take the mvars
07:28:04 <Saizan> forever (threadDelay maxBound)
07:28:08 <EvanR> merijn: i am facing it, every day
07:28:12 <adimit> ghci & debugging question: given modules A, B, C, B imports A, C imports B, I want to :step through a function in A, but I need access to definitions in C. So if I load C directly, A isn't interpreted, and I can't set :break-points. If I then :add *A, I seem to lose access to all definitions in C. How do I set A to be interpreted while retaining everything in C? Do I need to import A directly from C?
07:28:49 <merijn> EvanR: Not all threads are spawned from the main thread, so I wouldn't know how to get access to an mvar in both the thread and main
07:28:51 <Cale> adimit: Make sure you don't have .o files lying around. I think it should interpret everything in that case.
07:29:02 <merijn> (Hence why I thought waiting for System.Exit would be cleaner)
07:29:45 <EvanR> merijn: wait for an exception from one of the threads? i figured you wanted to wait for all of them
07:30:00 <EvanR> have the spawner wait, and when its done signal the main thread
07:30:25 <adimit> Cale: that's not possible in my case, since I'm using cabal-dev.
07:30:32 <adimit> So I guess I can't use cabal-dev?
07:30:36 <merijn> EvanR: Well, there is a point where I know that no thread is still doing useful work (and should've been shutdown, but I don't really care if they're not)
07:30:50 <adimit> (cabal-dev requires cabal-dev build be issued before doing cabal-dev ghci.)
07:30:53 <EvanR> then you just need one mvar, main wait on that mvar
07:31:00 <EvanR> and at 'that point' write to it
07:31:08 <Cale> I'm afraid I don't know anything about cabal-dev
07:31:38 <adimit> thanks anyway :-)
07:32:30 <Cale> adimit: Can't you just run ghci from your source directory?
07:33:36 <adimit> Cale: the dependencies are hairy. I'm trying that right now, but it's not so easy :-\
07:34:21 <adimit> specifically, mtl and transformers seem to bite each other along the way somewhere. *sigh*
07:38:36 <adimit> yay, I got it to configure. Now i'll have to wait half a year until the deps are compiled :-)
07:40:55 <ksf_> damn this beer is quaffable.
07:40:58 <ksf_> and strong.
07:41:26 <ksf_> very, very easy on the hops.
07:42:12 <ksf_> it's your basic unremarkable lager with the exception that it's darn quaffable and strong. thus, the perfect homer beer.
07:42:33 <gtmanfred> ksf_: what beer?
07:42:43 <ksf_> where "unremarkable" means "no fancy tastes, just plain beer"
07:42:44 <ksf_> duff.
07:43:26 <ksf_> 4.9 rpm. honestly, it tastes stronger.
07:43:49 <JuanDaugherty> it's the "homer" that raises questions
07:44:31 <ksf_> apparently time warner or whoever owns the simpsons merchandise can't do anything against the beer 'cos you have to use a brand to keep it.
07:44:36 <ksf_> and they're not producing beer.
07:44:58 <JuanDaugherty> k wasn't sure if simpsons or -ule
07:45:09 <gtmanfred> i like this right now http://beeradvocate.com/beer/profile/764/47507/
07:45:13 <beaky> what are some applications of haskell in industry?
07:45:23 <ksf_> http://www.duff-bier.de/
07:45:59 <djahandarie> Can anyone think of a faster "counter" data structure than IntMap Int? Interface would look like  upCount :: Counter -> Int -> Counter   and   checkCount :: Counter -> Int -> Int    where the Int parameter is the key in both cases.
07:46:41 <quicksilver> under what kind of conditions are you finding IntMap too slow, djahandarie ?
07:46:52 <ksf_> always wanted to try asgaard, but so far no shop I visited had it.
07:47:27 <Jafet> Array Int Int
07:47:39 <ksf_> http://en.wikipedia.org/wiki/Asgaard_%28brewery%29 there
07:47:46 <c_wraith> IOUArray Int Int :)
07:48:03 <djahandarie> quicksilver, just in general.
07:48:14 <t7> bitonic: are you doing anything type checky related?
07:48:25 <quicksilver> djahandarie: a mutable array might be faster for some access patterns.
07:48:36 <quicksilver> djahandarie: but an IntMap is pretty fast.
07:48:40 <djahandarie> It's mainly incrementing, not much reading
07:48:51 <bitonic> t7: what
07:49:04 <t7> compiler-y
07:49:09 <bitonic> meant to say, t7: what do you mean?  at the moment?
07:49:15 <Jafet> I don't like using IOUArrays; the code invariably has less $
07:49:21 <t7> yeah, recently
07:49:22 <nand`> beaky: http://www.haskell.org/haskellwiki/Haskell_in_industry
07:49:35 <bitonic> t7: no
07:50:03 <c_wraith> Jafet: pfft. like you need money
07:52:59 <Saizan> ksf_: btw, this is not -blah
07:53:33 <copumpkin> whoa, lots of ops right now
07:53:35 * applicative considers, 'If I had a dollar bill for all the $ I've typed...'
07:53:38 <copumpkin> it's like a pope convention
07:53:59 * applicative tries to think up a way to all ops at once
07:54:07 <applicative> a way  to INSULT them rather
07:55:31 <applicative> copumpkin: does this crushing scala look like it could be ported to haskell?  http://shootout.alioth.debian.org/u64q/program.php?test=mandelbrot&lang=scala&id=4
07:56:12 --- mode: Saizan set -o Saizan
07:56:14 <applicative> it comes in just after Fortran; why it even beats ATS!
07:57:03 <singpolyma> Hey all.  My cabal seems broken.  I even tried deleting ~/.cabal and no change.  Any time I try to install Hipmunk I get: cabal: Couldn't read cabal file "HUnit/1.2.5.0/HUnit.cabal"    -- HUnit is not even a dependency
07:57:06 <merijn> Is there a quick "My First Cabal package" tutorial somewhere that tells me how to write a cabal file?
07:57:21 <Clint> somewhere
07:57:28 <applicative> oh no singpolyma this came up on the list
07:57:31 <srhb> merijn: They're all pretty bad. You should write one.
07:57:42 <ksf_> Saizan, but I'd be not not off-offtopic, there!
07:57:45 <applicative> merijn: cabal init will walk you through
07:58:11 <copumpkin> applicative: probably! :)
07:58:16 <merijn> srhb: Oh :(
07:58:45 <merijn> Semi-related, how do I figure out a good spot in the hierarchical library namespace to pick? Or do I just make shit up?
07:58:54 <applicative> singpolyma: http://www.haskell.org/pipermail/haskell-cafe/2012-July/102416.html  byorgey comprehends it, he was explaining to someone the otoher day
07:59:17 <copumpkin> applicative:   val bytesPerRow = (size + 7) >> 3
07:59:18 <copumpkin> that >> 3 is key
07:59:23 <copumpkin> wouldn't want to divide by 8, cause that's slow
07:59:26 <copumpkin> >_>
07:59:29 <applicative> what is >>
07:59:33 <copumpkin> right bitshift
07:59:38 <byorgey> applicative: that link doesn't seem like the right one
07:59:40 <Clint> merijn: http://www.haskell.org/haskellwiki/Hierarchical_module_names
07:59:50 <Jafet> Maybe the jvm still sucks
07:59:52 <merijn> I guess Language.MyLang is a good spot for something related to my own language?
07:59:55 <applicative> byorgey: oh, sorry, good thing I woke you up....
08:01:28 <singpolyma> applicative: ah, some search and I have found that thread.  Man.  Cabal sucks :P
08:01:50 <tew88> Ah, I wasn't aware that hpaste hlinted submissions -- is this a new feature?
08:01:58 <applicative> singpolyma: byorgey is advising  a different thread I think
08:02:00 <quicksilver> new in the last year or two, yes
08:02:26 <tew88> Well that predates my time with Haskell :)
08:03:28 <c_wraith> I think it started doing that when ChrisDone rewrote hpaste...
08:03:34 <c_wraith> Which was a year or two ago now, yeah
08:03:44 <quicksilver> well he rewrote it *yonks* ago
08:03:51 <quicksilver> it took a little while to get it established on hpaste.org
08:05:01 <beaky> anyone here writing interesting Haskell projectS?
08:05:09 <copumpkin> nope, only boring ones
08:05:19 <beaky> like theorem provers?
08:05:25 <copumpkin> yeah, lots of those
08:05:26 <copumpkin> eww
08:06:29 <copumpkin> applicative: you should try translating it! it doesn't look too obscure
08:06:35 <beaky> haskell seems to be one of the more powerful programming languages out there. hopefully it becomes more popular than java someday
08:06:43 <applicative> copumpkin: i'm trying to figure it out.
08:07:16 <applicative> that it is mercifully short suggested this might be possible
08:07:21 <copumpkin> I'd just use REPA instead of explicit parallelism, in the main
08:07:31 <copumpkin> they use nested arrays
08:07:34 <copumpkin> which you could just use REPA arrays for
08:07:57 <copumpkin> but I guess REPA might not be present on that site
08:07:58 <copumpkin> probably isn't
08:07:59 <applicative> well yes, repa seems natural
08:08:04 -ChanServ(ChanServ@services.)- Saizan set flags +ARfiorstv on ski.
08:08:25 <copumpkin> nested Vector should work though
08:08:27 <applicative> copumpkin: he has the haskell platform. I was trying one with vector not long ago, I think he is willing to do cabal install
08:08:35 <copumpkin> oh, that'd be great then
08:08:37 -ChanServ(ChanServ@services.)- Saizan set flags +V on ski.
08:09:08 * barrucadu trembles before the might of ski 
08:09:25 -ChanServ(ChanServ@services.)- Saizan set flags -V on ski.
08:09:33 <applicative> copumpkin: yes I hadn't looked at it for a while, but a lot of them might at least be much handsomer if they used vector
08:09:50 <applicative> and probably no slower than they've gotten to be.
08:09:56 <copumpkin> yeah
08:10:03 <copumpkin> with standard GHC `par` annotations
08:10:10 <applicative> dons recommends that we do this somewhere among his occasional interventions from floor 324
08:12:15 <singpolyma> Wait, ok, so I gave up on using hackage and installed one package using cabal directly from a folder on my HDD, but now I try that with a second package and configure and build work fine, but install gives the same error?
08:12:51 * applicative proposes to hold up Standard Chartered Bank
08:13:04 * applicative  will demand not money but all of lennart a's code
08:15:09 <singpolyma> is there some way to pass the *.a file to ghc directly and have the import still work?
08:17:00 <merijn> Is there a convenient way to figure out which libraries I depend on in my stuff? I'm not sure which parts are in the standard library and which parts are extra libraries
08:17:26 <ksf_> singpolyma, the thing is, the package database only includes the -lfoo name.
08:18:30 <applicative> merijn: cabal init in the main directory will derive this for you
08:18:31 <Clint> singpolyma: i've had to unpack the .a and load the .o files individually
08:18:31 <byorgey> merijn: if you have a recent enough version of cabal, you can run  'cabal init' and it will create a cabal package, including automatically filling out the build-depends field
08:18:46 <hpaste> isomorphic pasted “http-conduit” at http://hpaste.org/72007
08:18:48 <Clint> singpolyma: oh, i thought you said ghci
08:19:16 <ksf_> isomorphic, runResourceT
08:19:31 <applicative> merijn: it will require the thing you are using in the versions you are using, so it might need further tuning.
08:19:45 <ksf_> ...before the inner do.
08:19:49 <applicative> things*
08:19:54 <isomorphic> ksf_: I think I know what you're saying - but following the types, I can't convince myself I need it
08:20:14 <ksf_> also, probably more liftIOs
08:20:14 <merijn> applicative, byorgey: Right now build-depends is empty and I now it should *at least* have monad-loops in there, so I guess it isn't new enough
08:20:31 <byorgey> merijn: what's the output of  cabal --version  ?
08:20:47 <ksf_> isomorphic, *you* probably don't need it, but conduits like to need it.
08:20:53 <applicative> merijn: ah yes, i hadn't remembered what byorgey says, that its a recent feature
08:21:12 <merijn> 0.10.2 (and 1.10.2 for the Cabal library)
08:21:46 * ksf_ decides he's not going to try to get at position annotations for his xml parser.
08:21:46 <byorgey> yeah, I think you need 0.14.0 for that feature
08:21:59 <merijn> Blah :p
08:22:03 <ksf_> xml-conduit has a fine interface, and it's not my bloody fault it only supports positions half-way.
08:22:11 <merijn> I guess I'll just wait until someone tries to install and it doesn't work :)
08:22:28 <byorgey> merijn: however, if you just try to build it with cabal, it will complain that it can't find a certain module and I think it says something like "it's in such-and-such package, which is hidden"
08:22:35 <byorgey> then you just add that package to the build-depends and repeat
08:22:48 <merijn> ah, nice
08:23:28 <isomorphic> ksf_: Thanks.  I think adding runResourceT may have made conduit angrier.
08:24:20 <applicative> merijn, put it on github and i'll derive the imports for you with my shiny cabal-install
08:24:25 <applicative> :)
08:24:57 <jfischoff> applicative: :O
08:25:00 <isomorphic>  ksf_:  No instance for (monad-control-0.3.1.3:Control.Monad.Trans.Control.MonadBaseControl  IO m0).  I'm building with cabal with minimal packages exposed... Is the error legit?
08:25:45 <jfischoff> applicative: you have a way to update the deps in a cabal file automatically?
08:26:32 <applicative> jfischoff: just the cabal init way.  if you have what is needed to build it, it derives this
08:26:34 <merijn> applicative: Thanks, but I'm not in a hurry so I'll fix it later :)
08:27:19 <jfischoff> applicative: So I can keep running cabal init and it will update the deps?
08:27:44 <applicative> jfischoff: well, mv the old .cabal file and see what happens
08:27:46 <singpolyma> jfischoff: I usually figure out the minimal cabal deps by runnig cabal configure and reading the errors :)
08:28:05 <applicative> singpolyma: I think this new feature basically automates that ....
08:28:28 <applicative> one couldn't help noticing the mechanical character of the old way ...
08:28:52 <jfischoff> applicative: ah. Honestly I would be fine with a little munging there
08:29:35 <applicative> jfischoff: I think cabal init might overwrite the old file?  not sure why I'm saying mv except I thought that
08:30:01 <jfischoff> applicative: that's what I assumed, I guess I'll test
08:30:04 <singpolyma> ok, seriously, the fact that I can't even run cabal install locally on some packages is nuts :P
08:30:05 <ksf_> isomorphic, I've never had that error. you must be missing some instance, the docs even mention that instance somewhere.
08:31:13 <isomorphic> ksf_: Interesting.  I've got another small example with httpLbs to work - but interestingly it breaks with the same error if I replace that by (lbsResponse . http)
08:31:17 <applicative> jfischoff: no, its better behaved, it makes a new one with the version number foo.0.3.cabal
08:31:46 <jfischoff> ah
08:32:25 <astory> I have a datatype that I want to define a pretty print instance for, but don't want to do it in the same file as I define the datatype for code layout reasons.  Is it possible to define the pretty instance in a separate file?
08:34:00 <jfischoff> astory: its always possible, just not advisable, unless the class definition is in the aforementioned separate file.
08:34:02 <wowser> howdy
08:34:10 <jfischoff> underlines?
08:34:39 <astory> I guess I'm asking if this is going to cause Terrible Bad Things to happen
08:35:12 <geekosaur> astory: http://www.haskell.org/haskellwiki/Orphan_instance
08:35:28 <geekosaur> it can cause bad things to happen
08:35:40 <singpolyma> it can, but if the two files live in the same package, it seems pretty safe
08:36:04 * hackagebot netlink 0.1 - Netlink communication for Haskell (MaximTreskin)
08:36:14 <applicative_> astory: you didn't say anything about a class?  you just a pretty function?
08:36:24 <applicative_> you just want a pretty function
08:36:28 <applicative_> rather
08:36:35 <astory> applicative_: eh, I was going to make it an instance of pretty
08:36:43 <astory> although I could certainly just do a pretty function
08:37:34 <astory> this type already supports so many classes that I don't really want to add more, and that's why I want it in a separate file, so just a pretty function is probably the best way to do it actually.
08:38:19 <singpolyma> I just had the idea of manually editing my local hackage metadata.  Maybe it'll work
08:39:27 <applicative_> I don't see what they are worried about, especially if the natural use of the package is through a module that exports the type declaring module and the instance declaring module
08:41:06 <hpaste> isomorphic pasted “Change creates errors” at http://hpaste.org/72008
08:41:07 <applicative_> module Data.Astory (module Data.Astory.Core,module Data.Astory.Pretty) where ...; module Data.Astory.Core (as you wrote it)  ... module Data.Astory.Pretty where instance Pretty Astory....
08:42:11 <isomorphic> I've added the two cases to a hpaste - the errors at the foot happen when using (lbsResponse . http) - but this is actually the definition of httpLbs, which works without error :/
08:42:24 <isomorphic> Can anybody shed light on why?
08:44:30 <singpolyma> ok, just changing the tarball in ~/.cabal/packages makes it so it cannot find any packages anymore.  that's suboptimal
08:46:58 <isomorphic> Oh, so... lbsResponse . http request == lbsResponse . (http request) not (lbsResponse . http) request
08:48:45 <Cale> isomorphic: yes
08:48:57 <Cale> Function application binds more tightly than any infix operator
08:49:12 <isomorphic> :) Thanks Cale, very much appreciated
08:49:23 <singpolyma> hmm.   cabal copy && cabal register    seems like maybe it will work for me
08:51:40 <isomorphic> Did this make it into the channel already? http://fay-lang.org/ ?
08:52:04 --- mode: ski set -o ski
08:54:24 <plat0> Everyone's loving Fay today.  I think it's a great idea.
08:56:04 <singpolyma> ok, I got what I needed working with cabal copy && cabal register for now.   Hopefully hackage gets fixed sometime soon, but at least I can get work done again :)
08:57:30 <spirity> does anyone know of a library for parsing urlencoded HTTP response  bodies?
08:59:11 <Clint> spirity: why would the body be urlencoded?
08:59:22 <mauke> because form submission
08:59:33 <mauke> ... wait, response?
08:59:37 <spirity> it's actually a response from a http-based API.
09:00:29 <spirity> eh I suppose I can just parse it myself. should be simple enough
09:01:12 <Clint> you could use urlDecode in Network.HTTP.Base i suppose
09:07:31 <ski> merijn : did you manage to write the `Read' instance ?
09:18:33 <srhb> What exactly does it mean when a binary operator is strict in its right-hand argument?
09:19:33 <spirity> it means that a <> _|_ = _|_
09:19:45 <byorgey> srhb: it means that if _|_ (aka bottom, aka undefined, aka infinite loop) is passed as the right-hand argument to the operator, the result of the operator is also _|_
09:19:57 <byorgey> srhb: for example, + is strict in its right-hand argument:
09:20:00 <byorgey> > 3 + undefined
09:20:00 <lambdabot>   *Exception: Prelude.undefined
09:20:14 <spirity> && is conditionally strict in its right-hand argument.
09:20:15 <byorgey> srhb: however, && is not:
09:20:20 <srhb> byorgey: But isn't that more the effect of it being strict than the definition?
09:20:22 <byorgey> > False && undefined
09:20:24 <lambdabot>   False
09:20:29 <byorgey> srhb: no, that is the definition.
09:20:33 <srhb> Oh, okay.
09:20:46 <byorgey> srhb: the definition of a strict function is a function for which  f _|_ = _|_ .
09:21:06 <srhb> Okay. :) Lazy is more ill-defined then?
09:21:08 <srhb> Or at least, non-strict
09:21:16 <sclv> nope
09:21:17 <srhb> "where it isn't necessarily true that..."
09:21:31 <byorgey> srhb: non-strict is well-defined, it means "not strict" =)
09:21:56 <byorgey> oh, right, I guess it means "not *necessarily* strict"
09:22:03 <srhb> But lazy does not mean that f _|_ /= undefined
09:22:11 <srhb> erh, a mixing of terminology there
09:22:16 <mauke> f _ _ = undefined  -- f is strict in all arguments
09:22:17 <spirity> there exists an a such that f a /= _|_
09:22:23 <spirity> er
09:22:25 <sclv> yes
09:22:25 <spirity> no
09:22:35 <spirity> lots of functions do that.
09:23:17 <spirity> it's more applicable to binary operations
09:23:18 <sclv> f _|_ /= _|_ is nonstrict
09:23:25 <srhb> sclv: Right.
09:23:44 <sclv> we speak of functions of arity greater than 1 of being strict in some arguments and not in others
09:24:07 <srhb> But f a _|_ /= for some an (but not necessarily all) is non-strict
09:24:11 <srhb> on its second argument
09:24:21 <srhb> for some a*
09:24:24 <spirity> right
09:24:30 <srhb> Thanks.
09:24:35 <avpx> I guess cons would be strict in its first argument but not its second?
09:24:36 <mroman> How does minBound work?
09:24:41 <mroman> @src minBound
09:24:41 <lambdabot> Source not found.
09:24:47 <sclv> nope, cons is strict in neither argument.
09:24:52 <mroman> > minBound (0 :: Char)
09:24:52 <avpx> Hmm.
09:24:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
09:24:53 <lambdabot>    arising from the literal `0...
09:25:02 <mroman> > minBound ('c' :: Char)
09:25:03 <lambdabot>   No instance for (GHC.Enum.Bounded (GHC.Types.Char -> a))
09:25:03 <lambdabot>    arising from a ...
09:25:32 <spirity> huh, persistent apparently has no PersistField instance for Char.
09:25:39 <sclv> > (\x -> case x of (a : b) -> True) $ (undefined : undefined)
09:25:40 <lambdabot>   True
09:26:37 <mroman> oh
09:26:40 <avpx> > (\x -> case x of n -> True) $ (1 + undefined)
09:26:41 <mroman> > minBound :: Char
09:26:41 <lambdabot>   True
09:26:43 <lambdabot>   '\NUL'
09:26:46 <mroman> sneaky.
09:26:50 <mroman> > minBound :: Int
09:26:51 <lambdabot>   -9223372036854775808
09:27:25 <spirity> mroman: usually minBound's is inferred so that it will "just work" in a larger expression.
09:27:34 <spirity> *minBound's type
09:28:05 <spirity> > minBound : "hello"
09:28:07 <lambdabot>   "\NULhello"
09:28:13 <mroman> I got it now, yes.
09:28:25 <mauke> > [minBound .. maxBound]
09:28:26 <lambdabot>   [()]
09:28:27 <mroman> The error message No instance ... (a -> b) just confused me totally.
09:28:50 <sclv> > (\x -> seq x True) $ ((1 :: Int) + undefined)
09:28:51 <lambdabot>   *Exception: Prelude.undefined
09:28:57 <sclv> > (\x -> seq x True) $ (undefined : undefined)
09:28:58 <lambdabot>   True
09:29:07 <avpx> sclv: Ah, I see now.
09:29:25 <spirity> mroman: you actually could write an instance (Bounded b) => Bounded (a -> b)
09:29:29 <spirity> mroman: any idea what it would look like?
09:29:44 <srhb> sclv: Huh, I don't understand how that second example could be True
09:30:06 <avpx> It's because (:) isn't strict in either argument, apparently. Though I expect it to be
09:30:09 <nand`> srhb: seq only forces the (:)
09:30:36 <avpx> But I guess that since (:) is a constructor evaluating a:b to WHNF doesn't force a or b
09:30:42 <byorgey> avpx: correct.
09:30:48 <srhb> What is whnf of a:b?
09:30:52 <mauke> srhb: a:b
09:30:54 <avpx> srhb: It's just a:b
09:30:55 <srhb> Right.
09:31:08 <srhb> So that's the whole trick really. :-)
09:31:13 <sclv> the infix makes it look more confusing
09:31:13 <avpx> Yeah. Makes sense now.
09:31:19 <sclv> think of it as: (:) a b
09:31:24 <srhb> Yeah
09:31:32 <srhb> Or as seeing the [
09:31:36 <srhb> Though that's probably misleading
09:33:06 --- mode: ChanServ set -q woowoowoo!*@*
09:35:48 <mroman> spirity: No.
09:35:57 <mroman> If you *could* use type variables then
09:36:08 <mroman> instance Bounded b => (a -> b) where minBound = minBound :: b
09:36:09 <spirity> what do you mean?
09:36:15 <mroman> but that's not possible without extensions.
09:36:41 <mauke> mroman: that looks like a type error
09:36:43 <spirity> mroman: you want to return a function whose result is an instance of bounded
09:36:49 <ski> itym s/minBound =/minBound _ =/
09:37:28 <spirity> mroman: for an input of any type.
09:37:40 <spirity> there's only a few things that can really do that in a well-defined manner.
09:38:45 <mroman> *** Exception: compiler/rename/RnSource.lhs:429:14-81: Irrefutable pattern failed for pattern Data.Maybe.Just (inst_tyvars,
09:38:52 <mroman> something is broken with ghci
09:40:00 <spirity> mroman: instance Bounded b => bounded (a -> b) where { minBound = const minBound; maxBound = const maxBound }  doesn't require any extensions
09:42:42 <mroman> but ghc can't compile
09:42:49 <mroman> instance Bounded b => (a -> b) where minBound = const . minBound maxBound = const . maxBound
09:43:07 <spirity> that's because const . minBound doesn't type correctly
09:43:15 <mroman> no.
09:43:25 <mroman> It's because it doesn't even get to the typechecker
09:43:33 <mauke> why did you put a . there?
09:43:37 <c_wraith> you don't have a class name
09:43:41 <c_wraith> it's a syntax error
09:43:57 <mroman> No.
09:44:01 <mroman> It's not a syntax error.
09:44:06 <spirity> it is.
09:44:11 <c_wraith> what you pasted is certainly a syntax error
09:44:17 <spirity> instance Bounded b => Bounded (a -> b) where ...
09:44:20 <c_wraith> I can't guarantee what you pasted is actually your code, though
09:44:45 <mroman> parse error (possibly incorrect indentation)
09:44:49 <mroman> ^- that is a syntax error.
09:44:52 <mroman> or parse error
09:45:00 <c_wraith> you can keep ignoring me
09:45:02 <mroman> *** Exception: compiler/rename/RnSource.lhs:429:14-81: Irrefutable pattern failed for pattern Data.Maybe.Just (inst_tyvars,
09:45:03 <c_wraith> or you can fix the problem
09:45:15 <mroman> ^- that is ghc crashing trying to compile the code.
09:45:23 <mauke> mroman: paste your code
09:45:54 <c_wraith> mroman: so maybe you found a case where ghc's parser doesn't handle the parse error you're throwing at it.
09:45:55 <hpaste> mroman pasted “*** Exception: compiler/rename/RnSource.lhs:429:14-81: Irrefutable pattern failed” at http://hpaste.org/72013
09:46:14 <c_wraith> but that code *definitely* has a syntax error in it
09:46:26 <c_wraith> So, you can report the syntax error to ghc trac
09:46:26 <mroman> c_wraith: It has.
09:46:34 <mauke> try.hs:1:23: Malformed instance header: a -> b
09:46:55 <mauke> ghc 7.0.4
09:47:03 <noteventime> Any reason why there isn't an "alterLookup" in Data.Map?
09:47:05 <mroman> but ghc 7.4.1 doesn't say that it is a syntax error.
09:47:17 <avpx> *sigh*
09:47:22 <spirity> noteventime: what is alterLookup?
09:47:48 <avpx> mroman: Are you actually reading what c_wraith is saying?
09:47:49 <c_wraith> mroman: then submit a trac ticket telling them to fix the parser so it doesn't crash on that malformed input, and move on. (nothing in the language spec says the compiler isn't allowed to crash on bad input)
09:48:09 <avpx> It's a syntax error. if ghc isn't handling it right, submit it to the trac
09:48:51 <noteventime> spirity: update changes a value in a Map, alter adds the ability to add a value if its missing. Now, there's an updateLookup which also returns the updated value, but no alterLookup analogue for alter. :)
09:49:32 <mroman> avpx: I said ghc can't compile it.
09:49:41 <mroman> And everybody stated a reason for it
09:49:51 <dmwit> mroman: So, yes, submit a bug to trac, then fix your code.
09:49:55 <mroman> none of them the actual reason for ghc NOT compiling it.
09:49:59 <dmwit> Add the word "Bounded" after "=>"
09:50:18 <c_wraith> mroman: the fact that there's a syntax error is certainly why GHC doesn't compile it.
09:50:31 <mauke> <c_wraith> you don't have a class name
09:50:34 <mroman> Probably. But not from my perspective.
09:50:40 <mroman> And I know that a class name is missing.
09:50:48 <mauke> so what are you complaining about?
09:50:49 <c_wraith> mroman: the fact that it crashes due to the syntax error is unfortunate, but irrelevant as to the reason it's not compiling
09:50:55 <dmwit> I am so confused.
09:51:23 <dmwit> If you know there's an error, and you know GHC is broken, and you know how to fix your error, then what has got you so hot and bothered?
09:51:56 <hatds> the 2nd bit it sounds like+
09:52:06 <spirity> noteventime: hm. guess not.
09:52:36 <dmwit> The second bit is nothing to get hot and bothered by. Just submit a bug to Trac and it'll be fixed in the morning.
09:52:37 <noteventime> spirity: It's not a huge deal, I was mostly curious if I was missing some obvious reason for it not being useful
09:53:15 <hatds> :t \f -> fmap (.f)
09:53:16 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f a -> f1 (a -> b) -> f1 (f b)
09:53:27 <avpx> Is there documentation out there on lambdabot?
09:53:44 <avpx> I'm curious what kinds of input it can take
09:54:16 <spirity> noteventime: I don't see anything else that directly implements its behavior.
09:54:21 <mcstar> how about insertWith?
09:54:36 <spirity> that doesn't return the looked up value.
09:54:43 <spirity> insertLookupWithKey is similar
09:54:51 <spirity> but it doesn't handle the case where the value wasn't there to begin with
09:55:03 <spirity> like alterLookup would
09:56:22 <noteventime> I'll just have to do two traversals
09:57:05 <c_wraith> does updateLookupWithKey not work?
09:57:26 <noteventime> c_wraith: No, because I might have to insert a key that doesn't exist
09:57:28 <c_wraith> ah, I see, it doesn't
09:57:30 <spirity> presumably he wants to handle the case where the key doesn't already exist.
09:57:45 <spirity> noteventime: if you'd like to mak it a bit more efficient you could use the indexing functions at the bottom.
09:58:00 <spirity> which will make subsequent updates/lookups a bit quicker.
09:58:24 <noteventime> spirity: Good idea
09:58:24 <spirity> but I doubt it's really needed.
09:58:38 <spirity> donald knuth etc
09:59:02 <ski> @let showsPrecFunOn :: [a] -> (Int -> a -> ShowS) -> (Int -> b -> ShowS) -> (Int -> (a -> b) -> ShowS); showsPrecFunOn domainA showsPrecA showsPrecB p f = showParen (p > 0) $ showString "\\a -> case a of {" . (foldr (.) id . intersperse (showString "; ")) [showsPrecA 0 a . showString " -> " . showsPrecB 0 (f a) | a <- domainA] . showString "}"
09:59:04 <lambdabot>  Defined.
09:59:29 <dmwit> noteventime: If you want to make it efficient, the way to do it is to submit a patch to the library. =)
09:59:30 <ski> @let showsPrecFun :: (Bounded a,Enum a) (Int -> a -> ShowS) -> (Int -> b -> ShowS) -> (Int -> (a -> b) -> ShowS); showsPrecFun = showsPrecFunOn [minBound .. maxBound]
09:59:31 <lambdabot>  <local>:3:17:
09:59:31 <lambdabot>      Class `Bounded' used as a type
09:59:31 <lambdabot>      In the type signature...
09:59:37 <ski> @let showsPrecFun :: (Bounded a,Enum a) => (Int -> a -> ShowS) -> (Int -> b -> ShowS) -> (Int -> (a -> b) -> ShowS); showsPrecFun = showsPrecFunOn [minBound .. maxBound]
09:59:39 <lambdabot>  Defined.
09:59:57 <ski> > (showsPrec `showsPrecFun` showsPrec) 0 not ""
09:59:59 <noteventime> dmwit: Would something like that be accepted?
09:59:59 <lambdabot>   "\\a -> case a of {False -> True; True -> False}"
10:00:10 <ski> > (showsPrec `showsPrecFun` (showsPrec `showsPrecFun` showsPrec)) 0 (&&) ""
10:00:13 <lambdabot>   "\\a -> case a of {False -> \\a -> case a of {False -> False; True -> False...
10:00:25 <spirity> dmwit: absolutely not! you need to be a Ph.D and attend many functional programming conferences and give at least one talk or write one paper.
10:00:33 <spirity> noteventime: ^
10:00:51 <dmwit> noteventime: I'd give it pretty high probability, spirity's complaints notwithstanding. =D
10:01:05 <noteventime> And I guess a paper on this particular function might be somewhat boring :)
10:01:35 <noteventime> Although it should capture most other operations you can do
10:01:51 <ski> mroman : would you like '[minBound,maxbound] :: [Bool -> Bool]' to be `[\_ -> False,\_ -> True]', or `[id,not]' or what ?
10:02:19 <hatds> :t showsPrecFun
10:02:21 <lambdabot> forall a b. (Bounded a, Enum a) => (Int -> a -> ShowS) -> (Int -> b -> ShowS) -> Int -> (a -> b) -> String -> String
10:02:30 <mroman> ski: You're addressing the wrong guy I guess.
10:02:48 <mroman> Or at least I don't know what you're referring to right now.
10:02:54 <hatds> :i showsPrecFun
10:03:16 <mcstar> i dont understand why insertLookupWithKey is the solution
10:03:21 <mcstar> is not*
10:03:31 <spirity> because nothing happens when the key isn't defined
10:03:49 <spirity> alter gives a Maybe a input to the argument function
10:03:52 <spirity> as opposed to an a
10:03:54 <ski> mroman : i thought you were the one who were pondering `Bounded (a -> b)' ?
10:04:21 <c_wraith> spirity: actually, that's not true.  if the key isn't found, it just inserts the key and value.
10:04:22 <ski> > (showsPrec `showsPrecFun` (showsPrec `showsPrecFun` showsPrec)) 0 (\() () -> ()) ""
10:04:25 <lambdabot>   "\\a -> case a of {() -> \\a -> case a of {() -> ()}}"
10:04:30 <c_wraith> spirity: I think insertLookupWithKey is exactly what you want
10:05:01 <spirity> oh right. well then it doesn't allow you to update the key based on the previous value.
10:05:18 <spirity> I think?
10:05:22 <c_wraith> it does
10:05:27 <spirity> oh I see.
10:05:34 <spirity> noteventime: ^^^^^^
10:05:52 <mroman> ski: Spirity asked me if I could figure out how to implement Bounded (a -> b)
10:06:04 <noteventime> Seriously, I generated a long password and github complains about it not containing any numbers
10:06:04 <mroman> but besides that I have no particular interest in Bounded (a -> b), no.
10:06:07 <ski> mroman : oh, ok. sorry then
10:06:08 <mcstar> M.insertLookupWithKey (\key new old -> new) 'a' 1 M.empty
10:06:12 <mcstar> (Nothing,fromList [('a',1)])
10:06:23 <mroman> That's why I was so confused about your previous question.
10:06:41 <mroman> I have no idea what a practical use for Bounded (a -> b) would be.
10:06:50 <spirity> ski: I specifically asked what the instance for Bounded b => Bounded (a -> b)  would be.
10:06:53 <spirity> ski: so the former.
10:06:56 <mcstar> so i think insertLookupWithKey is what he wants
10:07:02 <mcstar> ofc he has to figure out the function..
10:07:05 <ski> spirity : so i suppose my question then is : what would be reasonable semantics for `minBound' and `maxBound' for `a -> b' ?
10:07:39 <spirity> ski: uh.... maxBound = id; minBound = undefined
10:07:43 <spirity> I can't think of anything else.
10:07:51 <spirity> const undefined
10:07:54 <noteventime> mcstar: I want the inserted value, not the one that was there before
10:08:04 <spirity> ski: oh nevermind
10:08:04 <ski> let's assume we're talking about some kind of partial orders, then i suppose it would make sense that `minBound' was the least (totally defined) element, and `maxBound' the greatest one
10:08:05 <spirity> const
10:08:08 <spirity> for maxBound
10:08:20 <spirity> ski: right. that's what I was thinking as well
10:09:02 <ski> and if we know `Bounded b', then we can define `Bounded (a -> b)' for any `a' as above -- but would then `minBound' resp. `maxBound' be the least resp. greatest elements ?
10:09:20 <spirity> ski: maxBound = const undefined; minBound = undefined   perhaps?
10:09:33 <ski> the real question here is : what partial order do we want for 'a -> b' here ? (is there any appropriate one ?)
10:10:02 <spirity> that's the only one that would really make any sense to me.
10:10:04 <ski> spirity : no, i'm assuming `minBound _ = minBound; maxBound _ = maxBound', for the moment
10:10:26 <ski> i think it makes sense for `minBound' to not be `_|_'
10:10:32 <spirity> oh. what? I thought we were talking about Bounded (a -> b)
10:10:41 <ski> yes, we are
10:10:55 <spirity> ...what other functions have that type?
10:11:08 <ski> (note that `minBound _ = minBound' is the same as `minBound = const minBound')
10:11:15 <spirity> of course.
10:12:03 <spirity> unsafeCoerce, undefined, and const undefined are the only values I can think of that satisfy the type a -> b
10:12:09 <ski> well, the two total alternatives are `\_ -> minBound' and `\_ -> maxBound' (assuming `Bounded b' is total)
10:12:20 <ski> and you also suggested `undefined' (which is not total)
10:12:34 <spirity> I feel like you're leaving out the instance head in this discussion
10:12:35 <ski> spirity : we're assuming `Bounded b', here
10:12:39 <spirity> oh.
10:12:41 <spirity> then yes.
10:12:50 <ski> (sorry if that wasn't clear)
10:13:03 <mcstar> noteventime: you know the inserted value
10:13:11 <spirity> ski: that's actually what I asked mroman. I knew the answer before I suggested it to him. :P
10:13:42 <ski> but my question is still : wrt which partial order does this definition of `forall a b. Bounded b => Bounded (a -> b)' give the least and greatest elements ?
10:14:22 <spirity> the one defined by b? what other partial orders are there? :P
10:14:39 <ski> yes, but here we need a partial order on `a -> b'
10:14:47 <spirity> oh
10:15:09 <spirity> [.., -1, 0, 1, ...] -> [..., const -1, const 0, const 1, ...]
10:15:10 <ski> let's assume we define `f =< g  <=>  forall x. f x =< g x', e.g.
10:15:43 <ski> i'm wondering whether `\_ -> minBound' and `\_ -> maxBound' really are the least and greatest elements wrt this partial order
10:15:51 <ski> (possibly they are, i'm just not seeing it yet)
10:16:06 <spirity> ski: as opposed to?
10:16:06 <noteventime> mcstar: If you mean by applying the update to the returned old value, wouldn't this risk computing the value twice?
10:16:28 <ski> spirity : as opposed to them not being least and greatest elements
10:16:54 <spirity> ski: I meant, what could a counterexample be?
10:16:59 <ski> i don't know
10:17:06 <spirity> you would bee
10:17:09 <spirity> *need
10:17:18 <spirity> (Bounded a, Bounded b) => Bounded (a -> b)
10:17:31 <spirity> then you could define a partial ordering via (input, output) pairs.
10:17:42 <dmwit> ski: Yes, this is a minimal element by this ordering.
10:17:51 <dmwit> want to prove: minBound <= g
10:18:03 <dmwit> therefore, must prove: forall x. minBound x <= g x
10:18:07 <ski> hm .. let's assume `f =< g' and `g =< f', so `forall x. f x =< g x' and `forall x. g x =< f x', so `forall x. f x = g x' (assuming anti-symmetry on `b'), so `f = g' (assuming extensionality) -- so it appears that it really is a partial order, and not just a preorder
10:18:10 <dmwit> but: minBound x = minBound
10:18:21 <dmwit> therefore, must prove: forall x. minBound <= g x
10:18:27 <mcstar> noteventime: you have a new value, you try to update the map, if the key was present or not, the new value will be placed in the map, if the fst of the returned tupe is Nothing, the key wasnt present, if it is Just x, x was the old value
10:18:29 <dmwit> This is true by the property of minBound. Done.
10:18:39 <ski> dmwit : right, ok
10:18:39 <mcstar> noteventime: now, what does this not provide, that you want?
10:19:39 <spirity> mcstar: that was kind of a weirdly worded explanation.
10:19:42 <noteventime> mcstar: If the Map already contains the key I'm applying a function to the value, not replacing it with some predefined one
10:19:50 <spirity> :t insertLookupWithKey
10:19:51 <ski> spirity : yes, i was pondering contrasting the above with the alternate definition `f =< g  <=>  forall x0 x1. x0 =< x1 => f x0 =< f x1'
10:19:51 <lambdabot> Not in scope: `insertLookupWithKey'
10:19:58 <spirity> insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
10:20:07 <spirity> noteventime: if the value exists then the update function is applied
10:20:15 <mcstar> noteventime: ok, then you write your insert function to return the old one, thereby, not updating the key
10:20:17 <ski> s/f x1/g x1/
10:20:20 <spirity> if it doesn't, the insert value is added.  (that's the third argument there)
10:20:30 <mcstar> noteventime: you can still decide on the fst of the returned tuple
10:20:53 <ski> wrt this ordering, which are the least and greatest (total) elements of `Bool -> Bool', e.g. ?
10:20:54 <spirity> ski: right but there's not enough information to define that particular ordering without a Bounded instance on the input type.
10:21:06 <ski> spirity : yes, so let's assume that as well
10:21:48 <spirity> ski: so basically we're asking if const is monotonic? is that the right word in this case?
10:22:15 <noteventime> mcstar: This is probably me being really stupid, but I don't get it. I need something of the type (Maybe a -> a) -> k -> a -> Map k a -> (a, Map k a) where the first component of the result is either the third argument (if the key is not in the Map) or the first argument applied to the current value in the Map.
10:22:21 <spirity> actually that doesn't make any sense.
10:22:34 <ski> spirity : note that i corrected my alternate definition to `f =< g  <=>  forall x0 x1. x0 =< x1 => f x0 =< g x1'
10:22:53 <ski> `f' being monotonic means `forall x0 x1. x0 =< x1 => f x0 =< f x1'
10:23:14 <spirity> right
10:23:27 <noteventime> mcstar: Err, I borked it there not Maybe a but a (confused it with the build-in ones)
10:23:58 <ski> so if `f' is monotonic, then `f =< f'
10:23:58 <spirity> ski: I don't think that one is true.
10:24:04 <ski> spirity : which one ?
10:24:15 <spirity> ski: f =< g  <=>  forall x0 x1. x0 =< x1 => f x0 =< g x1
10:24:32 <ski> that's an alternate definition of the partial order on `a -> b'
10:24:52 <spirity> when x0 = minBound   x1 = maxBound  that's always false
10:25:30 <ski> surely not if `b' is `()' ?
10:25:37 <spirity> oh, right.
10:25:42 <spirity> in that case, it's true.
10:25:51 <astory> is there a more natural way to print a new line other than putStrLn "" ?
10:26:08 <ski> astory : maybe `putChar "\n"' ?
10:26:13 <geekosaur> putChar '\n' ?
10:26:20 <spirity> astory: print can sometimes be more natural. It just depends on what you want to print.
10:26:23 <ski> (er, passing char, yes)
10:26:41 <astory> which would you prefer for readability?  This isn't a huge issue, but neither feels right to me
10:26:45 <ski> @src putStrLn
10:26:46 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
10:27:18 <spirity> astory: I think putStrLn would be preferable in most circumstances.
10:27:32 <otters> aw man, you can't make your own types instances of PrintfArg
10:27:41 <mroman> Has haddock a flag to also document not exported functions?
10:28:12 <ski> spirity : in the case of `a' and `b' being `Bool', then if `f = \_ -> False' and `g = \_ -> True', it seems to me that `f =< g' holds according to this definition
10:28:22 <astory> mroman: it does, let me see if I can get it from my bash history
10:28:38 <Taneb> How does that work, mroman and astory
10:29:07 <spirity> ski: I think you need to remove the x0 => x1   condition
10:29:23 <astory> mroman: I can't find it :/
10:29:25 <spirity> because you're asking if that's true for all elements.
10:29:37 <noteventime> mcstar: If I do insertLookupWithKey and the Map already contains the key I won't have access to the new value at that key, or am I wrong?
10:29:44 <astory> Taneb: you can auto-generate hackage-like docs for your code if you format the comments right
10:30:00 <Taneb> No, I mean docs for non-exports
10:30:15 <Taneb> (I have used Haddock before)
10:30:32 <astory> oh, there's some flag you set that I can't remember
10:30:43 <Taneb> I mean what does it look like?
10:30:50 <astory> IIRC it looks the same
10:31:01 <Taneb> That'd be misleading, wouldn't it?
10:31:02 <ski> spirity : need to do it for what ?
10:31:18 <mcstar> noteventime: first of all, you KNOW the new value that you are trying to insert, second, you can set up your insert your new value, your old value, or transformation of them, third, you get back Nothin gor Just oldvalue, which indicates whether the key was present or not
10:31:37 <astory> mroman: haddock --internal ?
10:31:58 <mcstar> set up your insert function to insert*
10:32:03 <ski> spirity : note that `forall x0 x1. x0 =< x1 => f x0 =< g x1' parses as `forall x0 x1. (x0 =< x1 => f x0 =< g x1)', so i'm asking whether for all `x0' and `x1' which are ordered wrt the `a' ordering, it also is the case that `f x0' and `g x1' is ordered wrt the `b' ordering
10:32:05 <mcstar> sorry, fraudian compression
10:32:39 <noteventime> mcstar: How do I know the new value if its a function of the old value? (Without risking to recompute it bya applying the function to the returned old value)?
10:32:50 <spirity> ski: right I parsed that correctly. I may be misparsing the meaning of the inequalities.
10:34:01 <spirity> ski: so in x =< y => z does that mean x and z are not ordered wrt each other?
10:34:13 <ski> spirity : `=>' is implication
10:34:21 <spirity> ...oh
10:34:22 <spirity> right
10:34:30 <spirity> okay, yes.
10:34:43 <spirity> I thought it was a weird chain of inequalities. wasn't really making any sense.
10:36:42 <mcstar> noteventime: so you would like to update an old value in the map, to a new one, which is a function of the old one, and if the key is not present, you want to insert some default?(and get back the newly inserted value, with the map)
10:37:01 <noteventime> mcstar: Yes
10:37:51 <ski> spirity : fyi, i'm atm just comparing these (ostensibly) different orders on `a -> b' ..
10:38:09 <mcstar> noteventime: hold on for a second
10:38:12 <mroman> ace2001ac: Something like that yes.
10:38:15 <spirity> ski: x0 = minBound, x1 = maxBound.   f = const maxBound   g = const minBound
10:38:16 <mroman> eh sorry.
10:38:18 <mroman> wrong nick.
10:38:31 <spirity> ski: wouldn't this make the implication false?
10:38:32 <mroman> astory: If there were a --internal
10:38:50 <astory> mroman: cabal haddock --internal worked for me
10:38:58 <ski> i suppose we can already say that with this latter definition on `a -> b', we're already only considering monotone functions (otherwise reflexivity fails)
10:39:28 <ski> spirity : yes, and so `f =< g' does not hold in that case
10:39:35 <spirity> ski: so it's not a ordering over the entire set (Bounded a, Bounded b) => a -> b
10:39:39 <ski> (i never claimed `forall f g. f =< g')
10:40:04 <ski> spirity : why ?
10:40:22 <spirity> because that includes the non-monotone ones.
10:40:46 <spirity> er, nevermind.
10:40:49 <spirity> I see.
10:40:56 <ski> ok, yes, i mentioned we need to exclude non-monotone ones due to wanting reflexivity
10:41:17 <ski> spirity : i was hoping you were seeing another counter-example :)
10:41:45 <noteventime> ski: I haven't followed the discussion properly, but aren't you just taking the product order?
10:42:01 <spirity> ski: are we considering functions like "const maxBound" to be a set of monomorphic functions?
10:42:27 <spirity> that's a subset of the Bounded a -> Bounded b  set
10:42:29 <ski> noteventime : is `forall f g.  f =< g  <=>  forall x0 x1. x0 =< x1 => f x0 =< g x1' defining the "product order" ?
10:43:05 <spirity> I'm pretty sure there are multiple ways to define partial orderings over products.
10:43:08 <noteventime> ski: Hmm, good question
10:43:12 <ski> spirity : `const maxBound', which is `\_ -> maxBound' is a single function (and it's monotonic)
10:43:21 <noteventime> I see the problem now
10:43:47 <ski> noteventime : heh, i suppose i was really asking you "what is the product order ?" :)
10:44:17 <mroman> --internal does --ignore-all-exports
10:44:26 <noteventime> ski: Just the order you get when you compare point-wise (i.e. f < g iff forall x. fx < gx)
10:44:41 <spirity> ski: right. my earlier counterexample would only apply for the set of all the monomorphic functions. as opposed to the set of all the polymorphic constant functions. I don't really see a counterexample there.
10:45:07 <ski> noteventime : ok, well that's the ordering we were considering first. then i wondered how this second one compared to the first one, in case we assume a partial order on the domain as well
10:45:42 <noteventime> ski: I wonder if it might not just be the restriction of the product order to monotonic functions
10:45:55 <noteventime> I'll have to get some pen and paper though
10:46:21 <ski> spirity : i'm not sure where monomorphic functions come into this ? (do you mean monomorphic as in monomorphic vs. polymorphic ? or monomorphic as in a monomorphism ? or do you really mean monotonic ?)
10:46:34 <spirity> I mean vs. polymorphic.
10:47:00 <ski> ok, so then i don't see where polymorphism (or lack of it) really enters the picture (except trivially)
10:47:33 <ski> noteventime : it sounds possible, but i'm not seeing it
10:49:15 <spirity> ski: I guess it doesn't really.
10:49:25 <spirity> I was still thinking that forall f g.  needed to be true.
10:49:57 <spirity> I don't really know what to do with these unqualified f's and g's
10:50:13 <spirity> my intro to adv. math class has not prepared me for such evils.
10:50:30 <spirity> *quantified even
10:50:45 <hpaste> mcstar pasted “noteventime” at http://hpaste.org/72019
10:50:55 <ski> spirity : well, for each `f' and `g', we're defining `f =< g' to be exactly as true as `forall x0 x1. x0 =< x1 => f x0 =< g x1'
10:51:04 <DMcGill> is there an iff :: a -> a -> Bool -> a?
10:51:21 <spirity> dcolish: (==)
10:51:26 <spirity> DMcGill: ^
10:51:34 <DMcGill> I find myself wanting some kind of mIff :: m a -> m a -> m Bool -> m a
10:51:38 <spirity> @hoogle cond
10:51:38 <lambdabot> Language.Haskell.TH.Syntax CondE :: Exp -> Exp -> Exp -> Exp
10:51:38 <lambdabot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
10:51:38 <lambdabot> Language.Haskell.TH.Lib condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
10:51:43 <spirity> @hackage cond
10:51:43 <lambdabot> http://hackage.haskell.org/package/cond
10:51:48 <noteventime> mcstar: Sure, but what won't that traverse the Map twice?
10:51:52 <spirity> DMcGill: ^^^^^^^
10:51:59 <spirity> actually I don't think I define that particular function
10:52:07 <DMcGill> liftM3 cond will do it
10:52:11 <ski> @pl iff consequent alternate condition = if condition then consequent else alternate
10:52:11 <lambdabot> iff = flip . flip if'
10:52:21 <mcstar> noteventime: if the key is not present?
10:52:29 <DMcGill> @hoogle if'
10:52:30 <lambdabot> No results found
10:52:38 <DMcGill> @src if'
10:52:39 <lambdabot> Source not found. That's something I cannot allow to happen.
10:52:39 <noteventime> mcstar: Yes
10:52:42 <ski> @pl iff condition consequent alternate = if condition then consequent else alternate
10:52:42 <lambdabot> iff = if'
10:53:10 <DMcGill> I guess I'll just define it myself or not bother then, it doesn't come up that much
10:53:11 <DMcGill> thanks
10:53:21 <mcstar> ofc, the insert is separate from the search
10:53:22 <ski> .. i suppose possibly `alternate' should come before `consequent' in the argument ordering, for consistency
10:53:28 <spirity> DMcGill: it's your responsibility to improve the future state of Haskell conditional operators by being an early adopter of cond.
10:53:36 <ski> (in the case of your original `iff', i.e.)
10:54:08 <spirity> ski: right. it's just an open statement on f and g. which makes it difficult to disprove. :P
10:54:16 <mcstar> noteventime: i dont think thats a problem, what you wanted, is not to compute your expensive new value, iirc
10:54:38 <edwardk> roconnor_: ping
10:54:52 <noteventime> mcstar: But there's no reason there couldn't be a updateLookup... that returns the new value instead, or is there (thus traversing only once)?
10:55:15 <roconnor_> edwardk: pong
10:55:29 <edwardk> https://github.com/ekmett/physics/blob/master/Physics/Rep.hs
10:55:48 <edwardk> note the use of (forall x. Lens (f x) x) as the representation of f
10:56:02 <mcstar> i guess, when it looks for a key, and looks past the position, where that key would have been found, it could insert there somehing more efficiently..
10:56:03 <noteventime> mcstar: Yours is an improvement on what I was doing, but I still think there's soom for an alterLookup function
10:56:05 <spirity> DMcGill: oh by iff you meant if' not a logical biconditional?
10:56:19 <mcstar> noteventime: in reality, i dont think it will mattter
10:56:27 <mcstar> how often do you think it will miss the key?
10:56:38 <DMcGill> I was looking to abstract out the do{cond <- something; if cond then f else g} pattern
10:56:47 <noteventime> mcstar: Probably one in ten times, or thereabouts
10:56:50 <spirity> DMcGill: that's what ifM does
10:56:50 <edwardk> roconnor_: that lets me define representability without using type families or MPTCs
10:56:56 <avpx> Why is it that you can float a "forall" out of the right of a function arrow but not out of the left?
10:57:00 <edwardk> roconnor_: i still need rank n types, but thats not so bad
10:57:01 <noteventime> Possibly more often
10:57:08 <ski> spirity : you're not meant to prove or disprove it, it's meant as a definition :)
10:57:29 <Nereid> avpx: it is clearer on the other side of curry-howard
10:57:58 <edwardk> roconnor_: in that sense the polymorphic lenses form a fairly canonical notion of a path
10:58:01 <ski> spirity : the question was to what extent this definition differs from `forall f g.  f =< g  <=>  forall x. f x =< g x', under the presupposition that `a' has a partial order
10:58:09 <spirity> ski: but my immediate reaction to any new definition proposed to me is to look for holes.
10:58:21 <Nereid> avpx: forall x. (P -> Q x) = P -> (forall x. Q x)
10:58:24 * roconnor_ tries to remember representable functors
10:58:28 <noteventime> ski: since you have reflexivity your order gives x <= x implies f x <= g x for all x, no?
10:58:35 <Nereid> avpx: meanwhile, (forall x. P x) -> Q = exists x. (P x -> Q)
10:58:42 <Nereid> (in predicate logic)
10:58:46 <edwardk> roconnor_: f a is corepresentable if it is isomorphic to (x -> a) for some x
10:58:58 <edwardk> here i'm choosing x = forall y. Lens (f y) y
10:59:15 <edwardk> er rather f is corepresentable if it is isomorphic to (->) x
10:59:30 <roconnor_> where did co come from?
10:59:33 <avpx> Nereid: Oh, okay. Thanks.
10:59:33 <noteventime> mcstar: I'll use your solution for now, thanks :) maybe I can get an alterLookup patch accepted.
10:59:41 <edwardk> technically what i call representable there is corepresentable
10:59:54 <roconnor_> >:(
10:59:59 <edwardk> my vocabulary is backwards in representable-functors
11:00:04 <mcstar> ok
11:00:28 <avpx> Nereid: In predicate logic, is this -> referring to "if-then"?
11:00:33 <edwardk> the contravariant functors f that are isomorphic to (-> a) are the contrarepresentable/representable functors and the covariant ones are 'corepresentable'
11:00:34 <Nereid> I tend to call both "representable", but yes, if you use corepresentable, ti would be for this one.
11:00:38 <Nereid> avpx: implication, yeah.
11:00:43 <avpx> Okay
11:00:44 <edwardk> but representable is often used for both
11:00:46 <noteventime> ski: And conversely if f x <= g x for _all_ x then trivially x <= y implies f x <= f y <= g y
11:00:51 <edwardk> so its not that bad
11:01:07 <roconnor_> this corespentablity notion isn't fitting in my head
11:01:19 <edwardk> roconnor_: take data Pair a = Pair a a
11:01:24 <edwardk> that is representable by Bool
11:01:29 <edwardk> Bool -> a   is isomorphic to Pair a
11:01:37 <Nereid> (modulo issues relating to bottom)
11:01:41 <edwardk> sure
11:01:51 <noteventime> ski: So unless I'm mistaken (which I tend to be), your order is the restriction of the product order to monotonic functions
11:02:06 <roconnor_> edwardk: oh okay
11:02:08 <edwardk> since f is 'just isomorphic to a function' you can say a lot about f
11:02:14 <roconnor_> this is the normal representablity that I think of
11:02:17 <edwardk> yes
11:02:20 <roconnor_> whew
11:02:39 <edwardk> now, i'm choosing to use the polymorphic lenses _as_ a canonical choice of representation for a functor
11:02:52 <roconnor_> what did you use before?
11:03:03 <edwardk> forall a. Lens (f a) a --  that defines a path.
11:03:08 <edwardk> so lets go to our Pair example
11:03:17 <roconnor_> edwardk: you mean van Laarhoven lenses.
11:03:33 <edwardk> Pair a ~ (forall b. Lens (Pair b) b -> a)
11:03:38 <edwardk> no i mean polymorphic in the value type
11:03:49 <edwardk> er
11:04:03 <edwardk> Pair a ~ (forall b. Lens (Pair b) b) -> a
11:04:18 <ski> noteventime : "since you have reflexivity your order gives x <= x implies f x <= g x for all x, no?", yes, which is why we're only considering the monotonic functions in `a -> b'
11:04:18 <roconnor_> sure I understand that
11:04:25 <roconnor_> edwardk: but what were you using before?
11:04:32 <edwardk> i had a type family
11:04:36 <ski> spirity : "but my immediate reaction to any new definition proposed to me is to look for holes." -- holes in which sense ? :)
11:04:47 <edwardk> type family Key (f :: * -> *) :: *
11:04:47 <roconnor_> edwardk: bold choice getting rid of that
11:04:55 <roconnor_> edwardk: why not use data-lens?
11:04:59 <Nereid> ski: I don't see what that has to do with monotonicity but I don't know what you're doing.
11:05:00 <spirity> ski: a contradiction
11:05:29 <edwardk> this is in a separate experimental library for rigid body physics, i needed representability but didn't want a million dependencies
11:05:33 <edwardk> so i came up with this lens scheme
11:05:56 <noteventime> ski: Doesn't that prove it's just the point-wise order for monotonic functions though?
11:06:02 <edwardk> class Functor f => Rep f where rep :: ((forall g x. Functor g => (x -> g x) -> f x -> g (f x)) -> a) -> f a -- covers everything i need
11:06:09 <roconnor_> Bool seems so much more efficent than (forall g x. Functor g => (x -> g x) -> (x,x) -> g (x, x))
11:06:21 <ski> noteventime : where did "if f x <= g x for _all_ x" come from ?
11:06:26 <edwardk> the instances are very nice: https://github.com/ekmett/physics/blob/master/Physics/V2.hs#L72
11:06:36 <Nereid> roconnor_: one of them is canonical
11:07:03 <edwardk> roconnor_: i don't use representability very often, mostly to remove boilerplate
11:07:11 <roconnor_> Nereid: ?
11:07:51 <edwardk> https://github.com/ekmett/physics/blob/master/Physics/Plucker.hs#L33   is nicer than writing out (>>=) by hand
11:08:10 <ski> noteventime : hm, ok, so you were proving `forall f g. f =<_pointwise g  =>  f =<_blah g'
11:08:47 <edwardk> you aren't stick with lenses. i could have just used something like the polymorphic algebras. (forall x. f x -> x) as the key type
11:08:51 <edwardk> er stuck with
11:09:14 <roconnor_> edwardk: that seems like it would be easier
11:09:14 <edwardk> but then i wouldn't get the nice property that i can use
11:09:24 <roconnor_> what property?
11:09:41 <edwardk> q^.i  to access a quat that is represented by rep f = Quaternion (f e) (f i) (f j) (f k)
11:09:53 <mgsloan> should change D2 to be "R2", and V2 to be "D2".  That way it can be "instance R2 D2 where"
11:09:55 <ski> noteventime,Nereid : hm, sorry, misread "x <= x implies f x <= g x for all x
11:09:57 <ski> "
11:10:05 <edwardk> before i had to make up data types and fight with a lot of boilerplate
11:10:30 <edwardk> and come up with disjoint names for the axes X and Y in 2d and 3d, etc.
11:10:32 <mcstar> noteventime: let new = f k -> let new = f def
11:10:43 <edwardk> mgsloan: hahaha
11:10:54 <edwardk> R2 is actually a nicer name for D2
11:11:06 <roconnor_> edwardk: hmm
11:11:10 <mgsloan> yeah, that's the name we use in diagrams
11:11:47 <noteventime> ski: Yea, I (hopefully) proved the orders to be equivalent
11:11:55 <mgsloan> though for something like V2 instead
11:11:56 <roconnor_> edwardk: you make Plucker a Monad? ... how bold
11:11:57 <edwardk> just swapped them all over to that
11:11:59 <ski> noteventime : yes, i think it's right
11:12:01 <edwardk> roconnor_: =P
11:12:02 <roconnor_> edwardk: I didn't even make RGB a monad.
11:12:21 <roconnor_> only Applicative
11:12:24 <edwardk> roconnor_: i need to work with my ad package in places
11:12:29 <edwardk> and the monad comes for free
11:13:05 <edwardk> the monad is just the diagonal, its useful for computing traces, etc.
11:13:20 <edwardk> sum $ m >>= id  -- gives you a trace
11:13:25 <mgsloan> I'm hoping to have (in all seriousness):  type R2 = D2 Double;  newtype D2 a = D2 (a, a).  Whereas currently we just have newtype R2 = R2 (Double, Double)
11:13:39 <roconnor_> edwardk: ya but m >>= id  -- gives you arbitrary nonsense
11:14:23 <avpx> It seems like the types are wrong for m >>= id
11:14:26 <Nereid> m >>= id = join m
11:14:28 <edwardk> here im using it on a square matrix represented by m (m a) so trace :: (Monad m, Foldable m, Num a) => m (m a) -> a
11:14:31 <edwardk> Nereid: yes
11:14:48 <avpx> In m >>= f, shouldn't f be of type f :: a -> m b? id doesn't seem to fit the bill
11:14:57 <Nereid> avpx: what if a was m c?
11:14:58 <roconnor_> avpx: moor unification
11:15:02 <edwardk> avpx: it does when a = m b
11:15:07 <Nereid> or m b
11:15:44 <edwardk> we can make that more sane by using representability of course
11:15:50 <edwardk> =)
11:16:29 <edwardk> given a finitely representable functor, we can trace = tally $ \i -> m^.i.i
11:16:43 <edwardk> er trace m = tally $ \i -> m^.i.i
11:16:51 <roconnor_> edwardk: compactly representable functor?
11:17:13 <edwardk> possibly, haven't thought through of compact is enough
11:17:17 <edwardk> er if
11:17:26 <edwardk> or what that precisely means in this setting
11:17:35 <edwardk> what i need is that there are a finite number of elements in the basis
11:17:40 <edwardk> or representation
11:18:14 <roconnor_> we can integerate in Haskell over compact types
11:18:16 <edwardk> i don't have a nice way of representing finite representability in this code yet
11:18:25 <roconnor_> edwardk: use the J monad
11:18:28 <roconnor_> somehow
11:18:55 <edwardk> heh did you see my "generalization" of J to any contravariant functor?
11:19:31 <Nereid> what's the J monad?
11:19:39 <edwardk> newtype Search f a = Search (f a -> a) is a monad for contravariant f
11:20:00 <roconnor_> edwardk: I vaguely recall seeing it
11:20:07 <edwardk> the J monad is martin escardo's topological trick for searching infinite spaces in finite time, given a predicate that terminates in finite time for all inputs
11:20:19 <edwardk> its related to hilbert's epsilon
11:20:40 <roconnor_> and the J monad isn't in the mtl for some reason
11:20:44 * roconnor_ stares at edwardk
11:20:47 <Nereid> ah thanks, a term I can google now
11:20:54 <c_wraith> only JT would appear in the mtl. :P
11:21:24 <c_wraith> JT is a hilariously useless name for a type.
11:21:47 <edwardk> Nereid: look on comonad.com for 'searching infinity parametrically' i wrote up a more refined notion of it
11:22:02 <Nereid> ok
11:22:03 <edwardk> c_wraith: i call it 'Search' when i use it
11:22:18 <edwardk> http://hpaste.org/69758
11:22:44 <edwardk> anyways it requires enough boilerplate to actually use that its not a good mtl candidate
11:22:56 <edwardk> plus then i have to armwrestle ross to get it into transformers =(
11:23:43 <roconnor_> oh right, it's ross's fault
11:23:46 <roconnor_> sorry edwardk
11:23:56 * roconnor_ glares at ross
11:25:08 <dylukes> http://www.williams-sonoma.com/products/breville-one-touch-tea-maker/?pkey=e%7Ctea%7C30%7Cbest%7C0%7C1%7C24%7C%7C5&cm_src=PRODUCTSEARCH||NoFacet-_-NoFacet-_-Feature_Recipe_Rule-_-
11:25:12 <dylukes> w/c
11:26:15 * hackagebot cyclotomic 0.2 - A subfield of the complex numbers for exact calculation (ScottWalck)
11:28:09 <edwardk>  roconnor_ : anyways i figured the abuse of lenses for representability was novel enough to get your attention ;)
11:28:24 <edwardk> and you have to admit the code looks very nice with it, even if the type signature is vile ;)
11:28:27 <roconnor_> edwardk: it feels familiar
11:28:48 <edwardk> roconnor_: it came up when we talked about 'telescope' for cofree f
11:28:54 <Nereid> this sounds cool, I'll have to read the log later
11:29:10 <edwardk> telescoping :: (Functor f, Functor g) => [(Cofree g a -> f (Cofree g a)) -> g (Cofree g a) -> f (g (Cofree g a))] -> (a -> f a) -> Cofree g a -> f (Cofree g a)
11:29:22 <roconnor_> edwardk: I'm looking for a way to have multilenses make your life easier.
11:29:28 <edwardk> =P
11:29:41 <roconnor_> edwardk: let me know when you need to represent 2^X where X is your basis
11:29:49 <roconnor_> cause then you can use multilenses :D
11:29:52 <edwardk> hah
11:29:54 <edwardk> yeah
11:30:25 <edwardk> there is a use-case of that for Fin n as the representation of Vec n
11:30:27 <roconnor_> sounds vaguely Clifford algebra
11:30:56 <edwardk> and then the thing that Vec n is the representation of
11:31:26 <edwardk> i'm leaving off clifford algebras here, i only needed 3d plucker/study coords
11:31:38 <edwardk> =)
11:31:56 <edwardk> i may add a separate Study type
11:32:10 <edwardk> since its a nicer basis for many operations
11:33:56 <roconnor_> I'm not familiar with study
11:35:13 <edwardk> eduard study came up with something that are isomorphic to plucker coordinates around 1880, but they are awkward to work with in projective geometry, but are useful in oriented projective geometry
11:36:17 <edwardk> they turn out to be the basis you get when you diagonalize the quadratic form for the plucker quadric
11:38:12 <jfischoff> skimming your thesis, but what application in physics.git are they helpful for?
11:38:58 <jfischoff> edwardk: also where do you want the physics package to go?
11:39:17 <jfischoff> or put another way, what contributions would be useful?
11:39:56 <edwardk> jfischoff: this is honestly just a toy so i can have rigid body physics for a toy 2d game engine. i'll probably get bored of it before i finish ;)
11:40:54 <edwardk> jfischoff: i could use bullet or physx or pal, but i wanted the ability to deal with the world in a purely functional manner for AI purposes, so i can let AI agents simulate their controls and do simple a* like searches through game space
11:41:03 <jfischoff> toy 2d game engine that doesn't go anywhere is exactly the type of projects I like to work on ;)
11:41:04 <edwardk> and i wanted the ability to mix 2d and 3d physics
11:41:28 <luite> creating the environment for next year's icfp challenge?
11:41:40 <edwardk> i have an 'arcade' project i haven't uploaded to hackage yet which is basically a physics engine and the start of a network-serializable ai model
11:41:50 <jfischoff> it would be nice to make a simple game showing of the iOS patch
11:42:17 <edwardk> so i can send agents around and possibly send game designs to clients, it'd be kind of neat to have a general purpose side-scrollery engine, but i'm not sure where i'll go with it
11:42:27 <Ornedan> How do I set a network connection to time out?
11:42:31 <edwardk> it was mostly a 'hey i have a bunch of code lying around, what can i do with it?' experiment
11:42:34 * roconnor_ wonders what the ICFP contest was this year
11:42:37 <edwardk> and i finally got sdl to work on a mac ;)
11:44:02 <Ornedan> Trying to create the socket myself and then doing "setSocketOption sock SendTimeOut 1000" fails with *** Exception: setSocketOption: invalid argument (Invalid argument)
11:44:17 <Ornedan> What kind of values should I be feeding to setSocketOption?
11:44:39 <Ornedan> And is it even the right way to set timeouts?
11:45:14 <roconnor_> Ornedan: I think there is a package that lets you set timeouts
11:45:30 <edwardk> jfischoff: anyways i'd started by just wanting to do 2d physics, because i've only got a cheesy little 2d platformer/shmup engine in mind, but it'd be nicer to have 3d physics so i can make impats on ragdolls send bodies flying, etc.
11:45:33 <roconnor_> AFAIU the standard network still doesn't let you set timeouts on sockets
11:45:40 * roconnor_ isn't a networking guy
11:45:55 <edwardk> plus i've already done almost this work before so its mostly a matter of reinventing what i've done a decade ago to work in haskell
11:46:01 <ski> @where impossible
11:46:01 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
11:46:03 <ski> Nereid ^
11:46:05 <Ornedan> Oh. It's not a part of the platform, is it?
11:46:20 <jfischoff> edwardk: sounds super fun
11:46:31 <matthew-> so I'm having a few issues getting my head around ContT. Basically, I don't understand why it doesn't manipulate the inner monad at all - certainly nothing like what StateT does. The few examples I can find of ContT don't seem to be overly helpful. Any pointers?
11:46:36 <Nereid> ski: I've already found them ;)
11:46:40 <ski> @where topology
11:46:40 <Nereid> thanks though
11:46:40 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
11:46:41 <lambdabot> dvi|ps)> by Martn Escard
11:46:42 <roconnor_> Ornedan: the network bindings have been broken for about 10 years
11:46:43 <edwardk> jfischoff: the library you see there was written last night. not much actual physics/contact point stuff yet
11:46:46 <ski> Nereid : might also be interesting
11:46:50 <edwardk> not sure how i want to represent everything yet
11:46:50 <Nereid> mm
11:47:18 <ski> Nereid : there's also one or two more posts on Andrej Bauer's blog about Escardó's search idea
11:47:27 <edwardk> i do like the way matrix multiplication works though
11:47:42 <mgsloan>  edwardk: could be a good thing for hac-phi!
11:47:52 <edwardk> mgsloan: true that
11:48:19 <mgsloan> back when I was interested in making video games, 2d physics games were my M.O.
11:48:35 <edwardk> mgsloan: i'm more of a 3d guy at heart
11:48:45 <edwardk> but i'm also not in a hurry to make a whole art pipeline, etc.
11:49:10 <mgsloan> gotcha.  Well, I was always intent on 2d gameplay with 3d elements / acceleration
11:49:15 * roconnor_ simulates 2d physics to the atomic level.
11:49:16 <edwardk> *nods*
11:49:38 <edwardk> here, i've made #haskell-arcade, lets stop spamming the channel =)
11:49:41 <jfischoff>  edwardk: wah…I need to figure that out.
11:50:06 <mgsloan> yeah
11:50:54 <roconnor_> http://www.meta-synthesis.com/webbook/35_pt/pt_database.php?PT_id=29
11:53:10 <djahandarie> mgsloan, you still at OPLSS?
11:53:28 <mgsloan> djahandarie: yup, Amal is doing logical relations right now
11:53:40 <djahandarie> Heh, nice, that was a good one
11:53:46 <djahandarie> Feel like you're getting more out of it this time around?
11:56:10 <mgsloan> djahandarie: definitely, and Awodey is an excellent lecturer
11:56:27 <mgsloan> though dense for people who haven't tried to learn category theory previously
11:56:53 <djahandarie> Oh, here's there this year? That would have been nice
11:57:29 <djahandarie> Is there a talk on Homotopy Type Theory? :)
11:58:24 <mgsloan> Harper focused more on breadth than proof depth, so he kinda hand-waved a bit about homotopy and higher-dimensional type theory
12:00:53 <mgsloan> there's also some Haskell from John Hughes later this week!  The haskellers and non-haskellers alike are excited for that
12:01:10 <Qtr> how do i get apt-get haskell platform on ubuntu?
12:01:54 <mgsloan> lunch time!
12:01:55 <Clint> apt-get install haskell-platform ?
12:03:07 <latro`a_> silly question: you can define >=> in terms of >>=, can you go the other way?
12:03:52 <roconnor_> latro`a_: yes and yes
12:04:14 <dmwit> :t \m f -> (const m >=> f) ()
12:04:15 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
12:04:36 <latro`a_> ah
12:04:39 <latro`a_> ty
12:05:02 <latro`a_> const was the trickery I needed
12:05:11 <latro`a_> and wasn't thinking of
12:14:09 <Ornedan> roconnor_: Found the package (network-socket-options), but turns out the recv and send timeouts aren't quite the thing that I was looking for
12:16:40 <Ornedan> With send and recv timeouts set to 1ms, trying to connect to something that doesn't respond still times out only after several tens of seconds
12:19:09 <roconnor_> :/
12:19:11 <roconnor_> sorry
12:20:02 <statusfailed> Hey guys, I have a terrible joke!
12:20:05 <noteventime> Wasn't there some general package to timeout IO stuff?
12:20:07 <statusfailed> what's the opposite of :?
12:20:27 <otters> ?:
12:20:27 <lambdabot> Maybe you meant: . ? @ v
12:20:41 <statusfailed> pros
12:20:43 <statusfailed> ha ha ha
12:20:44 <statusfailed> :|
12:20:47 <mcstar> _
12:20:49 <mcstar> :?
12:20:54 <otters> oh
12:20:55 <mcstar> i.e. bar-:?
12:20:57 <otters> I thought :? was the symbol
12:21:00 <otters> not :
12:21:00 <statusfailed> lol
12:21:04 <otters> "what's the opposite of ':' ?"
12:21:07 <otters> is the question
12:21:17 <Cale> I was going to say the opposite of (:)
12:21:22 <noteventime> I thought it was a reference to the ghci thingie
12:21:24 <otters> it's snoc
12:21:29 <otters> import Data.Text
12:21:53 <otters> or maybe head &&& tail?
12:22:44 <Qtr> statusfailed: tail
12:22:59 <Ornedan> noteventime: System.Timeout?
12:22:59 <Qtr> statusfailed: now tell us!
12:23:00 <otters> no, because cons has type a -> [a] -> [a]
12:23:07 <statusfailed> has to be \(x:xs) -> (x,xs)
12:23:10 <statusfailed> surely
12:23:11 <otters> whereas head &&& tail would have type [a] -> a -> [a]
12:23:13 <statusfailed> aka head &&& tail
12:23:17 <otters> or possibly tail &&& head
12:23:24 <otters> no, [a] -> ([a], a)
12:23:27 <Qtr> so the joke is?
12:23:28 <otters> not the other thing I said which was wrong
12:23:32 <statusfailed> Qtr: not funny?
12:23:33 <statusfailed> :D
12:23:38 <otters> the joke is pro is the opposite of con
12:23:48 <Qtr> > (head &&& tail) [1,2,3,4]
12:23:49 <lambdabot>   (1,[2,3,4])
12:23:57 <otters> > (tail &&& head) [1..4]
12:23:58 <lambdabot>   ([2,3,4],1)
12:24:06 <Qtr> statusfailed: i dont get it
12:24:12 <mcstar> in haskell the opposite of : is :
12:24:14 <mcstar> noobs
12:24:14 <otters> what's the opposite of cons? pros
12:24:23 <otters> or maybe it's flip (:)
12:24:30 <otters> there are all kinds of ways you could answer this question
12:24:40 <Qtr> ghc failed to install on ubuntu on vmware
12:25:01 <sclv> uncons
12:25:12 <sclv> ?hoogle uncons
12:25:13 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
12:25:13 <lambdabot> Data.ByteString.Lazy.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
12:25:13 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
12:25:19 <statusfailed> dammit
12:25:25 <statusfailed> they missed out on giving that a proper name
12:25:32 <otters> pros?
12:25:32 <mcstar> : is the way to construct a list, and the way to deconstruct it
12:25:34 <otters> yeah, definitely
12:25:39 <mcstar> end of story
12:25:53 <sclv> the way to deconstruct a list is fold :-P
12:26:10 <mcstar> what does 'fold :-P' mean?
12:26:15 <sclv> fold
12:26:20 <Nereid> @type head (&&&) tail
12:26:21 <sclv> and :-P is a dude sticking out his tongue
12:26:21 <Nereid> er
12:26:22 <lambdabot>     Couldn't match expected type `[a]'
12:26:22 <lambdabot>            against inferred type `a1 b c -> a1 b c' -> a1 b (c, c')'
12:26:22 <lambdabot>     In the first argument of `head', namely `(&&&)'
12:26:23 <Nereid> @type head &&& tail
12:26:25 <lambdabot> forall c. [c] -> (c, [c])
12:26:28 <mcstar> @hoogle (:-P)
12:26:29 <lambdabot> Parse error:
12:26:29 <lambdabot>   (:-P)
12:26:29 <lambdabot>      ^
12:26:36 <otters> son of a gun
12:26:51 <otters> let P = [1..10] in 0 :P
12:26:56 <otters> > let P = [1..10] in 0 :P
12:26:57 <lambdabot>   Not in scope: data constructor `P'Not in scope: data constructor `P'
12:27:01 <otters> bah
12:27:07 <Nereid> try p
12:27:18 <mcstar> not half as funny with p
12:27:26 <statusfailed> we can make P and instance of Num?
12:27:29 <statusfailed> an*
12:27:34 <otters> > let þ = [1..10] in 0 :þ
12:27:35 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
12:27:37 <otters> better
12:27:58 <Nereid> > let し = [1..10] in 0 :し
12:28:00 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
12:28:42 <Nereid> > let ☃ = '☃':☃ in ☃
12:28:44 <lambdabot>   <no location info>: parse error on input `
12:28:46 <Nereid> aw.
12:28:49 <statusfailed> whaaaat
12:29:12 <edwardk> Nereid: http://hpaste.org/51474
12:29:12 <otters> > '\2603'
12:29:14 <lambdabot>   '\2603'
12:29:23 <statusfailed> Is there a unicode middle finger?
12:29:29 <otters> > ['\2603']
12:29:30 <lambdabot>   "\2603"
12:29:34 <otters> *sigh*
12:29:43 <edwardk> i just found it funny that i could make (╯°□°)╯ 彡 ┻━┻  "yep"  -- into legal haskell
12:29:48 <mcstar> sick story
12:29:52 <edwardk> thanks
12:29:58 <edwardk> i pride myself on my writing ability
12:30:01 <mcstar> no, not a compliment
12:30:03 <GyorsCsiga> haha
12:30:16 <GyorsCsiga> i fallz off muh sk8burd
12:31:18 * hackagebot eurofxref 0.2.0 - Free foreign exchange/currency feed from the European Central Bank (StephenBlackheath)
12:31:20 * hackagebot paypal-api 0.2 - PayPal API, currently supporting "ButtonManager" (StephenBlackheath)
12:31:55 <GyorsCsiga> wow
12:32:03 <GyorsCsiga> nice
12:32:05 <shirt> statusfailed: ┌∩┐
12:32:14 <GyorsCsiga> looks like the alamo
12:32:39 <statusfailed> hahah
12:32:41 <statusfailed> I can't tell what it is
12:32:57 <shirt> ┌∩┐(-_-)┌∩┐
12:32:57 <GyorsCsiga> probably intended to be the middle finger
12:33:03 <noteventime> A tombstone?
12:33:03 <GyorsCsiga> yes, now that's even more obvious
12:33:30 <statusfailed> oh right :)
12:33:32 <GyorsCsiga> its an indifferent face in the middle of two tombstones
12:33:43 <GyorsCsiga> maybe it's a zombie
12:33:55 <mcstar> maybe its offtopic
12:34:09 <GyorsCsiga> maybe
12:34:26 <singpolyma> In case anyone else is having the problem with cabal where in refuses to intall anything because of Hackage being hosed, this command just came up on the mailing list and fixed it for me:  tar -vf 00-index.tar --delete HUnit/1.2.5.0/HUnit.cabal
12:37:30 <Nereid> > let (☃) = const '☃' in ☃ ☃ ☃ ☃
12:37:32 <lambdabot>   <no location info>: parse error on input `
12:37:37 <Nereid> oops.
12:37:42 <Nereid> I'm silly.
12:38:07 <otters> > let (☃) = const "☃" in ☃ ☃ ☃ ☃
12:38:08 <Nereid> > let (☃) = const '☃' in (☃)☃(☃)
12:38:08 <lambdabot>   <no location info>: parse error on input `
12:38:09 <lambdabot>   Couldn't match expected type `(b -> GHC.Types.Char) -> t'
12:38:10 <lambdabot>         against i...
12:38:13 <otters> well that seems silly
12:38:24 <Nereid> I'll stop being sill ynow.
12:38:27 <Nereid> gfhbngfhb
12:38:36 <shachaf> > let (☃) = 5 in ☃ ☃ ☃ ☃
12:38:37 <lambdabot>   <no location info>: parse error on input `
12:38:48 <shachaf> > let (☃) = 5 in (☃)☃(☃)
12:38:49 <lambdabot>   5
12:39:00 <Qtr> Einstein said something like: Doing the same thing twice and expecting different results is the definition of stupididty. Well I showed him because i apt-got ghc again and it worked!
12:39:26 <mcstar> not twise, repeating something
12:39:27 <otters> > 5 5 5
12:39:28 <mcstar> twice*
12:39:28 <lambdabot>   5
12:39:32 <EvanR> einstein is the most often quoted dude about stuff that he has no basis in giving advise
12:39:34 <otters> > 1 2 3 4 5
12:39:35 <lambdabot>   1
12:39:39 <EvanR> advice
12:39:43 <mcstar> insanity, not stupidity also
12:39:45 <otters> > 1 "your mom"
12:39:46 <lambdabot>   1
12:39:51 <shachaf> In the words of Einstein: "I didn't say half the things I said"
12:39:53 <otters> wow, no kidding
12:40:25 <mcstar> einstein is still awesome
12:40:34 <mcstar> he was jew and all that
12:40:51 <otters> well who isn't
12:40:58 <mcstar> yeah
12:41:13 <EvanR> im not
12:41:16 <mcstar> thats the reason im not gonna be famous...
12:41:24 <otters> gotta be jewish
12:42:20 <phaer> Hi, i have some hsenv environments and keep getting "There are files missing in the `base' package" when i try compile. Might a ghc update be the reason for that?
12:42:45 <Qtr> woot! ran my first haskell program on linux
12:43:56 <Qtr> i have been in israel, does that make me jewish enough to become great?
12:44:18 <mcstar> nah, doesnt work that way
12:47:08 <noteventime> It's matrilinear not... terrilinear?
12:50:37 <edwardk> @ask roconnor_ can you tweak data-lens to allow it to use comonad 3.0? that would let me link with snap
12:50:37 <lambdabot> Consider it noted.
12:51:38 <veldskoen> ha ha ha
13:05:38 <dysinger> anyone know an easy (lazy) way to convert camel case to snake case for aeson? I'm already using the TH deriveJSON code (which is nice).  Now I just need it to snake_case_my_attributes
13:06:48 <mauke> > concatMap (\c -> (if isUpper c then ('_' :) else id) [toLower c]) "snakeCaseMyAttributes"
13:06:50 <lambdabot>   "snake_case_my_attributes"
13:07:14 <mauke> > concatMap (\c -> (if isUpper c then ('_' :) else id) [toLower c]) "XMLHttpRequest"
13:07:16 <lambdabot>   "_x_m_l_http_request"
13:07:35 <latro`a_> not as simple as it looks :p
13:07:51 <latro`a_> probably have to actually iterate
13:07:54 <latro`a_> eh recurse
13:08:57 <mcstar> is_this_really_called_snake_case? or you just made it up?(i havent heard this before)
13:10:19 <ciaranm> snake snake snake snake snake
13:10:30 <noteventime> How should XMLHttpRequest be snake_cased (unless you want to keep a list of keywords)?
13:12:23 <tromp_> no mention of snake in http://en.wikipedia.org/wiki/CamelCase
13:12:53 <noteventime> Snake case sounds like python nomenclature
13:13:08 <dysinger> yes
13:13:09 <dysinger> sorry
13:13:25 <dysinger> words_like_this where as haskell idiom is wordsLikeThis
13:13:34 <noteventime> tromp_: https://en.wikipedia.org/wiki/Letter_case
13:13:36 <mauke> how about a compromise? snake_Camel_Case_Everywhere!
13:13:42 <dysinger> heh
13:13:43 <noteventime> Check section "computers"
13:13:53 <dysinger> this works https://gist.github.com/2050507
13:14:26 <noteventime> I like StudlyCaps
13:14:34 <mauke> nice description
13:14:43 <dysinger> I have to integrate with an api that uses words_like_this for keys in JSON
13:14:55 <dysinger> I don't want to dirty my code with underscores
13:15:12 <dysinger> the above link works - I'm happy
13:15:16 <mauke> dysinger: that's more or less what I've written
13:15:20 <mauke> only complicated
13:15:34 <dysinger> is there something simpler ?
13:15:38 <mauke> yes
13:15:43 <mauke> THE CODE I WROTE
13:15:47 <mauke> ABOVE
13:15:49 <mauke> FOR YOU
13:15:51 <latro`a_> mauke's thing is simpler, though I suspect a comprehension would be even simpler :p
13:15:56 <latro`a_> well, equivalent
13:15:59 <latro`a_> but no explicit concatMap
13:16:01 * dysinger ah derp looks again
13:16:36 <mauke> latro`a_: expressing concat in comprehensions can be counterintuitive
13:16:43 <mauke> depends on your intuition :-)
13:17:27 <latro`a_> ah wait nvm, there's a two-element
13:17:30 <latro`a_> that can pop out
13:17:39 <latro`a_> nvm
13:18:50 <mauke> > (\xs -> [ c' | c <- xs, c' <- (if isUpper c then ('_' :) else id) [toLower c] ]) "snakeCaseMyAttributes"
13:18:51 <lambdabot>   "snake_case_my_attributes"
13:19:39 <latro`a_> right, which means you need two <-, which is the ugly bit
13:19:58 <mauke> exercise for the reader: do notation
13:20:06 <noteventime> > intercalate "_" . Data.List.groupBy (\_ x -> isLower x) $ "XMLHttpRequest"
13:20:07 <shachaf> do no tation
13:20:09 <lambdabot>   "X_M_L_Http_Request"
13:20:28 <noteventime> damn, needs map toLower too :P
13:20:38 <mauke> needs more const isLower
13:20:58 <noteventime> > map toLower . intercalate "_" . Data.List.groupBy (\_ x -> isLower x) $ "XMLHttpRequest"
13:21:01 <lambdabot>   "x_m_l_http_request"
13:21:13 <noteventime> yay for three traversals :P
13:25:16 <parcs`> looks like a single traversal to me
13:26:20 * hackagebot tls 0.9.8 - TLS/SSL protocol native implementation (Server and Client) (VincentHanquez)
13:28:55 <dysinger> thanks mauke !
13:32:02 <cutec> hey
13:39:02 <Raynos> I have two lists. I want the union minus the intersection. What's the correct "name" for an operation / function that does that for me
13:39:18 <byorgey> hi cutec
13:39:52 <c_wraith> Raynos: symmetric difference (also known as XOR in logic)
13:39:54 <byorgey> Raynos: that's called symmetric difference.  There is nothing in the standard libraries which does that.
13:40:11 <MostAwesomeDude> Raynos: You could use sets, which have this as the XOR operation.
13:40:18 <MostAwesomeDude> Oh, waaait. Sorry, ignore me.
13:40:21 <MostAwesomeDude> I thought I was in #python.
13:40:29 <Raynos> cool so defining a function which is symettricDifference(list, list, list, ...) is a sensible readable thing ?
13:41:33 <c_wraith> symmetric difference doesn't have an especially natural definition with more than 2 inputs, unlike union and intersection
13:41:38 <byorgey> Raynos: no, because it is not an associative operation
13:41:54 <Raynos> why doesn't it ?
13:41:59 <Raynos> why can't I take the union of all lists
13:42:05 <Raynos> and then remove the intersection of all lists
13:42:22 <byorgey> wait, hmm, maybe it is
13:42:27 <c_wraith> you can certainly do that - but the operation won't be very natural
13:42:29 <Raynos> I guess its the difference between removing the intersection of all lists and removing the union of pair wise intersections of all lists
13:42:48 <Raynos> your right, writing it for two lists makes sense
13:43:16 <byorgey> oh, it is associative!  but it's weird.
13:43:17 <Clint> you're trying to find those elements which appear in exactly one list?
13:43:38 <byorgey> iterated symmetric difference gives you those elements which are in an odd number of the input sets
13:43:47 <Raynos> im trying to take a list and remove all items from the other list in it
13:44:16 <mcstar> :S
13:44:28 <otters> filter (not . (`elem` list1)) list2
13:44:36 <Raynos> yeah that makes sense
13:44:52 <Raynos> thats a better building block
13:45:03 <byorgey> OK, but I'm going to take Raynos's side here, it seems like a natural generalization of symmetric difference to more than two inputs would be to return all those elements which occur in exactly one of the inputs
13:45:32 <otters> ooh
13:45:34 <otters> I wanna try and write that function
13:45:38 <c_wraith> There are a bunch of different ways to generalize it for more than one input.
13:45:40 <latro`a_> I think that's what you get with one of the folds
13:45:44 <Raynos> im so jealous ;_;
13:45:51 <Raynos> my language doesn't have a function compose operator
13:45:59 <otters> D:
13:46:02 <mcstar> just make it a left associative operator and youre done
13:47:14 <frerich_> I wish something like Data.Natural was in the Prelude :-/
13:48:13 <frerich_> Or maybe even a class instead of a type.
13:48:28 <c_wraith> You can generalize symmetric difference to a parity operation, present in exactly one input, present in some but not all inputs, probably more...
13:48:40 <byorgey> c_wraith: yeah, ok, good point.
13:48:41 <noteventime> Couldn't you define some kind of inclusion-exclusion kind of operator to generalise it?
13:49:03 <c_wraith> noteventime: that sounds like the parity version
13:49:04 <mendez> does anyone know how to write an instance declarition for something like this: class (Show a) => MyType a where ...
13:49:25 <noteventime> c_wraith: Right, didn't manage to read it before I pressed enter :)
13:49:59 <noteventime> mendez: What about it?
13:50:10 <donri> mendez: instance MyClass SomeType where ...
13:50:31 <donri> and make sure SomeType has a Show instance
13:50:43 <mendez> how do I add the show instance?
13:50:55 <donri> normally, "deriving (Show, ...)"
13:51:11 <mendez> I need a custom function for show
13:51:20 <donri> otherwise, instance Show SomeType where show = "SomeType"
13:51:47 <mendez> it says i need flexibleinstancs when I do that
13:51:51 <mendez> is that necessary?
13:52:02 <noteventime> Depends on how your type looks
13:52:17 <otters> > let compoundSymDiff lists = let addItem ls b = case lookup b ls of { Just count -> (b, succ count):(snd $ partition ((== b) . fst) ls); Nothing -> (b, 1):ls } in map fst $ filter ((== 1) . snd) $ foldl addItem [] $ concat lists in compoundSymDiff [[1..3], [2..4], [3..5]]
13:52:19 <lambdabot>   [5,1]
13:52:27 <mendez> noteventime: is pastebin welcome on #haskell?
13:52:58 <noteventime> mendez: Why not use hpaste.org?
13:53:22 <mcstar> otters: really?
13:53:23 <mendez> noteventime: didn't know about it!
13:53:36 <otters> mcstar: what?
13:53:44 <mcstar> otters: there is a Data.Set library
13:53:53 <otters> yeah, but I wanted to do it without any dependencies
13:54:00 <mcstar> oh, how sweet
13:54:39 <otters> anyway, how would you do that with a set?
13:55:06 <hpaste> mendez pasted “multiple class example” at http://hpaste.org/72024
13:55:09 <mcstar> i can try..
13:55:29 <mendez> noteventime: how would I make show work with that?
13:56:04 <noteventime> mendez: I can't see why you'd need flexibleinstances for those instances
13:56:41 <noteventime> mendez: What do you mean by "make show work with that"?
13:56:46 <mendez> noteventime: should I just add "instance Show Command where ..."
13:57:11 <noteventime> You can't make an instance for a class
13:57:32 <noteventime> instance Show MyCmd where show MyCmd = "whatever"
13:57:45 <noteventime> class (Show a) => Command a where
13:57:57 <noteventime> just states that anything which wants to be a "Command" must also be a "Show"
13:58:06 <mendez> noteventime: ok! ghc is telling me to put that _in_ in the instance declaration for "Command MyCmd"
13:58:24 <Nereid> no
13:58:30 <Nereid> you need a Show instance for MyCmd
13:58:34 <Nereid> before you can define a Command instance
13:58:42 <mendez> ok, the wording ghc uses is just weird then
13:58:44 <dzhus> StateT wraps Reader. Being in State, how do I get down to Reader actions?
13:58:59 <mendez> alright it all works!
13:59:02 <c_wraith> dzhus: that's what lift is for
13:59:04 <noteventime> dzhus: lift?
13:59:08 <Nereid> if you don't need Show, you shouldn't require it, though
13:59:13 <noteventime> c_wraith: Always a second before me, eh?
13:59:22 <mendez> noteventime: Nereid: donri: thanks for the help! :)
13:59:30 <c_wraith> dzhus: though you should be able to just use the MonadReader class interface
14:01:08 <hpaste> mcstar pasted “otters” at http://hpaste.org/72027
14:03:29 <mcstar> hm, infixl isnt necessary, sd should be associative
14:03:38 <hpaste> otters pasted “multiple symmetric difference” at http://hpaste.org/72028
14:04:03 <otters> maybe I should stop trying
14:04:46 <mcstar> you can put 'sd' in a fold..
14:05:31 <otters> oh, yours calculates the difference of two
14:05:34 <ski> is-this-called-hyphenated-case-or-what?
14:05:47 <noteventime> floating snake case?
14:05:51 <mcstar> otters: yes
14:05:56 <mauke> tactical air snake
14:05:56 <mcstar> pretty obvious :)
14:06:18 <mcstar> dash-case
14:06:45 <noteventime> Perhaps bead-case?
14:06:57 <otters> mine just takes them in a list
14:06:59 <otters> how dirty
14:07:03 <mcstar> or, simply lispy
14:07:13 <mcstar> lol
14:07:25 <mcstar> i remember, after CL i wrote something in C
14:07:34 <mcstar> and the damn thing didnt want to compile
14:07:42 <mcstar> i even asked some other people, why not
14:07:55 <mcstar> turned out, i used - to separate words, instead of _
14:08:04 <hpaste> mmos1127 pasted “unsafePerformIO” at http://hpaste.org/72029
14:08:15 <noteventime> ski: It's used a lot in lisps, isn't it (at least elisp)?
14:08:17 <otters> lol
14:08:59 <mauke> it's used in lisp (multiple-value-bind) except when it isn't (rplaca)
14:09:05 <ski> noteventime : yes, it's common in Scheme as well, and i think Common Lisp
14:09:16 <noteventime> I find it kinda sad that I've written more elisp than scheme or CL >_>
14:09:38 <ski> yeah, but `rplca' is a hysterical raisin
14:09:44 <hpaste> mmos1127 annotated “unsafePerformIO” with “unsafePerformIO (annotation)” at http://hpaste.org/72029#a72030
14:09:55 <noteventime> ski: rplca sounds like an R package
14:10:07 <ski> noteventime : at least Emacs Lisp has recently got support for lexical scoping and closures ..
14:10:14 <mmos> question posted at hpaste
14:10:24 <ski> (`rplca' in CL is `set-car!' in Scheme)
14:10:29 <Peaker> emacs lisp is still a lisp 2, right?
14:11:11 <noteventime> I should just bite the bullet and learn Yi
14:11:14 <mcstar> replica
14:11:59 <ski> Peaker : yes
14:12:38 <noteventime> That reminds me, is there some nice way to get something like R's data frames in Haskell (using HList?)?
14:12:49 <ski> (something like `RePLace CAr', i imagine)
14:13:06 <Peaker> ski, one of the weirdest features in a language.. inelegant, complicates things, and of so little practical value
14:13:28 <ski> Peaker : yeah, i'm in the Lisp-1 camp :)
14:13:43 <ski> (though i think for some purposes multiple namespaces could be useful)
14:14:14 <mauke> I'm in the Lisp-7 camp (a.k.a. Perl)
14:14:36 <ski> hm, can you represent each namespace as a tree ?
14:14:53 <mcstar> ski: ofc, replace car, but it is annoying that 'replica' comes to my mind first, but it doesnt matter much, i only see it in old code
14:15:29 <Peaker> mauke, if I understood your explanations correctly, Perl's namespaces aren't really distinct?
14:15:54 <Peaker> mauke, if you want to do stuff with some 'x' array, you might need to use a different sigil but still access 'x'?
14:15:59 * ski . o O ( "Seven Trees in One" by Andreas Blass in 1995 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.8517> )
14:16:00 <Peaker> (s/understood/remember)
14:16:24 <Hakkla> hello, newbie here.
14:16:44 <ski> hello Hakkla
14:17:10 <otters> Lawvere [8]
14:18:25 <noteventime> Something about that abstract makes it sound like  joke
14:19:10 <ski> Hakkla : have you found a Haskell tutorial or book to follow yet ?
14:19:15 <otters> something about that abstract makes me unable to understand any of it
14:19:24 <ski> Hakkla : if you have any questions, you're welcome to state them :)
14:19:55 <Hakkla> Thank you!
14:20:37 <Hakkla> I've been flipping through numerous tutorials and two books, plus the wikibook on Haskell. It's quite fun to learn.
14:20:47 <noteventime> Presumably I'm missing something, but can't you just take a fixed tree with seven leafs and tuck on whatever trees you want there?
14:21:11 <Hakkla> This is, until you end up losing your hair after so much head-scratching.
14:21:32 <Hakkla> That's when I know it's time to take a break...
14:21:36 <noteventime> Damn it, now I have to read that paper
14:21:38 <ski> Hakkla : you can also just stay in here, and lurk, sometimes seeing if there's an interesting discussion going on which you can follow
14:21:55 <mcstar> sometimes that interesting discussion will scare you
14:22:06 <ski> in that case, just ignore it for now
14:22:43 <ski> Hakkla : if you're new to IRC, you might find <http://tremulous.net/forum/index.php?topic=7451.10;wap2>,<http://weblog.terrellrussell.com/2007/10/always-away-for-plausible-deniability/>,<http://www.zephoria.org/thoughts/archives/2005/02/13/cultural_divide_in_im_presence_vs_communication.html>,<https://6002x.mitx.mit.edu/wiki/view/IRCCulture> interesting
14:23:02 <mcstar> ski: how an earth do you do that?
14:23:06 <ski> do what ?
14:23:23 <mcstar> instantly give multiple links on any topic
14:23:53 <ski> hehe, i had these prepared since earlier, when i was looking for some IRC intro for newbies
14:24:01 <noteventime> ski is lambdabot in disguise
14:24:09 <mcstar> much better than lambdabot
14:25:19 <Hakkla> thanks ski (proceeds to delve into the documents...)
14:25:24 <ski> Hakkla : anyway, the most important IRC custom/rule/point : if you ask a question, please stick around *at least* half an hour for people to get a chance to answer it (this is more important on less-active channels than #haskell, though)
14:26:32 <Hakkla> I wonder if after half an hour someone will be able to find your message through half an hour of cross-chatting
14:26:49 <keseldude> does anyone know why do notation doesn't mind nonexhaustive pattern matching, yet >>= does?
14:26:52 <noteventime> ski: Followed by don't-ask-to-ask? :)
14:26:52 <ski> sometimes this channel actually is pretty quiet, as well
14:26:57 <ski> noteventime : yeah :)
14:27:04 <keseldude> > [Just 1, Nothing, Just 3] >>= \(Just x) -> [x]
14:27:05 <lambdabot>   [1*Exception: <interactive>:3:30-45: Non-exhaustive patterns in lambda
14:27:25 <keseldude> > do {Just x <- [Just 1, Nothing, Just 3]; return x}
14:27:26 <lambdabot>   [1,3]
14:27:34 <ski> Hakkla : but yes, it's more of an urgent issue on less-active channels
14:27:57 <ski> > [x | Just x <- [Just 1, Nothing, Just 3]]
14:27:58 <lambdabot>   [1,3]
14:28:02 <latro`a_> keseldude, do notation calls fail when patterns fail to match
14:28:13 <ski> @undo do {Just x <- [Just 1, Nothing, Just 3]; return x}
14:28:13 <lambdabot> [Just 1, Nothing, Just 3] >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
14:28:15 <keseldude> oh okay
14:28:19 <latro`a_> yeah, that
14:28:19 <ski> @undo [x | Just x <- [Just 1, Nothing, Just 3]]
14:28:19 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) [Just 1, Nothing, Just 3]
14:28:35 <keseldude> thank you
14:28:39 <ski> yw :)
14:29:51 <noteventime> λm
14:30:21 <mcstar> mirror fail
14:30:27 <mcstar> λm :)
14:30:52 <noteventime> Couldn't help myself :P
14:31:10 <noteventime> Damn, you're right
14:38:33 <joedenson> *running out of stack space in the io monad* hello all. i'm doing some work in the io monad, and it's a loop, so each call apart from the last finished with a call to same function. i thoguth this was tail calling, so i would be fine, but then i thought, is a monadic bind actually a tail call. any advice?
14:38:56 <hpc> joedenson: paste your code?
14:38:59 <hpc> @where hpaste
14:39:00 <lambdabot> http://hpaste.org/
14:39:05 <mauke> stack is unrelated to calls
14:40:12 <joedenson> hpc: thanks - it can be boiled down to this. http://hpaste.org/72032. will that run out of stack space?
14:40:46 <joedenson> hpc: obviously, there's an if, so it doesn't always call function again
14:41:04 <joedenson> hpc: it works on small problems, but runs out of stack on larger ones
14:41:12 <hpc> it shouldn't - your problem is somewhere in the elided details
14:41:15 <ski> joedenson : yes, `..x..' is executed in a tail-context of (executing) `... >>= \x -> ..x..', in the case of the `IO' monad -- however, see what mauke said
14:41:25 * hackagebot vector-space 0.8.2 - Vector & affine spaces, linear maps, and derivatives (ConalElliott)
14:41:44 <conal> thanks to byorgey for the vector-space patch
14:41:54 <hpc> ooh
14:41:59 <hpc> conal: what's the patch?
14:42:00 <joedenson> hpc: ok thanks, just suddenly thought that maybe binds aren't ever tail calls
14:42:24 <hpc> joedenson: if that were the case you would find that there aren't many programs you can write with reasonable performance :P
14:42:26 <ski> joedenson : also, nitpick, if you have `function :: IO Blah' (as opposed to e.g. `function :: Foo -> IO Blah'), then `function' is not a function (it's an `IO'-action)
14:42:27 <conal> hpc: generalized the type and implementation of projecting one vector onto another.
14:42:37 <hpc> cool
14:42:58 * hpc pretends he has any memory of linear algebra
14:43:21 <Nereid> linear algebra is great
14:43:26 <ski> conal : elaborate ?
14:44:00 <noteventime> projection as in orthogonal projection?
14:44:04 <conal> yes
14:44:17 <ski> generalized from what to what ?
14:44:20 <noteventime> I really need to check out the vector space package :)
14:45:07 <conal> ski: i was normalizing one of the vectors. brent's (equivalent) formulation doesn't need normalizing and so is probably faster and works over Fractional, not just Floating.
14:45:31 <conal> a small thing, but it pleases me.
14:45:57 <Nereid> ah good, you're using the formula in my first-year linear algebra text.
14:46:03 <Nereid> :P
14:46:36 <noteventime> Hmm, does that mean the notion of inner product space makes sense over the rationals?
14:46:55 <Nereid> it makes sense over any ordered field.
14:47:03 <Nereid> (drop ordered if you don't require positive-definiteness)
14:47:14 <noteventime> True, I never thought of that
14:47:25 <ski> conal : ok, so it'd work even with the zero vector, then ?
14:47:42 <Nereid> which vector being zero?
14:48:58 <Nereid> also I would rather see ((v <.> u) / magnitudeSq u) ^* u but oh well.
14:48:59 <ski> hm, or i suppose in general it wouldn't be specified with just a single vector
14:49:09 <Nereid> in general one would project onto a subspace.
14:49:29 <conal> ski: not with zero. the new version divides by the magnitude^2.
14:49:43 <Nereid> er, *^
14:49:50 <ski> Nereid : well, i was imagining either the vector spanning the line you want to project onto, or the vector which is orthogonal to the coline (line,plance, &c.) which you want to project ontu
14:50:05 <Nereid> coline = hyperplane.
14:50:12 <ski> but then i thought about `|R^4 --> |R^2' and stuff
14:50:19 <Nereid> eww |R
14:50:20 <Nereid> :P
14:50:33 <ski> you prefer complex vector spaces ?
14:50:45 <Nereid> no I mean eww at how you typed that.
14:50:53 <ski> hehe, ok
14:51:05 <Nereid> it looks terrible.
14:51:06 <noteventime> Are ther unicode symbols for mathbb?
14:51:09 <Nereid> yes
14:51:19 <Nereid> ℝ
14:51:24 <Nereid> oops
14:51:38 <dzhus> Puzzled by transformers again. StateT wraps Reader. How do I `run` the whole burito (=give initial states to StateT and reader)?
14:51:44 * lispy has his own vector space implementation as he only cares about dim < 5.
14:51:59 <noteventime> dzhus: First runStateT to get a Reader, then run the reader
14:52:12 <Nereid> conal: any good way to represent subspaces with your thing?
14:52:13 <lispy> I keep looking at vector-space and not using it. I have borrowed some ideas though.
14:52:35 <conal> Nereid: i don't know.
14:52:37 <monochrom> @type runReader
14:52:38 <lambdabot> forall r a. Reader r a -> r -> a
14:52:55 <monochrom> runReader (runStateT prog s) r
14:53:03 <ski> Nereid : is ⌜ℝ⁴ → ℝ²⌝ better ?
14:53:08 <Nereid> I see boxes.
14:53:16 <Nereid> so, no
14:53:17 <Nereid> :)
14:53:33 <Nereid> R suffices.
14:53:34 <noteventime> Aren't those japanese quotation marks or something like that?
14:53:35 <monochrom> R^n are boxes anyway
14:53:35 <lispy> ski: looks nice here, FWIW
14:53:37 <dzhus> monochrom: noteventime: right. I interchanged the two (had reader inside state). Unwrap matches the wrap!
14:53:42 <Peaker> @type runStateT
14:53:44 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
14:53:47 <dzhus> *runReader inside *runState
14:54:09 <Peaker> dzhus, monad transformers generally provide some sort of "unwrap" function like:   t m a -> m a   (usually) so then you can chain these unwrappers
14:54:35 <conal> Nereid: i like your suggestion of projecting onto subspaces.
14:54:36 <Nereid> @type runReader . runStateT
14:54:37 <lambdabot>     Couldn't match expected type `ReaderT r Identity a'
14:54:37 <lambdabot>            against inferred type `s -> m (a1, s)'
14:54:37 <lambdabot>     Probable cause: `runStateT' is applied to too few arguments
14:54:42 <Nereid> oh.
14:54:47 <ski> @type \r s -> (`runStateT` s) . (`runReaderT` r)
14:54:49 <lambdabot> forall s (m :: * -> *) r a. r -> s -> ReaderT r (StateT s m) a -> m (a, s)
14:54:50 <Nereid> yeah.
14:54:51 <avpx> Peaker: I haven't dealt much with monad transformers, but wouldn't that unwrap function essentially be escaping the monad introduced by t?
14:54:53 <ski> @type \r s -> (`runReaderT` r) . (`runStateT` s)
14:54:54 <lambdabot> forall r (m :: * -> *) s a. r -> s -> StateT s (ReaderT r m) a -> m (a, s)
14:55:20 <noteventime> avpx: You do that with normal state/reader e.t.c. though (runState, runReader)
14:55:21 <avpx> Or "running," I'm not sure what you kids are calling it these days
14:55:24 <ski> @unmtl ReaderT r (StateT s m) a
14:55:24 <lambdabot> r -> s -> m (a, s)
14:55:30 <ski> @unmtl StateT s (ReaderT r m) a
14:55:31 <lambdabot> s -> r -> m (a, s)
14:55:33 <avpx> noteventime: Yeah, I was just clarifying
14:55:41 <Nereid> conal: and then the question is how to represent subspaces.
14:55:58 <Nereid> I guess the easiest way would just be to take a list (or something) of vectors that form a basis.
14:56:07 <lispy> conal: any plans to add homogeneous coordinate operations?
14:56:10 <conal> Nereid: yes, indeed.
14:56:17 <Peaker> avpx, right, often it's not (t m a -> m a)  but (<extra args> -> t m a -> m (extraWrapper a) )
14:56:19 <Nereid> but then you'd have to worry about them being orthogonal and such.
14:56:41 <Peaker> avpx, so <extra args> and extraWrapper represent the inescapable part.. or in case of Cont:
14:56:41 <conal> Nereid: or at least linearly independent
14:56:43 <Peaker> @src runContT
14:56:43 <lambdabot> Source not found. Are you on drugs?
14:56:50 <Peaker> @type runContT
14:56:51 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
14:56:52 <ski> conal : yes, and preferably, the given vectors wouldn't need to be linearly independent
14:57:02 <Nereid> no, they *should*
14:57:11 <conal> lispy: nope. i'm not actively working on this library.
14:57:17 <ski> why not just project to the subspace spanned by them ?
14:57:36 <lispy> conal: now I feel less bad about writing my own library :)
14:57:44 <Nereid> ski: numerical errors
14:57:54 <Nereid> ski: every linearly dependent set (of 2 or more vectors) is very close to a linearly independent set
14:58:15 <Nereid> (if the space is large enough)
14:58:31 <Nereid> actually, 1 or more.
14:58:33 <ski> hm, ok
14:58:46 <Nereid> so
14:58:56 <Nereid> a linearly dependent set that spans some subspace is very close to a basis for some larger subspace.
14:59:00 <Nereid> in general.
14:59:12 <ski> Nereid : even "0 or more", i'd gather
14:59:13 <avpx> Peaker: I think I see. That type signature is a bit hard to read.
14:59:20 <ski> *nod*
14:59:26 <Nereid> ski: ah, yes, vacuously true.
14:59:28 <Nereid> :P
14:59:28 <latro`a_> does that work for the Schauder case, Nereid?
14:59:30 <lispy> conal: I was somewhat surprised to find out that C++ overriding is actually a bit nicer to read than the encoding we have to do in Haskell.
14:59:30 <ski> (:
14:59:41 <Nereid> anyway, I was going to say, gram-schmidt can be used to orthogonalize a set of vectors without taking square roots.
14:59:44 <Hakkla> Any tips for a *shall we say welcoming for new users* haskell IDE? I don't think I'd like those function-overloaded editors (like shall we say Emacs) which seem to be *the* mainstream, but I can't stick with notepad forever!
14:59:46 * ski is fond of including trivial/vacuous cases
14:59:47 <Peaker> avpx, runContT?
14:59:54 <Nereid> ski: me too, I just wasn't thinking that way.
15:00:11 <avpx> Peaker: I'm not terribly familiar with Cont or monad transformers, so I had to stare at it for a bit.
15:00:15 <Nereid> any linearly dependent set with size no larger than the dimension of the space, then.
15:00:22 <Peaker> avpx, basically the "run" of monad transformers usually exposes the inner structure/representation of the transformer, which lets you "peel" it off as needed
15:00:30 <conal> lispy: the extra ad-hoc-ness helps sometimes. what in particular came out prettier in C++ for you?
15:00:36 <avpx> Peaker: Yeah, that makes sense
15:00:36 <Peaker> avpx, Cont is one of the most confusing things :)
15:00:38 <Nereid> latro`a: I've been assuming finite-dimensionality everywhere :s
15:00:38 <latro`a_> "dimension" in which sense, Nereid? :p
15:00:40 <noteventime> Hakkla: What's wrong with emacs? :)
15:00:40 <latro`a_> ah
15:00:42 <latro`a_> nvm
15:00:59 <avpx> Peaker: I've used continuations in Scheme but not so much in Haskell.
15:01:04 <latro`a_> (sorry, Hamel and Schauder dimension don't coincide)
15:01:04 <lispy> conal: I'm not fond of writing operators like this: (^*)
15:01:14 <Nereid> lispy: what can you do
15:01:40 <conal> lispy: ah, yeah. me neither.
15:01:53 <noteventime> Nereid: Wouldn't it be reasonable to just let type of subspaces be given by the collection of projections?
15:01:54 <lispy> Nereid: you could use the module system to define (*) for each operation isolation?
15:02:01 <ski> Hakkla : i think emacs can be used as a simple editor, not using most of the bells and whistles (or learning some of them, as you need them). -- but there's probably other good choices, for other tastes as well
15:02:01 <Nereid> sometimes it would be nice to completely gut out the whole Num hierarchi and redo it
15:02:15 <Nereid> hierarchy
15:02:26 <lispy> Nereid: but then you endup with import Foo as F; a F.* b
15:02:34 <Nereid> lispy: you would
15:02:40 <noteventime> ski: I guess it depends on what kind of features you want, you can check out Leksah if you want something more like a "regular" IDE
15:02:44 <Peaker> avpx, Then (a -> r) -> r   should be relatively familiar
15:02:51 <Peaker> avpx, unless Scheme hides it from you very well
15:02:56 <ski> noteventime : you might want to say that to Hakkla :)
15:03:07 <noteventime> Hakkla: *
15:03:08 <Nereid> noteventime: but how do you tell whether something's a projection
15:03:09 <noteventime> Sorry :P
15:04:01 <Nereid> hmm
15:04:07 <lispy> I could just do scaleVector :: Scalar a -> Vector a -> Vector a
15:04:09 <ski> Hakkla : you can probably use Notepad++, GEdit, &c. as well -- istr someone mentioning a Haskell plugin for Eclipse, but i might be imagining things
15:04:13 <lispy> But that's kind of verbose too
15:04:13 <Nereid> I'd rather describe a subspace as an inclusion.
15:04:31 <Nereid> but then for projecting onto a subspace maybe you'd need to supply a basis for the subspace anyway.
15:04:42 <noteventime> Nereid: The basis of the codomin can be written in terms of the image of the basis of the domain or something like that >_>
15:04:49 <Nereid> you don't get a basis that way
15:04:55 <ski> Peaker : yes, you don't see it in Schem, unless you're doing CPS (and are thinking about the types)
15:05:02 <ski> s/Schem/Scheme/
15:05:31 <Nereid> maybe we'd just have to trust the programmer to supply a basis that's actually a basis.
15:05:35 <Peaker> ah
15:05:50 <Nereid> (just as we trust them to supply a nonzero number when dividing)
15:05:52 <monochrom> how about use agda? :)
15:05:57 <Hakkla> thanks. the thing is, writing code is hard enough. full-blown editors have this large learning curve which can get frustrating when you can't find the *run* button, or if it has that name or if it even exists.
15:06:14 <latro`a_> Nereid, check P^2 =  P?
15:06:17 <Nereid> how?
15:06:28 <latro`a_> how what
15:06:34 <latro`a_> how do you check P^2 = P?
15:06:43 <latro`a_> if P is supplied as a matrix, multiply and check
15:06:46 <Nereid> yes, you have to check it yourself.
15:06:52 <Nereid> there's no way to enforce it.
15:06:57 <latro`a_> if P is supplied as a linear map, pick a basis, build the matrix, and do the same
15:07:23 <noteventime> Nereid: You mean enforce statically?
15:07:33 <Nereid> somehow.
15:07:39 <ski> Hakkla : i would suggest just playing with the interactor in a terminal by the side, to start with
15:07:49 <monochrom> you can enforce that statically in agda :)
15:08:06 <Nereid> monochrom: floats
15:08:07 <ski> (though maybe you'll find that tedious, after being used to "run bottons" in other editors/IDEs ?)
15:08:13 <Nereid> anyway, I think it's most useful to describe subspaces by inclusions, because
15:08:15 <Nereid> (a) that's what they are, and
15:08:24 <Nereid> (b) subspaces don't automatically give you projections without an inner product
15:08:33 <latro`a_> uh
15:08:34 <latro`a_> no
15:08:37 <latro`a_> that is not how that works
15:08:43 <Nereid> what's not how what works
15:08:48 <latro`a_> there are non-orthogonal projections
15:08:58 <Nereid> those aren't canonical
15:09:02 <Nereid> I meant canonical projections
15:09:08 <latro`a_> fair enough
15:23:44 <Hakkla> ski: Whilst the GHCi does the job nicely (for now), I have to resort to external editors if I want to write a small program, instead of simply evaluating expressions in the shell. Anyway, I guess I won't find that "perfect" Haskell IDE yet - I'll give a closer look to the options available. Thanks!
15:24:40 <Peaker> Hakkla, working on "the perfect Haskell IDE", heh, will take a looong while till released, though :)
15:26:00 <ski> Hakkla : yes. what i was suggesting was writing in an "external" editor, save the file, use `:r' to reload in the interactor, and then test if the reload was successful -- then back to editing
15:26:25 <ski> Hakkla : there's some things called Yi and Leksah, but i haven't tried them
15:26:28 <ski> @where Yi
15:26:28 <lambdabot> http://www.haskell.org/haskellwiki/Yi
15:26:31 <ski> @where Leksah
15:26:31 <lambdabot> http://www.leksah.org/
15:28:34 <roconnor_> edwardk: you have sent me on a long chase to upgrade ghc and cabal-install :)
15:28:34 <lambdabot> roconnor_: You have 1 new message. '/msg lambdabot @messages' to read it.
15:28:54 <Botje> it's for a good cause.
15:31:58 <mm_freak> i wonder what's the difference between an "IDE" and a powerful text editor like emacs
15:32:26 <noteventime> IDEs take longer to load, break in stranger ways and tend to be developed by Microsoft
15:32:40 <mm_freak> probably "Integrated Development Environment" just sounds more corporaty
15:32:43 <lispy> My IDE is my shell.
15:32:59 <lispy> IDE == Integrated Development Environment, right?
15:33:03 <shachaf> Ooh, is it make-fun-of-people-who-use-different-tools-from-ours-o'clock?
15:33:20 <noteventime> shachaf: Indeed ;)
15:33:27 <lispy> shachaf: is that right before beer thirty?
15:33:27 <luksow> I think that the most important thing for people looking for IDE for any language is autocompletion with documentation integrated
15:33:27 <roconnor_> shachaf: my watch says we have 5 minutes
15:33:28 <mm_freak> shachaf: my question was serious
15:33:31 <mm_freak> what's the difference?
15:33:33 <noteventime> In bead-case
15:33:57 <mm_freak> it's like that misnomer "scripting language"
15:34:02 <shachaf> mm_freak: "IDE" is a vague word.
15:34:08 <shachaf> Like "scripting language", yes.
15:34:25 <shachaf> Feel free to call Emacs an IDE, or not.
15:34:26 <noteventime> mm_freak: I think people expect an IDE to be very project centric
15:34:41 <lispy> stepping back for a second, why would anyone want an IDE? The point is to increase productivity and make development easier.
15:34:57 <lispy> Lots of ways to achieve that goal.
15:35:02 <shachaf> There's a certain style of thing that people call "IDE" that has a certain way of working.
15:35:37 <noteventime> lispy: I suspect it might be just as much related to standardising workflow in corporate environments
15:35:46 <lispy> If you use vim, I recommend vundle. Easy to install and it makes it painless to try out all the great vim scripts out there.
15:36:12 <Nereid> how does it compare to the billion other plugin managers
15:36:15 <mm_freak> noteventime: what makes it that way?  i have my projects in emacs…  i fail to see how people can say "there is no good IDE for haskell" despite the presence of emacs and vim
15:36:29 <lispy> I just started using it. I put all my dotfiles in a repo on github (totally optional) and now I have one command to install my plugins on any computer I work on.
15:36:47 <lispy> Nereid: It's the only one I've tried.  That's how it compares :)
15:36:50 <Nereid> ok
15:37:00 <Nereid> I admit I've only tried one as well.
15:37:13 <Nereid> and only just recently.
15:37:15 <Botje> "vundle"? man, how many bundling scripts are there :)
15:37:37 <noteventime> mm_freak: I'm not sure, but I think the fact that  you aren't automatically forced into working with the notion of a file hierarchy + build script is part of the problem.
15:37:45 <lispy> For anyone interested: https://github.com/dagit/dotfiles
15:37:50 <roconnor_> wow, upgrading cabal actually fixed my problem
15:37:53 <roconnor_> cabal++
15:37:58 <noteventime> lispy: Is it something like packages+marmalade for emacs?
15:38:16 <lispy> noteventime: I have no idea.
15:38:34 <lispy> noteventime: With emacs I always installed packages by hand, but it makes sense that they would have a package manager by now.
15:38:57 <mm_freak> noteventime: i guess what people makes disqualify emacs/vim as real IDEs is that they require some initial configuration to be useful…  visual studio also requires that, but people don't see it and just use the ugly default settings
15:38:58 <Nereid> lispy: vundle fetches things from github?
15:39:02 <merijn> lispy++
15:39:06 <lispy> Nereid: yes, or other places
15:39:10 <Nereid> neat.
15:39:41 <merijn> I just have my own scripts to pull from github and make all the relevant symlinks/whatever to update my environment
15:39:51 <noteventime> mm_freak: At risk of sounding like an asshole, I think the problem is almost as much due to emacs being configuratble at all (as opposed to what I can remember from using Visual Studio)
15:40:31 <Peaker> emacs is horrendously behind the times, and I really don't understand why it remains that way for so long
15:40:47 <noteventime> Peaker: In what sense?
15:40:53 <mm_freak> noteventime: VS 2008 settings are comprehensive enough that you can make coding somewhat sufferable
15:40:53 <merijn> Peaker: Because it's codebase is almost as awful as vim?
15:40:56 <Peaker> no proper code indexing, when Eclipse/Visual studio have that relatively covered
15:40:57 <geekosaur> emacs is arguably the configurable program version of a turing tarpit
15:41:06 <noteventime> lispy: The package manager is only included since 24 I think
15:41:14 <merijn> I wanted to make vim more emacs-y, but the vim codebase is so awful I ended up weeping and vomiting instead
15:41:42 <noteventime> Peaker: What's wrong with imenu?
15:42:08 <noteventime> merijn: Why not make emacs more evil-mode?
15:42:30 <Peaker> noteventime, the problem is that there's no existing tool compatible with emacs (other than eclim, but that's cheating) that can index C, C++, Java, etc  code-bases properly
15:42:40 <merijn> noteventime: Because all vim emulation modes I've tried so far suck and it is very hard to retrofit proper modal editing
15:42:44 <mm_freak> Peaker: emacs and vim are simply the best we have…  i wouldn't trade emacs editing for indexing/completion…  i just live with the fact that i can only use dabbrev and love haskell for being such a wonderful language that i seldomly need documentation
15:42:47 <lispy> I like a lot about emacs, but for some reason (load times?) I switched to vim in the last year and I feel like it's just as good as emacs but harder to script.
15:42:51 <noteventime> mm_freak: I haven't used visual studio since it started calling itself .NET, so I really shouldn't pretent I know :P
15:43:29 <Peaker> mm_freak, I agree, I use emacs myself, but I'm disgruntled about such a horrible program being "the best". Also, when just code browsing, and not editing, it's not really the best
15:43:39 <noteventime> lispy: Load times as in startup times?
15:43:44 <lispy> noteventime: yeah
15:43:46 <merijn> Peaker: All the more reason to get bottle going :p
15:43:56 <mm_freak> Peaker: check out ecb
15:43:57 <Hakkla> Quick question: have these editors remained the same in ages?
15:44:00 <lispy> noteventime: it was probably my fault (something in my huge emacs config)
15:44:00 * ski . o O ( "Living in Zmacs" by John Wiseman in 2003-12-02 at <http://lemonodor.com/archives/000629.html> )
15:44:03 <noteventime> lispy: You realise you can just run it daemonised?
15:44:16 <Nereid> that's just wrong in so many ways.
15:44:33 <Nafai> Nereid: Why?
15:44:43 <Nereid> no reason.
15:44:47 <merijn> Hakkla: Not entirely, but they feel very similar to the version of 10-20+ years ago, yes
15:44:49 <mm_freak> Hakkla: the core of emacs hasn't changed much
15:44:57 <lispy> noteventime: yeah, I never liked leaving my emacs running though. I didn't like the way it managed internal state (like paths)
15:45:13 <lispy> noteventime: whereas with vim it always assumes the path I ran it from
15:45:16 <Peaker> merijn, yeah, tell me about it :)
15:45:20 <ski> Peaker : that ^ Zmacs link mentions several things which Zmacs on the Lisp machines had, but which GNU Emacs doesn't have ..
15:45:28 <Toheii> The real problem I have with IDE's is they don't let me play tetris like emacs does but seriously I'm pretty sure vim wasn't really meant to be used as a IDE hence the large amount of packages to hack it into one
15:45:46 <mm_freak> Hakkla: emacs alone is really just a very simple text editor…  it's all the various scripts that make it so powerful
15:45:51 <noteventime> Toheii: I think some old version of Visual Studio had a built in flipper game
15:45:53 <merijn> Peaker: I'll have time to dive into debugging the graphics issues I had with bottle later this week, so I'll probably bug you then with questions :p
15:45:58 <lispy> mm_freak: true
15:46:21 <Peaker> mm_freak, from a quick glance, it seems ecb does not support jumping to some_struct::x  rather than some "x"
15:46:28 * hackagebot data-lens 2.10.1 - Haskell 98 Lenses (RussellOConnor)
15:46:30 <lispy> mm_freak: and elisp is really a crummy language for making anything significant (and the execution model means it sucks to run external code)
15:46:32 <merijn> Toheii: Personally I just use tmux/screen and Ctrl-Z to drop to the shell from vim when I need to do non-editing stuff :p
15:46:40 <Peaker> mm_freak, quick glance suggests it also doesn't index the preprocessed code
15:46:40 <ski> Peaker : also "We aren't gonna lie. Emacs sucks. Some of us tolerate it, but we can't tell you if YOU'LL be able to. Try it and make up your own mind." :)
15:46:59 <Peaker> ski, where's that quote from?
15:47:02 <noteventime> lispy: From what I've been told, the Vim configuration langauge is a lot worse :P
15:47:02 <shachaf> ski: "But if you want to use Agda, you'd better be able to"
15:47:07 <Toheii> merijn: I do the same except with "awesomewm" and terminator
15:47:18 <lispy> noteventime: yeah it is. We need Yi to come and save us?
15:47:25 <ski> Peaker : `/msg fsbot salespitch' (`fsbot' is a regular of #emacs, and that quote is often invoked there)
15:47:31 * lispy should probably try yi again, does it still have a cli mode?
15:48:01 <lispy> by cli I guess I mean textual UI
15:48:03 <noteventime> lispy: You can configure emacs in Javascript, if it's more to your liking :P
15:48:17 <noteventime> lispy: I think those are called TUI
15:48:18 <Hakkla> so everything related to text editors is a hack somehow.
15:48:48 <lispy> noteventime: I tried hacking on several email clients written in elisp. I think that's when I realized the folly of my ways :)
15:48:49 <roconnor_> @tell edwardk data-lens is updated
15:48:49 <lambdabot> Consider it noted.
15:48:56 <noteventime> Hakkla: Arguably most "useful" software is a hack somehow :P
15:49:05 <mm_freak> Peaker: ecb uses a package to add language-specific stuff…  i don't know how well it behaves for C++, but at least for haskell it works very well
15:49:09 <ski> still, dispite Emacs sucking, it's still much better than common "IDE" alternatives in several ways
15:49:13 <Toheii> Hakkla: Unix shell is a very good programming environment but a lot of people try to "hack" the features of the shell into an editor
15:49:40 <ski> Peaker : and i'm thankful for you trying to improve the situation, out of your perspective on things :)
15:50:00 <Peaker> ski, cool :)
15:50:15 <lispy> Toheii: yeah. I think that's an important realization for programmers about the shell.
15:50:28 <Peaker> mm_freak, given my previous experiences with emacs code indexing, I'd not be optimistic about it, unfortunately
15:50:33 <ski> Peaker : it remains to be seen whether i'll like it, but i think it's good that people do try to do these kinds of things
15:50:37 <noteventime> lispy: I'd love to use Yi too, I'm just scared I'll have to reimplement ido-mode :P
15:50:56 <mm_freak> Peaker: i really doubt that ECB uses the builtin mechanism
15:51:06 <ski> (.. as long as they're informed on the current main alternatives, at least)
15:51:13 <lispy> noteventime: I um...tried to solve that problem a different way once. I started writing an elisp compiler.
15:51:17 <lispy> noteventime: in haskell...
15:51:41 <noteventime> So soon we'll have Yi but with all the bad parts of emacs!
15:51:55 <Peaker> mm_freak, I understand, the bar has simply been set so low, I tried some other indexing thing a while back that seemed promising, but then choked on a real-sized code-base
15:51:59 <ski> (some people are attempting to make Guile Scheme the main language of Emacs ..)
15:52:02 <monochrom> emacs has no bad parts :)
15:52:05 <lispy> noteventime: later I realized I should have come up with some Haskell primitives that model elisp (like dynamic scope) and then translate to Haskell? (turns out to be a hard problem if you want good performance)
15:52:29 <merijn> Peaker: The only thing I hate about you're bottle project is that it's undercutting my original plan of pitching a similar idea as a task for my phd ;p
15:52:30 <ski> monochrom : not even dynamic-scope-by-default ?
15:52:32 <Peaker> mm_freak, also ecb itself makes no mention of preprocessing (bad sign), or field lookups (bad sign) though maybe that's because these features are specific to C/C++ (and the latter also to Java)
15:52:47 <Peaker> merijn, I think the project is too large for a PhD
15:52:51 <monochrom> oh, I forgot that. nevermind
15:52:57 * lispy goes back to vim to write some code :)
15:53:03 <monochrom> in fact I forgot all of the lisp part :)
15:53:07 <merijn> Peaker: Maybe
15:53:17 <mm_freak> Peaker: as i'm mainly a haskell programmer i really can't tell you much there…  i can just tell you that ecb works for me and that you might find it interesting =)
15:53:24 <ski> monochrom : hygienic macros would also be good
15:53:24 <Peaker> merijn, we've (2 of us) spent about 5 months on it so far, and maybe 20%-33% finished
15:53:40 <mm_freak> Peaker: also ecb is by no means a solution…  it's an approach
15:53:46 <Peaker> mm_freak, ah, thanks, maybe for Haskell it's going to have an easier time
15:53:48 <monochrom> I am now wary of macros too, hygienic or not
15:53:49 <noteventime> Peaker: What is this bottle project?
15:54:25 <Peaker> noteventime, a structural editor/IDE for Haskell-like programming. Very preliminary work, though: http://github.com/Peaker/bottle
15:54:38 <ski> monochrom : well, they can be misused, yes. did you have any more substantial complaint (i can think of at least one) ?
15:54:52 <Peaker> noteventime, getting rid of textual representation of code from the entire toolchain, opening up lots of interesting possibilities
15:55:10 <noteventime> Peaker: I've been wondering why something like that wasn't around for a long time :)
15:55:11 <monochrom> I write you "(f x y)" and you have no idea whether f is a function or a syntax macro thingy. no idea.
15:55:16 <ski> (well, that one is more a complaint about current (hygienic or not) macro-systems, rather than the macro idea itself)
15:55:35 <Peaker> noteventime, it's a hard problem, because the entire toolchain has to be reinvented, from scratch, and compete with text tools that have evolved for a long time
15:55:46 <Peaker> noteventime, s/from scratch// :)
15:55:51 <ski> monochrom : some people would prefer using (say) square brackets for macro application
15:56:07 <noteventime> Peaker: How does it relate to research into visual programming languages?
15:56:07 <monochrom> yeah, that would be good enough for me
15:56:20 <ski> monochrom : i suppose the current answer there is "know what things you have in scope" (hygiene helps a lot here, too)
15:56:28 * hackagebot free-functors 0 - Provides free functors that are adjoint to functors that forget class constraints. (SjoerdVisscher)
15:56:57 <Peaker> noteventime, "visual programming language" implies (to me) presenting code on screen as a bunch of boxes and arrows, which is not a good idea :)
15:57:22 <ski> (i.e. hygiene means that in `(foo (bar ...))', `foo' can't be locally binding `bar' to a macro in its actual parameters)
15:57:23 <Peaker> noteventime, also implies mousy-clicky UI approach, which cannot compete with good key bindings in a text editor
15:57:39 <Peaker> noteventime, Just my subjective interpretations of "visual programming language", so I'm not sure
15:57:48 <ski> (i.e. if `foo' wants to bind a local macro, the name of that has to be selected by the caller of `foo', like `(foo bar (bar ...))')
15:57:52 <lispy> Peaker: I think those are stereotypes left over from the 80's-90's.
15:58:18 <lispy> People still do VPL research, but it's evolved a bit
15:58:34 <ski> monochrom : .. and of course using square brackets for "primitive" syntax like `if',`define',`cond',`set!' as well
15:58:36 <Peaker> lispy, Well, if what's being presented on screen is similar to the text encoding, then it's more a "structural" thing than a "visual" thing?
15:59:08 <lispy> Peaker: I don't know. I couldn't really figure out how the VPL folks define the boundaries of what they do.
15:59:35 <monochrom> I prefer every formal phrase, not just code but also math and logic, in boxes and arrows
15:59:35 <lispy> Peaker: One researcher told me that "visual" should really be "helping you understand it and build a mental model"
15:59:36 <Hakkla> I'd say that making adding VPL would be too hard for the benefits it could bring
16:00:00 <Peaker> noteventime, I think lots of previous attempts tried to do the editing part structurally, but still serialize to/from text in the backend, which has huge drawbacks.. Others repeat the mistakes I mentioned above..  Others just mess up various other things
16:00:07 <monochrom> at least for educational purposes
16:00:39 <Peaker> lispy, well, we're going to have a "skins" feature where you press a button to have all the names be presented in a different language.. Would that qualify us as "visual" then?
16:01:23 * ski recalls that trigger scripts in the Heroes of Might and Magic IV editor was written by clicking on buttons on a window, writing/editing a sub-command opened a new (modal) window, &c.
16:01:45 <monochrom> students keep thinking "(∀x. P) -> Q" is the same as "∀x. P->Q" and similar things. This is precisely because of the text. Put them in boxes and arrows, draw the parse trees, clearly unequal.
16:02:05 <noteventime> Peaker: How will you serialise things, something like a squeak image?
16:02:05 <Toheii> The one place where visual might help is huge data structurs like binary tree's with 7-8 branches
16:02:06 <matthiasgorgens> How do I reduce a list of type [Msg -> IO (Maybe Msg)] to Msg -> IO (Maybe Msg), in the obvious way.
16:02:08 <matthiasgorgens> ?
16:02:27 <copumpkin> :t sequence . sequence
16:02:28 <lambdabot> forall a. [[a]] -> [[a]]
16:02:28 <ski> monochrom : i think there's value in at least emphasizing the tree view at the start, and having them practice with it
16:02:31 <Peaker> noteventime, we're using a versioned key/value store
16:02:38 <matthiasgorgens> (I.e. are there some monad transformers, or so, that make it easier to pass through the msg, and drop out if it's Nothing.)
16:02:40 <lispy> Peaker: yeah, I think so.
16:03:17 <Peaker> noteventime, the idea is that the backend store for the editor is a data structure that's appropriate for the kinds of things you do with it.. pull/push to remote repos, the searches needed, refactorings, editings, are all in sane O() complexities rather than O(size of project) as they often are in a text-backend approach
16:03:19 <copumpkin> matthiasgorgens: there isn't an obvious way
16:03:23 <ski> monochrom : however, the traditional textual / (mostly) linear notation is more compact -- cf. tree-style ND proofs vs. linearized ones (with or without boxes for local assumptions)
16:03:24 <copumpkin> :t sequence .: sequence
16:03:25 <lambdabot> forall (m :: * -> *) a (g :: * -> *). (Monad m, Monad g, Functor g) => [g (m a)] -> g (m [a])
16:03:30 <copumpkin> that comes close, though
16:03:33 <matthiasgorgens> yeah.
16:03:37 <copumpkin> but you haven't said what to do with the multiple Msgs
16:03:46 <matthiasgorgens> is (.:) = (.) . (.) ?
16:03:49 <ski> yes
16:03:50 <copumpkin> yup
16:03:55 <monochrom> I am also lately thinking of people with dylexia. (∀x. P) -> Q, ∀x. P->Q, ∀x. P/\Q all look the same to them. only the parse tree can help, and even then is just one small piece of the solution
16:04:14 <ski> monochrom : that's my original definition (with `infixr 9 .:'), then that got slightly generalized by Cale's `(.) = fmap' :)
16:04:16 <Peaker> noteventime, a simple exported-name-rename with a text-backend means you have to replace the name in the entire project (not to mention the source control conflicts you'll have later), with a horrible O()
16:04:17 <ski> er
16:04:20 <ski> matthiasgorgens ^
16:04:35 <noteventime> Peaker: I'd give an arm for something like that combined with a dependenly typed language :)
16:04:58 <matthiasgorgens> ski, so (.:) = fmap fmap fmap?
16:05:14 <ski> matthiasgorgens : yeah, though you can say simply `fmap . fmap'
16:05:18 <ski> @type (.:)
16:05:19 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:05:20 <Peaker> noteventime, We are tempted to support DT's, but we're not really skilled in DTs.. first goal is to have it self-hosted (which will be a while from now)
16:05:41 <mmos> http://hpaste.org/72029   <-- question here
16:05:41 <nart> hi
16:05:46 <Peaker> noteventime, we don't really know enough about making DTs work to do it properly, yet
16:05:53 <mmos> If someone answered this previously I apologize. I was away.
16:05:53 <nart> how can i solve this error ... GHCi runtime linker: fatal error: I found a duplicate definition for symbol _hsnet_freeaddrinfo whilst processing object file .cabal/lib/network-2.3.0.11/ghc-7.4.2/HSnetwork-2.3.0.11.o ?
16:05:57 <lispy> Very few humans are skilled in dependently typed languages/programming.
16:06:00 <ski> matthiasgorgens : the original intension was that `(f .: g) a b = f (g a b); (f .:: g) a b c = f (g a b c)', &c.
16:06:02 <monochrom> anyway, even without quantifiers, even at a more basic level, students have zero problem and full confidence saying "(x and y) or z" = "x and (y or z)"
16:06:10 <lispy> (and I suspect the ones that are, feel like no one is)
16:06:22 <ski> > (^2) . [0 .. 9]
16:06:24 <lambdabot>   can't find file: L.hs
16:06:27 <ski> > (^2) . [0 .. 9]
16:06:30 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
16:06:30 * hackagebot biophd 0.0.5 - Library for reading phd sequence files (DanFornika)
16:06:30 <noteventime> Peaker: How far do you think one could reasonable take it as a language independent framework? Or would it just reduce to a somewhat fancy version control system?
16:06:38 <copumpkin> o.O
16:06:39 <ski> > (^2) .: [Just 0,Nothing,Just 2]
16:06:41 <copumpkin> what happened there?
16:06:41 <lambdabot>   [Just 0,Nothing,Just 4]
16:07:06 <matthiasgorgens> monochrom: sounds like the students aren't pedantic enough?
16:07:10 <ski> copumpkin : presumably race condition with someone else MSGing lambdabot a `run' command
16:07:14 <copumpkin> lol
16:07:16 <matthiasgorgens> monochrom: or shall I say, exacting.
16:07:18 <Peaker> noteventime, Language independence would mean less interesting code editing features.. For example, we offer on-the-fly type-inference, giving you immediate feedback on your type errors
16:07:33 <Peaker> noteventime, and we intend to also execute the code on example inputs as you edit it, perhaps visualizing it as a 2d graph when possible
16:07:46 <monochrom> students do not know that it's important to be exacting for this
16:08:07 <Peaker> noteventime, and every time you fill "holes" in the structure -- the completions/search will be type-aware... i.e: a *lot* of stuff gain usefulness from the language-specificness
16:08:31 <matthiasgorgens> monochrom: they should go and do some c programming, where everything just blows apart if you aren't exacting.  with all these fancy Haskell compilers, people have it to easy these days.
16:08:45 <monochrom> they do not know because we do not convince them why, and/or our notation doesn't encourage them to be
16:09:14 <Peaker> noteventime, whether an agnostic editor that has far less features could still be nicer than text editing, I'm not sure, but it's possible
16:10:01 <matthiasgorgens> monochrom: I guess S-Expressions or RPN notation would make that more obvious.
16:10:08 <ski> matthiasgorgens : (on starting to count at zero) "... The above has been triggered by a recent incident, when, in an emotional outburst, one of my mathematical colleagues at the University —not a computing scientist— accused a number of younger computing scientists of \"pedantry\" because —as they do by habit— they started numbering at zero. He took consciously adopting the most sensible convention as a provocation. ..." in "Why number
16:10:13 <monochrom> I know that c programming has not changed students to become more exacting, either
16:10:37 <ski> hm, i suspect that got cut off near "... in \"Why numbering should start at zero\" by Edsger Wybe Dijkstra in 1982-08-11 at <http://www.cs.utexas.edu/~EWD/transcriptions/EWD08xx/EWD831.html>"
16:10:53 <matthiasgorgens> monochrom: yeah, the ones who are already exacting, aren't changed.  and the un-exacting types, just get frustrated, I'd guess.
16:11:24 <matthiasgorgens> ski: I know some mathematicians who always start counting at -1 when computer scientists are around, just to annoy the schmucks.
16:11:32 <Peaker> lispy, yeah, that's more reason to stick to Haskell for now.. familiar ground
16:11:33 <noteventime> Peaker: Very interesting, just the notion of not, essentially, moving up and down lists of things seems like it could be very liberating. I hope something comes out of it :)
16:11:46 <Peaker> noteventime, you can play with a prototype now :)
16:11:59 <monochrom> c programming at most convinces students that computing is black magic
16:12:11 <ski> matthiasgorgens :)
16:12:17 <irene-knapp> it isn't?
16:13:03 <monochrom> i.e., you get somtimes segfaults and you don't know why, and it doesn't always happens, and all you know is that Dennis Ritchie's programs don't segfault
16:13:22 <irene-knapp> well, sure
16:13:32 <noteventime> Peaker: I'll give it a try, just need to install a bunch of dependencies first
16:13:35 <matthiasgorgens> monochrom: my girl-friend is just working through K&R C.  At least that book isn't too bad.  (She used to have a C course at university before, but didn't understand anything..)
16:14:09 <matthiasgorgens> about black magic: I feel the same about Haskell performance, and battling with lazyness.
16:14:55 <edwardk> roconnor_: well, your efforts are much appreciated
16:14:55 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
16:15:10 <enigmuriatic> what do you use in pattern matching for a list containing two or more items?
16:15:21 <enigmuriatic> > 3 * 15
16:15:23 <lambdabot>   45
16:15:24 <latro`a_> (x:y:xs) or such
16:15:32 <Peaker> noteventime, I just noticed we pushed a bit of brokenness to master branch. Gonna debug that now :)
16:15:45 <enigmuriatic> ah thanks. so (x:xs) would be valid latro`a_?
16:16:03 <latro`a_> hm?
16:16:10 <latro`a_> (x:xs) only guarantees that there is at least one element
16:16:17 <enigmuriatic> ah i see
16:16:23 <noteventime> Peaker: Otherwise I'll just pull once in a while until it compiles :P
16:16:27 <latro`a_> (x:y:xs) guarantees there are at least two, etc.
16:16:37 <enigmuriatic> is that because of the one cons between that item and the []?
16:16:46 <enigmuriatic> makes sense
16:16:48 <ski> noteventime : in the meantime, there are pseudo-structural editing stuff in emacs, for sexprs with the `C-M-f',`C-M-b',`C-M-u',`C-M-d',`C-M-k',`C-M-SPC',`C-M-q' commands, and also `paredit.el' at <http://mumble.net/~campbell/darcs/paredit/paredit.(html|el)>
16:16:51 <Peaker> noteventime, :)
16:16:51 <latro`a_> um, maybe it will help if you insert the parens
16:17:00 <latro`a_> (x:y:xs) is (x:(y:xs))
16:17:09 <latro`a_> because of the associativity of :
16:17:35 <enigmuriatic> I'm saying that [x] is technically x:[ ], so i was just realizing that that's why there's two cons in a two item list
16:17:43 <latro`a_> ah
16:17:43 <matthiasgorgens> copumpkin: sequence .: sequence has the wrong semantics..
16:17:44 <latro`a_> yes
16:17:45 <latro`a_> correct
16:17:48 <noteventime> ski: I won't pretend I write a lot of sexprs though :)
16:17:55 <enigmuriatic> by the way, does anyone make 2D games in haskell experimentally? it seems like a fun way to learn the language
16:18:09 <ski> enigmuriatic : note that the pattern itself really only needs to be `x0:x1:xs' -- the only reason for the wrapping brackets is because `foo x0:x1:xs = ...' will be parsed as `(foo x0):x1:xs = ...'
16:18:17 <latro`a_> I saw an experimental roguelike thing
16:18:18 <matthiasgorgens> copumpkin: sequence .: sequence works more like the reader monad, but I want  Maybe Monads behaviour.
16:18:22 <noteventime> enigmuriatic: Check out Gloss
16:18:22 <latro`a_> that you can probably google
16:18:28 <hpc> enigmuriatic: search for monadius
16:18:29 <ski> noteventime : iirc, there's some support for xexprs, as well (XML,SGML,HTML)
16:18:30 <matthiasgorgens> copumpkin: (context: my question from earlier.)
16:18:36 <lispy> enigmuriatic: I have in interest in writing games in haskell, but since I do it in my spare time I've never finished one.
16:18:38 <hpc> enigmuriatic: it's not a fun way to learn the language though
16:18:48 <lispy> enigmuriatic: #haskell-game is a good channel
16:18:58 <hpc> it's a fun way to use the language once you have learned enough of it to be comfortable
16:19:07 <hpc> oh, that reminds me
16:19:11 <ski> (maybe i'm confusing that with some other pseudo-structural editing mode for xexprs, i'm not sure)
16:19:14 <hpc> /join #haskell-game
16:19:22 <copumpkin> matthiasgorgens: so I guess it wasn't so obvious ;)
16:19:32 <enigmuriatic> lispy: why don't you find it fun?
16:19:38 <matthiasgorgens> I made my C writing co-workers recoil in horror today with https://github.com/matthiasgoergens/stripComments/blob/master/stripComments.c Haskellers might like it, and actually view it as the only sane style to write this small parser in C.
16:19:52 <lispy> enigmuriatic: I find it fun. Did you mean to ask hpc?
16:20:10 <enigmuriatic> yeah, that was directed at hpc
16:20:51 <lispy> enigmuriatic: all the example code I have game-related is opengl stuff.
16:20:53 <Peaker> matthiasgorgens, my first reaction was "ick!", my second reaction was "Hmm.. nice" :)
16:21:14 <lispy> enigmuriatic: see for example: https://github.com/dagit/nehe-tuts
16:21:21 <hpc> enigmuriatic: there's too much extraneous complexity in making a game
16:21:21 <ski> enigmuriatic : however, if you're using `case', you don't need the brackets :
16:21:28 <ski> > case "Hello" of x0:x1:xs -> concat ["x0 = ",show x0,",x1 = ",show x1,",xs =",show xs]; x:[] -> concat ["x = ",show x]; [] -> "Empty list"
16:21:28 <hpc> you end up learning game development instead of haskell
16:21:29 <lambdabot>   "x0 = 'H',x1 = 'e',xs =\"llo\""
16:21:36 <Peaker> matthiasgorgens, maintaining the } when they're on the end of the last line in block may be annoying, probably
16:21:59 <ski> noteventime : have you tried any Agda(2) ?
16:22:14 <lispy> enigmuriatic: I also have a simple raytracer. I've actually been thinking about trying to get the ray tracer to do 30-60 fps and see if I could make a game using it.
16:22:19 <noteventime> ski: Just very little, did some Coq for a while
16:22:38 <noteventime> Though only as a theorem prover
16:23:29 <ski> noteventime : the Alfa structural proof editor for Agda1 isn't bad for a structural editor
16:23:32 <ski> @where Alfa
16:23:33 <lambdabot> Proof editor, using Agda1 proof engine/checker, at <http://www.cse.chalmers.se/~hallgren/Alfa/>,(broken) <http://www.cs.chalmers.se/~hallgren/untested>,<http://ogi.altocumulus.org/~hallgren/untested>
16:23:33 <lambdabot> ,<http://ogi.altocumulus.org/~hallgren/untested/for_Linux/alfa-041029-bin-i386-Linux-RedHat9.tar.gz>,<http://ogi.altocumulus.org/~hallgren/untested/Source_code/alfa-050126.src.tar.gz>. Also see `
16:23:33 <lambdabot> Agda',`Fudgets',`GF'
16:23:47 <ski> noteventime : <http://img220.imageshack.us/img220/9348/proofpg.png>,<http://img812.imageshack.us/img812/3056/proof2cropped.png> are two screenshots of it
16:24:16 <Eduard_Munteanu> I wonder if Agda1 is alive anymore.
16:24:17 <lispy> Just occured to me: With mathematics as the ideas becomes more sophisticated, it becomes easier to express things and apply it. With programming, as it becomes more sophisticated it's harder to modify your code :)
16:24:57 <ski> Eduard_Munteanu : well, that Alfa binary link (includes the Agda1 engine) above works here -- however i don't think it's developed
16:25:07 <ski> (people jumped to Agda2 instead)
16:25:22 <noteventime> ski: Are those natural-deduction style trees representation (basically) parse trees?
16:25:30 <noteventime> Or where do they come from?
16:26:13 <noteventime> lispy: Not always, in either direction :P
16:26:26 <ski> noteventime : the ND is a style in which you can write proofs, you can also display them more like in Agda2, and also in a "tall" (rather than "wide") view
16:26:50 <ski> noteventime : in any case, you manipulate expressions in that editor, not plain text (though there's an escape "edit as plain text" as well)
16:27:12 <noteventime> Interesting, horrible font though :P
16:27:15 <matthiasgorgens> Peaker: The } are where they are to optimize readability, not write-ability.
16:27:42 <ski> noteventime : usually, you place point at a "hole", then select a construct/operation to fill it with, either by clicking in the other window (context-sensitive, filtered by what type-checks), or by typing the (auto-computed) abbreviations shown in that window
16:27:44 <Peaker> matthiasgorgens, Yeah, maybe a C preprocessor can add {} from layout
16:27:47 <matthiasgorgens> lispy: that's because mathematicians cheat their notation.
16:27:49 <Peaker> matthiasgorgens, to optimize both
16:28:31 <ski> noteventime : if the construct requires parts, or the operation is a function, one or more sub-holes will automatically be created
16:28:33 <matthiasgorgens> Peaker: yeah.  I treat the {} as messages to my editor.
16:28:41 <matthiasgorgens> Peaker: so that it knows how to indent.
16:28:48 <noteventime> ski: That's basically like agda2's editor though, no+
16:29:02 <matthiasgorgens> I then check if the automatic indentation matches my ideas of what the code should be.
16:29:05 <noteventime> By that I mean agda2's haskell mode
16:29:37 <noteventime> err, emacs-mode
16:31:15 <ski> noteventime : yes, though you'll have to do `C-c C-r' manually
16:31:54 <ski> (or write `?'s, and do `C-c C-SPC')
16:32:23 <noteventime> I wish I could do that on paper too :P
16:32:52 <ski> anyway, i think Alfa is quite nice
16:33:16 <noteventime> It looks quite cool, but agda1...?
16:33:49 <ski> (of course there's some things which could be nicer : e.g. one would like to be able to mark an expression, except a marked subexpression, copying/cutting a "context", which can then be inserted around any other subexpression -- transposing such contexts would also be handy)
16:34:15 <ski> (also, i want a tree- (or graph-) shaped history, not a linear one !)
16:34:38 <Peaker> ski, there's undo-tree.el which is very nice
16:35:01 <ski> Peaker : i should get around to trying that one
16:35:16 <ski> Peaker : iiuc, you're planning to have some kind of support this this kind of thing in bottle ?
16:36:23 <ski> (pipeline-error, s/this this/for this/)
16:38:33 <Peaker> ski, yeah, bottle's history already forms a graph
16:38:44 <Peaker> ski, but we haven't yet implemented a visualization of that graph
16:38:54 <ski> and you have some way to navigate this ?
16:38:56 <Peaker> ski, but you can make ptrs to points in the graph (branches) and switch between them
16:39:01 <Peaker> (no merges yet, though)
16:39:28 <ski> Peaker : well, if two edits are independent, one should be able to commute them, at the very least
16:39:29 <Peaker> it's not very useful yet, since clipboard/etc is internal to the current branch/view
16:39:57 <Peaker> ski, yeah, the version control problem is very important and interesting, but we'll tackle it only once we're done with the UI/language stuff
16:39:58 <noteventime> What's the relation between undo/redo and versioning, in your case?
16:40:04 <ski> (i.e. discovering that some changes in one part were bad, but other changes in other part made since is still good)
16:40:16 <Peaker> noteventime, The undo/redo buffer is persistent and forms the version control (no heuristic guessing of what changed)
16:40:40 <Peaker> ski, yeah, we love rebase -i, so we need to offer that kind of power (in a saner way, probably)
16:40:53 <Peaker> ski, just can't tackle too many problems at once so we're postponing version control..
16:41:04 <ski> Peaker : sure, i understand
16:43:03 <Nereid> I should have a look at some good examples of actual applications written in haskell.
16:43:05 <Peaker> noteventime, there's no "save" button, everything is committed to the database directly
16:43:29 <noteventime> Peaker: So it's a little like smalltalk, in that sense?
16:43:36 <noteventime> Or at least, squeak
16:43:49 <Peaker> noteventime, Not sure what squeak had in relation to version control
16:44:15 <noteventime> I seem to remember them doing something a little similar to that
16:44:29 <noteventime> I never was much into smalltalk though, so don't take my work for it
16:44:46 <ski> in Squeak you at least is modifying the running system
16:44:51 <ski> and there's no files, per se
16:45:27 <ski> (but there may have been a "commit" button for the window pane showing the code of a method, i'm not sure)
16:47:03 <noteventime> Peaker: So will you rely on something akin to tagging to get a notion of "reasonable state of the codebase", or will you forgo such things entirely?
16:47:28 <j_tillman> are there any non-trivial STM data structures in haskell? i use the STM TVar, TQueue, TChan and so on, but are there STM maps data structures, for example?
16:48:09 <enigmuriatic> a_to_b :: ((fst a) - (fst b)) * ((snd a) - (snd b)) / 2
16:48:09 <MostAwesomeDude> j_tillman: I'm pretty sure that you can do Map SomeKeyType TVar.
16:48:28 <monochrom> I think STM map is counterproductive
16:48:35 <enigmuriatic> what about that isn't a valid expression in a type constructor?
16:48:54 <noteventime> Enigmagic: Aren't you trying to devide a type by 2?
16:49:03 <noteventime> err enigmuriatic
16:49:11 <noteventime> I need to fix erc tab completion
16:49:31 <Peaker> noteventime, yeah, tagging
16:49:38 <noteventime> As far as I know Haskell doesn't have quotient types :P
16:49:52 <Peaker> noteventime, tagging with name becomes like "save" except it preserves history relationships
16:50:08 <monochrom> replace :: by =
16:50:11 * geekosaur is assuming it's related to the new type level naturals since otherwise it's completely wtf...
16:50:28 <enigmuriatic> oh right thanks
16:50:31 <j_tillman> MostAwesomeDude: yeah I can, but then I can only modify an existing member of the map. i'd like to do transactional adds, removes and so on
16:50:47 <Peaker> noteventime, I just pushed some minor reverts/fixes to make the factorial example reasonable to write in bottle
16:50:58 <Enigmagic> j_tillman: TVar (Map k v) ?
16:51:00 <j_tillman> monochrom: thanks, can you elaborate on that? what would you use instead?
16:51:03 <Enigmagic> i use that frequently
16:51:43 <irene-knapp> okay, so does anybody have experience with conduits?
16:51:50 <j_tillman> Enigmagic: but that's a single transactional variable. you might as well use an mvar for that. i'd like to modify different parts of the map, and have them proceed without conflict if they don't touch the same parts of the map, which is what stm is really great for
16:52:00 <monochrom> I use simply "TVar (Map k v)"
16:52:05 <noteventime> Peaker: I suspect I'm missing some font, because I just get a black screen with some random colours and a bunch of null pointer to ftgl warnings
16:52:23 <Enigmagic> j_tillman: not if you want to touch other TVars/TChans/etc in the same transaction.
16:52:24 <Peaker> noteventime, though to do so, you have to know that (currently) type variable instantiations are explicit, so in bottle it's currently defined something like:  fac (x : <hole>) = if <hole> [x == 0] 1 [x * fac [x - 1]]    (the <hole> for type of x and type variable of "if" are inferred automatically from the rest as you go along)
16:52:29 <irene-knapp> what I'm trying to do is have a pipeline of them that has a side-along stream of error messages, in addition to the main stream which goes from bytes to texts to characters to tokens to low-AST to high-AST
16:52:45 <Enigmagic> j_tillman: either way, the Map/HashMap structure won't touch the bulk of the map even without a TVar.
16:52:57 <irene-knapp> I wrote a function split :: :: (Monad m) => Sink a m ra -> Sink b m rb -> Sink (Either a b) m (ra, rb)
16:53:03 <Peaker> noteventime, if you install ftgl from https://github.com/Peaker/ftgl  you will get proper errors instead of null ptrs
16:53:15 <irene-knapp> which lets me treat the errors separately from the results at the very end of the pipeline
16:53:23 <j_tillman> Enigmagic: but if i do that, any two concurrent access to the map will cause a conflict. i'd like to not cause a conflict, and so increase parallelism, where the keys are distinct
16:53:27 <Peaker> noteventime, "/usr/share/fonts/truetype/ttf-dejavu/DejaVuSans.ttf" is the filename I currently use.. later we just need to distribute a ttf file with bottle
16:53:30 <irene-knapp> it consumes the entire pipeline in the process of doing that, which is necessary if you think about the control structure
16:53:32 <Peaker> noteventime, Main.hs hard-codes a font name
16:53:50 <irene-knapp> but what I can't figure out how to do (so I am soliciting alternate approaches) is write functions
16:54:08 <enigmuriatic> is there any easy way to return a possible Flaot/Fractional Int in a function that's built into a type declaration?
16:54:20 <irene-knapp> toLeft :: (Monad m) => Conduit a m a' -> Conduit (Either a b) m (Either a' b)
16:54:20 <enigmuriatic> I'm getting the error message No instance for (Fractional Int)
16:54:23 <irene-knapp> and similarly for toRight
16:54:42 <irene-knapp> this would be easy if I only wanted to map a pure function over them, right
16:55:05 <irene-knapp> but what I want to do is of course have it not interfere with the demand-based semantics of the conduit
16:55:06 <monochrom> my "TVar (Map k v)" maximizes parallelism and has provably zero race conditions
16:55:28 <irene-knapp> nobody? :(
16:55:31 <Enigmagic> j_tillman: what do you mean conflict? top level TVar usage won't cause many (if any) retries since all that is happening is a thunk allocation
16:55:33 <Peaker> monochrom, if there's no need for atomicity across any other variable, then IORef with atomicModifyIORef will probably be faster
16:55:37 <monochrom> and satisfies all those "atomic" "serializable" safety conditions
16:55:44 <monochrom> yes, that too
16:55:49 <irene-knapp> oh well.  ping me by nick if you see this in scrollback and want to comment; I'll be in another window.
16:56:14 <noteventime> Peaker: A symlink fixed it :)
16:56:30 <Peaker> noteventime, note we chose a specific font that has support for an arrow glyph we use, but that's less important
16:56:31 * hackagebot egison 2.3.5 - An Interpreter for the Programming Language Egison (SatoshiEgi)
16:56:33 * hackagebot egison 2.3.6 - An Interpreter for the Programming Language Egison (SatoshiEgi)
16:57:42 <j_tillman> Peaker: thanks, but the problem is that I have lets say a large hash table. i have lots of threads accessing it through transactions. if i use a single top level TVar, then any concurrent update to the TVar will conflict. if the map used TVars all the way down (in the same way that most C, word-based STMs implicitly do), then if two updates use different buckets they can proceed at the same time
16:58:06 <Peaker> noteventime, so it runs?  press <enter> on "foo" to rename it to "fac", then <space> to add param, "x". Under "x" you see its type, you can leave it as a hole or annotate it. Press right to go to body, then you can type: "if", <space>, <space>(leave explicit type-var param to if), [, ==, ...
16:58:08 <monochrom> use a large hashmap, not a large hash table
16:58:12 <enigmuriatic> what's the best way to deal with a function in which two Ints are being passed in, and either one Int or one Float is being returned?
16:58:23 <monochrom> and so, TVar (Hashmap k v)
16:58:24 <Peaker> noteventime, (infix support is currently bad, as things are in flux, you have to write it as though it was prefix)
16:59:04 <Peaker> j_tillman, using a TVar to point to an immutable hash table would be a performance catastrophe in any case
16:59:10 <j_tillman> monochrom: but for any n threads, only 1 can modify the TVar concurrently. if each bucket in a hash table were a TVar, any n distinct buckets can be updated in parallel
16:59:11 <noteventime> Peaker: Yep, runs, already started fiddling with it. Feels like Johnny Mnemonic :P
16:59:27 <Peaker> noteventime, remember it's very preliminary, but it already shows some useful characteristics
16:59:30 <monochrom> not hash table. hashmap. pure data structure
16:59:36 <j_tillman> Peaker: yeah, exactly! so a data structure that used TVars internally, and so each bucket can be updated individually would be better
17:00:02 <noteventime> Peaker: I didn't mean that in a bad way :D The large fonts are somewhat confusing though
17:00:14 <j_tillman> monochrom: but if it's shared and i want to mutate it, using TVars internally, a hash table would be a valid implementation technique
17:00:14 <Peaker> noteventime, you can zoom with ctrl-minus/plus
17:00:17 <enigmuriatic> can anyone help me out? should be a simple problem to solve
17:00:37 <noteventime> Hmm, looks like it died on me
17:00:44 <Peaker> noteventime, how?
17:00:53 <noteventime> Everything turned black
17:01:04 <monochrom> hash table sounds very nice to many people. in practice no one bothers to do it in haskell. yet.
17:01:08 <Peaker> noteventime, #haskell-blah ?
17:01:18 <Peaker> monochrom, I do it :)
17:01:25 <Peaker> (though it's a toy, mostly)
17:01:36 <j_tillman> Peaker: do you have an STM hash table implementation I could use?
17:01:52 <Peaker> j_tillman, no, I have a hash-table-over-file in IO
17:01:59 <dmwit> All of these regex libraries are specialized to String (or Text or ByteString). =/
17:02:03 <Peaker> for a toy persistent key/value store in pure Haskell
17:02:15 <monochrom> but this has great potential for the XY Problem. must you use a hash table?
17:03:04 <j_tillman> monochrom: no, i just need a map data structure. if i use an immutable one in a TVar then concurrency is very much restricted. Most STM maps use a hash table with effectively a TVar per bucket
17:03:45 <monochrom> with map or hashmap ("immutable" data structures), atomically (do {m <- readTVar x; writeTVar x (insert m blah)}) spends O(1) in the critical section. I am not kidding. think why.
17:04:36 <monochrom> this feature is unavailable in most other languages
17:05:02 <Peaker> it is based on the thread safety of thunks, though, which arguably costs O(N) elsewhere
17:05:19 <Peaker> (though it is a cheap cost, because of purity allowing a race in thunk access)
17:05:20 <j_tillman> monochrom: yes, that's true, it's O(1). and only one thread can be in that critical section (lets such a global lock model of STM semantics for simplicity). that limits parallelism. ideally i'd like lots of little critical sections, such as one per bucket, so that there is much more avaialable parallelism
17:06:08 <Peaker> monochrom, you'd get some serialization from multiple threads blocking on a black hole, potentially
17:07:24 <monochrom> O(1) critical section = little critical section
17:07:28 <mm_freak> j_tillman: i think you may be confusing concurrency with parallelism here…  there is nothing that stops the actual computation to be carried out in parallel
17:07:50 <mm_freak> the STM computation really just changes a pointer in actual code
17:08:14 <mm_freak> haskell is very unique in that regard
17:08:15 <monochrom> yeah, that's why I can say O(1)
17:08:27 <monochrom> and unavailable in most languages
17:08:29 <Peaker> you can implement the same kind of trickery in other languages, it'd just be harder
17:08:50 <monochrom> right, well, unavailable out of the box
17:09:03 <monochrom> "atomicity not included"
17:09:04 <mm_freak> Peaker: in other languages you have to make dangerous assumptions, and they will bite you sooner or later…  i think haskell is the only language that gets along without such assumptions
17:09:22 <Peaker> mm_freak, Haskell guarantees those assumptions
17:09:33 <Peaker> (that in other languages you have to work harder to get)
17:09:43 <mm_freak> that's what i meant, yes
17:10:13 <mm_freak> i think STM doesn't work well in other languages…  either it's very restricted or performance suffers seriously
17:10:41 <mm_freak> at least in strict, side-effectful languages
17:10:53 <Peaker> oh, I was talking about the thunk trick for O(1) critical section, not STM
17:10:53 <j_tillman> mm_freak: i'm not sure the performance numbers of STM are different in haskell comapred to other languages. if you have some citations to show that i'd be interested to see them.
17:11:21 <hpc> very few other languages even have STM
17:11:48 <monochrom> if there are performance comparisons, they could be misleading and lying, too
17:11:51 <j_tillman> hpc: i've used implemenations in scala, clojure, c, c++, java and python
17:11:54 <mm_freak> j_tillman: i'm sorry, but it's really just personal experience and some understanding of how STM in haskell is actually implemented…  in fact, when you use STM only with isolated transactions, the performance is really the same as using regular constructs like MVar
17:12:17 <monochrom> "let's compare haskell STM hash table with XXX hash table" is a stupid comparison
17:12:36 <j_tillman> monochrom: i didn't say that it was a good comparison
17:12:50 <monochrom> "let's compare haskell TVar (Hashmap k v) with XXX hash table" is a more reasonable comparison IMO
17:12:55 <j_tillman> mm_freak: but mvars aren't composable are they?
17:13:05 <mm_freak> j_tillman: the point is that parallelism isn't even the point of STM, but can be achieved easily if you need it
17:13:07 <Enigmagic> j_tillman: here's an old paper: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/lock-free-flops06.pdf
17:13:30 <mm_freak> j_tillman: MVar actions are IO actions, so they are composable in the IO sense, but a composition isn't atomic
17:14:02 <j_tillman> Enigmagic: yeah, i know that one, and in that they implement a queue using TVars internally. that's now available in STM 2.4. i'm asking about maps using TVars internally, which isn't a massive leap to make
17:14:27 <mm_freak> however, you can use an MVar like a safe multi-threaded mutable variable…  start with a filled MVar and always use modifyMVar
17:14:34 <mm_freak> this gives you at least atomicity of updates
17:14:54 <j_tillman> using a single TVar for the whole map, is like using a single global lock on the whole map, rather than allowing for finer grained transactions within the map
17:15:06 <mm_freak> also there is really nothing wrong with Map K (TVar X)
17:15:12 <monochrom> unlike. my point is not sinking in
17:15:39 <Enigmagic> j_tillman: what app are you trying to fix? i use the STM extensively with Maps/HashMaps/etc and haven't found it to be slow enough to bother looking at
17:16:02 <j_tillman> mm_freak: there is, that doesn't allow you to add or remove from the map, in a transaction. it just allows you to store TVars within a map. with Map K (TVar X) i can't both add and remove in a single transaction
17:16:25 <mm_freak> j_tillman: why not?
17:16:40 <monochrom> "insert m blah" takes logarithmic time. atomically (do {m <- readTVar x; writeTVar x (insert m blah)}) does not hold the lock for logarithmic time. think why.
17:17:06 <dmwit> Presumably mm_freak means TVar (Map k (TVar x)). But understanding monochrom's point is an important first step before deciding.
17:17:16 <monochrom> the map update is completely outside the transaction
17:18:09 <dmwit> (Especially understanding this: who *does* pay the logarithmic cost, finally?)
17:18:17 <mm_freak> i think it pays off to understand haskell first, before understanding haskell STM
17:19:24 <monochrom> in fact, change my code to use MVar instead. same conclusion. O(1) time holding lock.
17:19:42 <dmwit> BUT STM IS BETAR
17:20:09 <monochrom> or atomicallymodifyIORef. same lock same O(1) conclusion
17:20:18 <shirt> this is something i've been thinking of... it seems to me that whenever you store a value in an IORef or a TVar, you almost always want to store it strictly. this rule of thumb seems to help avoid space leaks
17:20:22 <monochrom> but yes I still go for STM because it sounds cooler :)
17:20:32 <enigmuriatic> when defining a function in a type constructor, how do you reference the variable being passed as a whole?
17:21:00 <dmwit> "defining a function in a type constructor"?
17:21:15 <Enigmagic> shirt: if you look at packages like monad-par you'll see that they require NFData instances for most operations for this very reason.
17:21:25 <monochrom> do not define a function in a type constructor. just don't. please.
17:21:46 <shirt> Enigmagic: so my intuition is correct?
17:21:47 <dmwit> What does that even mean?
17:21:47 <applicative> enigmuriatic: say more what you mean?
17:21:55 <dzhus> is it possible to set state hack on and off on per-source file basis?
17:22:21 <Enigmagic> shirt: for data parallelism yeah. not much use in having a bunch of worker threads out there allocating thunks instead of doing work
17:22:27 <monochrom> no, your intuition is not correct. the decision has nothing to do with IORef or TVar or not using either
17:22:46 <hpaste> enigmuriatic pasted “rectangles” at http://hpaste.org/72042
17:23:06 <monochrom> you evaluate earlier iff the data structure is not meant to be lazy. that is the only condition.
17:23:12 <enigmuriatic> should be pretty self-explanatory code, everything works excepting the parameter function
17:23:12 <shirt> monochrom: it just seems to me that for most of the use cases of IORef/TVar, laziness doesn't seem to add any advantages
17:23:18 <mm_freak> shirt: absolutely not…  i almost never force values in TVars or MVars
17:23:27 <dmwit> enigmuriatic: parameter r = 2 * width r + 2 * height r
17:23:39 <enigmuriatic> ah thanks dmwit
17:23:42 <dmwit> or name it something longer, like rect or even rectangle
17:23:44 <monochrom> it has nothing to do with IORef. look at foldl (+). same deal
17:24:15 <dmwit> Rectangly is a deceptive name for this data type, though.
17:24:20 <dmwit> Perhaps quadrangle would be better?
17:24:21 <monochrom> you're wrongly attributing to IORef and TVar because you have only been storing non-lazy data there
17:24:44 <monochrom> or maybe more precisely not-meant-to-be-lazy data
17:24:54 <enigmuriatic> and "parameter" is supposed to be "perimeter", lol
17:25:05 <monochrom> I mean, maybe you put a list there but you don't intend it to be a lazy infinite list or something
17:25:38 <monochrom> in fact, I have just been reiterating on an STM example where I do not want a hashmap evaluated early
17:26:08 <dmwit> It would be okay to evaluate it early, so long as "early" still means "outside the transaction".
17:26:26 <monochrom> atomically (do {m <- readTVar x; writeTVar x (insert m blah)} --- you do not want to "strictify" the insert inside
17:26:37 <monochrom> yeah
17:26:58 <dmwit> let m' = insert m blah in m' `seq` atomically (...)
17:27:30 <monochrom> atomically (do {m <- readTVar x; let m' = insert m blah; writeTVar x m'; return m'}) ; now evaluate m'
17:27:32 <shirt> monochrom: why not strictify it? the transaction will take longer but so what?
17:27:47 <mm_freak> shirt: simple:  in many cases you simply don't want that
17:27:59 <mm_freak> shirt: TVar [RandomNumber]
17:28:06 <monochrom> the transaction will take longer, so j_tillman will win the argument
17:28:11 <applicative> enigmuriatic: note that you can pattern match in the definitions of height and width, not  that it matters,  height (Rectangle (a,a') (b,b') _ _) = b' - a'
17:28:35 <dmwit> j_tillman is long gone anyway.
17:28:37 <monochrom> he loses the argument iff the transaction is O(1) both theoretically and practically
17:28:39 <applicative> then you avoid using snd , and similarly fst in the definition of width
17:28:53 <mm_freak> shirt: also in most cases there is really no reason to force…  the querying thread will force anyway, and often you have many of them, so you get parallelism for free
17:29:04 <enigmuriatic> thanks applicative
17:29:34 <monochrom> force evaluation, sure, but do it outside the bloody critical section. critical sections are not for wasting time
17:29:55 <monochrom> God what has this world come to?
17:30:11 <hpc> hah
17:30:12 <shirt> mm_freak: but if you do a long series of such updates, without any other threads reading, then you end up building a giant thunk that will drain all your memory until it is eventually evaluated and the whole program will stall
17:30:13 <monochrom> someone wants a short critical section and someone else wants a long critical section
17:30:43 <monochrom> and they're just 5 minutes apart or something. in the same channel.
17:30:53 <shirt> monochrom: i thought the whole point of the transaction system was that critical sections won't bother each other unless they touch the same variables, in which case you lose anyway
17:31:30 <monochrom> it reminds me of a friend submitting a paper and receiving conflicting reviews. yes conflicting. one reviewer says "not enough detail". another says "too much detail"
17:32:16 <shirt> monochrom: like all things it depends on the situation
17:32:32 <dmwit> monochrom: Hell, I've given that advice in my own reviews.
17:32:34 <shirt> it's just in my experience it almost always seems like i want to store strict values in mutable variables
17:32:35 <hpc> shirt: you still want to get one critical section over with quickly, so the other one can come in without conflict
17:32:40 <dmwit> "Flesh this out or delete it, your choice."
17:32:41 <monochrom> that is not the whole point. that is just one point, how to increase parallelism
17:32:44 <hpc> there's no lining up for the rollercoaster, so to speak
17:33:06 <monochrom> another point is you can mutate two variables consistently
17:33:13 <shirt> hpc: yes, i imagine if two threads want to concurrently update the TVar, then lazy evaluation will prevent unnecessary cpu work
17:33:24 <ddarius> dmwit: You want Haskerl (re you regex comment above.)
17:33:45 <mm_freak> shirt: even if you do want to force along with the update, do it before or after the transaction
17:33:53 <mm_freak> forcing in an STM transaction is stupid at best
17:33:58 <monochrom> there was only one paper, submitted to only one journal. there was only one situation.
17:34:10 <mm_freak> so there is no way the STM actions can do that for you
17:34:33 <monochrom> and yes let me be clear. the conflicting "not enough" and "too much" refer to the same part of the paper
17:34:56 <monochrom> only one paper, only one part referred to, only one journal. how many situations can there be?
17:35:07 <dmwit> ddarius: The half-finished project to compile Haskell to Erlang's VM?
17:35:19 * shapr hugs ddarius
17:35:19 <dmwit> ddarius: (I don't see anything by that name on Hackage, and Google turns up only unrelated things.)
17:35:19 <ddarius> dmwit: No.
17:35:23 <shapr> ddarius: long time no see!
17:35:30 <shirt> how about this? You have a TVar containing a counter. one thread increments the counter every second. another thread periodically reads the counter. here you definitely want to store the value strictly, otherwise you end up with a huge (1+1+1+1+1...) thunk that builds up until the counter is read from
17:35:38 <ddarius> @where haskerl
17:35:39 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
17:36:07 <ousado> monochrom: different persons, different perspectives, different preferences, that's a good thing, isn't it?
17:36:15 <monochrom> there you go, TVar containing a counter. counter is not meant to be lazy or postponed or deferred or whatever
17:36:53 <monochrom> ousado, the journal editor is then supposed to notice it and make a ruling
17:37:10 <dmwit> ddarius: I file that under "unrelated things". It's a cute joke, though. =)
17:37:33 <ddarius> dmwit: Joke?
17:37:40 <ddarius> shapr: It's been a bit.
17:37:48 <shapr> ddarius: How's code and life?
17:38:17 <dmwit> Is it not a joke? It looks like a joke, doesn't have a link to an implementation, and was published on April 1.
17:38:27 <monochrom> if I have an accumulator parameter containing a counter, I would want to make it strict too. nothing to do with TVar or threads
17:38:33 <shirt> monochrom: right. i just find that (in my experience at least), most times when an IORef or TVar is used, it is used like this counter example, where you don't want to defer/laziness
17:38:35 <ddarius> dmwit: A lot of the ideas in that actually ended up in Haskell.
17:38:44 <ddarius> dmwit: For example, it preceded do-notation.
17:39:26 <monochrom> you just found that most times when you use IORef or TVar, you put rather simple data there
17:39:57 <ddarius> shapr: Life is more or less the same though I'm going to the west coast for a brief bit, duration depending on whether west coast Haskellers (or others) can make a case for me using my time off.
17:40:15 <ddarius> shapr: I bought a software-defined radio recently.
17:40:18 <JoeyA> Fortunately, STM 2.3+ has modifyTVar', a strict version of modifyTVar.
17:40:22 <dmwit> ddarius: That's cool and all, but doesn't help me solve my problem.
17:40:43 <shapr> ddarius: ooh, USRP or one of the tv-tuners?
17:40:43 <JoeyA> The next version of base will have strict versions of modifyIORef and modifySTRef, too.
17:40:48 <shirt> monochrom: i guess so. IORef or TVar are often used to store "state", and "state" is usually -- as you call it -- simple data
17:40:52 <ddarius> shapr: A beefier USRP.
17:41:01 <monochrom> but I guess, who am I, I am not amazon, I am not supposed to be telling you what you statistically do
17:41:16 <shapr> ddarius: Awesome, is it accessible from a shell account somewhere? :-)
17:41:17 <ddarius> shapr: If I get bored of doing radio stuff, I can program the FPGA.
17:41:19 <JoeyA> But watch out when that state is "statistics".
17:41:25 <monochrom> I am not getting paid to do that statistics anyway!
17:41:58 <ddarius> shapr: Right now it's not even plugged in.  Also, it's not an embedded one, so I'd need to host the shell on my computer... which actually is running a secure shell server.
17:41:59 <JoeyA> Statistics is, by definition, a bunch of calculations that tend to go unused.
17:42:40 <JoeyA> (at least you should assume that when looking for space leaks)
17:42:45 <monochrom> but you may also like: http://www.vex.net/~trebla/haskell/lazy.xhtml http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
17:42:49 <shapr> ddarius: If I get some spare time I'd love to play with it.
17:45:25 <mm_freak> shirt: undoubtedly you'll want to force somewhere, but (again) not inside the transaction, so the TVar operations can't do that for you
17:45:48 <mm_freak> force before or after the transaction
17:46:09 <mm_freak> in particular even if you would have forcing operations in STM, there is no way to get this right
17:46:20 <mm_freak> you can't rely on 'seq', but you also can't use NFData
17:46:36 <mm_freak> ultimately the author of the transaction has to do the forcing
17:46:37 <shirt> mm_freak: well, for a counter you can't force before(since you don't know the old value), so i guess forcing after the transaction is the way to go
17:47:25 <JoeyA> What's wrong with forcing inside a transaction (unless it's an expensive computation)?  Kills performance?
17:47:41 <monochrom> expensive computation is the only thing wrong
17:47:50 <mm_freak> JoeyA: makes the transaction take longer
17:48:07 <dmwit> I hereby define all computations not required to create the transaction to be "expensive".
17:48:15 <mm_freak> JoeyA: now think of retries
17:48:29 <shirt> let's say that instead of the counter incrementing by one, you want to increment it to the next prime number (and it starts out large)...
17:48:32 <monochrom> to much extent I don't mind forcing an Int in the transaction
17:48:36 <mm_freak> a value is almost computed, bam, another transaction makes it retry
17:48:40 <mm_freak> the computation time is lost
17:48:49 <JoeyA> Right.
17:48:52 <ddarius> Yes, if the values get unboxed, then manipulating them will be faster than making thunks.
17:49:12 <dmwit> monochrom: What if the computation behind that Int is to find an even number that isn't the sum of two primes?
17:49:30 <shirt> hey, that's what i just said! :P
17:49:33 <JoeyA> But shouldn't forcing the value in a transaction be fine even for Data.Map operations (assuming the comparison function isn't ridiculously expensive)?
17:49:34 <ddarius> mm_freak: I'd expect in many cases the entire work won't be lost.  If so, then it's a trivially small thing or your transaction is too large anyway.
17:49:38 <monochrom> ah, I was thinking of just adding 1
17:50:08 * dmwit nods agreeably
17:50:13 <JoeyA> Or does that depend on the use case (whether the application programmer needs high performance numbers or not) ?
17:50:15 <mm_freak> JoeyA: it's going to be a thunk anyway, so it's quite pointless to do it in the transaction
17:50:16 <dmwit> I knew pretty much what you meant, I was just making a joke. =P
17:50:36 <monochrom> haha ok!
17:51:19 <mm_freak> ddarius: if the work is shared somehow, it's not lost
17:51:32 <mm_freak> but i don't remember a single time where i had a shared variable in a transaction
18:16:44 <bob_> I am not sure if I hate or love Haskell
18:17:02 <bob_> I think I will go with both
18:18:32 <mm_freak> i hate it
18:18:37 <mm_freak> it ruined me for all other languages
18:18:47 <bob_> or made you better
18:19:03 <hpc> mm_freak: perhaps you hated all other languages the entire time
18:19:07 <bob_> it is so different
18:19:07 <hpc> and didn't realize it
18:19:12 <bob_> that's probably why I love it
18:19:40 <Dashkal> It made me see PHP for that it is...
18:19:48 <noteventime> hpc: Philosoraptor
18:20:12 <bob_> As a C/C++ programmer I love PHP
18:20:24 <bob_> in the first day with web servers, I wrote a complete program
18:20:37 <bob_> before that I knew only basic HTML haha
18:20:41 <noteventime> I didn't think "love" and "PHP" could be concatenated without including a negation
18:20:42 <Dashkal> PHP is an excercise in crashing.
18:20:52 <Dashkal> I like my programs to terminate properly
18:20:52 <Sgeo_> I'm currently playing with Tcl
18:21:12 <hpc> bob_: check out blaze-html
18:21:16 <bob_> I said as a C programmer I love PHP
18:21:20 <bob_> not as a person
18:21:26 <Dashkal> That and a function with the type String -> a -> b is utterly terriufying to me
18:21:32 <bob_> hpc: ok
18:21:43 <hpc> probably not in your first day, but you'll write a complete program, with html that you know is correct
18:21:54 <hpc> and your code will look like the html it generates
18:22:19 <Clint> as a C programmer I hate PHP
18:22:46 <noteventime> as a programmer I hate PHP (though I've been told it's possible to write good PHP)
18:22:48 <bob_> not enough (void*)malloc(sizeof()...
18:23:14 <bob_> I don't think it's possible to write good PHP, and I will never attempt it
18:23:20 <noteventime> I'm actually tempted to try PHP again, just as an exercise in self discipline
18:23:28 <bob_> but it is easy to write quickly
18:23:37 <Ralith> as a C programmer, why are you casting the return value of malloc to tye type it already has?
18:24:02 <otters> sure it's possible to write good PHP
18:24:09 <otters> it's possible to write good any language
18:24:14 <otters> also, why the hell are we talking about PHP in #haskell
18:24:25 <bob_> so I can do type *var = (type*) malloc
18:24:38 <bob_> stuff
18:24:44 <otters> not even gcc -Wall complains if you don't cast malloc
18:24:48 <noteventime> otters: Because everyone likes making fun of the stupid kid?
18:24:49 <otters> there's no reason to do it
18:24:55 <otters> noteventime: it's getting a little tiring, now...
18:25:27 <noteventime> To be fair though, it's not like there's a whole lot else going on here right now :)
18:25:34 <bob_> I was just saying that my PHP kinda looks like my C
18:25:41 <otters> well, it would
18:25:45 <bob_> on the other hand, my C++ is usually really organized
18:25:51 <bob_> and beatiful
18:25:56 <otters> my Haskell is the stuff of legend
18:26:58 <bob_> my Haskell is one line long and never compiles
18:27:19 <otters> my Haskell is many thousands of lines long and compiles about 8% of the time
18:27:23 <otters> but that's good; that's what the compiler is for
18:27:29 <dmwit> Hm, that's some confusing documentation.
18:27:40 <dmwit> class ShortcutExpander m => ShortcutExpander m
18:27:51 <otters> o_o
18:27:57 <noteventime> dmwit: Some kind of rewrite involved?
18:27:58 <otters> is that possible?
18:28:11 <otters> and isn't that a redundant class constraint
18:28:11 <shachaf> dmwit: Different modules?
18:28:13 <dmwit> In the source, one of them is a qualified name.
18:28:14 <dmwit> shachaf: yes
18:28:26 * shachaf wins the haddock award! Or something.
18:28:30 <shachaf> That's why I just read the source.
18:28:46 <Nereid> the worst is in stuff like
18:29:36 <Nereid> class C a => C a where ...
18:29:41 <Nereid> instance C T, C T, ...
18:29:45 <Nereid> numeric-prelude hi
18:30:08 <dmwit> Yes, but at least with that author he's very consistent.
18:30:12 <Nereid> :-)
18:30:22 <dmwit> T is the type, C is the class, and you *must* look at the qualified names to understand it.
18:30:35 <dmwit> This one was sort of out of left field. =P
18:30:45 <Nereid> yes but haddock doesn't produce things you can understand.
18:30:53 <dmwit> haddock--
18:31:17 <dmwit> Doing better than what haddock does now seems like a Hard Problem, though.
18:32:34 <Nereid> make it so you can give it an option to qualify all names under some module or something
18:33:20 <Nereid> or maybe specify that in the source
18:36:10 <mm_freak> it's impossible to write good PHP
18:36:25 <otters> nonsense!
18:36:40 <mm_freak> PHP code has the inevitable tendency to get unmaintainable over time, no matter how good you write it
18:36:50 <irene-knapp> agreed :(
18:36:55 * irene-knapp makes her money on PHP
18:37:17 <otters> I would totally make money on PHP
18:37:20 <otters> it's easy to write
18:37:37 <mm_freak> it isn't even easy to type, much less easy to write
18:37:47 <Nereid> PHP makes it easy to write terrible code
18:37:55 <sordina> mm_freak: I'd say that it's definitely not impossible to write good PHP, but PHP makes it very easy to write bad code.
18:38:07 <mm_freak> sordina: i view it the other way around
18:38:13 <mm_freak> PHP makes it very hard to write good code
18:38:25 <sordina> mm_freak: Agreed. But not impossible.
18:38:28 <Nereid> PHP makes it so that even if you think you're writing good code, it's actually terrible
18:38:28 <mm_freak> with all the inconsistency, the braindead semantics, etc.
18:38:43 <mm_freak> and again, the maintainability problem that you can't circumvent
18:38:46 <liyang> But for anything other than throw-away projects, you spend more time reading than writing.
18:38:47 <mm_freak> there is simply no way around it
18:38:59 <mm_freak> liyang: PHP code is also terrible to read
18:39:12 <otters> PHP makes it so for every line you write, a baby sparrow dies
18:39:34 <mm_freak> in any case, using PHP for a new project is a mistake
18:39:36 <mm_freak> unconditionally
18:39:52 <otters> now that I've invented stanley, it is always a bad choice
18:40:30 <sordina> There would be some cases where it may make sense to use it for a new project.
18:40:51 <irene-knapp> so the argument that seems to trump every other, in the circles where it's popular, is
18:40:52 <mm_freak> like what?
18:41:04 <mm_freak> irene-knapp: "it's easy to find programmers"
18:41:07 <irene-knapp> "We can hire someone who would otherwise work the counter at McDonald's to maintain your code."
18:41:07 <irene-knapp> yes
18:41:11 <noteventime> sordina: Was my initial reaction too, but then I couldn't think of any
18:41:20 <irene-knapp> when I advance it in that format they never actually agree with it, but they keep saying it :)
18:41:39 <mm_freak> irene-knapp: the fallacy is that on the bottom line you will have spent more time and money, even though you had programmers all the time
18:41:44 <irene-knapp> certainly
18:41:47 <sordina> Imagine that you have a company with a large and well-structured code base with large amounts of PHP framework for dealing with domain-specific business logic.
18:42:03 <irene-knapp> well
18:42:07 <Nereid> doesn't sound like a new project in that case
18:42:07 <mm_freak> sordina: that's not a new prject
18:42:10 <irene-knapp> part of the problem is that frameworks are fads, right
18:42:26 <otters> frameworks are hard compared to PHP
18:42:27 <irene-knapp> so whatever PHP codebase your current team bases their stuff on
18:42:40 <irene-knapp> in two years you will have had 100% staff turnover and nobody will understand the old crap at all
18:42:41 <sordina> You can certainly class something as a new project that uses existing code-frameworks.
18:42:58 <sordina> Not a greenfields project, but a new project.
18:43:03 <mm_freak> sordina: not if they include domain-specific business logic
18:43:19 <mm_freak> at least that's not the "new project" i meant
18:43:29 <mm_freak> i mean from scratch using publicly available utilities
18:43:39 <mm_freak> you should totally go for something other than PHP
18:43:52 <sordina> mm_freak: Ah I see.
18:44:03 <mm_freak> haskell is a good choice nowadays
18:44:38 <sordina> Don't get me wrong. I'd love to see the death of PHP and having it replaced with haskell would be a dream come true.
18:44:56 <mm_freak> we'd be rich =)
18:45:06 <sordina> But, it's not always a good idea to use a new language.
18:45:22 <mm_freak> it's a good idea in the case of PHP
18:45:26 <sordina> At least not in an undiciplined manner.
18:45:32 <noteventime> Is legacy code actally an excuse for using a legacy languge though? I'm wondering if you might not generally win in the long run by writing some semi-safe interface to the old PHP stuff instead
18:45:48 <irene-knapp> I personally advocate mechanical translation of code from PHP to /anything/ :D
18:45:55 <irene-knapp> freaking brainf*ck is more maintainable
18:46:01 <sordina> noteventime: Yes, it is a very good excuse if the code-base is in good condition.
18:46:50 <mm_freak> noteventime: in general i found that reimplementing in haskell is faster than maintaining the old code
18:46:53 * noteventime is thinking of all the poor people maintaining COBOL (though I'm guessing they're the ones laughing when they get their paycheck)
18:47:57 <mm_freak> we should simply compile haskell programs to SKI calculus and write a PHP run-time system for it
18:48:09 <mm_freak> that would make us productive and others wary of PHP =)
18:48:23 <noteventime> sordina: A code base making it hard to write an interface layer doesn't sound like one in a good condition
18:50:12 <sordina> noteventime: If the code-base is in good condition then that will be a solved problem. It won't be as elegantly soved (understatement) as it would be as if it were written in haskell, but if the abstraction is clean, then you have to look at the advantage gained by performing such a rewrite.
18:50:45 <noteventime> sordina: I didn't advocate a rewrite though
18:51:43 <sordina> If the system has to be changed significantly, then rewriting it in a better language is probably a good idea, but it doesn't make sense to say that existing codebases in PHP should always be rewritten.
18:51:54 <orzo> hello, i need help with cabal.  It wont let me do anything at all because it "Couldn't read cabal file "HUnit/1.2.5.0/HUnit.cabal" ... I can't even find that file on my disk, where would it be?
18:52:49 <donri> orzo: tar -vf ~/.cabal/packages/hackage.haskell.org/00-index.tar --delete HUnit/1.2.5.0/HUnit.cabal
18:52:54 <irene-knapp> I think rewriting existing code is usually a mistake unless the changes needed are really substantial
18:52:56 <noteventime> sordina: I didn't say the code-base should be rewritten, simply that the dependency of the new code on the old code should be mediated by some interface, rather than writing the new code in the old language
18:53:00 <sordina> noteventime: Sorry, I misinterpreted what you were saying.
18:53:45 <monochrom> orzo: another way: use a newer cabal-install. essentially, HUnit/1.2.5.0/HUnit.cabal has a line that older cabal-install doesn't understand
18:54:04 <orzo> donri, thanks, that worked for me
18:54:11 <noteventime> irene-knapp: A brainf*ck web development extension would be... interesting
18:54:17 <irene-knapp> wouldn't it :D
18:55:01 <monochrom> oh god, the perversion of humankind has no limit
18:55:20 <noteventime> brainf*ck isn't actually that bad
18:55:25 <sordina> noteventime: It exists. Check out mod_bf
18:55:36 <monochrom> QED
18:55:58 <orzo> how do i ensure that cabal installs profiling versions ?
18:56:18 <monochrom> first way: --enable-library-profiling
18:56:26 <mm_freak> sordina: i'm the fanatic, not noteventime =)
18:56:28 <noteventime> sordina: wow
18:56:39 <monochrom> second way: there is a line in config file ~/.cabal/config
18:56:47 <mm_freak> also brainfuck is quite boring…  it's not a difficult language, just inconvenient
18:56:54 <mm_freak> if you want a difficult language, check out lazy k
18:56:58 <sordina> mm_freak: Yep, my mistake. Direct my rant to yourself :P
18:57:27 <mm_freak> and lazy k is not only difficult for the coder, but also for the compiler developer =)
18:57:46 <mm_freak> lazy k needs everything from closures to garbage collection
18:57:53 <noteventime> Malbolge is an interesting language too
18:58:06 <noteventime> More in the spirit of brainf*ck
18:58:09 <mm_freak> malbolge isn't that interesting really…  it's quite easy to make such a language
18:58:33 <noteventime> mm_freak: True, but I still thought it quite funny
18:58:49 <noteventime> Might just be that it was the first of its kind I read about though
18:59:16 <sordina> unlambda strikes me as a very elegant ersolang, although I've never written anything in it.
18:59:23 <sordina> esolang*
19:00:12 <mm_freak> sordina: lazy k is unlambda done right
19:00:22 <sordina> Ah cool. What did they change?
19:00:40 <mm_freak> it's the lazy, pure sister of unlambda
19:00:40 <shachaf> They got rid of side effects.
19:01:24 <sordina> Lazym pure and side-effect free? Sounds familiar :)
19:01:32 <mm_freak> =)
19:01:36 <irene-knapp> "What distinguishes Lazy K from other such languages is its almost total lack of other features. It does not, for example, offer an integrated Hindley-Milner polymorphic type system. It is not shipped with an extensive standard library with support for platform-independent GUI programming and bindings to other languages. Nor could any such library be written since, among other things, Lazy K does not provide any way to define
19:01:39 <irene-knapp> oops
19:01:44 <irene-knapp> that looked shorter in the browser
19:02:02 <mm_freak> lazy k is haskell restricted to the Applicative combinators of (e ->) and 'interact'
19:02:03 <monochrom> yes it's truncated
19:02:15 <irene-knapp> oh well, I think you get the gist :)
19:02:19 <monochrom> yeah!
19:02:35 <otters> lazy k is just the SKI combinators?
19:02:43 <mm_freak> otters: + interact
19:02:56 <mm_freak> a lazy k program is a nonstrict function from stdin to stdout
19:03:02 <irene-knapp> ahahahaha: "Lazy K's motto is "there's more than one way to do it." In fact, there are exactly four ways to do it..."
19:03:03 <otters> oh
19:03:11 <monochrom> hahaha
19:03:11 <irene-knapp> dig at Perl is much appreciated :D
19:04:20 <sordina> I heard that there was a variant of unlambda where it was impossible to construct invalid programs.
19:04:27 <sordina> Jot I think.
19:04:29 <mm_freak> there's more than one way to do id
19:04:34 <mm_freak> I, S K K, …
19:05:15 <mm_freak> the interesting thing about lazy k is that it actually requires a full-blown haskell-style run-time system
19:05:31 <mm_freak> if you were to write a lazy k interpreter in C you would go mad
19:06:52 <shachaf> mm_freak: Is that why Hugs stopped being maintained?
19:07:00 <otters> well, Jot allows any string of 1s and 0s
19:07:01 <otters> but I don't know what it does for other characters
19:07:01 <otters> I believe whitespace is the same way
19:07:21 <irene-knapp> we lose more developers to insanity :)
19:07:27 <otters> heh
19:07:49 <mm_freak> shachaf: well, hugs needs to do much more than a lazy k interpreter…  in particular i'd expect the type system to be very tiresome to implement in C
19:55:21 <hashpuppy> I'm running a quick poll to learn more about productivity by querying members of the scala, clojure, and haskell community.  If you guys have 2 minutes, it would be much appreciated: https://docs.google.com/spreadsheet/embeddedform?formkey=dGZpbHExdHZteXY4VkpaRnBQUzRPRHc6MQ
19:59:01 <ski> hashpuppy : you picked a slow channel time ..
19:59:49 <hashpuppy> unfortunately, i did.  all 2 other channels are just about as dead.  i might hit up the mailing list.  or try again tomorrow morning.
20:00:10 <shachaf> The productive people aren't going to be on IRC. :-)
20:00:59 <lispy> hashpuppy: post it to the reddits
20:13:21 <shirt> that is one strange poll
20:13:25 <BMeph> Nothing says productivity, like a reddit thread... ;þ
20:16:11 * BMeph would consider that "survey" a joke...if only it could be taken so seriously... ;þ
20:25:05 <dmwit> So, how come hash-consing is so uncommon in Haskell?
20:26:29 <Jafet> cons what cons
20:27:09 <dmwit> We still make data in Haskell. ;-_-
20:27:25 <sordina> dmwit: I think we just share the data directly most often.
20:28:03 <dmwit> That technique seems quite applicable in other languages. Why isn't it used there?
20:28:03 <Jafet> Hash consing is a way to have that done for you
20:28:30 <Jafet> According to Baker it seems to work best for symbolic computation
20:28:44 <Jafet> A Haskell program that does that might implement hash consing
20:28:50 * Jafet squints
20:29:37 <dmwit> I mean, in OCaml, they throw hash-consing into programs the way we throw monad stacks in.
20:29:46 <dmwit> meaning: always
20:29:51 <sordina> dmwit: Does it require mutation?
20:30:05 <dmwit> I suppose so, yes.
20:30:13 <sordina> That's probably why then.
20:30:53 <Jafet> It doesn't need to look like mutation
20:31:05 <Jafet> So you could unsafePerform it I suppose
20:31:41 <dmwit> I mean, mutation is just as doable in Haskell as it is anywhere else...
20:32:02 <dmwit> Can we really pin this on the slight inconvenience of IO/ST?
20:32:07 <dmwit> maybe so
20:32:08 * hackagebot hexpat 0.20.2 - XML parser/formatter based on expat (StephenBlackheath)
20:32:13 <Jafet> No
20:32:22 <covi> What are some web frameworks written in Haskell that are production ready?
20:32:30 <Jafet> Hash consing has overheads
20:32:35 <sordina> Well yes, but it's generally avoided unless there's a compelling reason to use it. I'd say that's more the reason than the inconvenience.
20:33:17 <Jafet> I mean, we have deforesting and on the other hand you want to evaluate h() for every new cons
20:33:25 <Jafet> I don't know how ocaml is implemented
20:33:53 <gienah> covi: happstack, snap, yesod
20:35:09 <covi> gienah: how about bird?
20:35:23 <gienah> covi: I haven't heard of bird
20:37:14 <augur> ski: do you know of any sequent calculi with normalization rules for a non-comm logic?
20:37:22 <sordina> gienah: Also, Scotty, if you want a wai based sinatra-clone rather than a hack based one.
20:37:50 <ski> augur : no, haven't seen many papers on ordered logic
20:38:11 <augur> ski: what i want to figure out, really, is how abstraction works
20:38:18 <augur> i suspect it's something like
20:38:21 <covi> sordina: which one do you think is more suitable for small web app?
20:39:14 <sordina> I haven't used Bird, but Scotty is nice and easy. It's certainly not as production-hardened as Happstack, Snap, or Yesod though.
20:39:15 <augur> ski: A,G |- B ==> G |- A\B   and   G,A |- B ==> G |- B/A
20:39:17 <augur> but im not sure
20:39:37 <ski>   A , Gamma |- B , Delta
20:39:40 <ski>   ---------------------- |- ->
20:39:41 <ski>   Gamma |- A -> B , Delta
20:39:44 <ski> and
20:39:54 <ski>   Gamma , A |- Delta , B
20:40:00 <ski>   ----------------------- |- <-
20:40:11 <ski>   Gamma |- Delta , B <- A
20:40:13 <ski> iirc
20:40:19 <augur> so basically what i said ;)
20:40:25 <augur> <3
20:40:28 * ski reads what augur said
20:40:39 -StaffNotice(~Staff@213.140.116.188)- Offical Freenode Memo - Snardbafulator has been reported missing, and the FBI is suspecting foul play related to the barage of cyberbullying that has been taking place over the last two weeks. His manner of speaking in channels may be different that what you are used to, but Freenode staff asks that you act like everything is normal so that the FBI investigation is not impeded. : Christel - Freenode Staff
20:40:46 <ski> augur : yes
20:42:30 <augur> ski: so i wonder then if its possible to have an admissable rule like this:
20:43:11 <augur> ski:    G |- A/B   D |- B\C   ===B\X   G,D |- A\C
20:43:18 <augur> or would that have to be primitive
20:43:19 <Sgeo_>  /whois StaffNotice
20:43:21 <Sgeo_> oops
20:46:25 <augur> ski: i dont think so, right? i mean, you could go   C, D |- B   G, B |- A   ===cut   G, C, D |- A
20:46:46 <augur> btu then you couldnt \ over C
20:47:24 <augur> i wonder if lambek derived these things
20:47:27 <augur> i should check
20:48:02 <ski> augur : sounds right
20:48:17 * Clint accidentally learns that you don't need spaces outside of "
20:48:26 <augur> oh but ski, it seems
20:49:48 <augur> according to buszkowski, you have:    G, A, G' |- C    D |- B    ===   G, D, (B\A), G' |- C
20:50:05 <augur> and   ===   G, (A/B), D, G' |- C
20:50:12 <augur> interesting
20:50:19 <augur> this is for the lambek calculus, anyway
20:51:07 <ski> looks right, i think
20:51:16 <ski> hm
20:53:25 <ski> right, now i see
20:53:29 <ski> (or recall)
20:57:26 <dmwit> Why, that's not an official freenode memo at all!
20:58:05 <shachaf> ?
20:58:09 <ski> given `G1 |- B', we can derive `G0 * G1 * (B -> A) * G2 |- G0 * B * (B -> A) * G2' (by functorality of `X |-> G0 * X * (B -> A) * G2'), and then we have `B * (B -> A) |- A', so by (functorality again and) composition, we derive `G0 * G1 * (B -> A) * G2 |- G0 * A * G2', finally we compose with `G0 * A * G2 |- D' to get `G0 * G1 * (B -> A) * G2 |- D'
20:58:14 <ski> augur ^
20:58:32 <ski> dmwit : .. hehe, only noticed it now ? :)
20:58:32 <augur> ski: actually, those are basic categorial grammars in the sense of bar-hillel
20:58:38 <augur> apparent lambek CGs are what you describe
20:59:05 <dmwit> shachaf: "?"?
20:59:18 <dmwit> ski: I walked away from #haskell for a bit. Crazy, I know.
20:59:35 <ski> not sure what bar-hillels sense of basic categorical grammars is
20:59:59 <ski> dmwit : note the quit message
21:00:11 <shachaf> dmwit: What's not an official Freenode memo?
21:00:23 <shachaf> Oh.
21:00:30 <augur> ski: using the one i gave instead of the one you gave, apparently. :p
21:00:42 <ski> augur : anyway, the above is how i rederive the left rules of the two implications (and negations) in ordered logic
21:01:28 <augur> oh, ski, actually im wrong
21:01:30 <ski> augur : well, you said "G, A, G' |- C    D |- B    ===   G, D, (B\A), G' |- C", which is the same as what i said, except i renamed some, and showed the (in terms of categorial theory) derivation
21:01:35 <dmwit> ski: Yeah, that's a pretty solid clue.
21:02:07 <augur> BCGs are just     G,A,G' |- C   D |- B   ===   G,D,B\A,G' |- C
21:02:18 <augur> and the symmetric right case
21:02:40 <augur> LCGs are BCGs +   B, G |- A   ===   G |- B\A   and the sym right case
21:03:19 <ski> augur : so you're basically saying that BCG only contains the left rules for the implications, while LCG also containts the right rules ?
21:03:27 <augur> ski: seems so
21:03:30 <ski> (and what does "L" in "LCG" stand for ?)
21:03:34 <augur> lambek!
21:03:38 <ski> ok
21:04:34 <ski> i suppose BCG has some axioms/constants of implicational types, which they then need left-rules to "eliminate", while LCG also allows one to derive new implications (from sequents with the implication antecedent as a premise)
21:05:49 <augur> hm so i think CCG's cross rules are genuinely new
21:06:22 <ski> what's that "C", then ?
21:06:37 <augur> combinatory
21:06:52 <ski> ok. and what are the "cross rules" ? :)
21:06:57 <augur> :)
21:07:13 <ski> (and is this an extension of BCG or LCG ?)
21:07:16 <augur> cross composition, for instance:   X/Y   Z\Y   =>   Z\X
21:07:23 <augur> its.. i dont know
21:08:00 <ski> that "cross computation" seems to afford (at least a limited amount of) commutativity / non-ordering
21:08:21 <augur> cross composition :P
21:08:32 <ski> the normal case would be `X / Y , Y / Z |- X / Z'
21:08:33 <augur> and yes, ts a small amount of commutativity i guess
21:08:56 <ski> (and the mirror image, of course)
21:10:22 <augur> ok so that scarpers my plans a little bit D:
21:10:33 <augur> one of my plans!
21:11:23 <ski> what, pray tell, does your devilish plan consist of, this time ? :)
21:12:08 <augur> :p
21:12:10 * hackagebot fft 0.1.7 - Bindings to the FFTW library. (JedBrown)
21:12:50 <augur> ski: just figuring out whether or not normalized categorial grammar proofs constitute an equivalent of a transformational grammar
21:14:49 * ski isn't sure exactly whay "transformational grammar" amounts to
21:18:32 <augur> ski: a grammar where the rules dislocate parts of the tree
21:19:00 <augur> ski: typically very simple in nature, like:   ((X,Y),Z) ==> (Y,((X,_),Z))
21:19:25 <ski> hm, the weird duplication you had in derivations in an older paper you were writing ?
21:20:07 <augur> ski: im not sure what you mean
21:20:25 * ski doesn't recall the details
21:20:56 <augur> chomsky-style grammars, tho, have always employed displacement of some sort
21:20:57 <ski> there were some kind of references from some parts of the tree to other ("parallel") parts
21:21:07 <augur> oh, no not quite.
21:21:19 <augur> more recent versions are very resource-y
21:21:59 * ski would like to get a book on basic (relatively modern) grammar theory (as used in natural languages) ..
21:22:36 <augur> but theyve always involved displacement processes
21:22:43 <augur> well, i can teach you some stuff, ski :D
21:23:14 <augur> ski: but if you check out adger's book Core Syntax, you'll get a good idea of some stuff
21:23:37 <augur> it starts out with some unnecessary stuff about morphosyntactic features, but
21:23:39 <ski> if you could suggest some code works i should look out for, and others i should beware (in your opinion), that could be helpful
21:24:05 <augur> i dont know, man
21:24:19 <augur> i would just say start with Core Syntax. its a nice little boo
21:24:20 <augur> k
21:25:47 <ski> "Core Syntax: A Minimalist Approach" by David Adger in (e.g.) 2003, i take it
21:25:53 <augur> yes
21:26:01 <augur> i suspect libgen has it
21:26:46 <Nensha> Hello
21:26:49 <drbean> augur: You had a web page summarizing modern linguistic theories.
21:26:54 <ski> hello Nensha
21:27:00 <Nensha> Can I find cabal maintainers here? )
21:27:17 <augur> drbean: yes, i did, but ski probably wants something better than just "its like logic!"
21:27:19 <augur> :p
21:27:38 <augur> i suppose really its closest to having like.. only application and cut
21:27:57 <Nensha> [mirror] <augur> drbean: yes, i did, but ski probably wants something better than just "its like logic!"
21:28:13 <augur> Nensha: you forgot the :P
21:28:14 * ski found a <http://www.words-in-world.de/core-syntax.html> site, not sure how relevant it is
21:28:25 <augur> this is an unacceptable oversight, Nensha
21:28:44 <Nensha> augur what do you mean?
21:28:47 <augur> nevermind
21:29:09 <ski> cabal maintainers are sometimes found in here
21:29:16 <augur> ski: but for what its worth http://www.wellnowwhat.net/blog/?p=251
21:29:43 <Nensha> ski: I want to ask if they really need to keep 2 different Distribution folders for cabal and cabal-install
21:30:03 <augur> ski: also keep in mind, the feature system is not standardized. people have different versions of it, and noone has a good canonical description of any of them
21:32:00 <ski> Nensha : you could try catching dcoutts in here -- not sure which time of day would be most likely to succeed
21:32:09 <ski> preflex: xseen dcoutts
21:32:10 <preflex>  dcoutts was last seen on freenode/#ghc 18 days, 12 hours, 5 minutes and 49 seconds ago, saying: Axman6: it can do either
21:32:38 <Nensha> ski: ok, I shell try =)
21:32:53 <Nensha> == 18 days ago...
21:35:24 <ski> augur : ok
21:38:54 -StaffMsg(~Staff@ool-43513fda.dyn.optonline.net)- Offical Freenode Memo - Snardbafulator has been reported missing since yesterday, and the FBI has opened an investigation related to the barage of cyberbullying that has been taking place over the last two weeks. His manner of speaking in channels may be different that what you are used to, but Freenode staff asks that you act like everything is normal so that the FBI investigation is not impeded. : Christel - Freenode Staff
21:42:37 <signalsea> Hey all. Question: What would be an idiomatic way to associate static data with a type (emulating something like static attributes in OO)?
21:43:26 <Nereid> signalsea: for example?
21:44:02 <Nereid> everything is static, btw
21:44:05 <ski> augur : on a first impression, `[V,uN]' appears similar to `V / N'
21:44:23 <augur> ski: yeah, except its really more like -> in that its not directional
21:44:33 --- mode: ChanServ set +q StaffMsg!*@*
21:44:55 <augur> ski: but it gets tricky because you get weird properties of non-linearity, reuse, etc.
21:45:05 <signalsea> Nereid: Like  if I could pass a type to an ordinary function and receive a tuple back
21:45:12 <Nereid> "pass a type"?
21:45:22 <Nereid> I mean a specific example.
21:46:05 <ski> signalsea : like `instance Bounded Ordering where minBound = LT; maxBound = GT' ?
21:46:26 <dmwit> ?djinn a -> a -> a
21:46:27 <lambdabot> f _ a = a
21:46:57 <Nereid> I was thinking something like typeclasses but I wanted him to be clear on what he's trying to accomplish.
21:47:00 <dmwit> ?djinn (a -> b) -> [a] -> [b]
21:47:01 <lambdabot> Error: Undefined type []
21:47:04 <dmwit> right
21:47:23 <ski> @djinn (a -> b) -> (Maybe a -> Maybe b)
21:47:23 <lambdabot> f a b =
21:47:23 <lambdabot>     case b of
21:47:23 <lambdabot>     Nothing -> Nothing
21:47:23 <lambdabot>     Just c -> Just (a c)
21:47:44 <Latro__> wow, there's an @djinn
21:47:46 <Latro__> that is cool
21:47:53 <ski> @help djinn
21:47:53 <lambdabot> djinn <type>.
21:47:54 <lambdabot> Generates Haskell code from a type.
21:47:54 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
21:47:59 <Latro__> @djinn (Int->Bool)->Int
21:47:59 <lambdabot> Error: Undefined type Int
21:48:01 <Latro__> er
21:48:02 <Latro__> wait
21:48:03 <Latro__> what
21:48:04 <ski> @list djinn
21:48:05 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
21:48:13 <Latro__> @djinn (Nat->Bool)->Nat
21:48:13 <lambdabot> Error: Undefined type Nat
21:48:20 <dmwit> ?djinn (a->b) -> a
21:48:20 <lambdabot> -- f cannot be realized.
21:48:22 <Latro__> :/
21:48:23 <signalsea> say I had a type "data Foo = Bar String Date String", how could I associate this with a list ["Enter your name", "Enter current date in format xyz", "What is your favorite color?"]
21:48:27 <ski> `djinn-env' lists the types (and classes) it has in scope
21:48:35 <Latro__> @djinn-env
21:48:35 <lambdabot> data () = ()
21:48:35 <lambdabot> data Either a b = Left a | Right b
21:48:35 <lambdabot> data Maybe a = Nothing | Just a
21:48:35 <lambdabot> data Bool = False | True
21:48:35 <lambdabot> data Void
21:48:37 <lambdabot> type Not x = x -> Void
21:48:39 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
21:48:41 <lambdabot> class Eq a where (==) :: a -> a -> Bool
21:48:43 <dmwit> ...saw that one coming
21:48:44 <signalsea> I want to make a simple CLI CRUD interface
21:48:58 <ski> @djinn-add type NotNot a = Not (Not a)
21:48:59 <Latro__> sorry, figured it wouldn't have a ton of stuff there
21:49:00 <Nereid> signalsea: you just put the list somewhere
21:49:11 <ski> @djinn NotNot (Either a (Not a))
21:49:11 <dmwit> signalsea: http://hackage.haskell.org/package/wizards maybe
21:49:11 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
21:49:19 <dropdrive> @djinn (a->b)->a->Maybe a
21:49:19 <lambdabot> f _ a = Just a
21:49:25 <dropdrive> @djinn (a->b)->a->Maybe b
21:49:25 <lambdabot> f a b = Just (a b)
21:49:28 <ski> @djinn (a -> NotNot b) -> (NotNot a -> NotNot b)
21:49:28 <lambdabot> f a b c = void (b (\ d -> void (a d c)))
21:49:35 <ski> @djinn a -> NotNot a
21:49:36 <lambdabot> f a b = b a
21:49:51 <signalsea> thanks dmwit.
21:49:56 <signalsea> Nereid: What do you mean?
21:50:15 <Nereid> signalsea: what are you doing with the list?
21:50:26 <dropdrive> @djinn (a->b)->a->b->(b,b)
21:50:26 <lambdabot> f a b c = (c, a b)
21:50:47 <dmwit> Oh, the documentation seems to be on github, not Hackage.
21:50:52 <dmwit> Sorry for the misleading link.
21:50:57 <dmwit> https://github.com/liamoc/wizards
21:51:09 <signalsea> Nereid: I suppose I'd be passing it to a function that consumes each string and prompts the user for input
21:51:21 <Nereid> right, and how does it relate to Foo
21:51:21 <ski> signalsea : why do you need to "associate static data with a type", instead of just defining `myList = ["Enter your name", "Enter current date in format xyz", "What is your favorite color?"]' ?
21:52:13 <signalsea> Well, if I had a bunch of types, and I wanted to just define a whole bunch of prompt strings in one place to gather data from the user
21:52:48 <signalsea> or rather, that is what I'd want to do
21:53:43 <ski> signalsea : so you're defining some `IO'-action which will print these prompt strings, read answers, parse them a bit, and return a value of the respective type ?
21:55:32 <ski> signalsea : if so, i suppose i might try to define a few operations like `queryFoo :: IO Foo', each of which printed its own prompt strings, read things of the correct type, and constructed each respective resulting value
21:55:54 <ski> signalsea : .. but i'm just guessing here, since we don't know that much about the details of what you want to do
21:56:02 <mauke> signalsea: why would you have multiple types?
21:56:03 <dmwit> dropdrive: Anyway, the point is that it's hard enough just knowing whether a type is implementable at all that you have to restrict the types you can accept really a lot before you can even check, let alone find a "simplest" implementation. =)
21:56:28 <Nereid> and perhaps if you have a bunch of types like this you could make a class like
21:56:30 <signalsea> I'll explain what I'm really trying to do, but you'll have to wait a moment while I put it into clear words
21:56:33 <Nereid> class Query a where query :: IO a
21:56:42 <Nereid> which would be queryFoo for a = Foo
21:56:51 <ski> signalsea : e.g. i suspect that your types like `Foo' can have constructors with different number of arguments with different types -- is this so ?
21:56:53 <dmwit> I feel like people are being unusually unhelpful to signalsea right now.
21:57:31 <Nereid> it might be good to abstract this
21:57:34 <dmwit> It's really not hard to do what he's asking.
21:57:48 <mauke> dmwit: and?
21:57:54 <Nereid> for each type, we have some query strings, and then a function that takes response strings and gives you a value of that type
21:58:05 <dmwit> e.g. liftM3 Foo (queryString "Enter your name") (queryDate "Enter current date in format xyz") (queryString "What is your favorite color?") is very nearly exactly what he's asking for.
21:58:09 <dmwit> So just say that.
21:58:26 <ski> dmwit : possibly, but i'm not sure yet what s/he wants to do
21:58:39 <mauke> dmwit: I don't see how that's what they're asking for at all
21:59:26 * dmwit shrugs and awaits clarification from signalsea
22:03:18 <signalsea> I would like to declare several types corresponding to domain-specific data, and for each type, have a list of tuples [(String, *somefunction*)] where the list corresponds exactly to the number of constructor arguments for each type, and each typle (String, *somefunction*) corresponds to some prompt string and a function to decide what to do with it. Now I want to just call the series of prompt strings in my crud program for variou
22:03:51 <dmwit> That got cut off at "crud program for variou"
22:03:57 <signalsea> oh boo
22:04:17 <signalsea> ahhh I'll pastebin it give me a few moments
22:04:29 <dmwit> But the answer from the description so far is "don't do that".
22:05:15 <signalsea> what shall I do instead? How would a person ie implement multilanguage packages for an interactive program
22:05:24 <mauke> "ie"?
22:05:39 <dmwit> Storing a list of strings is fine.
22:05:48 <dmwit> Storing a list of strings next to functions of different types is not fine.
22:05:58 <signalsea> ok
22:06:07 <dmwit> Storing a map from names to strings is even better.
22:06:11 <signalsea> yes
22:06:14 <dmwit> Just naming your strings is better still.
22:06:57 <dmwit> Unfortunately, I don't think there's been very much work on l10n or i18n in Haskell.
22:07:04 <dmwit> At least, last time I looked there weren't any really serious solutions.
22:07:19 <Nereid> well this page exists http://www.haskell.org/haskellwiki/Internationalization_of_Haskell_programs
22:09:46 <signalsea> nvm my problem. I will check out the wizards package and possibly return with a much more concrete example
22:10:31 <dmwit> Nereid: Nice.
22:10:41 <signalsea> ...if I can't solve my problem with your explanations either
22:11:17 <signalsea> thank you for your help
22:12:02 <dmwit> I like the idea of GF. Is it, like... actually usable realistically?
22:13:34 <Nereid> I like the idea but I'm somewhat skeptical that it would work in real life situations
22:15:06 <Nereid> I wouldn't be comfortable with it producing translations into languages I don't know.
22:15:11 <Nereid> which is most languages.
22:15:27 <dmwit> Yeah, I'd think you need a hybrid approach.
22:15:36 <Nereid> well, in any case have them checked by a human.
22:15:41 <dmwit> Use GF for the initial translations, and get a native speaker to help you fix it up when it inevitably goes wrong.
22:15:46 <Nereid> right.
22:16:23 <Nereid> and at that point you're required to use another library anyway.
22:16:30 <Nereid> I might be wrong on some points since I don't really know anything about GF.
22:23:10 <Nereid> on a completely unrelated topic, I'm interested in uh
22:23:19 <Nereid> doing some processing on video streams
22:23:37 <Nereid> say, applying transformations like scale/rotate/crop/delay, and combine multiple streams together
22:23:52 <dmwit> There are bindings to gstreamer and OpenCV on Hackage.
22:24:33 <Nereid> hmmmmm
22:25:09 <Nereid> I'm not sure if gstreamer is what I want.
22:27:09 <Nereid> anyway, if I were to implement these transformations myself,
22:27:19 <Nereid> I guess I'd be worried about performance
22:27:20 <Nereid> ?
22:27:57 <Nereid> it would be nice to have some pure way of doing this stuff
22:29:56 <Nereid> it would be nice if I could find some DirectShow bindings though (yes I'm doing this for windows)
22:30:52 <Nereid> or something
22:32:47 <Nereid> I dunno.
22:34:10 <Nereid> it's probably easiest to do all this in C++. :/
22:37:14 * dmwit squints at Nereid in confusion
22:37:56 <Nereid> ok here's the story.
22:38:08 <Nereid> this is all windows-only.
22:38:43 <Nereid> my goal is to make a virtual capture device, whose output is made by taking video/audio from other sources, like the screen, or other capture devices
22:38:57 <Nereid> there are several things that do this already, but they all have certain limitations
22:39:21 <ski> signalsea : i'm still not sure why you want to store this list of tuples separatedly from its use
22:39:39 <Nereid> (examples of such software: vhmulticam, scfh dsf)
22:41:18 <Nereid> so a lot of this code is going to be pretty closely tied to windows-specific stuff like directshow
22:43:02 <mietek> It seems like it's really difficult to install gtk2hs on OS X
22:43:14 <mietek> I had to give up on brew
22:45:45 <hamishmack> mietek: Try using gtk-osx.  When you do the bootstrap step, use … jhbuild bootstrap --skip=libiconv
22:46:55 <hamishmack> mietek: https://live.gnome.org/GTK+/OSX/Building
22:47:41 <mietek> hamishmack: thanks, but I'm not interested in building it in a vacuum
22:47:46 <mietek> hamishmack: I'm back to MacPorts now
22:48:25 <mietek> So much yak shaving just to install Haskell diagrams
22:50:36 <Nereid> so I'd probably have to write a bunch of glue code.
22:50:50 <Nereid> maybe I'll do the windows-specific stuff in C/C++ and let haskell do the fun stuff.
22:51:55 <Nereid> as if I'll have time to work on this.
22:54:04 <hamishmack> mietek: If that fails give gtk-osx a go, but remember when you get to the "jhbuild bootstrap" step to run… jhbuild bootstrap --skip=libiconv
22:54:22 <hamishmack> or it will not play nice with ghc
23:02:14 * hackagebot warp 1.3.0.1 - A fast, light-weight web server for WAI applications. (MichaelSnoyman)
23:17:32 <MostAwesomeDude> Hm. So I don't get free monads. Are they actually ever practical, or just a curiosity?
23:18:41 <latro`a__> I think that essay that was pasted in here recentlyish showed their practicality fairly well
23:19:07 <MostAwesomeDude> Well, it showed me a very very roundabout way to purify some trivial code in IO.
23:19:12 <MostAwesomeDude> Maybe I just don't grok it.
23:19:22 <latro`a__> that much was sort of about encapsulation
23:19:35 <latro`a__> you've made a type which is a very small subset of the IO monad that does everything you want
23:19:49 <latro`a__> in principle, with a more complicated "run", you could also abbreviate your code
23:19:56 <latro`a__> if you had some patterns that were common
23:20:37 <ski> well, you have some effects, and you represent them by constructors in a data-structure
23:21:06 <ski> then you can either use the normal interpreter, getting the previous behaviour, or you can analyze the data structure in other ways
23:21:20 <latro`a__> the example there was sorta overly trivial, it'd be nice to see a slightly larger example
23:21:28 <latro`a__> perhaps an example where you actually do save some lines
23:21:34 <ski> (e.g. in some cases print out descriptions of the actions, instead of performing them)
23:22:04 <GormBensen> Sadly, the seemingly inevitable result is that humans eventually have to move on as the filthy nigger hordes arrive. If you can nip it in the bud by means of the police--which as jeannieD stated the geezers will take care of--then well and good. I hope you come up with a plan that will be effective and fit in to your principles. I wish you the best of luck.
23:22:14 <GormBensen> It is sad that we have to avoid avoid avoid...while niggers run roughshod over all we have built.
23:22:14 <GormBensen> I do believe Jennie is right. The old people will do the calling.
23:22:14 <GormBensen> Meanwhile I must do recon to know what I'm dealing with, hence the walking.
23:22:14 <GormBensen> I will also casually network with other neighbors...ie "Gee did you see the residents on the next block that don't fit in around here" I'll make note of libtards and allies.
23:22:14 <GormBensen> My property is secure, There is nothing outside to steal, and no where on my property to hide (ie fences, bushes etc) and I have a flood light on in the driveway/carport to cover the vehicles (trucks and bikes).
23:22:15 <GormBensen> If there is a real crime, I would call cops, and of course if there were an clear and present mortal threat I am EQUIPPED to deal with it within the law.
23:22:15 <GormBensen> The only thing I'm lacking is my CCW and as stated I could be in better shape.
23:22:17 --- mode: ChanServ set +o mauke
23:22:18 --- kick: GormBensen was kicked by mauke (GormBensen)
23:22:22 --- mode: mauke set +b *!*@46.19.226.126
23:22:26 <latro`a__> thank you sir, mauke
23:22:37 <Hermit> just in time
23:23:38 <ski> also consider an example of a game engine querying a player what to do. when querying a human user, that query would probably be interpreted in terms of `IO'-actions to interact with some UI; while when querying an AI, the query would be interpreted in terms of some internal algorithms on the AI state
23:24:26 --- mode: mauke set -o mauke
23:24:32 <latro`a> incidentally, is there any more elegant way to write something like
23:24:40 <latro`a> f <some pattern> = foo
23:24:53 <latro`a> f x = putStrLn "pattern match fail" >> f x
23:25:18 <mauke> f _ = forever (putStrLn "pattern match fail")
23:25:22 <ski> MostAwesomeDude : they are also useful for getting a type of "expressions" with "free variables", given a type representing a "layer/node" in such an expression
23:25:27 <latro`a> uh
23:25:31 <latro`a> no, that's not the right thing
23:25:47 <latro`a> I actually wasn't clear, sorry
23:25:51 <Hermit> I'm trying to override functions in prelude, trigonometric ones to be precise. How can I... just... use them from a module definition yet make the new ones the only ones when importing the module. I know it sounds confusing.. What I'm trying to do is have the trigonometric functions work on  Floating a => Radians a (and Degrees a) without the need to prefix them in any way
23:26:04 <latro`a> sorta like
23:26:18 <MostAwesomeDude> ski: I see.
23:26:22 <mauke> Hermit: import Prelude hiding (sin, cos, ...
23:26:34 * Hermit gives that a try
23:26:37 <latro`a> f = do {str <- getLine; let parsed = someparser str; g str}
23:26:47 <latro`a> where g <some pattern> = foo
23:26:59 <latro`a> g x = putStrLn "pattern match fail" >> f
23:27:09 <latro`a> er sorry, not g str
23:27:10 <latro`a> g parsed
23:27:18 <ski> Hermit : you can use e.g. `import qualified Prelude as P' and `P.cos',`P.sin' to access the original ones, in the module
23:27:35 <ski> (Hermit : at the same time as using mauke's suggestion)
23:27:43 <latro`a> that is, take in input, then if it's formatted correctly, do some more stuff, if it's not, print an error and go back to the same function call you started with
23:27:59 <latro`a> eh not call, the same action you started with
23:28:01 <ski> latro`a : you could use a `case', i suppose
23:28:09 <latro`a> I mean a way to encapsulate this
23:28:22 <solrize> i think you should make Radians and Degrees instances of Floating that convert to radians for trig functions
23:28:25 <asfasd> Do all American niggers get free Medicare?
23:28:25 <asfasd>     This question has been eating at me lately. I have been without Health Insurance for over 2 years due to finances and other extenuating living expenses. I just need to know how this Gibbs works. Do employed niggers have to pay for their Medical Insurance like the rest of us?
23:28:25 <asfasd>     Do all welfare niggers recieve free Medicare regardless of their rap sheet and criminal record?
23:28:25 <asfasd>     Since our country is apt to fortify the least productive and most pernicious members of society while the rest of us get screwed, it has been obvious that our country has been in self-destruct mode for quite some time. What was once intended as a Bandaid to help the destitute has become a responsibility of the government as our country slowly gets eaten away by the Black Plague.
23:28:32 --- mode: ChanServ set +o mauke
23:28:32 --- mode: mauke set +b *!*@109.121.229.2
23:28:34 <latro`a> I wound up doing this several times already
23:28:36 --- kick: asfasd was kicked by mauke (asfasd)
23:29:06 <ski> latro`a : `f = do str <- getLine; let {parsed = someparser str}; case str of <some pattern> -> foo; _ -> f' ?
23:29:55 <latro`a> something like that, minus failing to actually do the parsing
23:30:03 <latro`a> er, use the parsed form
23:30:26 <ski> latro`a : hm, actually, i think by `g str' you really meant `g parsed'
23:30:26 <latro`a> eh, I dunno, I may be being silly/imperativeish by trying to think of things this way
23:30:29 <latro`a> yes, I did
23:30:32 <latro`a> I mentioned that
23:30:35 --- mode: mauke set -o mauke
23:31:07 <ski> latro`a : i suppose you could say `f = result <- h; foo' and `h = do str <- getLine; let {parsed = someparser str}; case parsed of <some pattern> -> return result; _ -> h'
23:31:28 <applicative> Hermit: I think sin sinh and co. are mostly under the class 'Floating' so you could do 'import Prelude hiding (Floating(..)) but it sounds like you are wanting to define a 'Floating' instance; maybe you should just newtype Double or whatever
23:31:29 <latro`a> that winds up being more verbose than the original form, I think
23:31:44 <ski> (latro`a : oh, so you did -- missed that)
23:33:16 <Hermit> applicative: I tried that before, not sure if I did it right, but since typeclass Floating defines sin :: a -> a  I'd get  sin :: Floating a => Radians a -> Radians a   which doesn't make sense
23:33:50 <applicative> Oh i see Radians is polymorphic Radians a
23:34:30 <hpaste> latro`a pasted “Error and backchain” at http://hpaste.org/72046
23:34:41 <latro`a> ski: an example of what I mean is in that hpaste
23:35:04 <latro`a> it seems like having to ">> askyn' ioN ioY" every time is somewhat redundant
23:35:13 <Hermit> applicative: still, I'm relatively new to haskell so there may be a better way to do it that I haven't thought of yet. Please bear with me :-)
23:35:44 <Jafet> That problem looks easy to fix.
23:36:25 <applicative> what does the declaration of Radians look like Hermit?
23:36:58 <Jafet> Wait, you are doing user interaction in continuation style?
23:37:26 <latro`a> at present no, I don't think so
23:37:44 <latro`a> askyn' and askyn'' (which isn't there) are just versions of askyn with arguments supplied in advance
23:37:52 <Hermit> newtype Radians x = Radians x deriving (Eq, Ord, Show), then I derive Floating a => Num (Radians a). Same for Fractional (and both derivations for Degrees too)
23:37:58 <Hermit> applicative: ^
23:38:10 <latro`a> I can envision a form which would do it in continuation style, however
23:38:18 <Hermit> applicative: (quite a lot of repetitive stuff)
23:38:33 <latro`a> something like askyn' = f askyn "You must say either y or n." for some f that I don't know how to write
23:38:54 <Hermit> applicative: I know about that mighty pragma GeneralizeNewtypeDerivation, but I wanted to stay h98 compliant
23:39:10 <Jafet> prompt "A:" >> askyn' (prompt "AA:" >> askyn' (prompt "AAA:" >> askyn' aaaa aaab) (prompt "AAB:" >> askyn' aaba aabb)) (
23:40:58 <latro`a> not seeing what that is meant to do
23:42:16 <latro`a> basically this just seems like a common IO-recursion construct, in a way analogous to folds and such in pure recursion; maybe I'm mistaken and this isn't usually done this way
23:42:20 <Jafet> Well, f ask err = fix (\x n y -> ask (putStrLn err >> x n y))
23:42:25 <Hermit> applicative: I'm wondering if I'm overgeneralizing things here...
23:42:37 <latro`a> huh
23:43:03 <Jafet> This definition of course gives totally no insight to what it does
23:43:38 <latro`a> is there one that does? because this really does seem like a pretty standard format
23:44:51 <applicative> hm Hermit, I was thinking augustss 's response here might help, not sure  stackoverflow.com/8604849
23:45:13 <Jafet> tryInput parse = do inp <- getLine; case parse inp of Right v -> return v; Left msg = putStrLn msg >> tryInput parse
23:45:41 <latro`a> hm
23:45:58 <latro`a> that....works, actually
23:46:02 <latro`a> and can be generalized
23:46:05 <Hermit> applicative: link seems broken
23:46:13 <Jafet> tryInput (\x -> if x == "n" then return (return ()) else if x == "y" then return launchMissiles else fail "Say y or n")
23:46:14 <applicative> just a sec
23:46:54 <latro`a> in fact you can avoid the explicit getLine inside tryInput
23:46:59 <latro`a> by supplying an IO action argument
23:47:22 <applicative_> http://stackoverflow.com/questions/8604849/how-to-avoid-quadratic-explosion-of-typeclass-instances <-- Hermit . Nothing remarkable
23:48:20 <latro`a> tryInput inputAndParseAction = do parsed <- inputAndParseAction; case parsed of Right v -> return v; Left msg -> putStrLn msg >> tryInput inputAndParseAction
23:48:27 <latro`a> that is apparently what I wanted, thanks
23:48:28 <latro`a> :)
23:49:08 <applicative_> Hermit, naw.  Maybe something else involving the type system  and physical dimensions
23:49:23 <Hermit> applicative, ski, mauke: thanks for the help. I finally managed to do what I wanted, doing: import qualified Prelude (sin, cos, ...) then import Prelude hiding (sin, cos, ...) so I access the originals with Prelude.sin, etc and redefine those the way I want
23:50:17 * Hermit is reading the stack overflow link nevertheless
23:52:36 <hpaste> ski annotated “Error and backchain” with “pulling recursive call inside `askyn'” at http://hpaste.org/72046#a72047
23:52:51 <ski> latro`a : not sure how much that ^ helps ..
23:53:34 <latro`a> ...
23:53:36 <latro`a> s <- failure s
23:53:37 <latro`a> what
23:53:54 <latro`a> does that cause some sort of namespace collision?
23:54:12 <fftrerged> I love your avatar, cal the AMBERlamps...I have an oldie but a goodie and I think one of my favorite
23:54:12 <fftrerged> What's the difference between dog shit and niggers?
23:54:12 <fftrerged> When dog shit gets old it turns White and quits stinking.
23:54:12 <fftrerged> How do you get a nigger out of a tree?
23:54:12 <fftrerged> Cut the rope.
23:54:20 <fftrerged> Best one I've ever heard to this day is the one about the Chinese guy and the nigger bartender. It's on here in a few different forms but it's all in the delivery. My father first told it to me when I was a kid and I just about pissed my pants laughing. I've cracked up liberals with it over the years in spite of themselves.
23:54:23 --- mode: ChanServ set +o mauke
23:54:23 --- mode: mauke set +b *!*@111.179.36.166
23:54:26 <ski> that's just a silly generalization since it seemed somewhat strange to me to have `()' in `IO ()', instead of anything more "useful"
23:54:30 --- kick: fftrerged was kicked by mauke (fftrerged)
23:54:44 <latro`a> certainly
23:54:46 <ski> latro`a : no, that binds a new variable `s' which shadows the old one
23:54:52 <latro`a> hm
23:54:53 <latro`a> OK
23:54:58 <Jafet> I generalize code by commenting out the type signatures
23:55:06 <latro`a> ^I have done this
23:55:07 <mietek> hamishmack: you called it...
23:55:14 <mietek> I am really tired now
23:55:22 <latro`a> sometimes the result is ugly, though
23:55:29 <latro`a> a big mess of class constraints
23:55:29 <ski> `let'- (and `where'-) bindings are recursive, `<-'-bindings in `do' and list comprehensions are not recursive
23:55:31 <latro`a> or whatever
23:55:35 <mietek> So MacPorts' gtk2 and friends depend on MacPorts' libiconv
23:55:40 <ski> (unless you use `rec' in `do')
23:55:51 <latro`a> I see
23:55:54 <mietek> Which is incompatible with Haskell Platform's use of OS X-standard libiconv
23:56:19 <augur> ski: :|
23:56:20 <ski> Jafet : yeah, but the monadic result of `failure' was still put to no use ..
23:56:30 --- mode: mauke set -o mauke
23:56:55 <mietek> http://hackage.haskell.org/trac/ghc/ticket/4068
23:57:31 <mietek> Indeed, why aren't the iconv-using bits simply linked into libHSbase-4.5.0.0.a ...
23:57:39 <mietek> Kill me now
23:58:01 <latro`a> I see the trick I can pull now though
