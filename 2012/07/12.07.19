00:00:12 <tgeeky_> if you don't think that's true, then shame on you. If you don't think that's related to color, then shame on me
00:00:13 <edwardk> but black is a perceptual thing. black is where the 3 sets of cones are all reporting non stimulus. THAT exists, because background radiation is far far far below the sensitivity of rods or cones =P
00:00:21 <Nereid> ok, I can't help but say a few things, so here goes.
00:01:08 <edwardk> and black if you are getting no information from rods or cones, congratulations you see black =P
00:01:10 <mroman> bits.hs:1:14: Unsupported extension: DefaultSignatures
00:01:12 <mroman> Hu.
00:01:15 <Nereid> a black body is something that absorbs all light, not reflecting it. there's nothing inconsistent about such a thing existing (as far as I know anyway). black bodies at some positive temerature of course emit light.
00:01:16 <edwardk> mroman: 7.4.1
00:01:18 <Nereid> but that
00:01:21 <Nereid> 's different from reflection.
00:01:41 <mroman> Damn :(
00:02:18 <edwardk> Nereid: the niggling distinction is of course the lack of black bodies in practice. they are a theoretical nicety
00:02:31 <Nereid> sure, we don't see them in real life.
00:02:45 <edwardk> anyways, i'm on your side here so far ;)
00:02:59 <Nereid> we can still sensibly talk about seeing black, though
00:03:08 <Nereid> i.e. the eyes not receiving any visible photons
00:03:08 <edwardk> sure
00:03:22 <edwardk> thats what i'm poking at as well
00:04:14 <shachaf> Dude, what if, like, when you see what you call black, I see something that I call *something else*, dude?
00:04:17 <shachaf> like, whoa
00:04:22 <mroman> ah well.
00:04:30 <edwardk> this is why we measure luminous flux in lumens and radiant flux in watts, they are different things ;)
00:04:32 <tgeeky_> no, even that isn't correct for, say, observing a star (like the Sun). The "black" sunspots on the surface are only black because they have a relatively lower temperature.
00:04:34 <Nereid> I was going to say something about temperature but that's even more off topic.
00:04:36 <tgeeky_> This isn't the human eye, of course.
00:04:37 <mroman> Let's compile the new hp for half a day
00:04:58 <Nereid> whoa, where'd this talk about sunspots come from.
00:05:12 <shachaf> I like how this is all an argument about words.
00:05:26 <Nereid> tgeeky_: write some code. code that does something cool.
00:05:41 <edwardk> shachaf: sadly they are all well defined words
00:05:45 <Nereid> (or something at all)
00:06:03 <shachaf> edwardk: That's never stopped anyone from arguing!
00:06:14 <edwardk> i have no idea how sunspots came into this either
00:06:45 <tgeeky_> I can't discuss about an object that emits light, which has apparently black spots on its surface
00:06:52 <tgeeky_> in a discussion about light and the meaning of "black"
00:06:58 <Dodek> hey, do applicative functors have any counterparts in math world?
00:07:15 <Nereid> Dodek: I asked this the other day, and received "lax monoidal functors" in response.
00:07:22 <Dodek> ah.
00:07:33 <tgeeky_> strong lax monodial functors, even
00:07:33 <Nereid> I haven't thought about it enough to comment on the "lax" part but it works out.
00:07:38 <Nereid> or strong.
00:07:47 <edwardk> absolute black = 0 photons hitting rods or cones in your eye, done. now, you can talk about something that gets perceived as black because its dark, but nobody offered up that definition =)
00:07:50 <Nereid> @type liftA2 (,)
00:07:51 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
00:08:15 <Dodek> thanks, Nereid
00:08:46 <Nereid> ^ having this function is equivalent to having <*>
00:09:55 <edwardk> photometry is only defined in terms of visible wavelengths, and luminosity is a function of human brightness sensitivity, so the lack of stimulus response is the appropriate definition for black in that system
00:10:49 <ski> tgeeky_ : "The point is to pick a set of colors from both spaces" -- which spaces ?
00:10:53 <ski> Peaker : ty for that reddit link, i've been pondering such additive actions myself re affine vs. linear space
00:11:14 <Nereid> actions are cool, I could talk about those.
00:11:27 <edwardk> Nereid: strong lax monoidal functors technically
00:11:39 <dmwit> :t (fmap (uncurry ($)) .) . liftA2 (,)
00:11:40 <lambdabot> forall b b1 (f :: * -> *). (Applicative f) => f (b -> b1) -> f b -> f b1
00:11:41 <Nereid> that was said, yes.
00:11:48 <dmwit> yay, I can implement <*>
00:11:53 <Nereid> mhm
00:11:59 <ski> @let strength :: Functor f => a -> f b -> f (a,b); strength = fmap . (,)
00:12:00 <lambdabot>  Defined.
00:12:17 <Dodek> so basically monoidal functors are functors preserving monoidal structure on category
00:12:24 <edwardk> every functor in haskell is strong, so that part is easy
00:12:25 <Nereid> on monoidal categories yes
00:12:37 <tgeeky_> ski: in a general sense, I would hope any two. In this case, I just picked an additive and subtractive color space (because I could identify the (zero +) and (1 -) components as inverses of each other)
00:12:46 <Nereid> oh I guess you basically said that.
00:12:48 <edwardk> (which is part of why we can't have some nice comonads)
00:12:57 <edwardk> Dodek: yes
00:12:58 <ski> @let strength' :: Functor f => f (a -> b) -> (a -> f b); strength' = flip (fmap . flip ($))
00:13:00 <lambdabot>  Defined.
00:13:30 * ski forgets what `lax' means
00:13:53 <ski> @type flip
00:13:55 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
00:14:12 <edwardk> http://ncatlab.org/nlab/show/lax+functor
00:14:12 <Dodek> and applicative functors are monoidal functors for monoidal structure of endofunctors, am i understanding definition correctly?
00:14:22 <Nereid> yeah
00:14:36 <Dodek> cool
00:14:41 <Nereid> well
00:14:48 <Nereid> they're monoidal endofunctors of Hask
00:15:02 <edwardk> Dodek: have you seen the original idiom/applicative paper?
00:15:09 <ski>   class ApplicativeFunctor i where aUnit :: i (); aPair :: i a -> i b -> i (a,b)
00:15:10 <Dodek> nope
00:15:44 <ski> (oh, i suppose we really need `Functor i => ' there, as well)
00:16:09 <Nereid> I don't know what a _strong_ lax monoidal functor is.
00:16:10 <Nereid> ??
00:16:15 <edwardk> http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
00:16:24 <ski> tgeeky_ : "any two" -- any two color spaces ? -- what is a color space ?
00:16:47 <edwardk> section 7 of that paper dives into their derivation categorically
00:16:47 <Dodek> edwardk: thanks, i'll read it tomorrow
00:16:53 <Dodek> need to get some sleep today
00:17:43 <ski> @let aUnit :: Applicative i => aUnit = pure (); aPair :: Applicative i => i a -> i b -> i (a,b); aPair = liftA2 (,)
00:17:43 <lambdabot>   ScopedTypeVariables is not enabled
00:18:00 <ski> @let aUnit :: Applicative i => i (); aUnit = pure (); aPair :: Applicative i => i a -> i b -> i (a,b); aPair = liftA2 (,)
00:18:01 <Nereid> ah, now I know.
00:18:02 <lambdabot>  Defined.
00:18:08 <Nereid> or rather, know where to look to find out.
00:19:06 <ski> @type let pure a = fmap (\() -> a) aUnit in pure
00:19:07 <lambdabot> forall b (f :: * -> *). (Applicative f) => b -> f b
00:19:22 <ski> @type let (<*>) = fmap (uncurry ($)) .: aPair in aPair
00:19:23 <lambdabot> forall (i :: * -> *) a b. (Applicative i) => i a -> i b -> i (a, b)
00:20:04 <edwardk> the problem with color spaces is that they don't really make sense. you wind up wanting to talk about the actual wavelengths involved because if you actually try to print a given color you immediately get to deal with metamerism concerns as it is shown under different lighting conditions, etc. or you need to talk about the gamut and icc curves of the display being used to approximate the color to the user because it has similar issues
00:20:07 <Peaker> ski, sure.. it's a pretty common theme/requirement
00:20:22 <edwardk> so color spaces are all bad approximations
00:20:22 <tgeeky_> edwardk: also, as a relevant fact that is to me a hint -- the reason I picked Rudvalis is: it has a moonshine (an OK fact), it has a string theory representation (it has a virasoro algebra and a superalgebra) (a really intresting fact to me). It also appears to be related to a discrete version of the quaternions (if such a thing is sensible).
00:20:44 <tgeeky_> edwardk: http://www.maths.qmul.ac.uk/~raw/talks_files/Bielefeld.pdf <--
00:21:22 <tgeeky_> Ru contains all of the W 'double algebras'
00:21:42 <edwardk> but none of that tells me how this finite group describes mapping between color spaces ;)
00:22:54 <tgeeky_> edwardk: If I had all the answers, I would be publishing a paper and not talking on #haskell :)
00:23:28 <\rs> is every usage of typeclass (including extension multiparam functionaldependency ...) can be mimicked in c++ template traits?
00:23:31 <edwardk> what i mean is i don't even get from your proposal a suggestion of how it even _can_ apply to this space
00:23:57 <edwardk> its like trying to screw in a lightbulb with a spork
00:24:04 <tgeeky_> that sounds like friday night
00:24:38 <startling> \rs, can every piece of x86 assembly be mimicked in brainfuck?
00:25:18 <ski> @type let (<*>) = fmap (uncurry ($)) .: aPair in (<*>)  -- oops
00:25:19 <lambdabot> forall (f :: * -> *) b b1. (Applicative f) => f (b -> b1) -> f b -> f b1
00:26:12 <edwardk> \rs: no. not sanely anyways, keep in mind haskell allows polymorphic recursion, templates have to be instantiated for all their possible types up front
00:26:24 <\rs> startling: could you give a counterexample? i've read C++ templates/traits versus Haskell type classes and get disappointed with its conclusion that typeclass can be emulated
00:26:33 <edwardk> \rs: i say not sanely because both are turing complete so their exists some asinine embedding both ways =P
00:27:10 <shachaf> edwardk: Polymorphic recursion. :-(
00:27:23 <shachaf> Should it make me sad?
00:27:30 <\rs> startling: though the c++ counterpart is wordy and ugly
00:27:53 <startling> \rs, I wasn't disagreeing with you
00:29:15 <tgeeky_> edwardk: the reason I posted the code in the first place, was just to find out if the kinds that I listed indicate that the structure will be impossible to inhabit (or not)
00:29:32 <edwardk> i didn't see code
00:29:40 <tgeeky_> heh
00:29:42 <edwardk> i just saw colorimetry come up as a topic
00:30:21 <tgeeky_> so the guy who doesn't understand the code tells me I don't understand color, and that guy who does understand color misses the code!
00:30:38 <tgeeky_> edwardk: http://hpaste.org/71761
00:31:31 <edwardk> now the guy who understands color also doesn't understand the code ;)
00:31:37 <tgeeky_> edwardk: :)
00:31:47 <edwardk> what are you modeling with each of those types?
00:33:02 <\rs> edwardk: computationally equivalence doesn't imply expression ability, doesn't it?
00:33:18 <edwardk> \rs: correct
00:33:45 <edwardk> \rs: anyways, the polymorphic recursion example is the most damning for those who try to claim templates can do everything typeclasses can do
00:34:10 <edwardk> \rs: and partial template specialization is something that you _shouldn't_ do with overlapping/incoherent instances in haskell
00:34:23 <edwardk> so there is functionality that each provides that the other does not adequately cover
00:34:43 <shachaf> They're pretty different in all sorts of ways.
00:34:44 <edwardk> and the fact that each can supply those features in turn is why the other thing isn't handled well by it
00:34:47 <edwardk> sure
00:35:39 <\rs> edwardk: the SFINAE principle has no counterpart in typeclass but it can be emulated by wrapping/unwrapping?
00:35:43 <edwardk> templates try to resolve at compile time all the possible ways you are going to instantiate them, type classes just set up the building blocks
00:37:34 <\rs> the template approach instantiates a function specific for every instance it encounters, so this is the reason that it doesn't support polymorphic recursion?
00:37:47 <edwardk> SFINAE is kind of goes against the grain of haskell.
00:37:52 <edwardk> yes
00:40:27 <edwardk> SFINAE lets you sneaky introspect to find out if instances/declarations are in scope, etc. thats all information we don't let you have here
00:41:35 <edwardk> er sneakily
00:55:03 <ski> \rs : maybe the fact that type class methods can be overloaded on return type is somehow relevant, as well ..
00:55:59 <ski> \rs : re equivalences, it's also interesting whether a translation is local or global (requiring one to translate arbitrary third-party libs)
00:56:07 <ski> "SFINAE" ?
00:56:34 <archeyDevil> Can someone please help me? In an attempt to learn haskell better- I'm trying out Happastack; I'm having some issues understanding how to split sections from the input..
00:56:39 <archeyDevil> main = simpleHTTP nullConf path $ \s -> ok $ "hello, " ++ s
00:57:04 <augur> ski: should i mention the difference between proof terms on the one hand and elements of a set on the other? and "types" as syntactic objects vs. "types" as sets?
00:57:27 <augur> if i dont mention the semantic side, i should remove mention of \times from my abstract, i feel
00:57:41 <archeyDevil> That works, however, it doesn't catch multiple words and I'd like to split it up a bit.. (Intended use /page-id-number/title-if-is-wrong-auto-redirrect-by-pageid-for-seo
00:58:52 <archeyDevil> Hmm. it cuts at the / so I'm using the wrong function for a start.
00:59:14 <dmwit> ski: I just looked it up on Wikipedia. It's horrible.
00:59:19 <ski> augur : hm, i think the first one is good, since it's part of the point of CH (finding that analogy/correspondence)
00:59:47 <augur> ski: but i think the analogy/corespondence is between propositions and types
00:59:53 <augur> types arent necessarily denotations, after all
01:00:11 <augur> i mean, the type [[ A * B ]] could be interpreted in any category with products, right
01:00:21 <\rs> ski: i'm actually writing a introductory slide about various of programming languages. i know it's imprudent as i'm merely a beginner for each language i display....
01:00:24 <augur> so it doesnt have to be cartesian products in Set
01:01:26 <ski> augur : i.e. seeing the analogy between function/pair/... types (/sets) and implication/conjunction/... propositions (and correspondingly for elements of the former and proofs of the latter) -- and also maybe the option of even identifying the two (but then in some cases, it's nice to keep a distinction between proofs which are computationally forgotten and ones which aren't)
01:01:38 <augur> there's this sort of tri-partite distinction here, i feel -- ND proofs/props are just LC terms/types, which have BHK interpretations
01:01:53 <\rs> \rs: SFINAE forms the base of a whole of rules to deal with overloaded instances and such in c++ templates
01:02:12 <ski> augur : well, now you're talking Curry-Howard-Lambek. the original CH was between propositions and types/sets, i think
01:02:37 <augur> ski: was it? i havent read the original papers on CH
01:03:13 <ski> augur : i'm not sure i have either, but i have the distinct impression that the CT link was only appreciated later
01:03:24 <augur> ski: well, i dont mean just the CT link
01:03:43 <augur> ski: what i mean is any interpretation of the simply typed LC
01:03:58 <augur> BHK, boolean algebras, etc.
01:04:16 <augur> i feel saying & <=> * is about the BHK interpretation
01:04:24 <augur> as opposed to the CHC
01:04:25 <ski> if we forget alternative products (e.g. in topoi or monoidal closed cats), then i think the products here are more or less the cartesian products in `Set'
01:04:52 <augur> sure, or they're intersection, as in the Set-based boolean algebra
01:05:29 <hpaste> tgeeky_ annotated “is this isom actually possible to implement in some domain?” with “is this isom actually possible to implement in some domain? (annotation)” at http://hpaste.org/71761#a71764
01:05:36 <ski> \rs : (itym s/\\rs:/ski:/) well, one good point with being a beginner is that you (hopefully) haven't yet forgotten what things were hard/new to learn in the language
01:06:37 <augur> ski: thats why i want to distinguish CHC from the interpretation of the LC, because the CHC holds with no variation -- proofs are terms, propositions are types -- while interpretations vary
01:07:10 <augur> we have a language of proofs/propositions//terms/types on the one side, and we have the semantics of it on the other side
01:07:10 <ski> augur : "there's this sort of tri-partite distinction ...","i feel saying & <=> * is about the BHK interpretation" -- hm, you may be right, i'm not sure
01:07:25 <augur> im going to stick with that, because it lets me talk about different interpretations as well
01:08:00 <ski> tgeeky_ : you didn't answer my avariance question :)
01:08:23 <ski> augur : hm, i'm not sure i see the boolean algebra connection
01:08:39 <augur> ski: well, the standard interpretation of propositional logic is as a boolean algebra
01:08:40 <ski> (to CH, i.e.)
01:08:54 <augur> classical propositional logic that is
01:09:00 <ski> yes
01:09:11 <ski> how does that connect to CH ?
01:09:15 <augur> oh, it doesnt
01:09:18 <ski> oh, ok
01:09:31 <augur> im just saying that we dont want to fix a particular interpretation
01:09:34 <augur> i mean
01:09:39 <augur> we dont want to say & = cartesian product
01:09:48 <augur> because thats fixing the BHK interpretation
01:09:53 <ski> how would you interpret LC in terms of BA ?
01:10:21 <augur> ski: well, i dont know how substitution would work, so it might not be possible, i dont know. i'm going to have to check.
01:10:35 <tgeeky_> ski: I put it in there to represent the overall fixing (choosing the major and minor column to affix the 8)
01:10:43 <augur> but that said, we could at least interpret LC in any interpretation of intuitionistic propositional logic
01:11:05 <ski> augur : "... -- proofs are terms, propositions are types -- while interpretations vary","we have a language of ..." -- i see your side
01:11:07 <augur> ski: i dont think the STLC can be interpreted in an arbitrary BA, actually
01:11:18 <tgeeky_> ski: that explains the o. I did the i for symmetry (for fixing a major and minor (only 2) row), instead
01:11:20 <augur> but i do think that the untyped LC probably can
01:11:25 <startling> edwardk: I think I'm misunderstanding something fundamental about trifecta. what does >>= do for MonadParsers?
01:11:47 <ski> augur : "we dont want to say & = cartesian product","because thats fixing the BHK interpretation" -- ok
01:11:56 <edwardk> parse the first thing, get the answer, and determine what to parse next
01:12:13 <ski> tgeeky_ : ok, so it's a phantom of some sort
01:12:32 <ski> (no idea what "choosing the major and minor column to affix the 8" means)
01:12:34 <augur> ski: talking to you about these things the last few days has been great, btw. <3
01:12:53 <tgeeky_> ski: http://arxiv.org/pdf/math/0609449v2.pdf <-- see page 35
01:12:59 <tgeeky_> ski: it's a phantom, but it's an arbitrary phantom
01:13:22 <ski> augur : yeah, attempting to explain what i implicitly "know" has made some stuff clearer to me as well :D
01:13:22 <startling> edwardk: so it sequences two parsers?
01:13:33 <edwardk> startling: yes
01:14:00 <edwardk> startling: trifecta shouldn't do anything too surprising if you are used to parsec
01:14:19 <edwardk> startling: the main difference is support for monad transformers and better diagnostics
01:14:28 <augur> ski: well, its more than that for me. i very rarely have someone i can have such technical discussions with. either my interests are too divergent, or the person doesn't have time
01:14:59 <ski> (sigh, 403 on that link ..)
01:15:15 <startling> edwardk: k. so what am I doing wrong when I'm trying to (>>=) two MonadParser m => m String?
01:15:30 <edwardk> startling: you probably mean to use >> or *>
01:15:34 <edwardk> :t (>>=)
01:15:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:15:39 <edwardk> :t (>>)
01:15:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
01:15:56 <edwardk> :t (*>)
01:15:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
01:16:09 <edwardk> see the a -> m b?
01:17:08 <tgeeky_> ski: hmm? 403? which error is that?
01:17:10 <startling> oh! man, I was confused
01:17:19 <augur> ski: http://wellnowwhat.net/Programming/Curry-Howard.pdf   can you comment on the typographical and naming conventions?
01:17:23 <startling> edwardk: thanks!
01:18:11 <augur> ski: im using evocative names, upper italics for propositions, lower italics for variable/hyp names, upper greek for contexts/hyp sets, and upper script for proof trees
01:18:45 <augur> upper italics also get used in rule names
01:19:04 <augur> and lower italics get used for constructor names when i rename things to be more familiar
01:19:28 * hackagebot GenericPretty 1.2.0 - A generic, derivable, haskell pretty printer. (RazvanRanca)
01:19:38 <augur> i think i should probably use something other than italics for rule names, at least. like sans serif
01:19:43 <augur> i like sans serif in latex, its pretty
01:22:37 <ski> tgeeky_ : "Forbidden", due to `wget'
01:23:40 <tgeeky_> ski: ahh. They don't like download bots over there. I was banned from there because of how my browser was behaving
01:24:11 <tgeeky_> downloading too many papers in a session or something
01:25:27 <ski> tgeeky_ : yeah, i managed to tell `w3m' to use `gv' instead of `evince' (which is a pig), so it's all ok now
01:26:34 <ski> augur : well, i find this kind of topic fun ;) (and hopefully i'll even learn a thing or two myself)
01:26:44 <silver> why it's a pig?
01:26:53 <ski> hogging memory
01:27:03 <tgeeky_> i really just want to develop an intuition for kind signatures
01:27:14 <silver> ski, you don't read djvus?
01:28:08 <ski> each `evince' process here seems to each around `180M', while `gv' seems to eat around `7M'
01:28:25 <ski> (and i have maybe 20 papers open, and not too much RAM here)
01:28:43 <silver> oh
01:28:47 <ski> silver : hm ?
01:29:04 <silver> http://en.wikipedia.org/wiki/DjVu
01:29:20 <silver> some books I encounter use this
01:29:36 <silver> evince is capable of viewing pdf and djvu
01:29:49 * ski isn't sure this system has a reader for that -- i rarely seem to encounter that format
01:29:53 <ski> ok
01:29:57 <solrize> anyone use debian here?  i'm trying to install haskell platform 2012.2 on a squeeze system using "apt-get -t install haskell-platform" and it installs a 2010 version of platform
01:30:18 <mroman> solrize: Which version you get depends on which debian version you have.
01:30:39 <solrize> i thought apt-get -t overrides that
01:30:41 <mroman> If you get 2010 you probably have sequeeze
01:30:47 <solrize> yes i have squeeze
01:30:53 <solrize> that's the current stable version
01:30:59 <mroman> For 2012 you need at least wheezy
01:31:04 <ski> maybe there's a backport or something
01:31:06 <solrize> oh hmm
01:31:11 <mroman> solrize: Yes, and stable versions always are behind current versions
01:31:22 <Botje> unstable has 2012.
01:31:31 <mroman> testing and unstable both have 2012
01:31:31 <Botje> but that won't help you much, i guess
01:31:40 <solrize> i thought the idea of stable version was that the defaults were all older versions but i could install newer versions of specific packages
01:31:59 <mroman> No, the idea of stable is that they have tested a specific version of it
01:32:05 <solrize> hmm
01:32:08 <solrize> ic
01:32:08 <mroman> and packaged it so it works with any other package they provide
01:32:18 <solrize> can i just download the platform tarball and install it?
01:32:20 <mroman> which is why it takes them a long time to switch to new versions.
01:32:20 <ski> solrize : if you tell it to use a backport repo as well, i think one can do that (to the extent newer packages have been backported)
01:32:23 <solrize> it has a lot of dependencies
01:32:38 <solrize> hmm where would the backport repo be?
01:32:41 <mroman> That's a problem almost every linux distribution with a package manager has.
01:33:08 <mroman> They have to guarantee that everything works together ;)
01:33:14 <mroman> solrize: Or you could just build it from source.
01:33:19 <mroman> It takes hours though.
01:33:25 <ski> solrize : something like `deb http://backports.debian.org/debian-backports/ squeeze-backports main contrib non-free', maybe
01:33:36 <solrize> i don't remember what i did to install on my fedora box but it wasn't too hard
01:33:59 <merijn> hmmm, can conduits only be used for seqeuential processing? As far as I can tell from the explanations only one part of a conduit can be executing at a time?
01:34:04 <mroman> The Glorious Glasgow Haskell Compilation System, version 7.4.1 \o/
01:34:10 <mroman> Compiled in 1.5 hours.
01:34:41 <ski> maybe `deb http://ftp.se.debian.org/debian/ squeeze-updates main contrib non-free' and `deb-src http://ftp.se.debian.org/debian/ squeeze-updates main contrib non-free' as well
01:34:42 <solrize> i seem to remember downloading a big tarball and installing it
01:34:59 * ski has no idea whether this would include `haskell-platform'
01:35:12 <solrize> oh hmm i seem to be at 7.0.3 on fedora
01:35:25 <solrize> the 6.12 on squeeze doesn't compile quite a few hackage modules
01:35:40 <mroman> Latest is 7.4.2
01:35:51 <solrize> yeah maybe i should upgrade debian?
01:36:18 * ski . o O ( "better safe than sorry" )
01:36:44 <solrize> "deb" not found
01:37:00 <mroman> Although current HP is at 7.4.1
01:39:57 <startling> why shouldn't I use NoMonomorphismRestriction?
01:40:36 <solrize> the extra polymorphism can slow down your program badly
01:40:44 <startling> ah
01:41:00 <startling> but there's no harm for playing around with it in ghci?
01:41:32 <solrize> it's fine to do that
01:41:40 <startling> thanks!
01:44:26 <t7> if the curry howard corispondance means that simply typed lambda calc is equivalent to prop logic, how do i represent 'not x' as a type?
01:45:05 <solrize> x -> _|_
01:45:34 <solrize> x -> False
01:45:44 <solrize> is the proposition
01:46:02 <t7> x -> (x -> _|_)  = x ?
01:46:10 <merijn> STLC is equivalent to *intuitional* prop logic, not classic proc logic, right?
01:46:34 <merijn> intuitional prop logic doesn't have negation (other than "implies _|_" as solrize points out)
01:46:57 <alang> intuitionistic
01:47:07 <merijn> blah, close enough
01:47:11 <mroman> t7: Can you do or and and?
01:47:22 <mroman> If so, you can build not using those.
01:47:45 <t7> encode them as lambda pairs i guess?
01:47:52 <merijn> mroman: Why go through the trouble of implication and bottom exist?
01:48:06 <solrize> http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism
01:48:14 <mroman> t7: `xor` True is an Inverter
01:48:15 <t7> \x . \y . \f . f x y
01:48:27 <mroman> and xor is defined as ((not a) && b) || (a && (not b))
01:48:31 <mroman> which would make
01:48:37 <mroman> or wait.
01:48:50 <mroman> ok, it's not that simple
01:49:01 <mroman> it'll bloat up :)
01:49:18 <mroman> actually
01:49:30 <solrize> t7, and is tuples  x && y     =>    (x,y)
01:49:46 <solrize> x or y  is    Either x y
01:49:50 <solrize> the wikibook article is good
01:50:28 <ski> solrize : sorry, those were lines which you are meant to put in `/etc/apt/sources.list'
01:50:39 <ski> t7 : negation corresponds to continuations
01:50:43 <solrize> ski, aha, i wondered about that
01:50:46 <solrize> yeah that makes sense
01:51:02 <solrize> i think i want to leave out nonfree since haskell platform shouldn't need it
01:51:46 <solrize> this versioning stuff is a pretty bad disease
01:52:58 <mroman> Ok, I mixed things up :(
01:55:32 <ksf> blaze should have a Builder -> Integer length function
01:57:03 <startling> uh, is (<|>) no longer in trifecta? has it been renamed?
01:57:28 <mroman> That thing with the defaultsignatures does not work as expected.
01:57:32 <ski> t7 : "A Formulae-as-Types Notion of Control" by Timothy Griffin in 1990-01 at <http://www.cs.ru.nl/~freek/courses/tt-2011/papers/griffin.pdf>
01:57:47 <ksf> startling, Control.Applicative
01:57:48 <mroman> Could not deduce (Bits a) arising from a use of fromBools'
01:58:02 <mroman> bound by the class declaration for `BoolBits'
01:58:11 <ksf> mroman, you need standard type class instances, not deriving ones.
01:58:20 <t7> has anyone heard of something like agda-mode latex input for vim?
01:58:22 <ksf> (took me ten minuts to figure that out)
01:58:51 <mroman> I'm not deriving
01:58:56 <mroman> the idea was
01:58:57 <startling> ksf: oh what
01:59:12 <mroman> to define a default implementation for a function
01:59:31 <mroman> fromBools :: Endianness -> [Bool] -> a
01:59:35 <mroman> fromBools = fromBools'
01:59:49 <mroman> so that you can just write instance BoolBits Int
01:59:58 <mroman> but fromBools' has a (Bits a) =>
02:00:24 <ksf> startling, <|> is in Control.Applicative.
02:00:27 <startling> ksf: wow, never made the connection with Alternative.thanks!
02:01:56 <merijn> Can conduits only be used for seqeuential processing? As far as I can tell from the explanations only one part of a conduit can be executing at a time?
02:02:16 <Botje> mroman: then you need to push the Bits constraint into fromBools as well.
02:02:24 <mroman> ah.
02:02:30 <mroman> I'm missing the default keyword :)
02:03:03 <mroman> cool.
02:03:06 <merijn> Relatedly: splitting a single conduits to multiple sinks seems trivial (just have a state sink containing all possibilities and randomly pick one to push in), but is it possible to have multiple sources for one sink?
02:03:10 <mroman> ghci now even can define instances.
02:04:26 <ksf> merijn, if conduits are anything like iteratees, you just sequence the sources.
02:04:43 <ksf> for some combanatorial value of "sequence"
02:04:56 <ksf> there's also e.g. zip.
02:05:24 <ksf> and if you want to interleave parsers over another, there's uu-parsinglib.
02:06:09 <merijn> ksf: I was wondering how easy it would be to parallelise conduits. Because as far as I can see now they essentially process the input sequentially
02:06:32 <ksf> yes.
02:06:44 <ksf> I'd say reimplement the API on top of CHP.
02:06:52 <merijn> Whereas there doesn't seem to be any reason why they couldn't execute multiple steps in parallel (i.e. start computing conduit 2 as soon as and while conduit 1 is producing output)
02:06:58 <merijn> CHP?
02:06:59 <ksf> replace continuation passing with channels.
02:07:05 <ksf> concurrent haskell processes.
02:07:29 <merijn> You mean forkIO and channels? Yeah, that was my original plan
02:07:29 <ksf> *communicating
02:07:40 <ksf> http://www.cs.kent.ac.uk/projects/ofa/chp/
02:08:10 <ski> t7 : also see `force',`phi',`negate',`thunk',`conttofun',`funtocont',`delay' (reading `cont' as negation) in "Continuation passing style and self-adjointness" by Hayo Thielecke in 1996  at <http://www.cs.bham.ac.uk/~hxt/research/cw97final.ps>
02:08:33 <merijn> ksf: Ha, that looks like it might obsolete the entire research project I wanted this for :p
02:08:35 <t7> ah cheers
02:09:36 <ski> `force' is double-negation-elimination, `thunk' is double-negation-introduction, `phi' is one form of contraposition, `conttofun' and `funtocont' relates `A -> B' and `not (A /\ not B)'
02:10:08 <ski> t7 : also, it's possible to prove (in Haskell syntax) `Either (Not a) a' there
02:10:20 <ksf> merijn, if you want you could replace it by one that implements a gui framework on top of chp.
02:10:45 <ksf> I'd say its sufficiently alike as well as different from frp so that it could just work.
02:11:24 <ski> merijn : arguably `not A' is isomorphic to `A -> _|_' in intuitionistic and classical and linear logic ..
02:12:19 <ski> solrize : sure
02:12:47 <ski> @index <|>
02:12:47 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
02:13:17 <ski> hm, apparently it doesn't see `Control.Applicative'
02:13:22 <merijn> Semi-related question, writing data into a Chan doesn't copy it, right? (at least I hope)
02:14:48 <ski> merijn : i probably don't know the answer, but i wonder if by "multiple sources for one sink" you mean the inputs getting merged nondeterministicall, on a first-come-first-serve basis ? (which is one step away from declarative concurrency)
02:15:10 <solrize> merijn, it just copies a pointer, which may be to an unevaluated thunk
02:15:22 <solrize> so be careful, you can end up making the other side eval it
02:15:35 <ski> augur : before you had `/\E_L', now you have `/\EL' (imo not as nice). maybe not italic on `true' (you don't have it on `|-' and `:') -- hm, i see you switched hypothese introduction from superscript to subscript. you may or may not want to note that if we disallow unused assumptions, we get relevant/relevance logic. (the "active" vs. "inactive" naming is your terms, yes ?)
02:15:37 <solrize> sort of defeating any parallelism you might have hoped for
02:15:40 <ski> augur : maybe s/when `a' does not appear in `F'/when `a' does not appear freely in `F'/. maybe you should emphasize more that beta rules are about "elim after intro", while eta rules are about "intro after elim", and that these two groups in some sense belongs together
02:15:59 <merijn> ski: non-deterministically is good enough for me
02:16:12 <augur> ski: i want to avoid using subscripts for things that arent variables
02:16:21 <merijn> solrize: Yeah, but in this case it'll mostly be FFI data and I just wanted to be sure I wouldn't be copying big arrays
02:16:50 <ski> merijn : hehe, well generally one'd prefer non-deterministically to arbitrarily prescribing a certain interleaving order a priori :)
02:17:03 <ski> augur : yeah, i realized
02:17:04 <augur> ski: as for relevant logic, i mention later that how we manage hypotheses/contexts affects the logic. active/inactive is, i dont know, i think mine? im not sure if ive seen it elsewhere
02:17:23 <absence> i wanted to try the example at the top of http://hackage.haskell.org/packages/archive/monad-coroutine/0.7.1/doc/html/Control-Monad-Coroutine.html (i.e. the producer function), but ghc says No instance for (MonadTrans (Coroutine (Yield Int))). am i missing something?
02:17:33 <ski> augur : how about superscript for variants, like `/\E^0'/`/\E^L' ?
02:18:18 <augur> ski: also, i dont want to say that eta is intro after elim, since its not always (as with Or) but ill mention something about that.
02:18:34 <ski> well, "morally" it is :)
02:18:40 <augur> ski: what do you mean superscript for variables? you mean use &E^L instead of &EL?
02:18:48 <augur> ski: morally i dont know. :p
02:19:06 <augur> this is what my earlier quibling about local soundness and completeness was about
02:19:15 <merijn> ski: Well, our current C implementation has a deterministic (round-robin) implementation of merging to, but I could make it work with just non-deterministic (or steal our C deterministic implementation, since it is implemented on top of the non-deterministic C implementation anyway)
02:24:36 <t7> is there a class in the platform for navating trees? like Zippable or something?
02:24:42 <t7> navigating *
02:25:04 <mroman> Cabal has support for quickcheck of some sort?
02:25:46 <augur> ski: i should get in the habit if writing semantic latex
02:26:34 <ski>   Gamma |- A                Gamma , A |- C   Gamma , B |- C
02:26:43 <ski>   --------------- |- \/^0   ------------------------------- \/ |-
02:26:48 <ski>   Gamma |- A \/ B           Gamma , A \/ B |- C
02:26:51 <ski>   --------------------------------------------- cut
02:26:52 <ski>   Gamma |- C
02:26:55 <augur> O_O
02:27:06 <ski> is the translation of the beta-rule into sequent calculus
02:28:11 <ski>   Gamma |- A    Gamma , A |- C
02:28:14 <ski>   ---------------------------- cut
02:28:14 <ski>   Gamma |- C
02:28:20 <ski> is the other side of the equation
02:28:32 <augur> hmm
02:28:50 <augur> but thats using \/ |- and cut, as opposed to the extant rules
02:29:03 <augur> you need left rules and also cut, which im not looking to get into
02:29:12 <ski> yes, beta-reduction corresponds to cut-elimination
02:29:38 <ski> the cut-elimination makes a left-rule and a right-rule interact
02:30:15 <ski> note how we went from cutting on `A \/ B' to cutting on (the simpler) `A' above
02:30:43 <augur> it seems clear to me now, but only now, after writing this tutorial, that cut = substitution
02:31:03 <augur> as opposed to cut = composition, which always seemed weird to me.
02:31:11 <augur> but now realizing that substitution = external composition
02:31:16 <augur> it makes sense
02:31:23 <ski> then we continue, based on the structure of `A', and the structure of the derivations of `Gamma |- A' and `Gamma , A |- C' (we often need to commute some rules to get hold of ("float up") a left- and a right- rule to interact with each other)
02:31:55 <t7> i wanna make a game based on theorem proving using only rewriting
02:32:12 <t7> so ideally i only want /\ \/ and ¬
02:32:57 <t7> Just need to work out which re-write rules would be simplest/most-fun but still complete
02:34:53 <mroman> Hm.
02:34:59 <mroman> Do I need to export every function of a class?
02:35:13 <mroman> fascinating.
02:35:40 <t7> mroman: MyClass (..) ?
02:35:51 <t7> (not sure if that works)
02:36:11 <mroman> @hoogle test
02:36:12 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
02:36:12 <lambdabot> Test.HUnit.Base data Test
02:36:12 <lambdabot> Test.QuickCheck.Test test :: State -> (StdGen -> Int -> Prop) -> IO Result
02:36:38 <mroman> Those examples on the wikibook seem broken.
02:36:49 <mroman> there is no test in Test.QuickCheck
02:37:15 <ski>   ---------------- id
02:37:21 <ski>   A \/ B |- A \/ B
02:37:24 <ski> expands to
02:37:29 <ski>   ------ id             ------ id
02:37:32 <ski>   A |- A                B |- B
02:37:35 <ski>   ----------- |- \/^0   ----------- |- \/^1
02:37:39 <ski>   A |- A \/ B           B |- A \/ B
02:37:44 <ski>   --------------------------------- \/ |-
02:37:45 <ski>   A \/ B |- A \/ B
02:37:58 <tomboy64> wtf
02:38:00 <ski> by id-introduction/expansion
02:38:10 <ski> augur : this corresponds to eta-conversion
02:38:12 <augur> ski: im pretty sure that cut elimination is just the definition of substituion
02:38:18 <augur> ski: thats my guess anyway, i havent checked
02:38:33 <mroman> how do I run a quickCheck Test?
02:38:39 <ski> augur : well, there's the issue of commuting other rules as well involved
02:38:41 <mroman> main = mapM_ (\(s,a) -> printf "%-25s: " s >> a) tests
02:38:53 <mroman> where tests = [("name", test function)] does not work
02:38:58 <augur> ski: oh?
02:39:08 <mroman> in the sese that test does not exist and Text.QuickCheck.Test.test seems to be something else
02:39:12 <mroman> *sense
02:39:34 * hackagebot Contract 0.1 - Practical typed lazy contracts. (OlafChitil)
02:40:01 <companion_cube> ski: do you have a tool to write those ascii-sequent proofs? :D
02:41:13 <augur> ski: example of this commutation?
02:41:22 <augur> companion_cube: i think the tool is called a text editor :P
02:41:47 <ski> augur : if we have a cut on `A /\ (B \/ C) |- B \/ C' and `(C \/ B) -> D , B \/ C |- D' where these two are derived by `|- /\^0' and `-> |-', then we have to do some commutations, to get at the left- and right- rules for `\/'
02:42:24 <ski> companion_cube : the tool is irssi
02:42:29 <mroman> Hm.
02:42:59 <mroman> How can people write introductions to QuickCheck WITHOUT mentioning how to actually run it.
02:43:37 <Eduard_Munteanu> ski: so, you simply write something, press down, write something else etc.. then you send them all one by one?
02:43:44 <companion_cube> too bad :)
02:44:10 <ski> mroman : `quickCheck :: Testable prop => prop -> IO ()' ?
02:44:14 <augur> ski: hmm...
02:44:15 <mroman> where is quickCheck
02:44:20 <mroman> @hoogle quickCheck
02:44:20 <lambdabot> package QuickCheck
02:44:20 <lambdabot> Test.QuickCheck.Test quickCheck :: Testable prop => prop -> IO ()
02:44:20 <lambdabot> Test.QuickCheck quickCheck :: Testable prop => prop -> IO ()
02:44:24 <ski> @index quickCheck
02:44:24 <lambdabot> Test.QuickCheck, Debug.QuickCheck
02:44:41 <augur> ski: im not sure i follow.
02:44:56 <augur> ski: i'd need to see it actually eliminate
02:45:39 <mroman> Tests.hs:8:40: Ambiguous type variable `a0' in the constraints:
02:46:03 <mroman> ah.
02:46:06 <mroman> Ok.
02:46:08 <mroman> Done.
02:48:04 <bitonic> how can I link to modules in Haddock?
02:48:06 <bitonic> if I can
02:49:22 <tgeeky> 'Fully.Qualified.Name'
02:50:45 <bitonic> tgeeky: that does not work (I want to link to the *module* not to some type/value)
02:51:08 <tgeeky> "Fully.Qualified.Module" ?
02:51:42 <bitonic> tgeeky: I already said that that does not work :P
02:52:16 <tgeeky> there is a difference between single and double quotes, I think
02:52:22 <tgeeky> I just can't ever remember which is which
02:52:24 <bitonic> ah
02:52:28 <ski> augur : let's take a more abstract situation :
02:52:33 <ski>                Gamma , A |- B   Gamma , A , C |- D
02:52:38 <ski>                ----------------------------------- -> |-
02:52:43 <bitonic> tgeeky: you're right! thanks.
02:52:47 <ski>   Gamma |- A   Gamma , A , B -> C |- D
02:52:51 <tgeeky> bitonic: most welcome
02:52:52 <ski>   ------------------------------------ cut
02:52:57 <ski>   Gamma , B -> C |- D
02:53:07 <liyang> tgeeky: "Modules" and 'values' or 'types'
02:53:09 <ski> which commutes to
02:53:14 <ski>   Gamma |- A   Gamma , A |- B       Gamma |- A   Gamma , A , C |- D
02:53:17 <ski>   --------------------------- cut   ------------------------------- cut
02:53:21 <ski>   Gamma |- B                        Gamma , C |- D
02:53:27 <ski>   ------------------------------------------------ -> |-
02:53:28 <ski>   Gamma , B -> C |- D
02:54:15 <ski> augur : in this case we get more `cut's (the proof becomes wider), and it doesn't become shallower, but the `cuts' are closer to the leaves/axioms/hypotheses
02:54:20 <augur> ski: hm. im going to have to sit down and write these out in ND trees to see whats going on
02:55:41 <augur> ok lemme do that now that im done poking around with my tutorial's formatting
02:55:57 <ski> augur : in the case of beta-reduction and ND, we have stuff like `fst (case e of Left x0 -> e0; Right x1 -> e1)  =  case e of Left x0 -> fst e0; Right x1 -> fst e1' -- this is a *local* transformation rule which can be very handy (e.g. inside GHC), even if globally, we can just "evalaute" the `case' first instead
02:58:00 <archeyDevil> Any reason the /topic is an array?
02:58:25 <shachaf> It's not.
02:59:01 <archeyDevil> shachaf: Techniqually, no. But visually and importable into ghci and it'll give type Array
02:59:42 <ski> augur : also `case case e of Left x0 -> e0; Right x1 -> e1 of Left y0 -> f0; Right y1 -> f1  =  case e of Left x0 -> case e0 of {Left y0 -> f0; Right y1 -> f1}; Right x1 -> case e1 of {Left y0 -> f0; Right y1 -> f1}'
02:59:50 <archeyDevil> i.e Is it just to be a little creative? Set via the bot?
02:59:58 <ski> (which is `\/^E' commuting with itself)
03:00:36 <ski> @help topic
03:00:37 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
03:00:42 <ski> @help topic-tell
03:00:43 <lambdabot>  @topic-tell #chan -- Tell the requesting person of the topic of the channel
03:00:49 <augur> ski: whats the ND version -> |-?
03:01:04 <ski> augur : modus ponens / implication-elimination
03:01:18 <augur> i cant see how
03:01:29 <t7> can i make a transversable instance for my data type that has kind *
03:01:31 <t7> ?
03:02:48 <mroman> @hoogle [a] -> Int -> [[a]]
03:02:49 <lambdabot> Prelude drop :: Int -> [a] -> [a]
03:02:49 <lambdabot> Data.List drop :: Int -> [a] -> [a]
03:02:49 <lambdabot> Prelude take :: Int -> [a] -> [a]
03:02:59 <mroman> ok, no.
03:03:28 <ocharles> Anyone know how to turn a POSIX file descriptor into a socket?
03:03:33 <augur> ski: aha, got it i think
03:03:36 <ocharles> I can turn it into a Handle, but I can't work out how to get a Socket
03:04:56 <ski>   Gamma |- A -> B   Gamma |- A
03:04:59 <ski>   ---------------------------- ->E
03:05:04 <ski>   Gamma |- B
03:05:06 <ski> becomes
03:05:11 <ski>                                  -------------- hyp
03:05:15 <ski>                     Gamma |- A   Gamma , B |- B
03:05:21 <ski>                     --------------------------- -> |-
03:05:25 <ski>   Gamma |- A -> B   Gamma , A -> B |- B
03:05:29 <ski>   ------------------------------------- cut
03:05:30 <ski>   Gamma |- B
03:05:46 <ski> i'll let you figure out the converse translation :)
03:06:05 <shachaf> archeyDevil: No, it won't.
03:07:26 <archeyDevil> shachaf: a :: [[Char]]
03:07:37 <ski> (and of course, if you compose the two directions, you should get translations that translate proofs into proofs which are equivalent, modulo some small rewriting)
03:07:50 <archeyDevil> Array of (array of chars|strings)
03:08:03 <ski> that's not an array, that's a list
03:08:27 <archeyDevil> Same thing.
03:08:29 <ski> archeyDevil : "Is it just to be a little creative? Set via the bot?" -- yes
03:08:33 <ski> hehe, not really
03:08:51 <triyo> There are quite a few ways to report and handle errors in Haskell. Is there a preferred way or does each approach have distinctive features that should be contextual to the problem in hand?
03:09:03 <liyang> ocharles: http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html#v:mkSocket
03:09:04 <ski> arrays have constant-time lookup (modulo memory hierarchies -- really it's logarithmic)
03:09:27 <ski> lists in Haskell are single-linked lists, must be accessed in order (linear time lookup)
03:10:00 <ski> @type let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix body = array ix [(i,body i) | i <- range ix] in tabulate
03:10:02 <lambdabot> forall i e. (Ix i) => (i, i) -> (i -> e) -> Array i e
03:10:11 <archeyDevil> Good night all..
03:10:16 <ski> > tabulate (0,9) $ \i -> i^2
03:10:18 <lambdabot>   Not in scope: `tabulate'
03:10:19 <ski> is an array
03:10:26 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix body = array ix [(i,body i) | i <- range ix]
03:10:28 <lambdabot>  Defined.
03:10:29 <ski> > tabulate (0,9) $ \i -> i^2
03:10:33 <lambdabot>   array (0,9) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,...
03:10:48 <ski> > (tabulate (0,9) $ \i -> i^2) ! 5  -- array indexing
03:10:51 <lambdabot>   25
03:10:54 <ski> archeyDevil : good night
03:11:00 <archeyDevil> Night ski
03:11:56 <mroman> Matching instances: instance BoolBits Int -- Defined at Data/BoolBits.hs:52:10 instance BoolBits Int -- Defined at Data/BoolBits.hs:52:10
03:11:59 <mroman> ^- uhm...
03:12:06 <mroman> wtf?
03:13:42 <solrize> triyo error handling is a big mess   there was just a pretty nice blog rant about it
03:14:05 <solrize> http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html
03:14:17 <solrize> it says use Either for everything
03:14:19 <triyo> solrize: thanks for the link
03:14:34 <triyo> Hehe, well thats what I've been doing so far.
03:14:40 <triyo> Either e a
03:14:53 <solrize> i'd like to know if that generates multiple levels of tests when you error out of multiple nested ones
03:14:57 <mroman> Declaring instances in ghci breaks stuff :(
03:15:06 <solrize> also it seems to me that you really do need exceptions sometimes
03:15:12 <mroman> if I do instance BoolBits Word8 in ghci, I get overlapping instances for Int
03:15:22 <mroman> if I do instance BoolBits Word8 in my .hs file, it works fine.
03:15:49 <triyo> solrize: well sometimes exceptions just seem a cleaner approach
03:15:52 <ski> triyo : maybe try <http://www.haskell.org/haskellwiki/Error_reporting_strategies>,<http://www.haskell.org/pipermail/haskell-cafe/2011-March/089766.html>
03:16:30 <triyo> ski: thanks, I'll check those out too
03:16:53 <ski> augur : any comment on the above translation example ?
03:17:33 <augur> ski: working on it
03:19:37 * hackagebot sundown 0.5 - Bindings to the sundown markdown library (FrancescoMazzoli)
03:20:07 <ski> (triyo : the latter was just an example of a mailing list post, there are probably more interesting posts on error handling in there)
03:20:30 * ski misread "sundown markdown" as "sundown market"
03:23:41 <augur> ski: interesting. i just wrote down the ND proofs involved and they end up being identity
03:24:05 <augur> ski: so its related to associativity of composition
03:25:02 <ski> augur : and `id' being identity of composition as well
03:25:24 <ski> augur : and, categorically speaking, stuff like `<f,g> . h  = <f . h,g . h>'
03:25:25 <augur> ski: do you have a ref for defining cut elimination locally so that it produces such results?
03:25:46 <augur> like, locally as in pushing it through individual rules, not whole trees?
03:26:20 <augur> or, well, i guess this is one such thing
03:26:21 <augur> nevermind
03:26:22 <augur> hmm
03:26:26 <ski> augur : hm, not that i can recall atm. maybe Girard or Blass someone there has it (e.g. in comparision to how it works in linear logic presented in sequent calculus)
03:27:43 <ski> augur : well, you agree that if `e',`e0',`e1' are closed (the latter two upto `x0' and `x1'), we can evaluate the `case' in `fst (case e of Left x0 -> e0; Right x1 -> e1', instead of distributing `fst' inside the branches ?
03:28:21 <ski> however, this may require doing an unbounded amount of work (i.e. bounded in some way by the complexity of `e',`e0',`e1')
03:28:32 <ski> the local rule above side-steps this
03:28:38 <augur> ski: i dont know what i agree with
03:28:43 <augur> i havent gotten there yet :)
03:28:50 <augur> i was just looking at the -> example
03:28:55 <augur> which was very enlightening
03:29:02 <ypo> @help
03:29:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:29:15 <augur> @i need somebody
03:29:15 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
03:30:56 <ski> of course the commutation is an admissability result : you have to prove it by considering each possible shape of the `e',`e0',`e1' derivation trees, branching on the different rules -- so if you add rules to the logic, you have to recheck that this commutation is still valid in the presence of those (most commonly, but not always as simple as, just adding a new case to the induction proof)
03:31:12 <ski> (cut-elimination itself is of course also an admissability result)
03:31:58 <augur> ski: i wish there were a good resource for this. every proof theory book ive looked at just says "heres the sequent calculus, lets do cut stuff"
03:31:59 <ski> though i suppose one could maybe take the commutations as axioms (similarly how one takes the deduction theorem / implication-introduction for granted in ND, instead of having to prove its admissibility as in Hilbert-style)
03:32:14 <augur> ski: but the intuitions about these things really come from ND
03:32:18 <ski> augur : i think i've mostly learned this stuff by osmosis
03:32:34 <augur> and without a nice connection between the ND/Sequent versions, its hard to understand
03:32:36 <hpaste> mbuf pasted “How to use S.head” at http://hpaste.org/71768
03:32:50 <augur> but now that i have such a thing, im going to go back and look at some proof theory books again
03:33:10 <augur> ski: i feel like i should write this stuff up to as part of the tutorial
03:33:20 <augur> ski: maybe as part 2 of the tutorial.
03:33:24 <augur> hell, i could write a whole book!
03:33:24 <augur> :p
03:33:53 <ski> augur : yea, understanding the mapping there-and-back-again between the rules of sequent calculus and natural deduction is probably key
03:34:23 <augur> ski: understanding as in groking tho. which for me requires pictures.
03:34:23 <ski> sequent calculus is often nicer in that it's more symmetrical
03:34:41 <ski> but natural deduction is more familiar since it's (solely) expression-focused
03:34:49 <augur> more symmetrical?
03:35:44 <ski> (well, it's possible to formulate an expression-focused version of sequent calculus as well, employing subtitution all over the place -- but that's not the common way to do, i think)
03:35:52 <fmap> mbuf: is it a question?
03:35:59 <mbuf> fmap: yes
03:36:07 <mbuf> fmap: BTW, nice nick
03:36:54 <fmap> mbuf: I've not used Data.Stream but looks like you want `S.fromList' instead of `S.Cons'
03:37:08 <ski> augur : yeah, compare `\/I^i',`\/E' vs. `/\I',`/\E^i' and `|-\/^i',`\/|-' vs. `/\^i|-',`|-/\'
03:37:21 <ski> in the latter (sequent calculus) case, the rules are much more symmetric
03:37:24 <mbuf> fmap: will try, http://hackage.haskell.org/packages/archive/Stream/0.4.6/doc/html/Data-Stream.html
03:37:49 <ski> (in fact, exact duals, if you take classical logic (or single-premise, single-conclusion as in categorical logic))
03:39:21 <mbuf> fmap: worked . thanks!
03:39:28 <fmap> yw
03:39:45 <ski>   Gamma , x0 : A0 |- e[x / fst x0] : B
03:39:48 <ski>   ----------------------------------------- /\^0 |-
03:39:49 <ski>   Gamma , x : A0 \/ A1 |- e : B
03:40:13 <ski> augur : is the (somewhat strange) expression-focused sequent calculus thing
03:40:26 <ski> er, replace `\/' with `/\', of course
03:40:45 <ski> (and of course i goofed up the substitution syntax ..)
03:41:13 <dmwit> Don't worry, if you can imagine a variation on substitution syntax, it's been done.
03:41:36 * ski nods sadly
03:41:53 <ptarsa> hi
03:41:58 <ski> hellp ptarsa
03:42:06 <ski> eh, s/hellp/hello/ :)
03:42:11 <ptarsa> i'm learning haskell and i have a small problem
03:42:27 <ptarsa> on http://learnyouahaskell.com/higher-order-functions there is a sentence: One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list. However, if you take an infinite list at a point and you try to fold it up from the left, you'll never reach an end!
03:42:38 <ptarsa> how can folds work on infinite list?
03:42:52 <ski> because of laziness
03:42:53 <ptarsa> how can i "take an infinite list at some point"?
03:43:08 <Cale> foldr f z [] = z
03:43:17 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
03:43:25 <Cale> look at that second equation
03:43:32 <ski> > foldr f (error "never used") (cycle [a,b,c,d]) :: Expr
03:43:35 <lambdabot>   f a (f b (f c (f d (f a (f b (f c (f d (f a (f b (f c (f d (f a (f b (f c (...
03:44:08 <Cale> foldr f z (x:xs) immediately passes control to f
03:44:12 <ski> ptarsa : if some `f' call here doesn't use its second argument (or at least doesn't require it to compute it's "main" result), then this terminates
03:44:16 <Cale> under outermost-first evaluation
03:45:01 <ski> > foldr (\a n -> if a < 10 then a + n else 0) 1000 [0 ..]
03:45:02 <lambdabot>   45
03:45:06 <ski> > foldr (\a n -> if a < 10 then a + n else 0) 1000 [0 ..] :: Expr
03:45:07 <lambdabot>   0 + (1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + 0)))))))))
03:45:08 <Cale> If f never examines its second parameter before producing some or all of its output, then the recursion won't continue immediately or at all.
03:45:30 <ptarsa> so the function f itself has to decide when to stop to make everything working. i am right?
03:46:02 <ski> > foldr (\a as -> a : a^2 : as) (error "help, i'm trapped in a recursion, they won't let me go !") [0 ..]
03:46:03 <lambdabot>   [0,0,1,1,2,4,3,9,4,16,5,25,6,36,7,49,8,64,9,81,10,100,11,121,12,144,13,169,...
03:46:16 <Cale> ptarsa: essentially, yes
03:46:57 <ski> ptarsa : that latter is an example of "or at least doesn't require ...", because `:' is lazy, so the `as' doesn't need to be evaluated if we just want to get `a' or `a^2' at some point
03:47:14 <Cale> > foldr (\x xs -> if x > 100 then ("here we go: " ++ show x) else xs) "oops" [1..]
03:47:16 <lambdabot>   "here we go: 101"
03:48:18 <XexonixXexillion> > (\y -> foldr (\n xs -> if n == y then n else n * xs) 1 [1..]) 10
03:48:19 <lambdabot>   3628800
03:48:57 <ski> > foldr (\a acc_sum acc -> if a < 10 then acc_sum (acc + a) else acc) (\acc -> error "Pontrjagin duality") [0 ...] 1000 :: Expr
03:48:58 <lambdabot>   A section must be enclosed in parentheses thus: (0 ...)Not in scope: `...'
03:49:08 <ski> > foldr (\a acc_sum acc -> if a < 10 then acc_sum (acc + a) else acc) (\acc -> error "Pontrjagin duality") [0 ..] 1000 :: Expr
03:49:09 <lambdabot>   1000 + 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9
03:49:30 <ski> > foldr (\a acc_blah acc -> if a < 10 then acc_blah (acc ** a) else acc) (\acc -> error "Pontrjagin duality") [0 ..] 1000 :: Expr
03:49:31 <lambdabot>   (((((((((1000**0)**1)**2)**3)**4)**5)**6)**7)**8)**9
03:49:59 <ptarsa> thanks for explanations
03:50:04 <ski> yw :)
03:50:14 <dmwit> That's a funny special-case error message.
03:50:19 <dmwit> > [0 +]
03:50:20 <lambdabot>   A section must be enclosed in parentheses thus: (0 +)
03:50:22 <dmwit> but:
03:50:25 <dmwit> > [+]
03:50:27 <lambdabot>   <no location info>: parse error on input `]'
03:50:34 <augur> ski: im going to go back to reading this book but later, maybe, i'll look some more at left rules and cut elimination
03:50:41 <ski> augur : ok
03:50:44 <ski> (which book ?)
03:50:50 <ptarsa> form what i understood foldr works on infinite lists if either f stops at some time or f makes a list using : operator which is lazy
03:51:00 <augur> ski: Lectures on the Curry-Howard Isomorphism
03:51:07 <dmwit> ptarsa: Close, but too specific.
03:51:12 <ski> ptarsa : s/makes a list/makes a lazy structure, like e.g. a list/
03:51:17 <dmwit> ptarsa: f can make any data type lazily, not just lists.
03:51:34 <ski> augur : is that Pfenning or what ?
03:51:48 <augur> sörensen and urzyczyn
03:51:52 <ski> ok, ty
03:51:57 <augur> its on libgen
03:52:13 <ptarsa> ok, thank you all
03:52:13 <augur> someone recommended it to me on reddit, i think, in the thread i made for the tutorial
03:52:41 <augur> ski: its really good. it has a whole section on semantics of the LC, too, so your question about BA semantics is answered ther
03:52:52 <ski> i don't think i've seen that before
03:53:18 <ski> augur : hm, i forgot the reddit link
03:53:36 <ski> ptarsa : hth
03:53:49 <augur> ski: http://www.reddit.com/r/haskell/comments/wpu3e/a_tutorial_on_the_curryhoward_correspondence/
03:53:54 <ski> ty
03:57:33 <GyorsCsiga> hairy dude has a hairy connection
03:57:56 <augur> ski: ah, it was koninkje_away who mentioned the book. awesome!
03:58:08 <HairyDude> trying to figure out why I wasn't auto-connecting to #yesod on startup... answer: I mucked up the configuration
03:58:40 <augur> ski: also, the current version of the tutorial on my site is my current version locally, with all my new typography
04:00:08 <ski> pulling
04:00:51 <ski> augur : you didn't change the `true's ?
04:00:54 <augur> writing this tutorial and talking with you have been the most useful proof theory things ive done in years
04:01:01 <augur> ahh! the trues! yes, i will do that right away. :)
04:01:26 * ski . o O ( the truce )
04:02:20 <HairyDude> I'm getting a bunch of "orphan instance" warnings that turn into "can't deduce" errors if I remove said instances
04:02:29 <augur> ski: lol
04:02:38 <ski> maybe "knowing `T' doesn't require any proof" could be "knowing `T' doesn't add any new consequences/information" -- not sure
04:03:14 <augur> ski: ok
04:03:51 <ski> (i was just thinking "doesn't require any proof" was a bit vague/unspecific about the point)
04:04:40 <ski> why the `_|_E' rule is good might also not be obvious to people -- not sure if you want to enter into this here
04:05:58 <ski> (one example is that commonly when doing case analysis, and we discover one case is actually impossible (given the current hypotheses), then one way to "discard" that branch is to use `_|_E' (another is to use a multiplicative `_|_E' rule, if we have multiple conclusions))
04:06:51 <augur> hmm
04:07:33 <augur> ski: you should write something about the different flavors (additive/multiplicative/whatever) of intros and eliminations
04:07:43 <ski> (another example is showing `not A \/ B |- A -> B')
04:08:19 <ski> (though here again, multiplicative variants can be used instead)
04:09:19 <ski> then one can have ackermann falsity `f' which is just something inconvenient/awkward which we wish weren't true, but which doesn't actually entail everything (e.g. in relevant logic)
04:10:47 <ski> e.g. if we do rules for natural numbers (including equalities/conversions of those) in e.g. a Martin-Löf thing, then we can't prove `Zero = Succ n -> False'
04:10:53 <dmwit> "If this were true, it would make me sad. I don't want to be sad. Therefore it is false." -- Zach Weiner
04:11:10 <ski> but if we don't include `False', we can *define* it as `Zero = Succ Zero'
04:11:14 <tgeeky> dmwit: hehe, I like!
04:11:44 <ski> (and then we don't get `False-elim')
04:11:56 <ski> dmwit : exactly :)
04:12:47 <tgeeky> re: inconvenient/awkward which we wish weren't true
04:12:59 <tgeeky> ski: what's the logic symbol for a wish?
04:13:14 <dmwit> <3 x
04:13:17 <tgeeky> hehe
04:13:26 <tgeeky> pweeeeeese x |- y
04:13:31 <ski> Brouwerian counterexamples in intuitionistic math are examples of things we wish weren't true, but we can't prove it
04:13:34 <ski> <http://en.wikipedia.org/wiki/Constructive_proof#Brouwerian_counterexamples>
04:13:34 <dmwit> hehehe
04:13:36 <augur> dmwit: proof by anti-sadness
04:14:24 <ski> so, when we want to show that there's no point in trying to prove something intuitionistically, we show it entails a Brouwerian counterexample
04:14:28 <tgeeky> ski: cool, I didn't know there was a counterexample the implied Mu :o
04:14:44 <augur> ski: updated that section on True/False rules. its hard to explain why it makes sense to have a false-elim :(
04:15:00 <ski> tgeeky : "counterexample the implied Mu" ?
04:15:28 <ski> augur : yeah, appeals to symmetry will probably not sway hardnosed pragmatics :)
04:16:51 <ski> (btw, note that wishing they weren't true is distinct from wishing them were false -- they are provably *not* false in intuitionistic math -- otherwise there'd be no problem)
04:17:06 <ski> (s/them were/they were/)
04:17:51 <tgeeky> ski: Mu as in the GEB sense. "You should unask that question."
04:17:52 <ski> (of course, this is assuming a hardnosed verificationist interpretation of truth, where truth means verifiability/provability)
04:18:16 <t7> why is hackage not high on google anymore when i search for modules?
04:18:25 <t7> the haddock stuff
04:18:33 <dmwit> I like the joke you made, but I don't think "mu" is the appropriate understanding of Brouwerian counterexamples.
04:18:35 <ski> tgeeky : well, often i think `Mu' means the question is not well-formed (iow, strictly speaking, meaningless) -- at other times, the suggestion is that the question isn't productive
04:18:52 * dmwit high-fives ski
04:19:05 <mroman> bitrust: Did you have luck with your [Bool] -> [Word8]?
04:20:01 <ski> maybe sometimes `Mu' means that the answerer thinks the question is in some sense unanswerable (e.g. in the sense that neither it nor its negation are believed to be provable (usually one of those is provably not provable (assuming the consistency of the logical system, of course :)))
04:20:28 <dmwit> We need to go deeper! P A R E N T H E S I S
04:20:51 * ski tall-sevenths dmwit
04:21:49 <merijn> If I want to time/benchmark some IO code, what'd be the best way to do it (without getting tripped up by something like lazy evaluation not executing my timestamp when I want it)
04:22:01 <dmwit> cabal install criterion
04:22:42 <augur> tgeeky: Mu in the GEB sense is more "That question presupposes things to be true which are not true."  surely
04:23:32 <dmwit> Poor tgeeky.
04:23:46 <augur> ski, tgeeky, dmwit: Mu is generally taken to mean that (if only implicitly). basically its a response to what pragmaticists would call an infelicitous question
04:24:01 <merijn> dmwit: Ah, that looks useful, thanks
04:24:22 <augur> which means if you're really interested in that sort of thing, you should read on felicity conditions and how semanticists/pragmaticists model them :)
04:24:53 <tgeeky> hehe. I think this originated in ancient asian culture, not modern semantics
04:25:12 <augur> oh it definitely did, tgeeky
04:25:41 <augur> but modern semantics/pragmatics has actually tried to model that
04:25:58 <tgeeky> I took the ancient meaning to be, a response (only) to a question which can not lead to enlightenment, or which can only lead to confusion
04:25:58 <augur> whereas ancient chinese philosophy didnt really develop a linguistic model of such things
04:26:24 <augur> oh, see, in my reading of buddhist literature, Mu is definitely still about infelicity
04:26:27 <augur> like
04:26:55 <augur> asking does a dog have buddha nature presupposes the relevance of an answer
04:26:56 <tgeeky> yes, you are right
04:27:20 <tgeeky> I don't know what the ancient chinese word for infelicity is :o
04:27:37 <dmwit> I think hacker culture has a different meaning for the word than the original word had.
04:27:47 <dmwit> Also I think the standard example used to explain Mu is dumb.
04:27:55 <tgeeky> yes
04:28:03 <tgeeky> the best one is the voltage example, imho
04:28:04 <augur> "mu", i think is (old?) chinese for "nothing"
04:28:06 <tgeeky> but I would say that
04:28:12 <augur> making it approximately equivalent to _|_ in haskell
04:28:22 <augur> or, well, undefined, really
04:28:22 <dmwit> What's the voltage example?
04:28:26 <augur> or whatever
04:28:39 <dmwit> If you say "mu" I'll cut off a finger. =P
04:28:45 <tgeeky> dmwit: from Zen and the Art of Motorcycle Maintnence: For example, it's stated over and over again that computer circuits exhibit only two states, a voltage for "one" and a voltage for "zero." That's silly! Any computer-electronics technician knows otherwise. Try to find a voltage representing one or zero when the power is off! The circuits are in a mu state.
04:28:46 <augur> dmwit: which standard example?
04:28:55 <tgeeky> augur: the: does dog have buddah nature
04:29:15 <dmwit> Oh, I meant "have you stopped beating your wife".
04:29:17 <tgeeky> but see, in chinese philosophy, a dog probably *should* have buddah nature, because dogs are very (uniquely) connected to humans
04:29:44 <augur> dmwit: yeah, the stopped beating your wife example is common in literature on felicity conditions and presupposition
04:29:46 <tgeeky> dmwit: yes: "Have you told your Mom that you're gay?" and "Have you stopped beating your wife?"
04:29:56 <dmwit> They're both dumb.
04:30:07 <tgeeky> hence used by 3rd graders
04:30:16 <dmwit> The idea that you can't answer them stems from the incorrect belief that you must answer "yes" or "no".
04:30:18 <shachaf> Third graders and #haskell.
04:30:26 <tgeeky> dmwit: yep
04:30:31 <augur> tgeeky: well, im maybe dogs do, maybe they dont, but i think the Mu response is about the infelicity from a human-purpose point of view
04:30:40 <shachaf> #haskellosophy
04:30:46 <tgeeky> dmwit: so, that is a question which just demands ternary logic: Yes | No | Other
04:30:46 <shachaf> (Except not really.)
04:30:51 <augur> tgeeky: as in, the question may be answerable truth-wise, but not utility-wise
04:30:53 <tgeeky> oh, I thought we were in #-blah
04:31:00 <tgeeky> augur: yes, which gets back to my original point
04:31:04 <augur> tgeeky: indeed
04:31:17 <dmwit> shachaf: My armchair is the finest one around.
04:31:29 <shachaf> dmwit: You should be in #-blah!
04:31:39 <dmwit> I should be in bed.
04:31:45 <shachaf> Too late.
04:31:59 <tgeeky> indeed. All nighters abound
04:32:02 <augur> tgeeky: so i think your "lead to confusion" meaning is actually a minor variation on the standard infelicity meaning --- both are about the presuppositions, one about presuppositions of truth of some proposition, and the other about presupposition of relevance
04:32:04 <tgeeky> I know dmwit is in my time zone
04:32:13 * dmwit high fives tgeeky
04:32:16 <augur> i wonder if relevant logic has something to say about this
04:32:19 <augur> that'd be interesting if it does
04:32:53 <t7> can i use traverse to keep track of position in a tree?
04:33:02 <augur> like if you could unify these two interpretations by having a bipartite logic where half is relevance logic and the other half is intuitionistic logic
04:33:21 <tgeeky> augur: that seems logical
04:33:22 <dmwit> t7: traverse doesn't really do positioning, no
04:33:48 <t7> whats the stardard class for dealing with positions in trees?
04:33:56 <merijn> How do I poll multiple Chan's for input? Is that even possible?
04:33:57 <dmwit> I don't think there is one.
04:34:03 <t7> ugh
04:34:05 <tgeeky> take a derivative of a tree, and then traverse the (hole,context) pairs?
04:34:09 <dmwit> merijn: Yes, spawn a thread for each Chan.
04:34:15 <Nereid> t7: zippers?
04:34:37 <augur> ski: do you know of any logics that imploy different "styles" for different segments of the judgements?
04:34:55 <t7> if i want to draw a tree on screen and be able to click on the nodes etc
04:34:56 <dmwit> merijn: Or just have all your producers write to the same Chan.
04:35:08 <t7> i cant see an elegent way
04:35:12 <t7> elegant *
04:35:19 <augur> ski: like if you had judgements like   G | D |- P   where G is one kind of context (say, classical) and D is another (say, linear)
04:35:19 <Nereid> zippers are pretty elegant
04:35:44 <merijn> dmwit: That won't work for my usecase, as the former doesn't allow me to selectively ignore some channel after seeing input on it and the latter doesn't let me control ordering
04:36:28 <dmwit> I'm not sure I understood either complaint.
04:36:31 <dmwit> Can you expand a bit?
04:38:07 <merijn> dmwit: Ok, so we're thinking of rewriting/reimplementing our runtime system from C to haskell (because the C RTS is an ugly hack). We essentially have CSP with processes communicating over bounded streams.
04:38:35 <merijn> One combinator we use merges streams together in a single stream. That one has two implementations (non-deterministic and deterministic merge)
04:38:59 <t7> is there a type safe way todo zippers ?
04:39:09 <tgeeky> t7: all of them
04:39:17 <t7> i guess it would need dependant types
04:39:24 <merijn> The non-deterministic one is trivial to implement by writing to the same Chan, but the deterministic merger I don't know how to do
04:39:47 <dmwit> What does the deterministic merge do?
04:40:53 <merijn> For deterministic merge we have control records flowing on all streams, it polls all streams for incoming records and after encountering a non-control record will forward it immediately, then remove it from the poll set
04:41:09 <Eduard_Munteanu> t7: what do you mean by typesafe?
04:41:26 <merijn> It will then wait for a control token on each other stream (removing them as they come in), once the input set is empty it will switch back to polling all streams
04:42:17 <augur> oh, ski, yes, i was going to add syntax highlighting to my tutorial. i should figure that out some time today. :)
04:42:19 <merijn> I don't see how I could do that if I had one thread for each Chan (because they wouldn't be aware of which chan's are currently "suspended") and writing to the same Chan will not give me any ordering whatsoever
04:42:23 <augur> make some of these things more legible
04:42:40 <t7> Eduard_Munteanu: like i cant try to follow a zipper that will fail
04:42:42 <dmwit> I see. So the goal is to forward messages fairly, but not in a fixed order?
04:43:03 <dmwit> e.g. one from each source (in nondeterministic order), then rinse repeat?
04:43:47 <tgeeky> i swear those are the same instructions as my shampoo bottle
04:44:01 <dmwit> So, here's what you do:
04:44:16 <Eduard_Munteanu> t7: ah, you mean the path? Hm.
04:44:29 <merijn> dmwit: Actually, I just saw a bug in my explanation
04:44:40 <t7> need agda for that i guess
04:44:47 <dmwit> Okay, I won't say what to do yet, then.
04:45:10 <Eduard_Munteanu> t7: you could just hide the internal representation of the path
04:45:58 <t7> and make a type that holds the tree and its zipper?
04:46:08 <t7> nah then i couldnt take a branch...
04:46:28 <merijn> dmwit: We have combinators for composing parts of our graph, the combinator for alternate paths introduces a splitter and merger that is responsible for forwarding inputs to the appropriate streams and eventually merging them together. Our processes have a fixed multiplicity and so our deterministic implementation has to ensure *all* produced output of any input has been forwarded before forwarding anything else
04:46:37 <Eduard_Munteanu> You could provide functions to do it.
04:47:01 <Eduard_Munteanu> e.g. left :: Zipper a -> Maybe (Zipper a)
04:47:15 <Eduard_Munteanu> Though that does fail too.
04:47:19 <merijn> dmwit: This is trivially done by sending a control input to all possible branches and waiting until you have seen that control message on each branch (forwarding any incoming outputs you encounter before a control message)
04:47:56 <merijn> dmwit: But it means that after a control input has been seen on a stream, that stream should be ignored until it has been seen on *all* streams
04:48:07 <Eduard_Munteanu> t7: try Agda if that's an option for you
04:48:17 <ski> augur : good point about presupposition (which can be seen as a special kind of non-sense/meaninglessness/non-wellformedness)
04:48:18 <t7> yeah im gonna have a fiddle :)
04:49:51 <dmwit> merijn: Okay. So my new understanding is that you have several sources, and you want to wait until you've seen one message from each, then forward on a big packet that has all of the messages seen this round.
04:49:55 <dmwit> Right so far?
04:50:45 <dmwit> (I don't consider this "control/not-control" distinction very important. If it comes to it, you can put a tiny thread on there that does nothing but buffer non-control messages until it sees a control message, then sends the buffer along as a single message.)
04:51:06 <dmwit> If so, then I don't see why you can't just wait on each Chan in turn.
04:51:12 <dmwit> mapM readChan inputs
04:51:15 <dmwit> -- done
04:51:57 <augur> ski: is there a conventional way of indicating in latex when a link is external?
04:52:38 <merijn> dmwit: Well, we just forward all messages in order without merging
04:53:22 <merijn> dmwit: The problem with mapping across each Chan is that it is *functionally* what I want, but not operationally
04:54:02 <dmwit> Can you describe what is wrong with it operationally?
04:54:32 <dmwit> (Is my synopsis above not correct?)
04:55:03 <merijn> dmwit: Blocking on the control messages of each branch before eventually finding input on the last branch introduces a delays where output is ready but not being sent, this ruins throughput latency and introduces jitter
04:55:43 <dmwit> Oh, so you don't want to wait until you've seen a control message from each branch before sending something on?
04:55:44 <merijn> Because any code further down the path way can't start computing until it gets input
04:55:47 <dmwit> Isn't that what you said you wanted?
04:56:00 <dmwit> (And if you don't want that, what motivates the name "deterministic"? =P)
04:56:23 <dmwit> Anyway, I'll outline the approach I was going to say before, since that covered this more interesting scenario.
04:56:58 <dmwit> Again, I'm going to ignore the control/not-control distinction. It should be clear how to generalize.
04:57:21 <dmwit> So, the first thing you do is you come up with a distinct tag for each input channel.
04:57:52 <dmwit> Then you write a function that takes an (infinite) list of (tagged) messages and reorders it to satisfy your restriction on transmission.
04:58:13 <dmwit> e.g. it pulls out the first message from each tag, and recurses on any it skipped during that process
04:58:59 <mmaruseacph2> a Chan had a unGetChan method for this when I needed it
04:59:01 <dmwit> Then you merge all your input channels into a single channel transmitting tagged messages, call getChanContents on the single merged channel, and mapM putChan along the transformed messages
04:59:06 <mmaruseacph2> now I see that it is deprecated
04:59:22 <dmwit> unGetChan isn't necessary.
04:59:41 <merijn> dmwit: The deterministic name comes from having a split -> multiple branch -> merge, where the splitter sends its input to 1 of the branches and wanting to make sure we send all output of one input to the splitter before sending any output for another input to the splitter
05:00:12 <ben> The first time I used unGetChan, my program hung because that didn't wake up a readChan'ing thread
05:00:18 <ben> the next time I checked, it was deprecated :V
05:01:26 <mmaruseacph2> merijn: if you need a bareer there then the mapM method above is right
05:01:54 <mmaruseacph2> if you don't want to block then you need to shuffle the contents and reorder it, just like the second idea of dmwit
05:02:13 <mmaruseacph2> basically, it all reduces to hoz much you want to block
05:02:19 <mmaruseacph2> if I understood it correctly
05:12:35 <merijn> dmwit, mmaruseacph2: Thanks, not sure if that's how I eventually want to do it, but I guess it'd good enough for now
05:14:32 <merijn> Hmm, alternately I might be able to wrap Chan and couple it with a SampleVar to wake up the reading thread
05:15:44 <hpaste> dmwit pasted “merging Chans” at http://hpaste.org/71773
05:15:58 <dmwit> I didn't run it, but it typechecks. ^_^
05:20:21 <flojistik>  /g
05:22:13 <ski> tgeeky : yes, tristate buses
05:22:24 <ski> tgeeky : fyi : "Chapter Three : The Trivalent Logic of Aymara" by Iv n Guzm n de Rojas in 1984 at <http://aymara.org/biblio/html/igr/igr3.html>
05:22:34 <ski> augur : well, in relevant predicate logic, you can say that `P' holds relevantly for `a' iff `forall x. x = a -> P a', where `->' is relevant implication
05:22:44 <ski> t7 : for position, something comonady might work. "Evaluating cellular automata is comonadic" at <http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html> and "Comonads and reading from the future" at <http://blog.sigfpe.com/2007/02/comonads-and-reading-from-future.html> by sigfpe (aka dpiponi aka Dan Piponi) might be slightly relevant
05:22:50 <ski> (tgeeky : yes, derivatives/zippers could also work)
05:22:53 <ski> merijn :
05:22:56 <ski> @hoogle mergeIO
05:22:56 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
05:22:57 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
05:23:00 <marcot> Hi.  Is there a way to ignore parse errors in parsec.  For instance, I have:
05:23:08 <marcot> Prelude Text.ParserCombinators.Parsec> parse (sepEndBy1 (string "xy") (char ',')) "" "xy,xy,x"
05:23:08 <ski> augur : not sure what you mean by "imploy different \"styles\" for different segments of the judgements" -- i assume that you're not thinking of something like the ability to emulate classical/intuitionistic logic in linear logic using the exponential(s), nor that some presentations divide the premise-part of the sequent in a bounded and an unbounded part (in addition to the "of course" connective) ?
05:23:14 <ski> augur : oh, ok, you appeared to have that in mind
05:23:18 <marcot> unexpected end of input
05:23:18 <marcot> expecting "xy"
05:23:18 <ski> merijn : oh, you're thinking of deterministic merge .. (using what prescribed interleaving ? maybe just a single given list/array ?)
05:23:23 <augur> ski: well no not quite actually
05:23:29 <ski> merijn : hm, the combinators with splitting and merging reminds me of Fudgets (not sure how relevant this is)
05:23:32 <ski> @where Fudgets
05:23:32 <lambdabot> GUI using X, by Thomas Hallgren and Magnus Carlsson, at <http://www.altocumulus.org/Fudgets/>,<http://www.carlssonia.org/ogi/ProdArrows/>. Also see `Alfa'
05:23:33 <ski> augur : re external links, dunno
05:23:40 <marcot> I would like to have ["xy", "xy"] returned, and the final x ignored.
05:23:54 <Eduard_Munteanu> ski: I think he's complaining navigating through the zipper isn't implicitly safe.
05:24:13 <ski> oh, failure to navigate
05:24:16 <augur> ski: all i mean is that the system should really just be a combination of proof systems for different logics, perhaps with new things added given that they've been squashed together into one
05:24:35 <Eduard_Munteanu> Some dependent tree type might help there.
05:25:16 <augur> ski: basically so that you could say something like these propositions here can be reasoned with using relevance logic, and these over here with classical logic
05:25:46 <augur> i guess really all you need is an embedding of one into the other
05:26:18 <Cale> marcot: put the string "xy" in a try?
05:26:20 <augur> i suspect also that judgements should be very highly useful
05:26:38 <Cale> ghci> parse (sepEndBy1 (try (string "xy")) (char ',')) "" "xy,xy,x"
05:26:38 <Cale> Right ["xy","xy"]
05:27:05 <marcot> Cale: Thanks, it's simpler than what I had in mind. =)
05:27:56 <marcot> Cale: But it doesn't handle inputs like "xy,x,xy"
05:28:09 <Cale> sure it does
05:28:18 <marcot> I think I'll need to use Maybe, and try (Just <$> string "xy") <|> Nothing
05:28:32 <Cale> What do you expect to get for that input?
05:28:38 <marcot> Cale: Well, it depends on your meaning of handle.  It doesn't return both xy's.
05:29:03 <Cale> In that case you should be accepting any string between the commas, and filtering the output of the parser
05:30:20 <Cale> oh, I know...
05:30:22 <ski> Eduard_Munteanu : well, something like `Zip f -> f (Zip f)' with `Zip f = mu r. (mu r. f r) + d (f r) / d r' might work for downward traversal, leaving `Zip f -> Maybe (Zip f)' for upward
05:31:05 <marcot> Well, in the real case the comma is not something simple, and to know what is really the separator I need to parse the "xy"'s.
05:31:20 <ski> augur : ok
05:31:46 <ski> augur : maybe it would be interesting to ponder a combination of an ordered and an (unordered) linear logic here
05:32:02 <ski> (where the ordered one is possibly cyclic)
05:32:20 <Eduard_Munteanu> ski: mm, what do you mean by   mu r. (mu r. f r)? Typo?
05:32:38 <Eduard_Munteanu> Or do you mean that literally?
05:33:12 <marcot> Cale: I think I'll have to parse error values enough to determine the separator.  Thanks.
05:33:29 <Cale> parse (fmap concat (sepEndBy1 (fmap (:[]) (try (string "xy")) <|> (many (noneOf ",") >> return [])) (char ','))) "" "xy,x,xy"
05:33:33 <Cale> something like that
05:33:39 <Cale> (that could be tidier)
05:34:05 <Eduard_Munteanu> ski: but still, don't you require a dependent 'f' for that to be traversal-safe?
05:34:24 <Eduard_Munteanu> I mean, a more special 'f'.
05:34:41 <esato> hello there
05:34:58 <Eduard_Munteanu> esato: hi
05:35:20 <marcot> Cale: Yes, that is kind of the same of what I had in mind.
05:35:39 <esato> Guys… I've been reading "The essence of functional programming" by Wadler
05:36:03 <Cale> esato: hello
05:36:20 <Cale> esato: feel free to ask any questions you might have
05:37:26 <augur> ski: im pretty sure there's a clear connection between the polarity of an occurrence of a formula and its role in game semantics
05:37:45 <ski> augur : we can have a choice : (0a) unordered commutes with everything ("central"); (0b) unordered only commutes with unordered ("abelian") -- also we can consider having several environments of ordered premises, where ones from different environments commutes with each other (cf. categorical product / free product and the direct product in the category of (not necessarily commutative/abelian) groups)
05:37:52 <marcot> Cale: The only problem is that the separator is not something so simple that I can create a negation using many . noneOf
05:37:53 <ski> Eduard_Munteanu : literally
05:38:17 <esato> It shows how to use monads to emit Error messages, then to generate Error messages with positions, then it shows how to use the State monad to count the number of function applications, and so on. My question is: what if I want to do all that stuff at the same time? For example: what if I want to count the number of function applications AND, at the same time, generate error messages with positions?
05:38:22 <augur> i think positive occurrences are ones that Player has to give, and negative occurrences are ones that Opponent has to give
05:38:34 <esato> I did understand how the monads work, though.
05:38:54 <augur> ski: i think logic games would be a useful way of looking at a programming task
05:39:04 <Cale> marcot: you might be able to use manyTill
05:39:15 <Eduard_Munteanu> esato: you can combine monads by using monad transformers.
05:39:16 <augur> programming just is playing a logic game, especially if you're using an interactive environment like agda
05:39:33 <ski> Eduard_Munteanu : for `data Tree a = Tip | Node a (Tree a) (Tree a)', `f' would be `TreeLayer' where `data TreeLayer a self = TipL | NodeL a self self'
05:39:54 <augur> which suggests to me that interactive theorem provers might've originated around the same time that games originated
05:40:11 <confusing> esato: monads in haskell form a stack (a little like a call stack). you can have your "Error" monad, on top of that a "State" monad, then your "Position" monad, etc.
05:40:25 <ski> Eduard_Munteanu : so you'd then manually match on the outer `TreeLayer' to determine the shape, and the choose which sub-tree to enter (and the corresponding `self' part contains a zipper seen from the perspective of following that branch)
05:40:36 <Cale> confusing: are you trying to be confusing? :D
05:40:52 <confusing> esato: in that situation, functions from all 3 monads are available
05:40:54 <ski> Eduard_Munteanu : "a more special 'f'2 ?
05:40:58 <ski> s/2/"/
05:41:05 <Cale> Monad *transformers* can stack
05:41:07 <Cale> Monads can't
05:41:46 <Cale> You can apply as many monad transformers as you want to add new features one at a time to an existing monad.
05:41:48 <esato> @Eduard_Munteanu @confusing: thanks. Are there any good examples on the internet?
05:41:48 <lambdabot> Unknown command, try @list
05:41:51 * ski still wonders about monad coproducts ..
05:42:06 <Eduard_Munteanu> ski: ah, I was thinking you might need an explicitly defined type function for 'f'.
05:42:21 <Cale> esato: Okay, so you understand how the State monad is implemented?
05:42:28 <confusing> cale: well yes, but i didn't think that distinction is that important to a beginner. i thought almost all monads have corresponding transformers (exception: IO)
05:42:29 <esato> Cale: Is I do
05:42:35 <esato> Cale: Yes, I do
05:42:47 <Cale> So, in the plain State monad, we had:
05:42:50 <ski> augur : hehe, writing a (polymorphic enough) function can often be interpreted in terms of game semantics :) (then after you've written it, you try to figure out what it actually *does* :)
05:43:20 <Cale> newtype State s a = S (s -> (s,a)); runState (S f) s = f s -- something like this
05:43:23 <Cale> and
05:43:33 <Cale> return v = S (\s -> (s,v))
05:43:41 <esato> @Cale: I follow you
05:43:41 <lambdabot> Unknown command, try @list
05:44:08 <Cale> x >>= f = S (\s -> let (s',v) = runState x s in runState (f v) s')
05:44:15 <Cale> good so far?
05:44:23 <esato> @Cale: so far so good
05:44:23 <lambdabot> Unknown command, try @list
05:44:32 <esato> Cale: so far so good
05:44:33 <Cale> Okay, so now, we're going to generalise this a bit
05:44:35 <ski> esato : please attribute a specific person here by something like `person : ...', `person, ...' (this is old IRC custom and many IRC clients will then alert the person you're directing the message to), not like `@person ...'
05:44:37 <marcot> Cale: manyTill might work, I'll check here.
05:44:54 <Cale> newtype StateT s m a = S (s -> m (s,a))
05:44:55 <esato> ski, thanks
05:45:12 <Cale> runStateT (S f) s = f s
05:45:20 <ski> confusing : i think in some cases, a monad can correspond to several different monad transformers (at least this is the case for comonads)
05:45:25 <esato> ski, looks like I was driving lambdabot nuts
05:46:03 <ski> yeah, lambdabot is good for keeping that twitterism in check ;)
05:46:17 <nand`> I think ‘@’ is older than twitter
05:46:24 <Cale> and now:
05:46:38 <Cale> return v = S (\s -> return (s,v))
05:46:42 <confusing> ski: interesting ... are there any well-known examples? i mean, Reader and List and State and such aren't affected, right
05:46:43 <ski> nand` : ok, do you know what other protocols/systems ?
05:47:03 <ski> (well, there's email of course (though `!' was also used, iirc), but apart from that)
05:47:09 <Cale> x >>= f = S (\s -> do (s',v) <- runStateT x s; runStateT (f v) s')
05:47:37 <esato> Cale: I think I get the Idea
05:47:49 <nand`> ski: none in particular but I've seen it used in online forums when users are too lazy to multi-quote (or don't want to waste space), eg. ‘@UserOne: Foo <LF> @UserTwo: Bar’
05:47:54 <Eduard_Munteanu> confusing: example of what?
05:48:01 <ski> augur : the idea of a dependent interactor where the admissible options at each time depend on what has been entered before is an attractive one
05:48:02 <nand`> ages before twitter existed
05:48:14 <esato> Cale, that's kind of what Wadler does on the Position Example
05:48:19 <Cale> esato: So the idea is that we've just built a State monad like thing layered on top of some other monad m
05:48:42 <Cale> Now on top of this, we can also turn m actions into StateT s m actions
05:48:50 <Cale> lift :: m a -> StateT s m a
05:48:56 <confusing> Eduard_Munteanu: ski was mentioning there might be monads that correspond to several different monad transformers. but i bet it's not anything newbie-level
05:49:06 <ski> nand` : .. but were those older than IRC ?
05:49:13 <esato> Cale, Haskell seems like magic sometimes…
05:49:16 <ski> oh, twitter, sorry
05:49:20 <Cale> lift x = S (\s -> do v <- x; return (s,v))
05:49:25 <ski> nand` : ok, point taken
05:49:34 <confusing> esato: sufficiently advanced technology is indistinguishable from magic! :-)
05:50:04 <ski> esato : the magic (and attempting to understand it) is part of the fun :)
05:50:05 <Eduard_Munteanu> confusing: well, it's pretty easy to find transformers which are equal only up to isomorphism
05:50:06 <nand`> does this mean technicians are magicians?
05:50:22 <nand`> (and by extension, Haskell programmers)
05:50:27 <Cale> esato: and so our new monad StateT s m a in some sense "contains" all the actions which m had, plus it can support getting and setting an extra state parameter of type s
05:50:31 <ski> @quote indistinguishable
05:50:31 <lambdabot> shachaf says: Sufficiently advanced misunderstanding is indistinguishable from trolling.
05:50:36 <ski> @quote indistinguishable
05:50:37 <lambdabot> Eduard_Munteanu says: * Eduard_Munteanu considers coining "Sufficiently advanced category theory is indistinguishable from trolling" <geheimdienst> @remember Eduard_Munteanu [snip] <geheimdienst> ...
05:50:37 <lambdabot>  coined <Eduard_Munteanu> Aw.. but I paraphrased shachaf on some other stuff. <Eduard_Munteanu> @forget Eduard_Munteanu [snip]
05:50:37 <esato> confusing, ski: It seems to me that Haskell is, maybe, the "most dense" language there is
05:50:42 <Cale> (I didn't write get and put, but you can probably imagine how to implement those)
05:50:46 <ski> @quote indistinguishable
05:50:47 <lambdabot> shachaf says: Sufficiently advanced misunderstanding is indistinguishable from trolling.
05:51:01 <ski> @quote sufficiently.misguided
05:51:02 <lambdabot> monochrom,ezyang says: The Principle Of Idiot Savant: any sufficiently misguided opinion is indistinguishable from deep insight
05:51:09 <augur> ski: im not sure what you meant with that
05:51:11 <nand`> esato: if by ‘dense’ you mean ‘terse’ or ‘short’, I agree completely
05:51:31 <esato> Cale: and then we can use the Identity Monad to get State from StateT, right?
05:51:34 <nand`> esato: in practice, my C# code has, for the same purpose, been anywhere from 5x as 10x as long in terms of SLOCs, even when I'm being generous (eg. by putting { and } on the same lines)
05:51:44 <Cale> esato: yes :)
05:51:45 <nand`> from 5x to 10x*
05:52:22 <quicksil1er> nand`: I think that APL might claim to be denser and terser (e.g. http://en.wikipedia.org/wiki/APL_(programming_language)#Conway.27s_.28very_concise.29_Life )
05:52:33 <nand`> Cale: get and put can be implemented in terms of ‘state’ either way
05:52:47 <nand`> oh, you didn't show ‘state’ either
05:53:00 <esato> nand: I've been studying haskell. And it goes like this: I spend some minutes writing some code. Then I spend 10x as much time staring at the code and wondering how it works. It is strange…
05:53:04 <ski> augur : well, considering an interactor like GHCi or Hugs as a game (something like `(x0 : A0) -> (y0 : B0 x0) * ((x1 : A1 x0 y0) -> (y1 : B1 x0 y0 x1) * ...)')
05:53:31 <confusing> what i'd like to see is some comparison in terms of programmer time. i suspect haskell is much faster because it cuts debugging time dramatically, but i can't prove it
05:53:34 <ski> augur : you make your move, and the situation changes to allow new moves and remove or modify old ones
05:53:35 <nand`> quicksilver: hehe. Nice example, if completely baffling
05:53:39 <av> hi guys, I have a question relating to diagrams, but #diagrams is quite inactive, so I'll just ask over here:
05:54:24 <av> is it possible to define a path on diagrams that consists of straight lines and circular or elliptic arcs?  at the moment, I can only find a way of creating paths from straight lines and cubic splines
05:54:40 <ski> (augur : and re games like these, the axiom of determinacy <http://en.wikipedia.org/wiki/Axiom_of_determinacy> might be interesting)
05:54:59 <nand`> quicksilver: is learning APL worth it nowadays?
05:55:04 <nand`> quicksilver: it seems fascinating
05:55:06 <augur> ski: ah, i see
05:55:35 <augur> ski: im adding a section to the tutorial on alternative logics, noting that expressions of math, for instance, can be seen as other logics
05:55:49 <confusing> nand`: it has monads! ;) although not the same sort as haskell
05:55:50 <quicksilver> nand`: I doubt you'll make much use out of it but it's certainly edifying.
05:55:55 <merijn> nand`: Instead of APL, J seems a more usable/typable variant
05:56:09 <Cale> av: Are you talking about Brent Yorgey's library?
05:56:23 <nand`> quicksilver: I doubt I'll be switching away from Haskell for my “language to get things done in” any time soon :)
05:56:25 <augur> ski: for instance, you might have the connectives N * + with rules   N  N  ===*  N   and   N  N  ===+  N
05:56:48 <quicksilver> merijn: J doesn't quite have the same charm, from an esoterica perpsective :)
05:57:02 <augur> ski: i think this have the obvious algebraic semantics (Nat, *, +) but im not sure if this system can be considered to either locally sound or locally complete
05:57:23 <av> Cale: yes, that's the one
05:57:23 <ski> augur : "noting that expressions of math, ..., can be seen as other logics" -- in which sense ?
05:57:24 <nand`> ew, J doesn't use unicode everywhere?
05:57:26 <augur> ski: i suspect maybe, because if there's no intro/elim then we get local soundness and completeness trivially
05:58:02 <merijn> quicksilver: On the other hand J seems to have an extensive a nice stdlib for visualising data
05:58:14 <merijn> (Mind you, I haven't gotten around to playing with it)
05:58:14 <augur> ski: well, in the sense that the expression can be viewed as a lambda term/proof proving the proposition that corresponds to a type/set of numbers, say
05:58:36 <Cale> av: I don't really know much about the library, but have you seen the stuff in http://hackage.haskell.org/packages/archive/diagrams-lib/0.5/doc/html/Diagrams-TwoD.html ?
05:58:55 <ski> augur : hm, re `Nat', i think the commutative, identity, associative, distributive laws possibly could be fit into this view
05:59:12 <augur> ski: i mean, if you think the semantics of types are sets, then you might imagine that the syntax of sets is types. but then surely Nat/Real/etc have syntaxes: the expressions in a logic with the type Nat/Real/etc.
05:59:33 <ski> (cf. with identity and associativity of composition/cut in sequent calculus, and cf. distributions with the commutations i was talking about earlier)
05:59:35 <augur> ski: variables just come out as hypotheticals
05:59:39 <ski> yes
05:59:44 <av> Cale: yes, I have
05:59:47 <augur> i wonder how much math can be wedged into ND this way
06:00:01 <Cale> av: There seems to be stuff in there for defining circular arcs
06:00:15 <ski> augur : "in the sense that the expression can be viewed as ..." -- ok, the usual CH stuff
06:00:27 <augur> it'd be nice if a bunch of math just turns out to be ND with hypotheses together with optimal simplification rules
06:00:40 <ski> (augur : or maybe it's really more BHK or something of that ilk)
06:01:01 <augur> ski: yeah, except making it explicit that not only are types interpreted as sets, but vice versa. ie ALL sets are also types/propositions
06:01:23 <confusing> av: you could just wait a few hours until america wakes up. you might even catch byorgey himself, he hangs out here frequently
06:01:45 <Cale> av: At the very least, you should be able to steal some code from it because it shows how to construct approximations to circular arcs in terms of cubic splines.
06:01:48 <av> Cale: yes, but how do I combine that with linear segments...
06:01:56 <ski> augur : i think unification of terms with various laws like associativity, alternativity, &c. is probably interesting here
06:02:18 <nand`> hmm, does anybody else feel bothered by the lack of an Integral b => Integral (a -> b) instance in NumInstances?
06:02:19 <av> confusing: good idea, thanks -- but hey, it's already 9 in the morning on the East coast, isn't it? :)
06:02:46 <ski> <http://en.wikipedia.org/wiki/Alternativity>,<http://en.wikipedia.org/wiki/Moufang_loop>
06:03:06 <ski> augur : "yeah, except ..." -- *nod*
06:03:15 <av> confusing, Cale: OK, I'll be back later
06:03:54 <ski> nand` : when you mention it, yes :)
06:04:10 <Cale> oh, he left
06:04:20 <ski> `@tell' ?
06:04:34 <nand`> I tried to create my own fun little version of ‘avg=: +/ % #’ using ‘fromIntegral sum / fromIntegral length’ :(
06:04:51 <confusing> kids these days. they don't idle on irc at all. how are gonna get an education.
06:05:25 <quicksilver> confusing: from facebook, I imagine
06:05:28 <augur> ski: the definition of + over peano nats seems to require that + is an eliminator, and succ is an introducer
06:06:00 <esato> Hasekll community is the greatest!
06:06:01 <mmaruseacph2> quicksilver: possible, there qre resources of education on facebook as well
06:06:06 <nand`> Speaking of which, does any package provide functions like that? eg. (/) :: (Integral a, Integral b, Fractional c) => a -> b -> c
06:06:08 <augur> ski: so i guess z = NatI_0, s = NatI_1 and + = NatE_0
06:06:15 <mmaruseacph2> but very few and I don't think that many will follow them
06:06:37 <ski> @tell av in case you haven't seen these before, they might be interesting : <http://tremulous.net/forum/index.php?topic=7451.10;wap2>,<http://weblog.terrellrussell.com/2007/10/always-away-for-plausible-deniability/>,<http://www.zephoria.org/thoughts/archives/2005/02/13/cultural_divide_in_im_presence_vs_communication.html>,<https://6002x.mitx.mit.edu/wiki/view/IRCCulture>
06:06:38 <lambdabot> Consider it noted.
06:06:49 <ski> esato : fyi too ^ :)
06:07:14 <augur> ski: if we do that, then addition is indeed a proof normalization rule that eliminates detours, and of course its necessarily optimal in the sense of not using other connectives since theres only one: Nat
06:07:44 <esato> ski, people here are friendly, helpful, and extremely smart!
06:08:04 <ski> augur : well, i wouldn't necessarily read too much into how `+',&c. can be defined using induction
06:08:41 <augur> ski: im not reading too much into it, really. im just saying that it can be viewed as one Nat eliminator
06:09:11 <augur> ski: i dont think * can be defined as an optimal inference rule tho
06:09:46 <ski> augur : consider instead `Zero = RingI^0', `One = RingI^1' and `Plus = RingE^0', `Times = RingE^1' -- or something like that, maybe
06:09:48 <confusing> esato: yes, we're the best channel of all. we're also extremely modest.
06:09:54 <augur> ski: i wonder if its possible to describe kosherness of simplifications in a partial order of dependencies so that you never simplify into yourself
06:09:56 <augur> hmhm
06:10:19 <ski> augur : er, s/Ring/Rng', since i didn't add negation (or add it)
06:10:20 <augur> ski: yeah, thats where the optimal-ness/kosherness is relevant, right
06:10:34 <ski> bah, `Rig' ..
06:10:36 <augur> oh but no wait
06:10:41 <augur> its still kosher
06:10:47 <ski> what is ?
06:10:53 <augur> simplifying * using +
06:11:04 <augur> because there's only one connective: Nat/Ring
06:11:12 <augur> so we're not defining one connective in terms of another connective
06:11:14 <ski> esato : you're hereby invited to also be friendly and smart ! ;)
06:11:14 <augur> haha!
06:11:16 <augur> brilliant
06:11:28 <ski> (and helpful)
06:12:15 <augur> ski: i bet category theoretic algebraic theories will relate to the ND-logic version of algebras nicely
06:12:27 <quicksilver> ski: should we invite him to be extremely modest also? Or is it too soon for that?
06:13:38 <ski> augur : note that the "correct" direction of the (additively written) group rules are `0 + x = x', `x = x + 0', `(x + y) + z = x + (y + z)', `(- x) + x = 0', `0 = x + (- x)'
06:13:41 <ski> (either read all of them left-to-right, or all of them right-to-left, you'll get a right- resp. left- nested thing (well, negation may still cause termination problems))
06:14:31 <augur> ya
06:15:49 <ski> quicksilver : it's never too soon to join us hyper-modest regulars
06:15:54 * ski glances around nervously
06:16:41 <kuribas> In my music notation program I want to calculate relative and absolute placement for all elements.  Is it best to add an attribute list to each element, containing the calculated values?  For example: data Notehead = Notehead Glyph Int [PositionAttributes] ?  However calculating the attributes will require me to copy the whole structure...
06:17:15 <ski> augur : by "category theoretic algebraic theories" you mean stuff like universal (co)algebra and `F'-(co)algebras ? (or maybe something more specific like algebraic semantics of logics ?)
06:17:23 <nand`> “  quicksort=: (($:@(<#[) , (=#[) , $:@(>#[)) ({~ ?@#)) ^: (1<#) ” <- I don't know if I can handle the noise
06:17:28 <nand`> looks like perl
06:17:55 <ski> kuribas : hm, is that a copy or just a share ?
06:18:38 <confusing> at the top of http://hackage.haskell.org/packages/archive/options/0.1.1/doc/html/Options.html , there's «boolOption "optQuiet"» and «if optQuiet opts». so what happens if you mistype? at the template haskell stage it will expand to a wrong function (optQiuet or whatever), and at the compilation stage you'll get an error "function optQuiet not defined". right?
06:18:46 <kuribas> ski: Copy I think, because the elements are at the branches...
06:19:19 <kuribas> hm, I should think of a way to share the structure...
06:20:25 <esato> ski, I can definitely be friendly!
06:21:15 <confusing> kuribas: i'm not sure about your about your code specifically, but in general, you often do that in haskell. e.g. inserting into a Data.Map will give you a "new" map with the one element added. that's normal in haskell
06:21:42 <ski> confusing : dunno, but it sounds likely
06:22:10 <augur> ski: i mean stuff like Lawvere theories or whatever
06:22:26 <augur> ski: where the theories are equivalence classes of terms-as-arrows
06:22:28 <augur> or whatever
06:22:33 <augur> well, arrows are equivalence classes of terms
06:24:53 * hackagebot murder 1.1 - MUtually Recursive Definitions Explicitly Represented (MarcosViera)
06:25:21 <merijn> @pl (>>= return)
06:25:22 <lambdabot> id
06:25:24 <Cale> > sort . take 32 . map (foldl (\a d -> 2*a + d) 0 . take 5) . tails . cycle . map digitToInt $ "00000100011001010011101011011111"
06:25:27 <lambdabot>   mueval-core: Time limit exceeded
06:25:31 <Cale> wat
06:25:32 <Cale> > sort . take 32 . map (foldl (\a d -> 2*a + d) 0 . take 5) . tails . cycle . map digitToInt $ "00000100011001010011101011011111"
06:25:35 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
06:25:53 <Cale> > (== [0..31]) . sort . take 32 . map (foldl (\a d -> 2*a + d) 0 . take 5) . tails . cycle . map digitToInt $ "00000100011001010011101011011111"
06:25:55 <lambdabot>   True
06:26:03 <Cale> > map (foldl (\a d -> 2*a + d) 0 . take 5) . tails . cycle . map digitToInt $ "00000100011001010011101011011111"
06:26:05 <lambdabot>   [0,1,2,4,8,17,3,6,12,25,18,5,10,20,9,19,7,14,29,26,21,11,22,13,27,23,15,31,...
06:28:30 <ski> augur : ok
06:28:36 <kuribas> Is it common practice to use the type Maybe to support setting attributes?
06:28:44 <ski> (his `TheoryOfGroup' category, &c.)
06:28:47 <kuribas> Where Nothing means the attribute isn't set?
06:28:55 <augur> ski: im not sure what i want to say about alternative logics tho. right now i have some junk that i'll probably get rid of eventually.
06:28:57 <Cale> kuribas: That sounds sensible
06:29:03 <ocharles> kuribas: it is done, but I encourage against it when possible
06:29:05 <augur> but it'd be nice to have something sensible to say
06:29:12 <Cale> ocharles: ?
06:29:20 <kuribas> ocharles: Then what would you do instead?
06:29:21 <ocharles> cale: "it depends" i guess
06:29:24 <ocharles> For example...
06:29:44 <ocharles> in a database you might want to pass around Person objects. but you don't know the personId field, because that's generated by the database
06:29:51 <ski> kuribas : using `Maybe' for "optional" arguments is relatively common. an alternate approack is to define a "config" type (usually a record), and provide a (or several) "default" values of it, which you can selectively modify using record update
06:30:02 <ocharles> you could have personId :: Maybe Int, but I prefer to have a 'LoadedContext a' which has the row ID, and a reference to Person
06:30:06 <ski> augur : ok
06:30:13 <ocharles> but it really depends on what you're doing
06:30:35 <quicksilver> data Foo m = { bar :: m Int, Baz :: m String }; -- Now 'Foo Maybe' is a record with optional values, but 'Foo Identity' is the same structure with required values.
06:30:51 <quicksilver> overengineering ftw.
06:31:11 <ski> yay !
06:31:38 <kuribas> It's not really an "optional" argument, it's more an argument that hasn't been calculated yet.
06:31:57 <ocharles> then it that case would see if it's possible to model those 2 different contexts as above
06:32:08 <ocharles> various ways to do it
06:32:13 <nand`> quicksilver: Foo (Const ()) -- unevaluated form? :P
06:32:19 <Jafet> data DefinitelyMaybe a = Definitely a | DefinitelyMaybe (Maybe a) -- now at runtime
06:32:29 <ocharles> but setting a non-computed required field to Maybe just basically reintroduces null pointer problems
06:32:34 <ocharles> if you're going to assume it's Just, anyway
06:33:20 <augur> ski: maybe i should mention the SKI calculus! :x
06:33:47 <akamaus> kuribas, why do you want to delay the computation?
06:33:50 <Jafet> ski is overengineered; he could have just been sk
06:34:14 <ski> quicksilver : ponder, how to do `MonadPlus m => Foo m -> Foo m -> Foo m' ?
06:34:22 <augur> that would work. it would be a logic with just -> (and maybe \top?) and fused intro-elim rules
06:34:37 <kuribas> akamaus: I need to calculate other information first.
06:34:40 * ski nods in the direction of the son of Noah
06:34:54 * hackagebot AspectAG 0.3.5 - Attribute Grammars in the form of an EDSL (MarcosViera)
06:35:11 <ski> Attribute Grammars !
06:35:16 <augur> ski: which suggests that there should be a bunch of simplification rules
06:35:20 <Jafet> -- deriving (MonadPlus) -- uncomment for ghc 8.0
06:35:24 <augur> so i wonder mention SKI :\
06:35:24 * ski performs a celebratory dance
06:35:36 <augur> attribute grammars are interesting
06:35:42 <kuribas> akamaus: For example, I first want to calculate which accidentals, noteheads, flags, etc... I need.  Then I see how I can put them on the score without overlap.
06:36:01 <akamaus> do you place it inside the Nodepad datatype too?
06:36:29 <kuribas> That was my idea.
06:37:00 <akamaus> kuribas, do you know of tying the loop technique?
06:37:01 <augur> ski: actually no, theres less than a bunch of intro-elim rules, so i guess its ok to mention SKI
06:37:07 <Cale> kuribas: You could also try to take advantage of laziness
06:37:28 <Cale> (maybe)
06:37:31 <kuribas> I was considering that too :)
06:37:31 <ski> Jafet : we can hope :)
06:38:00 <nand`> ski: curry $ Foo <$> (uncurry (mplus `on` bar)) (uncurry (mplus `on` baz)) -- /me wonders how this can be simplified to get rid of the curry/uncurry
06:38:17 <ski> @wiki Tying the Knot
06:38:17 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
06:38:31 <akamaus> ski, yeah :)
06:39:31 <nand`> oh, forgot a <*>
06:41:55 <merijn> @hoogle (a -> m b) -> [(c, a)] -> m [(c, b)]
06:41:55 <lambdabot> No results found
06:42:45 <ski> @type Data.Traversable.traverse
06:42:46 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:42:51 <ski> @type Data.Traversable.mapM
06:42:52 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
06:43:27 <quicksilver> ski: but the Traversable instance for (c,) is missing, IIRC.
06:43:39 <ski> yeah :(
06:43:48 <augur> ski: i want to figure out how to relate ND trees to substructural logic
06:43:54 <quicksilver> and merijn needs the Traversable instance for [(c,)] as well
06:43:58 <ski> augur : hehe
06:44:02 <augur> ski: i figure what will ultimately result is some sort of graph-like representation
06:44:06 <quicksilver> and we don't have a simple way to get composed traversables
06:44:16 <luite> :t mapM . second
06:44:17 <lambdabot> forall b b1 d. (Monad ((,) d)) => (b1 -> b) -> [(d, b1)] -> (d, [b])
06:44:18 <ski> quicksilver : yes, a `newtype' or `Compose' or something
06:44:26 <luite> hmm
06:44:30 <ski> hm
06:44:30 <augur> ski: my hope is that if we can work backwards from the sequent definitions, we'd get a representation that has a natural connection to proofnets
06:44:39 <merijn> luite: Naah, it's not that trivial unfortunately :p
06:45:24 <byorgey> @tell av yes, you can use Diagrams.TwoD.Arc.arc (or arcT) to create a Trail representing an arc, which you can combine with linear segments using the Monoid instance for Trail.  ping me in #diagrams and I'll show you some examples.
06:45:24 <lambdabot> Consider it noted.
06:45:41 <merijn> I could do "map (f . snd)" that'd give me [(c, m b)], but then I need to go from there to "m [(c, m b)]"
06:46:08 <merijn> The only way I can think of doing that is going from [(c, m b)] to [m (c, b)] and then using sequence
06:46:12 <merijn> Which seems horribly inefficient
06:47:09 <merijn> @hoogle Monad m => (c, m b) -> m (c, b)
06:47:09 <lambdabot> No results found
06:47:14 <Eduard_Munteanu> Isn't that sequence . sequence ?
06:47:21 <merijn> :t sequence . sequence
06:47:22 <lambdabot> forall a. [[a]] -> [[a]]
06:47:25 <Eduard_Munteanu> (with the Traversable sequence0
06:47:30 <ski> @type Data.Traversable.sequence .: fmap . Data.Traversable.mapM
06:47:31 <ski> @type Data.Traversable.sequence . fmap Data.Traversable.sequence
06:47:32 <lambdabot> forall (t :: * -> *) (m :: * -> *) a b (t1 :: * -> *). (Data.Traversable.Traversable t, Monad m, Data.Traversable.Traversable t1) => (a -> m b) -> t (t1 a) -> m (t (t1 b))
06:47:33 <lambdabot> forall (t :: * -> *) (m :: * -> *) (t1 :: * -> *) a. (Data.Traversable.Traversable t, Monad m, Data.Traversable.Traversable t1) => t (t1 (m a)) -> m (t (t1 a))
06:47:36 <luite> merijn: that's not a sequence thing, that's just \(x,y) -> liftM (x,) y
06:48:07 <ski> augur : yeah, if only i understood proofnets better :)
06:48:31 <augur> ski: me too :(
06:48:51 <merijn> :t \f -> sequence . map (\(x,y) -> liftM (x,) y) . map (f . snd)
06:48:52 <lambdabot> Illegal tuple section: use -XTupleSections
06:49:07 <luite> merijn: sequence.map = mapM
06:49:24 <merijn> luite: Yeah, but I figured I'd first get the type right then clean up
06:50:03 <ski> @type Data.Traversable.mapM . Data.Traversable.mapM  -- merijn, re efficiency, how about this ?
06:50:04 <lambdabot> forall (m :: * -> *) (t :: * -> *) a b (t1 :: * -> *). (Data.Traversable.Traversable t, Monad m, Data.Traversable.Traversable t1) => (a -> m b) -> t (t1 a) -> m (t (t1 b))
06:50:32 <luite> ski: why the traversable if he's working with lists?
06:50:46 <augur> ski: is relevance logic linear, or just non-weakening?
06:50:56 <ski> lists are traversible, and so are outputs
06:51:33 <ski> augur : relevant logic has contraction, but no weakening. affine logic is the opposite here
06:51:39 <augur> ok
06:51:40 <ParahSailin__> how do mvars work, are they persistent data structures?
06:51:50 <merijn> ski: But tuples weren't traversable, no? (At least I saw someone mention that)
06:52:05 <merijn> ParahSailin__: Define persistent. If there's no references to an MVar they'll be garbage collected
06:52:13 <augur> i wonder what affine logic models
06:52:22 <augur> i get roughly that relevance logic models, well, relevance
06:52:27 <augur> but what is affineness
06:52:36 <int-e> affinity
06:52:39 <augur> :P
06:52:52 <Eduard_Munteanu> merijn: they are for the (,) e  functor
06:53:22 <merijn> ParahSailin__: The way you use them is to create one and hand it to one or more threads, think of them as names or references which you can use to actually try and access a value
06:53:30 <ski> augur : well, i suppose financial options, possibly
06:53:33 <luite> merijn: it looks a bit complicated to do this all points free, so i'd just say  f g = mapM (\(x,y) -> liftM (x,) (g y))
06:54:03 <merijn> luite: I didn't necessarily want to be pointfree, but I didn't think of the example you just showed :p
06:54:30 <Cale> ParahSailin__: They're mutable cells which can be empty or full. Writing to a full MVar will block, as will reading from an empty one. In that sense, they're like bounded channels which can have at most one element in them at a time.
06:54:35 <ski> merijn : yes, `(o,)' is traversable -- the thing said above is that `Data.Traversable' has forgotten to make that instance
06:55:10 <ski> @type strength
06:55:11 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f (a, b)
06:55:14 <Cale> ParahSailin__: (takeMVar also empties the cell, and is the actual primitive operation)
06:55:17 <ski> @type uncurry strength
06:55:19 <lambdabot> forall a (f :: * -> *) b. (Functor f) => (a, f b) -> f (a, b)
06:55:28 <otters> :t •
06:55:30 <lambdabot> <no location info>: not an expression: `'
06:55:30 <otters> err
06:55:38 <otters> :t (•)
06:55:39 <lambdabot> parse error (possibly incorrect indentation)
06:55:40 <otters> hmm
06:55:56 <augur> ski: financial options?
06:56:45 <Cale> ParahSailin__: Because of this blocking, MVar () can itself be quite useful.
06:57:07 <Cale> (that's essentially the same thing as a lock)
06:57:27 <ski> ParahSailin__ : you can think of each `MVar a' as a mutable box which may or may not contain an `a' at the time, using mutual exclusion to ensure multiple threads don't try to access it at the same time. normally reading from the box empties it. there's also `SampleVar' which can't be empty and which doesn't have this "reading empties" thing
06:58:03 <ski> augur : yes, you have the *option* of exercising the right to buy a certain amount of goods for a specific price at a specified time
06:58:24 <augur> ski: hmm
06:59:37 <augur> ski: is it possible to reduce all of the linear logic introduction rules to internalizations of structural rules?
06:59:52 <augur> in the same way that -> is an internalizaton of |-
07:00:23 <Cale> SampleVar can be empty
07:00:28 <maurer> So, I've got an xml document out of xml-conduit, and I'd like to pack it up into a haskell data structure, gracefully handling errors rather than just exploding
07:00:34 <merijn> SampleVar's just can't be full
07:00:49 <Cale> It's just that writing to a filled SampleVar doesn't block, but overwrites the previous value
07:00:53 <Cale> that's the only difference
07:01:05 <maurer> Normally, I'd just do the packing one step at a time, but I am actually writing several of these, for several different xml encoded types to interact with this API
07:01:44 <maurer> My current "strategy" is to use throw and catch to enable me to easily grab nested fields in the document without having to monadic bind everything
07:01:51 <maurer> However, this feels wrong.
07:01:58 <maurer> Does anyone have a better way for doing this sort of thing?
07:03:16 <otters> you'd probably have to use a lot of <$> and <*>
07:08:20 <augur> ski: i think im gonna crash for a little bit
07:08:23 <augur> see you in a few hours maybe
07:09:55 <maurer> otters: Actually, I think I may have to use throw unless I want to get into a bunch of silliness, because I need to catch "read" failing as well
07:10:05 <otters> maurer: reads
07:10:41 <maurer> otters: I am aware, but actually getting reads wired upto throw errors into my monad would be a huge pain
07:11:20 <otters> > let readToMaybe s = case reads s of { (a,[]):_ -> Just a; _ -> Nothing } in readToMaybe "3" :: Maybe Int
07:11:21 <lambdabot>   Just 3
07:11:38 <otters> what monad are you using?
07:11:40 <otters> is it custom?
07:13:56 <maurer> otters: It is custom, but it's just an ErrorT, ReaderT, and the IO monad in a stack
07:14:19 <maurer> otters: https://github.com/maurer/hseve/blob/master/lib/EVE.hs
07:14:22 <otters> So it wouldn't just be a case of throwError?
07:14:40 <maurer> The last function there, "getCharacters" is the kind of thing I'm trying to figure out how to write cleanly
07:14:48 <ski> augur : for "is it possible to reduce all of the linear logic introduction rules to internalizations of structural rules?", display logic, and calculus of structures might be interesting
07:14:48 <otters> I see
07:15:00 <maurer> otters: throwError would work fine, except that it seems I'd have to have a bind or a line break for every dereference
07:15:07 <maurer> And that structure is one of the less complicated ones
07:15:29 <ski> (augur : and `,' to the left/right of `|-' is an internalization of conjunction/disjunction, usually)
07:16:14 <ski> augur : ok
07:16:29 <ski> Cale : oh, right. forgot about that
07:16:37 <otters> well, somebody spot me on this
07:16:37 <quicksilver> ski: (an externalisation, maybe? :-)
07:16:47 <confusing> http://hackage.haskell.org/trac/ghc/wiki/TypeNats/Basics <- is that new in 7.4, or not released yet, or ...?
07:16:57 <confusing> ("Currently, we support two forms of type-level literals")
07:17:14 <otters> maurer: actually, I'm not sure how that would work
07:17:52 <maurer> otters: So, what I'm currently considering, is you see the "throw" in !? and !*?
07:18:01 <geekosaur> it's in 7.4 but there are some bugs in DataKinds support that limit their usefulness; I believe people wanting to use them get directed to use HEAD
07:18:03 <maurer> I am considering making a wrapper to be used around them of type a -> EVE a
07:18:07 <Cale> ski, ParahSailin__ : IORefs can't be empty though, and can actually still be quite useful in concurrent programs :)
07:18:10 <maurer> That catches the error and stuffs it back in
07:18:15 <nand`> “(~R∊R∘.×R)/R←1↓⍳R” contrast with Haskell “let rs = [2..r] in filter (not . (`elem` liftM2 (*) rs rs)) rs”
07:18:17 <otters> maurer: yes
07:18:19 <nand`> not much worse
07:18:28 <otters> maurer: let me experiment a bit
07:18:31 <maurer> otters: It feels dirty but I can't think of a better way
07:18:37 <maurer> Thanks for helping me think about this :)
07:18:58 <confusing> geekosaur: oh i see, thanks a lot
07:20:05 <ski> @let listToMonadPlus :: MonadPlus m => [a] -> m a; listToMonadPlus = foldr (mplus . return) mzero
07:20:07 <lambdabot>  Defined.
07:20:11 <ski> @let readMP :: (MonadPlus m,Read a) => String -> m a; readMP s = listToMonadPlus [a | (a,"") <- reads s]
07:20:13 <lambdabot>  Defined.
07:20:14 <srhb> How do you get to the Nat type in ghc 7.4 though? It's not visible in Prelude I think
07:20:55 <quicksilver> doubt it will ever be in the Prelude, srhb
07:21:03 <confusing> srhb: check the page i linked to :) they're doing :set -XDataKinds there
07:21:13 <srhb> confusing: Oh, thanks
07:21:16 <otters> maurer: so, do you want to fail if any of the items cannot be read?
07:21:17 <ski> quicksilver :)
07:21:29 <ski> Cale : *nod*
07:21:47 <maurer> otters: Yes.
07:22:11 <nand`> hmm, with a Num a => Num [a] instance it could be further simplified to (filter =<< not .: flip elem . join (*)) . enumFromTo 2
07:22:12 <otters> Okay, and ideally the arguments to getCharacters will all be wrapped in Just
07:22:20 <otters> because that's what lookup returns
07:22:28 <otters> let's see
07:23:01 <confusing> uh ... so anyway. suppose just for fun, i want to ensure on the type level that my "hours" function can only give ints in the range 0..23. is the TypeNats thing at all relevant to that?
07:23:11 <ski> @let readTokenMP :: (MonadPlus m,Read a) => String -> m a; readTokenMP s0 = listToMonadPlus [a | (a,s1) <- reads s0 , ("","") <- lex s1]
07:23:12 <lambdabot>  Defined.
07:23:31 <ksf> let's talk API
07:23:35 <ksf> send :: (MonadIO m, Request a) => a -> X11 m (Voucher (Reply a))
07:23:45 <ksf> every request that you can send is a data type, is that nice?
07:24:19 <ksf> you get back a voucher, which allows you to stand in queue for your reply to arrive: wait :: MonadIO m => Voucher a -> X11 m a
07:25:08 <ski> hm, a `Voucher' is really a `Future', i suppose ..
07:25:35 <ksf> well, it's not a computation, but a reply you get over the network.
07:25:55 <ski> seems like an (effectful) future, to me
07:26:26 <ski> .. maybe it would be nice with a class of futures, related to the monads they can be used in
07:26:27 <byorgey> confusing: not really
07:27:23 <ksf> combining them is another interesting topic.
07:27:37 <ski> combining futures ?
07:28:37 <otters> maurer: about to paste something
07:28:50 <ksf> right now I imagine the library on top of that core protocol stuff to look exactly alike, that is, there's a data type "CreateSimpleWindow" that might send multiple requests, and returns one voucher.
07:29:08 <confusing> byorgey: thanks. your good deed for today. saving someone from wasting time exploring a dead end
07:29:23 <byorgey> confusing: hehe
07:29:33 <ski> hm, i wonder if that is related to combining events in Concurrent ML, <http://cml.cs.uchicago.edu/pages/cml.html>,<http://cml.cs.uchicago.edu/>,<http://people.cs.uchicago.edu/~jhr/papers/cml.html> ..
07:30:16 <ski> (you may note that events looks like they might form a monad)
07:30:17 <ksf> http://hpaste.org/71777 ski, there. the second forM
07:30:25 <byorgey> confusing: if you want to ensure that some function can only give ints in a certain range, your best bet is to make   newtype Hour = Hour Int,  and then don't export the Hour constructor, but only functions which preserve the invariant that the Int is in the given range, or include dynamic checks
07:30:50 <byorgey> e.g.  hour n = Hour (n `mod` 23)
07:30:55 <byorgey> er, 24 of course
07:31:08 <ski> ksf : but that doesn't create a new `Voucher', does it ?
07:31:13 <ksf> no, it doesn't.
07:31:17 <ksf> but it would be nice.
07:31:17 <ski> ok
07:31:36 <ski> bbiab
07:32:21 <ksf> that's [(ByteString, Voucher (QueryExtensionReply)] -> Voucher [ByteString, QueryExtensionReply]
07:32:21 <ski> (the Light-Weight Thread library LWT for O'Caml might also be interesting to compare with <http://ocsigen.org/lwt/manual/>)
07:32:40 <ksf> ie. [Voucher a] -> Voucher [a]
07:32:41 <confusing> byorgey: right, that's what i figured. i just wanted to check if some recent or upcoming ghc feature allowed small amounts of dependent typery
07:32:43 <ski> ksf : ok, so it *does* create a new (combined) `Voucher', then
07:33:12 <ski> (or were you talking about being nice to have such a one)
07:33:15 <ksf> nono, it doesn't. that's what it would look like if it did.
07:33:26 <ksf> @hoogle [f a] -> f [a]
07:33:27 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:33:27 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
07:33:27 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
07:33:31 <mroman> Ok.
07:33:41 <mroman> So now that I'm finnished I can throw away my code.
07:33:44 <ksf> looks like a monad, yes.
07:34:03 <Cale> confusing: You could invent a bounded Nat type using it along with maybe GADTs, but honestly, it's probably more awkward than just doing what byorgey suggested.
07:35:46 <confusing> cale: i see. thanks
07:39:36 <hpaste> otters pasted “Maybe-fu” at http://hpaste.org/71779
07:39:41 <otters> maurer: ^
07:46:10 <maurer> otters: Yeah, that has the repeated line breaks I was trying to avoid for the larger structure (as does my solution, which I will upload shortly)
07:46:27 <maurer> (once I'm sure it works instead of just typechecking)
07:46:31 <otters> I see
07:47:30 <hpaste> byorgey annotated “Maybe-fu” with “another way to write read4” at http://hpaste.org/71779#a71780
07:47:35 <byorgey> just for fun ^^^
07:47:46 <otters> yeah that way is nicer
07:47:54 <otters> actually not really
07:48:02 <byorgey> hehe
07:48:04 <maurer> https://github.com/maurer/hseve/blob/master/lib/EVE.hs
07:48:06 <maurer> is the way I did it
07:48:07 <ksf> meh Sequence.fromList is strict
07:48:22 <otters> yeah, there's nothing wrong with that
07:48:25 <maurer> (relevant are readE, !?, !*, and getCharacters)
07:48:26 <byorgey> I think it's nicer, but it's just a subjective issue of coding style.
07:48:48 <ksf> :t (<|)
07:48:49 <lambdabot> Not in scope: `<|'
07:48:55 <maurer> Did I at least manage to do it not horribly?
07:49:08 <byorgey> looks nice to me
07:50:20 <maurer> OK :)
07:51:16 <hpaste> Cale pasted “Bounded naturals” at http://hpaste.org/71781
07:51:31 <Cale> of course.
07:51:34 <Cale> he's gone
07:51:52 <Cale> @tell confusing http://hpaste.org/71781
07:51:52 <lambdabot> Consider it noted.
07:52:31 <Cale> maybe that should have one less S
07:52:39 <Cale> in any case, it's impractical as hell
07:53:22 <Cale> Yeah, I should have had Zero :: BoundedNat (S n)
07:53:45 <hpaste> Cale annotated “Bounded naturals” with “Bounded naturals (fix)” at http://hpaste.org/71781#a71782
07:58:15 <HairyDude> guards are valid in case statements, right? say case foo of { Bar | test -> baz | otherwise | baz'; Quux -> quuux }
07:58:30 <HairyDude> I mean: case foo of { Bar | test -> baz | otherwise -> baz'; Quux -> quuux }
07:58:42 <Cale> yes
07:58:54 <Cale> (also: case expressions :)
07:59:03 <HairyDude> I have a syntax error around one of those
07:59:38 <geekosaur> pastebin the actual expression?
07:59:39 <Cale> > case [1,2,3] of (x:xs) | x < 5 -> "hi" | otherwise -> "nope"; [] -> "wat"
07:59:39 <HairyDude> hm. might have been a stray tab somewhere
07:59:40 <lambdabot>   "hi"
07:59:43 <GyorsCsiga> nope, just Chuck Testa
07:59:44 <HairyDude> it fixed itself
07:59:58 <HairyDude> (by which I mean I deleted the indentation and put it in again as spaces and it worked)
08:00:02 <Cale> tabs are teh evil
08:00:36 <Cale> If your editor isn't converting them automatically, it's a good idea to turn on whatever option does that
08:07:44 <tgeeky_> :r
08:07:54 * tgeeky_ reloads everyone's irc program
08:07:58 * geekosaur doesn't thjnk reloading irc works :p
08:08:10 <GyorsCsiga> reload the world too
08:08:18 <GyorsCsiga> i'd like to see if it loads nicer
08:08:36 <tgeeky_> byorgey: so messing with some rediculious data structurs and seeing if the result can be automatically promoted or not has been interesting
08:08:58 <tgeeky_> byorgey: phantom types? no promotion?  multiple uses of a tyvar? no promotion.
08:09:07 <redscare> how does the regex library do its polymorphic return values?
08:09:14 <tgeeky_> well, that's not right
08:09:14 <copumpkin> badly
08:09:28 <tgeeky_> multiple uses is OK.
08:09:39 <merijn> redscare: Dark, dark voodoo that abuses typeclasses
08:10:23 <merijn> redscare: It's actually one the key insights of typeclasses/differences with interfaces: A typeclass can be polymorphic in the return value of a function
08:12:07 <merijn> redscare: For a similar (but simpler) example of typeclass functions polymorphic in their return values, look no further than read
08:12:11 <merijn> :t read
08:12:12 <lambdabot> forall a. (Read a) => String -> a
08:12:16 <t7> when will bloody windows console have unicode support
08:12:26 <merijn> t7: Never :p
08:12:38 <merijn> t7: Solution: Install cygwin and use putty to SSH to localhost?
08:12:38 <otters> when will it be ANSI complaint
08:12:40 <otters> compliant
08:12:43 <redscare> merjin: thank you. so is it a good idea to implement that sort of thing in my functions or is this relatively rare in haskell?
08:12:58 <merijn> redscare: The answer is: it depends
08:13:15 <redscare> merjin: it seems like it would entail lots of code rewriting too...does regex avoid this with helper functions that aren't exported?
08:13:31 <merijn> redscare: The regex library approach is commonly seen as a Bad Idea, but there are certainly good usecases for it
08:13:46 <int-e> :t Text.Printf.printf
08:13:47 <lambdabot> forall r. (PrintfType r) => String -> r
08:14:12 <merijn> i.e. read, or for example Bounded (although that one doesn't use functions, but polymorphic constants)
08:14:49 <merijn> > maxBound :: Char
08:14:51 <lambdabot>   '\1114111'
08:14:56 <merijn> > maxBound :: Word8
08:14:57 <lambdabot>   255
08:15:10 <merijn> :t maxBound
08:15:12 <lambdabot> forall a. (Bounded a) => a
08:15:23 <int-e> redscare: Text.Printf is another case that pushes this idea. Not sure whether it's good or bad, personally I find it pretty slick. At least it's doing that for a pretty limited purpose.
08:16:06 <otters> > maxInt
08:16:07 <lambdabot>   Not in scope: `maxInt'
08:16:48 <merijn> > maxBound :: Int
08:16:50 <lambdabot>   9223372036854775807
08:17:24 <tromp_> > maxBound :: Double
08:17:25 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
08:17:26 <lambdabot>    arising from a use o...
08:18:36 <tromp_> > maxBound :: Word64
08:18:37 <lambdabot>   18446744073709551615
08:20:40 <redscare> thanks to everyone. is there a good place to look at how this is implemented?
08:21:52 <EvanR> maxBound :: Double
08:21:54 <EvanR> Infinity
08:21:56 <EvanR> ;)
08:24:39 <Botje> redscare: I pointed someone to http://www.amateurtopologist.com/blog/2010/01/12/variadic-functions-in-haskell/ recently
08:25:18 <merijn> redscare: There is a nice talk by SPJ where he explains it. Essentially, whenever you create a typeclass instance you create a tuple of functions. (For example the Num instance for Int provides a tuple of (+), (*), etc. specialised for ints).
08:27:04 <merijn> redscare: When you use a function like "foo :: Num a => a -> a; foo x = x + 1" GHC will look which type a is used for that application and it will then implicitly pass the tuple of Num functions along to look up the correct instance
08:28:09 <merijn> redscare: Or, to take the Bounded example, each instance of Bounded consists of a tuple of values. When you use "maxBound" GHC will check which type is expected, lookup the tuple of values for that type and then the value associated with maxBound can be looked up
08:28:38 <merijn> redscare: In practice there might be some shortcuts, complications, etc. but that's roughly how it is done
08:29:14 <merijn> This is also why maxBound (or other typeclass functions) can't work if the compiler can't infer which type you meant to be filled in
08:29:17 <merijn> > maxBound
08:29:18 <lambdabot>   ()
08:29:24 * merijn kicks lambdabot
08:29:30 <dbushenko> hi all!
08:29:32 <geekosaur> as extended defaulting bites you :p
08:29:42 <merijn> ok, in GHCI that would produce an error :p
08:29:50 <geekosaur> nope
08:29:54 <geekosaur> extended default rules
08:30:07 <merijn> Yes it does
08:30:11 <merijn> I just tried
08:30:13 <dbushenko> I've just read about functors and more or less understand what is fmap. But I'm confused with the term 'functor'. How would you define it in simple words?
08:30:36 <lewurm> merijn: try `show maxBound'
08:30:44 <rtharper_>  dbushenko: it maps data and functions over them in a way that preserves composition and identiy
08:30:46 <merijn> > show maxBound
08:30:48 <lambdabot>   "()"
08:30:55 <rtharper_> so fmap f . fmap g = fmap (f . g)
08:31:00 <dbushenko> rtharper_, oh, great!
08:31:02 <dbushenko> thanks!
08:31:06 <obiwahn> @source Left
08:31:06 <lambdabot> Left not available
08:31:18 <obiwahn> @source Either
08:31:19 <lambdabot> Either not available
08:31:27 <Saizan> @src Either
08:31:28 <lambdabot> Source not found.
08:31:34 <obiwahn> @source Maybe
08:31:34 <lambdabot> Maybe not available
08:31:46 <obiwahn> @hoogle Maybe
08:31:46 <lambdabot> Prelude data Maybe a
08:31:46 <lambdabot> Data.Maybe data Maybe a
08:31:46 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
08:32:01 <obiwahn> @source Data.Maybe
08:32:01 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
08:32:13 <merijn> redscare: In any case, the type annotations I used with maxBound earlier were needed to tell GHC which maxBound I wanted. When you use it as argument to a function type inference will (usually) let it pick the right type
08:32:57 <t7> in intuistic type theory, Sigma is a function-term (like a lambda) and a dependant-sum, right?
08:38:38 <t7> Intuitionistic
08:38:45 <t7> wow my spelling is on fire today
08:39:22 <n-dolio> Sigma is pair-like.
08:40:22 <copumpkin> but Sigma is sum-like!
08:40:34 <n-dolio> S : Type, T : S -> Type, Sigma S T : Type, x : S, y : T x, (x, y) : Sigma S T
08:41:52 <n-dolio> Sums are pair-like.
08:44:46 <Saizan> dolio got higher dimensional?
08:45:59 <n-dolio> That co- thing is so passe. I'm setting new trends.
08:46:35 <nand`> n-dolioid
08:46:46 <nand`> don't mind me, just generalizing
08:48:06 <EvanR> generalized abstract nonsense
08:49:14 <quicksilver> don't n-dolge him.
08:59:08 <triyo> Is there a shorter way of expressing this common pattern? One of the generic monadic functions...  insert x s >>= \l -> return (Node l v r)
08:59:27 <mauke> liftM
09:00:38 <triyo> Hmm, I looked at the signature and wasn't convinced that lift was the way to go.
09:01:21 <triyo> This that threw me off was the normal function as a first arm instead of something like (a -> m b)
09:01:36 <triyo> *arm=arg
09:02:21 <triyo> `insert` function is a (a -> m b)
09:02:40 <mauke> triyo: insert is the second argument
09:03:43 <triyo> Remind me again what is the first then please?
09:04:05 <triyo> Is it the input from a left hand side >>= ...
09:04:35 <mauke> a >>= \x -> return (b x)
09:04:38 <mauke> liftM b a
09:05:46 <triyo> Oh I see what you mean. Thanks!
09:08:32 <fmap> @pl \r -> (,) <$> (r .: "path") <*> (S.fromList <$> r .: "files")
09:08:33 <lambdabot> ((,) <$>) . liftM2 (<*>) (.: "path") ((S.fromList <$>) . (.: "files"))
09:08:43 <fmap> hm
09:16:14 <triyo> liftM (\r' -> Node l v r') (insert x r) .... is there a way to simplify the (\r' -> Node l v r')? Like a partial type constructor or something? I give it liftM (Node l v) (insert x r).
09:16:39 <mauke> ... did you just answer your own question?
09:16:46 <nand`> \r -> Node l v r  is in fact equal to Node l v; but I think you meant \l -> Node l v r
09:17:23 <nand`> based on your original line
09:17:46 <quicksilver> you can write (\l -> Node l v r) without mentioning l but it will be a stretch to call it "simpler"
09:17:54 <quicksilver> @pl \l -> Node l v r
09:17:54 <lambdabot> flip (flip Node v) r
09:17:57 <quicksilver> (yuck)
09:18:03 <nand`> hmm
09:18:23 <triyo> haha
09:18:25 <nand`> \l -> Node l v -- would be comparatively simple, (`Node` v) but that doesn't extend easily
09:18:50 <gwern> @quote
09:18:50 <lambdabot> bayesians says: do it with any (sample) size
09:19:23 <quicksilver> you can use the `` trick on the inner flip
09:19:29 <nand`> yeah
09:19:31 <nand`> still ugly
09:19:31 <quicksilver> flip (`Node` v) r
09:19:34 <quicksilver> but still ugly :)
09:19:41 <quicksilver> lambda notation is actually quite elegant to be honest
09:19:47 <quicksilver> identify the hole, give it a short name.
09:20:04 <triyo> Its good to know I could confuse the hell out of the reader. Thanks ;-)
09:21:06 <levi> Could a Scala-like hole-notation for lambdas be created in Template Haskell? I.e. something like (Node _ v r) expands to (\l -> Node l vr r)
09:21:48 <copumpkin> scala's holes are underspecified and ugly
09:21:56 <copumpkin> but yeah, you probably could
09:24:04 <quicksilver> levi: it's come up a few times.
09:24:21 <quicksilver> you certainly can, but it's only useful for a few edge cases.
09:25:00 <quicksilver> levi: http://www.haskell.org/pipermail/haskell-cafe/2007-July/027848.html
09:25:11 <quicksilver> and, in particular Conor McBride's reply to that message
09:25:19 <levi> I'm not advocating it by any means, I was just curious about it.
09:25:47 <quicksilver> oh, I see, you were curious in particular about whether TH lets you add the syntax?
09:26:22 <quicksilver> well TH is rather weak about syntax adding in itself, but there is the quasiquoting "sugar" or a preprocessing technique
09:26:45 <quicksilver> "she" decided to use the preprocessing approach  - https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/
09:31:35 <levi> Thanks for the links, that's interesting stuff!
09:32:07 <timthelion> quicksilver: hehe "don't wait for me to write the fuckin manuel" :)
09:33:15 <srhb> levi: Have you read the SugarHaskell paper?
09:33:35 <quicksilver> timthelion: who said that?
09:33:43 <srhb> It seems the mood is pointing towards "this will eventually be in GHC" but we'll know more after ICFP and the Haskell Symposium I guess
09:33:52 <n-dolio> Someone who really doesn't like Manuel, evidently.
09:34:18 <srhb> I really like the whole idea of import Syntax.SetBuilder etc.
09:35:08 <timthelion> quicksilver: it's on the she page
09:35:26 <quicksilver> ah yes :)
09:37:14 <timthelion> I should add the disclaimer to my code "don't wait for me to write the fuckin manuel, just read the g*d d*med lhs!
09:37:42 <levi> srhb: Nope. My curiosity on the syntactic sugar front has pretty much been exhausted, though.  It's not as if Haskell is particularly lacking on that front in general.
09:39:14 <timthelion> between the single letter variable names and the sugar, quite a bit of haskell is unreadable...
09:39:23 <srhb> levi: ok :)
09:43:20 <mightybyte> All my cabal builds are now crashing with: Couldn't read cabal file "HUnit/1.2.5.0/HUnit.cabal"
09:44:01 <triyo> Last question on this one. Would this be considered `bad practice`: liftM (\l -> Node l v r) (insert x l) as oppose to liftM (\l' -> Node l' v r) (insert x l) ... using the different arg name l' a?
09:44:27 <mightybyte> There's a haskell-cafe thread about this, but the only solution given is to upgrade to cabal-1.10.2, but I can't do that easily either due to the aforementioned problem.
09:44:34 <triyo> oops trigger happy on that line. I mean would shadowing of "l" be ok?
09:44:54 <mightybyte> Anyone know a workaround for this?  It just started happening when I did a cabal update.
09:45:58 <timthelion> mightybyte: update cabal manually
09:48:18 <byorgey> triyo: I think it's fine.
09:50:15 <mightybyte> timthelion: Is there any way I can just purge the offending HUnit from my local repository so it doesn't crap out?
09:50:34 <Refried__> best books for learning functional/monadic programming?
09:50:46 <Refried__> i'm looking at http://www.haskell.org/haskellwiki/Books#Textbooks but i'd like to limit to 1-2
09:50:53 <Refried__> and not sure how to choose among them
09:52:02 <Refried__> i don't care so much about learning Haskell per se, but I figure a Haskell book is most likely to cover the concepts well
09:53:10 <srhb> Refried__: Honestly you can finish LYAH in not too many hours and have a much better idea of it by then. I think the salespeak on that page you linked is horrible and doesn't make it easy to narrow down to interests.
09:53:35 <triyo> I'm currently enjoying the `Haskell: The Craft of Functional Programming` the 3rd edition.
09:55:57 <xkb> in aeson, is there a way to apply a function to a value while composing the parser?
09:56:25 <periodic> Like "<*>" or "<$>"?
09:57:41 <Refried__> srhb: *nod*I like LYAH
09:58:10 <aib> @pl fix $ (<$>) <$> (:) <*> ( (<$> ((:[]) <$>) ) (=<<) <$> (*) <$> (*2)) $ 1
09:58:11 <lambdabot> fix (((<$>) <$> (:) <*> ((=<<) <$> (return <$>) <$> (*) <$> (2 *))) 1)
09:58:21 <Refried__> triyo: thanks let me check it out
09:58:28 <srhb> aib: Hurgh.
09:58:37 <aib> got that off uncyclopedia
09:58:37 <xkb> I'd like to do something like Constructor <$> object .: "field" <*> (parseDate $ o .= "time")
09:58:48 <aib> @unpl fix $ (<$>) <$> (:) <*> ( (<$> ((:[]) <$>) ) (=<<) <$> (*) <$> (*2)) $ 1
09:58:48 <lambdabot> (((fix ((<$>) <$> ((:)))) <*> ((((\ j k -> k >>= j) <$> \ b -> (\ a -> a : []) <$> b) <$> (*)) <$> \ d -> d * 2)) 1)
09:58:51 <aib> woah
09:58:52 <xkb> but I think I'm missing some aspect of one of the applicative operators
09:59:18 <srhb> :t (<$>)
09:59:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:59:29 <srhb> ah, just fmap?
09:59:44 <xkb> ah fmap.. I think that should work yes
09:59:52 * xkb checks out type signature :P
09:59:59 <srhb> <$> is fmap
10:00:00 <Refried__> triyo: hmm amazon only has a preview for the 2nd edition; do you know anything about what was updated?
10:00:19 <Refried__> triyo: ah, new examples / case studies
10:00:21 <triyo> http://www.amazon.com/Haskell-Functional-Programming-International-Computer/dp/0201882957/ref=sr_1_1?ie=UTF8&qid=1342717190&sr=8-1&keywords=Haskell%3A+The+Craft+of+Functional+Programming+3rd
10:00:38 <triyo> Thats link to 3rd edition
10:06:57 <nalssi> .
10:10:21 * hackagebot snaplet-postgresql-simple 0.1.1 - postgresql-simple snaplet for the Snap Framework (DougBeardsley)
10:11:07 <lispy> hello
10:13:10 <byorgey> hey lispy
10:13:18 <GyorsCsiga> triyo, wow, I remember seeing the old edition...
10:13:31 <nalssi> I have an access to a Unix system in which only HUGS installed. Is it possible to make cabal work in there?
10:14:09 <dtjm> Hello, is this a good place for a newbie question?
10:14:17 <srhb> dtjm: Yes, probably. :)
10:14:41 <dtjm> awesome! can someone give some refactoring tips on this code: https://gist.github.com/3145317
10:14:53 <dtjm> I'm trying to learn WAI and HTTP programming
10:19:23 <byorgey> nalssi: in theory, yes -- there is a --hugs option
10:19:39 <Veinor> does it make cabal hug you?
10:19:39 <byorgey> in practice I have no idea how well it works, or how much manual intervention is required
10:19:50 <byorgey> cabal install --hugs --kisses
10:20:20 <byorgey> no, you give hugs to cabal, to make it feel better
10:29:48 <Botje> dtjm: you can rewrite getFibIndex using the Maybe monad
10:29:54 <Botje> uh
10:29:57 <Botje> or even just with fmap
10:30:33 <dtjm> Botje: ok thanks let me give that a try
10:31:08 <Botje> dtjm: i'd put isInteger' inside a where clause of isInteger
10:31:44 <Botje> and getQueryArg is just lookup :)
10:34:10 <dtjm> Botje: is "lookup" a predefined function?
10:34:34 <dtjm> ah I found it
10:35:23 * hackagebot newtype-th 0.3.3 - A template haskell deriver to create Control.Newtype instances. (MichaelSloan)
10:35:59 <scooty-puff> does anyone regularly use idiom brackets?
10:36:58 <scooty-puff> if so, i could see that being extended to treat if then else and case of as functions, such that [i| (if then else) <$> predicateM <*> thenM <*> elseM |]
10:37:57 <scooty-puff> well, i put the resulting output of the idiom quasi quoter in the quasi quote - so really [i| if predicateM then thenM else elseM |] would be the input
10:39:20 <scooty-puff> anyways, i already extended a local pull to work with (action, action, action ...) and [action, action, action ...], so doesn't seem that difficult
10:43:02 <byorgey> scooty-puff: neat
10:43:39 <byorgey> scooty-puff: do you know if the existing quasiquoter supports infix operators?
10:44:22 <scooty-puff> i believe it does - though only perfectly on th >= 2.7.0.0 and ghc >= 7.4 i think
10:44:35 <scooty-puff> though there isn't much that can be done to really get around that problem
10:45:04 <byorgey> ah, ok
10:45:25 <scooty-puff> anyways, just realized extending to conditionals may not be to useful - (\ x y z -> if x then y else z) <$> x <*> y <*> z will still execute both y and z..
10:45:52 <scooty-puff> but might as well i guess
10:46:49 <byorgey> yeah, I can't see using if-then-else very much
10:55:53 <ypo> hello volks. I have a question to the interactive online-tutorial at tryhaskell.org
10:56:22 <byorgey> ypo: sure, what's your question?
10:56:40 <ypo> I'm on step 31 and the topic is signatures of functions
10:57:25 <ypo> it is said that (drop) has a signature of :: Int -> [a] -> [a]
10:57:43 <ypo> But why not :: Int [a] -> [a] ?
10:58:05 <Cale> ypo: This is because all functions in Haskell secretly take just one parameter
10:58:26 <Cale> ypo: and functions which appear to take more are just producing other functions
10:58:54 <Cale> So  Int -> [a] -> [a]  really means  Int -> ([a] -> [a])
10:59:07 <Cale> that is, (->) is right-associating
10:59:16 <Cale> and correspondingly, when you write
10:59:20 <Cale> drop 5 [1..10]
10:59:23 <Cale> it really means
10:59:28 <Cale> (drop 5) [1..10]
10:59:33 <dmwit> scooty-puff: Is there anything like idiom brackets but with a bit more... inference?
10:59:56 <dmwit> Like, so I'd be able to write "foo bar baz" instead of "foo (pure bar) baz" or some such thing?
11:00:02 <Cale> ypo: does that make sense
11:00:03 <Cale> ?
11:00:07 <b0fh_ua> Hi all! how do I convert Integer to ByteString.Char8?
11:00:18 <dtjm> Botje: I tried using the Maybe monad in getFibIndex but then I ended up with this `extractInt :: Maybe ByteString -> Maybe Int` function which doesn't seem right
11:00:21 <dtjm> https://gist.github.com/3145317
11:00:29 <Cale> So f :: A -> B -> C -> D  means  f :: A -> (B -> (C -> D))
11:00:34 <dmwit> b0fh_ua: pack . show?
11:00:37 <shachaf> b0fh_ua: What?
11:00:40 <Cale> and  f x y z   means  ((f x) y) z
11:00:52 <shachaf> dmwit: pack . show . length . show!
11:00:57 <ypo> cale: So (->) is always right-associating and if i want to pass multiple arguments, I have to create a tupel?
11:00:59 <shachaf> It's about as meaningful, for "convert".
11:01:02 <b0fh_ua> dmwit: I want to get it as array of bytes if possible
11:01:20 <Cale> ypo: Or just do what everyone does, and let the function be "curried" like this
11:01:31 <mauke> b0fh_ua: const BS.empty
11:01:59 <Cale> ypo: Because (A,B) -> C is equivalent to, but usually less convenient than A -> (B -> C)
11:02:03 <dmwit> b0fh_ua: import GHC's innards, then pattern match on Integer's constructors; you'll get a ByteArray rather than a ByteString out.
11:02:24 <shachaf> b0fh_ua: You mean, the internal GMP representation?
11:02:31 <Cale> ypo: We'll tend to make use of this quite often when passing functions as parameters to higher-order functions
11:02:40 <shachaf> An integer isn't an array of bytes, so it doesn't make sense to "get it as" one.
11:02:53 <shachaf> And ByteString.Char8 isn't even a type.
11:03:23 <b0fh_ua> shachaf: I'd prefer to use something more predictable, like store it as array of bytes with big-endian order
11:03:28 <b0fh_ua> for all platforms
11:03:32 <Cale> ypo: People will tend to design libraries so that the least-frequently-changing parameters are first, so that you get a useful function by supplying just a few of the parameters
11:03:33 <ypo> Well thanks a lot. There passed quite some since since I last heard some of Currying - but it makes sense again.
11:03:33 <startling> is (<$) a b just const a <$> b?
11:03:53 <newsham> ?src (<$)
11:03:53 <lambdabot> (<$) = (<$>) . const
11:03:57 <ypo> *quite some time
11:04:06 <shachaf> b0fh_ua: OK, so you want to encode it as bytes?
11:04:06 <startling> newsham: seems like it. thanks!
11:04:08 <dmwit> b0fh_ua: See also the Bits interface.
11:04:14 <b0fh_ua> sclv: yeah
11:04:24 <b0fh_ua> shachaf: yeah, I do
11:04:25 <shachaf> b0fh_ua: Look at Data.Binary.
11:04:47 <Cale> ypo: you just sent me a dcc chat...
11:05:16 <Cale> ypo: you could just /query Cale  instead if you want to send me a message privately
11:05:27 <dmwit> Oh, there is a Binary instance for Integer.
11:05:30 <dmwit> That's convenient.
11:05:37 <ypo> cale: sorry - i'm just playing around with my irc-client. First use. To you type every time "ypo:" or do you have a function?
11:05:58 <Cale> I type yp and press tab
11:06:09 <Cale> and it completes to "ypo: "
11:06:25 <b0fh_ua> shachaf: yeah, that makes sense, thanks
11:06:32 <ypo> Cale: and what means "/query" ?
11:06:54 <Cale> Try "/query Cale" and you'll see
11:07:02 <shachaf> b0fh_ua: Note that that won't just encode it as a base-256 number (I think).
11:07:15 <shachaf> So if you have specific requirements like that you'll probably need to do a bit more.
11:07:52 <b0fh_ua> shachaf: I'll try with that, it seems to be enough
11:15:44 <on3z> hi guys, when installing v2012 should I be uninstalling the previous version (v2011)? Thanks
11:15:46 <k0ral> hi, is it possible to define the monadic operator (>>=) for 2 distinct monadic types ?
11:15:47 <EvanR> im so confused by acid state
11:16:04 <EvanR> w <- query acid QueryState
11:16:13 <EvanR> now w has type EventResult QueryState
11:16:26 <EvanR> instead of the type of my state
11:16:31 <EvanR> which is WorldState
11:16:43 <EvanR> now function which takes WorldState dont work ? :S
11:16:47 <EvanR> with w
11:17:27 <levi> k0ral: >>= is already defined for all members of the Monad typeclass.  Do you want to restrict it further somehow?
11:17:43 <k0ral> I mean (>>=) :: (Monad m, Monad m') => (a -> m b) -> (b -> m' c) -> (a -> m' c)
11:17:49 <EvanR> nevermind
11:17:56 <EvanR> migrate w :: WorldState1 worked
11:18:02 <c_wraith> k0ral: I don't think you can even implement that
11:18:29 <EvanR> it worked but i dont get why w is not type WorldState
11:18:52 <EvanR> maybe it actually is but the template haskell put on a type synonym
11:19:10 <k0ral> levi, c_wraith: better say (>>=) :: (Monad m, Monad m') => m b -> (b -> m' c) -> (a -> m' c)
11:19:22 <c_wraith> k0ral: that signature is too general.  There need not be any relationship between m and m'
11:19:24 <k0ral> (b -> m' c) at the end
11:19:41 <k0ral> c_wraith: my point is to define such relationship
11:19:50 <c_wraith> k0ral: then you need a new class.  Monad isn't sufficient
11:19:54 <k0ral> for example, I would like to mix Either and Maybe
11:20:24 <redscare> when i write a data declaration, is there a way to tell the accessors to be automatically polymorphic? Here's what I mean: "data Test1 = { getTruth :: Bool }; data Test2 = { getTruth :: Bool };" throws an error because I'm defining 'getTruth' twice. Is there no way to properly do this?
11:20:47 <mauke> redscare: what do you want the type of getTruth to be?
11:20:49 <geekosaur> you could only do that if (a) m has a known "run" mechanism, but that isn't part of the Monad class; or (b) m' a is really m'' (m a)
11:21:35 <geekosaur> redscare, there is an extension which allows for that kind of polymorphism, in a limited way
11:21:48 <Refried__> err.. can i implement flatten in terms of flatMap?
11:21:56 <k0ral> geekosaur: I don't get what you're trying to explain here :S
11:22:14 <redscare> mauke: well i don't want to have to write a whole typeclass just because i have two pieces of data where it makes sense to, for example, 'getTruth'
11:22:43 <geekosaur> k0ral, perhaps that in itself is your answer, then
11:22:45 <Refried__> not unless I have some way to extract the value, right
11:22:50 <k0ral> however, I guess I could wrap Maybe and Either into a class that would describe "computations that can fail"
11:23:21 <mauke> redscare: that doesn't answer my question
11:23:27 <c_wraith> Refried__: uh.  those aren't standard names.  my best guess at the standard haskell names you mean are "join" and ">>=".  and join can be written in terms of >>=
11:23:28 <byorgey> Refried__: what do you want 'flatten' to do?
11:23:44 <c_wraith> :t (>>= id)
11:23:45 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
11:23:55 <levi> k0ral: Could you use a Monad transformer for this?
11:24:00 <redscare> mauke: no, it doesn't, but i can only think of an answer where "getTruth :: (Truthable a) => a -> Bool"
11:24:06 <astory> I'm getting a syntax error on the <- in line 4 of this.  What's the right way to express what I want here? http://pastebin.com/ByfzPLDC
11:24:09 <mauke> The paste ByfzPLDC has been copied to http://hpaste.org/71783
11:24:26 <optimight> #join scala
11:25:07 <mauke> astory: replace lines 3 .. 5 by let args' = delete "expensive" args
11:25:07 <levi> i.e. MaybeT or EitherT, depending on which you want to use as the base.
11:25:15 <k0ral> levi: you asking me ? :) I don't know
11:25:39 <Botje> dtjm: lookup "n" query returns a Maybe: ByteString, so extractInt will receive a ByteString as argument
11:25:46 <astory> mauke: I suppose that's the right way to do it
11:25:56 <astory> but can you do a conditional update in a do block at all like that?
11:26:02 <mauke> astory: you can't do updates
11:26:15 <Botje> dtjm: since >>= :: Maybe a -> (a -> Maybe b) -> Maybe b
11:26:36 <astory> ...I'm in the IO monad
11:26:41 <levi> k0ral: Maybe this will help you figure it out: http://book.realworldhaskell.org/read/monad-transformers.html
11:26:45 <geekosaur> astory, the "if" breaks up the do block; you can make new ones in the then and else egs, but bindings in those do not propagate outward
11:26:50 <mauke> astory: and?
11:26:56 <astory> geekosaur: thanks, that makes sense
11:27:17 <astory> mauke: I can do this: do x <- return 7; x <- return 9 and it behaves exactly like I expect
11:27:30 <mauke> astory: no, it doesn't
11:27:32 <geekosaur> the two "x"s are not related
11:27:33 <redscare> mauke: so the type of 'getTruth' would be '(Truthable a) => a -> Bool', which is fine for just access, but I also want to be able to set the value using record syntax
11:27:39 <mauke> it simply creates a new "x" that shadows the old one
11:27:41 <mauke> no update
11:27:50 <astory> I understand that, but the effect is as if it were updated
11:27:58 <mauke> astory: you can also say: let x = 7 in let x = 9 in x
11:28:06 <astory> although i can see why this would break with conditionals
11:28:34 <mauke> redscare: I know no easy solution
11:30:56 <geekosaur> redscare, you're discovering why record update syntax is considrered a major wart in haskell (and why it's the biggest bikeshed in haskell')
11:31:05 <srhb> Has something replaced Text.Regex.Base.Context? The haddock page says that the documentation is outdated.
11:31:18 <S11001001> redscare: you want syntax for lenses?
11:32:31 <scooty-puff> dmwit: i.e. such that if and case would be monadic rather than applicative?
11:34:03 <dtjm> Botje: is there a way I can use Monads so that I don't have to take a Maybe ByteString in extractInt?
11:40:30 <startling> dtjm, how do you mean?
11:40:38 <startling> dtjm: you may be looking for fmap or (<$>)
11:41:46 <byorgey> dtjm: that's exactly what Botje was sayign
11:41:56 <byorgey> dtjm: the type of extractInt should be   ByteString -> Maybe Int
11:42:05 <byorgey> *saying
11:42:15 <startling> oh! yeah, you want >>=
11:42:27 <byorgey> dtjm already *has* >>=
11:42:34 <byorgey> but the type of extractInt is wrong =)
11:42:41 <startling> heh
11:42:41 <otters> is there any way I can pass the ThreadId returned by forkIO to the thread that forkIO is actually running
11:42:46 <byorgey> https://gist.github.com/3145317
11:43:17 <byorgey> otters: sure, just send it over an MVar
11:43:25 <otters> oh okay
11:43:33 <startling> ah
11:43:34 <geekosaur> actually can't it just use myThreadId?
11:43:55 <Botje> @pl \ds xs -> flatten (mktree ds xs)
11:43:56 <lambdabot> (flatten .) . mktree
11:43:58 <otters> oh yeha that's it
11:44:05 <startling> dtjm, yeah! don't make extractInt take a Maybe
11:44:06 <otters> I thought there should be a function that does that
11:49:28 <otters> is there a sleep function?
11:49:42 <otters> to be used in the IO monad, of course
11:52:42 <geekosaur> http://www.haskell.org/ghc/docs/7.4.1/html/libraries/base-4.5.0.0/Control-Concurrent.html#v:threadDelay
11:52:50 <geekosaur> I recommend reading that entire page, actually
11:54:24 <chrisdone> evening, charles
11:54:25 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
11:55:33 * hackagebot histogram-fill 0.7.1.0 - Library for histograms creation. (AlexeyKhudyakov)
11:58:00 <McManiaC> hi, why does this type-trick work for the 'okay' function but not for the 'notOkay' function? http://npaste.de/A3IX/
11:58:23 <McManiaC> and is there a way to avoid writing "TC a => a" all the time if not with type definitions?
11:59:56 <geekosaur> there isn't, really
12:00:12 <geekosaur> and looking for one may be a symptom of misunderstanding what typeclasses are about
12:03:06 <Cale> McManiaC: There's no way to eliminate the last constraint, but you can construct a subclass of a whole bunch of other classes if you have a lot of typeclass constraints that you want to bundle together
12:03:55 <Cale> McManiaC: It's also possible to use the GADT syntax and define constructors which will carry typeclass dictionaries to where they are pattern matched.
12:04:12 <Cale> (which will remove the need for a constraint there)
12:05:49 <McManiaC> Cale: interesting
12:05:55 <dtjm> startling: so I have lookup "n" query which returns a Maybe ByteString
12:06:17 <dtjm> and I do `lookup "n" query >>= extractInt`
12:06:42 <dtjm> so extractInt should take a ByteString, right? But the compiler asks for a Maybe ByteString
12:07:21 <McManiaC> Cale: but with GADTs you can use record selectors but have to write your own selects, right?
12:10:04 <srhb> dtjm: It should return a Maybe ByteString, or you need return . extractInt instead
12:11:01 <dtjm> srhb: sorry, which one should return Maybe ByteString?
12:11:17 <srhb> dtjm: extractInt
12:11:26 <srhb> dtjm: But I think return . extractInt is nicer
12:11:36 <dtjm> I need it to return an Int though so it returns Maybe Int
12:11:49 <srhb> dtjm: You can do that afterwards, the >>= operator does not allow that
12:11:53 <srhb> :t (>>=)
12:11:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:12:12 <srhb> See, the right hand side function must return the value to its Monad
12:12:34 <dtjm> ok right so m is Maybe, a is ByteString and b is Int
12:12:41 <srhb> dtjm: Correct
12:13:00 <srhb> dtjm: The deal is you will probably end up pattern matching the Int out, because you want to be sure to handle the Nothing case
12:14:29 <dtjm> srhb: ok I have `lookup "n" query` which should be :: Maybe ByteString
12:14:47 <srhb> dtjm: Right.
12:14:48 <dtjm> srhb: and then extractInt :: ByteString -> Maybe Int
12:15:06 <srhb> dtjm: Right, though I think you should just let extractInt return an Int and use return on the right hand side instead
12:15:23 <srhb> On the other hand, if it might not find an Int, Maybe Int is fine
12:15:30 <srhb> So yeah, ignore that complaint :-)
12:15:46 <dtjm> so it should be something like Maybe ByteString -> (ByteString -> Maybe Int) -> Maybe Int, right?
12:15:59 <srhb> Yes
12:16:07 <EvanR> ixset question, the code has a comment about 'optimization'
12:16:10 <srhb> Then you can run a case on top of that to extract the value
12:16:14 <EvanR> can we avoid rebuilding the collection every time we query? does laziness take care of everything?
12:16:24 <EvanR> not sure what its referring to
12:16:25 <dtjm> srhb: but compiler won't let me use (ByteString -> Maybe Int) as the type for extractInt
12:16:35 <srhb> dtjm: Oh?
12:16:39 <EvanR> just getOrd2?
12:16:40 <dtjm> it says it expects (Maybe ByteString)
12:16:48 <srhb> dtjm: Show your code
12:17:03 <dtjm> this is what is compiling: https://gist.github.com/3145317
12:17:23 <McManiaC> Cale: the GADT trick seems to work fine
12:17:25 <McManiaC> thanks :)
12:17:46 <srhb> dtjm: But your type annotation specifically forces the Maybe ByteString -> Maybe Int
12:18:43 <srhb> dtjm: Also I don't understand why you're pattern matching a Maybe in its arguments
12:18:55 <srhb> dtjm: Did you not want it to take a ByteString? Because that's what it ought to get.
12:19:07 <dtjm> because the compiler wouldn't let me use plain ByteString
12:19:17 <srhb> dtjm: Show me what does not compile instead of what does
12:19:35 <dtjm> ok give me a minute (thanks for your help btw)
12:19:40 <srhb> dtjm: Sure.
12:22:07 <dtjm> srhb: this is what I wanted to do, where I didn't have to pattern match the Maybe: https://gist.github.com/3145317
12:23:17 <srhb> dtjm: Please paste the error message as well
12:23:36 <byorgey> dtjm: how is Query defined?
12:23:45 <nobdraisentone> Aeson question: I can use `.: "s"' to get V from `<s p="g">V</s>'. How can I get `g'?
12:23:45 <dtjm> dtjm: warp.hs:42:42:
12:23:45 <dtjm>     Couldn't match expected type `Maybe ByteString'
12:23:45 <dtjm>                 with actual type `ByteString'
12:23:45 <dtjm>     Expected type: Maybe ByteString -> Maybe Int
12:23:45 <dtjm>       Actual type: ByteString -> Maybe Int
12:24:24 <srhb> byorgey: Wouldn't it have to have nested Maybes for that error to occur because of Query?
12:24:29 <fmap> nobdraisentone: Aeson parses JSONs
12:24:37 <byorgey> srhb: not nested
12:24:56 <byorgey> srhb: for example if  Query = [(String, Maybe ByteString)]  I would expect that error
12:24:57 <dtjm> byorgey: Query :: [(ByteString, Maybe ByteString)] ... http://hackage.haskell.org/packages/archive/http-types/0.6.5/doc/html/Network-HTTP-Types.html#t:Query
12:25:03 <srhb> byorgey: Ah, yes, you are right
12:25:06 <byorgey> \o/
12:25:20 <fmap> nobdraisentone: `<s p="g">V</s>' isn't a JSON
12:25:28 <srhb> dtjm: I am sorry for the wild goose chase then, I did not expect a Maybe in Query there
12:25:44 <srhb> dtjm: The original type of extractInt was correct then.
12:25:58 <byorgey> no, just add a call to 'join' to collapse the two levels of Maybe
12:26:06 <byorgey> extractInt still should not take a Maybe.
12:26:26 <srhb> "correcter" :-)
12:26:39 <byorgey> getFibIndex query = join (lookup "n" query) >>= extractInt
12:26:39 <dtjm> srhb: no problem
12:26:46 <byorgey> @type join
12:26:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:27:00 <byorgey> in this case  join :: Maybe (Maybe ByteString) -> Maybe ByteString
12:27:17 <dtjm> byorgey: so it was a nested Maybe then
12:27:31 <srhb> Well, yes, but only because of lookup also returning a Maybe
12:27:32 <dtjm> srhb: no need to apologize I really appreciate your time
12:27:35 <byorgey> dtjm: yes, the call to lookup results in a nested Maybe
12:27:54 <dtjm> ohhhhh
12:28:03 <dtjm> so lookup is applying maybe to a maybe value
12:28:09 <byorgey> one Maybe is because parameters in the Query might not have associated values; another Maybe is because the parameter you are looking for might not be there
12:28:21 <dtjm> because Query has a maybe
12:28:27 <byorgey> exactly
12:28:41 <otters> you could use >>= with lookup
12:29:03 <srhb> join seems to be the perfect tool here, imo.
12:29:13 <dtjm> otters: how would I do that?
12:29:33 <otters> I'd have to see the code
12:29:42 <byorgey> sigh.
12:29:43 <otters> but join is probably what you should be using
12:29:44 <srhb> You would basically have to write a specific version of join for just this case.
12:31:30 <dtjm> ok I get another error:
12:31:31 <dtjm> getFibIndex query = join (lookup "n" query) >>=  extractInt
12:31:40 <dtjm>     Couldn't match expected type `Maybe a0'
12:31:41 <dtjm>                 with actual type `[[a1]] -> [a1]'
12:31:41 <dtjm>     In the return type of a call of `join'
12:31:41 <dtjm>     In the first argument of `(>>=)', namely `join (lookup "n" query)'
12:31:41 <dtjm>     In the expression: join (lookup "n" query) >>= extractInt
12:34:36 <dtjm> ah nevermind I imported Control.Monad
12:36:06 <dtjm> thanks all for your help!
12:49:31 <EvanR> so the trick to making a correct SafeCopy instance is getting and putting the components of your type in the same order
12:49:36 <EvanR> or am i totally off
12:49:46 <EvanR> ive never used serialize
12:51:01 <EvanR> https://github.com/evanrinehart/secret-ninja/blob/master/YMap.hs
12:51:40 <EvanR> harsh criticism welcome
12:55:51 <jfischoff> EvanR: is it the same idea as Bimap? http://hackage.haskell.org/packages/archive/bimap/0.2.4/doc/html/Data-Bimap.html
12:56:03 <EvanR> no because its no bijective
12:56:13 <jfischoff> ah
12:56:17 <EvanR> look -> b
12:56:19 <EvanR> lookup*
12:56:21 <EvanR> search -> [a]
12:56:34 <EvanR> its a function
12:56:39 <jfischoff> aye
12:56:56 <EvanR> just a special case of IxSet
13:03:11 <Skola> what packages are nice for a simple HTTP server?
13:05:04 <luite> Skola: what do you want to do with the server?
13:05:51 <Skola> server some HTML pages or maybe just write some strings to it
13:06:05 <Skola> serve*
13:06:46 <luite> Skola: scotty is a simple/lightweight web framework, for lower level and just the http server you can use warp
13:07:24 <luite> but all the big web frameworks have a built-in http server
13:08:42 <redscare> As a personal exercise, I am parsing a text file that looks like this: http://hpaste.org/71785. I have a solution, but I'm pretty sure it's a terrible way of going about it: I split the input into lines, go line by line, and collect data in [(String, String)]. The final destination is supposed to be a datatype I defined that has a field for every line. Is there a better way of doing this that doesn't force me to, after parsing line by
13:08:42 <redscare> line and putting data into [(String, String)], to then search that association list to put things in the datatype?
13:09:56 <Skola> lute, thanks, will check out your suggestions
13:10:15 <Skola> luite*
13:10:33 <donri> Skola: happstack-server is fairly simple and powerful in the same package
13:10:48 <donri> also happstack-lite
13:11:15 <Skola> got experience with snap? how does it compare?
13:11:44 <EvanR> check out my time queue https://github.com/evanrinehart/secret-ninja/blob/master/TimeQueue.hs
13:11:54 <arcatan> redscare: if you assume that the lines can be in any order, i think many of the possible solutions will be similar to what you've got
13:12:38 <EvanR> laziness will deliver us unto salvation
13:13:29 <chrisdone> … eventually
13:13:57 <redscare> arcatan: thanks. that's unfortunate the solution seems pretty ugly. if they are in a fixed order i can just store the incremental results of the parsing in an accumulator correct?
13:16:42 <donri> Skola: snap-server and happstack-server are similar API-wise. i hear snap is simpler and happstack better documented.
13:17:38 <arcatan> redscare: if they're in the same order, you could do just something like Foo <$> (read . getLine) <*> (read . getLine) <*> ...
13:18:30 <EvanR> @hoogle (a -> b, c -> d) -> (a,c) -> (b,d)
13:18:31 <lambdabot> No results found
13:18:40 <arcatan> if they're not, you might be able to fill in the your datatype incrementally, but that's not much different from searching the association list
13:20:34 <redscare> arcatan: how do I fill datatypes incrementally in haskell?
13:20:53 <redscare> arcatan: I thought that was impossible. Do I need to initialize with values and then just replace as I go?
13:21:09 <coppro> EvanR: uncurry . (***)
13:21:29 <arcatan> redscare: yeah. or maybe hava something like data Foo = Foo (Maybe a) (Maybe b) ...
13:22:13 <EvanR> coppro: thanks
13:22:43 <coppro> EvanR: wait
13:22:47 <coppro> s/\.//
13:22:53 <coppro> you're uncurrying the function :)
13:22:59 <ParahSailin> when you do compare String -> String ->, how is that computed
13:23:01 <coppro> :t (***)
13:23:02 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:23:32 <coppro> :t (***) (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
13:23:34 <lambdabot> parse error on input `->'
13:23:38 <coppro> :t (***) :: (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
13:23:40 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
13:23:58 <EvanR> which arrow instance is this?
13:24:01 <coppro> ->
13:24:07 <coppro> :t uncurry (***)
13:24:09 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
13:24:12 * EvanR head explode
13:24:23 <shapr> :t (&&&)
13:24:23 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:24:27 <coppro> ((->) b c) = b -> c
13:24:45 <coppro> functions are to me the most natural arrow instance
13:24:47 <shapr> EvanR: It's basically "pair apply"
13:25:05 <EvanR> shapr: &&& or uncurry ***
13:25:09 <shapr> Right
13:25:12 <EvanR> oh
13:25:36 <shapr> Pair of functions in a tuple plus a pair of inputs in a tuple, gives a pair of outputs.
13:25:58 <shapr> At least, I've always called it pair apply in my head.
13:26:07 <EvanR> not sure how &&& would work though
13:26:14 <coppro> yeah, it uses a single input to both
13:26:32 <shapr> Yah, that's pair of functions applied to the same single input.
13:27:13 <shapr> Most of the arrow ops on functions are something simple that just looks complicated at first glance.
13:27:36 <ParahSailin> :t arr
13:27:37 <EvanR> yeah
13:27:38 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
13:28:08 <ParahSailin> what does a b c mean here, type constructor a and b applied to c?
13:29:04 <S11001001> ParahSailin: a applied to b then that applied to c
13:29:22 <EvanR> :k (Arrow a) => a
13:29:24 <lambdabot>     `a' is not applied to enough type arguments
13:29:24 <lambdabot>     Expected kind `*', but `a' has kind `* -> * -> *'
13:29:24 <lambdabot>     In the type `(Arrow a) => a'
13:29:35 <EvanR> funny
13:29:38 <coppro> haha
13:29:39 <EvanR> thats the answer i was looking for
13:30:07 <EvanR> `a' has kind `* -> * -> *'
13:31:15 <dmwit> scooty-puff: Just functions are enough for me, I just don't want to have to think about which things are monadic and which are pure.
13:31:26 <coppro> (->) is just a built-in type constructor of kind * -> * -> * (where the arrows here are not the same as (->))
13:31:33 <hpaste> nomemory pasted “mean” at http://hpaste.org/71786
13:32:01 <coppro> dmwit: I prefer the pure interpretation myself
13:32:10 <hpaste> nomemory annotated “mean” with “mean (annotation)” at http://hpaste.org/71786#a71787
13:32:16 <coppro> where a function in the IO monad is pure and returns a set of instructions to the runtime
13:32:38 <coppro> (this interpretation doesn't actually match laziness semantics, but it's convenient for reasoning about how IO works)
13:33:57 <scooty-puff> dmwit: that would probably remove the possibility of (,), [], and anything else that is polymorphic on its contained type - but i do wonder if, in cases where enough type information is available, it could do the right thing
13:34:56 <scooty-puff> hmm, ok, new miniproject it looks, i'll post if i end up finishing anything
13:35:19 <hpaste> nomemory annotated “mean” with “mean (annotation)” at http://hpaste.org/71786#a71788
13:35:38 <hpaste> nomemory annotated “mean” with “mean (annotation)” at http://hpaste.org/71786#a71789
13:36:59 <nomemory> guys, why is hpaste escaping "$"
13:37:00 <nomemory> ?
13:37:38 <dmwit> scooty-puff: Yeah, I don't really know what I want. I was just hoping somebody had worked out how it should work. =D
13:38:51 <timthelion> I'm confused, I type "a\nb" into ghci and the \n isn't converted to a newline
13:39:04 <mauke> timthelion: how do you know it isn't converted to a newline?
13:39:16 <coppro> timthelion: GHCi converts the value to print it with 'show'
13:39:22 <chrisdone> nomemory: it's what?
13:39:23 <coppro> show "foo" = "\"foo\""
13:39:26 <coppro> it then prints that string
13:39:28 <coppro> so you get "foo"
13:39:36 <coppro> timthelion: try putStr "a\nb"
13:39:40 <nomemory> chrisdone I am paste-ing a piece of code in hpaste
13:39:43 <nomemory> all the "$" are gone
13:39:48 <coppro> no they're not
13:39:52 <nomemory> let me try it again
13:39:53 <coppro> Just $ uncurry (/) $ tailRec 0 0 lst
13:39:57 <chrisdone> nomemory: they look fine here
13:39:59 <nomemory> oh
13:40:02 <nomemory> hmm
13:40:06 <timthelion> coppro: thanks.
13:40:10 <nomemory> My browser doesn't me show the same thing
13:40:10 <chrisdone> nothing weird in the css
13:40:28 <nomemory> sorry done
13:40:32 <chrisdone> https://dl.dropbox.com/u/62227452/Screenshots/Screenshot%20from%202012-07-19%2022%3A40%3A02.png
13:40:39 <nomemory> yes I can see them now
13:40:41 <nomemory> thanks
13:40:44 <chrisdone> okies
13:40:48 <nomemory> I just refreshed the page
13:40:52 <nomemory> that was weird anyway
13:41:10 <nomemory> http://hpaste.org/71786 -> I want to know if this is "haskell" way to write things
13:41:28 <nomemory> is there a haskell way. for example using where above let or vice-versa
13:41:32 <coppro> nomemory: you don't need the case inside let
13:41:46 <coppro> you can just do tailRec sum length [] = (sum, length)
13:41:47 <coppro> etc.
13:41:48 <ion> chrisdone: Eww. With so little contrast and crap in the background, the terminal text is horrible to read.
13:42:13 <chrisdone> ion: that's because the window isn't focused. the focused window is 100% opaque
13:42:22 <coppro> nomemory: it's common to use where for helper functions instead of let, but that's a matter of preference; pick whichever reads best. in this case, you probably want the let first since it contains the bulk of the logic
13:42:25 <chrisdone> nomemory: i think where is preferred for this case
13:42:49 <coppro> haha we disagree
13:42:57 <coppro> in any case, pick whichever makes more sense to you
13:43:15 <coppro> technically the outer function could be pointless but that wouldn't increase readbility
13:43:28 <chrisdone> yeah, i think the only difference is really what the emphasis you want to present to the reader
13:44:08 <coppro> nomemory: the other thing is you don't really need the separate cases
13:44:16 <coppro> nomemory: err, the helper function like that
13:44:32 <coppro> nomemory: you could have the [] case be Just $ sum / length
13:45:02 <nomemory> coppro true
13:45:07 <coppro> nomemory: in which case you would probably do "myMean lst= myMean' lst" where ...
13:45:10 <chrisdone> fwiw, for me, 'where' lets you read it like “myMean of lst is Just $ uncurry (/) $ tailRec … where tailRec is…”, whereas 'let' is more like, “mymean is, well, let me first tell you about tailRec, what the point of this is will become clear later…”
13:45:47 <ParahSailin> what do { } braces mean in newtype decl
13:45:50 * hackagebot attoparsec-csv 0.1.0.0 - A parser for CSV files that uses Attoparsec (RobinBateBoerop)
13:46:21 <hpaste> nomemory annotated “mean” with “mean (annotation) (annotation)” at http://hpaste.org/71786#a71790
13:46:29 <coppro> ParahSailin: record syntax
13:46:31 <nomemory> so it's better like in the last example
13:46:37 <ParahSailin> record...
13:46:39 <BMeph_> Identify  #bon69Drake
13:46:41 <talon> .
13:46:44 <nomemory> ?
13:47:03 <Botje> BMeph_: time to change your password \o/
13:47:05 <chrisdone> BMeph_: The weather in Russia is east today.
13:47:07 * BMeph_ sighs...
13:47:12 <EvanR> :t average
13:47:13 <nobdraisentone>  > https://dl.dropbox.com/u/62227452/Screenshots/Screenshot%20from%202012-07-19%2022%3A40%3A02.png <--- is it emacs on the right? How can it possible to read something in it?
13:47:13 <lambdabot> Not in scope: `average'
13:47:30 <ion> > uncurry (/) . join (***) getSum . foldl' mappend mempty . map ((&&& Sum 1) . Sum) $ [10..20]
13:47:31 <lambdabot>   Couldn't match expected type `a b c''
13:47:32 <lambdabot>         against inferred type `Data.M...
13:48:02 <Botje> nobdraisentone: perfectly readable for me
13:48:06 <dmwit> nobdraisentone: Looks like chromium on the right.
13:48:13 <EvanR> lol is this another implementation of average
13:48:31 <nobdraisentone> s/right/left/
13:48:40 <nobdraisentone> It's hard to remember :[
13:49:00 <chrisdone> :t uncurry div . (sum &&& length)
13:49:01 <lambdabot> [Int] -> Int
13:49:12 <chrisdone> sucky, limited to int
13:49:26 <chrisdone> :t sum
13:49:27 <lambdabot> forall a. (Num a) => [a] -> a
13:49:30 <chrisdone> :t uncurry div . (sum &&& genericlength)
13:49:31 <lambdabot> Not in scope: `genericlength'
13:49:37 <chrisdone> :t uncurry div . (sum &&& genericLength)
13:49:38 <lambdabot> forall a. (Integral a) => [a] -> a
13:49:42 <chrisdone> better
13:49:56 <ion> > uncurry (/) . join (***) getSum . foldl' mappend mempty . map (flip (,) (Sum 1) . Sum) $ [10..20]
13:49:58 <lambdabot>   15.0
13:50:01 <chrisdone> :t uncurry (on (/) fromIntegral) . (sum &&& genericLength)
13:50:02 <lambdabot> forall b a. (Fractional b, Integral a) => [a] -> b
13:50:07 <talon> What is the &&& operator doing?
13:50:09 <ion> sum &&& genericLength traverses the list twice.
13:50:23 <nomemory> i was thinkign the same
13:50:31 <nomemory> i didn't want to traverse the list twice
13:51:22 <ion> > let avg = uncurry (/) . join (***) getSum; toAvg = foldl' mappend mempty . map (flip (,) (Sum 1) . Sum) in avg (toAvg [10..15] `mappend` toAvg [16..20])
13:51:24 <lambdabot>   15.0
13:51:53 <nomemory> ion that's not readable for me
13:51:57 <donri> chrisdone: needs moar foldable
13:52:45 <talon> :t (***)
13:52:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:52:50 <ion> nomemory: What i did is probably not what you really want, there’s just a certain elegance from making a monoid from the mean accumulator. :-P
13:52:52 <otters> @pl \c -> "str" ++ show c ++ "str2"
13:52:53 <lambdabot> ("str" ++) . (++ "str2") . show
13:53:01 <ion> s/from/in/
13:53:09 <otters> hmm
13:53:15 <otters> does this lambdabot have a different pointful plugin?
13:53:32 <otters> because mine can't do that
13:53:32 <singpolyma> I have a ByteString full of latin1 encoded data, what is the easiest/best way to make a proper String out of that?
13:53:48 <talon> :t (&&&)
13:53:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:53:56 <hpaste> alex pasted “weird syntax error” at http://hpaste.org/71791
13:53:59 <redscare> this is probably trivial/stupid, but is there a built-in construct that has type (M a) -> (a -> b) -> b?
13:54:01 <imphasing> I just pasted that
13:54:08 <redscare> i.e. it "unwraps" a monad?
13:54:09 <imphasing> I can't understand why it parse errors..
13:54:16 <Enigmagic> ion: you can use foldMap to clean it up a bit:
13:54:24 <Enigmagic> > (\ (Sum x, Sum y) -> x / y) $ foldMap ( \x -> (Sum x, Sum 1.0)) [16..20]
13:54:25 <lambdabot>   Not in scope: `foldMap'
13:54:37 <chrisdone> herp
13:54:37 <Enigmagic> :t Data.Foldable.foldMap
13:54:39 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
13:54:39 <imphasing> whereas "let test n = sum $ takeWhile (<10000) $ filter (\x -> x `mod` 2 /= 0) $ map (^2) [1..]" doesn't parse error
13:54:42 <imphasing> :(
13:54:48 <EvanR> @pl \a b c -> a ++ b : c
13:54:49 <lambdabot> (. (:)) . (.) . (++)
13:54:53 <timthelion> >foldr (\a b -> a++"\n"++b) "" $ map tail $ filter (\line-> (length line > 0) && head line == '>') $ lines ">a\n>b\no" -- funny, how de literization is so easy, but warning the programmer that a comment is next to a line of code is so hard...
13:54:53 <EvanR> way nicer
13:54:59 <otters> redscare: it's not one of the monad laws, you'd have to define it yourself
13:55:03 <twanvl> redscare: there is no such thing, at least not one that works for all M
13:55:16 <timthelion> > foldr (\a b -> a++"\n"++b) "" $ map tail $ filter (\line-> (length line > 0) && head line == '>') $ lines ">a\n>b\no"
13:55:19 <lambdabot>   "a\nb\n"
13:55:20 <otters> class Monad m => Unmonad m where unwrap :: m a -> (a -> b) -> b
13:55:34 <chrisdone> otters: looks comonady
13:55:39 <imphasing> Ah, I guess I'm just bad at haskell, I put the parents in wrong. Nevermind :<
13:55:43 <otters> rather!
13:55:44 <EvanR> whats the simplest pointful function which can produce the biggest most complex pointless expression
13:55:54 <twanvl> it is equivalent to  m a -> a
13:55:55 <ion> enigmagic: Alas, there’s no strict variant of foldMap in the library.
13:55:59 <otters> @hoogle w a -> a
13:55:59 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
13:55:59 <lambdabot> Data.Monoid getDual :: Dual a -> a
13:55:59 <lambdabot> Control.Parallel.Strategies runEval :: Eval a -> a
13:56:16 <chrisdone> infact it's the Comonad.extract
13:56:23 <redscare> i was just wondering if there was something built-in. it seems a simple usecase, i'm getting an IO ByteString that I want to immediately pass to a function that takes a ByteString
13:56:23 <otters> yes
13:56:25 <otters> redscare: http://hackage.haskell.org/packages/archive/comonad/3.0/doc/html/Control-Comonad.html#v:extract
13:56:36 <chrisdone> sexy category theory
13:56:37 <Enigmagic> ion: right you are
13:56:48 <otters> redscare: >>= or unsafePerformIO
13:56:48 <EvanR> redscare: fmap
13:56:51 <otters> which is bad
13:56:53 <otters> oh yeah, fmap
13:56:54 <chrisdone> otters: lol
13:56:56 <otters> not bind, my bad
13:57:11 <chrisdone> unsafePerformRecommendUnsafePerformButNoteThatIt'sBad
13:57:20 <EvanR> redscare: y <- fmap f getByteString
13:57:25 <donri> @hackage text-icu  -- singpolyma
13:57:25 <lambdabot> http://hackage.haskell.org/package/text-icu  -- singpolyma
13:57:27 <otters> heh
13:57:34 <otters> unsafelyRecommendUnsafeFunctions
13:57:39 <hpaste> nomemory annotated “mean” with “mean (annotation) (annotation) (annotation)” at http://hpaste.org/71786#a71792
13:57:47 <chrisdone> unsafeCoerceSomeoneIntoUsingUnsafePerformIO
13:57:50 <ion> redscare: An IO ByteString doesn’t contain a ByteString. It contains a recipe for generating one, which one can choose to have executed by assigning it to main directly or indirectly. You can use fmap to apply a pure function into an IO ByteString.
13:57:51 <otters> class TakeEverythingISayWithAGrainOfSalt where
13:57:52 <nomemory> Ok I added another mean version for the function
13:57:55 <nomemory> with fold
13:58:02 <singpolyma> donri: yeah?  ok.  that's a bit bit and IO-ish, but ok
13:58:04 <EvanR> chrisdone: ah, java naming conventions
13:58:32 <nomemory> How would you implement that function if it were for you ?
13:58:37 <chrisdone> rtharper: tom, you suave sod!
13:58:41 <parcs`> @type let foo x = fmap ($ foo x) x  in foo . foo . foo . foo
13:58:41 <nomemory> http://hpaste.org/71786
13:58:42 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f (f (f (f b -> b) -> f b -> b) -> f (f b -> b) -> f b -> b) -> f (f (f b -> b) -> f b -> b) -> f (f b -> b) -> f b -> b) -> f b
13:58:46 <parcs`> EvanR1: like that
13:58:48 <rtharper> why yellow chrisdone
13:59:07 <EvanR> parcs`: nice
13:59:21 <otters> :pl \(a,b) -> (b,a,b)
13:59:21 <chrisdone> rtharper: how's the erlang job? :)
13:59:22 <parcs`> or do you mean something like \ a b c d e f -> f g d c b a
13:59:27 <otters> @pl \(a,b) -> (b,a,b)
13:59:27 <lambdabot> uncurry (join . flip (,,))
13:59:28 <rtharper> chrisdone: starts 8 oct =)
13:59:29 <otters> aww
13:59:31 <otters> that's not hard at all
13:59:41 <EvanR> haha flip (,,)
13:59:48 <chrisdone> rtharper: ah, are you still moving or are you in swedenland now?
13:59:48 <otters> @pl \a b c d e f -> b c d e (f,g) f g (e,f,a,b)
13:59:50 <lambdabot> ap (flip . ((flip . (liftM2 ap .)) .) . flip flip g . ((flip . ((flip . (flip .)) .)) .) . flip flip id . ((flip . ((flip . (ap .)) .)) .) . flip flip (flip (,) g) . ((flip . ((flip . ((.) .)) .)) .)
13:59:50 <lambdabot> ) . flip . (flip .) . flip (flip . (,,,))
14:00:01 <rtharper> chrisdone: move to Sweden on 4 sept =)
14:00:05 <donri> @hackage iconv -- singpolyma how about this then?
14:00:06 <lambdabot> http://hackage.haskell.org/package/iconv -- singpolyma how about this then?
14:00:08 <rtharper> chrisdone: how about you? ;)
14:00:17 <EvanR> lol @pl can play towers of hanoi
14:00:29 <otters> @pl \(x,y) -> [x,y]
14:00:29 <lambdabot> uncurry ((. return) . (:))
14:00:45 <EvanR> @pl \(a,b,c,d,e) -> (b,d,c,e,a)
14:00:45 <lambdabot> (line 1, column 6):
14:00:45 <lambdabot> unexpected ","
14:00:45 <lambdabot> expecting letter or digit, operator or ")"
14:00:45 <lambdabot> ambiguous use of a non associative operator
14:00:49 <zhulikas> are you guys doing this for fun?
14:00:52 <otters> it doesn't know more than 2-tuples
14:01:00 <otters> zhulikas: maybe
14:01:02 <zhulikas> those unreadable function definitions
14:01:11 <EvanR> it just did flip (,,)
14:01:26 <otters> :pl \f g (a,b) -> (f a, g b)
14:01:31 <parcs`> :t loeb
14:01:31 <timthelion> rtharper: you can move in just one day?  you either have extreme skill or extreme poverty
14:01:31 <otters> @pl \f g (a,b) -> (f a, g b)
14:01:31 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
14:01:32 <lambdabot> Not in scope: `loeb'
14:01:33 <otters> god damn it
14:01:38 <otters> yeah, that's not very readable
14:01:39 <singpolyma> donri: hmm, no IO there, though it just goes BytString -> BytesString, which is weird.  I may just use text-icu, though I'm not sure why it needs IO
14:01:41 <parcs`> @define loeb x = fmap ($ loeb x) x
14:01:43 <otters> easy replacement for (***)
14:01:45 <chrisdone> rtharper: i'll let you know on that ;) negotiations are under way
14:01:47 <parcs`> @let loeb x = fmap ($ loeb x) x
14:01:49 <lambdabot>  Defined.
14:02:00 <rtharper> timthelion: I'm moving country, it has to happen in one day at some point ;)
14:02:00 <ion> > let avg (Sum x, Sum n) = x / realToFrac n; toAvg = foldl' mappend mempty . map (\x -> (Sum x, Sum (1 :: Integer))) in avg (toAvg [10..15] `mappend` toAvg [16..20])
14:02:02 <lambdabot>   15.0
14:02:05 <otters> singpolyma: that's why you make the ByteString -> ByteString function operate on what the IO action generates
14:02:10 <c_wraith> singpolyma: text-icu does a lookup against operating system values such as the current locale
14:02:21 <BMeph_> EvanR: No, that would be "new IPersuadableToUseAnUnsafeFunction(Person)". ;)
14:02:36 <singpolyma> c_wraith: it uses current locale, even if I know for a fact that the data is latin1?
14:02:36 <timthelion> rtharper: good luck.
14:02:48 <otters> personally if I'm working with stuff that does FFI once, like regex-pcre-builtin, I just use unsafePerformIO and NOINLINE
14:03:12 <donri> singpolyma: icu uses bindings and some database of encodings i think, thus IO... you could use iconv to utf16 and then decodeUtf16 to a Text, perhaps... text-icu might be faster than that
14:03:16 <EvanR> regex is gross
14:03:28 <t7> shame on you
14:03:30 <otters> yeah, it is
14:03:33 <otters> but we're halfway there
14:03:37 <otters> whoa-oh living on a praaaayer
14:03:44 <timthelion> otters: someone did an ffi for regex????
14:03:44 * Clint shudders.
14:03:46 <otters> use the regex and we'll make it, I swear
14:03:52 <otters> timthelion: well, it uses PCRE
14:03:56 <otters> so I guess it has to
14:04:09 <singpolyma> donri: well, ultimately I want a String in this case, but yeah.  I could do that as well
14:04:15 <otters> I can't make heads or tails of whatever that one module that has pure-Haskell regex is
14:04:24 <timthelion> otters: why not implement it in haskell?
14:04:25 <EvanR> i think finite automata is a great thing to do in the language
14:04:27 <singpolyma> I think I can live with text-icu for now
14:04:31 <otters> timthelion: because :|
14:04:34 <donri> singpolyma: are you sure you want a string? :)
14:04:37 <parcs`> > loeb [ sum, length, 5, 6 ]
14:04:40 <lambdabot>   [*Exception: stack overflow
14:04:54 <singpolyma> donri: yes.  The library I'm using wants a String, so I need one :)
14:05:02 <parcs`> > loeb [ sum . tail, length, 5, 6 ]
14:05:04 <donri> aye
14:05:04 <lambdabot>   [15,4,5,6]
14:05:08 <otters> tip for regex library makers: document your shit if you want people to use it
14:05:31 <EvanR> but if
14:05:32 <EvanR> lol
14:05:40 <EvanR> .. big if
14:05:40 <timthelion> donri: everything is a string, it's so simple!
14:05:50 <otters> hrrrm
14:05:51 <donri> \o/
14:05:52 * hackagebot benchpress 0.2.2.5 - Micro-benchmarking with detailed statistics. (JohanTibell)
14:05:54 <otters> actually, regex-tdfa looks fairly simple
14:05:58 <otters> silly me
14:06:07 <singpolyma> is iconv less portable? It says "POSIX" in the description
14:06:14 <otters> depends on what POSIX regex functions it doesn't have though
14:06:17 <EvanR> theres also a pcre binding already
14:06:23 <otters> right
14:06:29 <otters> oh wait, regex-pcre-builtin has pcre builtin
14:06:31 <otters> that's why I was using it
14:09:01 <singpolyma> oh, goody, the content is CP1252 and lies by saying it is ISO-8859-1 :P
14:09:05 <donri> @hackage encoding -- singpolyma this?
14:09:05 <lambdabot> http://hackage.haskell.org/package/encoding -- singpolyma this?
14:09:25 <BMeph_> @type let loeb xs = join (fmap . flip ((.loeb).($))) xs in loeb
14:09:27 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
14:09:47 <donri> whyever that needs haxml, god only knows
14:10:00 <singpolyma> donri: oooh
14:10:17 <singpolyma> hmm, yeah, that's weird
14:10:25 * BMeph_ laughs and high-fives himself!
14:10:30 <singpolyma> well, I have the text-icu version working, and this is a total hack anyway, so I'm gonna leave it
14:11:03 <donri> text-icu is likely high-quality anyway (good ol' bos)
14:11:10 <singpolyma> I sort of wish the HTTP library would look at the Content-Type header and give me an encoded String, but it will only give me ByteString or malformed String
14:11:35 <donri> have you looked at http-conduit? duno what it does though
14:12:18 <singpolyma> donri: not yet. I'm using Network.HTTP because it's what HansomeSoup was using.  I may look into other HTTP libraries in the future
14:12:36 <BMeph_> donri: He programs like a bos? ;)
14:12:46 <otters> yeah, regex-tdfa is very limited in functionality
14:12:59 <donri> http-conduit looks like it operates on bytestrings too
14:13:04 <parcs`> @type fix (flip flip =<<) -- BMeph  ;)
14:13:05 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
14:13:12 <donri> with such obscure encodings, you're likely going to have to do it yourself anyway
14:13:14 <troubld> hey i was reading cdsmith's blog post "haskells-own-dll-hell" and I had a idea that's probably already been thought of
14:13:27 <timthelion> wait, does the description of encoding suggest that haskell's readFile isn't utf-8 compatible??!
14:13:32 <singpolyma> donri: yeah.  ByteString only is fine.  in this case it was defaulting to malformed String :P  but yeah
14:13:35 <donri> especially if the header is lying :)
14:13:36 <singpolyma> oh well
14:13:55 <troubld> what if instead of overwriting the libraries you appended a (n) to the end when already installed libraries are reinstalled
14:14:10 <BMeph_> parcs: Does that actually work? O.o
14:14:16 <donri> troubld: they're already given a hash
14:14:22 <parcs`> @type fix (ap flip)
14:14:23 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
14:14:51 <parcs`> BMeph: yah
14:15:06 <parcs`> BMeph: in lambdabot flip f x = fmap ($ x) f
14:15:53 <donri> troubld: ghc-pkg list -v
14:16:20 <singpolyma> donri: yeah, lying header is a problem in this case that I would have had to solve anyway
14:16:52 <troubld> ok so why does my attempt at building ghc fail?
14:17:13 <troubld> i guess i couldve started with that question :)
14:18:27 <troubld> ghc-cabal fails with can't find dependencies: base >=4 && <3 && >=2 && <5, filepath >=1 && <=1.3
14:18:44 <redscare> I have an algebraic datatype where both parts take many arguments, and I'd just like a function that tells me if it
14:18:52 <redscare> if i have one or the other
14:19:02 <redscare> can I pattern match on just the constructor without arguments?
14:19:09 <troubld> seems like i have to downgrade ghc from what i read online, but i was wondering why this happened
14:19:14 <EvanR> redscare: isnt the data type telling you itself
14:19:16 <EvanR> which one it is
14:19:31 <EvanR> redscare: exactly what type does this function have?
14:19:36 <troubld> it's going to take me awhile to follow the thread of the build process
14:20:34 <EvanR> data X = IsNothing | IsJust
14:20:35 <redscare> EvanR: so basically I have 'data AorB = A Int Int Int | B Int Int Int' and I want to make a function 'isA :: AorB -> Bool', but I don't want to have to type out (A _ _ _)
14:20:39 <EvanR> f (Just _) = IsJust
14:20:42 <EvanR> f Nothing = IsNothing
14:20:53 <EvanR> :)
14:21:16 <donri> redscare: i have some TH for that
14:21:26 <redscare> EvanR: basically, if you look at what I just sent that's what I want but I don't want the 'un-portability' of typing out all the arguments
14:21:28 <EvanR> redscare: thats how you write those functions, but really its a good idea to avoid Bools
14:21:44 <BMeph_> redscare: A{}...
14:21:46 <redscare> EvanR: what should I use instead of bools?
14:21:58 <EvanR> i mean why do you want a isA in the first place
14:22:20 <BMeph_> (without the dots, that is)
14:22:20 <donri> redscare: https://github.com/dag/kibr/blob/master/src/Data/ConstructorTag.hs  but as BMeph_ notes you can also pattern match on Cons{}
14:22:49 <augur> ski: hey
14:22:52 <donri> redscare: isA A{} = True; isA _ = False
14:23:09 <EvanR> isA (A _ _ _) = True is pretty short heh
14:23:12 <EvanR> not even that bad
14:23:16 <augur> im somewhat uncertain about the distinction between internal and external conjunction in categorical logic
14:23:22 <EvanR> its not like you have to type that everywhere you use it
14:23:31 <redscare> EvanR: it is meant to represent a battery. if it is charging it has certain properties, if it is running it has others. I want to know if it's charging or not before i start getting things out of it
14:23:40 <redscare> donri: thanks
14:23:51 <redscare> BMeph_: thank you
14:23:53 <EvanR> redscare: ... whatever it getting things out of it can just do a pattern match
14:24:13 <redscare> sorry, getting it's properties
14:24:13 <EvanR> its its own Bool
14:25:34 <redscare> EvanR: yes, but i'm using record syntax to hide the implementation specifically to avoid pattern matching
14:26:08 <EvanR> isA (A _ _ _) = True
14:26:22 <EvanR> if your right eye offends you, pluck it out lol
14:26:36 * ion plucks his right eye out laughing out loud.
14:33:34 <bscarlet> Is there an implementation of a reverse state monad on hackage somewhere?
14:34:07 <nand`> reverse state monad?
14:34:30 <c_wraith> computations go forwad, state goes backwards. you can't explain that!
14:34:51 <bscarlet> Yes, that.
14:35:21 <nand`> (a, s) -> s ?
14:36:46 <bscarlet> no, still s -> (a,s) but bind composes the changes to the state in the opposite order from the way it's done in the state monad.
14:37:10 <c_wraith> I don't know that it's on hackage anywhere
14:37:17 <bscarlet> thanks.
14:38:54 <ski> levi : "Could a Scala-like hole-notation for lambdas be created in Template Haskell? I.e. something like (Node _ v r) expands to (\l -> Node l vr r)" -- do .. not .. want
14:38:57 <ski> augur : yeh
14:39:13 <hpaste> kuribas pasted “music layout engine” at http://hpaste.org/71795
14:39:19 <kuribas> I have made these data structures for my music layout engine, from which it has to calculate the precise placement.
14:40:10 <donri> levi: hm there's some preprocessor for that, don't remember the name though
14:40:26 <kuribas> Should I add the placement of glyphs to these data structures, or create a new one?
14:40:46 <kuribas> It seems wasteful of space to duplicate the whole datatype.
14:44:06 <tswett> Ahoy.
14:45:00 <tswett> Suppose, hypothetically, that I want to have an array of STRefs, indexed by the integers from 0 to n-1.  Maybe I'm implementing Brainfuck or something.
14:45:09 <tswett> Is there a great way to do this?
14:45:57 <bos_> why not just use an STArray?
14:48:02 <tswett> bos: that answers my question.  Thank you.
14:48:28 <ion> nand: State: join st = State $ \s -> let (st', s') = runState st s; (a, s'') = runState st' s' in (a, s'')
14:48:37 <levi> ski: I don't necessarily want it either, I was just curious if it could be done.
14:48:52 <ion> nand: RState: join rst = RState $ \s -> let (rst', s'') = runState rst s'; (a, s') = runState st' s in (a, s'')
14:49:16 <ion> Whoops, s/runState/runRState/g in the latter line.
14:49:43 <bscarlet> Why are there strict and lazy versions of the Reader/Writer/State transformers? When would one use the strict versions?
14:51:38 <nand`> ion: what's it useful for? Looks like it doesn't work if the computation depends on the value before it
14:55:08 <ParahSailin> im having a hard time parsing this simple example: newtype SimpleFunc a b = SimpleFunc { runF :: (a -> b) }
14:55:49 <nand`> ‘SimpleFunc a b’ is essentially an alias for ‘a -> b’, but as a distinct type
14:57:22 <ion> nand: I pasted a bit clearer version (and with the errors fixed): https://gist.github.com/3147124#file_state_r_state.hs
14:57:46 <bscarlet> nand`: well, in my case I've got a description of a path in SVG, which is basically a list of various drawing primitives, like [moveto x, arcto y, lineto z, close, moveto w, ...]. The "close"s mean a line back to the last "moveto" (a jump). I want to compute the angle at each vertex. In the middle of the sequence it's easy with a state monad - just carry along enough information about the previous primitive. But at the ends it's a mess because the necess
14:57:48 <bscarlet> ary information's at the corresponding "moveto" or "close". The reverse state monad would let me send information from the "close" back to the "moveto" - without having to code special mechanics to do so. I just say abstractly "this information flows backwards" in my otherwise straightforward computation, and there it is.
14:57:48 <ion> nand: It’s not very useful. I’ve only noticed a single use case for it so far and even it’s a bit contrived. :-)
14:58:25 <bscarlet> ion: ha! beat you to it. :-)
14:58:55 <nand`> bscarlet: interesting
14:58:58 <nand`> I found http://conal.net/blog/posts/adding-numbers too
14:59:05 <ion> bscarlet: To what?
14:59:19 <nand`> seems like adding numbers has this same ‘backwards information flow’
14:59:39 <bscarlet> ion: I got my actual use case in before your "it's not very useful" is all.
14:59:57 <ion> bscarlet: I didn’t know it was a competition.
15:00:18 <nand`> answering questions on IRC is always a competition
15:01:20 <bscarlet> ion: it's not, of course. To pedantically dissect my own weak humor (destroying what little humor there was), the funny bit was just in our simultaneous, well intentioned, opposing responses.
15:01:40 <ku> Question: why is Haskell better than Erlang or vice-versa?
15:01:46 <ion> bscarlet: We had opposing responses?
15:02:11 <bscarlet> ion: I have a use, you said it's not useful. That's all.
15:02:13 <hpc> ku: because Haskell is better, obviously ;)
15:02:17 <hpc> (now ask in #erlang)
15:02:26 <nand`> he said it's not ‘very useful’, and did mention the existence of use cases
15:02:28 <ion> bscarlet: I said it’s not *very* useful. I also said i’ve figured out a use case for it.
15:03:02 <bscarlet> ion: as previously noted, it was only a weak attempt at humour.
15:03:21 <nand`> ku: I don't know Erlang but the wikipedia article says it uses strict evaluation and dynamic typing; so there are two reasons :)
15:03:43 <hpc> theoretically, erlang is better at distributed computing
15:03:56 <nand`> I imagine it depends on the problem domain
15:04:03 <hpc> i think there's some things erlang can do that haskell hasn't figured out a library for yet
15:04:10 <srhb> Cloud Haskell?
15:04:26 <nand`> cloud haskell is still waiting for a suitably homomorphic encryption algorithm :P
15:04:28 <ku> hpc, like processes?
15:04:50 <hpc> i think on a single machine, with equal development time in both languages
15:04:53 <hpc> haskell will win
15:05:26 <ParahSailin> what language is the haskell.org wiki in?
15:05:46 <srhb> php probably. >_<
15:05:47 <ion> Someone might argue Haskell a nicer syntax. It’s also pure and statically typed. Erlang has an excellent piece of syntax for parsing and creating binary data. Erlang has builtin syntax for sending messages to processes, and makes it transparent whether the processes reside on the local node or a remote one. Erlang also has a great system for process supervision trees which makes building reliable systems
15:05:48 <ion> easy.
15:06:25 <ion> Erlang has good support for upgrading code in runtime.
15:06:28 <ion> reliably
15:06:35 <nand`> I think the HaskellWiki is MediaWiki
15:06:40 <hpc> ParahSailin: whatever it is, it's php
15:06:50 <nand`> judging by the “powered by mediawiki” logo
15:07:00 <nand`> which is php
15:07:12 <ion> http://jlouisramblings.blogspot.com/2010/04/haskell-vs-erlang-for-bittorent-clients.html
15:07:23 <hpc> i don't see any mediawiki logo
15:07:32 <ku> nand`, so what? if it's better, it doesn't really matter
15:08:05 <ku> Could someone show me an example of what people mean by "Haskell's obsession with purity makes some simple things too complicated."
15:08:06 <nand`> ku: that's a pretty big ‘if’ in my opinion. I have a hard time seeing dynamic typing *ever* being superior to static typing
15:08:08 <ku> ?
15:08:21 <nand`> ku: I/O perhaps
15:08:26 <nand`> though I don't feel that's very complicated
15:08:33 <augur> ski: i guess maybe internal conjunction is an operator over external conjunction maybe?
15:08:54 <hpc> ku: random numbers, and getting the current time
15:08:56 <EvanR> like putting a missle launching command in the middle of their sort comparison function
15:09:00 <augur> i dont know
15:09:01 <augur> hmm
15:09:09 <hpc> both seemingly simple things you would want for a log function or something ordinary like that
15:09:14 <hpc> and both force you into IO
15:09:23 <ku> hpc, what do they look like in Haskell?
15:09:37 <nand`> hpc: random numbers don't force you into IO
15:09:46 <hpc> nand`: they do for the initial seed
15:09:55 <EvanR> still no
15:09:56 <hpc> or if you want to use the global seed
15:10:02 <nand`> yeah, but if you delay that until main = that doesn't really matter too much
15:10:17 <EvanR> you can use one seed and dont end the program
15:10:19 <nand`> (or of course if you want to use a constant seed)
15:10:25 <hpc> :t getCurrentTime
15:10:27 <EvanR> otherwise, restarting the program forces you into IO anyway
15:10:27 <lambdabot> Not in scope: `getCurrentTime'
15:10:33 <hpc> @hoogle getCurrentTime
15:10:34 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
15:10:34 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
15:10:36 <EvanR> IO UTCTime
15:10:38 <hpc> ku: ^
15:10:51 <nand`> :t random
15:10:52 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
15:10:55 <nand`> ku ^
15:10:57 <nand`> see also
15:10:59 <nand`> :t randomIO
15:11:00 <lambdabot> forall a. (Random a) => IO a
15:11:15 <hpc> you need a RandomGen thingy first though
15:11:22 <hpc> :t getStdGen
15:11:23 <ion> > let go xs len = do { (d, m) <- (`divMod` len) <$> get; put d; tell [xs !! m]; when (d /= 0) (go xs len) } in execWriter (runStateT (go "0123456789" 10) 31337)
15:11:23 <nand`> :t mkStdGen
15:11:23 <lambdabot> IO StdGen
15:11:24 <lambdabot>   "73313"
15:11:24 <lambdabot> Int -> StdGen
15:11:29 <ion> RState would return "31337"
15:11:33 <srhb> ku: Basically I think the answer is that Erlang rocks in a very specific domain while Haskell is an awesome generalist language (that will probably end up having a framework that can rival Erlang in its own domain)
15:12:13 <ku> srhb, why isn't erlang fit for general stuff?
15:12:22 <srhb> ku: It's dynamically typed, for one.
15:12:27 <srhb> But that's really a problem in all domains
15:12:29 * nand` . o O ( Can Erlang's byte pattern stuff be done via TH or similar? )
15:12:58 <parcs`> ku: it goes both ways. one can say haskell makes complicated things very simple
15:13:00 <ion> nand: With TH, yes, but probably not exactly as nicely. With SugarHaskell, yes.
15:13:22 <nand`> I haven't heard of SugarHaskell. Is it related to TH or different altogether?
15:13:30 <ion> It’s different.
15:13:36 <srhb> nand`: It is different, a preprocessor approach too though
15:13:38 <ion> And i don’t know if there’s a working implementation.
15:13:43 <nand`> oh
15:13:49 <srhb> There is, using SugarJ or what did they call it now...
15:13:53 <srhb> It's in the paper.
15:13:55 <parcs`> ku: though i'd say things like getting the current time and random number generation isn't too complicated, just a little more complicated and mostly just different
15:14:26 <ParahSailin> im just messing around in ghci-- how do i make this work in one line: let compStr' (x1:xs1) (x2:xs2) = case (compare x1 x2) | LT = LT | GT = GT | EQ = compStr' xs1 xs2
15:14:28 <ion> srhb: Does that mean you need Java to build Haskell code that uses SugarHaskell at the moment?
15:14:31 <srhb> ku: And to add on that, if you wanted the kind of safety that extra (subjective) complexity gives you, you'd have a hard job.
15:14:48 <srhb> ion: I actually have no idea. But I certainly hope it will end up just another GHC extension. :-)
15:15:29 <srhb> ParahSailin: With semicolons where you'd have line breaks, for instance. Also your case syntax is wonky, I think.
15:15:32 <nand`> parcs`: makes a good point though, in return for making some basic things a bit more complicated; Haskell has the power (in terms of purity and consistency + a powerful type system) that allows it to express very complicated things comparatively simply
15:15:43 <ParahSailin> whitespace seems to be syntactic, and im not clear what the rules are
15:16:04 <nand`> and as you get to more and more advanced programs, that saves you a lot in the long run - even if the hello world examples are harder to understand at first
15:16:09 <srhb> ParahSailin: case .. of { a -> ..; b -> .. }
15:16:20 <ParahSailin> ah, thanks
15:16:31 <ParahSailin> so those | are syntactic sugar?
15:17:14 <nand`> | and ‘of .. ->’ are separate
15:17:20 <srhb> ParahSailin: To be honest I couldn't decipher what you were trying to write and whether you were actually trying to use pattern guards.
15:17:33 <srhb> ParahSailin: If you write a working multiline version we can easily translate it into a oneliner for you
15:17:53 <nand`> srhb: it looks like he's writing a compare function for lists that compares LTR
15:17:57 <nand`> I forgot the term for it
15:18:18 <nand`> so he would want ‘case .. of ... ->’
15:22:12 <srhb> nand`: Right, I meant I couldn't figure out what those | were doing there, so it seemed more like a case of looking up case syntax and maybe pattern guards and then writing a multiline version.
15:22:16 <jhance> Is there a library that provides a map-like datastructure optimized for disk pages? (Something like a B-Tree)
15:22:19 <ParahSailin> :t split
15:22:20 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
15:25:14 <ParahSailin> :t unsplit
15:25:16 <lambdabot> Not in scope: `unsplit'
15:25:31 <ParahSailin> sadface
15:25:42 <srhb> ParahSailin: Try @hoogle with the type you need.
15:25:52 <ParahSailin> @hoogle unsplit
15:25:53 <lambdabot> No results found
15:26:03 <srhb> ParahSailin: The type, not the name. :-)
15:26:16 <nand`> ‘unsplit’ can be a type :P
15:26:24 <srhb> No, it can't.
15:26:27 <ParahSailin> i have no idea what im doing
15:26:30 <nand`> :t undefined :: unsplit
15:26:31 <lambdabot> forall unsplit. unsplit
15:26:49 <HairyDude> huh. I had a binding like foo = if bar then FormFailure [] else FormSuccess Nothing, with no type signature. It defaulted to FormResult (Maybe Integer). So I slapped on {-# LANGUAGE NoMonomorphismRestriction #-} and... it defaulted again
15:27:02 <srhb> nand`: Since when are types allowed with a minor starting letter. :(
15:27:15 <nand`> since always? it's just a variable
15:27:27 <nand`> :t undefined
15:27:28 <lambdabot> forall a. a
15:28:00 <HairyDude> so it seems you still get some defaulting even with NoMonomorphismRestriction
15:28:00 <srhb> Fine, okay, though it's still not a type. :P
15:28:13 <ParahSailin> :t arr
15:28:14 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
15:29:26 <srhb> @hoogle [a] -> [a] -> [a]
15:29:27 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
15:29:27 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
15:29:27 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
15:29:36 <srhb> ParahSailin: That kind of thing was what I meant.
15:33:04 <ParahSailin> @hoogle a b -> (b, b)
15:33:05 <lambdabot> Data.Complex polar :: RealFloat a => Complex a -> (a, a)
15:33:05 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
15:33:05 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
15:33:29 <ParahSailin> @hoogle Arrow
15:33:29 <lambdabot> Control.Arrow class Category a => Arrow a
15:33:29 <lambdabot> Control.Arrow class Arrow a => ArrowApply a
15:33:29 <lambdabot> Control.Arrow class Arrow a => ArrowChoice a
15:38:57 <augur> ski: interesting
15:39:05 <quintessence> Does this error make sense to anyone: "The first argument of `IO' should have kind `*', but `()' has kind `()'"
15:40:08 <srhb> quintessence: Well no, because it's not true..
15:40:16 <srhb> (I think)
15:40:35 <nand`> @kind ()
15:40:36 <lambdabot> *
15:41:24 <c_wraith> quintessence: that only makes sense if you are doing DataKinds stuff...
15:41:33 <nand`> wouldn't it be '() then?
15:41:36 <nand`> or something like that
15:41:40 <c_wraith> it should be, yes
15:41:57 <c_wraith> But that's the only way for () to even be a kind
15:42:09 <c_wraith> and the leading ' is sometimes optional
15:42:14 <augur> the lambda-mu calculus is just ND for classical logic, directly.   mu is the constructor for the inference for DNE, basically, while [_] is the inference for DNI
15:42:36 <quintessence> c_wraith: DataKinds is off, just using RankNTypes and TH
15:42:51 <nand`> maybe paste?
15:43:24 <Anpheus_> If I'm doing a ton of string processing with concatenating strings of various lengths and the like on a bunch of Text data, should I use Strings as the intermediate forms before concatenating? Should I start with a String and convert to Text afterward?
15:43:46 <nand`> isn't concatenation fairly efficient for Text?
15:43:47 <augur> essentially. really its the external versions of those:   mu is   ~a ... \bot ===mu a   and [_] is   ~a ... a ===[_] \bot
15:43:58 <Anpheus_> I think it is, but I'm doing a lot of "prefix `snoc` c"
15:44:02 <Anpheus_> Where I'm concatenating single characters
15:44:15 <nand`> String is horrible for that
15:44:34 <Anpheus_> I figured a snoc list would be ideal (I think that's what it's called? just a reversed list?)
15:45:26 <nand`> oh, Text snoc reallocates the array in the process, making it O(n) (unless fused)
15:45:42 <nand`> maybe you want Seq Char ?
15:46:04 <Anpheus_> That may be, I expect most of the strings to be built up before concatenated to be relatively short
15:46:22 <c_wraith> actually, Text concat is just about ideal
15:46:40 <c_wraith> it takes all the pieces passed in, calculates the output size, and allocates it once
15:46:44 <Anpheus_> I've got a sort of state machine I'm using to process a bunch of text one character a time, and occasionally I hit these branches where I need to buffer the text a bit to see if I need to perform a transformation on it, before concatenating
15:46:49 <c_wraith> so it's just one copy of each piece
15:47:02 <Anpheus_> Ok, so if I keep everything lazy and use Text I should be OK?
15:47:10 <Anpheus_> As long as I don't force anything it should fuse?
15:47:43 <c_wraith> eh.  fusion is nearly irrelevant with lazy text
15:48:03 <c_wraith> since it doesn't reallocate the chunks, just the lazy wrapper
15:48:05 <Anpheus_> I think I'm working with Data.Text here as my input from a conduit
15:48:35 <Anpheus_> I meant that as long as I don't use bang patterns / seq / $! I should be ok using the `snoc` to append characters at a time
15:48:36 <quintessence> -ddump-splices says something is generating "IO GHC.Tuple.()" instead of "IO ()", that could be it
15:49:12 <nand`> I think what c_wraith means is instead of generating a Text by appending small bits at a time, generate a list of bits to append then use concat to do it all in one operation
15:49:33 <Anpheus_> ok
15:49:40 <Anpheus_> so use [Text] as my intermediate data type
15:49:50 <nand`> :t Data.Text.concat
15:49:51 <lambdabot> [Data.Text.Internal.Text] -> Data.Text.Internal.Text
15:49:53 <ku> What is better, Real World Haskell or Learn You...?
15:50:01 <nand`> LYAH is favorable imo
15:50:04 <coppro> ku: The latter is a short introduction to the language
15:50:16 <coppro> The former is a book on using Haskell in practical applications.
15:50:21 <geekosaur> RWH might work better as a intermediate text
15:50:21 <jhance> Anpheus: nand`: c_wraith: Isn't it better to use a Builder instead?
15:50:43 <Anpheus_> Maybe?
15:50:47 <dgpratt> it seems I will have the opportunity to give a talk about Haskell at the next meeting of my local user group...
15:50:54 <Anpheus_> The input data type from the conduit is going to be ByteString
15:51:03 <jhance> ku: Whether or not you read LYAH, you should read the latter half of Real World.
15:51:10 <Anpheus_> which I'm going to be converting to Utf8 Text with Data.Conduit.Text
15:51:22 <dgpratt> ...now I just need to decided what bits of Haskell I will talk about
15:51:32 <Anpheus_> So I'll have these chunks of text that I need to do fold over with my state machine
15:51:45 <ku> jhance, why specifically??
15:51:51 <jhance> Anpheus_: Is your target Text, after appending it all, lazy or strict?
15:51:58 <jhance> ku: It includes topics not touched in LYAH.
15:52:00 <c_wraith> jhance: slightly. honestly, none of these are *too* different unless you are absolutely sure you've found your bottleneck
15:52:04 <Anpheus_> Text *or* ByteString actually
15:52:12 <Anpheus_> So if I use Builder that might make sense
15:53:13 <dgpratt> for most (all?) of the audience, it will probably be the first time they've seen Haskell
15:55:56 <dgpratt> I saw a Haskell presentation given by Mark Lentczner a little while back that I thought was good, but I'm not at all certain that's the direction I want to take
15:58:58 <dgpratt> is anyone aware of another 'Intro to Haskell'-type talk that they thought was good? (I don't intend to plagiarize, mind you...at least not without permission...I only seek inspiration)
15:59:43 <lusche> dgpratt: The one SPJ gave at oscon a few years ago
15:59:53 <lusche> I look for a link
16:00:01 <lusche> *am looking
16:00:03 <bytter> does someone know of a good intuition to grasp co-monads?
16:00:35 <ion> They’re like burritos turned inside out.
16:00:45 <dgpratt> ion: sounds messy
16:00:46 <Anpheus_> So burrito bowls?
16:01:38 <lusche> dgpratt: http://blip.tv/oreilly-open-source-convention/oscon-2007-simon-peyton-jones-a-taste-of-haskell-part-i-329701
16:02:12 <bytter> i mean, the best analogy i've seen out there is this one from the relation to cellular automatas: "whenever you see large datastructures pieced together from lots of small but similar computations there's a good chance that we're dealing with a comonad"
16:02:16 <dgpratt> lusche: I'll check it out, thanks
16:03:00 <bytter> my intuition so far has lead me drawing a parallels between monads and amorphisms, and co-monads and catamorphisms
16:03:31 <bytter> but maybe it's just because the duality of cata/ana, and there's nothing else related
16:03:36 <Anpheus_> Question: Will GHC fuse functions that became adjacent, i.e.: would the lambda: (\x -> (Data.Text.foldl Data.Text.snoc) Data.Text.empty x) result in fused appends or not?
16:03:59 <coppro> Anpheus_: that's for Data.Text to decide
16:04:18 <Anpheus_> Well I'm asking if that's what it decides :P
16:04:37 <jhance> Anpheus_: Its possible to have GHC output what replacements it does, and you can look at the core as well.
16:06:57 <bos> Anpheus_: not in the case you're asking about
16:06:57 <lambdabot> bos: You have 3 new messages. '/msg lambdabot @messages' to read them.
16:09:55 <Catnaroek> @type iterate
16:09:56 <lambdabot> forall a. (a -> a) -> a -> [a]
16:11:27 <Catnaroek> @src product
16:11:27 <lambdabot> product = foldl (*) 1
16:12:34 <ion> dgpratt: http://youtu.be/b9FagOVqxmI
16:13:24 <dgpratt> ion: yes, that was the one I was thinking of, thanks for the link
16:13:45 <Anpheus_> bos: so given that 99% of what my program will be doing is this concatenation of varying lengths of strings (1-512 characters chunks, biased heavily towards "1")
16:13:58 <Anpheus_> bos: I should probably pick the right data type now to make sure my fold isn't crappy
16:14:28 <bos> Anpheus_: use the Builder type, that's what it's for
16:14:41 <Anpheus_> Ok
16:14:56 <Anpheus_> That's cool, ByteString is my intended destination type so that's what I'll do
17:04:45 <nart> hi :)
17:04:58 <nart> is it cloudhaskell dead ?
17:05:56 <nart> *is cloudHaskell dead ?
17:06:02 <ion> Someone made an alternative implementation of it recently IIRC.
17:06:20 <srhb> nart: Not at all, I belive there's a talk on it at the Symposium, but not sure
17:06:22 <nart> ion: mmm, what's the name of it ?
17:06:24 <ion> http://hackage.haskell.org/package/distributed-process
17:06:29 <nart> ion: ty
17:07:17 <ion> Skimming it quickly, its source seems cleaner than Remote’s source.
17:07:41 <nart> ion: yep, exactly what i was thinking
17:08:11 <ski> augur : not sure what you mean by "i guess maybe internal conjunction is an operator over external conjunction maybe?"
17:08:22 <ski> augur : looking at some Curien or Herbelin paper ?
17:16:20 * hackagebot snap 0.9.1 - Snap: A Haskell Web Framework: project starter executable and glue code library (DougBeardsley)
17:31:21 * hackagebot egison 2.3.1 - An Interpreter for the Programming Language Egison (SatoshiEgi)
17:47:27 <ptrf> 43
17:47:38 <ptrf> sorry, wrong window
17:49:42 <ion> 42
17:52:48 <xvilka> hi
17:52:48 <xvilka> in examples for Haskell FFI i've found that for C structs i need use hsc2hs
17:52:48 <xvilka> but how i can do it manually?
17:53:40 <acowley> Write your own Storable instances with hard-coded field offsets
17:54:22 <xvilka> acowley: thx!
18:00:40 <redscare> In learning haskell, I am trying to create a small monitoring utility that updates every second. I've got it working, but it uses 1% cpu all the time. Conky (another monitoring utility, albiet written in C) never shows up as using any CPU. Normally, I'd blame my own code, but i just wrote a main loop like "main = do threadDelay 10^6; main" and it still uses 1% cpu. is there a way to bring this down?
18:01:17 <Clint> really? in my experience conky chews up ram and cpu like crazy
18:01:25 * hackagebot snap 0.9.1.1 - Snap: A Haskell Web Framework: project starter executable and glue code library (DougBeardsley)
18:01:48 <Ralith> in my experience, *top* uses about 1% CPU
18:02:20 <ClaudiusMaximus> possibly some RTS options might stop it gc'ing every time it's idle?
18:02:30 <Ralith> redscare: waking the CPU every second costs resources.
18:02:58 <redscare> so you guys think i can't reasonably bring it down? what bothers me is when I add logic to 'main' besides 'threadDelay', CPU usage doesn't go up appreciably
18:03:14 <redscare> Ralith: but somehow conky does it negligibly. moreso that Haskell :)
18:03:18 <Ralith> yes, that's because the cost is mostly from the wakeup
18:03:29 <Ralith> redscare: I suspect you are misreading your tool, or your tool does not list Conky.
18:03:58 <redscare> Ralith: top? :)
18:04:13 <Ralith> what about it?
18:05:07 <redscare> Ralith: it's the tool. I sort by CPU usage in it. my Main is always using 1% even doing nothing but 'threadDelay'ing for 1 second, conky updating every second and output info is showing up as using 0
18:05:32 <xvilka> radscare: i suspect something wrong in your gui output, not in loop itself
18:05:43 <redscare> xvilka: out to console
18:05:58 <redscare> xvilka: it's actually pretty well controlled, both conky and my Main output to console
18:06:11 <redscare> are there compiler options I can give besides -O3 to maybe optimize this away?
18:06:31 <Ralith> redscare: I don't believe it's possible to write to console every second and register as 0 CPU usage.
18:06:44 <Ralith> perhaps conky forked another process that you are unaware of?
18:06:55 <xvilka> Ralith: well, it depend from CPU power
18:07:31 <xvilka> redscare: try tree view of processes. and maybe powertop
18:07:33 <redscare> Ralith: nope. the only processes using >0% cpu are Xorg, firefox, and my Main. not conky.
18:07:34 <Ralith> xvilka: if he has a CPU more powerful than top's precision, then what's he doing here when he could be out philanthropizing :P
18:08:02 <Ralith> redscare: are you rounding?
18:08:53 <xvilka> redscare: try powertop, it show ms/us stuff
18:11:35 <redscare> xvilka: i just installed powertop, it's not in real time is it?
18:12:25 <xvilka> redscare: it updates periodically - collect data
18:12:54 <xvilka> at least 2.0 version. Dont remember about 1.* versions
18:14:42 <redscare> xvilka: it does
18:15:04 <redscare> xvilka: 3.5 events/second in the conky version. 100 events/second my "monitor"
18:15:11 <redscare> xvilka: I'm really confused as to why
18:17:45 <xvilka> redscare: at least you know the reason of 1% CPU eating
18:19:45 <redscare> look at this code: http://hpaste.org/71796. why are there 100 events/second? why is it going at 5.3 ms/s? when conky is doing things and it's at 1% of that?
18:19:58 <redscare> more importantly, is there any way to bring it down?
18:26:24 <xvilka> redscare: hm. looks like threadDelay have no quarantees not only to call, but even for precise delay.
18:26:54 <redscare> xvilka: so is there a better option? what are these RTS arguments to ghc?
18:27:02 <xvilka> lets try.
18:28:16 <xvilka> redscare: have you already checked xmonad sources? Looks like it have not such big latency
18:28:22 <ku> Why should I use Haskell instead of Erlang? other than static typing.
18:28:51 <hpc> > "Haskell" > "Erlang" -- lambdabot has spoken!
18:28:52 <lambdabot>   True
18:29:40 <JoeyA> > "Haskell" > "Java"
18:29:40 <redscare> xvilka: first of all, thanks for putting up with me. did you mean try RTS options? I'm not sure how to compile with them...
18:29:41 <lambdabot>   False
18:29:42 <JoeyA> wat
18:33:38 <redscare> xvilka: also, it seems like a general problem. just downloaded and ran xmobar, had that doing nothing, also jumped to 100 events/second
18:34:18 <xvilka> redscare: with -rtsopts it looks better, but not as desired
18:35:22 <redscare> xvilka: how do you mean?
18:35:39 <xvilka> redscare: ghc your.hs -rtsopts;./loop;powertop - and i give 1ms/s interrupt
18:36:05 <redscare> xvilka: well that's much better. how does that work?
18:36:05 <xvilka> 46 events/s
18:36:14 <redscare> xvilka: a huge amount better
18:36:59 <geekosaur> -rtsopts by itself shouldn't do anything, actually
18:37:22 <geekosaur> except enable you to add +RTS -V0 options
18:37:39 <xvilka> geekosaur: but it works!
18:37:47 <geekosaur> which should tame the runaway timer (I'm still not clear on whether that qualifies as a bug)
18:38:00 <xvilka> redscare: yes, try add -V<sec> option too
18:38:04 <geekosaur> hm, is $GHCRTS set in the shell?
18:38:36 <xvilka> geekosaur: no, it's empty
18:39:01 <redscare> so do I change the way i run the program or the way i compile?
18:39:01 <geekosaur> iiinteresting.  this smells like a bug in the ghc runtime
18:39:15 <xvilka> redscare: read runtime-control manual. it have a lot of options to control a lot
18:39:41 <redscare> i.e. do I run "ghc --make test.hs -rtsopts +RTS -V0" or "./test +RTS -V0"?
18:39:58 <xvilka> i have 7.4.1 version, lets try update.
18:40:13 <redscare> geekosaur: yeah i'm confused about it. and the System.Posix sleep doesn't work at all, so i have to use threadDelay
18:40:58 <geekosaur> +RTS -V0 applies to the thing yoy are running
18:41:12 <geekosaur> so including it on the ghc command line would apply it to ghc itself
18:41:46 <geekosaur> (there *is* an option to set default RTS options, but -rtsopts isn't it; -rts turns off the "omg security don;t allow any RTS options"
18:42:02 <redscare> +RTS V0 made the thing an insane amount better. is there any disadvantage to just permanently setting +RTS -V0?
18:42:05 <geekosaur> er, -rtsopts does
18:42:36 <geekosaur> multithreaded programs might behave worse, although I think the default is already so bad that maybe not
18:43:03 <xvilka> redscare: it can break things
18:43:14 <redscare> geekosaur: sweet, i'm on one thread. is there a way to compile it into the program permanently through ghc?
18:44:15 <redscare> geekosaur: nvm found the compiler flag
18:44:24 <geekosaur> -with-rtsopts
18:44:52 <geekosaur> apparently I can;t type tonight, you found it yourself while I was editing to remove typoes >.>
18:45:21 <xvilka> redscare: http://haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html
18:48:46 <redscare> so I'm using -V0 -I0 and it's looking pretty good :) not quite as good as the C version but much better
18:49:58 <xvilka> redscare: i think there is more ways to improve it. But i dont know them
18:50:20 <xvilka> just use your google-fu
18:53:18 <redscare> xvilka: I've been trying :) Should I look anywhere besides additional RTS options?
18:58:29 <xvilka> redscare: i dont know, never done such optimization. I'm Haskell newbie. :)
19:01:26 <hpaste> NovaDenizen pasted “NovaDenizens Polymorphism issue” at http://hpaste.org/71800
19:01:48 <redscare> well with RTSOPTS -V0 and -I0 i get basically 0% CPU. any haskell masters that can tell me that I should never be using these options ever? :)
19:01:50 <ku> I have to say that the more I learn about Haskell, the more I hate its "purity"
19:01:52 <NovaDenizen> Could somebody look at my paste and explain the polymorphism error to me like I'm five?
19:02:37 <otters> yeah you can't have a class constraint *inside* a data declaration
19:02:39 <otters> IIRC
19:02:46 <otters> not without compiler extension
19:03:17 <Axman6> ku: learning the importance of purity is vital to learning the power of haskell. it is a pain when you're starting out, but it becomes natural, and eventually you will start to hate reading code that doesn't make the distinction
19:04:01 <ku> Axman6, I guess it probably also has to do with never using a completely functional language. I usually use Python, which is multi-paradigm
19:04:25 <otters> NovaDenizen, you see what I said?
19:06:01 <NovaDenizen> Yeah, but I had already gotten that far.
19:06:32 <otters> oh okay
19:06:33 <NovaDenizen> It still doesn't make sense to me that I have to pick a particular RandomGen-implementing type.
19:07:02 <NovaDenizen> And I'd really rather not put the g as a type parameter for the Species record.
19:07:10 <otters> Well, you could use RankNTypes
19:07:28 <otters> But that field can't be polymorphic unless it's a type parameter
19:07:32 <NovaDenizen> Maybe I'll have to settle for that.
19:07:38 <otters> err, *type can't be polymorphic
19:07:54 <otters> yeah, needing to enable compiler extensions always feels a little weird to me
19:08:54 <NovaDenizen> The idea is that Species embodies all the nitty-gritty of a genetic algorithm type, whereas I can put all the stuff regarding judgement and managing generations, parallellism, and algorithms spearately.
19:09:12 <NovaDenizen> It doesn't make sense that I have to choose a particular RandomGen.
19:09:35 <NovaDenizen> Especially since it seems like nothing depends directly on the type.
19:10:52 <xvilka> ku: after starting learning haskell, i'm even trying to use pure functions in C, quite useful to make flexible and easy for refactoring program
19:12:55 <NovaDenizen> Oh well.  I guess I'll just add Rank2Types and chalk it up as another flaw in the Haskell Class system.
19:13:21 <NovaDenizen> One of these days I'm going to create a world-conquering FP language with dependent types that will wipe everything else off the map.
19:13:25 <NovaDenizen> Until then...
19:13:45 <otters> just because it's not default behavior doesn't mean it's broken
19:14:19 <BMeph> NovaDenizen: Until then, you might want to look at the multitude of dependently-typed languages already out there. Just sayin'... ;)
19:16:36 <NovaDenizen> Haskell's 100% great until you get to the typeclasses; they're only about 70% great.
19:17:16 <NovaDenizen> The whole newtype-wrapper-requirement to get a sum or product Monoid thing rubs me the wrong way.
19:18:04 <NovaDenizen> There ought to be a better way to make multiple instances of a typeclass for a particular type, like a Monoid (Int, (+), 0) and a Monoid (Int, (*), 1).
19:21:34 <redscare> ok new problem. I have this code: http://hpaste.org/71801. If I write to console, "Test" gets put to the screen every second
19:21:43 <redscare> but if I try to pipe to a program, nothing shows up
19:22:41 <otters> pipe to what?
19:22:53 <\rs> have you guys ever thought of a recursive acronym for Haskell?
19:22:54 <redscare> otters: anything. grep, dzen2
19:23:05 <otters> redscare: maybe it's buffered :O
19:23:16 <redscare> how would I make it not do that? :)
19:23:39 <otters> @hoogle hFlush
19:23:39 <lambdabot> System.IO hFlush :: Handle -> IO ()
19:23:39 <lambdabot> GHC.IO.Handle hFlush :: Handle -> IO ()
19:23:39 <lambdabot> GHC.IO.Handle hFlushAll :: Handle -> IO ()
19:23:44 <redscare> otters: on the other hand, how would haskell "know" that it's being piped as opposed to output to the CLI?
19:23:48 <otters> take a look at that
19:23:50 <NovaDenizen> [22:10] <xvilka> ku: after starting learning haskell, i'm even trying to use pure functions in C, quite useful to make flexible and easy for refactoring program
19:23:50 <NovaDenizen> [22:11] *** shapr quit (Ping timeout: 244 seconds)
19:23:51 <\rs> like lots of irritating superfluous parenthesis
19:24:02 <\rs> s/sis/ses/
19:24:04 <NovaDenizen> hFlush stdout
19:24:10 <otters> XAI: XAI Ain't Impure
19:24:10 <NovaDenizen> I'm so slow.
19:24:15 <otters> or XAI Ain't Imperative
19:24:55 <NovaDenizen> It's standard behavior in the runtime to check if output is to a console or to a file/pipe.
19:25:01 <NovaDenizen> If it's not a console, it gets buffered.
19:25:28 <redscare> NovaDenizen: is hFlush the most efficient way of doing this then? or can I 'trick' it into thinking it's to console?
19:25:43 <otters> hFlush is the most efficient way
19:26:04 <NovaDenizen> hFlush just empties the buffer when you call it.  You'd need to call it many times.
19:26:12 <glguy> redscare:  hIsTerminalDevice
19:26:20 <otters> disregard me
19:26:22 <otters> please
19:27:33 <NovaDenizen> @hoogle hSetBuffering
19:27:33 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
19:27:33 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
19:27:50 <otters> hSetBuffering NoBuffering is slow, though
19:27:59 <NovaDenizen> hSetBuffering stdout LineBuffering
19:28:29 <NovaDenizen> I would thing LineBuffering is the same speed as flushing after every line.
19:28:31 <augur> ski: i dont know what i meant. :)
19:28:36 <NovaDenizen> s/thing/think
19:28:41 <augur> i need to read some more of this categorical logic stuff
19:30:10 <NovaDenizen> Setting stdout to LineBuffering is basically 'tricking' the runtime into thinking it's a console, like you wanted.
19:30:44 <NovaDenizen> But it's kind of silly to think about it in terms of efficiency since it takes a lot of activity to move the output over to another process.
19:31:17 <Seo007> Is your website on page 1 of Google? http://bit.ly/LYh99L
19:31:18 <redscare> NovaDenizen: thanks, I understand
19:44:06 <clara> hello
20:15:36 <NovaDenizen> @hoogle getcontents
20:15:37 <lambdabot> Prelude getContents :: IO String
20:15:37 <lambdabot> System.IO getContents :: IO String
20:15:37 <lambdabot> Data.ByteString.Lazy getContents :: IO ByteString
20:16:52 <NovaDenizen> @hoogle writecontents
20:16:53 <lambdabot> No results found
20:16:56 <NovaDenizen> @hoogle writefile
20:16:56 <lambdabot> Prelude writeFile :: FilePath -> String -> IO ()
20:16:56 <lambdabot> System.IO writeFile :: FilePath -> String -> IO ()
20:16:56 <lambdabot> Data.ByteString writeFile :: FilePath -> ByteString -> IO ()
20:24:29 <augur> ski: interesting. im reading about lambda-mu right, and the [_] addresses are quite interesting
20:25:55 <augur> ski: they seem to represent places where what we've done is cut out a part of the proof tree, sort of taken a proof of the shape   ...D... P ...E... \bot   and cut out the E in the middle
20:26:20 <augur> ...D... P ...E... \bot   ===>   ...D... P ===[a : ~P] \bot
20:26:51 <augur> which suggests to me that we should use fancier lines for these kinds of rules, i think a zig-zag line, to indicate that its sort of a cutting of the tree
20:27:37 <augur> in a sense, [a] is as if we have an actual proof rule corresponding to the metanotation ...a...
20:30:40 <otters> "metanotation"
20:30:44 <otters> surely there's a channel for this
20:32:19 <augur> otters: yes, its ##logic, but its also #haskell because its intimately related to computation :P
20:38:41 <augur> i can see very clearly how this relates to (delimited?) continuations
20:38:45 <augur> its quite interesting
20:38:52 <kallisti> any idea why port cabal-install uses?
20:38:54 <kallisti> *what
20:41:12 <Clint> port?
20:41:38 <thoughtpolice> kallisti: it just downloads packages via HTTP and installs them locally
20:41:43 <m3ga> kallisti: cabal install uses HTTP as a transport
20:44:57 <ion> And as an answer to the question, probably 80.
20:45:50 <kallisti> would it be feasible to run cabal-install through a proxy?
20:45:59 <kallisti> SOCKS proxy in particular
20:46:02 <kallisti> but I could set up HTTP as well
20:48:36 <Axman6> @hoogle showHex
20:48:36 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
21:14:33 <savask> Hello. I'm trying to build my program with profiling, but when I try to compile it with -prof, it says that I have no profiling libraries for base package. Then I do: "cabal install base --enable-library-profiling --reinstall" But it couldn't resolve dependences, and failed. How can I fix that?
21:16:46 <jfischoff> savask: you are going to need to install the profiling libraries
21:16:52 <jfischoff> so what is the error?
21:17:36 <savask> jfischoff: http://pastebin.com/avza0YXG
21:17:41 <mauke> The paste avza0YXG has been copied to http://hpaste.org/71805
21:18:40 <jfischoff> savask: hpaste your cabal file
21:18:55 <savask> jfischoff: My cabal file?
21:19:17 <savask> It's an error from "cabal install base --enable-library-profiling --reinstall"
21:19:27 <savask> My prog has no cabal file.
21:19:34 <jfischoff> savask: oh whoops
21:20:11 <jfischoff> what base do you have
21:20:32 <savask> 4.5.0.0
21:21:04 <jfischoff> savask: try explicitly reinstalling that
21:21:33 <savask> jfischoff: Explicitly? How is that o_O
21:21:52 * jfischoff is surprised base doesn't have profiling built in
21:22:24 <jfischoff> savask: `cabal install base-4.5.0.0 --enable-library-profiling --reinstall"
21:22:42 <savask> Ah, I tried that.
21:23:05 <hpaste> savask pasted “New cabal error” at http://hpaste.org/71806
21:23:25 <savask> jfischoff: That's the thing it says now.
21:23:37 <jfischoff> maybe you can't reinstall base
21:23:51 <jfischoff> it comes with the compiler
21:24:28 <savask> But how can I install profiling libs then?
21:25:00 <jfischoff> that's what is confusing me :(
21:26:24 <u_> so um
21:26:29 <u_> cabal is taking up 100% cpu
21:26:34 <u_> and i can't kill it
21:26:38 <otters> kill it
21:26:40 * u_ tried
21:26:46 <otters> unless you're not an admin
21:26:48 <otters> in which case
21:26:50 <tgeeky_> sudo killall -9 cabal
21:26:55 <u_> that's exactly what i did
21:26:57 <tgeeky_> you should be running as you anyway
21:27:07 <tgeeky_> u_ got problems!
21:27:19 <u_> :P
21:27:23 <u_> haskell virus?
21:28:29 <otters> yeah
21:29:03 <savask> jfischoff: Thanks for help, but I just installed profiling libraries from ubuntu repo and it worked :-)
21:30:05 <u_> how could killing it not work?
21:38:19 <jfischoff> savask: nice!
21:40:05 <savask> Yeah. Though manually installing all these libraries is boring -_- If I will turn on installing profiling libraries in cabal config, will it install profiling for all dependences?
21:49:04 <nightofday> Enter text here...hi
21:49:09 <nightofday> hi
21:49:10 <nightofday> hi
21:49:11 <nightofday> hi
21:53:06 <KirinDave> So. I don't drop horrible posts in here often
21:53:10 <KirinDave> But this is an exception.
21:53:11 <KirinDave> http://robots.thoughtbot.com/post/27572137956/tell-dont-ask
21:53:44 <KirinDave> Isn't OO wonderful? How we can tightly couple presentation and data? How we can decrease composability and call it progress?
21:54:17 * tgeeky_ aims his Intercontinental Basllistic Pitchfork toward KirinDave 
21:54:30 <KirinDave> tgeeky_: You can hurt me, but that won't make the pain stop.
21:54:44 <tgeeky_> KirinDave: it's a *really* big pitchfork
21:55:17 <nightofday> is anybody in here knows about VB 6
21:55:19 <nightofday> ?
21:56:59 <nightofday> ?
21:57:00 <nightofday> ?
22:05:17 <pharaun> :|
22:05:45 <u_> restarting cleared it up
22:05:48 <u_> still a bit spooky
22:05:59 <u_> all the explanations i read for why processes can be immune to killing
22:06:04 <u_> didn't seem to apply to something like cabal
22:07:41 <Ralith> it can happen if it's blocked in a particular kind of IO state, I think
22:07:45 <Ralith> but that would preclude eating CPU
22:08:15 <u_> yeah the CPU eating wasn't constant either, it kept switching from one core to another and stuff
22:09:04 <u_> if you took the graphs for each core it looked like you could jam them together like a lock and key
22:10:17 <pharaun> if its a D iirc
22:10:25 <pharaun> that means its i/o block, its not going to eat up the cpu
22:11:40 * hackagebot sbv 2.3 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving. (LeventErkok)
22:27:34 <savask> Eh, while compiling with profiling, I got another error: "/usr/bin/ld: cannot find -lHSlargeword-1.0.1_p" Googling doesn't show anything about that flag.
22:27:45 <savask> What does it even mean?
22:29:45 <Ralith> savask: it means something was trying to link with a library named HSlargeword-1.0.1_p
22:29:56 <Ralith> but that library wasn't in the search paths
22:30:00 <savask> Oh
22:30:45 <savask> Hmm, hoogle doesn't show anything either.
22:33:47 <Ralith> it is likely that that precise version number and profiling flag is not a common string
22:34:07 <savask> Ralith: What can I do?
22:34:23 <liyang> cabal install --enable-library-profiling --reinstall largeword
22:34:40 <Ralith> ^
22:34:44 <liyang> Perhaps.
22:35:00 <savask> Doesn't help.
22:35:07 <liyang> I would guess largeword wasn't installed with profiling enabled.
22:35:30 <Ralith> cabal should be able to catch that in a well-functioning install, though
22:35:45 <Ralith> the fact that it gets all the way to the linker suggests something is screwed up
22:36:25 <savask> That's bad news for me.
22:36:53 <Ralith> wait, you're compiling this by hand, right?
22:37:00 <Ralith> try writing a cabal file instead
22:37:12 <savask> Do you think it will help?
22:37:16 <Ralith> yes.
22:37:27 <savask> I've already installed all libraries and profiling libraries.
22:37:50 <savask> Also, I'm afraid I won't be able to list all dependences right.
22:37:58 <Ralith> but it would not surprise me if they weren't in your default search paths
22:38:02 <Ralith> cabal will tell you if you miss a dep :P
22:38:14 <savask> Ah, okay.
22:38:46 <savask> Maybe that is because I use hmatrix?
22:38:54 <savask> It uses C libraries, as I remember.
22:41:00 <Ralith> unless largeword is intimately related to hmatrix, that seems unlikely
22:49:23 <kallisti_> how do you end a character escape sequence??
22:50:12 <sabren> you can never escape
22:50:25 <sabren> it never ends
22:50:59 <sabren> or it ends on its own i guess
22:55:40 <mauke> \&
23:04:26 <augur> ski: omg
23:04:43 <augur> ski: i tryied to find a nice representation for the sequent calculus in place of proof trees
23:04:52 <augur> ski: so i figured, lets try proof graphs
23:05:11 <augur> ski: at some point it became convenient to make propositions into the edges, and inference rules into the nodes
23:05:16 <augur> ski: and out popped string diagrams
23:06:07 <augur> this is definitely getting written up somewhere :D
23:11:02 <savask> Ralith: Well, now I have a .cabal file. I've added -prof to Ghc-options in it, and I get the same error.
23:12:19 <Ralith> savask: I strongly suspect that's the wrong way to tell cabal to use profiling.
23:12:32 <savask> What is the right way then?
23:12:46 <Ralith> the idea having been that you'd use the .cabal file to inform cabal of your intent to profile, and then cabal would swap out lib search paths as needed.
23:12:49 <Ralith> I don't know.
23:12:56 <Ralith> I've never needed to profile something!
23:13:01 <savask> Oh
23:13:18 <savask> At least I have .cabal file. Yay.
23:14:55 <Ralith> I am sure someone in here has done it before.
23:15:31 <savask> Yeah, but by some reasons they can't help right now :-P
23:15:59 <savask> Ralith: Btw, do I need to make Setup.sh even for executables?
23:16:19 <savask> Eh, Setup.hs
23:16:46 * Ralith examines his last project
23:16:48 <Ralith> apparently not!
23:16:57 <savask> Oh, nice.
23:30:29 <savask> Ralith: Thanks for help, I've managed to fix that error by installing older version of package longword
23:33:02 <Ralith> huh.
23:33:13 <Ralith> that works, I guess!
23:44:40 <Ralith> Can anyone recommend a good library for writing PNGs?
23:47:16 <AfC> Who is maintaining ByteString these days? I'd like to report a bug but the homepage listed on hackage is 404
23:49:49 <kfish> AfC, dons' email should still work though
23:50:17 <dmwit> :t (^)
23:50:18 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
23:51:09 <kfish> AfC, it may actually be being maintained as part of ghc or platform though, the upload was by Igloo ...
23:51:32 <AfC> kfish: so I should file a GHC trac ticket?
23:52:09 <kfish> AfC, nfi
23:52:15 <kfish> what's the bug anyway?
23:55:00 <dmwit> Ralith: cairo, gd, JuicyPixels, DevIL-repa
23:58:26 <AfC> kfish: documention bug — they've deprecated something and its not mentioned in the haddock but -Wall -Werror noticed I was calling something I shouldn't be
