00:14:51 <solrize> EvanR, hmm, i thought it had something like that, at least back in the past
00:20:49 <Lemmih> copumpkin: I am now.
00:22:05 <copumpkin> Lemmih: I was just wondering how usable your berkeley db package was. And is there not a way to persist state across runs?
01:15:02 <Lemmih> copumpkin: Hm, I can't remember. I think I wanted to use it with AcidState.
01:21:08 <startling> hi, do people here use QuickCheck? I'd like to have a newtype of String that's an instance of Arbitrary such that repeatedly chooses from a set of chars and concatenates the results
01:21:49 <startling> I don't even know where to get started, though -- I'm thinking it'll use variant and replicateM but I'm having trouble finding a clear explanation of how Arbitrary works
01:22:02 <startling> as well as QuickCheck's random-ish functions
01:22:40 <Cale> startling: Well, there's a monad called Gen for random generators
01:23:02 <startling> Cale: heh, I gathered as much from :t
01:23:04 <Cale> the Arbitrary class gives the canonical generator that QuickCheck will use for any given type
01:23:17 <Cale> which is called arbitrary
01:23:21 <startling> right
01:24:22 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck-Gen.html has a bunch of useful functions for creating Gen values
01:25:46 <Cale> You might just want  listOf (elements myListOfChars)
01:26:51 <Cale> The other method of Arbitrary is called shrink, and it is used by quickCheck to try to shrink counterexamples to properties, once one is found that fails
01:27:19 <Cale> Basically, quickCheck will apply shrink to the failing example, and see if any of the shrinks still fail the property, and if so, it'll try shrinking them more
01:28:05 <roconnor_> is ML's module system like Haskell's type classes but without the dictionary inference?
01:29:21 <Cale> roconnor_: Comparisons have been made. It's also not really type-dependent.
01:29:41 <Cale> roconnor_: But you can have modules which are functions of other modules, essentially
01:29:47 <startling> Cale: very cool. I think I understand better now. thanks!
01:30:01 <roconnor_> ML's modules are not type dependent?
01:30:39 <Cale> roconnor_: I mean it doesn't pick modules based on the types of things
01:30:45 <startling> so is making a newtype of an already-made type for making an instance of Arbitrary a good idea?
01:30:51 <Cale> You have to tell it which module you want, iiuc.
01:30:57 <roconnor_> Cale: ah.  That's what I meant by "without the dictionary inference"
01:31:15 <Cale> startling: yes, and there are a bunch of them already like that:
01:31:15 <Taneb> Can someone explain what all the fuss about first-class modules is?
01:31:18 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck-Modifiers.html
01:31:28 <startling> Cale: awesome, thanks
01:31:40 <roconnor_> I figured ML functors are very vaguely like class instances.  very vaguely.
01:32:24 <startling> are ML functors modules with parameters? I think that's what I heard
01:32:35 <srhb> Kind of.
01:33:22 * roconnor_ has been slowly trying to put together his understanding about how modules / type-classes / dependent records / typeing contexts are or are not the same thing.
01:33:25 <startling> ah. and they're used for polymorphism kind of?
01:33:32 <Cale> Taneb: There are a lot of libraries right now which import either Data.ByteString or Data.ByteString.Lazy, and even though they might work with either imported, they have to choose one. (Many libraries will provide lazy and strict modules themselves in a similar way)
01:33:58 <Cale> Taneb: Imagine if you could pass the ByteString library to use as a parameter to your parser's module, say.
01:34:14 <Taneb> Oh, that would be usefuk
01:34:17 <Taneb> *useful
01:34:46 <Taneb> Yeah, I could do with that for family-tree, I think
01:35:38 <Cale> Of course, another option is to make a typeclass which specifies exactly what's in the ByteString module and then write code which is polymorphic over that class, and that's the sense in which they're "equivalent"
01:36:05 <roconnor_> startling: my understanding is taht everything we prefixx with (Foo t) => in haskell has to be gather together in a module (or several modules) in ML.
01:36:06 <Cale> But the sort of stuff which each makes natural is different.
01:36:40 <Cale> For instance, the MLs don't have an equivalent of Eq
01:37:02 <Cale> because it'd be awkward to be importing different modules for different implementations of (==)
01:38:43 <Cale> and in Haskell, we don't turn ByteString's whole interface into a typeclass either, though that might not be a terrible idea, people generally don't like to define typeclasses with more than a handful of methods.
01:39:36 <AfC> Cale: I really liked Gabrielle's dictionary based approach to Strings that turned up the other day in the crazy-prelude discussion
01:40:24 <AfC> s/Gabrielle/Gabriel/ eek
01:41:52 <startling> roconnor_: weird
01:42:16 <roconnor_> well, I'm not an ML programmer so don't trust me too much
01:42:28 <startling> heh
01:43:26 <startling> is there a thing somewhere in QuickCheck that'll print me a random whatever so I can make sure my Arbitrary definition is sane?
01:44:12 <startling> ah, sample
01:44:18 <Cale> Much of what we'd do with typeclasses in Haskell would turn into explicit passing of dictionaries in ML
01:45:55 <Cale> startling: and while we're here, coarbitrary is for making it possible for QuickCheck to generate functions. In order to generate random functions of type A -> B, QuickCheck needs an instance of Arbitrary for B and an instance of CoArbitrary for A.
01:46:42 <startling> yeah, understood
01:46:52 <startling> (because not all functions are bijections etc etc)
01:47:10 <Cale> startling: If you look in the code, you can see how the instances for that usually go. A lot of it is calls to variant and ><
01:48:27 <startling> while I'm here, is there a way to do something like [1..5, 9..12]?
01:48:37 <Cale> [1..5] ++ [9..12]
01:48:38 <Botje> [1..5] ++ [9..12]
01:48:39 <startling> I guess [1..5] ++ [9..12] works
01:48:48 <startling> but it seems like that'd be inefficient?
01:48:55 <Botje> why?
01:49:24 <Cale> If you're worried about the one time constant cost of (++), you could always just write it out :P
01:49:40 <Cale> But I don't know, GHC might even constant fold that.
01:50:18 <startling> yeah, I guess I'm being dumb about it
01:50:43 <Cale> nope, it doesn't, but still, it's a pretty cheap operation
01:51:03 <startling> yeah
01:51:10 <Cale> (++) is only really bad when you do it repeatedly with long left arguments
01:51:53 <srhb> Cale: Assuming you only read the list left-to-right, that doesn't really have anything to do with (++) does it?
01:52:28 <srhb> Cale: I mean, the cost only occurs if we request the element after the last element of the first list, and even then the cost only happens in that step, and is constant regardless of the length of the first list?
01:52:50 * srhb does not understand how long left arguments are an issue
01:53:33 <hiptobecubic> I want to represent some Boops. Some Boops can foo and others cannot. If I make Boop an ADT, then for the Boops which can't foo I'll have to handle the problem at runtime, right?
01:54:02 <Cale> srhb: xs ++ ys takes O(length xs) steps to reduce
01:54:12 <Cale> srhb: so if you write something like
01:54:16 <Cale> reverse [] = []
01:54:19 <hiptobecubic> If i make each Boop it's own type and make a class "Fooable", then a function can't take a generic Boop anymore because they are not longer interchangeable
01:54:25 <Cale> reverse (x:xs) = reverse xs ++ [x]
01:54:31 <hiptobecubic> its*
01:54:43 <Cale> then you end up with a quadratic time algorithm for reverse
01:55:00 <Cale> however, there's a nice general solution in cases like this
01:55:25 <Cale> basically, replace lists with functions that add elements to the beginning of some arbitrary list
01:55:35 <Cale> (++) becomes (.)
01:55:39 <Cale> [] becomes id
01:55:47 <Cale> [x] becomes (x:)
01:56:14 <Cale> and then just applying the resulting function to [] at the end will produce a normal list again
01:56:34 <Cale> the reason this is an improvement is that (.) always takes O(1) steps to reduce
01:56:48 <Cale> So if we do it to that reverse:
01:56:52 <Cale> reverse' [] = id
01:57:02 <Cale> reverse' (x:xs) = reverse' xs . (x:)
01:57:13 <Cale> reverse xs = reverse' xs []
01:57:19 <Cale> this is now linear time
01:57:52 <timthelion> hiptobecubic: why not just have a data Boop = Fooable | Notfooable
01:58:33 <hiptobecubic> timthelion, how does that solve the issue?
01:58:41 <triyo> I upgraded to the latest Haskell Platform release. Now I have all sorts of problems. 1st one: "Could not find module `Char' It is a member of the hidden package `haskell98-2.0.0.1'.". Anyone know what replaced I use now for the Char module?
01:59:07 <timthelion> hiptobecubic: then a function can pattern match against it
02:00:08 <Cale> srhb: did all that make sense?
02:00:23 <startling> Cale, that's a pretty cool explanation
02:00:24 <timthelion> omg, how many Simons are there in this community???!
02:00:24 <hiptobecubic> timthelion, so put the information about whether or not the Boop is Fooable as a member of the Boop datatype itself?
02:00:32 <startling> haskell is so goddamn elegant
02:00:40 <timthelion> hiptobecubic: of course
02:00:55 <srhb> Cale: I think so, though I wasn't convinced of the original reverse being anything but linear.
02:01:16 <Cale> srhb: okay, let's look at the implementation of (++)
02:01:22 <Botje> triyo: Data.Char probably.
02:01:23 <Cale> [] ++ ys = ys
02:01:30 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
02:01:44 <hiptobecubic> srhb, nÂ² / 2 i think, because it re-traverses the growing list each step.
02:02:06 <timthelion> hiptobecubic: though it needent be top level ... data Foo = Fooable | NotFooable ; data Boop = Boop ... ... Foo
02:02:06 <Cale> yeah, more or less
02:02:30 <hiptobecubic> first time is 1 step, next time is 2 steps... up to n
02:02:44 <Cale> reverse [1..100] -> reverse [2..100] ++ [1]
02:02:59 <triyo> Botje: thanks, I see how some modules have been move to be in more appropriate places.
02:03:07 <triyo> *moved
02:03:10 <Cale> -> (reverse [3..100] ++ [2]) ++ [1]
02:03:16 <Cale> -> ...
02:03:41 <hiptobecubic> timthelion, but now to add another property, all functions using the type must be changed it seems
02:03:52 <triyo> And a final one for now. "Could not deduce (Monad (Either String))"...Possible fix: add (Monad (Either String))
02:03:53 <Cale> -> (<some list with 98 elements> ++ [2]) ++ [1]
02:03:55 <timthelion> Cale: haskel has a really remarkably efficient ++ compaired to most languages :)
02:04:53 <Cale> -> <some list with 99 elements> ++ [1]
02:05:26 <hiptobecubic> triyo, Control.Monad.Instances
02:05:27 <timthelion> hiptobecubic: you can always ignore things by using feild selectors..
02:05:35 <triyo> Has the (Either s) instance of monad been removed?
02:05:59 <srhb> Cale: Looks linear to me? <_<
02:06:02 <Cale> triyo: It was never in the Prelude afaik. There's one in Control.Monad.Error
02:06:04 <triyo> Switching from 7.0.4 to latest broke, hence I ask
02:06:25 <hiptobecubic> srhb, [1] ++ [2] ++ [3] -> ([1] ++ [2]) ++ [3], yes?
02:06:33 <Cale> srhb: Think about the fact that each (xs ++ [x]) will take O(length xs) time
02:06:34 <hiptobecubic> so first we stick 1 and 2 together, no big deal
02:06:48 <triyo> Cale: it seems to have been as I don't have an import
02:06:49 <srhb> Oh, yeah, okay.
02:06:52 <srhb> I see it.
02:06:53 <hiptobecubic> srhb, then to stick 3 on the end, we first have to start at 1, walk to 2, and then stick on 3
02:07:17 <srhb> Why don't we just stick an accumulating parameter on reverse and cons instead then?
02:07:24 <Cale> That's what we do
02:07:26 <srhb> oh.
02:07:28 <hiptobecubic> :)
02:08:04 <Cale> But I like to express that a little differently because it actually is more general the way I expressed it
02:08:11 <srhb> Right
02:09:47 <hiptobecubic> timthelion, but we are still dealing with errors at runtime then, because that's when the pattern match will fail
02:10:32 <yitz> triyo: Data.Char
02:11:13 <Cale> You can imagine cases where you're working with lists that need concatenating and they're in some other datastructure or there's some other obstruction to just adding an accumulating parameter. You can still replace those lists of type [a] with functions [a] -> [a] and do the same trick.
02:12:44 <yitz> triyo: ah someone answered already. sorry.
02:12:55 <triyo> thanks, no worries
02:17:25 <timthelion> hiptobecubic: If it compiles with -Wall there will be no pattern match errors
02:17:56 <hiptobecubic> What is the syntax for pattern matching using field selectors?
02:18:53 <dmwit> Constructor { field = pattern }
02:19:40 <hiptobecubic> then we bind pattern only, correct?
02:20:08 <dmwit> There's no other place where names can go, so... yes.
02:25:35 <hiptobecubic> timthelion, -Wall will just tell you it's a partial function. The problem is the some boops are fundamentally NotFooable and passing them to functions which expect Fooables should be impossible entirely.
02:26:53 <timthelion> hiptobecubic: are you using an FFI?
02:27:13 <hiptobecubic> no
02:27:40 <timthelion> then what is the essence of Foo-ability?
02:28:12 <hiptobecubic> heh, what do you mean? It's the property of being able to foo :D
02:28:26 <hiptobecubic> For example, say you want to represent people
02:28:42 <hiptobecubic> You can have a type Man and Woman
02:28:52 <hiptobecubic> or a type Person = Man | Woman, or whatever
02:29:32 <hiptobecubic> But if you want to operate on these, some operations, like "castrate" are fundamentally impossible on Woman types
02:29:47 <dottedmag> I am trying to read appendix A of "How to make ad-hoc polymorphism less ad hoc" by Wadler & Blott, but the notation is unknown for me. I tried to read papers from the references, but can't find the one which describes pre-requisites for this paper.
02:31:09 <dottedmag> Where I can find the prerequsite info to understand the notation for inference rules and the general idea of the type system from appendix?
02:32:30 <hiptobecubic> So I think Man and Woman are actually *not* the same type, they are just instances of Person. Man will additionally be an instance of Castratable, but Woman will not. Then you require the argument of castrate to be a Castratable. Is this reasonable?
02:33:18 <NoICE> hiptobecubic: this can be solved using constructors, right? like castrateable (Woman _) = false ..
02:34:49 <pshr> Hi, I am trying to get started with yesod and haskell, How do I run shell commands like 'dir' etc
02:35:22 <shachaf> Based on that question, the answer is most likely "you shouldn't". :-(
02:35:38 <maurer> pshr: http://hackage.haskell.org/packages/archive/directory/latest/doc/html/System-Directory.html#v:getDirectoryContents
02:35:41 <maurer> Try that instead
02:35:55 <maurer> pshr: Breaking out to shell should be kind of a last resort.
02:35:58 <timthelion> hiptobecubic: I just lost all my internets,, what was my last message?
02:36:16 <hiptobecubic> NoICE, but there is no sensible return value from there and the program can't go on at all.
02:36:18 <maurer> (you can do it, I'm just agreeing with shachaf that it's not the right solution to your problem)
02:36:22 <maurer> (most likely)
02:36:43 <hiptobecubic> timthelion, what was the last thing you got?
02:36:55 <NoICE> hiptobecubic: I understand.
02:37:57 <NoICE> hiptobecubic: having that verified by the type system is a good thing. I would go for instances.
02:38:02 <pshr> maurer: thanks for the link but is there a way to run general purpose commands not only dir ?
02:38:09 <hiptobecubic> timthelion, <hiptobecubic> So I think Man and Woman are actually *not* the same type, they are just instances of Person. Man will additionally be an instance of Castratable, but Woman will not. Then you require the argument of castrate to be a Castratable. Is this reasonable?
02:38:14 <hiptobecubic> timthelion, that's enough to figure out what i was saying
02:38:35 <timthelion> hiptobecubic: you can make a type, data Fooable = Fooable Boop, and a function, fooAble :: Boop -> Maybe (Fooable) and make functions requireing fooability take a fooable and not a Boop at all
02:38:40 <timthelion> hiptobecubic: or you can do data Man...  data Woman ...  data Person = Male Man | Female Woman, and then make the castrate function take a Man and not  a Person
02:38:43 <shachaf> pshr: Yes, but you probably shouldn't. What do you want to do?
02:39:12 <timthelion> those where my last messages
02:39:49 <hiptobecubic> timthelion, didn't get those.
02:39:53 <pshr> shintah: I have an internal project I would want to develop a web interface to invoke vmcommands with "vmrun" to start and stop the Virtual machines
02:40:04 <pshr> shachaf: I have an internal project I would want to develop a web interface to invoke vmcommands with "vmrun" to start and stop the Virtual machines
02:40:08 <hiptobecubic> timthelion, in the first case there, it will still "fail" at runtime right?
02:40:29 <srhb> pshr: Have you looked at System.Process?
02:40:40 <hiptobecubic> fooAble will return Nothing, but we don't know that until we know which Boop it was, which requires running the program
02:40:55 <timthelion> hiptobecubic: no, you just have to deal with the Nothing case somehow
02:41:44 <hiptobecubic> timthelion, but that's the point. The only sensible way to deal with it is terminating the universe.
02:42:08 <hiptobecubic> timthelion, say it returns Nothing, then the function using must also return Nothing because it couldn't do anything, yes?
02:42:11 <timthelion> hiptobecubic: so what's the problem?
02:42:38 <hiptobecubic> And now the whole program is wrapped in maybes when really I just shouldn't have written it such that a NonFooable Boop is Foo'd.
02:43:11 <timthelion> hiptobecubic: so then use the seccond option
02:43:33 <pshr> thanks srhb may be that'll work I am giving it a try :)
02:44:05 <maurer> pshr: System.Process is what you want, but the "correct" way would be to bind the VIX API. Since you're just getting started though, that might be a bit ridiculous
02:44:07 <hiptobecubic> timthelion, so then we operate on a Person, and we pattern match the Man, Woman part away?
02:44:12 <hiptobecubic> i mean Male Female
02:44:36 <hiptobecubic> except for castrate, which just takes a Man directly
02:44:43 <timthelion> hiptobecubic: yes
02:46:33 <hiptobecubic> timthelion, but now we have to write a new function to castrate dogs? Or we use Male Dog and use guards ?
02:46:39 <hiptobecubic> hm
02:48:20 <timthelion> but in that case I might do data Person = Person Stuff ReproductiveOrgan ; data ReproductiveOrgan = Male | Female ; So you don't need to replicate info that is shared between men and women, make castrate work on reproductiveOrgans instead
02:49:04 <hiptobecubic> ah
02:49:18 <hiptobecubic> I find this to be the most difficult aspect of haskell
02:49:45 <roconnor_> s/haskell/programming
02:50:00 <hiptobecubic> s/programming/life
02:50:31 <roconnor_> s/life/haskell
02:50:56 <ion> @remember timthelion but in that case I might do data Person = Person Stuff ReproductiveOrgan ; data ReproductiveOrgan = Male | Female ; So you don't need to replicate info that is shared between men and women, make castrate work on reproductiveOrgans instead
02:50:56 <lambdabot> Good to know.
02:51:23 <timthelion> it's a bit strange... The authors of Haskell themselves found it hard...  So doing things the right way isn't as obvious as it should be
02:54:55 <hiptobecubic> This is the type signature that led me to this problem: doStuff :: (Fooable a, Fooable b, Castratable b) => (? -> Int -> Int -> Double) -> a -> b -> Int -> Int -> Double
02:55:34 <hiptobecubic> so doStuff takes two Fooables, foos them and additionally castrates one, then combines the results
02:55:54 <hiptobecubic> but the ? is the problem
02:56:35 <hiptobecubic> the function that is the first argument there only requires a Fooable
02:56:56 <hiptobecubic> so it can be applied to both 'a' and 'b', which indeed is what happens
02:57:28 <hiptobecubic> But it can't be applied to both because then the compiler wants a and b to be the same type
02:57:33 <hiptobecubic> not just fooable
02:59:00 <hiptobecubic> That was pretty poorly explained, but hopefully it's clear
03:00:01 <roconnor_> hiptobecubic: it left me pretty confused
03:01:18 <hiptobecubic> :D
03:02:04 <makao007> could anyone tell me how to hidden system message such as "xx has joined #haskell " in freenode ?
03:02:20 <roconnor_> makao007: my client let me do taht
03:02:33 <makao007> on webchat.freenode.net
03:03:42 <roconnor_> hiptobecubic: after reading the scroll back I still don't understand what you are saying.  does castrate :: Castratable b => b -> b make a caterated copy?
03:04:22 <roconnor_> hiptobecubic: I guess I think of programming as a data flow problem, and this object talk is kinda confusing for me :D
03:04:53 <knz> hi all
03:05:15 <srhb> knz: Hi
03:05:48 <knz> haskell design question: given hs's "bind" operator and category theory's "join" operator can be defined in term of one another; what was the motivation to have bind as primitive in hs instead of join?
03:06:13 <shachaf> knz: Motivation is that it's in the Report.
03:06:33 <dmwit> whaaaat
03:06:41 <shachaf> OK, OK.
03:06:42 <shachaf> You have to have *some* operator, and in 199something they chose (>>=).
03:06:56 <shachaf> Motivation is probably that it corresponds directly to do-notation.
03:06:58 <roconnor_> knz: I *think* bind was more commonly used in the actual programms that monads were designed to abstract.
03:07:05 <knz> shachaf: you mean, the choice of return/bind predates the realization that the constructs are equivalent to the monad in category theory?
03:07:09 <dmwit> "Why did you choose X?" "In 199something, we chose X."
03:07:12 <dmwit> no shit?
03:07:12 <shachaf> I.e., foo >>= (\x -> ...) is a very common pattern.
03:07:21 <roconnor_> knz: people use various bind instanced before there was a Monad class
03:07:23 <dmwit> knz: No, absolutely not.
03:07:27 <shachaf> dmwit: I meant it in the sense of "the motivation doesn't matter, that's just how it is".
03:07:33 <knz> dmwit: ok, I am interested
03:07:42 <knz> shachaf: then you're not answering my question, sorry
03:07:46 <roconnor_> *instances
03:08:03 <knz> so
03:08:24 <srhb> I like to pronounce it fish. Just a public service announcement. Also because you fish the value out. :> And fishes are awesome.
03:08:29 <knz> roconnor_: is it correct then to say there was a clear discussion as to which of the wto forms would be most comfortable to use, and bind was therefore preferred?
03:08:58 <shachaf> srhb: "fish the value out" :-(
03:09:05 <roconnor_> knz: that I do not know
03:09:13 <knz> aha
03:09:36 <roconnor_> srhb: >=> is fish IIRC
03:09:39 <knz> alternate question then: who would actually know what the motivation was?
03:09:56 <roconnor_> knz: I expect Phil Wadler to know
03:10:00 <roconnor_> probably others too
03:10:12 <knz> ok
03:10:35 <roconnor_> knz: adding type classes for thing that were not types was a big step forward in Haskell
03:11:26 <dmwit> knz: You might look in the history of Haskell that was recently published.
03:11:40 <knz> is that a book?
03:12:03 <dmwit> I would link you to it, but my Internet connection is 100% crap just now.
03:12:45 <dmwit> Oh, the wiki page just finished downloading (after about 75s).
03:13:01 <dmwit> http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm
03:13:10 <knz> many thanks
03:15:29 <hpaste> hiptobecubic pasted âTypeclass Monstrosityâ at http://hpaste.org/71924
03:15:37 <hiptobecubic> Ok so
03:16:24 <hiptobecubic> I realized i could (Foo c => c -> String) in my signature and now it wants RankNTypes, which i guess is relating to kinds? I haven't played with that much yet
03:16:24 <srhb> shachaf: Yes, I am sorry. :P I should never say that loudly again, but it lives in my mind. (Like the real fish)
03:16:49 <shachaf> srhb: I meant the part where you implied that there's "a value" in it in the first place.
03:17:17 <srhb> shachaf: Yeah, it is nonsense beyond intuition.
03:18:08 <srhb> Come to think of it, it is kind of sad that I have a whole catch-and-release analogy for that operator. :(
03:19:27 <knz> ok, I read the history and it still does not answer my quesiton fully. Bascially what happened is that the designers of hs saw this publication: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=39155 which enables the use of category theory to describe behavior, and as a result they designed monadic I/O with return and bind
03:19:37 <knz> interestingly the cited paper uses unit and join, not bind
03:19:55 <knz> but why bind was favored to join is neither discussed in the cited paper nor the history paper
03:20:24 <ion> Neither should be favored, the typeclass would provide both in a perfect world.
03:21:41 <knz> ion: but in a perfect world we should also avoid too many different ways to do the same things, lest the learning becomes difficult
03:21:44 <srhb> Well, either can be defined in terms of the other, can't it?
03:21:45 <Cale> knz: Why bind is favoured should be obvious if you've written any amount of code in, say, the IO monad, or a parsing monad, or... well, most monads relevant to computation.
03:21:46 <srhb> As long as you have fmap.
03:22:07 <knz> Cale: well, here you're giving me an answer to the question
03:22:15 <knz> but I am surprised it's not clear for everyone
03:22:46 <dmwit> I'm pretty sure that roconnor_ gave you the exact same answer right when you asked.
03:22:55 <Cale> join is preferable if you're studying the setup mathematically, because it's simpler to describe as a natural transformation
03:22:58 <shachaf> ion: In a perfect world would the typeclass also provide (>=>)?
03:23:13 <dmwit> None of us chimed in to agree because none of us knows for sure whether that was the exact reason it was done. But I think most of us agree that's pretty likely to be it.
03:23:32 <knz> ok
03:23:43 <knz> I'll ask wadler, he seems approachable
03:24:00 <Cale> join also corresponds directly to multiplication in a monoid, (and return to its unit)
03:24:09 <shachaf> knz: "Functor isn't a superclass" is another good reason. :-)
03:24:17 <roconnor_> all this said, I wish a little that join was part of the typeclass
03:24:19 <srhb> shachaf: It's not ?!
03:24:19 <shachaf> Though you could just ask "why".
03:24:24 <srhb> But why D:
03:24:28 <ion> fmap f st = State (first f . runState st); join st = State (uncurry runState . runState st)
03:24:32 <shachaf> srhb demonstrates.
03:24:32 <dmwit> roconnor_: yep, that would be nice
03:24:38 <ion> Some monads can be implemented rather nicely with join instead of bind.
03:24:48 <srhb> Haha
03:24:50 <Cale> (once you generalise monoids to arbitrary monoidal categories, and then re-specialise to the monoidal category of endofunctors on a fixed category C)
03:24:56 * srhb is predictable D:
03:24:57 <mroman> How do I say Parsec when it's ok if no more input comes?
03:25:07 <mroman> I'm getting "unexpected end of input" right now
03:25:20 <mroman> but I'm not actually expecting more input.
03:25:32 <ion> By not trying to parse further.
03:25:41 <shachaf> join :: ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
03:25:43 <shachaf> It's so simple!
03:25:53 <Cale> shachaf: :)
03:26:05 <Cale> @djinn join :: ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
03:26:05 <lambdabot> Cannot parse command
03:26:10 <shachaf> @djinn  ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
03:26:10 <lambdabot> f a b = a (\ c -> c b)
03:26:43 <Cale> hmm, I was sure it accepted naming the function, oh well
03:26:50 <mroman> The problem is do { s <- char '{'; e <- parse; t <- char'}'; return $ Block e;}
03:26:52 <shachaf> Cale: You might be thinking of @free
03:27:02 <mroman> It's always expecting more and more
03:27:07 <Cale> Or maybe the commandline version of djinn
03:27:14 <shachaf> (>>=) :: ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
03:27:22 <shachaf> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
03:27:23 <lambdabot> f a b c = a (\ d -> b d c)
03:27:24 <dmwit> mroman: That example is hopelessly incomplete.
03:27:31 <dmwit> mroman: If you want help, you've got to give us enough to go on.
03:27:38 <shachaf> All simple, I guess.
03:27:44 <ion> mroman: No, the problem is âparseâ. (Isnât that a function provided by Parsec, not a parser, btw?)
03:27:45 <shachaf> Those implementations are too simple, in fact. :-(
03:27:53 <shachaf> @ty \a b -> a (\c -> c b)
03:27:54 <lambdabot> forall t t1 t2. (((t -> t1) -> t1) -> t2) -> t -> t2
03:28:04 <Dodek> hey, how can i sleep for a specified amount of time in forkIO thread?
03:28:11 <dmwit> Dodek: threadDelay
03:28:11 <srhb> Dodek: threadDelay
03:28:12 <ion> mroman: Btw: Block <$> (char '{' *> parse <* char '}')
03:28:20 <dmwit> Dodek: See also the Hackage package unbounded-delays
03:28:57 <mroman> Hm.
03:29:14 <mroman> Apparently the order in which I chain my parsers in parse using <|> is a HUGE deal.
03:29:15 <Dodek> thanks
03:29:22 <Cale> @djinn ?join :: ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
03:29:23 <lambdabot> Cannot parse command
03:29:31 <Cale> Djinn> ?join :: ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
03:29:31 <Cale> join :: ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r
03:29:31 <Cale> join a b = a (\ c -> c b)
03:29:33 <k0ral> hi
03:29:37 <mroman> if the block parsing is not at the end, it's expecting more
03:29:37 <maurer> mroman: So, <|> is explicitly adding a potential backtrack
03:29:53 <mroman> a <|> b <|> c <- it always tries the c even if b parsed.
03:29:54 <srhb> k0ral: hi.
03:30:08 <mroman> and I'm not expecting any more c's :(
03:30:17 <k0ral> I have encoding problems, would you please be so kind as to have a look at https://gist.github.com/3159194 and tell me what's wrong ?
03:30:24 <knz> shachaf: either I do not understand your answers or you are trying to confuse me on purpose.
03:30:37 <knz> in both cases it's annoying
03:30:43 <Cale> mroman: The order in which you add parsers with <|> is very important, but you're wrong about it always trying c
03:30:45 <knz> and not helping
03:30:45 <shachaf> knz: I'm not trying to confuse you on purpose.
03:30:49 <maurer> mroman: That is not what it does
03:30:56 <maurer> mroman: Why do you think that it is doing that?
03:31:02 <shachaf> If it's the former, I could clarify further if you said what you don't understand, rather than "it's annoying".
03:31:18 <mroman> maurer: Because my code is finished at }
03:31:21 <Cale> mroman: x <|> y  will attempt to parse with x, and if x fails *without consuming input*, it will attempt to parse with y instead
03:31:22 <knz> shachaf: I just sent an e-mail to wadler to ask him what he thinks
03:31:25 <mroman> but it keeps expecting stuff after }
03:31:25 <shachaf> It's true that I made a joke earlier, which maybe wasn't clear.
03:31:29 <knz> he seems helpful from his web page
03:32:03 <Cale> mroman: If x parses any input at all before failing, then y will not be attempted.
03:32:21 <mroman> my parse is many $ parseBlock <|> parseSep <|> parseNumber <|> parseChar <|> parseIdent
03:32:31 <mroman> an parseBlock is the '{' parse '}' thingy.
03:32:38 <Cale> However, note that whenever x is a parser, try x is a parser which tries to parse with x, but if x fails, acts as if no input was consumed.
03:32:52 <mroman> And If I try to parse {1} I get unexpected end of input.
03:32:53 <shachaf> knz: OK?
03:32:59 <hiptobecubic> Aha!
03:33:00 <maurer> mroman: Did you forge tto consume whitespace after your parseBlock if you didn't use a tokenized parser at the end?
03:33:21 <maurer> Or forget to consume EOF ater the many?
03:33:22 <hiptobecubic> doStuff :: (Foo a, Foo b, Bar b) => (forall c. (Foo c) => c -> String) -> a -> b -> IO ()
03:33:37 <shachaf> knz: If I'm causing other people misery, I'm generally happy to not do that. But "you're annoying, so I emailed my question to someone else instead" probably won't accomplish anything in terms of that. :-)
03:33:38 <mroman> If I try to parse "{1} " it says expecting {, digit or }
03:34:02 <mroman> which means that it want's another block after each blokc
03:34:07 <mroman> maurer: EOF might be the problem.
03:34:41 <maurer> mroman: It is most likely a tokenization thing. Did you do char '}' or something like that?
03:34:45 <maurer> Instead of using the braces combinator?
03:34:51 <Cale> knz: shachaf was just playing around with the join from the continuation monad
03:35:05 <mroman> maurer: char '{'; t <- parse; char '}' yes.
03:35:12 <knz> shachaf: I usually spend more time with people who are "generally not happy to cause misery" and not merely "generally happy to not cause misery" because it provides a better incentive to avoid misery in the first place
03:36:00 <mroman> When does many exactly stop parsing?
03:36:10 <Cale> knz: I'm pretty sure the potentially-confusing part of what shachaf said recently was actually not directed at you :)
03:36:17 <shachaf> knz: I think your distinction is too subtle for me.
03:36:20 <knz> Cale: ok
03:36:38 <shachaf> Anyway I still have no idea what it was that I said that caused misery, if anything.
03:36:55 <augur> ski: so i find that the one-or-zero intuitionistic sequent calculus makes it really easy to give a syntax
03:37:06 <maurer> mroman: Your issue is a tokenization one. Either use the token module to generate token parsers or add a whitespace parser at the end of each of your parsers
03:37:11 <maurer> iirc the parsec manual covers this
03:37:16 <augur> ski: but it forces a particular syntax, namely, bottom up.
03:37:37 <augur> ski: i was hoping if you did it top down, you could get something else that was interesting, but it seems to be almost impossible to do that. :\
03:38:02 <knz> ok to give some context to my inquiry
03:38:19 <knz> it just happens I am interested in education
03:38:19 <maurer> mroman: The problem is that "EOF" is an incoming symbol, and in a normally structured parser, this is dealt with by the whitespace consumption tacked on to the end of each token
03:38:31 <maurer> mroman: If you feel the need to manually structure your parser you will need to consume it yourself
03:38:33 <knz> and it is obvious when you educate logically-minded people that join is simpler to explain
03:38:36 <knz> and to learn
03:38:48 <Cale> knz: That is true for some monads
03:38:53 <Cale> knz: and less true for others
03:38:55 <knz> which makes me think that it would make sense to have join as a primivite and derive bind from it if it is that useful
03:39:03 <knz> Cale: is that so?
03:39:23 <maurer> knz: State monad would be a good example
03:39:29 <Cale> knz: Well, think about what   join :: IO (IO a) -> IO a   does in terms of IO actions.
03:39:30 <maurer> knz: Sure, both are trivial, but one is intuitive
03:39:35 <ion> maurer: Of which?
03:39:44 <Cale> Or sure, the State monad
03:39:47 <knz> Cale: that's program composition for you
03:39:47 <maurer> ion: Of something where bind is more intuitive than join
03:39:51 <Cale> Or a parsing monad
03:39:55 <knz> the evaluation thereof
03:39:57 <ion> maurer: fmap f st = State (first f . runState st); join st = State (uncurry runState . runState st)
03:40:11 <Cale> knz: Well, what does it actually do?
03:40:23 <mroman> "{1} " gives me expecting digit, but "{1}1" says unexpected digit
03:40:25 <mroman> very confusing.
03:40:31 <Cale> Lots of things could be called "program composition"
03:40:48 <shachaf> Cale: When combined with Control.Monad.Spawn, it does what "join" does in every other language. :-)
03:40:51 <Cale> and in fact, in this case, that's a little confusing, since there's only one program which is the input to join here
03:40:52 <shachaf> (I.e., "join thread".)
03:41:25 <Cale> (a program which happens to produce another program as its result)
03:42:13 <maurer> ion: I don't know what you are trying to prove to me. Intuitiveness doesn't have too much to do with the implementation, and writing a pointfree join like that is unlikely to be intuitive to people who are still learning.
03:42:21 <maurer> ion: Note that pedagogy is the current topic of discussion.
03:42:26 <Cale> join x = do v <- x; v -- this is not a very common imperative pattern for most people (even if variations on it can be quite a useful one)
03:42:38 <mroman> Even if I doy char '}'; eof; it keeps yelling at me :(
03:42:40 <mroman> -y
03:42:50 <Cale> mroman: paste your entire code to hpaste
03:43:09 <ion> maurer: I find ârun the state action against the current state resulting in a new state action and a new state; run the new state action against the new stateâ quite intuitive.
03:43:12 <Cale> mroman: It's really hard to know for sure what's going on without seeing the whole parser.
03:43:21 <triyo> Anyone try the distributed-process examples?
03:43:31 <triyo> They don't compile on my end
03:43:45 <knz> Cale: could you not describe this join you just wrote as the performing of 1 step in a computation
03:43:49 <knz> ?
03:43:54 <knz> that seems intuitive to explain
03:44:01 <Cale> knz: uh... not really
03:44:05 <k0ral> is anyone looking at my problem ? :S
03:44:16 <ion> maurer: as a description of State s (State s a)
03:44:21 <mroman> oh
03:44:25 <ion> maurer: Err. State s (State s a) -> State s a
03:44:26 <mroman> my parseIdent consumes EOF
03:44:28 <Cale> knz: It takes a computation which produces another computation as its result, and turns that into a computation which runs the first, and then runs its result afterward
03:44:42 <mroman> and since an ident has at least a length of two it's expecting something AFTER eof.
03:45:02 <Cale> knz: In the list monad, join is easy to describe though. It's just concatenation there :)
03:45:16 <knz> hmm
03:45:25 <mroman> noneOf "1234567890" consumes EOF.
03:45:27 <Cale> while >>= is concatMap
03:45:35 <Cale> or rather =<< is
03:45:58 <shachaf> These operations are so similar that an argument that one is obviously always more intuitive is a bit silly.
03:46:05 <shachaf> I can give you lots of justifications for both of them.
03:46:10 <Cale> sure
03:46:45 <Cale> Though it's hard to deny that in real programming, an occasion to use join in the IO monad is rare
03:46:46 <mroman> Ok. How can I adjust ident to not parse eof
03:46:48 <shachaf> For example: join/fmap/return is three operations, (>>=)/return is two. (>>=) is a complicated higher-order function, whereas with join/fmap/return the only higher-order function involved is simple.
03:46:52 <dmwit> mroman: "consumes EOF"?
03:46:58 <dmwit> Nothing consumes EOF.
03:47:03 <shachaf> do-notation directly translates to (>>=), not to join/fmap
03:47:20 <Cale> (i.e. an occasion where you wouldn't just use >>= instead)
03:47:37 <dmwit> noneOf "1234567890" doesn't successfully parse if you've reached EOF, but that's a bit different. "consume" has a technical meaning in the context of Parsec.
03:47:37 <srhb> k0ral: Are you sure that it doesn't work? I see \233 where I would expect Ã©, althought my French is rusty, that seems correct
03:47:45 <knz> can we please leave do-notation out of this conversation?
03:47:48 <mroman> I have paseIdent at the end of the <|> chain
03:47:53 <shachaf> Sometimes, (>>=)'s type/implementation is more complicated. Sometimes, join/fmap's type/implementation is more complicated.
03:47:56 <knz> I understand do-notation is useful pedagogically to teach haskell to imperative programmers
03:47:58 <triyo> Examples seem to refer to mkTransport function and TCPConfig constructor that don't exist. I compiled the packages from distributed-process source
03:47:59 <mroman> and parseIdent does noneOf "123456790" twice
03:48:01 <knz> but that's not the context I'm coming from
03:48:03 <shachaf> knz: Didn't you say this was about teaching?
03:48:11 <shachaf> knz: do-notation isn't really just about imperative programmers.
03:48:15 <mroman> and debugging tells me, that parseIdent is the cause for the unexpected end of input.
03:48:15 <knz> shachaf: teaching to people who come from theory/logic
03:48:45 <shachaf> "theory"?
03:48:52 <knz> I mean, I am find with teaching first join, then expressing do-notation in terms of join by eliding bind from the transition
03:48:59 <knz> shachaf: algebra
03:49:00 <k0ral> srhb: well, I obviously would like to see "Ã©" rather than \233
03:49:01 <knz> sorry
03:49:04 <Cale> by the way, something interesting I was thinking about the other day because of a question of acowley's in ##categorytheory is that Monad has this basis over Functor of return and join, each of which involves only one type parameter 'a'
03:49:11 <Cale> Can the same be done for Applicative?
03:49:19 <triyo> Ok there is a ticket that says examples are out of date. Fair enough.
03:49:21 <srhb> k0ral: Well, the \233 is exactly an Ã©, I think.
03:49:25 <Cale> Or how do we prove that such a thing is impossible? :)
03:50:17 <dmwit> > "Ã©"
03:50:18 <lambdabot>   "\233"
03:50:28 <dmwit> > text "Ã©"
03:50:29 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
03:50:30 <Cale> knz: do-notation is also just good notation
03:50:57 <k0ral> srhb: but I don't want to read \233, I want an "Ã©" to be printed, isn't that obvious ?
03:51:13 <k0ral> srhb: with other RSS feeds, accents are correctly displayed
03:51:16 <Cale> knz: For basically the same reason that list comprehensions are good notation
03:51:17 <knz> Cale: "good" on which scale?
03:51:20 <dmwit> k0ral: So, don't use "print" for output?
03:51:38 <k0ral> dmwit: then why does it work for many other RSS feeds ?
03:51:45 <maurer> k0ral: http://hpaste.org/71925
03:51:47 <k0ral> it just doesn't work for this one
03:51:51 <dmwit> k0ral: What is "it"?
03:51:56 <maurer> k0ral: Does this explain your problem?
03:52:00 <dmwit> k0ral: What does "work" mean?
03:52:01 <k0ral> dmwit: my example script
03:52:05 <Cale> knz: Well, it gets rid of a lot of syntactic noise in the construction of many terms
03:52:13 <maurer> k0ral: print implicitly calls "show" which prints escaped characters
03:53:14 <k0ral> maurer: it seems to be my problem, but:
03:53:27 <k0ral> 1/ why did it work with other RSS feeds ?
03:53:40 <maurer> 1.) They probably did not have characters which were escaped by show
03:53:41 <hpaste> mroman pasted âparsec, unexpected end of inputâ at http://hpaste.org/71926
03:53:45 <knz> Cale: so it increases the signal/noise ration in the desription of algorithms
03:53:50 <ion> maurer: I also find the similarity between the implementations of fmap and join potentially useful in an educational context.
03:53:50 <k0ral> 2/ try to replace print with putStrLn in my example script, it doesn't turn escaped characters into accents either
03:54:05 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; if x^2 + y^2 == z^2 then return (x,y,z) else []
03:54:06 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
03:54:13 <k0ral> maurer: 1/ there were accents so...
03:54:17 <knz> my challenge then would be, is there no alternate notation than do-notation that would have the same signal/noise ratio as do-notation for algorithms and directly map to join instead of bind?
03:54:30 <k0ral> dmwit: "work" means "do not print escaped characters"
03:54:41 <Cale> > [1..20] >>= \x -> [x..20] >>= \y -> [y..20] >>= \z -> if x^2 + y^2 == z^2 then return (x,y,z) else []
03:54:42 <knz> or otherwise, a proof it is impossible to define such a notation?
03:54:43 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
03:55:01 <mroman> The unexpected "1" is also really bugging me
03:55:12 <mroman> as I'd expect parseNumber to kick in and eat that "1"
03:55:28 <maurer> k0ral: Some accets are within ASCII iirc
03:55:35 <shachaf> maurer: ?
03:55:48 <srhb> k0ral: Using Data.Text.Lazy.IO.putStr I do get the correct accents in your example
03:55:57 <maurer> http://en.wikipedia.org/wiki/Extended_ASCII
03:56:13 <maurer> shachaf: ^
03:56:15 <srhb> k0ral: "... et j'ai cherchÃ© Ã  installer skype. Le premier rÃ©flexe quand on veut installer skype c'est... "
03:56:17 <ion> > join (fmap (\x -> join (fmap (\y -> join (fmap (\z -> if x^2 + y^2 == z^2 then return (x,y,z) else []) [y..20]) [x..20]) [1..20])
03:56:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:56:18 <shachaf> "Extended ASCII" :-(
03:56:28 <Cale> > join (fmap (\x -> [x..20] >>= \y -> [y..20] >>= \z -> if x^2 + y^2 == z^2 then return (x,y,z) else []) [1..20])
03:56:29 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
03:56:53 <Cale> > join (fmap (\x -> join (fmap (\y -> [y..20] >>= \z -> if x^2 + y^2 == z^2 then return (x,y,z) else []) [x..20]) [1..20])
03:56:54 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:56:56 <Cale> oops
03:57:07 <maurer> mroman: Your parsers are not atomic
03:57:13 <maurer> mroman: So they are failing with input consumed
03:57:16 <Cale> > join (fmap (\x -> join (fmap (\y -> [y..20] >>= \z -> if x^2 + y^2 == z^2 then return (x,y,z) else []) [x..20])) [1..20])
03:57:18 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
03:57:46 <Cale> > join (fmap (\x -> join (fmap (\y -> join (fmap (\z -> if x^2 + y^2 == z^2 then return (x,y,z) else []) [y..20])) [x..20])) [1..20])
03:57:47 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
03:58:12 <k0ral> srhb: :D right, thank you !
03:58:14 <Cale> ^^ I've gotten rid of the do-notation and >>=
03:58:17 <srhb> k0ral: :)
03:58:28 <Cale> Sure, you can write code like this
03:58:51 <Cale> but it's kind of weird, especially once you get to writing IO code
03:59:00 <srhb> k0ral: Take-away point: Don't use show (or indirectly, print) in production, it behaves like a debugging tool
03:59:17 <knz> I am personally more interested in explaining do-notation in terms of join - fmap  + CPS
03:59:20 <knz> instead of bind
03:59:30 <Cale> join (fmap putStrLn getLine)
03:59:33 <k0ral> srhb: noted :)
03:59:51 <shachaf> knz: Why not define (>>=) as join .: fmap and then explain it in terms of (>>=)?
04:00:04 <Cale> That might actually be the most readable example :)
04:00:06 <shachaf> I mean, there's no better abstraction to explain do-notation in terms of than (>>=).
04:00:15 <shachaf> It translates *exactly* to (>>=).
04:00:56 <roconnor_> apparently lenses are the monads for 2013
04:00:59 <roconnor_> :P
04:01:11 * roconnor_ is reading http://www.infoq.com/interviews/bjarnason-scalaz
04:02:00 <srhb> :t (.:)
04:02:01 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
04:02:07 <ion> roconnor: Whatâs the food-related analogy?
04:02:35 <srhb> ion: Lenses... Are like taco shells stuffed into peep holes.
04:02:53 <roconnor_> ion: lenses are like bananas covered in barbed wire
04:03:09 <shachaf> Lenses are like lenses.
04:03:25 <shachaf> I always like making analogies to real-world objects like that!
04:03:28 <shachaf> Here's another one:
04:03:30 <shachaf> Monads are like monads.
04:03:43 <srhb> I don't like recursive analogies.
04:03:57 <shachaf> srhb: It's a corecursive analogy.
04:04:00 <Sgeo_> Recursive analogies are like recursive analogies.
04:04:03 <srhb> shachaf: Sorry :(
04:04:11 <srhb> shachaf: It's hard to tell the difference.
04:06:22 <Cale> Monads are just like monoids, but where sets have been replaced by endofunctors, the Cartesian product has been replaced by functor composition, the one-element set with the identity functor and functions have been replaced by natural transformations.
04:14:45 <savask> Hello. How can I change packed vector (http://hackage.haskell.org/packages/archive/hmatrix/0.13.0.0/doc/html/Data-Packed-Vector.html#t:Vector) cell? I heard there is a magic ST monad which can do sorcery like that, but I'm not sure if it will work for packed vectors.
04:17:10 <mcstar> http://hackage.haskell.org/packages/archive/hmatrix/0.13.0.0/doc/html/Data-Packed-ST.html
04:17:57 <savask> mcstar: Thanks, now I should learn how to use ST :-P
04:18:07 <nand`> Cale: (re: StateT pick) not bad :)
04:18:23 <Eduard_Munteanu> savask: it's pretty easy. Have you used IORefs, btw?
04:18:33 <Eduard_Munteanu> Or IOArrays?
04:18:38 <savask> Eduard_Munteanu: No.
04:18:54 <zzzzzbogus> hi! is there a vim mode for Haskell with support for cabal projects?
04:19:32 <Cale> nand`: There are a bunch of related ones where pick is adjusted appropriately, or you do something other than replicateM
04:19:39 <Eduard_Munteanu> savask: you can build a computation on mutable stuff in the ST monad, and extract the result using runST
04:19:51 <nand`> Cale: I just saw the one you highlighted me for
04:19:58 <Cale> nand`: I didn't type out the others
04:20:54 <savask> Eduard_Munteanu: Okay. But it's still a bit confusing, cause it has functions like "freeze".
04:20:57 <Eduard_Munteanu> savask: e.g.   runST $ do { v <- newVector ...; readVector v 1 }
04:21:08 <Cale> I just mean, if you change pick, say, to instead of picking a tail, select out one element in all possible ways, and give the remaining elements in the list, you get permutations instead
04:21:28 <Eduard_Munteanu> savask: that's supposed to give you an immutable vector which can escape the ST context.
04:21:50 <nand`> Cale: oh, I see what you mean -> You mean the trick can be generalized to solve a lot of choice problems
04:21:54 <Cale> yes
04:21:56 <nand`> I wonder what you can do in monads other than []
04:22:40 <savask> Eduard_Munteanu: Isn't readVector v 1 at the end useless?
04:23:32 <Cale> There's a similar trick you can pull with Cont in order to compose together a bunch of 'withFoo' style functions to give you access to a list of resources all at once.
04:24:16 <Eduard_Munteanu> savask: mm, no, how do you mean? That example creates a vector and reads the second element (and returns it).
04:24:22 <Eduard_Munteanu> readVector :: Storable t => STVector s t -> Int -> ST s t
04:24:36 <Eduard_Munteanu> :t runST
04:24:38 <lambdabot> forall a. (forall s. ST s a) -> a
04:25:09 <Cale> :t \withFoo n -> runCont (replicateM n (cont withFoo))
04:25:11 <lambdabot> forall a r. ((a -> r) -> r) -> Int -> ([a] -> r) -> r
04:25:18 <savask> Eduard_Munteanu: I thought runST will return the vector o_O
04:25:25 <Cale> or the other way, of course:
04:25:30 <Cale> :t \n withFoo -> runCont (replicateM n (cont withFoo))
04:25:32 <lambdabot> forall a r. Int -> ((a -> r) -> r) -> ([a] -> r) -> r
04:25:53 <Eduard_Munteanu> savask: it will, if you use freeze as the last statement.
04:26:14 <Eduard_Munteanu> runST (return $ 1 + 1)
04:26:16 <Cale> :t withCString
04:26:17 <lambdabot> Not in scope: `withCString'
04:26:18 <Eduard_Munteanu> > runST (return $ 1 + 1)
04:26:20 <lambdabot>   2
04:26:48 <Cale> :t Foreign.C.withCString
04:26:49 <lambdabot> forall a. String -> (Foreign.C.String.CString -> IO a) -> IO a
04:26:54 <hiptobecubic> @type flip id
04:26:55 <lambdabot> forall a b. a -> (a -> b) -> b
04:26:58 <Cale> ^^ functions like this
04:27:00 <Eduard_Munteanu> > runST (newSTRef 5 >>= modifySTRef (+1) >>= readSTRef)
04:27:02 <lambdabot>   The section `GHC.Num.+ 1' takes one argument,
04:27:02 <lambdabot>  but its type `GHC.STRef.STRe...
04:27:06 <hiptobecubic> I don't see where that is coming from
04:27:09 <hiptobecubic> give flip and id
04:27:15 <hiptobecubic> @src flip
04:27:15 <lambdabot> flip f x y = f y x
04:27:28 <Eduard_Munteanu> > runST (newSTRef 5 >>= flip modifySTRef (+1) >>= readSTRef)
04:27:29 <lambdabot>   Couldn't match expected type `()'
04:27:29 <lambdabot>         against inferred type `GHC.STRef....
04:28:01 <savask> Eduard_Munteanu: I'm going to use runSTVector. It's type shows that it returns the vector, so I don't need to use freeze?
04:28:16 <Eduard_Munteanu> :t flip modifySTRef (+1)
04:28:18 <lambdabot> forall s a. (Num a) => STRef s a -> ST s ()
04:28:23 <Cale> :t \xs -> runCont (sequence (map (cont . Foreign.C.withCString) xs))
04:28:24 <lambdabot> forall a. [String] -> ([Foreign.C.String.CString] -> IO a) -> IO a
04:28:25 <Eduard_Munteanu> > runST (newSTRef 5 >>= flip modifySTRef (+1) >> readSTRef)
04:28:27 <lambdabot>   Couldn't match expected type `GHC.ST.ST s a'
04:28:27 <hiptobecubic> I guess it takes the  x and y and applies y to x
04:28:27 <lambdabot>         against inferred type ...
04:28:31 <Eduard_Munteanu> Ah.
04:28:51 <Cale> of course...
04:29:03 <Eduard_Munteanu> > runST $ do { a <- newSTRef 5; modifySTRef a (+1); readSTRef a)
04:29:03 <Cale> :t \xs -> runCont (mapM (cont . Foreign.C.withCString) xs)
04:29:04 <lambdabot>   <no location info>: parse error on input `)'
04:29:05 <lambdabot> forall a. [String] -> ([Foreign.C.String.CString] -> IO a) -> IO a
04:29:10 <Eduard_Munteanu> > runST $ do { a <- newSTRef 5; modifySTRef a (+1); readSTRef a}
04:29:11 <lambdabot>   6
04:29:25 <Eduard_Munteanu> savask: maybe it actually does the same thing
04:29:53 <savask> Eduard_Munteanu: I should try :-P
04:29:58 <Eduard_Munteanu> It's analogous to runSTArray.
04:30:27 <Eduard_Munteanu> Ah...
04:30:33 <Eduard_Munteanu> runSTVector :: Storable t => (forall s . ST s (STVector s t)) -> Vector t
04:30:34 <Eduard_Munteanu> runSTVector st = runST (st >>= unsafeFreezeVector)
04:30:49 <savask> Ah, it does that for me.
04:31:13 <Eduard_Munteanu> And yeah, better than just freezing.
04:33:10 <mroman> Ok.
04:33:15 <mroman> My ident probably consumes the '}'
04:33:23 <mroman> and therefore there is none left for parseBlock
04:34:16 <mroman> ha.
04:34:21 <mroman> That was the problem :)
04:53:35 <ksf> anyone here know uuagc?
04:53:58 <ksf> I get GenAst.ag:33:29: warning: Nontrivial field import is used as local at constructor Import of nonterminal Decl.
04:53:58 <ksf>    even though I'm doing everything as in the tutorial
04:54:01 <ksf> err manual
04:54:25 <ksf> that is, the field import is a DATA field.
04:55:55 <hiptobecubic> Can any emacs users confirm that this is also the case there? I don't know how ghc-mod works for emacs. If it just calls commandline ghc-mod then i assume so.
04:55:58 <hiptobecubic> https://github.com/kazu-yamamoto/ghc-mod/issues/69
04:58:35 <ksf> ahhh. "nontrivial" means "is a uuagc-declared type instead of a pure haskell type"
04:59:47 <hiptobecubic> how can i list all installed packages with cabal?
05:01:03 <ksf> ghc-pkg list
05:03:53 <k0ral> hey guys, can I upgrade the Text.Feed module although I'm not it's author/maintainer ?
05:04:21 <k0ral> it messes up with the encoding I was having troubles with (it only uses String)
05:05:36 <luite> k0ral: you can edit the source (cabal unpack feed), bump its version and make it installable with cabal-src
05:05:47 <d-old> hey anyone know if this: http://www.haskell.org/haskellwiki/Extensible_datatypes was ever implemented?
05:06:43 <luite> k0ral: if you want to publish it, best first mail the maintainer, if you don't get a response, then ask haskell-cafe. then decide what to do (new maintainer, or fork package under a new name)
05:07:19 <hpaste> hape01 pasted âJSON exampleâ at http://hpaste.org/71929
05:08:16 <hpaste> hape01 annotated âJSON exampleâ with âJSON example (annotation)â at http://hpaste.org/71929#a71930
05:08:23 <mroman> How can I re-export a module I imported?
05:08:31 <k0ral> luite: ok :)
05:09:25 <hpaste> hape01 pasted âJSON exampleâ at http://hpaste.org/71931
05:10:12 <hpaste> hape01 annotated âJSON exampleâ with âJSON example (annotation)â at http://hpaste.org/71931#a71932
05:10:31 <hpaste> hape01 annotated âJSON exampleâ with âJSON example (annotation) (annotation)â at http://hpaste.org/71931#a71933
05:10:39 <mroman> nvm.
05:12:02 <hape01> How Do I tell GHCI that it shall include "json" module when compiling my sourcefile?   When I compile with cabal evertything is fine (since "json" module is referenced) but when I run the single Testsourcefile with GHCI the json reference is missing. http://hpaste.org/71931
05:13:30 <Nereid> hape01: it *should* work
05:13:52 <Nereid> what's the exact error?
05:13:57 <Nereid> oh it's there.
05:14:19 <Nereid> ok, the problem isn't to do with the json module
05:14:22 <Nereid> your code is wrong :)
05:15:19 <kmels> hello, how can I have a function of type Int -> Word8 if I know that Int is a value between 0 and 2^8-1 ?
05:15:27 <Nereid> kmels: fromIntegral
05:15:33 <kmels> thanks
05:15:42 <Nereid> @type fromIntegral
05:15:43 <lambdabot> forall a b. (Integral a, Num b) => a -> b
05:16:22 <kmels> right, Word8 is an instance of Num
05:16:35 <hape01> Nereid: In GHCI it doesnt compile... what can I do to solve? How tell GHCI which modules to use?
05:16:42 <Nereid> hape01: fix your type error
05:17:11 <hape01> Nereid: Since it compiles with cabal, why should it have a type error?
05:18:01 <Nereid> hape01: what is this "json" package you speak of, anyway? I don't see a package by that name on hackage.
05:18:20 <Nereid> oh, I'm blind.
05:18:44 <Nereid> anyway,
05:18:50 <Nereid> it is strange that it compiles.
05:18:55 <Nereid> with cabal.
05:19:10 <hape01> Nereid: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/json
05:19:31 <Nereid> yes, I found it. and ghci agrees with what I think should happen give the type of toJSObject
05:19:40 <maurer> hape01: At ghci, type :m Text.JON
05:19:58 <Nereid> maurer: that doesn't help, and isn't the problem anyway
05:20:53 <Nereid> hape01: oh
05:20:58 <Nereid> here's why it compiles in cabal
05:21:02 <Nereid> cabal isn't seeing your source file at all
05:21:05 <Nereid> so there is nothing to compile
05:21:31 <hape01> Nereid: ?
05:21:46 <Nereid> you are not referencing your JsonTest01 anywhere in your cabal file
05:22:11 <hape01> Nereid: sure I do: hs-source-dirs: src
05:22:13 <hape01> therein it is
05:22:20 <maurer> hape01: Is it called Main.hs?
05:22:25 <Nereid> hape01: then you don't understand what hs-source-dirs does.
05:22:33 <Nereid> read the docs
05:22:59 <maurer> Nereid: tbf, it could be called Main.hs, but then I'd expect other errors due to a mismatch of filename and module name
05:23:06 <hape01> Nereid: it is not called main.hs - that might be the reason....
05:23:19 <Nereid> ...
05:23:19 <hape01> Nereid: yes this information helps me ...
05:25:40 <Nereid> hape01: you should read the cabal user guide on developing packages
05:25:47 <Nereid> before using cabal
05:27:12 <Nereid> "Every module in the package must be listed in one of other-modules, exposed-modules or main-is fields."
05:29:04 <hape01> Nereid: Thank you for your hints, that will solve it for me.
05:30:03 <hiptobecubic> How does packaging actually work? There are two places that meta-data is stored? Cabal has a repo *and* ghc has one?
05:30:31 <Nereid> cabal is for building and installing packages only
05:30:40 <maurer> hiptobecubic: cabal-install has a registry of where to find packages, ghc-pkg maintains the only registry of installed packages
05:30:42 <hpc> cabal knows where to get packages
05:30:44 <Nereid> ghc has a list of installed packages
05:30:45 <hpc> ghc knows which ones you have
05:31:04 <Nereid> and cabal-install is a handy tool for building and installing packages, as well as fetching them, etc.
05:31:16 <Nereid> (cabal is the library, cabal-install is the program)
05:31:47 <hiptobecubic> well I just upgraded ghc, and i'm trying to avoid this problem where you end up with unresolvable dependencies after a month or two
05:31:48 <maurer> hiptobecubic: If you are an old school unix man, cabal-instal : ghc-pkg :: apt-get : pkg-config
05:31:59 <hiptobecubic> maurer, ohhh
05:32:24 <maurer> hiptobecubic: Though cabal-install is actually a little dumber than apt-get -- it doesn't even know what it's installed
05:32:40 <Nereid> "cabal is not a package manager"
05:32:49 * nand` uses portage for Haskell packages
05:32:50 <hiptobecubic> cabal-install is pretty shockingly dumb, yes
05:32:51 <nand`> works very well
05:33:03 <nand`> never ended up with an unusable system, gone from GHC 6.x to 7.4.2 in rolling updates
05:33:08 <maurer> Nereid: cabal is definitely not. cabal-install is also not, but is closer
05:33:21 * maurer thinks we really should have named cabal-install something else to avoid this confusion, but it's too late now
05:33:24 <hpc> isn't cabal-dev even closer still?
05:33:32 <hiptobecubic> nand`, if you don't need the latest of everything AND eveything is available, then that's fine
05:33:41 <maurer> hpc: cabal-dev does things in a mostly orthogonal direction I thought?
05:34:12 <maurer> Like, bottling up installs is not normally what people think of a package manager as doing
05:34:31 <maurer> (though it would be nice if they could do that by default - the hackity solution one uses to do clean debian packaging is a nightmare)
05:34:40 <nand`> hiptobecubic: the repository I use has older versions available too down to a sane limit; but you can always install the packages straight off hackage so theoretically any version on hackage is available (+ other stuff not distributed via hackage, live repos etc.)
05:35:19 <nand`> hiptobecubic: some hackage packages *don't* have portage packages available for them, but a single command line invocation creates them
05:36:01 <Nereid> nand`: I found hackport annoying after a while
05:36:21 <nand`> Nereid: for what reason?
05:36:40 <Nereid> I don't remember, but I stopped using it.
05:36:43 <hiptobecubic> I guess i'll just live with my monthly rebuild-everything strategy :)
05:37:04 <nand`> hiptobecubic: to perhaps clarify, portage has a tool called âhaskell-updaterâ that rebuilds all haskell packages with broken or missing dependencies
05:37:29 <nand`> which is what allows it to do rolling updates of haskell packages without resulting in total breakage
05:37:46 <hiptobecubic> nand`, sounds nice if it's robust
05:38:28 <Nereid> and if you don't have that, ghc-pkg check will give you a list of broken packages
05:38:31 <Nereid> which you can do something about yourself
05:38:35 <nand`> yeah
05:38:46 <nand`> (haskell-updater uses ghc-pkg internally, it's not deeply magical)
05:39:43 <maurer> nand`: How do you create them?
05:39:58 <maurer> I currently use gentoo (and the haskell overlay), but have had to use cabal for other packages
05:40:04 <maurer> As I did not know it was simple to add them
05:40:14 <nand`> maurer: using app-portage/hackport and a local overlay
05:40:40 <nand`> I have an alias to âsudo hackport -p /usr/local/portageâ (the path is that of my local overlay)
05:41:03 <mekeor> Is Haskore really complicated or is it me?
05:41:08 <maurer> Ah, I also already have a local overlay exactly there from other stuff :)
05:41:09 <maurer> Thanks
05:41:12 <nand`> so I just run âhackport merge packageâ to automatically add it; or âhackport merge package-versionâ
05:41:54 <nand`> if the package isn't on hackage, (eg. for git versions) it's a bit more complicated, you have to download the .cabal file and run âhackport make-ebuild dev-haskell file.cabalâ
05:42:03 <nand`> where dev-haskell is the category it will be in
05:42:50 <flojistik> Hey there
05:43:25 <mekeor> Hi flojistik :)
05:43:25 <flojistik> is there a way to get an up-to-date haskell platform on Debian without messing-up with the system too much?
05:43:50 <nand`> flojistik: install it outside apt? :P
05:44:33 <mekeor> flojistik: personally, i just use the debian unstable :P. but most people will recommend you to just download and install the latest GHC, i think.
05:45:21 <mekeor> hmm, GHC, or the whole HaskellPlatform, dunnoâ¦
05:45:30 <zmv> lol debian
05:45:51 <flojistik> nand`: I don't really care, but I'd like not to mess up with the system too much, so I wouldn't mind outside apt
05:45:53 <zmv> I've only had bad experiences with it.
05:46:01 <nand`> flojistik: that's what I'd do in your place
05:46:03 <flojistik> if it could be self-contained, I would be happy
05:46:12 <nand`> install it to ~/.ghc ~/.cabal perhaps
05:46:20 <hpc> zmv: that's strange, because it's been nothing but stable for me
05:47:01 <nand`> hpc: perhaps he's measuring by criteria other than stability? Personally, I can't stand debian, but that doesn't mean I've had it crash on me
05:47:21 <hpc> ah
05:47:25 <zmv> it never *crashed* on me too
05:47:44 <nand`> (by contrast, I've had my favorite distro crash on me before, it's still my favorite)
05:47:53 <hpc> i don't use it as a desktop OS, so that might be part of it
05:48:22 <zmv> it felt a little bit slower than arch, the packages were annoyingly old and I had to work harder than usual to get wifi working
05:48:35 * mekeor . o O ( are people ignoring me or is my irc-client broken? )
05:48:36 <zmv> and I didn't really know how to use wpa-supplicant by itself back then
05:48:54 <zmv> mekeor: I wouldn't know.
05:49:03 <nand`> zmv: I don't bother with wpa-supplicant. I use wicd for wireless
05:49:04 <hpc> zmv: ah, that makes sense
05:49:10 <mekeor> aah, finally someone called my name, thanks!
05:49:24 <nand`> mekeor: if zmv hadn't spoiled it, I would have pretended to ignore that message just to unnerve you
05:49:25 <hpc> i haven't had any of those problems, except for maybe the old packages one
05:49:26 <nand`> :)
05:49:45 <hpc> debian testing updates at about arch-speed
05:50:00 * mekeor uses debian unstable.
05:50:05 <mekeor> â it's stable! :D
05:50:11 <hpc> except for ghc, which updates painfully slowly
05:50:20 <hpc> you don't generally ever want to install ghc from apt
05:50:22 <zmv> also, SBCL
05:50:27 <nand`> my main gripes with debian's repository per se is the fact that mixing old with new versions is harder than it needs to be. There are backports, but only for a few packages
05:50:30 <Qtr> is there some haskell-centric linux distro?
05:50:36 <mekeor> Qtr: yes
05:50:42 <nand`> mekeor: there is?
05:50:46 <nand`> mekeor: which?
05:50:46 <mekeor> Qtr: i forgot its nameâ¦
05:50:55 <mekeor> it was on the mailing listâ¦
05:51:02 <Qtr> Arch?
05:51:13 <mcstar> nixos
05:51:19 <mcstar> ?
05:51:31 <nand`> Î»OS!
05:51:38 <nand`> (not really)
05:51:53 <mcstar> Î»OST
05:51:57 <mcstar> where T is bottom
05:52:16 <mekeor> i rly forgot its nameâ¦ -.-
05:52:39 <mcstar> zmv: is sbcl still broken on arch?
05:52:49 <zmv> mcstar: it was broken? :P
05:52:52 <mcstar> yes
05:53:04 <mcstar> i have it in pkg-ignore list
05:53:26 <zmv> I don't think it's broken
05:53:29 <mcstar> i built mine own, cause the official one has broken bactrace
05:53:39 <mcstar> try it
05:53:43 <zmv> 1.0.57 is working fine here, I guess
05:53:49 <mcstar> define fine
05:54:06 <zmv> what's bactrace?
05:54:47 <mcstar> backtrace
05:54:57 <zmv> well, the backtrace is working fine here
05:55:18 <zmv> at least I can't see anything wrong with it
05:56:18 <mcstar> (defun f2 (x) (1+ x)) (defun f1 (x) (f2 x)) (f1 nil)
05:56:33 <mcstar> zmv: can you paste me the backtrace of the above?
05:57:52 <zmv> "SIMPLE-TYPE-ERROR [...] Argument X is not a NUMBER: NIL [...]"
05:58:29 <mcstar> pls, write 'backtrace' at the debug prompt
05:58:36 <mcstar> and copy the stuff to a pastebin
05:59:26 <mcstar> if you do that, ill give you a cybercookie for your troubles
06:00:18 <zmv> http://paste.lisp.org/display/130638
06:00:34 <mcstar> yay
06:00:37 <mcstar> looks good
06:00:56 <mcstar> zmv: here you go: <cookie>
06:01:13 <zmv> wee
06:01:41 <Qtr> Where is Dons?
06:04:25 <hiptobecubic> How do you tell cabal to *always* build profiling libs?
06:04:50 <hiptobecubic> and why on earth can't they be added later without rebuilding everything and breaking the universe
06:05:08 <maurer> hiptobecubic: You can do it by adding it to your .cabal/config
06:05:23 <maurer> hiptobecubic: It can't be added later because cabal's dependency tracking doesn't track changes to compilation options
06:05:30 <Qtr> Could you say that a typeclass is like an interface?
06:05:41 <hiptobecubic> maurer, i thought I did? library-profiling : True ?
06:05:56 <maurer> hiptobecubic: That should do it, yes, what's going wrong?
06:06:03 <hiptobecubic> maurer, it doesn't build them.
06:06:04 <hiptobecubic> lol
06:06:10 <mcstar> build what?
06:06:12 <hiptobecubic> it will if i specify -p
06:06:16 <mcstar> it will build new packages with profiling
06:06:18 <hiptobecubic> the *.p_o
06:06:27 <hiptobecubic> mcstar, it is not building them with profiling.
06:06:33 <mcstar> o.O
06:06:33 <maurer> Qtr: Yes and no. They are frequently used for similar things, but they must be indexed by types
06:06:35 <mcstar> O.o
06:07:08 <maurer> hiptobecubic: Do you ahve that space in there? Maybe it's a misparse?
06:07:14 <hiptobecubic> i just wiped out everything, started completely over and now it says it build syb without them so it's just going to explode instead of continuing
06:07:32 <mcstar> would cabal config be that fragile?
06:07:51 <hiptobecubic> ah wait
06:08:22 <hiptobecubic> I didn't realize the -- were comments here as well, since every option is commented out I thought it was just the weird syntax of cabal configs
06:08:53 <hiptobecubic> well that's depressing
06:08:56 <hiptobecubic> guess i'll start over
06:09:49 <mcstar> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/faster
06:09:54 <mcstar> hiptobecubic: have you seen this?
06:10:04 <mcstar> hiptobecubic: lol
06:10:21 <mcstar> im sorry, but thats soo funny
06:12:01 <Qtr> im confused if i have data Matrix = MatrixI [Int] | MatrixD [Double], how do i do instance Num Matrix?  one for each type of Matrix?
06:12:31 <ion> data Matrix a = Matrix [a]
06:12:35 <hiptobecubic> mcstar, which part?
06:12:53 <mcstar> hiptobecubic: which part what?
06:13:04 <hiptobecubic> is funny?
06:13:15 <mcstar> ah, that you didnt know -- were comments
06:13:52 <hiptobecubic> In haskell files, sure. Cabal clearly isn't using haskell syntax though. I wasn't expecting the entire file to be a comment :)
06:14:03 <mcstar> hiptobecubic: the site i linked contains general remarks to enhance performance, i thought it might come handy
06:14:08 <Qtr> ion: then how do i construct a Matrix?
06:14:17 <hiptobecubic> mcstar, yes, i had it bookmarked already :)
06:14:49 <ion> qtr: Matrix [42, 43]
06:15:43 <maurer> hiptobecubic: That's a common thing in config files, not just in haskell. e.g. most distros ship files in /etc/ with example directives which represent the defaults, but are all commented out
06:16:27 <hpaste> Qrt pasted âNum typeclass problemâ at http://hpaste.org/71934
06:16:42 <Nereid> Qtr: I think you should use a different type.
06:16:44 <hiptobecubic> maurer, sure. If they were '#' comments it would have clicked. For some reason it just didn't look strange to me. Also vim didn't highlight anything so nothing stood out. Particularly not the note at the top about '--' being comments :D
06:16:45 <Qtr> how to do the Num?
06:16:50 <Nereid> data Matrix a = Matrix [a]
06:17:08 <Nereid> and then have an instance Num a => Num (Matrix a)
06:17:17 <Qtr> i know [] is terrible efficiency-wise but im just learning about typeclasses not implementing matrices
06:17:18 <Nereid> (a list still might not be what you want though!)
06:17:21 <mcstar> instance (Num a) => Num Matrix where
06:17:24 <ion> qtr: Youâre trying to apply (+) to two arbitrary âaâs in the zipWith part. You need a âNum aâ constraint, as Nereid said.
06:17:42 <hiptobecubic> isn't that going to be a problem? Matrix a = Matrix [a]? infinite type?
06:18:17 <mcstar> left Matrix is a type, right Matrix is a constructor
06:18:30 <Nereid> i.e.
06:18:34 <hiptobecubic> oh right
06:18:36 <hiptobecubic> yes, nevermind
06:18:39 <Nereid> it's defining a type Matrix a, and a constructir Matrix :: [a] -> Matrix a
06:18:49 <Nereid> constructor
06:19:19 <ksf> can someone explain like I'm five why I need lines 20..23?  http://hpaste.org/71935
06:19:39 <ksf> it even warns me that default copy rules of that are deprecated if I leave out 22.23
06:20:01 <ksf> ...all I want to access is a field that's definetely there, that's all.
06:20:30 <mcstar> out of curiosity, what language is that?
06:20:31 <Nereid> what language is that :s
06:20:38 <ben> I bet it's agda
06:20:42 <ksf> that's uuagc-augmented haskell
06:20:46 <ben> oh :(
06:20:48 <Nereid> doesn't look like agda
06:20:55 <ben> it said .ag somewhere in it!
06:21:03 <Nereid> but not .agda
06:21:04 <Nereid> ;)
06:22:02 <ksf> I mean, uuagc has a big machinery to avoid having to state the obvious, and then it's enforcing such things.
06:25:48 <Qtr> what is signum? sign?
06:25:58 <Qtr> sign of matrix whats it that really?
06:26:06 <Qtr> if it has positive and negative elems?
06:26:11 <Qtr> > sgn [1,2]
06:26:13 <lambdabot>   Not in scope: `sgn'
06:26:18 <Qtr> > signum [1,2]
06:26:19 <lambdabot>   No instance for (GHC.Num.Num [t])
06:26:20 <lambdabot>    arising from a use of `e_112' at <inte...
06:26:21 <Qtr> > sign [1,2]
06:26:23 <lambdabot>   Not in scope: `sign'
06:26:29 <Qtr> > signum 1
06:26:30 <lambdabot>   1
06:26:35 <Qtr> > signum (-2)
06:26:37 <lambdabot>   -1
06:26:41 <Qtr> > signum 2
06:26:42 <lambdabot>   1
06:26:46 <Qtr> > signum 0
06:26:47 <lambdabot>   0
06:27:00 <Qtr> > positive 9
06:27:02 <lambdabot>   Not in scope: `positive'
06:27:06 <Qtr> > pos 9
06:27:07 <lambdabot>   Not in scope: `pos'
06:27:12 <ksf> matrixen usually aren't instances of num
06:27:18 <mcstar> eh
06:27:22 <mcstar> matrices
06:27:25 <ksf> at least if the library has some dignity left.
06:27:29 <byorgey> Qtr: signum returns -1, 0, or 1  depending on whether the argument is negative, zero, or positive
06:27:36 <ksf> nono. it's ox, oxen, so it's matrix, matrixen.
06:27:48 <ksf> just like boxen and regexen.
06:27:57 <mcstar> k......
06:28:01 <ksf> and soksen, of course.
06:28:06 <ksf> *socksen
06:28:06 <byorgey> what about vertex/vertices and kleenex/kleenices ?
06:28:22 <ksf> those are latin.
06:28:33 <mcstar> i think its a grammar joke, that ksf is pulling on us
06:28:33 <ksf> -en is the germanic plural.
06:28:40 <byorgey> ahh, right, and matrix is lower estonian
06:28:41 <Botje> kleenices? *G*
06:28:49 <byorgey> kk, makes sense
06:34:01 <k0ral> @hoogle extractHtml
06:34:01 <lambdabot> No results found
06:36:06 <Nereid> really one should have data Matrix Nat Nat a
06:36:29 <hiptobecubic> I thought Nat wasn't possible
06:36:40 <Nereid> it is with DataKinds
06:36:48 <hiptobecubic> Nereid, how so?
06:36:55 <Nereid> read up on DataKinds and find out ;)
06:37:37 <Nereid> they're still experimental on 7.4 though
06:38:08 <nand`> Agda? In my Haskell?
06:38:36 <Nereid> it's not full-blown dependent types so no ;)
06:38:59 <nand`> I know :( but still, reminds me of Agda-style vectors
06:39:09 <Nereid> of course it does.
06:39:25 <nart> hi
06:39:28 <scopedTV> hi nart
06:40:07 <nart> i have broken haskell-platform-2012.2.0.0 ... how can i reinstall it ?
06:40:46 <scopedTV> how did you manage that? / what did you do?
06:40:58 <scopedTV> which platform are you on?
06:41:40 <nart> osx, i have unregistered network 2.3.0.13
06:41:59 <nart> because it was conflicting with 2.3.0.14 (or ithought it was)
06:42:16 <scopedTV> the easiest (not necessarily best) way is to remove ~/.ghc and ~/.cabal, then reinstall the platform
06:42:35 <scopedTV> you could try to install network 2.3.0.13 again, as well.
06:42:42 <nart> already did
06:42:53 <nart> it's not working, because i should reinstall it
06:43:33 <nart> i suspected there was no easy way ... i have to reinstall everything :(
06:44:27 <nart> scopedTV: thank you anyway
06:46:39 <mroman> When using functional dependencies to combine
06:46:39 <mroman>       MonadState s (StateT s m),
06:46:44 <mroman>         arising from the dependency `m -> s'
06:47:00 <mroman> What does that error message mean?
06:47:25 <scopedTV> That's not enough context mroman.
06:47:32 <scopedTV> Can you paste your program and the error message?
06:47:33 <scopedTV> @hpaste
06:47:34 <lambdabot> Haskell pastebin: http://hpaste.org/
06:48:20 <hiptobecubic> I don't really get why we need RankNTypes
06:48:25 <mroman> That happens when you have State Foo () but giving something else to put
06:48:42 <hiptobecubic> i'm looking at the Haskell wiki with this forall example, but i don't see a difference between rank1 and rank2 really
06:48:52 <mroman> ie State String () and you do put (6 :: Int)
06:49:04 <scopedTV> hiptobecubic: consider the following example.
06:49:09 <hiptobecubic> why is forall a. a -> (forall b. b -> a)  rank1 but forall a. a -> (forall b. b -> a) rank2?
06:49:43 <scopedTV> g :: (a -> a) -> (String, Integer); g f = (f "Hello", f 37)
06:49:51 <scopedTV> does this typecheck?
06:50:17 <hiptobecubic> scopedTV, yes?
06:50:20 <scopedTV> no
06:50:22 <hiptobecubic> damn
06:50:24 <hiptobecubic> :D
06:50:51 <scopedTV> for example,  g (id :: Integer -> Integer), judging by the types, would be valid, right?
06:51:04 <hiptobecubic> well a->a can only be id right?
06:51:10 <hiptobecubic> with no other info
06:51:12 <scopedTV> That's true
06:51:21 <scopedTV> but also not important.
06:51:48 <scopedTV> g :: (Num a => a -> a) -> (Float, Integer); g f = (f 37.0, f 37)
06:51:57 <scopedTV> same question really
06:52:00 <hiptobecubic> hmm
06:52:23 <scopedTV> take  map :: (a -> b) -> [a] -> [b]
06:52:28 <scopedTV> now the *caller* can choose a and b
06:52:37 <scopedTV> map *cannot* use any information on a and b
06:52:44 <hiptobecubic> true
06:52:55 <dzhus> is it possible to access mutable vectors (from vector package) concurrently?
06:53:06 <scopedTV> but what if i want to pass a polymorphic function?
06:53:16 <scopedTV> then you'll need rank-2 types
06:53:33 <hiptobecubic> scopedTV, but in the first example, g didn't need to know anything about f other than it worked on Nums
06:53:40 <hiptobecubic> and then it was given some Nums
06:54:22 <scopedTV> hiptobecubic: it should really be
06:54:31 <scopedTV> g :: Num a => (a -> a) -> (Float, Integer)
06:54:49 <hiptobecubic> What does that change?
06:54:57 * hackagebot timers 0.2.0.0 - Simple package that implements timers. (PetrPilar)
06:55:06 <scopedTV> this promises a function that for all a that instantiate Num, g is a function that takes a (a -> a) and returns a (Float, Integer)
06:55:36 <scopedTV> in particular, i should be able to apply g to a value of type Double -> Double.
06:56:42 <scopedTV> hiptobecubic: the first syntax is illegal.
06:56:59 <scopedTV> the latter example is what I meant.
06:57:19 <hiptobecubic> scopedTV, oh ok sure. a also needs to be Integral
06:57:32 <scopedTV> no, still not enough
06:58:01 <scopedTV> so the problem is that g really wants a polymorphic function as its argument
06:58:03 <hiptobecubic> and f needs to have (fromIntegral) composed with it?
06:58:30 <hiptobecubic> scopedTV, sure, but isn't it? what is 'a' there?
06:58:31 <scopedTV> i.e. it wants   (forall a. Num a => (a -> a)) -> (Float, Integer)
06:58:50 <hiptobecubic> does f lose its polymorphism somehow?
06:59:01 <scopedTV> g :: forall a. Num a => (a -> a) -> (Float, Integer)
06:59:26 <scopedTV> this g can be applied to a  Double -> Double, since that is what the function promises
06:59:44 <scopedTV> h :: (forall a. Num a => (a -> a)) -> (Float, Integer)
06:59:52 <ski> Cale : "For instance, the MLs don't have an equivalent of Eq" -- SML has equality type variables
07:00:21 <scopedTV> h cannot be applied to a  Double -> Double, since it requires an argument of type  forall a. Num a => (a -> a)  (i.e. a polymorphic function)
07:00:36 <hiptobecubic> wait wait
07:01:02 <hiptobecubic> h requires that the definition of f *also* use forall then?
07:01:16 <scopedTV> No. Normally "forall" is implicit
07:01:21 <hiptobecubic> yes
07:01:26 <hiptobecubic> but it's there
07:01:34 <scopedTV> but yeah.
07:01:56 <hiptobecubic> and in g, we're saying what then?
07:01:56 <scopedTV> h requires that the type of its argument is polymorphic, of type  forall a. Num a => (a -> a)
07:02:05 <hiptobecubic> that f can have any type, but only one?
07:02:35 <scopedTV> in g, we're saying that for all a instantiating Num, we have a function that takes a  (a -> a)  and returns a  (Float, Integer)
07:02:53 <hpaste> hiptobecubic pasted âRankNTypesâ at http://hpaste.org/71937
07:03:11 <hiptobecubic> That was the example i made this morning, when i discovered i needed RankNTypes
07:03:13 <scopedTV> in h, we're saying that for all functions (forall a. Num a => a -> a), we have a (Float, Integer)
07:03:37 <scopedTV> yeah, this is the same problem/issue
07:04:58 <scopedTV> now you should be able to see why it's similar
07:05:47 <srhb> Is there a better way than this to make a (coord,value) pair from a list of lists? \ls -> [ ((x, y), v) | (l,x) <- zipWith (,) ls [1..], (v,y) <- zipWith (,) l [1..] ]
07:05:47 <srhb>  
07:05:53 <srhb> Or, more idiomatic I guess i should say
07:07:15 <scopedTV> looks ok srhb
07:07:23 <srhb> Righto :)
07:07:40 <scopedTV> I'd write    (i, xs) <- zipWith (,) [1..] xss
07:07:50 <scopedTV> i.e. the "coordinate" first
07:07:57 <scopedTV> zipWith (,) is just zip
07:08:04 <srhb> Oh yeah
07:08:05 <srhb> I forgot
07:08:09 <hiptobecubic> so f gets its type restricted when you apply it to A, and then it can't be applied to B?
07:08:22 <scopedTV> hiptobecubic: that's what happens operationally in the compiler
07:08:35 <scopedTV> hiptobecubic: in general it's not possible to make the compiler "smart enough" in these cases, you need type annotations
07:08:59 <hiptobecubic> i guess i don't understand why it's not the default, if implicit forall is the default?
07:09:18 <scopedTV> hiptobecubic: well if you'd leave the forall off in your example, it would mean
07:09:38 <scopedTV> forall a b c. (Foo a, Foo b, Bar b, Foo c) => (c -> String) -> a -> b -> IO ()
07:09:46 <scopedTV> this is very different from what you wrote, which is
07:10:02 <scopedTV> forall a b. (Foo a, Foo b, Bar b) => (forall c. (Foo c) => c -> String) -> a -> b -> IO ()
07:10:35 <hiptobecubic> hmm
07:10:47 <hiptobecubic> ok
07:10:48 <scopedTV> the second is "stronger", you require that f is polymoprhic. this means that your caller has to provide a polymorphic function
07:11:28 <hpc> effectively, instead of specializing c to Int or Bool, you specialize it to "it can't be specific"
07:11:47 <hiptobecubic> But why does it get specialized to Int or Bool?
07:11:59 <hiptobecubic> if we start off with 'c can be anything'
07:12:10 <hpc> hiptobecubic: well, suppose you had
07:12:22 <hpc> exampleMap :: (a -> a) -> [a] -> [a]
07:12:29 <flojistik> go
07:12:32 <flojistik> oops
07:12:35 <hpc> which is really forall a. (a -> a) -> [a] -> [a]
07:12:40 <hiptobecubic> ok
07:12:41 <knz> hi back
07:12:45 <hpc> now, you can pass in "not" as the first parameter
07:13:01 <hpc> which specializes the function to (Bool -> Bool) -> [Bool] -> [Bool]
07:13:19 <hpc> or you could pass id, which does no specialization
07:13:25 <hpc> or (+ 5), etc
07:13:30 <hpc> now suppose you had
07:13:30 <hiptobecubic> ok sure, but the next time you want to apply exampleMap in the same scope, it should start over from the general type?
07:13:50 <hpc> exampleMap :: forall a. (forall b. b -> b) -> [a] -> [a]
07:13:54 <scopedTV> hiptobecubic: yes, if that's the type that has been inferred.
07:13:58 <scopedTV> hiptobecubic: or specified.
07:14:13 <hpc> you can no longer pass in (+ 5), or not, or whatever
07:14:19 <scopedTV> hiptobecubic: however, the compiler cannot find the most general type anymore in presence of rank-2 types
07:14:21 <hpc> that first function parameter has to be polymorphic over b
07:14:41 <hiptobecubic> but for example
07:14:42 <hpc> you have specialized (a -> a) to the case of being polymorphic
07:14:42 <scopedTV> hiptobecubic: this is a limitation of the universe.
07:14:52 <hiptobecubic> we have exampleMap (a->a)->[a]->[a]
07:14:56 <hpc> the only thing you can pass into exampleMap now is "id"
07:15:21 <hiptobecubic> we do  x = exampleMap (+1) [1,2,3]
07:15:36 <hiptobecubic> then we want to do  y = exampleMap (not) [true, true]
07:15:41 <hiptobecubic> why is that confusing
07:15:52 <scopedTV> you mean,   [True, True]
07:15:58 <hiptobecubic> yes
07:16:00 <scopedTV> your example is fine. That works.
07:16:17 <hpc> hiptobecubic: let's typecheck x = exampleMap (+1) [1,2,3]
07:16:18 <hiptobecubic> Then i don't see how it's different
07:16:22 <hpc> for both types of exampleMap
07:16:24 * ski wonders what hiptobecubic is up to
07:16:33 <hpc> so starting with it matching the type of "map"
07:16:49 <hpc> exampleMap :: (a -> a) -> [a] -> [a]
07:16:59 <hpc> unify (a -> a) with (Int -> Int)
07:17:02 <hpc> a = Int
07:17:12 <hpc> etc etc, and x :: [Int]
07:17:18 <hpc> now
07:17:32 <hpc> exampleMap :: (forall b. b -> b) -> [a] -> [a]
07:17:44 <hpaste> hiptobecubic pasted âNot RankNTypesâ at http://hpaste.org/71938
07:17:46 <hpc> unify (forall b. b -> b) with (Int -> Int)
07:17:57 <hiptobecubic> how is this different from the example i just made with exampleMap?
07:19:16 <hiptobecubic> hpc, i see that that won't work because we can't *do* anything with b
07:19:24 <hpc> yes
07:19:25 <hiptobecubic> but we could if we knew they were Ints?
07:19:27 <ski> hpc's `exampleMap' above is using a rank-2 function
07:19:34 <scopedTV> Your example is more like  exampleMap2 :: (a -> a) -> [b] -> [c] -> ([b], [c]);  exampleMap2 f xs ys = (map f xs, map f ys)
07:19:34 <ski> hiptobecubic : no
07:20:43 <ski> there is no "if we knew they were Ints?" with `exampleMap :: (forall b. b -> b) -> [a] -> [a]'
07:20:51 <hpc> hiptobecubic: i think a rough analog of what you pasted is
07:21:31 <hiptobecubic> ski, i'm not saying we could somehow find out they are Ints, I'm saying that we can't do anything because don't what they are, but if we did, as in the normal case, then we could
07:21:47 <hpc> > do {print False; print [1, 2, 3, 4, 5];} -- i think you are roughly asking if print is rank-2 in this expression
07:21:49 <lambdabot>   <IO ()>
07:22:05 <hpc> albeit with a more complex example
07:22:14 <ski> hiptobecubic : is the "we" you're talking about the caller of `exampleMap', or the callee (i.e. that function itself) ?
07:22:23 <hiptobecubic> hpc, i'm not super familiar with how print actually does things, so maybe?
07:22:39 <scopedTV> hiptobecubic: and the answer is "yes" if print is an argument to a function
07:22:41 <ski> `print' is not rank-2
07:22:47 <rwbarton> yes, but in hpc's example, print did not come into scope via a function argument, it is a top-level binding
07:22:51 <hpc> cool, so let's start with that first
07:22:52 <scopedTV> however, in global scope it is not.
07:22:56 <hpc> what rwbarton said
07:22:57 <rwbarton> or in the exampleMap example
07:22:59 <ski> if you had `foo print = do {print False; print [1, 2, 3, 4, 5];}', then `foo' would be rank-2
07:23:06 <hiptobecubic> rigiht
07:23:16 <hiptobecubic> yes, this is what i'm not understanding
07:23:22 <hiptobecubic> why is it ok at top-level and not otherwise
07:23:34 <ski> "it" being ?
07:23:34 <scopedTV> it *is* ok otherwise.
07:23:40 <hpc> hiptobecubic: the cop-out answer is, "because otherwise polymorphism wouldn't work"
07:23:53 <scopedTV> only the compiler cannot infer this without a hint
07:23:54 <hiptobecubic> why does the type get restricted if you pass the function to another function, but not if it's at top-level
07:24:07 <ski> hiptobecubic : it does not
07:24:33 <hiptobecubic> ski, well it wouldn't, except that the compiler does it anyway?
07:24:46 <ski> however, if you pass a polymorphic thing as an argument to a function (using it polymorphically in the body), then that function is higher-rank
07:24:54 <hpc> hiptobecubic: what happens in "do {print False; print [1, 2, 3, 4, 5];}", is that the two calls to "print" don't get unified with each other
07:25:07 <hpc> but they separately get unified with the top-level type of print
07:25:23 <ski> hpc : `length' might be a nicer example than `print'
07:25:37 <hiptobecubic> ski, yes. ok that is a great summary and what I'm asking is what about that makes it higher rank? Why does a polymorphic function need a hint to be told "yes, please continue to be polymorphic"
07:25:44 <ski> (or `reverse')
07:26:14 <ski> hiptobecubic : it's not the polymorphic function which needs that, but the function which takes it as an argument
07:26:18 <scopedTV> hiptobecubic: because the haskell type inference requires this.
07:26:28 <rwbarton> well type inference for higher rank types is undecidable like scopedTV mentioned earlier
07:26:38 <scopedTV> hiptobecubic: in "normal" haskell types (i.e. rank-1) all forall's are pushed to the left.
07:26:52 <hpc> hiptobecubic: if you want to pass a top-level function as a parameter to another function, and have it typecheck in exactly the same way as at the top-level, you do something like
07:27:04 <ski> hiptobecubic : taking polymorphic things as *arguments* requires the thing taking it as an argument being declared with a higher-rank type signature
07:27:06 <hpc> foo topLevel ... = ...
07:27:15 <hpc> foo :: (exact type of topLevel) -> ...
07:27:17 <hpc> so for print
07:27:18 <hpc> :t print
07:27:20 <lambdabot> forall a. (Show a) => a -> IO ()
07:27:28 <hpc> foo :: (forall a. (Show a) => a -> IO ()) -> ...
07:27:57 <hiptobecubic> hm
07:28:46 <hpc> what makes function parameters diffent from top-level definitions is the position of the forall
07:28:56 <hpc> if that makes sense
07:28:57 <rwbarton> also you normally don't want polymorphic arguments... like in map :: (a -> b) -> [a] -> [b]
07:29:12 <rwbarton> well, bad example
07:29:18 <hpc> no, good example
07:29:20 <scopedTV> you could do that in rwbarton's example
07:29:26 <scopedTV> but it makes the function far less useful
07:29:27 <hpc> in map :: (a -> b) -> [a] -> [b]
07:29:27 <rwbarton> well, okay
07:29:34 <ski> polymorphic arguments / rank-2 types can be useful to hide implementation details
07:29:40 <hpc> you want the "a" in (a -> b) and [a] to be THE SAME "a"
07:29:45 <hiptobecubic> ski, that's what i'm doing with it
07:29:46 <rwbarton> the point is the two as are the same and the two bs are the same yes
07:29:49 <hiptobecubic> Sure, there you want the first a to be the exact same a as the second one
07:29:54 <hiptobecubic> hpc, right
07:29:56 <hpc> which means the "forall a." goes all the way on the outside
07:30:16 <rwbarton> if "map :: (a -> b) -> [a] -> [b]" meant "map :: (forall a b. a -> b) -> (forall a b. [a] -> [b])"... how would you express the actual type of map
07:30:30 <hpc> hiptobecubic: turn on Rank2Types in a file and play around a bit
07:30:44 <hpc> it will do more for you than our explaining will
07:30:48 <scopedTV> I like my example as well.
07:30:56 <scopedTV> g f = (f "hello", f 37)
07:30:57 <hiptobecubic> hpc, did you see my paste? I was doing that this morning, it's how i came to this problem
07:30:58 <ski> hiptobecubic : i came in late, i'm not quite sure what it is you are wondering / want help with
07:30:59 <rwbarton> in other words there is no special relation between "forall" and "->"
07:31:08 <hpc> hiptobecubic: oh, i see
07:31:23 <rwbarton> it is just that any free variables are implicitly forall'd, at the top level of the type
07:31:45 <hiptobecubic> scopedTV, to be honest, I don't see the connection with your example compared to the others given
07:32:11 <scopedTV> hiptobecubic: that example is really the core of the problem.
07:32:18 <scopedTV> g :: (a -> a) -> (String, Integer)
07:32:29 <ski> hiptobecubic : an example of using rank-2 types to hide implementation details : "repaste of PoorManDebug" by ski in 2009-09-30 at <http://hpaste.org/10060>
07:33:05 <ski> hiptobecubic : hm, you mentioned a paste .. where is it ?
07:34:12 <beaky> is 'learn you a haskell for great good!' a good book on haskell or does it get some thigns wrong?
07:34:28 <rwbarton> ski: http://hpaste.org/71937 http://hpaste.org/71938
07:34:29 <scopedTV> beaky: it's universally acclaimed in this channel
07:34:31 <nand`> I think it's a good
07:34:34 <nand`> good book*
07:34:37 <scopedTV> beaky: i have no personal experience
07:34:41 <Nereid> it's a good introduction
07:35:00 <hpc> i learned haskell from LYAH
07:35:10 <beaky> it seems to be a great introrduction
07:35:33 <hiptobecubic> I used it as well. It's enjoyable
07:35:34 <beaky> I like the cute pictures.
07:35:40 <chidy> LYAH got me excited about haskell
07:35:56 <beaky> so all I need to follow LYAH is ghc?
07:36:02 <nand`> ghci, preferably
07:36:04 <beaky> do I need the entire haskell-platform ?
07:36:07 <nand`> (which is part of ghc)
07:36:12 <hiptobecubic> hpc <hpaste> hiptobecubic pasted âNot RankNTypesâ at http://hpaste.org/71938
07:36:26 <scopedTV> hiptobecubic: so g :: (String, Integer); g = (id "hello", id 37)
07:36:40 <scopedTV> vs  g :: (forall a. a -> a) -> (String, Integer); g id = (id "hello", id 37)
07:36:47 <scopedTV> hiptobecubic: do you now see the connection?
07:36:48 <Nereid> beaky: the book tells you what you need ;)
07:36:58 <beaky> xlent book
07:37:11 <Nereid> I think ghc suffices?
07:37:25 <Nereid> but it's good to get the whole platform
07:37:35 <chidy> Bring a good sense of humor along too
07:37:38 <beaky> what does Haskell let you easily accomplish that would be more difficult or impossible to do in a conventional language like Java or C++?
07:37:54 <hiptobecubic> scopedTV, what i'm seeing is that without the forall, a gets bound to one of the types and then won't typecheck against the other one
07:38:09 <scopedTV> hiptobecubic: yes that's how the type inference engine works
07:38:26 <ski> hiptobecubic : and you're wondering why `doStuff :: (Foo a, Foo b, Bar b) => (forall c. (Foo c) => c -> String) -> a -> b -> IO ()' instead of `doStuff :: (Foo a, Foo b, Bar b, Foo c) => (c -> String) -> a -> b -> IO ()' ?
07:39:02 <scopedTV> hiptobecubic: if type inference were smart enough, it could infer this type.
07:39:08 <Nereid> should have a
07:39:11 <Nereid> "forall a b c." in front of that
07:39:16 <scopedTV> hiptobecubic: however, it has been proven that that's not possible.
07:39:19 <hiptobecubic> beaky, it let me easily consume hours worth of arguably expert instruction in category theory for free? C++ most argues about new places they can wedge the std library in.
07:39:40 <ski> hiptobecubic : the thing is that with the former type signature, `doStuff' will decide what type `c' is, but with the latter, the caller will decide (a single type) which `c' is
07:39:44 <beaky> what is category theory?
07:39:55 <hiptobecubic> it begins...
07:40:00 <Nereid> can we call them different names?
07:40:09 <Nereid> call the latter doStuff'
07:40:12 <beaky> I like how lots of the modern C++ features originate from Haskell
07:40:14 <Nereid> (the wrong one)
07:40:23 <ski> beaky : advanced math stuff which you don't really need to understand to understand how to use `Functor',`Applicative',`Monad' in Haskell
07:40:35 <Nereid> now in doStuff', there's a quantifier "forall a b c." in front.
07:40:36 <hiptobecubic> ski, scopedTV ok. i think i get it
07:40:39 <ski> beaky : .. but if you're curious, we're happy to explain it :)
07:40:59 <Nereid> which means the function better work for any types a b c
07:41:07 <Nereid> which means it can't assume a = c or b = c
07:41:19 <Nereid> moreover, c can only be a single thing, so we can't have both a = c and b = c.
07:41:40 <hiptobecubic> beaky, you don't NEED it. But i'd argue it's the most compelling reason to spend hours writing something that would be simple in a less rigorous setting like python's ducktyping
07:42:19 <beaky> so most of the way haskell works comes from Catogery Theory concepts?
07:42:26 <ski> no
07:42:30 <ski> some of it does
07:42:34 <ski> not most it
07:42:41 <hiptobecubic> i thought it was an afterthought that just fit really well?
07:42:50 <hiptobecubic> Monads weren't around in the early days, no?
07:42:53 <Nereid> there is a connection between haskell and category theory, but you don't need to understand it to be productive in haskell
07:42:53 * geekosaur also
07:42:56 <ski> hiptobecubic : correct
07:43:04 <Nereid> (or category theory)
07:43:06 <hiptobecubic> beaky, i spent a few hours talking to DrSyzygy  and saved the whole thing. It might not be helpful if you aren't asking your own questions, but it might still be good.
07:43:15 <hiptobecubic> i'll paste it
07:44:17 <ski> beaky : the basic workings of Haskell has little to do with category theory (per se). a few common library things has connections to category theory
07:44:39 <Nereid> the connection is basically "haskell types form a category"
07:44:50 <Nereid> (and the category has various properties)
07:44:58 <hiptobecubic> http://hpaste.org/71939
07:45:01 <hiptobecubic> knock yourself out
07:45:02 <ski> Nereid : yes, but you could argue that about e.g. ML or Pascal as well
07:45:30 <Nereid> sure, but it then turns out that lots of things that come up in haskell can be expressed in terms of category theory.
07:45:50 <Nereid> in a nice way.
07:46:22 <ski> beaky : if you're just beginning to learn Haskell, i would advice you to wait with the log hiptobecubic provided
07:46:32 <hiptobecubic> beaky, you should start with the wiki page on monad or monoid or something though, this looks heavy form the start
07:46:37 <hiptobecubic> beaky, what ski said
07:46:39 <ski> Nereid : yeah, parametric polymorphism e.g.
07:46:39 <beaky> right
07:47:07 <hiptobecubic> by this point i had already spent a few hours trying to figure it out on my own
07:48:07 <ski> beaky : so .. start with LYAH, and come back here when you've got questions, ok ? :)
07:48:16 <ski> (but maybe you've got more questions already ?)
07:48:43 <hiptobecubic> beaky, yes. LYAH is a good place to start.
07:49:21 <covi> LYAH is not light. A gentle warning :)
07:49:37 <hiptobecubic> it starts pretty easy i think?
07:49:41 <ski> beaky : it can also be useful to stay in here, and lurk, reading what other people are talking about, trying to make some sense of it :)
07:50:03 <hiptobecubic> especially if you have had some experience with some other language, which most people who start haskell have, it seems
07:50:09 <covi> hiptobecubic: I mean heavy in volume for a complete newbie
07:50:23 <nand`> volume is good
07:50:26 <nand`> it's all about the pacing
07:50:28 <hiptobecubic> covi, volume?
07:50:43 <nand`> if you try to read and make sense of all chapters in a single day that is not the right thing to do :P
07:50:48 <beaky> lots of haskell features ive already played with in other languages: list compherehensions(python), typeclasses(c++ templates), functor, but closures, monads, and currying not so much :(
07:51:06 <covi> hiptobecubic: It's long.
07:51:14 <nand`> what about laziness, purity and sum types?
07:51:14 <hiptobecubic> covi, better than short :)
07:51:23 <covi> hiptobecubic: sure
07:51:28 <Eduard_Munteanu> Well, for some LYAH is ok, for others the (Not So?) Gentle Introduction might do too.
07:51:28 <hiptobecubic> currying is by far the easiest to understand
07:52:01 <Philippa> the Gentle Introduction could use a modern rewrite (but with the same brevity), I reckon
07:52:07 <beaky> laziness is new
07:52:25 <hiptobecubic> laziness takes some work to get your head in the right mode
07:52:43 <Philippa> well, it depends: a lot of stuff *just works* because of it
07:52:54 <hiptobecubic> but i think LYAH is a good place to start. If nothing else, the pictures stop it from being boring
07:52:55 <Philippa> a lot of other stuff is more thinky, but if you're sticking to finite data...
07:53:00 <beaky> aren't we lazy by nature?
07:53:04 <nand`> I thought laziness was pretty easy to understand
07:53:21 <hiptobecubic> beaky, yes. but you've probably been trained to think your computer is not
07:53:31 <Philippa> nand`: that depends on how you define "understand", there are some thorny corners
07:53:49 <nand`> it's most brain-warping when you get to some more odd concepts, eg. why one recursive function can terminate while another can when the only thing you add is an irrefutible pattern match
07:53:54 <Saizan> nand`: it has some non-local consequences which are not that easy to foresee
07:54:24 <Philippa> the difference between laziness and non-strictness matters, too!
07:54:29 <nand`> laxness
07:54:39 <EvanR1> slackness
07:55:26 <hpc> is there a function that takes an array's bounds and a function, then makes an array from (f index)?
07:55:42 <hiptobecubic> Generate?
07:55:48 <nand`> hiptobecubic: personally, when I was learning Haskell I forgot all about the computer; since I had no concept of how Haskell maps down to assembly (and still hardly do); I just forgot the computer existed
07:55:57 <nand`> meanwhile in imperative languages I have a feeling for what the processor does
07:56:08 <scopedTV> i read the STG paper.
07:56:21 <scopedTV> but it's not so useful to know
07:56:24 <Philippa> yeah, the STG paper and the eval-apply followup will give you a fair model
07:56:34 <nand`> I skimmed through http://blog.ezyang.com/2011/04/tracing-the-compilation-of-hello-factorial/ but it seemed too full of noise for me to ever really get into
07:56:35 <mikeplus64> hpc: i'm not sure but i think repa's delayed/function arrays may be able to do this
07:57:14 <hpc> mikeplus64: don't want a dependency just for that function
07:57:18 <hpc> ill write it myself i suppose
07:57:23 <hiptobecubic> hpc, http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector.html look at generate
07:58:05 <covi> I forgot 'the haskell way' after a while without any programming in haskell
07:58:11 <beaky> what's the best way to get the haskell platform on archlinux?
07:58:21 <hpc> @where platform
07:58:22 <lambdabot> http://hackage.haskell.org/platform/
07:58:23 <hpc> beaky: ^
07:58:30 <beaky> ah thx
07:58:33 <hiptobecubic> hpc, there's also unfoldr
07:59:07 <beaky> for my own distro, I get a 404 error :(
07:59:39 <hpc> hiptobecubic: doesn't return an array
07:59:46 <parcs`> beaky: all the HP packages build fine on linux. just install ghc and cabal and then install the HP locally
07:59:47 <hpc> and i need it to be two-dimensional
07:59:51 <beaky> alright
07:59:52 <hiptobecubic> hpc, in Data.Vector, not Data.List
07:59:58 <edsko> is there no cross-platform compatible way to turn a Socket into an Fd? there is socketToHandle, and the unix package provides handleToFd, but that's all I can find
08:00:00 <NotNotSure> hi
08:00:24 <EvanR1> fd is a cross platform concept? thanks windows
08:00:30 <mekeor> hi NotNotSure :)
08:00:40 * geekosaur is not sure that windows has the notion of sockets being related to fds, yeh
08:01:16 <edsko> hmmm, Network.Socket exports fdSocket :: Socket -> CInt
08:01:25 <ski> beaky : also iteration-through-recursion, no mutable variables (well, they exist, but are typically only used when really needed)
08:01:27 <NotNotSure> I know everybody here is into haskell. I notice it's very different from mainstream imperative languages. When I looked at sample computer science qualifying exams, I saw haskell questions, so basically functional programming is considered more advanced?
08:01:49 <EvanR1> functional is easier :(
08:02:20 <scopedTV> NotNotSure: I'd disagree.
08:02:20 <hiptobecubic> NotNotSure, it's just a different paradigm.
08:02:23 <parcs`> NotNotSure: how did you draw the conclusion?
08:02:25 <EvanR1> seems like people want things to be more complex so they have something to wrap their brain around
08:02:32 <EvanR1> 'its too simple' problem
08:02:41 <beaky> so Haskell is totally stateless?
08:02:53 <EvanR1> :t runState
08:02:54 <lambdabot> forall s a. State s a -> s -> (a, s)
08:03:04 <EvanR1> >:)
08:03:07 <beaky> oh
08:03:32 <hiptobecubic> beaky, it's just handled explicitly. you don't have the same notion of globally modifiable objects accessible from everywhere
08:03:46 <beaky> oh
08:04:44 <Saizan> NotNotSure: it's just less known
08:05:02 <ksf> why isn't there a simlpe pMapIO :: [IO a] -> IO [a]?
08:05:32 <Saizan> that's more like sequence, also i think there's a package with it on hackage
08:05:49 <ksf> @hoogle [IO a] -> IO [a]
08:05:49 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
08:05:50 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
08:05:50 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
08:06:15 <hiptobecubic> ksf, maybe with repa?
08:06:36 <ksf> that's a rather heavy dependency
08:06:50 <ksf> http://hackage.haskell.org/packages/archive/parallel-io/0.3.2/doc/html/Control-Concurrent-ParallelIO-Global.html
08:07:23 <Qtr> Is the key to monads just stop tp try to think what they *are* and just seee what they do? instead of saying they are *insert allegory* they are just something abstract that lets you chain computations together?
08:07:34 <ksf> indeed it is.
08:07:42 <hiptobecubic> Qtr, apparently
08:07:43 <ksf> see it as anything but an algebraic structure and you're lost.
08:07:58 <parcs`> ksf: i think there's something like that in base
08:07:59 <scopedTV> I've never understood the big fuss about "monads".
08:08:07 <ksf> unless, of course, you've got a concrete monad at hand, in that case think about the algebraic structure over whatever the monad does.
08:08:30 <hiptobecubic> Monads are like a chocolate freight train traveling backwards through space.
08:08:45 <EvanR1> lol
08:08:45 <merijn> Yampa and reactive-banana are still the state-of-the-art in FRP, right?
08:09:04 <hiptobecubic> with different kinds of 'freight' and through different kinds of 'space'
08:09:13 <ski> beaky : "so Haskell is totally stateless?" -- it's stateless in the sense that there's no implicit state in the evaluation model
08:09:14 <EvanR1> comonads are like nightclubs
08:09:24 <hiptobecubic> and maybe there are different kinds of 'trains', and also the chocolate is more like 'chocolate'
08:09:25 <knz> Qtr: I beg to disagree in the sense that a lot of people are still interested in *how things work* (not merely the fact that they do work)
08:09:29 <beaky> right
08:09:42 <ski> @quote no.state
08:09:42 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
08:10:00 * hackagebot imm 0.2.0.0 - RSS-to-maildir tool (koral)
08:10:07 <EvanR1> i wish there were no state
08:10:14 * EvanR1 hides from NARUS
08:10:14 <merijn> Qtr: tbh, if you can look at the >>= and return signatures and understand them, you pretty much understand monads
08:10:20 <hiptobecubic> Haskell is basically just for anarchists
08:10:28 <merijn> hiptobecubic: And hippies
08:10:37 <EvanR1> and gypsies
08:10:44 <byorgey> merijn: yes, and also netwire
08:10:56 <parcs`> ksf: never mind... but check out the new 'async' package
08:11:11 <EvanR1> :t (>>=)
08:11:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:11:18 <parcs`> pMapIO could be defined as mapM (aysnc >=> wait)
08:11:38 <beaky> how will HS make me a better programmer in other lanuages like C, C++, Java, C#, VB, ruby, python and others?
08:11:51 <ksf> first, I seem to need more stuff to compute.
08:11:56 <merijn> byorgey: Which one would you recommend as a first start in FRP?
08:12:04 <ksf> it's stable at ~210% no matter what I do.
08:12:09 <EvanR1> in ruby python perhaps you will think more carefully about the types you are using
08:12:11 <merijn> beaky: I think it improved my C at least
08:12:21 <EvanR1> in C java you will be frustrated with their type support
08:12:27 <ski> ksf : "how things work" is different from "what they *are*" :)
08:12:36 * merijn uses much more recursion and trees/linked lists in C nowadays
08:12:38 <knz> Cale shachaf roconnor_: FYI I asked wadler about bind vs. join, his answer is 2fold: 1) join was there first (as described in his 90 paper, "comprehending monads") and indeed easier to explain 2) bind came indeed to simplify the expression of I/O programs
08:12:48 <byorgey> merijn: reactive-banana, I think
08:12:56 <ksf> ski, "inherently parallel"
08:12:58 <merijn> byorgey: ok, thanks
08:13:00 <byorgey> though I'm not really that familiar with them
08:13:03 <roconnor_> knz: interesting
08:13:10 <ski> er ..
08:13:13 <hiptobecubic> beaky, you will stop randomly using IO and changing global variables in every single function so that when you have a bug you have some hope of figuring out where it is.
08:13:17 <ksf> but stuff just flies by too fast.
08:13:28 <ski> knz : the message i sent to ksf above was really meant for you
08:13:50 <ksf> ~60% idle time distributed over two cores.
08:14:20 <knz> ski: hmm
08:15:12 <knz> ski: there's a pedagogical question coming for you then: is there any hope to give confidence to someone about your explanation of how things work, unless you tell them either a) what they are or b) how to translate them to things where "what is" is clear?
08:15:46 <EvanR1> give examples
08:17:14 <knz> EvanR1: the main issue at hand is that people who build stuff to run (as opposed to people who use haskell "merely" to *think* better) want to understand the process in charge of executing their program
08:17:32 <knz> now executing a 1st order funciton is trivial, basically you just run the code
08:17:35 <EvanR1> give examples then expand them to see how they work
08:17:41 <Qtr> Not saying this is a good Monad but basically if i have a function can fail and if it fails i want to continue(so not the same as Maybe where success continues) I could do it with a moinad? maybe bad idea since i want to abort as soon as it succeeds but..,
08:17:43 <knz> well
08:17:55 <knz> but that's the challenge; the I/O monad is relatively trivial to expand
08:17:58 <knz> but most monads are not
08:18:26 <merijn> Qtr: Sounds like an alternative implementation of the "Either a" monad?
08:18:44 <byorgey> Qtr: yes, you can almost certainly do that with a monad.  However, in order for us to explain how you will have to be much more precise.
08:18:54 <EvanR1> knz: sounds like you want to explain how something works by saying 'dont worry about how it works, its a black box'
08:18:58 <EvanR1> which is a contradiction
08:18:58 <byorgey> if the function "fails" does it still give an output?
08:19:07 <byorgey> if not, what value do you want to use in order to "continue"?
08:19:18 <byorgey> and what does "failure" really mean in this context?
08:19:22 <knz> EvanR1: what do you mean? no that's not what I want :)
08:19:51 <EvanR1> i was just interpreting 'without' in your question to ski
08:20:11 <knz> ok
08:20:25 <knz> but I understood from ski's answer it's possible to look at how things work without looking at what they are
08:20:32 <knz> maybe I understood wrong
08:20:38 <knz> but what I understand I disagree with
08:21:02 <ski> Qtr : maybe you want `mplus' ?
08:21:35 <Qtr> could stuff like mapM and mapM_ have clear names?
08:21:52 <Qtr> @type (mplus)
08:21:54 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
08:22:16 <byorgey> knz: Qtr's question clearly linked the question of "what monads are" with the various analogies sometimes found in monad tutorials
08:22:20 <merijn> Qtr: It's just means "map in a Monad" and the _ is just convetion for monad functions that return "m ()" return than a value
08:22:31 <byorgey> in that sense it is certainly possible to look at how monads work without figuring out "what they are"
08:22:33 <ski> knz : well "what they are" is bordering on the philosophical, "how things work" can be more concrete (but also more accidental)
08:22:59 <byorgey> perhaps the issue here is what is meant by "what monads are"
08:23:06 <knz> ah
08:23:07 <knz> yes
08:23:09 <byorgey> if you just mean "what is their definition" then of course there is no problem
08:23:14 <ski> > Nothing `mplus` Just 3 `mplus` Just 4 `mplus` Nothing
08:23:15 <lambdabot>   Just 3
08:23:18 <byorgey> but I don't think that's what Qtr meant.
08:23:45 <EvanR1> burritos all the way down
08:23:49 <ski> Qtr : here the `Nothing' "failed", so it continued to the next part, `Just 3', which succeeded with `3', so it "aborted", not trying the rest `Just 4' and `Nothing'
08:23:54 <knz> I should have qualified: "what parts of the definition monads enables a program expressed using monad operations to actually have a behavior at run-time"
08:24:02 <ski> Qtr : are you looking for something in that vein ?
08:24:07 <knz> that's what I found most people I know want to knowa bout "what monads are"
08:24:28 <EvanR1> its a self perpetuating non-mystery
08:24:31 <ski> knz : that's more related to `IO' than to monads in general, i think
08:24:37 <EvanR1> its unknown because so many people claim to not know
08:24:48 <ksf> first impression of uuagc: you have to forward declare a lot, the code is a magnitude shorter and clearer than raw haskell, and the whole thing is going to end up as a mess, too.
08:25:02 <ski> ksf : heh
08:25:03 <EvanR1> as if a billion people proclaimed javascript arrays to be a total enigma
08:25:04 <ksf> the difference between uuagc-mess and normal mess being that the former stays extensible.
08:25:43 <knz> EvanR1: you'd be (unpleasantly) surprised...
08:25:50 <ksf> there's going to be definition of aspects all over the place, in no discernable order, but the good thing is that doesn't hurt composability at all.
08:26:37 <ksf> as comparison: I reordered my old mess, too, and it stayed a mess of state/writer/concatMap/Either/whatnot spaghetti code.
08:26:42 <hpaste> qrt pasted âqrt has monad problemsâ at http://hpaste.org/71940
08:27:42 <ski> Qtr : `Protectable' needs to accept a type parameter for it to be able to be a monad
08:27:45 <ksf> if you're already returning an either, and telling five types in nested tuples and maybes the code isn't going to become easier to modify, ever again.
08:28:11 <ksf> code, that is, that only a bookkeeper can love.
08:28:37 <ski> Qtr : something like `data Protectable a = Protected a | Unprotected a', maybe ?
08:28:45 <beaky> what's haskell's equivalent of nil, or NULL, or None, or whatever the most empty object is?
08:29:10 <EvanR1> () Nothing False [] empty
08:29:20 <ski> Qtr : hm, or rather `data Protectable a = Protected Int | Unprotected a', perhaps
08:29:30 <EvanR1> mzero mempty
08:29:38 <ksf> () is the most empty type, it only has one inhabitant.
08:29:42 <Qtr> ski: still get the same error
08:29:49 <ksf> Maybe is probably what you want, being Just something or Nothing.
08:29:54 <ksf> False is a bool.
08:30:13 <ksf> and lists are the same as Maybe except they hold an unbounded amount of stuff.
08:30:21 <EvanR1> beaky: all values are effectively the same as far as 'emptiness' goes, Nothing is not more empty than ()
08:30:43 <EvanR1> or []
08:30:44 <ski> beaky : there is no (detectable) empty value in each type. if you have a potentially failing computation, or a field in a datastructure which may be missing, you'd typically use `Nothing' in the `Maybe Foo' type, where `Foo' is the type of the real contents which may be there
08:30:44 <merijn> Technically the emptiest value/NULL would be undefined, wouldn't it?
08:30:58 <EvanR1> > undefined
08:30:59 <lambdabot>   *Exception: Prelude.undefined
08:31:03 <EvanR1> not a value
08:31:04 <ski> Qtr : even with my amendment ?
08:31:16 <Qtr> yes
08:31:16 <ksf> merijn, if we wouldn't be reasoning fast and loose, yes.
08:31:44 <ksf> there's uninhabited types with -XEmptyDataDecls, though.
08:31:45 <EvanR1> > undefined :: Void
08:31:46 <lambdabot>   Not in scope: type constructor or class `Void'
08:31:47 <ski> Qtr : what is the error message ?
08:32:08 <ksf> and newtype Void = Void Void is also, if you squint, uninhabited.
08:32:08 <ski> (merijn : hehe, i qualified with "detectable" :)
08:33:04 <hpaste> Qrt pasted âqrt has monad problems stillâ at http://hpaste.org/71941
08:33:04 <ski> beaky : btw, not having a `NULL'/`null' value in every (or almost every) type is considered a feature
08:33:47 <ski> Qtr : next time, please *annotate* the original paste with updates, using the "Annotate" button on the original paste page
08:34:01 <ski> Qtr : replace
08:34:04 <ski>   instance Monad (Protectable a) where
08:34:05 <ski> with
08:34:08 <ski>   instance Monad Protectable where
08:34:32 <ski> Qtr : and replace
08:34:34 <ski>   data Protectable a = Protected a | Unprotected a
08:34:35 <ski> with
08:34:37 <ski>   data Protectable a = Protected Int | Unprotected a
08:34:41 <ski> as i suggested before
08:34:59 <ski> (you can change `Int' to something else (not mentioning `a'), if you prefer)
08:35:01 * hackagebot kevin 0.1.5.2 - a dAmn  IRC proxy (JoelTaylor)
08:35:33 <otters> goodness me, hackagebot, why can't you display that character
08:35:37 <hpaste> qrt annotated âqrt has monad problems stillâ with âtype problem monadâ at http://hpaste.org/71941#a71942
08:35:54 <ski> beaky : were you wondering in general, or were you attempting to achieve some specific task ?
08:36:52 <beaky> was just wondering as I worked through LYAH
08:36:52 <ski> Qtr : also, when annotating, you can remove the parts that aren't new (unless the context of the new parts is not obvious) :)
08:37:04 <beaky> what's Haskell's killer app?
08:37:06 <ski> Qtr : anyway, please try the other suggestion i made above
08:37:23 <Qtr> beaky: darcs maybe?
08:37:24 <EvanR1> monadic parser combinators?
08:37:25 <merijn> beaky: xmonad?
08:37:33 <EvanR1> FRP?
08:37:41 <merijn> Also, compiler writing and concurrency are pretty neat
08:37:42 <EvanR1> school of expression?
08:37:49 <Qtr> ski: but if i dont want is as a specific type?
08:37:53 <mm_freak> beaky: concurrent programming
08:37:53 <EvanR1> fast webservers
08:38:37 <ski> Qtr : then `data Protectable nonSpecificType a = Protected nonSpecificType | Unprotected a', changing `instance Monad Protectable' to `instance Monad (Protectable nonSpecificType)'
08:38:58 <otters> probably parsec
08:39:12 <Nereid> Qtr: and then Protectable becomes Either
08:39:20 <mm_freak> beaky: i.e. highly scalable server programs, parallelizable, type-safe, etc.  it's actually fun to write concurrent servers in haskell (and erlang)â¦  in other languages it pisses you off (at least if you know how easy it is in haskell)
08:39:23 <ski> Qtr : and yes, you can rename `nonSpecificType' if you prefer :) (and the name in the `instance Monad ...' definition is unrelated to the name in the `data ...' one, they can be renamed independently of each other)
08:39:34 <ski> Nereid : we're going that way, yes :)
08:41:00 <Nereid> and I'm going the way of bed
08:41:21 <beaky> so compared to writing the web server in javscript or C++, working in Haskell lets you simply jump over those concurrency issues thanks to pure referential transparency?
08:41:50 <Nereid> beaky: and when your things aren't pure, haskell gives you powerful tools to deal with concurrency
08:42:27 <merijn> beaky: In haskell you'd simply use one thread per client and the runtime will use kqueue/epoll to multiplex those threads over a small set of OS threads
08:42:52 <GyorsCsiga> hey guys :) is the statement 'it is difficult to predict performance in haskell' true for all functional programming languages?
08:42:52 <ski> not really jump over them, but since mutable stuff are used much less in Haskell, concurrency becomes simpler
08:42:54 <merijn> beaky: Purity and lack of mutability means that writing threaded code without race conditions, etc. is easier too
08:43:23 <clsmith> GyorsCsiga: probably moreso for lazy languages than strict
08:43:30 <ski> GyorsCsiga : no, that's a result of non-strict evaluation
08:43:40 <GyorsCsiga> ah
08:43:45 <ski> GyorsCsiga : well, and higher-order operations, to some degree
08:43:59 <ski> (and the latter are also pretty common in other FPLs)
08:44:02 <GyorsCsiga> so then if you force strict evaluation we will always be able to predict performance?
08:44:29 <knz> GyorsCsiga: not either, because on top of the problems of non-stric evaluation you have data-dependent complexity
08:44:33 <clsmith> arguably you can't necessarily predict performance for any given turing-complete language...
08:44:37 <absence> is there a way to construct the "Infinite" value?
08:44:45 <Nereid> absence: what is the "Infinite" value?
08:44:47 <knz> whereby your performance is not predictable until you start your computation, by which time a prediction is too late :)
08:45:11 <ski> GyorsCsiga : well, you could always pretend Haskell is strict when evaluating performance. then you'd get an upper bound (the problem is that usually the upper bound is way much larger than the actual performance)
08:45:23 <absence> Nereid: the one returned by read "Infinity"
08:45:26 <ski> > 1 / 0  -- ?
08:45:27 <lambdabot>   Infinity
08:45:32 <Nereid> > read "Infinity"
08:45:33 <lambdabot>   *Exception: Prelude.read: no parse
08:45:38 <ski> > read "Infinity" :: Float
08:45:39 <lambdabot>   Infinity
08:45:47 <ski> > read "Infinity" == 1 / 0
08:45:49 <lambdabot>   True
08:45:49 <Nereid> > read "Infinity" :: [String]
08:45:50 <knz> ski: that's nearly a useless approach, since the assumption of strictness in hs gives you a WCET of infitinity
08:45:50 <lambdabot>   *Exception: Prelude.read: no parse
08:45:53 <knz> infinity
08:46:03 <ski> knz : "WCET" ?
08:46:09 <knz> worst case execution time
08:46:21 <Nereid> absence: read "Infinity" has type forall a. Read a => a
08:46:32 <ski> knz : sure. but it's what has been done, before "Purely Functional Data Structures" by Chris Okasaki
08:46:33 <Nereid> absence: the value depends on which type it's instantiated for
08:46:51 <absence> Nereid: yes
08:46:52 <clsmith> ski: but if there are any _|_s you're screwed i guess
08:46:55 <ski> knz : that book presents two models for reasoning about complexity in the presence of call-by-need
08:47:09 <Nereid> absence: so, which type?
08:47:16 <ski> clsmith : yeah, as well as infinite data structures :)
08:47:27 <hpaste> qrt annotated âqrt has monad problems stillâ with âqrt has monad problems still (annotation)â at http://hpaste.org/71941#a71943
08:47:40 <absence> Nereid: Double i guess
08:47:50 <Qtr> so trying to use my Protected but had to add a Num instance which doesnt work
08:47:50 <knz> ski: thx
08:47:57 <ski> knz : anyway, whether it's "WCET of infinity" depends on the specific case -- but often it'd be true, yes
08:48:07 <Nereid> Qtr: well yeah, you can't add a Protectable a with an a
08:48:13 <knz> ski: that's what I meant, yes
08:48:22 <absence> Nereid: or some other Fractional instance
08:48:29 <ski> knz : Okasaki also has a thesis by that name available on the web -- it includes the same things, but is less complete than the book
08:48:34 <ski> @where Okasaki
08:48:35 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
08:48:39 <Nereid> > 1/0 :: Rational
08:48:40 <lambdabot>   *Exception: Ratio.%: zero denominator
08:49:01 <absence> Nereid: i could always use 'let a = 1/0' or 'let a = read "Infinity"', but it seems clumsy
08:49:10 <Nereid> > read "Infinity" :: Rational
08:49:11 <lambdabot>   *Exception: Prelude.read: no parse
08:49:15 <knz> yeah I found it already
08:49:17 <knz> looking at it now
08:49:20 <ski> absence : define `infinity = 1 / 0' ?
08:49:30 <Nereid> @type 1/0
08:49:32 <lambdabot> forall t. (Fractional t) => t
08:49:51 <Nereid> > 1/0 :: Double
08:49:52 <lambdabot>   Infinity
08:49:53 <ski> maybe `RealFloat' or something ..
08:49:54 <Nereid> > 1/0 :: CReal
08:49:58 <lambdabot>   mueval-core: Time limit exceeded
08:50:01 <ski> @src RealFloat
08:50:01 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:50:14 <hpaste> timthelion pasted âlink errorsâ at http://hpaste.org/71944
08:50:15 <Nereid> > 1/0 :: Complex Double
08:50:16 <lambdabot>   NaN :+ NaN
08:50:32 <EvanR1> lovely
08:50:40 <ski> @src RealFrac
08:50:40 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
08:50:41 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
08:50:42 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
08:50:44 <hpaste> kiran pasted âData.Generics not foundâ at http://hpaste.org/71945
08:50:47 <ski> @src Floating
08:50:48 <lambdabot> class  (Fractional a) => Floating a  where
08:50:48 <lambdabot>     pi                                                      :: a
08:50:48 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
08:50:50 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
08:50:52 <lambdabot>     (**), logBase                                           :: a -> a -> a
08:50:55 <ski> hm, `Floating' i suppose i meant
08:51:17 <Nereid> > 0**(-1)
08:51:18 <lambdabot>   Infinity
08:51:18 <timthelion> so I'm trying to package a library, I cabal installed it, and when I use it I get those errors ...
08:51:23 <Nereid> > 0**(-1) :: Complex Double
08:51:25 <lambdabot>   NaN :+ NaN
08:51:26 <ski> > log 0
08:51:27 <lambdabot>   -Infinity
08:51:28 <Nereid> figures.
08:51:32 <ski> > log (-1)
08:51:33 <lambdabot>   NaN
08:51:34 <timthelion> any hints?
08:51:38 <ski> > log (-1) :: Complex Double
08:51:39 <lambdabot>   0.0 :+ (-3.141592653589793)
08:51:41 <Nereid> :)
08:52:00 <knkumar> why are there Data.Generics module search problems in ghc but not in ghci - http://hpaste.org/71945
08:52:09 <ski> Nereid : .. weren't you going to bed ?
08:52:10 <absence> i suppose infinity = 1 / 0 is viable, it just seems a bit strange. i don't want to divide anything after all, i just want an infinite value :)
08:52:14 <Nereid> yes bye
08:52:18 <ski> night, Nereid
08:52:21 <absence> but if there isn't a literal, there isn't
08:53:06 <Qtr> sseems iut cant drive Eq and Show?
08:53:19 <ski> absence : i suspect `infinity :: Floating f => f' could be an appropriate signature
08:53:29 <mm_freak> absence: reasonable, but i don't see a way to get at it without divisionâ¦  in fact i believe you have to encode the floating-point value yourselfâ¦  the machine insists on division as well
08:53:40 <ski> Qtr : on `Protectable' ? you should be able to
08:54:00 <ski> <Qtr> so trying to use my Protected but had to add a Num instance which doesnt work
08:54:05 <ski> Qtr : elaborate ?
08:54:20 <hpaste> qrt annotated âqrt has monad problems stillâ with âqrt has monad problems still (annotation)â at http://hpaste.org/71941#a71946
08:54:25 <mm_freak> absence: however, just define the value as a CAF, then it gets only computed once per process
08:54:44 <mm_freak> plusInf :: (Fractional a) => a
08:54:47 <mm_freak> plusInf = 1 / 0
08:55:19 <mm_freak> or better:  plusInf = recip 0
08:55:33 <mm_freak> similarly:  minusInf = recip (-0)
08:56:10 <ski> Qtr : jfyi, you know you can say
08:56:17 <ski>   Protected a + _ = Protected a
08:56:18 <ski>   ...
08:56:35 <ski>   Unprotected x >>= apply = apply x
08:56:37 <ski>   ...
08:56:37 <mm_freak> you may want to put RealFloat instead of Fractional to make sure that infinities actually exist in the given type
08:56:38 <ski> yes ?
08:56:46 <hpaste> qrt pasted âtypeclassesâ at http://hpaste.org/71947
08:57:27 <ski> mm_freak : "then it gets only computed once per process" -- with specialization
08:57:39 <mm_freak> ah, right
08:57:43 <Qtr> ski: im saying that, oh you posted before
08:58:20 <ski> you need
08:58:26 <ski>   test :: Num a => Protectable a -> Protectable a
08:58:31 <ski> or something more specific, like
08:58:34 <mm_freak> {-# SPECIALIZE plusInf :: Double #-}
08:58:36 <mm_freak> that should do it
08:58:39 <ski>   test :: Protectable Integer -> Protectable Integer
08:58:51 <ski> Qtr : because you're adding `1' to `r' there
08:59:15 <ski> Qtr : i didn't post anything, yet :)
09:00:03 <Obfuscate> absence: http://stackoverflow.com/questions/2354707/in-haskell-is-there-num-a-infinity-a#comment2332197_2354766
09:00:31 <ski> Qtr : i'm not sure why you're wanting to put `Protectable a' in `Num' ?
09:02:48 <ski> Qtr : also, i suggest changing `class Eq elem => Coll coll elem' to `class Eq elem => Coll coll elem | coll -> elem'
09:04:02 <Qtr> ski: so i could add
09:04:07 <hiptobecubic> What is a data type which is Floating but not Ord?
09:04:53 <merijn> hiptobecubic: Complex Floating? (wild ass guess)
09:05:34 <ski> Qtr : why do you need to add `Protectable a' things ? -- you don't need this for `test'
09:05:55 <ski> > (2 :+ 3) < (3 :+ 2)
09:05:55 <Qtr> i want to tryi fit works as intended
09:05:56 <lambdabot>   No instance for (GHC.Classes.Ord (Data.Complex.Complex t))
09:05:56 <lambdabot>    arising from ...
09:06:09 <hiptobecubic> indeed, ok.
09:06:24 <ski> Qtr : ok, then you need `instance Num a => Num (Protectable a)'
09:06:38 <knz> (although technically it is possible to define arbitrarily instances of Ord for complex numbers...)
09:06:46 <knz> (there's not a canonical one)
09:07:08 <ski> Qtr : because your `Unprotected (a + b)' tries to add two things of type `a', you need to assume that `a' also has numeric operations
09:07:37 <Qtr> class Eq elem => Coll coll elem | coll -> elem where // what does that mena really?
09:08:31 <ski> Qtr : the `coll -> elem' part is called a "Functional dependency", and it means that for each `coll' type, there can be at *most* one corresponding `elem' type with an instance `Coll coll elem'
09:08:39 * monochrom splits hair between "there is no canonical choice" and "there are 5 canonical choices" :)
09:08:46 <ski> Qtr : iow, each collection type can have at most one element type
09:09:21 <ski> Qtr : adding this will remove ambiguity about which element type you want to use, so that you don't have to litter your code with as many type ascriptions to disambiguate
09:09:54 <ski> monochrom : what if there's three canonical choices, and two non-canonical choices ? :)
09:10:06 <monochrom> haha
09:11:35 <hpaste> Qrt pasted âinstance problemsâ at http://hpaste.org/71950
09:11:39 <ski> Qtr : consider e.g. the code `insertTwo xs x0 x1 = insert (insert xs x0) x1' -- this will infer the constraints `(Coll coÄºl elem0,coll elem1)' with `xs :: coll',`x0 :: elem0',`x1 :: elem1'
09:12:11 <ski> Qtr : if you add the `coll -> elem' functional dependency (FD), it will realize that `elem0' and `elem1' has to be the same type (which is usually what you'd want here)
09:13:06 <ski> Qtr : you still forgot to change
09:13:07 <ski>   instance Num (Protectable a) where
09:13:08 <ski> into
09:13:12 <ski>   instance Num a => Num (Protectable a) where
09:13:17 <ski> (as i mentioned above)
09:13:44 <ski> Qtr : since in
09:13:46 <ski>   (+) (Unprotected a) (Unprotected b) = Unprotected (a + b)
09:13:51 <ski> (which can be written instead like
09:13:57 <ski>   Unprotected a + Unprotected b = Unprotected (a + b)
09:13:58 <ski> )
09:14:42 <ski> you're in `a + b' adding two elements of the type `a' in `Protectable a', you need to add the `Num a =>' part, to tell the system that you expect that the type `a' supports numeric operations
09:14:47 <ski> Qtr : ok ?
09:17:08 <hpaste> Qrt pasted âambigous type variableâ at http://hpaste.org/71951
09:18:29 <ski> Qtr : heh, you've changed your `r + 1' to `r + (Protected 1)', why ?
09:20:21 <Qtr> i didnt but thought i had to
09:20:35 <ski> you don't have to, no
09:20:43 <ski> (depending on what you want to achieve)
09:21:03 <EvanR1> hmmm ByteString or Vector of Word8 ?
09:21:03 <Qtr> anyway it doesnt work
09:21:08 <Qtr> i want to do r+1
09:21:36 <ski>   test :: Num a => Protectable a -> Protectable a
09:21:37 <ski>   test a = a >>= \r -> return (r + 1)
09:21:38 <ski> ?
09:21:41 <ski> try that ?
09:21:52 <ski> then something like
09:22:17 <ski>   *Main Control.Monad> test (Unprotected pi)
09:22:22 <ski>   *Main Control.Monad> test (Protected 42)
09:22:46 <beaky> would you guys recommend Haskell for a person new to programming?
09:22:58 <beaky> as a first programming language/
09:23:01 <Qtr> it isnt showable
09:23:01 <ski> i think, yes
09:23:29 <ski> Qtr : note that you must pass an argument to `test', as i did above
09:23:30 <hpc> beaky: i think it depends
09:23:46 <hpc> beaky: as a first programming language for say, a math PhD
09:23:46 <hpc> sure
09:23:51 <EvanR1> is there a function to convert four Word8 into a Word32
09:24:02 <Qtr> i dont need the Num for protected right?
09:24:18 <hpc> EvanR1: do it the same way as in C
09:24:45 <ski> Qtr : are you asking whether you need `instance Num a => Num (Protectable a) where ...' for the `test' versioni suggested above ?
09:24:48 <hpc> (0 .|. word1 << 8) .|. word2 << 8 ...
09:24:58 <EvanR1> alrighty then
09:25:05 <Qtr> yes
09:25:08 <ski> EvanR1,hpc : probably with `fromIntegral's in there
09:25:26 <ski> Qtr : right, you don't need that `Num' instance for that
09:25:53 <ski> Qtr : but if you (for whatever reason) want to try stuff like `r + Protected 1', then you *do* need it
09:28:57 <Qtr> no i need a show instance/why cant it be derived). this drives ma bit nuts
09:29:17 <applicative> beaky, you can learn haskell before learning another programming language; there is no problem.
09:29:43 <ski> Qtr : what *exact* thing are you trying which causes you to believe you need a `Show' instance ?
09:30:03 * hackagebot her-lexer 0.0 - A lexer for Haskell source code. (TimothyHobbs)
09:30:18 <ski> beaky : arguably, it might be easier to learn Haskell if you don't know any other programming language (due to not having to unlearn loads of stuff)
09:30:48 <applicative> beaky whether it is a good idea depends on your purpose.
09:31:33 <applicative> beaky what ski says has quite a bit of truth I think.  There is an old witticism about lisp like that that holds at least as true in this case.
09:31:42 <hpaste> Qrt pasted âshow and eq problemâ at http://hpaste.org/71952
09:32:44 <applicative> beaky: but on the other hand it is an 'eccentric' language so your larger purpose may matter. That it wont be harder for you than for anyone else is true though.
09:33:49 <ski> Qtr : as with `Num' above, `instance Eq (Protectable a)' needs to be `instance Eq a => Eq (Protectable a)', since you're comparing two values of type `a' in `(==) (Protected a) (Protected b) = a == b' and ` (==) (Unprotected a) (Unprotected b) = a == b'
09:34:50 <ski> Qtr : similarly with your `instance Show (Protectable a)', though i would advice against defining `show' in this way
09:35:30 <hiptobecubic> what is the purpose of Typeable in real code?
09:35:42 <Qtr> instance for (Show (Protectable a0 -> Protectable a0))
09:35:46 <ski> Qtr : because (imo), `Show' is for showing a value as a textual representation of a Haskell *expression* which evaluates to that value -- so :
09:35:49 <Qtr> somehow i have a function
09:35:56 <ski>   show (Protected a) = "Protected " ++ show a
09:36:09 <ski>   show (Unprotected a) = "Unprotected " ++ show a
09:36:11 <ski> would be better
09:36:24 <ski> (best would be to define it using `showsPrec', though)
09:36:39 <ski> <Qtr> instance for (Show (Protectable a0 -> Protectable a0))
09:37:02 <ski> Qtr : because you're trying to evaluate (and show) `test' itself in the interactor : don't
09:37:10 <ski> Qtr : instead, try
09:37:19 <ski>   *Main Control.Monad> test (Unprotected pi)
09:37:25 <ski>   *Main Control.Monad> test (Protected 42)
09:37:55 <Qtr> i see now
09:38:02 <ski> Qtr : `test' itself is a function, and they can't (normally) be shown -- you presumably want to call the function on various inputs, and inspect the corresponding outputs
09:38:53 <applicative> beaky this channel can help of course;  the going beginner's manual seems to be 'Learn You A Haskell'
09:38:57 <Qtr> this data of Mine, Protectable, is it Either you say?
09:39:04 <Qtr> no not really
09:39:13 <Qtr> maybe it is jsut a stupid data/monad
09:39:55 <ski> Qtr : it's more or less `Either'
09:40:11 <ski> and it's not a stupid monad, it's quite useful, at times
09:41:06 <Qtr> ok ty
09:43:37 <Qtr> so cant you get num without instance? like:
09:43:44 <Qtr> > (Just 5) + (Just 5)
09:43:45 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
09:43:45 <lambdabot>    arising from a use of...
09:43:57 <ion> > liftA2 (+) (Just 5) (Just 5)
09:43:58 <lambdabot>   Just 10
09:44:09 <ion> You could make a Num instance for applicatives that does liftA2.
09:44:26 <ion> and fromInteger = pure . fromInteger
09:44:31 <ion> or something
09:44:43 <Qtr> where is liftA2?
09:44:50 <ion> @hoogle liftA2
09:44:50 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
09:45:12 <Qtr> Int and Integer : difference?
09:45:43 <Qtr> and Applivative is like Monads in that it lets you chain computations together but in a different way?
09:45:46 <ion> Yes. Int shouldnât exist in Prelude. Itâs a fixed-size integer type of some varying size that may be less than 32 bits.
09:46:33 <ion> Applicative functors are a bit more powerful than functors and monads are a bit more powerful than applicative functors.
09:46:56 <EvanR1> > ord '0'
09:46:57 <lambdabot>   48
09:47:03 <ion> > (+42) <$> Just 8  -- Functor can do this
09:47:04 <lambdabot>   Just 50
09:47:12 <ion> > Just (+42) <*> Just 8  -- Applicative can do this
09:47:12 <lambdabot>   Just 50
09:47:14 <EvanR1> > chr (0+48)
09:47:15 <lambdabot>   '0'
09:47:18 <EvanR1> > chr (5+48)
09:47:19 <lambdabot>   '5'
09:47:38 <ski> Qtr : `Integer' (conceptually) contains *every* integer, `Int' just some of them.
09:47:46 <ion> > Just . (+42) =<< Just 8  -- Monad can do this
09:47:48 <lambdabot>   Just 50
09:47:58 <ski> Qtr : "and Applivative is like Monads in that it lets you chain computations together but in a different way?" -- basically, and vaguely, yes
09:48:33 <ski> > intToDigit 5  -- EvanR1
09:48:34 <lambdabot>   '5'
09:48:35 <jfischoff> Qtr: With Applicative a list of computations can't depend on each are all executed, with monad's one computation can affect the next, and you can short circuit and prevent further computations from occurring.
09:48:51 <ski> > intToDigit 14
09:48:52 <lambdabot>   'e'
09:48:55 <ski> > intToDigit 16
09:48:56 <lambdabot>   *Exception: Char.intToDigit: not a digit 16
09:49:02 <ion> > intToDigit 36  -- :-(
09:49:02 <lambdabot>   *Exception: Char.intToDigit: not a digit 36
09:49:32 <ion> whoops, i meant to say 35
09:49:33 <ski> yeah, arguably `intToDigit' ought to accept every integer from `0' to `35'
09:50:15 <ski> (if they have hexadecimal, why not pentadodecimal ?)
09:50:41 <ski> (er, pentatridecimal, i suppose)
09:51:29 <EvanR1> > intToDigit 10
09:51:31 <lambdabot>   'a'
09:51:40 <EvanR1> well shit i almost reinvented the whole function
09:51:50 * EvanR1 deletes ten lines of code
09:52:06 <ion> ten?
09:52:07 <Qtr> jfischoff: how can I shortcircuit? basically what i want is: if Nothing then continue else return Just Item
09:52:22 <EvanR1> approx
09:52:23 <clsmith> i find programming in haskell is mostly about reinventing things and then discovering them in Prelude
09:52:43 <EvanR1> did 0-9 together and then a-f separate
09:52:44 <jfischoff> Qtr: look at the source for the Maybe Monad instance
09:53:13 <ion> @type maybe  -- qtr
09:53:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:53:19 <jfischoff> hmm
09:53:31 <jfischoff> I misread what you said Qtr
09:53:48 <EvanR1> Qtr: maybe you really just want to go from [Maybe a] -> Maybe a, and stop on the first Just
09:54:08 <Qtr> EvanR: yes
09:54:11 <EvanR1> > mconcat (map First [Nothing, Nothing, Just 9, Just 3])
09:54:12 <lambdabot>   First {getFirst = Just 9}
09:54:21 <Qtr> so i cant chain Maybe because it continues with Just
09:54:26 <ion> @remember clsmith i find programming in haskell is mostly about reinventing things and then discovering them in Prelude
09:54:26 <lambdabot> Good to know.
09:54:46 <EvanR1> Qtr: the First monoid ;)
09:54:48 <ion> > Data.Foldable.foldMap First [Nothing, Nothing, Just 9, Just 3]
09:54:49 <lambdabot>   First {getFirst = Just 9}
09:54:53 <ion> > ala First Data.Foldable.foldMap [Nothing, Nothing, Just 9, Just 3]
09:54:54 <lambdabot>   Just 9
09:55:33 <jfischoff> > msum [Just "a", Just "b"]
09:55:34 <lambdabot>   Just "a"
09:55:48 <mcstar> ah, First, i simulated it with Either
09:55:55 <mcstar> Left some, Right ()
09:56:01 <EvanR1> > msum [Nothing, Just "a", Just "b"]
09:56:02 <lambdabot>   Just "a"
09:56:25 <EvanR1> goodbye python there aint more than one way to do it
09:56:28 <knz> anyone here familiar with ghc's porting process? or maybe a suggestion as to whom is?
09:56:57 <EvanR1> Maybe monadplus, First monoid, first foldable
09:57:00 <ski> Qtr : in your case, it stops at `Protected blah'
09:57:14 <DrSyzygy> ... so monadplus on Maybe a takes the first non-nothing?
09:57:20 <ski> yes
09:57:29 <ski> @src Maybe mplus
09:57:29 <lambdabot> Nothing `mplus` ys = ys
09:57:29 <lambdabot> xs      `mplus` ys = xs
09:57:48 <DrSyzygy> If I want the "obvious" mplus for Monoid a => Maybe a ? what should I do then?
09:57:53 <DrSyzygy> *just curious*
09:58:22 <ski> DrSyzygy : possibly you want to use edwardk's `Option', with `SemiGroup' instead of `Monoid' ?
09:58:38 <ski> edwardk ^
09:58:42 <edwardk> DrSyzygy: obvious in what way?
09:58:56 <DrSyzygy> edwardk: In that it delegates the monoidal operation to inside when possible?
09:59:16 <DrSyzygy> s/obvious/induced/
09:59:18 <EvanR1> > mconcat (map Last [Nothing, Just 3, Just 9, Nothing])
09:59:18 <edwardk> DrSyzygy: that is the monoid on Maybe, stupidly it assumes the inside is a Monoid because they didn't have a name for Semigroup
09:59:19 <lambdabot>   Last {getLast = Just 9}
09:59:29 <EvanR1> > mconcat (map Last [Nothing, Just 3, Nothing, Just 9, Nothing])
09:59:30 <lambdabot>   Last {getLast = Just 9}
09:59:36 <EvanR1> thats crazy
09:59:38 <ski> Qtr : "so i cant chain Maybe because it continues with Just" -- you can't chain it with `(>>=)', and have it do what you want .. you can either chain `Either blah'/`Protected' with `(>>=)', or you can chain `Maybe' with `mplus', though
09:59:40 <ion> foldMap == mconcat . map
09:59:40 <edwardk> DrSyzygy: instance Monoid m => Monoid (Maybe m) basically makes up a new unit for an existing monoid
09:59:45 <identity> @src Last
09:59:45 <lambdabot> Source not found. You type like i drive.
09:59:54 <identity> i don't get it :(
09:59:58 <identity> :info Last
10:00:01 <EvanR1> last looks at the entire list?
10:00:02 <edwardk> instance Semigroup m => Monoid (Option m) is in the semigroups package
10:00:06 <DrSyzygy> edwardk: OIC
10:00:10 <DrSyzygy> thanks!!
10:00:16 <ski> `Option ~= Maybe'
10:00:24 <DrSyzygy> but in a semigroupy way?
10:00:35 <DrSyzygy> @src Option
10:00:35 <lambdabot> Source not found. My pet ferret can type better than you!
10:00:45 <absence> mm_freak: thanks!
10:00:56 <absence> Obfuscate: any idea why that encodeFloat example is better?
10:01:06 <ski> DrSyzygy : new type because there already is an instance of `Monoid' for `Maybe m'
10:01:18 <ski> DrSyzygy : if that gets removed, `Option' could go away
10:01:38 <Qtr> EvanR1: isnt it "there should be preferrably one way to do it" or a mi misunderstanding you? you mean there really is only way?
10:01:55 <EvanR1> Qtr: the python motto is theres only one way to do it
10:02:29 <ion> âthere are zero to one ways to do itâ
10:02:32 <EvanR1> Qtr: weve been going through various ways to get what you want besides writing a custom monad / monoid / something else
10:02:38 <EvanR1> lol
10:02:40 <DrSyzygy> EvanR1: But that's clearly not true. :-P
10:02:55 <EvanR1> python makes me mad lets not discuss it
10:03:40 <Qtr> EvanR1: im pretty sure it is: "there should preferrably only be one way"
10:04:01 <mcstar> theres always a wrong way
10:04:37 <mcstar> and theres the highway
10:06:43 <ksf> uuagc is *not* meant to be a computational model, as it seems.
10:06:58 <EvanR1> only one way is the warcry of the fascist authoritarian religious leader
10:07:12 <ksf> seems left folds aren't really supported. at least not ones that need an initial value.
10:07:21 * monochrom rejects the motto
10:09:09 <monochrom> there are two problems
10:09:52 <PaulVisschers> are there isLeft and isRight functions?
10:10:00 <monochrom> on the problem-solving side: it makes easy things easier, but hard things harder or impossible
10:10:58 <otters> so quasiquotation returns the AST wrapped in Q, right?
10:11:51 <monochrom> on the language design side: you add restrictions to the language so as to reduce deviations. this makes the language rules complicated, full of exceptions and exceptions to exceptions, and non-uniform, unorthogonal
10:11:59 <otters> there's no way to just get the AST, is there?
10:12:10 <otters> because right now I have to build it by hand and it is NOT great
10:12:37 <monochrom> basic examples are python's still castrated lambda, and in early versions, lack of tenary expressions
10:12:56 <jfischoff> otters: if your writing your own have to first parse a string, then convert to the template haskell expression or pattern type or whatever else
10:13:11 <otters> jfischoff: the string is parsed
10:13:22 <osfameron> and then pythonistas whine that you're not taking their language seriously ;-)
10:13:24 <otters> I just want to be able to create an AST with [|...|] syntax
10:13:32 <mcstar> monochrom: what i dont understand wrt python, is why an earth, isnt a compilation unit a function?
10:13:33 <otters> without Q involved
10:13:48 <mcstar> on*
10:13:58 <jfischoff> otters: why is Q a problem?
10:14:01 <Qtr> lets say i dont want Ord for Unprotected < Protected but for Protected < Protected and sane for Unprotcted(maybe youd never want this) then how would you do it for Unprotctedt < Protected? exhausted patterns doesnt seem like a good idea and i cant use Maybe
10:14:21 <otters> jfischoff: because you can't break up your quoter into smaller functions that, say, all return a Dec
10:14:23 <EvanR1> "RealWorld is deeply magical. It is primitive, but it is not unlifted (hence ptrArg). We never manipulate values of type RealWorld; it's only used in the type system, to parameterise State#."
10:14:27 <otters> or an Expr
10:15:15 <otters> Exp*
10:15:34 <Saizan> you make them all return Q Exp?
10:15:40 <otters> I guess I could use do-notation
10:15:46 <Saizan> right
10:15:51 <otters> which isn't horrible, I spose
10:15:53 <otters> okay
10:16:27 <jfischoff> otters: Or just treat Q like IO and only have top level function in it
10:17:19 <Saizan> jfischoff: if you use [| .. |] you can't do that
10:17:23 <otters> yeah, that's my point
10:17:32 <jfischoff> oh now I understand
10:17:37 <otters> so I'll just use do notation
10:18:33 <otters> :pl \f x -> sequence $ concat $ mapM f x
10:18:38 <otters> @pl \f x -> sequence $ concat $ mapM f x
10:18:38 <lambdabot> ((sequence . join) .) . mapM
10:18:40 <otters> there we go
10:19:34 <ski> ksf : "uuagc is *not* meant to be a computational model, as it seems.","seems left folds aren't really supported. at least not ones that need an initial value." -- isn't there some state attribute threading ?
10:19:49 <ski> mcstar : "what i dont understand wrt python, is why an earth, isnt a compilation unit a function?" -- it's not obvious to me why it ought to be
10:20:44 <ski> Qtr : hm, so you don't want to order all the elements of `Protectable a' wrt each other ?
10:20:45 <mcstar> ski: because python is unable to optimize anything, because a single expression is not big enough
10:20:59 <DMcGill> :t (sequence . concat) .: mapM
10:21:00 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> [m a]) -> [a1] -> m [a]
10:21:06 <mcstar> if it could generate code for a function, on the other hand...
10:21:15 <ski> mcstar : i don't follow ..
10:21:21 <DMcGill> :t ((sequence . concat) . ) . mapM
10:21:22 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> [m a]) -> [a1] -> m [a]
10:21:29 <mcstar> ski: nvm, its not important
10:24:45 <knz> any clue where I could find an unregistered ghc for osx/x86-64?
10:24:53 <knz> or do I need to build my own?
10:27:27 <otters> in TH, can you generate a type signature without defining the corresponding function?
10:28:34 <Saizan> you can do the type with [t| .. |]
10:29:06 <otters> oh, neat
10:29:14 <EvanR1> why is import Foo not working sometimes in ghci
10:29:23 <EvanR1> i get to feedback and no loaded module
10:29:29 <EvanR1> no feedback
10:29:50 <ion> The âno feedbackâ thing has been fixed in HEAD AFAIR.
10:29:51 <geekosaur> knz, I expect you need to build your own.  but why would you need it?
10:30:04 <ion> Or was it already fixed in 7.4.2?
10:30:05 * hackagebot directory-tree 0.10.1 - A simple directory-like tree datatype, with useful IO functions (BrandonSimmons)
10:30:13 <EvanR1> well what am i doing wrong
10:30:23 <EvanR1> the module loads if i run ghci Foo.hs
10:30:29 <EvanR1> so i must be typing the command wrong
10:30:51 <Saizan> does Foo have a module Foo where header?
10:31:37 <b0fh_ua> Hi all! In file ModName.hs I defined data type and instance for Binary typeclass for the data. However when importing the module into another file I am getting the error: no instance for (Binary MyData) arisng from using decode.
10:31:40 <EvanR1> Saizan: yeah
10:31:41 <knz> geekosaur: performance comparison with another platform which doesn't have a reg implementation
10:31:50 <b0fh_ua> should I re-export typeclass implementation somehow?
10:32:03 <beaky> is haskell garbage-collected?
10:32:37 <EvanR1> beaky: yeah
10:32:39 <beaky> how does garbage collection work if I build native binaries using ghc?
10:33:01 <EvanR1> the runtime is bundled with the binary
10:33:17 <beaky> oh
10:33:30 <EvanR1> along with all the libraries
10:33:33 <EvanR1> oyu use
10:33:41 <beaky> and ghc makes code almost as fast as C++ right?
10:33:52 <EvanR1> heh g++ build times
10:33:55 <latro`a> that depends on a lot of stuff
10:37:37 <beaky> isn't OCaml that other language that's almost as fast as C++?
10:37:57 <mcstar> no, thats C
10:39:47 <MostAwesomeDude> Clearly you're all thinking of Python. :3
10:40:07 <knz> beaky: natively compiled ml code is pretty fast yes, although you probably need a quite decent ml programmer to compete performance-wise with a decent  C programmer
10:40:31 <DMcGill> no, that's fortran
10:40:42 <knz> (nb: any naive ml/haskell programmer probably competes easily performance-wise with a naive c programmer)
10:40:46 <mcstar> no, fortran is clearly superior
10:41:02 <mcstar> knz: thats totally untrue
10:41:13 <knz> oh?
10:41:30 <Qtr> https://john-millikin.com/articles/monad-is-not-difficult/
10:41:34 <Qtr> i dont get the state thingÂ¨
10:41:39 <mcstar> a naiv haskeller would abandon haskell because he/she wouldnt understand why the hell is his code soo slow/eats too much memory
10:41:39 <Qtr> put and get
10:42:02 <ion> qtr: This may or may not be helpful: http://heh.fi/state-monad
10:42:24 <MostAwesomeDude> Qtr: Do you understand the type of State? State s a = s -> (a, s)
10:43:09 <knz> mcstar: ok, maybe not fully naive then
10:43:34 <knz> but that level of naiveness would make a c programmer throw up their hands in the air at segfaults
10:43:40 <knz> so well
10:44:24 <MostAwesomeDude> Qtr: I just demonstrated State to a coworker by having him derive (>>=), get, put, and modify. It was very instructive but arduous.
10:45:02 <merijn> MostAwesomeDude: Should've turned it into a blogpost and saved everyone some time when people need to see it
10:45:15 <mcstar> huh, i imagined, that chinese mine-workers proove monad laws among themselves in lunch break
10:45:58 <MostAwesomeDude> merijn: Well, that link of ion's appears to do so.
10:46:07 <Qtr> MostAwesomeDude: it is a function
10:46:09 <MostAwesomeDude> I might write it up at some point in the near future.
10:46:09 <Qtr> contains
10:46:19 <EvanR1> mcstar: naive haskellers code wouldnt eat too much memory, it would crash because of a stack overflow
10:46:31 <mcstar> EvanR1: right
10:46:40 <EvanR1> er ran out of 'normal' amount of stack memory
10:48:20 <b0fh_ua> Hi all! In file ModName.hs I defined data type and instance for Binary typeclass for the data. However when importing the module into another file I am getting the error: no instance for (Binary MyData) arisng from using decode. How do I export instances of typeclasses?
10:50:05 <mm_freak> b0fh_ua: could you paste the code?
10:50:14 <applicative> you don't have to b0fh_ua
10:50:23 <mm_freak> b0fh_ua: because instances get exported automaticallyâ¦  in fact you can't prevent this
10:50:32 <b0fh_ua> interesting
10:50:55 <applicative> b0fh_ua: something else is wrong
10:52:00 <b0fh_ua> okay, the type and class definition is taken from another cabal module
10:52:33 <hpaste> qrt pasted âfrustration with Stateâ at http://hpaste.org/71956
10:52:45 <Qtr> i think return is correct but it doesnt work
10:52:54 <b0fh_ua> so perhaps I need to tune cabal file somehow in order to export things? I just checked - if directly load haskell file in ghci - I am able to use encode/decode from Binary
10:53:04 <b0fh_ua> if I load it from installed module - I can't do that
10:53:13 <Qtr> return st = put st in my mind but obv wrong
10:53:43 <ion> return isnât supposed to change the state, itâs just supposed to result in the given value without side effects.
10:55:13 <Qtr> so it retusn (st, ()) ?
10:55:18 <Qtr> i dont get it at all
10:55:21 <MostAwesomeDude> return's type would be return :: a -> s -> (a, s)
10:55:29 <MostAwesomeDude> return a s = (a, s)
10:56:05 <MostAwesomeDude> Figure it out for unwrapped State first before looking at wrapped State.
10:56:33 <b0fh_ua> perhaps I misuse cabal
10:56:50 <Qtr> how do i even do Monad for something unwrapped?
10:56:59 <applicative>   return x = State $ \s -> (s,x)
10:57:12 <HairyDude> Qtr: "State" is not a monad. "State st" is a monad for given st.
10:58:00 <applicative> you can't write a monad instance directly for type State s a = s -> (s,a)  for good or ill
10:58:20 <HairyDude> applicative: well, you can, but it's probably not the monad you want :)
10:58:40 <applicative> HairyDude: did I make a mistake writing the type?
10:59:26 <HairyDude> applicative: ... ah, no, ignore me, I'm wrong
10:59:47 * HairyDude shuts up to avoid confusing the newbie
11:00:28 <applicative> Qtr you can define your own return, bind and >> for the unwrapped 'true' state type , and even use do notation, if you use noimplicitprelude etc
11:08:29 <Qtr> return x = State (\s -> (s,x))
11:08:29 <Qtr>          (>>=) (State f) v = State (\st -> (st, f v))
11:08:32 <Qtr> qhSBHqswdshvbsgdhbfh
11:08:44 <Qtr> return works but noit bind
11:09:20 <copumpkin> you're passing the state through unchanged
11:09:23 <copumpkin> that doesn't seem right :)
11:09:46 <copumpkin> describe what it should do in words :)
11:10:10 <Qtr> it should a state and return (oldstate, newstate)
11:10:20 <Qtr> it should take a state and return (oldstate, newstate)
11:10:22 <copumpkin> huh :)
11:10:51 <copumpkin> no it shouldn't
11:12:01 <knz> should return (value, newstate)
11:12:02 <copumpkin> xs >>= f should 1) run the xs action with your initial state 2) take the return value of that, and pass it into f, getting a new state action 3) take the _new_ state from (1) and pass it in as the state for the action computed in (2)
11:12:47 <copumpkin> there should be three distinct states you deal with, and two output values
11:13:37 <Qtr> but the xs action is my syate!?
11:14:53 <ski> the `xs' is your `State f'
11:15:07 <copumpkin> @djinn (s -> (s, a)) -> (a -> (s -> (s, b)) -> (s -> (s, b))
11:15:08 <lambdabot> Cannot parse command
11:15:16 <copumpkin> @djinn (s -> (s, a)) -> (a -> (s -> (s, b))) -> (s -> (s, b))
11:15:16 <lambdabot> f a b c =
11:15:16 <lambdabot>     case a c of
11:15:16 <lambdabot>     (d, e) -> b e d
11:15:44 <Qtr> so how can xs be ana ction and a state?
11:15:51 <copumpkin> xs isn't a state
11:15:55 <copumpkin> it's a state action
11:17:28 <Qtr> so how do i run it without input?
11:17:42 <b0fh_ua> Hi again! Can somebody please take a look at this question: http://tinyurl.com/cj423oy ?
11:17:53 <copumpkin> Qtr: State s a -> (a -> State s b) -> State s b
11:17:59 <copumpkin> you're returning a new state action
11:18:19 <ski> Qtr : after `=' you write an action `State (\s0 -> ..s0..)', which will get the input `s0' when later executed
11:21:09 <Qtr> (>>=) (State s) f = State (\a -> f a)
11:21:14 <hpaste> Deech pasted âCont List Iteratorâ at http://hpaste.org/71958
11:21:21 <deech> Can someone help me debug the above following ContT based list iterator? The expected output is: "1\n2\n3\nnil" but I just get "nil".
11:21:25 <Qtr> ouldn't match expected type `(st, b)'
11:21:25 <Qtr>                 with actual type `State st b'
11:21:46 <ski> Qtr : closer
11:22:19 <ski> Qtr : however, your `a' there is the initial state, you need to pass it to `s', not to `f'
11:22:28 <hpc> Qtr: hint: in that definition, s is a function
11:23:08 <JoeyA> b0fh_ua: I think that's a known issue: http://hackage.haskell.org/trac/ghc/ticket/4832
11:23:27 <JoeyA> And I think GHC 7.4.2 cleaned up module imports in GHCi.
11:23:32 <Qtr> (>>=) (State sf) f = State (\a -> sf a) // so how do I do with f?
11:23:32 <ski> Qtr : maybe you could rename your `s' to `f', and `f' to `g' ?
11:23:37 <ski> ok
11:23:54 <ski> Qtr : now, `sf' has type 's -> (s,a)'
11:24:25 <ski> Qtr : so `sf a' has type `(s,a)' -- it contains the result `a' of the the first action, together with the next state
11:24:52 <ski> Qtr : first, i'll assume you rename `a' to `s0`, as in :
11:24:54 <b0fh_ua> JoeyA: well, it doesn't work if built with cabal as well
11:25:05 <ski>   State sf >>= f = State (\s0 -> sf s0)
11:25:07 <JoeyA> deech: In Haskell, when you say () -> K a, you might as well say K a.
11:25:17 <b0fh_ua> I mean if I create a module which uses that TestBinary.Test - I will get same error
11:25:27 <ski> Qtr : then, you can use `let (s1,a) = sf s0 in ...' in there instead
11:25:52 <JoeyA> b0fh_ua: Are you compiling with ghc-options: -Wall ?
11:25:59 <JoeyA> Maybe you have some orphan instances.
11:26:05 <ski> Qtr : so `s1' is then the next version of the state, and `a' is the result of the first action, iow the intermediate result which needs to be passed on
11:26:11 <ski> Qtr : ok ?
11:26:50 <Qtr> not ok
11:27:45 <Qtr> why is s1 to the left
11:27:54 <JoeyA> b0fh_ua: Hmm, looks like you don't have an orphan instance.  It's just a simple little module.
11:28:04 <ski> because you defined it as
11:28:05 <ski>   data State st a = State (st -> (st, a))
11:28:07 <ski> instead of
11:28:10 <ski>   data State st a = State (st -> (a, st))
11:28:21 <deech> JoeyA: I only do that because "k" is of type (a -> m r)
11:28:24 <JoeyA> b0fh_ua: You mean you can get the instance error without even touching ghci?
11:28:31 <ski> either would work, but you of course have to be consistent
11:29:12 <b0fh_ua> JoeyA: yes, with ghc
11:29:25 <Qtr> next version of the state, and `a' is the result of the first action, //arent those the same?
11:30:44 <Qtr> ok i dont get it, can you show me maybe i can figure it out
11:30:53 <Qtr> (back in 10)
11:32:04 <JoeyA> Hmm, is there a ghc-pkg command to print all packages having module Foo?
11:32:33 <JoeyA> b0fh_ua: ghc-pkg list | grep -i binary
11:32:41 <geekosaur> ghc-pkg find-module Foo
11:32:59 <JoeyA> thanks
11:33:03 <JoeyA> b0fh_ua: Actually, ghc-pkg find-module Data.Binary
11:33:24 <b0fh_ua> JoeyA: https://gist.github.com/3160624
11:33:28 <b0fh_ua> that's the sample file
11:33:32 <ski> Qtr : no, consider e.g. `randomInt :: State StdGen Int', where the input state is a random number generator state, and the result is an `Int' computed from that, while the output state is the "next" random number generator state, which can then be used later to generate more random numbers
11:33:44 <b0fh_ua> JoeyA: ghc --make 1.hs gives same error as GHCI
11:34:06 <hpc> b0fh_ua: try renaming it "one.hs"?
11:34:09 <JoeyA> Maybe ghc-binary and binary are two different (perhaps identical) packages.
11:34:20 * hpc hasn't read the gist
11:34:25 <JoeyA> I'm looking at the dependencies of the package.
11:34:27 <geekosaur> at one point ghc had its own private version of binary, yeh
11:34:37 <geekosaur> dunno if it's still needed/used
11:34:40 <JoeyA> I think there are two things called "Binary" floating around.
11:35:07 <b0fh_ua> JoeyA: binary-0.5.1.0 and ghc-binary-0.5.0.2
11:35:11 <JoeyA> b0fh_ua: I think if you change "ghc-binary" to "binary" in your cabal file, it'll work.
11:35:13 <JoeyA> Bingo.
11:35:22 <b0fh_ua> hpc: why?
11:35:40 <hpc> oh, just read up, ignore me
11:36:09 <b0fh_ua> ok, let me try
11:39:56 <JoeyA> deech: "return (ContT (\k -> K ([x],k))) >> "
11:40:10 <JoeyA> return x >> m is equivalent to m
11:40:40 <JoeyA> Unless you're using a monad that doesn't obey the monadic laws.
11:41:15 <JoeyA> deech: So looking at: data K a = Nil | K (a,() -> K a)
11:41:34 <JoeyA> It is equivalent to: data K a = Nil | K (a, K a)
11:42:20 <JoeyA> Thus, K a is isomorphic to [a].  You might as well say [a] instead of K a.
11:42:22 <copumpkin> which is roughly equivalent to Nil | K a (K a)
11:42:28 <JoeyA> Not what you meant, I suspect.
11:43:06 <b0fh_ua> JoeyA: seems it worked
11:43:09 <b0fh_ua> let me double-check
11:43:20 <JoeyA> Hurray, I'm useful!
11:43:43 <mcstar> i dont understand
11:43:58 <b0fh_ua> JoeyA: great :) many thanks!
11:44:41 <mcstar> if i have a ModuleName.hs file with a module in it, why cant i use it directly from ghci?
11:45:00 <mcstar> i.e why cant i import it?
11:45:08 <JoeyA> You mean import ModuleName?
11:45:11 <mcstar> yes
11:45:11 <JoeyA> I'm pretty sure you can...
11:45:14 <mcstar> no
11:45:18 <mcstar> thats what ive been testing
11:45:30 <mcstar> thats one reason b0fh_ua cant load his module too
11:45:32 <JoeyA> You need to say "module ModuleName where" at the top, though
11:45:37 <mcstar> ofc
11:45:55 <JoeyA> mcstar: The issue was a clash between the binary and ghc-binary packages.
11:45:55 <mcstar> JoeyA: i can compile a main.hs with ghc
11:46:13 <mcstar> but i cant load the module with 'import ModuleName'
11:46:17 <mcstar> via ghci
11:46:23 <mcstar> and, theres the -i flag
11:46:34 <mcstar> i dont think its working
11:47:35 <ksf> mcstar, that's because it's not named in a way that ghc would understand.
11:47:45 <mcstar> ghc understands it
11:47:47 <mcstar> ghci doesnt
11:48:00 <ksf> modules named not like their decl says are always main modules.
11:48:11 <ksf> mcstar, ghc wouldn't understand you either if you tried to import it.
11:48:21 <mcstar> hm?
11:48:30 <mcstar> theres a main.hs, that imports Module
11:48:42 <ksf> if a module isn't locatable by path, the only chance is to give its name at the command line.
11:49:07 <mcstar> no, i dont need to give its path, if its in the same dir as my main.hs
11:49:28 <ksf> in that case you're probably bitten by a stray .o file
11:49:43 <ksf> (at least you should check that before anything else)
11:49:51 <ksf> that is, rm Module.o
11:50:12 <mcstar> even if it didnt work before i compiled anything?
11:50:16 <mcstar> now come on..
11:50:24 <ksf> nah, unlikely.
11:50:27 <Qtr> ski: i get the random nbr gen but i dont see how to compute
11:50:50 <ksf> can you paste the exact error?
11:51:23 * ksf never had problems with :m
11:51:41 <ski> Qtr : let's consider `foo >>= bar', in your state monad, with `foo :: State st a' and `var :: a -> State st b'
11:52:04 <hpaste> mcstar pasted âwtfâ at http://hpaste.org/71961
11:52:12 <ski> Qtr : the computation starts with someone sending an initial state value `st0' of type `st' to the whole `foo >>= bar'
11:52:42 <ski> Qtr : then it's your job to : (a) pass this initial state `st0' to `foo', getting a new state `st1' back, as well as a result of type `a'
11:53:12 <ski> Qtr : then (b) pass the result `a' to `bar :: a -> State st b', getting a new action of type `State st b'
11:53:37 <ski> Qtr : then (c) pass the current state `st1' to this action, getting a new state `st2', and a result `b'
11:53:59 <ski> Qtr : finally (d) return this new state `st2' and `b' from the action `foo >>= bar' which you're defining
11:54:03 <ski> Qtr : is that clear ?
11:54:50 <Qtr> pass it to foo >>= bar? i thought foo >>= bar already contained it
11:55:17 <ski> no, `foo' as well as `foo >>= bar' are state *transformers*
11:55:25 <ski> they don't contain states, they *transform* them
11:56:23 <ski> if you have `foo >>= bar', then someone will use this state transformer by doing `let State f = foo >>= bar; (finalState,result) = f initialState in ...'
11:56:54 <ski> or, if you define a `runState', they could say `let (finalState,result) = runState (foo >>= bar) initialState in ...'
11:57:06 <ski> Qtr : in any case, when you write
11:57:09 <mcstar> ksf: have you looked at it?
11:57:23 <ski>   State sf >>= bar = State (\st0 -> ...)
11:57:42 <ski> then the `st0' will get a value whenever someone provides `initialState' as above
11:58:12 <ski> Qtr : you, as the writer of `(>>=)' doesn't have to worry about where `st0' comes from, you just have to accept that someone will later provide it
11:58:23 <ksf> oh, you already did.
11:58:34 <ski> Qtr : your job is to determine what `(>>=)' should do, after `st0' already has been passed
11:58:42 <ski> iow, your job is to fill in the `...' in
11:58:44 <ski>   State sf >>= bar = State (\st0 -> ...)
11:58:47 <ksf> mcstar, :m +Mod
11:58:51 <ski> Qtr : ok ?
11:59:12 <mcstar> ksf: same, import can be used in ghci
12:00:19 <hpaste> Qrt pasted âSTate #%Â¤%"&â at http://hpaste.org/71963
12:01:25 <ksf> mcstar, either something is utterly broken, or noone has enough information to fix the problem.
12:01:28 <ski> Qtr : note that saying `s1 = (\a -> f a)' is the same as saying `s1 = f'
12:01:43 <ksf> and with noone I mean both you and us
12:02:00 <ski> Qtr : i think you want something like
12:02:13 <mcstar> ksf: if you do it, does it work for you?
12:02:17 <ski>   State sf >>= bar = State (\st0 -> let (st1,a) = sf st0 in ...)
12:02:28 <ksf> as in "propably it's something so obvious that it's undetectable"
12:02:29 <mcstar> ksf: i think thats the way i did these things before, and they worked...
12:03:41 <mcstar> ski: can i hijack you for a minute?
12:03:42 <ksf> hmmm no it doesn't.
12:03:51 <ksf> the way I've been doing things is giving the command line.
12:03:56 <ksf> *the module on
12:04:12 <mcstar> ski: if you wrote a simple modules, and wanted to try it out in ghci, what would you do?
12:04:34 <mcstar> ksf: like: ghci Mod.hs ?
12:04:47 <ksf> tab completition doesn't show it, so it's probably an import path issue
12:04:50 <ksf> mcstar, exactly
12:05:23 <mcstar> ksf: what do you think the ghci '-i' flag is good for?
12:05:45 <otters> okay, time to clarify this once and for all
12:05:57 <mcstar> otters: at last, ty
12:06:31 <otters> are [| ... |] typechecked when declared or when spliced?
12:06:49 <scooty-puff> are there any good examples of uses of Data.Distributive?
12:08:09 <ski> otters : i suspect the latter
12:08:18 <otters> what I want to do
12:08:30 <ski> otters : the former is true in systems like MetaML and MetaOCaml
12:08:37 <otters> is create a type signature that refers to a function called "route" and has a type [Text] -> Method -> HandlerResponse
12:08:39 <mcstar> ksf: :add adds a module file, makes it importable
12:08:42 <otters> but I can't just do
12:08:43 <ski> mcstar : load it into GHCi ?
12:08:49 <mcstar> ski: yes
12:08:54 <otters> [d| route :: [Text] -> Method -> HandlerResponse |]
12:09:08 <otters> and then splice that, because "route" is a type signature without a definition
12:09:15 <ski> mcstar : if you're already inside GHCi, there's also `:l' (`:load'), and `:r' (`:reload')
12:09:24 <mcstar> ski: i know, that loads files
12:09:25 <otters> so instead what I have to do is return $ SigD (mkName "route") (...)
12:09:36 <mcstar> ski: i want to import my modules just like my system modules
12:09:36 <otters> or sigD ...
12:10:18 <otters> is there any way to refer to names that may not be defined yet within quasiquotatinos?
12:10:22 <otters> quasiquotations
12:10:26 <Qtr> ski: ok i just dont get it
12:11:20 <ski> Qtr : did you understand my suggestion
12:11:21 <ski>   State sf >>= bar = State (\st0 -> let (st1,a) = sf st0 in ...)
12:11:22 <ski> ?
12:12:00 <ski> here `State sf :: State st a' is the first action (a state transformer)
12:12:02 <Qtr> not completely
12:12:05 <Qtr> (>>=) (State f) g = State (\st0 -> let (st1, a1) = f st0 in
12:12:05 <Qtr>                                             let (st2, a2) = g a1 in
12:12:18 <ski> and `sf :: st -> (st,a)' is the actual state-transformer function inside of that
12:12:19 <Qtr> not sure what to do with it
12:12:32 <ski> Qtr : that's getting closer
12:12:38 <applicative> Qtr is this dumb labeling any use?  http://hpaste.org/71965  I think it's right
12:13:09 <applicative> I take it thats how you manage the state.
12:13:17 <ski> Qtr : note that `g :: a1 -> State st a2', so 'g a1 :: State st a2' is correct
12:13:46 <ski> Qtr : but then you have to unpack that into a second state-transformer function of type `st -> (st,a2)'
12:14:04 <ski> Qtr : i.e. you need something like `let State h = g a1 in ...' there
12:15:37 <otters> guess I'll just write the AST myself
12:16:43 <srhb> There's no such thing as "reopening stdin" -- is there?
12:17:06 <geekosaur> not in general
12:17:21 <srhb> Right.
12:17:28 <geekosaur> you can't rewind a tty or a pipe, after all
12:17:51 <applicative> ml-ers are crowing, "Haskellers caught wishing for first-class modules"
12:17:54 <geekosaur> (there are probably Windows equivalents although I don't know if they get associated with Handle abstractions)
12:18:09 <ski> applicative : hehe, we've been doing that for a long long time :)
12:18:33 <applicative> I thought Haskellers had been caught wishing for them from the beginning
12:18:41 <geekosaur> what, they haven't seen the first class records mess?  (some variants of which do turn out to be first class modules...)
12:18:49 <geekosaur> yep
12:19:25 <applicative> geekosaur: its a crossposting from the r/haskell foolishness to /r/ocaml  http://www.reddit.com/r/ocaml/comments/wwhts/haskellers_caught_wishing_for_firstclass_modules/
12:19:35 <geekosaur> awww
12:19:44 <applicative> just a few remarks all well spirited in fact
12:19:54 <geekosaur> ah
12:20:07 * geekosaur doesn't do much reddit, mostly because it often seems to not be "well spirited"
12:20:08 * hackagebot comonad 3.0.0.1 - Haskell 98 compatible comonads (EdwardKmett)
12:21:06 <applicative> geekosaur: yeah, r/haskell is tolerable, but I wish some similar function could be moved out of there. I  guess the thought was it might attract more readers thatway
12:21:36 <Qtr> can you writw the whole function?
12:21:48 <jmcarthur> this is silly. we could have been doing the same thing to them the whole time
12:21:48 <mcstar> why is a first class modules such a great thing?
12:21:49 * ski . o O ( "What ails or ales one thing is clear, Spirits are not served here." )
12:21:55 <jmcarthur> gadts, for example
12:22:11 <Qtr> what do i do woith the intermediate result?
12:22:17 <ski> mcstar : module functors are more imporant than first-class modules, imo
12:22:34 <jmcarthur> oh i just read it. it's not so bad
12:23:02 <mcstar> let me rephrase, why do you need anything that current modules to solve namespacing?
12:23:12 <mcstar> than*
12:23:21 <ski> mcstar : "anything than" ?
12:23:35 <mcstar> yes
12:23:36 <Qtr> whats a first class kodule?
12:23:36 <jmcarthur> other than?
12:23:39 <Qtr> module
12:23:41 <geekosaur> anything other than, presumably
12:23:42 <applicative> !
12:23:46 <mcstar> erm
12:23:47 <mcstar> yes
12:24:20 <ski> mcstar : you e.g. would like to parameterize a module on the implementation of priority-queue, or byte-string, or ... that is used in the module
12:24:57 <ski> mcstar : you shouldn't have to change the module (an `import' declaration) to change which implementation of some ADT you are using
12:24:59 <jmcarthur> first class modules in ocaml basically give you existential types
12:25:10 * hackagebot constraints 0.3.2 - Constraint manipulation (EdwardKmett)
12:25:22 <ski> first-class modules are more powerful than plain module functors, but can be nice too
12:25:29 <jmcarthur> so, actually, i don't think first class modules buy you much
12:25:49 <jmcarthur> if you already have existentials, at least
12:25:58 <ski> jmcarthur : with first-class modules, you can pass statically-typecheck code over the network as in Alice ML
12:26:20 <ski> jmcarthur : yes, you can simulate it with existentials, but it's a bit clumsy
12:27:02 <jmcarthur> i feel like first class modules are basically a clumsy way to encode existentials, but since i don't know how your example works i'm in a bad position to make an argument anymore
12:27:36 <Sabadoooooo> http://%6d%65%61%74%73%70%69%6e%2e%63%6f%6d
12:28:16 <ski> (.. that was fast)
12:28:25 <mcstar> ski: should i imagine this like this: import ParameterizedModule<AnotherModuleThatOuterModuleUsesForSpecificStuff> ?
12:28:44 <jmcarthur> eh... something like that
12:28:52 <mcstar> :)
12:29:00 <ski> mcstar : e.g., yes. also `module Foo Bar' where 'Bar' is a module parameter
12:29:06 <jmcarthur> that's basically it, but i don't feel like it looks very motivating like that
12:29:18 <srhb> So, if my program reads input from stdin with hGetContents, I cannot ever send text commands to it from the same terminal?
12:29:24 <mcstar> jmcarthur: i like long descriptive names
12:29:30 <mcstar> (no i dont)
12:29:47 <ski> srhb : the text commands will end up in the `String' that `hGetContents' get, yes
12:29:53 <srhb> ski: Yeah..
12:30:53 <ski> srhb : and in any case, afaiui, you shouldn't really be `hClose'ing a handle that you've passed to `hGetContents', except as an efficiency optimization
12:31:20 <ski> (the handle is already conceptually closed, it's just that the closing hasn't happened yet)
12:31:37 <Qtr> ski: can you show the whole function?
12:31:58 <srhb> ski: Right, got it that far, I'm just watching my (poor) program design go down the drain. :-)
12:32:58 <mcstar> ski: why cant the same be achieved with a HOF?
12:33:51 <ski>   State sf >>= k = State (\st0 -> let (st1,a) = sf st0
12:33:55 <mcstar> like, a have a smart record constructor, that takes a parameter, and parameterizes the modules's functions with that parameter, which is a function, and provides the implementation for specific stuff
12:34:01 <ski>                                       State sg = k a
12:34:13 <ski>                                       (st2,b) = sg st1
12:34:21 <ski>                                    in (st2,b)        )
12:34:27 <mcstar> @where hpaste
12:34:28 <lambdabot> http://hpaste.org/
12:34:29 <ski> Qtr : something like that ?
12:35:36 <ski> mcstar : it can, but it's clumsy encoding with existentials
12:35:52 <Qtr> so I got it working but cant say i really understand it
12:36:16 <Qtr> @hoogle StdGen
12:36:17 <lambdabot> System.Random data StdGen
12:36:17 <lambdabot> System.Random getStdGen :: IO StdGen
12:36:17 <lambdabot> System.Random mkStdGen :: Int -> StdGen
12:38:12 <Qtr> then i dont get hopw to use it and how to use put and get and what ehy do
12:40:13 <Qtr> get is a complete mystery to me
12:40:20 <Qtr> https://john-millikin.com/articles/monad-is-not-difficult/
12:41:31 <ski> mcstar : see the messages in the thread "Is overloading a good thing?" in the newgroup comp.lang.functiona by Neelakantan Krishnaswami in 2002-07-14 at <http://groups.google.com/group/comp.lang.functional/msg/ac9ec53dd11e97a2> and Adrian Hey in 2002-07-17 at <http://groups.google.com/group/comp.lang.functional/msg/22ea87a1cb8abfb8>
12:41:34 <latro`a> it may help a bit to look at the type signature of >>=, specialized to State
12:41:40 <MostAwesomeDude> ^^
12:41:45 <latro`a> State s a -> (a -> State s b) -> State s b
12:41:50 <MostAwesomeDude> Qtr: get :: State s s
12:41:56 <latro`a> note that the second argument takes an a
12:42:05 <latro`a> but what if we want to fiddle with an s?
12:42:40 <latro`a> but if the first argument to bind is get, we have a signature
12:42:49 <latro`a> State s s -> (s -> State s b) -> State s b
12:43:26 <ski> > (`runState` 0) $ do x <- get; put (x + 10); y <- get; put (x + y + 2); return (x,y)  -- Qtr, an example use
12:43:27 <lambdabot>   ((0,10),12)
12:44:33 <ski> > (`runState` 0) $ get >>= \x -> put (x + 10) >> get >>= \y -> put (x + y + 2) >> return (x,y)  -- the same thing, with explicit `(>>=)' calls
12:44:35 <lambdabot>   ((0,10),12)
12:44:55 <latro`a> I think that may be a little bit involved for a first example
12:44:58 <Qtr> but i cant use get? it creates a function onÃ¶y, how would i use it?
12:45:08 <ski> Qtr : you use it with `(>>=)'
12:45:20 <otters> > (`runState` 0) $ put 3
12:45:22 <lambdabot>   ((),3)
12:45:23 <latro`a> or implicit (>>=) in do notation, if preferred
12:45:38 <Qtr> test = get >>= put     compiles
12:45:40 <otters> > (`runState` 3) $ get >>= \x -> put (x + 3)
12:45:42 <lambdabot>   ((),6)
12:45:44 <otters> there we go
12:45:46 <otters> that's more simple
12:45:48 <otters> simpler
12:45:57 <ski>   *Main Prelude> let State sf = get >>= \x -> put (2 * x)  in  sf 12
12:46:01 <ski> Qtr : try that ^
12:46:07 <ski> Qtr : if you define
12:46:17 <ski>   runState (State sf) st = sf st
12:46:19 <ski> you can then say
12:46:31 <ski>   *Main Prelude> runState (get >>= \x -> put (2 * x)) 12
12:47:32 <Qtr> i still dont get get
12:47:45 <Qtr> it creates an inital dummmy state?
12:48:09 <Botje> it takes a state and returns the state
12:48:10 <ski> each state transformer action will (a) accept any starting state; (b) somehow transform that into (b0) a new state; and (b1) a result value
12:48:16 <mauke> 'get' gets the current state
12:48:16 <Botje> it also leaves the state unchanged.
12:48:31 <ski> Qtr : in the case of `get', the state isn't changed, the "output" state is the same as the "input state"
12:48:45 <ski> Qtr : further, the "result value" is also the same as the "input state"
12:49:10 <ski> the "result value" is what users of `(>>=)' weill get in `x' when they do `get >>= \x -> ...'
12:49:58 <ski> Qtr : so `get' *both* keeps the state the same, not changing it, *and* presents that state as the "result value", so it can easily be inspected, using `(>>=)' as just above
12:50:40 <luft> hi
12:51:10 <luft> this is a really dumb question, but is there any major difference between the Maybe monad and IO Monad?
12:51:17 <latro`a> ....yes
12:51:35 <edwardk> luft: yes
12:51:36 <mauke> luft: do they have anything in common?
12:51:51 <mm_freak> mauke: yes, exceptions
12:52:00 <mauke> NO EXCEPTIONS
12:52:03 <latro`a> but that's about it
12:52:12 <luft> mauke: they have the basic monadic operations in common
12:52:14 <latro`a> and IO catches them, too, or at least can
12:52:17 <latro`a> um
12:52:21 <latro`a> not the same ones
12:52:23 <mauke> luft: that's ... 'return' and '>>='
12:52:25 <mauke> so not much
12:52:32 <mm_freak> well, i think for both monads the exception stuff isn't really part of it
12:53:02 <latro`a> depends on whether you consider returning Nothing to be an exception or an absence
12:53:20 <ski> both
12:53:20 <mm_freak> it is an exception, but within the monadic framework you can't have Nothing
12:53:57 <mm_freak> (cheating aside, because there is 'fail')
12:54:15 <latro`a> erm, sure you can? your a -> Maybe b can return Nothing
12:54:22 * ski . o O ( `mzero :: MonadZero m => m a' )
12:54:24 <latro`a> you don't need fail to get Nothing out of a Maybe computation
12:54:40 <mm_freak> latro`a: try constructing a Nothing using only 'return' and '>>='
12:54:44 <E0F> Hi, I have searched for it on my own but I can't find an answer.
12:55:10 <latro`a> that's true, but that's restricting matters trivially
12:55:17 <E0F> Is there a location documenting the LLVM backend optimisation flags and their anwers ?
12:55:20 <latro`a> er, to the point of triviality
12:55:24 <E0F> sorry if it's a noob question
12:55:42 * ski idly ponders the point of triviality
12:55:52 <mm_freak> E0F: see the GHC manual
12:56:14 <mm_freak> E0F: http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
12:56:26 <E0F> mm_freak: I've had a look at it but I couldn't find a list of flags with their effect
12:56:30 * ski has that URL burnt into memory
12:56:37 <E0F> or it wasn"t exhaustive maybe
12:56:58 <mm_freak> in that case you'll probably have to read the source code =)
12:57:18 <E0F> yay, so much fun :)
12:57:32 <ski> Happy Happy Joy Joy.
12:57:34 <mcstar> ski: thanks for the links
12:57:40 <ski> yw
12:57:41 <E0F> Be sure I'll share the doc if I manage to do so, I'm a Haskell newcomer
12:58:21 <ski> E0F : you might want to stay in here then, idle, and sometimes try to read what other people are talking about
12:59:33 <E0F> ski: Actually, I read the flags people used on the computer language shootout. But I'd like to have some solid info about the flags semantic. For instance, does the -optc-ffast-math affect the llvm backend ?
13:00:09 * ski has no idea, sorry :/
13:00:38 <E0F> I was assuming it was using GHC
13:00:46 <mm_freak> E0F: sometimes a simple experiment can provide the answer much fasterâ¦  if you notice a speed difference, then the flag matters
13:02:28 <Qtr> can someone show me how to use StdGen with my State?
13:03:35 <mcstar> E0F: -optc, so i guess not (pass option to the C compiler)
13:03:40 <E0F> mm_freak: well, I'm unsing haskell for solving problems of the Euler project (as a motivation to learn the language) and it's really hard to say if a difference is significative or only due to statistical fluctuations
13:04:17 <mm_freak> E0F: the PE problems are designed in a way such that a proper solution never takes long enough to compute that you might care about optimization =)
13:04:31 <E0F> mcstar: I told myself the same actually, but I've seen a page on the wiki where somebody compiled a snippet with the llvm backend and multiple -optc flags, so I was just wondering
13:04:49 <mcstar> E0F: can you link that?
13:04:58 <mm_freak> in any case GHC produces such good code that you rarely would care about some extra performance
13:05:01 <E0F> mm_freak: yup I've read that on the home page, that's why I said that
13:05:10 <E0F> mcstar: just a second please
13:05:44 <E0F> mm_freak: yeah, clearly, I was really amazed by the performance of the zipWith implementation of the fibonacci sequence with ghc 7.4.2 and llvm 3.1
13:06:17 <mcstar> fibonacci is a really bad benchmark
13:06:27 <mcstar> you measure gmp performance
13:06:30 <mcstar> not haskell's
13:08:01 <Qtr> t = get >>= \x -> put (x * 2) >>= \r -> put (r * 4) // why does nthet last >>= \r break things?
13:08:09 <Qtr> i thought i could chain forever
13:08:36 <mm_freak> Qtr: check the type of 'put' and (>>=)
13:08:46 <mm_freak> put :: s -> State s ()
13:09:03 <mm_freak> so:  (put >>=) :: (() -> State s b) -> State s b
13:09:30 <mm_freak> now i suspect 's' to be something like Integer
13:09:31 <E0F> mcstar: http://www.haskell.org/haskellwiki/Shootout/Fasta please look at point 3 'a new proposal'
13:09:45 <mm_freak> so (r :: ()) * (4 :: Integer)
13:09:55 <mm_freak> which is a type error, because (*) expects both arguments to have the same type
13:10:05 <mm_freak> (*) :: (Num a) => a -> a -> a
13:10:15 <ion> instance Num ()
13:10:17 <E0F> it may be outdated but it's still the first search result for "ghc llvm optc-ffast-math"
13:10:43 <mm_freak> ion: still type error
13:11:23 <ion> Ah, i was only looking at Qtrâs line.
13:11:32 <mcstar> E0F: i dont think -optc flags have relevance if llvm is used
13:11:43 <mcstar> you can diff the 2 binaries to if theres a difference though
13:11:45 <latro`a> in short you don't >>= after a put, instead you >>, which ignores the (null) result value, and then if you want to directly mess with the state again you need to get again
13:11:49 <mcstar> to see*
13:12:29 <E0F> mcstar: good idea, gonna try this out
13:12:34 <mcstar> E0F: just like bare -O3 is nothing more than -O2
13:12:53 <E0F> is O2 really more than -O ?
13:13:00 <mauke> yes
13:15:36 <Qtr> t = get >>= \x -> put (x * 2) >> \r -> put (r * 4) // not woking either
13:15:45 <Qtr> :t (>>)
13:15:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:15:48 <Qtr> :t (>>=)
13:15:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:15:59 <EvanR> >> doesnt take a function
13:16:11 <EvanR> you have >> \r ->
13:17:20 <mcstar> how can i match certain words with regex?
13:17:43 <mcstar> test<space>word<space>test
13:17:48 <mcstar> text*
13:17:53 <mm_freak> i think \b matches word boundaries
13:18:03 <EvanR> word `elem` words text
13:18:32 <mcstar> this is grep, not haskell :)
13:18:53 <mcstar> mm_freak: i think it worked, ty
13:19:01 <mcstar> \bword\b
13:19:10 <Qtr> so what does >> take, i must pass on the state somehow
13:19:29 <mm_freak> Qtr: again, see the type of 'put'
13:19:36 <mm_freak> put :: s -> State s ()
13:19:43 <mm_freak> the result is not the state, but ()
13:20:57 <hpaste> E0F pasted âoptc-ffast-math and llvmâ at http://hpaste.org/71966
13:21:16 <Qtr> so im back to being clueless
13:21:21 <EvanR> Qtr: you can still refer to x in you expression
13:21:23 <E0F> yum bot, just did that
13:21:28 <Qtr> so hwat is get for? jsut some inittÂ´state?
13:21:34 <E0F> mcstar: the two binaries are different
13:21:42 <EvanR> but it will be outdated so nevermind
13:21:52 <mcstar> E0F: yes, though it is not conclusive
13:21:55 <mcstar> :)
13:21:59 <E0F> indeed
13:22:00 <mcstar> it has *some* effect
13:22:08 <E0F> indeed^2
13:22:17 <mm_freak> Qtr: 'get' retrieves the /current/ state
13:22:19 <Qtr> yes but i want the enw state not overwritew the old
13:22:48 <mm_freak> Qtr: get >>= \x -> put y >> more
13:22:48 <Qtr> but ic ant just do get out of context
13:22:59 <Qtr> it just creates a new start-state?
13:23:07 <mm_freak> Qtr: in 'more' x is still the original state, but another 'get' would retrieve the current state, which is y
13:23:34 <Qtr> ok that works but i dont see how
13:23:35 <EvanR> Qtr: puts creates a new state, get doesnt
13:23:39 <Qtr> yeah in the monad
13:28:13 <Qtr> how would i use StdGen with STate?
13:28:20 <EvanR> put doesnt return the new state because presumably you have it already
13:28:26 <mm_freak> Qtr: when you say "get >>= \x -> â¦", then 'x' does not refer to the current stateâ¦  it refers to the state it was at that point
13:28:44 <ion> qtr: The page i linked to you happens to contain an example.
13:28:52 <Qtr> link?
13:29:00 <mm_freak> Qtr: getRandom :: (Random a, RandomGen g) => State g a
13:29:07 <ion> qtr: http://heh.fi/state-monad
13:29:07 <mm_freak> getRandom = state random
13:29:19 <EvanR> theres also the Random monad which is the same thing
13:29:35 <mm_freak> EvanR: the same thing as â¦?
13:29:47 <EvanR> RandomGen g => State g
13:30:19 <mm_freak> huh?
13:30:39 <EvanR> :|
13:30:44 <mm_freak> MonadRandom is about monads having a random number generator, not about state monads
13:30:58 <mm_freak> IO is a MonadRandom, but not a MonadState
13:31:18 <EvanR> MonadRandom is a class i was talking about the specific monad
13:31:34 <EvanR> can be implemented with State
13:31:47 <EvanR> like in all the old monad tutorials
13:31:49 <hpaste> E0F pasted âtime_diffâ at http://hpaste.org/71967
13:32:39 <E0F> mcstar: here it is, with some voluntarily poor implementation of pb5. The timing diff isn't that significant
13:33:36 <mcstar> indeed
13:36:05 <beaky> hello
13:36:29 <Qtr> No instance for (RandomGen Integer
13:36:38 <Qtr> what does that mean? add an instance decl
13:37:11 <mauke> that's like a quarter of an error message
13:37:17 <mroman> :t RandomGen
13:37:19 <lambdabot> Not in scope: data constructor `RandomGen'
13:37:30 <mroman> @instances RandomGen
13:37:31 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
13:37:43 <mroman> @instances-importing RandomGen
13:37:44 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
13:38:14 <latro`a> an integer isn't a generator; generators are an abstract type
13:38:20 <mroman> Qtr: There is only RandomGen StdGen
13:38:22 <Qtr> @hoogle randomR
13:38:23 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:38:23 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
13:38:23 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
13:38:44 <mroman> you can't use Functions from RandomGen on Integers.
13:39:26 <mroman> at least not without declaring your own instance.
13:40:45 <mm_freak> latro`a: it's actually a detail that Integer is not a generator
13:41:17 <mm_freak> you can easily define a good RandomGen instance for Integer
13:41:18 <latro`a> no, it's a detail that Integer is not a first argument to mkStdGen
13:41:23 <mcstar> E0F: why the 'pb' prefix?
13:41:35 <mm_freak> latro`a: StdGen is /a/ RandomGen
13:41:39 <mm_freak> Integer can very well be another
13:41:54 <latro`a> oh I see what you're saying nvm
13:41:59 <beaky> on average, how much slower is haskell compared to C++
13:42:00 <latro`a> but you'd have to implement the whole thing
13:42:03 <Qtr> goodnight,ty
13:42:14 <latro`a> beaky--I'm not sure such an average makes sense
13:42:29 <mauke> beaky: Haskell and C++ have no speed. they're languages.
13:42:32 <Ralith> beaky: on average, how much slower is seventeen compared to calculus?
13:42:44 <E0F> mcstar: for "problem", that's just a naming pattern I've adopted
13:43:03 <beaky> right
13:43:10 <beaky> I should compare implementations instead
13:43:41 <geekosaur> also specific tasks
13:43:56 <EvanR> beaky: language benchmark game
13:44:57 <geekosaur> like, benchmarks are often worthless because performance often has a sensitive dependency on details of the actual task, including not only the code but the data.  (like, mostly sorted data causes some sort algorithms to go faster and others much slower...)
13:45:01 <mm_freak> latro`a: yes, you do in general have to implement the whole thing, because half a house is probably not a good thing to be living in =)
13:45:21 <latro`a> you know what I meant :p
13:45:30 <beaky> right
13:45:53 <mm_freak> latro`a: actually no, but nevermind =)
13:46:01 <beaky> maybe those tasks on the benchmark games favor C implementations over Haskell, whereas for some other tasks, functional languages take the cake
13:46:17 <E0F> well, somebody mentionned the fact that fib wasn't a good benchmark because it benchmarked gmp instead of ghc, but it is worth noting that the zipWith implementation I used is much much faster than the naÃ¯ve recursive definition of the fibonacci sequence
13:46:23 <mm_freak> beaky: GHC produces efficient enough code for most purposes
13:46:25 <beaky> ghc code is quite fast tho
13:46:46 <E0F> so I think GHC and LLVM optimisations are really great on that
13:47:00 <latro`a> E0F that's comparing apples to oranges: the asymptotic complexities of the algorithms are different
13:47:05 <beaky> as long as Haskell maintains programmer productivity due to the expressiveness and power of the language, the libraries, etc.
13:47:14 <mm_freak> E0F: no, the reason is that the asymptotic complexity of the recursive one is very bad
13:47:18 <E0F> latro`a: really ? I thought it was the same actually
13:47:24 <latro`a> definitely not
13:47:34 <mm_freak> E0F: not anywhere near the same =)
13:47:40 <latro`a> the memoized version is O(n), the non-memoized version is O(fib(n)) which is exponential
13:47:44 <E0F> yeah I didn't take the time to compute the asymptotic complexity of both algorithms
13:48:13 <E0F> thank you for this useful piece of information :)
13:48:13 <jfischoff> does anyone know how partial lenses fit into lens-family?
13:48:20 <latro`a> both are pretty straightforward to compute: the memoized version adds n numbers, the non-memoized version adds 1's fib(n) times
13:48:41 <mcstar> E0F: erm
13:48:57 <mcstar> E0F: lazyness and sharing makes that fast
13:49:08 <mcstar> it is basically becomes like the iterative algorithm
13:49:10 <E0F> I tought the zipWith implementation was just syntactic sugar for an underlying recursion
13:49:13 <E0F> shame on me
13:49:22 <mcstar> and you measure ghc'c thunking speed and gmp ofc
13:49:37 <latro`a> it's recursive, but it's memoized nonetheless
13:50:04 <latro`a> once, say, the 500,000th element of the list is computed, it's done, no more recursion to compute it
13:50:15 <mm_freak> actually there is no memoization going on in the zipWith variant
13:50:23 <mm_freak> it's simple sharing and GC at work
13:50:28 <latro`a> eh, true
13:50:35 <latro`a> similar idea algorithmically, though
13:50:50 <latro`a> once fib(n) is computed, fib(n+m) doesn't need to compute it again
13:51:22 <mcstar> still, a strict tail recursive version would beat that
13:51:31 <E0F> Yeah that's why memoization rocks
13:51:34 <mcstar> i think i benchmarked quite a lot of implementations one time
13:51:43 <mm_freak> this is not how the zipWith variant works
13:51:48 <latro`a> oh?
13:52:02 <mauke> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 5 :: Expr
13:52:02 <mm_freak> the zipWith variant really does just this:
13:52:03 <lambdabot>   1 + 1 + 1 + (1 + 1) + (1 + 1 + 1)
13:52:20 <mm_freak> > fix (\r x y -> x : r y (x + y)) 0 1
13:52:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:52:39 <mm_freak> it has a shift register with two places and shifts and shifts
13:52:57 <mm_freak> using zipWith3 you could implement the same thing for three variables
13:53:05 <mauke> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib x
13:53:09 <lambdabot>   mueval-core: Time limit exceeded
13:53:33 <mm_freak> memoization is really a form of caching, not sharing
13:53:54 <mcstar> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 5 :: Expr
13:53:55 <lambdabot>   1 + 1 + 1 + (1 + 1) + (1 + 1 + 1)
13:54:05 <mcstar> :(
13:54:08 <E0F> memoization is keeping in memory the previously computed values for further computations I thinkk
13:54:22 <latro`a> keeping in memory and using, yeah
13:54:29 <mm_freak> E0F: explicitly
13:54:37 <latro`a> I don't think the distinction you're making is quite as sharp as you think, though
13:54:42 <mm_freak> memoization says, "i'll need this value later again, keep it"
13:54:50 <mcstar> but here, you are just making a list, you dont evaluate fib function at a memoized point
13:54:59 <mm_freak> sharing says, "i need this value twice, so compute it only once"
13:55:07 <mm_freak> s/so/but/
13:55:15 <latro`a> mcstar: that's a semantic point when you then go off and define fib n = fibs !! n
13:55:23 <mm_freak> memoization is an explicit abstraction
13:55:27 <mm_freak> sharing is implicit
13:55:36 <mcstar> yes, i like that
13:55:48 <mcstar> you nowhere say: memoize this value
13:56:05 <mm_freak> in fact sharing is semantics, while memoization is a caching library
13:56:32 <latro`a> an algorithmic perspective doesn't make that distinction, I don't think
13:56:38 <E0F> ok, and why would a tail-recursive implementation beat the zipWith one ?
13:56:40 <latro`a> I see what you mean, though
13:56:57 <mm_freak> latro`a: view it this way:  memoizing ten values takes O(n) space
13:57:02 <mm_freak> sharing /saves/ space
13:57:14 <mm_freak> s/ten/n/
13:57:51 * E0F thinks he really needs to switch to computer science
13:57:53 <mm_freak> E0F: it probably won't beat the zipWith version
13:58:19 <otters> my lambdabot is broken
13:58:24 <mm_freak> there is no tail-recursive formula for computing all fibonacci numbers, but one for computing a particular one
13:58:29 <otters> whenever I try to pl it uses 100% CPU and returns nothing
13:58:30 <mcstar> mm_freak: well, maybe it will, think about allocations
13:58:34 <companion_cube> my lambdabot is full of eels
13:58:52 <otters> :pl \a b c -> fmap fst $ g a b c
13:58:57 <otters> @pl \a b c -> fmap fst $ g a b c
13:58:57 <mm_freak> mcstar: the code i've seen so far calculates the /list/ of all fibonacci numbers
13:58:57 <lambdabot> ((fmap fst .) .) . g
13:59:00 <otters> and then I forget to use @
13:59:08 <mm_freak> a tail-recurive algorithm will beat this:  fibs !! n
13:59:10 <E0F> mm_freak: I'm gonna have a deeper look at tail recursion
13:59:19 <mcstar> mm_freak: yes
14:00:05 <mm_freak> even then the TCO variant is unlikely to beat the list, because of deforestation
14:00:21 <mm_freak> the list is compiled away
14:00:38 <mcstar> but list elements must be boxed
14:00:48 <mcstar> function parameters arent
14:00:57 <mcstar> erm, not arent
14:00:57 <jfischoff> roconnor: can one make partial lenses with lens-family?
14:01:45 <jfischoff> roconnor_: ^^
14:04:28 <roconnor_> jfischoff: in theory, but it isn't implemented yet
14:04:36 <roconnor_> jfischoff: is that something you would like?
14:04:42 <ddarius> Any Haskell events happening on the west coast between 5 Aug and 10 Aug?
14:04:57 <jfischoff> roconnor_: yes is there any way I could help with that?
14:05:20 <roconnor_> jfischoff: how soon do you need it?
14:05:40 <beaky> what does the $ operator do?
14:05:42 <curveater> A little musical break: http://www.youtube.com/watch?v=MfVz17wSUD4&feature=youtu.be   or  www.myspace.com/4smartfeminity
14:05:47 <jfischoff> roconnor_: its not pressing.
14:05:51 <ddarius> beaky: Nothing. ($) = id (almost)
14:06:07 <E0F> OK, tail recursion is great, I should look for exercises about that and try to practice
14:06:13 <roconnor_> jfischoff: I could throw together a darcs branch pretty quickly
14:06:17 <beaky> I thought it associated stuff
14:06:33 <beaky> like f $ a b = f (a b)
14:06:46 <ddarius> beaky: No.  It's just a user-defined operator like all the others, so it follows the same syntactical rules as them.
14:06:50 <hiptobecubic> @src ($)
14:06:50 <lambdabot> f $ x = f x
14:06:55 <jfischoff> roconnor_: that would be great.
14:07:01 <ddarius> beaky: 3 + f x is also 3 + (f x)
14:07:08 <beaky> right
14:07:15 <jfischoff> roconnor_: just let me know. For now I'll make Getter's only
14:07:24 <jfischoff> which is fine
14:09:27 <mcstar> i wonder if anyone gets kicked out, who pastes a link as a first message
14:09:40 <mauke> extremely unlikely
14:09:58 <mcstar> then, how does the no-spam kicking works?
14:10:01 <ddarius> beaky: There is a very subtle difference between ($) and (id :: (a -> b) -> a -> b) which you probably don't care about it.
14:10:06 <mauke> mcstar: what no-spam kicking?
14:10:27 <mcstar> oh, it left the chat
14:10:35 <mauke> uh
14:10:40 <hiptobecubic> :t id
14:10:41 <lambdabot> forall a. a -> a
14:10:52 <mcstar> mauke: no, it was killed, or i dont nuderstand something
14:10:59 <mauke> mcstar: it was killed
14:11:03 <ddarius> mcstar: curveater was K-lined most likely because this isn't the only channel s/he posted the link in.
14:11:39 <mcstar> its just weird, that the link just shows, and the person is kicked right away
14:11:53 <mauke> they weren't kicked
14:12:11 <mcstar> i sorry, i am not familiar with the terminology
14:12:14 <mcstar> killed then
14:12:21 <mauke> the issue is concepts, not terminology
14:12:22 <otters> is there any type that's an instance of Monad but not Functor?
14:12:39 <mcstar> mauke: can you shed some light on the concept then, pls?
14:12:41 <mm_freak> otters: practically yes
14:12:46 <mm_freak> otters: conceptually no
14:12:48 <mauke> a kick removes a nick from a channel
14:12:55 <mauke> a kill disconnects them from the network
14:13:09 <mcstar> ok
14:13:09 <mauke> i.e. what you saw wasn't channel specific
14:13:16 <otters> mm_freak: example?
14:13:17 <E0F> and a ban prevents them from accessing the channel
14:13:18 <otters> of practically
14:13:21 <otters> not conceptually
14:13:51 <mcstar> is this an automatic procedure?
14:14:03 <mcstar> basically, my question is, how do you detect spam?
14:14:09 <mauke> idoru is a bot
14:14:11 <mcstar> is this because of the url?
14:14:14 <mauke> I don't know how it works
14:14:19 <mm_freak> otters: just recently i found that monad-coroutine's Coroutine monads don't have Functor and Applicative instances, which i find very unfortunate
14:14:22 <ddarius> It's also not on-topic for #haskell.
14:14:25 <mauke> presumably it scans for duplicated messages across all channels
14:14:32 <otters> I'll take a look
14:15:01 <mcstar> ill try it
14:15:01 <ddarius> mm_freak: Impressive.  I'm amazed anyone nowadays would make a Monad instance without, at least, a Functor instance.  I can see Applicative, though that is silly too.
14:15:47 <E0F> most of the spam detection done by bots relies on two concepts : many messages in a short time span, the same message repeated again and again
14:15:55 <mm_freak> yeahâ¦  the lack has made me write my own Coroutine monads
14:16:04 <mcstar> mauke: had a good time?
14:16:09 <ddarius> mm_freak: Why not just submit a patch?
14:16:16 <merijn> mcstar: Someone could also have reported him to freenode staff to get him k-lined
14:16:28 <mm_freak> ddarius: because i didn't have the time to wait for the author to respond
14:16:42 <ddarius> mm_freak: Yes, but you could use the patched library in the mean-time.
14:17:04 <mm_freak> i suppose
14:17:05 <roconnor_> jfischoff: do you just need lens-family core or also lens-family?
14:17:17 * roconnor_ wonders if there would be a difference
14:17:37 <jfischoff> roconnor_: to be honest I don't know, but I think core would be fine
14:20:12 <roconnor_> jfischoff: what's your use case?
14:21:48 <jfischoff> roconnor_: I'm writing lens version of fgl. I think the "match" function here : http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-Graph.html#v:match could be a rephrased as partial lens
14:22:22 <jfischoff> roconnor_: err Int -> PLens that is
14:22:56 <jfischoff> roconnor_: more generally I making lenses for fgl
14:23:30 <roconnor_> Int -> PLens?
14:23:53 <jfischoff> type Node = Int. I'm not being that precise one sec
14:25:25 <jfischoff> hmm
14:25:54 <EvanR> when using hGetLine with a socket where the other end is not trusted
14:26:06 <EvanR> seems like you have a vulneravility
14:26:08 <EvanR> bility
14:26:17 <EvanR> they just never send the newline
14:26:24 <roconnor_> edwardk: ping
14:26:30 <edwardk> pong
14:26:48 <edwardk> i swear i just want to write a script for that to mess with people
14:27:08 <jfischoff> roconnor_: This is not the best example, but it would be something like:  match (Graph gr) => Node -> Maybe (PLens (gr a b) (GDecomp gr a b))
14:27:21 <roconnor_> edwardk: how would you feel about adding a PointedType / PointedSet to the pointed package, thus making Const o Pointed when o is PointedType
14:27:32 <edwardk> ?
14:27:43 <roconnor_> ya a bit confusing
14:27:52 <edwardk> source for PointedType and PointedSet?
14:28:00 <roconnor_> edwardk: you know how Const o is applicative when o is a monoid?
14:28:13 <jfischoff> roconnor_: when trying to set a context in a graph, the context can refer to nodes that don't exist and fail.
14:28:19 <roconnor_> and how (,) o is applicative when o is a monid?
14:28:19 <edwardk> my knee jerk reaction is rather negative but i'm open to being convinced
14:28:23 <edwardk> sure
14:28:41 <roconnor_> I want to do the same with applicative replaced by pointed and monoid replaced by PointedSet
14:29:01 <edwardk> 'PointedType' is in data-default
14:29:27 <edwardk> i use the Default class whenever i want that functionality
14:29:35 <roconnor_> edwardk: yes but are the instances in data-default reasonable?
14:29:37 <edwardk> not that i ever use it any more
14:29:47 <edwardk> are they not?
14:29:57 <edwardk> they align with mempty wherever there is a monoid
14:30:00 <roconnor_> I don't know, I've never used them
14:30:10 <ddarius> EvanR: You're worried about them sending arbitrarily large data or just not sending anything?
14:30:10 <edwardk> so they are what you want ;)
14:30:18 <edwardk> ddarius lives!
14:30:46 <EvanR> ddarius: large data
14:30:46 <ddarius> edwardk: I'm trying to find out if something is happening on the west coast at the beginning of August.
14:31:16 <ddarius> EvanR: Then yes, you do.  You should specify an upper-bound to the amount of data you'll accept which hGetLine does not allow.
14:31:27 <edwardk> heading that way?
14:31:32 <EvanR> ddarius: yeah, whats the easy way out (tm)
14:31:36 <edwardk> so i guess you won't be going to hac phi ;)
14:31:58 <ddarius> EvanR: How is that the easy way out?  It's what you should be doing.  If you have limits, you need to say them somewhere.
14:32:16 <EvanR> ddarius: i asked whats the easy way to enforce this limit
14:32:24 <ddarius> edwardk: HacPhi completely conflicts with another prior engagement.
14:32:37 <edwardk> ddarius: do you have any good references for using conformal geometric algebra for rigid body physics?
14:32:43 <edwardk> fair nuff
14:32:57 <ddarius> EvanR: Probably to handle accepting blocks of data in one layer, and then the "hGetLine" would be a parser over it.
14:33:07 <ddarius> edwardk: One second.
14:33:26 <EvanR> buffering
14:33:35 <EvanR> blaw feels like programming an OS
14:33:38 <edwardk> there are some slides by lasenby, and a couple of papers i've found, one by hestenes using it for elastic joints, but thats about it
14:34:43 <popl> ddarius: In August on the west coast, most health insurance will cover women's contraception.
14:34:59 <popl> I imagine it will also happen on the other coast as well, though.
14:35:21 <roconnor_> edwardk: okay, how do you feel about making a instance Default o => Pointed (Const o)  and instance Default o => Pointed ((,) o) ?
14:35:34 <jfischoff> roconnor_: better example insEdge :: (DynGraph gr) => PLens (gr a b) (LEdge b) will fail if one of the Nodes in the LEdge doesn't exist in the graph.
14:35:38 <roconnor_> edwardk: actualy I don't need you to do that
14:35:43 <popl> Sorry, I just made the assumption that you were referring to the west coast of the US.
14:35:44 <roconnor_> since I can do it myself
14:36:15 <edwardk> roconnor_: instance Default m => Pointed (Const m) where point _ = Const def    -- is already in pointed ;)
14:36:28 <edwardk> as is
14:36:31 <roconnor_> what?
14:36:31 <edwardk> instance Default e => Pointed ((,)e) where point = (,) def
14:36:36 <ddarius> edwardk: Yeah.  I don't think there's an in-depth article using CGA for rigid body mechanics.  The one about elastic joints is close-ish, but I think is 4D projective.  It can probably be redone in CGA.
14:36:58 <roconnor_> oh so it is
14:37:10 <edwardk> basically figuring it would unify a lot of the wall/ball contacts
14:37:56 <roconnor_> edwardk: okay I have a second not unrelated question:  Which is more important for making libraries, what the users want or what the types want?
14:38:38 <ddarius> edwardk: Maybe "Objects in Contact: Boundary collisions as geometric wave propagation" would be relevant.
14:39:10 <ddarius> I think it preceded the term "conformal geometric algebra" but it uses a N+1,1 Minkowski geometric algebra.
14:39:35 <edwardk> roconnor_: that is a question like 'what is the best in life?' i'm tempted to give conan's answer.
14:39:36 <ddarius> edwardk: There is, of course, a paper that formulates a ray tracer using 3, 4, and 5D GA.
14:39:56 <edwardk> ddarius: been through that one
14:40:00 <edwardk> (the raytracer one)
14:40:09 <ddarius> roconnor_: What the types want should be what the user want whether they know it or not.
14:40:11 <ddarius> edwardk: I figured.
14:40:18 <ddarius> It's also pretty brief in detail.
14:40:25 <shachaf> hi ddarius
14:40:29 <edwardk> i'm mostly interested in the conformal ga component because it can handle curved paths well
14:40:50 <edwardk> but then you need to play all sorts of games with the notion of bounding for the collision engine
14:41:27 <roconnor_> ddarius: ya, I'm inclined to think that too
14:41:30 <edwardk> i tend to favor the types over users, the users who are happy with that call are the ones that i want anyways ;)
14:41:30 <shachaf> ddarius: What parts of the west coast?
14:41:50 * roconnor_ worries that edwardk will soon be unhappy with lens-family
14:42:09 <ddarius> shachaf: I'll start near San Francisco.  After that, I can go anywhere.  I was thinking of going up to Portland if anything was happening up there.
14:42:15 <edwardk> i'm already a little unhappy with it, how much worse is it getting?
14:42:41 <roconnor_> edwardk: I'm adding instance Default m => Pointed (Getting c)
14:42:50 <roconnor_> and instance Monoid m => Applicative (Getting c)
14:42:59 <edwardk> Getting is a data type?
14:43:04 <edwardk> oh i guess it is
14:43:09 <roconnor_> newtype Getting c a = Getting { unGetting :: c }
14:43:17 <ddarius> Where is m coming from?
14:43:35 <edwardk> i can add those to pointed
14:43:42 <edwardk> rather than your module if you want i guess
14:43:45 <roconnor_> no no
14:43:51 <roconnor_> I'm happy to add it to my module
14:43:52 <shachaf> ddarius: Bay area Haskell is usually in SF on the third Wednesday of the month, but there might be something happening earlier.
14:43:58 <edwardk> the Monoid instance makes sense
14:44:03 <edwardk> at least type wise
14:44:07 <roconnor_> yep
14:44:08 <roconnor_> type wise
14:44:10 <edwardk> so be it
14:44:16 <edwardk> do users want it?
14:44:27 <edwardk> i couldn't give a crap less about the Pointed instance
14:44:30 <edwardk> do you have a usecase?
14:44:36 <roconnor_> they enable multilenses which you are not so fond of
14:44:38 <shachaf> PDXFunc is on the second Monday, which is the 13th.
14:44:41 <edwardk> oh that crap
14:44:45 <roconnor_> the Pointed stuff enables partial lenses
14:44:46 <ddarius> edwardk: I bought a software defined radio recently.
14:45:01 <edwardk> oh nice. one of those gnu things?
14:45:19 <edwardk> who is calling for multilenses, etc?
14:45:19 <ddarius> shachaf: 13th is too late.  I need to be back in MA and working on the 13th.
14:45:28 <edwardk> and what the hell do they mean? =P
14:45:35 <jfischoff> edwardk: I want partial lenses
14:45:47 <ddarius> edwardk: It's not GNU, but it is the USRP family which is what GNU Radio primarily works with.
14:45:52 <roconnor_> edwardk: all the people using uniplate are calling for multilenses
14:45:54 <jfischoff> edwardk: or at least I think I do ;)
14:46:12 <otters> bah, hlint chokes on quasiquotes
14:46:15 <edwardk> jfischoff: what is an example of the need?
14:46:18 <roconnor_> edwardk: and your fancy maps for Setting that you like so much are the setting halves of multilenses
14:46:24 <edwardk> jfischoff: partial lenses i'm relatively okay with
14:46:42 <ddarius> otters: You expected otherwise?
14:46:56 <shachaf> ddarius: It's also possible that they could move "bay area categories and types" to earlier in the month -- not a lot of people tend to show up so they might move it if people were interested.
14:47:19 <jfischoff> edwardk: I'm writing lenses for fgl, and setting things like edges is partial, because the nodes might not exist.
14:47:39 <jfischoff> edwardk: Also for sum types
14:47:40 <djahandarie> Hey ddarius!
14:47:48 <edwardk> jfischoff: have you looked at modifiers in the new lenses?
14:47:56 * shachaf will be getting back to CA on Aug 02.
14:48:23 <otters> ddarius: rather!
14:48:37 <edwardk> jfischoff: you can write a modifier to try to change part of the contents of a sum type
14:48:42 <jfischoff> edwardk: I'm skimmed your blog post. Is the functional for my case already present?
14:48:50 <jfischoff> ah
14:49:21 <roconnor_> heh, pointed has a lot of dependencies
14:49:27 <edwardk> modifying (`adjust` "hello") ^= 12
14:49:30 <roconnor_> what STM?
14:49:37 <edwardk> roconnor_: yep, and i'm not inverting them again =P
14:49:45 <edwardk> roconnor_: because pointed is a crappy thing to need/use =P
14:49:46 <roconnor_> this doesn't seem so haskell 98
14:49:54 <ddarius> I don't see inverting a dependency on STM happening any time ever.
14:50:07 <roconnor_> edwardk: I expect most people will eventually prefer multilenses to partial lenses in the future
14:50:32 <jfischoff> edwardk: is it possible to use modifiers for the edge insertion case?
14:50:42 <edwardk> roconnor_: whatever man, i still don't understand them =P
14:51:29 <edwardk> jfischoff: reacquainting myself with the mess that is fgl
14:51:39 <ddarius> edwardk: One of the nice things about the USRP I got, and one of the reasons I was willing to spend the money on it, is that it has an accessible and programmable FPGA.
14:51:39 <roconnor_> edwardk: multilenses are to monoids as partial lenses are to default
14:51:47 <roconnor_> ... sounds like a title of a paper :D
14:51:59 <jfischoff> edwardk: no don't do that I can find a simpler example
14:52:02 <edwardk> roconnor_: i understand the analogy, but not the laws in practiec
14:52:21 <otters> what's the recommended library for dealing with datetimes in Haskell?
14:52:44 <edwardk> insEdge :: DynGraph gr => LEdge b -> gr a b -> gr a b -- is your goal?
14:52:56 <jfischoff> yes
14:53:18 <edwardk> so what is the foo-lens in question?
14:53:53 <edwardk> a partial lens from gr a b to LEdge b ?
14:54:12 <jfischoff> hmm
14:54:13 <edwardk> with insertion on inserting Just and deletion on inserting Nothing?
14:54:14 <mm_freak> otters: what about 'time'?
14:54:14 <jfischoff> wait
14:54:17 * ddarius could turn the USRP into a ridiculous audio effects pedal...
14:54:26 <otters> mm_freak: okay
14:55:36 <edwardk> so if i had to design a lens into a graph using fgl i'd probably do something like
14:55:38 <confusing> otters: i don't know about any snazzy library, but just ask in here about the thing you want to do. istr it's usually quite simple, but it's hard to figure out from the haddock
14:55:53 <jfischoff> actually I think the best example is the setting of the context ...
14:55:54 <edwardk> edge :: Node -> Node -> Lens (gr a b) (Maybe b)
14:56:07 <edwardk> with the appropriate DynGraph gr => constraint
14:56:37 <roconnor_> edwardk: BTW, what are you somewhat unhappy about in lens-families?
14:56:41 <edwardk> foo ^. edge x y     -- would read the value of the edge between x and y
14:57:06 <otters> datetime looks closer to what I want ta do
14:57:08 <otters> to do
14:57:19 <edwardk> not so keen on the punning of names between lens-family-core and lens-family and the number 2 in the module names from lens-family is an eyesore
14:57:46 <edwardk> given my druthers i'd have named the modules in Core with a Lens.Family.Core.* or something and mangled their names
14:57:48 <jfischoff> here is a better example contextLens :: Node -> PLens (gr a b) (Context a b)
14:57:55 <edwardk> so you can use both without annotations
14:58:12 <jfischoff> edwardk: the issue is the context can refer to nodes that don't exist
14:58:57 <edwardk> trying to remember the way context works, doesn't it crap out if the Node isn't present?
14:58:59 <jfischoff> so the setting can fail ( I guess it should really Node -> Maybe (PLens â¦))
14:59:07 <jfischoff> yeah
14:59:25 <jfischoff> it should return a Maybe (PLens â¦)
14:59:28 <edwardk> it can't be a Node -> Maybe (PLens â¦) can it? you need the graph to know if it'll fail
14:59:37 <merijn> Speaking of lens-family, how is it different from data-lens?
14:59:38 <jfischoff> crap
14:59:57 <edwardk> merijn: polymorphic lenses, and you can mix getters and setters with real lenses
15:00:20 <edwardk> merijn: this lets you do things like (1 :+ 2, 3) ^. fstLens . getting magnitude
15:00:31 <edwardk> merijn: or change the type of the field in a pair by using its setter
15:00:36 <jfischoff> yeah it would have to Node -> gr a b -> Maybe (PLens ..)
15:00:52 <edwardk> sndLens ^= "Hello" $ (1,2)    ==> (1,"Hello")
15:00:57 <edwardk> even then its bad
15:01:08 <edwardk> because the PLens it gives you only works on that graph
15:01:11 <edwardk> which isn't a lens
15:01:16 <edwardk> it needs to work for anything with that type
15:01:22 <jfischoff> aye
15:02:21 <edwardk> now, we can make lenses for edges and nodes that work fine, but Context is a dangerous type
15:02:51 <edwardk> you can make node :: DynGraph gr => Node -> Lens (gr a b) (Maybe a)
15:02:53 <jfischoff> makes sense
15:03:31 <ddarius> edwardk: Why don't we stick a monad in it?
15:03:37 <edwardk> ddarius: =P
15:04:09 <jfischoff> which would delete with when given Nothing?
15:04:22 <edwardk> yes
15:04:55 <edwardk> just like the insertions/deletions into a map
15:04:55 <edwardk> mygraph^.node x   -- also even reads nicely
15:05:06 <jfischoff> right
15:05:20 <edwardk> and mygraph^.edge x y
15:05:47 <edwardk> edge x y ^= Just "hello" $ mygraph
15:06:41 <edwardk> now, we can make getters to read a context
15:06:47 <absence> is reverse and foldr a good solution for the space leak problem with foldl?
15:07:16 <jfischoff> roconnor_, edwardk: alright if sum types are handled by modifying and I can't really make a lens for the context anyway, I don't have a need for partial lenses that I can think of
15:07:31 <edwardk> thats what i was looking for ;)
15:07:39 <jfischoff> ditto
15:07:47 <jfischoff> thanks guys!
15:07:50 <roconnor_> jfischoff: huh, I wasn't paying attention
15:07:51 <edwardk> i've been able to defuse each one of these scenarios in my own code by applying that same reasoning
15:08:18 <roconnor_> edwardk: just because lenses can be split into Getting and Setting doesn't mean it isn't useful to have the combined object
15:08:46 <confusing> otters: that datetime thingy looks handy! from the source much of it seems to be "only" aliases and minor smoothing of the builtin time stuff. it definitely looks useful
15:09:03 <confusing> absence: you might be interested in this http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
15:09:06 <jfischoff> roconnor_: it doesn't look like I need partial lenses after all. 
15:09:30 <roconnor_> jfischoff: do you ever want to "get" with a partial lens?
15:09:41 <roconnor_> jfischoff: or use focus?
15:10:12 <edwardk> roconnor_: type MultiLens a b c d = forall f. Applicative f => (c -> f d) -> a -> f b -- is what you're after here?
15:10:19 <roconnor_> edwardk: naturally
15:10:35 <jfischoff> roconnor: if the current code can handle getting sum types then no I don't have a use case off hand
15:10:46 <edwardk> okay, so it works with both Getting and Setting
15:10:59 <edwardk> sort of, hrmm
15:11:07 <jfischoff> err roconnor_: ^^
15:11:19 <edwardk> working my way back through multilenses
15:11:28 <edwardk> trying to see if i still hate them =P
15:11:38 * roconnor_ reread the backlog
15:11:49 <roconnor_> [18:02] <edwardk> you can make node :: DynGraph gr => Node -> Lens (gr a b) (Maybe a)
15:11:53 <roconnor_> this does seem correct
15:12:09 <edwardk> does? or doesn't?
15:12:21 <roconnor_> in addition to not needing partial lenses, it also has the virtue of actually satisfying the lens laws
15:12:32 <edwardk> yes
15:13:07 <otters> lol @ Data.Time.Format having a picosecond specifier
15:13:20 <roconnor_> anyhow I just finished the quick and dirty and grossly undocumented version with partial lens and multilens.  I might as well put the branch on my homepage
15:14:44 <edwardk> my main concern is that all this window dressing distracts from the core set of combinators that are really quite simple
15:15:08 <edwardk> i have a hard time getting my will up to add 2-3 dependencies when i only want 2 combinators ;)
15:15:15 <roconnor_> edwardk: with the van laarhoven lenses the code doesn't change.  The only change is adding new instances for Getting Setting and Focusing
15:15:25 <absence> confusing: ah, that's good to know. i thought foldr didn't have the space leak problem
15:15:26 <edwardk> thats fine
15:15:43 <edwardk> i'm actually 100% behind adding the instances
15:15:56 <roconnor_> edwardk: that and I added nullPL :: Pointed f => Lens f a b
15:16:06 <roconnor_> hmm, that should be LensFamily f a a' b b'
15:16:39 <roconnor_> oh nope
15:16:42 <roconnor_> pointed is endo
15:17:08 <roconnor_> nullPL :: Pointed f => LensFamily f a a' b b perhaps
15:17:28 <confusing> otters: i just remembered, http://hackage.haskell.org/package/time-units-1.0.0 sometimes is quite handy
15:17:54 <edwardk> the time library always makes me sad
15:18:34 <roconnor_> nullPL :: (Pointed f) => LensFamily f a a b b'
15:18:38 <roconnor_> this typechecks
15:18:42 <roconnor_> so it must be right
15:19:09 <edwardk> with only the one '?
15:19:31 <roconnor_> the source is
15:19:39 <roconnor_> nullPL _ = point
15:19:53 <edwardk> i don't believe that lens yet
15:20:11 <confusing> edwardk: sad how?
15:20:14 * hackagebot HGamer3D-SFML-Binding 0.1.6 - Library to enable 3D game development for Haskell - SFML Bindings (PeterAlthainz)
15:20:16 * hackagebot HGamer3D-API 0.1.6 - Library to enable 3D game development for Haskell - API (PeterAlthainz)
15:20:19 <edwardk> in fact i'm pretty sure that is an illegal lens
15:20:35 <edwardk> what did you do with the thing you were handed?
15:20:46 <roconnor_> edwardk: as in you don't believe nullPL Identity === Identity and preserves compositon?
15:20:59 <edwardk> correct
15:21:12 <roconnor_> edwardk: I was handed an update function for the substructure which I ignored since there is no substructure.
15:21:42 <roconnor_> well the Identity is pretty clear
15:21:50 <edwardk> you're purporting to be a LensFamily though, i find that to be a _REALLY_ hazardous abuse of that type alias
15:21:52 <roconnor_> let me think about composition while I get the laundry
15:22:19 <edwardk> since what you have there is something less
15:22:22 <ddarius> absence: Space behavior is not a matter of using on function versus another.  You have to know what is going on.
15:22:52 <edwardk> confusing: needlessly opaque types that you can't get in and out of without paying horrendous conversion costs and lots of incidental complexity
15:24:09 <ddarius> Conversion costs should be fixable without changing the API.
15:24:15 <confusing> edwardk: right. you mean conversion costs in the sense of runtime slowness, or code readability?
15:24:25 <edwardk> runtime slowness
15:24:42 <edwardk> i'm okay in general with using lots of words to convert between types in the name of correctness
15:25:13 <edwardk> but i'm not so much okay with pissing away all my performance on something where the word nanosecond is involved anywhere in the code ;)
15:25:50 * ddarius learns how to implement MoM.
15:26:06 <EvanR> CoWoW
15:27:07 <roconnor_> edwardk: My trip to the laundry convinced me that nullPL sastifies the composeCoalgebroid law
15:27:29 <roconnor_> edwardk: if you pay me I'll do a proof in Coq;  If you pay me more I'll do a proof in Agda
15:27:29 <edwardk> coalgebroid is what you're calling these indexed algebras?
15:27:47 <roconnor_> a coalgebroid is (a -> f b) for a functor f
15:27:52 <roconnor_> duh
15:27:56 <ddarius> Oh Jesus.
15:27:57 <roconnor_> :)
15:29:16 <edwardk> nullPL still makes me feel ill =P
15:29:35 <jfischoff> so how would one emulate headLens?
15:29:42 <jfischoff> with lens-family?
15:29:56 <edwardk> [1,2,3]^.getting head
15:30:21 <jfischoff> and for setting?
15:30:26 <jfischoff> don't?
15:30:33 <edwardk> i'm not a huge fan of headLens to begin with =P
15:30:50 <jfischoff> how did I guess ;)
15:30:53 <edwardk> =)
15:30:59 <roconnor_> headLens f [] = point [];  headLens f (x:xs) = (:xs) <$> f x
15:30:59 <donri> "getting head" is partial, headLens isn't IIRC?
15:31:19 <roconnor_> headPL f [] = point [];  headPL f (x:xs) = (:xs) <$> f x
15:31:35 <edwardk> well the problem is how can i restore the thing i took the head of when i put something in and then take it back out
15:32:16 <roconnor_> [1,2,3] ^. headPL will return 0
15:32:21 <ddarius> Ugh.
15:32:24 <edwardk> *twitch*
15:32:25 <roconnor_> since someone decided that 0 is the default integer
15:32:34 * roconnor_ glares at Data.Default
15:32:43 <edwardk> there isn't a better alternative, is there?
15:32:45 <dmwit> Somebody just pointed me at http://axisofeval.blogspot.com/search/label/thispltlife
15:32:55 <dmwit> Thought people in here might enjoy it. =)
15:33:01 <roconnor_> edwardk: ya, removing some unsightly instances form Data.Default
15:33:11 <roconnor_> edwardk: this is what I mentioned earlier
15:33:31 <edwardk> meh, i'm really against the notion of making yet another notion of 'default'
15:33:46 <coppro> is it bad mojo to upload a poorly-documented package, especially for a first-time author?
15:33:50 <roconnor_> then [1,2,3] ^. headPL will return 0
15:34:06 <edwardk> well, then headPL is clearly not the right lens =P
15:34:07 <roconnor_> this is what the types want, not what the users want
15:34:13 <roconnor_> er
15:34:16 <roconnor_> god I'm sorry
15:34:23 <roconnor_> [1,2,3] ^. headPL will return 1 of course
15:34:29 <roconnor_> [] ^. headPL will return 0
15:34:38 <edwardk> interesting
15:34:39 <roconnor_> my bad
15:34:47 <jfischoff> dmwit: :D
15:35:15 * hackagebot optparse-applicative 0.2.0 - Utilities and combinators for parsing command line options (PaoloCapriotti)
15:35:18 <roconnor_> this is what I get for not running my code
15:35:19 <edwardk> i'm not liking these. they compose with real lenses, and can be used in both positions, etc. but they clearly violate lens laws
15:35:29 <roconnor_> what?
15:35:31 <roconnor_> oh
15:36:11 <roconnor_> well they don't violate the coalgebra of comonad laws nor do they violoate the monoidal natural transformation laws
15:36:15 <ddarius> coppro: Most packages are poorly documented.
15:36:20 <roconnor_> but yes, they do violate the get/set laws
15:36:23 <ddarius> coppro: Also, documentation doesn't matter if you have no users.
15:36:25 <edwardk> before with Getter and Setter they actually didn't violate the lens laws.
15:36:38 <roconnor_> edwardk: Indeed
15:36:42 <edwardk> because you couldn't put a getter or setter in both positions, and therefore you were safe from the laws
15:37:01 <edwardk> these you can put in both positions, but they just start lying to you =P
15:37:09 <roconnor_> edwardk: but ddarius and edwardk suggested that I ignore user concerns and do what the types wanted
15:37:25 <coppro> ddarius: sounds good then!
15:37:28 <edwardk> the types don't check the laws
15:37:36 <edwardk> the laws speak out against this abuse =P
15:37:37 <coppro> I have no users :P
15:38:04 <roconnor_> edwardk: well the coalgebra of comonad laws and the monoidal natural transformation laws are still statfied.
15:38:04 <ddarius> I would say anything involving Default is probably a bad idea.
15:38:29 <edwardk> yes, but those aren't the laws that drive the actual ability to reason about lenses
15:38:43 <roconnor_> ddarius: the same problems hold for Applicative / Monoid with respect to multilenses
15:39:11 <roconnor_> edwardk: doesn't everyone use the coalgabra laws now-a-days to reason about lenses?
15:39:29 <edwardk> yeah all 3 of us =P
15:40:14 <roconnor_> edwardk: don't get me wrong.  I share exactly the same concerns that you do.  ... but focus is really sweet this way
15:40:15 * hackagebot terminfo 0.3.2.4 - Haskell bindings to the terminfo library. (JudahJacobson)
15:40:35 <edwardk> i've just lost all ability to reason about the resulting code is all
15:40:48 <edwardk> for me that is a pretty damning issue ;)
15:40:56 <edwardk> now, lets take a step back for a sec
15:41:03 <roconnor_> edwardk: focus :: (Monoid o) => MultiLens a b -> State b o -> State a o
15:41:15 <edwardk> the actual Applicative instance, etc. i'm down with
15:41:36 <edwardk> its the nullPL and actually packaging partial lenses in the lens-family package that makes me queasy
15:41:38 <jmcarthur> i wondered briefly the other day whether invertible computing (e.g. Roshan James, "Information Effects") might have some application to lenses. getters would have the obvious semantics, and setters could be seen as performing some transformation, modifying the result, then applying the inverse of the original transformation
15:42:02 <roconnor_> edwardk: there is no point in adding the Applicative instances without adding multilens support.
15:42:24 <edwardk> jmcarthur: this is basically what dmwit and benjamin pierce do with some quirky differences for moving into the nullspace of an invariant
15:42:34 <ddarius> jmcarthur: There isn't a reverse of setting, though you could definitely and trivially make a reversible language using bidirectional lenses.
15:42:39 <roconnor_> [18:40] <edwardk> i've just lost all ability to reason about the resulting code is all
15:42:44 <roconnor_> I think you exagerate
15:42:44 <tgeeky__> jmcarthur: yes, it does, if lesnses have a monodial structure -- I guess
15:42:52 <edwardk> roconnor_: adding the applicative instances in lens-family gets you a lack of orphans
15:42:52 <roconnor_> the result isn't lawless
15:43:05 <jmcarthur> ddarius: i don't mean you can reverse the setting. i just mean the reversal is to "unproject" the part of the data structure you were focused on after modifying it somehow
15:43:17 <edwardk> roconnor_: well, you went out of your way to exaggerate my emphasis on letting the types dictate the functionality, so i figured turnabout is fair play =P
15:43:45 <ddarius> jmcarthur: I see.
15:43:45 <edwardk> no, but the resulting laws are weak enough to be nearly useless
15:44:07 <jmcarthur> ddarius: if the lens is an invertible function called L, a modification would look like   L^(-1) . f . L
15:44:07 <ddarius> I'll need to read this "Information Effects" thing to know if what you're talking about and what I'm thinking of are the same.
15:44:24 <jmcarthur> s/modification/set/
15:44:43 <jmcarthur> i guess f can't change the type
15:44:50 <edwardk> jmcarthur: we have the ability to build lenses out of isomorphisms
15:44:56 <roconnor_> okay
15:45:07 <roconnor_> well if I can't convince edwardk then I'm in serious trouble
15:45:17 * hackagebot haskeline 0.7.0.0 - A command-line interface for user input, written in Haskell. (JudahJacobson)
15:45:20 <tgeeky__> nawwww
15:45:35 <roconnor_> edwardk: but they are exactly the laws that you expect a multi-lens to have
15:46:55 <roconnor_> > ["1","2","3"] ^. traverse = "123"
15:46:57 <lambdabot>   <no location info>: parse error on input `='
15:47:09 <jfischoff> jmcarthur: or like L^-1 . first f . L
15:47:11 <roconnor_> how awesome is that
15:47:40 <startling> what's the composition operator (as in g â¦ f) in TeX?
15:47:42 <edwardk> anyways where i was going with that was that perhaps if you put the instances for Applicative, etc. in the right place, and hide the multilens aliases and operations in another module i'd be less prone to vomit ;)
15:47:51 <edwardk> that is actually kind of disturbingly neat
15:47:51 <sm> is there an easy way to build just a particular executable when the cabal file defines several ?
15:47:53 <ddarius> \circ
15:48:02 * roconnor_ wonders if that actually works
15:48:09 <startling> ddarius: \circ seems to be â
15:48:14 * roconnor_ tries running his code for the first time
15:48:32 <copumpkin> holy shit, ddarius is back
15:48:34 * copumpkin faints
15:49:00 <mauke> startling: that's because your "composition operator" is actually WHITE BULLET, not an operator
15:49:04 <jfischoff> has anyone use pointedlist? Any recommendations on a pointed list?
15:49:10 <startling> mauke: oh heh
15:49:19 <startling> that's what I get for copy-pasting out of papers I guess !
15:49:36 <roconnor_> edwardk: it works
15:49:48 <roconnor_> what are other good monoids?
15:50:14 <roconnor_> @instances Monoid
15:50:15 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:50:31 <edwardk> traverse is a pretty cute multilens
15:50:46 <startling> roconnor_: they're all good monoids. :)
15:51:03 <startling> roconnor_, have you gotten to "every monad is also a monoid" yet?
15:51:22 <copumpkin> roconnor_ has been known to talk about comonoids!
15:51:35 <ddarius> copumpkin: All one of them?
15:52:35 <roconnor_> edwardk: I'm going to bed now;  I won't be releasing this multilens stuff anytime soon.  I'm still a little uncomforatable with it. ... The types are compelling me though.
15:53:07 * ddarius has 500ft of solid core copper wire which is a -little- more than he needs.
15:53:38 <edwardk> my main concern is that nullPL not find its way where someone who expects actual lenses would trip over it, if its in another module, then perhaps i can learn to live with the reduced certainty about what my code is doing
15:54:30 <edwardk> adding the instances is kinda cool, and it is rather interesting that you can compose multilenses with getters/setters/lenses this way
15:54:40 <edwardk> so don't take me as 100% negative
15:54:59 <roconnor_> edwardk: well, your fancy edit-lens-setters are just half of multilenses
15:55:05 <edwardk> sure
15:55:06 <roconnor_> so it isn't so surprising that it composes
15:55:30 <roconnor_> it's just that get getter half is ... unsettling
15:55:32 <edwardk> i'm not surprised. i'm mostly rather pleased about it
15:56:03 <edwardk> the fact that LensFamily is used in the type alias is somewhat unsettling
15:56:27 <edwardk> maybe the Core type aliases should be more obviously marked as something unsettling
15:56:32 <edwardk> LensLike f a b c d
15:56:34 <edwardk> or something
15:56:59 <roconnor_> edwardk: I'm thinking of renaming LensFamily and Lens in core to LensFamilyFor and LensFor
15:57:05 <roconnor_> strongly thinking of this
15:57:30 <edwardk> then nullPL :: Applicative f => LensLike f a a c d -- doesn't look like its claiming to be a lens
15:57:43 <edwardk> hrmm
15:57:51 <roconnor_> well maybe even better names are needed
15:57:51 <edwardk> i like it better than the current convention, definitely
15:57:59 <roconnor_> something that deemphesises the Lens bit
15:58:08 <edwardk> can we switch the module names around while we're at it?
15:58:12 <edwardk> Lens.Family2 is pretty bad =P
15:58:20 <roconnor_> oh I'll leave you with another tidbit of multilens awesomeness
15:59:18 <edwardk> hrmm, what about just 'Family'? but that doesn't give a nice name for Lens f /LensFor f
15:59:46 <copumpkin> ddarius: going to roll your own tesla coil or a coilgun?
16:00:06 <ddarius> copumpkin: No.
16:00:16 <roconnor_> k -> PartialLens (k, v) v -- returns a null lens when the key does not match, and returns a lens for v when the key does match.  ...
16:00:16 * hackagebot ncurses 0.2.3 - Modernised bindings to GNU ncurses (JohnMillikin)
16:00:31 <roconnor_> keyPL :: k -> PartialLens (k, v) v -- returns a null lens when the key does not match, and returns a lens for v when the key does match.  ...
16:00:59 <edwardk> cute
16:01:02 <roconnor_> and then traverse . keyPL -- a multilens picking out all the values matchin a key
16:01:32 <roconnor_> say from an association list, or whatever traversable container
16:01:38 <edwardk> *nods*
16:01:44 <roconnor_> anyhow
16:01:47 <roconnor_> really is off to bed
16:01:52 * roconnor_ really is off to bed
16:08:52 <jfischoff> edwardk: I think I want to use the PointedCycle from here http://comonad.com/reader/2008/the-pointed-set-comonad/ . I also read your not supporting Pointed any more, does that mean there is a more modern way to build PointedCycle now?
16:09:07 <chaotic_good> is haskel really that much more fun than ruby etc?
16:09:09 <chaotic_good> perl?
16:09:20 <copumpkin> yeah
16:09:23 <chaotic_good> it seems it would be blinding fast on 8 core
16:09:34 <edwardk> the pointed set comonad isn't a "pointed" data type
16:09:42 <chaotic_good> ok to lean with ghc? I cant get platform going
16:10:03 <flojistik> chaotic_good: it should be OK; though installing the platform should be easiest
16:10:24 <edwardk> i never did bother reimplementing those comonads in any canonical location
16:10:28 <ddarius> chaotic_good: It will certainly be faster than ruby, but that isn't saying anything.
16:11:15 <jfischoff> edwardk: Copointed I mean, but I guess the way there implemented is the way you would still implemented them?
16:11:23 <edwardk> yeah
16:11:32 <jfischoff> thakns
16:11:35 <edwardk> keep in mind that they are comonads, so you can just use extract
16:11:38 <edwardk> no need for copointed
16:12:04 <jfischoff> ah
16:12:09 <jfischoff> I see
16:29:25 <sm> can I get a list of recent commands from within a ghci session, to replay in another one ?
16:29:44 <sm> without quitting and starting over ?
16:41:24 <monochrom> I think you can press up-arrow to recall recent ghci commands
16:41:33 <Obfuscate> absence: The encodeFloat method is basically the same way it would be done in C or assembly, where you would just construct the value directly. It should be the easiest form for an optimizer, but I don't know how any of this is actually handled behind the scenes.
16:54:09 <creepyvag> Snardbafulator is responsible for this spam!
16:54:14 -creepyvag(~vagcreep@89.205.62.78)- Chimpout's Nigger World Atlas, Page 19: United States of America
16:54:14 <creepyvag>     United States of America
16:54:14 <creepyvag>     Location: North America
16:54:14 <creepyvag>     Population: 305,611,000
16:54:14 <creepyvag>     Capital: Washington, D.C.
16:54:30 <EvanR> chimpout has reached #haskell, nice
16:54:46 * tgeeky__ fires up the banbot
16:57:28 <Cale> Thankfully, the ircops are on top of it
16:59:36 <mgsloan> just got my hacked-together tool for getting consistent module signatures working.  This lets you use "diff" on the outputted API, with some pretty good results
16:59:41 <mgsloan> https://github.com/mgsloan/api-compat/blob/master/examples/diagrams-core.api.diff
16:59:54 <mgsloan> (this is the differences between diagrams-core-0.4 and diagrams-core-0.5.1)
17:00:16 <ddarius> EvanR: That's hardly the first time.
17:00:42 <mzarella> polymorphism is when a function is taken as a first-class value, correct?
17:01:12 <ddarius> mzarella: Incorrect.
17:02:18 <geekosaur> no, polymorphism is when a function can operate on more than one type.  so for example (+) is defined for Int, Integer, Float, Double, etc.; concat is defined for lists regardless of what type those lists contain (lists themselves are not polymorphic, every element of a list must be the same type)
17:05:37 <Zearen> In HaskellDB, how do you retrieve a the value from the Record
17:06:24 <Zearen> I.e. I want to turn the results of a query into a list of tuples on certain fields.
17:06:42 <Zearen> s/a the/the/
17:07:46 <Zearen> Hahahaha, just as I ask, I figure it out.  NVM
17:09:36 <Cale> mzarella: Or even not a function -- non-function values can be polymorphic too:
17:09:37 <Cale> :t pi
17:09:39 <lambdabot> forall a. (Floating a) => a
17:09:47 <Cale> > pi :: Float
17:09:49 <lambdabot>   3.1415927
17:09:51 <Cale> > pi :: Double
17:09:53 <lambdabot>   3.141592653589793
17:09:56 <Cale> > pi :: CReal
17:09:57 <lambdabot>   3.1415926535897932384626433832795028841972
17:10:02 <nand`> > pi :: Rational
17:10:03 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
17:10:03 <lambdabot>    arising from a us...
17:10:07 <nand`> :(
17:10:20 <nand`> I thought I remembered that working
17:10:30 <nand`> oh
17:10:32 <nand`> > toRational pi
17:10:34 <lambdabot>   884279719003555 % 281474976710656
17:27:55 <Zearen> Is there a document for converting a GenParser in Parsec 2 to ParsecT (I assume) in Parsec 3 ?
17:32:42 <kulin> Is there a language extension which will allow you to export functions (in a module's where clause) for specific programs or library only, ie to expose a function for testing modules but not program modules?
17:34:51 <kulin> or maybe any import that says "import all Program.Module.X"
17:34:55 <kulin> something along those lines
17:35:56 <kulin> it seems like the whole world wants to encourage unit tests, but the language is being difficult about it
17:36:39 <EvanR> kulin: this is why some people get mad about modules that hide stuff
17:38:02 <kulin> hiding helper functions is very obviously a huge aid to usability and modularity
17:40:59 <tswett> I suppose you could have a module that exports everything, and then a second module that imports and re-exports just the things you want to be visible everywhere.
17:41:19 <tswett> Then I guess you can tell people to import the second module, not the first.
17:41:22 <kulin> ya tswett, but that create a lot of extra boilerplate and naming headaches
17:41:37 <ddarius> Zearen: Just recompile whatever.  GenParser is an type alias that expands to ParsecT in Parsec 3.
17:42:15 <ddarius> kulin: Not really.
17:42:33 <kulin> ddarius, are there any guides on creating a ghc extension?
17:42:52 <ddarius> There's the GHC wiki.
17:42:55 <kulin> google is not returning much
17:43:33 <ddarius> There's also a compiler plugin interface, though I'm not sure how flexible that is for defining new features.
17:44:00 <ddarius> Really, most people make a Foo.Internals module and a Foo module that may re-export stuff from Foo.Internals.
17:44:28 <kulin> I just find that solution offensive to what haskell is suppose to be. That is a very c++ solution to a problem.
17:45:50 <ddarius> Note that GHCi will allow access to private methods when it loads a file for interpretation.
17:47:29 <tswett> Can I run the Haskell Platform installer if I already have a previous version of the Platform installed?
17:47:48 <Zearen> Hrmm, ddarius, you mean by keeping the Text.ParserCombinators.Parsec import ?  Because I was hoping to exploit the transformer for something.
17:49:13 <ddarius> kulin: If I ever get unlazy, the local modules proposal that I've mentioned (but not written up) would handle this pretty well, I believe, albeit in a way different from what you want.
17:50:13 <kulin> does ghc use the c-preprocessor? is there a way to combine that with cabal to use macros to remove lines in the modules export list based on package name?
17:50:27 <ddarius> Zearen: You shouldn't need to do anything but (perhaps) generalize the types to have some existing Parsec 2 parser code become Parsec 3 code.
17:50:56 <ddarius> kulin: You can ask GHC to run a preprocessor including a (modified) C preprocessor.  It doesn't use it as a matter of course though.
17:50:58 <byorgey> kulin: based on *package name*?  Not that I know of.
17:52:46 <loold> hi - i'm having trouble working out what dependencies to use for my haskell project. i guess a standard is best, so haskell98 or haskell2010. but then there's also base. and there's some stuff that i want that's only in one of those three. i can't seem to find a happy medium. for example, I want MVar, which is in base, but I also want getArgs, which is only in haskell98 or haskell2010.
17:53:42 <kulin> loold, from what i understand you want base if you are doing any real world project, but wait for a better answer :)
17:54:33 <loold> kulin: i thought that - but then i can't seem to find getArgs anywhere in base. in haskell98 it's in System, in haskell2010 it's in System.Env, but where in base?
17:54:56 <ddarius> @hoogle getArgs
17:54:57 <lambdabot> System.Environment getArgs :: IO [String]
17:54:57 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
17:55:00 <kulin> loold have you tried hoogle?
17:55:13 <byorgey> loold: don't use haskell98.
17:55:21 <ddarius> There is no reason to use haskell98.
17:55:44 <kulin> loold, www.haskell.org/hoogle/ it is your best friend, you type getArgs in there and the package System.Environment in base comes up
17:56:34 <loold> kulin: ok, i see that now. but then how come my haskell platform docs only show System.Environment as being in haskell2010
17:57:06 <byorgey> loold: because that's where it's ultimately defined.  base re-exports it from there.
17:57:20 <kulin> loold, sorry i dont know what platform docs are so I cannot explain what is going on there
17:57:20 <sinelaw> what's a good approach to sql in haskell?
17:57:28 <sinelaw> i mean library
17:57:57 <ddarius> sinelaw: I'm assuming you want database access, in which case there are a lot of database libraries with different goals and trade-offs.
17:58:32 <sinelaw> ddarius, right. i want type-safe construction of sql queries, and not to care abuot the underlying DB
17:58:56 <Zearen> Wow, I actually defined everything with one super generic combinator.  Go me :D
17:58:56 <ddarius> Maybe HaskellDB then.
17:59:51 <Zearen> HaskellDB is fun; I've been playing with it all day.
18:00:23 * hackagebot process-extras 0.1.1 - Process extras (DavidLazar)
18:01:20 <ddarius> Persistent would be another, rather different choice.
18:01:59 <shirt> kulin: you can have a module A, and then an additional module A.Internal, this is what is commonly done
18:02:09 <sinelaw> ddarius, what's the main difference?
18:02:11 <augur> ski: is there a dual to 0-or-1 conclusion SC, thats 0-or-1 premise SC?
18:02:21 <augur> ski: i mean, it "exists", but is it anything interesting
18:03:15 <kulin> shirt, ya but that is a lot of work and obfuscates the code because haskell was designed before unit testing was a thing, i think im going to try to use the cpp pre processor from cabal, it might accomplish what i want
18:04:46 <ddarius> sinelaw: They are completely different approaches entirely.
18:05:54 <Cale> I don't understand how having an A.Internal module would be a problem syntactically
18:05:57 <shirt> kulin: I have also done that. In you cabal file you can add a -DTESTING flag, and then do an #ifdef TESTING in your export list
18:06:15 <Cale> You know that you can import stuff with modified qualifiers, right?
18:06:26 <Cale> (or even just import it wholesale)
18:06:31 <shirt> kulin: but usually i use the A.Internal method as it is a lot cleaner
18:07:02 <mouna> Hello, Could anyone helps me please with this code :
18:07:06 <mouna> import Data.List  data Result a = Result (Int,a) deriving (Eq)  encodeModified :: Eq a => [a] -> [Either Result a] encodeModified xs = map (\ l -> if (length l) == 1 then (head l) else (length l, head l)) $ group xs
18:07:37 <kulin> Cale, I know, but my concern is that the helper functions should be in proximity to the code that depends upon it if it can be helped, using the preprocessor I might even leave the unit tests in that file as well since they won't have an impact on the final file
18:07:38 <mouna> when compiling, I found this error :   `Result' is not applied to enough type arguments     The first argument of `Either' should have kind `*',     but `Result' has kind `* -> *'     In the type signature for `encodeModified':       encodeModified :: Eq a => [a] -> [Either Result a]
18:07:48 <applicative> mouna you can put it on hpaste.org; it'll be more legible probably
18:08:44 <Cale> uh, sure. You can also just not export the tests.
18:09:09 <Cale> (Unless you're super-worried about compilation time)
18:09:29 <mouna> ok applicative
18:09:36 <kulin> Cale, I'm worried about resulting file size for bandwidth concerns
18:09:46 <Cale> kulin: I usually will just put quickCheck tests alongside the code.
18:09:59 <Cale> kulin: bandwidth? really?
18:10:08 <Cale> What?
18:10:15 <applicative> mouna: the complaint was that the signature should be encodeModified :: Eq a => [a] -> [Either (Result a) a] not  encodeModified :: Eq a => [a] -> [Either Result a]
18:10:46 <kulin> Cale, I don't have this concern today, but the end result will be creating libraries that can be updated automatically through a tool, and I want to start tackling this problem from the start
18:10:53 <Cale> There is no way I could download enough source code in a month to match my bandwidth usage for video in 1 hour.
18:11:08 <shirt> kulin: if you want the helper functions in the same file, in close proximity to the code that depends on them, then you can put the "main" functions as well as the helper functions all in A.Internal. Then have A itself just re-rexport the "main" functions.
18:11:15 <applicative> mouna: it cant understand  Either Result a, since Either takes two ordinary types  (*), but Result needs a type , its a (*  ->*)
18:11:27 <Cale> and if you're talking about binary size, well, the tests should not be included in that
18:11:31 <Cale> because they'll be dead code
18:12:41 <mouna> applicative : could you please explain more ?
18:13:31 <mouna> because when changing it the way you mentioned, it gave another error
18:13:41 <applicative> mouna,  I was trying to explain the error message, it says Either need two arguments of kind * (ie. two regular types) as with Either Int Char or Either Bool  String
18:14:21 <applicative> but then its irritated you are giving it Result as the first argument, rather than something it sees as sensible like Bool or Int or Char
18:15:04 <applicative> it can make sense of Either (Result a) a  but not Either Result a
18:15:34 <mouna> I changed it that way but it gives an error
18:17:05 <applicative> mouna yes, there is another intrinsic error in the actual definition, youll see it if you strike the signature.
18:17:57 <applicative> mouna the definition is trying to return a pair, not an Either  hmmm
18:18:02 <mouna> I need a type : a list that may contain either (Int,a) or a
18:18:18 <coppro> [Either (Int, a) a] ?
18:18:26 <coppro> or [(Maybe Int, a)] ?
18:18:32 <mouna> let me try it
18:18:59 <coppro> which you want depends on how you want to interact with the 'a's
18:20:16 <mouna>  [Either (Int, a) a]  doesn't work
18:20:24 <hpaste> applicative pasted âencodeModifiedâ at http://hpaste.org/71972
18:20:45 <applicative> mouna ^^ is this sort of right?
18:21:27 <applicative> mouna, you need to mark the cases as either Left or  Right
18:21:40 <mouna> jut a minute that I can see it please
18:23:05 <applicative> mouna I separated out the lambda and called it foo so we could think about it more clearly
18:29:28 <mouna> Thanks applicative it works
18:30:01 <mouna> but when executing it says :    No instance for (Show (Result a0))       arising from a use of `print'     Possible fix: add an instance declaration for (Show (Result a0))     In a stmt of an interactive GHCi command: print it
18:30:03 <ddarius> Hmm, if I do a Fourier transform on just the time component, I should be able to use the Euclidean Green's function at a constant frequency which should be enough for my purposes...
18:30:17 <applicative> mouna, notice that foo, as I called it overlooks a case, the empty list
18:30:51 <mouna> so I added the deriving ( Show ) for Result
18:31:28 <mouna> it worked but not exactly the way I wanted it to be
18:31:47 <mouna> encodeModified [1,1,1,1,2,2,3,4,4] [Right (Result (4,1)),Right (Result (2,2)),Left 3,Right (Result (2,4))]
18:32:07 <ddarius> mouna: You should not be so reactionary in your coding.
18:33:05 <hpaste> applicative annotated âencodeModifiedâ with âencodeModifiedIIâ at http://hpaste.org/71972#a71973
18:33:08 <mouna> is there any way to not seeing Result , Right and Left
18:34:37 <applicative> mouna, you cant have [(4,1), (2,2),  3 ...] what would it be a list of
18:35:16 <applicative> you can write a function, pretty, say, that prints as you please
18:36:00 <mouna> applicative here is the link of the problem I'm trying to code, have a look at it please and you'll see what I mean http://www.haskell.org/haskellwiki/99_questions/11_to_20 it's problem num 11
18:36:54 <applicative> ah i was  going to advise something like that
18:37:45 <applicative> data Result a = Multiple Int a | Single a would be the type
18:39:05 <applicative> then where I wrote Left x  you could write  Single x and where I wrote  Right (Result (1+length xs, xs)) you;d write Multiple  (1+length xs) xs
18:39:31 <applicative> have to, grrr
18:40:21 <mouna> So I won't need the Either type anymore right ??
18:40:22 <kulin> shirt, what cabal option do you use to pass "-DTESTING"? I've tried cc-options without success
18:42:10 <hpaste> Mouna pasted âProblem with Either Type â at http://hpaste.org/71975
18:42:53 <mouna> applicative : I tried my version that way but I still have a problem
18:43:04 <kulin> shirt, nevermind i should have been using cpp-options
18:43:13 <mouna> I will switch it to foo and will try it again
18:46:30 <latro`a> Multiple takes two curried arguments
18:46:33 <latro`a> eh, "curried"
18:46:35 <latro`a> not a tuple
18:46:38 <latro`a> @ mouna
18:46:45 <latro`a> you want Multiple (length l) (head l)
18:48:05 <mouna> : latro `a could you explain please why Multiple takes 2 arguments ?
18:48:32 <mouna> oh sorry this was because of the definition
18:50:44 <mouna> still have a compiling problem
18:50:50 <hpaste> Mouna pasted âProblem with Either Type â at http://hpaste.org/71977
18:51:14 <cesip> 99 problems i see! sporty! :D oh what the hell, ten minutes to 4 AM, might as well have a go at a couple myself until it hits 4
18:51:47 <latro`a> where is lowercase
18:52:10 <latro`a> that said with that fixed it should work
18:52:15 <latro`a> but you also don't need Eq a
18:52:23 <latro`a> you tested the length, not the elements, for equality
18:54:00 <latro`a> > group [1,2,3]
18:54:01 <lambdabot>   [[1],[2],[3]]
18:54:07 <latro`a> > group [1,2,3,4]
18:54:07 <lambdabot>   [[1],[2],[3],[4]]
18:54:09 <latro`a> er
18:54:11 <latro`a> > group [1,2,3,3]
18:54:12 <lambdabot>   [[1],[2],[3,3]]
18:54:14 <latro`a> there we go
18:54:15 <latro`a> k
18:54:21 <latro`a> (was making sure none of them would be empty)
18:54:39 <Nereid> > group []
18:54:40 <lambdabot>   []
18:54:42 <Nereid> good
18:54:45 <latro`a> ah
18:54:50 <latro`a> but the map
18:54:52 <latro`a> will fix that
18:54:54 <latro`a> so that's OK
18:55:00 <latro`a> > map head []
18:55:01 <lambdabot>   []
18:55:14 <mouna> @ latro a please have a look at the problem so you 'll understant what i mean
18:55:15 <mouna> http://www.haskell.org/haskellwiki/99_questions/11_to_20
18:55:23 <mouna> problem 11
18:55:24 <latro`a> I saw it
18:55:28 <latro`a> you need [[a]], though
18:55:31 <Nereid> > map (length &&& head) . group $ "abbccccddd"
18:55:34 <lambdabot>   [(1,'a'),(2,'b'),(4,'c'),(3,'d')]
18:55:46 <mouna> &&& doesn't work
18:55:51 <mouna> I tried it
18:55:51 <Nereid> import Control.Arrow
18:55:56 <latro`a> &&& needs Control.Arrow, yeah
18:56:24 <Nereid> @type (&&&) -- where a = (->)
18:56:25 <mouna> but I didn't find problem with map neither group
18:56:26 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:56:37 <mouna> the problem is with the result type
18:57:07 <Nereid> mouna: it would help, if you had compile errors, if you pasted the error with the code
18:57:33 <mouna> ok I'll do it right now just a minute
18:57:37 <Nereid> for example, Where should be where
18:58:11 <hpaste> Mouna pasted âProblem with Either Type â at http://hpaste.org/71978
18:58:24 <Nereid> mouna: yes, your Where should be lowercase
18:58:45 <Nereid> also, you should use that "annotate" link to add to your pastes
18:58:56 <Nereid> from now on
18:59:05 <rwbarton> it helps to read error messages also; "parse error" is not a type error
19:00:55 <mouna> yeah but at first when I tried with Either it was a type error
19:03:16 <hpaste> Mouna annotated âProblem with Either Type â with âProblem with Either Type  (annotation)â at http://hpaste.org/71978#a71979
19:03:37 <mouna> I fixed the 'where"
19:03:45 <mouna> but still have a problem
19:03:48 <Nereid> ok, now your Result type needs to derive Show
19:03:57 <mouna> ok
19:04:46 <mouna> Finally after 2 days of fighting
19:05:14 <mouna> thank you very much @ Neireid and @ latro a
19:10:12 <shachaf> Cale: Are you still "working for iPwn Studios"?
19:16:35 <Cale> shachaf: I'm still working for Ryan at the moment, though iPwn is on hiatus until he can get more funding for it. The game engine is fairly close to being done, so it would be a shame if we didn't find some way to finish it at some point.
19:18:07 <Cale> I have some ideas about how we might be able to use the engine in its existing state to put together a smaller game and perhaps make some money to finish the larger one :)
19:20:20 <Cale> shachaf: Edward Kmett has expressed interest in hiring me, so I'm going to talk to him some more come the end of August or so.
19:21:08 <shachaf> Cale: Are you going to come to Boston?
19:21:15 <Cale> Maybe, if needs be
19:21:47 * edwardk lures cale to boston
19:21:54 <Cale> I've had no problems up to this point with telecommuting.
19:22:02 <shachaf> edwardk: :-(
19:22:06 <shachaf> You should lure Cale to CA.
19:23:30 <Cale> I'm already in Canada, silly
19:23:47 <MostAwesomeDude> Hm. Is there a way to see what the fixity for an operator is?
19:23:47 <shachaf> Cale: I'm talking about the CA that has an Ontario in it.
19:23:52 <shachaf> MostAwesomeDude: :i in ghci.
19:23:54 <Nereid> lol shachaf
19:23:55 * Clint chuckles.
19:24:03 <MostAwesomeDude> Oh, waaait, these are `` operators.
19:24:11 <shachaf> `` operators can have fixity too.
19:24:12 <Nereid> you can set fixity of `` operators too
19:24:24 <Cale> :info should say
19:24:33 <MostAwesomeDude> So what fixity do I need for <$!> such that I can do MyConstructor <$!> thing `ap` thing `ap` thing -- and have it work?
19:24:42 <shachaf> Same as <$>
19:24:53 <shachaf> :i tells me that's infixl 4
19:24:55 <Cale> also, y u no use <*>?
19:25:04 <Nereid> lol
19:25:11 <MostAwesomeDude> Is <*> suitable? I'm working in a Monad...
19:25:21 <Cale> Every monad should be an Applicative
19:25:24 <Nereid> every decent monad instance also has an applicative instance
19:25:43 <Cale> Where pure = return and (<*>) = ap
19:25:58 <MostAwesomeDude> Success! <*> works, thanks.
19:26:07 <MostAwesomeDude> I wish <$!> were in some standard place. :c
19:26:19 <Cale> What is <$!>
19:26:30 <Cale> Some strictification of fmap?
19:26:42 <shachaf> You could call it <$>!
19:26:57 <Nereid> shouldn't it be !$ if it's strict in the first argument? ;)
19:27:07 <shachaf> !<!$!>!
19:27:26 <Nereid> oh wait
19:27:29 <Nereid> $! is strict in the second
19:27:30 <Nereid> okay!
19:27:52 <Nereid> strict in the first would hardly make sense anyway.
19:28:05 <MostAwesomeDude> Right, it's this: f <$!> ma = do { a <- ma; return f $! a }
19:28:58 <Cale> http://www.twitch.tv/garrison_tt -- Might be about to set another world record
19:29:19 <Cale> (In Super Metroid any% realtime)
19:33:26 <autodidakto> I've read that it's often more elegant to use a fold instead of recursion, yet the haskell source I've been reading (Data-List, etc)  seems to strictly use recursion. Any opinions?
19:33:58 <Cale> autodidakto: a lot of that code was written when certain optimisations were still missing from GHC
19:34:04 <Cale> and was hand optimised as a result
19:34:17 <rwbarton> also make sure you are not reading the source code of foldr :)
19:35:04 * ion watches
19:36:03 <autodidakto> Cale: Yeah I noticed some weirdness that was too over my beginner head to figure out. But are you saying that folds were once slower, but now faster?
19:36:23 <autodidakto> rwbarton: I'll have to check it out now..
19:36:31 <Cale> autodidakto: Things get optimised better -- specifically in Data.List, you'll see a lot of explicit unboxed Int operations.
19:37:30 <Cale> and I believe the optimiser is good enough now that it's probably not necessary to expand out a lot of that code in the way that it has been
19:37:39 <Cale> but I don't know, you'd have to check
19:38:01 <Cale> In any case, Data.List has to be finely hand-tuned because that's code which affects everything
19:38:18 <Cale> So if it needs to be a little inelegant to be a small amount faster, that's how it'll be
19:39:02 <autodidakto> Cale: You're referring to the #ifdef stuff, for example?
19:39:17 <Cale> The stuff which uses Int#
19:39:23 <autodidakto> ahh, right
19:39:54 <autodidakto> Concerning folds vs recursion, are you saying that folds are slower?
19:40:13 <Cale> well, they *should* be about the same in general
19:40:21 <Cale> Sometimes they'll be better
19:40:27 <Cale> because there are rewrite rules
19:40:29 <autodidakto> Or at least, if Data-list were re-written there might be more folds?
19:40:38 <Cale> which will eliminate the construction of intermediate structure
19:40:39 <Cale> s
19:41:09 <Cale> Yeah, if Data.List were rewritten, it's possible that a lot of the low-level mess could be left out
19:41:18 <Cale> Maybe some of it is still relevant, you'd have to check
19:41:29 <shachaf> Cale: Doesn't GHC still have problems inlining recursive functions?
19:42:54 <autodidakto> I'm trying to make the connection between the exlusive use of recursion (instead of folds) and the points about optimization... Are you saying that recursion makes it easier to include that (now perhaps not necessary) low-level optimization code?
19:43:13 <Cale> yes
19:44:01 <autodidakto> Thanks :)
19:44:12 <autodidakto> That cleared up a lot
19:44:39 <Cale> Recursion is something you do in defeat -- either because you can't understand an algorithm well enough to pull it apart into higher order functions, or because you want to hand-optimise the operational details.
19:45:33 <autodidakto> Hmm. Food for thought.
19:45:48 <Cale> But with naively written code, often using the higher order functions is going to be faster, because 1) GHC has cleverly implemented versions of them and 2) there are rewrite rules which will collapse them and make more efficient code
19:47:12 <autodidakto> Gotcha. And that's the point of using a functional language in the first place, no? Higher order functions instead of messing with operational details, that is.
19:47:46 <Cale> yes
19:47:49 <autodidakto> I'm taking your words a bit out of context, but I think you get me
19:49:28 <ddarius> Ed has a better story than I do in this case for getting Cale gainfully employed.
19:50:40 <Cale> 48:30.75 is the new wr for any% realtime Super Metroid :)
19:51:29 <ddarius> I.e. the fastest time to beat Super Metroid while exploring as little of it as desired?
19:51:35 <Cale> yes
19:52:03 <djahandarie> Where do you work these days, ddarius?
19:52:09 <Cale> and measured using a wall-clock timer rather than the in-game timer (which doesn't tick during menus and item boxes)
19:52:16 <Cale> (and room transitions)
19:52:45 <Cale> Realtime is more interesting because room transitions and getting items count against you
19:54:48 <jfischoff> Cale: I would like to learn how to not use explicit recursion. Is there a good example of how to write a simple arithmetic evaluator with without explicit recursion?
19:55:11 <jfischoff> Cale: Also you should move SF :)
19:55:16 <ddarius> jfischoff: Just read about the general theory of folds.
19:55:36 <latro`a_> probably a dumb question: did System.Random move, and if so where?
19:55:40 <jfischoff> ddarius: just google that?
19:55:57 <Nereid> ~catamorphisms~
19:56:26 <Cale> jfischoff: Start by writing the catamorphism for your type -- a recursive function which replaces all the data constructors with other values throughout the structure.
19:57:25 <latro`a_> (I have a program that imports System.Random that compiles on an older version of GHC but not 7.4.2)
19:57:46 <Nereid> latro`a_: what's the error message?
19:57:57 <latro`a_> could not find module System.Random
19:58:09 <jfischoff> Cale: ok
19:58:11 <latro`a_> this is on a fresh install of GHC on windows, by the way
19:58:20 <latro`a_> (checking the version on my linux machine now)
19:58:20 <Nereid> do you have the random package installed?
19:58:28 <latro`a_> that would do it
19:58:36 <ddarius> djahandarie: Same place.  We're hiring, and in particular, the place I'm physically working is very eager to hire.
19:58:41 <latro`a_> now to learn how to get cabal on windows
19:58:55 <ddarius> latro`a: You install the platform.
19:59:01 <latro`a_> that would work too
19:59:06 <ddarius> Or you can just build it.
19:59:06 <latro`a_> should probably have done that in the first place
19:59:13 <shachaf> ddarius: Same place as what? Was it a defense contractor?
19:59:22 <djahandarie> ddarius, as opposed to the place you're mentally working?
19:59:53 <ddarius> djahandarie: As opposed to the mostly non-existent offices of my employer.
20:00:06 <djahandarie> Ah.
20:00:36 <djahandarie> Are they looking for someone to work on the crazy stuff you've done on top of the crazy stuff ed has done that probably 3 other people in the world are qualified to touch?
20:00:39 <ddarius> shachaf: I'm a contractor and I'm currently doing defense contract work albeit my employer doesn't solely do defense work.
20:01:07 <Cale> ddarius: Non-existent, or just "non-existent"? :)
20:01:25 <shachaf> Or perhaps "\"non-existent\""?
20:02:35 <ddarius> shachaf: Really I could do whatever I wanted to as long as I could find someone to hire me as a contractor through my employer at adequate rates.
20:03:07 <ddarius> In fact, since I'd like to give the west coast a try for a while, I'll probably be doing just that in a bit.
20:05:28 <ddarius> djahandarie: I think one of the more substantial things Ed worked on has almost been replaced, though I did work on it for a while.
20:07:07 <ddarius> djahandarie: I mostly don't do too crazy things, though I did try out a continuation monad using LINQ.  It needs a promise-like mechanism to increase parallelism but it served it's purpose fairly well.
20:07:35 <ddarius> The new async stuff in C# would obsolete it (thankfully.)
20:08:17 <djahandarie> That's sad to hear, it'd be funnier if you did crazy things.
20:08:28 <djahandarie> Though I guess your employer wouldn't find it that funny.
20:08:45 <shachaf> djahandarie: See, the west coast is the place to be. All the cool people are moving here.
20:08:57 <Ralith> west coast \o/
20:08:58 <djahandarie> You almost sold me there shachaf
20:08:59 <Ralith> best coast
20:09:01 <djahandarie> Almost
20:09:05 <djahandarie> Try again next time though
20:09:06 <ddarius> djahandarie: My employer wouldn't care as long as the client is happy.
20:11:10 <djahandarie> Oh. Try to use some research from an entirely unrelated field next project you do, then! "This is more elegently implemented using a topological quantum field theory, we'll have to do that."
20:11:40 <ddarius> I don't really care much for TQFT.
20:12:32 <djahandarie> I don't know much about it, aside from that it looks kind of cool. My physics knowledge is just totally not there to dive into the details though
20:12:51 <sordina> Hey guys. What was that package that uses a directory structure as a template?
20:13:19 <ddarius> djahandarie: I may inch people toward FRP techniques for certain new projects.
20:13:36 <ddarius> Though I'm more interested in general constraint systems for this area
20:16:45 <ddarius> shachaf: I'll probably only be on the west coast (if at all) for a few years at most, unless I really like it, in which case I'll still leave in a few years but I may come back later.
20:18:41 <djahandarie> I'd like to go to the west coast, but only because the weather there is nicer.
20:18:55 <jfischoff> eh, not in SF
20:19:08 <ddarius> djahandarie: Go to Hawaii.
20:19:14 <shachaf> Or in WA!
20:19:20 * shachaf is currently ~2 hours from Seattle.
20:19:41 <ddarius> (I guess I could just solve for a particular time/frequency then the problem should be easier...)
20:19:42 <Ralith> oh hey
20:19:43 <Ralith> me too
20:19:52 * Ralith waves at shachaf 
20:20:13 <shachaf> hi Ralith
20:20:20 <shachaf> ~2 hours in which direction?
20:20:28 <Ralith> presently? Northeastish.
20:20:32 <Ralith> interning at MS
20:20:37 <shachaf> Oh.
20:20:37 <ddarius> The real question is by which mode of transportation.
20:20:46 * BMeph is currently at the opposite end of I-5 from Seattle...
20:21:03 <shachaf> Anyway I'll be going back to the bay area in a couple of weeks.
20:21:12 <Ralith> traitor
20:21:38 <djahandarie> Unfortunately Hawaii lacks the employement opportunities that some places on the west coast have
20:21:55 <shachaf> djahandarie: newsham is in Hawaii!
20:22:25 <BMeph> San Diego has great weather, and nice employment opportunities. Just saying... ;)
20:22:42 <djahandarie> That's true. He has a wikipedia article though, I'm not that cool.
20:24:04 <shachaf> http://en.wikipedia.org/wiki/DJ_Ahandarie
20:24:16 <shachaf> I guess not.
20:25:01 <djahandarie> I guess I need to do more concerts and stuff.
20:25:30 * hackagebot type-level-natural-number-induction 1.0.0.1 - High-level combinators for performing inductive operations. (GregoryCrosswhite)
20:30:39 <Cale> You could always just start a Darius Jahandarie Wikipedia article. Make posts to arxiv.org to use for citations.
20:31:19 <shachaf> You should add an initial initial to your name to sound more legitimate.
20:31:22 <shachaf> D. Darius Jahandarie
21:30:33 * hackagebot dynamic-linker-template 0.1.0.0 - Automatically derive dynamic linking methods from a data type. (SylvainHenry)
21:50:22 <tgeeky__> whoa, what?
21:50:23 <tgeeky__> cool
22:03:34 <The_Aristocat> hello?
22:06:48 <copumpkin> The_Aristocat: hi
22:07:50 <The_Aristocat> I am new to computer languages, and was just wondering what Haskell is primarily used for
22:08:01 <dmwit> Haskell is good for what ails ya.
22:09:11 <The_Aristocat> how does Haskell differ from Python or C++ (really any other language)
22:09:41 <dmwit> Haskell is strongly typed, functional, and lazy.
22:09:53 <popl> The_Aristocat: Visit the URI in the title to learn about the language.
22:10:02 <popl> The_Aristocat: Look it up on Wikipedia for a broader overview.
22:10:03 <dmwit> Python is duck-typed and strict; C++ is imperative and strict.
22:10:34 <dmwit> -strict +eager maybe
22:11:45 <The_Aristocat> should i begin with C++
22:11:53 <latro`a_> begin what
22:11:55 <popl> by strict do you mean strong, dmwit?
22:12:14 <latro`a_> er, no, strictness is about evaluation, not typing
22:12:32 <EvanR> python is pretty imperative
22:12:36 <popl> Oh right
22:12:52 <The_Aristocat> begin as in which language to start off with
22:12:53 <popl> I thought he was talking about typing there.
22:13:03 <EvanR> i need help understanding this thing i wrote
22:13:22 <EvanR> data Dialog a = Answer a | Question String (String -> Dialog a)
22:13:51 <EvanR> Question "what" (\a1 -> Question "who" (\a2 -> Answer (f a1, f a2)))
22:14:00 <EvanR> now i can have a dialog with the user
22:14:06 <EvanR> but its not a monad
22:14:09 <EvanR> wtf
22:14:42 <EvanR> f1 a1, g a2 *
22:14:46 <EvanR> f*
22:14:58 <The_Aristocat> whats a good language to learn first
22:15:52 <popl> The_Aristocat: http://mitpress.mit.edu/sicp/
22:16:04 <popl> That one.
22:16:17 <EvanR> scheme is ok but may not help with haskell
22:16:25 <EvanR> its dynamic and strict
22:16:27 <popl> He's not looking for help with Haskell.
22:16:33 <EvanR> and impure
22:16:44 <popl> He wants to learn to program. Scheme is a great introduction to programming.
22:16:58 <popl> :)
22:17:03 <latro`a_> there are a lot of good places to start, but to some extent it depends on where you want to end up
22:18:26 <colock> learnpythonthehardway
22:18:42 <colock> not only teaching python, but also all the things around programming
22:19:02 <colock> i.e. typing, spot differences, being accurate, etc
22:19:17 <The_Aristocat> Im not sure where this will take me, I've just been playing around with terminal and want to learn more about computer languages
22:19:32 <mauke> I'd start with Haskell
22:19:32 <The_Aristocat> scripts w/e
22:19:38 <colock> mauke: :]
22:20:03 <colock> I would start with Haskell if I also have math & formal languages interests
22:20:08 <colock> (which I personally do)
22:20:24 <popl> w/e?
22:20:38 <colock> what ever?
22:20:38 <The_Aristocat> "whatever"
22:20:53 <popl> Yes, I just looked it up. :P
22:21:03 <colock> i just guessed :P
22:21:12 <colock> week-end seemd so out of context
22:21:29 <popl> I don't like to assume.
22:21:40 <The_Aristocat> haha, nor do i
22:21:53 <colock> i don't like to, but I do all the time :/
22:22:06 <popl> You know what they say about assuming.
22:22:17 <The_Aristocat> no what??
22:22:20 <colock> popl: what they say?
22:22:33 <colock> usually wrong?
22:22:37 <mauke> presuming makes a pres out of u and ming
22:22:54 <popl> mauke: Defenders of the Earth?
22:22:55 <colock> mauke: who says that?
22:22:58 <hpaste> EvanR pasted âdialog, monad like?â at http://hpaste.org/71984
22:23:27 <EvanR> basically im wondering if theres a better way to write these
22:23:36 <ddarius> dmwit: "eager" > "strict"
22:23:48 <geekosaur> you've seen MonadPrompt?
22:23:56 <ddarius> Of course, "non-strict" > "lazy"
22:24:14 <EvanR> geekosaur: nope
22:24:16 <popl> The_Aristocat: Do you know what a programming language is, and how it is different from a markup or scripting language?
22:24:26 <Nereid> ddarius: if > means "implies", then sure, and those two are logically equivalent. :)
22:24:32 <mauke> popl: I don't, actually
22:24:53 <The_Aristocat> no.... what is it?
22:24:57 <ddarius> Nereid: It doesn't mean "implies" and those are not logically equivalent at all.
22:24:58 <colock> mauke: :)
22:25:13 <Nereid> ddarius: ok, I'm not sure what > means, then
22:25:14 <popl> mauke is calling me out. :(
22:25:15 * ddarius doesn't know how a programming language is different from a scripting language.
22:25:17 <EvanR> geekosaur: now i have
22:25:20 * Nereid either
22:25:34 <EvanR> haskell is a scripting language based on python
22:25:36 <colock> ddarius: turing completeness?
22:25:42 <latro`a_> lol based on python
22:25:44 <ddarius> Nereid: For the phrases and context dmwit was using "eager" and "non-strict" are better words than "strict" and "lazy"
22:25:45 <geekosaur> the line is fuzzy.  shell, sure.  perl?  python? (for that matter:  runhaskell)
22:25:56 <popl> yes geekosaur
22:26:08 * ski . o O ( "Douglas Fredericks & The House Of They" <http://www.comicbookresources.com/?page=preview&id=2784> )
22:26:10 <ddarius> I'm not aware of any language called commonly a "scripting language" that is not Turing complete.
22:26:11 <Nereid> ddarius: oh I didn't see that.
22:26:12 <popl> Although some languages are clearly scripting languages.
22:26:23 <colock> ddarius: html is a markup language
22:26:25 <mauke> define "scripting language"
22:26:28 <EvanR> popl: not really
22:26:28 <colock> it is not turing complete afaik
22:26:35 <ddarius> colock: I didn't say anything about markup languages.
22:26:36 <EvanR> except by democratic consensus
22:26:40 <Nereid> html does not have a sense of turing completeness
22:26:46 <Nereid> since it does not have a sense of computation
22:26:47 <ski> wb ddarius
22:27:02 <Nereid> any programming language worth speaking of is turing complete
22:27:04 <EvanR> html is still declarative
22:27:13 <ddarius> Nereid: Some would disagree.
22:27:15 <mauke> Nereid: [citation needed]
22:27:17 <Nereid> perhaps.
22:27:26 <Nereid> in any case, html is a document description language.
22:27:40 <colock> then, popl, let's just leave markup languages out
22:27:45 <popl> But my overall suggestion was going to be that since The_Aristocat didn't know the difference (or potential overlap) of some of these things, he/she should read about what a programming language is on Wikipedia or something (since he/she expressed an interest in learning about programming languages specifically).
22:28:09 <ddarius> [cite http://tunes.org/~nef/logs/haskell/12.07.22]
22:28:11 <BMeph> Is awk TC?
22:28:15 <ddarius> BMeph: Yes.
22:28:27 <mauke> popl: I still don't know what a scripting language is
22:28:28 <colock> The_Aristocat: learnpythonthehardway is abook, is free to read online as html. it teaches you how to program, not just a programming language
22:28:30 <BMeph> ddarius: Sweet! =8*O
22:28:31 <popl> colock: I was using it as an example.
22:28:49 <colock> it's really for beginners and it's worth it
22:28:52 <EvanR> "html is not a programming language because it doesnt have global mutable variables, statements which modify them and cause effects, and no looping mechanism"
22:28:55 <The_Aristocat> !!!thank you
22:28:56 <Nereid> colock: too bad it's python
22:29:02 <colock> Nereid: i know :/
22:29:16 <popl> mauke: Perl is a scripting language.
22:29:18 <popl> :P
22:29:24 <EvanR> and python isnt a programming language because it doesnt have goot
22:29:26 <Nereid> EvanR: I guess haskell isn't a programming language either!
22:29:27 <mauke> popl: I still don't know what a scripting language is
22:29:27 <EvanR> or goto
22:29:35 <Nereid> I know what a scripting language.
22:29:37 <colock> nothing stops you to just go through a few chapters of it to get used to text editors and typing and spot errors etc
22:29:41 <Nereid> you show me a language, I tell you if it's a scripting language.
22:29:43 <colock> and then pick up some haskell books
22:29:48 <Nereid> s/if/whether or not/
22:29:56 <mauke> Nereid: Piet
22:30:03 <EvanR> malbolge
22:30:21 <popl> mauke: It's what doctors use to fill out prescription forms.
22:30:26 * ddarius (re)defines Nereid to be const "Not a scripting language."
22:30:38 <Nereid> ddarius: Done.
22:31:13 <maurer> Nereid: "test"
22:31:19 <Nereid> Not a scripting language.
22:31:57 <mauke> my favorite language is cat. every program in it is a quine
22:32:08 <Nereid> I would define a scripting language as a language for writing scripts.
22:32:16 <mauke> define "scripts"
22:32:26 <ddarius> Nereid: I typically use English for that.
22:32:32 <popl> The_Aristocat: People give you shit when you talk bollocks. Remember that. Let me be a lesson to you.
22:32:34 <ddarius> Admittedly, I don't often write scripts.
22:32:52 <mauke> ddarius: do you also use English for programs?
22:33:03 <popl> I use Slackware and this entire distribution is held together with shell scripts. :P
22:33:06 <ddarius> mauke: No.
22:33:11 <Nereid> actually I'm not entirely unsatisfied with the Wikipedia definition.
22:33:28 <Nereid> I agree that the distinction is very vague.
22:33:32 <BMeph>  I'm not entirely unsatisfied with the Wikipedia
22:33:48 <EvanR> geekosaur: i was really hoping there was something less sophisticated
22:33:51 <ddarius> The "distinction" is more harmful than useful.
22:33:52 <popl> Nereid: I knew I was going to get mocked when I brought it up, but I did it anyways.
22:33:54 <beekor> I'm trying to get [2,8,1,2] to be 2812, and i'm a lost beginner and not even sure how to search for this.  any suggestions ?
22:34:08 <Nereid> concat . map show
22:34:11 <mauke> beekor: const 2812
22:34:23 <The_Aristocat> pople: thats for all the help
22:34:30 <mauke> Nereid: concatMap
22:34:31 <The_Aristocat> popl*
22:34:39 <Nereid> or concatMap show
22:35:00 <Nereid> or (>>= show)
22:35:02 <mauke> read . map intToDigit
22:35:20 <Nereid> oh, and then read
22:35:38 <mauke> foldl' (\z x -> z * 10 + x) 0
22:35:39 <ddarius> Nereid: As far as I can tell the definition of "scripting language" applies to all programming languages and then some (those those extra are rarely called "scripting languages").
22:35:48 <beekor> okay then.  thanks !
22:35:57 <Nereid> yes, I was going to suggest a fold next.
22:36:33 <ddarius> beekor: Why are you trying to search for something?  What would you even be searching for?
22:36:44 <Nereid> @hoogle [Int] -> Int
22:36:45 <lambdabot> Prelude head :: [a] -> a
22:36:45 <lambdabot> Data.List head :: [a] -> a
22:36:45 <lambdabot> Prelude last :: [a] -> a
22:36:54 <beekor> searching for help on the Googlie, i did mean, dd
22:37:29 * geekosaur thinks scripting is less a language style than a programming style
22:37:52 <geekosaur> you can script in C, and I've seen my share of programs that did so...
22:38:21 * ddarius thinks trying to move the "distinction" around does not change its harm/value quotient.
22:39:08 <EvanR> its not a technical difference, its a cultural difference
22:39:22 <EvanR> yes culture is meaningless get over it
22:39:34 <ddarius> EvanR: I don't agree that its even a cultural difference.
22:39:40 <ddarius> What are the two cultures?
22:39:45 <EvanR> there are many cultures
22:40:18 <ddarius> I'm pretty sure every programmer has written "scripts."  Is every programmer now part of the "scripting" culture?
22:40:22 <EvanR> god means this to one, something else to another, and doesnt exist to yet another ;)
22:41:06 <scopedTV> I'd consider a "script" a "program written in an embedded/domain specific language"
22:41:16 <ddarius> EvanR: Also, I wasn't complaining that it was (just) meaningless, but that it was a "distinction" conferring more harm than benefit (though I haven't said why at this point.)
22:41:32 <scopedTV> That is still very vague.
22:41:52 <EvanR> scopedTV's version would eliminate all the standard scripting languages from being able to produce scripts
22:42:05 <scopedTV> right, I wouldn't consider "a python program" a script
22:42:19 <Nereid> "scripting language" is a horrible term
22:42:20 <EvanR> my case is made
22:42:23 * EvanR leaves the building
22:42:33 <popl> FOLDOC defines a scripting language as "a loose term for any language that is weakly typed and has little or no provision for complex data structures."
22:42:35 <scopedTV> however, if you embed python in your app, you can use it as a scripting environment
22:42:36 <popl> Hrm.
22:42:41 <scopedTV> I don't think it's a particularly useful definition.
22:43:11 <EvanR> scopedTV: heh. all those MUDs which embedded a weird dialect of C
22:43:20 <popl> It gives MS-DOS batch files as an example.
22:43:20 <Nereid> popl: sounds like python
22:43:22 <Nereid> ;>
22:43:23 <mauke> popl: "weakly typed" is as bad as "scripting language"
22:43:34 <scopedTV> mauke: why?
22:43:45 <mauke> scopedTV: don't ask me, I didn't invent the terms
22:44:05 <copumpkin> EvanR: tanking
22:44:07 <copumpkin> oh wait
22:44:08 <scopedTV> why do you consider "weakly typed" bad, as nomenclature?
22:44:10 <copumpkin> EvanR: rallymode
22:45:28 <mauke> scopedTV: because it means nothing, just like "scripting language"
22:45:42 <ski> i thought "weakly typed" meant you could write programs which invoke UB
22:45:57 <mauke> ski: ... like Haskell?
22:45:58 <ddarius> ski: That's one definition among many.
22:46:20 <Nereid> UB?
22:46:35 <scopedTV> mauke: a "weak type system" allows many type coercions
22:46:37 <ski> mauke : if you include `unsafePerformIO',`unsafeIndex',&c., then yes
22:46:45 <scopedTV> Nereid: Undefined behavior.
22:46:49 <mauke> scopedTV: that's not a definition
22:47:30 <mauke> ski: do you count _|_ as undefined?
22:47:36 <ski> mauke : nope
22:48:10 <ski> ddarius : i'm aware some use the term differently (i'm not sure how exactly), but the UB one is the one which to me seemed the useful one
22:48:34 <scopedTV> I don't see the essential relation between UB and the type system
22:48:52 <scopedTV> Sure, for unsafePerformIO, but unsafeIndex?
22:49:03 <mauke> ski: why not just call it "unsafely typed" then?
22:49:06 <ski> scopedTV : the link is that UB in typical implementations can be used to subvert the type system
22:49:29 <ski> mauke : tradition, i suppose. that term might be clearer
22:49:43 <ddarius> ski: I agree.  It's the one I interpret "weakly typed" to mean when people say it, but it is quite evident that people use the term to also mean "untyped"/"dynamically typed" as well as arbitrary discriminations within that category (e.g. Forth is often called "weakly typed" and not because of the potential to cause undefined behavior.)
22:49:50 <mauke> ski: except I'm unaware of a tradition where "weakly typed" means that
22:50:13 <scopedTV> ski: in e.g. C there are many other examples of UB
22:50:39 <scopedTV> ski: not only things like  union { int i; float f; } u; u.i = 3; float f = u.f;
22:50:53 <ski> scopedTV : yes, e.g. accessing outside an array, or even making a pointer to outside an array (except the cell after the last "real" cell)
22:51:27 <ski> scopedTV : using that, you can in many implementations overwrite other parts of memory, subverting the type system
22:51:45 <popl> I think I prefer the term unsafe as opposed to weak.
22:51:59 <ski> ddarius : i agree
22:52:09 <scopedTV> I'd think the most commonly used argument is "JavaScript is weakly typed because 42 + "37" yields 79." I'm not sure how to generalize this.
22:52:17 <ski> mauke : iirc, it's been used in that sense on LtU, at least
22:52:31 <scopedTV> popl: agreed
22:52:42 <ddarius> instance Num String where (+) = (++); fromInteger = show
22:53:04 <ddarius> Or instance IsString Integer where fromString = read
22:53:22 <mauke> > foldr (\x z -> z*10 + 5/6*x*x - 17/2*x + 47/3) 0 [2,8,1,2]
22:53:24 <lambdabot>   2812.0
22:53:29 <mauke> so how about them apples?
22:54:04 <beekor> i'll uhh.  umm
22:54:23 <popl> mauke: I'm allergic to apples.
22:54:51 <ddarius> mauke: It'd be more interesting if you used z in a non-affine manner.
22:55:08 <mauke> I'm not hardcore enough to know what that even means
22:55:57 <mauke> I was happy enough to have solved the equations for mapping the digits with pen and paper
22:57:03 <popl> but I thought mauke was omniscient... :(
22:57:36 <ddarius> popl: mauke doesn't even know what "scripting language" means.
22:57:43 * popl tears down the poster from his wall
22:58:12 <mauke> http://mauke.hopto.org/exe/jslinenc?I+just+know+a+few+things+I+repeat+over+and+over.
22:58:32 <ddarius> mauke: That's my secret too.
22:58:47 <popl> This is really going to affect my daydreams. Thanks a lot mauke.
22:59:16 <dmwit> Oh my goodness, it's ddarius.
23:00:03 <popl> dmwit: I know that song, The Age of ddarius isn't it?
23:00:10 <ski> scopedTV : you might find John Regehr's "Compilers and Termination Revisited" (follow-up to "C compilers Disprove Fermatâs Last Theorem") in 2010-06-07 at <http://blog.regehr.org/archives/161>, "A Guide to Undefined Behavior in C and C++, Part 1" in 2010-07-09 (also parts two (23) and three (30)) at <http://blog.regehr.org/archives/213>, and "Contest: Craziest Compiler Output due to Undefined Behavior" in 2012-07-12 at <http://blog.regehr.or
23:00:27 <ski> cut off near ".. and "Contest: Craziest Compiler Output due to Undefined Behavior" in 2012-07-12 at <http://blog.regehr.org/archives/759> interesting, re UB"
23:00:35 <scopedTV> Thanks, ski.
23:02:03 <ddarius> "also there is good reason to believe this theorem cannot be disproved"
23:02:33 <ddarius> Even C programmers have higher standards of rigor than mathematicians.
23:02:37 <dmwit> If it hasn't been proven, is it still okay to call it a theorem?
23:03:17 <ddarius> FLT was called a theorem far longer than it was proved.
23:03:41 <mauke> .oO( faster-than-light travel? )
23:03:46 <Nereid> it was claimed to have been proved for a long time though.
23:04:08 <ddarius> Though yes, I noticed that subtlety too, where, technically the statement is an oxymoron.
23:04:34 <Nereid> mathematicians didn't really consider it a theorem until it was actually proved though.
23:04:35 <popl> Whenever someone mentions FLT I have to stop to consider whether they mean last or little.
23:04:38 <Nereid> it was just a name.
23:04:44 <Nereid> it always means last.
23:05:05 <scopedTV> popl: It's clear from the context. I don't think I've seen it used for the little theorem though.
23:05:16 <mauke> FlT
23:05:22 <scopedTV> lol
23:05:26 <ddarius> scopedTV: It is used when you are reading texts that use it quite a bit.
23:05:35 <Nereid> Fermat's little theorem is a special case of other things though.
23:06:23 <Nereid> much more general things.
23:07:02 * ski . o O ( "Fermat's Last Margin" <http://www.scannedinavian.com/~shae/blog/2004-12-01.html> )
23:07:38 <popl> I only got as far as Euler's theorem.
23:07:50 <popl> I know there are other generalizations though.
23:07:56 <Nereid> I was thinking Lagrange's theorem.
23:08:42 <scopedTV> about the indices of subgroups of subgroups?
23:08:44 <popl> Nereid: Which one?
23:08:52 <Nereid> the groups one.
23:09:02 <popl> thanks
23:12:06 <ddarius> popl: You ask "which one" after referring to "Euler's theorem"?
23:12:15 <Nereid> Lagrange.
23:12:28 <Nereid> apparently there are multiple Lagrange's theorems.
23:13:20 <ddarius> Nereid: I meant what I said.
23:13:33 <Nereid> I know.
23:13:47 <Nereid> but I'm not sure why you said it.
23:13:52 <popl> According to Mathworld, there are.
23:14:58 <Nereid> you had to remind me mathworld exists, didn't you. :p
23:16:22 <popl> That's interesting.
23:17:44 <popl> Nereid: Don't blame me for your mental processes. :P
23:18:00 <Nereid> I'm always looking for someone to blame.
23:18:14 <mauke> git can help you
23:18:22 <Nereid> I use hg :(
23:18:39 <popl> Nereid: You might consider a career in politics.
23:18:55 <Nereid> That might not be good for my sanity.
23:19:11 <mauke> will there be a sanity clause?
23:19:39 <popl> You would have a seemingly endless source of scapegoats.
23:20:05 <Nereid> I'd have endless sources of other things too.
23:21:13 <scopedTV> Nereid: hg blame also exists.
23:21:29 <Nereid> I don't use hg very much :(
23:21:32 <popl> Who needs sanity when you're wealthy?
23:21:59 <ddarius> Hg is a neurotoxin.
23:22:44 <popl> Hg is the chemical symbol for mercury. </pedant>
23:24:33 <ddarius> popl: And "mercury" is a textual symbol for mercury.  I'm not sure how to communicate actual that which is referred to by mercury over IRC.
23:24:47 <popl> ddarius: Neither do I.
23:24:58 <Nereid> easy, don't quote it.
23:26:21 <ddarius> I didn't quote Hg.
23:26:44 <ddarius> Or I should've said, "I didn't quote 'Hg'."
23:27:20 <mauke> <quote>where is your god now?</unquote>
23:27:33 <popl> I've quoted HHGTTG.
23:28:40 <popl> I don't know if you would consider that to be neurotoxic.
23:31:51 <ddarius> <quote><![CDATA[where is your god now?]]></unquote>
23:40:20 <crappola> fucking niggers
23:40:25 <crappola> i am going to kill snardbafulator
23:40:29 <crappola> oh yeahhh
23:40:35 <crappola> that fucking incompetent op in ##philosophy
23:40:48 <chu> !ops
23:40:57 <roconnor_> @where ops
23:40:58 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:40:58 <Corey> chu: Pay better attention, please.
23:41:04 --- mode: ChanServ set +o copumpkin
23:41:09 <chu> Corey: Sorry :)
23:41:13 --- mode: copumpkin set -o copumpkin
23:41:19 <crappola> you fucking kline me?
23:41:21 --- mode: ChanServ set +o copumpkin
23:42:04 --- mode: copumpkin set +b *!*ggallin*@*
23:42:06 --- mode: copumpkin set -o copumpkin
23:42:40 <shachaf> copumpkin++
23:43:32 <Enigmagic> apparently someone doesn't know what a k-line is.
23:44:00 <shachaf> ?
23:44:04 <js__> Does anyone know if c2hs is supposed to work from windows under cygwin? I just get a c2hs.exe: permission denied.
23:44:13 <Enigmagic> "<crappola> you fucking kline me?"
23:44:30 <shachaf> Enigmagic: That was from a different host.
23:44:42 <ddarius> js__: It should work fine.
23:44:54 <Enigmagic> shachaf: k-lines are bans from a server
23:44:59 <Enigmagic> not to a particular channel
23:45:27 <shachaf> On Freenode they're bans from the network.
23:45:52 <roconnor_> Enigmagic: juping is the right term?
23:46:02 <js__> ddarius, Do you get any idea from my problem how to troubleshoot ? (I have little or no windows experience)
23:46:13 <shachaf> But I assumed it was a Freenode person in this channel. Anyway, who knows.
23:46:35 <Enigmagic> roconnor_: i dunno, they were always referred to as k-lines on efnet
23:46:59 <ddarius> js__: It sounds more like a unix error where c2hs.exe doesn't have execute permissions.
23:47:07 <ddarius> I forget if cygwin goes that far.
23:47:13 <roconnor_> Enigmagic: I mean to ban a person on a channel would be juping ... anyhow, clearly it isn't commonly used.
23:47:27 <ddarius> Of course, you may also just not have permissions to that file or it couldn't find it or some such.
23:47:37 * roconnor_ goes ahead and deletes the paragraph on wikipedia :P
23:48:08 <Enigmagic> roconnor_: yah i haven't heard that used at all.. but i've spent most of my life on efnet
23:48:16 <ddarius> js__: You should probably use mingw anyway.
23:48:25 <Enigmagic> sad as efnet is nowadays :P
23:48:34 <ddarius> EFNet wasn't sad before?
23:48:37 <js__> ddarius, I can execute c2hs --help and get the help output. but when I run it on an actual .chs file the "permission denied" happens. I guess c2hs launches a bunch of other programs while running though.
23:48:42 <Enigmagic> in 92 it was awesome.
23:48:51 <Enigmagic> i was also 12.
23:49:20 <roconnor_> actually z-line is probably more appropriate
23:49:33 <popl> When I was younger I remember thinking that some things were much larger than they appear to be now.
23:49:55 <js__> ddarius, mingw. I see. I must look into that. thanks.
23:50:01 <roconnor_> hmm
23:50:04 <roconnor_> anyhow
23:50:06 <ddarius> I might have joined EFNet briefly when I was 12 which was after '92.  It apparently wasn't awesome enough then to have me not not use IRC for several years.
23:50:11 <roconnor_> haskell++
23:51:04 <kulin> Is there a typeclass for a 2 dimensional Ord?
23:51:17 <roconnor_> kulin: Ix is close
23:51:35 <ddarius> kulin: Why would there need to be and what would it mean?
23:52:50 <Enigmagic> ddarius: you may have had a more enjoyable life at 12 than i did
23:52:52 * ddarius thinks he will parallel NEC using GA.
23:53:00 <ddarius> Enigmagic: I highly doubt that.
23:53:01 <kulin> ddarius, i would be using it to help find a path in a sorted tree, but it would essentially be something that described if something was >, <, = on both the x and y plane
23:53:39 <roconnor_> kulin: you will have to compare coordinates yourself I think.
23:53:40 <ddarius> And if x1 < x2 and y1 > y2 ?
23:53:54 <kulin> then you get, type x>, y<
23:54:11 <ddarius> Sounds like all you want is compare &&& compare
23:54:35 <roconnor_> @type compare &&& compare
23:54:37 <lambdabot> forall b. (Ord b) => b -> (b -> Ordering, b -> Ordering)
23:54:47 <ddarius> Doh.
23:54:51 <roconnor_> ddarius: I don't think binary functions &&& nicely
23:55:06 <ddarius> roconnor_: Depends on your definition of binary.
23:55:55 <kulin> i guess the result could even be something like quadrants
23:56:00 <shachaf> @ty complement &&& (.&. 0x08)
23:56:02 <lambdabot>     Ambiguous occurrence `.&.'
23:56:02 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
23:56:02 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
23:56:07 <kulin> i guess ill just make something up then, was just curious what existed
23:56:42 <ddarius> I didn't want (&&&) anyway.
23:57:32 <ddarius> @pl \(x1, y1) (x2, y2) -> (compare x1 x2, compare y1 y2)
23:57:33 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. compare) . flip . (((.) . (,)) .) . compare)
23:58:22 <c_wraith> :t join (***) compare
23:58:24 <lambdabot> forall b. (Ord b) => (b, b) -> (b -> Ordering, b -> Ordering)
23:58:36 <c_wraith> oh, that's all wrong.  heh.
23:58:53 <c_wraith> well, it's half-right.
23:59:06 <ski> @type curry ((uncurry compare *** uncurry compare) . ((fst *** fst) &&& (snd *** snd)))
23:59:07 <lambdabot> forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> (Ordering, Ordering)
