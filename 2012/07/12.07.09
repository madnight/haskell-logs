00:00:53 <hpaste> fuchsto pasted “if/else in do-block” at http://hpaste.org/71122
00:01:03 <crutcher> http://trac.haskell.org/haskell-platform/ticket/189
00:01:11 <crutcher> applicative: yes, I used the regular installer
00:01:15 <fuchsto> blackdog: Pasted.
00:01:15 <fmap> LK4D4: i'm not a parsec expert but something like `(many (try (manyTill anyChar (try (char '%'))) <|> many1 anyChar))' should work
00:01:26 <crutcher> it suggested that I run uninstall-hs to clear out the old installs
00:02:24 <mroman> hm.
00:02:28 <mroman> Did they remove comparing?
00:02:34 <mroman> @hoogle comparing
00:02:35 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
00:02:45 <mroman> or move it.
00:02:48 <applicative> crutcher: I think -fllvm has worked fine for the last couple versions of the haskell platform.
00:03:18 <fmap> LK4D4: if you always have ending `%' then `(many (manyTill anyChar (try (char '%'))))' would be enough
00:03:41 <applicative> ghc --version says 7.4*?
00:04:44 <crutcher> 7.4.1
00:05:16 <crutcher> at this point, I think I'm going to uninstall my macports and haskell installs; and try a clean install, rather than an upgrade
00:05:19 <applicative> hm  is llc available?
00:06:00 <mroman> @pl (\s -> (length . show s, show s))
00:06:00 <lambdabot> ap ((,) . (length .) . show) show
00:06:14 <gww> hi,everyone
00:06:21 <applicative> llc --version and the like work
00:06:34 <applicative> hi gww
00:06:37 <mroman> map f $ map g is the same as map f.g, right?
00:06:39 <gww> :)
00:07:14 <archeyDe1il> LOL!! Somehow.. I just crashed my computer with complex math (just testing ghci) :P
00:07:34 <fmap> mroman: that's (length . show &&& show)
00:07:36 <archeyDe1il> Worked faster than a forkbomb :P
00:08:07 <fmap> and yes, `map f . map g' ≡ `map (f . g)'
00:08:14 <mroman> shortest term = minimumBy (comparing fst) . map ((\s -> (length s, s)). show) $ rewrites term
00:08:32 <mroman> I had map (\s) ... . map show before that.
00:08:46 <mroman> but it's still quite a long line.
00:09:09 <JoeyA> Micro-optimization question: when building a list through a series of appends, is it faster to build a difference list and apply it to [], or build a regular list and reverse it?
00:09:11 <crutcher> applicative: llc is not available
00:09:32 <mroman> (\s -> (length s, s)) is probably length &&& id ?
00:09:41 <mroman> > (length &&& id) "foo"
00:09:42 <lambdabot>   (3,"foo")
00:09:45 <mroman> yay.
00:10:23 <applicative> wait a minute, crutcher mine *is* in /usr/local/bin I cant believe thats what -fllvm is using though
00:10:29 <applicative> maybe it is?
00:11:19 <HugoDaniel> thanks for all the support
00:11:25 <HugoDaniel> im going to sleep something now :)
00:11:31 <HugoDaniel> xau xau
00:12:09 <applicative> isn't there some sort of #ghc irc, maybe you can ask them tomorrow crutcher
00:12:20 <mroman> there is #ghc on freenode.
00:12:23 <crutcher> wiped macports and hp; trying again
00:12:29 <crutcher> applicative: thanks again
00:13:40 <LK4D4> fmap, thank you very much
00:13:53 <mroman> Cool. Now I can find the shortest possible simplification of a term.
00:14:25 <applicative> i wonder if you need an independent install of llvm to get something ghc can call as llc if thats what it's doing?  This  doesn't seem right, but I dont know how -fllvm works
00:14:38 <applicative> though  I use it all the time  :)
00:14:59 <JoeyA> > (first length) "foo"
00:14:59 <lambdabot>   Couldn't match expected type `([a], d)'
00:14:59 <lambdabot>         against inferred type `[GHC...
00:16:00 <mroman> JoeyA: first takes a tupel.
00:16:14 <mroman> > (first length) ("12","123")
00:16:15 <lambdabot>   (2,"123")
00:16:20 <JoeyA> Ah
00:17:27 <smplx> I wonder if there is a way of not letting show to defile Chars and Strings.
00:17:32 <Enigmagic> applicative: hmm? i think ghc just uses whatever llc/opt are in the path
00:17:45 <dmwit> smplx: Yes, don't call it.
00:17:47 <blackdog> fuchsto: can't see if anyone else replied - you need to put the "then" on the next line
00:18:11 <dmwit> > (['a'], "no need to call show if it's already a String and that's all you wanted, eh?")
00:18:13 <lambdabot>   ("a","no need to call show if it's already a String and that's all you want...
00:18:42 <smplx> dmwit: It would be nice to use the rest of it's functionality though, since it does what i want for the other types.
00:18:49 <oka> help
00:19:51 <dmwit> smplx: Write a typeclass like class Show a => PPrint a where pprint :: a -> String; pprint = show
00:20:02 <dmwit> smplx: Then override the default instance for Char and String.
00:20:26 <smplx> Thanks, i'll try that out.
00:20:45 <dmwit> oka: You need to ask a question if you want help.
00:20:50 <hpaste> “Joey Adams” pasted “Listing CRC-32 collisions (demonstrates Arrow combinators)” at http://hpaste.org/71123
00:21:40 <JoeyA> This code is pretty elegant (thanks mroman for mentioning &&&), but can I do better?
00:22:10 <JoeyA> First of all, would this be a good place to use arrow notation?
00:22:15 <oka> fst
00:22:29 <JoeyA> (looking at collisionGroups)
00:22:52 <oka> <JoeyA>Delete
00:23:09 <JoeyA> ?
00:23:19 <oka> delete
00:23:49 <JoeyA> What about it?
00:23:51 <JoeyA> :t delete
00:23:53 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
00:23:57 <applicative> Enigmagic: yes I guess thats what we are realizing, you need to install llc via macports or homebrew or whatever on os x?
00:24:12 <dmwit> JoeyA: You can get rid of line 19; group(By) guarantees non-empty sublists.
00:24:13 <oka> im windows not mack
00:24:14 <Enigmagic> applicative: or you can just download the binary tarball from llvm.org
00:24:37 <oka> wkwkwk
00:24:50 <JoeyA> dmwit: I'm deleting groups with only 1 sublist.
00:24:56 <JoeyA> err, only one item.
00:25:01 <JoeyA> So groups that have 2 or more items.
00:25:03 <oka> ?
00:25:12 <oka> ok
00:25:18 <dmwit> JoeyA: ah, so you are
00:25:24 <oka> oka
00:25:41 <oka> t: delete
00:25:58 <applicative> yes, but there are llvm things all over these macs Enigmagic
00:26:22 <oka> _root__br_
00:27:07 <oka> http://webchat.freenode.net/?channels=haskell&uio=Mz1mYWxzZSYxMD10cnVlJjExPTI0Nge9#
00:27:28 <Enigmagic> applicative: the llvm versions on llvm.org don't match up with whatever comes with xcode.
00:28:26 <dmwit> JoeyA: Overall looks pretty sane to me
00:28:34 <Enigmagic> applicative: i don't know if the version checks that GHC performs will work correctly with the xcode versions either (i haven't tried).
00:28:35 <applicative> yes, but is it made clear in e.g. Haskell  platform docs that you need an independent llvm? Maybe it used to be clear
00:29:04 <Enigmagic> applicative: i don't know, xcode didn't used to come with any llvm bits
00:29:05 <applicative> I'm not seeing an llc anywhere except my 'homebrew' one.
00:29:29 <JoeyA> dmwit: Thanks for the input
00:29:31 <applicative> anyway it seems crutcher needs to come by an llc
00:29:37 <Enigmagic> applicative: clang (which is mostly what xcode calls "LLVM") doesn't use llc
00:29:57 <JoeyA> Maybe I should say >= 2 instead of > 1, for clarity.
00:30:44 <JoeyA> 69c8c72d codding gnu  (only CRC-32 collision in my /usr/share/dict/words )
00:30:46 <applicative> Enigmagic: yes, it is all making sense. The only point is that the haskell platform, and things like the dph docs should mention this.
00:32:04 <applicative> I think I might have known all this when it first became possible to use -fllvm on os x, but had lost that that was the reason why I had a homebrew version
00:32:37 <applicative> In any case I think this is all that crutcher is missing
00:33:05 <crutcher> applicative: I've installed the macports llvm package now
00:33:17 <crutcher> I'm trying to work out how to get cabal to use the installed llc
00:33:28 <applicative> ...make sure /opt/local/bin is in path :)
00:35:57 <applicative> crutcher: my experience fits with what Enigmagic says, if 'which llc' works, then -fllvm works
00:39:45 <crutcher> applicative: llc isn't in /opt/local/bin
00:39:52 <crutcher> llc-mp-3.2 is
00:39:54 <applicative> grrr
00:43:04 <crutcher> dropping a symlink to it (so that $(which llc) works) doesn't fix it
00:43:33 <applicative> mine is certainly installed by homebrew llvm it symlinks ../Cellar/llvm/2.8/bin/llc
00:43:55 <applicative> I'm lost but I think we are close to the real problem anyway
00:44:11 <Enigmagic> crutcher: download the mac tarball from llvm.org and use that
00:44:13 <crutcher> ghc: could not execute: opt
00:44:50 <crutcher> Enigmagic: why isn't this in the platform distribution?
00:44:53 <applicative> yes my opt is symlinked the same way
00:45:11 <crutcher> I don't appear to have an opt
00:45:29 <crutcher> no, I see it.
00:45:35 <Enigmagic> crutcher: i don't know. i always thought that ghc should get on the llvm train and link against it directly instead of calling out on the command line to llc and opt
00:46:34 <crutcher> the whole "batteries included" line is really failing me right now
00:47:03 <Enigmagic> crutcher: -fllvm isn't turned on by default at least.
00:47:31 <applicative> well it took me much longer than Professor Brady  but I now have my virtual debian squeeze + haskellplatform ready for a total icfp fail
00:47:34 <dmwit> crutcher: =(
00:47:37 <crutcher> Enigmagic: it's required to cabal install dph-examples, which is the documented way to get dph
00:49:09 <Enigmagic> crutcher: i don't think that forcing ghc to come with llvm is the right way to ensure dph will build. not unless ghc was switching over to the llvm backend by default.
00:49:15 <applicative> crutcher: yes, I think this wasn't so clear, it was only by degrees that they got fllvm to work on macs, it was all coming back to me as Enigmagic went through things
00:49:42 <Enigmagic> crutcher: i do think the error messages could be more helpful and the docs should be updated though
00:49:42 <applicative> they should make clear in the platform docs that in addition to XCode whatever you need llvm
00:50:26 <crutcher> applicative: Xcode depends on llvm; whatever crazy crack is going on that I have to have ANOTHER llvm installed for this is just depressing
00:50:30 <applicative> though strictly you don't need it; thus the platform installs without it, though it fails if it cant find gcc
00:51:01 <Enigmagic> crutcher: Xcode does not depend on llvm. xcode comes with a fork of llvm linked in to clang that apple calls "LLVM".
00:51:09 <applicative> crutcher, it's okay, -fllvm isn't that old really
00:51:48 <applicative> I remember when it first existed.
00:51:56 <Enigmagic> crutcher: this has come up a few times on the llvm mailing list and i think apple screwed up by not including all of llvm in xcode.
00:52:23 <Enigmagic> the llvm guys don't even know what revision they fork each version from
00:52:37 <applicative> i think it is just a matter of adding it to the docs, you need a gcc you need an llc
00:52:43 <crutcher> Enigmagic: sure, ok. ghc is a compiler, compilers are sometimes largish. ship the whole thing?
00:53:21 <applicative> doesn't the windows platform have its own personal gcc?
00:53:25 <applicative> :)
00:53:27 <Enigmagic> crutcher: just for dph? last time i checked it was an experimental extension
00:53:54 <applicative> Enigmagic: but -fllvm is very ordinary by now, it has nothing to do with dph
00:54:02 <Enigmagic> crutcher: not that i disagree, i just think ghc should link against llvm directly.
00:54:58 <crutcher> Enigmagic: no, not for dph. There's a general llvm-wards move going on, and having -fllvm work out of the box would be nice to accelerate that
00:56:20 <crutcher> o.m.g. I hate macports
00:56:35 <Enigmagic> crutcher: imo it would be better to fix ghc to link against llvm and drop the "ghc->llvm assembly->assembly->object" mess and replace it with "ghc->object" using llvm as a library.
00:56:39 <crutcher> apparently, I can install some kinds of packages without "selecting" them
00:57:26 <crutcher> Enigmagic: you'd still want to get in there and fuck around sometimes, so you'd want the whole chain to be accessable
00:57:33 <crutcher> might as well ship it all
00:57:41 <Enigmagic> crutcher: you can do that without calling the command line. look at clang.
00:58:02 <Enigmagic> just parsing a giant .ll file takes a while
00:58:32 <crutcher> so, _somethings_ happening now
00:58:43 <crutcher> that I've "selected" a version of llvm and clang
00:58:56 <crutcher> thank you macports, that was so not helpful
01:00:26 <crutcher> it's my firm belief that nothing increases adoption like a simple install, and this was a really painful evening for me
01:06:42 <merijn> crutcher: If you feel like it maybe describe the correct process on the wiki?
01:06:44 <archeyDevil> Is there any haskell OS which can draw fancy things with opengl?
01:07:24 <merijn> archeyDevil: What do you mean? An OS written on haskell with opengl support or just an OS which supports haskell drawing stuff using opengl?
01:07:25 * geekosaur is not sure what was just asked
01:07:26 <crutcher> omg. now that the llvm nonsense is taken care of … pretty sure the HP ghc just doesn't support dph at all
01:07:28 <dmwit> Wait, you want to run an OS just to use OpenGL?
01:07:34 <crutcher> $ ghc -c -Odph -fdph-par DotP.hsghc: unrecognised flags: -fdph-par
01:07:34 <crutcher> Usage: For basic information, try the `--help' option.
01:07:37 <archeyDevil> merijn: first
01:07:39 <archeyDevil> Like House.
01:07:47 <merijn> archeyDevil: Probably not
01:07:54 * archeyDevil doesn't know if House supports opengl (doubt)
01:08:09 <geekosaur> crutcher, no, HP doesn;t ship DPH yet
01:09:31 <dmwit> archeyDevil: Can I ask what motivated this question?
01:10:05 <crutcher> what happens if I install a ghc on top of the hp?
01:10:55 <dmwit> Nothing special. All GHC directories are versioned.
01:11:05 <dmwit> All the executables, too.
01:11:10 <dmwit> ghc is just a symlink to ghc-x.x.x
01:11:30 <archeyDevil> dmwit: Curious. Also, after using XMonad for some time. I'd like to see something like House develop more. (Still a haskell noobie myself) However, my point is. If/when House improves to a state where it has file-systems, hal, ram-management etc; It'd be nice to see running with a tiler like xmonad. (if not just xmonad)
01:12:04 <dmwit> archeyDevil: What does that have to do with OpenGL?
01:12:12 <dmwit> xmonad doesn't use OpenGL at all.
01:12:31 <archeyDevil> Chances are, if a distro supports openGL it'll be matured a bit :P
03:11:39 --- topic: '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]'
03:11:39 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Thu Jul 05 12:31:10 2012]
03:11:59 <antihero> :(
03:12:15 <frerich> antihero: Judging from what you posted, I think you know plenty of Haskell already and certainly enough for this problem, cheer up :-)
03:12:24 <antihero> ok
03:12:30 <frerich> antihero: It's just that wrapping your head around this so that you solve it recursively may be a bit tricky.
03:12:30 <antihero> well I only started reading the book yesterday
03:12:35 <antihero> yeah
03:12:47 <ciaranm> it might be easier if you produce the output backwards first
03:12:59 <antihero> well what's really getting me is how I "split" the list without recursively splitting
03:13:06 <antihero> among other things
03:13:08 <antihero> :)
03:13:10 <ciaranm> huh?
03:13:24 <antihero> ^how I feel
03:13:32 <frerich> antihero: One tip: instead of doing the recursion in "split'", use a little helper function which calls itself recursively, and which takes three arguments: the separator, the input list, and the current "buffer"
03:13:57 <antihero> ok
03:14:07 * ciaranm was going to suggest doing a fold instead
03:14:11 <frerich> antihero: You could call the helper function "mySplitHelper". Or just "go". Try to implement this function - once you have that, building "split'" on top of that will be easy.
03:15:41 <mcstar> dmwit: did your solution involve the use of undefined?
03:16:06 <frerich> antihero: So "go" would be something like "go :: (Eq a) -> a -> [a] -> [a] -> [[a]]" where the first argument is the separator, second is input list, third is the "buffer". So initially people would call it like go ',' "Hello,World" ""
03:16:18 <frerich> antihero: (Eq a) =>, sorry.
03:16:24 <antihero> word
03:16:39 <antihero> I was thinking it could just return two lists
03:16:43 <antihero> before and after split
03:17:00 <frerich> antihero: you could do that, too
03:17:41 <frerich> antihero: For that, I'd suggest to have some sort of "split" function which takes a separator, a list, and then it returns two lists (a tuple, "([a], [a])")
03:18:22 <frerich> So you split in two halves, and then prepend the first half to a recursive call on the second half.
03:18:27 <Nereid> frerich: how would you know when to terminate
03:18:33 <ciaranm> i'm surprised no-one has said ([a], [[a]]) yet
03:18:52 <antihero> yeaht hats kind of what I'm playing with
03:19:08 <frerich> Nereid: Your "split" helper function could yield an empty list or a Bool or a Maybe or anything else
03:19:41 <Nereid> I was talking about the ([a],[a])
03:20:35 <frerich> Nereid: Yeah - one of the lsits could be empty if the input list doesn't contain the separator, so "Hello,World" gives ("Hello",",World") but "HelloWorld" gives ("HelloWorld","")
03:21:14 <frerich> (you must not swallow separators when doing this, because othewise you cannot tell "a," and "a" apart)
03:23:08 <antihero> argh I'm lost again
03:23:28 <antihero> is this even on the right track? http://bpaste.net/show/h4QRuqvmKyFli9tSbeRL/
03:23:51 <Penetrator> i'm having intense type system frustration >:/
03:24:00 <Penetrator> factors n = [x | x <- [2..upperLim], n `mod` x == 0]
03:24:00 <Penetrator>             where upperLim = ceiling $ sqrt n :: Integer
03:24:17 <Nereid> Penetrator: sqrt doesn't work with integers
03:24:39 <Penetrator> Nereid: wont ceiling round it up?
03:24:50 <Nereid> :t sqrt
03:24:51 <lambdabot> forall a. (Floating a) => a -> a
03:25:17 <Nereid> Penetrator: n has to be Floating there for that to work
03:25:21 <Nereid> because it's used as an argument to sqrt
03:25:29 <Penetrator> ah
03:25:34 <frerich> antihero: Try not doing everything at once. You could start witha "splitIntoTwo" function which takes a list and a separator and then returns a tuple of two lists (where the first tuple element contains the list up to the separator, and the second tuple item contains the separator and everything following it - or an empty list, if there is no separator)
03:25:59 <Nereid> Penetrator: I'm thinking replacing [2..upperLim] with something like
03:26:13 <Nereid> takeWhile (\y -> y^2 <= n) [2..]
03:26:27 <Nereid> so you don't need to take square roots anywhere
03:26:32 <Penetrator> Nereid:  ah the :: Integer cast was my attempt other issue
03:26:38 <Nereid> yes, that's not a cast
03:26:43 <Penetrator> thats a great idea
03:27:00 <Penetrator> call it a disambiguation then
03:28:07 <fmap> it's called 'type annotation' actually
03:28:19 <Penetrator> Yes!
03:28:34 <Nereid> I should go now, so that I have a chance of getting up in the morning.
03:28:51 <Penetrator> Nereid: night and thanks
03:28:57 <Nereid> bye
03:31:28 <bas> can I execute a .hs script from within another script?
03:31:54 <bas> ie. I have a bunch of function calls acting as a DSL, and I want to execute them and store their results somewhere
03:32:58 <bas> ie. the script I want to call has things like: makeInput "foo" "bar"
03:33:11 <bas> and I want to execute those without adding boilerplate to it
03:34:20 <ciaranm> bas: haskell is generally compiled these days
03:35:31 <bas> sure
03:35:46 <however> bas: you could do «system "./thescript.hs"» or «system "runhaskell thescript.hs"» or something. see http://hackage.haskell.org/packages/archive/process/1.1.0.1/doc/html/System-Cmd.html . the more elaborate way to spawn processes is System.Process (the System.Cmd page links to it)
03:39:06 <bas> but I basically want to pull the code from thescript.hs into the program, is that a funny proposition? I guess I could go Parsec
03:40:14 <antihero> GO DAMNIT BRAIN
03:40:51 <bas> hint looks funky, should try
03:42:04 <however> bas, in the simplest case, readFile woule be enough. you could then e.g. add the imports or whatever boilerplate you need, and write it out into a file to execute. (or you could probably pipe it into runhaskell directly)
03:42:27 <however> bas: another idea -- how about running ghci and doing ":load thescript.hs"?
03:43:33 <bas> I like your first idea
03:43:49 <bas> adding boilerplate to tempfile etc
03:44:26 <antihero> ooh, nearly there
03:44:53 <antihero> splitIntoTwo now gives me ("", "ans") for "splitIntoTwo 'a' "beans")
03:46:04 <bas> take 2 $ splitOn "a" "beans"
03:46:07 <bas> split package
03:46:14 <dmwit> He's writing it by hand as an exercise.
03:46:19 <bas> ah ok cool
03:46:27 <antihero> thanks though
03:48:19 <antihero> I am not sure how to combine indentation of where statement and that of guards
03:48:50 <antihero> ok figured it
03:51:36 <mikeplus64> how can you test Q [Dec] quasiquoters (ie quoteDec) in ghci?
03:52:05 <mikeplus64> oh, I guess just doing $(quoteDec quoter whatever) might work
03:52:15 <mikeplus64> nope
03:52:17 <mikeplus64> lol
03:52:37 <dmwit> Have you set -XTemplateHaskell or whatever in ghci?
03:52:45 <dmwit> (Setting it in the module that defines the quasiquoter isn't enough.)
03:52:51 <mikeplus64> yes
03:52:53 <dmwit> I guess -XQuasiWhatever
03:53:02 <mikeplus64> $() is for Q Exp
03:53:07 <dmwit> Okay. I vaguely remember asking a similar question, let me grep my IRC logs.
03:53:19 <mikeplus64> thanks
03:54:01 <Saizan> to print the AST you can use $(lift . show =<< ...) iirc
03:54:07 <dobblego> is there a compiler flag to not import Prelude, as if all source files have "import Prelude()" at the top?
03:54:27 <however> dobblego: NoImplicitPrelude, i believe
03:54:27 <Lemmih> dobblego: -XNoImplicitPrelude
03:54:28 <Nereid> -XNoImplicitPrelude?
03:54:32 <dobblego> oh nice thanks
03:55:00 <Lemmih> Woot, a trio answer.
03:55:24 <dobblego> I will insert it three times!
03:55:54 <dmwit> mikeplus64: Well, there's runQ :: Q a -> IO a.
03:56:02 <dmwit> No idea if that actually does what you want it to do, though.
03:56:02 <however> (#haskellers seem to be like cats ready to pounce, with a routine question being a dangly feathery cat toy)
03:56:36 <dmwit> mikeplus64: (I can't seem to find the answer in my IRC logs. I don't remember a sufficiently statistically unlikely phrase from the conversation.)
03:58:22 <antihero> woo I did it now I just need to do an edge case
04:00:18 <antihero> HOLY SHIT YEAHHHHHHH
04:00:37 <mcstar> did it burst?
04:01:19 <antihero> frerich: http://bpaste.net/show/v50OEwkGxhk1uWs41Xye/
04:02:06 <aleator_> http://bpaste.net/show/v50OEwkGxhk1uWs41Xye/
04:02:46 <antihero> I like it because it doesn't rely on any other functions
04:02:55 <antihero> well
04:03:01 <antihero> it relies on the haskell symbols
04:03:45 <antihero> so happy
04:05:15 <fmap> you probably want `(x:acc)' instead of `(acc ++ [x])' and reverse it in the end
04:05:22 <fmap> @src (++)
04:05:23 <lambdabot> []     ++ ys = ys
04:05:23 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:05:23 <lambdabot> -- OR
04:05:23 <lambdabot> xs ++ ys = foldr (:) ys xs
04:05:28 <dobblego> why is it that I have import Prelude() yet I get ambiguous occurrence for (.) from Data.Function?
04:05:59 <fmap> since (++) is O(left list length)
04:06:01 <shachaf> dobblego: Ambiguous with what?
04:06:11 <dobblego> I have declared my own (.) function
04:06:15 <shachaf> (Data.Function..) is the same as (Prelude..), so I don't think they should conflict.
04:06:24 <shachaf> Oh.
04:06:33 <mcstar> import Prelude hiding ((.))
04:06:38 <dmwit> You are importing something (else) that exports (Data.Function..).
04:06:38 <dobblego> I don't want Prelude or Data.Function — I want my own (.)
04:06:38 <shachaf> Probably something you're importing has Data.Function.
04:06:55 <dobblego> but I'm not, srsly
04:07:01 <shachaf> What are you importing?
04:07:03 <Nereid> what, exactly, are you importing then?
04:07:07 <dobblego> import Prelude()
04:07:12 <shachaf> That's it?
04:07:15 <dobblego> yes
04:08:00 <ClaudiusMaximus> is this in ghci?
04:08:02 <dmwit> Could not reproduce.
04:08:03 <dobblego> yes
04:08:15 <shachaf> This program works for me: import Prelude (print,(+)); (.) = (+); main = print (5 . 3)
04:08:15 <dmwit> Aha, ClaudiusMaximus++
04:08:16 <dobblego> I will post a trimmed down example in a sec if I cannot work it out
04:08:22 <shachaf> Oh, ghci.
04:08:24 <dmwit> dobblego: :set -XNoImplicitPrelude
04:08:31 <dmwit> dobblego: (Settings for files don't apply to ghci!)
04:08:42 <shachaf> fg
04:08:54 <dobblego> ok, I fiddled with that, but I'll go again
04:10:08 <shachaf> echo 'import Prelude ((+)); (.) = (+)' > w.hs; ghci -XNoImplicitPrelude w.hs
04:10:20 <shachaf> ghci w.hs; *Main> 5 . 3 -- 8
04:10:31 <shachaf> Er.
04:10:37 <shachaf> ghci -XNoImplicitPrelude
04:10:45 <shachaf> Oh, I guess I said that.
04:10:57 <mcstar> if you import Prelude explicitely, then you dnt have that flag
04:11:06 <mcstar> need*
04:11:12 <dmwit> You can't explicitly import Prelude in ghci.
04:11:13 <shachaf> Actually you don't need that for ghci either.
04:11:29 <dmwit> I'm wrong.
04:11:31 <dmwit> As usual.
04:11:42 <shachaf> dmwit: You can implicitly import Prelude in ghci.
04:11:47 <shachaf> But it won't hide it.
04:11:54 <shachaf> So it doesn't do much good. :-)
04:12:03 <shachaf> You need -XNIP for it to do anything useful.
04:12:09 * hackagebot maude 0.6.1 - An interface to the Maude rewriting system. (DavidLazar)
04:12:10 <dmwit> You can explicitly import Prelude () in ghci, and nothing in Prelude will be in scope.
04:12:12 <shachaf> On the *other* hand, you can shadow things in ghci, so it doesn't matter.
04:12:13 <dmwit> I just checked.
04:12:22 <shachaf> Oh.
04:12:25 <shachaf> Did that get changed?
04:12:34 <hpc> dmwit: you can also make ghci panic when loading a file
04:12:38 <hpc> (that way is my favorite)
04:12:44 <shachaf> Yep, it's not that way in 7.0.3
04:12:45 <dobblego> http://pastebin.com/HpGR3fEN here is a small example
04:12:50 <shachaf> So it's a recent change.
04:12:50 <mauke> The paste HpGR3fEN has been copied to http://hpaste.org/71126
04:13:44 <shachaf> That file has a non-Prelude () import. :-)
04:13:53 <shachaf> It's not even "qualified", which you probably meant it to be.
04:14:27 <dobblego> wait a minute, you mean import Control.Typeclassopaedia.Semigroupoid as X ?
04:14:55 <dmwit> Well, we *did* ask what other things you imported.
04:14:58 <dmwit> We really meant it.
04:15:04 <dobblego> yeah sorry
04:15:15 <shachaf> Oh, maybe the :l messes it up.
04:15:32 <shachaf> You should try doing it without a .ghci file at all, and a minimal module.
04:15:36 <dmwit> Anyway, that shouldn't be the cause of the problem.
04:15:38 <shachaf> Then add things one step at a time until it breaks. :-)
04:16:00 <dobblego> yeah if I remove the :l then ghci, then :load it myself, it works
04:16:04 <antihero> could anyone look at my function and give critique?
04:16:15 <b52> antihero: just paste it
04:16:18 <dobblego> seems a bit rude
04:16:19 <antihero> http://bpaste.net/show/v50OEwkGxhk1uWs41Xye/
04:16:41 <shachaf> dobblego: Probably has to do with the order you're doing things or something.
04:16:50 <b52> if you paste it using http://hpaste.org you get hlint for free antihero
04:16:53 <aetoxx> Is there any distributed programming library which takes into account cost-metrics for realistic systems (Amazon cloud, etc.)?
04:17:09 <dobblego> good ol' order of doing things
04:17:10 <antihero> Ooh
04:17:14 <dobblego> anyway, thanks for the tips
04:17:29 <b52> antihero: do you try to mimic partition ?
04:17:33 <hpaste> antihero pasted “Epic newbie split function” at http://hpaste.org/71127
04:17:50 <b52> @hoogle partition
04:17:51 <lambdabot> Data.List partition :: (a -> Bool) -> [a] -> ([a], [a])
04:17:51 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
04:17:51 <lambdabot> Data.Text partition :: (Char -> Bool) -> Text -> (Text, Text)
04:17:54 <mcstar> Typeclassopaedia
04:17:59 <antihero> that's pretty cool
04:18:06 <mcstar> ghci bails out on spelling errors
04:18:08 <antihero> b52: No it's not like partition
04:18:15 <antihero> it's more like python str.split
04:18:18 <antihero> or PHP explode
04:18:20 <dobblego> yeah that's why I spelled it correctly
04:18:21 <antihero> except it works on numbers too
04:18:24 <shachaf> @ty break
04:18:26 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:18:28 <shachaf> @ty span
04:18:30 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:18:42 <aetoxx> antihero, the problem is related to your feedback.
04:18:57 <shachaf> That (++[acc]) thing is probably not what you want, at any rate.
04:19:01 <hpaste> antihero pasted “Epic newbie split function II” at http://hpaste.org/71128
04:19:10 <aetoxx> antihero, a programmer would have to decypher your code to make sense of it.
04:19:13 <shachaf> Instead you could (first (acc:)) the result, or something.
04:19:44 <dobblego> fwiw, I cannot seem to get it working in any order, this is sad
04:19:45 <aetoxx> antihero, as such any programmer would just write their own version of split' which is understandable making it worthless.
04:20:22 <aetoxx> antihero, if you would actually put some kind of contract on the function in the form of a comment or something like that, then this wouldn't be needed.
04:20:39 <shachaf> aetoxx: Huh?
04:20:46 <antihero> aetoxx: it's for learning purposes
04:21:08 <dmwit> What, you don't write Enterprise-level documentation for your learning exercises?
04:21:23 <b52> :D
04:21:25 <ClaudiusMaximus> i hate the qualified import syntax - i tend to misspell qualified.  but i do like ability to re-use shorter names like: module MyPrelude(module P) where ; import Data.List as P ; import Data.Ord as P ; import Data.Function as P
04:21:26 <antihero> brb creating an extensive batter of unit tests
04:21:33 <antihero> 120% coverage baby
04:21:40 <aetoxx> dmwit, most enterprises don't do that.
04:22:49 <ciaranm> clearly the type signature is all you need to know what the function should do
04:22:52 <hpc> antihero: gonna cover the same 1% 120 times? :D
04:23:38 <however> i think the name "split'" is pretty clear, and i think you really only need 2 short lines of documentation ... "-- >>> split' ',' "abc,def"" and "["abc","def"]". you can even check it with doctest
04:23:39 <aetoxx> antihero, there are lots of other things wrong with it, btw.
04:23:59 <dmwit> Biggest test is best test.
04:24:00 <aetoxx> antihero, and they all result from not writing down your goal with the function.
04:24:07 <ciaranm> realistically, there are only three things a function with that signature could sensibly do
04:24:39 <antihero> what are the other things
04:24:59 <shachaf> It could include the breaking element on either side of the split.
04:25:10 <ciaranm> the question is really what you do with the delimiters
04:25:19 <ciaranm> you could include them, discard them, or put them in their own elements
04:25:33 <shachaf> Oh, or that.
04:25:39 <ciaranm> i'd be inclined to say that the third option would imply something other than Eq, though
04:25:41 <dmwit> I think aetoxx is being overly harsh. It looks fine to me, up to one minor edge case.
04:26:01 <shachaf> I agree.
04:26:04 <ciaranm> if you're putting the delims in their own element, you'd probably have an (a -> Bool) rather than an Eq a => a
04:26:24 <dmwit> antihero: Compare split' 'a' "aa" and split' 'a' "baa".
04:27:26 <aetoxx> dmwit, what is the time complexity of his function?
04:27:46 <dmwit> Didn't we already cover the performance bug some time ago?
04:28:12 <aetoxx> dmwit, he just pasted it.
04:28:19 <dmwit> No, you're wrong.
04:28:38 <shachaf> dmwit fights harshness with harshness.
04:28:49 <aetoxx> dmwit, how can I be wrong? I didn't say anything.
04:29:12 <aetoxx> dmwit, and you can paste the IRC log somewhere.
04:29:37 <dmwit> You can look at your own IRC log.
04:29:44 <aetoxx> dmwit, I don't have one.
04:29:55 <frerich> antihero: Sorry, was gone for lunch - good to see that you got something going :-)
04:30:11 <dmwit> Anyway, he's pasted it half a dozen times, and been told of the performance bug at least three times that I remember. Probably more, due to #haskell stereo.
04:30:33 <aetoxx> dmwit, I saw one line by shachaf.
04:30:43 <aetoxx> dmwit, with no explicit use of the word performance.
04:31:35 <ksf> is someone who knows hxt around?
04:31:41 <ksf> I'm lost on how to throw errors while deserialising.
04:32:39 <aetoxx> dmwit, where are all these invisible quotes you are talking about?
04:32:55 <aetoxx> dmwit, you said there was 'only an edge case'-problem.
04:34:54 <mcstar> aetoxx: looking for an opportunity to argue, eh?
04:35:24 <aetoxx> mcstar, you could also just say I am right; much easier.
04:35:45 <mcstar> you are right much easier
04:36:03 <shachaf> aetoxx: Please do not troll.
04:36:30 <aetoxx> shachaf, I give the poor newbie some advice and that's called trolling?
04:36:50 <aetoxx> shachaf, then I tell someone who says not much wrong with it that he is completely wrong and then it's still trolling.
04:37:15 * dmwit sighs
04:37:28 <dmwit> Your helpful feedback was "write documentation".
04:37:34 <dmwit> And the guy we're arguing about isn't even here.
04:37:49 <shachaf> He's not?
04:37:50 <dmwit> The right next thing to do is ask him if he noticed the performance bug once it was pointed out to him, but what's the point?
04:38:12 <mcstar> he is afaik
04:38:13 <aetoxx> dmwit, again, when was this pointed out?
04:38:15 <dmwit> If I were him, I'd have stopped paying attention and started hacking on more code long ago. Since he hasn't said anything in a while, I suspect he's like m.
04:38:35 <ciaranm> his function sucks because it doesn't come with a uml diagram
04:38:38 <ciaranm> or something
04:38:39 <aetoxx> dmwit, I only have seen shachaf say something without details.
04:39:15 <aetoxx> dmwit, no, that wasn't my feedback.
04:39:23 <aetoxx> dmwit, I cannot help it that you don't get it.
04:39:38 <aetoxx> dmwit, I also thought that this student was very rude in his response.
04:39:52 <ciaranm> i get it, and you're wrong
04:39:53 <mcstar> my point is, its too easy to point out the flaws of a newbie from the ivory tower....
04:40:06 <frerich> Isn't there some sort of #haskell-meta channel for this kind of discussion?
04:40:26 <mcstar> frerich: there is
04:40:30 <aetoxx> dmwit, he asks a question about a piece of code which would never enter a production system and then starts to make fun of my suggestion along with the rest of the clueless inhabitants who disagree.
04:40:54 <aetoxx> And yes, some people said something reasonable here.
04:41:41 <Rc43> Hi, huys.
04:41:43 <Rc43> *guys
04:42:12 <mcstar> hi
04:42:17 <Rc43> Can I somehow write to stdin for other process?
04:42:29 <mcstar> yes
04:42:36 <Rc43> I want run `diff` inside haskell script and then write data to it
04:42:53 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#t:CreateProcess
04:43:58 <fmap> Rc43: iirc you can use arbitrary Handle as stdin with runProcess
04:44:54 <antihero> Hello
04:45:02 <Rc43> `runProcess "diff"` will work the same way as `system "diff"`?
04:45:21 <antihero> did I do something wrong?
04:45:33 <antihero> Sorry if I pasted it lots I've never used hpaste :(
04:46:13 <dmwit> You're fine. Mr. "even beginners should write production-quality code" over here is just grumpy.
04:46:19 <dmwit> Were you aware of the performance bug in your code?
04:46:29 <antihero> I was not, what was it?
04:46:45 <antihero> TBH it's bloody magic that I got this far
04:46:47 <dmwit> Appending to lists is slow. You should prepend whenever possible.
04:46:51 <antihero> ok
04:47:04 <antihero> so I could prepend then reverse it? Would that be faster?
04:47:08 <dmwit> Yes.
04:47:09 <antihero> or do the whole thing in reverse perhaps
04:47:16 <shachaf> You don't need to reverse at all.
04:47:18 <shachaf> @src break
04:47:18 <lambdabot> break p =  span (not . p)
04:47:20 <shachaf> @src span
04:47:20 <lambdabot> span _ xs@[]                     =  (xs, xs)
04:47:20 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
04:47:21 <lambdabot>                   | otherwise    =  ([],xs)
04:47:26 <dmwit> Or, you could do away with the accumulator entirely.
04:48:27 <antihero> shachaf: Indeed, I should use the inbuilt functions, though I was trying to do it purely with the inbuilt constructs
04:48:40 <aetoxx> dmwit, by that logic you would be Mr "Never Acknowledges someone else is right and instead calls people trolls".
04:48:42 <however> Rc43: yes, pretty much the same as i understand it. of course system is limited, while the runProcess functions let you pass in handles and all kinds of things
04:48:51 <dmwit> I never called anybody a troll.
04:49:01 <dmwit> I believe you have good intentions.
04:49:10 <shachaf> No, that was me.
04:49:15 <shachaf> And I never said you weren't right. :-)
04:49:27 <shachaf> antihero: I'm not saying you should use span, I'm showing you how it works. You can do the same thing.
04:49:33 <antihero> ah cool
04:49:37 <Rc43> however, now it is clear, thanks
04:50:08 <antihero> could you possibly show me with my code? or is it totally broken from the get-go?
04:50:16 <XexonixXexillion> does anyone have any experience interfacing Haskell and Matlab?
04:50:29 <antihero> is there something like (x:xs) but gets me (xs:x)
04:50:37 <antihero> like a pop or whatever
04:50:39 <dmwit> No, there's nothing like that.
04:50:40 <ciaranm> antihero: no
04:50:43 <antihero> hmm
04:51:09 <antihero> so the performance issue is on line 12
04:52:12 <ciaranm> produce your output backwards
04:52:13 <dmwit> antihero: The idea is this: instead of putting something on the end of an accumulator, why not just start returning it?
04:52:31 <dmwit> antihero: e.g. instead of splitIntoTwo c xs (acc ++ [x]), try something like x : splitIntoTwo c xs
04:52:32 <antihero> dmwit: Ok
04:52:40 <antihero> that makes more sense
04:54:48 <mcstar> dmwit: i give up
04:54:59 <dmwit> mcstar: I gave up, too.
04:55:07 <dmwit> Do you want the links ski gave me with the answers?
04:55:09 <antihero> am I this dumb?
04:55:23 <mcstar> dmwit: i tell you my idea first
04:55:47 <however> antihero: i don't think they are talking about your code :)
04:56:11 <shachaf> Give up on what?
04:56:24 <ciaranm> public masturbation
04:56:37 <mcstar> dmwit: so, i wanted to make a function with foldr, that would consume the second list, (driving it from another foldr) this function would give back a similar function, as long as it is partially applied
04:56:38 <dmwit> shachaf: Writing zip as a foldr.
04:56:45 <dmwit> shachaf: (Two foldrs, actually, one for each list.)
04:56:47 <shachaf> A double foldr?
04:57:01 <mcstar> dmwit: i realized that i cannot use foldr for that, since it would involve a recursive type definition
04:57:03 <dmwit> shachaf: And no funny business: no pattern matching on lists.
04:57:39 <mcstar> dmwit: the problem, is that That function's signature would look much like a list structure, but i wasnt able to use this to my benefit
04:58:01 <dmwit> mcstar: Yes, I tried using the Church encoding of lists, too, but it didn't help me figure out the answer. =P
04:58:07 <mcstar> dmwit: i asked you earlier, if you used undefined, im wondering if it oculd be used to somehow circumvent the type system
04:58:13 <Saizan> mcstar: ski's solution ends up using recursive newtype's
04:58:16 <shachaf> data List = Nil | Cons a (List a); zipList (Cons a as) (Cons b bs) = (a,b) : zipList as bs; zip a b = zipList (foldr Cons Nil a) (foldr Cons Nil b)
04:58:19 <shachaf> What do I win?
04:58:37 <ciaranm> a pony
04:59:11 <shachaf> Oops, missed the [] case.
04:59:17 <mcstar> Saizan: i didnt know thats possible
04:59:21 <dmwit> shachaf: "pattern matching on lists" was just an example of "funny business", I'm afraid.
04:59:22 <shachaf> data List a = Nil | Cons a (List a); zipList (Cons a as) (Cons b bs) = (a,b) : zipList as bs; zipList _ _ = []; zip a b = zipList (foldr Cons Nil a) (foldr Cons Nil b)
04:59:25 <mcstar> Saizan: or, if it was permitted...
04:59:34 <shachaf> dmwit: Hey! What's funny about my business?
05:00:12 <dmwit> mcstar: I don't think you should need undefined, but you may indeed need infinite types (mitigated by a newtype, for example).
05:00:30 <shachaf> Wait, why would you need either?
05:00:42 <mcstar> dmwit: im too noob for that, so yes pls, id like the links :)
05:01:47 * mcstar in the meantime inspects shachaf's solutin
05:01:58 <dmwit> http://hpaste.org/47814
05:02:04 <dmwit> mcstar: shachaf's solution is a joke
05:02:10 <mcstar> oh
05:02:13 <dmwit> http://okmij.org/ftp/Algorithms.html#zip-folds <- and this
05:02:21 <shachaf> dmwit: It's a joke but it's totally correct!
05:02:38 <dmwit> I think you know why it's not correct.
05:03:39 <shachaf> I think using a recursive newtype is kind of terrible.
05:04:15 <mcstar> why you need the foldrs?
05:04:23 <mcstar> zipList already does everything
05:04:59 <mcstar> shachaf: ^^
05:05:17 <shachaf> mcstar: The point is that you can't explicitly pattern-match on []'s constructor.
05:05:23 <shachaf> Because you're just given its foldr, for instance.
05:05:37 <shachaf> @ty \f z -> foldr f z ?l
05:05:39 <lambdabot> forall a b. (?l::[a]) => (a -> b -> b) -> b -> b
05:05:42 <mcstar> shachaf: but you pattern match on your Cons
05:06:00 <mcstar> you just mitigated the problem
05:06:00 <shachaf> Like that. You have two functions :: (a -> b -> b) -> b -> b, which represent lists, and you want to zip them together.
05:06:31 <mcstar> actually, not mitigated, but delayed, transferred...
05:06:41 <shachaf> I thought maybe dmwit's point was that my solution used recursion rather than being type-checked to be safe, but apparently the other one does too...
05:06:57 <dmwit> shachaf: No, my point is that you're using pattern matching on lists.
05:07:06 <dmwit> Just because you made another list type doesn't change that. =)
05:07:11 <mcstar> yeah
05:07:29 <shachaf> Well, it means my solution works on a general function :: (a -> b -> b) -> b -> b
05:07:38 <shachaf> The implementation details of my function don't matter. :-)
05:07:42 <dmwit> shachaf: Yes, it does.
05:07:50 <dmwit> This puzzle is about implementation details, not about types.
05:08:15 <dmwit> You just solved a different puzzle, that's all.
05:08:17 <shachaf> Using foldr is basically pattern-matching on lists, too. :-)
05:08:22 <shachaf> Except recursively.
05:08:30 <dmwit> shachaf: If you say so, then just write down the solution and be done with it!
05:08:39 <shachaf> I don't know. At this point I don't understand the rules.
05:08:42 <dmwit> But I think you'll find it's not basically just pattern matching on lists. =)
05:08:56 <shachaf> I mean, I can see why my solution isn't valid, but by that logic I think a recursive-newtype solution oughtn't be valid either.
05:09:01 <schlicht> data Foo a = Foo { f :: (Show a) => String -> a} why doesnt that work? or how do i get it to work :)
05:09:43 <dmwit> shachaf: Well, the rules in Oleg's paper are: no recursive types. Period.
05:10:27 <shachaf> dmwit: Ah, then that's more interesting.
05:10:36 <shachaf> Is it also "no recursion, period"?
05:10:46 <dmwit> According to the abstract, yes.
05:11:51 <shachaf> Well, that sounds worthwhile.
05:14:39 <fmap> schlicht: do you get any errors?
05:15:18 <however> schlicht: for error messages >1 line, please use hpaste.org
05:16:04 <hpaste> schlicht pasted “error rank2” at http://hpaste.org/71130
05:16:35 <schlicht> i dont realy get, why that should be rank 2
05:18:07 <Eelis> has anyone ever pondered making ghci's tab completion type-aware? for example, when you type "not F<tab>", you currently get suggested completions like Float and FilePath, which seems a bit silly
05:19:02 <ksf> \o/
05:19:09 <ksf> I sucessfully threw an error.
05:19:15 <ksf> ...in case I suceed.
05:19:47 <ksf> now I have to figure out how to throw it when I fail.
05:20:08 <schlicht> ksf, good luck :)
05:21:05 <fmap> looks like `:: (Show a => a) -> a' is rank2 and `Show a => a -> a' isn't
05:21:13 <fmap> i don't think i get it either
05:21:21 <however> i'm noticing that http://www.haskell.org/haskellwiki/Existential_type says "you can't, in haskell 98", but stops short of actually saying which language extension you need to turn on
05:21:28 <however> (in section 1. or maybe i'm blind)
05:21:36 <Saizan> shachaf: would you like one done with existential types?
05:21:46 <shachaf> Saizan: One what?
05:21:59 <schlicht> i dont see why my example is rank2 at all
05:22:01 <Saizan> solution to the zipwith puzzle
05:22:57 <Saizan> schlicht: it's not really rank2, but the Show a => context in the field confuses the check
05:23:23 <schlicht> Saizan, alright, how do i help him? :)
05:23:24 <Saizan> schlicht: though that's a weird field type, are you sure it's what you mean?
05:23:42 <schlicht> Saizan, pretty sure, why?
05:23:53 <dmwit> however: ExistentialQuantification, but also, if you just try it, GHC will tell you.
05:24:30 <schlicht> dmwit, i dont see why that example is existential
05:24:30 <antihero> I'm looking at the STL "words" function and I can't see where s' is defined
05:24:39 <Saizan> shachaf: because it means f is a function that will require a Show a instance, for the particular 'a' which is the parameter of the Foo type
05:24:46 <antihero> or is it defined by the case statement
05:24:51 <Saizan> schlicht: i meant that for you ^^^
05:25:06 <akamaus> Hi, I basically have an IO computation which I want to run across the list and collect the results. A work for mapM, but I need to skip failures and report them to user. How best to tackle that? Should I use ErrorT IO, or exceptions, or something another? What to take into consideration?
05:25:17 <antihero> ooh pattern matching
05:25:19 <Saizan> schlicht: in particular it doesn't mean that the presence of the Show a instance will be required to construct a (Foo a) value
05:25:23 <antihero> so doing s' -> blah 's
05:25:24 <however> dmwit: i see, thanks. i should add that to the wiki page. if it had been Rank2, it'd been relevant to schlicht's question =)
05:26:03 <schlicht> Saizan, What i want is a record, used as configuration for my program. the user has to give me a parse function for strings, where the result is instance of a typeclass.
05:26:21 <Nereid> akamaus: what if you put the error in the result type
05:26:23 <shachaf> akamaus: What are "failures"? Something explicitly defined in your code?
05:26:53 <Saizan> schlicht: then what you wrote is not what you want
05:27:09 <Nereid> like if you have a list of X's and you want to run f: X -> IO Y on them, where f might fail
05:27:20 <ksf> the thing is... HXT's arrow is a list arrow. If I know that I can't find some element it's [], and throwing the error has no element to execute on.
05:27:23 <schlicht> Saizan, how do i express what i want?
05:27:27 <akamaus> Nereid, this way I need later to split Rights and Lefts apart in the resulting list.
05:27:28 <Nereid> use f to build something like X -> IO (Maybe Y) or X -> IO (Either ErrorType Y)
05:27:36 <Nereid> you do.
05:28:08 <Nereid> that doesn't sound so bad.
05:28:27 <shachaf> dmwit: OK, so a reasonable way to do it is probably to start out by making two functions, "cons" and "uncons". :-)
05:28:44 <Saizan> schlicht: -# LANGUAGE ExistentialQuantification #-}
05:28:45 <Saizan> data Foo a = Show a => Foo { f :: String -> a }
05:28:45 <akamaus> shachaf, I'm writing a web scraper, so I need to handle several classes of errors, both IO and parsing.
05:28:58 <schlicht> Saizan, no way around that?
05:29:19 <schlicht> i dont realy get, why i need it
05:29:49 <Saizan> schlicht: note that i've also shifted the Show a => constraint
05:30:05 <smplx> dmwit: Hmm, i tried your idea and it seems that i'm not allowed to have overlapping instances. Not sure how one could overide a class behavior for particular types.
05:30:34 <akamaus> wow, I use HXT too, like ksf :)
05:30:48 <however> akamaus: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html offers a function that takes a list of Eithers and gives you all the Lefts and all the Rights. you could then analyse the Lefts (the errors) further and display them etc.
05:31:05 <Saizan> schlicht: there isn't a good reason why (except implementation details) while this feature is bundled up into the ExistentialQuantification extension, but that's how it works
05:31:17 <schlicht> Saizan, yeah, that was my first version. but why is that existential?
05:31:21 <schlicht> Saizan, ahh okay.
05:31:26 <Saizan> s/while//
05:31:30 <akamaus> however, looks like a reasonable way to me
05:31:34 <schlicht> Saizan, didnt realy match my understanding of the term
05:31:58 <Saizan> data Foo = forall a. Show a => Foo { f :: String -> a } would really be an existential type
05:33:32 <dmwit> smplx: You'll have to give me a bit more to go on than that. Maybe paste some code?
05:33:33 <schlicht> Saizan, exactly, so i didnt get it totally wrong. so know i have to fight with record selectors and existential types ...
05:33:34 <however> schlicht: as far as i know, ExistentialQ is pretty uncontroversial. it's not one of the exotic, dangerous cowboy extensions
05:33:41 <dmwit> I've suggested a lot of things in the last three days...
05:33:53 <schlicht> however, cowboy :D pew pew
05:35:43 <hpaste> simplx pasted “overriding Show” at http://hpaste.org/71131
05:36:32 <dmwit> You'll want
05:36:48 <dmwit> class Show a => CShow a where cshow :: a -> Text; cshow = T.pack . show
05:37:16 <shachaf> dmwit: How's this solution?
05:37:21 <dmwit> Then keep the instances for Char and String, and write instances with no cshow definition for any other types you want to cshow.
05:37:23 <shachaf> type List a = forall b. (a -> b -> b) -> b -> b
05:37:36 <shachaf> let { cons :: Maybe (a,List a) -> List a; cons Nothing = \_ z -> z; cons (Just (x,l)) = \f z -> f x (l f z) }
05:37:41 <LK4D4> someone can help with Data.Conduit?
05:37:49 <shachaf> let { uncons :: List a -> Maybe (a,List a); uncons l = l (\x y -> Just (x,cons y)) Nothing }
05:37:58 <shachaf> let z :: List a -> List b -> [(a,b)]; z (uncons -> Just (a,as)) (uncons -> Just (b,bs)) = (a,b) : z as bs; z _ _ = []
05:38:16 <dmwit> shachaf: I think that fails the "no pattern matching on lists" constraint.
05:38:23 <shachaf> Huh?
05:38:31 <shachaf> Come on, just because I used view pattern syntax?
05:38:32 <dmwit> Maybe (a, List a) is a list.
05:38:48 <dmwit> cons Nothing = ...; cons (Just foo) = ... is a pattern match on a list.
05:38:53 <shachaf> What, so you want me to Church-encode it completely so it won't be a list anymore?
05:39:03 <dmwit> I want you to only use foldr.
05:39:04 <shachaf> That doesn't change anything.
05:39:10 <LambdaDusk> I have a stupid question: I have a file with structured data, and I want this data to become a Haskell data structure on load time (via Template Haskell). Is there a simple tutorial covering this?
05:39:27 <shachaf> Only foldr? No datatypes, no functions?
05:39:27 <smplx> dmwit: ah, but i wanted to avoid redefining every single instance that Show has. It has a lot of disadvantages.
05:39:35 <dmwit> smplx: tough
05:39:43 <dmwit> (sorry)
05:40:07 <dmwit> shachaf: You can use data types, I guess, as long as they're not lists!
05:40:09 <LambdaDusk> shachaf: no datatypes, only "converting" the data to an IO () function
05:40:29 <shachaf> LambdaDusk: Sorry, that was a separate discussion. :-)
05:40:39 <LambdaDusk> shachaf: oh ok
05:40:49 <shachaf> dmwit: But forall b. (a -> b -> b) -> b -> b is totally a list!
05:40:58 <shachaf> Are you saying I can't use "intermediate" lists?
05:41:21 <dmwit> Yep, and I'm fine with using that type, so long as all you do with a value of that type is apply it to arguments. =)
05:41:34 <dmwit> (i.e. no pattern matching, not even Church-encoded pattern matching)
05:41:39 <shachaf> But Maybe isn't allowed?
05:41:48 <shachaf> Church-encoded pattern matching isn't allowed?
05:41:54 <shachaf> That's taking it a bit far.
05:41:55 <dmwit> Right.
05:42:10 <antihero> is there any reason not to use -fllvm ?
05:42:32 <dmwit> shachaf: Don't complain to me, complain to ski. He's the one who set the weird requirements.
05:42:50 <bitonic> antihero: the native code generator is more mature and I think it still generates slightly faster code
05:43:11 <Saizan> dmwit: ski is also the one that's fine with recursive newtypes though
05:43:14 <antihero> bitonic: Fair enough
05:43:31 <dmwit> yeah
05:43:39 <shachaf> Yes, Oleg's solution didn't use recursion at least.
05:43:42 <shachaf> Which is much more principled.
05:44:05 <shachaf> If you said that was the rule, I'd be fine with it. :-)
05:44:17 <dmwit> shachaf: Anyway, I think the point is to find a different implementation of zip. Writing the same implementation of zip with a different representation of lists doesn't count.
05:44:25 <however> trash-talking a la #haskell. "he's someone who's fine with recursive newtypes!"
05:44:31 <Saizan> i think shachaf's solution is fine, the others just end up doing some more church encoding and fusion
05:45:08 <shachaf> "The zip function might appear complex. However, if we recall that we already have stake and sdrop (so that we can `split' an FR stream into the head element (stake 1) and the rest (sdrop 1)), the code for szipWith becomes trivial:"
05:47:42 <mauke> that made me remember http://hpaste.org/71132
05:49:16 --- mode: ChanServ set +o mauke
05:49:16 --- mode: mauke set +b strmpnk!*@*$##fix_your_connection
05:49:40 <shachaf> mauke: Is "spork l = foo $ foldr (...) l" allowed, or just "spork l = foldr (...) l"?
05:50:18 <mauke> that is a good question and the answer is I don't know
05:50:46 <mauke> less postprocessing on foldr = better solution
05:50:47 <shachaf> I wonder what the class of things that you can write in that form is.
05:51:02 <shachaf> Obviously you can write anything with postprocessing.
05:51:16 --- mode: mauke set -o mauke
05:51:33 <antihero> does recursion get easier as you get more used to it?
05:51:39 <mauke> antihero: yes
05:51:42 <antihero> good
05:51:46 <antihero> because my brain hurts
05:52:13 <antihero> it's good though, I was getting kinda bored with Python, great as it is
05:52:16 <shachaf> (I meant "spork l = fold (...) (...) l", of course.)
05:52:25 <mauke> to understand recursion, you must first understand recursion - or know someone who already understands recursion
05:53:04 <aetoxx> mauke, and what about co-recursion?
05:53:23 <antihero> can you use haskell for boring system scripts and whatnot
05:53:28 <antihero> like day-in-day out stuff
05:53:28 <mauke> I don't understand corecursion
05:53:30 <shachaf> antihero: No.
05:53:37 <mauke> antihero: yes
05:53:40 <shachaf> antihero: By virtue of being written in Haskell, the scripts automatically become interesting.
05:53:43 <shachaf> It's unfortunate.
05:53:51 <antihero>  because making random crap like that is how I learn
05:54:01 <schlicht> really using an existential type proves quite hard
05:54:09 <antihero> I have a pricing calculator I'd quite like to report, but doing it without state is going to be a world of pain.
05:54:18 <Saizan> shachaf: what about spork l = foldr (..) (..) l (..) ?
05:54:22 <shachaf> schlicht: It's often the wrong thing to do.
05:54:30 <shachaf> Saizan: That's postprocessing.
05:54:37 <mcstar> shachaf: did you solve the puzzle differently from oleg?
05:54:47 <shachaf> The question is whether your one-and-only foldr on the list is the outermost thing.
05:55:11 <shachaf> Saizan: In particular, it's ($(..)) $ foldr (..) (..) l :-)
05:55:32 <ksf> anyone know hxt in here?
05:55:37 <schlicht> shachaf, yeah, i don't know any other way. the guys from this channel told me it is the way to go
05:55:45 <hpaste> antihero pasted “A pricing calculator” at http://hpaste.org/71133
05:55:56 <shachaf> schlicht: No, they told you that what you were trying to do was to use existentials.
05:55:58 <ksf> I'm trying to throw an error if the xml doesn't look as I'd like, but I fail to do so.
05:56:02 <antihero> ^ if only I'd learned haskel a few months ago
05:56:16 <Saizan> shachaf: i told him it was the way to go
05:56:18 <shachaf> schlicht: Using existentials will probably work, but it'll probably be really annoying and cumbersome.
05:56:21 <shachaf> Oh.
05:56:28 <shachaf> Maybe I only saw a snippet of that conversation, then.
05:56:30 <Saizan> schlicht: you're not using an existential, you're just using the extension
05:56:33 <shachaf> OK, complain to Saizan, not me. :-)
05:56:51 <Saizan> schlicht: anyhow, what problem are you having?
05:56:51 <schlicht> Saizan, yeah, but i get the same problems
05:57:10 <ksf> basically, I need a "whenEmpty" predicate for the list arrow.
05:57:41 <schlicht> Saizan, i can't accesse the function via record selctor
05:58:14 <Saizan> schlicht: can you paste the actual code and the error? because there should be no problem for that
05:59:13 <schlicht> Saizan, the code ist quite long, i hope that doesnt bother you
05:59:38 <Saizan> schlicht: nope, as long as i can find the relevant part
05:59:54 <xhx> woa, thats a lot
06:00:07 <schlicht> Saizan, i will cut the unrelevant parts
06:00:53 <Saizan> schlicht: better not
06:01:00 <Saizan> schlicht: http://hpaste.org/71134 <- this is to show that it works
06:02:37 <Saizan> what requires pattern matching though is the use of the typeclass dictionary
06:04:03 <schlicht> Saizan, http://hpaste.org/71135
06:04:05 <Saizan> i.e. k :: Foo a -> String; k xs = show (f xs ""); wouldn't typecheck
06:04:27 <schlicht> Saizan, i see the difference...
06:04:43 <Saizan> schlicht: you added the forall a.
06:04:49 <schlicht> yes i did
06:05:02 <schlicht> thank you very much :)
06:05:08 <Saizan> np :)
06:06:09 <schlicht> works like a charm
06:07:29 <Saizan> if you're going to use the PrettyPrint context you'll need to pattern match, even (Global {}) will be enough as a pattern
06:08:24 <schlicht> Sorry - I don't quite follow.
06:17:04 <Saizan> schlicht: suppose (bar :: PrettyPrint a => a -> String); and you want to define foo :: Global a -> a -> String; then you've to do it like that: "foo Global{} x = bar x"
06:17:29 <Saizan> schlicht: because "foo g x = bar x" will complain there's no PrettyPrint a instance
06:18:02 <schlicht> ahh okay :)
06:18:05 <schlicht> good to know
06:26:46 <savask> Hello. The program I'm making should be able to interpret commands and read binary files from stdin. Like, I send "t\nfile" to it and it does something with the file. As I guess I should end file data with EOF, but won't that close stdin?
06:27:11 <mauke> no
06:27:23 <mauke> you make the program see EOF by closing its stdin
06:27:34 <mauke> you can't "send EOF"
06:28:01 <savask> mauke: I thought it's something like \n
06:28:08 <mauke> it isn't
06:28:15 <savask> How can I show the end of binary data then?
06:28:28 <mauke> <mauke> you make the program see EOF by closing its stdin
06:28:29 <yrlnry> close the file handle.
06:28:56 <savask> No, stdin must be opened.
06:29:09 <mauke> then your design is wrong
06:29:11 <savask> Another program will send data to my program through pipe.
06:29:11 <yrlnry> That's what "close" means, it means you're not going to write any more data.  Then the OS tells the reader that you're not going to write any more data.  Logical, right?
06:29:20 <LK4D4> can someone give example of using Conduit.Data.Binary.dropWhile?
06:30:07 <savask> yrlnry: Yes, it's logical. But how can I show that it's the end of binary data to my prog?
06:30:19 <yrlnry> close the file handle.
06:30:20 <barrucadu> savask: The thing doing the writing closes the file handle
06:30:45 <yrlnry> What's Haskell-speak for "file handle"?
06:30:54 <srhb> file handle.
06:31:02 <however> > Prelude.dropWhile isAlpha "abc123def" -- if it's anything like this function ... LK4D4
06:31:03 <lambdabot>   "123def"
06:31:13 <mauke> @kind System.IO.Handle
06:31:16 <lambdabot> *
06:31:43 <however> LK4D4: er sorry, you're talking about Conduit. i somehow misread it as ByteString. never mind
06:31:47 <savask> barrucadu: But won't that disconnect the pipe?
06:31:58 <barrucadu> savask: Yes.
06:32:10 <savask> That's not nice.
06:32:14 <barrucadu> Which is what you want, because you've reached the end of the data
06:32:23 <savask> Sender program is going to send data quite frequently.
06:32:35 <hpaste> dmwit annotated “-” with “sporkr (annotation)” at http://hpaste.org/71132#a71136
06:32:36 <barrucadu> Then you don't use EOF
06:32:43 <savask> What should I use then?
06:32:43 <dmwit> mauke: my attempt
06:32:46 <yrlnry> Instead of having it send raw data, you could have it send a length, then the data.  Then the reader will know when to stop reading.
06:32:55 <savask> Okay.
06:33:18 <savask> I thought there is a kind of terminator, or whatever.
06:33:26 <yrlnry> Sure, if you want there to be one.
06:33:32 <srhb> savask: You can always make your own.
06:33:46 <srhb> savask: But you need to be careful that it cannot occur in your binary data, if you do that.
06:33:50 <savask> Yes, but binary data can contain any possible byte.
06:34:00 <savask> That's why no terminator for me :C
06:34:03 <yrlnry> Escape characters.
06:34:22 <savask> ?
06:34:32 <yrlnry> Say '\\' means '\' and '\X' means "end of this message".
06:34:35 <srhb> The length + data approach is much better, really. Stop thinking about anything else. :P
06:34:37 <fmap> savask: how would you encode terminator if data can contain any possible byte?
06:34:45 <savask> fmap: Nohow.
06:34:48 <yrlnry> Then instead of "I like pie\you do too"  send "I like pie\\you do too\X"
06:35:00 <srhb> But that places trust on the sender.
06:35:09 <barrucadu> You could have a beginning sequence and an ending sequence, and pad the data stream such that those sequences can't occur in the middle. Though, length + data is the simplest
06:35:12 <savask> fmap: That's why I said that "no terminator for me"
06:35:13 <yrlnry> Receiving messages *always* places trust on the sender.
06:35:32 <savask> Okay, probably I'll use length+data
06:35:34 <yrlnry> "I got a letter from my dad the other day but it is written in French and I on;y understand English."
06:35:34 <srhb> yrlnry: Sure, but keeping that trust to a minimum seems safer.
06:35:43 <yrlnry> No, that makes no sense at all.
06:35:46 <dmwit> Clearly the right answer is to encode your bytes so they're 7-bit ASCII clean and treat any byte with the high bit set as a terminator.
06:35:54 <srhb> yrlnry: Do elaborate.
06:36:28 <savask> dmwit: So the "right-way" is to convert it to base(I don't remember what) and send that?
06:36:48 <dmwit> base 2^7, encoded with only seven bits per byte, yes
06:36:50 <however> the disadvantage with escaping is that the program putting the stuff into the pipe needs to slog through all the data and do the replacing. but for the length, there's a chance it's known anyway (e.g. if it's a file being read from the filesystem)
06:36:57 <dmwit> I am 130% serious about this proposal.
06:37:02 <mcstar> why not send the filename through the pipe, and make your 'interpreter' open that file, and do whatever it wants with it?
06:37:13 <savask> No
06:37:22 <savask> There are no files with data.
06:37:29 <yrlnry> Then write one.
06:37:33 <mcstar> you said there were
06:37:37 <mcstar> you said 'file'
06:37:43 <savask> When? o_O
06:37:56 <savask> Oh, yes.
06:37:56 <mauke> <savask> Hello. The program I'm making should be able to interpret commands and read binary files from stdin.
06:37:57 <mcstar> "I send "t\nfile""
06:37:58 <savask> My bad.
06:38:08 <savask> s/file/data/g
06:38:50 <savask> Well, data is kept on a server, and that server uses my prog as kind of daemon (not really though)
06:39:25 <dmwit> I bet you'll be annoyed with yourself for using a binary format later instead of something really braindead like JSON.
06:39:25 <mcstar> you can do it like this too: 1 control character / N bytes
06:39:49 <dmwit> I don't even know what problem you're trying to solve, though.
06:39:59 <savask> dmwit: You don't understand :-P Binary data is a save file for a game.
06:40:04 <yrlnry> Self-inflicted wounds.
06:40:04 <savask> I can't change that.
06:40:13 <mauke> I wish to reinvent http
06:40:21 <savask> But still thanks everyone, I'll just send data length.
06:40:55 <however> savask: could you run your program once for each file? or is there some problem with that (something like: it's a million files and you don't want to spawn a million tiny processes)
06:40:57 <yrlnry> He could use System V message queues.
06:40:58 <mcstar> dont forget to write error correction ...
06:41:10 <mauke> yrlnry: ew.
06:41:22 <savask> however: No, I can't. It's a neural network, and it does take long time to dump it's state to file.
06:41:22 <yrlnry> I make joke! Laugh, comrade, laugh!
06:41:47 <mauke> SysV IPC is not a laughing matter :-|
06:44:54 <dmwit> Oh, FunnyList is totally unnecessary.
06:48:38 <dmwit> > let sporkr = fst . foldr (\v ~(k, t) -> (maybe t (:k) v, k)) ([], []) in sporkr ([Nothing] ++ [Just x | x <- [1..100]] ++ repeat Nothing])
06:48:40 <lambdabot>   <no location info>: parse error on input `]'
06:48:47 <dmwit> > let sporkr = fst . foldr (\v ~(k, t) -> (maybe t (:k) v, k)) ([], []) in sporkr ([Nothing] ++ [Just x | x <- [1..100]] ++ repeat Nothing)
06:48:51 <lambdabot>   mueval-core: Time limit exceeded
06:49:05 <mcstar> there is something called SysV shared segments
06:49:16 <dmwit> Anyway, that works and is lazy.
06:49:45 <dmwit> mauke: I'll be impressed if it gets much more compact than that. =)
06:50:09 <yrlnry> mcstar:  that is shared memory.
06:50:16 <yrlnry> not the same as the message queues.
06:50:27 <mcstar> yrlnry: no, but it says, it can persist process terminatino
06:50:36 <yrlnry> Sure.  So can the message queues.
06:50:40 <Kiryx> Hi #haskell
06:50:58 <uniquenick> I have a function that takes a Foo and returns a Maybe String, and I am fmaping it onto a Maybe Foo, so I get back a Just Just String
06:51:03 <mcstar> yrlnry: still, for this problem, is seems preferable to some fifo, imho
06:51:11 <yrlnry> The problem with using shared memory as a mailbox is that you still need some other mechanism to synchronise the processes talking to each other.
06:51:25 <uniquenick> how do I flatten out the nested Maybes into a Just String or a Nothing instead of a Just Just String or Just Nothing?
06:51:26 <yrlnry> Otherwise you get a situation where the reader is erasing the message before the writer has finished writing it, etc.
06:51:33 <mcstar> yrlnry: but that can be done over the text pipe
06:51:33 <barrucadu> uniquenick: "join"
06:51:35 <barrucadu> :t join
06:51:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:52:00 <dmwit> uniquenick: Instead of using fmap and join, it's common to use bind.
06:52:03 <dmwit> :t (>>=)
06:52:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:52:25 <dmwit> :t (=<<) -- sometimes this order is more aesthetically pleasing
06:52:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
06:52:32 <mcstar> yrlnry: what does one process need to open a shared segment? just an address?
06:52:58 <Kiryx> Does haskell suffer from Global Interpreter Lock as Python does, effectively resulting in lack of easy multi threading ?
06:53:16 <mcstar> the haskell runtime interpreter
06:53:17 <dmwit> Kiryx: By default, GHC uses a non-threaded runtime, which indeed has a global lock, essentially.
06:53:23 <yrlnry> mcstar:  design of SysV IPC is very stupid.  You need a special shared-memory-segment ID.
06:53:28 <dmwit> Kiryx: However, the threaded runtime is quite multithreaded.
06:53:31 <dmwit> And threads are cheap.
06:53:43 <yrlnry> Then you call shmat() with the ID, or something like thay.
06:53:44 <dmwit> It uses m-to-n green threading to ensure this.
06:53:44 <yrlnry> that.
06:54:11 <however> uniquenick: if you have a list with Nothing, Just Nothing, and Just (Just String), and want to remove the Nothings you may be interested in catMaybes
06:54:13 <however> :t catMaybes
06:54:15 <lambdabot> forall a. [Maybe a] -> [a]
06:54:40 <dmwit> however: Hm. Did you see that uniquenick's question had two lines?
06:57:09 <however> dmwit: um yeah? it sounded as if he wanted to throw away the Nothings and unwrap the stuff in the Justs? ... anyway, it was just a suggestion :) "you may be interested"
07:03:08 <EvanR> is there a language that uses jvm and has a sane type system
07:04:21 <MostAwesomeDude> EvanR: What does "sane" entail? :3
07:04:32 <EvanR> "like haskell" ;)
07:05:13 <aristid> EvanR: i bet the JVM makes that hard ;)
07:05:23 <EvanR> thats what im thinking
07:05:23 <Botje> meh, the JVM is untyped
07:05:30 <EvanR> hm ok
07:05:47 <however> evanr: scala may or may not be relevant here ...
07:06:30 <dmwit> I think the existence of Scala prompted MostAwesomeDude's question.
07:07:10 <dmwit> Huh, there's OCaml-Java
07:07:18 <dmwit> http://en.wikipedia.org/wiki/List_of_JVM_languages
07:07:31 <EvanR> ah right scala
07:08:49 <mcstar> switching to CLR from JVM may or may not be relevant here
07:09:09 <dmwit> ?src liftM
07:09:09 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:09:14 <EvanR> heh
07:09:25 <EvanR> mcstar: the reason i brought up jvm was the 'great libraries'
07:09:58 <mcstar> cant comment on that
07:10:23 <dmwit> fmap f x >>= g = x >>= g . f -- is this a monad law? if so, how come it gets so little love?
07:10:34 <Blazemore|work> My mouth tastes like monster munch, but I haven't eaten monster munch
07:10:51 <mcstar> XD
07:10:52 <EvanR> maybe thats a monad theorem ;)
07:11:01 <dmwit> I was trying to prove it.
07:11:06 <dmwit> Assuming fmap = liftM.
07:11:44 <hpaste> mkramer pasted “No instance for (Eq Row) ?” at http://hpaste.org/71139
07:11:57 <EvanR> haha jaskell
07:12:18 <dmwit> fmap f x >>= g = x >>= return . f >>= g = x >>= (\y -> (return . f) y >>= g) = x >>= (\y -> return (f y) >>= g) = x >>= \y -> g (f y) -- got it
07:12:51 <flux> evanr, there is ocaml-java :)
07:13:07 <EvanR> i saw that
07:13:14 <mkramer> Could someone explain how I'm failing to declare an instance for Eq Row in my snippet?
07:13:18 <srhb> dmwit: Okay, now I'm curious. How is that a proof? In fact, what does a proof mean in Haskell?
07:13:34 <ksf> :t constA
07:13:35 <lambdabot> Not in scope: `constA'
07:13:42 <ksf> :t Arrow.constA
07:13:43 <lambdabot> Couldn't find qualified module.
07:13:49 <dmwit> mkramer: could not reproduce
07:13:57 <EvanR> have you guys seen this page lol http://www.datarecoverylabs.com/ultimate-computer-language-guide.html "haskell is a scripting language inspired by python"
07:13:58 <dmwit> mkramer: That file loads fine here.
07:14:00 <mkramer> so that looks right to you
07:14:54 <dmwit> srhb: Well, if you assume the monad laws, plus laws like "I can replace a name with its definition" and "I can take as many steps of evaluation as I like", then, yeah, it's a proof.
07:15:11 <however> mkramer: restart ghci perhaps?
07:15:18 <dmwit> srhb: Though I would expect for it to be a convincing proof, I'd have to tell you which of the things above I used for each equality.
07:15:29 <keseldude> in my experience, the theorem is usually just that you can take a value of set A and produce a value of set B
07:15:38 <keseldude> and then the proof is the implementation of your function
07:15:38 <mcstar> EvanR: thats a highly useless page
07:15:47 <mkramer> however: I that, and it works.  I think my network mounted filesystem is slower than I can :reload
07:15:57 <srhb> dmwit: Right, thanks.
07:15:58 <dmwit> keseldude: That's a very different meaning of proof.
07:16:09 <flux> evanr, hmmm, can't tell if the page is an intentional joke or not :)
07:16:11 <however> EvanR: more useful is this classic guide http://james-iry.blogspot.de/2009/05/brief-incomplete-and-mostly-wrong.html
07:16:21 <dmwit> keseldude: If you want to call that a proof, then I'd call this one a "metaproof" or something like that.
07:16:24 <EvanR> haha
07:16:36 <mcstar> no, the page evanr linked is not suppsed to be a joke
07:16:43 <mcstar> it is mostly correct except haskell
07:16:47 <mcstar> but useless
07:16:55 <EvanR> avoid success at all costs
07:17:00 <EvanR> DONE lol
07:17:25 * hackagebot distributed-process 0.2.0.1 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
07:17:26 <mcstar> what however linked succeeds in being funny
07:17:26 <however> mcstar: "PHP ... was originally intended as a means of making hypertext code more dynamic" <- hypertext code, yo
07:17:27 * hackagebot distributed-process-simplelocalnet 0.2.0.1 - Simple zero-configuration backend for Cloud Haskell (EdskoDeVries)
07:17:50 <barrucadu> however: Can we shorten that to "hypercode"?
07:18:00 <EvanR> hypercode streaming xml
07:18:17 <however> streaming pile of hypercodes
07:18:18 <barrucadu> PHP enables dynamic hypercode for XML streaming.
07:18:45 <however> barrucadu: not sure about shortening, but we can certainly link it *tada*
07:18:54 <Tukeke> Hi all
07:19:23 <Cale> Hello!
07:20:10 <mcstar> hi Cale
07:20:17 <EvanR> however: this blog is hilarious
07:20:34 <ksf> ok, I managed to wrap a working error arrow over the hxt arrow
07:20:37 <ksf> http://hpaste.org/71140
07:20:47 <ksf> can someone help me with those lift instances?
07:22:33 <ski> mcstar : ok ?
07:22:41 <mcstar> ski: ok!
07:22:56 <ksf> weil, there's another array transformer lib.
07:22:59 <mcstar> ski: i didnt succeed, talked to dmwit since, have the links
07:24:56 <ski> ok, fine :)
07:25:18 <applicative> hi Tukeke
07:25:25 <ski> you can probably note that the solution isn't that obvious, maybe
07:26:03 <ski> the basic idea is that we want to think of the two `foldr' calls as coroutines, and we want to create both of them, passing the starting state of one of them to the other
07:26:33 <dmwit> shachaf: ski is currently defending his solution, if you care
07:26:48 <ski> then, as they continue, they'll each time "pass the buck" to the other one (and the `a' element they read from the list, in the case of the first one)
07:27:21 <ski> each one will be passed the "current state" of the other, and when it wants to resume the other, it'll have to call this (with it's own current state as argument)
07:28:20 <ski> e.g. in
07:28:23 <ski>     consB b kB = MkB $ \a kA -> f a b : unA kA   kB
07:28:41 <ski> `kB' is the "continue state" of this (the current) coroutine B
07:28:53 <ski> (`kB' is computed recursively by `foldr')
07:29:02 <mcstar> ski: i had that notion of 'interleaving' early on, but rejected it out of hand, as not possible
07:29:10 <EvanR> "1970 ... Lambdas are relegated to relative obscurity until Java makes them popular by not having them."
07:29:13 <EvanR> haha
07:29:25 <ski> it is also passed `kA' whenever the other coroutine feels like passing the buck to it
07:30:16 <ski> and then, it outputs `f a b' to the output list, and the rest of the output list is gotten by resuming the other coroutine (A), passing the next state of B to it (so it can resume back, if need be)
07:31:08 <ski> mcstar : yeah :) -- well, i was stubborn and thought that it *ought* to work out, *somehow*
07:31:26 <ski> and after some while (days iirc) thinking about it, i came up with the solution on hpaste
07:31:50 <mcstar> (atm it is too hot here to form coherent thoughts, so im drinking water, and losing heat by evaporating)
07:32:29 <ski> in a sense, `kA' (by `foldr') contains all the rest of the `a'-elements, and `kB' contains all the rest of the `b'-elements
07:32:41 <mcstar> ski: its good, that youre so perseverant
07:33:07 <ski> by cleverly setting these up so that we can pass them to each other, we can achieve the goal : the interleaving of the two processes !
07:33:56 <ski> EvanR : yeah, also check the Prolog entry :)
07:34:34 <ski>   1972 - Alain Colmerauer designs the logic language Prolog. His goal is to create a language with the intelligence of a two year old. He proves he has reached his goal by showing a Prolog session that says "No." to every query.
07:34:49 <EvanR> hahaha
07:35:02 <ciaranm> someone just googled "a monad is just a monoid in the category of endofunctors"
07:35:06 <applicative> sclv there are directed arrows
07:35:30 <ski> yeah, Wadler's line is also great
07:35:41 <ciaranm> that's actually from Mac Lane
07:36:21 <aetoxx> Can anyone recommend a distributed filesystem?
07:36:29 <ski> ciaranm : including the "what's the problem?" part ?
07:36:52 <EvanR> aetoxx: torrents ;)
07:37:01 <ciaranm> ski: naah. it's after several pages on monads. it's something like "So all told, a monad on x is just a monoid in the category of endofunctors on x"
07:37:14 <ski> ciaranm : ok, i see :)
07:37:17 <yitz> ski: saunders wouldn't say "what's the problem." if he said that, he was serious.
07:37:31 <ski> (yes, that's what i would expect)
07:37:37 <aetoxx> EvanR, a file-system is something which exposes a FS API.
07:37:42 <ski> mcstar,dmwit,shachaf : anyway, i'd love to chat more on the coroutine one, if you have more questions / are more curious -- but i have to dash and run atm
07:37:48 <ciaranm> halmos seemed to think mac lane was a miserable bastard
07:38:02 <aetoxx> EvanR, so, unless there is TorrentFS, I don't see how that answers the question.
07:38:10 <yitz> ciaranm: he's still alive and he's not.
07:39:01 <ksf> Arrow.Abort doesn't work as an error reporting arrow.
07:39:25 <yitz> aetoxx: you mean like an afs kind of thing?
07:40:06 <aetoxx> yitz, for example.
07:40:18 <aetoxx> yitz, something which has all the bugs removed already.
07:40:28 <yitz> aetoxx: afs is pretty mature
07:40:51 <ciaranm> like a rotten sock
07:41:02 <ciaranm> with dementia
07:43:20 <yitz> aetoxx: more modern things that do something similar to part of what a dfs does are dropbox and google drive. but i'm not sure why you want a distributed fs.
07:43:40 <EvanR> mcstar: wait a minute i just read the rest of the stuff on that ultimate-computer-language guide
07:43:46 <EvanR> lol that shits gotta be a joke
07:44:04 <aetoxx> yitz, dropbox and google drive are products, not distributed file systems.
07:44:14 <yitz> aetoxx: yes absolutely
07:44:37 <aetoxx> yitz, what do you mean?
07:45:26 <yitz> aetoxx: the question is what you are trying to accomplish. anyway, this is kind of getting off topic.
07:46:02 <aetoxx> yitz, I was asking for experiences with distributed file systems.
07:46:19 <aetoxx> yitz, how could you possibly have interpreted it in any other way?
07:46:33 <mcstar> EvanR: i still think it is a sserious, but misguided guide
07:47:03 <EvanR> no this is the kind of thing i would have written in highschool
07:47:20 <EvanR> with a friend that would mutually assure both of us we were hilarious
07:48:06 <yitz> aetoxx: i understood your question. i was asking what you are trying to accomplish by using a dfs. most people don't, you know. because it is a very complex piece of machinery that does a lot of things, and most people don't need all of those things and can do something simpler than using a dfs.
07:48:25 <mcstar> Mutual Hilariousity: keeping the world peace since 1945
07:49:03 <EvanR> lol
07:50:54 <mcstar> aetoxx: http://9p.cat-v.org/
07:51:09 <mcstar> comes from bell labs, must be great
07:51:18 <aetoxx> mcstar, that's not your experience.
07:51:32 <mcstar> no, i googled that for you
07:51:36 <aetoxx> mcstar, I can also use Google.
07:51:49 <mcstar> anyway, you are welcome
07:52:09 <aetoxx> mcstar, however, you can't ask Google for all people who have used at least 5 dfs and get a good review from them.
07:52:21 <aetoxx> mcstar, all you can find are some uninformed 3 line reviews.
07:52:50 <aetoxx> mcstar, things like 'we use this in production and we haven't found any problems in the past 5 years' are of interest.
07:53:15 <mcstar> aetoxx: you could find some google employee, who for example uses google's distributed filesystem, and have a talk with him
07:53:29 <mcstar> unlikely you will get a very well informed opinion here
07:53:40 <ciaranm> "not found any problems" is largely useless
07:54:00 <earthy> 5 dfs... no.
07:54:07 <aetoxx> ciaranm, fine, formal proof of correctness then.
07:54:11 <aetoxx> ciaranm, happy now?
07:54:25 <aetoxx> ciaranm, or are you now going to say "but nobody does that".
07:54:35 <ciaranm> "found problems and how they were fixed" is where it gets interesting
07:54:43 <aetoxx> ciaranm, which in turn would make your initial claim... even more questionable.
07:54:43 <earthy> afs I have used. zfs I have used. DRBD I have used....
07:55:03 <earthy> most of them did what they said
07:55:46 <aetoxx> earthy, how is zfs distributed?
07:56:16 <earthy> it can run over arbitrary network topology including iscsi?
07:56:28 <earthy> (oh, right, iSCSI providers...)
07:56:49 <Baughn> aetoxx: Google employee here. Probably can't tell you anything, but what was it?
07:57:52 <aetoxx> Baughn, I wanted to know which distributed file systems actually work as opposed to only being advertised to work.
07:58:05 <Baughn> Aha.
07:58:20 <aetoxx> Baughn, the very existence of GFS sort of suggests that apparently those which existed at the time weren't good enough.
07:58:33 <Baughn> Well, the only distributed filesystem I've used is what Google uses, and GFS works pretty well IMO..
07:58:46 <ciaranm> because google has never reinvented the wheel
07:58:52 <Baughn> But you can't have it. Which means that's not terribly useful.
07:58:58 <aetoxx> Baughn, and since Colossus also exists, one would expect that nothing new is either good.
07:59:02 <Baughn> Yes, of course we'd reimplement the wheel. Everyone does. :P
07:59:05 <however> well, "good enough" is very subjective
07:59:23 <Baughn> aetoxx: Eh, it might be a matter of scale. We're somewhat larger than the creators of other DFSs may have planned for.
07:59:56 <aetoxx> Baughn, I don't really see why a distributed FS wouldn't scale to infinity.
08:00:08 <aetoxx> Baughn, if it doesn't, I would consider it a design failure.
08:00:18 <ciaranm> a regular FS doesn't scale to infinity
08:00:18 <mcstar> eh, finite address space?
08:00:19 <aetoxx> Baughn, subject to all kinds of practical side-conditions.
08:00:34 <Baughn> aetoxx: Then you haven't tried to build one. There are all kinds of theorems that prevent it for practical purposes.
08:00:39 <ciaranm> and the cost of keeping stuff in sync between n nodes grows way faster than n
08:00:44 <MostAwesomeDude> aetoxx: Are you familiar with analysis of algorithms?
08:00:52 <Baughn> In particular, algorithms that "don't get slower as the network gets larger" tend to /start/ very slow
08:00:54 <aetoxx> MostAwesomeDude, yes
08:01:03 <ciaranm> also if anyone mentions the CAP theorem they get stabbed
08:01:19 <aetoxx> Baughn, which theorem?
08:01:26 <Baughn> aetoxx: The overall effect is that any given DFS will have a certain range of network sizes it's most useful for
08:01:39 <MostAwesomeDude> aetoxx: So what kind of complexities "scale to infinity?"
08:02:03 <Baughn> aetoxx: Not really an expert, but.. the logic of distributed decisions, mostly, especially if byzantine errors are to be avoided
08:02:06 <aetoxx> MostAwesomeDude, logarithmic ones?
08:02:24 <ciaranm> log infinity is infinity
08:02:37 <aetoxx> ciaranm, can you please not state the obvious.
08:02:45 <mauke> but what if your log base is infinity?
08:02:47 <Baughn> aetoxx: There's also stuff like.. a filesystem that relaxes some POSIX constriants, such as by having eventual consistency, will be *MUCH* more performant than one that doesn't
08:02:52 <aetoxx> ciaranm, also read this word called 'to'.
08:03:10 <aetoxx> ciaranm, infinity is not a completed number.
08:03:19 <aetoxx> ciaranm, and also consider the context, please.
08:03:37 <ciaranm> aetoxx: well you're talking crap by saying "scales to infinity", for starters
08:04:15 <MostAwesomeDude> aetoxx: To my mind, you're asking for constant-time actions.
08:04:47 <Baughn> Which are possible, so long as you limit the scaling. :P
08:04:50 <ciaranm> there's no such thing as constant time, except if you restrict yourself to small problems
08:04:53 <aetoxx> Baughn, I think what you are saying is provably wrong w.r.t. that there can be no single system which is slower up to a small multiplicative constant.
08:05:14 <mauke> .oO( scales to infinity (poorly) )
08:05:15 <aetoxx> Baughn, i.e. that you need 'different systems'.
08:05:16 <Baughn> aetoxx: Huh?
08:05:31 <aetoxx> Baughn, that's what you said earlier.
08:05:43 <aetoxx> Baughn, every dfs is built for a certain range.
08:05:52 <Baughn> aetoxx: Yes, I did say that. They are.
08:05:57 <aetoxx> Baughn, that there cannot be one system to rule them all.
08:06:06 <Baughn> aetoxx: I did not say that.
08:06:18 <Baughn> Although I /would/ point out that no-one has made one.
08:06:25 <aetoxx> Baughn, ok
08:07:06 <aetoxx> Baughn, so basically Google either decided that they wanted to control every line of code written (NIH syndrom) or everything else out there was deemed to be designed for toy systems?
08:07:24 <Baughn> aetoxx: Or there were other tradeoffs that made them unsuitable.
08:07:40 <Baughn> Such as weighing reliability over performance
08:07:44 <aetoxx> I can sort of understand why Google would rather just implement from scratch.
08:08:01 <Baughn> We have a five-digit number of developers.
08:08:06 <aetoxx> Why let someone else do it, if you have enough people who can do it better anyway.
08:08:18 <aetoxx> Baughn, yes, that's what I was saying.
08:08:20 <Baughn> This being the case, the cost of rewriting something is much smaller than for smaller organizations / the benefit is larger.
08:08:26 <shachaf> dmwit, ski: Ah, was gone.
08:08:47 <Baughn> aetoxx: Oh, and as to the "One FS to rule them all" thing.. that was actually my master's thesis.
08:08:58 <Baughn> aetoxx: I *failed*, obviously, though it was pronounced an admirable attempt.
08:09:04 <Baughn> *DFS
08:09:21 <srhb> Anyone got experience on some embedded Haskell programming? Is there a preferred platform? Arduino? mBed?
08:09:23 <aetoxx> Baughn, what name did the DFS have?
08:09:37 <Baughn> srhb: Arduino is way, way too small to run haskell
08:09:56 <aetoxx> srhb, there is Atom.
08:10:08 <srhb> Baughn: I see.
08:10:11 <srhb> aetoxx: What is that?
08:10:16 <Baughn> srhb: It's not something I think anyone has tried. GHC runs on.. okay, it's fairly easy to port, but generally just ARM and Intel.
08:10:20 <Baughn> An intel cpu
08:10:30 <MostAwesomeDude> http://hackage.haskell.org/package/atom/
08:10:34 <Baughn> srhb: So you probably want an ARM SOC. Something with enough heft in it to run Linux.
08:10:36 <aetoxx> srhb, a language which compiles to hard-real time C.
08:10:42 <aetoxx> srhb, embedded in Haskell.
08:10:50 <flux> at the risk of sounding a fanboi, there's OCaml for Microchip's microships (OCaPIC) :)
08:10:51 <srhb> I see. That sounds interesting.
08:10:57 <Baughn> ..oh, hum. Now that's a different meaning of "atom"..
08:11:00 <flux> that's probably the closest you can get to haskell on a microcontroller at the moment.
08:11:10 <Baughn> Yes, that atom looks /very/ interesting
08:11:13 <flux> and I really should try it out 'some day'
08:11:23 <MostAwesomeDude> http://leepike.wordpress.com/2009/05/05/an-atomic-fibonacci-server-exploring-the-atom-haskell-dsl/
08:11:28 <aetoxx> The interesting part about Atom is that it has been tested.
08:11:41 <Baughn> aetoxx: Do you know what the smallest chip it can usefully run on is?
08:12:16 <aetoxx> Baughn, no, but I would imagine it to be very, very small.
08:12:40 <Baughn> aetoxx: I've got a PIC with 256 words of EEPROM and 8 bytes of RAM. Can I run it? :P
08:13:04 <MostAwesomeDude> Atom can target Arduinos.
08:13:16 <Baughn> Atmegas, rather, I hope
08:13:17 <srhb> That's really cool.
08:13:35 <Baughn> But yeah, ATMega chips are pretty huge
08:13:58 <aetoxx> Baughn, if you are talking about how large the overhead is, then if you want your program to basically do a little loop or something like that, I think that should be possible.
08:14:23 <Baughn> aetoxx: It's a bit more complex.. I think I'll probably drop to assembly for that one.
08:14:32 <Baughn> The program should still fit on a screen or two, so.
08:14:47 <Baughn> But it sounds like just what the doctor ordered, for arduinos.
08:15:08 <aetoxx> Baughn, why do you have such a small device?
08:15:24 <Baughn> Because it's the smallest device that would fit the program..
08:15:25 <aetoxx> Baughn, I mean: for 25$ you have a Raspberry Pi.
08:15:42 <Baughn> Rrgh. And a raspberry pi would chew through the battery in a minute flat.
08:15:48 <aetoxx> Baughn, ok, so you actually computed the minimum requirements for your program :)
08:15:53 <aetoxx> Baughn, I like that.
08:16:05 <Baughn> Well, I /wrote/ the program. I expect I could squeeze it smaller, but..
08:16:11 <dada_cetacean> I was referred here by Learn You A Haskell For Great Good!
08:16:22 <srhb> dada_cetacean: Welcome. :)
08:16:42 <Baughn> I'm using the PIC to bit-bang TWI on one end, and run a moisture sensor on the other. Basically using it as an analog-to-TWI converter.
08:17:06 <aetoxx> Baughn, TWI being?
08:17:08 <Baughn> It uses ~40 nanowatts *while running*. Do you see now, why I like it? :)
08:17:31 <aetoxx> Baughn, how do you even measure that?
08:17:53 <Baughn> aetoxx: Looking at the manufacturer's datasheet.
08:17:54 <aetoxx> Baughn, unless you leave it running until it is empty and then divide, that is.
08:18:07 <aetoxx> Baughn, and you trust those? ;)
08:18:13 <Baughn> Also, my bad. I didn't mean TWI.
08:18:19 <Baughn> OWI. One-wire interface.
08:18:35 <srhb> dada_cetacean: Questions or company? :-)
08:18:43 <Baughn> aetoxx: In general, yes. Microcontroller manufacturers are pretty good about that sort of thing.
08:18:50 <aetoxx> Baughn, for what are you using it?
08:19:09 <Baughn> As I said.. converting a capacitative moisture sensor to a one-wire bus.
08:19:27 <aetoxx> Baughn, I mean your end-user goal (which might be you).
08:19:33 <dada_cetacean> srhb, I'll be working through the book this week, I usually hang out in ##math and I was happy to see a freenode shoutout
08:19:42 <dada_cetacean> Thought you guys would appreciate the acknowledgement, heh
08:19:44 <Baughn> Oh, well. Watering controller for my garden.
08:20:03 <srhb> dada_cetacean: Cool. :) Enjoy it, I really liked the book.
08:20:27 <Baughn> ..the way I'm making the moisture sensor work is ..pretty lunatic, from one POV.
08:20:40 <aetoxx> Baughn, are you doing that under company time?
08:20:47 <Baughn> Would be much simpler if I picked a PIC with an analog input, but noo, that wouldn't be challenging enough. :P
08:20:50 <Baughn> No, of course not.
08:21:12 <aetoxx> Baughn, well, I can imagine it is useful if employees know about PICs, and embedded tech.
08:21:45 <Baughn> In a general sense, I suppose.
08:22:01 <dmwit> Can it run Haskell.
08:22:04 <dmwit> That was a joke.
08:22:15 <aetoxx> Then again, 50 out of those 10K+ developers likely already can do that far better.
08:22:24 <Baughn> dmwit: Well, it has 256 full words of memory, of *twelve bits each*.
08:22:30 <Baughn> dmwit: And eight whole bytes of ram!
08:22:36 <Baughn> dmwit: So yeah, I think I can fit GHC in there.
08:22:54 <Baughn> It also has a hardware stack! How fancy!
08:22:58 <Baughn> A two-level hardware stack.
08:23:38 <dmwit> pfft, we just need to retrofit GHC with cross-compilation abilities
08:23:49 <aetoxx> Baughn, what is a two-level hardware stack?
08:23:57 <dmwit> ...and decrease the size of the RTS by a factor of about... 1000?
08:24:02 <Baughn> aetoxx: It has call and ret instructions.
08:24:33 <however> Baughn: does it do tail call optimization? ;)
08:24:43 <aetoxx> Baughn, is that a term in common usage?
08:24:55 <Baughn> aetoxx: Not outside the embededed world, I don't think. :P
08:25:34 <Baughn> aetoxx: Basically, its call instruction copies the current PC to a dedicated register, and the current value of that register to /another/ register. The value of the second register is just overwritten.
08:25:41 <Baughn> aetoxx: Ret does the reverse.
08:25:55 <aetoxx> Baughn, yeah, I know what instructions...
08:26:06 <tdammers> brainfuck should be doable
08:26:10 <aetoxx> Baughn, what the instructions do.
08:26:17 <Baughn> So, dedicated registers for a stack, instead of a pointer to main memory.
08:26:55 <aetoxx> Baughn, ah, ok. I read a bit too fast.
08:27:22 <aetoxx> Baughn, so basically no nested functions then?
08:27:35 <Baughn> Yup.
08:27:51 <Baughn> But it's not a worry, with 256 words of program space you can't fit anything large in anyway.
08:28:48 <however> Baughn: you make it sound small. but each of the words has 12 whole bits in it
08:28:51 <augur_> ahhhhh
08:29:02 <augur_> i just figured out how to derive the Y combinator from first principles
08:29:11 <aetoxx> Baughn, the amount of programs which terminate in 5000 steps which use one byte of RAM and 256 instructions cannot be that much :)
08:29:20 <Baughn> however: You're right. An almost embarassing richness of space.
08:29:32 <Baughn> aetoxx: Oh really.
08:29:41 <aetoxx> Baughn, no, not really.
08:29:51 <aetoxx> Baughn, probably still a ridiculously high number.
08:30:19 <shachaf> augur_: Which principles are those?
08:33:03 <OODavo> Is there any particular reason there can't be an IOT monad transformer?
08:33:03 <OODavo> I realise that the runIOT evaluation function couldn't simply unwrap into a pure value, but runIOT :: Monad m => IOT m a -> IO (m a) would be possible.
08:33:28 <shachaf> That's not what monad transformers are, though.
08:33:32 <ben> That's already what the other monad transformers do
08:33:57 <shachaf> Then again, who knows what monad transformers are?
08:34:15 <augur_> shachaf: lambda calculus inference rules together with the goal of Y to be a recursion combinator
08:34:50 <MostAwesomeDude> OODavo: This is why there's MonadIO and IO usually forms the base of the stack. Did you have a different monad you wanted as the base?
08:34:57 <however> shachaf: it's some movies involving megan fox, i believe
08:35:14 <MostAwesomeDude> Is that the one where she licks things?
08:36:13 <however> MostAwesomeDude: yes. the transforming is generally preceded by licking
08:36:24 <OODavo> I'm not really thinking of a particular use-case for having IO elsewhere in the transformer stack. Just wondering whether it'd be practical.
08:37:03 <shachaf> It doesn't really make sense.
08:37:09 <MostAwesomeDude> OODavo: It sounds backwards IMO since IO is the monad you're actually using as your base, in most programs. But I'm pretty limited in my experience.
08:37:10 <shachaf> What you described, at any rate, isn't IOT.
08:37:17 <shachaf> How would you write lift?
08:38:35 <OODavo> Ah, that is a good point. I haven't any idea how lift would be written, so there's a good reason for it not to work.
08:39:08 <EvanR> "Pike is a high level programming language similar to C. It came about largely as a means for coding Multi-User Dungeon games."
08:39:55 <EvanR> maybe i should use pike instead of haskell for that mud then ;)
08:41:31 <raymank26> hi all. I have sample MaybeT code here http://hpaste.org/71145 Why the 6th line raise a type error?
08:42:01 <mauke> because you're not using return
08:42:29 <shachaf> Because the value (Just "some") is not of type (MaybeT ...)
08:43:10 <raymank26> ok... But how can i fix this?
08:43:21 <mauke> by using return
08:43:28 <EvanR> :t return
08:43:29 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:44:02 <raymank26> hmm
08:44:35 <however> raymank26: that signature that evanr brought up means that return can produce *any* Monad, including your monad "MaybeT IO ..."
08:44:48 <however> :t Just
08:44:50 <lambdabot> forall a. a -> Maybe a
08:45:07 <however> ^^ that's a different type
08:45:59 <EvanR> IO a -> Maybe (IO a)
08:46:19 <EvanR> burritos ftw
08:46:29 <raymank26> b <- return $ Just "some"
08:46:34 <raymank26> yes?
08:46:35 <mauke> no
08:46:40 <raymank26> =(
08:47:13 <mauke> b <- return "some"
08:47:24 <raymank26> hm..
08:47:26 <mauke> let b = "some"
08:47:27 <raymank26> magic here
08:47:39 <shachaf> Completely magic.
08:47:44 <EvanR> more magic
08:48:02 <raymank26> let b is not my way
08:49:36 <raymank26> thanks, it's works.. oh haskell..
08:52:14 <abelincoln> hi, i'm just starting out with the tutorial (have done object-oriented and imperative programming before, never functional)
08:52:24 <mauke> which tutorial?
08:52:28 <abelincoln> had a question, when i try (1,2,3) == [1,2,3] it throws an error instead of returning False
08:52:30 <abelincoln> why is that?
08:52:53 <EvanR> :t (==)
08:52:54 <lambdabot> forall a. (Eq a) => a -> a -> Bool
08:53:01 <abelincoln> just the basic one when you start help
08:53:17 <roconnor> abelincoln: you can only compare values of the same type.
08:53:22 <EvanR> abelincoln: == only works between two values of the same type
08:53:32 <EvanR> a and a
08:53:34 <abelincoln> ahh, hmm, interesting
08:53:48 <roconnor> abelincoln: (and even they they have to be an Eq type)
08:54:05 <roconnor> abelincoln: so for example, you cannot compare functions at all
08:54:12 <mcstar> "apples and oranges"
08:54:15 <EvanR> (1,2,3) and [1,2,3] are very different data, and they are two different types, so they are definitely not equal ;)
08:54:30 * roconnor bites his lips about functions with compact domains.
08:54:32 <mcstar> EvanR: not not equal, not comparable
08:54:49 <EvanR> well it cant be equal without being comparable first!
08:55:05 <mcstar> it cant be not equal wo being comparable first
08:55:22 <EvanR> excluded middle up in here
08:55:26 <however> abelincoln: welcome :) that's a good question. the answer is in the signature that evanr showed with the ":t" command (for now you can ignore the part to the left of "=>"). a function "equals :: a -> b -> Bool" would be what you're looking for, but i don't think there's any such thing
08:55:28 <abelincoln> is this the case with most staticly typed languages?
08:55:46 <EvanR> no, example C does conversions
08:55:50 <EvanR> before applying ==
08:55:57 <mauke> EvanR: that doesn't answer "most"
08:56:13 <abelincoln> good enough as a response, was just curious :P
08:56:15 <roconnor> abelincoln: If it makes you feel better, the compiler is saying that this will is always False, so why are you trying it? ... though this isn't really a good way to look at it.
08:56:19 <mauke> hmm, unless you're arguing that most statically typed languages are C
08:56:29 <HugoDaniel> what is the difference from using conduits to copy a file in filesystem, or using system "cp" ?
08:56:32 <EvanR> in the main stream they try to approximate C ;)
08:56:46 <mauke> let's draw up some morphisms
08:57:43 <mauke> :t (=====)
08:57:44 <lambdabot> Not in scope: `====='
08:57:46 <mauke> aww
08:57:52 <fmap> HugoDaniel: you may not have cp
08:57:52 <mcstar> mauke: mocking me?
08:58:03 <mauke> mcstar: what do you mean?
08:58:23 <mcstar> mauke: i was trying out === ==== in private lambdabot
08:58:32 <however> abelincoln: look at it this way -- to be equal, two things need to have the same type and the same value. haskell is clever enough that the first half (type) can be ensured at compile-time. (that's the error you were seeing). only the values need to be checked at runtime. in other languages, you wouldn't know anything at compile time and had no choice but to check both at compile time
08:58:34 <codolio> roconnor: Scala can't prevent you from doing such always false comparisons, so it has an ad-hoc compiler warning instead. :)
08:58:45 <mcstar> mauke: dont you run lambdabot?
08:58:54 <mauke> mcstar: no
08:58:59 <HugoDaniel> fmap: yes, but besides that, system probably forks a new process, while conduit probably blocks the current one, or no ?
08:59:02 <mcstar> my bad then
08:59:03 <EvanR> my equals is more equal than yours
08:59:15 <EvanR> to ensure a more equal treatment
08:59:29 <barrucadu> All equalities are equal. Especially EvanR's.
08:59:31 <HugoDaniel> if system "cp" fails then im in the dark, if conduit fails i can try to know why did it fail, or no ?
08:59:33 <mcstar> mauke: there was some equality function defined on all types some time ago in lambdabot
09:00:47 <mauke> > 1 ==== "yes"
09:00:52 <lambdabot>   mueval-core: Time limit exceeded
09:00:58 <mauke> amazing
09:01:00 <mauke> > 1 === "yes"
09:01:03 <lambdabot>   False
09:01:18 <mauke> > 1 ==== "yes"
09:01:19 <EvanR> its always creepy when you do like [] == [] in other languages and thats false
09:01:20 <mcstar> @src (====)
09:01:20 <lambdabot> Source not found. It can only be attributed to human error.
09:01:22 <lambdabot>   False
09:01:22 <EvanR> because of pointer comparison
09:01:28 <however> three "=" signs are just inside the time limit. four are one too much and it times out
09:01:31 <EvanR> > [] == []
09:01:32 <lambdabot>   True
09:01:42 <mcstar> :)
09:01:47 <mauke> EvanR: not pointer comparison, object identity
09:02:09 <EvanR> probably implemented with pointer comparison
09:02:34 <mauke> > sqrt 4 ==== length "ab"
09:02:37 <lambdabot>   True
09:02:51 <mcstar> creepy
09:02:57 <mauke> :t (====)
09:02:57 <mcstar> > True
09:02:59 <lambdabot>   True
09:02:59 <lambdabot> forall a a1. (Show a, Read a1, Eq a1, Show a1, Read a, Eq a) => a -> a1 -> Bool
09:03:07 <EvanR>  > True
09:03:11 <EvanR> <lambdabot> False
09:03:21 <mcstar> fail
09:03:42 <lambdabot> False
09:03:53 <Baughn> @src (====)
09:03:53 <EvanR> lol
09:03:53 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:04:00 <mauke> > оtherwise
09:04:03 <lambdabot>   False
09:04:08 <EvanR> wuh
09:04:14 <mcstar> EvanR: how did that happen?
09:04:15 <Baughn> > 42 ==== "42"
09:04:16 <fmap> HugoDaniel: you can always use System.Process to get some response from cp but that's odd thing to do if you can just use some bytestring io
09:04:16 <spree> anyone know of a good explanationor pseudo code implementation of the simplex algorithm?
09:04:17 <lambdabot>   can't find file: L.hs
09:04:18 <shachaf> > "оtherwise"
09:04:19 <lambdabot>   "\1086therwise"
09:04:37 <mauke> > 42 ==== "42"
09:04:40 <lambdabot>   False
09:04:41 <EvanR> hahahaha
09:04:41 <fmap> which, i guess, conduits do under the hood
09:04:52 <Baughn> spree: http://en.wikipedia.org/wiki/Simplex_algorithm
09:05:22 <mauke> :t (===)
09:05:25 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
09:05:33 <Baughn> > 42 ==== 42
09:05:38 <lambdabot>   True
09:05:41 <Baughn> > 42 ==== 42.0
09:05:41 <raymank26> :r
09:05:44 <lambdabot>   True
09:05:49 <Baughn> > 42 ==== "42"
09:05:52 <lambdabot>   False
09:05:55 <mauke> > M.empty ==== S.empty
09:05:58 <lambdabot>   True
09:06:00 <Baughn> ..what's the logic, here?
09:06:02 <abelincoln> is there a syntax reference guide somewhere? the tutorial just starts using things like @ without ever really explaining what it means >.>
09:06:19 <mauke> abelincoln: <mauke> which tutorial?
09:06:23 <shachaf> abelincoln: There's always the report. But does it really do that?
09:06:42 <EvanR> > Nothing == ""
09:06:44 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
09:06:44 <lambdabot>         against inferred ...
09:06:44 <abelincoln> lesson 5, step23 uses @
09:06:48 <EvanR> > Nothing ==== ""
09:06:50 <mauke> <mauke> abelincoln: <mauke> which tutorial?
09:06:51 <lambdabot>   False
09:06:51 <abelincoln> without ever saying what it was :(
09:06:53 <srhb> abelincoln: What are you reading?
09:07:09 <shachaf> mauke: Presumably haskell.org/tutorial!
09:07:20 <abelincoln> tryhaskell.org => help
09:07:39 <srhb> abelincoln: You should probably look into Learn You a Haskell or something. :)
09:07:44 <EvanR> Nothing, False, [], M.empty, 0
09:07:44 <however> shachaf: there should be some sort of punishment for casually mentioning the R word in the presence of beginners
09:07:55 <shachaf> however: Not really?
09:07:59 <shachaf> It's very readable.
09:08:15 <shachaf> There exist much more opaque specifications.
09:08:26 <mauke> abelincoln: it just hangs
09:08:28 <mcstar> monaRd?
09:08:30 <srhb> I got stuck on the Haskell Report while starting out. It's readable now, but it made no sense then.
09:08:36 <abelincoln> sorry, thought this was an IRC for just tryhaskell >.>
09:08:52 <srhb> abelincoln: Ah, no, it's just #haskell :)
09:08:56 <coppro> shachaf: it is bad at explaining semantics though
09:09:05 <coppro> it sort of assumes that the semantics are obvious
09:09:51 <shachaf> abelincoln: That line is the one that explains @, I think.
09:09:57 <shachaf> You can also grab a whole value and pattern match on it (have your cake and eat it too):
09:10:00 <shachaf> let abc@(a,b,c) = (10,20,30) in (abc,a,b,c)
09:10:06 <shachaf> @ lets you "grab a whole value and pattern match on it"
09:10:29 <shachaf> If you think there's a better phrasing you should submit it. :-)
09:11:17 <coppro> @ is used to name a compound term in a pattern match :)
09:11:57 <MostAwesomeDude> Out of curiosity, is there a version of the 2010 report prepared as a diff against the 98 report?
09:12:29 <EvanR> > let abc@(a,b,c) = (10,20,30) in (abc,a,b,c)
09:12:31 <lambdabot>   ((10,20,30),10,20,30)
09:12:33 <shachaf> Not really, but there's a wiki page listing the important things that went in.
09:13:52 <abelincoln> can i ask what about lists rather than tuples causes let x@(a,b) = (3,4) in [x,b] to return the error let x@(a,b) = (3,4) in [x,b] while trying let x@(a,b) = (3,4) in (x,b) works fine?
09:14:13 <abelincoln> err copy and apste fail
09:14:24 <abelincoln> the error is Occurs check: cannot construct the infinite type: t = (t1,t)
09:15:00 <shachaf> All elements of a list must have the same type.
09:15:33 <srhb> abelincoln: And (a,b) cannot possibly be the same type as b.
09:15:53 <shachaf> It can be with equirecursive types!
09:15:54 <abelincoln> ah, okay. this is really different than python >.>
09:15:56 <ben> Note that x is the whole list, [a, b], so you're trying to make it say [[a, b], b], which can't be
09:16:03 <srhb> abelincoln: Oh yes. :P
09:16:22 <however> abelincoln: b is of type Int (by default), while x is of type [Int] (list of Ints). those are not the same.
09:16:24 <MostAwesomeDude> abelincoln: Oh, you know Python.
09:16:25 <shachaf> abelincoln: It's actually not *that* different from the way you're *supposed* to use lists and tuples in Python.
09:16:26 <ben> Haskell isn't sophisticated enough to cope with heterogenous lists~
09:16:33 <shachaf> But no one enforces it and people just do whatever.
09:16:35 <srhb> however: What?
09:16:39 <MostAwesomeDude> abelincoln: Lists are homogenous; they must all be of the same type.
09:16:47 <srhb> ben: What?
09:16:52 <srhb> <_<
09:17:05 <shachaf> srhb: Don't worry, everyone's just saying nonsense.
09:17:11 <shachaf> You might as well give in and join in.
09:17:15 <however> srhb: what do you mean?
09:17:15 <srhb> Ah ok.
09:17:32 <srhb> Heterogenous lists for life, Haskell couldn't drive a coffee machine if it had five heads.
09:17:37 <EvanR> not sure exactly what the deal is with python tuples/lists
09:17:56 <MostAwesomeDude> abelincoln: Tuples in Haskell are, well. I don't think that there's a straight analogy. You could think of them as new types created by combining existing types in a given order.
09:17:56 <ben> I got really mad at python when it turned out their lists are really arrays
09:18:09 <ben> and no one in the python channel could tell me what to import to get real lists
09:18:09 <EvanR> are they?
09:18:11 <MostAwesomeDude> ben: It's just nomenclature.
09:18:23 <however> evanr: if it walks like a duck and quacks like a duck, it must be a duck, a tuple, maybe a list, possibly a string, or a ConfigParser
09:18:25 <shachaf> MostAwesomeDude: That's sexist!
09:18:36 <ben> they kept telling me their lists were probably fine, but my pathological toy example really burned without O(1) removal
09:18:45 <MostAwesomeDude> ben: The deque is a data structure in Python which is nearly always a doubly-linked list.
09:18:53 <MostAwesomeDude> shachaf: Crap, what'd I say wrong? :c
09:19:10 <shachaf> "nomenclature". Try "nopeopleclature" or something.
09:19:34 <ben> There's no straight anology for lists because they're homogenous. There ought to be one for tuples, though.
09:19:40 <MostAwesomeDude> shachaf: Oh, pfft. Please tell me you're joking.
09:20:01 <shachaf> I'll do it if you do it.
09:20:23 <MostAwesomeDude> ben: The namedtuple is a very similar data structure in spirit, but doesn't have the same semantics.
09:20:51 <MostAwesomeDude> shachaf: "nome" is the root for "name" and "nomen" is just a plural. It's not anti-masculine, I promise. :3
09:21:08 <EvanR> feminist latin!
09:21:13 <srhb> MostAwesomeDude: What?
09:21:24 <srhb> People really should stop talking nonsense. :P
09:21:27 <shachaf> MostAwesomeDude: I will not let your "facts" get in the way of justice!
09:21:34 <MostAwesomeDude> shachaf: Noes, not the justice!
09:21:38 <shachaf> srhb has a point.
09:21:41 <srhb> Theuy're not even facts, they're wrong!
09:21:43 <srhb> So you're home safe.
09:21:46 <EvanR> men unite! rise up and throw off the feminine yokes! nowomenclature ftw!
09:22:08 <codolio> I believe it's spelled "gnome". Silent g.
09:22:28 <shachaf> hi codolio. hodolio
09:23:29 <shachaf> codolio: What's the difference between dolio and codolio?
09:25:29 <codolio> codolio is in the opposite category.
09:26:38 <shachaf> tibbe: By the way, bahaskell is moving to Mountain View, it seems.
09:27:17 <tibbe> shachaf: oh? permanently? to where exactly?
09:27:29 <shachaf> tibbe: ~Castro St.
09:27:46 <shachaf> I don't know if it's permanent, but the place in SF is no longer available for the purpose, so it depends on what else comes up.
09:28:10 <shachaf> I guess there'll be more information in the email.
09:32:05 <tibbe> shachaf: ah, I see
09:43:28 <DMcGill> which is better style: "f . g . h $ x", "f . g $ h x", "(f . g . h) x", "f $ g $ h $ x" or "f (g (h x))"?
09:43:42 <c_wraith> most people here will argue for the first
09:43:47 <ThePro> what does this Just mean?
09:43:54 <mauke> @src Maybe
09:43:55 <lambdabot> data Maybe a = Nothing | Just a
09:43:55 <c_wraith> and there's one good reason for preferring the first
09:44:08 <DexterLB> ThePro: Maybe can be either Nothing or Just x
09:44:14 <ThePro> hm
09:44:25 <c_wraith> it has the maximum number of subexpressions which are well-typed in isolation
09:44:27 <however> DMcGill: whatever is clearest with your function names (assuming they're not really f, g, h)
09:57:03 <jfischoff> what's a good name for a function at its domain i.e. (Set a, a -> b)?
09:57:25 <shachaf> Map a b?
09:58:43 <jfischoff> can you think of another one, I want to differentiate the two?
10:00:24 <S11001001> jfischoff: free associative?
10:01:02 <srhb> I don't quite get the question, doesn't function exactly encompass that concept?
10:01:48 <S11001001> srhb: not foldable
10:01:59 <shachaf> srhb: Not quite...
10:02:23 <jfischoff> S11001001: what is that in reference to? (quick google did give me much)
10:02:26 <shachaf> If you have type Foo a b = (Set a,a -> b), then a (Foo Int Char) can be applied to Ints not in the Set.
10:02:59 <srhb> True enough.
10:03:06 <jfischoff> yeah its really for partial functions a -> Maybe b
10:03:28 <jfischoff> but then you have the domain that it is total over
10:03:46 <S11001001> jfischoff: eating my own dogfood: https://bazaar.launchpad.net/~scompall/+junk/associative--mainline/view/head:/src/Data/Associative.hs
10:04:14 <shachaf> jfischoff: Have you seen conal's total-map?
10:04:34 <shachaf> @google conal elliott total map
10:04:35 <lambdabot> http://hackage.haskell.org/package/total-map
10:04:35 <lambdabot> Title: HackageDB: total-map-0.0.4
10:04:36 <jfischoff> shachaf: yeah very similar
10:07:27 <hpaste> olahol pasted “Clunky forM_ over a maps items” at http://hpaste.org/71146
10:07:43 <olahol> does anyone know a better way of doing this?
10:09:07 <ThePro> lets say i have a function which returns Just 2
10:09:14 <ThePro> how to get the 2?
10:09:19 <shachaf> @ty \m f -> mapM_ (uncurry f) (Data.Map.assocs m)
10:09:21 <lambdabot> forall a b (m :: * -> *) b1. (Monad m) => M.Map a b -> (a -> b -> m b1) -> m ()
10:09:22 <srhb> ThePro: You could pattern match it out
10:09:32 <shachaf> ThePro: Well, you have to consider the case that the function returns Nothing.
10:09:37 <shachaf> Pattern-matching is a good way of doing it.
10:09:44 <srhb> ThePro: That's usual the value of Maybes, because you'll have guarded functions where you either flow with the Just x or the Nothing
10:09:56 <shachaf> case (foo blah hmm) of Nothing -> ...; Just x -> ...
10:10:02 <ThePro> I am using findIndex to find an index of a char in a string
10:10:34 <srhb> @type findIndex
10:10:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
10:10:46 <shachaf> olahol: (Is one possible implementation, I think?)
10:10:46 <olahol> shachaf: thanks
10:11:11 <srhb> > case findIndex (=="a"= -> "abc") of Just x -> print x; Nothing -> putStr "NOPE"
10:11:13 <lambdabot>   <no location info>: parse error on input `='
10:11:15 <srhb> arrr
10:11:26 <srhb> > case findIndex (=="a") "abc" of Just x -> print x; Nothing -> putStr "NOPE"
10:11:28 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:11:28 <lambdabot>         against inferred ty...
10:11:31 <srhb> Oh really.
10:11:39 <Cale> 'a'
10:11:43 <Cale> 'a' :: Char
10:11:47 <Cale> "a" :: String
10:11:47 <geekosaur> =='a', yeh
10:11:48 <srhb> > case findIndex (=='a') "abc" of Just x -> print x; Nothing -> putStr "NOPE"
10:11:50 <lambdabot>   <IO ()>
10:11:53 <srhb> Cale: My bad :-)
10:12:11 <geekosaur> and just produce a string, not an IO action :p
10:12:19 <Cale> IO actions won't get executed by the bot
10:12:26 <geekosaur> > case findIndex (=='a') "abc" of Just x -> show x; Nothing -> "NOPE"
10:12:28 <lambdabot>   "0"
10:12:34 <olahol> shachaf: is there a performance penalty for converting it back to a list?
10:12:58 <srhb> ThePro: Did that make sense?
10:13:20 <srhb> ThePro: The pattern helps you ensure your program deals with all possible cases.
10:13:26 <shachaf> olahol: Possibly?
10:16:30 <jfischoff> S11001001: Interesting. I bookmarked your page. Its very related to what I was working on.
10:17:13 <ThePro> srhb: ah i think i got it
10:17:25 <ThePro> srhb: so its meant so be used on case
10:18:06 <srhb> ThePro: You could also have it in a function definition (it's basically the same)
10:18:22 <ThePro> k thx
10:18:33 <S11001001> jfischoff: let me know if you have any suggestions; it's my vague attempt to formalize something that proved very useful in real-world code recently.  In particular, replaceKeys doesn't fit quite as well, but was needed in any case
10:18:35 <srhb> > let foo (Just x) = show x; foo Nothing = "NOPE" in foo (Just 2)
10:18:37 <lambdabot>   "2"
10:24:46 <jfischoff> S11001001: Will do. Likewise, when it is on github, you might find my partial function instances (foldable, applicative, alternative) interesting, assuming they actually respect the laws which I have to validate.
10:32:15 <coldpizza72i> let divisors n = 1 : filter ((==0) . rem n) [2 .. n `div` 2]
10:33:18 <coldpizza72i> I'm trying to make a function numD instead that gives me the length of the list, and i was thinking i could do a lambda function or something but got stuck
10:33:50 <shachaf> numD = length . divisors?
10:34:34 <coldpizza72i> Is there an easy way of doing without the two separate functions
10:35:31 <srhb> coldpizza72i: Just chuck a length in front of it?
10:39:33 <coldpizza72i> shachaf: is there a way to do it without 2 separate functions
10:39:41 <coldpizza72i> this is kinds where I'm at let numDivisors length \n -> 1 : filter ((==0) . rem n) [2 .. n `div` 2]
10:39:49 <shachaf> coldpizza72i: Oh.
10:39:51 <shachaf> Just add parentheses.
10:40:00 <shachaf> Er, what?
10:40:11 <coldpizza72i> no lambda then?
10:40:14 <shachaf> You don't even have "=" in there.
10:40:23 <shachaf> You don't need a lambda any more than the other definition did.
10:41:08 <coldpizza72i> let numDivisors length (n = 1 : filter ((==0) . rem n) [2 .. n `div` 2])?
10:41:30 <shachaf> coldpizza72i: I think you don't really understand the syntax that you're typing. :-)
10:41:34 <shachaf> Do you know what that "=" is?
10:41:37 <mcstar> weird misunderstanding of the syntax
10:42:15 <coldpizza72i> schlicht: "=" reads defined as i believe
10:42:32 <mcstar> coldpizza72i: by that logic, you were defining 'n' to be somehting
10:42:41 <mcstar> do you want that?
10:42:46 <mcstar> (no)
10:42:51 <coldpizza72i> o
10:43:21 <mcstar> coldpizza72i: label <pattern1,...> = expressions
10:43:33 <mcstar> thats informally how you define something
10:43:53 <coldpizza72i> let numDivisors n = length (1 : filter ((==0) . rem n) [2 .. n `div` 2])
10:44:04 <mcstar> great
10:44:11 <coldpizza72i> :)
10:58:42 <coldpizza72i> why doesn't this work let numDivisors n = 1 + length [m | m <- [1 .. n `div` 2], m `rem` n == 0]
10:59:00 <zzing_> I have noticed we have [Char], Data.Text and ByteString (and more?) for text representations, is it possible to do everything with one of these and have high performance and unicode?
10:59:44 <dmwit> zzing_: Yes, use Text.
10:59:59 <shachaf> zzing_: ByteString isn't for text.
11:00:03 <dmwit> ByteString isn't for text.
11:00:04 <dmwit> ...yes
11:00:07 <shachaf> It's for...
11:00:16 <dmwit> strings of bytes!
11:00:18 <c_wraith> you can't use Text alone.  You need to do IO at some point.
11:00:23 <unlink> What is the idiomatic Haskell for this:   M.fromList . mapMaybe (\x -> x !? uid >>= \y -> return (y, x))  ?
11:00:30 <zzing_> Now I notice the API for pandoc uses [Char], is that just external api or internal too?
11:00:31 <srhb> coldpizza72i: Works for me
11:00:45 <coldpizza72i> hmm
11:00:51 <dmwit> unlink: :t (!?)
11:00:53 <srhb> > let numDivisors n = 1 + length [m | m <- [1 .. n `div` 2], m `rem` n == 0] in numDivisors 34
11:00:55 <lambdabot>   1
11:01:01 <unlink> s/uid/"uid"/
11:01:09 <srhb> Well, it compiles, certainly.
11:01:25 <byorgey> coldpizza72i: the arguments to `rem` are backwards
11:01:32 <unlink> dmwit: It's like Data.Map.lookup for BSON.
11:01:32 <coldpizza72i> o
11:01:34 <c_wraith> I think 34 has more than one divisor
11:01:42 <geekosaur> srhb, that compiles but seems not working ... that
11:01:45 <coldpizza72i> I'm not sure
11:02:00 <coldpizza72i> yea 2 is also
11:02:07 <byorgey> 1,2,17,34.
11:02:40 <dmwit> unlink: That doesn't seem to typecheck to me.
11:03:05 <dmwit> "uid" >>= \y -> return (y, x) :: [(Char, typeOf x)]
11:03:06 <shachaf> dmwit: I assume !? returns a Maybe.
11:03:14 <srhb> coldpizza72i: byorgey is right, m and n are switched in the remainder calculation :)
11:03:19 <dmwit> shachaf: and (!?) takes a ...?
11:03:24 <dmwit> Oh, precedence.
11:03:34 <shachaf> A map-like thing and a key?
11:03:58 <shachaf> Maybe something like fmap (,x) (x !? uid) would be nicer?
11:03:58 <dmwit> unlink: Anyway, foo >>= return . f is best written fmap f foo.
11:04:04 <dmwit> right
11:04:11 <shachaf> dmwit: Lots of stereo today.
11:04:39 <dmwit> Probably you just want a list comprehension, too.
11:05:16 <dmwit> M.fromList [(x, y) | x <- xs, Just y <- x !? "uid"]
11:05:24 <dmwit> uh
11:05:27 <dmwit> M.fromList [(x, y) | x <- xs, Just y <- [x !? "uid"]]
11:05:37 <dmwit> unlink: How's that look?
11:06:17 <unlink> Looks nicer. I don't usually use list comprensions, though. Still not bad.
11:07:08 <shachaf> [(x,y) | x <- map (!? "uid") xs] ?
11:07:15 <shachaf> Er.
11:07:22 <shachaf> Never mind, I completely messed that up.
11:07:31 <shachaf> In multiple ways.
11:07:32 * shachaf sighs.
11:08:35 <applicative> zzing_: it's all [Char]
11:08:49 <zzing_> applicative, isn't [Char] really slow?
11:09:19 <geekosaur> somewhat slow, very wasteful of memory
11:09:21 <applicative> I think attempts to make it use Text were slower. There is a text variant on github
11:10:05 <zzing_> ok
11:10:13 <applicative> I think the latter is somewhat faster but for a different reason, to which Text is irrelevant, namely the avoidance of two passes
11:10:51 <zzing_> I am doing a live markdown to html converter in snap and likely going to add caching (not sure how I would test performance to see what is faster)
11:11:01 <applicative> If Text were to be preferred I think it wouldnt be for the sake of speed but interoperability
11:12:01 <applicative> zzing_: but this may be wrong, just things I remember from the list
11:12:35 <unlink> Yes, M.fromList . mapMaybe (\x -> flip (,) x <$> x !? "uid") should work as well.
11:13:08 <applicative> I think a dedicated markdown to html machinery could probably be much faster; it could bypass the intermediate type, for example
11:13:24 <coldpizza72i> this is valid syntax right? load: "eq.hs"
11:13:30 <coldpizza72i> I'm getting load not in scope
11:13:32 <applicative> :load eq.hs
11:13:39 <applicative> : first
11:13:55 <applicative> or :l eq.hs
11:15:37 <unlink> M.fromList . mapMaybe (fmap <$> flip (,) <*> (!? "uid"))  for those of you still golfing
11:15:51 <coldpizza72i> is there anything wrong with this line     putStr( show ((2 * (numDivisors n) -  1)) mod 1000007 )
11:16:06 <applicative> > ( show ((2 * (numDivisors n) -  1)) mod 1000007 )
11:16:07 <lambdabot>   Not in scope: `numDivisors'
11:16:35 <applicative> > let numDivisors = (+1) in ( show ((2 * (numDivisors n) -  1)) mod 1000007 )
11:16:36 <avpx> coldpizza72i: mod isn't an infix operator
11:16:36 <lambdabot>   Couldn't match expected type `(a -> a -> a) -> t1 -> t'
11:16:37 <lambdabot>         against inf...
11:16:45 <applicative> > let numDivisors = (+1) in ( show ((2 * (numDivisors n) -  1)) `mod` 1000007 )
11:16:47 <lambdabot>   No instance for (GHC.Real.Integral GHC.Base.String)
11:16:47 <lambdabot>    arising from a use o...
11:16:54 <avpx> coldpizza72i: You can use it as an infix operator if you surround it by backticks, like: `mod`
11:16:55 <applicative> lot of problems here...
11:17:04 <coldpizza72i> oops
11:17:22 <Taneb> Insane conspiracy, fuelled by me reading a PDF on the history of Haskell: the fplangc email group is still active, and is secretly controlling the progress of Haskell
11:17:23 <applicative> > let numDivisors = (+1) in show $(2 * (numDivisors n) -  1) `mod` 1000007
11:17:24 <EvanR> > 19 `mod` 4
11:17:25 <lambdabot>   "(2 * (n + 1) - 1) `mod` 1000007"
11:17:25 <lambdabot>   3
11:17:29 <EvanR> > 19 `rem` 4
11:17:30 <lambdabot>   3
11:17:49 <applicative> > let numDivisors = (+1) in show $ (2 * numDivisors n -  1) `mod` 1000007
11:17:51 <lambdabot>   "(2 * (n + 1) - 1) `mod` 1000007"
11:18:22 <applicative> > let numDivisors = (+1) ; n = 3 in show $ (2 * numDivisors n -  1) `mod` 1000007
11:18:25 <lambdabot>   "7"
11:19:01 <coldpizza72i> let me pastebin
11:19:22 <EvanR> > x + 2 * 3
11:19:24 <lambdabot>   x + 2 * 3
11:19:25 <coldpizza72i> http://pastebin.com/55Lc0GBY
11:19:30 <mauke> I have copied your paste 55Lc0GBY to http://hpaste.org/71148 - pray I don't copy it any further.
11:20:12 <Taneb> mauke, has that message changed?
11:20:16 <Botje> yes, yes it has :)
11:20:17 <applicative> haha
11:20:19 <applicative> yes
11:20:25 <Taneb> I like it :)
11:20:42 <aristid> coldpizza72i: to use mod as an operator, write `mod` instead
11:20:53 <coldpizza72i> i did i thought
11:21:00 <coldpizza72i> ...
11:21:04 <EvanR> coldpizza72i: use div with mod, and quot with rem
11:21:04 <aristid> no, you wrote 'mod'
11:21:06 <aristid> not `mod`
11:21:15 <aristid> two different characters
11:21:22 <coldpizza72i> ohh yea
11:21:36 <zzing_> I noticed when I compiled a program (related to sna p server) with a lot of dependencies (that still did not much) that it was close to 100MB. If I were to take a C++ program that basically served webpages and statically linked it would it be roughly the same size?
11:21:48 <hpaste> applicative annotated “pastebin.com/55Lc0GBY” with “pastebin.com/55Lc0GBY (annotation)” at http://hpaste.org/71148#a71149
11:22:09 <applicative> coldpizza72i: also the 'let' was wrong
11:22:33 <coldpizza72i> it was?
11:22:53 <coldpizza72i> why
11:23:25 <applicative> oh it can't be
11:23:31 <applicative> at the top level like that
11:23:52 <applicative> you  just write numDivisors x = ... x ... at the left margin
11:24:42 <applicative> coldpizza72i: you are using an analogy from inside ghci where you do write 'let a = 1"
11:25:04 <EvanR> let a = 1 works inside a do block
11:25:27 <applicative> coldpizza72i: but that is because, as EvanR is saying, ghci is a bit like being inside a giant do block
11:25:38 <coldpizza72i> eq.hs:7:1: parse error
11:25:52 <srhb> coldpizza72i: We don't even have a line 7 in that paste.
11:26:13 <coldpizza72i> i don't have a line 7 either :-)
11:26:14 <srhb> coldpizza72i: I count five left parens and four right
11:26:22 <raek> could one say that the top level is like a giant where block? (modulo type definitions I guess)
11:26:25 <applicative> it's lookiing for mmore
11:26:42 <EvanR> raek: you can put type signatures in a where
11:26:42 <srhb> coldpizza72i: So match that last paranthesis :)
11:26:58 <EvanR> er... i think
11:26:58 <applicative> raek that's sort of the suggestion of module Blah where ...
11:26:59 <byorgey> raek: yes, modulo a few technicalities about type inference
11:27:09 <raek> EvanR: but not stuff like "data Foo = ...", right?
11:27:10 <byorgey> EvanR: yes, but not type *definitions*
11:27:18 <EvanR> yes
11:27:31 <EvanR> local data types could be nice ;)
11:28:07 <applicative> If we can have them inside ghci why not everywhere, inside lambdas...
11:28:59 <byorgey> "if we can have X in ghci why not everywhere" is fallacious.  ghci is quite special.
11:29:26 <coldpizza72i>     No instance for (Integral String)
11:29:34 <hughfdjackson> byorgey: in so much as it runs inside the IO monad?
11:29:35 <coldpizza72i>  No instance for (Num String)
11:29:42 <EvanR> > "456" `div` "3"
11:29:44 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
11:29:44 <lambdabot>    arising from a use ...
11:29:49 <SegFaultAX|work2> So I have a general question: I've read through LYAH very closely and I feel I have a good grasp on say, 85% of what I read (maybe more).
11:29:50 <applicative> byorgey: yes, I am working with my former a priori that lines in ghci is like a big do block
11:29:56 <SegFaultAX|work2> What now?
11:29:58 <applicative> are rather
11:30:26 <SegFaultAX|work2> I don't feel like LYAH gives you a good sense of "now you can start being useful with Haskell" because there is this other whole mountain of stuff.
11:30:36 * EvanR rewrites the error message to say "you cant use div with a String because it has no Integral instance"
11:30:43 <hughfdjackson> real world haskell seems to be more.. realworldy
11:30:47 <srhb> SegFaultAX|work2: I sort of had the same feeling and used RWH to tie the ends together
11:30:51 <SegFaultAX|work2> I mean sure, I have written a few trivial applications using Haskell. But trivial applications are, well, trivial.
11:30:53 <mcstar> not true, you can be productive after LYAH
11:31:03 <srhb> SegFaultAX|work2: But for getting the basics right, LYAH is just so good.
11:31:08 <EvanR> SegFaultAX|work2: you need to know about all the libraries
11:31:09 <mcstar> SegFaultAX|work2: you can hang out here, and give adive to newbies
11:31:20 <mcstar> advice*
11:31:33 <SegFaultAX|work2> mcstar: I'm still such a newbie though. I'm in no position to give advice (yet).
11:31:42 <Botje> SegFaultAX|work2: learning together is fun :)
11:31:45 <srhb> SegFaultAX|work2: When you finish LYAH, try RWH. :)
11:32:10 <mcstar> SegFaultAX|work2: now found something, you always wanted to write, and just start writing it
11:32:15 <applicative> byorgey: this is  why I was secretly kind of disappointed by the new power to declare data types in ghci it makes the environment even more impenetrable
11:32:18 <mcstar> find* (sry)
11:32:21 <SegFaultAX|work2> srhb: So I actually work with a guy who worked with bos (the author) and so he also reccomends that book highly.
11:32:32 <applicative> byorgey: though granting that this is unrealistic
11:32:47 <SegFaultAX|work2> mcstar: That's the problem, I don't feel I know enough of the language to be effective.
11:32:49 <EvanR> applicative: yeah, in other interpreters its suggestive of how the source code is written
11:32:53 <srhb> SegFaultAX|work2: I think most people here will, for the exact same motivations.
11:33:08 <S11001001> EvanR: I disagree http://hackage.haskell.org/packages/archive/acme-php/0.0.1/doc/html/src/Prelude-PHP.html
11:33:09 <EvanR> SegFaultAX|work2: just start writing the program and ask for help when you get stuck
11:33:19 <EvanR> S11001001: lol yeah php interpreter is horrible
11:33:19 <mcstar> SegFaultAX|work2: you will pick it up what you need, as you solve your problem, you can do quite much already, if you finished LYAH
11:33:22 <srhb> SegFaultAX|work2: But to be honest, setting a goal for a real, nontrivial application and doing it based on LYAH and a few questions here is quite doable.
11:33:38 <srhb> mcstar and I seem to be almost the same person right now. :-)
11:33:44 <SegFaultAX|work2> srhb: Sure, and that's how I've picked up the various other languages I know and use.
11:33:59 <zachk> SegFaultAX|work2: what kind of full-scale apps did you have in mind?
11:34:04 <SegFaultAX|work2> I write C++, Python, Ruby, and Erlang all day.
11:34:06 <mcstar> srhb: caucasian male, brown eyes, 180cm, 90kgs?
11:34:21 <coldpizza72i> how do you read in an int
11:34:21 <SegFaultAX|work2> And yet, I feel paralyzed when it comes to doing anythning of value in haskell because it's just _so_ different. :)
11:34:27 <srhb> mcstar: Caucasian fe, brownish, 179, not disclosed.
11:34:32 * zachk knows the feeling 
11:34:33 <srhb> :/
11:34:35 <mcstar> :)
11:34:48 <jfischoff> SegFaultAX|work2: for example?
11:34:50 <Peaker> SegFaultAX|work2, it was like this for ~4 months for me
11:34:52 <SegFaultAX|work2> (When I say all day, I mean literally, that's what I do for a living)
11:35:02 <SegFaultAX|work2> jfischoff: Of?
11:35:23 <jfischoff> SegFaultAX|work2: a project that you don't know how to start
11:35:30 <zachk> SegFaultAX|work2: do you wanna quickly play with some web stuff? try cabal install snap ;)
11:35:56 <SegFaultAX|work2> jfischoff: Maybe part of the problem is "I don't know which types of problems Haskell would be a good tool for, compared to the tools I already know and use"
11:36:17 <SegFaultAX|work2> I'm a "right tool for the job" sorta guy.
11:36:33 <SegFaultAX|work2> And the toolset I've mentioned above has served me well for > 10 years.
11:36:44 <applicative> coldpizza72i: what do you mean read in an int ? there is e.g. readLn which takes  a line of user input and returns what you want it to read,
11:36:50 <SegFaultAX|work2> I don't fully grasp how Haskell fits in the picture. It just seems so... diffeerent.
11:37:02 <spree> any of you smarties took optimization or know the simplex method anyway? i cant find a good resource to understand the algorithm(yeah i have been to wikipedia)
11:37:07 <EvanR> SegFaultAX|work2: thats a good question
11:37:10 <applicative> coldpizza72i: it's the same as fmap read getLine, I think
11:37:22 <coldpizza72i> applicative: is - and * infix
11:37:22 <EvanR> SegFaultAX|work2: ive been trying to figure out the same thing
11:37:28 <srhb> @src readLn
11:37:29 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
11:37:31 <zachk> spree: you need a SAT solver I think
11:37:31 <EvanR> SegFaultAX|work2: im finding server apps to be a good place for haskell
11:37:40 <applicative> there's a delicacy about - coldpizza72i
11:37:45 <EvanR> SegFaultAX|work2: its also good for scripts to process data
11:37:50 <coldpizza72i> ?
11:37:51 <srhb> @src readIO
11:37:52 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:37:54 <srhb> Meh.
11:37:57 <SegFaultAX|work2> EvanR: But that's what I use Ruby and Erlang for. And from what LYAH has taught me, my current tools are superior (or are they?)
11:38:16 <applicative> @type readIO
11:38:17 <lambdabot> forall a. (Read a) => String -> IO a
11:38:22 <EvanR> SegFaultAX|work2: yeah, but i find such apps to be easier in haskell than ruby because of the type safety
11:38:25 <srhb> What.
11:38:38 <applicative> @src readIO -- wont happen
11:38:38 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:38:38 <EvanR> SegFaultAX|work2: and the easier to use concurrency
11:38:46 <srhb> Indeed. What a strange type.
11:38:47 <kallisti> has anyone ever had problems with cabal-dev just... stopping?
11:38:54 <zachk> SegFaultAX|work2: haskell compiles down to decently tight machine code
11:38:56 <kallisti> stopping halfway through compilation of a package, no error messages
11:39:02 <SegFaultAX|work2> EvanR: That's a fair point. However, Erlang + Dialyzer goes a long way.
11:39:03 <kallisti> the whole thing failed with an error.
11:39:15 <zachk> Dialyzer?
11:39:18 <kallisti> something like "this package depends on that package which failed to install"
11:39:26 <SegFaultAX|work2> zachk: Static analysis of Erlang code.
11:39:35 <zachk> ahhh
11:39:36 <applicative> coldpizza72i: * and - are infix
11:39:42 <SegFaultAX|work2> zachk: Can find all kinds of type violation bugs.
11:39:55 <zachk> does Erlang compile?
11:39:59 <applicative> coldpizza72i: but negative numbers put a bit of a wrench in the use of -
11:40:00 <EvanR> SegFaultAX|work2: such a thing would be nice for many many dynamic systems, python, ruby, etc
11:40:05 <EvanR> php
11:40:25 <SegFaultAX|work2> zachk: Erlang is a virtual machine. More like a miniature operating system.
11:40:29 <mcstar> zachk: excuse me, why would he need a SAT solver?
11:40:38 <EvanR> the question is, why use system X with tool Y to make it usable when haskell has it designed in from the start ;)
11:40:38 <applicative> coldpizza72i: but you can any 'operator' as prefix if you put it in ()
11:40:46 <applicative> > (+) 2 3
11:40:47 <lambdabot>   5
11:40:50 * zachk may be off base here...
11:41:04 <mcstar> zachk: spree wants to solve linear programming with the simplex method
11:41:08 <zachk> mcstart: he said optimization problems? sometimes there is crazy logic involved
11:41:10 <applicative> > (-) 2 3
11:41:12 <lambdabot>   -1
11:41:14 * zachk is most likely off base 
11:41:29 <coldpizza72i> I'm not sure whats wrong here http://hpaste.org/71150
11:42:38 <srhb> coldpizza72i: You forgot to read n
11:42:42 <mcstar> n <- getLine
11:42:46 <applicative> coldpizza72i: it is reading show together with the parenthetical expression, then doing `mod` 1000007 on it
11:42:51 <mightybyte> SegFaultAX|work2: I got going in Haskell by using it for things that were too mind-numbing to do in any other language. :)
11:42:58 <coldpizza72i> srhb: i tried that too
11:43:00 <SegFaultAX|work2> So it sounds like I should either a) invent a new project to hack on or b) port one of my existing tools to haskell.
11:43:10 <applicative> woops
11:43:11 <SegFaultAX|work2> mightybyte: Like what, for example?
11:43:12 <EvanR> SegFaultAX|work2: write a game or a server or something ;)
11:43:14 <mightybyte> Web apps
11:43:16 <EvanR> write a webapp
11:43:28 <mcstar> write a theorem prover
11:43:32 <mcstar> pls
11:43:36 <SegFaultAX|work2> :D
11:43:50 <SegFaultAX|work2> Actually a web app is a good starting place since that's what I do IRL anyway.
11:43:50 <EvanR> write an AI
11:43:53 <mcstar> thats my holy grail
11:44:08 <coldpizza72i> srhb: i just annotated with my original try
11:44:11 <eikke> write a Haskell compiler!
11:44:14 <SegFaultAX|work2> I can apply a portion of my existing domain knowledge instead of starting totally fresh.
11:44:21 <hpaste> applicative annotated “a” with “a (annotation)” at http://hpaste.org/71150#a71152
11:44:23 <mightybyte> SegFaultAX|work2: I had been working on a web app in PHP with drupal, but I was tearing my hair out and couldn't motivate myself.  Haskell made it stimulating.
11:44:37 <applicative> coldpizza72i: it was both errors at once
11:44:45 <SegFaultAX|work2> What's a good framework for buliding web apps in Haskell?
11:45:01 <mightybyte> SegFaultAX|work2: I ended up writing the Snap Framework. :)
11:45:12 <applicative> you need read or readLn somewhere; but "hello" `mod` 6 doesn't make sense
11:45:17 <mightybyte> So that's obviously what I would recommend.
11:45:54 <hpaste> srhb annotated “a” with “a (annotation) (annotation)” at http://hpaste.org/71150#a71153
11:46:18 <SegFaultAX|work2> mightybyte: Getting a rec from the creator is good enough for me!
11:46:41 <EvanR> SegFaultAX|work2: i like to mix and match libs, starting with direct-fastcgi
11:46:53 <mightybyte> Join us in #snapframework for snap-specific questions.
11:47:11 <SegFaultAX|work2> mightybyte: Is it active?
11:47:17 <mightybyte> Yeah
11:47:20 <EvanR> a direct-fastcgi program with one of those crazy lightweight webservers ends up being a ridiculously efficient server
11:47:31 <SegFaultAX|work2> mightybyte: Sweet, I'll add it to my irssi conf. :D
11:49:49 <mcstar> spree: there an issue of the AMS Notices, which describes the simplex method, these papers are usually quite good, search fot it
11:50:03 <mcstar> http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=9&ved=0CHcQFjAI&url=http%3A%2F%2Fwww.ams.org%2Fnotices%2F200703%2Ffea-gale.pdf&ei=2Cb7T4m6IcrKswbM1s28BQ&usg=AFQjCNGv32k3IqPg_gsrtG0XfLui4MfkjQ
11:50:09 <mcstar> or alternatively ^^
11:50:21 <coldpizza72i> applicative: I'm still having trouble
11:51:33 <applicative> coldpizza72i: with what?  just keep posting srhb and I are repairing,...
11:51:37 <coldpizza72i> o new annotation
11:53:33 <mcstar> 1 `mod` 1000007
11:53:37 <mcstar> doesnt make much sense
11:53:43 <srhb> Yeah I don't understand what that is about either :P
11:54:08 <EvanR> > 1 `mod` 1000007
11:54:10 <lambdabot>   1
11:54:12 <EvanR> \o/
11:54:44 <EvanR> > 1 `mod` 1
11:54:45 <lambdabot>   0
11:54:51 <EvanR> > 1 `mod` 2
11:54:52 <coldpizza72i> >  2000016 'mod' 1000007
11:54:52 <lambdabot>   1
11:54:53 <lambdabot>   <no location info>:
11:54:53 <lambdabot>      lexical error in string/character literal at chara...
11:55:02 <geekosaur> coldpizza72i, `` is not ;;
11:55:05 <geekosaur> er, is not ''
11:55:06 <EvanR> coldpizza72i: fix your font
11:55:09 <coldpizza72i> opps
11:55:12 <coldpizza72i> ugh
11:55:20 <EvanR> > 1 `mod` 0
11:55:21 <lambdabot>   *Exception: divide by zero
11:55:42 <EvanR> > 1.0 `fmod` 0.0
11:55:44 <lambdabot>   Not in scope: `fmod'
11:57:02 <au__> 2 /quit
11:57:26 <EvanR> 2 legit 2 /quit
11:58:14 <aetoxx> How do I run a Haskell98 program without modifying any code with a new GHC?
11:58:49 <mauke> hmm. my guess would be some -package options
11:58:52 <aetoxx> -package haskell09 -hide-package base doesn't do the trick
11:59:12 <aetoxx> If I don't hide it, it tells me that Prelude comes from two packages.
11:59:35 <coldpizza72i> how do you do factorial
11:59:38 <aetoxx> Isn't there some -haskell98 option?
11:59:56 <mauke> aetoxx: -XHaskell98 ?
11:59:56 <rupert> hi, i have a data type Range which is an alias for the tuple (min, max)
12:00:03 <geekosaur> ^^
12:00:04 <srhb> coldpizza72i: So many ways.. How do you?
12:00:05 <mcstar> > product [1..100]
12:00:07 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
12:00:21 <coldpizza72i> is there not an operator i mean
12:00:22 <rupert> how can i change the behavior of show? i want to print (min - max) instead of (min, max)
12:00:25 <mcstar> http://www.willamette.edu/~fruehr/haskell/evolution.html
12:00:28 <coldpizza72i> n! ?
12:00:30 <mcstar> dont forget to read this ^^
12:00:37 <mauke> coldpizza72i: no
12:00:40 <geekosaur> rupert, you write your own instance instead of deriving one
12:00:41 <nand`> coldpizza72i: no postfix operators
12:00:49 <aetoxx> mauke, that doesn't actually exist, does it?
12:01:11 <geekosaur> aetoxx, you mean -XHaskell98?  it should exist as of ghc 7.4.x
12:01:19 <aetoxx> mauke, ghc --help | grep Haskell didn't find it.
12:01:23 <mauke> aetoxx: no, I was clearly on crack when I copy/pasted it from the manual
12:01:59 <EvanR> is there a floating point mod operationg
12:02:01 <EvanR> is there a floating point mod operation
12:02:01 <geekosaur> ghc --help is incomplete and specifcally says refer to the manual]
12:02:06 <rupert> i tried to do this, but i do not really know how to do this
12:02:16 <geekosaur> there are far too many options, languages, etc. to sanely list
12:02:29 <aetoxx> mauke, well, my manual doesn't list it.
12:02:29 <nand`> mauke: what GHC version are you using?
12:02:32 <rupert> instance Show Range where
12:02:35 <aetoxx> mauke, I will try it anyway.
12:02:35 <nand`> my manual doesn't list it either
12:02:47 <mauke> nand`: 7.0.2, why?
12:02:58 <geekosaur> I can tell you it works in 7.4.1 because I just tested it
12:03:25 <mauke> nand`: er, 7.0.4
12:03:28 <nand`> hmm, seems it's just my manual that's outdated
12:03:31 <coldpizza72i> is product [1..n] the most efficient factorial function
12:03:50 <EvanR> coldpizza72i: check out 'evolution of a haskell programmer'
12:03:51 <aetoxx> geekosaur, I just tried it here and it doesn't work.
12:03:56 <EvanR> coldpizza72i: theres a note on performance at the end
12:04:00 <aetoxx> geekosaur, it doesn't complain, but it doesn't deliver.
12:04:15 <geekosaur> that said it does seem to be missing from the listing in the online manual; probably should be reported as a bug
12:04:34 <aetoxx> geekosaur, Could not find module 'System'. It is a member of the hidden package 'haskell98<details>'.
12:04:52 <aetoxx> geekosaur, perhaps they don't document it, because it doesn't work?
12:05:11 <geekosaur> ... no, they don't work that way
12:05:20 <aetoxx> Did anyone write a Haskell auto porter?
12:05:29 <aetoxx> Just like exists for Python?
12:05:59 <zachk> autoporter?
12:06:11 <aetoxx> I don't get why they write a programming language (they even wrote the standard themselves) and then abandon it within 15 years or so.
12:06:24 <geekosaur> this does sound like a bug, but if it's one of the bugs fixed in 7.4.2 then you're kinda stuck
12:06:25 <mauke> aetoxx: no one abandoned haskell
12:06:37 <aetoxx> mauke, how can I run a Haskell98 program then?
12:06:51 <mauke> aetoxx: no idea
12:06:58 <geekosaur> looks like:  -package haskell98 -hide-package base
12:06:59 <mauke> given that there are no haskell98 compilers
12:06:59 <c_wraith> get an old version of ghc
12:07:01 <EvanR> you probably want to run a 'haskell program' instead
12:07:04 <however1> aetoxx: you may want to post the specific errors you're getting with the new ghc. people could give more specific advice then
12:07:07 <geekosaur> which is what -XHaskell98 is supposed to do, but.
12:07:38 <aetoxx> mauke, there are no haskell98 compilers? What?
12:07:52 * hackagebot for-free 0.1 - Functor, Monad, MonadPlus, etc for free (AaronBlack)
12:08:08 <mauke> aetoxx: to my knowledge no compiler implements the full standard
12:08:28 <geekosaur> the full standard is unimplementable actually
12:08:41 <EvanR> for-free huh, how is that different from the 'free' package
12:08:42 <aetoxx> geekosaur, continue...
12:08:46 <mauke> geekosaur: why?
12:09:03 <geekosaur> there's a bit of the layout rule that can't actually be implented as written, because there are multiple legal ways to do a certain case of brace insertion
12:09:05 <mcstar> not enough funding
12:09:08 <aetoxx> mauke, yes, I know that, but in the past they came closer.
12:09:20 <mauke> geekosaur: nice
12:09:22 <geekosaur> so two complaint compilers can do it in different ways and thereby not parse the same language
12:09:31 <geekosaur> compliant
12:09:37 * mauke compiles complaints
12:09:52 <rupert> type Range = (Int, Int)
12:09:52 <rupert> instance Show Range where
12:09:52 <rupert>   show ((m0, m1) :: Range) = show m0 ++ "-" ++ show m1
12:10:05 <EvanR> complaints will be compiled into /dev/null
12:10:11 <mauke> rupert: you can't do that
12:10:17 <mauke> rupert: 'type' doesn't create new types
12:10:29 <aetoxx> rupert, you have to use the right extensions to be able to do that.
12:10:30 <rupert> ok, it is just an alias?
12:10:35 <mauke> rupert: yes
12:10:44 <aetoxx> rupert, but it is a really, really bad idea.
12:10:45 <mauke> typedef, if you know C
12:11:17 <aetoxx> rupert, so, you can do it, but you shouldn't.
12:11:18 <rupert> ok, i should declare a type using data?
12:11:53 <aetoxx> rupert, a newtype would be appropriate.
12:12:10 <aetoxx> rupert, but it doesn't really matter a lot.
12:12:11 <however> rupert: data is one possibility, newtype is another. what the right tool for the job is depends on what you're trying to do. (if you want to post longer snippets of code, use hpaste.org )
12:12:31 <mauke> rupert: I'd use data
12:12:39 <geekosaur> also, you don;t generally define show, you define showsPrec
12:12:55 <aetoxx> geekosaur, which paragraph/rule says that exactly?
12:12:56 <mauke> do you? I don't
12:13:35 <aetoxx> Neither do I.
12:13:43 <aetoxx> But there are some advantages to it, IIRC.
12:13:51 <aetoxx> Then again, show isn't intended for user code.
12:14:11 <however> rupert: the simplest, crudest alternative might be to stick with the 'type' you have, not bother with an instance for Show, and make a new function rangeShow or whatever (you already have an implementation)
12:14:17 <geekosaur> aetoxx, are you talking about the layout rule thing?  I'd have to dig to find the mailing list discussion of the exact issue.  but do you really care or are you just being annoyed that a language had the brazen gall to *evolve* instead of staying still?
12:14:37 <aetoxx> geekosaur, I don't consider it an improvement if the language changes.
12:14:39 <however> :t showsPrec
12:14:41 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
12:14:46 <rupert> however: this sounds fine
12:14:53 <aetoxx> geekosaur, unless they add a compiler to go from one version to another.
12:14:58 <mauke> "stable" languages that have stopped evolving are also known as "dead"
12:15:16 <mcstar> CL is dead
12:15:32 <aetoxx> mcstar, which is why people implement STM also in CL.
12:15:38 <aetoxx> mcstar, and ported Python to it last year.
12:15:57 <mcstar> ported python to what?
12:16:04 <aetoxx> mcstar, and why it has better C interoperability than Haskell.
12:16:05 <mcstar> software transactionalmemory?
12:16:20 <aetoxx> mcstar, but sure... it's dead.
12:16:37 <aetoxx> mcstar, and why it has a better development environment than Haskell.
12:16:39 <mcstar> it really is, the language specificaiton
12:16:41 <BluePeppers> aetoxx, may not be the case in haskell, but in many languages, having an automated translator is not always a good thing, and often isn't possible for anything other than the most minor of changes.
12:16:47 <mcstar> it was written a long time ago, and doesnt change
12:17:02 <EvanR> uh oh
12:17:02 <aetoxx> mcstar, yes, and it doesn't need to change.
12:17:08 <EvanR> is this a CL vs haskell flameware starting
12:17:12 <srhb> Yeah :P
12:17:14 <aetoxx> mcstar, why would it have to change? It has read-syntax.
12:17:15 <mcstar> i dont think so
12:17:21 <BluePeppers> it was python vs haskell last night
12:17:25 <mcstar> aetoxx: who said it needs?
12:17:28 <EvanR> ubuntu vs slackware
12:17:30 <EvanR> lol
12:17:31 <aetoxx> mcstar, as such, any 'change' anyone would want to implement could be done.
12:17:34 <mcstar> aetoxx: i was just giving an example of a dead language
12:17:44 <mcstar> you took it as an offense
12:17:52 <aetoxx> mcstar, no, I did not.
12:17:53 * hackagebot test-simple 0.1.3 - Simple Perl inspired testing (BorisSukholitko)
12:18:04 <aetoxx> mcstar, I disagree with the notion of it being dead.
12:18:11 <aetoxx> mcstar, it's a stable language.
12:18:18 <aetoxx> mcstar, or unchanging.
12:18:20 <aetoxx> mcstar, not dead.
12:18:25 <EvanR> i hope the culture is not 'if its still working and doesnt need to be "fixed", its dead'
12:18:43 <EvanR> its like doing work for the sake of it
12:18:52 <EvanR> to satisfy managers
12:19:02 <aetoxx> EvanR, that's how a lot of companies work.
12:19:19 <geekosaur> anyway:  http://www.haskell.org/onlinereport/syntax-iso.html#layout note 1, but you can't quite see it there.  the point is when you have two nested layout contexts, the insert-brace-and-retry is not unambiguously specified
12:19:22 <EvanR> and here we have even more versions of C coming out
12:19:24 <EvanR> its like, why
12:19:32 <srhb> I don't know CL enough to tell if there are things that should be changed, but I certainly think that breaking programs, and hopefully in a way that breaks them from compiling, is often necessary in order to improve languages and keep the community alive.
12:19:47 <aetoxx> srhb, uhm, WHAT?
12:19:57 <EvanR> the community needs to be happy when stuff is Fing finished
12:20:05 <EvanR> and not expect more changes for the sake of changes
12:20:07 <geekosaur> aetoxx, it should be noted that haskell98 is mainly treated as a pedagogical language, like pascal.  nobody uses standard pascal, for good reason...
12:20:09 <srhb> aetoxx: You heard me. :)
12:20:32 <aetoxx> If you write a program, you write a language in a formal notation. That notation should be understood by computers forever like you are writing the f*cking bible.
12:20:45 <aetoxx> Anyone who doesn't get that, needs to grow up.
12:20:58 <mcstar> i dont speak/read hebrew
12:21:03 <srhb> Sure, for any given version. That doesn't mean we can't say "hmm, this feature x actually causes a lot of y, we should remove it" or whatever.
12:21:11 <EvanR> mcstar: old greek
12:21:27 <Enigmagic> i still code with punch cards
12:21:38 <however> aetoxx: your tone is very abrasive. #haskell prides itself on being civil. please adhere to that.
12:21:39 <Enigmagic> portable and low rates of corruption
12:21:42 <EvanR> STEM on my ethernet cable
12:21:47 <aetoxx> geekosaur, Oleg doesn't agree.
12:22:07 <mauke> aetoxx: clearly oleg doesn't know what he's talking about
12:22:17 <aetoxx> mauke, yeah, clearly.
12:22:18 <mcstar> keep in mind too, that haskell started out as a research language
12:22:38 <aetoxx> mcstar, keep in mind, that that is a completely insane argument.
12:22:43 <srhb> This is a silly discussion anyway.
12:22:54 <mauke> aetoxx: "That notation should be understood by computers forever" - are you the one who's going to maintain and port all the implementations?
12:23:17 <srhb> If you don't like a core philosophy in the development and life cycle of a certain language, you can expect to be pissed off so many times. Why would you ever bother with Haskell?
12:23:32 <aetoxx> mauke, if they cannot write their compilers in a way that it isn't a problem to maintain it forever, they should just learn compiler development.
12:23:33 <srhb> It'll just give you a heart disease. :-)
12:23:45 <srhb> Hehe.. Troll alert! :)
12:23:45 <geekosaur> waa waa waaaaa
12:23:47 <EvanR> aetoxx: u trollin
12:23:57 <mauke> aetoxx: your opinion has been noted
12:24:20 <aetoxx> EvanR, no, it's not like it's hard to add a flag to a compiler. Look at gcc.
12:24:25 <andreuk> I'm going through haskell.org tutorial, and I can't even paste in the factorial function definition... I put in "fac 0 = 1" and get back "<interactive>:1:7: parse error on input `='" .... what am I possibly doing wrong?
12:24:29 <EvanR> aetoxx: OK
12:24:30 <however> aetoxx: will you please stop insulting people
12:24:39 <BluePeppers> aetoxx, gcc is hardly noted for being easy to maintain/extend
12:24:39 <srhb> andreuk: In ghci you need to use let foo x = ...
12:24:43 <mauke> andreuk: trying to paste code in hgci
12:24:46 <srhb> andreuk: Instead of just foo x = ...
12:24:46 <mauke> andreuk: er, ghci
12:24:51 <aetoxx> BluePeppers, which was not what I was talking about.
12:24:59 <andreuk> jeez, how many interfaces/compilers are there? why isn't it standardized?
12:25:02 <EvanR> andreuk: let fac 0 = 1
12:25:12 <aetoxx> BluePeppers, even gcc, with all their ancient development methods still manages to keep old code running.
12:25:25 <geekosaur> scuse?
12:25:27 <aetoxx> BluePeppers, but somehow a 'state of the art' compiler cannot.
12:25:28 <andreuk> mauke: I *am* putting it in ghci
12:25:39 <BluePeppers> aetoxx, You said a compiler should be able to be maintained forever. and pointed to gcc. Which has really payed a price for maintaining so much backwards compatibility
12:25:48 <srhb> andreuk: It's an artefact of how ghci is built, and it is indeed a slight annoyance. You get used to it. If you write it in a source file and load it into ghci, you won't need it (and won't be allowed to use it like that)
12:25:57 <srhb> Hmm, spelling.
12:25:58 <aetoxx> BluePeppers, I didn't pay that price.
12:26:07 <BluePeppers> aetoxx, you wrote gcc?
12:26:11 <andreuk> srhb: fair enough... maybe the real noob tutorials like "haskell in 5 steps" on the website should mention this
12:26:18 <andreuk> srhb: considering that they are explicitly using ghci
12:26:28 <aetoxx> BluePeppers, I did not pay that price.
12:26:29 <srhb> andreuk: Yes, they absolutely should. Link please?
12:26:41 <andreuk> srhb: http://www.haskell.org/haskellwiki/Haskell_in_5_steps
12:26:42 <however> andreuk: ghci accepts pretty much a subset of the code that ghc accepts. "x = y" is one of the things outside the subset. (this will become clearer as you study haskell further; in ghci you're basically inside an IO block)
12:27:39 <mcstar> andreuk: on the wiki they load up the code, or compileit
12:27:39 <andreuk> srhb: I'm wrong, the part where they define fac is said to be inside fac.hs
12:27:41 <aetoxx> Ok, so who wants their programs to break in 10 years?
12:27:46 <aetoxx> Raise hands please.
12:27:49 <andreuk> mcstar: yes, my mistake
12:27:59 <srhb> andreuk: Indeed, but they should probably still mention it (without going into technicalities of the "why")
12:28:00 <mauke> andreuk: yes. you asked "what am I doing wrong?"
12:28:13 <geekosaur> aetoxx, I have seen very few programs continue to work in 10 years
12:28:20 <geekosaur> most of the ones that do are trivial
12:28:31 <geekosaur> come back wnen you've lived in the real world for a few years
12:28:33 <EvanR> aetoxx: i do, i even put an explicit check to make sure it bails if you run it in a year > 2022
12:29:04 <zzo38> Do you like CodensityAsk, CodensityAskT, Finalize, Decompose, Recompose, etc?
12:29:15 <aetoxx> EvanR, you are going to let it fail specifically for me?
12:29:25 <EvanR> no, f u
12:29:33 <geekosaur> "I want a pony too"
12:29:51 <aetoxx> geekosaur, lots of CL programs of >15 years old still work.
12:30:02 <aetoxx> geekosaur, 30 year old asm programs also still work.
12:30:02 <geekosaur> *yawn*
12:30:07 <srhb> I think this discussion is getting out of hand, people have strong opinions and it's not really relevant for most of us.
12:30:14 <aetoxx> geekosaur, tons of Pascal programs also still work.
12:30:14 <geekosaur> aetoxx, if you an find emulators to run them on maybe
12:30:37 <aetoxx> geekosaur, there are tons of company still using Pascal/Delphi and they are doing fine.
12:30:42 <zzo38> Old TeX programs always work even 50 years in future.
12:30:43 <aetoxx> er companies
12:30:49 <aetoxx> Yeah
12:30:52 * geekosaur does whois, concludes this can in fact be ignored safely
12:31:04 <BluePeppers> srhb, if he keeps this up, he could stay off topic for over several hours
12:31:14 * aetoxx notes that geekosaur needs to grow up
12:31:22 <BluePeppers> now that's just funny
12:31:26 <zzo38> Pascal and so on program may be different in future but TeX is same always.
12:31:50 <EvanR> ive never seen anyone get kicked for trolling this channel before, i think
12:32:17 <geekosaur> it happens
12:32:21 <srhb> No. It just kind of ruins the atmosphere and mood for new people joining us, and traditionally I think it's very good. :)
12:32:49 <geekosaur> not often but it happens
12:33:03 <aetoxx> Yeah, I am like the flu.
12:33:11 <mcstar> i dont think he needs kicking
12:33:15 <mcstar> we keep feeding him
12:33:19 <mcstar> i stfu
12:33:33 <aetoxx> I think this channel needs some kicking out of ivory towers.
12:33:54 <mauke> let's continue in #haskell-blah
12:34:01 <EvanR> unsafeThrowStonesInGlassHouse
12:43:00 <shapr> I get the impression aetoxx is angry about something. I wonder what.
12:43:10 <mcstar> i wonder woman
12:43:24 <shapr> mcstar: Oh hai! Are you writing Haskell today?
12:43:47 <mcstar> shapr: no, reading rather
12:44:47 <shapr> mcstar: Reading something interesting?
12:44:56 <shapr> I have the original Applicative paper on my to-read list.
12:45:19 <mcstar> reading conal's AD
12:45:30 <shapr> Oh, neat.
12:46:01 <jfischoff> shapr: Applicative Programing with Effects?
12:46:17 <Taneb> :t ap id unsafeCoerce --fixed point combinator
12:46:19 <lambdabot> Not in scope: `unsafeCoerce'
12:46:22 <shapr> jfischoff: Yah, that one.
12:46:42 <Taneb> :t let f a = f a in f
12:46:44 <lambdabot> forall t t1. t -> t1
12:46:47 <frerich_> Hi; I currently have a function which determines whether two 'Codes' match. A Code is "type Code = [Color]" and my function is basically "matches :: Code -> Code -> Bool". Now, one assertion of "matches" is that both codes have to be the same length. I currently have an 'assert' for that, but just wondered whether I could easily enforce this at compile time. Is there maybe a nice trick for this, or would I need to start tinkering wth type arithmetic ("data Ze
12:46:47 <frerich_> and "data Succ a" and the like)?
12:47:26 <conal> mcstar: enjoy!
12:47:26 <jfischoff> shapr: I just read that paper last week!
12:47:31 <shapr> jfischoff: What did you think?
12:47:37 <mcstar> conal: hi, thanks!
12:47:42 <Taneb> There's tuples, but then you lose a lot of things, frerich_
12:47:44 <conal> :)
12:47:59 <srhb> frerich_: For arbitrary length codes it gets tricky.
12:48:18 <byorgey> frerich_: yeah, you would probably need type arithmetic, and a new length-indexed list type
12:48:33 <byorgey> though for length-indexed lists in particular I think there's already something on hackage.
12:48:55 <conal> @where type-unary
12:48:55 <lambdabot> I know nothing about type-unary.
12:49:01 <conal> @wiki type-unary
12:49:01 <lambdabot> http://www.haskell.org/haskellwiki/type-unary
12:49:30 <conal> length-indexed lists/vectors ^^ . there are other such packages.
12:49:40 <jfischoff> shapr: very good. I had tried reading it two years ago but I couldn't follow it really. The one thing that is confusing is that in Base we have Foldable, which means some off of the Traversable examples do not need a Traversable instance.
12:50:05 <jfischoff> shapr: also it made me wish I new more about the s, k, i calculus
12:50:09 <Taneb> conal, broken link?
12:50:18 <shapr> jfischoff: How is Foldable related to Applicative? Same paper?
12:50:19 <dmwit> What's the absolutely most clever (but still lazy) way to take two lists and return one that's as long as the length of the second minus the length of the first?
12:50:26 <frerich_> conal: Thanks for the link! Indeed, it appears there are many implementations of this. I guess everybody whips up one of these himself sooner or later (it must be a Haskell rite or something).
12:50:59 <dmwit> Maybe lazy is too much to ask for. Since I don't know what I mean by lazy.
12:51:16 <byorgey> I suppose conal meant http://hackage.haskell.org/package/type%2Dunary
12:51:20 <Eduard_Munteanu> Lazy programmer or lazy evaluation? :)
12:51:24 <mauke> :t drop . length
12:51:26 <lambdabot> forall a a1. [a1] -> [a] -> [a]
12:51:32 <dmwit> right
12:51:35 <dmwit> Lazy enough.
12:51:36 <jfischoff> shapr: They cover Traversable, which uses applicative functors, but the the Traversable in the paper and in base are slightly different
12:51:37 <dmwit> Thanks. =)
12:52:05 <jfischoff> shapr: The paper doesn't have Foldable essentially.
12:52:10 <Rc43> Anybody knows how to read from StdStream? createProcess returns it
12:52:30 <dmwit> ?hoogle createProcess
12:52:30 <lambdabot> System.Process CreateProcess :: CmdSpec -> Maybe FilePath -> Maybe [(String, String)] -> StdStream -> StdStream -> StdStream -> Bool -> CreateProcess
12:52:31 <lambdabot> System.Process data CreateProcess
12:52:31 <lambdabot> System.Process createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
12:52:46 <however> Rc43: i bet it's using hGetLine and similar
12:52:48 <Rc43> Oh
12:52:50 <dmwit> Rc43: No it doesn't?
12:52:58 <byorgey> Foldable can be viewed as a sort of 'degenerate' Traversable
12:53:07 <Rc43> It is handle, not StdStream, now it is clear.
12:53:53 <Rc43> (I searched methods for StdStream not for Handle.)
12:54:06 <conal> hah. i got it wrong twice. yeah. i meant:
12:54:08 <conal> @hackage type-unary
12:54:09 <lambdabot> http://hackage.haskell.org/package/type-unary
12:54:30 <conal> Thanks, Taneb & byorgey
12:55:10 <Nafai> byorgey: btw, your blog tool is awesome!  I'm going to give it a try the next time I write an entry
12:55:12 <Taneb> I don't feel thankworthy :/
12:55:25 <byorgey> Nafai: thanks, glad you like it!
12:55:31 <shapr> Bah, now I want to go read that paper instead of doing ghclive code.
12:55:49 <byorgey> Nafai: let me know how it goes, and whether there are any additional features you'd like to see
12:56:22 <byorgey> shapr: which paper? "Applicative Programming with Effects"?
12:56:26 <shapr> Yes, that one.
12:56:40 <Nafai> byorgey: editing entries :)
12:56:41 <byorgey> yeah, that's a nice paper
12:56:50 <byorgey> just skip the stuff at the end with the scary commutative diagrams
12:56:56 * shapr gives in and reads...
12:57:09 <mauke> :t reads
12:57:11 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:58:02 <byorgey> also, everyone should come to Philadelphia August 3-5 for Hac Phi!
12:58:08 <byorgey> well, OK, maybe not *everyone*
12:58:17 <srhb> No, it is a bit far for some.. :P
12:58:30 <byorgey> also it would be rather crowded
12:58:50 <theadmin> What's this "forall a." in types lambdabot gives anyway? GHCi says type of read is "Read a => ReadS a"...
12:58:51 <shapr> I'd love to show up :-)
12:58:53 <srhb> I was under the impression that Philadelphia is rather big. :-)
12:59:02 <mauke> theadmin: same thing
12:59:04 <srhb> theadmin: The forall is implicit in ghci
12:59:21 <mcstar> conal: recip  (D x x') = D (recip x) (x' / sqr x) , dont you need a negate in the last expession?
12:59:40 <byorgey> srhb: yes, but not big enough for *everyone*
12:59:55 <srhb> byorgey: This may be true.
13:00:42 <theadmin> srhb: Well, even if it is implicit, what IS it?
13:00:46 <jfischoff> shapr: fyi, the 'reduce' function in the paper I think became 'fold' in Foldable.
13:01:04 <mauke> theadmin: a type variable quantifier
13:01:12 <conal> mcstar: hm! i think you're right. wow. i've had that bug for a long time.
13:01:16 <byorgey> as for distance, I should point out that past Hac Phi attendees have come from exotic places like Canada and the Netherlands
13:01:18 <srhb> theadmin: forall a simply means for ALL types a...
13:01:34 * frerich_ wonders why he has the strong urge to name his Haskell projects so that their name includes "lambda" or "mu" or "hask" or so. I wonder if I'd do the same if 'C++' would be easier to pronounce...
13:01:35 <mauke> length ∷ ∀α. [α] -> Int
13:01:37 <theadmin> srhb, mauke: Ah, I see
13:01:49 <mauke> length ∷ ∀α. [α] → Int
13:02:06 <parcs`> ℤ
13:02:07 <srhb> mauke: So pretty.
13:02:16 <mauke> frerich_: "sepples"
13:02:22 <srhb> byorgey: I see you're the new maintainer of haxr, can I ask you a question or two about it?
13:02:24 <conal> mcstar: no. it's right as is.
13:02:47 <mcstar> conal: can you explain?
13:02:52 <kallisti> why is cabal-dev using the HUnit that's already installed in ~/.cabal when resolving dependencies?
13:02:58 <byorgey> srhb: of course
13:03:25 <theadmin> kallisti: Why wouldn't it? What's the point of reinstalling something that's already installed?
13:04:05 <kallisti> theadmin: to prevent dependency conflicts, such as the one I'm having.
13:04:05 <however> byorgey: truly exotic, both. i hear they wear their shoes on their hands and sing everytime they use the bathroom
13:04:15 <srhb> byorgey: Thanks. I'm a bit new to haskell too, so bear with me, please. I was extremely impressed by the asXmlRpcStruct TH bit, but I seem to run into issues a lot where I'm building a client which either overlapping field names or names that are not valid in Haskell. Is the only solution really to derive my own instances and use getField?
13:04:16 <jfischoff> kasllisti: cabal dev does not ignore global packages
13:04:30 <conal> mcstar: oh yeah. sry. i was thinking sqrt.
13:04:35 <mcstar> (x^n)' = n*x^(n-1)*x'; (x^-1)'=-1*x^-2*x'
13:04:47 <Rc43> Hmm, why `createProcess "find" ["."]` returns Nothing for stdout?
13:04:59 <conal> mcstar: where do you see that buggy recip equation?
13:05:11 <mcstar> conal: http://conal.net/blog/posts/what-is-automatic-differentiation-and-why-does-it-work
13:05:26 <mcstar> where you declare D a as an instance of Num
13:05:34 <mauke> Rc43: that looks like a type error
13:06:12 <Rc43> mauke, where?
13:06:18 <Taneb> What happens if main has a non-IO type?
13:06:18 <conal> mcstar: thx. i'll fix it. fortunately not present in the paper or library.
13:06:29 <Rc43> mauke, oh, I mean `proc` between `createProcess` and "find"
13:06:39 <Taneb> Nothing? Everything? Run-time error?
13:06:50 <Rc43> so it is `createProcess $ proc "find" ["."]`
13:06:56 <mcstar> np
13:06:58 <mauke> Rc43: that would be because 'proc' makes find inherit your stdout
13:07:03 <geekosaur> Taneb, compile time error
13:07:21 <byorgey> Taneb: try it and see.
13:07:31 <theadmin> Taneb: That's impossible. Main.main is either IO () or IO a.
13:07:37 <geekosaur> IITRC the standard says main :: IO () and GHC relaxes that to main :: IO a
13:07:38 <mauke> Rc43: try createProcess (proc "find" ["."]){ std_out = CreatePipe }
13:08:00 <Taneb> Oh, okay
13:08:07 <conal> urgh. my blog is slow to load (as i've been told). looking forward to jettisoning wordpress someday.
13:08:37 <EvanR> conal: really? its not running on haskell ? :)
13:08:50 <soulsaver> is dualiy about for example turning max f(x) into min -f(x)? ie gives same result?
13:08:53 <conal> EvanR: really :(
13:09:01 <Rc43> mauke, it will redirect stdout from screen into "my program"?
13:09:14 <conal> i'd love to convert to hakyll or some such.
13:09:15 <mauke> Rc43: yes
13:09:30 <byorgey> srhb: I'm afraid so.  The punning between xml field names and Haskell names is convenient when it works but doesn't really scale, as you have discovered.
13:10:00 <srhb> byorgey: Sad. When just one field overlaps I have to build an entire instance. Oh well! Thanks for clearing that up :)
13:10:06 <byorgey> srhb: however, it's not hard to imagine generalizing the TH interface so it can optionally take a mapping between Haskell names and xml field names.
13:10:24 <srhb> byorgey: Something like that was what I suspected existed, but I guess not yet. :)
13:10:35 <byorgey> I don't really have time to work on that myself but would happily accept patches in that direction.
13:10:54 <theadmin> How do you deal with contractions in function names and data-type names? (RGB versus Rgb, stringToRGB versus stringToRgb, rgbToString versus _RGBToString), what's the convention?
13:10:57 <srhb> byorgey: Hmm. I'll take a look and see if I understand any of the inner workings yet, but I fear not.
13:11:24 <Rc43> is `IO Maybe Something` awful thing?
13:11:49 <srhb> No, why?
13:11:59 <theadmin> Rc43: ...Why not "Maybe IO Something"?... I see no point in sending Nothing to an IO stream so...
13:12:16 <byorgey> IO Maybe Something is a kind error.  Perhaps you mean  IO (Maybe Something)?
13:12:24 <shapr> conal: hakyll is *really* simple, probably wouldn't take more than an afternoon at most.
13:12:29 <Rc43> byorgey, yes
13:12:35 <shapr> conal: Have you seen hakyll-contrib's simpleblog?
13:12:50 <Rc43> theadmin, because I am reading line from handle and it can be and can not to be
13:13:34 <conal> shapr: i haven't. it's the conversion i'm worried about, including comments.
13:13:35 <byorgey> srhb: I'm also happy to try to answer questions about the inner workings
13:13:56 <shapr> Ah, I don't know how convert comments... disqus?
13:14:05 <srhb> byorgey: OK, I'll poke you. :)
13:14:33 <theadmin> Rc43: Maybe (IO String)?
13:14:49 <byorgey> You would have to use some kind of external commenting system, since hakyll is a static site generator
13:14:54 <mauke> theadmin: no
13:14:58 <S11001001> theadmin: you can
13:15:05 <S11001001> 't get that from IO (Maybe String)
13:15:14 <kallisti> jfischoff: HUnit isn't global as far as I know.
13:15:16 <hpc> dont use disqus
13:15:41 <byorgey> hpc: could you elaborate?
13:15:42 <Rc43> theadmin, what is right way for converting IO Maybe to Maybe IO? I am returning Myabe _from_ IO.
13:15:43 <shapr> hpc: Why so?
13:15:48 <hpc> it doesnt display anything at all unless javascript is turned on
13:15:56 <kallisti> Rc43: you don't
13:15:59 <theadmin> Rc43: Ohh... Wow. Uhm.
13:16:04 <jfischoff> kallisti: I've seen that happen when the stuff is installed with the haskell platform, which might default to global
13:16:07 <hpc> and as far as comment systems go, it isnt even that good
13:16:16 <kallisti> jfischoff: aha
13:16:21 <shapr> hpc: It works, it's free?
13:16:21 <kallisti> where are global packages installed?
13:16:27 <mauke> I'm not going to enable javascript from disqus.com just to read comments on some random website
13:16:34 <Rc43> theadmin, I am checking hReady, and if it is False then I am returning Nothing.
13:16:40 <hpc> shapr: except when it doesnt work :P
13:16:50 <shapr> hpc: Are there better options?
13:16:54 <theadmin> kallisti: ghc -v | grep package
13:17:00 <hpc> there is something to be said for not having comments at all
13:17:05 <S11001001> Rc43: maybe you should return return Nothing
13:17:13 <shapr> hpc: Yes, but I also like receiving comments.
13:17:16 <zzing_> Is there a functional data structure equivalent to a bin?  (specifically: http://en.wikipedia.org/wiki/Bin_%28computational_geometry%29 )
13:17:32 <shapr> hpc: So, assume I wish to have comments on a static hakyll blog, is there a better option than disqus?
13:17:38 <hpc> shapr: make your blog not static
13:17:50 * shapr randomly hugs byorgey for writing awesome software
13:17:58 <shapr> hpc: I'll stick with disqus then :-)
13:18:07 <hpc> disqus is a bad solution for a contradiction of a problem
13:18:10 <mauke> shapr: get so popular that someone else sets up a version with comments
13:18:26 <hpc> like trying to grow trees without water or sunlight
13:18:37 <shapr> mauke: Like chrisdone's hackage disqus comments? :-)
13:18:57 <mauke> like http://blog.refefe.de/
13:18:57 <shapr> hpc: You could be right, I don't know. But at the moment, I would like to have comments on my static hakyll blog.
13:19:15 <however> conceivably you could have some kind of comment form which on the server-side invokes hakyll to write out a new static html page, with the new comment
13:19:25 <frerich_> Hi, I'm currently experimenting with Parsec, but it's pushing the limits of my Haskell knowledge a bit - many parser generator functions (is that how you call them?) have types like "parseThis :: GenParser Char st String". I cannot figure out what "st" is - shouldn't it be a type? That can't be I think, because type names have to start with an uppercase letter.
13:19:37 <hpc> however: codinghorror does that
13:20:04 <hpc> it assumes a certain level of unpopularity
13:20:08 <mauke> frerich_: it's a type variable
13:20:38 <however> frerich_: that's a type variable, similar to the "a" and "b" in map :: (a -> b) -> [a] -> [b]
13:20:41 <frerich_> mauke: Hm, doh, of course - but where is it filled with meaning?
13:20:56 <nule> i think i'm doing this the hard way, maybe someone can give a look
13:20:56 <theadmin> frerich_: The function body?
13:21:00 <hpaste> nule pasted “Looping on IO” at http://hpaste.org/71158
13:21:10 <mauke> frerich_: runParser at the latest
13:21:18 <hpc> frerich_: it doesn't
13:21:23 <however> frerich_: you probably don't need to understand all the weird GenParser types in order to successfully use parsec (or parsec-ish libraries)
13:21:39 <nule> that part works, but I need to create a list of those "steps" lists and trying to loop on functions with IO is confusing me
13:21:58 <hpc> frerich_: restrict yourself to the Parser type
13:22:10 <hpc> and everything starts to look simpler
13:22:13 <nule> i got a function working with n -> [IO [Int]] and got stuck
13:22:17 <jfischoff> frerich_: With Parsec you can have custom state that parser can use. That is what the st type is for … I'm pretty sure. I've never used it. I would ignore it.
13:22:22 <theadmin> nule: There's mapM, mapM_, forM and forM_. Look at those, it might help?
13:22:37 <frerich_> jfischoff: Yeah, I gathered that "st" seems to be the "state" type, but everybody appears to be using () there
13:22:39 <however> :t sequence -- nule
13:22:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:22:45 <hpc> jfischoff: it is a state that is sensitive to backtracing
13:23:05 <hpc> unlike transforming over StateT
13:23:18 <nule> i got stuck on sequence, but i'll look again at that and check out mapM forM *, thanks theadmin/however
13:23:20 <jfischoff> hpc: what would be a use case?
13:23:50 <hpc> jfischoff: dunno
13:23:55 <hpc> dont do much parsing
13:24:02 <frerich_> mauke, however, hpc, everybody else who replied: Thanks for clearing thigs up, I'll just stick with 'Parser a' :-)
13:24:28 <jfischoff> hpc: aye
13:24:31 <jfischoff>  I am curious though
13:24:51 <hpc> oh, i know
13:24:51 <however> frerich_: just a suggestion -- i found this chapter to be the most clear explanation of parsec http://book.realworldhaskell.org/read/using-parsec.html#csv (you'll go mad if you try to learn parsec from the haddock, for instance)
13:24:56 <nand`> Mu is to types as fix is to functions, right? the same way I can rewrite any recursive function in terms of fix $ \f ... ->   I can rewrite any recursive data type in terms of Mu on data X ... f; correct?
13:25:01 <theadmin> nule: Not sure if those are what you want, but they help you map IO over lists, example: mapM_ print [1..5]
13:25:02 <hpc> context-sensitive grammars
13:25:12 <hpc> in applicative/alternative style
13:25:47 <frerich_> however: That's precisely what I'm reading right now. The very first example in that chapter has this: "csvFile :: GenParser Char st [[String]]" and that's what made me just keep using "st" everywhere without every understanding what it's actually good for.
13:26:19 <frerich_> however: As far as I can see, the only explanation of "st" is this: 'The st can be ignored for now.' :-]
13:27:07 <hpc> frerich_: i skipped rwh
13:27:15 <hpc> and went stright to the docs
13:27:50 <hpc> you can pick up most of it eaasily, once you get past the initial "how do i run a Parser" stage
13:28:03 <however> frerich_:  oh you're right, rwh does talk about GenParser Whatever :-/ i'm surprised they even spelled out those types. i don't think it does anything to enlighten anyone ...
13:28:28 <nule> theadmin/however: thanks - you were right of course, sequence works when the parens are in the right place... /facepalm
13:28:35 <hpc> learn on your own until you get to "try"
13:28:42 <hpc> then go back to rwh
13:28:53 <however> nule: no worries :)
13:29:17 <Eduard_Munteanu> nand`: up to isomorphism
13:30:27 <jfischoff> hpc: now I just need to understand context sensitive grammars and their value ;)
13:30:46 <hpc> jfischoff: you know what a cfg is?
13:31:07 <hpc> like, imagine a cfg for arithmetic expressions
13:31:15 <jfischoff> hpc: yeah
13:31:30 <hpc> but then imagine you can assign a precedence for each operation
13:31:34 <hpc> in-language
13:31:40 <jfischoff> ok
13:31:48 <mauke> infixl 3 ???
13:32:04 <hpc> cant do that without the "context" of a context-sensitive grammar
13:32:05 <jfischoff> are we there?
13:32:10 <jfischoff> ah
13:32:20 <jfischoff> okay that makes sense
13:32:22 <hpc> see the great wiki in the sky for a precise definiton of context
13:32:47 <jfischoff> I looked found it lacking
13:32:55 <jfischoff> your example should be there :)
13:33:49 <dmwit> So, is Haskell context-free or not?
13:34:15 <jfischoff> I would think not
13:34:38 <dmwit> I guess only if I hand you all the fixity declarations up front.
13:35:14 <twanvl> what about layout?
13:35:41 <theadmin> twanvl: It's not a "must". You can write an entire Haskell program in a single line. Though that's ugly.
13:35:42 <dmwit> oh, bugger
13:35:54 <c_wraith> fixity declarations are incredibly context-sensitive
13:36:24 <c_wraith> But whitespace is also pain
13:37:45 <theadmin> I don't see how it's a pain, I mean, as long as it's not forced like in Python...
13:38:53 <c_wraith> because when parsing the language, you have to accept everything allowed
13:39:20 <theadmin> c_wraith: True. Are you writing your own compiler or something?
13:39:28 <c_wraith> I didn't ask the question in the first place
13:40:03 <theadmin> Ah, sorry.
13:40:30 <balor> When calling a function with signature such as "f : Monad m => String -> m ()" I get an error stating ambigous type variable m0... (http://hpaste.org/71159) why is m ambiguous in such a function?
13:41:06 <mauke> hmm. is that the MR?
13:41:32 <hpc> yes
13:42:28 <c_wraith> well, the MR can result in that sometimes, anyway
13:42:42 <c_wraith> > return ()
13:42:43 <lambdabot>   No instance for (GHC.Show.Show (m ()))
13:42:44 <lambdabot>    arising from a use of `M514456570...
13:42:54 <however> balor: at your ghci prompt, type -XNoMonomorphismRestriction
13:42:56 <c_wraith> heh.  lambdabot appears not to monomorphize!
13:43:02 <c_wraith> which doesn't help
13:43:05 <theadmin> Arising from use of WHAT?
13:43:09 <c_wraith> > return () :: Just ()
13:43:10 <lambdabot>   Not in scope: type constructor or class `Just'
13:43:15 <c_wraith> > return () :: Maybe ()
13:43:16 <lambdabot>   Just ()
13:44:08 <Botje> theadmin: lambdabot generates a random package name to put stuff in.
13:45:38 <balor> however, thanks
13:45:51 <theadmin> Botje: Oh.
13:45:58 <however> balor, you're welcome
13:48:20 <theadmin> Hm. Is it sane to have a "main" in a module if that main isn't exported? (for example purposes or something like that)
13:51:37 <otters> > let fix' f = f (fix f) in fix' (1:)
13:51:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:51:40 <otters> no way
13:51:42 <otters> no wait
13:51:46 <otters> > let fix' f = f (fix' f) in fix' (1:)
13:51:47 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:51:51 <otters> okay, so it works the same way
13:52:00 <otters> in that case, why is fix defined the way it is instead of just f (fix f)?
13:52:09 <c_wraith> otters: operational concerns
13:52:26 <c_wraith> otters: in particular, the definition with a let binding ties the knot, so it minimizes allocation
13:52:35 <otters> oh
13:52:45 <c_wraith> otters: where the definition you gave allocates a new cons cell for every element of the list
13:53:55 <Veinor> theadmin: it won't break anything
13:54:11 <Veinor> @src fix
13:54:12 <lambdabot> fix f = let x = f x in x
13:54:50 <Veinor> c_wraith: so in fix (1:) , all the 1s are 'the same'?
13:55:01 <theadmin> Where is fix defined?
13:55:02 <c_wraith> Veinor: all the (:)s are the same, too
13:55:07 <Tomsik> Anyone knows what is the right place to ask elm-related questions?
13:55:07 <nand`> theadmin: Data.Function I think
13:55:08 <c_wraith> theadmin: Data.Function
13:55:23 <otters> Control.Monad.Fix
13:55:28 <Veinor> hmm
13:55:30 <Tomsik> #elm is empty and can't find anything on the website
13:55:32 <otters> oh
13:55:42 <theadmin> nand`: Thanks, that's it
13:55:58 <Veinor> c_wraith: oh, that makes sense
13:56:51 <nand`> otters: Control.Monad.Fix just re-exports it
13:59:11 <byorgey> otters: it used to be defined in Control.Monad.Fix
13:59:21 <byorgey> before there was a Data.Function
13:59:39 <c_wraith> Data.Function is kind of strange
13:59:50 <c_wraith> it only exports on and fix, right?
14:00:19 <c_wraith> oh, ok, there's a bunch more in it
14:00:31 <c_wraith> it's just that the rest are re-exported by the Prelude
14:00:40 <otters> does ghci have a command that lists the exports of a module
14:00:42 <byorgey> it re-exports some stuff from the Prelude too
14:00:45 <c_wraith> :browse
14:00:53 <otters> oh neat
14:05:08 <theadmin> Does it have anything to view the source of a function? I know there's :list but it doesn't work for Prelude stuff, for example.
14:05:45 <byorgey> no
14:06:28 <theadmin> Oh, duh, I can just go to the Haskell report, it has the Prelude source
14:06:58 <byorgey> the Haskell report has code which specifies the semantics of Prelude functions
14:07:11 <byorgey> however, the actual implementations are sometimes different for efficiency reasons
14:07:31 <theadmin> byorgey: True, but that's fine, I still can understand how stuff works.
14:07:32 <byorgey> if you want to see the actual source you can search for functions on Hoogle and then click on 'source'
14:07:43 <identity> There's also @src
14:07:45 <identity> @src map
14:07:46 <lambdabot> map _ []     = []
14:07:46 <lambdabot> map f (x:xs) = f x : map f xs
14:07:49 <byorgey> sure, if your goal is just to understand how things work, the Report is ideal
14:07:51 <theadmin> What I totally don't understand is the definitions of (-) and negate, they... depend on each other
14:08:06 <mauke> theadmin: that's only the fallback code
14:08:08 <byorgey> theadmin: those are the *default* definitions
14:08:38 <byorgey> theadmin: when defining an instance of Num you can implement whichever one you want, and the other one will use the default implementation in terms of the one you gave
14:08:51 <byorgey> theadmin: but if you don't implement either one and try to use them, you will get an infinite loop.
14:08:56 <identity> theadmin: As I understand it, while most functions in the prelude are simply actual, normal haskell code, there are still elements(like arithmetic and such) of the code that are 'magic'
14:09:14 <mauke> primitives are magic
14:09:38 <theadmin> "magic" as in it falls back to C or assembly or something?
14:10:28 <Veinor> i mean, ghc is written in haskell
14:10:47 <Veinor> so in a sense primitives are written in haskell, it's just at a lower level. so to speak.
14:10:48 <byorgey> but the runtime is written in C.
14:10:49 <mauke> the RTS is in C
14:10:51 <Veinor> oh is it?
14:11:05 <identity> theadmin: Well, an example is the Int type, or the Integer type. Naturally, Int isn't data Int = 1 | 2 | 3 .. | 2^b-1
14:11:11 <illissius-> if you want a complete list of magic you can look at: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
14:11:19 <identity> But mauke, byorgey or one of the other wizards can probably give you better answers than I can.
14:11:33 <mauke> I'm not a wizard
14:11:38 <mauke> @src Int
14:11:39 <lambdabot> data Int = I# Int#
14:12:15 <theadmin> @src Int#
14:12:15 <lambdabot> Source not found. That's something I cannot allow to happen.
14:12:19 <frerich_> Hm, reading the GHC.Prim page, I see "Haskell98 specifies that signed integers (type Int) must contain at least 30 bits." - wonder why it's 30 bits. Two bits for bookkeeping of the garbage collection machinery, or so?
14:12:20 <theadmin> D'oh.
14:12:25 <mauke> frerich_: yes
14:12:28 <Veinor> yeah
14:12:32 <mauke> frerich_: also for potential unboxing
14:12:40 <frerich_> Ah, unboxing, good point.
14:12:47 <mauke> ocaml represents 'int' as 31 bits with the bottom bit set
14:13:33 <identity> theadmin: At any rate, the suggestion before will work: Google the functions, find them, and click Source.
14:14:11 <theadmin> identity: Did that just now for a few functions... Took me a while to find the "source" link though
14:14:38 <pqmodn> byorgey: i enjoyed your "typeclassopedia" monad.reader article. belated "nice work" :]
14:14:49 <frerich_> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#t:RealWorld is almost philosophical: "RealWorld is deeply magical."
14:15:07 <byorgey> pqmodn: thanks!
14:15:32 <mauke> have you seen reflection? it runs purely on black magic
14:15:33 <byorgey> pqmodn: note the canonical version (which has been updated since the Monad.Reader version) is now on the Haskell wiki
14:15:37 <byorgey> @where typeclassopedia
14:15:37 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:15:46 <pqmodn> oh, thanks
14:15:58 <illissius-> frerich_: yeah, and I think that doc is half-intended as a plain source code comment, which is why it mentions ptrArg (which isn't visible anywhere in the haddocks)
14:16:34 <identity> "Someone in the #haskell IRC channel used (***), and when I asked lambdabot to tell me its type, it printed out scary gobbledygook that didn’t even fit on one line! Then someone used fmap fmap fmap and my brain exploded." Hahahaha.
14:16:45 <byorgey> @package acme-realworld
14:16:45 <lambdabot> http://hackage.haskell.org/package/acme-realworld
14:16:49 <byorgey> frerich_: see ^^^  =)
14:17:23 <frerich_> byorgey: Hihi, and it has a launchMissiles pun
14:17:24 <illissius-> that's my favorite package ever
14:17:26 <identity> I can really relate to the whole robot sentiment.
14:17:54 * frerich_ has "It's the end of the world as we know it" in his head now...
14:18:01 <frerich_> Who was that again...
14:18:05 <illissius-> R.E.M.
14:18:07 * hackagebot arithmoi 0.4.0.3 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms. (DanielFischer)
14:18:15 <frerich_> Right!
14:21:30 <nobdraisentone> Is there some data structure like list with fast isElem (a -> Bool) method (0(1) prefered)?
14:21:57 <mauke> Set
14:22:16 <theadmin> Huh, Haskell has an Acme namespace too?
14:22:16 <identity> But it's not O(1)
14:22:20 <theadmin> That's... interesting
14:22:32 <illissius-> theadmin: package authors can choose whatever module names they want
14:22:33 <Rc43> Is there a way to give my haskell programm list of pairs as arguments from command line? E.g. `myProgram [(1,2)]`
14:22:48 <Rc43> It is easy to imlement, but bash can't erad brackets.
14:22:51 <lp_> why would one use control.monad.error instead of control.exception for handling exceptions?
14:22:53 <Rc43> *read
14:23:00 <identity> Rc43: Sure -- as long as the elements are types that are instances of Read, you can use read.
14:23:02 <theadmin> illissius-: Sure, but there *are* general conventions on names to choose, right?
14:23:10 <byorgey> Rc43: just put it in quotes?  myProgram '[(1,2)]'
14:23:13 <illissius-> theadmin: yeah, put everything in "Data" :)
14:23:20 <nobdraisentone> mauke: member is O(log n) in set
14:23:20 <Rc43> identity, I am about brackets and bash parsing
14:23:28 <identity> Rc43: Ah.
14:23:47 <illissius-> theadmin: but I think Acme is an appropriate namespace for satire
14:23:48 <mauke> nobdraisentone: that's approximately O(1)
14:23:54 <Rc43> byorgey, it wotks; thanks
14:23:58 <illissius-> (or whatever category this falls into)
14:24:04 <nobdraisentone> mauke: ?
14:24:09 <Rc43> byorgey, tried with " not with single ' before
14:24:11 <dmwit> nobdraisentone: For all n, log n < 30
14:24:24 <nobdraisentone> N s large
14:24:52 <nobdraisentone> Actually, I would like something like Hash without a value part, only keys
14:25:00 <theadmin> I wonder if we have anything like Perl's Acme::Bleach.
14:25:04 <parcs`> nobdraisentone: Data.HashSet from unordered-containers
14:25:43 <mauke> nobdraisentone: it's still smaller than your address space
14:26:26 <illissius-> nobdraisentone: hmm. (a) does the function need to be pure, or is IO/ST okay? (b) are writing and reading going to be interleaved, or is all the writing going to happen up-front, and after that just reading?
14:26:46 <ptrf> :t (***)
14:26:48 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:27:05 <ptrf> 's not that bad...
14:27:33 <dmwit> It's not bad for you, because your eyes skip half of it by instinct now.
14:27:42 <ptrf> hehe
14:27:42 <nobdraisentone> illissius-: pure prefered, One initial writing (fromList) and than only reading
14:28:03 <ptrf> maybe
14:28:07 * hackagebot factual-api 0.4.0 - A driver for the Factual API (RudigerLippert)
14:28:11 <theadmin> Mother of god, my eyes hurt from that signature.
14:28:13 <theadmin> @hoogle (***)
14:28:14 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:28:19 <theadmin> Oh.
14:28:30 <ptrf> theadmin: again, the forall is implicit
14:28:52 <theadmin> Oh, right.
14:29:04 <theadmin> What's an Arrow, then?
14:29:08 <nobdraisentone> parcs`: http://hackage.haskell.org/packages/archive/unordered-containers/0.2.1.0/doc/html/Data-HashSet.html member O(min(n,W)) , what does W mean there?
14:29:20 <DMcGill_> theadmin: it's like a function with extra stuff
14:29:22 <stepkut> where is the right place to get the Free monad from? for some reason I think the free package has been deprecated?
14:29:23 <mauke> theadmin: (***) :: (Arrow (~>)) => (b ~> c) -> (b' ~> c') -> ((b, b') ~> (c, c'))
14:29:57 <DMcGill_> so if you think of Arrow a => a b c as (b -> c) it's a start
14:30:07 <DMcGill_> I mean that's wrong, but it's wrong in the right direction
14:30:07 <dmwit> stepkut: Eh? It was last updated four days ago.
14:30:13 <dmwit> What makes you think it's deprecated?
14:30:37 <stepkut> dmwit: maybe that is the right version.. I feel like it existed two places and one is wrong.. maybe I am thinking of codensity though
14:30:42 <illissius-> nobdraisentone: ah. in that case I'm not sure whether there's a package that provides exactly what you want/need. mutable hash tables can't be implemented in a pure functional way, but there's no theoretical obstacle to having a pure read-only hash table (which you would construct with IO/ST, or just fromList)
14:30:47 <stepkut> or something completely different
14:30:53 <dmwit> stepkut: It also exists in category-extras, which is certainly deprecated.
14:31:14 <stepkut> ah
14:31:19 <illissius-> nobdraisentone: the most impressive package I know of for hash tables is called hashtables; maybe you could build on top of it, or mention your use case to the author
14:31:33 <dmwit> (But which is still my go-to package when I want to find which of edwardk's 30 packages provides something I want. =)
14:32:18 <theadmin> Ooh, GHCi's got tab completion. That's cool.
14:33:27 <ptrf> try ctrl+a, ctrl+e, ctrl+w, ctrl+k etc
14:33:37 <ptrf> it's got a bunch of readline features as well
14:33:49 <ptrf> if it isnt actually readline
14:34:02 <nobdraisentone> illissius-: problem with hashTables is I dunno what to do with `value' part, because I don't need it actually. So it seems to be non optimal way of using it
14:34:38 <theadmin> ptrf: I wish it had Vim-style line editing instead of those weird emacs (?) shortcuts
14:34:51 <mauke> it's haskeline
14:35:28 <mauke> theadmin: echo 'editMode: Vi' >> ~/.haskeline
14:35:41 <EvanR> do we have arrow tutorials to go with monad burritos and comonad nightclubs
14:36:19 <theadmin> mauke: Oh, nice!
14:36:20 <illissius-> nobdraisentone: type Set a = Hash a () (or even Hash a a with both the key and value being references to the same data) is a fairly common way of using a map (hash) as a set, and sure, it's not 100% optimal, but I'm pretty sure it's just a small constant factor.
14:37:15 <EvanR> illissius-: i figured theres also no way to have array-based tables at all in a purely functional way, mutable or not
14:37:23 <parcs`> nobdraisentone: word size
14:37:33 <parcs`> nobdraisentone: in bits
14:37:42 <illissius-> nobdraisentone: though again, you might mention your use case to the author, the package seems to have comprehensiveness as a goal so it's possible he would be receptive.
14:38:11 <illissius-> EvanR: yeah, I believe so
14:38:11 <nobdraisentone> illissius-: actually, HashSet seems to be ok
14:38:14 <nobdraisentone> parcs`: thanks
14:38:32 <illissius-> wrt my previous comment I should distinguish between pure interface and pure implementation :)
14:39:00 <EvanR> illissius-: then again you could take tuples and immutable arrays to be both features provided by the environment rather than the language
14:39:35 <EvanR> you cant implement tuples or arrays in the language
14:40:07 <EvanR> errrrrrr
14:40:32 <EvanR> data Array19 a = Array19 a a a a a a a a a a a a a a a a a a a
14:40:46 <mauke> aaaaaaaaaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
14:40:54 <illissius-> yeah, that's a bit awkward
14:40:56 <illissius-> hmm
14:41:14 <EvanR> index11 (Array 19 _ _ _ _ _ ... x ... _ _) = x
14:41:17 <EvanR> : )
14:41:24 <EvanR> minus space
14:41:28 <mauke> https://metacpan.org/module/AAAAAAAAA
14:41:49 <EvanR> but then you cant do index arith
14:42:00 <theadmin> Hm... What's wrong with this definition?: http://sprunge.us/hZEA
14:42:07 <EvanR> youd need an index type
14:42:20 <illissius-> type instance Array Z a = (); type instance Array (S n) a = (# a, Array n a #)
14:42:34 <illissius-> or something like that
14:42:40 <illissius-> indexing is a still a problem
14:42:40 <mauke> theadmin: nothing?
14:42:48 <geekosaur> aside from inefficiency
14:42:58 <theadmin> mauke: When I try to "saneShow 5" in GHCi, it fails out with a type error :/
14:43:05 <mauke> theadmin: yes, because 5 is not a String
14:43:22 <EvanR> mauke: lol wtf. you and your crazy perl
14:43:30 <mauke> theadmin: saneShow :: String -> String
14:43:45 <mauke> EvanR: what. that Acme.RealWorld module was much crazier
14:43:47 <dmwit> theadmin: If you want a function that behaves differently at different types, you need a typeclass. There's no getting around that. Sorry.
14:43:57 <EvanR> haha
14:44:30 <illissius-> there was talk of having an unsafeAccess# function or something (not sure what the name was) in GHC.Prim of type a -> Int -> Any
14:44:32 <dmwit> mauke: Apparently, that page is in Croatian.
14:44:39 * dmwit hits the "yes, translate it" button
14:44:45 <illissius-> which would get the Nth field of a tuple or other product type
14:45:02 <illissius-> and obviously be very unsafe to use directly
14:45:09 <illissius-> I think it would be nice
14:47:34 <theadmin> D'oh... Okay, I'm trying to figure this out.
14:57:24 <theadmin> And I got it, for anyone interested: http://sprunge.us/GENF
14:57:54 <mauke> theadmin: that should be called insaneShow
14:59:13 <dmwit> mauke: Could be worse. He could have used "read" instead of "tail . init".
14:59:46 <mauke> or cast
14:59:54 <theadmin> cast? What's that do?
14:59:59 <mauke> :t cast
15:00:01 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
15:00:05 <mauke> it's concentrated evil
15:00:40 <illissius-> what does that make unsafeCoerce?
15:00:42 <mauke> @let insaneShow x = fromMaybe (show x) (cast x)
15:00:45 <lambdabot>  Defined.
15:00:47 <navaati> yeah, that's anything but sane, here is a better version :
15:00:48 <hpaste> navaati pasted “Maybe saner show” at http://hpaste.org/71166
15:00:56 <mauke> > insaneShow ()
15:01:00 <lambdabot>   "()"
15:01:05 <mauke> > insaneShow "hi"
15:01:08 <lambdabot>   "hi"
15:01:39 <EvanR> > show ()
15:01:41 <lambdabot>   "()"
15:01:45 <navaati> err, i'm wrong
15:01:50 <EvanR> > show "hi"
15:01:52 <lambdabot>   "\"hi\""
15:01:59 <EvanR> oh did you ask about this last week?
15:01:59 <shapr> Bah, I can setImports in hint, but I can't get back the list of modules in scope!
15:02:44 <navaati> well, what's evil with cast in this particular case ?
15:02:46 <theadmin> Well, I suppose a better name is showButIfAIsStringDoNotEscapeQuotes... But that's way long.
15:02:46 <dmwit> illissius-: angelic > good > bad > evil > unsafe
15:03:09 <mauke> theadmin: you shouldn't want that operation
15:03:18 <dmwit> mauke++
15:03:28 <twanvl> ... > reallyUnsafe
15:03:42 <DrSyzygy> ... >reallyUnsafeNoWeMeanIt
15:03:53 <dmwit> Is there like an "actuallyWrong" prefix?
15:04:09 <twanvl> though reallyUnsafePtrEquality is safer than unsafeCoerce
15:04:12 <illissius-> twanvl: fwiw I think reallyUnsafePtrEquality# is less unsafe than than unsafeCoerce# :) (and unsafePerformIO)
15:04:16 <illissius-> jynx
15:04:28 <shachaf> mauke: What do you think of the use in http://hackage.haskell.org/packages/archive/shqq/0.1/doc/html/System-ShQQ.html ?
15:05:04 <theadmin> mauke: The thing is I don't... I have no idea why I wanted to write it to be honest %)
15:07:29 <mauke> shachaf: why is it needed there?
15:08:18 <dmwit> mauke: It seems to define showNonString just the way you did.
15:08:27 <shachaf> I think it makes it more convenient to embed both strings and non-String Show values?
15:08:53 <mauke> according to the docs it's only supposed to work with Strings
15:08:55 <Peaker_> does reallyUnsafePtrEquality have any invariant? When is it safe?  Maybe at least it has no false positives?
15:08:55 <dmwit> Oh, I answered only the least interesting part of that question. Sorry.
15:08:57 <BluePeppers> What extra requirements are there for types in FFI that are returned, but not as pointers? I.e. Foo -> IO () instead of Ptr Foo -> IO(). I have a type defined, and FFI is fine with passing it around as Ptr Foo, but not as Foo. I just get a load of "Unacceptable (argument|return) type in foreign declaration: Foo"
15:09:06 <shachaf> mauke: Where do the docs say that?
15:09:12 <illissius-> Peaker_: I believe that's the case
15:09:14 <shachaf> >>> let x = Just (2 + 2) in [sh| touch $x; ls -l J* |]
15:09:14 <shachaf> "-rw-r--r-- 1 keegan keegan 0 Oct  7 23:28 Just 4\n"
15:09:19 <illissius-> false negatives, but not false positives
15:09:20 <shachaf> Variables of type other than String are interpolated via show.
15:09:28 <mauke> shachaf: oh, misread
15:09:47 <mauke> or rather, I missed the last paragraph
15:09:47 <Eduard_Munteanu> shachaf: did you hax kmc? :)
15:09:49 <dmwit> BluePeppers: There's a very small list of acceptable (argument|return) types listed in the FFI spec.
15:10:07 <shachaf> Eduard_Munteanu: All the way to Vermont.
15:11:14 <dmwit> BluePeppers: 8.4.2, http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1540008.4
15:11:17 <BluePeppers> dmwit, is there any typeclass I can implement to add my type to it? It's a really simple C struct, but I browsed the FFI spec earlier today, but couldn't see anything relevant.
15:11:48 <dmwit> BluePeppers: No, but you can use the various tools like c2hs and friends to make it a tad less painful.
15:11:53 <illissius-> BluePeppers: AFAIK you can only pass structs by pointer in the FFI
15:12:12 <mauke> BluePeppers: write a wrapper function in C
15:12:18 <BluePeppers> dmwit, I'm using hsc2hs which is fun, but thanks :)
15:12:57 <dmwit> BluePeppers: Yes, hsc2hs can do it via #peek, #poke, and #ptr.
15:13:04 <mauke> dmwit: ?
15:13:09 * hackagebot ssh 0.2.10 - A pure-Haskell SSH server library. (GuillaumeHoffmann)
15:13:16 <BluePeppers> mauke, a wrapper to make everything a pointer? I guess :/
15:13:18 <dmwit> where "it" means "access fields of a struct pointer"
15:13:23 <mauke> BluePeppers: yes
15:13:37 <BluePeppers> dmwit, yes, i've implemented Storable on the type already
15:13:39 <shachaf> dmwit: That's not the same as "pass a struct by value", though. :-)
15:13:46 <dmwit> I am aware.
15:13:48 <mauke> BluePeppers: the haskell ffi can't deal with varargs or struct args
15:13:56 <dmwit> None of the things I said implied that you can pass a struct by value.
15:14:06 <shachaf> Ah, that's not what you meant by "it".
15:14:15 <BluePeppers> mauke, a shame. I guess i'll take your advice. Thanks :)
15:38:11 * hackagebot highlighter 0.2.1 - source code highlighting (GuillaumeHoffmann)
15:42:50 <Peaker_> #python grew to ~1050, #haskell remains around ~900.. we used to be slightly bigger
15:42:57 <Peaker_> maybe depends on timezones, though
15:45:30 <theadmin> I guess it's thanks to people migrating to Python 3 where they actually started to fix stuff?
15:45:52 <HugoDan> hmm
15:46:01 <HugoDan> but haskell is still better than python :)
15:46:26 <theadmin> True, but not many people are into functional programming nowadays. At least not as many as those into imperative.
15:46:29 <peddie> theadmin: if you remove lambda from the language, is Python 3 'fixed' in the same sense a cat is 'fixed'?
15:46:48 <theadmin> peddie: ...How can you fix a cat?
15:47:02 <tgeeky> neuter or spay?
15:47:05 <hpc> theadmin: snippy snippy
15:47:05 <peddie> theadmin: it refers to neutering or spaying the cat
15:47:34 <theadmin> Well I'm not saying Python is good. Still a horrible language in my opinion.
15:48:01 <HugoDan> i always cry when i have to write python code
15:48:09 <Peaker> http://i.imgur.com/41iAb.png --  can anyone suggest a way to make things cleaner -- while still retaining the sub-expression type information?
15:48:11 <tgeeky> you guys have it good
15:48:41 <tgeeky> Peaker: s/Integer/Z/
15:49:00 <Peaker> tgeeky, I'm asking in general though -- not just for this expression in particular
15:49:00 <theadmin> What's a GLFW?
15:49:25 <Peaker> theadmin, simple cross-platform library to open windows, get events, and get OpenGL drawing context
15:50:14 <Peaker> Note how the x * fac (x - 1)  becomes elevated due to the inferred types
15:50:17 <tgeeky> Peaker: mgsloan is working on something that seems (at least superficially) similar: panopti (on github)
15:51:11 <tgeeky> Peaker: here's a SS: http://www.mgsloan.com/panopti.png
15:51:32 <tgeeky> Peaker: http://www.mgsloan.com/panopti2.png
15:51:48 <Peaker> tgeeky, it seems focused on type-visualization
15:51:56 <tgeeky> Peaker: I'm not sure if this will help (in fact, I am pretty sure it won't)
15:51:59 <Peaker> (and seems cool though I don't understand it fully)
15:52:02 <tgeeky> but it's at least a haskell visualization
15:52:06 <theadmin> I wonder... To someone who doesn't know a programming language at all, would Haskell be easy to learn? What's your opinion?
15:52:13 <tgeeky> theadmin: no
15:52:31 <Peaker> we just want a practical structural editor
15:52:45 <Peaker> we might have to give up on the extra type info for sane alignments, though it'd  be a shame
15:53:01 <mm_freak> theadmin, tgeeky: yes
15:53:12 <Peaker> theadmin, dibblego (Tony Morris) claims he taught Haskell to beginners and it was easier than teaching imperative languages
15:53:32 <tgeeky> learning any programming language is hard, and Haskell isn't the easiest to learn
15:53:34 <mm_freak> i taught haskell to a few groups of people and those with no prior programming experience had a very easy time learning haskell
15:53:36 <Peaker> (but non-beginners pose extra difficulties)
15:54:02 <theadmin> I'm kind of inclined to think the answer is "yes" myself. First off, imperative knowledge leads you in the wrong direction, trying to say "this is like that" is wrong. Secondly, Haskell has less "extra" stuff like loops etc, and the stuff it has is straight to the point.
15:54:06 <otters> do beginner tutorials include do-notation with IO
15:55:08 <theadmin> otters: They probably don't (not at an early point anyway), because IO is impure and Haskell is all about purity. Besides, IO is a rather high level (if you start from the very beginning) anyway
15:55:16 <otters> yeah
15:55:16 <mm_freak> in fact non-programmers starting with haskell immediately got the right feeling about things like laziness and IO
15:55:38 <otters> but if I was learning a new language I'd want to learn something like "Get a string from stdin, reverse it, print it out"
15:55:52 <mm_freak> they used laziness like it's a totally natural thing to have in a language
15:56:27 <mauke> it's almost like referential transparency
15:56:34 <mm_freak> my reasoning is:  unlike languages like C haskell is a very natural language
15:58:29 <theadmin> otters: Well, something like that is simple enough actually, and can be done in a nice-looking manner: main = interact reverse
15:58:43 <theadmin> So yeah, no do-notation really needed at first steps
15:59:25 <otters> okay
15:59:54 <theadmin> Then again, the do-notation seems pretty obvious -- do this, then do that. Then again, it also seems pretty imperative.
16:01:07 <Peaker> it is imperative, at least in IO
16:01:57 <theadmin> Well I don't really see how you can do IO in a non-imperative manner. IO implies sequencing.
16:02:20 <Peaker> mm_freak, Haskell is very natural from a perspective of describing computation
16:02:32 <Peaker> mm_freak, C is very natural from the perspective of ordering hardware around
16:02:58 <mm_freak> Peaker: i think even there haskell is more natural
16:03:30 <Peaker> mm_freak, it's harder to map Haskell to the hardware instructions, the mapping is thicker and harder to understand
16:03:57 <mm_freak> i found that people had a hard time writing an infinite loop in C, but they almost always got to 'main = putStrLn "hello!" >> main' very fast
16:04:18 <Peaker> mm_freak, while(1) was hard?
16:04:23 <Peaker> or for(;;) ?
16:04:24 <mm_freak> yes
16:04:38 <otters> o_o
16:04:38 <pv2b> main() { puts("hello!"); main(); }
16:04:52 <mm_freak> harder than the haskell variant at least…  the haskell variant appears very natural
16:05:13 <theadmin> Except the >> part, I always think "very much greater than" when I see that function.
16:05:16 <mauke> beginners in C/Pascal like to abuse recursion as loops
16:05:22 <theadmin> Or "redirect to file" :/
16:05:27 <mauke> and sometimes they're confused when the functions they called actually return
16:05:31 <theadmin> Rather, "append to file", whatever
16:05:42 <unnali> pv2b: it's harder because calling "main();" is not valid C (afaicr)
16:05:45 <mauke> (because they think of it as goto)
16:05:51 <mauke> unnali: it's valid C
16:05:53 <mauke> just not C++
16:06:03 <unnali> i stand corrected :)
16:06:12 <ion> Why does C++ make it invalid?
16:06:18 <mauke> ion: because main isn't a function in C++
16:06:26 <pv2b> it'll compile. whether it's legal or not and in what variant of C I can't say.
16:06:30 <ion> Oh, just like in Haskell.
16:06:31 <mauke> for retarded reasons
16:06:34 <mm_freak> mauke: huh?
16:06:35 <d-snp> I get no google results for haskell descending range, how do you make a descending range in haskell?
16:06:35 <theadmin> mauke: It isn't? What the hell is it then?
16:06:45 <mauke> theadmin: an unspecified special something
16:06:47 <mm_freak> well, "main()" is wrong anyway
16:06:49 <theadmin> d-snp: [10,9..0]
16:06:52 <d-snp> ohhh
16:06:53 <mm_freak> it's "return main();"
16:06:53 <d-snp> thanks :D
16:06:58 <mauke> mm_freak: no
16:07:01 <unnali> mm_freak: nopu
16:07:15 <pv2b> mm_freak: you can fall off the end of a function in C. it'll throw up a warning, but it's legal.
16:07:26 <mauke> we're not falling off the end of a function
16:07:30 <mauke> main never returns
16:07:30 <unnali> http://stackoverflow.com/questions/2128321/can-main-function-call-itself-in-c "The function main shall not be used within a program."
16:07:39 <pv2b> mauke: right, but the compiler doesn't know that.
16:08:02 <mauke> pv2b: why not?
16:08:30 <pv2b> well, it does. i guess. in this particular case if it's smart enough to do tail call optimization or something
16:08:32 <mm_freak> mauke: from a pure language standpoint writing "main();" at the end of 'main' is a type error
16:08:41 <mm_freak> at least if you subscribe to "int main"
16:08:43 <mauke> mm_freak: no, it isn't
16:08:56 <theadmin> d-snp: You can make alternations to the syntax, it's quite neat, for example: [10,10.5..20]
16:10:01 <mm_freak> mauke: how come?  is it specified that way?
16:10:18 <mauke> mm_freak: well, how do you define "pure language"?
16:10:41 <ion> pure (language standpoint)
16:10:42 <mauke> "C as specified by the standard" or "a pure language"?
16:11:23 <pv2b> first of all - in the particular example I wrote, it'll default to a function returning to an int since the return type is not specified. in the more general case, a function like f(){} in C is perfectly legal, and I guess you can even call it as int x=f(); - but the return value - and by extension the contents of x will not be defined.
16:11:48 <pv2b> which is why it's legal to call main() and not have a return
16:12:05 <pv2b> and nothing in C says you can't call your main()
16:12:09 <mm_freak> mauke: as specified
16:12:15 <mauke> implicit int hasn't been legal since 1999
16:12:33 <mm_freak> ok, this code:  int main() { main(); }
16:12:40 <mm_freak> is that one legal?  i'd say no
16:12:48 <pv2b> mauke: who says i was writing my example in C99? :P
16:12:52 <mauke> mm_freak: in that case the C standard says falling off the end of a function is fine as long as no one inspects the result
16:12:58 <mauke> pv2b: you said "in C"
16:13:15 <mauke> the C standard also says that its definition of "C" is the only one
16:13:44 <pv2b> then i'll make my own C standard that says my program is perfectly legal. and thou shalt have no other C's before me.
16:13:46 <mauke> mm_freak: so that's not a type error per se. and in this particular case we're not even falling off the end
16:14:54 <theadmin> Why did we switch to C all of a sudden? %)
16:14:58 <pv2b> i dunno
16:15:06 <unnali> theadmin: "C is the world's finest pure functional programming language"
16:15:16 <theadmin> unnali: le wut.
16:15:17 <pv2b> i made a stupid example using c purposely in a way to mimic the syntax in an example haskell program
16:15:25 <pv2b> and it turned into a language lawyer discussion. who knew? :)
16:15:58 <theadmin> Hm, do runghc and runhaskell use GHCi internally?
16:16:22 <theadmin> (I know the two are the same thing, mind you)
16:16:43 <sipa> they use ghc, iirc
16:17:43 <geekosaur> they're all (including ghci) different operating modes of ghc
16:17:53 <theadmin> Ah.
16:18:21 <theadmin> Hm... I wonder what part gives the <<loop>>, that's pretty clever. Especially for debugging.
16:18:42 <geekosaur> there's also ghc -e to evaluate a single expression
16:19:40 <DMcGill_> theadmin: find an explaination of laziness and thunks to see how <<loop>> works
16:20:12 <theadmin> DMcGill_: I do know what those 2 are (well, I understand the concepts), do you mean an explanation of their implementation in Haskell or something?
16:20:28 <unnali> wow, I just found the -B RTS option.
16:20:32 <unnali> that's fun.
16:20:42 <donri> so distributed-process is the new "remote"?
16:20:55 <mauke> theadmin: a thunk is represented by a function pointer
16:21:24 <mauke> to force the thunk, the function pointer is called. after that the function pointer is overwritten with the actual result
16:21:47 <theadmin> "force the thunk" sounds kind of funny
16:21:51 <theadmin> But I do get your point
16:21:56 <mauke> what you probably didn't know: before the function pointer is called, it's overwritten by something else
16:22:20 <theadmin> Huh. If you overwrite it with something, then how can you call it?
16:22:24 <mauke> that is, during evaluation of a thunk, the function pointer is set to a function that raises a <<loop>> exception
16:22:38 <geekosaur> save the original value, set it to point to "<<loop>>" exception, run the saved value
16:22:47 <mauke> tmp = thunk.fn_ptr; thunk.fn_ptr = raise_loop_exc; tmp();
16:22:52 <geekosaur> if the saved value tries to call back into itself" it falls into the exception instead
16:22:56 <theadmin> Oh, <<loop>> is an exception?
16:22:59 <mauke> yes
16:23:13 * hackagebot highlighter 0.2.2 - source code highlighting (AlexSuraci)
16:25:06 <mm_freak> <<loop>> is a feature of the STG machine…  it's inherently bound to the exact way haskell programs are compiled
16:25:26 <mm_freak> in fact it's almost trivial to implement for STG machines
16:25:56 <c_wraith> I'm amused that GHC has regrown a spine and tags.
16:26:14 <d-snp> making an ordered list of products is pretty hard :S
16:26:20 <unlink> Is there a better way of saying this?    ((== GT) .) . comparing snd
16:26:23 <sipa> so it's a G machine now?
16:26:30 <mm_freak> sipa: nope
16:26:47 <unlink> basically I want  "maxBy snd"
16:26:57 <mm_freak> despite being called a "spineless tagless G-machine" it's very different from the actual G-machine
16:26:59 <sipa> @unpl ((== GT) .) . comparing snd
16:26:59 <lambdabot> (\ e h -> (comparing snd e h) == (GT))
16:27:38 <shachaf> @ty ((== GT) .) . comparing snd
16:27:39 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Bool
16:27:45 <shachaf> @ty (>) `on` snd
16:27:46 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Bool
16:27:53 <unlink> a winner is you
16:27:57 <unlink> thanks.
16:28:10 <mm_freak> unlink: i'd write the points there
16:28:22 <shachaf> mm_freak: (>) `on` snd isn't that bad.
16:28:26 <shachaf> When you're used to `on`, at least.
16:28:43 <mm_freak> well, true
16:28:48 <unlink> (>) `on` snd is definitely the way to go here
16:28:52 <mm_freak> but it required looking twice
16:28:59 <mm_freak> for me at least
16:29:18 <shachaf> (\(_,x) (_,y) -> x > y) doesn't?
16:29:38 <mm_freak> yeah…  not saying it's bad, but as a first reflex i'd probably have written the points =)
16:29:40 <shachaf> Hmm, that's not *quite* the same function, either.
16:29:59 <shachaf> (\~(_,x) ~(_,y) -> x > y)
16:30:04 <mm_freak> with refutable patterns
16:30:05 <mm_freak> yeah
16:30:13 <mauke> shachaf: syntax error
16:30:16 <mauke> needs more space
16:30:20 <shachaf> :-(
16:30:26 <mm_freak> is it?
16:30:29 <unlink> oh. no. this isn't what I wanted. I wanted something of type   Ord a => (t, a) -> (t, a) -> (t, a)
16:30:31 <shachaf> (\ ~ ( _ , x )  ~ ( _ , y ) -> x  >  y)
16:30:33 <mm_freak> :t \~x -> x
16:30:36 <lambdabot> parse error on input `\~'
16:30:38 <mm_freak> indeed
16:30:45 <mm_freak> shachaf: too much space
16:30:47 <shachaf> > let (\~) = 5 in (\~)
16:30:49 <lambdabot>   5
16:30:51 <mauke> :t \ ~(_,x)~(_,y)->x>y
16:30:53 <lambdabot> forall t t1 t2. (Ord t1) => (t, t1) -> (t2, t1) -> Bool
16:31:12 <shachaf> unlink: max `on` snd?
16:31:21 <shachaf> Hmm, no.
16:31:28 <mauke> maxBy (comparing snd)
16:31:30 <unlink> maxBy snd, if it existed.
16:31:33 <mm_freak> master of unisaster
16:31:34 <shachaf> Yes, what mauke said.
16:31:39 <unlink> er, maxWith.
16:31:47 <mauke> :t maxBy
16:31:49 <lambdabot> Not in scope: `maxBy'
16:31:52 <mauke> aww
16:32:03 <shachaf> Indeed.
16:32:42 <unlink> M.fromListWith (\x y -> case ((>) `on` snd) x y of GT -> x ; _ -> y)
16:33:26 <mauke> I'd like to see how you get (>) to return GT
16:33:27 <shachaf> You might write a separate function for it
16:33:38 <pqmodn> @src on
16:33:38 <lambdabot> (*) `on` f = \x y -> f x * f y
16:33:43 <geekosaur> heh
16:33:51 <unlink> mauke: yeah, the thing like that that I actually meant :-$
16:34:05 <unlink> dammit Haskell you have failed me!!
16:34:09 <pqmodn> @where on
16:34:10 <lambdabot> I know nothing about on.
16:34:15 <mauke> @index on
16:34:16 <lambdabot> bzzt
16:34:18 <DMcGill_> Data.Function
16:34:19 <shachaf> @hoogle on
16:34:19 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:34:19 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
16:34:19 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
16:34:26 <pqmodn> thanks
16:34:29 <mauke> well, that would've been the right command if @index was maintained
16:35:07 <shachaf> Who needs @index when we have @hoogle?
16:35:31 <shachaf> The annoying thing about @hoogle is that it spams.
16:35:53 <d-snp> hey, can someone give me a small hint as to why my products of 3 digits function isn't ordered right? https://github.com/d-snp/euler/blob/master/4.hs
16:36:07 <shachaf> Project Euler questions :-(
16:36:27 <mauke> my id-4.hs is 2 lines
16:37:09 <mauke> > let palin s = s == reverse s in maximum $ filter (palin . show) [a * b | a <- [999, 998 .. 100], b <- [a, a - 1 .. 100]]
16:37:12 <d-snp> mauke: bigger is better right :P
16:37:12 <lambdabot>   906609
16:37:29 <DMcGill_> lol, what happened to "small hint"?
16:37:36 <d-snp> :P
16:37:43 <mauke> that would require understanding the original program
16:38:31 <d-snp> why.. is your list comprehension ordered right?
16:38:32 <d-snp> oh
16:38:36 <d-snp> you do a maximum?
16:38:39 <d-snp> thats lame..
16:38:45 <shachaf> > maximum [(a * b,a,b) | a <- [100..999], b <- [100..999], let s = show (a * b), s == reverse s]
16:38:45 <mauke> yes, it wanted the largest palindrome
16:38:48 <lambdabot>   (906609,993,913)
16:39:04 <mauke> d-snp: all of my euler solutions use brute force
16:39:15 <d-snp> yes, none of mine do ;)
16:39:47 <blackdog> d-snp: time spent optimising a program beyond requirements is wasted time
16:40:07 <blackdog> what's worse is that it's extremely appealing. it's geek crack.
16:40:08 <d-snp> blackdog: there are no requirements to begin with, it's just a game
16:40:34 <blackdog> d-snp: oh, i know. i've done about a hundred euler problems, i think
16:40:45 <blackdog> but you do 'em the dumbest way possible first :)
16:40:52 <d-snp> anyway, I didn't ask for the answer to the euler program, I was wondering how to build an ordered list of pairs :)
16:41:44 <pqmodn> perhaps build a list of pairs and then use Data.List.sortBy?
16:41:52 <d-snp> yes.. without a sort :D
16:42:16 <mauke> ordered how?
16:42:42 <d-snp> well in this case, in descending order
16:42:53 <mauke> descending order of what?
16:43:04 <d-snp> of the product of their members, sorry :(
16:43:28 <shachaf> Oh. Just do a diagonalization thing.
16:44:06 <blackdog> shachaf: what do you mean?
16:44:51 <shachaf> @google rationals diagonalization
16:44:52 <lambdabot> http://www.homeschoolmath.net/teaching/rational-numbers-countable.php
16:44:52 <lambdabot> Title: Proof that rational numbers are countable - from Homeschool Math
16:44:56 <shachaf> Something like that.
16:46:35 <monochrom> oh, I know!
16:47:53 <mdmkolbe> What category of parser is uulib? LL(1)?
16:50:53 <monochrom> http://www.cs.ox.ac.uk/publications/publication1664-abstract.html  Jeremy Gibbons's "enumerating the rationals"
16:51:30 <shachaf> Enumerationalating.
16:51:57 <shachaf> monochrom: Anyay, the duplicates issue isn't relevant here.
16:52:05 <ion> Enumerationalatizing.
16:52:07 <shachaf> Well, there's a different duplicates issue, but that one's easier to solve.
16:52:22 <ion> Enumerationalatizationing.
16:52:24 <monochrom> I understand. but Gibbons's functional pearl is so slick :)
16:53:45 <shachaf> That's a pretty nifty tree.
16:53:56 <shachaf> Oh, there are lots of trees.
17:13:05 <mm_freak> @djinn (a -> b -> b) -> b -> [a] -> b
17:13:05 <lambdabot> Error: Undefined type []
17:13:31 <mm_freak> @djinn (a -> b -> b) -> b -> ((a -> b -> b) -> b -> b) -> b
17:13:32 <lambdabot> f a b c = c a b
17:13:43 <shachaf> \_ x _ -> x
17:13:59 <hpc> djinn tries to use arguments
17:14:15 * mm_freak is impressed, although it's quite obvious
17:14:17 <shachaf> @djinn (a -> b) -> b -> Maybe a -> b
17:14:17 <lambdabot> f a b c =
17:14:18 <lambdabot>     case c of
17:14:18 <lambdabot>     Nothing -> b
17:14:18 <lambdabot>     Just d -> a d
17:14:37 <shachaf> @@ @djinn @type maybe
17:14:38 <lambdabot>  f a b c =
17:14:38 <lambdabot>     case c of
17:14:38 <lambdabot>     Nothing -> a
17:14:40 <lambdabot>     Just d -> b d
17:16:20 <hpc> @src maybe
17:16:21 <lambdabot> maybe n _ Nothing  = n
17:16:21 <lambdabot> maybe _ f (Just x) = f x
17:17:21 <shachaf> It's sad how much less readable a program becomes when you turn f g x xs y ys n m i j etc. into a b c d e f g h i
17:18:02 <hpc> it's funny how naming conventions become information
17:20:24 <Peaker> it's horrible how the general nature of Haskell gave people a good reason to use one-letter variable name, only to be copied everywhere even when there's no generality
17:21:00 <shachaf> Peaker: To be fair, what I said is true even in the case of general functions.
17:21:29 <Peaker> shachaf, yeah, the conventions help a lot
17:21:45 <shachaf> In a way that's worrying.
17:21:59 <Peaker> I dislike stuff like the new lens libs which have: data Lens a b c d    instead of:   data Lens outerrec outerfield innerrec innerfield
17:22:00 <shachaf> I'd like something that ensures that code will be readable. :-)
17:22:13 <shachaf> But I'll settle for "helping code be correct" for now.
17:22:22 <hpc> Peaker: i would have gone for data Lens or of ir if
17:22:55 <Peaker> hpc, ok too if you learn the conventions once
17:23:04 <blackdog> hpc: you might have a bit of trouble with 'if' :)
17:23:09 <Peaker> hpc, but "a b c d" is useless and I'll re-look it up every single time
17:23:14 <hpc> blackdog: oh crap :P
17:23:26 <hpc> Peaker: yeah, at least SOME convention
17:23:48 <blackdog> hpc: just another reason to exclude unnecessary syntax like 'if' anyway :)
17:24:06 <hpc> that's what agda does
17:24:10 <hpc> it works well enough
17:24:28 <Lemon> @pl \a c -> do {b <- return 'a'; f a b c}
17:24:28 <lambdabot> (line 1, column 12):
17:24:29 <lambdabot> unexpected "{"
17:24:29 <lambdabot> expecting variable, "(", operator or end of input
17:24:54 <Lemon> @pl \a c -> do {return 'a' >>= \b -> f a b c}
17:24:55 <lambdabot> (line 1, column 12):
17:24:55 <lambdabot> unexpected "{"
17:24:55 <lambdabot> expecting variable, "(", operator or end of input
17:25:00 <Lemon> @pl \a c -> return 'a' >>= \b -> f a b c
17:25:00 <lambdabot> (($ 'a') .) . flip . f
17:25:04 <Lemon> oh okay
17:25:26 <Lemon> this is probably not worth it
17:28:20 <sinelaw> Peaker, hey
17:28:36 <Peaker> sinelaw, hey!
17:28:47 <sinelaw> the planets are aligned :)
17:28:59 <Peaker> sinelaw, today we made a step towards solving the layout problem -- making stuff more aligned
17:29:07 <Peaker> sinelaw, http://i.imgur.com/41iAb.png
17:29:14 <Peaker> sinelaw, still not pleased with it though
17:30:08 <Peaker> current ideas: A) avoid all the subexpr types unless explicitly requested   B) shrink the size of stuff so their tops are still aligned
17:30:20 <Peaker> sinelaw, but I'd love ideas if you have one s:)
17:30:33 <Peaker> sinelaw, (note how the (x - 1) is higher by far)
17:30:48 <sinelaw> Peaker, that's not very aligned
17:30:56 <hpc> Peaker: align the values and drop types below
17:31:02 <sinelaw> :)
17:31:04 * hpc will shop an example
17:31:11 <sinelaw> Peaker, hpc is right
17:31:34 <Peaker> hpc, that would mean that the "int"  after "if" is very far from "Set"
17:32:02 <hpc> Peaker: it's cool
17:32:15 <hpc> the white rules are there to guide you to what level you are at anyway
17:32:19 <Peaker> yeah it's probably still better
17:32:21 <sinelaw> hmm
17:32:31 <Peaker> somewhat harder to implement :)
17:33:00 <sinelaw> especially once you've already built it this way
17:33:21 <Peaker> heh
17:34:19 <sinelaw> Peaker, looks cool regardless :)
17:34:25 <Peaker> sinelaw, cool :)
17:34:57 <Peaker> we have an hbox of all the subexpressions, each has an "alignment point" at the bottom white line height, and those are set to be the same height in the hbox
17:35:18 <theadmin> This isn't exactly the right place to ask, but are there localized versions of RWH or LYAH around?
17:35:59 <hpc> theadmin: ask BONUS
17:36:08 <hpc> preflex: seen BONUS
17:36:08 <preflex>  BONUS was last seen on #haskell 1 year, 71 days, 5 hours, 8 minutes and 9 seconds ago, saying: yeah i think that's better as well
17:36:09 <theadmin> hpc: What's a BONUS?
17:36:14 <hpc> the author
17:36:22 <hpc> http://learnyouahaskell.com/ -- his email is here
17:36:51 <sinelaw> what happened to him/her
17:36:53 <theadmin> Oh... Well, I'm more interested in RWH -- it helps you get your hands on more practical things AND to learn the basics...
17:36:54 <sinelaw> 1 year!
17:37:16 <Peaker> ok, not very hard to implement! http://i.imgur.com/ojnTm.png
17:37:52 <hpc> snazzy
17:37:58 <Adeon> are you aiming for the fanciest looking haskell prize
17:38:12 <mauke> what is Int :: Set?
17:38:19 <Peaker> mauke, it's not quite Haskell
17:38:38 <hpc> looks more like agda
17:38:40 <Adeon> oh, it isn't
17:38:42 <Peaker> mauke, some weird cross of Haskell and Agda in the presentation layer.. backend it is a variant of System F
17:38:55 <hpc> in fact, it is valid agda if you can get an Int type
17:39:11 <hpc> oh, and fix the font color
17:39:11 <Peaker> mauke, it's a structural editor, it's pretty easy to rename Set to *
17:39:19 <hpc> pink on purple has awful contrast
17:39:34 <mauke> needs more lens flare
17:39:34 <Adeon> I don't think the colors are the point here
17:39:36 <Adeon> they can be fixed!
17:39:44 <Peaker> hpc, hehe :)
17:39:55 <Peaker> mauke, what do you mean ?:)
17:40:08 <hpc> ooh, and vignette
17:40:15 <hpc> and tilt focus
17:40:49 <irene-knapp> bloom
17:40:51 <hpc> then save it as a quality 20 jpg, "optimized for netscape"
17:40:56 <Adeon> motion blur
17:41:06 <hpc> you'll get to the top of yahoo search results in no time
17:41:08 <irene-knapp> motion blur might actually be kinda cool
17:41:21 <Adeon> screen space ambient occlusion like in all modern fancy dancy 3d games
17:42:10 <Peaker> irene-knapp, the motion is smooth animation it feels like motion blur anyway :)
17:42:19 <irene-knapp> haha fair enough
17:42:26 <sinelaw> Peaker, cool much better
17:42:27 <irene-knapp> anyway, it looks neat
17:42:44 <Peaker> sinelaw, Sep 12-Oct 8 are our dates btw
17:44:06 <theadmin> How do you make those images, Peaker? They look neat.
17:44:24 <Peaker> theadmin, it's screenshots of the structural editor I'm working on
17:45:20 <copumpkin> Peaker: how does it deal with oddly quantified variables
17:45:33 <copumpkin> (looks cool btw)
17:45:52 <Peaker> copumpkin, what do you mean?
17:45:55 <Peaker> copumpkin, and thanks :)
17:45:59 <copumpkin> is that idris?
17:46:15 <copumpkin> Peaker: say you had some higher-rank polymorphism or something
17:46:19 <Peaker> copumpkin, it's bottle
17:46:20 <hpc> custom language
17:46:21 <copumpkin> oh
17:46:29 <hpc> oh
17:46:38 <Peaker> copumpkin, we just have explicit forall lambdas
17:46:47 <copumpkin> hm okay
17:46:50 <Peaker> copumpkin, note "if Int" there
17:46:54 <zzing_> Is there a function that can extract a value out of Maybe, or throw if there is Nothing?
17:46:55 <copumpkin> yeah, saw that
17:47:04 <Peaker> (though we will probably hide these params later)
17:47:05 <copumpkin> zzing_: fromJust, but you shouldn't use it
17:47:15 <copumpkin> @hoogle Just a -> a
17:47:16 <lambdabot> Did you mean: Maybe a -> a
17:47:16 <lambdabot> Prelude id :: a -> a
17:47:16 <lambdabot> Data.Function id :: a -> a
17:47:17 <hpc> zzing_: do you want to be able to catch the error?
17:47:22 <copumpkin> @hoogle Maybe a -> a
17:47:22 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
17:47:22 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
17:47:22 <lambdabot> Data.Monoid First :: Maybe a -> First a
17:47:23 <kopi> http://ontwik.com/haskell/simon-peyton-jones-data-parallel-haskell/
17:47:26 <kopi> good stuff
17:47:28 <zzing_> hpc, no snap will do that for me
17:47:37 <hpc> it might not
17:47:51 <zzing_> :t liftIO
17:47:52 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
17:47:56 <hpc> write your own function to do it
17:48:29 <hpc> the exceptions thrown by "error" are impossibly hard to catch with any predictability
17:49:03 <Peaker> theadmin, http://github.com/Peaker/bottle if you want to try it out
17:49:04 <zzing_> This isn't production ready yet, just throwing around ideas so I can change it later
17:49:40 <zzing_> I really hate byte strings
17:49:55 <hpc> if you're in a do-block, you can use
17:50:02 <hpc> (Just x) <- thingReturningMaybe
17:50:09 <zzing_> I happen to be
17:50:09 <hpc> thingReturningMaybe :: m (Maybe a)
17:50:20 <hpc> Nothing will call fail
17:50:29 <Peaker> something will!
17:50:35 <hpc> that too!
17:50:59 <Peaker> I hate pattern matching with "<-"
17:51:12 <Peaker> (except in list/maybe monad when I intend on fail to be used)
17:51:12 <sinelaw> why
17:51:18 <hpc> Peaker: it's a godsend in those
17:51:21 <hpc> and when parsing
17:51:30 <Peaker> sinelaw, because if I add a second data constructor to the type
17:51:38 <sinelaw> preflex: seen edwardk
17:51:38 <preflex>  edwardk was last seen on #haskell 1 day, 11 hours, 45 minutes and 28 seconds ago, saying: nand`: see dmwit's reads hack
17:51:39 <hpc> or in the gtk user input monad, where you use it to guard on specific inputs
17:51:40 <Peaker> sinelaw, ghc won't warn me that my pattern match is now incomplete
17:51:47 <sinelaw> ah
17:53:06 <Peaker> maybe <- that can call fail should have different syntax, otherwise so when you want safety you could use <-
17:53:14 <Peaker> anyway, night!
17:55:54 <sinelaw> Peaker, night!
18:13:53 <shapr> Pp537: Really irc'ing as root?
18:14:02 <Pp537> nope
18:23:07 <shapr> Pp537: So, do you write lots of Haskell? :-)
18:23:08 <theadmin> Pp537: Arch, huh. That's good. Wish they had sane Haskell packages without having to add extra repos :/
18:23:08 <shapr> theadmin: How's your code going?
18:23:08 <theadmin> shapr: Um, which?
18:23:08 <theadmin> shapr: I believe you're confusing me with someone... "pgrep vim" doesn't return anything ;)
18:23:09 * shapr looks around
18:23:09 <shapr> theadmin: You appear to be the person using the nick "theadmin" on the irc channel #haskell
18:23:09 <shapr> theadmin: Assuming that's correct, have you written any interesting Haskell code lately?
18:23:09 <theadmin> shapr: Yes, I have indeed, but it's mostly silly stuff for the purpose of learning
18:23:09 <shapr> That sounds useful.
18:23:09 <theadmin> The latest was trying to implement "uPrint" %) universal print sort of thing.
18:23:09 <theadmin> Figured out it was pointless too late
18:23:15 <Veinor> i've heard there's been some interesting work done lately about lenses
18:23:35 <Pp537> shapr, no, i just want to learn.
18:23:47 <shapr> Pp537: Oh, how's that going?
18:24:00 <XexonixXexillion> Is there ever a legitimate use of unsafeCoerce?
18:24:02 <Pp537> theadmin, Haskell packages are available in core repo.
18:24:18 <mauke> XexonixXexillion: yes
18:24:25 <theadmin> Pp537: They're in "extra", but the amount of them is so tiny you really should add [haskell]
18:24:48 <Veinor> XexonixXexillion: data.dynamic uses it
18:27:24 <guibou> Hello. I have defined a type ( data RGBColor = RGBColor Double Double Double deriving (Show) ) and another (data XYZColor = XYZColor Double Double Double deriving (show)). For both of them I have defined a class (ColorVector a where add :: a -> a -> a) with (instance ColorVector RGBColor where add (RGBColor r g b) (RGBColor r' g' b') = RGBColor (r + r') (g + g') (b + b') ) and the same for XYZColor
18:27:30 <guibou> How can I factorize this
18:27:48 <guibou> Ie, all my colors follows vector additions, but I want to avoid addition between different colors
18:28:31 <mauke> define a base color vector, newtype RGB and XYZ, derive instances
18:29:09 <theadmin> You know, I still can't get the proper hang of "where" and more importantly "let ... in", I keep declaring stuff at the top level :/ Is that too bad?
18:31:45 <guibou> mauke: data BaseColor = BaseColor Double Double Double; newtype RGBColor = RGBColor BaseColor; Something like that ?
18:32:36 <siracusa> theadmin: If said stuff is only needed in a single function you should declare it there locally
18:32:38 <mauke> yes, except newtype RGBColor = RGBColor BaseColor deriving (ColorVector)
18:33:37 <guibou> mauke: ok, but in this case I'm forced to create a RGBColor like that: mycolor = RGBColor (BaseColor a b c)
18:33:42 <theadmin> siracusa: Yeah, I know that, trying to get the hang of that. And how should I go about deciding whether to use "let ... in" or "where"?
18:33:44 <guibou> which is painful. Did I miss something ?
18:33:59 <mauke> rgbcolor a b c = RGBColor (BaseColor a b c)
18:34:11 <siracusa> theadmin: Matter of taste, IMHO
18:34:16 <theadmin> siracusa: I see :D
18:34:34 <zachk> theadmin: where is better looking, let is easier to reason about at first if you come from other languages with lexical bindings. let is quick and dirty, where is nice
18:35:18 <guibou> mauke: is there a way to freely get an "RGBColor constructor" which takes the three arguments ? It is like I'm repeating myself ;)
18:35:29 <theadmin> zachk: Well, "let" also makes me either indent or use {;} for the *main* (long) code, neither of which are too nice so I'm trying to stick to where
18:35:39 <mauke> guibou: I don't think so
18:35:56 <mauke> you may be able to autodefine the instances with Template Haskell but that's not free either
18:36:07 <mauke> theadmin: no, it doesn't
18:36:45 <theadmin> mauke: Well, yeah, if it's a single line it does not.
18:37:00 <theadmin> mauke: But one-liners aren't pretty most of the time
18:37:02 <mauke> theadmin: even if it's multiple lines
18:37:10 <mauke> stop insisting on being wrong
18:37:22 <theadmin> mauke: Um... You mean omitting the "in"? Or how?
18:37:30 <mauke> wtf
18:37:34 <theadmin> I'm not insisting on anything, I'm trying to figure out how to be right?
18:37:42 <mauke> just don't indent
18:37:44 <mauke> how hard is this
18:37:57 <theadmin> Ok... *tries*
18:39:30 <XexonixXexillion> Can a foreign call be interrupted by the garbage collector?
18:40:07 <Gracenotes> How many people here frequently use Hakyll?
18:40:33 <Gracenotes> I don't actually have a question about it, just thinking about various approaches for blogging.
18:40:37 <serialhex> Gracenotes: i want to start uising hakyll
18:41:22 <Gracenotes> Of course, I would also want comments, but am not sure how comfortable I feel with an external service like Disqus. I wonder if there's something in-between a full-fledged CMS and static-generated site.
18:42:17 <serialhex> Gracenotes: i'm sure one can build something like that....
18:42:19 <Gracenotes> Something that can run serverside but only needs flat files, perhaps with recaptcha, markdown, and some basic spam filtering
18:42:27 <serialhex> that'd be kind of cool
18:42:44 <hpaste> mkramer pasted “where am I running out of memory?” at http://hpaste.org/71170
18:42:53 <Gracenotes> yeah, so a local disqus "server". CGI endpoint, or something like that.
18:43:59 <mkramer> hey guys, I just posted an ~80 line program that runs out of memory.  It might be asking too much, but could someone point me to the source of the memory leak? I'm guessing the matrix multiplication (•)
18:44:13 <mkramer> http://hpaste.org/71170
18:44:24 <Gracenotes> I might try to implement it myself as a project. the two main candidate languages probably are Haskell and Python then... depending on libraries, really
18:44:36 <mauke> ♥ hlint
18:45:22 <theadmin> Hm... I've seen "literal haskell" quite a few times, what's that, what's the difference between "literal" and, uh, "normal" Haskell?
18:45:50 <donri> theadmin: do you mean literate?
18:45:57 <theadmin> Oh, that's the one, sorry
18:46:07 <Gracenotes> I mostly use figurative Haskell
18:46:12 <mauke> theadmin: everything's a commment by default
18:46:21 <serialhex> Gracenotes: +1 haskell!  though hakyll is based on jekyll which uses ruby - and i like ruby too... :)
18:46:28 <donri> literate haskell means everything is a comment unless marked as code
18:46:45 <donri> instead of the normal mode where it's the other way around
18:46:56 <Eduard_Munteanu> theadmin: see "literate programming" for context
18:46:59 <Gracenotes> mkramer: if you're worried about space leaks, you can make things stricter
18:47:02 <Eduard_Munteanu> @google literate programming
18:47:04 <lambdabot> http://en.wikipedia.org/wiki/Literate_programming
18:47:04 <lambdabot> Title: Literate programming - Wikipedia, the free encyclopedia
18:47:21 <XexonixXexillion> mkramer: I think the matrix multiplication needs to be strict, or (••) will run out of memory
18:47:37 <mkramer> how would I strictify it?
18:47:47 <donri> blog posts and such often claim to be written as "literate haskell" which means you should be able to copy the blog post text and save as a .lhs file and simply run/compile it as haskell
18:47:48 <Gracenotes> this includes data structures, and functions which operate on them. Depending on the frequency of creation of the former, and use of the latter
18:50:39 <Gracenotes> mkramer: so accessing the first element of the matrix you return will evaluate the entire thing
18:50:55 <Gracenotes> well, first row, in this case
18:51:11 <zzing_> Has anyone written an operator like ++ for Text? I know of 'append' just want something more elegant
18:51:26 <Gracenotes> To be honest, Array (Int, Int) might not be so bad.
18:51:33 <XexonixXexillion> mkramer: import Data.DeepSeq (($!!)) and change the otherwise in (••) to | otherwise = (•) m $!! m •• (n-1), but there may be another memory leak
18:51:43 <CSWookie> Is it possible to make a list comprehension refer to itself?
18:51:51 <pizzaplane> <> from Data.Monoid works for Text
18:52:02 <zzing_> ok, nice
18:52:07 <Gracenotes> CSWookie: recursive let, or fix
18:52:36 <Gracenotes> assuming you make it so that it doesn't loop without producing anything :)
18:53:17 <CSWookie> Well, we'll see if I can do that. :)
18:53:43 <Gracenotes> list comprehensions are really only useful for cartesian products, anyway (if you want to avoid heavy lifting). I guess I'm just one to prefer explicit use of map/filter
18:54:19 <otters> > let (•) = (.)
18:54:21 <lambdabot>   not an expression: `let (
18:54:29 <otters> > let (•) = (.) in succ • pred $ 3
18:54:32 <lambdabot>   3
18:54:56 <XexonixXexillion> > fix (\rec n -> [ x | x <- [1..n] ++ (rec (n+1))
18:54:57 <lambdabot>   <no location info>: parse error on input `rec'
18:55:18 <XexonixXexillion> > fix (\rec n -> [ x | x <- [1..n] ++ (rec (n+1))])
18:55:19 <lambdabot>   <no location info>: parse error on input `rec'
18:56:32 <Gracenotes> rec is a strange arrows thing, yeah?
18:56:54 <Gracenotes> arrows syntax... so widely used, everywhere... yeah.
18:56:58 <otters> :t rec
18:57:00 <lambdabot> <no location info>: not an expression: `rec'
18:57:01 <XexonixXexillion> ... it shouldn't be here, I'm shadowing it
18:57:15 <Gracenotes> it's a keyword
18:57:33 <XexonixXexillion> > take 20 $ fix (\fixedpoint n -> [ x | x <- [1..n] ++ (fixedpoint (n+1))]) 1
18:57:37 <lambdabot>   [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5]
18:57:47 <aristid> Gracenotes: because lambdabot has -XArrows, or always?
18:57:57 <Gracenotes> oh wait, rec is the mdo thing
18:58:00 <geekosaur> I thought rec is recursive do these days, no?
18:58:01 <geekosaur> that
18:58:14 <aristid> oh:)
18:59:06 <otters> > do { xs <- Just (1:xs); return (map negate xs) }
18:59:07 <lambdabot>   Not in scope: `xs'
19:02:25 <XexonixXexillion> how long has rec been a keyword?
19:02:39 <CSWookie> How do I take the first x values of a list?
19:02:46 <donri> it's only a keyword if DoRec is enabled
19:02:53 <mauke> SAQ
19:02:53 <donri> CSWookie: "take" :)
19:02:54 <XexonixXexillion> CSWookie: take x
19:03:12 <CSWookie> take 50 myList ?
19:03:14 <Gracenotes> donri: hence the not breaking hundreds of modules
19:03:40 <donri> zzing_: I like interpolatedstring-perl6
19:04:08 <zzing_> donri, yet another string type?
19:04:16 <Gracenotes> donri: er... well, lots of people indiscriminately use -fglasgow-exts which includes DoRec. Might be bad. shrug.
19:04:25 <donri> zzing_: it's a quasi-quoter generating IsString code
19:04:30 <mauke> people still use -fglasgow-exts?
19:04:36 <donri> and it uses mappend i think
19:04:46 <Gracenotes> this would be old packages in Hackage then
19:04:49 <deckeraa> CSWookie: correct.
19:05:20 <Gracenotes> there's a warning though for some time though iirc
19:06:07 <zzing_> Is there any way to speed up the compilation/linking of this kind of build: http://hpaste.org/71173   it has a lot of dependencies
19:06:14 <donri> zzing_: it's nice when you need to concat many texts, involving literals and possibly different text types, and if you need to call show on some things
19:07:46 <XexonixXexillion> So does this mean in future I should avoid using rec as a variable name in my own code to avoid any confusion?
19:08:23 <donri> XexonixXexillion: seems a little boring to avoid all keywords stolen by extensions
19:09:44 <Gracenotes> hm. I might try to sign up for Akismet, since there a Haskell API library
19:12:57 <hpaste> WraithM pasted “Nearest Neighbors” at http://hpaste.org/71175
19:13:12 <WraithM> So, I'm being silly and clearly doing this wrong.
19:13:52 <WraithM> The function "evaluate" is the problem.
19:14:33 <mkramer> so, when I tried to force evaluation of matrix multiplication, my program stopped type checking, which is surprising
19:16:17 <WraithM> All I want to do is just change 4 values in my nested list, but it's not happy.
19:16:41 <mkramer> The recommended Data.DeepSeq didn't exist, but I Hoogled for Control.DeepSeq
19:18:21 <hpaste> mkramer pasted “force leads to type check failure” at http://hpaste.org/71176
19:23:18 * hackagebot random-extras 0.19 - Additional functions for random values. (AristidBreitkreuz)
19:24:10 <Gracenotes> actually, for implementing my own comment system, I'm wondering if I should have first-time commenters recaptcha, and then set a MAC-verified cookie so they can avoid future captcha'ing
19:24:51 <Gracenotes> I guess it's funny, I guess I want to be at the star in this scale: CMS |-----------*---+-| Static site
19:24:57 <Gracenotes> Where the plus sign is stuff like Jekyll
19:25:27 <Gracenotes> in the sense of having JS-loaded comments within static documents, but hosting the server myself
19:28:38 <serialhex> Gracenotes: couldn't you have the doc you wrote as your base, and then all the coments for each post go into a separate document (one doc per post, not one doc per comment) and have just *that* part of the page generated...?
19:28:42 <hpaste> CSWookie pasted “Primes” at http://hpaste.org/71178
19:28:52 <CSWookie> That hangs.
19:29:38 <CSWookie> What am I doing wrong?
19:30:21 <Gracenotes> serialhex: I would like some degree of tree commenting I'd think... or at least the ability to support there
19:30:24 <Gracenotes> *that
19:30:28 <Gracenotes> and comment-reporting, etc.
19:30:38 <XexonixXexillion> CSWookie: shouldn't it be <prime, not <=prime ?
19:31:18 <serialhex> hmm... ok, so then a static doc wouldn't work... or wouldn't be easy...  :-/
19:31:31 <serialhex> but i dont think it would be too hard
19:31:37 <Gracenotes> It would still be nice to store the data in flat files
19:31:52 <serialhex> you could store it in a yaml file
19:31:59 <Gracenotes> Even one which just had some separator and.. yes, something like that
19:32:02 <CSWookie> I was thinking that would screw something up with the case where prime is 2...  but I can't remember what.
19:32:10 <Gracenotes> with the author data, text, and tree information stored as an edge
19:32:22 <serialhex> yes indeed!
19:32:47 <Gracenotes> this would be preprocessed by some ajax-called cgi script, potentially with HTML rendering (if it's fast), and sent out
19:33:10 <Gracenotes> yes, that is sort of what I have in mind
19:33:39 <serialhex> yeah, doing a pre-render server side would probably be faster overall.... unless you're getting 100K comments/day or something insane
19:34:11 <serialhex> ...probably less than that actuall :P but any average blog it should be fine
19:34:37 <Gracenotes> at least some kind of cache and an authoritative markup source would be nice
19:35:02 <serialhex> yes indeed!!
19:35:27 <Gracenotes> I like the idea of MAC-verified cookies, though. No one ever does those, they just use session-ids, which require server-side storage
19:36:38 <Gracenotes> then a feature set: making it possible to edit or delete comments? This would have to be cookie-based.
19:37:22 <CSWookie> XexonixXexillion: I have a feeling that's not what's making it hang, though.
19:37:28 <serialhex> yes, or login-based
19:37:30 <Gracenotes> but kind of complicated... and not what you'd expect
19:37:34 <Gracenotes> logins are too much >.>
19:37:41 <Gracenotes> I don't want to be as creepy as disqus
19:37:55 <serialhex> well, you can have login as an optional thing...
19:38:40 <Gracenotes> yeah, of course, but I sort of have a limited scope in my mind. I would like to persist cookies and flat-files with posts. not much else.
19:38:57 <Gracenotes> and instead of flat-files there could be other backends supported... depends on how it's structured
19:39:46 <serialhex> hmm
19:40:42 <serialhex> fyi - i dont know much about databases, but i've been playing with mongodb for a bit, and it's pretty spiffy!  that might work as an optional backend for you
19:42:03 <irene-knapp> you are right to put mongodb in a separate category from databases :)
19:42:28 <irene-knapp> I got to deliver a line that I was inordinately pleased with the other week at work.  "What's your opinion on NoSQL?"
19:42:36 <irene-knapp> "It is an abomination unto my sight and we shall not speak of it further."
19:43:16 <aristid> irene-knapp: answering a question with an implicit overgeneralization with an explicit overgeneralization!
19:43:30 <Gracenotes> yes, key-value in general will work. Especially if you have big values.
19:43:32 <irene-knapp> exactly!
19:43:48 <Gracenotes> also filesystems
19:44:02 <serialhex> well i know *how* DB's work, and how SQL-based DB's work in general, and i like how mongodb does things, it just... flows better IMHO
19:44:03 <irene-knapp> filesystems are indeed better optimized for hierarchical key-value blob storage :)
19:44:10 <irene-knapp> but not transactional, typically
19:44:24 <irene-knapp> you are welcome to your wrong opinions :D
19:44:58 <serialhex> :P
19:45:45 <Gracenotes> NoSQL isn't necessarily transactional
19:45:53 <irene-knapp> yes, true
19:45:56 <Gracenotes> "Yeah, distributed systems are easy, whatever"
19:46:19 <Gracenotes> in any case, O_APPEND has certain guarantees
19:46:32 <irene-knapp> actually the closest book to me right now is _Transactional Information Systems_ (Weikum and Vossen) haha
19:46:36 <Gracenotes> of atomicity
19:46:42 <irene-knapp> but that's a huge reference tome which I've only skimmed
19:46:45 <serialhex> yeah, so is cold fusion... you just get some molecules *REALLY* cold and they'll all stick together to generate body heat... right?
19:47:08 <irene-knapp> actually no, there's an activation energy
19:47:09 <Gracenotes> >_> well, just saying, I could also have a concept of "locking" for manual editing
19:47:11 <irene-knapp> anyway haha
19:47:27 <irene-knapp> anyway, I don't think you really need ACID for a structure editor, if that's still what this is?
19:47:35 <irene-knapp> most filesystems support atomic rename
19:47:43 <irene-knapp> so you can write to a temp file and swap it with the original
19:48:02 <irene-knapp> unless your structures get far bigger than a program ever should
19:48:08 <donri> serialhex: try acid-state
19:48:25 <donri> mongo isn't really acid anyway :p
19:48:58 <Gracenotes> irene-knapp: blog posts will have unique ids, and all comments will go in one file with that id
19:49:01 <Gracenotes> in this setup
19:49:06 <irene-knapp> oh, gotcha
19:49:09 <irene-knapp> CMSy thing then
19:49:23 <Gracenotes> but without being a huge effing CMS.
19:49:33 <irene-knapp> right, makes sense
19:49:39 <irene-knapp> I have similar aspirations but it's a low priority for me atm
19:49:39 <Gracenotes> To be used with Jekyll-type setups
19:49:58 <irene-knapp> not familiar, actually
19:49:59 <Gracenotes> a stand-alone comment server on the same site as a Jekyll "static" site
19:51:43 <irene-knapp> ah, I see, a Ruby cache layer thingy
19:51:45 <irene-knapp> sounds decent
19:52:33 <Gracenotes> well, I wouldn't use Ruby if I can avoid it, and might try out Haskell alternative, Hakyll. But yeah, the only HTML rendering of posts happens upon publishing
19:53:18 <irene-knapp> right, certainly
19:54:26 <serialhex> i've used jakyll & hakyll a bit, and hakyll is *much* more configurable, so no matter tha lang i would suggest hakyll.  and b/c it is more configurable, you can probably use happstack or snap to do all the rest of the fun server-side stuff you want w/ comments
19:55:48 <Gracenotes> well, this website has CGI Haskell support, so I'll start there, but make it sufficiently generic with regards to backend
19:56:04 <aristid> and there's stuff like disqus for the comments
19:56:15 <tgeeky> serialhex: the default template for octopress (which uses hakyll) is lovely though
19:56:18 <tgeeky> err!
19:56:19 <tgeeky> jekyll
19:56:28 <Gracenotes> well, the whole point of this excursion is that disqus is a little bit creepy.
19:56:41 <tgeeky> I'm a little bit creepy
19:56:44 <shapr> Gracenotes: how so?
19:56:44 <aristid> Gracenotes: oh, i wasn't there when that started
19:56:47 <serialhex> tgeeky: yes, yes it is!
19:56:55 <aristid> or i was, but i didn't pay attention
19:56:57 <Gracenotes> I "own" these comments, in theory, so why shouldn't they be on my server?
19:57:12 <tgeeky> Gracenotes: because that's not profitable for other people
19:57:15 <Gracenotes> And why should comments on my blog be cross-correlated with those on others'? Pseudonym or real name should be enough to do so.
19:57:20 <aristid> Gracenotes: because it destroys the nice "static files" architecture! :)
19:57:20 <serialhex> tgeeky: though i imagine it shouldn't be too hard to convert from one to the other...
19:57:43 <tgeeky> serialhex: probably not, but I'm lazy and I want to devote nearly 100% of my time to learning/using haskell (and not to learning/using Ruby and/or CSS and JS)
19:57:51 <Gracenotes> aristid: that is true, although I'd prefer to run my own disqus instance in such a case. That's not possible, however -- it's a global service.
19:57:58 <tgeeky> serialhex: plus, I don't have all of my debut blog posts finished yet
19:58:51 <sirtophat> apparently 2 ** 2 ** 2 ** 2 ** 2 == infinity
19:58:51 <aristid> Gracenotes: i guess you could write your own disqus-like service, host it with yesod/happstack/snap, and host the content itself as static files
19:58:54 <sirtophat> interesting
20:00:06 <serialhex> tgeeky: yeah, i'm working on a project for work while we're slow, and writing a webapp in ruby so we stop using paper workorders (small computer shop & paper workorders??  -_- )
20:00:33 <serialhex> though i can't *STAND* html/css/js  that is not what i want to do with my coding time.... :(
20:00:46 <Gracenotes> aristid: yeah, that is the plan. Currently, would like to use cgi, flat files, and some user cookies. The former two "technologies" can be swapped out, though.
20:01:04 <Gracenotes> serialhex: well, JS can be fun if it's sufficiently un-braindead
20:01:11 <serialhex> oh?
20:01:27 <Gracenotes> I mean, if there's something interesting logic in the things you're implementing
20:01:36 * irene-knapp is writing her language bootstrap in JS :) haha
20:01:45 <irene-knapp> slightly insane to do something so theory-intensive in such a theory-averse language,  yes
20:01:58 <serialhex> i havn't done much in it....  thoughi imagine no matter what lang you are using you can find interesting problems to solve using it
20:02:22 <irene-knapp> yes
20:02:26 <serialhex> irene-knapp: intentionally making it harder for yourself?
20:02:28 <irene-knapp> it's basically Lisp without metaprogramming
20:02:32 <irene-knapp> serialhex: actually yes
20:02:40 <serialhex> ooh nice!!! :D
20:02:41 <irene-knapp> the notion is that I won't be tempted to be an architecture astronaut
20:02:41 <sirtophat> why is haskell turning large numbers into infinity
20:03:02 <irene-knapp> and will be able to focus on just the shortest path to the goal, because I'll be so sick of the penalties of dynamic typing and all that crap :)
20:03:05 <sirtophat> Prelude> 2 ** 2 ** 2 ** 2 ** 2
20:03:06 <sirtophat> Infinity
20:03:29 <irene-knapp> sirtophat: if we had a lambdabot for C, you could get the same result in it.  does that provide a clue?
20:03:46 <sirtophat> that haskell just turns numbers it can't represent into infinity?
20:03:53 <irene-knapp> floating-point precision is limited
20:03:58 <serialhex> statusfailed: b/c no one has built a sufficently-designed surreal-number library for haskell yet
20:04:02 <irene-knapp> it's the FPU that's doing that, not Haskell
20:04:11 <Gracenotes> sirtophat: yeah, get a better computer
20:04:14 <Gracenotes> >_>
20:04:18 <serialhex> lol :P
20:04:35 <Gracenotes> speaking of that, if you want to know what it feels like to slam your head against a brick wall, may I suggest: http://wiki.theory.org/YourLanguageSucks
20:04:55 <Gracenotes> Complaining about JavaScript, a bullet point is: 0.1 + 0.2 === 0.30000000000000004;
20:05:02 <irene-knapp> yes, I'm familiar
20:05:08 <Gracenotes> another complaint: NaN !== NaN
20:05:36 <Gracenotes> and this is pretty rich, in the Python column: "incomplete native support for complex numbers: both (-1)**(0.5) and pow(-1, 0.5) raise an error instead of returning 0+1j."
20:05:43 * irene-knapp has a not-yet-proven proof-of-concept project for arbitrary-precision irrationals
20:06:06 <irene-knapp> haha, Common Lisp is the only language I know of in which that works
20:06:13 <irene-knapp> wait, haha
20:06:17 <Gracenotes> known for its speed
20:06:18 <irene-knapp> j?  they want quaternions?
20:06:22 <irene-knapp> quite so
20:06:45 <sirtophat> I don't think it's my computer being bad
20:06:52 <sirtophat> python got it instantly
20:06:57 <serialhex> a not-yet-proven proof-of-concept???  how does that work??? :P
20:06:59 <irene-knapp> aw, no entry for Haskell on that list!
20:07:05 <Gracenotes> Python's ** operator is not the same as Haskell's **
20:07:10 <irene-knapp> oh, it's an exercise-to-the-reader-of-concept!
20:07:19 <Gracenotes> Python ** is overloaded to use integers and doubles.
20:07:41 <Gracenotes> try "float(2) ** 2 ** 2 ** 2 ** 2"
20:07:54 <serialhex> i dont know about python, but i imagine ruby would simply use bignum - which turns it into an arbitrarily large Integer
20:08:12 <Gracenotes> sirtophat: okay, I'll stop being unhelpful. you want this:
20:08:14 <Gracenotes> > 2^2^2^2^2
20:08:16 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
20:08:22 <irene-knapp> >>> float(2) ** 2 ** 2 ** 2 ** 2
20:08:23 <irene-knapp> Traceback (most recent call last):   File "<stdin>", line 1, in <module> OverflowError: (34, 'Result too large')
20:08:27 <irene-knapp> just saying
20:08:29 <Gracenotes> ^, **, and ^^ are different operators
20:08:37 <Gracenotes> irene-knapp: that's effectively infinity :)
20:08:40 <irene-knapp> yes :)
20:08:41 <serialhex> yep, i'm right with ruby :)
20:08:53 <irene-knapp> but yeah
20:09:00 <irene-knapp> I want a language where pi / 2 * 2.0 == pi
20:09:10 <sirtophat> yeah, 2^2^2^2^2 did it
20:09:18 <irene-knapp> that's what my not-proof-of-concept would be doing
20:09:34 <irene-knapp> not original, based on an archaic paper someone here dug up and pointed me at when I expressed a desire for such a thing
20:09:55 <sirtophat> Prelude> (pi*2/2)==pi
20:09:55 <sirtophat> True
20:10:06 <irene-knapp> > e
20:10:07 <lambdabot>   e
20:10:16 <irene-knapp> > e ^ i * pi
20:10:20 <Gracenotes> or 'exp 1', as they call it in my parts
20:10:21 <lambdabot>   mueval: ExitFailure 1
20:10:21 <lambdabot>  mueval: Prelude.undefined
20:10:33 <irene-knapp> > exp 1 ^ pi
20:10:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:10:35 <lambdabot>    `GHC.Float.Floating a'
20:10:35 <lambdabot>  ...
20:10:37 <irene-knapp> hm
20:10:43 <irene-knapp> well, anyway, it would have precision drift
20:11:00 <irene-knapp> but it needn't, because both numbers are expressible precisely as recipes for computing them, as it were
20:11:04 <irene-knapp> rather than as decimal expansions
20:11:31 <irene-knapp> (a decimal expansion is, of course, only a particular type of recipe for computing a number...)
20:11:32 <Gracenotes> > exp (0 :+ pi) + 1
20:11:34 <lambdabot>   0.0 :+ 1.2246467991473532e-16
20:11:48 <irene-knapp> close but no cigar :)
20:11:55 <Gracenotes> I'll tell Euler
20:13:13 <serialhex> irene-knapp: hmmm....  that might not work well all the time, as different ways of getting pi might not play nicely with the few ways of getting e... and it might take a while to realize that e^pi*i == 1
20:13:37 <siracusa> -1
20:13:45 <irene-knapp> well, yes, but actually the paper /claims/ to have a representation which admits of a simple canonicalization algorithm
20:13:51 <serialhex> yes yes, sorry :P
20:13:52 <irene-knapp> I haven't been able to verify this claim yet
20:14:15 <theadmin> "I want a language where pi / 2 * 2.0 == pi" => perl -e 'use constant PI => 4*atan2(1, 1); print ((PI / 2 * 2.0) == PI);' # Am just sayin :P irene-knapp
20:14:59 <irene-knapp> hm, …. *visualizes a unit circle*
20:15:02 <serialhex> yeah, that's what you'd need... cause i know of a few ways to get pi, 3 use sigma notation, and one is an iterative process using 3 variables...  and i'm sure there are more :)
20:15:11 <Gracenotes> irene-knapp: you don't want a language where that's the case, you want a floating point representation where the least significant fractional binary digit is 0
20:15:14 <irene-knapp> right, of course
20:15:20 <jmcarthur> > pi / 2 * 2 :: Double
20:15:20 <Gracenotes> ...or a compiler which optimizes it away >_>
20:15:21 <lambdabot>   3.141592653589793
20:15:25 <jmcarthur> > pi / 2 * 2 :: CReal
20:15:27 <lambdabot>   3.1415926535897932384626433832795028841972
20:15:33 <monochrom> some scheme implementations are capable of sqrt(2)^2 == 2 and moreoever sqrt(2)^2 is rational. I don't know what they do to pi.
20:15:37 <irene-knapp> well no, Gracenotes, I don't care about the language really, I meant to say I want a number representation.  but calling it floating-point is wrong.
20:15:53 <jmcarthur> > (pi / 2 * 2 :: CReal) == pi
20:15:54 <lambdabot>   True
20:16:08 <jmcarthur> (not really an accurate test of equality, but the fact it claims is at least true)
20:16:16 <irene-knapp> that's nice then
20:16:17 <serialhex> (pi / 2 * 2 ) == pi
20:16:22 <serialhex> > (pi / 2 * 2 ) == pi
20:16:25 <lambdabot>   True
20:16:33 <theadmin> Infact... I think...
20:16:40 <theadmin> > (pi / 2 * 2.0) == pi
20:16:40 <Gracenotes> irene-knapp: hm, yeah. some fixed point representations, even arbitrary-precisioned, may admit some of those nice properties
20:16:41 <lambdabot>   True
20:16:42 <irene-knapp> > let epsilon = 1 ^^ −16 in epsilon
20:16:43 <lambdabot>   <no location info>: parse error on input `
20:17:01 <irene-knapp> argh unicode transformation
20:17:06 <irene-knapp> well, I don't care enough
20:17:13 <monochrom> perhaps 1e-16
20:17:18 <irene-knapp> I was going to try adding an epsilon, subtracting it again, and seeing if it worked
20:17:19 <irene-knapp> ah
20:17:32 <theadmin> Let me do that for you...
20:17:42 <irene-knapp> > let epsilon = 1e-16 in (pi / 2) + epsilon * 2 == pi
20:17:43 <lambdabot>   can't find file: L.hs
20:17:47 <theadmin> > let epsilon = 1 ^^ (-16) in epsilon
20:17:49 <lambdabot>   1.0
20:18:05 <irene-knapp> clearly, that is not the operator I thought haha
20:18:08 <monochrom> clearly, 1^^blah = 1
20:18:11 <theadmin> What's ^^?
20:18:20 <theadmin> I know ^ and **, but what's ^^?
20:18:34 <theadmin> @src (^^)
20:18:35 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
20:18:44 <monochrom> a^^2 = a*a and a^^(-2) = 1/(a*a)
20:18:52 <irene-knapp> does anybody know where that "can't find file: L.hs" came from?
20:19:03 <monochrom> a race condition. so just try again
20:19:10 <jmcarthur> > exp (pi * (0 :+ 1)) :: Complex CReal
20:19:12 <lambdabot>   (-1.0) :+ 0.0
20:19:13 <irene-knapp> > let epsilon = 1e-16 in (pi / 2) + epsilon * 2 == pi
20:19:14 <lambdabot>   False
20:19:36 <irene-knapp> > let epsilon = 1e-16 in ((pi / 2) + epsilon) * 2 - (2 * epsilon) == pi
20:19:37 <lambdabot>   True
20:19:39 <irene-knapp> hm
20:19:39 <irene-knapp> nice
20:19:53 <irene-knapp> > let epsilon = 1e-16 in ((pi / 2) - epsilon) * 2 + (2 * epsilon) == pi
20:19:54 <lambdabot>   True
20:19:59 <Gracenotes> just a sec
20:20:02 <Gracenotes> :t (^)
20:20:04 <Gracenotes> :t (^^)
20:20:05 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
20:20:05 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
20:20:06 <Gracenotes> :t (**)
20:20:06 <irene-knapp> > let epsilon = 1e-64 in ((pi / 2) - epsilon) * 2 + (2 * epsilon) == pi
20:20:07 <lambdabot>   True
20:20:07 <lambdabot> forall a. (Floating a) => a -> a -> a
20:20:25 <irene-knapp> > let epsilon = 1e-1024 in pi + epsilon == pi
20:20:28 <lambdabot>   True
20:20:30 <irene-knapp> there we go
20:20:40 <irene-knapp> that's the simplest way, probably, of showing why I'm displeased with floats :)
20:20:49 <jmcarthur> > let epsilon = 1e-1024 in pi + epsilon == (pi :: CReal)
20:20:51 <lambdabot>   True
20:20:57 <jmcarthur> silly approximate equals
20:21:05 <irene-knapp> it's actually precise equals, but bitwise
20:21:11 <Gracenotes> irene-knapp: I don't know why game programmers insist on using floats instead of fixed
20:21:13 <irene-knapp> it's not doing rounding at comparison time
20:21:21 <jmcarthur> irene-knapp: for CReal it just doesn't compute enough
20:21:24 <irene-knapp> Gracenotes: I know right!  In games in particular, the weird properties of floats show up
20:21:32 <Gracenotes> I guess if all of the math happens with the camera at (0, 0, 0), you at least get better precision closeby
20:21:42 <irene-knapp> Gracenotes: like, did you realize half the precision of any float type is between 0.0 and 1.0?
20:21:48 <Gracenotes> yeah
20:21:55 <irene-knapp> the other half of the precision is smeared hyperbolically over the entire rest of the range
20:21:59 <irene-knapp> yeah
20:22:18 <irene-knapp> so if you have a zero-point within the accessible bounds of your game world, it is a strange and mysterious place indeed for bugs :)
20:22:23 <jmcarthur> > 1e-1024 :: Double
20:22:24 <lambdabot>   0.0
20:22:26 <jmcarthur> > 1e-1024 :: CReal
20:22:28 <lambdabot>   0.0
20:22:37 <Gracenotes> well, it goes ... < 0.125 < .25 < .5 < 1 < 2 < 4 < 8 < 16 < ...
20:22:43 <irene-knapp> yes
20:22:50 <theadmin> jmcarthur: Stop surprising lambdabot.
20:22:52 <Gracenotes> where each '<' range is an equal amount of precision with the others
20:22:58 <irene-knapp> theadmin: haha
20:23:01 <jmcarthur> > showCReal 100 1e-1024
20:23:02 <lambdabot>   "0.0"
20:23:05 <jmcarthur> meh
20:23:11 <theadmin> Now you gave it eyebrows!
20:23:13 <theadmin> %)
20:23:29 <irene-knapp> showHex 1e-1024 ""
20:23:34 <irene-knapp> > showHex 1e-1024 ""
20:23:35 <lambdabot>   Ambiguous type variable `t' in the constraints:
20:23:35 <lambdabot>    `GHC.Real.Integral t'
20:23:35 <lambdabot>   ...
20:23:42 <irene-knapp> > showHex 1e-1024 :: CReal
20:23:43 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
20:23:44 <lambdabot>         against infe...
20:23:51 <irene-knapp> > showHex (1e-1024 :: CReal)
20:23:52 <lambdabot>   No instance for (GHC.Real.Integral Data.Number.CReal.CReal)
20:23:52 <lambdabot>    arising from...
20:23:58 <jmcarthur> > drop 1000 $ showCReal 100000 1e-1024
20:24:00 <lambdabot>   "00000000000000000000000001"
20:24:02 <irene-knapp> > showHex (1e-1024 :: CReal) "" — sorry for the verbosity
20:24:04 <lambdabot>   Not in scope: `sorry'Not in scope: `for'Not in scope: `the'Not in scope: `v...
20:24:12 <irene-knapp> > showHex (1e-1024 :: CReal) ""
20:24:13 <lambdabot>   No instance for (GHC.Real.Integral Data.Number.CReal.CReal)
20:24:13 <lambdabot>    arising from...
20:24:16 <theadmin> irene-knapp: Jeez, use GHCi to play around, or at least PM the bot >.<
20:24:18 <irene-knapp> okay, what jmcarthur said
20:24:19 <irene-knapp> sorry
20:24:32 <monochrom> @type showHex
20:24:33 <lambdabot> forall a. (Integral a) => a -> String -> String
20:24:36 <irene-knapp> was attempting to be helpful, but couldn't get it right heh
20:24:41 <jmcarthur> sorry, it's my own fault for starting this LB spam
20:24:46 <monochrom> see the "Integral" there. I think you can't use showHex
20:24:51 <irene-knapp> no, I was equally guilty
20:24:56 <irene-knapp> ah indeed
20:25:02 <theadmin> Anyway y'all, I'm off
20:25:06 <irene-knapp> well, you could use Storable to look at the bits if you cared
20:25:11 <monochrom> haha
20:30:58 -StretchedALot(StretchedA@93.89.92.12)- Tired of niggers? Sick of their monkeyshines? We are too! Join Chimpout Forum! http://www.chimpout.com/forum At Chimpout, we are NOT white supremacists! I myself am a Mexican! Basically, if you are not a NIGGER and you hate NIGGERS, we welcome you with open arms! Join Chimpout Forum today! http://www.chimpout.com/forum  If you report me and get me klined, there will be ddos attacks of innocents in your channel in the future.  We have monitored and hav
20:31:27 <Raynos> classy as always
20:31:56 --- mode: ChanServ set +o monochrom
20:32:05 --- mode: monochrom set +b *!*@93.89.92.12
20:32:05 --- kick: StretchedALot was kicked by monochrom (StretchedALot)
20:32:07 <tgeeky> I for one am pround to have common ancestry with Chimpanzees.
20:32:10 <tgeeky> proud*
20:33:04 <monochrom> perhaps I should report him and get us ddos'ed as promised
20:33:26 <jmcarthur> please do
20:33:30 <jmcarthur> it would be worth it
20:33:45 <BMeph> monochrom: Perhaps you should report him to the US gov't as a cyber-terrorist...
20:33:46 <serialhex> +1!!!
20:33:52 <serialhex> HAHAHAHAH!!!!
20:34:05 <monochrom> marienz: please note StretchedALot StretchedA@93.89.92.12 above, thanks
20:34:10 <serialhex> oh wait... that might be a fate worse than he deserves.....   :(
20:34:42 <zzing_> What did I just come back to… what a message
20:36:31 <Gracenotes> for a really large channel, we get rather few trolls
20:36:52 <XexonixXexillion> ... what is a monkeyshine?
20:37:28 <Gracenotes> in any case, on to matters of Haskell, and less so bait.
20:38:21 * hackagebot egison 2.1.12 - An Interpreter for the Programming Language Egison (SatoshiEgi)
20:41:47 <CSWookie> Am I right in thinking that there is no concept of time in a list comprehension?  If the end result is going be 5 elements long then testing the length in the middle of its evaluation will give me five?
20:42:10 <CSWookie> XexonixXexillion: Monkeyshines are like shenanigans.
20:42:31 <zzing_> CSWookie, how exactly would you test the length in the middle?
20:42:49 <monochrom> I don't understand the question, but there is no time
20:43:09 <zzing_> Also there is no guarantee of the order of evaluation afaik
20:43:23 <monochrom> perhaps you should just read my http://www.vex.net/~trebla/haskell/lazy.xhtml
20:43:27 <CSWookie> let xs = [y | x <- [1..5], let y = length xs]
20:44:37 <monochrom> > let xs = [y | x <- [1..5], let y = length xs] in xs
20:44:38 <lambdabot>   [5,5,5,5,5]
20:44:58 <CSWookie> That's what I got, yes.
20:45:08 <XexonixXexillion> that's not really evaluated in the middle
20:45:15 <CSWookie> I'm verifying my understanding of what happened there.
20:45:51 <XexonixXexillion> you get xs = [length xs, length xs, length xs, length xs, length xs]
20:46:09 <monochrom> your understanding holds you so far. but beware: one experiment can prove you wrong
20:46:41 <monochrom> > let xs = [y | x <- [1..], let y = length xs] in length (take 10 xs)
20:46:43 <lambdabot>   10
20:47:08 <monochrom> s/holds you/holds up/
20:47:37 <Gracenotes> > length $ take 10 (repeat undefined)
20:47:40 <lambdabot>   10
20:47:52 <XexonixXexillion> > let xs = [y | x <- [1..], let y = length xs] in take 10 xs
20:47:57 <lambdabot>   mueval-core: Time limit exceeded
20:48:27 <XexonixXexillion> and now it fails, as it can't get the length of xs
20:48:36 <CSWookie> I'm experimenting because I was trying to write a list comprehension to spit out primes, and was hanging.  I'm thinking that my problem was expecting the predicate to happen between each result determination.
20:49:07 <Gracenotes> XexonixXexillion: sure you can. it's just a million. er, no, a bit higher. billion.. trillion... you'll get to it eventually
20:49:13 <Gracenotes> maybe.
20:49:44 <XexonixXexillion> Gracenotes: length returns an Int, it can't be higher than maxBound :p
20:50:19 <monochrom> maxBound grows with Moore's law
20:50:46 <Gracenotes> additionally.. hm... length xs might only be calculated once, depending on the degree to which ghc does lambda lifting.
20:51:01 <Gracenotes> I forget.
20:51:47 <monochrom> "let" is enough to set up for calculating at most once
20:52:08 <monochrom> oh wait, I see what you mean, you are right
20:53:06 <Gracenotes> Denotational semantics: $0. For everything else, there's Debug.Trace.
20:53:27 <monochrom> haha
20:57:13 <CSWookie> So, how would I write my lc?  I was trying to do a test on all of the lc that had been created "so far", but that's not going to work for me, since there is no "so far".
20:58:05 <CSWookie> I'm fairly sure I'm tripping over my background in imperitive languages, here.
21:18:55 <siracusa> CSWookie: What is an lc?
21:20:32 <Cale> CSWookie: Still with us? :)
21:21:39 <zzing_> :t <*>
21:21:41 <lambdabot> parse error on input `<*>'
21:21:50 <Cale> I'm interesting in hearing what he means by lc too. The only things I can think of are lambda calculus, lowercase and line count.
21:21:54 <Cale> :t (<*>)
21:21:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:22:48 <BMeph> Cale: List comprehension. He was (is?) calculating a list of primes.
21:23:00 <Cale> ah, okay
21:23:32 <zzing_> :t liftIO
21:23:34 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
21:23:35 <Cale> Well, you can use the list that you're defining recursively
21:23:48 <Cale> (though I'm not sure he's still here...)
21:25:12 <zzing_> :t liftA
21:25:14 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
21:26:37 <c_wraith> So, what's the use case for existing record syntax that Van Laarhoven lenses don't cover?
21:26:58 <zzing_> :t (<$>
21:26:59 <zzing_> :t (<$>)
21:27:00 <lambdabot> parse error (possibly incorrect indentation)
21:27:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:28:22 * hackagebot metamorphic 0.1.2.3 - metamorphisms: ana . cata or understanding folds and unfolds (DrewDay)
21:29:33 <zzing_> :t (>>=)
21:29:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:31:08 <zzing_> :t (=<<)
21:31:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:31:28 <coppro> =<< is the correct function
21:31:52 <zzing_> coppro, do you know what I am doing?
21:32:01 <coppro> nope
21:32:11 <coppro> besides playing with lambdabot a lot
21:32:14 <zzing_> How would you know what is the correct function :-)
21:32:32 <coppro> what are you trying to do?
21:32:46 <zzing_>                  writeText =<< (liftIO $ inputMarkdown (documentPath <> (T.unpack s) <.> "md"))
21:33:00 <zzing_> That is the correct way of doing it for compilation - now can it be made nicer? :P
21:33:11 <coppro> oh
21:33:12 <coppro> dunno
21:33:15 <zzing_> Just trying to avoid s <- ..     writeText s
21:33:40 <zzing_> I love monoids
21:33:54 <coppro> <3 monoids
21:34:08 <zzing_> Once I heard that all string types were monoids…
21:34:33 <Cale> Well, [a] is a monoid under (++) and []
21:35:47 <coppro> the free monoid even
21:36:03 <zzing_> I forget - what was the free monoid?
21:36:29 * coppro acquires the lock on the answer
21:36:33 * coppro goes to change the laundry
21:37:04 * zzing_ picks the lock
21:37:16 <Cale> zzing_: Well, there's a way to formalise it properly, but vaguely a "free" something or other is a thing which satisfies the axioms of whatever you're talking about, and all the things those will imply, and no "extra conditions"
21:37:31 <Cale> But that's a kind of bad description :)
21:37:43 <zzing_> Why is that a bad description?
21:38:35 <Cale> Well, for example, [Char] is the free monoid on Char, and it certainly has some properties which just any type of lists doesn't have, but those are all properties from Char being in the way
21:41:06 <dolio> [()] is commutative, but that is not required of monoids.
21:42:38 <Cale> So, a working description... a free monoid on the set X is a monoid F together with a function i: X -> F, so that for any other monoid M and function f: X -> M, there is a unique monoid homomorphism u: F -> M so that u . i = f. (This is easier to follow if you draw the triangle of arrows)
21:43:52 <Cale> If N and M are monoids, then a monoid homomorphism is a function f: N -> M so that f(1_N) = 1_M, and f(x*y) = f(x)*f(y) (where the multiplication on the left is in N and on the right in M)
21:45:34 <Cale> This technical description of free monoid is probably going to be a bit tough to grasp if you haven't seen such things before though...
21:46:53 <Cale> I don't know if you've had any linear algebra, but this is analogous to the situation where if you have a basis X for a vector space (which I'm going to strangely call) F
21:47:24 <Cale> then for any other vector space M and function X -> M, there's a unique linear transformation F -> M
21:47:55 <Cale> (which, incidentally, is the property that lets us record linear transformations using matrices)
21:48:26 <Cale> By saying what the linear transformation does to each of the basis vectors, we know what it does everywhere
21:48:35 <coppro> zzing_: The other way of thinking about a free structure is that it is the structure that preserves the most information.
21:48:45 <coppro> The free monoid, for instance, actually preserves the entire construction
21:49:28 <coppro> [a] ++ [b] ++ [c] ++ [d] ++ [e] == [a, b, c, d, e]
21:53:02 <zzing_> > [a] <> [b]
21:53:04 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
21:53:04 <lambdabot>         agains...
21:55:07 <zzing_> Is there a better way to write something like this: c <- contentType     ;              modifyResponse $ setContentType (TE.encodeUtf8 c)
21:57:20 <coppro> zzing_: contentType >>= modifyResponse . setContentType . TE.encodeUtf8 ?
22:02:59 <Cale> or use =<< so that the data will flow in the same direction across the page
22:03:05 <Kaidelong> I take it there is nothing like Squeak for haskell
22:04:18 <Cale> There's Vital...
22:05:11 <Cale> not really analogous
22:06:06 <Cale> and it only implements a small subset of Haskell
22:07:26 <unlink> there must be a better way to express this ...  \a x (y, y') -> case a x of (f, f') -> (f y, f' y')
22:07:45 <Kaidelong> yeah it's interesting, reminds me a little of asmL but
22:08:00 <Kaidelong> it doesn't really seem to be a "multimedia IDE"
22:08:01 <Kaidelong> oh well
22:08:33 <Axman6> i think chris done is doing a lot of work to basically turn emacs into something sort of similar
22:08:36 <Kaidelong> multimedia does seem a littlehairy for haskell in general especially on windows
22:09:01 <unlink> Sort of like uncurrying, except instead of ``(x,y) -> z'' I have ``(a -> b, c -> d)''
22:09:06 <zzing_> I think I keep missing out on opportunityies to composefunctions
22:09:20 <Cale> Kaidelong: It's less the multimedia aspect which makes that hard than the self-editing part.
22:09:44 <Kaidelong> oh that's true
22:10:10 <Kaidelong> doesn't seem intractible though
22:12:49 <dolio> @type uncurry (***)
22:12:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
22:13:08 <zzing_> :t (=<<)
22:13:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
22:13:34 <zzing_> >>=
22:13:36 <unlink> I got here by doing something like   ((+) *** userId)
22:13:38 <zzing_> :t (>>=)
22:13:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:14:22 <unlink> whoops.... ((+) *** comparing userId)
22:17:28 <unlink> oh boy, that's the trick.
22:17:44 <zzing_> Is there a certain pattern to constructions with $ that can be modified to be composition? It just seems like a pattern in a few instances
22:19:31 <shachaf> What is written in Haskell as "f $ g $ h $ x" can be written as "f . g . h $ x"
22:19:38 <shachaf> The latter is considered better style.
22:19:51 <joecool> http://hackage.haskell.org/trac/ghc/ticket/5991 << this is not fixed with 7.4.2
22:20:01 <joecool> i'm still seeing around 100 wakeups/s from xmonad
22:20:38 <zzing_> Can anyone suggest any improvements to this: https://github.com/iaefai/Askin/blob/master/StaticDoc.hs    I just got it working, it does use snap, but is mostly ordinary I think.
22:20:48 <joecool> nope, seems a little better i guess, i waited around 5 minutes and it's down to like 30/second (which is still high IMO)
22:22:21 <DanBurton> Hello, all. I have come to spam you, as I occasionally do, with shameless self-promotion. http://www.reddit.com/r/haskell/comments/wbb69/the_long_and_epic_journey_of_lambdacase/
22:22:51 <shachaf> Don't spam. :-(
22:23:11 <fizzbang> hello! i'm missing something basic i guess: when i do in ghci "import Math.Tau" and then "tau" it tells me "tau" isn't in scope!
22:23:23 <shachaf> Man, if only there was a website you could post Haskell links to, where people could vote on which ones should be the most visible.
22:23:24 <DanBurton> I could call it something else if you prefer. A gift, from the blog gods.
22:23:24 * hackagebot AbortT-transformers 1.0.0.1 - A monad and monadic transformer providing "abort" functionality (GregoryCrosswhite)
22:23:36 <shachaf> fizzbang: What does ":browse Math.Tau" say?
22:24:40 <fizzbang> shachaf: it can't find it in the current program or any known package!
22:24:46 <DanBurton> oh this is an annoying thing about ghci, it seems to silently swallow "import" statements that don't work
22:25:05 <shachaf> fizzbang: Oh, "import" in ghci doesn't give an error message.
22:25:10 <fizzbang> i guess i need to install the module? but i come from python; i thought since import didn't give an error then it hat imported fine..
22:25:14 <shachaf> fizzbang: Try ":m + Math.Tau"
22:25:24 <shachaf> fizzbang: It's just a ghci weirdness/bug.
22:25:44 <shachaf> Anyway, I don't think Math.Tau comes built-in with the standard library?
22:25:46 <fizzbang> shachaf: right! and you cleared that up quickly :)
22:26:00 <fizzbang> ah, i guess it doesn't come built-in..
22:26:08 <DanBurton> "cabal install tau" should do the trick
22:26:15 <DanBurton> @hackage tau
22:26:15 <lambdabot> http://hackage.haskell.org/package/tau
22:26:43 <zzing_> 7.6.1 looks to be a rather huge endevour
22:26:56 <shachaf> Hmm, tau = 2*pi
22:27:11 <shachaf> Is there ever a case where it makes sense to talk about "pi" but where multiplication isn't commutative?
22:27:17 <zzing_> I love the version numbering
22:27:20 <DanBurton> every 7.(2*n).1 release has appeared to be a rather huge endevour
22:27:28 <shachaf> Man, remember 6.6?
22:27:32 <shachaf> *That* was a great release.
22:28:41 <DanBurton> I'm such a Haskell noob xP I don't really know about anything pre-6.12
22:28:55 <fizzbang> shachaf: i guess i was asking more about module stuff, just using tau as an example really :P
22:28:56 <zzing_> I played with 6.4 I think
22:29:10 * zzing_ collects geek points
22:29:19 <shachaf> 6.6 introduced the threaded RTS, I think.
22:29:29 <shachaf> That's right -- GHC-compiled programs were single-threaded before that!
22:29:34 <zzing_> What version do we take over the world?
22:30:00 <zzing_> Can I get cabal to tell me if I am not using certain depends?
22:30:32 <DanBurton> I say 2013 will be The Year of The Linux^H^H^H^H^HHaskell
22:30:51 <zzing_> 2013 will be the year of the Haskell Desktop
22:30:54 <ion> Haskell on the desktop
22:30:59 <shachaf> The year of Haskell on the Linux.
22:31:23 <zzing_> 2015 will see FreeBSD take over Linux installs and all will be right with the world
22:31:24 <ion> I heard they will release Steam implemented in Haskell in 2013.
22:31:27 <DanBurton> I always secretly hope that Darcs will catch on again and become more popular than git
22:32:22 <DanBurton> zzing_: not sure. The dumb way is to just comment out the dependency in the .cabal file and see if it compiles xP
22:32:29 <zzing_> Doesn't it have fundamental performance issues?
22:32:59 <DanBurton> most of the performance issues were fixed in Darcs 2.0, or so I'm told
22:33:13 <zzing_> I heard the issues were after 2 was released
22:33:36 <DanBurton> *shrug*
22:34:15 <DanBurton> people over in #darcs might give you a better answer
22:34:35 <zzing_> ghc on freebsd is still 7.4.1 - is there any issues that would be disadvantageous to run 7.4.1 instead of 7.4.2?
22:35:33 <DanBurton> here's the release notes: nothing really important to the casual user that I'm aware of http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/release-7-4-2.html
22:36:25 <AfC> zzing_: It's called the "red giant bug", but I'm sure™ they've fixed it; http://blogs.operationaldynamics.com/andrew/software/version-control/red-giant-bugs was a long time ago.
22:36:32 <zzing_> nothing super major
22:36:41 <DanBurton> I mean, the minor version changes are just bugfixes, so you're not missing out on any new features or anything
22:37:34 <zzing_> hmm, the writer didn't like git...
22:37:51 <DanBurton> Yeah I just read that too :)
22:37:57 <zzing_> Why did they call darcs a '2nd generation' tool and git/bzr/etc a 3rd generation?
22:38:34 <DanBurton> arbitrary age classification I guess. darcs is older than those other ones iinm
22:38:48 <newsham> I have a program with a foo.cabal file.  is there an option I can run that will fetch and install all prereqs without doing any configure/build/install steps on the program itself?
22:39:14 <Adeon> complain that it incorrectly gives the impression that darcs is outdated
22:39:33 <DanBurton> newsham: I swear I've seen that before, let me check...
22:39:40 <zzing_> The guy wrote it 6 years ago :P
22:39:58 <DanBurton> cabal install --only-dependencies
22:39:59 <Adeon> "I remember what you did 6 years ago"
22:40:30 <newsham> perfect, thank you db
22:40:55 <DanBurton> no problem, got that from cabal install --help
22:43:43 <zzing_> Adeon approach the guy from behind in the dark and say that with a red knife
22:43:54 <Kaidelong> looks like for making a cross platform haskell game engine, I'll have to roll my own, and for 3D graphics I might have to too although there are ogre bindings
22:44:42 <zzing_> I wanted to look to see if one could make a 2d metro game app for windows 8 in mostly haskell :P
22:45:10 <Kaidelong> there is a windows-specific game engine called HGamer that looks nice
22:46:21 <zzing_> nice
22:47:08 <zzing_> I am interested in coming up with a 2d engine, I was thinking a monoid for screen objects and FRP for events
22:47:51 <Kaidelong> 2D also makes it easier
22:48:04 <Kaidelong> don't need a way to import models made in a modeler
22:48:20 <Kaidelong> sdl_image serves just fine
22:48:27 <zzing_> I like the possibilities of win8
22:49:59 <zzing_> I will pick up more tricks from snap before I am ready for that though
22:56:13 <zzing_> I am being annoyed with template haskell I believe now
22:56:46 <zzing_> StaticDoc.hs:31:1: Parse error: naked expression at top level
22:56:56 <zzing_> makeLens ''StaticDoc
22:57:22 <zzing_> forgot {-# LANGUAGE TemplateHaskell #-}
22:59:15 <zzing_> Are the extension directives best in the source file or in cabal file?
23:00:22 <yitz> zzing_: probably both
23:00:59 <yitz> zzing_: if a particular module file depends on an extension, seems to me to make sense that the extension should appear together with that code in the file itself
23:01:11 <zzing_> I suppose so
23:01:31 <yitz> zzing_: and at the same time cabal ought to know about it too, to make sure to do whatever it needs to
23:06:03 <zzing_> I should update that
23:06:22 <zzing_> Heist gives me problems should wait until tomorrow to seek answers to those
23:24:18 <optimight> I had a brief view to documentation of EMACS 23 , but could not understand how to use it for .hs file, how to to set it to haskell mode?
23:24:31 <pqmodn> @hoogle m (n a) -> n (m a)
23:24:32 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
23:24:32 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
23:24:32 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
23:26:51 <zzing_> Mine just worked when I loaded an hs file
23:27:42 <optimight> When I loaded .hs file , it does not give syntax highlighting
23:27:57 <zzing_> Does it say haskell on the bottom bar?
23:28:26 * hackagebot fast-logger 0.2.0 - A fast logging system (KazuYamamoto)
23:28:28 * hackagebot wai-logger 0.2.0 - A logging system for WAI (KazuYamamoto)
23:28:30 * hackagebot wai-logger-prefork 0.2.0 - A logging system for preforked WAI apps (KazuYamamoto)
23:28:31 <optimight> zzing: nopt
23:28:36 <optimight> nope*
23:28:49 <zzing_> optimight, google for the haskell major mode that is the best I can help you with
23:28:58 <optimight> okay
23:35:45 <optimight> zzing: yes , I did sudo apt-get install haskell-mode and it worked  -- started highlighting syntax in .hs file
23:40:47 <zzing_> nice
23:41:46 <drakoniis> @help
23:41:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:41:50 <drakoniis> @list
23:41:51 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:42:27 <drakoniis> @help unlambda
23:42:28 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
23:42:32 <drakoniis> ooo
23:43:12 <drakoniis> @unlambda ``^xxy
23:43:13 <lambdabot>   unlambda: Unknown operator '^'
23:44:13 <drakoniis> @unlambda ```sxyz
23:44:14 <lambdabot>   unlambda: Unknown operator 'x'
23:44:18 <drakoniis> @unlambda ```s
23:44:18 <lambdabot>   unlambda: Parse error at end of file
23:44:29 <drakoniis> @unlambda `skk
23:44:30 <lambdabot>  Done.
