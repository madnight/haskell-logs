00:00:38 * hackagebot FilePather 0.1.0 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.1.0 (TonyMorris)
00:01:10 <drdo> dmwit: I guess, i've never ran into such a situation, the Text module has quite a lot of functions to do all the usual things
00:02:35 <rmshkmr> hello folks
00:02:40 <rmshkmr> got a newbie question
00:03:07 <andares> I'd love to help but I'm a newb myself rmshkmr.
00:03:09 <andares> but shoot!
00:03:19 <rmshkmr> trying to compile this on Hugs:
00:03:21 <rmshkmr> averageThree :: Int->Int->Int->Float
00:03:22 <rmshkmr> averageThree x y z = (x + y + z) / 3
00:03:31 <dmwit> :t (/)
00:03:32 <lambdabot> forall a. (Fractional a) => a -> a -> a
00:03:36 <rmshkmr> but getting the error:
00:03:37 <rmshkmr> Hugs> :l chap_3.hs
00:03:37 <rmshkmr> ERROR "chap_3.hs":52 - Type error in explicitly typed binding
00:03:37 <rmshkmr> *** Term           : averageThree
00:03:37 <rmshkmr> *** Type           : Int -> Int -> Int -> Int
00:03:37 <rmshkmr> *** Does not match : Int -> Int -> Int -> Float
00:03:43 <dmwit> rmshkmr: (/) takes and returns values of *the same type*.
00:03:58 <rmshkmr> ah I c
00:04:00 <dmwit> rmshkmr: (And Int isn't Fractional, but that's beside the point for now.)
00:04:00 <rmshkmr> thank you.
00:04:22 <dmwit> rmshkmr: You might like `div` if you want to return an Int, or fromIntegral to convert Int's to Float's.
00:04:28 <rmshkmr> using the book "Haskell: Craft of Functional Programming - 2nd edition"
00:05:14 <rmshkmr> the type signature of that function 'averageThree' was specified as averageThree :: Int->Int->Int->Float
00:05:23 <rmshkmr> it must have been an error in the book then.
00:05:25 <rmshkmr> thanks.
00:10:48 <andares> hey, is Haskell type syntax itself a functor?
00:11:07 <andares> like the a -> b -> c things in type declarations.
00:11:55 <kallisti> ???
00:12:17 <rmshkmr> Folks, it's really my 2nd day with functional programming and I'm really struggling even with the simplest stuff. Pls bear with me. How do I write a function which takes three Int numbers, calculates their average and returns a Float?
00:12:27 <kallisti> andares: the type (->) a  is a functor.
00:12:39 <andares> oh, wow.
00:12:56 <kallisti> rmshkmr: f :: Float; f x y z = (x + y + z) / 3
00:13:06 <kallisti> replace the semicolon with a newline  (though the semicolon is also valid Haskell)
00:13:23 <shachaf> kallisti: That certainly won't be valid.
00:13:34 <kallisti> oh
00:13:35 <kallisti> yes
00:13:41 <kallisti> 3 AM. -_-
00:14:01 <rmshkmr> but how do i assert the type check on x, y & z?
00:14:22 <kallisti> rmshkmr: f :: Int -> Int -> Int -> Float; f x y z = fromIntegral (x + y + z) / 3
00:14:36 <rmshkmr> let me try that.
00:14:47 <kallisti> :t fromIntegral
00:14:48 <lambdabot> forall a b. (Integral a, Num b) => a -> b
00:15:06 <kallisti> rmshkmr: you can think of fromIntegral as a conversion from integer-like values to any kind f "number"
00:15:12 <kallisti> *of
00:17:20 <kallisti> > (2 + 2 + 2 :: Int) / 3
00:17:21 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
00:17:21 <lambdabot>    arising from a use o...
00:17:24 <kallisti> this doesn't work
00:17:35 <kallisti> because divison can escape the integers.
00:17:53 <kallisti> (the operator `div`, on the other hand, performs integer division)
00:18:38 <roastbird> hello. may i ask whether there's an easier way to obtain the "network" package for ghc on windows, without installing msys/mingw or cygwin?
00:19:17 <rmshkmr> works like a charm:
00:19:17 <rmshkmr> averageThree :: Int->Int->Int->Float
00:19:18 <rmshkmr> averageThree x y z = fromIntegral(x + y + z)/3
00:19:18 <rmshkmr> Hugs> :l chap_3.hs
00:19:18 <rmshkmr> Main> averageThree 2 6 8
00:19:18 <rmshkmr> 5.333333
00:19:18 <rmshkmr> Main> averageThree 1 2 3
00:19:19 <rmshkmr> 2.0
00:19:19 <rmshkmr> Main>
00:19:23 <rmshkmr> Thanks Guys.
00:19:52 <rmshkmr> 20 years of hardwired imperative programming is really something huge to go up against while learning functional programming.
00:19:55 <rmshkmr> :)
00:20:53 <kallisti> rmshkmr: another important thing to note that numeric literals in Haskell are overloaded.
00:21:04 <kallisti> so when you write the literal 2, it's overloaded to any numeric type.
00:21:13 <rmshkmr> implicitly?
00:21:16 <kallisti> yes.
00:21:20 <kallisti> > 2 + 2 :: Int
00:21:21 <lambdabot>   4
00:21:23 <kallisti> > 2 + 2 :: Integer
00:21:24 <lambdabot>   4
00:21:26 <kallisti> > 2 + 2 :: Word8
00:21:27 <lambdabot>   4
00:21:27 <rmshkmr> you mean like it is automatically 'casted'?
00:21:28 <kallisti> etc
00:21:35 <kallisti> it's polymorphic.
00:21:46 <rmshkmr> ok, thanks.
00:22:02 <kallisti> rmshkmr: what it means depends on how it's used.
00:22:07 <kallisti> > 2 + 2 :: Expr
00:22:08 <lambdabot>   2 + 2
00:22:12 <rmshkmr> on the context?
00:22:24 <kallisti> yes, on the concrete type it's given.
00:22:25 <rmshkmr> something similar to  perl I suppose
00:22:37 <kallisti> not really. Perl just has one number type.
00:22:40 <latros> I wouldn't try to draw analogies to other language's type systems, frankly
00:22:46 <rmshkmr> tell me about it.
00:22:54 <latros> there are analogies to other languages to be made in some places
00:22:54 <rmshkmr> it's really challenging unlearning things now
00:22:58 <latros> the type system is not one of them
00:23:04 <latros> (for the most part)
00:23:14 <rmshkmr> i am beginning to see that the hard way :)
00:23:39 <kallisti> rmshkmr: what "2" means is inferred from other things. it can also be inferred from an explicit type signature.
00:23:45 <kallisti> > 2 :: Float
00:23:46 <lambdabot>   2.0
00:23:56 <kallisti> here I use an explicit type signature
00:23:59 <kallisti> > 2 + 2.0
00:23:59 <lambdabot>   4.0
00:24:02 <kallisti> here it's inferred.
00:24:09 <rmshkmr> ic.
00:24:21 <kallisti> (though 2.0 is also overloaded. :P )
00:24:28 <kallisti> so maybe not a great example.
00:25:00 <rmshkmr> i'm currently using Craft of Functional Programming by Simon Thompson. Do you have any other suggestions of texts I should look at?
00:25:16 <kallisti> Learn You a Haskell seems to be the easiest to follow.
00:25:47 <kallisti> :t round
00:25:48 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:25:48 <rmshkmr> but it's too prosaic...not coming to the point at times. I am also reading that.
00:26:04 <rmshkmr> 2.0 is overloaded too?
00:26:04 <kallisti> rmshkmr: I haven't really noticed that much.
00:26:10 <rmshkmr> gosh
00:26:11 <kallisti> yes, in a different way.
00:26:16 <kallisti> numeric literals are special
00:26:18 <rmshkmr> i'm literally scratching my head now :)
00:26:38 <kallisti> it's to make simple things like arithmetic relatively painless
00:26:39 <dmwit> rmshkmr: re: "you mean like it is automatically 'casted'?" There are no casts in Haskell.
00:26:57 <kallisti> the only kind of cast is an explicit conversion via a function
00:26:58 <rmshkmr> ok
00:27:00 <kallisti> > round 2.0
00:27:01 <lambdabot>   2
00:27:16 <kallisti> which isn't a "cast" at all.
00:27:23 <dmwit> re: "Do you have any other suggestions of texts I should look at?"
00:27:24 <rmshkmr> :)
00:27:31 <dmwit> The usual suggestions are RWH, LYAH, and the Gentle Introduction.
00:27:44 <kallisti> also, play around with lambdabot and ghci
00:27:47 <dmwit> If you feel any of the things you are reading are too wordy, the Gentle Introduction will cure you of that complaint. =)
00:27:48 <rmshkmr> Gentle Introduction is a book?
00:27:49 <kallisti> also, try to write programs.
00:27:52 <dmwit> ?where gentle
00:27:53 <lambdabot> http://www.haskell.org/tutorial/
00:28:08 <kallisti> I think I started with gentle intro actually.
00:28:13 <dmwit> I really like the Gentle Introduction, but it doesn't get a lot of love these days because it's very, very fast.
00:28:14 <kallisti> and then LYAH
00:28:36 <kallisti> fast is good, for an overview.
00:28:44 <dmwit> It is gentle... for programming language researchers who have been dealing with similar languages for twenty years. =)
00:28:47 <kallisti> it helps to have a big picture so that the details make more sense as you're going through them
00:29:13 <rmshkmr> i'm hopping between COFP and LYAH currently, I should look at Gentle Intro first then
00:29:37 <kallisti> rmshkmr: if you're not a novice programmer then it's not a bad choice.
00:30:02 <kallisti> it uses scary terms like "lambda" and "first-class" and "expression"
00:30:15 <rmshkmr> actually, i think being a novice programmer would be making things easier for me.
00:30:38 <dmwit> ...those terms aren't scary.
00:30:39 <kallisti> well, maybe I should say, if you have familiarity with programming language concepts.
00:30:46 <andares> LYAH is the most awesome one ever.
00:30:48 <rmshkmr> it's all that stuff accumulated through the years forcing me to draw parallels and analogies with what I've learnt of imperative languages
00:30:54 <kallisti> dmwit: too literal, my friend.
00:32:11 <rmshkmr> any place where i could get a collection of questions/exercises i could try my hands on which develops gradually in difficulty?
00:32:21 <mathstuf> dmwit: Xrandr pull request filed :)
00:32:22 <dmwit> rmshkmr: "averageThree" isn't exactly a paramount of functional programming. It's hardly more than an expression in any language, imperative or otherwise...
00:32:30 <dmwit> mathstuf: Wow, fast work!
00:32:33 <rmshkmr> i really feel like i'm really learning programming for the first time with haskell.
00:34:01 <kallisti> rmshkmr: what else are you familiar with?
00:34:46 <hpaste> asd pasted “sad” at http://hpaste.org/65094
00:34:47 <rmshkmr> C/C++, Perl, Prolog, Python, Java, Unix Shell
00:36:23 <rmshkmr> would it help if i tackle "Lambda Calculus" first before touching Haskell?
00:36:37 <kallisti> probably not.
00:36:42 <rmshkmr> that's even scarier -> Lambda Calculus
00:36:46 <kallisti> but sure.
00:36:51 <kallisti> go for it. lambda calculus is good.
00:37:09 <rmshkmr> my ultimate destination is to use haskell for computational semantics in NLP
00:37:46 <roastbird> then lambda calculus and other logic algebras would be unavoidable
00:38:01 <roastbird> might as well invest in them early
00:38:07 <rmshkmr> i can see a lot of features from Perl and Python having been drawn from Haskell
00:38:12 <andares> man, Haskell is so far out.
00:39:07 <rmshkmr> do you guys know Lisp?
00:39:09 <dmwit> Lambda calculus is too bare to really help, I think.
00:39:20 <dmwit> Haskell is a better starting point for lambda calculus than lambda calculus is.
00:39:20 <rmshkmr> how do u compare that with Lisp with Haskell?
00:39:25 <rmshkmr> LOL
00:39:27 <rmshkmr> LOL
00:39:44 <rmshkmr> i somehow feel that is right instinctively :)
00:39:49 <roastbird> i'd say lambda calculus is (relatively) simple, and offers a good benefit / reward for any major programming task
00:40:09 <andares> dmwit: I am trying to use Haskell to improve my abstract algebra/category theory for a knot theory course. do you know of any algebra/category-theoretic aspects I could look at?
00:40:42 * hackagebot uAgda 1.2.0.3 - A simplistic dependently-typed language with parametricity.  http://hackage.haskell.org/package/uAgda-1.2.0.3 (JeanPhilippeBernardy)
00:40:52 <dmwit> um
00:41:12 <dmwit> I suppose the whole Category/Functor/Applicative/Monad chain is pretty CT-inspired.
00:41:32 <dmwit> You might want to look into domain theory to understand how types and functions can form a category.
00:41:53 <dmwit> There's the numeric prelude for algebra stuff.
00:42:07 <dmwit> ?hackage numeric-prelude
00:42:08 <lambdabot> http://hackage.haskell.org/package/numeric-prelude
00:42:16 <dmwit> And I think the "Haskell for Maths" blog might be relevant.
00:42:25 <dmwit> http://haskellformaths.blogspot.com/
00:42:36 <dmwit> sigfpe's blog is also certainly very CT- and Haskell-focused.
00:42:40 <dmwit> ?where sigfpe
00:42:40 <lambdabot> http://sigfpe.blogspot.com/
00:43:07 <andares> thanks!
00:44:41 <roastbird> rmshkmr: i've built web applications in scheme, haskell, and java before. i quite fancy haskell as a language (i'm very into mathematical abstractions, coming from an economics/stats/algebra background), but i had a much more productive time with PLT scheme
00:45:01 <rmshkmr> PLT?
00:45:27 <roastbird> it's now known as racket scheme. if you haven't heard of it before, it can be summarized as a scheme with batteries included.
00:45:42 * hackagebot uAgda 1.2.0.4 - A simplistic dependently-typed language with parametricity.  http://hackage.haskell.org/package/uAgda-1.2.0.4 (JeanPhilippeBernardy)
00:46:07 <rmshkmr> this part of the world is really the computing backwaters -> Malaysia  :)
00:46:25 <kallisti> I now feel like I'm using String and Text somewhat arbitrarily...
00:47:29 <roastbird> my most major issues with haskell are: 1. very hard to use dynamic types. i use the dynamic types library. unfortunately, web servers are much simpler when you use dynamic types.
00:48:09 <roastbird> 2. haskell has a primitive module system. this matters a lot when software scales up.
00:48:21 <kallisti> roastbird: you usually have no reason to use the dynamic types library.
00:48:40 <roastbird> rmshkmr: i'm next to you -> Singapore (:
00:48:49 <kallisti> because the problem is usually better solved by an appropriate data structure or type class.
00:48:50 <rmshkmr> ha ha ha
00:49:29 <kallisti> but, if you're looking for easy to use dynamic types in a statically typed language, I don't know what to say...
00:49:33 <Hemite> What's wrong with: scalr (flip (:)) [] [3,2,1]
00:49:36 <Hemite> scalr works fine
00:49:43 <roastbird> kallisti: that's what i thought too initially. i commonly have a hashtable with values with dynamic types
00:49:44 <Hemite> scanl*
00:49:56 <kallisti> roastbird: probably better solved with an algebraic data type.
00:49:59 <kallisti> in almost all cases...
00:50:18 <dmwit> Hemite: Did you mean to stick a control character in the middle of your list?
00:50:20 <dmwit> :t scanl
00:50:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
00:50:41 <kallisti> I'd imagine if you were to write a JSON library you would turn to dynamic types, no? because, hey, it's JSON.
00:50:43 <dmwit> > scanl (flip (:)) [] [3,2,1]
00:50:44 <lambdabot>   [[],[3],[2,3],[1,2,3]]
00:50:53 <kallisti> however, if you look at any JSON library, they use algebraic data types instead.
00:50:55 <dmwit> Hemite: Anyway, that seems to WFM
00:50:57 <Hemite> yea sorry, the code should be:
00:50:58 <Hemite> scanl (flip (:)) [] [3,2,1]
00:51:24 <Hemite> how come the same doesn't work with scanr
00:51:25 <Hemite> I get an error I don't understand
00:51:39 <dmwit> Hemite: ...scanr has a different type.
00:51:42 <dmwit> :t scanr
00:51:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
00:51:55 <dmwit> > scanr (:) [] [3,2,1]
00:51:56 <lambdabot>   [[3,2,1],[2,1],[1],[]]
00:51:58 <rmshkmr> anyone here's done any work using Haskell in the field of computational semantics/Natural-Language Processing?
00:52:02 <Hemite> oh ok
00:52:05 <dmwit> That said, you basically never want to use scanr.
00:52:23 <roastbird> kallisti: I agree that JSON can be statically typed. the number of types in a JSON object is finite (string, number, and a few more). i encounter problems in other areas, like creating a hashtable that can dispatch functions of different types.
00:52:48 <kallisti> ...different arity as well?
00:52:59 <roastbird> different arity, different types
00:53:21 <roastbird> FunctionDispatchHashTable -> MyReifiedTypeId -> TypedValue
00:53:25 <kallisti> someone with more experience could perhaps point you to a better solution. I don't know of any.
00:54:45 <shachaf> roastbird: Can you give an example of how you use that?
00:56:41 <roastbird> hi shachaf, i can't remember clearly as it's been some time ago - i have since switched to scheme and python for my webservers. vaguely, i was using a DSL to generate a combination of HTML/JS/CSS in such a way that assures the requires/imports in the HTML/JS/CSS.
00:57:48 <roastbird> to identify what has already been "loaded", e.g. if a JS library (written in Haskell) has been included, a unique ID associated with the JS library is added to a hash table
00:58:24 <roastbird> however, to retrieve the functions in the JS library from the hash table, i had to get a structure that held the functions of the js library
00:58:40 <roastbird> the only information i had are the keys to the hash table, and perhaps the type ID
01:00:17 <roastbird> the generation of the library assigned unique JS variable names, so it required the use of IO or at least unsafeIO (which was difficult, but workable)
01:01:08 <roastbird> because the variable names differed according to the sequence of and which JS libraries loaded, it isn't possible to statically define them.
01:01:47 <roastbird> i.e. the JS libraries are usulaly of : UniqueIdGenerator -> SomeOtherStaticTrackingVariablesSTate -> SomeMonad
01:02:16 <kallisti> roastbird: are you familiar with web app frameworks such as Yesod?
01:02:22 <roastbird> yup
01:02:35 <roastbird> use the warp server. nice piece of work
01:03:07 <roastbird> it's a bit lacking on the client-side templating. beyond a certain complexity, templating fails.
01:08:10 <roastbird> there were a few other issues here where static typing was impossible without dependent types, and everything went dynamic types instead - in the end, i realized that i might as well use a dynamic-type by default language, like scheme. didn't really regret haskell though, as it was incredibly easy to rewrite haskell code in scheme. haskell is remarkably clean.
01:08:46 <roastbird> not sure if other haskellers face the same issues. this is pretty much for web applications that's around the complexity of say google maps, or some of those more interactive html5 games.
01:10:12 <roastbird> ( and for simpler web applications that can easily run on Yesod or Happstack, there's really no need to use Haskell, unless it's a front-end to a Haskell application stack )
01:12:21 <JonFairbairn> Is there a uu-parsinglib combinator (ⓞ say) so that p1 ⓞ p2 means something like p1<|>micro p2 1 ?
01:30:32 <kallisti> @hoogle (<.>)
01:30:32 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
01:30:32 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
01:45:22 <drbean> I wanted to bring rmshkrmr's attention to http://www.computational-semantics.eu, where they use haskell.
01:47:11 <DrSatan> hi guys, this function is meant to find the product of a list of tuples, but it doesnt work, can someone help me out please?:
01:47:24 <DrSatan> pairProducts xs = [x * y| x <- fst xs, y <- snd xs]
01:47:47 <shachaf> DrSatan: The thing on the right side of a <- needs to be a list.
01:47:50 <latros> fst xs isn't a thing, because xs isn't a tuple
01:47:55 <kallisti> DrSatan: that looks like a 2-tuple of lists to me.
01:48:05 <latros> unless xs is in fact a 2-tuple of lists
01:48:08 <latros> in which case that would work
01:48:15 <DrSatan> it is a list of tuples yes
01:48:25 <kallisti> which is not a 2-tuple of lists.
01:48:26 <latros> a list of tuples, not a tuple of lists
01:48:28 <shachaf> It's clear what DrSatan meant, but list comprehensions aren't magic. :-)
01:48:38 <DrSatan> i.e., [(1,5),(2,4),(3,3),(4,2),(5,1)]
01:48:39 <shachaf> Now someone is going to type in an answer and ruin the whole thing.
01:48:51 * latros resisted the compulsion to do so
01:48:54 <DrSatan> just tell me what I'm doing wrong rather...
01:49:03 <kallisti> you're using a tuple function on a list
01:49:03 <latros> you can't call fst/snd on a list
01:49:04 <shachaf> DrSatan: Do you understand what the code that you wrote does?
01:49:14 <kallisti> > fst [(1,2),(3,4)]  -- ?????
01:49:15 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `[a1]'
01:49:36 <latros> on the other hand
01:49:41 <latros> map fst [(1,2),(3,4)]
01:49:41 <shachaf> DrSatan: I recommend writing your function without using a list comprehension first.
01:49:45 <latros> er
01:49:49 <latros> > map fst [(1,2),(3,4)]
01:49:50 <lambdabot>   [1,3]
01:50:03 <kallisti> latros: I don't think that's what he wants either.
01:50:13 <latros> I agree
01:50:16 <latros> I was just making a point
01:50:20 <kallisti> mmk
01:51:50 <kallisti> DrSatan: the pattern on the left side of the <- is applied to each element in the list.
01:51:53 <kallisti> think about that.
01:52:05 * shachaf has the feeling that it's impossible to be helpful.
01:52:13 <kallisti> DrSatan: are you familiar with pattern matching?
01:52:50 <shachaf> #haskell is the worst channel on Freenode. Everyone here is terrible. Especially me.
01:52:53 * shachaf ought to go to sleep.
01:53:20 <JonFairbairn> Is there anyone about who’s familiar with uu-parsinglib?
01:56:03 <c_wraith> I've used uu-parsinglib a bit.
01:57:35 <JonFairbairn> c_wraith: I was wondering if there was an operator like <|> but with a micro applied to the rhs
01:57:56 <randomclown> why is the first number always 6 when I call evalState (liftM3 (,,) rollDie2 rollDie2 rollDie2) (mkStdGen 0)
01:57:58 <randomclown> hpaste.org/65095
01:58:11 <randomclown> http://hpaste.org/65095
01:58:21 <shachaf> randomclown: Because you're calling mkStdGen 0 each time.
01:58:28 <randomclown> the other two number change
01:58:33 <randomclown> numbers*
01:58:42 <kallisti> they should also be the same each time.
01:58:44 <kallisti> I would think.
01:58:47 <randomclown> when I seed with something other than 0
01:58:49 <kallisti> if you're always using the same seed.
01:58:55 <kallisti> randomclown: yep.
01:59:02 <kallisti> because you used a different seed.
01:59:02 <DrSatan> Is there any super user friendly text editor for haskell (im thinking like code blocks-esque), or do i keep using wordpad?
01:59:11 <kallisti> that's how PRNGs work. same seed gives you the same value always.
01:59:29 <randomclown> when I do (mkStdGen 0) = (6,6,4)
01:59:51 <randomclown> when I do (mkStdGen 1) = (6,5,2)
01:59:56 <kallisti> oh, that.
02:00:03 <kallisti> yes I've noticed that as well.
02:00:13 <randomclown> when I do (mkStdGen 324) = (6,4,5)
02:00:19 <c_wraith> mkStdGen does not initialize the state well
02:00:33 <c_wraith> you will see patterns like that for all kinds of small moduli
02:00:39 <kallisti> and large.
02:00:53 <kallisti> (ambiguous qualifiers! yeaaah!)
02:01:03 <shachaf> randomclown: It's not always 6.
02:01:20 <randomclown> it's 6 for every number for every number I've tried so far
02:01:21 <shachaf> It's just not all that random, as c_wraith says.
02:01:30 <c_wraith> JonFairbairn: no, there's no combinator that does that.
02:02:01 <shachaf> randomclown: Try 100000
02:02:21 <randomclown> finally a 5
02:02:34 <shachaf> randomclown: More generally, try typing map (\x -> let (a,b,c) = evalState (liftM3 (,,) rollDie2 rollDie2 rollDie2) (mkStdGen x) in a) [1..] into ghci and watching it for a while.
02:02:43 <kallisti> randomclown: I'd recommend either chopping off a large chunk of the random number sequence (gross hack), use a different PRNG, or use IO (I'm not sure that using IO actually fixes anything, but the effect is less noticeable).
02:03:01 <c_wraith> > [ n | x <- [0..], let g = mkStdGen x, let (_, n) = randomR (1, 6) g ]
02:03:02 <lambdabot>   [40014 40692,80028 40692,120042 40692,160056 40692,200070 40692,240084 4069...
02:03:11 <c_wraith> heh, oops
02:03:18 <c_wraith> > [ n | x <- [0..], let g = mkStdGen x, let (n, _) = randomR (1, 6) g ]
02:03:19 <lambdabot>   [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,...
02:03:24 <ClaudiusMaximus> > randomR (1, 6) (read "does this give more bits of entropy? or might parse fail?" :: StdGen)
02:03:25 <lambdabot>   (*Exception: Prelude.read: no parse
02:03:45 <randomclown> well randomR is definately broken
02:03:46 <c_wraith> > dropWhile (==6) [ n | x <- [0..], let g = mkStdGen x, let (n, _) = randomR (1, 6) g ]
02:03:47 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
02:03:49 <shachaf> Maximum entropy
02:04:01 <c_wraith> randomclown: randomR is fine.  The problem is mkStdGen
02:04:09 <randomclown> either one
02:04:40 <c_wraith> randomclown: no, it matters. randomR is implemented correctly, regardless of the particular RandomGen instance being used.
02:04:57 <randomclown> alright alright it's mkStdGen
02:04:58 <JonFairbairn> c_wraith: thanks.  Obviously I can define one :-)
02:04:58 <ClaudiusMaximus> > randomR (1, 6) (fst . head . reads $ "does this give more bits of entropy? or might parse fail?" :: StdGen) -- oops
02:04:59 <shachaf> > take 5 . nubBy ((==) `on` fst) $ [ (n,x) | x <- [0..], let g = mkStdGen x, let (n, _) = randomR (1, 6) g ]
02:05:00 <lambdabot>   (6,1520331930 40692)
02:05:01 <lambdabot>   [(6,0),(5,53668),(4,107336),(3,161004),(2,214673)]
02:08:03 <c_wraith> man, shachaf. That's quite an indictment of mkStdGen.  Why wasn't it built to do a little more work to make the initial state less uniform?
02:10:44 <shachaf> c_wraith: Maybe if you're using mkStdGen you don't care anyway.
02:14:03 <kallisti> using Aeson has made this Selenium library pretty painless
02:14:11 <kallisti> since it's all just sending and receiving JSON.
02:14:17 <kallisti> over HTTP.
02:16:04 <kallisti> might even put in on Hackage as my first package.
02:16:08 * kallisti feels unworthy.
02:49:03 <niteria> can I do something like instance Num a => Ix a where ... ?
02:49:24 <mauke> no
02:50:03 <niteria> so what can I do if for all Nums instances look the same?
02:50:32 <niteria> just spell them out?
02:51:35 <mauke> yes
02:52:00 <mauke> niteria: how would that instance even look like if you could?
02:52:43 <ClaudiusMaximus> perhaps something like this might work? (though still inappropriate for these particular classes)   newtype WrappedNumForIx a = W a  instance Num a => Ix (WrappedNumForIx a) where ...
02:54:17 <niteria> mauke: http://hpaste.org/65097 ?
02:54:37 <mauke> :t \x y -> [x .. y]
02:54:38 <lambdabot> forall t. (Enum t) => t -> t -> [t]
02:54:44 <mauke> niteria: ^ that requires Enum, not just Num
02:54:53 <mauke> niteria: and <= requires Ord
02:55:06 <niteria> I tried with Enum, Ord already
02:55:34 <mauke> remember that Num includes, among others: Word8, Int, Integer, Float, Rational, Complex Double, and functions
02:55:42 <niteria> and class Ord a => Ix a where
02:55:49 <mauke> yeah, you still can't do that
02:57:28 <ClaudiusMaximus> instance Num a => Ix a where ...   will overlap with everything, because constraints aren't taken into account when matching instances
02:57:40 <niteria> Oh I forgot about Complex
02:57:58 <ClaudiusMaximus> > (1,2,3) * 7
02:57:58 <lambdabot>   (7,14,21)
02:58:18 <mauke> niteria: and your rangeSize is a type error
03:00:01 <niteria> what about something like instance Ix Int, Ix Integer where ... ?
03:00:46 <mauke> niteria: that makes no sense
03:01:17 <mauke> you suffer from premature abstraction
03:01:24 <mauke> write the two instances by hand first
03:01:31 <mauke> then decide whether they are the same
03:15:46 <pocky> !
03:38:20 <root> ?src
03:38:20 <lambdabot> src <id>. Display the implementation of a standard function
03:38:29 <Guest21195> ?src unfoldr
03:38:29 <lambdabot> unfoldr f b  = case f b of
03:38:29 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
03:38:30 <lambdabot>    Nothing        -> []
03:39:23 <niteria> @src array
03:39:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:41:56 <Guest21195> ?src transpose
03:41:56 <lambdabot> transpose []             = []
03:41:56 <lambdabot> transpose ([]   : xss)   = transpose xss
03:41:57 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
03:49:16 <ben> Is System.Posix.Directory.changeWorkingDirectory the most portable way to do it
03:52:01 <ChristianS> ben: Posix won't work on windows
03:57:47 <ben> ChristianS: That's why I asked :)
04:00:16 <ChristianS> ben: i don't know of a more portable way, but do you really need that function?
04:02:00 <opqdonut> I was under the impression that windowses are in fact posix compatible
04:02:38 <mauke> opqdonut: ok, call me when you find a working fork() on windows
04:03:30 <opqdonut> (... compatible to some pretty much useless extent, of course)
04:05:49 <ChristianS> System.Posix is in the unix package which (surprise, surprise) "is not supported under Windows (except under Cygwin)" -- http://hackage.haskell.org/package/unix
04:08:34 <HugoDaniel> hmm
04:09:47 <ben> I was expecting a portable wrapper somewhere in base. I'll use the posix one for now and see about wrapping it when I get that far.
04:10:34 <mauke> ben: setCurrentDirectory
04:11:43 <ben> Thank you
04:28:25 <JoeyA> What's a good name for things like IORef and TVar that hold a single value that can be modified?
04:29:02 <JoeyA> "variable" is ambiguous, in that it can also refer to names of immutable values (e.g. x in f x = ...)
04:30:31 <ClaudiusMaximus> @hoogle StateVar
04:30:31 <lambdabot> package StateVar
04:30:31 <lambdabot> package readline-statevar
04:30:47 <tzxn3> JoeyA: container?
04:31:01 <tzxn3> that's really what variables are in most languages
04:31:53 <Axman6> JoeyA: mutable variables?
04:32:25 <JoeyA> I think I'll go with "mutable variable".  Thanks.
04:32:45 <tzxn3> I think mutable variable leads to confusion
04:33:17 <tzxn3> as they are more like containers than the mathematical concept of variables that Haskell uses
04:34:57 <adnauseam>  tzxn3 would be alright to call haskell's vars defs as in definitions?
04:36:15 <adnauseam> hrm. is it me or does it take a while to understand how haskell's random functions..
04:36:46 <tzxn3> I don't know.
04:37:19 <adnauseam> i don't get what a RandomGen is supposed to be exactly :|
04:37:34 <tzxn3> I'd just call them variables, but it is a bit of a misnomer compared to what variables are in imperative languages.
04:38:01 <tzxn3> however, it could be argued that the use of the term "variable" in an imperative language is a misnomer
04:38:31 <zerax> Imperative ruining it for everyone.
04:38:50 <adnauseam> hah
04:39:10 <dmwit> adnauseam: In Haskell, you (get to/have to) track the random number generator's state manually.
04:40:20 <adnauseam> hrm
04:41:18 <adnauseam> i don't know about being able to following it manually myself. i'm pretty lost trying to understand this definition: random (mkStdGen 100) :: (Int, StdGen)
04:41:28 <adnauseam> function call*
04:41:55 <adnauseam> is mkStdGen here being set as a n Int type?
04:42:10 <adnauseam> and 100 as stdGen ?
04:42:40 <adnauseam> it doesn't make ssense - somehow im not reading this correcrly
04:43:23 <_Mikey> adnauseam
04:43:34 <adnauseam> yea :|
04:43:37 <Cale> :t mkStdGen
04:43:38 <lambdabot> Int -> StdGen
04:43:39 <_Mikey> the value returned by random
04:43:45 <Cale> :t mkStdGen 100
04:43:45 <lambdabot> StdGen
04:43:49 <Cale> :t random
04:43:50 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
04:43:52 <_Mikey> when passed the stdGen
04:43:56 <Cale> :t random (mkStdGen 100)
04:43:57 <_Mikey> will be a tuple
04:43:57 <lambdabot> forall a. (Random a) => (a, StdGen)
04:44:28 <_Mikey> Cale has shown you with the types.
04:45:03 <adnauseam> reading
04:45:16 <adnauseam> trying to understand, this will take a bit until it clicks
04:45:28 <_Mikey> no worries
04:45:55 <adnauseam> hrm, what does it mean to call a function with ::
04:46:05 <adnauseam> i was thinking of it as casting
04:46:14 <adnauseam> but i think it's not
04:46:23 <adnauseam> now*
04:46:33 <nand`> @where lyah
04:46:33 <lambdabot> http://www.learnyouahaskell.com/
04:46:45 <nand`> ^- adnauseam
04:46:52 <adnauseam> reading it - that's where i'm stuck atm
04:46:58 <Cale> adnauseam: x :: t  where x is a value and t is a type says that x has type t
04:46:59 <nand`> ah, apologies then
04:46:59 <adnauseam> i don't remember where :: was >.>
04:47:03 <nand`> :: is simply a type definition
04:47:08 <nand`> it should be right near the beginning
04:47:30 <mauke> nand`: no
04:47:33 <Cale> adnauseam: You can write it as a declaration of what type the name x will be defined as having
04:47:50 <Cale> Or you can use it in an expression to clarify which type the expression has
04:47:53 <_Mikey> sometimes the result of an expression may have an ambiguous type
04:47:55 <_Mikey> hea
04:48:00 <_Mikey> yea*
04:48:04 <nand`> :t 5 :: Int
04:48:05 <lambdabot> Int
04:48:07 <nand`> :t 5
04:48:07 <lambdabot> forall t. (Num t) => t
04:48:26 <_Mikey> :t 5 :: Integer
04:48:27 <lambdabot> Integer
04:49:05 <Cale> You can't use it to cast or convert between types, but you can use it to reduce the amount of polymorphism
04:49:07 <nand`> adnauseam: For what it's worth, :: is *not* a cast. Haskell does not cast (unless you use unsafeCoerce); it's a type definition. So you can't do this:
04:49:11 <nand`> > (5 :: Int) :: Integer
04:49:12 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
04:49:12 <lambdabot>         against inf...
04:49:32 <nand`> but you can do this
04:49:36 <adnauseam> so in this case,  the return type of random (mkStdGen 100) is being defined as being (Int, stdGen)?
04:49:40 <nand`> > fromIntegral (5 :: Int) :: Integer
04:49:41 <lambdabot>   5
04:49:51 <_Mikey> yea
04:50:15 <Cale> adnauseam: yes, which determines which instance of the Random class to use, which tells it what sort of (pseudo-)random value to generate
04:50:41 <Cale> adnauseam: otherwise, it might not be able to tell what sort of thing you wanted, and complain about ambiguous types
04:50:42 <adnauseam> it's a bit funny since i was thinking ghc would infer it is what it is since it's defined in random's own function type definition
04:50:59 <Axman6> :t ranomd
04:51:00 <lambdabot> Not in scope: `ranomd'
04:51:00 <Axman6> sfkjsefk
04:51:04 <Axman6> :t random
04:51:04 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
04:51:12 <Cale> random's type definition lets it generate any sort of random value for which there's an instance of the typeclass Random
04:51:28 <Cale> So, you need to give a type signature to say which kind of random value you want
04:51:41 <adnauseam> yeah i'm seeing it's a type parameter and not a concrete type - maybe that's where my confusion stems from
04:51:55 <nand`> > fst $ random (mkStdGen 100)
04:51:56 <lambdabot>   -3650871090684229393
04:52:02 <nand`> oh, defaulting
04:52:22 <Cale> Yeah, lambdabot has extended default rules turned on
04:52:49 <nand`> > fst $ random (mkStdGen 100) :: Bool
04:52:50 <lambdabot>   True
04:52:54 <nand`> > fst $ random (mkStdGen 100) :: Int8
04:52:55 <lambdabot>   No instance for (System.Random.Random GHC.Int.Int8)
04:52:55 <lambdabot>    arising from a use o...
04:52:57 <nand`> > fst $ random (mkStdGen 100) :: Int
04:52:58 <lambdabot>   -3650871090684229393
04:53:02 <nand`> > fst $ random (mkStdGen 100) :: Char
04:53:03 <lambdabot>   '\134011'
04:53:06 <nand`> etc.
04:53:17 <_Mikey> fst $ random (mkStdGen 100) :: (Bool,StdGen)
04:53:29 <_Mikey> > fst $ random (mkStdGen 100) :: (Bool,StdGen)
04:53:30 <lambdabot>   No instance for (System.Random.Random
04:53:30 <lambdabot>                     (GHC.Bool.Bool, S...
04:53:36 <_Mikey> really?
04:53:57 <nand`> _Mikey: the “fst” in this case takes the type Random a => (a, StdGen) -> a
04:54:14 <ClaudiusMaximus> @instances-importing Random System.Random
04:54:15 <lambdabot> Couldn't find class `System.Random'. Try @instances-importing
04:54:18 <_Mikey> ahh
04:55:08 <adnauseam> hrm
04:55:20 <_Mikey> > random(mkStdGen 100)
04:55:21 <lambdabot>   (-3650871090684229393,693699796 2103410263)
04:55:29 <_Mikey> >fst$ random(mkStdGen 100)
04:55:42 <_Mikey> :t fst$ random(mkStdGen 100)
04:55:43 <lambdabot> forall a. (Random a) => a
04:55:56 <adnauseam> hrm, seems like the random generator type should be given too
04:56:03 <nand`> adnauseam: look at
04:56:06 <nand`> :t mkStdGen
04:56:07 <lambdabot> Int -> StdGen
04:56:13 <_Mikey> > fst $ random(mkStdGen 100) :: (Bool,StdGen)
04:56:14 <lambdabot>   No instance for (System.Random.Random
04:56:14 <lambdabot>                     (GHC.Bool.Bool, S...
04:56:20 <nand`> adnauseam; so it's already unambiguous since it has to be StdGen
04:56:37 <_Mikey> I thought Bool was an instance of random though
04:56:57 <nand`> _Mikey: it is
04:57:24 <_Mikey> oh ok, I must be doing something stupid then. :)
04:57:31 <Axman6> @instances Random
04:57:32 <lambdabot> Couldn't find class `Random'. Try @instances-importing
04:57:46 <adnauseam> so mkStdGen is a instance of StdGen, but i still need to specify which stdGen i'm going to use to with random, since per definitoin it takes one of severel random-number-standard-generators
04:57:50 <Axman6> @instances-importing System.Random Random
04:57:51 <lambdabot> Bool, Char, Double, Float, Int, Integer
04:58:04 <_Mikey> > fst $ random(mkStdGen 100) :: (Char,StdGen)
04:58:05 <lambdabot>   No instance for (System.Random.Random
04:58:05 <lambdabot>                     (GHC.Types.Char, ...
04:58:17 <Axman6> @instances-importing System.Random RandomGen
04:58:17 <lambdabot> StdGen
04:58:27 <ClaudiusMaximus> _Mikey: :: has lowest precedence of anything - it parses as    (fst $ random(mkStdGen 100))  ::  (Bool, StdGen)
04:58:45 <_Mikey> Ahhh
04:58:48 <_Mikey> :$
04:58:56 <_Mikey> > (fst $ random(mkStdGen 100)) :: (Char,StdGen)
04:58:57 <lambdabot>   No instance for (System.Random.Random
04:58:58 <lambdabot>                     (GHC.Types.Char, ...
04:59:02 <_Mikey> no?
04:59:17 <nand`> _Mikey: he's saying that's the same as what you were using
04:59:28 <mauke> why are you trying to generate a random StdGen?
04:59:28 <nand`> you want fst $ (random (mkStdGen 100) :: (Char, StdGen))
04:59:45 <adnauseam> who, me?
04:59:52 <nand`> adnauseam: no, _Mikey
05:00:01 <_Mikey> I see
05:00:06 <adnauseam> oh alright
05:00:17 <nand`> adnauseam: as for your question, no, StdGen is an instance of RandomGen. You don't have to clarify “which StdGen” you are using since there's only one
05:00:36 <nand`> with random you have to clarify which RandomGen you are using, but with mkStdGen that is not an issue because there is only one
05:02:21 <_Mikey> Unlike imperative languages such as Java and C++ Haskell does not use classes to create objects and then send messages between objects. Rather it uses Declarative and Data-driven methods to process data.
05:02:32 <_Mikey> would anyone disagree with that?
05:03:00 <adnauseam> data driven sounds a bit like magic
05:03:09 <adnauseam> rest is ok
05:03:39 <nand`> _Mikey: I disagree. Haskell doesn't do any of those; it's the programmer that does things using Haskell
05:03:52 <nand`> You can just as easily create a huge StateT IO and pass messages
05:04:07 <_Mikey> yea, I guess.
05:04:23 <nand`> The important thing is using the right technique for the job
05:04:38 <adnauseam> can haskell do oop ? o_0
05:04:58 <steakknife> If perl can, anyone can. :)
05:05:02 <adnauseam> well, can oop be done with haskell*
05:05:12 <nand`> adnauseam: not out of the box, but you can probably define some sort of OOP yourself. (Similarly to how C doesn't have objects but you can use record counting techniques, structures and pointers to get the same)
05:05:12 <mauke> steakknife: what. perl has built-on support for it
05:05:19 <Axman6> adnauseam: yes, but please don't, especially if you're learning
05:05:23 <_Mikey> But you wouldn't agree that Haskell makes it more natural to take a different approach to programming?
05:05:24 <steakknife> mauke: um, noo
05:05:29 <steakknife> not perl 5
05:05:30 <mauke> yes
05:05:38 <adnauseam> personally i'm taking a liking to the style used in LYAH
05:05:45 <mauke> adnauseam: http://homepages.cwi.nl/~ralf/OOHaskell/
05:05:47 <steakknife> yes, it's an alias of module because larry doesn't believe in oop. :)
05:05:52 <mauke> steakknife: no, it isn't
05:06:00 <nand`> _Mikey: I disagree, depends on your definition of “different”. Different coming from what? OOP? Yes. Other pure functional languages? Perhaps not
05:06:03 <steakknife> we'll have to agree to disagree.
05:06:04 <mauke> steakknife: at least get your facts right
05:06:17 <steakknife> someone didn't take their happy pills.
05:06:30 <_Mikey> nand`, from an OOP perspective.
05:06:31 <steakknife> here, i'll share.
05:06:58 <mauke> steakknife: clearly anyone who notices you're wrong must be unhappy
05:07:03 <nand`> I would agree with “Haskell makes it more natural for OOP programmers totake a different approach to programming”
05:07:22 <_Mikey> :)
05:07:32 <adnauseam> more natural ?;p
05:08:52 <donri> for a haskell programmer, java would be "more natural for taking a different approach to programming"
05:08:57 <steakknife> mauke: keep it friendly, there's no need to be an aggressive troll.
05:09:18 <mauke> steakknife: you just insulted me by calling me a troll
05:09:26 <nand`> donri: I would agree with that, except perhaps for a personal opinion that Java seems unnatural
05:09:27 <mauke> what are you even doing
05:09:31 <donri> steakknife: he's not being aggressive, just pointing out you're wrong (which you are)
05:09:45 <donri> nanpoint being "wtf does more natural even mean" :P
05:09:52 <donri> nand`: loltab
05:09:53 <mauke> .oO( "keep it friendly, you asshole" o_O )
05:09:57 <Axman6> now now children. no one likes to hear they're wong so bluntly
05:09:57 <steakknife> oop is an illusion.
05:10:19 <donri> yes, and perl5 supports that illusion via blessing
05:10:36 <otters> haha perl isn't oop
05:10:43 <mauke> otters: define "isn't"
05:10:50 <otters> isn't = not . is
05:10:57 <mauke> otters: what language is oop?
05:10:59 <donri> moose certainly is similar to classic oop
05:11:02 <nand`> donri: Perhaps I should refine; “natural” in this case I would interpret as “straightforward and easy for a sane programmer”
05:11:05 <otters> probably java
05:11:10 <mauke> otters: haha java isn't oop
05:11:21 <otters> isn't it?
05:11:26 <mauke> isn't = not . is
05:11:41 <otters> um
05:11:46 <donri> no, it doesn't have multiple inheritance
05:11:46 <otters> okay we aren't getting anywhere
05:11:56 <donri> clearly not oop, according to a definition that includes multiple inheritance
05:11:59 <donri> :)
05:12:05 <otters> indeed
05:12:15 <otters> then again I don't think perl supports that either
05:12:16 <nand`> donri: is multiple inheritance required to create something that could be considered “OOP”? What about indirect multiple inheritance via interfaces?
05:12:20 <mauke> otters: it does
05:12:22 <otters> oh
05:12:26 * donri notes that "fp" is similarly ill-defined
05:12:42 <otters> okay well I guess you could say perl and java are both oop then
05:12:43 <otters> or neither
05:13:28 <steakknife> actually, up to a certain point, perl 4 and such were not actually object oriented.
05:13:41 <mauke> that point is called version 5
05:13:43 <hpc> perl5 uses prototype OO
05:13:48 <mauke> hpc: no
05:13:54 <steakknife> yeap like js
05:13:58 <nand`> It's all semantics either way, which I believe is a fuzzy field - it's not reasonable to exactly define what is “OOP” and what is not, as it's usually obvious for most people involved and when it isn't it can be attributed to a difference in perspective or opinion, hardly anything worth arguing over
05:14:04 <hiptobecubic> I didn't realize cwi was using haskell for... anything
05:14:10 <_Mikey> donri, are there any constructs which Java has which haskell doesn't have(as standard)?
05:14:16 <exFalso> nand`+
05:14:18 <steakknife> object oriented cloud computing
05:14:19 <steakknife> :D
05:14:28 <hpc> mauke: well, at least Moose is prototype
05:14:31 <mauke> hpc: no
05:14:52 <donri> _Mikey: not sure what you mean. they're very different languages, hardly share any constructs in the language at all.
05:14:56 <steakknife> basically i dropped in to see if someone can change the header to support bayhac
05:15:03 <exFalso> _Mikey: type safe abstract classes?
05:15:03 <steakknife> and to stir up the trolls :)
05:15:20 <steakknife> (hacking complete)
05:15:31 <_Mikey> exFalso, check!
05:15:35 <mauke> steakknife: congratulations. you can leave now.
05:16:00 <MaskRay> donri: what's the more authoritative and accurate definition of 'FP' ?
05:16:05 <steakknife> mauke: after you, ladies first.
05:16:18 <donri> i'm not sure there is one
05:16:21 <_Mikey> oh I've got it in my research
05:16:30 <_Mikey> two seconds!
05:16:32 <xplat> @tell roconnor oh duh, i should have mentioned http://r6research.livejournal.com/23705.html when i was spreading credit around :)
05:16:32 <lambdabot> Consider it noted.
05:16:46 <mauke> steakknife: ok, last warning
05:16:57 <steakknife> this is me caring.
05:17:12 <hpc> MaskRay: https://en.wikipedia.org/wiki/FP -- obviously "fat princess" because it comes first on the disambiguation page ;)
05:17:32 <hpc> MaskRay: more seriously though, i like the definition that FP "emphasizes the application of functions"
05:17:47 <donri> but then what a function is is ill-defined
05:17:48 <hpc> as opposed to changing state or machine operations
05:17:51 <steakknife> mauke: chill dude, it's the internets.  plenty for everyone.
05:18:01 <_Mikey> http://dl.acm.org/citation.cfm?id=72554
05:18:08 * steakknife passes a beer
05:18:21 <donri> i guess mainly it means "takes input and returns a result, as opposed to modifying" but then not all FP langs are pure
05:18:31 <exFalso> isnt a good definition: (constructible) types are closed under (->)?
05:18:35 <_Mikey> like second paragraph of that paper has a definition, not an extensive one but its in an academic peer reviewed paper
05:18:37 <donri> so the sense of functions becomes convulated once you have side-effects
05:21:42 <_Mikey> A functional language is language  in  which  computation  is  carried  out  entirely  through  the evaluation  of  expressions.
05:21:48 <_Mikey> would anyone disagree?
05:22:06 <nand`> _Mikey: I would
05:22:10 <steakknife> order agonistic, yeah?
05:22:19 <Axman6> odd that your definition of functional doesn't mention functions =)
05:23:10 <steakknife> Btw, does anyone know of an SKI or iota combinator reference?
05:23:17 <nand`> My personal definition of functional language: A language which emphasizes writing and combining functions to make larger functions
05:24:04 <exFalso> nand`: isnt that true for... C?
05:24:08 <nand`> By “function” I mean here “deterministic, non-stochastic function which satisfies the property that f(x)=f(x)”
05:24:14 <steakknife> has lambda then?
05:24:36 <nand`> exFalso: C does not emphasize writing or using functions, it emphasizes writing or using procedures
05:24:38 <hpc> steakknife: that would include python's lambda :P
05:24:55 <exFalso> H
05:24:57 <exFalso> ah
05:25:26 <nand`> Examples of multi-paradigm languages which I would consider functional or nearly functional: Common Lisp, Ruby
05:25:49 <hiptobecubic> python can be used very functionally as well
05:26:31 <steakknife> is python missing some closure of lambdas?
05:26:38 <nand`> In the case of ruby, even though it's object oriented and stateful, the recommended style is to use higher order functions like map instead of stateful statements like for (;;)
05:26:51 <nand`> steakknife: It is not, you just need to be careful of what scope you close
05:27:01 <nand`> (afaik, I'm not a python programmer)
05:27:17 <steakknife> ruby's procs and lambdas can get tricky, but i'm liking their flexibility
05:27:42 <nand`> Ruby actually has syntactic sugar for passing functions to functions, which I'd say only enforces that style
05:28:04 <hiptobecubic> nand`, I guess the guru's are shying away from map and pushing people towards list comprehensions instead, but it all works the same way more or less. map is present and works as expected
05:28:04 <nand`> foo { |x, y| bar } <- an anonymous lambda is passed to “foo”
05:28:09 <hiptobecubic> nand`, in python i mean
05:28:23 <nand`> contrast with haskell foo \x y -> bar
05:28:30 <steakknife> y-combinator in ruby http://is.gd/DPZgB1
05:28:30 <nand`> foo $ \x y -> bar
05:28:53 <hiptobecubic> foo = lambda x, y: bar
05:29:29 <steakknife> ->(x,y) { }   # right ?
05:31:03 <deech> Hi all, is there some way to tell GHC to ignore unused import statements when compiling? I would like to share one import file among multiple applications.
05:31:40 <steakknife> i should flame myself, that's an anon fn, not a lambda.
05:32:19 <dmwit> deech: Why not explicitly export those modules?
05:32:31 <steakknife> s/rescue LoadError/<haskell equiv>/
05:32:45 <dmwit> deech: module JustImportEverything (module Foo, module Bar) where import Foo; import Bar
05:32:46 <exFalso> module SomeModule (someFunction, SomeType, module ExportedModule) where
05:35:13 <deech> dmwit: I see what you are doing, but what I want to do is to share one file, say, EverythingUnderTheSun.hs among multiple applications that do "import EverythingUnderTheSun" but don't have huge executables.
05:40:18 <dmwit> deech: Not sure where you're going with this. Can you take it all the way to the question?
05:40:57 <exFalso> deech: you will have huge executables wither way as long as you do static linking
05:40:59 <Saizan> dmwit: he'd like GHC to not link imported modules that aren't actually needed for the code
05:41:36 <exFalso> wat
05:41:51 <dmwit> Okay. Can we agree that this solves deech's original question, though, which was about how to do this without getting any warnings?
05:42:09 <dmwit> ...ah, I see that wasn't the original question at all.
05:42:23 <Saizan> heh
05:42:26 <dmwit> I saw "ignore unused imports" and immediately thought of the warning, but that's not what deech had in mind.
05:42:29 <dmwit> Okay.
05:45:26 <xplat> kallisti: the convenience of Strings should be overlooked as often as possible, since that is what very slowly makes Text more convenient
05:48:09 <Axman6> @hoogle Text -> Maybe (Char, Text)
05:48:09 <lambdabot> Data.Text uncons :: Text -> Maybe (Char, Text)
05:48:09 <lambdabot> Data.Text.Lazy uncons :: Text -> Maybe (Char, Text)
05:48:09 <lambdabot> Data.Text mapAccumL :: (a -> Char -> (a, Char)) -> a -> Text -> (a, Text)
05:48:13 <Axman6> ah good
05:48:16 <deech> It's not a huge deal. I was just being lazy :). At least now I know there isn't an easy way. Thanks all!
05:48:39 <Axman6> would be nice if it had a version that unboxed the Char and Text values
05:51:45 <Eliel> @seen roconnor
05:51:45 <lambdabot> Unknown command, try @list
05:51:48 <mysticc> @hoogle ioref
05:51:48 <lambdabot> Data.IORef module Data.IORef
05:51:48 <lambdabot> Data.IORef data IORef a
05:51:48 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
05:52:10 <Eliel> ... strange, seen is listed as a command here http://code.haskell.org/lambdabot/COMMANDS
05:53:13 <Twey> It used to be a command but was disabled
05:55:30 <finway> ;;seen roconnor
05:55:39 <finway> no bots
05:58:27 <mauke> yes bots
06:12:21 <ChristianS> preflex: seen roconnor
06:12:21 <preflex>  roconnor was last seen on #haskell 8 hours, 15 minutes and 34 seconds ago, saying: xplat: this fact may make it easier to formulate lens independence using coalgebra operations.
06:28:32 <JoeyA> Is there a function for re-chunking a lazy bytestring to a desired chunk size (e.g. 16384 bytes per chunk, but the last chunk may have a short count)
06:28:44 <JoeyA> @hoogle L.ByteString -> L.ByteString
06:28:44 <lambdabot> Parse error:
06:28:44 <lambdabot>   L.ByteString -> L.ByteString
06:28:44 <lambdabot>    ^
06:28:52 <JoeyA> @hoogle Int -> ByteString -> ByteString
06:28:52 <lambdabot> Data.ByteString drop :: Int -> ByteString -> ByteString
06:28:52 <lambdabot> Data.ByteString.Char8 drop :: Int -> ByteString -> ByteString
06:28:52 <lambdabot> Data.ByteString take :: Int -> ByteString -> ByteString
06:30:16 <ClaudiusMaximus> @hoogle Int -> ByteString -> (ByteString, ByteString)
06:30:16 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
06:30:16 <lambdabot> Data.ByteString.Char8 splitAt :: Int -> ByteString -> (ByteString, ByteString)
06:30:17 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
06:58:38 <lukish> I wan't to use timestamp::Integer value to build some value of my typeclass. How can I get Integer value from getPOSIXTime :: IO POSIXTime ?
06:59:32 <leino> I have a question about debuggin in ghci
07:00:16 <leino> I would like to be able to set breakpoints like so 'break: Module.Hierarchy.functionAtWhichIWantToBreak'
07:00:25 <ClaudiusMaximus> lukish: realToFrac
07:00:37 <leino> however, I don't export functionAtWhichIWantToBreak, and so it's not in scope.
07:00:55 <hpc> lukish: POSIXTime is an instance of Num
07:01:31 <leino> so my question is: why can't I set breakpoints this way and what do I do instead?
07:04:18 <lukish> ClaudiusMaximus: could you explain in details?
07:07:00 <ClaudiusMaximus> lukish: look at the list of instances here http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t:NominalDiffTime (type POSIXTime = NominalDiffTime -- relative to POSIX epoch date)
07:07:05 <lukish> > let a = (floor =<< getPOSIXTime)
07:07:06 <lukish> <interactive>:1:10:
07:07:06 <lukish>     No instance for (Integral (IO b0))
07:07:06 <lukish>       arising from a use of `floor'
07:07:06 <lambdabot>   not an expression: `let a = (floor =<< getPOSIXTime)'
07:07:47 <ClaudiusMaximus> :t floor `fmap` getPOSIXTime
07:07:48 <lambdabot> Not in scope: `getPOSIXTime'
07:08:13 <lukish> > :t floor `fmap` getPOSIXTime
07:08:13 <lukish> floor `fmap` getPOSIXTime :: Integral b => IO b
07:08:13 <lambdabot>   <no location info>: parse error on input `:'
07:08:32 <lukish> It's still IO monad
07:08:40 <mauke> duh?
07:08:58 <lukish> I need clear Integer value actually
07:09:17 <mauke> like, a constant?
07:10:14 <lukish> Yes
07:10:22 <mauke> sorry, the current time is not a constant
07:10:44 <lukish> It's a pity
07:11:57 <tsanhwa> hi, I have problem deploying snapframework app. I compile my app on one machine and scp to another, and failed to run, saying :https://gist.github.com/2011704
07:12:28 <tsanhwa> what's the matter
07:13:47 <exFalso> does anyone use ghc-mod? it depends on ghc -any... where can i find that package?
07:14:33 <hpc> exFalso: i assume it means the GHC API
07:14:43 <hpc> exFalso: in which case, all that means is "you can't use hugs or whatever"
07:14:57 <exFalso> hpc: no its a package dependency
07:15:09 <exFalso> i -am- using ghc
07:15:19 <hpc> exFalso: and it's stopping cabal install?
07:15:24 <exFalso> hpc: yes
07:15:32 <hpc> huh
07:15:48 <exFalso> i tried to manually remoce the dependency]
07:15:54 <alpounet> exFalso, can you show us the build log?
07:16:01 <exFalso> but then it cant find some module
07:16:07 <dcoutts_> exFalso: what does "ghc-pkg list ghc" report?
07:16:15 <exFalso> Resolving dependencies...
07:16:15 <exFalso> cabal: cannot configure ghc-mod-1.10.11. It requires ghc -any
07:16:15 <exFalso> There is no available version of ghc that satisfies -any
07:16:50 <Saizan> exFalso: how did you install your ghc?
07:17:11 <exFalso> Saizan: pacman
07:17:18 <exFalso> 7.4.1
07:17:32 <exFalso> i'll try reinstalling
07:17:38 <hpc> run "ghc-pkg list ghc"
07:17:43 <hpc> it should say ghc-7.4.1
07:17:46 <Saizan> yeah, do what hpc says
07:17:50 <hpc> or something like that
07:17:58 <exFalso> hpc: it does
07:18:15 <hpc> try changing "ghc -any" to "ghc any", perhaps?
07:18:21 <Saizan> no
07:18:23 * hpc doesn't know cabal syntax very well
07:18:27 <hpc> ah, k
07:18:33 <Saizan> exFalso: what is the full cabal error?
07:18:40 <hpc> @where hpaste
07:18:40 <lambdabot> http://hpaste.org/
07:19:16 <dcoutts_> exFalso: does "ghc-pkg list ghc" report it in {}'s ?
07:19:20 <Saizan> hpc: -any is what cabal prints when there's no constraint
07:19:46 <exFalso> (compiling everything again, will paste when its done)
07:21:52 <HugoDaniel> how do i merge two QExp's ?
07:22:01 <HugoDaniel> like appending one to the end of the other ?
07:22:36 <dcoutts_> HugoDaniel: since they're expressions, you have to say what you mean by appending
07:22:46 <exFalso> HugoDaniel: depends how you want to "append"
07:23:00 <exFalso> an example would be function application
07:26:39 <ChristianS> @remember <mauke> sorry, the current time is not a constant <lukish> It's a pity
07:26:39 <lambdabot> Good to know.
07:26:56 <mauke> ChristianS: you have failed
07:27:05 * ChristianS ducks
07:27:11 <ChristianS> why?
07:27:19 <mauke> @quote <mauke>
07:27:19 <MostAwesomeDude> Come to think of it, the current time isn't a pity, either.
07:27:19 <lambdabot> <mauke> says: sorry, the current time is not a constant <lukish> It's a pity
07:27:24 <hpc> @forget <mauke> sorry, the current time is not a constant <lukish> It's a pity
07:27:24 <lambdabot> Done.
07:27:41 <hpc> @remember mauke <mauke> sorry, the current time is not a constant <lukish> It's a pity
07:27:41 <lambdabot> It is forever etched in my memory.
07:27:47 <hpc> @quote mauke time
07:27:47 <lambdabot> mauke says: <mauke> sorry, the current time is not a constant <lukish> It's a pity
07:27:57 <ChristianS> hpc: thanks
07:32:17 <exFalso> reinstalling everything solved the issue as usual:)
07:32:34 <exFalso> takes me back to resintalling windows memories
07:35:58 <HugoDaniel> i dont understand what does qAddDependentFile do :/
07:36:26 * hackagebot data-cycle 0.1.2 - a cyclic doubly linked list  http://hackage.haskell.org/package/data-cycle-0.1.2 (TobiasBrandt)
07:47:29 <parcs`> HugoDaniel: it tells ghc to recompile the module if the dependent file changes
07:49:13 <HugoDaniel> just that ? doesn't it run the quasiquoter ?
07:52:03 <parcs`> not necessarily
07:53:47 <parcs`> you should probably use addDependentFile
07:54:16 <HugoDaniel> ok
08:01:27 * hackagebot atl 15409.1 - Arrow Transformer Library  http://hackage.haskell.org/package/atl-15409.1 (MatthewFarkasDyck)
08:05:47 <shergill> um what the... that's an interesting versioning scheme
08:07:05 <HugoDaniel> 15409.1 ?
08:07:37 <vodik> build number?
08:07:51 <HugoDaniel> yeah, probably
08:07:52 <HugoDaniel> :)
08:46:04 <ion> eww http://hackage.haskell.org/packages/archive/atl/15322.2/doc/html/src/Control-Arrow-Abort.html
08:46:12 <ion> That is, { eww; };
08:46:22 <rostayob> ion: ahah.
08:46:22 <lambdabot> rostayob: You have 1 new message. '/msg lambdabot @messages' to read it.
08:46:38 <monochrom> ♥
08:49:54 <rostayob> ion: btw, isn't that library kind of useless, given the existence of the "arrows" package?
08:53:05 <rostayob> how do you send messages to people via lambdabot again?
08:54:01 <ion> @tell rostayob like this
08:54:02 <lambdabot> Consider it noted.
08:54:06 <shapr> @tell rostayob oh ya!
08:54:06 <lambdabot> Consider it noted.
08:54:29 <mauke> preflex: tell rostayob or even without lambdabot!
08:54:30 <preflex>  Consider it noted.
08:55:02 <rostayob> cool.
08:55:02 <lambdabot> rostayob: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:55:03 <preflex>  rostayob: you have 1 new message. '/msg preflex messages' to read it.
08:55:05 <rostayob> oh well.
09:00:57 <fenix> hi.. is there anything like ErrorT that uses a Monoid to collect errors instead of discarding all but the last error?
09:01:31 <monochrom> WriterT
09:01:31 <rostayob> fenix: the point about ErrorT is that once you throw an error, it stops
09:01:43 <rostayob> fenix: you want a WriterT or something along those lines
09:02:01 <Twey> Precisely a WriterT, in fact
09:02:53 <fenix> I don't think WriterT is what I'm looking for: I need normal ErrorT behaviour for bind and collecting behaviour for mappend
09:02:57 <_Mikey> Hi guys,
09:03:22 <_Mikey> if I remove haskell from my machine will it remove all installed cabal packages as well?
09:03:30 <Twey> fenix: If you have ErrorT behaviour then you only ever get one error, so there's nothing to collect (because the monad stops at the first error)
09:03:38 <Twey> Unless I'm misunderstanding you
09:03:42 <rostayob> fenix: how do you collect errors if after throwing the first one computation stops?
09:04:34 <fenix> Left ["error1"] `mplus` Left ["error2"] should yield Left ["error1", "error2"]
09:04:52 <fenix> and not Left ["error2"]
09:05:21 <fenix> I want to keep errors during backtracking
09:05:24 <rostayob> fenix: what does a Left ["error1"] `mplus` Right 1 `mplus` Left ["error2"] returns?
09:05:42 <fenix> that will return Right 1
09:05:48 <fenix> which is fine for me
09:06:00 <rostayob> so you don't want an ErrorT behaviour
09:06:04 <rostayob> you want a writer
09:06:09 <rwbarton> he's talking about mplus, not (>>=)
09:06:17 <rostayob> ah right
09:06:22 <fenix> y
09:06:22 <monochrom> this is not well thought out
09:06:30 <fenix> I've implemented what I need...
09:07:32 <fenix> http://pastebin.com/JXHBezck
09:07:34 <mauke> The paste JXHBezck has been copied to http://hpaste.org/65108
09:08:18 <rostayob> fenix: as far as I can see, this is just a WriterT + a MaybeT, and some helper functions
09:16:18 <mysticc> Whats the best way to write a function to generate unique id each time .. choosing a random id still has some probability to choose same id again ..
09:16:31 * hackagebot strict-io 0.1.2 - A library wrapping standard IO modules to provide strict IO.  http://hackage.haskell.org/package/strict-io-0.1.2 (NicolasPouillard)
09:16:50 <mysticc> I also want to free a id if it is out of use so that it can be used afterwards ..
09:17:31 <mauke> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/base-4.3.1.0/Data-Unique.html
09:18:21 <scighera> !list
09:18:35 <monochrom> syntax error
09:18:46 <scighera> ciao
09:18:55 <scighera> hi
09:18:58 <mauke> scighera: you might be an idiot
09:19:09 <quidnunc> Anyone know how cabal-debian generates dependencies?
09:19:19 <rwbarton> why are they all from italy?
09:19:32 <rwbarton> or is it always the same person?
09:25:46 <sm> ack.. how do I turn off haskell-mode's converting -> etc. to unicode for terminals which don't support that ?
09:27:02 <sm> I customized haskell-font-lock-symbols to nil, with no effect. Hoping not to restart emascs
09:27:43 <quidnunc> sm: Maybe try fontify-buffer. Failing that, revert-buffer
09:28:06 <mysticc> mauke: One problem with unique is I wanted it to be Serializable .. so that I can write it on the file ..
09:28:18 <monochrom> is that even haskell-mode?
09:28:47 <rostayob> fenix: actually i was thinking about it and wait a said won't work. I'm not sure you can have that using the standard mtl library
09:30:27 <sm> phew. Answer: customize haskell-font-lock-symbols to nil then M-: (load "haskell-font-lock")
09:30:42 <sm> that took a whiel
09:30:52 <sm> on with the hacking
09:31:29 <fenix> rostayob: thank you nevertheless :)
09:31:54 <fenix> rostayob: I am currently thinking about putting the whole thing into an arrow
09:32:26 <rostayob> fenix: why an Arrow?
09:32:54 <fenix> rostayob: it kind of reminds me of arrow choice
09:33:24 <fenix> rostayob: with some kind of loop in it
09:33:40 <rostayob> fenix: well, ok, I'd need more context to understand :)
10:00:10 <_Mikey> Hi!
10:00:22 <_Mikey> how can I pull a package from code.haskell.org
10:00:31 <_Mikey> without downloading each individual file
10:00:51 <Clint> is it a darcs repo?
10:01:07 <_Mikey> I think it might be, there is a darcs folder there.
10:01:56 <Clint> then you probably want to grab it with darcs
10:10:21 <_Mikey> Clint, have you heard of darcsden?
10:12:08 <jmcarthur> _Mikey: darcsden and patch-tag are both pretty nice. it would be nice if the maintainers had a little more time to support them and if they were both a bit more popular, though
10:17:45 <_Mikey> jmcarthur, cool, I was just freaking put because I couldn't pull a repo, something about versions.. and I have the latest version of darcs as far as I know. I can get it though, so all is good.
10:18:01 <jmcarthur> ah
10:27:33 <sm> _Mikey: did you have an existing local repo from c.h.o that latest darcs could no longer pull to ?
10:30:23 <sm> should I be using mtl or transformers ?
10:33:17 <sm> seems I'm using mtl, mtl depends on transformers but seems to provide similar stuff, so maybe I should try to switch
10:34:04 <jmcarthur> sm: mtl
10:34:57 <sm> great. Why jmcarthur ?
10:35:06 <jmcarthur> sm: transformers lacks a lot of stuff, like the classes for the different effects
10:35:10 <jmcarthur> MonadReader, MonadState, etc.
10:35:18 <sm> aha, thank you
10:35:20 <jmcarthur> that's why mtl exists
10:35:42 <sm> the haddocks are trickily similar when you're looking up how to do stuff
10:36:20 <jmcarthur> in fact, the description for mtl is "Monad classes using functional dependencies, with instances for various monad transformers"
10:37:01 <petrus> 2 + 2
10:37:24 <sm> the two packages' descriptions could refer to each other and make this clearer
10:38:03 <jmcarthur> sadly, transformers refers to a couple other packages apart from mtl
10:38:28 <jmcarthur> presumably from the time that mtl was not the only commonly recommended library
10:38:59 <jmcarthur> monads-fd does at least say to use mtl
10:39:39 <jmcarthur> monads-tf isn't quite comparable since it uses type families instead of functional dependencies
10:39:49 <jmcarthur> so it doesn't have the same recommendation
10:40:41 <sm> monads-fd, monads-tf - where do they come in ?
10:40:42 <pozic> How can I tell ghcmod not to show everything which doesn't have a type-annotation in blue?
10:41:17 <pozic> I think it comes from Hlint ultimately.
10:41:35 <jmcarthur> sm: they are mostly historical now
10:42:08 <jmcarthur> sm: monads-tf might still have some use as an alternative to mtl, but since most packages use mtl you might end up having to fuss with both, depending on which ones you use
10:42:30 <jmcarthur> sm: they should have essentially the same functionality, just with slightly different ways of providing it
10:42:44 <Twey> Why are they historical now?  Were their changes merged into mtl?
10:42:58 <jmcarthur> Twey: monads-fd says itself that it's obsolete
10:43:14 <jmcarthur> Twey: monads-tf doesn't, i guess for the reasons i just stated
10:44:25 <Twey> Ah, I see
10:45:07 <sm> jmcarthur: thanks. So a basic user should focus on mtl and ignore the rest. I think I knew that once
10:45:47 <Twey> jmcarthur: But why is it obsolete?
10:46:09 <jmcarthur> sm: that's basically the idea, but it doesn't have to be a rule
10:47:15 <jmcarthur> Twey: they both have the same maintainer, and the maintainer says so ;)
10:47:27 <jmcarthur> they = monads-fd and mtl
10:47:56 <jmcarthur> i don't exactly know. i think it's just that one is maintained and the other isn't
10:48:02 <pozic> Does anyone know how to map a city name to an acceptable value for the TZ variable?
10:48:12 <jmcarthur> they were essentially the same anyway, so they were just consolidated
10:48:38 <Clint> pozic: parse zone.tab?
10:49:01 <pozic> Clint: that only helps if these places are put on some map.
10:49:08 <jmcarthur> pozic: re: ghcmod: if you enter C-c C-c, it should switch to just type checking mode instead of hlint mode
10:49:17 <pozic> Clint: I am asking whether someone has already done that.
10:49:29 <pozic> jmcarthur: how can I set that as default?
10:49:31 <jmcarthur> pozic: i don't know of a way to disable certain checks with hlint, but there might be ways
10:49:41 <pozic> jmcarthur: there is the -i (ignore flag)
10:49:43 <jmcarthur> pozic: i thought it was the default, but it's been a while since i set it up
10:49:54 <pozic> jmcarthur: naturally, the manpage is not complete.
10:50:00 <jmcarthur> naturally :(
10:50:09 <pozic> It's a really, really bad development.
10:50:48 <jmcarthur> i'm interested in chris done's emacs mode for haskell, but i really would miss a decent indentation mode
10:50:53 <pozic> One used to be able to do man command, and get the real documentation, now it is man foo => look at foo.com => click, click, click => we moved to bar.com => click, click, click => there is it.
10:51:44 <jmcarthur> heh, man should just be links (aka lynx if my intent wasn't clear)
10:52:27 <pozic> I prefer a fully integrated IDE.
10:53:54 <pozic> The feature I was looking for is built-in to Gnome.
10:54:13 <pozic> I wonder if they built a library out of it. It is kind of useful.
10:56:07 <sm> +1 for man pages, note pandoc can make them out of markdown now
11:06:31 <jmcarthur> man, this pipes-core library looks awesome
11:06:58 <jmcarthur> i hadn't read up on pipes before this so i may just be late to the party
11:08:48 <jmcarthur> ah but this is discouraging http://www.reddit.com/r/haskell/comments/qq5p6/pipescore_001_released/c3zlpci
11:09:45 <jmcarthur> i'll wait for the flames to settle down a bit
11:13:18 <fenix> hmmm the Error + Monoid problem really sucks.
11:15:18 <MostAwesomeDude> Hm. Is Haskore worth learning for music? Is there anything better/newer?
11:19:47 <jmcarthur> fenix: Error + Monoid problem?
11:22:12 <gentleben> great, more streaming io libraries
11:22:57 <jmcarthur> gentleben: without them, we wouldn't even exploring the design space
11:23:37 <gentleben> jmcarthur: other than conduit i have not seen any good explanations of what problems they are trying to solve that enumerator did not
11:25:55 <jmcarthur> i think the main problem i have with all of them so far is the lack of a simple model
11:26:18 <gentleben> jmcarthur: what do you mean?
11:27:04 <jmcarthur> they don't really have a nailed down semantics
11:27:16 <jmcarthur> they are defined by whatever utility functions were convenient when they were written
11:27:25 <Cody_> > let positions x xs = [ i | (x', i) <- zip xs [0..length xs - 1], x == x'] in positions 1 [1,2,1,2,0,1]
11:27:26 <lambdabot>   [0,2,5]
11:28:26 <Cody_> Does haskell check the next successive tuple in the above?
11:29:15 <fenix> jmcarthur: Error + Monoid problem = Left ["foo"] `mplus` Left ["bar"] = Left ["bar"] vs Left ["foo"] `mplus` Left ["bar"] = Left ["foo", "bar"]
11:30:50 <nand`> > let positions x xs = map fst . filter ((==) x . snd) . zip [0..] in positions 1 [1,2,1,2,0,1]
11:30:51 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [a])
11:30:51 <lambdabot>    arising from a use ...
11:30:54 <nand`> hmm
11:31:00 <nand`> > let positions x = map fst . filter ((==) x . snd) . zip [0..] in positions 1 [1,2,1,2,0,1]
11:31:01 <gentleben> jmcarthur: enumerator was fine with me. We have only upgraded code to conduit that touched upgraded libs
11:31:02 <lambdabot>   [0,2,5]
11:31:26 <jmcarthur> fenix: ah, MonadPlus forms a Monoid by simply interpreting Left and Right as booleans with the or operation rather than considering the full structure of the value in Left?
11:31:45 <fenix> jmcathur: yes
11:31:53 <fenix> jmcarthur: yes
11:31:55 <jmcarthur> fenix: you could always just write your own newtype wrapper with the semantics it sounds like you want
11:32:15 <jmcarthur> hmm
11:32:23 <jmcarthur> i'm wondering if that would actually form a monoid...
11:32:58 <jmcarthur> i think it would
11:33:12 <fenix> I can write it.. but it adds so much overhead
11:33:23 <jmcarthur> syntactic overhead you mean?
11:33:34 <jmcarthur> it shouldn't add that much, really
11:33:40 <jmcarthur> if you instantiate the right classes
11:33:50 <fenix> yes.. all the instances for Transformers etc.
11:34:10 <jmcarthur> it's boilerplate, but it only needs to be written once
11:34:39 <fenix> maybe it would be a nice addition to mtl
11:37:51 <fenix> but I wonder.. instance (MonadPlus m, Error e) => Error (m e) where noMsg = mzero; strMsg = return . strMsg
11:37:54 <jmcarthur> assuming that it actually obeys the laws as we expect, i think this would actually be a better default than the current one. the current one's semantics can basically be recovered by wrapping the left value in Last
11:38:12 <jmcarthur> s/better/more general/
11:39:23 <fenix> it could break things
11:39:51 <jmcarthur> yeah
11:40:17 <fenix> hmmm....
11:40:17 <jmcarthur> Either String a would be changed, for example
11:40:45 <jmcarthur> err
11:40:52 <jmcarthur> ErrorT instead of Either
11:41:23 <jmcarthur> i'm still in the old world where Either had the less general Monad instance, i guess
11:42:18 <fenix> it seems rather arbitrary anyways...
11:42:26 <fenix> the same could be done for Right
11:42:26 <rwbarton> fenix: can't you generalized newtype derive any instance you need other than your new MonadPlus instance?
11:45:51 <FooBarWidget> I've just installed Haskell on Linux by downloading the binary distribution linked from haskell.org, and installing the haskell platform. however it would appear the 'base' package is stuck at version 3.0, but I need version >= 4.5 so I can install git-annex. how do I upgrade the 'base' package?
11:46:04 <FooBarWidget> $ ghc --version
11:46:04 <FooBarWidget> The Glorious Glasgow Haskell Compilation System, version 7.0.4
11:47:43 <rwbarton> if you need base-4.5, then you need ghc-7.4, which doesn't have a corresponding haskell platform yet
11:47:53 <fenix> generalized newtype derive: rocks!
11:48:46 <rwbarton> but I'm a bit confused because ghc-7.0.4 doesn't come with base-3, afaik, but rather base-4.3
11:48:49 <FooBarWidget> what is the haskell platform anyway?
11:49:07 <FooBarWidget> isn't it just ghc + some libraries?
11:49:24 <rwbarton> pretty much, yes
11:49:37 <FooBarWidget> then how come ghc 7.4 doesn't have a haskell platform?
11:50:54 <FooBarWidget> and what happens if I install ghc 7.4, then install haskell-platform 2011.4? will it downgrade ghc?
11:51:26 <FooBarWidget> where do I find ghc 7.4? it doesn't seem to be linked from haskell.org.
11:52:01 <rwbarton> http://www.haskell.org/ghc/
11:52:55 <FooBarWidget> what is included in the haskell platform that's not in 'stock' ghc?
11:53:19 <FooBarWidget> it appears that installing ghc already installs cabal, which I presume can be used to install any haskell library, so what is the haskell platform for?
11:53:32 <FooBarWidget> and why is it so out of date with ghc?
11:53:34 <rwbarton> I've never personally installed the haskell platform so I'm not 100% sure.
11:53:54 <c_wraith> FooBarWidget: cabal-install (the cabal executable) does not come with stock ghc.
11:53:57 <FooBarWidget> the haskell platform is linked from the "Download" button on www.haskell.org so it seems pretty important to me
11:53:59 <dcoutts_> FooBarWidget: it's like the difference between the kernel/gcc and a linux distro
11:54:34 <dcoutts_> FooBarWidget: gcc releases are not synchronised with say debian releases, similarly ghc releases are not synchronised with Haskell Platform releases
11:55:03 <FooBarWidget> hm. oh well I'll try upgrading my ghc to 7.4 although I've already installed haskell-platform. hope everything goes well
11:55:23 <dcoutts_> this is a good thing, it means ghc devs don't have to fix everything before a release, and it gives us time to sort things out before a platform release
11:55:47 <c_wraith> FooBarWidget: also, ghc 7.2.* was never intended for production use, and 7.4.1 is new enough that it still has some strange bugs.  7.0 is still the stable series for production stuff
11:55:50 <FooBarWidget> yeah but it's not every convenient for users that the haskell platform is so out of date
11:55:59 <rwbarton> don't think of it that way
11:56:06 <dcoutts_> FooBarWidget: unless you particularly need 7.4, there's no need to upgrade now now now
11:56:09 <rwbarton> instead, you get the latest ghc from the future ahead of time!
11:56:15 <FooBarWidget> git-annex insists on base >= 4.5
11:56:30 <FooBarWidget> I don't have a choice
11:56:38 <c_wraith> use an older version
11:56:40 <c_wraith> that's a choice
11:56:51 <FooBarWidget> older versions have more bugs
11:57:02 <c_wraith> like working
11:57:04 <FooBarWidget> I don't want to lose my documents
11:57:55 <c_wraith> you only have to go back one version
11:57:59 <dcoutts_> FooBarWidget: so it's a tradeoff, you choose if you want to use the stable set of tools, or the bleeding edge
11:58:10 <c_wraith> it looks like the current release of git-annex is just a compatibility release
11:59:04 <c_wraith> ghc 7.4 has a bunch of changes that require minor fixups in most stuff.  Mostly the changes to base.
11:59:28 <c_wraith> I think the newest version of git-annex is *just* to be compatible with those changes
11:59:51 <dcoutts_> and not all package authors can be bothered to make their latest version work with both latest and stable versions of ghc
12:00:59 <c_wraith> honestly, it's a fair amount of work to be compatible with different versions of base, sometimes
12:01:09 <FooBarWidget> base changes that quickly?
12:01:30 <c_wraith> at times it does.  GHC doesn't like to stand still.
12:01:33 <FooBarWidget> going back one version of git-annex gives me this error:
12:01:35 <FooBarWidget> ghc -O2 -Wall -ignore-package monads-fd --make configure
12:01:35 <FooBarWidget> Utility/StatFS.hsc:54:8:
12:01:36 <FooBarWidget>     Could not find module `GHC.Foreign':
12:01:36 <FooBarWidget>       Use -v to see a list of the files searched for
12:01:47 <c_wraith> how did you install ghc?
12:01:48 <FooBarWidget> Building git-annex-3.20120230...
12:01:48 <FooBarWidget> Git/Version.hs:11:18:
12:01:48 <FooBarWidget>     Could not find module `Build.SysConfig':
12:01:48 <FooBarWidget>       Use -v to see a list of the files searched for.
12:02:14 <FooBarWidget> this is on my mac which has ghc 7.0. I'm upgrading to ghc 7.4 on linux
12:02:30 <FooBarWidget> it was installed through www.haskell.org -> Download -> OS X -> Haskell Platform for OS X
12:02:46 <c_wraith> still, given that base was willing to break Num, I'm surprised they aren't willing to redo the Functor/Applicative/Monad stuff
12:03:10 <c_wraith> That would barely break more existing code than the change to Num did
12:03:53 <Clint> suggest it
12:04:02 <c_wraith> It's been suggested hundreds of times
12:05:30 <FooBarWidget> so what is this error? what does it mean?
12:05:47 <FooBarWidget> and what do I do about this?
12:07:24 <Clint> too bad you can't do apt-get install git-annex on mac
12:07:59 <FooBarWidget> I can't do it on linux either. I'm on ubuntu 10.04 LTS and it only has ghc 6
12:08:40 <FooBarWidget> speaking of which, git-annex fails to install on linux with ghc 7.4 too because Crypto-4.2.4 fails to install:
12:08:48 <FooBarWidget> Building Crypto-4.2.4...
12:08:48 <FooBarWidget> [ 1 of 26] Compiling Data.Digest.SHA2 ( Data/Digest/SHA2.hs, dist/build/Data/Digest/SHA2.o )
12:08:48 <FooBarWidget> Data/Digest/SHA2.hs:111:4:
12:08:49 <FooBarWidget>     Could not deduce (Show a) arising from a use of `showHex'
12:08:49 <FooBarWidget>     from the context (Integral a)
12:08:49 <FooBarWidget>       bound by the instance declaration at Data/Digest/SHA2.hs:109:10-39
12:09:42 <dfletcher> > (concat . take 16 . repeat . show) (0/0) ++ " Batman!"
12:09:43 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!"
12:09:47 <dfletcher> yay :)
12:09:54 * dfletcher learning
12:09:59 <Clint> FooBarWidget: http://freshdirect.chtah.com/a/tBPWjqWB7S$bRB8hR-wMpGEqpx1/hosted?t=BPWjqWB7S$bRB8hR-wMpGEqpx1&email=freshdirect@b.scru.org
12:10:03 <Clint> er
12:10:05 <Clint> sorry
12:10:08 <Clint> FooBarWidget: http://anonscm.debian.org/darcs/pkg-haskell/haskell-crypto/patches/class-constraints.diff
12:10:32 <FooBarWidget> I have to patch the package?
12:10:52 <Clint> or get the maintainer to release a fixed version to hackage
12:11:39 <FooBarWidget> I just want to install git-annex and get it working as quickly as possible. I'm not a haskell programmer. am I supposed to locate SHA2.hs on my filesystem and re-run cabal-install Crypto-4.2.4?
12:12:40 <Clint> you're going to have to make some choices
12:12:46 <FooBarWidget> what are my choices?
12:13:31 <Clint> use older git-annex, do the integration work, or use newer operating system
12:13:56 <FooBarWidget> older git-annex doesn't work either. I get that Build.SysConfig error
12:14:09 <FooBarWidget> newer ubuntu distro is not compatible with my hardware and has bugs
12:14:26 <Cody_> How do I throw an error message, specifically in a case statement?
12:16:24 <Clint> FooBarWidget: try installing the git-annex from natty
12:18:09 <JoeyA> Cody_: The simplest way is 'error'
12:18:15 <JoeyA> :t error
12:18:16 <lambdabot> forall a. [Char] -> a
12:18:47 <JoeyA> When evaluated, error "blah" will throw an exception saying "blah".  This is what 'head' uses to fail, for example.
12:18:50 <JoeyA> > head []
12:18:50 <lambdabot>   *Exception: Prelude.head: empty list
12:18:55 <JoeyA> (I think)
12:19:28 <nomeata> @src head
12:19:28 <lambdabot> head (x:_) = x
12:19:28 <lambdabot> head []    = undefined
12:19:55 <JoeyA> But avoid using this for run-time errors that are likely to occur (e.g. file not found).
12:20:13 <Cody_> JoeyA: Any way that I can add a description as to why?
12:20:14 <ion> cody: Remember that using error is the last resort.
12:20:28 <Cody_> ion: I been returning -1 lately
12:20:55 * JoeyA waits for someone to say "ugh"
12:21:22 <JoeyA> Haskell has a rich language of types that can keep you from having to do that sort of thing.
12:21:44 <JoeyA> If it's an IO action that will either fail or succeed, you can have it return a bool (i.e. IO Bool)
12:21:45 <jmcarthur> error is a perfectly fine way to define partial functions if you're the type of person that likes partial functions, but i don't count myself among such people
12:22:10 <JoeyA> Though it's usually better to throw an exception in IO using, say, throwIO.  Or, if you're lazy, use the fail function.
12:22:27 <JoeyA> (well, more convenient, not necessarily "better")
12:22:41 <jmcarthur> more general
12:22:45 <jmcarthur> err
12:22:51 <jmcarthur> actually, they are completely different
12:22:58 <JoeyA> Cody_: There's also the 'Maybe' type.
12:23:18 <jmcarthur> fail works in any monad, but in IO only throws a certain type of exception. throwIO only works in IO but can throw any kind of exception
12:23:24 <JoeyA> e.g. getRecord :: Record r => Connection -> Id r -> IO (Maybe r)
12:23:27 <Cody_> JoeyA: Its not dealing with IO, just want to throw an error message if two vectors are not of the same size
12:23:36 <jmcarthur> and when i say fail works in any monad, i mean fail sort of works in most haskell monads
12:23:43 <Cody_> ok
12:23:53 <JoeyA> Cody_: Sounds like 'error' would be a good choice.
12:24:03 <jmcarthur> Cody_: i would use Either or Maybe or something, i think
12:24:07 <JoeyA> Assuming it is an error condition for the vectors to be the wrong size.
12:24:18 <jmcarthur> well yeah, if it's well-documented then error might be okay
12:24:29 <mmaruseacph2> does anyone know if haskell-platform is broken on Arch?
12:24:36 <jmcarthur> like... if it's *programmer error* to violate that condition
12:25:04 <jmcarthur> mmaruseacph2: i wouldn't be surprised since ghc 7.4 is in the main arch repos now
12:25:14 <jmcarthur> i doubt the platform package is updated yet
12:25:28 <lukish> How can I suppress\remove the string entered to getLine, after press <enter>?
12:25:29 <JoeyA> To be honest, I haven't spent a lot of effort making my programs handle errors really well.  I just log the heck out of stuff.  That's an area I could strive to be better at.
12:25:52 <jmcarthur> JoeyA: there's almost no excuse since monads make error handling so convenient and general
12:26:06 <jmcarthur> even when using different kinds of errors
12:26:16 <mmaruseacph2> jmcarthur, so, I will have to install each packet manually, right?
12:26:17 <jmcarthur> sometimes not so convenient, admittedly
12:26:23 <mmaruseacph2> either via pacman or cabal?
12:26:33 <JoeyA> lukish: What do you mean?
12:26:35 <jmcarthur> mmaruseacph2: dunno. i don't use the platform explicitly
12:26:37 <JoeyA> As in, hide it from the command line?
12:26:38 <Cody_> JoeyA: When trying to find the scalar product it is. I would like to be able to send an error such as "error: not compatible" rather than all the stuff Haskell throws at you.
12:26:45 <lukish> JoeyA: yes
12:26:47 <mmaruseacph2> thanks, will try this for now :)
12:26:55 <JoeyA> lukish: Are you writing a password prompt?
12:27:04 <lukish> No
12:27:09 <Cody_> JoeyA: but 'error' is fine
12:27:15 <fenix> in theory... "error "foo"" erros should not occour at all
12:27:33 <lukish> It should be hide after pressing <enter>
12:27:45 <JoeyA> lukish: http://www.termsys.demon.co.uk/vtansi.htm
12:27:54 <fenix> the typechecker should prevent the programmer from violating invariants
12:28:01 <JoeyA> putStrLn "\r\ESC[K"
12:28:05 <JoeyA> err
12:28:16 <JoeyA> that will only clear the current line.  You'll need to go up a line, since the user hit enter.
12:28:50 <ben> What if he pressed enter twice since your program got a chance to process terminal input
12:28:53 <JoeyA> lukish: To use the page I posted in Haskell, substitute <ESC> with the "\ESC" escape sequence.
12:29:01 <ben> what if he typed in some obscure other terminal formatting codes
12:29:09 <ben> what if the line wrapped around
12:29:16 <JoeyA> So for Erase End of Line	<ESC>[K , do putStr "\ESC[K"
12:29:35 <JoeyA> Be sure to hFlush stdout if you aren't writing a full line.
12:29:37 <jmcarthur> you could just temporarily disable echoing in the terminal
12:29:51 <jmcarthur> oh, you want it to show and then disappear...
12:30:03 <jmcarthur> i would still just disable echoing and then explicitly print what i want to show
12:30:13 <jmcarthur> and then re-enable echoing after the user hits enter
12:30:21 <JoeyA> How do you disable echoing?
12:30:26 <jmcarthur> i forget :
12:30:28 <jmcarthur> :
12:30:31 <jmcarthur> gah
12:30:40 <jmcarthur> it was supposed to be a smiley, but i give up
12:30:44 <JoeyA> lol
12:30:52 <JoeyA> I guess you're not happy, anymore.
12:31:40 * hackagebot atl 15409.2 - Arrow Transformer Library  http://hackage.haskell.org/package/atl-15409.2 (MatthewFarkasDyck)
12:31:57 <fenix> arrow transformers?! :D
12:32:15 <fenix> I get a headache from just thinking about it :D
12:32:20 <JoeyA> hSetEcho
12:32:34 <lukish> JoeyA: what about getLine
12:32:34 <lukish> ?
12:32:37 <jmcarthur> arrow transformers aren't so bad
12:32:54 <jmcarthur> arrows are simpler than monads, really
12:33:00 <JoeyA> lukish: Do you want the line to show as the user is typing it?
12:33:03 <jmcarthur> they just aren't as pretty syntactically
12:33:08 <lukish> JoeyA: q <- getLine >> putStrLn "\ESC[K" now works
12:33:19 <lukish> yes, I di
12:33:21 <lukish> do
12:33:30 <lukish> And then It should dissapear
12:33:36 <JoeyA> Hmm, I'm not sure why that would work.  The cursor is on the next line when the user hits enter, I would think.
12:33:37 <ChristianS> atl-15409.2 -- strange versioning scheme...
12:34:41 <JoeyA> getLine >> putStrLn "\ESC[A\r\ESC[K"
12:34:44 <lukish> h <- getLine >> putStrLn "\ESC[2A"
12:35:13 <JoeyA> \ESC[A moves up a line, \r moves to beginning of line (it's a carriage return), and \ESC[K clears to end of line.
12:35:17 <fenix> jmcarthur: I like arrows.. but thinking about arrow transformers is mindmelting ;)
12:36:45 <JoeyA> getLine >> putStrLn "\ESC[A\r\ESC[KPoof, it's gone"
12:37:25 <jmcarthur> i like arrow transformers...
12:37:44 <jmcarthur> they aren't useful very often, but when they are they are quite welcome
12:38:03 <jmcarthur> i've used them as a design tool before (ended up inlining them though)
12:39:12 <ion> Btw, never generate escape ^[[ codes manually.
12:39:26 <ion> They vary across terminals and that’s what terminfo’s supposed to handle.
12:39:43 <fenix> I am still thinking about Error...........
12:39:48 <lukish> client nick h = forkIO (forever $ hGetLine h »= (λtext → printMessage (Message nick (Text text)))) >> (forever $ getLine >>= hPutStrLn h . packMessage >> putStrLn "\ESC[2A")
12:39:55 <JoeyA> Is http://hackage.haskell.org/package/terminfo a good library for that sort of thing?
12:39:57 <lukish> How can I split it to 2 parts?
12:39:58 <ben> a lot of people spend a lot of time thinking about errors
12:40:03 <ben> and a lot less time than that agreeing about them
12:40:29 <fenix> and I just came up with something
12:40:50 <ion> joeya: Probably, i haven’t had the need to try it yet.
12:41:06 <lukish> forkIO (io1) >> (io2) - I want it like = forkDo \n io1 \n io2
12:41:15 <lukish> Is there some analogues?
12:41:28 <ion> joeya: trifecta seems to use it, so at least edwardk seems to find it good enough. :-)
12:41:36 <JoeyA> forkIO $ do {launchMissiles; putStrLn "Nuclear launch detected."}
12:41:43 <edwardk> ion: which?
12:41:46 <JoeyA> (you don't need the braces if you use whitespace)
12:41:50 <ion> http://hackage.haskell.org/package/terminfo
12:41:58 <fenix> using the current semantic: Left e1 `mplus` Left e2 = Left e2 seems to imply: instance (Error e) => Monoid e where mempty = noMsg; mappend x y = y
12:42:02 <edwardk> i don't really like terminfo as a library but its the best tool i have
12:42:25 <JoeyA> lukish: I assume you want to perform multiple actions in the forked thread in sequence, correct?
12:42:30 <fenix> which is an akward assumption!
12:42:42 <ion> It must at least be better than manually hardcoding sequences that happen to work on the author’s terminal. :-)
12:43:19 <lukish> JoeyA: well, I want to break that line in 2 actually
12:43:27 <lukish> Without any meaning modifies
12:43:37 <lukish> It works well
12:43:55 <lukish> But unfortunately unreadable
12:44:08 <danharaj> sometimes I wish tuple types were defined with an infix type operator
12:46:09 <fenix> ErrorList.... Workaround so that we can have a Haskell 98 instance Error String.
12:46:32 <fenix> this is so BROKEN
12:47:13 <lukish> JoeyA:  forkIO $ do doesn't work
12:47:21 <lukish>  Couldn't match expected type `()'
12:47:21 <lukish>                 with actual type `GHC.Conc.Sync.ThreadId'
12:47:21 <lukish>     Expected type: IO ()
12:47:21 <lukish>       Actual type: IO GHC.Conc.Sync.ThreadId
12:47:38 <JoeyA> lukish: That's because forkIO returns a ThreadId value.
12:48:01 <JoeyA> The return value of the last statement in a do block is the return value of the block as a whole.
12:48:17 <JoeyA> To discard the ThreadId and return (), you'll need to do:
12:48:21 <JoeyA> _ <- forkIO $ do
12:48:23 <JoeyA>     ...
12:48:24 <JoeyA> return ()
12:49:00 <JoeyA> You could say just forkIO $ do and it will still compile, but it will produce a warning if you compile with -Wall.
12:49:32 * hpc thinks -Wall is noisy in any language
12:49:34 <fenix> even noMsg is somewhat broken by design.. they should have used a semigroup for that
12:50:11 <JoeyA> -Wall saved me from a bug today.  It said "unused variable 'f'"
12:50:24 <JoeyA> The code was x <- readIORef ref; writeIORef ref $! x
12:50:30 <JoeyA> I meant to apply f to x.
12:51:03 <andares> there's no way you could derive Functor, could you?
12:51:31 <c_wraith> andares: ghc 6.12+ has an extension for deriving functor for any Algebraic data type
12:52:01 <andares> c_wraith: what sorts of things are algebraic data types?
12:52:10 <c_wraith> andares: after all, there's only one correct implementation of functor for (non-generalized) algebraic data types with the correct kind
12:52:41 <c_wraith> andares: anything that's not a generalized algebraic data type.  that is, anything defined with data, without the GADTs extension
12:53:52 <andares> c_wraith: and for any abstract data type, there can only be one definition of fmap that satisfies fmap (f . g) = (fmap f) . (fmap g)?
12:54:05 * andares hopes he remembered the functorial law correctly.
12:54:09 <c_wraith> yes
12:54:11 <c_wraith> and you did
12:54:34 <andares> yay.
12:54:51 <andares> it seems almost like the concept of linearity, like linear maps.
12:54:51 <lukish> JoeyA: http://hpaste.org/65117     The last statement in a 'do' construct must be an expression:
12:54:54 <lukish>     _ <- forkIO
12:55:16 <c_wraith> andares: the extension in GHC 6.12+ is DeriveFunctor
12:55:26 <andares> cool. :)
12:55:31 <c_wraith> andares: it will work with any type that's a Haskell98 type.
12:55:47 <jmcarthur> "for any abstract data type, there can only be one definition of fmap that satisfies fmap (f . g) = (fmap f) . (fmap g)?"  <-- this is not true. sometimes there isn't one at all
12:55:51 <JoeyA> lukish: Looks right to me.  Do you have tabs in there?  That might be messing up the indentation.
12:55:54 <andares> I think for now I should write them by hand myself though. I started learning a couple days ago so I'm still pretty behind.
12:56:08 <jmcarthur> even when it has the right kind
12:56:08 <JoeyA> Protip: Don't use tabs in Haskell.
12:56:17 <lukish> I use apces
12:56:20 <lukish> spaces*
12:56:26 <c_wraith> well, ok.  There are 0 or 1 correct implementations of Functor
12:56:40 <jmcarthur> it won't work for this, for example:   data Foo a = Foo (a -> Int)
12:58:40 <lukish> JoeyA: is that `do _ ← forkIO $ do ` right?
12:59:49 <andares> jmcarthur: fmap (a->b) foo where foo :: Foo a would return a Foo ((a->b) a) -> Int, right?
12:59:57 <andares> where (a->b) is a function that takes a to b.
13:00:05 <andares> *something of type a to something of type b.
13:00:17 <JoeyA> lukish: Yes.  I can't figure out what's wrong with it, so I'm trying to compile it.
13:00:30 <JoeyA> (I'm not sure what hodgepodge of GHC extensions I need to parse that Unicode)
13:00:57 <Enigmagic> {-# LANGUAGE SmellyUnicodeTaint #-} :-)
13:01:10 <JoeyA> {-# LANGUAGE UnicodeSyntax #-} doesn't work
13:01:11 * Enigmagic ducks
13:01:55 <JoeyA> It's not liking » for some reason.
13:02:10 <lukish> Oh
13:02:12 <lukish> My fault
13:02:30 <lukish> It needs one more space in 2nd line
13:04:12 <c_wraith> Huh.  I just worked out the Functor instance for « data X a = X ((a -> Int) -> Int) » by hand. That is... kind of odd.
13:04:35 <lukish> JoeyA: well, that return () breaks forever loop
13:04:39 <chrisdone> http://hackage.haskell.org/packages/archive/haskell-src-exts/1.11.1/doc/html/Language-Haskell-Exts-Syntax.html#g:7
13:04:39 <chrisdone> TyForall (Maybe [TyVarBind]) Context Type — qualified type
13:04:39 <chrisdone> is this a typo, should be quantified type? never heard 'qualified type' for forall
13:04:39 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:04:56 <fenix> c_wraith: your functor is a continuation monad
13:05:39 <andares> what's a continuation monad?
13:06:03 <chrisdone> @tell ivanm you're better sending me an email than irc to get a response. anyway it's on hs-config.el
13:06:03 <lambdabot> Consider it noted.
13:06:07 <fenix> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Cont.html#t:Cont
13:06:22 <JoeyA> andares: I'd tell you, but you didn't give me a 'k' to pass the answer to.
13:06:37 <andares> I… what?
13:06:55 * andares uses the Hubble space telescope to observe the joke going over his head.
13:07:00 <tgeeky> yeah
13:07:05 <JoeyA> lol
13:07:19 <JoeyA> lukish: return in Haskell is not like return in most other languages.
13:07:23 <tgeeky> also, very rare that joke about not getting joke >>>> original joke
13:07:30 <JoeyA> In C, return short-circuits the rest of the function.
13:07:40 <lukish> Yeah, I know
13:07:42 <JoeyA> In Haskell, return () has no effects.
13:07:55 <lukish> Return is INJESHUN actually
13:07:55 <JoeyA> What's probably happening is that your main thread is finishing.
13:08:07 <andares> lukish: return is just what pure is called in monads.
13:08:13 <JoeyA> When the main thread of a Haskell program finishes, the program stops, regardless of what the other threads were doing.
13:08:14 <fenix> in soviet russia haskell returns you
13:08:20 <tgeeky> JoeyA: it has the effect of consuming a sideways hamburger ()
13:08:41 <JoeyA> lukish: Run one of those loops in the main thread, and it should work.
13:08:43 <jmcarthur> andares: fmap (f :: a -> b) (foo :: Foo a) :: Foo b, but you can't define an fmap that would work
13:09:19 <jmcarthur> andares: since you'd have to be able to write something like this:   fmap :: (a -> b) -> (a -> Int) -> b -> Int
13:09:25 <jmcarthur> @djinn (a -> b) -> (a -> Int) -> b -> Int
13:09:26 <lambdabot> Error: Undefined type Int
13:09:29 <JoeyA> If you want more of a challenge, see if you can get the worker threads to use an MVar to signal completion to the main thread (even in the event of an exception).
13:09:30 <jmcarthur> grr
13:09:34 <jmcarthur> @djinn (a -> b) -> (a -> c) -> b -> c
13:09:34 <lambdabot> -- f cannot be realized.
13:09:53 <andares> huh, I see.
13:09:54 <JoeyA> Well, *only* in the event of an exception, since the only way to terminate forever (besides terminating the program) is to throw an exception.
13:09:59 <andares> I'll have to think about it.
13:10:01 <jmcarthur> c_wraith: yeah, that's just Cont. it's a monad, not just a functor
13:10:31 <c_wraith> jmcarthur: it's hardly *just* Cont when you've never worked through it by hand before. :)
13:10:32 <jmcarthur> c_wraith: in fact, it's a monad transformer, and it doesn't even require the underlying type constructor to be a monad
13:11:02 <JoeyA> Someone should write an Acme module with a Monad instance that violates all of the monad laws.
13:11:06 <jmcarthur> newtype ContT r m a = ContT ((a -> m r) -> m r)
13:11:10 <jmcarthur> ^^ m doesn't need to be a monad
13:12:53 <fenix> gargh.. the more I think about ErrorT, the more broken it gets
13:13:52 <JoeyA> How so?
13:15:13 <fenix> noMsg from Error e is just a hack; strMsg should be read; Error e should be Monoid
13:15:26 <fenix> or if the hack is to be removed: SemiGroup
13:16:10 <fenix> and mplus of ErrorT should really combine Errors with mappend
13:16:41 <fenix> instead of doing so in secret by assuming mappend e1 e2 = e2
13:16:58 <JoeyA> Pfft, typical ivory-tower Haskell programmer attitude.  In the Real World, sum [] = NULL.
13:17:24 <JoeyA> (I'm being facetious, of course.)
13:17:37 <zerax> Can hardly blame them, the view is so good from the ivory-tower ;)
13:18:11 <fenix> sum [] = mempty ;)
13:18:48 <fenix> or even better: sum = foldl mappend mempty
13:19:01 <JoeyA> Seriously, in SQL, SELECT sum(x) FROM tbl WHERE ... returns *null* when there are no rows.
13:19:05 <c_wraith> I feel sad right now, because I'm sure djinn can solve this problem that I cannot
13:19:07 <JoeyA> rather than 0, the unit of addition.
13:19:42 <JoeyA> In PostgreSQL, array_agg (convert a result set to an array) returns null instead of an empty array.
13:19:57 <c_wraith> @djinn (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> ((b -> r) -> r)
13:19:57 <lambdabot> f a b c = b (\ d -> a (\ e -> c (e d)))
13:20:03 <c_wraith> yes, it certainly can
13:20:28 <dropdrive> Which of the many conduit/pipes packages should I look at if all I want to do is to just learn about this stuff?
13:20:53 <tgeeky> f (l)eft (c)enter (r)ight
13:21:01 <JoeyA> It makes sense to return NULL for min and max with no rows, since those don't have a unit, but sum and add...
13:21:13 <tgeeky> f l c r = c (\ d -> l (\e -> r (e d))
13:21:26 <tgeeky> much better
13:21:38 <tgeeky> except for the syntax error
13:22:01 <JoeyA> Handling the empty case in an illogical fashion creates bugs.  See, for example, a bug in the digest package: https://github.com/jkff/digest/pull/2
13:22:35 <JoeyA> zlib's crc32 function gives NULL special treatment, so you have to be really careful when dealing with empty strings.
13:22:58 <fenix> java is a single bug because of that :D
13:23:08 <JoeyA> (I should point out that the maintainer of the digest package responded to my ticket very quickly)
13:24:27 <fenix> cause in java: if (x == null) return ChooseRandom(null, throw EmptyException, 0);
13:24:53 <jmcarthur> i take back what i said earlier about enumerator/conduit/pipes/etc. looking at the original pipes by Gabriel Gonzalez, it looks very principled and simple
13:25:31 <fenix> oh and even worse: if (x == null || x.isEmpty() || x.length == 0)
13:25:37 <JoeyA> Of course, there's the boxed integer strangeness: http://stackoverflow.com/a/2021413/149391
13:26:07 <JoeyA> There was a better post on StackOverflow, but the thread it was in got deleted (and it was a really popular thread, too :( )
13:26:18 <nand`> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
13:26:21 <jmcarthur> dropdrive: since they are all so different, knowledge of one doesn't necessarily enable you to use others without another heavy learning process
13:26:21 <nand`> reminds me of this
13:26:56 <jmcarthur> i've not used pipes or conduit yet, but pipes is looking very simple
13:27:04 <jmcarthur> sadly missing error handling so far though
13:27:22 <jmcarthur> this new pipes-core package seems to support it, but the author of pipes claims it has problems
13:28:49 <fenix> in 8 ways continuatioins are missing
13:29:37 <fenix> one could do the callCC \ err -> when (wrong something) (err something)  trick, too ;)
13:30:08 <fenix> *continuations
13:38:20 <dfletcher> > ((++" Batman!") . take 48 . cycle . show) (0/0)
13:38:21 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!"
13:38:33 <tgeeky> giggles
13:39:14 <JoeyA> @quote dfletcher > ((++" Batman!") . take 48 . cycle . show) (0/0)
13:39:14 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
13:39:19 <JoeyA> @remember dfletcher > ((++" Batman!") . take 48 . cycle . show) (0/0)
13:39:20 <lambdabot> I will remember.
13:39:24 <JoeyA> @quote batman
13:39:25 <lambdabot> dfletcher says: > ((++" Batman!") . take 48 . cycle . show) (0/0)
13:39:40 <tgeeky> for want of a newline
13:40:50 <dfletcher> :) someone showed me some js that did it this morning and I've been on a mission :P
13:41:02 <dfletcher> first day of haskell, not too bad eh? =)
13:41:41 <ion> I liked the earlier one more.
13:42:12 <fenix> dletcher: best program ever :D
13:42:25 <fenix> dfletcher: best program ever :D
13:42:36 <dfletcher> :)
13:47:07 <fenix> anyone remembering basic?
13:47:14 <fenix> "on error resume next"
13:49:29 <fenix> (([Stamement], Environment) -> Environment) -> ((Statement, Environment) -> Environment) -> ([Statement], Environment) -> Environment :D
13:49:40 <zerax> fenix, You don't even have to go that far back, ASP 3.0 still had it.
13:49:47 <fenix> If I had known that back in the day... :D
13:51:59 <jmcarthur> :t repeat
13:52:00 <lambdabot> forall a. a -> [a]
13:52:14 <jmcarthur> oh, not what i was really wanting after all
13:52:24 <fenix> one could even think of it as onErrorResumeNext :: (ArrowChoice a) => a c d -> a b (Either c d) -> a b d; onErrorResumeNext next current = current >>> left next
13:53:41 <fenix> argh type error
13:54:25 <fenix> onErrorResumeNext next current = current >>> (next ||| returnA)
13:54:26 <fenix> ;)
13:56:11 * BMeph prefers: "> ((++"! Batman!") . take 47 . cycle . show) (0/0)"
13:57:19 <dfletcher> heh BMeph thought about that after I pasted it. end in "a" :)
13:58:21 <td123> BMeph: did you get it from https://www.destroyallsoftware.com/talks/wat ?
13:58:37 <dfletcher> actually someone pasted the original from there to me
13:58:43 <dfletcher> been on a haskell mission ever since :P
13:59:01 <dfletcher> it's still longer than the js version
13:59:19 <dfletcher> new Array(16).join("wat"-1) + " Batman!";
14:01:26 <BMeph> td123: Never heard of it.
14:01:59 <DanBurton> take 47 seems rather arbitrary
14:03:05 <dfletcher> well once I switched to cycle take is taking Char s so the original was 48 which is 16*3 (len of "NaN" x 16)
14:03:33 <dfletcher> 47 just chops off the last N so it sounds more like the silly song :P
14:04:11 <Enigmagic> dfletcher: this is the same length as the js:
14:04:13 <Enigmagic> > take 48 (fix (show (0/0)++)) ++ " Batman!"
14:04:14 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!"
14:04:24 <dfletcher> nice :)
14:04:28 <fenix> foldr (const $ (++) (show (0/0))) " Batman!" [0..47]
14:05:02 <dfletcher> hmm fix new one for me
14:05:59 <Enigmagic> can be useful for code golf
14:06:35 <jmcarthur> > join(replicate 16.show$0/0)++" Batman!"
14:06:37 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!"
14:07:17 <dfletcher> jmcarthur wins the terseness award =)
14:07:34 * BMeph loves fix's definition... :)
14:07:43 <Enigmagic> dfletcher: mine is still shorter if you remove whitespace :P
14:08:17 <jmcarthur> of course, since we are using 0/0 instead of "wat"-1, we almost might as well just say "NaN"
14:08:25 <shachaf> > join(replicate 16"NaN")++" Batman!" -- are we golfing here?
14:08:26 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN Batman!"
14:08:38 <shachaf> Right, what jmcarthur says.
14:08:57 <jmcarthur> the output and input are the same lengths now
14:08:58 <dfletcher> yeah but the original has NaN -> String trick
14:09:10 <jmcarthur> the fact that we don't have that is a good thing
14:09:17 <jmcarthur> it just makes the challenge less interesting
14:10:26 <jmcarthur> woops, i was misreading my ghci session. the input is of course much shorter than the output
14:11:44 <brisingr> ahh what did I miss
14:12:06 <brisingr> fix, NaN, Batman and golfing
14:12:22 * DanBurton found himself writing fix in Python today :)
14:12:57 <sm> hey all: I'm doing (errs, results) <- partitionEithers `fmap` mapM trySomeIOParser parsers, and expecting to access errs and results lazily, but I think it always tries all parsers. Does mapM force that ?
14:13:21 <Clint> @pl \z -> (\x y -> [x,y]) <$> z <*> z
14:13:22 <lambdabot> (( :) . return <$>) . ( z <*>) . 
14:13:30 <Clint> wtf is that
14:13:43 <brisingr> Â?
14:13:47 <byorgey> sm: the IO monad forces that.
14:13:52 <DanBurton> It's A-hat, obviously...?
14:13:52 <Clint> brisingr: yes
14:13:56 <brisingr> âââââ :(
14:14:04 <sm> thanks, I see
14:14:37 <byorgey> sm: mapM results in an IO actions which results in an [Either a b] list; the IO effects won't be interleaved with the lazy production of the result
14:14:53 <byorgey> sm: *unless* you use unsafeInterleaveIO, though I don't understand in what situations you can/should use that.
14:15:11 <brisingr> Clint: I have no idea whatsoever.
14:19:54 <mauke> !ops#perl whom will this highlight?
14:20:59 <fenix> (concatMap ( show . uncurry (/)) $ (<*>) =<< ((,) <$>) $ replicate 7 0.0)  ++ " Batman!"
14:21:49 <dfletcher> whats that the most obfuscated version? ;)
14:22:18 <fenix> almost :D
14:22:44 <DanBurton> new idea for lambdabot command: @obfuscate
14:22:57 <dfletcher> hmm UNcurry? I want an actual curry!
14:22:57 <dylukes_> We already have it.
14:23:00 <dylukes_> It's called @pl.
14:23:01 <DanBurton> although 80% of the time this is equivalent to @pl
14:23:02 <brisingr> DanBurton: can't you just pl unpl
14:23:05 * dfletcher goes for some indian food
14:23:48 <dylukes> @unpl (\x -> x + 1)
14:23:49 <lambdabot> (\ x -> x + 1)
14:24:05 <dylukes> @. pl unpl (\x -> (\ y -> x + y))
14:24:06 <lambdabot> (+)
14:24:09 <MostAwesomeDude> @pl f x = x + 1
14:24:09 <lambdabot> f = (1 +)
14:24:09 <brisingr> @unpl (\x y -> if x > 0 then y else y + 2)
14:24:09 <lambdabot> (\ x y -> if (x > 0) then y else (y + 2))
14:24:30 <shachaf> (\x -> ap const const x + 1)
14:24:32 <brisingr> @pl f x y z t = x + y * z + 2 * t
14:24:32 <lambdabot> f = flip flip (2 *) . ((flip . (((.) . (+)) .)) .) . (. (*)) . (.) . (+)
14:24:37 <dylukes> @. unpl pl (\x y -> if x > 0 then y else y + 2)
14:24:37 <lambdabot> (\ f -> (if' (f > 0)) >>= \ k -> (\ a -> 2 + a) >>= \ j -> return (k j))
14:24:39 <dylukes> :D
14:24:40 <dylukes> done
14:24:56 <DanBurton> dylukes: perfect
14:24:57 <dylukes> @. unpl pl (f x y z t = x + y * z + 2 * t)
14:24:57 <lambdabot> ((line 1, column 12) : unexpected "=" expecting variable, "(", operator or ")")
14:25:03 <dylukes> @. unpl pl f x y z t = x + y * z + 2 * t
14:25:04 <lambdabot> f v f j m = (v + (f * j)) + (2 * m)
14:25:08 <DanBurton> let obfuscate = unpl . pl
14:25:41 <dylukes> x + y * z + 2 * t => (v + (f * j)) + (2 * m)
14:25:44 <dylukes> isn't that obfuscated though :P
14:25:48 <DanBurton> u_u
14:25:58 <dylukes> It does have explicit parens :D
14:26:11 <dylukes> I mean, what else could you do to obfuscate that.
14:26:12 <DanBurton> let explicitParens = unpl . pl
14:26:48 <DanBurton> dylukes: you could write it lisp-style
14:27:27 <dylukes> Exactly XD
14:27:37 <DanBurton> ((+) ((+) v ((*) f j)) ((*) 2 m))
14:27:53 <DanBurton> but if you know how to read s-expressions it's not very obscure
14:28:27 <DanBurton> @. unpl pl ((+) ((+) v ((*) f j)) ((*) 2 m))
14:28:27 <lambdabot> ((v + (f * j)) + (2 * m))
14:28:36 <geekosaur> more parens than lisp has, too.  win!
14:28:58 <brisingr> @. unpl pl unpl pl unpl pl ((+) ((+) v ((*) f j)) ((*) 2 m))
14:28:58 <lambdabot> unpl pl unpl pl ((v + (f * j)) + (2 * m))
14:29:01 <brisingr> ahh damn
14:29:13 <DanBurton>  @. only does composition of two commands
14:29:45 <dylukes> An amusing side effect I've noticed on my PSN account of prices ending in .99...
14:30:15 <dylukes> is that when my balance hits $0, the number of cents is the number of purchases I've made...
14:30:25 <dylukes> er, wait... nah, that's just a coincedence...
14:30:30 <fenix> real men use peano axioms + SK-Calculus to obfuscate  code :D
14:30:37 <DanBurton> modulo 100
14:30:47 <dylukes> edwardk: is a manly man
14:31:05 <nand`> fenix: exactly, even I is too easy
14:31:14 * edwardk arches an eyebrow
14:33:11 <fenix> we could also use a grotendieck construction to have negative numbers
14:33:15 * DanBurton starts formulating dylukes' PSN observation as a quickCheck property
14:33:23 <dylukes> >_>
14:33:59 <fenix> and maybe do some tensor calculus and inner products to count in sk :D
14:34:32 <nand`> I use Lazy K as my main programming language. I find using anything else too artificially restricting and detrimental to my workflow
14:35:10 <fenix> VHDL ;)
14:35:35 <Peaker> diagrams looks really nice
14:36:15 <byorgey> Peaker: thanks!
14:36:30 <dylukes> Well duh.
14:36:34 <dylukes> It's made of sex and combinators.
14:36:44 * edwardk is bogged down calculating a bunch of spline fits for colorimetry data today. boorring
14:36:49 <byorgey> pretty much
14:37:10 <dylukes> I feel like there's a joke or pun to be had in the phrase "combinatorial sex".
14:37:43 <fenix> women is just a typo... should be comen
14:38:30 <edwardk> nah, its just sexist that we call them comonads. Clearly they should be womonads.
14:38:52 <fenix> :D:D
14:38:56 <edwardk> And wopumpkin should be getting an operation any day now
14:39:25 <Peaker> byorgey: none of the examples in the gallery have a visible x-axis/y-axis with names/value markers.. any existing work to make data-graphs easy to draw?
14:40:32 <fenix> poor womonads... no prelude for them
14:44:01 <fenix> and if a monad and a womonad really like each other and get close a new identity is definied
14:50:07 <jay_gridley> hello, anyone has experience with installing vacuum-cairo on Windows?
14:51:18 <byorgey> Peaker: no, but building data visualization frameworks on top of diagrams should be (I hope) fun & easy
14:51:47 <Hemite> SuperSimple haskell question, How can I read in an int from stdin and then use it in a function I made earlier
14:52:33 <hpaste> DanBurton pasted “The dylukes-psn theorem” at http://hpaste.org/65121
14:53:02 <dylukes> awesome.
14:53:06 <dylukes> :D
14:53:12 <DanBurton> passes 10000 tests, it's official
14:53:18 <dylukes> Nope.
14:53:25 <dylukes> Until you prove it inductively in Agda, no one cares
14:53:38 <dylukes> You could also use Coq, but we'll make penis jokes about you.
14:53:42 <DanBurton> lol
14:53:53 <DanBurton> Personally I want to start learning Idris
14:53:57 <byorgey> Hemite: main = do { n <- readLn; ... someFunctionThatTakesAnInt n ... }
14:54:19 <Hemite> oh allright thanks
14:55:17 <DanBurton> hrm suddenly I'm curious. I bet it's possible to define a proposition in Agda/Idris/whatever, and then run quickCheck on it before you start trying to prove it, just as a sanity check that you're not proving something dumb.
14:55:25 <DanBurton> s/dumb/false
14:55:46 <dylukes> Use Agda's haskell FFI perhaps>
14:55:49 <dylukes> *?
14:55:57 <dylukes> The thing is, you'd have to have a Bool result.
14:56:01 <byorgey> DanBurton: sure, I think that's a great idea.  But I'm not aware of any system that actually lets you do that.
14:56:05 <dylukes> Which isn't too useful in Agda.
14:56:16 <cadabra> I installed GHC 7.4.1, which has base-4.5.0.0. Now I can't cabal install cabal-install, because it depends on unix-2.4.2.0, which requires base <4.4. Now what? :-|
14:56:19 <DanBurton> it could also be nifty to just provide a random generator seed that produces a counterexample
14:56:31 <byorgey> dylukes: hmm, good point.
14:56:35 <DanBurton> although it would be clearer to just use the counterexample
14:56:39 <dcoutts_> cadabra: still got the older ghc installed?
14:57:00 <dylukes> cadabra: GHC 7.4.1 needs cabal-install from darcs.
14:57:01 <dcoutts_> cadabra: or still got cabal-install from your previous installation?
14:57:03 <cadabra> dcoutts_:  No, but I can get there. Why?
14:57:14 <dylukes> cabal-install darcs, darcs cabal-install
14:57:15 <cadabra> Yes to the latter, I guess
14:57:18 <dylukes> I'm not even kidding.
14:57:21 <dcoutts_> cadabra: well the old binary still works
14:57:27 <dylukes> That's almost like, tragically poetic.
14:57:50 <DanBurton> lol
14:58:02 <dylukes> cadabra: cabal install darcs, then use darcs to get the HEAD of cabal-install... then install it with... cabal install.
14:58:05 <DanBurton> a new version of darcs is usually available from your system's distribution as well, e.g. apt-get
14:58:14 <dylukes> If you're on a linux box.
14:58:17 <cadabra> Okay.
14:58:37 <dylukes> DanBurton: but, those only go to like compat with 7.2.x
14:58:39 <dylukes> I think.
14:58:39 <dcoutts_> cadabra: you said you still had the old cabal binary
14:59:08 <cadabra> Yeah, I can use that. I was just trying to update it.
14:59:14 <dcoutts_> cadabra: so you don't need to do anything
14:59:18 <DanBurton> usually you don't use darcs for its Haskell libraries, but simply as the command line tool, in which case it doesn't really matter what ghc it is built with as long as it works
14:59:28 <dcoutts_> cadabra: there's nothing to update :-) you've got the latest release
14:59:59 <Peaker> byorgey: cool.. next time I toy with visualizations :)
15:05:05 <Hemite> byorgey: Hey that didn't seem to fix it, I'm getting: No instance for (Read (IO ()))
15:05:43 <byorgey> Hemite: that means it thinks 'n' is supposed to have type  IO ().
15:05:54 <byorgey> Hemite: so you must have used n in a way that requires it to have that type, instead of Int.
15:05:56 <cadabra> Trying to compile a simple program since installing 7.4.1 and getting: Could not find module `System' - It is a member of the hidden package `haskell98-2.0.0.1'
15:06:06 <byorgey> Hemite: if you paste your code on hpaste.org I could take a look.
15:06:39 <cadabra> If I `ghc-pkg expose haskell98-2.0.0.1`, I get: Ambiguous module name `Prelude': - it was found in multiple packages: base haskell98-2.0.0.1
15:07:04 <byorgey> cadabra: the name 'System' is deprecated.  It was part of the Haskell 98 standard but the 2010 standard specifies hierarchical names like  System.Environment etc.
15:07:16 <byorgey> cadabra: you can't use 'base' and 'haskell98' at the same time, you must choose one
15:07:27 <cadabra> I see.
15:07:34 <byorgey> cadabra: you don't really want to ghc-pkg expose haskell98
15:07:47 <Hemite> byorgey:  http://hpaste.org/65122
15:08:05 <byorgey> it is hidden so it will only be used for packages that specifically request it
15:08:17 <byorgey> cadabra: what code are you trying to build?  can you edit it?
15:08:26 <cadabra> Yeah, I can fix it up.
15:08:40 * dylukes does the 100% trophy dance.
15:09:36 <dylukes> cadabra: The correct way to do it is,
15:09:47 <dylukes> set the cabal requirement >=1.10,
15:10:01 <dylukes> set default-language on each lib/exec to Haskell98 or Haskell2010
15:10:13 <dylukes> and give the proper requirement for base.
15:11:40 <byorgey> Hemite: well, to use myLast n in that position it would have to have type  IO ().  Try replacing  'myLast n' with  'print (myLast n)'.
15:11:58 <byorgey> Hemite: is there some particular Haskell tutorial you are going through?
15:12:16 <Hemite> what is thie IO () type?
15:14:10 <Peaker> Hemite: it's the type of procedures that do some IO and eventually yield a value of type ()
15:14:30 <Hemite> I see
15:14:31 <nand`> Hemite: () is an empty tuple and IO is a monad representing some computation which can use input/output
15:14:52 <nand`> so, it represents a computation that can do IO but will ultimately return nothing useful
15:14:59 <nand`> like putStr
15:16:33 <Hemite> byorgey: Yea I'm reading learn you a haskell but it doesn't cover the main function, just using ghci
15:17:05 <Hemite> I'm trying to print the result of my functions to stdout after reading from stdin
15:17:30 <shachaf> Hemite: Why not follow along with ghci?
15:18:04 <shachaf> Doing IO in Haskell involves understanding several parts of the language that are more easily learned on their own.
15:18:35 * shachaf off
15:18:49 <DanBurton> Hemite: one simple way to test a single function in the way you desire is with `interact'
15:18:55 <DanBurton> main = interact myFunc
15:18:58 <Hemite> I seem, well I just wanted to limit my use of ghci and wrote code on vim then compile it, but maybe I should use ghci more
15:19:03 <DanBurton> where myFunc is a String -> String
15:19:33 <DanBurton> yeah for starting out, you should definitely play with ghci more
15:20:13 <DanBurton> you can even have two windows: one with vim, and the other with ghci. Then whenever you change the file in vim, you just use :r to reload it in ghci
15:20:34 <Hemite> oh ok I'll try that
15:20:39 <DanBurton> I believe LYAH teaches you how to :l and :r in ghci
15:22:05 <brisingr> ah ah ah, yet another bragging moment: 500kB milestone reached! http://bit.ly/xDsDSj
15:22:39 <brisingr> Yes, I will brag every once in a while
15:23:22 <brisingr> hope I'm not being *too* obnoxious
15:24:05 <adimit> Say I've a list of Foos where data Foo = Bar
15:24:23 <adimit> data Foo = Bar | Baz … how do I filter just the Bar?
15:24:32 <adimit> sorry, Enter is too close to backspace.
15:25:12 <adimit> ah, list comprehensions, no?
15:25:25 <mauke> yes
15:25:36 <adimit> … damn, but now I want the indices of these items.
15:25:51 <mauke> write an isBar function
15:25:56 <adimit> so I basically want a function (Foo -> Bool)
15:25:58 <applicative> filter (fst . isBar)
15:26:08 <applicative> wrong way round
15:26:11 <adimit> mauke: yeah, I thought so, I just didn't know whether there wasn't a more canonical way to do it.
15:26:19 <mauke> @hoogle (a -> Bool) -> [a] -> [Int]
15:26:19 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
15:26:19 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
15:26:20 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
15:26:26 <mauke> findIndices isBar
15:26:27 <applicative> the canonical way is to write isBar
15:26:39 <adimit> yup thanks.
15:27:03 <applicative> if you derive Eq, the x == Bar  is the same as isBar
15:27:22 <sipa> > [x ¦ Left x <- [Left 1, Right 2, Left 3] ]
15:27:23 <lambdabot>   <no location info>: parse error on input `<-'
15:27:39 <adimit> applicative: yeah, though I made a simplificatoin in my problem description. Both constructors contain fields.
15:27:42 <adimit> (actually records)
15:27:50 <Axman6> that's a strange pipe character sipa (try c&p | )
15:28:00 <adimit> So I think writing isBar is probably the way to go.
15:28:46 <mauke> U+00A6 (c2 a6): BROKEN BAR [¦]
15:29:35 <applicative> maybe you can do it sipa's way though, with [(int,field) | (Bar field, int) <- zip foos [1..]] or am i hallucinating
15:30:07 <adimit> applicative: no, zipping came to my mind, too.
15:30:09 <sipa> > [x | Left x <- [Left 1, Right 2, Left 3] ]
15:30:10 <lambdabot>   [1,3]
15:30:34 <adimit> applicative: but i think the way I've got it now is a bit clearer.
15:31:06 <adimit> i.e. let target_indices = findIndices isBar s -- very readable to my future self!
15:31:45 <mauke> |¦‖❘❙⫾｜￤⦀⫴⫼⫿
15:31:47 * hackagebot numbering 0.2.1 - Combinators for creating bijections from some type to the natural numbers.  http://hackage.haskell.org/package/numbering-0.2.1 (DanielSchuessler)
15:37:26 <applicative> > take 2 "▁▂▃▄▅▆▇"
15:37:26 <lambdabot>   "\9601\9602"
15:39:24 <jasonalmeida> http://www.wardenbox.com/eng/BuyGifts.aspx Wonderful gift IDEA!!!
15:40:33 <cheater_> > "▁▂▃▄▅▆▇"
15:40:34 <lambdabot>   "\9601\9602\9603\9604\9605\9606\9607"
15:42:05 <adimit> @pl \p -> f p && g p
15:42:05 <lambdabot> liftM2 (&&) f g
15:44:34 <adimit> ah. I always forget that (a ->) is a Functor & Monad.
15:44:58 <Glorius_B> hello i have a graph made of a list of edges [(Int,Int)] and the number of verteces Int  and I have a module: module Colours (colours) where colours :: [String], colours = ["red","yellow", "blue"] how do i make a function so i link a vertix with a certain colour?
15:46:48 * hackagebot FilePather 0.1.1 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.1.1 (TonyMorris)
15:47:24 <jmcarthur> Glorius_B: what is the type of the function you want?
15:47:26 <rostayob> what's the point of re-exporting Text.ParserCombinators.Parsec.Token if it's incompatible with parsec 2 anyways?
15:47:37 <rostayob> ah no it's not.
15:48:44 <psyR> hi is there anyone around to help me with a trivial gloss animation problem?
15:51:44 <Axman6> psyR: not if you don't tell us what it is
15:52:11 <psyR> lol ok i'll pastebin
15:52:12 <Glorius_B> i have to  do backtracking depth first serch of the graph and see if two adjacent verteces have the same colour,  if they are reject it and i have to move to the previous vertex and keep searching in the graph for all possible arrangements of verteces where 2 adjacent vertexes are not the same colour, and I do not know how to link my colours to my verteces
15:52:51 <psyR> Glorius_B, http://pastebin.com/Pt5U6mxA
15:52:53 <mauke> The paste Pt5U6mxA has been copied to http://hpaste.org/65123
15:53:13 <psyR> it gives me a compile error
15:53:20 <psyR>  No instance for (Integral Float)
15:53:20 <psyR>       arising from a use of `round'
15:53:20 <psyR>     Possible fix: add an instance declaration for (Integral Float)
15:54:18 <rwbarton> @type round
15:54:19 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:54:58 <rwbarton> you'll need to convert the result of round from an integral type back to Float
15:55:07 <psyR> oh okay
15:55:11 <rwbarton> e.g. using fromInteger
15:55:28 <Glorius_B> i think its fromIntegral
15:55:29 <Glorius_B> :D
15:56:18 <rwbarton> either will work
15:56:23 <psyR> yay it compiles
15:56:48 * hackagebot FilePather 0.1.2 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.1.2 (TonyMorris)
15:57:22 <psyR> but it infinite loops =[
15:58:09 <Glorius_B> maybe u dont have ur termination condition somewhere
15:59:04 <psyR> well the homework is anim2 n should display anim n overlaid on top of anim2 (n-1)
15:59:11 <psyR> so it's supposed to go forever
15:59:17 <psyR> but the program just crashes
16:04:40 <jmcarthur> Glorius_B: a function?
16:04:45 <jmcarthur> Glorius_B: color :: Int -> Color
16:06:16 <Glorius_B> so Colour will be of type red blue yellow?
16:06:56 <hpaste> Glorious pasted “Colour” at http://hpaste.org/65124
16:07:29 <Glorius_B> i imported the file in my main file
16:09:13 <jmcarthur> could just be a function   Int -> String,   if that's what you want
16:09:58 <henux> How to make this work: foo xs = let len = (length xs) / 2 in len
16:10:26 <henux> I just need size of the list halved in a temp var
16:11:00 <adimit> > [ (x,y) | x <- [1..3], y <- [1..4] ]
16:11:01 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4)]
16:11:15 <adimit> > [ (x,y) | x <- [3..1], y <- [1..4] ]
16:11:16 <lambdabot>   []
16:11:44 <adimit> oh.
16:11:47 <adimit> > [3..1]
16:11:48 <lambdabot>   []
16:11:57 <adimit> funny.
16:12:39 <c_wraith> > [3,1..1]
16:12:40 <lambdabot>   [3,1]
16:13:10 <adimit> c_wraith: but I want [3,2,1]…
16:13:22 <c_wraith> > [3,2..1]
16:13:23 <lambdabot>   [3,2,1]
16:13:23 <henux> Is there a function which splits a list into two equal halves?
16:13:30 <c_wraith> yeah, it's not actually a shortcut in that case
16:13:37 <c_wraith> > [10,9..1]
16:13:38 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
16:13:46 <adimit> c_wraith: ah, thanks :-)
16:13:56 <adimit> henux: well, you could use length and splitAt.
16:14:17 <adimit> henux: there's no way you're going to make that less than O(n), of course, since you've got to know the length of the list.
16:15:05 <adimit> :t length
16:15:06 <lambdabot> forall a. [a] -> Int
16:15:09 <adimit> :t splitAt
16:15:10 <lambdabot> forall a. Int -> [a] -> ([a], [a])
16:15:36 <henux> i see
16:16:18 <henux> so length traverses through the list and counts the elements
16:16:24 <adimit> yes.
16:17:04 <applicative> aimit, ParallelListComp just occurred tom e
16:17:08 <applicative> > [(x,y) | Left x <- [Left 1, Right 'a', Left 3] | y <- [1..]]
16:17:09 <lambdabot>   [(1,1),(3,2)]
16:18:01 <adimit> applicative: look at that. nifty.!
16:18:38 <henux> adimit: dividing the lentgh by two in '(length x)/2' gives me some error about Fractional Int. can you tell me how to fix that?
16:18:49 <adimit> :t div
16:18:50 <lambdabot> forall a. (Integral a) => a -> a -> a
16:18:56 <adimit> :t (/)
16:18:57 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:19:23 <adimit> henux: length and splitAt take Int as arguments, which are Integral, but not Fractional.
16:19:35 <adimit> div is the integral counterpart of Fractional.
16:19:42 <adimit> > 9 `div` 3
16:19:43 <lambdabot>   3
16:19:51 <adimit> > 9 `div` 2
16:19:52 <henux> ok
16:19:52 <lambdabot>   4
16:19:53 <henux> got it
16:23:53 <adimit> * div is the integral counterpart of fractional (/). Man, 'tis getting late.
16:26:06 <henux> ok here is a highly inefficient merge sort implementing made in haskell. this is the first haskell program i have ever made. http://pastebin.com/5V5BPdnM
16:26:09 <mauke> The paste 5V5BPdnM has been copied to http://hpaste.org/65125
16:26:40 <henux> anyone can suggest how to make it better?
16:27:11 <twanvl> instead of a case for [x], have a case for []
16:27:27 <twanvl> what is   merge [] ys ?
16:27:27 <henux> ok
16:27:36 <twanvl> and what is   merge xs [] ?
16:28:06 <twanvl> instead of  [x] ++ stuff, write  x : stuff
16:28:39 <twanvl> actually, hlint already suggests that, see the hpaste link from mauke
16:31:45 <henux> anything else?
16:31:45 <dmwit> splitAt does both a take and a drop in one pass
16:32:10 <dmwit> Also, the comment at the bottom about list sizes that are not a power of two is a lie, so you should delete it.
16:32:16 <henux> length being O(n) elimates the idea of merge sort
16:32:37 <dmwit> You can split the thing into two lists in a lazier way than first computing the length, if you like. =)
16:32:41 <dmwit> See if you can figure out how.
16:32:46 <dmwit> We can give you some hints if you can't.
16:33:13 <twanvl> how does length being O(n) eliminate the idea of merge sort?
16:33:15 <dmwit> You should add a case for sorting the empty list, as well.
16:34:15 <dmwit> As for length being O(n) -- this should not affect the asymptotics of the sort. However, if you don't like doing that on every recursive call, you're welcome to plumb the correct lengths around, and only call length once at the top level.
16:34:39 <dmwit> mergeSort xs = go xs (length xs) where {- define "go" here to keep track of the length -}
16:34:57 <dmwit> That's a standard idiom for such one-time computations.
16:35:36 <Glorious_B> hello I m trying to learn how the modules work, and i wrote this program in 2 separate files http://hpaste.org/65126
16:35:42 <Glorious_B> could some1 please tell me whats wrong
16:36:07 <dmwit> > let merge (x:xs) (y:ys) = min x y : merge (max x y : xs) ys; merge xs ys = xs ++ ys in merge [1,3,4,6] [2,5]
16:36:08 <lambdabot>   [1,2,5,3,4,6]
16:36:36 <dmwit> ah, yes, you have to put it back on the correct list
16:36:38 <dmwit> fine
16:37:12 <dmwit> > let merge (x:xs) (y:ys) | x < y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys; merge xs ys = xs ++ ys in merge [1,3,4,6] [2,5]
16:37:14 <lambdabot>   [1,2,3,4,5,6]
16:37:49 <dmwit> Glorious_B: You don't define a type named Colours, and you don't define identifiers named blue, red, or yellow.
16:38:10 <dmwit> Glorious_B: Your Colours module defines exactly one identifier, and it is named colours.
16:38:26 <Glorious_B> so how do i play with the colours then
16:38:47 <dmwit> You may use the identifier colours to play with them.
16:38:57 <dmwit> For example, perhaps you meant to write this (annotation incoming).
16:39:02 <rasfar> @tell dreixel I got it! (syb join) I tried to make a small example suitable for hpaste, but it only works in the context of my problem (because I transform away the T nodes when hit the join in a bottom-up traversal).  The crucial SYB function turned out to be gcount.
16:39:02 <lambdabot> Consider it noted.
16:39:37 <hpaste> dmwit annotated “Glorious_b” with “Glorious_b (annotation)” at http://hpaste.org/65126#a65127
16:39:41 <hpaste> henux pasted “mergeSort v2” at http://hpaste.org/65128
16:39:46 <henux> how about now?
16:40:12 <dmwit> henux: Now you should delete the clause for merge [x] [y], since it is subsumed by the above ones. =)
16:40:46 <dmwit> henux: Other than that, this looks quite idiomatic.
16:41:40 <henux> dmwit: you would consider that very typical and good haskell code?
16:41:52 <henux> except the length xs
16:41:59 <dmwit> I would. This looks basically identical to what I would write if I sat down to write this function.
16:42:07 <henux> ok nice
16:42:09 <dmwit> I would even have written the length xs. =)
16:42:11 <henux> this was my first haskell
16:42:23 <dmwit> I would have used fewer newlines, but that really is a personal aesthetic.
16:42:31 <dmwit> You use what looks good to you, there, and nobody will complain. =)
16:42:48 <henux> yes
16:44:26 <Glorious_B> thank you dmwit
16:44:30 <kallisti> I think you could actually infer what a data structure looks like based on how it's pattern matched upon.
16:44:32 <henux> is it customary practive to use camel casing in haskell source filenames? mergeSort.hs vs. MergeSort.hs ?
16:44:39 <kallisti> I'm not suggesting this is a good idea or that Haskell should do this, but it would be possible.
16:44:53 <henux> practice
16:45:01 <twanvl> Source files usually start with upper case
16:45:11 <kallisti> pranq: typically camelcase with initial capital letter, yes.
16:45:26 <kallisti> er
16:45:27 <kallisti> henux: ^
16:45:38 <henux> ok thanks for your help
16:45:39 <dmwit> henux: Modules start with an upper-case, and the easiest thing (with GHC) is for the file name to match the module name exactly.
16:46:27 <dmwit> henux: On sane operating systems, this means at the very least a capital letter is the first character in the file name.
16:46:30 <dmwit> ;-)
16:47:32 <henux> yes. tried writing merge sort with C++ and it took me a lot more time and it was inconvenient than with haskell, even when im not very good with the basic language
16:47:53 <dmwit> \o/
16:48:08 <henux> its not so efficient tho
16:48:18 <henux> the O(n) with the length troubles me
16:48:36 <dmwit> Splitting a list is going to be O(n) anyway.
16:48:54 <dmwit> If linked list is your underlying data-structure, you can't do much better than this.
16:49:27 <henux> true
16:49:28 <dmwit> You might consider using an array, but then merging will be O(n), too.
16:50:08 <dmwit> (In fact, this implementation is O(n * log n), and it's possible to prove that you can't do better than this if the only operation you're allowed is comparisons. Have you seen this proof?)
16:50:15 <kallisti> liftIO (simpleHTTP req) >>= either (throwError . HTTPConnError) return
16:50:20 <kallisti> it's stuff like this that I enjoy about Haskell..
16:50:39 <henux> no i think i havent
16:51:41 <dmwit> henux: http://planetmath.org/encyclopedia/LowerBoundForSorting.html
16:52:14 <dmwit> gotta run
16:58:57 <kallisti> any URL/URI libraries out there that are made to work Text?
16:59:15 <kallisti> I'm using Network.URI but I have to convert Text to String.
17:27:21 <danharaj> I have a typing problem.
17:28:10 <danharaj> A value won't typecheck with a signature because of  an ambiguous type variable, without the signature and with NoMonomorphismRestriction, it typechecks but includes a constraint that doesn't even show up in the type.
17:28:25 <danharaj> Then when I try to use the type that GHCi gives me, it still fails to typecheck.
17:29:51 <danharaj> Wait I think I know what the problem is.
17:32:45 <danharaj> Nope... that didn't work.
17:34:03 <hpc> danharaj: rewrite the value so it makes sense, would be my suggestion
17:34:12 <danharaj> hpc: It typechecks ;\
17:34:16 <danharaj> without the annotation.
17:34:41 <DanBurton> hpaste it?
17:35:10 <danharaj> well, let me make sure nothing strange happens when I try to evaluate the value.
17:35:24 <hpc> haha
17:35:41 <danharaj> "GHC: I have deduced that your value is bottom!"
17:35:59 <danharaj> (A possibility)
17:36:23 * shachaf never got that message from GHC. :-(
17:38:11 <danharaj> aha, I cannot use the value. A good clue.
17:48:25 <ForSpareParts> Would anyone mind giving a bit of homework help?
17:49:53 <shachaf> ForSpareParts: You should specify what the problem is. :-)
17:49:54 <danharaj> ForSpareParts: feel free to ask questions
17:49:58 <hpaste> rasfar pasted “SYB join -- seems to work?” at http://hpaste.org/65130
17:50:23 <shachaf> danharaj: In GHC you can make an identifier that doesn't even have a type.
17:50:28 <rasfar> @tell dreixel http://hpaste.org/65130 and thanks a lot for your advice etc
17:50:28 <lambdabot> Consider it noted.
17:50:54 <rasfar> ForSpareParts: just ask away
17:53:45 <rasfar> pfft
17:53:57 <ForSpareParts> Thanks. I'm working on a Forth interpreter. The teacher gave us a bit of skeleton code, creates a dictionary for operations, a couple of stacks, and a tail loop...
17:54:16 <ForSpareParts> I'm trying to make an operation to print the whole stack
17:54:27 <ForSpareParts> and I'm still very new to the whole monad... thing.
17:54:57 <ForSpareParts> Ideally, the operation would take a list as an argument, print it, and return the original argument
17:55:19 <ForSpareParts> but if I try anything in do-notation, IO corrupts everything I work with.
17:55:46 <ForSpareParts> So, how would I get that kind of side-effect?
17:57:10 <rasfar> I don't think IO would corrupt anything in such a case, where's the harm in printing it?
17:57:41 <sral> anyone have the feeling that monad transformers are quite messy? they make your type look like onions
17:57:49 <danharaj> ok I figured out my problem, I needed to use scoped type variables and forall's to make a top-level constraint the same as a constraint in a subfunction.
17:58:17 <lispy> yo haskellers
17:58:22 <lispy> How's code?
17:58:25 <danharaj> ForSpareParts: paste your current try?
17:58:30 <rasfar> yo lispy, actually really well thanks!
17:58:31 <lispy> cmccann: how is hackage going?
17:58:38 <danharaj> lispy: realToFrac is still a scourge upon the opengl library ;p
17:58:39 <lispy> rasfar: \o/
17:58:47 <ForSpareParts> danharaj: alright, one sec
17:58:51 <lispy> danharaj: yes yes it is
17:59:01 <danharaj> down with broken floating point conversion api's!
17:59:03 <danharaj> >:O
17:59:15 <lispy> danharaj: I thought the Andy Gill rewrite rule got applied
17:59:23 <lispy> danharaj: Pull requests accepted :)
17:59:31 <lispy> http://github.com/haskell-opengl
17:59:33 <ForSpareParts> http://pastebin.com/GvLi4T5z
17:59:35 <mauke> The paste GvLi4T5z has been copied to http://hpaste.org/65131
17:59:51 <danharaj> I just realized my version is really old. My bad. :3
18:00:07 <lispy> danharaj: I could be wrong
18:00:25 <danharaj> lispy: I totally don't have to contribute because already there's a lot of guys doing cool things on the mailing list.
18:01:04 <lispy> danharaj: open source works best when we all chip in :)
18:01:50 <danharaj> lispy: I balk at the Big Decisions that must be made to bring the library into a state where it can keep up with the standard revisions.
18:02:02 <danharaj> lispy: I'll let more competent people make them :p
18:02:24 <lispy> danharaj: what do you mean?
18:02:48 <lispy> danharaj: oh, you mean the opengl spec revisions
18:03:17 <lispy> danharaj: how about this, try the latest version and if realToFrac is still slow for you
18:03:26 <lispy> Let me know
18:03:39 <cmccann> lispy, haven't had any time for it at all sadly
18:03:44 <danharaj> lispy: I only used realToFrac in one place, and I just replaced it with unsafeCoerce, now I just work with Floats.
18:03:49 <cmccann> real life stuff getting in the way
18:04:05 <lispy> cmccann: no worries, I just thought I would ask
18:04:28 <lispy> cmccann: tibbe was talking about using amazon to host the tarballs and someone mentioned using github to host them
18:05:02 <lispy> cmccann: it made me wonder how things were going for you
18:06:52 <lispy> I think I'm going to play with the simply typed lambda calculus
18:07:01 <lispy> It looks like a neat foundation for other things
18:07:04 <cmccann> lispy, I'll let you know when I get back to it :]
18:07:12 <rasterfar> ForSpareParts: I'd recommend using explicit type declarations for your functions, but I don't think there's any problem with printing the stack.
18:07:12 <lispy> cmccann: yay!
18:07:57 <rasterfar> my connection here is horrible, rather than litter the channel with all the disconnects, i'll be off...
18:08:18 * lispy configures his client as to not see connect/disconnect notices.
18:08:38 <lispy> I streamline my client to see real content.  I totally recommend it.
18:09:11 <mauke> makes it harder to react to abuse
18:09:47 <lispy> I'm no longer an op so that's not really important for me
18:09:58 <lispy> Plus, I think the disconnects do appear in my log file
18:11:16 <ForSpareParts> @ rasterfar/anybody else, since he's gone: I've tried compiling the code that I put on pastebin, but it says that it "expects" an IO type 'IO b0' and find actual type [a0]
18:11:19 <ForSpareParts> *finds
18:12:36 <danharaj> ugh, I have a <<loop>> from using rec arrows. What tools do I have to see what's going o?
18:12:36 <danharaj> on*
18:15:38 <ForSpareParts> I've been attempting to do an explicit type declaration as rasterfar suggested, but I haven't gotten anything to compile yet. Is every line of a "do" considered as an argument?
18:15:39 <lispy> danharaj: hmm...I've never tried to find a <<loop>>
18:16:27 <danharaj> lispy: Normally I would just rely on my mental model, but my mental model of ArrowLoop is shaky.
18:16:40 <lispy> danharaj: if rec arrows work similarly to recursive do, then I would expect it's happening because you depend on something that hasn't happened yet
18:16:44 <ForSpareParts> Like if I did f = do {putStrLn "string" ; 42} with the intent of returning 42, would that be type IO() -> int?
18:16:45 <DanBurton> use someone else's mental model?
18:17:23 <lispy> danharaj: there was a good TMR article about recursive do and the dangers of depending on the future
18:17:24 <DanBurton> ForSpareParts: you would need to do this: f = do {putStrLn "string"; return 42}, which would have type IO Int
18:17:29 <ion> @undo do {putStrLn "string" ; 42}
18:17:29 <lambdabot> putStrLn "string" >> 42
18:17:35 <ion> @type (>>)
18:17:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
18:17:53 <ion> Can you see why that’s a type error?
18:18:31 <danharaj> lispy: If you remember the issue I should read it!
18:18:36 <ForSpareParts> still confused, sorry...
18:19:02 <ForSpareParts> DanBurton: Is there no way to get back just an Int?
18:19:05 <ion> @type putStrLn "string"
18:19:06 <lambdabot> IO ()
18:19:06 <lispy> danharaj: third article: http://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
18:19:25 <danharaj> thanks
18:19:32 <ion> “m” is IO and “a” is (). The second parameter must be “IO b” where b might be e.g. an Integer.
18:19:41 <ion> 42 :: Integer
18:19:43 <ion> return 42 :: IO Integer
18:21:56 <ion> “putStrLn str” is an IO action. (>>) takes two IO actions and returns a new one that (upon execution) does both of the original actions in sequence. “do a; b” is syntactic sugar for “a >> b”.
18:22:09 <ion> If “a” is an IO action, “b” must be one as well.
18:22:40 <ForSpareParts> ion: OK. Think I've got that, then. So, what I'm trying to do is impossible in Haskell, then, and I need to approach it from a different angle?
18:23:26 <ion> What are you actually trying to do?
18:24:55 <ForSpareParts> Well, the forth interpreter is an eval loop that looks up functions in a dictionary and calls itself with transformed versions of the arguments (the number stack, the integer stack, and the dictionary itself)
18:25:09 <ForSpareParts> and the problem I'm supposed to solve is to add an operation that prints the stack without altering it
18:26:04 <ForSpareParts> We're given an operation to pop the top item off of the stack, print it, and move on -- that's done using a do with a putStrLn followed by a recursive call to the eval loop
18:26:42 <ForSpareParts> I tried to do the same thing, but I'd have to put the function somewhere Haskell doesn't seem to like -- one sec, I'll pastebin it
18:26:48 <ion> What’s the type of pop?
18:28:49 <ForSpareParts> http://pastebin.com/uxYskN1M
18:28:51 <mauke> The paste uxYskN1M has been copied to http://hpaste.org/65133
18:28:58 <ForSpareParts> part of our skeleton code
18:29:59 <ForSpareParts> I originally tried to add a condition like:
18:30:32 <ForSpareParts> Unknown ".S" -> do {printstuff; eval [arguments to eval]}
18:30:50 <ForSpareParts> underneath the first Unkown -- Unknown "."
18:31:08 <ForSpareParts> but the compiler said that there was some kind of parse error on finding a second Unknown there.
18:32:08 <mauke> what was the error message?
18:32:47 <ForSpareParts> parse error on input `Unknown'
18:33:01 <mauke> show your code
18:33:34 <ForSpareParts> http://pastebin.com/q00WLV3k
18:33:36 <mauke> The paste q00WLV3k has been copied to http://hpaste.org/65134
18:34:10 <ion> Your indentation is broken.
18:34:17 <ForSpareParts> in my source, the second Unknown appears to have the same level of indentation.
18:34:28 <mauke> keyword: "appears"
18:34:37 <ion> Make sure your editor isn’t inserting tabs anywhere.
18:34:40 <mauke> because you're mixing spaces and tabs
18:34:55 <ForSpareParts> thanks! I'll take a look.
18:37:32 <lispy> ?djinn p -> (q -> p)
18:37:32 <lambdabot> f a _ = a
18:37:48 <lispy> ?djinn (p -> (q -> r)) -> ((p -> q) -> (p -> r))
18:37:48 <lambdabot> f a b c = a c (b c)
18:39:10 <ion> const and (<*>)
18:39:15 <shachaf> @djinn ((p -> q) -> p) -> p
18:39:15 <lambdabot> -- f cannot be realized.
18:39:34 <shachaf> Intuitionists.
18:40:00 <ion> @djinn (p -> q) -> ((p -> q) -> p) -> p
18:40:01 <lambdabot> f a b = b a
18:40:10 * shachaf is pretty sure djinn are supposed to be non-constructive.
18:40:35 <shachaf> ion: Amazing! :-)
18:40:47 <shachaf> @djinn (((p -> q) -> p) -> p) -> ((p -> q) -> p) -> p
18:40:47 <lambdabot> f a = a
18:40:56 <ion> :-)
18:41:13 <dbelange> @djinn p -> p -> p -> p -> p -> p -> p -> p -> p
18:41:13 <lambdabot> f _ _ _ _ _ _ _ a = a
18:41:47 <ion> @@ @djinn @type \a b c d e f g -> c a b b a g e
18:41:48 <lambdabot>  f a b c _ d _ e = c a b b a e d
18:44:45 <lispy> :t lift0
18:44:46 <lambdabot> Not in scope: `lift0'
18:45:23 <ForSpareParts> alright, so my code compiles now, but I'm getting really weird behavior
18:45:25 <lispy> shachaf: do you have that memorized or are you reading TMR 6 too?
18:45:34 <ForSpareParts> using my new operator butchers my list in ways I don't totally get
18:45:54 <ForSpareParts> http://pastebin.com/WjqRnkVj
18:45:56 <mauke> The paste WjqRnkVj has been copied to http://hpaste.org/65135
18:46:01 <mgsloan> if (>>=) is bind, what's the english name for (>>) ? sequence is already taken.. hmm
18:46:05 <ion> liftA0 :: Functor f => (a -> b) -> f b
18:46:09 <mgsloan> forgetful bind
18:46:23 <ForSpareParts> I made my ".S" map to EXACTLY the same thing as ".", but it still does something different
18:46:43 <ForSpareParts> starts the eval loop with some kind of transformed list
18:46:47 <shachaf> lispy: Have what memorized?
18:46:58 <ion> I mean, liftA0 :: Functor f => b -> f b
18:47:05 <ion> Look familiar? :-P
18:47:10 <shachaf> lispy: Peirce's law?
18:47:32 <lispy> shachaf: ((p -> q) -> p) -> p
18:47:47 <ForSpareParts> like if the list is [3, 4, 5] it turns it into [1, 3] somehow
18:47:58 <shachaf> lispy: I guess you could call that "memorized"... It's the type of callCC (more or less).
18:48:49 * shachaf wonders if that waas spoilers or something.
18:49:12 <lispy> shachaf: I don't think so.
18:49:21 <shachaf> Nope, I haven't read that article, but I've read similar ones.
18:49:43 <shachaf> lispy: Have you seen the proof of LEM from callCC?
18:49:43 <lispy> shachaf: I didn't even notice it being callCC but that does make sense.  That one is meant to enable classical logic
18:50:30 <lispy> shachaf: I haven't read a proof of it using callCC, but I've seen similar things like using hilbert's choice operator to make a logic classical
18:50:44 <lispy> shachaf: hilbert's operator is very similar to callCC but not exactly
18:51:02 <shachaf> lispy: Right -- the Cont monad in Haskell is "equivalent" to the standard embedding of classical logic in intuitionistic logic.
18:51:46 <danharaj> I have deduced that the problem indeed is that I am pattern matching on data from the future.
18:51:59 <lifestream> I spent 1hr watching the 1st lecture of Dr. Erik Meijer on Haskell, and 4hrs working out the exercises at the end. (Yes, I'm slooow). One of the exercises is to implement your own init (remove last item from a list). Eventually I gave up and looked it up. Someone came up with "myInit (x:xs) = x : myInit xs"  What does" x : myInit xs" do, exactly? O_o"" Thanks...
18:52:03 <lispy> danharaj: roconnor++
18:52:07 <danharaj> However the data from the future I am matching on does not depend on the past.
18:52:16 <danharaj> So I am confused on how to resolve the issue.
18:53:11 <mauke> lifestream: calls (:) with two arguments, 'x' and 'myInit xs'
18:53:13 <lispy> lifestream: try replacing "myInit xs" with the definition of "myInit xs"
18:53:31 <lispy> lifestream: expand this out a few times and I think you'll start to see what is happening
18:54:11 <shachaf> lispy: The particular proof I'm talking about is pretty neat. You can treat it as a Haskell exercise: Given ccc :: ((p -> q) -> p) -> p, write lem :: Either (Not p) p
18:54:30 <lifestream> mauke, lispy, so : is the opposite of ++ ? I tried to look up : keyword on the wiki and it wasn't there.
18:54:41 <mauke> lifestream: no, : is one of the list constructors
18:54:54 <shachaf> lifestream: (:) is much more fundamental than (++). (++) is just a function.
18:54:59 <mauke> lifestream: a list is either empty ([]) or is a cons (:) containing an element and another list
18:55:29 <lispy> :t (:)
18:55:30 <lambdabot> forall a. a -> [a] -> [a]
18:55:32 <lifestream> Ah, like the last answer here: http://stackoverflow.com/questions/1696751/what-does-the-infix-operator-do-in-haskell
18:55:36 <lispy> > 1 : []
18:55:37 <lambdabot>   [1]
18:55:39 <lifestream> I read it but didn't understand :-)
18:55:41 <lispy> > 1 : 2 : []
18:55:42 <lambdabot>   [1,2]
18:56:01 <danharaj> XD
18:56:03 <mauke> @src []
18:56:03 <lambdabot> data [] a = [] | a : [a]
18:56:14 <danharaj> so since my future didn't depend on its past I just swapped the statements and it worked.
18:56:37 <danharaj> It is a little confusing working with arrowLoop and FRP because I have two time dimensions to think about.
18:57:37 <lifestream> What I was thinking to make my own Init was to... take a list... reverse it... head it... and reverse it again.   *facepalm*
18:58:11 <mauke> not bad, except s/head/tail/
18:58:26 <mauke> but that's a reasonable solution if you don't understand what a list is
18:58:37 <lispy> shachaf: hmm...he may get into callCC after all. /me is still reading so not certain
18:59:06 <shachaf> lispy: Doesn't look like he gets into the particular thing I'm thinking of.
18:59:32 <lifestream> Oh yes, you're right, tail would be correct. Well, basically this Dr Erik Meijer didn't even teach me how to code in haskell yet, but he expects me to be able to code my own init by the end of the first lecture :P So I was at a loss... :P
19:00:08 <lifestream> Well, I like to learn things the hard way anyway.
19:04:20 <lispy> shachaf: well he proves pierce's law and then implements callCC with it :)
19:04:27 <lispy> peirce*
19:04:59 <shachaf> lispy: OK, but he doesn't implement LEM. :-)
19:05:14 <shachaf> Also, what does "proving Peirce's law" mean?
19:05:17 <mauke> stan lem
19:05:21 <shachaf> It's usually taken as an axiom.
19:06:22 <lispy> shachaf: Page 27 http://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
19:06:59 <shachaf> Oh, he uses Not (Not p) -> p as an axiom.
19:07:43 <lispy> Yes, he's explicitly classical
19:09:12 <dolio> Peirce's law is callCC.
19:11:07 <lispy> dolio: he explains that too
19:11:56 <lispy> Godel-Gentzen translation is one way to get a CPS translation.  Interesting.
19:15:15 <dolio> Double negation elimination looks like K r a -> a, where K is Cont.
19:15:30 <dolio> Peirce's law looks like J r a -> a.
19:15:42 <dolio> Where J is the search monad.
19:15:59 <dolio> Escardo's (had to think of the name).
19:16:20 <dolio> And there's an obvious mapping J r a -> K r a.
19:16:36 <dolio> So there's also an obvious mapping (K r a -> a) -> (J r a -> a)
19:16:47 <dolio> From double negation to Peirce's law.
19:16:53 <dolio> Double negation elimination.
19:17:26 <lispy> I'm not familiar with J
19:17:42 <dolio> J r a = (a -> r) -> a
19:17:59 <lispy> dolio: oh, I am familiar with it. It uses the cantor set
19:18:19 <adit> argh.
19:18:40 <adit> Scumbag Bryan Sullivan: tons of useful libraries, no documentation : (
19:19:06 <dolio> lispy: Yeah, for r = Bool, more or less.
19:19:48 <lispy> dolio: I learned about it via an older post he has.  I can't say I understand it though.
19:21:17 <dolio> lispy: J r a represents a searchable set of as, sort of. Given a generalized predicate (a -> r), it gives back an a that satisfies the predicate, or some arbitrary a in the set if nothing does.
19:22:24 <dolio> You can go t J r a to K r a by applying the predicate to the element returned, which just tells you whether there exists a satisfying element.
19:22:41 <dolio> At least, when r = Bool that's the interpretation.
19:25:01 <lispy> J seems to be a lot like hilbert's choice with the added ability to find the thing given a searchable set
19:25:30 <dolio> Yes, it is like that.
19:27:04 <dolio> An element of J r a takes a predicate and chooses a satisfying element if possible.
19:27:46 <lispy> and _|_ otherwise
19:27:50 <dolio> No.
19:27:58 <dolio> If there is no satisfying element, it just returns whatever.
19:28:28 <dolio> But if it returns something that doesn't satisfy the predicate, you know that nothing in the set does.
19:29:07 <lispy> yes, I see now
19:29:29 <lispy> search is in charge of checking what find returned
19:29:42 <lispy> and translates a bad result into Nothing
19:39:26 <danharaj> what does it mean in a heap profile when a color is labeled by a fun1/fun2/...? Thunks?
20:04:53 <scooty-puff-sr> i need to provide something of kind (terminology?) * -> Constraint to a type class
20:05:03 <scooty-puff-sr> but not sure how to have the default case of () represented
20:05:23 <scooty-puff-sr> do i need to create a dummy class Id a; instance Id a
20:07:13 <hpaste> lifestream pasted “homemade Init” at http://hpaste.org/65137
20:07:23 <lifestream> Stalker.
20:08:19 <hpaste> lifestream pasted “wangs” at http://hpaste.org/65138
20:08:39 <lifestream> Eh?
20:09:24 <shachaf> lifestream: reverse (init (reverse xs)) is already a "correct" implementation of init.
20:09:42 <shachaf> (Other than strictness.)
20:09:51 <shachaf> You don't gain anything from the first two lines if you use that.
20:10:29 <lifestream> I really don't know anything about haskell, I kind of had to follow compiler errors and google around to figure out what to do.. so I wasn't too sure if I needed those two lines :)
20:10:51 <danharaj> so I have a strange leak
20:11:12 <danharaj> it leaks until I tell the offending FRP thing to do something.
20:11:21 <shachaf> lifestream: You should probably read an introduction to Haskell or something.
20:11:21 <danharaj> it's building up a thunk or something.
20:11:35 <shachaf> Delicious thunks.
20:12:27 <danharaj> it's weird because it looks like IO actions are being too lazy
20:13:56 <lifestream> shachaf, ah, yes, I have tried to read a couple books (realworld + lyahfgg) but it seems I can only learn things if I start from a goal (remove last item from a list), then figure things out from there. Really, I tried to read a few chapters from the books but I didn't understand anything AT ALL. I know, I'm weird...
20:23:34 <DanBurton> I recommend reading and following along with lyah
20:23:46 <DanBurton> once an idea is introduced, start playing with it in ghci
20:27:11 <Veinor> what does the MAIN cost center in GHC's -hc profiling output mean?
20:32:26 <tgeeky> edwardk: byorgey: can either of you make sense the abstract here: http://www.math.unicaen.fr/~giliberp/paper/Larder.pdf
20:34:19 <edwardk> i get the gist if not the exact mechanism
20:34:28 <lifestream> I'm trying to figure out how the "myInit (x:xs) = x : myInit xs" works, http://hpaste.org/65137 eventually it comes to "E : []", so at that point myInit can't run anymore (right?). So basically what happens is not that we *remove* the last item from the list, but we *see* how many times myInit can run.  Is it really that simple? :-O
20:34:38 <tgeeky> edwardk: so... what's it do?
20:36:44 <edwardk> well i haven't grokked the poset stuff he's using, but the rest of it is looking at A and B through S and trying to translate diagrams from A to B
20:37:58 <edwardk> not really my realm of expertise
20:38:23 <cmccann> fun facts learned today: lisp enthusiasts are easier to troll than haskell enthusiasts
20:39:14 <dolio> The art of trolling lisp enthusiasts has been developed for much longer.
20:39:37 <lifestream> (Ah, nevermind, I understand myInit now, sorry to bother ;-P)
20:39:53 <shachaf> Every new trolling technique discovered in other languages has been known by LISP people for 50 years.
20:39:59 <cmccann> shachaf, hahahaha
20:40:31 <danharaj> I hate this leak so much.
20:40:49 <danharaj> I have absolute control over it. I can make it die literally by pressing a single key.
20:41:05 <danharaj> and the profiler is mean.
20:41:10 <danharaj> What is stg_ap_2_upd_info!? :\
20:41:24 <byorgey> tgeeky: no freaking clue
20:41:54 <shachaf> «In spite of its lack of popularity, LISP (now "Lisp" or sometimes "Arc") remains an influential language in "key algorithmic techniques such as recursion and condescension"[2].»
20:41:55 * lispy waves at edwardk 
20:42:56 <lispy> danharaj: stg means spineless tagless g-machine (thats the state machine that evaluates GHC haskell at run-time), IIRC 2 means how many arguments to the closure
20:43:28 <lispy> danharaj: upd probably means update the thunk and info is maybe for profiling? (now I'm just guessing)
20:44:12 <cmccann> shachaf, the excessive footnotes in that bit were a nice touch, I thought
20:44:19 <danharaj> lispy: so there is something thunking up all up in here. I need to figure out *where* though.
20:44:49 <danharaj> and *why*. Nothing should be lazy!
20:45:25 <lispy> danharaj: recursive arrows and nothing should be lazy?
20:46:08 <lispy> danharaj: anyway, without more information I doubt I can do more than empathize (not that I want to debug your thing at the moment as I'm trying to learn some type theory)
20:46:30 <danharaj> lispy: indeed.
20:46:34 <byorgey> @remember danharaj so there is something thunking up all up in here.
20:46:34 <lambdabot> Good to know.
20:48:43 <lispy> byorgey: You might like this; I was reading some slides about logicians' reactions to using CT as a foundation of math.  One logician pointed out that it's more of an organizational theory. This maybe me wonder about using CT as a foundation for a multi-paradigm language. You know, kind of how we implement different mini-languages using monads but taken to an extreme.
20:49:35 <lispy> byorgey: Perhaps different languages with different semantics can be embedded in different categories within one framework
20:49:48 <lispy> I don't yet grasp CT well enough to know if what I'm saying makes sense :(
20:49:49 <edwardk> heya lispy
20:50:19 <lispy> edwardk: need me to do anything wrt to gsoc?
20:50:36 <edwardk> lispy: drum up mentors
20:50:41 <lispy> hmm
20:50:44 <lispy> gwern!!!
20:50:45 <lispy> ;)
20:50:47 <edwardk> hah
20:51:20 <lispy> someone at work mentioned that galois folks should mentor.  I can repeat that this week at our 'all hands' meeting
20:51:43 <shachaf> edwardk: That sounds dangerous. You should treat your mentors nicely.
20:51:44 <lispy> I think emertens would be a good mentor if we can get him excited
20:51:49 <byorgey> lispy: I think it could make some sense.  reminds me of Neel Krishnaswami et al's work on a multi-paradigm GUI framework -- the GUI bits are written in a linear-typed language and the other bits are written in a usual functional language, with a pair of (adjoint?) functors to embed each into the other, or something like that.
20:51:52 <danharaj> Is there a way to ask the profiler to give me a breakdown of what is holding on to a certain type?
20:52:01 <edwardk> we have a week before we get formally accepted or rejected, then we get to kick into high gear
20:52:12 <edwardk> and i get to go hunting for lots of SPI paperwork ;)
20:52:15 <lispy> danharaj: retainer profiling
20:52:29 <shachaf> Haskell.org could be rejected for SoC?
20:52:48 <lispy> shachaf: I thnk the risk is low but as I undertand it, it's always possible
20:52:53 <byorgey> edwardk: I'm definitely interested in mentoring but probably wouldn't do a very good job mentoring the sorts of real-world/performance/infrastructure-oriented projects we often end up sponsoring
20:53:09 <byorgey> but maybe you have some thoughts on that.
20:53:14 <lispy> byorgey: what would you be good at mentoring?
20:53:31 <edwardk> thats fine. sign up, vote, and if something comes up that you think you're a good fit, put your name down
20:53:39 <byorgey> edwardk: ok.
20:53:54 <edwardk> saying you're interested isn't going to shackle you to mentoring something outside of your comfort zone
20:54:00 <byorgey> sure
20:54:05 <lispy> byorgey: to add to what edwardk just said, publicily proposing project ideas helps to ensure students to mentor :)
20:54:22 <byorgey> heh, yes, I'm aware of that =)
20:54:32 <byorgey> edwardk: where do I sign up?
20:54:35 <edwardk> and if you think you can contribute some but not enough to take over full mentor duties, we try to maintain a backup mentor for every project we can, that way if the mentor needs to go away for a while, we have someone who can step up, etc.
20:54:48 <lispy> byorgey: http://www.google-melange.com/gsoc/homepage/google/gsoc2012
20:55:08 <shachaf> What's involved in mentoring, anyway?
20:55:29 <lispy> shachaf: typically, helping your student stay on track to successful completion
20:55:29 <edwardk> byorgey: this is why i haven't beaten the bushes yet. in a week when google accepts/rejects us you can register with the project on the socghop website
20:55:40 <cmccann> shachaf, I'm assuming it involves a lot of unpaid work and getting hassled by edwardk if you slack off
20:55:53 <edwardk> shachaf: it typically a few hours of work a week to help keep someone on track
20:56:00 <lispy> shachaf: that varies by project/student, but typically meeting regularly to get status updates, helping them understand things when stuck, and the like
20:56:28 <edwardk> in exchange you get a t-shirt, haskell.org gets about $500 that we put towards infrastructure, and google invites a couple of us to go visit you in the bay area ;)
20:56:54 <shachaf> If I'm still in the bay area by then!
20:57:29 <shachaf> (Or do they move the place where the mentors go to wherever I live?)
20:57:35 <edwardk> I think the latter
20:57:36 * lispy goes back to implementing this paper
20:57:48 <edwardk> We tried to get them to move the gsoc event to zurich last year to no avail
20:57:55 <edwardk> lispy: good luck =)
21:00:35 <shachaf> edwardk: Hmm, OK.
21:01:03 <edwardk> they said, no, shachaf is here.
21:01:27 <shachaf> Fair enough!
21:01:46 <edwardk> are there any packages for cubic spline interpolation in haskell that can deal with arbitrary condition for the endpoints? gershom has one but its only natural splines
21:01:53 <edwardk> not that its hard, just don't want to bother ;)
21:02:43 <edwardk> i need to interpolate a bunch of colorimetry numbers so i can have derivatives
21:03:37 <edwardk> e.g. integrating over wavelengths from 400 to 420 nm
21:05:36 <ktklam9> anyone here has experience in nonlinear optimization algorithms? I'm working on a project
21:07:33 <edwardk> ktklam9: i had to tackle a concave programming problem in my thesis
21:07:43 <edwardk> is it at least concave?
21:07:48 <edwardk> er at least convex
21:08:03 <ktklam9> edwardk: are you familiar with Conjugate Gradient, quasi-Newton methods etc..?
21:08:23 <dbelange> edwardk: don't worry about the details, it's only your thesis
21:08:41 <patdohere> Hi
21:08:49 <edwardk> yes
21:08:50 <edwardk> dbelange: well it was only my _first_ thesis and it was a while ago ;)
21:09:08 <dbelange> are you one of these guys with 99 theses
21:09:14 <ktklam9> the only optimization algorithms available in Haskell right now are from hmatrix, which is a binding to GSL, which isn't that great
21:09:21 <edwardk> ktklam9: there are some simple mechanisms in my ad package, but they are just naive gradient ascent, and the higher householder methods, etc.
21:09:24 <edwardk> dbelange: nah, just 2
21:09:32 <tgeeky> dbelange: Jay-Z? Or Martin Luther?
21:10:05 <edwardk> ktklam9: not true, http://hackage.haskell.org/packages/archive/ad/1.3.0.1/doc/html/Numeric-AD-Newton.html http://hackage.haskell.org/packages/archive/ad/1.3.0.1/doc/html/Numeric-AD-Halley.html
21:10:07 <dbelange> Jay-Z; I count _Jews And Their Lies_ as a hundredth thesis for Luther
21:10:27 <edwardk> ktklam9: though they aren't all that robust, you can use the ad package to get you derivatives to use for stronger methods.
21:10:29 <lispy> > let Term↑ = 3 in Term↑
21:10:30 <lambdabot>   <no location info>: parse error on input `='
21:10:54 <lispy> I take it ↑ is not valid inside a haskell identifier?
21:10:56 <edwardk> i do some dedicated optimization in a little train track dsl i did for this last summer's domain specific workshop up at mcmaster as well
21:11:12 <geekosaur> you can't mix letter and symbol characters, no
21:11:32 <edwardk> there i had to deal with the fact that i was hill climbing in homogeneous coordinates, so i had to cut down degrees of freedom to avoid swimming in the null space
21:11:53 <edwardk> lispy: probably an operator?
21:12:10 <lispy> edwardk: this paper defines a type Term↑ and I just wanted to do that literally if I could
21:12:11 <rwbarton> > let x ↑ y = x ^ y in 3 ↑ 4
21:12:12 <lambdabot>   81
21:12:13 <edwardk> > let x ↑ y = x + y in 2 ↑ 3
21:12:14 <lambdabot>   5
21:12:21 <ktklam9> edwardk: that is only for functions that are R -> R, I'm thinking about optimizing functions R^n -> R
21:13:00 <edwardk> ktklam9: um, the gradientAscent and gradientDescent in there are R^n -> R
21:13:28 <rwbarton> > let a𐍊 = 3 in a𐍊
21:13:29 <lambdabot>   <no location info>: lexical error at character '\66378'
21:13:52 <ktklam9> edwardk: well, that is Gradient Descent...
21:14:09 <geekosaur> right, letter characters make an identifier, symbols an operator.  the unicode spec is used to determine which is which
21:14:23 <rwbarton> > let aꜛ = 3 in aꜛ
21:14:24 <lambdabot>   <no location info>: lexical error at character '\42779'
21:14:37 <edwardk> ktklam9: yeah, its naive.
21:15:02 <edwardk> ktklam9: what i was trying to say was that there are at least some methods in there, and all the tools to calculate gradients which you can use for less naive methods
21:15:14 <ktklam9> edwardk: I'm thinking about full-fledged optimization, using better algorithms like Conjugate Gradient, BFGS, along with Line Search
21:15:19 <edwardk> yep
21:15:34 <edwardk> i've been meaning to add those to the package
21:17:51 <edwardk> i actually should dump conjugate gradient in there. i have code already
21:19:22 <ktklam9> edwardk: what line search are you using along with Conjugate Gradient?
21:19:44 <Enigmagic> ktklam9: what are you trying to optimize?
21:20:03 <edwardk> newton or gradient descent
21:20:55 <ktklam9> edwardk: are you using Strong Wolfe conditions for termination?
21:21:15 <ktklam9> because exact line search can be very expensive?
21:21:33 <edwardk> pretty sure the code i had was pretty naive
21:22:47 <ktklam9> Enigmagic: I'm trying to optimize for feed-forward neural networks
21:23:55 <ktklam9> edwardk: if it is ok with you, can I see what you have for Conjugate Gradient so far?
21:24:21 <Enigmagic> i meant, what problem are you trying to solve? not the algorithm
21:24:22 <edwardk> I'm not sure where it is, honestly
21:24:48 <lispy> :t (!!) -- this really should be something other than Int, even Word would be better
21:24:49 <lambdabot> forall a. [a] -> Int -> a
21:24:58 <edwardk> send me your email address and i'll make a note to email you if i stumble on it
21:25:35 <edwardk> sadly the haskell community back int he dawn of history decided to error on the side of convenience over correctness ;)
21:25:43 <Enigmagic> lispy: how would you index into lists of negative length then?
21:27:01 <Enigmagic> edwardk: fromIntegral silently truncates values too
21:29:41 <lispy> Enigmagic: how often do you have lists of negative length?
21:30:49 <Enigmagic> lispy: all the time
21:31:30 <lispy> Enigmagic: example please :)
21:34:35 <Enigmagic> i'd try on here but i'm worried that lambdabot would catch fire
21:35:13 <edwardk> lispy: they are virtual lists. ask byorgey.
21:36:22 <edwardk> > length $ replicate (maxBound + 1) 0
21:36:23 <lambdabot>   0
21:36:28 <edwardk> :t replicate
21:36:29 <lambdabot> forall a. Int -> a -> [a]
21:36:52 <edwardk> > maxBound :: Int
21:36:52 <lambdabot>   9223372036854775807
21:37:01 <edwardk> confused
21:37:10 <danharaj> hooray
21:37:13 <danharaj> I fixed my time leaks.
21:37:23 <danharaj> lispy: Thanks for pointing out retainer profiling. Was crucial.
21:37:24 <byorgey> lists of negative length are presumably things such that the type of pairs of negative lists and normal lists is isomorphic to Void.
21:37:30 <edwardk> danharaj: congratulations on getting your sunday back ;)
21:37:40 <danharaj> edwardk: oh my god exactly
21:37:51 <byorgey> since the generating function for lists is 1/(1 - X) we can thus compute the generating function for nega-lists as 1 - X
21:38:17 <danharaj> byorgey: Your faux calculus reminds me of a physicist doing renormalization.
21:38:28 <edwardk> danharaj: sadly its not even faux calculus
21:38:35 <edwardk> it actually works =P
21:38:39 <danharaj> :p
21:38:41 <byorgey> so we conclude that if you have Either a nega-list of a's or an a, you have a unit.
21:38:56 <byorgey> I am only half making this up ;)
21:39:08 <danharaj> I'm waiting on someone defining i
21:39:12 <shachaf> byorgey: Let me guess: You're making up the negative half?
21:39:34 <edwardk> shachaf: byorgey already blogged how to deal with virtual species for normal people
21:39:46 <byorgey> shachaf: no, I am making up the half where I give an intuitive semantics to virtual species.
21:39:58 * shachaf should read that, then.
21:43:06 <edwardk> byorgey: just found the little tridiagonal solver in diagrams, didn't know that algorithm. neat!
21:45:53 <byorgey> edwardk: yeah, that's all fryguybob's doing
21:45:59 <byorgey> it is indeed neat =)
21:46:51 <danharaj> what are the semantics of deepSeq?
21:47:05 <danharaj> I think I need this to get rid of my leaks once and for all
21:47:21 <edwardk> byorgey: gah, can't specify conditions for the endpoints of the spline
21:47:36 <edwardk> ok, going to actually sit down and spend the 20 minutes i spent 2 hours procrastinating on
21:48:11 <byorgey> edwardk: indeed, http://code.google.com/p/diagrams/issues/detail?id=66
21:48:33 <edwardk> yep
21:50:06 <edwardk> in my case i have a bunch of colorimetry data, which describes tristimulus light response, and i need to take a bunch of historically measured data points, turn them into a cumulative total, then spline the cumulative distribution of them, so i can ask for piecewise integrals and get derivatives
21:50:33 <edwardk> ut for that i can't use a natural spline for the end
21:52:03 <edwardk> http://en.wikipedia.org/wiki/CIE_1931_color_space#Color_matching_functions these things
21:52:29 * shachaf wonders what edwardk is doing.
21:52:43 <edwardk> shaving a yak
21:52:56 <ion> Nice euphemism.
21:53:02 <edwardk> But I'm not sure what color the yak is
21:53:41 <shachaf> edwardk, pioneer of yak racism
21:53:58 <edwardk> Playing with an idea for how to more efficiently bounce light around in metropolis light transport by using automatic differentation
21:54:17 <sipa> who says that yak races are distinguished by color? :p
21:54:34 <edwardk> but if i'm going to build a core for that style of raytracer i'd like it to be photometrically accurate
21:54:59 <edwardk> an so i need a standard observer model so i can actually use real light wavelengths
21:55:18 <edwardk> otherwise flourescent lights won't mess up the look of a room ;)
21:56:11 <edwardk> and so i'm now finding myself 9 steps removed from my original problem and trying to figure out a nice way to encode spectral data and get all the derivatives i need
21:56:13 <byorgey> it's the yak *skin* color that determines their race.  That's why you need to shave them.
21:56:18 <edwardk> yep
21:56:30 <edwardk> how can i know which yaks i don't like unless i shave them first?
21:57:07 <byorgey> edwardk: it sounds like you have progressed beyond yak shaving to yak razor design
21:58:44 <edwardk> byorgey: especially when you consider that i'm trying to build a horribly bastardized notion of a "Riemann manifold Hamiltonian metropolis light transport renderer with NUTS" just to test a theory? =)
21:59:07 <byorgey> that too. =)
21:59:08 <edwardk> er I guess i should capitalize Metropolis as well
21:59:25 <edwardk> damnit, 3 proper names cluttering up my description
22:02:03 <edwardk> basically trying to figure out of hamiltonian monte carlo can be used to 'jump over' all those cosine terms that come up from light bouncing off walls in rendering equations.
22:03:56 <edwardk> i hate it when i say something like that and the channel falls silent =P
22:07:42 <ktklam9> edwardk: do you happen to have example codes of how to use your automatic differentiation package?
22:08:01 <ktklam9> edwardk: like to find gradient of a function R^n -> R?
22:08:14 <alpounet> do you mean that he doesn't document his packages enough? :P
22:08:21 <edwardk> grad (\[x,y] -> x * sin y) [1,2]
22:08:33 <edwardk> you can use any other Traversable than []
22:08:39 <edwardk> so if you have a Vector, that works fine
22:08:48 <ktklam9> edwardk: would Vector from hmatrix work?
22:09:35 <edwardk> sadly no, the Packed Vector format they use doesn't work with AD variables since they could be trees
22:09:42 <edwardk> the optimization doesn't work here
22:09:46 <edwardk> you can use Vector from Data.Vector
22:09:56 <edwardk> but not the ones in hmatrix
22:11:35 <danharaj> I've always wanted to write a matrix library based on repa, and hence vector, but I would not let myself half-ass it. Something like that needs to blaze as fast as possible.
22:11:48 <edwardk> i was talking to alberto at one point about making ad and hmatrix more compatible but he needed to split hmatrix into its GPL and BSD parts for that to be viable, and apparently hasn't gotten around to it
22:13:31 <edwardk> danharaj: i started one a few years back that was using observable sharing to deconstruct a series of requested matrix operations in such a way that i could figure out if the result was being used once or multiple times and split between destructive and non-destructive blas calls
22:13:53 <edwardk> but i didn't have the tag-bits package at the time
22:14:07 <ktklam9> edwardk: uhhh... is there any possibility of hmatrix becoming compatible with ad in the near future?
22:14:27 <edwardk> and so i couldn't deal with things like dot products which give you scalars and which can break out of the 's' phantom type argument you need
22:14:34 <ktklam9> because that would mean I won't have to write backpropagation for neural networks :)
22:14:45 <edwardk> ktklam9: not in the next few months
22:14:46 <edwardk> yeah
22:14:53 <edwardk> its nice, its a free backpropagator
22:15:20 <edwardk> you can of course serialize back and forth from Data.Packed.Vector to Data.Vector
22:16:00 <edwardk> in fact it'd be pretty much free, comparatively, because grad is going to refill the Data.Vector you give me with AD variables anyways before proceeding with your function
22:16:10 <Veinor> what does the MAIN cost center in GHC's -hc profiling output mean?
22:16:39 <edwardk> and hopefully Roman's magic vector stream code would fuse that with your Packed.Vector -> Vector transformation
22:17:49 <Enigmagic> Veinor: https://github.com/ghc/ghc/blob/master/rts/Profiling.c#L68
22:18:00 <ktklam9> edwardk: will reverse mode will automatically differentiate any function? even if it's R^n -> R^n -> R, so I can have something like f(x0,x1,x2) = h(x0,x1) + sin(x2), where h(x0,x1) = x0^2 + x1^3?
22:18:16 <edwardk> yep
22:18:27 <ktklam9> edwardk: cool, great work :)
22:18:28 <edwardk> it'll even do mixed mode for hessians
22:18:54 <edwardk> and you can compute derivative jets as well, if you need all of the higher order derivatives
22:19:51 <ktklam9> that is very cool, wish I had known about automatic differentiation before writing a manual backpropagation
22:20:54 <edwardk> ktklam9: yeah. i wrote it in response to http://stackoverflow.com/questions/2744973/is-there-any-working-implementation-of-reverse-mode-automatic-differentiation-fo
22:21:20 <edwardk> the HNN guys were going to use it at one point, but that project seems to have stalled
22:21:33 <edwardk> (or at least moved off my radar)
22:21:45 <alpounet> no, the project has stalled for now :p
22:22:04 <edwardk> well, guess that answers that
22:22:06 <edwardk> =)
22:22:21 <ktklam9> I think it's because they were going with a graph implementation for the network
22:22:35 <ktklam9> made it too complicated, in my opinion
22:22:41 <edwardk> yeah, i pushed for special cases, but oh well
22:23:08 <Veinor> Enigmagic: so what does it mean if MAIN is my biggest cost center?
22:23:13 <edwardk> but at least the derivatives are easy (as long as you stay acyclic)
22:24:03 <Veinor> it's still MAIN even when i profile by module
22:24:31 <Enigmagic> Veinor: that means you don't have enough SCC annotations. if you have a simple app try rebuilding with -auto-all -caf-all
22:24:58 <zzo38> I have thought of something about ephemeris program. Perhaps have an ephemeris interface type:  (IO x, x -> IO (), Word16 -> Word32 -> x -> IO (Either EphemerisError ((Double, Double, Double), (Double, Double, Double), (Double, Double, Double)))   could be a type.
22:25:23 <zzo38> Do you know if there is anything like this?
22:26:24 <zzo38> Or probably the first part can be    String -> IO x    so that you can specify options such as a directory of ephemeris files, when you are initializing it.
22:26:51 <zzo38> And the third one I forgot, it need the date/time input too.
22:27:58 <Veinor> Enigmagic: tried that, still nothing
22:28:19 <zzo38> (I am thinking of the Word16 as the major object number, Word32 as minor object number, and the return value the XYZ coordinates of three things: the center, the north pole, and the zero longitude reference. So that, you can calculation rotation of planets and so on.
22:31:11 <Enigmagic> Veinor: did it actually rebuild? you may need to add -fforce-recomp
22:31:45 <Veinor> did a cabal clean
22:32:50 <alpounet> edwardk, ktklam9, well yeah there has been quite some discussion, and in the end i wanted a simple Data.Vector based version for feed-forward NNs and Tom would have had his graph impl for fancy neural networks
22:33:38 <edwardk> alpounet: well, i did finally release that graphs package
22:33:49 <edwardk> alpounet: so you are free to use it ;)
22:34:22 <danharaj> edwardk: Is your code lying around somewhere? Might be something cool to look at and maybe hack on.
22:34:51 <edwardk> danharaj: not sure. maybe on github
22:35:07 <alpounet> well i have a much bigger and more important project now :p and i've been discussing with ktklam9 by email and pretty much decided to let his library be the "default" one for NNs in Haskell
22:35:13 <Veinor> yeah i tried one more time, watched gcc compile it, and it's still mostly MAIN
22:35:33 <Veinor> also it's reporting usage of like 550k when i know the actual usage is much higher
22:36:30 <alpounet> edwardk, meaning that if i put efforts in a NN library, i'd most likely just focus on his and submit patches
22:36:32 <Enigmagic> Veinor: do -Pa profiling runs work?
22:36:34 <edwardk> danharaj: I have a half dozen of these sorts of 'observably share to get the DAG, compile down to something more interesting, send it off and get back an answer' type of DSLs. The BLAS problem is actually pretty easy except for the tricky side-condition where you need to actually evaluate early for things like dot products, etc.
22:36:48 <Veinor> -Pa?
22:36:54 <Enigmagic> Veinor: instead of -hc
22:37:57 <Veinor> it gives me a bunch of output
22:38:00 <Veinor> in foo.prof
22:38:11 <Enigmagic> Veinor: does it look more like what you'd expect?
22:38:32 <Veinor>         total alloc = 8,764,326,104 bytes  (excludes profiling overheads)
22:38:42 <Veinor> i'm pretty sure it didn't use 9 GB of ram :)
22:38:52 <Enigmagic> total allocations, not max heap size
22:39:03 <Veinor> it doesn't list that anywhere
22:39:12 <edwardk> danharaj: i'm pretty sure i stalled in the infrastructure phase when i was trying to figure out how to clear all the concerns i had that were blocking me. notably not having a way to make the unevaluated matrix operation tree and the (lazily) evaluated tree exist side-by-side and check if i'd had to evaluate the lazy slow path version
22:39:22 <edwardk> now i could do that, but at the time i didn't have the trick yet
22:39:50 <Enigmagic> Veinor: i mean do the time/space assignments make sense there? the 9gb number is probably accurate
22:39:55 <Veinor> ah
22:40:24 <edwardk> so for instance a "Matrix s a" would be a pair of a syntax tree, and a lazy unevaluated result. carrying a phantom type parameter 's'.
22:40:25 <Veinor> i mean, the allocations make sense (it's mostly ByteStrings and i'm profiling a yesod project)
22:40:42 <edwardk> or Matrix s n m a -- not ure if i had dimensions in the types
22:41:20 <edwardk> and then if you went and took the dot product of two vectors, i'd just compute it by forcing the lazy result.
22:41:22 <danharaj> edwardk: the phantom type is to make sure those innards never leak out?
22:41:31 <edwardk> and otherwise i'd just keep building up the AST
22:41:39 <Veinor> but i'd still like to at least know what module is leaking :/
22:42:02 <edwardk> and then when you used a runMatrix :: (forall s. Matrix s a) -> …   i'd go through compile, and blas it away
22:42:51 <edwardk> and when you got there, you'd already have some of the nodes evaluated
22:43:53 <edwardk> so you'd substitute the answers for the evaluated nodes in the tree, and evaluate the rest destructively, returning the final answer
22:44:10 <Enigmagic> Veinor: i've found that the heap profiler isn't as accurate or reliable as the regular profiler
22:44:10 <edwardk> since you're amortizing the compilation cost over the cost of fairly expensive matrix ops it shouldn't be that bad
22:44:29 <Enigmagic> Veinor: even with 7.4.1 i have similar problems, so either there is a bug or the default options aren't very good
22:44:38 <Veinor> Enigmagic: sure, but I don't care if it's allocating a bunch of bytestrings if they're getting freed right after
22:44:40 <danharaj> edwardk: seems great for scientific use of linear algebra.
22:44:45 <edwardk> and the worst case is you just work with it lazily and ignore the AST (which would mean you'd sadly leak memory)
22:45:14 <Enigmagic> Veinor: i understand that. one thing you could try is the -hT profiler on a regular (non-profiled) build
22:45:19 <edwardk> but you could make the lazy usecase not leak memory by making 's' into a functor that you use to wrap the ast nodes.
22:45:35 <Veinor> -hT?
22:46:02 <edwardk> danharaj: thought so. i had a project folder called 'blase' for it at some point.
22:46:25 <Enigmagic> Veinor: regular builds have some limited profiling that ou can enable with -hT that is similar to -hy in a profiling build
22:46:53 <ozataman> has cabal-dev stopped separating built .hi files into separate package directories in its last release?
22:46:55 <edwardk> https://github.com/ekmett/blase/tree/master/Numeric/BLAS/Raw doesn't look like the version i uploaded had much in it
22:47:20 <ozataman> it totally messes up projects that indirectly depend both on MonadCatchIO-mtl and -transformers
22:48:06 <edwardk> danharaj: the code there appears to be from the raw api that i was working up in order to bolt the nicer sharing based api on top
22:48:23 <nyingen> is there some kind of primer on haskell arrays somewhere?
22:48:38 <nyingen> I'm trying to  work with CArray and I'm totally confused by its documentation
22:49:19 <edwardk> CArray?
22:49:30 <nyingen> Data.Array.CArray
22:49:38 <danharaj> edwardk: I never groked observable sharing. It seems a lot like fighting with the compiler.
22:49:48 <hpaste> rasfar annotated “SYB join -- seems to work?” with “SYB join -- seems to work? (annotation)” at http://hpaste.org/65130#a65139
22:49:55 <edwardk> danharaj: a little, but then you can get really really pretty DSLs
22:50:08 <edwardk> in 'ad' the code for dealing with it is about 8 lines.
22:50:11 <Veinor> ... huh, ok
22:50:32 <Veinor> i tried rebuilding on the actual thing i wanted to profile and it looks like it's the stack
22:50:38 <edwardk> nyingen: never heard of it. looking
22:50:39 <Veinor> time to rebuild with profiling and debug
22:51:52 <nyingen> edwardk: the haddock for CArray seems to assume I know a bunch of stuff about certain other Haskell array modules, and its totally opaque without that knowledge
22:51:52 <edwardk> nyingen: The Abs class in that package makes me sad =(
22:52:03 <edwardk> nyingen: why are you forced to use this module?
22:52:18 <nyingen> edwardk: I'm reading sound data using hsndfile, and passing it to a FFT
22:52:25 <nyingen> the latter module wants CArrays
22:52:29 <edwardk> ah
22:52:32 <edwardk> then you're stuck
22:53:07 <edwardk> http://hackage.haskell.org/package/array-0.4.0.0 is your starting point
22:53:10 <nyingen> no offense to the author of CArray, but its docs are a poster child for certain general problems with haskel lib docs
22:53:40 <edwardk> http://hackage.haskell.org/packages/archive/array/0.4.0.0/doc/html/Data-Array-IArray.html
22:53:43 <nyingen> no examples, no commentary on what the functions are for, no indication of when to use what, or what the applications are
22:54:03 <nyingen> edwardk: yeah, I looked at IArray a bit just now
22:54:18 <edwardk> > listArray (0,4) [1,2,3,4,5]
22:54:19 <lambdabot>   array (0,4) [(0,1),(1,2),(2,3),(3,4),(4,5)]
22:54:39 <edwardk> > listArray (LT,GT) [5,6,7]
22:54:40 <lambdabot>   array (LT,GT) [(LT,5),(EQ,6),(GT,7)]
22:55:07 <edwardk> > listArray ((0,LT),(4,GT)) [ 1 .. ]
22:55:08 <lambdabot>   array ((0,LT),(4,GT)) [((0,LT),1),((0,EQ),2),((0,GT),3),((1,LT),4),((1,EQ),...
22:56:03 <ktklam9> edwardk: I'm having trouble, getting this to compile http://hpaste.org/65142, it uses your automatic differentiation package, what am I doing wrong?
22:56:07 <nyingen> how abou multidimensional arrays?
22:56:08 <edwardk> you can do updates with //  use amap to map over them and (!) to access a member
22:56:19 <edwardk> your type signatures
22:56:37 <edwardk> nyingen notice the array ((0,LT),(4,GT)) example i gave
22:56:58 <edwardk> thats a 2 dimensional array the first dimension is indexed by numbers from 0 .. 4, the second by Orderings, from LT to GT
22:57:05 <nyingen> I see
22:57:34 <edwardk> then you can index that multidimensional array with foo ! (3,EQ)  just like you can with any unidimensional array
22:57:46 <edwardk> the Ix class takes care of converting from the index to a raw number
22:57:49 <nyingen> can I transform a 1d array into a 2d array where each row of the latter is a slice of the former?
22:58:19 <edwardk> ktklam9: the AD package would use h :: Mode s => [AD s Double] -> AD s Double
22:58:55 <edwardk> or more succinctly h :: Num a => [a] -> a -- if you swap **2 and **3 for ^2 and ^3 respectively
22:59:09 <edwardk> the latter is better because it gives nicer derivatives anyways
22:59:20 <edwardk> and because it still permits easy testing
22:59:35 <edwardk> if you have something that really is a Double and you need to turn it into an AD s Double, use 'lift'
23:00:12 <edwardk> if you aren't worried about perturbation confusion you can use 'vgrad' instead of grad
23:00:30 <edwardk> then you can write h x0 x1 = x0^2 + x1^3
23:00:42 <edwardk> f x0 x1 x2 = h x0 x1 + sin x2
23:00:47 <ktklam9> edwardk: ah ok, I see, thank you
23:00:47 <edwardk> g = vgrad f
23:01:50 <edwardk> the 's' in AD s a is the AD mode, and quantifying over it is how i keep you from accidentally getting perturbation confusion problems
23:01:58 <Veinor> argh
23:02:09 <Veinor> if i compile it with profiling enabled, i get useless information
23:02:30 <edwardk> there are some blog posts out there that describe the sorts of wrong answers that you could get if you use vgrad on a function that uses vgrad and aren't super careful about getting the number of 'lift's right
23:02:33 <Veinor> if i compile it with profiling disabled and use -hT, i get accurate information
23:02:46 <edwardk> but grad is immune to those problems thanks to the quantifier
23:03:30 <edwardk> ktklam9: also you don't need to import Reverse. Just import Numeric.AD
23:03:43 <edwardk> it'll bring in the right combinators from each mode to get optimal behavior
23:03:51 <edwardk> that way if you use 'diff' it can use forward mode
23:03:57 <edwardk> but it'll use reverse for grad, etc.
23:04:21 <edwardk> its entirely invisible to you and its a lot faster when it can sneak in a provably fast forward mode evaluation
23:05:52 <edwardk> http://hackage.haskell.org/packages/archive/ad/1.3.0.1/doc/html/Numeric-AD-Mode-Mixed.html has the docs of what gets imported (it also brings in some Newton method stuff)
23:06:20 <edwardk> each section in that file includes in parentheses what AD mode is being used for each operation in it
23:08:30 <ktklam9> edwardk: if I use Data.Packed.Vector from hmatrix and uses operations vector dot product, can I still use AD?
23:08:50 <edwardk> you can't pack AD variables
23:09:04 <edwardk> otoh vector dot product is pretty easy to code up on Data.Vector
23:09:26 <edwardk> dot as bs = Vector.sum $ Vector.zipWith (*) as bs
23:09:35 <ktklam9> edwardk: well if there is a dot product for Data.Vector, then AD can be used right?
23:09:43 <edwardk> yes
23:09:54 <edwardk> that dot above would work fine
23:09:59 <Veinor> 1:59:50            <edwardk> if you aren't worried about perturbation confusion you can use 'vgrad' instead of grad
23:10:01 <Veinor> 03:00:08            <edwardk> then you can write h x0 x1 = x0^2 + x1^3
23:10:10 <Veinor> edward, did it really take you an hour to continue your train of thought?
23:10:19 <edwardk> veinor: yep
23:10:29 <edwardk> veinor: you might also note daylight savings time ;)
23:10:33 <Veinor> pff!
23:11:11 <ktklam9> doesn't it make more sense to have a linear algebra package based on Data.Vector?
23:11:54 <edwardk> ktklam9: yes
23:12:31 <edwardk> ktklam9: i have an algebra package, but its focused on a very different view of linear algebra
23:13:31 <ktklam9> edwardk: what does it have?
23:14:07 <edwardk> ktklam: http://hackage.haskell.org/package/algebra
23:14:20 <edwardk> in particular it focuses on vector spaces described as free modules or free vector spaces (e -> r)  for some ring/field r, and their covectors described as (e -> r) -> r
23:14:55 <edwardk> i should probably actually pull that part out into a separate package, since most of that doesn't need the crazy algebra classes
23:15:01 <edwardk> and i love that covector monad
23:15:23 <ktklam9> edwardk: does it have elementary operations and some things like cholesky decomposition?
23:15:37 <ktklam9> that's all I really need >_>
23:16:02 <edwardk> its not a linear algebra library, its an abstract algebra library that grew to cover things like geometric algebra, and which deals with vector spaces kind of by accident ;)
23:17:20 <edwardk> there is a vector-space package but it doesn't have cholesky
23:32:43 <ktklam9> if I was going to make a linear algebra out of Data.Vector, what would be an efficient way to represent a matrix?
23:33:34 <edwardk>  Vector (Vector a)
23:33:46 <edwardk> i'm actually thinking i might bundle a linear-algebra package up
23:34:12 <edwardk> i'd rather not tie to Vector, but rather make Vector a special case
23:34:27 <edwardk> the approach I used in 'ad' has been really nice to work with
23:34:36 <edwardk> you can use whatever vector types you want there, and it just works
23:34:56 <ktklam9> edwardk: well, I hope you do, because I want to use your ad package, would make life a lot easier ;)
23:35:03 <edwardk> =)
23:35:30 <edwardk> fortunately i'm about to write a lot of code that needs a lot of linear algebra, so your pain point is close to mine ;)
23:35:57 <edwardk> otoh, i'd been planning on just limping by on functors for particular vector lengths, etc.
23:37:16 <edwardk> but i need cholesky decomposition to compute an certain positive definite matrix that comes up in hamiltonian monte carlo
23:37:38 <edwardk> so i suppose solving the general problem isn't that bad an idea
23:38:25 <ktklam9> edwardk: if you do pursue it, how long do you think it would take to get it done?
23:39:13 <edwardk> not sure. i'm sitting here trying to figure out how to get Covector out of algebra without all the crazy classes for super fine grained numeric hierarchies
23:40:32 <edwardk> talk to me tomorrow. it'll either be done or i'll know why i can't do what i want, or i'll have moved on ;)
