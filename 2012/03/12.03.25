00:07:00 <NihilistDandy> byorgey: Any details on your Williams talk in April?
00:22:41 <mikeplus32> is there a mapM/mapM_ for Arrays?
00:24:34 <mikeplus32> there is mapM in Data.Traversable, but that pretty much converts the array to a list then runs mapM over it
00:40:51 <liyang> mikeplus32: I think the list in that case will get fused away.
00:41:56 <liyang> Check the Core, Luke.
00:50:38 <mikeplus32> also, how are you meant to use Data.Vector.Unboxed.Mutable.new? I have to give it a type sig. but  have no idea of what it should look like
00:50:43 <mikeplus32> liyang: ok, thanks
01:04:23 <mikeplus32> and, what's the equivalent for mapM_ for Data.Vector.Unboxed.Mutable (.Safe ?)?
01:05:25 <mikeplus32> oh I see, Data.Vector.Generic has it
01:05:33 <mikeplus32> but: is there a imapM_?
01:16:17 <mikeplus32> actually, it isn't :(
01:21:24 <mikeplus32> I would "just" use repa but it is broken with ghc 7.4.1
01:25:39 <liyang> What's imap supposed to be? map with an extra index argument?
01:26:40 <Taneb> @hoogle imap
01:26:40 <lambdabot> package bimap
01:27:00 <liyang> I think that's a different kind of imap.
01:27:06 <Taneb> So do I
01:27:59 <Taneb> Where's your imap?
01:33:42 <liyang> mikeplus32: by imapM_, do you mean something of type (Int -> a -> m ()) -> v a -> m () ? You can write one in terms of ifold[lr]'?. I wouldn't call it imapM_ though; traverseWithKey_ seems more appropriate.
01:33:48 <liyang> Also, see http://hackage.haskell.org/packages/archive/keys/latest/doc/html/Data-Key.html
01:36:40 <mysticc> Some comments on improving the readability and getting rid of if possible if else and cases or a better composition version of this small code : http://paste.pocoo.org/show/570880/
01:42:06 * hackagebot nsis 0.1.2 - DSL for producing Windows Installer using NSIS.  http://hackage.haskell.org/package/nsis-0.1.2 (NeilMitchell)
01:43:15 <hiptobecubic> Is there a way to extend a datatype?
01:44:34 <liyang> mysticc: http://paste.pocoo.org/show/570886/
01:44:52 <hiptobecubic> For example ordering is defined as LT | GT | EQ, but if i want to use (>) with types like (Num a => Foo a), then i need (Foo LT | Foo GT | Foo EQ)...
01:45:50 <Axman6> i don't understand the question
01:46:12 <Taneb> instance Ord (Foo a) where Foo a `compare` Foo b = a `compare` b
01:46:26 <Axman6> Foo a is a type, and presumably you can implement instalce Ord a => Ord (Foo a)
01:46:27 <liyang> mysticc: if you need to do something more complicated in the "not bool" case, I'd turn that whole if/then/else into a case bool of …
01:46:44 <hiptobecubic> Taneb, but that returns an Ordering and need a Foo Ordering
01:46:59 <Axman6> why do you think you need that?
01:47:05 <Taneb> Why would you need a Foo Ordering?
01:47:08 <c_wraith> hiptobecubic: you don't need a Foo Ordering to use (<)
01:47:11 <mysticc> liyang: Thanks
01:48:37 <liyang> mysticc: hpaste.org has syntax highlighting.
01:48:43 <hiptobecubic> I know it could be done with just an ordering, but I'm looking at this paper which is making a combinator library and they are making functions like (%>) and (%<) to do ordering comparisons because "Haskell's type system does not work quite so smoothly for relational operators, such as (<)"
01:49:13 <hiptobecubic> then they are defining them as, for example, (%<) = lift2 (<)
01:49:22 <hiptobecubic> to stay 'in' the Foo type
01:49:37 <hiptobecubic> Why, I don't know yet. But i was wondering what the issue was and why it couldn't be done
01:49:41 <Axman6> so, you need Ord a => Foo a -> Foo a -> Foo Ordering, for use in a DSL?
01:50:02 <hiptobecubic> Axman6, that's what they are doing, i guess. Yes.
01:50:18 <mysticc> liyang: What do you use on terminal for pasting on it
01:50:28 <hiptobecubic> http://i.imgur.com/E5UMo.png
01:52:00 <Saizan> hiptobecubic: it wouldn't make sense to solve this problem by extending the Ordering datatype
01:52:11 <hiptobecubic> Saizan, why wouldn't it?
01:52:45 <Axman6> hiptobecubic: yes, so they're defining a DSL, and the need to represent things like ordering at their language level, which doesn't work with haskell's Ord class. Ord is designed for ordering haskell types, not anything else, hence the need to create new functions for this job
01:53:04 <Saizan> hiptobecubic: well, first Foo LT doesn't make sense because LT is not a type(same for EQ and GT)
01:53:05 <liyang> mysticc: I copy and paste into my browser. :-/
01:53:24 <hiptobecubic> Saizan, Foo Ordering would be a type
01:53:40 <hiptobecubic> so Foo LT would be a value of that type, no?
01:53:48 <Saizan> hiptobecubic: no
01:54:14 <Saizan> hiptobecubic: not necessarily, it depends on how Foo is defined
01:54:40 <hiptobecubic> Saizan, can you elaborate? I don't see it.
01:54:46 <Axman6> assuming data Foo a = Foo a i think
01:54:53 <hiptobecubic> yes
01:55:19 <hiptobecubic> Sorry, yes. Type and Type Constructor are the same in this case.
01:55:48 <Saizan> is that how they are defining Obs in that paper?
01:56:37 <Saizan> anyhow, even if you had data Ordering = LT | EQ | GT | Obs Ordering as a result of extending Ordering that would still not be what you want
01:57:57 <Saizan> | C (Obs Ordering), even
01:59:57 <hiptobecubic> I think so, but i'm still working it otu
02:00:30 <hiptobecubic> Saizan, what is it that you think I want? Maybe I don't understand it enough to know what I should be wanting here.
02:01:41 <Saizan> you want Obs Ordering in place of Ordering in the signature of compare, you don't want to mess with Ordering itself otherwise Obs Ordering will change meaning too
02:02:06 * hackagebot cmdargs 0.9.4 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.9.4 (NeilMitchell)
02:02:08 * hackagebot cmdargs 0.9.5 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.9.5 (NeilMitchell)
02:02:17 <Saizan> so one way would be to make Ord a multiparam typeclass so that you can specify those as well
02:02:39 <Saizan> s/those/result types of the comparisons/
02:03:00 <hiptobecubic> as in Ord m a ?
02:03:09 <Axman6> then you'd need to do things like sort :: Ord a Ordering => [a] -> [a] right?
02:03:19 <hiptobecubic> and then "normal" orderings would be what?
02:03:55 <Axman6> hmm. there's quite a few ways to implement this even with a MPTC.
02:03:56 <Saizan> class Ord a o b where compare :: a -> a -> o; (>) :: a -> a -> b; ...
02:04:19 <Axman6> and current Ord a would become Ord a Ordering Bool
02:04:26 <Saizan> so that Ord a Ordering Bool would correspond to the original typeclass
02:04:28 <Axman6> ok, that makes sense
02:05:16 <hiptobecubic> hmm
02:05:45 <mikeplus32> Taneb: liyang: what I'm looking for is a map, mapM and imap (map with an extra index argument, yeah) for Data.Vector.Unboxed.Mutable.Safe vectors, but can't find any
02:05:50 <Saizan> if you choose the class Ord a m where compare :: a -> a -> m Ordering way than you can use Ord a Identity for something isomorphic to the original
02:06:13 <Axman6> but horrible to use...
02:06:43 <hiptobecubic> I can see that this is kind of a mess
02:07:08 <mikeplus32> I can simply read each element then write each element but I want to know if there is a better way
02:12:06 * hackagebot hlint 1.8.25 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.25 (NeilMitchell)
02:15:48 <alistra> there should be a death sentence for not making changelogs :P
02:17:27 <Saizan> mikeplus32: that might be slower than using the Traversable instance
02:21:54 <hiptobecubic> If i define "instance Eq a => Eq (Foo a) where (==) (Foo a) (Foo b) = a == b", why does "Foo 3 == 3" type check? Shouldn't it require "Foo 3 == Foo 3" ?
02:22:30 <c_wraith> hiptobecubic: not if Foo a is an instance of Num
02:22:46 <c_wraith> hiptobecubic: remember, numeric literals are polymorphic
02:22:58 <hiptobecubic> ahhh
02:23:12 <hiptobecubic> So it's inferring the type of 3 to be Foo 3, instead of say Double 3
02:23:39 <hiptobecubic> Well, Foo 3 instead of 3.0, let's say
02:23:47 <c_wraith> it's probably actually inferring Foo Integer
02:23:56 <hiptobecubic> Sure
02:23:57 <Saizan> Foo 3 is not a type
02:24:07 <hiptobecubic> Foo Integer, yes.
02:24:17 <yasar> I am trying to solve problem 13 in here: http://www.haskell.org/haskellwiki/99_questions/11_to_20 , I did this: http://codepad.org/DWMt4kg8 , but It won't compile. Can someone help?
02:24:19 <hiptobecubic> the value of 3, i should have said
02:25:06 <hiptobecubic> wow. Is there a way to get these error messages from ghc? These are much easier to read
02:25:36 <Saizan> those are from hugs
02:25:40 <BlankVerse> how should a ptr to a particular location in the file be stored ?
02:25:43 <hiptobecubic> yasar, looks like you need (flip myhelper)?
02:26:51 <mikeplus32> Saizan: there is a Traversable instance for an unboxed mutable safe vector?
02:26:53 <mikeplus32> :o
02:27:26 <Saizan> mikeplus32: ah, no, different type
02:27:28 <Axman6> BlankVerse: probably an Int64 (or better yet, Word64)
02:27:37 <savask> Hello. I have a small problem with reactive-banana - I can't express one idea in terms of behaviours and events. I have a random number behaviour which is generated on event egot. But I want that number satisfy the predicate held in another behaviour. How can I do so?
02:28:01 <mikeplus32> Saizan: damn.
02:28:12 <hiptobecubic> Funny. People were saying earlier how hugs' error messages were no longer more readable than ghc. I humbly disagree
02:28:57 <c_wraith> hiptobecubic: it has somewhat less information than GHC's error message.  You just like *s, apparently
02:29:54 <Axman6> yasar: i think you simply need to swap the order of the arguments in myhelper
02:30:40 <yasar> Thank. I did, no more syntax error. Now I am trying to getting it work correctly :)
02:31:13 <hiptobecubic> c_wraith, no. It's easier to read. Instead of writing me a paragraph about it, it just lists offending code in a way that's easy to spot the differences between actual and expected types
02:31:15 <c_wraith> yasar: an infinite type is not a syntax error.
02:31:31 <BlankVerse> is it possible to store a Maybe Word32 in 4 bytes?
02:31:44 <hiptobecubic> BlankVerse, seems unlikely
02:32:04 <Axman6> BlankVerse: well, Maybe Word32 has strictly more than 32 bits of information =)
02:32:46 <Saizan> BlankVerse: 4 bytes are only enough for Word32
02:40:03 <shachaf> Only if your bytes are 8-bit bytes.
02:41:54 <c_wraith> personally, I don't think 93 is a number you really need.  You can map it to Nothing
02:42:45 <shachaf> c_wraith has a point.
02:42:46 <shachaf> > chr 93
02:42:47 <lambdabot>   ']'
02:42:52 <shachaf> Who needs those anyway?
02:47:53 <Axman6> BlankVerse: does the value 0 make sense for where you're using it? if not, it could be your Nothing representation (sort of makes sense if you're talking pointers, unless you need zero offset pointers)
02:51:12 <zzo38> Is it possible to make Alternative for (ContT r m) if r is Monoid and m is Applicative? It does seem to me.
02:51:56 <zzo38> (That also means you could make MonadPlus since ContT is always monad regardless of m)
02:55:02 <BlankVerse> Axman6: cool , so I can make a word32 of 0 as Nothing and all other Word32 as Just Word32 :)
02:55:50 <hpaste> mikeplus32 pasted “repa install failure” at http://hpaste.org/65932
02:56:11 <c_wraith> BlankVerse: you can do that for any fixed 32-bit pattern. *if* you choose to do that, make the choice of which one very carefully
02:56:16 <mikeplus32> anyone know what I should do to fix this?
02:59:30 <alpounet> mikeplus32, it seems you've hit http://hackage.haskell.org/trac/ghc/ticket/5704
03:00:53 <zzo38> It also seems that if r is a ring then (Cont r) also forms a ring, but not necessarily a computable ring.
03:01:16 <bbommarito> Morning all.
03:01:42 <mikeplus32> alpounet: ok, (damn), thanks
03:02:59 <mikeplus32> alpounet: bumping the TH version worked :)
03:04:55 <alpounet> mikeplus32, cool! what would also be cool would be to avoid such issues though... having the dependency hell is already too much :p
03:05:05 <mikeplus32> yeah
03:05:28 <mikeplus32> but I'm a helpless end user, don't hurt me
03:05:43 <alpounet> heh
03:10:49 <killy9999> I'm trying to understand how function composition and $ work
03:11:09 <killy9999> If I have: a . b . c $ d then . have higher priority than $
03:11:22 <mekeor> correct.
03:11:32 <killy9999> does this mean that a . b . c first creates partially applied function
03:11:44 <killy9999> and then passes value after the $ to that function?
03:12:22 <ChristianS> yes
03:13:14 <mauke> well, it's not really partially applied
03:13:22 <mekeor> a . b . c $ d == (a . (b . c)) d -- right, mauke?
03:13:31 <mauke> I don't know
03:13:40 <Axman6> something like that anyway
03:13:51 <mekeor> ((.) is infixr)
03:14:21 <mauke> then yes
03:14:22 <killy9999> $ is also inficr,  but it has priority 0 so thant's rather irrelevant in that case
03:15:10 <mekeor> killy9999: i wasn't sure whether it's (a . (b . c)) or ((a . b) . c) …
03:15:17 <mekeor> :t (.)
03:15:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:15:35 <mekeor> that's lambdabot feature, right?
03:15:38 <killy9999> ah, right
03:15:51 <mekeor> (.) :: (b -> c) -> (a -> b) -> a -> c
03:15:54 <mauke> mekeor: not quite, it's in a module somewhere
03:16:06 <mekeor> mauke: anyway…
03:16:07 <mauke> just an import
03:16:11 <mekeor> yea
03:16:43 <killy9999> mhm, so my example is equivalent to (a . b . c) d
03:16:46 <mekeor> so, yes, actually in your example, killy9999, (.) is partially applied…
03:16:51 <killy9999> ok, now this makes sense to me
03:16:53 <mekeor> killy9999: exactly
03:17:10 * hackagebot gloss 1.7.0.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.0.1 (BenLippmeier)
03:17:12 * hackagebot gloss-examples 1.7.0.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.0.1 (BenLippmeier)
03:17:12 <mauke> @src (.)
03:17:12 <lambdabot> (f . g) x = f (g x)
03:17:13 <lambdabot> NB: In lambdabot,  (.) = fmap
03:17:36 <mekeor> you can also think of (.) as type of :: (b -> c) -> (a -> b) -> (a -> c)
03:17:38 <mauke> if . was defined as f . g = \x -> f (g x), would it then be fully applied there?
03:18:24 <killy9999> hm...
03:18:28 <mekeor> actually, not, because that's still of the same type
03:18:37 <killy9999> monomorphisc restriction would allow it to be defined that way?
03:18:47 <mauke> sure, why not?
03:19:01 <zzo38> The document of gloss is not available yet; can you tell me if they support IO results for their actions?
03:19:05 <mauke> (.) = \f g x -> f (g x) might be a problem without a type signature but probably not
03:19:12 <mekeor> mauke: the type is still the same… so… it's still partiall applied, or not?
03:19:23 <mauke> mekeor: how do you define "partially applied"?
03:20:37 <mekeor> right, actually, there is no "partially applied" in haskell… (because of currying).  but i think, informally you say partially applied when given a function 'f :: a1 -> a2 -> ... -> an' you give it less than n arguments…
03:20:40 <killy9999> mauke: I'd defined is a closure with some variables unbound
03:20:50 <Axman6> hmm, ghci doesn't have a way to list all functions and their types in a specific module does it? that would be quite handy
03:20:55 <mauke> all variables are bound
03:21:37 <mekeor> i meant less then (n-1), i think…
03:21:40 <killy9999> well, yes.... function parameters unbound would be more correct to say?
03:22:30 <Modius> Warning: Defaulting the following constraint(s) to type "Integer" - what are good ways to make this go away?  I'm typing in thenumeric literal 5
03:22:39 <mauke> killy9999: is 'id length' partially applied?
03:23:08 <mauke> Modius: (5 :: Integer)
03:23:45 <killy9999> I think I see your point
03:24:29 <mekeor> Modius: the type of 5 is 'Num a => a'. the default instance of Num is Integer. since you don't say ghci which type you want it warns you that it uses the default type…
03:24:35 <killy9999> but I'd say yes, at least in the sense that I use "partially applied" for my own convenience
03:25:23 <killy9999> (id length) is not a concrete value, it still can accept some parameters
03:25:23 <mauke> :t [printf "%03d", show]
03:25:24 <lambdabot> forall a. (PrintfArg a, Show a) => [a -> String]
03:25:46 <mauke> > sequence [printf "%03d", show] 42
03:25:47 <lambdabot>   ["042","42"]
03:26:50 <reinoud> :-)
03:27:13 <zzo38> Axman6: I think the :browse command will tell you everything in the module you specify
03:27:42 <reinoud> i have a question regarding ghc and cabal: Is it possible to compile a program (ImplicitCAD in this case) that is normally build and installed with cabal without cabal?
03:28:29 <mekeor> zzo38: cool!
03:28:43 <ChristianS> reinoud: yes, you just have to do all the steps manually that cabal does automatically
03:30:06 <mauke> http://mauke.hopto.org/stuff/haskell/Makefile
03:30:14 <mauke> PREFIX=/usr/local make
03:33:06 <reinoud> tnx!
03:33:08 <reinoud> will try
03:35:29 <yasar> what is the difference between Int and Num ?
03:35:34 <bbommarito> Anyone have any suggestions for learning Haskell? Haskell has fascinated me for a few years now, and I finally have the time to sit down and start learning it.
03:35:53 <mekeor> yasar: there are lots of instances of Num: Float, Double, Integer, Int…
03:35:58 <yasar> bbommarito: http://www.haskell.org/haskellwiki/Meta-tutorial
03:36:03 <mekeor> yasar: Num is a type class. Int is a type!
03:36:12 <yasar> ohh, I see. Thanks.
03:36:31 <mekeor> (and Int is an instance of Num…)
03:36:39 <yasar> bbommarito: http://stackoverflow.com/questions/1012573/how-to-learn-haskell
03:37:34 <mauke> @where lyah
03:37:34 <lambdabot> http://www.learnyouahaskell.com/
03:38:19 <mekeor> yeah, that's best.
03:38:48 <mikeplus32> the "standard" way of removing cabal installed packages is simply ghc-pkg unregister pkg, right?
03:39:29 <bbommarito> mauke: I have seen mention of lyah, now I have to check it out.
03:40:07 <mikeplus32> bbommarito: lyah and rwh are excellent
03:40:13 <mikeplus32> there are some good pages on the wikibooks too
03:40:18 <mikeplus32> and the haskell.org wiki
03:40:34 <bbommarito> mikeplus32: rwh?
03:40:45 <mikeplus32> real world haskell
03:41:29 <mekeor> @where rwh
03:41:29 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:41:34 <vel> hello guyz, what compiler/library better supports ARM now?
03:41:46 <killy9999> bbommarito: I'm reading lyah at the moment
03:41:58 <bbommarito> killy9999: What do you think of it so far?
03:42:02 <killy9999> very nice tutorial, the only downside is the lack of exercises of any sort
03:42:08 <yasar> bbommarito: I suggest you start with "learn you a haskell", I am a beginner too, and "learn you a haskell" is more newbie friendly than real world haskell.
03:42:25 <yasar> killy9999: I support it with http://www.haskell.org/haskellwiki/99_questions
03:42:31 <hiptobecubic> I liked lyah, but I agree, it needs more practicing
03:42:37 <bbommarito> yasar: Beginner friendly as in not written Haskell, or beginner friendly as in 'never programmed before'?
03:42:45 <killy9999> so you have to be creative and come uo with your own problems
03:42:47 <mekeor> vel: all i know is that there's no ghcI (the interpreter!!!) for ARM. GHC exists for ARM. GHC is very good.  there's also hugs for ARM.  probably other compilers, too, but idk.
03:42:58 <yasar> bbommarito: not written haskell.
03:42:59 <hiptobecubic> yasar, yes, you need to pair it up with project euler or some other list of problems
03:43:07 <killy9999> or as yasar said, google 99 haskell problems
03:43:17 <killy9999> although I think their curve is pretty steep
03:43:26 <bbommarito> yasar: Okay, because the latter is not me.
03:43:27 <vel> oops misschan actually it was question about D, but mekeor thank you for answer
03:43:39 <mekeor> vel: lol, okay :D
03:43:49 <blackdog> killy9999: ... but a zygohistomorphic fold ain't one
03:43:53 <bbommarito> I don't know why I find Haskell so fascinating, but something about it intrigues me.
03:44:21 <hiptobecubic> Also the coding sites like codechef, codesprint, SPOJ, etc
03:44:27 <killy9999> I think that's the logic of the langiuage
03:44:27 <blackdog> bbommarito: it's because it won't take your wishy-washy underspecified crap:)
03:44:40 <blackdog> at least, that's been my experience
03:44:44 <killy9999> everything is soooo logical and makes sense
03:44:50 <bbommarito> blackdog: Maybe that, or maybe because it is so strict in no side-effects.
03:44:53 <yasar> bbommarito: Actually, I doesn't matter if haskell is your first pure functional programming language. It feels very strange and different at first. I was shocked when I first red there is no for and while loops in haskell
03:45:07 <killy9999> except for one thing maybe: Floats aren't ordered (Ord typeclass)
03:45:21 <bbommarito> yasar: That's what recursion + guard clause is for:)
03:45:28 <hiptobecubic> yasar, sure there are. map and for
03:45:39 <hiptobecubic> yasar, and list comprehensions
03:45:50 <killy9999> someone here once stated that project euler is not the best for haskell newbies
03:45:52 <mekeor> yasar: yes, me, too :D haha.  and also, i always wanted to change the value of variables and missed the ++ operator from C :D haha
03:45:52 <ChristianS> what's MonadRWS? it's part of the mtl package but i find no clear explanation...
03:45:56 <bbommarito> Hell, I work in Ruby day to day, and that has all the loops, but I tend to do recursion.
03:46:31 <hiptobecubic> bbommarito, does ruby do tail-call recursion smartly? python overflows
03:46:46 <blackdog> bbommarito: there are side effects. they just come along with an IO type:)
03:47:04 <bbommarito> hiptobecubic: No, it does not do tail-call, so you can run into lots of odd situations. Primarily stack overflows.
03:47:22 <yasar> hiptobecubic: Python sucks at tail call recursion, but you can use tail call optimize and/or memoize decorators for that.
03:47:43 <blackdog> bbommarito: i've worked in ruby for years - i even wrote a bridge between ruby and haskell
03:47:50 <hiptobecubic> bbommarito, yeah. I should get a tattoo: "Exception: Maximum Recursion Depth Exceeded"
03:47:50 <blackdog> but i've got more fundamentalist of late
03:47:57 <blackdog> ruby is not fit for purpose
03:48:00 <bbommarito> I am one of the odd ones (And co-workers sometimes hate me for this), that doesn't alter state in objects, merely return a new copy, and all that fun stuff.
03:48:37 <hiptobecubic> bbommarito, that's not good if the language isn't designed to handle things that way though. You'll break equality tests and things
03:48:47 <blackdog> you miss half the benefit if the interpreter/compiler doesn't know you're doing it.
03:48:55 <blackdog> wearing the hairshirt without the benefits.
03:49:35 <reinoud> i know it depends on the program, but how compatible is ghc with hugs in general use?
03:49:47 <bbommarito> See, this is the problem when you were functional for a good while before getting into OOP and all that nonsense.
03:51:27 * reinoud doesn't like OOP though he seemed (not using it anymore) pretty good in it
03:52:00 <bbommarito> reinoud: I don't mind OOP, I just hate people that want to shove everything into an object. I have failed interview questions because I didn't see the need to make something an object.
03:52:28 <bbommarito> "Well, why wouldn't you make that an object?" "Well, because it's being used in one place, and a function works just fine here"
03:53:00 <Modius> I use the snide remark that 2 types of people AVOID OOP - those that have not been exposed to it, and those who understand it.
03:53:09 <mekeor> the only difference between OOP and haskell's type system is that OOP saves "methods" inside the class. that doesn't make sense.  -> Haskell is better.
03:53:40 <mekeor> okay… maybe not the only difference but IMO the biggest…
03:53:51 <blackdog> bbommarito: it's sort of a conflation of namespacing and first-argument dispatch
03:55:52 <bbommarito> mekeor: Is Haskell's "OOP" similar to Lisp's in that you have a data type, then you have functions that can operate on that type?
03:56:29 <shachaf> bbommarito: Haskell doesn't really have "OOP".
03:56:46 <mekeor> hi shachaf
03:56:59 <Elemir> Is there language that have OOP?
03:57:03 <Elemir> Smalltalk?
03:57:13 <mrcarrot> ocaml
03:57:16 <shachaf> bbommarito: The more "OOP" analogies you make while you're learning, the worse off you'll be, probably. :-)
03:57:39 <mekeor> Elemir: what? of course there are OO programming languages… or what's ur question??
03:57:41 <mrcarrot> ocaml might give what you want
03:57:45 <bbommarito> shachaf: Neither does Lisp, really. CLOS is not true OOP, you merely write a function that explicitly works on some data type you define.
03:57:46 <Elemir> Ocaml have subtyping, it isn't OOP
03:58:03 <Elemir> mekeor: Smalltalk is only one OOP language
03:58:21 <Modius> OOP definition discussed:  http://mumble.net/~jar/articles/oo.html
03:58:21 <shachaf> bbommarito: OK. It's (probably) not really like CLOS either.
03:58:25 <bitonic> ocaml has OOP
03:58:27 <mekeor> Elemir: why?
03:58:43 <bitonic> the problem with "OOP" is that is a very vague term
03:58:47 <bbommarito> The "OOP" part of CLOS is that the data type holds...data...kind of like a struct.
03:58:54 <Modius> OOP has meant different things to different groups/contexts. In C it meant "anything with more language power than C"
03:58:56 <shachaf> If y'all are going to have a discussion about which languages "have OOP" and which don't, can you have it in #haskell-overflow or something?
03:59:10 <mekeor> Elemir: what about Java?
03:59:23 <shachaf> It's been a pretty unfruitful discussion almost every time I've ever seen it being had.
03:59:25 <Modius> It may be easier on a case by case basis to discuss specific practices or constructs.
03:59:56 <shachaf> bbommarito: You're best off treating type classes as their own thing, distinct from OOP classes/interfaces/whatever, until you understand them reasonably well.
04:00:08 <mekeor> Elemir: are you gone?
04:00:13 * Elemir thinks that creator of the term OOP, Alan Kay, gave clearness definition of this term
04:00:24 * Elemir googles Alan Kay quotes
04:00:42 * mekeor expects answers from Elemir to his question!
04:01:05 <sepp2k> bbommarito: The OO part of CLOS is that it has subtyping and run-time polymorphism
04:01:07 <shachaf> Could you look up quotes and expect answers in #haskell-overflow?
04:01:08 <Elemir> http://en.wikiquote.org/wiki/Alan_Kay
04:01:24 <blackdog> Elemir: it's worth pointing out that the way Alan Kay defined it is more like Erlang than anything else.
04:01:24 <bbommarito> Here's a Haskell question: What is the difference between data and type?
04:01:38 <Elemir> Hem, erlang
04:01:53 <Elemir> ok, erlang are second OOP language
04:01:59 <sepp2k> bbommarito: data defines an algebraic data type. type defines a type alias.
04:02:06 <shachaf> bbommarito: "type" defines a type alias, like typedef in C; it's just a different name, but intechangeable (almost like text substitution). data defines a new data type.
04:02:36 <mekeor> Elemir: do you deliberately ignore me?
04:02:38 <shachaf> bbommarito: The distinction between "data" and "newtype" is a bit trickier, but you can mostly ignore the latter for now.
04:02:40 <Elemir> "OOP" languages as C++ or Java are just languages with subtyping support
04:02:45 <Elemir> mekeor: 15:00 < Elemir> http://en.wikiquote.org/wiki/Alan_Kay
04:03:15 <Elemir> Alan Kay is a creator of term `OOP'. So he knows all about it
04:03:16 <bbommarito> So, basically I could make 'foo' be an empty list?
04:03:29 <shachaf> bbommarito: I don't know what 'foo' is.
04:03:40 <mekeor> bbommarito: let foo = [] -- ??!
04:04:08 <bbommarito> mekeor: In terms of type. So type foo = []
04:04:22 <shachaf> bbommarito: No. The empty list isn't a type, it's a value.
04:04:25 <mauke> bbommarito: constants must start with an uppercase letter
04:04:28 <shachaf> bbommarito: Also, types start with an uppercase letter.
04:04:31 <mauke> type Foo = [] is valid, though
04:04:33 <mekeor> bbommarito: data List a = Foo | Bar a (List a) -- ?
04:04:35 <Elemir> "OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. […]
04:04:42 <shachaf> mauke: But it doesn't refer to an empty list.
04:04:46 <Elemir> […] It can be done in Smalltalk and in LISP. There are possibly other systems in which this is possible, but I'm not aware of them. "
04:04:51 <mauke> shachaf: true
04:05:07 <bitonic> Elemir: nobody cares really. OOP is what people made of it
04:05:10 <mekeor> @src []
04:05:10 <lambdabot> data [] a = [] | a : [a]
04:05:11 <shachaf> bbommarito: This sort of thing is usually covered in introductions -- are you reading one right now?
04:05:41 <bbommarito> shachaf: I am jumping around and reading some various source bits:) Yes, I eventually will hit a intro but...
04:05:54 <bbommarito> Specifically I am going through xmonad a bit.
04:06:12 <bitonic> bbommarito: you should read something first before reading XMonad's source
04:06:13 <shachaf> bbommarito: It's a bit silly to ask these sorts of questions in here, though, when people have already written up much more in-depth answers and put them online. :-)
04:06:22 <bitonic> @where LYAH
04:06:23 <lambdabot> http://www.learnyouahaskell.com/
04:06:26 <bitonic> bbommarito: ^^^
04:06:33 <bitonic> this is the best beginner's resource, imo
04:06:44 <Jafet> How do you even explain to someone why an empty list is not a data type
04:07:06 <Jafet> This week's applied ontology challenge
04:07:13 <Elemir> There are nice word in a russian language for defining uneducated people — `bydlo'. IMHO it cannot be translated to english, byt historical meaning of the word — a herd
04:07:27 <bitonic> Elemir: whatever.
04:07:31 <Elemir> So that humans can't create really meaning of a term
04:07:34 <mauke> hey, that's a song in "pictures of an exhibition"
04:08:20 <Modius> I ditto "learn you a haskell", and add that ghc-mod, with its auto-warnings when editing text, is invaluable when learning.
04:08:22 <bitonic> Elemir: it's so irritating when people bicker "no THAT's the only true OOP!" as if it mattered. when people talk about OOP today they mostly talk about Java, C++, Python, Ruby
04:09:02 <Elemir> It calls `subtyping'
04:09:34 <shachaf> It's so irritating when people talk about the meaning of "OOP" at all, since it usually ends up being a useless argument about definitions. Especially in #haskell. :-)
04:09:40 * shachaf ought to go to sleep.
04:10:26 <bitonic> Elemir: people have defined OOP formally in various different ways. but it really doesn't matter when someone asks "does Haskell have OOP". when people ask that question they're asking about java-style objects. replying with an argument about the "true" OOP is pointless
04:10:33 <mauke> WAKE UP SLEEPLE
04:10:47 <mauke> true OOP is lambda calculus
04:11:08 <Jafet> Embrace the four-sided truth of the lambda cube
04:11:10 <Elemir> Haskell dosen't support subtyping
04:11:34 <Elemir> Subtyping can be emulated with typeclasses and existential
04:12:12 <bitonic> how do you "emulate" mutation?
04:12:29 <bbommarito> Huh, reading through the lyah chapter on data types, very interesting in what you can actually do with them.
04:12:39 <Elemir> Mutation isn't a part of subtyping or ur `OOP'
04:13:10 <Elemir> Java, C# use mutation because they are imperative
04:13:12 <bitonic> yes it is. anyways shachaf is right, pointless discussion altogether :P
04:13:18 <mekeor> Elemir: a Bird can be a Duck, a Cuckoo or an Ostrich. that's subtyping, right?
04:13:24 <vel> bitonic: +1
04:13:35 <mekeor> bitonic: +1
04:14:02 <Elemir> mekeor: Yes.
04:14:10 <Jafet> No, a bird is a unit that measures the amount of morphisms in your code.
04:14:16 <vel> subtyping it's like in scala and f# right?
04:14:33 <Elemir> As in ohaskell ;)
04:14:44 <mekeor> Elemir: data Bird = Duck | Cuckoo | Ostrich -- ??!
04:14:47 <Elemir> No
04:14:55 <mekeor> why?
04:15:08 <Elemir> Because Duck isn't a TYPE
04:15:21 <bitonic> a subtyping relation is when you can treat something as if it was of another type. e.g. in Java each class is a subtype of Object
04:15:25 <mekeor> Elemir: ah
04:15:35 <bitonic> so you can treat each class as if it was an Object
04:15:51 <mekeor> Elemir: and Bird is a type, too??!
04:16:04 <mekeor> Elemir: in haskell, Bird would be a type class…
04:16:15 <Elemir> 15:11 < Elemir> Subtyping can be emulated with typeclasses and existential
04:16:44 <mekeor> Elemir: in actual "subtyping", would Bird have to be a type?
04:16:50 <vel> all that OOP stuff is overrated meaningless buzz. incapsulation? inferitance? polimorphism? lol.
04:17:07 <_mpu> Elemir, do you have pointers for this?
04:17:12 <Elemir> mekeor: Look at ohaskell, please
04:17:14 <Jafet> mekeor: you can use existential typing to make a type corresponding to Bird.
04:17:24 <bitonic> mekeor: you have a point, in the sense that subtyping is used to emulate sum types in Java
04:17:34 <bitonic> mekeor: but subtyping is not that
04:17:34 <Jafet> Obligatory link to http://uncyclopedia.wikia.com/wiki/Turing_Duck_Test
04:17:37 <mekeor> Elemir: Yes or no?
04:18:27 <Elemir> You says gibberish
04:18:55 <mekeor> why? i just asked a question.
04:18:59 <bitonic> mekeor: in your example, 'Bird' would be an abstract class, and 'Duck', 'Cuckoo' and 'Ostrich' would be classes extending 'Bird'. 'Duck' 'Cuckoo' and 'Ostrich' are then subtypes of 'Bird'
04:19:49 <hpaste> killy9999 pasted “forM” at http://hpaste.org/65934
04:20:01 <mekeor> bitonic: "class" in haskell-sense or OOP-sense?
04:20:05 <Elemir> With subtyping you can have two types A and B. And if B is a subtype of A you can use B as A
04:20:22 <bitonic> mekeor: OOP sense (I was using java terminology)
04:20:38 <killy9999> I'm trying to modify one of the examples from LYAH
04:21:20 <mauke> killy9999: you can't do that
04:21:28 <killy9999> I want to avoid color <- getline (unpacking), return color (packing) and then unpacking the whole result of forM into colors
04:21:48 <killy9999> yes, I noticed that from error messages :)
04:21:57 <killy9999> the question is why?
04:22:01 <bitonic> killy9999:     colors <- forM [1,2] $ \a -> do ....
04:22:12 <bitonic> 'let' will just bind 'colors' to that IO actuion
04:22:27 <bitonic> while you are already in the IO monad, and you want to get the result of that action
04:22:29 <killy9999> aaargh, right
04:22:36 <killy9999> yes, I see
04:22:38 <hpaste> mauke annotated “forM” with “forM (annotation)” at http://hpaste.org/65934#a65935
04:22:51 <jel> Hi guys.  What's haskell like for processing large data streams, or more accurately, loading multiple GBs of data into ram as objects for processing?  Is there a lot of memory overhead to objects?  Scala couldn't handle it in the JVM, for example.  C++ and PyPy do OK, but lack simple concurrency.
04:23:05 <bitonic> killy9999: also, you just need 'getLine'. 'color <- getLine; color' won't typecheck (you can figure out why :))
04:23:37 <jel> ... but haskell is compiled, right?
04:23:37 <yasar> In other languages, you could print variables inside the function to see what it is doing, in haskell you can't, is there anyway I could see the values of variables in a function?
04:23:48 <mauke> jel: no, Haskell is a language
04:23:51 <killy9999> bitonic: yes, I can gigure it out :)
04:23:57 <mauke> yasar: trace
04:24:03 <hpaste> killy9999 annotated “forM” with “forM (annotation)” at http://hpaste.org/65934#a65936
04:24:12 <jel> mauke: not encouraging me about the community so far.
04:24:18 <mauke> jel: huh?
04:24:25 <yasar> mauke: how does it work?
04:24:36 <mauke> yasar: evil magic
04:24:37 <bitonic> jel: compiled/not compiled doesn't make much difference here. Haskell has good libraries for processing large streams. lazy ByteStrings alone are nice, and there are also parsers tailored around that problem, like attoparsec
04:25:08 <mekeor> mauke: don't say unsafeXY!! no nooooo!
04:25:08 <yasar> jel: You can compile haskell, or use it interpreted. It is up to you.
04:25:57 <yasar> mauke: I mean is it a option inside ghci, or is it a seperate utility, or what?
04:25:58 * bitonic goes to have lunch
04:26:07 <mauke> @hoogle trace
04:26:07 <lambdabot> Debug.Trace module Debug.Trace
04:26:07 <lambdabot> Debug.Trace trace :: String -> a -> a
04:26:07 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
04:26:16 <mauke> see the documentation for Debug.Trace
04:26:27 <mekeor> cool
04:26:44 <mekeor> mauke: is that impure?
04:26:48 <mauke> mekeor: yes
04:27:10 <mauke> @quote oasis
04:27:10 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
04:27:34 <killy9999> is there any deifference between mapM and forM except for order of parameters?
04:27:41 <mauke> @src forM
04:27:41 <lambdabot> forM = flip mapM
04:27:46 <mauke> @src flip
04:27:47 <lambdabot> flip f x y = f y x
04:28:01 <killy9999> mhm
04:28:38 <killy9999> ho can I do something like @src in ghci?
04:28:55 <jel> bitonic: attoparsec sounds cool so far.  I guess my concern is the per-object/per-record non-lazy overhead for hundreds of thousands of messages
04:33:39 <bitonic> jel: I don't understand what your concern is. Anyways I have to go, there are a lot of attoparsec users here anyways
04:33:55 <jel> bitonic: no worries, thanks.
04:40:52 <bbommarito> So here's a question: Is there any sort of Haskell source code formatting standards?
04:41:18 <mauke> good question
04:41:44 <nart> hi =)
04:42:00 <mekeor> hi nart. nice to see you again.
04:42:18 <mekeor> nart: consider #haskell-blah, too.
04:42:35 <nart> bbommarito: i follow this https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
04:42:48 <nart> mekeor: hi, i'll join right now :)
04:44:56 <bbommarito> nart: Thanks. Seems like a reasonable 'standard'
04:50:11 <BlankVerse> what might be the advantage of capturing btree operations in a new monad class?
04:50:48 <BlankVerse> all the operations are on a disk based btree
04:50:59 <hiptobecubic> BlankVerse, you get a Monadic merit badge
04:51:14 <nart> ahahah
04:51:27 <nart> i want one too
04:51:35 <mysticc> me too ..
04:51:36 <hiptobecubic> i haven't earned mine yet either
04:56:24 <Modius> What's the cleanest way to convert a list of (A, B) into a list of (A, [B]) where the As are unique?
04:56:45 <Modius> I assume you can do sort then groupby for adjacency; but want something that uses a hashtable.
04:56:51 <Modius> Or a lookup/dictionary by implemnetation
04:57:52 <nart> Modius: you mean from [(1,"h"), (2,"c")] -> [(1, ["h"]), (1, ["c"])] ?
04:58:00 <Modius> nart: yes
04:58:45 <ClaudiusMaximus> @hoogle fromListWith
04:58:46 <lambdabot> Data.IntMap fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
04:58:46 <lambdabot> Data.Map fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
04:58:46 <lambdabot> Data.IntMap fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
04:59:50 <nart> > let x = [(1,"h"), (2,"c")] in map (\(f,s) -> (f, [s])) x
04:59:51 <lambdabot>   [(1,["h"]),(2,["c"])]
05:07:01 <mekeor> > let map (second (:[])) [(1,"h"), (2,"c")]
05:07:02 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:07:13 <mekeor> > map (second (:[])) [(1,"h"), (2,"c")]
05:07:14 <lambdabot>   [(1,["h"]),(2,["c"])]
05:11:42 <ski> > (map . fmap) (:[]) [(1,"h"), (2,"c")]
05:11:44 <lambdabot>   [(1,["h"]),(2,["c"])]
05:12:20 * hackagebot reducers 0.1.9 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.1.9 (EdwardKmett)
05:12:54 <mauke> > fmap fmap fmap return [(1,"h"), (2,"c")]  :: [(Int,[String])]
05:12:55 <lambdabot>   [(1,["h"]),(2,["c"])]
05:15:01 <nart> so fmap f for tuple apply the f to the second term of the tuple ?
05:15:37 <mauke> nart: look at the types
05:17:56 <ski>   fmap :: (b0 -> b1) -> ((a,b0) -> (a,b1))
05:18:05 <ski>   fmap :: (b0 -> b1) -> ((,) a b0 -> (,) a b1)
05:18:19 <ski>   fmap :: (b0 -> b1) -> (f b0 -> f b1)  where  f = (,) a
05:18:27 <ski> nart ^
05:18:38 <nart> ski: ahhh, that's cool, got it thanks
05:19:17 <ski> > (map . fmap) show [Left 0,Right 1,Left 2,Right 3]
05:19:19 <lambdabot>   [Left 0,Right "1",Left 2,Right "3"]
05:20:55 <ski> @type fmap `asTypeIn` \fmap -> (map . fmap) show [Left '0',Right '1',Left '2',Right '3']
05:20:56 <lambdabot> (Char -> String) -> Either Char Char -> Either Char String
05:21:30 <ski> @type fmap `asTypeIn` \fmap -> (map . fmap) show [('1',"h"), ('2',"c")]
05:21:31 <lambdabot> ([Char] -> String) -> (Char, [Char]) -> (Char, String)
05:21:47 <ski> @type fmap `asTypeIn` \fmap -> (map . fmap) (:[]) [('1',"h"), ('2',"c")]
05:21:48 <lambdabot> ([Char] -> [[Char]]) -> (Char, [Char]) -> (Char, [[Char]])
05:23:32 <timthelion> Is there any particular preformance reason why a haskell should not have 500 threads?
05:23:46 <timthelion> s/haskell/haskell program/
05:23:48 <alpounet> nope
05:24:12 <alpounet> these are "green threads"
05:24:15 <nart> > fmap (:[]) <$> [(1,"h"),(2,"c")]
05:24:16 <lambdabot>   [(1,["h"]),(2,["c"])]
05:24:16 <alpounet> they're lighter than OS threads
05:24:32 <ciaranm> "green" usually means "doesn't make use of SMP"
05:25:07 <elliott> "lightweight threads", then
05:25:08 <koeien> timthelion: not at all, ghc rts can easily handle that
05:25:14 <elliott> timthelion: you can have tens of thousands if you want.
05:25:20 <elliott> probably hundreds
05:25:25 <alpounet> ciaranm, hmm iirc it means that they are scheduled by a VM or some runtime system
05:25:27 <elliott> or was that sparks
05:25:35 <timthelion> Good, I think from a design standpoint, rather than trying to juggle many values in some State monad, it would be better to fork for each new thing that I'm keeping track of, and deal with communication through MVars.  That means that each thread only needs to pass an MVar to "call home" to the parent thread, and the values it's interested in.
05:26:01 <ciaranm> alpounet: well... usually the claim is that "green" threads suck because they only give you more i/o, not more cpu. i'd avoid the term for any decent threading implementation...
05:26:15 <ciaranm> incidentally, you can't have 100! threads. ghc doesn't like that.
05:27:28 <timthelion> Like if I have a check box in my GUI, I would have a separate thread for that which would consist of a recursive function which would eat checkbox value changed events, toggle a bool, and "send that home" using an mvar to the parent thread.
05:27:56 <timthelion> I'm not sure if I'm making sense.
05:28:11 <ciaranm> you're doing an event loop with one thread per event handler?
05:28:14 <nart> > ((:[]) <$>) <$> [(1,"h"),(2,"c")]
05:28:15 <lambdabot>   [(1,["h"]),(2,["c"])]
05:28:19 <ClaudiusMaximus> timthelion: sounds like STM would be a better fit, though I've never used it myself
05:28:44 <timthelion> ClaudiusMaximus: Give me one reason why it would be better.
05:30:15 <ClaudiusMaximus> timthelion: the parent thread would wake up only when the checkbox value changed value, rather than having to poll it?
05:30:46 <timthelion> ClaudiusMaximus: Yes.
05:30:46 <ClaudiusMaximus> timthelion: (thinking of the case of more than one checkbox, mainly)
05:31:00 <ski> > show (product [1 .. 100]) ++ " threads"
05:31:02 <lambdabot>   "93326215443944152681699238856266700490715968264381621468592963895217599993...
05:31:05 <timthelion> ClaudiusMaximus: But you can share one MVar across more than one thread.
05:31:10 <nart> > let f <$$> x = fmap f <$> x in (:[]) <$$> [(1,"h"),(2,"c")]
05:31:11 <lambdabot>   [(1,["h"]),(2,["c"])]
05:31:38 <ski> > ((:[]) `fmap`) `map` [(1,"h"),(2,"c")]
05:31:39 <lambdabot>   [(1,["h"]),(2,["c"])]
05:32:16 <nart> i like <$> better :D
05:32:22 * ski doesn't
05:32:32 <elliott> timthelion: you can share TVars across multiple threads, too...
05:32:41 <nart> ski: eheh
05:32:51 <elliott> ClaudiusMaximus: Note that with takeMVar it *wouldn't* poll. But it's still a silly design.
05:33:38 <ski> nart : i'd prefer `<$>' as a name for `ap'/`<*>' ..
05:34:02 <elliott> <*> is less ugly than <$> though
05:34:02 <ski> (and `<*>' having type `Applicative i => i a -> i b -> i (a,b)')
05:34:50 <ski> (an alternative name for `<$>' might be `$>')
05:34:54 <timthelion> Imagine a program that allows you to draw.  And  Mvar (Image->Image) shared across several threads.  One recursive loop would read keeptrackofimage image mymvar = do change <- takeMvar mymvar ; keeptrackofimage (change image) mymvar... And then a whole bunch of "tool thread" which would write functions to mymvar... Wouldn't that work?
05:35:16 <Modius> I saw it earlier but can't find it aagain - what's the haskell function to filter a list, by predicate, into a tuple containing the 2 lists?
05:35:32 <timthelion> keeptrackofimage :: Image -> Mvar (Image -> Image) -> Image
05:35:48 <nart> @type <*>
05:35:48 <lambdabot> parse error on input `<*>'
05:35:57 <ski> @type partition
05:35:57 <nart> woops, why is that ?
05:35:58 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:36:07 <ski> @type (<*>)
05:36:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:36:11 <nart> ah ok
05:36:12 <nart> xD
05:36:23 <td123> Modius: definitely partition
05:36:33 <Modius> Yes, it was partition  thanks
05:36:36 <Modius> What does Haskell do to keep memoization safe across threads?
05:37:11 <timthelion> Does my concept seem sound?
05:37:14 <ClaudiusMaximus> timthelion: perhaps Chan would be more appropriate here, unless you want the tool threads to block until the loop is ready
05:37:15 <nart> is it possibile to search an haskell function by type ?
05:37:27 <td123> nart: yes, hoogle :)
05:37:52 <elliott> <ski> (and `<*>' having type `Applicative i => i a -> i b -> i (a,b)')
05:37:53 * timthelion looks up Chan
05:38:01 <elliott> ski: thus defeating the point of applicative style? :p
05:38:03 <nart> td123: awesome, thanks
05:38:13 <elliott> oh, I see, you'd give (<$>) the type (<*>) has now
05:38:23 <ski> yeah
05:38:30 <nart> ski: why is that ?
05:38:50 <ski> since `*' is a symmetric symbol, and is more associated with multiplication, i'd prefer it to have the more symmetric type
05:39:20 <ski> `$' is already associated with application, so `Applicative i => i (a -> b) -> (i a -> i b)' makes more sense for `<$>', imho
05:39:30 <timthelion> ClaudiusMaximus: I think it's probably about the same.   I can see MVars being more stable though.  Not sure, I'll have to think about it.
05:39:34 <elliott> i find the fact that tuples are products and so are * a more convincing reason
05:39:43 <ski> nart : why is what ?
05:39:46 <elliott> anyway we just need idiom brackets, (| (a,b) |) vs. (| a $ b |) :p
05:40:01 <elliott> timthelion: "stable"?
05:40:05 <ski> elliott : heh, i rather think we need reflective syntax :)
05:40:09 <nart> ski: why "you'd give (<$>) the type (<*>) has now"
05:40:15 <nart> ski: but you have already answered
05:40:49 <elliott> ski: calling applicatives "i" is so old-school
05:40:51 <ski> @type liftA2 (,)
05:40:52 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
05:40:56 <timthelion> elliott: Well, you want to prevent the situation, that the user does the command "change contrast" and then, when nothing blocks, keeps working, and draws something, and all of a sudden, when change contrast, which took 10 secconds finished, a whole bunch of things unexpectedly happen at once.
05:41:10 <ski> elliott : what can i say, i'm an old-school kind of person ;)
05:42:03 <timthelion> elliott: if I used Chan, then all those events that got written to the Chan while the changecontrast action was happening would suddenly be preformed after it was done, not a good UI feature.
05:42:03 <nart> @help hoogle
05:42:03 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
05:42:17 <nart> @hoogle  (a -> Bool) -> [a] -> ([a], [a])
05:42:17 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
05:42:17 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
05:42:17 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
05:42:21 <nart> awesome
05:42:25 <timthelion> though now that I think of it, MVars do nothing to prevent that.
05:43:12 <ClaudiusMaximus> timthelion: ever used a slow ssh connection?  it would be a nightmare if you had to wait for each character to be echoed before you could type another one...
05:44:40 <ClaudiusMaximus> timthelion: personally my ideal interface for something like this would be to be able to build up a queue of operations as quickly as humanly possible, with an "apply" button that would run the stuff, and an "auto-apply" checkbox for those times i want interactive feeedback
05:44:50 <timthelion> ClaudiusMaximus: yes, I guess, Chan + greying out of components to stop the user from being stupid when nessecary, is probably optimal.  It would make no sense to have lines become jagged when drawn on a slow comp... :)
05:45:20 <timthelion> ClaudiusMaximus: well when you are using a paint brush on a tablet you want instant results.
05:46:03 <timthelion> But that's un entirely different question.  Has anyone else tried the massively multithreaded state paradigm for GUI's in a purely functional language yet?
05:46:26 <timthelion> s/un/an/
05:47:27 * ski isn't sure whether Fudgets apply
05:49:35 <timthelion> mmm, Fudgets looks very close to my idea. thanks for the sugestion...
05:50:15 <ski> @where Fudgets
05:50:15 <lambdabot> GUI using X, by Thomas Hallgren and Magnus Carlsson, at <http://www.altocumulus.org/Fudgets/>,<http://www.carlssonia.org/ogi/ProdArrows/>. Also see `Alfa'
05:51:02 <timthelion> ski: I'll read up on that.  But I'm definitely going to implement it my own way.  Threading tools have improved A LOT since 1993 :D
05:52:06 * elliott wonders if timthelion is on the path to writing an ad-hoc, informally-specified, bug-ridden, slow implementation of half of FRP.
05:55:20 <timthelion> elliott: well, I don't really know what I'm doing.  But from the articles I HAVE read, most seem to sugest some complicated and awkward single threaded State...  I had a better idea, and I'd wonder, if this idea is so well known already, why is a worse method in such wide use?
05:57:14 <elliott> I don't know what articles you're reading. But I doubt anyone uses State with typical GUI toolkits in Haskell, since they don't interact well with monad transformers.
06:00:57 <ski> WWWBrowser at the end of <http://web.archive.org/web/20080604184942/http://www.cs.chalmers.se/Cs/Research/Functional/Fudgets/demoform.html> automatically fetched images in parallel, due to the incremental way Fudgets is structured, without relying on any host threads
06:01:40 <timthelion> elliott: If I recall correctly, in "the awkward squad" preformunsafeIO is sugested as a work arround for the trouble of having a config file :)
06:02:46 <elliott> timthelion: I don't see the relevance.
06:02:55 <elliott> (And I don't think many people would agree with that recommendation.)
06:04:56 <elliott> Anyway, anyone trying to recast GUI programming in a less stateful style will more or less inevitably end up reinventing FRP.
06:05:10 <timthelion> anyways, I'm not going to argue with you, because I think you're right, I am trying to do FRP, and I'm glad for the information :D
06:05:23 * elliott isn't arguing. My original comment was a Greenspun's tenth law reference
06:05:27 <hpc> elliott: or as CPS
06:05:41 <elliott> timthelion: You may want to take a look at e.g. http://hackage.haskell.org/package/reactive-banana http://hackage.haskell.org/package/reactive-banana-wx
06:05:51 <elliott> also http://hackage.haskell.org/package/netwire
06:06:18 <elliott> hpc: Well, the standard coroutiney CPSy automaton arrow formulation that people often come up with is just a type of arrowised FRP.
06:06:36 <elliott> (Albeit they usually, regrettably, end up working without continuous time.)
06:07:23 * hackagebot xml-hamlet 0.2.0.3 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.2.0.3 (MichaelSnoyman)
06:07:30 <ski> hpc : as CPS how ?
06:08:11 * elliott assumed the standard: Widget i o = i -> IO (o, Widget i o) or similar
06:08:11 <hpc> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
06:08:28 <elliott> hpc: hmm, then i don't understand. oh, I said "less stateful"
06:08:31 <timthelion> elliott: The original thought, was that GIMP2 has a terrible UI, and an unmaintainable source code(that's not an accusation, it's a claim made by the maintainers themselves) and it would make sense to write a modern image editing program in Haskell...
06:08:33 <elliott> when I really meant "less imperative"
06:08:40 <hpc> ah
06:08:43 <hpc> :P
06:09:16 <elliott> hpc: it's true that that technique will reduce a lot of state-related problems, though, which are a large source of problems with imperative code. but it actually makes it /more/ sequential (and so further from FRP)
06:11:35 <bbommarito> So, I thought I was going to have a heck of a time understanding function composition, I was wrong.
06:12:19 <hpc> bbommarito: nah, the fun comes from understanding all the OTHER ways of composing functions
06:12:26 <hpc> > (+) `on` f $ x :: Expr
06:12:27 <lambdabot>   Precedence parsing error
06:12:27 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
06:12:35 <hpc> > ((+) `on` f) x :: Expr
06:12:36 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
06:12:36 <lambdabot>         against inferred ...
06:12:38 <hpc> piffles
06:12:43 <hpc> :t on
06:12:44 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:12:53 <hpc> > ((+) `on` f) x y :: Expr
06:12:53 <lambdabot>   f x + f y
06:13:15 <hpc> bbommarito: also, congrats
06:13:39 <vel> do you have any good example of UI in Haskell?
06:13:59 <timthelion> elliott: to make this clear, are you Conal Elliott?
06:14:07 <hpc> timthelion: conal is conal
06:14:09 <bbommarito> The thing that did trip me up a bit (Again reading a bit of code), is when a function takes two arguments, but the second argument isn't listed because it's a composition.
06:14:16 <bitonic> timthelion: and elliott is elliott
06:14:19 <vel> I think problem is UI IS state-related. This is state which is in head of user.
06:14:40 <elliott> timthelion: I'm Conal for the period of time when you first see me on IRC to when you ask me whether I'm Conal.
06:14:46 <elliott> Then the horrible truth comes out: nope, sorry.
06:15:03 <mauke> preflex: ? who:ConalElliott
06:15:03 <preflex>  conal
06:15:05 <elliott> You can tell I'm not conal because I say a lot of nonsense :)
06:15:06 <mauke> preflex: botsnack
06:15:07 <preflex>  ☺
06:15:14 <hpc> > botsnack
06:15:14 <nart> what is the general thought about Iteratee IO ?
06:15:14 <lambdabot>   Not in scope: `botsnack'
06:15:16 <hpc> :(
06:15:43 <mauke> @bitsnack
06:15:43 <lambdabot> :)
06:15:58 <bbommarito> Can we import botsnack?
06:16:14 <elliott> nart: Thought howso? Non-iteratee approaches to the streaming data solution seem to be getting more popular (conduit, pipes).
06:16:18 <elliott> But even those are all pretty alike.
06:16:36 <dixie_> > [1..0]
06:16:37 <lambdabot>   []
06:16:49 <dixie_> > [1,..0]
06:16:50 <lambdabot>   <no location info>: parse error on input `..'
06:17:14 <bbommarito> Okay, I have to try this.
06:17:20 <mauke> > [1, 0 .. 0]
06:17:21 <lambdabot>   [1,0]
06:17:27 <bbommarito> toUpper
06:17:34 <bbommarito> > toUpper
06:17:35 <lambdabot>   Overlapping instances for GHC.Show.Show
06:17:35 <lambdabot>                              (GHC.T...
06:17:48 <elliott> vel: The idea that UI is inherently stateful/imperative in the sense that traditional GUI toolkits are is a myth.
06:17:53 <bbommarito> > map toUpper . reverse "Hello"
06:17:54 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:17:54 <lambdabot>         against inferred ty...
06:18:20 <elliott> It's just a slightly-reduced form of the myth that all useful programs are inherently stateful (and so functional languages are useless).
06:18:27 <mauke> > (map toUpper . reverse) "Hello"
06:18:28 <lambdabot>   "OLLEH"
06:21:24 <bbommarito> Ah, so in the interperator, you cannot simply the function down to just map toUpper . reverse
06:21:32 <bbommarito> simply=simplify.
06:21:41 <mauke> why not?
06:21:41 <elliott> eh?
06:21:46 <elliott> No, it's just that what you said is
06:21:51 <elliott> (map toUpper) . (reverse "Hello")
06:21:56 <elliott> which is
06:22:04 <elliott> \x -> (map toUpper) ((reverse "Hello") x)
06:22:08 <ski> @let bbommarito = map toUpper . reverse
06:22:09 <elliott> which makes no sense; whereas mauke's is
06:22:09 <lambdabot>  Defined.
06:22:14 <ski> > bbommarito "Hello"
06:22:16 <lambdabot>   "OLLEH"
06:22:24 <elliott> (map toUpper . reverse) "Hello" === (\x -> (map toUpper) (reverse x)) "Hello"
06:22:37 <elliott> === (map toUpper) (reverse "Hello") === (map toUpper) "olleH" === "OLLEH"
06:23:03 <bbommarito> Okay, so there's a bit of confusion: Why does the function 'bbommarito' now work fine, but without creating the function map toUpper . reverse does not work?
06:23:33 <ski> bbommarito : you need to say `(map toUpper . reverse) "Hello"' since `map toUpper . reverse "Hello"' means `(map toUpper) . (reverse "Hello")'
06:23:55 <adnauseam> :t map
06:23:55 <nart> @type ($$)
06:23:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:23:56 <lambdabot> Doc -> Doc -> Doc
06:24:00 <ski> bbommarito : it's just a matter of precedence : function application binds tighter than `.'
06:24:16 <adnauseam> map function mappable-structure
06:24:30 <mauke> bbommarito: it did work
06:24:55 <bbommarito> Okay, I see what's happening now.
06:25:17 <Elemir> Guys, what haskell CMS is more useful?
06:25:20 <adnauseam> bbommarito: without proper voundries()
06:25:38 <adnauseam> bbommarito: without proper  boundries (), map thinks you're giving it extra parameters
06:25:41 <adnauseam> and fails
06:26:09 <elliott> "boundries"? it's just operator precedence...
06:26:20 <adnauseam> just trying to use layman's terms ;p
06:26:49 <ski> adnauseam : s/mappable-structure/list/ or s/map/fmap/
06:26:49 <elliott> Elemir: there are haskell CMSes?
06:26:57 <elliott> :t map
06:26:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:26:59 <vel> elliott: well it's theoreticaly possible to make declarative DOM builder like HTML but in Haskell with recent features like declarative CSS animation and stuff and FRP scripting in Haskell. But... theoreticaly... all projects are dead
06:27:04 <elliott> heh, caleskell keeps map the same?
06:27:19 <elliott> vel: reactive-banana, netwire, sodium are not dead
06:27:20 * Elemir knows happstack and yesod
06:27:28 <elliott> Elemir: web framework =/= cms
06:27:31 <ski> elliott : maybe it hasn't always, can't recall
06:27:42 <ski> you could ask Cale about it
06:27:58 <elliott> nah, i don't doubt it
06:28:03 <elliott> it's just funny that it changes (.) to fmap but leaves map the same
06:28:06 <ski> @type (++)
06:28:07 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:28:17 <elliott> "succ . Just 42" is much more readable than "map succ (Just 42)"!
06:28:17 <ski> @type flip
06:28:18 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:28:24 <ski> (that last one is my fault ;)
06:28:30 <mauke> > toUpper . reverse "Hello"
06:28:32 <lambdabot>   "OLLEH"
06:28:38 <elliott> ski: you're terrible :(
06:28:42 <nart> how can i develop something like Hakyll or xmonad's kind of DSL language to write config files ?
06:28:49 <ClaudiusMaximus> Elemir: gitit springs to mind
06:28:52 <elliott> nart: http://hackage.haskell.org/package/dyre
06:29:32 <elliott> nart: unless you have very special requirements it would be best to use a normal config format
06:29:50 <elliott> nart: e.g. http://hackage.haskell.org/package/configurator
06:30:04 <nart> elliott: mine it's just a question out of curiosity
06:30:19 <Elemir> elliott: aaaand? Happstack or yesod not only web framework
06:30:30 <elliott> Elemir: well, you were asking about CMSes.
06:30:33 <elliott> and listed two web frameworks as examples
06:30:42 <nart> elliott: thanks for the links
06:30:48 <elliott> if you want to know about the available web frameworks, then asking about the available CMSes won't get useful answers ;)
06:31:04 <Elemir> This frameworks are CMS too, so good sample
06:31:06 <elliott> nart: right, it basically comes down to using the GHC API (or invoking ghc separately)
06:31:16 <elliott> nart: and making your application a library + stub loader for the above
06:31:22 <elliott> Elemir: happstack and yesod are not CMSes
06:31:59 <Elemir> Why?
06:32:38 <BlankVerse> how to convert a value of type ByteString to lazy?
06:32:38 <ski> elliott : you don't like caleskell `flip' ? ;)
06:32:41 <hpc> a framework lets you program a website
06:32:42 <BlankVerse> and vice-versa
06:32:57 <hpc> a CMS has all the programming done and you just use some crappy joomla admin page to do everything
06:33:00 <hpc> :P
06:33:01 <vel> Elemir: right, but happstack and yesod are thin client approach. and I mean really reactive GUI like... maybe Qt
06:33:12 <elliott> ski: i don't like caleskell at all :) (well, some things are better, like (++), but I don't like lambdabot deviating from the norm in the first place, seeing as it causes rampant confusion esp. when teaching)
06:33:26 <elliott> (i realise the official position is that lambdabot is not for newbies - tell that to everybody who teaches newbies in here)
06:33:33 <Elemir> Really CMS just provide XML interface for programming
06:33:41 <elliott> Elemir: what
06:34:10 <nart> elliot: how is something like that http://random.axman6.com/blog/?p=104 achieved ?
06:34:15 <Elemir> For example at yesod I can write pages, scriptes and css-shit at pure haskell
06:34:23 <nart> elliott: how is something like that http://random.axman6.com/blog/?p=104 achieved ?	
06:34:30 <Elemir> *at pure template haskell
06:34:46 <elliott> Elemir: you're not really making any sense
06:35:04 <elliott> nart: achieved? the code is there in the blog post
06:35:17 <elliott> oh, it isn't
06:35:25 <nart> not really =(
06:35:45 <ski> elliott : well, i agree it would peobably be better if one could easily switch between caleskell and normal bindings
06:35:48 <elliott> nart: well just define things like: para = Node P []
06:35:56 <elliott> nart: text = Text etc.
06:36:10 <elliott> nart: you can see http://hackage.haskell.org/package/html http://hackage.haskell.org/package/xhtml for "full" versions of this idea
06:36:28 <elliott> and http://jaspervdj.be/blaze/ for a more modern HTML DSL in Haskell taking a different approach
06:36:41 <Elemir> IMHO yesod is a CMS, like XMonad is a WM.
06:37:04 <Elemir> Haskell is using for configuration at them
06:37:46 <elliott> Elemir: you're welcome to that opinion... but it's like saying that C is a program to list directories
06:37:49 <elliott> because you can write ls in C
06:38:09 <Elemir> XMonad is a really library, for example
06:38:17 <elliott> a CMS is a complete piece of web software that lets content be managed without programming, see http://en.wikipedia.org/wiki/Content_management_system
06:39:27 <Elemir> But I don't meet with a opinion that XMonad isn't a WM, because it isn't a program at all
06:40:23 <elliott> xmonad is a program:
06:40:23 <vel> I don't understand for what generate HTML (by template or not) witch is DOM-generator itself at all
06:40:24 <elliott> $ which xmonad
06:40:24 <elliott> /home/elliott/.cabal/bin/xmonad
06:40:42 <elliott> yes, xmonad is structured in a way that it is configured with code
06:40:48 <Elemir> Yes, it's a program, that writing by you
06:40:53 <elliott> the difference is that xmonad contains a lot of code dedicated to being a window management application, which it functions as out of the box
06:40:56 <elliott> that isn't true at all for yesod
06:40:59 <elliott> or happstack
06:41:14 <vel> declarative generators to generate another declarative generators
06:41:46 <Elemir> How many SLOC are needed for writing simple blog at yesod?
06:42:00 <elliott> that's irrelevant... but i really don't feel like arguing this any more
06:42:01 <Elemir> With using plugins, of cause
06:42:40 <Elemir> % wc -l ~/.xmonad/xmonad.hs
06:42:40 <Elemir> 152 /home/elemir/.xmonad/xmonad.hs
06:43:31 <elliott> the point is that you can have no xmonad.hs at all and xmonad is still a window manager. but, this is ridiculous.
06:43:38 <Elemir> May be happstack isn't a CMS, I know nothing about it
06:45:52 <Elemir> elliott: IMHO nodoby uses XMonad without writing xmonad.hs, so it's a sophistry
06:45:56 <shergill> Elemir: you should pose this question to snoyman, and ask him why when _clearly_ yesod is a cms does he continue to market it as a web framework
06:46:24 <elliott> CMS, n. something that can be turned into a CMS with few lines of code
06:46:47 <Elemir> Recursive definition?
06:47:13 <vel> shergill: lol
06:47:43 <Philonous_> shergill:  You should sell tickets to that event ;)
06:47:55 <shergill> heh
06:47:56 * Elemir thinks that author may have some term phobies, it's a normal
06:48:20 <ozataman> anybody having haskell-mode hang after C-c C-l?
06:49:32 <elliott> ozataman: did GHC just fail to load your file before you did that?
06:49:46 <elliott> and drop you at a prompt with no modules loaded?
06:49:58 <elliott> that usually results in hanging for me, if you kill the buffer and try it it works
06:50:03 <ozataman> elliott: no, fresh emacs boot.. the *haskell* buffer loads all the pakcages and fails to show the > prompt
06:50:12 <ozataman> I've tried killing many times
06:50:38 <elliott> ozataman: weird.
06:50:41 <ozataman> weird thing is, when I use cabal-dev and set haskell-program-name to cabal-dev, it works
06:50:46 <mekeor> @remember ozataman I've tried killing many times
06:50:47 <lambdabot> Done.
06:50:50 <mekeor> lol
06:50:54 <mekeor> @quote ozataman
06:50:54 <lambdabot> ozataman says: I've tried killing many times
06:51:05 <hpc> @quote kill
06:51:06 <lambdabot> Olathe says: 11 PM is a poison that sneaks up on you and then kills you tomorrow.
06:51:15 <ozataman> I think this started after I upgraded to 7.4.1
06:51:16 <ozataman> haha
06:51:21 <ozataman> oh come on guys, this is gonna get me in trouble :)
06:51:28 <mekeor> :D :D:DD:D
06:51:36 <Modius> What's the typical way you raise a runtime error in the "impossible" pattern?
06:51:46 <mekeor> that my family and me laughing ↑
06:51:48 <elliott> Modius: error "this is impossible"
06:51:49 <parcs`> error "blah blah blah"
06:51:54 <elliott> Modius: (but don't do it!)
06:51:56 <hpc> Modius: i just don't include the pattern
06:51:59 <Elemir> Ok, without trolling. There can I found pros and contras of yesod and happstack?
06:52:00 <hpc> then i get line numbers
06:52:02 <elliott> (unless you can actually prove it's impossible.)
06:52:37 <elliott> Elemir: probably nowhere objective. try both, stick with the one you like more. try snap, too
06:53:55 <Elemir> Dou… Easy to say "try both", but it isn't easy to try…
06:54:32 <parcs`> why not?
06:54:52 <shergill> Elemir: look at code examples of both and see which you prefer?
06:55:11 <nart> is it possibile to forkIO a function that "returns" a Monad that is not IO but derives it ?
06:55:30 <hpc> nart: huh?
06:55:44 <Elemir> :t forkIO . liftIO
06:55:45 <lambdabot> Not in scope: `forkIO'
06:55:49 <hpc> what do you mean "derives"
06:55:53 <vel> i enjoyed snap's approach
06:56:07 <nart> hpc: i'm using GeneralizedNewtypeDeriving
06:56:09 <Saizan> hpc: MonadIO
06:56:16 <hpc> oh
06:56:17 <Saizan> maybe not
06:56:18 <elliott> Saizan: ... no?
06:56:20 <hpc> you can't
06:56:21 <elliott> nart: you mean like StateT s IO?
06:56:24 <hpc> not generally
06:56:28 <elliott> nart: how would that work, in general?
06:56:30 <ozataman> Elemir: what are you looking to do with yesod/happstack/snap?
06:56:33 <hpc> the best you can do is run the action and get an IO-thing back
06:56:36 <elliott> nart: does it spawn off a new state?
06:56:37 <hpc> then forkIO that
06:56:46 <elliott> or does it share the state of the forking context somehow?
06:56:58 <elliott> but, see monad-control/lifted-base for a "partial" solution for *some* monads.
06:57:29 <nart> elliott: it shares the state
06:57:30 <hpc> alternatively, don't see it :P
06:57:40 <chrisdone> beep
06:57:41 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:57:47 <hpc> a few of the type classes in lifted-base and monad-control are more powerful than the functions they lift over
06:57:49 <elliott> nart: oh, well that's impossible then.
06:57:57 <hpc> (which is bad for what they are used for)
06:58:01 <elliott> nart: StateT maintains its own *internal* thread of state
06:58:07 <elliott> it can't be interfered with from the outside like that.
06:58:15 <Elemir> ozataman: Web framework for writing a sites without diving into xml, sgml and ecmascript
06:58:17 <hpc> @unmtl StateT s IO a
06:58:18 <lambdabot> s -> IO (a, s)
06:58:18 <elliott> nart: use ReaderT (MVar MyState) IO
06:58:23 <elliott> or TVar MyState
06:58:25 <elliott> or whatever
06:58:36 <hpc> MVar
06:58:39 <hpc> TVar is STM
06:58:39 <elliott> Elemir: html5 is neither xml nor sgml
06:58:49 <elliott> Elemir: and common javascript implementations aren't ecmascript-compatible
06:58:52 <elliott> so: you're in luck!
06:58:53 <ozataman> Elemir: well, the 3 are all web frameworks. I wanted to know a bit more about your project
06:59:02 <elliott> hpc: i know TVar is STM.
06:59:05 <shergill> elliott: heh
06:59:10 <elliott> hpc: it may be a better choice than MVar, still.
06:59:18 <elliott> might even be the better choice more than 50% of the time
06:59:22 <hpc> elliott: not if you still want IO to be the underlying monad :P
06:59:30 <elliott> hpc: uh?
06:59:31 <elliott> :t atomically
06:59:32 <lambdabot> Not in scope: `atomically'
06:59:35 <elliott> grr
06:59:36 <elliott> @hoogle atomically
06:59:37 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
06:59:37 <lambdabot> GHC.Conc atomically :: STM a -> IO a
06:59:37 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
06:59:58 <nart> elliot: thanks for the tip
07:00:00 <elliott> ok, so you have to "ask" the TVar before diving into the atomically
07:00:04 <elliott> but you can encapsulate all that.
07:00:07 <nart> grrr elliott: thanks for the tip	
07:00:14 <elliott> nart: no problem :)
07:00:16 <hpc> elliott: http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Conc-Sync.html#v:unsafeIOToSTM
07:00:21 <elliott> most people just don't bother spelling my name correctly, btw :P
07:00:28 <nart> ehee
07:00:28 <hpc> elliott: what you would do is ReaderT (TVar MyState) STM
07:00:33 <hpc> elliott: then atomically the whole thing
07:00:48 <elliott> hpc: shh!!! there are newbies listening!
07:00:51 <elliott> they might take you seriously
07:01:00 <ozataman> Elemir: are you looking for a quick/dirty rails-like prototyping? is there going to be a lot of CRUD? is it an API server? is it going to be JS-heavy, or mostly server generated views, etc..
07:01:01 <Elemir> ozataman: Argh, I just hate web technologies and wants to abstract from it
07:01:36 <hpc> elliott: what i mean is, it's not safe to be able to perform arbitrary IO inside an STM action
07:01:53 <elliott> hpc: i have no idea why you think i am suggesting doing such a bizarre thing
07:02:01 <hpc> eh, nvm
07:02:19 <elliott> i am suggesting, instead of trying to have a (StateT s IO) in multiple threads somehow, use STM to manage the state
07:02:25 * hackagebot sindre 0.4 - A programming language for simple GUIs  http://hackage.haskell.org/package/sindre-0.4 (TroelsHenriksen)
07:02:25 <elliott> by carrying around a TVar in a ReaderT over the IO
07:02:42 <elliott> if this isn't workable, then using STM from IO isn't workable either, which is a really weird position to take
07:03:21 <chrisdone> anyone wanna try my additions to haskell-mode?
07:03:22 * Elemir don't really want to write a big web shit, just a good old site, but with a normal design
07:03:42 <hpc> elliott: oh, im derp
07:03:52 <elliott> hpc: :)
07:03:55 <hpc> elliott: somehow i tricked myself into thinking that STM TVars were like STVars
07:04:06 <elliott> Elemir: hakyll?
07:04:20 <nart> chrisdone: what kind of additions ?
07:04:20 <elliott> hpc: ah
07:04:22 <hpc> with the whole non-escaping thing
07:04:30 <iainm> Elemir: My very ad-hoc take is: if you want something that has opinions on forms and databases, then probably Yesod. If you want a haskell-flavoured data store, then probably HappStack. If you're doing a totes fashionable js-heavy thang, probably snap.
07:04:34 <elliott> hpc: heh, so all variables must last exactly one transaction
07:04:38 <elliott> hpc: makes isolation easy, I guess
07:04:58 <shergill> chrisdone: i be curious too. what kind of additions?
07:05:18 <hpc> elliott: and also makes the whole purpose of STM void, since there's no way to share the state :P
07:05:25 <hpc> so yeah, im derp
07:05:34 <Elemir> elliott: Hem
07:05:37 <Elemir> Hem
07:05:57 <Elemir> Is it support cgi or something like that?
07:05:58 <hpc> @remember hpc atomically the whole thing
07:05:58 <lambdabot> Okay.
07:06:59 <elliott> Elemir: Well, you said you just want a "good old site".
07:07:15 <elliott> That weakly implies non-interactivity, to me.
07:07:43 <Elemir> Web1.0 impoved interactivity throw cgi and perl :)
07:08:21 <killy9999> @src (.)
07:08:21 <lambdabot> (f . g) x = f (g x)
07:08:21 <lambdabot> NB: In lambdabot,  (.) = fmap
07:09:43 <hpaste> chrisdone pasted “haskell-mode-bindings” at http://hpaste.org/65941
07:10:56 <DMcGill> @src fmap (->)
07:10:56 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:11:00 <Modius> Is there a (a->b)->(a->a->c)->(b->b->c) function?
07:11:10 <DMcGill> @src (->) fmap
07:11:10 <lambdabot> fmap = (.)
07:11:15 <chrisdone> nart: shergill: erm, it adds concepts of "sessions", that is, a project + some running ghci process, and replaces inferior-haskell-mode
07:11:15 <nart> @hoogle (a->b)->(a->a->c)->(b->b->c)
07:11:16 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:11:16 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
07:11:17 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
07:12:12 <chrisdone> nart: shergill: so if you pull the latest haskell mode https://github.com/haskell/haskell-mode/ and use these bindings instead of inferior-haskell's http://hpaste.org/65941 you can try it
07:12:21 <hpc> @djinn (a->b)->(a->a->c)->(b->b->c)
07:12:21 <lambdabot> -- f cannot be realized.
07:12:30 <hpc> wat
07:12:44 <hpc> oh wait, it can't
07:12:53 <hpc> @djinn (a->b)->(b->b->c)->(a->a->c)
07:12:53 <lambdabot> f a b c _ = b (a c) (a c)
07:13:21 <hpc> :t \b -> join (liftA2 b)
07:13:22 <lambdabot> forall b c (f :: * -> *). (Applicative f) => (b -> b -> c) -> f b -> f c
07:13:55 <Modius> Why did I need to import Data.Function to get "on" but didn't need it for flip ?
07:13:56 <chrisdone> nart: shergill: if you use cabal-dev for your projects, add this (custom-set-variables '(haskell-process-type 'cabal-dev))
07:14:03 <hpc> @hoogle flip
07:14:03 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
07:14:03 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
07:14:03 <lambdabot> package Flippi
07:14:07 <hpc> flip is in Prelude
07:14:25 <Modius> Aah, the doc page says "Prelude re-exports" for stuff like that gotcha
07:14:52 <chrisdone> yeah it's pretty annoying to add an import line for one function `on'
07:15:12 <hpc> imo, it's a bug that Prelude doesn't re-export all of Control.Applicative, Control.Monad, Data.Function
07:15:26 <chrisdone> and Data.Ord
07:15:28 <bbommarito> I have to say, I really, really dig Maybe.
07:15:34 <chrisdone> most of the time these are imported for me
07:15:40 <chrisdone> Data.Maybe too
07:15:53 <yitz> ++Maybe
07:15:59 <chrisdone> hpc: i haven't yet thought of a good name for a project-specific Prelude
07:16:01 <elliott> @karma Maybe
07:16:02 <lambdabot> Maybe has a karma of 0
07:16:03 <elliott> ++Maybe
07:16:03 <elliott> @karma Maybe
07:16:04 <lambdabot> Maybe has a karma of 0
07:16:08 <yitz> ?
07:16:09 <hpc> chrisdone: i just call it Lib.All
07:16:14 <killy9999> @src $
07:16:14 <lambdabot> f $ x = f x
07:16:17 <bbommarito> Now that I actually understand what in the hell Maybe, Just and Nothing is.
07:16:20 <chrisdone> hpc: yeah, ugh :)
07:16:31 <hpc> ugh indeed, but it works nicely for websites
07:16:36 <elliott> chrisdone: was about to say Overture, but realised it's taken
07:16:42 <chrisdone> lol
07:16:45 <elliott> yitz: wanted to see if lambdabot recognised preincrements
07:16:51 <hpc> what with the way the import graph is "upside-down"
07:17:05 <yitz> elliott: it does generally
07:17:07 <chrisdone> I have *a lot* of .Extra modules… tis a shame
07:17:17 <ben> @karma Maybe++
07:17:17 <lambdabot> Maybe++ has a karma of 0
07:17:19 <ben> :(
07:17:25 <hpc> @karma c
07:17:25 <lambdabot> c has a karma of 0
07:17:28 <hpc> @karma c++
07:17:28 <lambdabot> c++ has a karma of 1
07:17:31 <yitz> elliott: how about Fugue?
07:17:31 <hpc> wat
07:17:38 <hpc> @karma Cale
07:17:39 <lambdabot> Cale has a karma of 2
07:17:43 <elliott> <yitz> elliott: it does generally
07:17:44 <elliott> are you sure?
07:17:45 <hpc> did the karma file die?
07:17:45 <bbommarito> @karma bbommarito
07:17:45 <lambdabot> You have a karma of 0
07:17:46 <elliott> @karma yitz
07:17:46 <lambdabot> yitz has a karma of 1
07:17:48 <elliott> ++yitz
07:17:49 <elliott> @karma yitz
07:17:49 <lambdabot> yitz has a karma of 1
07:17:51 <elliott> nope
07:17:53 <elliott> postincrements only
07:17:54 <yitz> elliott: used to
07:18:03 <elliott> @karma elliott
07:18:03 <lambdabot> You have a karma of 10
07:18:09 <elliott> hpc: doubt it
07:18:10 <chrisdone> $ find . -name '*.hs' | grep Extra
07:18:10 <chrisdone> ./Data/List/Extra.hs ./Data/Time/Extra.hs ./Data/String/Extra.hs ./Data/Function/Extra.hs ./Control/Monad/Extra.hs ./Text/Digestive/Extra.hs ./Text/Blaze/Extra.hs ./Database/HaskellDB/Extra.hs
07:18:13 <yitz> ++elliot
07:18:13 <hpc> @karma C
07:18:13 <lambdabot> C has a karma of 0
07:18:15 <yitz> ++elliott
07:18:21 <elliott> @karma elliott
07:18:21 <lambdabot> You have a karma of 10
07:18:24 <elliott> nope
07:18:25 <elliott> elliott++
07:18:25 <hpc> C used to have a huge karma
07:18:26 <elliott> @karma elliott
07:18:27 <lambdabot> You have a karma of 10
07:18:29 <elliott> aw
07:18:32 <elliott> hpc: no, that's preflex
07:18:33 <elliott> preflex: karma c
07:18:34 <preflex>  c: 185398
07:18:36 <hpc> oh
07:18:38 <elliott> lambdabot ignores C++
07:18:39 <Elemir> @karma haskell
07:18:39 <chrisdone> this is my way of extending libraries i'm using ^
07:18:39 <lambdabot> haskell has a karma of 3
07:18:39 <hpc> preflex: karma c++
07:18:39 <preflex>  c++: -61
07:18:46 <bbommarito> BRB, irssi is beginning to drive me insane.
07:18:53 <ben> c++++ :(
07:18:56 <hpc> preflex: karma c++
07:18:56 <preflex>  c++: -60
07:18:58 <hpc> haha
07:18:59 <Elemir> c++--
07:19:01 <elliott> chrisdone: pfft, .PlusPlus is clearly better
07:19:04 <elliott> Prelude.Plus.Plus
07:19:11 <elliott> 2karma c++
07:19:12 <elliott> @karma c++
07:19:12 <lambdabot> c++ has a karma of 1
07:19:14 <elliott> (c++)--
07:19:15 <elliott> @karma c++
07:19:15 <lambdabot> c++ has a karma of 1
07:19:16 <chrisdone> that reminds me of a funny thing i read about c++
07:19:27 <bbommarito> There.
07:19:30 <Elemir> @karma lambdabot
07:19:31 <lambdabot> lambdabot has a karma of 4
07:19:35 <Elemir> lambdabot++
07:19:47 <hpc> hehe, DoublePlus.Prelude
07:20:13 <hpc> each new version has fewer and fewer functions, with the rest being error "Please wait for the thought police"
07:20:54 <Modius> Any rule of thumb on using $ vs the equivalent parens?
07:21:01 <ben> Whatever looks nicer to you
07:21:51 <elliott> Modius: whatever you want. although, instead of (f $ g $ x) write (f . g $ x)
07:22:03 <elliott> (a) less visual noise; (b) you can refactor out "f . g" with cut-and-paste, not so for "f $ g"
07:22:08 <elliott> (due to operator precedence)
07:22:09 <chrisdone> on the language used to write the Duqu virus: ‘The idea that the coders are “old school” is also supported by their use of C over the more modern C++ language.’
07:22:32 <chrisdone> i love incompetent software journalism
07:22:48 <chrisdone> (http://www.wired.com/threatlevel/2012/03/duqu-mystery-language-solved/)
07:22:59 <shergill> we need us some fortran viruses
07:23:31 <shergill> or algol
07:23:46 <bbommarito> So, anyone in here work on the Haskell wiki?
07:24:50 <elliott> chrisdone: "Most commenters who wrote in response to Kaspersky’s plea thought the code was a variant of LISP" wat
07:24:52 <chrisdone> i sometimes edit it, but not in a way that would get me in trouble or require me to do something for anyone
07:25:02 <elliott> i never once saw that suggestion in multiple comment threads on the topic
07:25:23 <bbommarito> Because I found a video that is a useful Haskell learning resource, but don't know where to put it on the resources page.
07:25:28 <chrisdone> probably in email correspondance. i think that's what people use when they're not on reddit or ycombinator
07:25:32 <Modius> I'm gonna say it - I've done enough Haskell now that I have been able to finally witness supreme beauty that I haven't seen since (albeit in another form) Common Lisp
07:25:32 <elliott> "Two other people who sent Kaspersky direct emails made crucial contributions when they suggested that the code appeared to be generated from a custom object-oriented C dialect — referred to as OO C — using special extensions." lol the secret C dialect of "OO C"
07:26:23 <bbommarito> So, does OO C == Objective-C, since Objective-C is C with Objects? Or C++?
07:26:40 <Modius> (I don't claim to know a great deal of haskell, just enough now to see the elegance)
07:26:40 <elliott> Objective-C isn't C with objects, it's C with Smalltalk plus superglue
07:26:51 <hpaste> a pasted “a” at http://hpaste.org/65942
07:27:04 <chrisdone> what's more of a polemic word in programming discussion, “OO” or “scripting language”?
07:27:10 <elliott> wtf is it with the nonsense pastes that keep getting posted in here by hpaste
07:27:16 <elliott> they only started recently
07:27:18 <bbommarito> elliott: Sad thing is: I used to write a lot of smalltalk, and Obj-C hurts my head...
07:27:18 <hpaste> me annotated “a” with “a (annotation)” at http://hpaste.org/65942#a65943
07:27:27 <elliott> the lamest trolling attempt ever?
07:28:06 <shergill> any thoughts on proving the need for unsafePerformIO . newIORef? how can i assure myself that a mutable object really is required? or any good rules of thumb?
07:28:15 <chrisdone> possibly someone is writing a program to make pastes
07:28:51 <shergill> or extending/testing hpaste.el, yeah
07:30:08 <bbommarito> Anyway, the video is a Google video, and it's basically an hour of Haskell being thrown around. He explains it, but it's not a tutorial, it expects programming knowledge.
07:30:09 <chrisdone> your own mutable objects are usually necessary when a library or control structure you're working with doesn't let you pervade state through the monad or as parameter passing
07:30:18 <elliott> shergill: if you need it, you'll know
07:30:22 <elliott> if you don't know, you don't need it
07:30:33 <elliott> if you know before thinking about it for a few minutes, you don't really know
07:30:54 <shergill> elliott: it's easy to fool ones own self =/
07:31:03 <elliott> e.g., like chrisdone said, when you're interfacing with external libraries, that's a good reason to know
07:31:13 <Modius> Is there a generic "union" type, like Maybe but can be TypeA or TypeB?
07:31:22 <elliott> or if you're writing something that "extends" the language, like an externally-pure memoisation library
07:31:34 <elliott> if it's neither of those, you're very unlikely to need it
07:31:37 <elliott> Modius: Either A B
07:31:45 <elliott> Left :: a -> Either a b; Right :: b -> Either a b
07:31:51 <shergill> yeah, i am using it to cache the result of io transactions for a given time window
07:32:07 <elliott> Modius: in general you might be better off defining your own, more descriptive type. but "Either SomeError Result" is fine (and has a Monad instance to match, if you know how Maybe's works)
07:32:15 <elliott> shergill: then it might be OK.
07:32:25 * hackagebot biostockholm 0.2.2 - Parsing and rendering of Stockholm files (used by Pfam, Rfam and Infernal).  http://hackage.haskell.org/package/biostockholm-0.2.2 (FelipeLessa)
07:32:27 <elliott> shergill: are you not in a monad transformer stack already?
07:32:33 <elliott> best to slip the state in there if you can.
07:33:14 <shergill> elliott: i tried that, but i'd like it to be externally transparent i.e., across function calls without state having to be explicitly passed around
07:33:21 <chrisdone> i have some TH code that uses unsafePerformIO . newIORef. i was showing it SPJ because there's some GHC weirdness where it shows warnings for unused vars despite being used, he noticed unsafePerformIO and ran away screaming
07:33:39 <shergill> haha
07:36:58 <chrisdone> k so no one interested in trying my emacs thing right now. i'm off
07:39:18 <elliott> shergill: well your function still returns an IO action, right?
07:39:32 <shergill> elliott: correct
07:39:37 <elliott> so you're in a monad already. no harm in making it (MonadWithMyAdditionalCache m) rather than (MonadIO m), so to speak
07:40:39 <shergill> except i'd like to be able to make it a drop in replacement where you have a MonadIO constraint so it should be an instance of MonadIO
07:41:20 <elliott> shergill: well, what you are saying is "I would like to do it with unsafePerformIO, so it should be done with unsafePerformIO"
07:41:34 <elliott> I can't argue against that, only ask you if you might want to reconsider
07:42:06 <shergill> elliott: ah am i? well then that's fine. i did not know if there was another way to achieve what i wanted or if it really meant using unsafePerformIO
07:45:09 <cody_> any idea on why this code is throwing an error message saying I have ambiguous type variables in the constraints?
07:45:13 <cody_> http://hpaste.org/65946
07:46:41 <ClaudiusMaximus> cody_: fromIntegral should help
07:46:44 <Saizan> cody_: works fine here
07:46:58 <Saizan> ah, yeah, the problem is using it
07:47:13 <Modius> I can't find on hoogle - is there an equiv of:           \x->(b,x)       ?
07:47:19 <byorgey> cody_: use  n `div` 2  instead of  truncate (n/2)
07:47:34 <byorgey> cody_: / is for floating point division, it cannot be used on integral types
07:47:56 <Saizan> Modius: (,) b
07:48:05 <Modius> Haha but of course :)
07:48:06 <cody_> byorgey: thanks, but doesn't truncate convert it to an int?
07:48:16 <elliott> Modius: or (b,) with {-# LANGUAGE TupleSections #-}
07:48:18 <byorgey> cody_: the problem isn't with truncate but with the division.
07:48:19 <elliott> cody_: yes, the problem is input
07:48:26 <byorgey> cody_: if n is an Int, you cannot call / on it
07:48:44 <byorgey> because / expects some fractional type such as Double or Rational
07:49:06 <cody_> ahh i see
07:49:27 <byorgey> cody_: if you wanted to do division on an Int and end up with a Double (say), you could do  fromIntegral n / 2
07:49:34 <byorgey> which converts the Int to a Double first
07:49:51 <byorgey> but in this case you just want to do integer division anyway, so you should use `div`
07:49:55 <byorgey> > 5 `div` 2
07:49:56 <lambdabot>   2
07:50:12 <cody_> truncate $ 5 / 2
07:50:17 <cody_> > truncate $ 5 / 2
07:50:17 <lambdabot>   2
07:50:33 <cody_> byogery: i see point though
07:50:37 <cody_> *your
07:50:38 <Modius> Is there a shorter way (without TupleSections) to express this?:  (flip (,)) 3
07:50:46 <elliott> cody_: 5 and 2 there are Doubles
07:50:47 <byorgey> cody_: note that integer literals are polymorphic
07:50:59 <byorgey> cody_: so in the case of 5 / 2  it chooses the type Double for 5 and 2
07:51:14 <byorgey> which is why you can do  5 / 2  but not  n / 2  when n :: Int
07:52:26 * hackagebot hierarchical-clustering 0.4.1 - Fast algorithms for single, average/UPGMA and complete linkage clustering.  http://hackage.haskell.org/package/hierarchical-clustering-0.4.1 (FelipeLessa)
07:52:50 <cody_> that clears it up
07:53:37 <bbommarito> Okay, is there a performance penalty for using fmap vs map?
07:54:31 <sepp2k> bbommarito: No
07:54:32 <bitonic> bbommarito: there is one more level of indirection. you shouldn't notice anything anyways.
07:55:09 <bitonic> bbommarito: the compiler/interpreter has to look up for the method in the typeclass definition, while with map it doesn
07:55:11 <bitonic> 't
07:55:25 <elliott> uh
07:55:38 <elliott> bitonic: there's pretty much no chance GHC won't inline fmap when used on lists
07:55:49 <elliott> it can easily be resolved at compile-time with no indirection
07:56:16 <bitonic> elliott: yeah
07:56:28 <elliott> i guess it might have an overhead in Hugs :
07:56:29 <elliott> :p
07:56:38 <bbommarito> So, if fmap really won't make a difference performance wise vs map, is there a reason to not use fmap (IE developers hate that, or someone will hunt you down and kill you for doing it)?
07:56:49 <bbommarito> I mean to not use fmap all the time.
07:57:06 <sepp2k> bbommarito: It's one more letter to type :p
07:57:07 <bitonic> bbommarito: you have to clutter your function with Functor constraints
07:57:12 <ben> map is only really there because people wanted to tell newbies about lists before they tell them about type classes
07:57:23 <elliott> bitonic: not if the type is a list...
07:57:23 <bitonic> bbommarito: if you're using [] already, then no,  no difference
07:57:30 <elliott> bbommarito: map is generally used when you're using lists
07:57:41 <elliott> bbommarito: is there any particular reason for it? no, but it's convention, and probably clearer
07:57:48 <bitonic> elliott: yeah I assumed that he wanted fmap to make the function more generic
07:57:48 <elliott> if I see "fmap" I'll think "oh, what's the Functor?"
07:57:57 <bbommarito> elliott: That was what I was looking for.
07:58:03 <bbommarito> convention...
07:58:08 <elliott> I mean, ideally fmap would be called map
07:58:20 <elliott> but as it is, if I see someone using fmap or (<$>), I'm not going to expect the functor in question to be a list
07:58:28 <hpc> ideally, (<$>) would be called (.) too
07:58:30 <elliott> in 90% of cases
07:58:34 <elliott> hpc: no :(
07:58:39 <elliott> hpc: that should be Control.Category.(.)
07:58:42 <bitonic> hpc: no?
07:59:10 <ClaudiusMaximus> i find concatMap is clearer than (=<<)
07:59:22 <bitonic> I wouldn't want a generic (.) in the Prelude, I'd be really confused as a beginner :P
08:00:09 <elliott> who cares about beginners?! the point is that fmap is the *wrong* abstract nonsense for (.)! :)
08:00:33 <bitonic> I use >>> to compose functions anyways.
08:00:43 <bitonic> to add some Arrow spice
08:00:56 <elliott> bitonic: !
08:00:58 <elliott> (>>>) is not Arrow
08:01:01 <elliott> it's Control.Category
08:01:09 <elliott> just like i was proposing (.) be :p
08:01:18 <ben> That's, like, three arrows per function composition!
08:01:18 <ben> A bit excessive!
08:01:20 <bitonic> yeah, but it's used mostly for arrows
08:01:21 <hpc> real men use (<=<) and write all their functions in Kleisli Identity
08:01:33 <bitonic> hpc: <=< is <<< :P
08:01:35 <elliott> bitonic: tell that to lens users :)
08:01:45 <elliott> (<=<) is only (<<<) modulo a newtype
08:02:12 <bitonic> elliott: ehe, ok. I learnt it with Arrows and my brain associates it with that now :P
08:02:41 <yasar> Does lazy evaluation cause stack overflows often in haskell?
08:02:56 <hpc> yasar: sometimes
08:03:07 <hpc> sometimes strict evaluation causes the heap to fill up
08:03:12 <bitonic> yasar: lazy evaluation causes stack overflow when people write wrong programs
08:03:31 <bitonic> in the same way that recursion causes stack overflow
08:03:39 <ben> bitonic: Sometimes the wrong program is ghc~
08:04:20 <bitonic> yasar: in other words, you have to know what you're doing :)
08:04:26 <yasar> Isn't haskell optimized for recursion? I mean, recursion is heart of the haskell.
08:04:40 <hpc> yasar: there's many kinds of recursion
08:04:50 <yasar> bitonic: That goes for evert language I guess.
08:04:51 <ben> Given lazy evaluation you don't really recurse all that much
08:04:54 <hpc> (or rather, many shapes that recursion can take)
08:05:13 <hpc> @src foldr
08:05:13 <lambdabot> foldr f z []     = z
08:05:13 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:05:15 <hpc> @src map
08:05:16 <elliott> yasar: recursion is a fairly low-level technique
08:05:16 <lambdabot> map _ []     = []
08:05:16 <lambdabot> map f (x:xs) = f x : map f xs
08:05:20 <elliott> we like to use combinators instead when we can
08:05:28 <elliott> like, as hpc showed, foldr, or map
08:05:34 <hpc> @src mapM
08:05:35 <lambdabot> mapM f as = sequence (map f as)
08:05:39 <hpc> @src sequence
08:05:39 <lambdabot> sequence []     = return []
08:05:40 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:05:40 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
08:05:51 <hpc> functions, functions everywhere
08:06:20 <ben> at least (:)) looks like a fairly happy function
08:06:27 <hpc> @src foldl
08:06:28 <lambdabot> foldl f z []     = z
08:06:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:06:34 <yasar> I thought map and foldr themselves were implemented recursively.
08:06:52 <hpc> yasar: they are
08:06:56 <hpc> see above
08:07:41 <elliott> yasar: yes, high-level techniques are implemented on top of low-level techniques
08:07:54 <elliott> the compiler turns "if" and "while" into "goto"s, that doesn't make the latter high-level :)
08:08:00 <elliott> (*the C compiler)
08:08:24 <nart> what is the difference from using a State Monad over using Reader Monad and a TVar ?
08:08:51 <elliott> nart: well, you need to have IO at the base to use the latter, since STM runs in IO
08:09:13 <elliott> and you can share the same TVar over multiple ReaderTs, letting you do things like fork threads off that share the state, etc.
08:09:14 <bitonic> nart: a State monad is simply some computation carrying a state around. TVar is used STM to write concurrent programs
08:09:38 <bitonic> so they let you do different things
08:10:18 <nart> ah ok, so because i'm writing an Irc Bot, i should use Reader + TVar right ?
08:10:28 <bitonic> nart: it depends what you need to do
08:10:33 <elliott> i don't see the relevance of irc bot :)
08:10:45 <bitonic> if State serves your needs, use that.
08:11:04 <bitonic> STM is a completely different beast, and it needs IO to be executed
08:11:29 <bitonic> State is basically a function of type s -> (a, s)
08:11:38 <elliott> nart: if you want to share state between multiple threads, you want TVars
08:11:49 <elliott> (or MVars)
08:12:01 <elliott> nart: note that you'll probably want more than one TVar
08:12:21 <jmcarthur> nart: a TVar is a kind of reference like you may be used to in other languages (except with some neat transactional stuff to help with shared memory concurrency). the State monad simply gives you access to a single value that you can read and modify
08:13:01 <ben> Only one value? Someone gotta invent a state monad that can carry multiple values!
08:13:03 <jmcarthur> nart: if you want references without the transactional stuff you could just use IORef
08:13:19 <nart> ok, thanks for the explanation, i know see that i have to write it with TVar
08:13:30 <jmcarthur> ben: just store a value that holds multiple values within. or use multiple state monad transformers
08:13:58 <jmcarthur> nart: there are a few kinds of references. the most common are IORef, MVar, and TVar, each with different uses
08:13:59 <Philonous_> What happened to chrisdone's haskell-emacs? Is it merged with haskell-mode?
08:14:11 <elliott> ben: scientists have discovered a revolutionary way to pack multiple values into one.
08:14:16 <elliott> Philonous_: it still exists
08:14:23 <ben> So, like, I'd use the StateT from mtl and the one from transformers and
08:14:30 <bitonic> ben: and a tuple.
08:14:33 <elliott> ben: mtl staett = transformers statet
08:14:36 <elliott> *statet
08:14:42 <elliott> mtl is based on transformers nowadays.
08:14:53 <jmcarthur> ben: no, you could just use many of the same transformer and use lift in various ways to reach each one
08:15:03 <jmcarthur> (i'm not endorsing this for large numbers of values, for the record)
08:15:18 <Philonous_> elliott:  I tried to pull it earlier but the repo on github is gone, instead he seems to be actively contributing to haskell/haskell-mode
08:15:28 <bitonic> that's the wrong way of storing multiple values, you should always keep one State in your monad stack imo
08:15:32 <jmcarthur> ben: but really, a record type with one state monad is fine
08:15:46 <jmcarthur> bitonic: sometimes multiple ones come up due to composing various other monads. this is fine
08:15:53 <ben> But then I'll need to throw away the whole record when I just want to change one value!
08:16:09 <jmcarthur> bitonic: you should shouldn't use multiple state monads just because you want more than one value to modify
08:16:19 <bitonic> jmcarthur: it's not that fine because you lose the possibility to use the typeclasses (MonadState etc.)
08:16:21 <jmcarthur> ben: is that so bad?
08:16:28 <elliott> Philonous_: oh, huh
08:16:32 <elliott> Philonous_: well, he was in here just minutes ago.
08:16:37 <elliott> talking about something to do with haskell and emacs, so...
08:16:39 <jmcarthur> bitonic: you basically should abstract away the fact that State is involved at all, most of the time
08:16:42 <elliott>  @ask him?
08:17:03 <elliott> ben: throw away?
08:17:08 <elliott> ben: the record will consist of a few pointers
08:17:10 <bitonic> jmcarthur: yes, and you can't if you have multiple State in your stack. which is why you shouldn't.
08:17:21 <ben> elliott: Yeah, but most of those pointers are still gonna point to the right values
08:17:28 <elliott> ben: yes, so? those will be kept
08:17:29 <hpc> i think you can have multiple states of different types in the stack
08:17:33 <elliott> the overhead will be very tiny.
08:17:35 <Philonous_> elliott:  He seems to be gone now, but I will.
08:17:43 <elliott> Philonous_: thus the @ before ask :)
08:17:46 <hpc> StateT A (StateT B Foo) -- for instance
08:17:49 <elliott> @ask Philonous_ do you know how to use @ask?
08:17:49 <lambdabot> Consider it noted.
08:17:55 <ben> elliott: Surely it's gonna have to allocate a whole new record, copy the old pointers over and just slot in one new one at a time
08:18:32 <ben> Maybe I should make it a record of a bunch of IORefs
08:18:33 <elliott> ben: allocate a whole new record - free (GHC can allocate a handful of pointers very quickly); copy the old pointers over - free (a few MOVs); change one of them - free (one MOV)
08:18:34 <nart> Philonous_: he posted: chrisdone	nart: shergill: so if you pull the latest haskell mode https://github.com/haskell/haskell-mode/ and use these bindings instead of inferior-haskell's http://hpaste.org/65941 you can try it
08:18:44 <elliott> ben: that won't do anything. IORefs are a single pointer in a record just the same
08:18:50 <jmcarthur> bitonic: i think you missed my point. the point is that each abstraction should hide no more than one state monad underneath it (usually). however, layering these larger stacks on top of each other will result in a stack that technically has multiple state monads, and i claim that this scenario is just fine
08:18:57 <ben> Yeah, but then I won't ever need to change the record
08:18:58 <elliott> seriously, if you're worrying about how long allocating a new record will take, you need to stop using haskell and go use C
08:19:12 <elliott> because you're caring about fractions of fractions of a second :)
08:19:38 <elliott> thunks involve memory allocation too!
08:19:53 <bitonic> jmcarthur: and I claim it isn't, because you can't use MonadState if you have that situation.
08:19:57 <elliott> Philonous_: <chrisdone> anyone wanna try my additions to haskell-mode?  <chrisdone> nart: shergill: erm, it adds concepts of "sessions", that is, a project + some running ghci process, and replaces inferior-haskell-mode  <chrisdone> nart: shergill: so if you pull the latest haskell mode https://github.com/haskell/haskell-mode/ and use these bindings instead of inferior-haskell's http://hpaste.org/65941 you can try it
08:20:00 <elliott> Philonous_: so, looks like it
08:20:02 <jmcarthur> i admit to using IORefs with Reader on a few occasions
08:20:18 <elliott> IORefs + Reader is fine, of course
08:20:22 <jmcarthur> bitonic: i claim that most reasonable abstractions will not expose MonadState at all
08:20:30 <elliott> but "State Record is slow because it has to allocate and copy" is silly in the highest :)
08:20:31 <bitonic> jmcarthur: ? what do you mean?
08:20:58 <bitonic> I use MonadState all the time
08:20:59 <Philonous_> nart, elliott thanks, so I guess he merged his own haskell mode into this.
08:20:59 <lambdabot> Philonous_: You have 1 new message. '/msg lambdabot @messages' to read it.
08:21:01 <jmcarthur> bitonic: i, the use of a library, do not care how the monad is implemented and don't want to deal with low level operations like putting a getting some state
08:21:04 <jmcarthur> *user of
08:21:57 <bitonic> jmcarthur: no, you don't understand. If you have a function 'MonadState Foo m => m a', and you want to run it with a stack 'StateT Bar (State Foo)', you can't
08:22:43 <jmcarthur> bitonic: the point is that i don't want to *have* a stack 'StateT Bar (State Foo)' in the first place. also, for the record, i can access either state with MonadState in this case with no trouble at all
08:23:00 <jmcarthur> bitonic: the point is that the fact that it's a stack of state monads is an implementation detail
08:23:20 <bitonic> jmcarthur: well then we agree. I am arguing against stacks of monad with multiple StateT
08:23:38 <jmcarthur> we do not agree, i think
08:23:54 <bitonic> well than there's some serious communication problem here :P
08:23:58 <jmcarthur> stacks of monads with multiple StateT is fine. i just don't want such a low level detail to be exposed
08:24:17 <bitonic> oh god. they're not fine because you can't use those stacks with generic functions.
08:24:26 <jmcarthur> monad transformers are for creating abstractions. transformer stacks are not the end result
08:24:48 <jmcarthur> why not?
08:24:56 <bitonic> because haskell will just pick the first instance
08:24:59 <jmcarthur> i think you are confused, for what it's worth
08:25:03 <bitonic> it won't reach the second state
08:25:05 <jmcarthur> you can still use MonadState
08:25:07 <jmcarthur> yes it can
08:25:15 <mauke> jmcarthur: only with manual lifting
08:25:19 <bitonic> jmcarthur: no
08:25:19 <jmcarthur> no
08:25:28 <bitonic> ... I'll write an example
08:25:31 <jmcarthur> the only time it can't automatically is when they are the same type
08:25:52 <elliott> i think jmcarthur is completely wrong
08:25:55 <elliott> because of the functional dependency
08:26:08 <elliott> instance MonadState (StateT Bar (State Foo)) Bar, therefore not instance MonadState (StateT Bar (State Foo)) Foo
08:26:10 <elliott> because m -> s
08:26:25 <elliott> i think i flipped the args there; w/e
08:26:38 <jmcarthur> oh stupid fundep
08:26:41 <bitonic> jmcarthur: what elliott said. if you're still not convinced, I'll write an example.
08:27:15 <elliott> jmcarthur: that stupid fundep is stopping ghc's brain exploding with ambiguity :)
08:27:23 <elliott> but yes without it it would "work"
08:27:48 <jmcarthur> i still claim that you rarely *care* if you shadow one state with another
08:27:52 <bitonic> I don't think it couldn't be otherwise considering how haskell picks instances...
08:27:58 <jmcarthur> because you want to abstract such things away anyway
08:28:04 <elliott> bitonic: it could
08:28:06 <Philonous_> elliott:  How would you write the lifting instance for StateT?
08:28:08 <elliott> you'd just have to specify the types a lot
08:28:14 <elliott> Philonous_: ?
08:28:22 <elliott> oh, right
08:28:27 <bitonic> elliott: I mean with the current situation in terms of specifying constraints
08:28:28 <elliott> jmcarthur is wrong even if you get rid of the fundep
08:28:34 <jmcarthur> i agree. i was wrong about that
08:28:36 <elliott> because you'd need a lifting instance for StateT, which would conflict with the one that actually uses the state
08:28:44 <bitonic> yes
08:28:44 <elliott> yeah ok
08:29:10 <bitonic> jmcarthur: I disagree what you rarely care about that. In my experience you care most of the times
08:29:18 <jmcarthur> i've never made a transformer stack and exposed its guts or any mtl instances outside of the module, though
08:29:27 <jmcarthur> i've never cared
08:29:52 <bitonic> because you never had this situation in which you had to compose different states
08:30:11 <jmcarthur> i take that back slightly... i've exposed mtl instances before, but they were only to lift the base monad through a new transformer that i made
08:30:16 <jmcarthur> yes i have
08:30:19 <elliott> jmcarthur seems to be coming from the perspective of implementing monads in terms of StateT
08:30:25 <elliott> rather than end-user code which has to manage multiple levels of state
08:30:27 <jmcarthur> correct.
08:30:32 <elliott> sure, two monads that use StateT internally stacked on top of each other is fine
08:30:37 <elliott> two StateTs stacked on top of each other is not
08:30:45 <bitonic> elliott: which is what I was arguing the whole time :P
08:30:47 <jmcarthur> i never expose the fact that mtl is involved in the implementation at all
08:30:49 <elliott> you're unpacking newtypes mentally, which is making your perspective absurd from the POV of end-user code
08:30:54 <elliott> which does *not* see the two as equivalent
08:31:00 <elliott> jmcarthur: yes, but bitonic isn't talking about library code!
08:31:06 <elliott> they're talking about application code which has its own stack
08:31:17 <jmcarthur> i used the word "library" several times
08:31:22 <elliott> including two StateTs (<-- *not* StateT-based monads) in that stack to manage multiple states is a recipe for pain
08:31:37 * elliott isn't taking sides, just annoyed at the miscommunication :P
08:31:51 <jmcarthur> even in application code, i abstract such things
08:31:55 <bitonic> jmcarthur: and I always used the word StateT, not something wrapping a StateT. anyways, things are clear now
08:32:09 <jmcarthur> if i need two different states, i just make two functions for accessing each and i'm done with it
08:32:27 <jmcarthur> even as a type class, if i want
08:32:41 <jmcarthur> layering state monads is never an issue this way
08:32:53 <bitonic> no, you don't, if you want to keep the functions generic!
08:33:22 <jmcarthur> class MonadFoo m where  getFoo :: m Foo; setFoo :: Foo -> m ()  ...   <- plenty generic
08:33:23 <bitonic> of course you can create your own scaffolding
08:33:33 <bitonic> jmcarthur: yeah, generic just for your code in that context
08:33:39 <elliott> jmcarthur: so you rewrite MonadState every time you want to use a state monad?
08:33:41 <jmcarthur> generic for any monad implementing that interface
08:33:46 <bitonic> the nice thing about MonadState & co. is that everybody has access to them
08:33:55 <jmcarthur> no, i use StateT and write an instance of MonadFoo for the newtype
08:34:04 <elliott> MonadFoo is MonadState Foo
08:34:07 <bitonic> boilerplate fest
08:34:07 <jmcarthur> yeah, it's nice within a particular module
08:34:26 <jmcarthur> elliott: the difference is i can have MonadFoo and MonadBar
08:34:40 <jmcarthur> elliott: but not, as you rightly pointed out, MonadState Foo and MonadState Bar
08:34:45 <jmcarthur> elliott: further, this was a bad example
08:34:54 <bitonic> jmcarthur: that defies the point of "generic" functions.
08:34:56 <jmcarthur> i normally wouldn't expose getters and setters. i would expose more domain specific functions
08:35:08 <reinoud> i have a silly performance question..... how fast is uniqueifying [(x,y,z)] with as input [[x+dx, y+dy, z+dz] | (x,y,z) <- shell, dx <- [-d..d], dy <- [-d..d], dz <- [-d..d]] for say d = 6 and shell say 300 elements?
08:35:12 <bitonic> if you're creating a typeclass specific for each of your monad stacks
08:35:43 <mauke> reinoud: define "uniquefying"
08:35:47 <jmcarthur> only sometimes
08:36:03 <reinoud> as in no doubles of (x,y,z) pairs
08:36:04 <jmcarthur> i want to emphasize that i'm *not* just reimplementing MonadState each time
08:36:16 <reinoud> they are ints btw
08:36:18 <mauke> reinoud: as in actual code
08:36:26 <jmcarthur> these are more in tune with the kind of interface i *want* out of the stack rather than what its implementation offers by default
08:36:40 <bitonic> jmcarthur: I don't get you. This discussion is dead :P
08:36:47 * jmcarthur shrugs
08:37:01 <reinoud> i wondow how the lazy evaluation would effect this... or will it just create the list for i'll have to sort and then remove doubles?
08:37:24 <mauke> what
08:37:51 <mekeor> Do I have to an Haskell-interpreter to use Haskell with FastCGI?
08:38:01 <elliott> mekeor: no, just write a fastcgi server (with the fastcgi library say) and compile it
08:38:08 <elliott> I wonder how many times mauke has said what in #haskell
08:38:29 <bitonic> what, what?
08:38:41 <bitonic> I think we could find out
08:39:05 <mekeor> elliott: so, i wanna use haskell with fastCGI with lighttpd on linux on an ARM-platform. would that work?
08:39:14 <mekeor> (because there's no GHCI for ARM…)
08:39:15 <bitonic> mekeor: the hardest part of that is "ARM"
08:39:21 <bitonic> not fastcgi
08:39:22 <mekeor> bitonic: why?
08:39:32 <bitonic> I'm not sure how good ARM support is for GHC.
08:39:40 <elliott> there's an iphone port
08:39:44 <elliott> and an android port underway
08:39:45 <reinoud> can't it use the 'c' backend?
08:39:51 <elliott> so i wouldn't be surprised if arm/linux worked...
08:39:51 <mekeor> GHC runs on ARM. ghcI not.
08:40:05 <bitonic> mekeor: ok, then you can do what you want to do
08:40:08 <elliott> reinoud: -fvia-c is deprecated (and actually it wouldn't help because it's unportable)
08:40:16 <mekeor> bitonic: yippie yay
08:40:19 <elliott> the unregistered C is what would be relevant
08:40:24 <bitonic> well, it's portable where GCC is portable, isn't it?
08:40:27 <elliott> (it outputs portable, very-slow C)
08:40:30 <elliott> bitonic: no
08:40:34 <elliott> the C outputted by the C backend is platform-specific
08:40:40 <bitonic> elliott: oh ok.
08:40:58 <bitonic> i've heard horrible things about -fvia-C C, but I didn't know that :P
08:40:58 <elliott> bitonic: and it's not even just gcc, it shoves the assembly gcc generates through a literate perl script to do tail calls
08:41:05 <elliott> (yes, literate perl)
08:41:10 <mekeor> whenever someone has too much time (that is, he's bored), please port GHCI to ARM! thanks in advance.
08:41:11 <bitonic> oh god, right. the evil mangler
08:41:14 <elliott> there's a reason -fvia-c is deprecated :P
08:41:25 <elliott> mekeor: i think it's being worked on.
08:41:34 <reinoud> is it currently creating asm directly then?
08:41:36 <mekeor> elliott: it's even removed in the latest ghcs.
08:42:09 <bitonic> reinoud: there are two mantained backend. one that generates native code directly, and the other which produces LLVM bytecode and then lets LLVM do the heavy lifting
08:42:12 <bitonic> *backends
08:42:13 <mekeor> reinoud: not asm but binary, i believe.
08:42:30 <ben> "the true performance potential of haskell is still unknown. [...] the only large program in haskell remains GHC and darcs, and darcs is extremely slow."
08:42:33 <ben> :I
08:42:54 <elliott> reinoud: there's also the llvm backend
08:43:08 <bitonic> mekeor: no, it generates assembly
08:43:11 <reinoud> oh that llvm might be neat for the ARM :) it works for ARM AFAIR
08:43:18 <elliott> ben: please, keep the stupid statements about haskell to /r/programming ;)
08:43:26 <mekeor> which is the biggest haskell currently actually? (apart from GHC)
08:43:35 <bitonic> ben: there are plenty of industrial haskell users
08:43:42 <mekeor> bitonic: rly? srsly?
08:43:47 <bitonic> mekeor: yes, rly
08:44:11 <mekeor> abbr r fny
08:44:16 <ben> It's a quote from hn, a bunch of possible counterexamples spring to mind but I'm not sure I want to start a language performance slapfight. http://news.ycombinator.com/item?id=3752510
08:44:22 <bitonic> galois, standard chartered, tsuru, barclays capital, that swedish startup, others that I don't know
08:44:36 <elliott> hacker news, /r/programming, what's the difference.
08:44:54 <ben> Dude gets props for calling "faster than c" benchmarks "superluminal" though :)
08:45:16 <mekeor> pandoc is quite big, isn't it?  (talking about the biggest Haskell-project…)
08:45:30 <bitonic> pandoc is quite big yes
08:45:34 <mekeor> Yi, too.
08:45:44 <elliott> i suspect the web frameworks are bigger
08:45:52 <mekeor> ah, right..
08:45:52 <bitonic> yesod probably
08:46:00 <mekeor> or snap
08:46:02 <bitonic> and the whole happstack environment
08:46:05 <bitonic> snap is pretty small afaik
08:46:15 <ben> Those guys with their webservers are getting fairly good performance from haskell too, aren't they?
08:46:22 <mekeor> but i think, as ben said, there's no really big haskell-project!
08:46:40 <ben> Though I suppose requests per second is also just a microbenchmark
08:46:49 <bitonic> mekeor: ...we just mentioned some? what do you mean by big?
08:46:55 <elliott> ben: there's that mighttpd benchmark where it beats nginx under certain circumstances :P
08:47:09 <bitonic> also darcs being slow has nothing to do with haskell
08:47:13 <ben> Maybe someone should write a git client in haskell then :)
08:47:14 <mekeor> bitonic: firefox, linux are big
08:47:21 <mekeor> bitonic: emacs is big
08:47:45 <mekeor> bitonic: games are big – oh right! there's a haskell ego-shooter!
08:47:49 <bitonic> mekeor: those are huge, not big. what's a clojure or scala or whatever project that big?
08:48:01 <mekeor> idk
08:48:08 <ben> I'd say darcs and ghc certainly count as "big"
08:48:16 <bitonic> yeah, so "find me something as big as linux" is a silly argument
08:48:20 <elliott> mekeor: now think how big GHC would be if it wasn't written in haskell
08:48:23 <mekeor> so, is there (apart from GHC (and darcs??)) a huge haskell-project?
08:48:29 <ben> and finding stuff on the order of darcs' magnitude shouldn't be too hard
08:48:30 <mekeor> elliott: hehe
08:48:32 <elliott> this question is stupid
08:48:45 <elliott> not only are haskell programs much smaller than programs in languages like C++
08:48:49 <mekeor> XMonad is big!
08:48:55 <bitonic> xmonad is very small.
08:48:55 <elliott> but projects of a gigantic size are very rare full stop
08:48:58 <bitonic> xmonad-contrib is kinda big
08:49:07 <bitonic> well, very small
08:49:11 <ben> elliott: I think it would be fair to measure "big" by complexity and not lines of code
08:49:12 <bitonic> it's what, 2k lines? it's mid sized
08:49:13 <elliott> what about the agda compiler?
08:49:21 <elliott> ben: good luck coming up with an objective cross-language measure of complexity
08:49:25 <bitonic> yeah the agda compiler is big and complex :P
08:49:48 <ben> elliott: I'm gonna reply to the guy saying that ghc, written in haskell, compiles code faster than g++, written in C, does
08:49:52 <ben> argue with that!
08:50:14 <mekeor> inquiry: which haskell-programs do you use daily?   GHC, XMonad, … ?
08:50:18 <bitonic> ben: replies to silly statements are useless
08:50:20 <elliott> ben: you should adopt my tactic: ignore discussions about haskell on social news websites that are not /r/haskell
08:50:34 <bitonic> mekeor: GHC, Agda.
08:50:36 <elliott> it does wonders to cure misanthropy
08:50:40 <bitonic> darcs sometimes.
08:50:51 <bitonic> (XMonad sucks, long live i3)
08:50:51 <elliott> mekeor: ghc, xmonad
08:51:02 <elliott> cabal
08:51:03 <elliott> :p
08:51:06 <shergill> mekeor: yesod, ghc/ghci
08:51:07 <mekeor> oh, right
08:51:11 <stulli> don't forget xmobar! :)
08:51:14 <shergill> oh cabal
08:51:16 <mekeor> oh, right
08:51:16 <shergill> heh
08:51:18 <elliott> i don't use xmobar
08:51:27 <mekeor> me, too.
08:52:31 <mekeor> i'll push the inquiry/survey to #-blah
08:59:30 <jmcarthur> funny that we like to claim that haskell uses fewer lines of code than other languages and then turn around and try to come up with large haskell projects as evidence of how it scales
08:59:38 <jmcarthur> well, sort of funny, at least
09:00:07 <byorgey> why is that funny?
09:03:21 <shergill> elliott: cyclomatic complexity or some variant thereof would probably be slightly more general than loc
09:03:52 <shergill> ben: ^
09:04:03 <ben> *nod*
09:06:57 <mekeor> so, when i do 'cabal install packageNameHere --global', then it put's the executable to /usr/bin/ or so, right? (and not into ~/.cabal/bin/)
09:07:31 * hackagebot shake 0.2.9 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.2.9 (NeilMitchell)
09:08:10 <elliott> <jmcarthur> funny that we like to claim that haskell uses fewer lines of code than other languages and then turn around and try to come up with large haskell projects as evidence of how it scales
09:08:15 <elliott> jmcarthur: two different "we"s :)
09:08:19 <elliott> the former is an argument against the latter
09:08:43 <shergill> mekeor: try --dry-run?
09:08:55 <BMeph> More like two different and contradictory standards of "good code". :)
09:09:32 <mekeor> shergill: what does that do?
09:10:16 <shergill> mekeor: the help tells me: "--dry-run                      Do not install anything, only print what would be installed."
09:10:24 <elliott> mekeor: might be /usr/local
09:10:26 <elliott> check ~/.cabal/config
09:10:30 <elliott> you should generally use user installs.
09:10:32 <parcs`> what is the cpsed version of writer?
09:11:06 <elliott> parcs`: forall r. (w -> a -> r) -> r?
09:11:52 <mekeor> elliott: so, --global makes it install into /usr/local/ ?
09:12:01 <BMeph> "haskell uses fewer lines of code than other languages" -> Haskell lets you do meaningful things with fewer lines of code;
09:12:21 <jmcarthur> byorgey: i was trying to make a little joke about lines of code being considered a good or a bad thing by different people or in different contexts
09:12:38 <mekeor> elliott: and why should i use user installs?
09:12:54 <BMeph> "haskell ... scales" -> Haskell lets you manage large amounts of code.
09:12:58 <elliott> mekeor: like i said, check ~/.cabal/config.
09:12:58 <jmcarthur> but i gave up and just pointed it out. i did that badly, too :_
09:13:07 <elliott> and because you can add ~/.cabal/bin to your path, and it's better to run cabal with fewer privileges
09:13:20 * BMeph feels jmcarthur's pain...
09:13:35 <mekeor> elliott: hm, ok…
09:14:27 <parcs`> :t let tell w k = (k ()) . (++ w) in tell
09:14:27 <lambdabot> forall m b. (Monoid m) => m -> (() -> m -> b) -> m -> b
09:14:46 <parcs`> hmm, actually i think it's just (a -> w -> r) -> w -> r, just like reader and state
09:15:01 <parcs`> how elegant :p
09:15:25 <elliott> parcs`: why isn't it forall r. (w -> a -> r) -> r?
09:15:32 <parcs`> how would you define tell?
09:15:36 <elliott> maybe I don't know what you mean by "CPSed" :)
09:15:39 <elliott> that's certainly Codensity Writer
09:15:44 <elliott> tell w k = k w ()
09:15:55 <shergill> mekeor: ask yourself, are there other users for whom you want to make the installation via cabal available? if not, then you probably want to install locally
09:16:06 <parcs`> elliott: o i c
09:16:12 <parcs`> haha so what did i write
09:16:22 <elliott> parcs`: i think you implemented Writer in terms of CPS'd State
09:16:28 <elliott> or something
09:16:29 <parcs`> oh
09:16:34 <elliott> yeah
09:18:35 <parcs`> contstuff defines it as (a -> (r, w)) -> (r, w)
09:18:57 <parcs`> wait no that's OldWriter
09:19:33 <parcs`> wait no that's also Writer
09:19:41 <elliott> wait, what i said isn't Codensity Writer
09:19:44 <elliott> parcs`: *that's* Codensity Writer
09:20:01 <elliott> otoh, (forall r. (w -> a -> r) -> r) is trivially ~ (w, a)
09:20:08 <elliott> so mine is ok too, it just depends what you mean by CPSed
09:20:17 <elliott> parcs`: but yes, that one is probably better
09:20:36 <parcs`> Codensity is forall r. (a -> r) -> r?
09:20:57 <parcs`> well m r
09:22:07 <copumpkin> parcs`: what you wrote is the double negation monad, which is codensity id
09:22:57 <elliott> parcs`: forall r. (a -> m r) -> m r
09:23:14 <elliott> so for Writer, (a -> (w, r)) -> (w, r)
09:23:20 <elliott> *forall r.
09:23:29 <elliott> http://hackage.haskell.org/packages/archive/kan-extensions/2.1.2/doc/html/Control-Monad-Codensity.html
09:25:03 <parcs`> cool
09:26:24 <mekeor> is that by edwardk?
09:26:38 <parcs`> yeah
09:27:04 <andre27> ciao
09:28:26 <elliott> mekeor: it has "co" in it, and no documentation
09:28:30 <elliott> did you really have to ask?
09:30:07 <elliott> :p
09:30:33 <mekeor> :(
09:31:48 <byorgey> jmcarthur: hehe, fair enough =)
09:32:34 * hackagebot natural-numbers 0.1.1.0 - Natural numbers  http://hackage.haskell.org/package/natural-numbers-0.1.1.0 (WolfgangJeltsch)
09:33:10 <elliott> mekeor: just kidding :)
09:34:36 <mekeor> =]
09:34:46 <mekeor> is hackagebot live?
09:34:58 <tgeeky_> like, sentient?
09:35:14 <tgeeky_> mekeor: yes, he's pretty fast
09:36:22 <mekeor> cool.
09:38:16 <ChristianS> @faq can hackagebot and lambdabot become sentient beings?
09:38:17 <lambdabot> The answer is: Yes! Haskell can do that.
09:48:55 <sm> hackagebot polls every 5 minutes
09:51:05 <Fullmoon> Can I save and then restore a repl with CHC?
09:53:08 <koeien> i don't think so
09:53:32 <koeien> generally at that point i tend to make a file for my ramblings
09:53:40 <koeien> (and then just reload it as necessary)
09:55:31 <bbommarito> Is there a haskell function like Ruby's next_cons, which essentially takes a list, and an integer and iterates over that list, grabbing the first n (Where n is the int) elements, then drops the first element off the list, and continues on down the line?
09:56:43 <koeien> map (take n) . tails
09:56:49 <koeien> something like this?
09:57:07 <ClaudiusMaximus> and a takeWhile (not . null), probably
09:57:21 <koeien> yeah or takeWhile ((==n).length)
09:57:31 <koeien> i'm not familiar with Ruby or this function
09:58:02 <koeien> if you want tuples, there is ap zip tail
09:58:08 <koeien> > ap zip tail [1..10]
09:58:09 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
09:59:45 <ClaudiusMaximus> > transpose . take 5 . tails $ "hmm, perhaps this?"
09:59:46 <lambdabot>   ["hmm, ","mm, p","m, pe",", per"," perh","perha","erhap","rhaps","haps ","a...
10:01:08 <bbommarito> ClaudiusMaximus: That's what I need
10:02:09 <ClaudiusMaximus> bbommarito: well, the main issue is what happens at the end of the list, or for a short list
10:02:35 * hackagebot hstzaar 0.9.1 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.9.1 (PedroVasconcelos)
10:02:37 <bbommarito> Essentially, I want to take a string and turn it into a Hash of Trigrams
10:03:01 <watermind> just noticed ghc-mod was basically developed over the year of 2010
10:03:22 <watermind> 1st version march, latest november
10:03:40 <watermind> it's really nice, it is a shame if it's not developed further :S
10:04:00 <Fullmoon> koeien: OK. Thanks. I am coming from common lisp and was thinking of SAVEINITMEM
10:20:53 <reinoud> woww...  i just noticed 924 ppl. in the room
10:21:36 <mysticc> @hoogle sync
10:21:37 <lambdabot> GHC.Conc.Sync module GHC.Conc.Sync
10:21:37 <lambdabot> package sync
10:21:37 <lambdabot> package synchronous-channels
10:22:00 <reinoud> @hoogle ImplicitCAD
10:22:00 <lambdabot> No results found
10:24:36 <bitonic> watermind: maybe the author is happy with it. what features do you miss?
10:31:28 <mysticc> @hoogle Fandle -> Fd
10:31:29 <lambdabot> Warning: Unknown type Fandle
10:31:29 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:31:29 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
10:31:33 <mysticc> @hoogle Handle -> Fd
10:31:33 <lambdabot> System.Posix.IO handleToFd :: Handle -> IO Fd
10:31:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:31:33 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
10:37:54 <kmels> hello, i have a list xs :: [(a,a)] and a function g :: a -> a -> Int, how can I get the result of what _could_ be achieved by "map g xs" ?
10:38:10 <roconnor_> map (uncurry g) xs
10:38:28 <kmels> super, thanks
10:38:53 <mmos> In Data.Map there is a unionWith, something like unionWith :: (a->a->a) -> Map k a -> Map k a.  I need something like unionWith :: (a -> b -> c) -> Map k a -> Map k b -> Map k c  (when a key is in only one map it would just skip it)
10:43:43 <copumpkin> mmos: intersectionWith? :P
10:44:14 <shapr> wheee
10:44:26 <elliott> mmos: Map.map (\(InBoth z) -> z) . Map.filter isInBoth $ Map.unionWith (\(JustInLeft x) (JustInRight y) -> InBoth z) (Map.map JustInLeft m1) (M.map JustInRight m2)
10:44:31 <elliott> ugly, I know...
10:50:38 <mmos> elliot: thanks
10:50:45 <mmos> copunkim: thanks
10:50:53 <mmos> copumnkin: thanks
10:51:13 <mmos> copumkin: 3rd times the right spelling
10:51:34 <mmos> elliott: spell this right too
10:52:36 * hackagebot function-instances-algebra 0.1 - Instances of the Algebra.* classes for functions  http://hackage.haskell.org/package/function-instances-algebra-0.1 (TobiasBrandt)
10:54:30 <nyingen> "THANK YOU NYINGEN. BUT OUR FUNCTION IS IN ANOTHER MODULE!"
10:54:45 <nyingen> the opengl binding is a bit of a maze
10:55:13 <bitonic> nyingen: the haddock index helps
10:55:36 <monochrom> just import everything
10:56:19 <parcs`> use the raw bindings
10:57:01 <geekosaur> hayoo is useful for finding where something really lives.  http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:57:36 * hackagebot digestive-functors-snap 0.1.3.1 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.1.3.1 (JasperVanDerJeugt)
11:00:22 <nyingen> heh, "just import everything"
11:01:03 <nyingen> the 'import' declarations would be longer than the program :)
11:01:20 <nyingen> module Main where import Hackage ...
11:04:13 <Modius> Is there a good trick to drop the last N items off the end of a list without doing "reverse" twice?
11:04:38 <timthelion> elliott: did I just send you a message then imediately disconnect, or did I not send you a message?
11:04:54 <elliott> You didn't send me a message.
11:04:58 <c_wraith> Modius: yes.  \n xs -> zipWith const xs (drop n xs)
11:05:19 <timthelion> elliott: I have been reading about this functional reactive programming paradigm.  Yes, it is what I want, however it's fundumentally slighly less than optimally expressed by Conan Elliot.  You see, C. Elliot described Behaviors as functors of time, which are then changed by Events.   I would throw out time entirely(if I need to make an animation I can use an event called frame change.  And make Behaviors functors of State, which arrow from
11:05:27 <timthelion> elliott: there, that's what I thought I had written.
11:05:54 <elliott> Behaviours aren't "changed" by events.
11:06:17 <Modius> c_wraith:  Nice thanks
11:06:19 <timthelion> elliott: what is the relation between events and behaviors ?
11:06:25 <elliott> But anyway, "throw out time entirely" doesn't really make much sense. There does not have to be an explicit Time type in an FRP system.
11:06:37 <elliott> Throwing out time turns (Behavior a) into... uh, a.
11:06:52 <timthelion> elliott: in C. Elliot's original paper Time is explicit.
11:06:56 <elliott> Anyway, you got cut off after "which arrow from".
11:07:06 <elliott> Yes, FRP has evolved dramatically since the original paper.
11:07:12 <elliott> (btw, "Elliott")
11:07:40 <timthelion> which arrow from State1 to State2 to State_n.  My system is fundumentally simpler than his.
11:07:42 <yitz> elliott: timthelion doesn't really mean throw out time entirely, rather replace time by something else, like frame change.
11:08:03 <elliott> yitz: sure. but Event includes Time too!
11:08:24 <elliott> if you replace [(Time,a)] with [a], then there's no way to relate occurrences of separate events together, unless you just use a discrete timestep
11:08:38 <elliott> in which case, you still have time, it's just not continuous any more
11:08:40 <timthelion> elliott: the thing is, that the act of having Behaviors that in themselves relate not only to events but time as well was fundumetally missguided :)
11:08:46 <yitz> elliott: i agree with timthelion. frp should not be done with time, rather with any poset.
11:08:56 <elliott> timthelion: that doesn't really make any sense. behaviors don't "relate" to events
11:09:18 <timthelion> elliott: ?
11:09:27 <mysticc> Warning: newtype `CInt' is used in an FFI declaration, but its constructor is not in scope. ?? How to correct the warning
11:09:33 <elliott> yitz: I don't disagree with any statement that FRP can be done best without a notion of time, but I don't think timthelion's statements are meaningful enough to count as that
11:09:43 <elliott> *with every
11:10:40 <yitz> elliott: ok. i do think that's what timthelion means though. e.g. [(Frame,a)] where Frame has an ordering.
11:11:35 <mysticc> even if I have imported CInt from from Foreign.C.Types
11:11:42 <elliott> yitz: ok, so let's say Behavior is now Frame -> a
11:11:54 <mysticc> @hoogle Handle -> Fd
11:11:54 <lambdabot> System.Posix.IO handleToFd :: Handle -> IO Fd
11:11:55 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:11:55 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:11:55 <elliott> yitz: timthelion says that "having Behaviors that in themselves relate not only to events but time as well was fundamentally misguided"
11:12:09 <elliott> yitz: how does this new Behavior relate any less to events and now frames?
11:12:23 <elliott> of course, I don't really have any idea what "relating to events" means, which is why I'm confused :)
11:12:26 <timthelion> elliott: that's not what I meant.  I don't want to replace f t = a with f = a, I want to replace f t = a with f a0 = a1 :)
11:12:48 <elliott> timthelion: ok, so you want a step function?
11:13:06 <elliott> timthelion: how can that (a -> a) react to anything?
11:13:14 <timthelion> elliott: yes. The entire thing can be done entirely with step functions.  No need for behaviors.
11:13:16 <elliott> it can't know if a button's been pressed, because you deny it knowledge of the current time
11:13:45 <timthelion> elliott: well because we go to the next a in the sequence every time we do something, therefore, reactivity :)
11:14:12 <elliott> timthelion: how do you define this behavior: an integer, initially 0, incrementing by one each time the event e happens
11:14:15 <elliott> (say e = some button is clicked)
11:14:15 <timthelion> elliott: but time is implicit in the fact that events are modifying behaviors :)
11:14:28 <elliott> you can't, because the only input you get is the previous value
11:14:31 <timthelion> elliott: sure, could be an integer.
11:14:32 <elliott> there's no way to tell whether a button was clicked
11:15:14 <timthelion> if e > 0 then the button was clicked.
11:15:31 <elliott> what? e isn't an integer
11:15:32 <timthelion> how would you figure it out based on time?
11:15:44 <timthelion> oh, I meant the behavior, sorry
11:16:08 <timthelion> Behavior Int a > 0 when the button has been clicked
11:16:11 <elliott> here it is with Behavior a = Time -> a and Event a = [(Time,a)]: \t -> sum [1 | (t',()) <- e, t' < t]
11:16:17 <elliott> assuming e :: Event ()
11:16:19 <timthelion> but how would you even figure that out as a relation to time.
11:16:20 <timthelion> ?
11:16:25 <elliott> i just defined it
11:17:24 <timthelion> elliott: moment while I read that...
11:17:36 * hackagebot derive 2.5.6 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.6 (NeilMitchell)
11:18:07 <elliott> i.e. \t -> sum (filter (\(t',_) -> t' < t) e)
11:18:19 <elliott> i.e. "the value of the behavior at time t is the number of occurrences of e before t"
11:18:23 <elliott> declarative
11:19:49 <Mathnerd314> @undo [1 | (t',()) <- e, t' < t]
11:19:49 <lambdabot> concatMap (\ a -> case a of { (t', ()) -> if t' < t then [1] else []; _ -> []}) e
11:19:54 <timthelion> elliott: "the value of the behavior is the number of occurences of e which we have experienced up to this point" is also quite declarative.
11:20:30 <elliott> how do you express that with only (a -> a)
11:20:36 <elliott> what is your definition of Event
11:21:17 <elliott> (anyway, the notion of "a current time" is anathema in a "declarative" context, but whatever)
11:22:22 <timthelion> elliott: perhaps I cannot express what I want in terms of FRP, despite the concepts being almost identical.  Think of a lazy list values and an imperitive function that takes one more value from that list each time an event occures.  The last value received is the value.
11:23:46 <elliott> ok, so you essentially have a function (Nat -> a) and you "tie" this to an event at the time of its creation
11:24:07 <timthelion> elliott: perhaps.
11:24:08 <elliott> in other words, all you have to construct behaviors is... well, something less powerful than accumE
11:24:20 <timthelion> elliott: perhaps.
11:24:31 <elliott> I really have no idea what you mean by "relating to events" though, this is no less relating to events and time than frp
11:25:02 <timthelion> elliott: except we have no variable time.  It doesn't matter WHEN, but in which order!
11:26:30 <elliott> timthelion: look at arrowised FRP. it has no time
11:26:51 <elliott> really you should probably just read all the main frp papers before trying to improve on it :p
11:27:10 <timthelion> elliott: I'm working on that :)
11:27:58 <timthelion> elliott: but I always try to improve on things as I read.  If I didn't I wouldn't understand.  I only understand something, by knowing how it works, and by knowing how something works, I necessarly must be able to see the flaws.
11:29:08 <elliott> well, no offence but i don't think you know how it works yet
11:30:13 <timthelion> elliott: That's why I'm on here trying to figure out where I've gone wrong :)
11:30:22 <elliott> well, i'm not sure where :p
11:32:06 <timthelion> elliott: I did understand C. Elliott's paper.  I don't think I was wrong at all there.  I only think, that it was written in 97 and that the concepts can be expressed much much better...  Unfortunatly, the modern stuff, still uses his old vocabulary, which was missguided...
11:33:12 <scooty-puff> is it a bad practice to define utility'ish type classes that are kept internal to a module (internal in that all classes, instances, and constraints involving them, are kept in the module)
11:33:53 <byorgey> scooty-puff: no, why would it be?
11:34:17 <timthelion> scooty-puff: you should do so, untill someone else reads your code and tells you(oh, that has been implemented more robustly elsewhere, go use this API instead :))
11:34:28 <scooty-puff> k
11:34:44 <scooty-puff> just wondering, was for some reason making me feel suspicious of a code smell or something like that
11:39:27 <jfischoff> what are the potential problems of undecidable instances?
11:39:50 <elliott> the compiler can fail to terminate (= give up after N steps and output an error)
11:39:56 <elliott> they're not that risky
11:40:28 <jfischoff> cool, is it still a good practice to not use them?
11:40:57 <elliott> well, if you can avoid it :)
11:41:03 <Saizan> the other problem is that you have to check fundeps yourself
11:41:33 <jfischoff> ah, so if you were to make an overlapping instance it mean divergence?
11:41:39 <jfischoff> for the compiler
11:41:46 <elliott> well, GHC never diverges.
11:41:50 <elliott> just gives up after a while
11:41:52 <jfischoff> right
11:42:02 <elliott> (and you can set how long it'll wait (in steps) before giving up :))
11:48:05 <mekeor> can a haskell program have multiple threads without being compiled with "-threaded" ?
11:48:23 <ben> Haskell threads, yeah
11:48:34 <mekeor> ben: "haskell threads" ?
11:48:46 <ben> The thing you get when you say forkIO
11:49:03 <mekeor> ah
11:49:50 <ben> You need to compile with -threaded if you want the runtime to run all the haskell threads on multiple OS threads though, if I understand it correctly.
11:50:21 <bitonic> ben: no. mekeor: -threaded actually handles the haskell runtime threads with multiple OS threads.
11:50:55 <bitonic> otherwise, one OS thread will be used. So you can still spawn haskell threads (the one you spawn with 'fork') but they will all "live" in one OS thread.
11:50:57 <mekeor> what the hell?…
11:51:27 <mekeor> what's an OS thread and what's a haskell thread? ?? ???
11:51:48 <bitonic> mekeor: an OS thread is a thread managed by the kernel.
11:51:50 <Lemmih> mekeor: http://en.wikipedia.org/wiki/Green_threads
11:51:52 <ben> no?
11:52:12 <nart> mekeor: http://i.stack.imgur.com/f57Hm.png
11:52:50 <mekeor> nart: ah, okay. got it.
11:52:59 <mekeor> just kidding… still… i don't understand…
11:53:05 <mekeor> Lemmih: green?!?
11:53:11 <elliott> mekeor: the haskell runtime starts e.g. 2 operating system threads
11:53:20 <elliott> mekeor: it schedules its own, userspace threads inside that
11:53:26 <elliott> (one for each forkIO you do)
11:53:35 <monochrom> without -threaded, you can still forkIO, they just all share the same OS thread. also, every FFI call stops the world.
11:54:02 <ben> Isn't that what I said?
11:54:08 <elliott> mekeor: this may help: http://stackoverflow.com/questions/958449/what-is-a-spark-in-haskell
11:54:12 <monochrom> I think so!
11:54:12 <elliott> ben: dunno, i didn't read any previous responses :P
11:54:14 <mekeor> so, actually, my concrete question is whether FastCGI would work without -threaded.
11:54:33 <mekeor> (because -threaded doesn't work on ARM due to an sucking bug…)
11:54:40 <elliott> the answer to "will X work without -threaded" is usually "yes", but you can use -threaded without actually starting multiple threads
11:54:45 <elliott> and you should for networking stuff
11:54:48 <elliott> because you'll get the fancy IO manager
11:54:52 <elliott> oh
11:54:55 <bitonic> ben: sorry, I had understood that you were saying that each haskell thread will get a different OS thread
11:54:59 <elliott> ok, don't use -threaded and you should be fine.
11:55:45 <mekeor> monochrom: nice to see you again, btw. we missed you, #haskell missed you!
11:56:08 <monochrom> really?!
11:56:20 <mekeor> elliott: do you agree (with me) ?
11:56:33 <mekeor> @faq do you agree, #haskell?
11:56:33 <lambdabot> The answer is: Yes! Haskell can do that.
11:56:47 <monochrom> I'm wondering whether FastCGI calls FFI
11:56:49 <elliott> monochrom's terrible. we missed him tons!
11:57:06 <elliott> yes, fastcgi uses ffi :)
11:57:19 <monochrom> then when it calls FFI, it stops the world
11:57:23 <elliott> i guess the fcgx_accept call might be problematic, yes
11:57:40 <mekeor> monochrom: that is, FastCGI doesnt work without -threaded ??
11:57:42 <elliott> mekeor: are you *sure* you need to use ARM? :p
11:57:43 <mekeor> ;(
11:57:53 <bitonic> mekeor: I told you ARM & Haskell would be messy
11:57:53 <mekeor> elliott: my server is ARM…
11:58:00 <mekeor> bitonic: i remember.
11:58:14 <elliott> mekeor: run "qemu-i386 ./myhsprog" on the server :p
11:58:16 <reinoud> whay about my hint about using llvm on arm?
11:58:17 <bitonic> you know, I hate to say "I told you", but I did :D
11:58:19 <monochrom> I don't know what is "works". I'm stating properties. maybe you don't mind stop-the-world.
11:58:22 <mekeor> elliott: lol :D
11:58:28 <elliott> mekeor: i'm only half-kidding!
11:58:42 <mekeor> :)
11:59:00 <dzhus> I have lots of 3-vectors implemented as Vector !Double !Double !Double in my program, would switching to vector library with unboxed vectors make things faster?
11:59:09 <elliott> dzhus: no
11:59:12 <mekeor> monochrom: what does "stop-the-world" mean?
11:59:14 <elliott> unless you're doing really weird thing
11:59:14 <elliott> s
11:59:15 <dzhus> current module for reference: http://hpaste.org/65953
11:59:17 <elliott> I guess
11:59:29 <elliott> dzhus: are you compiling with -funbox-strict-fields?
11:59:30 <bitonic> mekeor: that the FFI call cannot be interrupted
11:59:32 <monochrom> when one haskell thread calls FFI, all haskell threads wait
11:59:37 <elliott> if so, the answer is more or less definitely no
11:59:46 <bitonic> "more or less definitely".
11:59:48 <bitonic> elliott: :)
11:59:55 <mekeor> bitonic: so what?
12:00:07 <mekeor> ah
12:00:08 <elliott> dzhus: p.s., that Num instance is really broken, define the other methods :(
12:00:27 <mekeor> monochrom: ah. omg! then FastCGI wouldn't make sense anymore!
12:00:29 <elliott> bitonic: what that means is, "definitely, but if I turn out to be wrong, nobody can accuse me of incompetence"
12:00:49 <mekeor> monochrom: then it's more or less the same as (usual) CGI, isn't it?
12:01:16 <elliott> mekeor: if i understand the fastcgi lib's code then it's not even an option for you
12:01:24 <elliott> because it will be calling fcgx_accept in a loop
12:01:32 <elliott> which means your code will pretty much never run
12:01:35 <monochrom> no, usual CGI spawns a million processes while FastCGI may just spawn one
12:01:43 <elliott> because it'll be blocked on FFI all the time
12:01:57 <elliott> mekeor: why not just run a haskell web server like WAI or snap?
12:01:59 <nart> elliott: why dzhus's Num instance is broken ?
12:02:02 <elliott> and proxy it from your main web server
12:02:04 <mekeor> elliott: yea! that's what seemed to happen in tests!!!!
12:02:08 <elliott> nart: it doesn't define fromInteger etc.
12:02:11 <elliott> mekeor: rather than using fastcgi?
12:02:23 <elliott> they're "production-ready"
12:02:24 <nart> elliot: ah ok ty
12:02:38 * hackagebot reactive-banana 0.5.0.0 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.5.0.0 (HeinrichApfelmus)
12:02:40 <mekeor> elliott: because………………………… -- erm… erm… er.
12:02:57 <elliott> mekeor: ...and they won't use the FFI at all, so they should work fine without -threaded
12:03:02 <elliott> (albeit less performantly)
12:03:08 <elliott> (but it's ARM, so you're not getting any of that anyway)
12:03:35 <mekeor> "elliott" reminds me of "idiot"…
12:03:50 <mekeor> sry for that.
12:04:17 <bitonic> oh oh major reactive-banana release!
12:04:20 <mekeor> but it's all the time… when i read your name i always think "idiot"… omg… sorry! :/
12:04:30 <mekeor> bitonic: O_O
12:04:32 <bitonic> he changed the interface
12:04:40 <elliott> finally Discrete is dead!
12:04:43 <mekeor> apfelmus is great
12:04:45 <elliott> you can all thank me, the idiot :P
12:04:47 <aristid> preflex: seen apfelmus
12:04:47 <preflex>  apfelmus was last seen on #haskell 263 days, 23 hours, 57 minutes and 20 seconds ago, saying: byorgey: Anyway. Let me know if you're taking the homebrew route, I'll be happy to contribute. :)
12:04:53 <mekeor> elliott: eheh
12:04:55 <aristid> too bad he isn't here :D
12:05:11 <bitonic> coolio, installing
12:05:13 * elliott dances on Discrete's grave
12:05:16 <parcs`> preflex: seen apfelmus_
12:05:17 <preflex>  apfelmus_ was last seen on #haskell 285 days, 3 hours, 14 minutes and 34 seconds ago, saying: Thanks for your help!
12:05:30 <elliott> preflex: xseen apfelmus
12:05:30 <preflex>  apfelmus was last seen on freenode/#haskell 263 days, 23 hours, 58 minutes and 4 seconds ago, saying: byorgey: Anyway. Let me know if you're taking the homebrew route, I'll be happy to contribute. :)
12:05:36 <mekeor> anyway. thank you, elliott and bitonic and monochrom. i'll consider snap.
12:05:48 <elliott> mekeor: by snap i just meant the snap web server
12:05:55 <elliott> but of course if you are using snap-the-framework that works too
12:05:56 <bitonic> mekeor: I'd probably consider something else than haskell for a small ARM thingie.
12:06:03 <Franciman> preflex: xseen Franciman
12:06:03 <preflex>  Franciman was last seen on freenode/#haskell 1 day, 7 hours, 11 minutes and 50 seconds ago, saying: I'm too C-ized
12:06:03 <elliott> or if you are using yesod then WAI is the obvious choice
12:06:16 <hiptobecubic> making a quicksort that is actually usable in the real world turns out to be far from trivial
12:06:20 <elliott> i don't know if the happstack people have a preferred native-haskell web server... but i bet there's a packages to plug it into snap and wai
12:06:20 <mekeor> elliott: what's yesod actually? is it like snap?
12:06:22 <maltem> Good evening. What's my starting point if `cabal sdist` is broken? (cabal: dist/src/sdist.-16044/zlib-enum-0.2.2: does not exist)
12:06:23 <elliott> s/a packages/packages/
12:06:33 <mekeor> elliott: i know. i once tried snap.
12:06:44 <elliott> mekeor: snap is a web server and on top of that a web framework, yesod is a web framework that uses WAI (by the same developers) as its web server
12:06:51 <elliott> and is also the origin of conduits etc.
12:07:03 <mekeor> conduits?
12:07:07 <mekeor> >.>
12:07:12 <hiptobecubic> the old   qsort (x:xs) == qsort (filter...) ++ x : qsort (filter...)     , quite predictably, isn't so hot for large lists
12:07:22 <elliott> mekeor: it's like you don't even read /r/haskell!
12:07:28 <elliott> http://hackage.haskell.org/package/conduit, like iteratees/enumerators
12:07:29 * mekeor thinks snap is cooler than yesod+wai…
12:07:38 * hackagebot reactive-banana-wx 0.5.0.0 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.5.0.0 (HeinrichApfelmus)
12:07:40 <mekeor> elliott: that's true! oO
12:07:48 <elliott> to be clear: again, I wasn't recommending snap-the-framework, although if you want to use it that's of course fine
12:08:00 * mekeor is not (very?) active on reddit
12:08:04 <elliott> I was just naming the two production-ready native-Haskell web servers I know, which are WAI and Snap-the-server
12:08:06 <elliott> WAI is faster IIRC
12:08:08 <bitonic> hiptobecubic: doing quicksort on an haskell list doesn't make much sense. quicksort main advantage is that you can do it in place
12:08:22 <mekeor> elliott: yep. i like snap.
12:08:45 <bitonic> elliott: WAI is just an interface. warp is fast
12:08:45 <reinoud> what is the easiest way to sort?
12:08:46 <hiptobecubic> bitonic, sure. but it's always the first example someone reaches for to demonstrate how nice it is to program lazily in haskell
12:09:01 <jmcarthur> reinoud: Data.List.sort
12:09:27 <reinoud> @hoogle Data.List.sort
12:09:29 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
12:09:29 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
12:09:29 <lambdabot> package sorty
12:09:33 <mekeor> > sort [1,4,2,3]
12:09:33 <bitonic> hiptobecubic: yeah but it's simply a cute example, nothing more
12:09:34 <lambdabot>   [1,2,3,4]
12:09:36 <hiptobecubic> bitonic, there is mergesort, which is what ghc uses now by default i think?, but that isn't in place either is it?
12:09:43 <elliott> bitonic: err, I meant warp
12:09:47 <elliott> sorry mekeor
12:10:02 <mekeor> what?
12:10:14 <mekeor> warp?
12:10:14 <reinoud> > sort [(1,2,3), (4,3,1), (1,3,5)]
12:10:15 <lambdabot>   [(1,2,3),(1,3,5),(4,3,1)]
12:10:16 <jmcarthur> no purely functional sort is in-place
12:10:19 <bitonic> hiptobecubic: yes. doing an in-place sort with [] is impossible.
12:10:21 <reinoud> neat!
12:10:56 <bitonic> hiptobecubic: you can implement quicksort with a STArray/vector/whatever as you would do in any imperative language if you want
12:11:07 <elliott> hiptobecubic: it isn't hot for short lists either
12:11:11 <dzhus> also, from performance point of view, is it good to rely on lots of comparisons with infinityP defined as 1/0? I've read it prevents me from using -ffast-math
12:11:17 <elliott> it's the worst sort you can implement in two lines of haskell :P
12:11:45 * reinoud looking fort a hs-plugins that work on ghc 7.4.1
12:11:47 <jmcarthur> well, i suppose a clever compiler or type system could make sure that the collection is used linearly and then do some in-place sort that could be considered pure, but that's pushing it, i think
12:12:45 <elliott> jmcarthur: linear/uniqueness types should be enough to do it, no?
12:12:52 <elliott> but you need to change the language :)
12:12:57 <bitonic> damn. again.
12:13:05 <reinoud> > uniq . sort [(1,2,3), (4,3,1), (1,3,5)]
12:13:06 <lambdabot>   Not in scope: `uniq'
12:13:14 <jmcarthur> elliott: for the price of giving up free undo, yes
12:13:16 <reinoud> > unique . sort [(1,2,3), (4,3,1), (1,3,5)]
12:13:17 <lambdabot>   Not in scope: `unique'
12:13:20 <reinoud> hmmm
12:13:21 <Cale> nub
12:13:24 <Cale> also $
12:13:28 <danharaj> also ponies
12:13:34 <Cale> or map head . group
12:13:48 <Cale> > group . sort $ "mississauga"
12:13:50 <lambdabot>   ["aa","g","ii","m","ssss","u"]
12:13:55 <elliott> jmcarthur: just have the sort record how it moves things and also return a thunk that constructs a new array by shuffling the sorted one back :P
12:13:56 <Cale> > map head . group . sort $ "mississauga"
12:13:58 <lambdabot>   "agimsu"
12:14:06 <Cale> > nub . sort $ "mississauga"
12:14:07 <reinoud> map head . group  [(1,2,3), (4,3,1), (1,3,5)]
12:14:08 <lambdabot>   "agimsu"
12:14:10 <jmcarthur> elliott: like i said. you've lost *free* undo
12:14:13 <Cale> > nub $ "mississauga"
12:14:14 <lambdabot>   "misaug"
12:14:18 <reinoud> > map head . group  [(1,2,3), (4,3,1), (1,3,5)]
12:14:19 <lambdabot>   Couldn't match expected type `[a]'
12:14:19 <lambdabot>         against inferred type `(t, t1, t...
12:14:36 <elliott> jmcarthur: well yeah, in-place sorting with free undo would be as nice as a perpetual motion machine :P
12:14:44 <Cale> You either need to put parens around the composition, or put a $ to apply the composed function to its argument
12:14:51 <reinoud> > nub . sort [(1,2,3), (4,3,1), (1,3,5)]
12:14:52 <lambdabot>   Couldn't match expected type `[a]'
12:14:52 <lambdabot>         against inferred type `(t, t1, t...
12:15:03 <Cale> reinoud: that reads as  nub . (sort [...])
12:15:19 <Cale> reinoud: but the result of sorting the list isn't a function
12:15:30 <jmcarthur> elliott: i was trying to imply that it it's just compiler cleverness and not a type system change then you could get in-place sort when it's used linearly or a non-in-place sort when it's not used linearly
12:15:35 <jmcarthur> *if it's just
12:15:42 <reinoud> @hoogle nub
12:15:43 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
12:15:43 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
12:16:06 <jmcarthur> elliott: so it would still have somewhat free undo, depending on how you look at it
12:16:08 <reinoud> > nub $ sort [(1,2,3), (4,3,1), (1,3,5)]
12:16:09 <lambdabot>   [(1,2,3),(1,3,5),(4,3,1)]
12:16:25 <Cale> > nub . sort $ [(1,2,3), (4,3,1), (1,3,5)] -- or even this, if you like :)
12:16:26 <lambdabot>   [(1,2,3),(1,3,5),(4,3,1)]
12:16:28 <reinoud> > nub $ sort [(1,2,3), (4,3,1), (1,3,5), (1,2,3)]
12:16:29 <lambdabot>   [(1,2,3),(1,3,5),(4,3,1)]
12:16:49 <reinoud> is there a performance difference?
12:16:50 <Cale> map head . group will be a little faster
12:16:54 <elliott> jmcarthur: well, you get to choose expensive sort, free undo, or free(!) sort, expensive undo
12:16:56 <jmcarthur> but that would either be a very special case optimization or it would have to be a *very* clever compiler
12:17:07 <reinoud> > map head . group [(1,2,3), (4,3,1), (1,3,5), (1,2,3)]
12:17:08 <Cale> actually, it'll be asymptotically faster ;)
12:17:08 <lambdabot>   Couldn't match expected type `[a]'
12:17:08 <lambdabot>         against inferred type `(t, t1, t...
12:17:15 <elliott> jmcarthur: but, I mean, you could also define a notInPlaceSort that isn't in place and lets you keep the original around in this hypothetical language, but that's less manual :)
12:17:20 <Cale> > map head . group . sort $ [(1,2,3), (4,3,1), (1,3,5), (1,2,3)]
12:17:22 <lambdabot>   [(1,2,3),(1,3,5),(4,3,1)]
12:17:33 <reinoud> argh
12:17:35 <Cale> > sort $ "mississippi"
12:17:36 <lambdabot>   "iiiimppssss"
12:17:42 <Cale> > group . sort $ "mississippi"
12:17:44 <lambdabot>   ["iiii","m","pp","ssss"]
12:17:48 <Cale> > map head . group . sort $ "mississippi"
12:17:49 <reinoud> i have to get used to $, coming from a Miranda background
12:17:50 <lambdabot>   "imps"
12:18:09 <Cale> Did composition bind more tightly than function application in Miranda/
12:18:10 <Cale> ?
12:18:26 <monochrom> you don't have to use $ you know?
12:18:26 <reinoud> AFAIR, but it has been quite a while
12:18:48 <jmcarthur> elliott: i see the tradeoff as  cheap sort + expensive undo  vs.  slightly-less cheap sort + free undo
12:18:48 <lambda_zero_cool> hey all-anyone think they might be able to answer a question about HOpenGL and the IORef data type?
12:19:03 <jmcarthur> lambda_zero_cool: depends on the question
12:19:48 <monochrom> $ is the root of much evil
12:19:51 <jmcarthur> is there a lambda_acid_burn to go along with lambda_zero_cool?
12:20:14 <lambda_zero_cool> xD i wish.  one moment on the question - i pulled this up in the same terminal my editor is in xD
12:20:42 <monochrom> just last night a student of pointfree failed to see why "g cs = concat $ map f cs" is not equivalent to "g = concat $ map f"
12:21:21 <monochrom> just get rid of $ and it's plain as day: "g cs = concat (map f cs)" is clearly not "g = concat (map f)"
12:21:28 <lambda_zero_cool> so in my HelloWorld file, containing main, i have the following line: angle <- new IORef 0.0
12:21:42 <Mathnerd314> monochrom: which is why (.) is the one true combinator
12:21:50 <lambda_zero_cool> in another file i have the following: angle $=! a + 0.1
12:22:03 <hiptobecubic> monochrom, i make that mistake sometimes. ($) just feels like "do everything that could possibly come after this, first
12:22:09 <issactrotts> I got stuck while trying to reproduce the results in this article: http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/. Getting this error: /usr/local/Cellar/ghc/7.0.4/lib/ghc-7.0.4/include/stg/Regs.h:177:0:
12:22:11 <issactrotts>      sorry, unimplemented: LLVM cannot handle register variable ‘R1’, report a bug
12:22:19 <lambda_zero_cool> i receive the following type error: No instance for (Num (IO ())) arising from a use of `+'
12:22:22 <Mathnerd314> :t \cs -> concat . map f . return cs
12:22:23 <lambdabot> forall a a1 (f :: * -> *). (Show a1, SimpleReflect.FromExpr [a], Monad f, Functor f) => [a1] -> f [a]
12:22:42 <Mathnerd314> :t \f cs -> concat . map f . return cs
12:22:43 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> [a]) -> [a1] -> f [a]
12:22:46 <issactrotts> Does it mean I should report a bug against GHC or LLVM?
12:22:53 <jmcarthur> lambda_zero_cool: it's probably just defaulting working against you
12:23:01 <DMcGill> @hoogle ($=!)
12:23:02 <lambdabot> No results found
12:23:23 <jmcarthur> lambda_zero_cool: add a type signature for angle in your main or somewhere relevant?
12:23:25 <reinoud> OK, this sucks, no module hs-plugins
12:23:38 <reinoud> for ghc 7.4.1
12:23:39 <jmcarthur> oh i see a number there now
12:23:59 <jmcarthur> lambda_zero_cool: is it reasonable to put some code on hpaste.org?
12:24:49 <lambda_zero_cool> @jmcarthur - my message isn't working
12:24:50 <lambdabot> Unknown command, try @list
12:25:15 <lambda_zero_cool> @jmcarthur - /msg, I mean.  do you want to paste or do you want me to paste?  I can also link you to the original tutorial.
12:25:15 <lambdabot> Unknown command, try @list
12:25:30 <jmcarthur> lambda_zero_cool: oh it's part of a tutorial... link me to that please
12:25:39 <jmcarthur> lambda_zero_cool: also, don't use @. it makes lambdabot unhappy :)
12:26:24 <lambda_zero_cool> jmcarthur: http://www.haskell.org/haskellwiki/OpenGLTutorial2
12:26:29 <jmcarthur> lambda_zero_cool: seriously, just keep it in the channel. it's relevant :)
12:27:23 <Mathnerd314> jmcarthur: why couldn't lambdabot just use ':' instead of '@'?
12:27:32 <jmcarthur> lambda_zero_cool: yeah, i still suspect defaulting. try adding a type signature over the display function
12:27:40 * hackagebot cabal2nix 1.30 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.30 (PeterSimons)
12:27:44 <jmcarthur> Mathnerd314: @ is pretty common for bots
12:28:16 <monochrom> (why couldn't twitter use : instead of @? :) )
12:28:20 <jmcarthur> lambda_zero_cool: oh, or rather, the idle function
12:28:27 <Mathnerd314> jmcarthur: but lambdabot has already taken over :
12:28:31 <lambda_zero_cool> jmcarthur - the error actually occurs in the "idle" function in the Display.hs file.  what type signature would you recommend?
12:28:47 <lambda_zero_cool> jmcarthur: thanks for help, btw.  <-- total noob :D
12:28:50 <jmcarthur> lambda_zero_cool: what type should angle have? GLfloat or something?
12:28:57 <basri> hi
12:29:12 <monochrom> lambdabot does not entirely take over : . it only does :t. in fact...
12:29:16 <monochrom> :type id
12:29:24 <jmcarthur> i'm thinking GLfloat, so the type of idle would look like this, i think:    idle :: IORef GLfloat -> IO ()
12:29:30 <monochrom> even that is rejected
12:30:32 <monochrom> the :t thing is a very odd-man-out special case that a few delusional people requested
12:30:32 <lambda_zero_cool> jmcarthur: thanks for the suggestion!  unfortunately, i receive the same type errors as before.
12:30:53 <jmcarthur> oh i think i misread the type error
12:31:02 <jmcarthur> let me look in less of a hurry
12:31:38 <jmcarthur> lambda_zero_cool: it would be nice if you could paste your code at hpaste.org, i think
12:31:38 <lambda_zero_cool> jmcarthur: i can paste the entire error message as well
12:31:43 <monochrom> hrm, the tutorial has a type error?
12:31:50 <jmcarthur> lambda_zero_cool: both the code and the error would be nice
12:32:20 <jmcarthur> monochrom: i haven't found it yet, if it does
12:32:33 <jmcarthur> but i only just now realized what the actual error was
12:32:57 <lambda_zero_cool> jmcarthur - let me try one more thing, if it does not work i'll paste the code and error
12:33:08 <jmcarthur> i had previously misread Num (IO ()) as Num ()
12:33:11 <jmcarthur> okay
12:34:15 <monochrom> Num (IO ()) has the prospect of "readIORef x + readIORef y"
12:34:26 <monochrom> err, no, but close
12:34:34 <jmcarthur> i'm pretty sure this tutorial's code is alright. i remember a completely different issue coming up from this particular line of code which is now fixed
12:34:43 <jmcarthur> (chain of thunks!)
12:35:34 <monochrom> death by chocolate and huge thunk
12:35:41 <hpaste> lambda_zero_cool pasted “OpenGL Tutorial Type Error” at http://hpaste.org/65954
12:36:18 <lambda_zero_cool> jmcarthur: hpasted ^^
12:37:33 <jmcarthur> lambda_zero_cool: i don't see how this could compile:      angle <- newIORef (0.0:GLfloat)
12:37:49 <jmcarthur> but that's a separate file, so i can see why it wouldn't come up
12:37:51 <lambda_zero_cool> jmcarthur: it used to be just 0.0, the 0.0:GLfloat was the last thing i tried
12:37:54 <ClaudiusMaximus> lambda_zero_cool: detab your file is my guess (tab stops are 8col in haskell, which is uncommon in editors)
12:38:31 <jmcarthur> lambda_zero_cool: a type annotation requires two colons
12:39:10 <jmcarthur> the hpaste doesn't seem to have tabs, to me
12:39:35 <lambda_zero_cool> jmcarthur: so i think i may know a problem -- when i'm trying to compile, it's going through Display first
12:39:42 <lambda_zero_cool> jmcarthur: because HelloWorld.hs calls on display
12:39:53 <jmcarthur> yeah
12:39:55 <ClaudiusMaximus> oh!  ghci tells me $= is infixr 2  but  $=!  has no fixity declaration
12:39:58 <lambda_zero_cool> jmcarthur: I just cleaned and started over -- and it hits display first, which is why any errors in HelloWorld wouldn't be noticed.
12:40:30 <jmcarthur> lambda_zero_cool: try adding parens around the right side of $=!
12:40:40 <jmcarthur> i think ClaudiusMaximus and i discovered the same thing at the same time :)
12:40:56 <jmcarthur> lambda_zero_cool: angle $=! (a + 0.1)
12:41:02 <ClaudiusMaximus> lambda_zero_cool: congrats, you found a library bug :)
12:41:20 <jmcarthur> and a tutorial bug, from a different point of view
12:41:24 <jmcarthur> it obviously wasn't tested
12:41:31 <jmcarthur> i remember when that line was changed ^_^
12:41:45 <jmcarthur> a disturbingly long time ago
12:41:50 <lambda_zero_cool> jmcarthur: thank you very much :D
12:42:17 <lambda_zero_cool> jmcarthur - to deliver karma, do i say "jmcarthur++" ?
12:42:34 <jmcarthur> heh, yes
12:42:37 <lambda_zero_cool> jmcarthur++
12:42:38 <jmcarthur> @karma jmcarthur
12:42:39 <lambdabot> You have a karma of 3
12:42:48 <elliott> <issactrotts> Does it mean I should report a bug against GHC or LLVM?
12:42:51 <elliott> issactrotts: probably ghc
12:42:55 <jmcarthur> ... i thought i had much more than that. oh well
12:42:57 <lambda_zero_cool> ClaudiusMaximums - it's not a library, just the OpenGL tutorial on Haskell Wiki
12:43:19 <jmcarthur> lambda_zero_cool: StateVar is the library
12:43:26 <jmcarthur> where ($=!) comes from
12:43:43 <jmcarthur> lambda_zero_cool: it's a bug that you have to use parens there
12:43:49 <lambda_zero_cool> jmcartur - one last question.  you see where angle gets reassigned - it uses the "$=!" operator.  i switched this to "$=" and was able to compile -- what is the difference between "$=!" and "$=" ?
12:43:56 <lambda_zero_cool> oh, really? haha, wow! perhaps i did find a bug :)
12:44:04 <mekeor> why is rubyOnRails so much faster than snap?
12:44:08 <issactrotts> elliott: Thanks
12:44:23 <elliott> mekeor: are you serious
12:44:27 <bitonic> mekeor: aha.
12:44:45 <mekeor> mekeor: fuck. i mixed up. the higher the numbers the better it is…
12:44:51 <mekeor> http://snapframework.com/blog/2010/11/17/snap-0.3-benchmarks
12:44:53 <mekeor> heeh :D
12:44:58 <bitonic> RoR was engineerd for speed and stability from day 1. that's why Basecamp restarted 400 times a day.
12:45:15 <elliott> mekeor: that's a very old post too
12:45:47 <jmcarthur> lambda_zero_cool: well, aside from the incorrect difference in precedence, the difference is that $=! forces its second argument, but $= does not
12:46:32 <jmcarthur> lambda_zero_cool: the correct one to use here is $=!. that's because the idle callback may be called many times between the display calls, so you could end up with a space leak if you don't force it to be evaluated each time you update it
12:46:38 <reinoud> ok, serious problem here... ghc 7.4.1 has no working hs-plugins
12:47:25 <elliott> reinoud: downgrade or don't use plugins :p
12:47:45 <lambda_zero_cool> jmcarthur - oh, this makes sense. thanks again!
12:47:46 <jmcarthur> mekeor: those benchmarks look good for snap, but i doubt they are very indicative of snap's performance today. it's very likely to have gone up or down due to how much it has changed, i think
12:47:57 <jmcarthur> lambda_zero_cool: no problem
12:48:02 <jmcarthur> lambda_zero_cool: tutorial has been fixed, too
12:48:10 <jmcarthur> (again, without testing...)
12:48:10 <mekeor> jmcarthur: ok, i see.
12:48:39 <reinoud> in my pkgsrc system i can only choose a 6.x version that lacks some modules or use the 7.4 version.... i guess someone hasn't tested it all!
12:48:53 <shergill> reinoud: or port hs-plugins to ghc 7.4.1? though you may want to get in touch with don about that, and see what the issue is there
12:49:02 <reinoud> [ 8 of 12] Compiling System.Plugins.Load ( src/System/Plugins/Load.hs, dist/build/System/Plugins/Load.o )
12:49:02 <reinoud> src/System/Plugins/Load.hs:87:35:
12:49:02 <reinoud>     Module `GHC' does not export `defaultCallbacks'
12:49:02 <reinoud> src/System/Plugins/Load.hs:89:35:
12:49:02 <reinoud>     Module `GHC.Exts' does not export `addrToHValue#'
12:49:02 <reinoud> *** Error code 1
12:49:25 <elliott> reinoud: please paste long pastes into hpaste.org
12:49:44 <elliott> but seriously, hsplugins is pretty bitrotten as i understand it.
12:49:46 <reinoud> sorry
12:49:48 <lambda_zero_cool> jmcarthur: there are a few other things that are a tad misleading in the tutorial.  i'm not sure if it's my system implementation or not, but when i get the desired effects i might go back and make changes when i find all the underlying causes
12:50:03 <jmcarthur> like what?
12:50:14 <reinoud> i am trying to get a package ImplicitCAD working but it uses the hs-plugin :(
12:50:38 <elliott> reinoud: you'll have to rewrite the package or downgrade ghc. or update hs-plugins.
12:50:44 <basri> hi
12:50:56 <jmcarthur> one thing i don't like about that tutorial is that it doesn't teach modern opengl at all
12:51:36 <mekeor> basri: hi
12:51:51 <elliott> mekeor: hi
12:52:20 <lambda_zero_cool> jmcarthur: on my system i need to adjust the window size or use othe rmethods to force animation to occur
12:53:04 <lambda_zero_cool> jmcarthur: however, i also did not need the reziecallback early on.
12:53:31 <lambda_zero_cool> jmcarthur: however, i'm on fedora, and new software gets pushed every ten seconds, so it could be an issue on my end >.>
12:54:15 <elliott> you think fedora has it bad... /me pacman -Syu
12:54:36 <jmcarthur> lambda_zero_cool: i think you need to set postRedisplay on the window if you're not already
12:54:51 <jmcarthur> yeah i get like 10 updates a day on arch
12:55:08 <jmcarthur> lambda_zero_cool: each time you run the idle callback, that is
12:55:36 <ClaudiusMaximus> reinoud: the version on hackage doesn't need plugins, but also will fail to build with ghc-7.4.1 because it uses both base and haskell98 (which is easier to fix, but boring)
12:55:48 <lambda_zero_cool> jmcarthur: the postRedisplay Nothing line in the tutorial leaves me with a blank raster
12:55:55 <jmcarthur> huh...
12:56:24 <jmcarthur> lambda_zero_cool: are you also calling swapBuffers after drawing?
12:56:58 <lambda_zero_cool> jmcarthur - no, let me look that up and see what i can find
12:57:13 <jmcarthur> seems like these should be in the tutorial, but indeed, at least in this point of it, they are not
12:57:28 <jmcarthur> i am also confused by "Only required on Mac OS X, which double-buffers internally"
12:58:15 <jmcarthur> maybe windows doesn't double buffer by default, and the author uses windows
12:58:29 <jmcarthur> but i've never not used double buffering, so...
12:59:10 <jmcarthur> the tutorial does get into that later, as if there's a choice...
13:00:09 <ClaudiusMaximus> swapBuffers is useful! (see also http://dmalcolm.livejournal.com/2433.html )
13:00:27 <lambda_zero_cool> jmcarthur -- yeah, you need to use a DoubleBuffered mode, then add swapBuffers
13:00:39 <lambda_zero_cool> jmcarthur -- i might note that this is needed in linux in the tutorial...
13:00:54 <elliott> ClaudiusMaximus: whoa, that thing only dates back to 2009?
13:01:27 <ClaudiusMaximus> elliott: i don't know if it's the original source
13:02:05 <elliott> i think so
13:26:54 <bgamari> bitonic: ARM and GHC shouldn't be _that_ messy anymore
13:27:01 <bgamari> My recent builds have usually worked
13:27:24 <bgamari> ;)
13:27:48 <reinoud> ClaudiusMaximus: the ImplicitCAD program uses Plugins.Load
13:31:39 <Lorehead> Pardon, but wheres the right place to ask about http://hackage.haskell.org/trac/summer-of-code/ticket/1617
13:32:44 * hackagebot anansi 0.4.4 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.4.4 (JohnMillikin)
13:33:24 <isaacbw> http://en.flossmanuals.net/GSoCStudentGuide/
13:33:35 <ben`> Lorehead: There was a discussion on haskell-cafe@ a while ago, IIRC
13:34:14 <Lorehead> isaacbw: Thank you; Ive completed a GSoC project before.
13:34:29 <Lorehead> Just not for you guys. :)
13:34:30 <ben> huh
13:34:31 <isaacbw> did you fly out to a google office for it?
13:34:50 <Lorehead> No, but I met the project manager at OSCon.
13:35:59 <isaacbw> I'm looking forward to the projects list
13:37:10 <Lorehead> That one looked interesting, and reminded me of some projects Id done for a course in parallel programming.
13:37:52 <Lorehead> I could possibly use Shalev and Shavits Split-Ordered Lists algorithm.
13:38:48 <reinoud> @hoogle sort
13:38:49 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
13:38:49 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
13:38:49 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
13:39:24 <Lorehead> But Im not sure who (other than Greg Collins) to ask about it.
13:40:26 <ClaudiusMaximus> supposing i want to write a library to parse and generarate source code for a language with no formal specification other than the .l and .y files in the source code of the compiler - should i translate using alex+happy (which i've never used before) or something else?  ideally something where i only need to write it once and have both parser + printer made for me...
13:41:59 <monochrom> so you have the grammar in *.l and *.y forms. parsing is no problem. generating, that's the interesting part.
13:45:17 <ClaudiusMaximus> monochrom: right, .l and .y using C - but hopefully simple enough to translate to haskell, possibly even to haskell that doesn't need IO (it's a small language, .l + .y < 700 lines)
13:46:13 <reinoud> @hoogle group
13:46:14 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
13:46:14 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
13:46:14 <lambdabot> System.Posix.Types type GroupID = CGid
13:47:23 <monochrom> for one notation for both parsing and pretty-printing, it seems the popular haskell answer is http://thread.gmane.org/gmane.comp.lang.haskell.cafe/85652/ look at how two persons suggest Rendel's work, and Rendel also speaks up :)
13:48:00 <elliott> ClaudiusMaximus: parser and printer from one thing is painful
13:48:03 <elliott> if you want an EDSL
13:48:05 <monochrom> actually, 3 persons: byorgey, malcolm wallace, Ken Shan
13:48:13 <elliott> because you're not allowed even fmap or anything
13:48:20 <elliott> non-EDSL is presumably a lot less painful
13:49:03 <monochrom> however, I am not sure how hard it is to start from *.l and *.y if you want to using Rendel's work
13:50:20 <ClaudiusMaximus> monochrom: thanks, will read the paper shortly and see if it's sane
13:50:31 <ClaudiusMaximus> (for my use case)
13:50:33 <edwardk> ClaudiusMaximus: ultimately parsing and pretty printing can't be perfect inverses unless you are willing to carry around a _lot_ of useless crap in the syntax tree (e.g. every space or comment in the source file). This doesn't lead to a very nice model to actually program with
13:50:40 <monochrom> the slides may be even more succint
13:50:55 <ClaudiusMaximus> edwardk: mm, true
13:51:09 <scooty-puff> is it possible to get the width of a terminal in haskell?  i'm not even sure what native means i might use..
13:51:27 <companion_cube> edwardk: but can they be inverse modulo garbage (like spaces)?
13:51:29 <edwardk> scooty-puff: i do it in wl-pprint-terminfo by curses + terminfo voodoo
13:51:35 <glguy> scooty-puff: If you are using the "vty" library you can ask
13:52:04 <glguy> (but I wouldn’t advocate for using it solely for that reason)
13:52:07 <edwardk> companion_cube: what you are looking for is something like parse . pretty . parse = parse
13:52:15 <companion_cube> i suppose so
13:52:34 <scooty-puff> k, edwardk, i'm actually using with with wl-pprint-extras for rendering - does it do this automatically
13:52:48 <scooty-puff> actually, i'll just use the terminfo version you mentioned
13:52:58 <edwardk> so you want pretty . parse to be idempotent, with parse taking you down to a smaller set of information that you want to retain. This is a split idempotent basically
13:53:00 <ClaudiusMaximus> elliott: yea i do want to be able to generate code programmaticcally without too much pain
13:53:27 <edwardk> scooty-puff: wl-pprint-terminfo uses wl-pprint-extras it just chooses the argument to be a set of terminal operations
13:53:45 <edwardk> so the change should be pretty painless for you =)
13:53:57 <edwardk> scooty-puff: i use wl-pprint-terminfo in trifecta
13:54:41 <scooty-puff> k
13:56:38 <edwardk> scooty-puff: just import System.Console.TermInfo.PrettyPrint and you can use 'red', etc in your free pretty printer, and use display, displayLn and displayDoc to scribble to the screen using the terminal width if available and falling back on whatever terminfo says is the default for your terminal (or 80 if no info is available)
13:57:19 <edwardk> TermDoc is just "Doc Effect" for a set of terminal effects like changing colors, bolding, etc.
13:57:58 <scooty-puff> i have most of my stuff being instances of Pretty - do if i manually call pretty, I imagine the Doc e would unify with Doc Effect (maybe?)
13:58:09 <scooty-puff> *do -> so
13:58:58 <edwardk> yeah
13:59:20 <edwardk> you can make instances of PrettyTerm by just having prettyTerm = pretty
13:59:21 <nart> what's the best library for creating plots ?
13:59:38 <edwardk> in fact, there is a default implementation that just does that
14:00:12 <edwardk> prettyTerm allows the printer to add effects like color, the default then just doesn't change any colors
14:00:47 <elliott> (class Pretty e a where pretty :: a -> Doc e?)
14:01:13 <edwardk> elliot: its just class Pretty a where pretty :: a -> Doc e -- by default Pretty doesn't use the hole type
14:01:28 <scooty-puff> k - hopefully will add nicer effects later, just so arbitrary about what color i should choose..
14:01:30 <elliott> edwardk: right, the idea is that you wouldn't need PrettyTerm
14:01:40 <elliott> because you could just write "instance Pretty TermThing T where ..."
14:01:46 <edwardk> elliott: its haskell 98
14:01:46 <scooty-puff> o duh, edwardk, at first thought you meant overlapping instances
14:01:48 <elliott> or if you don't use any special stuff "instance Pretty e T where ..."
14:01:50 <elliott> edwardk: ah, fair enough
14:03:04 <edwardk> elliott: i do confess that i don't really -like- the current PrettyTerm nonsense, because its a lot of boilerplate for folks to add to their code
14:03:51 <edwardk> e.g. i never need to generate 'Doc e's in trifecta, but i have to make a bunch of dumbed down non-TermDoc pretty printers
14:04:16 <elliott> you could remove the constraint and use a default signature ... which isn't haskell 98 :)
14:04:37 <edwardk> i could, but i don
14:05:21 <edwardk> t really like default signatures much, and the better signature would want to live in the wl-pprint-free package and point at PrettyTerm which is in a descendant package
14:05:37 <edwardk> default signatures usually muck up class hierarchies, because you need to get everything together in the same place
14:06:24 <reinoud> nite nite
14:06:57 <elliott> edwardk: you could just remove it altogether but i guess " where prettyTerm = pretty" would get annoying
14:07:53 <edwardk> its not that bad, except in some of the scaried diagnostic pretty printers, where its a recipe for cut and paste coding mistakes ;)
14:07:56 <edwardk> er scarier
14:07:57 <timthelion> Is there a "Display" monad for gtk2hs not unlike Read, which would, for example, be able to "display" a Bool as a checkbox, or "display" a string as an edit text area?
14:18:20 <osa1> I'm wondering if it is possible to implement a dynamically typed imperative programming language interpreter in haskell efficiently/elegantly .. any ideas?
14:19:13 <roconnor> @faq is it possible to implement a dynamically typed imperative programming language interpreter in haskell efficiently/elegantly
14:19:13 <lambdabot> The answer is: Yes! Haskell can do that.
14:19:33 <sully> hm.
14:19:40 <sully> @faq blah
14:19:40 <lambdabot> The answer is: Yes! Haskell can do that.
14:19:42 <sully> I see.
14:20:11 <sully> @faq Is it possible to have data structures that transparently rely on benign effects?
14:20:12 <lambdabot> The answer is: Yes! Haskell can do that.
14:20:14 <sully> hm.
14:20:18 <sully> inaccurate.
14:20:19 <timthelion> osa1: is this a joke ?
14:20:46 <DMcGill> @faq can haskell tell jokes?
14:20:46 <lambdabot> The answer is: Yes! Haskell can do that.
14:20:47 <osa1> timthelion: no. what made you think that?
14:21:06 <timthelion> osa1: #haskell humor :)
14:21:37 <monochrom> the answer is still yes
14:21:44 <roconnor> osa1: dynamically typed imperative is pretty much the opposite of everything that Haskell stands for.  That said, Haskell is pretty good at impelementing laguages, even dynamically-typed imperitive ones.
14:21:57 <timthelion> osa1: there have been several books about it.  I think RWHS is, I'm not sure, is Perl dynamically typed?
14:22:07 <DMcGill> not so much dynamic, but I've done lots of iterative programming in Haskell
14:22:34 <DMcGill> doesn't SPJ have a quote on the topic?
14:23:15 <DMcGill> "In short, Haskell is the world’s finest imperative programming language"
14:23:16 <timthelion> Somewhere I read that you can't call yourself a haskell programer unless you've implemented Perl in haskell.
14:23:24 <DMcGill> from 'Tackling the Awkward Squad'
14:23:59 <timthelion> DMcGill: He also sugests you use unsafepreformIO to load config files though ;)
14:24:56 <DMcGill> ooh, relevant question. When I was programming in HOpenGl, I had a getBackground :: IO Image
14:25:31 <DMcGill> when displaying, I'd do `do {background <- getBackground; display background}'
14:25:51 <timthelion> osa1: basically, an imperitive program is just a program that is deterministic as to order of evaluation.  Many mathematical structures are determinstic, gnostically, as to order of evaluation, therefore, imperitiveness is a subset of the structures which haskell can represent.
14:26:05 <DMcGill> but each time I did that it'd reread the background from the file. To get around this I used unsafePerformIO, what's a better solution?
14:27:25 <timthelion> osa1: does what I just said make sense to you?
14:27:34 <Botje> DMcGill: read it once and pass it along
14:27:41 <osa1> timthelion: thanks. I'm interested in PL implementations. right now I have a extended version of McCarthy's micro-manual for lisp implemented in haskell, but I'm not happy with the result so I wanted to ask.
14:28:03 <Botje> DMcGill: or stuff it in an IORef and read that when you need it
14:28:04 <quintessence> osa1: you might want to look at pugs (perl6 in haskell)
14:28:18 <nart> osa1: what's "extended version of McCarthy's micro-manual" ?
14:28:43 <timthelion> nart: McCarthy's mega-manual :D
14:28:46 <osa1> nart: google for "micro-manual for lisp". I wrote an extended version of it
14:29:14 <Botje> is pugs still the only programming language implementation to use ropes ?
14:30:23 <timthelion> Botje: when I looked up "Pugs ropes", the only results are a dog playing with a chew toy tied to a rope...
14:31:06 <elliott> http://hackage.haskell.org/package/Pugs
14:31:11 <elliott> i guess http://pugscode.org/ is more helpful
14:31:49 <timthelion> elliott: thanks, but I wanted info on ropes...
14:32:08 <elliott> http://en.wikipedia.org/wiki/Rope_(computer_science)
14:32:15 <elliott> including an inexplicably-tilted diagram
14:32:27 <timthelion> elliott: thank you, you are very kind, but you really don't have to go look up the URL for me :)
14:32:59 <elliott> I'm faster than Google!
14:33:28 <timthelion> elliott: lol, that you are, how is that?
14:33:29 <quintessence> Botje: I think some javascript implementations use them
14:35:46 <Botje> quintessence: ooh, interesting
14:35:47 <elliott> timthelion: Well, I'm actually strictly slower than Google, since I used Google to get that URL.
14:36:06 <elliott> But there's a slight chance I have a lower-latency connection to Google.
14:36:12 <Botje> i'll search for them when i have some free time
14:36:41 <wollw> Hmm... I was looking at the GSoC proposed projects and noticed the "Library for the Arduino platform" proposal.  I'm only passingly familiar with Haskell right now but I've done a fair amount of work with the AVRs with avr-libc and assembly and it seems like an interesting project to me.
14:37:31 <blackdog> wollw: it's a pretty hard one, i think, but could be interesting.
14:37:31 <wollw> "While this sounds like a cool project, I'm worried it wouldn't see much use behind perhaps a handful of people." <-- this is certainly a valid concern though
14:37:39 <hpaste> ClaudiusMaximus pasted “load on demand with cache” at http://hpaste.org/65958
14:37:58 <wollw> blackdog: yeah, my first thought was wondering how feasible it even was
14:38:06 <ClaudiusMaximus> DMcGill: ^^ perhaps
14:38:11 <blackdog> wollw: i'd be interested. My startup is based on Haskell and Arduino, so it's right in my wheelhouse:)
14:38:13 <elliott> Well, it can't be harder than the "fix Cabal" project.
14:38:27 <blackdog> elliott: at least it's tightly defined, right?:)
14:38:33 <elliott> right :P
14:38:40 <wollw> blackdog: what's your startup?
14:38:45 <blackdog> wollw: ninjablocks.com
14:39:00 <wollw> blackdog: ah, i've seen that
14:39:00 <blackdog> kind of Twine + IFTTT + actuators
14:39:15 * blackdog is suffused with joy
15:01:50 <nand`> would (head . sort) evaluate in O(n) time?
15:02:08 <copumpkin> supposedly
15:03:16 <nand`> I'm thinking it might be O(log n) depending on how sort is implemented
15:03:26 <nand`> (then again, I could just look at the source)(
15:03:55 <shachaf> nand`: That would be a neat trick.
15:10:53 <elliott> nand`: http://apfelmus.nfshost.com/articles/quicksearch.html
15:17:12 <DMcGill> nand`: how could it be worst case O(log n), surely it has to at least compare against every other element?
15:17:53 <nand`> I meant O(n log n) of course
15:17:56 <nand`> my bad
15:19:41 <nand`> given the type of sort any less than O(n) ought to be utterly impossible
15:21:39 <nand`> (as measured by number of operations, that is; O(log n) *time* should be conceivable if you allow parallel processing)
15:23:02 <Lorehead> Still, with algebraic refactoring, its possible to look at head . sort and realize, hey, thats the minimal element.
15:23:10 <Lorehead> Which can be found in O(n) time.
15:23:24 <Lorehead> I mean, a human can do it.
15:23:33 <nand`> a compiler can too
15:23:37 <nand`> just not generally
15:24:11 <Lorehead> Right; itd be interesting to formalize a system that could look at the postconditions and deduce something like that.
15:24:21 <Lorehead> Very interesting.
15:24:37 <DMcGill> does `head . sort' have any advantages over `foldr1 min' or whatever the prelude def is?
15:24:40 <DMcGill> @src minimum
15:24:40 <lambdabot> minimum [] = undefined
15:24:41 <lambdabot> minimum xs = foldl1 min xs
15:25:51 <nand`> DMcGill: “head . sort” shouldn't, but that can be generalized to “take k . sort”
15:27:14 <lcfrs> has anyone done anything with websockets and conduits? i'm working on a websocket-plainTCP gateway: http://hpaste.org/65961.
15:40:32 <lcfrs> jaspervdj: ping?
15:45:43 <adnauseam> a question regarding LYAH
15:45:48 <adnauseam> in "  A value of Just "dharma" means that the string "dharma" is there whereas a value of Nothing represents its absence, or if you look at the string as the result of a computation, it means that the computation has failed."
15:46:12 <adnauseam> how can only in the string as a result mean that the computation has failed ?
15:46:31 * shachaf is unable to parse adnauseam's last sentence.
15:46:45 <adnauseam> because it's not either Just "dharma" or Nothing ?
15:46:50 <rtharper> ?
15:46:55 <rtharper> Nothing signifies failure
15:47:00 <shachaf> adnauseam: However, that quote in LYAH is a *definition* of "failure" -- that word has no meaning before being defined.
15:47:02 <adnauseam> yeah it's confusing me myself, it's straight out of learn you a haskell
15:47:14 <shachaf> adnauseam: No, I'm confused by what you said, not by what it said. :-)
15:47:16 <rtharper> and Just with any value signifies success
15:47:23 <adnauseam> oh
15:47:23 <adnauseam> hmm
15:47:40 <adnauseam> well it said that " if you look at the string as the result of a
15:47:42 <adnauseam>                    computation, it means that the computation has failed"
15:47:55 <adnauseam> how can getting the string be a failure ?
15:47:59 <rasfar> "it means" refers to the Nothing case, if that's the point of confusion
15:48:05 <shachaf> adnauseam: Ah, the phrasing is confusing.
15:48:16 <shachaf> adnauseam: It should say "if you look at the Maybe String as the result of a computation ..."
15:48:23 <shachaf> In the case that the Maybe String is Nothing.
15:48:29 <adnauseam> rasfar: that's what i /assumed/ but i'm a bit confused and don't want to read on without making sure
15:48:33 <adnauseam> shachaf: yeah
15:48:53 <shachaf> adnauseam: However, failure is only one of the possible meanings you can assign to (Maybe x).
15:48:56 <adnauseam> shachaf: yeah that makes sense like that
15:49:10 <adnauseam> ofcourse , failure is relative
15:49:18 <adnauseam> im jut being a noob :}
15:49:38 <adnauseam> i think it'll be many mpore months before i start sounding coherent ;p
15:50:04 <DMcGill> For example, if you're performing IO actions, Nothing could mean success while Just could contain an error value.
15:50:19 <DMcGill> Not that I'm convinced that's a good idea
15:50:31 <adnauseam> oh, heh, i hadn't thought of Maybe in terms of errors or exceptions, cool
15:50:39 <shachaf> DMcGill: What does that have to do with IO?
15:50:44 <shachaf> Oh, I see.
15:50:55 <shachaf> Either Error ReturnValue would probably be nicer.
15:51:09 <Lorehead> If youre looking up something in an association list, Nothing means there were no matches.  That could, in context, be expected or unexpected, and so could the opposite.
15:51:14 <shachaf> Although that's equivalent to Maybe Error if ReturnValue = (), of course.
15:51:17 <DMcGill> If there really isn't one though, surely Maybe Error is nicer than Either Error ()?
15:51:23 <DMcGill> ha, exactly
15:51:26 <elliott> DMcGill: I disagree.
15:51:28 <shachaf> DMcGill: Is it?
15:51:31 <elliott> The Either monad does what you want there.
15:51:33 <elliott> The Maybe monad doesn't.
15:51:42 <shachaf> It's less consistent, if some things return things and other things don't.
15:51:50 <shachaf> There's also what elliott said.
15:52:03 <DMcGill> What's the difference between `Either Error ()' and `Maybe Error' other than the names of things?
15:52:07 <elliott> The instances.
15:52:13 <elliott> In particular, like I just said, Monad.
15:52:20 <elliott> > Just "error" >> return 42
15:52:21 <lambdabot>   Just 42
15:52:24 <elliott> > Left "error" >> return 42
15:52:24 <shachaf> And Functor
15:52:25 <lambdabot>   Left "error"
15:52:32 <elliott> Right, Functor too.
15:52:33 <DMcGill> ah I get it now, thanks
15:52:40 <elliott> And Applicative, Alternative, MonadPlus, ..., :)
15:52:56 * adnauseam 's head explodes
15:53:32 <adnauseam> though i think i actually understood some of what you guys said... it's better i burry my head in the book again
15:53:52 <adnauseam> i shal return with more confusion in due time o_0
15:54:25 <nand`> > Just "error" >> Nothing
15:54:26 <lambdabot>   Nothing
15:54:32 <elliott> adnauseam: The rough point me and shachaf were making is "sequencing (Either Error ())s makes the errors act as 'exceptions' properly, sequencing (Maybe String)s doesn't"
15:54:39 <elliott> (it treats the errors as successful results instead)
15:58:24 <adnauseam> elliott: in that, the logically speaking, there must be an action, or an error, and not a fuzzy condition of Maybe having an action or an error. though i think i'm only talking from the aspect of reason, not Haskell's inner functionality - i've only actually begun reading about Monads, and i'm at Maybe
15:58:39 <adnauseam> s/the logically speaking/logically speaking
15:59:00 <shachaf> Ugh. Maybe.
15:59:24 <adnauseam> :p
15:59:26 <shachaf> I don't like the approach that goes "let's learn aboout Monad! OK, as a first step in order to do that, let's learn about Maybe the Monad!"
16:00:02 <adnauseam> *points to* lyah o_0 not my fault
16:00:19 <DMcGill> Why not? It's the simplest and most intuitive monad imo
16:00:59 <shachaf> It's just misleading.
16:01:01 <elliott> DMcGill: "Let's learn about integers! First, here's a bunch of properties of the number 0."
16:01:09 <elliott> "Understand integers yet?"
16:01:16 <adnauseam> personally i think it's alright - especially since the previous chapter covered monoids and applicatives
16:01:24 <rasfar> lcfrs: have you seen http://www.yesodweb.com/blog/2011/12/resourcet ?  I wonder if it could help at the point you're at?  Personally I've not worked with these tools (had to install lots of stuff to compile your example) (which doesn't compile anyways...)
16:01:25 <shachaf> elliott: Hey, to be fair, it's the number 1.
16:01:38 <elliott> adnauseam: Well, a monad is just a monoid in the category of endofunctors.
16:01:44 <elliott> So you don't even need a whole chapter on them, really.
16:01:51 <shachaf> I also think "let's learn about Monads! OK, first step: Let's learn about Applicatives! ..." is not a good approach.
16:01:52 <adnauseam> yeah, an "upgraded applicative" as lyah describes it
16:02:05 <adnauseam> no no, we learned about applicatives
16:02:07 <elliott> shachaf: LYAH doesn't even talk about monads when it introduces applicatives, I don't think.
16:02:11 <adnauseam> and now we're moving on to monads
16:02:16 <adnauseam> and why am i saying we o_0
16:02:16 <shachaf> elliott: OK, but it's still using that order.
16:02:32 <elliott> shachaf: Do you really wish monads were taught before functors and applicatives?
16:02:33 <aristid> shachaf: what is a good approach?
16:02:35 <shachaf> Better to start with something concrete -- or several somethings concrete -- and then show "oh, look, this pattern generalises!".
16:02:43 <elliott> Well, sure.
16:02:46 <shachaf> Like, say, _Programming in Haskell_ does.
16:02:51 <elliott> But teaching Monad before Applicative is still sin.
16:02:58 <elliott> Independent of the method you use.
16:02:58 <aristid> shachaf: i think rwh does the same
16:03:16 <shachaf> elliott: Hardly. I don't think Applicative is worth mentioning.
16:03:29 <shachaf> aristid: I don't think RWH is an introductory book.
16:03:43 <aristid> shachaf: i used it as such, back in 2010 :P
16:03:46 <tswett> A monad is a monoid in the category of endofunctors, you say.  What's a monoid in a category?
16:03:52 <elliott> shachaf: What do you have against Applicative?
16:03:53 <adnauseam> hrm, applicatives is the one thing i've actually made me understand functors =p
16:03:55 <lcfrs> rasfar: thanks for taking a shot at it, i've taken a look at resourcet, but i'm still figuring it out. according to ghc, i need to make the WebSockets monad an instance of MonadBaseControl, which has little documentation to go on.
16:04:12 <elliott> tswett: eta :: 1 ~> m; mu :: m*m ~> m
16:04:22 <elliott> tswett: For Monoid, define 1 = (), (~>) = (), (*) = (,)
16:04:33 <lcfrs> but i'm looking at a happstack patch that includes monad control decls.
16:04:39 <elliott> tswett: For Monad, define 1 = Identity, (~>) = natural transformation, (*) = functor composition
16:05:02 <tswett> elliott: ...so what do ~> and m represent in your definition?
16:05:20 <elliott> m is the mon(oid|ad).
16:05:38 <shachaf> tswett: In the context of Monoid, m represents the Monoid intsance. In the context of Monad, it represents the Monad instance. Note that the two have different kinds.
16:05:44 <elliott> I.e. monads are eta :: Identity a -> m a; mu :: m (m a) -> m a
16:05:53 <elliott> Monoids are eta :: () -> m; mu :: (m, m) -> m
16:06:28 <nand`> https://en.wikiversity.org/wiki/Introduction_to_Category_Theory/Monoids#Monoids <- Monoid in a category
16:06:32 <tswett> So, from what you say, I'm getting the idea that a monoid is an object M together with two morphisms, mu : M * M -> M, called multiplication, and eta : I -> M, called unit, such that mu is associative and eta is an identity for mu.
16:07:01 <tswett> (...Yeah, I'm being sarcastic.)
16:07:12 <adnauseam> ... o_0
16:08:08 <rasfar> lcfrs: good luck; hopefully someone with more experience will pop up if you're still stuck
16:08:16 <lcfrs> thanks
16:09:03 <lcfrs> ezyang: ping?
16:09:09 <elliott> lcfrs: i know monad-control, more or less
16:09:17 <elliott> what is WebSockets declared as?
16:09:41 <DMcGill> adnauseam: Don't feel bad, I'm in my 3rd year of doing maths at uni and still haven't done any category theory despite specialising in pure maths
16:10:19 <lcfrs> elliott: it's a newtype of ReaderT (WebSocketsEnv p) (Iteratee (Message p) IO) a
16:10:22 <adnauseam> 1st year of computer sciences - i come from a background in literature o_0
16:10:32 <danharaj> The first place most mathematicians will see category theory is in homological algebra.
16:11:00 <DMcGill> I'm doing modules in abstract algebra at the moment, how far from that am I?
16:11:01 <adnauseam> 1st semester, going into my second - feeling i should buy happy pills, crying\punching pillows and a baseball bat o_0
16:11:09 <elliott> lcfrs: you can probably just derive MonadBaseControl with the appropriate extensions then
16:11:58 <danharaj> DMcGill: I don't know where you're going to school. It's usually a graduate level topic. Another place category theory can be introduced is in algebraic geometry.
16:12:53 <lcfrs> elliott: ok cool, except, i'm not sure how to. is there some guiding material available? maybe some example cases?
16:13:07 <elliott> lcfrs: deriving as in literally
16:13:10 <elliott> deriving (MonadBaseControl IO)
16:13:13 <elliott> after the definition
16:13:17 <lcfrs> ah right
16:13:25 <lcfrs> that doesn't compile
16:13:27 <elliott> failing that you should be able to write an instance that literally just unwraps and wraps the newtype when appropriate
16:13:30 <elliott> assuming ReaderT has an instance
16:13:32 <elliott> oh, but does Iteratee?
16:13:39 <lcfrs> let me find the error message
16:13:39 <elliott> in fact, I think Iteratee might be one of the things that _can't_ be MonadControl'd
16:13:43 <elliott> because it's kind of like Cont
16:13:49 <elliott> so... you might be out of luck
16:13:57 <elliott> maybe email haskell-cafe asking
16:13:59 <lcfrs> ha
16:14:00 <lcfrs> ok
16:14:17 <lcfrs> thanks, i'll try that
16:15:18 <tswett> But yeah.  A monad is a monoid in the category of endofunctors, that means...
16:15:28 <tswett> That definition of a monad is equivalent to the definition I already know.
16:15:30 <tswett> Why am I surprised.
16:17:33 <tswett> Then again, what does this Pangur symbol mean... ah, it only makes sense in a monoidal category, whatever that is.
16:18:00 <DMcGill> ha, read that as "monocidal" there
16:18:27 <adnauseam> in haskell ; +3 === 3+ ?
16:18:33 <DMcGill> monocidal: a tendancy to really want to kill one thing in particular
16:18:43 <elliott> adnauseam: no
16:18:47 <adnauseam> hrm
16:18:47 <elliott> except
16:18:48 <elliott> wlel
16:18:52 <elliott> sure (+3) is equivalent to (3+)
16:18:57 <elliott> but only because (x+3) is equivalent to (3+x)
16:19:05 <tswett> "A pseudoring, also called a monocidal ring . . ."
16:19:10 <elliott> (does this hold for floating point?)
16:19:11 <adnauseam> i got thinking when i tried to do -3
16:19:17 <adnauseam> and found out it had to be 3-
16:19:35 <adnauseam> but then got confused as to why all examples have the action at the front
16:19:47 <shachaf> It's not "at the front".
16:19:48 <adnauseam> when it works just as fine if it's at the back - and also avoids getting errors with -3
16:19:57 <DMcGill> > subtract 3 10
16:19:58 <lambdabot>   7
16:20:09 <tswett> I'm pretty sure that (-3) is a special case.  All operators *except* for - can be put before the argument that way.
16:20:42 <elliott> adnauseam: Let's say % is some operator. (% y) === (\x -> x % y)
16:20:50 <elliott> (x %) === (\y -> x % y)
16:20:51 <elliott> Not the same.
16:20:54 <elliott> - is a special case though.
16:21:01 <elliott> (-3) is negative 3 instead of (\x -> x - 3)
16:21:03 <elliott> It sucks.
16:21:17 <elliott> But (3-) is (\x -> 3 - x), which is not (\x -> x - 3).
16:21:17 <adnauseam> hrm, i see your point actually
16:21:51 <adnauseam> +3 to 3 is not as -3 to 3
16:21:57 <bbommarito> Is there a good Haskell lib for dealing with sqlite databases?
16:22:42 <DMcGill> @hackage sqlite
16:22:42 <lambdabot> http://hackage.haskell.org/package/sqlite
16:22:58 <DMcGill> I wasn't actually expecting that to work...
16:23:14 <adnauseam> haha
16:23:14 <adnauseam> =]
16:23:16 <elliott> bbommarito: http://hackage.haskell.org/package/direct-sqlite http://hackage.haskell.org/package/HDBC-sqlite3 http://hackage.haskell.org/package/hsql-sqlite3 http://hackage.haskell.org/package/hsSqlite3 http://hackage.haskell.org/package/sqlite http://hackage.haskell.org/package/bindings-sqlite3
16:23:18 <elliott> pick one :p
16:23:44 <bbommarito> elliott: Okay, I did that whole search. Perhaps the better question: Which one is still maintained and in use?:)
16:24:45 <elliott> http://hackage.haskell.org/package/persistent-sqlite is based on direct-sqlite, apparently.
16:24:52 <irene-knapp> yes
16:24:53 <blackdog> ski: turned out i was being too clever by half yesterday, btw. the conversion typeclass is rigid - if i have a datatype Foo { bar :: Int } , it'll work if i pass in the equivalent of "{'bar': 1}", but not "{'bar': 1, 'extraneous':2}"
16:24:53 <elliott> I gather persistent has a lot of users, so maybe direct-sqlite or sqlite.
16:25:02 * irene-knapp is pleased about that
16:25:14 <elliott> sqlite is the other option only because it has a valuable piece of namespace.
16:25:21 <ezyang> lcfrs: pong
16:25:23 <elliott> Can't resist the pull.
16:26:03 <lcfrs> ezyang: i was wondering if it was any value trying to run conduit operations inside the websocket monad, or if i should just stick to iteratee style ops.
16:26:42 <lcfrs> i was trying to do something like: http://hpaste.org/65961 -- doesn't compile
16:27:20 <lcfrs> but elliot has suggested that conduits is not compatible with iteratee
16:38:38 <kallisti> what would be the best way to add a "finalizer" in the Error monad.
16:38:52 <kallisti> code that's executed on both exceptional and successful conditions.
16:39:06 <kallisti> I can't think of a clean way to do it with just catchError
16:40:19 <kallisti> hm oh wait here's a possibility.
16:40:38 <kallisti> I could throw mzero at the end of my code, the MZero case represents a successful execution.
16:41:07 <kallisti> though that's kind of backwards from the usual logic.
16:42:17 <nart> anyone has an idea that is cool, not too difficult, and educational to implement ? =D
16:43:32 <kallisti> nart: a markov chain of some kind.
16:43:42 <kallisti> to randomly generate text, sounds, words, images, etc.
16:43:46 <kallisti> pick your application.
16:44:33 <nart> kallisti: never heard of it, ty for the suggestion
16:45:38 <ezyang> lcfrs: In general, conduits and iteratees are not particularly compatible with each other.
16:45:47 <ezyang> lcfrs: But I don't know what the WebSocket monad is.
16:48:47 <lcfrs> ezyang: ah. well thanks for replying, i'll keep looking.
16:49:13 <rasfar> lcfrs: i'm still slogging at it, one thing is your address and port args are out of order in call to runServer.  (i realise this is hardly the point...)
16:50:09 <kallisti> throwing strMsg with a special success string and catching feels really hacker.
16:50:16 <kallisti> surely there's a better way to do finalizers.
16:50:24 <kallisti> s/hacker/hacky/
16:50:44 <rasfar> (and to runTCPClient)
16:51:04 <lcfrs> rasfar: sorry, i've updated it removing the silly errors. talking with people here, it seems like the conduit operators are not the correct approach to take with websockets.
16:51:33 <elliott> <lcfrs> but elliot has suggested that conduits is not compatible with iteratee
16:51:34 <elliott> erm, i did?
16:52:36 <kallisti> aha, this probably works well: have the action return a Maybe WDError and then have the finalizer code immediately afterward.
16:53:10 <kallisti> myStuff `catchError` return . Just
16:53:12 <kallisti> like so
16:53:20 <lcfrs> elliott: did i misinterpret? i meant to summarize what i thought our conclusions were. iteratee can't be monadcontrol'd.
16:53:40 <lcfrs> perhaps i was too general
16:56:16 <elliott> lcfrs: well, conduit does not afaik depend on monad-control for all operations
16:57:01 <lcfrs> yes, you're right, i was thinking about network-conduit which does depend on monad-control
16:59:14 <otters> has somebody implemented an SSH client in haskell
17:01:57 <nand`> I don't know but libssh2 might c ome in handy
17:03:59 <rasfar> There's https://github.com/bcoppens/HaskellSshClient which might make a good starting point, but the README hardly inspires confidence :D
17:04:46 <kallisti> (myStuff' >> return Nothing) `catchError` (return . Just) >>= finalizer
17:04:53 <kallisti> so does this look like reasonable finalizer code?
17:16:21 <rasfar> lcfrs, if you don't mind educating me a little: i'm trying to declare an instance for MonadBaseControl.  That would mean giving a definition of liftBaseControl correct?  but when I try that, I get:
17:16:25 <rasfar> `liftBaseControl' is not a (visible) method of class `MonadBaseControl'
17:16:42 <rasfar> does that mean we can't make new instances?
17:17:25 <rasfar> (I'm using the source of Control.Monad.Trans.Control as a model for declaring instances)
17:17:50 <lcfrs> rasfar: i'm afraid i don't know enough to help you
17:18:17 <elliott> http://hackage.haskell.org/packages/archive/monad-control/0.3.1.1/doc/html/Control-Monad-Trans-Control.html#t:MonadBaseControl
17:18:17 <rasfar> hah! ok...
17:18:23 <elliott> you define StM, liftBaseWith, restoreM
17:18:37 <rasfar> thanks elliott, i'll look
17:23:12 <bunn> greetings. help me. pls solve the equation. (3x+y)/y =dy/dx (3y+x)/y=dy/dx
17:25:27 <Modius> Is there the equivalent of F#'s object cloning in haskell?  That is, you have an object and can get a copy of it with 1-N fields replaced?
17:26:39 <mauke> did you mean: N-1
17:40:55 <siracusa> Modius: What kind of Haskell "object" are you trying to clone? And why?
17:41:48 <Modius> data Foo = Foo { Something:: int, SomethingElse :: string }
17:42:04 <Sgeo_> Modius, since you can't change an object, there's no reason to copy an object
17:42:08 <mauke> record update syntax
17:42:18 <mauke> also your capitalization is off
17:42:19 <Sgeo_> Oh, that
17:42:36 <Modius> In F# there's this useful goodie where you can say { foo with SomethingElse = "Replacement" } <-- copies the original, with specified fields swapped.
17:42:51 <mauke> foo{ somethingElse = "Replacement" }
17:42:52 <Modius> I'm talking about immutable objects.
17:44:06 <Modius> mauke:  Thanks, that was it - what's the term used in haskell-world for this?
17:44:13 <mauke> <mauke> record update syntax
17:48:41 <kakashi> what's the problem with orphan instances?
17:49:13 <roconnor> kakashi: when orphan instances collide!
17:50:00 <kakashi> what do you mean collide
17:50:22 <kakashi> at runtime?
17:50:44 <JoeyA> When multiple modules define the same instance, which fails at compile time (I just joined; I don't know the context).
17:53:59 <siracusa> JoeyA: context:  "what's the problem with orphan instances?"
17:55:15 <JoeyA> gotcha
17:56:35 <kakashi> i don't see a big deal yet, an answer on stack overflow said it could crash programs at runtime
18:01:16 <c_wraith> orphan instances can't crash programs at runtime.  All the damage they can do is at compile-time.
18:02:26 <kakashi> http://stackoverflow.com/a/3079748/50754
18:04:02 <c_wraith> meh. That's not a problem with orphan instances, it's a problem with bad instances.
18:04:50 <mauke> I don't believe that "crashing at runtime" part
18:04:55 <mauke> preflex: seen yitz
18:04:55 <preflex>  yitz was last seen on #haskell 6 hours, 54 minutes and 15 seconds ago, saying: elliott: ok. i do think that's what timthelion means though. e.g. [(Frame,a)] where Frame has an ordering.
18:06:41 * BMeph says in "announcer voice": In a world, where orphan instances collide, one language holds the key to successful compilation, in our time.
18:07:24 <shergill> BMeph: +1
18:08:45 <hpc> @remember BMeph (in "announcer voice") <BMeph> In a world, where orphan instances collide, one language holds the key to successful compilation, in our time.
18:08:45 <lambdabot> Okay.
18:11:09 <dobblego> hey roconnor want me to put data-lens 4.0.0 up on hackage? I'm using it a fair bit in other hackage packages
18:12:34 <roconnor> dobblego: really?
18:12:38 <roconnor> what features are you using :D
18:12:42 <dobblego> truly
18:12:48 <dobblego> lots of them -- actually I am  using my fork
18:12:56 <roconnor> link?
18:13:01 <dobblego> but in particular, I mostly create a partial lens for many of my ADTs
18:13:13 <dobblego> then I write specialised combinators of those
18:13:25 <dobblego> pattern-matching is so 90s
18:13:27 <roconnor> dobblego: you are aware of the partial-lens package?
18:13:35 <dobblego> yes
18:13:43 <dobblego> I figured it's deprecated for data-lens innit?
18:14:08 <dobblego> https://github.com/tonymorris/data-lens/tree/tmorris
18:14:31 <roconnor> ah right.
18:14:59 <roconnor> I glanced through your changes, I'm not sure how I feel about so many infix operations :)
18:15:11 <dobblego> I was just doing that for consistency -- remove them
18:15:29 <roconnor> :)
18:15:36 <dobblego> there is another operation I am using, but haven't implemented in that yet
18:15:43 <dobblego> PLens a b -> PLens (Maybe a) b
18:16:30 <roconnor> heh
18:16:57 <dobblego> pretty simple, but I have colleagues asking about "how to traverse down my JSON data type?"
18:17:06 <dobblego> so I wrote them that and it shut them up
18:17:18 <roconnor> colleagues?
18:17:28 <dobblego> yes, at work I mean
18:17:34 <dobblego> I write libraries for them to use a fair bit
18:17:42 <roconnor> you use haskell at work?!
18:17:48 <dobblego> damn straight mate
18:18:05 <dobblego> and scala -- about 50/50
18:18:19 <dobblego> actually about 45/45, sometimes they trick me with their javascript/java problems
18:18:24 <dobblego> I just lol
18:18:47 <roconnor> So I've though about it, but I'm afraid that data-lens 4.0 just isn't ready for distribution yet. :(
18:19:00 <dobblego> what's the hold up you think?
18:19:13 <roconnor> The problem is that I'm moving to France in a week, so I've been spending all my time preparing for that.
18:19:30 <roconnor> dobblego: I'm worried that Multi-lens is totally untested
18:19:32 <dobblego> I'm happy to tidy it up if we can agree what needs doing
18:19:38 <roconnor> and I know I've made some mistakes in it.
18:19:42 <dobblego> oh ok, I haven't looked at that much
18:20:02 <roconnor> It is so easy to get thing "backwards" in Multi-lens
18:20:03 <NemesisD> anyone use the Options library or know if john milikin ever comes in here
18:20:20 <roconnor> in fact, I have a hard time figuring out which way is backwards and which way is forwards.
18:20:23 <roconnor> :D
18:20:28 <dobblego> roconnor: yep I can see that, I'll take a look when I can (right now is not a good time for reviewing code)
18:20:54 <roconnor> dobblego: if you can wait a week or two, I should get some free time
18:21:00 <dobblego> yeah sure
18:21:10 <roconnor> or, perhaps when I'm stuck in airport longues I'll get some time to work on it. :D
18:21:10 <dobblego> I want it to be awesome as much as you mate -- happy to help when I can
18:21:23 <dobblego> ha, I just did that
18:21:26 <roconnor> dobblego: have any uses for multi-lens?
18:21:31 <nart> what's a lens ?
18:21:32 <dobblego> though I was finishing up a paper on lenses
18:21:50 <dobblego> roconnor: not that I have recognised, but that's likely to be me more than anything
18:22:21 <roconnor> nart: a lens is a data-type that captures the idea of how to refer to a substructure from a superstructure for purposes of updating.
18:22:22 <dobblego> nart: I wrote a paper, Asymmetric Lenses in Scala, which has been accepted to Scala Days 2012 -- you can read the draft if you like
18:22:44 <roconnor> dobblego: is that more asymmetric that data-lenes, or just as asymmetric?
18:23:13 <dobblego> roconnor: just as asymmetric; covers Lens and a short bit on partial lenses (ran out of room)
18:23:32 <dobblego> http://dropbox.tmorris.net/media/doc/lenses.pdf
18:23:34 <nart> dobblego: is the draft public ?
18:23:43 <nart> dobblego: nice thanks :D
18:23:47 <dobblego> np
18:24:29 <roconnor> Its funny that lenses weren't popular 20 years ago.
18:24:59 <dobblego> there is question once per week on the scala mailing list where the appropriate answer is, "congratulations, you've just invented lenses"
18:25:04 <jfischoff> roconnor: what's your take on the isomorphic form of lenses
18:25:19 <dobblego> it causes a bit of abrasion though
18:25:24 <roconnor> dobblego: did you ever see edwardk's youtube videos of his talk on lenses in Scala?
18:25:29 <dobblego> roconnor: yep
18:25:36 <roconnor> dobblego: good
18:25:42 <roconnor> jfischoff: isomorphic form?
18:26:02 <dobblego> roconnor: we (Ed, me and a few others) have lenses written up in a third-party library (scalaz)
18:26:05 <shergill> roconnor: got a link?
18:26:06 <jfischoff> yeah, a -> (a/b, a)
18:26:21 <jfischoff> err s/->/<->
18:26:48 <dobblego> jfischoff: it is discussed in "Functor is to lens as applicative is to biplate" iirc
18:27:04 <shergill> roconnor: nvm
18:27:11 <roconnor> jfischoff: oh ya.  I'm a bit skeptical of it.  I was going to try to write it in Agda or Coq to check that it works, but I've never got around to doing it.
18:28:39 <jfischoff> roconnor: you might like https://www.cs.indiana.edu/~rpjames/papers/rational.subc.pdf
18:28:54 <NemesisD> what the actual F
18:29:32 <roconnor> dobblego: do you the partial-lens operations on State?
18:29:50 <dobblego> I think you an important word
18:29:58 <dobblego> do I use them? Yes
18:30:27 <dobblego> mostly in top-level code, where it is specific to the application itself
18:31:46 <roconnor> Okay; I just sort of made up those operations.  I'm not actually sure they are useful/the right ones
18:31:56 <hpaste> NemesisD pasted “WTF Word16” at http://hpaste.org/65972
18:32:23 <roconnor> dobblego: the idea of assignment silently failing is a bit foreign to the imperative world, where an exception is usually thrown instead.
18:32:24 <dobblego> they seem fine to me, but I think I mostly use a subset of them
18:32:29 <NemesisD> can someone please tell me what on earth is happening to my word16 there? its printing as an entirely different number
18:32:35 <dobblego> yeah I often wonder about that
18:32:40 <dobblego> i.e. how to best solve it
18:32:51 <roconnor> dobblego: the semantics seem to point this way though.
18:33:18 <roconnor> dobblego: at least it isn't totally silent, you can check the "return value" to see if it was Nothing, if I recall correctly.
18:33:18 <mauke> NemesisD: yes! do not use PortNum (the data constructor)
18:33:24 <mauke> NemesisD: that should solve all your problems
18:33:41 <NemesisD> mauke: what do i use then?
18:33:44 <NemesisD> and why is it a problem?
18:33:54 <dobblego> right but you don't know "where" it failed if you want that granularity (maybe it could be argued that either you want it and you're using ti wrong or you don't)
18:33:56 <mauke> NemesisD: because you're looking at port internals
18:34:02 <mauke> don't access internals
18:34:14 <mauke> NemesisD: fromIntegral
18:34:21 <mauke> PortNumber should be a Num
18:35:15 <NemesisD> mauke: i am highly confused. hedis has a field that uses PortNumber, it just uses a number
18:35:20 <roconnor> dobblego: anyhow, the coalgebraic semantics says that setting a null value simply returns the orignal structure.  Hard to argue with the math.  I didn't invent coalgebra of comonads :D
18:35:23 <mauke> NemesisD: yes!
18:35:26 <mauke> exactly
18:35:34 <dobblego> roconnor: haha, perfect argument if you ask me!
18:35:50 <roconnor> jfischoff: looks interesting
18:35:57 <NemesisD> but for some reason if i just try to use the number i get a type error, can't match expected type NS.PortNumber with actual type GHC.Word.Word16
18:35:58 <roconnor> jfischoff: do you understand it?
18:36:40 <mauke> NemesisD: yes, because your redisPort has the type Word16
18:36:44 <mauke> NemesisD: ... why, actually?
18:36:56 <mauke> can't you use PortNumber?
18:37:05 <jfischoff> roconnor: Honestly I don't know. But I had started to come a similar idea when working on isomorphism between trees. They took much further.
18:37:44 <roconnor> jfischoff: do you know about lambda-mu-mu-tilde-calculus?
18:37:59 <mauke> now you're just making up symbols
18:38:01 <NemesisD> mauke: my cli options parser parses into a word16, redis has data PortId = PortNumber NS.PortNumber
18:38:03 <jfischoff> I can't say that I do
18:38:17 <mauke> NemesisD: fromIntegral
18:38:32 <roconnor> jfischoff: if you like this sort of thing, you might be interested in it.  Let me find a paper
18:38:45 <NemesisD> mauke: there we go!
18:38:46 <jfischoff> please
18:38:59 <NemesisD> mauke: i'm still kind of confused why that number would look entirely different
18:39:09 <mauke> NemesisD: PortNumber is "really" an abstract integer type
18:39:25 <mauke> NemesisD: but for your convenience it exposes its internals, which store the port in network byte order
18:39:38 <NemesisD> ohh
18:39:42 <mauke> and you're running on a little endian machine
18:40:12 <roconnor> jfischoff: http://hal.inria.fr/inria-00156377_v1/
18:41:26 <jfischoff> roconnor: saving it. Are you interested in reversible computation?
18:41:40 <roconnor> jfischoff: very vaguely
18:45:04 <jfischoff> roconnor: I can't tell if that is a yes or no :s
18:45:21 <roconnor> let's say yes for the sake of argument.
18:50:01 <jfischoff> well then you might find this interesting http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.129.2549&rep=rep1&type=pdf
18:54:46 <Luke> anyone able to install hstats with cabal using ghc 7.4.1?
18:55:08 <Luke> I can't seem to get it to install
18:57:43 <byorgey> Luke: looks like it depends on both base and haskell98
18:57:55 <byorgey> but as of ghc 7.2 those are mutually exclusive
18:58:11 <byorgey> (looks like it was last uploaded in 2008 so no wonder it's out of date)
18:58:25 <quest> hey
18:58:49 <byorgey> Luke: however, it may work if you just get it with 'cabal unpack', edit the .cabal file to remove the haskell98 dependency, and fix a few imports
18:58:50 <quest> could you show me any material to leanr how to calculate more "sophisticated" types? like (.)(.)($) ?
18:58:52 <byorgey> hi quest
18:58:54 <quest> i don't get the idea
18:59:39 <Luke> byorgey: thanks
18:59:42 <quest> all materials i got shows how to do that for easy functions
19:00:01 <byorgey> quest: it all comes down to unification
19:00:26 <byorgey> quest: i.e. to take two types and try to match them up
19:00:55 <byorgey> for example, a -> Char  unifies with  [Int] -> b   if a = [Int] and b = Char
19:01:11 <quest> could you show me the step by step for some more sophisticated example?
19:01:15 <quest> let we say :t flip flip
19:01:33 <Luke> byorgey: that was the problem - thanks
19:01:37 <byorgey> I can't really right now, maybe someone else can
19:01:38 <mauke> :t P.flip
19:01:39 <lambdabot> Couldn't find qualified module.
19:01:46 <mauke> :t Prelude.flip
19:01:46 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
19:02:04 <shergill> in the chapter on persistent in the yesod book, the section on 'attributes' talks about how you can assign arbitrary attributes after the first two words for each field. what's the set of valid attributes?
19:03:14 <mauke> (flip :: (a1 -> (b1 -> c1)) -> (b1 -> (a1 -> c1))) (flip :: (a2 -> (b2 -> c2)) -> (b2 -> (a2 -> c2)))
19:03:36 <mauke> a1 -> (b1 -> c1)  =  (a2 -> (b2 -> c2)) -> (b2 -> (a2 -> c2))
19:04:02 <mauke> therefore  a1  =  a2 -> (b2 -> c2)
19:04:15 <mauke> and  b1 -> c1  =  b2 -> (a2 -> c2)
19:04:36 <mauke> therefore  b1  =  b2
19:04:44 <mauke> and  c1  =  a2 -> c2
19:05:37 <jmcarthur> jfischoff: huh, i've just been reading literature on reversible computation that cited some of the same research (although not that exact paper). what's been steering you toward reversible computation?
19:05:40 <quest> why a1  =  a2 -> (b2 -> c2)
19:05:47 <mauke> the result type is  b1 -> (a1 -> c1)  =  b2 -> ((a2 -> (b2 -> c2)) -> (a2 -> c2))
19:05:58 <jfischoff> jmcarthur: laziness :)
19:06:14 <mauke> quest: from A -> B = C -> D we get that A = C and B = D
19:06:35 <jmcarthur> jfischoff: i attended a talk by this guy last thursday and got into it: https://www.cs.indiana.edu/~rpjames/
19:06:36 <quest> eee, wait, i don't see that
19:06:58 <jfischoff> jmcarthur: I think isomorphism are easier to verify. There are a lot reasons
19:07:10 <kallisti> :t flip const
19:07:11 <lambdabot> forall b a. a -> b -> b
19:07:21 <jfischoff> jmcarthur: I have been reading their stuff, it is very cool
19:07:26 <jmcarthur> jfischoff: highly recommend the Information Effects paper and Negative and Fractional Types paper
19:07:50 <jfischoff> jmcarthur: ha I just recommended that to roconnor
19:08:00 <jmcarthur> oh i missed that
19:08:33 <jfischoff> jmcarthur: I'm writing a blog post write now about the semiring they build, and Generalized Arrows
19:08:41 <quest> damn i don't see this unification
19:09:03 <mauke> quest: do you follow the general A -> B = C -> D rule?
19:09:20 <kallisti> I just think about it intuitively. I know that's not very helpful for teaching someone else how to do it though..
19:09:24 * shachaf has been reading "quest: ..." as "... is now our goal"
19:09:31 <Mathnerd314> @src pi
19:09:31 <lambdabot> Source not found. Just try something else.
19:09:41 <jmcarthur> jfischoff: ah, i was thinking about playing around with generalized arrows for this stuff, myself
19:09:47 <kallisti> :t pi
19:09:48 <lambdabot> forall a. (Floating a) => a
19:09:51 * mauke is now known as proof
19:09:54 <kallisti> Mathnerd314: pi is a method of the typeclass Floating.
19:09:55 <jmcarthur> would have been the first time i tried generalized arrows
19:10:01 <quest> or maybe i see :D, please wait, let me do another example but by myself
19:10:12 <kallisti> Mathnerd314: so there isn't one loca for its source code.
19:10:15 <kallisti> *location
19:10:52 <mauke> actually, A -> B = C -> D is just a specific instance of making type constructors line up
19:10:55 <shachaf> quest: "flip id" is probably a bit simpler.
19:11:01 <mauke> it's really (->) A B = (->) C D
19:12:01 <mauke> you need that to do fun stuff like unifying 'm Int' with '[a] -> b'
19:12:14 <jfischoff> jmcarthur: if you play around with Biarrows you end writing some of the function out of necessity in generalized arrows. Which are also the combinators in the \product language
19:12:23 <Mathnerd314> > pi :: CReal
19:12:24 <lambdabot>   3.1415926535897932384626433832795028841972
19:12:51 <kallisti> > last $ showCReal 1000 pi
19:12:52 <lambdabot>   '9'
19:13:03 <kallisti> showCReal lets you specify how many digits you want to see.
19:13:04 <jmcarthur> yeah
19:13:27 <tgeeky> > last $ showCReal (10^9) pi
19:13:32 <lambdabot>   mueval: ExitFailure 1
19:13:32 <lambdabot>  mueval: Prelude.undefined
19:13:35 <tgeeky> > last $ showCReal (10^6) pi
19:13:35 <quest> wait, :t flip = (a -> b -> c) -> b -> a ->c  what is (a -> b -> c) ?
19:13:39 <lambdabot>   mueval-core: Time limit exceeded
19:13:44 <quest> the type of function which flip takes?
19:13:56 <tgeeky> > flip id
19:13:57 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> (a -> b) -> b)
19:13:57 <lambdabot>    arising fro...
19:14:06 <tgeeky> :t flip id
19:14:07 <lambdabot> forall a b. a -> (a -> b) -> b
19:14:10 <mauke> quest: yes
19:14:14 <kallisti> quest: id :: x -> y;   so a = x  and y = b -> c
19:14:43 <shachaf> kallisti: id :: x -> x
19:14:46 <kallisti> er
19:14:46 <kallisti> yes
19:14:58 <shachaf> I thought quest wanted to do this one on their own. :-)
19:15:16 <quest> ok, so now ( a->b->c) from first flip should be unified with the type of the second flip, right?
19:15:29 <kallisti> second flip?
19:15:36 <shachaf> Yes, because that's the argument being given to flip.
19:15:41 <mauke> kallisti: yes, the code in question is 'flip flip'
19:15:47 <quest> kallisti (:t flip flip)
19:15:51 <kallisti> oh nevermind. I thought we were talking about flip id.
19:16:00 <shachaf> If it helps clarify things, you can make up new variables too.
19:16:08 <shachaf> That match up to old variables.
19:16:11 <quest> ok, so:  ( a1 -> b1 -> c1) = :t flip  right?
19:16:24 <mauke> yes
19:17:58 <gwern> @quote
19:17:59 <lambdabot> Wild_Cat says: [on #python] (I mean, if you believe the #haskell denizens, half the financial world uses Haskell)
19:18:11 <shachaf> f1 :: (a -> b -> c) -> b -> a -> c; f2 :: (d -> e -> f) -> e -> d -> f; let W = a->b->c; X = b->a->c; Y = d->e->f; Z = e->d->f; f1 :: W -> X; f2 :: Y -> Z; in "f1 f2", you now know that W = Y -> Z
19:18:18 <shachaf> ...That may have been less helpful than I had hoped.
19:18:24 <mauke> oh god what
19:18:34 <quest> ok, i see this example right now
19:18:43 <quest> now i'm trying to calculate (.)(.) by myself
19:18:46 <shachaf> mauke: It's all so clear while you're writing it down!
19:19:25 <mauke> and then (.)(.)(.)!
19:19:46 <quest> yup, but i stucked at double (.) :/
19:20:05 <shachaf> @ty (Prelude..)
19:20:06 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:20:32 <quest> (.) :: (b1 -> c1) -> (a1 -> b1) -> (a1 -> c1)
19:20:44 <quest> (.) :: (b1 -> c1) -> ((a1 -> b1) -> (a1 -> c1))
19:20:46 <quest> right?
19:20:49 <mauke> yes
19:21:02 <shachaf> Those numbers make it much more difficult for me to think about it.
19:21:10 <quest> what is b1 -> c1 on the left?
19:21:13 <shachaf> d1 :: (b -> c) -> (a -> b) -> a -> c; d2 = (e -> f) -> (d -> e) -> d -> f; (b -> c) = (e -> f) -> (d -> e) -> d -> f
19:21:25 <shachaf> quest: It's the first argument of (.)
19:21:52 <mauke> shachaf: the numbers tell you which copy of (.) they came from :-)
19:22:26 <quest> so now i need to unify ( b1 -> c1) with second (.) ?
19:22:36 <mauke> yes
19:22:54 <shachaf> mauke: That's true, I guess... They still make it more annoying for me.
19:23:07 <quest> b1 = a2 -> b2         c1 = a2 -> c2
19:23:11 <mauke> should be easy; b1 -> c1 is pretty much the genericest function type possible
19:23:30 <mauke> quest: that looks wrong
19:23:35 <shachaf> quest: No, that's not c1. Look at the type of the second (.) again.
19:25:22 <kallisti> I find the more I write down the more confused I get..
19:25:27 <quest> c1 = c ?
19:25:34 <mauke> wait, what is c_
19:25:37 <mauke> wait, what is c_
19:25:39 <mauke> wtf
19:25:53 <quest> c1 = c2, but nevermind, it can't be true
19:26:16 <shachaf> quest: (b1 -> c1) = the type of the second (.)
19:26:22 <shachaf> What's the type of the second (.)?
19:26:55 <quest> ok, c1 = (a2 -> b2) -> a2 -> c2
19:27:15 <quest> right?
19:27:27 <mauke> that looks right
19:27:34 <quest> or wait a moment, let me write it down again
19:29:16 * hackagebot wai-app-file-cgi 0.5.6.2 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.6.2 (KazuYamamoto)
19:29:18 * hackagebot wai-app-file-cgi 0.5.7 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.7 (KazuYamamoto)
19:29:50 <quest> b1 = b2 -> c2   c1 = (a2 -> b2 ) -> a2 -> c2
19:30:11 <quest> ok now?
19:33:56 <kallisti> quest: that looks right to me.
19:34:04 <OODavo> The distinction between functors and monads is that monads have a definition for join :: m (m a) -> ma. I'm finding it difficult, however, to think of a possible functor which /can't/ have join defined, and hence can't also be a monad. Would someone perhaps be able to provide an example of a functor which cannot have join, and thus cannot be a monad?
19:34:24 <mauke> OODavo: don't forget return
19:34:32 <quest> ok, but now what?
19:34:50 <dobblego> OODavo: ZipList
19:34:54 <kallisti> quest: now you substitute things into the type of the first (.)
19:35:02 <kallisti> quest: aka apply the function
19:35:06 <kallisti> :t ($)
19:35:07 <lambdabot> forall a b. (a -> b) -> a -> b
19:35:54 <kallisti> so basically chop off the first argument of the first (.), and then substitute variables.
19:36:40 <quest> ((b2 -> c2) -> (a2 -> b2) -> a2 -> c2) -> (a1 0> b1) -> a1 -> c1
19:37:21 <quest> :t Prelude.flip
19:37:22 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
19:37:30 <quest> :t Prelude.(.)(.)
19:37:30 <lambdabot> Not in scope: data constructor `Prelude'
19:37:37 <quest> :t (.)(.)
19:37:38 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
19:37:48 <mauke> :t (Prelude..) (Prelude..)
19:37:49 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
19:38:02 <quest> it doesn't look the same
19:38:11 <mauke> even modulo alpha equivalence?
19:38:41 <OODavo> To be honest I'm not clear on why join :: ZipList (Ziplist a) -> ZipList a couldn't be defined. :/
19:39:05 <quest> it's not the same
19:40:27 <OODavo> And ZipList already has return defined, since it has pure.
19:40:32 <kallisti> OODavo: if I recall correctly, the problem is that you can't satisfy  join (fmap f m) = m >>= f
19:41:04 <kallisti> a monad is not merely defined by join, but join, fmap, and return.
19:41:18 <kallisti> alternatively, you can define it in terms of >>= and return, as the typeclass does.
19:41:25 <dobblego> OODavo: it won't give ap=(<*>), if you're looking for a structure where it won't type-check, see Accy (essence of the iterator pattern)
19:44:16 * hackagebot ghc-mod 1.10.12 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.12 (KazuYamamoto)
19:45:24 <OODavo> Ah, I see now. Thanks. ^_^
19:49:07 <quest> http://pastebin.com/NQ3WWRJ7
19:49:09 <mauke> The paste NQ3WWRJ7 has been copied to http://hpaste.org/65977
19:49:15 <quest> culd you check please where i'm wrong?
19:53:00 <Modius> Is there anything in haskell or GHC that can be used to suppress memoization?
19:53:12 <mauke> Modius: what memoization?
19:53:48 <Modius> The storage of the evaluated result of some lazy value.
19:55:23 <mauke> why do you want that?
19:55:37 <hpaste> mauke annotated “pastebin.com/NQ3WWRJ7” with “pastebin.com/NQ3WWRJ7 (annotation)” at http://hpaste.org/65977#a65978
19:55:42 * BMeph suspects that some wild-and-crazy XY reasoning is going on here...
19:55:49 <Modius> I have no immediate use, was just looking for understanding.
19:56:26 <mauke> quest: I don't understand what you're doing so I wrote down what I'm doing
19:58:23 <sipa> Modius: lazyness is not exactly the same as memoization
19:58:53 <sipa> Haskell does not really have memoization, but a shared value being used twice will not be evaluated twice
19:58:55 <Modius> sipa: I know; but it's my understanding that, at least by default, haskell onlny evaluates each thunk once/caches the result.
19:59:16 <Modius> sipa:  "Will not be evaluated twice" - am interested if the programmer is given any access to that mechanis.m
20:00:26 <monochrom> actually, GHC normally don't memoize, unless your code strongly suggests to, e.g., "let x = sin y * tan y in x+x" and "(\x -> x+x) (sin y * tan y)"
20:00:51 <quest> i don't understand this: ? (.) (.) :: (a1 -> b1) -> (a1 -> c1)
20:01:02 <gdoteof> can someone take a look at http://hpaste.org/65980 line ~57 and tell me why i am getting Couldn't match expected type `(GamingSession, Player, Table)'
20:01:19 <gdoteof> with with actual type `[t0]'   --sorry for double post
20:01:26 <mauke> quest: we're asking for the type of (.) (.)
20:01:37 <monochrom> if you write "do print (sin y * tan y); print (sin y * tan y)" memoization is unlikely
20:02:14 <mauke> quest: if you have an expression of the form 'f x', then f must have a type of the form 'a -> b', x must have a type that unifies with 'a', and the type of the whole expression is 'b'
20:02:20 <monochrom> if you define "f n = f (n-1) + f(n-1)" you can be sure there is no memoization
20:02:31 <quest> ok, see it now
20:03:14 <quest> and now it works, thanks a lot :)
20:04:53 <gdoteof> i am not sure why 'x' isn't the type i am expecting it to be
20:05:09 <gdoteof> i even use it later as an (x,y,z)
20:05:10 <quest> ok, it seems i understand that, thanks a lot :)
20:05:13 <quest> bye
20:05:56 <mauke> gdoteof: [x : xs] :: [[a]]
20:06:13 <monochrom> replace [x:xs] by (x:xs). haskell is not prolog.
20:06:43 <monochrom> similarly [xs] by (xs) etc
20:07:24 <kallisti> is there anything like read for Text?
20:07:38 <gdoteof> how does one differentiate a tuple from a list of tuples?
20:07:40 <kallisti> or is it just read . T.unpack ?
20:07:52 <kallisti> gdoteof: by their type? I don't understand the question
20:07:58 <mauke> gdoteof: how does one confuse them?
20:08:05 <kallisti> a list of 2-tuples would be [(a,b)]  a 2-tuple has the type (a,b)
20:08:54 <monochrom> that is probably not the real question
20:08:59 <dylukes> I finally got my own domain name ^^.
20:09:17 <mauke> dyluk.es?
20:09:36 <kallisti> gdoteof: are you perhaps getting an expected type vs. actual type error between these two types?
20:09:37 <gdoteof> mauke: this is a good question.  when trying to pattern match the head off something ie func (xs) = ...
20:09:44 <Lemon> yo why is the GHC tarball so huge?
20:09:46 <mauke> gdoteof: that's not a head
20:09:47 <monochrom> hrm, perhaps I could get my own domain name as monoch.ro ? :)
20:09:48 <gdoteof> kallisti: yeah exactly
20:09:58 <Lemon> is there a "lightweight" version anywhere?
20:10:00 <mauke> gdoteof: func (xs) better written as func xs, btw
20:10:09 <kallisti> > let (a,b) = (2,3) in a
20:10:10 <lambdabot>   2
20:10:18 <dylukes> monochrom: I got std.io :D
20:10:19 <kallisti> > let (a:xs) = [1,2,3] in a
20:10:20 <lambdabot>   1
20:10:32 <monochrom> didn't I just said "replace [x:xs] by (x:xs). haskell is not prolog."?
20:10:36 <dylukes> mauke: Nope, see above.
20:10:41 <mauke> preflex: ? .io
20:10:41 <preflex>  Britisch Indian Ocean Territory
20:10:44 <monochrom> tableMeta (x:xs) acc = do
20:10:53 <gdoteof> monochrom: yes i did that.  and it worked
20:11:15 <monochrom> then x is the head and xs is the tail. x is a tuple. xs is a list.
20:11:39 <gdoteof> ok.  so i should always do (x:xs) regardless of whether or not x is a tuple
20:11:44 <dylukes> kallisti:
20:11:49 <kallisti> yes that's irrelevant.
20:11:51 <dylukes> > let (a:xs) = [1,2,3] in xs
20:11:52 <lambdabot>   [2,3]
20:11:55 <gdoteof> gotcha
20:12:15 <kallisti> gdoteof: if you wanted to extract elements from the tuple you could do something like:  ((a,b):xs)
20:12:15 <dylukes> let a:as = [1,2,3] in as
20:12:21 <gdoteof> i was confused, thinking the [] should turn to () because x was a tuple, not because i was just a noob that didn't know the syntax
20:12:26 <dylukes> > let a:as = [1,2,3] in as
20:12:27 <lambdabot>   [2,3]
20:12:27 <kallisti> dylukes: wrong ping
20:12:32 <dylukes> kallisti: indeed
20:12:40 <dylukes> gdoteof: like most of them ,the parentheses are optional.
20:12:45 <dylukes> See above.
20:12:46 <gdoteof> mmk
20:12:52 <gdoteof> now it make sense
20:12:56 <dylukes> : is just an infix constructor
20:13:03 <dylukes> It's identical to saying (if such a thing existed)
20:13:08 <monochrom> no dylukes, "f (x:xs) = ..." parentheses not optional
20:13:12 <dylukes>  let Cons a as = [1,2,3]
20:13:17 <dylukes> oh yes, in a function they're not.
20:13:24 <dylukes> In a let statement they are :P.
20:13:43 <dylukes> > let f x:xs = x in f [1,2,3]
20:13:43 <lambdabot>   <no location info>: Parse error in pattern
20:13:46 <dylukes> indeed.
20:13:47 <monochrom> well why don't we leave let statements for another day? information overload etc
20:13:52 <kallisti> gdoteof: there's no implicit conversion of any sort.
20:14:10 <dylukes> gdoteof: Okay so, do you get how lists are defined?
20:14:21 <dylukes> data List a = Nil | Cons a (List a)
20:14:22 <dylukes> yes?
20:14:32 <dylukes> compare to
20:14:43 <dylukes> data [a] = () | a : [a]
20:14:56 <dylukes> (you can't actually write that, but that's basically what haskell list syntax is)
20:15:18 <dylukes> It's just a special case where we get nice syntax.
20:15:46 <shachaf> dylukes: Other than the () bit.
20:16:10 <dylukes> s/()/[]/
20:16:13 <dylukes> >_<
20:20:21 <lifestream> Not sure if you remember me asking about type signatures a few days ago, but since then I've been reading books and books and books and I still don't understand! I should give up, right? ;{
20:20:26 <gdoteof> dylukes: yes i do, thanks
20:20:41 <dylukes> lifestream: What's your question
20:21:15 <lifestream> I can't really put it into a question, I tried so many times to write an email to haskell-beginners and I can't really put it into words.
20:21:52 <lifestream> But maybe I should do that anyway, post it to haskell-beginners even if it doesn't make much sense.
20:33:51 <BMeph> lifestream: ...and, you could practice by asking some questions here (hint, hint). :)
20:34:10 <Axman6> and we can practice giving you answers
20:34:20 <Axman6> everyone benefits
20:35:24 <lifestream> I think you will faint. My boyfriend is sick of hearing "x is a function that takes a function that... ERROR!BING!BING!!! Brain crash!"
20:36:33 <monochrom> then perhaps you should stick with the type notation and never translate it to words
20:36:55 <shachaf> monochrom++ # words are hard
20:37:01 <monochrom> (a -> b) -> [a] -> [b] is not so bad if you don't read it aloud
20:37:06 <Axman6> lifestream: do you understand the type of id?
20:37:08 <Axman6> :t id
20:37:09 <lambdabot> forall a. a -> a
20:37:18 <lifestream> But I will have to write my own, won't I? If I don't understand what they "say" then how will I understand how to write them?
20:37:57 <Axman6> lifestream: they're not difficult, we'll have you understanding them in half an hour ;)
20:38:01 <shachaf> lifestream: Yes, but you'll rarely need to use words. :-)
20:38:12 <monochrom> I am not convinced. what is your mother tongue? english I presume? or whatever
20:38:16 <lifestream> Axman6: that sure would be nice, Ive read books and tutorials and even watched lectures :)
20:38:44 <lifestream> I'm portuguese but honestly I understand english better
20:38:44 <Axman6> lifestream: so, do you understand what id :: a -> a means?
20:39:05 <monochrom> when you were 3 years old and you were learning your mother tongue, did you ask your mother, "I don't get this language, how do you translate it do my language?"
20:39:17 <lifestream> Axman6: a function that returns its argument?
20:39:33 <lifestream> You know monochrom I made that same joke just yesterday >_>
20:39:50 <Axman6> lifestream: well, that explains what it does, but not what the type means (it doesn't necessarilly have to return its argument, we could return undefined and still have that type)
20:40:07 <shachaf> Axman6: Don't be disgusting.
20:40:09 <monochrom> apparently one can learn a language, even type notation, by using it rather than translating it
20:40:43 <twomashi> Hi
20:40:49 <monochrom> True :: Bool, False :: Bool, you already know that
20:40:56 <lifestream> monochrom: Was thinking of going that route, making a To-do program for myself using topples (Bool, [Char]), Bool is set depending if the task is done or not.
20:41:08 <Axman6> lifestream: so, do you understand that a -> a says that we've got a function that takes something of type a and returns something of type a, where a can be any type (Int, Bool, String etc.)
20:41:25 <monochrom> if I write a function "not True = False; not False = True", then not :: Bool -> Bool
20:41:28 <twomashi> Could anyone tell me how to print the result of the following when called in the ghci console: [System.Random.randomRIO (1,10)]
20:41:54 <Axman6> twomashi: that's almost certainly not what you want
20:42:00 <monochrom> generally, if a function wants parameter type A, return type B, the function's type is A->B
20:42:50 <monochrom> now nothing says A, B can't in turn be function types themselves. it's alright. there is no infinite descent.
20:43:21 <monochrom> "map" happens to be such a function. a special case: map :: (Bool -> Bool) -> ([Bool] -> [Bool])
20:43:41 <lifestream> I guess my problem then, is that I keep thinking "what it does".
20:43:45 <twomashi> Axman6: Correct, that expression specifically is not a part of the solution im working on… but I'm intrested to know how to show it anyway
20:43:47 <monochrom> so it's like map :: A->B, A happens to be (Bool->Bool), etc
20:43:48 * Axman6 thinks teaching someone something without  first discovering to what level they already understrand it is a bad idea
20:43:53 <twomashi> No instance for (Show (IO a0))
20:44:24 <monochrom> so first of all you can write "map not", since not fits the Bool->Bool there in the parameter type of map
20:44:36 <Axman6> lifestream: types for functions just tell you what things you can give to them, not what they do. the implementation is what tells you what they do
20:44:38 <lifestream> Actually mzero gave me some really really harsh examples for my level, and I learned a lot that way... ofcourse, I spent a few hours trying to figure out what the heck it all meant :)
20:45:03 * Axman6 heads to uni
20:45:23 <monochrom> then you notice that "map not :: [Bool]->[Bool]", which can take one more parameter, so you feel free it give one.
20:45:38 <kallisti> what's the name of the extension that lets you derive Typeable?
20:45:44 <monochrom> the new parameter has to be a list, so you can give it like [True, True, False]
20:45:53 <monochrom> DeriveDataTypeable
20:45:55 <lifestream> So I'll just stick my fingers in boiling water everytime I try to think "what it does", hopefully the habit will go away :)
20:46:05 <kallisti> monochrom: ah. I was close. I typed DataDeriveTypeable  :P
20:46:23 <monochrom> it's an abbreviation for "derive Data.Typeable"
20:46:44 <kallisti> ah I see
20:46:54 <monochrom> so now the whole expression is "map not [True, True, False]" and it's type is [Bool]
20:47:07 <monochrom> > map not [True, True, False]
20:47:07 <lambdabot>   [False,False,True]
20:47:19 <monochrom> the answer is indeed of type [Bool]
20:47:29 <kallisti> {-# LANGUAGE GeneralizedNewtypeDeriving, DeriveDataTypeable, TemplateHaskell, OverloadedStrings, NoMonomorphismRestriction,  ExistentialQuantification #-}
20:47:36 <kallisti> Okay this is definitely a Real Haskell Program now.
20:47:42 <lifestream> The whole expression is simply [Bool], makes sense.
20:48:01 <monochrom> it's alright to ask "what does it do". there is no conflict with the type. the type imposes some constraint on what it can do, that's all.
20:48:45 <monochrom> I have been only using this type rule: if f::A->B and x::A, then (f x) :: B.
20:49:31 <monochrom> so for example, if map :: (Bool->Bool)->([Bool]->[Bool]), and not :: Bool->Bool, then (map not) :: [Bool]->[Bool]
20:50:12 <monochrom> do it again: if (map not) :: [Bool]->[Bool] and [True,True,False]::[Bool], then ((map not) [True,True,False]) :: [Bool]
20:50:25 <kallisti> hm, lifting catch into my Monad isn't trivial.
20:50:49 <lifestream> That's pretty simple.
20:51:00 <lifestream> ( monochrom ) :)
20:51:09 <monochrom> and some parentheses can be omitted, so I wrote "map not [True,True,False]". essentially, ((f x) y) = (f x y)
20:51:46 <kallisti> the problem is that catch wants an IO action... so I think I nee to run my Monad.
20:51:50 <kallisti> *need
20:53:11 <kallisti> @hoogle Either b a -> Maybe a
20:53:12 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
20:53:12 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
20:53:12 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
20:53:28 <monochrom> and the type expression can omit some parentheses too. A->(B0->B1) = A->B0->B1, so you can also write "map :: (Bool->Bool) -> [Bool] -> [Bool]"
20:54:16 <monochrom> unfortunately parentheses around A cannot be omitted if A is a compound type
20:55:03 <lifestream> Hold on, let me check something..
20:55:11 <kallisti> does anyone know of a better way of catching IO exceptions within a MonadIO instance other than simply running the Monad as an IO action?
20:56:48 <monochrom> http://hackage.haskell.org/package/monad-control
20:57:26 <monochrom> or perhaps http://hackage.haskell.org/package/lifted-base as it suggests
20:57:32 <Jade_> @type either (\p -> \f -> f p p) (\q -> \f -> q)
20:57:33 <lambdabot> forall a b. Either a b -> (a -> a -> b) -> b
20:57:43 <monochrom> oh nevermind, they're probably complementary
20:57:58 <lifestream> So with filter :: (a -> Bool) -> [a] -> [a] (I think that's correct), it's writen that way because... filter takes a function (that takes an a and returns a Bool), then returns a function that takes a list of as and returns a list of as. Phew.
20:59:23 <Jade_> @type \f -> \(g, h) -> h $ f g
20:59:23 <lambdabot> forall t a b. (t -> a) -> (t, a -> b) -> b
20:59:53 <kallisti> lifestream: yep
21:00:06 <kallisti> -> is left associative. meaning that  a -> b -> c  is the same thing as a -> (b -> c)
21:00:20 <kallisti> er, right associative.
21:00:24 <shachaf> kallisti: To say that it's "left-associative" means the opposite (and isn't true).
21:00:27 <shachaf> Right.
21:00:38 <monochrom> if you know what it does, you see why it cannot have a simpler type. that is usually the psychological unblocker for that type
21:01:42 <kallisti> shachaf: what was a really weird way of wording it..
21:01:45 <monochrom> and yes it's purely psychological. you are capable of reading that type. you just don't want to, suspecting that it is unnecessary to. subconsciously anyway.
21:01:52 <kallisti> shachaf: you could have just said "that's not right"
21:02:08 <kallisti> #haskell-psychoanalysis
21:02:52 <monochrom> there are numerous examples of humans understanding arbitrarily complex things iff they find the complex things useful.
21:03:22 <glguy> and then there are category theorists... ;)
21:04:21 <monochrom> filter has to do this: based on a user-provided criterion, weed out some items in a list and return the rest in a list
21:04:27 <liyang> category terrorists.
21:04:41 <maloi> liyang: i read that too :)
21:04:42 <liyang> (is what I read that as, when I glanced over it.)
21:04:56 <kallisti> lifestream: once you get the hang of, reading and understanding types with similar complexity to filter is cake.
21:04:59 <kallisti> +it
21:05:50 <monochrom> so it needs the criterion. the simplest kind of non-trivial criterion has to have type "a->Bool", so it can take an item and say "True" or "False", so filter knows what to omit
21:06:00 <monochrom> and it needs the original list, of course
21:06:45 <monochrom> so filter's type cannot escape from (a->Bool) -> [a] -> [a] or the other order. it has to take a function parameter. that's the user-provided criterion
21:09:00 <lifestream> So the type of take (I don't want to check in ghci before I figure it out) would be just  take :: a -> [a] -> [a]? Because... it takes an a and returns a function that takes an [a] to [a]? *sweats*
21:09:21 <monochrom> no, that is not what take does
21:09:32 <kallisti> take does not take an a as its first argument
21:09:41 <monochrom> take says: tell me a number, I truncate the list to that length
21:10:04 <lifestream> Right. *scratches head*
21:10:07 <monochrom> for simplicity, the number type is pinned as Int
21:10:23 <lifestream> Oh, as oposed to a.
21:10:37 <kallisti> a, an arbitrary type, has no concept of "length"
21:10:56 <kallisti> so it can't be used as the first argument of take, which needs a length to truncate to.
21:11:44 <lifestream> So that's why sometimes it will say Int, Bool, instead of a, b
21:11:57 <notthemessiah> @list todo
21:11:57 <lambdabot> todo provides: todo todo-add
21:12:03 <kallisti> yes, because sometimes you need to actually know what kind of value you're dealing with.
21:12:10 <kallisti> a type variable says "I don't care what this type is"
21:12:27 <lifestream> I must have read it a million times before, now for once it will stick in my mind ;)
21:13:58 <kallisti> lifestream: if tried to implement take in such a way that its first argument has the type "a", you would soon be scratching your head figuring out how you're supposed to take an arbitrary type and use it to truncate a list to a certain length.
21:14:19 <kallisti> because you have zero information about that value.
21:14:27 <lifestream> Sure, take cookie "cookie jar" =  cookie!
21:14:28 <lifestream> Duh!
21:14:29 <DanBurton> @pl f action = do a <- foo; b <- bar; action a b
21:14:30 <lambdabot> (line 1, column 23):
21:14:30 <lambdabot> unexpected ";"
21:14:30 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
21:14:38 <kallisti> lifestream: yeah okay. :P
21:15:15 <DanBurton> @pl f action = foo >>= \a -> bar >>= \b -> action a b
21:15:15 <lambdabot> f = (foo >>=) . ((bar >>=) .)
21:15:18 <DanBurton> ugh
21:15:55 <shachaf> liftM2 (uncurry action) foo bar?
21:16:07 <DanBurton> :t liftM2 (uncurry action) foo bar
21:16:08 <lambdabot> Not in scope: `action'
21:16:08 <lambdabot> Not in scope: `foo'
21:16:08 <lambdabot> Not in scope: `bar'
21:16:09 <kallisti> lifestream: as an example of what I mean. How many functions do you think satisfy the type  a -> a ?
21:16:19 <DanBurton> :t \action foo bar -> liftM2 (uncurry action) foo bar
21:16:20 <lambdabot> forall a b a2 r (m :: * -> *). (Monad m) => (a -> b -> a2 -> r) -> m (a, b) -> m a2 -> m r
21:16:40 <DanBurton> hrm
21:16:42 <lifestream> kallisti: Hmmm, not many, I would think, unless I misunderstand
21:16:43 <shachaf> kallisti: Are you looking for 1 or 2 or 3 as an answer?
21:16:48 <lifestream> (None?) ^^
21:16:54 <kallisti> shachaf: for simplicity, 1.
21:17:31 <DanBurton> :t let action :: String -> Int -> IO Bool; action = undefined; foo :: IO String; foo = undefined; bar :: IO Int; bar = undefined in liftM2 (uncurry action) foo bar
21:17:32 <lambdabot>     Couldn't match expected type `a2 -> r'
21:17:32 <lambdabot>            against inferred type `IO Bool'
21:17:32 <lambdabot>     In the first argument of `liftM2', namely `(uncurry action)'
21:17:57 <DanBurton> :t let action :: String -> Int -> IO Bool; action = undefined; foo :: IO String; foo = undefined; bar :: IO Int; bar = undefined in join $ liftM2 action foo bar
21:17:58 <lambdabot> IO Bool
21:18:12 <lifestream> kallisti: forgot about the function id mentioned before
21:18:16 <kallisti> lifestream: correct. there's really only one function with this type that actually returns a value.
21:18:27 <kallisti> id x = x
21:18:57 <kallisti> the other cases involve non-termination and undefined behavior (which are semantically equivalent in Haskell)
21:19:12 <DanBurton> hrm is there a well-known name for \f a b -> join (liftM2 f a b) ?
21:19:26 <DanBurton> :t (.:.)
21:19:27 <lambdabot> Not in scope: `.:.'
21:19:31 <kallisti> DanBurton: none that I know of.
21:19:40 <DanBurton> @let (.:.) = (.:) . (.)
21:19:42 <lambdabot>  Defined.
21:19:50 <DanBurton> :t join .:. liftM2
21:19:51 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
21:20:16 * DanBurton is fascinated that .:. can actually be almost useful for this obscure case
21:21:21 <kallisti> DanBurton: someone needs to combine a big list of combinators and make a pointfree library
21:21:28 <lifestream> So I get confused on this a b thing.  With map :: (a -> b) -> [a] -> [b] ... why isn't it (a -> b) -> [a] -> [a]? The list returned is the same type as before, no? map (drop 1) ["life", "stream"]
21:21:35 <kallisti> we could collect data from the countless "is there a shorter way to do X?"  questions on #haskell
21:21:54 <kallisti> lifestream: it does not have the same type as before
21:21:58 <kallisti> it can, but doesn't have to
21:22:14 <ben> lifestream: it's possible that a = b depending on how you use map
21:22:18 <kallisti> because you're applying a function of type a -> b to each element in a list of type [a]
21:22:23 <kallisti> the a's become b's in the result list.
21:22:23 <ben> but it doesn't have to, so they write down the general form
21:22:59 <kallisti> > map length [[1,2,3], [4,5,6], [7,8,9]]
21:23:00 <lambdabot>   [3,3,3]
21:23:12 <kallisti> a = [Int].  b = Int
21:23:38 <lifestream> Gotcha...
21:23:48 <DanBurton> kallisti: it has been done, sort of :)
21:24:06 <DanBurton> not liftM2
21:24:07 <lifestream> I'm going to try to write a few more types, then I think I can finally move on to the next lesson, thanks everyone!
21:24:13 <DanBurton> join .:. liftM2  I mean
21:24:26 <DanBurton> but who was it that wrote that template haskell for crazy pointfree stuff
21:24:48 <ben> @type map length
21:24:49 <lambdabot> forall a. [[a]] -> [Int]
21:25:03 <kallisti> DanBurton: are you talking about the plumbers thing
21:25:07 <kallisti> I have no idea what any of those operators do.
21:26:14 <danharaj> So uh, Oleg and Shan's paper on implicit configurations is pretty cool.
21:26:39 <DanBurton> kallisti: they have a really obvious meaning, except it's totally nonobvious until it is explained to you
21:27:36 <kallisti> DanBurton: documentation would help.
21:28:13 <DanBurton> agree
21:29:27 <kallisti> I guess there wouldn't be a clandestine pointfree cabal if everyone could make their Haskell look like APL.
21:29:56 <kallisti> actually something like J is more appropriate.
21:31:51 * kallisti is pleased to see Perl 6 taking some influence from the APL family.
21:33:45 <Enigmagic> when is Perl 6 coming out?
21:34:08 <kallisti> ba dum tssh.
21:34:16 <Enigmagic> :)
21:34:59 <kallisti> when they finish implementing -- oh wait, wouldn't it could cool if Perl 6 could do THIS...
21:36:01 <kallisti> s/could/be   so many typos. :_(
21:36:20 <Enigmagic> it'll be a few weeks after haskell gains widespread acceptance
21:36:45 <kallisti> undoubtedly.
21:38:23 <kallisti> rest assured that Haskell programmers in high demand, for jobs that require Haskell experience...
21:38:33 <kallisti> I just wish the number of such jobs would increase just slightly.
21:39:42 <ion> > ("It needs to be more like " ++) . (++ " first.") <$> ["Forth", "APL", "Lisp", "Haskell", "Erlang", "C", "INTERCAL"]
21:39:46 <lambdabot>   ["It needs to be more like Forth first.","It needs to be more like APL firs...
21:41:25 <c_wraith> all languages need to be more like intercal
21:42:20 <Enigmagic> i developed a simple haskell interpreter in intercal
21:53:58 <c_wraith> sounds buggy
21:54:20 <ion> But what came out was PHP?
21:54:22 * hackagebot xhb 0.5.2012.3.26 - X Haskell Bindings  http://hackage.haskell.org/package/xhb-0.5.2012.3.26 (AntoineLatter)
21:54:23 <DanBurton> doh that reminds me. I need to work on my System F blog post >,<
21:54:45 <ion> I like to think the “F” in “System F” is a censored word.
21:55:06 <DanBurton> lol
21:55:29 <DanBurton> here's the raw code I'm going to comment up if anyone is interested: https://github.com/DanBurton/system-f/blob/master/SystemF.hs
21:55:51 <mdwrigh2> So, I'm trying to compile gitit using cabal with the latest Haskell Platform, and it fails after it starts linking, only outputting "gitit-0.9 failed during the building phase."
21:56:44 <DanBurton> mdwrigh2: it should say something during compilation of a particular source file about what went wrong
21:56:55 <mdwrigh2> I've turned on verbose (-v3), and still am not getting any real error messages. anyone have any ideas why this is failing? or what I could do to get better error messages?
21:57:11 <DanBurton> @where gitit
21:57:12 <lambdabot> I know nothing about gitit.
21:57:18 <DanBurton> @google haskell gitit
21:57:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gitit
21:57:21 <lambdabot> Title: HackageDB: gitit-0.9
21:58:19 <DanBurton> mdwrigh2: This is probably a good topic for the gitit mailing list https://groups.google.com/forum/?fromgroups#!forum/gitit-discuss
21:59:15 <DanBurton> by default cabal-install will spew out the compilation info for every file it compiles, so if the gitit package isn't doing that then it must be configured weird or something
21:59:26 <DanBurton> that's my guess, anyways
22:01:02 <mdwrigh2> DanBurton: it is spewing out the compilation info, I"m just not getting any errors
22:04:22 * hackagebot yoko 0.3.2.1 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-0.3.2.1 (NicolasFrisby)
22:06:08 <unlink> :t (.:)
22:06:09 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
22:06:31 <mdwrigh2> DanBurton: It turns out Linux's OOM killer was killing it. Doh.
22:10:16 <lispy> yo haskell
22:10:18 <lispy> How's code?
22:10:47 <DanBurton> it's...typed
22:10:49 <lispy> mdwrigh2: ExitFailure 11 indicates the OOM killer got you, in my experience
22:11:02 <lispy> mdwrigh2: as you may guess, 11 correpsonds to segfault
22:13:40 <kallisti> :t forever
22:13:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
22:16:25 <DanBurton> :t liftM unsafeCoerce
22:16:26 <lambdabot> Not in scope: `unsafeCoerce'
22:16:30 <DanBurton> :P
22:17:01 <DanBurton> :t let unsafeCoerce = a -> b; unsafeCoerce = undefined in liftM unsafeCoerce
22:17:02 <lambdabot> parse error on input `->'
22:17:06 <DanBurton> blah
22:17:09 <c_wraith> haha
22:17:11 <DanBurton> :t let unsafeCoerce :: a -> b; unsafeCoerce = undefined in liftM unsafeCoerce
22:17:12 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m b
22:17:29 <c_wraith> that's no different from just unsafeCoerce, though
22:17:34 <DanBurton> true
22:18:12 <DanBurton> it just weirded me out for a minute that `forever' has type m a -> m b
22:18:26 <DanBurton> it seems like cheating
22:18:42 <edwardk> DanBurton: =)
22:18:57 <kallisti> bottom is cheating!
22:19:15 <DanBurton> its return type should be m () to indicate that it has no useful return
22:19:22 * hackagebot integration 0.1 - Fast robust numeric integration via tanh-sinh quadrature  http://hackage.haskell.org/package/integration-0.1 (EdwardKmett)
22:19:26 <kallisti> I'm actually finding that by changing some of my ()'s to a's I can cut down on my void addiction. :P
22:19:30 <edwardk> danburton: that depends. sometimes you need to pass it in a context that needs another type
22:19:48 <DanBurton> edwardk: for example?
22:19:52 <edwardk> I use Void for arguments that aren't there and polymorphic variables for returned results that aren't there
22:20:01 <edwardk> danburton: well, the canonical example is callCC
22:20:14 <edwardk> which really needs a rank-3 type to be done properly
22:20:32 <edwardk> (or to have the type broken up into two parts so it can be properly typed with a rank 1 type
22:21:11 <edwardk> But you can call the current continuation in the middle of a computation that expects ANY other type, and you need that
22:21:54 <kallisti> DanBurton: similarly, undefined should return () to indicate that it has no useful result. ;)
22:22:07 <edwardk> and the fact that its polymorphic in 'a' tells you a lot more than it being ()
22:22:54 <edwardk> [()] could be any of [],[()],[(),()],..
22:23:20 <edwardk> but forall a. [a] is either [] or a list involving undefineds or bottoms
22:23:45 <shachaf> [()] could also involve _|_. :-)
22:23:59 <DanBurton> so it should be m Void then
22:23:59 <edwardk> shachaf: sure. =P
22:24:32 <edwardk> no, i don't like returning Voids from functions, because that makes people map unnecessarily to get the absurdity out
22:24:34 <shachaf> forall a. [a] and [Void] are more or less the same thing.
22:25:00 <edwardk> forall a. [a] ~ [Void], but [Void] requires me to know how to map over [] to get any other list out using absurd
22:25:07 <copumpkin> [forall a. a] ?
22:25:21 <edwardk> copumpkin: oh yeah and there is that ;)
22:25:48 <edwardk> is hackagebot dead?
22:25:56 <copumpkin> [Void] ~ () (ignoring laziness)
22:25:56 <shachaf> 22:19  * hackagebot integration 0.1 - Fast robust numeric integration via tanh-sinh quadrature  http://hackage.haskell.org/package/integration-0.1 (EdwardKmett)
22:26:00 <edwardk> guess not =)
22:26:05 <copumpkin> oooh
22:26:13 <edwardk> ah i was distracted
22:26:24 <kaitocracy> hi I've got a function that should return a (ResourceT IO Response), but if I 'return' in that function I only get a (IO Response)
22:26:33 <kaitocracy> how do I wrap it back up in a ResourceT?
22:26:45 <edwardk> copumpkin: should give you a few significant figures very very cheaply
22:26:46 <copumpkin> oh, I guess they are equal
22:26:47 <DanBurton> @hoogle m a -> t m a
22:26:47 <lambdabot> Control.Monad.Trans.Identity IdentityT :: m a -> IdentityT m a
22:26:47 <lambdabot> Control.Applicative WrapMonad :: m a -> WrappedMonad m a
22:26:47 <lambdabot> Text.Regex.Base.RegexLike AllMatches :: (f b) -> AllMatches f b
22:26:50 <shachaf> kaitocracy: "return" is polymorphic; it should be able to do both.
22:26:59 <edwardk> uses http://en.wikipedia.org/wiki/Tanh-sinh_quadrature
22:27:09 <kaitocracy> shachaf: that's what I thought but it's not working
22:27:15 <shachaf> copumpkin: What, ∀a.[a] and [∀a.a]?
22:27:28 <copumpkin> yeah
22:28:14 <DanBurton> kaitocracy: can you hpaste a little more context?
22:28:32 <kaitocracy> sure
22:29:09 <hpaste> kaitocracy pasted “ResourceT?” at http://hpaste.org/65984
22:29:33 <shachaf> Hmm, GHC isn't very friendly to impredicative types these days.
22:29:48 <kaitocracy> um okay so in line 3, (connection >>= selectStmtTpl) should be type
22:29:53 <kaitocracy> um hold on let me work this out
22:31:44 <kaitocracy> okay in line 3 (connection >>= selectStmtTpl) is IO [Maybe Account]
22:31:48 <kaitocracy> where Account is just a simple record type
22:34:26 <kaitocracy> do I need to lift something or other?
22:35:04 <kallisti> kaitocracy: what do you want the return type of application to be?
22:35:23 <nyingen> so I'm trying to use Vector.Storable to try to marshal some floats from Haskell to a C lib. Is using 'malloc' from Foreign.Marshal.Alloc and then 'poke' from Storable the right way to do this? I get 'no instance for (Storable Vector CFloat)' when I try
22:35:24 <kaitocracy> ResourceT IO Response
22:35:37 <kallisti> kaitocracy: you'll want a liftIO applied to the IO action then.
22:35:52 <kallisti> kaitocracy: also you appear to make no use of output.
22:36:01 <kallisti> I assume you intend to later or left part of the code out?
22:36:28 <kaitocracy> kallisti: oh I do, I just substituted "asdf" in there to see if it would work, "asdf" used to be (toLBS $ show output) where toLBS converted it to a lazy ByteString
22:36:42 <kallisti> ah I see.
22:37:04 <kaitocracy> kallisti: so I think I've gotten the hang of Monads, but I still don't get lifting, are there any good resources for understanding that?
22:37:22 <kallisti> I don't know of any off the top of my head. Real World Haskell might do some liftIO stuff.
22:37:28 <kaitocracy> okay thanks
22:37:35 <kallisti> essentially ResourceT IO is an instance of MonadIO
22:37:53 <kallisti> and MonadIO has a thing called liftIO :: MonadIO m => IO a -> m a
22:38:29 <kallisti> without liftIO, you would have to use the more general lift function. For deeply nested monad stacks, this can quickly get out of hand.
22:38:42 <kaitocracy> oh I see, so I should use liftIO and not lift?
22:38:54 <kallisti> for IO actions, yes.
22:38:57 <kaitocracy> okay thanks
22:39:22 <kallisti> @hoogle lift
22:39:23 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
22:39:23 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
22:39:23 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
22:39:30 <kallisti> hm, nevermind.
22:41:47 <DanBurton> @hoogle MonadTrans t => m a -> t m a
22:41:48 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
22:41:48 <lambdabot> Control.Monad.Trans.Identity IdentityT :: m a -> IdentityT m a
22:41:48 <lambdabot> Control.Applicative WrapMonad :: m a -> WrappedMonad m a
22:42:40 <copumpkin> edwardk: nice tables
22:51:44 <dmwit> ?hoogle MaxPriority
22:51:44 <lambdabot> No results found
22:54:20 <edwardk> copumpkin: heh, well the code to generate them is included
22:54:27 <copumpkin> yeah, I saw :)
22:54:29 <edwardk> copumpkin: but they take about 10 minutes to process
22:54:35 <copumpkin> scary
22:54:47 <edwardk> well, its the round trip in and out of CReal
22:54:55 <edwardk> if i calculate them in Double I lose accuracy
22:56:06 <edwardk> and i pretty much need every bit of mantissa i can get
22:56:08 <copumpkin> ah
22:56:39 <edwardk> since tanh-sinh quadrature uses some pretty tiny weights around the edges
22:57:50 <kallisti> obviously Haskell needs Quadruples.
22:59:08 <copumpkin> ah
22:59:23 * hackagebot xturtle 0.1.9 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.9 (YoshikuniJujo)
22:59:53 <kallisti> shouldn't that be "LOGO-like turtle?"
23:00:04 <edwardk> its just f(x) = tanh (pi /2 * sinh x)    times a 1/2^l level multiplier
23:00:04 <kallisti> I guess it's the same.
23:00:50 <edwardk> rather those are the absiccas, and you need to use AD to calculate the weights
23:01:50 <edwardk> If anyone cares I can add the tan based variable changes to do (0,infinity) improper integrals as well
23:02:37 <edwardk> or the strange (-infinity,infinity) double exponential changes of variables, but those are awkward because you need to know something about the function
23:07:43 <nyingen> how do I marshal an object of type Vector CFloat (from Data.Vector.Storable) to C ? That is, how do I get a 'Ptr (Vector CFloat)' out of it?
23:07:56 <nyingen> I found a mention of this on StackOverflow but the answer used unsafeWith
23:10:51 <kallisti> nyingen: you can use thaw to extract an MVector from the Vector.
23:10:59 <kallisti> the MVector constructor carries a Ptr and a ForeignPtr.
23:11:04 <kallisti> might be useful to you.
23:12:01 <kallisti> nyingen: it does however require a O(n) copy of the Vector. the O(1) version is unsafeThaw, but it requires that the immutable Vector can't be used afterward.
23:13:17 <kallisti> nyingen: oh nevermind that's basically what unsafeWith does, I think.
23:13:17 <edwardk> kallisti: only if you mutate it while you have it as an MVector
23:13:39 <edwardk> kallisti: unsafeThaw to do read only operations is pretty tame
23:13:45 <kallisti> right
23:13:50 <kallisti> unsafeWith is likely similar to using unsafeThaw.
23:13:56 <kallisti> thaw is the safer way to do it.
23:14:25 <kallisti> it sure is bouncy in here.
23:15:31 <nyingen> kallisti: thanks
23:17:28 <nyingen> the name 'storable vector' implied that peek, poke etc should be used, but I guess that's not the case
23:17:54 <kallisti> well, peek and poke is used in the implementation
23:17:57 <kallisti> not in the interface.
23:19:23 <nyingen> this should probably be documented
23:19:57 <kallisti> it kind of is. maybe not spelled out quite in the way you want though.
23:20:11 <nyingen> since the point of Data.Vector.Storable is to marshal to C, the top of the documentation page should discuss this, or have an example
23:20:37 <kallisti> it has other purposes. efficient memory representation of arrays of complex types.
23:20:43 <kallisti> in particular.
23:20:46 <nyingen> sure
23:20:49 <kallisti> it's not necessarily for FFI.
23:21:41 <nyingen> the other thing is the stigma against 'unsafe*'
23:22:03 <nyingen> I initially ignored those functions (unsafeWith etc) because, well, they must be unsafe
23:22:26 <nyingen> but passing immutable data to C seems like a safe operation
23:22:47 <kallisti> heh. really?
23:22:50 <nyingen> though I guess there's no guarantee that C won't modify it in general
23:22:56 <kallisti> if you copy it, yes. that's what thaw does
23:23:05 <kallisti> if you pass it directly, you're at the will of the C code.
23:23:25 <nyingen> er, passing immutable data to C code that only reads the data, seems like a safe operation, though I guess even in that case, it may not be
23:23:26 <kallisti> thus the "unsafe"
23:23:30 <nyingen> right
23:23:35 <kallisti> nyingen: correct. reading is perfectly safe.
23:23:44 <kallisti> "unsafe" means "you should really think about this before using it"
23:23:56 <kallisti> not "you should NEVER use this."  if that were the case it wouldn't be exported for you to use.
23:24:21 <nyingen> A tutorial entitiled "How do I get various Haskell types to C" would be nice
23:24:46 <nyingen> kallisti: right, i see what you mean
23:24:49 <dibblego> the number of people who do think about it, conclude they should use it, when in fact they shouldn't, is quite high in my observations
23:25:02 <dibblego> it's not as simple as saying, "think about it"
23:25:05 <kallisti> there are some FFI resources out there that are pretty good.
23:25:11 <dibblego> it's more like, "know how to think about it"
23:25:13 <kallisti> Real World Haskell has examples of how to convert to C types.
23:25:22 <nyingen> Yeah, I've read it
23:25:50 <nyingen> but when I"m trying to hack up some quick tool or other, I often wish for cookbook-style references
23:26:18 <nyingen> rather than puzzling out how the code has to be written by following haddock breadcrumbs
23:26:36 <kallisti> well FFI isn't necessarily for the faint of heart.
23:27:03 <nyingen> the proliferation of array-like types compounds the problem
23:27:07 <kallisti> in many cases there isn't one universally good way to do it.
23:27:26 <danharaj> edwardk: The latest build of reflection on hackage is GHC-7.2, is there an issue with 7.4?
23:27:45 <kallisti> I assume you've seen this:  http://www.haskell.org/haskellwiki/FFICookBook   it doesn't really cover array types though.
23:27:48 <edwardk> danharaj: let me check
23:28:07 <nyingen> for example, if you use hsndfile to read audio data, you can get Vector objects out of it, but then the FFTW binding requires a type called CArray, and converting between the two is not really discussed anywhere
23:28:24 <edwardk> installed clean for me
23:28:28 <kallisti> CArray is just a pointer.
23:28:30 <kallisti> I believe.
23:28:49 <edwardk> is it just that it didn't bother rebuilding it because it had build successfully?
23:29:05 <danharaj> edwardk: not sure now that I think of it. It installed on my end with no apparent problems too.
23:29:10 <edwardk> k
23:29:19 <kallisti> oh nevermind CArray is something else.
23:29:23 <danharaj> edwardk: So uh, I just read Oleg's paper on this and it kind of scares me :p
23:29:23 <kallisti> I was thinking of CString
23:29:25 <edwardk> i think its just the rare case where it didn't need to be updated after the 7.4.1 release ;)
23:29:36 <edwardk> danharaj: hahahaa its an awesome hack
23:29:48 <edwardk> basically you just have to baby step through the reasoning
23:30:14 <edwardk> you can reify a natural number as a type
23:30:19 <danharaj> edwardk: Phantom types truly are awesome. Now I'm wondering why this hasn't been adapted into an extension for confluent local instances?
23:30:19 <edwardk> and you can reify a list of those as a type
23:30:27 <kallisti> nyingen: it's pretty straightforward to look at both the documentation of CArray and Vector.Storable to figure out what to do. I admit it takes some familiarity with the FFI though.
23:30:34 <edwardk> so you can reify anything storable
23:30:39 <edwardk> and stable pointers are storable
23:30:42 <edwardk> so you can reify anything
23:30:46 <nyingen> kallisti: hopefully someday someone will write a tutorial/cookbook for dealing with the different array types, and how to marshal them (since this is a common need)
23:31:00 <edwardk> plus a little bit of magic to avoid leaking the stable pointers
23:31:04 <danharaj> Which means some level of dependent types because GHC's type system is awesome.
23:31:19 <edwardk> the internals of that package have changed radically over the years to keep up with compiler changes/bugs, but its a very handy package
23:31:53 <kallisti> nyingen: have you figured out the conversion steps
23:31:53 <edwardk> i use it to make monoids out of transition diagrams from a particular regular expression, etc.
23:32:00 <nyingen> kallisti: also, one builds "familiarity with the FFI" by writing programs, and a program that does spectral analysis (read audio data, run FFT) is a good candidate. But then the conversion stuff gets in the way
23:32:09 <nyingen> kallisti: I posted about it on cafe and got answers :)
23:32:10 <kallisti> correct.
23:32:29 <kallisti> nyingen: I had similar "fun" when writing a bindings to a C plugin interface. :>
23:32:33 <nyingen> yeah
23:32:42 <danharaj> edwardk: So is there a kind Prop to be had? :)
23:32:54 <nyingen> I like the haskell FFI, but once you get past simple stuff, it seems like there's not much documentation
23:32:59 <kallisti> nyingen: I actually did enjoy it by the end though. It was just frustrating at times.
23:33:06 <edwardk> danharaj: you mean like a kind-level version of this?
23:33:07 <nyingen> reading other people's code helps sometimes, but not always
23:33:16 <kallisti> the docs are just scattered in multiple places. :P
23:33:20 <nyingen> right
23:33:26 <nyingen> they should be consolidated :)
23:33:41 <danharaj> edwardk: I mean, you can reify types. Can you now reason about them with a kind for propositions?
23:33:50 <kallisti> because Vector is not "built-in" to Haskell like the rest of the FFI is.
23:34:25 <nyingen> "How to Marshal Anything to C"
23:34:47 <edwardk> well, we can reify terms as types, reifying types as a kind is a harder prospect, since you can only lift some of them
23:35:34 <kallisti> for my project I wrote some code to convert linked lists to/from C arrays. it was fairly painless actually.
23:35:34 <danharaj> edwardk: I don't mean reifying types as kinds, but having a kind Prop that ranges over propositions and doing proofs over types.
23:35:42 <kallisti> and that's more work than the Vector to CArray stuff. :P
23:36:00 <edwardk> danharaj: good luck with that ;)
23:36:05 <kallisti> oh and use hsc to convert ADTs to C structs.
23:36:09 <kallisti> that's another thing I did.
23:36:19 <nyingen> yeah, I've done that in a couple of projects
23:36:22 <nyingen> it wasn't too painful
23:36:44 <nyingen> though there were some gotchas with writing the Storable instance
23:38:00 <kallisti> if Q were a MonadIO instance you could write some TH to automatically generate Storable instances from C headers. :D
23:38:13 <edwardk> i do kinda wish we could make explicitly kind indexed type/data families, where you don't supply the type argument, just the kind
23:38:39 <edwardk> so many neat and terrible hacks that would allow
23:39:26 <kallisti> giving TH access to IO would also allow for neat and terrible hacks.
23:40:54 <monochrom> such as playing a movie while you wait for a long compile :)
23:41:05 <kallisti> yes!
23:41:53 <Saizan> TH has access to IO
23:41:59 <monochrom> I also tried putStrLn "please enter stuff to be injected into the code"; s <- getLine; ...
23:42:08 <kallisti> Saizan: oh, indeed it does.
23:42:17 <kallisti> qRunIO :: IO a -> m a
23:43:23 <monochrom> so if you don't know how to implement something, just stub a TH command there, and ask the user to implement it at compile time
23:43:33 <dmwit> kallisti: Huh, but not instance MonadIO m?
23:44:02 <c_wraith> I have some code in a TH splice to error out and tell the user to rebuild a library with different compile flags at one point...
23:44:14 <monochrom> haha
23:44:36 * kallisti gets to work on his Perl to Haskell TH compiler
23:44:56 <DanBurton> o_O
23:45:08 <antonh> TH compiler?
23:45:22 <antonh> what does "TH" stand for?
23:45:26 <kallisti> template Haskell
23:46:17 <kallisti> I meant a TH function to read perl source files and magically create Haskell bindings to them. I guess it would more than likely just be a perl interpreter (and thus TH wouldn't be required..)
23:46:46 <Enigmagic> dmwit: i see it as "qRunIO :: Quasi m => IO a -> m a"
23:47:54 <dmwit> ?hoogle Quasi
23:47:54 <lambdabot> Language.Haskell.TH.Syntax class (Monad m, Functor m) => Quasi m
23:47:54 <lambdabot> Language.Haskell.TH.Quote QuasiQuoter :: (String -> Q Exp) -> (String -> Q Pat) -> (String -> Q Type) -> (String -> Q [Dec]) -> QuasiQuoter
23:47:54 <lambdabot> Language.Haskell.TH.Quote data QuasiQuoter
23:49:02 <dmwit> should be class (MonadIO m, Functor m) => Quasi m IMNSHO
23:49:02 <Enigmagic> where the preferred usage i believe is this one: runIO :: IO a -> Q A -- Defined in `Language.Haskell.TH.Syntax'
23:49:26 <Enigmagic> 'Q a' rather
23:49:47 <dmwit> (and delete qRunIO from the class, obviously)
23:50:37 <dmwit> I guess liftIO doesn't ship with GHC, and that is why they did this.
23:50:57 <dmwit> The fragmentation caused by GHC-core libraries refusing to depend on non-core libraries is a bit frustrating.
23:51:09 <Enigmagic> they do ship with mtl-1
23:51:12 <kaitocracy> is there any way that I can check if an input string x can be read into an integer?
23:51:14 <dmwit> ...but totally understandable in that "how do you bootstrap" way.
23:51:25 <dmwit> kaitocracy: use reads
23:51:48 <dmwit> It's the professional version of read.
23:52:07 <kaitocracy> so I use reads, which gives me a parser for x
23:52:37 <kaitocracy> I can't figure out what to do with that, I (reads x) should give me a String -> [(a, String)]
23:52:38 <kaitocracy> hmm
23:52:55 <dmwit>  No, reads x gives you an [(a, String)]
23:53:09 <dmwit> reads is already String -> [(a, String)]
23:53:13 <kaitocracy> oh
23:53:14 <dmwit> :t reads
23:53:15 <lambdabot> forall a. (Read a) => String -> [(a, String)]
23:53:19 <kaitocracy> got it
23:53:46 <Enigmagic> > reads "1foo" :: [(Int, String)]
23:53:48 <lambdabot>   [(1,"foo")]
23:54:03 <kaitocracy> what is the second part in the tuple?
23:54:20 <|Steve|> The remaining bit?
23:54:40 <kaitocracy> ahh I see
23:57:31 <dmwit> :t [x | (x, "") <- reads "foo"]
23:57:32 <lambdabot> forall a. (Read a) => [a]
