00:00:20 <sanjoyd> Nice way to calculate the cross product of two Sets?
00:00:32 <sanjoyd> Basically (Ord a) => Set a -> Set b -> Set (a, b)
00:03:45 <ChristianS> > [(i,j) | i <- [1,2], j <- [1..4]]
00:03:46 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4)]
00:04:03 <ChristianS> sanjoyd: list comprehension should work fine ^^
00:04:53 <sanjoyd> No, I have to use a Set.  Of course, I can use two folds, but I was wondering if there was a nicer way, especially using something that looks like a list comprehension.
00:05:18 <adit> I think you could do it as an applicative?
00:05:56 <adit> @hoogle Set
00:05:57 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
00:05:57 <lambdabot> Control.OldException setUncaughtExceptionHandler :: (Exception -> IO ()) -> IO ()
00:05:57 <lambdabot> Data.Set module Data.Set
00:06:07 <adit> @hoogle Data.Set
00:06:07 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
00:06:07 <lambdabot> Data.Set module Data.Set
00:06:07 <lambdabot> Data.Set data Set a
00:06:18 <sanjoyd> I don't think Data.Set is an Applicative.
00:06:19 <sanjoyd> Is it?
00:06:24 <sanjoyd> The doc page does not say anything.
00:06:32 <adit> Prelude Data.Set> :info Set
00:06:32 <adit> data Set a
00:06:33 <adit>   = Data.Set.Tip
00:06:33 <adit>   | Data.Set.Bin {-# UNPACK #-} !Data.Set.Size a !(Set a) !(Set a)
00:06:33 <adit>   	-- Defined in Data.Set
00:06:33 <adit> instance Eq a => Eq (Set a) -- Defined in Data.Set
00:06:34 <adit> instance Ord a => Ord (Set a) -- Defined in Data.Set
00:06:34 <adit> instance (Read a, Ord a) => Read (Set a) -- Defined in Data.Set
00:06:34 <adit> instance Show a => Show (Set a) -- Defined in Data.Set
00:06:35 <adit> ugh
00:06:40 <adit> nevermind, it's not :(
00:07:01 <ChristianS> sanjoyd: why not convert the two sets to lists and convert the result back?
00:07:36 <albel727> ("no Applicative" probably stems from the "Set can't be made into Functor" problem)
00:07:39 <sanjoyd> ChristianS: seems wasteful.
00:09:17 <ChristianS> sanjoyd: i doubt it would be more fasteful than a fold, which would basically convert the set into a list anyway
00:09:53 <edwardk> sanjoyd: it can't be applicative
00:10:05 <ivanm> unless you use the rmonad package by heffalump
00:10:12 <ivanm> but that's not technically the *same* Applicative
00:10:22 <edwardk> yeah but you're still going to have a hard time USING (<*>) then ;)
00:10:47 <ChristianS> sanjoyd: my experience is that whenever to try to "outsmart" ghc by manually writing out the things that fromList etc. do automatically, you lose (or more exactly, you win nothing except longer code).
00:10:47 <edwardk> all you'll need is an Ord instance for (a -> b) -- go ahead. I'll wait
00:10:56 <ivanm> oh, yeah :)
00:11:08 <sanjoyd> ChristianS: yeah, probably true.
00:11:12 <ivanm> it's things like that that stopped me from writing Suitable-based versions of all of the Prelude
00:11:22 <ivanm> ChristianS: yeah
00:11:33 <edwardk> well, there is that monomorphization problem that we keep going back and forth over as well =P
00:11:46 <adit> edwardk: why can't it be an applicative?
00:11:57 <augur> edwardk: any good videos on haskell lenses? i want to get an intuitive sense of them
00:12:10 <sanjoyd> adit: <*> needs a Set (a->b)
00:12:10 <edwardk> adit: because it needs to reorder the elements in the list according to an ordering on the result.
00:12:13 <ivanm> adit: because of the Ord constraint
00:12:18 <sanjoyd> And Set needs (Ord (a->b)).
00:12:31 <adit> ah okay
00:12:32 <ivanm> instance Ord (a -> b) where compare _ _ = LT
00:12:32 <ivanm> :p
00:12:52 <edwardk> ignoring (<*>), you run into problems just trying to use fmap
00:12:53 <shachaf> ivanm: Might as well use the Pugs trick: instance Ord (a -> b) where compare = compare `on` addressOf
00:13:09 <edwardk> shachaf: that'll work wonders when the gc moves stuff on you
00:13:12 <ivanm> nah, that sounds a bit undeterministic
00:13:26 <edwardk> shachaf: plus the whole changing answers with every program run problem
00:13:41 <shachaf> edwardk: Or just when you have two equivalent functions...
00:13:43 <sanjoyd> How about hashing the function code?
00:13:43 <edwardk> or under different optimization options
00:13:51 <augur> edwardk: ? :(
00:13:54 <shachaf> edwardk: But Pugs does it!
00:13:58 <ivanm> sanjoyd: you mean the implementation code? that's not kept around to be able to hash it...
00:13:58 * hackagebot universe-th 0.0.0.1 - Construct a Dec the ancestor list.  http://hackage.haskell.org/package/universe-th-0.0.0.1 (JonathanFischoff)
00:14:00 * hackagebot universe-th 0.0.0.2 - Construct a Dec's ancestor list.  http://hackage.haskell.org/package/universe-th-0.0.0.2 (JonathanFischoff)
00:14:05 <edwardk> sanjoyd: not a good idea, because then you disallow huge classes of optimizations
00:14:05 <sanjoyd> ivanm: oh, okay.
00:14:16 <edwardk> i'm not willing to give up orders of magnitude worth of performance to get a bad hack
00:14:23 <edwardk> if you want that, go code in scheme
00:14:33 <edwardk> r5rs says you'll get a nice location code associated with every lambda
00:14:36 <ivanm> sanjoyd: plus, how do you state that (*2) == \ x -> x + x ?
00:14:44 <sanjoyd> Right.
00:14:46 <edwardk> which is awesome, if thats what you want, and its hell if you want to actually do any optimization in your compiler
00:14:55 <albel727> and what about http://article.gmane.org/gmane.comp.lang.haskell.cafe/78052/
00:14:57 <sanjoyd> Is there even a theoretical basis to ordering functions?
00:15:00 <shachaf> @remember edwardk <edwardk> i'm not willing to give up orders of magnitude worth of performance to get a bad hack <edwardk> if you want that, go code in scheme
00:15:00 <lambdabot> I will never forget.
00:15:06 <sanjoyd> I think you can make a poset and stuff.
00:15:09 <ivanm> sanjoyd: I doubt it
00:15:12 <ivanm> not for arbitrary ones
00:15:12 <augur> edwardk: am i on /ignore? :(
00:15:16 <ivanm> if you limit the types, maybe
00:15:17 <sanjoyd> Oh, okay.
00:15:24 <edwardk> augur: no. just don't have any haskell lens references
00:15:26 <ivanm> albel727: that's what rmonad uses
00:15:30 <augur> oh well ok then
00:15:42 <ivanm> well, something like that
00:15:51 <albel727> oh, indeed.
00:16:03 <shachaf> sanjoyd: You can't even check if two functions are equal.
00:16:06 <edwardk> beside, if you were, how would i have been able to see your query to reply? =)
00:16:10 <sanjoyd> shachaf: yeah.
00:16:17 <wagle> hi -- how do you tell emacs to look in ~/.cabal/share/Agda-2.3.0/emacs-mode/ for the agda-mode files?
00:16:40 <ivanm> wagle: add that to the load-path
00:17:07 <wagle> thanks
00:17:10 <ivanm> (add-to-list 'load-path "~/.cabal/.......)
00:17:20 <edwardk> sanjoyd: the problem is Pi_0^2 complete. all you need is an oracle for the halting problem.
00:17:54 <BMeph> augur: I liked ezyang's blarticle. I can't think of any videos on lenses, not even an SPJ one.... :\
00:18:04 <Saizan> wagle: agda-mode setup should have taken care of that
00:18:07 <augur> hah blarticle :)
00:18:17 <edwardk> http://fsl.cs.uiuc.edu/pubs/rosu-2006-icfp.pdf showcases it in the space of stream processing, but consider a function from Int as a stream and you can borrow the tools
00:18:46 <edwardk> augur: have you read roconnor's multi plate paper?
00:18:48 <wagle> Saizan: its didnt set the load-path
00:19:02 <augur> oh btw, edwardk, i think i have a nice little translation of actions (as in lagrangian mechanics) into graphs :D
00:19:06 <augur> edwardk: no, ill check it out
00:19:08 <edwardk> http://arxiv.org/abs/1103.2841
00:20:23 <augur> awesome
00:20:45 <edwardk> you may also find an article by jeremy gibbons based on a preprint of that useful
00:21:36 <edwardk> http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/
00:22:04 <wagle> wotta train-wreck..  the emacs lisp it added to my .emacs file looks for agda-mode instead of agda-mode2
00:22:15 <edwardk> it'll give you some intuition for the costate comonad coalgebra viewpoin
00:23:06 <wagle> no, the error is mine
00:24:58 <augur> i think i shall go play deus ex. thank you edwardk :)
00:29:13 <edwardk> i love it when you reach that magic moment where a tool from domain a can be used on a slightly overlapping problem in domain b, and vice versa. two research topics for the price of one!
00:30:29 <wagle> problem is that its not using my PATH for the macosx emacs application
00:32:10 <ivanm> you have to basically re-define your PATH in emacs unfortunately
00:32:22 <edwardk> realized today hamiltonian monte carlo can be applied to metropolis light transport, and the core implementation of my revision control monad can be used with the mixture of automatic differentiation & HMC that make up the MIT's 'bher' version of MIT-Church to make a cool monad
00:32:29 <ivanm> wagle: e.g. (setenv "PATH"
00:32:29 <ivanm>   (concat
00:32:29 <ivanm>    (getenv "HOME") "/bin" ":"
00:32:29 <ivanm>    (getenv "HOME") "/.cabal/bin" ":"
00:32:29 <ivanm>    (getenv "PATH")
00:32:29 <ivanm>   )
00:32:31 <ivanm> )
00:33:08 <edwardk> besides you can get some neat HaMiLTon puns out of the former
00:34:01 <albel727> speaking of emacs, is there an ide with autocompletion for haskell?
00:34:09 <albel727> </troll>
00:34:11 <edwardk> and the latter makes for a neat way to run probabilistic programs with lots of continuous variables faster
00:34:14 <ivanm> chrisdone's haskell-emacs
00:34:31 <edwardk> albel727: sure, visual studio ;)
00:34:39 <albel727> F#? ))
00:34:55 <Enigmagic> visual haskell
00:34:57 <edwardk> no, marlow implemented a couple of rounds of 'visual haskell'
00:37:11 <shergill> edwardk: are you implementing your own automatic differentiation framework?
00:37:18 <edwardk> shergill: already did that
00:37:30 <edwardk> http://hackage.haskell.org/package/ad-1.3.0.1
00:37:43 <shergill> edwardk: ah cool
00:38:04 <edwardk> handles functions of a couple hundred thousand variables pretty well
00:38:46 <shergill> oh nice, i was wondering about performance/scalability
00:39:12 <shergill> i should follow you on github, you're doing stuff which might come in handy for a couple of projects i have in mind
00:39:17 <edwardk> and does forward/reverse/mixed mode/derivative towers, calculates the minimum number of partials for very high order partial derivatives, etc.
00:40:08 <edwardk> that became really important when i was using it with taylor models
00:41:10 <edwardk> because when you need 24 derivatives, the difference between n^k and (n + k - 1) `choose` k becomes rather significant ;)
00:41:24 <shergill> heh
00:41:53 <augur> :|
00:42:09 <augur> damn cops started shooting at me for no reason. forget that! :|
00:42:38 <edwardk> were you wearing anything that identified you as a linguist? =)
00:42:56 <augur> i was playing deus ex
00:43:03 <edwardk> that'd do it
00:43:09 <augur> XD
00:43:13 <augur> jew sex
00:47:16 <wagle> ivanm: bleh
00:48:12 <ivanm> wagle: either that, or have your PATH set before emacs launches
00:57:47 <wagle> <fsbot> hmm, osxpath is to set environment variables, see http://www.emacswiki.org/emacs/MacOSTweaks#toc13
01:03:31 <Rc43> Hi, guys.
01:03:46 <Rc43> How can I catch exception, which appear not in IO monad?
01:04:04 <Rc43> For example, I get "Exception: No match in record selector ids" in pure code.
01:04:24 <Rc43> I know how to fix it, of course. But  Iwant to prevent all such errors.
01:04:25 <ivanm> you have to catch it in IO
01:04:33 <ivanm> or just use a smarter function
01:04:37 <Rc43> catching is not pure operation?
01:04:57 <ivanm> I'm guessing that you're using a record selector on a data type with multiple constructors
01:04:59 <ivanm> @type catch
01:05:00 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
01:05:05 <ivanm> that's not it...
01:05:07 <Rc43> Hm, ghci throws exception, it isn't pure behaviour, right?
01:05:09 <ivanm> @doc Control.Exception
01:05:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
01:05:19 <Rc43> So I get impure thing in pure calculation.
01:05:26 <ivanm> something like that
01:05:26 <Rc43> Control.Exception is for IO too.
01:05:32 <ivanm> yeah, and that's how you do it
01:05:42 <ivanm> Rc43: the idea is, you're not meant to let things like that happen
01:05:47 <ivanm> you use Maybe, Either, etc.
01:05:51 <Rc43> So only way is to wrap calculation with IO?
01:05:58 <ivanm> that's an error, so it can't be caught purely
01:06:04 <Rc43> ivanm, it isn't my excaption.
01:06:05 <ivanm> Rc43: or avoid that issue in the first place :p
01:06:07 <Rc43> It is buit one.
01:06:10 <ivanm> oh, dodgy library?
01:06:18 <ivanm> bug the author of the library to fix it!
01:06:27 <ivanm> or write a wrapper function to do a Maybe
01:13:19 <Rc43> ivanm, no, not the lib; bug is mine, but to know about it I had to run all functions by hand in ghci, there were no errors in standard work, only sudden hanging.
01:13:35 <Rc43> ivanm, and I just want to know about such things when they appear
01:13:40 <ivanm> I wouldn't expect it to hang...
01:13:50 <Rc43> it is way to use unsafePerformIO just for debugging, lol
01:14:23 <Rc43> ivanm, main work is in other thread, it answers only on network to other app
01:14:39 <ivanm> *don't* use unsafePerformIO unless you know what you're doing!
01:14:42 <Rc43> and this other app (client) hangs up when state of server is inconsistent
01:15:01 <Rc43> ivanm, just for debugging, not for standard run
01:29:06 * hackagebot global-variables 1.0.1.1 - Namespaced, global, and top-level mutable variables without  unsafePerformIO.  http://hackage.haskell.org/package/global-variables-1.0.1.1 (JeanMarieGaillourdet)
01:34:21 <augur> omg
01:34:28 <augur> oh woops, wrong place :D
01:42:54 <zhulikas> @hoogle String -> ByteString
01:42:54 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
01:42:55 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
01:42:55 <lambdabot> Data.String fromString :: IsString a => String -> a
01:43:12 <zhulikas> @hoogle Data.Text -> Data.ByteString
01:43:13 <lambdabot> Parse error:
01:43:13 <lambdabot>   Data.Text -> Data.ByteString
01:43:13 <lambdabot>       ^
01:43:21 <zhulikas> @hoogle Text -> ByteString
01:43:21 <lambdabot> Data.Text.Encoding encodeUtf16BE :: Text -> ByteString
01:43:21 <lambdabot> Data.Text.Lazy.Encoding encodeUtf16BE :: Text -> ByteString
01:43:21 <lambdabot> Data.Text.Encoding encodeUtf16LE :: Text -> ByteString
01:46:11 <zhulikas> @hoogle Char -> Word8
01:46:12 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
01:46:12 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
01:46:12 <lambdabot> Prelude error :: [Char] -> a
01:48:25 <zhulikas> @hoogle a -> Word8
01:48:25 <lambdabot> Prelude id :: a -> a
01:48:25 <lambdabot> Data.Function id :: a -> a
01:48:25 <lambdabot> GHC.Exts breakpoint :: a -> a
01:48:44 <zhulikas> how can I create a dummy strict ByteString easily? :|
01:49:16 <Elemir> ByteString isn't IsString?
01:50:07 <zhulikas> oh yes, it is
01:50:24 <zhulikas> thanks
02:07:17 <Elemir> @type print
02:07:18 <lambdabot> forall a. (Show a) => a -> IO ()
02:08:34 <Elemir> Why not people uses IO in such functions?
02:08:53 <Elemir> Why not "MonadIO m ()" for example?
02:09:44 <Elemir> Writing liftIO is tiresome :(
02:16:06 <James_KL> hello , installing haskell , gives that error x86_64 : http://bitsy.me/img4dy - WTF?
02:19:04 <Elemir> Russian language status???
02:19:59 <Saizan> James_KL: stop spamming
02:24:37 <hiptobecubic> Has anyone gotten tags working with vim? I'm not having any luck with the haskellmode plugin
02:24:54 <hiptobecubic> It makes the tags file, but vim doesn't load any of them.
02:25:00 <Elemir> haskellmode is very-very slow…
02:35:24 <savask> hiptobecubic: If you mean the _ct thing, then it works for me.
02:36:47 <monad> Hi Haskell channel: I have an important FFI question
02:37:16 <monad> Please look at http://hpaste.org/64684: I receive a segmentation fault, if I execute this program
02:37:33 <monad> Maybe there is a problem with allocation, but I have absolutely no idea
02:37:44 <monad> I simply want to return cstrings in this program
02:38:48 <monad> I can claim that the C-part is correct
02:38:58 <monad> so there is a problem with the haskell part
02:39:09 * hackagebot streamed 0.2 - Programmatically edit MIDI event streams via ALSA  http://hackage.haskell.org/package/streamed-0.2 (HenningThielemann)
02:39:11 * hackagebot reactive-balsa 0.0 - Programmatically edit MIDI events via ALSA and reactive-banana  http://hackage.haskell.org/package/reactive-balsa-0.0 (HenningThielemann)
02:49:19 <hiptobecubic> savask, it does? what version of ... stuff? vim/linux/windows? can you hpaste a file that works for sure so i can try?
02:59:42 <btby> When using comma notation for lists specified across many lines, one sometimes sees commas placed at the beginning of the next line (most notably in XMonad configs) - is this convention to simplify the addition of new elements or it serves some other purpose as well?
03:01:48 <Elemir> It's just nice and legible
03:10:10 <hpaste> savask pasted “Test file for hiptobecubic” at http://hpaste.org/64685
03:11:19 <savask> hiptobecubic: Sorry, I was away. I have vim 7.3.154 and last haskellmode plugin, as I remember. I'm on linux, ubuntu. I do _ct on that file, then Ctrl+] on haha and vim jumps to the function definition.
03:11:47 <hiptobecubic> savask, ok thanks
03:16:04 <hiptobecubic> savask, interesting. That works, but TagList.vim doesn't load them :/
03:18:13 <savask> hiptobecubic: Hmm, taglist.vim?
03:18:59 <savask> hiptobecubic: "taglist.vim : Source code browser"? This one?
03:24:14 * hackagebot timeplot 1.0.6 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.6 (EugeneKirpichov)
03:25:21 <alpounet> wow, scoped kind variables now
03:26:33 <Jafet> Boom headshot
03:26:44 <hpaste> timthelion pasted “How can I pass null/none arguments?” at http://hpaste.org/64686
03:27:33 <timthelion> Hello, in my function "if_body (Destination..."  How can I pass arguments of no interest to "if_body (Action"  Do I have to make up random and unused info?
03:27:44 <Jafet> :t undefined
03:27:45 <lambdabot> forall a. a
03:28:24 <timthelion> thank you :)
03:31:04 <rostayob> timthelion: you probably don't want to write function like that (partial)
03:31:16 <timthelion> rostayob: why?
03:31:42 <rostayob> timthelion: well because they're partial, they don't want on all the inputs of that type
03:32:10 <rostayob> wait a sec
03:32:15 <timthelion> And how else should I write a function like that?
03:32:20 <rostayob> ah no I see what you're doing now, sorry
03:32:27 <rostayob> you just want to get an 'Action'
03:32:47 <rostayob> timthelion: be aware of 'undefined' anyways
03:32:49 <rostayob> > undefined
03:32:50 <lambdabot>   *Exception: Prelude.undefined
03:32:51 <hpaste> timthelion annotated “How can I pass null/none arguments?” with “How can I pass null/none arguments? (annotation)” at http://hpaste.org/64686#a64687
03:33:23 <timthelion> rostayob: yes, I just want to see that  it is an action.
03:34:30 <rostayob> timthelion: still, if you need to use undefined in your code something is probably wrong
03:34:58 <rostayob> (the only justified use imho is for typeclass non-functions, e.g. sizeOf)
03:35:47 <timthelion> rostayob: I don't see the problem with it.  How else should I write that code?
03:36:37 <rostayob> timthelion: that code has no context, I don't know.
03:36:48 <rostayob> but ideally you should have actual values to use that functions with
03:37:15 <rostayob> if those functions don't care about most of the data in 'Cell', then you should have another datatype
03:38:24 <rostayob> timthelion: also, those functions are partial, but maybe you're still writing them
03:39:27 <rostayob> or maybe your facing a common problem when interpreting parsed code in Haskell (the AST is untyped)
03:41:15 <timthelion> rostayob: I am simply looking to see if the next cell is an action or not.
03:41:35 <timthelion> and the function is yet to be finished.
03:42:02 <rostayob> timthelion: all I'm saying is that in the end you shouldn't need to use undefined, if you do there's something wrong
03:42:23 <timthelion> rostayob: but you have yet to tell me what is wrong with it.
03:42:41 <rostayob> timthelion: that if something tries to use that undefined the program will crash.
03:43:11 <timthelion> rostayob: yes, but since I'm calling a function that is throwing away those values anyways, then the program cannot crash.
03:43:24 <rostayob> timthelion: yes but the types have no idea about that
03:43:33 <rostayob> if you change that function in the future to use those arguments
03:43:40 <rostayob> and you're still passing undefined
03:43:43 <rostayob> you won't even get a warning
03:44:07 <rostayob> one of the point of Haskell is that "things don't go wrong", or at least go wrong a lot less than in other languages
03:44:28 <timthelion> I know.  But in a program that will never exceede 200 lines of code, I think I can keep track of these things myself.
03:44:52 <rostayob> timthelion: expecially if the program is 200 locs if you need to use undefined something is wrong
03:45:37 <rostayob> I guess that data type is the output of some parser right?
03:46:21 <timthelion> rostayob: The data type Cell is a recursive list.  I read down the list, printing out the contents.  And at one point I have to know if I'm at the end or not, because I need the cell 1 before the end to be different.  That's all I'm doing there.
03:46:32 <timthelion> rostayob: yes, essencially
03:46:54 <rostayob> timthelion: I understand what your function does. I don't understand why you need to use undefined. You should just have values of that type as a result of the parsing.
03:47:05 <rostayob> of course you can use and abuse undefined while debugging
03:47:27 <rostayob> but in the final program 'undefined' shouldn't appear in the source code :P
03:48:50 <hpaste> timthelion pasted “Precompiler” at http://hpaste.org/64688
03:49:25 <timthelion> rostayob: all I'm doing is taking the function cell , and outputing valid, albiet odd looking, haskell code
03:50:06 <rostayob> timthelion: you should use haskell-src for that
03:50:16 <rostayob> and you don't need undefined
03:57:48 <Elemir> Hum. Let I have 'data Obj = forall a b.(Obj a b) => RawFile' a b'
03:58:35 <Elemir> It is equivalent for forall r. (forall a b.(RawFile a b) => a -> b -> r) -> r
04:02:17 <Elemir> O, it seems that I answered on my question when I try to formulate it
04:05:58 <james-ubc> hi, i was going through lyah annd got stuck on this little bit
04:06:04 <james-ubc> i cant tell what's going on at all http://pastebin.com/SSbKieM2
04:06:06 <mauke> The paste SSbKieM2 has been copied to http://hpaste.org/64689
04:09:17 <james-ubc> O.o
04:12:39 <Saizan> james-ubc: at all? there are 3 uses of random with different generators to produce 3 elements of Bool
04:12:59 <james-ubc> yeah, im not getting how the let bindings work
04:13:45 <james-ubc> as in the whole thing just make no sense to me :/
04:14:11 <mauke> do you know amy other programming language?
04:14:15 <mauke> *any
04:14:18 * hackagebot gf 3.3.3 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.3.3 (ThomasHallgren)
04:14:25 <james-ubc> java
04:14:37 <Saizan> "let x = expr in .." defines x to be expr in the scope of ..
04:14:41 <mauke> int x = 42; ...
04:14:46 <mauke> let x = 42 in ...
04:14:56 <Saizan> though instead of a simple variable 'x' you can also have a pattern there
04:15:22 <Saizan> and they work roughly like pattern matching in function definitions
04:15:23 <james-ubc> yeah i dont see how the pattern (firstcoin,  newgen) even appears
04:15:35 <Saizan> > let (a,b) = (1,2) in 1
04:15:36 <lambdabot>   1
04:15:37 <Saizan> > let (a,b) = (1,2) in a
04:15:38 <lambdabot>   1
04:15:45 <janbanan> I have a problem with a function that im not really sure how to solve: http://pastebin.com/tJpNZZ39
04:15:47 <mauke> The paste tJpNZZ39 has been copied to http://hpaste.org/64691
04:15:52 <mauke> > let x = (6, 7) in x
04:15:53 <lambdabot>   (6,7)
04:15:55 <Silvah> > let 5 = 6 in 5
04:15:56 <lambdabot>   5
04:16:05 <mauke> > let x = (6, 7); (a, b) = x in b
04:16:06 <lambdabot>   7
04:16:22 <mauke> > let x = (6, 7); (a, b) = x in (b, a)
04:16:23 <lambdabot>   (7,6)
04:16:25 <Silvah> > let x = y; y = x in x + y
04:16:29 <lambdabot>   mueval-core: Time limit exceeded
04:16:32 <Saizan> (,) is the constructor for pairs, so that's (the) valid pattern for them
04:18:01 <james-ubc> so when you say (a,b) = (1,2)
04:18:10 <james-ubc> does that mean (1,2) = (a,b)?
04:18:18 <james-ubc> aswell
04:18:34 <mauke> binding is directional
04:18:34 <vodik> = is assignment
04:18:40 <mauke> vodik: what
04:18:57 <vodik> well i mean you can't go let 5 = x
04:19:04 <mauke> yes, you can
04:19:07 <vodik> til
04:19:13 <vodik> but i was wondering if he ment ==
04:19:14 <mauke> it just doesn't make sense
04:19:23 <mikeplus64> > let 2 + 2 = 5 in 2 + 2
04:19:24 <lambdabot>   5
04:19:51 <mauke> james-ubc: the left part is always what's being defined
04:19:53 <mikeplus64> > let a = 32; b = 12; (1, 2) = (a, b) in (1, 2)
04:19:54 <lambdabot>   (1,2)
04:20:00 <vodik> mauke: thats just added pattern matching rules to (+), right?
04:20:07 <mauke> james-ubc: the right side is the values it's defined as
04:20:32 <vodik> err mikeplus64 ^
04:20:43 <Saizan> vodik: no, it's defining a new local (+)
04:20:45 <mauke> vodik: "added" is wrong
04:21:12 <vodik> included locally?
04:21:16 <vodik> or still wrong?
04:21:21 <mauke> huh?
04:21:30 <Saizan> > let 2 + 2 = 5 in 1 + 1
04:21:31 <lambdabot>   *Exception: <interactive>:3:4-12: Non-exhaustive patterns in function +
04:21:38 <vodik> okay
04:21:41 <vodik> that answers it for me
04:22:01 <vodik> i was thinking you where futher defining (+), not locally redefining it
04:22:12 <vodik> if that makes sense
04:22:30 <b4> Hello. I am new to Haskell, not entirely to functional programming, and I am wondering if there is an easy way to emulate the ¨key¨ parameter you often see in stdlib functions of other languages
04:22:36 <mauke> > let "hello" + () = ('a', pi) in "hello" + ()
04:22:37 <lambdabot>   ('a',3.141592653589793)
04:22:51 <b4> e.g. sort, but then apply a key
04:23:04 <mauke> "often"?
04:23:25 <b4> yes I see it so often, like, during lunch and then before I go to bed, too
04:23:29 <b4> I just check if they are still there
04:23:35 <sipa> what is "apply a key" ?
04:23:45 <mauke> because I know like a dozen languages and I have no idea what you mean
04:23:58 <mikeplus64> b4: Data.Map?
04:23:59 <b4> http://www.lispworks.com/documentation/lw50/CLHS/Body/f_sort_.htm
04:24:23 <b4> no no much simpler
04:24:29 <b4> wait let me try to rephrase this
04:24:36 <mauke> sortBy (comparing key)
04:25:00 <b4> comparing?
04:25:19 <mauke> > sortBy (comparing length) (words "yes I see it so often, like, during lunch and then before I go to bed, too")
04:25:20 <lambdabot>   ["I","I","it","so","go","to","yes","see","and","too","then","bed,","like,",...
04:25:34 <b4> hey nice, comparing
04:26:06 <mauke> > sortBy (comparing length `mappend` compare) (words "yes I see it so often, like, during lunch and then before I go to bed, too")
04:26:07 <lambdabot>   ["I","I","go","it","so","to","and","see","too","yes","bed,","then","like,",...
04:26:22 <b4> ok so that looks cool, but also pretty sort specific, right?
04:26:27 <mauke> yes
04:26:28 <Silvah> > let x@5 = 6 in x
04:26:29 <lambdabot>   *Exception: <interactive>:3:4-10: Irrefutable pattern failed for pattern (x...
04:26:40 <b4> now I am still getting to grips with haskell, I was just wondering if there is a function that goes like this:
04:28:08 <HasLog> Are the random numbers generated with mkStdGen using a particular seed uncorrelated to those generated with seed+1?
04:28:15 <b4> wrap wrapperf puref
04:29:32 <b4> so when I do, say, (wrap read (* 2)) ¨4¨
04:29:46 <b4> ehhh hmm I think I am still too confused to express myself properly
04:29:59 <mauke> dude, don't you have " on your keyboard?
04:30:07 <sanjoyd> Why can't we have 'where' inside typeclass declarations?
04:30:15 <sanjoyd> Oh, got it.
04:30:16 <b4> this is pidgin magic
04:30:20 <b4> I wish it were different
04:30:20 <sanjoyd> Never mind.
04:30:24 <b4> believe me
04:30:25 <Jafet> HasLog: probably not
04:30:42 <mauke> > flip (.) read (* 2) "4"
04:30:44 <lambdabot>   8
04:30:59 <Jafet> In fact, I'm not sure if the base generator has anything to recommend it
04:31:08 <Jafet> Other than, well, being in base
04:31:21 <b4> ok let me give the lisp equivalent: (defun wrap (wrapf origf) (lambda (&rest r) (apply origf (map wrapf r)))
04:31:54 <b4> *mapcar or map ´list or something
04:32:00 <mauke> in haskell every function takes exactly one argument
04:32:03 <b4> but the idea is clear
04:32:14 <mauke> there are no argument lists
04:32:17 <b4> yes, I understand that
04:32:51 <grandboy> http://xeducation.info/2012/03/blonde-teen-bj-in-a-car-then-beautifully-fucked-in-the-pussy/
04:32:52 <Silvah> Jafet: it's not in base (anymore?).
04:32:55 <janbanan> Someone that can take a look at this problem: http://pastebin.com/tJpNZZ39
04:32:55 <mauke> The paste tJpNZZ39 has been copied to http://hpaste.org/64691
04:32:58 <b4> but if you give an explicit number of arguments it could consider currying
04:33:08 <mauke> the 1-arg case is flip (.)
04:33:15 <mauke> the 2-arg case is on
04:33:16 <b4> ok thanks
04:33:26 <b4> ahhh ok so there are some things like this
04:33:38 <b4> thanks man, it was not easy getting my point accross :P
04:33:50 <mauke> > ((+) `on` read) "2" "3"
04:33:51 <lambdabot>   5
04:33:54 <Jafet> Silvah: there goes the last reason for recommending it!
04:33:57 <b4> yes perfect!
04:34:00 <b4> that is what I meant
04:34:03 <b4> aha
04:34:10 <mauke> @src comparing
04:34:10 <lambdabot> Source not found. Where did you learn to type?
04:34:14 <b4> so now the magical question: is there a constructor for on-like functions?
04:34:15 <mauke> :-(
04:34:20 <b4> so f 2 = on ?
04:34:31 <b4> and f 1 = flip (.) ?
04:34:32 <Jafet> Yes and no.
04:34:32 <mauke> comparing f = compare `on` f
04:34:45 <mauke> b4: what would its type be?
04:34:50 <HasLog> which library is recommended for randoms?
04:35:00 <b4> mauke: not pretty, probably?
04:35:04 <b4> :)
04:35:35 <Jafet> HasLog: one which implements a random number generator that you want.
04:35:53 <Jafet> I would recommend that one
04:36:13 <mikeplus64> System.Random is good
04:36:36 <mikeplus64> I just do randomRIO (min, max)
04:36:57 <b4> anyway, you could generate the type at compile type if the argument to that function is known at that point
04:37:12 <b4> how much freedom do you have with such things?
04:37:20 <tzxn3> I'm not really clear on how the state monad works
04:37:23 <mauke> b4: template haskell
04:37:37 <mauke> sort of like macros
04:37:39 <tzxn3> say I want to keep track of a player's score in a simple quiz, and report it at the end
04:37:44 <b4> boom, perfect
04:37:45 <b4> there we go
04:37:49 <b4> that is what I want
04:37:54 <Jafet> Haha
04:38:03 <Jafet> <mauke> macros <b4> WHEEE
04:38:19 <Jafet> Admission of defeat
04:38:19 <b4> thanks man
04:38:36 <b4> ?
04:38:55 <Jafet> b4: type-class polymorphism is normally used for these things.
04:39:01 <ddarius> "I'm used to macrosso I want those raather than porhaps considering a different way of doing things."
04:39:29 <Jafet> A type class is used to specify a range of types that a function can have.
04:39:41 <tzxn3> what's the most elegant way to do that in Haskell?
04:40:01 <b4> If you guys have more ways in which this can be done, please feel free to share
04:40:04 <b4> do not let me hold you back!
04:40:52 <mauke> > printf "%s %d" "asdf" 42 :: String
04:40:53 <lambdabot>   "asdf 42"
04:40:56 <mikeplus64> tzxn3: you can just have an argument to your quiz "loop" that keeps track of the score
04:41:05 <Jafet> > runState (do { x <- get; put (x + 1); x <- get; return (x + 2); }) 0
04:41:05 <lambdabot>   (3,1)
04:41:16 <b4> ddarius: do you know of a good way to do it?
04:43:14 <b4> Jafet: could I solve that problem with type classes?
04:43:34 <mikeplus64> what problem?
04:43:48 <mauke> mikeplus64: correct!
04:44:03 <b4> a function that acts like so: f 1 = flip (.)      and:    f 2 = on      and so forth.
04:44:28 <mauke> that's not a problem, though
04:44:34 <mauke> that's crazy talk
04:44:56 <b4> come again?
04:44:59 <vodik> b4: you might want to oppeate on a list instead
04:45:02 <Jafet> Well, the best implementation of f is one that ignores the numerical parameter
04:45:17 <b4> Jafet: even better, that would be sweet
04:45:28 <b4> that was what I was looking for in the first place
04:45:40 <Jafet> Okay, now venture forth with this magical kazoo and write it
04:45:59 <b4> ....
04:46:23 <mikeplus64> b4: template haskell or maybe the typeclass hackery used in Text.Printf can do this I believe
04:46:33 <Jafet> Ocarinas are passé.
04:46:50 <mauke> my hair is a bird
04:46:53 <brenda22> http://xeducation.info/2012/03/uk-soccer-fan-with-big-boobs-horny-as-hell/
04:46:53 <brenda22> http://xeducation.info/2012/03/blonde-teen-bj-in-a-car-then-beautifully-fucked-in-the-pussy/
04:46:53 <brenda22> http://xeducation.info/2012/02/bisex-party/
04:46:53 <brenda22> http://xeducation.info/2012/02/my-tight-teens-pussy-is-very-wet-while-big-dicks-fucks-my-asshole/
04:46:53 <brenda22> http://xeducation.info/2012/02/young-lesbians/
04:47:15 <b4> mikeplus64: yeah I am looking into those at the moment
04:47:16 <mauke> wow, they're persistent today
04:47:31 <tzxn3> I'm trying to think about whether I can do anything outside the IO monad
04:47:52 <Jafet> I got out of bed today... without using the IO monad!
04:48:11 --- mode: ChanServ set +o mauke
04:48:11 --- mode: mauke set +q *!*@79.125.*
04:48:56 --- kick: emmy was kicked by mauke (are you a bot?)
04:48:59 <mikeplus64> (Jafet uses iteratees to get out of bed)
04:49:01 <tzxn3> my first attempt at writing it is a mess of IO :(
04:49:45 <Jafet> Iteratees put me to sleep, if anything.
04:49:55 <Elemir> Jafet: You change state of RealWorld so you did it in IO monad
04:50:42 <Jafet> Whatever, the RealWorld has no value.
04:50:56 --- mode: mauke set -o mauke
04:51:11 <obiwahn> has hugs better error messages than ghc?
04:51:15 <ddarius> No.
04:51:20 <mikeplus64> tzxn3: paste code somewhere?
04:51:44 <rostayob> obiwahn: define "better". sometimes they're shorter/clearer
04:51:47 <obiwahn> see hiptobecubic
04:51:53 <Elemir> Control.Monad.Error ← good error messages
04:52:14 <Elemir> Use "ErrorT crap Id", Luke
04:52:24 <KorriX> hello
04:52:43 <KorriX> how to serve statical directory over happstack web-routes ?
04:53:06 <KorriX> i need boomerang combinatior witch pass all the url
04:53:18 <KorriX> i have 	<> "static"    . rStatic
04:53:31 <KorriX> and it does not match to the /static/css/style.css
04:53:55 <KorriX> ( this is simple example, i need it for more complicated thing )
04:54:19 <tzxn3> it's embarrassing
04:59:28 <KorriX> any suggestions ?
04:59:35 <zhulikas> @hoogle forall v. [Filter v] -> [Filter v] -> [Filter v]
04:59:35 <lambdabot> Warning: Unknown type Filter
04:59:36 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
04:59:36 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
05:07:59 <janbanan> Can I do an let within an if-then-else?
05:08:37 <ddarius> A let expression is an expression, you can use it anywhere an expression is expected.
05:08:37 <ivanm> les
05:08:39 <ivanm> *yes
05:08:46 <ivanm> well, a let ... in ...
05:08:57 <ClaudiusMaximus> > if let x = True in x then let r = 4 in r else let p = 65 in p
05:08:58 <lambdabot>   4
05:09:25 <tzxn3> I think my problem is doing the two actions dependent on one condition, within the io monad
05:11:08 <tzxn3> if the player's answer is correct, it should evaluate doQuiz nextquestionnumber (numberofcorrectanswers + 1)
05:13:05 <tzxn3> and also evaluate putStrLn "correct"
05:16:14 <nand`> You may wish to model your game logic inside a State GameState and then just evaluate that in the context of IO in your main function
05:16:20 <nand`> that way the game logic itself doesn't require IO
05:16:49 <nand`> Something like a String -> State GameState String or something?
05:17:24 <tzxn3> haha
05:17:30 <tzxn3> not sure I understand any of that
05:17:57 <Iceland_jack> In Purely Functional Data Structures, Okasaki remarks that “Lazy evaluation can be viewed as a form of self-modification, […]”
05:18:03 <Iceland_jack> How so?
05:18:32 <Iceland_jack> (chapter 3.3, page 21)
05:18:49 <ddarius> You have a thunk representing a delayed computation, and it updates itself to a something that just immediately returns the then evaluated result.
05:19:32 <Iceland_jack> So the ‘updating’ part is self-modification?
05:21:04 <ronankde> how to solve this
05:21:16 <ronankde> $ man cabal No manual entry for cabal See 'man 7 undocumented' for help when manual pages are not available.
05:22:44 <alpounet> Iceland_jack, yeah
05:23:03 <Iceland_jack> Hm I suppose that is strictly true, maybe not the most intuitive way of describing it
05:23:10 <Iceland_jack> thank you :)
05:23:34 <alpounet> Iceland_jack, once the value actually has to be computed, the runtime system computes the value and the "delayed computation" is replaced by something that just returns the computed value
05:23:58 <alpounet> so that if other parts were pointing to that thunk, they'll also benefit from that computation
05:24:46 <Iceland_jack> It's actually the realization of that thunk that is a form of self-modification?
05:25:40 <Elemir> http://www.mail-archive.com/haskell-cafe@haskell.org/msg22126.html ← I have same question
05:25:57 <alpounet> well, once the actual value has been computed, it modifies itself to replace the way ddarius described it
05:26:20 <Iceland_jack> Right :)
05:26:39 <Iceland_jack> have to run, thanks for the help
05:27:58 <Elemir> It must works! But it doesn't in my ghc 7.2.2 :(
05:33:44 <berksgra> hi, how do you get permission to post to the mailing list for haskell_cafe, emailed the owners but no response.
05:37:00 <Cale> berksgra: as far as I know, you just sign up for the mailing list and then send messages to it
05:37:19 <Cale> berksgra: http://www.haskell.org/mailman/listinfo/haskell-cafe -- sign up here
05:37:27 <berksgra> ah ok will try - thanks
05:39:13 <maloi> Cale: is bloodknight coming anytime soon? :)
05:40:53 <mercury^> Is that the game Cale is working on?
05:41:01 <Cale> maloi: I hope so! I've been working on the performance of the FRP system for the last couple of weeks. There are still a good number of opportunities for improvement to be made.
05:41:07 <mercury^> Link?
05:41:17 <Cale> There's not much to link to at the moment :)
05:41:28 <Cale> http://ipwnstudios.com/ -- this is the company page
05:41:36 <albel727> ipwn, lol
05:41:43 <mercury^> Will one need an iphone to play it?
05:41:50 <maloi> Cale: nice, looking forward to it :)
05:41:59 <Cale> mercury^: initially. We also hope to do a release for Android at some point.
05:42:54 <mercury^> Can one play it without touchscreen and on a ‘regular’ platform, such as GNU/Linux on amd64?
05:43:24 <mercury^> Or rather, will we be able to do that. :)
05:43:35 <mercury^> I suppose that _you_ can. :P
05:44:16 <Cale> Yeah, we test the game on Linux, but the controls are intended for multitouch. I'm not sure about any plans to release a desktop version. Personally, I think that would be kinda cool. We would need to get the artists to cook up higher resolution art. :)
05:51:14 <alpounet> Cale, so you're also working on ghc-on-android?
05:51:54 <ddarius> Usually artists work at a higher resolution then downsample.
05:53:24 <maloi> often it's much more work to do for e.g. high-res 3d models
05:53:27 <Cale> ddarius: yeah, but there's not a whole lot of point in really refining the hell out of things which are going to be downsampled onto a tiny model that's maybe 70 pixels tall :)
05:54:18 <Cale> You end up with a lot of crude brushstrokes that'd need to be cleaned up for a higher resolution version
05:55:52 <Cale> alpounet: We're not actively working on getting Android support working specifically right now, but there's some general cross-compiling machinery which Stephen Blackheath has done which is applicable to it, and that's going into ghc 7.6
05:57:30 <alpounet> neat!
05:57:45 <Jafet> Is it a bad thing that bloodknight reminds me of bloodrayne
05:57:59 <alpounet> Cale, so you're also kind of binding to the Android graphics library too, right?
05:59:38 <rostayob> Cale: is it? that's cool
05:59:57 <Cale> alpounet: We haven't done anything Android specific
06:00:30 <Cale> alpounet: but we'll probably do whatever's required to get OpenGL ES working there.
06:00:49 <rostayob> Cale: doesn't the iPhone compiling work with -fvia-C? or is it LLVM now/
06:01:02 <Cale> It's LLVM now, from what I understand :)
06:01:14 <alpounet> Cale, ok, that's great!
06:03:27 <rostayob> Cale: well this is great, is there any preview somewhere?
06:05:03 <Cale> rostayob: of the GHC cross compiling support? I *think* it's supposed to be in HEAD now
06:05:36 <exFalso> hi, can you suggest a good graphics library for haskell? (like a nice opengl wrapper or sg)
06:06:18 <framee> Hello, any pandoc veterans present here?
06:06:28 <Jafet> Having to wrap OpenGL places some tight bounds on how nice a library can be.
06:06:37 <Cale> exFalso: Well, it depends on what you're doing...
06:07:00 <rostayob> exFalso: gloss
06:07:02 <Cale> If you just want to quickly get some simple graphics and animation on the screen, gloss is nice to play around with
06:07:22 <exFalso> thanks, gloss it is:)
06:07:24 <rostayob> exFalso: if it's for the ludic thing, gloss.
06:07:30 <Cale> (But it probably will only take you so far for serious things)
06:07:31 <exFalso> rostayob: yeah
06:07:38 <rostayob> exFalso: can we do it with Haskell?
06:07:57 <exFalso> rostayob: we'll see :D
06:08:38 <rostayob> I'd rather not risk it, whatever
06:11:42 <rwbarton> @faq can Haskell do "the ludic thing"?
06:11:43 <lambdabot> The answer is: Yes! Haskell can do that.
06:12:04 <framee> raise your hand if you ever converted a markdown file directly into pdf using pandoc and latex
06:12:24 <rostayob> framee: I think I did
06:12:45 <exFalso> and the hundreds of raised hands go unnoticed
06:12:46 <framee> really? mind to help me out on a question?
06:13:27 <framee> i hope it was not meant in an ironic way
06:13:56 <rostayob> framee: just ask :)
06:14:01 <rostayob> asking to ask is not that useful
06:14:02 <framee> http://johnmacfarlane.net/pandoc/demos.html   <- example nr. 13 wont work for me
06:14:16 <rostayob> framee: what error do you get
06:14:18 <framee> although i have texlive-full installed
06:14:51 <framee> it creates a file ending on .pdf but it is a html file
06:15:12 <rostayob> framee: maybe specify the type explcitly?
06:15:37 <framee> there is no -t pdf or similiar
06:16:02 <rostayob> framee: really? I remember something like that, wait let me install pandoc
06:16:46 <rostayob> framee: btw, did you try to convert to .tex and then pdf manually?
06:17:12 <framee> if i try to set the latex engine manually via the --latex-engine switch it gives me an error
06:17:23 <rostayob> framee: ...which error?
06:17:41 <framee> pandoc: unrecognized option `--latex-program=/usr/bin/pdflatex'
06:17:46 <framee> aeh wrong
06:17:52 <framee> pandoc: unrecognized option `--latex-engine=/usr/bin/pdflatex'
06:17:54 <framee> this one
06:18:42 <framee> i assume there is sth. wrong with the latexpdf enginerecognition in general
06:18:49 <framee> yes i tried to convert manually
06:18:52 <framee> it works fine
06:19:01 <Cale> Apparently --latex-engine expects pdflatex lualatex or xelatex as a parameter
06:19:04 <Cale> not a file path
06:19:17 <framee> i tried pdflatex aswell
06:19:22 <Cale> and the default is pdflatex anyway
06:19:36 <framee> and the path
06:19:46 <Cale> oh, er, the user's guide actually does say it's okay to give a file path, nevermind
06:19:50 <framee> also luatex and xelatex, same error
06:20:10 <alpounet> framee, i guess you checked that you indeed have a /usr/bin/pdflatex binary
06:20:13 <donri> would it be wrong to call -> "to"?
06:20:36 <alpounet> donri, in types?
06:20:40 <framee> I am on texlive-full
06:20:48 <framee> which pdflatex gave me that path
06:20:48 <maloi> dunno but spj says to in talks i've seen
06:20:54 <donri> yes, the function constructor
06:21:10 <Cale> Okay, one sec, let me cabal install pandoc
06:21:25 <rostayob> donri: call it "implies" if you want to piss logicians off
06:21:35 <alpounet> donri, don't see any reason why that'd be wrong
06:21:41 <ChristianS> framee: earlier versions of pandoc contained a specific markdown2pdf command to be used for PDF generation. maybe that's still the case with your version?
06:21:43 <maloi> rostayob: :D
06:21:43 <brill> framee: Example works fine for me. I'm on Debian Squeeze.
06:22:11 <framee> I read that, too and wondered what version they meant
06:22:21 <framee> I installed pandoc yesterday
06:22:28 <framee> I am on ubuntu
06:22:29 <rostayob> framee: yep, the example works for me as well
06:22:34 <framee> hmm
06:22:42 <Cale> framee: and you installed some Ubuntu package for it?
06:22:45 <rostayob> pandoc 1.9.1.1
06:22:46 <framee> mind telling me, what tex environment you use?
06:23:04 <framee> 1.8.1.1
06:23:10 <brill> framee: Texlive standard deb.
06:23:11 <rostayob> framee: I've got the full texlive. the problem is most likely that you have ubuntu's old pandoc version
06:23:21 <framee> i don't know how to get the most recent one
06:23:27 <framee> i used apt-get install
06:23:29 <Cale> cabal install pandoc
06:23:34 <framee> and cabal afterwards
06:23:41 <rostayob> framee: you can just use the current one
06:23:45 <Cale> uninstall the ubuntu one
06:23:52 <brill> framee: I used cabal install also.
06:23:52 <rostayob> but you have to find the documentation somewhere
06:24:01 <framee> i don't know if there  are two installations now that interfere
06:24:09 <ChristianS> framee: does  which markdown2pdf  find anything? if yes, you could just try that (or else cabal install the latest version).
06:24:13 <framee> i am still too new to linux
06:24:13 <Cale> which pandoc
06:24:29 <framee> yes
06:24:30 <rostayob> framee: if you're using ubuntu haskell packages, adding cabal packages will result in a mess
06:24:36 <framee> points to /user/bin/mar...
06:24:59 <framee> I imagined sth like this
06:24:59 <rostayob> framee: I suggest to use the current pandoc version and find out how it works :P
06:25:16 <Cale> cabal install will install by default to ~/.cabal/bin
06:25:22 <framee> should i apt-get purge and reinstall cabal?
06:25:34 <Cale> so you should find a pandoc binary there which you can try running
06:25:50 <framee> because i don't know how to get to 1.9
06:26:00 <Cale> try:  ~/.cabal/bin/pandoc README -o example13.pdf
06:26:06 <framee> k
06:26:14 <Cale> If you cabal installed it, you should have gotten 1.9.1.1
06:26:32 <Cale> but it's probably running the system one unless ~/.cabal/bin is at the start of your path
06:26:42 <brill> framee: I'm using 1.9.1 from doing cabal install.
06:27:25 <brill> framee: Sorry. 1.9.1.1. Check.
06:27:56 <framee> yeah!
06:27:58 <framee> it worked
06:28:00 <framee> you rock
06:28:14 <framee> ty very much
06:28:21 <Cale> no problem
06:28:31 <framee> any idea how i call ~/.cabal/bin/pandoc when i just type pandoc?
06:28:42 <brill> Do the change in .bashrc
06:28:45 <alpounet> put ~/.cabal/bin at the start of your PATH
06:28:50 <brill> Or .profile
06:28:52 <Cale> You need to add that directory to your PATH environment variable
06:28:56 <brill> Yep.
06:29:04 <HasLog> in case an exception occurs can I let ghc specify in which function it occurred, without having to place breakpoints or go step by step
06:29:10 <alpounet> it must come before /usr/bin, /usr/local/bin or w/e
06:29:17 <Cale> What I do is actually just to add ~/bin to my path, and then make ~/.cabal/bin a symlink to there
06:29:19 <framee> ok I think I can get along with this
06:29:25 <hpc> you can also cabal install pandoc --global, if you want it to be usable by other users
06:29:44 <framee> k I'll do that
06:35:11 <ddarius> @google girard ludics
06:35:14 <lambdabot> http://en.wikipedia.org/wiki/Ludics
06:38:53 <Cale> I have a really hard time figuring out if Girard is just pulling everyone's leg :)
06:39:23 <Cale> The paper certainly makes it look like the most complicated joke ever told :)
06:52:51 <quuuux> hi #haskell. Does anyone have an opinion on how far is too far wrt dependency cycles and SOURCE imports? I'm in a bit of a bind with having to decide between a 7-module cycle, or a single monster module with lots of disparate stuff in it
06:54:03 <Cale> quuuux: that's quite a cycle...
06:54:18 <Cale> quuuux: does the usual trick of separating the type declarations into another module not help?
06:57:46 <quuuux> Cale: not a lot. It's quite a few disparate-ish types
06:58:24 <quuuux> Cale: the context here is it's for a MUD kernel, and there are a lot of dependencies on the Player and GameState types
07:00:27 <quuuux> also cleaving types from their functions doesn't seem like a huge improvement in structure over a monster module
07:01:26 <Cale> quuuux: Well, often cycles come about because of modules which depend on the same set of types
07:01:39 <Cale> (mutual recursion in functions is a bit less common)
07:05:59 <quuuux> Cale: most of it is types, yes. I'm just not sure that splitting types away from their operations would be a win in terms of code structure (versus the giant cycle option or a mega-module)
07:10:22 <ChristianS> quuuux: both giant cycle and mega-module sound bad, so i would suppose that any other option will be better.
07:21:38 * ddarius <3 SPJ.
07:25:08 <ciaranm> before he turned to the dark side, and then the even darker side?
07:25:46 <Cale> ciaranm: ?
07:25:54 <hpc> http://www.mentallyjumbled.com/wp-content/uploads/2010/10/Darth-Vader-Made-You-Some-Toast.jpg
07:25:57 <hpc> ^ relevant
07:26:17 <ciaranm> the only thing worse than microsoft is politics!
07:26:24 <jmcarthur> what is this, -blah?
07:26:42 <hpc> jmcarthur: in -blah they talk about haskell :P
07:27:21 <jmcarthur> heh
07:30:14 <Cale> Microsoft : MSR :: Xerox : Xerox PARC
07:30:45 <alpounet> what's that a : b :: c : d thing ?
07:30:57 <hpc> Microsoft : MSR :: Oracle : the stuff they bought from Sun
07:30:58 <hpc> :D
07:31:13 <hpc> alpounet: "a is to b as c is to d"
07:31:27 <alpounet> oh, thanks
07:31:36 <hpc> one of the many useless things they teach in US high school english
07:32:46 <alpounet> hah, i've only seen it this week
07:37:22 <bgamari> Are there any regex implementations on Data.Text?
07:38:53 <ion> I’ve noticed http://hackage.haskell.org/packages/archive/text-icu/0.6.3.4/doc/html/Data-Text-ICU-Regex.html in the past, but it uses IO all over the place.
07:39:50 <ion> The entire text-icu API seems horrible. :-P I looked at it for charset conversions earlier; it doesn’t seem to have any way to get an indication of conversion failures.
07:40:21 <hpc> bgamari: i wonder if you could make one with parsec :P
07:46:05 <t7> 1 module down, 9 more to go
07:46:09 <t7> this weekend is gonna suck
07:46:16 <t7> fuck you windows server
07:49:17 <hpc> t7: compiling or refactoring? :P
07:49:38 * hackagebot KMP 0.1 - KnuthMorrisPratt string searching algorithm  http://hackage.haskell.org/package/KMP-0.1 (CindyLinz)
07:49:40 <t7> training :( 'planning and implementing windows server 2008'. got my exam on monday
07:49:54 <hpc> ouch
07:50:48 <zerax> Sounds longish, they could probably write a 600 question exam on just active directory
07:51:03 <t7> you should see the size of the book
07:52:43 <zerax> I can imagine
07:54:11 <MaskRay> CindyLinz: sorry, but is it really KMP instead of MP
07:56:33 <MaskRay> CindyLinz: KMP should be  pi[i] = max{k | a[0..k] == a[i-k..i] && a[k] != a[i]} while the MP version does not impose the `a[k]!=a[i]' limitation
08:14:44 <sm> morning all
08:15:35 <applicative> mornin', sm.
08:17:03 <exFalso> hi, i think i found a bug in ghc (panic) and i'd like to report it bug i cant register on ghc's Trac, can someone else send a report?
08:17:15 <exFalso> *but:)
08:19:10 <exFalso> i should be asking that on #ghc really...
08:20:27 <Saizan> exFalso: you can login with guest/guest
08:21:05 <exFalso> Saizan: thank you!
08:23:52 <Cale> exFalso: Out of interest, how'd you make it happen?
08:24:07 <Cale> (I know at least one panic in 7.4.1 which is really annoying)
08:24:25 * ddarius suspects that there are many panic inducing situations in GHC 7.4.1
08:25:12 <exFalso> Cale: it happens when you try to export a non-nullary promoted type synonym
08:25:41 <exFalso> (with -XDataKinds)
08:25:57 <Cale> Yeah, it seems like 7.2.x and 7.4.1 have been moving in the direction of less stability. I hope they take the next version or two and really shore up the features that are already there :)
08:26:25 <Cale> (as much as I hunger for ever more type system features...)
08:26:31 <exFalso> :D
08:26:40 <exFalso> promoted types are awesome
08:26:54 <confab> :t .:
08:26:55 <lambdabot> parse error on input `.:'
08:27:05 <Cale> :t (.:)
08:27:06 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
08:27:08 <confab> ah
08:27:11 <confab> thanks
08:27:23 <ronankde> How can I convert a Int to a Float? fromInt does not seem to work (ghc 7.0.3)
08:27:28 <Cale> fromIntegral
08:27:56 <Cale> fromInt was from some versions of Haskell prior to 1998 :)
08:28:11 <Cale> I'm not even quite sure when it was removed.
08:28:15 <maloi> why 1 ⊑ 2 does not hold? (with a ⊑ b meaning that either b is more defined than a or both are equal)
08:28:31 <Cale> maloi: Because 1 and 2 are both completely defined and not equal
08:29:11 <ronankde> but
08:29:12 <Cale> a <= b in this ordering when b can be obtained from a by replacing occurrences of bottom in the structure of a with other values
08:29:28 <ronankde> fromIntegral 122
08:29:35 <ronankde> out > 122
08:29:39 * hackagebot haddock 2.10.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.10.0 (DavidWaern)
08:29:46 <maloi> ahh (and so have the same definedness) made me thin k that equal mean having same definedness
08:29:53 <Cale> fromIntegral will convert from any integer-like type to any numeric type you ask for
08:30:17 <maloi> thanks
08:30:23 <Cale> and the default numeric types which will be tried in case of ambiguity are Integer and Double, in that order
08:30:42 <Cale> So if Integer is acceptable (as it is at the ghci prompt), that's what you'll get
08:31:06 <Cale> By simply applying an operation which requires a floating point number, or giving an explicit type signature, you'll get Double instead
08:31:13 <Cale> (or Float, if you prefer)
08:31:23 <Cale> > fromIntegral (122 :: Int) :: Float
08:31:24 <lambdabot>   122.0
08:31:36 <Cale> > sqrt (fromIntegral (122 :: Int))
08:31:37 <lambdabot>   11.045361017187261
08:31:37 <ronankde> hum
08:31:49 <Cale> > sqrt (fromIntegral (122 :: Int)) :: Float
08:31:50 <lambdabot>   11.045361
08:32:02 <Elemir> lol
08:32:58 <Cale> In a real program, you don't tend to bump into ambiguous numeric types very much
08:32:58 <ronankde> and pi does not work
08:32:59 <t7> > (255 :: Word8) + 1
08:33:00 <lambdabot>   0
08:33:14 <Cale> because you'll have top-level type signatures for things which will pin it down
08:33:27 <Cale> ronankde: doesn't work how?
08:33:31 <Cale> > pi
08:33:32 <lambdabot>   3.141592653589793
08:33:35 <Cale> > pi :: Float
08:33:36 <lambdabot>   3.1415927
08:33:41 <Cale> > pi :: CReal
08:33:42 <lambdabot>   3.1415926535897932384626433832795028841972
08:33:46 <Cale> > pi :: Complex Double
08:33:47 <lambdabot>   3.141592653589793 :+ 0.0
08:34:07 <Cale> > pi :: Integer -- this won't work
08:34:08 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
08:34:09 <lambdabot>    arising fr...
08:34:39 <t7> > prime
08:34:39 <otters> > pi :: Complex CReal
08:34:39 <lambdabot>   Not in scope: `prime'
08:34:40 <lambdabot>   can't find file: L.hs
08:34:48 <ion> > exp (pi * sqrt (-1)) + 1 :: Complex CReal
08:34:49 <lambdabot>   0.0 :+ 0.0
08:35:06 <Cale> lol, I wonder why lambdabot has started having problems recently with people making requests at the same time
08:35:17 <Cale> There seems to be some kind of race condition involving L.hs
08:35:29 <ronankde> i understand
08:35:33 <ronankde> this is error
08:35:54 <ronankde> It could refer to either `Prelude.pi', imported from Prelude  or `UI.HSCurses.Curses.pi', imported from UI.HSCurses.Curses
08:35:58 <Cale> oh!
08:35:59 <Cale> haha
08:36:29 <Cale> Well, if you don't need the one from HSCurses, you can  import UI.HSCurses.Curses hiding (pi)
08:36:39 <ion> or use a qualified import.
08:37:17 <ronankde> Thank you
08:37:36 <zhulikas> @hoogle (a -> m (a, b)) -> [a]
08:37:38 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
08:37:45 <zhulikas> I wonder how can I do something like this
08:38:20 <Cale> :t unfoldM
08:38:21 <lambdabot> Not in scope: `unfoldM'
08:38:25 <Cale> hmm :)
08:38:58 <zhulikas> I end up having (a -> (a, m b)) -> [a]
08:39:02 <zhulikas> which is bad
08:39:11 <zhulikas> hmm
08:39:21 <zhulikas> @hoogle (m a, m b) -> m (a, b)
08:39:22 <lambdabot> No results found
08:39:29 <Cale> you can't get [a] as the result
08:39:30 <zhulikas> that could work if I just return on a
08:39:36 <Cale> You'll need to accept m [a]
08:39:37 <zhulikas> woops
08:39:40 <zhulikas> that's not the result
08:40:10 <Cale> or m [b], more likely
08:40:11 <zhulikas> @hoogle (a -> m (a, b)) -> [a] -> m [(a, b)]
08:40:11 <lambdabot> No results found
08:40:21 <Cale> oh, that's just mapM
08:40:22 <zhulikas> I need that
08:40:28 <zhulikas> well, mapM doesn't quite work
08:40:29 <Cale> :t mapM
08:40:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:40:44 <Cale> why not?
08:40:58 <Cale> Well, it works type-wise.
08:41:08 <Cale> :t mapM :: (Monad m) => (a -> m (a, b)) -> [a] -> m [(a, b)]
08:41:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m (a, b)) -> [a] -> m [(a, b)]
08:41:22 <Cale> But maybe it doesn't do what you want.
08:41:52 <zhulikas> hmmm
08:41:55 <Cale> However, without an additional way to combine two values of type a, you're either going to end up ignoring some elements of your list, or something else which is unnatural.
08:41:56 <zhulikas> maybe I do something wrong
08:42:09 <zhulikas> I can show you the line
08:42:16 <Cale> (if mapM isn't what you want)
08:42:19 <Cale> okay
08:42:24 <zhulikas> mapM is what I need
08:42:28 <zhulikas> but it doesn't work :D
08:42:43 <monochrom> you should define what you want
08:42:44 <Cale> Note that if it helps, there's also a flipped over version
08:42:57 <Cale> forM xs $ \x -> do ... stuff involving x ...
08:43:02 <zhulikas> m <- mapM (\t -> (t, runDB $ count [PostTagId ==. (entityKey t)])) tags
08:43:18 <zhulikas> tags is [Entity Tag]
08:43:19 <Cale> you have a pair there
08:43:23 <Cale> inside the function
08:43:25 <Cale> which is wrong
08:43:31 <zhulikas> runDB ... returns m a
08:43:33 <zhulikas> t is just b
08:43:40 <zhulikas> so how can I fix it?
08:43:45 <zhulikas> without a pair mapM works fine
08:43:45 <Cale> m <- forM tags $ \t -> do v <- runDB ...; return (t,v)
08:44:04 <zhulikas> @hoogle forM
08:44:05 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
08:44:05 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
08:44:05 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
08:44:16 <Cale> Of course, if you want, you could also  fmap ((,) t)  or something fancy like that
08:44:17 <monochrom> mapM (\t -> do v <- runDB ...; return (t,v)) tags
08:44:28 <Cale> or put the function first and use mapM
08:44:42 <zhulikas> hmmm
08:44:50 * zhulikas trying to process what Cale said
08:45:03 <monochrom> mapM (\t -> runDB >>= \v -> return (t,v)) tags
08:45:14 <monochrom> err, mapM (\t -> runDB ... >>= \v -> return (t,v)) tags
08:45:27 <zhulikas> aahhh, I see
08:45:29 <Cale> m <- forM tags $ \t -> fmap ((,) t) (runDB ...)
08:45:31 <zhulikas> thanks
08:45:38 <Cale> but there's no real need for that
08:45:44 <Cale> just use do notation :)
08:45:48 <zhulikas> I can read this one: mapM (\t -> runDB ... >>= \v -> return (t,v)) tags
08:45:53 <mysticc> bytestring are actually implemented as sequence of bits .. how to see actual bits of a given bytestring ?
08:46:05 <zhulikas> this is too complicated for me
08:46:06 <Cale> Yeah, that's the same as using do
08:46:06 <zhulikas> m <- forM tags $ \t -> fmap ((,) t) (runDB ...)
08:46:14 <zhulikas> but yeah, thanks
08:46:20 <Cale> Well, (,) t is the function which pairs a value with t
08:46:27 <Cale> > map ((,) 5) [1,2,3]
08:46:28 <lambdabot>   [(5,1),(5,2),(5,3)]
08:46:57 <Cale> and fmap f x will apply a function f to the result of an action x
08:47:35 <vodik> fmap in this case is really just boxing the value you get back into (x, t)
08:47:45 <vodik> where x is the result of runDB
08:47:51 <Cale> other way around
08:47:53 <Cale> (t,x)
08:47:55 <ozataman> anyone know why I would get GHC panic in TH phase when calling "isClassInstance" on a pretty complex type? Something like: AppT (ConT Database.PostgreSQL.Simple.FromRowTHTest.Entity) (ConT Database.PostgreSQL.Simple.FromRowTHTest.Car)
08:47:56 <vodik> right
08:48:11 --- mode: ChanServ set +o mauke
08:48:11 --- mode: mauke set -q *!*@79.125.*
08:48:22 <Cale> mysticc: what do you mean by "the actual bits"... the Show instance will tell you what's there...
08:49:02 <ozataman> it says the 'impossible' happened - but I'm not even sure what to say if I report this :)
08:49:19 <zhulikas> mysticc, you can unpack it to Word8 for starters
08:49:47 <Cale> Yeah, Data.ByteString.unpack :: ByteString -> [Word8]
08:49:48 <mysticc> Cale: I am writing bytestring to a file , but I need my data to be a fixed size ... if it is more then it gets truncated .. if it is less then I want to add something to make it that size (something like zeroes) ...
08:50:11 --- mode: mauke set -o mauke
08:50:51 <Cale> mauke: quieting Amazon Web Services?
08:52:16 <monochrom> bytestring has length
08:53:27 <ddarius> Cale: Unquieting.
08:53:48 <Cale> oh, unquieting, right
08:54:57 <ddarius> "Take your spam... to the cloud!"
09:04:02 <maloi> :t iterate
09:04:03 <lambdabot> forall a. (a -> a) -> a -> [a]
09:04:18 <Cale> > iterate (*2) 1
09:04:18 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
09:05:56 <zhulikas> iterate (++"a") "a"
09:06:02 <zhulikas> > iterate (++"a") "a"
09:06:03 <lambdabot>   ["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","a...
09:06:25 <ddarius> > tails (repeat "a")
09:06:26 <lambdabot>   [["a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","...
09:06:30 <albel727_> > iterate (\x -> x ++ x) "a"
09:06:32 <lambdabot>   ["a","aa","aaaa","aaaaaaaa","aaaaaaaaaaaaaaaa","aaaaaaaaaaaaaaaaaaaaaaaaaaa...
09:06:39 <ddarius> > inits (repeat "a")
09:06:40 <lambdabot>   [[],["a"],["a","a"],["a","a","a"],["a","a","a","a"],["a","a","a","a","a"],[...
09:06:46 <ddarius> Oh.
09:06:49 <ddarius> > inits (repeat 'a')
09:06:50 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"...
09:07:00 <Silvah> > map length $ inits $ repeat 'a'
09:07:01 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
09:07:06 <zhulikas> > iterate (+) 1
09:07:06 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
09:07:12 <zhulikas> :(
09:07:14 <albel727_> Mine is exponential.
09:07:20 <alpounet> > iterate (+1) 1
09:07:21 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:07:28 <zhulikas> (+1) is lame
09:07:28 <ddarius> albel727_: So is Cale's.
09:07:32 <alpounet> hah
09:07:53 <zhulikas> > foldl (+) 0 [1..]
09:08:01 <lambdabot>   mueval-core: Time limit exceeded
09:08:04 <zhulikas> :D
09:08:08 <zhulikas> kewl
09:08:09 <Silvah> > foldr (-) 0 [1..]
09:08:13 <lambdabot>   *Exception: stack overflow
09:08:53 <albel727_> >iterate (\x -> x^2) 2
09:09:12 <Silvah> > iterate (^333) 2
09:09:13 <lambdabot>   [2,174980057982640953949800178169409709228253554471456994914061648512796239...
09:09:27 <albel727_> >iterate (\x -> x^x) 1.01
09:09:41 <alpounet> albel727_, you forgot a space after the >
09:09:42 <ion> > iterate 1 1
09:09:42 <albel727_> > iterate (\x -> x^x) 1.01
09:09:43 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:09:43 <Silvah> > iterate (\x -> x^x) 1.01
09:09:43 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:09:43 <lambdabot>    `GHC.Real.Integral a'
09:09:44 <lambdabot>   ...
09:09:44 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:09:45 <lambdabot>    `GHC.Real.Integral a'
09:09:47 <lambdabot>   ...
09:09:58 <Silvah> > iterate (\x -> x**x) 1.01
09:09:59 <lambdabot>   [1.01,1.0101005033417416,1.0102030422152326,1.0103076789863008,1.0104144785...
09:10:06 <albel727_> > iterate (\x -> x**x) 1.1
09:10:07 <lambdabot>   [1.1,1.1105342410545758,1.123478572104428,1.1397470115213453,1.160772939176...
09:10:12 <albel727_> > iterate (\x -> x**x) 1.5
09:10:14 <lambdabot>   [1.5,1.8371173070873836,3.056683336818703,30.42684786675409,1.3515557412171...
09:10:15 <Silvah> > iterate (\x -> x**x) 1.9
09:10:16 <lambdabot>   [1.9,3.3855703439184803,62.1020385996825,2.2674051778494837e111,Infinity,In...
09:10:22 <alpounet> you can also use lambdabot in private :P
09:10:31 <Silvah> > "NO!"
09:10:32 <lambdabot>   "NO!"
09:10:37 <albel727_> that wouldn't be half as funny ::
09:10:38 <maloi> > map (++" Batman!")  (iterate (++"Na") "") !! 10
09:10:42 <lambdabot>   mueval-core: Time limit exceeded
09:11:41 <maloi> > map (++" Batman!")  (iterate (++"Na") "") !! 10
09:11:42 <lambdabot>   "NaNaNaNaNaNaNaNaNaNa Batman!"
09:12:08 <KSkrzet> is there a name for the way System.Exception.Exception class is designed?
09:12:30 <liyang> > print (0/0)
09:12:32 <lambdabot>   <IO ()>
09:12:34 <Silvah> > unsafeCoerce 5
09:12:38 <lambdabot>   mueval-core: Time limit exceeded
09:12:45 <liyang> > show (0/0)
09:12:46 <lambdabot>   "NaN"
09:12:59 <KSkrzet> I mean the fact that one can have many exception types openly added later based on Typeable and stuff
09:13:01 <Silvah> > text "test"
09:13:01 <lambdabot>   test
09:13:27 <liyang> > concatMap show (replicate 7 (0/0)) ++ " Batman!"
09:13:28 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaN Batman!"
09:13:35 <maloi> hehe
09:14:03 <ion> 10? 7?
09:14:13 <Yarou> lol
09:14:17 <liyang> I forget exactly how many there ought to be.
09:14:41 * hackagebot HDBC-postgresql 2.3.2.1 - PostgreSQL driver for HDBC  http://hackage.haskell.org/package/HDBC-postgresql-2.3.2.1 (NicolasWu)
09:15:03 <ddarius> liyang: 16
09:15:07 <maloi> 16 it should be it think
09:15:26 <ddarius> Four pairs of eighth notes for two bars.
09:15:34 <donri> liyang: clearly haskell sucks because that's much easier in js
09:16:17 <Ywen> hello guys, I've been using vim with haskell for quite a long time, but only recently I installed cool plugins (syntastic, ghcmod-vim...). Is there a plugin that enables interaction with GHCi (e.g. follow evaluation of a variable, debug)? I believe emacs has...
09:16:18 <donri> you don't even have to mean to do it to make that happen in js
09:16:24 <liyang> donri: computing NaNs? Yeah, I know.
09:16:31 <liyang> :(
09:16:58 <donri> Ywen: brisbin might have something for you
09:17:14 <donri> *ping by proxy*
09:17:17 <Ywen> donri: thanks
09:17:35 <Ptival> > cycle $ (take 48 (cycle "NA ")) ++ "BATMAN! "
09:17:36 <brisbin> a mention in #haskell, this is a banner day in the brisbin household ;)
09:17:36 <donri> there's SHIM that never worked well for me
09:17:36 <lambdabot>   "NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA BATMAN! NA NA NA NA NA NA ...
09:17:56 <timthelion> liyang: does C do that kind of error string?  Would make a great obfuscated C
09:18:12 <brisbin> Ywen: ther is haskellmode-vim which may have the features you need
09:18:18 <brisbin> i use/enjoy it but i don't exercise it to its fullest
09:18:27 * ddarius bets that brisbin does not own a banner.
09:18:38 * brisbin now has reason to purchase
09:19:16 <Ptival> lazy banner purchase is lazy
09:19:26 <donri> brisbin: hey do you have a license for "Html Template Syntax"? i want to steal some/most of it
09:20:00 <brisbin> donri: license is always something i think about last, i don't care what you take -- but i should formalize that stance soon
09:20:12 <donri> :)
09:20:12 <mysticc> @hoogle forkIO
09:20:14 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
09:20:14 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
09:20:14 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
09:20:20 <donri> i hate needing to care about licensing
09:20:21 <Ywen> brisbin: http://projects.haskell.org/haskellmode-vim/screencasts.html ? thanks. I saw it but I overlooked the part "GHCi expression evaluation"
09:20:44 <timthelion> donri: then just write public domain at the top :D
09:21:06 <ddarius> timthelion: You can't do that for other people's code.
09:21:08 <brisbin> Ywen: i found it via vimscripts but i'd bet it's the same project. there are number of mirrors on github too
09:21:30 <timthelion> ddarius: pitty
09:22:14 <Ywen> brisbin: in fact I remember having taken some features (ctags generation, include parsing so that gf works...)
09:22:25 <donri> haskellmode-vim didn't work much when i tried it
09:22:27 <Ywen> brisbin: from it by the past
09:22:34 <donri> but maybe other parts do work, that i didn't try?
09:22:41 <donri> i'm currently working on https://github.com/dag/vim2hs myself
09:22:46 <Ywen> donri: well the stuff I needed (ctags, gf) worked
09:22:56 <brisbin> i use it to add/show inferred types to the file
09:23:02 <brisbin> it can also follow imports depending on where the files are
09:23:18 <mysticc> @hoogle finally
09:23:19 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
09:23:19 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
09:23:19 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
09:23:22 <brisbin> and it sets ghc as the compiler for :make
09:23:24 <brisbin> which is handy
09:23:29 <Ywen> brisbin: yes, that's one thing it has extra compared with ghcmod-vim
09:23:49 <timthelion> ddarius: what I wonder, is if I copy paste out of GPL code, into GPL code which is copy right me, at what point does the code I copy pasted become copyrighted by me and not the original author.
09:24:01 <timthelion> ddarius: like if I just take a few lines...
09:24:04 <dzhus> is there a file-writing Iteratee?
09:24:15 <vodik> brisbin: what script?
09:24:25 <brisbin> vodik: haskellmode-vim
09:24:37 <vodik> oh right
09:24:41 <vodik> err, no right
09:24:46 <donri> brisbin: "follow imports"?
09:24:49 <vodik> but i've found that before and had trouble using it
09:25:07 <brisbin> donri: hit gf on import Foo and you go to lib/Foo.hs for instance
09:25:17 <vodik> donri: you can load the file for a module
09:25:25 <donri> brisbin: ah. i have that in vim2hs :D
09:25:35 <brisbin> fair enough
09:26:23 <Ywen> actually, it just boils bown to a simple "include" variable
09:26:34 <donri> includeexpr
09:26:41 <Ywen> (preferably in your ftplugin/haskell.vim)
09:27:10 <zenzike> donri: fwiw I actually do use escaped newline syntax on occasion
09:27:12 <donri> oh i guess 'include' might suffice
09:27:20 <donri> zenzike: aye, on the todo :)
09:27:32 <donri> optimally it should detect if the line ends in an escape
09:27:34 <zenzike> donri: ta :-)
09:27:58 <zenzike> donri: it's funny becaus I was thinking of githubbing my haskell vim config last month too
09:28:48 <donri> much of vim2hs is me moving stuff out of my vimrc to a dedicated haskell plugin
09:29:50 <ddarius> timthelion: http://ansuz.sooke.bc.ca/entry/23
09:33:20 <zenzike> it looks like you've got a lot more fancy features than me
09:33:20 <zenzike> I might have to take it a spin
09:33:20 <zenzike> /take/give/
09:33:20 <Ywen> donri: googling vim2hs gives nothing, is that available somewhere?
09:33:20 <donri> yea i linked it before, https://github.com/dag/vim2hs
09:33:20 <donri> i started this just days ago, not officially released yet or anything
09:33:20 <ddarius> @google vim2hs
09:33:20 <lambdabot> No Result Found.
09:33:20 <donri> zenzike: wait, you don't mean \n right?
09:33:20 <donri> because that certainly works
09:33:20 <zenzike> donri: no, I mean ending a string quote with \, and starting on a fresh line with \
09:33:20 <donri> yae
09:33:20 <monad_> Hi haskell channel! Is it possible to create functions with optional parameters?
09:33:20 <donri> monad_: sure, pass in a record and provide one with defaults
09:33:20 <zenzike> monad_: strictly speaking, no, that's not possible, but records are a way around
09:33:20 <monad_> ok
09:33:38 <monad_> thank you, this would be an idea...
09:33:39 <donri> or "Maybe", depending on what you meant
09:33:54 <donri> if you mean "default values" you want a record
09:34:14 <monad_> I have a function called render with signature render :: [Language] -> Int -> [Double] -> String; the parameter [Double] is optional
09:34:18 <donri> possibly with a data-default instance
09:34:40 <zenzike> monad_: what do you mean by optional?
09:34:42 <donri> ah. in that case, just pass in an empty list
09:34:56 <donri> list specifically is for the case of "zero or more"
09:35:13 <monad_> I want to call this function with or without that parameter and be able to react inside this function
09:35:44 <zenzike> monad_: would you distguish between passing [] and passing nothing?
09:35:53 <zenzike> /distguish/distinguish/
09:36:03 <monad_> no
09:36:03 * zenzike is having a bad-type day
09:36:18 <monad_> but maybe it's possible to declare functions which support that
09:36:23 <zenzike> monad_: then I'd go with donri's suggestion of just passing []
09:36:39 <monad_> ok
09:37:08 <zenzike> (If you did distinguish, then I'd suggest changing [Double] to Maybe [Double])
09:37:27 <monad_> I will also try to use records...
09:38:03 <monad_> record contains [] by default and can be changed if necessary
09:38:05 <donri> there really is no reason to use a reconrd in this case
09:38:17 <monad_> it's just a matter of design :-)
09:38:18 <donri> well, ok... maybe.
09:38:38 <zenzike> monad_: why do you want the parameter to be optional?  it would make it hard to work out the type of `render lang 0`, for example
09:39:12 <zenzike> monad_: since that could be either `render lang 0 :: [Double] -> String` or `render lang 0 :: String`
09:39:55 <monad_> I know this feature from C, Java, etc. and thought it would be also possible in Haskell to declare a function with default parameter
09:40:13 <zenzike> monad_: I see :-)
09:40:28 <zenzike> monad_: I think it's by design that we don't have optionals in that way in Haskell
09:40:36 <ddarius> Neither C nor Java have that feature.
09:41:08 <sipa> ddarius: Java 1.5 does, afaik
09:41:14 <monad_> aehm, no http://ubuntuforums.org/showthread.php?t=337880
09:41:16 <sipa> C doesn't, but C++ does
09:41:29 <monad_> sipa: yes you are right
09:41:45 <ddarius> sipa: It has variable argument parameters, not optional parameters.
09:41:57 <sipa> right, that's not exactly the same indeed
09:42:26 <ddarius> You can mimic optional parameters with overloading in Java, though, somewhat tediously.  But then it is Java.
09:43:56 * ddarius wonders how quickly he could implement a Joy interpreter in Java with some kind of reasonably not-horrible FFI to Java.
09:45:06 <shergill> you can have variadic functions in haskell as well, fwiw
09:45:53 <ddarius> shergill: To get variadic functions like Java or C, you can just pass in a list.  That's all they are, effectively, doing.
09:46:17 <ddarius> Though you are probably referring to the printf hack which is something a bit different.
09:46:28 <shergill> ddarius: yeah
09:46:44 <mike-burns> The printf hack is hard to use; I wish it just took a list.
09:47:02 <shergill> it's a mindfuck, the first time i saw it
09:48:20 <ddarius> Really the only thing you need to realize is that it works backwards.  It's a type directed parser generator.
09:49:06 * shergill has used variadic functions for ghci, to avoid having to type extra characters
09:51:26 <rostayob> ddarius: that's not what java is doing.
09:51:35 <rostayob> in Java you can overload functions to accept different types
09:51:45 <rostayob> it has nothing to do with passing a list
09:51:52 <rostayob> it's similar to what you do in C
09:52:09 <ddarius> rostayob: The varargs just passes in an array of (suitably typed) objects.
09:52:46 <ddarius> I was not talking about overloading.
09:53:02 <rostayob> weren't we talking about variadic functions?
09:53:26 <rostayob> well in Java you have two ways
09:53:38 <ddarius> Well I guess you are talking about making a bunch of overloads, but that will only give you up to a finite number of parameters (unless you additionally use varargs.)
09:53:54 <ddarius> (fixed finite)
09:54:03 <rostayob> but most of the times the best thing is to overload the function, which is something that you can't do easily in haskell
09:54:25 <tazjin> @src drop
09:54:25 <lambdabot> drop n xs     | n <= 0 =  xs
09:54:25 <lambdabot> drop _ []              =  []
09:54:25 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
09:54:33 <shergill> hmm well in java you're not constrained to having the same type for the arguments are you? which you would be in the case of passing in a list to a haskell function
09:54:42 * hackagebot persistent 0.8.0.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-0.8.0.2 (GregWeber)
09:54:53 <rostayob> shergill: yeah you can overload the function however you want
09:55:32 <ddarius> For a vararg parameter you must have all the types a subclass of the declared type.
09:56:03 <ddarius> Overloading does not solve the same problem as varargs, or vice versa.
09:56:41 <rostayob> ddarius: there is an overlap in functionality (e.g. if you want to have default arguments in C, that's the only way)
09:57:37 <ddarius> There's an overlap in functionality insofar as you can brutally abuse one to achieve the other to some extent.
09:58:38 <dzhus> what is the easy way to HTTP-POST a file in Haskell?
10:00:13 <rostayob> dzhus: curl?
10:00:38 <rostayob> can't remember how low level that binding is
10:01:06 <rostayob> ok, it looks pretty low level.
10:01:51 <Saizan> the HTTP package way is decently easy if you follow the types
10:02:54 <mysticc> In the example here  http://paste.pocoo.org/show/560424/ .. does sequence blocks the whole IO operation .. because I dont see any non determinsm in the output ..
10:03:41 <monochrom> you mean sequence_ ? because you write sequence_ in the actual code
10:04:23 <monochrom> buffering is going to reduce interleaving
10:04:28 <mysticc> monochrom: yeah ..
10:04:42 * hackagebot Peano 0.0.1 - simple Peano numbers  http://hackage.haskell.org/package/Peano-0.0.1 (AndrasSlemmer)
10:04:44 * hackagebot VecN 0.0.1 - a simple peano-indexed vector type  http://hackage.haskell.org/package/VecN-0.0.1 (AndrasSlemmer)
10:04:52 <mysticc> monochrom: If I uncomment the commented code then I see 142536
10:05:25 <mysticc> whereas with sequence_ even for 100 length data i dont see any interleaving ..
10:06:28 <monochrom> well you are comparing an apple experiment and an orange experiment
10:07:21 <monochrom> you have one experiment saying "hPutStr, hPutStr, hPutStr ..." and another saying "print, hPutStr, print, hPutStr ..."  I wouldn't use one to understand the other
10:08:04 <mysticc> monochrom: Oh .. understood ..
10:08:27 <mysticc> monochrom: print is messing with the buffering
10:09:52 <mm_freak> yeeehaaaa
10:09:57 <mm_freak> arch's got GHC 7.4.1 =)
10:10:00 <mm_freak> finally
10:10:32 <Silvah> And in [extra], so they won't move back to 7.0.whatever-it-was.
10:10:42 <mm_freak> it was .3
10:10:54 <brisbin> whoa, it's out of [testing] already. that seems fast
10:11:10 <Ywen> brisbin: well, that's Arch ^^
10:11:18 <brisbin> i have to set aside a rebuild-the-world day to update
10:11:19 <exFalso> yay rejoice
10:11:53 <Silvah> brisbin: it took them three weeks, it's not that fast.
10:12:03 <brisbin> oh, i must've noticed late
10:13:19 <monochrom> and why are you hClosing p while the two threads aren't finished?
10:13:40 <navaati> hi
10:13:47 <navaati> anyone here on archlinux ?
10:13:56 <Silvah> navaati: no.
10:14:09 <Elemir> I don't know
10:14:27 * Elemir uses gentoo and openbsd
10:14:28 <dark> why isn't http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Map.html a monad?
10:14:46 <Elemir> Why Map must be monad?
10:14:50 <Silvah> Elemir: my condolences.
10:14:59 <zhulikas> @hoogle fap
10:14:59 <lambdabot> No results found
10:15:10 <shergill> lol
10:15:16 <zhulikas> :(
10:15:18 <ddarius> dark: Start writing a Monad instance.
10:15:24 <dark> Elemir, so that one could operate with >>= or do notation
10:15:41 <dark> ddarius, I mean, is there any technical impediment for having a default instance?
10:15:57 <exFalso> which mirror has ghc-7.4.1 on arch?
10:16:09 <ddarius> dark: Start writing a Monad instance.
10:16:17 <dolio> What's a default instance?
10:16:25 <navaati> dark : what would be the meaning of a Map monad ?
10:16:28 <Elemir> Arch downloads not from official site?
10:16:33 <exFalso> he means derived i think
10:17:00 <dolio> You can't derive Monad anyway.
10:17:05 <dark> navaati, I.. don't know. Maybe that's it, it would be ill defined? (I just saw it is a functor and some other things, but not a monad)
10:17:08 <mm_freak> and my long world file seems to be ok with GHC 7.4.1
10:17:13 <mm_freak> i had to remove only a single package:  Agda
10:17:14 <brisbin> exFalso: http://www.archlinux.org/mirrors/status/
10:17:15 <exFalso> you -can- with GeneralizedNewtypeDeriving
10:17:17 <brisbin> pick an up to date one
10:17:24 <exFalso> brisbin: thanks
10:17:26 <dark> ddarius, I would, but I am lacking the basics .-.
10:17:39 <dolio> Map isn't a newtype.
10:17:53 <Elemir> How Map can be Monad?
10:17:58 <exFalso> ...
10:18:15 <dark> Elemir, how can it be a Functor?
10:18:16 <exFalso> well (Map a) :: * -> * is a monad
10:18:23 <dark> oh.
10:18:23 <exFalso> if you define it as [a] is
10:19:02 <Elemir> What is semantic of (>>=)?
10:19:07 <dark> actually it would be. why (Map a) isn't a monad (on the link I gave)
10:19:20 <exFalso> join :: Map a (Map a b) -> Map a b
10:19:28 <exFalso> which is easier to define i think
10:19:40 <exFalso> and >>= follows from that
10:19:40 <ddarius> exFalso: Start writing a Monad instance.
10:20:29 <exFalso> ddarius: meh :)
10:21:36 <Elemir> (>>=) must me (Map s a) -> (a -> Map s b) -> (Map s b)
10:21:48 <Elemir> It's something strange
10:21:58 <Elemir> @hoogle (Map s a) -> (a -> Map s b) -> (Map s b)
10:21:59 <Tomsik> Not quite
10:21:59 <lambdabot> No results found
10:22:19 <copumpkin> you'll find it hard to write return for Map :)
10:22:20 <dark> Elemir, I'm confused.. anyway I was trying to operate on a Data.Map with >>=, ghc gave me a lot of type erros but not that >>= wasn't defined for map.. I was trying to do mymap >>= f and in the end I needed to do Data.Map.mapWithKey mymap f
10:22:26 <Tomsik> If it's not quantified on the keys it's not very weird
10:22:29 <dolio> Map s is going to be comparable to (->) s, except it's deficient.
10:22:38 <exFalso> return = Map.empty
10:22:44 <exFalso> no
10:22:46 <exFalso> singleton
10:22:49 <copumpkin> oh yeah?
10:22:50 <rostayob> exFalso: which key?
10:23:02 <zhulikas> @hoogle Map.empty
10:23:02 <lambdabot> Data.Map empty :: Map k a
10:23:02 <lambdabot> package empty
10:23:02 <lambdabot> package NonEmpty
10:23:03 <exFalso> return a = Map.singleton a
10:23:06 <dark> return (a, b) = Map.singleton a b
10:23:10 <rostayob> exFalso: it's a Map, not a Set
10:23:16 <copumpkin> dark: wrong type
10:23:18 <rostayob> dark: that won't typecheck
10:23:21 <exFalso> oh
10:23:26 <exFalso> err
10:23:45 <exFalso> need some constraint on the key?
10:23:52 <copumpkin> you don't have a key
10:23:53 <rostayob> a better question is "Why isn't Set a Monad?", and the answer is "because you cna't enforce Ord"
10:23:58 <rostayob> exFalso: there is no key
10:24:08 <brisbin> it ran off with the spoon?
10:24:08 <rostayob> damnit copumpkin
10:24:19 <dark> rostayob, but Ord isn't implied in the definition of Monad
10:24:22 * copumpkin slaps rostayob 
10:24:30 <zhulikas> fight!
10:24:39 <rostayob> dark: (>>=) :: m a -> (a -> m b) -> m b
10:24:50 <dark> rostayob, and you can order any countable set (and internally they might be trees)
10:24:55 <rostayob> for that to work with set, there would have to be an 'Ord' on the a and on the b
10:25:18 <monochrom> you can circumvent the "Ord" restriction by asking "why isn't (Map Int) a Monad?"
10:25:18 <copumpkin> wat
10:25:29 <rostayob> dark: we're talking about Haskell's Ord and Set here
10:25:45 <monochrom> you can even say: newtype M a = Map Int a. why isn't M a Monad?
10:25:45 <dolio> monochrom: Maybe better use Map Integer.
10:25:59 <rostayob> monochrom: Ord has nothing to do with "why isn't 'Map a' a Monad"
10:26:11 <dolio> monochrom: In case you have a lot of memory.
10:26:33 <dolio> Or does it still fail associativity, like zip lists?
10:26:54 <rostayob> dolio: do you understand why it's impossible to define 'return' for 'Map a'?
10:27:03 <rostayob> wait
10:27:04 <dolio> I certainly do.
10:27:05 <rostayob> it wasn't dolio
10:27:18 <dark> rostayob, do you mean that we need to trasverse the set in an specific order to apply >>=?
10:27:18 <rostayob> I'm confused
10:27:20 <exFalso> instance (HasUnit k) => Monad (Map k) where
10:27:21 <exFalso>     return a = Map.fromList [(unit :: k, a)]
10:27:32 <exFalso> whatever HasUnit is
10:27:46 <monochrom> yes, my goal is to make sure that Ord has nothing to do with the question
10:28:17 <rostayob> dark: ? I mean that we need a constraint on the inner type that we can't have
10:28:29 <exFalso> rostayob: we dont
10:28:33 <shachaf> monochrom: You can define return for newtype M a = Map Int a
10:28:35 <rostayob> exFalso: I'm talking about Set
10:28:40 <doserj> Map k a ~ PartialFunc k a. PartialFunc k is a monad with return = const :P
10:28:41 <exFalso> oh
10:28:58 <rostayob> shachaf: but it would be pretty arbitrary
10:29:08 <dark> monochrom, a puzzling question (for me) is: why is it easy to define Functor (Map a) but apparently complicated to define Monad (Map a)?
10:29:16 <dolio> rostayob: No, not arbitrary.
10:29:21 <dolio> It just uses a lot of memory.
10:29:27 <Tomsik> Because not all functors are monads
10:29:30 <Tomsik> That's why :P
10:29:31 <misterbeebee_> related to Ord and Map: is there a way to define an "OrderedMap" type, so I can define a function with signature "f :: OrderedMap a -> b" instead of "f :: Ord a => Map a -> b"? I was writing some code recently and repeating "Ord a =?
10:29:32 <misterbeebee_> "
10:29:44 <misterbeebee_> "Ord =>" over and over again was annoying.
10:29:54 <rostayob> dark: return would have type 'return :: Map a b'. How do you define that?
10:29:56 <monochrom> no, there isn't a way
10:30:00 <misterbeebee_> er, "Ord a => " over and over again
10:30:07 <rostayob> dolio: mh?
10:30:22 <dolio> rostayob: return x is a map that takes every key to x.
10:30:35 <dolio> And there are only finitely many Ints.
10:30:37 <Tomsik> misterbeebee_: GADTs might be the answer if you don't mind an additional constructors there and there
10:30:48 <monochrom> for Map Bool, return a = fromList [(False, a), (True, a)]
10:30:51 <dark> rostayob, no, return would have type b -> (Map a) b
10:31:01 <dolio> So you can build a balanced tree like that.
10:31:02 <rostayob> dolio: :D
10:31:05 <dolio> In theory.
10:31:12 <rostayob> dark: yes sorry. how do you define that?
10:31:22 <misterbeebee_> Tomsik: thx.  I've read about GADTs, but they aren't in my skill set yet.
10:31:27 <rostayob> dolio: I guess that would make sense
10:31:56 <rostayob> return x = Map.singleton ?? x
10:31:59 <dark> actually. yes, return (x, y) = singleton x y doesn't actually work, because return doesn't have an element of type a
10:32:11 <ddarius> @hoogle Data.Map.singleton
10:32:12 <lambdabot> Data.Map singleton :: k -> a -> Map k a
10:32:32 <rostayob> dark: 'return :: b -> Map a b'. not 'return :: (a, b) -> Map a b'
10:32:34 <exFalso> rostayob: thats where we need to put a restriction on the key
10:32:42 <dark> yes .-.]
10:33:08 <rostayob> exFalso: well what dolio said make more sense, given how you'd implement >>=
10:33:11 <rostayob> *makes
10:33:36 <Tomsik> :t Data.Map.sinleton undefined
10:33:37 <lambdabot> Not in scope: `Data.Map.sinleton'
10:33:43 <Tomsik> :t Data.Map.singleton undefined
10:33:43 <lambdabot> forall a a1. a1 -> M.Map a a1
10:33:51 <rostayob> if the keys are finite and you can enumerate them all
10:33:52 <Tomsik> trolololo
10:33:57 <dolio> If you don't want to run out of memory, you could use /\a -> Either a (Map k a)
10:34:05 <dark> so why ghc haven't told me that >>= wasn't defined? it gave me that on mymap >>= f, f was returning the wrong type. if it was expecting a type, it was checking against >>=.. but it could know earlier that mymap doesn't match on the left side of >>=
10:34:20 <dark> or maybe it doesn't work like this..
10:34:30 <navaati> Data.Map.singleton "lol"
10:34:35 <navaati> err, oops
10:34:38 <navaati> > Data.Map.singleton "lol"
10:34:38 <lambdabot>   Not in scope: `Data.Map.singleton'
10:35:08 <monochrom> try Map.singleton
10:35:28 <ion> or M.singleton
10:36:04 <mysticc> > M.singleton "navaati"
10:36:05 <lambdabot>   Overlapping instances for GHC.Show.Show
10:36:05 <lambdabot>                              (a -> ...
10:36:09 <navaati> hmm, it's ok, i misread the type and was wondering how could this function exist, but you actually need to provide a key, so… normal
10:36:32 <mysticc> > M.singleton 1 "navaati"
10:36:33 <lambdabot>   fromList [(1,"navaati")]
10:37:08 <exFalso> hmm from what i understand we need a function that "composes" two keys when the embedded map is merged into the outer one, and a "unit" key such that someKey * unit = someKey... familiar?
10:37:31 <exFalso> so if we put a Monoid restriction on the key everything works
10:37:52 <monochrom> maybe. not convinced. prove the monad laws?
10:38:12 <exFalso> ehh
10:38:17 <exFalso> err, gotta go
10:38:20 <exFalso> :D
10:38:33 <rostayob> exFalso: that is not that useful
10:38:34 <Cale> WriterT w []
10:39:00 <rostayob> exFalso: since you'll only ever have one element
10:39:02 <rostayob> yes, what Cale said
10:39:03 <Cale> (Monoid w) => Monad (WriterT w [])
10:39:37 <ziv> hello, I need help. I just began learning haskell.
10:39:41 <sm> after some yesod package updates, cabal is fiercely ignoring many of the constraints in hledger-web.cabal. I need more upper bounds, but I'm having a hard time tracking them all down
10:39:42 <Cale> @unmtl WriterT w []
10:39:42 <lambdabot> Plugin `unmtl' failed with: `WriterT w []' is not applied to enough arguments, giving `/\A. [(A, w)]'
10:39:51 <Cale> @unmtl WriterT w [] a
10:39:52 <lambdabot> [(a, w)]
10:39:52 <exFalso> rostayob: hmm yeah it would only be useful with multimaps
10:40:02 <brisingr> ziv: ask away
10:40:07 <Cale> Of course, mtl gets everything backward
10:40:15 <Cale> with respect to pair ordering
10:40:33 <sm> I think I'd like cabal to have a --constraint 'all package versions released as of DATE'
10:40:36 <Cale> ziv: yeah, this is a good place to ask questions :)
10:40:51 <ziv> http://pastie.org/3513182 why won't this compile? it's supposed to give me the maximujm number in a list
10:41:24 <Cale> ziv: you missed some parens
10:41:36 <Cale> ziv: maxi x tail xs is passing 3 parameters to maxi
10:41:40 <Cale> (one of which is tail)
10:41:47 <ziv> ahhhhh
10:41:55 <ziv> so I need parentheses around it?
10:41:58 <Cale> yeah
10:42:04 <Cale> you might also just want to use pattern matching
10:42:08 <dark> or this maxi x $ tail xs
10:42:10 <Cale> maxi x (y:ys) = ...
10:42:17 <Cale> and then use y in place of head xs
10:42:21 <Cale> and ys in place of tail xs
10:42:27 <monochrom> adding more constraints (by yourself or by default) lead to more rejections, not more installs. this should be obvious.
10:42:35 <Cale> head and tail are dangerous functions to use, normally
10:42:56 <Cale> because if the list is empty (in this case, it can't be, but in general...), then your program crashes
10:43:31 <Taneb> My family tree program is nearing completion!
10:43:33 <brisingr> > let maxi x [] = x; maxi x (y:ys) = if x > y then maxi x ys else maxi y ys in maxi [4,5,6,7,5,2,3]
10:43:34 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
10:43:34 <lambdabot>    arising from a us...
10:43:45 <Cale> > let maxi x [] = x; maxi x (y:ys) = if x > y then maxi x ys else maxi y ys in maxi 0 [4,5,6,7,5,2,3]
10:43:46 <lambdabot>   7
10:43:54 <brisingr> > let maxi x [] = x; maxi x (y:ys) = if x > y then maxi x ys else maxi y ys in maxi 0 [4,5,6,7,5,2,3]
10:43:55 <lambdabot>   7
10:44:22 <monochrom> don't use head and tail if you are already pattern-matching anyway
10:44:56 <monochrom> but you can use head in "map head (group blahblah)" of course
10:45:14 <brisingr> ziv: you might want something like goodMaxi (x:xs) = maxi x xs so you don't need to carry the extra parameter
10:45:52 <ziv> I will add that
10:46:02 <monochrom> there is actually a Robert Harper blog article on not using head and tail
10:46:47 <ziv> yayyyy!
10:46:50 <ziv> thank you guys!
10:47:19 <brisingr> enjoy Haskell
10:51:16 <exFalso> http://hpaste.org/64694
10:51:26 <exFalso> ^ Map monad instance
10:52:34 <rwbarton> that doesn't look too likely to be associative
10:53:13 <exFalso> mappend is associative right?
10:53:14 <copumpkin> exFalso: keep in mind that you're basically trying to simulate the "diagonal" function instance
10:53:28 <applicative> this harper dude is deep "Let’s use streams as a motivating example, contrasting them with lists, with which they are confused in Haskell. "
10:53:31 <Cale> copumpkin: this is a different one :)
10:53:37 <copumpkin> oh?
10:53:49 <copumpkin> well, I meant what the goal is
10:53:54 <copumpkin> are there other valid instances?
10:54:01 <Cale> If you're using a monoid instance, it's definitely not the same :)
10:54:17 <cmccann> applicative, I don't think he understands Haskell very well, I wouldn't worry about it
10:54:25 <Cale> This is supposed to be analogous to WriterT w []
10:54:35 <Cale> Or perhaps I should say WriterT k []
10:54:36 <copumpkin> hm :o
10:55:21 <rwbarton> except it only keeps one result for each "written" value
10:55:31 <Cale> right, that'll be a problem :)
10:55:45 <Cale> Quite likely...
10:55:46 <exFalso> by [] you mean the list monad?
10:55:54 <Cale> yeah
10:56:13 <Cale> @unmtl WriterT k [] a
10:56:13 <lambdabot> [(a, k)]
10:57:07 <timthelion> Cale: Don't you think it's a bit ironic, that Writer has such an imperitive name?  Writer, aka, one who writes.  Writer DOES nothing, it simply is... :D
10:57:25 <ion> I don’t.
10:57:27 <Cale> You can think of it imperatively quite nicely.
10:57:57 <Cale> It gives you operations which allow you to write to a (monoidal) log of sorts as your computation proceeds
10:59:15 <exFalso> yeah not associative
10:59:17 <exFalso> oh well
11:02:11 <reltuk> >/quit
11:02:23 <timthelion> If I want to draw a really beautiful complex interface(with many custom graphical widgets) is gtk a good choice?  Or should I use OpenGL?
11:02:59 <zarazek> OpenGl for 2D?
11:03:22 <timthelion> zarazek: Yes, like blender does...
11:03:45 <timthelion> I'm having trouble thinking of many truely beautiful GUIs on linux...
11:03:53 <timthelion> So I'm not sure what to model off of.
11:04:17 <shepheb> can anyone suggest a reference for learning abstract algebra for someone who doesn't know much about monoids, groups, categories, etc.? a new Haskeller wants some intuition for these ideas, but is more interested in definitions and examples than rigor.
11:04:17 <dark> timthelion, are you willing to spend a lot of time specifying the interaction model of each widget? it seems a very ambitious project
11:04:42 <zarazek> if it's going to be 2D, I think OpenGL is not worth it, too low level, use something else like Cairo for nice, anti-aliased 2D vectors
11:04:51 <dark> the opengl widget toolkits I know (such as CEGUI) are pretty basic, and really only suitable for games =(
11:06:11 <timthelion> dark: I know it's a rather ambitious thing.  But I want to see if it can be done.  I think this is a place where GNU/linux is many years behind.
11:06:12 <brisingr> yes yes! bragging time: just finished second chapter: http://bit.ly/xDsDSj
11:06:17 <dark> timthelion, are your controls too novel? if you want to change existing controls, you could tweak some gtk or qt engine. or you could create an empty gtk engine and build your widget with cairo and the gtk infrastructure
11:06:47 <dark> timthelion, did you write something like this before?
11:06:48 <timthelion> dark: I think I'll do that, with GTK
11:07:03 <Cale> shepheb: Well... I suppose it depends on how much time you're willing to spend. :)  Dummit & Foote or Michael Artin's book are good choices for general abstract algebra
11:07:05 <timthelion> dark: I've written beautiful interfaces before in XAML many years ago.
11:07:24 <timthelion> but that was a long time ago and with M$ tools.
11:08:01 <dark> timthelion, what are the problems with the current gtk interface?
11:08:53 <timthelion> dark: I need a custom widget that lays out items on a grid, with arrows, like a flow chart.
11:09:16 <dark> timthelion, oh, you can build that with gtk, without touching other widgets
11:09:17 <totimkopf> hmm, could haskell be used for SEO analysis too?
11:09:44 * hackagebot hledger-web 0.17.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.17.1 (SimonMichael)
11:10:18 <timthelion> dark: can you think of a program that runs in X that uses such a widget?
11:10:18 <dark> timthelion, you just build an empty widget, add a "draw" function (using cairo, opengl, whatever), and functions for interacting (what will happen when the user click, etc)
11:10:20 <Cale_> shepheb: I'm not sure which if any of my last few messages were sent
11:10:33 <timthelion> OK, thanks.
11:10:50 <shepheb> Cale: I saw the one that mentioned Dummit and Foote.
11:10:51 <totimkopf> hi Cale
11:10:52 <dark> timthelion, yes. for example, I was working on a video player in python that got an empty widget, and used mplayer output to draw it
11:11:05 <brisingr> Cale: last message was Well... I suppose it depends on how much time you're willing to  spend.
11:11:12 <dark> (basically creating another widget, that inherited from the base but redefined the draw function)
11:11:18 <Cale> <Cale> shepheb: As a really good intro to Category Theory with little in the way of prerequitites, I recommend Awodey's book.
11:11:18 <Cale> <Cale> It also contains some basics on monoids and some other structures which are closely related.
11:11:30 <misterbeebee_> related, on the topic of graphics, what about for dead simple 2D drawing? (dots, lines, floodfill) Anything better than OpenGL?  would be easier to just write to an Array/Vector/JuicyPixels and then feed that to an image viewer?
11:11:32 <Cale> prerequisites*
11:11:34 <dark> what I was doing is to work with a python library that did just this
11:11:46 <timthelion> ok
11:12:08 <Cale> misterbeebee_: Maybe try gloss, if it's something really simple
11:12:30 <Cale> misterbeebee_: gloss is good for little visual toys and experimentation in 2D
11:12:41 <brisingr> I'll happily take criticism, I probably made my (un)fair share of mistakes
11:12:47 <dark> timthelion, actually I see novel widgets in gtk all the time. some of them are of good quality (but I guess it's hard to make a good widget that won't get ugly if you change the theme engine..)
11:12:52 <Cale> totimkopf: hello
11:12:54 <CodeWeaverX> Greetings, programs.
11:13:20 <CodeWeaverX> totimkopf…. Sky Captain?
11:13:25 <CodeWeaverX> Anyway.
11:13:27 <CodeWeaverX> *sips coffee*
11:13:55 <dark> timthelion, for example, http://gnomejournal.org/article/34/writing-a-widget-using-cairo-and-gtk28 for gtk2
11:14:29 <timthelion> dark: Yes, thank you.  I think Cario will work great.  I am looking at their examples page now.
11:15:15 <dark> timthelion, bear in mind that gtk2 is deprecated. but I can't find a similar guide for gtk3
11:16:08 <timthelion> dark: it's frustrating, that despite the fact that XAML was invented in the open source world we don't have such a powerful markup langauge for GTK(I have used GTKBuilder with no luck).
11:16:40 <sm> hrm. hackage trac no longer recognizes my login, cabal upload has stopped using the login info from config, and hackagebot has not announced my upload
11:16:44 <dark> ok, "gtk 3 custom widget" return some things
11:16:49 <misterbeebee_> Cale: oh sweet, Gloss is a simple API over GL/GLUT. thanks!
11:16:59 <Cale> I wonder if there's any reason for me to hate GTK 3 in the same way I hate Gnome 3
11:17:09 <Cale> misterbeebee_: yeah :)
11:17:31 <timthelion> Cale: Why do you hate gnome3,
11:17:33 <timthelion> ?
11:18:04 <Cale> timthelion: It looks like it was designed for people with tablet PCs and no mouse.
11:18:11 <timthelion> Cale: Mind you, if I wasn't on a tablet, I would also hate it.
11:18:21 <dark> timthelion, Hmm is XAML like XUL? Well I think that the overall direction is to substitute the current native rendering engines with an html engine. (both gtk3 and qt4 now uses CSS for theming, for example)
11:18:25 <zarazek> are there bindings for GTK3 for Haskell?
11:18:42 <Cale> 2011 is the year of poor UI design choices motivated by the possibility of tablets
11:18:46 <brisingr> timthelion: I'm with Cale here. Also, it takes a lot of time to change the WM in Gnome 3
11:18:53 <Cale> and 2012 :)
11:19:03 <timthelion> dark: yes, it's almost the same as XUL but has very nice 2D and 3D vector support.
11:19:20 <dark> Cale, I dislike the thin scrollbar =( (but apparently this doesn't happen in all themes). and I dislike the lack of a "mist" theme
11:19:32 <brisingr> Cale: last message was Well... I suppose it depends on how much time you're willing to  spend.Well... I suppose it depends on how much time you're willing to  spend.[A[A[A
11:19:37 <brisingr> sorry
11:19:41 <Cale> Also, little things like the fact that they did away with all the panel applets that I had grown addicted to
11:19:42 <brisingr> accidentally middle mouse button
11:19:44 * hackagebot persistent-mysql 0.8.1 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-0.8.1 (FelipeLessa)
11:20:01 <zarazek> timthelion: how are you typing on your tablet?
11:20:19 <dark> I'm now converted to xmonad, won't look back
11:20:24 <timthelion> zarazek: I have the kind with the turnable screen, so it transitions into a normal laptop
11:20:40 <Cale> I will say one thing though: Windows 8 looks *much* more annoying than Gnome 3 can ever hope to be.
11:20:51 <timthelion> I used to use xmonad.  I even wrote a layout for it many years back.  But it's useless with the tablet.
11:20:51 * applicative just installed scrotwm, is that wrong
11:20:55 <Cale> So at least Gnome 3 has that going for it
11:21:12 <Cale> But when you start having to compare with Windows to get a positive outlook on things...
11:21:22 <brisingr> I think the problem is that designers think the desktop model is outdated
11:21:44 <kallisti> Cale: I finally decided to switch to xmonad. I'll never go back. :P
11:21:55 <timthelion> brisingr: it is, but tablets aren't the replacement.  Wearables are :D
11:21:59 <Cale> xmonad is just a window manager though
11:22:03 <companion_cube> applicative: you naughty untyped language user!
11:22:04 <shepheb> I'm using graphics-drawingcombinators and OpenGL/SDL to make a window. but it doesn't seem to be a real X window in that it doesn't show up as one I can share while projecting my screen.
11:22:17 <shepheb> am I missing some step that will create a "real" window (Linux)
11:22:20 <kallisti> Cale: yeah. configuring takes a lot of time.
11:22:30 <cmccann> shepheb, possibly, check the SDL documentation
11:22:39 <brisingr> Cale: I find that xmobar replaces the gnome panel, but there are still some design choices I wouldn't have made
11:22:55 <Cale> I can't stand tiling WMs honestly.
11:22:58 <cmccann> the Haskell bindings are very close to the C API, so you can answer that sort of question based on that
11:23:05 <dark> shepheb, what is to project your screen?
11:23:16 <Cale> Many many programs don't work out well when squashed into arbitrary rectangles
11:23:39 <companion_cube> not so many, actually
11:23:46 <brisingr> the bad thing about xmonad is that people take one glance and say "Linux is hard"
11:23:48 <dark> Cale, for example? (also, the rectangles aren't arbitrary, they are programmable and one can make exceptions on a per-program basis)
11:24:11 <timthelion> The bigest problem with xmonad, is that linux is moving away from the UNIX philosophy of making small single purpose apps.  And such apps are becoming more and more rare.  For example, modern automounting and sleep are supported in Gnome yet no app exists which compairs to gnomes capabuilities in those feilds.
11:24:17 <Cale> anything with a horizontal menu or toolbar with more than a couple things on it
11:24:20 <kallisti> brisingr: well, the configuration certainly isn't trivial.
11:24:23 <applicative> companion_cube:  hey unlike xmonad, scrotwm isn't *crippled by not being written in C*
11:24:25 <t7> does one have to recompile xmonad to change settings?
11:24:44 <shepheb> I have great success using xmonad and basically having only one or two windows per workspace.
11:24:45 <companion_cube> applicative: oh, i thought it was the one written in lisp
11:24:57 <Cale> anything where there are side panels which will consume the region used for content as the window is resized
11:24:57 <timthelion> t7: in a way.  One presses a button, and magic  happens under the hood.
11:24:58 <companion_cube> maybe it's stumpwm or whatever, then
11:25:21 <Cale> Yeah, if you limit yourself to one or two windows, it'll probably work, but then, that's not really very effective is it?
11:25:31 <dark> Cale, well, 99% of time I have all my apps fullscreen. I work with a few core apps so each of them receive an workspace. I have a keyboard with 13 additional keys on the sides so I use them to switch between workspaces @.@
11:25:31 <timthelion> stump_wm is written in lisp
11:25:43 <Cale> Also, there are parts of windows which I *want* to be overlapped when I switch to another window
11:25:43 <brisingr> Also, the fact that gnome 3 promotes full screen usage
11:25:48 <kallisti> Cale: I typically use 2-4. sometimes 5. but at that point I begin to run out of screen space
11:25:50 <brisingr> which I find cumbersome
11:26:07 <Cale> If programs had a built-in notion of content area, you could do a very good tiling/automatic WM
11:26:26 <Cale> So that things like toolbars and such could be obscured depending on focus
11:26:47 <dark> but I use those windows a bit like emacs windows (or screen, or blender). I can divide the screen in two and adjust the sizes, and I can move some app window to somewhere else if needed, etc
11:26:52 * cmccann likes the idea of a tiling WM but agrees with Cale's complaints unfortunately
11:27:11 <kallisti> one annoyance is that libre-office's detatched toolbars tend to steal focus from the main window as they suddenly appear while I'm typing.
11:27:23 <kallisti> I'm sure a specific per-app configuration could remove that though.
11:27:28 <brisingr> I remember the once default debian behavior of super-simple file manager windows
11:27:34 <exFalso> Cals: xmonad can do that
11:27:37 <exFalso> *Cale
11:27:53 <Cale> exFalso: xmonad can't know where the toolbars and such are
11:28:04 <Cale> (which part of the window they're taking up)
11:28:16 <Cale> At least, not in any particularly universal way
11:28:22 <Cale> I suppose you could program it per-app
11:28:43 <exFalso> Cale: not sure what you are referring to but GIMP for example works
11:28:55 <exFalso> and that one has quite a few windows
11:29:00 <kallisti> Cale: that's the typical solution.
11:29:02 <brisingr> Most of all, I find having to do more and more things using the GUI disturbing
11:29:10 <dark> I have currently 10 very specific workspaces .-. one for emacs, other for chromium, other for gnome-terminal, etc
11:29:11 <kallisti> to configure per-app (or per window roles or other X properties)
11:29:29 <zhulikas> @hoogle (a -> b) -> m [a] -> m [b]
11:29:32 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
11:29:32 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
11:29:32 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
11:29:45 <ddarius> Cale: Does some other window manager know?
11:29:52 <Cale> exFalso: Suppose I have a web browser and my IRC client open. When I switch from my browser to IRC, I want to still be able to see the web page I was looking at, but I want the area which was used for toolbars to be covered by the IRC window. This is easy to arrange with floating windows
11:29:58 <Cale> But with tiles, it doesn't work.
11:30:42 <kallisti> Cale: I'm staring at both the web browser and IRC client at the same time, right now in xmonad. :P
11:30:42 <brisingr> You can always use xmonad with floating windows, but that's like always using a car in reverse
11:30:49 <dark> Cale, one could use detachable (mac-style) toolbars, if there is toolkit support
11:31:01 <kallisti> Cale: the fact that they're not floating on top of each other isn't interferring with anything.
11:31:01 <timthelion> I don't put enough thought into window management to care about 30 pixels most of the time :D
11:31:13 <copumpkin> mac toolbars are detachable?
11:31:22 <Cale> kallisti: well, it'll be cutting into the amount of scrollback that you have available
11:31:24 <dark> I mean, outside the window
11:31:32 <dark> and menu bar, not toolbar
11:31:53 <kallisti> Cale: hm?
11:32:33 <ddarius> copumpkin: So how about being at either Davis or Sullivan tomorrow sometime between 5-10, though preferably more like 5-7.  You too dolio.
11:32:42 <Cale> kallisti: the menu bar, tabs, toolbar, url bar, etc, in your web browser are taking up vertical screen real estate even when you have your IRC client focused.
11:32:53 <copumpkin> ddarius: sounds good
11:32:57 <dark> Cale, here I use chromium to save vertical space. also, since I have no gnome-panel or something like this, I save a bit more
11:33:13 <kallisti> Cale:  I'm using a horizontal layout.
11:33:20 <dark> I can put irc and web side-by-side and i will be happy with that
11:33:38 <brisingr> I tend to IRC and web with 2 monitors
11:33:48 * ddarius has IRC in a separate workspace.
11:33:49 <kallisti> Cale: but yes I see what you're saying. managing screen real estate becomes more important.
11:34:02 <kallisti> ddarius: I... move windows as appropriate. crazy, right?
11:34:03 * ddarius has zero desire to have IRC text scroll by in another window while I'm working on something else.
11:34:16 <brisingr> I use xmonad mainly because I'm too lazy to move my windows around
11:34:26 <Cale> kallisti: It's small, but lots of little things like that are what starts to annoy me whenever I've tried to use a tiling WM
11:34:44 * hackagebot fclabels-monadlib 0.2.0 - MonadLib monadic interface for the "fclabels" package.  http://hackage.haskell.org/package/fclabels-monadlib-0.2.0 (BardurArantsson)
11:34:52 <ddarius> I use xmonad because I almost always use apps fullscreen and have no desire for window decorations and do want relatively easy keyboard shortcuts.
11:34:52 <brisingr> Cale: like the config? :) I know it scared the hell out of me the first time
11:35:05 <Cale> and you can write lots of custom modes to handle the various cases you might want, but meh, just float the windows and let me handle it
11:35:34 <Cale> I would use xmonad if someone writes a mode to make it look and work like metacity
11:35:38 <Cale> :)
11:35:53 <kallisti> I'll send it by the #xmonad guys
11:35:54 <dark> Cale, writing such modes may be more fun than handling this manually
11:36:01 <Cale> I almost never fullscreen anything which isn't a game
11:36:36 <Cale> and I tend to leave little gaps around the edges of my screen where windows peek out and can be clicked in
11:36:47 <Cale> (rather than relying more on the taskbar)
11:37:00 * ddarius doesn't even have a way to change windows (workspaces really) with a mouse.
11:37:04 <dark> I feel claustrophobic when I don't fullscreen (18.5" widescreen here, I can have two windows side-by-side comfortably)
11:37:15 <ddarius> This is actually a bit annoying when I try to VNC into my computer from my phone.
11:37:33 <kallisti> Cale: but yeah which layout I use while attempting to web browser with multiple windows open depends on the website.
11:37:38 <kallisti> sometimes I switch to wide but I prefer tall.
11:37:44 <Cale> Yeah, I almost never alt-tab somehow.
11:37:48 <cmccann> ddarius, wait, you mean some people actually use a mouse to switch windows? huh.
11:37:58 * cmccann tries to figure that out
11:38:04 <Cale> I use the mouse almost always to switch windows
11:38:10 <brisingr> cmccann: there are even people without focus follows mouse
11:38:11 <kallisti> Cale: the way you operate a stacking WM sounds similar to the way I use them.
11:38:18 <Cale> and I use focus-follows-mouse
11:38:33 <cmccann> brisingr, eh, focus follows mouse annoys me massively
11:38:38 <exFalso> @hoogle fZipWith
11:38:38 <lambdabot> No results found
11:38:38 <ddarius> brisbin: Like everyone using Windows.
11:38:45 <exFalso> @hoogl fzipWith
11:38:45 <lambdabot> Maybe you meant: hoogle hoogle+
11:38:48 <ddarius> +gr
11:38:50 <cmccann> because it means I have to worry about where I leave the mouse cursor, instead of just getting it out of the way and forgetting about it
11:38:51 <brisingr> cmccann: I find that strange
11:38:52 <exFalso> @hoogle fzipWith
11:38:53 <lambdabot> No results found
11:39:06 <brisingr> cmccann: oh, now I know what you mean
11:39:27 <Cale> In other news, has anyone else had problems with windows not respecting Z order somehow?
11:39:52 <Cale> i.e. windows which are below others seem to occasionally draw through windows that are on top of them
11:39:55 <exFalso> everything's a-ok here in xmonadland
11:39:59 <Cale> Firefox is a major offender here
11:40:16 <Cale> I have no idea why it's started happening
11:40:18 <xplat> probably plugins
11:40:28 <cmccann> Cale, I get that occasionally when focus-stealing prevents a new window from taking focus but it still appears on top
11:40:34 <ddarius> I only have issues with that when I'm swapping or something, and then it is a tearing-like thing, not a full redraw.
11:40:50 <xplat> firefox plugins hate z-order and every other aspect of correct drawing
11:40:52 * ddarius utterly abhors focus stealing.
11:41:21 <xplat> especially flash
11:41:30 <rostayob> if you're talking about WMs
11:41:31 <rostayob> use i3!
11:41:33 <Cale> This isn't just plugins though
11:41:34 <cmccann> er, focus stealing prevention, I mean. i.e., a new window appearing on top but not getting focus
11:41:39 <Cale> it's the entire firefox UI
11:41:39 <rostayob> best window manager around
11:41:40 <brisingr> some firefox plugins hate memory management
11:41:52 <Cale> it'll draw itself on top of my IRC window sometimes
11:42:00 <zhulikas> uhm... help!
11:42:02 <zhulikas> http://hackage.haskell.org/packages/archive/yesod-form/0.4.2/doc/html/Yesod-Form-Types.html#t:FieldSettings
11:42:08 <zhulikas> how is it possible
11:42:11 <exFalso> @hoogle liftA2
11:42:11 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:42:14 <exFalso> ah
11:42:15 <xplat> if xmonad worked like i3 by default i would use xmonad
11:42:16 <zhulikas> to construct FieldSettings like this:
11:42:21 <cmccann> brisingr, some firefox plugins like crashing firefox, though
11:42:21 <zhulikas> "Title" { fsId = Just "title" }
11:42:24 <zhulikas> what kind of syntax is that??
11:42:41 <ion> OverloadedStrings perhaps.
11:42:45 <shachaf> Looks like record yntax with an abuse of OverloadedStrings
11:42:45 <exFalso> im guessing overloadedstrings
11:42:51 <exFalso> slowpoke
11:43:03 <zhulikas> yes, it says about updating a record if brackets left empty
11:43:05 <zhulikas> but whoa...
11:43:10 <zhulikas> ok then, overloaded strings
11:43:11 <zhulikas> thanks
11:43:21 <rostayob> xplat: possibly. but then why? i3 already does everything right
11:43:24 <xplat> but i3 seems to hard to persistently customize and xmonad too hard to manipulate fluidly (or get working in a reasonable way to start with)
11:43:25 <zhulikas> is this possible with anything?
11:44:18 <xplat> zhulikas: {-# LANGUAGE OverloadedStrings #-} i think
11:44:19 <rostayob> xplat: the great thing about i3 is that I've never felt the urge to customize it, apart from minimal things
11:45:13 <xplat> rostayob: for me it seems like the closer something is to perfect the more i want to customize it, so i can get it *just* *right*.
11:45:29 <ion> instance IsString (IO ()) where fromString = putStrLn
11:45:38 <xplat> (if it's a huge pile of fail, why bother?  all that effort and it won't work right anyway)
11:45:45 <Cale> zhulikas: The OverloadedStrings extension lets you define your own function String -> a to say how to interpret string literals as values of your own types.
11:46:09 <rostayob> xplat: mah, I stop worrying :D
11:46:09 <Cale> zhulikas: this is intended to be used just to allow other types of strings (Data.Text, Data.ByteString.Char8, etc.)
11:46:12 <rostayob> *stopped
11:46:31 <zhulikas> I have never seen it before
11:46:32 <Cale> zhulikas: but it can be abused by defining overloadings at, for example in this case, a record type.
11:47:12 <xplat> instance IsString (Integer) where fromString = read
11:47:41 <ion> instance Num String
11:47:50 <xplat> "2" + "2" = "4"
11:48:01 <ion> indeed
11:48:48 <xplat> instance IsString (ShowS) where fromString = (++)
11:48:54 <ddarius> instance IsString a where fromString = eval
11:49:04 <ion> unsafeCoerce
11:49:18 <xplat> "now we can do "    "this crazy thing that C does."
11:49:54 <xplat> (though only with up to 2 strings)
11:49:54 <ddarius> xplat: I like i.
11:49:57 <ddarius> +t
11:50:09 <brisingr> unsafeCoerce is to Haskell like analogies are to ducks
11:50:56 <exFalso> weirdest ghc-7.4.1 bug: earlier today i uploaded http://hackage.haskell.org/package/VecN-0.0.1 if import it and define any function without a top level signature ghc will panic :D
11:51:22 <xplat> unsafeCoerce is to Haskell like chainsawchucks are to weapons :)
11:52:20 <applicative> exFalso i don't think it explains that, but you included the dist directory in the tarball
11:52:43 <exFalso> applicative: my bad, not a regular hackage uploader
11:53:09 <ddarius> cabal-install should package it for you.
11:53:24 <ion> The encoding package has a similar problem. It has a x86-64 build of dist/setup/setup in the tarball.
11:53:35 <zerax> Isn't unsafeCoerce more like a nuclear deterrant? People seem to think it's necessary, but no one thinks it's a good idea to use it.
11:53:46 <exFalso> actually if you have -any- ambiguous type ghc will panic
11:53:55 <applicative> exFalso: similarly with Peano-0.0.1
11:53:56 <ddarius> zerax: unsafeCoerce is virtually unused in Haskell.
11:54:26 <zerax> Interesting, information on it seems fairly scarce, at least the last time I looked for it.
11:55:06 <cmccann> @quote ddarius unsafeCoerce
11:55:07 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
11:55:22 <xplat> unsafeCoerce is to Haskell like a ham and cheese sandwich
11:55:33 <zerax> delicious_
11:55:44 <brisingr> unsafeCoerce is to haskell like Segmentation fault.
11:55:48 * ddarius should make a wiki page with a list of functions that are special cases of unsafeCoerce.
11:56:01 <ClaudiusMaximus> the only time i've used unsafeCoerce is to convert between newtypes with unexposed constructors (for OpenGL uniform locations, or something)
11:56:07 <ddarius> listToMaybe = unsafeCoerce
11:56:08 <dark> @type unsafeCoerce
11:56:09 <lambdabot> forall t1 t. t1 -> t
11:56:17 <cmccann> ddarius, like https://gist.github.com/1934179 ?
11:56:32 <dark> oh, like Obj.magic from ocaml
11:57:07 <applicative> exFalso, to continue, peano should be called Peano in VecN.cabal
11:57:09 <ddarius> cmccann: That's a weak list.
11:57:15 <dark> I know it is used for unsafe marshalling  on ocaml (ocaml doesn't preserve types on runtine)
11:57:16 <xplat> unsafeCoerce is a slightly more obvious name for it
11:57:39 <kowey> any community.haskell.org admins around?
11:57:47 <xplat> calling it Obj.magic is like security through obscurity
11:58:20 <applicative> what is the version of base that comes with ghc-7.4?
11:58:23 <brisingr> yeah, well, it's better than doing it invisibly
11:58:27 <exFalso> applicative: i'll remember these things for next time...
11:58:43 <dark> you need to "trust" the other side (of network, or maybe some file) will give you a value of the type you are expecting.. if it isn't, your program may crash
11:59:15 <ion> applicative: ghc-7.4.1: base-4.5.0.0
11:59:16 <applicative> exFalso, you should specify base >= 4.4 since you use DataKinds I think that's the right number
11:59:34 <applicative> oh, maybe base >= 4.5 like ion says.
12:00:52 <xplat> dark: as in 'you can trust me, would an untrustworthy person have candy?'
12:01:27 <ClaudiusMaximus> so i'm using Graphics.Vty - but now i want to save the output to a sequence of images: is there a way to 1. check that it's running inside an X-based terminal; 2. get the coordinates of said X window?
12:02:49 <xplat> ClaudiusMaximus: w3mmee or whatever that console browser is called seems to do it
12:03:13 <exFalso> base < 5, base >= 4.5 is this the way to specify a lower and an upper bound?
12:03:43 <parcs`> && i think
12:03:46 <ClaudiusMaximus> base >= 4.5 && < 5   is the more common syntax
12:03:53 <exFalso> thanks!
12:04:54 <ClaudiusMaximus> xplat: is it written in Haskell?
12:05:14 <ClaudiusMaximus> s/is there a way to/how do i/
12:06:18 <ClaudiusMaximus> actually, a suitable hack might be to set the terminal window title
12:06:46 <dark> timthelion, btw i liked this one http://www.pygtk.org/articles/writing-a-custom-widget-using-pygtk/writing-a-custom-widget-using-pygtk.htm (but I suppose there are a lot of other tutorials on google)
12:13:21 <exFalso> applicative: uploaded new versions, hopefully everythings ok
12:19:46 * hackagebot Peano 0.0.2 - simple Peano numbers  http://hackage.haskell.org/package/Peano-0.0.2 (AndrasSlemmer)
12:19:48 * hackagebot VecN 0.0.2 - a simple peano-indexed vector type  http://hackage.haskell.org/package/VecN-0.0.2 (AndrasSlemmer)
12:23:40 <zhulikas> @hoogle for
12:23:40 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
12:23:41 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
12:23:41 <lambdabot> Foreign module Foreign
12:25:51 <applicative> looks good exFalso  why not call it VNil, the VecN Zero?  also vtail vhead maybe?
12:29:53 <ddarius> Hackage: 3,000 type level nats and nat indexed vector packages and counting
12:29:57 <applicative> also, you have KindSIgnatures on but don't give the kind signature like data VecN :: Peano -> * -> *  where
12:30:20 <applicative> ddarius, yes, but how many use DataKinds so far
12:30:22 <exFalso> ddarius: i checked, couldnt find any:)
12:30:38 <applicative> http://hackage.haskell.org/package/Vec
12:30:47 <exFalso> not a well kinded that is
12:31:40 <exFalso> applicative: yeah but when one's doing type-level comp with only * it feels like... well it feels like a dynamically typed scripting language...
12:31:44 <applicative> yeah, i don't think there's one with the new extension, though it is written in every illustration.
12:32:36 <byorgey> ah, nice, is this the first Hackage package using DataKinds? =)
12:32:38 <k0ral> glib doesn't compile with latest ghc, is it a known problem ?
12:32:52 <applicative> exFalso oh, was just thinking you wrote data VecN p a which is less informative, the letters you use with a GADT aren't still in scope on the later lines, if i remember
12:33:32 <applicative> exFalso, you haven't defined vappend!!
12:34:35 <exFalso> applicative: :) yeah this is 0.0.2
12:34:50 <exFalso> also we need addition for that
12:35:14 <applicative> yes, type family Plus ... or whatever
12:36:22 <exFalso> applicative: isnt it better to use a GADT to prove the addition and a typeclass to "auto-derive" the proof?
12:37:38 <k0ral> please can anyone answer me ?
12:37:52 <alpounet> k0ral, yes
12:37:59 <alpounet> there's an upcoming gtk2hs release
12:38:12 <alpounet> that will be compatible with ghc 7.4.1
12:40:43 <shurikas> @hoogle m a -> (a -> b) -> m b
12:40:43 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:40:43 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
12:40:43 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
12:40:47 <shurikas> sure
12:42:19 <tzxn3> http://pastebin.com/xFrAnirh -- what causes the number to be printed twice each time input is entered?
12:42:21 <mauke> The paste xFrAnirh has been copied to http://hpaste.org/64697
12:42:34 <tzxn3> oh right
12:42:37 <tzxn3> I just noticed
12:42:46 <tzxn3> actually no
12:42:46 <tzxn3> D:
12:43:36 <k0ral> alpounet: thank you
12:44:07 <tzxn3> newline is treated as an input character?
12:44:36 <byorgey> tzxn3: yes, it's because of newline
12:44:43 <applicative> oh, exFalso I'm not sure, I was just registering recognition of the further requirement.  You need to do whatever will get the ghc to be best at doing the arithmetic...
12:44:48 <byorgey> tzxn3: getChar only gets a single Char from the input stream
12:44:55 <tzxn3> ah
12:45:00 <alpounet> k0ral, i guess that it's the Num / Eq Show thing that bites you when trying to install glib on the latest ghc
12:45:28 <identity_> Do you guys happen to know about a way, in haskell, using some third party hackage library or something, to get a file's size, without doing it manually? I'm looking for the Windows api function for it, but it doesn't seem to have been wrapped
12:45:54 <identity_> Because it's pretty expensive seeking to the end and checking size that way for every file, for thousands of files
12:46:06 <k0ral> alpounet: no, it's "error: void value not ignored as it ought to be" in System/Glib/hsgclosure.c
12:46:34 <alpounet> uh
12:46:37 <alpounet> ok
12:47:30 <rasfar> identity_: have you looked at http://stackoverflow.com/questions/5620332/what-is-the-best-way-to-retrieve-the-size-of-a-file-in-haskell ?
12:47:34 <applicative> identity_ http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/src/Data-ByteString.html#length
12:48:23 <KSkrzet> identity_: did you see win32 package? in particular: http://hackage.haskell.org/packages/archive/Win32/2.2.2.0/doc/html/System-Win32-File.html
12:49:20 <t7> how do i make i withs and k ?
12:49:24 <t7> with s and k *
12:49:37 <rasfar> That's #haskell at your service!  Now if only I got that kind of support with my SYB lattice join problem...
12:49:55 <identity_> rasfar: KSkrzet Nope, didn't find it yet, thanks.
12:49:59 <identity_> applicative: I'll take a look
12:50:10 <identity_> KSkrzet: Eh, meant ot say yes to you.
12:50:11 <dreixel> rasfar: syb lattice join problem?
12:50:19 <identity_> That's what I'm referring to; the GetFileSize function isn't in there.
12:50:26 <identity_> From kernel32.dll
12:50:40 <applicative> identity_: it sounds like the stackoverflow plan is what you really meant, if i understand now
12:50:45 <identity_> Yeah
12:50:58 <rasfar> dreixel: if I have constructed a value from a mutually-recursive set of alg. data types, and I want to find the join of all terms of type T?
12:51:06 <identity_> I acutally just ran into the posix thing, right before the stackoverflow page was linked
12:51:09 <identity_> Thanks! :)
12:51:13 <rasfar> I have an algorithm in mind, but my SYB skills are not up to it yet.
12:51:19 <rasfar> (I have 5 new papers to read however...)
12:51:53 <dreixel> rasfar: you mean to find all elements of type T inside a value of type S?
12:52:54 <rasfar> not only find all those values, but find the join (in the lattice sense) -- the "lowest" node (of any type) under which all the T nodes reside.
12:53:21 <dreixel> rasfar: lowest by what definition?
12:53:46 <rasfar> well, that any descendant would not be an ancestor of every T node.
12:54:09 <rasfar> that, to my understanding, is the "lattice join"
12:54:30 <ion> t7: s f g a = f a (g a); k a _ = a
12:54:47 * hackagebot spike 0.2 - Experimental web browser  http://hackage.haskell.org/package/spike-0.2 (KrzysztofSkrzetnicki)
12:54:49 * hackagebot fuzzytime 0.7.7 - A 'ten past six' style clock  http://hackage.haskell.org/package/fuzzytime-0.7.7 (KamilStachowski)
12:54:54 <ion> t7: s k anything a = k a (anything a)
12:55:12 <rasfar> (it's alright, I have some fine reading on hand...)
12:58:48 <`Jake`> If I do something like random    (mkStdGen {some number}) :: (Float, StdGen)    will the funtion return something > 0 and < 1 or are the two numbers possible results?
12:59:14 <t7> @pl s f g a = f a (g a)
12:59:14 <lambdabot> s = ap
13:00:30 <ion> @type let s = (<*>); k = const in s k ?whatever
13:00:31 <lambdabot> forall b a. (?whatever::b -> a) => b -> b
13:02:07 <exFalso> `Jake`: http://hackage.haskell.org/packages/archive/random/1.0.0.1/doc/html/System-Random.html#4
13:02:17 <`Jake`> thanks
13:08:03 <hpaste> plat0 pasted “foldl'” at http://hpaste.org/64698
13:08:15 <plat0> ^ why does this work when compiled, but not in ghci?
13:09:21 <plat0> (in ghci it runs out of memory)
13:11:39 <ChristianS> plat0: why don't you use the standard definition of foldl' from Data.List ?
13:12:45 <plat0> Because I was experimenting with http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
13:15:09 <tzxn3> what's wrong with this function definition? http://pastebin.com/tVdjaKGP
13:15:11 <mauke> The paste tVdjaKGP has been copied to http://hpaste.org/64701
13:19:06 <doserj> tzxn3: remove the type signature and check what ghci thinks
13:22:20 <ChristianS> plat0: i don't know how good ghci is at garbage collection (all the interim results), maybe that is the problem?
13:23:05 <plat0> Could be.
13:27:56 <jmcarthur> plat0: it's because you're storing veryBigList
13:28:06 <jmcarthur> plat0: since it's bound in the top level
13:28:42 <jmcarthur> plat0: ghci has to keep it around instead of GCing it since it doesn't know if you will want to use it later
13:28:48 <plat0> Oh I see.
13:29:07 <plat0> Hmm, it could recompute it though, couldn't it?
13:29:12 <jmcarthur> plat0: if you remove it and just say sum3 [1..100000000] i bet it will be better
13:29:14 <hpaste> jpm pasted “SYB join” at http://hpaste.org/64705
13:29:26 <dreixel> rasfar: http://hpaste.org/64705 ?
13:29:30 <jmcarthur> plat0: it's not always clear whether it's better to store or recompute
13:29:59 <monochrom> it is better 50% of the time to flip a coin to decide :)
13:30:03 <dreixel> not entirely sure it is what you want, but it should be close. In any case, I'm sure the code could look nicer.
13:30:17 <monochrom> don't laugh, 50% is way better than most human judgements!
13:32:18 <plat0> If you run out of memory, surely just freeing something is better than crashing?
13:32:33 <plat0> But I agree, it's a hairy situation.
13:32:47 <plat0> Thanks jmcarthur for explaining.
13:34:58 <rasfar> dreixel: Thanks a lot!  I will be reading that with interest (probably for a while...)
13:35:24 <rasfar> now i'm off to make the print shop before 5 if possible; bye for now...
13:36:05 <jmcarthur> plat0: perhaps for some applications it's better to crash and start over than to get into a loop where you throw away and recompute work
13:39:42 <monochrom> "freeing something" may first require yet more memory for a moment. "crash" instantly frees everything
13:40:41 <monochrom> the typical dilemma of killing a fork-bomb: first you need to fork one more process, the killer!
13:42:59 <shurikas> @hoogle String -> Html
13:43:00 <lambdabot> Text.Html afile :: String -> Html
13:43:00 <lambdabot> Text.XHtml.Strict afile :: String -> Html
13:43:00 <lambdabot> Text.XHtml.Frameset afile :: String -> Html
13:47:02 <tzxn3> thanks doserj :)
13:47:28 <DanBurton> @hoogle toHtml
13:47:29 <lambdabot> Text.Html toHtml :: HTML a => a -> Html
13:47:29 <lambdabot> Text.XHtml.Strict toHtml :: HTML a => a -> Html
13:47:29 <lambdabot> Text.XHtml.Frameset toHtml :: HTML a => a -> Html
13:55:33 <monad_> Do you know how to set the locale in a gtkhs app, i.e. set the application language? I tried to set environment variable LC_CTYPE but without access?
13:56:36 <monochrom> LANG
13:56:56 <monochrom> perhaps there are more
13:58:00 <monad_> I also set LANG, but still the same problem
13:59:40 <geekosaur> LC_CTYPE only affects sorting.  LANG and LC_ALL are the usual ones (LANG should trump LC_ALL) but you may need to check for Gtk-related locale calls also
14:00:21 <geekosaur> (and ou're not going to get much localization if you haven't done the localization stuff in your own app, i.e. provided translations for your own strings)
14:01:28 <monad_> I know
14:01:43 <monad_> I just want to replace the default texts in the gtk-dialogs
14:02:40 <monad_> I have set "setEnv "LANG" "de_DE.UTF-8" True" before and after initGUI, but still no effect
14:02:49 <monad_> setEnv is part of System.Posix.Env
14:03:09 <monad_> strange...
14:03:32 <geekosaur> if you are using ghc7, the locale will have been initialized by the ghc runtime already, it's too late
14:03:57 <monad_> I dont use ghc7
14:04:08 <monad_> I use 6.12.3
14:04:53 <geekosaur> 6.12.3 already has GHC.Encoding so it's still too late, looks like
14:05:34 <monad_> and what to do else?
14:05:44 <monad_> I also set the env-variables on shell
14:06:13 <geekosaur> that's where you should be doing it.  so, probably the envars aren't sufficient and you need to check for gtk+ level functions
14:06:32 <geekosaur> in general I've found that you need to have both the standard gtk+ docs and the gtk2hs docs to do stuff like this
14:07:12 * geekosaur not exactly a gtk+ l10n expert though...
14:07:48 <monad_> ok
14:12:58 <geekosaur> (I in particular never looked to see how to use gettext from gtk2hs; the convention in other languages is a wrapper function named "_", but obviously that doesn't fly in haskell)
14:14:52 <alkabetz`> I've got a type T which has several data constructors.  What's the best way for me to let code outside the module to be able to pattern-match against the data constructor used to construct a T, but not against the arguments passed to that data constructor?
14:14:55 <ddarius> > let __ = id in __ "foo"
14:14:56 <lambdabot>   "foo"
14:15:00 <ddarius> > let __ = id in __"foo"
14:15:01 <lambdabot>   "foo"
14:16:01 <geekosaur> that is the easiest workaround, just gotta remember it :)
14:16:16 <monad_> geekosaur: but i18n in gtk is such a basic thing! I wonder why I can't find anything on that topic
14:16:17 <geekosaur> (and watch out for the folks trying to implement agda-ish "holes" :)
14:18:14 <doserj> alkabetz`: if the constructors are in scope, code can pattern-match and extract the arguments. If you don't want that, you can hide the constructors and export helper functions in the isJust, isNothing, etc. style
14:20:18 <alkabetz`> doserj: Okay--but what if I've got six or seven different data constructors, and I don't want to check for each one in turn?
14:21:13 <td123> is there a function that takes a predicate and a list and returns a tuple of elements that satisfy / don't satisfy the pred.?
14:21:22 <doserj> alkabetz`: well, what do you want to do instead?
14:21:35 <geekosaur> monad_, misisng or improper localization is *still* one of the biggest problem around :/ you can provide all the tools in the world, and programmers will ignore them because "it's faster"/thhey don't see the point --- in this case possibly meaning the folks behind gtk2hs didn't put a lot of effort into it.  in fact, I'm not seeing any reference to gettext/localization
14:21:44 <geekosaur> this is unfortunate
14:21:52 <alkabetz`> doserj: I'm thinking about defining a concrete TType data type which has data constructors corresponding to the (hidden) data constructors in T, and then writing a getTType :: T -> TType function.
14:21:52 <geekosaur> (in the gtk2hs docs that is)
14:21:59 <Enigmagic> td123: partition probably does the closest thing
14:22:15 <Enigmagic> :t partition
14:22:15 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:22:20 <doserj> alkabetz`: that's possible, yes.
14:22:37 <td123> Enigmagic: ya partition is the one I'm thinking about thanks
14:22:49 <td123> I also just found it on hoogle by searching the type :P
14:23:00 <alkabetz`> doserj: Okay, thanks.
14:23:11 <monad_> geekosaur, but gtk should support it, maybe it's possible to call some c-gtk functions via FFI
14:25:14 <geekosaur> I think getttext might already be on hackage
14:25:40 <monad_> geekosaur: This sounds interesing http://www.ibm.com/developerworks/opensource/library/os-gtk2/index.html
14:25:56 <monad_> geekosaur: There exists a packaged named hgettext
14:26:00 <geekosaur> it's the lack of either integration or even mention (when most gtk+ docs are good about mentioning how localization should be built into an app fromt he start)
14:26:40 <monad_> geekosaur: I dont want to use gettext if possible, because my application should be portable (windows support is said to be bad)
14:28:17 <edwardk> geekosaur: i have some localization and internationalization code for dealing with gettext through template haskell, don't think i've put it on hackage though
14:28:19 <geekosaur> monad_, gettext is *how* you localize gtk apps
14:32:23 <monad_> geekosaur: This sounds also good http://hackage.haskell.org/packages/archive/hgettext/0.1.3/doc/html/src/Text-I18N-GetText.html
14:37:32 <ddarius> edwardk: Want your books?
14:37:36 <hpaste> “_fh_” pasted “fltt” at http://hpaste.org/64711
14:37:39 <magicman> Haplo is scheduled between Tue Mar 06 20:00 EST and Tue Mar 06 21:59 EST.
14:40:05 <_fh_> hello everybody, I implemented this: http://tinypic.com/view.php?pic=35cj2tt&s=5 algorithm with this: http://hpaste.org/64711 code but it doesn't feel elegant, particularly the defition of Literals, what would an expert haskeller do differently?
14:41:44 <magicman> wtf... Sorry for that.
14:42:06 <magicman> Apparently that happens when someone in the designated channel triggers the script, and someone in another channel says something at the same time >_<
14:50:17 <hpaste> DanBurton pasted “Parser infinite loop” at http://hpaste.org/64713
14:50:33 <DanBurton> would anyone care to answer a Parsec question?
14:50:55 <DanBurton> I have parsers that are getting caught in an infinite loop, and I'm not sure how to express it any other way
14:51:12 <asdadsalkj> I can try, I'm just starting out myself
14:51:50 <DanBurton> exprP' can be a projectionP, which starts with a projLHS, which can be an exprP'. I think that's why I'm getting an infinite loop
14:52:23 <DanBurton> the code is in that hpaste ^
14:52:40 <asdadsalkj> Yup. And you're trying to figure out how to rewrite it?
14:52:46 <DanBurton> yeah
14:53:14 <DanBurton> I want the LHS of a projection (foo.bar) to be any valid self-contained expression, including projections (e.g. foo.bar.baz)
14:53:41 <DanBurton> foo.bar.baz should be parsed like (foo.bar).baz
14:53:48 <geekosaur> that's an infinite loop all right :)
14:53:49 <MostAwesomeDude> StateT question. I want to do a sort of stateful map; I have a list of objects which have Maybe some stuff, and I want to fill that stuff in for the objects with Nothing by carrying over left-to-right. Is StateT the right thing?
14:55:08 <asdadsalkj> thinking
14:55:08 <DanBurton> MostAwesomeDude: StateT might be overkill imho, but could probably get the job done
14:56:16 <asdadsalkj> sounds like you could do with a base case that defines what the smallest project would be
14:56:19 <asdadsalkj> projection*
14:56:31 <MostAwesomeDude> DanBurton: Is there some function I've missed for doing these kinds of maps where I can see the previous or next item during the map?
14:56:54 <DanBurton> MostAwesomeDude: no, it's not built in, but you could build it yourself
14:57:01 <geekosaur> DanBurton, refactor so exprP' checks for the '.', instead of projectionP trying to parse an exprP' first thing (which is the loop)
14:57:07 <whittle> I’m working my way through _Real World Haskell_ and got to the point in Chapter 4 where foldl is implemented as a special case of foldr. Looking at the implementation they give, I realized that I don’t understand the semantics of function application in Haskell. (I did read the suggested subsequent section on partial function application and currying, but it didn’t answer my questions.) Is there a resource that expla
14:57:08 <whittle> ins function application in a little more detail?
14:57:41 <MostAwesomeDude> DanBurton: Is there some idiom for it? I'd totally rather use State if there's nothing more obvious or recommended.
14:57:54 <quintessence> MostAwesomeDude: you can map over zip xs (tail xs)
14:58:05 <DanBurton> that's what I was thinking too ^
14:58:25 <MostAwesomeDude> quintessence: Okay, that's pretty snazzy. That'd work.
14:58:52 <MostAwesomeDude> And if I needed more tokens of lookahead, I could extend that appropriately.
14:59:07 <DanBurton> geekosaur: how exactly can I check for '.' in exprP', without going into an infinite loop looking for an exprP' first?
14:59:16 <asdadsalkj> whittle: what part do you not understand? LYAH is a good haskell tutorial
14:59:28 <parcs`> DanBurton: chainl1 looks useful here
15:00:14 <DanBurton> parcs`: mmm yes that could do the trick
15:01:02 <parcs`> try using parsec's combinators as much as possible, especially when you think you're going to deal with left recursion
15:01:04 <DanBurton> I hate to make a chain of projections a special case, but if it works it works
15:01:14 <parcs`> eventually you'll somehow find a solution :P
15:01:43 <DanBurton> I might switch my appP to use chainl1 as well
15:02:00 <parcs`> yeah
15:02:08 <MostAwesomeDude> Oh balls. I have to grab the last previous token satisfying a pattern match.
15:02:15 <MostAwesomeDude> Guess it's State time after all.
15:02:17 <whittle> asdadsalkj: I understand that Haskell functions very frequently return functions, but when I see "myFoldl f z xs = foldr step id xs z" I can’t figure out which arguments are getting applied to what functions.
15:02:50 <ddarius> whittle: Application is left associative.  That's all there is to it.
15:03:30 <DanBurton> amusing how both conversations are about left-associative chaining :)
15:03:34 <asdadsalkj> :D
15:04:20 <asdadsalkj> whittle: look at the type signatures for the functions using :t <function name> in ghci
15:04:29 <asdadsalkj> that might make things clearer
15:08:28 <hpaste> “Jason Whittle” pasted “myFoldl” at http://hpaste.org/64715
15:09:38 <asdadsalkj> So, myFoldl takes three arguments
15:09:46 <asdadsalkj> The first one is a function that takes two arguments
15:09:56 <asdadsalkj> The third one is a list
15:10:03 * hackagebot digamma 0.1 - A robust implementation of the digamma function  http://hackage.haskell.org/package/digamma-0.1 (BenGamari)
15:11:11 <whittle> asdadsalkj: Just like the prelude function it’s apeing.
15:11:21 <asdadsalkj> Right
15:12:24 <whittle> asdadsalkj: But foldr’s first argument should have type (a -> b -> b), right?
15:13:41 <rostayob> edwardk: is trifecta worth studying (since there is no documentation)?
15:14:33 <asdadsalkj> whittle: right
15:14:34 <Jafet> "Read the paper"?
15:14:46 <Jafet> Well, there doesn't seem to be a paper either
15:14:48 <asdadsalkj> let me rewrite the types and hopefully it will be clearer
15:15:42 <quintessence> whittle: here the type variable b in foldr's type gets instantiated with a function type
15:15:47 <rostayob> Jafet: no paper eeh
15:15:54 <hpaste> “Ill Logic” pasted “Functional Dependencies Conflict with flexible” at http://hpaste.org/64716
15:16:59 <quintessence> whittle: so "foldr step id xs", which is foldr applied to the normal number of arguments, gives you back a function which you can apply to z
15:17:45 <ill> You know as I was describing the problem I think I started to figure it out.
15:18:03 <geekosaur> ill?  if that's you with the Ill Logic paste, yes, that's a conflict, since you told it there are instances from a given a to both Integer and Float, but the fundeps say that any given a has a specific possible b
15:18:04 <shurikas> > :)
15:18:05 <lambdabot>   <no location info>: parse error on input `:'
15:18:32 <geekosaur> s/a given a/some particular a/
15:18:47 <geekosaur> (confusing descriptions, I has them)
15:20:20 <whittle> quintessence: So if foldr :: (a -> b -> b) -> b -> [a] -> b, b has the same type as id (id :: a -> a).
15:21:11 <ill> geekosaur: I was assuming that somehow I could restrict it to all a where it's part of an instance of B. but then I realized there's noting stopping me from making multiple of those which ultimately break the dependency.
15:21:37 <geekosaur> the part you miss there also is that context plays no role in selecting instances
15:22:00 <whittle> quintessence: Which would then mean that step :: a -> (a -> a) -> (a -> a)?
15:22:30 <quintessence> whittle: the 'a' in id and the 'a' in foldr are different type variables
15:22:50 <quintessence> So in this case foldr is being used at the (more specific) type (a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b)
15:22:55 <whittle> quintessence: Right, sorry.
15:23:55 <whittle> So step :: a -> (b -> b) -> (b -> b)
15:24:20 <asdadsalkj> wow, this could have done with some parenthesis
15:24:27 <asdadsalkj> I am equally lost now
15:24:52 <whittle> But then, why does step take 3 arguments?
15:25:27 <quintessence> -> associates to the right, so a -> (b -> b) -> (b -> b) is the same as a -> (b -> b) -> b -> b
15:25:34 <edwardk> rostayob: yes. just treat it like parsec with typeclasses. most of the stuff is in the same places
15:25:36 <edwardk> gotta run
15:25:49 <whittle> quintessence: Ah!
15:26:01 <quintessence> it might me more clear if you write step x g = \a -> g (f a x)
15:26:02 <whittle> Ah ha!
15:26:45 <whittle> quintessence: You’re right, the lambda makes it much clearer.
15:28:15 <ill_logic> geekosaur: So, what if I put the same dependency on B? That would mean that no two a's would ever point to the same b, which should translate to respecting the same thing in A.
15:28:36 <hpaste> DanBurton annotated “Parser infinite loop” with “chainl1 worked like a charm” at http://hpaste.org/64713#a64717
15:28:37 <ill_logic> Maybe that has to do with your point about not selecting the instance, which I'm still not sure I've digested.
15:29:29 <whittle> And since the first argument to foldr describes the operation to perform on the head and tail of the list...
15:29:31 <ill_logic> (Doing so doesn't work, as you probably know)
15:31:26 <whittle> Wait, I got lost again.
15:33:37 <quintessence> @pl \x g a -> g (f a x)
15:33:37 <lambdabot> flip (.) . flip f
15:34:02 <hpaste> “Ill Logic” pasted “Functional Dependencies Conflict with flexible” at http://hpaste.org/64718
15:34:35 <asdadsalkj> jesus
15:34:45 <asdadsalkj> Am I the only one that thinks this is a super confusing example
15:34:51 <ill_logic> Same result. Given that I put the same dependency on B, I don't see why it wouldn't work. But maybe GHC isn't that good yet.
15:34:53 <asdadsalkj> for chapter 4 of an intro book
15:35:07 <Sgeo_> asdadsalkj, hm?
15:35:17 <geekosaur> ill_logic, the context cannot help pick an instance
15:35:24 <geekosaur> doesn't matter what you do it or
15:35:27 <geekosaur> er, do to it
15:35:34 <asdadsalkj> Sgeo_: myFoldl f z xs = foldr step id xs z
15:35:34 <asdadsalkj>     where step x g a = g (f a x)
15:36:01 <asdadsalkj> a definition of my foldl using foldr
15:36:33 <stulli> asdadsalkj: To be fair, they state that it's not trivial IIRC
15:36:46 <whittle> Sgeo_: I’m working my way through _Real World Haskell_ and got stumped by it, so I came here for help.
15:37:00 <parcs`> DanBurton: nice :) but instead of 'foo >> return Bar', use 'Bar <$ foo'
15:37:12 <whittle> quintessence and asdadsalkj have been kind enough to walk me through some basics.
15:37:18 <parcs`> also consider using Text.Parsec.Token
15:37:24 <asdadsalkj> while getting confused in the process :P
15:38:19 <geekosaur> ill_logic, in fact, I cant figure out what you think you are doing, those instances will always conflict as far as I can tell
15:41:11 <ill_logic> geekosaur: well this is the essence of a bug I get in a larger project where it makes sense (to me) to do this. on its own it seems rather pointless.
15:42:00 <DanBurton> parcs`: yeah I need to learn me some applicative magicks
15:42:20 <xil> hey everyone. Is there a way to map something onto the elements of a Data.Map but rather than returning a new map, return a list? Something like "elems $ Map.map myfunc mymap' but which doesn't pass through the data twice?
15:42:55 <DanBurton> if you want the result to be a list, just use toList
15:43:02 <ill_logic> geekosaur: but basically I want to be able to declare instances of B. For those where the second type is Integer, I want it to also implement A in the first way. for Float, the other way.
15:43:14 <exFalso> xil: if you toList first then ghc will probably deforest the map
15:43:16 <xil> DanBurton: well I'd specifically like the list to be in order of the keys
15:43:39 <xil> why not just elems?
15:43:39 <DanBurton> > Map.empty
15:43:40 <lambdabot>   Not in scope: `Map.empty'
15:43:43 <DanBurton> > M.empty
15:43:44 <lambdabot>   fromList []
15:43:46 <ill_logic> geekosaur: I could add an example of what I just said if that's confusing.
15:44:02 <Cale> ill_logic: instances are selected entirely based on the structure of the types involved, and not on which other instances are present
15:44:04 <asdadsalkj> I'm still confused about this myFoldl implementation
15:44:10 <geekosaur> ill_logic, as I understand it, the whole point of a functional dependency is that it's determined by its use; you cannot declare it that way
15:44:28 <asdadsalkj> we are using a function as the accumulator to foldr
15:44:30 <Cale> ill_logic: (that is, you can't affect the decision of which instance applies with class constraints on the instances, those are applied afterward)
15:44:31 <geekosaur> (that is what makes it "functional")
15:44:35 <exFalso> :t elems
15:44:36 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
15:44:41 <exFalso> :t Map.elems
15:44:42 <lambdabot> Couldn't find qualified module.
15:44:51 <asdadsalkj> so it returns a function
15:44:55 <xil> :t M.elems
15:44:55 <lambdabot> forall k a. M.Map k a -> [a]
15:44:58 <Cale> The reason is that you can always add instances of classes in future modules
15:45:12 <Cale> (or siblings imported into the same project)
15:45:21 <exFalso> ah yeah elems is good too
15:45:26 <asdadsalkj> But it's also used as the second argument to `f`, which has a type (a -> a -> a)
15:45:29 <ill_logic> Cale: Right, but I can't think of any way I can add instances of A or B that would create a contradiction.
15:45:34 <asdadsalkj> So the second argument is *not* a function
15:45:35 <ill_logic> Given the restrictions I've put in.
15:45:37 <asdadsalkj> wtf
15:45:50 <xil> exFalso: elems is described to guarantee the elements be in key order, which I need. So I'll do that then, thanks =]
15:46:01 <Cale> ill_logic: Well, you said that the type a determines the type b
15:46:13 <exFalso> map myfunc . elems
15:46:13 <Cale> ill_logic: and in the first instance, any type a might apply
15:46:18 <Cale> and same for the second
15:46:19 <exFalso> xil: ah ok
15:46:30 <Cale> So for example, A Char Integer, and A Char Float
15:46:48 <Cale> which conflicts with the functional dependency
15:47:07 <Cale> a is supposed to determine b uniquely
15:47:11 <xil> exFalso: though I'd assume that the toList instance for Data.Map IS elems
15:47:21 <Cale> but the first instance says "any type a determines b = Integer"
15:47:30 <exFalso> xil: toList returns the keys too
15:47:32 <Cale> and the second instance says "any type a determines b = Float"
15:47:34 <exFalso> :t M.toList
15:47:34 <lambdabot> forall k a. M.Map k a -> [(k, a)]
15:47:38 <Cale> and those don't agree
15:48:00 <xil> interesting
15:48:07 <Cale> ill_logic: does that make sense?
15:48:23 <ill_logic> Cale: Well, if A Char Integer and A Char Float were created directly, they would cause an error in their own right, regardless of B. If however they were created via B and thus via these two instances, the compiler would stop it first because it violates the same restriction in B.
15:48:37 <asdadsalkj> whittle: http://stackoverflow.com/questions/6172004/writing-foldl-using-foldr
15:48:43 <Cale> ill_logic: well, I'm saying, you have implicitly created both of those instances
15:49:02 <asdadsalkj> dons has a great answer
15:49:04 <ill_logic> Cale: so I guess I should say, I can't think of any instances that would create a contradiction here that wouldn't create a contradiction for "higher" reasons already
15:49:41 <whittle> asdadsalkj: Awesome, well spotted.
15:49:51 <ill_logic> (just to be clear, I know I'm probably ultimately wrong, I'm mostly trying to learn exactly why, I don't mean to be stubborn or anything)
15:49:54 <Cale> The process of instance resolution can't see the "(B a Integer) =>" and "(B a Float) =>" constraints
15:49:58 <geekosaur> ill_logic, I think you're still not getting it.  what you wrote *is* a conflict, period.
15:50:08 <geekosaur> not "might be".  IS.
15:50:17 <Cale> Yes
15:50:54 <Cale> The first instance you wrote says that for any type a, we have that the corresponding unique choice of b is Integer
15:51:01 <exFalso> ill_logic: in trivial cases you can get around this by using OverlappingInstances
15:51:01 <Cale> The second instance you wrote says that for any type a, we have that the corresponding unique choice of b is Float
15:51:14 <exFalso> not in this case though...
15:51:45 <Cale> and that's not very unique then is it? :)
15:52:09 <Cale> If there are two possibilities for b for a given choice of a, then the functional dependency doesn't hold.
15:52:10 <ill_logic> Cale: And you're saying that it doesn't look into B to put any restrictions on what a can be.
15:52:15 <ddarius> Java brings hate into the world.
15:52:20 <Cale> ill_logic: that's true
15:52:36 <whittle> I hear the dinner bell ringing. asdadsalkj and quintessence, thank you both for your help. Much appreciated.
15:52:44 <Cale> ill_logic: But even if it did, there's no way it could prove that there *aren't* instances of B a Integer and B a Float
15:52:44 <asdadsalkj> np
15:53:01 <Cale> ill_logic: You can never assume that there *aren't* instances of a class.
15:53:16 <Cale> (because future modules which you haven't compiled yet can add them)
15:53:44 <BMeph> "Fear leads to anger. Anger to hatred. Hatred, leads to...Java?" ;)
15:54:00 <Cale> Seems backwards.
15:54:12 <Jafet> "Java makes me lose sleep"
15:54:18 <ill_logic> Cale: Well that's where the "maybe" thing that geekosaur said comes in. As I said before, if you add such a contradictory instance, it would be caught by the restrictions of B before it it would be able to trip into these instances.
15:54:20 <Cale> Java most definitely leads to anger and hatred ;)
15:54:39 <ill_logic> Or so I would imagine.
15:54:50 <Cale> B is unconstrained though
15:54:51 <ill_logic> I mean, it seems to me to logically follow that it would.
15:54:53 <DanBurton> Java leads to fear. Fear leads to anger. Anger to hatred. And then you either go insane or pick up Haskell instead.
15:55:04 <ill_logic> Cale: in my first hpaste it is unconstrained.
15:55:09 <ill_logic> I posted a second one with a constraint.
15:55:13 <geekosaur> again:  selecting an instance brings the constraint into scope.  the constraint cannot apply before the instance is chosen
15:55:17 <ill_logic> http://hpaste.org/64718
15:55:44 <exFalso> a class constraint is not a constraint that is used to resolve instances
15:57:17 * ski str some mailing-list (or trac ?) post discussing how to use instance constraints in resolving
15:57:21 <exFalso> a constraint would be something like
15:57:21 <exFalso> instance A (Identity a) Integer
15:57:36 <exFalso> where Identity puts a constraint on the type
15:57:55 <ill_logic> Identity being a parametric type or a typeclass?
15:58:14 <ski> the former
15:58:24 <exFalso> its a parametric type
15:58:46 <exFalso> a more common example is
15:58:46 <exFalso> instance A (a -> b) Integer
15:59:57 <ill_logic> Cool. Well, at the very least I understand the point that GHC isn't going to look back at B to figure out restrictions on a.
16:00:32 <ill_logic> The fact that what I've written (including the restriction in B) doesn't follow at least logically is still a mystery to me, but perhaps I can figure it out after some thought.
16:00:44 * ski idly wonders whether matthiasgorgens mispasted some large thing
16:01:01 <ill_logic> gtg for now, but thanks a lot geekosaur Cale exFalso
16:02:14 <davidd`> is it possible to define functions in ghci?
16:02:22 <ski> yes
16:02:24 <davidd`> every example I see calls for :l file
16:02:29 <ski> but you must prefix with `let'
16:02:38 <davidd`> ahh cool
16:02:52 <ski> it's more common to put them in files, and load those though
16:03:18 <DanBurton> you have to think of ghci as being inside a big IO do block
16:03:32 <ski> (for multiple lines, you can either use `;', possibly also `{' and `}' .. or you can use `:{' and `:}' in GHCi)
16:03:33 <DanBurton> it inserts an implicit "print" in front of non-IO expressions
16:05:25 <davidd`> oh cool
16:06:12 <davidd`> is haskell pretty succinct compared to other functional programming languages?
16:08:43 <stephenjudkins> davidd`: okasaki's "purely functional data structures" has most examples in ML with an appendix with Haskell translations
16:09:19 <davidd`> ok, I'll check it out
16:09:20 <stephenjudkins> they seem close to equal in brevity
16:10:12 <dolio> Although it is an ML extended with features that it doesn't have, because Okasaki needed them. :)
16:11:11 <stephenjudkins> dolio: i was excited about how he was doing memoization
16:11:29 <stephenjudkins> but then I when I got to that chapter it was sort of hand-wavy... "assume we are using ML with built-in memoization"
16:11:57 <dolio> Well, you could probably do it by hand, but it'd be ugly.
16:11:59 <stephenjudkins> none of the clever functional magic I expected
16:12:00 <quintessence> stephenjudkins: it's pretty easy to build with ML using references and lambdas, it's just ugly
16:12:08 <dolio> And there are no general macros to hide the ugliness.
16:12:41 <dolio> That is, there's no standard ML macro language.
16:13:17 <stephenjudkins> i was trying to add memoization to the y-combinator implementation I derived in Scala using only immutable data structures
16:13:43 <stephenjudkins> i eventually gave up and just used a mutable one.
16:14:09 <stephenjudkins> but i'd like to see how that would be done in Haskell
16:15:42 <ski> indirecting through an array or some other datastructure is common
16:32:25 <jerojasro> hi all. why does this code doesn't work? https://gist.github.com/1969435 ghci says y is not on scope
16:33:11 <monochrom> second where belongs to "z = a" only
16:33:22 <quintessence> jerojasro: "where" attaches to a definition, not a group of definitions
16:33:42 <monochrom> similarly, first where belongs to "cosa = x + z" only
16:33:51 <jerojasro> quintessence: so I should use let ... in, right?
16:34:11 <monochrom> you wouldn't expect "hi = z; cosa = x + z where z = ..." to make sense, would you?
16:34:52 <monochrom> let-in does not make a difference
16:34:57 <ski> (an SML-style `local <decls> in <decls> end' would have worked)
16:35:43 <monochrom> perhaps you should use just one level of where
16:35:55 <jerojasro> quintessence: thanks
16:36:37 <ski> > let cosa = x + z where (x,z) = (y,a) where (y,a) = (2,3) in cosa  -- also works, but may not be easy to do in more complicated situations
16:36:38 <lambdabot>   5
16:37:20 <jerojasro> ski: heh, nice
16:37:29 <jerojasro> kind of cheating, though ;)
16:37:34 <ski> yeah
16:37:38 <monochrom> ok, so I am completely invisible.
16:37:52 * DanBurton sees right through monochrom
16:37:52 <ski> seems you really want a `local <decls> in <decls> end' thing -- but Haskell doesn't have that
16:38:08 <ski> did someone say something ?
16:38:46 <jerojasro> ski: but it kinda does (what little haskell I know)
16:38:53 <jerojasro> let .. in let ... in ...
16:39:00 <ski> no
16:39:09 <jerojasro> https://gist.github.com/1969454
16:39:10 <ski> `let <decls> in <expr>' is an expression
16:39:21 <ski> `local <decls> in <decls> end' in SML is a declaration
16:39:45 <jerojasro> well, I need an expression anyway
16:42:40 <ski> well, if Haskell had this, you could have written it something like
16:42:48 <ski>   local
16:42:54 <ski>     local
16:43:01 <ski>       y = 2
16:43:08 <ski>       a = 3
16:43:12 <ski>     in
16:43:20 <ski>       x = y
16:43:25 <ski>       z = a
16:43:29 <ski>   in
16:43:32 <ski>     cosa = x + z
16:44:11 <jerojasro> mmm, I see the difference
16:44:17 <ski> this would make sure that, of the local bindings, only `x',`z' (not `y',`a') is in scope for the `cosa' binding
16:44:31 <ski> `y',`a' only being in scope for the `x',`z' bindings
16:46:35 <ion> It would be nice to have that in Haskell.
16:46:53 * ski nods
16:47:49 <ion> instance Foo Bar where { local { bar = … } in { method definitions that have access to the local “bar” } }
16:48:13 * jerojasro is barely on chapter 3 of real world haskell, so he can't give an informed opinion
16:48:15 <ski> aye
16:51:04 <quintessence> How often does that get used in ML?
16:51:27 * ski doesn't know
16:51:39 <ski> i'm relatively often missing it in Haskell, though
16:51:44 <quintessence> I guess you might use it for local shared state
16:52:43 <ski> (if you want, you could ask about it in #sml)
16:53:01 <Axman6> > let ave xs = sum xs / (fromIntegral . length $ xs) in ave [1..10000]
16:53:02 <lambdabot>   5000.5
16:53:05 <Axman6> > let ave xs = sum xs / (fromIntegral . length $ xs) in ave [1..1000000]
16:53:07 <lambdabot>   *Exception: stack overflow
16:53:18 <Axman6> > let ave xs = sum xs / (fromIntegral . length . map id $ xs) in ave [1..1000000]
16:53:20 <lambdabot>   *Exception: stack overflow
16:54:11 <ivanm> Axman6: you need to merge the two folds into one!  I thought you would have known that by now! :p
16:55:20 <rostayob> quintessence: local is quite used in SML
17:15:23 <Axman6> ivanm: i do, but i was interested to see if the map id making a new list would help, but obviously not
17:15:55 <shachaf> Axman6: No, the reference to the old list will still be kept around.
17:20:07 * hackagebot netclock 0.3 - Netclock protocol  http://hackage.haskell.org/package/netclock-0.3 (AlexMcLean)
17:23:09 <nejucomo> I often run into undecidable instances, and I never quite understand the problem.  I have: instance A t => b t   -what is wrong with this?
17:23:21 <nejucomo> Sorry: instance A t => B t where ...
17:23:33 <Enigmagic> Axman6: does that actually make a new list?
17:24:03 <nejucomo> Every function in B can be translated unambiguously to those of A, so it seems sensical to me.
17:24:46 <nejucomo> Maybe I should take more time to understand http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances
17:26:53 <ski> nejucomo : what if you also add an `instance B t => A t where ..' ?
17:27:22 <nejucomo> Ah, that helps.  ;-)
17:28:01 <quintessence> nejucomo: UndecidableInstances just means "I promise instance resolution will terminate, don't kick me if you can't see why"
17:28:47 <nejucomo> So if I use UndecidableInstances and it just so happens by luck that nothing declares instance B t => A t, then it will compile?
17:30:18 <Enigmagic> basically
17:30:44 <quintessence> Pretty much.  Though in your case as long as you have some instance of A, nobody can declare an instance B t => A t without overlapping it
17:36:50 <mgsloan> egads, what have I done! Main> ((,,,) $><<< (*9)) 1 2 3 4;    (2,3,4,9)
17:37:46 <mgsloan> it's awful, but beautifully pointless.  680 TH-generated operators later..
17:38:22 <scooty-puff> is it possible to disable warnings in a more finegrained way?
17:38:28 <scooty-puff> more finegrained than per module
17:43:28 <DanBurton> erm...not that I'm aware of
17:44:03 <mgsloan> 39 == ((*) $^<>> (+) $><<< (*9)) 1 2 3 4 == (\a b c d -> c * (d + (a * 9))) 1 2 3 4
17:44:05 <byorgey> mgsloan: o.O
17:44:18 <mgsloan> welcome to excessively pointless plumbing operators :)
17:44:32 <byorgey> mgsloan: that's... terrifying
17:44:32 <DanBurton> you should put it on hackage
17:45:02 <mgsloan> byorgey - they'll be much nicer once there's a more visual representation :D
17:45:13 <quintessence> finally, a package that lets me program on a DDR pad
17:45:15 <byorgey> mgsloan: I'm sure =)
17:45:31 <byorgey> quintessence: hehehe
17:45:39 <mgsloan> :t ($^)
17:45:39 <mgsloan> ($^) :: (t2 -> t1) -> t2 -> t -> t1
17:45:39 <lambdabot> Not in scope: `$^'
17:45:45 <DanBurton> quintessence: just bind < and > to ( and ) and you're half-way to lisp programming
17:46:38 <ski> @remember mgsloan (on pointless black magic)  <mgsloan> welcome to excessively pointless plumbing operators :)  <byorgey> mgsloan: that's... terrifying  <DanBurton> you should put it on hackage
17:46:38 <mgsloan> so, $-prefixed things are always composition-ey.  ^ is const, < means pass argument to left function, > means pass to right function, & means pass to both
17:46:38 <lambdabot> It is stored.
17:47:15 <byorgey> mgsloan: it almost makes sense!
17:47:20 <byorgey> ;)
17:47:25 <DanBurton> reminds me of brainfrack
17:47:29 <mgsloan> indeed!  I have ones for tuples too ;)
17:48:04 <mgsloan> I don't think this is actually a good idea, but interesting exercise.  It was triggered by the recent discussions of introducing more convenience compositions, like .:
17:48:24 <mgsloan> and I thought, hmm, why not generate a whole family of operators
17:49:04 <ski> mgsloan : it should be possible to build them up, compositionally
17:49:23 <mgsloan> true.  Instead I just have TH build them all, generatively :)
17:49:43 <ski> i.e. one should be able to define `$^<>>' in terms of a composition of some `$',`^',`<',`>' operators
17:50:54 <parcs`> > foldl (.) id [f,g,h]
17:50:55 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:50:55 <lambdabot>    arising from a use of `...
17:51:08 <parcs`> > foldl (.) id [f,g,h] x
17:51:10 <lambdabot>   f (g (h x))
17:51:11 <mgsloan> definitely.  instead, I leave its definition pretty trivial.
17:51:11 <mgsloan>     |^<>> f1 f2 a b c d = (f1 b, f2 c d)
17:51:21 <mgsloan> $^<>> f1 f2 a b c d = f1 b $ f2 c d
17:52:29 <ski> @type ($ []) .:: (.: (:)) .: (.: (:)) . (:)
17:52:30 <lambdabot> forall a. a -> a -> a -> [a]
17:52:35 <ski> @type ($ []) .:: (.: (:)) .: (.: (:)) . (.: (:)) id
17:52:35 <lambdabot> forall a. a -> a -> a -> [a]
17:52:42 <mgsloan> I actually could see some of the lower arity operators being used by people.. but it wouldn't really help haskell's image as far as symboly operators go
17:52:50 <DanBurton> o_O since when does lambdabot have .::?
17:52:57 <mgsloan> Caleskell!
17:52:59 <ski> those are attempts at building `\a0 a1 a2 -> [a0,a1,a2]' up, in a systematic way
17:53:15 <ski> DanBurton : since just a minute ago, when i defined it
17:53:34 <parcs`> > foldr (.) id [f,g,h] x
17:53:36 <lambdabot>   f (g (h x))
17:54:36 <DanBurton> wait...what? whether you foldr or foldl, you get the same result
17:54:45 <DanBurton> shouldn't one of them be backwards?
17:55:22 <DanBurton> > foldr c id [f,g,h] x
17:55:23 <lambdabot>   Couldn't match expected type `a -> b -> b'
17:55:23 <lambdabot>         against inferred type `S...
17:55:57 <byorgey> DanBurton: no, foldr/foldl doesn't change the order of the arguments, just the associativity
17:56:06 <parcs`> foldr (.) id is f . (g . (h . id))
17:56:07 <byorgey> DanBurton: they give the same answer for any commutative operator
17:56:13 <byorgey> + its identity
17:56:21 <DanBurton> byorgey: oh right.
17:56:22 <byorgey> err, *associative, not commutative
17:56:25 <parcs`> foldl is ((f . id) . g) . h
17:56:37 <DanBurton> my brain read associative the first time
17:56:42 <byorgey> parcs`: actually ((id . f) . g) . h
17:57:07 <parcs`> ah okay
17:57:22 <byorgey> but since id is the identity element for (.) it doesn't make a difference
17:59:21 <mgsloan> haha, yeah, these are pretty difficult to program with atm
18:01:26 <mgsloan> ((:) $<>> ((:) $<> (:[]))) 1 2 3
18:03:06 <otters> :t ($<>>)
18:03:07 <lambdabot> Not in scope: `$<>>'
18:03:28 <mgsloan> otters: my own, wacky operators
18:03:38 <otters> you're telling me
18:03:40 <otters> :t (:[])
18:03:41 <lambdabot> forall a. a -> [a]
18:03:56 <aristid> otters: that's just a section
18:04:02 <otters> I know
18:04:17 <ski> mgsloan : does that work ?
18:04:23 <mgsloan> ski - yup
18:05:16 <mgsloan> currently the ops are infixl, but infixr would make that code have one less pair of parens
18:05:49 <mgsloan> I think infixl makes more sense, even though it deviates from composition, as it's more like reading a stack machine backwards
18:05:57 <ski> mgsloan : and for four elements ?
18:06:17 <ski> (i.e. how to extend it in a straight-forward way)
18:07:00 <ski> (seeing has that uses both `$<>>' and `$<>', instead of only one of them, it's not easy to guess how to extend)
18:07:57 <mgsloan> ((:) $<>>> ((:) $<>> ((:) $<> (:[])))) 1 2 3 4
18:08:47 <mgsloan> or, when made infixr, ((:) $<>>> (:) $<>> (:) $<> (:[])) 1 2 3 4
18:08:54 <ski> ok, ty
18:09:04 <mgsloan> I only went up to arity 4
18:09:31 <ski> (could you separate `(:[])' into a `(:)' and a `[]', for uniformity ?)
18:09:53 <mgsloan> ((:) $<>>> (:) $<>> (:) $<> (:) $< []) 1 2 3 4
18:10:09 * ski claps
18:10:12 <mgsloan> :)
18:10:26 <Jafet> [,,,] 1 2 3 4
18:10:48 <ski> @type [,,,]
18:10:49 <lambdabot> parse error on input `,'
18:11:02 <aristid> well that's Jafetskell
18:11:03 * Jafet points and laughs
18:11:05 <mgsloan> *Main> ((:) $>>>< (:) $>>< (:) $>< (:) $< []) 1 2 3 4
18:11:06 <mgsloan> [4,3,2,1]
18:11:34 <mgsloan> or any permutation thereof, of course
18:12:01 <aristid> :t (:) . :()
18:12:02 <lambdabot> parse error on input `:'
18:12:06 <aristid> :t (:) . (:)
18:12:07 <lambdabot> forall a. a -> [[a] -> [a]] -> [[a] -> [a]]
18:12:17 <mgsloan> any permutation / subset can be made just by changing those operators
18:14:07 <joe9> Is "cabal install world" good enough after a ghc upgrade?
18:14:16 <ski> mgsloan : hehe :)
18:14:55 <ski> > (($ []) .:: (.: (:)) .: (.: (:)) . (.: (:)) id) 0 1 2
18:14:57 <lambdabot>   [0,1,2]
18:15:27 <ski> > (($ []) .::: (.: (:)) .:: (.: (:)) . (.: (:)) . (.: (:)) id) 0 1 2 3
18:15:28 <lambdabot>   No instance for (GHC.Num.Num [a])
18:15:28 <lambdabot>    arising from a use of `e_10123' at <in...
18:15:45 <ski> > (($ []) .::: (.: (:)) .:: (.: (:)) .: (.: (:)) . (.: (:)) id) 0 1 2 3  -- oh
18:15:46 <lambdabot>   [0,1,2,3]
18:16:06 <MaskRay> where is the magical .: defined?
18:16:11 <ski> in lambdabot
18:16:31 <ski>   (.:) = (.) . (.)
18:16:33 <ski> aka
18:16:43 <ski>   (f .: g) a b = f (g a b)
18:17:02 <ski>   (.::) = (.) . (.) . (.)
18:17:09 <ski>   (f .:: g) a b c = f (g a b c)
18:17:11 <ski> &c.
18:17:37 <ski> (all `infixr 9', like `.')
18:18:40 <MaskRay> @src .:
18:18:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:19:13 <ski> apparently Cale hasn't entered it into lambdabot's meagre `src' database
18:22:15 <hpc> @src (.:)
18:22:15 <lambdabot> Source not found. stty: unknown mode: doofus
18:27:48 <koninkje> edwardk: ping
18:29:55 <koninkje> MaskRay: Also it's defined in pointless-fun, if you want to use it outside of lambdabot
18:33:29 * ski idly wonders who wren ng thornton is
18:34:58 <koninkje> tis I
18:35:11 <koninkje> ;)
18:37:12 <ski> koninkje : why `infixl 8' instead of `infixr 9' ?
18:37:21 * mgsloan wonders what he should call this hackage package
18:37:35 <ion> Overture also defines (.:)
18:37:56 <ski> (koninkje : also, maybe you could add my `(.::)', and maybe `(.:::)' as well ..)
18:37:58 <mgsloan> plumbing ? plumbers ? mario-plumbing? mushroom-plumbing?
18:38:23 <mgsloan> plumbing-th
18:38:25 <mgsloan> heh
18:38:41 <koninkje> because infixl 8 seemed to work a lot better / more intuitively
18:38:58 * koninkje doesn't have a good distinguishing case off hand
18:39:20 <ski> hm, i think my example above could look more ugly wihtout `infixr 9'
18:39:23 <koninkje> I tried it with infixr 9 at first, but that came out a bit weird
18:39:39 <ski> it seemed obvious to me to reuse the same as `.', when i invented it
18:40:27 <ski> (and istr some other example where i wanted that associativity, as well)
18:42:47 <koninkje> oh yes, that's why:
18:42:48 <koninkje> :t \a b c d e f -> a . b .: c . d .: e . f
18:42:49 <lambdabot> forall b a b1 (g :: * -> *) a1 b2 a2 (g1 :: * -> *) (f :: * -> *). (Functor f, Functor g1, Functor g) => (g b1 -> b) -> (a -> b1) -> (g1 b2 -> g a) -> (a1 -> b2) -> (a2 -> g1 a1) -> f a2 -> f
18:42:49 <lambdabot> b
18:43:25 * ddarius just spent hours trying to figure out how to have an activity show full sized on his phone.
18:43:58 <koninkje> With infixl 8 you get that whenever there's "... f .: g ..." it follows that g takes two arguments
18:44:19 <koninkje> whereas with infixr 9 you get a bunch of higher-order functions and other wierdness
18:44:32 <ski> ;)
18:47:36 <koninkje> ski: I find uses for (.:) all over the place, but I haven't found much motivation for (.::) etc. What sorts of idioms make you want them?
18:49:45 <ski> hm, i'm not sure they were motivated that much by idioms at all
18:50:24 <koninkje> I see :)
18:50:34 <ski> many years ago, i noticed i could pass two arguments, using `(.) . (.)', thus `(.:)' was born
18:50:58 <ski> `(.::)',&c. is just the obvious extra-polation of it
18:51:29 <koninkje> My big motivation for (.:) was that the (f .) . g idiom is nice and pervasive, but not composable in any intelligible manner
18:51:38 <ski> if you have sensible uses for any of them, then all the better :)
18:52:36 <ski> you could also do `res (res f) g' instead of `(f .) . g', conal SEC-style
18:52:53 <ski> (alternatively `(res . res) f g', i suppose)
18:53:27 <ski> `arg' and `res' are sometimes more intelligble
18:54:16 <ion> I dislike the asymmetry of (f . g) .: h = f .: (g .: h). “curry (f . g . uncurry h)” works no matter how you group the composition.
18:55:16 <parcs`> man, i wish parsec didn't require 'try's to be littered everywhere :(
18:55:57 <parcs`> perhaps i should use trifecta. i think that has sane behavior
18:56:27 <Jafet> parsec has... documentation
18:58:06 <ski> ion : interesting
18:58:26 * ski think Parsek (sic!) has sane alternatives
18:59:32 <ddarius> If you are littering try everywhere, you are probably doing it wrong.
18:59:33 <parcs`> Jafet: trifecta copies most of parsec's modules
19:02:32 <parcs`> i don't even understand when i need to use try
19:02:48 <parcs`> sometimes alternatives work without it, sometimes they don't
19:04:30 <DanBurton> try is for when two alternatives might consume the same input at first
19:04:31 <DanBurton> iinm
19:04:46 <ByronJohnson> `\la
19:04:56 <ski> in `foo <|> bar', if `foo' eats any token (not inside `try'), then it will commit to `foo', not trying `bar'
19:05:27 <ddarius> parcs`: By default Parsec commits to alternatives (if they consume anything).  Usually, you want to commit to alternatives once they start consuming stuff.  Use try when you want a more non-deterministic (backtracking) behavior.
19:06:03 <mgsloan> https://github.com/mgsloan/plumbers/blob/master/src/Data/Function/Plumbers/TH.hs
19:06:08 <parcs`> thanks, that clears things up
19:07:16 <Jafet> Oh, I assumed parcs knew what try was for.
19:07:22 <parcs`> however i have a parser 'parens p <|> braces p' (no try) and it still parses the second alternative
19:07:54 <parcs`> ie it succeeds on the input "{ <whatever p parses> }"
19:07:56 <Jafet> Perhaps the parsec haddock should point to the parser behaviour in big red text
19:07:57 <ddarius> That's because it will immediately fail without consuming anything if the input doesn't start with '('.
19:08:14 <Jafet> If big red text is possible in haddock
19:08:38 <parcs`> ddarius: that's what i thought, but i wasn't sure
19:08:44 <parcs`> thanks again
19:08:50 <ski> parcs` : because the left branch doesn't consume any token in this case, it tries the other one
19:09:16 <ddarius> Basically you can think of it as Parsec providing you one "token" of look ahead where a "token" is anything wrapped in try or a primitive token parser.
19:10:39 <ddarius> I just now came to this way of describing it, but I think it is actually an excellent description.  One of the key things about using try is that you don't want to put "large" things in a try, otherwise you easily run the risk of destroying performance.
19:11:22 * mgsloan adds one more symbol to operator soup - *.  splits tuples :)
19:11:49 <ion> Splits tuples?
19:11:52 <ddarius> "Large" is very ambiguous, for example, identifiers can be arbitrarily large but you do usually want them wrapped with try.  Thinking about it as wanting to wrap "tokens" with try to produce a LL(1) parser is a good way to always do the right thing.
19:12:06 <mgsloan> so *** in my combinator world is now a pairwise fold on tuples
19:12:09 * ski thinks `try' feels a bit like an un-cut ..
19:12:52 <mgsloan> ion - I'm making plumbing operators that provide compact expression of anything involving (.), ($), const, and (,)
19:13:02 <mgsloan> compact != good of course
19:13:10 <mgsloan> but an idea nonetheless
19:13:13 <ddarius> ("Large" more has to do with recursive structures, particularly ones that recursively use try which can easily to exponential performance.)
19:13:19 <ski> (ddarius : but yes, it sounds like a good description)
19:15:22 <ski> mgsloan : soon, you'll be reinventing APL :)
19:15:43 <mgsloan> yay!
19:16:27 <Jafet> Sadly, Haskell doesn't allow operators to be used like that
19:17:27 <bitbucket_> Why isn't the following Template Haskell function valid?  foo name = [d| $name = "foo" |]
19:17:36 <bitbucket_> I want to splice a name into the quotation, can you not do that?
19:19:43 <ddarius> It takes a lot of memory to build a string representation of a linked list when you don't move to the next element.
19:23:25 <parcs`> @tell edwardk i had some dep. issues when installing trifecta on ghc 7.4; bumping the upper bound on array to 0.5 and deepseq to 1.4 fixed them though
19:23:25 <lambdabot> Consider it noted.
19:31:02 <_Vi> What are analogues of Show and Read classes for lazy ByteStrings?
19:31:27 <ddarius> Show and Read
19:35:00 <_Vi> Expected somethings like Serializable with "serialize :: a -> ByteString"  and Deserializable with "deserialize :: ByteString -> a". Can't find things with such signatures in Hoogle.
19:35:31 <byorgey> _Vi: perhaps see http://hackage.haskell.org/package/binary
19:36:13 <koninkje> _Vi: also see http://hackage.haskell.org/package/bytestring-lexing
19:36:27 <koninkje> depending on how exactly you mean
19:38:23 <Clint> or http://hackage.haskell.org/package/cereal if you like the word Serialize
19:41:38 <_Vi> OK, thanks. Looks like Binary is the closest thing.
19:54:19 <ddarius> Now to implement the primitives.
20:12:53 <netbyte> hi!
20:25:39 <mm_freak> i have a cheaply generated list and a cheap predicate for list elements…  the goal is to find the first element with the predicate
20:25:52 <mm_freak> is there a nice way to parallelize this without losing single-thread performance?
20:26:48 <mm_freak> the list is very long and potentially does not fit in memory…  it's basically a stream
20:27:01 <Jafet> Find a cheap way to split the list
20:27:53 <Jafet> generateListFromTo
20:28:31 <mm_freak> i have a cheap way to do that, but then what?
20:29:24 <mm_freak> i think i'll try monad-par
20:29:28 <Jafet> Then parallelize that
20:29:31 <ivanm> the problem I see that if you split it into parallel, how do you guarantee that the first value returned by a thread is indeed the first element in the list that matches the predicate?
20:29:51 <mm_freak> ivanm: sorry, i wasn't clear there
20:30:02 <ivanm> oh, you just want *an* element?
20:30:02 <mm_freak> /any/ element is fine
20:30:11 <mm_freak> it doesn't have to be the first
20:30:14 * hackagebot typelevel-tensor 0.1.0.4 - Tensors whose ranks and dimensions type-inferred and type-checked.  http://hackage.haskell.org/package/typelevel-tensor-0.1.0.4 (TakayukiMuranushi)
20:30:19 <Jafet> Finding the first element is easy, you just need to wait for the current threads to finish
20:30:50 <ivanm> Jafet: what happens if two threads both return a value; how do you know which value is "first"?
20:31:58 <mm_freak> zip [0..]
20:31:59 <ivanm> mm_freak: so if nothing else, write a function Int -> [a] -> [[a]] such that given an input n, values in the input list with an index == i mod n are in result list i
20:32:03 <ivanm> mm_freak: or that
20:32:08 <ivanm> duh
20:32:30 <Jafet> ivanm: the one from the part of the list that was taken from earlier in the list
20:32:49 <mm_freak> in any case, it doesn't have to be the first element
20:33:25 <ivanm> Jafet: maybe one thread runs faster than another, so it returns a result from later in the list before the other threads return one from earlier in the list? *shrug8
20:33:34 <mm_freak> it's a search algorithm…  something i'd have written using a for loop in other languages…  the search should have O(n) space where n is the number of threads
20:34:08 <mm_freak> and the first thread to find a good element is the winner
20:34:09 <Jafet> ivanm: then as I said, you wait for the threads searching through the earlier parts of the list to finish.
20:34:36 <ivanm> mm_freak: what does it get as a prize? :p
20:35:50 <Jafet> It doesn't get terminated
20:35:58 <Jafet> Have a happy daycycle
20:36:35 <ivanm> heh
20:39:57 <edwardk> hrmm, trying to figure out a nice way to get numbers out of Data.CReal into a Double once they've been worked out with sufficient precision. the best i have right now is to ShowCReal and Read =(
20:40:29 <edwardk> realToFrac doesn't work since CReal's crash when you use toRational on them
20:40:39 <monochrom> um, oh, yikes
20:41:13 <monochrom> we desperately need multiple dispatch!
20:42:26 <edwardk> i know i only need about care about numbers between 1.0e-12 and 1, and i know i only have 52 bits of mantissa in a double, so i need ~18 digits of accuracy, + 12 for the leading zeros, so I _could_ showCReal with 30-32 digits
20:42:38 <Jafet> > toRational (pi :: CReal)
20:42:39 <lambdabot>   *Exception: CReal.toRational
20:43:22 <dolio> If you dig into the source a little, you should be able to get it to give you at least 52 bits past the decimal.
20:43:26 <Jafet> edwardk: okay, so what's wrong with showCReal
20:43:34 <dolio> Maybe that's overkill for very large numbers, though.
20:43:47 <dolio> Oh, or very small.
20:43:53 <dolio> Never mind.
20:44:45 <edwardk> > let f t = tanh (0.5 * pi * sinh t) in showCReal 30 $ f (1/64 :: CReal)
20:44:46 <lambdabot>   "0.024539763574649160378815204133"
20:44:46 <dolio> > showCReal 0.00000000000000000000000001
20:44:47 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
20:44:47 <lambdabot>    arising from the lit...
20:45:11 <ivanm> :t showCReal
20:45:12 <lambdabot> Int -> CReal -> String
20:45:16 <dolio> Ah.
20:45:21 <edwardk> jafet: like i said, (read . showCReal n) is the best i have
20:45:24 <ivanm> > showCReal maxBound 0.00000000000000000000000001
20:45:25 <lambdabot>   "*Exception: Negative exponent
20:45:28 <ivanm> heh
20:45:29 <dolio> > show (0.00000000000000000000000001 :: CReal)
20:45:29 <lambdabot>   "0.00000000000000000000000001"
20:45:31 <edwardk> but i'd like to be able to get the mantissa out and apply an exponent
20:45:48 <edwardk> but i don't think i have an exposed CReal constructor
20:45:48 <ClaudiusMaximus> > encodeFloat (42, 42)
20:45:49 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
20:45:49 <lambdabot>         against inf...
20:46:50 <edwardk> the actual function i need is that and the derivative of that
20:47:00 <dolio> > show (0.000000000000000000000000000000000000000000001 :: Double)
20:47:01 <lambdabot>   "1.0e-45"
20:47:04 <edwardk> doing the operations directly in double leave me with uncomfortable amounts of rounding error
20:47:05 <dolio> > show (0.000000000000000000000000000000000000000000001 :: CReal)
20:47:06 <lambdabot>   "0.0"
20:47:49 <Jafet> CReal uses decimal, so I doubt there is any useful mantissa to get out
20:47:50 <dolio> I guess you need to keep track of the exponent yourself if you want the right amount of information out.
20:48:00 <edwardk> and limiting the showCReal to 30ish decimal places means that if i ever expand the table to get more accuracy i'll need to rethink it
20:48:02 <edwardk> yeah
20:50:11 <edwardk> i could just preprocess the entire table and spit it out i suppose
20:50:29 <edwardk> that would save me from depending on ad & numbers
20:52:07 <edwardk> bah, and i can't showGFloat a CReal either
20:52:36 <edwardk> hrmm maybe Data.Number.Fixed?
20:58:33 <ClaudiusMaximus> > let f t = tanh (0.5 * pi * sinh t) ; g t = let e = floor (logBase 2 t) ; e' = 53 - e in encodeFloat (round (2^^e' * t)) e'   in g (f (1/64 :: CReal)) :: Double
20:58:35 <lambdabot>   8.154735188341647e33
20:59:46 <ClaudiusMaximus> > let f t = tanh (0.5 * pi * sinh t) ; g t = let e = floor (logBase 2 t) ; e' = 53 - e in encodeFloat (round (2^^e' * t)) (negate e')   in g (f (1/64 :: CReal)) :: Double
20:59:48 <lambdabot>   2.453976357464916e-2
20:59:50 <edwardk> ?
21:00:44 <edwardk> ah
21:01:13 <ClaudiusMaximus> edwardk: using log to find a guess for the exponent, then shifting to get the mantissa
21:01:47 <edwardk> i think ultimately i should build the lookup table at compile time or before, since this is kind of a silly list of runtime requirements
21:01:55 <edwardk> for a fast little integrator
21:22:08 <rasfar> dreixel, are you about?  I've got a test set up for your SYB join, but there's an ambiguous type variable -- not sure where to put the type signature to fix it.
21:22:20 <hpaste> rasfar pasted “SYB join test” at http://hpaste.org/64720
21:23:07 <rasfar> there's some comments in the paste...
21:25:01 <mgsloan> ((+1) *>* (-)) 1 (2,3)
21:25:01 <mgsloan> (3,-2)
21:25:34 <rasfar> (the comments are not quite right actually, since I was able to produce Nothing with the second test tree)
21:28:42 <rasfar> dreixel: I'll need to be offline soon as no home internet, but if you want to add any annotation to that paste, I'll be checking the tunes logs...
21:33:22 <edwardk> ok. i finally have this thing actually computing all the constants i need. definitely a preprocess. zomg creals are slow!
21:34:34 <edwardk> heh, found http://www.codeproject.com/Articles/31550/Fast-Numerical-Integration which has the first several levels of them
21:36:10 <nexion> is there a function like filter that returns 2 lists, one of which contains the elements removed?
21:36:26 <edwardk> partition
21:36:32 <edwardk> > partition even [1..10]
21:36:33 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
21:36:56 <eyu> http://hpaste.org/steps/64323
21:37:08 <eyu> (posted by someone else, but I'm having this problem too)
21:37:15 <eyu> what is the most likely cause of this kind of build error?
21:37:18 <nexion> thanks :)
21:37:31 <eyu> I don't expect anyone to actually know what the problem is, obviously
21:37:52 <eyu> but I'm not sure why a popular package would have a type error
21:37:59 <td123> eyu: lol
21:38:06 <td123> eyu: this is on arch right?
21:38:20 <td123> against xmonad-extras?
21:39:05 <eyu> yes
21:39:22 <eyu> just using cabal install
21:39:27 <eyu> (not the AUR package)
21:41:43 <rasfar> I heard earlier today that Arch now has GHC 7.4.1 -- are you still using 7.0.3?  I suppose you could try the newer platform, in case this applies in your case.
21:42:47 <eyu> when I type "ghc" in the console it uses 7.4.1
21:42:57 <eyu> however cabal might be using a different version
21:43:22 <edwardk> anyone remember the name of ezyang's pretty show instance?
21:43:29 <thoughtpolice> edwardk: groom
21:43:32 <eyu> maybe it's the newer version that's the problem? I don't know how to make cabal use the older compiler though
21:43:34 <thoughtpolice> @hackage groom
21:43:34 <lambdabot> http://hackage.haskell.org/package/groom
21:43:38 <edwardk> thanks
21:43:49 <thoughtpolice> for a 2 line package it's remarkably nice :)
21:43:56 <edwardk> i need to format a 167000 character line into something that looks less awful ;)
21:44:08 <edwardk> heh
21:44:10 <rasfar> eyu: I think the usual trick is to change the order of component in your $PATH.
21:44:24 <td123> eyu: well the error is probably related to ghc 7.4.1, it seems the guy that maintains xmonad-extras at http://xsounds.org/~haskell/ghc74/ might have solved it
21:44:40 <edwardk> i'll try to load the data in process as a constant, and failing that i'll go offload it into the data dir of the project
21:45:10 <edwardk> its really not _that_ big of an array
21:45:14 <td123> eyu: that doesn't make sense, unless you compile and install ghc yourself alongside arch's ghc
22:01:01 <unlink> I'm looking for a mature, embedded type-safe, native Haskell persistence library. What are the options?
22:03:54 <mm_freak> unlink: acid-state
22:04:39 <eyu> td123: will try installing another version, I guess
22:04:52 <eyu> (of xmonad-extras)
22:05:41 <eyu> that doesn't work either =\
22:06:54 <td123> eyu: I would try emailing him and asking him for any patches
22:07:04 <td123> eyu: it looks like he got it to build against 7.4.1
22:12:15 <mzero> anyone have any pointers to a good example of keeping location information with a parse tree?
22:12:39 <unlink> mm_freak: I'll look into that, thanks.
22:31:25 <covi> :r
22:31:27 <covi> ..
22:32:33 <mzero> no, cove, I don't' think you can :reload your module here! :-)
22:32:46 <mzero> er, covi
22:33:07 <covi> mzero: my mistake. I thought this tab is my ghci.
22:33:12 <mzero> heh
22:33:43 <applicative> its powers are a little more limited
22:38:53 <covi> http://hpaste.org/64723  Can someone please check out this code? It cannot be loaded in ghci.
22:42:06 <Makoryu> covi: You're calling numbers as functions
22:42:08 <Makoryu> That's why
22:42:27 <Makoryu> :t f $ 20 20
22:42:28 <lambdabot> forall b. (SimpleReflect.FromExpr b) => b
22:42:33 <Makoryu> :t 20 20
22:42:34 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
22:44:06 <Makoryu> covi: Where'd you get the idea to write "f $ 20 20" instead of "f 20 20"?
22:44:18 <Jafet> > f $ 20 20
22:44:19 <lambdabot>   Ambiguous type variable `b' in the constraints:
22:44:19 <lambdabot>    `GHC.Show.Show b'
22:44:19 <lambdabot>      a...
22:44:24 <Jafet> > f $ 20 20 :: Expr
22:44:25 <lambdabot>   f 20
22:44:45 <Makoryu> :t \f -> f (20 20)
22:44:46 <lambdabot> forall t t1 t2. (Num (t1 -> t), Num t1) => (t -> t2) -> t2
22:46:51 <covi> Makoryu: thanks but deleting the two $'s does not help
22:47:09 <Makoryu> covi: Which two? I found three....
22:48:06 <covi> Makoryu: my bad...
22:48:22 <covi> Makoryu: but why isn't "f $ 20 20" the same as "f 20 20"
22:48:41 <Makoryu> covi: Because function application binds tighter than any operator
22:48:47 <Cale> covi: because f $ 20 20 = f (20 20)
22:48:54 <Cale> while f 20 20 = (f 20) 20
22:49:20 <Cale> f (20 20) means to apply f to the result of applying the function 20 to the value 20
22:49:26 <covi> Cale: thanks
22:49:29 <Makoryu> covi: The point of $ is to let you say "foo $ bar baz" instead of "foo (bar baz)"
22:49:34 <covi> Makoryu: I see, thanks
22:49:46 <covi> But now my program runs extremely slow in ghci
22:50:06 <covi> it's just a simple f[i][j] = f[i-1][j] + f[i][j-1] calculation, and the goal is f[20][20].
22:55:18 * hackagebot http-proxy 0.0.11 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.11 (ErikDeCastroLopo)
22:56:03 <ivanm> covi: if you're using f[i][j] to refer to looking stuff up in arrays, well, you're not keeping anything
22:56:08 <applicative> covi, your function is a bit like a naive fib, i'm not sure what would be the best optimization
22:56:16 <ivanm> applicative: yeah, was thinking that
22:56:28 <ivanm> or possibly a naive ackermann
22:57:25 <ivanm> using either implicit or explicit memoisation should help
22:58:34 <covi> ivanm: what is memoisation? How to make Haskell intelligently remember what it has already calculated?
22:59:24 <applicative> yes, basically
22:59:27 <ivanm> covi: try passing around a Map (Int,Int) Int with values it's already seen
23:00:27 <dolio> The problem screams dynamic programming.
23:00:40 <dolio> Unless you just realize that it's drawing Pascal's triangle.
23:01:05 <covi> dolio: that's what it's for.
23:01:33 <ivanm> aren't the values in pascal's triangle just a combination calculation or something?
23:01:53 <dolio> If you only want f 20 20, then, you can figure out which spot it is, and compute it directly.
23:02:36 <dreixel> how can I leave a msg for someone with lambdabot?
23:02:48 <covi> sure i can, but doing f[i][j] = f[i-1][j] + f[i][j-1]  is more intuitive
23:03:04 <thoughtpolice> dreixel: use @tell, i.e. '@tell dreixel hello world'
23:03:11 <dreixel> thoughtpolice: thanks
23:04:00 <dreixel> @tell rasfar typically you'll need a type signature in the result, to fix the 'b' type
23:04:00 <lambdabot> Consider it noted.
23:04:06 <applicative> something like an infinite list of infinite lists might work well in this sort of case, covi
23:06:02 <sparta300> Facebooks' password hacked through session hijacking! Take a look at this: http://leakyneuron.blogspot.in/
23:06:22 * ivanm randomly guesses spammer, spoofer or troll ...
23:06:40 <Jafet> Mmm irony
23:07:09 <ClaudiusMaximus> > let bs = ((0,0),(20,20)) ; a = array bs [ ((i,j), if i == 0 || j == 0 then 1 else a!(i-1,j) * a!(i,j-1) + 1) | (i, j) <- range bs ] in a ! (5, 5)
23:07:10 <lambdabot>   2647928126185116317725365841617509110202
23:07:43 <Jafet> Well done
23:08:43 * applicative was too lazy to realize his plan, but sure enough there's a witty version on the wiki
23:09:03 <applicative> >   let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in pascal !! 5
23:09:04 <lambdabot>   [1,5,10,10,5,1]
23:10:38 <applicative> >   let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in take 5 pascal
23:10:39 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
23:12:45 <sparta300> Facebooks' password hacked through session hijacking! Take a look at this: http://leakyneuron.blogspot.in/
23:12:46 <sparta300> Facebooks' password hacked through session hijacking! Take a look at this: http://leakyneuron.blogspot.in/
23:12:47 <sparta300> Facebooks' password hacked through session hijacking! Take a look at this: http://leakyneuron.blogspot.in/
23:13:10 <applicative> >   let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in  (pascal !! 100) !! 50
23:13:12 <lambdabot>   100891344545564193334812497256
23:15:32 <covi> applicative: I found this http://www.haskell.org/haskellwiki/Blow_your_mind
23:16:07 <covi> is the feature   [1,1]^3 = [1, 3, 3, 1]  a deliberate intention of Haskell's designers?
23:16:09 <applicative> yeah thats the one i found. Something a little less compressed would make the point more clearly
23:16:23 <applicative> covi, no that one depends on a special num instance, forget it
23:16:32 <MaskRay> is there any off-the-shelf function by which 'foldM (flip ($)) i $ replicate time (forward d >=> turn a)
23:16:37 <MaskRay>  can be simplified
23:16:43 <applicative> though it is very clever...
23:16:55 <Jafet> That instance is... so stupid that it blows my mind
23:17:17 <hpaste> jpm annotated “SYB join test” with “SYB join test (annotation)” at http://hpaste.org/64720#a64724
23:17:44 <dreixel> @tell rasfar http://hpaste.org/64720#a64724
23:17:45 <lambdabot> Consider it noted.
23:19:21 <applicative> covi, do you know the function 'iterate'? the first 'blow your mind' definition of pascal is pretty clear i guess
23:19:36 <applicative> > iterate (*2) 1
23:19:37 <lambdabot>   can't find file: L.hs
23:19:47 <covi> applicative: I don't know iterate.
23:20:06 <applicative> neither does lambdabot it seems
23:20:16 <covi> applicative: gimme a sec to study that
23:20:32 <covi> applicative: why do you suggest to forget about that use of polynomial calculation
23:20:35 <applicative> > take 10 $ iterate (*2) 1
23:20:36 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
23:21:08 <applicative> covi, no it seems great, I was just thinking it would be well to think through why your original definition was taking so much time and space
23:21:38 <applicative> and why a simple alternative doesnt do that
23:22:15 <applicative> it's like if you write fib 0  = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) all hell breaks loose at say fib 30
23:23:07 <applicative> whereas the usual witty fib definitions evade this. eg
23:23:21 <applicative> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in take 33 fibs
23:23:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:25:23 <covi> applicative: I think your approach is pretty neat :)
23:25:34 <applicative> its a little easier to see why the naive fib definition is hopeless than in the case of your f which has two arguments
23:25:59 <covi> sure
23:26:03 <mgsloan> hmm.  I have base-4.5.0.0, but I'm not seeing a (Data.Monoid.<>), why would that be?
23:26:11 <covi> memoization is a little hard for me to understand
23:26:58 <edwardk> *Main> integrate 1e-6 (\x -> exp(-x/5.0)*(2.0+sin(2.0*x))) 0 10   ==> 9.108239607322838 :+/-: 5.2101717384900326e-9 -- yay!
23:27:23 <edwardk> sad i hadn't ported this thing to haskell before
23:29:13 <yitz> covi: perhaps i'm in the minority here, but i believe that it's almost always wrong to use memoization. if you think you need memoization, it means your algorithm is wrong to begin with.
23:29:33 <hiptobecubic> The more I write, the more I'm discovering that most of programming is combinatorial problem solving with pencil and paper.
23:29:49 <yitz> covi: so if you're willing to take that view, you don't need to worry about memoization :)
23:30:24 <edwardk> some of us are more partial to memoization than others
23:30:25 <edwardk> ;)
23:30:40 <hiptobecubic> yitz, how do you avoid repeated computation?
23:31:06 <yitz> hiptobecubic: start with an algorithm that doesn't need it. depends on the problem.
23:31:06 <edwardk> wish lambdabot had representable-tries installed so i could show the version with that
23:31:09 <covi> yitz: got it
23:31:41 <covi> but now I sadly realize my goal of computing f[20][20] where f[i][j] = f[i-1][j] + f[i][j-1] is not the same as calculating the pascal's triangle
23:41:16 <yitz> covi: they're not exactly the same, but you were right that their is something in common.
23:41:28 <yitz> > iterate (scanl1 $ \x y -> x * y + 1) (repeat 1) !! 5
23:41:28 <lambdabot>   [1,6,1237,428611842,51458022952549550101,2647928126185116317725365841617509...
23:41:36 <yitz> > iterate (scanl1 $ \x y -> x * y + 1) (repeat 1) !! 5 !! 5
23:41:37 <lambdabot>   2647928126185116317725365841617509110202
23:41:48 <hiptobecubic> using scanl properly still blows my mind a little
23:42:37 <shachaf> hiptobecubic: scanl is just foldl step by step.
23:42:43 <shachaf> > scanl f z [a,b,c,d]
23:42:44 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d]
23:43:36 <hiptobecubic> shachaf, yes i know. but recognizing when to use it is a challenge
23:44:09 <hiptobecubic> In fact, recognizing when to do anything
23:48:44 <applicative> covi, iterate f x is [x, f x, f (f x), f (f (f x)), ...]
23:49:40 <applicative> so the definition from the 'blow your mind' page is starting with the list of just 1, [1] keep applying the following principle
23:50:09 <applicative> then it gives a clever way of realizing exactly the principle you'd use in developing the triangle by hand, which only uses the previous row
23:51:45 <applicative> > let pascal = iterate nextRow []; nextRow row = zipWith (+) ([0] ++ row) (row ++ [0] in pascal !! 3
23:51:46 <lambdabot>   <no location info>: parse error on input `in'
23:51:56 <applicative> > let pascal = iterate nextRow []; nextRow row = zipWith (+) ([0] ++ row) (row ++ [0]) in pascal !! 3
23:51:57 <lambdabot>   [0,0,0]
23:52:03 <applicative> uhoh
23:52:29 <applicative> teach me not to keep a separate conversation going with her
23:52:45 <applicative> oh i see, i left out 1
23:52:50 <ivanm> he
23:52:53 <ivanm> h
23:53:04 <ivanm> I was trying to work out what you did wrong and didn't see anything
23:53:10 <applicative> > let pascal = iterate nextRow [1]; nextRow row = zipWith (+) ([0] ++ row) (row ++ [0]) in pascal !! 3
23:53:12 <lambdabot>   [1,3,3,1]
23:53:24 <applicative> i was starting from the empty first line...
23:53:31 <ivanm> yeah
23:53:35 <adnauseam> now just turn that last 1 into a 7 and you've got a winner
23:53:52 <applicative> adnauseam: am I making another mistake?
23:54:18 <applicative> my advice is kind of like this
23:54:32 <adnauseam> no no, what i said, was said in jest
23:54:36 <adnauseam> 1337 ;p
23:54:58 <applicative> > intersperse (error "oh, right") $ repeat True
23:54:58 <lambdabot>   [True,*Exception: oh, right
23:55:38 <applicative> ^^^ thats what my advice tends to be like...
23:58:35 <MaskRay> that's good. even red panel cannot attract me when i'm concentrating on sth...
