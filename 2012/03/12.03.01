00:02:42 <osager> are you talking about my question ?
00:04:03 <ChristianS> osager: Saizan told you two ways of solving your problem, but both need language extensions to use
00:04:32 <osager> ok
00:04:43 <osager> i know about stripPrefix
00:04:53 <osager> just
00:05:11 <ChristianS> osager: e.g. if you add {-# LANGUAGE PatternGuards #-} at the top of your file, you should be able to use  foo xs | Just ys <- stripPrefix "ok" xs = ..
00:05:34 <osager> wow that's good hint
00:05:36 <ChristianS> then ys is the rest of your string, provided the pattern matched
00:05:38 <osager> thank you
00:05:51 <osager> so otherwise i have to use the first way
00:06:46 <ChristianS> yes, or you could use a case statement or something like that. but PatternGuards look pretty good to me.
00:06:53 <ChristianS> anyway, thank Saizan
00:08:03 <osager> couldn't i just use stripPrefix ? i think it's in data.list
00:08:24 <osager> ok i see
00:08:29 <osager> forget my question
00:09:19 <ion> The PatternGuards version is more like foo xs@("ok"++ys). The ViewPatterns version doesn’t leave an unwanted, similarly named variable of the same type lingering around in the scope which is an easy source of confusing bugs. :-)
00:10:49 <ChristianS> ion: but in osager 's case capturing the rest in a variable is actually indended, unless i misunderstood?
00:11:03 <ddarius_> Pattern guards are Haskell 2010.
00:11:59 <ChristianS> ddarius_: oh, so you can use that syntax even without a LANGUAGE pragma in newer versions of ghc? that's pretty cool...
00:13:05 <ChristianS> ion: any anyway, if you DON'T want that variable, you could just use "foo xs | Just _ <- stripPrefix "ok" xs = .." with PatternGuards, right?
00:13:20 <Ptival> Does Haskell check patterns exhaustiveness?
00:13:30 <osager> christians yes i want the rest of the variable
00:13:45 <ion> christians: That doesn’t change the fact that xs is still lingering around.
00:13:49 <Ptival> (in the absence of extensions)
00:14:31 <ion> ptival: GHC does at least in some cases.
00:14:38 <ChristianS> ion: oh you were talking about xs, not ys, i see. there you're right at case.
00:14:46 <shirt> where did all the wiki pages go? i am looking for http://www.haskell.org/hawiki/HaskellUnixDaemon
00:15:38 <Ptival> ion: using PatternGuards disables it then?
00:15:49 <ChristianS> Ptival: ghc won't usually check for exhaustiveness, but you can tell it do to so via the -Wall flag (or some more specific flag i don't remember)
00:16:13 <ion> “-Wall” isn’t “usually”? :-P
00:17:15 <ChristianS> ion: for me, -Wall is always on, but i'm not so sure about others ;-)
00:26:07 * hackagebot hedis 0.4.1 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.4.1 (FalkoPeters)
00:31:29 <unlink> I am trying to write a function of type [FilePath] -> IO [(FilePath, Bool)], where the Bool corresponds to whether the FilePath was a directory. I strongly suspect there may be a more idiomatic implementation than: mapM $ (return &&& doesDirectoryExist) >>> uncurry (liftM2 (,))
00:46:50 <Saizan> ?type liftM2 (liftM2 (,)) return doesDirectoryExist
00:46:51 <lambdabot> Not in scope: `doesDirectoryExist'
00:46:57 <Saizan> ?type liftM2 (liftM2 (,)) return ?doesDirectoryExist
00:46:58 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m, ?doesDirectoryExist::a1 -> m a2) => a1 -> m (a1, a2)
00:47:34 <Saizan> requires Control.Monad.Instances for the ((->) r) one
00:47:49 <unlink> yeah
00:47:57 <Saizan> but the most idiomatic is probably a lambda
00:48:22 <Saizan> \x -> (,) x <$> doesDirectoryExist x
00:48:50 <unlink> oh
00:51:56 <unlink> the C.M.I equivalent being liftM2 fmap (,) doesDirectoryExist
00:55:15 <unlink> although (return &&& doesDirectoryExist) >>> uncurry (liftM2 (,)) doesn't need C.M.I
00:56:39 <Saizan> ?type runKleisli (Kleisli return &&& Kleisli ?doesDirectoryExist)
00:56:40 <lambdabot> forall a (m :: * -> *) c'. (Monad m, ?doesDirectoryExist::a -> m c') => a -> m (a, c')
00:56:50 <Saizan> to add variants :)
00:57:47 <unlink> oh nice
00:57:56 <unlink> thanks for that one.
00:59:39 <Saizan> too bad for the newtype noise
01:00:45 <unlink> it's better than uncurry (liftM2 (,))
01:05:41 <unlink> It wasn't obvious to me what that Kleisli nonsense was all about.
01:06:10 <unlink> But this is a pretty good use.
01:06:38 <Ptival> C.M.I?
01:06:55 <unlink> Control.Monad.Instances
01:08:16 <AfC> Wow. 'hedis' is brilliant. Easier to use than 'redis-haskell' and a vast improvement compared to 'redis' which I never managed to get to work.
01:15:41 <brandwe> :echo has('ruby')
01:17:26 <brandwe> sorry about that. It does not :-( LOL
01:17:33 <shirt> 1
01:21:08 <beyeran_> I've read somewhere something about monad stacks, is th
01:21:20 <beyeran_> is there any good source for it?
01:21:50 <beyeran_> or is it known under a different term?
01:21:59 <alpounet> "monad transformers" i guess
01:22:09 <alpounet> that's what let you create those monad stacks
01:22:57 <beyeran_> alpounet: ah ok, thanks. I've always found transformers but I wasn't sure if this had something to do with it!
01:25:04 <alpounet> beyeran_, well you'll figure out what exactly it has  to do with it, and if you have some trouble understanding, do not hesitate to ask here
01:30:40 <macobo> Are there web crawlers written in hs?
01:32:02 <beyeran_> alpounet: Yes, thanks, I will :)
01:33:17 <zenzike> Kuba: Jakub from the comlab?
01:47:16 <tikhonjelvis> Hmm, I'm having some trouble building HOpenCV. I'm getting this error: http://hpaste.org/64585.
01:47:30 <tikhonjelvis> This is after installing the -devel version of OpenCV from my package manager.
02:00:05 <shergill> does setting 'shared: True' in your local cabal file work for people? i did it in an attempt to save up on disk space but it kept breaking packages and so i had to revert (packages which broke were hoogle and chp - with ghc 7.0.4). i don't have access to my laptop right now, but was wondering if others have run into similar woes with the shares library approach
02:00:35 <shergill> *shared
02:07:37 <t7> whats a sideways bottom symbol called?
02:08:16 <Saizan> turnstile
02:19:20 <t7> c# isnt toooooooo bad to be totally fair. Immutable types and stuff. It just very verbose
02:20:51 <t7> just needs a repl...
02:20:54 <yitz> they say linq has made it much better. haven't tried it yet. i hope that's right, because soon i'll have to.
02:21:29 <yitz> t7: if you find, or write, a repl. please let me know
02:21:38 <t7> there is one for mono i hear
02:22:01 <t7> but i just use vim and the c# compiler that comes with the .net framework as standard
02:22:17 <t7> its cool that you dont have to download visual studio or anything
02:22:18 <yitz> i'll probably be using vs
02:22:50 <t7> yitz: theres a new one in beta. Its all black and white or something
02:23:05 <yitz> a new what?
02:23:11 <t7> visual studio
02:23:14 <yitz> oh
02:23:20 <yitz> what's wrong with colors?
02:23:34 <yitz> i think they gave me v2 2010
02:23:38 <yitz> vs 2010
02:23:47 <t7> everyone is moving from colors, google, apple, microsoft
02:24:05 <t7> i miss colours
02:24:05 <yitz> sounds retro
02:24:28 <yitz> i hope they at least keep the syntax highlighting
02:25:08 <yitz> the next version will probably be sepia
02:33:25 <t7> can i construct a function that takes an arguement of kind other than star ?
02:33:29 <brandwe> Yeah we've gotten a lot of complaints about losing the colors. A lot of it is memory as much as anything. People pick icons based on colors
02:33:47 <t7> or only types can do that?
02:34:57 <Saizan> only types
02:36:04 <t7> but a forall needs a kind to describe type constructors i think
02:36:10 <Saizan> functions don't really take arguments that have kinds, but they take ones of types that have kinds
02:36:34 <Saizan> and the kind of those types has to be *
02:36:38 <t7> ok cool
02:44:36 <mysticc> whats the advantage of a zipper tree over simple mutable tree ... I have several concurrent threads working on the tree .. These threads can modify one or more nodes or can just read values .. I want no thread should read inconsistent value ..
02:45:22 <Saizan> you could just put your plain immutable tree in a MVar
02:46:47 <epsil> how do I get auto-indentation in yi?
02:48:28 <bott_L> @pl (\l x -> l ++ [x])
02:48:28 <lambdabot> (. return) . (++)
02:49:53 <rostayob> is yi still alive?
02:50:23 <mysticc> whats the advantage of a zipper tree over simple mutable tree ... I have several concurrent threads working on the tree .. These threads can modify one or more nodes or can just read values .. I want no thread should read inconsistent value ..
02:50:46 <mysticc> inconsistent here means .. suppose a thread change 2 nodes , so other thread if reading should see both new values or both old values ...
02:51:23 <Philippa> the easiest go-to for now is to use STM, which gives you a sensible way to build mutable trees
02:51:49 <Philippa> zippers have the advantages of immutability
02:52:30 <Philippa> Saizan: chucking the whole tree in one MVar is probably a bad move in that situation, no?
02:53:32 <mysticc> Philippa: I just want to know the advantage of immutability in case of zippers for concurrency ..
02:53:41 <ddarius> It would guarantee atomicity, but it would probably destroy concurrency.
02:54:07 <mysticc> ddarius: what would guarantee atomicity ?
02:54:15 <Philippa> mysticc: zippers don't do anything in particular for concurrency
02:54:25 <Philippa> they're just another immutable data structure
02:54:46 <Philippa> (which is still a nice thing if you're using eg a derivative of Daan Leijen's prettier concurrency system, but still)
02:56:37 <epsil> what do people use for editing haskell if not yi?
02:56:55 <Philippa> any and everything
02:57:05 <t7> why cant we have kind contructors?
02:57:12 <Philippa> myself, jedit. Plenty of emacs users
02:57:17 * ddarius types every other character in a new editor.
02:57:25 <Philippa> what do you think kind-level -> is, t7?
02:57:29 <mikeplus64> vim user reporting in
02:57:33 <ion> @hoogle (Integral n, Monad m) => n -> (a -> m a) -> a -> m a
02:57:34 <lambdabot> No results found
02:57:38 <Philippa> I hear cat's nice
02:57:39 <mikeplus64> (with ghc-mod)
02:58:00 <t7> its applications all the way down :o
02:58:09 <epsil> mikeplus64: how's the haskell auto-indentation in vim?
02:58:23 <mikeplus64> nothing very exciting
02:58:32 <Philippa> t7: read up on the Lambda Cube and then Pure Type Systems if you want to take that somewhere
02:59:01 <mikeplus64> press enter and the indentation is the same as the line before
02:59:22 <mikeplus64> with if, cases, = and lambdas it'll indent it one more step though
03:00:35 <rostayob> epsil: emacs. emacs.
03:00:38 <rostayob> emacs.
03:00:46 <mikeplus64> emacs scares me
03:01:03 <rostayob> since when does vim has ghc-mod?
03:01:12 <epsil> rostayob: I looked at emacs' haskell-mode, it had two indentation packages
03:01:13 <mikeplus64> a long time
03:01:17 <Philippa> that reminds me, I should try out shplit
03:01:21 <epsil> I couldn't figure out which I liked best
03:01:28 <ion> I haven’t found good Haskell autoindentation for vim yet. (But i haven’t been searching very actively.)
03:01:34 <Philippa> it's funny how seeing the author use a tool changes your inclination to use it
03:01:36 <rostayob> mikeplus64: interesting.
03:02:03 <rostayob> epsil: well one of them doesn't indent automatically
03:02:55 <epsil> yeah, one of them can only indent a single line at a time
03:02:56 <mikeplus64> I just use really simple indentation and don't have to worry about it
03:03:06 <epsil> the other is smarter, but does weird things at times
03:07:37 <ion> cmccann: Overture doesn’t seem to export (<$).
03:08:20 <Zedrikov> Hi, is there something like "class Normalizable t where normalize :: t -> t" where normalize would fully normalize a term (and not just put in hnf like seq)?
03:09:10 <rostayob> Zedrikov: NFData
03:09:52 <rostayob> Zedrikov: no sorry
03:09:58 <rostayob> that doesn't express what you want, I think
03:10:08 <rostayob> things that are NFData might not be normalizable
03:10:21 <Saizan> Zedrikov: there's class NFData a where rnf :: a -> ()
03:10:25 <rostayob> but NFData gives you a method that tries to fully evaluate them
03:10:36 <Saizan> in the deepseq package, iirc
03:10:45 <rostayob> defining a class that tells you if a term has a normal form is impossible in Haskell
03:12:54 <geekosaur> or anywhere else, I think (isn't that the halting problem?)
03:13:18 <Zedrikov> rostayob: I don’t want to know if something is in normal form, just a normalizing function and your pointer seems to be what I wished, I will take a deeper look at it
03:13:36 <rostayob> Zedrikov: look at NFData
03:13:46 <rostayob> geekosaur: well
03:13:49 <rostayob> you can have normalizing languages
03:14:07 <rostayob> geekosaur: but they're not turing complete ehe
03:14:23 <geekosaur> exactly :)
03:14:26 <rostayob> (still very useful)
03:18:15 <SoleSoul> Hi! I want to make my first real world application in Haskell. It would be an RSS reader with web interface. Since I'm very new to this can anyone suggest suitable libraries for the task? I'm hoping it won't be too hard :)
03:20:01 <rostayob> SoleSoul: with "web interface" do you mean a web server that serves the web interface?
03:20:08 <rostayob> or just a thing running locally?
03:20:56 <rostayob> SoleSoul: anyways, there are some web frameworks around, my favourite is Happstack, but there's also yesod and snap.
03:21:00 <SoleSoul> rostayob: mm... I was intending to develop it locally and later move it to my new first vps :)
03:22:09 <Zedrikov> I was taking a look at NFData, rnf function. For [t] instance, there is a "rnf (x:xs) = rnf x `seq` rnf xs" wouldn't have it been better to have "rnf (x:xs) = rnf (seq (rnf x) xs)" or does GHC automatically put it tail-recursive?
03:22:12 <Axman6> SoleSoul: shouldn't be too hard. you can make some nice use of threads there too (have a different thread for each feed that
03:22:22 <Axman6> that's followed, which gets new content every now and then)
03:22:27 <SoleSoul> rostayob: 1) what about the parsing of the rss/xml? should I write it myself? I saw a few libs for creating rss feeds...
03:22:49 <zomg> Axman6: with hundreds of feeds that sounds kind of like a poor idea
03:23:17 <Axman6> hundreds should be fine. tens of thousands maybe you'll start to get problems
03:23:33 <SoleSoul> zomg, Axman6: there are going to be lots of feeds. I'm thinking about local cache
03:23:35 <zomg> Yeah I suppose so
03:23:51 <SoleSoul> what is CTCP ping?
03:24:26 <xil> hey everyone. Is it a typo that this page http://www.haskell.org/haskellwiki/Case uses guards with a case-of expression when ghci fails to parse it? Also, is there a reason for why the wiki is so lacking in a proper explanation of case-of syntax?
03:24:27 <Axman6> SoleSoul: sure, but you need to download the RSS data somehow. the threads would each download their own feed's data, and store a cache of it in some central data store
03:24:57 <Axman6> xil: the syntax is quite simple, what problems are you having?
03:25:13 <Axman6> case with guards works fine
03:25:22 <xil> Axman6: well I figured out that I need to lose the guards to make my stuff work. I amigane the guards are for when you have something after the "of"
03:25:34 <xil> s/amigane/imagine/
03:25:45 <SoleSoul> Axman6: first step, download xml files to local filesystem. second step, parse rss. Third step, create html. ?
03:26:23 <xil> but I guess then that the wiki doesn't have a typo, it's just grossly lacking in important details
03:26:26 <Axman6> SoleSoul: possibly, depends what you want to do with the interface. you may want to parse the feed data and store it in a database for easier access
03:26:47 <Axman6> xil: you have to have something after the of...
03:27:07 <Axman6> guards are for checking some boolean condition  once a certain pattern has been matched
03:27:48 <quicksilver> xil: I don't understand what you think is wrong with the wiki article?
03:27:49 <zomg> SoleSoul: note that you'd also need to handle variants like RSS 0.9, 1.0 and Atom as well
03:27:57 <Axman6> > case 666 of 666 -> "Evil"; n | even n -> "How boring" | odd n -> "How odd"
03:27:58 <lambdabot>   "Evil"
03:27:58 <quicksilver> except "it isn't a complete description of case" but it's not really trying to be
03:28:07 <quicksilver> the wiki isn't a particularly good way to learn haskell.
03:28:10 <Axman6> > case 1 of 666 -> "Evil"; n | even n -> "How boring" | odd n -> "How odd"
03:28:11 <lambdabot>   "How odd"
03:28:14 <Axman6> > case 2 of 666 -> "Evil"; n | even n -> "How boring" | odd n -> "How odd"
03:28:15 <lambdabot>   "How boring"
03:28:26 <hpaste> xil pasted “case-of (no guards)” at http://hpaste.org/64587
03:28:54 <robertberry> Hey. I'm doing the 99 problems and have just got to 23, which is "Extract a given number of randomly selected elements from a list.". I figure I need to know about Monads to do this ... what's the best (and relatively shortest) thing I can read to get me up to scratch?
03:29:09 <Axman6> xil: your problem has nothing to do with case or guards. you're using things of the wrong type in your main function
03:29:34 <xil> oh wow. I just realized how guards work
03:29:40 <xil> looking at your example Axman6
03:29:41 <drdo> xil: main needs to have type IO ()
03:29:55 <xil> that was just a sample I wrote up to illustrate what I was getting at
03:29:55 <quicksilver> well, GHC permits IO anything
03:30:10 <xil> and I failed because I didn't realize how guards actually work
03:30:11 <xil> until now
03:30:20 <SoleSoul> Axman6: ah, that's a possible step. thanks.
03:30:25 <xil> you can basically put them anywhere where a pattern match is happening
03:30:46 <aristid> robertberry: you mean you need IO for that?
03:30:51 <robertberry> Yea
03:30:52 <SoleSoul> zomg: Is there a way to abstract it with a high level library? for the first project I don't want it to be too complicated.
03:30:55 <Axman6> quicksilver: hmm, i wonder what happens if you return an exception type from main... would be fun if it did treat it as an exception, but i feel it almost certainly won't
03:31:10 <zomg> SoleSoul: If someone has written a lib for it, sure. Don't know if anyonne has though
03:31:15 <robertberry> Well I assume System.Ranom uses some sort of Monads to do it
03:31:15 <xil> and if you put it directly after the "of" in a general enough way then it'll just match every time, like in the example in the wiki
03:31:20 <robertberry> *Random
03:31:22 <aristid> robertberry: if you're fine with always returning the same "random" set, then no you don't need IO
03:31:28 <Axman6> robertberry: you don't necessarilly need IO for that btw (though your program will return the same values every time you run it)
03:31:29 <SoleSoul> zomg: ok, thanks.
03:31:46 <SoleSoul> How do I download from Haskell? is there a standard way?
03:31:55 <aristid> robertberry: please stop saying "Monads" when you mean IO
03:31:55 <robertberry> Hmm I figure I should probably learn how to do that now
03:32:12 <robertberry> Well I dunno what they are :) that's why I'm asking for an article to read ha
03:32:25 <robertberry> I thought IO was using Monads?
03:32:44 <aristid> for binding actions together, yes. does not mean that Monads == IO
03:32:52 <SoleSoul> robertberry: I learned monads from lyah
03:33:18 <robertberry> OK cool - I'll have a look at that
03:33:22 <SoleSoul> robertberry: it was lengthy but it's the only source which could really get into my head
03:33:35 <xil> Axman6: so am I right to believe, now, that guards aren't an integral part of case statements, they just happen to be permitted in them. By which I mean that the different cases in a case-of aren't separated by guards, but a single case in the whole thing can match with a pattern and guard(s)
03:34:03 <robertberry> Thanks SoleSoul
03:34:30 <Guest56670> how can i print a quotation mark ( " ) to the screen?
03:34:52 <Axman6> xil: yes, case if 'just' there to do pattern matching inside of functions
03:34:56 <SoleSoul> robertberry: you'll have to start from chapter 11: applicative functors
03:34:57 <robertberry> & no need to be an asshole aristid. I came in here asking for help, not to be berated.
03:35:04 <Axman6> Guest56670: putStrLn "\""
03:35:22 <aristid> was i an asshole? *confused*
03:35:25 <quicksilver> xil: well, case statements and equational definitions are "basically the same thing"
03:35:37 <quicksilver> xil: and those are the only places guards are allowed.
03:35:49 <Axman6> aristid: no, but you could have made it more clear that it's important to understand that Monad /= IO
03:36:07 <Guest56670> axman6: thanks!
03:36:20 <Axman6> aristid: i think that after saying it so much, it's easy to forget that we need to keep telling people that part :P
03:36:38 <xil> quicksilver: right. Basically what I was doing before was this...
03:36:41 <aristid> Axman6: hm
03:36:48 <hpaste> xil annotated “case-of (no guards)” with “case-of (guards)” at http://hpaste.org/64587#a64588
03:37:17 <Axman6> aristid: anyway, you weren't in the wrong, and you weren't an asshole =)
03:37:20 <xil> quicksilver: the second one. And that was a confusion of what cases and guards are basically
03:37:25 * quicksilver nods
03:37:37 <quicksilver> the thing on the right of | is a boolean expression.
03:37:42 <quicksilver> the thing in a case is a pattern
03:38:00 <quicksilver> those are normally different, but "True" and "False" happen to be both of those things.
03:38:21 <xil> ooh, very interesting, I didn't really realize that, but being a pattern could come in handy so much more
03:38:28 <quicksilver> "True" and "False" are just about the only things which are boolean expressions as well as patterns.
03:38:38 <xil> haha, yeah
03:38:50 <quicksilver> case x of Red -> blah; Green -> blah; Blue -> blah;
03:39:00 <quicksilver> ^^ more typical case, over some other (invented) constructors.
03:39:19 <xil> I blame the wiki for my confusion =P
03:39:57 <Axman6> yeah, that page does a bad job of teaching you what case expression are. (but that is also not its purpose)
03:40:41 <xil> the wiki makes it look like you need to do "case x of _ | Red -> blah | Green -> blah | Blue -> blah"
03:40:47 <xil> or the same without the underscore
03:40:52 <xil> but I see now how it all works
03:41:29 <xil> Axman6: but what's the purpose of the page if not to explain how cases work?
03:41:46 <quicksilver> xil: to record a few curious or interesting tricks about case
03:41:49 <quicksilver> the wiki is not a tutorial
03:42:01 <Axman6> i believe there are other things called case statements elsewhere, and it's shopwing how to implement those using haskell. i could be wrong
03:42:02 <quicksilver> and AFAIK the wiki doesn't contain a decent tutorial these days
03:42:10 <quicksilver> although it has links to some
03:42:15 <quicksilver> xil: http://learnyouahaskell.com/syntax-in-functions
03:42:28 <quicksilver> is a better tutorial for patterns/guards/case
03:42:31 <xil> quicksilver: yeah that's where I found the right way to do what I'm trying to do
03:42:45 <pozic> Is there a tool like hpc for C code?
03:42:51 <quicksilver> the wiki isn't trying to be a tutorial or a language reference.
03:43:04 <quicksilver> it wouldn't be a terrible thing if it did, mind
03:43:09 <quicksilver> but it's not.
03:43:11 <xil> haha
03:43:23 <Axman6> pozic: a program coverage tool? i believe gcc has one... i think
03:43:25 <xil> it is definitely helpful sometimes
03:43:37 <pozic> Axman6: can you be more specific?
03:43:37 <Axman6> i swear it does, but i can't remember what it's called now. gcov?
03:43:49 <Axman6> @google gcc program coverage gcov
03:43:51 <lambdabot> http://gcc.gnu.org/onlinedocs/gcc/Gcov.html
03:43:51 <lambdabot> Title: Gcov - Using the GNU Compiler Collection (GCC)
03:43:51 <xil> but for me mostly when it's giving details about some module
03:44:02 * Axman6 wins
03:44:38 <Peaker> trying to install ghc-7.4 on Debian, "./configure" is failing because it runs ghc-pwd which wants libgmp.so.3, when Debian testing comes with libgmp.so.10
03:45:00 <Peaker> anyone got modern ghc installed on Debian testing or newer?
03:45:36 <Axman6> m3ga might know, i think debian's his distro of choice
03:46:11 <Axman6> he may be asleep by now though
03:46:38 <xil> well thanks for the info. You learn a little bit every day it seems =]. See y'all later
03:47:37 <m3ga> Peaker: debian unstable has ghc 7.4.1
03:47:49 <m3ga> i think testing has 7.0.4
03:47:51 <Peaker> m3ga, I'm worried about.. instability :)
03:48:00 <Peaker> I am trying to install ghc-7.4 manually as I always did with Ubuntu
03:48:54 <m3ga> i run a mixed debian testing/unstable system for my own stuff. i run ubuntu at work. i find little difference in stability.
03:49:39 <m3ga> if anything debian is more stable because testing is a rolling release, but ubuntu has a "change the world" thing every 6 months.
03:50:04 <quicksilver> ubuntu annoys me because people say stupid things about it
03:50:13 <quicksilver> this is not, strictly, ubuntu's fault. But there it is.
03:50:54 <quicksilver> I remember one time ars technica did a review of a new ubuntu release and they mostly talked about the default colour scheme of the default window manager of the default windowing system.
03:51:02 <quicksilver> (it was, apparently, a slightly different shade of brown)
03:51:33 <Cozminsky> quicksilver: this is important things people need to know
03:53:06 <Peaker> quicksilver, Ubuntu is really mostly about defaults
03:53:22 <geekosaur> fwiw on testing I have /usr/lib/libgmp.so.3 from libgmp3c2 and ghc 7.0.4
03:53:36 <TRH> I'm new to haskell and hoping someone could help me with a problem, why do I always get "<no location info>: can't find file" error when trying to compile any .hs file i loaded in GHC?
03:53:59 <quicksilver> what exactly are you typing to get that error message THR?
03:54:39 <Peaker> geekosaur, thanks
03:54:39 <TRH> I'm using the compile tool, it says ":! ghc --make "a.hs"  "
03:59:30 <quicksilver> TRH: well that's a plausible command. Maybe a.hs doesn't exist in the directory it's running it in?
04:00:56 <Peaker> nice, installing just ghc from sid seems to be easier than I'd imagined
04:02:13 <TRH> quicksilver: i think it is, I opened the file, it automatically said ":cd ..." and "load "a.hs""
04:04:14 <Axman6> TRH: why are you doing all these things inside ghci? things like cd and calling external functions are better done by your shell
04:06:50 <TRH> Axman6: ah, ok. what is the right way to compile? Since .hs is associated with ghci and there is a compile button it seemed that's the way it's meant to be done
04:07:15 <Axman6> oh, you're on windows?
04:07:25 <TRH> yep
04:07:43 <Axman6> can't help you then, i've never used haskell on windows
04:07:47 <TRH> should have mentioned it, sorry
04:08:03 <TRH> thanks for trying
04:09:55 <t7> http://stackoverflow.com/questions/9515956
04:11:58 <Peaker> the newest haddock package on hackage requires ghc < 7.4?
04:12:30 <SoleSoul> a little help: In ghci I can import "Network" but "import Network.Download" results in "could not find module". Is it possible that my installation is missing a package?
04:12:50 <Cale> SoleSoul: yes
04:13:24 <Cale> http://hackage.haskell.org/package/download
04:14:39 <SoleSoul> Cale: Thanks. I thought "haskell-network" on Archlinux contains everything in Network. I didn't know it can be separated.
04:14:58 <Guest56670> TRH: do you use WinGHCi?
04:15:00 <SoleSoul> Cale: Now I have to find out how to install it.
04:15:17 <TRH> Guest56670: yes i do
04:15:29 <Cale> SoleSoul: the hierarchical nature of modules is an illusion created by allowing dots in the module names :)
04:16:01 <Cale> SoleSoul: cabal install download
04:16:34 <Cale> (don't sudo, installing cabal packages as user is safer and easier to redo if things get messed up)
04:17:12 <SoleSoul> Cale: I'm still confused about how a linux package manager and cabal install live together, therefore I didn't install any package with cabal yet. How do you combine them? Are there any guidelines?
04:17:40 <Peaker> SoleSoul, the default cabal-install behavior is to install in ~/.cabal and ~/.ghc
04:17:52 <Peaker> SoleSoul, if you run it as user
04:18:20 <SoleSoul> Peaker: so if I want to uninstall anything I installed as a user with cabal I just have to delete .cabal and .ghc?
04:18:30 <Guest56670> TRH: that's how it works for me: http://hpaste.org/64590
04:19:15 <Peaker> SoleSoul, that would wipe out all your per-user installs
04:19:22 <Peaker> SoleSoul, typically you run "ghc-pkg unregister <name>"
04:19:31 <Cale> SoleSoul: I install nothing Haskell-related with my system package manager. I install the generic linux binary of ghc under /usr/local and then install everything else with cabal as user in my home directory
04:20:15 <Cale> Of course, you can split it up differently...
04:20:19 <SoleSoul> Peaker: Since there is no cabal-uninstall, is there a way to manage installed cabal packages?
04:20:41 <TRH> Guest56670: Thanks, that was the way i was doing it, and i tried it again, still getting the same error
04:20:54 <Cale> SoleSoul: everything is in ~/.ghc and ~/.cabal so you can ghc-pkg unregister and then just delete the files from there
04:21:02 <Peaker> SoleSoul, you just don't uninstall stuff, you just unregister them
04:21:07 <SoleSoul> Cale: Thanks. This sounds solid and straightforward. I guess the only drawback is compilation time, right? is it terribly long?
04:21:24 <Cale> Usually not very long at all
04:21:33 <Cale> (under a minute for most things)
04:21:57 <Cale> Some packages like gtk2hs can take a few minutes to install
04:22:02 <SoleSoul> Peaker: I will read about this ghc-pkg.
04:22:38 <Guest56670> TRH: did you try it using the shell / command prompt?
04:22:49 <SoleSoul> Cale: I may try the way you do it. Is there a way to update all of your cabal packages?
04:23:01 <Guest56670> maybe this works
04:23:27 <SoleSoul> Cale: And after a ghc update, do I have to update everything? rebuild everthing?
04:23:29 <Cale> SoleSoul: you generally want to be careful about that, because updating packages typically means editing your programs to work with the new versions of them
04:23:49 <Peaker> haddock from git head doesn't compile with ghc 7.4 either... hmm
04:24:12 <ski> SoleSoul : monochrom's "Storage and Identification of Cabalized Packages -- Corollary: Removing Packages" <http://www.vex.net/~trebla/haskell/sicp.xhtml#remove> might be useful
04:24:37 <Cale> SoleSoul: yeah, if you upgrade ghc, you need to reinstall things with cabal again
04:25:09 <Cale> SoleSoul: it's moderately annoying to do, but new GHC versions only come up every 6 months or somethign
04:25:18 <Cale> *ng
04:26:10 <Cale> (and it's mostly automatic, so you just need to reinstall things as you need them)
04:26:12 <SoleSoul> Cale: So when a new ghc versions comes out, do you do something like cabal-rebuild-all or do you have to rebuild each one manually?
04:26:24 <Cale> I just cabal install each package again as I need it
04:26:40 <Cale> Installing a new ghc will mean a completely separate set of visible installed packages
04:27:09 <Cale> (so I'll just be down to the stuff which comes with ghc initially)
04:27:13 <TRH> Guest55670: it did not, how to?
04:27:16 <SoleSoul> Cale: Ah, so updating ghc is like uninstalling everything?
04:27:19 <Cale> yeah
04:27:39 <SoleSoul> Cale: then you just delete the old packages folder?
04:27:59 <Cale> yeah, I'll typically clear out my ~/.ghc before updating
04:28:16 <Cale> but it's not really a big deal
04:28:37 <Cale> my current ~/.ghc is less than half a megabyte, and I have lots of packages installed
04:29:04 <SoleSoul> Cale: you mean, deleting the .ghc folder?
04:29:13 <SoleSoul> before update
04:29:15 <Cale> yeah
04:29:57 <SoleSoul> Cale: Sounds ok. Which linux distro do you use for haskell development?
04:30:22 <Cale> I'm using Ubuntu at the moment. I'm not going to say that I recommend it.
04:31:01 <SoleSoul> Cale: It's ok. I would have had more follow-up questions had you said NixOS :)
04:31:08 <Cale> I'm generally unhappy with the state of most linux distributions right now, though it's more the fault of gnome and the collection of linux audio software which is to blame than the individual distributions.
04:31:10 <Guest56670> TRH: go the shell (for example via "execute: cmd"), move to the folder where your .hs file is located (via cd/ cd..) type "ghci", then ":load yourfile.hs" then ":! ghc --make yourfile.hs"
04:31:21 <SoleSoul> This mysterious distro looks interesting
04:31:23 * ski str roconnor uses Nix
04:32:18 <SoleSoul> Cale: That's why I use Archlinux. Easy to change stuff when something is not as you like it.
04:32:22 <Cale> oh, right, hehe, the actual code for installed packages is in ~/.cabal/lib
04:32:39 <SoleSoul> Cale: Thank you for your patient explanations!
04:32:47 <earthy> NixOS... wow. that's an interesting set of pain. :)
04:32:49 <Cale> I could probably stand to clean mine up, I'm up to 1.6 GB :)
04:32:53 <earthy> sound concept though. :)
04:33:04 <Cale> (a lot of the stuff in there isn't actually registered with GHC)
04:33:15 <SoleSoul> earthy: Did you try it? I couldn't make my wireless work
04:33:40 <SoleSoul> Cale: did you tell that to me?
04:33:51 <SoleSoul> Cale: ah, I see
04:34:08 <SoleSoul> Cale: The "registry" is in .ghc, and the files are in .cabal?
04:34:45 <earthy> I did try it, back when Armijn and Eelco were first developing it
04:34:51 <Cale> yeah
04:35:16 <SoleSoul> Cale: If what you told me is true, you can delete both folders before next ghc update, am I wrong?
04:35:18 <Cale> down to 604 MB after deleting non 7.4.1 versions of packages :)
04:35:27 <TRH> Guest55670: Thanks, i tried. unfortunately the error stays the same, although the prompt chances to *Main>
04:35:50 <earthy> however, I haven't kept up with it, as it was, as I said, an interesting set of pain. :)
04:35:51 <Cale> You can just cd into ~/.cabal/lib and then rm -r */ghc-<oldversion>
04:35:54 <SoleSoul> Cale: This was fast. Easy enough to maintain then.
04:36:27 <SoleSoul> earthy: would you recommend trying it again? I couldn't find *any* support or explanation.
04:37:03 <Cale> aha, 322M, missed ghc-7.4.0.20111219 from when I was running the pre-release :)
04:37:30 <Cale> It might be nicer if it separated things first by ghc version and then by package name
04:37:38 <earthy> solesoul: I wouldn't recommend it for daily use, no.
04:37:42 <Cale> but even so, it's pretty easy to clean up
04:39:02 <SoleSoul> earthy: what about as a daily development station? is it missing crucial packages?
04:39:19 <earthy> well, I wouldn't think it misses anything crucial
04:39:50 <SoleSoul> Cale: I don't know if you tried it but Archlinux has quite good Haskell support.
04:40:12 <Cale> I've heard that
04:40:17 <SoleSoul> earthy: I think I can't resist trying it again :) too interesting to be ignored
04:40:44 <t7> i need a case expression with only gaurds
04:40:56 <t7> i dont care about the pattern
04:41:01 <SoleSoul> earthy: but the lack of documentation made me fail in my first and last try to use it.
04:41:02 <t7> just conditions
04:41:14 <t7> like a string of if elseif else
04:41:23 <t7> whats the best pattern
04:41:43 <earthy> ah. there is a manual... but I don't know how good it is
04:41:59 <earthy> it's a lot easier to install and administer when you have the designers a couple doors down the hall
04:42:23 <SoleSoul> t7: is it a function which needs that? can you elaborate on the context?
04:42:25 <earthy> but that was then. now I'm across the country. :)
04:42:30 <SoleSoul> earthy: oh, you work near them?
04:42:33 <Axman6> t7: case foo of _ | guard1 -> result 1 | guard2 -> result2
04:42:37 <t7> SoleSoul: inside a do block
04:42:44 <earthy> I used to be in the same research group
04:42:56 <t7> Axman6: but what do i put in foo?
04:42:59 <t7> undefined?
04:43:03 <Axman6> sure
04:43:05 <Axman6> or ()
04:43:11 <Axman6> those are common choices
04:43:37 <Axman6> better yet though, use: where result | guard1 = result1 | guard2 = result2
04:44:06 <t7> ah ok
04:47:20 <Guest56670> TRH: Maybe you want to subscripe to the haskell beginners mailing list (http://www.haskell.org/haskellwiki/Mailing_Lists) and state your problem there
04:47:28 <SoleSoul> earthy: cool! Internet is magic :) You know, the only place I could find which has people who know about this OS is  here in this channel.
04:48:06 <TRH> Guest55670: Thanks, for your help, i will do that
04:56:33 <earthy> solesoul: not that weird, as NixOS is too far from the beaten path to have a large following, *plus* it was developed in the Utrecht University Software Engineering research group
04:56:58 <earthy> and that group is strong with Haskell. :)
04:58:16 <SoleSoul> earthy: Do you know if it's still maintained? I think there is even no forum for it.
05:02:02 <earthy> there's a mailing list
05:02:32 <earthy> that actuall still has traffic on it
05:03:01 <earthy> http://lists.science.uu.nl/mailman/listinfo/nix-dev
05:06:53 <ziman> hello, I want to create a Haskeline computation of type "InputT (StateT MyState IO) ()" from a computation of type "StateT MyState IO ()". Does anybody have a clue where I could get the "lift" function needed for this? (Haskeline uses transformers, not mtl).
05:09:26 <osager> hi all, when i use fold, how can i keep track of the index in the list i'm processing ?
05:10:11 <osager> in c, i use for(i=0; i<10;i++), so i have the index
05:10:16 <ziman> osager, you can zip the list with [1..] beforehand
05:10:25 <ziman> (or [0..] if you prefer)
05:10:40 <osager> ok i'll take a look at the zip function ziman
05:10:47 <Axman6> :t zip
05:10:48 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
05:10:59 <Axman6> > zip [0..] "Hello osager"
05:11:00 <lambdabot>   [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'o'),(7,'s'),(8,'a'),(9...
05:11:16 <Botje> ziman: according to hayoo InputT is an instance of MonadTrans, which has lift
05:11:35 <osager> ok so i need to create an intermediate list
05:11:38 <osager> of tuples
05:11:48 <Botje> osager: yes, that's what zip does for you.
05:11:48 <Axman6> yes
05:11:58 <osager> ok thanks everyone
05:12:28 <amgarching> foldl (\ x y -> (fst x + y, snd x + 1)) (0, 0) [1, 2, 3]
05:12:39 <t7> are C++ templates based on system-f ?
05:13:27 <Axman6> i think they're based on smoking pot
05:13:34 <ziman> Botje, oh, I overlooked it, thanks.
05:13:36 <ion> I wouldn’t expect C++ design to be based on anything formal. :-P
05:13:44 <pozic> I think there are based on the c preprocessor.
05:51:30 * hackagebot Holumbus-Searchengine 1.2.3 - A search and indexing engine.  http://hackage.haskell.org/package/Holumbus-Searchengine-1.2.3 (UweSchmidt)
05:51:35 <iNeedHelp> hi, i neeed help I'm totally confused... i need to run Ghc 7.4 with DPH but i dont know to do it
05:52:00 <rostayob> doesn't ghc 7.4 come with DPH?
05:52:42 <Axman6> there's a flag for it, but i can't remember what it is
05:52:49 <Axman6> iNeedHelp: why do you need DPH?
05:53:37 <rostayob> iNeedHelp: http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell this is the "documentation" for DPH right now
05:54:37 <iNeedHelp> it said GHC couldn t find the module Data.Array.Parallel.Prelude...
05:54:58 <t7> i start all my types with capitals and all my methods with lower case now. thanks haskell :3
05:55:03 <iNeedHelp> i need to do a work to the college about parallel programming..
05:56:42 <Ptival> t7: and now you have to write OCaml and your habits get screwed :D
05:56:54 <Ptival> oh wait that's me...
05:57:01 <statusfailed> If I have a function taking a Num a, and I need a zero value of a, should I use fromInteger 0 to get it?
05:57:22 <ion> :t 0
05:57:23 <lambdabot> forall t. (Num t) => t
05:57:43 <Ptival> magic
05:57:56 <ion> A literal “0” already means “fromInteger 0”.
05:58:01 <statusfailed> oh whoops :D
05:58:10 <mux> yes but it won't necessarily chose the same Num type
05:58:20 <mux> he'd need to use asTypeOf or ScopedTypeVariables and an annotation
05:59:00 <ion> I’m almost certain he’s doing something where he doesn’t need to care about any of that. :-P
05:59:05 <mux> (if the compiler cannot know he wants the same Num type)
05:59:05 <statusfailed> ion is right :p
05:59:19 <mux> I meant, that's a possibility
05:59:42 <pozic> mux: why don't you rewrite the FreeBSD kernel in Haskell? ;)
05:59:54 <quicksilver> a literal 0 will always choose the same Num type as "fromInteger 0"
05:59:57 <statusfailed> mux: what do you mean by "won't necessarily choose the same Num type"?
06:00:04 <quicksilver> they are absolutely equivalent.
06:00:09 <mux> quicksilver: the same Num type as the one he takes as a parameter to his function
06:00:12 <mux> so not
06:00:16 <quicksilver> nonetheless
06:00:22 <quicksilver> the two are absolutely equivalent
06:00:26 <ion> Contrived example: (yourFunction foo, 0) “oh, and i want the 0 to have the same type” (which makes little sense)
06:00:28 <Axman6> ion: something about that definition makes my head go into an infinite loop: 0 means fromInteger 0 which must then mean fromInteger (fromInteger 0) which must mean...
06:00:33 <quicksilver> a literal 0 is "fromInteger 0"
06:00:55 <mux> pozic: because it'd be useless? :p
06:09:37 <statusfailed> Is there a library of columnwise operations for hmatrix?
06:09:44 <statusfailed> like mean, sum, range, etc.
06:09:54 <statusfailed> I need to center some data
06:21:25 <iNeedHelp> when i use the command cabal list i'm getting these error 'cabal: Couldn't read cabal file "pqc/0.5/pqc.cabal"' ... any idea?
06:33:14 <zhulikas> @hoogle String -> Text
06:33:14 <lambdabot> Data.Text.Lazy pack :: String -> Text
06:33:14 <lambdabot> Data.Text pack :: String -> Text
06:33:15 <lambdabot> Prelude read :: Read a => String -> a
06:37:02 <zhulikas> @hoogle Text -> String
06:37:02 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
06:37:03 <lambdabot> Data.Text.Internal showText :: Text -> String
06:37:03 <lambdabot> Data.Text.Lazy unpack :: Text -> String
06:49:24 <t7> i wish c# had pattern matching
06:49:34 <t7> haskell has spoilt me
06:51:34 * hackagebot Hayoo 1.2.3 - The Hayoo! search engine for Haskell API search on hackage  http://hackage.haskell.org/package/Hayoo-1.2.3 (UweSchmidt)
07:03:34 <zhulikas> t7, hey, at least c# has lambda expressions
07:03:54 <t7> even C++ has lambda expression now
07:04:02 <parcs`> lambda expressions aren't a big deal
07:04:05 <t7> thats nothing to boast about
07:04:15 <zhulikas> still better than nothing
07:04:24 <zhulikas> let's say comparing to Java
07:04:25 <parcs`> first-class functions are, and most languages have had those for a while
07:04:26 <t7> i so rarely use anonymous functions anyway....
07:04:45 <zhulikas> t7, have you tried F#?
07:05:03 <parcs`> t7: why do you want pattern matching? does c# have sum types?
07:05:08 <t7> never tried, i have had a look though
07:05:20 <zhulikas> I am considering to learn F#
07:05:28 <t7> parcs`: abstract classes
07:05:58 <t7> would be nice to unpack a struct in one line too
07:06:43 <ronankde> somebody have a vim autocomplete for haskell
07:07:11 <zhulikas> true
07:08:19 <Taneb> Hello!
07:08:34 <Taneb> What format would you people use for a family tree?
07:11:00 <Taneb> Preferably, I'd like it to be writable to a file, and readable from it
07:15:13 * linkbuck hi all
07:15:19 * linkbuck hi all
07:16:37 * hackagebot MagicHaskeller 0.8.6.3 - Automatic inductive functional programmer by systematic search  http://hackage.haskell.org/package/MagicHaskeller-0.8.6.3 (SusumuKatayama)
07:17:02 * ski thinks linkbuck should try to not abuse `/me' :)
07:19:41 * edwardk why? =)
07:20:25 <dmwit> ?tell Taneb Use a graph. Family trees have a nasty habit of not being trees.
07:20:26 <lambdabot> Consider it noted.
07:20:26 * ion /me is fine.
07:20:53 <Jafet> But... can the graph contain cycles
07:21:04 <ski> it's fine for when your nick naturally fits into a sentence
07:21:15 <dmwit> Jafet: There's a famous StackOverflow question which answers that question affirmatively. =)
07:21:29 <ion> Family digraph
07:21:47 <Jafet> Actually, there isn't any known instance of a cycle
07:21:50 <ski> (and yes, i'd prefer it if hackagebot and hpaste and preflex did NOTICEs)
07:22:01 <ion> ski: Hear, hear!
07:22:21 <Jafet> Unless some fella is 'is own grandpaw
07:22:42 <dmwit> Family trees typically have some non-biological edges.
07:22:49 <dmwit> s/typically/often/
07:23:15 <ski> (well, lambdabot too of course)
07:23:24 * linkbuck http://ef741e91.linkbucks.com Welcome
07:23:40 <dmwit> Damn, idoru, that was freaking fast.
07:23:45 <Jafet> linkbuck was too ACTION-oriented.
07:27:29 <quicksilver> I think idoru has K-line rules for certain popular spam
07:27:39 <quicksilver> I don't want to try to prove that by experimenting :P
07:27:45 <Jafet> Like people posting http://ef741e91.linkbucks.com ?
07:28:01 <Jafet> Surely it's sophisticated enough.
07:28:08 <quicksilver> I imagine it will be related to it being one of your first messages
07:28:20 <quicksilver> and or the proprotion of messages you've made, how many channels you post it in, etc.
07:28:24 <quicksilver> who knows ;)
07:28:56 <dmwit> Duh, of course idoru is a bot.
07:29:09 <marienz> Jafet: please don't repaste spam
07:29:14 * dmwit feels bashful
07:29:16 <quicksilver> :)
07:29:30 <quicksilver> marienz: did Jafet get himself flagged?
07:29:54 <marienz> quicksilver: if "flagged" means "made my client go beep" then yes
07:30:09 <quicksilver> :)
07:30:30 <Jafet> Curiosity klines the cat
07:30:35 <quicksilver> quite
07:31:11 <Saizan> uh, i didn't get the original spam message, i guess a k-line is powerful like that
07:31:34 <Jafet> Spammers are unpersons
07:33:42 <zhulikas> @hoogle String -> Text
07:33:42 <lambdabot> Data.Text.Lazy pack :: String -> Text
07:33:43 <lambdabot> Data.Text pack :: String -> Text
07:33:43 <lambdabot> Prelude read :: Read a => String -> a
07:34:06 <quicksilver> idoru has always been at war with eurasia
07:35:27 <ion> What linkbuck did is (unsurprisingly) against the site’s policy. Someone should report him. http://www.linkbucks.com/termsandconditions/
07:36:28 <reeee> hi all,
07:36:31 <reeee> someone there?
07:36:51 <ski> someone is here
07:37:08 <reeee> nice
07:37:22 <reeee> @ski dont know if you can help
07:37:22 <lambdabot> Maybe you meant: ask src wiki
07:37:39 <ski> if you have a (Haskell-related) question, just ask it :)
07:37:56 <reeee> @ski it 's haskell related
07:37:56 <lambdabot> Maybe you meant: ask src wiki
07:38:05 <reeee> just a few explanations
07:38:13 <ski> (also, don't do "@ski ..." do "ski : ...")
07:38:23 <ion> This isn’t French. ;-)
07:39:02 <reeee> ski : ok my background is some C C++ and some java
07:39:09 <ski> ok
07:39:19 <reeee> after that i turned into MAXmsp puredata programming
07:39:30 * ski doesn't know about that one
07:39:31 <reeee> dont know if you see...
07:39:49 <reeee> ok it 's mainly some C C++ on which on top a gui was put
07:40:02 <reeee> my main goal is to come into live coding
07:40:11 <reeee> for real time  DSP
07:40:17 <reeee> digital signal processing
07:40:20 <reeee> audio video
07:40:28 <ski> mhm
07:40:34 <reeee> i also recently switched to Fbsd 9.0
07:40:42 * ski knows very little about that kind of thing
07:40:48 <reeee> from mac previously win
07:41:02 <mux> good move ;-)
07:41:07 <reeee> ok np ;)
07:41:19 <ski> maybe someone else here can tell you what packages to try for DSP in Haskell
07:41:30 <reeee> so i am a bit confused on which lang i should go
07:41:38 * hackagebot composition 1.0.1.0 - Combinators for unorthodox function composition  http://hackage.haskell.org/package/composition-1.0.1.0 (DanBurton)
07:41:39 <reeee> my maibn goal is some live coding as i said
07:42:07 <reeee> yep thx
07:42:30 <reeee> i already got a big list of specialised language for that
07:42:56 <reeee> but the main specialized capacity it nedd t have is to be able to modify the apps while running
07:43:14 <reeee> LIVE CODING
07:43:25 <reeee> my searches brought me to lisp or haskell
07:43:33 <reeee> for advanced stuffs
07:43:34 <Jafet> Haskell implementations don't support that
07:43:55 <Jafet> Perhaps you should use erlang.
07:43:57 <tromp__> erlang might
07:44:15 <reeee> yeah i also read about
07:44:19 <reeee> is it a new one ?
07:44:23 <reeee> never heard about
07:44:31 <Jafet> Yes, it's only been around for over twenty years?
07:44:41 <reeee> iam mainly seeking something realy  modulable
07:44:42 <reeee> ;)
07:44:49 * ski wonders whether <http://www.pawfal.org/fluxus/> (for Scheme) could be useful
07:44:54 <reeee> sry as i said i got no huge background
07:45:05 <reeee> yep fluxus is one of them
07:45:19 <reeee> but am seeking for something more flexible
07:45:25 <sm> racket
07:45:48 <reeee> i also heard about racket
07:45:52 <reeee> but dont know it
07:46:08 <reeee> http://toplap.org/index.php?title=ToplapSystems
07:46:19 <reeee> have a look at this there you see a bit more what i am talking about
07:46:22 <sm> or if you're brave, get haskell's plugins-auto working
07:46:31 <sm> http://hackage.haskell.org/package/plugins-auto
07:46:39 <reeee> could you explain a bit further?
07:46:42 <reeee> brave i am ;)
07:46:50 <reeee> i plan to get in depth on those things
07:46:58 <reeee> like auto adaptation of the application
07:47:08 <ski> roconnor : you use Nix, yes ?
07:47:12 <reeee> in reaction to datas collected trough sensors
07:47:16 <reeee> yes
07:47:19 <reeee> FSBD 9.0
07:48:22 <reeee> sm : i see but there need to be no stop in the DSP
07:48:34 <reeee> must be full Realtime
07:48:46 <reeee> i was also asking myself if a RTos wouldn't be better
07:48:49 <sm> reeee: haskell isn't really well adapted for loading new code at runtime, still lots of people have tried to do it. That package is a recent attempt that probably works more or less
07:48:54 <reeee> but not so much experienced
07:48:56 <roconnor> ski: yes
07:49:12 <ski> SoleSoul was wondering about it a couple of hours ago
07:49:28 <sm> reeee: haskell also has garbage collection delays which may be noticeable for you
07:49:34 <t7> holy shit c# equality is retarded
07:49:44 * ski notes SoleSoul apparently has left now (has registered nick, though)
07:50:28 <ski> earthy pointed them to <http://lists.science.uu.nl/mailman/listinfo/nix-dev> for help/info
07:50:38 <roconnor> not to #nixos?
07:50:41 <ski> t7 ?
07:50:57 <ski> hm, no
07:51:09 * ski didn't recall there was a channel (ought to have suspected it, though)
07:51:25 <ski> i suppose we could add a `@tell'
07:52:23 <ski> @tell SoleSoul roconnor mentioned #nixos
07:52:24 <lambdabot> Consider it noted.
07:52:43 <roconnor> :)
07:54:02 <nand`> Time to bootstrap GHC on gentoo
07:54:29 <ski> (earthy seemed to suggest that it was hard (for a newbie) to configure stuff in it if you didn't have the developers next door)
08:00:20 <t7> ok i give up with c#
08:00:25 <t7> id love to say it was fun
08:00:53 <t7> but 200 lines of c# is the same as 40 of haskell
08:00:59 <t7> and haskell is so much clearer
08:01:11 <ski> if you need .NET, F# might be nicer
08:01:28 <ski> (there an ##fsharp channel here, as well)
08:02:31 <Taneb> dmwit, indeed
08:08:23 <tibbe> Is there an applicative version of =<<?
08:08:56 <nand`> applicatives have bind?
08:09:13 <tibbe> something with that type
08:09:21 <tibbe> I guess the answer is no
08:09:38 <tibbe> now when I think about it for a sec
08:09:53 <nand`> =<< = flip >>= and implementing >>= requires join, which applicatives do not have
08:10:15 <Taneb> What's the difference between a Map and a HashMap?
08:10:23 <nand`> (=<<) = flip (>>=) rather
08:10:33 <Jafet> HashMap is Map on drugs.
08:10:46 <Taneb> Jafet, that doesn't tell me much.
08:11:06 <t7> are there any languages with a pure type system?
08:11:27 <nand`> Can a type system be impure?
08:11:39 * hackagebot monad-exception 0.1 - Exstensible monadic exceptions  http://hackage.haskell.org/package/monad-exception-0.1 (ShaneOBrien)
08:11:41 <koala_man> t7: wikipedia has a list
08:11:52 <t7> ah ok
08:11:55 <nand`> Well, a strict type system
08:12:21 <t7> i think after kinds its just theory wankery really :P
08:13:07 <tibbe> Taneb: HashMap is unordered (and faster)
08:13:30 <tibbe> Taneb: Map would be your Java TreeMap
08:13:59 <Taneb> tibbe, I don't know Java!
08:14:12 <tibbe> Taneb: your scala SortedMap
08:14:17 <tibbe> which language do you want!?!? ;)
08:14:23 <Taneb> tibbe, I pretty much just know Haskell
08:14:28 <rwbarton> in Haskell it is called Map
08:14:37 * tibbe was being silly.
08:14:45 <Taneb> :)
08:14:58 <Taneb> But yeah, I don't care about order, so HashMap seems better
08:15:05 <Taneb> Especially as the keys are strings!?
08:16:49 <ChristianS> Taneb: for large collections, HashMap should be faster. for small, it doesn't generally matter in my experience.
08:17:39 <ChristianS> Taneb: beware, there are two Data.HashMap implementations -- one in unordered-containers, one in hashmap. unordered-containers is the package you want.
08:18:04 <Taneb> That's the one I have
08:18:14 <hpaste> dzhus pasted “Dynamic programming problem” at http://hpaste.org/64594
08:18:25 <Taneb> Right, my amazing family tree type:
08:18:28 <Taneb> type FamilyTree = IntMap (HashMap String String, Int, Int, IntSet)
08:18:50 <Taneb> Designed specifically for Aesoniness
08:19:13 <tgeeky_> Taneb: that's your family tree? Your fater was a String, and your mother was an IntSet?
08:19:18 <tgeeky_> *father*
08:19:31 <Taneb> Yeah, weird family
08:21:50 <ChristianS> Taneb: for serious string processing, i would suggestion Data.Text instead of String -- should be faster. aeson handles Text too, as far as i know.
08:22:51 <ski> nand` : what do you mean by the question ? implemented in an impure way ? allows impure code to type-check ? other ?
08:23:07 <Taneb> ChristianS, hmm
08:24:14 <tgeeky_> Tene: for comedic string processing, I would suggestion Data.String.Lolspeak
08:24:25 <tgeeky_> s/Tene/Taneb/
08:24:37 <tgeeky_> my barely-acceptable joking banter keeps getting thwarted by typos
08:24:46 <xraycat> :-)
08:24:52 <Taneb> I'm gonna use my alt nick.
08:24:57 <Taneb> It's less mistabbable
08:26:30 <Ngevd> Right, I now have Data.Text installed
08:27:10 <Athas> Curiousity: why doesn't GHC use (only) Cabal?
08:27:34 <Ngevd> Import list so far: 9 lines. Actual program: 1 lines
08:27:36 <Athas> I'm aware that there are some issues related to bootstrapping, but apart from that, what prevents a Haskell compiler from just being any other Haskell program?
08:28:26 <tgeeky_> Athas: the handful of built-in syntax that isn't valid haskell, like lists and a few others
08:28:35 <tgeeky_> Athas: maybe that's not right, but I think that should count
08:30:12 <dcoutts> Athas: ghc includes lots of generated files, C code, Cmm code, and the bootstrapping does make it more complex
08:31:32 <TheMG> is there a way to match only when two args match?
08:31:44 <TheMG> (and to use a different version when they dont)
08:31:52 <TheMG> f x x didnt work
08:32:03 <TheMG> or is there a good way to accomplish the same idea
08:32:11 <Ngevd> f x y | x == y
08:35:22 <Athas> dcoutts: I suppose that maybe cabal simply doesn't scale.
08:35:37 <Athas> In other matters, does anyone have experience with the GHC supercompiler plugin?
08:35:46 <Athas> I'm trying to figure out its general state.
08:36:40 * hackagebot nlp-scores 0.2.2 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.2.2 (GrzegorzChrupala)
08:40:02 <hpaste> killy9999 pasted “list reverse” at http://hpaste.org/64602
08:40:14 <killy9999> what is the more efficient way of doing list reverse?
08:40:26 <killy9999> except for using Data.List reverse
08:40:51 <yitz> @src reverse
08:40:51 <lambdabot> reverse = foldl (flip (:)) []
08:41:15 <killy9999> foldl is more efficient?
08:41:42 * hackagebot nlp-scores 0.2.3 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.2.3 (GrzegorzChrupala)
08:41:51 <killy9999> or the trick is that : is more efficient than ++ because it doesn't require rewriting of the list?
08:42:52 <DevHC> it's time to panic
08:42:56 <DevHC> teh impossible(TM) has happened
08:43:11 <DevHC> "thread blocked indefinitely in an MVar operation"
08:43:26 <DevHC> GHC 7.0.4, i386-unknown-mingw32
08:43:30 <yitz> killy9999: if you are not compiling with -O, or if you are using it in ghci, you would use foldl' instead of foldl
08:43:32 <rwbarton> killy9999: your reverse' is O(n^2) time, because (++) has to copy the left list, yes
08:43:49 <rwbarton> Prelude's reverse is O(n)
08:44:23 <ski> TheMG : unfortunately no non-linear patterns in Haskell
08:47:58 <aceilnos> Hi, I'm new to Haskell and just started with Learn You a Haskell, my issue is that whenever I try to define a function in ghci  it tells me "parse error on input `='", does anyone know what's up?
08:47:59 <yitz> rwbarton: i'm not sure the elements themselves would actually be copied that many times. but you would have O(n^2) list boxings/unboxing, and no way for the compiler to optimize them away.
08:48:17 <yitz> aceilnos: use let
08:48:30 <yitz> let f x = x ^ 2
08:48:43 <aceilnos> yitz: thanks, I'll give it a go
08:49:14 <alpounet> @index (</>)
08:49:14 <lambdabot> Text.Html
08:49:18 <alpounet> nah
08:49:24 <alpounet> @hoogle </>
08:49:24 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
08:49:25 <ski> aceilnos : alternatively, define it in a source file as `f x = x ^ 2', and load that file with `:l MyFile.hs' in GHCi
08:49:25 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
08:49:47 <ski> you can use `:r' to reload all loaded files
08:50:16 <parcs`> DevHC: was that ghci?
08:50:47 <aceilnos> ski: yeah, I was doing that but I wanted to find out what I'm doing wrong
08:51:51 <ski> aceilnos : GHCi primarily accepts expressions, while you primarily write definitions in a file
08:52:06 <ski> aceilnos : you need to prefix with `let' if you want to define in GHCi
08:52:21 <ski> (and if you want to put an expression in a file, you have to put it inside a definition)
08:52:28 <aceilnos> yeah, yitz just told me that
08:57:44 <DevHC> parcs`: yes
08:59:54 <aceilnos> another thing, on the Try Haskell page tutorial it showed me "sort" which my GHCi doesn't accept, does anyone know why?
09:00:25 <alpounet> aceilnos, you have to import Data.List for that
09:00:26 * DanBurton cackles evilly. At last, I'm not the last one on the Monad tutorials timeline!
09:00:31 <ski> @index sort
09:00:31 <lambdabot> Data.List
09:00:45 <aceilnos> ah right, thanks
09:00:53 <ski> so `:m + Data.List'
09:01:22 <DanBurton> random question: where does the `code' convention come from?
09:02:15 <quicksilver> DanBurton: the way troff formats manual pages for ascii terminals, I suspect.
09:02:21 <quicksilver> nroff, I mean.
09:04:45 <MagneticDuck> Hey, I have a quick question about good Haskell style...
09:05:07 <DanBurton> MagneticDuck: I have a slow answer
09:06:00 <alpounet> and an awesome sense of humor :P
09:06:15 <MagneticDuck> I'm making a quick program that will basically deal with rotating a cube.
09:06:44 <MagneticDuck> I need a type that says what side of the cube is pointed at the user.
09:06:51 <Tinned_Tuna> Heya, What's the current state of plugins in Haskell, I've bumped into System.Plugin and System.Plugin.Auto and I was wondering if any one knows how suitable/stable they are for real-world usage?
09:06:59 <MagneticDuck> I declare type CubeFace = Int
09:07:10 <Tinned_Tuna> I.e. has anyone used either of them, and how was their experience with them?
09:07:21 <MagneticDuck> Then, I have a data type that declares the direction to rotate the cube.
09:07:38 <MagneticDuck> I declare data RotDir = Up | Down | Left | Right
09:07:49 <MagneticDuck> However, it just doesn't seem right...
09:08:21 <Ngevd> Up | Right | Down | Left deriving (Enum)
09:08:26 <MagneticDuck> that sometimes I use a type synonym and sometimes a data type to declare two things that seem pretty just the same.
09:08:26 <Ngevd> Is what I would do
09:08:28 <DanBurton> MagneticDuck: it might be wise to declare `data CubeFace = Top | Front | Right | Left | Bottom | Back
09:08:35 <roconnor> a cube can be rotated positively or negatively along each of the 3 axes
09:08:44 <DanBurton> of course that would overlap with Right/Left from RotDir
09:08:51 <roconnor> or alternatively, a cube can be rotated clockwise along each of the 6 faces.
09:08:51 <MagneticDuck> Yeah... so I could make both data types using words...
09:08:52 <Ngevd> And from Either
09:08:57 <MagneticDuck> but I like math.
09:09:07 <yitz> DanBurton: but the cube rotates, any given side might be in any of those positions
09:09:22 <MagneticDuck> Yeah.
09:09:22 <srhb> > sequence $ map (\s -> s >>= return . read) [getLine]
09:09:23 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:09:23 <lambdabot>    `GHC.Read.Read a'
09:09:23 <lambdabot>      a...
09:09:26 <Tinned_Tuna> It's Maybes all the way down.
09:09:28 <srhb> That's strange..
09:09:30 <DanBurton> yitz: is it the cube that rotates, or is it the user moving around the cube?
09:09:54 <MagneticDuck> Well, the user could specify the cube to be rotated.
09:10:02 <DanBurton> you can just pick an arbitrary rotation and decide that it is "absolute", and then consider other points of view to be relative to that absolute
09:10:07 <srhb> Why does the above code not fail in the same way in my ghci? I get Prelude.read: no parse -- while I expect ambuguous type variable.
09:10:08 <MagneticDuck> And then the program would display the front side of the cube.
09:10:10 <yitz> DanBurton: i assume the CubeSide type will become richer, with other data attached to each side besides just a unique id
09:10:39 <MagneticDuck> My question is, should I use type synonyms and ints, or data types? I'm learning towards type synonyms...
09:11:02 <yitz> MagneticDuck: i wrote a cube-related program (quite a while back) in the style you are suggestion, and in retrospect it worked out very well
09:11:14 <MagneticDuck> Type synonyms?
09:11:16 <DanBurton> MagneticDuck: data types are safer
09:11:28 <MagneticDuck> DanBurton: Why?
09:11:29 <DanBurton> type synonyms are more convenient
09:11:40 <MagneticDuck> DanBurton: Agreed.
09:11:56 <DanBurton> safer because Int has more values than 1 through 6
09:12:14 <MagneticDuck> Yeah...
09:12:22 <quicksilver> a rule of thumb is never use type synonyms.
09:12:27 <MagneticDuck> So, I can't specify a type to be a range of numbers?
09:12:32 <quicksilver> I'm not saying they're useless, but that's a rule of thumb.
09:12:43 <quicksilver> in your particular example, it's black and white.
09:12:54 <ski> @type sequence $ map (\s -> s >>= return . read) [getLine]
09:12:55 <ski> @type mapM (liftM read) [getLine]
09:12:55 <lambdabot> forall a. (Read a) => IO [a]
09:12:56 <lambdabot> forall a. (Read a) => IO [a]
09:13:01 <quicksilver> you should not under *any* circumstance consider using a type synonym over Int for that.
09:13:03 <DanBurton> MagneticDuck: not really. You can derive Enum which is basically the same, though
09:13:11 <quicksilver> that's a cut-and-dried example of a nice custom data type.
09:13:11 <MagneticDuck> Quite split opinions!
09:13:19 <ski> srhb : defaulting, presumably
09:13:24 <MagneticDuck> @src Enum
09:13:24 <lambdabot> class  Enum a   where
09:13:24 <lambdabot>     succ                     :: a -> a
09:13:25 <lambdabot>     pred                     :: a -> a
09:13:25 <lambdabot>     toEnum                   :: Int -> a
09:13:25 <lambdabot>     fromEnum                 :: a -> Int
09:13:26 <lambdabot> [3 @more lines]
09:13:30 <yitz> MagneticDuck: you might want to do something like data CubeFace a = CubeFace a (CubeFace a) (CubeFace a), where the current face and the other two are, say, clockwise around a corner
09:13:36 <srhb> ski: But I can't even see what it defaults to?
09:13:47 <yitz> MagneticDuck: then you construct your cube using "tying the knot"
09:14:01 <srhb> It does not parse ints, chars or Strings.
09:14:33 <DanBurton> yitz: interesting...sort of a cyclical 2D zipper
09:14:34 <ski> srhb : i would assume it defaults to `()'
09:14:40 <yitz> MagneticDuck: now it doesn't depend on arbitrary Int values, and its representation is independent of orientation.
09:14:46 <MagneticDuck> Trying to visualize that...
09:14:56 <srhb> ski: How odd.
09:15:03 <ski> @check \x y -> x == y
09:15:04 <lambdabot>   "OK, passed 500 tests."
09:15:16 <DanBurton> yeah it defaults to () unless you give it a better type
09:15:17 <srhb> You are correct. Why does that make sense?
09:15:31 <yitz> MagneticDuck: if you choose the corner carefully for each face, you can walk over the entire cube just by following those links
09:15:32 <srhb> Shouldn't it just barf like lambdabot? That seems to make more sense.
09:15:34 <ski> srhb : what would you prefer it default to ?
09:15:35 <DanBurton> @check (\x y -> x == y where types = (x::Int))
09:15:36 <lambdabot>   Parse error at "where" (column 17)
09:15:42 <ski> or should it not default at all in this case ?
09:15:42 <DanBurton> doh
09:15:44 <srhb> I would not prefer it to default, I would prefer it to not compile.
09:15:48 <ski> @check \x y -> x == (y :: Bool)
09:15:49 <lambdabot>   "Falsifiable, after 0 tests:\nFalse\nTrue\n"
09:15:56 <MagneticDuck> yitz: Ah, yeah!
09:16:42 <DanBurton> yitz, MagneticDuck: imho it would be simpler to have a link to the 4 adjacent sides
09:16:44 <ski> yitz : how about modifications ?
09:17:05 <yitz> DanBurton: maybe, but then you lose independence of orientation.
09:17:15 <MagneticDuck> DanBurton: Yeah, because that's how I'm going to navigate the cube anyhow.
09:17:25 <DanBurton> yitz: true
09:17:26 <quicksilver> srhb: yes, extended defaulting is annoying.
09:17:28 <ski> @check \x y -> let _ = x :: Int in x == y
09:17:29 <lambdabot>   "Falsifiable, after 0 tests:\n1\n0\n"
09:17:45 <srhb> quicksilver: Is it a Haskell feature or a ghc feature? Can I disable it?
09:17:45 <quicksilver> extended defaulting is not part of haskell, I don't think
09:18:11 <MagneticDuck> I'll get writing! I guess I'll choose a name for each side, though... so I can display it.
09:18:15 <hpc> i think if it was part of haskell, it would just be called "defaulting" :P
09:18:21 <dolio> What would it be extended from, if it were part of Haskell?
09:18:28 <srhb> Huh, I thought by default I would be writing Haskell code if I didn't change anything.
09:18:41 <DanBurton> srhb, quicksilver: i'm 80% sure extended defaulting is only a hack for ghci
09:18:42 <quicksilver> srhb: some motivation here ; http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
09:18:52 <srhb> DanBurton: Thanks
09:18:54 <quicksilver> DanBurton: well you can turn it on for compiling if you really want.
09:18:54 <hpc> srhb: ghc has always been haskell plus REEEEAALLY minor additions
09:18:57 <DanBurton> but beware the monomorphism regardless
09:19:04 <yitz> DanBurton, MagneticDuck: actually this representation still isn't totally independent of orientation.
09:19:05 <DanBurton> *monomorphism restriction
09:19:15 <hpc> (like module heirarchy
09:19:49 <quicksilver> the main motivation for extended defaulting is just a limitation, that you can't Show polymorphic types
09:20:06 <quicksilver> basically you want to be able show [] as "[]"
09:20:19 <quicksilver> and whilst [] is perfectly well behaved term it has a polymorphic type
09:20:26 <quicksilver> and you have to pick a type, to show it.
09:20:33 <dolio> That one's not a problem.
09:20:42 <quicksilver> it's  problem for ghci, dolio
09:20:45 <dolio> No.
09:20:58 <quicksilver> why not?
09:21:28 <dolio> Well, maybe I'm wrong, because you need to pick a Show dictionary.
09:21:37 <quicksilver> you are wrong.
09:21:43 <quicksilver> > ([] :: [Int])
09:21:44 <lambdabot>   []
09:21:47 <quicksilver> > ([] :: [Char])
09:21:47 <lambdabot>   ""
09:21:48 <dolio> It's only a problem when you need to pick a dictionary, though.
09:22:00 <quicksilver> yes, the problem is because ghci has to 'Show' things.
09:22:16 <hpc> > ""
09:22:17 <lambdabot>   ""
09:22:17 <quicksilver> the problem is that ghci doesn't live *outside* the language and just dump compiler representation
09:22:18 <rwbarton> what happens in hugs if you type []?
09:22:24 <quicksilver> but it lives *inside* the language
09:22:28 <quicksilver> and is bound by its restrictions
09:22:32 <quicksilver> like the way Show instances work.
09:22:38 <yitz> DanBurton MagneticDuck: for that you would need data QuarterFace a = QuarterFace a (QuarterFace a) (QuarterFace a)
09:23:05 <ski> quicksilver : hm, maybe they could default to `Any' ?
09:23:32 <dolio> That happens in other situations when the type is unconstrained.
09:23:49 <yitz> DanBurton MagneticDuck: where the first link points to the next quarter face on the face clockwise, the second link points to the next quarter face clockwise around the adjacent corner, and all four corners on a face point to the same value of a.
09:24:43 <MagneticDuck> yitz: I'll have to think about this!
09:24:48 <dolio> I don't think Any has a Show instance, though.
09:25:44 <yitz> MagneticDuck: now if you have a specific QuarterFace object, it fixes an orientation of the cube completely: e.g., that could be the upper left corner of the face towards the user
09:26:00 <Guest4889> how can i print something like "ä" to the screen without getting the UTF-8 decoding error?
09:26:15 * ski tries in SML/NJ
09:26:30 <Phlogistique> Guest4889: what system are you using?
09:26:38 <yitz> MagneticDuck: and from that QuarterFace, you can get to anywhere on the cube, with exactly the same sequence of links no matter what the orientation of the cube.
09:27:08 <Guest4889> phlogistique: windows 7
09:27:31 <ski> SML/NJ dynamically invents types `?.X1',&c., used a bit similarly as `Any' i think, but apparently it doesn't make them `eqtypes'
09:27:34 <Phlogistique> oops
09:27:36 <Phlogistique> no@yorceev ~ % echo $LANG
09:27:36 <Phlogistique> en_US.UTF-8
09:27:36 <Phlogistique> no@yorceev ~ % ghc -e 'putStrLn "ä"'
09:27:36 <Phlogistique> Ã¤
09:27:41 <Phlogistique> now there is something wrong.
09:28:14 <ski> i suppose it could be good to invent a type which (vacuously) satisfied the constraints on it
09:28:27 <rwbarton> > "ä"
09:28:28 <lambdabot>   "\228"
09:28:40 <ski> would at least work for covariantly-only occuring tyvars, i think
09:28:42 <parcs`> what is the memory overhead of a list?
09:29:10 <yitz> parcs`: 8 words per item i think
09:30:16 <Guest4889> thanks
09:30:18 <Guest4889> "ü"
09:30:19 <yitz> parcs`: or maybe it was 8 bytes on a 32-bit system, i can't remember now
09:30:34 <Guest4889> ''ü''
09:30:57 <Guest4889> rwbarton: how do you make the labdabot print the right code for ä?
09:31:09 <rwbarton> by doing what I did
09:31:11 <quicksilver> ski: SML/NJ doesn't rely on 'Show' instances to print types in the repl, though.
09:31:18 <Guest4889> "ä"
09:31:19 <ski> Guest4889 : put `> ' before the expression
09:31:33 <alpounet> in a package archive, do we necessarily have the name of the cabal file == name of the package (case sensitively, i mean)
09:31:33 <Guest4889> uups
09:31:40 <alpounet> (or even, a different name for the cabal file, w/e)
09:31:40 <quicksilver> ski: I find this to be a flaw in ghci's design. Although I appreciate it makes things quite simple in other ways.
09:31:41 * hackagebot nlp-scores 0.3.0 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.3.0 (GrzegorzChrupala)
09:31:42 <ski> quicksilver : no, but it has the concept of `eqtypes', which was what i tested for
09:31:47 <Guest4889> sorry i read over that
09:31:49 <Guest4889> > "ü"
09:31:50 <lambdabot>   "\252"
09:31:50 <quicksilver> ski: *nod*
09:32:15 <parcs`> ski: this post http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html says that a string is 5n words, so maybe a list is 4n words (assuming a char is 1 word)?
09:32:17 <ski> (i did `val x = (fn x => x) []' then tried `x = x')
09:32:40 <quicksilver> ski: I think it would be much more consistent for a haskell repl to show terms at their principal type, not to have to monomorph them just to feed them to show.
09:32:41 <dcoutts> alpounet: yes the package name and .cabal file name should match, case sensitively
09:33:18 <alpounet> dcoutts, great, thanks for enforcing that, will make my next hour simpler :P
09:33:29 <Guest4889> > "ö"
09:33:30 <lambdabot>   "\246"
09:33:31 <rwbarton> quicksilver: so you're saying not to use show at all then?
09:33:52 <rwbarton> that sounds pretty inconvenient in other cases, though
09:35:18 <quicksilver> rwbarton: yes, that is my suggestion.
09:35:26 <hpaste> MagneticDuck pasted “Annoying data types” at http://hpaste.org/64605
09:35:32 <quicksilver> rwbarton: ghci should have a "repr"-style command which lives outside the langauge
09:35:44 <quicksilver> rwbarton: and works on the level of AST, not compiled expression.
09:35:47 <Guest4889> "Ü"
09:35:51 <quicksilver> ghci has its staging wrong, morally.
09:35:52 <Guest4889> > "Ü"
09:35:53 <lambdabot>   "\220"
09:35:55 <quintessence> parcs`: a (:) should be 3 words (header + 2 pointers) and a char should be 2 (header + payload), I think
09:36:03 <MagneticDuck> Alright, I'm having some trouble... I'm not thinking right... I'm having one of those moments when I forgot everything I learned...
09:36:10 <yitz> quintessence: it might be nice to be able to turn that on and off as an option
09:36:20 <yitz> oops quicksilver. sorry quintessence
09:36:32 <MagneticDuck> My code fails on compile with the error 'CubeFace' is not applied to enough type arguments...
09:36:37 <rwbarton> well I agree with the "morally" part, I guess. it sounds like an inconvenience to me though
09:36:38 <quicksilver> yitz: yes, there are quite a few advantages to the current setup also :)
09:36:55 <MagneticDuck> My code's here: http://hpaste.org/64605
09:37:15 <MagneticDuck> This should be fast...
09:37:16 <quicksilver> however a "repr" command could show something for IO actions and functions
09:37:24 <quicksilver> it could perhaps show the package they were defined in
09:37:32 <yitz> MagneticDuck: all the CubeFace a in EdgeLinks should be in parens
09:37:35 <quicksilver> maybe even source code line number if part of the code you're interpreting.
09:37:43 <rwbarton> oh I see what you are saying
09:37:47 <rwbarton> more like :repr, perhaps
09:38:14 <quicksilver> except I'm suggesting it be the 'default thing' it does if you just enter an expression and press return.
09:38:34 <quicksilver> I think entering a complex expression and getting a weird error message about missing Show instances is seriously newbie unfriendly
09:38:39 <rwbarton> 'h' : 'e' : 'l' : 'l' : 'o' : []
09:38:42 <MagneticDuck> Okay, cool.
09:38:43 <rwbarton> good times.
09:38:57 <quicksilver> why would a newbie guess that typing something at the repl would require something called a 'Show instance'
09:39:40 <quicksilver> it means you can't teach haskell gradually without having to say "hmm just ignore that message I can explain it in 4 lesson's time"
09:39:44 <mike-burns> It's more than newbie-unfriendly; it's not useful in 99% of cases.
09:39:50 <quicksilver> that too mike-burns.
09:40:01 <tazjin> > intersperse "/" ["de", "2011", "12", "401051"]
09:40:02 <rwbarton> what isn't?
09:40:02 <lambdabot>   ["de","/","2011","/","12","/","401051"]
09:40:06 <yitz> rwbarton: no, we're past the days of String. it would be: Data.Text.Internal.Text <memory address>
09:40:15 <rwbarton> if I type 1 + 1 then I cannot even show anything at all
09:40:21 <tazjin> Hmm. Is there a version of intersperse that also adds a leading and trailing element?
09:40:24 <rwbarton> yitz: right, again useless
09:40:35 <quicksilver> rwbarton: the message saying "perhaps you should add a Show instance for (a->b)"
09:40:43 <quicksilver> rwbarton: yes, arithmetic is a real problem.
09:40:46 <rwbarton> oh yeah, that message is terrible
09:40:47 <ChristianS> tazjin: don't think so, you have to do it yourself
09:40:48 <yitz> quicksilver: that's a stupid message
09:40:52 <quicksilver> I'd probably still want defaulting for arithmetic.
09:41:06 <tazjin> ChristianS: d'uh, okay
09:41:09 <quicksilver> and the "repr" of 2::Integer could just be 2. That's fine IMO.
09:41:12 <tazjin> @src intersperse
09:41:12 <lambdabot> intersperse _   []     = []
09:41:12 <lambdabot> intersperse _   [x]    = [x]
09:41:12 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
09:41:19 <quicksilver> although I wouldn't mind showing the type too; lots of other repls always show the type.
09:41:23 <quicksilver> (but it could be optional)
09:41:38 <hpaste> DanBurton pasted “Fun with cubes” at http://hpaste.org/64606
09:42:01 <parcs`> quintessence: i see, thanks
09:44:53 <DanBurton> another fun test: prop_rotate4 cube rot = cube == foldr rotate cube (replicate 4 rot)
09:45:01 <MagneticDuck> Going for a walk now, see you later. I'll be thinking about cubes, though! :)
09:47:40 <DanBurton> > [1,2,3] >>= \n -> [map (replicate n)] >>= [a,b,c]
09:47:41 <lambdabot>   Couldn't match expected type `([a] -> [[a]]) -> [b]'
09:47:41 <lambdabot>         against inferr...
09:48:18 <ion> [a,b,c] isn’t a function.
09:48:24 <DanBurton> indeed
09:48:44 <DanBurton> > [a,b,c] >>= \ch -> [1,2,3] >>= \n -> [map (replicate n) ch]
09:48:45 <lambdabot>   Couldn't match expected type `[a]'
09:48:45 <lambdabot>         against inferred type `SimpleRef...
09:49:07 <ion> a isn’t a list.
09:49:28 <DanBurton> > [replicate n ch | n <- [1,2,3], ch <- [a,b,c]]
09:49:29 <lambdabot>   [[a],[b],[c],[a,a],[b,b],[c,c],[a,a,a],[b,b,b],[c,c,c]]
09:49:50 <DanBurton> silly me :)
09:50:42 <mm_freak_> > do n <- [1, 2, 3]; ch <- [a, b, c]; replicate n ch
09:50:43 <lambdabot>   [a,b,c,a,a,b,b,c,c,a,a,a,b,b,b,c,c,c]
09:51:19 <DanBurton> > [a,b,c] >>= \ch -> [1,2,3] >>= \n -> [replicate n ch]
09:51:20 <lambdabot>   [[a],[a,a],[a,a,a],[b],[b,b],[b,b,b],[c],[c,c],[c,c,c]]
09:52:31 <ion> > aaaaaaaaaaaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
09:52:33 <lambdabot>   http://uncyclopedia.wikia.com/wiki/AAAAAAAAA
09:54:33 <monochrom> what?! :)
09:54:42 <DanBurton> wat
09:56:52 * DanBurton wonders how many easter eggs lambdabot has accrued over the years
10:00:14 <hpaste> mee pasted “Data.Set equality” at http://hpaste.org/64610
10:00:37 <srhb> I know there's a strict getContents, but could I use the lazy one in a strict manner by some usage of seq?
10:01:00 <mee> how does Data.Set determine equality between it's elements?
10:01:31 <rwbarton> srhb: yes. you have to demand the entire list though
10:01:44 <JoeyA> mee: Ord implies Eq
10:01:46 <rwbarton> e.g. length contents `seq` whatever
10:02:02 <srhb> rwbarton: Ah right, I was just doing list `seq` foo list to no avail
10:02:09 <roconnor> @let easterEgg = text "http://uncyclopedia.wikia.com/wiki/Easter_egg#Easter_Eggs"
10:02:10 <lambdabot>  Defined.
10:02:12 <mee> JoeyA: ah, so my instance is getting ignored
10:02:14 <roconnor> > easterEgg
10:02:16 <lambdabot>   http://uncyclopedia.wikia.com/wiki/Easter_egg#Easter_Eggs
10:02:41 <JoeyA> mee: Hmm, I wonder if it is or not.
10:02:49 <rwbarton> lambdabot, the extensible easter egg engine
10:03:06 <JoeyA> mee: Set (==) = error "Boo!", to see if it is being used or not.
10:03:17 <Saizan> mee: if you've both an Eq and an Ord instance you should have (x == y) give the same result as (compare x y == EQ)
10:03:18 <JoeyA> To see if your instance is being used, that is.
10:04:05 <ski> quicksilver : yes. also Hugs can do that (show not using `Show', print inferred type) (optionally, of course) :)
10:04:07 <mee> yep, defining both Ord and Eq instances for F works as expected
10:04:08 <ski> Prelude> :s +t -u
10:04:08 <mee> thanks.
10:04:10 <ski> Prelude> Nothing
10:04:13 <ski> Maybe_Nothing :: Maybe a
10:05:12 <mee> it's kind of weird that you can even have a `comare` b /= EQ when a == b
10:05:24 <mee> compare*
10:05:24 <ski> yes
10:05:26 <roconnor> > (0/0) /= (0/0)
10:05:27 <lambdabot>   True
10:05:49 <quintessence> > (0/0) `compare` (0/0)
10:05:50 <lambdabot>   GT
10:05:56 <roconnor> I'd be inclined to make (0/0) == (0/0) and (0/0) /= (0/0) return False.
10:06:05 <roconnor> I wonder if the IEEE would allow this.
10:06:20 <c_wraith> clearly, they should both return NaN
10:06:25 <c_wraith> who cares if that isn't a boolean
10:06:27 <ski> iirc, `NaN' is specified to not be equal to itself
10:06:31 <JoeyA> Better yet, FileNotFound
10:07:07 <srhb> Oh, this is what deepseq does!
10:07:09 <JoeyA> When using alloca (from Foreign.Marshal.Alloc), should I be wary of large buffer sizes, in case a future implementation (or even a current implementation) allocates the buffer on the stack?
10:07:12 <roconnor> ion: is 'NaN' not equal-to-itself, or is 'NaN' not-equal to itself.
10:07:23 <ski> (the idea being that my `NaN' and your `NaN' probably represents different things)
10:07:25 <JoeyA> > (0/0) == (0/0)
10:07:25 <lambdabot>   False
10:08:11 <ion> roconnor: dunno
10:08:30 <mm_freak_> JoeyA: i'd say no
10:08:37 <roconnor> ion: ha, sorry
10:08:42 <mm_freak_> haskell's alloca isn't related to C's alloca()
10:08:54 <mm_freak_> JoeyA: it's rather like withMemory
10:09:05 <JoeyA> Thanks, just making sure.
10:09:29 <Ngevd> This is about the seventh family tree program I have attempted to write.
10:09:31 <mm_freak_> JoeyA: GHC haskell doesn't even have a stack like that
10:09:38 <Ngevd> It's also the first where I've started with saving and loading
10:09:45 <Ngevd> So it should last a bit longer
10:10:03 <mm_freak_> as far as i know its stack is only used for pattern-matching stuff, but i'm not sure
10:10:07 <scooty-puff> stupid question - after escape analysis, could haskell's alloca end up being more comparable to C's alloca?
10:10:38 <mee> Set should really not require an Ord instance, imo. toList be damned.
10:10:52 <mm_freak_> haskell's alloca is defined in terms of normal Foreign.Marshal functions
10:11:29 <timthelion> Is it possible to make a list of functions, when the functions have different and arbitrary types?
10:11:31 <JoeyA> Looking at the source, GHC's version of alloca does some scary-looking pinned byte array stuff.
10:11:35 <DanBurton> the annoying thing about Set is that if you take out the Ord requirement, then it becomes slow
10:11:40 <mm_freak_> timthelion: not a list in the [] sense
10:11:43 * hackagebot xmlhtml 0.1.6 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1.6 (DougBeardsley)
10:11:55 <JoeyA> But based on a trivial test, it looks like I can allocate 1GB buffers with allocaBytes.
10:12:10 <mm_freak_> timthelion: although you can certainly have a type like [Either (Int -> Int) (Float -> Float)]
10:12:28 <mee> DanBurton: oh, membership test would go from O(log n) to O(n) I guess
10:12:29 <timthelion> mm_freak_: Is it possible to make a data structure, that can be looked up in and rearranged, that would contain functions of different and arbitrary types?
10:12:38 <timthelion> mm_freak_: that may work...
10:12:42 <timthelion> thank you
10:13:18 <mm_freak_> timthelion: well, "arbitrary" = fully polymorphic, which doesn't make too much sense, because you can't do anything with a value of fully polymorphic type
10:13:49 <mm_freak_> there are type-level ways around that, but in most cases when people ask for heterogenous lists, it's not what they really want =)
10:13:54 <timthelion> mm_freak_: have you heard of the language befunge?
10:13:58 <mee> maybe I'll roll Data.Set.SlowAndSensible later ;)
10:14:09 <mm_freak_> timthelion: the esoteric language?
10:14:14 <timthelion> mm_freak_: yes
10:14:15 <timthelion> 2D
10:14:18 <mm_freak_> yes
10:14:21 <mm_freak_> why?
10:15:32 <timthelion> I want to do a little experiment, where I make a 2D function of IO type.  Where the >> and the >>= would point to a location on a grid, rather then linearly.
10:16:22 <timthelion> And I would like to make an editor for such a meta langauge.  And it would be nice, if I didn't have to preprocess my code, but rather, that such a visually displayed meta lanaguge, could be expressed in pure haskell
10:17:07 <mm_freak_> doesn't sound like a meta-language
10:18:15 <timthelion> I already figured out how to preprocess a text file, from a cvs type grid, to haskell code. but I don't see why I cannot make it so that haskell code could do this.  That I could say "then do function[x][y] and pass the result to function [p][q]
10:18:50 <timthelion> I can, for example, do such a thing in python, without trouble.
10:19:07 <DanBurton> Haskell has mutable arrays too, if you really need them
10:19:24 <DanBurton> it's just way uglier
10:19:43 <timthelion> I don't need to modify the array, I need an array of arbitrary type...
10:20:16 <DanBurton> "arbitrary type", or "types selected from a small pool"? The latter is quite easy to do
10:20:30 <DanBurton> data MyTypes = I Int | B Bool | ...
10:20:59 <timthelion> I want to be able to do something like functions[0][0]>>=functions[1][0]>>=functions[1][1]
10:21:28 <rwbarton> then use an array of MyTypes -> IO MyTypes
10:22:20 <timthelion> OK, I guess that can work, with a properly inteligent editor.  But it's a bit of a hack...
10:22:21 <DanBurton> why do you want to store functions in an array anyways?
10:22:51 <rwbarton> yeah given what you are doing, I don't think you are really in a position to call it a hack :P
10:22:52 <c_wraith> virtual plugboard?
10:23:09 <rwbarton> it's the normal way to encode the kind of dynamic type system that Python has in Haskell
10:24:03 <DanBurton> iinm CPython does something like that to implement Python
10:24:16 <DanBurton> but don't quote me on that, I know next to nothing about CPython
10:26:45 * hackagebot yesod 0.10.1.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.10.1.2 (GregWeber)
10:27:03 <timthelion> http://www.imagehosting.cz/images/grid.png I don't know if this is too small to read or not
10:27:23 <timthelion> but I'd like to be able to have an editor.  That would express the code above, as the code bellow.
10:27:26 <timthelion> in a visual way
10:27:29 <timthelion> and actually compile
10:27:43 <timthelion> the arrows in the brackets being where the output should be sent
10:27:58 <timthelion> I know it's possible to do.  I'm just trying to figure out the best way.
10:28:47 <koala_bot> morning #haskell :)
10:29:00 <rostayob> koala_bot: hey it's dark here
10:29:04 <DanBurton> koala_bot: good almost-afternoon
10:29:17 <timthelion> good evening, it's 8 at night
10:29:32 <koala_bot> Happy whatever-time-of-day, then :P I was hoping somebody had a "explain it like I'm 5" description of the bind operator for me.
10:30:51 <DanBurton> koala_bot: well you take a thing of type "m a", and you cram it into a function of type "a -> m b", and you get the resultant "m b". The magic required to perform such cramming is called Monadic bind
10:30:53 <quintessence> timthelion: there's Data.Dynamic, which lets you convert (almost-)arbitrary type to Dynamic and back
10:31:07 <timthelion> quintessence: thank you
10:32:36 <DanBurton> koala_bot: another way to understand it is `bind m f = join (fmap f m)'
10:32:53 <rostayob> timthelion: Dynamic is just a wrapper around Typeable
10:33:06 <rostayob> data Dynamic = forall a. Typeable a => Dynamic a
10:33:26 <timthelion> koala_bot: You have flour, (you add water)<-first function, (then you knead)<-seccond function (the dough)<-thing passed from the first function to the seccond..
10:33:41 <rostayob> timthelion: (I'm not sure it's actually like that, but that's the idea.)
10:34:04 <koala_bot> timthelion: how would that be set up with >>=
10:34:18 <DanBurton> timthelion: wat. >>= only involves one function
10:34:40 <nand`> Hooray, GHC finally finished building. Phew, that felt like years
10:34:58 <timthelion> DanBurton: but it's usually used to combine two. ne?  echo :: IO ()
10:34:58 <timthelion> echo = getChar >>= putChar
10:35:29 <rwbarton> getChar isn't a function
10:35:36 <timthelion> getChar(add water, give dough to putChar) putChar(knead dough)
10:35:46 <timthelion> rwbarton: action?
10:35:51 <koala_bot> DanBurton: is >>= infix?
10:35:57 <rwbarton> getChar is an action, and putChar is a function that returns an action
10:36:49 <timthelion> right right right, rwbarton my vocabulary is influenced slightly more by my of programming then my mathematics.
10:36:49 <edwardk> tim: getChar is value, but a function per se. it is a value that describes a program that knows how to get a character from the user. putchar takes a char and gives you a value that when executed will put that char to the screen
10:37:36 <edwardk> >>= composes those programs into a larger program. it takes a program, and a function from the output of that program to another program, and composes them making a bigger program
10:38:08 <timthelion> edwardk: you know, more people would use haskell, if you guys didn't try to make things so damned correct :D
10:38:23 <edwardk> the key is the separation between figuring out what to do (computing the value of type IO whatever) and doing it (running the IO action)
10:38:33 <ski> mm_freak_ : well, you could possibly have something like `lookup1 :: Eq1 key => Map1 key value -> (key i -> Maybe (value i))' ..
10:38:51 <edwardk> well, that extra level of clarity leads to some very cool things that you can't even talk about in other languages
10:39:42 <edwardk> timthelion: http://www.ugcs.caltech.edu/~keegan/talks/first-class-concurrency/talk.pdf was a talk kmc gave at boston haskell on how you can use the extra clarity of being able to distinguish figuring out what to do from doing it to describe concurrency in a first class manner
10:40:24 <albel727> as if popularity is something to be strived for. there are plenty of popular languages. there are no correct ones. if haskell gives up clarity for popularity, is there's a meaning to its existence, even?
10:41:12 <edwardk> the nice thing is the process of figuring out what to do can be quite expensive in its own right, so its nice to be able to factor it out of the actual execution, for when you want to run the same task several times
10:41:39 <mm_freak_> ski: timthelion might be interested
10:41:42 <mm_freak_> i'm not =)
10:41:59 <Mathnerd314> albel727: Haskell has already gone down the slippery slope of correctness for speed, just look at unsafePerformIO
10:42:31 <edwardk> unsafePerformIO is there because it lets you do neat things that can't be done without it
10:42:47 <edwardk> lets you second guess an occasionally overly strict notion of purity
10:43:19 <ski> `unsafePerformIO' should only really be used when the computation is semantically pure
10:43:24 <albel727> I firmly believe, that if haskell ever turns the wrong way completely, there'll be a strong team of purists, who'll for fork it and do the right thing (tm).
10:43:35 <ski> (e.g. memoizing is an example)
10:43:47 <adu> *ceiling cat watching you unsafePerformIO*
10:43:48 <c_wraith> ski: well, sort of.  There are things like unamb where it's amazingly handy
10:44:06 <edwardk> every time you use unamb a kitten dies (eventually)
10:44:15 <Mathnerd314> albel727: the problem is that nobody knows where the right way is...
10:44:24 <c_wraith> and unamb is only pure if you follow its documented, but not enforce, conditions
10:44:28 <timthelion> Before I leave this chatroom and go back to reading for my project.  Did anyone look at the image I posted?
10:44:29 <c_wraith> *enforced
10:44:42 <ski> c_wraith : well .. as long as the user checks that the two expressions can't complict (otherwise it's UB)
10:45:02 <ski> (s/complict/conflict/)
10:45:42 <c_wraith> edwardk: were you the one writing all that speculative folding code?
10:45:59 <edwardk> c_wraith: yeah
10:46:13 <c_wraith> I suppose it used a few unsafePerformIOs.  Though I guess its semantics are pure.
10:46:14 <edwardk> http://hackage.haskell.org/package/speculation-1.4
10:46:18 <albel727> Mathnerd314: I know. It's where I like it to be =) heh, joking. well, if haskell gets to be forked, then it will be at least clear, that it was heading a wrong way.
10:46:32 <edwardk> you can actually define it without anything unsafe
10:46:42 <edwardk> i just optimize it with some unsafe tag bit inspection tricks
10:46:49 <timthelion> albel727: I thought microsoft did fork it with F#...
10:47:00 <c_wraith> F# is more of an ml
10:47:02 <MostAwesomeDude> Hm. What's the point of unamb? I can't quite understand when it would be desirable.
10:47:26 <c_wraith> MostAwesomeDude: when you have two different ways of calculating something that perform well in different cases
10:47:26 <tromp__> :t unamb
10:47:27 <lambdabot> Not in scope: `unamb'
10:47:39 <edwardk> spec g f a = s `par` if a == g then s else f a where s = f g
10:47:45 <edwardk> uses nothing unsafe
10:47:55 <c_wraith> ah, right.  you can implement it with par
10:48:02 <edwardk> but in practice i use
10:48:18 <edwardk> spec g f a | numCapabilities == 1 = f $! a  | otherwise = ...
10:48:38 <edwardk> and i also check using my 'unsafeIsEvaluated' on a to avoid computing g when a is already known
10:48:39 <c_wraith> doesn't examining numCapabilities require IO?
10:48:46 <edwardk> probably does now
10:49:31 <robertberry> hey, you know when you use sortBy you can supply (comparing length) for example? is there something like 'comparing' but for equality tests?
10:49:33 <edwardk> i know in specSTM i use unsafeIOToSTM numSparks to check that against the numCapabilities
10:49:53 <edwardk> looks likt numCapabilities doesn't require IO yet
10:49:58 <edwardk> they'll probably break that soon
10:50:21 <c_wraith> Hmm.  Control.Concurrent has getNumCapabilities :: IO Int.  Is numCapabilities on GHC.Conc or something?
10:50:22 <edwardk> (in fact specSTM was why Marlow added numSparks to the RTS)
10:50:25 <robertberry> basically I wanna groupBy length of sublists
10:50:30 <edwardk> c_wraith: yeah
10:50:34 <edwardk> i should switch
10:50:37 <robertberry> but groupBy wants an equality test rather than an Ord
10:50:52 <robertberry> I could write my own but would prefer to use something in the library if it exists
10:50:59 <Mathnerd314> (==) `on` length, with on from Data.Function
10:51:02 <edwardk> but then i need to figure out the version in which it was introduced
10:51:13 <robertberry> excellent - thank you very much
10:51:47 * hackagebot yesod 0.10.1.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.10.1.3 (GregWeber)
10:53:33 <stephenjudkins> functional programming enthusiasts: please offer your opinion on the *least* offensive language that compiles to javascript
10:53:40 <nand`> haskell
10:54:04 <stephenjudkins> nand`: yeah? through ghcjs?
10:54:15 <nand`> stephenjudkins: not sure but I've heard it's possible
10:54:19 <nand`> aren't there multiple ways?
10:54:28 <stephenjudkins> nand`: none of them look especially mature
10:54:35 <aristid> sadly i don't think it's practical _yet_, although proof of concepts exist
10:54:35 <nand`> so I've seen
10:54:44 <nand`> answers your question though :)
10:55:12 <stephenjudkins> ok, let me revise my question: what is the least offensive language that compiles to javascript and is practical to use?
10:55:19 <nand`> Haskell
10:55:28 <nand`> you didn't say it has to compile to javascript practically
10:55:29 <aristid> stephenjudkins: i think i would bite my tongue and use javascript or coffeescript :/. you might want to look at Opa though.
10:55:39 <stephenjudkins> aristid: yes, that's what I've been doing
10:55:49 <stephenjudkins> just poking my head around for an alternative :(
10:55:54 <aristid> stephenjudkins: you have looked at opa?
10:56:02 <stephenjudkins> has anyone tried http://roy.brianmckenna.org/?
10:56:02 <aristid> http://opalang.org/
10:56:33 <aristid> oh right, forgot about Roy. that looks nice, too :)
10:56:39 <monochrom> javascript does not offend me
10:59:03 <stephenjudkins> aristid: thanks for pointing out opa. it looks interesting
10:59:43 <aristid> stephenjudkins: :)
11:00:58 <ski> stephenjudkins : maybe Guile
11:01:27 <stephenjudkins> ski: woah, Guile still exists?
11:02:07 <ski> sure, and is alive and kicking
11:02:12 <stephenjudkins> i can't find anywhere where it targets JS
11:02:14 <ski> (wingo is a maintainer)
11:02:35 <ski> i've heard about JS backend, but i don't know whether it is finished or not
11:03:00 <ski> (you could ask in #scheme, wingo is in there right now)
11:03:59 <rostayob> stephenjudkins: Agda!
11:04:11 <rostayob> stephenjudkins: jokes aside, ClojureScript.
11:04:16 <stephenjudkins> rostayob: ha!
11:05:03 <stephenjudkins> rostayob: ah yes, clojurescript. that does look promising
11:05:23 <stephenjudkins> scala-gwt has a ways to go, but i think it might be a good choice in a few months
11:05:44 <rostayob> stephenjudkins: no! god no!
11:05:45 <rostayob> gwt :(
11:06:11 <stephenjudkins> well, there's a couple things going on with GWT. there is the part that actually compiles to JS
11:06:24 <stephenjudkins> and the collection of java classes that represent its "widgets" and what have you
11:06:48 * hackagebot reactive-bacon 0.1 - FRP (functional reactive programming) framework  http://hackage.haskell.org/package/reactive-bacon-0.1 (JuhaPaananen)
11:06:52 <rostayob> stephenjudkins: I don't like GWT (I used it at google)
11:06:58 <stephenjudkins> i am exciting about the former--compiling tasteful Scala to JS--but not so much about the latter
11:07:06 <rostayob> I really don't like things like GWT.
11:07:18 <stephenjudkins> yeah? please tell me more about its problems
11:07:20 <ion> Everyone has their own FRP framework now?
11:07:34 <rostayob> stephenjudkins: it's just a big huge framework that "somehow" work.
11:07:54 <JoeyA> Is there a way to explicitly enable assertions in GHC?  Or do I have to disable optimization in my .cabal file to get them to work?
11:07:56 <rostayob> it's not a language to language compiler. I mean it does that as well, but it's only part of the thing
11:08:19 <stephenjudkins> rostayob: yeah, i was planning on just ignoring the rest of that
11:08:25 <JoeyA> Err, my .cabal/config file (global), since the optimization setting there seems to override -Wall -O0.
11:08:57 <rostayob> stephenjudkins: well it doesn't make much sense to ignore that, the whole point is to program something that feels like a Java GUI application and then BAM it's a web application
11:09:21 <stephenjudkins> what problems would I face if I was attempting to *just* use it as a scala->js compiler?
11:09:34 <rostayob> and the website it's a morass of absurd javascript loading stuff when you click buttons things
11:10:01 <rostayob> stephenjudkins: I didn't even know that was possible
11:10:08 <hpaste> MagneticDuck pasted “myIterate” at http://hpaste.org/64612
11:10:11 <MagneticDuck> Hey, some newbie help? Please? :)
11:10:20 <stephenjudkins> MagneticDuck: just ask, don't ask to ask
11:10:32 <MagneticDuck> Yeah, sorry!
11:10:39 <stephenjudkins> and don't apologize! :p
11:10:46 <MagneticDuck> LOL
11:10:54 <MagneticDuck> AND DON'T SAY LOL!
11:11:28 <stephenjudkins> rostayob: hmm, i've been able to do it in my brief experiments. it definitely wasn't the way the documentation points you
11:11:30 <c_wraith> "What are you doing now?" "We're averting our eyes!"
11:11:54 <rostayob> stephenjudkins: I used GWT briefly, I'm definitely not an expert. but I really, really don't like that kind of system.
11:12:21 <rostayob> I'd try ClojureScript or CoffeScript.
11:12:21 <stephenjudkins> i agree and plan to completely ditch the "widget" parts
11:12:42 <stephenjudkins> clojurescript is worthy of investigation. thanks.
11:12:44 <rostayob> stephenjudkins: or I'd just learn javascript
11:12:57 <stephenjudkins> rostayob: oh, i know javascript plenty well.
11:13:01 <MagneticDuck> Never mind, typo! :P
11:13:16 <rostayob> stephenjudkins: if you're along, you can write nice javascript :P
11:14:00 <rostayob> apart from the ugly names you can remove most of the bad parts
11:14:03 <stephenjudkins> i'm sure I can, but we're in #haskell: i would think people here might understand the value of a decent type system?
11:14:57 <rostayob> stephenjudkins: oh if you want types ClojureScript and CoffeeScript are not solutions.
11:15:20 <rostayob> if you want the impression of types just to realize later that they're not types you can try Dart.
11:15:43 <stephenjudkins> yeah, clojurescript might offer other helpful tools though
11:15:47 <stephenjudkins> dart... bleh.
11:15:47 <hpaste> MagneticDuck annotated “myIterate” with “myIterate (annotation)” at http://hpaste.org/64612#a64613
11:16:17 <rostayob> stephenjudkins: we had a talk by one of the designer in my uni a few days ago. the reaction was interesting.
11:16:37 <stephenjudkins> rostayob: of dart?
11:16:39 <c_wraith> rostayob: the designer of which?
11:16:55 <rostayob> c_wraith: Dart, Gilad Bracha
11:17:08 <rostayob> I think he's one of the designers. he's definitely a proponent
11:17:17 <c_wraith> What sort of reactions were there?
11:17:51 <rostayob> well it was an academic crowd, and people didn't like dart that much :P
11:18:00 <rostayob> but I think he's quite used to that he was prepared
11:18:01 <stephenjudkins> dart strikes my as an unnecessarily conservative (perhaps "reactionary") language
11:18:43 <rostayob> expecially the part about generics being covariant, which is just wrong
11:18:49 <stephenjudkins> if you're writing a new language why not use it as an opportunity to really fix java's problems?
11:19:03 <rostayob> but they did it so that they don't have to educate people (that's what he said anyways)
11:19:16 <rostayob> stephenjudkins: because their goal is to please non-programmers
11:19:18 <ski> rostayob : mutable generics ?
11:19:25 <stephenjudkins> maybe it's stockholm syndrome, but you'd think one would notice how often one sees NullPointerExceptions and try to, uh, eliminate all of those
11:19:29 <rostayob> who copy paste code and tweak it until it works
11:20:04 <rostayob> ski: no, covariant generics (List<Dog> <: List<Animal>)
11:20:51 <rostayob> I get where they're coming from but I won't use Dart :P
11:22:06 <ski> rostayob : and the problem ?
11:23:00 <quicksilver> ski: intresting
11:23:08 <rostayob> ski: oh, I get what you were asking now. yes, mutable generics.
11:23:19 <rostayob> well mutable objects.
11:24:05 <rostayob> (List<Dog> foo; Cat meow; List<Animal> bar = foo; bar.add(meow);)
11:27:28 <scooty-puff> :t newIORef id
11:27:29 <lambdabot> Not in scope: `newIORef'
11:27:39 <scooty-puff> :+m Data.IORef
11:27:50 <c_wraith> haha
11:27:54 <c_wraith> no, that doesn't work.
11:28:00 <magicman> ... I only *now* realize that that's wrong because bar is a reference to the same thing as foo, and not a fully copied version of foo >_<
11:28:01 <ski> @type Data.IORef.newIORef id
11:28:02 <lambdabot> forall a. IO (GHC.IORef.IORef (a -> a))
11:28:43 <scooty-puff> @type unsafePerformIO $ Data.IORef.newIORef undefined
11:28:44 <lambdabot> Not in scope: `unsafePerformIO'
11:29:46 <ski> @type Foreign.unsafePerformIO (Data.IORef.newIORef id)
11:29:47 <lambdabot> forall a. GHC.IORef.IORef (a -> a)
11:30:12 <scooty-puff> in ghci, its given type IORef (GHC.Prim.Any -> GHC.Prim.Any)
11:30:42 <scooty-puff> o, nm, founded related ticket, will just go over the comments on that
11:31:30 <ski> @type let ref = Foreign.unsafePerformIO (Data.IORef.newIORef undefined) in \a -> Foreign.unsafePerformIO (Data.IORef.writeIORef ref a >> Data.IORef.readIORef ref)
11:31:31 <lambdabot> forall a a1. a -> a1
11:32:57 <ski> (that's how you could break the type-system using mutable reference-cells in ML, before they added imperative tyvars^W^Wthe value restriction)
11:33:03 <scooty-puff> @type unsafeCoerce $ putStrLn "hi"
11:33:03 <lambdabot> Not in scope: `unsafeCoerce'
11:33:31 <rostayob> ski: yes, and it sucks
11:33:39 <rostayob> (the value restriction)
11:35:19 <kallisti> the function Monad instance has an instance of MonadReader right?
11:36:18 <parcs`> yes
11:36:20 <kallisti> so I could make functions that also double as Reader monads.
11:36:22 <kallisti> cool.
11:36:24 <parcs`> instance MonadReader r ((->) r) -- Defined in `Control.Monad.Reader.Class'
11:36:36 <kallisti> so basically
11:36:51 <kallisti> arg1 -> arg2 -> StaticData -> result
11:37:13 <kallisti> if I applied arg1 and arg2, and left StaticData blank, then I could use the function within a do block as if it were a regular Reader
11:37:16 <ski> rostayob : yeah, i had trouble doing parser combinators ..
11:37:20 <parcs`> kallisti:
11:37:23 <parcs`> yeah
11:37:46 <kallisti> hm, but not as a ReaderT
11:37:49 <kallisti> or would ReaderT just be
11:37:50 <rostayob> well, the solution is just to wrap it in a lambda, it's not that bad.
11:37:53 <kallisti> arg1 -> arg2 -> StaticData -> t result
11:38:01 <rostayob> let foo = fn () => ...;
11:38:06 <rostayob> *var
11:38:12 <ski> yeah, but it's irksome to have to recompute :)
11:38:17 <parcs`> ReaderT would be arg1 -> arg2 -> Reader StaticData result
11:38:19 <rostayob> ski: yep, it is
11:38:40 <ski> hm .. i suspect static-optimization of parser combinators is hard, due to this
11:38:45 <kallisti> parcs`: huh?
11:38:58 <parcs`> @src Reader
11:38:58 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:39:01 <parcs`> @src ReaderT
11:39:01 <lambdabot> Source not found. My brain just exploded
11:39:16 <ski> (like in Swiersta & Duponcheel's paper, e.g.)
11:39:20 <rostayob> ski: they could optimize that, I wouldn't be surprised if MLton did
11:39:22 <parcs`> kallisti: ah, well 'newtype Reader r a = Reader (r -> a)'
11:39:25 <kallisti> @unmtl ReaderT IO a
11:39:26 <lambdabot> Plugin `unmtl' failed with: `ReaderT IO a' is not applied to enough arguments, giving `/\A. IO -> a A'
11:39:29 <rostayob> they could optimize something at least
11:39:39 <kallisti> @unmtl ReaderT IO s a
11:39:39 <lambdabot> IO -> s a
11:39:45 <ski> rostayob : yeah, i suppose the implementation might sometimes dtrt with it
11:39:45 <kallisti> @unmtl ReaderT s IO a
11:39:45 <lambdabot> s -> IO a
11:40:11 <kallisti> so, yeah. arg1 -> arg2 -> s -> t a
11:40:31 <kallisti> could double as a 2-argument function that returns a ReaderT s t a
11:41:20 <parcs`> if by double you mean 'when applied to fmap (fmap ReaderT)'
11:41:46 <rostayob> ski: I had problems with parser combinators & SML because of stricness more than value restriction
11:41:51 * hackagebot buildwrapper 0.5.0 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.5.0 (JeanPhilippeMoresmau)
11:52:14 <MagneticDuck> Hey, how exactly the "haskell-prof" package that comes as part of the Haskell platform on my computer?
11:52:20 <MagneticDuck> I think it's called that...
11:53:05 <MagneticDuck> No, haskell-platform-prof
11:54:15 <MagneticDuck> Any help?
11:54:19 <MagneticDuck> What does that package do?
11:54:32 <MagneticDuck> I know very little about how all this works...
11:55:01 <MagneticDuck> No, sorry, I meant the haskell documentation, haskell-platform-doc
11:55:53 <MagneticDuck> Mm, seems like everyone's busy coding!
11:56:02 <tzxn3> hm
11:56:11 <MagneticDuck> Yay! A voice!
11:56:14 <tzxn3> what does "runState" actually do?
11:56:32 <MagneticDuck> Oh, another question. I don't know...
11:56:42 <parcs`> tzxn3: absolutely nothing at runtime
11:56:55 <tzxn3> so what's the point of it?
11:56:58 <ski> @type runState
11:56:59 <lambdabot> forall s a. State s a -> s -> (a, s)
11:57:24 <ski> providing an initial state to a state action
11:57:25 <timthelion> Is there a function that will return 'b' when I pass it 'a' and 'c' when I pass it 'b'?  Simply adding 1 doesn't work.
11:57:34 <MagneticDuck> What does haskell-platform-prof do?
11:57:41 <ski> > map succ "ab"
11:57:41 <lambdabot>   "bc"
11:58:00 <MagneticDuck> Some sort documentation, but I can't figure out how to use it!
11:58:01 <timthelion> ski: thanks
11:58:19 <ski> > succ (maxBound :: Char)
11:58:20 <lambdabot>   *Exception: Prelude.Enum.Char.succ: bad argument
11:58:28 <ski> > pred '\NIL'
11:58:29 <lambdabot>   <no location info>:
11:58:30 <lambdabot>      lexical error in string/character literal at chara...
11:58:52 <MagneticDuck> How do I access haskell-platform-doc?
11:58:56 <parcs`> tzxn3: it used for typechecking
11:59:01 <ski> > pred '\NUL'  -- oh
11:59:02 <lambdabot>   *Exception: Prelude.Enum.Char.pred: bad argument
11:59:47 <ski> > maxBound :: Char
11:59:48 <lambdabot>   '\1114111'
12:00:31 <MagneticDuck> I'm just going to ask my question in a variety of forms until somebody finally decides to answer it.
12:00:53 <rostayob> > ord (maxBound :: Char)
12:00:54 <lambdabot>   1114111
12:01:02 <MagneticDuck> How would one access the information contained in the haskell-platform-prof package that comes with the haskell platform?
12:01:32 <monochrom> which os? how did you obtain haskell platform?
12:01:55 <MagneticDuck> I'm running Ubuntu, and I got the haskell platform from the universe repository.
12:02:26 <monochrom> then the doc package is somewhere in that repo. after installing, it's somewhere under /usr/share/doc
12:02:41 <MagneticDuck> Oh, you can't access it from ghci or something like that?
12:02:50 <monochrom> no, that's future work
12:02:53 <MagneticDuck> I'll just go and check where it was installed? Okay.
12:03:12 <monochrom> it's html and you can use a web browser
12:06:11 <MagneticDuck> All I got was a changelog.gz, a copyright notice and a README. Oh well.
12:07:12 <timthelion> Hmm.  How stupid can I be.  I cannot figure out a good way to make the infinitely long list ["a","b","c"..."aa","ab","ac"..."ba","bb,"bc"....."aaa","aab","aac"
12:07:50 <tzxn3> I'm still not sure about the definition of the bind function for the state monad
12:08:11 <rostayob> > zipWith take [1..] (repeat ['a'..])
12:08:12 <lambdabot>   ["a","ab","abc","abcd","abcde","abcdef","abcdefg","abcdefgh","abcdefghi","a...
12:08:12 <timthelion> tzxn3: lol, that gets said, about 7 times an hour arround here.
12:08:40 <timthelion> rostayob: that's not the same as the list I described though :(
12:09:05 <rostayob> timthelion: oh, I read quickly
12:09:11 <monochrom> the package name is haskell-platform-doc. it is a meta-package to bring in libghc-stm-doc etc. its files are in /usr/share/doc/libghc-stm-doc/html
12:09:27 <monochrom> http://packages.ubuntu.com/oneiric/haskell-platform-doc http://packages.ubuntu.com/oneiric/all/libghc-stm-doc/filelist
12:09:48 <rostayob> > map permutations . concat . zipWith take [1..] $ "abc"
12:09:49 <lambdabot>   Couldn't match expected type `[[a]]'
12:09:49 <lambdabot>         against inferred type `GHC.Typ...
12:10:02 <rostayob> > map permutations ["a", "ab", "abc"]
12:10:03 <lambdabot>   [["a"],["ab","ba"],["abc","bac","cba","bca","cab","acb"]]
12:10:09 <rostayob> > concatMap permutations ["a", "ab", "abc"]
12:10:09 <lambdabot>   ["a","ab","ba","abc","bac","cba","bca","cab","acb"]
12:10:13 <notrusty2> MagneticDuck, the -prof packages have profiling support built in
12:10:49 <rostayob> > concatMap permutations . zipWith take [1..] $ ['a'..]
12:10:50 <lambdabot>   Couldn't match expected type `[a]'
12:10:50 <lambdabot>         against inferred type `GHC.Types...
12:10:58 <rostayob> > concatMap permutations . zipWith take [1..] . repeat $ ['a'..]
12:11:00 <lambdabot>   ["a","ab","ba","abc","bac","cba","bca","cab","acb","abcd","bacd","cbad","bc...
12:11:12 <notrusty2> > concatMap permutations $ inits ['a'..]
12:11:13 <lambdabot>   ["","a","ab","ba","abc","bac","cba","bca","cab","acb","abcd","bacd","cbad",...
12:11:30 <rostayob> right, inits.
12:12:07 <tzxn3> well, my apologies
12:12:16 <tzxn3> I have tried to avoid asking annoying noob questions :p
12:12:55 <rostayob> tzxn3: well the trick here is that permutations is already defined. a good exercise is to define it yourself
12:13:10 <byorgey> rostayob: timthelion's list doesn't involve permutations.
12:13:19 <byorgey> you are still reading too quickly =)
12:13:21 <timthelion> tzxn3: well I was just laughing, since 19:25 < koala_bot> Happy whatever-time-of-day, then :P I was hoping somebody had a  "explain it like I'm 5" description of the bind operator for me.
12:13:33 <rostayob> byorgey: right, I'm tired
12:13:36 <timthelion> tzxn3: it was *just* asked
12:14:38 <rostayob> timthelion: you're looking for all the possible combinations using 'a' 'b' and 'c' right?
12:14:52 <parcs`> tzxn3: what don't you understand about it?
12:15:11 <tzxn3> I'll get back to you once I've figured that out
12:15:38 <hpc> @unmtl State s a
12:15:38 <lambdabot> s -> (a, s)
12:16:04 <parcs`> tzxn3: well the definition of bind for the state monad has a lot of noise due to the newtype unwrapping/wrapping
12:16:12 <timthelion> rostayob: well I asked about a specific list.  But yours would work for my purpose
12:16:15 <hpc> @src State (>>=)
12:16:15 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:16:18 <byorgey> > let l = "" : concatMap (\s -> map (s++) ['a'..'z']) l in l
12:16:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:16:19 <lambdabot>         against inferred ty...
12:16:20 <hpc> @src State (=<<)
12:16:20 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:16:20 <timthelion> I was just annoyed, that I couldn't make such a list
12:16:37 <byorgey> > let l = "" : concatMap (\s -> map ((s++) . (:[])) ['a'..'z']) l in l
12:16:38 <lambdabot>   ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r"...
12:16:52 <byorgey> > let l = "" : concatMap (\s -> map ((s++) . (:[])) ['a'..'z']) l in drop 30 l
12:16:53 <lambdabot>   ["ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao","ap","aq","ar"...
12:16:58 <byorgey> timthelion: ^^^
12:16:58 <hpc> tzxn3: eliminate the newtype noise and try and see if the logic is more obvious
12:17:02 <byorgey> probably not the cleanest way
12:17:06 <tzxn3> mhm
12:17:19 <rostayob> > let l = "" : concatMap (\s -> map ((s++) . (:[])) "abc") l in l
12:17:20 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
12:17:48 <nand`> Anybody with experience running haskell on gentoo?
12:18:03 <parcs`> tzxn3: see if this version is more understandable: bind :: (s -> (a, s)) -> (a -> s -> (b, s)) -> s -> (b, s); bind m f s = let (a, s') = m s in f a s'
12:18:55 <timthelion> byorgey: cool.  Now I will go study that and figure out how it works :D
12:19:02 <nand`> cabal won't install for me
12:19:20 <hpc> @pl let bind m f s = let (a, s') = m s in f a s' in bind
12:19:20 <lambdabot> (line 1, column 22):
12:19:20 <lambdabot> unexpected "("
12:19:20 <lambdabot> expecting "()", natural, identifier or "in"
12:19:31 <rostayob> timthelion: i'm not sure that does what you want, it generates an infinite list
12:19:57 <parcs`> you can even do 'bind m f s = uncurry f (m s)' :)
12:19:59 <rostayob> still better than my misunderstandings :P
12:20:00 <byorgey> (15:06) <timthelion> Hmm.  How stupid can I be.  I cannot figure out a good way to make the infinitely long list ["a","b","c"..."aa","ab","ac"..."ba","bb,"bc"....."aaa","aab","aac"
12:20:08 <byorgey> rostayob: ^^^
12:20:08 <rostayob> oh yeah.
12:20:18 <rostayob> I should just sleep ehe
12:20:22 <byorgey> rostayob: you really are tired, aren't you =P
12:20:28 <rostayob> byorgey: I am
12:20:34 <rostayob> I do my best!
12:20:38 <byorgey> =)
12:20:43 <byorgey> go take a nap!
12:20:50 <rostayob> yes a 10 hour nap
12:20:51 <byorgey> then you can haskell more.
12:20:58 <rostayob> eheh
12:22:18 <nand`> > subsequences "abcdefg"
12:22:18 <lambdabot>   ["","a","b","ab","c","ac","bc","abc","d","ad","bd","abd","cd","acd","bcd","...
12:22:32 <tzxn3> what does "let (a, s') = m s" mean?
12:22:43 <tzxn3> it doesn't make sense to me
12:23:07 <hpc> @let origin = (0, 0)
12:23:07 <lambdabot>  Defined.
12:23:08 <rostayob> goodnight!
12:23:13 <hpc> > let (x, y) = origin in x
12:23:15 <lambdabot>   0
12:23:17 <hpc> > let (x, y) = origin in y
12:23:19 <lambdabot>   0
12:23:29 <hpc> it's just a pattern match
12:23:56 <byorgey> tzxn3: the result of the function application (m s) is a tuple, and the components of that result tuple are called  a  and  s'
12:23:59 <nand`> > let foo x = (x, -x); (x, y) = foo 5 in [x,y]
12:23:59 <lambdabot>   [5,-5]
12:24:17 <ve1> btw is it possible to crash lambdabot because of out of memory? ;)
12:24:25 <tzxn3> oh right
12:24:26 <hpc> no
12:24:26 <tzxn3> haha
12:24:45 <hpc> you can crash mueval, and then lambdabot gets annoyed
12:24:51 <etpace> Hey guys, slightly offtopic question but im getting a bit of a brain fart: What's the common notation for "x instead of y in e", is it e[x/y] or [x/y]e or something else?
12:24:58 <nand`> :t \m s -> let (x, y) = m s in (x, y)
12:24:59 <lambdabot> forall t t1 t2. (t -> (t1, t2)) -> t -> (t1, t2)
12:25:00 <hpc> @hackage mueval -- it's a standalone executable
12:25:00 <lambdabot> http://hackage.haskell.org/package/mueval -- it's a standalone executable
12:25:17 <parcs`> > ?_
12:25:18 <lambdabot>   mueval-core: internal error: PAP object entered!
12:25:18 <lambdabot>      (GHC version 6.12.3 f...
12:25:41 <tzxn3> I'm still not entirely used to Haskell's notation for funtion application
12:25:45 <nand`> etpace: I would suggest (\y -> e) x
12:25:47 <tzxn3> *function
12:25:52 <nand`> but that's just me ;)
12:26:16 <hpc> :t (\y -> e) x
12:26:17 <lambdabot> Expr
12:26:18 <lpsmith> does anybody know when and where foldl was invented?  I'm guessing maybe somewhere in the lisp community in the 60s?
12:26:25 <nand`> and probably not what you want either
12:26:38 <hpc> lpsmith: yes; lisp's reduce is a foldl
12:26:44 <byorgey> etpace: hahaha, there are about ten notations that have been used for that.  I am not kidding.
12:26:57 <byorgey> etpace: choose a notation based on your audience.
12:27:00 <etpace> haha, atleast my confusion is justified then
12:27:03 <lpsmith> hpc, right,  but when was reduce invented?
12:27:09 <hpc> no clue
12:27:21 <hpc> probably quite early
12:27:32 <byorgey> etpace: e[x/y] and [x/y]e are both common.  also with { }  instead of [ ]
12:27:52 <Taneb> This function is way too unreadable...
12:27:53 <etpace> bit circular when im defining the semantics of (\y -> e) x nand`! ;)
12:27:53 <byorgey> also with   x |-> foo  instead of   foo/x
12:27:57 <Taneb> add_father :: FamilyTree -> Int -> Int -> FamilyTree
12:27:57 <Taneb> add_father tree p1 p2 =
12:27:59 <Taneb>   let p1' = IM.lookup p1 tree
12:28:01 <Taneb>       p2' = IM.lookup p2 tree
12:28:03 <Taneb>   in maybe (error ("No person at " ++ show p1 ++ "!"))
12:28:05 <Taneb>        (maybe (error ("No person at " ++ show p2 ++ "!"))
12:28:07 <Taneb>          (\p2'' p1'' -> if snd4 p1'' /= 0
12:28:09 <Taneb>                           then if HM.lookup (T.pack "sex") (fst4 p2'') /= Just (T.pack "female")
12:28:13 <nand`> etpace: oh haha
12:28:13 <Taneb>                                  then IM.adjust (\(a,b,_,d) -> (a,b,p2,d)) p1 (IM.adjust (\(a,b,c,d) -> (a,b,c,IS.insert p1 d)) p2 tree)
12:28:14 <etpace> ok, then I'll be safe with the [] I guess
12:28:16 <Taneb>                                  else error ("Person " ++ show p2 ++ " is female!")
12:28:18 <Taneb>                           else error ("Person " ++ show p1 ++ " already has a father!") ) p2') p1'
12:28:20 <Taneb> Long paste is long?
12:28:22 <Taneb> I'm not even sure if it works
12:28:22 <byorgey> etpace: sure
12:28:23 <nand`> Taneb: hpaste.org please!
12:28:29 <mauke> Taneb: don't paste into irc
12:28:38 <Taneb> Didn't seem quite worth it for just hat
12:28:53 <byorgey> Taneb: it's worth it for the other people in the channel.
12:28:57 <Taneb> True
12:29:07 <Taneb> I will now leave in shame, for unrelated reasons
12:29:14 <byorgey> hehe
12:31:42 <tazjin> I'm trying to install snap and I'm getting all sorts of weird errors: http://hpaste.org/64615
12:32:16 <clintm> uunnngggghhh... stm-chans... yummeh.
12:32:20 <tazjin> using GHC 7.4.1 - any ideas what could be wrong here?
12:32:49 <clintm> tazjin: I don't think it has been modified to work with 7.4.x yet.  Are you pulling from the git repo?
12:33:26 <clintm> tazjin: well, either way, pulling from git is your best bet for using 7.4.x
12:33:41 <tazjin> Clintm: No, but it looks like the errors are happening before it even gets to compiling snap itself
12:33:57 <carter> tazjin the problem might be with the crypto lib
12:34:09 <carter> have you tried installing all the other packages?
12:34:37 <carter> one by one
12:34:51 <tazjin> I tried, the first one it tries to build is quickcheck
12:34:58 <carter> quickcheck should build
12:34:59 <tazjin> but if I install quickcheck manually it works fine
12:35:00 <carter> umm
12:35:02 <carter> ok
12:35:17 <carter> how're you installing it manually?
12:35:29 <koala_bot> Why might it be necessary for an operator to be left associative?
12:35:32 <carter> and did you install ghc 7.4.1?
12:35:35 <carter> *how did you
12:35:57 <tazjin> carter: by manually I just meant doing cabal install quickcheck, not actually pulling the source and doing things manually
12:35:58 <carter> and have you run cabal update recently?
12:36:00 <mightybyte> tazjin: My first thought is that something is messed up with your Haskell install.
12:36:12 <mightybyte> tazjin: What OS?
12:36:14 <carter> mightybyte yeah, the .hi error shouldn't ever be the problem
12:36:24 <tazjin> carter: I downloaded the appropriate GHC 7.4.1 binaries and installed them, Ubuntu 64bit
12:36:43 <tazjin> Can I completely reset everything cabal has installed?
12:36:46 <carter> tazjin: res
12:36:47 <carter> yes
12:36:58 <carter> ghc-pkg list
12:37:01 <carter> type that
12:37:01 <carter> first
12:37:15 <carter> that should give you the location of the user installed stuff
12:37:28 <tazjin> yeah, it does
12:37:41 <carter> delete the contents of that folder
12:38:04 <carter> also you might want to empty you .world file
12:38:19 <carter> the location of the world file will be indicted in .cabal/config
12:38:21 <mightybyte> tazjin: FYI, the most recent hackage release of snap doesn't work with GHC 7.4.1 out of the box because the Crypto library hasn't been updated.
12:39:09 <tazjin> carter: Did that, what about ~/.cabal/lib and so on?
12:39:22 <tazjin> mightybyte: Ah, I guess that explains things
12:39:28 <carter> you can delete things in that folder
12:39:35 <monochrom> "/home/tazjin/.cabal/lib/template-haskell-2.6.0.0" is a very bad omen. you should never allow that. template-haskell already comes with GHC.
12:39:41 <mightybyte> tazjin: Well, the error you're getting is different.
12:40:14 <monochrom> having 2nd instances of libs that already come with GHC is a mess, unless you are an expert
12:40:54 <tazjin> monochrom: I'm pretty sure that I didn't tell cabal to install template-haskell again
12:41:11 <mightybyte> tazjin: What OS are you using?
12:41:21 <carter> mightybyte: he says ubunut 64
12:41:41 <tazjin> monochrom: x86_64 linux, distro is ubuntu
12:41:58 <mightybyte> How did you install GHC?
12:42:19 <tazjin> <tazjin> carter: I downloaded the appropriate GHC 7.4.1 binaries and installed them, Ubuntu 64bit
12:42:38 <carter> tazjin: also, did you at some point install haskell platform or the like? because you certainly don't get cabal with ghc
12:42:53 <tazjin> I installed the haskell-platform before I got the new GHC.
12:43:02 <carter> tazjin and did you uninstall the old ghc?
12:43:07 <monochrom> the "cabal" executable is fine
12:43:27 <tazjin> everything works with the *new* ghc btw, except for this cabal install of snap
12:43:28 <monochrom> even if it's obtained from a slightly older life
12:44:26 <monochrom> there has not been a new public cabal-install release anyway
12:44:46 <tazjin> carter: I didn't remove the old ghc, was not aware that that could cause any issues
12:45:06 <carter> tazjin: i'm running an experiment building snap with my ghc 7.4.1 install in a cabal dev folder, hoepfully that'll help isolate what the real problem might be
12:45:11 <carter> tazjin: that might be a none issue
12:45:20 <carter> i'm just mentioning everything
12:45:23 <monochrom> it does not cause a problem. if you set PATH with the right precedence
12:45:50 <tazjin> monochrom: Definitely done that, it's GHC 7.4.1 all the way to the bottom, until I reach turtles :p
12:47:27 <monochrom> bin/ghc is a shell script that calls the real executable with correct directory names, so even it does not need PATH. PATH is really just for cabal to find bin/ghc
12:49:26 <tazjin> carter: Got any errors yet?
12:51:40 <monochrom> I saw a failure mode recently that caused 2nd instances of libs to happen. http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg21500.html
12:52:15 <monochrom> the victim wanted hoogle. but hoogle wants an older Cabal (the lib), not the newer version that comes with GHC.
12:52:39 <monochrom> the older Cabal wants an older array, not the newer version that comes with GHC (GHC 7.4.1)
12:52:42 <tazjin> what's the current version of cabal?
12:53:05 <scooty-puff> could the Writer and State monads possible have there strictness parameterized?
12:53:37 <monochrom> the presence of an older array triggers cabal to further bring in 2nd instances of containers, deep-seq, template-haskell... a mess
12:54:26 <monochrom> you can type "cabal install --dry-run -v hoogle" to reproduce the phenomenon non-destructively (--dry-run).
12:55:35 <carter> tazjin: cabal-dev runs from scratch :) ,not quite done yet
12:55:38 <monochrom> you will see lines like "containers-0.4.2.1 (reinstall) changes: array-0.4.0.0 -> 0.3.0.3". it means: "you already have containers-0.4.2.1, but I'm going to get you a 2nd copy because a different version of array has appeared"
12:57:07 <tazjin> monochrom: That just caused quite a shock. I tried that and none of these lines appeared, took me a moment to realize that I had just ssh'd into a Mac running ghc 7.2.2 :'D
12:57:32 <monochrom> cabal-install is still at 0.10.2 on hackage
12:58:08 * byorgey has an alias defined which first does 'cabal install --dry-run' and then prompts me whether I want to continue with the actual installation
12:58:23 <byorgey> saved my neck so many times
12:59:05 <carter> tazjin: its looking good so far when i build it using cabal-dev, but its not quite done yet
12:59:22 <carter> ahhh, got the same crypto probleme
13:00:51 <carter> and bizarrely, a dependency on cabal-install for syb
13:03:33 <tazjin> carter: Yeah, I got some weird cabal dependency errors as well
13:04:21 <hpaste> scooty-puff pasted “Parameterize StateT with regards to strictness?” at http://hpaste.org/64617
13:04:39 <scooty-puff> i have done this wrong i'm sure - and would greatly appreciate knowing why
13:04:42 <tazjin> byorgey: Thanks for that alias idea, just did that as well :P
13:04:47 <scooty-puff> not sure where the pattern matches make it too strict
13:04:56 <scooty-puff> or where the function calls make it not strict enough
13:05:01 <scooty-puff> or if its really possible
13:10:15 <timthelion> > zip (zip [1][2])[3]
13:10:16 <lambdabot>   [((1,2),3)]
13:10:31 <DanBurton> if you're on ghc 7.4.1, you should probably get cabal-install from the darcs repo
13:10:33 <timthelion> how do I make it regurn [(1,2,3)]
13:10:48 <timthelion> return
13:10:53 <aristid> > zip3 [1] [2] [3]
13:10:54 <lambdabot>   [(1,2,3)]
13:10:59 <aristid> :)
13:11:02 <timthelion> :)
13:11:04 <DanBurton> @hoogle zip3
13:11:05 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
13:11:05 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
13:11:05 <lambdabot> Data.Sequence zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
13:13:26 <monochrom> hrm, what is base64-bytestring? :)
13:13:59 <monochrom> oh, encodes/decodes bytestring to base64
13:14:00 <ion> Without looking, perhaps it encodes bytestrings in base64.
13:14:16 <monochrom> but there is also base16-bytestring! what's that?
13:14:35 <ion> One more than base15-bytestring
13:14:35 <monochrom> ok, similar spirit
13:14:41 <monochrom> haha
13:14:45 <ben> base16 sounds like "using hex digits"
13:14:45 <byorgey> it uses base64-bytestring and then divides by 4
13:15:17 <byorgey> ben: I think that's exactly what it is =)
13:15:47 <byorgey> I use base64-bytestring to turn MD5 hashes into file names
13:16:08 <ion> Ah, it reverses MD5, too.
13:16:23 <timthelion> monochrom: Quantum computers use it to allow your soul to influence the future simply by observing the present thus proving through science that god exists.
13:16:50 <byorgey> err, I meant base16-bytestring
13:17:05 <byorgey> ion: hehe
13:18:11 <monochrom> base64 would give you shorter filenames...
13:18:15 <nexion> what function can I use to get a clock timestamp which can be expressed as an Integer? 1 second precision will do
13:18:23 <shergill> my girlfriend is awesome. she saw me programming and upon seeing the owl-operator, remarked: oh, stripper boobs!
13:19:07 <aristid> byorgey: oh, base64 uses /. otherwise you COULD use it for filenames! :)
13:19:53 <byorgey> aristid: indeed =)
13:19:54 <monochrom> snap has an explicit "template-haskell >= 2.2 && < 2.7" so it won't like the template-haskell that comes with GHC 7.4
13:19:58 <aristid> byorgey: there's base64url which uses - and _ instead of + and /... would still be more efficient than base16 :)
13:20:00 <timthelion> shergill: my girlfreind is awsome. she is very quiet, never buys cloths with my money, never complains about the mess, never tells me I have to get out of the house more, never calls me at 3 in the moring :'(
13:20:37 <shergill> timthelion: heh
13:20:45 <byorgey> aristid: ah, didn't know about that.  is there a Haskell package that implements it?
13:20:51 <monochrom> I have a number of wives. that number is 0.
13:21:04 <byorgey> oh, it's in base64-bytestring, I see
13:21:06 <monad_> Hi, I want to import C-Strings via FFI to Haskell. I implemented the following coding (see http://hpaste.org/64618), but no strings are return!
13:21:18 <monad_> How shall I proceed?
13:21:26 <aristid> byorgey: doesn't seem like it :/
13:21:33 <timthelion> monochrom: yes, but how many daughters do you have?
13:21:47 <byorgey> aristid: Data.ByteString.Base64.URL is in base64-bytestring
13:22:21 <aristid> byorgey: oh, lol i even had base64-byestring open but was blind to that module
13:22:24 <monochrom> what is 134514591?
13:22:26 <byorgey> hehe
13:22:41 <aristid> byorgey: well now you can make more efficient filenames! \o/
13:23:01 <monad_> monochrom: This is the converted result! I don't know! That's why I am asking how to correct the program...
13:23:30 <aristid> monochrom: a number in a base that is likely to be 10 or higher
13:24:18 <monad_> I want to receive the string and no encoded char sequences
13:24:20 <monochrom> then "hello = LANG #const STR" means something else
13:24:43 <monochrom> (why is it not "hello = LANG (#const STR)"?)
13:24:52 <DanBurton> looking at this question: http://stackoverflow.com/q/9519385/208257 is it true haddock doesn't handle UTF-8 nicely?
13:26:22 <monad_> monochrom: This doesn't matter! I will get the same result
13:26:29 <byorgey> DanBurton: oh, I had that problem recently... I'm trying to remember what the issue turned out to be
13:26:48 <DanBurton> I found a trac ticket for it http://trac.haskell.org/haddock/ticket/20
13:26:53 <DanBurton> 4 years old
13:27:12 <monad_> maybe I have to allocate space or do some other crazy things... I am new to FFI, so I have no idea how to import string
13:27:14 <monad_> s
13:27:43 <monochrom> False. haddock does utf-8 fine for me
13:28:47 * DanBurton wonders if it has been fixed in newer versions
13:29:58 <DanBurton> there's a comment on the ticket from 3 months ago from simonmar: "You can see we apply ord in alexGetByte and chr again in alexGetChar, so Unicode should be squashed to the low 8 bits."
13:31:00 <byorgey> yeah, but I got it to work and now I can't remember how.
13:31:17 <byorgey> I just tried it again on my source that has non-ASCII in the documentation and I'm getting boxes again =(
13:32:03 * hackagebot reactive-bacon 0.2 - FRP (functional reactive programming) framework  http://hackage.haskell.org/package/reactive-bacon-0.2 (JuhaPaananen)
13:32:05 * hackagebot xformat 0.1.1 - Extensible, type-safe formatting with scanf- and printf-like functions  http://hackage.haskell.org/package/xformat-0.1.1 (SeanLeather)
13:32:11 <monochrom> oh I see. GHC 7.0: haddock takes utf-8 in identifiers fine, but not in docs. GHC 7.4: haddock takes utf-8 fine for both
13:32:34 <byorgey> ah, I see
13:32:42 <byorgey> yeah, just now I was using 7.2 but I also have 7.4
13:32:46 <DanBurton> ah
13:32:54 <monad_> no idea?
13:33:10 <monochrom> no idea. I don't actually know hsc
13:33:19 <DanBurton> I just tried with a dummy project, unicode is working fine in the module docs
13:35:03 <DanBurton> oh i think i found a bug though. surrounding it in single quotes isn't linking to its definition
13:36:52 <monad_> Maybe a helper function which returns C-strings will solve the problem
13:38:24 <monochrom> Foreign.C.String has newCString
13:39:34 <monad_> I have just seen this function, maybe I could convert this number to a Haskell String...
13:40:43 <DanBurton> byorgey: hey! I was just about to answer that :)
13:40:51 <byorgey> oh, sorry =)
13:41:24 <byorgey> DanBurton: oh come on, you don't need the reputation ;)
13:41:25 <DanBurton> haven't seen you on StackOverflow before
13:41:33 <DanBurton> very true
13:41:42 <byorgey> I don't do very much on it
13:42:09 <byorgey> I very occasionally answer something if I get pointed to it by someone else, but I don't read it regularly
13:42:42 <DanBurton> I subscribe to new Haskell questions on my feed reader. It's quite an interesting way to learn various things about Haskell
13:42:44 <koala_bot> DanBurton: I am in a position where I want to check if the length of a list is even, but :t even length gives not good things... Can you point me in the right direction?
13:43:22 <DanBurton> koala_bot: you want to give an input to length, and *then* give its output to even
13:43:29 <DanBurton> > even (length [1,2,3])
13:43:30 <lambdabot>   False
13:43:34 <byorgey> DanBurton: at what rate (approximately) are new Haskell questions posted?
13:43:39 <DanBurton> koala_bot: the classic way to do this is function composition
13:43:47 <DanBurton> @type even . length
13:43:48 <lambdabot> forall a. [a] -> Bool
13:44:06 <DanBurton> byorgey: I'd say at least 5 a day, maybe up to 20 on a busy day
13:44:17 <koala_bot> there it is. Thanks DanBurton, I spaced on how to do that.
13:44:18 <DanBurton> I'll check my reader stats
13:45:08 <DanBurton> yeah, it looks like the average is 10-12 per day
13:45:09 <byorgey> DanBurton: OK.  sounds like more than I really want to read.  I just rely on the rest of the community as a filter =)
13:45:48 <DanBurton> fair enough
13:46:19 <DanBurton> the HWN is a good aggregator of the popular SO questions
13:46:52 <DanBurton> and the popular reddit posts; I'm thinking of maybe unsubscribing from the reddit feed
13:47:22 <byorgey> yeah, I usually skim through the HWN and click on a few interesting-looking SO questions
13:50:26 <MaybeJust> too often i find myself making to obvious comments to my code
13:50:41 <MaybeJust> for java and c
13:50:48 <brisingr> can't you just make fewer obvious comments?
13:50:53 <brisingr> :)
13:51:26 <MaybeJust> its when doing for school - forced to comment but sometimes there i nothing to comment really
13:51:59 <DanBurton> @where+ hwn Haskell Weekly News http://contemplatecode.blogspot.com/ For older posts, see http://sequence.complete.org/
13:51:59 <lambdabot> Done.
13:52:24 <brisingr> I just comment more on stuff I'm not sure about
13:52:31 <DanBurton> lambdabot was linking to the old hwn :P
13:52:40 <brisingr> (in our class, the teacher doesn't run the code, he just reads it)
13:52:59 <brisingr> s/he/he\/she/
13:53:25 <brisingr> (we have 2 teachers)
13:55:09 <brisingr> oh my god I just realized that this is the main channel... sorry ;(
13:55:37 <monochrom> -- you can put all off-topic remarks in comments :)
13:55:49 <dylukes> -- oh cool
13:55:53 <dylukes> > -- hahahahaha
13:55:53 <lambdabot>   not an expression: `-- hahahahaha'
13:55:59 <donri> {-
13:56:05 <dylukes> > 2 + 2 -- this doesn't work
13:56:06 <lambdabot>   4
13:56:13 <dylukes> > 0 -- oh it does, cool.
13:56:14 <lambdabot>   0
13:56:30 <MaybeJust> > 1 (--)
13:56:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:57:00 <MaybeJust> > 2 + 3 --ah i get it
13:57:01 <lambdabot>   5
13:57:02 <DanBurton> > let (--) = subtract 1 in (--) 5
13:57:03 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:57:04 * hackagebot hoogle 4.2.9 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.9 (NeilMitchell)
13:57:22 <monochrom> try ---
13:57:25 <MaybeJust> > subtract 1 5
13:57:26 <lambdabot>   4
13:57:31 <DanBurton> > let (---) = subtract 1 in (---) 5
13:57:31 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:57:40 <DanBurton> comment parsing is agressive
13:57:40 <dylukes> > 0 {- DanBurton: fuck you man. -}
13:57:41 <lambdabot>   0
13:57:50 <dylukes> > 0 -- oh so this will still work then?
13:57:51 <lambdabot>   0
13:57:52 <DanBurton> I want a -- operator
13:57:53 <MaybeJust> > let (+++) = (+1) (+1) (+1) in (+++) 5
13:57:54 <lambdabot>   8
13:58:23 <brisingr> I just derailed the main channel by apologizing for my off-topic posts
13:58:27 <monochrom> oh, --| , --+ , etc
13:59:03 <DanBurton> brisingr: just don't mention burritos and you'll be ok
13:59:33 <monochrom> > let x --| y = 0 in 0 --| 0
13:59:34 <lambdabot>   0
13:59:57 <brisingr> DanBurton: I'll keep that in mind
14:00:21 <monochrom> http://www.vex.net/~trebla/tmp/mucho-burrito.jpg
14:01:01 <ion> Control.Monad.Trans.Mucho
14:02:20 <brisingr> I've written something in my book I'm not sure about: "null is more efficient than list == [] because of laziness"
14:02:29 <brisingr> > [1..] == [] -- but then I did this
14:02:30 <lambdabot>   False
14:03:13 <ski> brisingr : `null' is better since it doesn't require `Eq'
14:03:34 <brisingr> ski: bingo, thanks
14:03:43 <rwbarton> what's really bad is length list == 0
14:04:18 <ion> genericLength list == (0 :: Nat)
14:04:22 <ski> (would be ok with lazy naturals, though)
14:04:30 <nand`> length (unsafeCoerce list :: forall a. [a])
14:04:47 <hpc> or just unsafeCoerce the list to Bool
14:04:56 <hpc> (hint: don't do that)
14:04:57 <ion> or to Nat
14:05:37 <hpc> ion: that would work for length if cons had its params reversed
14:05:47 <brisingr> ha! I can now fill an entire section with "how to check if a list is empty"
14:06:16 <DanBurton> or "how not to", rather
14:06:17 <ski> @free length
14:06:18 <lambdabot> length = length . $map f
14:06:28 <ion> brisingr: You should use unsafeCoerce as much as possible in the book. It brings the power of C casts to Haskell.
14:06:43 <DanBurton> @slap ion
14:06:43 * lambdabot secretly deletes ion's source code
14:07:19 <hpc> ion: it has all the precise semantics of perl combined with the memory safety of C
14:08:18 * MostAwesomeDude blames shachaf for MonadIO as "monn-AHD-ee-oh"
14:09:38 <brisingr> I just googled Haskell Nat and it gave me Haskell National Bank
14:10:26 <monochrom> rodeo : bull :: monadeo : monad
14:11:13 <brisingr> ion: after this book I'll write "How to unsafeCoerce and get away with it"
14:12:04 * hackagebot reactive-bacon 0.3 - FRP (functional reactive programming) framework  http://hackage.haskell.org/package/reactive-bacon-0.3 (JuhaPaananen)
14:12:40 <Franciman> hi all, which textbook do you suggest : Real World Haskell or Programming in Haskell Hutton, Grahm ?
14:12:50 <kallisti> haven't read the second
14:13:25 <hpc> has to be a textbook?
14:13:25 <ion> franciman: Learn You a Haskell
14:13:29 <hpc> ^
14:13:49 <DanBurton> I have read both LYAH and RWH and highly recommend both
14:13:49 <Franciman> already read
14:14:17 <Franciman> so I'll go for RWH?
14:14:33 <brisingr> IMO RWH has an odd chapter order
14:14:53 <DanBurton> wait a minute...reactive...bacon? o_O these FRP people are getting a little out of hand
14:15:16 <jamiltron> I'm reading RWH and I am kind of mucking around on the Parser/QuickCheck/Barcode-Scanner chapters
14:15:18 <brisingr> Franciman: go with RWH but look at LYAH too -- it's the perfect complement to RWH
14:15:21 <geekosaur> bananas, barbed wire, and lenses didn;t tell you that?
14:15:22 <Franciman> well thanks :D
14:15:32 <Franciman> thanks
14:15:40 <DanBurton> it makes me think of the "chunky bacon" meme from my Ruby days
14:15:47 <brisingr> Franciman: enjoy :)
14:15:57 <Franciman> gtg to bed now, good night :D
14:22:43 <Guest26328> hi. i have a tuple like this (foo,"baz"). foo is a function. what is the way to call the function which is at the fst of the tuple and passing the rest of the tuple as the arguments to it? the tuple might have more than just the "baz"
14:22:46 <Guest26328> oops
14:23:11 <henux> better
14:23:22 <DanBurton> > uncurry ($) ((+1), 3)
14:23:23 <lambdabot>   4
14:23:31 <henux> thanks!
14:23:41 <DanBurton> @type uncurry ($)
14:23:42 <lambdabot> forall b b1. (b -> b1, b) -> b1
14:23:52 <henux> what is the ($) ?
14:23:59 <DanBurton> $ is function application
14:24:01 <ion> @src ($)
14:24:01 <lambdabot> f $ x = f x
14:24:04 <henux> ok
14:24:16 <henux> i really need to learn more about this language
14:24:27 <DanBurton> and uncurry takes a curried function with 2 inputs, and turns it into a function with a single 2-tuple input
14:24:39 <MostAwesomeDude> > uncurry ($) ((+), 1, 3)
14:24:39 <lambdabot>   Couldn't match expected type `(b -> b1, b)'
14:24:40 <lambdabot>         against inferred type `...
14:24:56 <DanBurton> MostAwesomeDude: that trick will only work with a 2-tuple
14:25:22 <DanBurton> > (\(f,x,y) -> f x y) ((+), 1, 3)
14:25:22 <lambdabot>   4
14:25:25 <MostAwesomeDude> DanBurton: That's what I thought. henux asked about arbitrary tuples.
14:25:30 <DanBurton> that's the general way to do it ^ just unpack the tuple
14:25:41 <preyalone> I used Homebrew to installed the C libraries for opencv and ftgl, but cabal refuses to install the Haskell opencv package, claiming that it can't see the cv and highgui C libraries.
14:25:48 <mauke> > uncurry id ((+), 1) 3
14:25:49 <lambdabot>   4
14:25:54 <preyalone> Is there a pure Haskell opencv package?
14:26:02 <ion> henux: Why do you have such tuples in the first place?
14:26:14 <DanBurton> > uncurry (uncurry id) (((+), 1), 3)
14:26:15 <lambdabot>   4
14:26:25 <ion> This question has a slight smell of Y. :-)
14:26:44 <preyalone> lambdabot: x:x
14:27:04 <preyalone> > x:x
14:27:05 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
14:27:05 <lambdabot>         against inferre...
14:27:14 <mauke> > x : [x]
14:27:15 <lambdabot>   [x,x]
14:27:28 <DanBurton> > let foo = x : foo in foo
14:27:29 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
14:27:40 <preyalone> > fst []
14:27:41 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `[a1]'
14:27:46 <preyalone> > head []
14:27:47 <lambdabot>   *Exception: Prelude.head: empty list
14:28:11 <mauke> > listToMaybe []
14:28:12 <lambdabot>   Nothing
14:28:50 <henux> using haskell's terms, do i say a "reference to function foo" or something when i want to say that the tuple contains a function?
14:29:11 <henux> when using english, that is
14:29:27 <hpc> "tuple containing a function and a value", is what i would say
14:29:53 <hpc> or perhaps "tuple of a function and a value"
14:29:55 <mauke> henux: no, you say that the tuple contains a function
14:30:10 <mauke> (also, technically functions don't have names)
14:30:11 <henux> ok
14:34:23 <henux> thanks for your help, i need to sleep a bit now
14:34:49 <ion> henux: Again, why do you have such tuples in the first place?
14:36:36 <henux> ion: oh i am just learning haskell and testing new stuff
15:08:25 <Cale> http://www.scottaaronson.com/writings/phcollapse.pdf :D
15:09:37 <srhb> How should I go about reading a specific number of bytes from a file?
15:09:43 <srhb> Just ByteStrings?
15:10:12 <hpc> that would probably be best
15:10:23 <hpc> the function might even exist already
15:10:29 <Enigmagic> :t Data.ByteString.hGet
15:10:30 <lambdabot> GHC.IO.Handle.Types.Handle -> Int -> IO BSC.ByteString
15:10:30 <srhb> So I simply take n from the resulting bytestring?
15:10:33 <srhb> Aha
15:10:43 <srhb> Nifty.
15:11:34 <hpc> so you would use something like (hGet stdin 4096) :: IO ByteString
15:11:49 <c_wraith> Cale: awesome :)
15:12:13 <hpc> srhb: if your data is bytes, you will be using ByteString anyway
15:12:37 <hpc> if it's ascii text, you could probably change it to hGetChar + hSetEncoding
15:12:39 <srhb> Yeah. Never worked with binary before, but the tools here seem very tolerable.
15:12:42 <srhb> It is not ascii text.
15:12:46 <hpc> groovy
15:17:28 <MostAwesomeDude> If I wanna put a PEG into a Haskell library, can I just use parsec? I see people talking every other day about how x is better than parsec for most values of x.
15:18:39 <c_wraith> there are several parsers specifically for PEG
15:19:04 <c_wraith> using one of them would get you its actual advantages
15:20:22 <tgeeky_> and there's someone here who is developing something which has PEG as an ancestor
15:23:06 <timthelion> If I have a function of type IO: f = getChar, is there a way to say, the first time I run this function do the action, and the following times simply return the result that was already gotten?
15:24:09 <dibblego> timthelion: No, but then, why would you want that? Keep the original value around.
15:24:34 <timthelion> dibblego: because I don't want to be passing a bunch of values...
15:25:29 <timthelion> my functions would look like f a1 a2 a3 a4 a5 a6 a7 a8 a9 ... a1122 if I passed everything arround...
15:25:31 <mauke> timthelion: that's not a function and IO is not a type
15:25:57 <timthelion> mauke: how do you guys call it then
15:26:02 <dibblego> that seems to be quite an orthogonal issue and haskell has record types iirc
15:26:18 <timthelion> Yes, I know that you use the mathematical definition of a function.  But this is computer programming, I'm a programmer.
15:26:41 <mauke> timthelion: I don't use math. a function is something of type A -> B for some types A, B
15:26:54 <mauke> i.e. it has a "->" in the middle
15:27:09 <timthelion> mauke: well what is the term I should use?
15:27:17 <mauke> that depends on what you want to say
15:27:22 <MostAwesomeDude> Hm. I think PyMeta has spoiled me on parsers.
15:27:33 <dibblego> a value, called getChar, of the type IO Char
15:27:59 <mauke> an identifier called getChar referring to a value of type IO Char!
15:28:26 <mauke> that sounds wrong somehow
15:28:40 <mauke> now I think values don't have types
15:28:52 <mauke> timthelion: look what you've done, you've confused me
15:29:37 <shachaf> mauke: Why don't values have types?
15:29:51 <mauke> because the type checker doesn't evaluate stuff
15:29:57 <mauke> so it doesn't even know what the values are
15:30:18 <timthelion> well when I have main f >> y;f=getChar;y=putChar f;  I want the user to be promted for the charicter only once.
15:30:35 <shachaf> OK -- expressions have types?
15:31:05 <mauke> shachaf: I think so
15:31:10 <Mathnerd314> types are calling conventions, values do have types.
15:31:13 * shachaf is OK with that.
15:31:24 <timthelion> and don't tell me that I should do main getChar>>=putChar. because that's not what I want :P
15:31:38 <shachaf> mauke: I'm also OK with IO being a type -- I'm not sure why types should be restricted to things of kind *.
15:31:38 <rwbarton> you seem to have about 8 typos on that one line
15:31:57 <timthelion> rwbarton: who? me? on which line?
15:32:07 <mauke> timthelion: you, yes, on the last line you said
15:32:09 <rwbarton> "main f >> y;f=getChar;y=putChar f;"
15:32:12 <rwbarton> utterly incomprehensible
15:32:26 <mauke> main = f >>= y; f = getChar; y = putChar
15:32:39 <shachaf> It looks like timthelion wants global variables.
15:32:53 <timthelion> mauke: that doesn't work in my case, because there are many lines of code, between f and y
15:32:58 <shachaf> Global write-once variables, anyway.
15:32:59 <mauke> timthelion: what
15:33:05 <mauke> timthelion: I only fixed your typos
15:33:31 <mauke> shachaf: a.k.a. lazy evaluation
15:33:37 <timthelion> mauke: I wrote code that doesn't work, and you wrote entirely different code that does something different
15:33:45 <shachaf> mauke: Well, no, because the "writer" does IO.
15:33:46 <rwbarton> of course it does something different
15:33:47 <mauke> timthelion: no, I wrote what you meant
15:33:49 <rwbarton> yours does nothing
15:33:59 <Saizan> timthelion: getChar >>= \c -> ...many lines of code.. putChar c
15:34:05 <timthelion> shachaf: I want global variables, but I don't want IORef because it isn't typesafe...
15:34:28 * dibblego signs out (have fun!)
15:34:33 <Saizan> how is IORef not typesafe?
15:34:52 <shachaf> mauke: I don't think you wrote the code timthelion meant. What timthelion is for "f" to be executed more than once, with subsequent executions using the first result.
15:34:53 <timthelion> Saizan: well that's what I understood from my readings
15:34:54 <zhulikas> these things in Haskell... custom syntaxes, code generation behind the scenes and similar stuff... is it called metaprogramming
15:34:54 <zhulikas> ?
15:35:02 <shachaf> But I don't think timthelion knows what timthelion meant either.
15:35:10 <Saizan> timthelion: you've been reading weird stuff
15:35:15 <mauke> shachaf: no, there are two codes
15:35:55 <mauke> shachaf: one that timthelion wrote in broken haskell, and the other is the one timthelion wants
15:36:02 <timthelion> shachaf: I am trying to write a befunge like language that precompiles to haskell... http://www.imagehosting.cz/images/grid.png
15:36:14 <rostayob> timthelion: ...wat
15:36:16 <timthelion> I'm trying to make that graph, precompile to working haskell code
15:36:20 <Saizan> timthelion: there's a questionable trick involved into getting a global IORef, but that's still typesafe
15:36:24 <mauke> zhulikas: how do you create custom syntaxes in haskell?
15:36:43 <zhulikas> for example with quasiquotes
15:36:57 <shachaf> Saizan: It is?
15:37:16 <mauke> shachaf: if you do it right :-)
15:37:32 <shachaf> mauke: I don't think that's what "typesafe" means...
15:38:01 <Saizan> you just have to give it a type
15:38:03 <zhulikas> maybe what I think about is template haskell
15:38:06 <rwbarton> shachaf: Though it seems immaterial to the discussion at hand, I think you are right about what timthelion wants.
15:38:16 <shachaf> Saizan: A non-polymorphic type.
15:38:21 <timthelion> I want to use If for looping(by referencing a value which came earlier) and I also want to pas the getChar to the next getline..
15:38:44 <mauke> "If for looping"?
15:38:56 * mauke teleports out
15:39:06 <timthelion> mauke: yes, if for looping, that's what befunge does
15:39:15 <Axman6> Saizan: IORefs can be used to implement unsafeCoerce, though i forget exactly how (it involves creating an IORef of type IORef a, which can the  store any type, and have it be read as any other type)
15:40:19 <timthelion> mauke: main = f0; f0=getChar >>= f1 ; f1 v1 = if v1 == 'y' then return else f0
15:40:32 <timthelion> mauke: if for looping, exactly what I said.
15:40:45 <mauke> that's not if for looping
15:40:56 <timthelion> mauke: what would you call it then?
15:41:11 <mauke> recursion?
15:41:21 <timthelion> mauke: and recursion is looping
15:41:42 <Axman6> most people would say they are distinct concepts
15:41:50 <Saizan> you are missing an argument to return
15:41:57 <timthelion> Axman6: but they are semantically the same.
15:41:59 <Axman6> (recursion _can_ be used to form loops, but not necewssarilly)
15:42:00 <Cale> sigh... the new profiler is pretty cool, except that the profiling results are perhaps a bit *too* detailed... I have a .prof here which is 280652 lines long.
15:42:03 <Axman6> no they're not
15:42:04 <timthelion> Saizan: sorry
15:42:33 <rwbarton> if possible this discussion has become even less constructive
15:42:33 <Cale> I should grep it for lines where the contributions to time are nonzero or something.
15:42:37 <timthelion> Axman6: well the example I give, is a looping recursion.  it is the same as a while loop
15:42:42 <alpounet> Cale, used -auto-all ?
15:42:49 <Cale> alpounet: yeah
15:43:01 <timthelion> Axman6: indeed, if you compile it, it should look the same in assembly.
15:43:07 <Axman6> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) -- This cannot be defined as a loop can it?
15:43:08 <lambdabot>   not an expression: `let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)...
15:43:29 <Axman6> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 7
15:43:30 <lambdabot>   13
15:43:35 <alpounet> Cale, maybe triy setting a few cost centres yourself, and then dive from here by choosing more precise cost centres, following the path of the most costful parts
15:43:38 <alpounet> smth like that :P
15:43:42 <alpounet> but that's weird
15:43:43 <timthelion> Axman6: You are right recursion doesn't have to be a loop, but the example I gave, is a loop.
15:44:09 <Cale> alpounet: yeah, might have to do something like that. It's because of the new fancy "artificial stack" stuff that happens in 7.4.1
15:44:09 <kallisti> well... you can transform it into a loop.
15:44:45 <timthelion> but think about what the compiler does.  It takes while, and turns it into the same recursive if that I just described
15:44:54 <timthelion> so maybe looping is recursion :D
15:44:58 <alpounet> Cale, you should ask in #ghc if there's a secret trick to sort of fallback on the usual cost centres choosing mecanism
15:45:47 <Cale> Yeah, I think it's theoretically a great thing, the extra detail, but I really need better tools for looking at the output now :)
15:46:57 <kallisti> timthelion: it's already been shown that both imperative loops and recursion are equivalently computationally powerful.
15:47:14 <timthelion> kallisti: I know.
15:47:36 <timthelion> did anyone look at the image I posted?
15:53:36 <Cale> alpounet: http://cale.yi.org/share/gameBenchmark.prof (warning 40MB :)
15:55:53 <alpounet> oh yeah indeed
16:03:46 <srhb> How can I print something that lives inside the Get monad?
16:06:34 <Cale> srhb: return it from your Get computation, and then print it after the computation has run.
16:07:10 <srhb> Right, I forgot to run it. Doh.
16:14:15 <srhb> read . show is probably a sign I'm doing something wrong, right? :P
16:14:44 <rwbarton> safeCoerce
16:15:46 <srhb> Hmm, I only see unsafeCoerce
16:16:04 <rwbarton> oh, I was joking, safeCoerce = read . show :)
16:16:11 <srhb> Aha. :P
16:17:29 <Mathnerd314> there's cast...
16:18:08 <Mathnerd314> @hoogle cast
16:18:08 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
16:18:08 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
16:18:08 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
16:26:30 <Guest54513> @hoogle state
16:26:30 <lambdabot> Control.Monad.State module Control.Monad.State
16:26:30 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
16:26:30 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
16:32:10 <timthelion> http://hpaste.org/64624 Why does the type not match?
16:33:39 <zhulikas> timthelion, nice one
16:34:12 <timthelion> zhulikas: what?  it's computer generated code.  It's not meant to look pretty
16:34:13 <geekosaur> line 7: no "return", but a (:), so it uses the list monad instead of IO.  I think
16:35:16 <timthelion> geekosaur: so I need to return what?
16:35:51 <geekosaur> more to the point, the outer constructor on the thing you are feeding to (>>=) there is (:), which means it's the list monad.  but the context you are using it in expects the IO monad.
16:36:42 <geekosaur> either you wanted to fmap it to something in IO, or you wanted to "return" the result so it's lifted to IO.  but I'm afraid to look at that code any more closely to find out :)
16:36:49 <timthelion> changing that to f4x1 p1 = return ((:) p1 f1x0) changed the error
16:37:17 <timthelion> geekosaur: it's a very esoteric implementation of getLine
16:37:20 <geekosaur> no, you want to fmap, just arbitrarily tossing a return in won;t work
16:37:54 <geekosaur> f4x1 p1 = (: p1) `fmap` f1x0 >>= ... -- I think
16:38:30 <geekosaur> er
16:38:37 <geekosaur> f4x1 p1 = (p1 :) `fmap` f1x0 >>= ... -- I think
16:38:39 <geekosaur> my bad
16:39:09 <geekosaur> f1x0 produces something in IO, you want to fmap the (:) over that
16:39:36 <timthelion> ok
16:41:18 <timthelion> geekosaur: thank you, that fixed it.
16:54:00 <Guest54513> goddamn
16:54:03 <Guest54513> I <3 Parsec
16:59:59 <monochrom> parsec is pretty nice
17:05:35 <alpounet> Cale, so, got any lead?
17:05:48 <alpounet> i may very well need it for when i'll switch to 7.4.1
17:07:21 * hackagebot th-instances 0.1.0.14 - A place to collect orphan instances for Template Haskell  http://hackage.haskell.org/package/th-instances-0.1.0.14 (JonathanFischoff)
17:07:26 <rostayob> the GHC mailing list discussion about records is getting out of hands
17:07:29 <rostayob> *hand
17:08:06 <alpounet> rostayob, yeah dropped that one quite a while ago
17:08:17 <alpounet> i'm focusing on Johan's proposal
17:14:09 <rostayob> alpounet: which is?
17:16:49 <alpounet> rostayob, unpacking primitive types by default in data
17:17:00 <alpounet> http://www.haskell.org/pipermail/glasgow-haskell-users/2012-February/021882.html
17:17:23 * hackagebot type-sub-th 0.1.0.4 - Substitute types for other types with Template Haskell  http://hackage.haskell.org/package/type-sub-th-0.1.0.4 (JonathanFischoff)
17:28:25 <bill```> lol
17:28:45 <Axman6> @hoogle (<=>)
17:28:45 <lambdabot> No results found
17:29:00 <Cale> alpounet: Not really. I think I actually have enough information to get started on what I'm interested in, but it would be nice to have some tools for analysing all this.
17:29:46 <Axman6> hmm, what do others thing of the proposal for (<=>) = compare? reads nicely, and reminds you of the cases, less than, equal, greater than
17:31:21 <bill```> same as the comparison operator in ruby
17:32:01 <bill```> referred to as the "spaceship operator"
17:32:14 <Cale> Axman6: It does read nicely, but it does steal more nice operator symbols for use in libraries...
17:32:36 <ben> How common is compare?
17:32:37 <Axman6> yeah, i can see that also being useful for equivalence in logic
17:32:50 <Axman6> ben: imo, it should be more common
17:33:15 <Jafet> Ord a appears in many places that a->a->Ordering should appear
17:33:21 <Axman6> using things like <, <=, > etc. lead to easy to avoid bugs
17:34:46 <Cale> I use compare quite a bit myself
17:34:52 <rwbarton> personally I don't think there is that much gain from using infix operators for things that aren't "chainable"
17:34:59 <Cale> but I usually somehow don't mind it not being infix
17:35:07 <Cale> rwbarton: right...
17:35:23 <Cale> Now if (++) were mappend
17:35:37 <Cale> Then it might lead to some interesting cases :)
17:36:03 <rwbarton> compare x1 y1 ++ compare x2 y2 doesn't seem bad to me either
17:36:32 <rwbarton> And you don't have relative precedences to worry about
17:36:40 <Jafet> :t (++)
17:36:41 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:36:54 <ben> :t (.)
17:36:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:39:25 <Jafet> Prelude.. is infixr 9? I thought it should be lower
17:53:07 <aristid> :t read
17:53:08 <lambdabot> forall a. (Read a) => String -> a
18:19:16 <Axman6> hmm, anyone know a nice textual way to show something like a ternary tree? I managed to come up with something that works well for binary trees, but the method I used won't work too well...
18:19:45 <Axman6> hmm, maybe i can show it with the root at the left and growing right...
18:22:07 <edwardk> --+ a --+ b --+ c --+ d --+ []    -- with the usual fanout above and below for the left and right children?
18:22:30 <Axman6> yeah, trying to figure out how to code that :\
18:22:53 <edwardk> its not all that different from the code used in, say, Data.Set
18:23:22 <edwardk> you need an extra couple of prefix strings though
18:24:07 <edwardk> and the number of spaces becomes dependent on the length of the string used to describe the labels, annoyingly
18:24:33 <Axman6> yeah
18:25:16 <Axman6> the way i did it for binary trees was to just reparse the top line of each branch to find out where I needed to draw things to. worked quite well (after my horrible attempt to get all the maths to work)
18:25:41 <edwardk> ah, look at the Data.Set code, its pretty clean as i recall
18:25:50 <Axman6> well do, thanks
18:26:28 <edwardk> wow its a lot more verbose than mine, wonder where i put that
18:27:07 <monochrom> a pretty-printer library may help
18:39:58 <Axman6> monochrom: don't those tend to focus on just putting new lines where you need them? My other alternative is just to use something like Gloss and give the students an image
18:47:53 <edwardk> Axman6: i have a starting point for you
18:47:54 <edwardk> @hpaste
18:47:55 <lambdabot> Haskell pastebin: http://hpaste.org/
18:48:07 <hpaste> edwardk pasted “for axman” at http://hpaste.org/64626
18:48:34 <hpaste> edwardk annotated “for axman” with “for axman (example)” at http://hpaste.org/64626#a64627
18:48:40 <aszlig> okay, this is either really weird or i'm just too blind... if i'm returning responseLBS from a warp Application, it seems that if there is no header named X-HTTP-Version, it seems that the value of the Date-header is actually returned as a relpy
18:48:41 <edwardk> feel free to hide the tip nodes
18:48:45 <edwardk> i just wrote something quick
18:49:19 <edwardk> oh and i used mt instead of rt by mistake
18:49:34 <hpaste> edwardk annotated “for axman” with “for axman (annotation)” at http://hpaste.org/64626#a64628
18:49:35 <Axman6> beautiful! thanks a lot =)
18:49:48 <aszlig> but when grepping dependencies and source of warp there is no occurence of X-HTTP-Version
18:50:05 <Axman6> edwardk: mind if I steal it, with attribution?
18:50:10 <edwardk> its all yours
18:50:18 <aszlig> (and yep i grepped with -i and x.*http.*version)
18:50:53 <edwardk> the ‗'s are from my pasting it out of vim, strip them out =)
18:50:56 <Axman6> i should reference you anyway, since this isfor a first year CS course, which started with a big scary talk on plagiarism
18:51:07 <aszlig> the only occurence is in HTTP which i do not depend on at all
18:51:09 <edwardk> hah
18:51:12 <edwardk> fair nuff
18:51:15 <Axman6> =)
18:51:29 <edwardk> i hereby place this code in the public domain, blah blah blah
18:51:33 <edwardk> =P
18:51:50 <Axman6> Still, you're getting credit in the comments ;)
18:52:06 <edwardk> wait, first year CS?
18:52:16 <Axman6> yeah
18:52:49 <edwardk> getting edjumicated?
18:53:19 <Axman6> well, i'm writing the second assignment for the course
18:53:26 <edwardk> ah
18:53:29 <edwardk> that makes more sense =)
18:53:44 <Axman6> yah ;) should have made that more clear, heh'
18:56:12 <Axman6> edwardk: that works fantastically, thanks so much :)
18:56:39 <aszlig> "Fri, 02 Mar 2012 02:55:20 GMT 200 OK" is what i'm getting as a response without X-HTTP-Version being in the headers, and a perfect response when putting X-HTTP-Version in
18:57:12 <edwardk> @hpaste
18:57:13 <lambdabot> Haskell pastebin: http://hpaste.org/
18:57:33 <hpaste> edwardk annotated “for axman” with “sans tips” at http://hpaste.org/64626#a64629
18:58:06 <edwardk> looks a bit more lopsided, but its a lot less noisy
18:58:32 <Axman6> i found removing the +4's made it more compact too, which I think is a good thing
18:58:39 <edwardk> *nods*
18:58:56 <edwardk> i just put them there for alignment
18:59:10 <Axman6> ah i see
18:59:49 <Axman6> i think i prefer it without the alignment actually, since i'm using this as a prefix tree, and the left and right branches are in a sence 'higher' than the middle branch
18:59:54 <Axman6> if that makes sense
19:00:01 <edwardk> fair nuff =)
19:03:05 <hpaste> Axman6 annotated “for axman” with “sans tips (annotation)” at http://hpaste.org/64626#a64630
19:03:20 <Axman6> edwardk: that's what it's looking like now, and I think it works well
19:03:56 <edwardk> *nods* if you incorporate the if's in the code i gave it'd strip the empty branches off, but thats both good and bad
19:05:07 <Axman6> yeah, at least with that test, it looked confusing when I added the Nil pruning, so i'll keep it this way for clarity, even if it is less compact
19:05:15 <edwardk> *nods*
19:05:52 <hpaste> Axman6 annotated “for axman” with “Horrible binary tree Show” at http://hpaste.org/64626#a64631
19:06:01 <edwardk> you can also run 'go " " "-" " " instead of go [] [] [] to get a more clear root
19:06:26 <edwardk> heh is that what you started with?
19:06:26 <Axman6> that's my horrible code for drawing the binary tree I'm using (it's got the root at the top though)
19:06:48 <nexion> is there something like a TChan/queue that ignores duplicates?
19:07:03 <Axman6> well, that's what I'm using for the binary tree. I did try another version that calculated the widths things needed to be, but this way worked out quite well instead
19:08:07 <Axman6> nexion: you could probably use a Set for that... though taking things out in order would be slightly tricky
19:08:13 <edwardk> *nods*
19:09:35 <edwardk> your middle tree alignments are sligntly off though, they don't come off of the '+'
19:09:38 <edwardk> =P
19:09:42 <monochrom> you are better off arranging the absence of duplicates or robustness against duplicates
19:10:11 <nexion> ty Axman6
19:10:20 <Cale> You could have a TVar (Set a) which you'd maintain alongside the TChan a
19:10:28 <hpaste> Axman6 annotated “for axman” with “Horrible binary tree Show example” at http://hpaste.org/64626#a64632
19:10:38 <Cale> Though I'm not sure that's the best answer
19:10:41 <edwardk> ah
19:10:56 <nexion> what about.. TVar [QueueElement]?
19:11:08 <nexion> and just implement the basic insert/remove
19:11:57 <Cale> lists don't make very good queues generally
19:12:08 <Axman6> well, you could just use data UniqQ a = UQ (Set a) (TChan a), with insert and remove modifying/checking the Set first
19:12:15 <Cale> because accessing the end of a list is slow
19:12:20 <Axman6> uh, no, needs to be a TVar (Set a)
19:12:33 * hackagebot bindings-sipc 1.0 - Low level bindings to SIPC.  http://hackage.haskell.org/package/bindings-sipc-1.0 (JustinEthier)
19:12:47 <hpaste> edwardk annotated “for axman” with “trinary tree (stubbier)” at http://hpaste.org/64626#a64633
19:13:03 <edwardk> er missed a space
19:13:19 <Cale> (also in this case because looking through a list for a possible duplicate will be slow)
19:14:23 <hpaste> edwardk annotated “for axman” with “trinary tree (stubbier but spaced correctly) (annotation)” at http://hpaste.org/64626#a64634
19:15:08 <nexion> a combination of TChan and Set is sounding pretty good
19:15:12 <aszlig> okay, it seems that list order doesn't seem to be the root of the problem, plus it only seems to accept X-HTTP-Version O_o and even stfw does only return the haskell HTTP library and some perl stuff
19:15:47 <edwardk> Axman6: ok i consider this tree officially beaten to death =)
19:16:24 <nexion> this is a very beginner question, but why can't lists support O(1) tail access?
19:16:41 <tgeeky_> nexion: because that's what d-lists are for
19:16:55 <edwardk> nexion: there are data structures that do, but they aren't as easy to work with
19:17:04 <edwardk> tgeeky_: actually dlists suck for access ;)
19:17:11 <edwardk> you can just build them kinda quickly =)
19:17:25 <monochrom> that is like saying "why can't perl be statically typed"
19:17:29 <tgeeky_> yeah, but conceptually they are easy to see how you could get O(1) tail access
19:17:33 * hackagebot bindings-sipc 1.1 - Low level bindings to SIPC.  http://hackage.haskell.org/package/bindings-sipc-1.1 (JustinEthier)
19:18:07 <edwardk> tgeeky_: they give you cheaper append, but to read the tail is O(holycrap)
19:18:19 <Cale> heh
19:18:50 <tgeeky_> edwardk: hehe. right. so *write* the tail, and then you know what the tail is, without any more work -- which is O(0)
19:18:58 <Cale> nexion: because every node of the list would have to keep a pointer to the last element, which would waste lots of memory?
19:18:59 <edwardk> so i suppose it comes down to what you want to do with that access =)
19:18:59 <tgeeky_> but I use O(1) to avoid suspicion
19:19:02 <monochrom> perl is designed to maximize some other things and sacrifice static typing. list is designed to maximize some other things and sacrifice O(1) last-item access. if you want O(1) last-item access, you're welcome to use something else.
19:19:40 <edwardk> nexion: i can give you a pointer to the end of every list in haskell
19:19:41 <Cale> nexion: It's easy to just hang onto the end of the list yourself. Now, if you're talking about adding elements to the end of a list, it's easy to see why that *has* to be O(n)
19:19:41 <edwardk> > []
19:19:42 <lambdabot>   []
19:19:44 <tgeeky_> oh, category theory question I have been waiting to ask
19:19:47 <monochrom> question for tomorrow: "why doesn't irc support inline graphics?"
19:19:53 <edwardk> its just not very useful because we don't build lists through mutation
19:20:02 <tgeeky_> monochrom: because we've been chatting on IRC too much to write the replacement
19:20:04 <Cale> because it means changing all the lists in between
19:20:14 <Cale> (replacing them with lists that have a different tail)
19:20:22 <edwardk> we build them by building new list nodes and consing them onto other lists
19:20:29 <edwardk> also, we can have infinite lists in haskell
19:20:34 <edwardk> what is the pointer to the last node in
19:20:38 <edwardk> > fix (1:)
19:20:38 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:20:45 <nexion> true..
19:21:01 <edwardk> that very concept isn't well formed in a lazy world
19:21:05 <nexion> yeah
19:21:07 <Cale> Yeah, some lists don't have an end :)
19:21:08 <tgeeky_> edwardk: so. In this category theory book (which has been good so far), he's (several times) used the phrases "in the large" and "in the miniature" (which I assume could be "small"). What is this supposed to mean?
19:21:44 <Cale> tgeeky_: maybe nothing technical?
19:21:51 <edwardk> we can make a notion of a deque that provides O(1) access to the head and the tail of the list, for pushing and popping, and which is also persistent and purely functional, but it doesn't operate quite how you'd expect coming from an imperative background
19:21:54 <tgeeky_> Cale: fine, what does it mean, non-technically
19:21:57 <Cale> tgeeky_: "In general" and "In particular"?
19:22:12 <tgeeky_> Cale: really? it's a generality statement? that's weird.
19:22:19 <Cale> Well, I don't have any context
19:22:24 <Cale> What book are you reading?
19:22:30 <edwardk> either generality or size related =)
19:23:05 <Cale> Yeah, there are 'small categories', ones whose collection of objects is merely a set ;)
19:23:16 <byorgey> "in the miniature" means "this only works if you draw the diagrams real small"
19:23:20 <Cale> and then 'large categories' have a proper class of objects
19:23:23 <tgeeky_> byorgey: hehe
19:23:25 <Cale> hehehe
19:23:31 <edwardk> nexion: chris okasaki has made more or less a career out of building nice data structures for pure languages
19:23:44 <tgeeky_> byorgey: I ruled that out, by a (non-invariant) scale transformation with a magnifying glass
19:24:02 <tgeeky_> Cale: http://www.cs.man.ac.uk/~hsimmons/zCATS.pdf
19:24:03 <byorgey> tgeeky_: ah, very astute
19:24:04 <edwardk> http://www.eecs.usma.edu/webs/people/okasaki/jfp95queue.pdf
19:24:09 <tgeeky_> search for "in the miniature"
19:25:05 <Cale> tgeeky_: ah, yeah, it's sort of a generality statement combined with a hint about size :)
19:25:13 <tgeeky_> I have seen "in the large" before with other category theorirsts, but not "miniature" Evidently that word is unique to this guy (Simmons) and he plagarized himself.
19:25:34 <Cale> tgeeky_: Monoids are the same thing as categories with only a single object (which makes them 'miniature' in a way)
19:25:39 <monochrom> plagiarizing onself sounds very pervert :)
19:25:44 <edwardk> nexion: but in practice if you want both ends, use Seq from Data.Sequence, its faster
19:25:55 <tgeeky_> monochrom: doesn't it? I didn't even know it was a serious thing until late in college.
19:27:00 <edwardk> i think 'in the miniature' is just 'with nothing else cluttering up your view' in that context
19:27:01 <Cale> tgeeky_: and preorders (he seems to prefer presets?) are categories with at most one arrow between any pair of objects
19:27:03 <tgeeky_> Cale: but that isn't related to "small" in the category sense, which I thought was about sets vs. classes?
19:27:07 <Cale> tgeeky_: right
19:27:28 <Cale> tgeeky_: though monoids and preorders in the classical sense are both types of small categories
19:27:35 <edwardk> tgeeky_: yeah its not a small category size thing, just a 'teensy example' ;)
19:28:09 <tgeeky_> Cale: what I was trying to rule out, is that he's probably not making a statement where 'in the large' means exhausting all kinds of categorial contsructions
19:28:33 <edwardk> tgeeky_: nah, neither of those examples is very complicated
19:28:35 <Cale> http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf -- in case you don't also have it, you might like this for reference as well (it's my favourite intro to CT)
19:28:43 <edwardk> he's just usingthem as a sort of showcase for the concept
19:28:52 <nexion> edwardk: thanks, good info
19:29:32 <tgeeky_> and why the hell does nobody talk about loops?
19:29:35 <Cale> Category theory can be pictured as a sort of filled out "product" of the concept of monoids and the concept of preorders
19:29:45 <tgeeky_> There's a billion group theory books for every one about loops.
19:30:01 <Cale> tgeeky_: because it's kinda hard to say very much about loops?
19:30:03 <monochrom> recursion is better than loops. there, I have talked about loops. :)
19:30:14 <tgeeky_> monochrom: different kind of loops :)
19:30:32 <Axman6> edwardk: so, since you're the expert, I don't suppose you'd have a nice algorithm which balances a ternary tree when given a bunch of 1 length strings? (I'm using this for LZW compression, and I need to give the students a tree with '\0' .. '\255' already there, and my initial attempt makes a highly unbalanced tree, which is hilarious to look at when showin in the terminal
19:30:54 <edwardk> ah, no idea
19:31:14 <edwardk> i have a super tiny lz78 compressor/decompressor you can steal though ;)
19:31:24 <Cale> tgeeky_: Group theory is already very hard. Removing assumptions from it makes it harder to say things about the resulting structures.
19:31:40 <Axman6> i had an idea how to do it, but i couldn't wuite make it work
19:31:44 <tgeeky_> Axman6: randomly generate a negative-ternary (-3) base number and shift it
19:31:44 <Axman6> q*
19:32:00 <Axman6> wat
19:32:02 <edwardk> you can just balance it using the approach from data.set/data.map
19:32:14 <tgeeky_> Axman6: yeah, I'm not even sure if it makes sense.
19:32:20 <edwardk> that works even if you incorporate the mass of the third leg if you open up the rotation coefficients
19:32:35 * hackagebot copilot-libraries 0.4 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-libraries-0.4 (LeePike)
19:32:37 * hackagebot copilot 2.0.9 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.0.9 (LeePike)
19:32:45 <Axman6> the thing that's annoyed me is that i'be managed to create balanced binary trees before, but i couldn't get this to work >_<
19:33:02 <tgeeky_> Cale: well, it's just associtivity. Getting rid of that seems to just blow everything out of the water.
19:33:08 <edwardk> its the same trick, the third leg is just extra data, so anything you can do for binary trees works here
19:33:29 <Axman6> ah, i remember why that didn't work, each node has a key, which the binary trees didn't
19:33:48 <Axman6> I'll think about it agian and see if i can come up with something
19:34:03 <tgeeky_> Axman6: I was referring to this: http://en.wikipedia.org/wiki/Balanced_ternary
19:34:15 <edwardk> but thats the same thing as just balancing a binary tree of any other sort. you can add size info and do size balanced trees, avl trees with depth, etc.
19:34:23 <edwardk> ignoring the third leg
19:34:25 <Cale> tgeeky_: Indeed, there also don't seem to be so many important examples of loops which aren't groups, or rather, problems whose solution requires understanding of such things.
19:34:51 <Cale> tgeeky_: A more interesting generalisation of groups, if you ask me, is groupoids in the category-theoretic sense
19:35:03 <Cale> That is, categories in which every arrow has an inverse.
19:35:18 <tgeeky_> Cale: Yes. And that is the best possible explanation until we realize that we've been missing them all along for some reason.
19:35:28 <edwardk> because what you really have is data Tri a = Tri { runTri :: Map a (Tri a) }
19:35:30 <Cale> tgeeky_: sure :)
19:36:30 <edwardk> so balance that like you're balancing a Map
19:39:10 <Cale> tgeeky_: There are some examples of non-associative algebras which are actually important, and most of which have other weaker replacements for associativity of various sorts, and the units of those algebras might form a loop.
19:39:59 <tgeeky_> Cale: what's interesting to me, is that I've looked through (scanned...) lots of literature which I have access to
19:40:39 <tgeeky_> loops and geometric algebra were both stepchilds of study of Clifford algebras, but neither of them have *any* cross reference
19:40:42 <tgeeky_> as far as I can tell
19:41:11 <Cale> oh, loops were?
19:41:19 <Cale> Clifford algebras are associative
19:41:34 <Cale> I'm curious how loops showed up there :)
19:41:45 <tgeeky_> Cale: well, I'm saying they didn't show up, but that's obviously a good answer to that :)
19:42:36 * hackagebot copilot-core 0.2.4 - An intermediate representation for Copilot.  http://hackage.haskell.org/package/copilot-core-0.2.4 (LeePike)
19:42:37 <Cale> Oh, I must have taken 'stepchildren' the wrong way :)
19:42:47 <tgeeky_> Cale: no, it's more likely that I'm wrong
19:42:59 <Cale> I'm pretty sure there are connections between Clifford algebras and geometric algebra
19:43:14 <tgeeky_> Cale: GA is an extension of CA, for better or worse
19:43:20 <Cale> though I wouldn't be the ideal person to talk about that... who was our resident GA expert again?
19:43:37 <tgeeky_> Cale: but yeah, from http://en.wikipedia.org/wiki/Loop_(algebra) <-- and wolfram demonstration applets
19:44:43 <byorgey> ISTR ddarius knows some GA?
19:44:57 <edwardk> A geometric algebra is just a clifford algebra over the reals
19:45:18 <dmwit> byorgey: YSK TSAR, and DFTBA
19:45:20 <tgeeky_> Cale: the octonions edwardk uhhh, I think not anymore. they use fancier number systems in the state of the art stuff
19:45:27 <tgeeky_> errr
19:45:32 <tgeeky_> first of all. ignore all of that crap.
19:45:40 <edwardk> ?
19:45:41 <tgeeky_> edwardk: : uhh... ^^^
19:45:42 <Cale> edwardk: oh, hah
19:45:52 <tgeeky_> s/Cale: the octonions//
19:45:57 <byorgey> dmwit: IITB, your MFG is AWFL
19:46:50 <dmwit> Now you're just making things up.
19:47:18 <edwardk> there is a cute recurrence between the clifford algebras, which provides one way to decompose them and save work for certain use cases, but depending on what you're doing with GA you most likely don't want to work that way
19:47:37 * hackagebot copilot-language 0.7 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-0.7 (LeePike)
19:47:50 <tgeeky_> edwardk: yeah. I would assume so. The most GA practicioners seem to want to use it for physics these days.
19:48:09 <edwardk> i use it mostly for graphics
19:48:22 <tgeeky_> edwardk: you're weird like that
19:48:33 <tgeeky_> edwardk: one day, I'll ask you why you don't like physics.
19:48:46 <tgeeky_> And hopefully I'll make you feel bad about yourself.
19:48:51 <edwardk> hey i spent the whole day learning hamiltonian mechanics
19:48:57 <tgeeky_> edwardk: today?
19:49:00 <edwardk> yep
19:49:07 <edwardk> needed it for hybrid mcmc =)
19:49:14 <tgeeky_> edwardk: I'm so proud!
19:49:21 <Axman6> edwardk: managed to get something that works well (afaict anyway...). just using simple a splitAt (len `div` 2) to find the middle
19:49:32 <Axman6> it's probably not perfectly balanced, but it works well
19:49:40 <edwardk> now i have a hamiltonian metropolis hastings sampler
19:49:53 <tgeeky_> Figures.
19:50:05 <edwardk> lots faster
19:50:23 <tgeeky_> I'm starting a new reddit meme. Good Guy Edwardk.        Studies Hamiltonians for one day.              Already knows more about it than you.
19:50:23 <Cale> edwardk: There seem to be various weird hard-to-explain problems using the Dict type from your blog which vanished when I specialised it to various specific constraints I wanted to work with.
19:51:06 <edwardk> Basically if you let a frictionless puck skitter around in the well described by the negative log of the probability density function, and sample it every so often it makes a nice approximation of sampling from that distribution
19:51:19 <edwardk> cale: do you have any examples?
19:51:58 <Cale> edwardk: Only my thousands of lines of FRP implementation. I believe I've run into a few problems with the GHC typechecker, but it's really hard to produce small examples.
19:52:01 <edwardk> cale: you didn't try to do the 'smarter' 'on' that copumpkin keeps going on about did you?
19:52:06 <edwardk> ah
19:52:08 <Cale> no
19:52:26 <alang_> edwardk: how much kinetic energy do you give it?
19:52:26 <Cale> Just basic passing around of dictionaries and explicit unpacking
19:52:37 * hackagebot copilot 2.1.0 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.1.0 (LeePike)
19:52:46 <Cale> (I didn't even really use the fancy operators)
19:52:47 <alang_> edwardk: (the puck)
19:53:00 <tgeeky_> alang_: it's a Hamiltonian. So that is the question
19:53:13 <reltuk> If I've got an operation in a stack of two monad transformers, MT1 (MT2 m), it there any way to like...convert the action to one that adds a monad transformer inbetween the two existing transformers?
19:53:18 <alang_> right
19:53:55 <Cale> reltuk: so you want MT1 (MT2 m) a -> MT1 (MT3 (MT2 m)) a
19:54:00 <reltuk> indeed
19:54:08 <Cale> reltuk: which is  fmap lift
19:54:13 <reltuk> brilliant!
19:54:22 <dmwit> ?where aam
19:54:22 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
19:54:26 <edwardk> alang_: basically you're preserving total energy, drawing momentum from a multivariate gaussian, then running a leapfrog integrator for a few dozen steps, then doing it all over again
19:55:59 <edwardk> @hpaste
19:56:00 <lambdabot> Haskell pastebin: http://hpaste.org/
19:56:12 <alang_> ah I see
19:56:21 <hpaste> edwardk pasted “hmc step” at http://hpaste.org/64636
19:56:23 <tgeeky_> edwardk: Your 'basically' threshold is higher than mine, lol
19:56:42 <edwardk> thats a single dimensional version, the multidimensional version is that with a lot of zipping
19:57:02 <tgeeky_> this does look pretty simple
19:57:05 <edwardk> and i switched from variance of momentum to step size
19:57:26 <tgeeky_> edwardk: and why are you doing this again?
19:58:25 <edwardk> tgeeky_: because i want to be able to generate and test hierarchical bayesian models in haskell. also because i would like eventually to be able to cobble together a nice dsl for doing probabilistic programming in haskell that permits me to talk about continuous distributions
19:58:59 <tgeeky_> edwardk: I was thinking about the second part of that sentence this morning.
19:59:03 <tgeeky_> It would be nice, wouldn't it
19:59:09 <Cale> edwardk: Is this all somehow related to money in some way? :)
19:59:23 <edwardk> cale: eventually, yes =P
19:59:25 <tgeeky_> edwardk: he could answer that question, if he had the code working
19:59:37 <tgeeky_> sigh.
20:00:08 <edwardk> this is more like me pulling all my crazy metropolis code out of the gpu and trying to figure out a nice way to encode combinators for dealing with these kinds of problems in haskell in a more general setting
20:00:17 <tgeeky_> I don't know how watching an infant do almost nothing for several hours straight can be so tiring, but it was.
20:00:46 <edwardk> a.) it clears up my thinking, b.) i get a haskell library out of it, and c.) i can then use the knowledge gained in other projects
20:01:02 <tgeeky_> d.) opens the doors for haskell-physics
20:01:49 <edwardk> if you don't randomize p at the beginning there, then thats basically a leapfrog integrator for doing small step hamiltonian dynamics
20:02:26 <edwardk> anyways, why i care about it is it lets me use information about the derivative of the pdf… which i can obtain using automatic differentiation
20:02:38 <edwardk> and i happen to know a thing or two about automatic differentiation
20:05:06 <edwardk> tgeeky_ : with a grown up version of that toy up there (and some other methods) and some code for auto-tuning thinning based on auto-correlation i can draw nice samples from scary distributions
20:05:19 <dolio> Then you can do raytracing of a voxel-based 3D user interface with high definition surface materials using Metropolis-Hastings Markov chain Monte Carlo integration of automatically derived functions.
20:05:53 <edwardk> dolio: you figured out my end game!
20:05:54 <dolio> Better than the way John Carmak does it.
20:06:25 <tgeeky_> You forgot: Step 5) ??? Step 6) TRON
20:07:08 <tgeeky_> edwardk: keep me informed of this, good sir.
20:07:09 <edwardk> my obsessions are not designed to be strung together like that in a single sentence. ;)
20:07:32 <edwardk> you forgot to throw in 'lock free' some how ;)
20:07:38 * hackagebot copilot-c99 0.2.5 - A compiler for Copilot targeting C99.  http://hackage.haskell.org/package/copilot-c99-0.2.5 (LeePike)
20:08:08 <tgeeky_> edwardk: how about cache-agnostic?
20:08:23 <edwardk> and 'on the gpu' or 'distributed across 50 machines' and 'how to set things up so that you can still make forward progress when the New York office goes offline'
20:08:47 <edwardk> tgeeky_: i actually am quite the opposite of cache oblivious in my systems approaches ;)
20:08:57 <edwardk> i tend to optimize very much for particular cache sizes
20:09:13 <rwbarton> don't worry, there's a buzzword for that too I'm sure
20:09:21 <edwardk> cache-aware =)
20:09:25 <tgeeky_> rwbarton: too bad we can't just put a ! in front
20:09:31 <dolio> The user interface is for a lock free distributed GPU-based column store based on linear bloom filters.
20:09:53 <tgeeky_> edwardk: it occured to me this morning that 'athiest' was adopted as the monkier for people whose opinion opposed that of 'a theist'.
20:10:12 <tgeeky_> Just to learn that the opposite happend with the word 'apron' (from napron)
20:10:32 <tgeeky_> what is wrong with "you people"?
20:11:04 <dolio> a napron, an apron
20:11:26 <tgeeky_> yeah. who'd of thunk it.
20:11:47 <edwardk> found http://www.mit.edu/~ast/papers/nonstandard-interpretations-nips2011.pdf after i started playing around with langevin monte carlo last night. i really liked the AD usecases.
20:12:42 <edwardk> I also wish I hadn't tuned out alexey radul when he last mentioned it ;)
20:13:31 <tgeeky_> edwardk: his website is a bit rapey
20:13:34 <tgeeky_> http://web.mit.edu/~axch/www/
20:13:51 <edwardk> hah, well, he's happily married these days =P
20:22:42 <co_dh> May I post a python job here? I'd like to find a python programmer who loves Haskell.
20:23:25 <co_dh> Telecommunicating is ok as long as you can legally work in Canada.
20:23:52 <co_dh> If interested, send your resume to hdeng@pivotalpayments.com
20:40:11 <dmwit> co_dh: You should definitely post something on haskellers.com, I think that's what it's for.
21:02:25 <qued_____> hi
21:02:41 <qued_____> which lib to include for using "toUpper" / "toLower" in ghci ?
21:03:01 <qued_____> include/ load
21:03:08 <dmwit> import Data.Char
21:03:11 <dmwit> ?index toUpper
21:03:11 <lambdabot> Data.Char
21:03:27 <dmwit> You could also consider asking hoogle.
21:03:30 <dmwit> ?hoogle toUpper
21:03:30 <lambdabot> Data.Char toUpper :: Char -> Char
21:03:30 <lambdabot> Data.Text toUpper :: Text -> Text
21:03:30 <lambdabot> Data.Text.Lazy toUpper :: Text -> Text
21:03:44 <qued_____> data.char
21:03:49 <qued_____> dmwit: ty
21:05:31 <conal> is there a ghci flag that says to evaluate a given expression (and execute if IO) and then exit?
21:05:43 <conal> i vaguely remember there being one
21:06:36 <dmwit> There's ghc -e
21:07:01 <conal> dmwit: that's it. thanks!!
21:25:04 <qued_____> _ stands for substring in the following?     let (a:b:_:_) = "1234" in a
21:25:10 <qued_____> or char
21:25:47 <ulfdoz> its a pattern, and _ matches the part which you don't care for.
21:25:49 <mikeplus64> _ is pattern matched to a Char
21:25:54 <dmwit> qued_____: _ stands for a "don't-care" part of a pattern
21:26:11 <mikeplus64> well, a Char and a [Char]
21:26:17 <dmwit> qued_____: In that particular pattern, there are two: the first matches any character, and the second matches any string.
21:26:53 <mikeplus64>  > 'a':'b':'c':'d':[]
21:26:58 <mikeplus64> > 'a':'b':'c':'d':[]
21:26:59 <lambdabot>   "abcd"
21:29:25 <conal> is there a ghci flag that say to ignore the .ghci file?
21:30:32 <Cale> -ignore-dot-ghci
21:31:33 <qued_____> ty
21:33:22 <dibblego> hello, I have a brain block with implementing a choice function for Comonad f => CoKleisli f, can someone please give me a push? http://paste.pocoo.org/show/559580/
21:37:36 <sopvop> what's that ugly aliased picture on haskell platform site background?
21:39:13 <mzero> I think that might a problem serving the image - it shouldn't be aliased at all
21:39:25 <mzero> and I notice that I can't even surf the site at the moment
21:40:33 <sopvop> I think it's just sharpened too much. And site works for me. http://hackage.haskell.org/platform/
21:41:21 <mzero> ah working now - I see, the frozen water drops look like aliasing
21:41:43 <mzero> anyhow - it is dons' "winter" theme -
21:41:54 <mzero> he's got a theme (image & colors) for each season
21:47:45 * hackagebot math-functions 0.1.1.1 - Special functions and Chebyshev polynomials  http://hackage.haskell.org/package/math-functions-0.1.1.1 (BryanOSullivan)
21:48:44 <djahandarie> Anyone here happen to have a thought on what the bases of the logorithms are for Data.Sequence?
21:50:24 <tgeeky> this is a complexity question, right?
21:50:43 <djahandarie> Depends on what you mean by complexity, but yes, you could say that.
21:51:19 <alang_> djahandarie: you're referring to the big-Os?
21:51:22 <tgeeky> djahandarie: I think I mean, O (... )
21:51:26 <tgeeky> ^
21:51:41 <djahandarie> It wouldn't be big-O if you're talking about logorithm bases.
21:52:08 <djahandarie> logarithm*
21:52:28 <djahandarie> (Because you can switch bases with a constant factor.)
21:53:06 <tgeeky> like (n^2) -> ((n+1)^2)
21:53:09 <tgeeky> ?
21:54:03 <tgeeky> djahandarie: I'll admit that I've never seen a "log(..)" inside a O(..) notation, but I think I'm about to be embarassed about something I don't know
21:55:21 <djahandarie> Like log_10(5) = (1 / log_2(10)) log_2(5). You can do a base conversion with a constant factor, which means big-O doesn't care about it.
21:55:44 <djahandarie> I.e., O(log_10(x)) = O(log_2(x))
21:56:36 <startling> woah woah woah. are monads just combinators?
21:56:47 <djahandarie> Big-O notation is crap anyways, since it isn't actually equality, just idiots overloading =.
21:56:48 <dolio> No.
21:57:33 <startling> dolio: was that to me?
21:57:37 <dolio> Yes.
21:57:58 <alang_> djahandarie: I think it's meant to be equality in the space of functions modulo asymptotic behaviour?
21:58:01 <startling> how are they different? is it that monads wrap their values?
21:58:06 <djahandarie> alang_, right.
21:58:36 <djahandarie> Not existential function equality.
21:58:43 <dolio> Monads are functors together with a pair of natural transformations that satisfy some commutative diagrams.
21:59:21 <startling> dolio: functor in the math or the haskell-specific sense?
22:00:14 <dolio> The Haskell sense is a specialization of the math sense.
22:00:47 <startling> hm, okay.
22:02:29 <djahandarie> I guess I'll just look at the code. *sigh*
22:04:55 <dolio> If you're talking about performance, the base is going to be between 2 and 3.
22:05:02 <rwbarton> djahandarie, I'm not sure what kind of answer you are hoping to get
22:05:22 <djahandarie> The kind dolio just gave.
22:05:29 <rwbarton> I don't understand dolio's answer.
22:05:43 <tgeeky> I don't even understand the question! (seriously)
22:05:57 <rwbarton> Right, that is where I am too
22:06:17 <dolio> The branching factor is between 2 and 3, and that's where the logarithms come from.
22:07:28 <djahandarie> rwbarton, not sure what's complicated about it. I'm asking for the averageish time complexity of the various operations which involve tree manipulations in Data.Sequence.
22:07:49 <rwbarton> well, it is O(log n)
22:07:59 <rwbarton> which means the same thing regardless of what base you choose
22:08:23 <rwbarton> if you want an actual value in, like, seconds, that will depend on your hardware
22:08:44 <rwbarton> there's no value for the base which will tell you more information than any other value for the base
22:09:17 <djahandarie> rwbarton, there IS a value for the base, it's just hidden by the O.
22:09:28 <rwbarton> But, I'm especially confused because you seem to have pointed this out yourself already.
22:09:32 <rwbarton> Look.
22:09:40 <rwbarton> I can correctly state that the performance is O(log_2 n).
22:09:48 <rwbarton> I can equally correctly state that the performance is O(log_50000 n).
22:10:01 <rwbarton> There is no "value for the base" which you can extract.
22:10:22 <djahandarie> Sure, but you cannot state the performance is log_2 n if the performance is log_50000 n.
22:10:37 <rwbarton> I also can't state that the performance is log_2 n because that doesn't make any sense.
22:10:47 <rwbarton> Do you mean log_2 n seconds?
22:11:00 <tgeeky> rwbarton: are you infallable here, ie an expert or something?
22:11:23 <rwbarton> this is just basic algebra
22:12:26 <djahandarie> rwbarton, there's going to be a constant factor depending on your units/hardware/etc, but there is definitely a tree sitting behind things, and we can pinpoint that _part_ of the constant factor. That is what I'm asking for.
22:12:36 <rwbarton> it's totally irrelevant though.
22:12:47 <rwbarton> I can group two levels of nodes into a single "supernode" and square my branching factor.
22:13:00 <tgeeky> rwbarton: so you have some data structure that is treelike, and where each node can have a varying number of children, but that number must be among [1,4,9,29,42].
22:13:02 <rwbarton> Then there is a larger constant factor to process all the possible types of supernodes.
22:13:11 <tgeeky> what is the average complexity of that?
22:13:33 <shergill> djahandarie: you *can* state the performance is O(log_2 n) if it's O(log_50000 n)
22:13:44 <tgeeky> rwbarton: I don't mean to ask you to calculate it, but if that's the kind of question that works?
22:13:59 <djahandarie> shergill, I critically dropped the big-O when I said that.
22:14:46 <djahandarie> rwbarton, I don't see why it's irrelevant. It provides insight to how the library actually works.
22:15:17 <rwbarton> Oh, that's not what I thought you were asking about.
22:15:22 <shergill> djahandarie: the log should be base 2. but there would be other added costs which would probably influence the constant factor. profile it?
22:15:42 <tgeeky> djahandarie: if he had said the answer was between 65 and 63? what would that mean? :/
22:15:46 <shergill> /s/would/might
22:15:50 <tgeeky> except the other way around
22:16:08 <rwbarton> Though to be fair, your question was a lot more vague than how I interpreted it
22:16:45 <tgeeky> I feel like I've gotten djahandarie in trouble by asking stupid questions :o
22:17:32 <rwbarton> I just misunderstood and thought djahandarie was asking about performance in genereal
22:17:33 <djahandarie> Don't worry, I can escape any bind. I don't fear the IO.
22:18:57 <djahandarie> I think my puns may be getting too unclear.
22:20:36 <djahandarie> At least I'm not at the Conor McBride level.
22:21:54 <dolio> Even without big-O, you can write the answer in any base you want, of course.
22:22:39 <dolio> Because if the function takes C * log_b n steps, then you can also say it takes D * log_c n steps.
22:22:46 <dolio> Where C and D are related in the obvious way.
22:22:46 <djahandarie> Right.
22:23:39 <djahandarie> I really should have just said "branching factor" to avoid this whole mess.
22:29:26 <nyingen> @quote
22:29:26 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:29:33 <nyingen> @quote
22:29:34 <lambdabot> SAHChandler says: I noticed my left hand stays still at the keyboard, with the my right hand moving all over,
22:29:54 <augur> ahahaha
22:30:08 <augur> <camccann> Haskell shares many of Lisp's best features. Not being Java, for instance.
22:34:04 <Axman6> @unpl foldl (liftM2 (.) (++) (((return. liftM2 (++) head (take 1. last)).). map. (!!)))
22:34:05 <lambdabot> foldl ((++) >>= \ b -> (\ q ac -> return ((head >>= \ j -> (\ w -> take 1 (last w)) >>= \ i -> return (j ++ i)) (map ((!!) q) ac))) >>= \ a -> return (\ h -> b (a h)))
22:34:09 <Axman6> ha
22:36:30 <DanBurton> ew
22:37:11 <Enigmagic> code that should not be written
22:38:25 <shergill> heh@ cmccann's quote
22:38:48 <ocaml> > sizeOf nullPtr
22:38:49 <lambdabot>   Not in scope: `sizeOf'Not in scope: `nullPtr'
22:39:41 <ocaml> sizeOf nullPtr = 8 ? not 0? is there any function like isPtrNull :: Ptr a -> bool?
22:43:26 <Axman6> why would sizeOf nullPtr return 0? it'a a pointer, so it'll either be size 4 or 8 on a 32 or 64 bit system
22:43:46 <Axman6> ocaml: you can probably use castPtr x == nullPtr
22:43:59 <Axman6> (or maybe even just nullPtr == x
22:44:21 <Axman6> @quote cmccann
22:44:21 <lambdabot> cmccann says: in ContT, flow controls you
22:44:27 <Axman6> @quote cmccann
22:44:27 <lambdabot> cmccann says: someone should implement a dependently-typed unsafeCoerce in Agda, you'd have to provide a proof that the coercion is invalid
22:44:36 <Axman6> @quote cmccann
22:44:36 <lambdabot> cmccann says: it's sort of a rule of thumb in computer security that doing anything interesting in any way is probably a security hole somehow
22:44:58 * Axman6 heads to /msg to see if that quote's there, and adds it if not
22:46:05 <Axman6> @quote lisp.java
22:46:05 <lambdabot> No quotes match. My brain just exploded
22:46:19 <Axman6> @quote Lisp.Java
22:46:19 <lambdabot> No quotes match. Are you on drugs?
22:46:21 <Axman6> :(
22:46:37 <DanBurton> lambdabot insults are the best
22:47:11 <shergill> hah
22:51:20 <BMeph> Nice - "In Soviet imperative programming, values coerce YOU!" ;)
23:04:04 <wyvern> newb question (probably the first of many) -- how do I express a type signature that takes a list of any numeric type and returns a specific numeric type (e.g. Float)?
23:04:25 <sopvop> [Num] -> [Float]?
23:04:33 <sopvop> no
23:04:49 <wyvern> Can't use Num that way
23:04:52 <sopvop> (Num a) => [a] -> [Float]
23:05:05 <shergill> (Num a) => a -> [Float]
23:05:06 <shergill> um [a]
23:05:07 <shergill> yeah
23:05:23 <wyvern> well, I actually just want a scalar Float at the end but that still doesn't work
23:05:46 <sopvop> Maybe you try to make list of different types implementing Num?
23:06:00 <shachaf> @quote doesn't.work
23:06:01 <lambdabot> rwbarton says: Num works for Float/Double, it's Float/Double that doesn't work for Num
23:06:02 <wyvern> i would like to be able to operate on a list of ints or a list of floats equally
23:06:05 <mauke> wyvern: how does it fail?
23:06:12 <quicksilver> (Num a) => [a] -> Float is the correct type then
23:06:14 <shachaf> Hah! Not the quote I was looking for, but relevant nonetheless.
23:06:23 <quicksilver> maybe it's just you're having trouble writing the function with that type.
23:06:39 <wyvern> shachaf: sorry, i should have known better ;)
23:06:41 <wyvern> paste forthcoming.
23:06:58 <quicksilver> @type let example :: Num a => [a] -> Float; example = realToFrac . sum
23:06:59 <lambdabot> <no location info>:
23:06:59 <lambdabot>     not an expression: `let example :: Num a => [a] -> Float; example = realToFrac . sum'
23:07:04 <quicksilver> @type let example :: Num a => [a] -> Float; example = realToFrac . sum in example
23:07:05 <lambdabot>     Could not deduce (Real a) from the context (Num a)
23:07:05 <lambdabot>       arising from a use of `realToFrac' at <interactive>:1:48-57
23:07:05 <lambdabot>     Possible fix:
23:07:19 <quicksilver> it's quite hard to make something that works for all numbers in fact :)
23:07:34 <shachaf> Yes. What does that function mean for complex numbers?
23:07:40 <quicksilver> @type let example :: Real a => [a] -> Float; example = realToFrac . sum in example
23:07:41 <lambdabot> forall a. (Real a) => [a] -> Float
23:07:49 <quicksilver> easier if you restrict to Real.
23:09:11 <shergill> quicksilver: that function wouldn't have made sense for general complex numbers
23:09:28 <wyvern> It may be that I'm doing something else retarded. Like I said, newbie. :) http://pastie.org/3502239
23:09:41 <mauke> wyvern: your type is wrong
23:09:48 <mauke> also precedence
23:09:49 <wyvern> Probably. :)
23:10:12 <mauke> :t \x -> sum x / fromIntegral (length x)
23:10:13 <lambdabot> forall a. (Fractional a) => [a] -> a
23:10:17 <mauke> ^ correct type
23:10:19 <wyvern> Can you help me understand what I'm doing wrong... I'm literally 20 minutes into learning haskell
23:10:37 <mauke> wyvern: first off, you're trying to call fromIntegral with two arguments, length and x
23:10:42 <shergill> lambdabot: tell wyvern about lyah
23:10:51 <mauke> that's fixed by adding ( )
23:11:22 <mauke> wyvern: second, you're trying to convince the compiler that you can add up a list of any type of number and get a Float as a result
23:11:29 <mauke> that's simply not true
23:11:40 <shergill> oh different bot
23:11:44 <shergill> um
23:11:45 <wyvern> okay. I guess I don't understand exactly what Num implies. What does the Num type mean?
23:11:47 <shergill> @where lyah
23:11:48 <lambdabot> http://www.learnyouahaskell.com/
23:11:54 <mauke> @src Num
23:11:54 <lambdabot> class  (Eq a, Show a) => Num a  where
23:11:54 <lambdabot>     (+), (-), (*)           :: a -> a -> a
23:11:55 <lambdabot>     negate, abs, signum     :: a -> a
23:11:55 <lambdabot>     fromInteger             :: Integer -> a
23:12:03 <shachaf> wyvern: Num isn't a type.
23:12:04 <mauke> wyvern: ^ these are the operations supported by types in Num
23:12:11 <shergill> wyvern: an aside, but that book is good for beginners
23:12:19 <wyvern> shergill: noted.
23:12:25 <shachaf> The type class Num doesn't mean a whole lot, honestly.
23:12:31 <shachaf> @instances Num
23:12:31 <lambdabot> Double, Float, Int, Integer
23:12:36 <mauke> well, it does mean that 'sum x' is valid
23:12:43 <mauke> you can add up all elements
23:12:45 <shachaf> Yes.
23:12:49 <mauke> but the result will be of type a, not Float
23:13:39 <wyvern> Hm. What's up with Int vs Integer?
23:13:55 <mauke> wyvern: Int is bounded
23:14:03 <wyvern> got it.
23:14:09 <wyvern> 64bit or hwdep or what?
23:14:27 <BMeph> wyvern: Yes. ;)
23:14:31 <wyvern> I see :)
23:14:32 <mauke> I think the report requires at least 30 bits for Int
23:14:41 <mauke> in ghc it's the native int type
23:14:51 <mauke> (32 or 64 bits)
23:15:30 <wyvern> Okay so, to wrap this up then. What numeric type *should* I be claiming the input list's entries are?
23:15:58 <wyvern> Let's say I want to do integral numbers. "Int a" doesn't work because that's a constructor, right?
23:16:01 <mauke> er, depends on the results you want
23:16:33 <mauke> Int a doesn't work because that's a kind error
23:16:37 <mauke> Int takes no arguments
23:16:45 <wyvern> Oh, right.
23:16:52 <mauke> but there's a class Integral
23:17:17 <mauke> so you could start with xmean :: (Integral a) => [a] -> ...
23:17:25 <mauke> what result type do you want?
23:17:33 <mzero> wyvern: why not just    mean :: [Float] -> Float
23:17:43 <mauke> because Float sucks
23:17:49 <mauke> at least use Double
23:17:52 <mzero> sure
23:18:06 <wyvern> (Integral a) => [a] causes the same errors as before
23:18:11 <mzero> just trying to find out why we're jumping to various generic versions
23:18:24 <pfn> wyvern, learning Haskell now are ya?
23:18:29 <wyvern> pfn: yep
23:18:56 <wyvern> I realized that type theory is interesting... just took a few years to recover from my brutal programming languages professor, I guess ;)
23:19:13 <mauke> wyvern: <mauke> so you could start with xmean :: (Integral a) => [a] -> ...  <mauke> what result type do you want?
23:19:23 <wyvern> I learned enough lisp to realize I didn't like it, so here I am
23:19:37 <pfn> indeed
23:19:58 <mzero> wyvern:  fromIntegral (sum x) / fromIntegral (length x)
23:20:06 <pfn> hanging out here improves my scala or something like that
23:20:23 <wyvern> heh. I learned scala about a year ago and never used it for anything.
23:20:27 <mzero> that'll work for     :: (Integral i) -> [i] -> Double   (or Float)
23:20:51 <pfn> wyvern, you use it in place of anywhere java would apply
23:21:04 <wyvern> pfn: I know you *can* do that
23:21:15 <wyvern> But for most of what I use java for, the java-ness doesn't get in the way.
23:21:28 <pfn> and for you, that should be everywhere because java is teh suck
23:21:29 <wyvern> Let's not rehash that argument, at least not here. :)
23:21:45 <pfn> java always gets in the way
23:22:15 <wyvern> mzero: okay, figuring out why the extra fromIntegral made all the types happy.
23:22:21 <wyvern> thank god for :t
23:23:09 <mzero> because there is no coercion     sum x    was of the same type as the elements of x    --- and you declared that as some type that was Integral   --- -whcih can't be used with   the /  function
23:23:49 <wyvern> OK.
23:24:10 <mzero> did that mean that made sense? ;-)
23:24:12 <shirt> how can i access a field from a c struct using peekByteOff in a portable way (without hardcoding the offset) ?
23:24:15 <wyvern> It mostly makes sense. :)
23:24:29 <mauke> shirt: you use a tool like hsc2hs
23:24:38 <mauke> or c2hs
23:25:21 <shirt> mauke: right, i mean without using an extra tool
23:25:24 <wyvern> fromIntegral is (coarsely) Integral -> Num. length is [a] -> Integral. sum is [Num] -> Num, which in this case was further specified as [Integral] -> Integral.
23:25:45 <mauke> shirt: you don't
23:26:01 <wyvern> is / defined as -> Num -> Num -> Num?
23:26:04 <wyvern> and why can't I :t / ?
23:26:25 <mauke> :t (/)
23:26:25 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:26:26 <shergill> wyvern: :t (/)
23:26:26 <mzero> :t (/)
23:26:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:26:29 <wyvern> ah
23:26:33 <mauke> > (+) 2 2
23:26:34 <lambdabot>   4
23:26:34 <shergill> hah
23:26:38 <mauke> behold!
23:26:49 <wyvern> ah, so () takes an infix to a prefix?
23:27:02 <pfn> symbolic functions
23:27:09 <shergill> yep, and backticks the other way round
23:27:12 <wyvern> got it.
23:27:19 <pfn> must be surrounded be ()
23:27:21 <mzero> well.... to be technical,   () takes an operator and makes it a normal identifier
23:27:37 <mzero> whereas  ` `  takes an identifier and makes it an operator
23:27:50 <wyvern> operator <=> infix, identifier <=> prefix?
23:27:51 * hackagebot authenticate-oauth 1.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.1 (HiromiIshii)
23:28:07 <mauke> wyvern: pretty much
23:28:27 <wyvern> Okay. so the fromIntegrals took the Integral types to Fractionals?
23:28:30 <mzero> identifier is not quote prefix - as a "prefix operator" in most grammar systems implies that it *must* precede something
23:28:36 <mauke> :t fromIntegral
23:28:37 <lambdabot> forall a b. (Integral a, Num b) => a -> b
23:28:42 <mzero> where as    (+)   is a perfectly decent thing on its own
23:28:46 <wyvern> sure
23:29:13 <qiqi> hey guys, i cannot understand that in using callCC with \k->blabla, whenever you do something like k 1, then the return 1 or like that follows doesn't matter. is there a tutorial that elaborates on this "escaping"?
23:29:18 <wyvern> Yeah I guess I'm just wondering where the type system steps in to make the Nums into Fractionals.
23:29:31 <mzero> and similarly, operators aren't perhaps as   "infix" as they are in most other grammars
23:29:34 <mzero> consider
23:29:47 <mzero> > map (*7) [1..10]
23:29:48 <lambdabot>   [7,14,21,28,35,42,49,56,63,70]
23:29:48 <mauke> qiqi: any introduction to continuations should talk about that
23:30:01 <wyvern> right, i got that.
23:30:04 <idnar> @src ap
23:30:05 <lambdabot> ap = liftM2 id
23:30:12 <wyvern> so it's just a matter of the default parsing rules whether the name of a function is symbolic or alphabetic.
23:30:15 <mzero> that * in (*7) is an operator, but it certaiinly isn't in-between two things)
23:30:24 <idnar> @src [] <*>
23:30:25 <lambdabot> Source not found. That's something I cannot allow to happen.
23:30:36 <mzero> wyvern: correct
23:30:42 <qiqi> mauke: any recommendation for a decent and detailed intro? the ones I found online only say that it escapes, but doesn't really explain why
23:30:53 <mauke> qiqi: well, what do you mean by "why"?
23:30:54 <wyvern> all right thanks a lot for the help. /me bed &.
23:31:02 <mauke> qiqi: one answer is: because that's what continuations do
23:32:51 * hackagebot yesod-auth-oauth 0.8.1 - OAuth Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-oauth-0.8.1 (HiromiIshii)
23:33:22 <qiqi> my probably wrong theory is: if after you do k 1, you do return 1, then whatever outcome of k 1 is fed into return 1, which then calls the remaining computation upon 1
23:33:56 <mauke> there is no "after k 1"
23:34:02 <mauke> k is the current continuation
23:34:45 <qiqi> syntactically, it is blabla >>= k 1 >> return 2 right? I guess I 'm confused about how the last >> works
23:35:33 <mauke> oh, you can look at the source code
23:36:07 <qiqi> source code of callCC?
23:36:08 <mauke> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/src/Control-Monad-Trans-Cont.html#Cont
23:36:24 <mauke> source code of >>/>>=
23:36:27 <mauke> and callCC
23:36:42 <qiqi> i think i understand both..
23:37:33 <qiqi> actually i've been reading a lot, but haven't done any toying around with ghc/ghci. is there anyway that i can see all "intermediate" steps of what's going on? so that if I get into such problems again, I can just go dig up what really happens?
23:42:38 <mikeplus64> >((>>=(:[]))<=<(>>=(:[]))) [[1],[2,4,10],[3,4,5]]
23:42:44 <mikeplus64> > ((>>=(:[]))<=<(>>=(:[]))) [[1],[2,4,10],[3,4,5]]
23:42:45 <lambdabot>   [1,2,4,10,3,4,5]
23:44:04 <shirt> foreign import ccall "a b" b :: Foo
23:44:12 <shirt> i can't find any docs for what the "a" is used for
23:44:37 <mauke> @where ffi
23:44:38 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
23:45:06 <mauke> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-150004
23:47:16 <shirt> mauke: thanks
23:47:52 * hackagebot persistent-template 0.8.1.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.8.1.2 (MichaelSnoyman)
23:57:15 <mikeplus64> (\k s m p -> modifyIORef worldRef (inputHandler k s m p)
23:57:16 <mikeplus64> )
23:57:27 <mikeplus64> is there some way to make that less... lambda-y?
23:57:47 <mauke> @unpl \k s m p -> modifyIORef worldRef (inputHandler k s m p)
23:57:48 <geekosaur> @pl \k s m p -> modifyIORef worldRef (inputHandler k s m p)
23:57:48 <lambdabot> \ k s m p -> modifyIORef worldRef (inputHandler k s m p)
23:57:48 <lambdabot> (((modifyIORef worldRef .) .) .) . inputHandler
23:58:06 <mikeplus64> looks like I'll use the lambda ;)
23:58:16 <geekosaur> (be careful what you ask for :)
23:58:31 <randomclown> what is the best way to implement a z-buffer in haskell
23:58:35 <randomclown> intmap is too slow for me
23:58:40 <geekosaur> that's the usual lesson of pointfree in my experience
23:59:07 <randomclown> #join math
23:59:25 <randomclown> heh misfire
23:59:26 <shirt> randomclown: i think you need a mutable array
23:59:37 <mzero> randomclown: Data.Vector or perhaps Data.Vector.Unboxed
