00:41:02 <Zamarok> Is the source code that defines Haskell lists written in Haskell? I'd like to look at it
00:47:26 <ChristianS> Zamarok: you mean the (:) operator? i suspect it must be built in, since it's so fundamental...
00:47:59 <Lemmih> It is both, actually.
00:48:07 <Lemmih> One moment, I'll find it.
00:48:53 <flebron> So question. I understand how the Haskell Functor relates to a categorical functor. I also have heard the notion of a monad being a monoid in the category of endofunctors. How does the (fmap, return, join) definition map to the category theoretical notion of a monoid in the category of endofunctors of Hask?
00:49:46 <Zamarok> ChristianS: I'm not sure, but I suppose that's all you really need to define lists anyway
00:50:38 <Lemmih> Zamarok: http://darcs.haskell.org/packages/ghc-prim/GHC/Types.hs
00:51:01 <shachaf> Zamarok: In GHC it is. That code isn't valid Haskell 98, though.
00:51:25 <shachaf> Zamarok: (But that's only because of the syntax -- you could easily define your own list-equivalent.)
00:53:32 <flebron> (Although I'm not yet comfortable with the notion of tensor product, should I in order to understand this relation?)
00:55:48 <ChristianS> shachaf: true, thanks.
00:59:30 <shergill> what does # in a constructor denote? eg. data Char = C# Char#
00:59:48 <Lemmih> It's part of the name.
01:00:12 <shergill> Lemmih: right, i was just wondering if that convention implied something
01:00:28 <Lemmih> It implies unboxing.
01:00:54 <shergill> ok
01:13:27 <ChristianS> @src []
01:13:28 <lambdabot> data [] a = [] | a : [a]
01:14:16 <ChristianS> Zamarok: oh, lambdabot actually knows how lists are defined ^^
01:16:15 * hackagebot th-build 0.1.0.0 - More convenient construction of TH ASTs  http://hackage.haskell.org/package/th-build-0.1.0.0 (DanielSchuessler)
01:26:15 * hackagebot CV 0.3.5.3 - OpenCV based machine vision library  http://hackage.haskell.org/package/CV-0.3.5.3 (VilleTirronen)
01:36:16 * hackagebot type-digits 0.1.0.2 - Arbitrary-base type-level digits  http://hackage.haskell.org/package/type-digits-0.1.0.2 (NicolasFrisby)
01:36:18 * hackagebot yoko 0.3 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-0.3 (NicolasFrisby)
01:46:16 * hackagebot yoko 0.3.0.1 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-0.3.0.1 (NicolasFrisby)
01:54:26 <gregATio> i'm calling a haskell library from within a do block and getting the result out with a <- arrow, however this causing a problem as the result isnt the same type as returned from my function
01:54:58 <ben> What are the types involved?
01:55:05 <gregATio> how can i make the compiler happy?
01:55:51 <gregATio> IO Bool is returned from the call to library and I want to make the function return Either String String
01:56:19 <gregATio> its a problem from RWH
01:56:21 <ben> That'll be IO (Either String String) then ultimately?
01:56:26 <gregATio> yyes
01:56:33 <ben> That should do fine, really
01:56:39 <gregATio> ah i see
01:56:44 <Lemmih> gregATio: Use if-then-else on the boolean?
01:57:00 <gregATio> yes i tried that lemmih
01:57:26 <mroman> you might need to use do in if too
01:57:29 <gregATio> but even if the last return value in the do block is the right type
01:57:38 <mroman> code?
01:57:55 <gregATio> haskell doesnt like it if you pull out intermediate values that are not the right type with a <- in the do block
01:58:22 <ben> > let someIOBool :: IO Bool; someIOBool = return True; myFunction :: IO (Either String String); myFunction = do b <- someIOBool; if b then return $ Right "hooray" else return $ Left "welp" in myFunction
01:58:23 <lambdabot>   <IO (Either [Char] [Char])>
02:00:09 <gregATio> ah i see mroman but the if is determined by the contents of the do
02:00:43 <gregATio> thanks ben
02:01:00 <Lemmih> gregATio: It would be a lot easier to understand what you're trying to do if you showed us your code.
02:01:14 <gregATio> one other quick question what is the tool to use to suggest a type for a function
02:01:16 * hackagebot ghc-heap-view 0.1 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.1 (JoachimBreitner)
02:01:18 * hackagebot xturtle 0.1.6 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.6 (YoshikuniJujo)
02:01:48 <mroman> gregATio: ghci probably
02:01:53 <mroman> and :t
02:02:01 <mroman> or what do you exactly mean by "suggest a type"?
02:02:22 <ChristianS> gregATio: you can call ghc with -Wall, than it will complain about all top-level functions that don't have a type definition, and show the type definition it has figured out.
02:02:42 <ChristianS> (it will also print lots of other useful warnings which you should fix.)
02:44:21 <astor> does anyone use cabal-test-hunit? it is referenced from the Distribution.TestSuite documentation but it isn't on hackage and seems to be buried in a darcs repo somewhere http://hackage.haskell.org/packages/archive/Cabal/1.14.0/doc/html/Distribution-TestSuite.html
03:07:33 <hpaste> astor pasted “What does [| test|] mean?” at http://hpaste.org/65230
03:08:46 <astor> I get a parse error from ghc, so I wonder what it means - an empty quasi-quoter?
03:24:02 <Lemmih> astor: It's Template Haskell.
03:26:19 <astor> Lemmih: should't there be between the '[' and the '|'?
03:28:39 <Lemmih> astor: Nope. [| x |] is an expression splice of type 'Q Exp'.
03:29:39 <astor> Lemmih: ok. thx.
03:36:03 <liyang> That's a quote. Splices look like $… or $(…).
03:38:28 <mm_freak> what kind of quote is that?  it's missing the quoter
03:38:39 <mm_freak> i'd expect [quoter| … |]
03:39:12 <liyang> That's what quotes looked like before they became quasy.
03:39:26 <liyang> They quote Haskell expressions.
03:39:33 <mm_freak> ah, ok
03:39:43 <quicksilver> TH has expression quotations as well as splices
03:41:19 <quicksilver> $([| x |]) is x, I think.
03:41:51 <int-e> yep
03:41:55 <liyang> There's [t| … |] , [d| … |] and [p| … |] for types, declarations and patterns too.
03:42:13 <liyang> But you can't splice patterns, because no one got around to implementing it.
03:45:05 <quicksilver> althoguh you can use a quasiquote in pattern context
03:45:19 <quicksilver> isn't that effectively splicing a pattern?
03:49:07 <b0fh_ua> Hi all! Given String, how can I determine if it can be read as Int?
03:49:20 <liyang> Good point. The last time I tried to use $(e :: PatQ) I was sure I got an error...
03:49:21 <Botje> use the reads function
03:49:49 <Botje> > reads "x" :: [(Int, String)]
03:49:50 <lambdabot>   []
03:49:53 <Botje> > reads "42" :: [(Int, String)]
03:49:54 <lambdabot>   [(42,"")]
03:50:25 <ben> > reads "42 x" :: [(Int, String)]
03:50:26 <lambdabot>   [(42," x")]
03:50:27 <nexx> reads "4x2" :: [(Int, String)]
03:50:39 <ben> What do I gotta do to get more than one entry in that list?
03:50:40 <nexx> > reads "4x2" :: [(Int, String)]
03:50:41 <lambdabot>   [(4,"x2")]
03:51:59 <ion> > (listToMaybe . map fst . filter (null . snd) . reads) "42" :: Maybe Integer
03:52:01 <lambdabot>   Just 42
03:53:07 <b0fh_ua> thanks!
03:56:56 <dmwit> ben: The Read instance for all the built-in types return singleton lists only.
03:57:00 <dmwit> (Or empty lists, of course.)
04:01:07 <dmwit> > listToMaybe [x | (x, "") <- reads "42"] :: Maybe Integer
04:01:08 <lambdabot>   Just 42
04:01:17 <dmwit> List comprehensions make that so, so much clearer.
04:01:28 <ben> nice
04:01:30 <ion> aye
04:02:48 <taruti> defining a readM :: (Read a, Monad m) => String -> m a, can also be useful
04:02:59 <ion> Let’s see what pl comes up with (given that it doesn’t understand list comprehensions). :-D
04:03:10 <ion> @pl \s -> listToMaybe [x | (x, "") <- reads s]
04:03:10 <lambdabot> listToMaybe . return . ((x | (x, [])) <-) . reads
04:03:23 <dmwit> ((x | (x, [])) <-)
04:03:24 <dmwit> ...yup
04:04:04 <ion> (x | (x, "") <-) would be kind of cool.
04:04:56 <ion> [x | (x, "") <-]
04:07:10 <shachaf> @. pl undo \s -> listToMaybe [x | (x, "") <- reads s]
04:07:10 <lambdabot> (line 1, column 48):
04:07:10 <lambdabot> unexpected "{"
04:07:11 <lambdabot> expecting variable, "(", operator or ")"
04:07:16 <shachaf> @undo \s -> listToMaybe [x | (x, "") <- reads s]
04:07:16 <lambdabot> \ s -> listToMaybe concatMap (\ a -> case a of { (x, "") -> [x]; _ -> []}) reads s
04:07:49 <ben> I'm still waiting for lambda-case :(
04:09:24 <quicksilver> > [x | (x, "") <- reads "42"] :: Maybe Integer
04:09:25 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
04:09:25 <lambdabot>                             ...
04:11:26 * hackagebot couchdb-conduit 0.7.6 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.7.6 (AlexanderDorofeev)
04:17:09 <xyproto> Can lambdabot create irc logs? I couldn't find it on the feature list at http://www.haskell.org/haskellwiki/Lambdabot
04:24:06 <Amagineer> Hey, I'm fighting with package stuff on my system. I'm running arch and even though my (rebuilt locally for xinerama support) X11 (1.5.0.1) package is installed (and acknowledged by ghc-pkg) I get an error claiming that X11-1.5.0.1 doesn't exist. Can anyone lend a hand?
04:31:06 <merijn> I can't help but observe that Arch users tend to have a disproportionate number of problems getting programs to work on their system :>
04:31:45 <linduxed> merijn: doesn't mean we like our systems any less ;-)
04:33:06 <merijn> linduxed: No, but it does mean Arch users represent a disproportionate use of open source's most limit resource, volunteer time
04:33:22 <linduxed> merijn: naaah, it's not that bad
04:33:33 <gienah> arch is neat, I liked how it used to have about 2000 haskell packages in AUR that were compiled from the source code, that probably would have made it easier to build X11 with xinerama support
04:33:39 <linduxed> merijn: i don't get that impression at least
04:34:07 <gienah> and also it would be easier for other developers to help on arch if the haskell stuff was built from the source code like it used to be
04:34:17 <merijn> linduxed: Install issues seem to be at a 10 : 1 ratio arch : everything else (maybe worse)
04:34:32 * gienah is a gentoo dev so kind of biased to building stuff from source code
04:34:38 <Amagineer> recently, or overall?
04:35:06 <quicksilver> well arch's recent decision to package 7.4 has upped the problem count here
04:35:13 <quicksilver> I"m not sure that's long-term typical though
04:35:21 <merijn> I'm biased to building stuff from source too, I'm come from a FreeBSD background. Only difference is that I'm used to a stable environment where you can get and keep stuff working too :p
04:35:21 <linduxed> merijn: well that's because there are a lot of people who jump into arch because they've heard about it and want to try it out, but aren't ready for it
04:35:38 <linduxed> merijn: not to mention all the people who just refuse to search the VERY extensive wiki
04:35:54 <merijn> But I should stop trolling linux users in here >.>
04:36:01 <linduxed> haha
04:36:05 <linduxed> you're welcome to
04:36:37 <merijn> quicksilver: As far as I know Arch is the worst of the "bleeding edge - off cliff" crowd from linux, so I think that's typical. I could be wrong, though
04:36:44 <Amagineer> I'm still kind of confused, ghc-pkg says I've got X11-1.5.0.1 while the xmonad install seems to claim otherwise
04:37:17 <Amagineer> Am I doing something stupid here?
04:37:18 <linduxed> merijn: the worst, or at least one of them. if upstream has a new version, that's what arch has
04:37:50 <Amagineer> If so could you folks point me to the documentation I should be reading through?
04:38:26 <merijn> Amagineer: afaik the main problem is that Arch is using GHC 7.4, which is not well supported by the haskell ecosystem yet
04:39:46 <Amagineer> Eh? The odd thing is, it worked when I used the X11 package from the [haskell] repo, but the one I built on my machine (using their PKGBUILD from HABS) seems to be doing something fiddly
04:40:18 <Amagineer> Again, unless I'm just doing something idiotic, and there's a ghc-pkg thing I should be doing
04:42:32 <gienah> Amagineer: my guess is that if you build haskell stuff with PKGBUILD from HABS, then you will need to build all its reverse dependencies with PKGBUILD from HABS, until ghc-pkg check says that everything is ok
04:43:51 <Amagineer> Bleh
04:43:54 <dmwit> Amagineer: Hi!
04:43:58 * Amagineer builds xmonad
04:44:01 <dmwit> Amagineer: X11 maintainer and xmonad hacker here.
04:44:21 <gienah> Amagineer: which in the case of x11 is probably something like: x11-xft xmobar xmonad xmonad-contrib
04:44:23 <dmwit> Amagineer: Are you using X11 from hackage or git? Are you using xmonad from hackage or darcs?
04:44:55 <dmwit> Amagineer: The dependencies are in flux a bit right now because we're moving code from xmonad(-contrib) to X11.
04:45:01 <Amagineer> Looks like it's from hackage
04:45:11 <dmwit> So the build systems can get a bit confused if you aren't careful. (We're trying to fix things.)
04:45:17 <flux> so when is xmonad going to support Wayland?-)
04:45:24 <dmwit> flux: Get hacking! ;-)
04:45:42 <Amagineer> Yeah, from hackage for both
04:45:43 <dmwit> Amagineer: Okay. And can you bring me up to speed? I just joined. What's the question/problem you have?
04:47:25 <dmwit> Ah, looking back, it looks like when you try to build xmonad it asks you to install X11, even though it's already installed.
04:47:36 <Amagineer> Arch did a thing with haskell packages so I switched over the the 3rd party [haskell] repo, only to discover that their X11 package has no xinerama support. To remedy this I build the X11 package on my system (using their PKGBUILD) and installed it, only to discover that upon the installation of xmonad the installed X11 version isn't recognized even though the version number's the same
04:47:40 <dmwit> Are you perhaps trying to build xmonad for a global install, but built X11 for a local install?
04:48:01 <n3hima> arch has been playing about with their haskell packages a lot recently haven't they
04:48:13 <dmwit> Check that "ghc-pkg list X11 --global" still shows that it's installed.
04:48:17 <Amagineer> Yeah, they broke everything.. last week?
04:48:22 * gienah thinks since its arch that they are both global
04:48:37 <dmwit> gienah: If he's building xmonad by hand, that's not at all guaranteed.
04:48:39 <Amagineer> Yup, spits out X11-1.5.0.1
04:48:41 <n3hima> Amagineer: yeah I uninstalled all of my AUR haskell packages and managed to upgrade
04:48:53 <Amagineer> I'm using a PKGBUILD to build it "by hand"
04:49:00 <dmwit> Amagineer: Okay. And how are you trying to build xmonad? What's the command, and what's the error?
04:49:00 <n3hima> a lot of the AUR packages are orphans though so nobody's bothered to upgrade them
04:49:22 <dmwit> ?hpaste the error for bonus points
04:49:22 <lambdabot> Haskell pastebin: http://hpaste.org/
04:49:29 * gienah thinks since is a PKGBUILD its global and that x11-xft should be built before xmonad
04:49:31 <Amagineer> Well, I'm trying to install it from a binary the one in [haskell]
04:49:57 <dmwit> That's unlikely to help; GHC-built binaries are statically linked.
04:50:34 <hpaste> Amagineer pasted “X11/Xmonad” at http://hpaste.org/65233
04:50:50 <Amagineer> The actual error's on the last line
04:51:23 <dmwit> Yep, you'll need to build xmonad yourself.
04:51:26 <dmwit> Don't worry, it's pretty easy.
04:51:34 <Amagineer> Doing it right now
04:51:39 <dmwit> Just "cabal install xmonad", or, if you're into that kind of thing, "sudo cabal install xmonad --global".
04:52:01 <dmwit> You might want to add "--constraint 'X11 installed'" to make sure it doesn't try to rebuild X11.
04:52:09 <dmwit> But that should be no problem in this case.
04:52:17 <Amagineer> I'm going to try fiddling with the PKGBUILD stuff first, since that should fix it
04:52:29 <Amagineer> And maybe I'll switch to a more sane distro
04:52:34 <dmwit> I can explain the error anyway, if you care.
04:52:44 <Amagineer> Sure, let's hear it
04:52:56 <dmwit> GHC includes in its package versioning not only the package name and version, but also a hash of the library.
04:53:10 <gienah> Amagineer: yes I like the PKGBUILD approach, if you do: sudo cabal install xmonad --global" # and it updates some low level haskell package then it will break lots of stuff
04:53:10 <n3hima> Amagineer: if you just change the ghc version number in the PKGBUILDs and get rid of the deps that the new ghc replaces, then everything should work
04:53:33 <dmwit> This is because with the current ABI, it's very important that a program linked against library foo is used with exactly library foo.
04:54:02 <dmwit> So, that error is telling you that something changed (namely, you built with Xinerama support) between the hash it was expecting and the hash it saw.
04:54:38 <Amagineer> Ah, alright, that makes sense
04:54:51 <Amagineer> Also, building xmonad on this machine seems to have fixed it
04:55:00 <Amagineer> Thanks for the help
04:56:04 <b0fh_ua> with HappStack how do I convert result of function which makes IO request, into HappStack.Server.Response.ToMessage, so I could use it with "ok" response?
04:58:54 <dmwit> b0fh_ua: What classes is ToMessage an instance of?
04:58:59 <dmwit> (Where's the documentation?)
04:59:26 <b0fh_ua> dmwit: http://happstack.com/docs/6.0.0/happstack-server/Happstack-Server-Response.html
05:00:19 <siracusa> What does "X {..}" denote in a record pattern? Is it the same as "X {}"?
05:01:02 <dmwit> b0fh_ua: Um. ToMessage isn't a type.
05:02:19 <dmwit> siracusa: I think that it brings into scope one variable for each field in the X record.
05:02:45 <siracusa> With the same name as the field?
05:02:48 <dmwit> yes
05:02:53 <siracusa> Ah, thanks!
05:03:22 <dmwit> siracusa: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html#record-puns
05:05:52 <siracusa> Ah, the it's the RecordWildCards extension
05:06:22 <quicksilver> nasty extension that one
05:06:27 <rostayob> haddock doesn't support comments for constructor arguments right?
05:06:38 <quicksilver> shadowing identifiers with differently-typed identifiers is an impedance mismatch
05:06:43 <quicksilver> can make your neurons overheat.
06:09:28 <hpaste> dzhus pasted “Is this just me or MissingH has broken deps?” at http://hpaste.org/65241
06:11:34 * hackagebot secdh 0.2 - SECDH Machine Simulator  http://hackage.haskell.org/package/secdh-0.2 (PeterGavin)
06:11:51 <dmwit> dzhus: Perhaps you meant "-f -buildtests" instead of "--disable-tests"?
06:13:34 <dmwit> Anyway, you might consider modifying the .cabal file to relax the QuickCheck constraint. If it successfully compiles with the relaxed constraint, you're probably fine -- and you should send the MissingH maintainer a patch. =)
06:14:11 <dzhus> dmwit: it happens regardless of tests flag; I'll try
06:14:54 <gienah> dzhus: I think its a cabal 1.8 bug which pulls depends of testpack even for 'Buildable: false' target
06:14:56 <dmwit> Well, I just looked at the cabal file, and it only depends on QuickCheck at all when the "buildtests" flag is true.
06:15:16 <dmwit> ...and buildtests defaults to False.
06:15:50 <dzhus> I'm on cabal 1.14
06:16:40 <dmwit> dzhus: gienah probably means cabal-install-1.8
06:16:50 <dmwit> dzhus: Check "cabal --version".
06:17:05 <dzhus> 0.13.3 && 0.14
06:17:19 <dmwit> One of those isn't right.
06:17:20 * gienah does not know then as I don't use cabal-install (has missingh installed but not with cabal-install)
06:17:55 <dzhus> dmwit: yes :) cabal-install 0.13.3 and cabal 1.14.0
06:18:12 <dmwit> That's what I'm using. I can't reproduce your problem.
06:18:24 <dmwit> I don't have any QuickCheck installed, and --dry-run doesn't report that it will attempt to install one.
06:20:40 <dmwit> dzhus: Perhaps you should pull the latest cabal-install. You're running the bleeding edge, and sometimes the bleeding edge... well... bleeds a little. =P
06:22:23 <dzhus> dmwit: oh yes
06:25:51 <td123> there's cabal-install-ghc74 :)
06:26:47 <dzhus> td123: what for? except for missingh problems, 0.13.3 worked smoothly with my 7.4.1 install
06:27:32 <dmwit> I'm puzzled. What problem is cabal-install-ghc74 solving?
06:28:08 <td123> afaik, cabal-install doesn't have a version in hackage that works with ghc74
06:28:24 <quicksilver> the problem that "there is too little confusion w.r.t. cabal-install"
06:28:30 <dzhus> lol
06:29:12 <dmwit> Huh. darcs cabal-install is on 0.13, but there's no 0.12 on Hackage.
06:30:06 <td123> also cabal-install that ships with ghc doesn't work unmodified :P
06:31:29 <dzhus> i installed mah cabal from gentoo overlay
06:31:37 <dzhus> *cabal-install
06:31:53 <gienah> dzhus: then you could emerge dev-haskell/missingh
06:34:46 <td123> it would be nice if ghc provided a flag to automatically install the bundled cabal-install
06:36:33 <pozic> It is possible to join two acid-state structures (cf. joining two tables in SQL)?
06:36:35 * hackagebot persistent-mysql 0.8.3 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-0.8.3 (FelipeLessa)
06:40:34 <hpc> pozic: acid-state stores haskell data structures
06:40:51 <hpc> > join ["thing 1", "thing 2"] -- pretend these came from acid-state ;)
06:40:52 <lambdabot>   "thing 1thing 2"
06:42:18 <hpc> if the data structure you store is a tabley thing, there will be a join operation for that table type, but not necessarily from acid-state
06:43:10 <Jonno_FTW> hello
06:43:40 <Jonno_FTW> > [(x,y)|x<-[-3..3],y<-[-3..3], isInt (1/x - 1/y)]
06:43:41 <lambdabot>   Not in scope: `isInt'
06:44:39 <hpc> :t join ((==) `on` floor)
06:44:40 <lambdabot> forall a. (RealFrac a) => a -> Bool
06:45:09 <Jonno_FTW> > let isInr = x == fromInteger (round x) in  [(x,y)|x<-[-3..3],y<-[-3..3], isInt (1/x - 1/y)]
06:45:10 <lambdabot>   Not in scope: `isInt'
06:45:12 <hpc> > let isInt = join ((==) `on` floor) in isInt 1.0
06:45:13 <lambdabot>   True
06:45:16 <hpc> > let isInt = join ((==) `on` floor) in isInt 1.5
06:45:17 <lambdabot>   True
06:45:26 <hpc> oh, derp
06:45:35 <Jonno_FTW> > let isInr = x == fromInteger (round x) in  [(x,y)|x<-[-3..3],y<-[-3..3], isInr (1/x - 1/y)]
06:45:36 <hpc> > let isInt = ((==) <*> floor) in isInt 1.5
06:45:36 <lambdabot>   Couldn't match expected type `t -> GHC.Bool.Bool'
06:45:36 <lambdabot>         against inferred ...
06:45:37 <lambdabot>   Ambiguous type variable `t' in the constraints:
06:45:37 <lambdabot>    `GHC.Real.RealFrac t'
06:45:37 <lambdabot>   ...
06:45:44 <Jonno_FTW> what is wrong with my expression?
06:45:51 <hpc> Jonno_FTW: isInt doesn't exist
06:45:58 <Jonno_FTW> I defined it there in the let
06:46:48 <hpc> "let isInt = x ..." -- x is only in scope because lambdabot is magic
06:47:01 <hpc> "let isInt x = x ..." -- now it's taking x as a parameter
06:47:04 <hpc> > x
06:47:04 <osfameron> does Pandoc have any markup to prepare indexes with?
06:47:05 <lambdabot>   x
06:47:32 <hpc> > let isInt x = x == fromInteger (round x) in  [(x,y)|x<-[-3..3],y<-[-3..3], isInt (1/x - 1/y)]
06:47:33 <lambdabot>   [(-3.0,-3.0),(-3.0,0.0),(-2.0,-2.0),(-2.0,0.0),(-2.0,2.0),(-1.0,-1.0),(-1.0...
06:48:25 <hpc> > floor x
06:48:26 <lambdabot>   No instance for (GHC.Real.RealFrac SimpleReflect.Expr)
06:48:26 <lambdabot>    arising from a us...
06:48:41 <hpc> > x + y :: Expr -- this is what 'x' is in scope for, btw
06:48:42 <lambdabot>   x + y
06:49:00 <hpc> > foldr (*) 0 [x, y, z]
06:49:01 <lambdabot>   x * (y * (z * 0))
06:49:36 <Jonno_FTW> pl I see
06:49:40 <Jonno_FTW> *ok
06:49:47 <Jonno_FTW> I haven't written haskell in a while
06:50:03 <Jonno_FTW> and now I'm using it to solve my discrete math homework
06:50:11 <hpc> fun
06:52:44 <yan_> if i'm defining a few function defs for a pattern match, i can't leave one of them as partially applied, can i? ghc complains about diff length of arguments.. i.e. one is 'foo [] = 0' and another is 'foo = length'
06:52:59 <pozic> hpc: are there any such join operations?
06:53:28 <tromp__> yan: all defs must have same number of args
06:54:27 <yan_> tromp__: makes sense
06:56:37 * hackagebot persistent-mysql 0.8.4 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-0.8.4 (FelipeLessa)
06:59:23 <deech> Hi all, what is the best way of dealing with mutable state in Haskell when dealing with a impure library (eg. GTK)? Most calls end up in the IO monad and it feels like procedural programming. Is there a better way?
06:59:43 <dmwit> That is an area of active research.
06:59:56 <dmwit> There are about half a dozen FRP libraries on Hackage now; you might be interested in one of them.
07:00:15 <dmwit> There's also the "tangible variables" direction of research.
07:00:31 <dmwit> Practically, though, for now the best thing seems to be to write imperative code.
07:00:33 <deech> Would FRP be a good way of dealing with a non-gui library too?
07:00:58 <dmwit> It's entirely possible.
07:01:32 <earthy> yes. ISTR it being used for programming robots.
07:01:32 <deech> What about OOHaskell? I've gotten it to compile and written some toy examples but nothing more.
07:01:38 <dmwit> Depending on which particular library, the various iteratee/enumeratee packages may interest you as well.
07:02:07 <deech> earthy: Just googled for "ISTR haskell" and didn't come up with anything.
07:02:30 <dmwit> "ISTR" = "I seem to recall"
07:02:40 <deech> hah!
07:03:58 <deech> Thanks all for the pointers!
07:04:21 <earthy> see e.g. http://www.cs.nott.ac.uk/~nhn/ which has links to yampa and the robot simulator
07:08:51 <pozic> earthy: nobody on the planet is using Haskell FRP with robots at this point in time.
07:09:21 <pozic> One good reason for not using FRP is that despite its name, there is nothing reactive about FRP.
07:09:43 <pozic> Next!
07:11:10 <pozic> Look here for active work on Yampa: http://www.haskell.org/yampa
07:11:20 <pozic> (note the irony when you visit the link)
07:12:10 <dmwit> ?wiki yampa
07:12:10 <lambdabot> http://www.haskell.org/haskellwiki/yampa
07:13:15 <applicative> http://www.haskell.org/haskellwiki/Netwire is a yampa update
07:19:13 <etpace> hm... bit offtopic: How would I write "unionWith" in set builder notation? Ie, normal union but some operation + if an element is present in both sets
07:19:21 <etpace> or rather, key is present..
07:20:52 <t7> work just got me technet subscription :3
07:20:55 <ManateeLazyCat> Hi all. :)
07:21:22 <applicative> hi ManateeLazyCat!
07:21:33 <ManateeLazyCat> applicative: Hey, how are you? ;)
07:21:56 <applicative> okay. haven't seen you around.
07:22:22 <dmwit> etpace: {e | e \in X, e \notin Y} \cup {e | e \notin X, e \in Y} \cup {e + e | e \in X, e \in Y}
07:22:23 <ManateeLazyCat> applicative: Hehe, yes, busy on work.
07:22:23 <pozic> t7: aren't there giving those out for free then?
07:22:38 <dmwit> etpace: Though it's a bit weird that you want to do this on sets and not finite maps.
07:22:50 <t7> pozic: no lol, no one would buy anything
07:22:56 <applicative> ManateeLazyCat well i guess that is good.
07:23:14 <pozic> t7: my impression is that they are getting increasingly less relevant.
07:23:30 <t7> microsoft or technet?
07:23:43 <pozic> t7: isn't technet a microsoft initiative?
07:23:47 <roconnor> Someday I want to use dolio's callCC costrength function in a program: costrength f = callCC (\k -> Right $ map (either (k . Left) id) f)
07:23:49 <pozic> t7: microsoft.
07:23:57 <ManateeLazyCat> applicative: http://www.linuxdeepin.com/
07:24:00 <roconnor> @type \f -> callCC (\k -> Right $ map (either (k . Left) id) f)
07:24:01 <lambdabot>     Couldn't match expected type `Either a b'
07:24:01 <lambdabot>            against inferred type `[Either a1 b1]'
07:24:01 <lambdabot>       Expected type: Either a1 (Either a b)
07:24:13 <roconnor> :/
07:24:15 <t7> pozic: i hope so :) maybe then i wont have to fix windows boxes all day
07:24:30 <dmwit> roconnor: Did you mean "fmap" instead of "map"?
07:24:34 <Saizan> @type \f -> callCC (\k -> Right $ fmap (either (k . Left) id) f)
07:24:35 <lambdabot> forall b a a1. (MonadCont (Either a)) => Either a1 (Either a1 (Either a b)) -> Either a (Either a1 (Either a b))
07:24:35 <roconnor> @type \f -> callCC (\k -> Right $ fmap (either (k . Left) id) f)
07:24:36 <lambdabot> forall b a a1. (MonadCont (Either a)) => Either a1 (Either a1 (Either a b)) -> Either a (Either a1 (Either a b))
07:24:37 <ManateeLazyCat> applicative: I'm lead to developer many Linux desktop application to make it become usable to fighting Windows or Mac.
07:24:45 <ManateeLazyCat> applicative: But i missing Haskell time.
07:24:57 <roconnor> dmwit: hmm, that doesn't look right
07:25:21 <dmwit> roconnor: I can't fix your bugs, just spot probably type-correct massages. =P
07:25:27 <roconnor> :D
07:25:31 <roconnor> @type callCC
07:25:32 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
07:25:35 <applicative> ManateeLazyCat: I see it is a linux distribution focussed on ordinary Chinese users?
07:25:41 <roconnor> dmwit: I think some function applications should be binds
07:25:42 <cdh473> What am I doing wrong here? http://pastebin.com/j7CAatK7
07:25:44 <mauke> The paste j7CAatK7 has been copied to http://hpaste.org/65242
07:25:51 <ManateeLazyCat> applicative: We have English version.
07:26:00 <cdh473> I'm completely new to haskell by the way
07:26:10 <dmwit> chops_: You don't have an "else" clause.
07:26:13 <dmwit> err
07:26:17 <dmwit> cdh473: That was meant for you.
07:26:18 <ManateeLazyCat> applicative: http://www.linuxdeepin.com/feature is new software center by with my GTK+ knowledge.
07:26:21 <cdh473> ah
07:26:24 <dmwit> cdh473: The error likely says something to that effect, too.
07:26:33 <dmwit> cdh473: Also, you need a "do" in the "then" clause.
07:26:38 * hackagebot yesod-rst 0.1 - Tools for using reStructuredText (RST) in a yesod application  http://hackage.haskell.org/package/yesod-rst-0.1 (PascalWittmann)
07:26:51 <cdh473> so what would i add for the `else` clause?
07:27:01 <ManateeLazyCat> applicative: Unfortunately, i can't use Haskell, i use Python instead.
07:27:02 <cdh473> do Nothing?
07:27:11 <hpc> return ()
07:27:19 <dmwit> what hpc said
07:27:22 <hpc> main :: IO ()
07:27:24 <hpc> main = loop
07:27:24 <cdh473> ok thanks guys :)
07:27:28 <hpc> so loop :: IO ()
07:27:31 <dmwit> I see that the error does not say anything helpful re: else clauses.
07:27:34 <hpc> return () :: IO ()
07:27:34 <dmwit> That's annoying.
07:27:36 <ManateeLazyCat> applicative: How about gtk2hs, i have leave that project long time, how about that?
07:27:43 <roconnor> @type \f -> callCC (\k -> Right $ traverse (either (k . Left) id) f)
07:27:43 <lambdabot> Not in scope: `traverse'
07:28:30 <applicative> ManateeLazyCat:  I don't know, myself, I only occasionally the gloss library.  It certainly continues to compile, which used to be the main problem.
07:29:08 <cdh473> aha! it worked, thank you all
07:29:10 <cdh473> hpc++
07:29:11 <applicative> I mean, the problem with gtk2hs used to be that it was impossible to compile, but after all the work last year it seems solid
07:29:16 <cdh473> dmwit++
07:29:19 <hpc> cdh473: when you learn more about haskell, i think you will find that your first mistake was using if-then-else in a do-block at all :P
07:29:45 <hpc> if-then-else can be quite strange, just because it looks different from in other languages
07:29:56 <hpc> you probably haven't learned the better ways yet, but keep your eye out :D
07:29:59 <ManateeLazyCat> applicative: I'm glad gtk2hs can continue... i guss must be dcoutts fixed it. :)
07:30:30 <cdh473> hpc: this is the first thing i've tried to write :)
07:30:30 <applicative> ManateeLazyCat: I was thinking of how it was before you were also involved
07:30:50 <dmwit> cdh473: When you're ready, there's a function that implements else-less if's.
07:30:51 <dcoutts_> ManateeLazyCat: I didn't do much, I just committed a few fixes for 7.4.x
07:30:52 <dmwit> :t when
07:30:53 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:31:06 <cdh473> nice!
07:31:13 <hpc> @src when
07:31:14 <lambdabot> when p s = if p then s else return ()
07:31:42 <dmwit> (In fact, I think it's something of a misfeature that "if" was even built into the language at all. Other languages base syntax are Haskell's functions. =)
07:32:11 <applicative> ManateeLazyCat: well the gui aspect of Deepin looks very nice.
07:32:13 <ManateeLazyCat> dcoutts_: Hey, man, how do you do? It's really long time no see. :)
07:32:13 <hpc> so you could write loop = do {x <- getLine; when (x == "42") $ do {putStrLn x; loop}}
07:32:16 <cdh473> that when function seems much more useful for this application
07:32:29 <ManateeLazyCat> applicative: I hate Gnome-Shell
07:32:35 <hpc> (replace {} with alignment for justice!
07:32:36 <hpc> )
07:32:46 <hpc> ((balance parens, too))
07:33:05 <dmwit> looks balanced to me
07:33:37 <dmwit> ...oh
07:34:00 <roconnor> @type \f -> callCC (\k -> fmap Right $ Data.Traversable.mapM (either (k . Left) return) f)
07:34:01 <lambdabot> forall (m :: * -> *) b a (t :: * -> *). (Functor m, MonadCont m, Data.Traversable.Traversable t) => t (Either a b) -> m (Either a (t b))
07:34:26 <ManateeLazyCat> applicative: Gnome-Shell lies to on powerful with gjs, it use JavaScript, make desktop environment not stable enough, it use clutter library, make it can't running on ATI driver, i hate it.
07:34:28 <dcoutts_> ManateeLazyCat: really busy! :-)
07:35:05 * dcoutts_ should have realised that world domination would be time consuming
07:35:23 <int-e> delegate :)
07:35:33 <applicative> dcoutts_: It will be worse once you accomplish it
07:35:41 <dcoutts_> applicative: hah
07:36:11 <Taneb> Do compilers other than GHC have something like -XOverloadedStrings ?
07:36:29 <dcoutts_> int-e: doing that, hired two new minions to help with our evil plans
07:37:00 <dmwit> Taneb: Refer to the documentation for the other compiler to see a list of the extensions it supports.
07:37:13 <roconnor> @type \f -> callCC (\k -> Right <$> Data.Traversable.mapM (either (k . Left) return) f)
07:37:14 <lambdabot> forall (m :: * -> *) b a (t :: * -> *). (MonadCont m, Data.Traversable.Traversable t, Functor m) => t (Either a b) -> m (Either a (t b))
07:37:18 <dmwit> (Don't think OverloadedStrings is one of the well-supported ones, though.)
07:37:25 <Baikonur> mm, 20 mins for the first lesson of my "haskel 101" course
07:40:51 <Taneb> dmwit, it seems it isn't.
07:41:05 <Taneb> This isn't too annoying
07:42:03 <t7> Baikonur: a whole program is one single expression
07:42:17 <t7> Baikonur: prepare for mind blowing
07:46:26 <rostayob> what's the quickest thing to create a simple REPL?
07:46:39 <rostayob> no fancy things just evaluating haskell expressions (in other words no IO)
07:47:17 <companion_tesser> rostayob: ..ghci?
07:47:25 <Saizan> do you have your own evaluator or what to use GHC?
07:47:29 <Saizan> *want
07:47:33 <rostayob> my own evaluator
07:47:43 <rostayob> simple ML-like language, nothing real-world :P
07:47:50 <t7> readline
07:47:50 <companion_tesser> I mean, REPL is pretty explicit. :|.
07:47:54 <Saizan> haskeline
07:48:00 <companion_tesser> You read in a line, evaluate it, print the result, and loop.
07:48:03 <t7> theres a haskell native readline-like package on hackage
07:48:10 <companion_tesser> Or, maybe we should call it REPR.
07:48:11 <companion_tesser> :)
07:48:13 <companion_tesser> or REPF
07:48:20 <rostayob> yeah haskeline is pretty fancy I need a really simple thing, but anyways
07:48:22 <companion_tesser> (read, evaluate, print, recurse/fix)
07:48:42 <rostayob> does haskeline work with GHC 6?
07:49:14 <hpc> companion_tesser: RPER (read, print, evaluating lazily, recurse)
07:49:27 <Saizan> rostayob: it's _really_ annoying when you don't have standard editing facilities in a repl
07:49:58 <rostayob> Saizan: it's nothing to be used for practical purposes, just a small demonstration
07:53:45 <srhb> Can someone tell me what the Int64 is for in runGetState :: Get a -> ByteString -> Int64 -> (a, ByteString, Int64)
07:53:51 <srhb> The first one, ie. the last argument
07:54:42 <srhb> Hmm, maybe it's an offset, actually.
07:59:26 <Ptival> http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/src/Data-Binary-Get.html#runGetState
07:59:38 <Ptival> it's named off
08:00:14 <srhb> Ptival: I guess that's it then. Poorly documented, ah well.
08:00:15 <Ptival> Saizan: rlwrap helps for bad repls
08:00:45 <mekeor> why do i get the following error message when i try to connect to a sqlite3-database with HDBC using 'connectSqlite3'?: 'SqlError {seState = "", seNativeError = 21, seErrorMsg = "prepare 6: BEGIN: unable to open database file"}'
08:00:51 <Saizan> i don't think it's an offset
08:01:06 <weexplat> Ptival: it can, but it depends how bad.  sometimes it feels kind of lose/lose
08:02:02 <mekeor> the file exists, i even set the permissions to rwxrwxrwx! still, doesn't work…
08:02:48 <weexplat> mekeor: it might be failing to open the lock file, depending on directory permissions
08:03:01 <weexplat> well, actually it's a journal file
08:03:21 <mekeor> weexplat: the directorys permissions are 777, too.
08:03:21 <weexplat> or you could just have the wrong path
08:03:27 <itaqm> hola
08:03:37 <mekeor> weexplat: the path is right for sure :/
08:03:37 <itaqm> hi
08:03:57 <itaqm> http://www.tuenti.com
08:04:10 <mekeor> spam?
08:04:11 <itaqm> in spain
08:04:21 <weexplat> mekeor: and does it work if you query it with the sqlite3 executable and/or another language?
08:04:35 <itaqm> No
08:05:19 <mekeor> weexplat: yes, with 'sqlite3' i can just access to the DB fine.
08:05:34 <mekeor> with the exact same (absolute) path.
08:06:33 <weexplat> actually, yes it was spam.
08:07:16 <mekeor> thank you anyway, weexplat :)
08:07:49 * mekeor goes afk
08:08:20 <scooty-puff> is there any chance that TypeRep will gain functions that allow one to write a Hashable instance (i would not expect it to require that package)?
08:08:51 <scooty-puff> i would guess no, since it would basically be a weak random number generator
08:09:08 <scooty-puff> well, and inflexible
08:19:27 <cdh473> how do i convert an Int to a String?
08:19:37 <mauke> show
08:19:43 <cdh473> thanks
08:19:56 <cdh473> don't know why i couldn't find that :\
08:21:08 <koala_man> it's not obvious from hoogle
08:21:32 <quicksilver> @hoogle Int -> String
08:21:33 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
08:21:33 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
08:21:33 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
08:21:42 <quicksilver> hmm yes that's not very useful :)
08:21:47 <mauke> > gshow ()
08:21:48 <lambdabot>   "(())"
08:22:36 <rata_> hi guys
08:23:17 <rata_> I'm looking for a good introduction to category theory and thought you could know one
08:23:29 <dzhus> rata_: Barr & Wells
08:25:27 <hpaste> scooty-puff pasted “Records (repost + some changes) - anything really wrong with this (other than Map usage maybe)” at http://hpaste.org/65245
08:25:47 <rostayob> rata_: people here often suggest Awodey
08:26:00 <weexplat> > gshow "hi"
08:26:01 <lambdabot>   "\"hi\""
08:26:16 <quicksilver> rata_: Mac Lane
08:26:18 <weexplat> wat
08:26:33 <quicksilver> a copy of Johnstone's lecture notes if there is one around.
08:26:39 <quicksilver> the catsters videios maybe
08:26:44 <mauke> > show "hi"
08:26:45 <lambdabot>   "\"hi\""
08:27:02 <weexplat> can hoogle show the source of the functions it finds?
08:27:29 <weexplat> mauke: it's a little odd that gshow has the string hack, at least at the top level
08:28:01 <quicksilver> weexplat: yes, it can (indirectly)
08:28:08 <quicksilver> click the link to the docs, then the link to the source
08:28:30 <rata_> quicksilver, rostayob, dzhus: wow, thank you very much
08:28:41 <quicksilver> http://www.haskell.org/hoogle/?hoogle=map links to http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:map links to http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#map
08:28:49 <weexplat> lambdabot should use that somehow instead of that pack of lies that is @src
08:28:50 <rata_> do you know the differences between them?
08:29:01 <quicksilver> it would be nice, yes.
08:32:29 <rata_> MacLane is probably too math for me
08:33:08 <quicksilver> they're all quite dry, but then again a lot of category is a series of definitions. And, eventually, some theorems about them.
08:33:38 <quicksilver> that's inevitably a bit dry - although you can give a little life to the material with examples, which only works for the most part if the examples relate to something the listener already cared about.
08:35:25 <clsmith> i don't know barr & wells, but imo rydeheard & burstall is quite good
08:35:31 <clsmith> (speaking as a category noob :p)
08:35:54 <rata_> maybe barr & wells is the more computer-sciency one?
08:36:30 <rata_> probably computer-science examples would be the ones I care most about
08:36:58 <clsmith> the one i mentioned uses ML for its explanations
08:37:12 <clsmith> (which is why i found it more accessible)
08:37:53 <clsmith> seems to be available as a free pdf, too, if you want to google a look
08:38:00 <rata_> clsmith: I'll take a look at it then
08:38:14 <rata_> is there any of them with examples in haskell btw?
08:38:29 <clsmith> good question. anyone? ;p
08:38:37 <quicksilver> I don't think so.
08:38:37 <scooty-puff> any chance that a TypeRepMap will ever be included in the Data.Typeable module?
08:38:49 <quicksilver> there isn't much about category theory which can be illustrated by examples in haskell
08:38:54 <scooty-puff> i ask because it could probably be made more efficient than Map TypeRep
08:38:57 <clsmith> ml and haskell are very similar though, really. they only really differ in minor syntax and laziness
08:39:34 <dolio> And modules.
08:39:34 <clsmith> quicksilver: how so?
08:39:45 <rata_> quicksilver: why? is haskell not a good language for category-theoretic things?
08:40:17 <quicksilver> clsmith: well can you show me a colimit in haskell?
08:40:30 <quicksilver> the special adjoint functor construction in haskell?
08:40:37 <quicksilver> a 2-cell in haskell?
08:40:43 <clsmith> 15:35 < clsmith> (speaking as a category noob :p)
08:40:44 <clsmith> ;)
08:40:46 <quicksilver> the difference between a 2-functor and a bifunctor?
08:40:59 <clsmith> surely that's the same with ml then?
08:41:05 <quicksilver> yes, it is.
08:41:28 <clsmith> do you think there can be a programming language in which you can do those things?
08:41:35 <weexplat> quicksilver: you can make a product in haskell, which is more than you can do in ML :)
08:41:52 <rata_> quicksilver: what's then a good language for category theoretic things?
08:42:01 <quicksilver> I'm not aware that there are any
08:42:04 <quicksilver> why would you want one?
08:42:05 <clsmith> i suspect the answer is "maths" :p
08:42:09 <quicksilver> I sound like I'm being difficult :)
08:42:18 <quicksilver> category theory underlies some interesting ideas in functional programming
08:42:19 <mm_freak> when defining an instance function that has a default, is there a way to refer to this default?
08:42:20 <clsmith> i wants to execute my categories!
08:42:30 <quicksilver> but that doesn't mean functional programming languages are designed to model category theory
08:42:31 <dzhus> rata_: yes, barr & wells gives example how structure of a simple functional programming language can be a category on about like 15th page and I thinks it's nice
08:42:31 <dolio> If you want to do math, you should look at languages like Agda or Coq.
08:42:34 <quicksilver> (or explain it)
08:42:35 <mm_freak> (no, i can't modify the class)
08:45:30 <weexplat> mm_freak: you can refer to instantiations of it, anyway, by making a new instance.  probably there's an instance you could make that is 'universal' in that you could extract the original function from it, but i don't know offhand what that is
08:45:47 <clsmith> here's an odd question for you. do you think that we could write a compiler which could compile any mathematics that can be proven?
08:46:01 <clsmith> by compile i suppose i mean .. prove
08:46:08 <clsmith> (do i?)
08:46:39 <weexplat> clsmith: technically you could say that's already been done, depending what you mean by things like 'prove' or 'any'
08:47:17 <ibid> all true theorems are computably enumerable, so yeah, you could write a prover that proves anything that is provable
08:47:27 <weexplat> there are large chunks of mathematics that still aren't practical to express in those systems though
08:47:28 <ibid> (no guarantees that it'll disprove anything)
08:48:46 <weexplat> ibid: it would disprove anything that can be disproven, too.  what it wouldn't do, 'obviously', is disprove everything that can't be proven.
08:49:06 <weexplat> except maybe vacuously, if you give it an inconsistent set of axioms
08:49:24 <clsmith> mathematical notation is a weird thing. imo it needs more namespacing; everyone just uses the same greek letters.
08:50:11 <DrSyzygy> clsmith: Psht. It's obvious what I mean by \pi.
08:50:13 <weexplat> clsmith: the only difference between informal and namespaced mathematical notation is that in the former people don't write their import statements.  (or their type declarations.)
08:50:47 <weexplat> you could say informal math declares types fortran-style
08:51:09 <ibid> weexplat: if one defines "can be disproven" as "there is an algorithm that disproves it", then yeah
08:51:29 <ibid> weexplat: also if "can be disproven" is taken to mean "is contradictory"
08:51:56 <weexplat> ibid: i'm defining 'A can be disproven' as '¬A can be proven'
08:52:07 <ibid> weexplat: the latter, then.  yeah, that's true
08:52:22 <DrSyzygy> weexplat: ... because that makes sense?
08:52:54 <DrSyzygy> weexplat: An explicit dis-proof is not the same as a failure to find a proof -- which is why intuitionism and constructivism actually seem to make sense.
08:52:57 <weexplat> this includes, as a special case, providing a counterexample that can be proven to be such
08:53:06 <ibid> to me, however, "disprove" means "show that it cannot be proven". :)
08:53:30 <ibid> maybe i am misusing the term
08:54:18 <clsmith> i don't know, i guess i just find general mathematics more 'vague' than programming. it's not strictly defined enough that i could actually execute the equation.
08:54:33 <weexplat> unless you have a provability logic, you have to go meta in some way to show that something can't be proven.  at all, not just without disproving it in my sense.
08:54:56 <clsmith> but maybe that's not my problem, maybe it's that i find it difficult to visualise the 'workings' of abstract mathematics, whereas i can visualise the interactions of data structures for compsci
08:55:15 <weexplat> clsmith: that's why we have things like coq, agda, nuprl, lego, etc
08:55:28 <clsmith> i always liked lego as a kid
08:55:52 <weexplat> as a platform to take the vagueness out of mathematics and get something that can be 'compiled'
08:56:01 <ibid> weexplat: but in terms of a proving algorithm, it's desirable (and impossible) to answer no for all inputs for which yes is not available
08:56:30 <t7> anyone know of a language like apl/j/k that is staticly types?
08:56:33 <weexplat> ibid: it's not always impossible, but yes, in general that's right.
08:56:59 <clsmith> hmmm, i suppose so. those systems always seem to be a bit impenetrable. is there no way to get the expressiveness of mathematics but still be able to infer types etc, at least until you get into the crazier realms of type theory?
08:57:11 <ibid> weexplat: it's always impossible in the sense that there is no total algorithm (unless we restrict to decidable logics)
08:57:42 <ibid> mathematics is mostly a social exercise.  it's about convincing others, communicating ideas.  hence, the use of some formalism but not being strict about it
08:58:14 <quicksilver> the idea is that we know the formalism is there beneath the surface
08:58:20 <quicksilver> and we could recover it if we needed it
08:58:35 <quicksilver> sometimes this process goes wrong, and we believe fallacious proofs.
08:58:50 <quicksilver> human beings in "being fallible" shocker :)
08:58:55 <ibid> that's the fiction
08:59:07 <ibid> most mathematicians don't give a damn about the underlying formalism, though
08:59:07 <shergill> hmm it wouldn't be possible to prove the correctness of such a compiler within itself would it?
09:00:19 <narens> hello, is there an efficient way (ideally using enumerator) to read lines from a file in reverse
09:00:34 <ibid> (if they did, mathematicians wouldn't teach classic FOL when they teach introductory logic:)
09:01:53 <mm_freak> narens: nope
09:02:19 <narens> mm_freak: I thought as much
09:02:20 <mm_freak> narens: reading them in order and reversing the resulting list/vector/whatever is probably your best bet
09:02:49 <narens> mm_freak: how about an efficient way to append a line to the top of the file?
09:02:52 <clsmith> surely you can do it with seeks etc? does haskell not have that?
09:03:18 <clsmith> (in the stdlib i mean)
09:03:30 <thermoplyae> it's not a fiction, it's exactly what quicksilver said; it's just so rarely important to actually perform the recovery to the extent where you in turn start worrying about FOL pedagogy
09:03:46 <clsmith> narens: that's not possible in unix, without rewriting the entire file. (amusingly.)
09:03:47 <mm_freak> clsmith: it's possible, but it's not efficient
09:03:55 <mm_freak> likely much less efficient than reversing in memory
09:04:01 <ulfdoz>  _             _     _
09:04:02 <ulfdoz> | |_ __ _  ___| |__ | |
09:04:02 <ulfdoz> | __/ _` |/ __| '_ \| |
09:04:02 <ulfdoz> | || (_| | (__| | | |_|
09:04:02 <ulfdoz>  \__\__,_|\___|_| |_(_)
09:04:04 <ulfdoz>                        
09:04:07 --- mode: ChanServ set +o mauke
09:04:07 --- kick: ulfdoz was kicked by mauke (ulfdoz)
09:04:16 <clsmith> mm_freak: unless the file is particularly large, you're probably right
09:04:19 <mm_freak> because reading backwards kills the performance of every disk…  it's equivalent to reading a completely fragmented file
09:04:37 <mm_freak> except SSD
09:04:44 <clsmith> hurray for ssd :3
09:05:16 <rwbarton> can't the disk just spin backwards? :P
09:05:17 <narens> mm_freak: hmm... why would hSeek from end and using getChar be inefficient?
09:05:52 <ulfdoz> Sorry for that, was intended for another window.
09:05:55 <mm_freak> narens: well, appending to the top /can/ be efficient, when the filesystem has special support for it, but you will end up with a totally fragmented file
09:05:58 <clsmith> i was assuming you'd read in blocks
09:06:01 <mm_freak> so not a good idea either
09:06:07 --- mode: mauke set -o mauke
09:06:17 <clsmith> but mm_freak is right, unless the file is huuuge you're better off just reversing
09:06:28 <mm_freak> narens: it's related to the way magnetic disks work
09:06:37 <mm_freak> they are optimized for sequential forward-reading
09:06:42 <dolio> You know, roconnor has a theory that the reason that it seems difficult to prove things by induction on a computer is that mathematicians tend to not prove things by induction, but don't notice.
09:07:37 <mm_freak> narens: you might want to use a database instead of a file
09:07:42 <narens> mm_freak: yea... disk structure is coming back to me now. I guess if I am willing to live with a lot of small files I can just take that route rather than mucking around adding things at beginning of file
09:07:43 <dolio> That is, instead of proving '⊢ ∀n. P(n)' by induction, they prove '∀n. ⊢ P(n)' by meta-induction, and then assume they've correctly proved it by induction.
09:08:00 <dolio> But it's hard to tell the difference in the semi-formal world that most mathematicians work in.
09:08:31 <weexplat> ibid: like i said, in general you are right.  in specific cases (logics) you can always return YES or NO, and these are called decidable logics.
09:08:54 <t7> in the context of nothing, forall n, p applied to n
09:09:05 <t7> whats that proving?
09:09:17 <mauke> nothing
09:09:23 <mauke> it's not a proof
09:09:37 <narens> mm_freak: while I'm on here... i wonder if you have any good links/package names that use mfix. I have seen a few examples (including the thesis on value recursion), but I'd like to get more...
09:10:44 <weexplat> narens: if you want to read the lines in reverse, and append things to the top, why don't you just keep them in reverse order in the first place, then you can read them in order and append at the end.
09:10:54 <pqmodn> dolio: what's the significance of where ⊢ is placed? is the second instance syntactically valid?
09:11:16 <cdh473> is wxHaskell as good as I'd like to think it should be? I'm looking for it to resemble wxPython at least a bit
09:11:35 <t7> pqmodn: that means forall n is in the context? or it is the context?
09:11:38 <mm_freak> narens: well, netwire =)
09:11:44 <narens> weexplat: well, because the file doesn't just grow, i also have to delete things. either i write at bottom and delete from top or write at top and delete from bottom
09:11:48 <mm_freak> narens: it needs mfix for its implementation of ArrowLoop
09:12:15 <narens> mm_freak: interesting, haven't seen that one
09:12:31 <mm_freak> other than that it's probably mainly applications using mfix
09:12:41 <dolio> pqmodn: The first is object-level quantification, the second is meta-level quantification. 1 is ∀n. P(n) is a theorem. 2 is, P(n) is a theorem for all n.
09:12:57 <pqmodn> dolio: ah
09:13:42 <dolio> And there isn't usually a rule that lets you infer the former from the latter.
09:14:48 <weexplat> narens: it's easier to delete at the top and write at the bottom, if you have comment lines
09:15:17 <narens> mm_freak: final question... i was pointed to good links for understanding memory footprint of data structures last time i was on here, but I couldn't figure out the cost of an STRef. If i have a piece of data X... how much does each STRef to it cost? Is it wrong to use STRef like I would use a pointer in C (eg for a graph-like structure where things point to other things)?
09:15:22 <weexplat> narens: you can just delay trimming the fat until there's a lot of it
09:15:46 <narens> weexplat: yea, I was leaning towards that
09:17:15 <ibid> weexplat: as i said :)
09:17:32 <mm_freak> narens: i don't know exactly, but i'm pretty sure STRefs are expensive
09:17:43 <mm_freak> they are boxed and the values they contain are boxed, too
09:17:57 <clsmith> btw, am i right in thinking quantifiers are sort of like lambda abstractions, only with a different meaning to the variable they bind, and that they can be modelled with de bruijn indices, and a quantifier elimination sort of keeps the variable sort of still bound but the quantifier is 'invisible' in higher-up terms?
09:18:00 <weexplat> there are often a lot more metatheorems of the sort 'forall x, {P(x) is a theorem}' than theorems of the form 'forall x. P(x) is a theorem'
09:18:14 <weexplat> er, of the form 'forall x. P(x)'
09:18:15 <clsmith> if you hadn't noticed #haskell is the only nice maths channel i know :p
09:18:21 <mm_freak> narens: if you use a lot of STRefs you probably want some kind of a map or array
09:18:32 <narens> mm_freak: see, as far I have seen the way haskell packages do graph structures is to just store nodes in a map and then look em up using an ID, but to get that process to be efficient I have to end up using a hastable and that means no more pureness
09:19:03 <stj> in emacs haskell-mode, after typing 'forM_ [1..10] $ \x -> do' the next line is not indented by 2 spaces, but rather by 7 spaces -- anyone knows why and how to fix it?
09:19:34 <mm_freak> narens: your impression is wrong…  give Data.Map a try
09:19:39 <andares> hey, what is this {-# LANGUAGE business?
09:19:52 <mm_freak> HashMap from unordered-containers is only marginally faster than Data.Map
09:20:04 <narens> mm_freak: it is indeed, I use it now
09:21:15 <weexplat> andares: it's a way to enable language extensions from inside the file instead of from a compiler flag.  this is usually considered cleaner since the information about which language extensions are in use can't get separated from the code
09:21:26 <andares> ah, I see.
09:21:34 <narens> mm_freak: I was just trying to think of the most space economical way of doing it and not compromise on speed either. the hashmap has worst case on the order of the number of bits in the key
09:22:30 <weexplat> narens: if you have integer keys and a sparse map a patricia trie is a good structure
09:22:33 <narens> mm_freak: and you need to store key+value rather than just the value like you would in a hashtable
09:23:15 <weexplat> and Data.IntMap uses that iirc
09:23:29 <mm_freak> narens: HashMap is probably still more efficient in both
09:24:09 <mm_freak> an in-memory HashMap Integer Integer of 10 million entries barely fits into my RAM
09:24:14 <mm_freak> Data.Map doesn't fit
09:24:18 <pqmodn> clsmith: since nobody answered, that all seems right except i'm not sure what you're saying about quantifier elimination
09:24:32 <weexplat> IntMap should be a lot smaller than Data.Map Int or something
09:26:44 * hackagebot stm-conduit 0.2.4.1 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.2.4.1 (ClarkGaebel)
09:27:34 <companion_cube> moar plumbing!
09:28:18 <edwardk> they need to start labeling input conduits as hot or cold, and output conduits as sewage
09:29:16 <companion_cube> that's what contention is for, making conduits hot
09:29:29 <ksf_> why does derive choke on type synonyms?
09:29:32 <stj> putStrLn =<< withFile "fajl.txt" ReadMode hGetLine -- this works fine, but if I replace hGetLine with hGetContents, then it just outputs empty string -- what's wrong here?
09:29:41 <ksf_> and why does TH choke on quoting type applications?
09:30:13 <JoeyA> stj: The obvious question: is the file empty?
09:30:26 <JoeyA> Also, does readFile work as expected?
09:30:31 <rwbarton> it has to do with the interaction of withFile and lazy IO (hGetContents)
09:30:37 <rwbarton> just use  readFile "fajl.txt"
09:30:41 <weexplat> stj: the withFile closes the file before getContents starts reading it
09:31:01 <JoeyA> Bah, can't believe I missed that.
09:31:27 <ksf_> tl;dr: lazy IO is evil
09:31:35 <rwbarton> lazy IO isn't evil
09:31:41 <mauke> is too
09:31:42 <rwbarton> it's just misunderstood
09:31:50 <Tinned_Tuna> It just wants attention.
09:31:55 <mauke> .oO( no one knows what it's like ... )
09:32:11 <stj> weexplat: makes sense -- is there an easy fix that would really print the contents of the file?
09:32:28 <mauke> <rwbarton> just use  readFile "fajl.txt"
09:32:42 * cmccann needs to hurry up and get his stream processing library finished before all the possible synonyms for "thing that other things flow through" are taken
09:32:43 <ksf_> stj, put the putStrLn into withFile.
09:33:02 <dolio> When I manually rewrite my thunks with the wrong values, my program does the wrong thing.
09:33:04 <JoeyA> @quote cmccann
09:33:05 <lambdabot> cmccann says: beta reducing the chainsaws can be tricky
09:33:05 <dolio> Laziness is evil. :)
09:33:08 <ksf_> withFile "foo" ReadMode (putStrLn =<< hGetContents)
09:33:22 <rwbarton> or... you can not make things overly complicated, and just use lazy IO
09:33:23 <JoeyA> @remember cmccann
09:33:23 <lambdabot> Incorrect arguments to quote
09:33:38 <JoeyA> @remember cmccann * cmccann needs to hurry up and get his stream processing library finished before all the possible synonyms for "thing that other things flow through" are taken
09:33:39 <lambdabot> Done.
09:34:05 <dolio> There's no point in using withFile with lazy I/O.
09:34:16 <dolio> It will either do the wrong thing, or do something that doesn't matter.
09:34:21 <rwbarton> putStrLn =<< readFile "fajl.txt"
09:34:27 <JoeyA> http://thesaurus.com/browse/conduit
09:34:34 <weexplat> cmccann: i know the feeling
09:34:34 <HaudRex> dolio: Sounds like congress
09:34:45 <ksf_> dolio, strict IO can gobble a hell a lot of memory.
09:34:46 <dolio> Zing.
09:34:57 <ksf_> the proper solution, of course, is iteratees.
09:35:02 <rwbarton> no!
09:35:03 <rwbarton> argh
09:35:09 <cmccann> JoeyA, I'm thinking "aqueduct" is promising
09:35:13 <dolio> The ugly an overcomplicated solution?
09:35:24 <rwbarton> iteratees are not the proper solution to  putStrLn =<< readFile "fajl.txt"
09:35:24 <rwbarton> wtf
09:35:36 <copumpkin> lol
09:35:40 <JoeyA> arteries/veins
09:35:40 <ksf_> nah. lazy IO works fine, there.
09:35:51 <ksf_> especially in a withFile.
09:36:07 <dolio> withFile is just closing the file twice.
09:36:10 <dolio> In your solution.
09:36:11 <ksf_> "proper" as in "able to deal with more complicated stuff than trivia"
09:36:27 <ksf_> it's still more beautiful.
09:36:53 <cmccann> JoeyA, oooh, that's an excellent idea, I like that
09:36:58 <ksf_> if you use openFile you could later change hGetContents to something else and forget to close it.
09:38:13 * ksf_ is keenly awaiting talks titled "process your bananas with functional gutters"
09:38:25 * cmccann ponders using arteries/veins as terms to distinguish push vs. pull streams
09:38:47 <ksf_> veins are push, mostly.
09:38:55 <weexplat> "process your bloody files with veins and arteries"
09:39:18 <cdh473> what's the heart
09:39:24 <ksf_> two pumps.
09:39:27 <cdh473> :|
09:39:47 <ksf_> ...depending on species, of course.
09:39:54 <edwardk> lazy io and iteratees both suck, for completely different reasons.
09:40:09 <weexplat> the mammalian heart was the first pair of red pumps?
09:40:31 <ksf_> iirc only mammals have clearly divided hearts, two pumps a two chambers each.
09:41:36 <ksf_> oh, birds too.
09:41:36 <cmccann> ksf_, well, I'm thinking of the heart as the driving force even though that's oversimplifying things a bit, so arteries would be "push" because of carrying blood away from the heart
09:41:50 <ksf_> reptilians *nearly* have it, that explains things.
09:42:09 <cmccann> could call each step of the stream a "heartbeat" too
09:43:03 <weexplat> you've really got your finger on the pulse of the haskell community, haven't you?
09:43:13 <ksf_> you could call pushing "paying" and pulling "distraining"
09:44:24 <lispy> edwardk: yeah, but at least iterates have more hope of being correct
09:44:30 <lispy> iteratees*
09:44:50 <lispy> edwardk: granted, oleg's iteratees provide plenty of places to shoot yourself in the foot
09:44:58 <edwardk> lispy: i agree. i just hate the discussions with users about how to use them
09:45:20 <rwbarton> can't we just agree that they are good for different problems, and not go about calling things "evil"
09:45:25 <ksf_> this derive thing is highly annoying. I don't even want to derive for non-ground types, only for applied type fuctions.
09:45:27 <cmccann> lispy, lazy IO is easy to use correctly, so long as you only use it in places where it can possibly be correct
09:46:17 <ksf_> ...though deriving for non-ground types would be a perfectly sensible thing to support, too.
09:46:47 <shergill> people want silver bullets. people also want said silver bullets to be simple and just work on magic and unicorn dust. people be delusional
09:47:14 <dolio> If you weren't limited to a couple hundred file descriptors, lazy I/O might not be that bad.
09:47:40 <ion> @hoogle Rational n => ParsecT s u m n
09:47:41 <lambdabot> Warning: Unknown class Rational
09:47:41 <lambdabot> Text.Parsec.Prim parserZero :: ParsecT s u m a
09:47:41 <lambdabot> Text.Parsec.Prim parserReturn :: a -> ParsecT s u m a
09:47:42 <monochrom> eww
09:47:45 <ksf_> TH and deriving need more work, in general. both are seeing quite a lot of use and have huge warts.
09:47:46 <ion> @hoogle Fractional n => ParsecT s u m n
09:47:46 <lambdabot> Text.Parsec.Prim parserZero :: ParsecT s u m a
09:47:46 <lambdabot> Text.Parsec.Prim parserReturn :: a -> ParsecT s u m a
09:47:47 <lambdabot> Text.Parsec.Prim try :: ParsecT s u m a -> ParsecT s u m a
09:47:51 <quicksilver> file descriptors are not the only limited resource, and resource limits are not the only problem with interleaved IO.
09:48:01 * cmccann wants silver bullets that fire themselves, and also are made of steel because silver is too expensive
09:48:05 <edwardk> dolio: wait, we run into select limits or something? what is this 1990?
09:48:45 <ion> Some package had a nice Parsec parser for fractionals that would parse at least “-12.34”. Does anyone remember which one? :-)
09:48:50 <Ralith> edwardk: not select limits, but OS limits, I expect.
09:49:04 <dolio> edwardk: I think one of the common problems is running out of file descriptors because they aren't closed fast enough. I don't know what specifically fails.
09:49:10 <edwardk> fun
09:49:16 <JoeyA> dolio: Real-world example: hoogle combine -o default.hoo $(ls *.hoo | sed '/default/d') .  This had resource exhaustion when I ran it.
09:49:42 <JoeyA> I guess that's because of lazy I/O
09:49:46 <ion> Hmm, the package might have had something to do with parsing Haskell code.
09:49:47 <JoeyA> I don't know for sure.
09:49:49 <dolio> What resource?
09:49:51 <shergill> cmccann: silver bullets don't respect eta equivalency. it needs to be made of silver, and not simply *act* like one :P
09:49:57 <JoeyA> Too many open files, iirc
09:50:03 <edwardk> so raise the per process file descriptor limit. shouldn't it be like 1024?
09:50:13 <ksf_> cmccann, the thing that devides arteries and veins (apart form which side of the cappilars they're on) is that veins have valves to prevent blood flowing back. under workload, the surrounding muscles then pump the blood forwards (because they can't push it backwards)
09:50:25 <monochrom> hahaha shergill
09:50:34 <JoeyA> What about caterpillars?
09:50:35 <monochrom> @remember shergill silver bullets don't respect eta equivalency. it needs to be made of silver, and not simply *act* like one :P
09:50:35 <lambdabot> I will remember.
09:50:37 <dolio> I don't know if 1024 would be enough, either, although that's really a lot of files.
09:51:19 <edwardk> well, i was just referring to the limit given by ulimit -aS or ulimit -aH
09:51:21 <dolio> But, laziness in general leaks memory the same way lazy I/O leaks file descriptors. People just don't notice it because they have billions of bytes.
09:51:22 <ksf_> caterpillars are insects and thus should have a couple of handful one-chamber hearts.
09:51:46 <ksf_> ...if you can call what they have hearts, in the first place.
09:52:25 <quicksilver> dolio: not necessarily, though
09:52:28 <ksf_> then, of course, insects don't distribute oxygen to their muscles via their blood.
09:52:38 <quicksilver> dolio: sometimes a thunk uses less memory than its expansion.
09:52:43 <cmccann> ksf_, yes, but that's exceeding the degree to which I care about how things work when I'm just misappropriating the terms
09:52:50 <quicksilver> dolio: obviously lazy memory usage is complicated, yes.
09:52:50 <edwardk> i agree though that lazy io pisses away resources though, but running out of file descriptors is something you can ameliorate by other means =)
09:53:18 <dolio> quicksilver: Sometimes reading a whole file into memory is a bigger leak than a file descriptor.
09:53:25 <quicksilver> of course.
09:53:30 <ksf_> cmccann, well, I just thought it was interesting enough. if you can make the pull-part self-pushing, so to speak, then the term vein would be just perfect.
09:53:32 <cmccann> and I thought insects were basically just crunchy shells full of organs and goopy fluid and the closest thing to a heart is free-standing pumps that keep the goop moving
09:53:35 <monochrom> no no no. orphaned memory nodes are GCed. orphaned file descriptors aren't.
09:53:43 <quicksilver> they are actually monochrom
09:53:58 <ksf_> a bunch of chained buffers unblocking on near-underflow of or something
09:53:58 <quicksilver> although you can't guarantee the timeliness of it
09:54:02 <quicksilver> and it doesn't work for all resources.
09:54:11 <ion> I think i misremembered it having something to do with Parsec. readFloat was probably what i was thinking of.
09:54:24 <quicksilver> but orphaned file descriptors opened by 'readFile' *are* closed on their finalizer.
09:55:04 <ksf_> finalisers don't have any guarantee of being run.
09:55:20 <quicksilver> however, memory exhaustion triggers a GC (to reclaim memory) while FD exhaustion does not trigger a GC to recover FDs.
09:55:26 <cmccann> ksf_, well, in the library I'm working on, for which I'm not actually going to use these terms, push and pull aren't quite accurate anyway.
09:55:34 <quicksilver> lazy IO still sucks though :)
09:55:45 <dolio> Is that a fundamental limitation, or an implementation issue?
09:55:56 <quicksilver> it's an implementation issue.
09:56:07 <ksf_> finalisers are nasty, anyway.
09:56:11 <quicksilver> finalizers in general have plenty of disadvantages
09:56:32 <quicksilver> there are reasons why it may be wrong to architect a system which depends on finalizer behaviour.
09:56:35 <ksf_> pretty impossible to implement them in a general-purpose gc without thrashing performance.
09:56:39 <quicksilver> (on the other hand there are cases where it may work fine)
09:56:41 <edwardk> cmccann: pretty much, but they have a tracheal system for moving air around
09:56:55 <quicksilver> no silver bullet, see above.
09:57:14 <quicksilver> lazy IO sucks because it betrays the implicit promise of simplicity of "pure thunks"
09:57:25 <quicksilver> and because some resources are more precious than others
09:57:26 <monochrom> I also refuse to call certain memory or fd exhaustion "leaks"
09:57:34 <quicksilver> and because IO can be non-deterministic
09:57:37 <edwardk> this doesn't work at scale, which is one reason why we don't need to fear giant insects
09:57:39 <quicksilver> and because IO can return errors.
09:57:55 <cmccann> ksf_, a better analogy would be lazy vs. strict evaluation, maybe. "artery" would be a passive sink or active source, and v.v. for "vein". or something like that.
09:58:10 <quicksilver> edwardk: we should fear giant insects all the more, because we understand the challenges they have already overcome to become that large!
09:58:18 <edwardk> quicksilver: touche =)
09:58:21 <ksf_> edwardk, not when climate change has its way.
09:59:02 <monochrom> more precisely, if you clearly orphan something and it is not collected, I agree that's a leak. but if you still hold a reference to a thing, that's your error, not a leak.
09:59:15 <ksf_> at some point there were half a metre dragonflies iir my biology class correctly.
09:59:35 <dolio> monochrom: People call the latter leaks all the time here.
09:59:41 <dolio> It's exactly what a space leak is.
10:00:06 <monochrom> well I refuse to drink that kool-aid
10:00:24 <ksf_> that's the difference between a leak that's someone elses and one that is your fault.
10:00:26 <quicksilver> ksf_: you had half-metre dragonflies in your biology class? how on earth did you concentrate on the lesson? weren't people terrified of them?
10:00:27 <cmccann> leak is a bad term anyway.
10:00:49 <shergill> laziness makes it easier to have unintentional resource utilization. it's debatable whether to call it a leak or not =/
10:00:49 <quicksilver> if you orphan something and it isn't collected that's a leak in the RTS, or a bug in the GC.
10:00:59 <cmccann> resource leaks are about things sticking around when they should be gone, that's not a leak. it's more like a blockage.
10:01:03 <quicksilver> if you fail to orphan something you intended to orphan, that's a leak in your code.
10:01:21 <quicksilver> (a bug in your code)
10:01:38 <cmccann> if your toilet clogs and overflows instead of flushing, do we call that a "sewage leak"?
10:01:53 <pqmodn> conduit leak?
10:02:00 <shergill> heh
10:02:04 <cmccann> no, toilets use pipes, obviously
10:03:34 * cmccann is briefly tempted to invent some sort of debugging library for pipes just because of the potential for droll names
10:04:22 <copumpkin> mario?
10:04:46 <shergill> 70s b-grade porno references?
10:04:46 <cmccann> copumpkin, yes
10:05:05 <cmccann> shergill, that also occurred to me
10:05:12 <shergill> (aka, 70s b-grade movie references)
10:05:13 <cmccann> see, like I said. so much potential.
10:05:13 <shergill> heh
10:05:34 <copumpkin> cmccann: you must claim all the names immediately! then you can think of what to do with the real estate
10:05:46 * copumpkin starts a new business of hackage namesquatting
10:05:50 <cmccann> haha
10:05:50 <shergill> haskell needs a family of black dynamite themed libraries
10:06:39 <shergill> (for the uninitiated: http://www.imdb.com/title/tt1190536/)
10:06:53 <cmccann> shergill, hm, what sort of libraries would those be
10:07:10 <shergill> well they can't have any continuations for one
10:07:34 <shergill> and they'd expose the bare plumbing, for another
10:07:58 <monochrom> ok, I can see that "you should orphan it but you forgot it" is a leak. but that still doesn't justify calling one class of memory consumption leaks. specifically, "print (foldl1 (+) [1..n])" consumes a lot of memory, and people wrongly call it a space leak. but it contains nothing that should be orphaned and you forgot it. it is just being an inefficient algorithm.
10:08:32 <shergill> monochrom: the problem is that it's not that easy to see that it's an insufficient algorithm
10:08:47 <byorgey> leak : memory usage :: weed : plant
10:08:47 <shergill> the algorithm details have been somewhat abstracted away
10:08:52 <monochrom> right, sure, still doesn't make it a space leak
10:09:29 <shergill> it can lead to unexpected behavior more often than not, call it what you will
10:09:38 <roconnor> dolio, clsmith: the relevent link is: http://r6.ca/blog/20110307T035926Z.html
10:10:00 <mroman> why unexpected behaviour?
10:11:11 <shergill> unexpected behavior wrt resource utilization from the perspective of the programmer
10:11:24 <mroman> In my opinion it only makes the advantages of using haskell go away.
10:12:04 <mroman> If I have to worry about internals instead of how I express things I might as well use any other language.
10:12:21 <dolio> roconnor: Rereading, "In fact, if you are not a logician, you might even be convinced by the above there is actually a problem."
10:12:30 <dolio> I think you missed a "not"
10:12:33 <roconnor> ya I just corrected that
10:12:37 <dolio> Okay.
10:12:40 <roconnor> :)
10:12:48 <pqmodn> mroman: i haven't found a practical language that doesn't require me to understand the underlying implementation at least somewhat
10:13:44 <mroman> Me neither.
10:13:44 <rostayob> pqmodn: what? I don't understand the underlying implementations of most languages I use, and I doubt you do too
10:14:01 <rostayob> e.g. do you know how GHC compiles functional code to machine code?
10:14:03 <pqmodn> rostayob: "somewhat". eg, which things allocate memory
10:14:10 <mroman> but still
10:14:17 <rostayob> well that doesn't depend on the implementation
10:14:19 <roconnor> pqmodn: for most of my Haskell life, I had a wrong model of how GHC works.
10:14:20 <mroman> Haskell kinda advertises with its easiness like
10:14:22 <rostayob> that depends on the language
10:14:27 <mroman> just write "foldl (+) [1..n]"
10:14:53 <mroman> until you notice, that it is not as good as you were told.
10:15:00 <roconnor> pqmodn: I was quite confused by stack overflows since in my model in my head, there was no stack.
10:15:09 <dolio> rostayob: Whether or not foldl (+) 0 [1..1000000] uses a lot of memory depends on the implementation.
10:15:15 <dolio> So you need to know some stuff.
10:15:16 <cmccann> mroman, unless GHC optimizes it for you, which sometimes it does
10:15:36 <rostayob> dolio: the implementation of foldl
10:15:40 <dolio> No.
10:15:50 <dolio> The non-strict evaluation strategy.
10:16:04 <dolio> There are strategies where it's fine.
10:16:10 <dolio> But no one implements them.
10:16:24 <rostayob> dolio: oh, I didn't know about that. Is this in the standard?
10:16:25 <pqmodn> roconnor, rostayob: right, my point is an incomplete understanding of how your code is executed on the machine is a problem in any language (that i know of)
10:16:47 <pqmodn> (not that you must understand it fully to get work done)
10:16:48 <dolio> The standard doesn't say much of anything about evaluation strategies.
10:16:50 <roconnor> pqmodn: I guess I agree with that, that eventually it will likely be a problem.
10:17:03 <roconnor> or rather it likely will eventually be a problem.
10:17:29 <roconnor> pqmodn: but you can go along with in Haskell without really understanding how GHC works.
10:17:30 <rostayob> dolio: so wait what are the various ways a non-strict foldl could be implemented?
10:17:34 <mroman> pqmodn: But is that not exactly the opposite of what functional programming "promises"?
10:17:37 <pqmodn> i'm not sure how Haskell compares to other languages in how much knowledge is "mostly" sufficient
10:17:38 <roconnor> pqmodn: for a long time
10:17:46 <rostayob> dolio: I can see what you mean with stuff like deforestation etc.
10:18:14 <dolio> rostayob: You can implement non-strict evaluation by reducing arguments to functions a little up front, and stopping if it takes too long.
10:18:32 <dolio> That prevents building up big nested thunks like foldl does in some cases.
10:18:41 <rostayob> dolio: oh. I never heard of that.
10:18:50 <dolio> It's called optimistic evaluation.
10:19:28 <rostayob> dolio: cool, found a paper
10:19:41 <rostayob> anyways you can go a long why by understanding haskell semantics well
10:19:55 <dolio> So, if you had the right implementation, a lot of naive code that has problems that people solve in GHC using seq could just work.
10:20:03 <pqmodn> dolio: is that what distinguishes "non-strict evaluation" from "lazy evaluation"? i thought lazy means "won't evaluate unless it is *required*" where non-strict allows of optimistic evaluation
10:20:45 <dolio> Lazy evaluation is a specific strategy, yes. It involves sharing, too.
10:20:55 <shergill> i'm actually curious what would happen with a random evaluation strategy. you'd lose some guarantees, sure, but you may get certain statistical assurances (as in, some approximate bounds on space utilization from the optimal)
10:21:08 <dolio> So in 'let x = expensive in x + x' you only evaluate expensive once.
10:21:15 <byorgey> non-strict is a semantics.  lazy is a particular evaluation strategy which achieves a non-strict semantics.
10:21:16 <dolio> Barring race conditions.
10:21:32 <pqmodn> byorgey: ah, that makes sense
10:21:43 <quicksilver> unfortunately yes.
10:21:55 <quicksilver> it's not the only think functional programming "promises" though.
10:22:07 <quicksilver> and even that "promise" is not worthless - it works in some cases.
10:22:16 <roconnor> I wish we had a better name for non-strict evaluation ... Ideally we'd use the word "evalutation".
10:22:42 <majuscule> When I run a shell script that contains `export DISPLAY=:0; notify-send "test"` with createProcess, i can see the alert, but with runProcess I cannot. Either way the script it run. Why might this be?
10:23:29 <rwbarton> runProcess doesn't start a shell
10:23:40 <rwbarton> unless of course you are accounting for that already
10:24:00 <rwbarton> oh maybe I misunderstood
10:25:08 <quicksilver> see also the "full laziness" transform
10:25:19 <quicksilver> which, oddly, I can't find a good reference for with a quick google.
10:25:58 <rwbarton> anyways doesn't notify-send need some DBUS_* environment variables rather than (or in addition to) DISPLAY?
10:26:34 <dolio> quicksilver: Is that where you turn '\x -> let y = independent in ...' into 'let y = independent in \x -> ...'? I forget.
10:27:32 <shergill> majuscule: notify-send needs DBUS_SESSION_BUS_ADDRESS
10:28:01 <quicksilver> dolio: I think so yes.
10:33:39 <shergill> ah, it's been played around with. call by opportunity: http://www.cs.tufts.edu/~nr/cs257/archive/simon.../adaptive_speculation.ps
10:33:48 <shergill> arg, google
10:33:54 <edwardk> my copy of "Numerical Methods that Work" just arrived. on the cover _very very_ faintly embossed after the word 'that' is the word 'usually' in a way that it only appears when you catch it in the light ;)
10:34:31 <shergill> http://www.cs.tufts.edu/~nr/cs257/archive/simon-peyton-jones/adaptive_speculation.ps
10:35:11 <byorgey> edwardk: hehehe
10:35:26 <edwardk> shergill: rob ennals thesis is also a goldmine
10:35:29 <carter_> edwardk hows that numerical book look? I've been itching for a book that covers both the theory but manages to talk about what needs to be done in practice
10:35:48 <ski> roconnor : hm, can't you express `exists X_1,...,X_n. ' by `exists X. ' where `X' is a function ?
10:35:48 <edwardk> carter_: it just arrived. i haven't had much of a chance to dig into it
10:36:19 <shergill> edwardk: thanks for the reference
10:36:42 <edwardk> john cook recommended it, and said he'd read it a dozen times or so, so i took that as a good sign
10:37:36 <mroman> Can I combine fileName ~~? "*.java" ||? fileName ~~? ".css" ||? fileName ~~? ".jsp" somehow?
10:37:39 <mroman> (filemanip)
10:37:48 <edwardk> shergill: ennals' approach in that paper and in much more detail in his thesis has fascinated me since i first saw it.
10:39:29 <carter> byorgey: I think I may wind up using your monoidal tree for some scheduling algorithms I'm needing to work on, where in the diagrams repos (which I see are now in patchtag) can I find it?
10:39:45 <roconnor> ski: only in higher-order logic.
10:39:50 <mroman> hm.
10:39:56 <mroman> also ||? seems not to work this way
10:39:56 <byorgey> carter: diagrams-core:Graphics.Rendering.Diagrams.UDTree
10:40:07 <carter> thankee
10:40:08 <cheater_> hi how do you apply a function n times? foo :: a -> a
10:40:08 <byorgey> carter: I hope to clean it up a bit and split it out into its own package at some point
10:40:17 <ski> roconnor : why ?
10:40:19 <byorgey> cheater_: use 'iterate' and (!!)
10:40:24 <cheater_> i want foo $ foo $ foo $ foo $ x
10:40:25 <ski> roconnor : hmm
10:40:30 <roconnor> ski: because you cannot quantify over functions in first-order logic
10:40:35 <cheater_> byorgey: let me think about it
10:40:37 <cheater_> @type iterate
10:40:38 <lambdabot> forall a. (a -> a) -> a -> [a]
10:40:39 <ski> roconnor : oh, i was assuming we were in ZF or something
10:40:41 <roconnor> ski: which is basically the definition of first-order logic.
10:40:41 <cheater_> @type !!
10:40:42 <lambdabot> parse error on input `!!'
10:40:44 <carter> I may need to do that for you this week (albeit hackishly), I'm aiming to help a friend / cofounder get a YC app in for the summer
10:40:47 <cheater_> @type (!!)
10:40:48 <lambdabot> forall a. [a] -> Int -> a
10:40:53 <ski> roconnor : i see the point, now
10:41:05 <carter> assuming of course that it does what I think i want
10:41:11 <cheater_> > iterate (+1) 2
10:41:11 <byorgey> carter: hackishly would be OK to start
10:41:12 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
10:41:18 <byorgey> > iterate f x
10:41:19 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
10:41:22 <carter> byorgey: github or patchtag?
10:41:25 <mroman> Hm.
10:41:32 <cheater_> > iterate ('a':) []
10:41:33 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"...
10:41:37 <byorgey> carter: I'd prefer to keep it on patch-tag
10:41:38 <cheater_> > iterate ('a':) [] !! 7
10:41:39 <lambdabot>   "aaaaaaa"
10:41:41 <cheater_> nice
10:41:42 <cheater_> thanks
10:41:51 <carter> byorgey: i'll try to keep the repo choice kosher
10:41:58 <cheater_> wow iterate makes my mind bend.
10:42:07 <carter> btw: is there any recent version of darcs that builds on ghc 7.4?
10:42:08 <ski> roconnor : btw, the definition of "finite" here is that there is some natural number `n' such that the set is equipotent with `{m : |N | m < n}', yes ?
10:42:14 <cheater_> i wouldn't have expected this functionality to express iteration.
10:42:14 <chridi> has anybody a way to compile or interprete haskell sources on a openwrt machine?
10:42:24 <roconnor> ski: I guess
10:42:24 <td123> carter: darcs-beta does
10:42:40 <carter> td123: but is it beta or production in practice?
10:42:57 <mroman> ((fileName ~~? "*.java") ||? (fileName ~~? ".css") ||? (fileName ~~? ".jsp")) only gives me files matching *.java
10:42:59 <cheater_> chridi: why would you?
10:43:09 <td123> carter: sorry, dunno, I don't really use darcs :/
10:43:22 <td123> carter: given the name, it's probably not production ready :P
10:43:29 <byorgey> mroman: you forgot the * before .css and .jsp
10:43:35 <mroman> oh
10:43:40 <shergill> edwardk: is ennals code freely available, or have you had the chance to test it out/tinker with it?
10:43:41 <carter> td123: names are vague sans semantics / definitions
10:43:51 <mroman> *shameful hide*
10:44:10 <carter> cf how much work people put into HOAS etc
10:44:20 <edwardk> shergill: it used to be up on code.haskell or darcs.haskell at one point. i poked around in it, even tried a few toy stg evaluators of my own. bbiab
10:44:23 <KorriX> hello
10:44:35 <chridi> cheater_: because i find haskell neat
10:44:43 <roconnor> ski: I think you could try to proceed along your lines: by saying, in set theory, exists n, exists f : Fin n -> Set, forall i : Fin n. f i is nonEmpty ...
10:45:04 <roconnor> ski: but I think you end up needing to use finite choice to prove finite choice this way
10:45:14 <carter> does anyone have a handle on if darcs-beta is viable to use for serious or if i should just stick with my old 2.5 binary?
10:45:15 <roconnor> ski: which won't be acceptable.
10:46:10 <ski> roconnor : hm, could be
10:47:01 <KorriX> how to join lambdabot to the irc channel ?
10:47:07 <carter> time to find out empirically
10:47:48 <td123> carter: you should probably see if they have a changelog
10:47:56 <td123> carter: or release notes
10:49:14 <td123> carter: also, http://lists.osuosl.org/pipermail/darcs-users/2012-March/thread.html might be a better place to ask if no one knows here :)
10:49:55 <carter> td123 If no one knows on #haskell, that means no one is using it widely yet,
10:50:01 <carter> "widely"
10:51:02 <td123> don't forget lots of ppl are probably afk
10:51:14 <carter> http://darcs.net/releases/branch-2.8/
10:51:21 <carter> afk =?
10:51:33 <carter> i don't know that acronym
10:51:54 <td123> oh, away from keyboard :)
10:52:36 <carter> ah
10:53:09 <carter> http://darcs.net/releases/branch-2.8/NEWS
10:53:12 <carter> found the right file
10:53:22 <carter> wait, still out of date
10:53:30 <srhb> foo
10:53:32 <srhb> oops
10:57:32 <capiv12> hi
10:57:48 <KorriX> Polish haskell channel is now up - #haskell-pl
10:58:05 <capiv12> im in chat now...how do i go to step 4?
11:00:00 <b0fh_ua> Hi all! when building cabal-install on debian I'm getting the error: undefined reference to `rtsTimerSignal'
11:00:05 <b0fh_ua> what should I do about that?
11:00:21 <b0fh_ua> GHC 6.12.1
11:01:07 <td123> b0fh_ua: are you using debian's ghc?
11:01:53 <td123> cause if so, debian also ships its own cabal-install
11:02:37 <b0fh_ua> td123: yes, but I wanted to upgrade it. Anyway the same issue is caused when I try to install HUnit
11:03:35 <carter> byorgey: I may  be stealing your code and upsnazzing/specializing it with  the assumption that the monoidal things can be ordered
11:04:25 <byorgey> carter: OK, well in that case just make a fork =)
11:05:11 <byorgey> carter: in which case you can of course put it on github if you like
11:06:01 <carter> byorgey: roger, it'll be githubed then :p. I'm essentially actually just looking to have a 1D kdtree which keeps track of which intervals start, end or are properly contained in each sub tree
11:06:05 <slom> hi, how can I enable the replacement of operators with unicode chars in YI, with the pango frontend?
11:06:24 <td123> b0fh_ua: huh, I'm not really familiar with debian's problems but here is a link that looks similar to your problem http://askubuntu.com/questions/34390/problem-installing-cabal-1-8-0-2
11:31:53 * hackagebot libnotify 0.0.2.0 - Haskell binding for Libnotify  http://hackage.haskell.org/package/libnotify-0.0.2.0 (MatveyAksenov)
11:43:35 <dskippy1> I recently started using Graphics.GD and when I use setPixel on a PNG, the result is always black, no matter what RGB color I pass it. If I use fillImage, I can cover the enitre image in the color I want just fine. Anyone know about this issue?
11:44:41 <shergill> once you go black, you never go back.
11:48:32 <ion> Michael Jackson did.
11:49:11 <shergill> heh, touche
11:49:18 <NihilistDandy> The constraints are undefined for starting black.
11:49:23 <NemesisD> is there a simple way (i.e. not with lots of MVars or ST) to register cleanup code for when your application must exit?
11:49:49 <NemesisD> i tried finally but that didn't seem to work
11:50:31 <NemesisD> or rather it works sometimes, othertime i just get "Interrupted"
11:52:13 <NemesisD> oh, maybe runhaskell wasn't done compiling
11:53:28 <dmh> @source length
11:53:28 <lambdabot> length not available
11:53:59 <ski> @src length
11:53:59 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:54:08 <ski> @botsmack
11:54:08 <lambdabot> :)
11:54:44 <ski>   length :: [a] -> Int
11:54:48 <dmh> hrm
11:54:49 <ski>   length [    ] = 0
11:54:50 <ski>   length (_:as) = 1 + length as
11:55:04 <dmh> thx
11:55:14 <dmh> just wanted to compare my stab from memory
11:56:42 <dmh> i must be doing somethign wrong
11:57:15 <dmh> I lied, ghci :(
11:58:04 <ski> ?
11:58:12 <dmh> doesnt appear to work using lets ?
11:58:30 <dmh> Prelude> let len (_:xs) = 1 + len xs
11:58:30 <dmh> Prelude> let len [] = 0
11:58:37 <rwbarton> those are two separate definitions
11:58:42 <rwbarton> the second shadowing the first
11:58:46 <dmh> yea, so its shadowing huh
11:58:47 <dmh> aha
11:58:53 <vodik> hmm, are there any problems with writing: let loop = foo >> whenLoop loop in whenLoop loop?
11:58:55 <dmh> ok. didnt think it would work right in ghci as lets
11:59:03 <ski> you have to provide them at the same time
11:59:06 <rwbarton> let { len (_:xs) = 1 + len xs; len [] = 0 }
11:59:08 <Cale> dmh: let len [] = 0; len (_:xs) = 1 + len xs
11:59:13 <rwbarton> {} probably not mandatory
11:59:14 <dmh> oh, neat
11:59:19 <mroman> Didn't someone publish an article on how to write makefiles in haskell?
11:59:22 <ski> Prelude> let length :: [a] -> Int; len [] = 0; (_:xs) = 1 + len xs
11:59:23 <dmh> saves a lil time versus reloading file
11:59:27 <mroman> (somehow like that)
11:59:37 <ski> dmh : you can alternatively use `:{' and `:}' in GHCi
11:59:37 <dmh> appreciote it
11:59:49 <dmh> appreciate perhaps
12:00:51 <NihilistDandy> mroman: http://www.haskell.org/ghc/docs/5.00/building/sec-makefile-arch.html
12:01:12 <NihilistDandy> Though I think those are old docs
12:01:12 <dmh> one last question
12:01:15 <slyfox> ladies and gentlemen! i need an expert in c2hs implementation. do they happen to lurk here? It's about fresh http://www.mail-archive.com/gtk2hs-devel@lists.sourceforge.net/msg01160.html
12:01:18 <rwbarton> slightly yes :P
12:01:19 <mroman> No.
12:01:27 <mroman> I mean: You write haskellcode instead of makefiles.
12:01:42 <NihilistDandy> Very old~
12:01:47 <NihilistDandy> mroman: Oh… hmm
12:01:52 <NihilistDandy> I think I do remember something like that
12:01:54 <dmh> i would expect a type of, len :: [a] -> b
12:02:29 <dmh> or [a] -> Int
12:02:37 <dmh> but ghci reports len :: Num a => [t] -> a
12:03:02 <NihilistDandy> ghci tends to generalize
12:03:11 <dmh> hrm
12:03:17 <dmh> i wont try to ask why it inferred that
12:03:42 <NihilistDandy> Well, it's accurate
12:03:49 <NihilistDandy> It's just not quite what you want
12:03:51 <jackhill> Hi when installing packages through Cabal (in a virthualenv) the linking step the linking step eats up Lots of memory.
12:03:54 <dmh> i surely dont doubt it :p
12:04:08 <NihilistDandy> :D
12:04:22 <c_wraith> jackhill: ld is not very memory-efficient.  You can try alternate linkers, like gold
12:04:35 <jackhill> Has anyone seen this before? Is it expected? Likely a problem with my Haskell setup or my system linker? (ghc 7.0.4)
12:05:13 <c_wraith> jackhill: well-known.  Not an installation problem.  ld just isn't that good.
12:05:31 <jackhill> c_wraith: Okay, just wanted to see if it is expected.
12:05:46 <slyfox> i suspect ld.gold is even worse memory-wise
12:05:48 <jackhill> Maybe I'll try gold.
12:06:09 <c_wraith> eh.  People who've used gold report it's better, in terms of memory use.
12:06:14 <jackhill> If I install gold, do you know where I wold configure cabal to use it?
12:06:50 <c_wraith> I don't know how to control which linker ghc uses.
12:06:59 <dcoutts_> jackhill: it'd be more about getting gcc to use a different linker
12:07:06 <slyfox> it uses gcc
12:07:11 <dcoutts_> ghc (and thus cabal) use gcc as a linker
12:08:37 <qnikst> hello is there a way to make slice from STUArray?
12:08:43 <jackhill> I see. I don't think I'm ready to use gold to link all the packages on my system. What about ghc with the llvm backend?
12:09:03 <jackhill> (sorry, I'm new to the compiling process)
12:13:51 <byorgey> qnikst: I don't think so. perhaps you are interested in Repa ( http://hackage.haskell.org/package/repa )
12:14:03 <byorgey> which can do slices as well as quite a few other things.
12:14:58 <c_wraith> jackhill: llvm just produces .o files, same as ghc' native code gen.  linking is still done with the system linker
12:15:03 <c_wraith> *ghc's
12:16:04 <shepheb> can I request that our lambdabot join another channel that has nothing to do with Haskell? does it just honour some command? I can build my own under another nick, I suppose.
12:16:06 <ski> dmh : GHCi only sees that you use a literal `1' and the numeric operation `(+)' in your code. more types than `Int' support that, so it infers the general type `[a] -> b' where `b' is only required to be in the type-class `Num'
12:16:49 <ski> dmh : however, as i showed above, it's also possible to provide the type signature together with the definition, so you can get specifically `[a] -> Int' too, as well
12:17:01 <qnikst> byorgey, i think Repa will be overkill for my tutor task
12:17:09 <byorgey> qnikst: ok =)
12:17:31 <ski> (dmh : however, often it's interesting to not provide a type signature, and see which one it will infer, maybe it will infer a more general one than one would have thought of)
12:17:54 <qnikst> byorgey: but thanks )
12:18:15 <tran4> I'm a senior CS undergrad. student.  I applied directly to a company for these co-op and intern positions: http://pastebin.com/LdAH6eaZ  Are they worth doing?  I have no reply from the company but did get contacted by a recruiter whose ad I also applied to (the ad didnt say he was a recruiter) who wants to talk to me about the co-op position. Should i respond to him? The recruiter's ad has $14 / hr listed. The other legit ad that had a l
12:18:16 * ksf_ never types signature by hand
12:18:17 <mauke> The paste LdAH6eaZ has been copied to http://hpaste.org/65250
12:19:40 <byorgey> tran4: what sorts of things are you interested in?
12:19:54 <ski> ksf_ : not even when writing in a file ?
12:21:08 <byorgey> tran4: I doubt you would get to do any Haskell programming in that job.
12:21:15 <tran4> byorgey i dont know what i want to do yet. i was looking at software testing cause ive done some automatoin scripting before on windows computres
12:21:17 <ksf_> tran4, analysing the ad, I'd say they have no idea whatsoever about computers, and, worse (but not at all atypical) don't even know that they've got no idea.
12:21:42 <byorgey> yeah, it sounds pretty boring to me.  Sounds like it boils down to "fix computer stuff when it breaks"
12:21:45 <tran4> ksf_ yea but my parents want me to do something this summer and I live with them, and i havent been getting any replies for stuff ive been appliyn gtoo
12:22:14 <ksf_> google summer of code?
12:22:45 <shepheb> use Haskell for Code Jam, which starts in liek 40 minutes.
12:22:58 <shepheb> correction: 40 minutes ago.
12:23:16 <shepheb> I'm annoyed that I can't compete, employee of Google etc.
12:23:27 <gentleben> tran4: internships are good
12:24:01 <gentleben> tran4: and as a senior CS student you should be able to tackle more than just scripting
12:24:43 <ksf_> shepheb, well, they already pay you, there's no reason to pay you again as part of their brainstorming pool
12:24:49 <ksf_> ...even if said pool is underpaid.
12:25:17 <shepheb> ksf_: haha
12:25:36 <shepheb> and I'd be taking a spot from someone else, and I could in principle discover inside info about the challenges.
12:28:10 <niteria> @pl (\[a, b] -> (a, b))
12:28:10 <lambdabot> (line 1, column 3):
12:28:10 <lambdabot> unexpected "["
12:28:10 <lambdabot> expecting pattern
12:28:23 <niteria> @pl (\a -> (head a, head $ head a))
12:28:24 <lambdabot> liftM2 (,) head (head . head)
12:40:48 <dmwit> :t head . zip`ap`tail
12:40:48 <lambdabot>     Precedence parsing error
12:40:49 <lambdabot>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression
12:40:56 <dmwit> :t head . ap zip tail
12:40:57 <lambdabot> forall b. [b] -> (b, b)
12:41:31 <niteria> :t ap
12:41:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:41:58 * hackagebot nanoAgda 0.1.0 - A toy dependently-typed language  http://hackage.haskell.org/package/nanoAgda-0.1.0 (JeanPhilippeBernardy)
12:42:00 <colah> Does anyone else find themselves writing "\a -> case a of ..." a lot?
12:42:30 <dmwit> colah: No, usually I just put the patterns on the left of the = sign instead.
12:42:40 <colah> I'm thinking it would be cool to have an anonymous case syntax, lke so "caseof" = "\a -> case a of ..."
12:42:46 <dmwit> That almost always works (though there are certainly times when you need to use \a -> case a of!).
12:42:56 <dmwit> colah: Yep, there's been some proposals.
12:43:06 <dmwit> colah: One proposal is just to have \ introduce a block straight away.
12:43:10 <colah> dmwit: This is usually in dealing with monads, where its "return $ \a -> case a of.."
12:43:17 <cmccann> colah, could always use case analysis functions instead
12:43:26 <colah> That would be cool.
12:43:30 <cmccann> I've given serious consideration to hacking together some TH to auto-generate those
12:43:35 <colah> cmccann, could you go on?
12:43:48 <cmccann> colah, think "maybe" and "either"
12:43:58 <colah> Ah, I'm still kind of scared of TH.. :(
12:44:16 <cmccann> :t maybe
12:44:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:44:21 <dmwit> colah: If you post a bit more code, we may be able to give more situational advice.
12:44:24 <dmwit> ?hpaste
12:44:24 <lambdabot> Haskell pastebin: http://hpaste.org/
12:44:39 <roconnor> edwardk: what is memoized about Control.Comonad.Trans.Traced.Memo?
12:45:00 <edwardk> don't remember. going to look =)
12:45:06 <colah> It isn't really one specific thing. I just noticed that I was doing it a lot.
12:45:10 <colah> Thanks though :)
12:45:37 <colah> Presently I'm writing a pattern matcher like case for ImplicitCAD's extopenscad. Cause I love case so much :)
12:45:40 <edwardk> i think it stuffs the answer for mempty in the structure
12:45:44 <edwardk> yeah
12:45:45 <edwardk> thats it
12:45:52 <edwardk> data TracedT m w a = TracedT (w (m -> a)) (w a)
12:46:02 <edwardk> it holds onto the answer for m = mempty as the second (w a)
12:46:22 * ski yesterday wanted to point gaze___ to "Marshalling functions was: Transmitting Haskell values" <http://www.haskell.org/pipermail/glasgow-haskell-users/2003-October/005896.html> and "Survey on Marshalling in Functional Programming Languages" <http://web.archive.org/web/20070706205236/http://durchholz.org/jo/fpl-marshalling-survey/index.html>
12:46:45 <cmccann> colah, well, the result would just be a TH function you could use, e.g. "$(caseAnalysis [''Maybe])" or whatever would define "maybe" for you (if it didn't already exist)
12:46:48 <edwardk> its by analogy to the other memoized versions in there, which isn't to say it stores the whole memo-trie for m -> a in a polynomial functor with representation m, which i think i do in another data type
12:47:08 <edwardk> i never did check to see if the .Memo versions actually helped in practice
12:47:33 <colah> cmccann: Thats pretty cool. I may need to play around with that :)
12:48:14 <cmccann> colah, instead of "\a -> case a of ..." you'd use the case analysis function
12:48:30 <cmccann> and then one argument to it for each case
12:48:37 <cmccann> it doesn't give you everything pattern matching does though
12:48:48 <cmccann> colah, well, this doesn't exist yet :]
12:48:53 <cmccann> it's just something I've been meaning to do
12:49:35 <cmccann> with the new GHC generics stuff you could do it without TH, I think
12:50:11 <dmwit> How hard would it be to make a parser with two alternatives like this:
12:50:52 <dmwit> lambda = string "\" >> (layoutAwarePatternParser <|> backwardsCompatibleNoLayoutParser)
12:50:59 <dmwit> ?
12:52:41 <dmwit> I mean, I know CFGs are closed under concatenation and union (right?), but I suppose layout isn't exactly context-free.
12:53:24 <colah> cmccann: I like this idea a lot :)
12:54:11 <cmccann> colah, it's a handy approach
12:54:24 <ski> colah : O'Caml has this, with the `function <pat> -> <expr> | ... | <pat> -> <expr>' syntax ..
12:54:31 <Ralith> dmwit: I speculate that that might be nondeterministic
12:54:53 <cmccann> colah, for recursive types you probably want both a recursive and single-step version, e.g. for lists that would be foldr and uncons, respectively
12:55:13 <ski> cmccann : Charity has that
12:55:55 <ski> @where Charity
12:55:55 <lambdabot> http://pll.cpsc.ucalgary.ca/charity1/www/home.html
12:56:01 <cmccann> ski, has what? case analysis functions defined automatically?
12:56:21 <ski> cmccann : special syntax for case analysis functions, as well as folding functions
12:56:38 <ski> (and record construction function, as well as unfolding, for coinductive types)
12:56:58 * hackagebot th-build 0.2.0.0 - More convenient construction of TH ASTs  http://hackage.haskell.org/package/th-build-0.2.0.0 (DanielSchuessler)
12:57:11 <ski> (if fact, it *doesn't* have a `case' construction, nor does it have general recursion)
12:57:18 <niteria> how do I export the type but not it's constructors?
12:57:24 * cmccann dubiously regards the licensing requirements for charity
12:57:32 <ski> niteria : mention the type only
12:57:48 <ski> niteria : you must name all the constructors differently from the type, iirc
12:57:53 <niteria> oh
12:58:02 <cmccann> can also export Foo() I think
12:58:03 <rwbarton> module M (..., T(), ...) -- I thought
12:58:18 <ski> hm, that may also work
12:58:30 <cmccann> I think Foo and Foo() are the same where that makes sense
12:58:32 <cmccann> but I'm not sure
12:58:59 <roconnor> edwardk: ah okay.  I was thinking that the whole function m -> a was memoized.
12:59:04 * ski would like to be able to export a `type' as an abstract data type
12:59:23 <dskippy1> Does anyone have any recommendations for a graphics drawing library? I found GD, I think there's a bug. I might switch to Cairo. I want to draw lines on PNGs.
12:59:32 <cmccann> ski, that's called "newtype" :P
12:59:35 <roconnor> edwardk: 'cause I wanted to say that the stream comonad is just a memoized (Nat,+)-traced comonad.
12:59:42 * ski would also like to be able to mark the fact that a type was defined as a synonym as deprecated (but the type itself isn't deprecated)
12:59:59 <ski> cmccann : no, that means i have to write the code inside the module differently
13:00:07 <roconnor> edwardk: which then makes me wonder what (Nat,min)-traced comonads might be useful for.
13:00:09 <niteria> Foo and Foo() gives the same result
13:00:12 <parcs`> how do i turn a Q [Exp] into a Q Exp?
13:00:21 <roconnor> or (Nat,max)-traced comonads.
13:00:45 <cmccann> ski, why not ask for recursive definitions with type as well? :P
13:00:52 <parcs`> hmm, i think someone asked this question a couple of days ago
13:00:56 <niteria> it's kind of awkward because I have Array i e = Array (Tree i e)
13:00:59 <byorgey> parcs`: there are lots of ways.  it depends.
13:01:13 <byorgey> parcs`: how do you turn an [Exp] into an Exp?
13:01:17 <niteria> i should probably use newtype
13:01:17 <ski> cmccann : the "restricted type synonym" extension in Hugs, <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5>, is basically what i want
13:02:10 <byorgey> parcs`: i.e. you are being given multiple expressions, how do you want to combine them into one?
13:02:27 <ski> cmccann : that one lets one restrict the visibility of the definiendum of the type synonym definition to just certain definitions -- only being able to restrict it to the current module would suffice, though
13:02:37 <cmccann> ski, I dunno, I think it's already too unclear exactly how meaningful type synonyms are
13:02:40 <ski> cmccann : btw, SML and O'Caml allows this latter option
13:02:56 <cmccann> I mean, yeah, I see the utility here, certainly
13:04:34 <cmccann> but I'd be more inclined to do something like module-local declarations that relate a newtype to, uh, an old type
13:04:46 <cmccann> so that you could use them interchangeably inside a module
13:05:15 <ski> i thought that's what restricted type synonyms are doing ?
13:05:42 <roconnor> @hoogle range
13:05:42 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
13:05:43 <lambdabot> Data.Ix rangeSize :: Ix a => (a, a) -> Int
13:05:43 <lambdabot> Language.Haskell.TH.Syntax data Range
13:05:50 <roconnor> @hoogle inRange
13:05:50 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
13:06:04 <ski> cmccann : or you mean for a given pre-existing `newtype' ?
13:06:15 <roconnor> > inRange ('a','z') 'a'
13:06:16 <lambdabot>   True
13:06:17 <roconnor> > inRange ('a','z') 'z'
13:06:18 <lambdabot>   True
13:06:54 <mauke> > 1 `inRange` (2,3)
13:06:55 <lambdabot>   False
13:06:57 <cmccann> ski, yeah. and I'm specifically avoiding "type" here because I'd rather avoid treating those as first class entities
13:07:14 <ski> > (2,3) `inRange` 1
13:07:15 <lambdabot>   False
13:07:17 <cmccann> liberal type synonyms is already dubious enough
13:07:26 <ski> > inRange (0,1) (1%2)
13:07:27 <lambdabot>   No instance for (GHC.Arr.Ix (GHC.Real.Ratio t))
13:07:27 <lambdabot>    arising from a use of `G...
13:07:27 <DanBurton> tl;dr inRange is inclusive
13:08:06 <roconnor> > (ord 'A' - ord 'a')
13:08:07 <lambdabot>   -32
13:08:11 <ski> cmccann : liberal referring to allowing quantification and constraints in synonyms ?
13:08:26 <DanBurton> > chr (ord 'z' + 1)
13:08:27 <lambdabot>   '{'
13:08:34 <ski> > succ 'z'
13:08:35 <lambdabot>   '{'
13:08:48 <DanBurton> > 'a' < 'A'
13:08:49 <lambdabot>   False
13:08:55 <cmccann> ski, referring to the LiberalTypeSynonyms extension
13:09:18 <DanBurton> > (succ 'Z', succ 'Z' `inRange` ('A' .. 'z'))
13:09:19 <lambdabot>   <no location info>: parse error on input `..'
13:09:35 <cmccann> which allows various stuff, including partially-applied type synonyms in some situations
13:09:36 <DanBurton> > (succ 'Z', succ 'Z' `inRange` ('A', 'z'))
13:09:37 <lambdabot>   Couldn't match expected type `(a, a)'
13:09:37 <lambdabot>         against inferred type `GHC.Ty...
13:09:38 <ski> (i'm not sure if by "avoiding \"type\"" you mean avoiding that term, or avoiding the keyword `type' which introduces a type synonym)
13:09:40 <DanBurton> wat :(
13:09:56 <roconnor> http://www.reddit.com/r/haskell/comments/qsdeu/needing_help_with_mapping_function/c40o38h?context=1
13:09:57 <DanBurton> oh flipped
13:09:58 <cmccann> ski, the keyword/type synonyms, sorry
13:11:35 <ski> > (('A', 'z') `inRange`) `graph` succ 'Z'
13:11:36 <lambdabot>   ('[',True)
13:12:45 <cmccann> ski, with LiberalTypeSynonyms you can do stuff like church numeral arithmetic and some other simple "functions" using only type synonyms
13:12:52 <JoeyA> What's a good way to transform binary data efficiently?  (e.g. escape backslashes in a ByteString)
13:13:00 <cmccann> (though church numeral exponentiation requires polykinds I think)
13:13:14 <JoeyA> I did it with a simple ByteString.concatMap, but it takes 125x as long as my C version.
13:14:11 <ski> cmccann : yeah, just checked up the extension
13:14:44 <ski> cmccann : i'm not sure where "treating those as first class entities" comes into the picture, though
13:15:35 <ski> with restricted type synonyms, it acts like a type synonym in the restricted scope, and like an abstract type (like a `data' or `newtype' without any exported constructors) outside of it
13:15:38 <hiptobecubic> I'm building a big tree using  "iterate f l", where l are the leaves, all at depth N, and f is a function to compute the N-1 nodes given the leaves.  At the end, i'm interested in the root value, so I know the whole tree needs to be evaluated entirely. is this reasonable?   "let force = deepseq (f l) (f l) in  iterate (force f) l"
13:16:16 <hiptobecubic> I haven't used seq or deepseq before so i'm not sure what "normal" usage looks like
13:16:34 <ski> (.. s/force =/force f =/ ?)
13:16:49 <ski> (er, also `l' as argument, i suppose)
13:17:15 <ClaudiusMaximus> let thunk = buzzard quail albatross in deepseq thunk thunk
13:17:35 * ski would expect `deepseq (f l) (f l)' to be the same as just `f l' ..
13:18:06 <ClaudiusMaximus> worse - it forces (f l) doing loads of work, then creates a different (f l) and doesn't force it at all
13:18:10 <cmccann> ski, I'm dubious about giving type synonyms any meaning beyond the type they expand to is all
13:18:43 <cmccann> because that steps away from simple shorthands/aliases/synonyms/&c. to being a distinct sort of thing in their own right
13:18:58 <edwardk> roconnor: ah
13:19:11 <edwardk> roconnor: i have a memoized traced comonad somewhere else using representable-tries
13:19:12 <ski> cmccann : with restricted type synonyms, it *is* a type synonym inside the scope, and it's *not* a type synonym outside of it, so i don't see how this would be "giving type synonyms any meaning beyond the type they expand to"
13:19:16 <edwardk> its in an -extras package of some sort
13:19:49 <ski> (or rather s/not/not known to be/, but that amounts to the same thing)
13:19:52 <ClaudiusMaximus> hiptobecubic: you might find strict data and iterate' f x = x : (iterate f $! f x)  to be sufficient, it works for me
13:20:01 <hiptobecubic> ski, well testing it just now, it's about twice as slow with deepseq as i described it
13:20:21 <niteria> @hoogle [a] -> (a, [a])
13:20:21 <lambdabot> Data.Char readLitChar :: ReadS Char
13:20:22 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
13:20:22 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
13:20:43 <ski> hiptobecubic : yes, i was just commenting on that it seems to me that that `deepseq' call doesn't do anything at all (except add overhead)
13:20:53 <ClaudiusMaximus> > iterate succ 0 !! 100000
13:20:54 <lambdabot>   100000
13:21:03 <ski> @type head &&& tail
13:21:04 <lambdabot> forall c. [c] -> (c, [c])
13:21:14 <niteria> :)
13:21:17 <ski> @type init &&& last
13:21:18 <lambdabot> forall a. [a] -> ([a], a)
13:21:29 <ski> > (head &&& tail) []
13:21:29 <lambdabot>   (*Exception: Prelude.head: empty list
13:21:35 <cmccann> ski, yeah, I don't have any major objections here, I'm just suspicious of features involving type synonyms I suppose
13:22:02 <hiptobecubic> I'm trying to avoid building a giant tree of thunks and then walking back down to the leaves and then walking back up to the root again
13:22:06 <ski> cmccann : ok
13:22:20 <ClaudiusMaximus> @hoogle levels
13:22:20 <lambdabot> Data.Tree levels :: Tree a -> [[a]]
13:22:21 <lambdabot> Graphics.UI.GLUT.Objects type NumLevels = GLint
13:23:14 <ClaudiusMaximus> oh wait, you're going the other way
13:23:15 <ski> (ftr, i don't think of type synonyms as "being a distinct sort of thing in their own right" -- contrarily, i think of all of `data',`newtype',`type' as being different ways of implementing the same basic thing, a type)
13:23:56 <ski> hiptobecubic : hm, does the element at each node only depend (directly) on the elements of the direct child nodes ?
13:24:00 <hiptobecubic> ClaudiusMaximus, the tree is defined by the leaves, and then working back up to the root.
13:24:24 <hiptobecubic> ski, yes.
13:24:25 * ski thinks this backward-tree building sounds related to bar-induction
13:24:45 <ski> and this is a binary tree ?
13:25:24 <hiptobecubic> start with list of leaves, f folds over the list making a new list of nodes which is of length  (length leaves - 1)
13:25:28 <hiptobecubic> ski, recombinant, but yes
13:25:34 <ski> perfectly balanced ?
13:25:56 <hiptobecubic> yes
13:25:57 * ski isn't sure what "recombinant" means (DAG ?)
13:26:20 <ski> hm, oh
13:26:26 <hiptobecubic> ski, it means that taking the left child and then right child gives you the exact same node as if you had taken the right and then left
13:26:49 <ski> ah, right, so it's a kind of DAG, really (not a proper tree)
13:26:51 <parcs`> byorgey: i would like to interpolate each expression and mconcat them
13:27:25 <ski> (hiptobecubic : ok, so one could state that as path direction commuting)
13:27:47 <byorgey> parcs`: well, if you can write a function  foo :: [Exp] -> Exp,  then  fmap foo :: Q [Exp] -> Q Exp
13:28:00 <cdh473> If I want to remove all the lowercase letters in a string, what are the advantages of a list comprehension over regex?
13:28:06 <hiptobecubic> ski, ok, yes.
13:28:39 <byorgey> parcs`: alternatively, if the combining function needs access to the Q monad you can write   foo :: [Exp] -> Q Exp, and then   (>>= foo) :: Q [Exp] -> Q Exp
13:28:44 <lispy> cdh473: removing all the <some property> elements of a string is a filter operation. list comprehensions are good at filtering.
13:29:28 <rwbarton> ListE :: [Exp] -> Exp is a start
13:29:31 <parcs`> :t [| () |]
13:29:32 <lambdabot> parse error on input `|'
13:29:48 <parcs`> aw, lambdabot doesn't support th
13:29:57 <rwbarton> something like \xs -> AppE 'mconcat $ ListE xs
13:29:59 <hiptobecubic> I'm just trying to avoid building up a tree of thunks.
13:30:05 <ski> hiptobecubic : and you're only interested in the root element in the end, yes ?
13:30:27 <hiptobecubic> ski, yes.
13:30:29 <rwbarton> or I guess you need to get at mconcat some other way
13:30:35 <rwbarton> involving Q
13:32:00 <rwbarton> perhaps something like foldr (\x1 x2 -> [| $(x1) `mappend` $(x2) |]) [| [] |] is simplest? (working from memory here)
13:32:11 <ski> hiptobecubic : hm, i suppose you could either build your list, then traverse it to the end, making sure to evaluate each list element at each intermediate level before
13:32:22 <hiptobecubic> ski, i thought deepseq would do that
13:32:28 <rasfar> (lispy, thanks for the advice about cofiguring my chat client to ignore joined/leaving messages)
13:32:30 <ski> hiptobecubic : or you could make the transition function evaluate each element of the list before computing the next list
13:32:57 <ski> hiptobecubic : well, it can, but you didn't use it like that
13:33:10 <ski> also, `deepseq' is often overkill
13:33:15 <parcs`> rwbarton: i tried the latter thing, ghc complains about a "stage restriction"
13:33:22 <hiptobecubic> ski, oh. I must have misunderstood it's usage then
13:33:34 <ski> given a list `l' you should first evaluate *`l'* (not `f l'), before returning `f l'
13:33:53 <rwbarton> curious
13:33:55 <hiptobecubic> hm
13:34:05 <ski> hiptobecubic : you might alternatively use `unfoldr' instead of `iterate'
13:34:15 <hpaste> edwardk pasted “Nesterov's dual averaging algorithm” at http://hpaste.org/65254
13:34:16 <rwbarton> I thought this was exactly what $() within [| ... |] was for...
13:34:32 <niteria> @hoogle (a -> b, a -> c) -> [a] -> [(b, c)]
13:34:33 <lambdabot> No results found
13:34:51 <ski> hiptobecubic : and by "evaluate `l'", i mean walk through the list, evaluating each element in whatever way you prefer (e.g. a simple `seq' might suffice)
13:34:54 <cdh473> can someone show me how I would write a simple strToLower function that just converts all uppercase letters in a string to lowercase?
13:35:03 <niteria> @hoogle (a -> b, a -> c) -> [a] -> ([b], [c])
13:35:04 <lambdabot> No results found
13:35:10 <hiptobecubic> ski, isn't that what deepseq does?
13:35:12 <niteria> huh, no way
13:35:23 <lispy> rasfar: cool, glad it helps :)
13:35:31 <niteria> @hoogle (a -> b) -> (a -> c) -> [a] -> ([b], [c])
13:35:31 <lambdabot> No results found
13:35:47 <niteria> @hoogle (a -> b) -> (a -> c) -> [a] -> [(b, c)]
13:35:47 <lambdabot> No results found
13:35:54 <DanBurton> @hoogle (a -> b) -> (a -> c) -> a -> (b, c)
13:35:54 <lambdabot> No results found
13:36:22 <DanBurton> @hoogle (f a b) -> (f a ) -> f a (b, c)
13:36:22 <lambdabot> Data.Graph.Inductive.Query.MaxFlow maxFlowgraph :: (DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> gr a (b, b)
13:36:23 <ski> hiptobecubic : two no:s : (a) `deepseq' recursively tries to evaluate *all* of the structure (this is often overkill, and sometimes you don't even want all of the structure evaluated); (b) this doesn't really matter here anyway, since you didn't use `deepseq' correctly anyway
13:36:26 <DanBurton> wat :(
13:36:43 <rwbarton> you dropped a c
13:36:43 <hiptobecubic> ski, :D
13:36:44 <ski> hiptobecubic : writing `seq foo foo', as well as `deepseq foo foo' is never better than writing `foo' itself
13:36:59 <DanBurton> @type &&&
13:37:00 <lambdabot> parse error on input `&&&'
13:37:03 <DanBurton> @type (&&&)
13:37:04 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:37:10 <hiptobecubic> ski, doesn't seq foo foo, evaluate foo and then return foo?
13:37:26 <rwbarton> it does
13:37:30 <ski> hiptobecubic : because in `seq foo foo' the first `foo' is evaluated only in case the whole thunk is evaluated, in which case the second `foo' will also be evaluated -- so writing like this never helps
13:37:34 <rwbarton> when it is evaluated
13:37:37 <rwbarton> just like foo
13:37:46 <hiptobecubic> ski, oh
13:37:49 <ClaudiusMaximus> seq foo foo evaluates the first foo to WHNF when the second foo is forced to WHNF
13:37:51 <DanBurton> @type \f g -> map (f &&& g)
13:37:52 <lambdabot> forall a c c'. (a -> c) -> (a -> c') -> [a] -> [(c, c')]
13:38:18 <niteria> arrows to the rescue
13:38:32 <DanBurton> arrows are only useful for their (->) instance :P
13:38:49 <ski> hiptobecubic : so, e.g. something like `foldr seq (f l) l' might suffice in your case
13:39:19 <ski> hiptobecubic : this will evaluate the root of each element in `l' before (evaluating and) returning `f l'
13:39:45 <hiptobecubic> isn't that backwards?
13:39:46 <ski> hiptobecubic : if you want to evaluate more than the root of the element, you can swap out `seq' there
13:39:47 <hiptobecubic> :t seq
13:39:48 <lambdabot> forall a t. a -> t -> t
13:39:51 <ski> no
13:40:06 <hiptobecubic> a is evaluated and t is returned?
13:40:10 <DanBurton> > (\l -> foldr seq (f l) l) [1,2,3]
13:40:11 <lambdabot>   Ambiguous type variable `b' in the constraints:
13:40:11 <lambdabot>    `GHC.Show.Show b'
13:40:11 <lambdabot>      a...
13:40:13 <ClaudiusMaximus> > let f = seq f "pheasant" in f
13:40:17 <lambdabot>   mueval-core: Time limit exceeded
13:40:31 <ski>   foldr seq (f [a,b,c]) [a,b,c]  =  seq a (seq b (seq c (f [a,b,c])))
13:40:33 <DanBurton> > (\f l -> foldr seq (f l) l) id [1,2,3]
13:40:34 <lambdabot>   [1,2,3]
13:40:43 <niteria> @type map (minimum &&& maximum)
13:40:44 <lambdabot> forall a. (Ord a) => [[a]] -> [(a, a)]
13:40:51 * cmccann wants an Arrow-like class that allows an instance for ⊸
13:40:57 <ski> hiptobecubic : and i think you wanted more or less that, no ?
13:41:11 <hiptobecubic> ski, i don't know yet. I'm trying to figure out what you all are doing :)
13:41:45 <rwbarton> parcs`, "Prelude Data.Monoid Language.Haskell.TH.Syntax> :t foldr (\x1 x2 -> [| $(x1) `mappend` $(x2) |]) [| [] |]" worked for me
13:42:02 <ski> cmccann : for `-' ?
13:42:09 <DanBurton> [| [] |] -- ugh
13:42:40 <cmccann> ski, er
13:42:46 <cmccann> was supposed to be linear implication
13:43:02 <cmccann> but might be unreadable in your font
13:43:04 <ski> oh
13:43:32 <worldsayshi> Q to anyone: Is there a modulus operation for floats in haskell?
13:43:44 <rwbarton> mod'
13:43:50 <ski> (well, it was unreadable yes. viewing it in a graphical browser seemed to show a `-' sign, though -- maybe an m-dash, i dunno)
13:44:00 <ski> @hoogle mod'
13:44:00 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
13:44:00 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
13:44:46 <worldsayshi> aha! Thanks ski and rwbarton!
13:44:53 <ski> yw :)
13:45:50 <ski> hiptobecubic : anyway, the idea of `seq' is that you want to tell the computer to evaluate another expression *as* it's evaluating a certain expression
13:46:15 <ski> hiptobecubic : telling it to also evaluate `foo' whenever it evaluates `foo' isn't very useful, as you can imagine ;)
13:46:23 <hiptobecubic> I see
13:48:07 <DanBurton> > 3 `mod'` 1.5
13:48:09 <lambdabot>   0.0
13:49:51 <cdh473> > mod 3 2
13:49:52 <lambdabot>   1
13:49:57 <ski> > 3 `mod'` 0
13:49:58 <lambdabot>   *Exception: Ratio.%: zero denominator
13:49:59 <ski> :(
13:50:11 <DanBurton> what does mod 0 even mean o_O
13:50:19 <ski> `mod n 0' should be `n'
13:50:24 <cdh473> the remainder of division by 0
13:50:44 <DanBurton> shouldn't it be 0?
13:50:45 <cdh473> subtract 0 as many times as possible :P
13:50:50 <ski> DanBurton : no
13:51:17 <DanBurton> suppose you're dealing with numbers modulo 5. That means all numbers are equivalen to either 0, 1, 2, 3, or 4
13:51:20 <rwbarton> x = (x `div` y) * y + (x `mod` y)
13:51:39 <DanBurton> so modulo 0 under that definition means that there is no equivalence class at all
13:51:48 <cdh473> DanBurton: It won't be any real number at all
13:51:53 <vodik> > toIntegral 1.5
13:51:54 <lambdabot>   Not in scope: `toIntegral'
13:52:05 <rwbarton> DanBurton: 0, 1, 2, 3, 4 are representatives of Z/5Z
13:52:05 <vodik> > toInteger 1.5
13:52:06 <lambdabot>   Ambiguous type variable `t' in the constraints:
13:52:06 <lambdabot>    `GHC.Real.Integral t'
13:52:06 <lambdabot>   ...
13:52:18 <rwbarton> Z/0Z is just Z so the representatives are every integer
13:52:29 <ski> considering a dividend `n' a divisor `d', we are looking for quotients `q' and remainders `r' such that `n = q*d + r'
13:52:42 <DanBurton> Z/0Z is just Z? I disagree: it reduces to 1/0
13:52:44 <cdh473> is it possible to use lambdabot similarly to ECMAbot in that you can do multiple lines of code on 1 line?
13:52:47 <ski> in case `d' is zero, this can only be true if `r' is equal to `n'
13:52:48 <rwbarton> "x `mod` y is the smallest nonnegative integer z such that x - z is a multiple of y"
13:52:52 <rwbarton> Z/0Z is Z
13:52:59 <rwbarton> (Z = the integers)
13:53:01 <ski> (and `q' isn't in general uniquely determined here)
13:53:07 <DanBurton> oh that Z
13:53:20 <DanBurton> needs more unicode
13:53:24 * ski . o O ( das Ganze Zahlen )
13:53:37 <rwbarton> (... I guess when x is negative and y = 0 then z won't be nonnegative)
13:54:21 <rwbarton> Anyways it's not as bad as the gcd 0 0 thing :)
13:54:34 <ski> rwbarton : the "nonnegative" part only makes sense in case you can always choose a non-negative representant, imo
13:54:39 <ski> bad ?
13:54:47 <ski> `gcd 0 0' should obviously be `0'
13:54:53 <rwbarton> > gcd 0 0
13:54:54 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
13:54:59 <ski> anything is bad -- maybe that's what you meant :)
13:55:16 <rwbarton> I meant "3 `mod` 0 being undefined" is not as bad as "gcd 0 0 being undefined" imo
13:55:19 <hpaste> hiptobecubic pasted “Thunk Tree” at http://hpaste.org/65255
13:55:29 <ski> ("greatest" obviously referring to the divisibility ordering, not to the additive ordering)
13:55:37 <ski> ok
13:55:45 <rwbarton> right, there's no real excuse for gcd 0 0
13:55:49 <DanBurton> hrm wikipedia article on gcd doesn't mention 0 :(
13:55:56 <ski> (er, s/anything is/anything else is/)
13:56:19 <hiptobecubic> This function is kind of spaghetti I guess, but perhaps you can see what I'm referring to anyway
13:56:45 <hiptobecubic> Ignore the force f l = seq (f l) l, line, i was in the middle of changing it when I made the paste
13:56:50 <ski> cdh473 : no, but you can usually use non-layout with `let' and `where'
13:56:51 <shepheb> trying to cabal install lambdabot and I'm getting: can't load .so/.DLL for: /usr/lib/gcc/i686-pc-linux-gnu/4.6.3/../../../libncurses.so (-
13:56:54 <shepheb> lncursesw: cannot open shared object file: No such file or directory
13:57:03 <cdh473> thanks, ski
13:57:13 <hiptobecubic> also, it does hlint automatically? that's nice
13:57:32 <rwbarton> > 0^0
13:57:33 <lambdabot>   1
13:57:36 <rwbarton> :D
13:57:40 <cdh473> wut
13:57:46 <rwbarton> 1 out of 3 isn't bad I suppose
13:57:51 <DanBurton> shepheb: it seems you need the curses library. Do you have it installed?
13:58:02 <rwbarton> > 0^^0
13:58:03 <ski> > let length :: [a] -> Int; length [    ] = 0; length (_:as) = 1 + length as  in  map length (words "Universal Algebra")  -- cdh473, like this e.g.
13:58:03 <lambdabot>   1.0
13:58:03 <lambdabot>   [9,7]
13:58:05 <rwbarton> > 0**0
13:58:06 <lambdabot>   1.0
13:58:14 <shepheb> DanBurton: yep. the file actually exists, and that wonky path is correct, though definitely weird.
13:58:17 <cdh473> oh cool
13:59:03 <cdh473> > let trigOpp hyp theta = (sin theta) * hyp; trigOpp 2 5
13:59:04 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:59:18 <cdh473> hrm
14:00:53 <rwbarton> "in", not ";"
14:01:01 <rwbarton> needs to be a single expression
14:01:20 <JoeyA> Hmm, Data.ByteString.Lazy.foldr isn't lazy...
14:01:40 <JoeyA> This will leak memory if fed /dev/zero: L.getContents >>= L.putStr . L.foldr L.cons L.empty
14:01:44 <cdh473> > let trigOpp hyp theta = (sin theta) * hyp in trigOpp 2 5
14:01:45 <lambdabot>   -1.917848549326277
14:01:49 <cdh473> very fancy
14:03:17 <cdh473> so it's more or less not really allowing you to make full programs like that
14:03:58 <ski> cdh473 : you can also :
14:04:03 <ski> @let trigOpp hyp theta = (sin theta) * hyp
14:04:04 <lambdabot>  Defined.
14:04:07 <ski> > trigOpp 2 5
14:04:08 <lambdabot>   -1.917848549326277
14:04:51 <cdh473> > let trigAdj hyp theta = (cos theta) * hyp
14:04:52 <lambdabot>   not an expression: `let trigAdj hyp theta = (cos theta) * hyp'
14:04:56 <cdh473> aha
14:05:00 <cdh473> i see why now
14:06:11 <clintm> are any of you using yi regularly?
14:08:16 <cdh473> is Integer suitable for arbitrary addition?
14:08:48 <rostayob> cdh473: what's arbitrary addition?
14:08:53 <cdh473> eek
14:09:05 <cdh473> i meant as in allowing you to do infinitely large addition
14:09:27 <rostayob> well yes integer are arbitrary precision integer, so...
14:09:37 <rostayob> *Integer is
14:10:26 <cmccann> I don't think Integer supports infinitely large additions
14:11:15 <rostayob> well it supports what gmp numbers support
14:11:27 <rostayob> which is... 2^very_large_number
14:11:35 <cdh473> @let factorial n = product [1..n]
14:11:36 <lambdabot>  Defined.
14:12:05 <tromp__> > bit 30
14:12:06 <lambdabot>   Ambiguous type variable `a' in the constraint:
14:12:06 <lambdabot>    `Data.Bits.Bits a'
14:12:06 <lambdabot>      a...
14:12:13 <tromp__> > bit 30 :: Integer
14:12:14 <lambdabot>   1073741824
14:12:15 <cdh473> > sum (factorial 500) (factorial 500)
14:12:16 <lambdabot>   No instances for (GHC.Num.Num [t -> a], GHC.Enum.Enum [t -> a])
14:12:16 <lambdabot>    arising ...
14:12:27 <sipa> cmccann: there are no infinitely large integers :)
14:12:35 <tromp__> > bit 300 :: Integer
14:12:36 <lambdabot>   203703597633448608626844568840937816105146839366593625063614044935438129976...
14:12:36 <cmccann> rostayob, infinity is a lot bigger than 2^very_large_number ;P
14:12:38 <rostayob> sipa: just because there is no infintely large memory
14:12:46 <tromp__> > bit 3000000 :: Integer
14:12:47 <lambdabot>   970491963890071156409914258786623573025219449663262837980185560987767250767...
14:12:49 <rostayob>  but actually gmp has a limit, apart from memory
14:12:50 <sipa> rostayob: +infinity is not an integer
14:12:55 <tromp__> > bit 30000000000000 :: Integer
14:12:55 <lambdabot>   gmp: overflow in mpz type
14:12:57 <cdh473> > sum (factorial 500 :: Integer) (factorial 500 :: Integer) :: Integer
14:12:58 <lambdabot>   Couldn't match expected type `[a]'
14:12:58 <lambdabot>         against inferred type `GHC.Integ...
14:13:03 <cdh473> > sum (factorial 500 :: Integer) (factorial 500 :: Integer) :: Integer
14:13:04 <lambdabot>   Couldn't match expected type `[a]'
14:13:04 <lambdabot>         against inferred type `GHC.Integ...
14:13:06 <cdh473> ahh
14:13:10 <roconnor> rostayob: really? what is GMP's limit?
14:13:14 <tromp__> sum is for lists!
14:13:17 <rostayob> roconnor: I don't know, I read it somewhere
14:13:18 <roconnor> > maxBound :: Integer
14:13:18 <cmccann> sipa, sure there are. data Nat = Z | S Nat, infinity = S infinity
14:13:18 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
14:13:19 <lambdabot>    arising from...
14:13:23 <cdh473> lol oops
14:13:37 <tromp__> > bit 300000000000 :: Integer
14:13:37 <lambdabot>   gmp: overflow in mpz type
14:13:39 <cdh473> > sum [factorial 500 :: Integer, factorial 500 :: Integer] :: Integer
14:13:40 <lambdabot>   244027365198222013740247757084609385250714868560638568438482717677169074630...
14:13:41 <tromp__> > bit 3000000000 :: Integer
14:13:44 <sipa> cmccann: afaik that is not an integer, mathemetically
14:13:45 <cdh473> there we go :)
14:13:47 <lambdabot>   mueval: ExitFailure 1
14:13:47 <lambdabot>  mueval: Prelude.undefined
14:13:48 <cdh473> it worked
14:13:51 <cdh473> > sum [factorial 500 :: Integer, factorial 500 :: Integer] :: Integer
14:13:55 <lambdabot>   mueval-core: Time limit exceeded
14:14:06 <roconnor> rostayob: man, these bounded, unbounded integer implemenations really irritated my obsessive disorder.
14:14:12 <cmccann> sipa, oh, sorry. for some reason I thought you said "number" not "integer"
14:14:14 <roconnor> *irritate
14:14:39 * cmccann misread
14:14:42 <tromp__> > bit 30000000000 :: Integer
14:14:43 <lambdabot>   mueval-core: out of memory (requested 3750756352 bytes)
14:14:58 <rostayob> roconnor: I still have to read that stage. not enough maths in my life ehe
14:14:59 <roconnor> OTOH, they please my ultrafinitist convictions.
14:15:06 <rostayob> lol
14:15:38 <tromp__> > 30000000000/3750756352
14:15:39 <lambdabot>   7.998386774444366
14:15:59 <cmccann> roconnor, pf, ultrafinitism
14:16:13 * cmccann remains a co-ultrafinitist
14:16:23 <cdh473> > / 10 5
14:16:24 <lambdabot>   <no location info>: parse error on input `/'
14:16:29 <cdh473> well then
14:16:33 <cdh473> clisp does it >.>
14:16:42 <ski> cmccann : hehe, meaning ?
14:16:45 <c_wraith> cmccann: does that mean you don't believe in anything you can prove?
14:17:03 <ski> roconnor : "bounded, unbounded" ?
14:17:11 <cmccann> ski, meaning that I assert infinity exists, and includes sufficiently large finite numbers ;]
14:17:14 <roconnor> cmccann: you believe in only all but finitely many natural numbers?
14:17:17 <cdh473> ski: Int vs Integer
14:17:28 <rwbarton> only sufficiently large numbers exist
14:17:44 <ski> cmccann : oh -- i was guessing you meant something like Aczel's non-well-founded set theory
14:18:25 <roconnor> ski: bouned implemenations of unbounded integers. like GMP and almost every other integer implemenation I've ever seen.
14:18:31 <cmccann> nah, just a tongue-in-cheek definition of infinity as "anything larger than the largest number I care about"
14:18:36 <roconnor> ski: most crap out at around 2^(2^64) or so
14:19:03 <niteria> @type trace
14:19:03 <ski> roconnor : oh -- i was assuming you were thinking about Markov-Principle-like stuff (which was mentioned in #constructive-math some days ago)
14:19:05 <lambdabot> Not in scope: `trace'
14:19:16 <rostayob> there is a #constructive-math? jeeesus
14:19:32 <ski> hehe
14:19:45 <rostayob> #intuitionistic-type-theory
14:20:25 <ski> rostayob : all varieties of constructive math is welcome in #constructive-math
14:20:36 <ski> (it's not like we get that much traffic, anyway)
14:21:20 <rostayob> ski: I can imagine
14:21:23 <ski> roconnor : crap out due to memory limitations, or ?
14:22:59 <rostayob> ski: I've read on the mailing list that gmp has other limits. can't find the thread right now...
14:23:27 <rwbarton> well in whatever data structure gmp uses to store an integer, there is likely a field that stores the length of the integer (in bytes or "limbs" or whatever), and that field likely has some fixed size
14:24:27 <rostayob> it was something really high anyways. really, really high. not that distant from infinity :P
14:24:40 <rwbarton> as designing a library to store integers that would require more than 2^64 bytes to store is less than useful
14:25:07 <ski> rwbarton : yes .. but the question is whether that establishes any auxilary limitation, apart from the memory one
14:25:19 <roconnor> ski: crap out due to hard coded constants.
14:25:39 <rwbarton> oh, you mean below the limitations of real-world amounts of memory? i doubt it
14:25:45 <ski> roconnor : hm, do you mean returning wrong answers, instead of aborting with "out of memory" ?
14:25:51 <roconnor> ski: usually by having a 64-bit header indicating the number of bits or bytes that the number contains.
14:26:09 <roconnor> ski: either by retuning wrong answers or by segfaulting.
14:26:15 <hpc> that's what Integer does, yes?
14:26:20 <hpc> @src Integer
14:26:20 <lambdabot> data Integer = S# Int#
14:26:20 <lambdabot>              | J# Int# ByteArray#
14:26:24 <ski> rwbarton : no, i mean below the limitations of what would be possible given the addressing scheme (width of address bus, &c.)
14:26:27 <roconnor> hpc: yep
14:26:30 <roconnor> so lame
14:26:44 <hpc> i was hoping for a linked list of Ints
14:26:49 <hpc> that would be cool
14:26:55 <rostayob> and slow
14:27:07 <hpc> Integer isn't a paragon of speed anyway ;)
14:27:25 <roconnor> hpc: I was hoping for a linked list of Bools
14:27:27 <dolio> It's way faster than a list of Ints.
14:27:41 <hpc> roconnor: of course! an excellent optimization
14:27:51 <redheadphones> where would i look to have my program do call clean up function on SIGINT?
14:27:55 <ski> roconnor : well, as long as that doesn't restrict more than what could possibly be addressed on that architecture, i don't count this as a bound in itself (the fact that not checking for it is unsafe is another thing)
14:28:27 <redheadphones> like C-c triggering a function, then killing the program
14:28:31 <roconnor> hpc: data Integer = S Int | J Integer ByteArray  -- this would be nice
14:28:42 <hpc> redheadphones: http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Signals.html -- i think here
14:28:46 <ski> roconnor : .. i suppose one might be able to consider some kind of lazy representation which is incrementally produced and consumed, and which wouldn't fit in memory all at once
14:28:53 <roconnor> ski: most modern programming languages are architecture independent.
14:29:02 <redheadphones> hpc, cool, thanks
14:29:57 <ski> roconnor : but implementations typically have architecture-dependent restrictions
14:30:10 <roconnor> I don't write for implementations :D
14:30:17 <roconnor> Haskell 98 all the way!
14:30:25 <dolio> Then what are you complaining about?
14:30:28 <ski> GMP is an implementation, no ?
14:30:52 <dolio> The 'data Integer = S# Int# | J# Int# ByteArray#' definition is nowhere in the Haskell report.
14:31:10 <roconnor> dolio: I'm complaining about how GHC doesn't implement Haskell 98 ;)
14:31:57 <roconnor> granted GHC fails in other, more significant, ways.
14:32:16 <rwbarton> Haskell 98 can only be implemented on a Turing machine with infinite tape
14:33:04 * ski finds O'Keefe's distinction between an "error" and a "fault" to be useful
14:33:10 <hpc> hmm, what's the lambda-calc analog to "infinite tape"?
14:33:42 <dolio> H98 specifies that Integer is "arbitrary precision".
14:33:51 <ski> a "fault" is when the program has a perfectly good meaning, but the implementation isn't able to compute it. like "out of memory", or "integer overflow"
14:34:03 <roconnor> I'm okay with out of memory errors
14:34:03 <dolio> Not unbounded.
14:34:10 <rostayob> hpc: Integer -> Bool?
14:34:15 <ski> while an "error" is when the program fails to have a full meaning, like pattern-match failure
14:34:16 <rwbarton> arbitrarily chosen by whom?
14:34:25 <rwbarton> the compiler writer?
14:34:29 <hpc> rostayob: i mean, the term for it
14:34:39 <dolio> The architecture's addressible memory, presumably.
14:34:46 <hpc> i was thinking "acyclic graph" or something, but that's not right
14:34:53 <hpc> *cyclic graph
14:35:01 <dolio> That's what wikipedia says "arbitrary precision" means, anyway.
14:35:01 <rostayob> hpc: well you can have a lambda calculus term expressing that type, and you can cons and snoc to it
14:36:05 <ski> (in the case of an fault, the implementation may be blamed. in the case of an error, the writer of the program may be blamed)
14:36:06 <rostayob> and you can "initiate" it to be all 0s
14:36:18 <rostayob> well, all falses...
14:36:22 <ski> ("initialize" ?)
14:36:57 <rostayob> hpc: anyways I'm sure people proved that equivalence before :P
14:36:58 * ski wonders how a neophyte number looks like
14:37:06 * hackagebot test-framework-smallcheck 0.1.1 - Support for SmallCheck tests in test-framework  http://hackage.haskell.org/package/test-framework-smallcheck-0.1.1 (RomanCheplyaka)
14:39:02 <Paprikachu> is there a haskell interpreter i can embed in my c++ program to allow users to write plugins?
14:39:37 <tromp__> :t min
14:39:38 <lambdabot> forall a. (Ord a) => a -> a -> a
14:40:27 <rostayob> Paprikachu: define "embed". you can call haskell functions from C++
14:40:28 <dmwit> Paprikachu: Nothing pre-packaged. However, there's lots of tools that can help you make that happen.
14:40:30 <hpc> rostayob: actually, i suppose a good answer to my question would require some way to limit lambda calculus to the same computational power as a finite-state turing machine
14:40:34 <hpc> so ignore me
14:40:53 <dmwit> Paprikachu: Also, you don't necessarily need an *interpreter* to allow plugins.
14:41:03 <dolio> roconnor: By the way, I don't see a reason why all functors would be traversable classically. It doesn't make much sense for something infinite, like a stream.
14:41:13 <Paprikachu> i want to be able to load something like a haskell plugin at runtime und call functions from it
14:41:37 <rostayob> Paprikachu: nah I don't think there's something ready, you could hack something using the GHC api maybe.
14:41:37 <dmwit> Paprikachu: To get started, have a look at the FFI.
14:41:39 <dmwit> ?where ffi
14:41:40 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
14:42:04 <dolio> Having native continuations means you don't have to traverse to plumb things through your functor, not that you can plumb anything through. Maybe there is some trick I'm not seeing, though.
14:42:17 <dmwit> Paprikachu: You may also like to look at the GHC API, hint, and mueval (though perhaps not in that order), depending on exactly what additional features you need.
14:42:34 <Paprikachu> thx, i'll have a look at it.
14:42:57 <rostayob> Paprikachu: anyway it's going to be ugly.
14:43:05 <roconnor> dolio: okay ... I don't know exactly what you mean by "classically", though I have some idea.  ... something something about an LK sequent calculus.
14:43:07 <rostayob> I'd reccomend you use some more embeddable language
14:43:38 <rostayob> e.g. one of the scripting languages (lua, javascript, etc)
14:44:17 <dolio> roconnor: I usually think of a language that has call/cc with peirce's law as a type, or double-negation-elimination or excluded middle with similar semantics.
14:44:31 <dolio> But that's just because I'm most comfortable thinking about that.
14:44:52 <roconnor> dolio: ah, okay.
14:46:04 <roconnor> dolio: do you have reduction rules, presumablly that is impossible.
14:46:10 <roconnor> s/,/?/
14:46:10 <Telemachus_> roconnor meant: dolio: do you have reduction rules? presumablly that is impossible.
14:46:26 <roconnor> Telemachus_: thanks
14:46:39 <dolio> Wow.
14:47:00 <dolio> I don't off hand.
14:47:05 <roconnor> s/s/s!/
14:47:05 <Telemachus_> roconnor meant: Telemachus!_: thanks!
14:47:25 <roconnor> not quite what I meant.
14:47:48 <dolio> I've kind of convinced myself that costrength implemented with continuations satisfies the costrong comonad rule, though.
14:48:00 <roconnor> what?
14:48:05 <dolio> Er, for streams.
14:48:50 <ski> (dolio : how about `(forall a. Not (Not (P a))) -> Not (Not (forall a. P a))', when `a' is a natural ?)
14:48:59 <dolio> costrength s is initially Right s', where if there are any Lefts in s, will go back in time and switch to Left x if you look at the wrong element....
14:49:21 <roconnor> clearly it doesn't.  extract (Right 'a':repeat (Left '1')) is Right 'a', while right extract . costrength $ (Right 'a':repeat (Left '1')) is Left '1'.
14:49:41 <dolio> But, the law required is 'bimap id extract . costrength = extract', which doesn't allow you to look past the first element of the stream, and it always agrees if you only look at the first element.
14:50:25 <dolio> ski: I don't have enough experience with that one to know how acts relative to the others.
14:51:21 <roconnor> dolio: oh wait, you are claiming that right extract . costrength $ (Right 'a':repeat (Left '1')) is Right 'a' in your fictional callcc classical language.
14:51:25 <roconnor> dolio: interesting.
14:51:39 <dolio> roconnor: Yes, because it doesn't look far enough into the costrengthed stream.
14:51:50 <dolio> It's very delicate, though.
14:51:52 <notrusty2> anybody familiar with Graphics.Rendering.Chart?
14:51:53 <ski> (dolio : this one is additionally needed in one embedding of classical logic in intuitionistic logic. istr Escardo mentioning it (with `a' a natural) being related to bar induction, and being related to his impossible stuff)
14:52:04 <roconnor> dolio: callcc makes my head hurt
14:52:05 <dolio> It wouldn't work for, say, non-empty finite lists in a strict language.
14:52:12 <notrusty2> i'm trying to change set the range for my Y-axis...
14:52:17 <dolio> It depends crucially on the delays in streams.
14:52:46 <ski> hehe, non-strict language with `call/cc' :)
14:52:58 <dolio> Needless to say, it's pretty evil.
14:53:12 <dolio> I guess it's another reason why non-strict is obviously better, though. :)
14:53:14 <ski> linear continuations are much nicer
14:53:38 <roconnor> ski: do linear continutations require the continuation to be used?
14:53:43 <ski> the real problem with first-class continuations, afaiui, is if they're used non-linearly
14:53:57 <ski> roconnor : yes -- affine would not require it
14:54:06 <roconnor> ok
14:54:09 <dolio> I'm pretty sure what I'm doing is non-linear.
14:54:21 <ski> but i think it's mostly contraction, not weakening, which is problematic
14:54:21 <roconnor> dolio: probably affine though.
14:54:37 <dolio> Not even that.
14:54:57 <ski> (i think a language with something `call/cc'-like but for linear continuations could be pure)
14:55:15 <dolio> I could believe that.
14:55:45 <ski> the usual proof of Principle of Omniscience (aka LEM/PEM) crucially depends on using the continuation twice
14:56:07 <dolio> roconnor: I'm using the continuation in map, and map isn't even affine in its first argument.
14:56:41 <ski> dolio : heh, sounds maybe a bit similar to `argfc' ..
14:56:43 <dolio> It might end up getting called at most once (because once it is, it jumps out), but I don't think that matters.
14:57:07 <ski> hm, ok
14:57:21 <dolio> Also, I think call/cc is inherently non-linear.
14:57:33 <roconnor> dolio: oh god
14:57:45 <ski> dolio : yes it is
14:58:08 <roconnor> dolio: I'm imaging using costregth on the continuation functor.
14:58:11 <roconnor> and failing.
14:58:27 <dolio> That one's easy, I think.
14:59:59 <dolio> F X = (X -> ⊥) -> ⊥. costrength = bimap id double-negation-introduce . double-negation-elimination
15:02:22 <cmccann> ski, LEM is valid in linear logic, isn't it?
15:02:44 <ski> er, right
15:03:05 <ski> yeah
15:03:09 <cmccann> in linear logic LEM = id, actually
15:03:19 <ski> depending on whether you want multiplicative or additive disjunction
15:03:27 <ski> for multiplicative disjunction it is provable
15:03:37 <cmccann> LEM with additive disjunction is clearly nonsense
15:03:39 <ski> however, i was referring to the additive variant
15:04:10 <ski> (since i think the name "LEM" is a misnomer for the multiplicative variant, since multiplicative disjunctions isn't about choices)
15:04:41 <cmccann> well, it sort of is, just not in the same way
15:05:46 <jimmy_birer> Haskell is for casuals
15:07:08 * hackagebot freesect 0.6 - A Haskell syntax extension for generalised sections.  http://hackage.haskell.org/package/freesect-0.6 (AndrewSeniuk)
15:07:50 <dolio> roconnor: Basically, when you have continuations, Cont ⊥ might as well be Identity.
15:07:52 <cmccann> ski, think about it this way: A⅋B = ¬(¬A⊗¬B) = (A⊸⊥)⊗(B⊸⊥)⊸⊥
15:07:57 <rasfar> (as if in proof of jimmy_birer's aside)
15:07:58 <cmccann> :t either
15:07:59 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:08:10 <cmccann> note the similarity there
15:11:01 <cmccann> ski, think about it this way: A⅋B = ¬(¬A⊗¬B) = (A⊸⊥)⊗(B⊸⊥)⊸⊥
15:11:02 <ski> roconnor,dolio : the papers "Using a continuation twice and its implications for the expressive power of call/cc" in 1999 at <http://www.cs.bham.ac.uk/~hxt/research/usingtwice.ps> and "Continuation passing style and self-adjointness" in 1996 at <http://www.cs.bham.ac.uk/~hxt/research/cw97final.ps> by Hayo Thielecke defines "discardable side-effect" and "copyable side-effect", ...
15:11:08 <cmccann> :t either
15:11:09 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:11:19 <cmccann> note the similarity to the church encoding of Either
15:11:32 <ski> .. and shows examples of operations constructed using `call/cc' which are discardable but not copyable, copyable but not discardable, and neither copyable nor discardable
15:12:11 <dolio> I think I've read usingtwice way back.
15:12:18 <ski> some of the other publications listed at <http://www.cs.bham.ac.uk/~hxt/research/htpapers.html> might also be interesting (also see some of Andrzej Filinski's papers at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/>)
15:13:52 <ski> <ski> cmccann : yes, but if you have `call/cc' or say a two-sided sequent calculus allowing multiple conclusions, it is provable
15:13:53 * monochrom is amazed that someone is called hxt
15:13:55 <ski> <ski> (i.e. Gentzen's LK)
15:15:34 <ski> cmccann : yes i know, but `_|_' isn't `Void'/`0'
15:15:56 <augur> wowies
15:16:21 <augur> the modal logic K seems to be defined in such a way that makes all applicative functors into modal operators
15:16:45 <ski> (also, the proper Church encoding of additive disjunction would be `forall r. (a -o r) * (b -o r) -o r', where `*' is additive conjunction -- but i see the similarity, yes)
15:16:48 <cmccann> ski, yes, just noting that multiplicative disjunction still involves some notion of "choice"
15:17:12 <augur> atleast in terms of the types
15:18:16 <ski> augur : yeah :)
15:19:08 <ski> cmccann : yeah, in the sense of trying all possibilities, and expecting all but one of them to die (or all of them dying, if this is part of a larger computation with other branches)
15:20:54 <cmccann> ski, not sure if that's how I'd look at it but something along those lines, yeah
15:23:26 <ski> cmccann : basically, if you have something of type `Not a', you can think of this as a sort of communication channel to another branch of the computation
15:23:38 <cmccann> ski, right
15:24:10 <ski> if you manage to compute a value of type `a', and combines it with the continuation, you end up with `_|_', which effectively kills this branch, since `_|_ (+) A' is equivalent to `A'
15:24:19 <ski> (`(+)' being the multiplicative disjunction)
15:25:04 <ski> and of course `lem :: a (+) Not a' splits the current branch in two, constructing such a channel between them
15:25:35 <cmccann> not so much killed as completed, since the other branch actually needs the value used
15:25:59 <ski> the point is that with `A (*) B' (multiplicative conjunction), you must compute the two answers independently of each other, but the results may be combined together, interacting with each other (e.g. multiplication of naturals)
15:26:01 <shachaf> cmccann: Well, the branch's continuation is ignored. :-)
15:26:36 <cmccann> shachaf, how so? nothing is ignored with multiplicatives
15:26:40 <cmccann> that's their purpose
15:26:46 <ski> and dually, you must *use* the two parts of `A (+) B' independently from each other, but you may construct them in a communicating way
15:26:59 <shachaf> Hmm, /me reads up for context.
15:27:02 <ski> cmccann : "not so much .." -- agreed
15:28:09 <ski> one might define `lem' above something like
15:28:10 * cmccann was playing with a coroutine/continuation monad that let you "fork" with each pseudo-thread getting one end of a "channel", so they could feed/take values and cause evaluation to switch to the other side as needed
15:28:18 <ski>   lem = {a,\a -> {}}
15:28:43 <ski> where `{..,..}' is syntax for values of type `A (+) B', and `{}' similarly for `_|_'
15:28:56 <ski> note the strange scoping present here
15:29:18 <augur> hmm actually it seems that the axioms of modal logic will get you monads too
15:29:31 <ski> augur : which modal logic ?
15:29:34 <augur> this makes sense with other things ive read about monads being related to modal logic
15:29:35 <augur> hmm
15:29:36 <augur> ski: K
15:29:39 <cmccann> augur, isn't the connection between modal operators and monads pretty well-known?
15:30:10 * cmccann notes that the ! and ? operators in linear logic resemble a monad and comonad
15:30:14 <cmccann> or maybe it's the other way around
15:30:18 <cmccann> can never keep them straight
15:30:20 <ski> yeah
15:30:24 <ski> `!' is a comonad
15:30:54 <dolio> <> is a monad, [] is a comonad.
15:31:31 <ski> well, `[]' isn't a comonad in K
15:31:54 <ski> (T adds the `[] Phi -> Phi' axiom)
15:32:05 <augur> ah but its only on the type side, not necessarily the equational side
15:32:07 <augur> hmm
15:32:42 <ski> (provability logic is an interesting example of a modal logic without axiom T .. Boolos' book "The Logic of Provability" (the "The Unprovability of Consistency" in a former life) is interesting)
15:32:57 <cmccann> ski, anyway, for the last month or so I've been intermittently poking at a Haskell library that's very close to an encoding of linear logic, so I'm entirely too familiar with computational interpretation of multiplicative disjunction :T
15:33:13 <dolio> Provable P doesn't imply P?
15:33:27 * ski wonders how one can be *too* familiar with it
15:33:56 <ski> dolio : no : by Loeb's theorem, if that is provable for some `P', then `P' is also provable
15:34:10 <ski> so if it was provable for every `P', then the logic is inconsistent
15:34:11 <cmccann> ski, because getting it to work properly has caused no end of headaches
15:34:11 <JoeyA> Is it efficient to use {-# UNPACK #-} with Ptr?  Or is it somehow different from, say, Int or Float?
15:34:19 <ski> (the book i mentioned explains this)
15:35:05 <ski> dolio : of course, if `Provable P' is deducible in the empty context, then `P' is also deducible in the empty context
15:35:22 <ski> dolio : but `Provable P -> P' isn't generally deducible
15:38:48 <cmccann> ski, speaking of which I think I was supposed to tell you something about the aforementioned library since I had to run AFK last time it came up, but I forgot and as it happens I need to run AFK again this time
15:39:39 <roconnor> ski: more trivally if P is provable then so is `Provable P -> P`
15:39:58 <roconnor> thus `Provable P -> P` is provable iff P is provable.
15:40:28 <ski> roconnor : *nod*
15:40:49 <ski> i wonder whether one can make that equivalence into an isomorphism ..
15:40:57 <ski> .. i suspect it's only a retract
15:41:30 <roconnor> ski: what do we know about Provable (Provable P -> P) -> Provable P ?
15:41:53 <ski> @ask cmccann tell me what about which aforementioned library ?
15:41:53 <lambdabot> Consider it noted.
15:42:06 <ski> roconnor : it's provable ?
15:42:10 <pedr0> a
15:42:13 * ski isn't sure what roconnor is after
15:42:16 * roconnor has no idea.
15:42:24 <pedr0> someone know a good website about exploit ?
15:42:31 <roconnor> ski: presumably the proofs of that statement would be one direction of an aledged isomorphism
15:43:18 <Axman6> pedr0: that is not on topic here.
15:43:26 <roconnor> pedr0: http://www.marxists.org/subject/japan/sakisaka/exploitation.htm
15:44:09 <monochrom> http://www.amazon.com/Exploit-Anything-for-Great-Good/dp/1593272839/
15:44:58 <ski> roconnor : yes .. or at least *one* possible proof of it
15:46:33 * ski once tried to make a GADT (hlibert-system-like) for which one could do stuff like Loeb's theorem
15:48:03 * ski sometimes thinks there should be logical rules for working with "retract" and "isomorphism" instead of just "implication" and "biimplication"
15:48:56 <td123> is there a function in haskell that groups n consecutive items in a list into another list? so n -> [a] -> [[a]] I already tried hoogle :/
15:49:16 <danharaj> chunk
15:49:18 <danharaj> in Data.List.Split
15:49:28 <td123> thanks, I'll check it out
15:49:34 <ski> @hackage split
15:49:34 <lambdabot> http://hackage.haskell.org/package/split
15:49:34 <danharaj> hoogle misses that package for whatever reason it's pretty common
15:49:37 <ski> ^
15:50:09 <td123> ah it's a seperate pkg, I'll check it out anyways, was going to write one if no one knew :P
15:50:12 <td123> ty
15:51:32 <Cale> td123: you can also just use   map (take n) . takeWhile (not . null) . iterate (drop n)
15:51:37 <kallisti> "Whatever work the target thread  was doing when the exception was  raised is not lost: the computation  is suspended until required by  another thread. "
15:51:41 <kallisti> how does this work exactly?
15:51:54 <kallisti> how does another thread require this computation
15:52:08 <Cale> kallisti: context?
15:52:14 <ski> it references thunks which are already evaluated by the other thread ?
15:52:16 <kallisti> Control.Exception.throwTo
15:52:26 <kallisti> ah right
15:52:36 <kallisti> but it's not possible to "resume" the thread once it's in a suspended state, yes"?
15:54:16 <Cale> I think it just means that if the thread you threw an exception at was in the middle of computing some (pure) value, any progress that it had made in computing that value won't be lost when it gets the exception.
15:54:41 <Cale> So the next time that value is needed anywhere in the program, it'll resume from where it left off.
15:54:59 <Cale> lots of ping timeouts...
15:55:35 <cdh473> > let trigOpp theta hyp = (sin theta) * hyp in trigOpp 2 5
15:55:36 <lambdabot>   4.546487134128409
15:55:51 <monochrom> you have forkIO (let xs = [1..1000] in putMVar v xs >> print xs). the thread happily seqs and prints xs. it is killed in the middle. when some other thread discovers xs by takeMVar v, whatever is seq'ed is still there
15:56:32 <td123> Cale: that's pretty neat
16:06:19 <parcs`> does loading things via ghci set a CPP flag or something?
16:21:44 <sam5> I want to achieve something similar to this effect
16:21:50 <sam5> http://hpaste.org/65258
16:22:05 <sam5> But I'm not sure how I should approach in fixing the problem
16:23:00 <dmwit> sam5: Just use "type CipherText c = [c]" instead?
16:23:38 <dmwit> sam5: ...and drop the (ReifiesNum q) constraint, I guess.
16:23:46 <dmwit> I mean, what were you hoping that 'q' would do for you?
16:24:29 <sam5> I originally did not have 'q'
16:24:32 <dmwit> sam5: Does "CyclotomicRing" provide (+)? How is the compiler supposed to choose "m" and "r"?
16:25:01 <sam5> but I wanted 'q' to represent a value as a type
16:25:24 <dmwit> You will probably have to add "Proxy m" and "Proxy r" arguments to give the compiler enough information to work with.
16:25:27 <sam5> so that I can infer it from teh type rather than bringing it along
16:25:43 <dmwit> You don't have a value of type "q" anywhere in that code, though.
16:25:50 <dmwit> Or any value whose type even mentions "q".
16:26:45 <dmwit> ("CipherText q c" isn't a type that mentions "q", because "CipherText q c = [c]", and "[c]" doesn't mention "q".)
16:27:05 <monadic> Hi, building glib on ghc 7.4 is giving me "gtk2hsC2hs: UName: root name supply used before restoring
16:27:21 <dmwit> monadic: Yeah, we've had a few reports of that on the mailing list, too.
16:27:29 <dmwit> Haven't worked out what's going on there yet.
16:27:36 <dmwit> You're having that problem with glib, and not with gloss?
16:27:46 <sam5> hm.. give me a moment to rethink about what I am trying to do2026 :(
16:29:23 <monadic> dmwit: Not using gloss
16:30:55 <monadic> dmwit: Darn, I have to finally learn darcs to check out the glib code!
16:31:14 <dmwit> "darcs" should be the easy part.
16:31:21 <dmwit> We give you the command to run right on the glib Hackage page. =)
16:31:40 <monadic> dmwit: More like install doc without it pulling in the 30 dependencies it currently wants... Use flags ;)
16:31:42 <dmwit> (See the "Source repository" property.)
16:33:34 <dmwit> Ack, not gloss, glade.
16:34:34 <dmwit> monadic: Are you trying to build glade? (Can you double-check that this error comes while trying to build glib? I can reproduce the glade problem, but not the glib one.)
16:34:48 <monadic> dmwit: I'm pretty sure this is with glib...
16:34:55 <dmwit> alright
16:34:57 <dmwit> Bad news. =/
16:35:10 <monadic> dmwit: Let me check build output again
16:35:35 <monadic> dmwit: Yeah glade is a seperate package in gentoo so its unlikely that glib is building glade
16:35:40 <JoeyA> Is it possible to explicitly free a ForeignPtr allocated with mallocForeignPtrBytes ?  Or am I at the mercy of the garbage collector?
16:36:17 <monadic> JoeyA: Isn't the point of a foreign ptr to be finalized by the GC? Try mallocing a non-foreign pointer
16:36:47 <JoeyA> It is, but I was wondering if it was possible to explicitly tell it I'm done using it.
16:37:11 <monadic> JoeyA: Maybe remove finalizer and then with withForeignPtr and free
16:38:16 <JoeyA> I'm not sure mallocForeignPtrBytes uses the same heap as malloc, but I could be wrong.
16:38:34 <JoeyA> Sounds risky.  I doubt it will be much of a problem to let the GC clean it up.
16:38:38 <JoeyA> Thanks
16:38:52 <monadic> JoeyA: Why do you need to use a ForeignPtr if you want to finalize it yourself
16:39:14 <JoeyA> I'm expanding a buffer, and I don't need the old buffer anymore.
16:39:36 <monadic> JoeyA: Ohhh. That sounds like it could leak though if you expand it alot and it doesn't GC often... Well not leak, just become annoying
16:42:10 * hackagebot hmpfr 0.3.3.5 - Haskell binding to the MPFR library  http://hackage.haskell.org/package/hmpfr-0.3.3.5 (MichalKonecny)
16:47:38 <monadic> dmwit: It reproduces in darcs.
16:47:50 <fluffynukeit> hey everyone.  Relative haskell newbie here.  I'd like to know if it's possible to save/load a function from a (binary) file in the same way you could load text.  Is that possible?
16:47:58 <dmwit> That's not surprising, considering the only patch since release has been a documentation patch. =P
16:48:06 <dmwit> But it is very disheartening, since I definitely can't reproduce it.
16:48:12 <monadic> dmwit: I wish the error told you which chs file :(
16:48:19 <monadic> fluffynukeit: You need GHC API
16:49:13 <hpc> fluffynukeit: or a loose definition of "function"
16:49:21 <hpc> you can store a Map input output
16:49:26 <rostayob> fluffynukeit: you might be able to hack something with the GHC api but it's awkward. it's not something you should do
16:50:46 <monadic> dmwit: Any way I can get a more "useful" error, you think?
16:51:31 <fluffynukeit> thanks all for the quick responses.  They point me in the right direction to at least learn more and discover what the limitations are
16:51:36 <dmwit> I actually can't really do much on it tonight; I'm heading to bed about now.
16:51:50 <rostayob> fluffynukeit: big limitations. it's not something you do in Haskell right now
16:52:02 <rostayob> I actually miss that from other languages like scheme or erlang
16:52:11 <monadic> dmwit: The most disturbing thing is possibly that a verbose build gets rid of the error :O
16:52:23 <dmwit> I can point you to the tools/c2hs/base/general/UNames.hs file, but not much more, I'm afraid.
16:52:37 <dmwit> monadic: No, verbose doesn't matter; doing it twice does.
16:52:39 <dmwit> (!)
16:52:43 <monadic> dmwit: Oh.
16:57:02 <fluffynukeit> rostayob: my interest is in algorithmically generating a function that satisfies certain criteria, then in some sense save those functions so they can be recalled and tested at some later time.  Am I just out of luck if I choose Haskell?
16:58:05 <geekosaur> fluffynukeit, you are out of luck in most compiled languages, actually.  you sure you don't want an interpreted or (depending on implementation) bytecode language?
16:59:56 <Cale> I don't see why you'd have any trouble with that in Haskell. However, plain Haskell functions are not serialisable.
17:00:22 <Cale> So you'll just have to record the manner in which you constructed the given functions.
17:00:58 <geekosaur> ...you could possibly extract the function address, save it, and load it later for use with some kind of dynamic call mechanism, as opposed to saving the whole function.  the plugins package diesn't *quite* do this but could be used to work out how to do it
17:01:09 <geekosaur> or that
17:01:32 <Cale> Probably best just to use some algebraic datatype which encodes all the ways in which your system constructs functions.
17:01:46 <rostayob> fluffynukeit: just create a DSL for your functions.
17:01:55 <rostayob> that would be much better in any language but scheme I'd say anyways
17:02:41 <Cale> It's really hard to provide more detailed advice than this without more information about what you're actually doing.
17:02:53 <geekosaur> ^^ that
17:03:46 <rostayob> fluffynukeit: btw, if you wanted to generate haskell code you could do that easily, there are packages with datatypes representing Haskell code (haskell-src-exts). but a general purpose is most certainly too big, you probably want to do something quite specific. hence the DSL suggestion
17:07:14 <fluffynukeit> My interest lies in dynamic systems.  I am interested in creating a small library/DSL for analyzing time-invariant dynamics and multiple systems interacting with eachother's inputs and outputs.  This would be a learning exercise, but if such a library already exists that would be good to know too.  After connecting inputs and outputs of multiple subsystems, the resulting system has its own inputs and outputs.  I'm interested in
17:07:20 <BMeph> fluffynukeit: Also, you may get more help, if you sit down, think for a while, and come back to tell u sabout what you "really" want to do. It may be doable in a totally different way than how you've decided (that happens a LOT to folks with Haskell). ;)
17:07:56 * BMeph 's favorite insinuation is of people asking "XY" questions...
17:08:26 <fluffynukeit> Representing the input/output relationship of the resulting system using a function seems like a natural fit
17:08:49 <fluffynukeit> but I'm still a newb so maybe not :)
17:09:54 <rostayob> fluffynukeit: you definitely can create a DSL and store the data structures representing those, together with an interpreter that runs them
17:10:00 <geekosaur> yougot chopped off at "I'm interested in", by the way --- IRC has a fairly short packet length limit
17:10:25 <BMeph> fluffynukeit: Here's another helpful hint for you - there are folks who have years of experience (over five) with Haskell that are still "newbs"; Haskell is complex to master, but it's so much fun, we just don't care! :D
17:10:39 <fluffynukeit> sorry, my client allowed me to keep typing:  I'm interested in saving and loading the system later.
17:10:53 <rostayob> BMeph: I find it hard to believe that you're still a newbie after 5 years of haskell...
17:10:59 <rostayob> fluffynukeit: haskell is not hard as people say!
17:11:09 <scooty-puff> if in pattern matching, only a single data constructor is possible (because its part of a GADT, phantom types, etc.), will no check be performed, beyond forcing the value?
17:11:10 <geekosaur> yeh, many clients also have some way to twell them to split stuff automatically
17:11:27 <geekosaur> rostayob, it's like the ads for othello "easy to learn, hard to master"
17:11:36 <BMeph> fluffynukeit: Well, not yet. Once I have that much time, though, I expect to still be a Haskell newb. :)
17:11:46 <geekosaur> (othello being a brand name for someone's implementation of reversi)
17:12:16 <BMeph> rostayob: Whoops, that last was for you; I though fluff was saying that. :)
17:13:25 <scooty-puff> i ask, because i intend to use DataKinds and GADTs for a dependently typed heterogeneous list (like HList), but would hope that it never checks against Nil ever
17:13:28 <fluffynukeit> I find myself devouring haskell related blogs, literature, and PPTs, but I haven't done much beyond the RWH, LYAHFGG, and a few H99 problems.  Dynamics and control is my background so I'm hoping to leverage it to help me learn.
17:13:30 <scooty-puff> well, maybe..
17:13:54 <hpaste> scooty-puff pasted “List” at http://hpaste.org/65261
17:15:36 <Saizan> scooty-puff: it'll still do the match, at a minimum it has to check that the value given is not bottom
17:15:53 <scooty-puff> Saizan: o duh, i always forget that..
17:16:15 <scooty-puff> what if it was a strict field?
17:16:32 <scooty-puff> !x -> !List xs -> List (x ': xs)
17:17:52 <Saizan> i guess in that case it could assume the inner values are non-bottom once it has checked the outer is so, but i don't know if it takes advantage of this
17:18:11 <scooty-puff> ok - to the core i go
17:22:03 <kallisti> what's the latest version of GHC that supports cross compilation?
17:22:23 <parcs`> none
17:25:26 <kallisti> parcs`: ah. the iphone wiki entry says "now that GHC can be used a cross compiler... "
17:27:39 <irene-knapp> some people have made it work but it's not at all easy
17:28:42 <gentleben> yeah, i think visi is doing something like that
17:28:43 <acowley> We need to get Simon Marlow a Raspberry Pi to really motivate him.
17:29:04 <gentleben> for iOS on iPad
17:29:41 <gentleben> https://github.com/visi-lang/visi
17:30:11 <gentleben> there is a game out there somewhere that uses GHC on iPhone as well
17:30:38 * BMeph gives acowley a thumbs-up; he read that blog entry, too. :)
17:31:37 <gentleben> what is with the raspberry pi thing?
17:33:23 <dfletcher> it's a linux box for 20 bucks what's not to love ;)
17:33:37 * dfletcher wants one to play with too
17:33:47 <BMeph> dfletcher: Forty bucks; twenty-odd pounds. :)
17:34:22 <dfletcher> heh still worth it. I've paid 4x that much for boards with just a microcontroller
17:34:44 <acowley> I just say the RPi to motivate Simon because it appeals to his nationality, paternal instincts, and FOSS tendencies in ways iOS never will
17:35:15 <BMeph> Thirty-odd pounds, with shipping+VAT, really. but still, ridiculously cheap for a computer system - imagine the Beowulf possibilities... >;)
17:36:08 <monochrom> imagine also the Glasgow Parallel Haskell possibilities
17:37:06 <monochrom> perhaps it's time to revive GpH for a cluster of raspberry pies
17:37:27 * BMeph imagines a DPH setup on a cluster of RPi machines...would the proper term for a group of them be a "bunch"? ;)
17:37:40 <c_wraith> raspberries don't grow in bunches
17:37:46 <cmccann> raspberries are bunches
17:37:46 <lambdabot> cmccann: You have 1 new message. '/msg lambdabot @messages' to read it.
17:37:58 <BMeph> c_wraith: Raspberries are bunches! :)
17:38:00 <cmccann> each seed is a separate fruit
17:38:00 <lazythunk> $20 … can't get a real raspberry pie for that price
17:38:11 <cmccann> yeah, raspberries are stupid expensive
17:38:18 <kallisti> BMeph: if you use brainfuck exclusively on all machines then clusterfuck would be appropriate.
17:38:41 <cmccann> also, wouldn't a cluster of raspberry pies be called "a bakery"?
17:39:22 <monochrom> hahahaha
17:43:16 * dolio imagines raspberry pis, naked and petrified, with hot grits.
17:47:15 <Aune> Im trying to learn some profiling. What does the " SPARKS : #num1 (#num2  converted, #num3 pruned)" stand for?
17:49:41 <acowley> Aune: "The SPARKS statistic refers to the use of Control.Parallel.par and related functionality in the program. Each spark represents a call to par; a spark is "converted" when it is executed in parallel; and a spark is "pruned" when it is found to be already evaluated and is discarded from the pool by the garbage collector. Any remaining sparks are discarded at the end of execution, so "converted" plus "pruned" does not necessa
17:49:41 <acowley>  add up to the total."
17:49:59 <acowley> Aune: from http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/runtime-control.html
17:50:25 <Aune> acowley, thanks
17:52:05 <Philippa> so I'm thinking about getting a raspi, but mostly to see how I really feel about the complexity of porting ghci to arm
17:52:28 <Philippa> (until you've got real hardware and a real development environment and real docs making you go "aw, fuck"...)
17:53:53 <BMeph> Philippa: (...you're not trying hard enough?;)
17:54:56 <acowley> Philippa: The RAM constraints suggest to me that the cross-compilation story really needs to be sorted out. Every time I've tried to compile GHC in a RAM-constrained environment, I've regretted it.
17:55:17 <xil> hey everyone. I have a Data.Map String String and 2 Strings but when I try to insert I get this error
17:55:19 <hpaste> xil pasted “insert fail” at http://hpaste.org/65264
17:55:20 <Pseudonym> Gofer worked fine in a RAM-constrained envirohment, so you might have more luck with Hugs.
17:55:30 <Pseudonym> Of course, Gofer was G-machine and Hugs is STG.
17:55:54 <Aune> Is there an easy way to get the profiling libraries for all my installed libraries?
17:56:15 <monochrom> no, you have to rebuild them all
17:56:28 <Aune> darn
17:57:01 <monochrom> set a line in .cabal/config so you will never worry again
17:57:17 <monochrom> while you're at it, set also the other line about building docs
17:57:17 <Aune> monochrom, yeah. will do.
17:57:27 <acowley> We should have a kickstarter campaign to pay someone to give cabal-install the ability to recursively install profiling libs
17:57:48 <acowley> Even if you set that line in your config file, you still end up hitting this issue for the first few days after a fresh install.
17:57:52 <monochrom> no, I would rather campaign to change .cabal/config defaults
17:58:09 <dolio> That's going to take way more money.
17:58:13 <c_wraith> acowley: you can to "cabal install --reinstall world" on recent versions of cabal-install
17:58:28 <c_wraith> *do
17:58:31 <acowley> c_wraith: it's never worked for me, but it does seem like a good feature
17:58:41 <acowley> defaults are a rich man's game
17:59:06 <hpaste> xil pasted “accidental recursion?” at http://hpaste.org/65266
17:59:08 <xil> oh wait, I think this is a recursion fail. Here's the line...
17:59:44 <xil> no, it was simpler than that. I was using the wrong "insert" function
18:01:55 <Aune> monochrom, which is the line about building docs?
18:02:08 <int80_h> @src map
18:02:08 <lambdabot> map _ []     = []
18:02:09 <lambdabot> map f (x:xs) = f x : map f xs
18:02:17 <monochrom> documentation: True
18:07:13 * hackagebot unordered-containers 0.2.1.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.1.0 (JohanTibell)
18:10:13 <unlink> How can I handle UTF-8-encoded filenames in a typesafe way? Ideally I'd like functions like getDirectoryContents and renameFile which would refuse to operate on Strings, and would explicitly need to be passed encoded bytestrings.
18:17:19 <acowley> unlink: You will probabaly need to assemble your own module that exports every API you care about, where your implementation does the ByteString <-> String mapping and forwards the call to the existing System library.
18:21:11 <xil> can I not rely on trace to produce output if it's second argument is evaluated?
18:21:34 <Cody_> Why don't generators in Haskell run concurrently?
18:21:40 <Cody_> For example, the following produces...
18:21:44 <acowley> xil: hpaste some code for us to look at
18:21:44 <Cody_> > [x*y | x <- [1..3], y <- [1..3]]
18:21:45 <lambdabot>   [1,2,3,2,4,6,3,6,9]
18:21:50 <Cody_> Why doesn't it produce [1,4,9]?
18:22:34 <xil> acowley: I'm not really at that place right now. I haven't narrowed down my problem at all and there's a lot of code. I'll paste once I've done that, but I just noticed that some traces aren't showing up
18:22:35 <Enigmagic> > [x*y | x <- [1..3] | y <- [1..3]]
18:22:36 <lambdabot>   [1,4,9]
18:23:18 <acowley> xil: it's usually because the second argument either isn't being evaluated at all, or you're expecting it to be evaluated more than once but GHC has outsmarted you
18:23:21 <Cody_> What? That was the same?
18:23:28 <Cody_> Ohh
18:23:35 <xil> acowley: it's the second one, haha, thanks
18:23:35 <Cody_> I missed the "|"
18:23:36 <Enigmagic> Cody_: you'll also need to enable -XParallelListComp
18:24:32 <Cody_> Enigmagic: how do I do that?
18:24:40 <xil> acowley: I changed the code in a way that I can see how now GHC is being too smart about it
18:25:04 <Enigmagic> Cody_: add {-# LANGUAGE ParallelListComp #-} to the top of your file or use :set -XParallelListComp in ghci
18:26:22 <Cody_> Enigmagic: Got it. Is that a library or ... what?
18:26:53 <c_wraith> anything that begins with -X is a language extension
18:26:54 <Enigmagic> Cody_: nope, language extension implemented in GHC but turned off by default
18:27:18 <Cody_> Enigmagic: Is there a list of all the extensions that I can look at?
18:27:45 <cmccann> Cody_, type :set -X in GHCi and hit tab for autocomplete
18:28:09 <cmccann> though there might be a few that aren't there because you can't set them at runtime
18:28:48 <Enigmagic> Cody_: there is a list here too http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/flag-reference.html
18:28:53 <Cody_> cmccann: I see it.
18:29:27 <Cody_> Enigmagic: Bookmarked.
18:32:25 * JoeyA watches as {-# INLINE #-} actually makes his code faster.
18:32:36 <c_wraith> what? lies!
18:35:31 <kfish> https://plus.google.com/101555949501667191720/posts/i1YbDBWcLFW
18:35:38 <kfish> yay, now even easier :)
18:36:08 <NemesisD> anyone here use yesod?
18:40:11 <acowley> It seems to me one of the big selling points of a CI server is testing with multiple versions of compilers or dependencies. Can the Travis CI stuff help with that in a convenient way?
18:44:29 <gentleben> acowley: it also enforces discipline in a team
18:44:31 <acowley> Well, they use HP 2011.04, so I suppose multiple GHC versions is right out
18:45:37 <xil> are Data.Maps immutable?
18:45:47 <acowley> gentleben: Don't get me wrong, I think it's amazing that it's a free service! I'm just trying to figure what I'd get out of it other than a sanity check on builds.
18:45:51 <acowley> xil: yes
18:47:32 <acowley> gentleben: the multiple GHC issue is a pretty gnarly issue in our community, too, so if something existed to help with that it'd be more than welcome.
18:52:15 * hackagebot github-backup 1.20120314 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20120314 (JoeyHess)
18:52:36 <gentleben> acowley: that seems like a test farm problem
18:55:21 <hpaste> xil pasted “lazinesswut?” at http://hpaste.org/65267
18:55:52 <xil> hey all, so I narrowed down my weird problem. This is basically it...
18:56:43 <xil> on line 16 of that paste there is a trace statement. It does correctly execute every time it comes around. However, if I uncomment the end of line 7 then it doesn't produce output
18:57:06 <xil> the confusing thing is that I don't see how it could produce any output at all with the comment there
18:57:33 <xil> it's like the opposite of what should be happening is happening
18:57:48 <sam7> Can I get some help in fixing this error? http://hpaste.org/65269
18:58:04 <xil> actually I see why it produces output with the comment, but I don't see why without
18:58:56 <mauke> sam7: that's a different q
19:00:36 <sam7> different q?
19:02:00 <xil> YES! Fixed. On the last line there is a "db" and it should be "d". I have terrible variable names =/
19:02:07 <ski> sam7 : either add a pattern signature (using `PatternSignatures'), or a `forall q.' to the type signature of `ctMul' (using `ScopedTypeVariables')
19:02:15 <xil> sorry for filling up the chat everyone, but thanks for the rubber ducking
19:02:27 <ski> sam7 : the `q' in the type signature doesn't scope over the definition of `ctMul'
19:02:59 <ski> sam7 : so, either bind it again with a pattern signaure, or use `ScopedTypeVariables'
19:04:31 <sam7> Oh I see
19:04:57 <sam7> I am not familiar with forall but it seems to compile when I put it in with ScopedTypeVariables
19:05:07 <sam7> I guess I'll have to do some more reading
19:06:48 <ski> sam7 : <http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/other-type-extensions.html#scoped-type-variables>
19:32:16 * hackagebot uuid 1.2.4 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.4 (AntoineLatter)
19:36:52 <pcavs> What's a good way to create an executable from cabal that uses HStringTemplate and bundles its required templates with it? I'd also like to be able to grab the templates by using directoryGroup which requires a FilePath, so I guess I'd want to be able to know that these files are packaged in the same directory layout.
19:42:20 <tgeeky> pcavs: I could see that being accomplished using something like the 'shake' build system
19:46:38 <pcavs> tgeeky: thanks I'll take a look
19:52:08 <scooty-puff> what are polykinds?
19:52:13 <scooty-puff> and are they in 7.4.1?
19:54:02 <dolio> You know how you can do 'forall a' to quantify over types?
19:54:43 <dolio> Imagine that for kinds.
19:55:09 <scooty-puff> is the forall required?
19:55:21 <dolio> I don't think it's even implemented that way yet.
19:55:22 <scooty-puff> and is the ** syntax implemented?
19:55:25 <augur> man
19:55:30 <augur> modal logic is cool
19:55:38 <dolio> But they've begun the groundwork.
19:55:41 <scooty-puff> k
19:58:08 <scooty-puff> is it possible, given a kind (*, *), to somehow turn it into *, via a fst or snd of some sort?
19:58:27 <scooty-puff> (next question: a map?  [(*, *)] -> [*])
19:58:45 <scooty-puff> i think i only understand it more on a syntactic level..
20:00:22 <snhmib> hello
20:06:02 <tgeeky> man... I find it very pleasing that we are actually carrying out experiments using ants to discover the geometry of little worlds with little tiny microchips on their backs.
20:09:02 <Modius> Anyone using ghc-mod (in emacs or other)?  Having problems with C-eC-t, ghc-expand-th
20:09:10 <Modius> Not sure if it's working correctly returning "nothing"
20:09:17 <Modius> That is, it returns no text
20:13:14 <Eduard_Munteanu> scooty-puff: there are no such kinds in Haskell
20:17:11 <JoeyA> Micro-optimization question: If I have a function calling a continuation like this: A -> B -> C -> (A -> B -> C -> a -> IO r) -> IO r
20:17:24 <JoeyA> Is it better to pass the extra parameter a first or last?
20:17:52 <JoeyA> That is, will one choice or the other allow it to reuse the part of the stack containing A, B, and C?
20:24:21 <parcs`> dunno, but usually the a comes first
20:24:40 <parcs`> and so does the continuation
20:25:22 <parcs`> eg newtype Cont r a = (a -> r) -> r where r ~ A -> B -> C -> IO r'
20:25:35 <hpaste> scooty-puff pasted “List-backed Records” at http://hpaste.org/65270
20:26:03 <parcs`> you can easily benchmark this kind of thing with criterion
20:26:12 <Modius> http://mew.org/~kazu/proj/ghc-mod/en/    <-- the guy who wrote this plugin did a legendary job.
20:26:29 <scooty-puff> Modius, i very much agree
20:27:37 <scooty-puff> gadts and higher kinds are pretty sweet!
20:35:55 <peteofce> does anyone have a simple example of haskell mpi scatterSend and scatterRecv ?
20:44:39 <peteofce> does anyone have a simple example of haskell mpi scatterSend and scatterRecv ?
20:55:13 <dncr> @hoogle repeatFUntilNothing :: (a -> Maybe a) -> a -> [a]
20:55:15 <lambdabot> No results found
21:00:41 <hpaste> redheadphones pasted “saveExpr doesn't write file” at http://hpaste.org/65273
21:01:19 <redheadphones> i can't figure out why appendFile doesn't write out
21:01:39 <otters> @pl \x -> if x == 1 then '1' else '0'
21:01:39 <lambdabot> flip (flip if' '1' . (1 ==)) '0'
21:01:43 <otters> @where if'
21:01:43 <lambdabot> I know nothing about if'.
21:01:46 <otters> .
21:02:26 <peteofce> @where scatterSend
21:02:26 <lambdabot> I know nothing about scattersend.
21:02:37 <otters> if' is not the type of thing you can google and actually get if'
21:04:58 <mdmarek> @hoogle repeat :: a -> [a]
21:04:59 <lambdabot> Prelude repeat :: a -> [a]
21:04:59 <lambdabot> Data.List repeat :: a -> [a]
21:09:08 <redheadphones> does appendFile possibly wait to do the write until later?
21:11:34 <kallisti> hm, so you should be able to write inductive proofs over strings.
21:12:02 <kallisti> since strings are well-ordered
21:12:05 <kallisti> I believe?
21:12:16 <kallisti> I mean, they have a bijection to the natural numbers
21:17:33 <cadabra> Anyone noticed that Data.Text.ICU.Regex.find is a little slow? I'm seeing about two orders of magnitude slower than Text.Regex.PCRE's =~. Wondering if I'm doing something wrong...
21:18:08 <kallisti> cadabra: I don't know much about the regex packages. but http://www.haskell.org/haskellwiki/Regular_expressions provides a good overview of all the differences.
21:18:12 <kallisti> I think it covers efficiency as well.
21:18:14 <huangjs> noob question: if the code is written in monadic form and happened to be enclosed by IO monads, how could i parallelize it?
21:18:42 <kallisti> huangjs: what do you mean exactly by parallelize. what are you trying to make parallel.
21:19:34 <kallisti> if you just want concurrency, you can easily make an IO action into its own thread of course.. but I'm guessing you want to perfor some operation over the type contained within the IO value.
21:19:41 <kallisti> *perform
21:20:28 <kallisti> huangjs: typically there's a distinction between "parallel" and "concurrent" made in Haskell.
21:20:30 <cadabra> kallisti: it doesn't cover Data.Text. :/
21:20:37 <huangjs> kallisti: the part i need to parallelize in my program is a small fraction, and it's written in divide and conquer style\
21:21:12 <huangjs> kallisti: but the problem is, all functions (including local ones) are enclosed by IO monad
21:21:38 <kallisti> huangjs: for simple fractions?
21:22:08 <huangjs> kallisti: no, i can't tell about my program :) it's a tree walking program
21:22:35 <kallisti> you may be interested in http://hackage.haskell.org/packages/archive/parallel/3.1.0.1/doc/html/Control-Parallel-Strategies.html
21:23:35 <kallisti> but I don't know why you have everything in IO actions unless it's highly IO driven or is maybe written in in a strange style.
21:23:39 <huangjs> kallisti: yeah, i know that, but the IO monad seems to have forced the evaluation order. i got no spark converted
21:24:29 <huangjs> kallisti: it's pure, no IO, but the rest part that calls it happened to be in IO monad
21:24:56 <kallisti> that shouldn't much I would think.
21:25:39 <kallisti> +matter
21:26:00 <kallisti> if all of the code you want to parallelize is pure.
21:26:21 <kallisti> if you want to parallelize many IO actions, you actually want to use regular concurrency instead, most likely.
21:26:25 <huangjs> kallisti: i can rewrite it to remove the monad type, but i'm wondering if there're better ways
21:26:41 <kallisti> typically it's best to seperate your pure computations from IO.
21:27:06 <kallisti> but I'm guessing blindly here.
21:27:14 <huangjs> kallisti: yeah, so rewrite is the best way?
21:27:38 <kallisti> maybe.
21:27:45 <huangjs> ok
21:27:46 <kallisti> if you're writing code in IO just because other code is in IO, that's bad.
21:28:02 <kallisti> IO is not supposed to be contagious like that.
21:28:27 <huangjs> i agree, unfortunately, that's not my code. :( so i'm wondering how can i correct that without change too much
21:28:41 <kallisti> well, if you can change it, I would.
21:28:49 <huangjs> i see, thanks for the help
21:28:53 <kallisti> no problem.
21:29:46 <kallisti> huangjs: also may want to look at the Eval monad. it makes writing parallel code a bit more readable.
21:30:30 <kallisti> but it has no transformer that I know of.
21:31:04 <huangjs> kallisti: i'm using runEval, it's very neat
21:31:13 <kallisti> cool cool.
21:33:25 <kallisti> huangjs: it's possible that the previous programmer didn't know how to use the IO monad effectively. ;)
21:33:41 <kallisti> based on what you've said.
21:35:05 <kallisti> > (`replicateM` "abc") =<< [0..]
21:35:06 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
21:35:16 <kallisti> > zip [0..] $ (`replicateM` "abc") =<< [0..]
21:35:17 <lambdabot>   [(0,""),(1,"a"),(2,"b"),(3,"c"),(4,"aa"),(5,"ab"),(6,"ac"),(7,"ba"),(8,"bb"...
21:35:42 <lispy> does anyone else read "replicateM" as "replicate 'em!"
21:35:43 <kallisti> I would think is enough to indicate that you can write inductive proofs over the set of strings with a given finite length of alphabet.
21:35:43 <huangjs> kallisti: they wrote the first version in without monads, but in second version, they also want a similar function that dumps intermediate result, so they turned everything into monadic form
21:35:57 <kallisti> aaah
21:37:05 <kallisti> or are pure recursive functions a kind of inductive proof?
21:37:35 <ski> yes
21:37:51 <ski> at least ones which use structural recursion
21:37:56 <kallisti> ah I see.
21:37:59 <lispy> Not sure what you mean by "kind of"
21:38:17 <kallisti> I mean "I don't know about this stuff, please clue me in"
21:38:17 <lispy> Someone correct me if I'm wrong, but I thought the logic that corresponds to haskell is pretty weak.
21:38:38 <lispy> (corresponds to in the curry-howard sense, I mean)
21:38:46 * ski didn't understand it as kallisti specifically talking about Haskell
21:38:52 <lispy> ah
21:39:00 * lispy should maybe read the scroll-back
21:39:25 <kallisti> hm, well, I was talking about Haskell. but I meant "pure recursive functions" without necessarily implying "any Haskell code that's supposedly pure"
21:39:50 <kallisti> but you could write these kinds of structurally recursive functions in Haskell.
21:39:51 <lispy> kallisti: in proof based functional languages, structural recursion definitions are usually pretty easy to prove things about.
21:39:54 <ski> well, e.g. `iterate' wouldn't correspond to an inductive proof
21:40:18 <lispy> ski: co-inductive?
21:40:27 <lispy> (whatever that means)
21:40:31 <ski> but (the usual definitions of) `map',`foldr',`filter',`(++)' would
21:40:37 <ski> lispy : yeah
21:40:54 <kallisti> hm, interesting.
21:40:57 <kallisti> why not iterate?
21:41:16 <lispy> kallisti: iterate treats lists as co-data
21:41:24 <kallisti> huangjs: I actually haven't solved the "how to print intermediate values in pure code" problem myself. I haven't really needed to do that much and there's likely other ways to verify correctness.
21:41:32 <lispy> kallisti: http://blog.sigfpe.com/2007/07/data-and-codata.html
21:43:24 <huangjs> kallisti: i guess there's a debug function called trace in ghc? and the dump was for saving memory rather than verification, now it bites :)
21:44:00 <kallisti> yes trace is one way to go about debugging. I have never actually used it though.
21:44:04 <kallisti> I might look into it.
21:44:09 <ski> kallisti : "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs,Jan Rutten in 1997 at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf> might be interesting to look at
21:44:32 <kallisti> ski: thanks for the reading. :D
21:45:45 <kallisti> huh. is the sum' example uses an actual summation function?
21:45:49 <kallisti> *used
21:47:39 <kallisti> he should have maybe called it something else.
21:50:30 <kallisti> ski: I think I see where this is going. sum, which is a function on data, won't terminate on codata
21:50:41 <kallisti> or something along those lines
21:50:48 <kallisti> probably got the terminology wrong.
21:50:50 * kallisti reads on.
21:51:11 <ski> sounds probable
21:51:23 * ski can't recall seeing this sigfpe one before
21:51:32 <kallisti> but I'm seeing the distinction here.
21:51:40 <kallisti> with codata functions being sensible on codata.
21:51:48 <kallisti> and vice versa for data.
21:52:12 <nyingen> array question: I don't understand the 'ixmap' function from Data.Array.IArray. I need a function that lets me map a function over each element of an array, passing not just the element but also its index to the function
21:52:20 <nyingen> can ixmap be used for that?
21:52:27 <kallisti> @hoogle ixmap
21:52:27 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
21:52:28 <lambdabot> Data.Array ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
21:52:54 <kallisti> no. you want another function
21:52:55 <kallisti> let me look it up.
21:53:14 <lispy> nyingen: you may find Data.Vector to be more pleasant and faster.
21:53:23 <nyingen> I have to use IArray due to a library dependency
21:53:23 <kallisti> yes Data.Vector has that function for you.
21:53:34 <lispy> nyingen: but Data.Vector doesn't do multidimensional arrays...
21:53:40 <lispy> ah
21:53:45 <kallisti> it does if you define a proper indexing function. ;)
21:53:51 <nyingen> I guess I can write the function myself
21:54:02 <nyingen> I just wasn't sure what ixmap was supposed to be for
21:54:17 <kallisti> nyingen: using the array functions I think the best choice would be to map on assocs
21:54:21 <kallisti> and then pipe that into listArray
21:54:33 <kallisti> but that sounds questionable in terms of efficiency.
21:54:34 <nyingen> assocs?
21:54:38 <kallisti> @hoogle assocs
21:54:38 <lambdabot> Data.IntMap assocs :: IntMap a -> [(Key, a)]
21:54:39 <lambdabot> Data.Map assocs :: Map k a -> [(k, a)]
21:54:39 <lambdabot> Data.Array.IArray assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
21:54:44 <nyingen> I see
21:54:49 <kallisti> it gives you a list of index/value pairs
21:54:58 <nyingen> yeah, should be ok for this application
21:55:03 <kallisti> if you're not too concerned with efficiency I think that would be sufficient
21:55:08 <kallisti> oh wait it's not listArray
21:55:10 <nyingen> I'm having to turn it into a list anyway
21:55:12 <kallisti> that you'd want to use.
21:55:29 <kallisti> you would want to use array
21:55:36 <kallisti> @hoogle Data.Array.array
21:55:36 <lambdabot> Data.Array data Array i e :: * -> * -> *
21:55:37 <lambdabot> Data.Array.IArray data Array i e :: * -> * -> *
21:55:37 <lambdabot> Data.Array.IArray array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
21:55:50 <nyingen> got it
21:55:51 <nyingen> thanks
21:56:00 <kallisti> no problem.
21:56:03 <nyingen> I agree about Data.Vector, btw
21:56:10 <kallisti> yeah it's much better..
21:56:12 <nyingen> but the fftw binding demands CArray
21:57:07 <kallisti> nyingen: I want to say you could probably convert from Vector to Array pretty painlessly
21:57:17 <kallisti> but I'm not sure.
21:57:19 <ski> hm, in SML it's called `mapi' ..
21:59:25 <kallisti> @hoogle Vector a -> CArray i a
21:59:26 <lambdabot> Warning: Unknown type Vector
21:59:26 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
21:59:26 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
23:11:20 <unlink> acowley: Thanks. That is what I am doing now.
23:21:35 <dibblego> has anyone compared HTF vs test-framework?
23:32:23 * hackagebot URLb 0.0.1 - DEPRECATED A simple, liberal URL parser.  http://hackage.haskell.org/package/URLb-0.0.1 (JasonDusek)
