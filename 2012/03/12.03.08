00:00:51 <NemesisD> i gotta run. thanks for the help all
00:01:53 <dmwit> Thank goodness for VirtualBox. Saving and restoring snapshots is about as close as computer science comes to magic.
00:02:31 <astor> dmwit: it's just implemented as a persistent data structure, right? :-)
00:02:49 <dmwit> heh
00:03:33 <tikhonjelvis> dmwit: I suspect what counts as magic in CS varies person to person quite a bit.
00:04:07 <tikhonjelvis> I still think even the most primitive learning algorithms are magic. But I am easy to please :).
00:04:28 <dmwit> =)
00:04:45 <shachaf> "magic" is just another word for "primitive"
00:05:46 <DanBurton> @remember shachaf "magic" is just another word for "primitive"
00:05:47 <lambdabot> It is forever etched in my memory.
00:06:31 <companion_cube> "magic" is just a word for "cookie"
00:07:09 <tikhonjelvis> Well, cookies *are* magical, I cannot deny.
00:08:36 <mjrosenb> i,i any technology distinguishable from magic is insufficiently advanced
00:09:42 <astor> if one wants to write a list like so:   loop ... = (xpression ...) : (loop $ ...)  is there an idiomic way to avoid the parenthesis?
00:11:01 <tikhonjelvis> Chances are you don't need the first set of parentheses as is.
00:11:11 <Peaker> astor: loop .... = xpression ... : loop (...)
00:11:48 <astor> tikhonjelvis: right, (I had a tuple there..)
00:12:05 <shachaf> astor: Tuples require parentheses.
00:12:22 <shachaf> And $ has lower precedence than :, but you can always write the expression without the $
00:13:49 <astor> Peaker: thanks
00:16:04 <dmwit> astor: You might be interested in iterate and map.
00:16:35 <dmwit> ?src iterate
00:16:35 <lambdabot> iterate f x =  x : iterate f (f x)
00:22:03 * kallisti fixes a large batch of type errors.
00:22:10 * kallisti watches as a torrent of ambiguous type variables fill his terminal.
00:22:48 <Veinor> kallisti: always fun
00:23:09 <tikhonjelvis> Hey, the more errors you have, the more satisfying is it to fix all of them.
00:25:38 <kallisti> sometimes I program Haskell on autopilot
00:25:58 <kallisti> a) try to compile b) fix error c) try to compile d) fix error ...
00:26:13 <tikhonjelvis> That works well for some things.
00:27:59 <kallisti> oh hmmm... interesting
00:28:54 <kallisti> from Aeson:  (.=) :: JSON a => Text -> a -> Pair
00:29:13 <kallisti> if I turn on OverloadedStrings to make it convenient to write the Text fields as string literals
00:29:19 <kallisti> then things like:   "field" .= "value"
00:29:21 <kallisti> become ambiguous.
00:29:46 <kallisti> so I have to say "field" .= ("value
00:29:55 <kallisti> " :: String)
00:31:40 <kallisti> this is where something like a generalize default would come in handy. so that I could default IsString to String.
00:31:44 <kallisti> of course that's really dangerous as well.
00:33:35 <kallisti> huh, it compiles. but with a long list of what I'm guessing is TH warnings.
00:36:18 <kallisti> http://sprunge.us/PfIS
00:36:22 <kallisti> any idea what these warnings are all about?
00:36:38 <kallisti> they're very cryptic.
00:37:52 <quintessence> kallisti: SpecConstr is an optimization pass
00:38:00 <kallisti> ah
00:38:04 <quintessence> I have no idea why it's spewing warnings at you though
00:39:05 <kallisti> I'll see if -v gives any more info.
00:39:56 <kallisti> quintessence: it's likely from one of those dependencies.
00:40:07 <kallisti> http://sprunge.us/PfIS  verbose output
00:41:25 <kallisti> quintessence: would there be any reason not to reset -fspec-constr-count ?
00:41:56 <quintessence> are you using 7.0?
00:42:11 <kallisti> quintessence: 7.0.4 to be exact
00:42:32 <quintessence> it looks like http://hackage.haskell.org/trac/ghc/ticket/5125 is the issue, and you can suppress it with -dno-debug-output
00:43:49 <kallisti> quintessence: hm, weird.
01:19:17 <zeiris> Which array package should I use if I'm more concerned with code quality/looks, than performance?
01:20:19 <shachaf> It depends on what you're actually doing.
01:20:58 <zeiris> Simple cryptanalysis, doing a lot of playing in the shell/editing code.
01:27:21 <dmwit> zeiris: vector is nice
01:31:31 <unlink> How would I phrase this Applicatively? do { w <- many1 letter ; guard (w `elem` ["abc","abd","efg"]) ; return w }
01:34:56 <DanBurton> guard requires MonadPlus
01:35:29 <DanBurton> @hoogle guard
01:35:29 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
01:35:30 <lambdabot> Language.Haskell.TH.Syntax data Guard
01:35:30 <lambdabot> Language.Haskell.TH data Guard
01:35:32 <unlink> yes.
01:35:42 <DanBurton> so you can't use just Applicative
01:35:58 <DanBurton> iinm
01:36:02 <unlink> sure, or even Alternative.
01:38:53 <azn> hi
01:39:52 <quintessence> @hoogle MonadPlus m => (a -> Bool) -> m a -> m a
01:39:53 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
01:39:53 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
01:39:53 <lambdabot> Data.Sequence dropWhileL :: (a -> Bool) -> Seq a -> Seq a
01:57:28 <hpaste> hasknoob pasted “HGL Install” at http://hpaste.org/64970
01:58:10 <hasknoob> I just tried to install the graphics library using cabal install HGL.  -  what's the problem?
02:05:34 <hasknoob> Can someone please help. I am trying to install the graphics library HGL and get the following out http://hpaste.org/64970 . What at I doing wrong.
02:06:14 <gienah> hasknoob: trying to install it
02:07:01 <hasknoob> gienah: so what are you saying?
02:07:32 <dmwit> hasknoob: It looks like HGL hasn't been updated in a while.
02:07:50 <gienah> hasknoob: you could try wx, qtHaskell or gtk
02:07:51 <dmwit> You could attempt to update it yourself; "cabal unpack HGL" and then muck about with the cabal file in the resulting directory.
02:08:11 <dmwit> Probably simply updating the version requirements on base would allow it to build.
02:08:16 <dmwit> If it does, good for you.
02:08:16 <hasknoob> Is there any graphics package that is installable for simple graphics?
02:08:50 <dmwit> However, as gienah suggests, it's probably easier to use one of the better maintained packages.
02:09:12 <dmwit> If you choose gtk, you should wait a few hours; I plan to make a release soon. =)
02:09:41 <hasknoob> I don't know any packages. I just googled Haskell Graphics and found HGL
02:10:27 <hasknoob> dmwit: Really? :)
02:10:31 <hasknoob> hehe
02:10:44 <hasknoob> Cool
02:13:04 <hasknoob> out of wx, qtHaskell and gtk - which is OK for basic noobishness
02:13:19 <hasknoob> something to toy with now
02:15:19 <gienah> hasknoob: I guess the most popular ones are gtk: http://www.haskell.org/haskellwiki/GTK it has links to some tutorials, and wx, for wx you might need to look at tutorials for the underlying wxWidgets C++ library
02:16:00 <gienah> hasknoob: for wx: http://www.haskell.org/haskellwiki/Wx
02:17:15 <hasknoob> I have not heard of wx - but thats not a problem
02:17:27 <gienah> qtHaskell seems to be mostly ignored (I guess because its not on hackage and its GPL license): http://qthaskell.berlios.de/
02:17:53 <dmwit> If you want to use OpenGL, there are good libraries for that, too.
02:18:32 <dmwit> hasknoob: Have you seen Hackage?
02:18:56 <hasknoob> dmwit: I have heard of it
02:19:13 <astor> hasknoob: the chart package which is built on gtk has a few nice examples that you can get up and running quickly.  what type of graphics do you need?
02:19:40 <dmwit> ...and there are SDL bindings, too. So I guess the question is which graphics library you're familiar with from another language.
02:20:15 <hasknoob> astor: anything - just so I can start drawing
02:21:11 <hasknoob> astor: OpenGL would be OK - simple 2D would be OK - I am not reallu into GUI design though - more for gaming
02:22:08 <gienah> hasknoob: there are some games on hackage, they tend to use opengl
02:22:11 <hasknoob> but I imagine the larger package provide drawing surfaces
02:23:55 <vasanth_> nick
02:27:58 <vasanth_> quit
02:28:31 <_Mikey> If a function prints to console returning IO ()
02:28:45 <_Mikey> is it impossible to retrieve what was printed with another function?
02:29:24 <dmwit> Yes.
02:29:57 <dmwit> ...I suppose it's probably technically possible.
02:29:59 <shachaf> You could probably reopen stdout to a pipe and then read it.
02:30:04 <shachaf> Or something along those lines.
02:30:07 <dmwit> But you should treat it as impossible and restructure your code so that you don't need to do that.
02:30:18 <_Mikey> ok :(
02:30:19 <dmwit> shachaf: right
02:30:33 <geekosaur> didn't someone write a package that wraps a Handle around a scalar?
02:32:47 <geekosaur> in theory you might be able to reopen stdout onto such a handle, although I'd have to check how hardcoded the stdout filehandle is in GHC.IO to say for certain
02:36:21 <shachaf> But you shouldn't do any of these things.
02:36:34 <shachaf> For example, probably all of these solutions aren't thread-safe.
02:41:51 <janusz2> I have a class, and I want to make an instance of it for Int and Integer types. They are actually the same, is there a way in the syntax like : instance XXX Int, Integer, or something so I don't have to repeat myself ? I couldn't find anything on the net.
02:44:44 <shachaf> janusz2: You could do instance (Integral a) => MyClass a...
02:46:12 <janusz2> shachaf: Thx, that's a good start (and probably the right way to do it with Int and Integer). But how about types that don't have such "common ancestor" ?
02:46:28 <shachaf> How does the same implementation work for both types?
02:47:27 <shurikas> @hoogle m1 a -> m2 a
02:47:28 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
02:47:28 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
02:47:28 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
02:47:40 <rostayob> janusz2: if you do that you'll need overlapping instances if you have any other instances.
02:47:52 <rostayob> (If you do Integral a => MyClass a)
02:48:21 <janusz2> Yes I have other instances
02:48:28 <shachaf> Yes, that's true. It's not a very good solution in general.
02:50:43 <janusz2> shachaf: I am only a beginner in Haskell, and it's kind of hard for me to give you a good example other than of types like Int and Integer, where almost all operations are basically the same.
02:51:25 <janusz2> So what's the best way to go around this ? Use (Integral a) => ... or just repeat the code ?
02:51:29 <franco00> I have a datatype like data SmartString = SS (Char, Otherthing) . It would be awesome to "overload" functions like dropWhile? I mean, It would be great to have: dropWhile (/=' ') smartString , it returning [('I', property), ('t', otherProperty)]
02:51:32 <franco00> Possible?
02:51:48 <rostayob> janusz2: repeat the code
02:52:26 <rostayob> unless the only instance is the Integral one, or unless you know what you're doing and enable OverlappingInstances
02:52:44 <janusz2> rostayob: thx, I thought maybe there was a better way :)
02:52:59 <rostayob> franco00: it would be possible if dropWhile worked on some class, but it doesn't.
02:53:22 <rostayob> :t dropWhile
02:53:23 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:53:47 <rostayob> so in your case, you do 'dropWhile ((/= ' ') . fst) smartString'
02:54:06 <franco00> rostayob: yeah, I thought there was some hidden [] class or the like. Thanks for the tip, I'll do it like that
02:54:29 <rostayob> franco00: [] is a type constructor, no classes involved
02:57:12 <Axman6> [] is a data constructor no? (i guess it can be used as a type constructor too... but still, you'd not usually do so)
02:57:46 <rostayob> Axman6: you do that all the time. it's both
02:57:53 <rostayob> :t [] 5
02:57:54 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `[a]'
02:57:54 <lambdabot>     In the expression: [] 5
02:57:56 <rostayob> well
02:57:59 <rostayob> :t [5]
02:58:00 <lambdabot> forall t. (Num t) => [t]
02:58:04 <rostayob> :k [Int]
02:58:05 <lambdabot> *
02:58:08 <rostayob> :k [] Int
02:58:09 <lambdabot> *
02:58:23 <rostayob> :k []
02:58:23 <lambdabot> * -> *
02:58:38 <rostayob> :t []
02:58:39 <lambdabot> forall a. [a]
03:09:00 <unlink> For some reason, ghc is getting very confused when I use the -XCPP extension. The program "main = return () -- '" (with the ' in a comment) will warn me about an unterminated character literal.
03:09:41 <rostayob> unlink: let me gues, you're using max os x
03:09:43 <ivanm> unlink: I've had other issues with -XCPP; only enable it where and when you need it ;)
03:10:00 <Jafet> If you use CPP, your program may need to avoid confusing cpp.
03:10:50 <unlink> Well, actually I'm not using it, libraries like Network are.
03:11:01 <unlink> rostayob: You are correct.
03:11:09 <rostayob> unlink: yes, the cpp version shipped with recent mac os x do that.
03:11:27 <unlink> Consequently, the Haskell Platform ain't buildin'.
03:11:31 <rostayob> I'm not sure if they're "right" or "wrong" in doing that but it's a problem that has annoyed a lot of people.
03:12:10 <unlink> rostayob: True. Using cpp for non-C languages is a Bad Idea(TM), IMO.
03:12:38 <Jafet> They're not right nor wrong; we are wrong
03:12:38 <rostayob> unlink: why?
03:12:58 <rostayob> Jafet: with right I meant "adhering to the standard"
03:13:17 <unlink> rostayob: Because other languages aren't C. C tokenizes the way C does, and you shouldn't be surprised when other languages tokenize differently.
03:13:20 <Jafet> I thought GHC would have its own preprocessor by now.
03:13:50 <rostayob> unlink: that's a very vague statement, but yeah a dedicated preprocessor would be better.
03:14:25 <unlink> rostayob: In practice, you can get a lot of mileage out of the C preprocessor if your language is C-like.
03:15:40 <Jafet> rostayob: a /* b = ()
03:15:45 <unlink> As it turns out, Haskell (with -- and {- -} comments), is sometimes not very C-like, at least according to the CPP installed on my system.
03:16:12 <rostayob> unlink: I think your cpp might be right, but anyways, you might want to try this http://projects.haskell.org/cpphs/
03:17:13 <rostayob> unlink: http://projects.haskell.org/cpphs/#how
03:17:31 <Jafet> Also, cpp would probably complain about any use of foldl'
03:18:15 <unlink> My present goal is to compile the Haskell Platform.
03:18:43 <unlink> With a near-term goal of installing libraries which use -XCPP.
03:20:54 <rostayob> unlink: on a normal platform you could install gcc and use its cpp. i'm not sure that's easy on a mac.
03:21:22 <mjrosenb> iirc, you can get XCode for OSX without too much trouble
03:21:26 <mjrosenb> and that should have cpp
03:21:28 <Jafet> Why does a cpp warning prevent you from building packages?
03:21:42 <rostayob> mjrosenb: yeah, with a cpp that doesn't build haskell packages.
03:22:46 <Jafet> You can get any cpp trivially by installing it over your existing cpp
03:23:09 <rostayob> Jafet: it's not that trivial from what I've heard
03:23:25 <rostayob> but anyways mac people will know better
03:24:01 <unlink> Jafet: it's the cpp errors I'm more afraid of.
03:24:09 <Jafet> Or even using the ghc command line.
03:24:50 <unlink> e.g. -- ``Setup''
03:37:05 * hackagebot uniplate 1.6.7 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.7 (NeilMitchell)
03:41:06 <hpaste> unlink pasted “transformers build failure” at http://hpaste.org/64973
03:41:36 <hpaste> anborn pasted “Explicit typing” at http://hpaste.org/64974
03:41:37 <unlink> rostayob: Your suggestion worked well. I changed the ghc startup script to use cpphs.
03:43:21 <anborn> hi, I have this code (http://hpaste.org/64974) where I'm using the type "t" twice: once defining the function type and once in the function body. ghci is not understanding that I'm referring to the same type in both cases. How can I fix that?
03:44:11 <Axman6> :set -XScopedTypeVariable I think
03:44:21 <merijn> Don't types need to be capitalised?
03:44:51 <Axman6> only concrete types.
03:44:53 <merijn> Unless it's a type variable, in which case why even bother specifying "y = x :: t"
03:45:04 <merijn> Since you're throwing out x and y anyway
03:45:04 <anborn> Axman6: already tried ScopedTypeVariables :-(
03:45:13 <Axman6> like Int, but Maybe a has a type a, which isn't concrete
03:45:25 <anborn> Axman6: I was expecting that to work...
03:45:26 <Cale> anborn: you need to use ScopedTypeVariables and explicitly quantify the t
03:45:32 <Cale> f :: forall t. t -> Int
03:45:43 <Cale> f x = let y = x :: t in 2
03:46:06 <anborn> Cale: ah! I was missing the explicit quantification!
03:46:28 <anborn> Cale: thx
03:52:45 <rostayob> unlink: good
03:52:57 <rostayob> maybe ghc should just switch and ship with cpphs
03:53:27 <unlink> Having worked around the CPP issue, the compilation failure of transformers-0.2.2.0 has reared its ugly head.
03:54:01 <rostayob> unlink: let's see
03:54:12 <rostayob> you're installing transformers from the HP?
03:54:25 <hpaste> efie pasted “readIO” at http://hpaste.org/64975
03:54:59 <unlink> rostayob: I tried that, and bootstrap.sh from cabal-install.
03:55:32 <rostayob> unlink: wait. why do you even need to worry about bootstrap.sh?
03:55:52 <rostayob> the steps are: download ghc binaries (in this case 7.0.4), install that, download HP install that
03:56:06 <efie> can anyone glimps at what I posted above and help me?
03:56:18 <rostayob> unlink: I think that your problem is that
03:56:34 <rostayob> your installing the HP with a newer version of GHC
03:56:41 <rostayob> that includes those instances in base
03:57:11 <unlink> rostayob: oh, thanks.
03:57:39 <rostayob> efie: above where?
03:57:48 <efie> rostayob: http://hpaste.org/64975
03:58:14 <efie> ([12:54] <hpaste> )
03:58:55 <rostayob> efie: ok
03:58:59 <rostayob> > "blah"
03:59:00 <lambdabot>   "blah"
03:59:04 <rostayob> > read "blah"
03:59:05 <lambdabot>   *Exception: Prelude.read: no parse
03:59:12 <rostayob> > read (show "blah")
03:59:12 <lambdabot>   *Exception: Prelude.read: no parse
03:59:25 <rostayob> > read (show "blah") :: String
03:59:26 <lambdabot>   "blah"
03:59:32 <rostayob> > read "blah" :: String
03:59:33 <lambdabot>   "*Exception: Prelude.read: no parse
03:59:36 <rostayob> efie: the problem here
03:59:50 <rostayob> you want to see 'read' as the opposite of 'show'
04:00:04 <rostayob> read wants strings to be quoted so that they are unequivocably strings
04:00:17 <rostayob> on the other hand
04:00:26 <rostayob> you don't need to "read" that string at all. it's already a string
04:00:29 <rostayob> so that's rarely a problem.
04:00:59 <rostayob> efie: why are you doing what you're doing?
04:02:29 <rwbarton> in short, 'input' is already the string you read in. no need for readIO at all.
04:03:37 <rwbarton> Putting " around input doesn't "convert it to a String".
04:03:51 <rwbarton> That exception you see is a run time error.
04:03:59 <vodik_> well, it converts it to the proper serialized representation
04:04:04 <rwbarton> Because your input is not the representation of a String
04:04:11 <rostayob> vodik_: not really.
04:04:11 <rwbarton> Right
04:04:19 <rwbarton> Well, if you're lucky.
04:04:20 <rostayob> vodik_: because "read" reads escaped character
04:04:41 <efie> rwbarton: I don't want to do anyhting certain at all, I was just looking at the types and could not make sense of it
04:04:54 <rwbarton> that's because you seem to think you are getting a type error
04:04:57 <rwbarton> but you're not
04:05:15 <rwbarton> both programs compile fine
04:05:20 <rostayob> efie: your types are fine. Yes, haskell has run time errors!
04:05:49 <rwbarton> And, in Haskell, run time errors are not type errors. :)
04:06:24 <efie> rwbarton: ok, thanks for your answer :)
04:06:38 <mrcarrot> it is easy to get runtime errors... but you are lucky that they will make the program crash at the same moment rather than to pollute something
04:06:48 <mrcarrot> > [1,2,3] !! 5
04:06:49 <lambdabot>   *Exception: Prelude.(!!): index too large
04:06:58 <mrcarrot> that is for example one example
04:07:22 <mrcarrot> wrong usage of foldr might give stack overflow
04:07:27 <mrcarrot> and a crash immediately
04:15:03 <xil> hey everyone. So I was using "interact" for this parser  I wrote, but now I need to change it so that I don't output anything, just return IO (). How do I replicate the input behavior of interact? I.e., get the entirety of piped input and send it to a function whole
04:16:03 <rwbarton> getContents >>= f  where f :: String -> IO ()
04:16:39 <xil> rwbarton: awesome, thanks =D
04:35:41 <xil> I'm having an error I can't figure out. It's "expecting [[Char]], actual Column -> [String]" and the line in question is "map (map ("  " ++) . genColumnString) $ M.elems cs" where cs :: M.Map Int Column and genColumnString :: Column -> [String]
04:35:57 <xil> oh and the error is about genColumnString
04:40:16 <xil> ah found the problem
04:40:29 <xil> syntax error somewhere else
04:42:27 <Rc43> Hi, guys.
04:46:09 <merijn> xil: genColumnString is not getting a column argument
04:46:33 <merijn> xil: The rest of your code expect [[Char]] (i.e. [String]), presumably the result of genColumnString
04:46:55 <merijn> But it's getting "Column -> [String]" (presumably genColumnString
04:49:28 <merijn> xil: Oh, guess I should've read three lines further where you found out :p
04:50:38 <xil> yeah it's that I left out a @ in the definition of genColumnString and that made it think there were 2 arguments to it when there should be only 1
04:51:07 <xil> just goes to show I should provide type declarations even for auxiliary functions
04:52:40 <edwardk> elliottt: i'd hazard not ;)
04:59:52 <hpaste> osager pasted “how to understand the newline and string in this code” at http://hpaste.org/64976
05:00:56 <Botje> which newline? which string?
05:01:03 <Botje> there's rather a lot of them :P
05:01:53 <osager> all of them
05:02:02 <osager> i dont think they are functions
05:02:04 <osager> of haskel
05:02:13 <Botje> no, they're parsec actions.
05:02:15 <osager> i can't understand this grammer
05:02:21 <osager> ok...
05:02:25 <osager> parsec
05:02:31 <osager> i dont know abou this library
05:02:31 <Botje> each line in the do block is an action that parses something
05:02:56 <Botje> and the do block glues them all together in one big parser, which you can use in the rest of your program.
05:03:14 <Botje> most of the parsers are self-explanatory, i think
05:03:33 <osager> thank you very much botje
05:17:23 * hackagebot HsOpenSSL 0.10.1.4 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.1.4 (MasatakeDaimon)
05:31:27 <franco00> mhhhh if String is nothing more than type String = [Char], how can it have a Show instance? I thought only data and newtype could do that
05:32:03 <franco00> (a 'show' function rather than "Show instance")
05:36:13 <Igloo> It doesn't, but there is a showList method of the Show class too
05:37:37 <franco00> thanks
05:37:41 <osager> how to build a cabal package without installing it ?
05:37:51 <osager> during developement
05:37:55 <osager> i want to test the program
05:38:35 <osager> which command i issue ? something like cabal build ?
05:39:15 <geekosaur> "cabal unpack $packagename", then cd into the package directory and "cabal build"
05:40:04 <osager> ok thanks
05:41:04 <pozic> I get: GHCi runtime linker: fatal error: I found a duplicate definition for symbol __hscore_S_IFDIR
05:41:45 <pozic> This could be caused by:
05:41:45 <pozic>    * Loading two different object files which export the same symbol
05:41:45 <pozic>    * Specifying the same object file twice on the GHCi command line
05:41:45 <pozic>    * An incorrect `package.conf' entry, causing some object to be
05:41:45 <pozic>      loaded twice.
05:41:48 <pozic> GHCi cannot safely continue in this situation.  Exiting now.  Sorry.
05:44:24 <pozic> This happens when I install the directory package from hackage.
05:44:52 <pozic> At that point there are two versions of directory installed.
05:45:04 <pozic> I don't see why that should cause any issue, but it does.
05:45:30 <pozic> (other than that it has been wrongly designed by whoever wrote GHC)
05:46:00 <ChristianS> pozic: directory comes with ghc, i think? in that case, you shouldn't try to re-install it.
05:47:25 <Saizan> symbols generated from haskell defs are versioned, symbols from C sources aren't
05:48:04 <Saizan> so loading two versions of the same package is doable only if doesn't contain the latters
05:52:05 <hpaste> osager pasted “grep parameter question” at http://hpaste.org/64978
05:53:05 <geekosaur> pozic, is the fact that you would get a link error for using two different versions of the same library in C or C++ also "wrongly designed"
05:53:05 <pozic> ChristianS: I have a different opinion: it shouldn't allow me to re-install it.
05:53:07 <geekosaur> ?
05:53:16 <pozic> geekosaur: yes
05:53:24 <geekosaur> *that* I won;t argue although the cabal devs do argue it
05:53:43 <geekosaur> pozic, how would you insure that they can never conflict?
05:53:53 <osa1> is there a way to see documentation of a function in ghci?
05:53:57 <geekosaur> if you have an answer there's a Ph.D thesis and probably a lot of money in it
05:54:34 <Saizan> osa1: not really, the closer you get is using the command-line hoogle with --info
05:54:41 <geekosaur> (it can be solved for some limited cases, unless you count the brute force metho of versioned symbols which simply insures that one version isn't actually used)
05:55:01 <pozic> geekosaur: I don't actually know what the exact problem is.
05:55:08 <geekosaur> that seems evident
05:55:26 <pozic> geekosaur: I do know that I would never design something broken like that.
05:55:27 <geekosaur> if you did, you would not be expecting it to work
05:55:38 <geekosaur> fine, fine.  design it working and claim your Ph.D
05:55:49 <geekosaur> I'm serious
05:55:54 <pozic> geekosaur: the basic problem is providing a mapping from names to pieces of code.
05:56:20 <geekosaur> [08 13:56] <pozic> geekosaur: I don't actually know what the exact problem is.
05:56:26 <geekosaur> suggest you go learn what that exact problem is
05:56:56 <pozic> geekosaur: uhm, if someone wants me to solve a problem another human created, I think the solution is to remove that other human.
05:57:20 <geekosaur> ...excellent idea
05:57:28 <pozic> geekosaur: that other human could take the time to properly describe the problem.
05:57:35 <pozic> geekosaur: I am not the one who should to the write up.
05:57:41 <pozic> should do
05:58:59 <pozic> geekosaur: if you actually would know the exact fundamental problem, you would have provided a link to a scientific paper by now.
05:59:32 <pozic> geekosaur: I think the fundamental problem is not a computer science problem, but just lots of people that used a computer which shouldn't have done that.
05:59:53 <pozic> Just like PHP and Ruby exist.
06:00:57 <merijn> pozic: Unfortunately for you, you can't prevent that and so you just have to deal with the situation
06:01:12 <pozic> Also, saying that a problem which really is on the output of GHC is really caused by someone else is extremely stupid.
06:01:23 <pozic> GHC choses to 'leverage' broken technology.
06:01:58 <pozic> chose
06:02:01 <merijn> The solution would be to not leverage any technology at all and be incompatible with all existing code...
06:02:30 <pozic> If the old technology has fundamental problems, you should dump it, sure.
06:02:34 <pozic> You can still use the old code.
06:02:45 <pozic> The old code are simply denotations of computations.
06:02:53 <pozic> It doesn't mean you have to use the same linker.
06:03:05 <pozic> Or same object format for libraries.
06:03:26 <merijn> At the cost of a lot of man hours which might be better invested elsewhere
06:03:41 <pozic> While I am fine with the notion that it isn't perfect yet, I do object to this notion to point at someone else.
06:03:42 <merijn> There is a finite size budget, which means prioritising
06:03:44 <t7> anyone know of a massively scalable relational database?
06:03:57 <pozic> t7: Oracle
06:03:58 <merijn> t7: Oracle? :p
06:04:12 <pozic> Oh, you want it to be free and with a pony?
06:04:16 <Elemir> Berkeley db!
06:04:19 <t7> just open sauce
06:04:38 <Elemir> But it doesn't relational…
06:04:47 <Elemir> And doen't scalable :D
06:04:53 <pozic> Elemir: I don't wish BDB to my worst enemies.
06:04:55 <Elemir> *isn't
06:04:56 <t7> but it is tiny
06:05:30 <Elemir> Oracle is based on bdb, isn't it?
06:06:02 <t7> does postgre have to take input as a string sql query?
06:06:22 <t7> i guess parsing a string is not gonna be the bottleneck with a db query....
06:06:26 <pozic> t7: you want to send it a binary internal representation?
06:06:43 <pozic> t7: I also think not.
06:07:07 <pozic> I think there is no SQL database that is designed in the way I would like to see it work.
06:07:18 <Clint> clearly you want noql
06:07:20 <Clint> s
06:07:21 <Clint> dammit
06:07:31 <pozic> Perhaps SQL server works like I want it to work.
06:07:32 * hackagebot clean-home 0.0.4 - Keep your home dir clean by finding old conf files  http://hackage.haskell.org/package/clean-home-0.0.4 (IvanPerez)
06:08:04 <pozic> I know MySQL and PostgreSQL are not designed to be maintenance free.
06:08:48 <Entroacceptor> databases in principle aren't designed for that
06:08:56 <pozic> You should be able to give the Dell service guy the keys to your server and replace it every two years and not have any other maintenance on them.
06:09:10 <osa1> do I have to reinstall all libraries if I update ghc? I want to install leksah but looks like it needs a newer version of ghc than mine
06:09:10 <t7> isnt nosql just a key/value store?
06:09:11 <pozic> (I mean to swap hard disks)
06:09:33 <pozic> osa1: yes, one by one. Enjoy the breakage!
06:10:34 <osa1> pozic: fine. leksah can wait until I upgrade my distro :)
06:24:41 <td123> does anyone have any clue on how to fix this? http://pastie.org/3548657
06:27:41 <Saizan> td123: try cabal install --with-alex=/home/tom/.cabal/bin/alex hoogle
06:29:15 <td123> Saizan: worked, thanks :)
06:33:48 <t7> does anyone know off a database development app/environment like microsoft access or openoffice base, but with a webserver front end rather than a software runtime environment ?
06:34:41 <sipa> in haskell?
06:35:42 <t7> preferably
06:37:27 <td123> wasn't there a demo of having openoffice run through a webserver?
06:37:35 <td123> err, libreoffice
06:39:30 <td123> http://www.youtube.com/watch?v=xY_0_ojrUrQ could be worth checking out on the progress
06:40:15 <t7> that emulating a whole desktop application with gtk and stuff
06:40:19 <t7> i just want html forms
07:08:24 <hoverbear> http://s3.amazonaws.com/lyah/listmonster.png <-- Just totally made my day.
07:09:31 <Skola> yes it's quite cute, like all drawings from the book
07:09:35 <Skola> I wish my copy was in color
07:09:38 <hoverbear> It's freaking adorable
07:10:06 <Skola> even my mom liked the book, though purely on merit of those illustrations
07:10:18 <xplat> what's a good example of a package that internally includes a C library that is built with autoconf?
07:10:26 <hoverbear> So, as a person learning haskell (on linux) would building my own xmonad config offer a nice "First stop" on the trip?
07:10:41 <hoverbear> Skola: Yeah it's pretty darn adoarable
07:10:44 <xplat> where the packaging is done well
07:10:56 <davorb_> hoverbear that's sort of like asking would making my own .emacs file be a good start to learn lisp, imho
07:11:10 <hoverbear> davorb_: I don't know the answer to that, either. :-P
07:11:28 <Skola> the answer is no :}}
07:11:34 <hoverbear> Magic, thank you. :3
07:11:44 * zhulikas thought about yes :(
07:11:45 <davorb_> hoverbear i don't think you'll get much out of it. this will help you more http://www.learnyouahaskell.com/
07:11:50 <xplat> i would say 'if you already use xmonad, maybe a little, otherwise it's just plain distracting'
07:11:58 <hoverbear> davorb_: I'm reading that already. :3
07:12:11 * hoverbear just linked http://s3.amazonaws.com/lyah/listmonster.png from the book.
07:12:19 <davorb_> ah
07:12:32 <hoverbear> Back later, thanks.
07:12:42 <td123> davorb_: maybe editing xmonad.hs is good for practicing what you read in a tutorial
07:12:43 <davorb_> i guess doing all of the exercises from SICP in haskell would be good
07:12:58 <franco00> I want to export everything from a module *and* reexport a functio I have imported in such module, is there a quick way of doing it, without typing module MyMod ( funcA, funcB, funcEtcEtc ) ?
07:18:10 <xplat> franco00: use module MyMod ( module MyMod, moreStuff )
07:18:30 <franco00> cool! thanks!
07:20:02 <xplat> is there a channel for cabal?
07:24:57 <hpaste> sanjoyd pasted “instance” at http://hpaste.org/64979
07:25:00 <sanjoyd> Is there some way I can access the types we are writing an instance for inside the instance declaration?  ^^
07:25:26 <sanjoyd> The above does not compile because of `Ambiguous type variable `a0' in the constraint:'
07:27:09 <rwbarton> sanjoyd, I'm not sure whether you can do it directly with ScopedTypeVariables or something like that, but I can offer a workaround
07:27:22 <sanjoyd> rwbarton: go on, please.
07:27:35 <rwbarton> c x = (n (undefined `asTypeOf` fst x), n (undefined `asTypeOf` snd x)
07:27:48 <sanjoyd> The point is x might itself be undefined.
07:27:56 <rwbarton> that's fine
07:27:56 <sanjoyd> So I can't do fst x or fst y.
07:27:58 <Rc43> I am looking at http://projects.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Abstract-Widget.html and here is ther words `The child visibility can be set for widget before it is added to a container with widgetSetParent`. I can't google/hoogle this function. Btw, it will be very useful to get similar function.
07:28:00 <rwbarton> sure you can
07:28:01 <sanjoyd> Oh, okay.
07:28:12 <sanjoyd> Since I'm just doing an `asTypeOf`?
07:28:14 <rwbarton> asTypeOf doesn't evaluate its second argument, it is there juts to pin down the type
07:28:18 <sanjoyd> So it won't really matter?
07:28:22 <sanjoyd> Nice!
07:28:28 <merijn> yay, laziness!
07:28:34 <sanjoyd> I'll still have a look at ScopedTypeVariables, though.
07:29:28 <sanjoyd> Ah, I guess I
07:29:29 <rwbarton> I guess at worst with ScopedTypeVariables you could write   c = c' where { c' :: forall a b. (a, b) -> (Int, Int); c' _ = (n (undefined::a), n (undefined::b)) }
07:29:46 <sanjoyd> 'll use ScopedTypeVariables.  It seems to work "out of the box".
07:29:48 <rwbarton> but I'm not sure you can refer to a and b from the instance declaration head directly
07:29:51 <rwbarton> oh really? ok
07:29:53 <rwbarton> good to know :)
07:30:00 <sanjoyd> It seems I can.  The example compiles.
07:30:07 <sanjoyd> But thanks for the tip, rwbarton
07:30:44 <rwbarton> yeah, no problem. the asTypeOf thing is usually effective, but a bit ugly
07:30:58 <Rc43> Oh, but here is `reparentWidget`, it is looks like what I need.
07:30:58 <sanjoyd> Reminds me of Java.
07:35:47 <xplat> Rc43: yeah, you sometimes end up with problems like that because a lot of the documentation comes straight from gtk, so if there are interface changes they are not always reflected.
07:37:31 <trap> hello
07:37:31 <Rc43> btw, is gtk api just cloned to similar in haskell? (where interface is type class, etc)
07:41:49 <Rc43> Hm, it is gtk question, but googling is too long for just testing. How can I create drawable widget and get its drawable area? I want to test diagrams cairo-gtk backend.
07:42:00 <xplat> Rc43: that seems to be the approach with classes like Widget, no doubt some of the seldom-subclassed ones just become datatypes though
07:42:03 <Rc43> (diagrams is a package)
07:42:24 <rs46> Question about STM: If you have 4 functions in an atomically block, and one of them has a `retry' in it, is the whole atomically block started again, or just that one function out of the 4 ?
07:42:41 <t7> @src fix
07:42:41 <lambdabot> fix f = let x = f x in x
07:43:13 <t7> let fix f = f (fix f) in fix (1:)
07:43:17 <t7> > let fix f = f (fix f) in fix (1:)
07:43:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:43:31 <theclassgeek>  
07:43:43 <t7> @pl fix f = f (fix f)
07:43:43 <lambdabot> fix = fix (ap id)
07:44:07 <t7> @src ap
07:44:07 <lambdabot> ap = liftM2 id
07:45:18 <merijn> rs46: The whole atomic block, that's the definition of atomic :p
07:45:37 <merijn> rs46: Either the entire thing succeeds, or the entire thing fails
07:45:50 <rs46> merijn: thanks, that's clear.
07:45:57 <t7> > (\a -> \b -> b (a b)) (1) (\a -> (a:))
07:45:58 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
07:45:59 <lambdabot>    arising from a use ...
07:46:26 <merijn> > fix 1
07:46:27 <lambdabot>   1
07:46:51 <t7> how can i define fix with only lambdas?
07:47:22 <roconnor> t7: you cannot without support from a data type.
07:47:34 <merijn> That requires a y combinator, which won't type check in haskell
07:48:25 <xplat> Rc43: probably gtk-toy-diagrams would be the easiest way to play with it
07:49:24 <Rc43> xplat, are they on hackage? I have found only github repo.
07:49:50 <Rc43> xplat, and why they are easier? They reduce gtk code?
07:50:34 <xplat> gtk-toy-diagrams doesn't seem to be on hackage yet
07:50:47 <xplat> although the core of gtk-toy is
07:51:40 <xplat> Rc43: and yes, easier because they reduce the gtk code that you have to write, if you want to do it in bare gtk you can get it working with toy and then look at toy source to see what they do
07:52:25 <xplat> Rc43: specifically it looks like gtk-toy-diagrams will do the wiring to let a diagram appear in a widget
07:54:41 <Rc43> xplat, may be I need gtk-toy (didn't hear about it), but not diagrams. I wanted to use diagrams for simple GUI, then I get that I need use gtk too with them. Never used gtk / haskell gui libraries before.
07:54:56 <Rc43> So it seems that gtk-toy is what I really want.
07:57:49 <Rc43> Btw, what is the main difference between wx and gtk for example?
07:58:36 <Rc43> And between gtk and graphics part of qt? I have used to write apps with qt.
07:58:47 <geekosaur> API.  (they both use gtk underneath, actually)
07:58:48 <Rc43> *I used to
08:01:13 <Rc43> Are there any recomendations when to use one and when to use another?
08:02:20 <xplat> Rc43: wx is an abstract version of microsoft foundation classes that can render with windows widgets, mac widgets, or gtk.  gtk is a portable widget set that can draw the same widgets on windows, mac, and X11
08:02:43 <geekosaur> portability, mostly; native gtk+ is easier to deal with on linux/freebsd/etc., whereas if you want to use it on windows, wxwindows is easier for windows folks to get going than the windows port of gtk+ (although it is doable)
08:03:51 <xplat> gtk and qt are pretty much similar, except gtk is written in C using glib events and gobject for OO and Qt is written in C++ with moc for event handling and the native OO
08:03:57 <t7> is happstack the best everything-included web framework?
08:04:24 <Rc43> xplat, gtk signals look like more powerful
08:04:40 <merijn> t7: I think Yesod was?
08:04:52 <xplat> t7: that's currently a religious issue
08:05:01 <Rc43> so wx api is more similar to windows and gtk is just another, and qt has additional functionality, right?
08:05:04 <geekosaur> Rc43, not really, Qt uses much the same signals-and-sockets mechanism
08:06:05 <xplat> gtk is easier to use from different languages because most languages don't have good C++ FFI
08:06:53 <albel727> gtk is better. period.
08:06:58 <Rc43> oh, wx are written in c++
08:07:17 <geekosaur> Qt doesnt really have additional functionality, no; they're all much the same functionality presented in different ways
08:07:29 <xplat> ws and Qt both.  but wx has plenty of wrappers so i think they did something to make it easier, like a standard C wrapper for the interface
08:07:38 <Rc43> geekosaur, qt is not only graphics, gtk is too?
08:07:39 <geekosaur> to the extent that any of them had advantages, the others picked it up quickly
08:08:10 <xplat> and wx API is pretty similar to windows recommended API from like 15 years ago
08:08:23 <geekosaur> huh?  if you mean glib, that's largely providing stuff that C lacks but standard C++ libraries have
08:08:44 <xplat> windows has mostly gone .NET by now
08:09:40 <t7> > msum [Nothing, Just 123]
08:09:41 <lambdabot>   Just 123
08:09:51 <t7> > msum [Nothing]
08:09:52 <lambdabot>   Nothing
08:10:15 <t7> @src msum
08:10:16 <lambdabot> msum =  foldr mplus mzero
08:10:57 <merijn> :t mplus
08:10:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
08:11:06 <merijn> @src mplus
08:11:06 <lambdabot> Source not found. Just try something else.
08:11:08 <xplat> i think the suite of libraries surrounding Gtk offers basically the same functionality as that surrounding Qt, but they are factored in different/differently-sized pieces
08:11:30 <t7> how do i kill a happstack server
08:11:37 <t7> it doesnt listen for ctrl c
08:11:43 <Botje> send a ctrl-\
08:11:58 <Botje> or use your system's kill command
08:11:59 <Rc43> What about SDL? It is lower level without widget etc?
08:12:05 <xplat> the gtk ecosystem tends to have smaller chunks of functionality and more library interdependencies, Qt goes the other way
08:12:11 <geekosaur> SDL sits on top of a widget toolkit
08:12:39 <geekosaur> it's a higher level abstraction
08:13:29 <xplat> SDL is low-level graphics and input, it doesn't provide very much in the way of 'widgets'
08:13:37 <Rc43> I thought it is like `put pixel here, detect mouse click etc`
08:14:22 <xplat> it can run on top of or embed itself in widgets, but it doesn't really care about them otherwise, and is mostly optimized for speed
08:14:52 <Rc43> gtk uses sdl?
08:15:15 <xplat> gtk uses cairo as its low-level graphics layer
08:15:32 <Rc43> and cairo and sdl are two parallel ways?
08:15:42 <Rc43> which difference?
08:15:46 <xplat> cairo is more optimized for vector graphics instead of sdl's mostly pixel/bitmap orientation
08:16:00 <Rc43> a, cairo is graphics only, but sdl everything included
08:17:34 <xplat> sdl doesn't have 'everything' included, but it does include sound, input, fullscreen, and a platform-independent way to launch an app window
08:17:45 <xplat> cairo doesn't have those things
08:18:10 <goldenwest> where can i get pandoc help
08:18:14 <Rc43> And there is HGL. What is it? Just the same as gtk but unites Win32 and X11?
08:18:39 <xplat> HGL i don't really know
08:18:48 <geekosaur> HGL is a much simpler library, not really suited to serious app development
08:19:06 <geekosaur> it's intended to be portable and suitable for example programs
08:19:48 <Rc43> geekosaur, serious app is like? I need to create simple diagram editor.
08:20:25 <geekosaur> mmm, you might get a good idea just by looking at the available functions.  (very little other than basic text rendering and shape drawing)
08:20:48 <Rc43> ok,  will look
08:21:25 <geekosaur> it might be possible to do a simple diagram editor but it's not going to have much of a UI
08:21:50 <t7> http://happstack.com/docs/crashcourse/RouteFilters.html look at the simple POST GET example about 3/4 of the way down
08:22:07 <t7> why isnt dir "foo" $ do ... catch before ?
08:22:10 <t7> caught*
08:23:36 <Saizan> t7: what do you mean?
08:24:08 <t7> well the first do methodM GET should catch it
08:24:33 <Saizan> "Note that methodM also requires that the all the segments of request path have been consumed"
08:24:56 <t7> aha!
08:28:06 <hpaste> franco00 pasted “from one to many, monad” at http://hpaste.org/64980
08:28:43 <franco00> ^-- mini monadic code problem, any help would be appreciated ( http://hpaste.org/64980  )
08:31:41 <Saizan> franco00: accFun mv u = mv >>= \v -> updateVar v u
08:32:02 <Saizan> franco00: though, you'd better use foldM
08:32:40 <Saizan> ?type foldM
08:32:41 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:33:17 <franco00> thanks Saizan , I must have missed it in my cursory Control.Monad check
08:33:21 <Saizan> updateVars vars upds = foldM updateVar vars upds
08:37:16 <shergill>  i install a package foo with 'cabal install foo-version'. the package installs, however running 'cabal info foo' lists 'Versions installed' as '[ Unknown ]'. why is that? and how can it be fixed?
08:38:39 <Saizan> shergill: is it an executable only package?
08:38:39 <shergill> in case someone needs specifics, foo-version = djinn-2011.7.23
08:38:54 <shergill> Saizan: it looks like ti
08:38:55 <Saizan> so yes, i guess
08:39:07 <shergill> is this expected behavior for executables?
08:39:14 <Saizan> yep
08:39:21 <shergill> k thanks
08:42:52 * hackagebot Peano 0.0.3 - simple Peano numbers  http://hackage.haskell.org/package/Peano-0.0.3 (FrancescoMazzoli)
08:43:44 <jfischoff> is there a package that provides common monad transformer stacks. Like a newtype with ErrorT and ReaderT?
08:52:52 <aristid> jfischoff: transformers has RWST
08:53:16 <aristid> jfischoff: that essentially gives you all combinations of Reader, Writer and State
08:53:22 <jfischoff> yep but I find I make a few other combinations regularly
08:53:29 <jfischoff> usually adding ErrorT
08:53:41 <jfischoff> Maybe ErrorT is not in style though ...
08:53:41 <aristid> not sure then:)
08:53:55 <jfischoff> :)
08:53:57 <jfischoff> thanks
08:54:30 <t7> is there any defualt istances for acid-state?
08:54:33 <t7> like string etc
08:54:36 <t7> and list
09:06:55 <osfameron> hey.  I've not done IO/Random messing about for ages.  Can anyone give me a pointer for what I'm cocking up with https://gist.github.com/9df4b1db3c7d45cdc80b ?
09:07:58 <ClaudiusMaximus> :t randomRs
09:07:59 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
09:08:33 <ClaudiusMaximus> no IO there..
09:08:39 <shergill> how do the various haskell database interfaces (persistent, hdbc, haskelldb etc) match up? any performance numbers?
09:09:41 <osfameron> ClaudiusMaximus: ooo, thanks
09:10:04 * osfameron kinda expects random to mean "has IO in it"
09:10:14 <osfameron> and of couse the error messages are Very Long and Not Very Useful
09:10:17 <mrcarrot> osfameron: randomRIO is often more easy to use... but it is an IO-function
09:10:50 <osfameron> mrcarrot: thanks, I'll have a look at it
09:10:54 <JoeyA> shergill: They're all using the same backend code underneath, most of the time.
09:11:01 <mrcarrot> :t randomRIO
09:11:02 <lambdabot> forall a. (Random a) => (a, a) -> IO a
09:11:29 <osfameron> actaully, I think random Rs is what I want.  But ages can be a pure function, and something else can call it, duh
09:11:32 <mrcarrot> > randomRIO (1,10)
09:11:32 * osfameron rewrites
09:11:33 <lambdabot>   <IO Integer>
09:11:59 <JoeyA> shergill: Are you planning on writing a database-enabled application?
09:12:13 <shergill> JoeyA: in what sense?
09:12:44 <shergill> JoeyA: of sorts. i'm looking to develop a project in haskell which will have considerable database throughput
09:12:53 <JoeyA> Ah, okay.
09:13:23 <JoeyA> mysql and postgresql-libpq are low-level bindings to MySQL and PostgreSQL respectively.  mysql-simple and postgresql-simple are a step up.
09:14:27 <JoeyA> HDBC is on about the same level as mysql-simple and postgresql-simple, but is organized in a more generic fashion, rather than accounting for database-specific peculiarities.
09:14:43 <JoeyA> persistent uses mysql-simple and postgresql-simple now, if I'm not mistaken.
09:14:51 <zerax> Getting useful figures for database benchmarks is usually quite difficult, but I would suspect that if you use one of the Haskell bindings to such things you will have sufficient performance and if you find out that you don't, there will be things you can do or trying alternatives should not be too taxing.
09:15:48 <mrcarrot> then there is acid... but depending on how critical the project is, i do not know if i would dare to use it
09:16:26 <shergill> mrcarrot: experimental support?
09:16:52 <shergill> zerax: yeah, i'm mostly looking to make sure i don't shoot myself in the foot atm
09:17:02 <shergill> JoeyA: thanks for the breakdown
09:17:06 <sm> how would you find the current cabal configure state, including flags ?
09:17:11 <JoeyA> shergill: I'd say start by choosing what database you want to use (e.g. PostgreSQL, MySQL, MongoDB, etc.)
09:17:17 <mrcarrot> shergill: http://acid-state.seize.it/
09:17:50 <colah> How cany I make GHC happy with the following: instance Additive ℝ (forall n. Fractional n => n) ℝ where ...
09:18:06 <colah> I get complaints about "Illegal polymorphic or qualified type"
09:18:26 <colah> But it seems like something I ought to be able to do with RankNTypes...
09:18:43 <Saizan> you can only with a newtype
09:19:31 <Saizan> but, are you sure you don't mean instance Fractional n => Additive ℝ n ℝ where .. ?
09:20:47 <colah> No. I definitly want the rank 2 one. I'm trying to get it to automatically catch literals like 1.1 so I don't have to do type inference.
09:21:19 <sclv> yeah ghc won't do that.
09:21:24 <colah> Since my funcdeps aren't strong enough for haskell to determine the type, I often have to do (1.1::ℝ)
09:21:24 <sclv> you can guard with a newtype
09:21:42 <colah> But that doesn't solve my problem...
09:21:48 <sclv> or just use a smart constructor for literals.
09:22:04 <t7> im making a startup, who wants to pledge funding?
09:22:05 <colah> I tried overwriting fromIntegral and so on, but that didn't seem to work even without implicit prelude.
09:22:17 <sclv> the problem is 1.1 :: forall a. Fractional a => a
09:22:39 <colah> Right, that's why I was trying to have my operators take the rank 2 type (forall a. Fractional a => a
09:22:39 <sclv> but not :: (forall a. Fractional a => a)
09:22:40 <JoeyA> shergill: I think I would recommend persistent, unless the API turns out to be a bad fit for what you're trying to do.  However, expect rapid changes to persistent et al. as time goes on.
09:22:54 <sclv> you need impredicative polymorphism for the latter
09:23:08 <colah> Ah.
09:23:14 * colah googles impredicative polymorphism
09:23:17 <sclv> and even if you have it, then that's going to bork type inference and force you to provide yet more signatures.
09:23:24 <shergill> JoeyA: yeah i think i'm going with persistent. i'd like to start of with postgresql but want to have the option open of switching to mongodb without too much effort
09:23:45 <ezyang> So, uh, after all this time I still don't really understand what impredicative polymorphism is.
09:23:45 <sclv> also I think ghc's limited impredicative polymorphism support never worked with typeclass resolution.
09:25:15 <Saizan> sclv: are you sure there's a difference between those types?
09:25:23 <sclv> saizan -- not in haskell no
09:25:31 <sclv> i was expressing myself poorly
09:25:36 <dolio> Yeah, polymorphic types weren't first class as far as type classes were concerned, I think.
09:25:58 <sclv> the problem is the forall will always float to the front of any type signature given
09:26:18 <sclv> or inferred, rather. and there's no way to express that it shouldn't without guarding by a newtype.
09:26:49 <anton__> mic check
09:27:10 <colah> Hm. This seems silly.
09:27:11 <sclv> so you can just think about why, given newtype F :: F (forall a. Fractional a => a), F 1.1 is different from 1.1
09:27:38 <sclv> colah: if you allow impredicative polymorphism, type inference becomes undecidable.
09:27:55 <colah> That's OK! I'm already using UndecidableInstances :)
09:28:06 * sclv rolls eyes
09:29:19 <colah> I forget who it was that told me this, but "the farther you are from haskell 98, the realer a haskell you're writing!"
09:29:21 <dolio> It's undecidable even with the 'predicative' rank-n stuff GHC does do.
09:31:01 <colah> Even with ImpredicativeTypes, GHC hates me. And using the guard would defet the whole point.
09:31:14 <sclv> colah: yes, you can't do it, I think.
09:31:30 * colah sulks
09:31:54 <xplat> shergill: switching from postgresql to mongodb will almost always be a lot of effort, they're completely different sorts of databases
09:32:13 <sclv> dolio: true enough. i'm trying to remember precisely why impredicative polymorphism is even harder. just, I think, because they needed to work out the theory of how much type inference you can get away with.
09:32:18 <shergill> xplat: it's why i was looking at possible abstraction layers
09:32:35 <sclv> ezyang: if you're serious, i think the fph paper does a good job of explaining/motivating it?
09:33:16 <ezyang> ok.
09:33:19 <dolio> sclv: We're doing impredicative polymorphism at work. :)
09:33:32 <xplat> shergill: you probably want persistent because i don't think any of the other abstraction layers are that far away from the database
09:33:45 <sclv> in dmtl or in scala?
09:33:53 <dolio> dmtl
09:34:01 <dolio> It uses HMF.
09:34:48 <shergill> xplat: yeah, seems so. none of the others can match persistent in terms of varied backend-support anyway
09:34:59 <shergill> and it seems to be actively developed
09:35:20 <sm> bummer.. can't specify ghc-options in ~/.cabal/config
09:35:59 <dolio> sclv: If you read the paper on adding type classes to MLF, though, you have to use a completely different dictionary passing translation than GHC probably uses, though.
09:36:07 <Enigmagic> sm: yes, it's dumb. just edit the ghc script directly as a workaround
09:36:12 <dolio> Which would be a major change.
09:36:32 * sclv should read the hmf paper more carefully at some point
09:36:41 <sm> thanks
09:36:57 <xplat> hmf is crazy wild stuff
09:37:36 <dolio> Because you have, say, l = [id] :: [forall a. a -> a]. Then you do l' = (+1) : l :: [forall a. Num a => a -> a].
09:37:45 <xplat> recently they were switching to graph types, i think
09:38:04 <sclv> the subsumtion/skolemization stuff is nice.
09:38:05 <dolio> So, l had a list of things that didn't expect dictionaries, but suddenly it's used in a list of things that do expect dictionaries.
09:39:22 <sclv> the reason persistent has such varied-backend support is because it is so limited in what you can do with them.
09:40:21 <xplat> indeed, with persistent you're basically using the database as a super-dumb store
09:40:26 <dolio> Although, I don't think it's a problem with HMF, because l' will probably fail to type check.
09:40:32 <_oggy> noob question: I'm not succeeding in cabal installing the repa library because of a dependency issue
09:40:47 <copumpkin> edwardk: don't forget to eat all the pork shit
09:40:51 <hpaste> “_oggy” pasted “cabal repa” at http://hpaste.org/64982
09:41:03 <edwardk> hah
09:41:06 <edwardk> forgot.
09:41:09 <edwardk> will take it with me =)
09:41:12 <copumpkin> (sounds delicious, doesn't it)
09:41:34 <copumpkin> fatty pork shit ftw
09:41:45 <edwardk> oh, btw- those folds form a nice applicative, and with Control.Newtype they are pretty fun to use
09:41:50 <copumpkin> ooh
09:41:57 <edwardk> er not the folds, i mean the calcs
09:42:00 <xplat> i tend to read that last one with 'pork' as the verb
09:43:18 <copumpkin> edwardk: ah, I'd expect that I think
09:43:26 <edwardk> *nods*
09:43:31 <edwardk> i also added the profunctor
09:47:14 <shergill> sclv: as opposed to? i was looking at some of the other backends. groundhog seems to be one which has support for sum types, but in terms of abstraction is there anything which goes beyond that?
09:47:59 <lispy> good morning, fellow haskellers
09:48:09 * lispy is getting a lot of client side irc lag
09:48:12 <ChristianS> good evening
09:48:14 <mcglk> 'Mornin'.
09:48:55 <sclv> shergill: as opposed to taking advantage of sql (which you obviously can't do with no-sql backends)
09:49:24 <sm> this is strange. cabal installs on this VPS were ExitFailure 11'ing frequently until I started using --ghc-options '+RTS -M400m' or so. But this isn't working for haskell-src-exts. It grows to around 200M, plenty of free memory, and then ExitFailure 11 every time
09:50:09 <sclv> oh man, i hadn't read sigpfe's profunctors post since all that neat discussion went on.
09:50:35 <Saizan> which post?
09:50:39 <sclv> http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
09:50:48 <sm> strangeness 1: I can see no further growth even with top updating every 0.1s. strangeness 2: setting -M to something small would usually give "heap exhausted" but it seems to be having no effect
09:50:56 <t7> which is better: JavaScript or haskell?
09:51:09 <MostAwesomeDude> t7: This isn't #javascript.
09:51:32 <lispy> sm: ExitFailure 11 is segfault, FWIW
09:51:39 <dolio> sclv: You didn't read the article Paul linked to about how Google is now layering SQL on top of NoSQL, so everyone can jump back on the SQL bandwagon.
09:51:41 <sclv> @faq can haskell be better than javascript?
09:51:41 <lambdabot> The answer is: Yes! Haskell can do that.
09:52:01 <sm> lispy: right, usually caused by the out of memory killer
09:52:15 <t7> @faq can haskell type the y-combinator?
09:52:15 <lambdabot> The answer is: Yes! Haskell can do that.
09:52:17 <sclv> i thought the oom killer gave just terminated
09:52:22 <t7> i think thats a bug
09:52:27 <sclv> no, that's a feature!
09:52:27 <lispy> sm: someone was telling me that the problem with compiling haskell-src-exts is that it has a particular module that causes ghc to use far too much memory (something about too many data declarations in one module)
09:52:35 <xplat> yes, now you can layer nosql on top of sql or sql on top of nosql
09:52:51 <xplat> or sql on nosql on sql on nosql on sql
09:52:58 <sm> lispy: interesting. I guess it is causing a huge spike in memory demand, just too quick to see
09:53:05 * hackagebot template 0.2.0.6 - Simple string substitution  http://hackage.haskell.org/package/template-0.2.0.6 (JohanTibell)
09:53:27 <lispy> sm: yeah.  On my linode (which has too much swap configured for it) haskell-src-exts takes hours to do nothing useful
09:53:29 <sclv> You have a problem and think "I'll use NoSQL." Now you have to reimplement your problem.
09:53:43 <sm> and limiting heap isn't enough to contain it. Maybe I should limit stack as well
09:54:02 <Enigmagic> dolio: microsoft uses a sql-like language on top of dryad for almost all of their search analytics http://research.microsoft.com/en-us/um/people/jrzhou/pub/Scope.pdf
09:54:06 <lispy> sm: I think the solution is to either rewrite that module or fix ghc
09:54:39 <sm> indeed, or both
09:54:43 <Enigmagic> dolio: which i think predates the google work by quite a bit, but microsoft isn't cool (and i hated using scope at ms)
09:54:56 <dolio> Enigmagic: The last part is key.
09:55:31 <Enigmagic> dolio: dryad itself is pretty awesome though, as is dryadlinq
09:56:28 <CQ> @faq can haskell make coffee?
09:56:29 <lambdabot> The answer is: Yes! Haskell can do that.
09:56:36 <CQ> errm.... ;)
09:57:24 <t7> @faq can i launch the missiles outside of the IO monad?
09:57:24 <lambdabot> The answer is: Yes! Haskell can do that.
09:57:55 <sm> lispy: another workaround: --ghc-options -O0
09:58:20 <CQ> @faq is haskell based on an emacs-derived lisp implementation?
09:58:20 <lambdabot> The answer is: Yes! Haskell can do that.
09:59:10 <gentleben> oooh, sql on nosql
09:59:32 <gentleben> just tools
09:59:53 <sm> I guess that means building everything depending on it (hoogle) -O0 as well
10:00:01 <lispy> sm: interesting
10:02:25 <rasfar> Could it be the InternalParser.hs module that HSE generates using Happy?  That is a big one...
10:03:00 <lispy> rasfar: I heard it had to do with too many data declarations in one module
10:03:08 * hackagebot Hipmunk 5.2.0.7 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.7 (SoenkeHahn)
10:03:43 <sm> I think it's Language.Haskell.Exts.Annotated.Syntax, 2000 lines of instance declarations
10:04:26 <sm> and data types
10:04:28 <rasfar> Yeah you're probably right, there aren't many data declarations in InternalParser.
10:04:30 <lispy> that could be
10:05:34 <sm> yay, command-line hoogle updated. hoogle is awesome. Later all
10:08:56 <rasfar> Would be better to move the instance decls to a separate module?
10:26:18 <derpladee> hey does anybody here have any experience doing web development in haskell?
10:28:30 <jfischoff> I have very limited experience
10:28:35 <rostayob> derpladee: I have some. the best idea on IRC is to just ask.
10:28:42 <rostayob> asking to ask doesn't help
10:28:54 <derpladee> well i kinda want to do web development with haskell
10:29:02 <shurane> derpladee: do it
10:29:09 <rostayob> derpladee: there's yesod, happstack and snap
10:29:25 <rostayob> they all have kind of different values and development styles
10:29:30 <derpladee> how about hyena?
10:29:32 <derpladee> or warp
10:29:44 <xplat> warp is just a webserver, not a framework
10:29:50 <rostayob> derpladee: I don't know about hyena
10:30:00 <xplat> you could do webdev with it, but it would be a lot of work
10:30:05 <rostayob> and xplat is right about warp
10:30:38 <jfischoff> there is also miku, which is similar to ruby's Sinatra
10:30:47 <jfischoff> less used though..
10:31:51 <derpladee> i'm kinda thinking that yesod looks kinda nice
10:31:53 <derpladee> maybe i'll start there
10:38:36 <hpaste> Eu pasted “Teste” at http://hpaste.org/64987
10:46:38 <rasfar> sm, lispy: fwiw, I just split off the instances and recompiled.  Uncertain whether this would actually help with the memory usage or not though.
10:47:39 <sm> rasfar: great.. you can watch with top perhaps
10:48:02 <sm> or I guess ghc +RTS -MUCHBETTEROPTION
10:48:57 <rasfar> I suppose I've not seen this in my own project b/c I'm not compiling -O*, but I have seen it happen on some cabal-install's.
10:51:59 <hpaste> scooty-puff pasted “Is it possible to make this work?” at http://hpaste.org/64988
10:52:11 <scooty-puff> does anyone know how to get this to type check?
10:52:29 <scooty-puff> basically want the Int instance to apply when it can, but the other when it can't
10:52:50 <scooty-puff> seems like it would have to be a runtime check if through a particularly polymorphic call
10:52:56 <scooty-puff> that or reverse the fundep
10:53:56 <edwardk> scooty-puff: the usual idiom would be to use something other than 'a', like a newtype Box a = Box a -- that way you don't need OverlappingInstances-style evil
10:54:05 <scooty-puff> k
10:54:26 <edwardk> its not the prettiest answer though
10:54:40 <edwardk> another would be to get the fundep to run from c -> a
10:54:47 <edwardk> then BitSet and [a] are fine and don't overlap
10:55:14 <scooty-puff> thats how i changed it for now - i'll try messing around using a wrapper around a
10:55:27 <edwardk> c -> a will probably result in prettier code
10:56:26 <scooty-puff> and possibly resulting in odd type annotations - maybe, just messing with it now on ghci, so probably easier to take it out of the context that i will be using it in..
10:57:15 <edwardk> yeah
11:04:07 <Lemon> In a strict language, how would the Maybe monad work?
11:04:12 <rasfar> nah, the memory requirements with -O2 to compile Annotated.Syntax are identical with or without that particular split. :(
11:04:31 <rasfar> (namely about 400 MB)
11:04:37 <Lemon> wouldn't >>= evaluate its second parameter every time, and thus defeat the short circuiting?
11:08:06 <Lemon> wait, wtf am I talking about
11:08:14 <Lemon> the second parameter of >>= is a function
11:09:48 <koala_bot> could someone clarify what the difference is between type, class, and data declarations?
11:10:45 <mekeor> koala_bot: "type" just defines type-synonyms, like
11:10:55 <mekeor> type String = [Char]
11:11:28 <koala_bot> mekeor: Thanks. How about the other two?
11:11:58 <mekeor> koala_bot: while "class" defines a type class, that is a set of data-types for which a set of certain functions is defined.
11:12:08 <mekeor> @info Num
11:12:08 <lambdabot> Num
11:12:20 <Veinor> thank you, lambdabot
11:12:34 <koala_bot> lol Veinor
11:12:40 <scooty-puff> @info Monoid
11:12:41 <lambdabot> Monoid
11:12:42 <mekeor> koala_bot: e.g. the type class "Num" defines (+) and (-) and 'abs' etc.
11:12:47 <Guest73009> Example: class Eq where { (==) :: a -> a -> Bool; (/=) :: a -> a -> Bool }
11:12:47 <scooty-puff> blah, was hoping just too many instances..
11:12:58 <mekeor> @info @info @info
11:12:59 <lambdabot>  Parse error at "@info" (column 1)
11:13:11 <scooty-puff> :info Monoid
11:13:13 <Lemon> well, koala_bot
11:13:30 <Lemon> "class" doesn't actually define a set of data-types for which a set of functions is defined
11:13:37 <mekeor> koala_bot: and with "data" you can define completly new data-types with your own value-constructors..
11:14:00 <mekeor> koala_bot: for more information, please use google and particulary haskell-wiki :Þ
11:14:03 <scooty-puff> (think its worth distinguishing data constructors vs. type constructors?)
11:14:03 <Lemon> it defines a set of functions that need to be implemented for a type for that type to be considered part of the set
11:14:23 * rasfar usually ends up regretting it whenever they try to use type decls
11:14:32 <merijn> koala_man: So any type that is a member of the class Eq has to implement those two functions. You can make any type an instance of a class by simply defining "instance Eq MyClass where { sensible implementation of (==) and (/=) here }"
11:14:49 <Lemon> the total set of instances that you have in all the modules of your program defines the set of types that belong to that class
11:14:50 <mekeor> scooty-puff: AFAIK, 'Maybe' is a data-constructor while 'Just' (and 'Nothing', IMO, too) is a value-construcotr.
11:15:10 <Lemon> what
11:15:13 <Lemon> that's not right, either
11:15:26 <edwardk> Maybe is a type constructor
11:15:28 <Lemon> Just and Nothing are data/value constructors
11:15:30 <edwardk> Just and Nothing are data constructors
11:15:32 <koala_bot> mekeor: I definitely googled but really wasn't sure what was going on in the examples :) Thanks for the suggestion though.
11:15:33 <merijn> mekeor: There's nothing IMO about that, Nothing is a value constructors
11:15:43 <mekeor> oh, i meant type-constructor, not data-constructor, sorry =)
11:16:01 <merijn> constructor, even
11:16:29 <merijn> koala_bot: Learn you a haskell also has a fairly comprehensive explanation of all three
11:18:47 <koala_bot> Thanks. If I can summarize and have you guys tell me if I've got the general idea, type declarations define synonyms, so simply referring to an existing type as something else. A class is somewhat similar to an interface in Java in that it has a list of functions which must be defined for some value to be of that particular data-type.
11:19:03 <koala_bot> The data declarations on the other define new types entirely as well as the constructors necessary to make them
11:19:40 <merijn> koala_bot: An important difference between java interfaces is that constants can be part of a type class too
11:20:13 <merijn> Example: the type class for bounded values has a minBound and maxBound value of type "(Bounded a) => a"
11:20:19 <merijn> > minBound :: Int
11:20:20 <lambdabot>   -9223372036854775808
11:20:23 <merijn> > minBound :: Char
11:20:24 <lambdabot>   '\NUL'
11:20:44 <merijn> :t minBound
11:20:45 <lambdabot> forall a. (Bounded a) => a
11:20:46 <derpladee> hey guys i'm trying to install yesod and i get this problem: http://superuser.com/questions/390531/trouble-installing-yesod
11:20:53 <derpladee> it's not me but it's the same problem i have
11:21:22 <merijn> koala_man: Also, unlike Java interfaces you can have type class functions that are polymorphic in the return value, rather than arguments
11:21:26 <merijn> :t read
11:21:27 <lambdabot> forall a. (Read a) => String -> a
11:21:52 <koala_bot> merijn let me read that a couple more times. I"m not sure I follow.
11:23:50 <koala_bot> afaik you can have constants in java interfaces - are you saying type classes can or cannot? The info about polymorphic return values is going over m yhead; could you elaborate or direct me to a resource?
11:23:53 <Lemon> "for any type, if that type is in the Read class, then read will take a string and return a value of that type"
11:24:53 <merijn> koala_bot: You can have constants in an interface, but if you have an interface using generics (say, Set<x> or whatever the Java notation is) you can't have the constant depend on the value of x
11:25:28 <scooty-puff> koala_bot: its like if you had a interface and an associated factory interface, to make it nice and enterprisey
11:26:14 <koala_bot> I think I see
11:26:15 <scooty-puff> interface BoundedFactory<T extends Bounded<T>> { T minBound(); T maxBound(); }
11:26:18 <merijn> Say I define an interface "Bounded<x>"in java, then I cannot define minBound and maxBound dependend on x, unless I use some inheritance trick (like defining a function that returns minBound)
11:26:29 <merijn> err, scratch inheritance trick
11:26:41 <merijn> That was part of an earlier wrong sentence I was writing :p
11:26:50 <koala_bot> :)
11:26:52 <koala_bot> Thanks everybody.
11:26:55 <koala_bot> <3 super helpful
11:27:23 <ezyang> OK, so impredicative polymorphism is polymorphism as a "first class object." Why is it "impredicative"?
11:27:59 <merijn> koala_bot: What I meant by polymorphism is that I can define a function "int foo(Set<x> bar);", but not a function "Set<x> foo(int bar);", how would Java know where the x comes from?
11:29:06 <merijn> The only way to do that in Java is if x is also in the input type of foo (I think, my Java knowledge has become shaky :p)
11:29:30 <scooty-puff> but you could define interface SetCompanion<T, S extends Set<T, S>> { S empty(); } interface Set<T, S extends Set<T>> { S insert(T value, S set); }
11:29:53 <scooty-puff> merijn: i.e., the SetCompanion garbage
11:29:59 <scooty-puff> manual dictionary passing..
11:30:37 <Saizan> ezyang: because then a type like "forall (a :: *). .." can be instantiated to itself, and that's enough circularity to qualify
11:30:57 <ezyang> Huh.
11:31:02 <ezyang> Is that what makes it undecidable?
11:33:19 <Saizan> inference gets killed with less then that
11:33:30 <Saizan> *than
11:33:58 <ezyang> Hmmm
11:35:13 <ezyang> Wait, but can't we solve this by generating a hierarchy of universes?
11:37:21 <sclv> ezyang: huh. cute!
11:37:40 <sclv> but then you need universe polymorphism...
11:38:05 <Saizan> or cumulativity
11:38:06 <ezyang> Yeah... and then sometimes users get "Universe Inconsistency" and then things are really bad :-)
11:38:17 <Saizan> and/or Conor's "crude .."
11:39:52 <Saizan> i'd want to see someone trying to work with Codensity in such a system though
11:40:47 <sclv> You have a problem and think "I'll solve that by generating a hierarchy of universes." Now you have an undiagonalizable class of uncountable problems.
11:41:09 <sclv> sorry. tired meme is tired.
11:42:33 <aristid> sclv: calling that a meme... i don't know, where's the cat?
11:43:01 <ezyang> It's really cute that in Coq, Prop is impredicative, but everything else isn't.
11:43:30 <sclv> the cat is a cat of universes with inclusions as morphisms.
11:44:32 <dolio> Set used to be impredicative.
11:44:59 <sclv> http://xkcd.com/26/
11:45:17 <dolio> But that caused problems when people postulated excluded middle.
11:48:28 <tlorenz> I need some help to figure out what the best way is to create a mutable buffer of ByteStrings. I posted more details about my problem on stackoverflow: http://stackoverflow.com/questions/9623558/what-is-the-right-way-to-create-a-buffer-to-hold-bytestrings-in-haskell
11:48:45 <tlorenz> Any help is greatly apperciated
11:50:32 <sanjoyd> I just wrote this:  https://github.com/sanjoy/Snippets/blob/master/TicTacToe.hs  Any suggestions / improvements?
11:51:21 <jfischoff> tlorenz: you might want to look at http://hackage.haskell.org/package/vector-bytestring-0.0.0.1. Also in the aeson code, they use mutable state, its just hidden.
11:51:50 <jfischoff> tlorenz: full disclosure. I've never done what your trying to do
11:52:07 <tlorenz> thanks jfischoff, will look into it
11:52:19 <jfischoff> tlorenz: np
11:52:38 <jfischoff> tlorenz: I bet somewhere has a better answer too.
11:54:50 <jedai> tlorenz: I'm not completely sure that a mutable buffer is the way to go in your case, I would investigate the "builder" solution instead, that's what the really fast servers in Haskell use
11:56:29 <jedai> Basically instead of sending your bytestring one by one or concatening them and then send, you use builders that will send by chunks of a good size (experimentally determined)
11:58:13 <tlorenz> jedai but to send them you would first have to allocate them in memory before right? so would that fix my excessive garbage collection problem?
11:58:16 <jedai> tlorenz: see blaze-builder for this approach
11:59:09 <tlorenz> jedai - will look into blaze-builder
11:59:23 <mekeor> How can I e.g. import "../../foo/Bar.hs" ?
11:59:49 <jedai> tlorenz: I guess if you build reasonably sized chunks instead of plenty of small bytestrings, the GC time is reduced
12:00:24 <mm_freak> mekeor: by adding ../../foo to the search path and importing Bar
12:00:41 <mekeor> mm_freak: search path?
12:00:52 <mm_freak> mekeor: are you using cabal?
12:00:57 <mekeor> no.
12:01:18 <tlorenz> jedai, I am already using BlockBuffering with the size of the ByteString I'm sending (in one shot) and this made it 4 x faster than NoBuffering, but still have the GC problem
12:01:47 <jedai> tlorenz: from where do you get your Bytestring ?
12:02:02 <mekeor> mm_freak: No, I'm not using cabal.
12:02:03 <tlorenz> jedai since before sending it, it has to store lazy bytestring somewhere and then it needs to be selected
12:02:18 <jedai> tlorenz: what you're describing is not directly related to what I'm speaking about
12:02:29 <mekeor> mm_freak: Should I? I mean, for what kind of projects do you use cabal usually?
12:02:29 <tlorenz> I accumulate it as lazy ByteString from memory and/ or a file
12:03:03 <jedai> tlorenz: even if your Bytestring is sent as one block it doesn't mean it is one in memory
12:03:42 <tlorenz> jedai: ok, so you are saying each chunk gets allocated separately and also has to be collected as such?
12:03:56 <jedai> tlorenz: the "builders" avoid this "fragmentation" of your lazy bytestring in small sized chunks
12:04:07 <tlorenz> jedai got it, thanks
12:04:23 <takemitsu> :q
12:05:33 <jedai> tlorenz: note that if you're using your bytestring to stream a file to the network, there is a sendfile package that automatically use the optimal solution for that depending on your OS (on Linux it use the sendfile system call, which is much faster than streaming with bytestrings)
12:06:09 <jedai> tlorenz: of course, if you are doing some processing on the content of the file that wouldn't help you :-/
12:07:11 <parcs`> how can i get a dependency graph of a package?
12:07:47 <dmwit> parcs`: Call cabal info a couple times.
12:08:08 <dmwit> parcs`: Also, "dependency graph" doesn't do the situation justice.
12:08:16 <dmwit> Since there are disjunctions in the dependency constraints.
12:10:47 <mm_freak> mekeor: except for small test programs i use cabal for everything
12:10:57 <mm_freak> and the corresponding option in the cabal file would be Hs-source-dirs
12:11:26 <mm_freak> but if you need to import "../../foo/Bar.hs" and it belongs to the same project, you're probably doing something wrong
12:12:18 <parcs`> dmwit: what about a dependency graph of the install plan that cabal chooses? i really hope 'cabal info' isn't the only way :P
12:13:17 * hackagebot language-javascript 0.4.10 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.4.10 (AlanZimmerman)
12:17:52 <_Mikey> ich möchte ein funktio
12:17:53 <_Mikey> ahh
12:17:55 <_Mikey> whoops
12:18:22 <_Mikey> @hoogle Int->[Char]
12:18:22 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
12:18:22 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
12:18:23 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
12:18:32 <_Mikey> @hoogle Int->String
12:18:32 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
12:18:33 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
12:18:33 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
12:20:22 <jedai> _Mikey: Do you want to convert an Int into a String ?
12:20:33 <_Mikey> yes, I've got it though ;)
12:20:41 <_Mikey> show <Int>
12:20:58 <dmwit> parcs`: I think new cabal-install's have a --parallel option that will show more information about the dependency graph for the install plan.
12:21:00 <_Mikey> is there a more correct way?
12:21:10 <dmwit> parcs`: Currently you can only get (one) toposort of the graph, though.
12:21:18 <dmwit> parcs`: (e.g. exactly what --dry-run shows you)
12:21:29 <jedai> _Mikey: Not really, though you could look at Numeric for more flexible functions
12:21:57 <_Mikey> ok I'll take a look, but show is behaving as expected.
12:22:58 <jedai> _Mikey: Mainly if you wanted to use another base or to show Float or Double with more controls than show gives you
12:33:52 <tlorenz> jedai, yes I'm sampling the file, so sending the entire thing wouldn't help
12:34:14 <jedai> Too bad
12:34:53 <tlorenz> jedai, but someone on stackoverflow also suggested that I use blaze-builder
12:35:52 <tlorenz> so I will look into that in detail and also how Yesod and Snap are using it (these guys must know what they are doing ;) )
12:42:50 <yrlnry> So I was fooling around with 'eff', the new language from Andrej Bauer and his associate, and I was poking around in the source to see if the interactive version of the interpreter supported any commands analogous to ghci's ":t".
12:43:02 <yrlnry> Which it does; you can say #type, #exit, #use, etc.
12:43:18 * hackagebot pqueue 1.2.0 - Reliable, persistent, fast priority queues.  http://hackage.haskell.org/package/pqueue-1.2.0 (LouisWasserman)
12:43:20 <yrlnry> And I noticed from reading the source that there was a #help, so I tried it.
12:43:27 <yrlnry> And it said "Read the source."
12:43:35 <jedai> tlorenz: when you say you sample the file, you mean you process it, or that you have to read it to determine from where to send it, no ? Because sendfile can also send a part of a file if provided with an offset and a length
12:44:04 <geekosaur> yeh, the webpage more or less said that ("no docs, you have the source")
12:44:21 <Grahack> :exit
12:44:25 <Grahack> arf
12:44:29 <jedai> Is the source in a literal style ?
12:44:37 <tlorenz> jeda here is the project I'm working on:https://github.com/thlorenz/Pricetory
12:45:04 <geekosaur> I didn't check; "no docs" is not the way to hold my attention
12:45:11 <tlorenz> jedai, I need to sample the file in steps, e.g., extract ticks/minute from file that contains ticks/sec
12:45:27 <byorgey> yrlnry: hehehe
12:45:32 <yrlnry> The paper provides docs.
12:45:52 <yrlnry> Hi, Brent!  I hope you and yours are well and happy.
12:46:13 <jedai> tlorenz: Ok, so no sendfile for you :(
12:46:22 <tlorenz> jedai :(
12:46:25 <byorgey> Hi Mark!  We are, and I hope the same of you.
12:46:30 <yrlnry> Have you read the eff paper?  It is a really cool idea.
12:46:59 <tlorenz> jedai, at least now I know where to look at in order to improve my server's performance, so thanks for that
12:47:07 <byorgey> I read a few blog posts about it a while ago.  It is indeed a cool idea.  I just printed out the paper but haven't read it yet.
12:47:12 <jedai> tlorenz: Still for that kind of problem, blaze-builder is probably ideal :)
12:47:23 <yrlnry> It immediately grabbed me by the throat.
12:47:34 <byorgey> heh
12:47:46 <yrlnry> Why do I always want to spell Andrej Bauer as "Andrzej"?
12:48:25 <byorgey> I don't know, why?
12:48:31 <byorgey> (that was the setup to a joke, right?)
12:48:32 <yrlnry> To get to the other side!
12:48:35 <byorgey> hehehe
12:49:56 <yrlnry> Hmm, Sjoerd Visscher has a Haskell workalike.
12:50:10 <byorgey> workalike?
12:50:32 <byorgey> oh, something that works like Haskell
12:51:02 <yrlnry> No, a Haskell thing that does what eff does, in the same way that eff does it, but implemented so that you can use it in Haskell programs.
12:51:21 <yrlnry> https://github.com/sjoerdvisscher/effects/blob/master/examples.hs
12:51:37 <geekosaur> yrlnry, were you ever at cmu?  or mit and on zephyr?
12:51:41 <byorgey> oh, right
12:51:51 <geekosaur> keeping andrej and andrzej straight was always fun...
12:52:13 <byorgey> yrlnry: for some reason ISTR it is not quite as expressive as eff.  But I am not really sure.
12:52:14 <yrlnry> I was never at either CMU or MIT.
12:52:32 <geekosaur> ah
12:52:55 <geekosaur> (they were both on CMU CS zephyr at about the same time, yay confusion)
12:53:05 <yrlnry> Oh, you're brandon allbery.
12:53:10 <yrlnry> I know you from usenet.
12:53:30 <geekosaur> yep
12:54:59 * geekosaur gave up on using real name on irc, hanging out in #kerberos & #openafs meant always being mistaken for rra...
12:55:23 <yrlnry> I was not going to do that because I used to know rra pretty well.
12:59:43 <mee> Data.Set doesn't export Data.Set.Set's constructors. Is there a way to get at them if I want to pattern match on Data.Set.Tip and Data.Set.Bin ?
13:00:43 <dmwit> No, but you can use the various views it offers.
13:01:44 <_Mikey> Hey Philippa!
13:04:25 <dmwit> Hm, the views I thought were there aren't there.
13:05:03 <mee> yeah, what I need is a 'filter view'
13:05:20 <dmwit> Anyway, no, you can't pattern match, and I'm pretty sure that's on purpose: the implementation is subject to improvement as better immutable data structures are discovered.
13:05:26 <dmwit> mee: What is a "filter view"?
13:05:28 <mee> ie. Set a -> (a -> Bool) -> Maybe (a, Set a)
13:05:31 <dmwit> mee: Is "partition" sufficient?
13:05:44 <dmwit> :t Data.Set.partition
13:05:45 <lambdabot> forall a. (Ord a) => (a -> Bool) -> S.Set a -> (S.Set a, S.Set a)
13:06:46 <dmwit> mee: Your type can only return at most one 'a'; if multiple values matched, which one would you want it to return?
13:07:46 <dmwit> :t S.partition
13:07:47 <lambdabot> forall a. (Ord a) => (a -> Bool) -> S.Set a -> (S.Set a, S.Set a)
13:07:50 <mee> the only predicate I really care about is equality
13:08:03 <dmwit> mee: Oh, that's easy then.
13:08:33 <dmwit> :t S.splitMember
13:08:34 <lambdabot> forall a. (Ord a) => a -> S.Set a -> (S.Set a, Bool, S.Set a)
13:08:42 <mee> I can do it with filter, but I was trying to do it nicer
13:08:47 <DanBurton> @hoogle Set a -> a -> Maybe (a, Set a)
13:08:47 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:08:48 <lambdabot> Data.Traversable mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:08:48 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (forall e r. Data e => a -> c (e -> r) -> e -> (a, c r)) -> (forall g. a -> g -> (a, c g)) -> a -> d -> (a, c d)
13:08:56 <DanBurton> o_O
13:09:38 <dmwit> :t \x s -> guard (x `S.member` s) >> return (x, S.delete x s)
13:09:39 <lambdabot> forall a (m :: * -> *). (Ord a, MonadPlus m) => a -> S.Set a -> m (a, S.Set a)
13:10:02 <DanBurton> > S.fromList [1,2,3] S.\\ S.fromList [2]
13:10:03 <lambdabot>   fromList [1,3]
13:10:27 <dmwit> :t \x s -> let (small, b, large) = S.splitMember x s in guard b >> return (small `S.union` large)
13:10:28 <lambdabot> forall a (m :: * -> *). (Ord a, MonadPlus m) => a -> S.Set a -> m (S.Set a)
13:10:36 <dmwit> Two implementations, just for you!
13:10:41 <dmwit> oh, whoops
13:10:45 <dmwit> :t \x s -> let (small, b, large) = S.splitMember x s in guard b >> return (x, small `S.union` large)
13:10:46 <lambdabot> forall a (m :: * -> *). (Ord a, MonadPlus m) => a -> S.Set a -> m (a, S.Set a)
13:12:20 <DanBurton> and you can use any ol' function as a "view" to pattern match on with the ViewPatterns language extension
13:12:28 <mee> I might be abusing Set here. My set is of a type like data F Int Char with a homebrewed Eq instance where (F _ c1) == (F _ c2) = c1 = c2, so I'd like to pull the element out, update the part that doesn't effect equality and shove it back in.
13:12:41 <mee> which is easily done with filter, etc. but it's bit awkward
13:13:29 <mauke> why not use a Map?
13:13:34 <DanBurton> if you are already certain that the elementis in there, just do a delete and then an insert
13:13:42 <DanBurton> and if you're not, just test with member
13:14:19 <DanBurton> these operations are all O(log n) on a Set
13:14:28 <DanBurton> but filtering over the whole set is O(n)
13:15:24 <dmwit> mauke++ Just use a Map. It's what they're for.
13:15:27 <DanBurton> (n.b. split and splitMember are also O(log n))
13:15:53 <mee> DanBurton: except the member I want to insert is a product of the member in there and the new one (that are equal). mauke: yeah, I don't have a good answer for that. harumph.
13:16:20 <DanBurton> mee: sounds like an even stronger case for Map. use insertWith
13:17:42 <mee> DanBurton: yeah, that's exactly what I need.
13:17:44 <mee> thanks all.
13:20:26 <ehy_> (join . fmap join) [[[1], [2, 3]], [[]]]
13:20:28 <ehy_> > (join . fmap join) [[[1], [2, 3]], [[]]]
13:20:30 <lambdabot>   [1,2,3]
13:20:36 <ehy_> > (join . join) [[[1], [2, 3]], [[]]]
13:20:37 <lambdabot>   [1,2,3]
13:21:45 <aristid> :t join . fmap join
13:21:45 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m (m (m a)) -> m a
13:21:55 <aristid> :t join . join
13:21:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
13:25:05 <DanBurton> smells like a monad law
13:27:22 <otters> > join [[1,2]]
13:27:23 <lambdabot>   [1,2]
13:27:29 <otters> > join [[1],[2]]
13:27:30 <lambdabot>   [1,2]
13:27:39 <dmwit> Monad laws smell delicious.
13:27:49 <otters> @src [] join
13:27:49 <lambdabot> Source not found. I feel much better now.
13:27:56 <otters> hm
13:27:59 <DanBurton> dmwit: that is because Monads are cream puffs
13:28:16 <zhulikas> @hoogle [[a]] -> [a]
13:28:16 <lambdabot> Prelude concat :: [[a]] -> [a]
13:28:16 <lambdabot> Data.List concat :: [[a]] -> [a]
13:28:16 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
13:28:44 <DanBurton> otters: join is defined in terms of >>=
13:28:45 <dmwit> otters: join is defined outside the class
13:28:47 <dmwit> ?src join
13:28:47 <lambdabot> join x =  x >>= id
13:28:51 <otters> bah
13:29:00 <otters> > join [[[1]]]
13:29:01 <lambdabot>   [[1]]
13:29:12 <otters> > join $ join [[1]]
13:29:12 <lambdabot>   No instance for (GHC.Num.Num [a])
13:29:13 <lambdabot>    arising from a use of `e_11' at <inter...
13:29:41 <zhulikas> > concat [[2],[2]]
13:29:42 <lambdabot>   [2,2]
13:29:50 <zhulikas> > join []
13:29:51 <lambdabot>   []
13:29:53 <zhulikas> > join [[]]
13:29:54 <lambdabot>   []
13:29:56 <DanBurton> I always find GHC's "this isn't an instance of Num" to be the most worthless of error messages
13:30:07 <zhulikas> > join [[[]]]
13:30:08 <lambdabot>   [[]]
13:30:12 <copumpkin> > [] + []
13:30:13 <lambdabot>   No instance for (GHC.Num.Num [a])
13:30:13 <lambdabot>    arising from a use of `e_1' at <intera...
13:30:16 <zhulikas> :D
13:30:27 <zhulikas> @t (+)
13:30:27 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:30:30 <zhulikas> @type (+)
13:30:31 <lambdabot> forall a. (Num a) => a -> a -> a
13:30:42 <zhulikas> > [] mappend []
13:30:43 <lambdabot>   Couldn't match expected type `(a -> a -> a) -> [a1] -> t'
13:30:43 <lambdabot>         against i...
13:30:50 <zhulikas> > mappend [] []
13:30:51 <lambdabot>   []
13:31:00 <zhulikas> @type mappend
13:31:01 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:31:18 <DanBurton> you know ghci does exist for a reason ;)
13:31:38 <zhulikas> nah.
13:31:50 <zhulikas> lambdabot exist for a reason
13:33:23 * hackagebot type-sub-th 0.1.0.6 - Substitute types for other types with Template Haskell  http://hackage.haskell.org/package/type-sub-th-0.1.0.6 (JonathanFischoff)
13:33:49 <dmwit> > join 1
13:33:50 <lambdabot>   No instance for (GHC.Show.Show (m a))
13:33:50 <lambdabot>    arising from a use of `M8040922792...
13:34:04 <dmwit> uh
13:34:06 <dmwit> :t join 1
13:34:07 <lambdabot> forall (m :: * -> *) a. (Num (m (m a)), Monad m) => m a
13:34:38 <zhulikas> > join 1 2
13:34:39 <lambdabot>   1
13:34:41 <zhulikas> :|
13:34:42 <dmwit> Man, now I wish I hadn't used M8040922792...
13:35:12 <DanBurton> TIL numbers are monads...?
13:35:41 <DanBurton> or rather, there exists some monad such that (m (m a)) is a Num
13:36:09 <DanBurton> :t join 1 2
13:36:09 <lambdabot> forall a. (Num a) => a
13:36:26 <ehy_> wow
13:36:33 * DanBurton wonders which instance is working this dark magick
13:36:47 <ehy_> > join 1 2
13:36:48 <lambdabot>   1
13:36:55 <ehy_> > join True
13:36:56 <lambdabot>   Couldn't match expected type `m (m a)'
13:36:56 <lambdabot>         against inferred type `GHC.B...
13:37:12 <DanBurton> it works on numbers because of the implicit fromIntegral
13:37:13 <parcs`> > join (const (const 1)) 2
13:37:14 <lambdabot>   1
13:37:25 <ehy_> > (return 1)
13:37:26 <lambdabot>   No instance for (GHC.Show.Show (m t))
13:37:26 <lambdabot>    arising from a use of `M4486800389...
13:37:34 <ehy_> > join (return 1)
13:37:35 <lambdabot>   No instance for (GHC.Num.Num (m a))
13:37:35 <lambdabot>    arising from a use of `e_11' at <int...
13:37:45 <ehy_> > (join $ join (return 1)) 2
13:37:46 <lambdabot>   1
13:37:49 <ehy_> wtf
13:37:56 * DanBurton 's brain explodes
13:38:03 * ehy_ brain explodes
13:38:08 * ehy_ 's brain explodes
13:38:16 <ehy_> > join (join 1)
13:38:16 <lambdabot>   No instance for (GHC.Show.Show (m a))
13:38:17 <lambdabot>    arising from a use of `M2409656302...
13:38:23 * hackagebot universe-th 0.0.0.6 - Construct a Dec's ancestor list.  http://hackage.haskell.org/package/universe-th-0.0.0.6 (JonathanFischoff)
13:38:25 * hackagebot specialize-th 0.0.0.8 - Create specialized types from polymorphic ones using TH  http://hackage.haskell.org/package/specialize-th-0.0.0.8 (JonathanFischoff)
13:38:27 <ehy_> lol what is this monad
13:38:28 <zhulikas> :DD
13:38:31 <DanBurton> > join (join 1) 2
13:38:32 <lambdabot>   1
13:38:53 <ehy_> seriously? T_T
13:38:58 <ehy_> > join 1.0
13:38:58 <lambdabot>   No instance for (GHC.Show.Show (m a))
13:38:59 <lambdabot>    arising from a use of `M6277033215...
13:39:01 <zhulikas> @type m a -> m b -> a
13:39:02 <lambdabot> parse error on input `->'
13:39:10 <zhulikas> okay :|
13:39:12 <vodik> > join (join (join 1) 2) 3
13:39:13 <lambdabot>   1
13:39:15 <DanBurton> so lambdabot has a Num instance for Num a => b -> a ?
13:39:19 <zhulikas> @type a -> b -> a
13:39:19 <lambdabot> parse error on input `->'
13:39:22 <zhulikas> dafuq
13:39:35 <zhulikas> @hoogle m a -> m b -> a
13:39:35 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
13:39:35 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
13:39:35 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
13:39:43 <ehy_> > (+1) + (+2)
13:39:44 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:39:44 <lambdabot>    arising from a use of `...
13:39:48 <ehy_> > ((+1) + (+2)) 3
13:39:49 <lambdabot>   9
13:39:52 <ehy_> apparently
13:39:53 <zhulikas> @type join
13:39:53 <ehy_> lol
13:39:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:40:04 <ehy_> > ((+1) + (+2)) 5
13:40:05 <lambdabot>   13
13:40:07 <ehy_> > ((+1) + (+2)) 6
13:40:08 <lambdabot>   15
13:40:10 <DanBurton> (const 3 + const 4) undefined
13:40:10 <ehy_> > ((+1) + (+2)) 7
13:40:11 <lambdabot>   17
13:40:17 <DanBurton> > (const 3 + const 4) undefined
13:40:18 <lambdabot>   7
13:40:25 <zhulikas> stop confusing me :D
13:40:30 <andares> hey, does last take O(n)?
13:40:37 <ehy_> yes
13:40:43 <Rc43> Hi, guys.
13:40:43 <andares> hrm.
13:40:46 <ehy_> (id + id) -0
13:40:51 <ehy_> > (id + id) 0
13:40:52 <lambdabot>   0
13:40:55 <DanBurton> Rc43: hello
13:40:57 <ehy_> > (id + id + (+1)) 0
13:40:58 <lambdabot>   1
13:41:02 <ehy_> > (id + id + (+1) + (+1)) 0
13:41:03 <lambdabot>   2
13:41:05 <andares> so I'm working on a function to identify palindromic numbers.
13:41:06 <ehy_> > (id + id + (+1) + (+1)) 1
13:41:06 <DanBurton> dear newbies: just ignore all of this nonsense
13:41:06 <lambdabot>   6
13:41:07 <vodik> andares: has the preformance characteristics of a linked list
13:41:08 <ehy_> > (id + id + (+1) + (+1)) 2
13:41:09 <lambdabot>   10
13:41:25 <ehy_> dafuq
13:41:26 <Rc43> Can anybody tell which difference between Gtk2hs API and SOE.Gtk Api?
13:41:35 <andares> so I was going to convert the number into a list of digits, then check the digits for palindromicity.
13:41:37 <ehy_> > abs id
13:41:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:41:39 <lambdabot>    arising from a use of `...
13:41:45 <andares> what data structure should I use then for the list of digits?
13:41:48 <ehy_> > (abs id) :: int
13:41:49 <lambdabot>   Couldn't match expected type `int' against inferred type `a -> a'
13:41:49 <lambdabot>    `int' ...
13:41:50 <ehy_> > (abs id) :: Int
13:41:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:41:51 <lambdabot>         against inferred type ...
13:41:59 <DanBurton> andares: String works just fine
13:42:02 <ehy_> > abs (+1)
13:42:03 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:42:03 <lambdabot>    arising from a use of `...
13:42:08 <ehy_> > 2 + abs (+1)
13:42:09 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:42:09 <lambdabot>    arising from a use of `...
13:42:20 <ehy_> > (2 + abs (+1)) :: Integer
13:42:20 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
13:42:21 <lambdabot>         against inf...
13:42:22 <andares> DanBurton: isn't a String just a [Char]? and can I have a String of Ints?
13:42:27 <byorgey> andares: sounds good.  just use a list of Int (if you convert the number to digits mathematically) or a list of Char (if you convert it using 'show')
13:42:32 <kallisti> @hoogle sets
13:42:33 <lambdabot> Graphics.Rendering.OpenGL.GLU.NURBS setSamplingMethod :: NURBSObj -> SamplingMethod -> IO ()
13:42:33 <lambdabot> Network.BSD setServiceEntry :: Bool -> IO ()
13:42:33 <lambdabot> System.Posix.Signals setSignalMask :: SignalSet -> IO ()
13:42:50 <ehy_> you can't have a String of Ints simply because String = [Char]
13:42:52 <DanBurton> andares: either works
13:42:55 <andares> byorgey: but I'll have to access the last element of the list at each step of the palindrome checker, which seems wasteful.
13:43:00 <byorgey> andares: yes, String is the same as [Char].  A String of Ints does not make sense. You can have a list of Ints, i.e. [Int]
13:43:09 <DanBurton> andares: but no you cna't have a String of Int. You can have a [Int]
13:43:15 <byorgey> andares: that's not a very good way to implement a palindrome checker.
13:43:35 <parcs`> @check \x -> (sin^2 + cos^2) x == 1
13:43:36 <lambdabot>   "Falsifiable, after 0 tests:\n3.0\n"
13:43:55 <parcs`> @check \x -> (sin^2 + cos^2) x == 1
13:43:56 <lambdabot>   "Falsifiable, after 12 tests:\n-1.6666666666666665\n"
13:44:17 <dmwit> > (sin^2 + cos^2) 3
13:44:18 <lambdabot>   0.9999999999999999
13:44:22 <ehy_> > (sin^2 + cos^2) 134789
13:44:23 <lambdabot>   0.9999999999999999
13:44:29 <ehy_> oh lol you can add functions in Haskell
13:44:34 <ehy_> didn't know that
13:44:35 <DanBurton> @check \x -> (sin^2 + cos^2) x `approxEq` 1 where approxEq n m = abs (n - m) < 0.00001
13:44:35 <lambdabot>   Parse error at "where" (column 38)
13:44:38 <parcs`> @check \x -> round (sin^2 + cos^2) x == 1
13:44:39 <lambdabot>   No instances for (GHC.Real.RealFrac (a -> a),
13:44:39 <lambdabot>                    GHC.Real.I...
13:44:39 <DanBurton> doh
13:44:45 <byorgey> ehy_: you can add functions if you make a Num instance for functions.
13:44:48 <rwbarton> @check (sin^2 + cos^2) x == 0.9999999999999999
13:44:49 <lambdabot>   "Falsifiable, after 0 tests:\n"
13:44:50 <popx> :t (+)
13:44:51 <lambdabot> forall a. (Num a) => a -> a -> a
13:44:57 <popx> :info Num
13:44:57 <byorgey> ehy_: the standard libraries do not define such an instance, but lambdabot has it.
13:45:00 <ehy_> byorgey: yeah. I didn't know lambdabot had one
13:45:05 <dmwit> ehy_: Yes, there's a sneaky instance Num a => Num (b -> a)
13:45:15 <ehy_> > abs sin
13:45:16 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:45:16 <lambdabot>    arising from a use of `...
13:45:16 <andares> byorgey: I should do num `mod` 10 for the last digit. for the first digit, I will have to divide it by 10^i for some kind of power of i, right?
13:45:17 <andares> -
13:45:17 <DanBurton> @check \x -> let approxEq n m = abs (n - m) < 0.000001 in (sin^2 + cos^2) x `approxEq` 1
13:45:19 <lambdabot>   "OK, passed 500 tests."
13:45:21 <popx> where can I find a spec or likewise on lambdabots haskell?
13:45:51 <Saizan> popx: you can look at L.hs in the repo
13:45:54 <ehy_> @free reverse
13:45:55 <lambdabot> $map f . reverse = reverse . $map f
13:45:56 <DanBurton> parcs`: very cool
13:46:01 <Saizan> or was it Pristine.hs ?
13:46:01 <ehy_> @free map
13:46:02 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
13:46:11 <byorgey> andares: you could do that.  But I think it would be easier to convert it to a list of digits first.
13:46:18 <ehy_> I still don't understand how (join 1) works
13:46:20 <ehy_> > join 1 2
13:46:21 <lambdabot>   1
13:46:27 <andares> byorgey: but you just said that's not a good way to do it!
13:46:32 <ehy_> > :t join 1
13:46:33 <DanBurton> @free willie
13:46:33 <lambdabot>   <no location info>: parse error on input `:'
13:46:33 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `willie'\n\n"
13:46:37 <ehy_> :t join 1
13:46:37 <lambdabot> forall (m :: * -> *) a. (Num (m (m a)), Monad m) => m a
13:46:45 <byorgey> andares: I meant that looking at the last element repeatedly is not a good way to do it.
13:46:58 <byorgey> andares: there are other things you can do with a list of digits.
13:47:31 <DanBurton> ehy_: since Num a => b -> a is an instance of Num, and (b ->) is an instance of Monad, it...just works
13:47:47 <byorgey> andares: try thinking about the problem on a higher level.  What does it mean for a list to be a palindrome?
13:47:57 <DanBurton> @type join `asAppliedTo` (undefined :: a -> a -> c)
13:47:58 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
13:48:02 <ehy_> but Integer isn't a monad
13:48:02 <otters> > join 1
13:48:03 <lambdabot>   No instance for (GHC.Show.Show (m a))
13:48:03 <lambdabot>    arising from a use of `M7653566019...
13:48:11 <otters> wat
13:48:17 <ehy_> I know you can join functions
13:48:23 * hackagebot gdiff-th 0.0.0.1 - Generate gdiff GADTs and Instances.  http://hackage.haskell.org/package/gdiff-th-0.0.0.1 (JonathanFischoff)
13:48:25 * hackagebot zeromq-haskell 0.8.4 - Bindings to ZeroMQ 2.1.x  http://hackage.haskell.org/package/zeromq-haskell-0.8.4 (ToralfWittner)
13:48:30 <DanBurton> ehy_: but did you know functions are Nums?
13:48:34 <ehy_> > join (\x -> x*x) 2 == 4
13:48:35 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
13:48:40 <ehy_> DanBurton: yes
13:48:42 <andares> byorgey: list !! i == list !! l-i where l = length list
13:48:50 <ehy_> DanBurton: but I didn't know Integers were monads
13:48:54 <DanBurton> ehy_: that's the trick. all numeric literals have an implicit fromIntegral.
13:48:57 <DanBurton> ehy_: they're not
13:49:01 <ehy_> oh!
13:49:05 <ehy_> lol.
13:49:14 <ehy_> so it's implicitly doing join (const 1)?
13:49:21 <DanBurton> yes exactly
13:49:25 <ehy_> or rather
13:49:25 <andares> alternatively, that the inner part of the list is a palindrome, and that the first and last elements are the same.
13:49:27 <ehy_> join (const (const 1))
13:49:34 <byorgey> andares: that's a fairly low-level, algorithm-oriented way to define it.  Can you think of a way to define palindromes that does not involve talking about indices?
13:49:41 <DanBurton> @type 1 :: Num c => a -> b -> c
13:49:42 <lambdabot> forall a b c. (Num c) => a -> b -> c
13:49:51 * ehy_ 's mind is blown
13:50:28 <andares> byorgey: they're the same backwards as forwards?
13:50:34 <byorgey> andares: yes!
13:50:42 <andares> oh! I can just reverse the list and compare it.
13:50:43 <DanBurton> since Num c => b -> c is a num, that neams Num c => a -> (b -> c) is also a Num
13:50:44 <byorgey> andares: now, can you turn that into code? =)
13:50:47 <byorgey> andares: exactly =)
13:50:49 <andares> == is probably even defined on [Int], right?
13:50:54 <byorgey> andares: yes, it is
13:51:08 <andares> I sure can! thanks byorgey.
13:51:14 <popx> andares: defined on Eq a => [a]
13:51:14 <byorgey> andares: you're welcome =)
13:51:35 <ehy_> @free fix
13:51:36 <lambdabot> f . g = h . f => f (fix g) = fix h
13:51:58 <DanBurton> andares: meaning, any type "a" that has an Eq instance also has an Eq instance for [a]
13:52:35 <ehy_> let (f, g, h) = (const 1, const 2, const 1) in f (fix g)
13:52:40 <ehy_> > let (f, g, h) = (const 1, const 2, const 1) in f (fix g)
13:52:41 <lambdabot>   1
13:52:45 <ehy_> > let (f, g, h) = (const 1, const 2, const 1) in fix h
13:52:46 <lambdabot>   1
13:53:04 * ehy_ thinks the free theorem generator is amazing
13:53:04 <DanBurton> or, in Coq-y talk: given a proof of a type "a"'s Eq-ness, a proof of [a]'s Eq-ness can be derived
13:53:09 <ivanm> @src [a] (==)
13:53:09 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:53:12 <ivanm> @src [a] Eq
13:53:12 <lambdabot> Source not found.
13:53:14 <ivanm> bah
13:53:21 <DanBurton> @src [] Eq
13:53:21 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:53:23 <ehy_> @free on
13:53:24 <lambdabot> (forall x. g . k x = p (f x) . f) => f . q = f1 . h => g . on k q y = on p f1 (h y) . h
13:53:37 <DanBurton> @src (Eq a => [a]) Eq
13:53:37 <lambdabot> Source not found. Take a stress pill and think things over.
13:53:39 <DanBurton> bah
13:53:48 <ehy_> @free flip
13:53:49 <lambdabot> Expected variable or '.'
13:53:54 <byorgey> ehy_: parametric polymorphism is pretty amazing =)
13:54:26 <ehy_> byorgey: can the free theorem trick be extended to algebraic data types?
13:54:34 <ehy_> byorgey: or do you have to analyze each one separately
13:55:15 <DanBurton> ehy_: what sort of theorems would you want on an ADT? The interesting theorems seem to be about the way functions compose
13:55:29 <byorgey> ehy_: I think it should be possible to extend it to algebraic data types in a generic way
13:55:46 <ehy_> DanBurton: e.g. there are interesting free theorems involving lists
13:55:55 <DanBurton> true point
13:56:09 <DanBurton> that would make sense
13:56:10 <sclv> free theorems exist for polymorphic functions
13:56:10 <ehy_> DanBurton: I was wondering if that used a special trick that only worked for lists, or something that could work for all ADTs
13:56:24 <byorgey> are there any free theorems involving lists that make essential use of their "list-ness", though?
13:56:33 <byorgey> or are they just as applicable to any functor?
13:56:40 <sclv> byorgey -- I don't think there can be ?
13:56:47 * DanBurton suspects the latter
13:57:01 <byorgey> sclv: what do you mean?
13:57:11 <sclv> i don't think that a free theorem can make use of the listness of list
13:57:23 <sclv> just sort of by definition.
13:57:47 * DanBurton wonders what the implications of "free theorems" are for languages like Coq, Agda, Idris
13:58:09 <byorgey> DanBurton: see Jean-Philippe Bernardy's thesis
13:58:18 <DanBurton> byorgey: got a link?
13:58:23 <otters> huh
13:58:40 <otters> idris looks like let ((:),(::)) = ((::),(:)) in regularHaskell
13:58:40 <dpratt71> well folks, it turns out that Monads are light waves...or a rainbow...or the visible spectrum...or something like that
13:58:45 <dpratt71> just thought y'all should know
13:58:57 <DanBurton> otters: plus dependent types! wooo
13:59:07 <otters> oh
13:59:14 <otters> those too
13:59:22 <DanBurton> and interactive proof mode
13:59:28 <byorgey> DanBurton: maybe see http://publications.lib.chalmers.se/cpl/record/index.xsql?pubid=135303
13:59:32 <otters> if there's one thing I've always wanted
13:59:35 <otters> it's interactive proof mode
13:59:53 <DanBurton> if so then Idris must be a dream come true for you
14:00:06 <byorgey> otters: you laugh, but it's highly addictive.
14:00:14 <otters> I'm sure it is
14:00:32 <DanBurton> I was sketching out features that I wanted for a Haskell++ language, and Idris has several of them.
14:01:08 <andares> hey, the syntax for where is "where foo = bar\n baz=bop" right?
14:01:16 <DanBurton> overloaded functions being one. semi-first-class labels being another
14:01:23 <copumpkin> andares: they need to line up
14:01:31 <copumpkin> the beginning of foo and baz
14:01:34 <hpc> andares: yeah, with alignment on the 'f' of "foo" and the 'b' of "bar"
14:01:43 <byorgey> s/bar/baz/
14:01:49 <andares> huh, I thought it was..
14:01:50 <hpc> baz
14:01:53 <hpc> yeah, that
14:02:01 <byorgey> andares: careful you don't have any tab characters
14:02:23 <byorgey> andares: also, where can only come following a declaration, not in the middle of an arbitrary expression
14:02:29 <kallisti>     Could not deduce (b ~ [Char])
14:02:31 <kallisti>     from the context (ToJSON a, FromJSON b)
14:02:41 <kallisti> I don't really understand this error, because String is an instance of FromJSON.
14:02:51 <_Mikey> How do you install an older version of a package with cabal?
14:02:53 <andares> ah, fixed it. I think I'm going to stick with soft tabs.
14:03:09 <otters> overloaded functions do sound good
14:03:10 <stepcut> _Mikey: cabal install package-1.3.5
14:03:13 <DanBurton> byorgey: thanks for the link btw
14:03:25 <dmwit> kallisti: The error is saying that not all instances of FromJSON are String.
14:03:26 <_Mikey> stepcut, cheers
14:03:52 <dmwit> kallisti: Hard to say much more than that without looking at the code, though.
14:03:58 <byorgey> kallisti: String being an instance of FromJSON is neither here nor there.  That error says it needed b to be String for some reason but in fact b could be anything
14:03:59 <stepcut> _Mikey: if you are trying to get cabal to automatically pick an older verison of a dependency then you need to use the --constraints flag instead
14:04:13 <andares> there's no way to build lists adding to the right rather than to the left, right?
14:04:26 <byorgey> andares: there is:  someList ++ [element]
14:04:29 <byorgey> andares: however, don't
14:04:34 <DanBurton> andares: you can just imagine that the list is actually backwards
14:04:41 <byorgey> because it takes O(n) time
14:04:46 <otters> then what do you do
14:04:54 <dmwit> andares: There are other data structures than [] that are better suited to either-end-additions, if that's what you want to do.
14:05:02 <andares> DanBurton: hm, okay.
14:05:04 <DanBurton> > let snoc = flip (:) in [] `snoc` 1 `snoc` 2
14:05:05 <lambdabot>   [2,1]
14:05:06 <dmwit> andares: (But if you only need to add at the end, you might as well just store the list backwards, as DanBurton says.)
14:05:13 <DanBurton> andares: ;)
14:06:02 <dmwit> There's also a very beautiful implementation of queues via the type ([a], [a])
14:06:24 <DanBurton> andares: if you want efficient operations all over the list, and you don't mind a little more strictness, then go for Data.Sequence
14:06:34 <hpaste> “_Mikey” pasted “Problem with cabal” at http://hpaste.org/64993
14:06:44 <DanBurton> @type Data.Sequence.|>
14:06:45 <lambdabot> parse error on input `Data.Sequence.|>'
14:06:55 <DanBurton> @type (Data.Sequence.|>)
14:06:56 <lambdabot> forall a. Seq.Seq a -> a -> Seq.Seq a
14:07:03 <dmwit> push a (front, back) = (front, a:back); pop (a:front, back) = (a, (front, back)); pop ([], []) = error "die"; pop ([], back) = pop (reverse back, [])
14:07:09 <_Mikey> I've got a problem using cabal, it always complains about shared object files whatever I do.
14:07:30 <DanBurton> > Seq.fromList [1,2,3] Seq.|> 4
14:07:31 <lambdabot>   fromList [1,2,3,4]
14:08:02 <dmwit> _Mikey: Perhaps you should install libgmp-3
14:08:23 <_Mikey> dmwit, I'll give it ago
14:08:36 <kallisti> byorgey: well in most cases it can be anything, but in one case it is specifically a string. is that not allowed?
14:09:11 <byorgey> kallisti: English is too imprecise here.
14:09:38 <byorgey> kallisti: obviously it is not allowed, since you are getting an error. =)  But to explain why I would have to look at your code.  Maybe you can paste it?
14:10:11 * byorgey is pretty sure andares does not need any fancy queues etc.
14:10:25 <_Mikey> dmwit, I had it
14:10:35 <byorgey> (based on previous discussion)
14:10:52 <hpaste> stj pasted “matrix exponentiation - stack overflow” at http://hpaste.org/64994
14:10:54 * DanBurton will unendingly sing the glories of Data.Sequence
14:11:20 <stj> I get stack overflow when running this code - but why is that so? I thought foldl is tail-recursive
14:11:28 <kallisti> byorgey: hm, no that's okay. I think I see why.
14:11:50 <kallisti> it can't be /any/ FromJSON
14:11:52 <kallisti> because I made it a string.
14:11:53 <DanBurton> stj: try using foldl' or compiling with -O2
14:12:13 <DanBurton> stj: foldl can be lazy, and tail-recursiveness means nothing in the presence of laziness
14:12:22 <c_wraith> stj: foldl is tail-recursive, sure.  But that doesn't mean anything if the value it accumulates isn't evaluated
14:12:27 <byorgey> stj: tail-recursive is not an important concept in Haskell.  also, foldl should pretty much never be used.  See http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
14:12:36 <stj> all right, now I am using fold' and -O2... still stack overflow
14:12:47 <DanBurton> sadface
14:12:57 <DanBurton> I'll check it out.
14:13:22 <Saizan> it's not like seq'ing [[a]] is going to do much
14:14:07 <DanBurton> ...is there a deepseqfoldl?
14:14:21 <kallisti> byorgey: the problem is that there's two kinds of HTTP responses I can get. one is JSON and the other is plaintext.
14:14:27 <kallisti> so I guess I just need two different functions.
14:15:02 <byorgey> kallisti: not necessarily.  But I can't really offer any advice without seeing the code ;)
14:15:20 <DanBurton> stj: if you actually want to do matrixy things with Haskell, you should check out hmatrix, repa, and friends
14:15:34 <DanBurton> stj: but i'll still look into the stack overflow
14:16:05 <stj> I've been researching such libraries... but still, I'd like to find out how to make things tail-recursive and avoid stack overflows
14:16:37 <dmwit> _Mikey: In that case, perhaps you need to add something to an environment variable telling where to find the so file.
14:16:44 <DanBurton> I think one problem is taking a huge [[a]] and using transpose on it
14:16:45 <c_wraith> stj: then the most important thing you can learn is that stack overflows are not caused by lack of tail recursion, in GHC
14:16:56 <kallisti> byorgey: lemme fix all the other type errors first.
14:16:57 <DanBurton> list is not a great data structure for handling transpose well
14:17:51 <copumpkin> I dunno
14:17:54 <stj> hmm, so what if I want to exponentiate the matrix like this? It's kind of limiting that I can't make such a trivial for-loop without using recursion and running into stack overflow :(
14:18:08 <Veinor> > fix$(<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2))$1
14:18:09 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
14:18:12 <copumpkin> > let transpose = getZipList . Data.Traversable.traverse ZipList in transpose [[1,2,3],[4,5,6],[7,8,9]]
14:18:13 <Veinor> >:|
14:18:14 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
14:18:22 <copumpkin> that seems kinda cute
14:18:22 <dmwit> stj: Stack overflows come from deeply-nested thunks, not from deep call stacks in the traditional sense.
14:18:24 * hackagebot Peano 0.0.4 - simple Peano numbers  http://hackage.haskell.org/package/Peano-0.0.4 (FrancescoMazzoli)
14:18:32 <c_wraith> stj: would you please listen? stack overflows are not from function evaluation
14:18:58 <Axman6> stj: what happens if you use: Matrix as * Matrix bs = let bs' = transpose bs in zipWith (\xs ys -> sum (zipWith (*) xs ys)) as bs'?
14:19:25 <Axman6> (which, imo, is clearer)
14:19:35 <edwardk> stj: if you switch from a lazy list to an unboxed array you'd not have any lazy value problems
14:20:17 <stj> I see
14:22:25 <kallisti> byorgey: http://sprunge.us/LgUX?haskell source code and http://sprunge.us/agZH errors
14:22:58 <kallisti> byorgey: I apologize for One Big File. I haven't organized them into modules since I kind of just started yesterday.
14:23:24 * hackagebot resource-pool-catchio 0.2.1.0 - Fork of resource-pool, with a MonadCatchIO constraint  http://hackage.haskell.org/package/resource-pool-catchio-0.2.1.0 (JurrienStutterheim)
14:23:32 <elliottt> is sdist broken in cabal-install head?
14:23:57 <qued_____> test.hs:8:11: Not in scope: `toLower'
14:24:00 <qued_____> hoogle: Data.char
14:24:05 <qued_____> but how to include that
14:24:13 <kallisti> import Data.Char at the top
14:24:17 <qued_____> ty
14:24:19 <pozic_> On which platforms does the creation of shared libraries work and are there any examples of doing so available?
14:24:32 <pozic_> (with GHC of course)
14:24:55 <kallisti> byorgey: the protocol is HTTP. some responses send plaintext info and other send JSON. in particular, if I get a 302, then the Location header is the valuable piece of information. I handle that case specially.
14:25:03 <kallisti> byorgey: and then treat any 2xx response as JSON (at the moment)
14:26:40 <byorgey> kallisti: right, your function type signature promises to return whatever FromJSON instance the caller wants
14:26:47 <kallisti> byorgey: yeah I understand the problem now.
14:26:56 <kallisti> was hoping if you had any recommendations besides implement two different functions.
14:27:01 <DanBurton> > let transpose = foldr (zipWith (:)) (repeat []) in transpose [[1,2,3],[4,5,6],[7,8,9]]
14:27:02 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
14:27:17 <byorgey> kallisti: there has to be a better way than implementing two different functions.  I don't have any specific recommendations.
14:27:27 <byorgey> kallisti: my general recommendation, though, is to spend some time refactoring
14:27:43 <byorgey> kallisti: break it into modules, break giant functions like doCommand' into smaller functions, etc.
14:27:44 <kallisti> byorgey: oh I think I know
14:27:50 <kallisti> byorgey: well yes that too
14:28:05 <byorgey> through that process you will often solve problems like this indirectly
14:28:36 <kallisti> byorgey: I've already broken it down into handleHttpErr and handleHttpBody
14:29:59 <kallisti> byorgey: but I can take the plaintext, wrap it into a JSON string, and then apply fromJSON' to it.
14:30:10 <kallisti> and that will make it work with any FromJSON instance.
14:30:18 <byorgey> yep, sounds good
14:30:24 <kallisti> (though it's not technically a top-level JSON value, as part of the spec)
14:30:31 <kallisti> (I don't know how Aeson handles those cases)
14:30:41 <kallisti> may just be a runtime parse error.
14:30:44 <kallisti> guess I'll find out!
14:34:54 <kallisti> byorgey: I tend to make these large ugly blobs and then break them down later.
14:35:00 <kallisti> that might be counterproductive, I don't know.
14:35:14 <pozic_> What is the simplest web-server available in Haskell? The less features, the better.
14:35:16 <dmwit> I think we all do that from time to time.
14:35:28 <pozic_> (in the form of a library)
14:35:37 <dmwit> There's even a term for it: "technical debt".
14:35:41 <kallisti> dmwit: it's a good way to work out the process before figuring out the subcomponents.
14:35:57 <kallisti> dmwit: but I feel working with smaller pieces and putting them together could lead to a better design.
14:36:22 <byorgey> kallisti: there's nothing wrong with it, indeed, we all do it.  I was just suggesting that you might benefit from breaking them down a bit sooner than you otherwise would.
14:36:35 <DanBurton> does <* perform the left action first?
14:36:41 <byorgey> i.e. force yourself to start refactoring before you think you are ready.
14:36:42 <dmwit> ?src (<*)
14:36:43 <lambdabot> (<*) = liftA2 const
14:36:54 <dmwit> ?src liftA2
14:36:54 <lambdabot> liftA2 f a b = f <$> a <*> b
14:37:03 <DanBurton> guess so
14:37:13 <pozic_> DanBurton: please just don't use that.
14:37:27 <DanBurton> > runWriter $ tell [3] <* tell [4]
14:37:28 <lambdabot>   ((),[3,4])
14:37:39 <DanBurton> pozic_: what's wrong with it?
14:37:44 <pozic_> DanBurton: (if you have to ask, it means it is too complex)
14:37:47 <dmwit> ?src (<$>)
14:37:47 <lambdabot> f <$> a = fmap f a
14:37:54 <pozic_> DanBurton: imagine reading it next year.
14:38:13 <Veinor> pozic_: by that logic, i shouldn't use anything i don't already know
14:38:23 <pozic_> Veinor: and perhaps you shouldn't.
14:38:25 <dmwit> DanBurton: It probably depends on which instance you're using, but most instances seem to run the left action first.
14:38:29 <Veinor> but that includes haskell!
14:38:37 <Veinor> well
14:38:42 <Veinor> it did include haskell before i learned it
14:38:59 <DanBurton> dmwit: makes sense
14:39:30 <DanBurton> pozic_: I imagine by next year I'll have a much firmer grasp of applicative combinators
14:39:38 <pozic_> Veinor: if you know a Turing-Complete subset of a language and make clear code, it doesn't matter whether it uses Arrows or Monads or whatever you want.
14:40:21 * dmwit finds pozic_'s whole line of argument unconvincing
14:40:29 <DanBurton> except that certain styles of coding are much more maintainable
14:41:01 <rostayob> pozic_: applicative-style code is very very clear
14:41:13 <Veinor> pozic_: what's wrong with applicatives? i use them all the time
14:41:16 <rostayob> much more than point-free monadic code for example
14:41:32 * DanBurton glares at lambdabot 
14:41:35 <redheadphones> if i use guards to match cases, and two matches call the same function, how can i avoid repeating myself and not type the function once for each each guard?
14:41:44 <kallisti> byorgey: I remember in the past I would try to break things into modules/functions etc before I even had an idea of what the big picture looked like.
14:42:01 <kallisti> so I spent more time rearranging things than actually producing anything useful.
14:42:03 <DanBurton> redheadphones: you can use a "let" or a "where"
14:42:22 <DanBurton> redheadphones: due to laziness, it won't be evaluted unless one of the guards is reached
14:42:38 <kallisti> also:
14:42:40 <kallisti> rqURI = fromJust $ relURI `relativeTo` baseURI
14:42:42 <dmwit> redheadphones: Use a where clause. Let won't help because it's scoped incorrectly.
14:43:02 <kallisti> I looked at the code of relativeTo, and couldn't find a case where it actually returns Nothing.
14:43:11 <kallisti> (it's from Network.URI)
14:43:12 <pozic_> Veinor: I don't like the endless series of sequences of symbols.
14:43:44 <pozic_> Veinor: words actually mean something without having to lookup some symbol which some library author thought looked cute.
14:43:47 <kallisti> but just to be safe I should probably remove that fromJust and handle errors.
14:44:11 <kallisti> pozic_: many libraries use english phrases that are intended to be infix operators
14:44:19 <DanBurton> oh those kind of guards. yeah use where
14:44:24 <kallisti> however, for important operators, the terseness of symbolic operators is useful.
14:44:37 <kallisti> and, in many ways, learning these libraries is like learning a small language of its own.
14:44:44 <redheadphones> i'm already using where to make the lhs of = more concise, but two calls (each with different args) give the same rhs.
14:45:07 <pozic_> Veinor: compare sequence |> element vs insert_at_beginning element sequence
14:45:09 <dmwit> redheadphones: Perhaps you had better paste some code.
14:45:11 <dmwit> ?hpaste
14:45:11 <lambdabot> Haskell pastebin: http://hpaste.org/
14:45:26 <pozic_> Veinor: I never remember whether it is |> or <| and what the argument order is.
14:45:44 <Veinor> pozic_: ok. now what do you replace (>>=) with?
14:45:46 <pozic_> (in fact, argument order is a good argument for a more powerful type system)
14:45:59 <pozic_> Veinor: monads already have do syntax.
14:45:59 <kallisti> pozic_: the arrow indicates that the value is going "into" the sequence.
14:46:08 <DanBurton> kallisti: yeah that is weird. I wonder why relativeTo produces a Maybe
14:46:18 <kallisti> DanBurton: perhaps to be future-proof
14:46:25 <kallisti> DanBurton: with some code change that makes Nothing possible?
14:46:29 <Veinor> also, the > points towards the smaller thing. because the sequence is 'larger' than the individual element
14:46:30 <hpaste> redheadphones pasted “guards” at http://hpaste.org/64997
14:46:49 <pozic_> Veinor: it doesn't matter how you remember it.
14:47:01 <pozic_> Veinor: fact remains that you need to remember bits of information.
14:47:17 <redheadphones> dmwit, the first two guards are what i'm talking about
14:47:25 <kallisti> learning? in programming? my god... what has the world come to.
14:47:26 <Veinor> ok, so is it insert_at_beginning element sequence or insert_at_beginning sequence element?
14:47:31 <DanBurton> kallisti: seems wrong to do that, if the package follows PVP then appropriate version changes should be all that is necessary to "future-proof" in that way
14:47:48 <pozic_> Veinor: you can keep that order consistent.
14:47:50 <dmwit> redheadphones: where sendMsgDrop = sendMsg src chan msgDrop
14:48:01 <kallisti> I could be biased however. I also program regularly in perl. :P
14:48:07 <pozic_> Veinor: choose one and stick to it for all data structures.
14:48:14 <dmwit> redheadphones: Or, perhaps, where send = sendMsg src chan, so that all of the first three clauses can use send. =)
14:48:21 <pozic_> kallisti: learning is inefficient.
14:48:31 <pozic_> kallisti: you want to be programming, not think about these things.
14:48:34 <Nereid> Veinor: I would prefer the first one.
14:48:40 <Nereid> but consistency > all.
14:48:46 <redheadphones> dmwit, wouldn't that still need to be broken up into different guards? i was looking to have one less guard.
14:48:54 <pozic_> kallisti: and by programming, I mean that you want to think about features that you are going to implement; the programming is easy.
14:48:55 <dmwit> redheadphones: Oh!
14:49:11 <dmwit> redheadphones: In that case, just use the guard | prefix "> :t" || prefix "> :i" = blah
14:49:20 <dmwit> redheadphones: I didn't understand what you wanted. =)
14:49:23 <DanBurton> @tell tibbe kallisti noticed that `Network.URI.relativeTo' produces a Maybe result, but the code doesn't seem to ever produce Nothing. What's up with that?
14:49:23 <lambdabot> Consider it noted.
14:49:37 <hpaste> theozaurus pasted “cabal install git-annex” at http://hpaste.org/64999
14:49:48 <kallisti> DanBurton: I could be wrong about the Nothing bit... I didn't read the entire source. Did you double check?
14:49:59 <DanBurton> I looked through the source
14:50:07 <theozaurus1> Hi guys, trying to get git-annex installed and working, but can't for the life of me figure out this error. Could anyone point me in the right direction?
14:50:10 <kallisti> it seems to cover every case without an error.
14:50:12 <redheadphones> dmwit, ah, makes sense, i was thinking there might be some sort of fall through thing, maybe in case
14:50:16 <DanBurton> not thoroughly, but enough to get the feeling that there was never a Nothing case
14:50:43 <kallisti> indeed.
14:50:44 <Veinor> pozic_: and hopefully anybody that implements applicative will do it so that (<*) executes the left action first
14:51:08 <DanBurton> @check \x y -> isJust $ Network.URI.relativeTo x y
14:51:09 <lambdabot>   Not in scope: `Network.URI.relativeTo'
14:51:11 <DanBurton> :(
14:51:12 <pozic_> Veinor: the hopefully part should be replaced with proof obligations ;)
14:53:09 <kallisti> pozic_: I think having the ability to define custom infix operators is excellent. I don't think particular cases of poor operator choice negate this, in much the same way that poor name choice doesn't mean that we should do without named variables.
14:53:28 <Veinor> pozic_: what, like compile-time checked proof obligations?
14:53:39 <pozic_> kallisti: sure, it should not be rejected.
14:54:05 <kallisti> I see your point about <| and |>
14:54:10 <kallisti> it would make more sense in my mind if they were flipped.
14:54:22 <kallisti> so that the arrow points to the sequence that the value is being pushed into.
14:54:29 <Veinor> meh
14:54:32 <Veinor> i like them the way they are
14:54:39 <Veinor> because the arrow points towards the smaller thing, like with < and >
14:54:46 <kallisti> yes.
14:54:47 <pozic_> In fact, I think I even introduced aliases for those functions.
14:55:04 <pozic_> It gets inlined anyway.
14:55:21 <Veinor> well sure i'd hope that introducing aliases doesn't affect performance
14:55:26 <kallisti> however other operators are great. for example, the (.=) operator in Aeson for defining key-value pairs.  object $ ["key" .= value, "key" .= value]
14:55:33 <kallisti> excellent choice. it greatly shortens code, and it looks nice.
14:55:49 <pozic_> kallisti: yes
14:55:58 <pozic_> Veinor: if you care about performance, you wouldn't use Haskell.
14:56:12 <pozic_> Veinor: Haskell is not really slow, but it isn't fast either.
14:56:32 <kallisti> I think if you care about performance "enough", you would use Haskell.
14:56:38 <kallisti> but not "too much"
14:56:45 <pozic_> Veinor: the only fast Haskell that exists uses lists to fuse loops if all the stars are aligned and Haskell that looks like C.
14:56:54 <Clint> i thought mighttpd2 outperformed nginx
14:56:55 <DanBurton> pozic_: fsvo "if you care about performance". Haskell is typically on the faster end of comparably "pretty" languages
14:57:09 <pozic_> DanBurton: that is true.
14:57:18 <pozic_> DanBurton: but OCaml performs even better then.
14:57:35 <pozic_> DanBurton: the Shootout has those nice graphs for that.
14:57:36 <DanBurton> true, ML is more oriented towards performance
14:57:51 <DanBurton> Haskell is more oriented towards sexy types
14:58:09 <kallisti> is there a faster lazy language than Haskell?
14:58:09 <pozic_> I think if you know ML, going to Coq is a small step.
14:58:13 <kallisti> non-strict I should say.
14:58:20 <pozic_> Same thing for Agda and Haskell, really.
14:58:30 <DanBurton> Haskell is basically the only serious non-strict language, imho
14:58:33 <kallisti> er, excuse me...
14:58:43 <pozic_> DanBurton: Clean was/is much faster.
14:58:44 <kallisti> is there a faster lazy language implementation than GHC?
14:58:51 <kallisti> my apologies.
14:58:59 <dmwit> Is there any other lazy language than Haskell?
14:59:04 <kallisti> yes.
14:59:08 <DanBurton> I get the impression that Clean is no longer maintained...is this true?
14:59:11 <Axman6> C: &&, ||
14:59:12 <Axman6> >_>
14:59:45 <DanBurton> Axman6: qed. C is a lazy language.
15:00:02 <Axman6> of course
15:00:06 <pozic_> DanBurton: completely false.
15:00:28 <tromp__> perl is lazy if you stick to lambda
15:00:29 <pozic_> DanBurton: in fact there is a company which accepts your money if you want support.
15:01:08 <pozic_> There exist Haskell <-> Clean compilers.
15:01:15 <kallisti> io has some facilities for lazy evaluation
15:01:16 <DanBurton> For purposes of conversation, let lazyLanguage = not strictByDefault
15:01:17 <kallisti> nothing fancy.
15:01:20 <pozic_> As such it isn't really interesting in which notation you write.
15:01:45 <tromp__> i meant perl using only sub and shift
15:02:32 <DanBurton> Does the Clean -> Haskell compiler just turn uniqueness typing into monads?
15:02:46 <pozic_> I have no idea.
15:03:17 <tromp__> Scala has support for laziness too
15:03:17 <hpaste> ClaudiusMaximus pasted “SoftFloat normalization performance” at http://hpaste.org/65000
15:03:21 <hpaste> DanBurton pasted “relativeTo always isJust” at http://hpaste.org/65001
15:03:40 <_Mikey> Hey, I'm having terrible problems getting the latest version of wxcore to install
15:03:53 <_Mikey> has anyone else had problems, on debian?
15:03:55 <ClaudiusMaximus> anyone any ideas for speeding up my thing?
15:03:55 <pozic_> _Mikey: contact whoever wrote it.
15:04:11 <_Mikey> ok
15:04:11 <pozic_> _Mikey: first read the documentation.
15:04:16 <pozic_> _Mikey: all of it.
15:04:20 <_Mikey> I've read it..
15:04:25 <pozic_> _Mikey: ok, then go ahead :)
15:04:28 <_Mikey> there are known problems with Debian
15:04:34 <_Mikey> but, there is a solution
15:04:40 <_Mikey> which doesn't seem to work
15:06:28 <lambdanaut> When moving over to a dynamic language like javascript/python/php, what do you guys generally use to replace Haskell's Data Types. Like in Haskell to represent the state a game character could be in, I'd make a "data State = Happy | Sad | Neutral".
15:06:41 <lambdanaut> In Javascript the best thing that comes to mind is strings :(!!
15:06:49 <Saizan> ClaudiusMaximus: add a bang to the _ pattern
15:07:15 <pozic_> lambdanaut: it depends on whether you want third party code to be able to add States.
15:07:28 <pozic_> lambdanaut: if not, that looks OK.
15:07:45 <Saizan> ClaudiusMaximus: also {-# UNPACK #-}  to the fields of SoftFloat
15:08:39 <Saizan> pozic_: he wants to get tagged unions in js/python/php
15:08:49 <pozic_> Saizan: my mistake.
15:09:40 <pozic_> lambdanaut: the heavy weight way is to create new classes for each case.
15:09:52 <pozic_> lambdanaut: depending on support for enumerations in the language.
15:11:01 <adit> lambdanaut: STATES = ["happy", "sad", "neutral"] or STATES = {:happy => 1, :sad => 2, :neutral => 3}
15:13:43 <ClaudiusMaximus> Saizan: ok, the extra bang made a small improvement (which surprised me), was alreading -funbox-strict-fields
15:16:42 <ClaudiusMaximus> Saizan: still too slow for my happiness, do you think fully unfolding the recursion and re-ordering into an if-tree or similar would be worth it at all? could get from 64 comparisons down to 12, maybe...
15:18:12 <ClaudiusMaximus> or maybe an unsafe FFI call to a C implementation...
15:19:15 <mhitza> hey guys, what infix should I set for my custom operator (that is basically a `flip $`) so it behaves like $ but on the left side?
15:19:42 <jedai> mhitza: do :info ($) in ghci
15:21:00 <alpounet> ClaudiusMaximus, any reason for not having put a bang on the "m" ?
15:21:05 <parcs`> mhitza: 0
15:21:37 <ClaudiusMaximus> alpounet: pattern matching against 0 in the previous clause not good enough?
15:21:44 <niteria> wow, ghc-mod sounds awesome, can't wait to try it
15:22:08 <alpounet> ClaudiusMaximus, well, it won't force m until it gets at that 0
15:22:09 <mhitza> thanks parcs` got the same with jedai's help
15:22:57 <ClaudiusMaximus> alpounet: isn't it, force m when comparing with 0 - if it doesn't match, fall through to next clause?
15:23:51 <ClaudiusMaximus> alpounet: or am i missing something - like GHC being magic and knowing that if 0 is not hit on initial entry it'll never be hit by a recursive call
15:23:58 <alpounet> oh, yeah, sorry, i'm tired
15:24:09 <alpounet> well, i must be.
15:24:11 <alpounet> you're right
15:24:36 <alpounet> ofc it forces it to compare it to 0
15:24:45 <mhitza> and is there a way for me to set the infix from ghci?
15:25:37 <jedai> mhitza: yes, but only when you declare it
15:26:12 <ClaudiusMaximus> thanks for looking - gonna try a C implementation, get a baseline target for what might be acheivable..
15:26:13 <mhitza> jedai declare what?
15:26:23 <mhitza> the function ?
15:27:05 <jedai> like "let infixl 0 >$; (>$) = flip ($)"
15:28:05 <jedai> mhitza: you can't declare your operator then declare its precedence (like you could in a file)
15:28:07 <mhitza> I see. Tried with :infixl and infixl but obviously a let is required :)
15:28:27 * hackagebot gtk2hs-buildtools 0.12.3 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.12.3 (DanielWagner)
15:31:39 <alpounet> ClaudiusMaximus, maybe looking at the core could give a hint
15:32:11 <Nisstyre> someone posed this golf challenge in ##programming, and I'm trying to do it in Haskell
15:32:13 <Nisstyre> you have two files, one small file s and one huge file h. write a oneliner or something likewise short that for each line l of s it produces a file named l that contains all lines of h that contain l.
15:32:24 <Nisstyre> so far I have let f = (<$>) lines . readFile in (\(a,b)-> [[d|d<-b, isInfixOf c d]|c<-a]) <$> liftM2 (,) (f "s") (f "h")
15:32:47 <Nisstyre> (the requirement to produce a file was dropped)
15:33:21 <hpaste> mhitza pasted “flipped application” at http://hpaste.org/65004
15:33:29 * hackagebot couchdb-conduit 0.6.0 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.6.0 (AlexanderDorofeev)
15:33:31 * hackagebot hmatrix-syntax 0.1.1 - MATLAB-like syntax for hmatrix vectors and matrices  http://hackage.haskell.org/package/hmatrix-syntax-0.1.1 (ReinerPope)
15:33:33 * hackagebot glib 0.12.3 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.12.3 (DanielWagner)
15:33:37 <mhitza> jedai, may I bother you with another question?
15:33:58 <jedai> this channel is intended for this :)
15:34:10 <mhitza> could you take a look at my paste?
15:34:16 <mhitza> :)
15:37:25 <dmwit> mhitza: :i will show you that ghci simply ignores fixity declarations.
15:37:38 <dmwit> mhitza: Stick it in a file.
15:38:00 <dmwit> mhitza: Bonus points if you file a bug on the GHC bug tracker. It should at the very least give you an error if it's going to ignore you. =)
15:38:27 * hackagebot gio 0.12.3 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.12.3 (DanielWagner)
15:38:30 * hackagebot cairo 0.12.3 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.12.3 (DanielWagner)
15:38:30 <mhitza> dmwit, thanks but I wouldn't be able to write a GHC bug report to save my life :D
15:38:37 <jedai> ... yes that is annoying. Do ghc 7.4 works the same ?
15:38:49 <jedai> since they improved on GHCI
15:39:26 <rasfar> did hackagebot just wake up from a siesta or what?
15:39:50 <dmwit> jedai: Yes, GHC 7.4 has the same annoyance.
15:40:01 <dmwit> rasfar: No, I just uploaded a lot of packages from a script.
15:40:15 <dmwit> And a few other people happened to upload at the same time. =)
15:40:37 <quintessence> Strange, it works in GHCi as let {infix ...} in and as do { let {infix ...}; blah } but not at the top level
15:40:37 <rasfar> :)
15:41:18 * DanBurton starts quietly chanting "bug report, bug report"
15:41:21 <jedai> dmwit: yes, I just found the ticket, milestone : 7.6.1...
15:41:31 <dmwit> jedai: Great, link us! I want to be CC'd on it.
15:41:41 <jedai> http://hackage.haskell.org/trac/ghc/ticket/2947
15:42:05 <dmwit> Opened 3 years ago.
15:42:18 <dmwit> About that milestone 7.6.1... I wouldn't hold my breath if I were you.
15:42:46 <jedai> yes, especially given the astonishing level of activity around the ticket...
15:43:02 <dmwit> At least they keep updating the milestone. =P
15:43:18 <dmwit> It's always a heartbreaker when you see something like "milestone: <the version that was released five years ago>"
15:43:31 * hackagebot pango 0.12.3 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.12.3 (DanielWagner)
15:43:34 * hackagebot gtk 0.12.3 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.3 (DanielWagner)
15:43:34 <jedai> the latest change was "priority changed from low to lowest "
15:43:36 * hackagebot isohunt 0.1.1 - Bindings to the isoHunt torrent search API  http://hackage.haskell.org/package/isohunt-0.1.1 (ReinerPope)
15:43:58 <Saizan> ClaudiusMaximus: i'm afraid those bit operations aren't compiled down to simple machine instructions
15:44:09 <alpounet> dmwit, so, that's the GHC 7.4 compatible gtk?
15:44:17 <dmwit> alpounet: It is!
15:44:25 <jedai> Nice :D
15:44:29 <alpounet> hah good
15:44:40 <dmwit> And also Windows-compatible.
15:44:44 <alpounet> now byorgey will have to wrap up his release of the new diagrams version
15:44:54 <dmwit> Still no guarantees about Mac compatibility, though. =P
15:45:00 <dmwit> (Anybody want to donate some hardware?)
15:45:39 <alpounet> i think you could get some volunteers from -cafe pretty easily
15:45:45 <DanBurton> dmwit: someday when I am wealthy...naw I still wouldn't donate a Mac. A Linux box, maybe.
15:46:10 <dmwit> gtk2hs is well-supported on all of the operating systems I can legally run. =)
15:46:11 <DanBurton> @google hackintosh
15:46:13 <lambdabot> http://www.hackintosh.com/
15:46:13 <lambdabot> Title: Hackintosh Instructions, Hackintosh How To Guides @ Hackintosh.com
15:46:16 <dmwit> Linux is one such. =)
15:46:16 <DanBurton> >.>
15:46:42 <tech2> DanBurton: not legal though (contract violation)
15:46:58 * DanBurton wonders if there exists some country in which it is legal
15:47:21 <DanBurton> Not that I care, really. Me and my ubuntu/xmonad are doing just fine
15:47:48 <tech2> if you can find one which excludes the contract owner from stipulating what hardware the OS is permitted to be installed on, mebbe.
15:48:09 <tech2> heh, I don't have a high enough res screen to make xmonad's tiles useful ;)
15:48:52 <DanBurton> even so, in that case just use the 9+ workspaces
15:50:01 <DanBurton> so I'm trying to log into trac.haskell.org/network/ but it is giving me an "internal error" error: (111, 'connection refused')
15:52:07 <DanBurton> is there some secret initiation rite I need to go through first? I just created an account today
15:53:06 <ClaudiusMaximus> Saizan: even the ffi-to-C version takes 23% of runtime, and allocates more than the haskell version - i think it's just that it gets called often (40M times in one brief test)
15:53:28 * hackagebot first-class-patterns 0.3.0 - First class patterns and pattern matching, using type families  http://hackage.haskell.org/package/first-class-patterns-0.3.0 (ReinerPope)
16:11:14 <dgpratt> does there already exist some function/IO action that will do a 'glob' pattern search of files? supposing not, would it make sense to do regex pattern matching on the output of getDirectoryContents?
16:12:39 <aristid> dgpratt: http://hackage.haskell.org/package/Glob ?
16:12:56 <Cale> I was about to post the same link
16:13:07 <Cale> Shell globbing isn't the same as regex matching
16:13:16 <dgpratt> aristid: thanks
16:13:35 <dgpratt> Cale: I know, but I could've solved this problem either way
16:15:49 <dgpratt> in any case, I can't explain why it didn't occur to me to look for this on Hackage :)
16:28:48 <ivanm> @remember dylukes I'm getting way more acquainted with the GHC build system than I'd like to be.
16:28:49 <lambdabot> Okay.
16:36:02 <otters> how would you take items from a list until item n is equal to item n - 1
16:38:10 <adit> map fst $ takeWhile (\(a, b) a!=b) (zip l (tail l))
16:38:14 <adit> err
16:38:18 <adit> a/=b
16:38:20 <adit> something like that
16:38:52 <kallisti> wow, I just wrote "real" Haskll code and didn't have to import Control.Monad
16:38:54 <kallisti> just Applicative.
16:39:13 <Enigmagic> hopefully you were using enough extensions to make up for it
16:39:16 <kallisti> yep.
16:39:22 <kallisti> not too many
16:39:25 <kallisti> {-# LANGUAGE GeneralizedNewtypeDeriving, FlexibleContexts,  TemplateHaskell, OverloadedStrings #-}
16:39:50 <Enigmagic> excellent
16:40:10 <kallisti> $ grep '^import' Main.hs | wc -l
16:40:12 <kallisti> 19
16:40:16 <kallisti> not too many imports.
16:40:18 <otters> adit: I need the item after that last one too
16:40:27 <dmwit> Haskell does have sort of an import complex.
16:40:29 <dibblego> @hoogle (a -> f b) -> (b -> c) -> a -> f c
16:40:30 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
16:40:30 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
16:40:30 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
16:40:38 <dmwit> Probably 25% of all the lines of Haskell I've ever written were imports.
16:40:54 <dmwit> But it feels like 50%.
16:41:12 <kallisti> dmwit: yes, for one thing it's not OO. so you don't have large string, array, list, hash table, etc  data structure libraries by default.
16:41:31 <kallisti> as you would in, say, Python.
16:42:01 <kallisti> Ruby in particular has a lot of junk lying around its classes.
16:42:03 <kallisti> as well.
16:42:05 <dmwit> I don't really think it's an OO vs FP thing.
16:42:26 <dmwit> You could easily have a Haskell with a significantly larger Prelude and coarser-grained modules than what we have now.
16:42:39 <rwbarton> import Control.*
16:42:43 <dmwit> There just seems to be a culture of fine-grained modules.
16:42:43 <kallisti> :(
16:42:53 <kallisti> yes, I have nothing wrong with lots of imports.
16:44:04 <kallisti> I don't think the current module system is perfect, either.
16:44:06 <kallisti> but it works sufficiently.
16:45:08 <kallisti> also, import Control.* is horrible. :P I like the current method, which is to compile a number of modules into a single virtual module.
16:45:28 <kallisti> as you're more likely to get what you actually need.
16:45:38 <kallisti> because the package designer has set up a friendly interface for you.
16:45:45 <kallisti> (in a perfect world)
16:47:25 <kallisti> you could probably compile a virtual module of some commonly used modules.
16:47:50 <BMeph> @type flip ((.).fmap)
16:47:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (f1 a) -> (a -> b) -> f (f1 b)
16:48:03 <BMeph> @type flip ((Prelude..).fmap)
16:48:04 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a -> f a1) -> (a1 -> b) -> a -> f b
16:48:25 <BMeph> dibbs: ^^ ? :)
16:48:29 <dibblego> yeah it's some fmaps, thanks
16:48:51 <kallisti> Control.Monad, Control.Applicative, Data.List, Data.Maybe, Data.Either, in particular. Control.Category would be nice but then you'd have to hide Prelude (.)
16:49:23 <kallisti> Data.Char, perhaps.
16:49:47 <kallisti> I think it would be better for the list to be exlusive rather than inclusive.
16:50:11 <kallisti> import VIPMods.  -- :P
16:50:17 <kallisti> -.
16:50:29 * BMeph wonders why, if it had to have the hideous name, that the Monoid folks didn't make it "mAppend" so that he wouldn't keep reading the thing as "map-pend"... ;/
16:50:58 <kallisti> BMeph: hold on I'll get the Monoid folks on the phone and ask them what's up.
16:51:24 * BMeph waits with bated breath for kallisti's magical phone to connect...
16:51:49 <kallisti> BMeph: I'm still waiting on Overture (the name I've created for an imaginary improved Prelude) to come out.
16:51:50 * RichyB scribbles kallisti on an apple.
16:52:04 <ddarius> @hackage Overture
16:52:05 <lambdabot> http://hackage.haskell.org/package/Overture
16:52:14 <kallisti> oh, seems I'm not so clever.
16:52:24 <kallisti> oh, 404
16:52:25 <kallisti> nevermind.
16:52:38 <dmwit> BMeph: Do what we do in xmonad and call it <+>
16:52:57 <kallisti> ++ would be good but lolPrelude
16:53:42 <parcs`> <> is a synonym for mappend in base 4.5
16:53:57 <kallisti> oh nice.
16:54:00 <BMeph> kallisti: "Not as clever as ddarius" is kind of like saying "drives slower than a NASCAR driver" - it's underwhelmingly humble. :)
16:54:18 <kallisti> BMeph: er, no, that's not what I meant.
16:54:26 * BMeph still hates that it's called "mappend"...
16:54:30 <kallisti> I thought someone had already created a package named Overture. so my choice of name wasn't too clever.
16:54:40 <kallisti> but, ala, 404.
16:54:42 <kallisti> *alas
16:55:03 <BMeph> kallisti: Then, you found out that his cleverness has cleverness... ;)
16:55:32 <kallisti> but yes, anyone with a good sense of what an improve Prelude should look like, please begin Overture. ;)
16:56:32 <kallisti> I guess the name Overture would suggest that it has a lot more "stuff" though.
16:58:28 <RichyB> Don't use Overture as the package name. There won't be enough consensus as to what should go in to a Prelude replacement to be able to settle on a *single* Overture package.
16:58:50 <rwbarton> Solution: import Overture.*
16:58:53 <RichyB> Instead use the namespace a little more. Overture.EighteenTwelve, Overture.WilliamTell...
16:59:06 <kallisti> well, if it's on Hackage, then you don't /need/ consensus. it's the package maintainers discretion.
16:59:25 <kallisti> I wasn't suggesting that Prelude be replaced.
16:59:38 <kallisti> just that a supplement existed, where you could hide Prelude and import it. similar to numeric prelude.
16:59:42 <RichyB> Nothing really wrong with the idea.
17:00:11 <RichyB> {-# LANGUAGE NoImplicitPrelude #-} and "import Overture.FlyingDutchman" at the top of the file. Perfectly sensible.
17:00:17 <kallisti> import Prelude (); import Overture    --tasty
17:00:27 <jfischoff> is there a package for working with collections of lenses?
17:00:36 <dibblego> data-lens
17:00:40 <ion> A real Prelude replacement would be called Prelude. Overture is just fine for what it is.
17:01:17 <ion> Oh, you weren’t talking about the actual Overture but a hypothetical other Overture.
17:01:26 <jfischoff> dibblego: I didn't see containers for a collection of lenses, I'll look again
17:01:34 <ion> https://github.com/isomorphism/Overture
17:01:48 <jfischoff> no wait, that's haskell 98, can't see that happening
17:01:49 <ion> cmccann should really upload that to Hackage.
17:01:51 <RichyB> Don't imported packages all share a single namespace?
17:01:58 <otters> this is a weird error
17:02:00 <kallisti> not quite.
17:02:05 <otters> > (3 :: Float) :: CReal
17:02:06 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
17:02:06 <lambdabot>         against infe...
17:02:17 <kallisti> RichyB: if you import them qualified then they exist within their own namespace.
17:02:27 <ion> How is it a weird error? How can a value have two types at once?
17:02:30 <dmwit> jfischoff: What do you mean by "collection of lenses"?
17:02:35 <RichyB> kallisti, Misphrased question. Let me try again.
17:02:40 <ion> I take it you want to convert a Float into a CReal? realToFrac.
17:02:43 <otters> ion: oh, I guess I don't understand
17:02:56 <kallisti> ion: oh look someone already thought of this.
17:02:57 <otters> um, types
17:03:11 <kallisti> otters: :: is not like a cast in C.
17:03:44 <kallisti> otters: it specifies the type of a value. it doesn't perform any conversion. You're trying to give one value two different types and GHC is saying "...whut?"
17:03:46 <RichyB> Package A defines a module called "Text", package B defines a different module called "Text". Package C uses the "Text" module from A, and package D uses the "Text" module from B.
17:03:54 <ion> (3, which is a Float), which is a CReal
17:04:01 <RichyB> (C and D themselves don't have any module name collisions)
17:04:09 <kallisti> RichyB: oh, no. packages can explicit export packages they import
17:04:14 <kallisti> RichyB: but it doesn't happen implicitly.
17:04:18 <RichyB> Can you compile and link a single program that imports both C and D?
17:04:28 <jfischoff> for a particular data types I might have lens Lens a b, and Lens a c, etc. Since they are heterogeneous types I think I will have to make a data type for each collection, but thought I would ask
17:04:48 <kallisti> RichyB: I believe the new standard provides a mechanism to distinguish packages
17:04:56 <kallisti> something like package:Module
17:04:58 <kallisti> I think?
17:05:12 <kallisti> maybe I'm mistaken. I've never actually seen it used.
17:05:21 <RichyB> (Semi plausible example: imagine an accidental collision between graphics libraries or parsing combinator libraries or something)
17:05:56 <kallisti> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#package-imports
17:05:59 <kallisti> here we are
17:06:01 <kallisti> import "packge" Module
17:06:06 <kallisti> *package      like that.
17:07:04 <RichyB> Neat.
17:07:10 <kallisti> RichyB: most packages use sane namespacing however.
17:07:14 <dmwit> kallisti: That does require some foreknowledge of collision, though, which seems to be at least part of the crux of RichyB's question.
17:07:15 <kallisti> so you don't need it much.
17:07:27 <kallisti> dmwit: I'm sure you'd realize soon enough.
17:07:41 <RichyB> dmwit, well, I'm used to languages like C and Python where you have no mechanism at all to deal with such issues.
17:08:04 <dmwit> No, the point is that package C (which uses package B) would have to know about completely unrelated (in fact, perhaps even competing) packages D and A.
17:08:05 <RichyB> C particularly. Name collision? You're slightly boned.
17:08:07 <kallisti> there's kind of a mechanism in Python, you could import by an explicit path.
17:08:07 <dmwit> That's really unfortunate.
17:08:48 <RichyB> kallisti, in practice the Python community will pelt you with popcorn if you do that in production software. :)
17:08:52 <kallisti> yep.
17:08:58 <kallisti> JUS' SAYIN'
17:09:35 <kallisti> dmwit: oh, is that we he meant? yeah there's no way to control that unless it uses package imports as well.
17:09:57 <RichyB> kallisti, offtopic, but if you're fluent in Python then I strongly recommend reading a/watching a presentation called "5 years of bad ideas". It's funny.
17:10:35 <kallisti> RichyB: huh, I see. it's a presentation about 5 years of bad ideas, but it's not talking about PHP not Python?
17:10:41 <notthemessiah> How would I make a special instance of showList for a new data type?
17:10:41 <kallisti> er
17:10:46 <dmwit> lolphp.reddit.com
17:10:47 <kallisti> talking about PHP, not talking about Python.
17:11:07 <RichyB> kallisti, it's the author's own admissions of things that he has written in Python which he feels were Bad Ideas because they were too magical.
17:11:15 <kallisti> oh.
17:11:21 <dmwit> notthemessiah: Best practice is simply to derive Show. Use a different class for non-machine-readable output.
17:11:49 <kallisti> notthemessiah: if you need to do so explicitly.   make an instance declaration:   instance Show MyType where showList = ...
17:12:17 <kallisti> but yes derive Show when you can.
17:12:26 <kallisti> (which is usually)
17:13:16 <RichyB> kallisti, Python exposes much of the interpreter's state and you can do "evil" things with that and write libraries that have *really* weird semantics. e.g. classes that, when instantiated and bound to a variable, magically know the name of the variable that they're referred to by.
17:13:17 <byorgey> dmwit++
17:13:18 <notthemessiah> ahh, I just wanted to do it so that way a list of a datatype has cleaner output on screen, with 1 character per item
17:13:32 * hackagebot gloss 1.6.2.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.6.2.1 (BenLippmeier)
17:13:44 <kallisti> RichyB: I'm aware of all of Python's magic
17:13:52 <kallisti> that's common place in many modern dynamically typed languages.
17:14:11 <dmwit> byorgey: I suppose that's for gtk-0.12.3? =)
17:14:35 <byorgey> dmwit: although there are many other things I might also ++ you for, yes =)
17:15:24 <kallisti> byorgey: did I show you my lasted code? I wanted to get an opinion on the overall structure.
17:15:29 <kallisti> before I split it up into modules.
17:16:17 <byorgey> kallisti: sorry, I don't really have time to look at it now.  If you paste it maybe someone else can take a look.
17:16:29 <kallisti> byorgey: not a problem.
17:16:50 <kallisti> enjoy. :P  http://sprunge.us/AiOE?haskell
17:18:07 <RichyB> dmwit, come to think of it, that is a nice side-effect to fall out of the fact that you have to explicitly import a package to be allowed to import modules from it. :)
17:20:55 <dmwit> What's the side effect again?
17:21:33 <kallisti> side effects? no side effects here..
17:23:48 <scooty-puff> is there a standard module naming convention for cabal test suites?
17:25:05 <kallisti> (something reasonable).Test  I think
17:25:42 <scooty-puff> k
17:30:09 <andares> hey, is there a way to define a type signature from ghci?
17:30:48 <kallisti> not entirely sure what you mean. but I don't think you can define data types, type synonyms, instances, etc.
17:31:01 <dmwit> andares: let foo :: bar; foo = baz
17:31:06 <andares> thanks dmwit!
17:31:15 <dmwit> andares: It's important that you give the type ascription and definition in the same let block.
17:31:22 <kallisti> oh that
17:31:38 <andares> beatiful. I'm really starting to like this language.
17:31:49 <kallisti> andares: or you can put a :: on any expression
17:31:58 <kallisti> let foo = baz :: Type
17:32:20 <andares> oh you can? can you do that in regular Haskell?
17:32:24 <kallisti> yep
17:32:31 <kallisti> > pi :: Double
17:32:31 <lambdabot>   3.141592653589793
17:32:34 <kallisti> > pi :: CReal
17:32:34 <DanBurton> something's wonky about this documentation http://hackage.haskell.org/packages/archive/QuickCheck/2.4.2/doc/html/Test-QuickCheck.html#t:Result
17:32:35 <lambdabot>   3.1415926535897932384626433832795028841972
17:33:01 <sipa> ha! pie is a cereal!
17:33:16 <sipa> *as
17:33:54 <kallisti> :t showCReal
17:33:55 <lambdabot> Int -> CReal -> String
17:34:00 <kallisti> > showCReal 1000 pi
17:34:01 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
17:34:04 <byorgey> DanBurton: ha, looks like the annotations on each field are getting copied to all the other fields with the same name
17:34:17 <byorgey> DanBurton: because after all, they are all the same function... =P
17:34:17 <kallisti> > last $showCReal 1000 pi
17:34:18 <lambdabot>   '9'
17:34:28 <DanBurton> byorgey: true point. That is super annoying, though.
17:34:43 <byorgey> oh, I'm not arguing it *should* do that!
17:34:54 <byorgey> this is clearly a Haddock bug
17:35:25 <byorgey> try building it with Haddock 2.10 or whatever the latest version is and see if you get the same thing
17:35:30 <kallisti> andares: it's occasionally necessary to explicit declare types on values that would otherwise be ambiguous.
17:35:45 <DanBurton> I'll give it a go
17:35:48 <kallisti> > read "2"
17:35:49 <lambdabot>   *Exception: Prelude.read: no parse
17:35:54 <kallisti> > read "2" :: Int
17:35:55 <lambdabot>   2
17:36:15 <kallisti> here it's not clear what you want to interpret "2" as
17:36:17 <kallisti> however:
17:36:20 <kallisti> > read "2" + 2
17:36:21 <lambdabot>   4
17:36:24 <dmwit> > read "1e6" :: Int
17:36:24 <kallisti> here it is.
17:36:24 <lambdabot>   1000000
17:37:15 <kallisti> andares: ^
17:37:20 <DanBurton> byorgey: yep same bug, using cabal haddock with cabal-install 0.13.3 and haddock 2.10.0
17:37:58 <andares> hm, I see.
17:38:24 <dmwit> > read "1e10000000" :: Integer
17:38:26 <DanBurton> is there an (ubuntu) linux command to open your default web browser to a given page?
17:38:27 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
17:38:33 * hackagebot couchdb-conduit 0.7.0 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.7.0 (AlexanderDorofeev)
17:38:37 <dmwit> That... worked better than expected.
17:38:43 <ivanm> DanBurton: where did you get that version of cabal-install from? only 0.10.4 is available on hackage...
17:38:49 <dmwit> DanBurton: gnome-open http://blah
17:38:57 <ivanm> *0.10.2
17:39:03 <DanBurton> ivanm: the darcs repo
17:39:07 <dmwit> DanBurton: Or $BROWSER http://blah
17:39:10 <ivanm> ahhh
17:39:27 <DanBurton> modular solver magicks ftw
17:39:41 <quintessence> Why does read "1e6" :: Int work but 1e6 :: Int doesn't?  Shouldn't they be equally permissive?
17:40:00 <byorgey> DanBurton: fair enough.  file a ticket!
17:40:17 <dmwit> quintessence: Weird, isn't it? =)
17:40:22 <ddarius> sensible-browser
17:40:39 <DanBurton> byorgey: do I have to make a ticket for every different project at trac.haskell.org?
17:40:43 <DanBurton> *an account
17:40:44 <dmwit> quintessence: Anyway, there's no particular connection between valid Haskell expressions and valid strings to pass to read, except by convention.
17:40:53 <byorgey> DanBurton: I'm not sure
17:40:54 <ivanm> quintessence: the former probably goes via fromInteger
17:41:09 <ivanm> wait, so would the latter
17:41:37 <dmwit> > read "1.0e6" :: Int
17:41:38 <lambdabot>   *Exception: Prelude.read: no parse
17:41:56 <quintessence> "No instance for (Fractional Int) arising from the literal `1000000.0'"
17:42:06 <DanBurton> ugh...trac hates me today
17:43:49 <ddarius> :t 1e6
17:43:50 <lambdabot> forall t. (Fractional t) => t
17:47:29 <blackdog> anyone know if there's a working twitter-with-oauth library in haskell?
17:49:09 <DanBurton> @google site:haskell.org twitter oauth
17:49:13 <lambdabot> http://hackage.haskell.org/packages/archive/yesod-auth/0.7.9/doc/html/src/Yesod-Auth-OAuth.html
17:49:13 <lambdabot> Title: Yesod/Auth/OAuth.hs
17:49:23 <DanBurton> hrm
17:49:24 <DanBurton> don't think so
17:49:33 <ion> I don’t see a reason for 1e6 not to be an Integral t => t. 4.2e6 should be Fractional t => t, of course.
17:49:54 <ion> Err. s/Integral/Num/
17:50:23 <blackdog> DanBurton: there's twitter-enumerator, but it wants an older authenticate, and i'm in cabal hell trying to get it working.
17:52:46 <adit> blackdog: try askitter
17:52:53 <adit> https://github.com/veinor/askitter
17:53:08 <Veinor> oh hey, that thing
17:53:33 * hackagebot egison 1.1.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.1.1 (SatoshiEgi)
17:53:35 * hackagebot mighttpd2 2.5.5 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.5 (KazuYamamoto)
17:53:39 <hpaste> nandares pasted “Euler8” at http://hpaste.org/65008
17:53:45 <blackdog> adit: cheers
17:53:48 <andares> hey guys. http://hpaste.org/65008
17:53:50 <zeiris> Does testing that '(f.g) x == x' also test that '(g.f) x == x'?
17:53:58 <adit> no
17:54:10 <andares> for the life of me I'm not able to figure out why it's not matching.
17:54:12 <parcs`> :t (%)
17:54:13 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
17:54:14 <andares> it fails at x:xs.
17:54:14 <parcs`> :t (^)
17:54:15 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
17:54:18 <dmwit> zeiris: Certainly not. One of those might not even be well typed.
17:54:38 <parcs`> :t 1 * 10^6
17:54:39 <lambdabot> forall t. (Num t) => t
17:54:45 <dmwit> andares: What if prod == n?
17:54:48 <parcs`> why isn't 1e6 just sugar for thatn
17:54:55 <adit> (odd . (+1)) 3 != ((+1) . odd ) 3
17:55:12 <dmwit> andares: a.k.a. why you should use "otherwise" instead of negating all the previous conditions
17:55:22 <andares> ah
17:55:51 <andares> dmwit: it's still failing to resolve take 5 (x:xs).
17:56:06 <Veinor> :t 1e6
17:56:06 <lambdabot> forall t. (Fractional t) => t
17:56:11 <dmwit> andares: "failing to resolve"?
17:56:20 <Veinor> parcs`: probably because of 1e-3
17:56:21 <andares>     Couldn't match expected type `[Char]' with actual type `Char'
17:56:26 <andares> could not match, rather.
17:56:38 <adit> how are you calling the function?
17:56:49 <dmwit> :t foldl
17:56:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:56:52 <andares> adit: I'm not. I'm just trying to compile it.
17:56:57 <quintessence> andares: you're missing an argument to foldl
17:57:08 <dmwit> andares: Take a look at foldl's type again.
17:57:26 <andares> ohhh. darn it. these errors are confusing.
17:59:09 <andares> odd. that did not fix it.
17:59:43 <andares>         where prod = foldl (*) 1 (fmap (\k -> read k) (take 5 (x:xs)))
18:00:35 <andares> still won't match [Char] with Char in the x of x:xs
18:00:40 <parcs`> :t (^^)
18:00:40 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
18:00:44 <parcs`> o
18:01:59 <JoeyA> When a foreign import is a pure function, does GHC automatically insert unsafePerformIO internally?
18:02:08 <dmwit> yes
18:02:10 <JoeyA> Or does it treat it differently than an impure function?
18:02:13 <ddarius> If you give it a non-IO type, yes.
18:02:18 <DanBurton> andares: `(\k -> read k)' is the same as `read'
18:02:30 <JoeyA> unsafePerformIO, not unsafeDupablePerformIO, correct?
18:02:32 <andares> hm, I see. but why won't it work?
18:02:40 <ddarius> Actually, not unsafePerformIO.
18:02:41 <dmwit> andares: read operates on String.
18:02:50 <dmwit> andares: map read operates on [String], therefore
18:02:56 <dmwit> andares: (x:xs) is String, not [String]
18:03:04 <DanBurton> > foldl (*) 1 (fmap read (take 5 "12345678"))
18:03:06 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:03:06 <lambdabot>         against inferred ty...
18:03:20 <dmwit> andares: Perhaps you would like digitToInt or read . return
18:03:22 <dmwit> :t digitToInt
18:03:22 <lambdabot> Char -> Int
18:03:25 <dmwit> :t read . return
18:03:25 <DanBurton> > foldl (*) 1 (fmap digitToInt (take 5 "12345678"))
18:03:26 <lambdabot> forall a. (Read a) => Char -> a
18:03:26 <lambdabot>   120
18:03:50 <DanBurton> @src digitToInt
18:03:51 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:03:57 <andares> dmarkey: I don't have digitToInt on my haskell.
18:03:59 <dmwit> andares: Additionally, you may enjoy the following functions: product, maximum, zip
18:04:06 <DanBurton> andares: digitToInt is from Data.Char
18:04:09 <dmwit> ?index digitToInt
18:04:09 <lambdabot> Data.Char
18:04:12 <andares> dmwit: thank you!
18:04:27 <andares> how would (read . return) solve it though?
18:04:38 <dmwit> > read . return $ '1' :: Int
18:04:40 <lambdabot>   1
18:04:56 <DanBurton> return can turn 'c' into "c"
18:05:08 <andares> oh, is that what that does? interesting.
18:05:13 <andares> it uses monads?
18:05:30 <dmwit> Just one monad: the list monad.
18:05:33 <DanBurton> it just uses the list monad definition of return
18:05:39 <DanBurton> you could equivalently use "pure"
18:05:43 <DanBurton> > read . pure $ '1' :: Int
18:05:45 <lambdabot>   1
18:05:50 <dmwit> or (:[]), or half a dozen other spellings
18:05:53 <andares> hrm.. I need to read up on return.
18:06:04 <dmwit> > read . (\x -> [x]) $ '1' :: Int
18:06:06 <lambdabot>   1
18:06:16 <dmwit> Congratulations, you now understand what return does in the list monad. =)
18:07:07 <BMeph> Does that mean we're "BroNads" now? ;)
18:07:15 <DanBurton> andares: I recommend reading LYAH chapters about Functor, Applicative, and Monad, and then read Typeclassopedia
18:07:16 <adit> o.O
18:07:34 <ddarius> BMeph: No.
18:08:01 <dmwit> psh, ddarius is just a regular ol' "nonad"
18:08:18 * dmwit brofists BMeph
18:08:59 * BMeph Loves and Tolerates his Bronads... o.O
18:09:36 * DanBurton can't decide whether to try and make a joke or steer the discussion back on topic
18:10:33 * BMeph shakes his head; sorry, steer have no bronads. ;)
18:10:59 <eyu> where did the System module of Haskell 98 go?
18:11:14 <eyu> I'm trying to remove ministg's dependency on the haskell98 package
18:11:21 <eyu> since it doesn't work anymore
18:11:29 <dmwit> eyu: Ask about a specific function instead of a module.
18:11:45 <dmwit> eyu: And phrase your question in the following way: "?index <functionname>"
18:11:51 <eyu> k, makes sense. I'll just remove the import and see where the errors pop up
18:11:53 <eyu> ^^ thanks
18:13:09 <eyu> ?index exitFailure
18:13:09 <lambdabot> System.Exit
18:13:36 <eyu> ?index getArgs
18:13:36 <lambdabot> System.Environment
18:17:07 <otters> :src on
18:17:10 <otters> crap
18:17:10 <otters> @src on
18:17:11 <lambdabot> (*) `on` f = \x y -> f x * f y
18:26:11 <eyu> > reverse "bleminu"
18:26:12 <lambdabot>   "unimelb"
18:37:22 <hpaste> asdf pasted “asdf” at http://hpaste.org/65010
18:37:50 <randomclown> Why does it say "not in scope: data constructor `Writer'"?
18:37:51 <randomclown> http://hpaste.org/65010
18:38:02 <randomclown> I'm using an example from learnyouahaskell
18:38:12 <ivanm> randomclown: in logNumber, you probably want runWriter
18:38:15 <ivanm> or something like that
18:38:17 <ivanm> no, wait
18:38:28 <ivanm> randomclown: don't use Writer like that
18:38:51 <randomclown> then how
18:39:10 <ivanm> @hoogle runWriter
18:39:10 <lambdabot> Control.Monad.Trans.Writer.Lazy runWriter :: Writer w a -> (a, w)
18:39:10 <lambdabot> Control.Monad.Trans.Writer.Strict runWriter :: Writer w a -> (a, w)
18:39:11 <lambdabot> Control.Monad.Writer.Lazy runWriter :: Writer w a -> (a, w)
18:39:36 <ivanm> oh, wait, I get it now
18:39:49 <randomclown> Why does it say "not in scope: data constructor `Writer'"?
18:39:50 <ivanm> logNumber x = tell $ ["Got number: " ++ show x]
18:39:52 <ivanm> @type tell
18:39:53 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
18:39:58 <ivanm> randomclown: because there's no such constructor!
18:40:00 <ivanm> use tell ^^
18:40:07 <mauke> there used to be
18:40:15 <randomclown> right I see
18:40:31 <mauke> randomclown: try WriterT instead
18:40:46 <mauke> oh wait
18:40:54 <mauke> probably a type error
18:41:50 <ion> @type writer
18:41:51 <lambdabot> forall a w. (a, w) -> Writer w a
18:42:44 <randomclown> so what's the corect way to write the example in http://learnyouahaskell.com/for-a-few-monads-more
18:42:53 <randomclown> in the section "Using do notation with Writer"
18:43:13 <ivanm> huh, LYAH has something wrong? :/
18:43:32 <randomclown> could'nt match expected type Int with actual type ()
18:43:36 * hackagebot xturtle 0.1.5 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.5 (YoshikuniJujo)
18:43:40 <ion> randomclown: Change “Writer” to “writer” in the definition (but not the type) of logNumber.
18:43:41 <ivanm> randomclown: then use return after the tell
18:43:47 <maloi> will import Control.Monad.Writer.Lazy not help?
18:43:48 <kallisti> or void
18:43:49 <ivanm> preflex: seen BONUS
18:43:49 <preflex>  BONUS was last seen on #haskell 313 days, 7 hours, 15 minutes and 50 seconds ago, saying: yeah i think that's better as well
18:44:02 <ivanm> maloi: no, because C.M.W just re-exports .Lazy
18:44:15 <ivanm> randomclown: or use writer (not capitalised)
18:44:23 <ivanm> or is that the new one that just got added?
18:45:05 <randomclown> can you annotate http://hpaste.org/65010 with the correct version?
18:45:08 <randomclown> I'
18:45:17 <randomclown> not sure what do you mean
18:45:40 <ion> logNumber x = writer (x, ["Got number: " ++ show x])
18:47:03 <randomclown> right ty
18:47:09 <kallisti> hm, wait, why isn't Writer working?
18:47:37 <kallisti> :t Writer
18:47:38 <lambdabot> Not in scope: data constructor `Writer'
18:47:46 <kallisti> :t runWriter
18:47:47 <lambdabot> forall w a. Writer w a -> (a, w)
18:47:49 <ion> It’s no longer a data constructor; the Writer type is an alias to WriterT Something now.
18:47:55 <kallisti> ah right
18:48:03 <kallisti> so you could just add a return.
18:48:19 <kallisti> and use WriterT
18:48:29 <kallisti> but writer is probably clearer.
18:50:13 <kallisti> it's no good trying to explain monad stacks when you're just now going over some basic monads.
18:51:56 <aavogt> there are lowercase constructors provided
18:52:00 <aavogt> @ty writer
18:52:01 <lambdabot> forall a w. (a, w) -> Writer w a
18:52:39 <aavogt> oh that one did get mentioned
18:55:19 <kallisti> :t WriterT
18:55:20 <lambdabot> forall (m :: * -> *) a w. m (a, w) -> WriterT w m a
18:56:30 <sam6> Anybody familiar with bit reversal permutation?
18:57:06 <sam6> I have a code here http://hpaste.org/65011
18:57:36 <sam6> But I want to run in on large lists so I'm not sure if I can do it any faster because concatenation is expensive
19:01:32 <sam3> Hi
19:01:47 <kallisti> sam3: Data.Sequence has slightly better efficiency on concatenations I believe.
19:02:01 <kallisti> sam3: it's O(log(min(n1, n2)))
19:02:06 <kallisti> where n1 and n2 are the two sequences
19:02:40 <kallisti> http://hackage.haskell.org/packages/archive/containers/0.4.2.1/doc/html/Data-Sequence.html
19:02:53 <kallisti> if your data is fixed size you could use an array type. but it appears as though it's not fixed.
19:03:10 <sam3> it is not fixed size...
19:03:21 <sam3> I guess it is just the concatenation that is expensive right?
19:03:36 <kallisti> well it's compounded by the use of evens and odds
19:04:00 <byorgey> you could use a difference list representation to speed up the concatenation
19:04:11 <tgeeky> sam3: can you split the list arbitrarily?
19:04:13 <wagle> K combinator is bad for global warming: http://www.physorg.com/news/2012-03-landauer-dissipated-memory-erased.html
19:04:48 <byorgey> sam3: http://hackage.haskell.org/package/dlist
19:04:58 <kallisti> yes dlist might be worthwhile
19:05:56 <tgeeky> byorgey: I mention ^^, because aren't evens and bitrev, for that matter, list homomorphisms?
19:05:56 <edwardk> preflex: xseen copumpkin
19:05:56 <preflex>  copumpkin was last seen on freenode/#haskell-blah 43 minutes and 10 seconds ago, saying: dylukes: okay, still isn't done :)
19:07:27 <edwardk> wondering how expensive a terribly unsafe foreign prim fieldNo :: a -> Int# -> b would be
19:07:36 <tgeeky> byorgey: and I think both even/odd can be folded left and right, so the third list homomorphism thm. should apply
19:07:48 <blackdog> Veinor: having a look at askitter - is there a way to use a pre-prepared oauth verifier?
19:08:10 <blackdog> ie, our users have already gone to the twitter auth page, and we've got the results from that.
19:09:14 <edwardk> basically i want data V4 a = V4 a a a a -- but I want to be able to super-cheaply index it by an Int sans case cost
19:09:34 <edwardk> and I don't want a useless pointer between me and my data
19:09:52 <mauke> V4 !a !a !a !a
19:10:11 <Veinor> blackdog: oh, hm
19:10:29 <tgeeky> mauke: he wants :: a -> Int# -> b
19:10:31 <edwardk> mauke: thats not the cost i care about
19:10:42 <blackdog> (background: i have an existing ruby app i'd dearly love to run in haskell instead:)
19:11:03 <edwardk> mauke: but if it makes you feel better
19:11:05 <Veinor> i'm not sure actually, i haven't touched askitter code in ages
19:11:11 <ion> ruby2haskell <foo.rb >foo.hs
19:11:16 <Veinor> haha
19:11:38 <edwardk> guess it can't be too bad as a foreign prim
19:11:43 <edwardk> going to go write it =P
19:11:44 <JoeyA> Why does Foreign.ForeignPtr have {-# OPTIONS_HADDOCK hide #-} now?
19:11:52 <sam3> tgeeky: sorry but can you explain to me a little bit about list homomorphisms?
19:12:28 <tgeeky> sam3: http://www.iis.sinica.edu.tw/~scm/2008/constructing-list-homomorphism/
19:13:10 <JoeyA> Oh, it's now in http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-ForeignPtr-Safe.html
19:14:09 <byorgey> tgeeky: evens is not a list homomorphism.
19:14:32 <byorgey> tgeeky: evens [1,2,3,4] /= evens [1,2,3] ++ evens [4]
19:14:52 <byorgey> bitrev isn't either.
19:15:08 <Veinor> blackdog: it might be possible if you dive into the hoauth module
19:16:30 <tgeeky> sam3: see, my premise was totally, 100% incorrect! learning!
19:16:56 <blackdog> Veinor: righto, i'll check hoauth out
19:17:12 <ion> What’s evens? filter even? map snd . filter (even . fst) . zip [0..]?
19:17:14 <byorgey> oh, what I said isn't quite right, the RHS doesn't have to be ++, but there is obviously no operator +++ such that  evens [1,2,3,4] == evens [1,2,3] +++ evens [4]
19:17:24 <byorgey> ion: the latter
19:17:56 <edwardk> guess the main cost would be that it can't be inlined as well
19:18:00 <mauke> byorgey: const?
19:18:03 <edwardk> or at all
19:18:50 <byorgey> oh, sorry, I was thinking 1-indexed for some reason.  consider  evens [1,2,3,4] == evens [1] +++ evens [2,3,4]  then
19:18:58 <Elemir> Guys, is there nice unicode symbol for (>>=)?
19:19:21 <kallisti> nope.
19:19:33 <Elemir> =(
19:19:39 <ion> Not for that either.
19:19:45 <andares> hey, is it possible to put a where inside of a list comprehension?
19:19:52 <byorgey> unicode sad face
19:20:07 <tgeeky> byorgey: hahaha. near spit-take.
19:20:08 <Enigmagic> edwardk: does the compiler support inlining any primops written in cmm?
19:20:13 <eyu> > zipWith (,) [1] []
19:20:14 <lambdabot>   []
19:20:17 <Enigmagic> (i was thinking no)
19:20:18 <byorgey> andares: no.
19:20:22 <edwardk> Enigmagic: no
19:20:24 <byorgey> andares: you can put a let, though.
19:20:26 <edwardk> hence my aside =)
19:20:28 <ion> > [ let a = b where { b = 42 } in a | c <- [0..5] ]
19:20:29 <lambdabot>   [42,42,42,42,42,42]
19:20:38 <tgeeky> byorgey: It turns out I didn't read the code carefully, and just looked at the type signatures (seeing [x] -> [x]) and thinking it was arithmetic evens and odds
19:20:52 <byorgey> tgeeky: aha.
19:21:06 <Enigmagic> edwardk: now if ghc just had lto/ltcg support ...
19:21:09 <byorgey> tgeeky: I agree 'filter even' is a list homomorphism =)
19:21:24 <tgeeky> byorgey: and filter odd, and hence (filter even) ++ (filter odd) should be too :o
19:21:29 <sam3> I am looking at DLists, but is conversion from and to DLists cheap?
19:21:34 <andares> ooh cool.
19:21:38 <andares> wait, what does {} do?
19:21:42 <mauke> Elemir: visually similar: ⤚➵➳➼⤜⤔
19:21:45 <tgeeky> sam3: it should tell you the cost in the documentation?
19:22:09 <tgeeky> sam3: nope, it doesn't say.
19:22:14 <byorgey> tgeeky: not so sure about that last step...
19:22:15 <Enigmagic> edwardk: i have managed to inline primops written in C into Haskell with llvm as a proof of concept though
19:22:29 <edwardk> *nods*
19:22:51 <edwardk> i have a whole tracing jit for that purpose, just no time to work on it ;)
19:22:52 <byorgey> andares: it just groups things in a block.  you probably don't want to use something like what ion wrote.
19:23:09 <byorgey> andares: you can put 'let' on the right-hand side.  like so:
19:23:22 <mauke> ion, byorgey: "WHITE FROWNING FACE", "CRYING FACE"
19:23:23 <scooty-puff> ok this is probably very pedantic, but i'm basically using tuples for type safety in heterogeneous lists - should the first or second entry be used as the head?
19:23:36 <byorgey> > [x | y <- [1..10]; let x = y*3 + 6; x > 15]
19:23:37 <lambdabot>   <no location info>: parse error on input `;'
19:23:40 <mauke> ☹ and 😢
19:23:44 <edwardk> erm, how the heck do you force a thunk in c--, not sure i have had to
19:23:54 <scooty-puff> (a, (b, ()) or (((), b), a)
19:23:55 <byorgey> > [x | y <- [1..10], let x = y*3 + 6, x > 15]
19:23:56 <lambdabot>   [18,21,24,27,30,33,36]
19:24:04 <edwardk> can't think of a nice example off hand
19:24:15 <scooty-puff> i'm leaning towards the latter because the functor instance makes more sense
19:24:30 <ion> (☹) = (>>=)
19:24:45 <byorgey> scooty-puff: the functor instance seems pretty useless to me.
19:25:04 <byorgey> scooty-puff: I'd go with the former because it corresponds to the way normal homogeneous lists work.
19:25:51 <byorgey> scooty-puff: the only time I'd use the latter is when encoding typechecking contexts, since those are traditionally represented as snoc-lists
19:25:53 <scooty-puff> byorgey, k - so how i'm using them, it will obviously be finite, and not very long, but i'd prefer to void n lookups, if i use !, UNPACK, and SPECIALIZE well, will it help with that?
19:26:12 <byorgey> scooty-puff: I have no idea.
19:26:21 <scooty-puff> byorgey, typechecking contexts?  i can infer the definition, but am otherwise not certain
19:26:56 <scooty-puff> byorgey, the statement on lookup would be for user (me) defined tuple-like type
19:26:59 <byorgey> scooty-puff: e.g. a list of in-scope variables along with their types that you carry along while type checking a term
19:27:20 <mauke> scooty-puff: are you writing a type checker?
19:27:44 <scooty-puff> mauke, a compiler - this would be for the symbol table entries, as well as elsewhere
19:27:51 <Enigmagic> edwardk: maybe stg_ap_v ?
19:28:04 <edwardk> Enigmagic: thanks.
19:28:16 <scooty-puff> would be like HasFreeVars a, HasCallSet a => a, where "a" would often be (FreeVars, (CallSet, ())
19:28:27 <tgeeky> byorgey: ooh! I never saw this paper: http://takeichi.ipl-lab.org/~hu/pub/pldi07.pdf
19:28:47 <scooty-puff> the actual representation i'm not a fan of, but i do like being able to use type class constraints to make it safe to know where i can rearrange phases
19:30:01 <byorgey> tgeeky: nice
19:30:28 <tgeeky> byorgey: I bet, if I check carefully, I should have already found that paper by citation tracing in the third list homomoprhism thing I thought I had processed already
19:30:46 <byorgey> tgeeky: why bother? you've found it now, haven't you? =)
19:30:57 <tgeeky> byorgey: hehe :)
19:31:41 <edwardk> gah, i think i'll do the forcing in haskell before calling the primop. otherwise i need a return frame, etc.
19:32:14 <tgeeky> byorgey: I need to master this third-list stuff. It seems like a wonderful hammer which is lacking nails.
19:32:25 <dibblego> http://paste.pocoo.org/show/563161/ why doesn't GHC warn me here? I always thought it would (perhaps it once did?)?
19:32:32 <byorgey> tgeeky: hehe
19:33:05 <byorgey> dibblego: it does not and never has.
19:33:22 <dibblego> hrm, might have been a different language then, cheers
19:33:49 <byorgey> dibblego: it has been discussed.  But as I recall it can get arbitrarily complicated deciding when to warn.
19:33:58 <dibblego> yeah I can imagine
19:34:03 <tgeeky> byorgey: edwardk: one sentence on why using DList as adefault list implementation would be annoying?
19:34:08 <andares> is there a way to put multiple things in a let?
19:34:17 <edwardk> tgeeky: O(n) head
19:34:20 <tgeeky> extra credit if you can form one sentence about it together, without collaboration
19:34:35 <dibblego> andares: sure, just separate them by a line or semi-colon
19:34:59 <andares> thanks.
19:35:01 <edwardk> tgeeky: its really really expensive to get stuff out of it then put it back together longer
19:35:03 <byorgey> ...is slow
19:35:04 <tgeeky> edwardk: ok, fine, the default list type will be (LeftDList, (), RightDList)
19:35:13 <tgeeky> byorgey: you cheated!
19:35:34 <edwardk> great! even worse
19:35:34 <byorgey> tgeeky: you can't prove I had already read edwardk's commend
19:35:38 <byorgey> *comment
19:35:38 <tgeeky> byorgey: so you'll have an O(1) tail and an O(1) liat
19:35:58 <andares> inside of a list comprehension, dibblego?
19:35:58 <tgeeky> byorgey: I can easily prove that you could have (using c)
19:36:03 <edwardk> in general if you ever need to use the list twice, DLists fall down on the job
19:36:22 <edwardk> since they have to reproduce it and don't get sharing
19:36:26 <edwardk> its the same with codensity, etc.
19:36:32 <tgeeky> edwardk: so it's like playing jenga by never stopping the building phase?
19:36:45 <edwardk> so this isn't a TERRIBLE fault, its just one that makes it so that you don't want to make it the default
19:36:50 <edwardk> yeah
19:37:01 <edwardk> DLists are fine as long as you never look at the list except once at the end
19:37:09 <edwardk> Codensity is the same way
19:40:14 <tgeeky> edwardk: that statement seems so damning to me.
19:41:34 <edwardk> well, with things like Show you really don't look at it except at the end
19:41:41 <edwardk> hence why we use DLists in show
19:43:48 <sam3> in haskell is there a flag that simply gives you the time the program runs?
19:43:54 <tgeeky> edwardk: FYI, I had to do some work (patch! to cabal-dev) to make git-annex compile, but got it today so ETA ~ 5 days
19:43:58 <sam3> I want to use it to see how fast my code runs
19:44:17 <edwardk> tgeeky: np. appreciated =)
19:44:24 <tgeeky> sam3: there are several ways to get the time, the easiest (probably) is the unix command
19:45:03 <tgeeky> sam3: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html <-- bookmark this page
19:45:58 <tgeeky> sam3:  :set +s -- in ghci would also do the trick
19:46:31 <tgeeky> sam3: and then, there's http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
19:48:38 * hackagebot couchdb-conduit 0.7.1 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.7.1 (AlexanderDorofeev)
19:49:07 <tgeeky> man.. with all these conduit releases recently... how long until someone makes a conduit-conduit
19:50:10 <ion> with unsafeCoerce
19:52:53 <edwardk> how do you pass a polymorphic argument to a foreign import prim?
19:53:06 <edwardk> I get an error about "Unacceptable type"
19:53:19 * shapr squashes edwardk's type and gives it mono
19:53:33 <edwardk> tried that. mono is also unacceptable ;)
19:53:55 <shapr> Not even a monomorphic type?
19:54:17 <monochrom> does a foreign import prim even allow polymorphism?
19:54:32 <shapr> Man, my discrete math teacher told us that recursion is inherently less efficient. I asked her about tail call recursion and she just looked at me confusedly.
19:54:47 <ion> hah
19:55:14 <edwardk> monochrom: i have no idea
19:55:24 <shapr> But she's mentally inflexible so I'm not going to, um, update her knowledge she's either failed me out, or I actually pass. (She seems to enjoy trying to fail her students out of her classes.)
19:55:28 <monochrom> discrete math teacher is unqualified to opiniate on practical efficency
19:55:30 <edwardk> monochrom: it appears i can't seem to pass it anything of kind *
19:55:39 <edwardk> even if i fix the type to be (), etc.
19:55:46 <edwardk> i get the same error
19:55:48 <hpaste> drbean pasted “Using other functions defined in a where clause in a map.” at http://hpaste.org/65012
19:56:08 <edwardk> this might put a serious damper on my plans =(
19:56:16 <shapr> monochrom: Yup, I agree. But she teaches several classes necessary to the completion of a CS degree. For example, asm (System 360) and Software Engineering (waterfall is the big new thing).
19:56:39 <monochrom> asymptotic efficiency, sure, a discrete math teacher knows that well. the constant factor, no, a discrete math teacher is totally ignorant
19:57:21 <monochrom> how old is that teacher?
19:57:22 <shapr> I think she's soon to be upgrading the SE class to CMMI
19:57:37 <shapr> monochrom: Her daughter is also a math teacher in the same department, and has her own kids.
19:57:53 <ion> who are also math teachers in the same department
19:57:55 <monochrom> that may be 50 or 60+
19:58:01 <timemage> ion, heh
19:58:04 <monochrom> hahaha ion
19:58:38 * hackagebot couchdb-conduit 0.7.2 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.7.2 (AlexanderDorofeev)
19:58:43 <monochrom> in contrast, Tony Hoare is approaching 80 and still more up-to-date than most 60ers
19:59:13 <ion> Is that pronounced like whore?
19:59:20 <shapr> I've often wondered that.
19:59:24 <monochrom> yes, unfortunately
19:59:26 <ion> nice
19:59:53 <monochrom> anyway, you'll be amazed by how many people write-protect their brains at 21
20:00:03 <shapr> Many of my classmates, in fact.
20:00:40 <shapr> But there are a few that are really looking for the awesome in CS.
20:01:08 * eyebloom likes the phrase "write protected brain".
20:01:09 <edwardk> bah this would appear to be a feature request to get implemented =(
20:01:12 <monochrom> my https://plus.google.com/102208456519922110915/posts/6yqnZ3XoP7K has how to write-protect your 5.25" floppies!
20:02:49 <drbean> I'm creating a triple in a map, and I want to use the first element in a function defining the second in a where clause in the definition of the map.
20:03:12 <blackdog> shapr: almost up to 100k on kickstarter:)
20:03:27 <blackdog> marcus is at launch, and i'm at home rewriting my shitty ruby into slightly-less-shitty haskell.
20:03:30 <shapr> blackdog: w00t!
20:03:38 * hackagebot shapely-data 0.0 - Template haskell conversion of types to a "structural form" built from primitive sum, product, and unit types.  http://hackage.haskell.org/package/shapely-data-0.0 (BrandonSimmons)
20:03:40 * hackagebot indexed 0.1 - Haskell98 indexed functors, monads, comonads  http://hackage.haskell.org/package/indexed-0.1 (ReinerPope)
20:03:42 * hackagebot indexed-extras 0.1 - Indexed functors, monads and comonads that require extensions to Haskell98  http://hackage.haskell.org/package/indexed-extras-0.1 (ReinerPope)
20:03:55 <shapr> blackdog: sadly, I'm just too poor :-(
20:04:41 <blackdog> it's ok mate. it's largely aimed at time-poor but wealthier people anyway.
20:04:59 <blackdog> or those who couldn't program an arduino if their life depended on it
20:05:02 <shapr> I'm both time and money poor at the moment. But actually enjoying learning trig after all...
20:05:24 <shapr> And enjoying my discrete math class as much as the instructor is trying to spoil it.
20:05:57 <shapr> After the section on number bases I asked about base fibonacci and base prime and she totally shut me down.
20:08:20 <shapr> The section on mathematical induction made for fun Haskell code.
20:11:47 <rasfar> trouble with math courses is lack of projects, so you get creative of assignments where the prof is really looking for a particular answer/technique.
20:12:13 <rasfar> makes me appreciate the engineering side of cs
20:13:21 <shapr> I do wish my math courses used a proof assistant or something.
20:13:23 <edwardk> ok, giving up on the foreign prim. would have been really nice
20:13:32 <shapr> Then I could sort of write code while sort of doing math.
20:13:50 <edwardk> just use the proof assistant and try to follow along
20:13:51 <edwardk> ;)
20:18:39 * hackagebot couchdb-conduit 0.7.3 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.7.3 (AlexanderDorofeev)
20:19:39 <savask> Hello. How can I know with cabal which packages need updating? Or I must check them all by hand?
20:20:54 <monochrom> you are better off checking and choosing by hand. not all packages are supposed to be updated (unless you change GHC altogether)
20:22:26 <savask> So, there is no way to know if a package has a newer version without checking it myself?
20:24:32 <andares> is there a way to define a list over multiple lines in haskell?
20:24:48 <andares> like something like python's \ where it sees the next line as part of the current line?
20:25:08 <rasfar> so long as the offside rule is respected you can do it
20:25:16 <andares> offside rule?
20:25:28 <rasfar> let xs = [ 1, 2, 3,
20:25:38 <rasfar>             4, 5, 6 ]
20:25:42 <andares> it's not working though.
20:25:43 <rasfar> should be np
20:25:50 <quintessence> andares: a line that's as or more indented than the previous one is a continuation of it
20:25:51 <monochrom> works for me
20:25:59 <andares> oh, or does indentation have to match up?
20:25:59 <andares> ahh
20:26:04 <rasfar> s/  / /
20:26:25 <rasfar> s\/  \/ / \//
20:26:47 <mickeyu> does anyone know gloss i am wondering how to use pictures
20:26:47 <rasfar> match up or greater on consecutive lines
20:26:50 <andares> huh, this isn't working at all.
20:26:53 <mickeyu> do i just treat it like a list?
20:27:02 <quintessence> andares: are you mixing tabs and spaces?
20:27:19 <andares> nope, all spaces.
20:27:27 <JoeyA> What's a fast way to construct a valid Ptr to a single readable byte (I don't care what that byte actually is, I just prefer that reading it not segfault).  In C, you'd just say "".
20:27:35 <hpaste> andares pasted “won't compile” at http://hpaste.org/65013
20:27:47 <andares> http://hpaste.org/65013
20:27:49 <andares> yeah, that.
20:28:07 <andares> a search for \t in my code didn't find anything.
20:28:30 <rasfar> your 276th , was a .
20:28:31 <JoeyA> Meh, I'll just use 0x1.  I'd rather the function I'm calling dereference that and segfault than create an issue that's even harder to track down.
20:28:38 <rasfar> ;)
20:28:50 <andares> rasfar: wow. dang. thanks.
20:29:16 <andares> rasfar: wait, I don't think so.
20:29:23 <rwbarton> andares: try copying and pasting that into its own file. it compiles fine.
20:29:42 <andares> odd. okay! thanks
20:29:55 <rasfar> it compiles for me with GHC 7.0.4
20:30:07 <andares> rasfar: and yes, I am incredibly gullible :p
20:30:09 <rwbarton> in general this is good to test yourself before you paste something and say it doesn't compile :)
20:30:21 <andares> :) will do.
20:30:33 <rwbarton> probably the error you're getting is before or after that
20:30:56 <rasfar> i admit i'm a bit curious why this list in particular lol
20:31:15 <blackdog> anyone remember how to have both libraries and executables in a cabal file, and have the executables depend on the library? i'd rather not repeat all my dependencies for each executable...
20:33:03 <dmwit> blackdog: I think you just do it.
20:33:07 <dmwit> Not much to it.
20:33:34 <dmwit> Make sure you have a recent cabal-install when trying to use such a .cabal file, though.
20:33:39 <blackdog> dmwit: i've tried that, but i get an error when i try to build my executable, relating to a package only used in a library file
20:33:39 * hackagebot couchdb-conduit 0.7.4 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.7.4 (AlexanderDorofeev)
20:35:30 <dmwit> blackdog: Maybe post your cabal file to hpaste, along with the error?
20:36:49 <hpaste> blackdog pasted “cabal problems” at http://hpaste.org/65014
20:37:36 <blackdog> dmwit: make any sense?
20:38:47 <dmwit> blackdog: Uh, your library doesn't expose any modules.
20:38:50 <dmwit> That can't be right.
20:39:07 <blackdog> ... duh. yes.
20:39:14 <blackdog> sorry.
20:39:25 <dmwit> blackdog: Also, I remembered that there is a trick to do, but it's easy.
20:40:04 <dmwit> blackdog: You need to put your executables' sources in another directory than your library's sources.
20:40:21 <dmwit> This is to trick GHC into ignoring the local files in favor of the modules provided by the package that you install.
20:40:47 <blackdog> dmwit: ah, thanks. that would have been a hard one to debug.
20:41:03 <blackdog> what's the standard? lib? src?
20:41:34 <blackdog> actually, i suppose i might as well namespace it properly while i'm at it too.
20:41:51 <tgeeky> lol.
20:41:56 <tgeeky> This was a quick, on-a-whim sort of project that ended up taking me all week, as I learned my way around template haskell. It felt like trying to make a sandwich with your feet for the first time, and was about as traumatizing.
20:42:08 <tgeeky> brandonsimmons++
21:08:23 <nyingen> @quote
21:08:24 <lambdabot> Branes says: GPL is free, like herpes
21:08:28 <nyingen> @quote
21:08:28 <lambdabot> adaptec says: [in documentation for their raid chipsets] We have a disclaimer because there may be corner cases
21:09:34 <rasfar> tgeeky: thanks for putting me in the way of brandonsimmons' work, turns out his pez library looks to be just the thing for me at this juncture!  hope so anyway, tried a lot of things already...
21:14:51 <rasfar> err, maybe not (needs record labels) sigh
21:17:11 <scooty-puff> is there a particular set of language pragmas to make a polymorphic data type act like a template class in c++?
21:17:30 <scooty-puff> basically unpack polymorphic fields
21:20:13 <Ivoz__> pl
21:20:18 <Ivoz__> :pl
21:20:35 <Ivoz__> is there a pl service on here?
21:20:40 <Ivoz__> !help
21:20:51 <Ivoz__> \x y -> y x
21:20:57 <scooty-puff> ?
21:21:00 <scooty-puff> hmm
21:21:02 <scooty-puff> not sure
21:21:10 <scooty-puff> @help
21:21:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:21:16 <Ivoz__> http://www.haskell.org/haskellwiki/Pointfree#Tool_support
21:21:22 <dibblego> @pl \x y -> f y x
21:21:23 <lambdabot> flip f
21:21:39 <Ivoz__> @pl \x y -> (take x) $ repeat y
21:21:39 <lambdabot> (. repeat) . take
21:21:53 <Ivoz__> cool
21:22:12 <Ivoz__> thanks scooty-puff
21:22:21 <scooty-puff> np
21:22:47 <Ivoz__> now to figure out how that composition works...
21:25:43 <Ivoz__> how can '. <fnc>' work? doesn't (.) need an expression on either side?
21:27:56 <Cale> Ivoz__: that doesn't work on its own, but inside parens it becomes an operator section
21:28:02 <Cale> > (+ 3) 5
21:28:03 <lambdabot>   8
21:28:28 <Ivoz__> Cale: I don't know the jargon, operator section
21:28:34 <Cale> > (^ 2) 5
21:28:35 <lambdabot>   25
21:28:43 <Cale> > 5^2
21:28:44 <lambdabot>   25
21:28:59 <Cale> Ivoz__: It becomes a function of the missing parameter
21:29:02 <Ivoz__> Cale: so (. <fnc>) becomes a function that takes another function?
21:29:05 <Cale> yeah
21:29:20 <Cale> and composes that function with <fnc>
21:29:34 <Cale> (. f) g = g . f
21:30:06 <ion> You can always make the code even more readable by adding one more layer of nested (.)s!
21:30:13 <Cale> haha
21:30:35 <Ivoz__> I'm trying to work out how all that composition works with a pen and paper
21:31:04 <adnauseam> how do i go about printing a breakspace?
21:31:20 <ion> putChar ' '
21:31:32 <adnauseam> breakspace = breakline, sorry
21:31:38 <adnauseam> \n
21:32:13 <adnauseam> putChar ' ' would just put a space
21:32:17 <Elemir> > putChar '\n'
21:32:18 <lambdabot>   <IO ()>
21:33:00 <adnauseam> oo
21:33:02 <adnauseam> nice :o
21:33:02 <Ivoz__> > (. (+)) 2 5
21:33:04 <lambdabot>   2
21:33:10 <Ivoz__> O_O
21:33:37 <Elemir> @type (. (+))
21:33:38 <lambdabot> forall b a. (Num a) => ((a -> a) -> b) -> a -> b
21:33:39 <Ivoz__> > (. succ) 5
21:33:39 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
21:33:40 <lambdabot>    arising from a use of `...
21:34:30 <Elemir> Heh
21:34:41 <Ivoz__> I think (.) will remain a bit of black magic to me for now..
21:35:19 <Elemir> :t (.)
21:35:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:35:25 <Elemir> Lol
21:35:53 <Elemir> > (.) == fmap
21:35:54 <lambdabot>   Ambiguous type variable `f' in the constraint:
21:35:54 <lambdabot>    `GHC.Base.Functor f'
21:35:54 <lambdabot>     ...
21:36:03 <JoeyA> If I treat an empty ByteString whose underlying pointer is null differently from one whose pointer is not null, would it be a stretch to say I'm violating referential transparency?
21:36:20 <Elemir> Ivoz__: (.) at lambdabot isn't dot
21:36:29 <Elemir> It's fmap, as I see
21:37:38 <Ivoz__> shouldn't a x b === (x) a b ?
21:38:03 <Elemir> Of cause should
21:38:17 <kallisti> is there a tool to automatically generate export lists?
21:38:28 <Enigmagic> :t (Prelude..)
21:38:28 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:38:52 <NemesisD> anyone here use yesod?
21:39:36 <Enigmagic> kallisti: how would that work? all top level functions?
21:39:39 <Ivoz__> that looks closer, Enigmagic
21:39:58 <shapr> Enigmagic: Would need to export instances as well
21:40:42 <gentleben>  NemesisD: yes
21:40:44 <Enigmagic> okay, top level declarations
21:41:30 <kallisti> Enigmagic: yep. just a list, so that I can edit it by hand.
21:41:40 <kallisti> all types, constructors, etc.
21:41:45 <kallisti> and then I can omit as desired.
21:45:14 <Enigmagic> kallisti: you could probably hack one together with haskell-src-exts, i don't think ghc has an option to do it and the .hi file dumper (--show-iface) isn't easy consume
21:49:10 <Axman6> NemesisD: if you have yesod questions, you might also like to ask them in #yesod
21:49:22 * Sgeo is currently playing with CL
21:49:41 <Sgeo> But a thought occurs to me: An Error monad that would allow for recoverable errors.
21:49:58 <Sgeo> Something like Left someContinuation
21:50:05 <Sgeo> ?
21:50:12 <Sgeo> Has someone already done something like this?
21:51:40 <nyingen> CL as in common lisp?
21:51:44 <Sgeo> Yes
21:52:27 <mee> are you thinking about something like this? http://axisofeval.blogspot.com/2011/04/whats-condition-system-and-why-do-you.html
21:53:49 <geekosaur> monad-control and/or monad-peel on hackage?
21:53:54 <Sgeo> mee, yes
21:54:08 <geekosaur> there was some discussion about how to extend them on the list some time back
21:54:45 <mee> I've always thought that was a cool idea
22:17:13 <Elemir> Hem-hem. Why haskell doesn't support standard decontructors for types?
22:17:53 <mauke> it does: case .. of
22:18:46 <Elemir> \x -> case x of …
22:20:09 * Elemir thinks about full support of tacit style in haskell
22:20:38 <Elemir> Without deconstructors it isn't real
22:20:57 <mauke> what is "tacit style"?
22:22:00 <Elemir> http://en.wikipedia.org/wiki/Tacit_programming
22:22:11 <shachaf> mauke: It has a similar meaning to "point-free".
22:22:27 <shachaf> In fact it's apparently the same meaning.
22:22:28 <mauke> I see
22:23:02 <shachaf> Haskell doesn't support point-free deconstructors by default, indeed.
22:23:21 <mauke> you can easily define them yourself but its boilerplate
22:23:26 <mauke> *it's
22:23:41 <Elemir> With template haskell?
22:23:48 <mauke> no, with haskell
22:24:01 <Elemir> How?
22:24:17 <mauke> @src maybe
22:24:17 <lambdabot> maybe n _ Nothing  = n
22:24:17 <lambdabot> maybe _ f (Just x) = f x
22:24:21 <mauke> like that
22:24:41 <Elemir> It's doesn't point-free itself
22:24:47 <Elemir> *It
22:24:47 <mauke> yes
22:24:56 <Elemir> So sad =(
22:25:00 <mauke> why?
22:25:11 <mauke> point-free style isn't a goal in and of itself
22:27:16 <ktklam9> hi, I keep getting a stack overflow even though my function is in tail-recursive, is this because of lazy evaluation?
22:27:33 <adit> post your code
22:27:37 <Elemir> What function?
22:27:55 <BMeph> Yes. Maybe not on the compiler's part, but yes. ;)
22:29:35 <int-e> @pl \c e f i o r s t -> o f (c o u r s e (i t (i s)))
22:29:37 <lambdabot> (flip ((.) . ap . (((.) . (.) . (.)) .) . flip id) .) . flip flip ((.) =<< flip) . (((.) . flip . ((flip . (liftM2 (.) .)) .)) .) . flip . ((flip . (flip .)) .) . flip flip u
22:29:48 <int-e> oh, missed the u :)
22:29:59 <opqdonut> ktklam9: yes, laziness most probably. tail recursion isn't as important in haskell as it is in strict functional programs
22:30:34 <opqdonut> err, programming languages
22:30:36 <int-e> @type flip flip
22:30:37 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
22:30:51 <int-e> caleskell!
22:33:14 <ktklam9> http://hpaste.org/65018 <-- why does that crash?
22:34:09 <int-e> "crash"? you get a stack overflow I guess.
22:34:21 <mauke> yeah, c is a huge thunk
22:34:41 <mauke> the only time c is evaluated is in print
22:34:52 <ktklam9> ghc does not do tail recursion?
22:35:06 <mauke> it does
22:35:12 <int-e> the term is not very meaningful with lazy evaluation
22:35:14 <mauke> it builds the huge thunk very efficiently
22:35:34 <Cale> 'tail call optimisation' is what you mean, and that doesn't mean much when GHC doesn't have a call stack
22:35:51 <Cale> The stack which is overflowing isn't a call stack, it's a stack of pattern matches.
22:35:58 <ktklam9> ...? ok... so how do make that not crash?
22:36:12 <Cale> who are waiting for their scrutinee to be sufficiently evaluated to be able to pattern match
22:36:23 <int-e> make func artificially strict in its first argument
22:36:49 <int-e> func !c 0 = c  with bang patterns
22:37:17 <mauke> (func $! k * c) (i - 1) without
22:37:49 <nexx> http://www.techdirt.com/articles/20120228/17044017902/somethings-not-right-german-user-has-to-use-chinese-proxy-to-see-new-music-video.shtml
22:38:35 <ktklam9> mauke: I get parse error from ghc...?
22:39:23 <mauke> ktklam9: is that supposed to be a factorial function?
22:39:53 <ktklam9> mauke: it's just some random function that is closely matched to my function
22:41:05 <mauke> ktklam9: http://hpaste.org/65019 compiles
22:41:10 <mauke> but takes approximately forever to run
22:42:38 <ktklam9> mauke: so how would I fix it?
22:44:23 <mauke> like that
22:45:41 <ktklam9> mauke: it takes forever to run? I don't think that helped much
22:45:54 <mauke> why?
22:46:11 <mauke> you wanted it to loop 50000000 times
22:46:27 <ktklam9> mauke: it still shouldn't take that long
22:47:06 <JoeyA> What interpolated string quasiquoter package should I use?
22:47:22 <ktklam9> it's only O(n), compilers that do tail-recursion should optimize that away and the program should only take a second at most to run
22:49:08 <JoeyA> interpolatedstring-qq looks pretty simple.
22:49:53 <godzemo> good afternoon
22:50:10 <godzemo> is there a scheduled release date for haskell-platform with ghc 7.4.1?
22:50:13 <godzemo> thanks :)
22:51:32 <JoeyA> I'd like to know, too.
22:51:56 <mauke> > foldl' (*) 100 [1 .. 1000000]
22:52:00 <lambdabot>   mueval-core: Time limit exceeded
22:53:07 <Elemir> > head $ foldl' (*) 100 [1 .. 1000000]
22:53:08 <lambdabot>   No instances for (GHC.Enum.Enum [a], GHC.Num.Num [a])
22:53:08 <lambdabot>    arising from a use...
22:53:21 <Elemir> Argh
22:53:44 <Elemir> Logical
23:01:31 <taiyal> <lambdabot> (flip ((.) . ap . (((.) . (.) . (.)) .) . flip id) .) . flip flip ((.) =<< flip) . (((.) . flip . ((flip . (liftM2 (.) .)) .)) .) . flip . ((flip . (flip .)) .) . flip flip u
23:01:40 <taiyal> is haskell really that hard
23:01:47 <DrAwesomeClaws> did you just flip me off?
23:02:03 <Cale> taiyal: ?
23:02:27 <DanBurton> taiyal: is trolling really that hard
23:02:29 <Cale> taiyal: That's the output of an @pl command, which is an automatic program for removing lambdas from expressions
23:02:32 <DrAwesomeClaws> All I know about haskell (well, not really "all") is that there's some monad at play in that code, haha
23:02:39 <dmwit> DrAwesomeClaws: Hey, did you get the xmonad problem sorted?
23:02:44 <dmwit> DrAwesomeClaws: The one where xmonad freezes?
23:02:45 <Cale> The monad will be the function monad
23:02:59 <Cale> which @pl uses to duplicate arguments
23:03:16 <DrAwesomeClaws> dmwit, nope.  Asked around in #xmonad today but didn't get very far.  Going to strace it later and see if i get any interesting output
23:03:16 <taiyal> looks like an S-expression with cancer
23:03:17 <DanBurton> it uses ap, =<<, and liftM2
23:03:27 <dmwit> DrAwesomeClaws: Did you see my messages about it?
23:03:36 <dmwit> DrAwesomeClaws: The usual culprit is writing to a pipe, and not reading from the other end.
23:03:39 <DrAwesomeClaws> no, but they may be in my buffer...
23:03:41 <DanBurton> arguably, ap and liftM2 are not monadic, they only require applicative power
23:04:10 <dmwit> DrAwesomeClaws: e.g. if you're sending to xmobar, but xmobar either doesn't have the StdinReader/PipeReader plugin loaded as appropriate, or it has the plugin loaded but you haven't included them in your template
23:04:23 <edwardk> thinking i'm just going to bite the bullet and write a pair of incredibly pathetic 'FromDouble' and 'FromFloat' classes
23:04:36 <dmwit> DrAwesomeClaws: If you hpaste your xmonad.hs and other relevant config files, we could try to have a look together.
23:04:53 <DrAwesomeClaws> thanks.  Maybe... but it'd have to be something that's not specific to xmobar.  I had the issues before ever installing xmobar (actually, researching how xmonad works to try to fix the issue lead me to installing xmobar)
23:05:12 <DrAwesomeClaws> https://gist.github.com/2005217  that's my xmonad.hs  Not much there
23:05:20 <edwardk> the magic rewrite rules don't work well with parametric functions and take performance down terribly
23:05:30 <DrAwesomeClaws> the .xmobarrc is default except changing the weather stating
23:05:35 <DrAwesomeClaws> station
23:06:03 <dmwit> Please paste your .xmobarrc, too, anyway. I don't have a good grasp of what xmobar's defaults are these days.
23:06:19 <DrAwesomeClaws> ok, give me a min.  I'm on another machine at the moment
23:07:07 <DanBurton> what does the rc at the end of such files stand for?
23:07:24 <dmwit> Anyway, this xmonad.hs does indeed write to a pipe quite often, so I'm more sure than ever that your xmobar simply isn't reading the other end of the pipe.
23:07:30 <dmwit> DanBurton: "resource"
23:07:35 <DrAwesomeClaws> https://gist.github.com/2005413  my .xmobarrc
23:07:39 <mauke> read commands
23:07:59 <dmwit> DrAwesomeClaws: Yes, you need to include the StdinReader plugin both in your "commands" list and in your "template".
23:08:06 <dmwit> DrAwesomeClaws: That should fix the problem entirely. =)
23:08:09 * DanBurton isn't sure who to believe
23:08:34 <dmwit> DrAwesomeClaws: Alternately, if you don't want xmobar to use StdinReader, don't write to xmobar in your log hook. =)
23:08:46 <DrAwesomeClaws> hmmm... odd... since this happened before i had xmobar.  But I trust you know more about this than i do.  Can you point me to some documentation regarding what you're talking about? haha
23:09:21 <DrAwesomeClaws> sorry, I'm a bit of a haskell noob, so a lot of this is over my head.
23:09:22 <dmwit> DrAwesomeClaws: http://www.haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#XMonad_is_frozen.21
23:09:31 <mauke> DrAwesomeClaws: nothing to do with haskell
23:09:35 <mauke> this is unix
23:09:38 <mauke> (I know this!)
23:09:45 <DrAwesomeClaws> thanks, somehow i didn't find that with my earlier searches
23:09:54 <DrAwesomeClaws> I appreciate the help, immensely
23:10:04 <dmwit> Also, yes, configuring xmobar does not require Haskell knowledge (nor does Haskell knowledge really help).
23:10:16 <dmwit> Check out xmobar's documentation for more instructions on using StdinReader.
23:10:48 <dmwit> In short, though, you just add a line like "Run StdinReader," to the "commands" list, and add "%StdinReader%" somewhere in your template.
23:10:51 <DrAwesomeClaws> you're right, I was thinking more "configuring xmonad" when i typed that.  But in any event, I want to learn haskell much more anyway, so it's good regardless
23:10:52 <dmwit> Nothing more to it than that.
23:11:52 <DrAwesomeClaws> I'm still trying to wrap my heads around monads.  I'm at that point where they make perfect sense while reading about them / watching videos but never when i try to implement anything, haha
23:16:09 <DrAwesomeClaws> wow, suddenly very tired.  Think it's almost time for some khan academy/bed
23:16:29 <DanBurton> DrAwesomeClaws: that's normal. Just keep playing around with actual monads and you'll get the hang of it in no time
23:17:00 <DrAwesomeClaws> DanBurton: Yeah, that's what i figured.  I understand what's going on (generally), but have no intuition for it
23:17:24 <DanBurton> also, trying to implement the monad operations yourself for [], Maybe, etc is a good exercise
23:18:01 <DrAwesomeClaws> thanks, i might just do that.  Maybe seems almost doable to me (which probably means I'll have a hell of a time trying to do so, haha).
23:18:27 <DanBurton> @google 20 haskell intermediate exercises
23:18:30 <lambdabot> http://blog.tmorris.net/20-intermediate-haskell-exercises/
23:18:30 <lambdabot> Title: λ Tony’s blog λ » Blog Archive » 20 Intermediate Haskell Exercises
23:18:40 <DanBurton> these are also good Haskell exercises ^
23:18:44 <DrAwesomeClaws> oh, sweetness.  Thanks
23:18:44 <Axman6> those are fantastic
23:19:38 <DrAwesomeClaws> Even though I don't know haskell well yet, it just makes me so happy for some reason
23:20:27 <DanBurton> i know right? it's inexplicably delicious
23:21:01 <dmwit> I don't think it's really possible to say "I get monads, therefore I will instantly understand every monad I come across.".
23:21:29 <DrAwesomeClaws> I started as a PHP developer in 1997... where everything is a String...ish.  Then i learned some C/C++ and loved the Static typing... but not so much the language.  Haskell seems to be the best of all worlds.  Rock solid code that I can dance around as though I'm writing javascript
23:21:32 <dmwit> I've been programming with monads for a while now, and still have to play with any new monad for a significant time before I can say I've internalized it.
23:21:35 <Axman6> indeed, the Cont monad still confuses me somewhat (mainly because i've never spent any time using it)
23:22:13 <Axman6> dmwit: and the compiler punches you in the head when you do sopmething stupid, it's great!@
23:22:17 <Axman6> uh, DrAwesomeClaws
23:22:21 <DrAwesomeClaws> where type matters but doesn't get in the way
23:25:53 <DrAwesom_> strange, my connection went down. Maybe someone winnuked me, haha
23:27:40 <DrAwesom_> Axman6, not sure if you said anything after: "Uh,DrAwesomeClaws"... but it seemed as though you were going to admonish me for saying something dumb (which i fine, I say lots of dumb stuff).  I just want to hear it if that's the case
23:28:36 <dmwit> He didn't say anything afterwards.
23:28:53 <dmwit> And I think he was correcting the "dmwit: " to "DrAwesomeClaws: ", not preparing to admonish you.
23:28:56 <Axman6> DrAwesom_: "18:21:50 < Axman6> dmwit: and the compiler punches you in the head when you do sopmething stupid, it's great!" was meant for you
23:29:39 <DrAwesom_> ah, thanks both of you, haha
23:30:13 <mauke> ktklam9: your program has finished!
23:30:24 <mauke> ktklam9: it generated 5.4 MB of output
23:30:40 <mauke> that is, a number with 5565711 digits
23:31:30 <ktklam9> mauke: cool
23:32:26 <DrAwesom_> So, random comment:  Anyone have any thoughts on writing a genetic algorithm to solve the Even-n-parity problem in haskell?  I'm pretty sure this has been done, but it's been on my mind as something that might be fun to try to tackle
23:35:11 <DrAwesom_> seems like i should be able to pass generic boolean functions to an algorithm which evolves various algorithms to attempt to solve the problem.  I probably wouldn't find any efficient solutions, but it seems like a fun way to get better with haskell
23:35:22 <DanBurton> i knew it! mauke is a bot.
23:39:21 * hackagebot safe-freeze 0.2 - Support for safely freezing multiple arrays in the ST monad.  http://hackage.haskell.org/package/safe-freeze-0.2 (ReinerPope)
23:39:36 <augur> is there a standard function mOr Nothing y = y ; mOr x _ = x?
23:40:07 <Axman6> just for Maybe? or other types?
23:40:42 <Axman6> @hoogle MonadPlus m => m a -> m a -> m a
23:40:42 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
23:40:42 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
23:40:42 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
23:40:43 <mauke> > join (liftM2 mplus) [Nothing, Just 2]
23:40:43 <lambdabot>   [Nothing,Just 2,Just 2,Just 2]
23:40:57 <Axman6> it's basically (<|>) afaict
23:41:02 <mauke> > join (liftM2 mplus) [Just 2, Nothing]
23:41:03 <lambdabot>   [Just 2,Just 2,Just 2,Nothing]
23:41:15 <augur> just for Maybe
23:41:15 <mauke> good enough
23:41:38 <augur> or at least for maybe
23:42:03 <augur> at <|> does indeed work
23:43:05 <mauke> @check \x y -> (mplus x y) == (x <|> (y :: Maybe Bool))
23:43:06 <lambdabot>   "OK, passed 500 tests."
23:44:21 * hackagebot digest 0.0.1.1 - Various cryptographic hashes for bytestrings; CRC32 and Adler32 for now.  http://hackage.haskell.org/package/digest-0.0.1.1 (EugeneKirpichov)
23:46:40 <andares> I'm getting indentation problems with http://hpaste.org/65013
23:46:55 <andares> a number of people have said it works fine for them, when they pasted it in, but it doesn't for mine.
23:47:07 <andares> (ghc complains about improper indentation.)
23:47:07 <mauke> andares: what's the error message?
23:48:58 <DrAwesom_> works fine here
23:49:08 <DrAwesom_> ghc 7.4.1
23:49:32 <augur> whats a predicate transformer?
23:49:33 <andares> mauke: euler11.hs:2:1: parse error (possibly incorrect indentation)
23:49:48 <mauke> andares: what are lines 1 and 2 of euler11.hs?
23:49:58 <DrAwesom_> project euler! Thank you, forgot all about that
23:50:03 <andares> the entire thing is in that paste, mauke.
23:50:29 <mauke> andares: post a hex dump
23:50:43 <andares> mauke: okay, let me try to figure that out.
23:52:53 <hpaste> andares pasted “hex dump” at http://hpaste.org/65023
23:53:02 <andares> there you go mauke, thanks.
23:54:08 <dmwit> What do you know, no literal tab characters.
23:54:40 <andares> there shouldn't be any, should there?
23:54:58 <dmwit> I was betting on them.
23:55:10 <andares> yeah, I'd run into that before and fixed it.
23:55:21 <andares> it might be my ghc, but that seems unlikely.
23:55:26 <mauke> and no indentation
23:55:55 <mauke> there are only two spaces in the whole file
23:56:00 <mauke> "nums = "
23:57:41 <andares> darn! I was editing the wrong file. sorry.
23:58:08 <DrAwesom_> haha, hate when that happens
23:58:37 <DrAwesom_> there seems to be a universal law which dictates you'll never notice it's the wrong file until after asking on irc
