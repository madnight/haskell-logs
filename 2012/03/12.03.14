00:22:58 <dibblego> @type void
00:22:59 <lambdabot> Not in scope: `void'
00:23:04 <dibblego> @type Control.Monad.void
00:23:04 <lambdabot> Not in scope: `Control.Monad.void'
00:29:52 <ksf__> void :: Monad m => m a -> m ()
00:30:13 <DanBurton> @hoogle void
00:30:14 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
00:30:14 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
00:30:14 <lambdabot> package void
00:30:17 <shachaf> I thought void :: Void -> a
00:30:23 <ksf> oh, functor.
00:30:35 <DanBurton> functor...but defined in Control.Monad -___-
00:30:54 <ksf> hysterical raisins
00:31:39 <DanBurton> how much code would honestly break if we were to redo Functor/Applicative/Monad the right way?
00:32:59 <DanBurton> this would be a nice step forward for, say, Haskell 2012 or Haskell 2013
00:33:33 <elliott> It would break every piece of code that declares a monad and was written before Control.Applicative entered base.
00:33:37 <elliott> I think that only happened circa 2006.
00:34:42 <DanBurton> if the code hasn't been updated since ~2006 then it's probably relegated to an old ghc version anyways
00:35:03 <elliott> I don't think that's true at all.
00:35:12 <elliott> Perhaps the recent Num change made it true.
00:35:14 <elliott> But not before that.
00:35:25 <elliott> base is stable, as far as existing, long-standing APIs go.
00:35:53 <DanBurton> true enough
00:36:49 <elliott> However, the Num change breaks far, far more.
00:37:04 <elliott> So if we're wantonly breaking older code, I don't see a reason not to add the superclass.
00:37:34 <DanBurton> fortunately, for both cases, the fix is quite mechanical
00:37:39 <elliott> (The only non-compatibility argument against it I've heard is that we might discover a typeclass in the middle someday, but that's not compelling.)
00:39:15 <Tesseraction> does GHCi have an equivalent of the hugs option that shows how many steps were taking in a function?
00:39:34 <elliott> What is a step?
00:39:45 <elliott> It can count the number of seconds (:set +s).
00:39:56 <Tesseraction> hmm, that'll work just as well
00:40:15 <Tesseraction> effectively I'm trying to see whether one method is more efficient than the other
00:40:55 <ChristianS> doesn't the recent Num change mean that ghc haskell is now incompatible with standard haskell?
00:41:48 <elliott> ChristianS: Yes.
00:41:58 <elliott> Though I believe it deviates in some rather minor ways by default anyway.
00:42:08 <elliott> Tesseraction: Consider using the criterion library.
00:42:20 <kallisti> I'm somewhat surprised Text is not a Functor.
00:42:33 <elliott> Tesseraction: It makes effective benchmarking very easy (and will provide much more accurate timings).
00:42:37 <kallisto> Any news about Ticket #5899 (GHC RTS crash w/ strange closure type 603975781 on OS X 10.8)?
00:42:49 <elliott> kallisti: I am not surprised that a kind error is not true.
00:42:52 <Tesseraction> elliott: shall do, cheers
00:43:04 <kallisti> elliott: ah yes.
00:48:03 <ChristianS> elliott: it's a shame.
00:49:14 <elliott> ChristianS: Perhaps, though considering how universal GHC extensions are, it's a rather meaningless thing.
00:49:27 <elliott> Even if you don't use extensions, you almost certainly use libraries whose interfaces depend on extensions.
00:49:34 <elliott> The shame is more that the report isn't keeping up.
00:51:10 <ChristianS> hmm, i didn't mind language extensions since you explicitly have to request them.
00:51:40 <ChristianS> elliott: though your argument about libs that don't compile with anything except ghc is certainly true.
00:52:17 <ChristianS> also, i must say i'm pretty happy that standard haskell evolves so slowly.
00:52:35 <ChristianS> you can break a language by too much change, see perl 6/python 3.
00:53:52 <elliott> ChristianS: I am pretty sure ubiquitous portions of base's interfaces require language extensions.
00:54:15 <elliott> So, avoiding language extensions is a fairly pointless activity.
00:54:53 <elliott> ChristianS: The problems of Perl 6/Python 3 arose from their process and all-at-once nature; GHC's extensions have had a very long time to settle and be widely-accepted in the community.
00:55:13 <elliott> Standardising them won't suddenly make everyone revert to Hasekll 2010 tomorrow :)
00:59:22 <ChristianS> extensions are fine with me (as i said), especially if you have to enable them explictly (since that documents, at least, what's going on).
00:59:32 <elliott> Right.
00:59:41 <ChristianS> what i mind is breaking existing code, especially if that code is standard haskell.
01:00:13 <elliott> Yes -- but I am very sceptical of claims that a piece of code is standard Haskell, since it requires all its dependencies to be implementable in standard Haskell too.
01:00:41 <elliott> Still, there is little conceivable reason that e.g. FlexibleInstances still has to exist in 2010 because the report is changing too slowly to standardise it.
01:00:46 <elliott> Wait, it's 2012.
01:01:31 * kfish just added a bunch of FlexibleInstances pragmas to fix build breakage with ghc-7.5
01:02:10 <elliott> 7.5, eh?
01:02:19 <elliott> That's because TypeSynonymInstances used to sort of imply FlexibleInstances.
01:02:22 <elliott> That is, if you had
01:02:27 <elliott> instance Foo String where ...
01:02:35 <elliott> it would be accepted with TypeSynonymInstances, even though instance Foo [Char] would not be.
01:02:41 <elliott> 7.4 fixed that.
01:03:23 <ChristianS> elliott: won't argue against that.
01:03:33 * ChristianS wished that OverloadedStrings became standard haskell.
01:04:01 <elliott> I'm not a big fan of OverloadedStrings, though it's no worse than fromInteger...
01:04:06 <elliott> But the ambiguity errors it causes can be frustrating.
01:05:07 <ChristianS> there we go. tastes differ, so maybe it's better the committee people are so conservative ;-)
01:06:24 <elliott> Yeah. But there's no reason individual extensions themselves can't be standardised and off-by-default, even then.
01:06:38 <elliott> OverloadedStrings is in wide use, so a more formal, portable documentation it is valuable.
01:08:41 <ChristianS> right
01:09:45 <elliott> yczhang: ?
01:10:00 <ocharles> Is it possible to use data families and type classes? I have `data family Ref :: *a :: *` and another data type `data Foo a = Foo (Ref a) deriving (Eq)`
01:10:21 <ocharles> (excuse the typos, i'm on a train where the 3g is so slow I can't afford to correct them :))
01:10:36 <elliott> ocharles: deriving instance (Eq (Ref a)) => Eq (Foo a) should work.
01:10:41 <ocharles> Anyway, the above doesn't work, because it can't derive Eq, because Ref a is not an instance of Eq
01:10:49 <elliott> You can do
01:10:53 <ocharles> elliott: on the Foo data type?
01:10:58 <elliott> ocharles: no, as a separate declaration
01:11:01 <elliott> class (Eq (Ref a)) => Reffable a where data Ref a
01:11:05 <ocharles> oh
01:11:07 <elliott> deriving instance (Reffable a) => Eq (Foo a)
01:11:17 <elliott> but that's only useful if Reffable packs a lot of constraints together
01:11:20 <elliott> or has other members
01:13:23 <yczhang> elliott: Sorry if bothered you. Just playing with IRC client features (first time joining a IRC chat)
01:13:52 <elliott> yczhang: ah, ok :)
01:13:57 <elliott> no bother, just curious
01:14:17 <elliott> (you sent a version information request to my client, no big deal)
01:14:31 <ocharles> Hm, seems that the standalone deriving needs UndecidableInstances
01:14:50 <ocharles>  Constraint is no smaller than the instance head
01:14:51 <elliott> ocharles: oh. yeah, it will.
01:14:54 <ocharles>       in the constraint: Eq (Ref a)
01:14:55 <elliott> it's harmless there, though.
01:15:02 <ocharles> yea? cool
01:15:11 <ocharles> I never know when it's safe
01:16:35 <elliott> ocharles: well it's always safe really
01:16:48 <elliott> the worst that can happen is that things take too long and the compiler says "i give up, it took too many steps"
01:17:44 <ocharles> heh
01:17:52 <astor> how can I get cabal to install all missing dependencies that it complains about when I run 'cabal configure' on a package?
01:18:01 <ocharles> but I mean if I'm writing a library, ideally I don't want my customers to every experience that
01:19:28 <elliott> astor: cabal install --only-dependencies or something like that
01:19:32 <elliott> cabal help install if that exact option isn't it
01:20:28 <astor> elliott: thanks. that was exactly it it seems.
01:24:54 <astor> elliott: filed but on cabal
01:25:01 <astor> elliott: s/but/bug
01:26:42 <elliott> astor: ?
01:28:50 <ocharles> If I'm looking to serialize to XML, with no requirement to parse XML, what library would people recommend?
01:29:40 <astor> elliott: failure to inform the user that it should run 'cabal install --only-dependencies'
01:31:11 <elliott> astor: ah.
01:31:13 <elliott> well, that won't always help.
01:31:58 <t7> ocharles: this one is based on blaze but it does do parsing too http://hackage.haskell.org/package/xml-conduit
01:32:06 <t7> shouyld be really fast
01:33:06 <astor> elliott: then it should give some tip wrt what will help.  printing "if this mess happens repeatedly, you might want to install hsenv or cabal-dev.  otherwise you might want to run cabal install --only-dependencies" etc.. my patience with unhelpful error messages is diminishing with the years.  it is such a waste of time.
01:33:36 <elliott> i don't see how cabal-dev would help
01:35:30 <astor> elliott: no that would be when there is some version mismatch error..  anyways, I try to file bugs on everything that is a drag on productivity these days.
01:38:00 <elliott> cabal's releasing schedule is slipped enough without new features :p
01:38:44 <astor> elliott: maybe the most important feature would be to move to github so people could contribute more easily?
01:38:51 <t7> anyone else on linode here?
01:39:23 <elliott> astor: i think the devs are happy with darcs
01:39:52 <astor> elliott: I am sure they are.  I would be too I think.
01:40:10 <ocharles> t7: I want serialization, *not* parsing :)
01:40:25 <ocharles> i thought xml-conduit was more for parsing?
01:40:27 * ocharles looks again
01:40:28 <t7> yeah it renders XML data at text
01:40:29 <srhb> Why does this not make sense: foldr (\x acc -> (x:acc)) [] [1,2,3] ?
01:40:36 <t7> as well as parsing
01:40:58 <srhb> Er, I meant foldl. It works with foldr of course.
01:41:03 <astor> srhb:  (x:acc ??)
01:41:15 <ocharles> t7: oh right, I was looking for something with combinators to generate the actual XLM
01:41:17 <ocharles> XML*
01:41:30 <srhb> astor: Yes, that should be identity fold over the list.
01:42:04 <ocharles> maybe I'll go with xml-hamlet and xml-conduit
01:42:19 <t7> ocharles: err you could build your document with SExpression-like syntax using Text.XML :)
01:42:23 <srhb> astor: With foldr at least, I get an infinite type with foldl, but I don't quite understand why.
01:42:24 <elliott> srhb: it does not type
01:42:35 <srhb> elliott: Indeed, and I can't see why.
01:43:06 <elliott> :t foldl
01:43:06 <elliott> :t foldr
01:43:07 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:43:07 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:43:11 <elliott> see now?
01:43:14 <mauke> srhb: order of arguments
01:43:19 <elliott> foldl (flip (:)) [] will work
01:43:22 <elliott> (it's reverse)
01:43:28 <elliott> > foldr f z [a,b,c]
01:43:29 <srhb> Oh dear, right.
01:43:30 <lambdabot>   f a (f b (f c z))
01:43:31 <elliott> > foldl f z [a,b,c]
01:43:32 <lambdabot>   f (f (f z a) b) c
01:43:35 <elliott> > foldl (flip f) z [a,b,c]
01:43:39 <lambdabot>   mueval-core: Time limit exceeded
01:43:44 <elliott> > foldl (flip f) z [a,b,c]
01:43:46 <lambdabot>   f c (f b (f a z))
01:58:15 <tsanhwa> hi, any suggestion for http client library that is easy to use?
01:58:47 <elliott> tsanhwa: http-conduit
01:58:53 <elliott> failing that, HTTP
01:59:24 <tsanhwa> elliott: thanks
02:06:47 <unlink> Is there a more natural idiom for this Either monad usage:  _ <- if p x then Left "some error" else Right undefined
02:07:10 <dmwit> guard (p x)
02:07:43 <unlink> I don't get an error message out of that, though
02:08:08 <unlink> I suppose at least I could omit the "_ <-".
02:08:22 <elliott> unlink: guard (p x) <|> Left "some error"
02:08:41 <dmwit> nice
02:08:52 <elliott> reads nicely too
02:08:58 <elliott> well
02:09:04 <elliott> s/Left/fail/ to have it read nicer
02:09:12 <elliott> whether that's less or more evil is up to you
02:09:33 <shachaf> elliott: What happened to the the existential-bottom solution?
02:09:42 <unlink> Does C.M.E implement fail?
02:10:39 <elliott> E could be multiple reasonable things there.
02:11:07 <unlink> I meant Either.
02:11:28 <elliott> Ah, right.
02:11:30 <elliott> It does not.
02:11:35 <elliott> Or rather it just gets the default fail = error.
02:11:43 <elliott> So yes, stick with Left.
02:11:52 <elliott> > mzero <|> Left "abc"
02:11:53 <lambdabot>   Left "abc"
02:11:59 <elliott> Good, wasn't sure it had Alternative.
02:19:24 <unlink> This doesn't exactly feel super clean either: if x then return True else do { showPrompt ; (`elem` ["Y", "y"]) <$> getLine }
02:19:55 <elliott> unlink: that looks fine to me, except transform do { x ; y } into x >> y
02:20:00 <srhb> Would a sane method of counting inversions in a list in Haskell be to reproduce a simple merge sort and tie some sort of state into it?
02:20:01 <elliott> or even x *> y, since you're using applicative style
02:20:13 <srhb> Ie. each time I swap an element in the merge, I simply increment some state
02:20:18 <elliott> if x then return True else showPrompt >> (`elem` ["Y", "y"]) <$> getLine
02:20:19 <unlink> elliott: showPrompt is an abbreviation for more actions.
02:20:25 <elliott> unlink: ah.
02:20:28 <elliott> well, factor those actions out :P
02:22:23 <yitz> when (p x) $ Left "some error"
02:23:03 <elliott> oh!
02:23:09 <elliott> unlink: our solutions were wrong
02:23:12 <elliott> we flipped the condition
02:23:16 <elliott> yitz's is right
02:23:23 <unlink> yes.
02:23:35 <yitz> a minor point of course :)
02:23:57 <Tesseraction> If I have a function of type List -> List -> State SeveralLists (), how would I go about get-ing this State in another function? Any attempt to do so says cannot match () with expected type, but even (deliberately incorrectly) setting () to the expected type brings the same issue, so I'm assuming I've missed something obvious
02:24:08 <Tesseraction> my that was a longer question than I thought
02:25:23 <elliott> Tesseraction: your question is a bit unclear
02:25:30 <elliott> can you paste the code you're having problems with? hpaste.org
02:25:34 <merijn> Tesseraction: Sample code + error?
02:25:34 <Tesseraction> yeah sure
02:27:56 <Tesseraction> http://hpaste.org/65274
02:28:23 <Tesseraction> I renamed a variable or two to make it make sense in this context
02:28:24 <elliott> ok, what precise error do you get?
02:29:22 <Tesseraction> Couldn't match expected type () with actual type ([Bool],[Bool])
02:29:44 <elliott> the rest of the error would help too
02:29:48 <elliott> specifically the expression it is complaining about
02:31:43 <Tesseraction> http://hpaste.org/65276
02:31:58 <elliott> multiplyStep :: State Byte5 ()
02:32:01 <quicksilver> Tesseraction: multiplyStep's type makes no sense.
02:32:01 <elliott> 				return (third x)
02:32:07 <elliott> you declared the result type as ()
02:32:10 <elliott> yet you return a value
02:32:22 <Tesseraction> yeah, but previously changing that to Byte2 raised a similar error
02:32:27 <quicksilver> susepect it's supposed to be State Byte5 Byte2
02:32:45 <quicksilver> the "similar" error was probably quite different.
02:33:08 <quicksilver> multiplyInit would then have the wrong type
02:33:19 <quicksilver> since multiplyStep is the last expression in multiplyInit
02:33:24 <Tesseraction> oh, of course they would be similar, I copied the wrong error
02:33:28 <Tesseraction> it's one of those days it seems
02:33:33 <quicksilver> if multiplyStep returns a Byte2 then multiplyInit will return a Byte2
02:33:48 <Tesseraction> http://hpaste.org/65277
02:33:49 <Tesseraction> there we go
02:33:55 <Tesseraction> one's with Byte2, one's with ()
02:34:44 <elliott> is there any way to reduce a type in GHCi?
02:34:55 <elliott> e.g. I have SomeTypeFamily Blah Blah and I want to see the fully-reduced type -- I think yes but I forget what it is
02:35:09 <quicksilver> Tesseraction: I repeat my last remakrk.
02:35:19 <Tesseraction> right
02:35:22 <quicksilver> since multiplyStep is the last expression in multiplyInit, if multiplyStep returns a Byte2 then multiplyInit will return a Byte2
02:35:28 <Tesseraction> I have a feeling my tutor has been leading me up a garden path
02:35:30 <ozgura> elliott: was it :t!
02:35:39 <elliott> ah, :kind!
02:35:50 <elliott> ozgura: doesn't work (neither does :type!)
02:35:52 <elliott> but :kind! does
02:35:58 <elliott> annoyingly :k! doesn't, which is what I tried first
02:36:03 <ozgura> oh, ok
02:38:33 <mroman> or use return () if you really don't care about what it exactly returns ;)
02:41:17 <hpaste> unlink pasted “SortIncoming.hs” at http://hpaste.org/65278
02:41:56 <unlink> Style comments on the above paste would be appreciated. :)
02:43:22 <unlink> Highly IOful Haskell is a new idiom for me.
02:44:00 <ChristianS> unlink: don't convert to/from Data.Text just to decode/encode utf-8.
02:44:10 <ChristianS> unlink: better use Data.Text for everything.
02:45:30 <elliott> ChristianS: Where are directory functions that use Text for filenames?
02:45:54 <ChristianS> elliott: ok, point taken.
02:46:01 <elliott> That said, I am sceptical of unlink's use of FilePath.
02:46:20 <elliott> It seems to be making platform assumptions that are not necessarily true everywhere.
02:46:22 <unlink> Me too.
02:46:25 <elliott> I believe FilePath is already Unicode-decoded.
02:46:30 <elliott> RawFilePath is a ByteString on POSIX if you need it.
02:46:45 <unlink> That might be true if you're using a GHC newer than 7.0, which I'm not.
02:46:52 <elemir> @src FilePath
02:46:52 <lambdabot> type FilePath = String
02:47:09 <quicksilver> I do not think FilePath is ever decoded.
02:47:17 <elliott> Not even on Windows?
02:47:22 <quicksilver> ok maybe it is on windows
02:47:25 <elemir> String is unicode a priori
02:47:33 <quicksilver> yes, but FilePath is broken.
02:47:49 <quicksilver> due to the absence of a cross-platform agreement on a sensible way to implement FilePath
02:48:12 <quicksilver> on linux I'm pretty sure that filepath is just a sequence of bytes masquerading as a string
02:48:29 <quicksilver> (which GNOME/KDE both treat as UTF8 so that's emerging as a defacto standard)
02:49:43 <ChristianS> quicksilver: since a String is a sequence of chars, not of bytes, some decoding must be going on.
02:49:55 <elliott> "must"?
02:49:58 <quicksilver> ChristianS: no.
02:50:04 <quicksilver> ChristianS: I am telling you that it is stupid.
02:50:04 <elliott> "should must", perhaps.
02:50:17 <quicksilver> the string is actually undecoded bytes on linux
02:50:17 <unlink> (!! 2) <$> getDirectoryContents "."
02:50:18 <unlink> "\227\131\143\227\130\153\227\131\139\227\131\169\227\130\189\227\131\171\227\131\136"
02:50:20 <quicksilver> "FilePath is broken"
02:50:35 <quicksilver> it's broken because there is no single good solution under linux
02:50:43 <quicksilver> although, as I just said, UTF-8 is becoming a defacto standard.
02:51:17 <quicksilver> some discussion and a little bikeshedding in http://hackage.haskell.org/trac/ghc/ticket/3307
02:52:22 <unlink> and T.unpack $ E.decodeUtf8 $ C.pack of that is "\12495\12441\12491\12521\12477\12523\12488"
02:52:27 <elliott> GHC should just enforce UTF-8 and if someone really needs to handle wacky things they should use RawFilePath
02:52:36 <elliott> alternatively, use ByteStrings for everything. forbid interpretation of filenames
02:52:43 <elliott> (use UTF-16 encoded ByteString on Windows, UTF-8 encoded on Linux)
02:52:50 <zeiris> Problem: I've got some data tables (integer->string lookups for decoding protocol packets) and they're JUST big enough... For me to feel bad about encoding them as .hs files.
02:52:51 <elliott> that one will be unpopular, though, since you can't print filenames any more.
02:53:09 <zeiris> How do I load them into memory and use them... Without mucking things up with io, in what is a read-only access situation?
02:53:13 <elliott> zeiris: .hs files are a good encoding. that's what Read/Show is, after all
02:53:17 <elliott> zeiris: use template haskell
02:53:25 <elliott> to load them at compile-time
02:53:41 <elliott> quicksilver: "Fixed by 509f28cc93b980d30aca37008cbe66c677a0d6f6 to base."d
02:53:42 <zeiris> Huh. That's an interesting idea, Lisp style.
02:53:47 <elliott> quicksilver: did that fix still leave things broken?
02:53:50 <quicksilver> elliott: yes, but I don't know what the fix was
02:53:52 <elliott> zeiris: how big are they, kilobytes?
02:53:55 <quicksilver> elliott: or which GHC it went in to
02:54:08 <quicksilver> elliott: so, I don't know :)
02:54:08 <elliott> 10 months ago -> probably 7.4
02:54:33 <unlink> elliott: Apart from the horror that is UTF-8 filename under Mac OS X (!), do you hear any other WTFs screaming out in that code?
02:54:42 <zeiris> elliott: probably a few KB, yeah.
02:54:50 <yitz> quicksilver: i think the decision on these things is that on unix, filepath and args are decoded via the current encoding, and you can bypass that by using the new bytestring-based interface in System.Posix.
02:54:54 <elliott> zeiris: meh. keep 'em as .hs
02:54:59 <quicksilver> "There is now a raw bytestring version of the filepath and environment APIs. It uses a RawFilePath = ByteString type synonym"
02:55:03 <astor> zeiris: there is a template haskell solution for embedding arbitrary files at compile time
02:55:03 <quicksilver> is part of the 7.4 changelog
02:55:28 <quicksilver> the changelog doesn't mention any decision to arrange for non-raw filepaths to be decoded according to locale
02:55:31 <elliott> unlink: it looks basically ok to me. don't really have time to go through it in-depth, sorry
02:55:36 <elliott> unlink: may i suggest posting to http://codereview.stackexchange.com/questions/tagged/haskell?
02:55:45 <quicksilver> OK that's not quite true
02:55:52 <quicksilver> it is mentioned, just not in the 'filepath' section.
02:55:53 <yitz> quicksilver: there is some hack in effect that deals with broken unicode to attempt to get round-tripping nonetheless
02:55:54 <astor> zeiris: http://hackage.haskell.org/package/file-embed
02:56:00 <quicksilver> "The encodings used for the filesystem, for foreign calls, and for the locale, are now mutable. In order to alter them you need to use setLocaleEncoding, setFileSystemEncoding and setForeignEncoding from GHC.IO.Encoding"
02:56:04 <elemir> Guys, you make one error. You forgot setlocale
02:56:24 <quicksilver> so it seems like unlink could remove some of his utf8 hackery
02:56:26 <unlink> elliott: That's all I'm asking for, thanks.
02:56:26 <zeiris> astor: ooh, awesome :D
02:56:28 <quicksilver> if he upgraded to GHC 7.4
02:56:30 <quicksilver> which doesn't work.
02:56:34 <elemir> GHC mustn't enforce utf-8 locale
02:56:38 <quicksilver> but if it did, that would solve it.
02:57:08 <unlink> quicksilver: true, apart from the broken Haskell Platform, that is a far more elegant solution, I agree.
02:57:24 <yitz> foreign calls?
02:57:29 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-IO-Encoding.html#v:setFileSystemEncoding
02:57:54 <elliott> elemir: who would care if it did? Windows I guess
02:58:11 <quicksilver> elemir: well it doesn't, anyhow.
02:58:24 <elemir> Windows uses utf16 as default
02:58:27 <quicksilver> yitz: CString based APIs which assume particular encodings in practice, I think.
02:58:34 <yitz> ugh
02:58:40 <quicksilver> yitz: not sure what APIs do that.
02:58:51 <quicksilver> perhaps some parts of libc do?
02:59:11 <elliott> elemir: i already said windows :p
02:59:12 <elemir> POSIX default locale is ANSI
02:59:26 <elliott> so?
02:59:54 <elliott> i mean, to some degree POSIX is relevant. but things POSIX says are not relevant solely because POSIX says them
02:59:59 <elemir> GHC tries to decode your utf-8 shit as ANSI. FAIL
03:00:34 <quicksilver> you're not really making any sense, elemir
03:00:42 <quicksilver> GHC doesn't enforce utf-8
03:00:44 <quicksilver> do you have a point?
03:00:56 <yitz> elemir: on most real posix-like OSes the default is to set the locale to some UTF-8 thing. So the POSIX default for when the locale isn't set at all becomes irrelevant.
03:01:53 <merijn> elemir: Isn't the default locale c?
03:02:05 <elemir> C is ANSI, really
03:04:16 <elliott> is "ANSI" even well-defined?
03:04:44 <svark> @pl \x y z -> x:y:z:[]
03:04:45 <lambdabot> (. ((. return) . (:))) . (.) . (:)
03:05:00 <merijn> There's is no specification for the high bit values of chars, I think?
03:05:05 <elliott> svark: \x y z -> [x,y,z]
03:06:22 <yitz> http://stackoverflow.com/questions/701882/what-is-ansi-format
03:08:02 <yitz> technically, ansi==ascii, but it was abused for so many years to mean a certain 8-bit encoding that was the default on windows that most people now mean that when they say "ansi", even though the ansi organization had nothing to do with it.
03:08:06 <elliott> right
03:08:17 <elliott> so, I conclude "C is ANSI, really" is not even remotely true :P
03:18:06 <mauke> C is ISO
03:21:51 <franco00> I am using System.Console.ANSI 's setCursorPosition, but I get a bloody error (and rightly so) when I put it "outside" the console. Is there a way to check the bounds (height/width) of the console?
03:21:58 <franco00> I can't find the function
03:24:14 <wferi> Hi mornfall, cabal install cmdlib mtl-1.1.0.2 failed for me with "No instance for (Monad (Either CommandWrap)) at System/Console/CmdLib/Command.hs:240:19-27"
03:26:37 <elemir> franco00: http://en.wikipedia.org/wiki/ANSI_escape_code
03:27:12 <elemir> franco00: Try to find escape code for it ;)
03:27:33 * hackagebot msgpack 0.7.1.3 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.7.1.3 (HideyukiTanaka)
03:27:40 <elliott> franco00: there's no such function
03:27:58 <elliott> ansi-terminal is a bit... limited
03:28:40 <quicksilver> getScreenSize = return (80,24)
03:28:46 <quicksilver> job done!
03:28:50 <franco00> elliott, but how can stuff like (me being a naivete) weechat or vim  manage to "print just in the screen"
03:28:51 <franco00> hahaha quicksilver
03:29:13 <mauke> franco00: they don't use ansi codes
03:29:35 <elliott> franco00: they don't use ansi-terminal, for one
03:29:42 <elliott> but yes, they use less portable things to get the height/width
03:29:50 <elliott> you may be best off just assuming 80x24
03:29:55 <franco00> then I will rephrase: what is a simple, no frills, possibly portable library which will allow me to get terminal width/height?
03:30:06 <elemir> franco00: vty
03:30:36 <elemir> Powerful ncurses-based library
03:30:44 <quicksilver> franco00: consider vty
03:30:48 <mroman> Maybe with ncurses,hcurses.
03:30:49 <mauke> anything ncurses-based is not simple
03:30:51 <franco00> Uses the TIOCGWINSZ ioctl to find the current window size, which appears to be limited to Linux and *BSD.
03:31:07 <mroman> nvm. my screen buffer was out-of-date.
03:31:10 <elliott> elemir: vty is not ncusrses-based.
03:31:15 <elliott> *ncurses
03:31:17 <elliott> or indeed curses-based.
03:31:32 <elliott> but there's hscurses
03:31:37 <elemir> > vty is terminal GUI library in the niche of ncurses.
03:31:38 <lambdabot>   <no location info>: parse error on input `in'
03:31:44 <elliott> in the niche
03:31:50 <elliott> it's not ncurses-based
03:31:55 <elliott> it just serves the same purpose
03:32:14 <franco00> I thought that, if I could make that "setPosition" function fail without calling "error", I could "guess" width/height
03:32:18 <elemir> It must be termcap/terminfo-based
03:32:39 <elliott> nope
03:32:49 <elliott> it uses ansi escapes
03:33:06 <elliott> franco00: you can catch IO exceptions
03:33:27 <franco00> naaa that would be messy, I feel
03:34:06 <mauke> franco00: what error do you get?
03:34:23 <elemir> elliott: https://github.com/coreyoconnor/vty/tree/68b337220438b276e8f45a7047508d6fda58f8dc/src/Data/Terminfo
03:34:32 <elemir> What is it?
03:35:24 <elemir> ANSI codes sucks. So it uses terminfo databases. Terminfo is a part of ncurses now.
03:35:25 <franco00> *** Exception: setConsoleCursorPosition: invalid argument (Parametro non corrett o.) mauke
03:35:56 <mauke> that's not setCursorPosition
03:36:12 <elliott> elemir: hmm, that must be new from the last time i checked it.
03:36:29 <franco00> that *is* setCursorPosition
03:36:31 <elliott> saying vty is ncurses-based because it happens to parse terminfo files, and the canonical terminfo library is maintained as part of ncurses, is ridiculous
03:36:51 <franco00> which in turn calls consoleSetCursorPosition
03:38:16 <mauke> sec, hackage is being stupid
03:39:24 <mauke> franco00: no, it doesn't
03:39:36 <franco00> I am on a win machine mauke
03:39:41 <franco00> does that help?
03:39:52 <franco00> http://msdn.microsoft.com/en-us/library/windows/desktop/ms686025(v=vs.85).aspx
03:39:58 <mauke> not really
03:40:09 <mauke> that's not consoleSetCursorPosition either
03:40:13 <mauke> that's SetConsoleCursorPosition
03:41:42 <franco00> Ok, I will restate: when I call "setCursorPosition 900 2" I get this printed on the terminal "*** Exception: setConsoleCursorPosition: invalid argument (Parametro non corrett o.)"
03:42:03 <mauke> argh, you mistyped the second time
03:42:16 <franco00> where?
03:42:38 <mauke> <franco00> which in turn calls consoleSetCursorPosition
03:42:51 <franco00> ouch, yeah
03:44:10 <wferi> Hi morfall, could you please comment about cmdlib vs. mtl-1? cabal install cmdlib mtl-1.1.0.2 fails with "No instance for (Monad (Either CommandWrap)) at System/Console/CmdLib/Command.hs:240:19-27", is this a wrong dependency or something else?
03:45:23 <elliott> preflex: xseen mornfall
03:45:23 <preflex>  mornfall was last seen on freenode/#darcs 4 days, 18 hours, 19 minutes and 25 seconds ago, saying: But you certainly can't just take a new h-s and old darcs and expect it to work, much less fix problems.
03:45:28 <elliott> wferi: they're afk.
03:45:33 <elliott> wferi: use @tell
03:47:01 <mauke> franco00: fun. getConsoleScreenBufferInfo is in System.Console.ANSI.Windows.Foreign but it's not exported
03:47:25 <wferi> thanks, elliott. I misread mromans nick and thus thought he was around.
03:47:37 <elliott> wferi: hehe :)
03:48:02 <franco00> interesting to know mauke !
03:53:45 <idnar> is there any way to get from, say, http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Either to the location the Functor / etc. instances are defined
03:54:13 <rostayob> idnar: not from haddock, afaik.
03:58:21 <elliott> idnar: if they're not orphans, they're either in the class source
03:58:26 <elliott> or the definition of the Either source
03:58:30 <elliott> so there's only two links to check
03:59:38 <idnar> I think the Functor instance is an orphan, though? or is it just the Monad instance?
04:00:11 <astor> will ghc do common subexpression elimination in 99% of cases, or does it make sense to "help" using named 'where' equations?
04:00:36 <idnar> well, either way, I can't actually find the instance
04:00:50 <elliott> astor: Definitely not 99%. I'd add a local definition, depending on the computation
04:00:58 <elliott> what's the common subexpression in question?
04:01:15 <mauke> astor: it will do it in 1% of cases
04:01:37 <astor> mauke: :-)
04:02:37 * hackagebot alex-meta 0.3.0.2 - Quasi-quoter for Alex lexers  http://hackage.haskell.org/package/alex-meta-0.3.0.2 (JonasDuregard)
04:02:57 <astor> elliott: that's surprising.  with immutable data it should be very few exceptions which cse would have to avoid.
04:03:13 <quicksilver> astor: CSE causes terrible space behaviour
04:03:16 <quicksilver> that's why GHC doesn't do it.
04:03:32 <wferi> how do I cabal install an already cabal built package with a forced alternative dependency?
04:04:01 <astor> quicksilver: how?
04:04:16 <dmwit> cabal install --reinstall --constraint "otherpackage = 42.69.0"
04:04:27 <Tinned_Tuna> Why do most haskell data types (e.g. lists, vectors...) use Ints (which can overflow and wrap) as opposed to Integers? I would've thought that is an ugly wart, considering the purity of the rest of the language?
04:04:27 <elliott> astor: It can introduce space leaks.
04:04:33 <Tinned_Tuna> Is it just performance?
04:04:36 <elliott> astor: Compare:
04:04:41 <dmwit> Tinned_Tuna: Yes, just performance.
04:04:46 <elliott> astor: length (mkHugeList 1000) / sum (mkHugeList 1000)
04:04:52 <elliott> astor: let xs = mkHugeList 1000 in length xs / sum xs
04:05:10 <elliott> first one gets the list created and eaten as it goes incrementalyl, second one holds xs in memory throughout
04:05:11 <elliott> *incrementally
04:05:19 <dmwit> Tinned_Tuna: Int is about four times as fast as Integer for most operations, and usually big enough to cover the address space of the machine in question anyway.
04:05:23 <elliott> quicksilver: ("doesn't do it" is a bit strong I think :P)
04:05:44 <elliott> Tinned_Tuna: We've no shortage of warts. Overusage of Int is one.
04:05:48 <rostayob> Tinned_Tuna: what about the ugly wart of using integers where you actually need naturals :)?
04:05:57 <astor> elliott: thanks for the example.  that does make sense.
04:06:03 <elliott> (Using Integer for most things in protest is not worth it because you end up converting back and forth to use standard functions.)
04:06:14 <quicksilver> elliott: it is a bit strong, perhaps. But the situations in which GHC will CSE are AFAIK very limited.
04:06:35 <elliott> quicksilver: agreed, though less limited than I used to think they were apparently
04:08:09 <wferi> dmwit: thanks, but I get cabal: dependency expected (tried with -, with and without = and spaces)...
04:09:04 <dmwit> wferi: probably needs ==
04:09:15 <wferi> that's it
04:09:24 <wferi> I just found it :)
04:09:31 <wferi> thanks for the tip, dmwit!
04:10:06 <dmwit> Beware that any packages that depend on the one you're reinstalling will be broken.
04:10:22 <dmwit> Run "ghc-pkg check" after the installation to have GHC do a sanity check.
04:10:44 <wferi> I didn't reinstall, it's a fresh install
04:13:27 <dmwit> You probably didn't need --reinstall then, and I apologize for misunderstanding the question.
04:13:35 <dmwit> You could have gotten away with a much tamer command. =)
04:14:00 <wferi> I didn't include --reinstall
04:14:11 <wferi> and tried --preference as well, which wasn't enough
04:15:06 <wferi> so your answer was most valuable for me, thanks again!
04:17:38 * hackagebot BNFC-meta 0.3 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.3 (JonasDuregard)
04:21:01 <Tinned_Tuna> rostayob: Naturals are useful for this problem, but not perfect...
04:21:53 <Tinned_Tuna> dmwit: How come there aren't Integer variants of the usual indexing & length operations. That'd be so nice, because I regularly find myself re-writing length and (!!) to take Integers.
04:22:18 <Jafet> @hoogle generic
04:22:18 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
04:22:18 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
04:22:19 <lambdabot> Data.List genericLength :: Num i => [b] -> i
04:22:43 <Tinned_Tuna> Jafet: <3
04:22:53 <Jafet> Also let mung = fromIntegral
04:23:38 <rostayob> Tinned_Tuna: well it's still annoying that there are no efficient natural numbers. for example for indexing (!!) an integer doesn't make sense either
04:24:17 <elliott> and lists can't have negative length
04:24:25 <worldsayshi> A question to anyone: I'm setting up my dev environment where I will work on three projects where one depends on the two others. I want to be able to make changes to the dependencies while I work. How do I make the imports of my dependent project resolve to the path of my two other projects when building?
04:24:36 <Jafet> rostayob: why doesn't it make sense?
04:24:45 <Tinned_Tuna> rostayob: oh yea, but Naturals are just a sub-set of Integers, so it should be trivial to implement a Natural datatype, given Integers.
04:25:03 <elliott> yeah. and then in 2015
04:25:09 <elliott> "why do length and (!!) use Integer, not Natural?!"
04:25:18 <elliott> "this is stupid! who designed this?"
04:25:28 <Jafet> Why isn't length dependently typed already
04:25:33 <rostayob> Jafet: what does [1, 2] !! (-1) mean?
04:25:34 <Jafet> Damned committees
04:25:46 <rostayob> Tinned_Tuna: yeah but it's not there.
04:25:49 <Jafet> rostayob: it is undefined
04:26:01 <Jafet> rostayob: have a problem with that?
04:26:03 <Tinned_Tuna> Not that it's stupid -- more that I always see Haskell as pure, but occasionally stumble of warts. It makes me sad.
04:26:04 <rostayob> Jafet: we like total functions don't we?
04:26:22 <Jafet> rostayob: what does [1, 2] !! 2 mean?
04:26:34 <Jafet> You're being very selective about what totality means, aren't you.
04:26:40 <rostayob> Jafet: that is a problem which is harder to solve.
04:26:58 <rostayob> while having a natural type in haskell is trivial
04:27:07 <Jafet> It is. So go write it already.
04:27:13 <elliott> people have written it before
04:27:17 <elliott> that does not fix the Prelude
04:27:22 <Jafet> We'll see how many real problems it solves.
04:27:32 <rostayob> yeah that's my whole point. the prelude has many warts at the type level
04:27:38 <elliott> that sounds like the kind of rationale people use to use java/c++/whatever
04:27:45 <elliott> after all, how many real problems can haskell's pedantic type system solve?
04:27:58 <rostayob> Jafet: I'd be much happier with a standard naturals type in many occasions...
04:28:12 <Tinned_Tuna> Jafet: it's not "real" problems, it's making the language match up as best as possible with what the programmer intends.
04:28:35 <Tinned_Tuna> for example, when I use an Int, I generally don't want an overflow; so I use an Integer
04:28:51 <Tinned_Tuna> but a lot of functions don't take an Integer.
04:29:18 <elliott> Tinned_Tuna: my advice with current haskell is to use Int unless you know you need the extra range. like i said, it's not worth the effort
04:29:22 <Jafet> I just don't understand what makes one aspect of a problem imperative to solve simply because it is easy to solve.
04:29:41 <Jafet> Like I said, using Natural won't make (!!) any more total than it currently is.
04:29:47 <elliott> Jafet: "fixing warts is pointless unless we get dependent types!"
04:30:04 <rostayob> Jafet: lol, "imperative to solve", never said that. it'd still be really useful
04:30:20 <Jafet> Besides, you're just shuffling the problem off somewhere else. Now (-) is not total.
04:30:36 <Tinned_Tuna> I just think that as a policy, we should use Integer more on code with developers are likely to use. Hopefully, less developers would be bitten by the limits of the Int then.
04:30:56 <rostayob> Jafet: that's not shuffling the problem somewhere else, it's just using the right datatype for what you need to do.
04:31:03 <elliott> Tinned_Tuna: people will be bitten by the limits of Int as long as converting to and from Int is necessary
04:31:23 <elliott> since it is, there's no real point in using Integer unless you need it nowadays
04:32:05 <quicksilver> the reason that Int is the default is that Int is about 1,000,000 times faster than Integer
04:32:20 <quicksilver> if Integer wasn't so incredibly crawlingly slow, it might be easier to make Integer a default
04:32:28 <quicksilver> but some people try to write fast code in haskell...
04:33:11 <elliott> is the slowness because of gmp or primop overhead?
04:33:11 <worldsayshi> found it: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/separate-compilation.html#search-path
04:33:25 <quicksilver> the answer to that is complicated, elliott
04:33:35 <Jafet> rostayob: but what makes Natural more "right" than Integer? It doesn't change the behaviour of any list functions involving Integer
04:33:35 <Tinned_Tuna> My point is that we should try to (as a policy, not a hard limit) default to a safe datatype, and let people use Int when they really need the speed.
04:33:51 <Tinned_Tuna> but that Int comes with a health warning.
04:33:54 <elliott> quicksilver: that's why i asked :P
04:33:56 <rostayob> Jafet: ? because an index can't be negative
04:34:05 <elliott> Tinned_Tuna: i agree in an ideal world. in today's world using Int is much less pain
04:34:07 <rostayob> I don't understand what's so confusing about this
04:34:28 <elliott> Jafet: you're basically saying that, since we can't eliminate all bad inputs, we shouldn't eliminate any
04:34:30 <elliott> therefore
04:34:32 <quicksilver> elliott: well, it's partly gmp, and it's partly the way the primops work, and it's partly about strictness and unboxing, and it's probably somewhat about Cmm and how compilation works.
04:34:35 <elliott> (!!) :: [a] -> Dynamic -> a
04:34:38 <Tinned_Tuna> elliott: depends how big your input size is ;-)
04:34:46 <rostayob> elliott: lol
04:34:54 <elliott> Tinned_Tuna: right, unless you need it
04:35:17 <Jafet> I'm basically saying that changing Integer to Natural is purely cosmetic
04:35:37 <Jafet> All partial functions remain partial; they have the same input and output values...
04:35:44 <Tinned_Tuna> Jafet: it is purely cosmetic if you only consider a function as total or not
04:35:47 <rostayob> Jafet: what? no it isn't, you have less chance to screw up
04:35:55 <elliott> (BTW, this only helps if we fix Num.)
04:35:57 <Tinned_Tuna> i.e. if the debate is black-and-white
04:36:02 <elliott> (Right now, (-2 :: Natural) works.)
04:36:21 <quicksilver> I don't recall ever seeing a program bug caused by a negative index to !!
04:36:24 <elliott> (Hey, you know what sucks? fromInteger/fromString execute at runtime.)
04:36:24 <Jafet> How does it decrease my chance of screwing up?
04:36:31 <Jafet> rostayob: facts, not handwaving.
04:36:33 <quicksilver> whereas I've seen plenty where the index was > length of list.
04:36:49 <quicksilver> so I think forbidding negative indices to !! is solving what is a marginal problem at best.
04:36:54 <rostayob> Jafet: ...because you can't provide a negative index
04:37:05 <elliott> this is a really stupid discussion
04:37:08 <rostayob> i'm tired of this discussion. I don't even care about this
04:37:12 <elliott> Jafet knows it eliminates a certain class of inputs
04:37:16 <Jafet> Yes, you've eliminated half of an infinite set of invalid inputs. Congratulations
04:37:20 <elliott> rostayob knows the bugs aren't likely
04:37:27 <Jafet> And quicksilver notes that it's the far less probable half
04:37:38 <elliott> you two have differing cost-benefits on changing the type, simple as that
04:38:05 <rostayob> Jafet: in the same way that + for Int is partial but most of the times you don't care. that's all I wanted to point out
04:38:14 <quicksilver> what I'm saying is that in the enormous rich pasture of cases where the haskell type system fails to restrict things as much as you might hope
04:38:16 <Jafet> No, it isn't partial.
04:38:27 <rostayob> well, right
04:38:32 <quicksilver> you have chosen the least relevant, least interesting, least useful-to-solve example.
04:38:38 <rostayob> it doesn't work, more than being partial
04:39:26 <Jafet> Int corresponds to a platform's signed word.
04:39:41 <Jafet> It is not a fisher-price edition of Integer.
04:39:41 <elliott> quicksilver: it might help to remember the context
04:39:50 <elliott> in which Tinned_Tuna was upset that length/(!!) use Int rather than Integer
04:39:56 <rostayob> quicksilver: ok, I repent, I'll sin no more, I just wanted to point out that the types in the Prelude are not always the most appropriate
04:40:06 <elliott> rostayob was just saying that it's pointless to change them to Integer, and *if we were going to change them*, Natural would be far more appropriate
04:40:16 <elliott> surely we can all agree that, were we to change from Int, Natural would be better than Integer.
04:40:32 <elliott> it's not like rostayob just came out of nowhere saying (!!) must use Natural tomorrow :p
04:41:09 <Jafet> We already have Integer, it has a Num instance, that instance is total, and we already have list operations using Integer
04:41:09 <rostayob> elliott: thanks ehe
04:41:14 <quicksilver> but it's not true.
04:41:20 <quicksilver> Natural wouldn't be better than Integer.
04:41:31 <Jafet> And all those list operations work as well as they possibly could
04:41:46 <Tinned_Tuna> I'm not really upset, it's just something that I commonly trip up on. I think the solution for me at the minute is to change to using Data.List generic functions
04:41:47 <elliott> can we all just agree to stop this? of all the incredibly tedious minutiae that have been discussed in here, this is the most ridiculous
04:41:50 <quicksilver> the reason that Tinned_Tuna wanted an Integer was not specifically that he wanted the most precise type.
04:42:03 <quicksilver> the reason Tinned_Tuna wanted an Integer was interoperability
04:42:12 <quicksilver> he wanted to do arithmetic with other Integers he already had
04:42:20 <quicksilver> Natural would be less interoperable and therefore less useful.
04:42:23 <Tinned_Tuna> (which could possibly be large)
04:42:37 <quicksilver> I can certainly agree it's a stupid discussion.
04:42:58 <Tinned_Tuna> I was mainly wondering if there was a reason for it, beyond the performance issues.
04:47:41 * hackagebot AhoCorasick 0.0.1 - Aho-Corasick string matching algorithm  http://hackage.haskell.org/package/AhoCorasick-0.0.1 (SergeyLymar)
06:38:22 <gregATio> new version package installation system thats even better than package.el but i cant remember what its called , does anyone know?
06:40:03 <shepheb> what are the policies on getting lambdabot to join more channels?
06:42:06 <elliott> shepheb: you ask Cale
06:50:12 <fbern> hi!
06:50:22 <Tinned_Tuna> morning?
06:50:38 <fbern> i'm failing to install cmdargs
06:51:10 <fbern> cabal unpack cmdargs & cabal configure & cabal build
06:51:25 <fbern> error: System/Console/CmdArgs/Test/Implicit/Tests.hs:1:1:
06:51:25 <fbern>     cannot find normal object file `dist/build/cmdargs/cmdargs-tmp/System/Console/CmdArgs/Implicit.o'
06:52:04 <fbern> i'm using ghc 7.4.1
06:52:36 <fbern> what am i doing wrong? any hint appreciated.
06:53:19 <fbern> @Tinned_Tuna morning? it's afternoon here :)
06:53:19 <lambdabot> Unknown command, try @list
06:55:54 <fbern> gregATio: have you tried 'el-get'
06:57:38 <ga2arch> hi =)
06:59:23 <fbern> hey
07:01:57 <fbern> the answer to my problem is:
07:02:31 <fbern> do not compile in profiling mode.
07:03:32 <fbern> eq. cabal configure -p (or if that does not help comment *-profiling in ~/.cabal/conf)
07:03:59 <fbern> the linking error is due to a bug in ghc
07:06:15 <scooty-puff> do overlapping instances work differently in ghci vs. ghc?
07:07:40 <shepheb> I'm still failing to build lambdabot. it fails on an error with ncurses when it tries to load readline.
07:09:33 <hpc> scooty-puff: they shouldn't; i know defaulting is different though
07:09:49 <hpc> which may or may not explain any differences you see
07:10:55 <scooty-puff> k - basically, when trying to use this: http://hpaste.org/65270 from ghci for an in-ghci data A = A, it fails with overlapping instances, however, if i define data A = A in the original file loaded into ghci, it works without overlpa
07:10:57 <scooty-puff> *overlap
07:11:15 <scooty-puff> (A := "string" #| empty) #. A gives the error, will make an hpaste
07:12:06 <scooty-puff> http://hpaste.org/65283
07:13:36 <roconnor> How does DiffArray's implementation handle backtracking?
07:14:43 <Saizan> it keeps some sort of log of past values
07:15:34 <ClaudiusMaximus> scooty-puff: http://hackage.haskell.org/trac/ghc/ticket/5820 might be relevant
07:15:43 <roconnor> Saizan: and going forward again?
07:15:58 <roconnor> i.e. updating a backtracked value
07:17:19 <Saizan> not sure
07:17:50 <Saizan> i suppose so
07:18:06 <scooty-puff> ClaudiusMaximus: thanks, that looks like its it
07:24:40 <shachaf> 2012-0 3-14
07:24:56 <shachaf> Er.
07:26:21 <elliott> quite
07:35:56 <tromp__> :t parens
07:35:57 <lambdabot> Doc -> Doc
07:38:52 <tromp__> can a where clause apply to multiple patterns in a function definition?
07:49:07 <parcs`> no, but it can apply to multiple guards
08:01:30 <augur> is it possible to do analysis of program behavior in some way to determine the paradigm it was written in?
08:25:01 <krey_> hello, is there a difference between a bifunctor and a functor w/ two arguments?
08:26:00 <elliott> depends what a function with two arguments is
08:26:05 <quicksilver> a functor with two arguments doesn't, a priori, mean anything
08:26:20 <quicksilver> although with a notion of categorical product you might take it to mean a functor from A x B to C
08:26:47 <krey_> quicksilver: that's the definition of a bifunctor (i think)
08:27:46 <krey_> say I have F(-,-) where F(-,id) is a functor and so is F(id,-). is that a bifunctor then?
08:27:48 <elliott> bifunctor is just bimap :: (a -> a') -> (b -> b') -> f a b -> f a' b'
08:28:04 <elliott> with obvious generalised laws from functor
08:28:16 <quicksilver> krey_: not without further conditions, no
08:28:25 <quicksilver> you've only restricted F on two 'axes'
08:28:35 <quicksilver> it could be completely non-functorial outside those places.
08:28:43 <quicksilver> with some quite natural naturality conditions, then yes.
08:28:49 <rwbarton> no because F(f, id) F(id, g) might not equal F(id, g) F(f, id)
08:28:50 <krey_> cool, that pretty much answers my question
08:29:05 <krey_> so what are the conditions?
08:29:23 <quicksilver> that a whole suite of "obvious" diagrams commute
08:29:58 <quicksilver> rwbarton's concrete example is one instance of such a diagram.
08:30:05 <rwbarton> just the condition i gave, i think
08:30:30 <krey_> can you guys come up with a quick counterexample?
08:30:40 <quicksilver> elliott: yes, indeed; you can either define bifunctors by making 'bimap' primitive, or you can define bifunctors by making product categories primitive.
08:30:47 <rwbarton> sure, there is a "universal" counterexample
08:31:00 <elliott> quicksilver: yeah.
08:31:00 <quicksilver> elliott: I can't immediately think of a strong reason to prefer one exposition over the other
08:31:07 <elliott> i chose bimap because it's the one the bifunctors package goes with
08:31:11 <elliott> and this is #haskell after all :p
08:31:12 <rwbarton> imagine the free category on the graph that's a "square"
08:31:19 <rwbarton> * - *
08:31:21 <rwbarton> |   |
08:31:22 <quicksilver> there are a lot of choices of order of exposition in CT>
08:31:23 <rwbarton> * - *
08:31:32 <rwbarton> with the arrows pointing down and to the right
08:31:51 <rwbarton> hmm
08:32:14 <rwbarton> I think this will work, now take A = B = {* -> *}
08:32:57 <krey_> rwbarton: set of arrows?
08:33:17 <rwbarton> I mean the category with two objects and one (nonidentity) arrow
08:33:25 <krey_> k
08:33:38 <rwbarton> C is the category I described earlier
08:33:58 <rwbarton> it has two different "diagonal" arrows obtained by going around the square in the two different ways
08:34:53 <rwbarton> A x B is the commutative square
08:35:07 <rwbarton> it doesn't map to C (functorially) in the obvious way
08:35:22 <rwbarton> but I think it has a map of your form "F(-,-) where F(-,id) is a functor and so is F(id,-)"
08:35:26 <worldsayshi> What happens if I "get" a darcs repo into another darcs repo and then move into that repo. Will my commands affect the inner repo then?
08:35:41 <rwbarton> that's how i'd try to construct a counterexample
08:35:49 <krey_> rwbarton: that's an awesome construction
08:36:03 <krey_> rwbarton: is this a general technique? has it a name?
08:36:25 <worldsayshi> Perhaps I should ask version control question somewhere else?
08:36:34 <parcs`> worldsayshi: i think so. try it out with darcs log
08:36:34 <albel727> #darcs
08:36:38 <rwbarton> krey_: well...
08:36:41 <snifi> I have a question about lists in Haskell: The list [1,"hello"] is illegal, but there is a way to go around, isn't there?
08:37:03 <parcs`> replace [] with ()
08:37:10 <krey_> snifi: existential types!
08:37:11 <rwbarton> I think that a functor "F(-,-) where F(-,id) is a functor and so is F(id,-)" is the same as a functor out of some kind of "product" of A and B in which arrows of A are not required to commute with arrows of B
08:37:20 <elliott> no, not existential types
08:37:33 <parcs`> that kind of existential is totally useless
08:37:42 <elliott> snifi: what's your real problem?
08:37:46 <rwbarton> so this construction is just noting that that "product" is not the same as the cartesian product, and this is the simplest case where they are different
08:38:03 <snifi> something like data A = Integer a | String b
08:38:17 <krey_> rwbarton: cool. i'ma sit down and write this up, verify, etc. thanks a lot :)
08:38:30 <snifi> now A is a type, could it be used in the list above
08:38:36 <rwbarton> yes, there is a lot that I didn't bother to verify that would be good to check :)
08:38:59 <snifi> so that [1,"hello"] :: [A]
08:39:17 <elliott> snifi: data A = AnInteger Integer | AString String
08:39:21 <parcs`> you can have [Left 1, Right "hello"] :: [Either Int String]
08:39:24 <worldsayshi> parcs`: What do you mean by darcs log?
08:39:24 <elliott> [AnInteger 1, AString "hello"] :: [A]
08:39:33 <parcs`> but you need the constructors there
08:39:38 <rwbarton> actually this kind of semi-free "product" is a minor interest of mine
08:39:50 <elliott> you can technically make this [1, AString "hello"], and [1, "hello"] with a GHC extension. however, this is very much not advisable, and I would question why you want such a thing.
08:40:56 <parcs`> worldsayshi: oh, i meant cding into the inner darcs repo and executing darcs log to determine which repo is darcs using within that directory
08:40:58 <snifi> Yes, you are right, I don't want to do it, but technically speaking, why is there such restriction?
08:41:09 <parcs`> but i'm pretty sure the inner one would be used
08:41:23 <parcs`> the one 'closest' to the cwd
08:41:27 <worldsayshi> parcs`: Ah, got it. Thanks.
08:42:49 <parcs`> snifi: what restriction?
08:43:01 <snifi> the need to use constructors
08:43:55 <elliott> It's not really a "restriction".
08:44:00 <elliott> "hello" is a String, not an A.
08:44:00 <snifi> [AnInteger 1, AString "hello"] vs [1::Integer, "hello":String]
08:44:16 <elliott> Well, what's the latter one got to do with A?
08:44:25 <snifi> oh
08:44:56 <snifi> [1::A, "hello":: A] is this ok?
08:45:25 <rwbarton> it's okay if and only if 1::A is okay and "hello"::A is okay
08:45:41 <rwbarton> which it could be with some extensions, but in general is not
08:45:52 <elliott> snifi: No.
08:46:25 <quicksilver> snifi: it's not OK because we want expressions to have well-defined types.
08:46:47 <quicksilver> so we want the type of "hello" to always be String - not to be String most of the time, but A when its used in certain constructs.
08:47:07 <rwbarton> (it also doesn't really save you anything--and what if A had two constructors with a field of the same type?)
08:47:15 <quicksilver> it's very convenient for reasoning about and scaling programs if you can rely on the type of a subexpression.
08:47:33 <parcs`> snifi: what would the value of 1::A be if data A = X Int | Y Int
08:48:00 <parcs`> oh rwbarton already mentioned that
08:48:35 <scooty-puff> snifi: if you really want to do it, you could make A and instance of the Num type class, and IsString type class (with OverloadedStrings)
08:48:57 <scooty-puff> but would still need data A = Integer Integer | String String
08:49:07 <snifi> So, there is a fundamental difference between 1:: Integer, and AnInteger as a constructor.
08:50:36 <quicksilver> scooty-puff: only that doesn't really do it.
08:50:46 <quicksilver> it overloads string literals (only), not actual strings.
08:50:58 <snifi> so, [AnInteger 2, AnInteger 3] can never mean [1::Integer,2::Integer]
08:51:20 <parcs`> 1 :: Int, AnInteger :: Int -> A, AnInteger 1 :: A
08:51:28 <dskippy1> Hello. I am having some trouble understanding Graphics.GD. I am trying to setPixel on a PNG image. The colors I can create from the library functions seem to not match the functions that accept them.
08:52:02 <snifi> ok, I think I understood now. Thanks!
08:52:24 <dskippy1> Color is a CInt and there's a function "rgb :: Int -> Int -> Int -> Color" which produces CInts from 0 - 256^3
08:52:31 <elemir> :t (,)
08:52:32 <lambdabot> forall a b. a -> b -> (a, b)
08:52:35 <elemir> Hem
08:52:46 <dskippy1> However setPixel paints my image black for any CInt color that is not in the range of 0-60
08:52:58 <elemir> :t ((1,2),3) == (1,2,3)
08:52:59 <lambdabot>     Couldn't match expected type `((t, t1), t2)'
08:52:59 <lambdabot>            against inferred type `(t3, t4, t5)'
08:52:59 <lambdabot>     In the second argument of `(==)', namely `(1, 2, 3)'
08:53:06 <elemir> :t (1,(2,3)) == (1,2,3)
08:53:07 <lambdabot>     Couldn't match expected type `(t, (t1, t2))'
08:53:07 <lambdabot>            against inferred type `(t3, t4, t5)'
08:53:07 <lambdabot>     In the second argument of `(==)', namely `(1, 2, 3)'
08:53:09 <elemir> :(
08:53:31 <dskippy1> How could Graphics.GD have a setPixel that only accepts colors 0-60 but have a color constructor that produces 0-256^3?
08:55:09 <elemir> How does (,) really work?
08:55:26 <parcs`> :t (,)
08:55:27 <lambdabot> forall a b. a -> b -> (a, b)
08:55:33 <parcs`> like that
08:55:35 <elemir> No
08:56:03 <elemir> (1, 2, 3) isn't ((1,2),3) or (1,(2,3))
08:56:35 <parcs`> (1, 2, 3) is sugar for (,,) 1 2 3
08:56:39 <parcs`> :t (,,)
08:56:39 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
08:56:45 <elemir> :t (,,,,,,,,,,,,,,,,,,,,)
08:56:45 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n,
08:56:46 <lambdabot> o, p, q, r, s, t, u)
08:56:51 <elemir> Dou
08:57:51 <elemir> N-ary operators aren't normal
08:58:02 <elliott> It's not N-ary.
08:58:08 <elliott> It's a whole bunch of fixed-ary operators.
08:58:15 <elliott> The report only guarantees 15 IIRC.
08:58:33 <elemir> I understand that N is fixed
08:58:56 <elemir> But 100-ary operator! Or may be 1000-ary?
08:59:12 <etpace> whats wrong with that elemir?
09:00:14 * elemir is perfectionist
09:00:41 <merijn> elemir: Compiler built-in, I believe GHC implements tuples up to 62 elements
09:00:47 <edwardk> elemir: complaining about (,,,,,)'s?
09:01:09 <edwardk> elemir: you can always make your own tuple type with an HList that is fully generic and extensible
09:01:19 <edwardk> it'll have a crappy representation, but there you go
09:01:43 <edwardk> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
09:01:44 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
09:01:44 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 ->
09:01:44 <lambdabot> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 ->
09:01:44 <lambdabot> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37,
09:01:44 <lambdabot> t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69, t70)
09:01:55 <mux> holy jeebus
09:02:30 <edwardk> that appears to have more than 62 elements ;)
09:02:33 <elemir> http://dump.bitcheese.net/images/ocyxuko/crutch_bike.jpeg
09:03:54 <edwardk> besides that forall only has a few more variables than some recursion schemes I've seen ;)
09:04:27 <merijn> edwardk: What you've seen hardly qualifies as a measure of ordinary programming style
09:04:38 <ciaranm> now where's my curry62 and uncurry62?
09:04:39 <elliott> edwardk: it typechecks
09:04:42 <elliott> but it won't actually run
09:04:44 <elliott> if you try and use it, iirc
09:04:44 <edwardk> =)
09:04:47 <edwardk> fair enough
09:05:08 <merijn> Unless Agda is now enterprise
09:05:16 <merijn> Agda2EE :>
09:05:24 <ciaranm> (a, b, c) should clearly be (a, (b, c)) anyway
09:05:29 <nand`> ObjAdga
09:05:32 <elemir> ciaranm++
09:05:33 <nand`> s/dg/gd/
09:05:35 <merijn> ciaranm: No
09:05:51 <merijn> (a, (b, c)) has a completely different complexity
09:05:56 <elemir> At SML it is
09:06:11 * elliott wonders what merijn means by complexity.
09:06:12 <merijn> Which probably won't matter for three entries, but for large numbers of entries it does
09:06:18 <merijn> elliott: Accessing elements
09:06:23 <elemir> http://www.cs.cornell.edu/courses/cs312/2004fa/lectures/lecture3.htm
09:06:25 <elliott> Only if you don't do polymorphic unboxing :)
09:06:35 <elliott> The strictness properties are more worrying.
09:06:42 <elliott> In that (a, _|_) has no corresponding 3ple.
09:06:52 <merijn> Getting the first element of (a,b,c,...) is O(1), in (a, (b, (c,...))) it is O(n)
09:07:06 <elliott> merijn: That's just not necessarily true, if you unbox the latter.
09:07:16 <elliott> There are no infinite types, so there's nothing stopping it.
09:07:22 <elliott> GHC can't do it, though
09:07:49 <merijn> hmm, maybe
09:07:53 <merijn> Anyway, I need to run
09:08:08 <srhb> Is there any regular way of transforming stateful divide-and-conquer algorithms to a functional algorithm? I seem to be running into this a lot in classes.
09:08:23 <srhb> Especially the divide step.
09:08:31 * ciaranm hands srhb a state monad
09:08:39 <srhb> ciaranm: Thanks, but that's totally cheating. :-)
09:08:48 <ciaranm> how so?
09:09:13 <srhb> Well, it's not, but I was wondering if there was a more general approach than saying "ok, we need state". But I suppose that is a too general question in itself.
09:09:28 <ciaranm> the state monad isn't really "state"
09:09:46 <ciaranm> it's something that looks like state that isn't state
09:09:54 <elemir> State monad isn't really silver bullet
09:10:06 <dskippy1> ciaranm: Like Washington, D.C.
09:10:13 <elliott> Sure it's state.
09:10:19 <dskippy1> Something that looks like a state, but it's not a state.
09:10:20 <elliott> The State monad precisely gives you one chunk of global state.
09:10:51 <ciaranm> if state isn't a silver bullet, is reverse state an lsd-coated bullet?
09:12:06 <elemir> ciaranm: You should rewrite stateful data to lazy functional data.
09:12:54 <elemir> State monad can't help you with it
09:14:31 <quicksilver> some divide and conquer algorithms can be cleverly encoded as dynamic programming.
09:14:41 <quicksilver> others naturally present themselves as recursion schemes
09:20:00 <mm_freak> i think whether a state monad is the way to go depends on the 'conquer' step
09:20:32 <mm_freak> i.e. whether one division's result is dependent on another divisions result
09:20:56 <elemir> Is there some fast pure implementation of A* at haskell?
09:21:22 <dskippy1> Does anyone think that the values returned from Graphics.GD.rgb disagreeing with the value range accepted by Graphics.GD.setPixel could possibly be due to integer size on my machine or something?
09:23:39 <parcs`> elemir: there's a package on hackage
09:23:54 <parcs`> http://hackage.haskell.org/package/astar
09:24:50 <Mathnerd314> @djinn (forall a. (b -> a) -> a) -> b
09:24:51 <lambdabot> -- f cannot be realized.
09:25:55 <Mathnerd314> hmm...
09:26:47 <rostayob> How can I generate "top level" documentation in haddock like the one in hackage packages?
09:26:54 <rostayob> e.g. a description of what the package does
09:27:04 <rostayob> but possibly a method indipendent from cabal
09:27:11 <rostayob> I just want to put some text in the "index.html" file
09:27:59 <rostayob> oh, maybe it's -p
09:28:01 <rostayob> "prologue text"
09:29:24 <elemir> parcs`: Is it really fast?
09:29:55 <parcs`> dunno
09:30:09 <parcs`> it's probably fast enough :)
09:30:22 <Mathnerd314> :t ($id) `asTypeOf` (undefined :: (forall a. (b -> a) -> a) -> b)
09:30:23 <lambdabot>     Couldn't match expected type `(a -> a) -> b'
09:30:23 <lambdabot>            against inferred type `forall a1. (b1 -> a1) -> a1'
09:30:23 <lambdabot>     In the second argument of `asTypeOf', namely
09:31:21 <rostayob> yep, it's -p.
09:36:17 <Mathnerd314> @type (\f -> f id) :: (forall a. (b -> a) -> a) -> b
09:36:18 <lambdabot> forall b. (forall a. (b -> a) -> a) -> b
09:36:20 <Mathnerd314> @type ($ id) :: (forall a. (b -> a) -> a) -> b
09:36:21 <lambdabot>     Couldn't match expected type `forall a. (b -> a) -> a'
09:36:21 <lambdabot>            against inferred type `a -> b1'
09:36:21 <lambdabot>     In the expression: ($ id) :: (forall a. (b -> a) -> a) -> b
09:36:46 <Mathnerd314> what happened to referential transparency....?
09:37:25 <napping> @type ((\f x -> f x) id)
09:37:26 <lambdabot> forall a. a -> a
09:37:38 <elliott> Mathnerd314: that has nothing to do with RT
09:37:39 <Chaze> va
09:37:58 <Mathnerd314> @pl \f -> f id
09:37:59 <lambdabot> ($ id)
09:38:15 <elliott> Mathnerd314: it's just what happens when you have rank-2 types. compare the fact that you can't translate many SK-based combinators directly to haskell because they don't type
09:38:21 <elliott> (but can implement them directly)
09:40:02 <eyebloom> Ugg, I'm getting this error from GHC:     Couldn't match expected type `GL.Vertex4 GL.GLfloat'
09:40:02 <eyebloom>                                                                                                with actual type `GL.Vector4 GL.GLfloat'
09:40:14 <eyebloom> any ideas?
09:40:33 <elliott> eyebloom: one of them has a smudge of dirt.
09:40:39 <elliott> try cleaning your screen and recompiling
09:40:40 <elliott> wait
09:40:43 <elliott> eyebloom: "Vertex" =/= "Vector"
09:40:50 <eyebloom> Aha
09:41:07 <elliott> i believe i've heard of errors where GHC actually complains that it can't match A with A though
09:41:18 <eyebloom> Sorry, been coding all morning.
09:41:39 <eyebloom> Thanks for the fresh eyes.
09:45:56 <quicksilver> elliott: yes, "Couldn't match expected type `ByteString` with actual type `ByteString`" was at one point a common frustration
09:46:06 <quicksilver> I believe that's not a problem any more thought.
09:46:26 <quicksilver> it even includes the package version if that is required to explain why the types are not in fact the same.
09:50:54 <Mathnerd314> elliott: RT means I can replace an expression with its value and not change the program. in this case I can replace ($id) with \f -> f id, and program behavior changes.
09:51:21 <elliott> Mathnerd314: that doesn't hold though
09:51:31 <elliott> because in context ($id) and (\f -> f id) don't have the same type
09:51:49 <Mathnerd314> :t ($id)
09:51:49 <lambdabot> forall b a. ((a -> a) -> b) -> b
09:51:51 <elliott> if you must always be able to replace an expression by its definition without any type annotation or anything then even standard haskell violates this rule
09:51:55 <elliott> Mathnerd314: "in context" for a reason
09:51:56 <Mathnerd314> :t (\f -> f id)
09:51:57 <lambdabot> forall a t. ((a -> a) -> t) -> t
09:52:08 <Mathnerd314> since when does context affect type?
09:52:34 <elliott> since rank-2 types
09:53:13 <Mathnerd314> I doubt it
09:53:36 <rostayob> are there pragmas in Hugs? or can I have a local configuration?
09:54:01 <elliott> Mathnerd314: what do you doubt?
09:54:09 <elliott> your example is nothing new.
09:54:17 <donri> so i just realized what leksah is backwards; what do i win?
09:54:45 <elliott> donri: the missing l
09:54:56 <Mathnerd314> elliott: I doubt that rank-2 types have anything to do with the fact that context affects types
09:55:12 <elliott> well, my explanation may be imperfect. but rank-2 types are the reason your example does not type.
09:55:21 <hamishmack> donri: ezirpa
09:56:34 <napping> Is there any way to keep cabal-install from breaking things, besides just using cabal-dev everywhere?
09:56:38 <Mathnerd314> elliott: no, the implementation of GHC is the reason it does not type.
09:57:03 <elliott> Mathnerd314: that is untrue
09:57:11 <Mathnerd314> AFAICT there is no way to remove the rank-2 types without changing the meaning of the program
09:57:53 <elliott> Mathnerd314: this is the same reason why runST is funny
09:58:02 <elliott> in that (runST $ do { ... }) doesn't always work when (runST (do {... })) does
09:58:08 <elliott> although I think they added a hack to the typechecker to force that one to work.
09:58:16 <napping> It's especially annoying when cabal computes an install plan, then some package with Custom hooks fails to run complainign about Cabal versions
10:07:40 <rostayob> my program works in Hugs. I am amazed.
10:07:48 <rostayob> I mean actually I usually don't try
10:07:53 <tromp__> Happy Half-Tau Day!
10:10:26 <napping> Is there a released cabal-install that works with 7.4.1?
10:11:05 <elliott> napping: use darcs
10:11:11 <elliott> cabal-install, that is
10:13:03 <td123> napping: cabal-install-ghc74 in hackage works for me
10:13:08 * hackagebot attoparsec-expr 0.1 - Port of parsec's expression parser to attoparsec.  http://hackage.haskell.org/package/attoparsec-expr-0.1 (SebastiaanVisser)
10:13:45 <elliott> isn't that the old cabal-install with hacked up dependencies?
10:13:52 <elliott> better to get the modular solver etc. in the darcs version
10:14:53 <Mathnerd314> which reminds me: who is working on the next Haskell platform?
10:14:56 <napping> I'm worrying that using the darcs version might be part of why it's failing so hard
10:15:28 <napping> but maybe I need to install just the cabal-install from darcs, but not replace the Cabal-1.14.0 that seems to be wired into the 7.4.1 release
10:15:30 <elliott> Mathnerd314: the same people as the previous one, I gather. what's wrong with the one that just recently came out?
10:15:43 <elliott> it's only three months old.
10:15:52 <elliott> napping: I've used cabal-install from darcs with 0 problems whatsoever for months
10:15:54 <napping> on the other hand, I guess it was just ghc-7.4.1 package that broke
10:16:01 <elliott> napping: but, err, you replaced Cabal? never do that
10:16:09 <elliott> wipe everything, install ghc, install cabal-install from darcs head (but not Cabal)
10:16:47 <napping> actually, I think I installed some things that rebuilt directory against a different time, making the global Cabal inaccessible, then Custom build started failing complaining no Cabal was available
10:17:02 <napping> but yes, I'm going for a clean reinstall
10:17:11 <napping> how to get darcs?
10:17:35 <elliott> napping: install your distro's darcs package
10:17:40 <elliott> it will suffice
10:19:49 <napping> ah, right. somehow I was worrying it would pull in the distro ghc
10:21:43 <td123> elliott: someone created cabal-install-ghc74 on hackage, why not use that?
10:22:37 <napping> It seems to be time to learn again what the apparently good reasons are for the package database to be so fragile
10:22:56 <napping> something about using the C linker not letting multiple instances of the same version of a library coexist?
10:23:08 <elliott> td123: <elliott> isn't that the old cabal-install with hacked up dependencies?
10:23:10 <elliott> <elliott> better to get the modular solver etc. in the darcs version
10:23:39 <td123> ah ok
10:24:43 <elliott> i don't actually know that though
10:24:54 <elliott> so for all I know that could be FUD, but hopefully FUD with a limited lifespan of relevance
10:25:05 <napping> I hope I just went wrong by installing also the Cabal from darcs
10:25:44 <napping> the cabal-install-ghc74 package explicitly claims to be the stable cabal-install with hacked-up dependencies
10:26:08 <elliott> ok. then i feel justified in recommending darcs cabal :)
10:26:09 <td123> elliott: and yes, the ghc74 version is the cabal-install on hackage just with minimal changes to compile with ghc 7.4.1
10:26:11 <elliott> -install
10:26:16 <elliott> ugh I hate this naming scheme so much!!!
10:26:38 <elliott> can't wait until it becomes cabal and cabal-lib and people who didn't get the memo end up confused at all these people "installing cabal", that'll be so much better *sigh*
10:26:55 <Enigmagic> yeah, when is that going to happen?
10:27:21 <elliott> when hackage2 comes out
10:28:12 <napping> why are --solver=modular and --avoid-reinstalls not default?
10:28:50 <elliott> i guess they're beta quality or something
10:28:54 <napping> If I can install the k-framework and darcs Agda without cabal-dev or things breaking I'll be happy
10:29:11 <elliott> do you really have all that many problems nowadays?
10:29:16 <elliott> it's mostly plain sailing for me.
10:29:18 <elliott> didn't use to be
10:30:18 <parcs`> darcs cabal is pretty stable for me and is much better at not breaking your packages
10:30:44 <napping> that what I had been using which broke the packages
10:30:48 <parcs`> uh oh
10:31:31 <napping> this is a different thing, isn't it? array-0.3.0.3:Data.Array can't be safely imported!
10:31:36 <elliott> that's safe haskell
10:31:40 <elliott> you're installing something outdated or sth
10:31:53 <elliott> anyway the packages broke because you reinstalled cabal, not because of cabal-install :p
10:32:26 <napping> I'm not sure that I did reinstall Cabal, I'll see if it works now
10:33:56 <Gwern-away> @quote
10:33:56 <lambdabot> ndm says: performance is such an old concern
10:34:06 <parcs`> i currently have a whole bunch of stuff installed in a single cabal directory (yesod, happstack, agda, trifecta etc) and not a single package is broken! (according to ghc-pkg check)
10:34:25 <napping> It would probably help if there was some way to mark versions that are too outdated to be used
10:34:25 <elliott> once, spj installed the entirety of hackage in one package database.
10:34:29 <elliott> that was when he achieved enlightenment.
10:34:43 <dcoutts_> elliott: that's not actually possible yet :-)
10:34:45 <dcoutts_> but it will be
10:34:49 <elliott> dcoutts_: Not for mortals.
10:35:05 <elliott> (He did get some help from Oleg.)
10:35:26 <napping> Perhaps nix-style management of multiple lib directories might allow multiple instances of packages
10:35:34 <dcoutts_> napping: yes that's exactly the plan
10:35:43 <elliott> i think dcoutts_ is now having dejavu along the "why not do it like nix" lines
10:35:56 <napping> then all this buisness of stuff getting wedged is replaced by the much less objectionable buisness of rebuilding lots of stuff if it appears necessary
10:36:22 <elliott> well that is the business
10:36:26 <elliott> it starts with rm -r ~/.cabal ~/.ghc
10:36:36 <elliott> then it goes on to the rebuilding lots of stuff part
10:40:39 <donri> aren't some problems unsolvable though, like a dependency needs a version of another dependency that differs from the one you need, and the first dep exposes instances for classes in the second etc?
10:42:30 <Taneb> Hello
10:44:45 <hpaste> nelstar pasted “getting the year” at http://hpaste.org/65289
10:44:56 <nelstar> hello
10:45:18 <nelstar> can someone help me with the paste?
10:47:07 <napping> System.Time.ClockTime is not a string
10:47:45 <Taneb> Nor a list of Word8s
10:48:10 <napping> there's better ways to get the year out that printing it and parsing the year back out, but if the point is to mess with bytestrings, toss in a "show"
10:48:37 <napping> also, main should be IO (), not a plain bytestring
10:48:48 <nelstar> yeah that was the original program
10:49:07 <nelstar> then i read bytestring are prefered...
10:51:18 <napping> the easiest way from ClockTime to ByteString is through String
10:51:41 <elliott> bytestring is not preferred over string
10:51:43 <Saizan> but you need the pack from Data.ByteString.Char8
10:51:47 <elliott> they are not remotely the same (don't let "string" confuse you)
10:51:52 <elliott> text might be preferred over string in most cases however
10:52:22 <dskippy1> Does Riot try to make 5-champ skins that make a decent team together?
10:54:26 <elliott> wat
10:54:46 <elemir> Is there something like "commutative pair"?
10:54:54 <napping> nelstar: have you written the better one with toCalendarTime?
10:55:02 <elliott> elemir: You mean an unordered pair?
10:55:12 <elemir> Ye
10:55:18 <elliott> elemir: Depends what you want it for.
10:55:37 <elliott> You can define an abstract pair type which has a -> a -> Pair a, and (Ord a) => Pair a -> (a,a) (lowest first)
10:56:02 <elliott> If you mean something which has identical representation for (x,y) and (y,x), that's much trickier (and I really don't think there's a general way to define it generically to all types).
10:56:39 <elemir> Wait. I'll try to write it.
10:56:46 <elliott> Good luck with that.
10:57:05 <elliott> You aren't the first to wonder.
10:57:15 <elemir> Heh
10:59:37 <nelstar> napping : watching the definition of toCalendarTime but can't seem to understand how it works
11:00:22 <nelstar> no ok got it
11:02:49 <hpaste> Elemir pasted “Maybe something like that?” at http://hpaste.org/65290
11:03:54 <elemir> It's good for my task
11:04:21 <napping> Is there anything like http://packdeps.haskellers.com/, but for searching about dependencies on a package?
11:04:36 <elliott> elemir: that's not good for any task.
11:04:39 <elliott> seeing as you can never use any instance
11:04:45 * ski wonders why elemir is using `class' at all
11:04:52 <elliott> only the instance head (Pair b a) will be considered
11:04:55 <elliott> when deciding on an instance
11:04:57 <elliott> so that instance will always be picked
11:05:16 <elliott> i misinterpreted your original request though. but now i think it's just strange
11:06:07 <napping> I see something that seems to be going wrong
11:06:18 <ski> your `(<+>)' is basically `_>_'
11:06:27 <ski> er, `_|_'
11:07:18 <napping> one of the things I'm trying to install uses some obsolete packages, eventually including convertible-text, which forces old-time < 1.1, and then wants to rebuild process and directory, but those rebuild packages will be incompatible with the global Cabal
11:07:41 <ski> (maybe you wanted `(<+>) = flip (<+>)' .. but that's still cyclic)
11:08:29 <Mathnerd314> implicit arguments?
11:08:33 <elliott> napping: have you tried --solver=modular --avoid-reinstalls and all that?
11:08:39 <elemir> ski: No, I really want something similiar
11:08:48 <napping> --avoid-reinstalls pick a plan that involves building an obsolete vesion of directory
11:08:49 <elliott> <napping> Is there anything like http://packdeps.haskellers.com/, but for searching about dependencies on a package?
11:08:54 <elliott> not sure what this means
11:08:54 <napping> which is working so far
11:08:57 <elliott> packdeps has reverse dependencies
11:08:59 <elliott> hackage has dependencies
11:09:20 <napping> I was wondering if anything depends on old-time >= 1.1
11:09:57 <elliott> http://packdeps.haskellers.com/reverse/old-time
11:10:02 <napping> the full list, right
11:10:26 <dcoutts_> elliott: new hackage has reverse dependencies
11:10:49 <dcoutts_> http://hackage.factisresearch.com/packages/reverse
11:10:56 <elliott> that's also true
11:11:04 <elliott> i'm used to doing it via packdeps though
11:11:09 <dcoutts_> sure
11:11:16 <dcoutts_> and they actually show slightly different things
11:11:21 <napping> --avoid-reinstalls founders installing directory-1.0.0.3, which fails to compile with errors like
11:11:22 <dcoutts_> neither subsumes the other at the moment
11:11:24 <napping> System/Directory.hs:741:40: Not in scope: `c_opendir'
11:13:03 <augur> (,,)
11:13:17 <augur> the notorious two-clawed operator
11:13:37 <hpc> :t (,,,,,,,,,,,,)
11:13:38 <lambdabot> forall a b c d e f g h i j k l m. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (a, b, c, d, e, f, g, h, i, j, k, l, m)
11:13:40 <augur> (,,)^w^(,,)
11:14:06 <elliott> :t let w = undefined in (,,)^w^(,,)
11:14:07 <lambdabot>     No instance for (Integral (a -> b -> c -> (a, b, c)))
11:14:07 <lambdabot>       arising from a use of `^' at <interactive>:1:26-31
11:14:08 <lambdabot>     Possible fix:
11:15:28 <Botje> augur: heh. It kind of looks like a metroid.
11:18:30 <rostayob> :t let (^w^) = undefined in (,,)^w^(,,)
11:18:31 <lambdabot> parse error on input `)'
11:18:56 <rostayob> oh right. no letters in operators.
11:19:00 <rostayob> getting used to agda.
11:19:22 <elliott> rostayob: it was nice knowing you
11:19:58 <napping> you just need an instance Num (a -> b -> c -> (a,b,c))
11:20:03 * ski just tried, and couldn't get it to go from an instance `Foo => Foo' into an instance `Foo' (by essentially applying `fix')
11:20:26 <ski> elemir : btw, i'm not even sure what your code is supposed to achieve
11:20:49 <rostayob> elliott: I'll be back...
11:20:55 <elliott> rostayob: that's what they all say
11:21:23 <napping> cabal-dev it is
11:21:29 <rostayob> elliott: once you go agda...
11:22:14 <edwardk> You need a Zoidberg operator that you could actually implement, like  (\/)(o,,o)(\/)
11:22:30 <redheadphones> how would i specify LANGUAGE and OPTIONS_GHC pragmas in the same file?
11:22:38 <rostayob> redheadphones: two different pragmas?
11:22:42 <companion_cube> on my planet, a clams enjoys a tasty you!
11:22:57 <rostayob> {-# LANGUAGE ...#-}\n{-# OPTIONS_GHC ...#-}
11:23:04 <redheadphones> didn't know if they needed to be in the same {-# #-}
11:23:09 <redheadphones> cool
11:24:24 <rostayob> elliott: I'd be already swallowed by agda if I could write practical programs easily with it.
11:25:12 <elliott> rostayob: it's just a matter of FFI
11:25:28 <zhulikas> I was wondering, would it be very difficult to make some sort of domain specific language based on haskell and focused on Android (Java) applications?
11:25:28 <hpaste> scooty-puff pasted “Show Record” at http://hpaste.org/65291
11:25:31 <scooty-puff> is it possible to implement show without the ShowRecord type class?
11:25:32 <Enigmagic> redheadphones: you can use as many as you want. i only ever put one pragma per line, which helps with auto-merging between branches or when multiple developers are working on the same project.
11:25:44 <elemir> rostayob: How about a program speed?
11:25:46 <zhulikas> so Haskell -> Java translator
11:25:48 <redheadphones> makes sense
11:26:00 <elliott> zhulikas: look at Frege
11:26:01 <scooty-puff> zhulikas: have you heard of frege?
11:26:03 <zhulikas> nope
11:26:06 <zhulikas> thanks for a tip
11:26:15 <rostayob> elemir: yeah but still. hacking doesn't feel natural in that land
11:26:15 <Enigmagic> redheadphones: like so https://github.com/alphaHeavy/shake-install/blob/master/Development/Shake/Install/Rules.hs
11:26:26 <rostayob> elliott: program speed?
11:26:29 <rostayob> sorry, elemir
11:26:36 <elemir> rostayob: Agda is slow, isn't?
11:26:47 <rostayob> elemir: that is not my concern
11:27:00 <zhulikas> hehe, JVM language
11:27:04 <elemir> Lucky =(
11:28:11 <rostayob> elemir: right now performance is very low in the priorities of Agda's community, understandably :P
11:28:14 <rostayob> or so it seems anyways
11:28:38 * elemir really loves Agda. But it's platonic love…
11:29:00 <elemir> Agda has very strange syntax
11:29:20 <byorgey> elemir: what is strange about it?
11:29:27 <byorgey> it's pretty similar to Haskell actually
11:29:29 <rostayob> elemir: I'd say "flexible" more than strange
11:30:36 <rostayob> yeah it's basically haskell with the big addition of mixfix operators
11:32:27 <augur> elemir: you shut your mouth :|
11:34:00 * elemir tries to understand how can he write needed combinators
11:34:40 <ski> scooty-puff : Gottlob ?
11:35:47 <scooty-puff> ski: ?
11:36:28 <ski> "have you heard of frege?"
11:36:30 <rostayob> scooty-puff: gottlob frege.
11:36:33 <napping> http://code.google.com/p/frege/
11:37:09 <ski> <http://en.wikipedia.org/wiki/Gottlob_Frege>
11:38:25 <scooty-puff> o, i have, but only through wikipedia, and skimming that project page
11:39:32 <ski> scooty-puff : heh, "Gottlob ?" was my answer to your "have you heard of frege?"
11:39:39 <scooty-puff> o, i understand..
11:39:56 <scooty-puff> sorry, lost track of things
11:40:06 <ski> np
11:40:32 <rostayob> frege, good guy. apart from that little thing with nazism...
11:41:24 <elliott> Something predictable about Hitler and paintings.
11:42:19 <nand`> Frege? Wasn't he that mentally.. gifted logician?
11:42:24 <scooty-puff> it is nice to have things that there is a clearly defined "right"
11:43:41 <shergill> does frege aim to be the final solution (to the problem of 'too many programming languages')?
11:43:55 <scooty-puff> ok so i shouldn't, but lol
11:44:40 <nand`> solution :: (Language a, Language b) => a -> b
11:44:48 <elemir> Heh
11:45:05 <scooty-puff> its bad that all i thought was about Typeable
11:45:23 <nand`> solution = fromLazyK . toLazyK
11:45:30 <scooty-puff> :t fromJust . cast
11:45:31 <lambdabot> forall a a1. (Typeable a1, Typeable a) => a1 -> a
11:45:37 <Franciman> hey dudes how does Haskell support dynamic Typing?
11:45:43 <shergill> heh
11:45:44 <scooty-puff> :t Dynamic
11:45:45 <lambdabot> Not in scope: data constructor `Dynamic'
11:45:52 <scooty-puff> :t fromDyn
11:45:53 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
11:45:57 <scooty-puff> :t toDyn
11:45:58 <lambdabot> forall a. (Typeable a) => a -> Dynamic
11:46:34 <scooty-puff> i think all Dynamic really is is an existentially quantified data type, data A = forall a. Typeable a => A a
11:46:35 <Franciman> ohh there is a data type for that
11:46:50 <Franciman> it's awesome
11:46:52 <rostayob> scooty-puff: yes, that's what it is.
11:46:56 <rostayob> it's not that awesome.
11:47:10 <Mathnerd314> :info Dynamic
11:47:12 <scooty-puff> quite a good hammer for all these screws
11:47:28 <Franciman> *it's awesome as opposed to what I expected
11:47:33 <nand`> :t unsafeCoerce
11:47:34 <lambdabot> Not in scope: `unsafeCoerce'
11:47:39 <Mathnerd314> ^ idea for a new lambdabot plugin?
11:48:00 <Franciman> btw, when is Dynamic useful?
11:48:03 <nand`> so lambdabot can segfault more?
11:48:07 <nand`> (if that was in response to mine)
11:48:21 <Franciman> I can't find any usage
11:48:23 <rostayob> scooty-puff: I don't think that's actually how it is implemented but that would work
11:48:48 <scooty-puff> Franciman: i used it when i had a Map TypeRep Dynamic, but ended up making a custom value type with unsafeCoerce, trusting correct typeOf implementation (as cast does)
11:49:00 <scooty-puff> (the Map was hidden)
11:49:49 <Franciman> ah ok
11:50:45 <Franciman> ah it's useful for etherogeneous data-structures
11:50:49 <Franciman> didn't think about it
11:51:04 <Franciman> *heterogeneous
11:51:13 <scooty-puff> speaking of which, if i have data Value = forall a . Value a, and i know (via some means i can't prove to haskell, at least not without crazy higher kinds), would this be safe (if not good): f (Value a) = unsafeCoerce a
11:51:14 <Saizan> scooty-puff: make sure to use Any, since unsafeCoerce is picky
11:51:18 <scooty-puff> k
11:53:30 <scooty-puff> why does Any have a type parameter?
11:54:26 <elliott> it doesn't
11:54:31 <elliott> haddock is just confused
11:55:07 <scooty-puff> o
11:55:07 <scooty-puff> ok
11:55:25 <rostayob> elliott: this is weird. ghci is confused as well
11:55:51 <rostayob> λ> :info Any
11:55:53 <rostayob> data Any a -- Defined in `GHC.Prim'
11:56:11 <redheadphones> has anyone using mueval encountered issues with -l when you call runInterpreter multiple times?
11:57:40 <redheadphones> i can't seem to get it to reinterpret the file, and it craps out after the first call
12:03:25 <scooty-puff> is it relatively common to import from GHC.Prim?  or bad?  i know some of the language extensions i'm using will require enormous effort to be made available on any other compiler
12:04:21 <elliott> scooty-puff: import GHC.Exts
12:04:24 <elliott> never GHC.Prim
12:04:27 <scooty-puff> k
12:04:39 <edwardk> scooty-puff: importing from GHC.Prim is usually done when you know exactly what you are doing and don't care about portability or future proofing your code
12:04:40 <elliott> it's probably bad, but it's also not all that uncommon :)
12:04:51 <elliott> but you shouldn't need it 90% of the time.
12:05:23 <edwardk> Any is pretty safe
12:05:51 <scooty-puff> i think what i had been doing was sort of compiler specific - related to unsafeCoerce, but theres always the option of punting to Dynamic if i can't sort out what compiler is being used
12:05:55 <edwardk> what version of the compiler were you on that haddock gave you a type parameter?
12:06:12 <edwardk> unsafeCoerce + Any is a pretty common combination
12:06:23 <edwardk> in fact its largely the reason for Any's existence
12:07:27 <scooty-puff> k - i assume using an existentially quantified data type isn't used because the compiler will specially recognize Any and not ... do something bad
12:08:10 <scooty-puff> *isn't used -> shouldn't be used
12:09:27 <edwardk> well, there is a funny case where Any does something a bit smarter when you force it with !. not sure i remember the details
12:10:12 <scooty-puff> k
12:12:21 <Saizan> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#v:unsafeCoerce-35-
12:22:52 <k0ral> hi, say you have a String with malformed characters (things like \234, \233... which appear to be latin1 charset), how would you translate them ?
12:23:27 <mauke> what do you mean by "malformed"?
12:23:30 <mauke> translate to what?
12:23:39 <rostayob> k0ral: what do you mean? you want to convert the text to a different encoding?
12:24:00 <k0ral> let me rephrase it
12:24:27 <hiptobecubic> Optimizing haskell really feels like pin the tail on the voodoo donkey. I have no idea what's going on in there.
12:24:59 <k0ral> first I need to fix my irc client's encoding to be able to rephrase it -_-'
12:25:21 <dfletcher> yak shaving? fun!
12:25:31 <mauke> I bet this could be explained in ascii
12:26:49 <k0ral> well, see the character corresponding to 234 in latin1 ?
12:26:53 <NihilistDandy> Is there a good automatic way of cleaning up old cabal'd packages, or is manual the way?
12:26:57 <k0ral> an "e" with a ^
12:27:00 <mauke> ok?
12:27:19 <NihilistDandy> ê
12:27:26 <k0ral> I have a String with, instead of such character, "\234"
12:27:33 <k0ral> I want my character back :)
12:27:33 <mauke> what?
12:27:38 <mauke> "\234" is that character
12:27:55 <rostayob> > show "λ"
12:27:56 <lambdabot>   "\"\\955\""
12:28:00 <rostayob> > putStrLn "λ"
12:28:01 <lambdabot>   <IO ()>
12:28:02 <mauke> > "\65" == "A"
12:28:03 <lambdabot>   True
12:28:03 <rostayob> oh well
12:28:11 <mauke> > "\234" == "ê"
12:28:12 <lambdabot>   True
12:28:22 <jedai> k0ral: that's just the Show instance for Char
12:29:10 <jedai> k0ral: you character is still there and can be displayed with putStr (assuming you're on a compatible terminal)
12:29:11 <k0ral> fine, but you could easily understand I don't want to print "\234"
12:29:18 <rostayob> k0ral: use putStrLn
12:29:41 <mauke> k0ral: sure, so why are you doing it?
12:30:41 <jedai> hiptobecubic: That gets better with experience, usually...
12:30:42 <NihilistDandy> Sidenote, has anyone ever seen this: "evacuate(static): strange closure type 6684432"
12:30:42 <k0ral> I'm trying putStrLn, actually I want to write it into a file but if putStrLn works, hPutStrLn will too right ?
12:30:53 <mauke> k0ral: yes
12:30:58 <mauke> @src putStrLn
12:30:58 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
12:31:00 <mauke> @src putStr
12:31:01 <lambdabot> putStr s  = hPutStr stdout s
12:36:02 <k0ral> actually, I have "\\234" in my String
12:36:16 <k0ral> that's why putStrLn won't work alone
12:36:51 <ChristianS> k0ral: what's the length of your string?
12:37:04 <k0ral> ChristianS: rather long, it's an article
12:37:44 <mauke> k0ral: why do you have "\\234"?
12:37:45 <hiptobecubic> jedai, i was in here yesterday trying to figure out what to do. I think the first step is to enforce strictness because i'm building up a giant list of lists of thunks
12:38:32 <hiptobecubic> jedai, then I guess there isn't much else I can do without changing all the data types probably. Maybe unboxing stuff? It's all still magic to me :)
12:38:57 <jedai> The tricky part is to be lazy most of the time but just add strictness where it's necesssary (too much strictness is not a good solution either)
12:39:11 <k0ral> mauke: ask the guy who published this article :)
12:39:22 <k0ral> mauke: it's from a website's RSS feed
12:39:45 <ChristianS> k0ral: putStrLn "\234" prints  , while show "\234" prints "\"\\234\"" , hence i still wonder (a bit) whether you really have a problem.
12:39:51 <mauke> ouch
12:40:04 <mauke> k0ral: url?
12:40:15 <jedai> hiptobecubic: Normally you can just be strict in the functions that produces your big thunks so that they produce real values instead, you don't need to change your data structure (though that may be a good idea in some cases)
12:40:23 <NihilistDandy> k0ral: (_:xs) -> putStrLn xs?
12:41:13 <k0ral> mauke: http://www.cyrille-borne.com/index.php?feed/atom
12:42:00 <mauke> k0ral: that doesn't contain \2
12:42:15 <ChristianS> the feed looks fine to me, there are certainly some  in there.
12:42:33 <k0ral> mauke: you're probably viewing it through your browser
12:42:43 <hpaste> hiptobecubic pasted “Optimise me” at http://hpaste.org/65292
12:42:49 <mauke> k0ral: no
12:42:50 <k0ral> mauke: I'm downloading it using haskell's HTTP library
12:42:54 <mauke> k0ral: irrelevant
12:43:11 <mauke> k0ral: even if I did view it in my browser, my browser doesn't understand haskell-style \234 escapes
12:43:22 <mauke> it prefers html/xml
12:43:26 <ChristianS> k0ral: if you decode that feed as utf8, you should be fine, i think.
12:43:31 <qued_____> foldr needs O(n) time, and O(1) space ?
12:43:35 <k0ral> ChristianS: I did
12:43:52 <k0ral> ChristianS: before decoding it as utf8, I have pairs of escaped sequences
12:44:04 <mauke> what
12:44:18 <k0ral> ok I will paste it clearly
12:44:21 <k0ral> give me some time
12:44:47 <mauke> qued_____: depends a lot on the function
12:45:12 <mauke> qued_____: foldr const should be o(1)
12:46:00 <hiptobecubic> jedai, the problem is I need to do some Monte Carlo simulations using this function. So it will be called tens of thousands of times and each time i'm going to need the last entry of the "errors" list, which ends up meaning that i need the entire "purse" list... which means i need basically everything.
12:46:14 <qued_____> mauke: foldr (+) 0 [1..n]
12:46:25 <hiptobecubic> jedai, So i assume it's not good to build up all of the lists as thunks since they are all necessary in the end
12:46:29 <qued_____> it's tail recursive, and linear recursive.... isnt it?
12:46:30 <jedai> qued_____: That's O(n) time and space
12:46:33 <mauke> qued_____: no
12:46:43 <jedai> qued_____: foldr is never tail recursive
12:46:47 <qued_____> jedai: why O(n) space?
12:46:57 <mauke> > foldr (+) 0 [1..10] :: Expr
12:46:58 <hiptobecubic> doesn't it load the entire list?
12:46:58 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
12:47:00 <qued_____> ah okay...
12:47:14 <qued_____> mauke: but foldL is tail recursive, right?
12:47:17 <mauke> yes
12:47:19 <hiptobecubic> wow, lambdabot is amazing
12:47:21 <mauke> still O(n) memory, though
12:47:22 <jedai> qued_____: because it builds a thunks like 1+(2+(3+...+(10+0)...)
12:47:32 <qued_____> okay
12:47:32 <mauke> > foldl (+) 0 [1..10] :: Expr
12:47:33 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
12:47:33 <qued_____> got it
12:48:17 <jedai> qued_____: what you want to do is to be strict in the accumulator and use foldl to be tail recursive, then you have O(1) memory (still O(n) time of course)
12:48:21 <qued_____> So:   foldr (+) 0 [1..n]    with O(n) space/ time,
12:48:21 <qued_____>  foldl (+) 0 [1..n)     with O(n) time, O(1) space
12:48:22 <qued_____> ??
12:48:23 <qued_____> right?
12:48:26 <ChristianS> but foldl' is usually better than foldl, right?
12:48:39 <jedai> qued_____: You need to use foldl' rather than foldl
12:48:48 <hiptobecubic> ChristianS, i think foldl' is the strict version
12:48:54 <ChristianS> yes
12:48:57 <mauke> qued_____: no, foldl is still O(n) memory
12:49:03 <jedai> qued_____: foldl' is foldl but strict in the "accumulator"
12:49:04 <hpaste> koral pasted “Try me” at http://hpaste.org/65293
12:49:13 <jedai> @wheree fold
12:49:13 <lambdabot> Maybe you meant: where where+
12:49:17 <jedai> @where fold
12:49:17 <lambdabot> I know nothing about fold.
12:49:21 <jedai> @where foldl
12:49:22 <lambdabot> I know nothing about foldl.
12:49:22 <k0ral> mauke, ChristianS: try this paste
12:49:37 <henux> do you use the haskell-mode-2.8.0 in emacs, or is there a better one?
12:49:41 <k0ral> I personnally get a lot of escaped characters
12:49:57 <qued_____> mauke: jedai: my ghci only knows foldl / foldl1
12:50:06 <jedai> qued_____: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
12:50:09 <k0ral> mauke, ChristianS: always in pair
12:50:15 <jedai> qued_____: foldl' is in Data.List
12:50:24 <ChristianS> k0ral: yes, that looks broken.
12:50:57 <ChristianS> k0ral: Network.HTTP parses the feed as latin1 rather than utf8, i would presume.
12:52:00 <NihilistDandy> henux: I'd grab the Emacs Prelude
12:52:15 <NihilistDandy> Include Haskell-Mode, and you don't have to update everything yourself :D
12:52:19 <NihilistDandy> *Includes
12:52:27 <jedai> ChristianS: I don't think it "parse" anything
12:52:42 <henux> ok let me take a look
12:52:57 <k0ral> jedai: neither do I
12:53:19 <ChristianS> k0ral: got it, i think: Content-Type: text/html; charset=iso-8859-1
12:53:31 <ChristianS> k0ral: the webserver sends the wrong charset.
12:53:34 <jedai> k0ral: You just need to encode that with Data.Text (or use utf8-string or something like that)
12:53:35 <mauke> ChristianS: no, it doesn't
12:53:39 <mauke> jedai: no
12:54:33 <jedai> mauke: Why ? I got the feeling he was getting a stream of bytes rather than characters, isn't that the case
12:54:34 <k0ral> ChristianS: how comes common RSS clients manage to display it well ?
12:54:40 <mauke> jedai: no
12:54:57 <ChristianS> k0ral, mauke: sorry, must have made a mistake.
12:54:57 <mauke> k0ral: because they actually handle the Content-Type
12:55:29 <jedai> html can indicate the encoing in the file itself
12:55:31 <k0ral> mauke: you mean they work around it, since it's broken ?
12:55:40 <mauke> k0ral: no
12:55:42 <jedai> is that what's happening here ?
12:55:48 <mauke> k0ral: it's working fine and your code is broken
12:55:53 <mauke> jedai: no
12:55:57 <mauke> jedai: and this isn't html
12:56:12 <k0ral> ChristianS: err, actually I've got "Content-Type: application/atom+xml; charset=UTF-8"
12:56:24 <jedai> mauke: Well that's what the content-type says (or rather what ChristianS say)
12:56:33 <k0ral> ChristianS: it's the value of x in my paste you're talking about, right ?
12:56:36 <mauke> jedai: ChristianS is wrong
12:56:44 <jedai> Ok... that's a lot different !
12:57:06 <k0ral> mauke: how to fix it then ?
12:57:06 <timthelion> Hey, is there a way to ban IO(including unsafe IO) at compile time?
12:57:35 <ChristianS> k0ral: yup, made a mistake as i said. i tried querying with a HTTP/1.0 request (without Host) but the server won't handle it. if i send a correct request, i get the right Context-Type.
12:57:54 <k0ral> timthelion: import Prelude hiding(IO) or something like that maybe ?
12:58:38 <ChristianS> mauke: but what's the problem with k0ral 's code?
12:58:55 <timthelion> k0ral: I don't wish to change the code.  I wish for ghc to dissallow it.  I want to be able to import and compile code from a 3rd party, without getting a virus on my system(to say it in simple terms)
12:59:28 <Taneb|Hovercraft> import Random;main=newStdGen>>=putStr.randomRs('!','~')
12:59:35 <mauke> k0ral: as far as I can tell, simpleHTTP is broken
12:59:35 <Taneb|Hovercraft> Is it possible to get that shorter?
12:59:45 <mauke> k0ral: or at least the HStream String instance is
13:00:10 <k0ral> timthelion: that's beyond my knowledge scope, sorry
13:00:46 <k0ral> mauke: known problem for a long time ?
13:00:54 <mauke> ?
13:01:03 <jedai> mauke: I don't think so, it's just that ByteString is a more correct type since simpleHTTP makes no attempt to properly account for the encoding, no ?
13:01:37 <timthelion> I'd like to be able, for example, to create CAD files(computer aided design files) that consisted literally of haskell code which evaluates to a data type which expresses a 3D scene, people from all over the world would share these CAD files, and it would be essential that they weren't actual programs, rather just pure code which could not harm anyones system
13:01:41 <mauke> jedai: yes
13:01:50 <mauke> jedai: which makes String the wrong thing to use
13:01:54 <k0ral> mauke: you're telling me simpleHTTP is broken, as this is part of the Network.HTTP library that may be used by many people, I'm asking whether it is a known problem
13:02:08 <mauke> k0ral: I have no idea, this is the first time I've seen Network.HTTP
13:02:33 <mauke> k0ral: but basically, if you use getRequest or postRequest, you lose
13:02:55 <jedai> k0ral: it's more of an historical problem : String was used for byte string as well as for text, today we have better type for both those purpose and they're separate : ByteString and Text
13:03:58 <k0ral> timthelion: I think you don't need to hack ghc for that
13:04:14 <jedai> k0ral: what simpleHTTP does is retrieve stream of bytes from the net, it doesn't attempt to look at the encoding and should thus use ByteString rather than String (but doesn't for compatibility reasons)
13:04:14 <mauke> can I recommend perl instead?
13:04:49 <gdoteof> is anyone using haskell mode in vim?  i am trying to use http://projects.haskell.org/haskellmode-vim/
13:04:50 <hiptobecubic> What are "profiling libraries" and how are they different from a normal library?
13:04:56 <osa1__> why does an author put code that doesn't work on haskell in a haskell paper? I'm reading inductive graph paper by martin erwig and code in that paper contains a data type with infix constructor. one might think that as a constructor function but he then uses it for match some patterns..
13:04:59 <jedai> mauke: Why, he could just convert the result of his simpleHTTP with Data.Text,
13:05:03 <hiptobecubic> gdoteof, i am
13:05:07 <timthelion> k0ral: a compile time option for "This is a library which claims to contain no unsafeIO so don't let it" is no hack at all.
13:05:09 <mauke> jedai: how?
13:05:16 <gdoteof> hiptobecubic: great.  are you able to post to to hpaste direcgt from a buffer?
13:05:41 <k0ral> timthelion: I mean, I think you don't need to go through GHC to enforce such constraint
13:05:53 <mauke> jedai: for comparison, here's the perl code: use LWP::Simple; my $body = get "http://www.cyrille-borne.com/index.php?feed/atom"; print $body;
13:05:55 <jedai> mauke: decodeUtf8 ?
13:06:05 <mauke> jedai: how do you know you have to use decodeUtf8?
13:06:06 <gdoteof> hiptobecubic: i am getting Handler/Player.hs [haskell] format: unix; [1,1]
13:06:09 <gdoteof> E492: Not an editor command: HpasteIndex
13:06:10 <hiptobecubic> gdoteof, no. that feature is "temporarily" disabled because the interface to hpaste changed, apparently.   :help hpaste
13:06:12 <gdoteof> oops.  sorry
13:06:19 <gdoteof> hiptobecubic: got it
13:06:33 <timthelion> anyone else have a comment on this?
13:07:03 <hiptobecubic> timthelion, doesn't lambdabot handle this problem. look at what it does
13:07:05 <k0ral> mauke: don't question me using Haskell to do it :)
13:07:08 <gdoteof> hiptobecubic: i am looking at the hlp; i must have an old version or something that doesn't say it is disabled.  thanks
13:07:19 <hiptobecubic> hmm, maybe I have an old version :)
13:07:22 <jedai> mauke: Because it's in the content type and the file :). No I get what you're saying, but I hope there is a package that do this in Haskell (Note that I know Perl very well and agree that it's awesome for this kind of problem but there is no reason Haskell can't do the same)
13:07:35 <hiptobecubic> gdoteof, yeah  i think might.. hold on
13:07:50 <mauke> in fact, you probably want a RSS module
13:07:52 <k0ral> mauke: so now I must find a way to do it without using getRequest
13:08:02 <mauke> k0ral: what are you trying to do?
13:08:35 <timthelion> hiptobecubic: lambdabot evaluates lambda's it probably just looks at the single line of code to see if somewhere "unsafePreformIO" is written, no?
13:08:40 <jedai> mauke: LWP::Simple is much more high-level than Network.HTTP and you can actually find the equivalent of Network.HTTP in Perl, so we should have an equivalent to LWP in Haskell !
13:08:46 <k0ral> mauke: http://hackage.haskell.org/package/imm-0.1.1.0
13:08:49 <hiptobecubic> timthelion, I have no idea. Go look
13:09:20 <hiptobecubic> gdoteof, haskellmode-20100622?
13:09:21 <mauke> k0ral: wtf is that?
13:09:50 <k0ral> mauke: it's what I'm trying to do
13:09:57 <mauke> that doesn't tell me anything
13:09:57 <k0ral> mauke: converting RSS feeds into mails
13:09:59 <jedai> k0ral: it would be nice to have at least a description
13:09:59 <timthelion> hiptobecubic: I'm looking.  I'm on page 3 of google, just about to enter the land of desperation(according to xkcd)
13:10:08 <mauke> k0ral: there is no package description and no documentation
13:10:20 <k0ral> jedai: take an RSS feed, convert it into a maildir, each item becomes a mail
13:10:31 <mauke> k0ral: and you want to parse RSS manually?!
13:10:32 <hiptobecubic> timthelion, http://hackage.haskell.org/package/lambdabot
13:10:33 <k0ral> mauke: it's a start
13:10:44 <k0ral> mauke: please have pity :)
13:10:52 <mauke> decodeIfNeeded :: String -> String
13:11:00 <mauke> this function sucks
13:11:23 <k0ral> mauke: all your suggestions are welcome
13:11:50 <k0ral> I guess you're telling this because String -> String doesn't contain the information about the source encoding and the destination one
13:12:07 <jedai> k0ral: maybe _not_ parsing the RSS manually would be easier, why not use the feed package ?
13:12:31 <k0ral> jedai: as a matter of fact, I do
13:12:38 <k0ral> (use it)
13:12:40 <mauke> k0ral: no, because String is unicode text and can't be decoded
13:12:51 <jedai> ok, then forget what I said :)
13:12:58 <dfletcher> lol @ ~/.lambdabot/State/L.hs lines 115-156 :)
13:13:38 <k0ral> mauke: well, I happened to get String objects that weren't unicode, so how should I do it ?
13:13:38 <gdoteof> hiptobecubic: mine is slightly less old http://projects.haskell.org/haskellmode-vim/vimfiles/haskellmode-20101118.vba
13:13:44 <mauke> k0ral: wrong
13:13:48 <gdoteof> is anyone using anything to paste to hpaste from the command line?
13:13:49 <mauke> k0ral: String is always unicode
13:13:56 <gdoteof> or from within vim?
13:13:57 <jedai> k0ral: You should probably work with Text and ByteString rather than String, really, not only are they faster (most of the time) and more compact, they also have a better API than String
13:14:26 <k0ral> mauke: ok sorry for the mistake
13:14:51 <mauke> ok, apparently haskell has no library of this kind of thing
13:14:54 <k0ral> jedai: but wouldn't that imply converting each String into a ByteString or Text, which is O(n) ?
13:15:05 <mauke> jedai: no, you wouldn't have a String in the first place
13:15:08 <mauke> er, k0ral
13:15:26 <gdoteof> i see pastepipe.  but cabal install pastepipe is failing
13:15:38 <jedai> k0ral: I don't really see why you would work with String in the first place, if you didn't notice, Network.HTTP can produce ByteString as well as String
13:16:48 <k0ral> jedai: didn't expect String to lead to so much trouble, I'll switch to ByteString, thank you for pointing it out
13:17:12 <mauke> so yeah, I'd totally write that in Perl
13:17:17 <hiptobecubic> If i try to build with ghc -prof, and it says that the "profiling libraries" for a package aren't installed, can i cabal install them somehow? Or is hopeless
13:18:17 <k0ral> mauke: irrelevant, the aim isn't simply to get the job done, it's to get it done in Haskell
13:18:38 <jedai> mauke: It's a much more mature environment for this kind of thing, but if nobody ever use Haskell for this, how would it ever grows decent libraries for those usage ?
13:21:56 <ChristianS> jedai: how can Network.HTTP produce ByteString? i don't see it...
13:22:29 <k0ral> timthelion: I've been thinking about your problem, I still can't find any way to do it, I would be very interested to get the answer if you find one
13:26:03 <k0ral> ChristianS: I guess you can use Request ByteString
13:26:25 <k0ral> ChristianS: I still can't find the constraints on "a" from "Request a"
13:26:35 <mauke> constraints are in the functions, not types
13:27:00 <mauke> well, in the function signatures, not the data definition
13:27:10 <cmccann> timthelion, do the "Safe Haskell" extensions in newer GHC not do what you need?
13:28:45 <k0ral> ChristianS: I'm trying to reproduce getRequest but with a ByteString
13:28:55 <david80> hello! I'm have trouble installing template-haskell-2.7.0.0 it fails with : Language/Haskell/TH/PprLib.hs:55:10:
13:28:56 <david80>     Illegal instance declaration for `Show Doc'
13:28:56 <david80>       (All instance types must be of the form (T t1 ... tn)
13:28:56 <david80>        where T is not a synonym.
13:28:56 <david80>        Use -XTypeSynonymInstances if you want to disable this.)
13:28:57 <david80>     In the instance declaration for `Show Doc'
13:29:00 <david80> could anyone help?
13:29:12 <timthelion> cmccann: I don't know, I've never heard of them, but I'll looke them up
13:29:31 <cmccann> timthelion, http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html
13:29:44 <david80> I tried hacking the .cabal file to add the extension but it failed with another error
13:29:51 <timthelion> cmccann: thank you very much. this sounds quite promissing
13:30:27 <cmccann> timthelion, didn't read everything but from what you said I think Safe Haskell is actually stronger than you're after
13:30:31 <ChristianS> k0ral, jedai: ah, there are HStream instances for string and for lazy and strict bytestrings. got it now, thanks.
13:30:35 <dcoutts_> david80: typically you only want to use the version of template-haskell that comes with your version of ghc
13:31:02 <dfletcher> I'm messing with a custom lambdabot in a test chan and > (expr) always dumps out with "Terminated". anyone know what I need to enable or configure to make it work like this chan does?
13:31:11 <david80> dcoutts_  It was actually from trying to install another package "ad"
13:31:43 <dcoutts_> david80: if it really needs a later version of th, it may simply need a later ghc
13:31:43 <k0ral> ChristianS: oh right, thank you
13:31:56 <dcoutts_> david80: or hack 'ad' so it doesn't need the latest TH
13:32:11 <david80> dcoutts_ ahh, sounds like I need an earlier version of 'ad' thanks!
13:32:24 <dcoutts_> or that
13:32:36 <david80> many thanks
13:32:57 <aristid> using ghc 7.4 works fairly well by now
13:33:09 <aristid> not all packages support it, but most of those that i use, do
13:33:49 <timthelion> cmccann: It actually appears to be perfect, the senarios described on the page are exactly the same as the ones I had in mind.
13:34:50 <cmccann> timthelion, it's a reasonably obvious scenario, but non-trivial to handle correctly
13:35:30 <timthelion> cmccann: Personally, I think that it is one of the major advantages of haskell and purely functional programming in general.
13:35:54 <timthelion> such a concept doesn't exist in the imperical world.
13:36:14 <cmccann> oh, the concept exists, it's just vastly harder to establish that it holds
13:36:30 <hiptobecubic> i wish distcc/ccache worked with ghc
13:37:41 <cmccann> whereas a lot of basic everyday sort of code in Haskell meets the requirements of being safe without any hassle
13:38:12 <timthelion> cmccann: Other than java(which is not the same(the theory behind Java is that you create a new world in which side efects are shelterd from the outside) where as in this case, there simply is no spoon(I couldn't help it ;)
13:38:37 <timthelion> is there an example in the imperical world?
13:39:02 <cmccann> well, all sorts of sandboxing and whatnot, like you said
13:39:13 <cmccann> but that's about making sure that code can only misbehave in a disposable environment
13:40:47 <k0ral> ChristianS, jedai: still getting escaped symbols even with ByteString, is it normal ?
13:41:25 <mauke> k0ral: you never got escaped symbols
13:41:31 <mauke> so "still" makes no sense
13:41:38 <timthelion> cmccann: I guess you could say interpreted languages like brainfucked which don't have any commands other than writting to stdout also fall into that category.
13:41:42 <hiptobecubic> the best is when you get to the end of a five minute build and it fails because of some library that wasn't build with --enable-library-profiling.
13:41:54 <hiptobecubic> So you rebuild that library, and then you have to build the first one again entirely.
13:42:48 <k0ral> mauke: maybe I'm phrasing it bad, but I mean I'm getting the same "\xxx" things
13:43:10 <mauke> k0ral: you're getting bytes
13:43:17 <cmccann> timthelion, yes, and there are probably special-purpose languages designed to have such restrictions, besides esolangs like bf
13:43:21 <mauke> now you have to decode them according to the Content-Type
13:43:33 <k0ral> mauke: right, when I print them they are as bad interpreted as formerly
13:43:39 <mauke> print them how?
13:43:47 <k0ral> print
13:43:53 <mauke> well, don't do that then
13:44:16 <rostayob> k0ral: uff... print 'show's what you're printing first. 'show' escapes the special characters.
13:44:26 <k0ral> ok I got it working
13:44:32 <k0ral> Data.ByteString.putStrLn
13:44:45 <mauke> no, you still have to decode it
13:45:03 <paf31> 3
13:45:29 <k0ral> mauke: isn't putStrLn doing it ?
13:45:34 <k0ral> using my locale ?
13:45:39 <mauke> no
13:46:00 <mauke> Data.ByteString.putStrLn outputs bytes
13:46:04 <mauke> it doesn't care about encodings
13:47:52 <k0ral> fine, then I would interpret it as follows: my terminal interpret the bytes putStrLn sends to it
13:47:57 <k0ral> am I wrong (again) ?
13:48:20 <k0ral> because I'm getting the characters as I expect
13:49:10 <cmccann> well, "utf-8 incorrectly treated as ASCII" is a standard encoding many people use these days
13:49:21 <mauke> k0ral: that sounds correct
13:49:34 <mauke> your terminal reads bytes, interprets them somehow, then draws stuff on the screen
13:50:54 <k0ral> actually, should I even bother with the encodings ? why not just forwarding bytes no matter what the encoding is, and let the end-level reader interpret it ?
13:51:52 <cmccann> k0ral, if you don't need to manipulate it as text and can just pass bytes along unchanged then that's fine
13:51:53 <mauke> how do you tell the reader how to interpret it?
13:52:02 <k0ral> maybe I still want to enforce UTF8, so that I still have to re-encode it accordingly if the source encoding is wrong
13:52:23 <k0ral> then I tell the reader "use UTF8"
13:53:03 <k0ral> but this leads me to write something like "reencodeIfNeeded", and mauke will flame again
13:53:55 <k0ral> cmccann: I don't need to manipulate it, but I want the result to be utf8
13:54:19 <mauke> k0ral: depends on the type
13:54:36 <k0ral> ByteString -> ByteString
13:54:49 <mauke> no, that's crazy
13:55:09 <cmccann> well, that either means you do have to manipulate (namely by changing the encoding) or you have to kick things upstream and say that the input must also be utf-8 and disclaim responsibility if it isn't
14:02:12 <Taneb> In Data.Array.ixmap, what's the (i, i) for?
14:02:16 <Taneb> :t ixmap
14:02:17 <lambdabot> forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
14:02:34 <rwbarton> bounds of the resulting array
14:02:41 <Taneb> Aaaah
14:02:43 <Taneb> :)
14:02:54 <Taneb> This can be very useful
14:03:53 <hiptobecubic> What is the  lambda bot command that implements a function based on a type sig?
14:04:36 <k0ral> cmccann: I can't rely on upstream, I must manipulate it then
14:04:49 <ozgura> @djinn (a,b) -> a
14:04:49 <lambdabot> f (a, _) = a
14:04:56 <hiptobecubic> ozgura, thanks
14:05:11 <ChristianS> k0ral: what do you want to do this the feed after you have downloaded it? just store it in a file?
14:05:44 <k0ral> ChristianS: yes
14:07:16 <ChristianS> k0ral: in that case, you don't need to decode it. just use Data.ByteString.writeFile or similar to store it.
14:11:34 <cmccann> hiptobecubic, it's also a standalone program you can install from hackage
14:11:44 <cmccann> which has slightly more features than the lambdabot command I think
14:17:11 <k0ral> ChristianS: I don't get it: depending on the encoding, a given Char won't be written with the same bytes, right ?
14:18:02 <ChristianS> k0ral: oh, i missed your requirement that "want the result to be utf8". you can't have that.
14:18:56 <k0ral> ChristianS: why not ?
14:19:03 <ChristianS> if you just store it, the file will have whatever charset the server used to send.
14:19:53 <ChristianS> k0ral: but if the file is xml, that's not too bad, since the xml declaration should contain the charset, or else the file should be in utf8.
14:19:57 <k0ral> yes, hence the "unless (isUTF8 byteString) $ encodeUTF8 byteString"
14:20:52 <ChristianS> k0ral: you cannot encode a bytestring, you can only decode it
14:21:12 <ChristianS> encode: chars -> bytes; decode: bytes -> chars
14:21:16 <rostayob> k0ral: ByteStrings have no notion whatsoever of encoding. they're just bytes.
14:22:17 <ChristianS> k0ral: so first you have have the parse the Content-Type header to get the charset, and then you would have to decode it to string (or Data.Text).
14:22:34 <k0ral> ChristianS: I meant (encodeToUTF8 . decodeFromBadCharset)
14:23:05 <ChristianS> what's badCharset?
14:23:09 <ChristianS> latin1?
14:23:25 <ChristianS> you can certainly do that, but that's pure guesswork then.
14:24:24 <k0ral> ChristianS: that's pseudo code, don't interpret it litteraly
14:24:58 <k0ral> decodeFromBadCharset could be decodeFrom :: Charset -> ByteString -> Text
14:25:34 <monochrom> I don't get it. Isn't it as simple as: get data as bytes, decide how to decode it (look for headers? use heuristics? use default?), decode
14:26:03 <mauke> yes, headers, and that's not really simple
14:26:29 * cmccann recalls reading the HTML5 spec section about "how to guess character encodings"
14:27:07 <monochrom> well, presumably, the data format is set up so that you can find headers while still treating the data as bytes
14:29:26 <ChristianS> monochrom: Network.HTTP gives that headers so you can extract the charset from the Content-Type header. it's certainly doable but probably not much fun.
14:30:29 <monochrom> Network.HTTP is still living in the 1980s with all its latin1->String assumptions
14:30:29 <ChristianS> the second step would be to use a powerful enough library to decode many of the charsets that you'll find. text-icu package sounds reasonable for that.
14:31:32 <ChristianS> monochrom: k0ral already managed to get a bytestring out of Network.HTTP, but it doesn't seem to go any further than that.
14:32:16 <ChristianS> ideally, your network package would do the decoding for you, and return a correctly decoded string or Data.Text. anybody knows whether there is such a package?
14:35:04 <ChristianS> k0ral: even if you manage to pull off both steps, you may end up with an utf8-encoded xml file, but whose xml declaration says that the file is in latin-7 encoding.
14:36:29 <k0ral> actually I only need to re-encode just before writing the file
14:37:08 <k0ral> or not... the feed library may need String as input
14:38:14 <ChristianS> whatever. i guess it's time to wait for a http package that handles this mess, or else give up and use perl, as mauke suggested.
14:38:32 <k0ral> or improve the http package
14:39:59 <k0ral> anyway, thank you jedai, ChristianS and mauke, for taking time to explain/flame me :)
14:40:57 <ChristianS> :-) good luck!
14:42:41 <timthelion> So I had this problem that haskell-gtk was SIGSEGing on me.  Every singe app.  And then I realized, that my CPU was 64 bits, and I'd been running for years with a 32 bit kernel.  Reinstalled today, and gues what, haskell-gtk works!  Wonder if there is a correlation.
14:43:56 <monochrom> I have a 64-bit cpu and I'm using 32-bit linux and gtk and gtk2hs just fine
14:44:23 <monochrom> of course, all exe's and libs are also 32-bit
14:44:26 <timthelion> monochrom: what is your ghc version?
14:44:34 <monochrom> 7.0.3
14:44:45 <timthelion> monochrom: here I have 7.4.1
14:46:04 <timthelion> or perhaps it's just that the arch linux guys svn'd gtk2hs 32 hours ago :D
14:50:45 <td123> timthelion: http://projects.archlinux.org/svntogit/community.git/log/trunk?h=packages/haskell-gtk
14:50:49 <td123> timthelion: looks like you're right
14:50:59 <td123> (a new version was released exactly 32 hrs ago :P)
14:51:59 <nyingen> would it be worthwhile building a binding to the FFTW library that uses Vector instead of CArray?
14:54:29 <nyingen> this CArray business is pretty inconvenient
15:03:02 <Axman6> nyingen: i think people would appreciate that, yes
15:03:27 * hackagebot JuicyPixels 1.2 - Picture loading/serialization (in png, jpeg and bitmap)  http://hackage.haskell.org/package/JuicyPixels-1.2 (VincentBerthoux)
15:12:32 <nyingen> I don't like this array stuff at all. It seems like every time I look for a utility function that seems like it ought to be in the interface, it isn't
15:12:50 <Taneb> Such as
15:12:51 <Taneb> ?
15:20:54 <ga2arch> hi
15:21:51 <ga2arch> i have followed this tutorial http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
15:22:10 <ga2arch> but i don't understand where to place forkIO as suggested in the lastest part
15:22:33 <ga2arch> quoting "Use forkIO to add a command line interface, and you've got yourself an irc client with 4 more lines of code."
15:33:15 <BrianHV> is there any way to define an Eq instance for an existentially quantified type?
15:33:29 * hackagebot JuicyPixels-repa 0.2 - Convenience functions to obtain array representations of images.  http://hackage.haskell.org/package/JuicyPixels-repa-0.2 (ThomasDuBuisson)
15:33:51 <monochrom> that is too general
15:33:59 <BrianHV> data PageModule = forall a. (ToJSON a, FromJSON a, Show a, Eq a) => PageModule a    ...    instance Eq PageModule where PageModule a == PageModule b = a == b
15:34:20 <BrianHV> that doesn't work, for what I think is an obvious reason
15:36:45 <monochrom> what does equality mean? if two values have the same JSON serialization, are they equal? if two values have different JSON serializations, are they unequal?
15:37:40 <BrianHV> well... those are valid questions for where I'm hoping to end up, but what I'm asking now doesn't depend on their serialization.
15:37:55 <Kuba> Anyone from Poland? Join us on #haskell-pl :)
15:38:27 <Enigmagic> BrianHV: it's possible but you need to verify the 'a' is the same on both sides of the ==
15:38:54 <monochrom> ok, you still have to consider "what does equality mean?"
15:39:15 <Enigmagic> presumably "Eq a" would provide that?
15:39:56 <BrianHV> what I want it to mean is what I wrote in code, plus the types of a and b are the same.
15:40:27 <BrianHV> I imagine I'd have to use typeable or whatnot to do this the way I want
15:40:55 <monochrom> unfortunately usually you can't find out whether x and y have the same type, thanks to type erasure.
15:41:06 <monochrom> you can go Typeable, yes
15:41:29 <monochrom> which is to somewhat undo type erasure
15:42:02 <Enigmagic> i've typically seen it done via Typeable as well
15:43:34 <BrianHV> hm. maybe I don't want this to be existentially quantified at all...
15:43:37 * BrianHV records.
15:43:40 <BrianHV> recodes*
15:44:16 <Enigmagic> probably a better solution :)
15:45:57 <BrianHV> ADTs are more flexible than I usually give them credit for.
15:48:15 <rasfar> any opinions what would be a stable light-weight lib for creating a window with editable text?  i cannot install gtk2hs (depends on glib-0.12.3 which failed to install) with my haskell-platform 7.0.4.
16:04:00 <rasfar> really?
16:08:17 <tommd> Yes, he did change his name.
16:15:27 <rasfar> anyone used grapefruit?  or maybe wxhaskell would be better to try next, but learning something about reactive programming is appealing.
16:16:08 <timthelion> If I have a 1GB object in memory(say a large 3D model) and I modify it with a function. MyFunction :: MasiveThing -> MasiveThing  Will this mean that the object gets copied and a new 1gb of memory gets alocated?
16:16:22 <timthelion> because that would be impossible from a preformance standpoint
16:16:29 <rostayob> timthelion: no, it doesn't get copied.
16:16:41 <timthelion> rostayob: what happens?
16:16:49 <timthelion> it gets modified in place?
16:17:00 <rostayob> timthelion: well it depends what data you are manipulating
16:17:34 <rostayob> if it's for example a large binary blob (e.g. a large bytestring) if you want to modify it in a pure function you have to copy it
16:17:58 <rostayob> but if you're modifying an haskell data type the new parts will share the old parts with the provided data
16:18:33 <rasfar> well, grapefruit-examples installed at least
16:18:54 <timthelion> rostayob: Say I have a mesh, so it's a Data Vertex = Vertex Point Vertex Vertex Vertex(I think my syntax is right there)  that is a vertex which points to three other syntax.  And we preform a transform which changes the values of every point, across a million vertexes...
16:19:15 <stj> how would I make this (Node is a constructor) strict: find (go n x) x without introducing ugly lambda functions? what would be an elegant way to do it?
16:19:30 <stj> ignore what I wrote in paretheses, it's irrelevant
16:20:04 <mauke> (find $! go n x) x
16:20:08 <rostayob> timthelion: if you're changing the value of every point that's like creating a new Vertex, so you are creating a new data structure
16:20:13 <rostayob> and no sharing can take place
16:20:35 <rostayob> timthelion: anyways I have to go look up at sharing in purely functional data structures
16:20:45 <stj> mauke: wonderful, thanks
16:21:24 <timthelion> rostayob: hmm, in imeritive code, the values get changed in place, which is fast.  I'd need something as fast as what I can do in C.  I'm not trying to insult haskell, I'm just trying to figure out a good solution.
16:24:31 <timthelion> rostayob: actually the best example is Gimp. how would you implement changing the brightness of an image in haskell, so that it didn't mean that you had to copy the entire image in memory...
16:25:27 * ski supposes some diff-thing could be possible
16:26:00 <snhmib> timthelion: haskell has mutable arrays
16:26:40 <ski> (i.e. you could have an image, plus a representation of operations to perform on it -- then after adding enough operations, you could render the operations all at once, constructing just a single new image)
16:27:01 <timthelion> ski: but the user likes to see their changes as they make them :)
16:27:22 <ski> yeah -- this isn't appropriate in all cases
16:27:25 <timthelion> snhmib: and you want to use IO for one of the most basic image processing operations?
16:27:59 <snhmib> or ST
16:28:48 <timthelion> hmm
16:29:43 <timthelion> thanks for your thoughts
16:30:20 <pozic> Aren't GHC's internals way too crippled for image processing?
16:30:37 <pozic> Or has that changed?
16:30:45 <snhmib> crippled?
16:31:44 <pozic> If you do anything remotely looking like functional programming in the image processing domain your performance will be around zero.
16:32:24 <pozic> You have to resort to programming using malloc in the IO monad to get any decent performance.
16:33:04 <pozic> Haskell and 'modern machines' are a bad fit when it comes to those things. For lots of other things it doesn't really matter.
16:33:16 <snhmib> ghc unboxed arrays wouldn't be very slow no?
16:33:34 <pozic> snhmib: if you are used to C++ performance, they are slow.
16:34:14 <pozic> I don't know why, but writing a program in C++ (or nowadays perhaps D) that works efficiently is much easier than in Haskell.
16:34:20 <Makoryu> pozic: ^ By "GHC's internals" were you referring to the card marking issue where garbage collection interacted with large mutable arrays in a way that degraded performance?
16:34:34 <pozic> Makoryu: for example.
16:34:37 <snhmib> well yea that's true enough
16:34:41 <pozic> Makoryu: did that get resolved?
16:34:46 <Makoryu> pozic: I believe it did.
16:34:52 <pozic> Makoryu: URL please.
16:35:36 <pozic> I would also expect GHC to have region type-inference.
16:36:29 <pozic> With region type-inference applied in the right way, you can beat C compilers, because C programmers usually write their programs in a different style.
16:37:15 <Makoryu> pozic: Gimme a minute to find it. I heard this some time last year, and haven't seen any discussion of it since then.
16:37:46 <pozic> I don't think GHC does region type inference.
16:38:17 <Makoryu> pozic: Well, of course. GHC isn't web scale, and the maintainers haven't read SICP.
16:38:42 <pozic> A problem with a lazy language is that such inference would only work for complete expressions, which is kind of hard.
16:38:50 <Modius> I gotta point out again, ghc-mod is fu********ing sweet.  Does this sort of functionality exist in the other editors?  It's like Devstudio + resharper in many areas.  This should be the go-to capability for people learning the language, nothing like having warnings from within the editor as soon as mistakes are made. . .
16:39:05 <Makoryu> http://hackage.haskell.org/trac/ghc/ticket/650 <- I am pretty sure this is what I was thinking of, but I'm not certain.
16:39:08 <Makoryu> @pozic
16:39:08 <lambdabot> Unknown command, try @list
16:39:45 <pozic> Modius: do you know how to disable certain features for hlint in ghcmod?
16:40:01 <pozic> Modius: yes, flymake does that for lots of languages.
16:40:10 <Modius> pozic:  I don't claim expertise in ghcmod, just that it impressed me.
16:40:14 <Modius> aah (on flymake)
16:40:31 <pozic> Modius: and other languages are far better integrated into a system.
16:40:32 <Modius> I meant, does this level of haskell "flymaking" exits on other editors?
16:40:57 <pozic> Modius: in Coq you cannot even make mistakes.
16:41:00 <Modius> I'm just wondering if "trying out haskell" should mean "on emacs" or if you can get this level of assist in the other editors.
16:41:15 <pozic> Modius: for Haskell? I don't think so.
16:41:41 <pozic> Modius: in Coq and Agda, if you make a mistake you cannot continue.
16:41:48 <Makoryu> pozic: Are you by any chance replacing scientists with artists?
16:42:06 <pozic> Makoryu: what are you talking about?
16:43:29 <Makoryu> Modius: "The "ghc-mod" program written in Haskell is a backend to gather information from GHC and hlint." <- Support for other editors can be implemented, but it probably isn't there yet in, for example, TextMate
16:43:48 <Makoryu> Modius: But the hard part is more or less done
16:44:34 <vodik> there is vim support too
16:44:43 <Modius> I'm still a dilettante in Haskell but the "flymakey" capability in FSharp/Devstudio helped me immensely learning F#.  I think especially for the beginner, "flymakey" capability should supercede all other considerations, new coders should go to Emacs/ghc-mod
16:44:45 <Makoryu> Whoops forgot the link
16:44:49 <Makoryu> Modius: https://github.com/kazu-yamamoto/ghc-mod
16:45:02 <Makoryu> I mean just look at the README
16:46:19 <rasfar> No, can't even try grapefruit b/c it only supports Gtk backend, and still:  glib-0.12.3 failed to install.
16:47:26 <pozic> rasfar: if something fails to install, bother whoever distributed the package.
16:47:42 <pozic> rasfar: if they are bothered enough, they fix it (or they retract the package).
16:47:54 <pozic> rasfar: in both cases we get in a better situation. (less garbage)
16:49:19 <td123> Makoryu: oh, ghcmod-vim is a relatively new project? thanks I'll have to check it out (since haskell-vim hasn't been developed recently)
16:49:26 <Saizan> rasfar: why did it fail?
16:49:56 <fizzbang> hello haskell! http://pastebin.com/GAuzFzwk upon running this, i get an ambiguous type for y0 on line 8 ...
16:49:57 <mauke> The paste GAuzFzwk has been copied to http://hpaste.org/65300
16:50:28 <monochrom> "I'm pleased to announce the release of gtk2hs, the definitive Haskell bindings to Gtk+. This release includes GHC-7.4 support" http://www.mail-archive.com/haskell@haskell.org/msg23942.html
16:50:29 <fizzbang> i think this is because the righthand list is empty, but how do i "add a type signature to fix ..." etc...
16:50:49 <fizzbang> if you can direct me to relevant documentation, i can rtfm..
16:50:49 <vodik> fizzbang: try reording your pattern matching
16:50:59 <vodik> fizzbang: put the _ [] expressions first
16:51:28 <vodik> nm
16:51:48 <rasfar> I've narrowed it down to a dependency of Haskell glib on (non-Haskell) gtk2hsC2hs.
16:51:52 <Saizan> fizzbang: e.g. print $ piz [1, 2, 3] ([] :: String)
16:52:03 <monochrom> so I am inclined to disbelieve that gtk2hs 0.12.3 fails with ghc 7.4
16:52:18 <Saizan> rasfar: did you cabal install gtk2hs-buildtools ?
16:52:23 <rasfar> I just unpacked it manually and edited the glib.cabal file to relax the dependency to 0.13.4 and cabal configure works (which is the step that failed).
16:53:02 <fizzbang> vodik: that didn't work..
16:53:11 <rasfar> Saizan: I did, or at least I tried to (and got the same error).  Note that gtk2hsC2hs is a file in /usr/bin or something, so the problem is my linux platform is a year old.
16:53:38 <fizzbang> Saizan: are you suggesting that i annotate the function _call_ ? is there a way i can fix this in the function definition?
16:54:12 <Saizan> rasfar: i think you want to remove the gtk2hsC2hs that you have installed from your distro so that you can get the one from hackage to wrok properly
16:54:15 <rasfar> monochrom: it's 7.0.4 (said so someplace above...)
16:54:17 <monochrom> you should have gtk2hsC2hs in $HOME/.cabal/bin and it should be new
16:54:18 <pozic> fizzbang: he just said to annotate the empty list.
16:54:30 <pozic> fizzbang: an 'empty list' as such does not exist in Haskell.
16:54:41 <pozic> fizzbang: there is the empty list of Int values.
16:54:48 <pozic> fizzbang: there is the empty list of Bool values.
16:54:55 <pozic> fizzbang: but there is no 'empty list'.
16:54:55 <rasfar> monochrom: really?  it is in gtk2hs-buildtools?
16:55:17 <monochrom> yes
16:55:18 <vodik> pozic: i think he's asking how does zip know
16:55:19 <Saizan> fizzbang: yes, the function call, and you can solve it from the function def. only if you want to make the type of piz more restricted
16:55:25 <vodik> > zip [1,2,3] []
16:55:25 <lambdabot>   []
16:55:31 <pozic> fizzbang: []::[a], but that cannot be constructed.
16:55:56 <pozic> fizzbang: [True,False]::[Bool] can be constructed (I just did).
16:55:56 <rasfar> i'll try to sort that out, but (okay, well, that failed to install...) (will double check) -- anyhow I think I can build glib with 0.13.4....
16:56:05 <fizzbang> pozic: then why does "zip [] [3, 4, 5]" work? (zip defined in prelude, no annotation on the empty list)
16:56:23 <pozic> fizzbang: because it derives the 'a' from the other list.
16:56:24 <vodik> fizzbang: it doesn't
16:56:33 <vodik> fizzbang: try rerunning your code with zip insead of piz
16:56:34 <pozic> fizzbang: if you annotate 3 with ::Int
16:56:37 <fizzbang> Saizan: i don't mind making it more restricted-- I'm hear to learn! what's your suggestion?
16:56:38 <vodik> fizzbang: it fails the same way
16:56:48 <vodik> fizzbang: same error too
16:57:02 <rasfar> i just went carefully through APIs etc. to make sure that my own first cabal package had the laxest possible dependencies ... a tool to help automate that would be super, is there?
16:57:03 <vodik> (just tried it on my machine)
16:57:10 <Saizan> fizzbang: you'd have to replace x and y in the type with concrete ones
16:57:29 <Saizan> fizzbang: but really the right way is to annotate the calls where necessary
16:57:58 <rasfar> (yes glib built with the relaxed gtk2hsC2hs dep, whew!...)
16:58:11 <fizzbang> vodik: you're correct -- it worked in ghci but not in my compiled file -- now i'm confused about this discrepancy
16:58:21 <vodik> fizzbang: laziness
16:58:29 <vodik> fizzbang: try piz in ghci, works just fine there
16:58:36 <Saizan> fizzbang: with less trivial examples it won't be needed as often because there'll be more information for the type inference to work
16:58:44 <Saizan> vodik: laziness has nothing to do with this
16:58:50 <vodik> fizzbang: laziness and ghci does something special i think when its showing value
16:58:55 <deggis> rasfar: i would be interested in that tool too
16:59:10 <vodik> fizzbang: well drop the laziness part i guess
16:59:26 <Saizan> fizzbang: it works in ghci because it will try to resolve ambiguities with some ad-hoc rules
16:59:42 <Saizan> fizzbang: this is called "extended defaulting" in the manual
16:59:53 <rasfar> deggis: which one, you mean generally the lightweight text-editor GUI?
17:00:54 <fizzbang> Saizan: vodik: pozic: thank you three! I'll get back to the aforementioned manuals then..
17:00:56 <rasfar> drat! still getting "depends on glib-0.12.3 which failed to install" for ... everything grrr
17:01:19 <monochrom> you really have old software overriding new software
17:01:24 <rasfar> maybe i didn't register it? i thought "cabal build" automatically registered
17:01:32 <monochrom> no, does not
17:02:14 <rasfar> oops, so I should chase my build with an explicit "cabal install" ...  (I realise this is a bad way in general to go about solving my problem, I'll do it right later promise)
17:02:52 <monochrom> it's {cabal install} or {cabal configure, cabal build, cabal copy, cabal register}
17:03:22 <rasfar> oh, crap, i already just did cabal install in the build dir, and it worked (including haddocking)
17:03:36 <rasfar> but thanks -- wonder why it worked
17:03:38 <monochrom> actually the correspondence is inexact
17:03:56 <monochrom> well, "cabal install" just re-does a lot of work
17:04:12 <rasfar> well, i'll try "cabal install grapefruit-ui-gtk" again and see where i stand
17:04:24 <rasfar> okay, well, it didn't recompile or relink at least...
17:04:49 <monochrom> anyway there is much unverified misinformation about the cabal commands. people just assume. opinionative method vs scientific method
17:05:28 <rasfar> oh -- now other packages are also complaining about "gtk2hsC2hs version >=0.13.5 is required" so I just effectively proved why editing the .cabal file was a poor solution...
17:07:07 <td123> rasfar: did you install with cabal install gtk2hs-buildtools
17:08:18 <rasfar> td123, monochrom: you are right, I "could have sworn" I attempted to install gtk2hs-buildtools -- no wait, I did, but it was in a shell script not in command-line history...
17:08:38 <monochrom> "C->Haskell Compiler, version 0.13.5 (gtk2hs branch) "Bin IO", 13 Nov 2004"
17:08:47 <rasfar> but there was a list of packages to install, it probably failed before it reached that one.  It's just finishing compiling now ...
17:08:50 <monochrom> that's what I get with gtk2hs-buildtools 0.12.3
17:09:04 <monochrom> you are really allowing old software to override new software.
17:09:11 <rasfar> Linking dist/build/gtk2hsC2hs/gtk2hsC2hs ...
17:09:20 <rasfar> w00t!
17:09:34 <monochrom> gtk2hs-buildtools has 3 executables: gtk2hsC2hs, gtk2hsHookGenerator, gtk2hsTypeGen
17:09:49 <rasfar> thanks people
17:09:49 <monochrom> if any one of them is stale, something will break
17:10:06 <rasfar> i've never been a fan of Gtk somehow
17:10:29 <rasfar> but last night (i'm offline at home) i wanted to try a GUI and all I had was UI.Gtk stuff...
17:11:28 <rasfar> i'd prefer something lighter-weight.  hello world weighs in at 13 MB with Gtk...  But I'll be happy enough to get a reactive window.
17:11:57 <dcoutts_> rasfar: that's not so much gtk's fault as ghc really
17:12:11 <dcoutts_> the binary size I mean
17:12:54 <rasfar> oh?  i tried an experiment yesterday, moving all dependant libs (including /usr/lib stuff) for my app build -- into a ramdisk.  but it didn't give me faster link times unfortunately.
17:13:10 <rasfar> s/moving/copying
17:13:25 <rasfar> (and adjusting ghc -L paths)
17:14:02 <monochrom> you can almost never be sure that your adjustments are sufficient or complete
17:14:23 <monochrom> but you can use -v3 or something to verify
17:14:33 <rasfar> never managed to get ghc -dynamic to work yet, i try it occasionally, but then you pay the linker penalty each time you run the app, right?
17:15:44 <monochrom> have you measured the two respective penalties?
17:15:48 <rasfar> i was thinking of using some sort of I/O inspection to see if it was disk use, but really, during linking my program (with the executable target on ramdisk, but libs on hdd) I hardly see the disk light flicker at all, so i gave up on that.
17:16:28 <rasfar> assumed it's just a mamoth link job that takes some seconds (this is an Asus 1015pn netbook, only).
17:16:56 <rasfar> s/mam/mamm
17:18:42 <stj> how would I define a datatype like this? data Tree a (Num a, Bounded a) = Empty | Node a
17:18:49 <rasfar> I'd still appreciate hearing opinions about lightweight GUI (or text-capable interactive graphics anyway).  Gtk is a huge dependancy.
17:18:51 <stj> where should I put classes for "a"?
17:18:54 <rasfar> (sorry stj)
17:18:58 <otters> data (Num a, Bounded a) => Tree a = Empty | Node a
17:18:59 <otters> iirc
17:19:19 <shachaf> otters: That doesn't do what you want.
17:19:23 <otters> okay
17:19:28 <monochrom> you should put those classes nowhere. delete them.
17:19:28 <otters> disregard me
17:19:28 <shachaf> stj: There's no Haskell 98 way to do what you want.
17:19:44 <stj> I see
17:19:53 <shachaf> otters: You can put the constraints in the place otters said, but it won't help you with anything.
17:19:55 <dibblego> stj: that's not a Tree by the way -- that's Maybe
17:20:18 <shachaf> dibblego: It's a finite tree of depth ≤1. :-)
17:20:22 <dibblego> perhaps you want data Tree a = Empty | Node (Tree a) a (Tree a)
17:20:37 <stj> shachaf: yeah, I know, it was just a stupid example :)
17:20:50 <shachaf> stj: You'll still need to put the constraints on every function that uses the type.
17:21:05 <shachaf> stj: There *is* a way with GADTs to do something that's approximately like what you want.
17:21:10 <shachaf> But you probably shouldn't use that either.
17:21:24 <shachaf> Especially for this -- why would you want to constrain a tree to operate only on Nums?
17:21:24 <stj> um, all right
17:21:41 <dibblego> stj: type-class constraints on functions, not data types
17:21:48 <stj> you'd frown upon me if I told you, so I'll keep quiet :)
17:22:24 <JoeyA> Is it possible to create unboxed newtypes?
17:22:34 <monochrom> it is legit to want to restrict your data. but it is silly to believe that data (Num a) => ... helps you.
17:22:55 <shachaf> monochrom: Right.
17:23:03 <shachaf> Well, the only reason it's silly to believe it is that it's wrong.
17:23:15 <JoeyA> If I say newtype Foo = Foo Int#, I get a kind mismatch (since Foo is not unlifted).
17:23:24 <monochrom> law of excluded middle: you will export Tree details (Empty and Node), or you will not.
17:23:54 <monochrom> if you will export, why don't you let other people use that type without yours restrictions? you're bloody exporting it
17:24:05 <rasfar> [  3 of 207] Compiling Graphics.UI.Gtk.General.Enums ... omg my poor little netbook!
17:24:27 <monochrom> if you will not export, you already impose restrictions some other way
17:25:27 <hpaste> “what I'm trying to do” pasted “stj” at http://hpaste.org/65311
17:25:58 <stj> oh, by the way, Tree is really this: data Tree a = Empty | Node !(Tree a) !a !(Tree a) deriving (Show,Eq)
17:26:18 <shachaf> stj: The "a" in "(maxBound :: a)" isn't the same a.
17:26:20 <blackdog> is there a difference between hsenv and virthualenv?
17:26:28 <shachaf> Unless you're using ScopedTypeVariables
17:26:50 <shachaf> But I'm not sure that you need the (:: a) at all.
17:26:57 <monochrom> "find s (maxBound :: a)" is the same as "find s (maxBound :: b)" or any other type variable name
17:27:04 <stj> wow, cool
17:27:06 <shachaf> What's the type of find?
17:27:11 <stj> looks like I don't need it :)
17:27:17 <stj> find :: (Ord a) => Tree a -> a -> Tree a
17:27:47 <shachaf> So just using maxBound works?
17:27:52 <shachaf> There you go, then.
17:27:56 <stj> shachaf: yeah :)
17:28:05 <stj> thanks =)
17:31:20 <rasfar> monochrom: "you can use -v3 or something to verify" -- just for completeness sake, to answer you, yeah, that's what I did to determine which libs to copy.
17:33:16 <danharaj_> Is it possible to write new UArray instances?
17:33:55 <rasfar> well, aside from the typical "could not find link destinations" warnings, it built, wow.
17:36:27 <stj> is it possible to declare something like data Tree a { left :: Tree a, right :: Tree a, _ :: Int } where the third element doesn't have a getter/setter function?
17:36:45 <stj> sorry, should be Tree a = Node { left .......
17:37:03 <byorgey> danharaj: you mean IArray?
17:37:03 <monochrom> no, if you start giving field names, you have to be complete
17:37:08 <byorgey> danharaj: UArray is a type
17:37:11 <stj> all right
17:37:20 <monochrom> give it a 30-letter name so no one will use it in practice
17:37:43 <monochrom> dontusemedontusemedontusemedontuseme should work
17:37:53 <byorgey> danharaj: and yes, of course it is
17:38:08 <danharaj> byorgey: I meant instances of IArray with the first type fixed to UArray.
17:38:28 <byorgey> monochrom: even better, subtly misspell one of the words in the middle of the name
17:38:45 <byorgey> dontusemedontusemedontusmedontuseme
17:38:53 <monochrom> or oxyaminochlorofluorobromoiodotetrabenzododecathane
17:39:33 <monochrom> ask an organic chemist for further ideas on long names
17:39:46 <byorgey> or look at the closest bottle of shampoo
17:39:48 <lukish> How can I call that parser function? occP ∷ String → GenParser Char st Int
17:39:53 * cmccann suggests "ceciN'estPasUneFonction"
17:40:03 <lukish> parse occP x ("" s)
17:40:11 <lukish> Not works
17:40:17 <byorgey> lukish: occP must be applied to a String.
17:40:35 <tech2>    pneumonoultramicroscopicsilicovolcanoiosis? (can anyone play this game?)
17:41:05 <byorgey> tech2: 'volcanoCONiosis', IIRC
17:41:24 <tech2> byorgey: Good thing I don't work in the field :)
17:41:24 <lukish> Ow
17:41:27 <lukish> parse (occP x) "" s
17:42:02 <rasfar> dodecamethylcyclohexasiloxane baby
17:42:57 <stj> suppose I have something like this:  data Tree a = Empty | Node { size :: Int, left :: Tree a, right :: Tree a } and I want size Empty to be == 0 -- what would be the best way to achieve something like that?
17:43:38 <byorgey> stj: do   Empty | Node { _size :: Int, ... }
17:43:51 <byorgey> stj: then define  size Empty = 0; size (Node s _ _) = s
17:44:06 <danharaj> What do I need to satisfy with a datatype in order to sensibly write a IArray UArray instance for it?
17:44:31 <danharaj> (If it's possible)
17:44:36 <stj> byorgey: thanks
17:45:33 <Saizan> danharaj: i don't think it is
17:45:38 <byorgey> danharaj: it needs to have an unboxed variant, I suppose.
17:45:45 <rasfar> \o/ the grapefruit-examples work!  depends on just 400 source files to display a window with an asterisk in it. :-/
17:46:05 <danharaj> Saizan: Even if the type is just a glorified tuple of basic types?
17:46:47 <byorgey> danharaj: if those basic types can be unboxed, it might be possible, I am not sure.
17:47:32 <Saizan> i don't think enough of UArray is exposed to let you do so
17:47:54 <byorgey> danharaj: is there a particular reason you need to use UArray?  Can't you use e.g. the 'vector' package?
17:48:17 <byorgey> danharaj: vector has an adaptive unboxed vector type which can work on tuples etc.
17:48:20 <danharaj> byorgey: Well I'd like to have a 2d index, but I guess I could use repa over it.
17:50:02 <danharaj> Yeah, I'll probably do that I guess. It seems like Vector has been arranged to allow instances of unboxed vectors to be written.
17:50:44 <byorgey> yep, I think you just need to give an instance for a data family
17:51:13 <byorgey> the documentation has an example.
17:51:21 <danharaj> hmm, but I don't think repa has an interface for use with ST. I really would like to have a multidimensional index.
17:51:41 <danharaj> Pretty sure it's built on top of Vectors and not MVectors.
17:52:50 <Saizan> you could do your instance using a tuple of UArray's as the representation for your own Array type
17:54:29 <NihilistDandy> Any good reason configuring network would hang on the "--supported-languages" step?
17:57:44 <lukish> I have strange result for that parser http://hpaste.org/65313 .
17:57:46 <lukish> > parse (occP "an") "" "ananan"
17:57:46 <lukish> Left (line 1, column 4):
17:57:46 <lukish> unexpected "n"
17:57:46 <lukish> expecting "an"
17:57:47 <lambdabot>   Not in scope: `parse'Not in scope: `occP'
17:57:48 <lukish> it :: Either ParseError Int
17:57:53 <lukish> Actually I expect 3
17:58:00 <stj> is it possible to do something like this? UNode = update . Node -- here update is Tree a -> Tree a -- and Node is a data constructor for Tree a
17:58:26 <stj> the compiler is complaining: Not in scope: data constructor `UNode'
17:58:50 <danharaj> stj: the name can't start with a capital
17:59:13 <danharaj> stj: the only values with cap names are data constructors.
17:59:30 <stj> I see
18:00:56 <hpaste> stj pasted “what I'm doing -- another error :/” at http://hpaste.org/65314
18:01:58 <mauke> stj: seems fairly obvious
18:02:02 <mauke> @src (.)
18:02:02 <lambdabot> (f . g) x = f (g x)
18:02:03 <lambdabot> NB: In lambdabot,  (.) = fmap
18:02:06 <danharaj> :t (.)
18:02:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:02:12 <danharaj> damn you caleskell.
18:02:16 <mauke> uNode = update . Node
18:02:24 <mauke> therefore uNode x = update (Node x)
18:02:43 <mauke> and that's a type error because Node x isn't a Tree
18:03:38 <stj> hmmm, do you have a suggestion on what I could do achive what I want? :))
18:03:56 <stj> creating Trees like this would be pretty handy and I have lots of these in my code: uNode 0 Empty x tt
18:04:02 <danharaj> :t \f g -> ((((f .).).).) . g
18:04:03 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4) => (a -> b) -> f4 (f3 (f2 (f1 (f a)))) -> f4 (f3 (f2
18:04:03 <lambdabot> (f1 (f b))))
18:04:18 <monochrom> I can't tell what uNode is supposed to do
18:04:19 <danharaj> curse you caleskell.
18:04:30 <Saizan> stj: just spell out the arguments in your definition of uNode
18:04:33 <danharaj> it's supposed to construct a tree and then apply update to it.
18:04:41 <stj> danharaj: sorry about that, but I'm still not on a level to be able to understand this :(
18:04:59 <danharaj> stj: I was just jerking around. Saizan's suggestion is the most sensible.
18:05:03 <stj> monochrom: create a node, then call function 'update' on that node and return it updated
18:05:16 <stj> Saizan: thx
18:05:19 <monochrom> create a node from what?
18:05:21 <danharaj> There is a way to use sections and (.) to get versions that compose functions where the second argument takes more arguments.
18:05:50 <danharaj> monochrom: from the inputs to uNode. He tried to write (\w x y z -> update $ Node w x y z) point free.
18:06:18 <stj> monochrom: not sure if I understand what you're asking
18:06:35 <monochrom> you can't write pointfree code by intuition
18:06:36 <rasfar> or you could maybe use free sections
18:07:28 <stj> monochrom: I see, will look deeper into that later... I haven't even learned to use monads for real yet :/
18:07:39 <monochrom> monad is not involved
18:07:43 <lukish> Can anyone helps me with my parser?
18:07:48 <danharaj> monochrom: It's an easy mistake to make when you think about a function alternatively as taking an n-tuple and its curried form.
18:08:00 <stj> monochrom: just trying to show how much of a noob I am :)
18:08:13 <mauke> stj: you're already using monads
18:08:20 <lukish> I need here http://hpaste.org/65313 separator which actually can be any string
18:08:51 <stj> mauke: really? :) could you give me an example of a monad in my code?
18:09:14 <danharaj> stj: The identity monad.
18:09:22 <mauke> stj: ((->) e)
18:09:47 <mauke> stj: and [], but only implicitly (Show)
18:09:53 <dibblego> I bet you have \x -> f x x somewhere
18:10:07 <stj> dibblego: I doubt it :)
18:10:14 <dibblego> want a bet?
18:10:29 <stj> sure
18:10:37 <clintm> heh
18:10:49 <dibblego> you can set the terms if you like
18:10:50 <stj> oh by the way, I'm working on a simple&short splay tree implementation
18:11:42 <mauke> splay trees mutate on read :-/
18:12:30 <stj> mauke: splay trees are sexy
18:12:42 <mauke> yes, in C
18:13:20 <stj> hmm, my implementation looks promising
18:13:35 <dibblego> I also bet there is \f g x -> g (f x) x
18:15:11 <stj> I hope to finish it soon and paste it... then we can compare it with my implementation in C (and maybe some other haskell implementations)
18:15:49 <NihilistDandy> dibblego:
18:15:50 <NihilistDandy> >(\ f g x -> g (f x) x) (+2) (2 + 3) 4
18:15:54 <NihilistDandy> > (\ f g x -> g (f x) x) (+2) (2 + 3) 4
18:15:55 <lambdabot>   5
18:15:56 <NihilistDandy> derp
18:16:21 <JoeyA> Is there a shorter way to say ptr `plusPtr` sizeOf a ?
18:16:33 <JoeyA> Err, nevermind
18:18:06 <dstcruz> Greetings! I have ran "runhaskell Setup.hs build" on a package of mine. Is it possible to load said package into ghci without having to "cabal install" it?
18:18:16 <stj> is this really Data.Tree.Splay? I think it's wrong http://hackage.haskell.org/packages/archive/TreeStructures/0.0.2/doc/html/src/Data-Tree-Splay.html
18:18:17 <augur> is it possible to detect differences in program paradigm from machine behavior?
18:19:01 <stj> as far as I can see, lookup is just naive rotate-to-root method (there are no zig-zig, zig-zag, zag-zig and stuff)
18:20:48 <NihilistDandy> dstcruz: You should just be able to ghc-pkg register it
18:21:42 <dstcruz> it has to be registered? there is no way to tell ghci to "use this file here" kinda thing?
18:22:11 <monochrom> you can, but first you have to find out where it is stored. poke around the dist directory
18:22:54 <dstcruz> I see the .o, .a, .hi, and other files. I'm lacking the incantation to pass to ghci to use that
18:23:07 <monochrom> find out about the -i option
18:27:19 <rasfar> augur: interesting question!
18:27:28 <augur> rasfar: :D
18:33:47 <n3hima> what's the best way to get data out of an NTree?
18:34:09 <n3hima> do I really have to write lots of recursive boilerplate pattern-matching functions?
18:34:58 * ski wonders what an `NTree' is
18:35:06 <companion_cube> if it is Foldable or Traversable, you may avoid it
18:35:35 <ski> n3hima : often, you could write an `foldNTree' operation which would help
18:36:04 <rasfar> NTree = rose tree I think
18:36:07 <tgeeky> is an NTree a mutually recusrive data type?
18:36:22 <n3hima> I don't know what that means
18:36:26 <rasfar> HXT uses, that's where I came across them
18:36:34 <n3hima> yeah I'm using HXT
18:36:36 <rasfar> Node a [NTree a]
18:37:01 <rasfar> each node has a value, and a list of subtrees
18:37:03 <mauke> :t Tree
18:37:04 <lambdabot> Not in scope: data constructor `Tree'
18:37:06 <ski> rasfar : ok, like `Data.Tree', then ?
18:37:06 <mauke> :t Node
18:37:07 <lambdabot> forall a. a -> Forest a -> Tree a
18:37:13 <ski> that, yes
18:37:13 <tgeeky> I think mutual recursion is when you have two types that (can) have each other as children, so this doesn't seem to be one
18:37:16 <mauke> > Node 42 []
18:37:17 <lambdabot>   Node {rootLabel = 42, subForest = []}
18:37:27 <ski>   type Forest a = [Tree a]
18:38:12 * ski wonders what the data n3hima wants to extract it
18:38:30 <rasfar> yes, apparently the same idea
18:39:04 * ski suspects `foldMap' will do what n3hima wants
18:39:06 <n3hima> well essentially I have a tree representing some xml data, and I want to get the text from the top level element
18:39:07 <ski> @type Data.Foldable.foldMap
18:39:08 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
18:40:00 <n3hima> hmm yes I think I understant that
18:40:22 <ski> hm, if it's the top level element, why not just extract it, and get the text from it ?
18:40:34 <ski> shouldn't need a recursive function for that
18:41:17 <n3hima> no it's not recursive sorry, I got slightly mixed up with something I was doing earlier with the same data
18:41:24 <rasfar> n3hima: you may want innerText
18:41:35 <rasfar> or, if the text is stored in an attribute:
18:42:09 <rasfar> hasAttrValue "class" (=="blah") or similar
18:42:18 <n3hima> is innerText a functin?
18:42:30 <n3hima> because that is pretty much exactly what I want
18:42:44 <rasfar> i forget, i'm just looking at an old source file of mine to dredge these things up.  it's all in the HXT docs though :)
18:44:40 <manateeUser> Hello, all. :)
18:44:57 <manateeUser> Test manatee's irc client. ;)
18:45:42 -mauke(~mauke@p3m/member/mauke)- hello!
18:46:11 -Makoryu(~bloodgog@pool-74-104-128-38.bstnma.fios.verizon.net)- Hi mauke
18:46:19 <Gwern-away> @quote
18:46:20 <lambdabot> <vic_> says: everytime you unsafePerformIO, a C++ programmer spawns
18:46:22 -Makoryu(~bloodgog@pool-74-104-128-38.bstnma.fios.verizon.net)- How's it going
18:46:32 <manateeUser> :> map (+1) [1..10]
18:46:42 <manateeUser> > map (+1) [1..10]
18:46:43 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
18:46:54 <Makoryu> > map (/0) [1..10]
18:46:55 <lambdabot>   [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,In...
18:47:25 <mauke> > map 0 [(/),(/)]
18:47:26 <lambdabot>   [0,0]
18:47:53 <Makoryu> Whao
18:48:14 <Makoryu> What's the Num (a -> a) instance look like for that?
18:48:19 <Makoryu> Or
18:48:31 <dmwit> Num (a -> b)
18:48:32 <Makoryu> Is it Num (a -> a -> a)
18:48:37 <byorgey> Num a => Num (b -> a)
18:48:42 <dmwit> fromIntegral n = const n
18:48:48 <dmwit> s/Integral/Integer/
18:49:11 <Makoryu> > 0 0
18:49:12 <lambdabot>   0
18:49:13 <dmwit> [(+),(-),(*),(/)] = map liftM2 [(+),(-),(*),(/)]
18:49:16 <Makoryu> > 0 undefined
18:49:17 <lambdabot>   0
18:49:26 <dmwit> If only we could actually write that in a class instance. =P
18:49:30 <Makoryu> dmwit: Can you do that in an...yeah
18:49:39 <Makoryu> I'd like that
18:49:42 <mauke> dmwit: can't you?
18:49:50 <dmwit> mauke: nope
18:49:54 <mauke> :-(
18:49:56 <ozataman> is getCurrentTime an expensive call? (i.e. something like a system call)
18:52:47 <JoeyA> ozataman: It is a system call, but I wouldn't sweat bullets over it
18:53:25 <JoeyA> As long as you don't use it in the innermost loop of a bitmap rotation function, you should be fine ;-)
18:54:38 <JoeyA> ozataman: How often do you plan on calling it?
18:54:39 <n3hima> damn that's just what I was planning to do
18:54:40 <ski> > let [(+),(-),(*),(/)] = map liftM2 [(P.+),(P.-),(P.*),(P./)] in (2 * id) 3
18:54:41 <lambdabot>   6.0
18:54:56 <ben_m> I don't understand Arrows conceptually :( I understand what the ((->) r) Arrow does, but don't understand what Arrows are useful for in general. Does anyone have a good explanation or paper/article to read?
18:55:05 <JoeyA> n3hima: If you're interested in timing, use a monotonic time function instead ;-)
18:55:13 <dibblego> ben_m: ((->) r) is not an Arrow, (->) is
18:55:22 <ski> ben_m : Swierstra's and Duponcheel's original paper
18:55:23 <ben_m> Ah yeah, my mistake :)
18:55:31 <ski> ben_m : also Wadler has a paper, i think
18:55:40 <ozataman> JoeyA: If I don't cache calls to it, thousands of times a second. I can cut it down to 1/6th or 1/10th if I cache it during the computation
18:56:01 <ben_m> ski: I'l check them out, thanks.
18:56:56 <JoeyA> ozataman: Yeah, I'd be worried about thousands of times a second.
18:57:03 <dibblego> ben_m: I learned a lot about arrows by using the HXT package
18:57:20 <dibblego> I had read a lot of papers prior
18:57:20 * JoeyA installs criterion
18:57:53 <HugoDaniel> is there any better way to write this: sequence . map readFile $ fileLst
18:57:53 <HugoDaniel> ?
18:57:59 <mauke> mapM
18:58:09 <HugoDaniel> :)
18:58:12 <HugoDaniel> thanks
18:58:14 <dibblego> HugoDaniel: sequence . map f == mapM (or traverse) f
18:58:24 <ski> @src mapM
18:58:25 <lambdabot> mapM f as = sequence (map f as)
18:58:54 <dibblego> @type Data.Traversable.traverse readFile
18:58:54 <lambdabot> forall (t :: * -> *). (Data.Traversable.Traversable t) => t FilePath -> IO (t String)
19:00:48 <Makoryu> Is there a particular reason why the entire compilation process has to happen a second time when building ghci versions of libraries
19:01:30 <parcs`> it does?
19:01:34 <HugoDaniel> hmm
19:01:39 <HugoDaniel> and what about this: mapM readFile lst >>= return.concat  ?
19:01:52 <Makoryu> parcs`: ...Maybe not in GHC versions newer than what I have
19:01:52 <mauke> >>= return . is liftM
19:02:01 <parcs`> fmap concat (mapM readFile lst)
19:02:07 <Makoryu> parcs`: I mean, at build time, not at load time
19:02:16 <parcs`> :t concatMapM
19:02:17 <lambdabot> Not in scope: `concatMapM'
19:02:35 <dibblego> I have a (.>>=.) function for that
19:02:42 <HugoDaniel> hmm
19:02:48 <HugoDaniel> but liftM is not on prelude
19:02:59 <mauke> fmap is
19:03:02 <dibblego> use fmap
19:03:08 <HugoDaniel> ah yes
19:03:10 <HugoDaniel> yes yes
19:03:11 <HugoDaniel> thanks :)
19:03:13 <dibblego> or <$> if you have Control.Applicative
19:03:26 <dibblego> concat <$> mapM readFile lst
19:03:41 <HugoDaniel> yes, great :)
19:03:45 <parcs`> Makoryu: where/when do you observe this behavior?
19:03:46 <HugoDaniel> amazing readability
19:03:57 <Makoryu> parcs`: While installing stuff with Cabal
19:04:14 <Makoryu> Libraries get built twice
19:04:19 <parcs`> Makoryu: ghci doesn't need a special version of a library every since ghc 6.12 or something
19:04:37 <parcs`> what is the suffix of the object files during second build?
19:04:42 <parcs`> p_o? dyn_o?
19:04:48 <Makoryu> I think I'm on 7.0.4
19:05:08 <Makoryu> parcs`: Right now I'm looking at p_o
19:05:13 <Makoryu> There's a whole bunch of output
19:05:15 <Makoryu> Lemme scroll up
19:05:17 <parcs`> those are profiling libraries
19:05:19 <hpaste> “Joey Adams” pasted “Criterion benchmark for getCurrentTime” at http://hpaste.org/65318
19:05:33 <JoeyA> ozataman: It only takes a microsecond.
19:05:49 <JoeyA> So a million calls should only take a millisecond, I would hope.
19:05:52 <JoeyA> err
19:06:00 <JoeyA> right
19:06:05 <JoeyA> no, math fail
19:06:08 <parcs`> btw, i've noticed that the resolution of getCurrentTime is only around 1/800th of a second (on linux at least)
19:06:20 <ozataman> JoeyA: thanks, that's good to know. yeah - it'd take a second for a M calls
19:07:17 <ozataman> JoeyA: and thanks for doing the benchmark!
19:07:46 <ozataman> seems no need to prematurely optimize for that
19:08:17 <JoeyA> I should point out that safe foreign call overhead is smaller than that: http://hpaste.org/51264  (getCurrentTime uses an unsafe foreign call)
19:08:56 <JoeyA> A safe foreign call takes about 0.25 microseconds.
19:09:16 <JoeyA> (on whatever system was used to benchmark that)
19:10:09 <JoeyA> Actually, I get 0.331 microseconds on my system.
19:10:34 <JoeyA> (with -threaded; it's faster without -threaded)
19:11:07 <NihilistDandy> dylukes: Heard any good news about strange closure types on ML?
19:11:28 <dylukes> Well, it turns out it's a bit uh... deeper than expected.
19:11:47 <dylukes> Any binary compiled on 10.8 crashes on previous versions, firstly.
19:12:01 <NihilistDandy> Right, I rebuilt everything because I figured that'd be the case
19:12:02 <dylukes> Now, why GHC compiled on previous versions fails to compile stuff on 10.8, I don't know.
19:12:13 <dylukes> Yeah, I had no luck actually rebuilding anything.
19:12:19 <dylukes> Because I have nothing working to bootstrap from.
19:12:32 <NihilistDandy> Nor I
19:12:37 <NihilistDandy> I think I have the bindist
19:12:44 <NihilistDandy> So I suppose I do, really
19:12:47 <dylukes> It's apparently found it's way to the proper apple team
19:12:52 <dylukes> so it's a waiting game for now :\
19:13:20 <NihilistDandy> Well, I can run you through what worked for me, so far. Things work, I just can't cabal install or yesod init
19:13:29 <ski> NihilistDandy : "strange closure types on ML" ?
19:13:36 <NihilistDandy> At least you'll have a platform to work with
19:13:41 <NihilistDandy> skiold: Mountain Lion
19:13:48 <ski> .. mhm
19:14:03 * ski thought NihilistDandy was talking about either SML or O'Caml
19:14:18 <NihilistDandy> ski: Haha, yeah, I can see how that could happen
19:15:12 <NihilistDandy> dylukes: I just have to build everything manually and everything works fine. It's only slightly annoying :D
19:15:59 <dylukes> build manually?
19:16:04 <dylukes> so wait, it's something in the linking phase?
19:16:09 <dylukes> if so, add that to the GHC trac !!!!
19:16:11 <dylukes> ;___;
19:16:56 <dylukes> Glad to see it's currently moved up to highest priority in 7.4.2 milestone ^^
19:17:09 <dylukes> kudos to the GHC folks for having a responsive and aggresive dev team.
19:17:10 <NihilistDandy> Actually, I just got a segfault on some simple code out of RWH
19:17:25 <NihilistDandy> Segfault on run, though. It builds just fine
19:17:31 <dylukes> Yep.
19:17:36 <dylukes> Anything you build will crash.
19:17:39 <NihilistDandy> Oh, dear
19:17:41 <dylukes> But, that's true of ANYTHING built on 10.8.
19:17:43 <dylukes> Even with clang :D
19:17:50 <dylukes> except, those will only crash on pre 10.8.
19:18:01 <dylukes> GHC stuff will crash on *everything* (when built on 10.8).
19:18:13 <NihilistDandy> Getting RVM to play nice with 10.8 was a pain for a bit
19:18:26 <NihilistDandy> Yeah, I'm just finding that out :(
19:18:35 <dylukes> here's the trac, if you find anything
19:18:35 <dylukes> http://hackage.haskell.org/trac/ghc/ticket/5899
19:18:37 <NihilistDandy> I guess I'll just have to work in ghci for a bit
19:18:46 <dylukes> Nope...
19:18:47 <NihilistDandy> Because that's having no issues
19:18:51 <dylukes> how're you gonna cabal install packages :)?
19:18:54 <dylukes> You can't build them.
19:18:56 <NihilistDandy> I can
19:19:01 <dylukes> manually yes.
19:19:04 <NihilistDandy> Right
19:19:05 <dylukes> But compiling Setup.hs...
19:19:07 <dylukes> Setup will crash.
19:19:15 <NihilistDandy> That's why I don't compile it
19:19:18 <NihilistDandy> I just runghc
19:19:19 <dylukes> and if it uses a preprocessor? You're screwed.
19:19:24 <dylukes> Or if it requires alex or happy?
19:19:25 <dylukes> Screwed.
19:19:28 <NihilistDandy> True
19:19:36 <dylukes> So, that knocks out text, mtl, parsec...
19:19:45 <dylukes> template haskell, etc
19:19:51 <NihilistDandy> Which all compiled just fine
19:19:55 <dylukes> text did?
19:19:56 <dylukes> weird.
19:20:00 <dylukes> I have cpp issues. Anyways.
19:20:02 <alexbaranosky> does anyone know how many test trials quickcheck generates by default?
19:20:15 <dylukes> If you need to get stuff done in GHC, install linux and work from there for now.
19:20:27 <NihilistDandy> Yeah, I suppose that'll do
19:21:00 <rasfar> 100 I think
19:21:32 <alexbaranosky> rasfar, thanks!
19:21:48 <td123> I know this might be uninteresting for the majority, but does anyone else think it could be useful if ghc has a configure flag to auto build and install the cabal-install package that comes along with ghc?
19:21:59 <rasfar> http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck#Testing_with_QuickCheck
19:22:04 <NihilistDandy> dylukes: Though I'm grabbing 7.0.4 through homebrew just to see if things play out differently. I'm sure they won't, but...
19:22:07 <rasfar> ur welcome!
19:22:11 <dylukes> It won't :).
19:22:16 <dylukes> It just pulls it from the stable dist
19:22:33 <NihilistDandy> Yeah, I know. But the 7.4.1 dist built, so who knows?
19:23:42 <NihilistDandy> td123: Doesn't the Haskell Platform exist? Also, you can grab the Cabal darcs repo
19:23:55 <NihilistDandy> It's a pretty push-button process on most systems
19:24:39 <acowley> Anyone know who spacespacecomma on reddit is?
19:24:42 <td123> NihilistDandy: ya, but I'm talking about from a packager's perspective :P
19:25:03 <NihilistDandy> td123: I don't know that I know what you mean. Are you saying they should package cabal-install with ghc?
19:25:36 <td123> NihilistDandy: cabal-install does get shipped with ghc sources, but there is no way to tell the build process to automatically install cabal
19:26:06 <NihilistDandy> td123: Are you sure about that? I know Cabal is in there, I don't know about cabal-install.
19:27:18 <acowley> I'm with NihilistDandy on that one
19:28:16 <td123> NihilistDandy: yes, confirmed, just checked ghc-7.4.1/libraries/Cabal/cabal-install/
19:28:23 <NihilistDandy> That's unusual
19:28:50 <NihilistDandy> Well, you can add something to install-sh to do it for you
19:29:20 <NihilistDandy> My distribution of 7.4.1 didn't come with cabal-install :D
19:29:43 <td123> this is the source for ghc btw, not the distro's package
19:30:44 <NihilistDandy> Oh, I always grab the OS X bindist
19:31:08 <NihilistDandy> Maybe they just don't throw in cabal-install
19:31:23 <NihilistDandy> My /Cabal tree ends with Cabal/Cabal
19:31:48 <NihilistDandy> But hacking at install-sh will probably get you what you want
19:32:43 <td123> NihilistDandy: ya I was thinking that, but I'm not sure if ghc would be interested taking the same path as what ruby does (they ship their pkg manager with ruby and install it)
19:33:53 <danharaj> @pl \f g x y -> g x (f y)
19:33:53 <lambdabot> flip (flip . ((.) .))
19:34:03 <td123> I'm getting the source from http://www.haskell.org/ghc/dist/7.4.1/ghc-7.4.1-src.tar.bz2 fyi
19:34:33 <NihilistDandy> (flip flip id . (ap .) . flip (.)) (+2) (2 + 1) 9
19:34:37 <NihilistDandy> > (flip flip id . (ap .) . flip (.)) (+2) (2 + 1) 9
19:34:39 <lambdabot>   3
19:34:55 <danharaj> @pl \g x y -> g x (f y)
19:34:55 <lambdabot> flip flip f . ((.) .)
19:35:33 <danharaj> does pl do sections?
19:35:54 <danharaj> @djinn a -> a
19:35:54 <lambdabot> f a = a
19:35:59 <NihilistDandy> I dunno
19:36:20 <ski> `((.) .)' is a section
19:36:29 <danharaj> ski: with dummy variables
19:36:49 <danharaj> like I wanted it to spit out ((.f).)
19:36:53 <danharaj> I think that looks nice
19:36:55 <ski> @pl \x -> (x `f`)
19:36:55 <lambdabot> f
19:37:33 <ski> yeah, imo `pl' is a little bit too happy with using `flip'
19:37:42 <danharaj> @djinn (b -> b') -> (a -> b -> c) -> a -> b' -> c
19:37:43 <lambdabot> -- f cannot be realized.
19:37:49 <danharaj> err
19:38:00 <danharaj> @djinn (b' -> b) -> (a -> b -> c) -> a -> b' -> c
19:38:00 <lambdabot> f a b c d = b c (a d)
19:38:40 <ski>   \f g x y -> g x (f y)  =  \f g x -> g x . f  =  \f g -> (. f) . g  -- dunno if this helps
19:38:49 <rasfar> you might find fremissant.net/freesect interesting ... not saying it's a viable substitute.
19:39:21 <rasfar> http://fremissant.net/freesect sorry
19:39:38 <danharaj> ski: Yeah I'm just playing around with sections of (.) to see how I can twiddle the arguments to a multi argument function.
19:40:01 <rasfar> danharaj: truly, that's what my link is all about.
19:40:09 <danharaj> rasfar: cool
19:40:31 <monochrom> @src foldr1
19:40:31 <lambdabot> foldr1 _ [x]    = x
19:40:31 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
19:40:31 <lambdabot> foldr1 _ []     = undefined
19:41:07 <rasfar> my first cabal package -- just uploaded a couple days ago.  so you must forgive my enthusiasm (which is not shared by the likes of shafchaf, dolio, mzero ...
19:41:29 <danharaj> rasfar: A syntactic extension should always be met with some skepticism.
19:41:32 <dolio> do what now?
19:41:58 <rasfar> danharaj: i agree with that, especially now when Haskell is "exploding"
19:42:05 <dolio> Oh, right.
19:42:26 <rasfar> my intention isn't to get it in to GHC or anything, just an old cherished idea i took some time to work out
19:42:54 <danharaj> @djinn (a' -> a) -> (a -> b -> c) -> a' -> b -> c
19:42:54 <lambdabot> f a b c = b (a c)
19:43:11 <ski> preflex: xseen mgsloan
19:43:11 <preflex>  mgsloan was last seen on freenode/#haskell 2 days, 30 minutes and 15 seconds ago, saying: well,  to be fair, there is force-layout, but yeah, no proper graph layout
19:43:13 <rasfar> sorry if i woke you or anything dolio ;)
19:43:26 <dolio> Nah.
19:43:41 <ski> danharaj : mgsloan recently was thinking on some pointfree combinators which you might be interested in looking at ..
19:43:57 <ski> danharaj : there's also conal's SECs
19:43:59 <rasfar> if you get a chance to visit http://fremissant.net/freesect you might be amused, i dunno
19:44:14 <ski> (and my `(.:)',`(.::)',&c. stuff)
19:44:23 <danharaj> ah yes I saw that ski :)
19:44:28 <Axman6> @hoogle Storable a => [a] -> ByteString
19:44:28 <lambdabot> Prelude head :: [a] -> a
19:44:28 <lambdabot> Data.List head :: [a] -> a
19:44:28 <lambdabot> Prelude last :: [a] -> a
19:44:35 <ski> rasfar : "exploding" ?
19:44:36 <Axman6> -_-
19:45:09 <rasfar> well, with the number of packages, number of #haskell people, etc.  -- yes, "exploding"
19:46:05 <Axman6> rasfar: there's been this many people in this channel for several eyars
19:46:11 <Axman6> years*
19:46:39 <ski> rasfar : i have to say i'm not fond of your `__' idea, even with the `_[' and `]_' amendation
19:47:10 <ski> generally, i think lambdas are better
19:47:14 <rasfar> ski: that's fine, you're in good company.
19:47:29 <ski> (composing and scaling in a better way
19:47:40 <rasfar> did you see the section where i defend the syntax relative to lambdas?  i make some valid points.
19:47:41 <ski> rasfar : hm, so <http://fremissant.net/freesect> wasn't you, then ?
19:47:50 <rasfar> that is me, yes
19:48:08 * ski has only taken a very quick glance at it, yet
19:48:17 <rasfar> but i would use lambda myself, rather than run my preprocessor lol
19:48:20 <aristid> 837 nicks now... well, i guess that is close to the limit of what a freenode channel can support anyways
19:48:29 <Axman6> there's a limit?
19:48:33 <ski> (what's the limit ?)
19:48:43 <Axman6> better question
19:48:44 <danharaj> so sections with 1 or 0 .'s on the left and n on the right are pretty easy to understand.
19:48:45 <rasfar> there's five points in a list about how it compares to lambdas, i'd love to hear you refute those points.
19:48:48 <byorgey> more than 900 and it EXPLODES
19:49:03 <aristid> Axman6: i'm not sure, iirc there's a channel-configurable limit when people will be sent to #overflow
19:49:09 <aristid> byorgey: OH NOES
19:49:14 <Axman6> ah right
19:49:24 <danharaj> :t \f (.(.f))
19:49:25 <lambdabot> Parse error in pattern
19:49:42 <danharaj> :t \f -> (.(.f))
19:49:43 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => f a -> (f b1 -> b) -> (a -> b1) -> b
19:49:55 <ski> rasfar : i'll try to recall taking a look at it later (when i'm not as tired)
19:50:05 <parcs`> byorgey: the 900 mark has been hit a while ago :P
19:50:18 <parcs`> but iirc if a channel hits 1000 people it really explodes
19:50:23 <rasfar> ski: also, the web page is quite a bit better than formerly (as is the package).  thanks, i'd be very interested!
19:50:39 <byorgey> parcs`: it did explode, into 900 parallel universes
19:50:46 <byorgey> parcs`: you just can't tell because you're only in one of them
19:50:54 <Axman6> rasfar: it looks ugly and confusing to me. my 2c
19:51:27 <rasfar> these things are relative; comparable situations using lambdas or point-free also look ugly and confusing to me.
19:51:29 <danharaj> (.) sections are fun
19:52:07 <gwern> @quote
19:52:07 <lambdabot> ryan[WTF] says: it's enterprise quality if it runs everything in a big try/catch
19:52:17 <rasfar> but honestly, i'm not an advocate of free sections, just a bit enthusiastic because of all the recent effort.
19:52:43 <adu> haha
19:52:51 <ski> ("recent effort" referring to ?)
19:53:30 <rasfar> well, i began work on this from ground-zero about 3 weeks ago, and it uses patched HSE and SYB ... for me, that meant a lot of hard work.
19:53:45 <rasfar> maybe i shouldn't admit how much work!
19:54:26 <rasfar> now i'm turning to other things, and the enthusiasm can hopefully wane :)
19:54:50 <Axman6> it seems to me to add clutter to the code which may make things slightly clearer in small examples, but I have a strong feeling that it does not scale (in terms of user comprehension)
19:55:27 <rasfar> i think on the contrary it is with larger, "industrial" examples that it can shine
19:55:58 <rasfar> the toy examples look fine with lambda (even "better")
19:56:35 <rasfar> Axman6: the section "Some virtues of the new syntax" pretty much states my case.
19:57:44 <rasfar> My examples are still horrible.  I really need to improve those.  anyways, enough about me...
19:59:04 <NihilistDandy> That id one is a bit odd
19:59:25 <rasfar> NihlistDandy: you're right, that shouldn't be there even
20:00:08 <rasfar> in fact....
20:00:43 <rasfar> ....gone!
20:01:13 <NihilistDandy> It's followable, I'll give you that.
20:01:49 <NihilistDandy> It's typographically a little ugly, though. All those sharp lines :D
20:01:50 <rasfar> the bigger example ("dreadme") is more the type of situation where I'd expect it might find favour with someone.
20:02:38 <NihilistDandy> Mmhmm
20:02:41 <rasfar> I liked the _[ ]_ since it semiotically(?) actually symbolises what it means (combo of grouping and wildcards).
20:03:12 <rasfar> but most fonts put the _ too low and it just looks bad.
20:03:54 <rasfar> fortunately, you can usually omit the _[ ]_ with the context defaulting rules
20:04:50 <rasfar> as for the sharp lines, wish they could be single underscores but yet to figure out the reduce/reduce conflicts parsing
20:06:10 <rasfar> anyhow, it's been a real blast, and hopefully can be the start of more membership and contributions for me in the Haskell community.
20:06:40 <rasfar> next time i'll try to contribute patches to an existing project instead
20:07:21 <byorgey> rasfar: I think your extension is cool =)
20:07:45 <rasfar> byorgey, vous etes tres gentil, merci
20:09:24 <byorgey> rasfar: might I suggest http://projects.haskell.org/diagrams  as an existing project to which you can contribute ;)
20:09:26 <NihilistDandy> rasfar: I submitted a patch to Happy ages ago and hand no idea it had been merged until I tried to build happy and it didn't fail :D
20:10:19 <NihilistDandy> Though I imagine I wasn't the only one who had submitted the same change.
20:10:29 <eyebloom> I have a type synonym and I'd like to put a type constraint on the type synonym rather than other annotations that use it: as in type T a b = C a => a -> b
20:10:51 <eyebloom> then later use it in an annotation, ie.
20:11:02 <eyebloom> func :: T a b
20:11:08 <edwardk> eyebloom: that works
20:11:24 <eyebloom> don't I need a language extension?
20:11:39 <edwardk> eyebloom: the thing to note is that when you put it in negative position it doesn't usually mean what you want it to mean
20:11:50 <edwardk> so if you make a function that takes a T a b and gives you something else
20:12:00 <edwardk> then the constraint is in negative position
20:12:05 <edwardk> and you _probably_ don't want that
20:12:20 <eyebloom> well a function of type T a b is of type a -> b right?
20:12:29 <edwardk> Since (C a => a -> b) -> b  is not the same as C a => (a -> b) -> b
20:13:07 <eyebloom> I see, what is different?
20:13:37 <edwardk> (Foo => a) in negative position makes it an obligation. its clearer if you rewrite the =>'s as ->'s
20:13:50 <edwardk> which is what is going to happen behind your back in the compiler
20:14:04 <liyang> Constraints are all wrong. Why can't we just be explicit about the whole dictionary-passing business? ;_;
20:14:21 <edwardk> (C a => a -> b) -- says that given a constraint C a, i can give you a function from a -> b.
20:14:38 <eyebloom> Well, the goal is not to have to write C a => in every annotation that uses T a b
20:14:40 <Cale> liyang: because passing dictionaries around by hand everywhere really starts to suck quickly
20:14:49 <edwardk> liyang: because i actually like getting stuff done and i like confluence guarantees
20:15:21 <edwardk> eyebloom: sadly you can't just bolt it into the type like that since it will do the wrong thing when you accept a T a b in negative position.
20:15:44 <edwardk> liyang: if you want to plumb dictionaries by hand there is always scala. and what a lovely language that is.
20:15:56 <liyang> edwardk: was more thinking of Agda.
20:15:57 <eyebloom> What do you mean by negative oppinion?
20:15:58 <Cale> It would also probably make anything which used Eq, Ord, or Num ugly as sin :)
20:16:26 <eyebloom> *position
20:16:40 <edwardk> negative position is when it is on the left of an odd number of ->'s
20:16:48 <edwardk> a -> b  -- a is in negative position
20:16:53 <edwardk> b is in positive position.
20:17:07 <edwardk> (a -> b) -> c  -- a is back in positive position, b is still negative
20:17:37 <edwardk> if you work it out, a can be made covariant (you could write a Functor for Foo b c a = Foo ((a -> b) -> c)  if you wanted to
20:17:48 <edwardk> which is pretty much the definition of positive position
20:17:59 <edwardk> and it can be made contravariant if it occurs only in negative position.
20:18:06 <edwardk> er made an instance of Contravariant
20:18:17 <danharaj> and if it's in both...
20:18:23 <danharaj> (something about kan extensions)
20:18:27 <danharaj> (and dinatural transformations)
20:18:34 <eyebloom> Where do you learn these things?
20:18:37 <edwardk> and if its in both, the best you can do is hope that you have an isomorphism or want to work with dinatural transformations
20:18:39 <Cale> Another way to look at it is that with  f :: (a -> b) -> c  the things of type 'a' and 'c' are things which the function f is going to provide, and the thing of type 'b' is something provided (in a sense) by the user of f
20:18:41 <edwardk> ;)
20:19:06 <tgeeky> eyebloom: http://en.wikipedia.org/wiki/School_of_Hard_Knocks
20:19:33 <edwardk> positive/negative position comes up in type theory and in logic
20:19:55 <eyebloom> tgeeky: that's probably exactly wrong.
20:20:25 <danharaj> there's no place where all this lore is collected in one place.
20:20:33 <edwardk> there are further refinements, since there is a distinction between strictly positive and positive, e.g. the final result, which is on the left of 0 ->'s is 'strictly positive', while the thing that is doubly negated is merely 'positive'
20:21:53 <tgeeky> eyebloom: I mean that self-motivated study is probably the likely way to learn this. I don't think there are great, Haskell-specific webpages about that idea
20:22:23 <tgeeky> I don't like that definition of the idiom "school of hard knocks"
20:22:28 <danharaj> a real programmer reads edwardk's category libraries until they make sense
20:23:00 <edwardk> that approach works too
20:24:15 <eyebloom> tgeeky: Ah, it's seems like most programmers who stick to the "school of hard knocks" never study logic or switch to Haskell, they stick with C++ and Javascript ;) in any case I see your point.
20:24:29 <danharaj> better than the school of bad blogs.
20:25:20 <eyebloom> There must be some good source's though. In category theory for example.
20:25:50 <NihilistDandy> eyebloom: Categories for the Working Mathematician?
20:25:56 <tgeeky> eyebloom: it also happens to be edwardk's approach (as far as I understand).
20:26:19 <tgeeky> eyebloom: but yeah. With some things in Haskell, there's no better authority than yourself after diving in.
20:26:25 <edwardk> i really like CftWM. other people recommend Awodey
20:26:34 <NihilistDandy> Awodey's not bad, either
20:26:37 <danharaj> Awodey is kinda ehh.
20:26:48 <edwardk> your mileage may vary. in particular the difference seems to be how much you like pounding your face into a wall until you get it ;)
20:26:54 <NihilistDandy> lol
20:27:05 <danharaj> Cats4Mats doesn't cover all the latest cool gadgets though.
20:27:33 <tgeeky> take his statement with a grain of salt. He's just speaking in the category of schoolyard games, and he was bullied when he was a kid.
20:27:43 <edwardk> danharaj: thats ok. i'm not sure i really buy the relative benefit of all those newfangled toys. but then again, perhaps this is just my manifestation of a categorical version of the Blub paradox.
20:28:09 <danharaj> edwardk: Well category theory always seems completely worthless until you find a way to make it useful.
20:28:18 <danharaj> It's a very need-to-know based thing.
20:28:27 <NihilistDandy> Cats4Mats is the best way to refer to that book
20:28:36 <tgeeky> danharaj: I think that's almost the point of category theory.
20:28:42 <danharaj> tgeeky: pretty much.
20:28:57 <rasfar> I studied using Barr & Wells also a good resource
20:29:03 <NihilistDandy> I'm sure Blub is a category
20:29:19 <edwardk> barr and wells's tutorial is pretty nice
20:29:29 <tgeeky> danharaj: if you only need to know how one "mathematical object" works, studying category theory won't be of much help.
20:29:47 <rasfar> they have a rather large textbook too; i haven't actually seen the tutorial, may be since my course?
20:29:55 <tgeeky> danharaj: if you need to know how two or more such objects works, then category theory can be useful.
20:30:26 <danharaj> in the future n-cat programmers will replace n-star programmers
20:30:34 <edwardk> i find category theory to be very useful _after_ gaining intuition for a domain as a way of summing that domain up post hoc
20:30:38 <tgeeky> I'm a Rock-cat programmer!
20:30:42 <tgeeky> lol!
20:31:17 <edwardk> i'm not very good at using it in advance as a tool to reason about the domain, until i've worked with it a lot, and then i can start to spot categorical connections that might let me wedge it open and explore it further
20:31:20 <tgeeky> edwardk: which is where category theory has really been used by fiat -- mathematics communication and brain dumps
20:31:33 <NihilistDandy> Also
20:31:34 <NihilistDandy> http://math.stackexchange.com/questions/370/good-book-lecture-notes-about-category-theory
20:32:04 <NihilistDandy> Serge Lang wins again
20:32:12 <edwardk> for instance i still like the fact that every monad transformer gives rise to a right kan extension transformer. i find this idea fascinating
20:32:20 <tgeeky> edwardk: after all, the canonical text was called ______ for the Working mathemitician
20:32:30 <tgeeky> edwardk: you would!
20:32:33 <tgeeky> ;)
20:32:40 <edwardk> I love Lang's Algebra.
20:32:55 <edwardk> its about half as dense as CftWM, but its way way bigger
20:33:03 <rasfar> I quite enjoyed his General Topology too
20:33:31 <NihilistDandy> When you write as many books as Serge Lang, you will undoubtedly end up at the top of many lists
20:33:58 <NihilistDandy> Whoa, and video lectures
20:34:42 <danharaj> The only book I've read more dense than Cats4Mats is Serre's Course on Arithmetic
20:34:46 <edwardk> If anybody picks up Serge Lang's Algebra, I _heartily_ recommend grabbing the list of errata. I've marked up my copy beyond recognition. ;)
20:34:58 <danharaj> amusing anecdote: my friend once found it wedged between children's books at a public library.
20:35:16 <edwardk> http://math.berkeley.edu/~gbergman/.C.to.L/55.errata.ps
20:35:19 * rasfar wierd, i don't see a Topology title on his wikipedia page, maybe it was real analysis...
20:35:24 <BMeph> What would be good to study to "grok" session types? Besides Honda's paper, anyway....
20:36:12 <edwardk> funny thing was for me the first time i understood session types was after looking at Microsoft's singularity
20:36:31 <edwardk> that state machine model clicked for me for some reason
20:36:57 <dolio> Oh, that reminds me....
20:37:09 <dolio> Wadler posted that thing about linear logic and deadlock free session types.
20:37:42 * BMeph has noticed looking into a lot of topics from Wadler's blog postings...
20:37:43 <dolio> But, wasn't it already well known that linear logic is usable for deadlock free concurrent programs?
20:38:09 <edwardk> probably. milner did something big with session types before he passed away. i didn't see the wadler post. was it that?
20:38:23 <dolio> It was something along those lines.
20:38:38 <azaq23> edwardk: this is not the same book as Lang's "Undergraduate algebra", is it?
20:38:39 <dolio> I think Proofs and Types has an appendix about using linear logic that way.
20:38:59 <dolio> Maybe not with session types specifically, but as a concurrent programming language that has no deadlocks.
20:39:32 <dolio> Maybe it's the session types that are new.
20:39:34 <edwardk> azaq23: pretty sure its not. its the Springer Graduate Texts in Mathematics: Algebra. 3rd edition or so
20:40:14 <cmccann> dolio, I seem to recall reading something to the effect that linear logic only describes "unnecessary" parallelism, i.e. if you untangle the dependencies there won't be any loops or other weird stuff
20:40:36 <BMeph> I thought the Milner angle was in connecting session types to pi calc.
20:41:20 <edwardk> BMeph: that sounds right. he proved something about the kind of channels used in singularity that if they each made progress the system as a whole was deadlock free or some such
20:41:43 * BMeph nods; that sounds Milner-esque... :)
20:42:50 <azaq23> edwardk: ah it's different, ok, I asked since I'm reading Undergraduate algebra currently
20:43:06 <edwardk> ah. i had a copy of that, but i think i lent it out.
20:43:20 <NihilistDandy> I would just like to plug Dummit and Foote because they teach at my university
20:43:32 <NihilistDandy> And Abstract Algebra's a pretty fine book
20:43:59 <hpaste> eyebloom pasted “type includes typeclass constraint.” at http://hpaste.org/65322
20:44:34 <eyebloom> Here's a toy example of what I was trying to explain.
20:44:45 <edwardk> well, if the goal is to learn algebra per se, there is always mac lane and birkhoff
20:44:47 <eyebloom> It doesn't compile.
20:44:59 <edwardk> it only mentions categories a little at the end
20:45:08 <edwardk> which was how i really first encountered them
20:45:32 <copumpkin> aww, baby edwardk learning about categories
20:46:06 <edwardk> hey just remember. category-extras predates me. ;)
20:46:34 <edwardk> it has now had 4 maintainers. zednenem, dolio, me, and now dmwit. though poor dmwit is reduced to maintaining an index. ;)
20:46:56 <dolio> Oh, that reminds me again...
20:47:10 <dolio> Where the heck did Control.Functor.Strong go?
20:47:12 <dolio> Or whatever it was.
20:47:15 <edwardk> good question
20:47:26 <edwardk> where strength and costrength lived?
20:47:33 <dolio> Right.
20:47:40 <edwardk> don't think i gave them new homes
20:47:41 <dolio> I looked in all the deps of category extras and couldn't find it.
20:47:47 <dolio> Oh, that'd explain it.
20:47:59 <edwardk> strength is obvious and has two annoyingly equivalent definitions
20:48:01 <copumpkin> quick, we need a package called "strong"
20:48:12 <edwardk> costrength is the interesting case
20:48:15 * cmccann found at least one or two things that were in category-extras but not any of the other packages
20:48:40 <edwardk> cmccann: i didn't move everything. i tried to use the breakup as a chance to clean up my worst messes. ;)
20:48:51 <edwardk> i still mean to bring over indexed monads/comonads
20:49:21 <cmccann> can't complain too much since the stuff I was looking for wouldn't have actually helped directly anyway
20:49:50 <dolio> Is every costrong functor traversable?
20:50:05 <dolio> Because it was a bit odd to me that you went with that.
20:50:07 <edwardk> but there is a problem with them that zzo38 also noted, which is that an indexed monad seems to never be able to be compatible with an _indexed_ comonad, which infects my ability to make Apply work in lieu of a separate 'ComonadApply' or ComonadZip as Uustalu and Vene called it
20:50:19 <edwardk> i only established it as a sufficient condition, not a necessary one
20:50:41 <edwardk> hopefully i didn't lead anyone on in that regard in the post
20:51:08 <edwardk> on the other hand, i never proved it wasn't necessary. i'd love an answer to that question.
20:51:11 <dolio> Of course, I'm not sure if "(co)strong functor" is even something people talk about in category theory.
20:51:24 <dolio> And that traversable definition is going to be wrong for costrong comonads.
20:51:29 <edwardk> i _think_ it does have to be traversable in Haskell though
20:52:00 <edwardk> in that traversable gives you a mechanism to visit every 'a' inside of the 'f a'
20:52:08 <edwardk> not in the particulars of its implementation
20:54:24 <edwardk> i need to go back and find the stuff you and roconnor were talking about when the costrong comonad stuff came up
20:54:32 <edwardk> since i never did get an intuition for the issue
20:55:05 <rasfar> (time to go to no-internet-land, ciao)
20:55:28 <dolio> I'm also not sure there's any reason for costrong comonad to be 'w (Either a b) -> Either a (w b)'.
20:55:40 <dolio> Instead of w (a, b) -> (a, w b)
20:55:43 <dolio> Which is easy.
20:56:17 <rwbarton> particularly as Either a doesn't have an "extra" left adjoint
20:57:49 <edwardk> well, w (a, b) -> (a, w b) is easy, but its not the most satisfying extraction. the 'Either' version is providing a real service. not sure about the theoretical bona fides on either side at this point. its been a long time
20:58:22 <dolio> It's both easy, and costrong comonads actually exist in Haskell.
20:58:25 <dolio> Instead of not existing.
20:58:31 <dolio> Except for... Id.
20:59:47 <rwbarton> "strong" is usually in relation to a closed monoidal category I think
20:59:50 <dolio> Basically, both (*,1) and (+,0) are monoidal structures on Hask _and_ Hask^op, so by choosing costrength to work with either, you've decided to dualize the monoidal structure as well.
20:59:52 <edwardk> i think i took the costrong comonad definition from Pardo.
21:00:47 <edwardk> http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=4&cts=1331784018429&ved=0CDoQFjAD&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.35.1593%26rep%3Drep1%26type%3Dpdf&ei=6mhhT4mGH6Pi0QGL7PSqBw&usg=AFQjCNHNJFa7YnpW8qgktGgGRNWe2YLn_w&sig2=_MC5p5no8y0HUTvDIaLqyA
21:01:04 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.1593
21:01:16 <dolio> But, there's no reason to do that if you're just dualizing the strong monad definition.
21:02:40 <edwardk> not disagreeing, its just that that costrength is boring ;)
21:02:50 <dolio> So is strength. :)
21:02:56 <edwardk> hah
21:03:08 <dolio> costrength is still less boring.
21:03:14 <dolio> Because you can't get an a out of everything.
21:04:22 <stj> I have ByteString chunks of form (Chunk "I -1" Empty) ... how can extract the first letter (Char) and the number (Int) ?
21:04:42 <dolio> Oh, reader comonads were the other costrong comonads.
21:04:51 <edwardk> yeah
21:05:03 <dolio> T * (A + B) -> A + T*B is possible.
21:05:20 <dolio> And it will agree with the laws.
21:06:07 <dolio> rwbarton: Wikipedia's strong monad definition doesn't seem to care about closed monoidal.
21:06:15 <dolio> And nlab's definition is too opaque for me to read.
21:09:03 <rwbarton> you can indeed give a definition which doesn't care about the closed structure, but I think the main motivating example is when the category is closed monoidal
21:09:15 <dolio> Ah.
21:09:48 <rwbarton> if you have a functor F : C -> D you can think of its actions on maps as defining maps of sets Hom_C(X, Y) -> Hom_D(FX, FY) for every X, Y in C
21:10:17 <rwbarton> but if C and D are enriched in some other category beyond Set you might want a map of objects of that category
21:11:38 <rwbarton> now if C is closed monoidal and F : C -> C then taking Hom_C(X, Y) -> Hom_C(FX, FY) and extending it to C(X, Y) -> C(FX, FY) is basically making F a strong functor, I think (C(X, Y) = Y^X)
21:11:56 <rwbarton> that's the context in which I know strong functors in category theory
21:12:34 <rwbarton> for example if C = Top, I might like my functors to act continuously on spaces of maps
21:13:31 <rwbarton> Or indeed if C = Hask :)
21:13:43 <dolio> Ah, yes, that makes some sense.
21:13:56 <rwbarton> the whole X (x) FY -> F(X (x) Y) is way more opaque to me
21:14:38 <dolio> That also explains why Haskell functors are strong functors.
21:17:28 <dolio> Because we define them as having a map that is expressible as a natural transformation -^= -> F-^F=
21:21:55 <augur> can programming paradigms be detected by analyzing machine behavior?
21:23:47 <adu> augur: have you seen the latest LtU?
21:24:26 <augur> no i havent!
21:24:28 <adu> http://lambda-the-ultimate.org/node/4476
21:24:48 <augur> oh, the one about the worm
21:25:05 <adu> so what do you mean by "analyzing machine behavior"?
21:26:00 <augur> well, i mean
21:26:16 <augur> given full traces of memory/registers
21:26:31 <augur> can you tell by the memory access, etc. what kind of paradigm is being used
21:29:20 <adu> augur: I think that's debatable
21:29:35 <augur> adu: whether its possible or not, you mean?
21:30:13 <adu> you could argue that compilers are smart, and e.g. Haskell can merge operations like concatMap and stuff behind your back to make it hard to realise that a map is going on
21:30:45 <augur> sure, but one might expect that a functional paradigm, regardless of its optimization, will leave certain structural fingerprints on the machine code
21:31:08 <dncr> how do i go from Jan 23 07:39 UTC to a System.Time for it
21:31:13 <adu> you could also argue that you could fingerprint frequency of those things, and say that procedural language have less than 10% map usage, and anything more than 60% map usage must be functional
21:31:31 <augur> brb
21:32:02 <adu> dncr: date parsing?
21:32:18 <adu> I've never done that in Haskell
21:32:46 <dncr> i just feel like there must be a function that takes a bunch of Ints for month, day, hour, etc
21:33:15 <dncr> i guess the day and time are separated..
21:34:09 <adu> http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/Data-Time-Format.html
21:34:12 <dncr> i'm referring to the time package, i guess it's Data.Time not System.Time
21:35:04 <dncr> i guess they have the string parsing and no Int-taking functions..
21:35:16 * dncr will try that
21:35:18 <adu> int taking?
21:35:23 <dncr> f :: Int ->
21:35:33 <adu> I thought you needed -> Int
21:35:39 <dncr> ha well
21:35:57 <dncr> if you want a unixtime out of it
21:39:15 <dncr> > UTCTime (fromGregorian 2012 1 23) (secondsToDiffTime $ (7 * 60 + 39) * 60)
21:39:16 <lambdabot>   Not in scope: data constructor `UTCTime'Not in scope: `fromGregorian'Not in...
21:40:19 <dncr> i guess it's that or something like it
21:42:30 <Enigmagic> dncr: what, that doesn't seem obvious? ;)
21:42:37 <dncr> heh
21:43:20 <dncr> to each library its own
21:43:42 <Enigmagic> we use our own time library that will be open sourced at some point this year
21:46:00 <dncr> Enigmagic: who is we
21:46:23 <Enigmagic> dncr: https://github.com/alphaHeavy
21:47:05 <dncr> cool
21:47:41 <Enigmagic> dncr: it's not quite a port of joda-time to haskell but it's at least easy to use
21:48:21 <Enigmagic> compared to the time package at least
21:56:52 <JoeyA> What's a concise way to say @max 64@ in English?
21:57:05 <JoeyA> As in, if the buffer size is less than 64, it will be set to 64.
21:58:17 <JoeyA> The opposite of the word I'm looking for would be "cap" or "truncate".
22:07:16 <danharaj> So I'm trying to define a monoid instance for ST actions that modify a mutable array, with the monoid action being >=>. I'm not sure what the type I should newtype wrap is though. It should look like `newtype Foo i e = Foo  { unFoo :: forall s. STArray s i e -> ST s (STArray s i e) }, but I don't think that works because I can't apply runSTArray to such a thing.
22:08:38 <danharaj> er, when I do something like \x -> runSTArray $  (newArray ...) >>= unFoo x
22:08:53 <Jafet> You can't runSTArray an ST action that changes an array to another array, yes
22:09:00 <Jafet> I don't see why you should
22:09:32 <danharaj> Well I'm trying to define a writer monad that builds an action that modifies an array, then I want to apply that action to an array and then get a pure result.
22:09:35 <Jafet> runSTArray uses an ST action that creates an array, which isn't part of your monoid
22:11:58 <danharaj> so what can I do to realize my intent?
22:13:25 <Jafet> You need to create an array, some way or other
22:13:55 * hackagebot xsha1 0.0.0 - cryptanalysis of Blizzard's broken SHA-1 implementation.  http://hackage.haskell.org/package/xsha1-0.0.0 (AlexKropivny)
22:14:00 <Jafet> None of the actions above do that
22:14:15 <Jafet> How do you break a SHA-1 implementation
22:15:25 <JoeyA> I have a feeling Haskell will get slashdotted pretty soon
22:15:41 <danharaj> Jafet: yeah, I know. But I can't escape ST when I compose the action I'm wrapping with something like (newArray ...)
22:15:44 <zeiris> Jafet: when extending a 16-DWORD block to 80 DWORDs, you do 1<<N instead of N<<1.
22:15:53 <JoeyA> err, nevermind: The fact that it's cryptographically weak has been known for years
22:15:58 <JoeyA> "
22:15:58 <miller> I have a list of monadic actions [IO ()] that I'm attempting to run via forkIO. If I do `map forkIO actions`, nothing happens, since I'm guessing the forkIO is never forced. If I manually force it by doing `foldl seq (return ()) $ map (void . forkIO) actions`, then only one thread is ever run. How can I forkIO a list of things? :S
22:16:15 <JoeyA> miller: when main quits, the program quits.
22:16:20 <shachaf> miller: Executing actions is not the same as evaluating them.
22:16:23 <JoeyA> Even if other threads are doing stuff.
22:16:37 <shachaf> miller: You want something like mapM_ or sequence_.
22:16:38 <miller> JoeyA: I found that, and stuck a `forever $ yeild` right beneath it.
22:17:04 <shachaf> forever yield is a horrible way of doing it. :-( At least do forever (threadDelay maxBound) or something.
22:17:11 <Jafet> danharaj: runSTMonoid :: forall s. STArray s i e -> Foo -> Array i e
22:17:14 <miller> shachaf: so s/seq/sequence_/ ?
22:17:19 <shachaf> miller: No.
22:17:28 <shachaf> miller: They're completely different functions.
22:17:34 <JoeyA> I'd be afraid of threadDelay maxBound.  There's a chance some OS might truncate that.
22:17:45 * miller hoogles
22:18:01 <shachaf> JoeyA: Still better than forever yield, I think. :-)
22:18:06 <JoeyA> true
22:18:21 <Jafet> young = threadDelay maxBound
22:18:23 <shachaf> miller: I think that you should read some more about how IO works in Haskell.
22:18:44 <shachaf> The distinction between evaluation and execution is an important one.
22:19:12 <miller> shachaf: I wholeheartedly agree. Any suggestions on where to read?
22:19:34 <shachaf> So rather than doing the minimum work necessary to get your program running correctly, you should spend a bit of time understanding exactly why. :-)
22:19:40 <shachaf> miller: I think the FAQ might have some links.
22:19:42 <shachaf> @where faq
22:19:42 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:20:41 <shachaf> miller: The important concept is that an IO action is a completely static thing -- evaluating it is like reading a program's source code: It won't cause anything to execute, on its own.
22:20:45 <shachaf> @quote /bin/ls
22:20:45 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
22:21:09 <shachaf> I guess this isn't a "contains" issue, but it's related. :-)
22:21:57 <miller> oh, okay.
22:22:00 <Jafet> /bin/cat /bin/cat
22:22:27 <shachaf> #!/bin/cat is a great programming language for writing quines in.
22:22:32 <danharaj> jafet: So I had to put a type annotation to that effect somewhere. I'm not sure I have the intuition for where to put rank-2 types for GHC.
22:25:44 <Jafet> runSTMonoid isn't rank-2
22:26:21 <danharaj> no, but all the ST business is rank 2
22:27:03 <danharaj> wait. I removed the type annotation and it worked.
22:27:05 <Jafet> runSTMonoid a Foo{unFoo=f} = runSTArray $ return a >>= f
22:27:09 <danharaj> But I swear I wrote this already.
22:27:11 <danharaj> And it didn't work.
22:27:16 <danharaj> HOW LATE IS IT.
22:27:30 <Jafet> Coffee, the best airliner
22:29:47 <danharaj> oh. what I did before was runSTMonoid a = runSTArray . (return a >>=) . unFoo
22:29:50 <danharaj> That doesn't work.
22:29:56 <danharaj> I guess they don't mean the same thing.
22:30:35 <Jafet> @pl \f -> runSTArray $ return a >>= unFoo f
22:30:36 <lambdabot> runSTArray . flip unFoo a
22:31:38 <danharaj> :t \x y -> runSTArray . (return x >>=) . unFoo y
22:31:39 <lambdabot> Not in scope: `runSTArray'
22:31:39 <lambdabot> Not in scope: `unFoo'
22:31:59 <danharaj> lambdabot why can't you just pretend like you know what unFoo means.
22:32:46 <Enigmagic> what's the type of Foo/unFoo?
22:33:32 <danharaj> data Foo i e = Foo { unFoo :: forall s. STArray s i e -> ST s (STArray s i e) }
22:33:38 <danharaj> er, newtype Foo*
22:34:45 <Enigmagic> unFoo doesn't bring the s into scope but Foo{unFoo = f} does
22:34:53 <Enigmagic> (i don't know the details otherwise)
22:36:21 <Jafet> Yes, you need to be a strong typist
22:37:21 <eyu100> strong typist = good at typing on a keyboard, or strong typist = knows a lot about strong typing?
22:37:41 <Jafet> eyu100: yes.
22:37:53 <eyu100> Jafet: :(
22:38:06 <danharaj> So why exactly is the section'd version untypeable?
22:39:08 <dibblego> is it possible to find all hackage packages that depend on HTF?
22:39:33 <Jafet> I don't know
22:39:51 <Jafet> I'm guessing DMR
22:40:11 <Jafet> (It probably isn't, but it's an excuse to hate on the DMR.)
22:40:24 <dibblego> DMR?
22:40:34 <Jafet> @quote dreaded
22:40:34 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
22:40:59 <shachaf> @wham dmr
22:40:59 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
22:41:06 <Enigmagic> dibblego: http://packdeps.haskellers.com/reverse/HTF
22:41:09 <danharaj> GHC is usually good at warning you about the DRM
22:41:13 <dibblego> Enigmagic: ta
22:41:35 <Enigmagic> np
22:41:50 <danharaj> (Also just tried it with NMR and it still didn't work, so this time it ain't the MR's fault)
22:42:44 <Enigmagic> danharaj: it has something to do with only let and case statements bringing type variables into scope
22:43:11 <danharaj> Enigmagic: it seems to be a bit of a defect.
22:43:25 <Jafet> It should work to use type annotations with a scoped type variable
22:46:51 <Enigmagic> Jafet: i don't think it does
22:47:07 <Enigmagic> here's the compile error on 7.4.1:
22:47:13 <Enigmagic>     Cannot use record selector `unFoo' as a function due to escaped type variables
22:47:13 <Enigmagic>     Probable fix: use pattern-matching syntax instead
22:47:25 <danharaj> ah, I don't get such an error
22:47:34 <danharaj> I get no error if I omit the runSTArray
22:47:45 <danharaj> and then an error where the s isn't properly quantified.
22:47:50 <danharaj> when I do add it in.
22:50:51 <danharaj> (I'm on an old version of ghc)
22:53:40 <Enigmagic> newer ghc builds definitely provide better error messages
22:54:14 <Enigmagic> not always great but i saw a big improvement between 6.12 and 7.0, and another step up with 7.4
23:00:11 <kaitocracy> if I want to do a 'rm -rf' in haskell what's my best bet?
23:02:02 <Enigmagic> kaitocracy: start with "rm -rf /"
23:02:13 <Enigmagic> that will fix more cabal related build errors
23:02:40 <elemir> mkfs.ext4 /dev/sd*!
23:02:51 <kaitocracy> Enigmagic: I mean in haskell code, I see a library function System.Directory (removeDirectoryRecursive) but that follows symlinks
23:04:38 <Enigmagic> http://hackage.haskell.org/packages/archive/system-fileio/0.3.7/doc/html/Filesystem.html#v:removeTree
23:05:17 <kaitocracy> Enigmagic: ahh thanks
23:08:29 <kaitocracy> also can someone explain to me what string implementation I should be using? ByteString, String, Text?
23:11:41 <rasfar> too late now, but returned to say, i stupidly set the wrong permissions on http://www.fremissant.net/freesect earlier when we were discussing it.  the pages are restored (and improved), and v0.7 of the code is linked there also.
23:12:14 <Enigmagic> kaitocracy: for dealing with text use Text or String, in order of preference
23:15:40 <shachaf> kaitocracy: Contrary to its name, ByteString isn't a string implementation.
23:15:48 <shachaf> Well, not strings of characters, anyway.
23:15:58 <dolio> It's a string of bytes.
23:16:03 <dolio> Like its name says.
23:16:26 <kaitocracy> so for just real general purpose strings what should I be using?
23:16:28 <kaitocracy> Text?
23:17:06 <rasfar> (and shachaf, excuse me i misspelled your name earlier in a passing reference) ... okay bye
23:17:45 <shachaf> kaitocracy: It depends on how you're using the strings.
23:17:58 <shachaf> The standard library operates in terms of String, which is just [Char].
23:18:41 <kaitocracy> isn't there something with overloaded strings where I can make the default string whatever?
23:22:22 <Enigmagic> kaitocracy: you can make string literals into Text or String, yeah
23:22:36 <Enigmagic> but String itself doesn't change, so functions that expect String will still need a String (not a Text)
23:22:45 <kaitocracy> I see
23:44:30 <hpaste> huangjs pasted “why can't the code get type checked?” at http://hpaste.org/65326
23:45:04 <huangjs> the code is meaningless, just an example that i got confused. :)
23:46:35 <kaitocracy> is there a good rule of thumb of when to use type aliases?
23:46:42 <kaitocracy> I'm a total noob and I find myself doing this all the time:
23:46:52 <kaitocracy> type firstName = String; type lastName = String, etc.
23:46:57 <kaitocracy> basically type aliasing everything
23:47:31 <shachaf> kaitocracy: The unfortunate thing about that is that you don't actually get any type safety.
23:47:55 <kaitocracy> shachaf: yeah I know it's just syntatic sugar, so should I stop doing it?
23:48:01 <huangjs> need help. http://hpaste.org/65326
23:49:14 <shachaf> kaitocracy: Not necessarily -- it depends on the context, I guess.
23:49:39 <shachaf> If it makes the code more readable then it's probably good, unless it makes it too easy to make mistakes or something.
23:50:56 <kaitocracy> so for example I've got two function that take a shell command and an environment and return a string as output, and I have this http://pastie.org/3598996
23:51:00 <kaitocracy> is that unnecessary?
23:51:29 <shachaf> kaitocracy: If you used a newtype you would get actual type safety. :-)
23:51:51 <shachaf> This is a style question; different people do different things.
23:52:28 <kaitocracy> okay
23:53:13 <shachaf> kaitocracy: Data.Map.Map String String would be a type that communicates the intent of Environment more directly.
23:53:32 <shachaf> (And it would probably also be more efficient.)
23:53:44 <kaitocracy> shachaf: well I pass it off to createProcess which expects a [(String, String)]
23:54:18 <Enigmagic> huangjs: what is the Monad constraint for?
23:54:31 <bartek> Hi there. Kind of silly but the first question on http://www.haskell.org/haskellwiki/99_questions/1_to_10 asks to find the last element of the list, which seems obvious to me (myLast l = last l) .. However, all the solutions differ from this. Is it because these are using optimal ways?
23:54:55 <shachaf> kaitocracy: If you're only using a type once, and that one use is passing it to a function which expects an unsynonmized version, I don't know that a type synonym is really worth it.
23:55:02 <hpaste> Enigmagic annotated “why can't the code get type checked?” with “why can't the code get type checked? (annotation)” at http://hpaste.org/65326#a65327
23:55:06 <huangjs> Enigmagic: it's just a pedagogical example
23:55:13 <dibblego> bartek: mostly that using last is cheating -- the problem assumes last does not exist and so you now have to write it
23:55:19 <kaitocracy> shachaf: got it yeah that's basically what I'm doing I'll stop it now
23:55:32 <bartek> dibblego: Ah, that makes more sense. Got it, thanks :-)
23:56:47 <Enigmagic> huangjs: okay, well i'm not sure either so i removed it.
23:57:02 <huangjs> Enigmagic: ah, please don't remove the Monad constraint :)
23:57:50 <geekosaur> ...
23:57:52 <hpaste> Enigmagic annotated “why can't the code get type checked?” with “why can't the code get type checked? (annotation) (annotation)” at http://hpaste.org/65326#a65328
23:58:02 <geekosaur> if you don't know what you are doing, how is anyone else to know?
23:58:02 <Enigmagic> huangjs: okay, i put it back in but it's not going to be very useful
