00:01:00 <kallisti> dude a Haskell support group for paraphilias!? yessss.
00:06:41 <kallisti> hmm apparently hpaste isn't working.
00:08:35 <kallisti> well since hpaste is down:
00:08:37 <kallisti> http://pastebin.com/Vy5ed7TZ
00:08:42 <kallisti> I'm having issues with layout here...
00:08:45 <kallisti> but I can't figure out what it is.
00:10:13 <dmwit> hpaste is up, but it's giving weird error messages and not making IRC messages
00:10:22 <dmwit> http://hpaste.org/65868
00:10:33 <dmwit> Plus the five pastes before it. ;-)
00:10:52 <kallisti> oh, indeed :P
00:11:46 <kallisti> dmwit: for some reason it's not recognizing the implicit semicolon after the run call, I think?
00:11:57 <kallisti> er wait
00:11:58 <kallisti> where is do
00:11:59 <kallisti> I had a do.
00:12:00 <kallisti> what
00:12:06 <kallisti> oh there it is.
00:12:08 <kallisti> nevermind.
00:12:45 <kallisti> I should probably just break this down into parts anyway
00:12:49 <kallisti> that will probably fix it.
00:12:59 <dmwit> kallisti: That wouldn't result in seven arguments anyway.
00:13:08 <dmwit> five at best
00:13:44 <dmwit> ah
00:13:50 <dmwit> \ breaks the layout, I bet. =)
00:14:11 * dmwit tests
00:14:24 <kallisti> I have similar code where it doesn't...
00:14:58 <dmwit> kallisti: There's no literal tabs in your source file, right?
00:15:09 <kallisti> as far as I'm aware I have emacs set to use all spaces.
00:15:13 <dmwit> Possibly above or below this, and possibly being converted away by your editor's copy command?
00:15:28 <kallisti> let me check.
00:15:42 <kallisti> no tabs
00:16:54 <kallisti> hm it may be something else though
00:17:00 <kallisti> emacs is seriously confused about indentation after that do
00:17:28 <kallisti> oh I may have found it
00:17:35 <dmwit> Can't say I blame it.
00:17:35 <kallisti> a line in a do block one function above was indented 2 spaces too far.
00:18:04 <kallisti> dmwit: psh, I can't possibly see what the problem is.
00:18:17 <kallisti> it's only deeped nested infix operators, lambdas, do blocks, and let expressions
00:18:20 <kallisti> *deeply
00:20:36 <kallisti> hopefully the second rewrite of this code will be cleaner.
00:22:39 <kallisti> a different database library would help..
00:25:10 * hackagebot LambdaHack 0.2.1 - A roguelike game engine in early and very active development  http://hackage.haskell.org/package/LambdaHack-0.2.1 (MikolajKonarski)
00:29:43 <kallisti> I may be addicted to the state monad.
00:29:54 <kallisti> is there intervention for that?
00:39:03 <plat0> Is there somewhere I can get a list of the most commonly used monads?  I'm thinking Maybe, Either, List, IO, ST, State.  What others occur with high-frequency in Haskell code?
00:39:35 <dmwit> ?instances Monad
00:39:35 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
00:40:10 <plat0> Thanks dmwit.  Is this everything in Prelude?
00:40:21 <dmwit> See also http://hackage.haskell.org/package/transformers perhaps.
00:40:30 <dmwit> plat0: Oh, no, most of those are not in the Prelude.
00:40:43 <dmwit> The Prelude is really quite small.
00:40:48 <plat0> What is ?instances searching?
00:41:01 <dmwit> Good question.
00:41:04 <dmwit> ?help instances
00:41:05 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
00:41:16 <dmwit> Anyway, it's a fairly largish collection of modules that it's searching.
00:41:33 <plat0> OK
00:41:45 <plat0> That's great, thanks.
00:42:03 <dmwit> You can ask it to search more modules (but not less, I think) with ?instances-importing.
00:42:09 <dmwit> ?list
00:42:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:43:18 <dmwit> The Prelude only has Monad instances for Maybe, [], and IO, if you were still wondering that.
00:43:44 <mekeor> dmwit: and for `P'. but what's that?
00:44:00 <ClaudiusMaximus> i guess Identity probably occurs fairly often, in conjunction with monad transformer libraries
00:44:03 <dmwit> mekeor: Probably the parsing thing. Where do you see that?
00:44:15 <mekeor> http://hackage.haskell.org/packages/archive/haskell98/latest/doc/html/Prelude.html#t:Monad
00:45:32 <dmwit> That's ReadP, which is the parsing thing, yes.
00:45:40 <mekeor> ah
00:45:47 <dmwit> ReadP is not in the Prelude, though.
00:46:06 <dmwit> That documentation isn't telling you where the instances are written, only that it happened to find those instances when generating the documentation.
00:46:25 <dmwit> Oh, huh, there *is* an instance for a plain old 'P'. Weird.
00:47:15 <mekeor> where?
00:47:19 * mekeor looks around
00:48:53 <ClaudiusMaximus> is it just me or is hayoo broken?  (searches work, but links just go nowhere useful back to its home page)
00:49:01 <dmwit> I suspect it's some GHC internal thing.
00:49:07 <dmwit> Though I couldn't say for sure.
00:49:51 <ClaudiusMaximus> oh, it must be searching for "P" with quotes that breaks it...
00:50:20 <hiptobecubic> does compilation via C still work? It never seems to for me
00:51:14 <dmwit> hiptobecubic: "ghc: unrecognised flags: --via-c"
00:51:20 <dmwit> so, it seems the answer is "nope"
00:51:26 <ClaudiusMaximus> in ghc-7.4.1 i get Warning: The -fvia-c flag does nothing; it will be removed in a future GHC release
00:51:31 <hiptobecubic> yeah
00:51:42 <hiptobecubic> ClaudiusMaximus, right, but i think this also happens in 7.2
00:51:56 <dmwit> Why the "but"?
00:51:58 <hiptobecubic> so i guess it's just deprecated
00:52:10 <hiptobecubic> well, broken, actually :)  since it already does nothing
00:53:14 <ClaudiusMaximus> is there a way to configure cabal-install so that i don't have to remember to add --enable-optimization=2  on every cabal install command?
00:55:32 <dmwit> ClaudiusMaximus: I think there's a feature request to make the "optimization: " field in the config file take something more exciting than a Bool.
00:57:12 <dmwit> um
00:57:21 <dmwit> Forget that, the bug is just to make it look at that field at all. =P
00:57:25 <dmwit> http://hackage.haskell.org/trac/hackage/ticket/368
01:03:19 <mekeor> which proposition is false? Would you use other expressions?   (1) Integer and Bool are type constructors. (2) Maybe, Either and Monad are type constructors, too, but complex ones. (3) 5, True and "foo" are value constructors. (4) Just, Left and Right are complex value constructors.
01:05:43 <dmwit> Monad is not a type constructor.
01:06:02 <dmwit> "foo" is not a value constructor, though (:) and [] are.
01:06:27 <dmwit> "complex" doesn't strike me as the right term.
01:06:40 <Lemmih> I'd say that Integer and Bool are types, not type constructors.
01:06:52 <kallisti> hm, so it's not possible to have two MonadState instances satisfied by a single monad?
01:07:16 <dmwit> Yeah, I'm not sure where I stand on the terminology for terms at the type level. I don't think the conventions are strong enough to rely on without spelling them out at the beginning of whatever text you're writing.
01:07:25 <dmwit> kallisti: correct
01:07:34 <kallisti> that could be problematic
01:07:41 <Lemmih> kallisti: Nope, the state type is uniquely determined by the monad.
01:07:52 <kallisti> as I want my Monad to be useable within a monad stack.
01:07:57 <kallisti> but my monad itself has a MonadState instance
01:08:05 <mekeor> dmwit: can you suggest better terms?
01:08:05 <kallisti> so perhaps I need to hide that within my implementation
01:08:09 <dmwit> kallisti: newtype it
01:08:24 <kallisti> dmwit: it is. I derive MonadState because it was convenient for my implementation
01:08:32 * dmwit nods sympathetically
01:08:33 <kallisti> so I just need to remove that and make a seperate get* function
01:09:00 <mekeor> Lemmih: so, you'd say 'value' instead of 'value constructor' and 'value constructor' instead of 'complex value constructor' and same with types, right?
01:09:27 <kallisti> ...my goal is to have every single library action lifted to a typeclass, so that arbitrary monad stacks can use all of the actions I define.
01:09:39 <kallisti> as long as my monad is at the bottom.
01:09:40 <dmwit> mekeor: Don't generalize that far. "constructor" doesn't have the same flavor at the type and term level.
01:09:40 <Lemmih> mekeor: Yep.
01:09:51 <shachaf> kallisti: That sounds like an evil goal.
01:09:54 <dmwit> mekeor: I would still call [] a value constructor, even though it doesn't take any arguments.
01:09:57 <kallisti> shachaf: why?
01:10:18 <shachaf> Too many type classes.
01:10:25 <mekeor> dmwit: hm… okay…
01:10:36 <kallisti> shachaf: you mean, one?
01:10:37 <shachaf> dmwit: You wouldn't call Int a "type constructor"?
01:10:38 <dmwit> mekeor: (Because the defining characteristic of "constructors" at the value level is that they can be used in patterns.)
01:10:49 <dmwit> shachaf: As I said above, I'm not sure where I stand on that.
01:11:08 <dmwit> shachaf: ...and I don't think the conventions are strong enough to be able to get away with saying that if you haven't said clearly what you mean by "constructor".
01:11:37 <kallisti> shachaf: https://github.com/kallisti-dev/hs-webdriver all of the functions in Test.WebDriver.Commands use the same functions in their implementation. so, all I have to do is make those typeclass methods.
01:12:28 <shachaf> dmwit: That's why "of kind *" and so on are much nicer. :-)
01:12:30 <dmwit> The top-level comment I'm making, I guess, is that no matter what terminology/convention you pick, you should have a few sentences explicitly stating that convention.
01:13:44 <dmwit> There's a fair number of papers that call things like "Either" and "Maybe" just plain old "type". They're perfectly readable papers -- but only because they say at the beginning what the *$#@ they mean by each word they use. =P
01:16:00 <Saizan> I try to stick to type for everything with a kind, type constructor for types introduced by data or newtype, concrete type for types with kind *
01:16:14 --- mode: Saizan set -o Saizan
01:17:16 <kallisti> I don't think I can sanely remove the MonadError instance however.
01:17:24 <dmwit> See, that one sentence would be enough to completely clarify the rest of an exposition. =D
01:17:35 <kallisti> but I think MonadState would be good.
01:17:43 <kallisti> to have available to monad stacks.
01:18:42 <kallisti> the only way I could sanely remove MonadError would be to move all of my exceptions to IO exceptions.
01:20:21 <kallisti> and since my monad is basically a "IO with some stuff" monad, it would make some amount of conceptual sense I suppose. I don't know.
01:23:13 <kallisti> advice, anyone? I'm kind of in new territory.
01:25:25 <mekeor> is this always true?:   <$> f = <*> (pure f)  -- where, of course, the Functor which `f' is in is an Applicative.
01:27:42 <dmwit> ?src (<$>)
01:27:42 <lambdabot> f <$> a = fmap f a
01:28:21 <mekeor> i actually meant: (<$>) f = (<*>) (pure f) -- sorry
01:29:09 <mekeor> > (+1) <$> [1..5]
01:29:10 <lambdabot>   [2,3,4,5,6]
01:29:18 <dmwit> Yes, it is a law of the class that fmap f x = pure f <*> x
01:29:44 <mekeor> > (\f -> (<*>) (pure f)) (+1) [1..5]
01:29:45 <lambdabot>   [2,3,4,5,6]
01:29:59 <dmwit> (as noted in the documentation for Applicative)
01:30:17 <mekeor> dmwit: ah, ok
01:31:41 <dmwit> This is actually mildly surprising to me, since the documentation claims that equation is a consequence of the actual laws; but none of the actual laws mention fmap at all.
01:34:37 <dmwit> (Indeed, none of the laws even say anything about "pure f <*> x" for arbitrary f, so far as I can tell. But perhaps that is just a function of the current time.)
01:34:43 <dmwit> ?localtime
01:34:47 <lambdabot> Local time for dmwit is Sat Mar 24 04:34:22 2012
01:35:15 <shachaf> dmwit: Did you know that if you moved to the west coast, you would gain three extra hours every day?
01:35:27 <dmwit> =)
01:36:16 <mekeor> dmwit: what the *$#@ ?!
01:36:33 <shachaf> dmwit: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html says "As a consequence of these laws, the Functor instance for f will satisfy fmap f x = pure f <*> x"
01:36:50 <dmwit> shachaf: Yes, that is a claim that I don't understand.
01:36:55 <mekeor> shachaf: nice
01:36:57 <kallisti> now I'm beginning to wonder if removing ErrorT and using IO exceptions is a good choice.
01:37:05 <dmwit> Can you exhibit the proof that this is, indeed, a consequence of those laws?
01:37:58 <dmwit> mekeor: I can't answer "what the *$#@ ?!" since I don't know what you're asking. =P Could you make it more specific?
01:38:04 <kallisti> alternatively, I could remove the MonadError instance and use custom error handling functions..
01:39:17 <shachaf> dmwit: Functor instances are unique, right?
01:39:39 <kallisti> basically the question is "what monad transformers do I want to make convenient when used above my WebDriver monad?"
01:39:52 <kallisti> I think StateT and RWS should be easy to use.
01:40:04 <kallisti> *RWST
01:40:58 <dmwit> shachaf: Something like that. I was afraid you were going to say that it depended on parametricity.
01:41:08 <mekeor> ah, cool:
01:41:09 <mekeor> > [(*3),(+2)] <*> [2,3]
01:41:09 <dmwit> The documentation sentence should say that, too, if it's required.
01:41:10 <lambdabot>   [6,9,4,5]
01:41:58 <shachaf> dmwit: You can't take that for granted anymore? :-(
01:42:02 <kallisti> or should I do that thing that parsec and gives you a free state monad. :P
01:42:13 <kallisti> *parsec does
01:42:39 * dmwit -> bed
01:42:41 <kallisti> no need to do that, I think.
01:42:48 <kallisti> so many choices. o_O
01:47:03 <kallisti> http://hackage.haskell.org/packages/archive/plumbers/0.0.2/doc/html/Control-Plumbers-Monad.html
01:47:06 <kallisti> what
01:48:45 <kallisti> I can only imagine the pointfree possibilities.
01:48:54 <kallisti> because there's no documentation of what these operators do.
01:53:00 <mekeor> so, the notation `foo <- Bar' (e.g. in list comprehensions and do-blocks) isn't only for monads but also for functors ?
01:53:42 <mekeor> no?
01:54:01 <kallisti> well, not really.
01:54:06 <kallisti> but all moands are functors
01:54:08 <kallisti> so, yes..
01:54:16 <kallisti> but it has nothing to do with fmap
01:54:25 <kallisti> not directly.
01:54:45 <mekeor> > [ f x | f <- pure (+1), x <- [1..5]]
01:54:46 <lambdabot>   [2,3,4,5,6]
01:55:01 <mekeor> so, in list comprehensions it works. but not in do-blocks…
01:55:05 <kallisti> list comprehensions are for lists, do notation is for monads. there isn't any sugar for functors.
01:55:20 <kallisti> mekeor: pure (+1) = [(+1)]
01:55:26 <mekeor> ah
01:55:33 <kallisti> the problem with using pure in a do block
01:55:43 <kallisti> is that pure uses the Applicative instance of the type, rather than the Monad instance.
01:55:55 <kallisti> so it needs both of those constraints to work.
01:56:18 <mekeor> got it. thanks =)
01:56:29 <kallisti> > do { f <- pure (+1); f [1,2,3,4] }
01:56:30 <lambdabot>   No instance for (GHC.Num.Num [b])
01:56:30 <lambdabot>    arising from a use of `e_111234' at <i...
01:56:40 <kallisti> > do { f <- pure (+1); map f [1,2,3,4] }
01:56:40 <lambdabot>   [2,3,4,5]
01:57:41 <kallisti> in the case of lists, the interpreter can infer the applicative and monad instances.
01:58:09 <mekeor> that works because IO is an applicative functor, right?  (i mean, in theory all monads are but…)
01:58:17 <kallisti> this has nothing to do with IO
01:58:23 <mekeor> hmm…
01:58:30 <kallisti> do notation is not unique to IO
01:58:32 <kallisti> ??
01:58:46 <kallisti> but yes IO is an applicative functor.
01:58:57 <kallisti> but it was never used or mentioned so I'm not sure why you brought it up.
01:59:04 <mekeor> so, what's the type of "pure (+1)" there then?
01:59:17 <kallisti> Num a => [a]
01:59:27 <kallisti> er
01:59:30 <kallisti> Num a => [a -> a]
01:59:34 <mekeor> :t pure (+1)
01:59:35 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f (a -> a)
01:59:41 <kallisti> oh also Applicative. oops.
01:59:54 * kallisti is not running on very much sleep. :P
02:00:13 * hackagebot Allure 0.4.4 - Near-future roguelike game in very early and active development  http://hackage.haskell.org/package/Allure-0.4.4 (MikolajKonarski)
02:00:24 <mekeor> kallisti: but why a list and not an IO action?
02:00:40 <kallisti> I don't understand the question
02:00:47 <kallisti> it's a list because that's what all of the types work out to be.
02:00:54 <kallisti> because I use map
02:01:09 <mekeor> i mean, the type of "pure (+1)" could also be "Num a => IO (a -> a)"
02:01:15 <kallisti> correct
02:01:18 <mekeor> good.
02:01:24 <kallisti> but it's not here.
02:01:44 <kallisti> it can only be ONE type. the only possible type it can be in the above expression is a list
02:01:55 <kallisti> because I use map
02:02:07 <mekeor> > do { f <- pure (+1) :: Num a => IO (a->a); map f [1,2,3,4] }
02:02:08 <lambdabot>   Couldn't match expected type `GHC.Types.IO b'
02:02:08 <lambdabot>         against inferred type...
02:02:38 <kallisti> :: is not a cast. you told it that pure (+1) was a blatantly incorrect type and it got confused.
02:02:56 <kallisti> > 2 :: Char
02:02:57 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
02:02:57 <lambdabot>    arising from the literal `2...
02:03:02 <mekeor> i know that.
02:03:06 <kallisti> same thing happend here.
02:03:06 <kallisti> okay.
02:03:09 <ClaudiusMaximus> :t do { f <- ?anything ; map f [1,2,3,4] }
02:03:09 <lambdabot> forall b a. (?anything::[a -> b], Num a) => [b]
02:03:43 <kallisti> > do { f <- pure (+1); f undefined }
02:03:43 <lambdabot>   No instance for (GHC.Num.Num (f b))
02:03:44 <lambdabot>    arising from a use of `e_11' at <int...
02:03:55 <mekeor> so, my question is: Why does ?anything have to be a list?
02:04:04 <kallisti> because of map
02:04:11 <kallisti> oh
02:04:13 <kallisti> yes
02:04:15 <kallisti> because of >>= and map
02:04:16 <kallisti> together
02:04:25 <kallisti> f
02:04:26 <kallisti> er
02:04:28 <mekeor> :t map
02:04:29 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:04:49 <ClaudiusMaximus> @undo do { f <- pure (+1) ; map f [1,2,3,4] }
02:04:49 <lambdabot> pure (+ 1) >>= \ f -> map f [1, 2, 3, 4]
02:05:26 <mekeor> :t (>>=)
02:05:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:05:38 <kallisti> notice that there is only one monad being used, namely m.
02:05:50 <kallisti> so if your lambda returns a list
02:05:58 <mekeor> kallisti: AH!
02:05:58 <kallisti> then the left-hand side of >>= must also be a list.
02:06:04 <mekeor> yea!
02:06:08 <mekeor> got it now :D
02:07:22 <mekeor> thank you kallisti and ClaudiusMaximus !
02:08:14 <kallisti> no problem.
02:08:21 <kallisti> I wonder if do notation secretly had something to do with the confusion.
02:09:44 <kallisti> mekeor: are you familiar with join?
02:10:10 <mekeor> :t join
02:10:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:10:19 <mekeor> now, yes
02:10:33 <kallisti> > join . Just . Just $ 2
02:10:35 <lambdabot>   Just 2
02:10:39 <mekeor> yea
02:10:46 <mekeor> nice
02:10:48 <kallisti> > join [[1..3],[4..8]]
02:10:50 <lambdabot>   [1,2,3,4,5,6,7,8]
02:11:00 <mekeor> it's like concat
02:11:00 <kallisti> when m = [], join = concat
02:11:04 <kallisti> yes
02:11:15 <kallisti> so, here's another interesting property of monads
02:11:24 <kallisti> join (fmap f m) = m >>= f
02:11:32 <mekeor> oh, cool
02:11:36 <kallisti> using the list monad as an example you should be able to see this.
02:11:57 <mekeor> bah. that's hard to understand for me atm >.>
02:12:16 <kallisti> when m = [],  join = concat, fmap = map,  (>>=) = flip concatMap
02:12:50 <kallisti> maybe if you get more familiar with the list monad you'll be able to see it.
02:13:14 <mekeor> (flip concatMap) list func
02:13:20 <mekeor> concatMap func list
02:13:23 <kallisti> yes
02:13:24 <ClaudiusMaximus> what's the best way to encode video generated by haskell? i did use HSH once a long time ago to pipe ppm into ppmtoy4m|y4mscaler|mpeg2enc, but it was a bit of a headache w.r.t. buffering, threading, etc
02:13:30 <kallisti> the parentheses aren't needed
02:13:44 <mekeor> kallisti: rly?
02:13:51 <kallisti> yes function application is left associative
02:13:54 <kallisti> f x y = (f x) y
02:14:02 <mekeor> oh, right. neat :D
02:14:37 <kallisti> you know that <$> is fmap yes?
02:14:46 <mekeor> yes
02:15:08 <mekeor> (i'm reading LYAH on applicative functors atm…)
02:15:12 <kallisti> > (\x -> return (x+2)) <$> Just 2
02:15:13 <lambdabot>   No instance for (GHC.Show.Show (m a))
02:15:13 <lambdabot>    arising from a use of `M9795949525...
02:15:14 <kallisti> er
02:15:27 <kallisti> > (\x -> Just (x+2)) <$> Just 2
02:15:27 <lambdabot>   Just (Just 4)
02:15:38 <kallisti> > join $ (\x -> Just (x+2)) <$> Just 2
02:15:39 <lambdabot>   Just 4
02:15:39 <mekeor> > (+1) <$> Just 3
02:15:40 <lambdabot>   Just 4
02:15:47 <mekeor> > Just (+1) <*> Just 3
02:15:47 <lambdabot>   Just 4
02:15:58 <kallisti> > Just 2 >>= \x -> Just (x+2)
02:15:59 <lambdabot>   Just 4
02:16:06 <kallisti> see? same thing.
02:16:35 <mekeor> ah, yea
02:16:42 <mekeor> of course, yes.
02:17:11 <kallisti> >>= is just like a call to fmap followed by flattening a single level of nested monad.
02:17:52 <mekeor> :t (<*>) $ map (*) [1..5]
02:17:53 <lambdabot> forall a. (Num a, Enum a) => [a] -> [a]
02:18:08 <kallisti> knowing the relationship between fmap and >>= is helpful when trying to choose which one to use in an expression.
02:18:12 <mekeor> >  (<*>) $ map (*) [1..5] $ [6..10]
02:18:13 <lambdabot>   Couldn't match expected type `a -> b'
02:18:13 <lambdabot>         against inferred type `[a1 ->...
02:18:58 <kallisti> usually the question is something like:  do I want to apply a -> m b   or a -> b
02:19:36 <mekeor> >  map (*) [1..5] <*> [6..10] -- shouldn't this actually work?
02:19:37 <lambdabot>   [6,7,8,9,10,12,14,16,18,20,18,21,24,27,30,24,28,32,36,40,30,35,40,45,50]
02:19:45 <kallisti> yes it actually does. :P
02:19:49 <mekeor> :)
02:20:12 <kallisti> even better you can write it as
02:20:20 <kallisti> > (*) <$> [1..5] <*> [6..10]
02:20:21 <lambdabot>   [6,7,8,9,10,12,14,16,18,20,18,21,24,27,30,24,28,32,36,40,30,35,40,45,50]
02:20:32 <kallisti> this is a common Haskell idiom.
02:20:34 <mekeor> ah yes :D  super cool
02:20:45 <kallisti> > (,) <$> [1..5] <*> [6..10]
02:20:46 <lambdabot>   [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),...
02:20:50 <kallisti> boom cartesian product.
02:20:57 <mekeor> awesome
02:21:26 <kallisti> and of course you can use it with IO as well:   (++) <$> readLine <*> readLine
02:21:50 <mekeor> cool
02:22:30 <mekeor> @hoogle readLine
02:22:30 <lambdabot> Network.TCP readLine :: HStream bufType => HandleStream bufType -> IO (Result bufType)
02:22:31 <lambdabot> Network.Stream readLine :: Stream x => x -> IO (Result String)
02:22:31 <lambdabot> package readline
02:23:06 <kallisti> oh I meant readLn
02:23:11 <kallisti> I think
02:23:13 <kallisti> no...
02:23:14 <mekeor> or getLine
02:23:16 <kallisti> yes
02:23:26 <kallisti> with readLn you could do something like
02:23:34 <kallisti> (+) <$> readLn <*> readLn
02:23:50 <mekeor> but the former, too.
02:24:03 <kallisti> hmmm, well, yes, but it would have different semantics.
02:24:06 <mekeor> you'd have to type '"foo"' then…
02:24:08 <kallisti> it would expect quotations around the two lines.
02:24:08 <kallisti> yes.
02:24:11 <mekeor> yep
02:24:34 <kallisti> so usually when people first learn about monads that get the impression that they're kind of cumbersome to work with.
02:24:47 <kallisti> that's because they haven't learned about applicative functors. ;)
02:25:27 <kallisti> (well I shouldn't say "usually".)
02:26:11 <mekeor> :)
02:26:46 <kallisti> > Just 2 `mplus` Just 3
02:26:47 <lambdabot>   Just 2
02:26:52 <kallisti> > Nothing `mplus` Just 3
02:26:52 <lambdabot>   Just 3
02:27:00 <kallisti> > Just 2 `mplus` Nothing
02:27:01 <lambdabot>   Just 2
02:28:09 <kallisti> if you think of Maybe as a model of error handling, then mplus tries one action and, if it fails, tries a second action. then, if the second action fails the whole thing fails.
02:28:14 * mekeor doesn't know MonadPlus and Monoid yet..
02:28:31 <mekeor> kallisti: cool
02:28:34 <yawNO> hello!
02:28:40 <mekeor> hi yawNO :)
02:29:06 <kallisti> mekeor: I use mplus in Real Code(tm) to handle errors.
02:29:08 <yawNO> im on my quest for a functional programminganguage
02:29:16 <yawNO> *ming language
02:29:27 <nand`> > [1, 2] `mplus` [3, 4]
02:29:28 <lambdabot>   [1,2,3,4]
02:29:39 <mekeor> oh
02:29:46 <kallisti> nondeterministic logical or. :D
02:29:57 <yawNO> i've heard that haskell is more academical and erlang might be better for the web (which is what im interestedin)
02:30:02 <yawNO> is it true?
02:30:08 <yawNO> should i learn erlang or haskell?
02:30:12 <yawNO> thx ^_^
02:30:16 <mikeplus32> not quite, there exists yesod, hakyll etc for haskell
02:30:46 <mikeplus32> you should learn haskell, because erlang syntax will make you a very sad person
02:30:50 <kallisti> mekeor: you can kind of think of mplus as being something like "or"
02:31:01 <yawNO> lol i see
02:31:38 <yawNO> because i started clojure and i dont find it to be really fun to work with
02:31:46 <kallisti> >> is kind of like "and" with a bias towards the type on the right-hand side.  <* is "and" with a bias to the left.
02:31:49 <yawNO> so im looking at other langs
02:31:53 <kallisti> ...but I digress.
02:32:16 <mikeplus32> haskell imo is the most exciting functional programming language that is of "real world" use
02:32:36 <yawNO> okay.. best book to get started?
02:32:46 <yawNO> or online resource.. doesnt matter
02:32:50 <kallisti> yawNO: the only thing Erlang has going for it is easy distributive computing.
02:32:50 <mikeplus32> real world haskell, learn you a haskell, the wiki? :)
02:33:15 <yawNO> kallisti: so erlang scales better ?
02:33:20 <kallisti> no.
02:33:27 <kallisti> I mean it's easy to write distributed code.
02:33:31 <kallisti> not that it's better to do so.
02:33:40 <kallisti> in other sense.
02:33:41 <yawNO> gotcha
02:33:44 <kallisti> er *in any other sense
02:33:56 <yawNO> mikeplus32: thx
02:34:05 <yawNO> i'll head to amazon then
02:34:08 <kallisti> because Erlang can do things like transfer processes from one node to another.
02:34:12 <mikeplus32> oh, RWH is online too
02:34:20 <kallisti> which is not very trivial in most Haskell implementations.
02:34:24 <mikeplus32> unless you want to buy it of course
02:34:34 <yawNO> i have a kindle
02:34:37 <mikeplus32> ah
02:34:40 <yawNO> and pdf conversion sucks
02:34:45 <yawNO> so i usually buy books
02:34:47 <yawNO> :D
02:36:00 <kallisti> mekeor: once you become more comfortable in your Haskell shoes you should look at LogicT
02:37:18 <kallisti> yawNO: I'm broke. I read online.
02:37:40 <yawNO> kallisti: i am too.. i dont buy many books... trust me
02:37:52 <yawNO> i usually read stuff online.. blogs wikis etc
02:38:08 <kallisti> most blogs about Haskell are bad.
02:38:09 <yawNO> but i just cant read 300 pages on a laptop monitor
02:41:26 <yawNO> learn you a haskell looks better than RWH
02:42:06 <kallisti> LYAH is more accessible
02:43:14 <Zamarok> Hmmm.. how can I write this better?
02:43:17 <Zamarok> map (\(x,y) -> (xs !! x, xs !! y))
02:43:41 <kallisti> map ((!! x) &&& (!! y))
02:43:46 <kallisti> er
02:43:50 <kallisti> map ((!! x) *** (!! y))
02:43:55 <kallisti> *** is from Control.Arrow
02:44:42 <kallisti> ......wait
02:44:43 <Zamarok> hmm that's interesting
02:45:00 <kallisti> no. don't listen to me.
02:45:12 <kallisti> :t arr
02:45:13 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
02:45:15 <Zamarok> lol alrighty.. anyone else?
02:45:18 <ClaudiusMaximus> imo better not use !!, as it's slow and fragile - alternatives are IntMap e or Array Int e
02:45:42 <kallisti> map ((xs !!) *** (xs !!))
02:45:43 <kallisti> this
02:45:46 <kallisti> is what you want
02:46:27 <kallisti> map (join (***) (x !!))  too if you want to get a little fancier (and probably import one more thing).
02:46:42 <kallisti> *xs
02:46:46 <kallisti> okay I'm going to sleep now.
02:46:47 <ClaudiusMaximus> :t \xs -> uncurry ((,) `on` (xs !!))
02:46:48 <lambdabot> forall a. [a] -> (Int, Int) -> (a, a)
02:47:06 <Zamarok> oh ok, well thanks for the input kallisti
02:47:35 <kallisti> > map (negate *** recip) [(1,2), (3,4), (5,6)]
02:47:35 <lambdabot>   [(-1,0.5),(-3,0.25),(-5,0.16666666666666666)]
02:47:49 <kallisti> good stuff.
02:48:10 <zhulikas> [(xs !! x, xs !! y) | (x,y) <- ys]
02:48:51 <Zamarok> but can it be done concisely without importing a module? I bet with uncurry
02:49:17 <zhulikas> mine works without extra imports
02:49:19 <kallisti> uncurry is in prelude?
02:49:20 <zhulikas> :P
02:49:27 <ClaudiusMaximus> @index on
02:49:27 <lambdabot> bzzt
02:49:29 <kallisti> @hoogle uncurry
02:49:29 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
02:49:29 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> ((a, b) -> c)
02:49:36 <kallisti> oh. okay.
02:50:03 <kallisti> hows how much I don't use uncurry. :P
02:50:08 <Zamarok> zhulikas: ya that's basically how I'm doing it, but with a lambda
02:50:31 <ClaudiusMaximus> :t mapMaybe $ uncurry (liftM2 (,) `on` (m M.!))
02:50:32 <lambdabot>     Couldn't match expected type `M.Map a a1'
02:50:32 <lambdabot>            against inferred type `Expr'
02:50:32 <lambdabot>     In the first argument of `(M.!)', namely `m'
02:50:42 <ClaudiusMaximus> :t \m -> mapMaybe $ uncurry (liftM2 (,) `on` (m M.!))
02:50:43 <lambdabot> forall a2 a. (Ord a) => M.Map a (Maybe a2) -> [(a, a)] -> [(a2, a2)]
02:50:51 <kallisti> in some simple cases Control.Arrow can greatly shorten your code. in most other cases it renders it illegible.
02:51:11 <ClaudiusMaximus> :t \m -> mapMaybe $ uncurry (liftM2 (,) `on` (m `M.lookup`))
02:51:12 <lambdabot> forall a2 k. (Ord k) => k -> [(M.Map k a2, M.Map k a2)] -> [(a2, a2)]
02:51:33 <ClaudiusMaximus> :t \m -> mapMaybe $ uncurry (liftM2 (,) `on` (M.lookup m))
02:51:34 <lambdabot> forall a2 k. (Ord k) => k -> [(M.Map k a2, M.Map k a2)] -> [(a2, a2)]
02:51:36 <Zamarok> kallisti:  Yea I will use either uncurry and `on` from Data.Function or that
02:51:40 <ClaudiusMaximus> arrg...
02:51:54 <ClaudiusMaximus> :t \m -> mapMaybe $ uncurry (liftM2 (,) `on` (`M.lookup` m))
02:51:55 <lambdabot> forall a2 k. (Ord k) => M.Map k a2 -> [(k, k)] -> [(a2, a2)]
02:52:03 <kallisti> I actually find join (***) (xs !!)  readable..
02:55:23 <kallisti> and there's something fishy about (,) followed by uncurry.
02:57:20 <Saizan> ?type uncurry (flip (,))
02:57:20 <lambdabot> forall b a. (a, b) -> (b, a)
03:01:13 <Zamarok> kallisti ClaudiusMaximus - http://pastebin.com/XiK3yY4S
03:01:22 <Zamarok> that's what I was writing, if you were curious.. the first one is faster
03:01:40 <yasar> Can someone explain how exactly theese two functions work? http://codepad.org/VpvRPvX8
03:02:05 <Franciman> yasar
03:02:08 <Franciman> well the first
03:02:20 <Franciman> is a lambda in a lambda in a lambda
03:02:26 <Franciman> it's the same as
03:02:33 <Franciman> \x y z -> x + y + z
03:02:50 <Franciman> \x->\y->\z->x+y+z
03:02:51 <Franciman> means
03:02:58 <Franciman> that the first lambda is a function
03:02:58 <Zamarok> yasar: looks like someone is demonstrating "function currying"
03:03:12 <Franciman> that given a value x returns a new function
03:03:17 <yasar> Zamarok: http://learnyouahaskell.com/higher-order-functions
03:03:27 <Franciman> that accepts another value y , and the same is for this
03:03:28 <Franciman> one
03:04:12 <ClaudiusMaximus> Zamarok: speed difference makes sense, because !! is slow
03:05:13 <Zamarok> ClaudiusMaximus: How is that implemented without (!!)?
03:05:16 * hackagebot cabal2nix 1.29 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.29 (PeterSimons)
03:05:18 <yasar> DjFranciman: Can we put paranthesis around them to make it easier to understand?
03:05:30 <DjFranciman> yes
03:05:33 <DjFranciman> you mean
03:05:48 <DjFranciman> \x -> ( \y -> ( \z -> x+y+z ) )
03:05:48 <DjFranciman> ?
03:06:08 <yasar> yes.
03:06:22 <Franciman> well I'd prefer : \x y z -> x+y+z
03:06:23 <Franciman> lol
03:08:15 <yasar> Yes, but I am trying to understand how it fits together. Is is a lambda function, that takes "x", and returns a lambda function, that takes "y", and that lambda function, returns another lambda function, that takes "z", and last lambda function returns x + y + z ?
03:08:56 <mekeor> yasar: 'addThree = \x -> \y -> \z -> x + y + z' is the same as 'addThree x y z = x+y+z'.
03:09:05 <sepp2k> yasar: Yes
03:09:12 <ClaudiusMaximus> Zamarok: list comprehension with tails is how i'd do it
03:09:57 <ClaudiusMaximus> > tails[1,2,3]
03:09:57 <lambdabot>   [[1,2,3],[2,3],[3],[]]
03:10:08 <Franciman> yes
03:10:11 <yasar> So how come last lambda function know values x and y?
03:10:20 <Franciman> because they're in scope
03:10:23 <Franciman> it's like
03:10:28 <Franciman> fun x = some stuff
03:10:36 <Franciman> where some k = x + k
03:10:57 <Franciman> no wait maybe there is different
03:11:03 <Franciman> yasar it's like
03:11:06 <Franciman> fun x = 1 + x
03:11:12 <Franciman> why can you use x on the right side?
03:12:47 <mekeor> Franciman: you are confusing, not explaining…
03:12:52 <sepp2k> yasar: Because inner functions can access variables from the scope of the outer function.
03:13:13 <yasar> sepp2k: Hmm. makes sense.
03:13:19 <Franciman> mekeor actually .... :S
03:13:40 <sepp2k> Franciman: You're explaining why he can access z in the inner function - not why he can access x and y.
03:13:57 <OODavo> Does X11-1.6 actually exist? The newest patches to xmonad-contrib darcs make that version a dependency, but it doesn't seem to be on Hackage.
03:14:05 <yasar> How could have be write \x -> \y -> \z = x + y + z, with named functions, instead of lambdas?
03:14:18 <Franciman> addThree x y z = x+y+z
03:14:35 <Franciman> sepp2k, I did a "little" bit of confusion
03:14:42 <Franciman> I'm also new to haskell :(
03:15:01 <mekeor> I'm also new to haskell :)
03:15:19 <mekeor> (quite new…)
03:15:21 <yasar> me too! We should start a club or something :D
03:15:24 <ClaudiusMaximus> \x y z -> x + y + z  =  (\x -> (\y -> (\z -> x + y + z ) ) )  -- each lambda scopes as far as possible to the right, names are resolved to the nearest (innermost) scope that binds them - eg, http://en.wikipedia.org/wiki/Lexical_scope#Lexical_scoping
03:15:28 <Franciman> yasar LOL
03:16:02 <mekeor> yasar: i'm reading LYAH, too, btw: i'm at http://learnyouahaskell.com/functors-applicative-functors-and-monoids =]
03:16:04 <sepp2k> I think he meant using multiple nested named functions. Like this:  addThree x = let addTwo y = let addOne z = x + y + z in addOne in addTwo
03:16:27 <yasar> sepp2k: Yes, exactly!
03:17:11 <yasar> sepp2k: Can you paste it somewhere with indentation?
03:17:22 <sepp2k> Doing so now ;-)
03:19:05 <Zamarok> ClaudiusMaximus: yep, much faster - uniquePairs xs = [ (head x, y) | x <- (init $ tails xs), y <- (tail x) ]
03:19:44 <sepp2k> yasar: http://codepad.org/YTGravnu
03:21:06 <Chaze> I'm trying to understand the difference of :module, :import, :load and :add in ghci..
03:21:13 <Chaze> "It might seem that :module and :load do similar things: you can use both to bring a module into scope."
03:21:24 <Chaze> what exactly does it mean to bring a module 'in scope'?
03:21:50 <OODavo> :module is like import, in that it imports everything that the module /exports/.
03:22:06 <OODavo> :load pulls in everything in the module, even things that are only accessible from inside said module.
03:22:09 <OODavo> If I recall correctly.
03:22:16 <Chaze> OODavo: ah, that makes sense
03:22:56 <Chaze> some modules, I can't seem to "load"
03:23:11 <Chaze> "`...' is a package module"
03:23:16 <OODavo> I think :load works on actual source files, rather than modules.
03:23:17 <Chaze> what does that mean?
03:23:27 <OODavo> Hence its ability to show you stuff that's not exported.
03:24:32 <ClaudiusMaximus> Zamarok: head, tail, init also are generally to be avoided due to partiality (they can throw errors) - better to use pattern matching where possible
03:26:15 <Zamarok> ClaudiusMaximus: Really? Isn't it impossible for them to err the way I have them? It works fine for [] [a] and [a,a,..]
03:26:17 <yasar> It seems like there is belief in the wild that most Haskell users is mathematicians, in what degree does it hold true?
03:26:36 <Chaze> oh, i just realized import is a statement, not a command
03:27:15 <ClaudiusMaximus> Zamarok: right, it's safe in this case, but it's a good habit to get into - nothing worse than tracking down "*** Exception: Prelude.head: empty list"  in a large code base...
03:27:51 <yasar> or why people might think so to begin with?
03:27:54 <Chaze> so all that is missing now: is there a difference between "modules" and "packages"?
03:28:05 <Zamarok> ClaudiusMaximus: Oh that makes sense, I'll remember that
03:28:22 <OODavo> A package includes multiple modules.
03:28:46 <Chaze> ah, so i can import a module, but i obviously can't load it
03:29:28 <Chaze> OODavo: thanks, i think my picture is sufficiently complete now :)
03:30:50 <mekeor> yasar: haskell has a strong mathematical background.
03:31:32 <mekeor> yasar: haskell bases upon type theory and category theory.
03:32:39 <yasar> Will I need to learn those while learning haskell?
03:32:49 <zhulikas> not necessary
03:32:53 <mekeor> yasar: also, IMO, functional programming in general is farly more similar to maths then imperative programming because in maths usually the value of a variable can't change…
03:33:37 <OODavo> Haskell has some math-y syntax, as well: where and let bindings, for instance.
03:33:59 <mekeor> OODavo: or list comprehension (similar to set comprehension in maths).
03:34:07 <OODavo> Yep, those too.
03:34:21 <ClaudiusMaximus> guards too!   foo x | x > 0 = '+'   | x == 0 = '0'   | x < 0 = '-'
03:34:56 <mekeor> oh, yes. guards are like those big brackets, right?
03:35:23 <yasar> So in a sense haskell compiler solves mathematical problems according to definitions we wrote.
03:36:05 <Chaze> although i consider haskells syntax superior to "math syntax"
03:36:11 <ClaudiusMaximus> mekeor: yep, like this http://upload.wikimedia.org/wikipedia/en/math/b/a/0/ba0bc5b6d9e9c74b457275703ddb1026.png
03:36:16 <Chaze> in fact, one could perfectly hold a maths lecture in haskell, i believe
03:36:53 <Chaze> hhm, maybe it lacks convenient notations for sets
03:36:57 <mekeor> ClaudiusMaximus: i was about to paste a link, too… but yea, yes.
03:37:45 <mekeor> Chaze: that's right! it'd be grade to have syntactical sugar for sets =)
03:38:24 <mekeor> but sets aren't that useful in FP…  lists are most powerful… also, internally, Data.Set is an ascending list, right?
03:38:48 <Chaze> well yes, but i was thinking of writing stuff down in haskell you're discussing in a maths lecture
03:39:06 <shachaf> mekeor: No, no, and no.
03:39:23 <mekeor> shachaf: no?
03:39:33 <shachaf> Yes.
03:39:37 <mekeor> shachaf: why?
03:40:03 <shachaf> Statements don't become true just by being said.
03:40:36 <mekeor> shachaf: what do you refer to?
03:40:52 <shachaf> 03:38 < mekeor> but sets aren't that useful in FP…  lists are most powerful… also, internally, Data.Set is an ascending list, right?
03:41:07 <mekeor> to "useful" or to "ascending list" ?
03:41:19 <shachaf> Yes.
03:41:23 <mekeor> both?
03:41:59 <shachaf> Yes.
03:42:18 <mekeor> shachaf: can you give an explanation why?
03:42:37 <Saizan> Data.Set is a size-balanced tree
03:42:43 <mekeor> by useful, i meant that sets aren't as useful as lists…
03:42:57 <shachaf> mekeor: That's not a very satisfying definition of "useful".
03:43:12 <mekeor> shachaf: i am sorry then.
03:43:30 <shachaf> by useful, i meant that sets aren't as (sets aren't as useful as lists) as lists…
03:44:20 <mekeor> huh??
03:46:16 <mekeor> @src Set
03:46:16 <lambdabot> Source not found. stty: unknown mode: doofus
03:46:33 <mekeor> data Set a = Tip | Bin {-# UNPACK #-} !Size !a !(Set a) !(Set a)
03:47:51 <sepp2k> mekeor: He's saying your definition of usefulness is infinitely recursive
03:48:07 <mekeor> AH!
03:51:39 <mekeor> Saizan: why does Data.Set have functions like fromAscList and toAscList, then?
03:54:19 <Lemmih> mekeor: It's easier to construct a balanced tree if you know the input list is already sorted.
03:55:16 <mekeor> Lemmih: why does it have to be sorted?
03:57:36 <yasar> I still can't understand how come right fold works on infinite lists, there is no last value to start to recurse.
03:58:00 <Lemmih> mekeor: You can create a set from an unordered list of data but that involved a lot of comparisons. If you statically know that the input list is sorted then you can use that knowledge to construct the set more efficiently.
03:58:13 <Lemmih> s/involved/involves/
04:02:23 <mekeor> Lemmih: why is it easier to construct a balanced tree if you know the input list is already sorted?
04:02:36 <sepp2k> yasar: You don't necessarily need the last value.
04:03:13 <sepp2k> mekeor: Because then you know in advance that e.g. the first element of the list will be the left-most node of the tree etc.
04:04:07 <sepp2k> So basically you know where each node goes in advance and you can do everything in O(n) time instead of O(n log n)
04:09:03 <Franciman> hey people, in this example
04:09:04 <Franciman> http://hpaste.org/65883
04:09:32 <Franciman> isn't the tree copied totally ?
04:09:56 <Franciman> it's an example in the chapter that explains zippers in LYAH
04:11:09 <sepp2k> yasar: Note that  foldr f y (x:xs)  expands to  f x (foldr f y xs). So if f simply discards its second argument, foldr f y xs  will never be evaluated. So as long as that happens some time, the end of xs will never be reached, which is why it works for infinite lists.
04:11:40 <ClaudiusMaximus> Franciman: it changes the path down to the leaf that gets changed, the other branches are shared with the previous copy (eg, on line 5 - the 'r' tree is the same before and after)
04:12:31 <Franciman> ClaudiusMaximus, so it doesn't get copied?
04:12:45 <Franciman> ( btw, I like your name :P )
04:14:00 <Franciman> I keep not understanding
04:14:31 <Franciman> given a tree
04:14:44 <Franciman> doesn't that function construct a new tree?
04:15:02 <Franciman> that is different from the precedent just for a path
04:15:17 <sepp2k> Franciman: Yes, but the new tree still contains parts of the old tree.
04:15:34 <Franciman> but they're copied?
04:15:40 <sepp2k> No.
04:15:43 <Franciman> how?
04:15:46 <sepp2k> Why would they be?
04:15:54 <Franciman> I don't know, I just don't understand
04:16:31 <baleft> they are not copied? how do you mean?
04:16:36 <Franciman> I have a : Node x l r
04:16:46 <Franciman> if in a function I return a new Node
04:16:52 <Franciman> with x l r as parameters
04:16:58 <Franciman> isn't a new node created?
04:17:02 <Franciman> and x l ad r copied?
04:17:10 <baleft> in my opinion nearly everything in haskell gets copied not reused / referenced / etc.
04:17:21 <sepp2k> Franciman: A new node is created and nothing is copied.
04:17:35 <baleft> but copy means create new.
04:17:40 <baleft> like
04:18:20 <Franciman> wait, let me do a step back, my mind is too imperative-set
04:18:31 <sepp2k> Consider this: let changeFirstElement (x:xs) = 42:xs in changeFirstElement [1..]  This will create a new list that starts with 42 followed by 2,3,4,... It does not copy all the numbers from 2 to infinity (otherwise it would never terminate)
04:18:59 <baleft> because of laziness, sure
04:19:30 <Franciman> sure
04:20:02 <sepp2k> baleft: It would act the same way in a strict language though (minus the infinite lists). changeFirstElement would still be an O(1) operation in, say, ML
04:20:35 <Franciman> wait a second, when I pass a list to a function
04:20:39 <Franciman> it doesn't get copied right?
04:20:45 <baleft> there are no mutable values nowhere in pure haskell
04:20:53 <Lemmih> Franciman: Nope.
04:20:57 <yasar> > map ($ 3) [(4+), (10*), (^2), sqrt]
04:20:58 <lambdabot>   [7.0,30.0,9.0,1.7320508075688772]
04:21:00 <Franciman> and when I return a value
04:21:04 <Franciman> it doesn't get copied
04:21:05 <Franciman> right?
04:21:07 <Lemmih> Franciman: No need to copy anything in Haskell.
04:21:08 <baleft> no
04:21:12 <baleft> i cant follow
04:21:21 <Franciman> STUPID C++
04:21:33 <baleft> input parameter are as they are.
04:21:44 <baleft> you always create "new" values in haskell
04:21:48 <Franciman> of course
04:21:50 <baleft> which are not mutable
04:21:55 <Franciman> but if I do
04:21:57 <Franciman> f x = x
04:22:02 <Franciman> that x is not copied
04:22:03 <Franciman> right?
04:22:12 <baleft> sure, you get f 1 = 1
04:22:30 <Franciman> nor does it create a new value
04:22:31 <Lemmih> Franciman: Correct.
04:22:33 <yasar> > map ($ 3) [(4+), (10*), (^2), sqrt]
04:22:39 <yasar> What is going on here ^^^
04:22:47 <Franciman> insted, if I do f x = 1 + x
04:22:50 <Franciman> a new value is created
04:22:51 <Franciman> right?
04:22:56 <sepp2k> Right
04:23:21 <Franciman> so:
04:23:23 <baleft> I think the problem ist that you think input and output are related to each other after having processed the function
04:23:28 <baleft> but they arent
04:23:31 <Franciman> exactly
04:23:36 <Franciman> but now I've changed my mind
04:24:04 <zhulikas> yasar, you are mapping a value over a list of functions
04:24:18 <Franciman> baleft, and having : f ( Just x ) = Just x
04:24:21 <baleft> when having a look at referential transparency the function return value depends on inputs only and is in any case the same. if so no references are possible.
04:24:25 <zhulikas> > ($ 3) (4+)
04:24:26 <lambdabot>   7
04:24:28 <Franciman> is a new Just x created?
04:24:35 <zhulikas> @type ($ 3)
04:24:36 <lambdabot> forall a b. (Num a) => (a -> b) -> b
04:25:01 <Lemmih> Franciman: The compiler is free to do whatever.
04:25:16 <baleft> everything is an value, why do you need the term "created?" there is no allocation of memory logically visible.
04:25:30 <Franciman> baleft I mean
04:25:37 <Franciman> allocate a new Just x
04:25:44 <Franciman> and of course copy that x
04:25:46 <sepp2k> baleft: To reason about performance, I'd assume.
04:26:18 <baleft> e.g. if you have an "record" of master data, when you change one attribute of it (like you do when you cange an attribut in an c++ object e.g.) than you get a fresh copy of the structure, a pure structured value, nothing is reused, no references, e.t.c.
04:26:59 <Franciman> baleft, so in that case nothing is copied
04:27:04 <baleft> the things are stateless.
04:27:48 <Franciman> baleft, and last thing
04:28:18 <Franciman> f ( Node x l r ) = Node x (Node x Empty Empty) r
04:28:43 <Franciman> in this case what happens?
04:29:06 <Lemmih> Franciman: You're asking about implementation details.
04:29:10 <baleft> function f (Node x l r ) returns an value. which is specified on the right.
04:29:29 <baleft> what do you want to know?
04:29:40 <Franciman> whether a new Node is created
04:29:53 <baleft> any function returns values
04:29:55 <Franciman> *Tree
04:29:58 <baleft> you can call them "new values"
04:30:13 <Franciman> whether just the left Node is modified
04:30:18 <baleft> because they are not in a system of "states" - they are completly independent
04:30:31 <baleft> no modification at all is there
04:30:35 <Lemmih> Franciman: No modification takes place.
04:30:36 <yasar> The more I learn haskell, the more it feels like a perfect language. :)
04:30:39 <Franciman> yes sorry
04:30:50 <yasar> Everything is so elegant.
04:30:53 <baleft> parameter go into the function.
04:30:59 <baleft> return values get out
04:31:17 <Franciman> Lemmih, then the Zipper is implementation specific?
04:31:28 <Lemmih> yasar: I'm so glad that my employers agree with you. (:
04:31:49 <Lemmih> Franciman: No.
04:32:05 <Franciman> the point here is that I don't understand how the Zipper inserts element not in linear time
04:32:07 <Franciman> but in constant time
04:32:16 <Franciman> or log n
04:32:24 <Franciman> ( I do not remember )
04:32:37 <yasar> Lemmih: Do you use haskell at work? What kind of projects do you do with it?
04:33:25 <Lemmih> yasar: Prototyping of backend systems.
04:33:58 <baleft> Lemmih: what task do the backend systems is performing?
04:34:25 <yasar> And also, do you think haskells suits the job?
04:34:27 <Lemmih> Franciman: Try thinking about a zipper like you'd think about a set or a queue. It's a specific structure which allows some operations with specific complexities.
04:35:05 <Lemmih> baleft: Receiving data, processing it, handing it back to the frontend.
04:35:40 <baleft> Lemmih: that is functional, yes :-)
04:36:18 <baleft> Lemmih: is it for banking, or for security, or for ... else?
04:37:49 <Lemmih> It's about teaching, managing schools and the likes.
04:38:20 <Franciman> last attempt :
04:38:50 <Franciman> fun ( Node x l r ) = Node x (functionThatReturnsARandomNode) r
04:39:07 <Franciman> is this case after the function returns the new value, what is allocated?
04:40:12 <Lemmih> Franciman: You're asking all the wrong questions, my good man. Realizing that the allocations do not matter will bring you one step closer to enlightenment.
04:40:28 <Franciman> dman
04:40:31 <Franciman> *damn
04:41:10 <Franciman> I give up
04:41:39 <baleft> for my understanding in pure haskell there is no random at all since the function return value may only depend on the input - in Franciman example, different return values are imaginable even the same input values go into the function.
04:42:28 <Jafet> random = return 4
04:42:36 <Franciman> yes that was my random
04:42:37 <Franciman> :P
04:42:45 <baleft> That random is an IO function
04:42:57 <baleft> If you do IO then you can do procedural C++ too :-)
04:43:11 <zhulikas> yup, pure random is return 4
04:43:15 <baleft> :-)
04:43:21 <Franciman> for random I meant any node, I don't care what it is
04:43:28 <baleft> ok i see
04:44:18 <Jafet> Speaking of which, XLR was a terrible cartoon show.
04:44:39 <Lemmih> Franciman: Imagine you were trying to figure out how one can have O(log n) lookups in a set by looking at the op codes generated. That would be somewhat similar to what you're doing now.
04:44:44 <k0ral> hi, does the concept of inverse function exist in Haskell ? I mean: given a pure function, is there a way to build the inverse function, in  case it exists ?
04:44:48 <baleft> Franciman: your function will return a value of the form "Node x l r" or similar.
04:45:47 <Lemmih> Franciman: The number of instructions or allocations do not change the complexity of the algorithm.
04:46:04 <Franciman> yes
04:47:26 <yasar> How does foldr1 (const id) work?
04:47:35 <Franciman> my problem is that I have not understood when a new value is created and when nothing is created
04:47:40 <yasar> > foldr1 (const id) [1..10]
04:47:41 <lambdabot>   10
04:47:51 <zhulikas> @type const
04:47:53 <lambdabot> forall a b. a -> b -> a
04:48:03 <zhulikas> > const 1 2
04:48:04 <lambdabot>   1
04:48:09 <zhulikas> > id
04:48:09 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
04:48:10 <lambdabot>    arising from a use of `...
04:48:34 <Lemmih> > foldr1 (const f) [a,b,c]
04:48:35 <lambdabot>   f (f c)
04:48:35 <Franciman> say, I have a list : data MyList a = a ( Tree t ) | Empty
04:48:40 <Lemmih> > foldr1 (g f) [a,b,c]
04:48:41 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:48:41 <lambdabot>    `GHC.Show.Show a'
04:48:41 <lambdabot>      a...
04:48:45 <Franciman> and a function
04:48:58 <zhulikas> > foldl1 (const id) [1..10]
04:48:59 <lambdabot>   10
04:49:05 <zhulikas> :o
04:49:35 <Lemmih> Franciman: With you so far.
04:49:46 <baleft> Franciman: Any time new values are created when performing a function, believe me :-)
04:49:47 <Franciman> yes I've realized that i forgot the constructor
04:50:15 <Franciman> data MyList a = MyList a ( MyList l ) | Empty
04:50:24 <Franciman> attachTo myVal newList = MyList myVal newList
04:50:25 <zhulikas> > const id
04:50:26 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a -> a)
04:50:26 <lambdabot>    arising from a use...
04:50:37 <Franciman> in this case a new MyList is created
04:50:39 <Lemmih> Franciman: Btw, why do you care when things are allocated? You agreed that it won't affect the complexity of the algorithm you're implementing.
04:50:41 <baleft> k0ral: There are inverse functions, but there is no general method to generate the inverse for each function. You have to implement, e.g. inverse :: (a -> b) -> (b -> a)
04:50:58 <baleft> k0ral: Not any function may have an inverse of it
04:51:31 <Franciman> Lemmih I want to understand when data creation and copying happen
04:52:24 <k0ral> baleft: thank you
04:52:25 <Lemmih> Franciman: Then you will have to look at a specific Haskell implementation and figure out what it does.
04:52:31 <baleft> k0ral: e.g.  f :: a -> a -> b    implemented as   f x y = x+y    how should the inverse function look like?  finv :: b -> a -> a  how would you implement?? hihi
04:53:12 <Franciman> oh ok
04:53:13 <Lemmih> Franciman: Futhermore, most Haskell compilers do so much optimization that what you write is rarely recognizable once the allocations are made explicit.
04:53:45 <Franciman> well thank you baleft and Lemmih SO MUCH
04:54:01 <Lemmih> Franciman: With C you can guess at what each line is compiled to. With Haskell, there's no such hope.
04:54:09 <k0ral> baleft: I'm aware of the non-existence of inverse for some (most) functions, however I supposed some Haskell nerds could have taken advantage of the type system to enforce such existence
04:54:12 <Franciman> I'm too C-ized
04:55:00 <k0ral> baleft: I mean, defining a newtype that could be used only for invert-able functions
04:55:11 <baleft> Franciman: The longer you did C or C++ the longer you need to do Haskell / Erlang / Caml / etc.
04:56:55 <baleft> k0ral: cdsmith did investigate on that in detail... http://cdsmith.wordpress.com/2009/09/14/on-inverses-of-haskell-functions/
05:02:10 <k0ral> baleft: thank you, that's exactly what I was looking for
05:02:26 <baleft> k0ral you're welcome
05:02:32 <yasar> how come (const id) returns second element? const always returns first element, id returns same thing? How come they added together yields second element?
05:03:08 <alpounet> @type const id
05:03:09 <lambdabot> forall a b. b -> a -> a
05:03:09 <alpounet> :)
05:03:10 <baleft> yasar:   const :: a -> b -> a
05:04:12 <yasar> baleft: yes, it returns first element as is. I understood that far, but I can't figure out how combined with id, it returns second item.
05:04:27 <yasar> > (const id) 5 4
05:04:28 <lambdabot>   4
05:04:35 <yasar> const 5 4
05:04:40 <yasar> > const 5 4
05:04:41 <lambdabot>   5
05:04:56 <alpounet> yasar, well, in the type of "const"
05:05:03 <baleft> const is not intuitive for me in haskell...  but when i see the type it makes sense :-)
05:05:12 <alpounet> since we feed it id
05:07:58 <zhulikas> @type id
05:07:59 <lambdabot> forall a. a -> a
05:08:20 <baleft> why is const id 10 20 == 20? and not 10?
05:08:26 <hiptobecubic> @type const
05:08:27 <lambdabot> forall a b. a -> b -> a
05:08:34 <yasar> baleft: my point exactly!
05:08:44 <baleft> now i am lost,...
05:08:58 <yasar> baleft: me too...
05:09:02 <hiptobecubic> > const id 10 20
05:09:03 <lambdabot>   20
05:09:47 <hiptobecubic> > (const id 10) 20
05:09:47 <lambdabot>   20
05:10:15 <baleft> const (id 10) 20   == 10
05:10:34 <baleft> that means it is related to parentheses
05:12:24 <yasar> it is like first element to const function is "id 20"
05:12:36 <baleft> const id 10 20   means the same as  (const id) 10 20
05:12:47 <sepp2k> baleft: Because const id 10  is id and  id 20 is 20.
05:13:10 <yasar> sepp2k: That makes sense ...
05:13:20 <baleft> sepp2k: perfect
05:13:23 <baleft> thank you
05:28:02 <yawNO> heylo
05:36:58 <DrSyzygy> :t uncurry
05:36:59 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
06:07:34 <yasar> Can someone explain what is wrong with line 6: http://codepad.org/ZQrI3eVf
06:09:38 <Igloo> yasar: You don't want parentheses around /=
06:10:00 <Igloo> yasar: Parens change it to a prefix function, so you could write (/=) x (last xs)
06:12:31 <sepp2k> yasar: Also note that your function is terribly inefficient because last is an O(n) operation.
06:13:34 <yasar> How could I make it better?
06:15:10 <sepp2k> Oh and why is [] not a palindrome?
06:15:48 <sepp2k> isPalindrome xs = xs == reverse xs
06:16:57 <sepp2k> Oh and I just noticed your type signature is wrong. You can't use == or /= without an Eq constraint on the type.
06:17:11 <hpc> > [] == reverse []
06:17:12 <lambdabot>   True
06:17:27 <yasar> sepp2k: ghci noticied that too :)
06:17:31 <sepp2k> So it needs to be  Eq a => [a] -> Bool
06:19:26 <yasar> When you say x == reverse x , does it execute reverse x before it starts to compare, or does it get reversed while comparing?
06:19:41 <hpc> the latter
06:19:59 <hpc> it will stop mid-reverse if it finds inequal elements
06:20:24 <yasar> It is pretty efficient in that case.
06:20:35 <sepp2k> It is O(n) in either case.
06:21:02 <hpc> > let xs = [1, undefined, 3] in xs == reverse xs
06:21:03 <lambdabot>   False
06:22:09 <sepp2k> hpc: I'm pretty sure it does create the entire reverse list though. There's no way to efficiently reverse a list lazily that I'm aware of.
06:22:16 <sepp2k> :src reverse
06:22:17 <hpc> @src reverse
06:22:18 <lambdabot> reverse = foldl (flip (:)) []
06:22:33 <hpc> sepp2k: yeah, reverse is spine-strict
06:22:59 <koeien> well, reversing lists is often inefficient, like (!!)
06:23:07 <koeien> if you need to do it, often lists are not the way to go
06:23:22 <koeien> but it does not hurt for small examples and learning
06:23:51 <hpc> > let xs = [1, fix id, 3] in xs == reverse xs
06:23:51 <lambdabot>   False
06:23:56 <sepp2k> koeien: I wouldn't call O(n) inefficient for any operation that produces a result of size n.
06:24:15 <labo> Hello. What would be a good place to ask cabal questions?
06:24:21 <koeien> sepp2k: the problem that it takes O(n) to find the first constructor
06:24:24 <koeien> labo: here.
06:24:34 <koeien> or haskell-cafe
06:24:52 <hpc> what koeien said - reverse also takes O(n) memory
06:25:16 <hpc> which hurts if you don't want to fit the entire list in memory at once
06:25:39 <labo> I would like to include non-C code in a cabal package
06:25:40 <hpc> but since there's no better way to find palindromes... :P
06:26:04 <labo> but I can't figure out how to make cabal build anything other than haskell or C
06:26:25 <hpc> labo: it's a compiled non-C language?
06:26:31 <labo> fortran
06:26:35 <labo> yes
06:26:36 <hpc> i know lambdabot includes some perl...
06:26:38 <hpc> neat
06:26:53 <labo> hpc: I'll go look at that
06:28:01 <koeien> perl is not compiled though (or is it?)
06:28:21 <hpc> no
06:28:35 <hpc> http://www.haskell.org/cabal/ -- im going through here, seeing if anything has the answer
06:30:05 <yasar> How do I specify, not list value in case experession?
06:30:41 <koeien> yasar: i'm not sure what you mean.
06:31:05 <yasar> in case x not a list, do this, if x is a list do other thing etcç
06:31:14 <mysticc> @hoogle bracket
06:31:14 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:31:14 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:31:15 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:31:15 <labo> hpc: as koeien stated, lambdabot isn't helpful. The package is rather standard.
06:31:47 <sepp2k> yasar: Types are known statically. There will never be a situation where x could either be a list or not.
06:33:08 <koeien> yasar: yes that is not possible (and we like it that way :) ). what do you want to accomplish?
06:33:18 <yasar> I am trying to solve this problem: Transform a list, possibly holding lists as elements into a `flat' list by replacing each list with its elements (recursively).
06:33:48 <labo> hpc: I have tried googling and reading documentation, but I haven't found a solution.
06:34:15 <sepp2k> yasar: You can't have a list whose elements may or may not be lists. At least not using the normal [] data type.
06:34:43 <koeien> yasar: ah, we generally call this data structure a "tree"
06:34:47 <sepp2k> If you define your own NestedList data type, you can check whether an element is a nested list by matching on the constructors.
06:34:57 <koeien> or a "nested list"
06:35:11 <hpc> labo: yeah, i can't find anything either :(
06:35:17 <labo> hpc: It might be possible with custom userHooks or ./configure style.
06:35:27 <hpc> probably
06:35:31 <koeien> labo: blas is a package on hackage, but i doubt it actually ships fortran code
06:35:33 <labo> hpc: But I don't know anything about those
06:35:46 <koeien> labo: worth a look to make sure
06:35:59 <yasar> I guess that's why problem's title reads: Flatten a nested list structure.
06:36:28 <hpc> https://wewantarock.wordpress.com/2010/11/03/building-a-shared-library-in-cabal/
06:36:40 <labo> is there a way to search the package contents of all hackage packages for specific files?
06:36:43 <hpc> main = defaultMainWithHooks simpleUserHooks { confHook  = myConfHook, buildHook = myBuildHook }
06:36:55 <labo> i.e. *.f *.cpp or something like that
06:37:10 <sepp2k> yasar: Does the exercise not give you a definition of the data type you're supposed to use?
06:37:32 <yasar> no. Problem 7 in here: http://www.haskell.org/haskellwiki/99_questions/1_to_10
06:39:17 <sepp2k> yasar: Okay that indeed doesn't give a definition. However you can see from the example that the data type is supposed to have constructors List and Elem.
06:40:25 <sepp2k> So:  data NestedList a = List [NestedList a] | Elem a  and then  flatten :: NestedList a -> [a]
06:40:56 <yasar> ok, I will try it like that. Thanks.
06:49:48 <labo> hpc: thanks, it just might do. I would like a static library, so I'll see what I can do about that.
06:56:51 <mysticc> I have a data type data T = F A | G A B C .. to get A I have to write a function like this readA :: T -> A .. Is there any other practice which I should follow
07:00:18 <ClaudiusMaximus> mysticc: data T = T A T' ; data T' = F | G B C ..   perhaps?
07:00:49 <snhmib_> T = F { a :: A } | F { a :: A, b ::B } maybe
07:01:14 <snhmib_> err one of the F's should be G
07:01:41 <yasar> can someone check this? http://codepad.org/uZpmpSAJ
07:03:18 <sepp2k> yasar: In line 7 you're putting a value of type NestedList a into the list, but the list is supposed to hold values of type a, not NestedList a.
07:04:30 <k0ral> hi, I can't manage to use my own library through ghci
07:04:46 <yasar> How I am supposed to take value out of NestedList?
07:05:10 <k0ral> I "caball install" it, it exports MyLibrary.A, MyLibrary.B
07:05:36 <sepp2k> yasar: Just write a instead of Elem a
07:05:55 <k0ral> ok nvm I found the problem
07:06:37 <yasar> sepp2k: ohh, I thought a represented type of the Elem, not value.
07:07:46 <sepp2k> Huh? On line 7 the identifier a refers to the variable a bound by the pattern "Elem a" on that line.
07:08:01 <sipa> ~
07:09:03 <yasar> sepp2k: Concepts didn't sink in for me yet. I might be talking non-sense in any moment :)
07:10:00 <mysticc> How to check precedence of an operator
07:10:00 <yasar> And this still gives error: http://codepad.org/8MSCgxx4
07:11:32 <sepp2k> yasar: Ah, yes, b is a list of NestedLists, but flatten only takes a single NestedList. (I should have looked at the error message earlier...)
07:12:04 <koeien> mysticc: :info in ghci
07:12:18 <yasar> Should I change type signature, or ... some other thing.
07:13:14 <sepp2k> You should flatten each NestedList in b and then concatenate the results.
07:14:04 <yasar> umm, that is why I was calling flatten on b.
07:14:13 <hpc> no, flatten each ELEMENT of b
07:14:24 <hpc> > map f [x, y, z] -- let f = flatten
07:14:24 <lambdabot>   Ambiguous type variable `b' in the constraints:
07:14:25 <lambdabot>    `GHC.Show.Show b'
07:14:25 <lambdabot>      a...
07:14:31 <hpc> > map f [x, y, z] :: [Expr] -- let f = flatten
07:14:32 <lambdabot>   [f x,f y,f z]
07:14:42 <hpc> map flatten b
07:14:57 <hpc> then concat that... -- concat (map flatten b)
07:15:24 <hpc> b :: [NestedList]
07:15:36 <hpc> flatten :: NestedList -> [something]
07:15:43 <hpc> map flatten b :: [[something]]
07:15:58 <hpc> make sense?
07:16:14 <yasar> ohh, list is a LIST!  ---> greatest realization ever!
07:16:21 <hpc> ;)
07:16:48 <hpc> for extra credit, you can rewrite that with concatMap
07:16:50 <hpc> @src concatMap
07:16:50 <lambdabot> concatMap f = foldr ((++) . f) []
07:16:52 <hpc> er
07:17:05 <hpc> concatMap f xs = concat (map f xs) -- another definition
07:27:48 <mysticc> I have a type data T = T A T' ... and data T' = F | G B C ...  Now I have several operations on T which modify T' ... So I have to do a lot of case matchups for F and G .. I thought of declaring  a functor instance but I am a little confused as T does not have any type variable .. So should I add a pseudo type variable and write the functor instance ??
07:29:38 <adnauseam> u <*> pure y = pure ($ y) <*> u = pure <$> y <*> u ?
07:29:41 <parcs`> make a function T -> (T' -> T') -> T
07:29:43 <geekosaur> mysticc, to be able to fmap over T to get to the T', you would need to replace T' *in T* with a type variable
07:30:24 <koeien> mysticc: just write a catamoprhism
07:30:44 <hpc> :t \x -> pure ($ x)
07:30:45 <lambdabot> forall a b (f :: * -> *). (Applicative f) => a -> f ((a -> b) -> b)
07:30:48 <koeien> mysticc: mapT :: a -> (B -> C -> a) -> T' -> a
07:31:44 <koeien> cf. either, foldr, maybe
07:33:08 <adnauseam> hpc  - that confused a bit =P
07:33:29 <mysticc> koeien: still not clear on the type of mapT
07:33:44 <mysticc> hpc: Yeah ...confused here too :P
07:33:49 <mysticc> :t pure
07:33:50 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
07:34:01 <koeien> mysticc: so basically you write a function on each of the constructors
07:34:03 <koeien> so
07:34:44 <adnauseam> i'll rephrase my question ;p
07:34:45 <koeien> mapT a b c t' = case t' of F -> a; G x y z -> b x y z; C x -> c x
07:34:53 <koeien> mapT is a bad name.
07:35:30 <adnauseam> (u <*> pure y) is the same as (pure ($ y) <*> u), but is also the same as  (pure <$> y <*> u) ?
07:35:41 <mysticc> ok
07:36:33 <adnauseam> basically i think the question is: is <$> x equal to <$ x>
07:36:36 <adnauseam> ?
07:36:46 <koeien> <$ x> is nonsense
07:37:00 <koeien> (<$>) is the name of the function
07:37:19 <adnauseam> well it's in learn you a haskell :/
07:37:34 <adnauseam> it's oine of the laws of applicative functors
07:37:58 <adnauseam> the fourth one, stating that u <*> pure y = pure ($ y) <*> u
07:38:10 <adnauseam> i did confuse it there though, my bad
07:38:50 <adnauseam> :t ($) "a"
07:38:51 <lambdabot>     Couldn't match expected type `a -> b'
07:38:51 <lambdabot>            against inferred type `[Char]'
07:38:51 <lambdabot>     In the first argument of `($)', namely `"a"'
07:39:17 <hpc> :t ($) -- adnauseam
07:39:18 <lambdabot> forall a b. (a -> b) -> a -> b
07:39:39 <hpc> :t flip ($) -- because of how the section is written, ($) gets flipped
07:39:40 <lambdabot> forall a b. a -> (a -> b) -> b
07:39:48 <hpc> :t pure
07:39:48 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
07:40:16 <hpc> so now we have a -> (type of pure ($ x))
07:40:32 <hpc> or, a -> f ((a -> b) -> b)
07:40:47 <hpc> because (flip ($)) is partially applied
07:40:52 <adnauseam> hrm, that makes a bit more sense now
07:43:31 <adnauseam> hpc i think i got it :} thanks man
07:51:38 <covi> I'm curious, how do you learn Haskell at the begining? Lyah?
07:52:00 <covi> Or is there a different suggested tutorial?
07:52:30 <mysticc> :i $
07:52:39 <mysticc> :info $
07:52:58 <mysticc> How to check associativity of an operator
07:54:16 <geekosaur> you can't check it in lambdabot.   `:info ($)' should work in ghci
07:54:40 <koeien> covi: LYAH is fine.
07:54:53 <yasar> umm, still couldn't do it :S http://codepad.org/YaoXTBq2
07:54:57 <hpc> koeien: for very large values of "fine" :P
07:55:24 <koeien> covi: although i did not learn haskell from this book, i picked up a bit at university and other resources later
07:56:01 <covi> koeien: I'm trudging through lyah. But for now I think Haskell is really hard to learn.
07:58:50 <insomnia`> @pl (\x -> x)
07:58:51 <lambdabot> id
07:59:42 <insomnia`> @pl f (g a) b
07:59:42 <lambdabot> f (g a) b
08:00:01 <insomnia`> @pl (\a b -> f (g a) b)
08:00:01 <lambdabot> f . g
08:00:05 <hpc> covi: it is
08:00:19 <hpc> not really for being difficult to use though, but more because it's wildly different
08:01:12 <insomnia`> @pl \a b -> f (g b) a
08:01:12 <lambdabot> flip (f . g)
08:01:38 <hpc> @pl \a -> f (g a) a
08:01:38 <lambdabot> f =<< g
08:01:50 <hpc> (functions are strange)
08:02:38 <insomnia`> @pl \a b -> f a (g b)
08:02:38 <lambdabot> (. g) . f
08:03:08 <insomnia`> @unpl flip (flip f . g)
08:03:09 <lambdabot> (\ b c -> f b (g c))
08:03:32 <hpc> i wonder what the shorted @pl optimize loop you can write is
08:04:13 <insomnia`> @pl \a -> f0 (f1 a) (f2 a)
08:04:14 <lambdabot> liftM2 f0 f1 f2
08:04:44 <insomnia`> @pl \a -> f0 (f1 a) (f2 a) (f 3)
08:04:44 <lambdabot> flip (liftM2 f0 f1 f2) (f 3)
08:04:53 <insomnia`> @pl \a -> f0 (f1 a) (f2 a) (f3 a)
08:04:54 <lambdabot> ap (liftM2 f0 f1 f2) f3
08:05:18 <insomnia`> @pl \a -> f0 (f1 a) (f2 a) (f3 a) (f4 a)
08:05:19 <lambdabot> ap (ap (liftM2 f0 f1 f2) f3) f4
08:05:51 <hpc> aka f0 <$> f1 <*> f2 <*> f3 <*> f4
08:06:36 <ClaudiusMaximus> liftM4 ?
08:07:07 <insomnia`> @unpl f <$> g0 <*> g1 $ a
08:07:07 <lambdabot> (((f <$> g0) <*> g1) a)
08:12:00 <insomnia`> @pl \a -> f a (g a)
08:12:01 <lambdabot> ap f g
08:32:25 <gnoi> Is there any sleep function in haskell?
08:32:33 <gnoi> :google sleep
08:32:42 <gnoi> @google sleep
08:32:44 <lambdabot> http://en.wikipedia.org/wiki/Sleep
08:32:44 <lambdabot> Title: Sleep - Wikipedia, the free encyclopedia
08:32:46 <ClaudiusMaximus> @hoogle threadDelay
08:32:47 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
08:32:47 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
08:32:47 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
08:50:05 <insomnia`> @pl \a -> f a a (g a)
08:50:05 <lambdabot> ap (join f) g
08:50:18 <insomnia`> @pl \a -> f a a a (g a)
08:50:18 <lambdabot> ap (join (join f)) g
08:53:50 <parcs`> please /query lambdabot
08:55:56 <Tekmo> What's the correct package to use for free monads?  I found the "free" package and it seemed like the right one until I read a blog post by Edward saying that it was obsolete and he had moved it to comonads-fd, but that one doesn't have it anymore.
08:59:54 <ClaudiusMaximus> Tekmo: when was that blog post?  'free' was last uploaded quite recently (feb 7 this year)
09:00:10 <ClaudiusMaximus> (i don't know the answer to your question, sorry)
09:01:29 * hackagebot TCache 0.9.0.4 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.9.0.4 (AlbertoCorona)
09:04:55 <sonoflilit> Hi
09:05:07 <sonoflilit> I'm trying to learn FRP and reactive-banana
09:05:09 <koeien> hi sonoflilit
09:06:17 <sonoflilit> anyone know how to apply an IO action to a discrete
09:06:18 <sonoflilit> erm
09:06:49 <sonoflilit> as in, I have a timer event and I want a discrete that has a value that is the result of an IO action on every timer tick
09:08:21 <sonoflilit> ah, seems that fromPoll is relelvant, I'll read about it
09:16:30 * hackagebot typehash 1.4.0.4 - Create a unique hash value for a type.  http://hackage.haskell.org/package/typehash-1.4.0.4 (LennartAugustsson)
09:19:10 <Tekmo> The blog post in question was:
09:19:12 <Tekmo> http://comonad.com/reader/2011/free-monads-for-less/
09:19:22 <Tekmo> There he mentions the "free" package as being defunct
09:22:46 <insomnia`> @pl \a b -> f (g a) (g b)
09:22:46 <lambdabot> (. g) . f . g
09:23:06 <dolio> f `on` g
09:27:23 <insomnia`> @pl \a b -> f (g b) (g a)
09:27:23 <lambdabot> flip (f . g) . g
09:28:53 <Jafet> @pl \f g a b -> f (g a) (g b)
09:28:54 <lambdabot> join . ((flip . ((.) .)) .) . (.)
09:31:43 <insomnia`> @unpl \a b -> ((flip f) g . g) a b
09:31:44 <lambdabot> \ a b -> f (g a) g b
09:32:07 <insomnia`> @unpl \a b -> ((flip f g) . g) a b
09:32:07 <lambdabot> \ a b -> f (g a) g b
09:32:23 <insomnia`> @unpl flip ((. g) . f . g)
09:32:23 <lambdabot> (\ b c -> f (g c) (g b))
09:32:48 <dolio> \a b -> f (g b) (g a) = flip f `on` g
09:32:49 <mm_freak> is there a tutorial on free monads for the CT non-expert?
09:35:28 <dolio> I wrote this a while back: http://www.haskell.org/haskellwiki/Free_structure
09:35:41 <Tekmo> The way I think of it
09:35:45 <dolio> I don't know how good it is.
09:35:51 <Tekmo> A free monad is like a list of functors
09:36:15 <Tekmo> data Free f r = Pure r | Free (f (Free f r))
09:36:21 <Tekmo> Pure is Nil and Fre is Cons
09:37:38 <pasokan> help
09:37:51 <pasokan> quit
09:37:56 <hpc> in fact, Free ((,) e) () is isomorphic to [e]
09:38:06 <Tekmo> Yeah
09:41:41 <mm_freak> dolio: thanks
09:41:55 <mm_freak> Tekmo: i got that, but i'm still figuring out where that would be useful
09:42:06 <Tekmo> Well
09:42:15 <Tekmo> I found it useful when making my pipes library
09:42:34 <Tekmo> Pipes are a free monad over the following functor:
09:42:59 <Tekmo> data PipeF a b m r = Await (a -> r) | Yield (b, r) | M (m r)
09:43:06 <Tekmo> type Pipe a b m r = Free (PipeF a b m) r
09:43:25 <Tekmo> The free monad lets you essentially reify each step of the computation
09:43:39 <Tekmo> An ordinary monad forces you to combine computational steps irreversibly
09:43:49 <Tekmo> But a free monad lets you suspend the combination so you can manipulate them further beforehand
09:46:13 <mm_freak> thanks for the explanation
09:46:30 * hackagebot histogram-fill-cereal 0.6.0.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-cereal-0.6.0.0 (AlexeyKhudyakov)
09:46:40 <BMeph> Does anyone know of a person/institution that concentrates on studying VM/runtime systems?
09:53:34 <osa1> I'm reading simon marlow's "writing high-performance servers in haskell" and it's written here that concurrent haskell can't take advantage of multiple cores at the time the article is written, is it same now?
09:54:01 <mauke> link?
09:54:21 <geekosaur> multiple cores are supported now, yes
09:55:05 <osa1> geekosaur: thanks. where can I learn more about concurrent haskell? do we have good articles/papers/etc about it's usage?
09:56:29 <serialhex> ok, so i'm new here, what exactly does lambdabot do?  i see some ppl writing some functions, and lambdabot respond....  but what is it doing??  (i'm new to haskell too)
09:56:59 <ClaudiusMaximus> osa1: http://www.haskell.org/haskellwiki/Parallel has some links, check out the parallel haskell digest series, plenty of good stuff there
09:57:20 <osa1> ok, thank
09:57:30 <mm_freak> note the difference between concurrent and parallel
09:57:41 <mm_freak> concurrent programming as in servers has little to do with parallel programming
09:57:48 <geekosaur> (thank you, I was trying t scrape stuff together but I;m no expert)
09:57:54 <alpounet> serialhex, lambdabot evaluates what people feed it
09:58:00 <alpounet> > 2+3
09:58:00 <lambdabot>   5
09:58:57 <serialhex> alpounet: ahh... ok! thanks!!!
10:01:46 <insomnia`> @pl \a -> f (g a) (g b)
10:01:46 <lambdabot> flip f (g b) . g
10:01:59 <insomnia`> @pl \a -> f (g a) (g a)
10:02:00 <lambdabot> liftM2 f g g
10:02:05 <milord80> !lista
10:02:09 <milord80> !list
10:02:24 <alpounet> @list
10:02:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:02:58 <insomnia`> @unpl liftM2 f g g
10:02:58 <lambdabot> (g >>= \ b -> g >>= \ a -> return (f b a))
10:03:15 <insomnia`> @unpl liftA2 f g g
10:03:16 <lambdabot> liftA2 f g g
10:13:21 <insomnia`> 'f `on` g' is more restricted than '(. g) . f . g'.
10:43:19 <JOHNYY> http://www.wix.com/jetomestil/hot-ass-collection THE HOTTEST ASS IN THE WORLD---MUST WATCH
11:02:11 <hrdinka> hi guys, is someone here who is familiar with flemmih's acid-state
11:02:31 <hrdinka> lemmih's indeed^^
11:09:23 <dp1313> hello
11:14:35 <kodoque> hi
11:21:05 <kodoque> :t unwords . words
11:21:08 <lambdabot> String -> String
11:21:11 <kodoque> hmm
11:21:34 * hackagebot zlib-bindings 0.1.0.1 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.1.0.1 (MichaelSnoyman)
11:26:53 <byorgey> hi kodoque
11:28:22 <Mathnerd314> so when is the next darcs release?
11:30:41 <jmcarthur> what new features will there be?
11:31:02 <byorgey> Mathnerd314: dunno, ask in #darcs
11:31:24 <Mathnerd314> jmcarthur: updated version number :p
12:15:44 <query> anyone could tell me what : parse error on input '='..... means????????
12:16:15 <mauke> yes!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
12:16:31 <HugoDaniel> :)
12:17:58 <DMcGill> query: we need to look at your code - put it on hpaste.org
12:18:12 <sepp2k> query: It means you have a = where the parser didn't expect it. That either means that the = is somewhere where it doesn't belong or that there's a syntax error somewhere before the =.
12:19:10 <hpaste> Query pasted “Haskell query” at http://hpaste.org/65895
12:20:10 <DMcGill> I thought hpaste ran the code and reported compiler errors?
12:20:31 <BMeph> Is there an explanation somewhere on why we have universal quantification, and not/instead of, existential?
12:21:35 * hackagebot options 0.1 - Parsing command-line options  http://hackage.haskell.org/package/options-0.1 (JohnMillikin)
12:21:37 * hackagebot yoko 0.3.2 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-0.3.2 (NicolasFrisby)
12:21:48 <deej_> How do I add snap to my $PATH on OSX?
12:21:52 <deej_> sorry I'm so noob
12:22:15 <deej_> cabal is there, but bash can't find snap
12:22:21 <hrdinka> edit your shells profile/rc file
12:22:29 <nicmo> BMeph: I think you can read the unversal as "for all types such that..." which could also mean as "if there exists types such that..."
12:22:44 <hrdinka> dej_: put somthing like
12:22:48 <nicmo> so maybe having both universal and existential would not make much sense
12:22:54 <deej_> where do I find my shells profile file?
12:22:58 <byorgey> query: seems like perhaps your indentation is wrong
12:23:05 <hrdinka> dej_: export PATH=$PATH:~/.cabal/bin
12:23:17 <DMcGill> query: the first problem is indentation - lines 11,12 and 13 need to be indented further to the right
12:23:25 <byorgey> query: in particular lines 11-13 need to be indented, and the 'where' on line 17 needs to be indented
12:23:44 <byorgey> query: also, which line is the error on?
12:23:50 <hrdinka> dej_: i am not shure where it is on mac os x, type ls -a in your home folder to list all hidden files
12:24:06 <byorgey> query: (generally, it's a good idea to paste the error message along with the code)
12:24:22 <DMcGill> byorgey: I ran the code and fixing the indentation fixes the parse error
12:24:31 <DMcGill> there's still other errors ofc
12:24:34 <byorgey> nicmo: no, universal and existential are not the same
12:24:36 <deej_> I tried export PATH=$PATH:~/.cabal/bin, but snap init barebones still does not work
12:24:38 <byorgey> nicmo: however they are dual
12:24:41 <deej_> I think that is for linux machines
12:24:42 <nicmo> BMeph: "Some people forall should be there exists, but both views are valid: forall s, there is a constructor such that... vs. if you destruct _, there exists an s such that..."
12:24:54 <nicmo> byorgey: I know they are not
12:24:54 <hrdinka> dej_: it should be at ~/.profile
12:25:03 <nicmo> byorgey: I was quoting my professor on that one
12:25:09 <byorgey> ok
12:25:13 <deej_> export PATH=$PATH:~/.profile ?
12:25:26 <hrdinka> nope
12:25:38 <deej_> export PATH=$PATH:~/.cabal/.profile?
12:25:50 <byorgey> BMeph: UHC has exists IIRC
12:26:03 <hrdinka> dej_: echo "export PATH=$PATH: ~/.cabal/bin" >> ~/.profile
12:26:18 <deej_> export PATH=~/.profile
12:26:22 <deej_> ?
12:26:33 <hrdinka> dej_: echo "export PATH=$PATH: ~/.cabal/bin" >> ~/.profile
12:26:46 <nicmo> also, I accidentally a verb on quoting
12:26:57 <nicmo> s/on/when
12:27:05 <hrdinka> dej_: this will create a .profile if not present and add ~/.cabal/bin to your path
12:27:39 <deej_> when I type in "~/.profile" I get "No such file or directory"
12:28:11 <hrdinka> dej_: you don't have one by default
12:28:17 <deej_> what command should I prefix with?
12:28:45 <monochrom> cat ~/.profile
12:29:19 <hrdinka> dej_: have you already tried my above snipped?
12:29:23 <hrdinka> dej_: echo "export PATH=$PATH: ~/.cabal/bin" >> ~/.profile
12:32:22 <elliott> hrdinka: It doesn't have to be in ~/.profile for a single shell.
12:32:41 <elliott> deej_ said they tried "export PATH=$PATH:~/.cabal/bin" and it still doesn't work, so I don't think adding it to ~/.profile would help.
12:33:01 <hrdinka> dej_: you have to reload your profile file
12:33:08 <deej_> how do I reload it
12:33:19 <hrdinka> dej_: source ~/.profile, or fire up a new terminal
12:33:24 <deej_> when I echo $PATH I don't see ~/.cabal/bin
12:34:01 <deej_> when I type "source ~/.profile " I get "-bash: export: `/Users/Raphael/.cabal/bin': not a valid identifier "
12:34:05 <Chaze> shot in the dark: has anyone got to work the SDL bindings for windows?
12:34:15 <elliott> deej_: Please http://hpaste.org/ the entire contents of your .profile file.
12:34:31 <elliott> (cat ~/.profile as monochrom said)
12:35:25 <hpaste> Deej pasted “Contents of deej's ~/.profile” at http://hpaste.org/65897
12:35:31 <deej_> ok I hpasted
12:35:41 <hrdinka> oh
12:35:48 <elliott> deej_: Okay, well, the problem is the space, and also that you have three duplicate lines.
12:35:50 <elliott> hrdinka's line was wrong.
12:35:54 <deej_> oh, cabal is there
12:35:59 <elliott> It's not.
12:36:04 <elliott> The space is messing it up.
12:36:12 <hrdinka> dej_: now it is there, escape it with quotes
12:36:16 <elliott> Remove the duplicate lines and the space before ~/.cabal, save, and open a new terminal.
12:36:28 <elliott> hrdinka: What? No!
12:36:32 <hrdinka> and remove the space
12:36:34 <deej_> how do I do that, where is the file on my HD
12:36:37 <hrdinka> ^^
12:36:45 <elliott> deej_: .profile in your home directory.
12:36:58 <elliott> You might have to "show hidden files" or such, I forget how to do it in OS X.
12:37:00 <hrdinka> thought there was another space^^
12:37:01 <elliott> You might want to use a command-line editor like vi or nano if you can't find it.
12:37:23 <deej_> ah yea  the show hidden files worked
12:37:30 <hrdinka> dej_: or simple do
12:37:36 <hrdinka>  echo "export PATH=$PATH:~/.cabal/bin" > ~/.profile
12:37:38 <deej_> so just remove that space?
12:37:55 <hrdinka> dej_: this replaces the existing .profile
12:38:24 <deej_> echo "export PATH=$PATH:~/.cabal/bin" > ~/.profile <-- Doesn't work
12:38:45 <deej_> I used textmate
12:39:43 <deej_> This is my file
12:39:44 <deej_> export PATH=/Library/Frameworks/Python.framework/Versions/2.7/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/git/bin:/usr/X11/bin:~/.cabal/bin
12:39:57 <deej_> is this still wrong?
12:40:01 <hrdinka> seems right
12:40:05 <ClaudiusMaximus> maybe ~ isn't expanded, try absolute path
12:40:29 <hrdinka> but better put export PATH=$PATH:(path to home)/.cabal/.bin in there
12:41:09 <elliott> ~ is expanded at least on Linux IIRC
12:41:12 <elliott> Wait.
12:41:14 <elliott> Duh.
12:41:18 <elliott> ~/.cabal isn't used on OS X, is it?
12:41:24 <elliott> It's ~/Library/Haskell/bin or something stupid like that.
12:41:26 <query> :DMcGill what u mean the problem is the indentation ?
12:41:50 <elliott> deej_: Try changing ~/.cabal/bin to $HOME/Library/Haskell/bin
12:41:56 <elliott> And remember to open a new terminal to test it.
12:42:24 <hrdinka> haskell wiki says it is .cabal
12:42:26 <deej_> Elliot gets the bounty
12:42:26 <sepp2k> query: He means exactly that. Your code is indented incorrectly.
12:42:27 <hrdinka> http://www.haskell.org/haskellwiki/Mac_OS_X
12:42:27 <deej_> export PATH=$HOME/Library/Haskell/bin
12:42:29 <DMcGill> query: things in a do block (lines 11,12 and 13) have to start at the same place. Try putting 4 spaces before each of those lines
12:42:35 <deej_> export PATH=$HOME/Library/Haskell/bin
12:42:39 <deej_> did it
12:42:41 <elliott> deej_: Er.
12:42:42 <deej_> there is no .cabal
12:42:48 <elliott> That's a supremely unwise thing to put in your ~/.profile.
12:42:52 <hrdinka> your line is wrong
12:42:59 <elliott> That means you will not be able to execute any commands that aren't cabal-installed.
12:42:59 <deej_> well it works...
12:43:03 <elliott> No, it does not work.
12:43:05 <hrdinka> it replaces the whole PATH
12:43:11 <deej_> so I should just export
12:43:14 <elliott> export PATH=/Library/Frameworks/Python.framework/Versions/2.7/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/git/bin:/usr/X11/bin:$HOME/Library/Haskell/bin
12:43:20 <hrdinka> it should just append to it
12:43:23 <hrdinka> ok
12:43:45 <elliott> deej_: Actually better to make it:
12:43:51 <elliott> export PATH=$HOME/Library/Haskell/bin:$PATH
12:43:52 <hrdinka> export PATH=$PATH:$HOME/Library/Haskell/bin
12:43:55 <elliott> That way it'll work even if the system PATH changes.
12:43:57 <hrdinka> would be better
12:44:04 <ski> BMeph : i think having `exists' as well would be useful .. there are some problems that need to be solved in some way, though
12:44:40 <ski> nicmo : sounds like your professor maybe was talking about how `forall a. Foo a -> Bar' is isomorphic to `(exists a. Foo a) -> Bar'
12:45:09 <deej_> thanks a ton guys
12:45:12 <deej_> you guys rock
12:45:19 <nicmo> ski: yep
12:45:28 <deej_> big thanks elliot and hrdinka
12:45:29 <nicmo> it is much clearer putting it that way
12:45:31 <nicmo> :D
12:46:07 <elliott> length :: (exists a. [a]) -> Int -- much clearer!
12:46:24 <nicmo> bleh
12:46:26 <ski> nicmo : anyway, having both of them would make sense and be useful
12:46:58 <nicmo> ski: would that cover any other case not covered in your example?
12:47:33 <ski> elliott : yes, now consider `join (***) length :: (exists a. [a],exists b. [b]) -> (Int,Int)', vs. the current `join (***) length :: forall a. ([a],[a]) -> (Int,Int)'
12:48:29 <ski> nicmo : it would cover uses of `exists' in covariant position, like `frob :: Foo -> exists a. Bar a', and `zot :: forall a. Bar a -> exists b. Baz a b'
12:49:05 <elliott> ski: Yes, sure, I was just objecting to the idea that "forall a. Foo a -> Bar" is less readable than "(exists a. Foo a) -> Bar".
12:49:10 <elliott> Or maybe nicmo was saying the opposite. Oh well.
12:49:22 <elliott> ski: Anyway, are you sure that first type of "join (***) length" can be inferred?
12:54:13 <nicmo> ski: interesting... haven't thought of that
12:54:51 <nicmo> elliott: and I think you got the idea precisely
12:54:55 <nicmo> :D
12:56:24 * elliott thinks data SomeList = SomeList (exists a. [a]) is clearer than data SomeList = forall a. SomeList [a].
12:56:32 <elliott> Compare data SomeList = SomeList (forall a. [a]).
12:56:47 <edwardk> elliott: the problem is that what do you do when the exists needs to extend over multiple fields?
12:57:06 <edwardk> elliot :: data SomeList where SomeList :: [a] -> SomeList -- is even clearer ;)
12:57:12 * byorgey thinks  data SomeList where  SomeList :: [a] -> SomeList   is clearer than both
12:57:21 * byorgey high-fives edwardk 
12:57:26 <edwardk> @stereo
12:57:26 <lambdabot> Unknown command, try @list
12:57:28 <edwardk> bah
12:57:58 <edwardk> =)
12:59:11 <elliott> edwardk: Yeah, the GADT syntax is the way to go.
12:59:31 <ski> elliott : well, i'm wondering if one could have `gronk :: Foo a -> Bar' being shorthand for `gronk :: (exists a. Foo a) -> Bar', instead of `gronk :: forall a. Foo a -> Bar'
12:59:52 <elliott> ski: What is {gronk :: Foo a -> Foo a} shorthand for?
13:00:13 <hpaste> timthelion pasted “what the???” at http://hpaste.org/65898
13:00:37 <timthelion> It seems I fail at installing just about everyting :(
13:01:01 <ski> elliott : `gronk :: forall a. Foo a -> Foo a' (assuming `a' isn't already bound), of course
13:01:08 <elliott> timthelion: That library is out of date.
13:01:19 <elliott> timthelion: You will probably be happiest simply not installing it.
13:01:31 <elliott> Hmm, yet it was released in 2012?
13:01:32 <elliott> Strange.
13:01:43 <elliott> timthelion: ghc --version?
13:02:04 <timthelion> elliot: ghc 7.4.1
13:02:36 <timthelion> elliott, I'm not happy at all, I cannot install anything.  9 out of 10 packages that I try don't install.
13:02:44 <elliott> timthelion: Yes. The problem is that you're using GHC 7.4.1.
13:02:52 <elliott> It's still fairly experimental. Many packages don't work without hackery.
13:03:00 <elliott> Unless you're an expert, trash it and install the Haskell Platform, which uses GHC 7.0.4.
13:03:08 <elliott> Then you'll be happy :)
13:03:49 * timthelion wonders what the appropriet method of doing that on arch is.  And whether he might not just send a bug report to the arch devs to roll back the ghc package...
13:04:17 <elliott> Oh.
13:04:31 <elliott> It's Arch, they don't decrease versions, breakage be damned.
13:04:54 <elliott> timthelion: Uninstall GHC, download the GHC 7.0.4 binary distribution, install it, then install cabal-install.
13:04:54 <DaveNull> i'm afraid that, on Arch, you have to download plateform from haskell.org and build/install it in /opt or something
13:05:11 <elliott> No point doing the platform if you're going from source.
13:05:58 <ski> elliott : "Anyway, are you sure that first type of \"join (***) length\" can be inferred?" -- no, but i think/hope so
13:06:27 <elliott> ski: I seem to recall reading once that you can't infer such things.
13:06:40 <timthelion> and the cabal stuff, I have to remove any packages I've cabal installed with the new version of ghc?
13:06:51 <elliott> timthelion: Oh, yes.
13:07:22 <elliott> ski: The problem is that join (***) is essentially being used with the type ((a -> r) /\ (b -> r)) -> (a,b) -> (r,r), no?
13:07:27 <timthelion> deleting .cabal enough?
13:07:31 <elliott> timthelion: ~/.ghc too
13:07:37 <timthelion> I never did install global
13:07:38 <elliott> ski: And you can't do inference if you let that /\ in.
13:07:39 <timthelion> OK
13:07:42 <timthelion> thank you
13:07:52 <elliott> timthelion: Then http://www.haskell.org/ghc/download_ghc_7_0_4#binaries. And no problem :)
13:08:05 <elliott> Oh, you'll also want to uninstall cabal-install if you got it from Arch.
13:08:13 <adnauseam> why newtype Pair b a = Pair { getPair :: (a,b) }
13:08:19 <elliott> When you do get GHC installed, download http://hackage.haskell.org/packages/archive/cabal-install/0.10.2/cabal-install-0.10.2.tar.gz and run ./bootstrap.sh.
13:08:21 <adnauseam> why not newtype Pair a b = Pair { getPair :: (a,b) }
13:08:30 <adnauseam> is there a difference ?
13:08:32 <ski> @type join (***)
13:08:33 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
13:08:34 <elliott> adnauseam: Yes.
13:08:42 <elliott> adnauseam: Pair a b is (b,a) with the first one.
13:08:43 <ski> @type \f a -> join (***) f a
13:08:43 <lambdabot> forall b c. (b -> c) -> (b, b) -> (c, c)
13:08:45 <elliott> Pair a b is (a,b) with the second one.
13:09:00 <elliott> ski: Yes, but the point is that it's using its argument at two types.
13:09:09 <elliott> Hmm.
13:09:12 <timthelion> thank you elliott
13:09:15 <elliott> I guess you can do that even with just standard rank-2 stuff.
13:09:27 <elliott> But that bolsters my intuition that you can't infer it.
13:09:29 <adnauseam> elliott: it seems that the opposite is done with the newtype def
13:10:23 <elliott> adnauseam: Well, you pointed out the difference yourself.
13:10:30 <ski> elliott : in `forall b c. (b -> c) -> (b, b) -> (c, c)', `b' would be instantiated `exists a. [a]', and `c' to `Int'
13:10:35 <elliott> First one = newtype Pair onething anotherthing = Pair { getPair :: (anotherthing, onething) }
13:10:42 <elliott> Second one = newtype Pair onething anotherthing = Pair { getPair :: (onething, anotherthing) }
13:10:45 <elliott> The first one is flipped.
13:11:19 <hpc> in a sense, Pair = Flip (,)
13:11:42 <adnauseam> elliott: hmm, the thing is i don't know /why/ it is different :p
13:11:59 <adnauseam> like, for what purpose was it done in reverse when it's not supposed to0 be in reverse
13:12:18 <timthelion> I wonder what happens when I uninstall xmonad while xmonad is running.
13:12:25 * timthelion tries it
13:12:41 <hpc> timthelion: the program stays in memory until you close it; xmonad is pretty self-contained
13:14:00 <timthelion> hpc: We'll see.  It does do the weird recompile thing after all.
13:14:01 <Zamarok> this is true, I did that accidentally once, and then rebooted.. Xorg wouldn't until I reinstalled Xmonad
13:14:23 <Zamarok> wouldn't start*
13:14:27 <elliott> adnauseam: Well, I don't know the purpose. You just quoted a definition without linking any source or anything :)
13:15:08 <timthelion> Zamarok: well that's different.  And I actually run two xsessions.  One with gnome3(for things like magnification, and better handling of automization of sd cards, networking, projectors ect.  and one with xmonad.
13:15:49 <Zamarok> timthelion: why not run Xmonad on top of Gnome? I read that you can.. I run it on top of XFCE
13:16:22 <antonh> i have a tuple (Maybe a, Maybe b) and want a function that returns [a], [b] or [a, b]. how do does such a function look like?
13:16:23 <timthelion> Zamarok: you can do so on top of gnome-fallback, but then magnification no longer works.
13:16:49 <timthelion> it's not very stable either.  Not in that it crashes, but certainly random floating windows appear, and you get weird behavior.
13:17:02 <Zamarok> ahh, bummer :/
13:17:37 <DMcGill> antonh: a function can only return one type, you need to either pick one or use something like Either to combine them into one.
13:18:11 <ski> @type maybeToList *** maybeToList
13:18:11 <lambdabot> forall a a1. (Maybe a, Maybe a1) -> ([a], [a1])
13:18:20 * timthelion takes that back.  Last tried xmonad with gnome years ago.
13:18:39 <timthelion> magnification is the main issue...
13:19:14 <monochrom> perhaps your tuple is (Maybe a, Maybe a)
13:19:16 <osa1> what is the name of ! operator(or notation or whatever) ?
13:19:46 <Zamarok> osa1: do you mean (!!) ?
13:19:47 <ski> osa1 : (a) array indexing; or (b) strictness annotation
13:19:55 <antonh> ski, maybeToList is what I wanted, thank you
13:20:02 <deej_> hey guys
13:20:05 <deej_> I'm trying to install yesod
13:20:10 <deej_> and getting this
13:20:11 <deej_> cabal: Error: some packages failed to install: yesod-0.10.2 depends on yesod-form-0.4.2.1 which failed to install. yesod-auth-0.8.1.1 depends on yesod-form-0.4.2.1 which failed to install. yesod-form-0.4.2.1 failed during the building phase. The exception was: ExitFailure 1
13:20:17 <ski> antonh : yw :)
13:20:19 <deej_> I mean, build a yesod project
13:20:25 <osa1> ski: strictness annotation, thakns
13:20:29 <deej_> should I try the yesod platform?
13:21:28 <maloi>  deej_ there's #yesod
13:21:51 <hpc> deej_: you can also scroll up in the output of cabal until you see where the error is
13:22:18 <nand`> Is there an elegant way to randomly generate a specified length list of numbers without duplicates?
13:22:32 <nand`> Other than simply retrying
13:22:33 <elliott> > let len = 42 in [0..len]
13:22:34 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:22:35 <deej_> thanks
13:22:44 <elliott> oh, "randomly"
13:22:50 <elliott> well, you can never be sure :)
13:22:50 <deej_> let fact x = product [0..x]
13:22:53 <deej_> fact 5
13:23:03 <deej_> lambdabot fact 5
13:23:06 <deej_> :(
13:23:18 <deej_> product [1..x] :) oops
13:23:27 <hpc> > let fact x = product [1..x] in fact 5 -- gotta be on one line, starting with "> "
13:23:28 <lambdabot>   120
13:23:45 <ski> @let factorial x = product [1 .. x]
13:23:47 <monochrom> use a random shuffling algorithm. there are imperative ones and functional ones
13:23:49 <lambdabot>  Defined.
13:23:49 <ski> > factorial 5
13:23:52 <lambdabot>   120
13:24:08 <nand`> monochrom: that sounds like a good idea
13:24:09 <monochrom> Knuth TAOCP volume 2 has an imperative one. Oleg has both.
13:24:22 <nand`> Oleg has everything
13:26:49 <timthelion> Anyone else have the fealing that cabal is encouraging the increadibly bad practice of having user space executables?  (therefore it's practically like you are running as root)
13:27:48 <hpc> timthelion: uh... what's wrong with user-space executables? they don't run as root
13:29:03 <timthelion> hpc: key loggers which send the data to a 3rd party server, and interact with removable media and do all the other things that the user / root destinction is meant to prevent :D
13:29:06 <elliott> That's a strange definition of "incredibly bad practice".
13:29:16 <elliott> timthelion: What has that got to do with having executables in $HOME?
13:29:30 <elliott> What you install in your own $HOME is your own choice and responsibility.
13:29:35 <hpc> timthelion: you need root to do any of those things
13:29:53 <hpc> which you can't have with just programs saved in $HOME
13:29:54 <elliott> (Well, no, you don't. X lets basically anyone log keys.)
13:30:02 <elliott> (But it's irrelevant.)
13:30:06 <timthelion> hpc: actually you don't, a user level program can grab X's keyboard, and send the results to a server
13:30:16 <elliott> timthelion: and how does cabal promote that?
13:30:24 <elliott> installing things into /usr with cabal would have exactly the same risk
13:30:30 <timthelion> elliott: by installing executables to $HOME
13:30:31 <elliott> the risk here is "installing software you don't trust"
13:30:34 <elliott> the solution is "don't do that"
13:30:46 <elliott> timthelion: no, that doesn't enable that in any shape or form, there is nothing about installing into $HOME that makes keyloggers more possible or likely
13:30:53 <timthelion> elliott: no, because to some extent we expect hackage to be trusted.
13:31:05 <elliott> fine, then don't worry
13:31:06 <geekosaur> timthelion, pretty much every OSS package ut there is an incredibly bad practice by your theory
13:31:12 <elliott> $HOME is still irrelevant
13:31:56 <timthelion> $HOME is more likely to contain non trusted files which should not be executed.
13:32:31 <hpc> aaaaaand, cabal is encouraging this how?
13:32:44 <elliott> your argument is a complete non sequitur.
13:32:53 <hpc> it's not like you need cabal to wget warez.com/pornbunnies.exe
13:33:00 <timthelion> hpc: It encourages you to execute files which are in non trusted user space :D
13:33:11 <elliott> timthelion: so if cabal made you put "sudo" before installing things
13:33:15 <elliott> it would be _safer_?
13:33:32 <elliott> you're arguing that giving cabal _root privileges_ rather than _user privileges_ would promote better security practices
13:33:45 <timthelion> elliott: No, it would be safer if it didn't store executables in $HOME
13:33:51 <elliott> if / is trusted and $HOME is not, then it is promoting _better_ security practices this way
13:33:58 <elliott> by not giving you a false sense of security
13:34:04 <elliott> timthelion: how the heck would that be safer?!
13:35:08 <mmaruseacph2> hello
13:35:13 <staufinc> hi
13:35:21 <mmaruseacph2> does anyone know when the next haskell platform will be availbale for arch?
13:35:36 <elliott> arch is on a higher version of ghc than the latest haskell platform.
13:35:43 <mmaruseacph2> true :)
13:35:44 <elliott> so it will be after the next haskell platform comes out, if they are interested in supporting it atall.
13:36:01 <mmaruseacph2> ah, there is no haskell platform right now :)
13:36:04 <mmaruseacph2> understood
13:36:12 <timthelion> Well, the current method really isn't very safe.  It's possible for an executable to slip into .cabal and then get executed.  For example, if I send you a zip file full of pictures, and a .cabal folder and myevilexe... And you use xarchiver to unpackage it to home(xarchiver doesn't make new folders for their packages) I can potetially get my evil program excecuted without your knowing.
13:36:31 <hpc> mmaruseacph2: you can still install ghc and the libraries that come with the platform
13:36:37 <mmaruseacph2> what needs to be done to get the next haskell plaftorm ready?
13:36:39 <hpc> and call it close enough
13:36:58 <mmaruseacph2> hpc, yes, but i don't know all of them and installing them on requirement basis does not suffice
13:37:08 <hiptobecubic> is there a way defeat disgusting dependency problems using cabal?
13:37:09 <elliott> mmaruseacph2: installing them on requirement basis is a nicer experience than using the platform
13:37:15 <elliott> hiptobecubic: no, but you can localise them with cabal-dev
13:37:25 <mmaruseacph2> for example I was today in a place with no internet connection and needed to use GtkHs but it wasn't installed
13:37:33 <mmaruseacph2> 4 hours of productivity lost
13:37:44 <elliott> mmaruseacph2: good news: the Platform doesn't include gtk2hs
13:37:47 <elliott> :P
13:37:48 <mmaruseacph2> elliott, true that
13:37:52 <hiptobecubic> elliott, what do you mean?
13:37:57 <mmaruseacph2> aah, so i'll still have to do this by hand
13:38:05 <elliott> mmaruseacph2: installing a few common libraries will get you the majority of the platform, really.
13:38:19 <mmaruseacph2> oki, will do this
13:38:22 <elliott> hiptobecubic: with cabal-dev, cabal dependency problems only affect one project, and can be fixed without having to manually reinstall everything
13:38:29 <hiptobecubic> elliott, ah it make sandboxes. ok that's good enough i guess
13:38:36 <antonh> ehm. i have another beginners question. if i have data Point = Point Float Float how do i convert [(Float, Float)] to [data Point]?
13:38:59 <mmaruseacph2> hlint, mtl, gtkhs, array, arrows, vector
13:39:08 <mmaruseacph2> those are the ones I;m thinking about right now
13:39:11 <bitonic> antonh: map (uncurry Point)
13:39:17 <timthelion> gtkhs is different from gtk2hs?
13:39:34 <mmaruseacph2> gtk2hs
13:39:34 <elliott> gtkhs doesn't exist.
13:39:39 <mmaruseacph2> forgot the 2
13:40:08 * timthelion wants to make a gtkhs just to confuse people ^_^
13:40:24 <mmaruseacph2> back to coding :), hlint got installed
13:40:40 <antonh> bitonic, cool. thank you
13:41:02 <bitonic> antonh: you might want to figure out how that works if you're a beginner :)
13:41:56 <antonh> i've looked at the type for uncurry
13:42:21 <bitonic> yeah, look at the type for 'Point' too. Every constructor is a function, in case you didn't know
13:42:29 <bitonic> well, every constructor with arguments.
13:43:13 <antonh> i didn't know that. good to know :)
13:43:54 <antonh> at least i got some sense about what curried functions are :)
13:43:55 <mmaruseacph2> should i use cabal to install individual libraries or the system's packaging method?
13:43:59 <elliott> mmaruseacph2: cabal
13:44:14 <mmaruseacph2> thanks :)
13:44:35 <hpaste> timthelion pasted “Cannot install binary ghc” at http://hpaste.org/65903
13:45:49 <timthelion> elliott: I'm having no luck with the binary ghc.  I get an error message on ./configure
13:46:57 <DaveNull> timthelion, Arch is now at libgmp.so.10 :(
13:47:27 <DaveNull> i think you'll have to build yourself your binary
13:47:43 <elliott> timthelion: hpaste
13:47:46 <elliott> oh, right, that thing
13:47:50 <elliott> you can install the old gmp from AUR
13:47:51 <timthelion> grrrr :(
13:47:56 <elliott> less headache than building ghc
13:48:43 <watermind> So I cannot make a derived instance because the constructor is not H98
13:48:46 <mmaruseacph2> last question for today: if I use cabal can I setup it to install packages to a directory of my choosing?
13:48:55 <mmaruseacph2> something like /data/cabal-pkgs?
13:48:58 <watermind> and it suggests, Possible fix: use a standalone deriving declaration instead
13:49:16 <watermind> what does that mean? standalone deriving declaration?
13:49:29 <timthelion> According to google "Okay fixed it with sudo ln -s /usr/lib/libgmp.so.10.0.1 /usr/lib/libgmp.so.3 "  I wonder if that's not worth a try :)
13:49:43 <Dodek> hello
13:49:44 <mmaruseacph2> timthelion, that should work
13:49:57 <mmaruseacph2> I fixed the python3 versus python2 issue by using that
13:50:18 <Dodek> http://hackage.haskell.org/package/kan-extensions -- could anyone explain to me what this package is for? assume i know category theory etc.
13:50:22 <bitonic> watermind: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
13:50:32 <watermind> thank you bitonic
13:50:42 <elliott> Dodek: edwardk is your man
13:50:42 <c_wraith> Dodek: its author is edwardk, who's around right now
13:50:49 <elliott> and don't worry, he assumes everybody knows category theory ;)
13:51:08 <watermind> Ah nice
13:51:10 <Dodek> ah, thanks
13:51:11 <Dodek> edwardk, hi, you there?
13:51:30 <edwardk> yes
13:51:47 <Dodek> edwardk: what for is kan-extensions package?
13:51:51 <edwardk> assuming you know category theory?
13:51:54 <Dodek> yeah
13:52:02 <edwardk> a right kan extension works like a generalization of continuation passing style
13:52:19 <edwardk> when you apply it to endofunctors over the category of haskell types
13:52:44 <edwardk> i wrote a series of blog posts on the use of kan extensions in Haskell
13:52:48 <edwardk> have you seen them?
13:53:00 <Dodek> oh, you have a blog? no, i haven't seen them
13:53:04 <Dodek> could you give me an url?
13:53:19 <edwardk> In particular I can use codensity (which is just the right kan extension of a functor along itself) to asymptotically improve the performance of code that uses free monads
13:53:23 <edwardk> comonad.com
13:53:42 <edwardk> the posts in question are: kan extensions i - iii, and then a series that started up later on 'free monads for less'
13:53:55 <Dodek> cool
13:54:03 <Dodek> do you work in academia?
13:54:11 <edwardk> Control.Comonad.Density is the density comonad given by the left kan extension of a functor along itself
13:54:19 <edwardk> no, i build tools for quants
13:54:26 <byorgey> edwardk works in edwardkemia
13:54:32 <edwardk> byorgey: =)
13:54:41 <byorgey> it's a very special place
13:54:49 <byorgey> =)
13:55:01 <edwardk> and http://hackage.haskell.org/packages/archive/kan-extensions/2.1.2/doc/html/Control-Monad-Co.html lets you take any haskell comonad and turn it into a monad transformer
13:55:09 <edwardk> the proof of why this works is also on my blog
13:55:13 <hiptobecubic> How do things which do not build at all, end up on hackage? Is it because of changes to ghc or what?
13:55:25 <elliott> hiptobecubic: hackage doesn't reject code that doesn't build
13:55:25 <bitonic> hiptobecubic: hackage makes no attempt to check
13:55:28 <edwardk> hiptobecubic: not everything can be built on the hackage server
13:55:30 <elliott> sometimes people just upload plain broken stuff
13:55:33 <elliott> hiptobecubic: but usually it's because of either
13:55:37 <edwardk> hiptobecubic: it may not have the libraries you need, etc.
13:55:38 <elliott> (a) external C library dependencies, or
13:55:44 <elliott> (b) hackage being on 7.4.1
13:55:48 <elliott> and previously 7.2
13:55:52 <hiptobecubic> i'm talking about types not matching up, etc
13:56:08 <elliott> hiptobecubic: people are reckless
13:56:09 <Dodek> edwardk: man, this is interesting. i really need to find some time to learn more about applications of category theory to computer science.
13:56:10 <timthelion> hiptobecubic: On the ghc7.4.1 almost nothing in hackage builds.  So you aren't alone...
13:56:21 <hiptobecubic> great.
13:56:35 <edwardk> Dodek: in haskell terms codensity 'right associates' all of the uses of >>=, while 'Yoneda' lets us use the yoneda lemma to fuse together the use of the functorial map
13:57:07 <hiptobecubic> edwardk, you build tools for quants?
13:57:17 <hnsz> This channel is so out of my comfort zone :p
13:57:51 <edwardk> hiptobecubic: I work at ClariFi, which is part of S&P CapitalIQ
13:58:00 <timthelion> hnsz: I just hope the highly inteligent use their powers for good, rather then squandering their lives doing financial market analysis...
13:58:07 <wo0kie> hello everyone :)
13:58:07 <edwardk> hnsz: to be fair i tend to be the death of fun on every channel i join
13:58:17 <hiptobecubic> timthelion, it's a much more interesting problem than most
13:58:18 <byorgey> hi wo0kie
13:58:43 <wo0kie> I was wondering if someone could be so kind as to help me understand function composition in haskell a bit?
13:58:52 <hnsz> edwardk: Don't worry, it's not just you ;)
13:58:55 <byorgey> wo0kie: sure. what are you having trouble with?
13:58:55 <timthelion> hiptobecubic: it's interesting, but it does nothing for society. It's the mastrabation of applied mathematics.
13:58:57 <hiptobecubic> timthelion, the rest of my research group is studying how water moves through corals... how is this any less "intellectually wasteful"
13:59:00 <shachaf> edwardk: Nonsense. It's just A New Kind of Fun.
13:59:11 <wo0kie> byorgey, mind if I pm?
13:59:23 <edwardk> Dodek: I have another package in which I exploit the fact that every monad or monad transformer that I've ever found in Haskell can be written into the form of a 'right kan extension transformer'
13:59:23 <shachaf> wo0kie: You should probably just ask in here.
13:59:24 <Dodek> edwardk: for comonad -> monad transformer, is it similar to the construction of group structure on Hom(S, X) where S is a cogroup object?
13:59:36 <wo0kie> ok :)
13:59:40 <byorgey> wo0kie: if this channel is too noisy we can move to #haskell-overflow
13:59:46 <timthelion> hiptobecubic: that's very usefull.  That research gets used on the west coast of the US to determine how the fertilizers will effect algea blooms.
13:59:53 <byorgey> that way other interested people can help as well
14:00:04 <wo0kie> I have a function that I need to apply to a variable n number of times
14:00:11 <wo0kie> sounds simple in theory
14:00:16 <wo0kie> but I can wrap my head around the syntax
14:00:24 <wo0kie> the type declaration looks like this: fnRepeat :: Integer -> (a -> a) -> (a -> a)
14:00:34 <byorgey> wo0kie: right. what have you tried?
14:00:43 <wo0kie> (I'll let you know that this is a hw assignment - not looking for answers, just trying to understand how to solve it)
14:00:56 <wo0kie> I'll put what I have on pastie, sec
14:01:27 <hiptobecubic> timthelion, on a very very zoomed out scale perhaps, but you're being extremely generous. I'm talking about the dynamics of turbulent fluid flow around coral and its affect on the shape of the of the resulting coral.
14:01:38 <edwardk> Dodek: not sure. for me it comes from the fact that you can sandwich a monad between an adjunction and get a monad, and the contravariant functor (_ -> r) is its own adjoint, so when you sandwhich a comonad in hask in that you get a monad, and you can decompose the comonad into an adjunction and shuffle things around to see the connection to the right kan extension
14:02:01 <wo0kie> byorgey: http://pastebin.com/b52uAZ22
14:02:03 <mauke> The paste b52uAZ22 has been copied to http://hpaste.org/65906
14:02:39 <edwardk> dodek: this leads to one construction, but if you take an end over that, to get rid of the 'r's you get http://hackage.haskell.org/packages/archive/kan-extensions/2.1.2/doc/html/Control-Monad-Co.html
14:02:39 <wo0kie> logically, the base case makes sense - if the number of repititions after decrementing each time is 0, then we're done
14:02:50 <wo0kie> no?
14:03:23 <edwardk> the fact that that monad was a monad transformer emerged more or less by accident, because i didn't need the properties of 'r', so i could wrap it in a monad m and get a result identical to the way we get the continuation passing style monad transformer
14:03:24 <elliott> wo0kie: Your base case, as written, doesn't make sense.
14:03:29 <byorgey> wo0kie: you are very, very close =)
14:03:32 <mewalz> wo0kie: its currying
14:03:32 <elliott> wo0kie: Look at your definition and try and match it up with the type.
14:03:38 <elliott> mewalz: Currying is irrelevant.
14:03:45 <wo0kie> :o
14:03:50 <wo0kie> my name's Elliott too btw haha
14:03:53 <hiptobecubic> edwardk, I ask because I'm finishing up my master's and trying to find a nice thesis topic that bridges FP and finance
14:03:56 <byorgey> wo0kie: in  fnRepeat 0 f x = ... , what are the types of f and x ?
14:03:57 <timthelion> hiptobecubic: at least it's not making other people rich :D
14:03:57 <elliott> wo0kie: (The *conceptual* base case you're imagining is correct; you've just made an error turning it into code.)
14:03:58 <byorgey> wo0kie: there is nothing wrong with your logic
14:03:58 <byorgey> wo0kie: just your types
14:03:59 <byorgey> wo0kie: did you see my question above?
14:04:01 <elliott> *Another* elliott?
14:04:08 <shachaf> wo0kie: You should change your nick to elliott
14:04:11 <elliott> Come on. This is too many. I've lost track of all the Haskeller Elliotts.
14:04:13 <shachaf> wo0kie: elliott wasn't using his anyway.
14:04:22 <wo0kie> I can give an example of what the output should look like
14:04:23 <edwardk> hiptobecubic: ah. let me chew on that for a bit
14:04:23 <hiptobecubic> timthelion, you mean managing your grandparent's pension fund so they don't run out of money before they die?
14:04:31 <wo0kie> because I'm not sure what the types are:
14:04:33 <wo0kie> fnRepeat 10 (\ x -> x + 1) 10 ↝ 20
14:04:38 <hiptobecubic> timthelion, or your own, for that matter.
14:04:39 <byorgey> wo0kie: that is unnecessary.
14:04:42 <elliott> wo0kie: The type you wrote is correct.
14:04:47 <elliott> wo0kie: The line you followed it with doesn't match the type.
14:04:52 <wo0kie> oh
14:04:55 <byorgey> wo0kie: if you're not sure what the types are then that's what you need to focus on.
14:04:58 <elliott> wo0kie: What is the type of (\ x -> x)?
14:05:08 <wo0kie> I'm not sure :(
14:05:10 <byorgey> wo0kie: writing Haskell code without understanding the types involved is just asking for trouble ;)
14:05:18 <wo0kie> yeah sounds like it lol
14:05:22 <edwardk> dodek: http://comonad.com/reader/2011/monads-from-comonads/ starts the discussion, http://comonad.com/reader/2011/monad-transformers-from-comonads/ and http://comonad.com/reader/2011/more-on-comonads-as-monad-transformers/ work through the details
14:05:31 <byorgey> wo0kie: you know what the  \x -> x  syntax means?
14:05:38 <wo0kie> lambda function right?
14:05:46 <mmaruseacph2> wo0kie, what function?
14:05:49 <byorgey> yes, it's a lambda expression, aka anonymous function
14:06:09 <wo0kie> hmm
14:06:26 <hiptobecubic> timthelion, sure it's possible to abuse the financial markets, but then you also have to rule out most for-profit companies as immoral. I was skeptical about it too until i started taking courses and reading about it. There's a good side to finance as well.. although now we're offtopic :)
14:06:52 <wo0kie> mmaruseacph2: http://pastebin.com/b52uAZ22
14:06:54 <byorgey> so it must have a function type
14:06:57 <mauke> The paste b52uAZ22 has been copied to http://hpaste.org/65906
14:07:02 <augur> conal: do you know of anything that talks about differentiation in abstract? like, what it is/means, what is required to be a differentiation operation, etc.?
14:07:04 <timthelion> hiptobecubic: Sorry, I have a bias.  I understand the need for the industry.  I don't like the fact that 90% of it is bassed on indirect investment, such as derivitives...  Sorry, I don't want to argue with you...
14:07:18 <wo0kie> byorgey: I need to return a function then in my base case then, no?
14:07:19 <byorgey> in fact  (\x -> x) :: a -> a
14:07:20 <byorgey> that means it can take a value of any type 'a' and returns a value of the same type
14:07:30 <wo0kie> :o
14:07:57 <byorgey> wo0kie: no, because you wrote  fnRepeat 0 f x = ...
14:08:34 <wo0kie> :S
14:08:36 <augur> or byorgey, you might know
14:08:40 <augur> since you're mr species :p
14:08:48 <conal> augur: yes. i give some definitions & pointers in my differentiation paper. from calculus on manifolds.
14:08:54 <byorgey> wo0kie: 0 :: Integer;  f :: (a -> a);  x :: a
14:09:01 <byorgey> augur: I don't
14:09:01 <augur> conal: :D
14:09:02 <augur> <3
14:09:02 <byorgey> augur: I just know how to interpret it combinatorially =P
14:09:12 <hnsz> Imo any engineer that abuses the financial system is doing a good job as long as he does it for his own profit in stead of for a wage.
14:09:30 <conal> augur: in terms of linear mappings rather than specific representations like scalars, vectors, matrices, etc.
14:09:31 <byorgey> wo0kie: think of it this way:  foo a b x = y   is just shorthand for   foo a b = (\x -> y)
14:09:35 <byorgey> wo0kie: does that make sense?
14:09:48 <wo0kie> I think so
14:09:52 <augur> conal: beautiful differentiation?
14:09:54 <hiptobecubic> edwardk, my advisor is an ex physicist turned quant that's now the head of model validation at a large bank. He's not as concerned about the programming side of things as long as the application is relevant and high quality. I've been looking around but it's a tough search.
14:09:56 <conal> augur: yeah.
14:10:02 <augur> conal: reading now
14:10:06 <wo0kie> would foo a = (\ b x -> y) be synonomous?
14:10:07 <conal> augur: cool.
14:10:16 <byorgey> wo0kie: yes
14:10:20 <wo0kie> I see
14:10:42 <byorgey> wo0kie: the way you have written the type, Integer -> (a -> a) -> (a -> a), it takes two arguments (an Integer and an  a -> a  function) and returns a function
14:10:53 <conal> augur: in case you haven't found them, there are pointers to slides & video also on http://conal.net/papers/beautiful-differentiation/
14:10:57 <byorgey> wo0kie: so you might expect something like  fnRepeat 0 f = ...
14:11:02 <byorgey> where the ... is a function
14:11:03 <augur> conal: oh man, videos
14:11:06 <byorgey> wo0kie: with me so far?
14:11:09 <conal> :)
14:11:17 <wo0kie> you saying I have one too many arguments?
14:11:19 <wo0kie> :o
14:11:23 <byorgey> wo0kie: no =)
14:11:33 <augur> conal: i love videos. this is the perfect moment right now. a video talk by conal on what it means to be differentiation
14:11:45 <byorgey> wo0kie: because remember, foo a b = (\x -> y)  can also be written   foo a b x = y
14:11:54 <conal> augur: :) enjoy!
14:12:09 <wo0kie> hmmm
14:12:17 <augur> this is like the highlight of my year. (a) maybe an answer to a very important question for my research, (b) in video form, (c) by an awesome dude
14:12:19 <mmaruseacph2> I though that conal and elliott were the same :))
14:12:35 <augur> the only draw back is i cant watch it right now T_T
14:12:45 <gnoi> I have f :: IO (Maybe Integer). How can I get Integer from it? I use {m <- f; let a = fromMaybe 0 m}. Can it be done in single line?
14:12:45 <worldsayshi> Question to anyone: Does anyone know of examples of implementing type systems in embedded languages, extending the underlying haskell type system? I'm probably way over my head but I believe that's what I'm trying to do at the moment.
14:13:10 <wo0kie> so would my base case be more akin to: fnRepeat 0 f x = x?
14:13:11 <hnsz> conal: Is that your talk?
14:13:12 <elliott> mmaruseacph2: Everyone thinks that. I must be tarnishing conal's reputation.
14:13:21 <wo0kie> since (\ x -> x) matches (a -> a)?
14:13:31 <elliott> wo0kie: \o/
14:13:34 <elliott> you got it
14:13:38 <wo0kie> :D
14:13:43 <byorgey> wo0kie: yes!
14:13:43 <conal> hnsz: yeah.
14:13:53 <byorgey> gnoi: you could do   a <- fromMaybe 0 `fmap` f
14:13:54 <elliott> wo0kie: there's also an error in the second line -- you should be able to find it now
14:14:15 <wo0kie> hmm
14:14:23 <elliott> erm
14:14:24 <elliott> third.
14:14:53 <byorgey> what, there is?
14:14:53 <hnsz> conal: I'm going to watch it.
14:15:18 <wo0kie> I know it's wrong
14:15:20 <byorgey> second line looks OK to me
14:15:21 <wo0kie> just not sure why
14:15:26 <conal> hnsz: cool. i hope you like it. a good intro to the paper.
14:15:48 <byorgey> that's the one I meant.
14:16:00 <wo0kie> fnRepeat n f x = f (fnRepeat (n - 1) f x)
14:16:05 <wo0kie> so that makes sense?
14:17:09 <elliott> oh
14:17:13 <elliott> wo0kie: very sorry.
14:17:14 <augur> conal: just a sanity check, the definitions you give are compatible with differentiation of functors?
14:17:15 <wo0kie> oh wow, I was using "fnRepeat fnRepeat" by accident in ghci
14:17:17 <elliott> i misread your code originally :)
14:17:23 <elliott> yes, that is fine.
14:17:32 <wo0kie> but now I get a "show" error :\
14:17:37 <wo0kie> do I need to add a constraint?
14:17:48 <jmcarthur> :t \n = foldr (.) id . replicate n
14:17:49 <lambdabot> parse error on input `='
14:17:53 <jmcarthur> :t \n -> foldr (.) id . replicate n
14:17:54 <lambdabot> forall b. Int -> (b -> b) -> b -> b
14:19:11 <elliott> wo0kie: How are you using it?
14:19:22 <wo0kie> fnRepeat 10 (\ x -> x + 1)
14:19:26 <byorgey> wo0kie: you know what's wrong?
14:19:28 <byorgey> does it make sense to you? =)
14:19:30 <byorgey> (also, have you tried running it?)
14:19:31 <gnoi> `liftM2 (-) (fromMaybe 0 `fmap` f1) (fromMaybe 0 `fmap` f2)' how can I avoid duplicate?
14:19:46 <byorgey> gnoi: well, you could make a function that does  fromMaybe 0 `fmap`
14:19:57 <wo0kie> I'm thinking I'm missing a show constraint so that the integer can be printed
14:20:01 <elliott> wo0kie: What type does fnRepeat 10 (\ x -> x + 1) have?
14:20:11 <sonoflilit> In wxHaskell, can I add an item in the middle of a ListCtrl list?
14:20:20 <elliott> wo0kie: In particular, why do you expect it is an Integer?
14:20:30 <sonoflilit> I can only find a function to append an item to the end
14:20:45 <wo0kie> hmm, good point
14:21:08 <sonoflilit> it would also be ok if I knew how to set all items to a "new" item list but keep the scroll state similar
14:21:10 <conal> augur: oh!!
14:21:13 <conal> a
14:21:19 <conal> augur: oh!
14:21:38 <conal> augur: not that i know of. sorry about that.
14:21:57 <augur> conal: ah ok. well i guess we'll see then if i can make something of it :)
14:22:24 <wo0kie> so my base case is correct
14:22:31 <wo0kie> the third line seems correct
14:23:20 <conal> augur: i don't know a source for explaining what functor differentiation means.
14:23:44 <sonoflilit> gnoi: a <- fromMaybe 0 `fmap` f
14:23:47 <wo0kie> "No instance for (Show (a0 -> a0))"
14:23:49 <wo0kie> :\
14:24:09 <mewalz> wo0kie: its a function that returns a functions
14:24:10 <elliott> wo0kie: Your code is fine!
14:24:14 <elliott> wo0kie: Your example is not.
14:24:28 <elliott> wo0kie: (fnRepeat 10 (\ x -> x + 1)) is the composition of (\ x -> x + 1) with itself 10 times, right?
14:24:33 <elliott> Is that an Integer?
14:24:49 <wo0kie> I would think so
14:24:52 <wo0kie> D:
14:25:00 <edwardk> conal: http://strictlypositive.org/CJ.pdf gives you one notion, but there is a more general approach expressed on sigfpe's blog
14:25:12 <wo0kie> whoa
14:25:13 <elliott> wo0kie: Really?
14:25:22 <wo0kie> idk :<
14:25:25 <elliott> Maybe you should look at your definition's left-hand side again.
14:25:29 <wo0kie> I'm so bad at this lol
14:25:32 <wo0kie> hmm
14:25:48 <mewalz> wo0kie: All functions in haskell take only only one parameter.
14:25:54 <mewalz> :t map
14:25:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:26:01 <elliott> wo0kie: fnRepeat n f x = f (fnRepeat (n - 1) f x)
14:26:10 <elliott> wo0kie: n is 10, and f is (\ x -> x + 1)
14:26:11 <mewalz> :t map id
14:26:12 <lambdabot> forall a. [a] -> [a]
14:26:22 <elliott> wo0kie: But you haven't specified x.
14:26:33 <wo0kie> OHHHH
14:26:41 <wo0kie> wow I'm an idiot
14:26:43 <elliott> fnRepeat wants three arguments, but you've only given it two; (fnRepeat 10 (\ x -> x + 1)) is a function, and GHCi can't show functions.
14:26:49 <byorgey> wo0kie: no, you aren't =)
14:27:07 <wo0kie> fnRepeat n f = \x -> f (fnRepeat (n-1) f x) that works too ;D
14:27:12 <wo0kie> seems to make a bit more sense now
14:27:35 <wo0kie> I think in terms of the type declaration, that makes more sense to me
14:27:36 <byorgey> wo0kie: yep! and you can even simplify that using the function composition operator (.)
14:27:53 <wo0kie> f . fnRepeat (n-1) f x?
14:28:01 <byorgey> almost
14:28:05 <wo0kie> :o
14:28:17 <byorgey> what is that 'x' ?
14:28:35 <wo0kie> the third argument? :o
14:28:55 <elliott> what third argument?
14:29:01 <elliott> fnRepeat n f = f . fnRepeat (n-1) f x
14:29:02 <byorgey> f (g x) = f . g
14:29:03 <edwardk> augur: you are probably looking for the notion of a differential algebra or a differential ring
14:29:10 <elliott> where's x come from?
14:29:16 <byorgey> uh, ignore that, that made no sense
14:29:33 <wo0kie> oh I mean to say "fnRepeat n f x = f . fnRepeat (n-1) f x"
14:29:34 <augur> edwardk: hmm
14:29:49 <wo0kie> or fnRepeat n f = \ x -> f . fnRepeat (n-1) f x
14:29:50 <wo0kie> no?
14:29:53 <hpc> fnRepeat n f = f . fnRepeat (n-1) f
14:30:03 <wo0kie> partial application? :O
14:30:06 <byorgey> wo0kie: not quite
14:30:22 <hpc> or for extra fun
14:30:47 <hpc> fnRepeat = foldr (.) id .: repeat
14:30:52 <byorgey> wo0kie: (f . g) x = f (g x)
14:30:53 <hpc> (.:) = (.) . (.)
14:30:57 <elliott> hpc: giving the solution away is not conducive to learning :)
14:31:02 <hpc> :P
14:31:06 <edwardk> if i had to guess if you look at the generating functions that come from (finite) types you probably have a rather weak differential graded algebra
14:31:10 <hpc> :t foldr (.) id .: repeat
14:31:10 <wo0kie> lol
14:31:11 <lambdabot> forall b. [b -> b] -> [b -> b]
14:31:17 <wo0kie> I like my solution so far :)
14:31:20 <wo0kie> makes more sense
14:31:21 <hpc> oh wait, im wrong
14:31:24 <wo0kie> that makes sense byorgey
14:31:28 <hpc> @hoogle Int -> a -> [a]
14:31:29 <lambdabot> Prelude replicate :: Int -> a -> [a]
14:31:29 <lambdabot> Data.List replicate :: Int -> a -> [a]
14:31:29 <lambdabot> Prelude drop :: Int -> [a] -> [a]
14:31:36 <hpc> :t foldr (.) id .: replicate
14:31:37 <lambdabot> forall b. Int -> (b -> b) -> b -> b
14:31:40 <byorgey> wo0kie: yes, your solution is fine =)
14:31:42 <hpc> aha
14:31:49 <sonoflilit> another question: in wxHaskell, can ListCtrl be used in "virtual mode"? I couldn't find any reference in the documentation....
14:31:56 <hpc> wo0kie: yeah, go with the version you can understand :P
14:31:58 <byorgey> wo0kie: we just can't leave well enough alone and always have to show off all the fancy ways to do anything ;)
14:32:10 <wo0kie> hahah I understand :)
14:32:15 <hpc> and hopefully give ideas for future learning
14:32:18 <wo0kie> am I allowed to idle in here?
14:32:22 <hpc> sure
14:32:22 <byorgey> (yes, that too)
14:32:26 <byorgey> wo0kie: absolutely!
14:32:26 <hpc> 800 people can't be wrong!
14:32:27 <wo0kie> cool
14:32:35 <byorgey> it's a great way to learn stuff
14:32:37 <wo0kie> thank you so much for the help byorgey, elliott, and others
14:32:40 <hpc> er, 900
14:32:42 <elliott> no problem :)
14:32:50 <wo0kie> pointed me in the right direction :)
14:32:51 <wo0kie> cheers
14:33:00 <edwardk> i did sketch way to talk about infinite data structures in terms of bivariate generating functions a couple of years back, I just never really formalized it, something like that would probably be needed to cover all types in a lazy language correctly
14:33:48 <byorgey> edwardk: ooooh, do want!
14:34:10 <edwardk> byorgey: i'll see if i can dig up my notes
14:34:10 <byorgey> edwardk: is it on your blog?
14:34:15 <byorgey> that would be great
14:34:29 <edwardk> nah. only thing on my blog is that generatingfunctorology post
14:34:32 <byorgey> extending species to cover infinite data structures is on my list of research questions
14:34:35 <byorgey> ok.
14:34:58 <edwardk> i pestered cale about it interminably at the time
14:35:21 <sonoflilit> seems like this is not the correct place to ask wxHaskell questions. Can you guys point me to a better venue for my questions?
14:35:23 <Cale> HELLO
14:35:29 <elliott> HELLO CALE
14:35:30 <Cale> YES, THIS IS DOG
14:35:39 <edwardk> i don't know if what i had could be generalized to arbitrary species or not. I have a reltiely unsophisticated understanding of more general species
14:35:47 <elliott> sonoflilit: #wxhaskell maybe? Or a mailing list?
14:35:51 <elliott> Even haskell-cafe might be worthwhile.
14:35:54 <sonoflilit> thanks
14:36:01 <hpc> > hello
14:36:02 <elliott> I don't think anything Haskell is off-topic here, really.
14:36:03 <lambdabot>   yes, this is bot
14:36:14 <elliott> Whether you'll get useful reponses is another matter.
14:36:16 <elliott> *responses
14:36:20 <byorgey> edwardk: that's my job! =D
14:36:35 <Cale> One person you might want to talk to if you're interested in adapting species for functional programming is Jacques Carette, at McMaster University
14:36:41 <edwardk> byorgey: its probably in one of my boxes of papers from before the move.
14:36:52 <byorgey> Cale: oh, we have already been talking quite a lot =)
14:36:58 <sonoflilit> elliott: that's exactly it. Seems like nobody here has the answers
14:37:04 <hnsz> conal: Heh, I was thinking hey this guy really sounds like the techtalk guy from tangible functional programming.
14:37:16 <edwardk> jacques is a pretty smart guy =)
14:37:20 <conal> hnsz: :)
14:37:24 <byorgey> edwardk: well, if you ever find it, I would be extremely interested
14:37:36 <sonoflilit> #wxhaskell doesn't exist, at least here on freenode
14:37:42 <elliott> yeah I didn't know if it existed
14:37:44 <elliott> but it might have :)
14:39:29 <hnsz> conal: So you've walked through the infamous google q&a fire :D
14:44:44 <wo0kie> man you guys are geniuses
14:44:50 <wo0kie> just got the second question done without a hitch
14:44:52 <wo0kie> <3
14:48:20 <mikeplus32> anyone have luck installing repa with ghc 7.4.1?
14:49:46 <mikeplus32> http://hpaste.org/65909
14:51:15 <JoeyA> mikeplus32: repa has a base == 4.4.* dependency.  GHC 7.4.1 uses base 4.5, so repa won't install right away by itself.
14:52:01 <byorgey> wo0kie: \o/
14:52:13 <wo0kie> :D
14:52:23 <JoeyA> mikeplus32: You can say `cabal unpack repa` to download the source, change the base dependency in repa.cabal by hand, and run cabal install to see what happens.
14:52:29 <mikeplus32> JoeyA: yeah, I'm doing that now
14:52:48 <mikeplus32> so far so good...... but it hasn't gotten to building repa
14:53:37 <ehy_> > 1
14:53:38 <lambdabot>   1
14:53:53 <JoeyA> I'm guessing you'll get a jillion warnings about FFI and unsafe functions.
14:55:54 <mikeplus32> gotta break a few things to fix a few things
14:57:37 <hnsz> conal: You had a pretty esteemed audience i see. Nice talk. I'd have to read the paper to grasp it all I think.
14:58:35 <conal> thx. hopefully the paper orients you in reading the paper.
15:00:48 <Modius> shadowing existing binding (especially within a single function/expression) - you tend to avoid it?  Or remove the message?
15:01:04 <conal> s/hopefully the paper/hopefully the talk/
15:01:04 <mzero> I avoid it
15:01:29 <mzero> even though about ⅓ of the time I feel it's busy work
15:02:17 <mzero> but compiling -Wall is so useful, that I'm willing to rename things
15:03:24 <mzero> now, if you are shadowing an argument to a top level function with an argument or pattern match to something in a let or where clause in it - then absolutely fix it
15:03:52 <Modius> I assume ghc-mod in my stock install is using -Wall. . . ?
15:04:30 <elliott> -Wall isn't default. but if you're getting warnings then either -W or -Wall is on, presumably
15:05:02 <mzero> its on because ghc-mod's cabal file specifies it as being on
15:05:50 <elliott> ah
15:05:55 <elliott> i assumed it was being encountered in use of ghc-mod
15:06:06 <ski> (mzero : i don't always do that ..)
15:06:40 <watermind> " GADT pattern match in non-rigid context for `Fin0', Probable solution: add a type signature for `TDArrays.$con2tag_Fin' "
15:06:43 <watermind> ewww
15:07:04 <mzero> foo a b = ...   where foo' [] a b = ....         seems like asking for trouble, I just name to the top ones a0 b0
15:07:20 <watermind> I just searched a bit, and there was a ticket for this kind of error
15:07:29 <watermind> but apparently things have changed with GHC 7.x
15:07:38 <watermind> I think I should move to 7.x
15:07:44 <ski> mzero : yeah, but sometimes i want to make it explicit that the outer `a',`b' are *not* accessible inside the local definition
15:07:47 <vjousse> Hi there. I am new to haskell and struggling a little bit with the IO monad ... Here is the function I would like to have: width :: IO (Double) -> String
15:08:05 <ski> mzero : if i had a `local'-`in', i'd use that instead
15:08:07 <vjousse> and I have almost no idea how to "convert" this IO Double to a String
15:08:20 <jmcarthur> vjousse: you can't write that, but you can write this:  width :: IO Double -> IO String
15:08:52 <vjousse> ok so, as far as I am "in" an IO monad, I can't "escape" from it mostly?
15:09:12 <mzero> vjousse: probably what you want to write is   width :: Double -> String
15:09:17 <mzero> and then in the place where you were calling width
15:09:17 <jmcarthur> vjousse: there is no value to remove from an IO action, but you can turn a function on pure values into functions on IO actions
15:09:19 <watermind> but I have no idea how to do this... right now I have Haskell platform (OpenSUSE Repository), but this is on 6.12.x... and I have a bunch of stuff from hackage...  there is a standalone 7.x for openSUSE, but not the platform
15:09:22 <ski> vjousse : however, `width :: Double -> IO String' (or maybe even `width :: Double -> String', if possible) would be more idiomaic
15:09:23 <mzero> that is in a do block
15:09:33 <watermind> I have no idea what is the best path to upgrade this
15:09:41 <vjousse> let me give you a little bit more context
15:09:56 <jmcarthur> :t (>>=) :: IO a -> (a -> IO b) -> IO b
15:09:57 <lambdabot> forall a b. IO a -> (a -> IO b) -> IO b
15:09:59 <mzero> and you could extract the double and apply it there (staying within IO)
15:10:28 <mzero> vjousse: if it is more than a two lines of code, use hpaste
15:10:31 <jmcarthur> by "extract" mzero means use bind or one of the other higher order functions implemented in terms of bind
15:10:32 <ski> vjousse : maybe you have some code yo show us ?
15:10:34 <ski> @paste
15:10:34 <lambdabot> Haskell pastebin: http://hpaste.org/
15:10:43 <vjousse> yep sure
15:11:25 <vjousse> https://github.com/vjousse/dotfiles/blob/master/xmonad/lib/Dzen.hs#L202
15:11:28 <Elemir> > toString 12.3
15:11:29 <lambdabot>   Not in scope: `toString'
15:11:31 <vjousse> here is the function I want to use
15:11:32 <mikeplus32> watermind: if you get the 7.x ghc, you can build the other packages yourself with cabal
15:11:36 <Elemir> > show 12.3
15:11:37 <lambdabot>   "12.3"
15:12:00 <vjousse> I would like to use the value of my screen width
15:12:16 <vjousse> to do some computation to decide how to display my dzen here: https://github.com/vjousse/dotfiles/blob/master/xmonad/xmonad.hs#L98
15:12:56 <mzero> well, you can't use screen width in that context, because myStatusBar is a static string
15:13:01 <Modius> ghc-mod (and its warnings, amongst other things) is such a great aid to the haskell noob (i.e. me) that I find myself saying it again for the 10th time.
15:13:30 <vjousse> ok, that's what I was fearing mzero :)
15:13:30 <mzero> but, on line 18
15:13:31 <jmcarthur> vjousse: what you will have to do is get the screen width near the top of your main function there and then pass the result down into the config
15:13:38 <watermind> mikeplus32: so unistall the platform packages, upgrade ghc, cabal install the rest?
15:13:45 <wo0kie> is there a way to convert the head of a list to a list itself after a function is applied to it?
15:14:06 <mzero> you can write something like:      dzenPipe <- screenWidth >>= spawnPipe . myStatusBar
15:14:14 <mzero> and then make myStatusBar be a function of a Double
15:14:15 <wo0kie> for example, can I do [(f x)] where x is head of (x:xs)?
15:14:18 <jmcarthur> vjousse: your status bar value can then be a pure function, and you apply it to the screen width in the body of your main
15:14:20 <mikeplus32> watermind: yeah, you should probably start with a new ~/.cabal and ~/.ghc too
15:14:25 <mzero> myStatusBar :: Double -> String
15:14:49 <mzero> and NOW, myStatusBar can call  your     width :: Double -> String    function
15:14:52 <ski> wo0kie : yes
15:15:03 <watermind> mikeplus32: good point thanks for the tips
15:15:04 <mzero> did you follow that, vjousse ?
15:15:06 <mikeplus32> wo0kie: [f (head list)] :)
15:15:10 <mzero> or should I put it in a hpaste?
15:15:13 <vjousse> ouch
15:15:15 <wo0kie> hmmm
15:15:20 <vjousse> let me read it again and again :D
15:15:37 <hpaste> wo0kie pasted “listArgMins” at http://hpaste.org/65911
15:15:43 <vjousse> I'm coming from Scala, not so used to have only pure functions everywhere
15:15:47 <wo0kie> does that make sense?
15:15:51 <ski> mzero : `dzenPipe <- spawnPipe . myStatusBar =<< screenWidth' reads nicer, imo
15:15:57 <wo0kie> I keep getting an error on the 4th line :S
15:16:05 <mzero> I'm making a paste...
15:16:18 <mikeplus32> wo0kie: you can just use f x:listArgMins f xs
15:16:25 <wo0kie> :o
15:16:35 <mikeplus32> look at the hpaste output
15:16:40 <mikeplus32> it has good advice :)
15:16:42 * hackagebot bindings-gpgme 0.1.4 - Low level bindings to gpgme.  http://hackage.haskell.org/package/bindings-gpgme-0.1.4 (MauricioAntunes)
15:17:22 <wo0kie> hmm
15:17:29 <wo0kie> made changes, yet it still gives me an error D:
15:17:44 <wo0kie> some sort of type mismatch
15:17:55 <ski> wo0kie : i'd define `y = f x' and `ys = map f xs' and use those instead of recomputing
15:18:06 <jmcarthur> vjousse: i tried: https://github.com/jmcarthur/dotfiles/commit/5071966ef0aafac3bb931cc9a85c11c7e1576526
15:18:15 <vjousse> hmmm thanks guys, I have enough to play one more hour with it. I'll come back to you then. (thanks for the answer that's awesome)
15:18:26 <vjousse> let me check jmcarthur
15:18:52 <mikeplus32> wo0kie: you want Ord b => (a -> b) -> [a] -> [b]
15:18:59 <jmcarthur> vjousse: as my pull request said, it won't work out of the box, but with some tweaking to do what you actually want it should get you pretty close
15:19:01 <mikeplus32> not [a] -> [a]
15:19:13 <TTimoT> hackage is down? is the world ending?
15:19:26 <wo0kie> hmmm
15:19:26 <jmcarthur> TTimoT: i think you are incorrect
15:19:42 <elliott> if hackage being down means it's the end of the world, it's ended several times recently
15:19:54 <jmcarthur> hackage appears to be up, to me
15:20:03 <TTimoT> http://www.downforeveryoneorjustme.com/www.hackage.org
15:20:05 <TTimoT> says down
15:20:10 <vjousse> jmcarthur: makes a lot of sense to me. Discovering haskell and functionnal programming is like: what did I do during the past 10 years?
15:20:18 <vjousse> thanks jmcarthur I'll keep you posted
15:20:20 <jmcarthur> heh :)
15:20:22 <elliott> TTimoT: good thing hackage isn't at hackage.org, then
15:20:27 <jmcarthur> np
15:20:28 <elliott> http://hackage.haskell.org/
15:20:48 <TTimoT> damn you arbtt ! http://www.hackage.org/package/arbtt
15:20:54 <TTimoT> that's what he has in the man page :)
15:20:58 <TTimoT> ok ty
15:21:50 <hpaste> mzero pasted “using screenWidth” at http://hpaste.org/65912
15:22:08 <mzero> vjousse: see that paste
15:22:37 <vjousse> ok let me check
15:23:46 <vjousse> that's great :)
15:24:49 <ben> What's the easiest way to make QuickCheck test a property that is a function with four arguments using random numbers from four ranges I give it?
15:25:42 <mzero> if its a one-off, you can just make 'em all Int and apply mod to whatever QC gives you
15:25:57 <ben> okay, that's probably good enough :)
15:26:07 <mzero> if you've dozen of such tests, and the ranges are fixed, make newtype(s) for them
15:26:16 <ben> I started with checking them all for my range and using ==> but it wouldn't find enough numbers that fit
15:29:00 <mzero> yeah, ==> only works if you need to reject degenerate or rare cases
15:29:07 <Veinor> hm
15:29:43 <gnoi> How can I change timeLocale to UTC+n?
15:29:46 <Guest32898> hi, I'm just starting haskell and wanted to experiment a bit, but I'm currently stuck with a type error. Why does this code fail?:
15:29:48 <Guest32898> mysqrt :: Integer -> Integer
15:29:50 <Guest32898> mysqrt n = floor (sqrt n)
15:29:52 <Guest32898>  
15:30:14 <mzero> :t sqrt
15:30:15 <lambdabot> forall a. (Floating a) => a -> a
15:30:18 <ben> Because we don't do implicit conversions to floating point numbers, really
15:30:25 <mzero> Integer isn't a Floating
15:30:27 <elliott> Guest32898: please don't paste code here
15:30:28 <elliott> use hpaste.org
15:30:36 <ben> :t fromIntegral
15:30:36 <Guest32898> elliott: for 2 lines?
15:30:37 <lambdabot> forall a b. (Integral a, Num b) => a -> b
15:30:48 <elliott> Guest32898: usually, yes. (actually, it was 3.)
15:30:52 <elliott> anyway, yes, Integer isn't Floating, so you can't pass it to sqrt
15:31:01 <elliott> but you can use fromIntegral to turn Integer into something that is Floating.
15:31:16 * Guest32898 tries
15:31:59 <Guest32898> I see
15:32:52 <Guest32898> so fromIntegral converts an Integral to whatever numeric type is part of the Num class, according to what the next function expects, right?
15:33:14 * ski doesn't mind two or three lines pasted here ..
15:33:14 <mzero> well, sort of
15:33:26 <Guest32898> also, how can I see what a class has defined? for example, Num, how do I see what types it handles?
15:33:28 <elliott> ski: sure, when it's one person doing it :)
15:33:38 <elliott> Guest32898: You can see the instances of a class with ":info Class" in GHCi.
15:33:49 <elliott> Your terminology is kind of screwy, though -- classes aren't anything like OOP classes.
15:34:07 <ski> elliott : well, i wouldn't mind if five persons did it at roughly the same time, either :)
15:34:09 <mzero> the way to think of it is this: fromIntegral is a function from any Integral a to any Num b --- there's a version of fromIntegral just for the pair of types you need in any given situation, so long as they are Integral and num
15:34:48 <Guest32898> elliott: I'm not quite sure what haskell's classes are atm
15:35:03 <Guest32898> still haven't reached that point
15:35:06 <mzero> Haskell then uses the types it can figure out to decide what types fromIntegral must have in any particular usage
15:35:10 <vjousse> thanks a lot guys, it works like a charm (https://github.com/vjousse/dotfiles/commit/1668cf030100b9d64ee7e6f52798c6fb0856033d) and I think I'm starting to get the philosophy behind it :)
15:35:20 <Guest32898> it's just that I wanted to take a peek into one of them, since I've seen Num in some errors I got
15:35:43 <elliott> Guest32898: right, taking a premature peek is likely to confuse more than enlighten :)
15:35:46 <hpaste> Veinor pasted “parsec memory” at http://hpaste.org/65914
15:35:52 <elliott> I take it you're reading Learn You a Haskell or Real World Haskell?
15:35:56 <Veinor> can anybody help me optimize the memory usage of this?
15:36:06 <mzero> Guest32898: if you are familiar with more traditional OOP, then type classes are closer to interfaces, (though still not quite)
15:36:28 <Veinor> http://hpaste.org/65914 er, this one
15:36:44 <Guest32898> ok, that'd be all for now, thanks for the help
15:36:59 <elliott> Veinor: have you considered using a different parsing library? your code seems fine to me
15:37:17 <elliott> I know attoparsec is faster than parsec, dunno about space usage though, but I seem to remember hearing something about parsec 3 having undesirable space usage
15:37:31 <Veinor> elliott: the problem is i'm parsing something that's basically html
15:37:40 <dylukes> hm
15:37:42 <Veinor> but that's not structured
15:38:00 <dylukes> Veinor: perhaps?
15:38:00 <dylukes> http://www.crummy.com/software/BeautifulSoup/
15:38:11 <elliott> I was unaware Beautiful Soup had a Haskell port.
15:38:23 <elliott> Veinor: ...but take a look at the tagsoup library, perhaps.
15:38:27 <Veinor> i am :)
15:38:30 <elliott> ah
15:38:34 <Veinor> the parser parses a stream of Tag values
15:38:42 <dylukes> It... doesn't have a Haskell port that I know of.
15:38:45 <elliott> ah, I see
15:39:01 <dylukes> But we have MissingPy :\
15:39:04 <elliott> right, attoparsec wouldn't help then.
15:39:19 <elliott> Veinor: IIRC there's a library that plugs in tagsoup's parser to a proper document tree structure.
15:39:27 <dylukes> http://hackage.haskell.org/packages/archive/MissingPy/0.10.5/doc/html/Python-Interpreter.html
15:39:28 <elliott> You might find that less painful than writing parsers.
15:39:45 <elliott> http://hackage.haskell.org/package/hexpat-tagsoup http://hackage.haskell.org/package/hxt-tagsoup
15:40:03 <dylukes> brb
15:40:05 <Veinor> the problem is that the stuff i'm parsing is unstructured
15:40:31 <elliott> yeah... well, the actual code looks fine to me; maybe try heap profiling
15:40:36 <Veinor> http://hastebin.com/lukivaqeri.xml it looks something like this
15:42:07 <Veinor> maybe i should just rewrite it using list-manipulation operations instead of parsec
15:42:33 <elliott> i think most people just filter lists with tagsoup, yeah
15:42:50 <elliott> it's not very nice, i had grand plans to write a nicer html scraper library similar to beautifulsoup but never bothered
15:43:03 <Veinor> the other option would, of course, be to parse the html as a bytestring stream
15:43:08 <Veinor> and use attoparsec
15:49:37 <hnsz> gwern: Did you hyjacka a wikipedia proxy? :p
15:49:54 <hnsz> hijack*
15:50:34 <gwern> hnsz: no, I made over 100k edits among many other things; see http://www.gwern.net/Wikipedia%20resume
15:52:13 <hnsz> gwern: Good work
16:10:21 <wo0kie> is boolean logic capable of detecting exactly one truth in an operation?
16:10:35 <wo0kie> IE, True and False would yield True
16:10:45 <wo0kie> while True and False and True would yield false?
16:11:21 <wo0kie> if only one thing is true, the entire statement is true
16:11:32 <wo0kie> if 0 or more than one thing is true, it should be false :o
16:12:11 <hnsz> wo0kie: You have a list of values then
16:12:20 <wo0kie> yeah :P
16:12:47 <wo0kie> HMM
16:12:53 <hnsz> wo0kie: You cant do that with a binary operator
16:13:08 <wo0kie> I could do something like "map odd [1,2,3]" and then detect if more than one true, no?
16:13:10 <ski> > let exactlyOneTrue bs = case filter id bs of [_] -> True; _ -> False  in exactlyOneTrue [True,False]
16:13:11 <lambdabot>   True
16:13:12 <wo0kie> oooo binary operator
16:13:15 <ski> > let exactlyOneTrue bs = case filter id bs of [_] -> True; _ -> False  in exactlyOneTrue [True,False,True]
16:13:15 <lambdabot>   False
16:14:24 <Modius> Is there a stock function that converts GT into LT and LT into GT?
16:14:49 <Nisstyre> Modius: why would you want that?
16:14:55 <mplyho> flip
16:15:10 <Nisstyre> yeah, flip (>)
16:15:33 <Nisstyre> that seems like it would be very confusing though
16:15:35 <Modius> I should back up a bit - is reverse $ sort an efficient way to reverse sort?
16:15:55 <Nisstyre> I think you want sortBy
16:15:59 <ski> @type sortBy (flip compare)
16:16:00 <lambdabot> forall a. (Ord a) => [a] -> [a]
16:17:43 <Mathnerd314> > sortBy (flip compare) [1..5]
16:17:45 <lambdabot>   [5,4,3,2,1]
16:18:14 <Mathnerd314> @src sort
16:18:14 <lambdabot> sort = sortBy compare
16:18:18 <mplyho> > sortBy (flip compare) [1..1000000]
16:18:22 <lambdabot>   mueval-core: Time limit exceeded
16:18:25 <Mathnerd314> @src sortBy
16:18:25 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:18:53 <Mathnerd314> @src insertBy
16:18:53 <lambdabot> insertBy _   x [] = [x]
16:18:53 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
16:18:53 <lambdabot>                                  GT -> y : insertBy cmp x ys'
16:18:53 <lambdabot>                                  _  -> x : ys
16:19:16 <hpaste> WM pasted “cabal install” at http://hpaste.org/65916
16:19:17 <Mathnerd314> @src reverse
16:19:17 <lambdabot> reverse = foldl (flip (:)) []
16:19:52 <watermind> so I cannot cabal install cabal-install  because of package unix... (?) I'm a bit lost here
16:19:53 <watermind> http://hpaste.org/65916
16:19:58 <watermind> what does this mean?
16:20:35 <watermind> I tried to cabal install unix, but it does help
16:20:41 <watermind> doesn't *
16:22:49 <dmwit> watermind: You should not reinstall unix.
16:23:01 <dmwit> watermind: Perhaps add --constraint "unix installed" to your cabal install line.
16:23:14 <Modius> Is there a haskell equivalent of F#'s |>  ?  That is, lets you type     someList |> map function  for example
16:23:22 <Modius> (and if it exists is it idiomatically cool to use it)
16:23:39 <dmwit> You can define it yourself.
16:23:45 <dmwit> let x |> f = f x
16:23:48 <JoeyA> >>> from Control.Arrow ?
16:23:55 <ski> Modius : i've called it `$>' sometimes
16:23:59 <mekeor> dmwit: wo |> is flip ($), right?
16:24:00 <JoeyA> err, that composes
16:24:14 <mekeor> s/wo/so
16:24:16 <JoeyA> > (const [1,2,3] >>> map (+3)) 1
16:24:17 <lambdabot>   [4,5,6]
16:24:22 <Modius> Is it something people idiomatically tend to do in Haskell?  I don't want to trip over myself writing odd looking haskell from the outset.
16:24:23 <JoeyA> (1 is a dummy value here)
16:24:36 <ski> Modius : i don't think it's very common
16:24:43 <JoeyA> Not what I did ;-)
16:24:46 <mekeor> > let (|>) = flip ($) in "foo" |> map toUpper
16:24:48 <lambdabot>   "FOO"
16:26:58 <otters> nice
16:27:14 <otters> :t (>>>)
16:27:15 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:27:54 <misterbeebee> I am trying to write something like:   `foo :: Blah -> Handle -> IO ()`,  that print output to a file, and I want to chain lots of foo functions together, with something like Writer (or RWS) monad.  I can see how to do this with [String] instead of Handle as  `fooS :: Blah -> [String]`  and convert that to use Writer and then print the result of execWriter, but I want to stream output to file as early as possible. Is Writer totally the wro
16:27:55 <misterbeebee> choice, since File IO is not a monoid like [String]?  Or, should I use  "Writer ([String], [String])" an call  "hPut . execWriter" and let laziness do the work for me?
16:28:02 <ski> Modius : i think it would be more common to do `(f . g . h) x' or `f . g . h $ x'
16:28:56 <ski> "... Is Writer totally the wro"
16:29:04 <misterbeebee>  Is Writer totally the wrong choice, since File IO is not a monoid like [String]?  Or, should I use  "Writer ([String], [String])" an call  "hPut . execWriter" and let laziness do the work for me?
16:29:11 <gnoi> `formatTime defaultTimeLocale dateFormat <$> getCurrentTime'  returns time in UTC. How can I get time in UTC+10, for xample?
16:29:12 <misterbeebee> sorry for long paragraph)
16:30:45 <ski> misterbeebee : i think making a big `[String]' and outputting that with one call would be fine
16:31:38 <misterbeebee> Even if I plan to generate megabytes of output, over several minutes of computation? (computation that I hope to optimize, but that's another problem).
16:32:01 <misterbeebee> (Yes, I know I can use Lazy ByteString instead of String, that's not the part I'm worried about.)
16:32:26 <watermind> dmwit: I'll try
16:32:34 <ski> if you generate the `[String]' in an incremental fashion, i think it would work ok
16:32:51 <misterbeebee> OK, I'll try that in part and see if it works.
16:33:18 <ski> (and you may use `Writer' to generate it, if you want to)
16:34:07 <misterbeebee> (I'm have an existing program that passes around a file handle and calls hPutStr  under IO() where needed, and I want to clean up that mess before it gets worse as I had more functonality)
16:34:30 <hpc> misterbeebee: you can use ReaderT Handle IO
16:34:51 <hpc> where the Handle is the file you want to write to
16:34:57 <misterbeebee> ahhh
16:35:16 <hpc> and you have something like
16:35:21 <hpc> write = do
16:35:30 <hpc> er, write s = do
16:35:34 <hpc>   h <- ask
16:35:48 <hpc>   liftIO $ hPutStrLn h s
16:35:59 <hpc> (or hPutStr if you don't want newlines)
16:36:29 <hpc> write :: ReaderT Handle IO ()
16:36:37 <misterbeebee> That totally makes sense. I am writing code to use Reader for the file name, and I was silly in thinking that the output file handle should be Writer)
16:36:49 <misterbeebee> I can actually see how to code that, so I'll try that!
16:37:48 <misterbeebee> (ski's advice might be helpful for an orthgonal issue I have to solve: minimizing the use of IO where not essential.)
16:37:56 <ski> misterbeebee : well, you can use `Writer [String]' or `Writer String' to generate the output, and then a single `hPutStr handle' to push that out
16:38:03 <misterbeebee> yah
16:38:38 <ski> if you only use `handle' here once, then there'sn't much point to using `ReaderT Handle'
16:40:00 <misterbeebee> yeah, but since I already have code that calls to hputStr, I think it's smaller incrementatl code churn to start by changing the "foo handle ..=", "bar handle ... =" code to use the ReaderT Handle, and then change it to use a writer instead of directly calling hPutStr everywhere.
16:40:47 <gnoi> `formatTime defaultTimeLocale dateFormat <$> getCurrentTime'  returns time in UTC. How can I get time in UTC+10, for example?
16:50:57 <bitbucket_> gnoi: Use utcToZonedTime from Data.Time.LocalTime
16:51:26 <Mathnerd314> are there alternatives to System.Timeout?
16:52:43 <c_wraith> Mathnerd314: depends on exactly what you're trying to do.  If you use the IO manager's low-level interface, you can get timeouts in certain cases.
16:56:44 <watermind> dmwit: the option you suggested doesn't seem to parse
16:57:02 <watermind> dmwit: I tried removing the ghc-unix package I had installed but made no difference :S
16:57:55 <ben> Are there any examples or packages using the pipes package for, say, network programming or something?
16:58:01 <marina_-> I want to get in touch with people who actually run some blogs or websites? anyone arround here ? i ' d like him to msg me plz :) thanx
17:01:57 <watermind> 9
17:02:03 <watermind> ops
17:17:41 <donri> ben: stepcut has a http server using pipes-core et al i think
17:18:02 <donri> not pipes "proper" though
17:18:25 <stepcut> donri: yeah, it uses pipes-core and is only proof-of-concept
17:18:57 <donri> a proof of concept is still more than just a concept :)
17:19:01 <stepcut> donri: it currently out performs Warp.. but that will drop a bit when it actually does important things like timeouts :)
17:19:12 <donri> heh
17:20:42 <ben> I was hoping for something that uses pipes proper since the pipes dude seems fairly confident that being a category is more important than the pipes-core stuff
17:20:45 <stepcut> must finish this site so I can work on fun code again
17:21:03 <donri> pipes-core guy claims he fixed the category law issues
17:21:17 <donri> tekmo didn't respond to that though
17:21:44 <stepcut> ben: then pipes-core guy is confident that he fixed those problems. But I am still holding out for pipes proper because it looks like his  solution might be cleaner and somehow more better
17:22:00 <donri> not just better - more better!
17:22:05 * donri teasing
17:22:11 <stepcut> :)
17:22:51 <donri> it would be double plus good if he could actually make a release that handles resource finalization et al
17:23:23 <stepcut> donri: well.. that is the part that he is working on now
17:23:27 <donri> but i guess if we want something half-assed quickly there are many options already ;)
17:23:41 <stepcut> :)
17:24:09 <ben> Maybe we should put snoyberg, tekmo and pipes-core dude into a room and not let them out until they've got the whole thing sorted
17:24:13 <donri> we want wholly assed streaming solutions!
17:24:29 <stepcut> for now I am happy to lock tekmo in a room with no distractions
17:24:30 <donri> ben: or there's just one of them left alive
17:24:34 <hnsz> donri: I hate to do this but you are using et al. incorrectly there
17:24:44 <hnsz> donri: You use that for people.
17:24:46 <donri> i probably am!
17:24:49 <donri> OK
17:24:55 <donri> i want etc instead?
17:25:03 <stepcut> yeah
17:25:04 <hnsz> donri: etcetera works nicely
17:25:18 <donri> but et al makes me look smarter, especially when misused!
17:25:34 <hnsz> donri: It pains me
17:25:38 <donri> ;)
17:26:24 <ben> Did jmillikin ever announce any ambitions to make enumerator more betterer?
17:26:50 <mekeor> more betterer? lol
17:27:38 <ben> Well, I dunno
17:27:39 <donri> we should just get spj or someone to make lazy IO somehow magically "just work" for all scenarios
17:27:48 <donri> pretty please?
17:27:52 <ben> Everybody seemed to enjoy enumerators until snoyberg showed up with conduits
17:28:07 <stepcut> donri: et al is short for et alii. alli is the plural of alio. and alio is latin for garlic. So 'et al.' means 'and garlics'
17:28:19 * stepcut never enjoyed enumerators
17:28:19 <donri> i see!
17:29:04 <ben> stepcut: Where's your pipes-core webserver at, then?
17:29:06 <donri> seems to mean "men and boys"
17:29:08 <donri> sexist latin :(
17:29:23 <stepcut> donri: et alii is men and boys
17:29:52 <stepcut> there is also et alia
17:30:23 <stepcut> which is neutral, and et aliae which is girls and women (and sissy boys)
17:31:04 <donri> sexist ^W queer latin?
17:31:09 <hnsz> it stands for et alia
17:32:10 <hnsz> But I don't speak latin so that is all I can say about it.
17:32:27 <stepcut> hnsz: do you have a source for that? Most places I have seen suggest that et al. is short for the masculine, et alii
17:32:29 <nart> hi
17:32:35 * donri just dislikes "etc" for some reason
17:32:45 <Clint> the inflection hardly matters when you co-opt it for english
17:32:49 <stepcut> but my sources are not trustworthy sources
17:32:50 * ski prefers "&c."
17:32:50 <donri> maybe becasue of how swedes pronounce it
17:32:53 <hnsz> stepcut: A source?
17:33:32 <stepcut> hnsz: nevermind.
17:33:35 * ski sees nart
17:34:50 <Jafet> English has male and female connectors.
17:34:53 <nart> ski: hi =D
17:34:57 <Jafet> This discussion is stupid.
17:35:28 <hnsz> stepcut: et alia for mixed. et alii for masc plural and et et alii for fem plural.
17:35:44 <donri> wiktionary says alia is for "things"
17:35:44 <hnsz> stepcut: so it stands for all
17:35:49 <donri> so i guess i can use that then :D
17:36:35 <nart> ski: i took the liberty to prettify your explanation of what a monad is, http://dl.dropbox.com/u/10443564/monad.html
17:36:45 <Clint> donri: traditionlly you would use et al. if you have a specific list that you're abbreviating, and etc. if you have an indefinite one
17:36:55 <stepcut> donri: cetera is things. alias is others.
17:37:57 <Roolmo> Good night!
17:38:39 <watermind> I don't undertsand what happened... so I upgraded to ghc 7.4.1. Now I've lost emacs mode in Emacs, and I cannot cabal install cabal-install  nor install Agda
17:39:09 <watermind> in emacs if I do M-x haskell- <tab> it doesn't even autocomplete
17:39:28 <shachaf> By "cannot" do you mean that a feeling of "what I'm doing must be immoral" overwhelms you whenever you try to run the command?
17:39:31 <watermind> but I have all the .el files in place as well as emacs configuration, I did not touch any of that
17:39:52 <nand`> speaking of agda, which version should I get for playing around with it? live/git build or some specific version?
17:40:04 <watermind> schlicht: it means this, http://hpaste.org/65916
17:40:11 <watermind> and this: http://hpaste.org/65918
17:40:13 <watermind> :S
17:40:14 <hnsz> donri: Wiktionary doesnt say that
17:40:15 <ski> nart : heh, ok. it's somewhat confused-looking, i suppose; and could use more details and examples
17:40:48 <ski> Roolmo : good night to you too
17:40:50 <watermind> opss shachaf, it means that  http://hpaste.org/65916
17:41:03 <watermind> shachaf: and that http://hpaste.org/65918
17:41:11 <shachaf> watermind: Yes, I saw your links.
17:41:19 <shachaf> Maybe you just need to "cabal update" or something?
17:41:25 <watermind> I did that
17:41:29 <shachaf> Or maybe your installation of GHC is messed up.
17:41:43 <watermind> this is what I have http://download.opensuse.org/repositories/devel:/languages:/haskell:/next/openSUSE_12.1/x86_64/
17:41:45 <nart> ski: ofc, it's just a fast edit of your explanation, just to let me read it in a "nice" way, i still have to understand it and eventually i'll add what it's missing :)
17:42:16 <shachaf> watermind: Oh, you're not installing from the GHC website's package?
17:42:28 <shachaf> watermind: Sounds like you need to install a bunch of packages from there, then.
17:42:50 <shachaf> You're not really providing enough information to be able to give you a useful answer. :-)
17:43:28 <watermind> shachaf: I used the repository from openSUSE
17:43:28 <ski> nart : it's probably best to first understand "monoidal category","monoid in a monoidal category","functor category","the composition monoidal structure on an endofunctor category"
17:43:42 <watermind> shachaf: and I have all of those installed
17:43:54 <ski> nart : you might perhaps also ask Cale for elaboration on the concept
17:58:18 <roconnor> ugh, it took me a long time to understand how a monad is a monoid in the category of endofunctors.
17:59:05 <shachaf> roconnor: That just means you weren't waving your hands enough!
17:59:43 <hnsz> shachaf: you forget incantations
18:00:05 <roconnor> thankfully I understand it now, and was able to use the same idea to show that a lens is a monoidal natural transformation from the category of endofunctors.
18:03:36 <Cale> Eugenia Cheng explains it pretty well on TheCatsters YouTube channel, provided that you have enough of the prerequisites down to follow along.
18:03:37 <stepcut> roconnor: nice
18:04:08 <gwern> @remember JonathanShapiro [on abandoning BitC] "And I *still* don't believe in monads. :-)"
18:04:08 <lambdabot> Okay.
18:04:14 <gwern> @flush
18:04:16 <gwern> http://www.coyotos.org/pipermail/bitc-dev/2012-March/003300.html
18:06:11 <hnsz> cale thanks. I love to watch videos
18:09:56 <ski> gwern :)
18:11:31 <mgsloan> argh!  haskell-src-meta needs a flag in order to use template-haskell-2.7.0.0.  Which means anything that depends on it, and can use template-haskell-2.7.0.0, won't cabal install..  There must be a better solution!
18:13:09 <mgsloan> which further disincentives TH..  Saving some space / avoiding a bit of repetition usually isn't worth the cost of user setup effort
18:16:36 <nart> damn, i'm having an hard time understanding what Eugenia Cheng is saying :S
18:16:51 * hackagebot monad-supply 0.2 - Stateful supply monad.  http://hackage.haskell.org/package/monad-supply-0.2 (GeoffHulette)
18:17:00 <mgsloan> I guess at least cabal install can take flags, so it's not that bad, nvm
18:17:10 <nart> not conceptually but i literally don't understand what she says -.-'
18:17:18 * mgsloan thought people would need to cabal unpack and build and stuff
18:21:58 <blackdog> i'm having a bit of a mental block - is it possible to create a list of things that only share a typeclass with the operation fooalize:: a -> Foo, or should i just create it as [fooalize a, fooalize b, fooalize c] ?
18:22:51 <ski> i presume you mean `map fooalize [a,b,c]' for the former case ?
18:23:16 <blackdog> well, no. because i can't make [a,b,c], because a::A, b::B, c::C
18:23:17 <ben> blackdog: that soun like it requires existentials
18:23:38 <blackdog> where A,B, and C have instances for Foo
18:23:52 <shachaf> blackdog: There's no point in keeping that list when the only thing you're going to do to its elements is fooalize them.
18:23:53 <blackdog> blah. not Foo. for FooCreator.
18:23:55 <ski> yeah, but since you can't have explicit `[exists a. Foo a *> a]', you need to wrap in a datatype
18:24:24 <blackdog> shachaf: i know. it's just a pain having to call it individually on each element.
18:24:35 <shachaf> blackdog: You can't have the list [a,b,c]. You can use an existential type, but there's no real point in your case.
18:24:45 <ski> the best you can do is then `map fooalize [WrapFoo a,WrapFoo b,WrapFoo c]' which might not be that much nicer than `[fooalize a,fooalize b,fooalize c]' to begin with
18:24:54 <blackdog> normally i wouldn't be this anal about it, but it's for an API and i'd like to make it as easy to use as possible.
18:25:01 <shachaf> ski: It's strictly worse, in fact. :-)
18:25:38 <blackdog> perhaps if i structure the creation of a,b,c so the data constructor has an existential there?
18:25:39 <shachaf> blackdog: Maybe with with more context you'd get better answers.
18:25:45 <blackdog> (i haven't used existentials before)
18:26:53 <ski> shachaf : as blackdog gave it yes. maybe not if refactored, though
18:27:02 <shachaf> blackdog: An existential type is often the wrong solution to this problem. But there's not much more we can say without context. :-)
18:27:05 <shachaf> ski: Fair enough.
18:28:10 <blackdog> shachaf: i want to offer a plugin api. the data is coming from JSON, so i'd like to be able to call fromJSON on the incoming arguments, so that the plugin writer can have his arguments be real datatypes, rather than a json hash.
18:28:10 <ski> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
18:28:41 <blackdog> i'm aware that this is very much an OO hacker's pattern :)
18:29:26 <blackdog> my ultimate goal is to remove the burden of checking arguments in the json from the plugin writer
18:29:28 <ski> @where+ existential-antipattern "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
18:29:28 <lambdabot> Done.
18:29:39 <blackdog> that should happen outside
18:30:17 <blackdog> ski: reading the post, but is that enough context?
18:31:02 <shachaf> blackdog: Some concrete code might be helpful if you have some.
18:32:11 <parcs`> an existential won't remove any boilerplate if your class has only one method
18:33:07 <parcs`> actually it will increase boilerplate
18:34:05 <parcs`> instead of [fooalize a, fooalize b, fooalize c] you'll have [AnyFoo a, AnyFoo b, AnyFoo c] then to fooalize them you'll need to map (\(AnyFoo x) -> fooalize x) xs
18:34:32 <ski> .. or modify `fooalize'
18:36:35 <parcs`> ski: what do you mean?
18:36:51 * hackagebot ADPfusion 0.0.1.0 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.0.1.0 (ChristianHoener)
18:38:39 <ski> parcs` : depending, on could put the match on `AnyFoo' inside `fooalize'
18:40:40 <blackdog> shachaf: https://gist.github.com/2190651
18:41:10 <blackdog> i want a way to export waitUntil and periodically so that they can be called generically from outside
18:41:22 <blackdog> i already have fromJSON instances for DateData and PeriodData
18:41:49 <blackdog> (well, technically the equivalent in MessagePack terms, but if i can do it for JSON i can ape it for msgpack)
18:42:43 <blackdog> the external function should see if it can convert the raw json to a PeriodData or DateData value as appropriate for the function being called
18:42:57 <blackdog> but i don't have a way of exporting the functions without having to know the names
18:44:10 <ski> s/export waitUntil and periodically/export oneTime and periodically/ ?
18:46:16 <blackdog> ski: uh, yes. sorry.
18:46:43 <ski> you want a common wrapper type for `periodically' and `oneTime' so that when given "raw json" the former would try to convert it to `PeriodData' and the latter to `DateData' ?
18:46:52 * hackagebot Nussinov78 0.0.1.0 - Nussinov78 using the ADPfusion library.  http://hackage.haskell.org/package/Nussinov78-0.0.1.0 (ChristianHoener)
18:48:31 <blackdog> ski: yes, i suppose so. i guess i can just write a function that does that then export it as "exports = [("periodically", export periodically), ("oneTime", export oneTime)]
18:49:02 <blackdog> barring something really crazy with HINT and reflection and other evil tricks that's probably the best i'm likely to get, yes?
18:49:14 <ski> how do you convert from "raw json" to `PeriodData' respectively to `DateData' ?
18:49:47 <ski> blackdog : not sure
18:50:47 <augur> byorgey: so help me understand how the definition d F X = F (1 + X) satisfies the product law
18:50:59 <blackdog> ski: https://gist.github.com/2190677
18:51:31 <ski>   export :: BlahJSON a => (a -> b -> IO c) -> (JSONData -> b -> IO c)  -- hm ?
18:52:03 <blackdog> ski: yes, i think something like that should work. Thanks!
18:52:22 <blackdog> it's always a bit of a shock trying to port a system design from ruby to haskell:)
18:52:27 <byorgey> augur: from a combinatorial point of view, or explicitly starting from that definition?
18:52:54 <augur> byorgey: well my understanding is that with species, thats just the definition of d
18:53:03 <blackdog> Hey, straw poll: how many of you are currently working with Haskell in a professional capacity, and (possibly more importantly from my perpective) who isn't, but would like to be?
18:53:03 <augur> byorgey: so .. im not sure what you mean by or there :)
18:53:13 <ski> blackdog> :t pack
18:53:18 <ski> blackdog> :t tryUnpack
18:53:28 <blackdog> telecommuting would be a possibility, but living in sydney or SF would be ideal.
18:53:29 <byorgey> augur: well, I mean, do you want to understand it on an intuitive level, or on an algebraic level?  or both?
18:53:45 <augur> byorgey: algebraic
18:53:48 <augur> i think i get the intuitive level
18:53:55 <augur> im just failing to get the algebra to work out
18:54:16 <blackdog> ski: oh, it's in the messagepack library. hold on.
18:55:14 <byorgey> augur: ok, let me think for a minute
18:55:22 <shachaf> blackdog: I briefly worked with Haskell in a professional capacity! The project we worked on didn't end up working so well, but that wasn't particularly because of Haskell.
18:56:20 <byorgey> augur: ah, the problem is that is NOT the definition of differentiation.
18:56:28 <augur> byorgey: isnt it?
18:56:33 <byorgey> augur: the distinction is a bit subtle, let me think about how to explain it.
18:57:03 <augur> or does it have to do with the label stuff
18:57:21 <byorgey> yes, it does
18:57:27 <augur> ah ok nevermind then :)
18:57:32 <byorgey> F (1 + X)  means the species F composed with the species (1 + X)
18:57:54 <augur> ya, no, i get it now
18:57:57 <augur> or i get it enough
18:58:07 <blackdog> ski: sorry, fatfingered and killed the window
18:58:10 <blackdog> unpack :: (Unpackable a, IsByteString s) => s -> a
18:58:20 <blackdog> tryUnpack :: (Unpackable a, IsByteString s) => s -> Either String a
18:58:24 <byorgey> which is not the same as saying that the action of F' on a set of labels U is the action of F on U adjoined with an extra distinguished element
18:58:39 <ski> and `pack' ?
18:59:01 <byorgey> basically, the latter means that the distinguished element must occur exactly once, whereas in the former, the unit element can occur any number of times
18:59:02 <blackdog> pack :: Packable a => a -> Data.ByteString.Lazy.Internal.ByteString
18:59:24 <byorgey> augur: just like   Tree (Maybe a)  can contain multiple Nothings, but Tree' a  contains exactly one hole
18:59:34 <augur> byorgey: right, no i get it now.
18:59:38 <byorgey> ok.
18:59:43 <augur> i was thinking wrong about differentiating species :p
18:59:49 <augur> i forgot it was all about the labels
18:59:53 <byorgey> fair enough =)
19:00:32 <byorgey> thinking wrongly about species is very easy for functional programmers, because they are very like algebraic data types but subtly different in some key ways.
19:01:00 <byorgey> and I include myself in that.
19:01:18 <blackdog> shachaf: right. sorry i dropped out.
19:01:22 <byorgey> right now I am trying to tease out a precise statement of the relationship.
19:01:34 <blackdog> (am not asking because i want a job, i'm looking to hire soonish)
19:01:55 <blackdog> anyway, gotta run. if anyone's interested and good, i'm mark@ninjablocks.com
19:02:48 <ski> byorgey : reminds me of <http://blog.sigfpe.com/2006/09/infinitesimal-types.html>
19:04:35 <byorgey> ski: ah, very interesting, I didn't know about that post
19:05:36 <byorgey> yeah, I really think there might be some very interesting connections between SDG, linear types, and species...
19:07:34 <ski> blackdog : ok, i suppose wrapping in a closure with `export' might be enough here -- in general, GADTs can sometimes help with things like this
19:11:53 * hackagebot HMM 0.2.1 - A hidden markov model library  http://hackage.haskell.org/package/HMM-0.2.1 (MikeIzbicki)
19:21:04 <nathanel_> @pl \(x, y) -> (x, y + 1)
19:21:05 <lambdabot> second (1 +)
19:21:50 <maloi> :t second
19:21:51 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
19:22:21 <ski> also `fmap (+ 1)'
19:22:27 <maloi> hmm is it worth it?
19:22:36 <ski> @type \f x -> second f x
19:22:37 <lambdabot> forall b c d. (b -> c) -> (d, b) -> (d, c)
19:25:59 <lispy> I have a library here that uses DatatypeContexts.  Compiles cleanly on ghc 7.4.1 on OSX, but on Ubuntu ghc 7.4.1 complains and says to use -XDatatypeContexts.
19:26:22 <lispy> If I build a minimal test case, I can get the DatatypeContexts errors on OSX
19:26:41 <lispy> I built this thing with --verbose=3 and I don't see that extension being passed to ghc
19:26:54 <lispy> This is quite puzzling.  A bug in the osx release of ghc perhaps?
19:29:02 <JoeyA> Quick glance at the documentation: "In GHC this feature is an extension called DatatypeContexts, and on by default."
19:29:31 <JoeyA> (that probably wasn't very helpful)
19:30:25 <parcs`> is that old documentation? DataTypeContexts isn't on by default any more
19:33:12 <JoeyA> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/data-type-extensions.html
19:37:02 <parcs`> hmm data Num a => A a => A a ---> "Illegal datatype context (use -XDatatypeContexts): Num a =>"
19:42:29 <lispy> I've been told it's no longer on by default
19:43:53 <lispy> What I'm confused by is why my library builds on this machine but not on other machines with 7.4.1
19:44:01 <lispy> I can make examples that give the error
19:44:23 <lispy> But this library gets accepted and I don't see the extension getting enabled when I use --verbose
19:44:47 <nathanel_> the "second" from the Arrows library is probably not what i was looking for... i want to adjust the values from tuples before passing them to the array constructor
19:50:06 <ski> nathanel_ : adjust both components by the same function ? by different functions ?
19:50:40 <nathanel_> just the second component
19:51:54 * hackagebot hmm 0.2.1 - A hidden markov model library  http://hackage.haskell.org/package/hmm-0.2.1 (MikeIzbicki)
19:54:00 <zzo38> Are there any Haskell libraries for typesetting other than my own one? Someone told me HPDF. HPDF does not even have any Applicative instances as far as I can see.
19:54:16 <zzo38> Is that only ones?
19:54:44 <tgeeky_> zzo38: there are probably several LaTeX ones
19:55:07 <zzo38> My own library is based on DVI and TFM.
19:55:19 <zzo38> It can read and write DVI files, and can read TFM files.
19:56:20 <zzo38> Do you know what is a Haskell code for printing to go through a system printer driver such as Windows printing and so on?
19:56:53 <zzo38> I want to include a module for that purpose in my dvi-processing package so that you can use that to print a DVI file
19:59:49 <tgeeky_> zzo38: that I don't know about.
19:59:58 <tgeeky_> zzo38: maybe the Win32 package?
20:01:31 <zzo38> But I want the package to be usable on UNIX as well (even if you cannot use the system printer drivers on UNIX, the rest of the stuff should be allowed to work)
20:03:08 <lispy> hmm...I wonder if the check for datatype contexts doesn't work well with kind checking
20:03:24 <zzo38> And I do not see stuff in Win32 package for printing, anyways.
20:07:14 <zzo38> Make the list of Haskell Ephemeris ID numbers, including planets, dwarf planets, sun, moon, satellites, asteroids, fixed stars, artificial objects, fictitious objects, etc
20:08:57 <tgeeky_> ... that was quite a jump.
20:09:34 <zzo38> There is no Haskell Ephemeris but I want to make it up
20:09:52 * lispy grumbles about needing an extension to fix this code just because DatatypeContexts is now off
20:10:09 <tgeeky_> lispy: will you type the offending code again?
20:10:17 <tgeeky_> I saw two (=>)'s in it?
20:10:26 <lispy> -XDatatypeContexts is awfully new, so I'd rather not use it lest I berak older ghcs
20:10:41 <lispy> tgeeky_: it's the OpenGL code 2.5.0.0
20:10:57 <lispy> tgeeky_: works for me on OSX, but broken on some platforms (even though ghc version is the same)
20:11:27 <lispy> But, when I remove the datatype context it changes kind inference.  Which then breaks other things
20:11:43 <lispy> But, specifying a kind signature means using an extension too
20:11:55 <tgeeky_> weird!
20:12:08 <tgeeky_> lispy: 7.4.1 and 7.2.2 docs both say it's on by default
20:13:14 <lispy> tgeeky_: try an example, data (Functor f) => Blah f = Blah f
20:14:07 <lispy> It wouldn't be the first time the ghc docs are out of date, FWIW
20:15:15 <tgeeky_>     Warning: -XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language.
20:15:45 <zzo38> Datatype contexts doesn't even work anyways, as far as I know.
20:16:02 <lispy> tgeeky_: only a warning, which ghc version?
20:16:06 <BlankVerse> is there any disk based data structure library in haskell?
20:16:18 <tgeeky_> lispy: 7.2.1
20:16:18 <lispy> tgeeky_: for me it's a failure, unless I compile OpenGL then it's not even a warning
20:16:27 <lispy> tgeeky_: oh, well try with 7.4.1
20:16:32 <tgeeky_> lispy: ok, one sec
20:16:48 <BlankVerse> I want to build a btree (disk based) and wanted to look into design of such class of data structures
20:20:28 <tgeeky_> lispy: ok. on 7.2.2, it warns about DatatypeContexts, and fails to compile still after I turn it on (in ghci)
20:20:40 <tgeeky_> ok 7.4.1, it does compile after I turn the flag on (in ghci)
20:21:01 <lispy> tgeeky_: which flag?
20:21:07 <tgeeky_> lispy: DatatypeContexts
20:21:17 <lispy> oh, so the documentation is wrong
20:21:30 <tgeeky_> lispy: and, something is wrong with 7.2.1
20:22:15 <tgeeky_> at least, ghci in 7.2.1
20:22:18 <lispy> Wait, what is wrong with 7.2.1?
20:22:33 <lispy> In 7.2.1 datatype contexts were on but deprecated
20:23:31 <tgeeky_> lispy: yeah, GHCI is forgetting that I set it, or something. I do: ghcii.sh test.hs ... (warns about DatatypeConexts) ... :set -XDatatypeContexts ... :r ... still fails to compile, warns again
20:23:55 <tgeeky_> lispy: if I set it in the file (with a LANGUAGE pragma) it sticks
20:23:59 <zzo38> tgeeky_: I think to use it in loaded files you have to use -X on the command-line parameters not :set
20:24:22 <zzo38> :set is only for the codes typed interactively
20:24:38 <tgeeky_> really? hmmmmm
20:24:44 <tgeeky_> I think that's wrong... anyone?
20:24:49 <zzo38> At least, this is as far as I know.
20:24:56 <tgeeky_> I'm not sure, though.
20:25:35 <tgeeky_> lispy: anyway, yes, it's 7.4.1 wrong on docs
20:25:59 <tgeeky_> lispy: I bet it says 7.4 in whatever ticket is associated with deprecating datatypecontexts
20:26:56 * hackagebot first-class-patterns 0.3.1 - First class patterns and pattern matching, using type families  http://hackage.haskell.org/package/first-class-patterns-0.3.1 (ReinerPope)
20:27:37 <tgeeky_> next thing you know, patterns will have their special TSA-screening free security lines
20:28:02 <lispy> http://hackage.haskell.org/trac/ghc/ticket/5964
20:28:50 <tgeeky_> lispy: yeah, get em!
20:29:09 <tgeeky_> lispy: in before <fixes documentation, still no help to you>
20:34:06 <blackdog> ski: mildly amused that my project now has the line "import Export" at the top :)
20:45:07 <BlankVerse> anyone knows about ADQL.BinaryUtils?
20:45:21 <parcs`> wow, bindings-dsl is awesome
20:46:59 <parcs`> it could probably be improved, though. ideally a program could parse a c header file and autogenerate haskell bindings, right?
20:53:34 <dmwit> parcs`: You mean like what c2hs does?
20:54:40 <parcs`> whoa
22:08:15 <yasar> I want to write a new data type like this "data compressedUnit a", but I want a to be (Eq a), where do I spesify this?
22:08:39 <shachaf> yasar: In the functions that use your type.
22:09:07 <yasar> Ok, thanks.
22:09:29 <mzero> like      swizzleCompressed :: Eq a => CompressedUnit a -> CompressedUnit a
22:19:34 <SHAILANDRA> Hi
22:19:54 <SHAILANDRA> i m a newbie to haskell , help me
22:22:54 <mzero> sure - what's up?
22:23:19 <mzero> SHAILANDRA: what do you need help with
22:26:39 <SHAILANDRA> sir, i m new to haskell
22:26:48 <SHAILANDRA> tell me the starting poing
22:26:52 <SHAILANDRA> tell me the starting point
22:27:55 <mzero> @LYAH
22:27:55 <lambdabot> Unknown command, try @list
22:28:03 <mzero> @where LYAH
22:28:03 <lambdabot> http://www.learnyouahaskell.com/
22:28:07 <mzero> that is the starting point
22:28:09 <mzero> start there
22:28:47 <yasar> can somene see what am I doing wrong here?
22:29:08 <SHAILANDRA> ya ,thanks mzero
22:29:10 <mzero> no, somehow your screen isn't being cast into the channel!
22:29:18 <mzero> :-)
22:29:28 <mzero> yasar: what's up?
22:29:30 <yasar> in that case: http://codepad.org/eVW1dvrA :D
22:29:38 <SHAILANDRA> but , listen: mzero - i have the knowledge of "perl
22:29:59 <SHAILANDRA> so, is there any co-relation between "perl" and "haskell"
22:30:05 <yasar> I sometimes forget pasting links :)
22:30:20 <mzero> SHAILANDRA: not any more or less than most other languages and Haskell
22:30:34 <mzero> keep your mind open - things in Haskell are quite a bit different than in Perl
22:30:44 <SHAILANDRA> ok .....
22:30:46 <mzero> but you'll get it if you just follow that tutorial
22:31:00 <mzero> yasar: you're using Hugs?
22:31:04 <SHAILANDRA> ya , the nitty-gritty of haskell tell the same thing
22:31:09 <NihilistDandy> mzero: codepad uses hugs
22:31:17 <mzero> ah
22:31:19 <mzero> never mind
22:31:22 <SHAILANDRA> hey , is the "interpretar" of haskell"
22:31:23 <yasar> mzero:no, I am using ghci.
22:31:24 <mzero> but I'm looking at the code
22:31:26 <NihilistDandy> yasar: It looks like you're calling concat on a list instead of a list of lists
22:32:16 <mzero> no, it looks like a list of lists to me     myhelper :: CompressedUnit a -> [a]
22:32:31 <NihilistDandy> Oh, so it is
22:33:20 <mzero> ha
22:33:47 <mzero> yasar:    you either want         decode cs = concat $ map myhelper cs
22:34:03 <mzero> OR you want     decode = concat . map myhelper
22:34:39 <mzero> does that make sense?
22:36:05 <mzero> yasar: the later is "point free" form
22:36:29 <yasar> wait, I am trying to get it :)
22:37:06 <mzero> the first is easier --- you left off the argument to decode
22:37:20 <yasar> what is the difference between "decode cs = concat $ map myhelper cs" and "decode = concat $ map myhelper"
22:37:30 <mzero> the cs arguments
22:37:58 <yasar> I thought if I could left it out, if it's the last thing a use
22:38:10 <mzero> read it as     "to decode a list of cs,  concat the result of mapping myhelper over that list cs"
22:38:36 <mzero> but you have that $  in there  --- which is applying concat to everything on the right
22:38:37 <danharaj> your second example is decode = concat (map myhelper)
22:38:46 <danharaj> You want (.), not ($)
22:38:50 <mzero> everything on the right in      concat $ map myhelper      is     map myhelper
22:38:59 <monochrom> concat wants a list. in "concat (map f cs)", the list is (map f cs). in "concat (map f)", the list is (map f), which makes no sense.
22:39:14 <mzero> and     map myhelper      is a  function from lists to lists      ---- you can't concat *that*
22:39:16 <monochrom> and yes you will gain much understanding by never using $ again.
22:39:28 <danharaj> I am not a fan of $ tbh.
22:40:47 <yasar> So it is like, if I use $, I can't use point free form?
22:41:31 <monochrom> to transition properly to omitting cs, first rewrite "g cs = concat (map f cs)" to "g cs = (concat . map f) cs", then you can omit cs on both sides
22:41:31 <mzero> oy - silly IRC client
22:41:42 <danharaj> @pl f x y = y x
22:41:42 <lambdabot> f = flip id
22:42:17 <danharaj> huh.
22:43:15 <danharaj> I'm not gonna lie I don't get it.
22:44:10 <mzero> ah - the ol' "mind flip'd by flip id"
22:44:20 <danharaj> ok I get it now.
22:44:37 <monochrom> f x y = y x. f x y = id y x. (think of it as ($) y x.) f x y = flip id x y. f = flip id.
22:44:45 <mzero> I mean "flip id" --- why wouldn't you expect that to blow your mind?
22:44:56 <danharaj> yes indeed I was expecting (flip ($)).
22:45:27 <danharaj> Does GHCi have a display for how it derives a type signature?
22:45:36 <monochrom> no
22:45:38 <danharaj> It'd be cool to see the proof.
22:45:46 <danharaj> (in general)
22:45:51 <danharaj> So I don't have to do it in my head :3
22:46:51 * mzero thinks seeing H-M type inference displayed would probably flip id his mind...
22:54:34 <Sgeo_> :t flip id
22:54:35 <lambdabot> forall a b. a -> (a -> b) -> b
22:54:48 <Sgeo_> :t flip ($)
22:54:49 <lambdabot> forall a b. a -> (a -> b) -> b
23:17:05 <danharaj> What's a good overview of all the new kinding machinery in GHC?
23:17:21 <danharaj> I have an idea I want to mangle into an implementation.
23:27:28 <nyingen> in Data.Ratio, (%) looks like the constructor for Ratio objects, but it can't be pattern-matched on. Looking at the source code, I see that :% is the true constructor, but it's not exported. Why is this?
23:28:47 <Sgeo_> Hmm, how are Ratios represented?
23:28:58 <shachaf> nyingen: The type probably has some invariants.
23:29:11 <Sgeo_> Does 2 :% 2 exist when you do 2 % 2, or does (%) do the actual simplification?
23:29:19 <shachaf> E.g. a Ratio is stored in reduced form.
23:29:39 <shachaf> Sgeo_: % does.
23:29:45 <shachaf> > 2 % 2
23:29:46 <nyingen> I also don't see a definition for (%) in the source for the module, only a type declaration
23:29:46 <lambdabot>   1 % 1
23:29:51 <nyingen> er, type signature
23:30:02 <Sgeo_> shachaf, that's totally not proof, show could be doing the simplification
23:30:03 <nyingen> shachaf: what do you mean by invariants?
23:30:07 <mzero> Right   :% would be a constructor - which couldn't do any computation at all
23:30:07 <Sgeo_> (Although admittedly this would be stupid)
23:30:24 <mzero> @src (%)
23:30:25 <lambdabot> x % y = reduce (x * signum y) (abs y)
23:30:30 <mzero> and there's the answer
23:30:58 <shachaf> nyingen: I see (%)'s definition in GHC.Real
23:31:06 <shachaf> grep '(%)' won't find it because it's defined infix, but it's there.
23:31:21 <nyingen> ah
23:31:28 <nyingen> shachaf: I see it now
23:31:33 <mzero> and it wouldn't be stupid to define it in such a way that reduction is only done on printing
23:31:40 <shachaf> Anyway, you can probably get a view pattern if you really want to pattern-match on it.
23:31:50 <Sgeo_> nyingen, some things about the data structure are assumed to be true although not enforced by the type system alone
23:31:51 <mzero> doing a chain of operations, it may not be worth it to simplify on each step
23:32:09 <Sgeo_> One thing is that the two Integrals making it up do not make up a rational that can be reduced further
23:33:47 <shachaf> Aw, I was about to talk to mzero.
23:34:18 <nyingen> Sgeo_: ah, thanks. I think I get it now
