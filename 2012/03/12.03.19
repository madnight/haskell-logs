00:01:29 <koala_bot> argh
00:05:37 * hackagebot unification-fd 0.7.0 - Simple generic unification algorithms.  http://hackage.haskell.org/package/unification-fd-0.7.0 (WrenThornton)
00:07:01 <koala_bot> is there a simple way to see if a string contains some substring?
00:08:07 <Jafet> :t isInfixOf
00:08:08 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
00:08:12 <Saizan> > "bar" `isInfixOf` "foobarbaz"
00:08:13 <lambdabot>   True
00:08:23 <koala_bot> thank you
00:09:59 <koala_bot> Where is that? I get "not in scope"
00:10:26 <Saizan> Data.List
00:10:37 <ion> @hoogle isInfixOf
00:10:37 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
00:10:37 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
00:10:38 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
00:11:18 <koala_bot> Didn't think I'd have to import that one.
00:20:37 * hackagebot palindromes 0.2.2.1 - Finding palindromes in strings  http://hackage.haskell.org/package/palindromes-0.2.2.1 (JohanJeuring)
00:27:08 <koala_bot> I'd like to make a func URI -> URI -> Bool which compares tie uriAuthority of each argument and returns whether or not they are equal, but how do I get access to those properties?
00:29:25 <Saizan> f x y = uriAuthority x == uriAuthority y
00:31:10 <koala_bot> so in general those just work as function?
00:31:20 <Saizan> yep
00:31:38 <koala_bot> huh. I had no idea. thank you very much :)
00:43:29 <kaitocracy> hi this "ambiguous type variable" business is killing me and I don't know what to do
00:43:38 <kaitocracy> I'm trying to write a library like blaze-html for practice
00:43:51 <kaitocracy> and I've turned on OverloadedStrings
00:44:02 <kaitocracy> but now ghc is throwing ambiguous type variables all over the place
00:45:16 <c_wraith> kaitocracy: It just means there isn't sufficient context to identify the expected type of the string literals
00:45:37 <ChristianS> kaitocracy: add type signatures to your top-level functions. usually that should be sufficient.
00:45:48 <c_wraith> kaitocracy: In particular, in places where it needs to know the type to select what instances to use
00:47:27 <kaitocracy> I tried that but it's still not working right, let me put up my code
00:47:55 <hpaste> kaitocracy pasted “Blaze-Like” at http://hpaste.org/65557
00:48:14 <kaitocracy> okay so my main is all the way down at the bottom
00:48:30 <kaitocracy> and there are a couple of files that are separated by a bunch of ----'s
00:49:27 <ChristianS> kaitocracy: try giving  test  a type sig.
00:50:05 <kaitocracy> ChristianS: yeah that makes it work but I'd like it to work without giving it a type sig
00:50:11 <kaitocracy> somehow blaze-html can do that
00:51:54 <kaitocracy> the error is because the literal "content" must satisfy both Data.String.IsString and my Element.HTML
00:52:27 <ChristianS> kaitocracy: well, either you don't use "LANGUAGE OverloadedStrings", than it's clear that "content" is a String, or else you must give some additional hint whether it should be e.g. a Text or a String.
00:53:03 <ChristianS> anyway, type sigs are good style anyway.
00:53:43 <kaitocracy> is there any way I can tell it which to default to?
00:53:50 <ion> Perhaps something like instance IsString (MyHtml ()) (instead of MyHtml a) and h1 :: MyHtml () -> MyHtml ()
00:55:30 <kaitocracy> ion: sorry I'm a bit of a haskell noob, what does that do?
00:56:38 <ion> I didn’t actually look at your problem (i’m a bit busy), i just guessed that the ambiguous type variable errors might have come from something like an unspecified “a” in “MyHtml a” that could be () instead.
00:57:43 <kaitocracy> ion: oh no basically I have OverloadedStrings and one of my arguments must satisfy two typeclasses
00:57:47 <kaitocracy> and ghc is flipping out
00:58:25 <Saizan> the problem is not that there are 2 typeclasses that it must satisfy
00:58:41 <sohum> @pl \x y -> f (g x y)
00:58:42 <Saizan> just one would give you the same problems
00:58:42 <lambdabot> (f .) . g
01:00:26 <kaitocracy> Saizan: ??? I'm confused the error is http://pastebin.com/t0dQSwWL
01:00:28 <mauke> The paste t0dQSwWL has been copied to http://hpaste.org/65559
01:02:52 <Saizan> kaitocracy: maybe you want {-# LANGUAGE NoMonormorphismRestriction #-} as suggested in the message
01:03:14 <kaitocracy> Saizan: already did that and it didn't work
01:03:53 <Saizan> kaitocracy: in all the files?
01:03:59 <koala_bot> I would like to use relativeTo to get an absolute URI for what was previously only relative, but need the resulting absolute URI to be a String. How can I do this?
01:04:37 <hpaste> cemycc pasted “Pol” at http://hpaste.org/65560
01:04:39 <kaitocracy> Saizan: well I threw on -XNoMonomorphismRestriction
01:04:58 <Saizan> kaitocracy: ah, no, it wouldn't help because of main
01:05:16 <Saizan> kaitocracy: your only was is to add type annotations for test
01:05:37 <cemycc> I have this code http://hpaste.org/65560 I am trying to write the sum of polynomials but when I run that I get a error:  Couldn't match expected type `Term' with actual type `Int -> Term'
01:05:49 <cemycc> Someone can take a look at that code and tell me what I do wrong on the last line ?
01:07:09 <cemycc> sorry, the last line is: | cf a == cf b = (Term(cf a + cf b, ex a)) : (sumTerms as bs)
01:08:56 <ClaudiusMaximus> cemycc: you probably want something like   Term{ cf = cf a + cf b, ex = ex a }  or  Term (cf a + cf b) (ex a)  instead of Term (..., ...)
01:09:15 <cemycc> ClaudiusMaximus, oh thank you :)
01:13:21 <koala_bot> Does anyone know how I can return a URI as a String?
01:15:37 <osa1> what are differences between data.text and strings?
01:17:41 <Peaker> osa1: Data.Text and String?
01:18:26 <osa1> Peaker: yes
01:18:28 <Peaker> osa1: Data.Text uses an efficient representation, String uses a list of Char.  The main differences are much better performance for Text, but easier to work with lists (thus with String)
01:23:29 <augur> whats a graph whos edges have multiple in nodes?
01:24:19 <danr> a graph where two nodes can have more than one edge is usually called a multigraph
01:25:12 <Philonous> Is there there an equivalent of the Show class for Text?
01:26:36 <earthy> philonous: why would you want that?
01:27:25 <augur> danr: no no, not where multiple edges connect the same nodes
01:27:38 <augur> but where a single edge can have multiple in or out edges
01:28:00 <danr> ah
01:28:02 <danr> augur: a hypergraph
01:28:04 <earthy> philonous: as pack . show is perfectly valid
01:28:18 <danr> augur: http://en.wikipedia.org/wiki/Hypergraph
01:28:22 <augur> danr: hyper graphs are undirected tho, as far as i know, so the edges are just sets
01:28:35 <earthy> philonous: and not the magic 'subject to fusion'
01:28:45 <earthy> s/not/note/
01:30:06 <Philonous> earthy:  Fair enough.
01:31:18 <danr> augur: there are directed hypergraphs, where one set of nodes in an edge are sources and another which are target
01:31:33 <danr> augur: http://gdea.informatik.uni-koeln.de/585/1/hypergraph.ps
01:34:46 <augur> danr: hmm!
01:36:31 <astor> how can I create an alias for constraints so that instead of writing (A a, B a b c, C d a f, ...) => a -> b -> c ... I can write (X a b c d) => a -> b -> c ...
01:38:14 <Saizan> yes, either with ConstraintKinds in newer ghc's or UndecidableInstances
01:38:41 <Saizan> with ContraintKinds it'd just look as a type synonym iiuc
01:39:45 <Saizan> with UndecidableInstances you declare X as a new class with (A a, B a b c, C d a f, ...) as superclass constraints and then make the corresponding instance
01:51:45 <astor> Saizan: ConstraintKinds is what I want - unfortunately it is rather new.
02:15:49 <randomclown> http://hpaste.org/65562.3
02:15:51 <randomclown> http://hpaste.org/65562
02:15:57 <randomclown> what's the proper way to do this?
02:18:00 <randomclown> I have this data Coord = Coord Int Int deriving (Show, Eq) -- x,y coordinates
02:18:08 <randomclown> and this
02:18:08 <randomclown> data Instruction = Plant Coord | Farm Coord | DigUp Coord
02:18:20 <randomclown> I want to pattern match something like this
02:18:20 <randomclown> boundsValidate insn@(_ (Coord x y))
02:19:02 <randomclown> but I can't because of the type constructor
02:19:11 <randomclown> is there a way to wildcard the type constructor
02:19:27 <ClaudiusMaximus> data OpCode = Plant | Farm | DigUp ; data Instruction = Instruction OpCode Coord  -- perhaps
02:20:02 <randomclown> Ah of course
02:20:48 <Philonous> http://hpaste.org/65562
02:20:53 <ClaudiusMaximus> or data Instruction = Plant{ coord :: Coord } | Farm{ coord :: Coord } ...   ; boundsValidate ins = let Coord x y = coord ins in ...
02:21:54 <Philonous> With view patterns you can write "boundsValidate insn@(toCoord -> c) = ..."
02:27:09 <ChristianS> or, with pattern guards boundsValidate insn | c <- toCoord insn = ..., i would presume
02:27:41 <ChristianS> personally, i prefer pattern guards since i find them more readable and they are standard Haskell 2010.
02:55:43 * hackagebot snap-core 0.8.0.1 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.8.0.1 (GregoryCollins)
02:55:45 * hackagebot snap-server 0.8.0.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.8.0.1 (GregoryCollins)
02:55:55 <randomclown> should I use tuples or a strict pair for an array index?
02:57:13 <nart> hi
03:00:15 <miloneuss> hi nart
03:10:37 <timthelion> What is the difference between cross here http://www.muitovar.com/gtk2hs/chap6-1.html and zip?
03:13:11 <quicksilver> timthelion: cross gives you every possible pair
03:13:26 <quicksilver> > [ (x,y) | x <- [1,2,3], y <- [4,5,6] ]
03:13:27 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
03:13:34 <quicksilver> > zip [1,2,3] [4,5,6]
03:13:35 <lambdabot>   [(1,4),(2,5),(3,6)]
03:15:03 <timthelion> how does it do that?  To me the arrows are entirely opaque in their meaning.
03:15:24 <merijn> timthelion: monad instance of list
03:15:57 <timthelion> How do I figure out what it does by looking at the code?
03:16:25 <merijn> :i [] (>>=)
03:16:44 <merijn> :i (>>=) []
03:16:47 <astor> I wish I could remove [] from being an instance of Monad to simplify error messages
03:16:50 <merijn> I forget >.>
03:17:54 <timthelion> merijn: I think that some of the bots may be down.  At least where I am, irc.freenode.net is down.
03:18:07 <timthelion> it shows up in ghci
03:18:11 <merijn> timthelion: You have to look up the meaning of >>= for the relevant monad instance. In general "do {x <- value; foo x}" desugars to "value >>= \x -> foo x"
03:18:18 <merijn> Lambdabot appears to be here, though
03:18:20 <rostayob> @src [] (>>=)
03:18:21 <lambdabot> xs >>= f     = concatMap f xs
03:18:28 <merijn> Ah, that's the one
03:18:51 <quicksilver> timthelion: that's basically what the list monad means "take every possible combination"
03:18:59 <timthelion> ok
03:19:00 <ChristianS> @undo [ (x,y) | x <- [1,2,3], y <- [4,5,6] ]
03:19:01 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [4, 5, 6]) [1, 2, 3]
03:19:26 <timthelion> I prefer the version where concatMap is actually written out long hand.
03:19:58 <merijn> timthelion: You can parse the arrows in the list monad the same as in list comprehensions. i.e. "for each x, for each y, do f"
03:23:41 <hpaste> koala_bot annotated “Update: Sitemap Generator” with “Sitemap Generator” at http://hpaste.org/65547#a65564
03:23:53 <koala_bot> Can anyone see why my final list contains duplicates/
03:23:57 <koala_bot> duplicates*
03:25:22 <ChristianS> koala_bot: hm, to avoid duplicates, you could probably just use a Data.Set?
03:25:48 <koala_bot> I'm pretty new to Haskell - is it more complicated to work with than the typical List type?
03:26:22 <ChristianS> koala_bot: no, except that you can't pattern match.
03:26:40 <quicksilver> well even though you could avoid duplicates using a Set, probably it's good to understand where the duplicates come from
03:27:13 <koala_bot> yeh. THe deadline for this project is in 6 hours or so and I still have to write a 20 page report so I"m hoping for minimal adjustments :)
03:28:14 <ChristianS> here's the set api, in any case: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Set.html
03:28:14 <quicksilver> the classic error on avoiding duplicates in a tree traversal is where the left branch and right branch run independently and so aren't aware of duplicates "in each other"
03:28:21 <quicksilver> not sure if that's the mistake you've made
03:29:51 <koala_bot> I'm not using a Tree structure so I'm not sure how that would have happened :)
03:29:54 <koala_bot> Christian, thank you
03:30:35 <quicksilver> looks to me, koala_bot, like you check against duplicates in "visited"
03:30:49 <koala_bot> theoretically yes :)
03:30:53 <quicksilver> but you don't stop duplicates building up in the first paramter to crawl
03:30:53 <koala_bot> that's why I'm so baffled
03:31:00 <quicksilver> the "u:us" part
03:31:04 <koala_bot> hmmm.....
03:31:13 <quicksilver> so the same URL can get added twice into that part
03:31:20 <quicksilver> before it's ever gone into visited
03:31:30 <quicksilver> (it doesn't go into visisted until you actually visit it, I think)
03:31:50 <koala_bot> it goes into visited in crawl
03:32:26 <koala_bot> ineresting. I'm pventing it from parsing the URL twice but I'm not actually preventing it from being added to the list it would seem
03:36:28 <danr> randomclown: annotated your paste http://hpaste.org/65562
03:36:59 <ChristianS> koala_bot: while quicksilver is right (it's better to understand the algorithmic problem than just work around it), i would still think that Set is the better data structure here since filtering a list before every insert to avoid duplicates is expensive.
03:37:36 <randomclown> thankd danr
03:37:39 <randomclown> thanks*
03:37:45 <koala_bot> It may be but luckily the point of this assignment isn't to optimize but rather become familiar with the functional programming paradigm and more specifically with Haskell's various syntactical goods :)
03:38:07 <koala_bot> Also I'm a bit short on time (and brain power - I've been at this for about 18 hours) to change data structures now
03:38:15 <koala_bot> A shame, but only so much I can do
03:38:22 <danr> randomclown: although that approach only works when your constructors have all exactly the same arguments, it is usally _the right thing_ to do when all are equal
03:40:19 <astor> does anyone know whether ghc builds cleanly with make -jX?
03:40:48 * hackagebot stringbuilder 0.1.0 - A monadic builder for multi-line string literals  http://hackage.haskell.org/package/stringbuilder-0.1.0 (SimonHengel)
03:43:11 <ClaudiusMaximus> astor: works for me (where X is 4)
03:43:33 <Guest67868> guest
03:43:36 <CHRIS_> wut
03:43:50 <CHRIS_> hai guys
03:43:59 <CHRIS_> cameron vague smells
03:44:07 <Guest67868> i like onions
03:46:08 <CHRIS_> CUNTS
03:46:18 --- mode: ChanServ set +o quicksilver
03:46:22 --- mode: quicksilver set +b *!*c3c3eb72@*.195.195.235.114
03:46:22 --- kick: CHRIS_ was kicked by quicksilver (apparently so)
03:46:30 <zachk> thank you quicksilver
03:46:41 <quicksilver> gotta love students
03:47:30 <alistra> who
03:47:34 <alistra> 's cameron vague
03:47:55 <beginnerHaskell> How to read double value in Data.ByteString.Char8 . it contains readInt and readInteger but no readDouble
03:48:06 <quicksilver> someone in the cornwall college undergrad computing class, I imagine. Or one of the teachers.
03:48:37 <quicksilver> beginnerHaskell: http://hackage.haskell.org/packages/archive/bytestring-lexing/0.1.2/doc/html/Data-ByteString-Lex-Double.html perhaps
03:49:47 <beginnerHaskell> quicksilver: Thank you
03:50:15 <beginnerHaskell> quicksilver: but why this function is not part of Data.ByteString.Char8 (  Just curious )
03:50:36 <quicksilver> no reason, beginnerHaskell
03:50:49 <quicksilver> just keeping the API simple I suppose
03:51:30 <beginnerHaskell> quicksilver: thanks again :)
03:52:50 <ChristianS> beginnerHaskell: you could also unpack to String and use read
03:52:52 <ChristianS> > read "3.14" :: Double
03:52:53 <lambdabot>   3.14
03:53:14 <randomclown> :t evalstate
03:53:15 <lambdabot> Not in scope: `evalstate'
03:53:18 <randomclown> :t evalState
03:53:19 <lambdabot> forall s a. State s a -> s -> a
04:03:51 <randomclown> can pattern guards be used with case of?
04:04:32 <randomclown> oh it can
04:09:08 <Yanzay> hi guys!
04:24:10 <kamatsu> has anyone got GHC mod working on Aquamacs?
04:27:45 <randomclown> :t acculmArray
04:27:46 <lambdabot> Not in scope: `acculmArray'
04:28:05 <randomclown> :t accumArray
04:28:06 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
04:34:00 <randomclown> best way to count elements belong to a particular predicate in a Data.Array?
04:34:06 <randomclown> belonging*
04:36:24 <quicksilver> randomclown: length . filter (pred) . elems
04:36:29 --- mode: quicksilver set -o quicksilver
04:37:14 <randomclown> hm pretty close to what I was thinking
04:38:29 <t7> is there a haskell library for upnp ?
04:41:03 * hackagebot nlp-scores 0.5.2 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.5.2 (GrzegorzChrupala)
04:49:03 <opqdonut> package random-1.0.0.2-81c9f631b0081165c591e09a577f60ef is shadowed by package random-1.0.0.2-cf650c34bae72c01e165a0d26c11236b
04:49:16 <opqdonut> 1) why do I have to instances of that package
04:49:23 <opqdonut> 2) how can I hide one or the other
04:51:18 <opqdonut> okay ghc-pkg list -v shows that the other coms from ~ and the other comes from /usr/lib
04:51:40 <opqdonut> why did cabal install build me a "private" version of random instead of using the one from /usr/lib?
04:52:54 <opqdonut> (cabal install somethingelse, not cabal install random.)
04:56:47 <opqdonut> hah, just needed a --preference line
04:58:00 <t7> @hoogle [Word8] -> Integer
04:58:00 <lambdabot> Data.List genericLength :: Num i => [b] -> i
04:58:01 <lambdabot> Data.Fixed resolution :: HasResolution a => p a -> Integer
04:58:01 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:58:14 <t7> can i convert a list of bytes into an Integer?
04:58:44 <parcs`> :t foldl ((`shiftL` 8) . (+) . fromIntegral) 0
04:58:45 <lambdabot> forall a. (Bits (a -> a), Integral a) => [a] -> a
04:58:54 <parcs`> uh oh
04:58:55 <t7> is there no stdlib function
04:58:57 <t7> prelude*
04:59:01 <parcs`> don't think so
04:59:25 <parcs`> there's probably a hackage package out there
04:59:50 <t7> actually i dont need
05:00:24 <geekosaur> binary or cereal
05:00:32 <t7> yum
05:00:59 <parcs`> :t foldl (fmap (`shiftL` 8) . (+) . fromIntegral) 0
05:01:00 <lambdabot> forall b. (Bits b, Integral b) => [b] -> b
05:01:03 * hackagebot histogram-fill 0.6.1.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.6.1.0 (AlexeyKhudyakov)
05:01:29 <parcs`> :t foldl (fmap (`shiftL` 8) . (+) . fromIntegral) 0 [1, 1, 2]
05:01:30 <lambdabot> forall b. (Bits b, Integral b) => b
05:01:33 <parcs`> > foldl (fmap (`shiftL` 8) . (+) . fromIntegral) 0 [1, 1, 2]
05:01:34 <lambdabot>   16843264
05:02:17 <geekosaur> (Integer is especially problematic as the internal representation is usually opaque even to Haskell (a gmp structure)
05:02:46 <danharaj> I think GHC has a native implementation if you ask for it.
05:03:46 <geekosaur> it does, but it's non-default.  hence "usually"
05:03:56 <geekosaur> (also I'm ignoring things like I#/J#)
05:26:03 <av> hi everyone, I think I need some help with Parsec:
05:27:01 <av> I'm trying to parse a line with entries separated by a certain character, say, comma, the number of entries is unknown, then I have a newline at the end of the line
05:27:08 <astor> building the ghc 7.4 branch from github tries to clone something called packages/cabal-1.14.git or something which isn't on github.  anyone knows why?
05:27:40 <av> so I want a parser that reads as many comma-terminated statements as possible, then discards the rest of the line including the newline
05:27:45 <av> how do I do that?
05:28:01 <t7> > "i need a Word256 from " ++ show  (256/8) ++ " Word8's"
05:28:03 <lambdabot>   "i need a Word256 from 32.0 Word8's"
05:28:59 <ion> > "i need a Word291 from " ++ show (291/9) ++ " Word9s"
05:29:01 <lambdabot>   "i need a Word291 from 32.333333333333336 Word9s"
05:33:35 <parcs`> astor: git remote set-url origin http://darcs.haskell.org/ghc.git
05:34:15 <parcs`> you can't properly build ghc if you clone from github
05:34:50 <ClaudiusMaximus> @hackage largeword -- t7, this has a Word256
05:34:51 <lambdabot> http://hackage.haskell.org/package/largeword -- t7, this has a Word256
05:35:36 <astor> parcs': what is the github clone for?
05:35:53 <t7> ah cool
05:37:19 <nart> av: do { l <- sepBy <your parser> (char ','); newline; return l  }
05:38:48 <parcs`> astor: dunno :P
05:38:55 <parcs`> i guess it makes it easier to browse commits
05:39:57 <TedTedTedTed> hello everyone
05:40:34 <av> nart: tried that, unfortunately, that one also returns the rubbish after the last comma, which I don't want
05:41:00 <av> nart: simply replacing sepBy by endBy makes the whole thing break even more
05:41:19 <ClaudiusMaximus> :t fmap init
05:41:20 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f [a]
05:42:44 <t7> i allways forget how todo language pragmas
05:43:29 <nart> av: probably not the right way to do it  (i'm an absolute n00b) but what about ? do { l <- sepBy word (char ','); newline; _ <- many anyToken; return l  }
05:43:40 <ClaudiusMaximus> t7: {-# LANGUAGE Foo, Bar, ... #-} before the module declaration
05:46:47 <t7> has anyone made a library to chunk [Octet]s ready for encrypting
05:47:18 <ClaudiusMaximus> t7: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=octet
05:49:31 <av> nart: I've tried that (and many others), no success so far -- BTW, many anyToken must be before newline
05:50:14 <t7> is there an easy library for encrypting/decrypting bytestrings or strings or whatever
05:50:23 <t7> with AES ideally
05:50:31 <t7> aha!
05:51:08 * hackagebot palindromes 0.2.2.2 - Finding palindromes in strings  http://hackage.haskell.org/package/palindromes-0.2.2.2 (JohanJeuring)
05:57:02 <randomclown> :t get
05:57:04 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
05:59:53 <randomclown> :t evalState
05:59:54 <lambdabot> forall s a. State s a -> s -> a
06:02:18 <t7> > foldl (fmap (`shiftL` 8) . (+) . fromIntegral) 0 [1, 0]
06:02:19 <lambdabot>   65536
06:02:59 <t7> > foldl (fmap (`shiftL` 8) . (+) . fromIntegral) 0 [255, 0]
06:03:00 <lambdabot>   16711680
06:03:04 <t7> > foldl (fmap (`shiftL` 8) . (+) . fromIntegral) 0 [255, 255]
06:03:06 <lambdabot>   16776960
06:03:40 <t7> > 2 ^ (32 - 1)
06:03:41 <lambdabot>   2147483648
06:03:58 <t7> > 2 ^ (26 - 1)
06:03:58 <lambdabot>   33554432
06:04:01 <t7> > 2 ^ (16 - 1)
06:04:01 <lambdabot>   32768
06:06:10 <t7> shouldnt [1,0] be 256 ?
06:09:08 <rwbarton> That's what you get for writing things like "fmap (`shiftL` 8) . (+) . fromIntegral".
06:09:10 <geekosaur> t7, endian
06:10:43 <ClaudiusMaximus> which type level number package should i use before i end up with yet another copy of '{-# LANGUAGE EmptyDataDecls #-}data Z;data S t' in my code?
06:14:55 <koala_bot> What is the software on hpaste.org called which points out warnings, errors in formatting?
06:15:02 <ClaudiusMaximus> koala_bot: hlint
06:15:05 <koala_bot> thank you :)
06:37:59 <parcs`> > foldl (flip fmap (`shiftL` 8) . (+) . fromIntegral) 0 [1,0]
06:38:00 <lambdabot>   256
06:39:46 <parcs`> this is the actual correct version though
06:40:07 <parcs`> > foldr (flip fmap (`shiftL` 8) . (+) . fromIntegral) 0 . reverse $ [1,1] :: Integer
06:40:08 <lambdabot>   257
06:40:54 <randomclown> why can't I compose two IO monads
06:41:05 <randomclown> when I'm inside a do block that returns a State monad
06:41:18 <randomclown> a function that return State a b
06:41:53 <ion> Not enough information.
06:43:44 <mm_freak> randomclown: there is only one IO monad…  do you mean IO actions?
06:44:10 <randomclown> http://hpaste.org/65571
06:44:12 <mm_freak> randomclown: with some more accurate type info we might be able to help you
06:44:12 <randomclown> this piece of code
06:44:46 <mm_freak> ah, the good old state misconception =)
06:45:06 <randomclown> hmm?
06:46:10 <saite> hi
06:47:13 <Botje> randomclown: you cannot mix and match two separate monad actions.
06:47:15 <geekosaur> that code is deeply confused
06:47:32 <saite> could someone here please point me to the right google search terms for the follwing question: "how does one interface object code that was produced by ghc from c?"
06:47:44 <Botje> randomclown: you have to either separate them or use monad transformers to put one inside the other
06:47:56 <randomclown> how would you do it?
06:48:02 <mauke> @where ffi
06:48:02 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
06:48:17 <randomclown> @botje
06:48:18 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
06:48:19 <geekosaur> randomclown, also, "do" does not mean IO, it means monad.  State is a different monad from IO.
06:48:52 <mm_freak> randomclown: for now do it without a state monad
06:48:52 <randomclown> :botje
06:49:03 <mm_freak> randomclown: it will confuse you more than it will help you
06:49:28 <ion> @undo do { board <- get; readInstruction >>= checkBounds (snd . bounds $ board); return "wtf" }
06:49:28 <lambdabot> get >>= \ board -> readInstruction >>= checkBounds (snd . bounds $ board) >> return "wtf"
06:49:31 <Botje> randomclown: write a state action that handles one instruction, feed it instructions from within IO.
06:49:34 <ion> @type (>>=)
06:49:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:49:47 <ion> Note how the “m” must be same on both sides of (>>=) and (>>).
06:49:53 <hpaste> scooty-puff pasted “Too far?” at http://hpaste.org/65572
06:50:36 <ion> What’s that ': fields' syntax?
06:51:11 <Botje> do inst <- readInstruction; let (a,s') = runState (doInstruction inst) s; {- do something with the new state, or call yourself again -}
06:51:20 <ion> Actually, what’s that ': syntax?
06:51:27 <scooty-puff> ion: for DataKinds - needed to disambiguate a list i think
06:51:36 <scooty-puff> may not be necessary here though, let me try
06:52:05 <scooty-puff> it is necessary ehre
06:52:07 <scooty-puff> *here
06:52:54 <mm_freak> questions of haskell beginners shouldn't be taken too literally…  most often what the beginner thinks to be the problem has little to do with the actual problem
06:53:02 <Botje> randomclown: that last line was for you.
06:53:08 <mm_freak> in this case the question is NOT how to combine IO and State
06:53:09 <randomclown> I saw
06:54:15 <mm_freak> the solution is to understand what State is and why randomclown doesn't need it for now
06:54:23 <mm_freak> if at all
06:55:12 <ion> X/Y problem
06:55:54 <mm_freak> randomclown: rewrite your computation to a function of type "Board -> IO String"
06:56:10 <snhmib> would someone be interested in looking over an interpreter for 010 binary templates? (http://www.sweetscape.com/010editor/manual/IntroTemplates.htm)
06:57:02 <snhmib> it's not like, finished, but i would appreciate if someone would have time/interest to quickly look over it to see if it's readable code?, are the datastructures ok? and such..
06:57:33 <randomclown> mm_freak yeah but I know how to do that
06:57:43 <randomclown> the whole point is learn to to use state
06:58:06 <snhmib> i put it here: http://patch-tag.com/r/snhmib/BTEditor/home
06:58:57 <randomclown> so the problem was that IO didn't want to be composed with state
06:59:18 <randomclown> inside the do
06:59:34 <d^> EHLO
07:00:13 <mm_freak> randomclown: then take an example where State really pays off, because "State s a" is really just "s -> (a, s)"
07:00:26 <geekosaur> randomclown, you cannot "compose" monads that way.  you were shown why.  it has to be all in one monad
07:00:33 <geekosaur> :t (>>=)
07:00:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:00:41 <randomclown> yeah I get it now
07:00:44 <geekosaur> (>>= is what "do" notation turns into)
07:00:52 <mm_freak> randomclown: most notably an example where you don't need IO
07:01:07 <mm_freak> randomclown: because to combine IO and State you need the transformer-version of State called StateT
07:01:40 <mm_freak> randomclown: a very simple example where State can be useful is a computation that depends on a PRNG
07:03:09 <mm_freak> more generally whenever you are tempted to write "Y -> (X, Y)" a lot and need to pass that Y value around a lot you may consider switching to "State Y X" instead
07:03:36 <snhmib> anyone? :)
07:04:05 <Authoritarianism> Hello. Is there any Haskell project similar in spirit to node.js?
07:04:07 <randomclown> alright ty
07:04:25 <mm_freak> Authoritarianism: yesod, snap, happstack, salvia, …
07:04:27 <mm_freak> ;)
07:04:33 <Authoritarianism> mm_freak: Nice, thanks!
07:04:37 <rostayob> mm_freak: those are different in spirit to node.js (thankfully)
07:04:55 <merijn> Authoritarianism: What do you mean "similar in spirit"?
07:04:59 <mm_freak> rostayob: node.js was explained to me as "server-side scripting"
07:05:09 <mm_freak> (java-) scripting
07:05:10 <rostayob> mm_freak: that's a horrible description.
07:05:17 <merijn> mm_freak: With some idiotic event loop design that hurts the brain
07:05:18 <Authoritarianism> rostayob, merijn: By "similar in spirit to node.js", I mean "freeing me from the complexity of Apache and IIS".
07:05:25 <av> let's try again: I'm trying to parse a line with entries separated by a certain character, say, comma, the number of entries is unknown, then I have a newline at  the end of the line
07:05:40 <av> so I want a parser that reads as many comma-terminated statements as possible, then discards the rest of the line including the newline
07:05:48 <av> how do I do that with Parsec?
07:05:52 <merijn> Authoritarianism: So what you really mean is "web framework that doesn't rely on a separate server/cgi"? :)
07:05:53 <rostayob> Authoritarianism: I'm not sure what you mean, but mm_freak mentioned some popular web *frameworks* in Haskell.
07:05:57 <mm_freak> Authoritarianism: in that case, i withdraw my statement
07:06:09 <mm_freak> the web frameworks i mentioned don't suck
07:06:10 <rostayob> Authoritarianism: if you want something to create web services, you can look at warp
07:06:23 <Authoritarianism> merijn: Yep.
07:06:30 <mm_freak> if you need something at a lower level have a look at WAI
07:06:33 <mm_freak> the Web Application Interface
07:06:36 <rostayob> if you want something that works with an event loop and callbacks like node.js, you won't find it in Haskell, we have better ways of writing those programs.
07:06:45 <merijn> Yesod, snap and happstack all seem to fit that description.
07:07:00 <Authoritarianism> Mmm...
07:07:25 <mm_freak> Authoritarianism: perhaps it would be better to ask in terms of application instead of solution
07:07:37 <mm_freak> different applications require different solutions in different languages
07:07:40 <luite_> Yesod is built on WAI btw, you can make a regular website with Yesod, and fall back to WAI for really low-level things
07:07:53 <Authoritarianism> mm_freak: I just want to make a toy RESTful Web Service.
07:08:04 <mm_freak> then you can go for any of the frameworks i mentioned
07:08:14 <Authoritarianism> mm_freak: Yes, I am doing that right now.
07:08:15 <donri> @where web
07:08:15 <lambdabot> http://happstack.com/ http://snapframework.com/ http://yesodweb.com/
07:08:18 <Authoritarianism> mm_freak: Thanks.
07:08:19 <mm_freak> yesod, snap and happstack are the most popular, but there are some others as well
07:08:23 <Botje> Authoritarianism: we cal node.js 'the Cont monad' :P
07:08:29 <Botje> *call
07:08:40 <mm_freak> Botje: Cont monads are powerful ;)
07:08:56 <Authoritarianism> Botje: What is the Cont monad?
07:08:59 <merijn> Botje: Alternatively we replace it with forkIO :p
07:09:09 <luite_> we know the Yesod website design sucks btw, want to contribute a better one? ;p
07:09:30 <rostayob> node.js is basically a JS interface to epoll & similar using callbacks
07:09:31 <Botje> Authoritarianism: also, GHC's runtime is smart enough to switch to a different thread if a blocking call is made.
07:09:34 <mm_freak> Authoritarianism: are you a haskell beginner?
07:09:47 <Authoritarianism> mm_freak: Yep.
07:09:50 <merijn> luite_: The web design itself isn't that terrible. But the colours were picked about by a drunken colourblind monkey it seems?
07:09:55 <mm_freak> Authoritarianism: then don't bother about Cont for now…  it will hurt your brain with no immediate advantage =)
07:10:02 <Botje> Authoritarianism: the typical pattern f(arg1, arg2, function(result) { ... })
07:10:12 <Botje> is also known as 'continuation passing style'
07:10:20 <shachaf> Botje: "smart enough to"? Isn't that the bare minimum expected of a threaded runtime? :-)
07:10:27 <Authoritarianism> Botje: Yes, I know what continuation passing style is.
07:10:29 <merijn> I don't think explaining the contiuation monad to a new comer is all that helpful :p
07:10:42 <Botje> Authoritarianism: well, the Cont monad hides all those nasty continuations from you.
07:10:45 <mm_freak> Authoritarianism: well, Cont is the type-safe version of CPS =)
07:10:52 <luite_> merijn: yeah and then they were run through a local search function where someone accidentally negated the gradient
07:10:53 <merijn> (But I might be wrong, of course)
07:10:54 <mm_freak> and the implicit one
07:10:55 <shachaf> Botje: Is b1.onclick = function() { ... }; b2.onclick = function() { ... }; also continuation-passing style?
07:10:55 <rostayob> mm_freak: how is not
07:11:02 <rostayob> mm_freak: how is normal CPS not type safe?
07:11:05 <Authoritarianism> mm_freak, Botje: Amazing.
07:11:16 <Botje> shachaf: no, that's setting up onclick handlers
07:11:19 <mm_freak> rostayob: the type-safe implicit version…  the combination isn't trivial
07:11:24 <rostayob> I mean how does CPS implies type safety or the contrary
07:11:40 <rostayob> I can do CPS explicitly in haskell and it's perfectly type safe
07:11:55 <shachaf> Botje: OK, so what about: getURL(u1, function(data) { ... }); getURL(u2, function(data) { ... });?
07:12:13 <mm_freak> rostayob: add types to a language like vanilla scheme
07:12:21 <Botje> shachaf: uh, sure.
07:12:23 <mm_freak> with builtin CPS
07:12:54 <rostayob> mm_freak: well but "CPS" /= scheme
07:13:07 <mm_freak> the point is:  suddenly call/cc would have a type
07:13:08 <rostayob> Haskell is typesafe -> haskell CPS is type safe :P
07:13:13 <rostayob> replace CPS with whatever
07:13:29 <mm_freak> i'm putting the most emphasis on the first argument of Cont
07:14:01 <mauke> :t callCC
07:14:02 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
07:14:45 <rostayob> fun fact, dijinn can derive all the Cont functions!
07:14:46 <mm_freak> the first argument of Cont invalidates most wrong uses of Cont
07:15:22 <t7> Ambiguous module name `Data.LargeWord': :(
07:15:34 <parcs`> @djinn (((b -> r) -> r) -> r) -> r
07:15:34 <lambdabot> -- f cannot be realized.
07:15:35 <parcs`> lies
07:15:39 <shachaf> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
07:15:40 <lambdabot> f a b = a (\ c _ -> b c) b
07:15:53 <parcs`> @djinn Cont r (Cont r b)
07:15:53 <lambdabot> -- f cannot be realized.
07:16:13 <mm_freak> t7: you have multiple visible packages with that module…  either hide some of them or use the PackageImports iextension
07:16:38 <mm_freak> with the latter you can write:  import "the-package" Data.LargeWord
07:16:49 <shachaf> @djinn Cont r (Either (Cont r (Not a)) a)
07:16:49 <lambdabot> -- f cannot be realized.
07:16:53 <shachaf> @djinn Cont r (Either (Cont r (Not a)) (Cont r a))
07:16:53 <lambdabot> -- f cannot be realized.
07:16:54 <shachaf> Hmm.
07:17:03 <parcs`> :t callCC (return . fix)
07:17:04 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => m (m b)
07:17:06 * av wonders if anyone elses uses Parsec
07:17:07 <mm_freak> t7: later when you use cabal for your projects you won't have that problem anymore
07:17:26 <mm_freak> av: mainly attoparsec here
07:17:27 <dolio> @djinn Cont Void (Either (Cont Void (Not a)) (Cont Void a))
07:17:27 <lambdabot> f a = void (a (Right (\ b -> void (a (Left (\ c -> void (c b)))))))
07:17:53 <parcs`> dolio: what does that mean
07:18:18 <sohum> @pl \x -> (f x, a)
07:18:18 <lambdabot> flip (,) a . f
07:18:41 <shachaf> dolio: Ah, right.
07:18:48 <shachaf> Because I used (Not a) instead of (a -> r)
07:18:55 <dolio> Right.
07:18:58 <shachaf> @djinn Cont Void (Either (Cont Void (Not a)) a)
07:18:58 <lambdabot> f a = void (a (Left (\ b -> void (b (\ c -> a (Right c))))))
07:19:00 <Botje> sohum: if you already have (x, a), you can also write that as "first f"
07:19:17 <parcs`> @src Not
07:19:18 <lambdabot> Source not found. You untyped fool!
07:19:22 <shachaf> @djinn-env
07:19:23 <lambdabot> data () = ()
07:19:23 <lambdabot> data Either a b = Left a | Right b
07:19:23 <lambdabot> data Maybe a = Nothing | Just a
07:19:23 <lambdabot> data Bool = False | True
07:19:23 <lambdabot> data Void
07:19:25 <lambdabot> type Not x = x -> Void
07:19:27 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
07:19:29 <lambdabot> class Eq a where (==) :: a -> a -> Bool
07:19:31 <lambdabot> type Cont r a = (a -> r) -> r
07:19:33 <lambdabot> data Lens a b = L (a -> (b, b -> a))
07:19:37 <parcs`> shachaf: look what you did
07:19:39 <dolio> @djinn Cont Void (Either (Not a) a)
07:19:39 <lambdabot> f a = void (a (Left (\ b -> a (Right b))))
07:19:48 <parcs`> what about void?
07:19:54 <shachaf> Oh.
07:19:57 <dmwit> What ?djinn-env needs is a website + a list of what's been added manually.
07:20:18 <shachaf> Hmm, why does that work?
07:20:29 * shachaf examines for a moment.
07:20:32 <parcs`> @src void
07:20:32 <lambdabot> Source not found.
07:20:44 <shachaf> @djinn Cont r (Either (a -> r) a)
07:20:45 <lambdabot> f a = a (Left (\ b -> a (Right b)))
07:21:29 <parcs`> neat
07:21:59 <Authoritarianism> One question: Why does "sudo apt-get install haskell-platform" attempt to install X11 packages?
07:22:01 <parcs`> is there any logical meaning to these types?
07:22:22 <rostayob> Authoritarianism: because the haskell platform includes packages that use xlib?
07:22:24 <parcs`> haskell-platform comes with at least opengl which requires x11 libs
07:22:48 <Authoritarianism> Why does haskell-platform come with OpenGL?
07:23:11 <rostayob> Authoritarianism: ...because it's a useful package that a lot of people need?
07:23:13 <parcs`> it comes with opengl bindings
07:23:46 <Authoritarianism> Well, I guess then I will have to install those packages I need one by one, separately.
07:24:14 <shachaf> Tragic.
07:24:27 <parcs`> or just install ghc and cabal and forget about global haskell packages
07:25:30 <donri> ghc and cabal work fine without haskell-platform, but why do you care about some x11 packages?
07:26:14 <Authoritarianism> In any case, I have zero use for OpenGL and X11. I do no graphical stuff on my dev machine, it does not even have a desktop environment.
07:26:38 <donri> does it actually matter, or are you just being OCD about it
07:27:40 <Authoritarianism> donri: Maybe the latter.
07:28:09 <parcs`> i run a minimal arch install on a headless server and even then i have some x11 packages installed. you don't need a graphical desktop to find x11 packages useful, eg texlive requires x11 packages
07:28:37 <Botje> as does a JRE.
07:28:53 <mm_freak> Authoritarianism: don't feel obligated to use the haskell platform…  many linux users (including me) are more selective about installed packages
07:28:57 <donri> it only really matters in extreme edge cases like embedded systems
07:29:16 <snhmib> and paranoid admins :)
07:29:27 <donri> the point of the platform is to have some minimal set of mutually agreed upon package versions to target for library development
07:29:54 <mm_freak> Authoritarianism: even though i'm a happy user of KDE and compiz on all my non-server-systems =P
07:31:22 <sohum> @pl \x -> foo (g x) (h x)
07:31:22 <lambdabot> liftM2 foo g h
07:36:12 <sohum> @pl \x -> foo (g x) x
07:36:13 <lambdabot> foo =<< g
07:40:35 <snhmib> nobody wants to help me a bit & look at my code?
07:40:36 * snhmib sad
07:41:12 <shachaf> snhmib: "looking over" is a really vague request.
07:46:29 <snhmib> shachaf: true enough.. but it's my first bigger haskell project.. I think it's readable for others, but want to make sure :)
07:48:44 <nsxt_> snhmib: codereview.stackexchange.com ?
07:48:50 <snhmib> o_O
07:51:11 <Cale> snhmib: Did you post it on hpaste or something?
07:55:55 <snhmib> Cale: i put it here: http://patch-tag.com/r/snhmib/BTEditor/ it's a try to make an interpreter for: http://www.sweetscape.com/010editor/manual/IntroTemplates.htm
07:56:25 <snhmib> maybe it's a bit too big to ask for
07:58:04 <Cale> snhmib: Did you know that you can pattern match on a list like  let [v,msg] = args  ?
08:00:25 <snhmib> o_O no
08:01:13 <snhmib> ah makes sense
08:03:55 <Cale> For pretty printing, consider something like  http://hackage.haskell.org/package/wl-pprint  (see also http://legacy.cs.uu.nl/daan/download/pprint/pprint.html for information about the library)
08:04:29 <Cale> It looks like you're doing a bunch of IO in your pretty printer, which is kinda weird :)
08:04:58 <Cale> (given that it's constructing a string, and really doesn't do any actual IO)
08:05:14 <Cale> If you want mutable references locally, there's ST for that
08:05:19 <snhmib> well it makes a String out of a tree of IORefs
08:05:32 <Cale> oh, the IORefs are essential then?
08:05:42 <Cale> I see
08:05:51 <Cale> They're actually coming out of these structures, okay
08:06:17 * hackagebot network-info 0.2.0.1 - Access the local computer's basic network configuration  http://hackage.haskell.org/package/network-info-0.2.0.1 (JacobStanley)
08:07:08 <Philonous> I was wondering, what's currently "best practice" for handling xml?
08:07:16 <weexplat> has anyone done something like this?:
08:07:18 <ion> Burn it with fire.
08:07:22 <Botje> Philonous: thick gloves and goggles
08:07:24 * Cale tempted to say "not to use XML"
08:07:45 <weexplat> there's a database of function signatures, like hayoo or hoogle have
08:07:51 <Philonous> Cale:  Unfortunately, XMPP only comes with xml
08:08:02 <Cale> Philonous: right
08:08:22 <Cale> Philonous: expat-pickle can be nice
08:08:24 <weexplat> the user supplies a quickcheck property
08:08:39 <Cale> Philonous: there are a bunch of libraries which are probably better at different types of tasks
08:09:03 <weexplat> the program generates candidate functions fitting the type (like djinn)
08:09:20 <weexplat> terms that pass the test are printed
08:09:42 <weexplat> could call it 'quickhack' :)
08:10:16 <Cale> weexplat: there was a paper I remember which was something related to that, but I'm having trouble remembering who wrote it or what it was called
08:13:54 <Philonous> Cale:  Well, it's an embarrassment of riches. I have no clue how those libraries compare.
08:17:58 <Cale> Philonous: okay, well, there's hxt, which is extremely full featured, to the point where it reveals how complicated XML and surrounding standards can be, and is probably good for extremely serious heavy-duty processing tasks, but possibly a little on the awkward side for simpler things. Still probably worth looking at.
08:19:19 <Cale> There's 'xml', which is a more lightweight library for processing XML -- I haven't actually used it myself, but it looks rather straightforward.
08:19:34 <Cale> (and it is apparently in production use, so that's probably good :)
08:20:30 <scooty-puff> is there a good way to tell the difference between constraints and type functions, when using functional dependencies?
08:20:35 <scooty-puff> maybe a naming convention?
08:20:58 <t7> does anyone know a good paper on p2p networking?
08:21:14 <t7> how to avoid infinite relaying and stuff
08:21:16 <Cale> and there's hexpat which is a binding to the expat C library, which also has a nice library attached to it called hexpat-pickle, which gives you a nice datatype and combinators to define mappings between XML and Haskell datastructures
08:21:18 <t7> and even the basics
08:21:25 <Philonous> Cale:  Ah, sorry, I didn't mean to trouble you to give me a full tour. I thought there might just be one or two packages that are considered "canonical".
08:21:50 <Cale> Philonous: those are the three that I would start with
08:22:08 <Cale> Philonous: for more hacky projects, you might also want to consider tagsoup
08:22:53 <Cale> Philonous: and if HXT looks sort of right, you might also want to compare it with HaXml, which is quite similar
08:27:12 <Philonous> Cale:  Ah, thanks. Well, as far as I can see most of them seem to be stuck in String-land. I wonder whether that's a dead end.
08:27:51 <Cale> Philonous: well, a lot of them were written a good deal before Data.Text and Data.ByteString
08:28:59 <Cale> Philonous: hexpat uses ByteString from what I'm aware of though
08:30:51 <Cale> and there's this xml-conduit library which apparently uses Text, but I have no idea what conduits are about (apparently Michael Snoyman's answer to iteratees or something like that :)
08:31:20 <Clint> it's "enumerator" done better
08:31:48 <Clint> i misplaced the punctuation there
08:32:14 <tgeeky__> hehe
08:33:12 <tgeeky__>                 "     ------->"
08:33:38 <Philonous> Cale:  That's helped a lot, thanks!
08:33:40 <tgeeky__> Clint: in terms of reverse deps, however, it's doing quite well
08:34:09 <Clint> i wasn't saying it's not better
08:34:34 <Guest44638> !list
08:34:37 <tgeeky__> Clint: I know.
08:34:38 <Guest44638> ciao
08:34:46 <Philonous> tgeeky__:  It has yesod behind it, so big deal.
08:35:11 <tgeeky__> Philonous: I mean genuine (non-yesod, non-snoyman) reverse deps. Conduits of non-webby sorts.
08:36:14 <Philonous> tgeeky__:  Ah, fair enough
08:43:02 <sm> the xml package is quite memory-hungry I believe
08:43:36 <sm> me, I'd go with xml-conduit for basic needs
08:45:09 <t7> roconnor: your good at crypto and stuff
08:45:24 <roconnor> t7: my friends are at least
08:45:46 <hpaste> t7 pasted “test” at http://hpaste.org/65574
08:46:17 <t7> am i right in thinking no one should be able to add a message to the chain without knowing a previous hash?
08:47:40 <roconnor> what do you mean by "add a message"?
08:47:46 <t7> addToChain
08:48:00 <t7> all the sniffer can see is TransMessage
08:48:06 <t7> the MITM*
08:49:00 <t7> babbys first p2p network
08:51:48 <roconnor> t7: and attacker *might* be able to interfere by changing the TransMessage.
08:52:11 <roconnor> t7: You should probably use the keyd HMAC algorithm instead at the very least
08:52:41 <roconnor> t7: see RCP 2104
08:52:46 <roconnor> *RFC 2104
08:52:47 <t7> cheers
08:56:28 <Mathnerd314> are there any dependently-typed languages that let you define catamorphism :: {A : Set} -> <fold function> ?
08:57:08 <thoughtpolice> preflex: seen kfish
08:57:08 <preflex>  kfish was last seen on #haskell 16 hours, 22 minutes and 3 seconds ago, saying: koala_bot, f (TagOpen tag attrs) = print attrs
08:58:22 <kallisti> any recommendations for a DB interface for postgres?
09:00:55 <kallisti> or should I be looking at acid-state for persistence?
09:00:57 <t7> hdbc worked fine for me kallisti
09:01:21 <t7> you pass the query as a string
09:01:28 <t7> and it returns nice objects
09:01:44 <quicksilver> well acid-state is a completely different approach
09:02:03 <quicksilver> acid-state is a terrible idea if your architecture requires a relational DB
09:02:12 <quicksilver> but, probably, a great idea if you just want persistence.
09:02:18 <quicksilver> (and transactionality)
09:02:30 <kallisti> it doesn't require a relational DB, but I think it would probably be better as one.
09:03:26 <kallisti> in particular I'll be doing a lot of datetime-based queries
09:06:04 <kallisti> http://hackage.haskell.org/packages/archive/priority-sync/0.1.0.1/doc/html/Control-Concurrent-Priority-Queue.html
09:06:08 <kallisti> best concurrent priority queue?
09:06:15 <kallisti> or is there another?
09:06:43 <kallisti> oh wait I'm not sure this exists anymore.
09:07:55 <Mathnerd314> > let x = x*x in x+x
09:07:59 <lambdabot>   mueval-core: Time limit exceeded
09:08:00 <kallisti> Data.PriorityQueue is probably good.
09:10:54 <Mathnerd314> > let y = x * x in y+y
09:10:55 <lambdabot>   x * x + x * x
09:11:25 <Mathnerd314> conclusion: alpha-renaming doesn't work in Haskell
09:12:06 <Mathnerd314> s/alpha-renaming/something Robert Harper wants/
09:12:36 <geekosaur> let is letrec in haskell
09:12:51 <geekosaur> some people are offended by that
09:13:25 <Mathnerd314> corollary: Robert Harper doesn't consider Haskell to be a "practical" language
09:14:18 <merijn> Remarkable how all Haskell's downsides happen to be exactly what Robert Harper dislikes :p
09:18:56 <byorgey> Mathnerd314: let y = x * x in y+y  is NOT an alpha-renaming of  let x = x*x in x+x
09:19:15 <byorgey> Mathnerd314: because in Haskell, the variable after a 'let' is bound in its definition.
09:19:54 <byorgey> when alpha-renaming you cannot arbitrarily decide to rename some bound occurrences of a name and not others.
09:21:04 <byorgey> alpha-renaming does work in Haskell. It would be a very, very strange language indeed if it did not.
09:22:23 <mauke> alpha-renaming does not work in GNU C :-)
09:23:07 <Tinned_Tuna> That's because GNU C is a very, very strange language indeed.
09:23:07 <kallisti> any idea why Data.PriorityQueue's dequeue returns an m (Maybe a)  rather than m a ?
09:23:25 <kallisti> oh non-blocking
09:23:26 <kallisti> nevermind. :P
09:24:33 <mauke> http://gcc.gnu.org/bugzilla/show_bug.cgi?id=52554
09:24:53 <kallisti> I would really prefer that it blocked...
09:25:41 <kallisti> would it be okay to implement blocking behavior by repeatedly polling dequeue, with a yield between each call?
09:26:43 <t7> no sir
09:27:21 <mauke> kallisti: can't this be done with STM?
09:27:41 <Philonous> Mathnerd314:  And here I thought shadowing names was a bad Idea to begin with
09:28:14 <kallisti> mauke: well until now STM wasn't needed, since I basically have a single thread broadcasting to many.
09:28:29 <mauke> uh. ok?
09:28:51 <kallisti> I don't know. can it?
09:29:08 <mauke> I'm not sure how Data.PriorityQueue is supposed to work
09:29:39 <kallisti> mauke: works in any Monad.
09:29:51 <mauke> what does that mean?
09:30:00 <Luke> Is it possible to use the Control.Parallel.Strategies stuff for parallel IO?
09:30:11 <kallisti> mauke: it means that its operations are "monadic actions"
09:30:17 <mauke> what does that mean?
09:30:18 <Luke> I can't tell from the types if it's possible
09:30:21 <napping> I don't know about PriorityQueue in particular, but converting between blocking and non-blocking stuff is one of the nice things about Haskell's STM
09:30:23 <kallisti> mauke: I don't know
09:30:31 <kallisti> mauke: how about you just look at the docs if you're curious?
09:30:35 <mauke> I did
09:30:42 <mauke> it just describes some classes and functions
09:30:59 <mauke> and half of the links are broken
09:31:15 <Mathnerd314> byorgey: that's why I did s/alpha-renaming/something Robert Harper wants/
09:31:56 <Mathnerd314> Philonous: yes, I think that's the correct solution
09:32:18 <byorgey> Mathnerd314: I see =)
09:32:23 <napping> going by the name, HasRef might mean a PriorityQueue STM would be built on TVar
09:34:09 <kallisti> yes, it seems to be usable withSTM
09:34:15 <Mathnerd314> Philonous: modules / names don't have much place in language semantics
09:34:39 <kallisti> but I don't know if this solves the issue that it's non-blocking. Does that mean I should just manually retry on Nothing to implementing blocking?
09:35:34 <Philonous> Mathnerd314:  I think that's only true if modules do little more than provide name spaces.
09:35:55 <Mathnerd314> what else would they do?
09:36:23 * hackagebot cassette 0.1.0 - A combinator library for simultaneously defining parsers and pretty printers.  http://hackage.haskell.org/package/cassette-0.1.0 (MathieuBoespflug)
09:36:26 <napping> and do a bit better than a busy-wait if you blocked like atomically (do v <- dequeue; case v of Just x -> return x;_ -> retry)
09:36:38 <Philonous> Mathnerd314:  Provide abstractions, like they do in ML?
09:36:45 <kallisti> napping: yes that's what I meant
09:36:50 * Mathnerd314 googles
09:37:05 <napping> yes, that's how retry works - it blocks until any of the TVars the transaction touched are actually updated
09:37:38 <Mathnerd314> http://lambda-the-ultimate.org/node/1558 "In this work, we demonstrated how ML modules can be translated to Haskell type classes"
09:38:34 <napping> on the other hand, some of the papers suggest building imperative data structures out of TVars doesn't work as well as just using them to coordinate functional data structures
09:39:00 <kallisti> the implementation appears to be just a Map.
09:39:17 <kallisti> or do you mean something else?
09:39:32 <napping> why is it in a monad and parameterized over a map?
09:40:51 <kallisti> not sure. maybe it's for people like me who want a mutable priority queue and are too lazy to roll their own?
09:44:49 <monochrom> m (Maybe a) seems redundant. the idea is that a lookup or dequeue may fail. so you make it Maybe a and use Nothing, or make it m a and use fail. but you don't use both.
09:45:50 <kallisti> monochrom: or, ideally, MonadZero
09:46:03 <monochrom> yeah
09:46:56 <Mathnerd314> is let ... in ... considered syntactic sugar?
09:47:16 <dcoutts_> Mathnerd314: no
09:47:26 <monochrom> but you wouldn't dequeue :: (Monad m, MonadZero z, Monoid g, Alternative a) => Queue -> a (g (z (m (Maybe [a])))  :)
09:47:45 <Mathnerd314> dcoutts_: I know there's no construct for it in Core
09:47:51 <kallisti> monochrom: hey now, you never know.
09:48:05 <t7> > 2^224 / 1498294.3628165
09:48:06 <lambdabot>   1.7993758326949332e61
09:48:48 <Philonous> Mathnerd314:  you could translate "let x=p in e " to "(\x -> e) p", but you would loose sharing
09:49:28 <dcoutts_> Mathnerd314: yes, 'let' is in core.
09:49:35 <dcoutts_> Mathnerd314: in GHC core.
09:49:56 <Mathnerd314> curses, you're right
09:50:09 <dcoutts_> Mathnerd314: 'where' clauses are de-sugared into let
09:50:27 <dcoutts_> as are various kinds of pattern matching
09:50:47 <dcoutts_> tibbe: btw, I started work at the weekend on the cabal repl patches
09:50:56 <dcoutts_> tibbe: or rather re-started
09:50:59 <tibbe> dcoutts_: sweet!
09:51:05 <Mathnerd314> I thought those were case expressions
09:51:16 <dcoutts_> Mathnerd314: core has let and case.
09:51:39 <dcoutts_> but let doesn't do patterns in core, only case does that
09:51:47 <t7> > 2 ^ 256 / 0x0000000000000B32870000000000000000000000000000000000000000000000
09:51:48 <lambdabot>   6.435223481795734e15
09:52:09 <t7> > 2 ^ 256 * 0x0000000000000B32870000000000000000000000000000000000000000000000
09:52:10 <lambdabot>   208350307768972460976055015338383693534869919279115351365010247794893636498...
09:52:22 <kallisti> Mathnerd314: so let is half-sweet. :)
09:52:43 <dcoutts_> tibbe: I'm doing it not by merging the GSoC patches as such, but by redoing it carefully, following the GSoC changes as a guideline of what needs doing
09:53:03 <dcoutts_> I think it'll be quicker this way
09:54:17 <Mathnerd314> Philonous: it's an information-preserving transformation
09:55:19 <Mathnerd314> how does one observe sharing?
09:56:06 <c_wraith> Mathnerd314: generally by cheating. (that is, asking ghc to solve the technical problems for you. traditionally with StableNames)
10:04:18 <Mathnerd314> > let x = take 50000000 $ repeat id in (foldr ($) 2 x) + (foldr ($) 2 x)
10:04:19 <eacameron> Reading http://en.wikibooks.org/wiki/Haskell/Understanding_monads, I came across this: Has this change happened in GHC yet? "However, GHC thinks it different, and the Monad class has actually nothing to do with the Functor class. This will likely change in future versions of Haskell, so that every Monad will have its own fmap; until then, you will have to make two separate instances of your monads (as Monad and as Functor
10:04:25 <lambdabot>   mueval: ExitFailure 1
10:04:26 <lambdabot>  mueval: Prelude.undefined
10:04:35 <Mathnerd314> > let x = take 50000000 $ repeat id in let y = (foldr ($) 2 x) in y + y
10:04:39 <lambdabot>   mueval-core: Time limit exceeded
10:05:01 <Mathnerd314> curious
10:06:09 <Mathnerd314> > let x = take 40000000 $ repeat id in (foldr ($) 2 x) + (foldr ($) 2 x)
10:06:13 <lambdabot>   mueval-core: Time limit exceeded
10:06:19 <Mathnerd314> > let x = take 40000000 $ repeat id in let y = (foldr ($) 2 x) in y + y
10:06:23 <lambdabot>   mueval-core: Time limit exceeded
10:06:50 <applicative> eacameron: there is no change
10:07:06 <Mathnerd314> > let x = take 40000000 $ repeat id in let y = (foldr ($) 2 x) in y + y
10:07:09 <lambdabot>   4
10:07:38 <Mathnerd314> > let x = take 40000000 $ repeat id in (\y -> y+y) (foldr ($) 2 x)
10:07:42 <lambdabot>   mueval-core: Time limit exceeded
10:07:48 <Mathnerd314> > let x = take 40000000 $ repeat id in (\y -> y+y) (foldr ($) 2 x)
10:07:51 <lambdabot>   4
10:08:06 <merijn> eacameron: No, Monads are still not required to be an instance of Functor. And personally I don't think it will change any time soon
10:08:53 <Mathnerd314> > let x = take 40000000 $ repeat id in (foldr ($) 2 x) + (foldr ($) 2 x)
10:08:53 <kyagrd> eacameron: Control.Monad has WrappedMonad newtype. If you put a monad in WrappedMonad then it is a functor instance
10:09:01 <lambdabot>   mueval: ExitFailure 1
10:09:01 <lambdabot>  mueval: Prelude.undefined
10:09:36 <tibbe> dcoutts_: whatever works I guess
10:09:49 <tibbe> dcoutts_: make sure you give the student credit so he/she comes back.
10:10:01 <Mathnerd314> Philonous: looks like lambdas preserve sharing too
10:11:22 <dcoutts_> tibbe: of course, "based on the GSoC work by ..."
10:11:44 <applicative> eacameron, I think people sometimes suggest this is some sort of technical error about it, but there's nothing wrong with it, its just incovenient since we always do define Functor
10:11:58 <tibbe> dcoutts_: great
10:12:09 <tibbe> dcoutts_: are you also doing the :r emacs reload support?
10:13:16 <dcoutts_> tibbe: it's not to do with emacs, but the cabal repl patches include a trick to get ghci to call back out to cabal when the user does :r so we can run preprocessors etc
10:13:38 <Varakh> hi. why does instance Num (Maybe Integer) where ... not work?
10:13:54 <quicksilver> it is a simplistic restriction in haskell98 and haskell2010
10:14:13 <quicksilver> you can turn if off in the widely implemented "FlexibleInstances" extension.
10:14:41 <eacameron> thanks all
10:15:04 <tibbe> dcoutts_: right
10:15:07 <Varakh> thanks, so calculating with Maybes isn't working without the FlexibleInstances extension?
10:15:22 <quicksilver> well that is not quite true, Varakh
10:15:23 <scooty-puff> Varakh: you might want to do instance Num a => Num (Maybe a) where ...; though this would make it stand out a little more how maybe a separate type should be used
10:15:42 <quicksilver> instance Num a => Num (Maybe a)  --- would be fine without FlexibleInstances
10:16:01 <quicksilver> but what you originally wanted is really not unreasonable
10:16:17 <mdmkolbe> Where it the conventional place to put example files in a cabal distribution?  (that will eventually be put on Hackage)
10:17:23 <parcs`> example/?
10:17:39 <parcs`> i don't think there is a convention
10:18:34 <applicative> mdmkolbe examples/ is an excellent idea frequently used
10:23:36 <Varakh> just another question: why does num a => ... work? i dont understand that
10:26:05 <applicative> mdmkolbe: https://github.com/bos/aeson
10:26:37 <snhmib> is it possible/practical to write a pure interpreter for an imperative language (c, for example)? i.e. don't use IORef or STRef for assigning?
10:27:13 <kyagrd> snhmib: it is definitely possible, but it depends on what you mean by "practical"
10:27:29 <snhmib> i.e. the monad i'm using right now looks like: "type BT a = StateT BTState (ContT Value (ErrorT BTError IO)) a", where Value holds IORefs
10:28:05 <snhmib> i was thinking i can switch the StateT and ContT parts around and ditch all the IO stuff
10:28:08 <snhmib> does that make sense?
10:29:15 <applicative> Varakh, suppose you did Num a => Num (Maybe a) after having done Num a => Num (Maybe Int)
10:29:17 <nolrai_portland> So I am having real trouble getting EclipseFP to work. Mainly in that scion seems to be expecting really old versions of ghc and cabal. Is this normal?
10:29:53 <dcoutts> nolrai_portland: how old? older than 7.0?
10:30:06 <applicative> Varakh or rather, after Num (Maybe Int)   Try doing them both in one module.
10:30:49 <nolrai_portland> dcoutts: checking..
10:32:06 <jfischoff> snhmib: You don't need IO to write an interpreter, regardless of the language.
10:32:36 <jfischoff> snhmib: well as long as you are not doing IO :)
10:33:03 * applicative was trying to envisage what main was supposed to be for this interpreter
10:33:59 <nolrai_portland> dcoutts: "cabal install scion" asks for ghc < 6.12.
10:34:13 <snhmib> jfischoff: hmm, well yea. i might keep IO for that.. I'm mostly looking to get rid of the IORefs for variables
10:34:35 <dcoutts> nolrai_portland: oh, but eclipsefp uses its own fork of scion I thought, not the hackage one
10:34:42 <dcoutts> nolrai_portland: partly due to that issue
10:34:54 <nolrai_portland> dcoutts: I think you are right.
10:35:00 <snhmib> jfischoff: i'm thinking that would make it easy implement a kind of "go-back in history and execute again" sort of type of thing
10:35:19 <flicker> Is it cool to ask super-ignorant Haskell-noobie questions in here?
10:35:22 <flicker> like that one
10:36:15 <nolrai_portland> dcoutts: but eclipseFP says that its scion is too old..grr.
10:36:19 <applicative> flicket indeed yes
10:36:25 <applicative> flicker rather
10:37:21 <snhmib> yes! i'm cool! woooo
10:37:41 <flicker> I'm trying to wrap my head around array syntax. Trying to create a simple 2D array in Prelude with "let t = array ((1, 2), (1, 2)) [((i, j), i*j) | i <- [1, 2], j <- [1, 2]]", but then trying "t!(1,1)" results in "Error in array index". From what I've seen, this should work...
10:38:05 <quicksilver> flicker: I thin you want ((1,1),(2,2)) as the bounds
10:38:26 <flicker> Oh, I see
10:38:28 <quicksilver> ((1,2),(1,2)) is a one-element array, whose only element is indexed by (1,2)
10:38:49 <flicker> I misunderstood the meaning of the tuples passed
10:38:50 <flicker> I get it now
10:38:51 <flicker> Thanks!
10:38:57 <quicksilver> np
10:39:42 <jfischoff> snhmib: I would start with a pure version that has name value pairs for the variable environment. As for history, you can work with isomorphisms entirely, or you will need to store check points, i.e. memoization.
10:42:11 <mdmkolbe> applicative: BTW, thanks for the link to aeson.  It's a nice example to work from.
10:44:56 <applicative> mdmkolbe yeah I wish everyone did that.
10:49:05 <ski> snhmib : you can keep some kind of map or array around instead of using `IORef' for the variables
10:49:23 <ski> you could alternatively use `STRef s' instead -- but maybe you'd like to avoid that too ?
10:49:24 <xil> hey everyone. Would someone mind giving me a quick example of how to use a case with guards? I have "case a of q | (some boolean on q) = something | otherwise = something else" but I'm getting a parse error on the guard. Anyone know why?
10:49:59 <int-e> xil: need -> instead of = for case
10:50:54 <int-e> xil: if that's not the cause, maybe paste the code on hpaste.org so we can have a closer look
10:50:55 <xil> int-e: I tried that. Are you sure the -> is after the guard? I thought it went after the pattern if you weren't using guards. If you're sure I'll look for another error
10:51:08 <int-e> no, it comes after the guard
10:51:21 <xil> let me look and I'll paste if I can't fix it
10:52:00 <snhmib> ski: the thing is i'd like to "restart" certain things
10:52:11 <int-e> > case (1,2) of (a,b) | a == 2 -> "2" | otherwise -> "not two"
10:52:12 <lambdabot>   "not two"
10:52:33 <snhmib> ski: right now i'm having iorefs in the environment, so i would need to un-ioref some and store them
10:52:59 <ski> snhmib : restart how ? restart the computation all over from the start ?
10:53:07 <snhmib> from certain points
10:53:09 <hpaste> xil pasted “failing case?” at http://hpaste.org/65576
10:53:19 <ski> snhmib : or, restart some sub-computation, when something specific happens in the program execution ?
10:53:22 <jfischoff> snhmib: you mean like undo right?
10:53:39 <jfischoff> go back in time
10:53:48 <jfischoff> snhmib: right?
10:54:37 <ski> @undo let go = back in time
10:54:38 <lambdabot> let { go = back} in time
10:55:02 <xil> int-e: I pasted
10:55:10 <jfischoff> he
10:55:16 <snhmib> yes, the language is to parse binary data.. i.e. struct foo { int x; local i = 0; while (i != x) parse_more_stuff(); };
10:55:34 <int-e> xil: move the 'q' to the next line so that it reads 'q | guard -> exp'
10:56:01 <jfischoff> snhmib: wait do you want a reversible interpreter or a backtracking parser?
10:56:13 <xil> int-e: ah okay
10:56:31 <snhmib> jfischoff: each struct would store Either (Weak ParsedStuff) SomethingParsingFunction
10:57:11 <xil> int-e: it doesn't like the q now. Could there be a problem with the case itself? Can I not have a case right after a $
10:57:30 <ski> you can
10:57:46 <Mathnerd314> @djinn (b -> b -> b) -> Bool
10:57:46 <lambdabot> f _ = False
10:58:17 <Mathnerd314> wtf...
10:58:22 <ski> @djinn (forall b. b -> b -> b) -> Bool
10:58:23 <lambdabot> f _ = False
10:58:26 <snhmib> jfischoff: i want to "execute" a parsing script once, then have a tree of values, and be able to restart parsing of those values so it can work on big files
10:58:46 <ski> xil : make sure the two `|' are aligned
10:59:09 <ski> (they don't *need* to be aligned, but the second `|' needs to be more indented than the `q')
10:59:22 <xil> ski: they are, it's failing on the first line as a whole, on the q itself
10:59:29 <hpaste> int-e annotated “failing case?” with “failing case? (annotation)” at http://hpaste.org/65576#a65577
10:59:36 <snhmib> does that make sense?
10:59:47 <ski> xil : hm, annotate the paste with the exact code you have now
10:59:59 <int-e> xil: I don't know what you did, the version I pasted should work
11:00:01 <jfischoff> snhmib:Yep makes sense, just different from what I initially thought you were trying to do
11:00:29 <xil> I have what int-e just pasted
11:01:01 <ski> snhmib : hm, why `Weak' ?
11:01:04 <xil> is "as" a reserved word?
11:01:40 <ski> snhmib : are you parsing a programming language ? or some data format ?
11:01:44 <ski> xil : no
11:01:49 <jfischoff> snhmib: you want memoization. Caching of past computations. You can do this all in Haskell, does it have to be a seperate language>
11:01:56 <jfischoff> s/>/?
11:02:09 <ski> jfischoff : maybe s/he wants incremental/adaptive computation ..
11:02:41 <mauke> ski: error: unterminated replacement in s///
11:03:12 <ski> mauke : did you mean to point that to jfischoff ?
11:03:27 <ski> ah, ok :)
11:03:31 <Luke> Is it possible to use the Control.Parallel.Strategies stuff for parallel IO? I can't tell from the types if it's possible
11:03:39 <jfischoff> ski: what is incremental computation?
11:04:12 <jfischoff> ski: googled, I see
11:04:22 <snhmib> it's to look through big structured files. the language would define how the files are structured
11:04:44 <ski> jfischoff : see paper by Acar and Blelloch. also paper (and code) for Haskell by Magnus Carlsson
11:05:00 <snhmib> jfischoff: i was thinking to make it Weak so that you can "automatically" look through really big files.. disks for example
11:06:23 <ski> snhmib : so, was `struct foo { int x; local i = 0; while (i != x) parse_more_stuff(); };' meant as an example of a (part of a) data file you would parse ? or an example of code to parse it ? or both ?
11:06:36 <ClaudiusMaximus> Luke: Control.Concurrent is more IO-y, afaik Control.Parallel.Strategies ia deterministic, which rules out actually performing IO actions (though you can of course manipulate IO actions in parallel like any other value)
11:07:13 <xil> oh whoops. I didn't have what int-e had. I didn't indent the second and third lines more than the first
11:07:30 <snhmib> ski: ah, both, if you type "int x;" it would get x from a file "local int i = 0;" is not from a file. you can put code in structs, make functions etc.
11:08:00 <ski> xil : `as' is specially recognized in `import' declarations, but should otherwhere be seen as just an ordinary identifier -- syntax-highlighting modes might not understand this distinction, though
11:08:44 <xil> ski: gvim seems to make the distinction fine, it's just that hpaste didn't so I thought maybe I couldn't use it
11:09:30 <donri> > let default = "where is this keyword used?"
11:09:31 <lambdabot>   <no location info>: parse error on input `default'
11:09:55 <mauke> http://www.haskell.org/haskellwiki/Keywords#default
11:10:19 <snhmib> ski: anyhow, i think i will try to make the interpreter pure so it's easier to store the entire state at a point
11:11:09 <snhmib> seems to be neater than making a shadow nonIO datatype and then checkpoint the IO state into that
11:11:10 <donri> thanks
11:11:28 <snhmib> ski jfischoff: thanks :)
11:11:35 <donri> wow is it limited to num?
11:11:40 <jfischoff> np
11:14:03 <geekosaur> donri, per the standard yes, I think ghc has an extension to make it slightly more general.  it's ... kinda an ugly hack, really
11:14:34 <donri> yea, quite the waste of a good identifier name there ^_^
11:15:06 <donri> that could totally be useful for things like IsString or for that matter HSP's tendency to yield overlapping instances
11:19:25 <ski> snhmib : good luck :)
11:32:22 <davidj> anyone from chicago?
11:32:58 <gdoteof> how do i format a UTCTime?  I tried Data.Time.Format.formatTime theUTCTime "%c"
11:34:53 <elemir> gdoteof: You forgot locale
11:35:31 <elemir> :t formatTime
11:35:32 <lambdabot> Not in scope: `formatTime'
11:36:05 <elemir> formatTime :: FormatTime t => System.Locale.TimeLocale -> String -> t -> String
11:37:29 <gdoteof> elemir: i tried adding 'defaultTimeLocale' and it was out of scope
11:37:46 <gdoteof> i then tried importing System.Locale (defaultTimeLocale) and that module can't be found
11:38:02 <elemir> You should install package old-locale
11:38:40 <elemir> Prelude System.Locale Control.Monad Data.Time.Clock.POSIX Data.Time> liftM (formatTime defaultTimeLocale "%c") getCurrentTime
11:38:44 <elemir> "Mon Mar 19 18:38:11 UTC 2012"
11:42:12 <monochrom> "time" already depends on "old-locale". if you have "time" installed, you already have "old-locale" installed
11:44:42 <gdoteof> formatTime defaultTimeLocale (gamingSessionStart gs) "%c"
11:44:53 <gdoteof> where (gamingSessionStart gs) is a UTCTIme
11:45:10 <elemir> > FormatTime t => System.Locale.TimeLocale -> String -> t -> String
11:45:11 <lambdabot>   <no location info>: parse error on input `=>'
11:45:23 <elemir> Look at function type
11:46:13 <gdoteof> oh
11:46:35 <paolino> hello, I want to create a new structure for every element of a given structure where only the element is modified:: [a] -> (a -> a) -> [[a]] if the structure is a list. Which abstraction could help ?
11:47:46 <monochrom> why is it not [a] -> (a->a) -> [a] or [a] -> (a -> [a]) -> [[a]]?
11:48:03 <elemir> paolino: How shoul it work at [0, 1, 2, 3] and (+ 1),
11:48:39 * elemir really can't proof function with " [a] -> (a -> a) -> [[a]]" type
11:48:55 <paolino> [[1,1,2,3],[0,2,2,3],[0,1,3,3]]
11:49:50 <elemir> Hem
11:50:15 <paolino> ,[0,1,2,4]]
11:50:20 <jfischoff> @djinn f ? (Monad m) => m a -> (a -> a) -> m (m a)
11:50:21 <lambdabot> Cannot parse command
11:50:45 <jfischoff> well, it can't be realized anyway
11:51:03 <sipa> @djinn (Monad m) => m a -> (a -> a) -> m (m a)
11:51:03 <lambdabot> -- f cannot be realized.
11:51:06 <rostayob> jfischoff: djinn does not know about type classes
11:51:20 <sipa> @djinn m a -> (a -> a) -> m (m a)
11:51:20 <lambdabot> -- f cannot be realized.
11:51:31 <elemir> >__<
11:51:34 <rostayob> so it can't take advantage of Monad's functions
11:51:36 <t7> can everything be written in terms of fix?
11:52:03 <t7> and application and abstraction
11:52:06 <jfischoff> rostayob: I just cabal install it and it does now atleast
11:52:06 <rostayob> t7: "everything"? you mean every recursive function?
11:52:09 <monochrom> the best haskell tutorial cannot be written in terms of fix
11:52:13 <t7> yeah like map
11:52:16 <rostayob> yes
11:52:40 <jfischoff> rostayob: it has Monad and Eq built into the default environment
11:52:40 <elemir> "the best haskell tutorial cannot be written" fix
11:52:57 <rostayob> jfischoff: ok, didn't know about that. are they hardcoded or it is actually aware of typeclasses?
11:53:24 <tromp__> everything can be written in terms of s and k
11:53:24 <jfischoff> rostayob: according to the help you can add your own
11:53:26 <rostayob> paolino: anyway, that looks like a job for Traversable
11:53:36 <rostayob> jfischoff: oh right, like types
11:53:41 <jfischoff> rostayob: yep
11:53:51 <t7> tromp__: i wrote a lambda calc to ski converter the other day
11:54:01 <jfischoff> rostayob: but Monad is built in, hence my confusion
11:54:05 <t7> why do i ask silly things
11:54:20 <rostayob> everything can be written in terms of iota!
11:54:21 <paolino> rostayob, I could't realize it, I thought comonad, but it's out of my knowledge
11:54:22 <tromp__> t7: cool. what does it convert \x y->y to?
11:54:50 <rostayob> paolino: I don't get what your function does tbh. '[a] -> (a -> a) -> [[a]]'
11:55:00 <t7> i forget, i used the optimization on wikipedia
11:55:04 <t7> so it wasnt huge
11:56:13 <tromp__> mine used various rules to mimic Turner's combinators, while still only using s and k
11:56:52 <t7> tromp__: i couldnt make mine very type safe
11:56:53 <paolino> rostayob, if you have a function [a] -> b and you want it to sample it on all the lists from a given one where you change only one element for each
11:57:11 <paolino> or a Map
11:57:22 <t7> http://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis      rules   5 and 6 ruined my beautiful code
11:57:22 <tromp__> s and k are pretty much untyped
11:57:32 <jfischoff> paolino: paste and example
11:57:40 <rostayob> S and K can be typed as the lambda-calculus can
11:57:43 <t7> tromp__: no i mean the LambdaCalc -> SKIcalc
11:57:48 <rostayob> paolino: yeah post the code for your function
11:58:12 <paolino> mh, which function ?
11:58:15 <t7> i had to have a LambdaCalc -> HorribleHybrid
11:58:25 <t7> then convert the hybrid to ski
11:58:37 <jfischoff> paolino: a specific example of what you are talking about.
11:58:50 <rostayob> paolino: your '[a] -> (a -> a) -> [[a]]' function, because I still don't get what it does
11:59:33 <paolino> @paste
11:59:33 <lambdabot> Haskell pastebin: http://hpaste.org/
12:00:09 <tromp__> that T transformation looks a bit ugly
12:00:27 <tromp__> having to re-introduce lambda in rule 6
12:00:40 <jfischoff> @djinn f ? (a -> m a) -> m a -> (a -> a) -> m (m a)
12:00:40 <lambdabot> Cannot parse command
12:00:51 <tromp__> cleaner to make T have 2 arguments, just like lambda
12:01:03 <jfischoff> @djinn (a -> m a) -> m a -> (a -> a) -> m (m a)
12:01:04 <lambdabot> -- f cannot be realized.
12:02:28 <elemir> rostayob: He wants something like: (g lst f) !! i !! j === lst !! j if i /= j, (g lst f) !! i !! i === f $ lst !! j
12:02:58 <rostayob> elemir: that is not a function.
12:03:05 <elemir> Argh
12:03:21 * elemir tried to explain semantic
12:04:38 <geekosaur> rostayob, he wants the input list replicated as many times as the number of elements in it, on replication N the Nth element has been replaced by application of F to the original Nth element
12:04:49 <hpaste> paolino pasted “cannot be realized” at http://hpaste.org/65581
12:05:10 <paolino> not tried actually
12:05:33 <rostayob> geekosaur: ok, thanks.
12:06:08 <t7> @djinn m m a -> m a
12:06:09 <lambdabot> Error: cyclic kind
12:06:17 <t7> @djinn m (m a) -> m a
12:06:17 <lambdabot> -- f cannot be realized.
12:06:25 <rostayob> paolino: you can do that generally with traversable.
12:06:28 <t7> @djinn a -> m a
12:06:29 <lambdabot> -- f cannot be realized.
12:07:10 <paolino> rostayob, yeah, throw away the splitAt
12:08:35 <rostayob> paolino: is something like this: 'Traversable t => (a -> a) -> t a -> [t a]' good enough?
12:08:54 <paolino> yes
12:08:56 <rostayob> or do the results have to be contained themself in the data structure
12:09:05 <rostayob> yeah then you can do that
12:09:41 <rostayob> I think...
12:10:23 <paolino> I think Zip is necessary, but I'm here asking
12:10:56 <ski> t7 : `djinn' doesn't know `Monad'
12:11:49 <rostayob> paolino: with traversable you can get the number of elements in the data structure. then my idea would be to keep a counter in a state monad and run the action so that it modifies only the nth element
12:11:59 <rostayob> not necessarly State, but you get the idea
12:12:03 <Luke> ClaudiusMaximus: you mentioned before manipulating IO actions in parallel without preforming them, how would that work? currently I'm using the CSV-enumerator stuff and am not running the IO actions directly myself. I'm not sure if I have access at that level
12:12:48 <rostayob> paolino: I'm pretty sure that would work.
12:13:08 <paolino> rostayob, it seems quadratic
12:13:17 <rostayob> yeah it's bad
12:14:08 <rostayob> it's exactly the same that you're doing in your pasted code. of course you can do it more efficiently with lists
12:14:18 <ski> (t7 : also, you didn't add `Monad t', so those are correct answers, regardless)
12:14:29 <nolrai_portland> So anyone install EclipseFP recently?
12:14:36 <paolino> rostayob, it can be linear with lists ?
12:14:48 <elemir> @djinn Monad m => a -> m a
12:14:48 <lambdabot> f = return
12:14:49 <nolrai_portland> I really don't want to go back to just using geany...
12:14:57 <rostayob> nolrai_portland: emacs
12:15:03 <elemir> @djinn Monad m => m a -> m m a
12:15:03 <lambdabot> Error: cyclic kind
12:15:09 <elemir> @djinn Monad m => m a -> m (m a)
12:15:09 <lambdabot> -- f cannot be realized.
12:15:16 <elemir> :(
12:15:35 <rostayob> paolino: I'm not sure actually
12:16:51 <ski> hm, maybe it does know `Monad'
12:16:54 <ski> @djinn-env
12:16:55 <lambdabot> data () = ()
12:16:55 <lambdabot> data Either a b = Left a | Right b
12:16:55 <lambdabot> data Maybe a = Nothing | Just a
12:16:55 <lambdabot> data Bool = False | True
12:16:55 <lambdabot> data Void
12:16:57 <lambdabot> type Not x = x -> Void
12:16:59 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
12:17:01 <lambdabot> class Eq a where (==) :: a -> a -> Bool
12:17:03 <lambdabot> data DCont r a = DCont ((a -> r) -> r)
12:17:05 <lambdabot> type Cont r a = (a -> r) -> r
12:17:07 <lambdabot> data Lens a b = L (a -> (b, b -> a))
12:17:18 <nolrai_portland> What is lambdabot doing?
12:17:28 * ski forgets if that's in by default, or if he added it some time ago
12:17:29 <elemir> Everything
12:17:34 <rostayob> paolino: right now I'd say you can't...
12:18:09 <elemir> ski: By default
12:18:42 <ski> t7 : in any case, `djinn' doesn't handle higher-rank types, which means that it doesn't handle methods polymorphic in tyvars other than those in the class head (such as is the case with `Monad', e.g.)
12:19:34 <elemir> Is there vim module for djinn support?
12:19:51 <ski> elemir : yeah, you're right
12:26:15 <parcs`> > execWriter $ forever $ tell ("hi" :: String)
12:26:16 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
12:26:38 <rostayob> > fix (++"hi")
12:26:38 <ksf__> > cycle "hi"
12:26:39 <lambdabot>   can't find file: L.hs
12:26:41 <lambdabot>   mueval-core: Time limit exceeded
12:26:47 <rostayob> uh-oh.
12:27:07 <ksf__> > take 50 $ cycle "hi"
12:27:08 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihi"
12:27:13 <ksf__> > cycle "hi"
12:27:14 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
12:27:17 <ksf__> wtf
12:27:36 <Mathnerd314> lambdabot is multithreaded?
12:27:44 <parcs`> yes and multiprocess
12:28:04 <parcs`> and webscale
12:28:13 <Mathnerd314> probably has a memory leak or something
12:28:30 <rostayob> lambdabot is buzzwords-compliant
12:28:52 <c_wraith> lambdabot has a process leak, actually
12:29:04 <elemir> It's something like a God
12:29:14 <c_wraith> it's pretty easy to get tons of muevals with it
12:29:24 <tgeeky__> elemir: so, a dog?
12:29:51 <elemir> Like a dog too :3
13:32:13 <jeff_s_> If I have many many threads, is having each thread reading from a TVar faster than having each thread read from a MVar? I'm thinking TVar should be faster, since each read of a MVar takes and puts, whereas TVar just reads.
13:33:03 <jeff_s_> Hm, this should be easy to test.
13:33:51 <c_wraith> jeff_s_: if the use pattern is many reads, few writes, an IORef is probably your best bet. (with atomicModifyIORef)
13:33:55 <parcs`> TVars are a part of STM which adds overhead, though
13:34:04 <c_wraith> jeff_s_: TVar only makes sense if you're doing transactional stuff
13:36:33 <jeff_s_> Thanks, I'll try IORef.
13:36:59 <ski> there's also `SampleVar'
13:37:40 <c_wraith> ski: SampleVar is built on top of MVar - and designed for the opposite use case.  Many writes, occasional reads
13:37:49 <jeff_s_> IORef should be fine. I just need a variable to use for stop-the-world.
13:38:26 <jeff_s_> (sort of - I need the threads to continue running, but they need to check a value to change their behavior in an emergency.)
13:39:02 <ski> c_wraith : yea, just mentioning it as something that doesn't do `take' and `put'
13:40:03 <jeff_s_> I take it MVar is a Maybe IORef.
13:40:22 <c_wraith> no
13:40:25 <c_wraith> not even close
13:40:37 <c_wraith> MVar is a primitive with deep hooks into the GHC runtime
13:40:45 <c_wraith> and the scheduler in particular
13:40:58 <c_wraith> IORef is just a mutable memory location
13:42:04 <jeff_s_> Oh right, because threads need to "wake up" when an MVar is filled, so it can't be as dumb as an IORef.
13:45:22 <c_wraith> Yeah. In order to remain consistent, MVars use locks in their code in a couple spots. IORefs have nothing that complex. Even atomicModifyIORef doesn't lock - it uses an atomic compare-and-swap operation in a loop to perform its update.
13:45:45 <ski> hm, iirc, `MVar' could be implemented in terms of `QSem'
14:01:53 <danharaj> That awkward moment when you realize your arrow type is equivalent to a monad.
14:07:05 <hpc> danharaj: i expect a lot of arrows people write can be defined in terms of Kleisli
14:10:23 <jeff_s_> For a value being modified by many threads, must I always use atomicModifyIORef instead of IORef? I ask because the type of atomicModifyIORef resembles a map, which I don't think I need.
14:10:46 <jeff_s_> I'm not quite sure what it means.
14:11:38 * hackagebot url 2.1.3 - A library for working with URLs.  http://hackage.haskell.org/package/url-2.1.3 (IavorDiatchki)
14:11:47 <jeff_s_> I'll perform some experiments
14:11:53 <geekosaur> :t atomicModifyIORef
14:11:53 <lambdabot> Not in scope: `atomicModifyIORef'
14:12:01 <geekosaur> hm, rght
14:12:15 <jeff_s_> :t Data.IORef.atomicModifyIORef
14:12:17 <lambdabot> forall a b. GHC.IORef.IORef a -> (a -> (a, b)) -> IO b
14:12:44 <jeff_s_> I was expecting IORef a -> (a -> a) -> IO ()
14:12:49 <jeff_s_> just like modifyIORef.
14:13:58 <ski> @type \ref -> Data.IORef.atomicModifyIORef ref . const
14:13:59 <lambdabot> forall a b. GHC.IORef.IORef a -> (a, b) -> IO b
14:14:32 <ski> @type \ref -> Data.IORef.atomicModifyIORef ref . (runState . return)
14:14:33 <lambdabot> forall b. GHC.IORef.IORef b -> b -> IO b
14:14:35 <monochrom> atomicModifyIORef is the minimum requirement
14:14:59 <jeff_s_> Hm, so it looks like you can both modify the contents of the IORef, while returning a potentially unrelated value.
14:15:11 <geekosaur> that's what I'm seeing in the source
14:15:21 <monochrom> it has a real return value because consider "increase x but tell me the old value"
14:15:23 <geekosaur> enables you to use a computation atomically that produces additional data
14:15:42 <ski> @type \ref -> Data.IORef.atomicModifyIORef ref . (&&& id)
14:15:43 <lambdabot> forall c. GHC.IORef.IORef c -> (c -> c) -> IO c
14:15:47 <ski> @type \ref -> Data.IORef.atomicModifyIORef ref . (&&& const ())
14:15:49 <lambdabot> forall c. GHC.IORef.IORef c -> (c -> c) -> IO ()
14:15:56 <geekosaur> could be the old value, could be something else that you need to have generated along with the atomic value
14:16:03 <monochrom> yes
14:16:06 <jeff_s_> That sounds good to me. Would be nice if that was in the documentation. And why does modifyIORef not do that? It seems kind of arbitrary (Not that I've spent time thinking about it).
14:16:10 <hpc> could also just be ()
14:16:30 <geekosaur> yeh, the documentation really needs to be fixed
14:16:32 <hpc> jeff_s_: because when there aren't any race conditions, you can juts read and compute before modifying
14:16:37 <geekosaur> I shouldnt have had to load the source to find that out
14:16:44 <jeff_s_> I guess it has to do with atomicity. You can always do a read after a modify, if you don't care about being atomic.
14:16:49 <hpc> geekosaur: i couldn't even figure it out from the source
14:16:49 * JDiogoR Boa noite :D
14:16:54 <ski> @type let swap = snd &&& fst in \ref -> Data.IORef.atomicModifyIORef ref . (swap .: runState)
14:16:55 <lambdabot> forall a b. GHC.IORef.IORef a -> State a b -> IO b
14:17:01 <hpc> it looked like deep magic with a gimped hugs implementation
14:17:12 <geekosaur> hpc, I used the Hugs implementation in the source link from the haddock
14:17:17 <geekosaur> was retty clear to me
14:17:33 <maxerize> how does functional programming work
14:17:41 <mauke> you build expressions
14:17:55 <monochrom> that question is too general
14:18:00 <hpc> @faq how does functional programming work
14:18:01 <lambdabot> The answer is: Yes! Haskell can do that.
14:18:08 <maxerize> in the sense that i don't understand haskell or clojure or scala
14:18:39 <maxerize> I don't see how one could build useful apps without objects to store data or methods etc.
14:18:44 <tromp__> it works purely
14:18:51 <ksf__> objects are mere closures.
14:18:57 <ski> maxerize : you define your program as a collection of functions whose bodies are expressions calling other functions (or calling the same function in recursion)
14:19:05 <mauke> maxerize: you can store data in non-objects
14:19:12 <ksf__> maxerize, the best way to understand that is reading some code.
14:19:18 <mauke> s/reading/writing/
14:19:36 <ski> maxerize : you compute results by sending values returned from other function as arguments to new functions
14:19:36 <maxerize> ksf__: Don't understand anything, it looks like obfuscated code 2012
14:19:47 <hpc> maxerize: do you have ghc/ghci?
14:19:52 <maxerize> But wouldn't that make it something like f(g(h()))
14:19:52 <mauke> maxerize: well, then you better give up
14:19:57 <monochrom> read, guess behaviour, verify behaviour empirically, be a scientist
14:20:00 <maxerize> hpc: yes
14:20:05 <jeff_s_> maxerize: http://book.realworldhaskell.org
14:20:24 <hpc> maxerize: ill paste some code for you to read, sec
14:20:58 <monochrom> every foreign language looks obfuscated
14:21:34 <hpc> maxerize: http://hpaste.org/65586 -- save that to a file and run main
14:21:38 <monochrom> spend some effort if you want to understand, or decide not to understand if you don't want to spend the effort
14:22:14 <jeff_s_> Except Klingon. Don't spend effort on learning that.
14:22:18 <maxerize> monochrom: I don't think that making an effort is the problem here, it has to do with my understanding of functional programming on a theoretical basis
14:22:34 <monochrom> I completely disbelieve in that.
14:22:42 <ksf__> you won't get that understanding without reading and trying to understand code.
14:22:44 <monochrom> How do people learn Chess?
14:22:54 <jeff_s_> maxerize - basically, anything you can do in your C or Java with loops, you do with recursion instead. Limit yourself to recursion, and you'll be half way to programming with haskell.
14:23:06 <monochrom> Do they begin by reading and writing essays on "theoretical" basis of Chess?
14:23:06 <mauke> maxerize: why do you think programs need objects?
14:23:10 <jeff_s_> Well, maybe 1/100 the way.
14:23:17 <hpc> monochrom: alpha-beta pruning, a dictionary of opening moves, and a cray
14:23:22 <hpc> ;)
14:23:46 <ski> s/Limit/"Limit"/
14:23:51 <ksf__> yep. then use at least 80% expressions instead of statements, and another 15% first-class statements you pass around and not merely execute.
14:24:09 <danr> hpc: what's a cray?
14:24:10 <monochrom> I'm pretty sure hell no, people learn Chess by hearing and trying its rule, a bit by a bit. very slowly, but very practically. no "theory" up front.
14:24:20 <sclv> wut?
14:24:22 <hpc> https://duckduckgo.com/Cray
14:24:24 <ChristianS> hpc: i somehow doubt that showing people how to use the do monad to read and print a value will tell them much about functional programming...
14:24:34 <sclv> kids these days.
14:24:36 <danr> hpc: a supercomputer?
14:24:38 <mauke> what's a do monad?
14:24:39 <ski> maxerize : after a while of practice, reading and writing basic code, it will "click"
14:24:46 <maxerize> mauke: because i've only used object-oriented programming until now
14:24:49 <hpc> ChristianS: the important part was supposed to be "forever"
14:24:51 <hpc> oh well
14:24:51 <maxerize> jeff_s_: thanks, that makes sense
14:24:54 <ksf__> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
14:24:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:24:58 <ksf__> that's haskell.
14:24:58 <sclv> a do run run
14:25:10 <mauke> maxerize: maybe try C first :-)
14:25:12 <maxerize> hpc: thanks
14:25:23 <monochrom> eventually you will want to hear about abstract strategies etc but that's after playing a thousand games, not before. all the abstract talks would just be buzzwords if not backed by your own experience.
14:25:27 <maxerize> well, I saw a little bit of c before c+
14:25:29 <maxerize> *c++
14:25:32 <ChristianS> mauke: a do monad is obviously nonsense, thanks for finding the bugs in my remarks
14:25:40 <ChristianS> a do block*
14:25:42 <danr> hpc: or did you mean this? https://en.wikipedia.org/wiki/Crayfish
14:26:01 <mauke> maxerize: C isn't object oriented
14:26:21 <maxerize> I know, I simply didn't see a lot of it before c++
14:27:05 <maxerize> hpc: forever is a function that loops infinitely?
14:27:20 <hpc> maxerize: yes; it's one kind of loop function
14:27:25 <maxerize> what is the syntax in 'n = forever $ do'
14:27:37 <maxerize> var = function $ do
14:27:38 <maxerize> ?
14:27:45 <ksf__> it passes the do block as parameter to forever
14:28:02 <hpc> lemme comment it, actually
14:28:04 <ksf__> you can read the $ as ( and a ) at the very end.
14:28:05 <maxerize> Ah, I see. Thanks.
14:28:09 <ski> maxerize : `forever $ do ...' is just another way to write `forever (do ...)' -- `forever' is just an ordinary function, being passed an argument `do ...' here
14:28:20 <hpc> i just got back from work and im thinking in "hack the problem away" mode right now :P
14:28:22 <mauke> maxerize: $ is a user-defined operator
14:28:31 <ksf__> @src ($)
14:28:31 <lambdabot> f $ x = f x
14:28:38 <ksf__> (it's a precedence trick)
14:28:54 <ben> runST $ do...
14:29:27 <SoleSoul> Hi! I have a function with two pattern matches hence there are two lines with the name of the function. The value is the same for both the matches except for a little change in the where clause of each one. Is it possible to have a combined value line for both of them with only the where clause changed?
14:29:34 <hpc> http://hpaste.org/65587
14:30:01 <hpc> for extra credit, do-notation is syntactic sugar
14:30:02 <ksf__> maxerize, in OO terms, you create an object which captures that getLine etc, and pass it to a method that repeatedly calls the right method in that objcet.
14:30:11 <hpc> and what the compiler ends up seeing is
14:30:18 <hpc> forever action = action >> forever action
14:30:20 <hpaste> SoleSoul pasted “identical except for the where” at http://hpaste.org/65588
14:30:24 <hpc> (for some (>>))
14:30:39 <ski> @undo forever action = do action; forever action
14:30:39 <lambdabot> forever action = action >> forever action
14:30:40 <maxerize> hpc: Thanks very much :)
14:30:53 <hpc> main = forever $ putStrLn "..." >> getLine >>= \name -> putStrLn (...)
14:31:13 <hpc> that (\name -> ...) is lambda syntax
14:31:22 <ksf__> SoleSoul, pass that what varies as a function to writeScales.
14:31:37 <hpc> it's a function that takes a parameter, "name", and evaluates the body with it
14:31:50 <jeff_s_> SoleSoul - or bind the two values you need to top level names.
14:32:01 <ksf__> SoleSoul, but in general, I'd keep it like it is.
14:32:28 <kaitocracy> hi when I try to run my program with +RTS -p, nothing happens
14:33:10 <danharaj> uggghh
14:33:19 <danharaj> "Could not deduce Functor from Monad" or whatever the fuck.
14:33:22 <danharaj> I HATE THAT.
14:33:47 <SoleSoul> ksf__, jeff_s_: I didn't understand your suggestions. Sorry :). can you add a few more words?
14:33:54 <ksf__> danharaj, with 7.4 you can write a Functor class that can do that.
14:34:07 <danharaj> ksf__: hmm yet another reason to upgrade.
14:34:18 <danharaj> Still not enough reasons but 7.4 is making a name for itself.
14:34:46 <ksf__> oh, wait, forget what I said, variable catching doesn't work out.
14:35:05 <mdmkolbe> How do I tell GHC to accept "GHC.Tuple.(,) a b" as a pattern?  It is giving me a parse error.
14:35:12 <ksf__> SoleSoul, don't worry, that's not the kind of code duplication that's bad.
14:35:31 <ski> danharaj : `liftM' ?
14:35:33 <danharaj> mdmkolbe: I think there's the extension TupleSections that does that maybe?
14:35:34 <ksf__> danharaj, well, you'd have to write your own Functor class, or hack the prelude.
14:35:39 <mdmkolbe> Alternatively, is there a better way to print Template Haskell generated code in a way that GHC will be happy to parse back in?
14:35:43 <danharaj> ski: Yeah I can do that.
14:35:47 <maxerize> hpc: So many types
14:35:59 <SoleSoul> ksf__: It just doesn't feel right to me that it is written twice.
14:36:19 <tgeeky__> mdmkolbe: there are the 'tuple' packages, and 'rex'
14:36:20 <ksf__> mdmkolbe, first, try -ddump-splices
14:36:28 <tgeeky__> mdmkolbe: ignore 'rex', wrong thing
14:36:41 <ksf__> then there's a program that just expands TH and outputs haskell, but I forgot its name.
14:36:51 <tgeeky__> ksf__: zeroth, but it doesn't compile
14:36:52 <ksf__> SoleSoul, well, it's actually different things.
14:37:06 <parcs`> SoleSoul: removing the code duplication is possible but will just add way more complexity to your code -- it's not worth it in this case
14:37:08 <mdmkolbe> ksf__: -ddump-splices prints malformed Haskell code (it is missing paratheses and mixes braces in bad places)
14:37:22 <ksf__> SoleSoul, you could wield magic and have less duplication, but it'd make the code non-obvious.
14:37:39 <maxerize> Am I correct in saying that functional programming languages treat data as something that is constantly passed around instead of explicitely stored in memory?
14:37:51 <SoleSoul> ksf__, parcs`, jeff_s_: Ok. Thank you!
14:38:05 <tgeeky__> mdmkolbe: http://hackage.haskell.org/package/adaptive-tuple . http://hackage.haskell.org/package/tuple-th
14:38:21 <tgeeky__> mdmkolbe: http://hackage.haskell.org/package/tuple-gen
14:38:54 <mewalz> Suppose I have a two type classes Foo and Bar. How can I define an instance of Foo in terms of Bar? For example, is it possible to make a Functor instance for all Monads?
14:39:10 <ski> maxerize : that's more or less true, yes
14:39:13 <rostayob> mewalz: yes but it's a problem
14:39:21 <rostayob> because Haskell doesn't backtrack when picking instances
14:39:35 <rostayob> something like 'instance Functor f => Monad f where ..." will always match
14:39:36 <ksf__> mdmkolbe, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zeroth
14:39:50 <ski> maxerize : however, there's of course data structures storing things in FP as well. it's just that those data structures tend to be immutable (so they are values, albeit complex values)
14:39:53 <rostayob> mewalz: also, how would haskell decide between a specific instance (if there is one) and that?
14:39:56 <tgeeky__> ksf__: I think getting it to compile is non-trivial
14:40:00 <ksf__> yep.
14:40:17 <ksf__> well, ghc 6.8 should work.
14:40:22 <tgeeky__> haskell needs it though. someone fix it? :o
14:40:30 <ksf__> and it's a program, not a library, so it'd be usable.
14:40:40 <ksf__> ...modulo possibly choking on newer extensions.
14:40:45 <rostayob> mewalz: what would solve that specific problem is to have 'class Applicative m => Monad m where; (>>=) :: m a -> (a -> m b) -> m b'
14:41:34 <mdmkolbe> ksf__: that definately looks like the sort of thing I need
14:41:35 <mewalz> thanks, I think that solves my problem
14:41:45 <maxerize> ski: ok, thanks
14:41:49 <hpc> class Monad m => MonadFail m where fail :: String -> m a -- having that shortcut with do-patterns is still nice
14:41:52 <ksf__> maxerize, in the haskell case, data is almost completely code and code is almost completely data. more so than in e.g. lisp.
14:42:29 <ksf__> for example...
14:42:36 <ksf__> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
14:42:37 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:42:52 <ksf__> ...which is an infinite list which is 99.999% code.
14:43:57 <ksf__> it computes fibonacci in the same way as the iterative method, but threads each step into an acessible slot in a list.
14:44:14 <ksf__> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! 1000
14:44:15 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
14:44:40 <rostayob> mewalz: btw, "instance Foo a => Bar a where ..." is not standard haskell
14:44:45 <rostayob> (you need FlexibleInstances)
14:45:15 <parcs`> and UndecidableInstances
14:45:50 <rostayob> no
14:46:10 <rostayob> ah sorry, yes.
14:46:29 <ski> maxerize : have you found a tutorial or a book to read, yet ?
14:46:39 * hackagebot ekg 0.3.0.3 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.3.0.3 (JohanTibell)
14:55:00 <t7> no one ever learnt anything reading books
14:55:33 <mauke> I learned C++ from a book!
14:55:36 <geekosaur> ...
14:55:54 <monochrom> I learned something by reading books. but I also practiced. the two combined.
14:55:58 <maxerize> ski: i'm reading real world haskell
14:56:10 <monochrom> without books, I wouldn't know what to practice.
14:56:24 <maxerize> there are many different types and the vocabulary is quite different
14:56:40 <hpc> i learned haskell from LYAH
14:56:40 <t7> i kid, ofcorse. I leaned git from a book
14:56:43 <hpc> and it's a book
14:56:51 <hpc> (i even got it for free from BONUS)
14:57:02 <hpc> ((and no, i will never stop bragging about that))
14:57:03 <t7> LYAH put me off haskell for a week
14:57:09 <t7> but i cam crawling back
14:57:50 <t7> and now i have been coding in haskell for like a year and still see myself as a novice
14:58:12 <parcs`> hpc: freeloader!
14:58:30 <rostayob> I learnt Haskell from a person! and "Programming in Haskell">
14:59:07 <rostayob> and #haskell.
14:59:17 <rostayob> actually mostly #haskell.
14:59:30 <ski> maxerize : ok
15:00:05 <ski> maxerize : you should be prepared that learning a different programming paradigm (like functional programming) is a bit like learning to program from scratch again
15:00:19 <maxerize> I can certainly feel it :)
15:00:24 <ski> maxerize : what do you mean by "there are many different types" ?
15:00:37 <monochrom> IIRC hpc is not a freeloader. he wrote a review in exchange for a copy.
15:01:01 <ski> @where LYAH
15:01:01 <lambdabot> http://www.learnyouahaskell.com/
15:01:03 <maxerize> Well
15:01:10 <ski> maxerize : if you want to try LYAH as well, there it is ^
15:01:32 <rostayob> maxerize: you shouldn't start with RWH. that's a cookbook style book
15:01:33 <maxerize> The way you define a function by types, compared to python and its extremely loose typing
15:01:39 <ski> (LYAH might perhaps be slightly easier for a beginner -- probably depends on the person, though)
15:01:46 <monochrom> there are many Chess pieces and they all have funny names. there are even more in Chinese Chess.
15:02:10 <maxerize> Right, going to switch to learn you a haskell then. Thanks
15:02:22 <ski> maxerize : yes, Haskell is statically typed (like C,C++,Java,C#,&c. (and still, *not* like those)), while Python is dynamically typed
15:02:38 <ski> maxerize : you can check out both of the books, see which you prefer
15:03:48 <ski> maxerize : e.g. saying `foo :: Int -> Double -> Char' in Haskell is a bit similar to saying `char foo(int,double);' in C
15:04:07 <rostayob> (python is strongly typed)
15:04:16 <weexplat> what's the best way to canonicalize a filename in haskell?
15:04:19 <maxerize> ski: so the last -> indicated the return type?
15:04:45 <Saizan> weexplat: System.FilePath has something like a normalise function
15:04:49 <weexplat> the C file i'm porting changes the working directory and calls realpath, then changes back (the latter change is unchecked)
15:05:26 <weexplat> the only way to make that approach safe is to fork and write the canonicalized filename on stdout!
15:06:20 <ski> maxerize : yes
15:07:01 <maxerize> also, does: a `operation` b == (operation a b)
15:07:17 <monochrom> yes. after adding more parentheses to be safe
15:08:05 <maxerize> i.e (a) (b) ?
15:08:10 <monochrom> yes
15:08:42 <ski> maxerize : however, `foo :: Int -> Double -> Char' really means `foo :: Int -> (Double -> Char)', which in C terms would be `char (*foo(int))(double)', i.e. a function which takes an `Int' as argument, and *returns* a function that takes a `Double' as argument and returns a `Char'
15:09:07 <maxerize> wat
15:09:10 <tromp__> > succ 1 `max` pred 2
15:09:11 <lambdabot>   2
15:09:14 <ski> maxerize : usually, we read it as `foo :: Int -> Double -> Char' declaring `foo' as a function taking two arguments of types `Int' and `Double' and returning a `Char', though
15:09:24 <maxerize> oh
15:09:25 <tromp__> > max (succ 1) (pred 2)
15:09:26 <lambdabot>   2
15:09:31 <ski> maxerize : however, sometimes, this function-returning-function business is very useful
15:09:33 <tromp__> > max succ 1 pred 2
15:09:34 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
15:09:34 <lambdabot>    arising from a use of `e_112' a...
15:09:36 <maxerize> and how does ghci know?
15:09:48 <ksf__> > (zip`ap`tail) [1..]
15:09:49 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
15:10:10 <monochrom> "f x y" is a shorthand for "(f x) y"
15:10:58 <ksf__> > map (^2) [1..]
15:10:59 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
15:11:00 <monochrom> so, do "f x" first, oh, it returns a function, I can pass parameter y to that function
15:11:04 <ksf__> :t (^)
15:11:04 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:11:08 <ksf__> like there.
15:11:16 <ksf__> :t (^ 2)
15:11:17 <lambdabot> forall a. (Num a) => a -> a
15:11:18 <ski> > map (\n -> max 5 n) [0,3,6,9]  -- maxerize this is an example that is passing a function that takes a number `n' and returns the maximum of that number and `5'
15:11:20 <lambdabot>   [5,5,6,9]
15:11:36 <ski> maxerize : and `map' is calling that function on every element of a list, collecting a new list of the results
15:11:54 <ski> maxerize : do you follow this example, so far ?
15:12:40 <ksf__> > 10 `div` 2
15:12:41 <lambdabot>   5
15:12:45 <ksf__> > div 10 2
15:12:46 <lambdabot>   5
15:12:50 <ksf__> > (div 10) 2
15:12:51 <lambdabot>   5
15:12:59 <ksf__> > let f = div 10 in 2
15:13:00 <lambdabot>   2
15:13:03 <ski> maxerize : `\n -> max 5 n' is a function, the function that given `n' as argument will return `max 5 n'
15:13:05 <ksf__> > let f = div 10 in f 2
15:13:06 <lambdabot>   5
15:13:54 <ski> > let max5 = \n -> max 5 n  in  map max5 [0,3,6,9]  -- is another way of doing the same thing, this time giving the function a name `max5'
15:13:55 <lambdabot>   [5,5,6,9]
15:14:18 <ski> > let max5 n = max 5 n  in  map max5 [0,3,6,9]  -- is yet another way
15:14:19 <lambdabot>   [5,5,6,9]
15:14:58 * ski wonders whether maxerize is completely confused yet :)
15:15:21 <ksf__> @quote confus
15:15:22 <lambdabot> CharlesBabbage says: On two occasions I have been asked, 'Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?' I am not able rightly to apprehend the kind
15:15:22 <lambdabot> of confusion of ideas that could provoke such a question.
15:15:27 <ksf__> @quote confus
15:15:27 <lambdabot> newsham says: do'nt confuse larry wall's drug induced vision of computing with the state of reality
15:15:35 <ksf__> @quote confus
15:15:35 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
15:15:43 <ksf__> @quote confus
15:15:43 <lambdabot> Bulat says: we can also rename Pascal to Blez to avoid confusion
15:16:24 <monochrom> how do I convert Arrow to IO? :)
15:16:35 <weexplat> Saizan: if you mean System.FilePath.normalize it doesn't check for symlinks
15:16:54 <weexplat> (unless there's an unsafePerformIO hiding in there which i doubt)
15:17:12 <scooty-puff> is there a difference between class A a; instance B a => A a; and type A a = B a?
15:18:09 <ski> scooty-puff : yes, classes are not types
15:18:12 <Saizan> scooty-puff: assuming ConstraintKinds, the former doesn't let you deduce B a from an A a context
15:18:43 <Saizan> scooty-puff: it would with class B a => A a though
15:19:02 <scooty-puff> ok
15:19:10 <ski> oh .. apparently scooty-puff was talking about the difference between `instance B a => A a' and `type A s = B a', both in the context of `class A a'
15:27:24 <weexplat> so anything better than System.FilePath.normalize?
15:28:21 <monochrom> I'm afraid not. especially if you require symlink resolution, which seems a bit OS-specific
15:28:30 <monochrom> and which mandates IO
15:28:55 <monochrom> "how do I convert IO CanonicalFilePath to CanonicalFilePath?" :)
15:30:01 <weexplat> yes, i know it mandates IO.  symlinks are system-specific, but it's not like the user needs to know about them, that's all taken care of by the type signature 'FilePath -> IO FilePath' or whatever
15:30:13 <weexplat> @hoogle FilePath -> IO FilePath
15:30:14 <lambdabot> System.Directory canonicalizePath :: FilePath -> IO FilePath
15:30:14 <lambdabot> System.Directory makeRelativeToCurrentDirectory :: FilePath -> IO FilePath
15:30:14 <lambdabot> System.Posix.Files readSymbolicLink :: FilePath -> IO FilePath
15:32:06 <c_wraith> canonicalizePath might work
15:32:48 <c_wraith> in fact, it does
15:33:12 <monochrom> it seems to resolve a symlink. I have /usr/bin/ld symlink to /usr/bin/ld.gold (actually it's ubuntu and a ubuntu package). canonicalizePath "/usr/bin/ld" gives me "/usr/bin/ld.gold" successfully
15:33:33 <c_wraith> yeah, it resolves /home to /Users on my system (OS X)
15:33:46 <monochrom> oh, another use of IO is in canonicalizePath "f" -> "/absolutepath/f"
15:34:11 <monochrom> at the end, apparently the real use of IO is in just calling up some C function outside
15:34:55 <christian3> Hi everyone .. does anyone know whether there are restrictions on packages to upload to hackage? Is everyone (including myself ;) ) allowed to do so?
15:35:03 <monochrom> #if defined(mingw32 blahblah)  do path <- Win32.getFullPathName fpath
15:35:34 <weexplat> okay, canonicalizePath does what realpath does
15:35:41 <monochrom> #else ... c_realpath pInPath pOutPath ...
15:36:06 <weexplat> unfortunately it doesn't do (more safely, or otherwise) all the stuff that the horrible unsafe wrapper around realpath does
15:36:38 <monochrom> and then a call to "normalise", which is "like upper-casing the drive letter"
15:38:37 <weexplat> the 'get_full_path' procedure will canonicalize a given relative path with regard to a given directory
15:38:58 <weexplat> it does this by first changing directory to that directory, then calling realpath, then changing back
15:39:33 <weexplat> this can cause the program to end up with a different cwd than it started with, even if the change back is successful
15:44:36 <geekosaur> is there some reason it doesn't do the canonicalization in a child process which writes the result to the parent via a pipe?
15:46:18 <monochrom> that is a big sledgehammer. but I guess it's safer.
15:46:57 <geekosaur> there are safer ways to do it on some unixes but it's not portable
15:47:18 <geekosaur> (fchdir)
15:48:43 <geekosaur> (fchdir is POSIX but requires a fairly recent versions of the POSIX standard to be implemented)
16:04:23 <christian3> g'night..
16:09:13 <unlink> I'm counting inversions in a list, and I'm trying to figure out why my performance is *atrocious* (compared to a translation to a strict language). To quote The Simpsons, I've tried nothing and I'm all outta ideas!
16:09:15 <hpaste> unlink pasted “CountInversions.hs” at http://hpaste.org/65595
16:10:35 <c_wraith> unlink: isn't an inversion just when you have two adjacent elements out of order?
16:10:41 <Saizan> unlink: length is O(n) btw
16:11:36 <unlink> c_wraith: no, the two out-of-order elements needn't be adjacent.
16:12:20 <c_wraith> ah.
16:12:37 <Saizan> and you're likely accumulating big useless thunks in those Int's
16:13:16 <Saizan> splitAt is also O(n)
16:15:45 <unlink> Saizan: I've spent most of my time being baffled by the terrible space use characteristics of this program. Where am I being unnecessarily lazy?
16:17:08 <ski> @quote admitting.defeat
16:17:09 <lambdabot> Cale says: Computing lengths is admitting defeat
16:17:18 <hpc> haha
16:17:30 <c_wraith> unlink: you appear to be using a divide-and-conquer algorithm with a data structure not built for it.
16:17:39 <c_wraith> unlink: have you tried the simple algorithm first?
16:18:01 <unlink> c_wraith: The O(n^2) one? yeah, it's far slower.
16:18:17 <ski> unlink : maybe you want to use an array or a tree instead
16:18:36 <Saizan> or Seq from Data.Sequence
16:18:49 <c_wraith> Seq is a tree, for these purposes
16:19:19 <c_wraith> unlink: are you aware of what data structure [] is? You seem to be treating it as if it was an array.
16:19:28 <Saizan> unlink: those additions build up thunks
16:19:40 <unlink> c_wraith: looking over my code, I realize my stupidity.
16:20:11 <c_wraith> You could convert it into an array.  This is a case where immutable arrays are actually fine
16:20:25 <c_wraith> because you never modify it.  You just want fast lookups
16:21:00 <ski> c_wraith : yeah, though slices would be handy here
16:21:19 <unlink> yes. I now see that there is another key difference from my "strict" code.
16:38:05 <mhitza> hey guys, what could you infer from this combinators file definition and how? flip fmap (.) >>> (>>>)
16:38:33 <mhitza> function* definition
16:39:11 <hpc> :t flip fmap (.) >>> (>>>)
16:39:12 <lambdabot> forall b a b1 (f :: * -> *) c. (Functor f) => ((f a -> f b1) -> b) -> (b -> c) -> (a -> b1) -> c
16:39:37 <hpc> i can infer that i would write it another way
16:39:47 <mhitza> :)
16:40:02 <hpc> (>>>) = flip (.) -- for the (->) arrow
16:40:05 <hpc> so, that's
16:40:14 <hpc> :t fmap . flip fmap (.)
16:40:15 <lambdabot> forall b (f :: * -> *) a b1 (f1 :: * -> *). (Functor f, Functor f1) => ((f1 a -> f1 b1) -> b) -> f (a -> b1) -> f b
16:40:34 <hpc> :t flip fmap (.)
16:40:35 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => ((f a -> f b1) -> b) -> (a -> b1) -> b
16:40:54 <hpc> :t flip fmap
16:40:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
16:41:03 <hpc> yeah, i got nothing
16:41:06 <mhitza> hpc, do you know by head all combinators?
16:41:24 <c_wraith> no one knows them all
16:41:28 <hpc> ^
16:41:34 <c_wraith> if someone claims to, I'll create a secret library that has more. :)
16:41:34 <hpc> i know a lot of the interesting ones though
16:41:47 <mhitza> hpc, care to share more? :)
16:41:54 <hpc> :t (.:)
16:41:55 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:41:57 <c_wraith> But knowing most of the stuff from Control.Arrow, Control.Category, Control.Applicative, etc...  That's not too bad.
16:42:20 <hpc> yeah, Arrow + Applicative + Monad gives you most of what you will ever need
16:42:32 <hpc> semantic editor combinators gives you the really neat stuff
16:42:51 <mhitza> is there any book, or collection of papers on these combinators online
16:43:01 <hpc> if you download lambdabot's source, you can read State/L.hs to see what's in there
16:43:01 <mhitza> like specialized in combinators?
16:43:43 <hpc> nothing ive heard of
16:43:50 <mhitza> would be nice
16:44:19 <hpc> http://conal.net/blog/posts/semantic-editor-combinators
16:44:31 <hpc> (RE: what i mentioned above)
16:44:57 <mhitza> yeah, got it
16:45:15 <mhitza> yea*
16:45:56 <bgamari> Why does the latest Haskell Platform contain such an ancient GHC version?
16:47:10 <geekosaur> because ghc 7.2 was an experimental release and 7.4 only just came out
16:48:05 <bgamari> Ahh, I see
16:48:06 <bgamari> Thanks
16:48:59 <BrosefStalin> I will put my intense study of Functional Brogramming to all of your Schemes.
16:49:23 <sipa> yow yow
16:51:45 <geekosaur> next HP should be sometime next month, I think.  I don't know if they plan to support 7.4 or if they're waiting on more libraries to be updated.. or if the Num superclass change might be considered too large a change or somethinhg
16:54:19 <c_wraith> I think everything the platform depends on has been updated for that change
16:54:26 <c_wraith> But there have been some changes to the FFI
16:55:47 <hpc> geekosaur: part of me expects them to stagger the GHC major version and base major version
16:55:54 <adit> I'm getting a weird error with Text.Regex.Posix
16:55:57 <hpc> as a kind of separation of breakages
16:55:58 <adit> "test" =~ ".*?" :: Bool
16:56:05 <adit> Gives me *** Exception: user error (Text.Regex.Posix.String died: (ReturnCode 13,"repetition-operator operand invalid"))
16:56:34 <adit> It's happening because of the `?`
16:56:35 <c_wraith> adit: *? isn't a valid quantifier in posix regexes.  it was added by perl
16:56:45 <geekosaur> adit, POSIX REs don't support that
16:57:04 <hpc> what's *??
16:57:11 <geekosaur> non-greedy match
16:57:13 <c_wraith> hpc: match as few characters as possible
16:57:16 <hpc> oh right, dur
16:57:20 * hpc should have known that
16:57:34 <adit> ah okay
16:57:40 <adit> thanks c_wraith and geekosaur
16:57:58 <t4nk827> Hi all
16:58:14 <adit> hello
16:58:24 <Saizan> there's a PCRE package on hackage, i think
16:59:38 <geekosaur> several, one uses the Text.Regex interface, another is an extension thereto, a third is a direct binding
17:00:28 <adit> hrm
17:01:13 <adit> yeah, looks like I can just drop in regex-pcre and have it work
17:01:48 * hackagebot yesod-paginator 0.2.1 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.2.1 (PatrickBrisbin)
17:06:56 <dgpratt> oh my, am I excited!: there was this question on SO involving 'forall' and I kinda sorta almost knew the answer!
17:07:24 * ski idly wonders what it is about
17:07:24 <t4nk827> How can I filter words from two lists if they occur in both lists?
17:07:45 <ski> t4nk827 : you want the words which occur in both lists ?
17:08:04 <t4nk827> say like a = hello world
17:08:10 <dgpratt> ski: wonder no more: http://stackoverflow.com/questions/9779301/newtype-with-rankntypes
17:08:18 <t4nk827> b = world
17:08:39 <t4nk827> so c would give me world occurs in both a and b list
17:08:51 <ski> > words "i like strawberry ice-cream" `intersect` words "do you like strawberry cake"
17:08:53 <lambdabot>   ["like","strawberry"]
17:09:05 <t4nk827> cool
17:09:13 <t4nk827> thanks
17:09:24 <ski> > ["hello","world"] `intersect` ["the","world","is","enough"]
17:09:25 <lambdabot>   ["world"]
17:09:32 <t4nk827> perfect !!
17:09:39 <t4nk827> ski: thanks!
17:09:43 <ski> yw :)
17:12:41 <tibbe> anyone know of a way to peek at the next character, without consuming it, in attoparsec
17:14:00 <t4nk827> ski: what if I wanted to replace 'world' with '*****'
17:14:32 <t4nk827> or any words which intersects in two lists
17:18:12 <hpc> tibbe: i don't know even remotely enough about attoparsec to give a good answer, but you might try parsing a char, then backtracking and returning the char
17:18:18 <danharaj_> man I just learned about (| |) for arrow notation that stuff is hella useful.
17:18:35 <hpc> danharaj: they have that for arrow now?
17:18:40 <hpc> thought it was just applicative
17:18:51 <danharaj> hpc: Oh is it for applicative as well?
17:19:06 <t4nk827> ski: are you ther?E
17:19:12 <t4nk827> there?*
17:19:14 <danharaj> hpc: where are the docs for the applicative syntax?
17:19:18 <hpc> http://www.haskell.org/haskellwiki/Idiom_brackets
17:19:47 <tibbe> hpc: I could use try to backtrack I guess
17:19:50 <hpc> ...oh, not that
17:19:52 <tibbe> hpc: feels expensive though
17:20:07 <ski> t4nk827 : hm, replace that in the first list, or in the second ?
17:20:10 <ski> or in both ?
17:20:23 <tibbe> hpc: hmm, try doesn't do what I want either
17:20:29 <hpc> http://hackage.haskell.org/package/applicative-quoters
17:21:01 <t4nk827> ski: no like create a new list of intersect and then replace with asterisk
17:22:43 <hpc> something like that
17:22:50 <hpc> except with (|  |) syntax
17:24:17 <ski> > (map . map) (const '*') (words "i like strawberry ice-cream" `intersect` words "do you like strawberry cake")
17:24:19 <lambdabot>   ["****","**********"]
17:24:21 <ski> t4nk827 : like that ^ ?
17:24:50 * ski suspects not, but isn't sure what t4nk827 really wants here
17:25:10 <t4nk827> yh
17:25:53 <t4nk827> but can i paste my code
17:25:53 <t4nk827> so you can have a look
17:25:53 <t4nk827> that looks somewhere near
17:25:53 <t4nk827> ?
17:26:09 <ski> @paste
17:26:10 <lambdabot> Haskell pastebin: http://hpaste.org/
17:26:14 <ski> t4nk827 : use that ^ one
17:26:53 <t4nk827> sorry am not able to understand that.. what's ^?
17:27:15 <otters> it's an arrow pointing up
17:27:18 <t4nk827> or u mean <?
17:27:22 <t4nk827> oh sorry
17:27:33 <hpaste> snhmib pasted “darcs setpref test is failing me” at http://hpaste.org/65596
17:27:42 <t4nk827> ski: I didn't knew that works too
17:28:08 <snhmib> why wouldn't darcs run a test after i do setpref test?
17:28:17 <hpc> :t map . map
17:28:18 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
17:28:27 <adit> didn't know that one ^
17:28:30 <adit> pretty cool
17:28:36 <hpc> oh, i see what happened there
17:28:48 <hpc> :t (.:) -- what i would have used
17:28:49 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
17:28:56 <ski> t4nk827 : you didn't know *what* works too ?
17:29:12 <hpc> > (const '*') .: words "hello, yes this is dog"
17:29:14 <lambdabot>   ["******","***","****","**","***"]
17:29:18 <ski> adit : `(map . map) f' is `map (map f)'
17:29:31 <snhmib> hpc: o_O
17:30:05 <t4nk827> ski: ^ and cycle your name to send you direct message
17:30:08 <adit> ah I get it
17:30:31 <hpaste> t4nk857 pasted “error in replacing with asterisks” at http://hpaste.org/65597
17:30:35 <adit> map odd expects a list, so map . map odd expects a list of lists
17:30:53 <t4nk827> ski: there it is..
17:32:26 <t4nk827> ski: am trying to replace certain words which i pass it as command line arguements and then displays the text file which i pass as getContents
17:33:21 <t4nk827> ski: say if the text file contains poem... I feel like dancing in the rain.. if at cmd i enter ./myscript.hs feel
17:33:37 <elemir> Is STRef tread-safe?
17:33:47 <t4nk827> ski: it would be display as I **** like dancing in the rain
17:34:11 <ski> @hoogle atomicModify
17:34:12 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
17:35:18 <ski> elemir : i'm not sure, but would suspect not .. maybe try converting to `IORef', calling `atomicModifyIORef' ?
17:35:27 * ski looks at t4nk827's paste
17:35:40 <elemir> ski: crutches =(
17:35:51 * ski wonders how elemir is using `STRef' concurrently
17:36:44 <snhmib> anybody can help me with darcs? i think the people in #darcs are sleeping =]
17:37:00 <ski> @index getArgs
17:37:00 <lambdabot> System.Environment
17:37:01 <ski> @type System.Environment.getArgs
17:37:03 <lambdabot> IO [String]
17:37:47 <ski> t4nk827 : is there a point to calling `words' on each argument ?
17:38:05 <ski> hm
17:38:36 <t4nk827> it can be many words
17:39:05 <ski> yeah, but if you call `./myscript.hs foo bar', then `foo' and `bar' will already be two different arguments
17:39:18 <t4nk827> ski: yes
17:39:43 <ski> so, at least in common cases, `words' there will just convert each argument to a list containing only one word, which is the argument itself
17:39:48 <parcs`> snhmib: ask away
17:39:48 <t4nk827> then it will check for those words in whatever is passed in getContents and then replace those words with '*'
17:40:01 <elemir> Hem… May be rewrite STRef.Lazy to MState? :3
17:40:03 <ski> it seems to me that you really in the end want a list of words which should be checked for
17:40:29 <ski> so, either don't use `words' on the arguments, or use `concat' after the `map', to get a list of words (instead of a list of list of words)
17:40:36 <ski> (your choice)
17:40:50 <ski> elemir : `MState' ?
17:41:03 <elemir> http://hackage.haskell.org/package/mstate
17:41:20 <ski> mhm
17:41:24 <t4nk827> ski: ok
17:41:34 <snhmib> parcs`: i did a 'darcs setpref test' but it doesn't seem to run when i do darcs record
17:41:36 <ski> t4nk827 : anyway, i don't think you want `intersect', here
17:41:56 <snhmib> parcs`: this is a transcript of what i did: http://hpaste.org/65596
17:42:11 <t4nk827> then how can I filter those words which equals in two places
17:42:11 <t4nk827> ?
17:42:12 <ski> t4nk827 : i would `map' over the words in the input, checking for each word whether it's among the "special" words, and if so, replacing it with asterisks, otherwise keeping it
17:42:37 <t4nk827> ski: Yeah that what I want to do
17:42:53 <t4nk827> ski: any inspiration on that
17:42:54 <t4nk827> ?
17:43:44 <ski> though not strictly necessary, i would define `perLine' and `perWord' as in <http://www.haskell.org/haskellwiki/TV#IO> to handle the "for each word in the input" part
17:44:01 <ski> (i would just do this because i think this makes it more pretty)
17:44:19 <ski> t4nk827 : so, you have a string which is the contents of the input
17:44:38 <t4nk827> i would pass text file
17:44:40 <ski> you call `lines' on it to get a list of lines
17:44:54 <ski> then you call `words' on each of those lines to get a list of lists of words
17:45:09 <ski> then you transform each word with a transformer function
17:45:17 <t4nk827> ski: like-> cat poem.txt | ./myscript world strawberry cake
17:45:20 <ski> then you call `unwords' on each of the lists of words
17:45:42 <ski> then you call `unlines' on the list of lines, to get a final string to output using `putStr'
17:46:16 <parcs`> snhmib: "If a regression test is defined (see `darcs setpref') it will be run by `darcs check'.  Use the --no-test option to disable this."
17:46:24 <ski> the transformer function would check the word passed to it to see whether it matches any of the given "special" words, and in that case would replace it with asterisks, otherwise leaving it be
17:46:26 <t4nk827> ski: okay
17:46:26 <parcs`> looks like it only runs upon invocation of darcs check
17:46:54 <ski> t4nk827 : instead of using `lines' at the start and `unlines' at the end, you could more prettily use `perLine'
17:47:07 <ski> t4nk827 : instead of using `words' at the start and `unwords' at the end, you could more prettily use `perWord'
17:47:29 <ski> also, instead of using `getContents' at the start and `putStr' at the end, you could more prettily use `interact'
17:47:31 <t4nk827> ski: what i need to convert to lowercase to match their cases?
17:47:38 <t4nk827> ski: would*
17:47:54 <ski> t4nk827 : well, presumably the idea is to keep the original casing in the input
17:48:25 <ski> t4nk827 : so, you should then do a case-insensitive comparision when comparing each word from the input with the special words
17:48:40 <ski> btw, there could be another problem as well
17:48:42 <ski> consider
17:49:01 <t4nk827> ski: hmm
17:49:25 <ski> > words "I came, I saw, I conquered."
17:49:27 <lambdabot>   ["I","came,","I","saw,","I","conquered."]
17:49:42 <ski> note how `words' treat `,' and `.' as if they were parts of the words
17:50:06 <ski> you may or may not need to take this into consideration, depending on how your input text looks like, and what you're supposed to do
17:50:10 <snhmib> parcs`: it only runs when i do darcs check --test, otherwise not
17:50:12 <geekosaur> also note that you lose any formatting if you do the unwords/unlines thing
17:50:23 <t4nk827> ski: so which part of my code would you say needs to be changed more specifically ?
17:50:50 <t4nk827> ski: shall i get rid of the map words args?
17:50:51 <ski> t4nk827 : in the worst case, you may have to define your own `perWord :: (String -> String) -> (String -> String)', that passes only the proper words to the callbacl function
17:51:12 <ski> t4nk827 : well, i think `intersect' is inappropriate in your case
17:51:39 <ski> t4nk827 : "shall i get rid of the map words args?" -- depends on whether you want to handle arguments which contain space or not
17:52:10 <t4nk827> ski: intersect doesn't work :S
17:52:22 <t4nk827> ski: on my ghci
17:52:30 <ski> @index intersect
17:52:31 <lambdabot> Data.List, Data.Set
17:52:49 <ski> t4nk827 : so `:m + Data.List' or `import Data.List' in your GHCi, then
17:52:59 <t4nk827> done it
17:53:01 <parcs`> snhmib: ah, then i don't know. looks like the documentation is inconsistent or something
17:53:30 <parcs`> darcs record also has a --test flag, though
17:54:03 <t4nk827> ski: do i need 'intersect' or `intersect`
17:54:04 <t4nk827> ?
17:54:16 <adit> t4nk827: the second one
17:54:23 <t4nk827> ok
17:55:15 <snhmib> ah cool, i'll do manually for now :)
17:55:21 <snhmib> thanks parcs`!
17:56:11 <t4nk827> ski: adit I get lexical error in string/character literal at character 'n'
17:56:49 <adit> Can you paste your code and the error?
17:58:46 <monochrom> the error disappears as soon as someone tries to paste it :)
17:58:48 <t4nk827> words "I like Haskell" `intersect` words "Haskell is what I like"
17:59:03 <monochrom> > words "I like Haskell" `intersect` words "Haskell is what I like"
17:59:05 <lambdabot>   ["I","like","Haskell"]
18:00:40 <adit> erm. Incorrect encoding for your text editor?
18:01:11 <monochrom> haha that would be awesome
18:02:24 <adit> I have a linode box, and when I run into issues like this I usually run the code on the box too as a sanity check
18:02:33 <t4nk827> ski: I think I would call it a night now.. my eyes are flickering
18:03:22 <t4nk827> ski: thanks for your help, really appreciate.. will try to do the rest tommorrow and hopefully manage to sort it out soon
18:03:33 <t4nk827> adit: thanks adit for your help!
18:03:45 <adit> no problem...good luck :)
18:04:12 <t4nk827> ski: Thanks ski!! :D :Y
18:04:52 <mun> hi
18:05:09 <mun> does anyone know why haskell supports parametric polymorphism and not ad-hoc polymorphism?
18:08:25 <monochrom> type class is haskell's ad-hoc polymorphism story
18:08:47 <acowley> I love that story
18:09:04 <ion> “How to make ad-hoc polymorphism less ad hoc” http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps
18:09:10 <monochrom> in any case, parametric polymorphism was more popular than any other polymorphism among FP people back then
18:09:29 <parcs`> ion: pdf link?
18:09:43 <monochrom> it may be too old to have a pdf
18:09:43 <ion> ps2pdf
18:09:49 <parcs`> beh
18:10:23 <ski> mun : those aren't mutually exclusive
18:10:35 <ski> (but they're very different things)
18:10:39 <shachaf> Type classes are a scary story that you tell new Haskellers so they can go to sleep at night.
18:11:42 <acowley> Parametric polymorphism is the inspiring story you tell them to get them riled up and raring to go. It's like Braveheart for programmers.
18:12:12 <Mathnerd314> shachaf: type classes are a hack to the type system to make up for the lack of dependent types
18:13:23 <shachaf> Mathnerd314: Dependent types are a trade-off.
18:13:38 <mun> according to http://en.wikipedia.org/wiki/Ad-hoc_polymorphism with parametric polymorphism, polymorphic functions are written without mention of any specific type. but doesn't length Nil = 0; length (Cons x xs) = 1 + length xs mention datatypes? i.e. Nil and Cons.. where data List a = Nil | Cons a (List a)
18:14:10 <Mathnerd314> shachaf: between what and what?
18:14:15 <acowley> mun: it mentions a type constructor
18:14:36 <mun> acowley, so how does that compare to ad-hoc polymorphism?
18:14:45 <shachaf> Mathnerd314: The good parts of dependent types and the bad parts of dependent types, of course. :-)
18:14:49 <shachaf> For example, type inference is nice.
18:15:23 <ski> mun : see "1.3. Kinds of polymorphism" in "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> in addtyion to the paper ion suggested, for explanation of different senses of the word "polymorphism"
18:15:34 <monochrom> @remember shachaf Type classes are a scary story that you tell new Haskellers so they can go to sleep at night.
18:15:35 <lambdabot> Good to know.
18:15:43 <acowley> mun: If you're coming from a C++, Java, or C# background, it's very much like generics there.
18:16:07 <parcs`> how do type classes fake dependent types?
18:16:11 <monochrom> @remember acowley Parametric polymorphism is the inspiring story you tell them to get them riled up and raring to go. It's like Braveheart for programmers.
18:16:12 <lambdabot> Okay.
18:16:15 <ski> mun : no, `Nil' and `Cons' are not (data) types, they are (data) constructors. `List' would be a type
18:16:18 <parcs`> they seem rather orthogonal concepts
18:16:41 <acowley> ski: List by itself is, I think, not generally referred to as a type. List a is a type.
18:16:44 <rostayob> yeah, dependent types have little to do with type classes. in fact you can have both (see Ur/Web)
18:16:52 <rostayob> agda emulates type classes with implicit records.
18:16:53 <ski> Mathnerd314 : type classes were added to handle ad-hoc overloading in a less ad-hoc way
18:16:55 <mun> ski, oh yes, sorry. so how is the mention of constructors better than the mention of types?
18:17:16 <ski> acowley : i'm aware, but i think it's not useful terminology
18:17:20 <rostayob> if type classes were an hack in the absence of dep types, agda wouldnt' need to emulate anything :)
18:17:26 <acowley> mun: the purpose is that you can work with values of *any* type constructed by the List type constructor
18:17:30 <danharaj> wow
18:17:33 <acowley> ski: this seems specifically like a case where it matters :)
18:17:33 <danharaj> I made ghc panic.
18:17:37 <danharaj> Where do I get my cookie.
18:17:39 <hpc> rostayob: and it doesn't!
18:17:47 <hpc> (cue religious war in 3.. 2.. 1..)
18:17:49 <rostayob> hpc: uh?
18:17:51 <ski> acowley : how so ?
18:17:52 <acowley> danharaj: Cambridge, UK
18:18:01 <danharaj> acowley: Too far D:
18:18:46 <Mathnerd314> parcs`: encode datatype as a set of datatypes, use type classes / type families as functions, let GHC infer everything
18:18:53 <monochrom> the purpose of types is to ban more programs (religious war attempt)
18:18:53 <acowley> ski: Because we're considering a function, length, defined over all types constructed by List.
18:18:55 <mun> acowley, but ad-hoc lets you work with any type, right?
18:19:06 <shachaf> acowley: Not this argument again.
18:19:28 <acowley> uhoh, I didn't think I was in an argument. I've made a huge mistake
18:19:32 <shachaf> Just say "kind *" or something.
18:19:57 <acowley> Oh, yes I don't want to argue about that.
18:19:59 <ski> acowley : the terminology i use : `Nothing',`Just',`(:)' are data constructors (and `Just "abc"' isn't). `Bool',`Maybe',`Either' are type constructors, but `Maybe Int' and `Either String' isn't. all type constructor are types. types with kind `*' are *concrete* types
18:20:11 <ben> Is there a term for the kind of type that can be made an instance of a type class?
18:20:23 * elemir hates `RealWorld'
18:20:25 <hpc> ben: no
18:20:34 <monochrom> in "id a = a", you are already pinning part of the type, that is, we now know that the type of "id" must contain "->". you can already say, pathologically, every function definition already mentions types
18:20:38 <acowley> ski: Fair enough, I'm not interested in splitting that hair.
18:20:50 <elemir> Is it unreal to devide it to peaces?
18:21:04 <hpc> more concretely, you are saying the "root" of the type is (->)
18:21:06 <acowley> mun: ad hoc polymorphism lets you work with any type that satisfies a particular constraint (i.e. provides a specific interface)
18:21:10 <ski> mun : data constructors aren't types (anymore than e.g. tuple or record syntax are types), and therefore it doesn't mention types
18:21:10 <hpc> if you imagine the type to be a tree
18:21:20 <monochrom> but that's beside the point. the point is that the type is "t -> t" and you haven't pinned down the "t" part.
18:21:32 <ski> mun : types are removable at compile-time (in Haskell), data constructors aren't
18:21:47 <ski> (this is known as "type erasure")
18:21:58 <Mathnerd314> monochrom: preposterous, you could have id :: forall a. a
18:22:00 <elemir> ski: Remove existentials, please ^__^
18:22:20 <monochrom> similarly, in "length Nil = 0", you have pinned down as much as "[]", sure, but you haven't pinned down the "t" in "[t]"
18:22:21 <ben> It always confuses me how you can erase types at compile time and still manage to catch exceptions of only a specific type
18:22:32 <ben> the whole extensible exception thing is pure evil
18:23:01 <ski> mun : as for "how is the mention of constructors better than the mention of types?", i'm not sure what notion of "better" you have in mind -- depending on what you mean, maybe the answer is "it isn't"
18:23:03 <Saizan> elemir: there's no problem with that
18:23:07 <monochrom> you are mentioning the type parts "->" "[]" but you aren't mentioning the rest of the type
18:23:08 <ski> elemir : doesn't matter
18:23:12 <rostayob> ben: it makes sense if you see type classes are collections of functions parametrised over the instance.
18:23:23 <rostayob> (which is how GHC compiles them)
18:23:28 <elemir> Constructors isn't types because of constructors are functions
18:23:34 <elemir> *aren't
18:23:37 <parcs`> rostayob: it does? exception catching is pure magic
18:23:38 <ski> elemir : you can still erase types in the presense of existentials -- you can't erase *contraints*, though
18:23:43 <rostayob> parcs`: how is it magic?
18:24:05 <parcs`> :t catch
18:24:06 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
18:24:15 <elemir> :t catchError
18:24:16 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
18:24:18 <ski> @remember monochrom the purpose of types is to ban more programs
18:24:18 <lambdabot> Good to know.
18:24:24 <monochrom> extensible exception uses a type class. you are passing around a record of methods. the methods actually catch all exceptions, then re-throw most of them
18:24:56 <rostayob> parcs`: he's talking about the other catch (Control.Exception). I don't see how it's magic
18:25:12 <rostayob> types can be erased, type classes /= types
18:25:13 <elemir> :t error
18:25:14 <lambdabot> forall a. [Char] -> a
18:25:20 <parcs`> rostayob: well, i presume it could fall under the umbrella of IO
18:25:32 <rostayob> parcs`: the IO part is magic. the types aren't
18:25:59 <Saizan> well, throw/catch is magic if you consider compiler support for it as being magic (stack-unwinding etc.. is not implemented in haskell)
18:26:02 <ben> :t Control.Exception.catch
18:26:03 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
18:26:05 <parcs`> what i meant was magic was ghc's ability to choose a handler based on the type of the exception thrown
18:26:15 <rostayob> parcs`: that's not magic at all, it uses Typeable
18:26:21 <monochrom> so, if you write, "catch m (\e :: IOException -> ...)", the generated code does not just catch IOException; it catches all exceptions, sees if it is an IOException: if yes, give it to you; if no, re-throw, don't give it to you
18:26:43 <parcs`> rostayob: ah, TIL :)
18:26:44 <ski> ben : (depending on what you mean) more or less every type can be made an instance of a type class
18:26:46 <monochrom> and it can "see" if it's IOException because of Typeable
18:27:03 <ski> elemir : some constructors are not functions, like `[]',`()',`False',`True',`Nothing',&c. ...
18:27:08 <ben> That's very different than exception handling/catch-clause selection works with "statically typed" exceptions in C++, isn't it
18:27:15 <elemir> :t []
18:27:16 <lambdabot> forall a. [a]
18:27:28 <elemir> Normal function
18:27:30 <rostayob> ben: not really, but in C++/whatever the reified type information is included automatically in every class
18:27:41 <rostayob> while with Haskell it's defined in the language
18:27:50 <elemir> Without any paramters :)
18:27:52 <rostayob> (thankfully, we like parametricity!)
18:28:35 <ski> ben : not really
18:28:49 <parcs`> i have never actually considered why there is a Typeable superclass constraint on Exception -- now it makes sense :P
18:29:04 <ski> elemir : there is no such thing as a function without parameters
18:29:21 <monochrom> call it a "value"
18:29:26 <ben> hm, i guess must have overestimated how magic c++ exceptions can be
18:29:28 <ski> elemir : it is a function iff the type as the general shape `... -> ...'
18:29:38 * ski is ignoring `forall's and `=>' here
18:29:40 <monochrom> "True" and "sin" are both values. "sin" is in addition a function.
18:30:13 <elemir> ski: In lambda calculus everything is function
18:30:14 <monochrom> it is C, not haskell, that promotes "everything is a function"
18:30:54 <ski> elemir : in *pure* lambda-calculus, yes
18:31:09 <ben> ski: I mean that I can make "[]" an instance of a type class but not "[Char]" for example
18:31:19 <elemir> In haskell too
18:31:22 <monochrom> haskell is quite a few steps away from very rudimentary lambda calculus
18:31:39 <ben> Or maybe that I can make Int one and not [Char], but both seem to have the same kind
18:31:44 <ski> elemir : still, in pure polymorphic lambda-calculus you can't really assume that everything is a function, it's just that anything you can actually bind to a variable will be a function
18:31:53 <rostayob> ben: you can make [Char] an instance of something with FlexibleInstances
18:31:55 <ski> (so "everything is a function" is admissible, but not derivable)
18:32:08 <ben> rostayob: yeah, but I'm gonna assume that's cheating
18:32:10 <monochrom> philosophically, if you take an old shoe, replace this part, replace that part... is the end result still the original shoe?
18:32:16 <ben> and that it was prohibited for a reason :v
18:32:27 <ski> ben : it's not cheating
18:32:36 <monochrom> similarly, if you start with lambda calculus, but you add this, change that... after enough changes, is that still lambda calcullus?
18:32:47 <ben> anyway, I was wondering how you'd name the set of types that can be made instances of type classes in the absence of FlexibleInstances, then ;
18:32:50 <ben> ;)
18:32:53 <elemir> ski: You look at "system f" naively
18:33:02 <ski> ben : the reason it is not allowed in the standard is that they wasn't sure how to implement it right at that time. however, there's nothing bad about using `FlexibleInstances' now
18:33:17 <ski> elemir : i'm not sure what you mean ..
18:33:19 <monochrom> you know, javascript can be called lambda calculus, too
18:33:39 <rostayob> ben: you can only instantiate type constructors on their own in standard haskell
18:33:41 <ski> elemir : in Haskell, `[]',`False',`Nothing' are definitely *not* functions
18:33:45 <danharaj> There's not much wrong even with UndecidableInstances.
18:33:53 <rostayob> danharaj: wut?
18:34:01 <elemir> ski: Why?
18:34:03 <rostayob> loops in the typecheker yay
18:34:05 <ben> rostayob: but Int isn't a type constructor, is it
18:34:09 <rostayob> ben: it is
18:34:14 <ben> I thought it's a type
18:34:16 <danharaj> rostayob: Big deal, just tell it to terminate after N steps.
18:34:24 <ben> I thought type constructor meant * -> * or something like that
18:34:25 <ski> ben : yeah, the restriction which `FlexibleInstances' lifts has nothing to do with kind, it has to do with the shape of the instance head
18:34:27 <ben> i think with a -> in it
18:34:39 <rostayob> ben: well right, this is a terminology issue
18:34:47 <ski> elemir : because their types doesn't involve a `->'
18:34:50 <ben> rostayob: It's a terminology question :D
18:34:55 <geekosaur> Int is a type constructor the same way Nothing is a data constructor
18:34:59 <rostayob> ok... then I'm not sure about the answer :D
18:35:00 <Saizan> ben: there's more than one school
18:35:13 <ski> elemir : functions are those values which have type `A -> B', for some types `A' and `B'
18:35:17 <rostayob> geekosaur: no
18:35:19 <rostayob> :k Nothing
18:35:20 <lambdabot>     Not in scope: type constructor or class `Nothing'
18:35:22 <rostayob> :k Int
18:35:23 <lambdabot> *
18:35:25 <ski> elemir : lists are those values which have type `[] A', for some type `A'
18:35:39 <ski> elemir : pairs are those values which have type `(,) A B', for some types `A' and `B'
18:35:44 <ski> elemir : see the pattern ?
18:35:47 <geekosaur> rostayob, read what I wrote.  data constructor != type constructor
18:35:47 <rostayob> geekosaur: oh, sorry... I read type constructor
18:35:54 <rostayob> yes yes, my bad :P
18:35:58 <elemir> ski: No, it's wrong.
18:36:05 <ski> elemir : why would you think so ?
18:37:15 <Saizan> ben: i tend to stick to type for anything with a kind, type constructor for stuff like Int,[],Either,.. but sometimes type constructor is used for those with an -> in their kind, especially since classes that could take such type parameters were first known as "constructor classes"
18:37:27 <rostayob> ben: you are right in a way that if we make sure not to make a distinction between "functions" and "non-functions" we should make a distinction from types with an arrow in them and those without
18:37:28 <elemir> Because function concept in *typed* lambda calculus is more complicated
18:38:11 <ski> ben : i use "type constructor" to mean things like `Int',`Maybe',`Either', but not things like `Maybe Int',`Either Bool' (note that the last one has kind `* -> *', but imo it's the type constructor `Either' applied to the type constructor `Bool' -- it is not itself a type constructor -- compare with how `Node 3' isn't a data constructor (given `data Tree a = Node a [Tree a]'))
18:38:28 <ski> elemir : i don't agree
18:38:30 <ben> Saizan: So basically type contructor for anythin that you could say has a "data ..." line somewhere?
18:38:35 <ben> or newtype, I guess
18:38:40 <Saizan> ben: or newtype, yes
18:38:42 <rostayob> ben: yes
18:39:15 <ben> right, i always thought the constructor term was about the arrow in the kind :(
18:39:28 <ben> this seems more useful
18:39:29 <dmwit> How do you distinguish between things with kind * and other things, then, if not by type vs. type constructor?
18:39:30 <ben> thanks :)
18:39:30 <ski> a data contructor can't be decomposed into any constituent parts
18:39:33 <rostayob> I was a type constructor, then I took an arrow in the kind
18:39:36 <ski> similarly, a type contructor can't be decomposed into any constituent parts
18:39:54 <ski> dmwit : types with kind `*' are *concrete* types
18:39:55 <Saizan> dmwit: i use "concrete type" for :: *
18:40:09 <ben> so if the Show typeclass was designed today, would it still have the showList function or would it use flexibleinstances to let [Char] have the ""s? :)
18:40:22 <ski> @remember rostayob I was a type constructor, then I took an arrow in the kind
18:40:23 <lambdabot> Nice!
18:40:43 <Saizan> ben: still showList, because you'd also need OverlappingInstances to have different [a] and [Char] instances
18:41:13 <ski> (and `OverlappingInstances' is a Bad Thing -- though `IncoherentInstances' is even worse)
18:41:15 <ben> Oh, I thought that'd be part of it. That's why I thought it was evil.
18:41:54 <stepkut> is there a way to abuse OverloadedStrings so that writing, "foo" "bar", can act as concatenation?
18:42:20 * ski calls the type police
18:42:28 <stepkut> it's easy to do, "foo" . "bar". But harder using ' ' instead of '.'
18:42:28 <rostayob> stepkut: I think you can if you explicitly mark the type ("foo" "bar" :: String)
18:42:29 <ski> it's for your own good, son
18:42:56 <stepkut> rostayob: I don't see how that helps
18:43:24 <rostayob> stepkut: can't you create an IsString instance for (String -> String)?
18:43:38 <stepkut> ah
18:43:40 <rostayob> where fromString s = \s' -> s ++ s'
18:43:48 <stepkut> well, that doesn't really help me
18:43:59 <shachaf> instance IsString (String -> String) whre fromString = (++)
18:44:00 <Saizan> if you also want "foo" "bar" "baz" to work you need to start using Text.Printf style tricks
18:44:02 <parcs`> (IsString a, Monoid a) => IsString (a -> a)
18:44:07 <parcs`> it's even haskell98!!
18:44:32 <stepkut> Saizan: yes, I want to string an arbitrary number of segments together
18:44:51 <stepkut> though I am ok with ShowS like functionality where you eventually have to apply the function to something to get the final answer
18:45:28 <Saizan> oleg is your friend
18:45:36 <dmwit> parcs`: ...IsString?
18:45:59 <dmwit> Oh, I misread the context head.
18:46:03 <dmwit> instance head
18:46:06 <rostayob> Saizan: would you be able to use oleg's variadic tricks just with IsString?
18:47:08 <Saizan> rostayob: i think so, but i'd have to try
18:47:27 <rostayob> stepkut: btw, with my solution ("foo" ("bar" :: String)) works, but that's a bit silly.
18:47:31 <stepkut> yeah
18:47:45 <Saizan> http://code.haskell.org/~Saizan/Uncurry.hs <- might be of inspiration
18:48:08 <Saizan> though it might not be as usable as you'd like in the end
18:48:16 <josh__> @pl (\k t -> chr $ a + flip mod 26 (ord k + ord t -2*a))
18:48:17 <lambdabot> ((chr . (a +) . flip mod 26) .) . flip flip (2 * a) . ((-) .) . (. ord) . (+) . ord
18:48:18 <stepkut> it is easy to define, (.) = (<<<), but there is no way to define, ( ) = (>>>)
18:48:23 <stepkut> which is, sometimes, unfortunate
18:48:51 <Saizan> yeah, maybe you want a qq?
18:48:56 <rostayob> stepkut: I'm not sure how you'd parse haskell if space was an operator :P
18:49:08 <stepkut> Saizan: not really
18:49:49 <stepkut> rostayob: same way we always do ?
18:50:11 * stepkut tries not to think about it too hard
18:50:16 <Saizan> i'd be more worried about the additional ambiguities
18:50:29 <josh__> @pl (\tree -> (0 <=) . occurs tree)
18:50:29 <lambdabot> ((0 <=) .) . occurs
18:51:15 <stepkut> I can write:
18:51:17 <stepkut> httpVersion = "HTTP" >>> "/" >>> 1*digit >>> "." >>> 1*digit
18:51:31 <ben> let's have a class IsFunction a b where ($) :: (a -> b) -> a -> b so that instances can overload ' ' by providing a ($)
18:51:36 <stepkut> but that is a lot harder to read than, "HTTP" "/" 1*DIGIT "." 1*DIGIT
18:51:36 <ben> what could go wrong
18:51:44 <ski> josh__ : `(0 <=) .: occurs'
18:51:59 <rostayob> stepkut: "foo" (("bar" :: String -> String) ("baz" :: String)) works as well! ehe.
18:52:05 <ski> josh__ : `infixr9 .:; (.:) = (.) . (.)'
18:52:19 <josh__> <ski> thanks
18:52:27 <rostayob> stepkut: I usually use printf for those things...
18:52:32 <rostayob> but it's unsafe
18:52:33 <ski> @type let (.) = (Prelude..); infixr9 .:; (.:) = (.) . (.) in (.:)
18:52:34 <lambdabot> parse error on input `;'
18:52:38 <rostayob> it is an ugly problem
18:52:51 <stepkut> I guess something printf like could work
18:53:01 <ski> @type let (.) = (Prelude..); infixr 9 .:; (.:) = (.) . (.) in (.:)
18:53:02 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:53:09 <shachaf> stepkut: Why do you want this?
18:53:11 <stepkut> httpVersion = bnf $ "HTTP" "/" 1*digit "." 1*digit
18:53:19 <shachaf> Are you just looking for a convenient way to quote a long string in Haskell?
18:53:21 <ski> josh__ : it should be `infixr 9', not `infixr9'
18:53:29 <rostayob> stepkut: my friend wrote this: https://github.com/scvalex/interpol , but that's a bit overkill maybe.
18:53:35 <stepkut> shachaf: no. Looking for a reliable way to translate EBNF notation into Haskell
18:53:48 <stepkut> shachaf: a parser may, in fact, be the best answer
18:53:49 <Saizan> stepkut: without the $
18:53:58 <ski> @where bnfc
18:53:59 <lambdabot> BNF Converter, <http://www.cse.chalmers.se/research/group/Language-technology/BNFC/>
18:54:02 <rostayob> so you can write like "I have {okVal} apples.", where 'okVal' is a variable.
18:54:22 <ski> stepkut : that may or may not be interesting
18:54:23 <x_man> f : reg1 -> reg2
18:54:29 <parcs`> there's a type-safe quasiquote printf
18:54:41 <josh__> <ski> trying to wrap my head around point-free,  and trying to remove declared varibles
18:54:59 <josh__> <ski> I'll look into the boob operator now
18:55:24 <stepkut> ski: You don't have permission to access /research/group/Language-technology/BNFC/ on this server.
18:55:46 <ion> josh: That notation looks like you’re quoting ski.
18:55:47 <stepkut> oh well, I don't have to solve this problem for a few weeks
18:55:48 <ski> stepkut : hm, bad link, wait
18:57:13 <josh__> new to irc, should I not write that way? How should I direct a message?
18:57:55 <ion> “nick: message” is popular.
18:58:23 <josh__> ion: will do in future thanks
18:58:51 <ski> hm, <http://www.cse.chalmers.se/edu/year/2011/course/TIN321/lectures/bnfc-tutorial.html> works fine .. i'm not sure if they have moved (/ will move / are moving) <http://www.cse.chalmers.se/research/group/Language-technology/BNFC/> somewhere else .. you could see <http://web.archive.org/web/20100205211505/http://www.cse.chalmers.se/research/group/Language-technology/BNFC/> in the meantime
18:58:52 <hpc> josh__: you can tab-complete names
18:58:58 <ski> stepkut ^
18:59:03 <hpc> josh__: jo<tab> completes to "josh__: "
18:59:17 <hpc> or if it's not at the start of a line, "josh__ " -- ready for the next word
18:59:36 <josh__> neat, thanks for being so helpful hpc
18:59:46 <stepkut> ski: looks useful!
18:59:58 <stepkut> ski: I am trying to avoid inventing too much here :) I just want the end result
19:00:26 <ski> (josh__ : btw, i didn't call it "the boob operator" when i invented it -- blame others :)
19:01:12 <stepkut> ski: basically I want to combine BNFC and QuickCheck to do a better job testing my parsers
19:01:16 <ski> stepkut : the BNF converter is a wrapper over happy, which allows you to write code closer to (E)BNF -- there's also backends for other languages than Haskell
19:01:22 <stepkut> aka, grammar driven testing
19:01:34 <hpc> ski: you invented boobs?!?!
19:01:47 <josh__> ski: You invented it?! Wow, glad to meet a haskell celebrity.
19:01:52 <ski> @hackage BNFC
19:01:53 <lambdabot> http://hackage.haskell.org/package/BNFC
19:01:57 <nexion> hey guys, is there a SHA512 hash function that uses a lazy bytestring for input and output? (or even better, works with Text?)
19:02:01 <ski> stepkut : also there ^
19:02:19 <stepkut> ski: so, I want to take the EBNF as input, and then output strings that are valid according to the grammar
19:02:33 <ski> hpc : no, i invented the `(.:)',`(.::)',&c. operators long ago
19:02:54 <stepkut> ski: so.. a little different from what BNFC is doing.. but maybe I can leverage the code somehow
19:02:55 * ski has nothing to do with that name commonly given to it/them
19:03:16 <ski> stepkut : hm, generate random phrases ?
19:03:22 <JoeyA> nexion: Did you look at http://hackage.haskell.org/package/cryptohash ?
19:03:30 <stepkut> ski: yes
19:03:36 <JoeyA> hashlazy
19:03:44 <hpc> ski: ah; i love those operators and invented them independently
19:04:01 <JoeyA> import qualified Crypto.Hash.SHA512 as SHA512 ... SHA512.hashlazy lbs
19:04:10 <hpc> though ive never needed deeper than (.:)
19:04:27 <ski> josh__ : not sure i'm a celebrity .. i just hang around here, obsessing about issues related to programming languages and type systems, sometimes trying to help people as well
19:04:50 <ski> (hpc : i'm not sure but it might have been in 2001 or 2002)
19:04:52 <nexion> JoeyA, yup.. but while implementing, I realized that it outputs a strict bytestring, even though it takes a lazy one
19:05:22 <nexion> I could convert, but wondering if there is a neater way
19:05:26 <stepkut> ski: inspired by this post, http://professor-fish.blogspot.com/2012/03/more-than-you-ever-wanted-to-know-about.html
19:07:29 <ski> stepkut : if you're interested in grammars, then the UUAG attribute grammar system might also be interesting to you
19:08:00 <ski> <http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem>
19:08:46 <stepkut> ski: well... my interest is very specifically in translating EBNF specifications into something I can use to test my parsers/printers
19:09:06 <ski> ok
19:10:04 <JoeyA> nexion: 512 bits isn't a very big string.  Strict makes a lot of sense.
19:10:36 <JoeyA> nexion: If you need to convert it to a lazy bytestring, use L.fromChunks [hashlazy lbs].
19:10:53 <JoeyA> (import qualified Data.ByteString.Lazy as L)
19:11:47 <nexion> JoeyA, makes sense, thanks
19:14:43 <ski> stepkut : interesting post
19:14:52 <stepkut> ski: yeah
19:15:40 <elemir> preflex: seen ksf
19:15:41 <preflex>  ksf was last seen on #haskell 2 days, 9 hours, 45 minutes and 14 seconds ago, saying: well it dosn't make much sense to keep it if you have to copy, as copying and converting should have the same performance modulo statistical noise.
19:15:49 <elemir> preflex: seen ksf_
19:15:49 <preflex>  ksf_ was last seen on #haskell 1 day, 3 hours, 39 minutes and 51 seconds ago, saying: haskell is a formal background.
19:16:02 <elemir> preflex: seen ksf__
19:16:03 <preflex>  ksf__ was last seen on #haskell 4 hours and 20 seconds ago, saying: @quote confus
19:16:12 <elemir> preflex: seen ksf___
19:16:12 <preflex>  Sorry, I haven't seen ksf___
19:16:15 <elemir> :(
19:16:48 <ski> stepkut : in some sense the ideal system would be if you could specify the parser and the printer at the same time, using the same rules
19:17:10 <ski> stepkut : however, there're problems of getting both efficient when doing this, which would need to be solved
19:17:36 <stepkut> ski: yeah, that is what boomerang does
19:17:45 <ski> also there's some semantic problems (you might prefer it to not generate extranous bracketing -- also there's pretty-printing to worry about)
19:18:19 <stepkut> ski: http://happstack.com/docs/crashcourse/WebRoutes.html#web-routes-boomerang
19:18:30 <ski> also, it would probably mostly make sense in case the grammar code that you write is close enough to the declarative specification
19:19:06 <scooty-puff> any advice for writing typeable instances for types with higher-kinded type parameters?
19:19:24 <stepkut> ski: in my use case, I want to write some highly optimized parsers by hand, and then use the EBNF specs + quickcheck-like testing to provide that the parsers are correct
19:19:33 <ski> (otherwise it'd be better if you could test the parser with a separetedly written printer/generator which hopefully is closer to the declarative specification)
19:19:56 <eyebloom> What is the best way to find infinite loops in ghci?
19:20:07 <ski> scooty-puff : `Typable1',`Typable2',&c. .. i think in recent GHC these are all replaced by a polymorphic `Typable' class
19:20:49 <ski> eyebloom : hm, in case you don't have threads enabled, i think one can get it to generate a "blackhole" exception, which you might be able to breakpoint
19:20:53 * ski hasn't tried this
19:21:01 <scooty-puff> k - how recent? later than 7.4.1 i would guess
19:21:15 <ski> stepkut : *nod*
19:21:22 <ski> scooty-puff : i don't recall
19:21:28 <ski> pretty recent, in any case
19:21:41 <ski> (it needs "polykinds")
19:23:24 <ski> scooty-puff : previously `Typable' was for types with kind `*', `Typable1' for ones with kind `* -> *', `Typable2' for ones with kind `* -> * -> *',&c.
19:24:05 <ski> scooty-puff : for ones with a kind like `(* -> *) -> *' e.g., you'd need to define a new class with the previous system -- with the new, i think this is also handled by the sole polymorphic `Typable' class
19:24:24 <scooty-puff> k
19:27:29 <nexion> if I wanted to create a single-element list, is there a function I can call? similar to just doing [a], but something like toList a
19:27:38 <ben> (:[])
19:27:58 <otters> is there a name for that, because it kind of looks like a duck
19:28:03 <nexion> lol
19:28:16 <dmwit> return or pure
19:28:21 <dmwit> > pure 3 :: [Integer]
19:28:22 <lambdabot>   [3]
19:28:34 <dmwit> lots of ways to spell (:[])
19:28:39 <dmwit> \x -> [x] is good, too
19:28:57 <dmwit> Or just apply the damn thing to a value and write [foo]
19:29:19 <nexion> the reason I'm asking is so I could use $ instead of putting the brackets around the whole thing
19:29:20 <dmwit> (I know you already knew that one, just wanted to include it for completeness.)
19:30:35 <nexion> I'll stick with [foo]
19:31:17 * ski doesn't really see why people are so eager to use `$' instead of brackets
19:31:30 * Authoritarianism neither.
19:31:39 <ski> in case the expression is more than one line, i can understand it (but i don't always do it then, either)
19:31:45 <nexion> I didn't either at first
19:31:54 <nexion> but then started using it everywhere I could
19:32:33 <ski> but in most cases where i see it here, being used for a single-line expression, i would prefer using brackets (or possibly rewriting in some other way)
19:32:44 <stepkut> ftfy: <ski> in case the expression is more than one line, i can understand it $ but i don't always do it then, either
19:33:13 <nexion> preference, I suppose.. I find it easier to read and faster to write
19:34:01 <sipa> stepkut: you must like lisp!
19:34:05 <sipa> eh, ski
19:35:12 * ski passes stepkut through the type-checker at <http://lisperati.com/landoflisp/panel60.html>
19:35:53 <stepkut> :)
19:36:44 <ski> (that's a fun comic, btw)
19:37:10 <ski> (btw, what does "ftfy" stand for ?)
19:37:28 <Authoritarianism> ski: Fixed that for you.
19:37:38 <ski> sipa : well, i like Scheme, at least :)
19:37:42 <ski> Authoritarianism : ty
19:40:24 * Mathnerd314 wonders why @dict doesn't support urban dictionary
19:41:54 <stepkut> ski: fixed that for you (or something to that effect)
19:42:18 <stepkut> oops, sorry about the dup answer :)
19:42:40 <Authoritarianism> ski: I am reading that comic.
19:42:47 <Authoritarianism> ski: lmao @ lambdas used like swastikas.
19:44:59 * Mathnerd314 fills out urban dictionary API interest form
19:46:14 <Mathnerd314> "About how many calls per day will the application make?"
19:46:44 <Mathnerd314> no idea of how to measure this...
19:53:03 <danharaj> How much code is broken by the Num/Eq split in 7.4?
19:53:15 <danharaj> I'm wondering if it'll get incorporated into the next iteration of the standard.
19:53:46 <adrake> does anybody know of a haskell package that implements a non-naive discrete log solver? I didn't find anything obvious from a search on hackage
19:55:51 <geekosaur> it's expected to be in the next Haskell standard, yes.  in fact I think it's alredy been accepted for the standard; ghc 7.4 is just being a bit precocious
19:57:54 <ski> Authoritarianism : yeah, it's hilarious :D
20:13:31 <jfischoff> If I have two categories and functors back and forth, is there a convenient way to seamlessly compose them? Is there a way to use type classes to have the correct functor selected automatically?
20:13:56 <adu> jfischoff: either arrows or monad transformers
20:14:58 <jfischoff> adu: can you point me to an example?
20:16:09 <adu> jfischoff: well, first of all, do you know what a monad is?
20:16:18 <jfischoff> adu: yes
20:16:33 <adu> ok, http://www.haskell.org/haskellwiki/Monad_Transformers_Explained
20:18:05 <adu> or: http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial
20:18:38 <jfischoff> adu: thanks, thinking...
20:19:31 <adu> honestly, I've been using Haskell for about 15 years, and I've never used a monad transformer
20:19:41 <adu> so I might be the wrong person to answer that question
20:19:46 <adu> also, I like typing
20:20:32 <jfischoff> adu: ha, okay. I think the arrows approach is closer to what I am looking for
20:20:42 <adu> ok :)
20:20:46 <jfischoff> :)
20:23:47 <edwardk> @tell koninkje_away you can actually skip UndecidableInstances in the special case of building Show instances, by making a show instance for a type that is a newtype wrapper around the signature of showsPrec, and unwrapping layers of the free monad into that
20:23:47 <lambdabot> Consider it noted.
20:24:35 <edwardk> adu: part of that is because you were using haskell before they came around, so your habits were set ;)
20:24:43 <Saizan> jfischoff: you could have a generalized Functor class class (Category c, Category d) => Functor c d f where fmap :: c a b -> d (f a) (f b); but then c and d wouldn't be enough to determine what f is, so maybe you want a more specialized class with a fundep c d -> f
20:26:03 <ski> edwardk : how would the wrapper look like ? `newtype ShowsPrec a = SP (Prec -> a -> ShowS)' ?
20:26:11 <edwardk> I typically like to use a class (Category c, Category d) => Functor f c d -- with either f -> c d like one really should have or the slightly more pragmatic f c -> d, f d -> c which permits (,) to be an Endofunctor in the Kleisli category, etc.
20:26:31 <edwardk> ski: newtype ShowsPrec = ShowsPrec (Int -> String -> String)
20:26:58 <ski> Saizan : it would seem bad to me to only allow one functor between each pair of categories
20:27:10 <edwardk> instance Show ShowsPrec where showsPrec d (ShowsPrec f) d = d f
20:27:17 <ski> edwardk : also, what was the original question ? :)
20:27:45 <edwardk> ski: in the announcement for unification-fd 0.7 wren complained that he needed UndecidableInstances "-- For Show instances due to two-level types"
20:27:53 <Saizan> ski: yeah, it'd have to be a subclass with some more specialized intent
20:28:04 <ski> @hackage unification-fd
20:28:05 <lambdabot> http://hackage.haskell.org/package/unification-fd
20:28:51 <edwardk> ski: but you can avoid that because the two-level type involved is a free monad, and You can make an instance (Show (f ShowsPrec), Functor f) => Show (Free f) which doesn't require UndecidableInstances
20:29:29 * ski tries to find the announcement, or the relevant code/module
20:30:00 <edwardk> anyways, I'm just glad that I can drop my fork of unification-fd now =P
20:30:20 <edwardk> Since I'd made a similar change to the MutTerm type last year and hadn't gotten him to accept it =P
20:31:41 <ski> which module is the relevant one ?
20:32:56 <edwardk> ski: the one that defines UTerm: http://hackage.haskell.org/packages/archive/unification-fd/0.7.0/doc/html/Control-Unification.html
20:33:05 <edwardk> I don't recall where it was imported from
20:33:47 <ski> so `instance (Show v, Show (t (UTerm t v))) => Show (UTerm t v) where ...' ?
20:34:08 <edwardk> http://hackage.haskell.org/packages/archive/unification-fd/0.7.0/doc/html/src/Control-Unification-Types.html
20:34:09 <edwardk> yeah
20:34:54 <edwardk> I was able to use the ShowsPrec hack above in another package to avoid the undecidable instance for Show. It doesn't work for many other recursive instances though
20:35:01 <edwardk> e.g. to get Eq or Read you'd still need it
20:35:56 * ski wonders how complicated "higher-rank instances" like `instance (Show v, (forall a. Show a => Show (t a))) => Show (UTerm t v) where ...' would be to check
20:36:01 <Saizan> heh, rather than exploit open recursion you extract the algebra out of f's Show instance
20:36:57 <edwardk> saizan: yep
20:37:13 <ski> edwardk : hm, so you `fmap (flip showsPrec)' ?
20:37:33 <edwardk> ski: more or less I think there is a wrapping of it in a constructor as well but yes
20:37:35 <ski> well, with the constructor as well
20:37:42 <ski> yea, ok
20:38:13 <ski> it's basically a variant of the existential->closure conversion
20:38:55 <edwardk> re: checking higher rank instances. they aren't _that_ bad actually. I was able to do it in a toy type checker
20:40:20 <Saizan> it's common to have to solve stuff like Show (t a) in the context of Show a
20:41:42 <Saizan> foo :: Show a => t a -> String; foo x = show x -- typechecking this is the same problem
20:42:38 <tgeeky__> any lattice geeks / experts in here? Or anyone that is familar with the LLL algorithim?
20:45:10 <Saizan> ..except that t is not universalli quantified
20:47:17 <danharaj> does GHC have or-patterns?
20:47:31 <Saizan> nope
20:47:34 <danharaj> awww
20:47:39 <danharaj> Why not :(
20:48:43 <ski> edwardk : it seems to me that in mady such cases that is what we *really* want to do ..
20:48:50 <geekosaur> .oO { they're orful? }
20:48:59 <ski> danharaj : complain to GHC writers :)
20:49:33 * ski thinks disjunctive/or- patterns are nice
20:49:48 <edwardk> Also, if you don't export the ShowsPrec type from the module, then the only way to get the instance for f ShowsPrec is to have one for forall a. f a
20:49:59 <edwardk> (modulo some pretty hairy oleggery)
20:50:22 <ski> Saizan : for a fixed `t' ?
20:50:38 <Saizan> ski: yeah
20:51:09 <adu> edwardk: perhaps
20:51:22 <ski> Saizan : so using `instance Show a => Show (T a)' then ? or inferring the constraint `(forall a. Show a => Show (t a))' for `foo' ?
20:51:49 <Saizan> ski: the former
20:51:59 <ski> ok
20:52:14 <adu> edwardk: but on the other hand, my habits say that it isn't a bad idea to use IO for everything ;)
20:52:17 <Saizan> otherwise you can't allow that type signature for foo
20:52:59 <ski> Saizan : yeah, but i was thinking maybe `t' was bound in an outer scope, which didn't have a signature
20:53:42 <ski> (and therefore the type-checking of `foo' would also infer a constraint on `t' to put on that larger scope)
20:54:00 <Saizan> so my point was just that a compiler for h98 has to solve constraints like (forall a. Show a => Show (t a)) even if they can't be expressed in the type language
20:54:51 <ski> Saizan : more or less, yes -- but would it need to infer such constraints for this extension to be sensible ?
20:55:17 * ski suspects that similar to other higher-rank stuff, one would have to rely on giving explicit signatures/instances
20:55:58 <ski> (i.e. it could probably not infer the right instance constraints with instance deriving)
20:56:36 <Saizan> yeah, you'd probably have to give it hints for deriving like we do now
20:58:19 <Saizan> it'd be interesting to see how sensibly clever it might be
20:58:48 <Saizan> s/might/could/
20:59:33 <Saizan> i.e. how far can you go with a rule that tries to generalize illegal constraints
21:01:58 <ski> hm, what do you have in mind ?
21:05:13 <tgeeky__> edwardk: ack e-mail
21:05:17 <Saizan> well, in a naive deriving Show for Free f a, you'd deduce that you need Show (f (Free f a)) if you look at the code
21:05:23 <edwardk> tgeeky__: thanks =)
21:05:40 <tgeeky__> edwardk: did you do lattice stuff? LLL?
21:06:00 <Saizan> and then say "Show (f (Free f a)) would make it Undecidable, is there something stronger that doesn't?"
21:06:02 <edwardk> Lenstra-Lenstra-whosit?
21:06:19 <tgeeky__> edwardk: some people have a pre-print that seems to (maybe vastly) improve performance of LLL if you restrict your domain to Pisot numbers
21:06:24 <edwardk> I know the algorithm exists, I just never needed it
21:06:33 <ski> Saizan : yeah -- i think it's comparable to when you need to write an explicit rank-2 (or higher) type signature
21:07:03 <tgeeky__> edwardk: can you scan and judge: http://arxiv.org/pdf/1202.5785v1
21:07:06 <edwardk> tgeeky__: hrmm
21:08:00 <edwardk> tgeeky: i'll probably have to file it away. I haven't done any lattice work that required me to use LLL in the first place ;)
21:08:38 <tgeeky__> edwardk: just off their claims and the info about big-Oh
21:08:59 <tgeeky__> LLL is: O( d^5  n  log^3 B)
21:09:09 <Saizan> ski: yeah, i guess there's no strong reason to pick forall a. Show a => Show (f a) between all alternatives
21:10:02 <tgeeky__> edwardk: nevermind. I'm comparing things that aren't comparable.
21:10:16 <edwardk> O(d^5 n log^3 B) down to log(mn)^O(1). Sadly I don't have any intuition for what m n d and B are ;)
21:10:37 <tgeeky__> edwardk: m and n are integers
21:10:44 <edwardk> that much I gathered ;)
21:10:47 <tgeeky__> hehe :)
21:10:58 <edwardk> What I mean is how they related to one another
21:11:19 <tgeeky__> edwardk: I'll experiment with it tomorrow. Someone has written LLL over the reationals already
21:11:39 <edwardk> lemme know how it goes
21:11:43 <tgeeky__> edwardk: sure thing
21:11:44 <tgeeky__> http://hackage.haskell.org/packages/archive/Lattices/0.0.1/doc/html/Math-Lattices-LLL.html
21:13:04 <edwardk> Now that I'm looking at it more, I remember one of my professors being obsessed with this thing. (LLL, not the Pisot stuff)
21:14:01 <tgeeky__> edwardk: yeah. Pisot numbers, however they are defined, are useful because when you exponentiate them, you get close to an integer, exponentially fast
21:14:46 <Saizan> btw of restrictions, is there a good reason to ban forall's in the bodies of type families?
21:16:52 <Saizan> i guess solving stuff like (..) ~ (forall a. ..) is not quite easy
21:16:56 <edwardk> More Pisot + LLL stuff: http://www.ams.org/journals/mcom/2002-71-238/S0025-5718-01-01336-9/S0025-5718-01-01336-9.pdf
21:17:16 <edwardk> saizan: SPJ said it made it hard to figure out when to expand the family
21:17:34 <edwardk> saizan: I asked him at one point, that was the response I got ;)
21:18:23 <MelindaACN> Hello
21:19:14 <dolio> edwardk: By the way, Paul wants some GADTs. We should bang out some outside-in.
21:19:24 <edwardk> dolio: yay!
21:19:27 <edwardk> I'm in
21:19:28 <dmh> you guys best bang outside
21:19:34 <Saizan> edwardk: ah, yeah, it's the usual problem of not knowing if the context wants a polymorphic value or its instantiation
21:20:08 <edwardk> dolio: it actually shouldn't be THAT hard. there are only ~3 places in the code that are really HMF specific
21:20:24 <dolio> I don't think I believe that.
21:20:35 <dolio> It's probably easy to rip out the HMF.
21:20:54 <edwardk> Well, just based on the little OutsideIn(X) hack I did. The diff between that and the HMF version wasn't that severe
21:20:57 <tgeeky__> edwardk: thanks for the ref!
21:21:03 <dolio> Oh.
21:21:32 <dolio> I'm not really serious, anyhow. I think we can get by with some phantom types.
21:21:47 <dolio> Just won't be statically checked.
21:22:38 <Saizan> you should desugar them to typeclasses, oleg-style
21:22:49 <dolio> We don't have those, either.
21:23:03 <ski> edwardk,Saizan : i suspect higher-order unification may be lurking near
21:23:08 <dolio> I mean, we could just write them using the Church encoding.
21:23:17 <edwardk> dolio: damn
21:23:19 <dolio> Which is what Oleg is doing.
21:23:24 <Saizan> yep
21:23:40 <edwardk> dolio: I really think we could switch over in a week and a half or so
21:24:08 <ski> (church encodings of GADTs ?)
21:24:14 <edwardk> I would so love to be able to get rid of all of that 'some a.' nonsense in the IO module
21:32:53 <Saizan> ski: (you use something close to the dependent eliminator, except the motive only takes the indices and not the value itself)
21:33:57 <Saizan> e.g. data Vec a n where Nil :: Vec a Z; Cons :: a -> Vec a n -> Vec a (S n) ~~ \ a n -> forall (r :: * -> *). r Z -> (forall m. a -> r m -> r (S m)) -> r n
21:34:30 <Saizan> you need ~ though to write e.g. tail
21:35:06 <Saizan> or am i missing something?
21:41:03 <ski> Saizan : mhm
21:41:26 * ski isn't really sure what "the motive" refers to here
21:49:25 <Saizan> ski: r in this case
21:53:27 <Saizan> hah, ghc won't use even undefined at the type Z ~ S m => Vec a m
21:57:03 <Saizan> http://hpaste.org/65601 <- e.g.
22:00:58 <dolio> I suppose you need disjointness of type constructors.
22:02:56 <dented42> @pl titles a = catMaybe (map titles a)
22:02:56 <lambdabot> titles = fix ((catMaybe .) . map)
22:03:36 <dented42> @pl titles a = cm $ map t a
22:03:36 <lambdabot> titles = cm . map t
22:04:20 <ski> hm, if you have `data Foo :: * -> * where A :: Foo Int', i suppose `bar :: Foo Bool -> a; bar x = case x of { }' doesn't work ..
22:05:14 <ski> (where `bar ()' would work in Agda2)
22:05:33 <Saizan> btw, i'd go for newtype Vec a n = Vec { unV :: forall r. r Z -> (forall m. a -> Vec a m -> r m -> r (S m)) -> r n } actually, which is more like the dep. elim.
22:06:39 <ski> yeah, primitive recursion instead of structural recursion
22:09:43 <mzero> dented42:
22:09:47 <mzero> :t mapMaybe
22:09:48 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
22:09:58 <mzero> perhaps this is what you were looking for
22:10:05 <dented42> yes!
22:10:07 <dented42> thanks :D
22:21:37 <dolio> I suspect you can't write tail in something like system F or CoC.
22:22:19 <dolio> You can write something equivalent. Like tail :: Vec A (suc n) -> F n (Vec A n).
22:24:26 <dolio> But getting it out of the wrapper can't be done without ways to distinguish constructors.
22:32:07 <ski> @type (=<<) . (maybeToList .)
22:32:08 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
22:33:30 <mzero> a rather inefficient, and less clear way, no?
22:34:05 <ski> possibly
22:44:19 <miller> I have a chunk of monadic code living in the IO monad that takes in a callback. What I want the callback to be is a chunk of monadic code that saves the data passed to the callback using persistent, but that code lives in a I'm-not-quite-sure-but-it's-definitely-not-IO monad. Therefore, I can't simply have code that looks like `do { ...; callback data; ... }` callback is of a different monadic type, but
22:44:21 <miller> I don't know how to achieve the same effect as doing that.
22:45:15 <ski> if the callback type is in `MonadIO', you can use `liftIO (callback data)'
22:47:24 <miller> doesn't seem to work
22:47:32 * miller pieces together a small snippet of code to post
22:56:15 <hpaste> miller pasted “example” at http://hpaste.org/65602
22:56:41 <miller> ^that is what I'd like to do (but obviously doesn't work as it is now)
23:03:06 <ski> miller> :t callback
23:03:26 <ski> miller> :t runSqlConn
23:04:30 <Veinor> miller: i think you can just liftIO the getline
23:04:43 <ski> you could try changing the type of `readIntsForever' to `MonadIO m => (Int -> m ()) -> m ()', replacing `getLine' with `liftIO getLine'
23:06:29 * ski doesn't really think `$' is warranted in `callback $ read value' and `insert $ SavedData value' ..
23:06:49 <Veinor> ski: would you do callback (read value)?
23:07:03 <ski> yes
23:07:25 * miller studies ski's comments
23:07:50 <ski> (or `callback . read =<< getLine')
23:08:57 <ski> miller : if it wasn't evident, the first two comments to you were questions
23:09:02 <Veinor> you mean callback . read =<< liftIO getLine
23:09:09 <miller> ski: Oh!
23:09:14 <ski> Veinor : er, right
23:09:30 <Veinor> also, you'd need to change your type of readIntsForever to something like readIntsForever :: (MonadIO m) => (Int -> m a) -> m ()
23:09:33 <miller> ski: callback :: PersistStore b m => Int -> b m (Key b (SavedDataGeneric backend))
23:09:34 * ski hadn't connected the two fixes in mind
23:09:58 <miller> ski: runSqlConn :: (Control.Monad.Trans.Control.MonadBaseControl IO m, Control.Monad.IO.Class.MonadIO m) => SqlPersist m a -> Connection -> m a
23:09:59 <ski> Veinor : as already mentioned :)
23:10:06 <Veinor> ah, right
23:11:14 <ski> miller : changing the type of `readIntsForever' seems the simplest fix here -- whether it'll also work if/when you add more stuff to the code, we don't know
23:12:08 <ski> miller : hm, `runSqlConn' appears to want two arguments, but you only seem to pass it one in the code ?
23:12:14 <miller> ski: The type fix to readIntsForever does make it typecheck. \o/
23:12:33 <ski> miller> :t withSqliteConn
23:12:35 <miller> the connection argument is passed to it by the withSqliteConn
23:12:41 <Veinor> ski: withSqliteConn supplies the connection
23:12:45 * ski was suspecting that
23:13:40 <miller> ski: withSqliteConn :: Control.Monad.Trans.Resource.ResourceIO m => Data.Text.Internal.Text -> (Connection -> m a) -> m a
23:14:00 <ski> so, `readIntsForever callback' has type `SqlPersist m ()', for some `m'
23:14:30 <Veinor> specifically, for any m in the MonadIO typeclass
23:14:31 <ski> miller : is there an instance for `PersistStore SqlPersist m' ?
23:14:34 <Veinor> :i MonadIO
23:14:50 <ski> (i would assume there is, if that indeed type-checks)
23:15:10 <ski> @hoogle MonadIO
23:15:10 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
23:15:11 <lambdabot> package monadIO
23:15:26 <Veinor> MonadIO represents the class of types that you can 'do IO in'
23:15:42 <Veinor> (specifically, that you can do arbitrary IO in)
23:17:15 <miller> ski: The hackage page lists --   Instances: ResourceIO m => PersistStore SqlPersist m
23:17:22 <miller> so it does appear so
23:17:41 <Veinor> oh that reminds me of my other project
23:17:54 <Veinor> an online hoogle that indexes more than just the platform
23:18:08 <ski> miller : *nod*
23:18:48 <ski> miller : you saw the `callback . read =<< liftIO getLine' suggestion ?
23:18:58 <Veinor> i wouldn't use that until you really understand monads
23:19:07 <ski> if you think naming the intermediate result is clearer to you, though, go for that
23:19:12 <miller> ski: yes, is there a reason other than style to do so?
23:19:28 <Veinor> not afaik, i think it compiles to the same code
23:19:36 <ski> miller : no -- it's just style and what one thinks looks nicest
23:20:34 <ski> @type \callback -> callback . read =<< liftIO getLine
23:20:35 <lambdabot> forall a (m :: * -> *) b. (Read a, MonadIO m) => (a -> m b) -> m b
23:20:37 <ski> @type \callback -> callback =<< liftIO . readIO =<< liftIO getLine
23:20:38 <lambdabot> forall a (m :: * -> *) b. (MonadIO m, Read a) => (a -> m b) -> m b
23:21:12 <Veinor> :t readIO
23:21:13 <lambdabot> forall a. (Read a) => String -> IO a
23:21:13 <ski> miller : in case the `read' there can fail, it might be nicer to use `readIO' (to get the parse exception at this point, instead of sometime later)
23:21:31 <Veinor> @src readIO
23:21:32 <lambdabot> Source not found. You speak an infinite deal of nothing
23:21:42 <ski> @index readIO
23:21:43 <lambdabot> System.IO, Prelude
23:21:50 <Veinor> oh does readIO strictly read?
23:22:40 <ski> `readIO' is at <http://darcs.haskell.org/packages/base/System/IO.hs>
23:22:45 <ski> Veinor : yes
23:39:27 <miller> ski, Veinor: I have applied the fix to my original code, and everything works. Thanks for the help! :)
23:39:40 <ski> great :)
23:39:42 <ski> yw
23:49:50 <Snarbafulators> I want to get fucked in the ass by niggers
23:49:54 <Snarbafulators> a whole pack of them!
23:50:01 <Snarbafulators> until my stretched and abused asshole bleeds
23:50:10 <Snarbafulators> and then that the last one pulls out his shit-covered cock
23:50:16 <Snarbafulators> and shoves it down my throat
23:50:29 <Snarbafulators> then he can cum all of his afrosemen into my eyes
23:50:31 <Snarbafulators> ohyy yeahh
23:51:57 --- mode: ChanServ set +o Saizan
23:52:04 --- mode: Saizan set +b *!*CornFeces@*.130.154.254.dsl.dyn.telnor.net
23:52:05 --- kick: Snarbafulators was kicked by Saizan (Snarbafulators)
23:52:28 --- mode: Saizan set -o Saizan
23:52:56 <c_wraith> thanks
23:54:55 <Saizan> sadly recurring
23:55:36 <c_wraith> trolls think they're clever
23:55:53 <Saizan> but banning the whole *.dsl.dyn.telnor.net is probably overkill
