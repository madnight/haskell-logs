01:04:31 <ksf> is fromEnum False == 0 && fromEnum True == 1 specced?
01:05:26 <shachaf> ksf: The Report says data Bool = False | True deriving Enum
01:06:11 <shachaf> And it says that "The nullary constructors are assumed to be numbered left-to-right with the indices 0 through n-1"
01:06:25 <ksf> that's the important bit.
01:07:03 <ksf> wouldn't want to write a boolean expression or an ifthenelse to figure out whether no more than one bool is true.
01:09:29 <Franciman> hi all
01:10:36 <Franciman> hey gents, what do you think of this approach to trim spaces in a string :
01:10:39 <hpaste> Franciman pasted “Trimming” at http://hpaste.org/65144
01:11:14 <Franciman> is it too slow ? is there any better and more elegant way to do that?
01:15:50 <zhulikas> let trim = concat . words
01:15:59 <zhulikas> what about this one?
01:16:27 <Franciman> excellent
01:16:54 <zhulikas> there might be even simplier solutions I am not aware of :)
01:17:31 <Franciman> well I guess it's one of the fastest
01:17:46 <Franciman> because it doesn't iterate the string more than 2 times
01:17:49 <zhulikas> not necessarily
01:17:53 <zhulikas> well, yeah
01:18:02 <zhulikas> your approach with reverse reverse should be quite slow
01:18:14 <zhulikas> but I think it can be done even faster with folding
01:18:14 <Franciman> yes
01:19:21 <Franciman> the tricky part is trimming ending spaces
01:19:55 <Franciman> because you can't know just by iterating from start to end whether they're just internal spaces or endig spaces
01:19:58 <Franciman> *ending
01:20:27 <zhulikas> I don't see how that matters
01:20:36 <zhulikas> if you fold - you go over whole string
01:21:57 <Franciman> what you mean=?
01:22:33 <zhulikas> I am trying to write a fold based solution right now :D
01:23:05 <Franciman> oh ok, just let me know when you're done :)
01:23:18 <zhulikas> here
01:23:34 <zhulikas> let trim = foldr (\a acc -> if a == ' ' then acc else a : acc) []
01:23:39 <Franciman> lol
01:23:44 <zhulikas> this should be even faster than concat . words
01:23:52 <zhulikas> because concat . words are two operations
01:23:54 <zhulikas> and this is just one
01:24:02 <shachaf> zhulikas: dropWhile isSpace?
01:24:03 <zhulikas> and executes in O(n)
01:24:33 <zhulikas> @hoogle isSpace
01:24:33 <lambdabot> Data.Char isSpace :: Char -> Bool
01:24:44 <Franciman> zhulikans, but this also removes internal spaces
01:24:48 <shachaf> dropWhile (==' '), if you prefer.
01:24:54 <zhulikas> shachaf, it drops from the beginning :)
01:24:56 <Franciman> Hello World becomes HelloWorld
01:25:00 <Spockz> trim left is easy :), trim right is trickier :)
01:25:05 <Franciman> ^
01:25:06 <zhulikas> so it doesn't work
01:25:16 <zhulikas> aaa
01:25:19 <zhulikas> you want them to stay
01:25:20 <zhulikas> haha :D
01:25:24 <shachaf> Wait, I misread your function.
01:25:35 <Spockz> oh Franciman: sorry you said that already :)
01:25:37 * shachaf has no idea what whoever's doing anything is trying to do.
01:25:37 <zhulikas> sorry, I thought you want to get rid of ALL white spaces
01:25:50 <Franciman> ahah np
01:26:10 <Spockz> Franciman: there is a trim left and right in the MissingH package I believe
01:26:19 * Franciman wonders why he has laughed
01:26:44 <Spockz> Franciman: http://hackage.haskell.org/packages/archive/MissingH/1.1.1.0/doc/html/Data-String-Utils.html#g:1
01:26:57 <Franciman> Spockz, I'm more interested in implementing it, it's just an exercise, no real need
01:27:40 <Spockz> Franciman: sure, ok. But you can use it to check your solution
01:27:59 <Spockz> Franciman: you can do trim right also in O(N)
01:28:05 <Franciman> how?
01:28:10 <Franciman> btw, yeah thanks :)
01:28:23 <zhulikas> let trim str = concat $ intersperse " " $ words str
01:28:24 <zhulikas> :D
01:28:41 <Spockz> Franciman: the most obvious answer that still is in O(n) is trim . reverse ofcourse
01:28:43 <zhulikas> though this is quite slow
01:28:57 <Franciman> of course
01:29:08 <Franciman> that's sort of what I did before
01:29:20 <Spockz> Franciman: but you could also try using an accumulating parameter
01:29:39 <derpladee> hey guys, what should i look at if i want to load web pages?
01:29:48 <Spockz> derpladee: curl?
01:30:06 <zhulikas> Spockz, but trim . reverse is only half of the operation, isn't it?
01:30:14 <zhulikas> I mean... you also need to trim from the beginning
01:30:19 <shergill> derpladee: don't listen to Spockz, get firefox :P
01:30:34 <zhulikas> and that counts as two in total and also copying the data twice
01:30:54 <Franciman> and what about combining foldr1 and foldl1 ?
01:31:02 <Franciman> one trims right, the other trims left
01:31:04 <Spockz> zhulikas: yes, but that's why it is slow :)
01:31:33 <zhulikas> Franciman, how?
01:31:45 <zhulikas> ah, ok
01:32:15 <zhulikas> result of one operation is an input to other
01:32:21 <zhulikas> so it trims from the beginning, then from the back
01:32:25 <zhulikas> sounds good to me
01:32:46 <Franciman> yes
01:32:56 <Franciman> @hoogle foldr
01:32:56 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
01:32:56 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
01:32:57 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
01:33:28 <Franciman> yeah it's ok
01:33:39 <Franciman> how about performances and space?
01:34:19 <Spockz> Franciman: and how would you know when to stop killing spaces in your fold?
01:34:37 <Franciman> when you first encounter a non-space
01:34:42 <Spockz> yes
01:34:43 <Spockz> and then?
01:34:55 <Franciman> and then I pass the resulting array to the other fold
01:35:12 <Spockz> Franciman: you need to somehow remember that you have seen that other character
01:35:36 <Franciman> wait, let me try
01:36:54 <Sue> hi, i'm new to haskell. i'm having trouble with the net monad bit from the ircbot tutorial
01:37:22 <shachaf> Sue: That tutorial might not be the best introduction if you're still very new to the language.
01:37:35 <Franciman> Spockz, you're right
01:37:36 <Sue> yeah, i figure
01:37:45 <Franciman> maybe we could use laziness
01:37:57 <Franciman> like
01:38:02 <shachaf> It's also very old, though I don't know if it says wrong things or not.
01:38:10 <shachaf> Anyway, you should ask your question.
01:38:17 <Sue> that explains why it isn't working then
01:38:17 <Franciman> takeWhile (/=' ') foldr killSpace []
01:38:39 <Franciman> *takeWhile (/=' ') $  foldr killSpace []
01:38:54 <Sue> couldn't match expected type
01:38:55 <shachaf> Franciman: What are you trying to do?
01:39:24 <Franciman> shachaf, implement a trim function, to trim left spaces and right spaces
01:39:31 <Franciman> but not internal spaces
01:40:24 <Sue> maybe i should finish learn you a haskell first
01:40:43 <Sue> i think i got overexcited
01:41:01 <shachaf> > join (.) (dropWhile isSpace . reverse) "   blah blah   "
01:41:03 <lambdabot>   "blah blah"
01:41:15 <shachaf> Sue: If you have a specific question you can always ask it here.
01:41:29 <Sue> cool, i've been meaning to learn haskell for a while
01:41:52 <Sue> after i saw xmonad
01:42:05 <shachaf> (I meant about the Net thing, but that works in general too, I guess.)
01:42:17 <shachaf> The FAQ is good, and also remarkably difficult to find for some reason:
01:42:19 <shachaf> @where faq
01:42:19 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
01:42:27 <Sue> thanks
01:42:47 <shachaf> Franciman: (That was for you, by the way.)
01:43:02 <Franciman> shachaf, the FAQ?
01:43:20 <shachaf> Franciman: No, the "blah blah" thing.
01:43:23 <Franciman> ah yes
01:43:28 <Franciman> I was trying to understand it lol
01:43:39 <shachaf> I guess you could hope for better strictness behavior...
01:43:39 <Franciman> that's why I haven't posted back anything
01:44:17 <shachaf> Franciman: Lists aren't really designed for doing this sort of thing, by the way.
01:44:55 <shachaf> Franciman: I made it annoyingly complicated for no reason, by the way.
01:45:04 <Franciman> what's that join (.) part?
01:45:11 <shachaf> > dropWhile isSpace . (reverse . dropWhile isSpace . reverse) $ "   blah blah   "
01:45:12 <lambdabot>   "blah blah"
01:45:19 <shachaf> join (.) f = f . f
01:45:52 <Franciman> ahhh
01:45:54 <Franciman> thanks :9
01:45:57 <Franciman> :)
01:46:24 <shachaf> Anyway, you could write that function to be more lazy if you were less lazy about writing it. :-)
01:46:45 <Franciman> :)
01:46:50 <Franciman> and is it fast?
01:47:10 <Franciman> what the hell of question did I do? o.O
01:47:15 <Spockz> Franciman: do you have something yet?
01:47:18 <Spockz> Franciman: with foldr/
01:48:15 <Franciman> Spockz, I thought it could be done like this : takeWhile (Something) foldr KillSpaces []
01:48:53 <ChristianS> what's KillSpaces doing?
01:48:56 <zhulikas> in what cases when updating the list, the list itself is not copied?
01:49:06 <Franciman> shachaf, I meant,  is using two times revers very time consuming?
01:49:21 <Spockz> Franciman: https://gist.github.com/2015784
01:49:22 <shachaf> Franciman: For an infinite list, extremely.
01:49:31 <zhulikas> I mean... is it (a:[]) and a:b:[] ?
01:49:40 <Franciman> ChristianS, remove spaces until it finds a non-space
01:50:44 <zhulikas> pattern match list as (a:[]) and then update it with b:a:[] or a:b:[]. In second case list will be updated and not copied, right?
01:51:08 <shachaf> zhulikas: Nothing is ever updated in-place.
01:51:16 <ChristianS> > let normalizeSpace = unwords. words in normalizeSpace "  This  is a   string   with too    much  space .   "
01:51:17 <lambdabot>   "This is a string with too much space ."
01:51:20 <zhulikas> I don't get when that works, but I read somewhere that it's possible to update without copying
01:51:28 <ChristianS> Franciman: that ^^ what you trying to do?
01:51:33 <Franciman> no
01:51:40 <Franciman> I was trying to do
01:51:57 <Spockz> otherwise use the uulib parser to parse infinite (or long) streams
01:52:04 <Franciman> > join (.) ( dropWhile isSpace . reverse ) " Hello World "
01:52:06 <lambdabot>   "Hello World"
01:52:20 <shachaf> zhulikas: Update what without copying?
01:52:25 <zhulikas> a list
01:52:26 <zhulikas> [a]
01:52:33 <shachaf> What do you mean by "update"?
01:52:35 <Spockz> that's not how it works :)
01:52:36 <Franciman> but efficiently
01:52:54 <shachaf> If you say f (a:b:[]) = (a:b:[]), it'll (probably) construct new cons cells.
01:52:55 <zhulikas> insert a new value in the list without copying the list itself. It's a linked list after all
01:53:09 <Franciman> Spockz, and I guess that , that fold version is also slow
01:53:11 <ChristianS> Franciman: with String, you won't get more efficient that the function you already have.
01:53:14 <shachaf> zhulikas: What?
01:53:16 <zhulikas> :D
01:53:17 <Spockz> there are very few occasions where you will have inplace sorting
01:53:26 <ChristianS> Franciman: if you want to faster string type, use Data.Text.
01:53:32 <Spockz> Franciman: it's as fast as you'll get when using strings (and not ByteStrings)
01:53:37 <zhulikas> I should probably google to find where I read about it...
01:53:49 <Franciman> Spockz, so it's the fastest possible?
01:53:50 <shachaf> zhulikas: What are you actually asking? Can you give a concrete example?
01:54:06 <Franciman> ChristianS, it's just an exercise to get used to Haskell :)
01:54:12 <Franciman> btw, thanks for the advice
01:54:18 <Spockz> Franciman: do you understand what it does?
01:54:49 <Franciman> it goes from right to left
01:55:15 <Franciman> and applies f, that is, if the curr character is a space
01:55:19 <Franciman> it trims it out
01:55:27 <Franciman> otherwise it stops
01:55:40 <Spockz> stop? How do you mean that
01:55:43 <Franciman> no it doesn't stop, it returns
01:55:52 <Franciman> that character, sorry
01:55:59 <ChristianS> Franciman: also, Data.Text already has a strip function, through that'll ruin the learning effect, admittedly.
01:56:39 <Franciman> ah Spockz, I missed a part
01:56:47 <Franciman> ChristianS, yes :9
01:57:38 <Spockz> read the function |f| aloud, maybe that will make it clearer
01:57:50 <Franciman> Spockz, it does that only when it finds spaces, if the current character isn't a space
01:58:04 <Franciman> it doesn't return a [] and so it just merges the curr char with the string
01:58:56 <Franciman> and of course when foldr starts the first pattern is matched
03:01:03 <chemistree> foldplop
03:02:01 <Spockz> Franciman: basically, I'm checking whether the current char is the last char (the first case of f) and then check what the current char is, if it is a space I drop it, otherwise I'll pass it
03:02:28 <Franciman> yes, better words, I'm not a great english writer :S
03:02:56 <Franciman> Spockz, and it's faster than that reverse stuff, right?
03:06:01 <ChristianS> Franciman: you should try it for yourself, but i doubt you'll the able to get faster than the twice-reverse.
03:06:51 <Franciman> ChristianS, is foldr implemented in terms of reverse?
03:07:09 <Spockz> ChristianS: did you see my solution
03:07:25 <ChristianS> no (to both)
03:08:00 <Franciman> so I guess it's faster than the two times reverse
03:08:33 <ChristianS> Franciman: don't guess, try (and use the -O2 option to compile both).
03:08:52 <Franciman> but I like guessing :(
03:09:13 * ChristianS sighs
03:09:24 <Franciman> nevertheless, I'm compiling it right now
03:09:38 * chemistree yawns
03:09:52 * mrcarrot yawns
03:09:58 * chemistree comfirms test
03:10:13 <mrcarrot> for each yawn, somebody is doing a ping timeout
03:10:22 <Franciman> ahah
03:10:52 <Spockz> ChristianS: he should be able to reason out why it is faster, not just compile it
03:11:36 <chemistree> I am trying to create a channel and invite someone at the same time... Someone did this to me once, but I do not know how to do it....
03:12:25 <mrcarrot> i do not know what yu are talking about now, as i have not followed the discussion... still i do not agree that it is always possible to reason why something is faster. compilers are smart to do strange things sometimes that without a lot of insight information you never know what happened
03:13:36 <Spockz> mrcarrot: not "why something is faster" but "why the one should be faster than the other", if in practice the compiler does things you didn't expect you'll only learn from it
03:14:25 <Spockz> mrcarrot: if of course you understand what the compiler did and what made it do what it did
03:15:18 <chemistree> Haskell
03:16:39 <chemistree> does anyone here beep?
03:16:47 <Franciman> noob question, how do I profile it
03:16:48 <Franciman> ?
03:16:50 <chemistree> hear***
03:17:13 <chemistree> Got to start somewhere
03:17:24 <Franciman> unix's time doesn't show any difference, they both run in 0,003 secs
03:18:54 <ChristianS> Franciman: told you so.
03:19:51 <Spockz> Franciman: take bigger strings
03:20:02 <Spockz> and repeat your test 1000 times
03:20:07 <Spockz> (in the same program)
03:20:13 <Franciman> ok
03:23:00 <Franciman> Spockz, I'm use repeat x trimr
03:23:04 <Franciman> is it ok?
03:23:38 <Spockz> what does repeat do?
03:24:13 <Franciman> it creates a list of length x of elements provided by trimr
03:26:15 <Spockz> and those elements are what exactly
03:27:41 <Franciman> > repeat 5 [12]
03:27:42 <lambdabot>   Couldn't match expected type `[t1] -> t'
03:27:42 <lambdabot>         against inferred type `[t2]'
03:27:53 <Franciman> @hoogle repeat
03:27:53 <lambdabot> Prelude repeat :: a -> [a]
03:27:54 <lambdabot> Data.List repeat :: a -> [a]
03:27:54 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Parameters Repeat :: Clamping
03:28:04 <Franciman> > repeat 5 12
03:28:05 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
03:28:20 <Spockz> look at the type again :)
03:28:20 <Franciman> > repeat 5
03:28:21 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
03:28:24 <Franciman> lol
03:28:49 <Franciman> take 100 repeat 5
03:28:58 <Franciman> this is the correct usage for what I wanted to do
03:29:02 <Franciman> > take 100 repeat 5
03:29:03 <lambdabot>   Couldn't match expected type `[a]'
03:29:03 <lambdabot>         against inferred type `a1 -> [a1]'
03:29:09 <Franciman> no
03:29:20 <_Mikey> > take 100 $ repeat 5
03:29:21 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
03:29:25 <Spockz> you are missing parentheses
03:29:44 <Spockz> so what would take 1000 $ repeat trimr give you?
03:29:46 <Franciman> uhh, what a stupid, yes
03:29:52 <dmwit> > replicate 100 5
03:29:52 <_Mikey> > repeat 5 . take 100
03:29:53 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
03:29:53 <lambdabot>   can't find file: L.hs
03:30:14 <Franciman> Spockz, a list of strings
03:30:18 <Franciman> trimr'd
03:30:31 <dmwit> Franciman: not quite
03:30:37 <Franciman> no?
03:30:44 <dmwit> no
03:30:46 <Spockz> trimr is your function right :)
03:31:13 <dmwit> Franciman: (I mean, where would it get a list of String from? There's none in your code, is it supposed to just guess some?)
03:31:24 <Feuerbach> Hi, is there a ready-to-use program for visualizing the call graph of a haskell program?
03:31:34 <Franciman> dmwit, trimr " Hello World "
03:31:50 <dmwit> Franciman: Where did " Hello World " come from?
03:31:56 <Franciman> so it would be : take 100 $ repeat $ trimr " Hello World "
03:32:03 <Franciman> it's my input
03:32:04 <dmwit> Franciman: The question is about (repeat $ trimr).
03:32:17 <Franciman> I want it to be there
03:32:54 <dmwit> Yes, take 100 $ repeat $ trimr " Hello World " looks reasonable.
03:33:24 <dmwit> take n . repeat = replicate n, though, so you should use that instead. =)
03:33:28 <dmwit> ?src replicate
03:33:29 <lambdabot> replicate n x = take n (repeat x)
03:33:36 <Spockz> Franciman: something like https://gist.github.com/19cccfaa4eff9bf4e5c0 is what you want
03:34:21 <Franciman> right
03:34:23 <Spockz> dmwit: that would not run the function 100 times
03:34:36 <dmwit> Spockz: What does that mean?
03:34:39 <Spockz> trimr will run once on the hello world string
03:34:47 <dmwit> What does that mean?
03:34:51 <dmwit> It's a function. It doesn't run.
03:34:54 <Spockz> and then that will be repeated 100 times
03:35:18 <Spockz> dmwit: sure in the end this will only build up the list, if it isn't show
03:35:22 <Spockz> +ed
03:36:20 <dmwit> I'm certain I've missed some context here, but talking about "how many times" something is evaluated is a very dangerous thing in Haskell.
03:36:26 <dmwit> There really are no guarantees about that kind of thing.
03:36:42 <dmwit> The whole point of purity is that you don't need to know that anyway.
03:36:54 <dmwit> You get the right answer whether the computer did something horrible on its way there or not.
03:36:57 <Spockz> dmwit: in this case we want to benchmark the trimr function
03:37:09 <dmwit> I see.
03:37:17 <Spockz> (and yes, there are betters ways to do that)
03:37:24 <Spockz> but my link shows a basic way :)
03:37:27 <dmwit> Benchmarking pure functions is tricky, yes. =)
03:37:37 <dmwit> Spockz: Your link does not really show a foolproof way, no.
03:38:15 <Franciman> done
03:38:43 <dmwit> Anyway, you should both take a look at criterion, which was built to take the guesswork out of this kind of benchmarking.
03:39:07 <Franciman> ChristianS, Spockz, the foldr version runs in 0,928 s. the reverse version runs in 0,936 s
03:39:16 <Spockz> dmwit: I know
03:39:22 <ChristianS> same speed
03:39:45 <Spockz> Franciman: which string did you use?
03:39:59 <Franciman> "                                           <mrcarrot> i do not know what yu are talking about now, as i have not followed the discussion... still i do not agree that it is always possible to reason why something is faster. compilers are smart to do strange things sometimes that without a lot of insight information you never know what happened                             "
03:40:17 <Franciman> sorry mrcarrot :)
03:41:27 <ChristianS> Franciman: i found that often to be the case -- don't try to outsmart ghc, you won't succeed.
03:41:33 <ChristianS> combinations of standard functions will get you very far. trying to unroll the same algorithm in a hand-written fold will generally gain you nothing.
03:41:57 <Spockz> ChristianS: but two reverses are still costly :)
03:42:12 <Spockz> especially with something in between
03:42:42 <Franciman> also if I loop 300 times, instead of 100 : the foldr version is faster of just 1 ms
03:43:24 <Franciman> and with 500 loops
03:43:44 <Spockz> you also have a lot of overhead now
03:43:46 <Franciman> the reverse version runs in : 0,432 secs, the other in 0,464
03:44:23 <ChristianS> Spockz: you would have to look at the generated core code to see what exactly goes one. i suppose that ghc optimizes as much of the reverse away as possible.
03:44:46 <Spockz> https://github.com/bos/criterion/blob/master/examples/Fibber.hs << try soothing like that Franciman
03:45:07 <chrisdone> Match SrcLoc Name [Pat] (Maybe Type) Rhs Binds
03:45:07 <chrisdone> ^ what is the Maybe Type here?
03:45:42 <chrisdone> from http://hackage.haskell.org/packages/archive/haskell-src-exts/1.11.1/doc/html/Language-Haskell-Exts-Syntax.html#g:5
03:45:55 <Franciman> uff, I must download it
03:47:05 <kallisti> learning Haskell is like learning 25 languages.
03:47:18 <Spockz> kallisti?
03:48:04 <kallisti> nothing nothing
03:48:28 <Franciman> also, reverse-version runs in 0,661 doing 500 loops and enlarging the text , foldr-version in 0,694
03:48:43 <Franciman> now I'll try with criterion
03:59:40 <_Mikey> > mkStdGen 100
03:59:41 <lambdabot>   101 1
03:59:55 <_Mikey> > random (mkStdGen 100)
03:59:56 <lambdabot>   (-3650871090684229393,693699796 2103410263)
04:00:06 <_Mikey> :t random
04:00:09 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
04:00:37 <_Mikey> > random (mkStdGen 100) :: (Bool, StdGen)
04:00:38 <lambdabot>   (True,4041414 40692)
04:00:48 <_Mikey> >fst$ random (mkStdGen 100) :: (Bool, StdGen)
04:01:02 <_Mikey> > fst $ random (mkStdGen 100) :: (Bool, StdGen)
04:01:03 <lambdabot>   No instance for (System.Random.Random
04:01:03 <lambdabot>                     (GHC.Bool.Bool, S...
04:01:27 <_Mikey> > fst $ random (mkStdGen 100) :: Bool
04:01:28 <lambdabot>   True
04:02:40 <Axman6> > read "101 1" :: StdGen
04:02:41 <lambdabot>   101 1
04:03:39 <_Mikey> Axman6, is the type of that returned expression StdGen?
04:08:42 <dmwit> _Mikey: Yes. See the ":: StdGen" hanging off the end?
04:10:05 <_Mikey> dmwit, http://tinyurl.com/4xur3bb
04:10:15 <dmwit> =)
04:32:43 <Taneb> My genealogy program is SO CLOSE TO COMPLETION
04:33:06 <Taneb> I can TASTE the completedness
04:33:43 <Taneb> The code's got a pretty hefty nested if that I should replace with something less nested if-y at some point
04:33:58 <Taneb> And it can't save family trees (although that's easy to implement now)
04:34:35 <Taneb> And it could do with a better interface
04:34:51 <Taneb> And can only report the family tree as a simple ancestry tree
04:35:03 <Taneb> But it's only really meant so that I can use it
04:36:08 <Taneb> :)
04:36:34 <_Mikey> awesome!
04:44:45 <adimit> is there some sort of default pretty printer for stuff with automatically derived Show instances? I just want to look at some complex ADTs with records and don't feel like writing my own pretty printer for these types right now.
04:45:11 <rostayob> adimit: groom
04:45:26 <rostayob> adimit: well, groom is like show but with line breaks.
04:45:36 <adimit> rostayob: pretty much what I need, yeah :_)
04:45:38 <adimit> thanks!
05:17:25 * hackagebot tls 0.9.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.9.1 (VincentHanquez)
06:24:44 <Liii> Hi, could anyone help me with the meaning of this type declaration? To my surprise it type checks.
06:24:44 <Liii> {-# LANGUAGE FlexibleContexts #-}
06:24:44 <Liii> type List a = Num a => [a]
06:24:44 <Liii> f :: List Char
06:24:44 <Liii> f = "Hm?"
06:26:58 <Saizan> f is declared to be a [Char] but only if where you use it you can provide a Num Char instance
06:27:27 <Liii> Hm.
06:28:27 <Liii> Ok, I see. This doesn't work:
06:28:28 <Liii> h :: Char
06:28:28 <Liii> h = head f
06:28:31 <Liii> Thanks!
06:32:56 <Feuerbach> Saizan: how does that syntax (for contexts in the type declaration) gets allowed? It's not H98, and it's not mentioned in the FlexibleContexts docs
06:35:33 <Feuerbach> actually, Rank2Types seems to be needed for that...
06:39:51 <Saizan> it's not really a higher-rank type though
06:40:18 <Saizan> but i guess that's a fine extension where to put it
06:41:42 <bremner> email verification on trac.haskell.org is broken for me. Any idea who I should ask about that?
06:41:49 <bremner> or is the whole thing just dead?
06:43:45 <Spockz> bremner: it doesn't work for me anymore either
06:44:33 <Feuerbach> Saizan: still I don't understand what's going on in the Liii's example. E.g. ":t f" in ghci leads to a "No instance" message. Looks like a bug to me.
06:44:57 <Feuerbach> ah, got it now
06:45:04 <Feuerbach> the instance could be declared in another module
06:45:09 <bremner> Spockz: kindof embarassing...
06:45:32 <Spockz> bremner: it is.. I'm sorry
06:45:58 <bremner> Spockz: sure, not your fault, I assume ;)
06:46:04 <Spockz> bremner: apparently there are some emailaddresses that still work
06:46:09 <Spockz> bremner: no, not my fault
06:46:15 <Spockz> bremner: nor is it my responsibility
06:47:25 <bremner> is there some mailing list I could report this to?
06:47:33 * hackagebot CV 0.3.5 - OpenCV based machine vision library  http://hackage.haskell.org/package/CV-0.3.5 (VilleTirronen)
06:47:35 * hackagebot graphicstools 0.2 - Tools for creating graphical UIs, based on wxHaskell.  http://hackage.haskell.org/package/graphicstools-0.2 (VilleTirronen)
06:48:04 <Spockz> bremner: haskell user list I guess, but I'm not sure, I always pick the wrong mailing list :P
06:49:02 <bremner> ok
06:50:05 <Cody_> Is it more efficient to filter a list by 'x' or have 'x' be a predicate in the list comprehension?
06:50:21 <mauke> what's the difference?
06:50:22 <Axman6> @src filter
06:50:22 <lambdabot> filter _ []     = []
06:50:22 <lambdabot> filter p (x:xs)
06:50:22 <lambdabot>     | p x       = x : filter p xs
06:50:22 <lambdabot>     | otherwise = filter p xs
06:50:50 <Axman6> also pronounced filter p xs = [x | x <- xs, p x]
06:51:00 <Cody_> is there one? I dont know
06:51:25 <Cody_> In terms of speed
06:51:31 <mauke> if you can't tell the difference, why bother?
06:52:32 <Axman6> they end uo being the same
06:53:26 <Cody_> mauke: I'm doing a ProjectEuler problem that deals with large numbers and length its factors, in this case, the faster one would help more.
06:53:35 <Cody_> Axman6: Alright, thanks
06:53:43 <nand`> sounds like preemptive optimization
06:53:46 <mauke> Cody_: so why not test it?
06:54:08 <Jafet> A turbo-encabulator can filter using the barescent skor transform
06:54:09 <Cody_> mauke: Cause the first 'test' isn't done yet lol
06:54:14 <Axman6> it all boild down to case statements anyway
06:54:30 <Axman6> s*
07:00:30 <Spockz> where can I find the Haskell image sources?
07:04:58 <Axman6> Spockz: the what?
07:05:32 <Spockz> Axman6: the logos for Haskell and the Haskell platform, is there a source for them somewhere/
07:07:03 <Botje> http://en.wikipedia.org/wiki/File:Haskell-Logo.svg
07:07:05 <Botje> here's one.
07:15:59 <adnauseam> is a binary function simply a function that takes two parameters ?
07:16:16 <sipa> yes
07:16:17 <dmwit> probably
07:16:22 <dmwit> What's the context?
07:16:27 <adnauseam> foldr
07:16:42 <sipa> :t foldr
07:16:42 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:16:45 <Jafet> In other words, binary functions don't exist!
07:16:55 <adnauseam> wat :o
07:16:58 <sipa> in haskell they don't
07:17:14 <adnauseam> lyah refers to foldr's function as binary:|
07:17:31 <dmwit> Jafet's making a bit of a joke.
07:17:34 <sipa> it's matter of philosophy
07:17:43 <dmwit> It's a riff on the idea that every function in Haskell takes one argument.
07:17:49 <Jafet> Well, it was an obligatory one.
07:17:53 <adnauseam> oh - i'm a new so the context of jokes will be lost on me thinking you're always serious ;p
07:17:57 <dmwit> "Binary" functions take one argument and return a function that takes the next argument. =)
07:18:10 <td123> adnauseam: lyah certainly goes over currying
07:18:26 <adnauseam> it does - i understand the concept of currying
07:18:28 <Jafet> Also, b can be a function type, and a value of (a -> b -> b) will be able to take more than two parameters.
07:18:31 <adnauseam> i'm trying to understand foldr :p
07:18:55 <td123> oh
07:18:59 <dmwit> adnauseam: Check the diagrams here: http://en.wikipedia.org/wiki/Foldr
07:18:59 <nlogax> what languages have you used previously, adnauseam?
07:19:04 <dmwit> Those really cleared things up for me.3
07:19:06 <adnauseam> java :|
07:19:36 <sipa> adnauseam: you must unlearn what you have learned
07:19:43 <adnauseam> trying =P
07:19:53 <nlogax> oh, i thought i could point out a similar function/method, but i don't know of one in java :)
07:20:18 <Jafet> nlogax: it will have as many words in its name as foldr has letters
07:20:54 <nlogax> Jafet: and factories stretching out as far as the eye can see
07:21:12 <sipa> nlogax: sort exists, and they need an anonymous class to implement an anonymous function in an inefficient way
07:21:18 <td123> foldingAListWithFunctionAndAccumulatorStartingFromTheRightSide
07:21:40 <dmwit> The 'r' does not stand for "starting at the right side", it stands for "right-associative".
07:21:50 <Jafet> Not that long. There won't be any space left on that line for the generics types.
07:22:09 <nlogax> there's a nice tool that shows each iteration of foldr or whatever you put into it, but i forgot where it is/what it's called
07:22:30 <Jafet> dmwit: better than starting from the wrong side eh
07:22:33 <dmwit> > foldr f z [a,b,c,d]
07:22:34 <lambdabot>   f a (f b (f c (f d z)))
07:22:48 <nlogax> oh! nice
07:22:54 <adnauseam> what's z ? :|
07:23:03 <sipa> the initial value
07:23:04 <dmwit> adnauseam: It's a sneaky trick. =)
07:23:22 <Jafet> > x + y
07:23:23 <lambdabot>   x + y
07:23:29 <dmwit> adnauseam: "z" is defined to be a value which, when passed to "Show", results in the string "z"
07:23:33 <adnauseam> curses, tricks !
07:23:40 <adnauseam> hrm
07:23:41 <nlogax> @src sum
07:23:42 <lambdabot> sum = foldl (+) 0
07:23:44 <dmwit> > text "foo"
07:23:45 <lambdabot>   foo
07:23:49 <dmwit> > let foo = text "foo" in foo
07:23:50 <lambdabot>   foo
07:24:02 <dmwit> > let foo = text "but it's actually not magic" in foo
07:24:03 <lambdabot>   but it's actually not magic
07:24:06 <nlogax> adnauseam: there's an example of adding every number in a list, using 0 as the starting value
07:24:17 <adnauseam> yeah i got that
07:24:18 <dmwit> > let foo = text "really"; bar = text "magic" in foo + bar
07:24:19 <lambdabot>   No instance for (GHC.Num.Num Text.PrettyPrint.HughesPJ.Doc)
07:24:19 <lambdabot>    arising from...
07:24:25 <adnauseam> the thing is, what happens when z is []
07:24:31 <Saizan> @where stepeval
07:24:31 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
07:24:34 <dmwit> > let foo = var "really"; bar = var "magic" in foo + bar
07:24:35 <lambdabot>   really+magic
07:24:39 <adnauseam> it's easy enough to understand when i do sum
07:24:47 <sipa> adnauseam: stop
07:24:55 <adnauseam> :o
07:24:57 <sipa> :t foldr
07:24:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:24:58 <nlogax> adnauseam: then it doesn't type check. if you mean foldr (+) []
07:25:07 <mauke> > foldr f 0 [1 .. 4] :: Expr
07:25:08 <lambdabot>   f 1 (f 2 (f 3 (f 4 0)))
07:25:20 <sipa> the 'z' is of type b
07:25:39 <sipa> the list of values is of type [a]
07:25:59 <adnauseam> hrm
07:26:13 <sipa> and the function takes a value of type a, and the accumulator of type b
07:26:20 <zhulikas> <mauke> > foldr f 0 [1 .. 4] :: Expr
07:26:21 <zhulikas> <lambdabot>   f 1 (f 2 (f 3 (f 4 0)))
07:26:24 <zhulikas> how can I do that in ghci?
07:26:31 <adnauseam> what's the accumulator's role exactly ?
07:26:32 <dmwit> ?hackage simple-reflect
07:26:33 <lambdabot> http://hackage.haskell.org/package/simple-reflect
07:26:39 <dmwit> zhulikas: install that package
07:26:43 <zhulikas> thanks
07:27:11 <sipa> adnauseam: mauke's example is probably clearer
07:27:13 <zhulikas> amazing
07:27:38 * hackagebot SVGFonts 1.1.1 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.1.1 (TillmannVogt)
07:27:51 <dmwit> adnauseam: The accumulator gathers up information about all the various elements of the list.
07:28:01 <dmwit> adnauseam: What that means, exactly, depends on what you're trying to use foldr for.
07:28:20 <dmwit> adnauseam: For "sum", the accumulator gathers up the sum of all the elements it's seen so far.
07:29:06 <adnauseam> eah it's foldr's generic nature that's getting to me - i understand what it does in terms of the accumulator being 0, using it as the initial value and type. i just simpy find myself confused when using it in anything else
07:29:11 <adnauseam> but
07:29:23 <adnauseam> hrm
07:29:33 <adnauseam> so it's not an "initial" value
07:29:47 <adnauseam> hrm
07:29:49 <dmwit> What is "it" in that sentence?
07:29:50 <adnauseam> that's tricky
07:29:56 <adnauseam> the accumulator
07:30:15 <nlogax> it *is* the initial value
07:30:20 <adnauseam> it's only 0 because it's an accumulator that can have an Ord...
07:30:33 <adnauseam> yeah i actually understood that just now i think
07:30:40 <dmwit> adnauseam: The value you hand to foldr is the initial value of the accumulator.
07:30:57 <adnauseam> it's an accumulator that only happens to belong to Ord and be a 0
07:31:06 <dmwit> Wait, what?
07:31:08 <nlogax> @src foldr1
07:31:08 <lambdabot> foldr1 _ [x]    = x
07:31:08 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
07:31:08 <lambdabot> foldr1 _ []     = undefined
07:31:12 <adnauseam> :p
07:31:14 <dmwit> Where did Ord enter into this?
07:31:27 <nlogax> there's one where the initial value is just the first thing in the list
07:31:31 <adnauseam> well compare 0 to []
07:31:39 <mauke> adnauseam: what?
07:31:47 <nlogax> but then the list cannot be empty
07:31:50 <dmwit> Yeah, what?
07:31:50 <mauke> you can't compare 0 to []
07:32:07 <mauke> foldr does no comparisons
07:32:22 <adnauseam> no i meant caes when foldr is used with 0, and cases where foldr is used with [], on their respective data types
07:32:49 <adnauseam> if i use [] as an accumulator, and (+) as my function, what should my last element be
07:32:52 <adnauseam> ?
07:32:57 <mauke> that makes no sense
07:33:01 <mauke> you can't use + on []
07:33:06 <applicative> you'd have to add lists
07:33:16 <adnauseam> well when the accumulator is 0, then it has to be a /list/ of ints
07:33:18 <sipa> you could use (++)
07:33:25 <adnauseam> oh
07:33:38 <yitz> adnauseam: there is no mutable accumulator. a new value is computed at each step, and that is passed on as part of the input to the next step.
07:33:39 <applicative> > foldr (++) [] ["hello", "ad" , "nauseam"]
07:33:40 <lambdabot>   "helloadnauseam"
07:33:54 <adnauseam> :O
07:34:13 <nlogax> @src concat
07:34:13 <lambdabot> concat = foldr (++) []
07:34:16 <adnauseam> that explains 90% of these errors then
07:34:21 <zhulikas> :D
07:34:22 <dmwit> adnauseam: I think you may still have some fundamental wrong idea about foldr stuck in your head.
07:34:34 <adnauseam> i was trying to force an operation that doesn't really go with the type of list objects i had in it
07:34:35 <zhulikas> @type concat
07:34:36 <lambdabot> forall a. [[a]] -> [a]
07:34:46 <adnauseam> dmwit - trying to weed them all out
07:37:15 <applicative> adnauseam: did you see the nice pics at e.g. http://www.haskell.org/haskellwiki/Fold#List_folds_as_structural_transformations
07:38:13 <adnauseam> about to  ;p
07:41:28 <nlogax> adnauseam: the biggest problem i had when beginning to use haskell, was that i thought everything had to be really complicated, because it would have been in the languages i already knew. i thought there was lots of hidden magic everywhere. dunno if that helps, but if you have similar thoughts, just try to start from the beginning and don't assume anything :)
07:42:38 * hackagebot reactive-banana 0.4.3.2 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.4.3.2 (HeinrichApfelmus)
07:42:40 * hackagebot reactive-banana-wx 0.4.3.2 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.4.3.2 (HeinrichApfelmus)
07:45:17 <adnauseam> nlogax: our minds are powerful tools - it's just that it's intrinsically to unlearn things that were learned. i'm not a complete newb to programming - but aye i've noticed that functional programming with haskell, as with other languages such as lisp\ml etc, is a totally new paradigm to the maintstream
07:45:48 <Jafet> Heh, promotional lies
07:46:09 <adnauseam> where :o
07:46:11 <Jafet> Algorithmic programming in Haskell is largely the same, just with less typing
07:46:57 <yitz> @faq does haskell make everything simple?
07:46:58 <lambdabot> The answer is: Yes! Haskell can do that.
07:47:14 <adnauseam> i've been noticing that learning to do the same with less is a refined art :p
07:49:39 <Jafet> I think the best feature, in fact, is that there is less typing involved
07:49:49 <mizu_no_oto> cabal: dependencies conflict: ghc-7.0.4 requires array ==0.3.0.2 however
07:49:50 <mizu_no_oto> array-0.3.0.2 was excluded because ghc-7.0.4 requires array ==0.3.0.3
07:49:52 <mizu_no_oto> Is it just me, or is cabal complaining that a single package has conflicting dependencies?  How do I fix this?
07:50:57 <Saizan> mizu_no_oto: that's a variant of this http://www.haskell.org/cabal/FAQ.html#dependencies-conflict i think
07:50:58 <applicative> what v ersion of ghc itself do you have
07:51:43 <adnauseam> jaget - i've noticed that while looking at the implementation of quicksort
07:51:45 <applicative> it's strange to me that you are installing the ghc package by cabal it comes with ghc doesn't it
07:52:39 * hackagebot tuple-gen 2.0 - Enum instances for tuples where the digits increase with the same speed  http://hackage.haskell.org/package/tuple-gen-2.0 (TillmannVogt)
07:53:16 <Saizan> how haskell programming is not even the same as ml/lisp programming: http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
07:53:37 <adnauseam> yea it's not the same
07:53:53 <vl4kn0> hello, is there any way I can use regular expressions in haskell without using any external libraries? I only need matching strings against regexps
07:53:56 <mizu_no_oto> applicative: The Glorious Glasgow Haskell Compilation System, version 7.0.4
07:53:59 <adnauseam> just compared to java,c, c++ etc, the other ballpark just looks it belongs to the "other side"
07:54:11 <Axman6> Jafet: more types means less typing?
07:54:27 <dmwit> vl4kn0: Does "without using any external libraries" mean no FFI, or no Hackage?
07:54:32 <Axman6> adnauseam: son't forget those are all languages with a common syntac, C's
07:54:48 <adnauseam> which ?
07:54:53 <adnauseam> java\c++ etc?
07:55:01 <applicative> ghc-pkg list should show the library ghc-7.0.4 is already installed, no?
07:55:16 <Jafet> Axman6: no, it is purely a coincidence that Haskell has both
07:55:52 <Axman6> I'm not sure it's completely a coincidence, but yes
07:56:59 <adnauseam> well bickering over the nitty gritty doesn't do anyone good
07:57:03 <vl4kn0> dmwit: well, i'm doing my assignment to school, and the tutor is just going to run the ouput program, so if there is a way to enable them using haskell, that's ok
07:57:38 <Jafet> In fact, strong typing seems to correlate negatively with reduced typing, as far as other languages are concerned
07:58:02 <Axman6> bickering? we rarely bicker in here, the tone of conversation is usually quite conversational
07:59:08 <dmwit> vl4kn0: I'm not sure I understood your answer.
07:59:39 <dmwit> vl4kn0: Keep in mind that GHC-compiled executables are statically-linked. So if your deliverable is an executable, then any Hackage package might be fair game.
07:59:56 <dmwit> If your deliverable is source code, then you need to know what packages are installed on the grader's computer.
07:59:58 <ozataman> does anyone know why cabal-dev would all of a sudden start putting all .o and .hi files in a single module-like directory structure onder cabal-dev/lib?
08:00:00 <vl4kn0> dmwit: I see, that should be fine then
08:00:10 <Jafet> vl4kn0: if your tutor is deciding whether using a certain library is allowed, then your tutor can tell you whether using a certain library is allowed. We cannot.
08:00:43 <dmwit> Yes, also the usual caveats regarding checking with your instructor go here. =)
08:01:05 <vl4kn0> dmwit: ok, and is there any way to use regexps with only default installation of ghc?
08:01:21 <dmwit> You can implement them in about 30-40 lines of code. =)
08:01:37 <Jafet> You can implement regular expressions, not regexps!
08:01:46 <dmwit> hah
08:01:56 <vl4kn0> hmm
08:01:57 <Jafet> Or its estranged cousin, regexes
08:04:13 <MostAwesomeDude> a
08:04:19 <MostAwesomeDude> ...Dammit, screen.
08:13:24 <Jafet> > concatMap (\s -> if isPrefixOf "C-" s then ["C-a", s] else [s]) `iterate` ["C-x", "C-c"]
08:13:25 <lambdabot>   [["C-x","C-c"],["C-a","C-x","C-a","C-c"],["C-a","C-a","C-a","C-x","C-a","C-...
08:13:51 <Jafet> Actually, I don't think screen works like that...
08:26:27 <alistra> :t iterate
08:26:28 <lambdabot> forall a. (a -> a) -> a -> [a]
09:05:12 <scooty-puff-sr> if i have a GADT that includes a constraint, data MkThing thingConstraint :: * -> Constraint; with a few data constructors requiring certain constraints, but containing now other arguments
09:05:24 <scooty-puff-sr> i.e. to kind of reify a few constraints i guess
09:06:03 <scooty-puff-sr> i would expect that pattern matching on it would not actually require the value - that undefined :: MkThing Show, if no other data constructors have that Show constraint
09:06:34 <scooty-puff-sr> maybe a paste would clear it up a little
09:07:06 <dzhus> Is there a container which may be made of fixed length (on type level) with Functor instance?
09:07:35 <dzhus> (i'd like to map over triples)
09:07:59 <Saizan> the simplest way would be data Triple a = Triple a a a
09:08:38 <Saizan> otherwise you can look at size-indexed vectors
09:08:48 <kallisti> I think he menat with a type-encoded length paramter.
09:09:13 <Saizan> hence my otherwise :)
09:09:35 <dzhus> I think simple custom Triple datatype will do
09:09:57 <Saizan> data Z; data S a; data Vec n a where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a
09:12:04 <hpaste> scooty-puff-sr pasted “Unexpected evaluation of undefined” at http://hpaste.org/65151
09:12:28 <scooty-puff-sr> it seems to be that undefined should not be required - that it should be known based on the type
09:12:44 * hackagebot ltk 0.12.0.0 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.12.0.0 (JuergenNicklischFranken)
09:12:45 <dzhus> ok, is there liftM2, but for functors?
09:13:05 <Botje> there's liftA2 for applicative functors
09:13:13 <koeien> dzhus:i don't think that's possible in general
09:13:23 <koeien> that's require f (a -> b) -> f a -> f b
09:13:27 <koeien> that'd*
09:13:56 <rwbarton> @type liftM2
09:13:57 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:14:23 <dzhus> yes, I had lists and I could do (liftM2 (+) l1 l2)
09:14:29 <rwbarton> having liftM2 (and "liftM0") is basically what it means to be Applicative
09:14:45 <koeien> yup, you need <*> as well
09:15:05 <koeien> <$> is Functor already, you need pure and <*>
09:15:54 <koeien> for [] you have two choices, ZipList and the one that corresponds to the Monad instance
09:17:44 * hackagebot leksah-server 0.12.0.3 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.12.0.3 (JuergenNicklischFranken)
09:22:46 * hackagebot leksah 0.12.0.3 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.12.0.3 (JuergenNicklischFranken)
09:27:15 <Philonous> How is it possible that ghci, when started as a inferior emacs process suddenly isn't able to load libraries (that work fine when I start it in the console)
09:28:01 <ClaudiusMaximus> were libraries installed after ghci was started?
09:28:30 <Philonous> No
09:32:58 <Philonous> Ugh, problem solved, it was just me being a turnip.
09:35:52 <hpaste> scooty-puff-sr annotated “Unexpected evaluation of undefined” with “Works!  But uses unsafeCoerce” at http://hpaste.org/65151#a65152
09:36:30 <edwardk> dzhus: lists are stronger than Functor
09:37:52 <rwbarton> scooty-puff-sr: maybe I missed some context, but I'm not sure why you wouldn't expect a function which pattern matches on an argument whose value is undefined to evaluate undefined...?
09:39:21 <scooty-puff-sr> i'm not completely surprised - mostly would like a solution that works - and not really a fan of the unsafeCoerce (btw, still works after adding other Mk<...> constructors)
09:40:20 <rwbarton> well I'm not sure what the problem you're trying to solve is, but why can't you just pass MkShowThing?
09:40:55 <scooty-puff-sr> well, its a long story.. but from this: http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
09:41:12 <scooty-puff-sr> i have a (HasLocPred a hasLoc, MkMsg hasLoc a) => ...
09:41:12 <rwbarton> oh god
09:41:19 <scooty-puff-sr> and would like to get rid of the MkMsg constraint
09:41:32 <rwbarton> OverlappingInstances, okay never mind. :P
09:41:33 <scooty-puff-sr> kind of a code golf thing..
09:41:39 <rwbarton> your problem, not mine! :)
09:42:55 <scooty-puff-sr> yeah, should prob just accept the constraint..
09:43:31 <scooty-puff-sr> had gone so far as HasLocProd :: * -> (* -> Constraint) -> * - i.e., instead of the True/False in the pred, the actual constraint
09:43:41 <scooty-puff-sr> which ended up leading to trying to reify the constraint
09:43:49 <scooty-puff-sr> well, reify probably isn't really the right word
09:44:26 <scooty-puff-sr> which got me to the current set of pastes
09:53:22 <cheater_> is \case supported in 7.4?
09:57:05 <ChristianS> what's \case?
09:57:34 <parcs`> ChristianS: no
09:57:39 <parcs`> cheater_: no
09:57:50 <parcs`> if you mean lambda case expressions
09:58:10 <cheater_> yes
09:58:25 <cheater_> is it going to be supported somewhere at all?
09:59:59 <geekosaur> I thought that discussion kinda wound down to a lack of conclusion and ended up not being formally proposed.  possibly because the generalization (multipattern lambda) should have been left off/alone...
10:00:27 <koeien> i don't think it's that useful tbh, just introduce a name
10:02:39 <cheater_> aha
10:07:28 <Philippa> koeien: the introduction can be annoyingly chunky in what was otherwise pointless code, but yeah. Worst case is let/where-binding the pattern match
10:08:39 <henux> Hi, I'm new to Haskell! Can you recommedn me a library to draw simple graphics to a window, like filled rectangles and lines only?
10:08:55 * geekosaur should dig that discussion out of the archives and see where it actually ended up...
10:09:19 <geekosaur> henux: HGL will work for simple multiplatform graphics, and there at least used to be a haskell tutorial using it
10:09:44 <henux> Ok! Let me check that out!
10:09:53 <henux> I assume its and OpenGL binding?
10:09:58 <henux> an*
10:11:44 <geekosaur> no
10:12:01 <geekosaur> "haskell graphics library", the lat 2 words of which are the sole relationship to opengl
10:13:15 <henux> Ok. So do I need to download and install the package somehow or is it pre-installed with WinGHCi ?
10:13:51 <osfameron> hmmm.  the Haskell/Atom code in http://leepike.wordpress.com/2010/05/31/twinkle-twinkle-little-haskell/ seems rather more opaque than the equivalent C needed to do the task in Arduino
10:14:11 <osfameron> not to mention that it then writes C code in strings *anyway*.
10:14:28 <geekosaur> uh.  no idea.  (it used to be bundled but I have no idea about current arrangements expecially on windows)
10:15:40 <henux> Ok, I will try to find out. Thanks!
10:15:41 <yitz> henux: diagrams is very nice: http://byorgey.wordpress.com/2012/03/09/announcing-diagrams-0-5/
10:15:56 <yitz> henux: it doesn
10:16:25 <_Mikey> Am I right in saying in a functional language function calls have no side effects?
10:16:43 <_Mikey> or is this only true of purely functional languages?
10:16:56 <yitz> henux: it doesn't draw into a window. it creates a picture from a very nice high-level description. currently you can render as png or eps, soon also svg.
10:17:05 <geekosaur> the latter (it's a consequence of "pure")
10:17:08 <henux> yitz: Ok thanks
10:17:45 <_Mikey> ok thanks geekosaur, not that I don't believe you but could you point me in the right direction for proof
10:17:56 <_Mikey> not a wiki
10:19:23 <geekosaur> ...what?  I kinda suspect it's a single line in some paper which has been adopted generally
10:19:39 <geekosaur> the practical proofs are called lisp, scheme, sml, ocaml, ...
10:19:53 <_Mikey> hmm ok
10:20:03 <geekosaur> (lisp in particular os generally considered the first functional programming language, and very much supports side effects)
10:20:24 <_Mikey> cool
10:23:24 <geekosaur> if you really want a formal definition, the concept you're looking for is referential transparency
10:23:41 <dzhus> :t pure
10:23:42 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:24:48 <Philippa> geekosaur: I think that meaning of "pure" is actually the derivative of "pure functional", myself
10:25:02 <Philippa> ("pure OO" being a rather corrupted term by now)
10:25:22 <geekosaur> in some sense, yes
10:25:51 <geekosaur> (which is why the term referential transparency exists; "pure" has too many meanings/uses)
10:26:20 <Philippa> quite
10:26:30 <Philippa> though RT is occasionally misleading
10:27:46 <Philippa> consider map f nats vs mapp f nats, where nats = 1 : map (+1) nats; mapp f [] = []; mapp f [x] = [f x]; mapp f (x:x':xs) = f x : f x' : mapp f xs
10:28:00 <Philippa> (mapp is map that tries to eat two elements at once)
10:33:58 <MagneticDuck> Yo all... I have a little question for clarification: how do you say <*> out loud? I tend to say "app map", for "applicative map"
10:34:21 <niteria> is there a haskell package that takes a logical formula and gives its cnf form? To use with SAT solver
10:34:30 <zhulikas> I say less than star more than
10:34:35 <MagneticDuck> lol
10:34:38 <donri> "apply"?
10:34:51 <zhulikas> I say 'at'
10:34:52 <niteria> I've found one package, but it was last updated in 2007 and fails to compile even on ghc 6
10:34:54 <zhulikas> dunno why
10:34:55 <MagneticDuck> Yeah, but there are already two applies: "$" and "<$>"
10:35:07 <MagneticDuck> zhulikas: from applicative?...
10:35:16 <zhulikas> everything is 'at' for me
10:35:23 <zhulikas> well, especially $
10:35:35 <MagneticDuck> Names, names...
10:35:53 <MagneticDuck> But how *should* I say it? So I can talk with other Haskellers?
10:35:58 <zhulikas> :D
10:35:59 <MagneticDuck> Or Hackers, if you prefer
10:36:06 <zhulikas> are there any Haskellers around you??
10:36:10 <MagneticDuck> Nope...
10:36:14 <MagneticDuck> *sigh*
10:36:18 <zhulikas> so I don't see a problem :D
10:36:24 <ArchGT> hackagers
10:36:35 <zhulikas> I know one guy who uses Haskell in my city
10:36:38 <Philippa> MagneticDuck: "ap" for <*>, "map" or "fmap" for <$> and clarify if it's not obvious from context
10:36:39 <zhulikas> but I've never met him
10:36:50 <MagneticDuck> Hoogle, Hackers, Haskell, Hackers, Hackagers... I think I see a pattern!
10:36:55 <MagneticDuck> Philippa: Thanks
10:37:26 <MagneticDuck> Oh sorry, I forgot Hackage
10:37:39 <zhulikas> Haskellteers
10:38:00 <MagneticDuck> Nah, I like Haskellers, or if you must, Hashers better
10:38:01 <zhulikas> Haskellnauts
10:38:12 <zhulikas> Hashishers
10:38:14 <MagneticDuck> Hey, I actually do like Hashers!
10:38:39 <zhulikas> Haskeller is kinda standard as I see it
10:38:57 <zhulikas> what about Huskies
10:39:00 <MagneticDuck> LOL
10:39:08 <MagneticDuck> Not that, thankyouverymuch
10:39:28 <MagneticDuck> "Hacknerds"
10:39:30 <MagneticDuck> Nah
10:40:11 <zerax> Haskell Heroes
10:40:31 <dfletcher> hasskill :)
10:40:35 <dfletcher> mornin
10:40:48 <Philippa> "lazy fuckers"
10:40:53 <MagneticDuck> ?
10:40:56 <shergill> hah
10:41:01 <shergill> i like lazy fuckers
10:41:07 <MagneticDuck> Lazers
10:41:23 <MagneticDuck> Lazy Hackage Heroes
10:41:44 <MagneticDuck> Haskelly Hackers on Hackage who are Lazy
10:41:50 <MagneticDuck> or... the HHOHWAL
10:42:28 <MagneticDuck> BTW, I think niteria had a question...
10:42:52 <MagneticDuck> niteria: You still there?
10:43:02 <niteria> yeah, I did, I figured if anyone knew, it would be answered by now
10:43:51 <niteria> I figured it's not so hard to write one yourself
10:43:57 <MagneticDuck> We're lazy. That's part of the language. Personally, I had no idea.
10:45:08 <Philippa> niteria: it has the feel of something with a lot of NIH going on, people working on logic tend to be keen on their own chosen representations (and for good reason)
10:46:01 <henux> If I dont mention a function in module statement, does it mean the function will be private inside the module?
10:46:04 <zhulikas> for once a man can be proud to be lazy!
10:46:11 <zhulikas> is using Haskell
10:46:25 <MagneticDuck> henux: No
10:46:34 <MagneticDuck> Outside, yes.
10:47:04 <MagneticDuck> ...that is, you can't access it from *inside* the module? No.
10:47:08 <henux> Its invisible outside the module?
10:47:32 <Saizan> yep
10:47:36 <MagneticDuck> If you load the module, yes.
10:48:41 <MagneticDuck> That's the point of modules... besides keeping the structure clean, you only export a few functions, so you don't have to worry about people using all of your utility functions that you declared inside.
10:48:58 <byorgey> yitz: the diagrams cairo backend can be used to generate PDF, PNG, PS, SVG, *or* draw into a window.
10:51:59 <Philippa> byorgey: how easy is it to get clickable or drag'n'droppable widget-like things from there?
10:52:20 <Philippa> (to put it another way: I have backburner projects that want structural tree editors, how much boilerplate would I need?)
10:53:21 <byorgey> Philippa: it's definitely doable.  See mgsloan's https://github.com/mgsloan/gtk-toy  and  https://github.com/mgsloan/gtk-toy-diagrams
10:53:58 <byorgey> Philippa: the only potential downside is that it might not be fast enough; currently you would have to re-render the entire thing every time you drag a widget or whatever
10:54:29 <Philippa> I'm more worried about how much code I'd have to write to get it running, I guess
10:54:33 <byorgey> but we would like to move in the direction of better support for interactivity and incremental re-evaluation
10:54:46 <Philippa> remind me: does cairo support hardware rendering and do basic clipping?
10:55:02 <Philippa> because if so, that ought to be doable interactively on any remotely modern hardware
10:55:18 <byorgey> Philippa: re: cairo, I'm not sure
10:55:20 <hpaste> dzhus pasted “So I figured out about Applicative functors” at http://hpaste.org/65155
10:56:05 <Philippa> *nod*. I ask because... well, if my desktop can run Deus Ex: HR at the settings it can, a few tree diagrams shouldn't even nudge the temperature from idle
10:56:17 <byorgey> Philippa: re: how much code you would have to write, I don't know for sure, but you can take a look at mgsloan's projects to see how much code he had to write (and maybe you can even reuse some of it)
10:56:25 <byorgey> Philippa: yeah, good point =)
10:57:17 <byorgey> Philippa: would be fun to have an OpenGL backend too but no one is working on one ATM
10:58:43 <Philippa> byorgey: at a glance it looks like "more work than I can probably sustain through to getting to do the bit I care about", unfortunately. But my threshold for that's irritatingly low
10:59:20 <byorgey> Philippa: fair enough.  check back in a year or so! =)
10:59:57 <Philippa> *nod*. When it's Good Enough, there are some very promising tools that we've got the back end tech to make viable now
11:00:42 <byorgey> agreed
11:00:56 <Philippa> even if you're stuck working at External Core level, a refactoring tool with instrumentation up the wazoo feeding into a fully versioned storage format (at meta level, not just object level) is way, way too much fun to pass up on
11:01:51 <byorgey> yeah, sounds awesome!
11:02:20 <Philippa> to put it another way: photoshop for code :-)
11:02:29 <vodik> what name to people usually give Data.ByteString or Data.ByteString.Char8 when imported qualified?
11:02:39 <vodik> BS? B8?
11:02:47 <irene-knapp> BS
11:02:48 <Philippa> BS seems obvious enough
11:03:07 <koeien> i've seen S as well
11:03:13 <koeien> I use B or BS
11:03:37 <vodik> im using B8.putStrLn $ BS.pack out
11:03:43 <vodik> to print a [Word8]
11:03:50 <vodik> maybe there's a shorter way to do this
11:03:54 <koeien> avoid pack
11:04:07 <vodik> okay
11:05:03 <vodik> so how would i output a [Char8] to the screen then?
11:05:18 <koeien> oh it's fine if you can't avoid it.
11:05:33 <koeien> it's just relatively slow
11:05:37 <vodik> err [Word8]
11:05:48 <vodik> i understand
11:07:12 <henux> How do you install Haskell packages you download?
11:07:40 <koeien> tar zxvf bla.tar.gz; cd bla; cabal install
11:07:57 <parcs`> z is redundant ;)
11:08:05 <cnvmals> as is v
11:08:09 <parcs`> tar is smart enough to detect a compressed archive
11:08:22 <parcs`> yeah but v is useful sometimes
11:08:32 <koeien> TIL about z.
11:08:39 <koeien> i like to see what i unpack though
11:08:57 <henux> the online tutorial uses runhaskell setup
11:09:26 <dcoutts_> koeien: or simply: cabal install bla.tar.gz
11:09:37 <koeien> aha! even nicer.
11:12:54 <dzhus> :t []
11:12:55 <lambdabot> forall a. [a]
11:16:17 <hpaste> henux pasted “cabal error” at http://hpaste.org/65157
11:16:23 <exFalso> hi, im trying to install Agda with cabal. it has a dependency base < 4.5 which i removed (using ghc 7.4.1). now when im trying to install it it tries to reinstall DeepSeq (already installed) and fails due to an unsafe import(Data.Array). any ideas?
11:16:28 <henux> I get that error when trying to install HGL
11:17:01 <henux> I think I should have base
11:17:06 <dcoutts_> henux: HGL is very old, and I don't think it's ever been reliable with GHC anyway
11:17:12 <henux> I see
11:17:17 <dcoutts_> use one of the many alternatives
11:17:24 <henux> which do you recommend?
11:17:36 <dcoutts_> if you just want SOE stuff then there's a couple options
11:17:37 <henux> i just need to draw simple things like filled rects and lines
11:17:43 <henux> SOE?
11:17:50 <dcoutts_> never mind
11:17:59 <henux> no idea what is SOE
11:18:11 <dcoutts_> or there's SDL, Gtk + Cairo
11:18:24 <exFalso> gloss
11:18:37 <henux> Gtk no thanks
11:18:39 <dcoutts_> and others if you don't need a GUI just a graphics file output
11:18:48 <dcoutts_> and also OpenGL
11:19:48 <dcoutts_> henux: usually the only reason think they want HGL is because of SOE, but if you've never heard of it that's ok
11:20:14 <dcoutts_> only reason think they... / only reason *people* think they...
11:20:49 <henux> Ok nice. Installing SDL gives me an error that I dont have SDL installed. Where do I need to put those runtime libs for it to find it?
11:21:26 <parcs`> henux: what operating system?
11:22:21 <henux> Win7
11:29:01 <jay7557> Hello all!
11:29:30 <koeien> hi jay7557
11:29:56 <jay7557> hi koeien
11:30:41 <jay7557> Can you help me with hs script?
11:31:05 <hpaste> jay7557 pasted “error” at http://hpaste.org/65158
11:31:25 <koeien> jay7557: what would you like to accomplish?
11:31:53 <Cale> jay7557: are you getting an error?
11:32:14 <monochrom> "a" has type [[Char]], putStr wants [Char], you have a type error, reflecting mind error
11:32:15 <Cale> oh
11:32:16 <koeien> a is of type [String] instead of String.
11:32:28 <Cale> yeah, you used putStr instead of print
11:33:07 <lispy> thinkos are the best kind of error
11:36:32 <statusfailed> So what happened to Yi?
11:38:20 <jay7557> hi
11:38:42 <jay7557> sorry my ubuntu crashes everytime i try to run hs script
11:39:10 <rostayob> > let (+) + 1 + 1 = (+) in 1 + 1
11:39:11 <lambdabot>   <no location info>: Parse error in pattern
11:39:23 <rostayob> :( lambdabot doesn't have n+k patterns :P
11:39:39 <jay7557> :t Sum
11:39:39 <lambdabot>     Ambiguous occurrence `Sum'
11:39:40 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
11:39:40 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
11:40:00 <jay7557> :i Sum
11:40:01 <KorriX> hello
11:40:06 <jay7557> hello
11:40:21 <koeien> n+k is gone
11:41:05 <jay7557> hey koeien sorry i was in conversation with u and suddenly my ubuntu got stucked
11:41:19 <KorriX> with haskelldb function can return me [Table] ?
11:42:08 <jay7557> what am trying to accomplish is to get arguements at cmd which replaces certain words in text file with asterisk (*) that I specify as getArgs
11:43:52 <jay7557> @koeien.. any idea to as how i may be able to achieve the result?
11:43:52 <lambdabot> Unknown command, try @list
11:49:14 <kallisti> is there a library I can use to help me write Show instances for record types?
11:49:35 <shergill> jay7557: you really shouldn't use the @ prefix or users in this channel
11:49:39 <shergill> *for
11:50:00 <hpaste> scooty-puff-sr pasted “Convert HasLocPred to type family?” at http://hpaste.org/65160
11:50:16 <kallisti> I have an error info record that contains a Bytestring representing a base64 encoded PNG image. having the string flood my terminal during debugging is problematic, so I'd like to customize the Show instance to abridge that field.
11:50:19 <jay7557> sorry shergill
11:50:20 <scooty-puff-sr> the title pretty much says it - is it possible to convert the class HasLocPred, which uses fundeps, to a type family?
11:50:28 <scooty-puff-sr> i tried the naive conversion
11:50:29 <kallisti> just looking for a slightly less painful way to write the Show instance than by hand.
11:50:34 <jay7557> but how do i send messages to specific person?
11:50:35 <shergill> jay7557: nw
11:50:39 <kallisti> jay7557: like this
11:50:45 <scooty-puff-sr> but could not sort out how to change class (result ~ Prelude.False) => ... to a type family
11:50:48 <kallisti> or do you mean, in private?
11:50:53 <jay7557> like this
11:51:10 <kallisti> jay7557: most IRC clients have a way to tab-complete names. so I just type ta<TAB>
11:51:11 <jay7557> it comes in red letters when u text me something and bleeps
11:51:13 <kallisti> to ping you
11:51:27 <kallisti> er ja<TAB
11:51:29 <kallisti> <
11:51:30 <kallisti> ...
11:51:31 <kallisti> >
11:51:34 <kallisti> lol
11:51:51 <kallisti> jay7557: yes I would turn the system beep off.
11:52:19 <jay7557> kallisti: oh yh it worked
11:52:23 <jay7557> thanks
11:52:28 <jay7557> learned something new today
11:52:30 <jay7557> :D
11:52:31 <kallisti> yep.
11:52:39 <kallisti> other styles include using a , instead of a :
11:53:00 <kallisti> you can configure that. most clients just highlight when they see your name at all, or at least at the beginning of a message.
11:53:01 <Twey> 3/sb end
11:53:06 <Twey> Oops >.>
11:53:07 <kallisti> I have mine configured to highlight whenever my name is mentioned at all.
11:53:08 <jay7557> Wow
11:53:13 <jay7557> this is powerful!!
11:53:27 <kallisti> jay7557: heh. if you say so.
11:53:55 <jay7557> kallisti: it truly is
11:54:16 <jay7557> and lambdabot is robot ?
11:54:20 <jay7557> is it?
11:54:22 <kallisti> if you have a passionate interest in scuba diving, some clients allow you to specify custom phrases to highlight. So you could highlight "scuba diving"
11:54:29 <kallisti> jay7557: it's a program connected to IRC. if that's a robot, then yes.
11:54:52 <ForSpareParts> hey guys, I'm working on a forth interpreter for class and I can't figure out why two cases are exhibiting different behavior, anyone have any ideas? It's at http://hpaste.org/65161
11:55:12 <jay7557> Okay, I thot it was some nerd typing really quick everytime
11:55:14 <jay7557> lol
11:55:16 <kallisti> ForSpareParts: which cases in particular.
11:55:21 <ForSpareParts> "." is supposed to pop something and ".S" is supposed to print the whole stack, but I was having trouble with that so I just copied what "." did for a start, for troubleshooting
11:55:36 <ForSpareParts> so when I do ".", it pops as I would expect
11:55:48 <ForSpareParts> but when I do ".S" it corrupts the stack in WEIRD ways
11:56:00 <ForSpareParts> like, [3, 4, 5] becomes [1, 3]
11:56:33 <hpaste> jay7557 pasted “error1” at http://hpaste.org/65162
11:56:53 <jay7557> anybody knows what is wrong in this script?
11:57:21 <osager> hi all how toupdate cabal packages ? cabal update only updates the list
11:57:27 <kallisti> ForSpareParts: huh, really?
11:57:37 <ForSpareParts> yeah. fucking weird, right?
11:57:40 <kallisti> ForSpareParts: also, I highly recommend using pattern matching instead of head/tail
11:57:46 <dcoutts_> osager: cabal install $thepkg
11:57:51 <kallisti> also print = putStrLn . show
11:58:00 <kallisti> so you can just say  print (head istack)
11:58:08 <osager> thanks dcoutts, but what about for all packages ?
11:58:36 <dcoutts_> osager: you don't want to do that, core packages should not be upgraded
11:58:40 <geekosaur> not presently supported because some packages can't be safely updated
11:58:50 <MagneticDuck> jay7557: You can't find the words of a list of strings!
11:58:51 <osager> ok
11:58:54 <osager> thanks
11:59:07 <henux> ah fuck this, its impossible to build hsSDL on Win7 without tons of effort
11:59:09 <dcoutts_> geekosaur: there is actually a flag for it, but I'm not going to say what it is, it's just rope to hang yourself with :-)
11:59:21 <kallisti> ForSpareParts: what's the operator after .S ?
11:59:26 <ForSpareParts> kallisti: thanks. how would I use pattern matching inside of a case thing like this? The code was part of a skeleton that my professor gave me, so I only sort of understand what it's doing...
11:59:39 <kallisti> ForSpareParts: basically instead of the argument words
11:59:41 <kallisti> you would have
11:59:42 <jay7557> MagneticDuck: how can i do it?
11:59:45 <kallisti> (x:xs)
11:59:50 <geekosaur> dcoutts_, I know.  I still want the secret flag that will allow you to upgrade a bootlib at all...
11:59:53 <kallisti> eval (x:xs) (istack, cstack, dict) =
11:59:55 <jay7557> cons
11:59:56 <MagneticDuck> jay7557: depends what you want to do
12:00:05 <ForSpareParts> oh, ok
12:00:07 <geekosaur> (or more to the point, complete refusal to update a bootlib *without* such)
12:00:15 <kallisti> ForSpareParts: then x is equivalent to head words, and xs is equivalent to tail words
12:00:16 <jay7557> right now i just want to print every word
12:00:24 <ForSpareParts> thanks!
12:00:28 <MagneticDuck> In that case, words xs
12:00:30 <dcoutts_> geekosaur: right, it's too easy, not too hard :-)
12:00:46 <ForSpareParts> after .S is supposed to be . which pops and prints the top of the stack
12:01:00 <ForSpareParts> that's code I got from the skeleton file, and it seems to work
12:01:09 <jay7557> MagneticDuck: yh but if it's sentence with '\n'?
12:01:22 <kallisti> ForSpareParts: are you sure that your parser is working correctly?
12:01:23 <jay7557> MagneticDuck: would it still work?
12:01:54 <jay7557> a = lines xs
12:01:59 <jay7557> a' = words a
12:02:05 <MagneticDuck> Nope
12:02:07 <jay7557> is that valid syntax?
12:02:09 <ForSpareParts> kallisti: Not entirely, no. But unfortunately, I'm still so green at the Haskell stuff that it's largely over my head...
12:02:20 <jay7557> MagneticDuck: hmm..
12:02:26 <ForSpareParts> I *think* all it's doing is breaking the text input into words
12:02:27 <MagneticDuck> > @type words
12:02:28 <lambdabot>   <no location info>: parse error on input `@'
12:02:34 <MagneticDuck> > @t words
12:02:35 <lambdabot>   <no location info>: parse error on input `@'
12:02:36 <ForSpareParts> and recursively calling eval on each word
12:02:51 * hackagebot fb 0.7.5 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.7.5 (FelipeLessa)
12:02:56 <MagneticDuck> jay7557: map words a
12:03:05 <kallisti> ForSpareParts: if you have two operations that are supposed to run the exact same code but are having different behaviors, I would say the parser is suspect.
12:03:06 <otters> where's some parsec documentation
12:03:09 <jay7557> MagneticDuck: oh yh !
12:03:12 <ForSpareParts> alright.
12:03:13 <jay7557> let me try!
12:03:18 <ForSpareParts> I will look into that.
12:03:29 <otters> the one on the website was published in 2001
12:03:34 <kallisti> I could help you if I had the rest of the code.
12:04:03 <jay7557> MagneticDuck: Hurray sorted
12:04:06 <jay7557> :D:D
12:05:08 <MagneticDuck> welcome
12:05:24 <MagneticDuck> BTW, was it you who asked how to replace a pattern in a string?
12:05:46 <jay7557> MagneticDuck: If I was to replace certain words in text file and replace them with asterisk(*) how would I do that?
12:06:15 <MagneticDuck> By writing a find-replace function.
12:06:23 <MagneticDuck> But you asked me that question before, right?
12:06:29 <kallisti> some things that might be useful to you are isPrefixOf
12:06:35 <jay7557> MagneticDuck: cat textfile.txt | ./asterisk apple banana
12:06:35 <lispy> hello good citizens of #haskell!
12:06:44 <MagneticDuck> jay7557: I might be mixing you up with another person
12:06:47 <kallisti> > "the" `isPrefixOf` "the cat"
12:06:48 <lambdabot>   True
12:06:57 <jay7557> yh
12:07:05 <MagneticDuck> Okay, sorry I never wrote the email!
12:07:08 <lispy> > "pizza" `isInfixOf` "I like pizza!!"
12:07:09 <lambdabot>   True
12:07:16 <MagneticDuck> I missed your address!
12:07:27 <MagneticDuck> Anyway, I pasted my code a long time ago... on hpaste.org
12:07:30 <jay7557> may be someone is also stucked on same problem
12:07:32 <MagneticDuck> Let me see if I can find it...
12:07:32 <jay7557> lol
12:07:42 <lispy> hpaste knows all
12:07:53 <jay7557> ok
12:08:06 <MagneticDuck> Hm, I can't seem to search...
12:08:31 <ForSpareParts> kallisti: I got it!
12:08:44 <kallisti> cool
12:08:45 <hpaste> MagneticDuck pasted “Find 'n replace” at http://hpaste.org/65165
12:08:50 <MagneticDuck> There we go
12:08:59 <ForSpareParts> In an earlier attempt to make a go of .S, I put it in the dictionary that has most of the standard language actions
12:09:06 <ForSpareParts> with an arbitrary behavior
12:09:14 <kallisti> aha
12:09:18 <lispy> .S?
12:09:29 <ForSpareParts> command for the forth interpreter I'm working on
12:09:32 <lispy> ah
12:09:40 <ForSpareParts> supposed to print the whole stack without consuming anything
12:09:42 <lispy> I was thinking maybe you meant asm++
12:09:58 <ForSpareParts> I... actually don't know what that is?
12:10:07 <lispy> (c is .c; asm is .s; c++ is .C; so asm++ would be .S, right?)
12:10:11 <jay7557> MagneticDuck: cool
12:10:13 <kallisti> ForSpareParts: this might be too advanced for you, but you could use a StateT ForthState IO stack to handle implicit state through your interpreter.
12:10:17 <sipa> Object-oriented assembly? That would be .net?
12:10:25 <kallisti> ForSpareParts: then write functions to push/pop from the stack, lookup names, etc.
12:10:34 <jay7557> MagneticDuck: Can i import your module?
12:10:40 <MagneticDuck> jay7557: It's a bit messy... but I hope I made ti easy enough to understand!
12:10:42 <MagneticDuck> Yes, you can
12:10:54 <MagneticDuck> findNReplace is the main function
12:10:55 <jay7557> MagneticDuck: thanks
12:11:01 <MagneticDuck> welcome as always
12:11:19 <MagneticDuck> Sorry, I'm going inactive now... got tests coming up and have to study! See you around!
12:11:25 <ForSpareParts> kallisti: Yeah, I think that'd be a bit beyond me at this point... We actually haven't covered state in class yet, and I have to finish this by tonight.
12:11:49 <kallisti> ForSpareParts: well what you're doing is equivalent to what I suggested, just a bit more wordy and less readable.
12:11:57 <ForSpareParts> ah.
12:12:35 <kallisti> it would be good to transition from this into monad transformer stacks I think.
12:12:42 <kallisti> rewrite the code using monad transformers
12:13:29 <kallisti> ForSpareParts: what is cstack?
12:15:10 <kallisti> ForSpareParts: oh, another thing. those do blocks can be rewritten without ; and { }
12:15:28 <kallisti> using layout syntax. a newline represents a ;, and indentation is used in place of curly brackets.
12:16:24 <jay7557>  MagneticDuck I can display getContents
12:16:45 <jay7557> MagneticDuck: but the same syntax doesn't work for getArgs
12:16:59 <jay7557> gives me error
12:17:05 <kallisti> that's because they have different types
12:17:11 <ForSpareParts> kallisti: thanks, I'll fix that
12:17:16 <kallisti> getArgs is IO [String]  and getContents is IO String
12:17:39 <kallisti> ForSpareParts: I'll annotate your source actually
12:18:36 <jay7557> kallisti: How can I print it?
12:18:43 <jay7557> with show or print
12:18:58 <kallisti> oh nevermind, print should work fine with that.
12:19:06 * kallisti didn't actually look at any code. :P
12:19:57 <jay7557> ok
12:20:33 <hpaste> jay7557 pasted “error” at http://hpaste.org/65166
12:21:13 <hpaste> kallisti annotated “forth” with “forth (annotation)” at http://hpaste.org/65161#a65167
12:21:35 <kallisti> ForSpareParts: ^
12:21:40 <HugoDaniel> can i change the haskell reserved words to be something else ?
12:21:40 <lambdabot> HugoDaniel: You have 1 new message. '/msg lambdabot @messages' to read it.
12:21:44 <ForSpareParts> thx
12:21:59 <kallisti> ForSpareParts: are you familiar with how pattern matching works?
12:22:03 <kallisti> like, does that code make sense to you?
12:22:05 <HugoDaniel> like "import" to "load"
12:22:28 <ForSpareParts> the @ notation is new to me
12:22:31 <ChristianS> jay7557: just omit the  a = lines args , since args is already a list
12:22:32 <ForSpareParts> but other than that, I think I get it
12:22:40 <jay7557> ChristianS: thanks
12:22:48 <kallisti> ForSpareParts: it binds a name to the whole pattern.  istack@(s:ss)   istack refers to the entire argument, s is the first element, ss is the tail.
12:23:28 <ForSpareParts> so if the argument was [1, 2, 3] I'd use s for 1, ss for [2, 3] and istack for [1,2,3]?
12:23:31 <jay7557> ChristianS: cheers ChristianS
12:23:44 <kallisti> ForSpareParts: pattern matching is preferred to using head and tail because head and tail are partial functions. they're undefined on empty lists, and so they can become a source of runtime errors.
12:23:48 <kallisti> ForSpareParts: correct
12:24:00 <ForSpareParts> kallisti: sweet. that should be handy.
12:24:29 <kallisti> ForSpareParts: also I use it in the empty list case to shorten your code a bit. since you just match the ForthState and return it verbatim.
12:24:58 <wvoq> btw, what is the rationale for defining head and tail as partial functions rather than wrapping them in Maybe?
12:25:07 <kallisti> wvoq: good question.
12:25:26 <kallisti> the Prelude in general seems to love partial functions.
12:25:30 <HugoDaniel> i need to change the haskell reserved words, how can i do that ?
12:25:40 <applicative> a preprocessor
12:25:44 <HugoDaniel> hmm
12:25:47 <HugoDaniel> yes
12:25:48 <kallisti> perl.
12:25:49 <HugoDaniel> TH
12:25:49 <kallisti> :P
12:25:52 <rasfar> haskell-src-exts hackery?
12:25:53 <wvoq> I understand the tradeoffs, I just don't understand why head and tail are "naked" when so many other decisions like that are settled monadically
12:25:58 <kallisti> TH isn't likely to help much.
12:26:46 <kallisti> wvoq: I've sometimes wondered if defining a function that traps runtime errors and wraps them in a Maybe would violate referential transparency
12:26:54 <kallisti> by making distinctions between two different kinds of bottom.
12:27:14 <kallisti> the kind that doesn't terminate and the kind that throws IO exceptions.
12:27:37 <applicative> HugoDaniel, there is syntax for calling a preprocessor on your file.
12:28:18 <applicative> {-# OPTIONS_GHC -F -pgmF hugo #-}  for exampel
12:29:08 <HugoDaniel> nice :D
12:29:21 <HugoDaniel> can i change "OPTIONS_GHC" to be something else ?
12:29:35 <wvoq> kallisti: are you saying that I couldn't define my own monadic head and tail funcions without violating referential transparency?  I think I just need to catch the empty list, not any old runtime error
12:29:42 <ChristianS> wvoq: legacy, probably. also, suppose head and tail are older than the whole concepts of monads.
12:29:58 <kallisti> wvoq: no no. I mean writing a function to generalize an arbitrary partial function to a monadic function.
12:30:06 <wvoq> kallisti: oh, sure
12:30:34 <kallisti> specigically MonadPlus
12:30:38 <kallisti> ...*specifically
12:30:39 <ChristianS> wvoq: if you want a safe head, you can use Data.Maybe.listToMaybe . but there is on predefined safe tail i'm aware of.
12:31:21 <applicative> HugoDaniel: you're using somethign besides ghc?  I know hugs has a similar incantation, maybe you use it on the command line though
12:31:33 <HugoDaniel> hmm
12:31:55 <kallisti> I feel like something like that should be possible, but I believe it breaks Haskell semantics.
12:31:59 <HugoDaniel> applicative: if i could define what reserved word ghc must search for its options when compiling the files, would be great
12:32:02 <wvoq> ChristianS: true, it just seems out of step with the haskell Gestalt to use functions that you know might blow up at runtime in totally non-pathological circumstances
12:32:28 <HugoDaniel> like ghc --make Main.hs -S/GHC_OPTIONS/ROCK_N_ROLL
12:32:35 <HugoDaniel> or something like that :D
12:32:46 <kallisti> HugoDaniel: no satanism in my Haskell plz.
12:32:54 <HugoDaniel> :D
12:33:56 <jay7557> kallisti: Thanks for the help!
12:34:00 <jay7557> ChristianS: Thanks for the help!
12:34:42 <jay7557> am off, speak to you later!
12:34:45 <jay7557> :Q
12:35:01 <kallisti> I guess I should say: I feel like defining a function that converts an arbitrary partial function into a monadic function breaks Haskell semantics, but I'm not sure that it's in a noticeably dangerous way.
12:35:30 <bgamari> Is there really no way to filter nodes in fgl? There is an efilter function but I can't seem to find a corresponding nfilter
12:35:40 <bgamari> This library has some very strange quirks
12:36:01 <bgamari> As far as I can tell, there's no way to map over nodes and edges with both their labels and names
12:36:26 <parcs`> kallisti: are you talking about something like the spoon library
12:36:47 <kallisti> parcs`: I don't know. let me look up what it is.
12:36:52 <kallisti> oh. yes
12:37:05 <parcs`> the spoon library uses unsafePerformIO, so indeed it violates some semantics
12:37:15 <parcs`> i don't think you can implement it without unsafePerformIO
12:37:20 <kallisti> I agree.
12:37:22 <tazjin> Hey, a while ago I read a mathematical proof (I think it was on /r/haskell or StackOverflow) on why you can't prove function equality. Does anyone happen to have a link to that?
12:37:26 <kallisti> but, is it violating them in a bad way?
12:37:53 * hackagebot persistent-mysql 0.8.2 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-0.8.2 (FelipeLessa)
12:37:53 <kallisti> does that question even make sense?
12:38:35 <parcs`> in a bad way, not really
12:38:38 <parcs`> spoon is pretty useful
12:39:00 <conal> tazjin: one often *can* prove function equality. every universally quantified equation *is* equivalent to function equality.
12:39:54 <conal> tazjin: perhaps the discussion was about whether function equality is decidable in general. and the answer depends on the types involved.
12:40:01 <kallisti> parcs`: plus the maintainers email is pumpkingod@gmail.com, so you know it's legit.
12:40:17 <tazjin> conal: Yeah, I'm not really sure anymore, that's why I'm trying to find it
12:40:22 <kallisti> it's literally from pumpkin god Himself.
12:41:14 <conal> tazjin: there's a simple argument of reducing the halting problem to equality on (Nat -> Bool)
12:41:16 <Twey> kallisti: I think that's copumpkin's
12:41:32 <kallisti> aha
12:41:38 <kallisti> it all makes sense now.
12:42:44 * yaxu does a search and replace changing Double to Rational and solves all his problems
12:44:48 <kallisti> yaxu: what kind of program?
12:45:03 <ClaudiusMaximus> tazjin: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ perhaps?
12:45:10 <yaxu> kallisti: kind of a sound sequencer
12:45:25 <kallisti> > sin 5 :: Rational
12:45:26 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
12:45:26 <lambdabot>    arising from a us...
12:45:38 <yaxu> kallisti: described here http://yaxu.org/patterns-in-haskell-revisited/
12:45:54 <yaxu> > toRational $ sin 5
12:45:55 <lambdabot>   (-8637222012098867) % 9007199254740992
12:46:04 <kallisti> yaxu: cool. I've been wanting to work on DSP in Haskell for a while now. I might roll my own or contribute to an existing package.
12:46:08 <kallisti> but I don't know of any
12:46:31 <yaxu> kallisti: I'm doing the DSP in C
12:46:48 <kallisti> yaxu: :(
12:46:50 <yaxu> kallisti: there is some haskell DSP stuff mentioned on the haskell-art mailing list
12:47:01 <yaxu> let me see
12:47:05 <kallisti> FRP I think is a good model for signals
12:47:11 <kallisti> as it has both the discrete and continuous cases.
12:48:06 <DrSyzygy> yo yaxu
12:48:08 <DrSyzygy> congrats on the thesis
12:48:26 <DrSyzygy> waaaaait, there's a haskell-art mailing list?
12:48:31 <rasfar> HugoDaniel: there's the RULES pragma too, not sure if that could work
12:48:42 <DrSyzygy> yaxu: https://github.com/michiexile/poincare
12:48:59 <kallisti> yaxu: I think I'm less interested in Haskell for live performance and more interested in using Haskell to describe a composition.
12:49:16 <kallisti> (not in the traditional classical music sense)
12:49:48 <yaxu> hi DrSyzygy
12:49:56 <ClaudiusMaximus> DrSyzygy: oo, that link looks interesting to me - i did some stuff like that a while ago
12:50:00 <ClaudiusMaximus> hi yaxu
12:50:10 <yaxu> DrSyzygy: thanks
12:50:16 <yaxu> hi ClaudiusMaximus
12:50:24 <niteria> what was the code that generated all binary strings with mapM?
12:50:40 <niteria> @src mapM
12:50:40 <lambdabot> mapM f as = sequence (map f as)
12:50:49 <niteria> @sequence
12:50:49 <lambdabot> Unknown command, try @list
12:50:49 <kallisti> > (`replicateM` "01") =<< [0..]
12:50:50 <lambdabot>   ["","0","1","00","01","10","11","000","001","010","011","100","101","110","...
12:51:11 <yaxu> DrSyzygy: http://www.haskell.org/haskellwiki/Haskell_art
12:51:18 <kallisti> niteria: ^
12:51:48 <niteria> that's almost what I wanted, I forgot to say "of length n"
12:51:58 <yaxu> kallisti: Henning Thielemann is the main one looking at haskell DSP afaict, e.g. http://hackage.haskell.org/package/synthesizer-0.2.0.1
12:52:17 <niteria> > (`replicateM` "01") =<< [0..1]
12:52:17 <lambdabot>   ["","0","1"]
12:52:31 <niteria> > (`replicateM` "01") =<< [1..1]
12:52:32 <lambdabot>   ["0","1"]
12:52:34 <kallisti> > let binariesOfLen n = replicateM n "01" in binariesOfLen 3
12:52:35 <lambdabot>   ["000","001","010","011","100","101","110","111"]
12:52:36 <niteria> > (`replicateM` "01") =<< [3..3]
12:52:37 <lambdabot>   ["000","001","010","011","100","101","110","111"]
12:52:47 <Twey> niteria: [3 .. 3] = [3]
12:52:55 <kallisti> niteria: that's equivalent to just saying replicateM n "01"
12:53:03 <yaxu> kallisti: also see rohan drape's excellent bindings for the supercollider dsp server
12:53:11 <kallisti> oh nice.
12:53:22 <Twey> @let bins = flip replicateM "01"
12:53:23 <lambdabot>  Defined.
12:53:27 <Twey> > bins 4
12:53:28 <lambdabot>   ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","101...
12:53:31 <Twey> > bins 2
12:53:33 <lambdabot>   ["00","01","10","11"]
12:53:57 <niteria> @src replicateM
12:53:57 <lambdabot> replicateM n x = sequence (replicate n x)
12:54:05 <niteria> @src sequence
12:54:06 <lambdabot> sequence []     = return []
12:54:06 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:54:06 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
12:54:19 <kallisti> niteria: it's more instructive to look at the types.
12:54:21 <kallisti> :t sequence
12:54:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:55:36 <yaxu> the haskell art mailing list is v low traffic
12:56:02 <niteria> what I want to do is [[a ++ b ++ c ++ d ... , a <- as, b <- bs, ...] where list = [as, bs, cs]
12:57:03 <kallisti> > sequence ["123", "456"]
12:57:04 <lambdabot>   ["14","15","16","24","25","26","34","35","36"]
12:57:06 <kallisti> niteria: like that?
12:57:48 <niteria> yeah, just figured it out by myself :)
12:58:02 <kallisti> sequence on the list monad is a wonderful thing.
13:02:11 <tgeeky> kallisti: then applicative functors are ______?
13:04:55 <kallisti> tgeeky: monads? is this a pop quiz?
13:05:20 <kallisti> if I recall correctly there are some applicative functors that are not monads.
13:05:58 <kallisti> ZipList I believe is the standard example.
13:06:18 <conal> or liftA2 & pure
13:06:18 <danharaj> do bang patterns force WHNF or full evaluation?
13:06:36 <kallisti> WHNF
13:06:46 <tgeeky> kallisti: no, not a quiz. I was expecting an emotional answer. applicative grew out of observing sequence on the list monad, I think.
13:06:47 <danharaj> Is there a variant for full evaluation? I have time leaks.
13:06:48 <kallisti> see DeepSeq for full evaluation
13:08:03 <kallisti> danharaj: time leaks? typically adding extra evaluation steps takes extra time.
13:08:35 <danharaj> kallisti: time leaks as in things that should be evaluated at one time are being suspended until a much later time.
13:09:07 <kallisti> ah, too much time at the wrong place.
13:09:42 <kallisti> tgeeky: hm. really? my guess would have been that it was a generalization of liftM.
13:09:57 <kallisti> and not specifically sequence on lists.
13:11:02 <kallisti> danharaj: http://hackage.haskell.org/packages/archive/deepseq/1.3.0.0/doc/html/Control-DeepSeq.html
13:11:09 <danharaj> yeah deepseq needs a typeclass :\
13:11:22 <kallisti> what structure are you operating on?
13:11:43 <danharaj> general data structures
13:11:52 <danharaj> I just want to tell GHC to force all thunks right then and there
13:12:06 <kallisti> danharaj: you can't really do that without knowing something about the structure.
13:12:09 <danharaj> and right then and there == when I run an IO action
13:13:48 <kallisti> I would need more information to give any more advice. Perhaps you're looking to force the value in the wrong place.
13:15:03 <kallisti> danharaj: by "general data structures" do you mean that you're doing with Data.Data?
13:15:29 <danharaj> kallisti: I mean I don't know anything in general about type. Let me reformulate my problem.
13:15:53 <kallisti> well, you need to know that it's an instance of NFData to use deepseq on it..
13:16:12 <danharaj> I'm not sure I want to deepseq things.
13:17:41 <danharaj> I have an FRP implementation. A frame of execution is run by walking through an FRP value (which is an arrow type) and executing an io action `step :: FRP a b -> a -> (b, FRP a b)`. In particular, I can execute the composition of two such values. However, unless the intermediate value is required that particular frame, it will accumulate a thunk until a time when it is actually needed.
13:18:44 <danharaj> I was hoping that I could modify the implementation of step to force these thunks. Otherwise I have to seq these intermediate values in the definitions of my FRP values.
13:19:29 <kallisti> danharaj: I suppose requiring that the data be NFData is unacceptable?
13:19:53 <danharaj> kallisti: It's possible. It would be a much better option if NFData worked on newtypes and had a deriving instance.
13:20:20 <kallisti> danharaj: well you can derive it on newtypes with GeneralizedNewtypeDerive
13:20:26 <danharaj> indeed.
13:21:16 <danharaj> I find it strange that GHC doesn't provide a way to say "force this thunk all the way". I guess my model of the GHC runtime doesn't correspond to reality.
13:24:30 <kallisti> danharaj: I'm actually kind of surprised that there isn't an instance of NFData for instances of Data. I suppose to avoid overlapping instances.
13:24:46 <danharaj> kallisti: what would qualify as an instance of Data?
13:25:10 <kallisti> any algebraic data type can be an instance of Data.
13:25:16 <kallisti> but not all are, of course.
13:25:26 <kallisti> http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Data-Data.html
13:25:58 <rostayob> kallisti: people have proposed instances of NFData using GHC.Generics for sure
13:26:04 <rostayob> not sure about Data
13:26:35 * kallisti isn't clear on the specific differences between GHC.Generics and Data.Data
13:26:43 <kallisti> they seem to have similar goals.
13:26:55 <rostayob> kallisti: yes, but they're very different. GHC.Generics is nicer.
13:27:26 <danharaj> ... this is going to sound silly but does return x :: IO a force x?
13:28:25 <rostayob> danharaj: the only things that "force" execution in haskell are pattern matches, "seq"  and strict data types
13:28:40 <kallisti> I'm not entirely sure. I know "IO is strict" but I don't know to what degree.
13:29:30 <rostayob> kallisti: return wouldn't "force" anything
13:29:32 <danharaj> rostayob: what about `case x of x -> ... `
13:29:35 <kallisti> danharaj: but yes, you would need to force "return x" to force x. :P
13:29:41 <niteria> can records have only one constructor?
13:29:47 <kallisti> rostayob: I think he meant is it strict in its argument. which is "yes" I believe.
13:29:50 <rostayob> danharaj: that doesn't do anythin
13:29:55 <rostayob> *anything
13:29:57 <kallisti> niteria: no they can have multiple constructors.
13:30:20 <niteria> can they have fields with same names?
13:30:22 <rostayob> danharaj: what do you need to do?
13:30:42 <kallisti> danharaj: matching a constructor forces it.   so case z of (x:xs) -> ...  forces the first cons of a list.
13:30:53 <kallisti> but matching a variable doesn't force anything.
13:30:56 <kallisti> niteria: no
13:31:04 <kallisti> field names unfortunately exist in the top level namespace.
13:31:15 <rostayob> niteria: records can have multiple constructors e.g. data Foo = Foo {blah :: Int} | Bar {baz :: String}
13:31:20 <danharaj> rostayob: prevent thunks from accumulating in an frp value by forcing them every frame of execution generically.
13:31:22 <rostayob> but I'm not sure if that's what you mean
13:31:33 <rostayob> danharaj: use NFData?
13:31:51 <niteria> so data Foo = Foo {blah :: Int} | Bar {blah :: Int, x :: Int} is illegal?
13:31:56 <danharaj> rostayob: I am not sure if I need to deepseq.
13:31:58 <kallisti> niteria: yep.
13:32:03 <byorgey> > mapAccumL f x [a,b,c]
13:32:04 <lambdabot>   No instance for (SimpleReflect.FromExpr (SimpleReflect.Expr, y))
13:32:05 <lambdabot>    arising...
13:32:29 <byorgey> > mapAccumL f x [a,b,c] :: (Expr, Expr)
13:32:30 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:32:30 <lambdabot>         against inferred ...
13:32:42 <rostayob> danharaj: seq will only evaluate to WHNF (e.g. will only force one constructor)
13:32:49 <kallisti> niteria: a common convention is to encode some extra information in the field name.  fBlah and bBlah for example.
13:33:22 <kallisti> it's certainly not ideal, but it works.
13:33:48 <ByronJohnson> Liskni_si: By the way, are you aware of http://www.haskell.org/haskellwiki/Package_versioning_policy ?  I was expecting the major API changes listed in the article when I upgraded from loch-th-1.0 to loch-th-2.0, but https://github.com/liskin/loch-th/commit/9dc745b73c1b7eaa61be44169b2f71806823bf12 seems to only constitute a change in D
13:33:49 <niteria> umm, ok
13:33:54 <danharaj> rostayob: I see.
13:34:12 <ByronJohnson> (Not a big deal, and there's not much that can do about it now anyway; I still think it's a really helpful library.)
13:34:15 <rostayob> danharaj: NFData will go all the way, but it's not "built in" as seq is
13:34:37 <danharaj> rostayob: why is it that deepseq isn't as 'built in'?
13:34:39 <rostayob> GHC could provide a facility like NFData automatically but it doesn't
13:34:44 <danharaj> I see.
13:34:58 <kallisti> niteria: defining a record field defines an accessor function with the same name. data Foo = Foo {blah :: Int};  here blah is a function from Foos to Ints.
13:35:21 <kallisti> niteria: elsewhere if you have some value of type Foo, named x, you can access its blah field by writing:  blah x
13:36:28 <Mee_> seem legit
13:36:38 <kallisti> okay.
13:36:42 * kallisti is totally legit.
13:36:44 <kallisti> there.
13:37:14 <Mee_> k
13:37:18 <rostayob> danharaj: i'm going, good luck :)
13:37:34 <Mee_> Adios
13:37:50 <rostayob> Mee_: adios
13:38:35 <kallisti> danharaj: for library writers a common tool for making it convenient for users to make their data structures instances of important typeclasses is to use template haskell to auto-declare instances.
13:38:41 <kallisti> and, more recently, GHC.Generics
13:39:40 <danharaj> kallisti: I might look at that if manually managing strictness becomes a pain.
13:40:11 <Mee_> Why even use this programming language
13:42:15 <kallisti> danharaj: http://hackage.haskell.org/packages/archive/aeson/0.6.0.0/doc/html/Data-Aeson.html#g:4  heres an example of how GHC.Generic works. for an example of template haskell, see Data.Aeson.TH
13:42:42 <danharaj> thanks.
13:42:52 <Twey> Mee_: http://www.haskell.org/haskellwiki/Introduction#Why_use_Haskell.3F
13:42:56 <kallisti> library users use DeriveGeneric and DefaultSignatures to allow them to automatically derive GHC.Generic, and then allow you to write a default instance for all Generics.
13:45:13 <kallisti> Mee_: if you google on the subject you'll find plenty of blog posts about why you should learn Haskell. Many of these authors are likely to have only been exposed to Haskell for a few weeks.
13:45:18 <kallisti> hope that helps. :P
13:45:46 <Mee_> yea just looking from google just kinda found this
13:47:23 <kallisti> Mee_: oh cool. well welcome.
13:48:25 <kallisti> if you're looking for a long list of all the benefits of pure functional programming and static typing, I don't have the time. :(
13:48:35 <otc> kallisti: That has been my experience as well.
13:48:44 <otc> I'm trying to figure out how to do some sort of simple code generator.
13:48:55 <kallisti> otc: for what?
13:49:15 <otc> Learning experience. I'm not at all set on any specific or practical language.
13:49:47 <kallisti> I mean, what do you mean by code generator. That describes a lot of different things with different goals.
13:49:57 <otc> Yeah I admit that was a bit vague
13:50:19 <otc> Something like FFTW (which was done in OCaml) but on a much simpler algorithm
13:50:21 <cemycc> how can I parse lambda calculus  ? any tips ? and after that to apply beta and alpha reduction
13:50:26 <otc> Code that writes code
13:50:51 <Mee_> Can I ask you what kind of projects you do with this language?
13:51:25 <kallisti> cemycc: the first thing you want to do is define a data structure that represents lambda calculus expressions. basically the abstract syntax tree. From there you can write either a simple parser by hand or use a parsing library such as parsec.
13:51:26 <otc> With Haskell? I just plowed through Learn You A Haskell in a few days
13:51:32 <otc> My first functional language
13:51:43 <kallisti> Mee_: I'm currently working on a client library for Selenium 2.
13:51:53 <kallisti> for a freelance project.
13:52:21 <forspareparts> is there any way that I can get the floor of a division operation as an Integer?
13:52:32 <kallisti> forspareparts: you mean, you want integer division?
13:52:35 <kallisti> use `div` instead of /
13:52:37 <kallisti> > 5 / 2
13:52:38 <lambdabot>   2.5
13:52:41 <kallisti> > 5 `div` 2
13:52:42 <lambdabot>   2
13:52:43 <forspareparts> ah, thanks
13:52:56 <kallisti> but otherwise you could use floor.
13:52:59 <Mee_> ok. looks like this is mostly is in these kind of freelance projects or what you do on your spare time
13:53:00 <kallisti> > floor (5 / 2)
13:53:01 <lambdabot>   2
13:53:41 <forspareparts> floor didn't work because it didn't produce an Integer
13:53:52 <forspareparts> and I need to shove the result into a list of type Integer
13:54:07 <kallisti> Mee_: I have no clue what that sentence means, but I've written some Haskell programs for fun as well. simply stupid things, BF interpreter, lambda calculus evaluator, I've written an interface to the plugin system of an IRC bot written in C that allowed me to write Haskell plugins for it, etc.
13:54:31 <nicmo> hello everybody!
13:54:34 <kallisti> @faq what do people use Haskell for?
13:54:35 <lambdabot> The answer is: Yes! Haskell can do that.
13:54:40 <cts> forspareparts: There are conversion functions like fromInteger.
13:55:04 <kallisti> forspareparts: `div` is your best choice.
13:55:10 <kallisti> :T floor
13:55:14 <kallisti> :t floor
13:55:15 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:55:21 <forspareparts> alright
13:55:21 <kallisti> also, it should return an Integer just fine
13:55:35 <kallisti> > floor 5.5 :: Integer
13:55:36 <lambdabot>   5
13:55:43 <kallisti> no type errors.
13:55:49 <kallisti> perhaps the error was from something else?
13:55:54 <forspareparts> could be, yeah
13:55:55 <nicmo> has anyone here seen GHC give a warning about "Exciting arity"?
13:56:08 <kallisti> ..no.
13:56:20 <alpounet> exciting?
13:56:23 <otc> That's an interesting name for a syntax error.
13:56:25 <forspareparts> `div` seems to work, though -- think I'm just gonna stick with that
13:56:28 <nicmo> yep
13:56:37 <nicmo> Exciting arity, followed by what seems to be GHC Core
13:56:47 <nicmo> compiles fine(ish)
13:57:03 <kallisti> forspareparts: yep, that's your best choice if you meant integer division rather than "real" division
13:57:07 <alpounet> ghc never told me it got excited :(
13:57:11 <nicmo> but the warning is probably there for a reason
13:57:26 <nicmo> I'd prefer a well behaved ghc :P
13:57:38 <kallisti> forspareparts: note that you can write any function as an infix operator by surrounding it with `
13:57:42 <kallisti> div is just a regular function
13:57:46 <kallisti> > div 5 2
13:57:47 <lambdabot>   2
13:57:52 <forspareparts> yep, I know. thanks, though.
13:57:58 <kallisti> kk.
13:58:01 <nicmo> I'm testing with ghc 7.4 (currently using 7.2) and if the problem persists, I'll add as a bug
14:06:30 <niteria> > concat $ map (\(x, d) -> map (\(y, p) -> ((x, y), p)) d) $ zip [0..] $ map (zip [0..]) $ map words $ lines "1 0\n1 1"
14:06:31 <lambdabot>   [((0,0),"1"),((0,1),"0"),((1,0),"1"),((1,1),"1")]
14:06:45 <niteria> is there an easier way to construct Data.Array?
14:07:42 <Mee_> Haven't really never even tried these functional languages. Dunno probably won't even give a try cause have so much do to with school and other languages (like php, c++, vb, delphi(but this one only for school), and of course some javascript, and some others)
14:09:42 <kallisti> Mee_: no rush
14:10:29 <snifi> What is your opinion of using all these unicode characters in code, like 2x3 instead of 2*3, or lessequal sign, etc?
14:10:55 <niteria> silly me
14:10:57 <niteria> > listArray ((0, 0), (1, 1)) $ concat $ map words $ lines "1 0\n1 1"
14:10:58 <lambdabot>   array ((0,0),(1,1)) [((0,0),"1"),((0,1),"0"),((1,0),"1"),((1,1),"1")]
14:10:59 <niteria> works
14:11:23 <kallisti> I think syntactic replacements of existing tokens is largely pointless. However, I think that utilizing Unicode for new syntax is interesting, and should be looked into. The primary setback is lack of good keyboard support for convenient programming.
14:11:38 <rwbarton> niteria, if you already know the dimensions, yeah
14:11:46 <rwbarton> then you don't even need (map words . lines), can just use words
14:11:49 <otc> Unicode snowman
14:12:09 <niteria> oh, I see
14:12:21 <kallisti> it would solve a lot of issues. It seems as though our ASCII syntax space is largely filling up. This makes syntactic fixes such as improved record syntax/semantics difficult to solve.
14:14:12 <kallisti> niteria: btw you can replace  a string of f $ g $ h $ x  with  f . g . h $ x
14:14:21 <kallisti> this is the "preferred" style, for whatever it's worth.
14:14:52 <kallisti> it does make code somewhat easier to refactor, and it looks nicer.
14:15:13 <dfletcher> heh let's redefine <- as http://www.jwz.org/blog/2012/02/unicode-character-pile-of-poo-u1f4a9/
14:15:45 <kallisti> we need virtual keyboards with tactile sensitivity.
14:15:59 <nicmo> alpounet: http://hackage.haskell.org/trac/ghc/ticket/5929 if you want to see GHC getting excited with you
14:16:05 <kallisti> so that when I open haskell-mode in emacs my keyboard automatically adjusts itself into a Haskell layout, with convenient Unicode symbols.
14:16:08 <nicmo> needs optimization on when building, though
14:18:27 <alpounet> nicmo, hah ok
14:18:30 <tazjin> Is there a channel for acid-state related questions?
14:18:43 <cemycc> someone can explain me what arguments I need to write for this function : http://codepad.org/eqfUWbtP ?
14:19:06 <kallisti> cemycc: what do you mean by arguments
14:19:17 <alpounet> tazjin, people in #happs will be able to help for sure
14:19:41 <tazjin> alpounet: Alright
14:19:44 <kallisti> cemycc: you have all the different cases.
14:20:09 <cemycc> kallisti: I am trying to understand how to use that function with a lambda expresion
14:20:54 <rasfar> cemycc: there's a few problems with that code I think
14:21:47 <rasfar> eval m*n would return a number, not an Un
14:21:57 <kallisti> rasfar: so the where clause
14:22:00 <kallisti> *see
14:22:12 <kallisti> it's a bit confusingly written
14:22:32 <kallisti> but * is redefined here
14:22:39 <rasfar> and I think you need eval (m*n) or eval $ m*n -- otherwise it's (eval m) * n
14:22:44 <rasfar> oh...
14:22:49 <rasfar> oh! i see
14:23:08 <niteria> kallisti: somehow I prefer $, it feels like reverse unix pipe :)
14:23:41 <rasfar> (does application bind more tightly than default-precedence infix operators? i actually do not remember)
14:23:41 <kallisti> niteria: . is better because it doesn't require application.
14:23:44 <hpc> you mean (.)?
14:23:46 <kallisti> f = some . chain . of . functions
14:23:54 <kallisti> rasfar: yes
14:24:04 <kallisti> default precedence is 9.
14:24:07 <kallisti> application is something like 10
14:24:14 <hpc> application binds tighter than everything except other syntax
14:24:18 <kallisti> record modification is something like 11.
14:25:01 <jmcarthur> yeah application does not bind tighter than record modification
14:25:20 <jmcarthur> foo bar { baz = bleh }   ==   foo (bar { baz = bleh })
14:25:28 <jmcarthur> kind of weird, to me
14:25:48 <rasfar> yeah, with . you can do point-free where $ wouldn't allow it, i just realised this some minutes ago
14:25:51 <kallisti> I find it to be the common case, so it's nice.
14:26:13 <kallisti> rasfar: which is very nice when passing functions to higher-order functions, such as map
14:26:26 <rasfar> i concur
14:26:55 <kallisti> cemycc: your questions are kind of confusingly worded so I don't know how to answer properly.
14:27:06 <kallisti> you might benefit from a different representation of Lam
14:27:43 <cemycc_> kallisti: I am trying to use that function with a lambda expresion but I don't know how to write it corectly
14:27:50 <kallisti> oh
14:28:24 <kallisti> well it's not entirely clear how it works...
14:28:30 <kallisti> it seems to recurse infinitely for things like variable terms.
14:28:50 <kallisti> I would have Var holding a String/Text name or a De Bruijn index.
14:29:18 <kallisti> App (Lam $ \x -> x) (Var "y")
14:30:11 <kallisti> the lambda evaluator I wrote has a syntax tree representation, with strings for variable terms, and then a De Bruijn form that uses De Bruijn indices for bound variables and String names for free variables.
14:30:36 <kallisti> so that I don't have to worry about alpha equivalence
14:31:53 <shachaf> When do you ever have to worry about alpha equivalence?
14:32:05 <kallisti> so parsing to interpreting goes something like:   parse into syntax tree -> convert syntax tree to De Bruijn form -> beta reduce infinitely until it's fully reduced -> convert back into human readable string
14:32:30 <newhaskeller> Help, I changed my user password and made a typo
14:32:38 <newhaskeller> i am still logged in but once i log out
14:32:45 <newhaskeller> i wont be able to access my files
14:32:46 <kallisti> newhaskeller: password for what exactly?
14:32:58 <kallisti> shachaf: ...?
14:33:01 <newhaskeller> kallisti,  user, i am also sudo
14:33:13 <kallisti> can you log in as root?
14:33:21 <newhaskeller> how do i do that?
14:33:26 <newhaskeller> sudo, you mean?
14:33:27 <kallisti> er... what distro.
14:33:30 <cemycc_> kallisti, I think you need to use alpha reduce before beta reduce, right ?
14:33:30 <newhaskeller> lucid
14:33:35 <newhaskeller> kallisti, lucid
14:33:59 <shachaf> kallisti: Are you ever checking if two functions are alpha-equivalent?
14:34:16 <kallisti> shachaf: er, no.
14:34:20 <kallisti> I meant worrying about alpha conversion
14:34:23 <dolio> shachaf: You don't need to worry about alpha equivalence unless you're doing dependent types or some other equations on lambda terms. But you have to worry about alpha conversion to prevent variable capture.
14:34:38 <kallisti> newhaskeller: I mean... logging into the user named root
14:34:47 <kallisti> which is kind of what sudo does, but sudo uses your user password to accomplish this
14:35:16 <shachaf> Ah.
14:35:47 <Azel> kallisti: I believe Ubuntu doesn't have a root password in its default config...which means the only mean to become root is sudo (well, more exactly "sudo su)
14:36:00 <kallisti> Azel: ah I see.
14:36:07 <shachaf> Hmm, why isn't implementing shadowing enough?
14:36:33 <shachaf> Oh, I see.
14:36:36 <kallisti> shachaf: because I find De Bruijn indices easier to understand. :P
14:36:45 <kallisti> so I did that.
14:36:47 <Twey> shachaf: sudo offers the additional advantage that you can remove root access from one user without having to issue a new root password to all users
14:36:54 <Twey> Er
14:37:00 <Twey> Wrong definition of ‘shadowing’, please ignore :þ
14:37:02 <ion> s/sudo su/sudo -i/
14:37:07 <Azel> newhaskeller: try to do "sudo passwd <your user name>" and pray that your system has cached that you won't have to input your new password ?
14:37:44 <kallisti> cemycc_: I think you typically alpha convert /while/ you're beta reducing
14:37:53 <kallisti> not before.
14:37:57 * hackagebot BiobaseVienna 0.2.2.3 - Import Vienna energy parameters  http://hackage.haskell.org/package/BiobaseVienna-0.2.2.3 (ChristianHoener)
14:37:58 <ion> newhaskeller: Select rescue mode from the GRUB menu and you’ll get a root shell. Run passwd username in it.
14:38:42 <kallisti> cemycc_: but I don't know. alpha conversion scared me so I just used De Bruijn indices because they make way more sense.
14:38:44 <Azel> ion: Forgot that possibility...I must not be totally awake...
14:39:46 <shachaf> Actually, maybe I don't see.
14:39:56 <kallisti> cemycc_: De Bruijn indices also have other nice propeties. structural equality on your LC representation is the same as alpha equivalence.
14:40:05 <kallisti> ...er
14:40:06 <shachaf> What's an example of an expression where alpha conversion is necessary?
14:40:36 <kallisti> I guess shadowing would be sufficient, if you have a shadowing mechanism... I'm not clear on what that would look like that.
14:40:40 <cemycc_> I will need to read more about De Bruijin indices
14:40:44 <shachaf> Oh, never mind.
14:40:46 <dolio> shachaf: \x -> (\f x -> f) (\y -> x)  ~> \x -> (\x -> \y -> x)
14:40:52 <dolio> If you don't rename.
14:41:18 <shachaf> dolio: Right, I just came up with something similar.
14:41:19 <dolio> It should be \x -> (\z -> \y -> x)
14:41:21 <shachaf> Annoying.
14:42:14 <kallisti> cemycc_: you basically replace named variables in lambda expressions with a number indicating how far up the variable was defined.
14:42:14 <dolio> It's easy to screw up alpha renaming in subtle ways, too.
14:42:37 <dolio> I had an interpreter that used it, and when I went to implement something complicated it started showing variable capture issues.
14:42:48 <dolio> And I couldn't figure out where the problem was.
14:43:00 <dolio> So I switched to a different representation, and things just worked.
14:43:27 <kallisti> cemycc_: so 0 always refers to the most recently bound variable.  1 refers to variable bound by the next innermost lambda, and so on.
14:43:36 <Twey> (λx. (λy. f x y)) ⇒ (λ. λ. f 1 0)
14:44:20 <shachaf> dolio: Did you ever figure out the problem?
14:44:24 * Twey knew of this technique, and knew of De Bruijn indices, but never before realized the two were the same.
14:44:26 <dolio> No.
14:44:37 <dolio> And one of my interpreters probably still has it, because I didn't rewrite it.
14:45:03 <shachaf> Hmm. Do you have some code that demonstrates the problem?
14:45:28 <dolio> Not that you can easily tell what's going wrong.
14:45:55 <dolio> It was a paradox for a type system with too much impredicativity.
14:46:18 <kallisti> but I think with cemycc_'s representation of Lam as a function, there's no need for alpha conversion at all.
14:46:32 <kallisti> I'm just not sure how beta reduction works.
14:46:52 <dolio> It won't type check anyway in the interpreter that still has the variable capture problems, because it isn't that impredicative.
14:47:07 <dolio> And it isn't pluggable like the one I fixed.
14:47:59 <cemycc_> kallisti, Is not my code, I am trying to understand it and use it on simple examples
14:48:23 <kallisti> cemycc_: anyway, if you replace the constructor argument of Var with a String you should be able to actually write a representation
14:48:34 <kallisti> currently the structure is always infinite.
14:48:55 <dolio> shachaf: http://code.haskell.org/~dolio/pts/hurkens.pts
14:48:58 <dolio> That was the code.
14:49:05 <kallisti> I suppose you could do something like  var undefined but.....
14:49:07 <kallisti> *Var
14:49:29 <dolio> I think when the problem was still in there, that wouldn't work, but if you renamed things so that each definition used unique variable names, it would work.
14:51:17 <dolio> de Bruijn indices have their own problem, where you have to increment the 'free' levels in a term when you substitute under binders.
14:51:24 <dolio> Which is why locally nameless is pretty good.
14:51:31 <ezyang> HOAS for the win! :^)
14:51:43 <dolio> Yeah. HOAS has yet other problems.
14:51:49 <dolio> Take your pick.
14:52:59 <kallisti> http://sprunge.us/eZhT?haskell here's my lambda evaluator. I never actually tested it.
14:53:05 <kallisti> so you know it's legit.
14:54:27 <rostayob> I've got one as well! https://github.com/rostayob/lambda/blob/master/Lambda.hs
14:54:39 <kallisti> show and tell time, guys!
14:55:15 <kallisti> rostayob: yours is more robust and featureful. important in enterprise settings.
14:55:33 <dolio> Is it web scale?
14:55:36 <kallisti> it even handles errors gracefully!
14:55:41 <rostayob> yes.
14:56:05 <rostayob> today I also wrote an enterprise reasy type inference algorithm https://github.com/rostayob/ML-W/blob/master/TypeInfer.hs
14:56:15 <Liskni_si> ByronJohnson: yeah, I know about it, but I'm not sure if I did when I created the package (and anyway, I always thought the versioning policy is too robust for my little packages, but it starts to make sense when others expect some meaning in versions)
14:57:02 <kallisti> rostayob: hmm my reduce function is different.
14:57:13 <rostayob> kallisti: I have two reduce functions.
14:57:18 <rostayob> ah no
14:57:39 <rostayob> well I've got evaluation by name and by value
14:58:14 <kallisti> go c (Var x n) | n == j + c = shift c s
14:58:16 <kallisti> what's this line all about
14:58:49 <rostayob> kallisti: that's name to nameless conversion
14:58:57 <rostayob> or is it?
14:59:14 <rostayob> no it isn't.
14:59:20 <DanBurton> where do j and s come from
14:59:44 <rostayob> DanBurton: subst
15:00:01 <rostayob> kallisti: that makes sense
15:00:31 <rostayob> I'm keeping track of the depth
15:00:33 <rostayob> yeah
15:00:40 <rostayob> "I remember now"
15:01:34 <masylum> hi
15:01:42 <`Jake`> hi
15:01:57 <masylum> I have a doubt regarding data types and constructors
15:02:04 <rostayob> masylum: you're in the right place
15:02:13 <masylum> is there any way to enumerate the possible constructor for a given data type?
15:02:57 <hpaste> masylum pasted “data types enumeration” at http://hpaste.org/65172
15:02:58 * hackagebot Omega 1.0 - Operations on Presburger arithmetic formulae  http://hackage.haskell.org/package/Omega-1.0 (ChristopherRodrigues)
15:04:21 <alpounet> masylum, make it derive the Enum typeclass
15:05:22 <masylum> ok
15:05:26 <masylum> oh!
15:05:28 <masylum> true
15:05:36 <masylum> thanks!
15:07:05 <kallisti> masylum: there are mo general ways to do that for arbitrary data types, as well.
15:07:09 <kallisti> yes, mo'
15:07:37 <masylum> what do you mean?
15:07:38 <kallisti> from Data.Data and GHC.Generic
15:07:43 <masylum> let me check
15:07:44 <kallisti> er, I'm talking about something different
15:07:46 <kallisti> don't mind me.
15:07:48 <masylum> ok
15:07:51 <kallisti> lol
15:08:15 <alpounet> kallisti, yeah at first i thought masylum wanted something that'd work over any data type too
15:19:28 <lukish>   where
15:19:28 <lukish>     go [] = error "serverIP undefined"
15:19:28 <lukish>     go ((ServerIP s):_) = return s
15:19:28 <lukish>     go (_:xs) = go xs
15:19:43 <lukish> Why did ghc says
15:19:44 <lukish>     Warning: Pattern match(es) are overlapped
15:19:44 <lukish>              In an equation for `go': go (_ : xs) = ...
15:20:16 <kallisti> lukish: need more info
15:20:19 <kallisti> on the specific patterns
15:20:24 <kallisti> oh
15:20:27 * kallisti can't read.
15:20:54 <kallisti> lukish: it's just saying that the first and second cases have some elements that match both.
15:21:04 <lukish> Ok
15:21:07 <kallisti> they should check in sequential order, however, if I'm not mistaken.
15:21:15 <Saizan> yes
15:21:37 <lukish> I have some [Flag] , where Flag = ServerIP String | ...
15:21:52 <lukish> How can I get (ServerIP x) value from it?
15:21:57 <ion> ServerIP "v6"?
15:22:17 <lukish> "v666"
15:22:30 <Saizan> yours is a fine way
15:23:08 <Saizan> except for the return
15:23:22 <lukish> Saizan: except for the pattern matching cases
15:23:54 <Saizan> lukish: warnings are not errors because there are cases where it's fine to trigger them
15:25:04 <lukish> But how can I avoid it?
15:25:20 <Saizan> case [ s | ServerIP s <- xs] of [] -> error "serverIP undefined"; (s:_) -> s
15:25:31 <Saizan> that's another way with list comprehensions
15:25:54 <ion> Eww @ errors
15:26:02 <ion> listToMaybe [ s | ServerIP s <- xs ]
15:26:28 <Saizan> or, you could merge the second and third case of go into "go (x:xs) = case x of ServerIP s -> s; _ -> go xs"
15:27:14 <Saizan> but i think the one with overlapped patterns is better style
15:30:31 <lukish> serverFromArgs xs = case [ s | ServerIP s ← xs ] of ...
15:30:41 <lukish> Can I suppress that xs?
15:30:53 <lukish> Just interesting
15:31:13 <zmoazeni> Hey guys, I'm new to haskell and trying to work with cabal to install a couple dependencies. Right now I'm trying to try out snap, and I end up getting something like this for the snap-server. I'm not sure if it's something on my side that I can quickly fix or something wrong with the way they packaged snap. (I suspect the former) https://gist.github.com/384351f0077234d29c8e
15:32:16 <Saizan> lukish: nope
15:32:32 <zmoazeni> I stupidly closed my laptop while it was still installing, and I'm wondering if there may be cruft somewhere on the filesystem that it is trying to reuse. I tried the "cabal install --reinstall …" option, with the same result.
15:33:16 <rostayob> zmoazeni: mh, check in .cabal/packages/
15:33:25 <rostayob> delete the tarballs related to snap-server
15:33:36 <kosmikus> zmoazeni: look in ~/.cabal/packages/hackage.haskell.org/snap-server/
15:33:50 <hpaste> rasfar annotated “data types enumeration” with “data types enumeration (annotation)” at http://hpaste.org/65172#a65175
15:33:50 <zmoazeni> Ah yeah, I see it. It it most likely just a corrupted .tar.gz. Thanks!
15:34:33 <zmoazeni> Yup, that was it. Thanks!
15:40:24 <zmoazeni> On a related note, I wanted to experiment with http://hackage.haskell.org/package/scotty and I'm having an issue installing bytestring-lexing-0.4.0 due to "cabal: The program alex version >=2.3 is required but it could not be found.". However installing "cabal install alex" seems to work, though it seems to install a binary in ~/.cabal/bin/ rather than being listed in "cabal list --installed". Is there something special about that lib
15:40:24 <zmoazeni> that rings a bell for anyone?
15:41:38 <Peaker> zmoazeni: you need ~/.cabal/bin in your $PATH
15:41:49 <zmoazeni> Oh I see
15:41:58 <Peaker> zmoazeni: I think cabal-install does not track installed executables, just libraries
15:42:51 <zmoazeni> hrm
15:43:53 <zmoazeni> I just added it to my path with no change. I'll play with that a bit. I wonder if perhaps I should try installing a previous version too instead of the latest (3.0.1) http://hackage.haskell.org/package/alex - thanks though
15:44:24 <dcoutts_> zmoazeni: if it's a version problem it'll say so
15:44:57 <dcoutts_> zmoazeni: if alex is actually on the $PATH then cabal will find it
15:45:59 * dcoutts_ notes that if doing cabal build, a configure is required first, to have it look again
15:47:00 <Saizan> zmoazeni: does your $PATH happens to have a literal ~ ?
15:47:11 <zmoazeni> It does, I'll try expanding it
15:47:30 <Saizan> or use $HOME
15:47:43 <Safyia> hi, I have a problem with && operator. When I pass the argument in code as some variable 'x' it results in true, but when I write an expresion in winhugs with the exact String it results in false
15:47:44 <kallisti> it should matter I don't think
15:47:45 <zmoazeni> That was it.
15:47:51 <kallisti> ~ should be equivalent as far as I know.
15:48:03 <zmoazeni> It didn't like my ~/.cabal/bin. Using the expanded path worked out.
15:48:23 <zmoazeni> Thanks for your help fellas. Noob issues, I know, but a pain to work out solo.
15:48:31 <kallisti> zmoazeni: did you get it working?
15:48:37 <dcoutts_> the shell doesn't always expand ~ when used in command line params
15:48:42 <kallisti> you probably just needed to do source .profile or something
15:48:49 <Safyia> False is right, cause its true && false && false
15:48:51 <kallisti> dcoutts_: it doesn't? it does in bash..
15:49:16 <dcoutts_> $ echo --foo=~/bar
15:49:17 <dcoutts_> --foo=~/bar
15:49:30 <kallisti> zmoazeni: changes to your .profile don't take effect until you either run a new login or run "source .profile"  btw
15:49:34 <kallisti> not sure if you knew this or not.
15:49:39 <zmoazeni> I'm on OSX lion using ghc and cabal installed from homebrew. I'm using bash and have $HOME set. It didn't like "export PATH=$PATH:~/.cabal/bin"
15:49:46 <zmoazeni> Yeah
15:49:52 <dcoutts_> kallisti: and yet echo foo=~bar is expanded, odd.
15:50:10 <kallisti> hm
15:50:16 <zmoazeni> But dcoutts_ 's suggestion worked
15:50:20 <zmoazeni> I'm not complaining :)
15:50:30 <td123> dcoutts_: if you want expansion use $HOME
15:51:48 <dcoutts_> td123: sure, I know how to make it work, but helping other people figure out what's wrong is harder :-)
15:51:55 <geekosaur> bash tends to expand ~ only at the start of a word, not after = or :.  (and it is a shell expansion, not something the system understands; the system can't get at user environment)
16:02:19 <kallisti> remind me again how you use shows to concat a bunch of strings together...
16:03:04 <kallisti> is it... function composition?
16:03:19 <shachaf> Just look at the type.
16:03:53 <kallisti> I mean, I know the type.
16:04:03 <kallisti> I'm just dumb.
16:04:05 <kallisti> you see.
16:04:12 <shachaf> > shows 1 "hi"
16:04:13 <lambdabot>   "1hi"
16:04:22 <kallisti> > shows 1 . shows 2 . shows 3 $ ""
16:04:24 <lambdabot>   "123"
16:04:26 <kallisti> yes
16:04:52 <hpc> > join (words "oh hi there...    this should have all the spaces removed")
16:04:53 <lambdabot>   "ohhithere...thisshouldhaveallthespacesremoved"
16:04:57 <hpc> use join
16:05:08 <hpc> :t join -- (or, concat)
16:05:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:05:12 <hpc> :t concat
16:05:13 <lambdabot> forall a. [[a]] -> [a]
16:05:17 <kallisti> hpc: yes, yes.
16:05:25 <hpc> ;)
16:05:43 <rostayob> now somebody is going to say how join makes "so much more sense" than >>=.
16:06:03 <kallisti> zzo isn't here.
16:06:18 <kallisti> but man, it sure does make a lot of sense.
16:07:26 * kallisti considers how he could modify lambdabot to allow arbitrary top level declarations, except imports.
16:07:39 <kallisti> and a way to remove them individually
16:08:28 <geekosaur> might take a look at how ghci 7.4.1 does it?
16:08:49 <kallisti> you can add instance declarations in a ghci session?
16:08:57 <kallisti> oh 7.4
16:08:58 <rostayob> kallisti: yes
16:09:05 <kallisti> cool
16:09:14 <rostayob> you can add data decl for sure. not sure about instances.
16:09:45 * kallisti wishes ghci let wasn't so confusing for newbies.
16:10:43 <kallisti> I can't even imagine how confused someone could get if ghci simply let you top-level declarations
16:10:55 <kallisti> "help! I tried to define an instance inside this function and it's giving errors!"
16:11:08 <geekosaur> bunch of changes along those lines in 7.4, yeh.  (also not sure about instances in ghci but it might be possible to just use the same mechanism)
16:11:46 <kallisti> well my idea was to basically construct a large file with all the declarations from a lambdabot structure of some kind.
16:12:08 <Jafet> Newbies are let down by the number of bloggers implying that ghci is a Haskell interpreter
16:12:13 <kallisti> when someone tries to add a declaration, it constructs the file and runs it through GHC, if GHC complains, then it rejects the change.
16:12:39 <Jafet> The Haskell interpreter is actually runghc.
16:12:54 <kallisti> *the* Haskell interpreter.
16:12:55 <kallisti> :P
16:13:02 <alpounet> so there is no standard function for copying directories
16:13:21 <Jafet> There is no standard definition for copying directories
16:13:33 <alpounet> by standard i meant in HP
16:14:41 <Jafet> By standard I mean a method that is widely agreed upon.
16:15:22 <hpaste> DoctorSmaug pasted “Round if int” at http://hpaste.org/65176
16:15:32 <DoctorSmaug> I'm trying to write a function that rounds a Double to an int if it has no fractional part, but the only solution I can come up with has an Either return type.  Is there any way I can have it just return a single type?
16:15:40 <Jafet> I expect that a generally useful function for copying directories would need to have as many parameters as cp(1) has options.
16:16:16 <Jafet> DoctorSmaug: and what would that type be?
16:16:28 <DoctorSmaug> well that's the problem
16:16:30 <kallisti> http://search.cpan.org/~dmuey/File-Copy-Recursive-0.38/Recursive.pm
16:16:34 <DoctorSmaug> either a double, or an int...
16:16:36 <kallisti> just install this and then run perl.
16:16:41 <kallisti> what's the problem?
16:16:42 <Jafet> There you go. Either Double Int.
16:17:08 <kallisti> DoctorSmaug: you could also have it return a Double
16:17:14 <DoctorSmaug> Yes, I know, that's what I have, but is there any return type which supports both?
16:17:16 <kallisti> just convert the integer back to Double after rounding
16:17:22 <DoctorSmaug> probably a stupid question
16:17:37 <DoctorSmaug> I don't want the trailing zero if it's an int
16:17:46 <Jafet> Either Double Int supports both Double and Int.
16:18:04 <DoctorSmaug> Yeah I know, but I have to have case statements all over the place if I use Either
16:18:11 <kallisti> DoctorSmaug: the trailing zero is only relevant when displaying results. you can fix that problem when needed.
16:18:19 <DoctorSmaug> how?
16:18:34 <kallisti> hm, one way would be to make a newtype and define your own show instance
16:18:40 <Jafet> Naturally. You have two different types, and need to treat them differently.
16:18:43 <kallisti> but use GeneralizedNewtypeDeriving to get all the Double instances.
16:18:49 <kallisti> except Show.
16:18:50 <kallisti> or something
16:18:51 <kallisti> kind of a hack.
16:19:16 <Jafet> He didn't say anything about showing numbers.
16:19:21 <kallisti> if the ONLY reason you don't want to do that is to avoid the trailing zero
16:19:26 <DoctorSmaug> I'll give a bit more context - I'm trying to display the number using as few characters as possible.  So 12.0 becomes 12
16:19:32 <Jafet> Okay, now he did
16:19:37 <kallisti> 19:17 < DoctorSmaug> I don't want the trailing zero if  it's an int
16:20:31 <kallisti> DoctorSmaug: right, but otherwise you want the result to act like a Double?
16:20:36 <DanBurton> sounds like a job for a typeclass
16:20:38 <DoctorSmaug> exactly
16:20:42 <kallisti> either that
16:20:44 <DanBurton> instance IntOrDouble Int where
16:20:45 <Jafet> > 0.3
16:20:45 <kallisti> or a number formatting library.
16:20:45 <lambdabot>   0.3
16:20:48 <DanBurton> foo = round
16:20:50 <Jafet> > 0.1 + 0.2
16:20:50 <lambdabot>   0.30000000000000004
16:20:59 <kallisti> a formatting library would make things easier. but I don't know of one.
16:21:45 <kallisti> google suggests Text.Printf
16:21:58 <DoctorSmaug> Yes, I had thought of that
16:22:23 <DoctorSmaug> isn't that IO though?  I just want to return a string
16:22:29 <kallisti> it's not IO specific
16:22:33 <DoctorSmaug> ah ok
16:22:34 <rostayob> DoctorSmaug: be careful, printf throws errors at runtime if the string is not given the correct arguments
16:22:54 * kallisti is surprised there's no featureful number formatting library.
16:22:58 <kallisti> or not one that's easy to find.
16:22:59 <DoctorSmaug> noted
16:23:23 <kallisti> newtype might be the best option actually
16:23:41 <kallisti> just derive Num, Floating, RealFrac, Read, Fractional ....
16:23:42 <kallisti> what else?
16:23:54 <DoctorSmaug> Show
16:24:01 <kallisti> ...deriving Show defeats the purpose
16:24:07 <kallisti> since you'd be writing a show instance manually.
16:24:15 <DoctorSmaug> of course
16:24:17 <Jafet> That is madness
16:24:31 <DoctorSmaug> Seems a bit of overkill
16:25:08 <kallisti> DoctorSmaug: it doesn't take long at all to write.
16:25:25 <kallisti> the other option would be to do it manually each time you want to print it.
16:25:26 <DoctorSmaug> I'm thinking I might just deal with it as a string and strip ".0" if it occurs... Not ideal, but it would be quicker
16:25:30 <kallisti> or the other options mentioned.
16:25:52 <kallisti> you should definitely only deal with it as a string at the time of outputting, of course.
16:26:00 <DoctorSmaug> naturally
16:26:15 <kallisti> defining a newtype would be like doing that except automatically any time you need it ever in the future always. :D
16:27:07 <DoctorSmaug> Thanks for all the help :)
16:28:01 * hackagebot leksah-server 0.12.0.4 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.12.0.4 (HamishMackenzie)
16:28:33 <t4nk740> I have a simple question, I am very new to Haskell.  http://codepad.org/jCQ4Bu7N  I know that it returns the sum of the primes up to 50, but what is the (y:ys) doing in line 2 exactly?
16:29:32 <Jafet> > let showNoMercy x | fromIntegral (round x) == x = show (round x) | otherwise = show x in map showNoMercy [0,0.1..1]
16:29:33 <lambdabot>   ["0","0.1","0.2","0.30000000000000004","0.4000000000000001","0.500000000000...
16:29:48 <Jafet> > let showNoMercy x | fromIntegral (round x) == x = show (round x) | otherwise = show x in map showNoMercy [1,pi,3]
16:29:49 <lambdabot>   ["1","3.141592653589793","3"]
16:30:11 <t4nk740> wait this irc has an interactive bot in it?  lol
16:30:40 <kallisti> damn right.
16:30:43 <t4nk740> let p = [x|x<-[1..10]]
16:31:08 <t4nk740> I don't think I'm competent enough to use it.
16:31:09 <dfletcher> > ((++" Batman!").take 47.cycle.show)(0/0)
16:31:11 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNa Batman!"
16:31:15 <dfletcher> and that's how it's used :P
16:31:19 <shachaf> dfletcher: That was yesterday.
16:31:20 <t4nk740> LOL
16:31:22 <dfletcher> hehe
16:31:24 <rostayob> dfletcher: that is funny.
16:31:28 <kallisti> t4nk740: when defining functions you specify the arguments as patterns. the pattern you're most likely to have dealt with is just a simple variable name, which matches any kind of data you throw at it (within the bounds of the type)
16:31:58 <monochrom> hahahaha dfletcher
16:32:19 <kallisti> t4nk740: you can also specify data constructors in patterns.  so (x:xs) is using the : constructor for lists. The x here refers to the element at the front of the list, and the xs refers to everything else.
16:32:42 <kallisti> t4nk740: pattern matching on a constructor is the inverse of actually constructing the value with a constructor.
16:32:49 <kallisti> > let (x:xs) = [1,2,3,4] in x
16:32:50 <lambdabot>   1
16:32:52 <kallisti> > let (x:xs) = [1,2,3,4] in xs
16:32:52 <lambdabot>   [2,3,4]
16:33:00 <kallisti> > 1:[2,3,4]
16:33:01 <lambdabot>   [1,2,3,4]
16:33:05 <t4nk740> oooh
16:33:08 <dfletcher> yes shachaf I know it's from yesterday. today I'm implementing an integer to string with zero padding function for practice, but it's much less fun to type at lambdabot :P
16:34:08 <kallisti> t4nk740: note the difference between using the : constructor in a pattern (such as within a let expression) and using it normally as an infix operator.
16:34:44 <dfletcher> pad n l = take (l - length(show n)) (cycle "0") ++ show n ... -ish, but it handles negatives more gracefully.
16:34:45 <kallisti> when used in a pattern, it deconstructs the value
16:35:24 <kallisti> t4nk740: does that make sense? or am I using a lot of words you don't understand?
16:35:36 <rostayob> @where LYAH
16:35:36 <lambdabot> http://www.learnyouahaskell.com/
16:35:42 <rostayob> t4nk740: ^^^
16:35:49 <kallisti> rostayob: psh, lazy.
16:36:04 <t4nk740> I actually have learnyouahaskell open with GHCi and have been going through it.
16:36:18 <rostayob> t4nk740: then keep going :)
16:36:32 <t4nk740> I understand the examples you used above but am having some trouble applying it even in the simple case I gave of the prime generator.
16:36:35 <rostayob> he'll make a better job at explaining than we do. but ask here for whatever doubt
16:37:01 <t4nk740> I have a, in order of comfort, python, ruby, C background, if that helps when talking to me.
16:37:06 <Jafet> pad n l = reverse . take l . (++ repeat '0') . reverse . show $ n
16:37:37 <niteria> @pl \(x, y, z) -> a x y z
16:37:38 <lambdabot> (line 1, column 7):
16:37:38 <lambdabot> unexpected ","
16:37:38 <lambdabot> expecting letter or digit, operator or ")"
16:37:38 <lambdabot> ambiguous use of a non associative operator
16:37:46 <niteria> @pl (\(x, y, z) -> a x y z)
16:37:46 <lambdabot> (line 1, column 8):
16:37:47 <lambdabot> unexpected ","
16:37:47 <lambdabot> expecting letter or digit, operator or ")"
16:37:47 <lambdabot> ambiguous use of a non associative operator
16:38:01 <kallisti> t4nk740: do you see how the recursion works in the prime generator?
16:38:02 <Jafet> Tuples don't exist
16:38:48 <t4nk740> I don't think I'm getting it exactly.  isprime uses primes which relies on isprime.
16:38:55 <kallisti> note the '
16:39:01 <kallisti> isprime calls isprime'
16:39:12 <t4nk740> Yeah that, sorry.
16:39:26 <kallisti> isprime' itself doesn't ever refer to primes
16:39:31 <t4nk740> oh okay primes is what y:ys is referring to, I was wondering
16:39:45 <kallisti> t4nk740: it's referring to whatever argument is being passed.
16:39:48 <kallisti> but yes
16:39:50 <t4nk740> I some times forget functions use white space.
16:39:50 <Jafet> isprime\prime
16:39:53 <t4nk740> Yeah
16:40:02 <t4nk740> for their args.
16:40:07 <kallisti> yep.
16:40:45 <kallisti> t4nk740: so (y:ys) was the least of your worries. :P
16:41:31 <t4nk740> so the recursion bit is otherwise = isprime' x ys
16:41:37 <t4nk740> it checks the first of primes then the rest
16:41:42 <kallisti> yep
16:41:45 <t4nk740> cool
16:41:53 <kallisti> pattern matching makes recursive equations very nice to write.
16:41:53 <niteria> can I somehow tell ghci to reload all the files I :loaded each time I evaluate?
16:42:18 <niteria> it's tedious to :l everytime I make a change
16:42:22 <kallisti> not that I know of
16:42:26 <kallisti> just press up arrow a few times. :P
16:42:37 <kallisti> (assuming you're using a reasonable terminal)
16:43:01 * hackagebot freesect 0.0.5 - A Haskell syntax extension for generalised sections.  http://hackage.haskell.org/package/freesect-0.0.5 (AndrewSeniuk)
16:43:26 <kallisti> t4nk740: note however that isprime' is a partial function
16:43:32 <kallisti> there's one case of input it doesn't cover
16:43:38 <kallisti> that will throw a runtime exception.
16:43:54 <kallisti> t4nk740: do you see what it is?
16:44:01 <t4nk740> primes length less than 2?
16:44:14 <kallisti> well, yes
16:44:20 <kallisti> but mainly the empty list.
16:44:42 <kallisti> lists have exactly two constructors:   there's the (:) operator, and []
16:45:07 <kallisti> if you don't pattern match on both of these, then your function is partially defined over that list.
16:45:14 <kallisti> or any list, rather.
16:45:34 <kallisti> it's incomplete. the Haskell runtime will throw a non-exhaustive pattern error.
16:45:47 <kallisti> if the missing case occurs.
16:45:47 <t4nk740> Yeah the length of 2 was wrong, it's just empty sets, length of 1 would just give the only element, not an error.
16:46:01 <kallisti> no length of 1 would also error
16:46:04 <kallisti> if it doesn't satisfy the conditions
16:46:08 <kallisti> if it jumps to the "otherwise" case
16:46:13 <t4nk740> sorry, for the recursive part
16:46:16 <kallisti> then isprime' x []
16:46:17 <t4nk740> Yes
16:46:18 <kallisti> is called.
16:46:32 <t4nk740> I was just trying it with something that only needed y from y:ys not ys.
16:46:49 <kallisti> ah
16:47:23 <kallisti> t4nk740: here are some other partially defined functions on list
16:47:25 <kallisti> > head [1,2,3,4]
16:47:26 <lambdabot>   1
16:47:29 <kallisti> > tail [1,2,3,4]
16:47:29 <lambdabot>   [2,3,4]
16:47:31 <kallisti> > head []
16:47:32 <lambdabot>   *Exception: Prelude.head: empty list
16:47:36 <t4nk740> init []
16:47:40 <kallisti> avoid these when you can (which is always)
16:47:42 <kallisti> > init []
16:47:42 <lambdabot>   *Exception: Prelude.init: empty list
16:47:47 <t4nk740> oh I need >
16:47:57 <t4nk740>  > init []
16:48:07 <kallisti> no space before the >
16:48:10 <t4nk740> > init []
16:48:11 <lambdabot>   *Exception: Prelude.init: empty list
16:48:14 <t4nk740> victory at last
16:48:19 <kallisti> > last []
16:48:19 <lambdabot>   *Exception: Prelude.last: empty list
16:48:22 <kallisti> speaking of last.
16:48:25 <t4nk740> hah
16:48:29 <kallisti> :)
16:48:34 <t4nk740> I have only just started learning this today, so thanks!
16:48:41 <kallisti> not a problem.
16:48:56 <kallisti> t4nk740: did you know that lists can be infinite?
16:49:01 <DanBurton> > listToMaybe (take 1 [])
16:49:01 <t4nk740> yes
16:49:01 <lambdabot>   Nothing
16:49:09 <DanBurton> or actually
16:49:13 <DanBurton> > listToMaybe []
16:49:13 <lambdabot>   Nothing
16:49:18 <DanBurton> > listToMaybe [1,2,3]
16:49:19 <lambdabot>   Just 1
16:49:21 <kallisti> you could write:  filter isprime [3..]
16:49:31 <t4nk740> the code snippet I posted originally had [3..] instead of 50 and just returned primes !! 10000
16:49:37 <t4nk740> but I wanted a sum
16:49:38 <kallisti> yep
16:49:40 <kallisti> ah
16:49:42 <kallisti> well
16:49:46 <kallisti> once you have an infinite list you can do things with it
16:49:49 <kallisti> > drop 10 [1..]
16:49:50 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35...
16:50:01 <kallisti> so you can just grab the first 10, then take the sum.
16:50:03 <t4nk740> > take 10 [1..]
16:50:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:50:07 <t4nk740> yeah
16:50:21 <kallisti> > sum . take 100 $ [1..]
16:50:23 <lambdabot>   5050
16:50:39 <t4nk740> what are the . and $ ?
16:50:44 <kallisti> f $ x = f x
16:50:50 <t4nk740> Ah
16:50:53 <kallisti> however
16:50:55 <kallisti> it has low precedence
16:50:59 <kallisti> the lowest operator precedence in fact.
16:51:06 <dibblego> what is a better name for this type-class? http://paste.pocoo.org/show/564417/
16:51:14 <kallisti> (f . g) x = f (g x)
16:51:18 <kallisti> . is function composition
16:51:46 <t4nk740> neat, how mathematical this language seems to be.
16:52:09 <kallisti> t4nk740: so are you familiar with currying?
16:53:02 <dfletcher> is it what you do after a night of drinking? jk :)
16:53:54 <kallisti> t4nk740: semantically speaking, there is no such thing as a function that takes multiple arguments in Haskell.
16:53:56 <t4nk740> after looking it up I get it
16:54:02 <dfletcher> actually that part of Haskell knocked my socks off. functions with single args returning functions to simulate args :)
16:54:03 <kallisti> so when you write f x y
16:54:09 <kallisti> what you actually mean is:  (f x) y
16:54:46 <kallisti> so that's how the above code works:  sum . take 100 $ [1..]
16:54:50 <kallisti> take 100 is curried
16:55:03 <kallisti> (.) is defined with currying.   (f . g) x = f (g x)
16:55:25 <kallisti> er rather
16:55:28 <dibblego> you mean partially-applied, not curried
16:55:30 <kallisti> (.) is curried in the above example.
16:55:41 <kallisti> dibblego: hm, yes I suppose.
16:56:06 <t4nk740> out of curiosity what sort of math classes have you taken?  haskell seems to lend itself to that sort of background
16:56:51 <kallisti> well as a CS major I've taken upper-level calc courses. Discrete math. Right now I'm taking a course called intro. to advanced math which deals with writing simple proofs.
16:57:03 <kallisti> but I started learning Haskell during my senior year of high school.
16:57:26 <kallisti> dibblego: I sometimes confuse the distinctions between that particular terminology
16:57:30 <t4nk740> nice, I started with python my junior year, learned ruby earlier this year, C and Haskell now.  currently a freshman in college
16:57:52 <t4nk740> have some experience with proofs, calc with theory I, now calc with theory II and linear algebra
16:57:54 <kallisti> that sounds similar to the things I learned. Except I never really picked up Ruby much.
16:58:02 <roconnor> xplat: http://www.reddit.com/r/dependent_types/comments/qmlml/patricia_trie_challenge/c3zzzs6
16:58:03 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
16:59:04 <kallisti> map (drop 2) [[1,2,3],[4,5,6],[7,8,9]]
16:59:07 <kallisti> > map (drop 2) [[1,2,3],[4,5,6],[7,8,9]]
16:59:08 <lambdabot>   [[3],[6],[9]]
16:59:34 <t4nk740> > drop 2 [[1,2,3],[4,5,6],[7,8,9]]
16:59:35 <lambdabot>   [[7,8,9]]
16:59:51 <roconnor> @tell xplat http://www.reddit.com/r/dependent_types/comments/qmlml/patricia_trie_challenge/c3zzzs6 -- I think you should still add this to the gist so it doesn't get lost.
16:59:51 <lambdabot> Consider it noted.
17:00:20 <t4nk740> oh
17:00:31 <kallisti> :t map
17:00:32 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:00:35 <t4nk740> dropped 2 from each
17:00:42 <kallisti> yep
17:02:00 <kallisti> t4nk740: above is the type of map. a and b are type variables, which can be substituted with any type. -> is the type of functions
17:02:16 <kallisti> it's a right associative operator so:  a -> b -> c   is:  a -> (b -> c)
17:02:21 <kallisti> (that's the curried bit)
17:04:11 <kallisti> t4nk740: so  a -> b is a function with an argument type of a, and a return type of b.
17:05:11 <kallisti> so the type of map basically says: given a function from a to b, map produces a function from [a] to [b]
17:07:30 <kallisti> t4nk740: I think I lost you.. oh well.
17:07:58 <t4nk740> No sorry I was working on a separate problem, summing the digits in 100!
17:08:19 <t4nk740> I did a bunch of project euler problems in high school when I was learning python, then I did them in ruby, then C, and now working on haskell.
17:08:42 <kallisti> the first few are very simple in Haskell
17:08:53 <kallisti> just some list processing and maps and filters and such
17:09:12 <dfletcher> how does haskell actually extract function (b -> c) from my code that's using a -> b -> c? I suspect voodoo magic.
17:09:42 <kallisti> yep
17:10:47 <kallisti> it's the same as f a = \b -> c
17:11:08 <niteria> I have a [A] where data A = Foo | Bar, is there a generic function that gives me just Foo's?
17:11:10 <kallisti> the a just becomes a free variable in a closure.
17:11:42 <kallisti> niteria: "that gives me just Foos" what do you mean.
17:11:55 <kallisti> how many Foos?
17:12:02 <niteria> fun [Foo, Bar, Foo, Bar] = [Foo, Foo]
17:12:08 <kallisti> oh
17:12:16 <niteria> or rather fun [Foo, Bar, Foo, Bar] Foo = [Foo, Foo]
17:12:24 <kallisti> if you have a function named isFoo
17:12:26 <rasfar> don't need generics do you?
17:12:37 <kallisti> which returns True when a value of type A is Foo
17:12:43 <kallisti> then filter isFoo someList
17:12:45 <kallisti> will do that.
17:12:51 <niteria> well, can I avoid creating isFoo?
17:12:59 <kallisti> not that I know of.
17:13:01 <kallisti> not for this example.
17:13:09 <kallisti> isFoo Foo = True
17:13:11 <kallisti> isFoo _ = False
17:13:13 <kallisti> there. I did it
17:13:20 <rasfar> yes, but you'd end up creating something at least as complicated
17:13:30 <kallisti> probably more complicated.
17:13:30 <shachaf> [Foo | Foo <- l]
17:13:44 <kallisti> oh right, list comprehensions. I forget about those.
17:13:44 <shachaf> [x | x@Foo <- l]
17:14:04 <kallisti> I forget they magically ignore non-exhaustive patterns.
17:14:10 <rasfar> nice
17:14:38 <niteria> that's way cooler
17:14:51 <kallisti> meh
17:14:57 * kallisti doesn't like list comprehensions that much.
17:14:59 <shachaf> niteria: If you want to write fun [Foo,Bar,Foo,Bar] Foo, you can also use Eq for that.
17:15:22 <shachaf> kallisti: This pattern-matching behavior is one of the redeeming features of list comprehensions. :-)
17:15:37 <kallisti> yes I agree. I keep forgetting about it.
17:15:48 <kallisti> also, I apparently forgot about simple things such as Eq...
17:15:49 <niteria> well in my use case there are some constructor parameters that I want to ignore
17:15:54 <shachaf> niteria: If the constructors have arguments, you can use Data.Data.Data.
17:16:09 <kallisti> I would just pattern match with a list comprehension or function at that poit.
17:16:15 <kallisti> and use filter.
17:16:18 <shachaf> But it's slightly ugly...
17:16:27 <kallisti> Data.Data.Data is likely overkill
17:16:39 <rasfar> hahah
17:17:34 <rwbarton> Data.Data should be plenty.
17:17:38 <rasfar> listify (x -> case x of Foo -> True; _ -> False) or something?
17:18:11 <kallisti> replace listify with filter
17:18:33 <kallisti> > filter (==2) [1,2,3,4,5,2,5,1,2,1,2,5]
17:18:34 <lambdabot>   [2,2,2,2]
17:18:34 <rasfar> http://www.haskell.org/haskellwiki/Scrap_your_boilerplate
17:18:52 <rasfar> (that listify i mean)
17:18:55 <kallisti> oh
17:19:15 * shachaf is not recommending the Data.Data solution, for what it's worth.
17:19:39 * rasfar just learned a lot about syb over the last 3 weeks
17:20:08 <shachaf> Are you sure listify is what you want there?
17:20:23 <rasfar> not really -- would everything be better?
17:20:51 <rasfar> everything (mkT (\ x -> case ...))
17:20:58 <shachaf> Well, I have no idea what you're trying to do anymore.
17:21:16 <rasfar> who me? not a thing...
17:21:56 <shachaf> > everywhere (mkT (reverse::String->String)) "scrap your boilerplate"
17:21:57 <lambdabot>   "ca orbiepaetlrlo uyprs"
17:22:15 <rasfar> everywhere, right
17:22:19 <shachaf> ?
17:22:26 <shachaf> I'm not saying you should use everywhere.
17:22:41 * shachaf needs to go, anyway.
17:22:46 <kallisti> shachaf: but there's so much less boilerplate!
17:22:47 <rasfar> wow, that is wierd
17:23:09 <rasfar> i thought everywhere was bottom-up, left-to-right
17:23:41 <rasfar> or everything (mkQ ...) should do it too, i think, as it's a list anyhow
17:26:52 <xtea> hello
17:27:13 <rasfar> oh good! i wasn't disconnected
17:27:31 <rasfar> hi xtea, how's things?
17:28:11 <xtea> can anyone give me a hint how to enforce default implementation of (+) operator for given data type without using modulename.+ ?
17:28:23 <xtea> hi rasfar
17:29:11 <Saizan> xtea: maybe you want to make your type an instance of Num?
17:29:25 <Saizan> since that's how the overloading of Prelude's (+) works
17:29:32 <xtea> rasfar: not bad, apart of the fact that have been watching presentation by Connor McBride recently and feel a bit shitty about myself after that :)
17:30:00 <Saizan> heh, why?
17:30:38 <xtea> Saizan: I've declared Nat type for natural numbers which is recursive as for Zero and Succ Nat
17:31:10 <xtea> Saizan: and now want to declare (+) over Nats
17:31:54 <Saizan> xtea: have your learned about typeclasses?
17:32:35 <xtea> Saizan: not quite sure just noted the name and will check it
17:33:30 <hpc> :t everywhere
17:33:31 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
17:34:26 <xtea> Saizan: back to your question about C McBride he gave demo of what he can do in agda and I am quite concerned that this was a witchery ;)
17:34:40 <Saizan> hah
17:35:04 <rasfar> is that the same connor mcbride that's associated with OpenBSD?  That would make two (dons also)...
17:35:22 <Saizan> it's Conor btw
17:35:32 <rasfar> Conor McBride, sorry
17:36:16 <Saizan> i don't know if he has worked on OpenBSD
17:36:17 <rasfar> s/that's/who's/ also
17:36:21 <xtea> rasfar: not quite sure and if I bet I would say no
17:37:24 <xtea> Dr. McBride - Haskell , agda and types theory - as far as I know
17:38:17 <rasfar> ah.  i think the OpenBSD person was Ryan actually, nm
17:40:28 <rasfar> hpc: i think with "everywhere", you'd always get the whole list back (possibly with some elements transformed), but with "everything" you can filter.
17:57:10 <bgamari> Is there no convenient way to derive an instance of a class with associated types for a newtype?
17:57:29 <bgamari> It seems GeneralisedNewtypeDeriving can't do it
17:57:40 <bgamari> e.g. HasTrie for a newtype'd Int
18:15:24 <rasfar> bgamari: i don't really have any idea, but could http://hackage.haskell.org/trac/ghc/ticket/2850 be related?  if so, there's a few other extensions used in the example which might help. <shrug>
18:15:37 <bgamari> hmm
18:16:28 <bgamari> could be
18:16:55 <rasfar> their example does compile for me with 7.0.4
18:20:01 <hpaste> “Ben Gamari” pasted “NewtypeDeriving and TypeFamilies” at http://hpaste.org/65177
18:20:10 <bgamari> rasfar: That is my case
18:20:39 <bgamari> given the compiler explicitly tells me it rejects the code because the class has associated types, I suspect it's a real limitation
18:20:46 <bgamari> unfortunately
18:21:57 <bgamari> The snippet from that bug works on 7.4.1 as well
18:22:00 <bgamari> bah
18:22:35 <bgamari> it seems to me like this makes using memotries quite inconvenient in a good number of cases
18:24:11 * applicative suggest taking consolation from the witty parenthesis in the error message  '.... (even with cunning newtype deriving)'
18:25:28 <bgamari> heh
18:27:49 <hpaste> Ste1891 pasted “Inflation” at http://hpaste.org/65178
18:27:54 <Ste1891> Hi.  Does anyone know what a "lexical error in string/character literal (UTF-8 decoding error)" means and why I might be getting it from the code indicated?
18:28:05 <hpaste> dfletcher pasted “batman” at http://hpaste.org/65179
18:28:10 <rwbarton> probably your source is not in UTF-8 encoding
18:28:23 <dfletcher> I keep finding more and more crazy ways to do this :)
18:28:52 <mauke> Ste1891: what encoding did you save your file in?
18:29:02 <rwbarton> that's a compiler error right?
18:29:53 <Ste1891> The editor is set to default, but the code was compiling fine in WinGHCi until I added the last few lines.
18:29:54 <rasfar> I get an error even if use data instead of newtype
18:30:07 <mauke> Ste1891: what encoding did you save your file in?
18:30:15 <rasfar> bgamari: ^
18:30:41 <xplat> lispy: i think 'CT as a foundation for a multi-paradigm language' could quite likely make sense
18:30:41 <lambdabot> xplat: You have 1 new message. '/msg lambdabot @messages' to read it.
18:32:26 <rasfar> says: `HasTrie' is not a derivable class
18:32:32 <Ste1891> mauke: OK.  I've set it to UTF-8 and it works now.
18:34:18 <Ste1891> Thanks.  Bye...
18:34:23 <applicative> Ste1891: It sounds like the dreaded BOM?
18:36:07 <Tesseraction> Are there any particularly good resources on learning how to use the State monad?
18:38:31 <parcs`> i believe LYAH covers that
18:38:35 <Axman6> just try playing around with it and asking questions in here too
18:40:09 <bgamari> rasfar: hmm
18:40:27 <bgamari> rasfar: Not even sure what that means
18:41:39 <rasfar> Tesseraction: http://www.haskell.org/haskellwiki/State_Monad has some really small examples
18:41:44 <applicative> Tesseraction here's a simple IO use of state, http://hpaste.org/51068 based on http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
18:43:00 <shachaf> If you're trying to figure out how State works, I recommend not getting IO involved.
18:43:17 <rasfar> and if you want a longer example, there's applicative's :p
18:43:34 <Tesseraction> yeah I'm trying to avoid IO and State will help a lot
18:44:06 <bgamari> Bah, of course cabal would decide that the night before a paper deadline that its time to screw with process and directory, bringing down the entire stack
18:45:29 <applicative> Tesseraction: oh in that case, avoid it; for some reason I anticipated the opposite
18:46:19 <Tesseraction> it's fair enough, I may end up including it near the end
18:49:29 <Proge> bgamari: its a better excuse than the dog ate my homework
18:52:17 <Tesseraction> the dog used the wrong compiler options when building my homework
18:52:28 <jhance> Proge: Dogs can't eat your homework if you keep your homework in version control ;)
18:52:46 <shachaf> The dog garbage-collected my git repository.
18:53:18 <jhance> shachaf: Theoretically that isn't a bad thing though
18:53:45 <shachaf> If only my dog was theoretical. :-(
18:58:05 <JoeyA> If I'm stacking a bunch of "with" (e.g. withMVar) calls, what monad transformer should I be using instead?
18:58:09 * hackagebot FilePather 0.1.3 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.1.3 (TonyMorris)
18:58:14 <nwillems> Hello there - I'm trying to install happstack with cabal, but it keeps on failing at installing sendfile. Its telling me that theres a compile error about a Ptr Int64 not being an Ptr Int32.
18:58:49 <JoeyA> I guess you're running a 64-bit OS?
18:58:52 * JoeyA tries to install it
18:58:57 <JoeyA> Worked for me.
18:59:23 <JoeyA> nwillems: What version of sendfile is it trying to install?
18:59:50 <nwillems> JoeyA: Nope, a 32-bit Archlinux machine. I assert that somewhere somebody told it to use 64 bit pointers. It is trying to install version 0.7.4
18:59:59 <applicative> cabal install senfile works here.  I have 32 bit ghc
19:00:26 <JoeyA> I can cabal install sendfile-0.7.4 with ghc 7.0.3 and ghc 7.4.1, on Ubuntu 10.04 64-bit.
19:01:15 <JoeyA> nwillems: Can you paste the full error message on hpaste.org ?
19:01:24 <applicative> the cpp instructions in the cabal file are a little complicated
19:01:33 <mm_freak> JoeyA: you can use regions
19:01:43 <nwillems> JoeyA: yes - Just a sec
19:02:05 <nwillems> just for sendfile, right? Or you want the complete happstack?
19:02:10 <bgamari> Proge: sadly, this paper is going to a conference, not a teacfher
19:02:35 <JoeyA> mm_freak: As in, the regions package?
19:03:06 <mm_freak> yeah…  or write your own monad
19:03:41 <mm_freak> withResources $ do r1 <- getR1; r2 <- getR2; …
19:03:57 <mm_freak> then your monad would cleanup after the mess of getR1 and getR2
19:04:02 <applicative> nwillims yes the file it tries to install if it finds linux, is very complicated.  There is a flag -fportable that should make sendfile work
19:04:05 <JoeyA> I wonder if ResourceT (from the conduit package) would be a better choice.
19:04:49 <applicative> nwillems: I mean, the file assumes 64 bit
19:05:13 <mm_freak> JoeyA: it would probably
19:05:29 <mm_freak> ResourceT is less bound to lexical scope
19:05:40 <nwillems> applicative: Yeah - I just don't get how a 64bit somethign sneaked into my system :)
19:06:05 <mm_freak> JoeyA: but as long as your withFunctions are cascaded directly i'd probably just use them
19:06:38 <mm_freak> when they are, you can just write them in a column…  no need to extra-indent the inner with*s
19:07:00 <JoeyA> I think I'll just do it directly, as you suggest.
19:07:14 <mm_freak> withR1 $ \r1 -> withR2 $ \r2 -> do
19:07:15 <mm_freak> then indent
19:07:57 <JoeyA> But I may use ResourceT or something instead later.
19:08:02 <JoeyA> Thanks
19:08:19 <applicative> nwillems does cabal install sendfile -fportable work?
19:10:01 <nwillems> applicative: trying - looking like some different base version are doing wierd stuff
19:10:28 <applicative> nwillems: maybe forget that, there isa nother problem i see in the cabal file, an out of date network bytestring
19:11:18 <nwillems> applicative: "Cannot configure network-bytestring..." Ah, then that is a fist. But should that interfere with the rest or is it just interefering when using the -fportable?
19:11:44 <applicative> just with fportable
19:14:12 <nwillems> Oh, cool. Well, I'm trying to put the cabal output in a file. And the compile error keeps escaping the file. How to get it down there?
19:14:13 <applicative> yeah, nwillems network-bytestring is behind the going version of network, presumably for a reason
19:15:09 <applicative> oh i see, network-bytestring is deprecated.  this seems like a problem for sendfile
19:16:03 <nwillems> So network-bytestring is at somepoint providing a strange interface which sendfile complains about?
19:17:21 <rata_> hi
19:17:32 <applicative> no, it turns out that the network-bytestring business is in network now, so you have it.  I struck the line from the cabal file and it compiles
19:17:42 <rata_> what do you use guys for haskell debugging?
19:18:05 <Axman6> writing small, easily testable functions and ghci
19:18:13 <Axman6> then Debug.Trace
19:18:36 <niteria> @hoogle hPutStr
19:18:36 <lambdabot> System.IO hPutStr :: Handle -> String -> IO ()
19:18:36 <DanBurton> i use the compiler. it usually catches most of my dumb mistakes.
19:18:36 <lambdabot> GHC.IO.Handle hPutStr :: Handle -> String -> IO ()
19:18:36 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
19:18:54 <applicative> nwillems: so if you do cabal unpack sendfile then edit the cabal file and then do cabal install -fportable it should work, here's the cabal file  http://hpaste.org/65182
19:21:22 <applicative> i will try to send a patch to stepcut
19:22:17 <nwillems> applicative: editing the cabal file, can I just overwrite it with your provided cabal file?
19:22:55 <applicative> yes, I just deleted one line, and got rid of the upper bound on bytestring which was okay.
19:23:53 <nwillems> and the oneline is the network-bytestring dependendency, right?
19:24:10 <applicative> nwillems: yes.  but the comma at the end of the previos line must go too
19:24:40 <nwillems> applicative: Awww, but I like commas. Canøt this little fluffy one stay? :-)
19:24:56 <applicative> cabal is cruel
19:25:27 <rasfar> leading and trailing commas should always be accepted (ignored) imo
19:27:13 <JoeyA> What parser library does cabal use, so we can all avoid it?
19:27:32 <rata_> DanBurton: I usually rely on the compiler, but this time didn't catch it
19:27:38 <nwillems> applicative: I gave in, removed the comma and tried "cabal install -fportable", and now it fails at a function called safeMinus, "Could not deduce (Show a) from a use of `show'".
19:28:08 <parcs`> anyone know how to resolve this issue: http://hpaste.org/64861
19:28:23 <rata_> Axman6: I'm trying to port an existing code and therefore to keep the functions close to their original definition
19:28:55 <applicative> nwillems, oh no
19:29:20 <nwillems> rasfar: I'm not sure I do agree. In some situations it just makes things messy. applicative: sound really bad :-(
19:29:33 <rasfar> lib.so -- strange
19:29:47 <applicative> oh are you using ghc 7.4
19:29:52 <geekosaur> nwillems, if it's ghc 7.4.x then you need to find the definition of the type it's trying to "show" and possibly add a Show a constraint next to the Num a
19:30:09 <rasfar> nwillems: i like it because then you can reorder/comment/append items without fussing about them
19:30:48 <nwillems> applicative: yes ghc 7.4.1. geekosaur: in the library?
19:31:08 <geekosaur> preferably, yes
19:31:32 <niteria> wow, unary counting true variables in cnf generator for sat solver is easy in theory, but as it turns out hard to get right in practice
19:31:41 <niteria> and impossible to debug
19:31:57 <geekosaur> ghc 7.4 dropped the Show constraint on Num, so programs have to add it back in themselves if they want it.  you *could* add it in your program but "orphan instances" like that tend to cause problems in the long run
19:32:00 <nwillems> rasfar: I get that. But then at some point you think, ah I'm going to show the world how nice my code is, and then at some later point pour non coder thinking om nom nom nice code, and gets nothing :(
19:32:43 <rasfar> ? really don't understand
19:32:54 <geekosaur> (I'd been wondering if losing that implied instance might cause proliferation of orphan instances...)
19:33:04 <rasfar> you mean the extra commas might confuse people reading the code?
19:33:26 <applicative> nwillems, yes, then Num doesn't entail Show so you must also add Show a on line 138 of src/Network/Socket/SendFile/Internal.hs
19:33:38 <rasfar> (i'm recommending it for expediency, not esthetics)
19:34:03 * applicative sends another patch
19:34:36 <nwillems> applicative: geekosaur: adding it would mean changing the line to something like (Ord a, Num a, Show a) => a -> a -> a right?
19:34:48 <rasfar> i've had some pretty confusing compiler errors because of ending up with a leading or trailing comma (or missing comma) when reordering/deleting etc. items
19:35:21 <applicative> nwillems: thats what I was thinking.  i hope happstack compiles with this construction....
19:35:22 <geekosaur> yes
19:35:48 <applicative> nwillems: geekosaur probably the signature could be struck completely
19:35:50 <nwillems> rasfar: Yes, it might confuse. And yes I agree it is esthatics, and yes some compilers give strange error. You have an error on line 404, but wait there is a perfect line at 404. Hmm...
19:36:14 <rasfar> but i said it is not esthetics, so we disagree, actually <shrug>
19:37:42 <nwillems> rasfar: Sorry - I mean, that yes disallowing the leading/trailing commas is only for good-looks not for functionality. And that it can be nice, when doing reordering and such.
19:38:18 <nwillems> applicative: geekosaur: Thansk you guys so much. Now it compiles and is installed. Will report back in a sec when happstack is installed
19:39:41 <nwillems> All right might be more than a sec. 20 of 41 compiled
19:39:44 <rasfar> i'll stay with <shrug> on this one and move on
19:41:25 <nwillems> And it works - weeeee. Code code code.
19:45:54 <applicative> nwillems: oh excellent, ill send the other patch
19:47:07 <danharaj> FRP is pretty fun once you gun down all the time/space leaks.
19:52:05 <bgamari> any idiom for killing a space leak due to mapping over a list followed by taking its length?
19:52:54 <dbelange> scareder than a dutch boy in a room full of rocking chairs
19:53:12 <bgamari> I was really hoping the compiler could somehow fuse the map and length accumulation
19:53:29 <applicative> the length is the same before and after the map :)
19:55:39 <bgamari> eh?
19:56:09 <bgamari> yes, I was hoping the compiler woud realize this?
19:56:16 <bgamari> scratch the question mark\
19:59:01 <bgamari> hmm, yes, I guess I did a poor job of describing the problem
19:59:24 <bgamari> applicative: The actual issue is I'm accumulating (sum) and also need the length
19:59:49 <bgamari> Forget about the above idiocy
20:00:24 <jhance> bgamari: You could always incorporate length into a fold
20:01:19 <kallisti> :t curry
20:01:20 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:01:28 <applicative> ah this is the problem of 'average'
20:01:40 <bgamari> yep
20:01:46 <bgamari> I could always do as jhance said
20:01:54 <bgamari> but this just seems very hackish
20:03:06 <kallisti> @pl (\x y -> f . g . h $ (x,y))
20:03:06 <lambdabot> ((f . g . h) .) . (,)
20:03:11 * hackagebot URLb 0.0.0 - A liberal, simple URL parser.  http://hackage.haskell.org/package/URLb-0.0.0 (JasonDusek)
20:03:50 <applicative> there's a really lame discussion in section 2 here http://www.haskell.org/haskellwiki/Stack_overflow
20:03:51 <parcs`> why is that causing a space leak?
20:05:39 <mjreed> Is there a Haskell equivalent of let*, or do I just have to do "let ... in let ... in ..." ?
20:05:58 <shachaf> mjreed: You just have to do that, more or less.
20:06:04 <shachaf> Why do you want to?
20:06:05 <applicative> why use let at all?
20:06:07 <shachaf> Shadowing is often a bad idea.
20:06:55 * applicative favors where whenever possible
20:07:20 <Brandon_R> hey guys
20:07:28 <parcs`> > let a = 5 where b = let c = 6 in c in a
20:07:29 <lambdabot>   5
20:07:46 <Brandon_R> i have a quick question
20:07:57 <applicative> what is it Brandon_R
20:07:59 <Brandon_R> how many concurrent connections can a haskell server handle on average?
20:08:08 <parcs`> a lot
20:08:27 <shachaf> Brandon_R: You're not going to get useful answers to such a vague question.
20:08:35 <parcs`> eg mine
20:08:44 <nyingen> what does let* do again? IIRC ordinary let (in scheme, lisp) doesn't let later bindings refer to earlier bindings, whereas let* does. Is that right?
20:08:51 <bgamari> Brandon_R: that is definitely not a quick answer
20:09:13 <mjreed> no shadowing, just aliasing.
20:09:19 <mjreed> nyingen: right.
20:09:27 <shachaf> mjreed: Aliasing?
20:09:29 <mjreed> so you can do let x=y+1 z==x+y
20:09:31 <bgamari> Brandon_R: you should start by specifying what type of server you are interested in\
20:09:33 <nyingen> then doesn't haskell's 'let' already behae like let*?
20:09:38 <nyingen> behave
20:09:41 <shachaf> mjreed: You can already do that in Haskell.
20:09:44 <mjreed> oh.
20:09:50 <mjreed> well, then!
20:09:53 <nyingen> since you're here
20:09:56 <rwbarton> haskell's let is like scheme's letrec
20:10:05 <shachaf> > let y = 5; x = y + 1; z = x + y in (x,y,z)
20:10:06 <lambdabot>   (6,5,11)
20:10:14 <nyingen> I would like to know whether (in lisp, scheme) there's ever any reason to use let instead of let*
20:10:22 <nyingen> I asked this in #scheme but no one responded
20:10:22 <bgamari> Brandon_R: If you are interested in HTTP, you might be interested in http://www.yesodweb.com/blog/2011/03/preliminary-warp-cross-language-benchmarks
20:10:24 <shachaf> > let z = x + y; y = 5; x = y + 1 in (x,y,z)
20:10:25 <lambdabot>   (6,5,11)
20:10:35 <shachaf> nyingen: It's probably simpler?
20:10:45 <shachaf> Isn't let implemented with lambda or something?
20:11:13 <nyingen> I mean, is there a major efficiency concern involved?
20:11:25 <nyingen> Otherwise, why have the two separate forms?
20:12:02 <Sgeabomination> Haskell's let does not behave like let* (at least in CL). let* is one-way.
20:12:13 <rata_> nyingen: I think there's no reason to have two and that's probably why clojure doesn't have two
20:12:14 <Sgeabomination> You can't refer to later names earlier on.
20:12:23 <shachaf> Sgeabomination: I don't think anyone claimed that it does.
20:12:41 <rata_> nyingen: but you should ask that question in #common-lisp
20:12:43 <Sgeabomination> Oh
20:12:55 <Sgeabomination> There is no #common-lisp , just #lisp
20:12:56 <rwbarton> I mean, if you wanted to shadow multiple variables at once, then you'd use let.
20:13:04 <rwbarton> (let ((a b) (b a)) ...)
20:13:08 <nyingen> I casually said that haskell 'let' is like let*, which is not really correct (as Sgeabomination points out)
20:13:09 <mjreed> it's more of a style thing with let vs let*
20:13:13 <rata_> yes, that is
20:13:32 <mjreed> let conveys the fact that the definitions are independent of each other..
20:13:36 <rwbarton> Probably you should never do this though.
20:13:46 <shachaf> You should probably just never shadow variables.
20:13:50 <rwbarton> Indeed
20:13:51 <shachaf> Unless you have a good excuse.
20:13:53 <mjreed> also, let came first.  let* was added later...
20:13:57 <nyingen> mjreed: I guess in some circumstances that could be useful to know
20:14:03 <dolio> Haskell let is like let-rec, no?
20:14:10 <shachaf> GHC has extensions whose purpose is variable shadowing. :-(
20:14:14 <rata_> yes, haskell's let is different to cl's let and let*
20:14:16 <shachaf> dolio: Yes.
20:14:30 <rata_> in cl, you cannot refer to other variables defined in let
20:14:54 <mjreed> right.  and I was under the (mistaken) impression that the same was true in Haskell.
20:15:01 <mjreed> resulting in some ugly nested let's.
20:15:24 <mjreed> not sure why i didn't just try it. :)
20:15:30 <Sgeo> If you want to shadow variables earlier in the let with variables later, you need to nest lets
20:15:35 <Sgeo> But why would you do that?
20:15:41 <Sgeo> (In Haskell)
20:15:41 <mjreed> no idea.
20:15:44 <mjreed> don't want to shadow anything.
20:15:58 <nyingen> You do that as a hateful act of vandalism to make life difficult for your successor
20:16:42 <adnauseam> when creating an anonymous function, is \x the nameof said function, or a parameter ?
20:16:42 <rata_> hahahahaha
20:16:54 <mauke> adnauseam: if it had a name, it wouldn't be anonymous
20:17:02 <rata_> adnauseam: of a parameter
20:17:03 <Sgeo> With \x -> x + 1, the x is the argument
20:17:07 <adnauseam> hrm,
20:17:09 <adnauseam> elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys
20:17:23 <Jafet> Beware the pseudonymous functions
20:17:27 <adnauseam> isn't it being called again on the else ?
20:17:34 <mauke> adnauseam: no
20:17:52 <adnauseam> hrm, it's returning the value of the accumulator then if i understand
20:17:56 <mauke> functions are applied to an argument, not just "called"
20:18:32 <parcs`> @remember adnauseam when creating an anonymous function, is \x the nameof said function, or a parameter ?
20:18:32 <lambdabot> I will never forget.
20:18:48 <mauke> I don't think it was funny
20:19:37 <adnauseam> great - my ignornace is now canonized :p
20:19:53 <adnauseam> that won't stop me from asking stupid questions in the future you know!
20:20:03 <mauke> preflex: quote
20:20:04 <preflex>  <yaakov> The problem is that the inheritance tax makes OO programming expensive.
20:20:05 <nyingen> does Haskell support scientific notation for literal numbers?
20:20:18 <adnauseam> s/stupid/more stupid
20:20:20 <shachaf> nyingen: There's a pretty easy way to find out.
20:20:21 <mauke> nyingen: how hard would it be to try it?
20:20:21 <byorgey> adnauseam: good! questions (stupid or otherwise) are always welcome here
20:20:31 <nyingen> Yeah, I keep forgetting about ghci
20:20:44 <byorgey> or lambdabot!
20:20:45 <adnauseam> byorgey: i do my best ;p
20:21:02 <shachaf> byorgey: I think @remembering such questions might be seen as discouragement...
20:21:07 <Sgeo> The \x can be the name of the function!
20:21:20 <byorgey> shachaf: I agree, I do not condone the @remembering of such questions
20:21:22 <parcs`> i agree
20:21:26 <Sgeo> > fix (\fac x -> if x == 0 then 1 else x * fac (x - 1)
20:21:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:21:32 <parcs`> @forget adnauseam when creating an anonymous function, is \x the nameof said function, or a parameter ?
20:21:33 <Sgeo> > fix (\fac x -> if x == 0 then 1 else x * fac (x - 1)) 5
20:21:33 <lambdabot> Done.
20:21:34 <lambdabot>   120
20:21:38 <shachaf> If we were dealing with alligator eggs, you would call it "the red alligator & fam."
20:21:47 <Sgeo> ^^fac holds the function there
20:21:47 <Sgeo> >>>
20:21:49 <Sgeo> >.>
20:21:54 <mauke> Sgeo: no, it doesn't
20:21:55 <Sgeo> I hate typoing >.> as >>>
20:22:05 <mauke> Sgeo: the function takes two arguments; fac takes one
20:22:19 <Sgeo> Blargh
20:22:22 <Sgeo> <.<
20:23:20 <Sgeo> Therefore, that syntax secretly makes the thing after \ be the name of the function rather than an argument! </lies>
20:24:11 <shachaf> fix(\ is the syntax for starting a named anonymous function!
20:24:21 <shachaf> Brillant!
20:25:08 <shachaf> That works pretty well.
20:28:14 <mjreed> I want an enumerated type for directions that includes Left and Right, but those are predeclared in Data.Either.  Suggestions?   LEFT and RIGHT?  Leftwards and Rightwards? L and R?
20:28:28 <mauke> don't import Either
20:28:38 <mjreed> it's in the prelude, apparently.
20:28:48 <mjreed> I'm not importing it explicitly
20:28:54 <Enigmagic> import Prelude hiding (Either) ?
20:29:08 <shachaf> L and R?
20:29:12 <shachaf> Seems reasonable to me.
20:30:37 <pdxleif> Does Haskell support renaming on import?
20:30:47 <geekosaur> not of individual symbols
20:30:58 <stepkut> is there a function like, showOctets :: ByteString -> String
20:31:08 <stepkut> which shows the ByteSTring like a normal hex dump
20:31:18 <stepkut> aka, "00 E2 D5 CA" etc
20:31:38 <geekosaur> you could maybe do something like:  import Prelude hiding (Either); import qualified Prelude (Either(..)) as PE
20:31:43 * adnauseam 's head explodes
20:32:53 <geekosaur> actually I think you might need to hide Left and Right explicitly as well
20:33:02 <adnauseam> stepkut: i don't know if there is one, but it should be easy enough to create
20:33:06 <mjreed> gack.
20:33:16 <stepkut> adnauseam: yeah,  i am writing it now
20:33:22 <adnauseam> sweet man
20:34:30 <mjreed> maybe I'll just define turnLeft and turnRight instead of "turn leftOrRight".
20:35:38 <hpaste> “Mark Reed” pasted “Directions” at http://hpaste.org/65183
20:35:57 <mjreed> that seem like a reasonable way to do that?  is there a better one?
20:53:10 <kallisti> any reason threadDelay might be hanging indefinitely?
20:53:43 <shachaf> Maybe it's not indefinite but just really long.
20:54:14 <kallisti> I gave it 500000 as parameter. the documentation says microseconds...
20:55:31 <kallisti> I'll try smaller values then.
20:56:53 <kallisti> hmmm, perhaps it's something else.
20:56:55 * kallisti debugs.
20:57:23 <ClaudiusMaximus> could be that all capabilities are busy doing things that don't allow context switches (like tight loops with no allocation, unless that changed recently, or blocking unsafe FFI)?
20:57:58 <kallisti> when converting an int to NominalDiffTime it's in picoseconds right?
20:58:13 * hackagebot mighttpd2 2.5.6 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.6 (KazuYamamoto)
20:58:48 <kallisti> ah nevermind
20:58:50 <kallisti> seconds apparently
20:58:53 <kallisti> that would do it.
20:59:02 <kallisti> these tiny units of precision are insane. :P
20:59:58 <kallisti> my conversion choices are: seconds. picseconds.  great.
21:02:28 <kallisti> how do I take an int
21:02:35 <kallisti> and get a NominalDiffTime in units other than seconds.
21:03:11 <kallisti> ah nevermind I see. I can use fractional values.
21:07:42 <llano> Hi all. I am using ght2hs. there is one problem with TextView. I redirect stdout to a TextView, but all the text will display at once after all of them have been inserted. Is there a way to update the textview in REAL-TIME whenever a new line is written to the textview? in other words, I hope the text displayed in the text view would update as soon as a new line is added, instead of displaying all the texts in one time.
21:08:21 <Jafet> You could write some code to effect that.
21:09:07 <llano> what kind of code is that?
21:09:41 <Jafet> Code that periodically adds new text on stdout to the TextView.
21:10:51 <llano> right now, i get the stdout as a pipe handle
21:20:55 <dmwit> llano: Yes, it's possible. Write a separate thread that reads the handle and calls postGUI(A)Sync as appropriate with an IO action that updates the TextView.
21:21:32 <dmwit> llano: You'll want to read up a bit on the caveats of using multiple threads in a Gtk app, even if you don't plan on using the threaded runtime.
21:22:48 <dmwit> See http://hackage.haskell.org/packages/archive/gtk/latest/doc/html/Graphics-UI-Gtk-General-General.html for more details, especially initGUI's documentation.
21:23:24 <adnauseam> > fix
21:23:25 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a)
21:23:25 <lambdabot>    arising from a u...
21:24:11 <adnauseam> > (\fac x -> if x == 0 then 1 else x * fac (x - 1)) 5
21:24:12 <dmwit> > fix show
21:24:12 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
21:24:12 <lambdabot>    arising from a use of `...
21:24:13 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:24:29 <dmwit> > fix (\fac x -> if x == 0 then 1 else x * fac (x - 1)) 5
21:24:30 <lambdabot>   120
21:24:32 <adnauseam> *scratches his head*
21:24:56 <adnauseam> what's fix? it doen't seem to appear in preluide
21:25:02 <dmwit> ?index fix
21:25:02 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
21:25:04 <dmwit> ?src fix
21:25:04 <lambdabot> fix f = let x = f x in x
21:25:20 <dmwit> It gives the least fixed-point of an expression (in the defined-ness ordering).
21:25:45 <adnauseam> oh alright
21:26:07 <dmwit> If you know of the Y combinator, then you should understand fix immediately. =)
21:26:19 <adnauseam> not yet ;p
21:26:33 <shachaf> dmwit: fix behaves identically to the Y combinator, but it's completely different in purpose. :-)
21:27:19 <shachaf> adnauseam: A simpler definition: fix f = f (fix f)
21:27:28 <dmwit> Is it completely different in purpose?
21:27:37 <adnauseam> hrm
21:27:58 <shachaf> dmwit: I think the purpose of the Y combinator is to implement recursion without using recursion as a primitive.
21:28:10 <dmwit> Oh, alright.
21:28:47 <dmwit> adnauseam: The point of the "f (fix f)" thing is that if "f" is lazy (i.e. produces something before looking at its argument), then "f (fix f)" gets to produce something before recursing onto evaluating "fix f" again.
21:29:12 <adnauseam> oh!
21:29:20 <dmwit> adnauseam: For example, if "f" is "(1:)", then "f (fix f)" gets to produce the head of the list (1) before trying to recurse into "fix (1:)" again.
21:30:09 <adnauseam> that's why that lambda "recursed" and behaved like a fac then
21:30:39 <adnauseam> by that lamda i mean this one (\fac x -> if x == 0 then 1 else x * fac (x - 1)) 5
21:31:37 <shachaf> adnauseam: I think you might be best off reading about the behavior of functions in general before reading about fix. :-)
21:31:39 <dmwit> "(\fac x -> ...) 5" is not a subexpression of "fix (\fac x -> ...) 5".
21:32:20 <adnauseam> shachaf: yeah... i think i should stick it. i was trying to understand folding earlier and it lead to me misunderstanding lambdas and now to fix. heh
21:32:45 <adnauseam> dmwit: what do you mean by not a subexpression ?
21:33:03 <dmwit> I mean the argument to "fix" is not "(\fac x -> ...) 5".
21:33:03 <adnauseam> s/stick it/ stick to it
21:33:12 <adnauseam> hrm
21:33:17 <dmwit> You spoke as if "(\fac x -> ...) 5" was a meaningful entity, but it isn't.
21:33:44 <dmwit> "fix (\fac x -> ...)" is a meaningful entity.
21:33:54 <adnauseam> what does the 5 do ?
21:34:02 <dmwit> It's the argument to "fix (\fac x -> ...)".
21:34:19 <adnauseam> goes into fac ?
21:34:20 <dmwit> Just as "(\fac x -> ...)" is the argument to "fix".
21:34:32 <dmwit> No, it goes into "fix (\fac x -> ...)". =)
21:34:42 <adnauseam> ;p
21:34:51 <dmwit> Let's do it by hand!
21:34:58 * adnauseam gets a pen and paper
21:35:08 <dmwit> fix (\fac x -> if x == 0 then 1 else x * fac (x - 1)) 5
21:35:11 <dmwit> Now, by definition of fix,
21:35:29 <dmwit> (\fac x -> if x == 0 then 1 else x * fac (x - 1)) (fix (\fac x -> ...)) 5
21:35:46 <dmwit> (using shachaf's simple "fix f = f (fix f)" definition, since it's less cluttered)
21:35:58 <dmwit> Now, "fac" gets bound to the whole "fix" expression...
21:36:13 <dmwit> (\x -> if x == 0 then 1 else x * (fix ...) (x - 1)) 5
21:36:21 <dmwit> ...and then "x" gets bound to "5".
21:36:30 <dmwit> if 5 == 0 then 1 else 5 * (fix ...) (5 - 1)
21:36:43 <dmwit> We can now evaluate the if statement, since 5 == 0 is False.
21:36:48 <dmwit> 5 * (fix ...) (5 - 1)
21:37:14 <dmwit> 5 * (fix (\fac x -> if x == 0 then 1 else x * fac (x - 1))) (5 - 1)
21:37:46 <dmwit> Now, I'm going to cheat and evaluate (5 - 1), even though in a typical execution that would be evaluated later.
21:37:49 <adnauseam>  5*4
21:38:05 <dmwit> 5 * (fix (\fac x -> if x == 0 then 1 else x * fac (x - 1))) 4
21:38:06 <adnauseam> 5*4 (fix (\fac x -> if x == 0 then 1 else x * fac (x - 1))) (4 - 1)
21:38:18 <adnauseam> oh
21:38:31 <dmwit> Yep, eventually this steps to
21:38:45 <dmwit> 5 * 4 * fix (\fac x -> if x == 0 then 1 else x * fac (x - 1)) 3
21:38:58 <dmwit> ...and even more eventually, to
21:39:10 <dmwit> 5 * 4 * 3 * 2 * 1 * fix (\fac x -> if x == 0 then 1 else x * fac (x - 1)) 0
21:39:15 <dmwit> Expanding fix,
21:39:33 <dmwit> 5 * 4 * 3 * 2 * 1 * (\fac x -> if x == 0 then 1 else x * fac (x - 1)) (fix ...) 0
21:39:46 <dmwit> Now we can bind "fac" and "x", as usual:
21:40:09 <dmwit> 5 * 4 * 3 * 2 * 1 * if 0 == 0 then 1 else 0 * (fix ...) (0 - 1)
21:40:20 <dmwit> This time, the if statement evaluates to True, so
21:40:25 <dmwit> 5 * 4 * 3 * 2 * 1 * 1
21:40:27 * shachaf walks away for a moment, comes back to a wall o' IRC.
21:40:37 <dmwit> And then all the (*)s fire, and we roll back up to 120. =)
21:40:47 <adnauseam> it's a good wall of explanatory goodness
21:41:04 <adnauseam> i understand :o at least when it comes to THAT lambda
21:41:10 <dmwit> =)
21:41:20 <adnauseam> is fix a higher order function ?
21:41:33 <dmwit> The right way to understand this, I think, is to try it with a bunch of different lambdas, trying each time through to skip more steps in your head.
21:41:40 <dmwit> Eventually you'll be skipping straight to the answer. =)
21:41:41 <shachaf> I would start by understanding fix (1:) :-)
21:41:46 <shachaf> Which isn't a lambda at all.
21:41:50 <dmwit> adnauseam: Yes, fix is a higher-order function.
21:41:57 <adnauseam> i still have to understand folds first:P
21:41:58 <dmwit> Any function which takes another function as an argument is higher-order.
21:42:00 <shachaf> Most functions in Haskell are higher-order.
21:42:07 <shachaf> dmwit: Or returns a function!
21:42:29 <dskippy> Can anyone recommend an image manipulation library for Haskell? I want to do some simple things like change all pixels of a given RGB to another RGB and then draw lines on the image of various colors and widths.
21:42:30 <dmwit> Hm. I suppose.
21:42:39 <dmwit> That's not really what most people mean when they say higher-order, I think.
21:42:55 <adnauseam> they are extremely interesting and versatile - my confusing is basically seeing them in one context, understanding that, then seeing them in another context where then my brain does a back flip and "wat"
21:43:26 <adnauseam> needs more reading and ghci magic.
21:43:31 <shachaf> dmwit: It is in languages other than Haskell. :-)
21:43:34 <dskippy> Most functions in Haskell are higher order? That sounds very hard to believe. You mean in the standard library or in code written in Haskell by others?
21:43:51 <dmwit> dskippy: both
21:43:52 <shachaf> dskippy: Using the definition that includes functions returning other functions.
21:44:09 <dskippy> Oh so anything that has two arguments.
21:44:13 <shachaf> Right.
21:44:15 <dskippy> Fair enough.
21:44:29 <dmwit> dskippy: I'd say most functions are higher-order even in the more restrictive sense that I mean.
21:44:48 <dskippy> That they accept other functions as arguments?
21:44:59 <dmwit> yes
21:45:07 <dskippy> That's the one I am doubting.
21:45:25 <dskippy> but I don't have a strong opinion on the matter.
21:45:51 <dskippy> I do want to find an image library that will allow me to change the color of pieces of my image though. :)
21:46:21 <dmwit> Well, there's gd, DevIL+repa, and gtk.
21:46:39 <ktklam9> am I getting the difference between partial function application and currying correct? Currying is used behind the scene by GHC , but partial function application is when you do pass something to a function R -> R -> R and get back another function that is (R -> R)?
21:46:52 <dskippy> gd doesn't have a color swap. I found the docs for it. GD in Haskell seems very simple.
21:47:07 <shachaf> ktklam9: Currying is (for example) transforming a function of type (a,b) -> c to a function of type a -> (b -> c)
21:47:31 <shachaf> ktklam9: "partial application" doesn't have a whole lot of meaning -- it mostly just means "application".
21:47:48 <ktklam9> shachaf: right, so currying is used behind the scene?
21:47:51 <shachaf> When in doubt, don't use the word "currying", because it'll get silly people mad.
21:47:58 <dmwit> dskippy: gd has "getPixel" and "setPixel", so that's color swap. =P
21:48:03 <shachaf> ktklam9: Behind which scene?
21:48:03 * Enigmagic is currying right now
21:48:06 <dmwit> Not the most convenient, but still doable.
21:48:30 <ktklam9> isn't it how Haskell allows functions to accept more than one parameter?
21:48:39 <dskippy> dmwit: Not in this Haskell package it doesn't : http://hackage.haskell.org/package/gd
21:48:49 <dskippy> Am I only reading part of the docs or something?
21:49:47 <dmwit> dskippy: http://hackage.haskell.org/packages/archive/gd/3000.7.1/doc/html/Graphics-GD.html#v:getPixel
21:49:57 <dmwit> Change the "g" to "s" for the other one. ;-)
21:50:52 <dskippy> dmwit: What! What's the diff between your link and mine? I mean apart from the fact that you're has what I want.
21:51:08 <dmwit> I see those functions at your link, too.
21:51:22 <dmwit> Under all three of the exported modules. =)
21:52:04 <dskippy> Hrm :-\ Odd
21:56:13 <dfletcher> heh shortest version of the batman program yet :)
21:56:15 <dfletcher> > take 47([0/0..]>>=show)++" Batman!"
21:56:17 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNa Batman!"
21:56:56 <dskippy> :)
21:56:57 <dfletcher> why is it the further I progress with learning haskell the shorter this program becomes? eventually I'll be able to do it in four bytes of code :P
22:01:19 <dmwit> dfletcher: http://en.wikipedia.org/wiki/Kolmogorov_complexity
22:01:42 <dmwit> See also: HQ9x+
22:02:11 <dmwit> s/x//
22:03:03 <dfletcher> heh so I can actually calculate the minimum sized program? sweet I'll write a haskell program to do it :P
22:07:56 <pdxleif> How does >>= combine List Monad and IO Monad like that?
22:08:11 <dmwit> like what?
22:08:27 <dmwit> There's just two different implementations of (>>=), one for lists, and one for IO.
22:08:37 <Enigmagic> :t show
22:08:38 <lambdabot> forall a. (Show a) => a -> String
22:08:51 <Enigmagic> no IO involved
22:09:07 <dmwit> pdxleif: Are you asking about dfletcher's code, or is the question more general?
22:13:16 * hackagebot FilePather 0.1.4 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.1.4 (TonyMorris)
22:21:30 <pdxleif> dmwit: dfletcher's code
22:21:39 <pdxleif> But in general, too, I guess
22:23:16 * hackagebot vector-th-unbox 0.1.0.0 - Deriver for unboxed vectors using Template Haskell  http://hackage.haskell.org/package/vector-th-unbox-0.1.0.0 (LiyangHu)
22:38:07 <dmwit> pdxleif: In that case, listen to Enigmagic. No IO here.
22:38:18 <dmwit> (lambdabot doesn't do IO at all)
22:38:20 <dmwit> > print 3
22:38:21 <lambdabot>   <IO ()>
22:41:11 <pdxleif> n/m - I guess I had been thinking of "print" instead of "show"
22:41:26 <pdxleif> print seems to be putStrLn . show
22:42:31 <Axman6> @src print
22:42:31 <lambdabot> print x = putStrLn (show x)
22:42:54 <pdxleif> [1..10] >>= print doesn't work - I wasn't missing something, phew
22:44:07 <pdxleif> Maybe the P in REPL throws me off as to which actions are IO
22:56:05 <adnauseam> hrm. given that y = "a", xs = ["a","b"], why does foldr (\f x -> x == y then True else f) False xs, fail ?
22:56:24 <adnauseam> > let y = "a"
22:56:25 <lambdabot>   not an expression: `let y = "a"'
22:56:31 <adnauseam> > let y = "a"
22:56:32 <lambdabot>   not an expression: `let y = "a"'
22:56:34 <adnauseam> > let y "a"
22:56:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:56:44 <adnauseam> sigh i fail
22:58:17 * hackagebot FilePather 0.1.5 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.1.5 (TonyMorris)
22:58:20 * hackagebot shakespeare 0.11 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-0.11 (GregWeber)
22:58:22 * hackagebot shakespeare-css 0.10.8 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-0.10.8 (GregWeber)
23:01:22 <adnauseam> nvm - was missing the if
23:03:24 * hackagebot shakespeare-js 0.11.2 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-0.11.2 (GregWeber)
23:03:26 * hackagebot shakespeare-text 0.11 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-0.11 (GregWeber)
23:08:18 * hackagebot wai-app-file-cgi 0.5.6 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.6 (KazuYamamoto)
23:08:20 * hackagebot hamlet 0.10.9.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.10.9.1 (GregWeber)
23:08:22 * hackagebot shakespeare-i18n 0.0.2.1 - A type-based approach to internationalization.  http://hackage.haskell.org/package/shakespeare-i18n-0.0.2.1 (GregWeber)
23:10:52 <lispy> > let y = "a" in y
23:10:53 <lambdabot>   "a"
23:10:57 <lispy> adnauseam: ^^
23:11:06 <lispy> (maybe you figured that out already)
23:18:18 * hackagebot yesod-form 0.4.2.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.4.2.1 (GregWeber)
23:18:20 * hackagebot yesod-core 0.10.2.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.10.2.2 (GregWeber)
23:18:22 * hackagebot yesod 0.10.1.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.10.1.4 (GregWeber)
23:18:24 * hackagebot zoom-cache 1.2.1.1 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-1.2.1.1 (ConradParker)
23:23:06 <lispy> update all the packages!
23:23:35 <lispy> hackagebot: you could use some better throtteling I suppose
23:23:59 <dmwit> I dunno.
23:24:12 <dmwit> Seems less disruptive to print all the updates at once.
23:26:27 <kfish> if we want fewer package updates, we should tell snoyberg and GregWeber to take a coffee break / walk the dog between each upload
23:39:42 * QinGW Have fun for haskell
23:58:19 * hackagebot shelly 0.3.0 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.3.0 (GregWeber)
