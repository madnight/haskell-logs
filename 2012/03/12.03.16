00:06:38 <rata_> Enigmagic: I was thinking about putting the project in github, but I don't think it's useful for spotting the culprit function, as it is 2k loc
00:09:39 <rata_> nobody would like to read that just to help me out with a memory like, would you?
00:12:11 <rata_> Enigmagic: the profiler results are in https://gist.github.com/2048974
00:13:35 <Enigmagic> rata_: well the profiler results aren't that interesting without the code
00:14:24 <rata_> Enigmagic: I can send you a tarball if you wish
00:14:36 <rata_> or I can upload it to github
00:15:39 <Enigmagic> github is fine
00:18:26 <Enigmagic> have you done any profiling runs other than the -hy/-hT one on gist?
00:24:25 <rata_> Enigmagic: https://github.com/rhz/KaSimHs
00:24:35 <rata_> Enigmagic: no, what others can I do?
00:25:06 <Enigmagic> rata_: are you buliding with -prof ?
00:25:16 <rata_> Enigmagic: no
00:25:58 <Enigmagic> ah, if you can rebuild your app/libraries with -prof it'll allow you to get call center stacks (sorta like a call stack) where the allocation happened
00:26:00 <rata_> I'm a newbie at large haskell projects
00:26:20 <rata_> Enigmagic: how can I see that afterwards?
00:26:38 <Enigmagic> the same way as the -hT profile results you have there
00:26:52 <Enigmagic> i normally run it through hp2pretty and open it up in a web browser
00:28:16 <rata_> Enigmagic: I only have hp2ps
00:28:30 <Enigmagic> they're the same really except hp2pretty is faster and outputs svg instead of ps
00:30:08 <rata_> which package hp2pretty belongs to?
00:30:20 <Enigmagic> @hackage hp2pretty
00:30:20 <lambdabot> http://hackage.haskell.org/package/hp2pretty
00:31:03 <rata_> aha
00:31:17 <rata_> I thought first it was part of hp2any
00:33:22 <rata_> I'm reinstalling the libraries I use with profiler support now
00:34:08 <Enigmagic> cool
00:35:52 <rata_> indeed hp2pretty is prettier
00:38:44 <Baikonur> my function stopped working while i was sleeping
00:38:47 <Baikonur> what is this
00:40:30 <Baikonur> mm, actually all my functions stopped working
00:52:14 <rata_> Enigmagic: after compiling with -prof, I just run using -hT?
00:53:58 <rata_> I used -hc -T
00:56:22 <rata_> Enigmagic: here are the profiler results using -prof and -hc -T https://gist.github.com/2049038
00:58:37 <Enigmagic> rata_: heh uh try using "-prof -auto-all -caf-all" :)
01:03:50 <rata_> Enigmagic: aha, much better =) thanks
01:04:57 <rata_> but now that I now the main responsible functions, what can I do to solve the problem?
01:05:14 <Enigmagic> rata_: which function is it?
01:05:26 <rata_> updateVec in Misc.hs
01:05:49 <rata_> why are those data structures not being gc'ed?
01:06:41 <rata_> Enigmagic: https://gist.github.com/2049061
01:07:03 <Enigmagic> rata_: http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector.html#v:force
01:09:27 <rata_> Enigmagic: thank you very much =) I'll try putting some force in there.. but I first must think about where to put them, because perhaps putting that in updateVec isn't the most performant solution
01:10:28 <Enigmagic> yah, but it might be worth checking to see if it fixes the problem first before trying to make it fast
01:14:52 <rata_> Enigmagic: it doesn't solve it
01:16:10 <rata_> Enigmagic: https://gist.github.com/2049084
01:18:12 <rata_> that was putting a Data.Vector.force in front of the unsafeUpd
01:23:07 <Enigmagic> rata_: try changing SiteGraph.hs:102 to Map.foldrWithKey'
01:26:13 <rata_> Enigmagic: a bit better, but still the problem is there
01:26:23 <rata_> should I strictify every fold?
01:27:03 <Enigmagic> rata_: generally with those types of operations (updating a single value repeatedly) it's desirable to have it be strict
01:27:21 <rata_> ok
01:27:55 <rata_> I already did the conversion, but as I didn't see any improvement, I came back to the lazy ones
01:30:03 <rata_> Enigmagic: in fact, strictifying every fold in State.hs doesn't help
01:30:11 <rata_> just tried it
01:30:40 <Enigmagic> rata_: you may need to make the FragHeap constructor strict in the Vector field too
01:31:18 <Enigmagic> otherwise i'd look at the other heap profiling options to see if you can get a handle on where it is
01:31:26 <Enigmagic> i need to go to bed though, getting late here.
01:33:21 <rata_> Enigmagic: ok, thank you very much
01:33:41 <rata_> btw, how do I get around an "Unexpected strictness annotation" error?
01:34:09 <Enigmagic> put them on the variables not the types
01:34:21 <Enigmagic> and enable -XBangPatterns or {-# LANGUAGE BangPatterns #-}
01:34:53 <Enigmagic> or if it's a record field type you may need to add parens
01:35:02 <rata_> ok
01:35:05 <Enigmagic> like !(Maybe a) rather than !Maybe a
01:35:29 <rata_> with parens it worked
01:35:50 <rata_> (didn't have to use the BangPatterns)
01:35:59 <rata_> is that the way to do it right?
01:36:17 <Enigmagic> yeah unless you're trying to add strictness annotations to a function then you need bang patterns
01:36:25 <Enigmagic> or to use the `seq` operator
01:36:26 <rata_> ok
01:36:56 <Enigmagic> anyways, good luck. figuring out space leaks is harder than it should be :|
01:37:14 <rata_> ok, that didn't help, I'll look at the other profiling options, thank you very much =)
01:59:29 <unlink> What is the idiom for repeatedly executing monad actions that may signal for early termination of the loop?
02:00:25 <unlink> I am using Control.Monad.Loops and doing something like: unfoldM_ $ runMaybeT $ do { action ; Just val <- anotherAction ; ... } and using Maybe's fail method to terminate the loop.
02:05:01 <Peaker> unlink: MaybeT is a good way to do it.. EitherT if you want to carry information with the loop termination
02:10:13 <jaspervdj> blackdog: Did you solve your issue or do you need some assistance?
02:11:17 <unlink> Peaker: Thanks... I was just surprised that what seemed like a fundamental idiom required reaching so far from the Prelude...
02:11:58 <Peaker> unlink: well, loops with "termination" here is an imperative programming concept -- and those are generally buried pretty deep in the libraries
02:12:13 <Peaker> unlink: the functional equivalents don't require any transformers
02:12:44 <unlink> Peaker: of course not. But every now and again one needs to write imperative code O:-)
02:13:44 <Peaker> unlink: well, importing stuff from deep libraries is fortunately easy :)
02:34:11 <QinGW> @info _mapM
02:34:11 <lambdabot> _mapM
02:36:10 <merijn> Did you mean mapM_ by any chance?
02:37:15 <geekosaur> alos there is no @uinfo
02:39:34 <geekosaur> er, @info (it's edit-correcting to something that just echos back at you)
02:44:05 <nart> hi
02:54:27 <gbacon> how do I get a handle on the default implementation of the Trav monad in Language.C.Analysis.TravMonad?
02:58:24 <rostayob> gbacon: look at the instances
03:01:11 <augur> any good videos recently?
03:01:18 <gbacon> rostayob: ?
03:02:15 <gbacon> rostayob: the package readme says to see the examples directory, but it doesn't exist
03:04:45 <rostayob> gbacon: http://hackage.haskell.org/packages/archive/language-c/latest/doc/html/Language-C-Analysis-TravMonad.html#t:MonadTrav
03:05:33 <nart> how can i create a monad that derives the Reader and State monad and add custom methods to it ?
03:06:30 <rostayob> nart: your question is not that clear. I guess you want a new class like "class (MonadReader r m, MonadState s m) => MonadSomething ... where ..."
03:08:32 <rostayob> or do you want to derive automatically MonadReader and MonadState instances?
03:08:40 <nart> that's it
03:09:04 <nart> i want to derive them automatically
03:09:05 <rostayob> nart: the latter?
03:09:06 <rostayob> well
03:09:07 <danr> you can do that with GeneralizedNewtypeDeriving
03:09:11 <rostayob> what's your datatype?
03:09:28 <rostayob> yeah if it's just a newtype that wraps a StateT and a ReaderT you can do what danr said
03:09:33 <gbacon> rostayob: that module defines a Trav newtype, http://hackage.haskell.org/packages/archive/language-c/latest/doc/html/Language-C-Analysis-TravMonad.html#g:10
03:10:00 <nart> mmm ok i'm already using it
03:10:11 <rostayob> gbacon: yes, which is a MonadTrav
03:10:59 <nart> i think i'll to re-read the guide on monad, something isn't clear to me :S
03:11:06 <nart> thanks anyway
03:11:35 <gbacon> rostayob: but the module doesn't make a constructor available
03:12:21 <rostayob> gbacon: why would you need that?
03:14:51 <gbacon> rostayob: maybe an XY problem here. I want to experiment with Trav, but I don't see an a -> m a to get a handle on one
03:15:20 <quicksilver> gbacon: well "return 1" :: Trav s Int has that type
03:15:31 <quicksilver> there are lots of ways of creating values of a monad
03:15:43 <rostayob> gbacon: just write your functions with the MonadTrav (and Monad) functions, and then there should be a function to run the Trav monad
03:15:49 <quicksilver> with Trav you've got all its instances
03:16:05 <quicksilver> so the methods of Monad, MonadTrav, MonadName, MonadCError and MonadSymTab
03:16:12 <quicksilver> all give you ways to "Create" Trav values
03:16:56 <nart> i have this type    type Net = ReaderT Bot IO   newtype EventNet a = EN {unEN :: StateT MyState Net a}       deriving (Monad,MonadState MyState,MonadReader Bot,MonadIO)  type MyState = Map.Map String (String -> EventNet ())
03:17:19 <nart> mm maybe i'll use hpaste
03:17:58 <nart> http://hpaste.org/65389
03:18:07 <nart> how can i declare a typeclass for it ?
03:18:28 <quicksilver> why would you want to, nart?
03:18:33 <quicksilver> what would be the value of this new typeclass?
03:19:17 <nart> i would like to add methods inside the monad, just like the State monad has the ask method, or am i doing it wrong ?
03:19:52 <quicksilver> you might be doing it wrong :)
03:19:57 <danr> nart: You can use ask (from Reader) and put/get from State on your EventNet since they will be instances of MonadState and MonadReader as you have derived
03:20:06 <quicksilver> what makes you think you want to add methods and not just functions?
03:20:33 <quicksilver> I mean, you could certainly write "class MyEventNetClass where ... some methods ..." but I'm trying to ask you what your objective is.
03:21:09 <quicksilver> if you just want to define your own special purpose stuff ("combinators" people might call them) then you can just define them as functions on EventNet
03:21:24 <quicksilver> no need for a class unless you want to use the polymorphism somehow - by having more than one instance, e.g.
03:21:42 <nart> ah ok
03:22:58 <nart> but if i want to have, ex a function called broadcast, that when i call it inside the monad, alter the state of the monad and do other stuff
03:23:10 <quicksilver> sure
03:23:16 <quicksilver> no need for classes or methods.
03:23:35 <quicksilver> broadcast x = do ... alter state ... do stuff ...
03:24:13 <nart> and i can run it also inside another function ?
03:24:24 <nart> and alter the state of the function outside ?
03:24:45 <rostayob> I disagree with quicksilver, writing generic code expecially with  monad transformers makes it nicer
03:24:49 <rostayob> you don't have to lift etc.
03:25:00 <rostayob> (if I understood correctly what quicksilver is saying)
03:25:13 <quicksilver> rostayob: I'm saying nart doesn't need to define his own class
03:25:19 <rostayob> oh, ok.
03:25:24 <rostayob> but he should use the existing ones, right?
03:25:25 <quicksilver> rostayob: he can just write functions.
03:25:28 <quicksilver> of course.
03:25:31 <rostayob> ah ok.
03:25:40 <rostayob> I thought that was his goal from the beginning?
03:25:44 <quicksilver> nart: yes, this is "the whole point"
03:25:52 <quicksilver> rostayob: he said he wanted to "Add methods"
03:26:01 <quicksilver> I'm trying to explain that typeclasses and methods are for polymorphism
03:26:09 <quicksilver> for his custom type he doesn't need to "Add methods"
03:26:22 <quicksilver> although he should certainly use the existing methods of MonadState and MonadReader as his building blocks.
03:26:31 <rostayob> ok, good :)
03:26:34 <nart> thanks for the explanation
03:50:45 <lifestream> Aaah, haskell is so complicated. One minute I understand it, the next I'm completely lost
03:58:34 <hvr> lifestream: it gets better with time
04:06:52 <lifestream> It's good that there's so many different places to get information from.. couldn't understand something in the Hitchhiker's Guide to Haskell, so now I watch a C9 haskell lecture on higher-order functions.
04:07:36 <Zarathu> lifestream: Link?
04:08:11 <lifestream> http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell    http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/
04:09:03 <lifestream> I've tried reading so many books and tutorials, Hitchhiker's the only one that's sticking in my brain :)
04:13:11 <hvr> lifestream: you tried also LYAH?
04:14:38 <lifestream> Yes hvr, and gentle introduction, and real world, I can't remember the information on them because the examples don't have a "purpose". It's like learning your ABCs before learning how to speak!
04:15:51 <lifestream> This page is a gold mine in my eyes :)  http://www.haskell.org/haskellwiki/Meta-tutorial
04:17:43 <srhb> lifestream: How far in are you? I think I get where you're coming from, but you'll probably benefit from jumping to the later chapters in LYAH or RWH once you've got the basics down.
04:20:16 <lifestream> srhb, Honestly, I just got to the end of chapter 2 in the Hitchhiker's. But I feel like I've learned a lot more from it than the other books. Yeah, I'll probably head to the more advanced chapters of LYAH/RWH once I've learned a bit more. We'll see.
04:20:33 <lifestream> I'm sure each book has different things to learn from
04:25:29 <srhb> lifestream: No doubt about that. :) I'll be interested to hear if you can actually write a single program after Hitchhiker's, because I think I would not havebeen able to. :D
04:28:34 <lifestream> Hmm, think I'll be able to make my "mpd playlist duplicate song cleaner", even the first 2 chapters gave some hints how I may do that ;-D
04:34:45 <nart> hi
04:51:58 <hoo> hey
04:52:25 <lifestream> Hello hello
05:00:39 <Tesseraction> on this page http://www.haskell.org/haskellwiki/State_Monad#Complete_and_Concrete_Example_2
05:00:49 <Tesseraction> how does getNext know what (\st) represents?
05:02:02 <quicksilver> Tesseraction: because of the type of "state"
05:02:48 <Tesseraction> So is it generally advised to use lamba calc to work with similar functions?
05:03:15 <quicksilver> no.
05:03:38 <quicksilver> that example is just an example of some of the different things you can do.
05:03:46 <Tesseraction> Ah, then how would you go about defining the same function without using lambda calculus?
05:03:56 <quicksilver> "state" is not the generally advised way of using the state monad.
05:04:10 <Tesseraction> Oh?
05:04:14 <quicksilver> the normal way to write getNext would be
05:05:20 <quicksilver> do st <- get; put (nextState st); st' <- get; return (valFromState st')
05:05:23 <quicksilver> or somethign liek that
05:05:32 <quicksilver> Tesseraction: that code looks like it was written by someone very new to haskell.
05:05:48 <Tesseraction> Bah.
05:05:51 <quicksilver> a haskell programmer would never write "nextState(st)" or "valFromState(st')"
05:06:08 <Tesseraction> What would they write?
05:06:10 <funktronic> fold is your friend
05:06:21 <quicksilver> "nextState st" and "valFromState st'"
05:06:27 <Tesseraction> oh, duh
05:06:29 <quicksilver> the () around single values are pointless
05:06:40 <quicksilver> that's not haskell syntax for function calls
05:06:40 <Tesseraction> yeah, I should've known that myself
05:06:51 <quicksilver> looks like a slightly confused C/Python/PHP/whatever programmer
05:07:01 <quicksilver> which is not a problem, incidentally, but makes that an odd code example
05:07:25 <quicksilver> the most "normal" way to write state monad code is to use do notation, get, and put
05:07:30 <quicksilver> (and perhaps modify)
05:07:41 <quicksilver> the special combinator "state" is a way to combine all three of those
05:07:45 <quicksilver> and it is useful sometimes.
05:08:07 <quicksilver> I'm not sure if the author was making a point by using it, quite possibly, but I don't know what the point was )
05:08:10 <quicksilver> :)
05:08:42 <Tesseraction> Yeah, I have to admit that most State examples I find seem to have oddities.
05:08:52 <rs46> I'm trying to profile my code. When I compile with -prof -auto-all , and run with +RTS -prof I only see: "CAF  Main 48 16 100.0". It doesn't show any functions called within main ?
05:08:53 <Tesseraction> My particular favourite is the ones that don't even compile.
05:09:07 <srhb> Tesseraction: That sounds awesome. :P
05:09:24 <Tesseraction> Yep, "look how easy the State monad is! *gives broken code*"
05:09:31 <srhb> Haha.
05:09:33 <Tesseraction> And I sit at home pulling my hair out.
05:10:02 <quicksilver> rs46: did you recompile everything with -auto-all?
05:10:15 <quicksilver> you will need to force that, it doesn't happen automatically.
05:10:22 <nart> if i'm inside a monad, how can i run a function, ex Map.insert that returns a Maybe ?
05:10:33 <quicksilver> you just run it nart
05:10:39 <quicksilver> need more context to answer the question
05:10:43 <nart> yep sorry
05:10:44 <quicksilver> can you post code which doesn't work?
05:11:49 <nart> -.-' found the mistake, it was so stupid
05:16:16 <unlink> Which haskell-mode indentation package is the best maintained?
05:17:11 <unlink> ...or perhaps, none particularly well...
05:18:18 <nart> why is this http://hpaste.org/65396 ? :(
05:18:33 <d-snp> is this oleg guy such a bad ass?
05:19:32 <david80> Hello! I have a some code that slows down after a while and I'd like to profile it but it appears I don't have the correct Prelude available for profiling. I have the ubuntu package installed. Any suggestsions? Thanks!
05:20:29 <zhulikas> @hoogle get
05:20:29 <lambdabot> Prelude getChar :: IO Char
05:20:30 <lambdabot> System.IO getChar :: IO Char
05:20:30 <lambdabot> Prelude getContents :: IO String
05:20:33 <d-snp> nart: you don't supply the map to Map.Insert?
05:20:38 <d-snp> or am I getting it wrong..
05:20:47 <nart> omg
05:21:03 <nart> you're right
05:21:19 <nart> i completely overlooked that detail
05:21:43 <nart> thanks
06:18:28 <eacameron> curiosity - where's Haskell Prime these days? According to http://hackage.haskell.org/trac/haskell-prime/wiki, Haskell 2010 is the latest??
06:20:05 <srhb> eacameron: There were not enough serious and well-defined proposals to make Haskell 2011
06:20:31 <srhb> eacameron: http://www.haskell.org/pipermail/haskell/2011-January/022497.html
06:21:59 <Entroacceptor> mm_freak: I just clicked on your website, and you forgot to tell the browser you're using utf-8, the umlauts are all broken :)
06:22:10 <mm_freak> Entroacceptor: i haven'
06:22:19 <mm_freak> Entroacceptor: i haven't updated it for a long time
06:22:36 <mm_freak> right now i'm making a new website based on yesod‚Ä¶  until then you'll have to live with it =)
06:22:43 <Entroacceptor> but you still have it in your sig :)
06:22:56 <eacameron> srhb: Ahh...very helpful, thanks. I guess that's a good sign that people aren't chafing to change things.
06:23:03 <mm_freak> Entroacceptor: SEO =P
06:23:09 <Entroacceptor> pfft
06:23:22 <Entroacceptor> otoh maybe one can patch hakyll to throw warnings :)
06:23:42 <mm_freak> hakyll has changed almost entirely since that time
06:24:22 <mm_freak> i'm pretty sure my old site code doesn't even compile anymore with the current version of hakyll
06:35:23 <mauke> > [0, -0, 1 / 0, 1 / -0]
06:35:24 <lambdabot>   Precedence parsing error
06:35:24 <lambdabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
06:35:30 <mauke> > [0, -0, 1 / 0, 1 / (-0)]
06:35:30 <lambdabot>   [0.0,-0.0,Infinity,-Infinity]
06:46:45 <nand`> A prefix on the second argument of an infix and postfix on the first argument of an infix really shouldn't be throwing a precedence parsing error
06:48:24 <ksf> does ghc do stack traces by now?
06:48:32 <ksf> ...call stack, that is.
06:49:36 <ksf> oh, -xc
06:53:37 <ksf> ...it'd be great if profiled and unprofiled ways would be interlinkable, btw.
07:01:43 <BRampersad> hello haskies
07:05:41 <elemir> http://img1.liveinternet.ru/images/attach/b/0/22599/22599375_normal_hasky2.jpg
07:05:45 <blackdog> jaspervdj: think i got it - just isn't an obvious yesod guide. will try to move it across from pusherapp tomorrow.
07:06:18 <elemir> HASKIES. Bow-wow-wow
07:11:51 <nart> hi
07:17:51 <mekeor> hi nart
07:31:37 <unlink> Is this intended behavior? System.Posix> getAnyProcessStatus False False
07:31:37 <unlink> *** Exception: getGroupProcessStatus: does not exist (No child processes)
07:33:06 <unlink> :type System.Posix.getProcessStatus
07:33:09 <hpc> unlink: looks like it isn't
07:33:17 <hpc> getAnyProcessStatus :: Bool -> Bool -> IO (Maybe (ProcessID, ProcessStatus))Source
07:33:20 <hpc> getAnyProcessStatus blk stopped calls waitpid, returning Just (pid, tc), the ProcessID and ProcessStatus for any child process if one is available, Nothing otherwise. If blk is False, then WNOHANG is set in the options for waitpid, otherwise not. If stopped is True, then WUNTRACED is set in the options for waitpid, otherwise not.
07:33:34 <hpc> it shouldn't throw exceptions at all
07:33:48 <unlink> I get that result on Darwin and Linux
07:34:09 <hpc> i get it here
07:34:38 <hpc> find an email or bugtracker to report it to
07:34:52 <hpc> it definitely looks wrong
07:36:02 <CQ> is there anything like glade for haskell HTML design?
07:36:57 <hpc> CQ: don't think so
07:37:20 <CQ> I found this http://snapframework.com/about but thats about it...
07:37:27 <hpc> and having used glade, i hope not :P
07:37:47 <CQ> lol
07:38:09 <hpc> snap isn't like glade at all
07:38:18 <hpc> unless im horribly misunderstanding what you want that glade does
07:38:41 <hpc> you want WYSIWYG yes?
07:39:11 <CQ> if I can get it sure, else something like codeigniter...
07:39:35 <CQ> just trying to find pieces to help develop a web application with a DB backend ...
07:39:52 <hughfdjackson> CQ: those two things are very different, quite seperate concerns
07:40:08 <hughfdjackson> if i'm understanding you right
07:40:20 <hpc> codeigniter's website is seriously wtf
07:40:29 <hpc> the userguide is a copy of the sales pitch on the front page
07:40:35 <hpc> with no other links to anything guide-like
07:40:36 <CQ> hughfdjackson: yes. one is more front end, one is back end
07:40:51 <hughfdjackson> CQ: in terms of wysiwyg - i wouldn't got that way
07:40:55 <hughfdjackson> *go
07:41:15 <hpc> honestly, im not sure if you really want WYSIWYG HTML anyway
07:41:27 <hughfdjackson> what hpc said
07:41:29 <hughfdjackson> it never ends well
07:41:45 <hughfdjackson> they become inflexible, and generate (generally) markup that interfaces poorly with other tools you might chose to use
07:41:52 <CQ> hughfdjackson: how would you go about it then? design the front end by hand, but what framework for the back end stuff like user authentication, db interaction, etc.?
07:41:56 <hpc> just learn some html, install the web developer toolbar for firefox, and use the edit html thingy to make live edits to a page
07:42:02 <hpc> when you like what you have, code it up
07:42:07 <hughfdjackson> much better to go with a templating language that compiles to html, or just html, and css
07:42:17 <hughfdjackson> perhaps again, a tool (like stylus) that compiles to css
07:42:29 <hpc> i wouldn't go with a templating language either
07:42:33 <hughfdjackson> CQ: in terms of haskell, i can't comment ^^ i'm a newbie here
07:42:40 <hughfdjackson> my day job is js/html/css
07:42:45 <hughfdjackson> w/ emphasis on the js
07:42:52 <hughfdjackson> :P basically front-end deving
07:43:13 <CQ> hughfdjackson: so am I, I'm trying to find a project that makes sense to do in haskell, and is useful at the same time
07:43:14 <hpc> heh, my job is pretty much the whole stack
07:43:19 <hughfdjackson> hpc: hehe
07:43:24 <hpc> from js to database and .htaccess trickery
07:43:28 <hughfdjackson> CQ: hehe
07:43:34 <hughfdjackson> i was very much in the same position
07:43:39 <hughfdjackson> now most of my spare time is gone, less so
07:43:46 * hughfdjackson *will* get around to a json parser at some point
07:43:52 <hughfdjackson> that's not useful, i know, but it is interesting
07:44:05 <hpc> CQ: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=5 -- here's one approach to generating html in haskell
07:44:08 <CQ> theres a JSON parser in the RWH book
07:44:17 <hughfdjackson> :3 oh, there is, is there?
07:44:19 <hpc> disclaimer: that page is in SERIOUS need of some editing, as it's one of the first that i wrote
07:44:23 <hughfdjackson> i'll give it a look
07:44:45 <CQ> http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html
07:45:40 <hughfdjackson> CQ: very much appreciated :)
07:45:42 <CQ> my alternative is to skip the HTML part for now and work on command line stuff, usign parsec and dumping into a DB
07:46:09 <amstan> i'm on arch, is there a way to get haskell-platform without going to the aur? i'm on a really slow comp and i would prefer if i didn't compile it
07:46:43 <hughfdjackson> :D yay, his type declaration looks like mine
07:46:59 * hughfdjackson isn't entirely sure type declaration is .. on point, terminology-wise, or semantically
07:47:13 <CQ> hpc: thanks for the link, I'll probably stay away from html for a little while at first though than
07:47:19 <CQ> s/than/then/
07:47:57 <hpc> amstan: wow, that's annoying
07:48:03 <hpc> amstan: i can't find a binary either
07:48:22 <amstan> hpc: there's a ton of haskell packages in the repo, just not the platform one
07:48:26 <amstan> is that just a metapackage or something?
07:48:28 <CQ> amstan: sie virthualbox, install a minimal debian or ubuntu, and use hakell there?
07:48:37 <rostayob> amstan: I gather that arch decided to go with the most recent GHC, thus there is no HP
07:48:40 <rostayob> just the packages
07:48:41 <CQ> sie??? use...
07:48:53 <amstan> CQ: this comp takes like 10 seconds to alttab, vm is not an option
07:49:04 <hpc> amstan: old eeePC?
07:49:06 <hpc> :P
07:49:09 <rostayob> amstan: if you want to user the HP you'd have to reinstall GHC as well
07:49:18 <rostayob> just use the individual packages
07:49:27 <amstan> hpc: nah, work comp that i was promised will be replaced within a week, yet 2 months have passed
07:49:29 <hpc> what they said, individual packages
07:49:39 <stefanooldeman> ]
07:50:23 <hpc> http://lambda.haskell.org/platform/doc/current/index.html -- here's a list of the modules/packages in the current haskell platform
07:50:42 <hpc> (oh hey, that's me all the way at the bottom :P)
07:53:04 <rostayob> he's goe
07:53:06 <rostayob> *gone
07:53:43 <hpc> oh, that explains why his computer was so slow
07:53:46 <hpc> he's using kde
07:53:55 <hpc> "Quit: Konversation terminated!"
07:54:11 <hpc> (im only half-joking)
07:54:25 <hiptobecubic> I am trying to use System.Random.MWC but I don't understand how to use it in a pure function. I guess it has to run in the ST monad? I've never done that before.
07:54:43 <rostayob> hpc: joking? i'm pretty sure that's the reason why
07:54:47 <rostayob> alt-tabbing takes 10 seconds
07:54:57 <rostayob> it has to animate all the bling
07:55:30 <hpc> hiptobecubic: yeah, has to run in ST
07:55:32 <hpc> :t runST
07:55:33 <lambdabot> forall a. (forall s. ST s a) -> a
07:55:58 <hpc> hiptobecubic: the scary type just says "STRefs can't escape the action they are run in"
07:56:08 <hpc> other than that it's more or less just State, only cooler
07:58:02 <mauke> I don't think it's like State
07:58:06 <hiptobecubic> hpc, I am trying to make a brownian motion, so I just need a string of random variates from a standard normal. System.Random is too slow so I'm trying to convert my program to use MWC
07:58:22 <CQ> how do people program haskell? ghci? or use IDEs? or vim and load? or ... ?
07:58:29 <mauke> State gives you a single implicit mutable variable
07:58:40 <hiptobecubic> CQ, all of the above i think
07:58:42 <conal> CQ: emacs with a haskell mode
07:58:53 <CQ> conal: sorry, anything but emacs :)
07:58:57 <hiptobecubic> CQ I use vim with haskell-mode  :)
07:59:03 <mauke> ST lets you create mutable variables but you have to pass them around explicitly
07:59:05 <rostayob> CQ: why? anyway, vim has an haskell-mode too
07:59:09 <hpc> CQ: all of the above
07:59:12 <conal> including running ghci inside emacs
07:59:18 <hpc> though not so much IDE use
07:59:34 <conal> CQ: understood. emacs is a lot to bite off.
07:59:43 <rostayob> mauke: it's still a state but with the concept of references
08:00:45 <rostayob> you could implement ST yourself with a Map or whatever
08:01:10 <quicksilver> I'm with mauke
08:01:17 <quicksilver> ST is essentially entirely unlike State.
08:01:23 <td123> rostayob: haskell-mode isn't developed anymore afaik
08:01:34 <rostayob> td123: it isn't?
08:01:35 <quicksilver> ST is a mutable heap which lets you allocate new variables at will
08:01:37 <hiptobecubic> td123, i'm using it and it's working just fine
08:01:41 <quicksilver> (and also there is some array stuff)
08:01:50 <td123> hiptobecubic: I didn't say it doesn't work :P
08:01:51 <hiptobecubic> ok but how does it *work*.
08:01:52 <elemir> vim haskellmode is slower than yi
08:02:35 <td123> otoh though, vim does have neco-ghc and ghcmod-vim which are imo really good and they're both actively developed :)
08:03:07 <mauke> processes don't need syscalls to read/write their own memory. this is ST.
08:03:16 <rostayob> quicksilver: it works in a similar way a state works
08:03:18 <hiptobecubic> Is it possible to generate a list of random numbers in ST and then pass them to a function that isn't in ST? or is everything that depends on them requied to be in ST as well
08:03:20 <rostayob> a state monad
08:03:35 <mauke> hiptobecubic: no, see runST
08:03:56 <hiptobecubic> mauke, oh right. ok. I guess I'll look for some code examples
08:04:21 <quicksilver> rostayob: it does not work in a similar way.
08:04:28 <quicksilver> rostayob: it works in an entirely different way
08:04:31 <rostayob> quicksilver: conceptually it does
08:04:32 <quicksilver> also it exposes different primitives
08:04:38 <quicksilver> conceptually schmonceptually
08:04:40 <mauke> rostayob: disagree
08:04:42 <quicksilver> it's just *different*
08:04:51 <quicksilver> State lets you get/put a single variable of fixed type
08:05:01 <quicksilver> ST lets you create new variables of abitrary type
08:05:03 <quicksilver> and pass them around
08:05:06 <mauke> and that variable is global
08:05:09 <quicksilver> these two things are really very different.
08:05:24 <quicksilver> (and as it happens they are implemented utterly differently, although I agree that is less important)
08:05:51 <rostayob> type STRep s a = State# s -> (# State# s, a #)
08:05:54 <rostayob> this si what similar to me
08:05:56 <rostayob> *is
08:05:58 <rostayob> *what's :P
08:06:14 <mauke> that's not even haskell
08:06:56 <monochrom> except State# is a phantom type, does not store anything, only there for evaluation order
08:07:30 <quicksilver> rostayob: that's utter rubbish
08:07:43 <quicksilver> rostayob: if you ever, ever paste that line in this channel I will ban you.
08:07:48 <quicksilver> (that part is a joke :P)
08:07:58 <mauke> I don't get it
08:08:00 <quicksilver> it's not haskell, it's not a real thing, it's not a real function
08:08:08 <quicksilver> and it's a poor model for how ST works.
08:08:32 <rostayob> quicksilver: ok, whatever, I'm just saying that you can implement an ST with a map and coercing the values, that's all
08:08:42 <quicksilver> yes, you can do that, rostayob.
08:08:47 <quicksilver> you can also implement haskell in C
08:08:50 <quicksilver> by writing a haskell interpreter
08:08:55 <quicksilver> this doesn't make haskell the same as C
08:09:00 <quicksilver> and it doesn't make ST the same as State :)
08:09:36 <mauke> rostayob: you need at least a record with a polymorphic map and a fresh name generator
08:09:45 <rostayob> I think the difference between a state and ST is greater than the difference between haskell and C :P
08:09:53 <quicksilver> good, then we agree.
08:09:59 <rostayob> I mean, there's a "state" in ST
08:10:12 <hiptobecubic> I am confused here.    (standard gen) can produce a standard normal variate
08:10:25 <rostayob> I didn't mean it's the same as StateT
08:10:29 <hiptobecubic> but it gets it's randomness from the ether in the monad i guess
08:10:36 <hiptobecubic> its*
08:10:40 <rostayob> but you are carrying around some state
08:11:21 <osager> hi all
08:11:24 <monochrom> I recently found that the "X -> (X,a)" trick for ordering evaluation (again, X is a phantom type, does not store anything) was first introduced by someone I have known for a while in his PhD thesis. D. Hugh Redelmeier, "Towards Practical Functional Programming"
08:11:31 * hackagebot persistent-template 0.8.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.8.2 (MichaelSnoyman)
08:11:35 <hiptobecubic> So I want to create an entire list of this, can i  (iterate (\_ -> standard gen) 0)? ghci won't let me but maybe that's a quick from being in the interpreter
08:11:36 <osager> i have a mutually recursive function, i dont know when it stops
08:12:02 <osager> one of the functions f1 terminiates with zipWith (someFunction) [] []
08:12:21 <osager> will zipWith [] [] empty list stops the program ?
08:12:47 <hiptobecubic> should return []
08:12:47 <quicksilver> well zipwith on two empty lists returns the empty list
08:12:54 <quicksilver> that "stops the recursion"
08:12:57 <quicksilver> it doesn't "Stop the program"
08:13:08 <quicksilver> > zipWith const [] []
08:13:09 <lambdabot>   []
08:13:21 <osager> ok that's what i mean, because the recursive function is inside zipWith
08:13:30 <osager> OK so that will stop the recursion
08:13:35 <osager> that's what i want to know
08:14:04 <rostayob> quicksilver: spj original paper actually uses the same analogy
08:15:07 <quicksilver> rostayob: which? the mutable heap? or the RealWorld# token? or?
08:15:43 <monochrom> spj original paper uses and immediately renounces it. read the text again.
08:15:44 <rostayob> quicksilver: http://i.imgur.com/LHWU6.png
08:16:18 * quicksilver nods
08:16:23 <rostayob> monochrom: oh well, ok. I actually never read but I remember that page
08:16:28 <rostayob> it made sense to me
08:16:33 <quicksilver> but "state indexed by type s" is a subtle notion
08:16:41 <quicksilver> "indexed by type" is clever - and it's the point
08:16:43 <rostayob> "renounces it" from a practical point of view?
08:16:52 <quicksilver> and it's rather different from State with a capital S
08:16:55 <quicksilver> (the standard haskell monad)
08:17:31 <rostayob> still, that what I meant
08:18:20 <rostayob> "The "ST" stands for a "state transformer" which we take to be synonymous with "a stateful computation""
08:18:38 <mauke> the "state" there is not your state
08:18:43 <rostayob> what's my state?
08:18:48 <mauke> a map
08:18:59 <rostayob> what the state "is" is unspecified
08:20:37 <quicksilver> "stateful computation" in that paper means "computation using an unbounded set of (dynamically allocated) strongly typed mutable variables"
08:20:49 <monochrom> "I will say in Section 3.1 why I don't think this view of IO actions as functions is entirely satisfactory"
08:20:49 <quicksilver> it means "stateful like you can be in C-like languages"
08:21:05 <quicksilver> I'm not trying to say that ST is not stateful :)
08:21:19 <nart> are there any tutorials that explain how to create a DSL like languages like the one that uses Hakyll or Xmonad ?
08:21:22 <quicksilver> the assertion I was disagreeing with is that ST is like State (capital S, the specific haskell monad)
08:21:32 <rostayob> mah not really, he says "What the, is a "State"? Part of every state is a mapping from references to values"
08:22:12 <quicksilver> yes
08:22:18 <quicksilver> I'm not sure what you mean by "not really"
08:22:19 <monochrom> oh, the lazy state thread paper?
08:22:31 <quicksilver> is that somehow inconsistent with what I just said?
08:22:38 <rostayob> quicksilver: it doesn't have to be the same model as C
08:22:49 <quicksilver> oh this is a really frustrating discussion
08:22:53 <quicksilver> I'm not sure I can be bothered.
08:22:55 <rostayob> in which the references are just pointers
08:23:10 <hiptobecubic> Ok so I can make one number now :)   But how does one create many? I don't see how this would work.  iterate doesn't seem right
08:23:21 <quicksilver> hiptobecubic: replicateM ?
08:23:25 <mauke> nart: I wasn't aware xmonad had a dsl
08:23:37 <quicksilver> I'm not saying exactly like C
08:23:42 <quicksilver> I was just saying, mutable variables.
08:23:50 <hiptobecubic> quicksilver, i'll look. thanks
08:23:52 <quicksilver> ST gives you dynamically allocatable strongly typed mutable variables.
08:24:21 <quicksilver> and lets you run computations in that minilanguage as part of a pure function.
08:24:50 <rostayob> yeah. I don't see why a view in which there's a state mapping references to values is so absurd.
08:24:53 <nart> mauke: maybe i'm wrong, but the Hakyll website says that the software is using "an xmonad-like DSL for configuration."
08:26:11 <Clint> if you think a set of haskell types and functions are dsl-like
08:26:14 <quicksilver> rostayob: it's not absurd.
08:26:24 <quicksilver> rostayob: did anyone say it was?
08:27:09 <rostayob> quicksilver: well that's what I argued and you disagreed :). anyways, it doesn't matter.
08:27:39 <acowley> Why do neither of the priority search queue implementations on hackage have a Monoid instance? (Side question: they seem similar, why are there two?)
08:28:52 <quicksilver> rostayob: I disagree with two things (1) that ST and State are the same, or even similar (2) that State# should ever be mentioned or used as part of an argument.
08:29:19 <quicksilver> I certainly don't disagree that ST models stateful computations, or that a mapping form references to values is part of its natural semantic model.
08:30:01 <rostayob> quicksilver: I never argued that ST and State are the same. I never even capitalised State.
08:32:06 <rostayob> for what concerns point 2), why is it so bad to mention that?
08:32:41 <quicksilver> rostayob: you didn't, but hpc did, and you appeared to be joining in the conversation agreeing with him.
08:32:56 <Glorious> could sm1 help me here please http://hpaste.org/65405
08:33:12 <hiptobecubic> quicksilver, ok that worked. but it turns out I need something more like "forever", but now it doesn't work again :)
08:34:08 <quicksilver> rostayob: as for (2) because it isn't haskell, and it isn't a function
08:34:25 <quicksilver> rostayob: it uses haskell syntax but isn't haskell, so it's very confusing to mention it, because it gives incorrect intuition.
08:34:28 <quicksilver> it's a GHC implementation trick.
08:34:46 <Glorious> hm
08:35:13 <hiptobecubic> quicksilver, ok i don't actually need forever because it doesn't collect the intermediates
08:35:20 <hiptobecubic> So i need to know how many i want in advance
08:35:46 <hiptobecubic> quicksilver, is there a lazy way to generate an infinite list of ST computations?
08:36:35 <quicksilver> Glorious: looks like stringColours is a single string and you're using it like it's a list of strings
08:36:45 <quicksilver> hiptobecubic: I'm actually not sure if that works. Might work with lazy ST.
08:36:57 * quicksilver has never tried.
08:37:07 <zhulikas> also it returns a String, but as it looks like, it should be [[String]]
08:37:12 <quicksilver> well obviously you can generate an infinite list of computations.
08:37:13 <zhulikas> I mean generateColours
08:37:28 <quicksilver> I assume you meant "generate an infinite list from a computation"
08:37:29 <monochrom> http://www.vex.net/~trebla/haskell/testbed.cgi has an example of Control.Monad.ST.Lazy
08:37:30 <rostayob> quicksilver: well, ok
08:37:34 <quicksilver> (which is generated lazily)
08:37:36 <hiptobecubic> quicksilver, perhaps, yes?
08:38:01 <monochrom> it actually generates an infinite list [Int]
08:38:17 <hiptobecubic> quicksilver, i mean i want an infinite list instead of   (replicateM n $ standard gen)
08:38:43 <quicksilver> monochrom: that looks odd, do you need to pepper your code with strictToLazy to use lazy ST?
08:38:48 * quicksilver has never tried it though.
08:38:48 <monochrom> laziness of ST.Lazy is tricky. it is usually eager in what you expect to be lazy, and lazy in what you expect to be eager
08:39:24 <jaspervdj> BlankVerse: Ok, cool!
08:39:44 <monochrom> no, that call to strictToLazy is just my strictness analysis by hand
08:39:44 <rostayob> quicksilver: the STRef functions use strict ST
08:39:48 <rostayob> oh
08:39:51 <hiptobecubic> alright, I can't generate the list upfront though, it will be hundreds of thousands of numbers
08:40:02 <monochrom> there is Data.STRef.Lazy or something
08:40:14 <rostayob> right
08:41:22 <quicksilver> monochrom: maybe you should write a blog post on how to use it well and what the pitfalls are? :)
08:41:52 <monochrom> not ready for blog
08:45:17 <Glorious> ok
08:45:18 <Glorious> i modified
08:45:24 <Glorious> generateColours :: Int -> [(Int,Int)] -> [String] -> [[String]]
08:45:37 <Glorious> wont work
08:45:47 <_Mikey> Hey guys, what's the best way to approach debugging a Haskell program which just hangs?
08:45:57 <hiptobecubic> Can someone explain why this gives an error? the types mismatch but i don't understand the "forall"
08:45:58 <hiptobecubic> http://vpaste.net/j45dS
08:47:00 <dolio> hiptobecubic: runST . whatever won't work.
08:47:14 <monochrom> runST (strictToLazy ...) will not add any laziness
08:47:16 <dolio> There's a special case in ghc to make runST $ ... work
08:47:37 <dolio> But it only works for $ specifically. Only the dollar sign function.
08:47:44 <hiptobecubic> oh
08:47:59 <dolio> Which is heinous.
08:48:05 <dolio> But that's how it is.
08:48:17 <monochrom> replicateM 100000 (strictToLazy (standard g)) may have a better chance at laziness
08:48:39 <quicksilver> dolio: is there? wow.
08:48:41 <hiptobecubic> monochrom, yeah, i didn't gain any laziness :)
08:48:55 <rostayob> that is pretty ugly ehe
08:48:58 <dolio> quicksilver: Yep.
08:49:17 <dolio> If you try defining your own application operator, it won't work.
08:49:20 <dolio> Nor will `id`.
08:49:38 <quicksilver> I recall the discussion about why it was hard to get it right
08:49:46 <quicksilver> I never knew they solved it by doing a special case for $ ;)
08:50:09 <hiptobecubic> monochrom, your example doesn't compile
08:50:16 <dolio> They used to have an ad-hoc left-to-right solution, which they got rid of.
08:50:33 <dolio> Then in 7.something, they introduced the $ only solution, which is even more ad-hoc. :)
08:51:18 <monochrom> "strictToLazy (m >>= n)" does not mean "separately do m lazily, do n lazily". it means "do (m>>=n) in one stroke lazily", which means don't do (m>>=n) at all if unneeded, and do (m>>=n) in one stroke if needed
08:51:45 <Saizan> sounds a lot like unsafeInterleaveIO
08:51:51 <hiptobecubic> monochrom, ah ok
08:52:07 <monochrom> my example works. I just tested it. press "Evaluate"
08:52:53 <quicksilver> Saizan: the lazy ST monad is, in theory, interleaved by default.
08:53:03 <quicksilver> Saizan: however monochrom is suggesting it's fiddly to make it do the right thing ;)
08:53:07 <hpc> monochrom: strictToLazy sounds a lot like "id" :P
08:53:10 <quicksilver> Saizan: (and it's not particularly unsafe, or shouldn't be)
08:53:22 <dolio> Lazy ST is not interleaved like unsafeInterleaveIO.
08:53:29 <hpc> oh, nvm
08:53:33 <quicksilver> dolio: it isn't?
08:53:46 <dolio> I don't think so.
08:53:55 <quicksilver> what is it then?
08:54:33 <dolio> I think it's more like Control.Monad.State.Strict vs. .Lazy.
08:54:44 <dolio> Although I'm not sure that makes sense, because I'd expect it to use unboxed tuples.
08:55:00 <_Mikey> is it normal for haskell programs to just hang?
08:55:09 <rostayob> _Mikey: yes, perfectly normal
08:55:28 <rostayob> you can remove haskell from that statement and it still works :)
08:55:36 <monochrom> yes. 99% of randomly generated haskell programs hang
08:55:48 <_Mikey> how would you debug a hanging program
08:55:54 <_Mikey> normally in ghci right?
08:56:06 <monochrom> by getting the low-hanging fruits first
08:56:16 <quicksilver> dolio: since it's real mutation under the hood, it can only execute statements in the right order; it's only choice is to defer some final segment of the statements until needed, no?
08:56:31 <rostayob> _Mikey: mostly by thinking, also ghci and Debug.Trace
08:56:34 <dolio> quicksilver: Oh it is that. Lazy ST uses boxed tuples.
08:56:34 <_Mikey> monochrom, what do you mean by low-hanging fruits?
08:56:44 <monochrom> that was a joke
08:56:47 <_Mikey> ohh
08:56:48 <quicksilver> dolio: whereas lazy state can simply put everything into thunks and literally only demand-drive
08:56:55 <_Mikey> Debug.Trace
08:56:56 <_Mikey> cheers
08:57:10 <monochrom> I don't write hanging programs to begin with. you may be unable to apply this.
08:57:15 <rostayob> @wuote Debug.Trace
08:57:15 <lambdabot> No quotes match. Sorry.
08:57:18 <rostayob> @wuote trace
08:57:19 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
08:57:22 <quicksilver> I would debug a hanging program by running the parts individually
08:57:29 <quicksilver> until I found out which part hung!
08:57:36 <quicksilver> and then repeat, at a finer lever of resolution.
08:57:48 <quicksilver> that wouldn't normally involve debug.trace although occasionally it helps.
08:57:53 <rostayob> hey... why does lambdabot understand @wuote?
08:58:01 <monochrom> ok, I sometimes write hanging programs. but only when I'm learning. and when learning, I make sure the programs are so small that when they hang, I learn why.
08:58:12 <quicksilver> rostayob: it has a spelling-correction thing on commands
08:58:13 <geekosaur> rostayob, it has levenshtein distance on commands
08:58:18 <Enigmagic> i would just hook up gdb and look to see why it was hanging :P
08:58:23 <geekosaur> distance <= 3, IIRC
08:58:26 <rostayob> @snack
08:58:27 <lambdabot> go slap  yourself
08:58:32 <rostayob> ehe
08:58:35 <geekosaur> (to a unique command)
08:58:36 <monochrom> but when writing production code, that's after I have finished learning, so I just don't write hanging programs by then. I can't.
08:58:45 <quicksilver> Enigmagic: most people do not find gdb traces of GHC-compiled code very helpful.
08:58:49 <dolio> quicksilver: So, 'foo = foo >> ...' will probably work in Lazy ST, as long as foo doesn't do anything interesting.
08:58:49 <_Mikey> thanks quicksilver
08:58:56 <dolio> That's the difference.
08:59:02 <Enigmagic> quicksilver: i have symbols :P
09:00:07 <rostayob> I've never been so desperate to have to use gdb on haskell binaries
09:00:38 <singpolyma> I seem to be failing at understanding a piece of list comprehension.  How are these different: http://pastie.org/3609015
09:01:13 <Enigmagic> rostayob: the first time i had to debug something that only reproed after about 9 hours in compiled ghc code i stopped caring so much
09:01:42 <Enigmagic> i just use gdb most of the time now
09:02:09 <quicksilver> singpolyma: the first one lacks a 'return'
09:02:15 <quicksilver> singpolyma: (if you wish it to be equivalent to the second)
09:02:27 <hiptobecubic> Ok next iteration... http://vpaste.net/gSPrj
09:02:39 * hiptobecubic wishes that PastePipe worked
09:02:44 <quicksilver> singpolyma: so the first one will run through all the elements in a'++b' where the second will just return that list as one.
09:03:04 <zhulikas> I didn't know you can do such things in a do block
09:03:12 <zhulikas> I mean list comprehension
09:03:22 <quicksilver> zhulikas: which things?
09:03:51 <monochrom> you are initializing 100000 times?
09:04:42 <hiptobecubic> monochrom, oh. yikes. not intentionally
09:05:08 <hiptobecubic> I guess i want to strictly run gen first....
09:05:25 <Franciman> hi all
09:05:33 <hiptobecubic> where is the state in this thing. Just floating around in outer space?
09:05:40 <thoughtpolice> preflex: seen kfish
09:05:40 <preflex>  kfish was last seen on #haskell 2 days, 8 hours, 4 minutes and 9 seconds ago, saying: * kfish just added a bunch of FlexibleInstances pragmas to fix build breakage with ghc-7.5
09:06:21 <monochrom> L.runST (do { x <- strictToLazy (initialize whatever); replicateM 100000 (strictToLazy (blah x)) })
09:06:58 <hpaste> Franciman pasted ‚ÄúLen‚Äù at http://hpaste.org/65406
09:07:01 <Franciman> hey is this length implementation elegant enough, and is there any more elegant solution ( without using length ofc :P ) ?
09:07:21 <monochrom> it is very elegant to me
09:08:03 <mm_freak> üí©
09:08:21 <ChristianS> Franciman: looks ok to me, but you could do as hlint suggests (below the paste)
09:08:38 <monochrom> state is hidden away in inner space
09:08:42 <zhulikas> @hoogle length
09:08:42 <lambdabot> Prelude length :: [a] -> Int
09:08:42 <lambdabot> Data.List length :: [a] -> Int
09:08:42 <lambdabot> Foreign.Marshal.Array lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
09:08:46 <zhulikas> why is it Int
09:08:54 <zhulikas> can't it be bigger than Int boundaries
09:08:54 <zhulikas> :|
09:09:00 <zhulikas> what is it, 64bit?
09:09:27 <hpc> zhulikas: some say it's a bug in the spec
09:09:30 <hiptobecubic> monochrom, aha, yes. had to "strictToLazy" the initialization as well. :) thanks
09:09:37 <zhulikas> kool
09:09:42 <hpc> @hoogle genericLength
09:09:43 <lambdabot> Data.List genericLength :: Num i => [b] -> i
09:09:43 * zhulikas just found a bug!
09:09:44 <mm_freak> zhulikas: controversial‚Ä¶  i'd say it's a good choice
09:10:11 <zhulikas> what is known about performance of Int vs Integer?
09:10:21 <mm_freak> Int is slightly faster
09:10:21 <Franciman> Int is faster
09:10:24 <zhulikas> ok then
09:10:43 <zhulikas> and no sane programmer would count a length of a list larger than of Int probably
09:10:50 <mm_freak> Integer is only marginally slower for Int sizes though
09:11:01 <zhulikas> marginally?
09:11:04 <mm_freak> zhulikas: a haskell programmer might
09:11:07 <zhulikas> :D
09:11:26 <Aune> can you load language pragmas in ghci?
09:11:26 <mm_freak> because a list is not only a data structure‚Ä¶  it's also a good substitute for for/while-loops in other languages
09:11:30 <Franciman> okay thanks so much to anyone
09:11:38 <hpc> @src Integer
09:11:38 <lambdabot> data Integer = S# Int#
09:11:38 <lambdabot>              | J# Int# ByteArray#
09:11:42 <mm_freak> i.e. create an infinite list and search it, counting the number of items you checked
09:11:46 <zhulikas> :o
09:11:50 <zhulikas> whaaaat
09:11:55 <zhulikas> Integer is defined with Int??
09:12:00 <mm_freak> Int#
09:12:08 <zhulikas> @src Int#
09:12:08 <lambdabot> Source not found.
09:12:12 <zhulikas> what is it?
09:12:13 <hpc> > let isSmall (S# x) = True; isSmall (J# x bs) = False in isSmall 5
09:12:14 <lambdabot>   Not in scope: data constructor `S#'Not in scope: data constructor `J#'
09:12:17 <hpc> :(
09:12:18 <mm_freak> Int# is primitive
09:12:25 <mm_freak> you can't define it in haskell
09:12:30 <zhulikas> and what is S#?
09:12:31 <hpc> it's something GHC provides
09:12:41 <mm_freak> S# is a constructor‚Ä¶  it's just a name
09:12:45 <zhulikas> ah, ok
09:12:56 <zhulikas> so Integer is either Int, or bigger than Int?
09:12:57 <quicksilver> zhulikas: you can't have a list longer than the size of Int in memory anyway
09:13:00 <mm_freak> think of it as "Short#"
09:13:01 <hpc> zhulikas: yes
09:13:11 <parcs`> Integer is either an Int (if sufficiently small) or a bytearray and its length, or something :P
09:13:14 <zhulikas> how should I understand J# Int# ByteArray# ?
09:13:19 <zhulikas> oh
09:13:29 <zhulikas> hmm
09:13:47 <mm_freak> it's an array of bytes that represent the arbitrary-precision integer
09:13:48 <zhulikas> how is number extracted from a given ByteArray# ?
09:13:52 <monochrom> Aune: no, use :set -XRankNTypes instead
09:14:00 <mm_freak> zhulikas: by using the Integer that wraps it
09:14:09 <zhulikas> ah, so probably it's not
09:14:17 <zhulikas> but when you are using it - it's calculated by compiler?
09:14:23 <geekosaur> and the bytearray is usually a gmp number, although there is a BSD-licensed alternate interger library available.  so you should not try to poke within; no user serviceable parts inside
09:14:25 <zhulikas> or, well, not compiler...
09:14:34 <monochrom> the byte array is passed to GMP
09:14:39 <mm_freak> zhulikas: likely by a compiler‚Ä¶  GHC uses the GMP library for Integer arithmetic
09:14:46 <Aune> monochrom, Aaah, ok
09:14:47 <mm_freak> s/compiler/library/
09:14:55 <zhulikas> I just thought maybe it's defined by some Haskell code :)
09:15:03 <zhulikas> the extraction I mean
09:16:20 <mm_freak> accessing the Integer ByteArray# would be a üí© (i wonder if anyone sees this character‚Ä¶  i don't)
09:17:15 <hpc> i see a filled diamond with a question mark
09:17:16 <geekosaur> I get a substitute glyph with hex in it, suggesting non-BMP
09:17:35 <geekosaur> 01F4A9?
09:17:43 <mm_freak> it's the &#128169; character called "PILE OF POO"
09:17:49 <mm_freak> alias name:  dog dirt
09:18:17 <Chaze> is there a difference in the binaries with 'run' prefixed?
09:18:23 <Chaze> runghc as opposed to ghc
09:18:36 <mm_freak> Chaze: runghc/runhaskell are for executing scripts
09:18:47 <Chaze> what kind of scripts?
09:18:50 <mm_freak> they are equivalent to loading the source file into GHCi and then running :main
09:19:00 <mm_freak> just a regular haskell program that is run without compilation
09:19:09 <Chaze> i see
09:19:27 <Chaze> well, in case of runhaskell
09:19:35 <Chaze> but what does runghc do different from ghc?
09:19:42 <mm_freak> as said
09:19:46 <mm_freak> 'ghc' is the compiler
09:20:05 <geekosaur> ghc produces an executable from haskell source.  runghc interprets haskell source immediately
09:20:12 <mm_freak> runghc is a wrapper around the interpreter that runs the given module
09:21:18 <geekosaur> runhaskell is just anither name for runghc; it exists because you can have multiple haskell compilers installed, one of which is the default
09:21:38 <geekosaur> so you might have hugs providing runhaskell, but you cpuld still use runghc to get the interpreter version of ghc
09:25:22 <Ke> is there some lib that can do both url encode and decode
09:28:23 <Ke> like I need one lib for encode and decode
09:28:26 <acowley> It's always sad when fixing a bug dramatically hurts performance.
09:29:30 <Tesseraction> Ke: does Network-URL not do that?
09:30:04 <Lemmih> acowley: I know some prominent library authors who sometimes choose not to fix the bugs in those cases.
09:30:35 <Tesseraction> Lemmih: "it's not a bug it's a feature"
09:30:40 <acowley> Lemmih: That's the most painful part! You cast about trying to find a way to justify the buggy behavior.
09:32:23 <Chaze> I'm trying to get an example to run here. installing the dependencies seems to have worked, but i get a compilation error:
09:32:24 <Chaze> Elevator.hs:44:26: parse error on input `->'
09:32:31 <Chaze> in this line:
09:32:31 <Chaze> elevator = proc (lbp,rbp) -> do
09:33:01 <Chaze> is there some syntax extension i have to enable?
09:33:30 <Lemmih> Chaze: Yes.
09:33:40 <Chaze> Lemmih: do tell. :)
09:33:53 <Chaze> googeling the operator '->' isn't so easy
09:33:54 <Lemmih> Chaze: Alright, -XArrows. (:
09:34:25 <Chaze> thanks
09:34:58 <geekosaur> (what that enables isn;t so much -> as proc, note)
09:35:04 <Ke> Tesseraction: thank, it seems to do yes
09:35:07 <sebz> What's the right way to check that an instance (Applicative f, Alternative g) => Alternative (Compose f g) is valid?
09:35:20 <Franciman> gents, to do the average of the elements in a list is it best to use sum and length, or use a fold that keeps track of both current sum and length and then divide the elements of this pair?
09:35:41 <Franciman> ( I'm always speaking from a point of view of elegance, since for efficiency the fold version is better )
09:37:43 <Tesseraction> Franciman: not everyone is here is male :P but sum is a fold in itself
09:38:27 <rostayob> Franciman: fold is better. sum + length traverses the list twice.
09:38:36 <Tesseraction> yeah
09:39:14 <Franciman> Tesseraction, sorry lol, I meant both males and females :D
09:41:45 <eyebloom> Folding over a function that tracks sum and length would be pretty elegant.
09:41:51 <Tesseraction> indeed
09:42:10 <rostayob> that's simply "foldr (\(l, s) x -> (inc l, s + x))"
09:42:36 <Tesseraction> nothing more inelegant than redundancy, which two traversals would be
09:42:44 <rostayob> mah, it probably doesn't matter.
09:43:08 <rostayob> then you should use foldl' ehe
09:43:57 <hikingpete> @pl (\x y->x*10+y)
09:43:57 <lambdabot> (+) . (10 *)
09:44:40 <rostayob> > uncurry (on (/) fromIntegral) . foldl' (\(l, s) -> (l + 1, s + x)) (0, 0) $ [1, 2 3]
09:44:41 <lambdabot>   Couldn't match expected type `b -> (t, SimpleReflect.Expr)'
09:44:41 <lambdabot>         against...
09:45:04 <ClaudiusMaximus> :t uncurry (flip (/) `on` getSum) . mconcat . map ((,) Sum 1 . Sum)
09:45:05 <lambdabot>     Ambiguous occurrence `getSum'
09:45:05 <lambdabot>     It could refer to either `Control.Monad.RWS.getSum', imported from Control.Monad.RWS
09:45:05 <lambdabot>                           or `Data.VectorSpace.getSum', imported from Data.VectorSpace
09:45:13 <rostayob> > uncurry (on (/) fromIntegral) . foldl' (\(l, s) x -> (l + 1, s + x)) (0, 0) $ [1, 2 3]
09:45:14 <lambdabot>   0.6666666666666666
09:45:26 <rostayob> ah it's the other way around
09:45:35 <rostayob> > uncurry (on (flip (/)) fromIntegral) . foldl' (\(l, s) x -> (l + 1, s + x)) (0, 0) $ [1, 2 3]
09:45:37 <lambdabot>   1.5
09:45:43 <rostayob> > uncurry (on (flip (/)) fromIntegral) . foldl' (\(l, s) x -> (l + 1, s + x)) (0, 0) $ [1, 2, 3]
09:45:44 <lambdabot>   2.0
09:45:48 <rostayob> there.
09:45:55 <rostayob> or
09:46:07 <rostayob> > uncurry (flip (/)) . foldl' (\(l, s) x -> (l + 1, s + x)) (0, 0) $ [1, 2, 3]
09:46:08 <lambdabot>   2.0
09:46:13 <gwern> > 60 * 24 * 365.25
09:46:14 <lambdabot>   525960.0
09:46:21 <rostayob> if you already have fractionals
09:46:31 <rostayob> > uncurry (flip (/)) . foldl' (\(l, s) x -> (l + 1, s + x)) (0, 0) $ [1..10000]
09:46:33 <lambdabot>   5000.5
09:46:38 <rostayob> big numbers yay
09:46:41 <rostayob> > uncurry (flip (/)) . foldl' (\(l, s) x -> (l + 1, s + x)) (0, 0) $ [1..10000000]
09:46:45 <lambdabot>   mueval-core: Time limit exceeded
09:46:47 <rostayob> > uncurry (flip (/)) . foldl' (\(l, s) x -> (l + 1, s + x)) (0, 0) $ [1..1000000]
09:46:51 <lambdabot>   *Exception: stack overflow
09:47:08 <cheater_> wow:
09:47:09 <cheater_> no coder changes a single line of code without specs carefully outlining the change. Take the upgrade of the software to permit the shuttle to navigate with Global Positioning Satellites, a change that involves just 1.5% of the program, or 6,366 lines of code. The specs for that one change run 2,500 pages, a volume thicker than a phone book. The specs for the current program fill 30 volumes and run 40,000 pages.
09:47:29 <parcs`> you need to add some seqs there
09:47:37 <rostayob> cheater_: and still, they fuck up the mars rover!
09:47:41 <rostayob> unbelievable
09:48:08 <ben> Does Haskell have libraries for making sure you don't mess up the units of your numbers? :)
09:48:12 <Tesseraction> that's the joy of spending too much time working on something, you start to make careless mistakes because you expect the value to be right
09:48:19 <parcs`> what language is that kind of software written in
09:48:23 <rostayob> FORTRAN
09:48:31 <geekosaur> ben: dimensional, on hackage :)
09:48:39 <ben> cheers
09:48:50 <geekosaur> and the mars rover thing was trying to interface NASA stuff with ESA stuff (completely independent specs etc.), no?
09:49:06 <rostayob> geekosaur: no they just bought some routines from some third party
09:49:13 <rostayob> and didn't bother to check what units they were using
09:49:48 <rostayob> iirc
09:49:53 <edwardk> ben: bjorn buckwalter's dimensional is probably the best of the bunch
09:51:06 <rostayob> dimensional-tf is prettier
10:03:02 <Mathnerd314> @where+ units http://www.haskell.org/haskellwiki/Physical_units
10:03:03 <lambdabot> Done.
10:16:39 * hackagebot vector-instances-collections 0.1 - Instances of the Data.Collections classes for Data.Vector.*  http://hackage.haskell.org/package/vector-instances-collections-0.1 (TobiasBrandt)
10:22:55 <Glorious> hi im wondering why this does not work http://hpaste.org/65411
10:24:34 <d-snp> can I assume map goes through the list in first to last order?
10:24:50 <d-snp> (so there's no parallel bollocks going on?)
10:25:01 <sipa> the constructed list will have the same order as the origin list
10:25:11 <d-snp> ok
10:25:21 <sipa> the order the elements are computed, depends on the order in which they are evaluated
10:25:24 <d-snp> hmm
10:25:35 <Glorious> Couldn't match expected type `[String]'            against inferred type `Char'     In the third argument of `generateColours', namely `c'     In the expression: generateColours lnVertices edges c     In a stmt of a list comprehension:         y <- generateColours lnVertices edges c
10:26:30 <quicksilver> Glorious: I answered you last time
10:26:33 <quicksilver> (quite a few hours ago)
10:27:06 <Glorious> sry i had to run to class
10:27:13 <geekagent> Glorious: computeColours ignore the bodies and just look at the types.
10:27:15 <Glorious> and i closed my firefox
10:27:28 <geekagent> generateColours returns [[String]]
10:27:34 <quicksilver> the recursive call to generateColours is very odd
10:27:40 <quicksilver> I'm not sure that code will ever make sense :)
10:27:50 <quicksilver> but the immediate problem is that stringColours is a String
10:27:51 <Glorious> :(
10:27:53 <quicksilver> so 'c' is a Char
10:28:03 <quicksilver> and that's the wrong type to be used as 3rd argument to generateColours
10:28:13 <Glorious> but if i put
10:28:56 <Glorious> generateColours :: Int -> [(Int,Int)] -> Char -> [[String]]
10:28:59 <Glorious> it wont work either
10:29:21 <geekagent> Glorious: there's more than one thing wrong with that piece of code.
10:29:43 <Glorious> ohh
10:29:44 <geekagent> that's why quicksilver said "immediate problem"
10:29:54 <Glorious> ok
10:30:10 <Glorious> my stringColours is "rby"
10:30:31 <quicksilver> Glorious: do you understand that generateColours is calling itself recursively?
10:30:34 <Glorious> im just trying to generate all the permutations 1 by 1 now so it is rrr , rrb , rry....so on
10:30:35 <quicksilver> and is that what you want?
10:30:44 <quicksilver> and can you explain why it's what you want? :)
10:30:54 <Glorious> yes coz im trying to go generate what i just said
10:30:59 <Glorious> and then after i accomplish that
10:31:14 <quicksilver> you're expecting an infinite list?
10:31:19 <Glorious> no
10:31:23 <Glorious> i dont have a termination now
10:31:25 <Glorious> i know
10:31:27 <quicksilver> how will it ever stop?
10:31:43 <Glorious> i dont know yet
10:31:51 <geekagent> Glorious: perhaps you should break it down into smaller pieces
10:32:00 <quicksilver> at the very least I'd expect the recursive call to have different arguments? (Maybe substract 1 form something?)
10:33:26 <Glorious> the thing is with this reccursive call i expect to get the colours 1 by 1 formulated as "r+r+r" "r+r+y"...and so on and then i will somehow implement a bool function that checks if the current colour eg "r" is adjacent to the previous "r" if it is i will have to change it to another colour
10:34:32 <Glorious> now im just trying to achieve [r+r+r], [r+r+y] , 1 by 1 recursive filling the colours so i can check them 1 by 1
10:35:10 <geekagent> Glorious: Sometimes recursion isn't the answer.
10:35:21 <Glorious> i have to do this with list comprehension
10:35:39 <Glorious> so i cant do it without recursion :(
10:35:59 <Glorious> i want to start from
10:36:00 <geekagent> Glorious: why? Is this homework?
10:36:06 <Glorious> ComputeColours lnVertices edges = generateColours lnVertices edges []
10:36:14 <Glorious> so i will start from the empty list
10:36:25 <Glorious> and then recursively have my callors filled in in it
10:37:01 <Glorious> yes it is homework i dont need a straight answer, i  just need some clarifications maybe im thinking about this all wrong
10:37:18 <geekagent> Glorious: yes, you're thinking about this all wrong.
10:39:27 <geekagent> Glorious: the homework requires list comprehensions?
10:39:32 <Glorious> well i cant see other way in checking if 2 vertices that are adjacent have to be diff colours, ill start from a empty list and populate it 1 by 1 with the all possible permutations of colours of my vertices, so if i have 3 vertices ill have rrr, rrb...so on and then if i can just make it so it adds just 1 colour at the time "r+r+r" "r+r+y" i can actually check the pervious colour and the current colour if the vertices correspoing to
10:39:56 <Glorious> are  i can baacktrack and add a empty list and generate another color for the current vertice
10:40:02 <Glorious> am i thinking about this wrong?
10:40:07 <Glorious> yes it does
10:40:15 <Glorious> thats how im thinking about to solve it right now
10:40:45 <geekagent> Glorious: bizarre
10:40:54 <Glorious> :|
10:42:05 <geekagent> Glorious: There's a reasonable solution that uses list comprehensions.
10:42:26 <geekagent> Glorious: keep looking. It's straightforward.
10:43:05 <Glorious> could u tell me ur way of thinking about implementing it? ive been thinking for 2 days now .. maybe if u dont want to give me a full answer could u just give me from where to start or an indirect advice
10:43:23 <geekagent> Glorious: no post filtering required
10:43:52 <Glorious> i dont understand what no post filtering means :) u mean that i dont need to compare the previous with the current?
10:52:09 <geekagent> Glorius: are you supposed to find an optimal coloring, or just any coloring?
10:53:08 <Glorious> im supposed to find any colouring of the graph where the colouring can be for eg "rby" where the graph is [(1,2),(2,3)] for egs where no adjacent vertices have the same colour with backtracking and list comprehension
10:53:56 <Glorious> in this case i would have "r + r skip this r because 1,2 are adjacent so make it y check good + r check good" first valid colour r y r
10:54:03 <Glorious> or r b r
10:54:04 <Glorious> and so on
10:54:11 <Glorious> all possible valid colourings
10:54:42 <Glorious> already made a checkAdjacent function checkAdjacent :: Int -> Int -> [(Int,Int)] -> Bool
10:55:16 <Glorious> which gets the 2 vertices and the whole graph and returns true if they are adjacent and false if they are not
11:05:07 <super_> test
11:11:09 <tromp__> > fix error
11:11:10 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:12:48 <ski> la la la
11:13:13 <tromp__> > fix show
11:13:14 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
11:13:33 <prototrout> > fix id
11:13:37 <lambdabot>   mueval-core: Time limit exceeded
11:15:23 <ski> > fix read
11:15:26 <lambdabot>   mueval-core: Time limit exceeded
11:15:55 <ski> > read (fix show) :: String
11:15:59 <lambdabot>   mueval-core: Time limit exceeded
11:16:31 <ski> (i suppose it could work with an optimistic parser)
11:21:09 <tromp__> > map return $ fix show
11:21:10 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
11:21:10 <lambdabot>    arising from a use of...
11:21:44 <tromp__> > map (:[]) $ fix show
11:21:44 * hackagebot monad-atom 0.4.1 - Monadically convert object to unique integers and back.  http://hackage.haskell.org/package/monad-atom-0.4.1 (GrzegorzChrupala)
11:21:44 <lambdabot>   ["\"","\\","\"","\\","\\","\\","\"","\\","\\","\\","\\","\\","\\","\\","\""...
11:25:03 <hpc> > map (\x -> case x of '"' -> 0; '\\' -> 1) $ fix show
11:25:04 <lambdabot>   [0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,...
11:25:14 <hpc> @oeis 0,1,0,1,1,1,0,1,1,1,1
11:25:25 <hpc> aw :(
11:25:30 <lambdabot> Plugin `oeis' failed with: thread killed
11:27:21 <geekagent> hpc: it's 1 1 1 3 1 7 1 15 1 31 1 63
11:27:47 <hpc> @oeis 1 1 1 3 1 7 1 15 1 31 1 63
11:27:50 <lambdabot>  Expansion of (1+2*x)/((1+x)*(1-2*x^2)).
11:27:50 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
11:27:54 <hpc> ah
11:28:05 <hpc> > map length . group . map (\x -> case x of '"' -> 0; '\\' -> 1) $ fix show
11:28:09 <lambdabot>   mueval-core: Time limit exceeded
11:28:37 <geekagent> > take 5 $ map length . group . map (\x -> case x of '"' -> 0; '\\' -> 1) $ fix show
11:28:39 <lambdabot>   [1,1,1,3,1]
11:28:47 <geekagent> > take 9 $ map length . group . map (\x -> case x of '"' -> 0; '\\' -> 1) $ fix show
11:28:49 <lambdabot>   [1,1,1,3,1,7,1,15,1]
11:28:54 <byorgey> > take 9 . map length . group $ fix show
11:28:56 <lambdabot>   [1,1,1,3,1,7,1,15,1]
11:29:02 <hpc> gotcha
11:37:29 <byorgey> > let (a:as).+(b:bs) = (a+b):(as.+bs); (x:xs).*yys@(y:ys) = (x*y) : (map(x*)ys.+(xs.*yys)); (x:xs)./(y:ys) = let qs = (x`div`y):map (`div`y) (xs .+ map negate (qs.*ys)) in qs; x = 0:1:repeat 0; lit n = n:repeat 0 in (lit 1 .+ (lit 2 .* x))./((lit 1 .+ x).*(lit 1 .+ map negate (lit 2.*x.*x)))
11:37:30 <lambdabot>   [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1...
11:38:04 <byorgey> would look a lot nicer if you could make a local Num instance ;)
11:46:23 <ski> @oeis 0,1,0,1,1,1,0,1,1,1,1
11:46:38 <lambdabot> Plugin `oeis' failed with: thread killed
11:47:11 <ski> @let grabLitChar :: State String Char; grabLitChar = state (head . Data.Char.readLitChar)
11:47:13 <lambdabot>  Defined.
11:47:20 <ski> @let grabChar :: State String Char; grabChar = state (\('\'':(runState grabLitChar -> (c,'\'':s))) -> (c,s))
11:47:21 <lambdabot>   ViewPatterns is not enabled
11:47:32 <ski> @let grabString :: State String String; grabString = state (\('"':s) -> loop s) where loop ('"':s0) = ("",s0); loop (runState grabLitChar -> (c,s0)) = (c:s,s1) where (s,s1) = loop s0
11:47:32 <lambdabot>   ViewPatterns is not enabled
11:47:37 <ski> bah
11:48:30 <ski> @let grabString :: State String String; grabString = state (\('"':s) -> loop s) where loop ('"':s0) = ("",s0); loop s0 = (c:s,s2) where (c,s1) = runState grabLitChar s0; (s,s2) = loop s1
11:48:31 <lambdabot>  Defined.
11:48:45 <ski> > fix show
11:48:46 <ski> > fst (grabString `runState` (fix show))
11:48:46 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
11:48:47 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
11:49:10 <ben> help, i just blew my mind with laziness and don't know what to do
11:49:19 <hpaste> ben pasted ‚Äúfold either way‚Äù at http://hpaste.org/65414
11:49:33 <ski> > grabString `runState` "\"ab\\ncd\"fg"
11:49:35 <lambdabot>   ("ab\ncd","fg")
11:49:37 <ben> that doesn't iterate twice or anything dumb, does it?
11:50:45 <mustardtiger> eddie haskell
11:50:46 <mustardtiger> ?
11:50:47 <ski> @type let mapAndFoldl mapF foldF foldAcc xs = go foldAcc xs where go a [] = ([], a); go a (x:xs) = let (ys, a') = go (foldF a x) xs in (mapF x : ys, a') in mapAndFoldl
11:50:48 <lambdabot> forall t a t1. (t -> a) -> (t1 -> t -> t1) -> t1 -> [t] -> ([a], t1)
11:50:55 <mustardtiger> wasn't he one of the munsters?
11:50:59 <Tesseraction> ben: if you really want to check you can use :break and :step to see :P
11:51:05 <ski> @type let mapAndFoldl mapF foldF foldAcc xs = go foldAcc xs where go a [] = ([], a); go a (x:xs) = let (ys, a') = go (foldF a x) xs in (mapF x : ys, a') in let increaseAndSum = mapAndFoldl succ (+) 0 in increaseAndSum
11:51:06 <lambdabot> forall t. (Num t, Enum t) => [t] -> ([t], t)
11:51:24 <ben> Tesseraction: Wasn't there a website for that
11:51:31 <ski> @where stepeval
11:51:31 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
11:51:32 <Tesseraction> if there is I'd love to see it
11:51:34 <Tesseraction> aha
11:51:36 <ben> yeah :V
11:51:52 <Tesseraction> gonna use the hell outta this
11:52:03 <ben> it's a bit limited iirc
11:52:11 <Tesseraction> and hope it's not secretly logging all the stupid stuff I test in it
11:53:15 <ski> ben : hm, it looks ok to me
11:53:46 <acowley> Is anyone here familiar with PSQueue and fingertree-psqueue? I'm trying to swap between them and getting different results.
11:54:48 <ben> ski: Basically I wanted to have a right fold that ended up returning a tuple, with an additional value next to the typical foldr-as-map-style list
11:55:11 <ben> and somehow ended up trying to avoid ++'ing to a list as I go
11:55:17 <ben> but now this is all backwards and I don't know anymore D:
11:55:20 <ski> well, you're combining a *left* fold with a map ..
11:55:31 <ben> yeah the map is the right fold i meant
11:55:36 <ski> *nod*
11:55:37 <LoLCode> LoLCode is the only code
11:55:44 <ski> so .. what is the problem ?
11:56:35 <ski> (i would rather say s/foldr-as-map-style/map-as-foldr-style/)
11:56:46 * hackagebot snap-core 0.8.0 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.8.0 (GregoryCollins)
11:57:33 <ben> It feels crazy to reach ahead and pull out the final left-fold value and I couldn't convince myself I wouldn't have some degenerate case of recursion where everything is evaluateld multiple times or somethin
11:58:52 <ski> well, to compute the final left-fold value, it will need to do all the recursive calls of `go', meaning it will build up the whole mapped list in memory as well
11:58:54 <ben> It kinda feels like it does the right thing, like give me a thunk for the list that I can evaluate and have the recursion proceed step by step, and a thunk for the other value that gets mostly evaluated by evaluating the other thunk but can also force the whole expression by itself
11:59:04 <ski> maybe you don't want that
11:59:28 <ben> as long as it only does it once, I think I'm okay with that
11:59:35 <kaitocracy> can someone help me understand this? fibs = scanl (+) 0 (1:fibs)
11:59:38 <ski> well, the thunk it gives for the list is basically the whole mapped list (not just the outermost part, so to speak)
11:59:52 <kaitocracy> like I have no idea how to even start to understand that
12:00:15 <zachk> > 2 + x where x=3 --how do I use a where in lambdabot?
12:00:15 <lambdabot>   <no location info>: parse error on input `where'
12:00:26 <kaitocracy> how can I define a thing recursively? I can't wrap my head around it
12:00:26 <ben> as long as I don't touch the other thunk, it will still only evaluate the recursion as much as I look at the thunk, won't it?
12:00:34 <ski> if you later want to summarize the information in the mapped list into something small, then it would be better to bake this into this traversal, so it can incrementally consume the input list, and never need to have a complete output list in memory at the same time
12:00:38 <hpc> hey guys, feature request for the next haskell standard:
12:00:38 <acowley> kaitocracy: replace "scanl" with its definition and do a but of evaluation
12:00:44 <hpc> > (0x100, 0o100)
12:00:45 <lambdabot>   (256,64)
12:00:48 <acowley> s/but/bit
12:00:48 <hpc> > 0b100
12:00:49 <lambdabot>   Not in scope: `b100'
12:00:57 <hpc> there's no binary number literals
12:01:14 <ski> i.e., if you want to avoid multiple traversals, then it's usually also best to not require the creation of whole intermediate lists in meory
12:01:25 <acowley> pshaw, who uses binary?
12:01:38 <ben> hm, you're right
12:01:39 <ski> (since the reason for avoiding multiple traversals is typically to avoid keeping the whole input list in memory)
12:01:48 * hackagebot snap-server 0.8.0 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.8.0 (GregoryCollins)
12:01:50 * hackagebot snap 0.8.0 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.8.0 (GregoryCollins)
12:01:52 * hackagebot heist 0.8.0 - An (x)html templating system  http://hackage.haskell.org/package/heist-0.8.0 (GregoryCollins)
12:01:57 <kaitocracy> okay substituting in the definition of scanl and seeing what happens
12:02:03 <ski> ben : in any case, your code avoids multiple traversals of the input list
12:02:30 <ski> <ben> as long as I don't touch the other thunk, it will still only evaluate the recursion as much as I look at the thunk, won't it?
12:02:34 <ski> no -- at least i don't think so
12:02:54 <ben> thanks for the help
12:03:01 <acowley> kaitocracy: to cut down on the handwriting, it might help to consider "scanl (+)" itself as a unit so you can directly write the + operator in your expansion
12:03:08 <ski> it will need to bottom out the recursion to determine the second part of the pair, and that seems to me to essentially mean it must also create the full output list
12:03:42 <ski> (there might be some optimization which avoids this, but this is what i would expect with the naÔve graph-rewriting model of it)
12:04:42 <ski> ben : i.e., typically it's better to try to merge traversals when they look like `foldl's
12:05:09 <ski> (so if you later `foldl' the output list, it would be better to merge this larger traversal with the other `foldl' one)
12:06:05 <ski> ben : iirc, edwardk's <http://comonad.com/haskell/Origami.hs> is about this -- i think the accompanying blog article may have been lost, though
12:06:55 <ben> I think I might be in over my head with that
12:08:30 <kaitocracy> acowley: okay I get it; but how do people even come up with that?
12:08:32 <deech> Hi all is there some way to use hoogle or hayoo to search for instances of typeclasses? For instance, I'd like to know what Functors are out there.
12:09:43 <ski> kaitocracy : it might help to first understand `fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
12:10:33 <acowley> kaitocracy: it varies, and it is challenging. One way is that you start by thinking about the first few parts of the expanded version and recognize a repeated unfolding of a definition. In this case, the later parts of the list want to refer to the earlier parts of the list, so you say, "If only I had the earlier results of the very thing I'm writing‚Ä¶"
12:10:57 <ben> heh :)
12:11:15 <ski> kaitocracy : you can understand this one as a kind of pipeline. the pipeline starts by outputting `0' and then `1'
12:11:33 <kaitocracy> acowley: well thanks for all your help, clearly I just need to do more stuff with Haskell
12:11:53 <ski> kaitocracy : but the output of the pipeline is copied back into it twice (once with a delay, which is the `tail', skipping the first element)
12:12:10 <acowley> kaitocracy: don't get hung up on this stuff, it's a very small part of daily Haskell
12:12:18 <ski> kaitocracy : so `0 : 1 : ...' as well as `1 : ...' is fed back into it (the `fibs' and `tail fibs' parts)
12:13:06 <ski> kaitocracy : these two streams of items are now `zipWith (+)'ed with each other -- meaning that they are added, pointwise, resulting in `1 : (1 + ..) : ...'
12:13:26 <ski> kaitocracy : so, therefore the whole `fibs' pipeline now outputs `1' after the initial `0' and `1'
12:14:08 <ski> kaitocracy : so the feedback streams are now known to be `0 : 1 : 1 : ...' and `1 : 1 : ...', so the pointwise sum is `1 : 2 : (1 + ..) : ...', so the next item is `2'
12:14:48 <acfoltzer> did haskell.org not make the cut for GSoC this year? It's not in the list of accepted organizations unless my vision is really slipping
12:15:06 <ski> the best way to understand this is probably to draw a picture, imagining an engine which outputs `0 : 1 : 1 : 2 : ...' while that stream is being fed back to itself, munching away an item at a time, adding
12:17:31 <zachk> > let nothingMuch list = foldr (:) [] list in nothingMuch [1..10]  -- kaitocracy do you understand this?
12:17:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:18:27 <hpc> > foldr (+) 0 (x : (y : (z : []))) -- a bit more clearly, what's happening
12:18:28 <lambdabot>   x + (y + (z + 0))
12:19:58 <acowley> acfoltzer: it looks like it didn't. I thought we always did quite well with GSoC, I wonder what happened? Is the organization acceptance rate much lower this year?
12:20:00 <ski> > scanl (+) 0 [a,b,c,d]
12:20:01 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c,0 + a + b + c + d]
12:21:21 <dbelange> > scanl () e [c,h,o]
12:21:22 <lambdabot>   Couldn't match expected type `a -> b -> a'
12:21:22 <lambdabot>         against inferred type `()'
12:21:30 <geekosaur> what I am hearing elsewhere is that google is actively looking for smaller and "new" organizations
12:21:48 <dbelange> > scanl (+) e [c,h,o]
12:21:49 <lambdabot>   [e,e + c,e + c + h,e + c + h + o]
12:21:51 <dbelange> > scanl (++) e [c,h,o]
12:21:52 <lambdabot>   No instance for (Data.Monoid.Monoid SimpleReflect.Expr)
12:21:52 <lambdabot>    arising from a u...
12:22:10 <ski> > scanl (++) 'e' "cho"
12:22:11 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
12:22:11 <lambdabot>    arising from a use o...
12:22:28 <ski> > scanl (++) "e" (map (: []) "cho")
12:22:30 <lambdabot>   ["e","ec","ech","echo"]
12:23:56 <brisingr> wow, lambdabot can do that?
12:24:02 <brisingr> > show (a + b)
12:24:03 <lambdabot>   "a + b"
12:24:05 <brisingr> wow
12:24:11 <ski> @type a
12:24:12 <lambdabot> Expr
12:24:19 <brisingr> > a
12:24:19 <lambdabot>   a
12:24:23 <ski> > a == a + 0
12:24:24 <lambdabot>   False
12:24:41 <ski> > a ^ 5
12:24:42 <lambdabot>   a * a * (a * a) * a
12:24:44 <mauke> > a /= a + 0
12:24:45 <lambdabot>   True
12:24:56 <brisingr> huh
12:25:13 <ski> it is just doing structural comparision on the expressions
12:25:31 <brisingr> it seems it only has some reserved names
12:25:34 <ski> yes
12:25:47 <ski> > f a :: Expr
12:25:48 <lambdabot>   f a
12:25:50 <ski> > f a b :: Expr
12:25:51 <lambdabot>   f a b
12:26:05 <brisingr> That's actually very useful.
12:26:08 <ski> @type f `asTypeIn` $ \f -> f a :: Expr
12:26:09 <lambdabot> parse error on input `$'
12:26:17 <ski> @type f `asTypeIn` \f -> f a :: Expr
12:26:18 <lambdabot> Expr -> Expr
12:26:21 <ski> @type f `asTypeIn` \f -> f a b :: Expr
12:26:22 <lambdabot> Expr -> Expr -> Expr
12:26:25 <ski> @type f
12:26:26 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
12:27:00 <edwardk> whoa. we aren't on the list of approved google summer of code projects this year
12:27:09 <rostayob> yep.
12:28:08 <edwardk> it is WAY smaller this year
12:28:17 <edwardk> there are about a third of the number of accepted organizations =(
12:28:39 <hpc> i have lambdabot from darcs
12:28:40 <sclv> shit
12:28:49 <sclv> bummed
12:28:53 <hpc> is there a way to install all the dependencies without doing them individually
12:28:53 <Igloo> edwardk: They're still adding orgs
12:29:04 <hpc> and without "cabal install lambdabot" to get the current hackage version?
12:29:13 * sclv wipes his brow
12:29:35 <edwardk> ah, we actually were accepted
12:29:40 <edwardk> i just received the email =)
12:29:52 <weexplat> my biggest annoyance with haskell is every single time i start a project i end up futzing around for a couple of hours deciding how to handle command line arguments
12:29:55 <Saizan> hpc: there's a --deps-only flag or similar, check cabal install --help
12:30:34 <acfoltzer> edwardk: great! I just hit refresh on the list though, and still no luck there. Wonder why
12:30:39 <weexplat> in perl i always used Getopt::Std.  hardly ideal, but easy as pie and boom!  i'm done.
12:30:50 <edwardk> acfoltzer: i think i have another form to fill out before we appear
12:31:10 <weexplat> in haskell i feel like so far i haven't found anything lightweight and flexible enough to 'settle', even for a first cut, so i always have to shop around
12:31:15 <edwardk> (i need to pass along the financial contact information for the new umbrella organization)
12:31:29 <acfoltzer> edwardk: ah, that's cool. I was just quite surprised to not see the org on there at first :)
12:31:40 <hpc> Saizan: cool, misted that
12:31:41 <edwardk> likewise
12:31:43 <hpc> *missed
12:33:20 <dschoepe> weexplat: Did you try cmdargs?
12:33:56 <acfoltzer> I am really hoping someone signs up to have rrnewton mentor them on this: http://hackage.haskell.org/trac/summer-of-code/ticket/1608
12:34:52 <makkron> I would be interested
12:35:13 <rostayob> I'd be interested if I weren't working...
12:36:09 <acfoltzer> I guess the first step is to bug him to actually register as a mentor though...
12:36:25 <hpc> lambdabot in darcs is uninstallable
12:36:32 <hpc> lambdabot wants mtl > 2
12:36:39 <hpc> mueval wants mtl < 1.2
12:36:48 <rostayob> hpc: installing lambdabot is dark magic.
12:37:16 <hpc> oh wait, im derp
12:37:25 <hpc> mueval is a standalone thing, so i just install it separately
12:38:06 <hpc> can that sort of thing be expressed in a cabal file?
12:38:17 <rostayob> it's weird anyways. mueval requires mtl < 1.2 and base 4.*.
12:38:26 <rostayob> that's suspicious
12:38:49 <hpc> yeah, i took on the probably-impossible task of cleaning up lambdabot
12:38:55 <hpc> looks like i need to clean up mueval first
12:40:03 <hpc> im seeing a lot of glasgowExtensions warnings too
12:40:12 <hpc> scrolling too fast for me to see where
12:40:13 <dmwit> ?free maplike :: (a -> b) -> f a -> f b
12:40:13 <lambdabot> Extra stuff at end of line
12:40:24 <dmwit> ?free (a -> b) -> f a -> f b
12:40:24 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:44:56 <ben> http://hpaste.org/65415 is there a way I can get this into constant space?
12:45:06 <hpc> it looks like mueval is the only thing holding lambdabot back from a fresh install in a fresh vm
12:47:10 <unlink> Is there a remotely elegant way of altering maps inside of a record inside of StateT?
12:47:38 <zachk> how do I forget a @let statement?
12:47:43 <roconnor> unlink: lenses!
12:48:09 <roconnor> unlink: would you like to know more?
12:48:31 <unlink> do { people <- gets recPeople ; modify $ \s -> s { recPeople = M.delete person people } } <-- ugh.
12:48:36 <copumpkin> don't do it! roconnor will eat you with his lenses
12:48:49 <roconnor> unlink: lenses will do that except way more elegantly
12:49:26 <unlink> I am skeptical, but interested.
12:50:04 <roconnor> unlink: okay, lets have a look at the currently undocument data-lens library.
12:50:12 <unlink> perfect.
12:50:34 <hpc> ive emailed gwern about mueval, since hackage says that's who to email
12:50:37 <roconnor> unlink: http://hackage.haskell.org/packages/archive/data-lens/2.0.2/doc/html/Data-Lens-Common.html
12:51:07 <danharaj> oh god
12:51:09 <roconnor> unlink: lens :: (a -> b) -> (b -> a -> a) -> Lens a b -- this is the main constuction functor for lenses
12:51:14 <danharaj> whose idea was it to include that operator soup api
12:51:26 <roconnor> danharaj: I might clean that up
12:51:33 <danharaj> roconnor: please do :3
12:51:45 <roconnor> unlink: lens constructs a lens out of a getter (a -> b) and a setter (b -> a -> a)
12:51:58 <roconnor> unlink: however there are several stock lenses premade for you that you will be able to use
12:52:29 <hpc> that's not really an operator soup
12:52:34 <hpc> it's just missing documentation
12:52:55 <roconnor> unlink: so a lens is a data-type that focuses into a substructure of a superstructure.  ie. given a super structure it lets you get the substructure and set the substructure.
12:53:15 <roconnor> unlink: the most common case is where the superstructure is a record, and the substructure is a field.
12:54:06 <roconnor> unlink: for example, you will write recPeopleLens = lens recPeople (\nv s -> s { recPeople = nv})
12:54:38 <roconnor> unlink: that will build a Lens R F where R is your record type, whatever it is, and F is your field type, whatever it is.
12:54:50 <roconnor> unlink: now the most important bit!
12:55:00 <roconnor> unlink: Lenses form a Category!
12:55:07 <danharaj> roconnor: Have you considered a TH module to add sugar for record lenses?
12:55:31 <lpsmith> danharaj, already in data-lens-template
12:55:35 <danharaj> aha
12:55:36 <danharaj> see
12:55:39 <danharaj> you guys are so good at this.
12:55:57 <roconnor> danharaj unlink: ya, I data-lens-template will use template haskell to generate lenses from record declarations
12:56:22 <roconnor> unlink: So given a Lens A B and a Lens B C, you can compose them to get Lens A C.
12:56:54 <roconnor> This is very important.  It greatly increases modularity as we will see
12:57:38 <unlink> ah
12:57:38 <roconnor> unlink: because there is a stock lens for Data.Map : http://hackage.haskell.org/packages/archive/data-lens/2.0.2/doc/html/Data-Lens-Common.html#v:mapLens
12:58:09 <roconnor> unlink: So your recPeople is a map right?
12:58:12 <unlink> this could be useful. I have a record -> map -> record -> map structure.
12:58:59 <roconnor> so given a person, we can build (mapLens person :: Lens (Map Person Thingy) Thingy
12:59:03 <hpaste> unlink pasted ‚Äúthe records, they burn‚Äù at http://hpaste.org/65416
12:59:12 <roconnor> unlink: and now we can compose
12:59:56 <roconnor> unlink: (mapLens person) . recPeopleLens, or if you prefer recPeopleLens >>> mapLens person.
13:00:13 <roconnor> will be a Lens RecordType Thingy
13:00:47 <roconnor> okay, so that is great in of itself; and would be good enough reason to use Lenses, but wait, there is more
13:00:59 <roconnor> unlink: Lenses interact with StateT very very nicely
13:01:32 <roconnor> unlink: so suppose you are using the standard Lazy-StateT : http://hackage.haskell.org/packages/archive/data-lens/2.0.2/doc/html/Data-Lens-Lazy.html
13:01:48 <roconnor> (the same operations are available for Strict-StateT in another module).
13:02:09 <unlink> roconnor: this seems to be what the doctor ordered.
13:02:24 <roconnor> you can use access (recPeopleLens >>> mapLens person) to get StateT Record m Thingy
13:02:30 <roconnor> and to update
13:02:58 <roconnor> (recPeopleLens >>> mapLens person) ~= newThingy :: StateT Record m Thingy
13:03:13 <roconnor> (you can of course give a name to recPeopleLens >>> mapLens person if you want)
13:03:32 <roconnor> != will do a seq and then update
13:03:53 <roconnor> If thingy is a Num type you can use += to increment and *= and such
13:04:11 <roconnor> similalry &&= and ||= if Thingy is Bool.
13:04:50 <roconnor> So this gives you imperative update style code, without being imperative.
13:04:55 <roconnor> unlink: but there is still more
13:05:28 <roconnor> unlink: By far the most awesome function is focus :: Monad m => Lens a b -> StateT b m c -> StateT a m c
13:05:40 <roconnor> So given a Lens A B
13:06:05 <roconnor> focus lets you "lift" a StateT B m c into a StateT A m c
13:06:57 <roconnor> i.e. you can write a bunch of State code that manuplates state on a focused substructure, and KNOW from the type system that bit of code wont touch parts of the "global" state that it shouldn't be touching
13:07:30 <roconnor> and then you can "lift" it with focus into your StateT A m c, where A is the "global" state that your program is working on.
13:07:41 <roconnor> unlink: so that is it.  That is how lenses work.
13:09:43 <unlink> roconnor: that is quite cool. I'll let you know how things work out.
13:11:52 * hackagebot nanoAgda 0.1.1 - A toy dependently-typed language  http://hackage.haskell.org/package/nanoAgda-0.1.1 (JeanPhilippeBernardy)
13:13:44 <saml> i foudn a bug
13:13:51 <saml> > ([] :: [Int]) == ([] :: [Char])
13:13:52 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:13:52 <lambdabot>         against inferred type ...
13:13:58 <hpc> saml: not a bug
13:14:05 <hpc> the types are different
13:14:07 <saml> but empty set is the unique set
13:14:08 <hpc> :t (==)
13:14:09 <lambdabot> forall a. (Eq a) => a -> a -> Bool
13:14:13 <hpc> it's not a set, it's a list
13:14:18 <saml> ah my bad
13:14:28 <hpc> and it would still be the same if you used Set
13:15:01 <hpc> something of one type is never comparable to something of another type
13:15:10 <hikingpete> @pl (\(x1, y1)  (x2, y2) -> (x1+x2, y1+y2))
13:15:10 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
13:15:16 <hikingpete> Oh god.
13:15:35 <rostayob> much better.
13:15:37 <hpc> :t join (***) (+)
13:15:38 <lambdabot> forall b. (Num b) => (b, b) -> (b -> b, b -> b)
13:15:52 <saml> > Data.Set.fromList ([] :: [Int]) == Data.Set.fromList ([] :: [Char])
13:15:52 <lambdabot>   Not in scope: `Data.Set.fromList'Not in scope: `Data.Set.fromList'
13:16:03 <hpc> and... not sure how to get from there to (b, b) again
13:17:28 <saml> so, every null set should be the same?
13:17:42 <saml> but different in haskell?
13:17:59 <hpc> if they aren't even the same type, they can't be equal
13:17:59 <roconnor> each [] of a different types are different.
13:18:26 <saml> wouldn't it make sense to have them consider the same?
13:18:41 <hpc> saml: when you figure out how to do that, let us know
13:18:41 <saml> or will it cause paradox?
13:18:42 <roconnor> saml: not in a strongly typed system
13:19:07 <saml> In mathematics, and more specifically set theory, the empty set is the unique set having no elements
13:19:14 <mauke> that's nice?
13:19:16 <saml> *the* unique set
13:19:22 <saml> so type theory is different
13:19:26 <mauke> saml: this is about ==
13:19:29 <roconnor> yep, type theory is different
13:19:37 <saml> this is so hard
13:19:41 <hpc> > "haskell" == "set theory"
13:19:42 <lambdabot>   False
13:19:44 <saml> i can't understand and i'm losing hair
13:20:13 <roconnor> saml: OTOH we don't say that 1 \in <0,0> in type theory like they do in set theory.
13:20:17 <hpc> saml: let empty1 = [] :: [Int]; empty 2 = [] :: [Char]
13:20:34 <hpc> saml: empty1 == empty2 is true, hypothetically
13:20:48 <geekagent> saml: The empty list is still universal in type theory, just in a different way.
13:20:48 <hpc> saml: "five" == [5, 5, 5, 5, 5] obviously doesn't typecheck
13:21:00 <hpc> saml: so what about bigExpressionHere == bigExpressionHere?
13:21:03 <hpc> does that typecheck?
13:21:11 <geekagent> saml: univ :: () -> [b]
13:21:19 <geekagent> univ = const []
13:21:42 <saml> so, () is empty set in haskell
13:21:49 <mauke> wat
13:21:50 <hpc> no
13:21:53 <geekagent> saml:
13:21:53 <hpc> stop thinking in sets
13:22:07 <ChristianS> > [] == []
13:22:08 <lambdabot>   True
13:22:10 <geekagent> saml: () is more like the singleton set, but yes, stop thinking in sets
13:22:14 <ChristianS> > ([] :: [Int]) == ([] :: [Char])
13:22:14 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:22:15 <lambdabot>         against inferred type ...
13:22:19 <mauke> ChristianS: why again?
13:22:33 <monochrom> people underestimate the power of the knowledge that haskell is just a programming language, not mathematica
13:22:41 <hpc> saml: if you REAAAALLY can't stop thinking in sets, then think of types as sets
13:22:46 <ChristianS> mauke: just bored
13:22:47 <hpc> saml: so [Int] is a set, not []
13:23:02 <hpc> and the elements of [Int] are [], [0], [1], ...
13:23:13 <saml> type is a metadata of a value in haskell?
13:23:25 <mauke> I don't think so
13:23:29 <hpc> a type is a type
13:23:38 <xplat> dschoepe_: i've tried cmdargs before, it seems kind of messy and inflexible
13:23:38 <monochrom> what is "metadata"?
13:23:53 <glguy> data data?
13:23:58 <Clint> value is a metadatum of a type
13:23:59 <monochrom> or perhaps it's all irrelevant
13:24:03 <saml> computation is over value.. and before computation, haskell does weird computation like "type checking"
13:24:06 <xplat> dschoepe_: trying desperately to avoid boilerplate, yet somehow in the wrong way
13:24:18 <mauke> @let a === b = cast a == Just b
13:24:19 <lambdabot>  Defined.
13:24:35 <otters> :t cast
13:24:36 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
13:24:52 <saml> cast is actual computation over value?
13:25:02 <otters> @where cast
13:25:02 <lambdabot> I know nothing about cast.
13:25:05 <hpc> oh god, pretend Typeable doesn't exist
13:25:50 <sclv> > "hello" === 1
13:25:51 <lambdabot>   False
13:26:05 <hpc> i can't even think of how to explain this besides "forget what you think you know and @where lyah"
13:26:06 <sclv> > id === id
13:26:07 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:26:07 <lambdabot>    `Data.Typeable.Typeable a...
13:26:19 <monochrom> "what is type?" answer: type is what satisfies the axioms of types. the axioms are e.g. type-checking rules in TaPL
13:26:23 <saml> what module has === ?
13:26:26 <sclv> > (id :: String -> String) === (id :: String -> String)
13:26:27 <lambdabot>   *Exception: (==): No overloading for function
13:26:53 <glguy> saml: none, it was defined by mauke with a @let command
13:26:59 <sclv> > (id :: String -> String) === "hello"
13:27:01 <monochrom> so, take TaPL, take type rules you find there, those are the axioms of types. the end.
13:27:01 <lambdabot>   False
13:27:05 <saml> oh i see
13:27:18 <glguy> > "hello" === (id :: String -> String)
13:27:20 <lambdabot>   False
13:27:36 <dschoepe> xplat: Hm, I actually like it better than the standard getopt approaches (For example, not having to write some option specification _and_ usage instructions as one has to with Getopt::Long in perl).
13:28:01 <xplat> oh, awesome, hs-logo
13:28:08 <ChristianS> > ([] :: [Int]) === ([] :: [Char])
13:28:10 <lambdabot>   False
13:28:41 <geekagent> saml: [] is a polymorphic value. Given a type 'b' , it is the empty list of type [b].
13:28:44 <xplat> finally haskell can handle the turtle-oriented paradigm :)
13:28:57 <geekagent> So there isn't just one [], there's one for every type of list.
13:29:23 <sclv> somebody should totally write a logo where the turtle traverses various interesting topological objects, like hyperspheres.
13:29:49 <geekagent> sclv: Like a moebius strip and a klein bottle?
13:30:01 <saml> so type is metadata of value in haskell
13:30:02 <hpc> https://en.wikipedia.org/wiki/Calabi%E2%80%93Yau_manifold
13:30:16 <xplat> in a turtle-oriented language, what are turtles made of?  turtles!  it's turtles all the way down.
13:30:29 <geekagent> xplat++
13:30:29 <monochrom> I would leave open whether there is one [] shared by many types or there are many []s one per type. it should not matter. you don't need either axiom.
13:30:36 <osfameron> heh
13:30:43 <hpc> all you need is the type of (==)
13:30:46 <hpc> :t (==)
13:30:47 <lambdabot> forall a. (Eq a) => a -> a -> Bool
13:30:58 <hpc> if those 'a's are not both the same, it doesn't typecheck
13:30:59 <hpc> end of story
13:31:02 <elemir> geekagent: It's not true. In theory there is one [] typed "forall a. [a]"
13:31:07 <sclv> > (===) === (===)
13:31:08 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:31:08 <lambdabot>    `Data.Typeable.Typeable a...
13:31:20 <danharaj> if I have a lambda of type (s -> Foo), polymorphic in s, how can I lift it to type (forall s. s -> Foo)?
13:31:22 <otters> :t (===)
13:31:23 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
13:31:30 <hpc> and all this "counting the empty lists" stuff isn't even well-defined
13:31:39 <mauke> danharaj: isn't that the same thing?
13:31:44 <sclv> > ((===) :: Bool -> Bool -> Bool) === ((===) :: Int -> Int -> Bool)
13:31:45 <lambdabot>   False
13:31:50 <danharaj> mauke: ghc is telling me no.
13:31:53 * hackagebot snaplet-redis 0.1.0.1 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.0.1 (DmitryDzhus)
13:31:56 <mauke> danharaj: what are you doing?
13:31:59 <xplat> elemir: it's ambiguous whether polymorphic values are actual values or schemas, at least in Haskell98
13:32:13 <elemir> Haskell98 is joke
13:32:24 <danharaj> mauke: storing a function in a lambda with the quantifier in there.
13:32:40 <mauke> danharaj: "storing a function in a lambda"? what
13:32:47 <hpaste> danharaj pasted ‚Äúblah‚Äù at http://hpaste.org/65418
13:32:57 <danharaj> er
13:32:59 <danharaj> storing a function in a newtype
13:33:04 <danharaj> I need coffee.
13:33:09 <mauke> I need the code
13:33:31 <sclv> so get up/get down/haskell98 is a joke in yo town/late haskell 98 wears the late crown.
13:33:52 <elemir> Haskell98 is lazy pure ML with type classes and another syntax
13:34:17 <xplat> even with RankNTypes it's ambiguous whether [] used at a specific type is a polymorphic value or the polymorphic [] applied to a hidden type argument
13:34:31 <hpaste> danharaj annotated ‚Äúblah‚Äù with ‚Äúblah (annotation)‚Äù at http://hpaste.org/65418#a65419
13:34:44 <danharaj> mauke: there.
13:34:52 <hpc> elemir: that's like saying python is duck-typed C with an implicit top-level main function and another syntax
13:34:55 <hpc> :P
13:35:26 <elemir> There is many pure lazy ML implementation
13:35:27 <xplat> elemir: so what?  ML is lisp with partially algebraic syntax, static types and less unnecessary mutability
13:35:35 <mauke> danharaj: I can't run that
13:36:02 <elemir> Haskell 98 wasn't first or last
13:36:08 <geekagent> elemir: but for a set semantics, "forall a. [a]" means a natural transformation from the Identity Functor to [].
13:36:11 <danharaj> mauke: let me cook up a context free example.
13:36:55 * hackagebot mueval 0.8.2 - Safely evaluate Haskell expressions  http://hackage.haskell.org/package/mueval-0.8.2 (GwernBranwen)
13:37:00 <xplat> geekagent: er, not, it's from a constant functor
13:37:13 <hikingpete> Are expressions like `0 <= x < 4' not allowed by haskell?
13:37:14 <hpc> also not "Functor"
13:37:22 <geekagent> xplat: right.
13:37:24 <hpc> hikingpete: no
13:37:25 <elemir> Type classes are eqivalent for SML modules, so Haskell98 is really joke
13:37:40 <hpc> > let x = 3 in 0 <= x && x < 4
13:37:41 <lambdabot>   True
13:37:55 <hikingpete> Alright, thanks.
13:38:15 <hpc> see also, the type of all those functions
13:38:18 <hpc> :t (<)
13:38:19 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:38:32 <xplat> SML modules are equivalent for certain well-typed macros, so SML is 'really joke'
13:38:47 <sclv> elemir: what you described was basically the point of haskell!
13:38:52 <hpc> (0 <= x < 4) either parses as (0 <= x) < 4, or 0 <= (x < 4)
13:38:53 <hpaste> ClaudiusMaximus annotated ‚Äúfolding‚Äù with ‚Äúfolding (annotation)‚Äù at http://hpaste.org/65415#a65420
13:38:56 <hpc> neither of which is well-typed
13:39:00 <elemir> xplat: No, they aren't
13:39:05 <sclv> except then along came monads.
13:39:05 <ClaudiusMaximus> ben: ^^
13:39:16 <sclv> and mptcs
13:39:17 <geekagent> elemir: that natural transformation picks out one element in every set [a]
13:39:22 <rwbarton> > 0 <= x < 4
13:39:22 <lambdabot>   Precedence parsing error
13:39:23 <lambdabot>      cannot mix `GHC.Classes.<=' [infix 4] and `GH...
13:39:38 <geekagent> so there's one natural transform, but also one empty list of every type.
13:39:39 <ben> Cool, cheers
13:39:56 <sclv> haskell wasn't invented to be innovative at first but precisely to standardize an fp in the ml tradition with purity and laziness.
13:40:05 <xplat> elemir: so name something that SML modules can do that no lisp macro can do.
13:40:29 <geekagent> sclv: the first haskell compiler was written in Lazy-ML
13:40:49 <elemir> lisp macro cannot be predicate for existentials :3
13:41:17 <ben> That's fairly close to what I was thinking of earlier, it's much better than what I ended up doing
13:41:24 <xplat> elemir: ???
13:42:39 <danharaj> ok what the hell. Mauke: I got it to compile but what fixed it doesn't make sense to me.
13:42:45 <sclv> geekagent: and based on a modified lml compiler too :-)
13:43:09 <elemir> xplat: SML modules and type clasess are both type system
13:43:12 <ClaudiusMaximus> ben: i think it's quite elegant in that the type shows that to get the fold result you have to traverse the whole list, while the map results can be got incrementally
13:43:46 <hpaste> catseye pasted ‚ÄúExc.catch problem‚Äù at http://hpaste.org/65421
13:43:59 <elemir> They are equivalent type systems.
13:44:27 <sclv> and yale haskell was written in common lisp!
13:44:28 <catseye> hello. if someone could enlighten me as to why the code I just put on hpaste does what it does, i would be quite grateful.
13:44:36 <elemir> Lisp macros are ugly crutch not related with types
13:45:38 <catseye> i must be missing a place where i need to force strict evaluation, but i haven't been able to figure out where.
13:46:17 <sclv> catseye: you're not forcing deep evaluation of the function
13:46:19 <sclv> just whnf
13:46:27 <xplat> elemir: there are several versions of SML-like modules and several versions of type classes.  you can rephrase every typeclass-system as a module-system and vice versa, but the two perspectives invite exploration of different parts of the design space
13:46:28 <sclv> so the recursive evals can run into the pattern match failure
13:46:32 <sclv> and you hit them too late.
13:47:10 <xplat> elemir: also, they are obviously different at the UI level and make different things easy even when they are formally equivalent
13:47:20 <rwbarton> yep, in particular the "evaluate" just evaluates eval p down to the form Cons ??? ??? but the exception is raised later when you try to evaluate those subexpressions
13:47:20 <hpaste> danharaj annotated ‚Äúblah‚Äù with ‚Äúblah (annotation)‚Äù at http://hpaste.org/65418#a65422
13:47:50 <danharaj> mauke: That annotation can be run and shows the problem. `action` typechecks, `action' ` doesn't.
13:47:54 <xplat> elemir: and when type classes were first discovered the equivalence was not known--just knowing it exists was a useful discovery in PLT
13:48:17 <catseye> so, evaluation needs to be strict AND deep.  ok, that makes sense.  thanks!
13:48:50 <sclv> also as i recall once you get mptcs and fundeps or typefuns, then the equiv breaks down.
13:49:45 <c_wraith> aren't there mechanical differences as well?  ML functors allow sharing implementations in some way typeclasses don't?
13:50:19 <mauke> danharaj: action = tell (Action (\arr -> writeArray arr 1 1))
13:50:45 <xplat> c_wraith: iirc instances with constraints let you do the same thing
13:51:16 <mauke> danharaj: action' = (tell . Action) (\arr -> writeArray arr 1 1) still works
13:51:19 <mauke> danharaj: $ breaks it
13:51:35 <ClaudiusMaximus> catseye: a small side point, a common convention is to use Left for failures and Right for successes, which makes your code slightly confusing at first glance
13:51:35 <mauke> presumably because it monomorphs it down
13:51:55 * hackagebot snaplet-acid-state 0.2 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2 (DougBeardsley)
13:52:24 <danharaj> mauke: Just tried it with NoMonomorphismRestriction, it still doesn't compile. I am on an old version of GHC, can you tell me what error you get?
13:52:33 <xplat> Right is used for success both because of the pun and because it gives the right kind for Functor and Monad instances
13:52:48 <mauke> danharaj: for which version?
13:53:00 <catseye> oh, but deepseq is not derivable... so I can't $!! on arbitrary Haskell functions?  that's not so good.
13:53:03 <danharaj> mauke: I'm on 7.0.3. Perhaps a later version gives a more insightful error.
13:53:11 <mauke> danharaj: ... of the code
13:53:12 <xplat> so for the latter reason it's actually somewhat important that success is Right and failure is Left
13:53:19 <mauke> danharaj: and I'm on 7.0.4
13:53:51 <geekagent> catseye: how do you deepseq Cont r a?
13:54:30 <rwbarton> Data.Derive can probably produce Deepseq instances
13:54:33 <hpaste> danharaj annotated ‚Äúblah‚Äù with ‚Äúblah NMR‚Äù at http://hpaste.org/65418#a65423
13:54:41 <zhulikas> @hoogle (,) -> Int
13:54:41 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
13:54:42 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
13:54:42 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
13:54:53 <zhulikas> how to find out a number of elements in a tuple?
13:54:56 <danharaj> mauke: that one.
13:54:58 <catseye> geekagent: i have no idea; deepseq is new to me
13:55:10 <hpc> zhulikas: you don't
13:55:10 <rwbarton> zhulikas: count the number of commas and add one
13:55:18 <hpc> tuples of different sizes are different types
13:55:25 <geekagent> zhulikas: what hpc said
13:55:28 <mauke> danharaj: why NoMonomorphismRestriction?
13:55:33 <mauke> and why so many annotations?
13:55:34 <zhulikas> jeez
13:55:36 <zhulikas> so strict!
13:55:46 <xplat> tuple is not a single type in haskell
13:55:54 <hpc> zhulikas: you want strict, try #python ;)
13:55:59 <zhulikas> :D
13:56:04 <xplat> so there's no type you can give to a function to get the length
13:56:20 <zhulikas> what about using TH?
13:56:22 <xplat> plus the length is useless without knowing which types the elements are
13:56:32 <zhulikas> I am following an example where first element of tuple is returned
13:56:32 <geekagent> In fact, tuple is syntacital sugar for a group of constructors (,) (,,) (,,,) ...
13:56:33 <monochrom> please don't use a tuple for this
13:56:33 <hpc> zhulikas: that will work, but it's scary and compile-time
13:56:42 <hpc> if that happens to be what you need, have fun
13:56:44 <zhulikas> but that expression takes a number of elements in a tuple
13:56:46 <hpc> but it probably isn't
13:56:53 <geekagent> s/syntacital/syntactical
13:56:56 <zhulikas> hpc, actually my intention is to learn TH
13:57:03 <hpc> oh, then have fun :D
13:57:06 <zhulikas> :))
13:57:10 <zhulikas> it's actually quite fun
13:57:13 <zhulikas> and not so difficult :P
13:57:27 <zhulikas> (at least the basics)
13:57:34 <hpc> one of these days ill get over my indomitable distaste for macros and learn it
13:57:39 <hpc> probably
13:57:39 <zhulikas> :)
13:57:40 <zachk> compared to what? O;-^ p
13:57:43 <catseye> rwbarton: thanks, i'll look into it -- but this is quickly exploding in scope...
13:58:02 <monochrom> there is clearly a contradiction between "I'll write it in TH" and "where is it in Prelude?"
13:58:03 <zhulikas> I like the concept
13:58:08 <rwbarton> catseye, a lazy inefficient way would be to deepseq the result of show
13:58:11 <zhulikas> program the programming language:}
13:58:22 <rwbarton> (lazy as in lazy for the programmer, not lazy evaluation :)
13:58:32 <catseye> rwbarton: interesting.
13:58:37 <catseye> that might be sufficient
14:01:55 * hackagebot yesod-markdown 0.3.4 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.3.4 (PatrickBrisbin)
14:01:58 <t7> neutrinos are slow :(
14:02:12 <t7> there goes my neutrino based computer idea
14:02:14 <roconnor> slower than light.
14:02:35 <geekagent> roconnor: just barely
14:03:01 <roconnor> geekagent: presumably a neutrino at rest is a lot slower than light.
14:03:12 * roconnor wonders if neutrinos at rest are stable
14:03:49 * hpc wonders what a neutrino's rest mass is
14:04:44 <zachk> the neutrino is just some surf board riding a brane wave, and when it comes to rest the surfer falls off and the board stops obeying our laws of statistical physics
14:05:16 * hpc has never met a surfer with branes
14:06:05 <monochrom> BRAAAANES
14:06:11 <geekagent> roconnor: They detect neutrinos by having them go through a medium where the speed of light is slower.
14:06:20 <zachk> like brane from M-theory
14:11:56 * hackagebot snap 0.8.0.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.8.0.1 (DougBeardsley)
14:12:01 <sclv> catseye: yep, length . show is my default lazy man's deepseq
14:16:41 <catseye> hm, it would still require the result type to be an instance of Show.  which... i might be able to live with
14:17:11 <catseye> in fact, yeah, i can live with that
14:17:18 <rwbarton> @hoogle gdeepseq
14:17:18 <lambdabot> No results found
14:19:31 <drdo> We should really standardize a Serializable class somewhere
14:25:39 <roconnor> like in cereal?
14:25:40 <sclv> drdo: we do have a standard serializable! Data.Binary is in the platform.
14:25:55 <roconnor> drdo: don't use the platform, it is a trap!
14:26:15 <sclv> arguably Data.Binary isn't the best for all porpoises, but it is the standard.
14:26:17 <drdo> sclv: Just the class, not the whole kitchen
14:26:36 <drdo> Maybe i want to use attoparsec or blaze-builder or whatever
14:27:03 <drdo> Also binary is unusable, error handling is not possible
14:27:08 <sclv> you can just use the class w/o the kitchen.
14:27:10 <roconnor> no respectable dolphin would use Data.Binary
14:27:31 <sclv> yes, it isn't dolphin safe.
14:37:50 <nand`> I believe I've asked this before but easiest way to write a list of Word16s to a file, in little endian ordering?
14:38:03 <nand`> Does not necessarily have to be Word16s but I want to write 16-bit unsigned integers
14:38:16 <roconnor> nand`: use cereal's putWord16le
14:39:38 <nand`> roconnor: thanks
14:41:51 <nyingen> mm, cereal
14:42:19 <edwardk> yay, we exist! http://www.google-melange.com/gsoc/org/google/gsoc2012/haskell
14:42:35 <acowley> Oh darnit, I abused Eq and that's why PSQueue is behaving differently from fingertree-psqueue
14:43:00 <acowley> Why couldn't my dirty hack go unnoticed?!
14:43:11 <roconnor> I see an edwardk
14:43:25 <edwardk> roconnor: hah yeah
14:43:27 <acowley> Yes, GSoC orbits him
14:43:43 <cmccann> kind of looming over everyone else there
14:44:02 <edwardk> you can see me in last year's photo as well
14:44:03 <edwardk> http://www.facebook.com/ekmett
14:44:08 <edwardk> wearing a haskell shirt
14:44:25 <edwardk> sadly facebook butchers the resolution of that image
14:46:42 <hikingpete> (\x y-> compare (length x) (length y))
14:46:46 <hikingpete> @pl (\x y-> compare (length x) (length y))
14:46:47 <lambdabot> (. length) . compare . length
14:46:51 <acowley> You're like a halo over the bind-lambda
14:47:38 <edwardk> =)
14:47:55 <acowley> I saw the logo, isolated against a uniform black field, first, then my eyes drifted up and edwardk said, "Comonad"
14:48:42 <edwardk> hah
14:48:53 <edwardk> clearly i need a version with a comonadic version of that symbol
14:49:10 <acowley> Well, I'm glad that haskell was accepted. I always enjoy the discussions GSoC projects bring up. And I always hope someone will do something with OpenGL one of these times.
14:49:28 <edwardk> acowley: lispy had a student last time who was doing opengl stuff
14:49:35 <edwardk> he just stopped responding before the mid term =(
14:49:38 <acowley> yeah, but I understand it didn't pan out
14:49:43 <xplat> dschoepe: my main problems with cmdargs Implicit style are 1) &= is too magical 2) despite this, it's not magical enough to get everything in the data declaration and 3) you're basically stuck keeping your flags in a single record in the first place
14:49:52 <acowley> right, well, it's a big nasty project with as many opinions as users
14:50:07 <sclv> Do we even have a std comonadic bind operator?
14:50:10 <xplat> dschoepe: but it's not like i really have any clearly better alternatives, hence my rant in the first place
14:50:16 <luite_> my current haskell opengl strategy is to generate javascript that uses webgl :)
14:50:32 <ben> gross
14:50:55 <acowley> I've been doing OpenGL 3.x stuff interoperating with OpenCL, and I can do it from Haskell, but I don't hesitate at FFI'ing something when it acts weird from Haskell.
14:51:37 * lispy perks up
14:51:43 <lispy> Someone said OpenGL/OpenCL?
14:51:46 <luite_> ben: hehe it was kind of a joke, but I actually do use it that way, not because I want to use opengl, but because I already use haskell to generate web stuff and want 3d there
14:52:02 * hackagebot diagrams-svg 0.3.1 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.3.1 (DeepakJois)
14:52:16 <ben> luite_: I think it's amazing how recently all kinds of problems are solved by generating javascript, though ;)
14:53:23 <dschoepe> xplat: I agree with 1), that's why I prefer the explicit variants (which are just as usable) and count myself as lucky that I haven't run into 2) yet. :) -- There's also a ticket about allowing nested records, since having to have only a single record can indeed get annoying, especially when sharing some options between modes.
14:53:31 <astrobunny> wtf
14:53:32 <luite_> yeah, I found ot that Chrome isn't terribly reliable though... somtimes it seems to just compile something wrong, and you won't get the right results out of your javascript until you fully restart the browser
14:53:41 <astrobunny> someon said generate javascript o.o
14:53:44 <astrobunny> what folly
14:53:46 <astrobunny> what heresy
14:53:58 <ben> wow
14:54:12 <exFalso1> hi, does anyone know how to pass in flags to inferior-haskell-load-file in emacs haskell-mode?
14:54:42 <drdo> exFalso1: I just include them in haskell-program-name :P
14:55:09 <exFalso1> drdo: :D thanks ill try that
14:55:30 <roconnor> sclv: you mean extend?
14:56:04 <dschoepe> xplat: Err, I meant the Pure operators, not Explicit. (+= instead of &=)
14:56:06 <t7> @hoogle Text -> String
14:56:07 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
14:56:07 <lambdabot> Data.Text.Internal showText :: Text -> String
14:56:07 <lambdabot> Data.Text.Lazy unpack :: Text -> String
14:56:42 <hpc> > showStructure (text "oh hi there")
14:56:43 <lambdabot>   Not in scope: `showStructure'
14:56:46 <hpc> :(
14:58:11 <hpc> @src text
14:58:12 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:03:59 <t7> > (reads "123 321") :: ReadS Int32
15:04:00 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
15:04:00 <lambdabot>           ...
15:04:20 <t7> > (reads "123 321") :: [(Int32, String)]
15:04:21 <lambdabot>   [(123," 321")]
15:15:51 <hpaste> nooodl pasted ‚Äúugly fmap‚Äù at http://hpaste.org/65424
15:16:16 <causative> what programming language (not just haskell) work has been done on abstracting away the distinction between client and server, so the programmer doesn't have to worry about the semantics of setting up a protocol and sending specific pieces of data back and forth?
15:16:18 <nooodl> ^ this function does what i want it to do, but how can i get rid of the "fmap (y:)"? it feels like there's a better way.
15:17:48 <latros> you can pass around a copy
15:17:56 <latros> but that's about it
15:18:11 <nooodl> mhm
15:18:39 <latros> ah wait no
15:18:42 <latros> you return the tail
15:18:53 <latros> not just the list with only one side deleted
15:19:07 <latros> btw, that's a foldl
15:19:10 <latros> pretty sure
15:19:27 <latros> ah no
15:19:28 <latros> nm
15:19:30 <latros> not a foldl
15:19:40 <nooodl> it'd look even worse if i rewrote it to one, too
15:20:13 <monochrom> C# LINQ seems to get data from either memory or server with the same interface
15:21:04 <nand`> LinQ is just the [] monad
15:21:07 <parcs`> nooodl: looks fine
15:21:32 <latros> but yeah that does look fine to me
15:21:41 <nooodl> is it proper use of fmap? it really feels unclear
15:21:43 <latros> if it's gonna be recursive the (y:) isn't going anywhere
15:21:57 <nooodl> maybe i'm just not that used to haskell programming
15:22:01 <latros> seems perfectly clear to me
15:22:11 <latros> if you get to the end of the list
15:22:15 <nooodl> but i've never directly used fmap before, outside of theoretical stuff
15:22:17 <latros> your fmap short circuits and you get Nothing
15:22:20 <Enigmagic> causative: related to linq, http://en.wikipedia.org/wiki/Microsoft_Live_Labs_Volta
15:22:28 <nooodl> mhm
15:22:35 <hpc> nooodl: ever used map?
15:22:42 <hpc> > map (* 5) [1..]
15:22:42 <latros> if you never get to the end of the list, you prepend everything that you got to beforehand
15:22:43 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,12...
15:22:50 <nooodl> hmm, you're right
15:22:52 <nooodl> that's just fmap :)
15:22:55 <hpc> ever used (.)?
15:23:10 <hpc> :t fmap `asTypeOf` (Prelude..)
15:23:11 <lambdabot> forall a b a1. (a -> b) -> (a1 -> a) -> a1 -> b
15:23:23 <latros> I think the catch is about semantics basically
15:23:28 <nooodl> asTypeOf what now?
15:23:37 <hpc> asTypeOf :: a -> a -> a
15:23:41 <latros> Prelude.. is (.)
15:23:42 <hpc> asTypeOf x y = x
15:23:45 <nooodl> oh right
15:24:04 <hpc> in other words, fmap, where f = (->) a1
15:24:06 <latros> asTypeOf is just a type constrained const
15:24:20 <latros> in fact you could just write const
15:24:29 <latros> with the signature
15:24:31 <latros> I think
15:24:39 <hpc> yeah
15:25:32 <nooodl> let me guess. Maybe's fmap is to Nothing, as map is to []... as (.) is to id?
15:26:22 <hpc> not really
15:26:27 <hpc> at least, not as pertains to Functor
15:26:55 <JoeyA> > fmap (+3) [1..5]
15:26:56 <lambdabot>   [4,5,6,7,8]
15:27:00 <JoeyA> > fmap (+3) (Just 3)
15:27:01 <lambdabot>   Just 6
15:27:10 <latros> the analogy to [] is correct
15:27:13 <JoeyA> :t fmap (+3) id
15:27:14 <lambdabot> forall a. (Num a) => a -> a
15:27:20 <latros> the analogy elsewhere really isn't, because the structure of the functor is different
15:27:48 <latros> too different to draw the analogy, I mean
15:28:41 <copumpkin> sm: you there?
15:32:48 <latros> nooodl: why are you returning Maybe anyway?
15:33:13 <nooodl> it's part of a "isPermutation" function
15:33:17 <latros> I mean, you can remove the fmap if you just don't return Maybe at all
15:33:37 <latros> if you need a Maybe at the end you can listToMaybe
15:33:41 <latros> wait on
15:33:42 <latros> *no
15:33:43 <latros> nm
15:33:52 <nooodl> it'll keep removing common elements until it can't find one to delete, in which case this function returns Nothing
15:34:08 <latros> why not just return []
15:34:55 <latros> when you either have Just NonEmptyList or Nothing, you basically just have a list in the first place
15:35:07 <latros> ah wait
15:35:13 <parcs`> you would have to return [[a]]
15:35:15 <latros> this can technically return Just []
15:35:18 <parcs`> which wouldn't help at all
15:35:29 <latros> not if it can't return Just []
15:35:32 <latros> but it looks like it can
15:35:37 <latros> if it deletes the very last element
15:35:49 <latros> so nvm, I misunderstood
15:36:11 <latros> I was just saying that Just NonEmptyList | Nothing is isomorphic to List
15:36:59 <latros> but since you can have Just [] that's entirely different, so nvm
15:37:40 <causative> Enigmagic, how does volta work? do you write one file that generates client and server code?
15:39:47 <nooodl> http://codepad.org/0JAJyfHh here's the isPermutation function
15:40:04 <YellowOnion> I'm finding it extremely hard to actually write some code, been running over the "learn you a haskell tutorial" but I find it not applied enough could someone recommend me some tutorial's that are a bit more applied?
15:40:05 <nooodl> (is that indented correctly?)
15:40:34 <exFalso1> YellowOnion: real world haskell?
15:41:50 <YellowOnion> exFalso1: cool thanks, not sure why I haven't looked at this one before
15:42:02 <latros> RWH is a bit harder to handle imo
15:42:07 <nooodl> i'd think the things LYAH teaches you are far more important than diving into "full programs" with things like IO
15:42:08 <DaveNull> YellowOnion, "Programming in Haskell" (Hutton) is a good start, too, imho
15:42:19 <latros> eh more than a bit
15:42:25 <latros> RWH is tough as a first look
15:43:16 <YellowOnion> nooodl: it's just I get bored when all I'm doing is reading, I learn by doing
15:43:30 <nooodl> after some LYAH i really enjoyed redoing some project euler exercises in haskell (mostly as one or two lines :D)
15:43:45 <nooodl> ah, i see
15:43:51 <YellowOnion> but I'll keep in on hand as a reference or something
15:44:07 <latros> I'd get through chapter...what is it, 8? on the type system
15:44:22 <latros> without the burden of trying to write things, just getting your head around that material
15:44:26 <pqmodn> YellowOnion: i found RWH pretty good for motivating me to learn the features by demonstrating them
15:44:26 <t7> i should not be writing SQL querys in this day and age
15:44:51 <t7> how can haskell not just store this stuff automagicaly? :3
15:44:53 <Clint> YellowOnion: just play around in ghci until you hit walls, then go read up
15:44:55 <nooodl> also a good exercise for me was rewriting some prelude functions. kept me interested, and taught me more about thinking the haskell way
15:44:59 <Clint> t7: you mean haskelldb?
15:45:08 <acowley> So PSQueue is working out to be over 4x faster than fingertree-psqueue for my uses
15:45:41 <pqmodn> YellowOnion: however on second and third read, i'm finding some explanations in RWH are questionable and there are quite a few errors (even in the example code)
15:46:12 <nooodl> YellowOnion, out of curiosity, how far into learn you a haskell are you?
15:47:05 <YellowOnion> I read up to like chapter 9 or something, not sure how much I took in though
15:48:03 <Clint> so you can competently use map
15:48:28 <nooodl> chapter 10 is about "functionally solving problems", which might be interesting if you're stuck on how to concretely write things
15:48:39 <YellowOnion> it's been on and off over a month, so probably not
15:50:00 <stj> is there an elegant operator that would allow me to do something like this? let n = getLine >>= read :: Int
15:51:15 <acowley> stj: n <- read <$> getLine
15:52:15 <stj> acowley: thanks
15:52:25 <nand`> or n <- read `fmap` getLine
15:52:45 <nand`> but <$> is defined on Functor and not Applicative either way
15:53:44 <cmccann> edwardk, you around?
15:54:08 <edwardk> nope
15:54:14 <cmccann> pf
15:54:18 <stj> acowley: in what module is this operator <?>
15:54:20 <cmccann> edwardk, http://dl.dropbox.com/u/15282699/coHaskell-Logo.svg
15:54:32 <edwardk> hahaha
15:54:35 <latros> lol
15:54:38 <cmccann> :D
15:54:41 <stj> I meant <$>
15:54:46 <acowley> stj: Control.Applicative
15:54:55 <nand`> cmccann: hehe
15:55:17 <cmccann> it's a quick and dirty modified version of http://upload.wikimedia.org/wikipedia/commons/1/1c/Haskell-Logo.svg
15:55:21 <cmccann> to give credit where due and all
15:55:56 <nand`> the inverted colors gives it the final touch
15:55:57 <edwardk> good job though
15:56:10 * cmccann couldn't get the spacing to look right but oh well
15:56:20 <cmccann> nand`, yes I thought that was the most important part
15:56:35 <edwardk> now i just need to get it on a shirt
15:56:46 <nand`> haskell too mainstream?
15:57:55 <latros> lol
15:58:01 <cmccann> edwardk, does the logo shirt have anything printed on the back?
15:58:18 <edwardk> nope
15:58:33 <edwardk> ideally it'd be a zip up hoody with the logo moved to the back
15:58:38 <edwardk> rather than the one that i have
15:58:55 <causative> basically we need some notion of "located computation"
15:58:57 <edwardk> which is a nice hoody but which is awkward to take off and put on
15:59:05 <causative> compute f(x) "on the server" vs. compute f(x) "on the client"
15:59:24 <causative> to compute f(x) on the client, it could be computed on the client directly, or computed on the server and then sent to the client
15:59:25 <cmccann> edwardk, yeah, was going to say that the front and back would need to be swapped if possible
15:59:37 <edwardk> perfect =)
15:59:45 <causative> and some functions, we don't care where they are computed
16:00:04 <YellowOnion> > let f =(+ 1) in map f [1, 2, 3, 4]
16:00:05 <lambdabot>   [2,3,4,5]
16:00:25 <YellowOnion> is this competent enough?
16:00:28 <causative> like if f(x) = g(h(x), j(x)) then we don't care whether h(x) is computed on the client or on the server
16:00:32 <cmccann> edwardk, if you're seriously considering putting it on a shirt or whatever I should probably fix it up a bit when I have more than a few minutes to do it, heh
16:01:02 <rasfar> where i come from they call hoodies "bunnyhugs"
16:01:08 <exFalso1> (+1) <$> [1,2,3]
16:01:18 <roconnor> awww
16:01:30 <edwardk> cmccann: sure
16:01:36 <acowley> where we're going, we don't need bunnyhugs
16:01:41 <edwardk> and yeah if i can find a nice way to do so through cafe press i will
16:01:45 <nooodl> i feel a bunnyghc joke coming up...
16:02:08 * hackagebot diagrams-contrib 0.1.1.0 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-0.1.1.0 (BrentYorgey)
16:02:10 * hackagebot freesect 0.7 - A Haskell syntax extension for generalised sections  http://hackage.haskell.org/package/freesect-0.7 (AndrewSeniuk)
16:05:10 <YellowOnion> exFalso1: that should make it easier :-)
16:08:01 <YellowOnion> excellent someone coughed in the background of this recording :D
16:18:21 <_Mikey> Hi guys
16:18:49 <_Mikey> I'm having a really hard time debugging problem in my Haskell code
16:19:14 <_Mikey> it just hangs
16:19:17 <_Mikey> no errors :(
16:19:59 <_Mikey> testing individual parts everything performs as expected
16:20:02 <_Mikey> but as a whole ;/
16:21:08 <otters> sounds like it's trying to evaluate an infinite list or something
16:21:41 <_Mikey> hmm I'll take a look out for something like that
16:22:22 <_Mikey> the function I call is recursive maybe its not hitting the terminating condition
16:22:28 <otters> ja
16:22:30 <otters> there's an idea
16:23:12 <monochrom> then you have not truly tested all individual parts
16:24:11 <_Mikey> monochrom, I have tried believe me
16:24:25 <_Mikey> been smashing it non stop since I was last on hear.
16:24:28 <_Mikey> here*
16:25:48 <monochrom> I don't know what your program looks like, but if a program looks like "(if b then p else q) + (x * y)", I wouldn't call just testing b, p, q, x, y "testing individual parts". there are 2 more parts to test, "if b then p else q" and "x * y"
16:26:13 <monochrom> like someone shows you a grid of squares and asks "how many squares are there"
16:26:30 <monochrom> if it's a 3x4 grid you don't say "12 squares". there are a lot more.
16:26:51 <_Mikey> ohhh
16:27:04 <_Mikey> I'm using if then
16:27:11 <_Mikey> I'll take a look. thanks!
16:38:48 <hpaste> d-snp pasted ‚ÄúCondition‚Äù at http://hpaste.org/65426
16:38:59 <d-snp> hey guys, what's a smart way of doing this?
16:39:02 <d-snp> in haskell? :P
16:40:17 <ClaudiusMaximus> d-snp: let ... = if ... then ... else ...
16:40:46 <d-snp> oh right :D
16:48:27 <t7> a hoogle that walks through expressions trying to find the target type would be awesome
16:48:39 <t7> like im trying to find IO LocalDay
16:48:57 <t7> IO Day even
16:49:34 <hpc> @let hoogle _ = text "fix id"
16:49:35 <lambdabot>  Defined.
16:49:53 <mauke> > hoogle undefined
16:49:55 <lambdabot>   fix id
16:50:01 <hpc> > hoogle "String -> IO (Integer -> (Mu IO, [Int]))"
16:50:03 <lambdabot>   fix id
16:50:11 <hpc> :P
16:50:36 <hpc> man, i would hate to manipulate a value of type Mu IO
16:51:16 <dmwit> d-snp: Depending on what you know about chunks, you might want to do something like "process . dropWhile isCookieChunk . chunks $ message".
16:51:37 <dmwit> ?src Mu
16:51:37 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:51:57 <dmwit> I don't think there are any meaningful values of type Mu IO.
16:52:28 <dmwit> :t In . return
16:52:29 <lambdabot> forall (f :: * -> *). (Monad f) => Mu f -> Mu f
16:52:41 <dmwit> :t fix (In . return)
16:52:42 <lambdabot> forall (f :: * -> *). (Monad f) => Mu f
16:52:50 <hpc> dmwit: it's a representation of non-terminating programs
16:53:09 <hpc> any loop of IO that never exits would fit the type
16:53:42 <dmwit> I take it back. It seems plausible that there are many meaningful values of type Mu IO.
16:53:47 <dmwit> For example,
16:53:51 <hpc> dmwit: s/return/any kleisli arrow/
16:53:55 <hpc> in that fix expression
16:54:03 <hpc> and you have yourself a cool object
16:54:03 <dmwit> In (doSomethingMeaningufl >> return somethingNonMeaningful)
16:54:36 <hpc> dmwit: you also have actions like
16:54:53 <hpc> do {something meaningful; return (In theNextStep)}
16:56:09 <gnoi> How can I count number of occurence some substring in string using parseq?
16:56:12 <hpc> :t fix (\now -> do {next <- now; out next})
16:56:13 <lambdabot> forall (m :: * -> *). (Monad m) => m (Mu m)
16:56:20 <gnoi> l ‚Üê string "ab" `sepBy` ...
16:56:23 <dmwit> hpc: Seems kind of pointless when you could just as well write do {something meaningful; theNextStep; return somethingNonMeaningful}
16:56:28 <gnoi> What should I use for separator?
16:56:55 <hpc> dmwit: actually, ive found out the hard way that that can stack overflow
16:57:06 <hpc> from all the trailing returns piling up
16:57:45 <dmwit> :t parseq
16:57:46 <lambdabot> Not in scope: `parseq'
16:58:01 <dmwit> gnoi: :t parseq
16:58:39 <gnoi> dmwit: ?
16:58:52 <dmwit> gnoi: What is the type of parseq?
16:59:02 <hpc> :t let runMu (In now) = do {next <- now; runMu now} in runMu
16:59:03 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
16:59:03 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `t :: * -> *'
16:59:04 <lambdabot>       Expected type: t (Mu t) -> t b
16:59:24 <hpc> @hoogle Mu f -> f ()
16:59:25 <lambdabot> Warning: Unknown type Mu
16:59:25 <lambdabot> GHC.Conc.Sync writeTVar :: TVar a -> a -> STM ()
16:59:25 <lambdabot> GHC.Conc writeTVar :: TVar a -> a -> STM ()
16:59:30 <hpc> poo
17:00:46 <dmwit> :t let runMu :: Monad m => Mu m -> m (); runMu mu = out mu >>= runMu in runMu
17:00:47 <lambdabot> forall (m :: * -> *). (Monad m) => Mu m -> m ()
17:00:57 <dmwit> Weird, how come yours didn't type-check?
17:01:04 <dmwit> :t let runMu mu = out mu >>= runMu in runMu
17:01:05 <lambdabot> forall (m :: * -> *) b. (Monad m) => Mu m -> m b
17:01:19 <dmwit> oh
17:01:24 <dmwit> hpc: runMu next, not runMu now
17:01:38 <hpc> oh der
17:01:47 <hpc> :t let runMu (In now) = do {next <- now; runMu next} in runMu
17:01:48 <lambdabot> forall (t :: * -> *) b. (Monad t) => Mu t -> t b
17:01:54 <dmwit> \o/
17:02:09 <dmwit> :t fix (out >=>)
17:02:10 <lambdabot> forall (m :: * -> *) c. (Monad m) => Mu m -> m c
17:02:17 <hpc> anyhoo, runMu infiniteLoop :: forall a. IO a
17:02:35 <hpc> which is a nice type-level indication of "you're never getting anything from this"
17:02:48 <hpc> dmwit: oh, that too
17:02:53 <dmwit> You don't need Mu to write infiniteLoop :: forall a. IO a
17:03:36 <hpaste> d-snp pasted ‚ÄúsocketAcceptMessage‚Äù at http://hpaste.org/65427
17:03:40 <dmwit> Hell, there's even an infinite loop in the standard library that uses that type-encoding trick.
17:03:43 <dmwit> :t forever
17:03:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:03:48 <d-snp> finally got my method down
17:03:50 <hpc> yeah, but it's neat
17:03:51 <hpc> :P
17:04:00 <d-snp> do you guys have any recommendations for cleaning it up?
17:04:14 <d-snp> not sure if it compiles yet
17:04:29 <hpc> dmwit: also, (forever whatever) will match types like (IO Int)
17:04:36 <hpc> whereas Mu IO will not
17:04:48 <dmwit> d-snp: I have a suggestion. Your "Message" type sucks.
17:05:30 <dmwit> With a well-designed Message type, I would expect all these terrible nested if-then-else clauses to be a single pattern match.
17:05:40 <hpc> that won't even compile
17:05:43 <dmwit> hpc: I don't understand that.
17:05:53 <hpc> you're using do-style let-ins inside nested if blocks
17:06:05 <hpc> :t forever
17:06:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:06:12 <hpc> :t forever (return 5)
17:06:13 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
17:06:24 <hpc> :t forever (return 5) `asTypeOf` (return 5)
17:06:25 <lambdabot> forall (m :: * -> *) b. (Monad m, Num b) => m b
17:06:30 <hpc> :t forever (return 5) `asTypeOf` (return False)
17:06:31 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool
17:07:08 <dmwit> :t fix (out >=>) `asTypeOf` return False
17:07:09 <lambdabot>     Couldn't match expected type `m c' against inferred type `Bool'
17:07:09 <lambdabot>       Expected type: Mu m -> m c
17:07:09 <lambdabot>       Inferred type: Mu m -> Bool
17:07:34 <hpc> if you say a function wants a Mu m, you know the action won't ever finish
17:07:35 <dmwit> :t fix (out >=>) :: Mu IO -> IO Bool
17:07:36 <lambdabot> Mu IO -> IO Bool
17:07:50 <dmwit> hpc: The "runMu" thing has that same property.
17:07:59 <dmwit> So I don't understand what you're trying to say.
17:08:06 <d-snp> hmm
17:08:19 <dmwit> Anything with type forall a. IO a will not finish (properly), regardless of whether it was built with a Mu or not.
17:08:53 <hpc> dmwit: but you can use forall a. IO a in places that terminating computations can go
17:08:53 <dmwit> d-snp: For example, perhaps you'd like to write something like
17:09:07 <hpc> but you can't use a Mu IO in those same places without the noise of running it first
17:09:09 <dmwit> hpc: You can use Mu in places that a terminating computation can go, too.
17:09:22 <dmwit> hpc: You can't use Mu IO in *any* place without the noise of running it.
17:09:24 <dmwit> What's your point?
17:09:35 * cmccann wonders if "IO Void" might make more sense for a non-returning computation
17:09:49 <dmwit> d-snp: data Message = Message { header :: String, cookie :: String, payload :: [String] } -- or something like that
17:10:01 <hpc> in any event, my point is that "Mu IO" isn't usesless
17:10:05 <hpc> *useless
17:10:13 <dmwit> hpc: I don't (yet) agree with that point. =)
17:11:30 <dmwit> data Message = Message { checkSum :: Int, tag :: String, cookie :: Maybe String, payload :: [String] } -- I don't know, but you should ;-)
17:11:58 <cmccann> hpc, incidentally, something of type "Mu IO" can be run incrementally one layer at a time, that's potentially useful
17:12:16 <hpc> ah yeah, was thinking of how to word that
17:12:19 <dmwit> Yes, I could see Mu IO being used as a "checkpointing IO", sort of.
17:12:24 <hpc> it looks rather continuationy to me
17:12:33 <dmwit> Using it to guarantee nontermination doesn't convince me, though.
17:14:08 <cmccann> it's closer to guaranteeing the opposite if anything, if each step terminates you can keep running terminating steps indefinitely
17:14:41 <cmccann> it's sort of like a degenerate stream, with only nested effects rather than values
17:15:13 <hpaste> d-snp annotated ‚ÄúsocketAcceptMessage‚Äù with ‚ÄúsocketAcceptMessage (annotation)‚Äù at http://hpaste.org/65427#a65429
17:16:10 * cmccann has been playing around with representing streams as fixed points of functors for the last month or so, incidentally
17:17:17 <hpc> cmccann: you can refactor a lot of stream types into fixed points
17:17:22 <hpc> well, all of them
17:17:27 <cmccann> yes
17:17:27 <hpc> but that's beside the point :P
17:18:07 <hpc> i would like to play around with Mu in agda, actually
17:18:22 <d-snp> dmwit: there's a bunch of different message types
17:18:25 <hpc> i might need to learn the flat/sharp stuff though
17:18:31 <d-snp> the only thing they share is a common header
17:18:36 <cmccann> the fun part is that you can then express a lot of stream operations in terms of operations on functors
17:18:36 <d-snp> which has the tag field
17:23:56 <Makoryu> @pl f 1_1
17:23:56 <lambdabot> (line 1, column 4):
17:23:56 <lambdabot> unexpected "_"
17:23:56 <lambdabot> expecting variable, "(", operator or end of input
17:24:19 <dmwit> d-snp: At the very least, the cookies and the chunks should not be stored in the same list, since you never use them together.
17:25:16 <dmwit> d-snp: As for this tag :: Int, are you sure you wouldn't be better off with a real sum type?
17:25:48 <dmwit> sorry, tag :: VerificationTag or whatever
17:25:58 <d-snp> real sum type?
17:26:15 <dmwit> Yes.
17:26:24 <dmwit> moment
17:27:32 <d-snp> well this is how the protocol works, you get different kinds of messages, all for different cases
17:28:00 <d-snp> but the init and cookie/cookie ack messages are exceptions in the case that they can be sent/received before an association exists
17:28:59 <dmwit> data Chunk = Cookie { value :: BL.ByteString } | Payload { checksum :: Int, BL.ByteString } | SomeOtherChunkType { someCompletelyDifferentField :: SomeTypeThatNeedsToBeParsedFromAByteString }
17:29:03 <dmwit> for example
17:29:18 <dmwit> Though if cookies are a special case (as they seem to be here), I again would put them in the Message type and not in the Chunk type.
17:29:43 <dmwit> All I'm saying is: your datatypes look a bit too low-level. They're implemented at the protocol's convenience level, not at the programmer convenience level.
17:31:31 <d-snp> hmm
17:31:36 <d-snp> that's a valid point
17:31:38 <dmwit> Again, all these nested if-then-elses should be doable as a single, top-level pattern match if you design the type right.
17:31:39 <jfischoff> why does djinn not allow recursive types?
17:31:48 <dmwit> (With the possible exception of verifying the checksum.)
17:31:59 <cmccann> jfischoff, because it doesn't allow general recursion probably
17:32:41 <cmccann> and allowing only finite values with recursive types would be tricky I imagine
17:33:31 <dolio> Djinn decides propositional logic.
17:33:49 <dolio> Recursive types don't correspond to propositional constructs.
17:34:27 <jfischoff> is any type of recursion possible in propositional logic?
17:34:43 <jfischoff> or is there no recursion at all?
17:34:50 <dmwit> Recursion and decidability don't mix well.
17:35:08 <dolio> Propositional logic has true, false, and, or and implication.
17:35:10 <jfischoff> sure, Agda still has recursion
17:35:36 <dolio> So you get those.
17:35:46 <dmwit> Yes, and getting its termination checker to pass more code is an area of active research.
17:35:53 <dmwit> I wouldn't exactly consider that "mixing well".
17:36:09 <jfischoff> dmwit: true, but they do mix
17:36:25 <roconnor> dolio: I'd argue taht propositional logic doesn't have or :)
17:36:35 <dmwit> ...and that's when you're handed the proofs. Djinn isn't handed the proofs, it's *finding* them. =P
17:36:59 <cmccann> note that djinn is actually a pretty simple program
17:37:01 <Saizan> roconnor: this is intuitionistic prop. logic
17:37:23 <gnoi>   l ‚Üê string "abc" `sepBy` optional anyChar . How can I define Parser value on the right side of the sepBy as a string that matches any string even empty?
17:37:42 <roconnor> Saizan: I admit it is traditional to have or in int. prop. logic, but I'd argue that or is really a honest to goodness data-type.
17:38:35 <dmwit> gnoi: many anyChar, perhaps?
17:39:37 <dmwit> OOOOH, "parseq" was a typo for "Parsec". I totally get it now.
17:39:40 * dmwit facepalms
17:39:47 <Saizan> i don't think sepBy would like that much
17:40:01 <gnoi> dmwit: it's not work
17:40:07 <gnoi> occP = do l ‚Üê string "abc" `sepBy` many anyChar return $ length l
17:40:10 <dmwit> Probably not. It's probably better to use "abc" as the separator.
17:40:16 <gnoi> > countP "abc abc"
17:40:16 <gnoi> 0
17:40:17 <lambdabot>   Not in scope: `countP'
17:40:35 <dolio> roconnor: Does that go for exists, as well?
17:40:37 <Saizan> maybe you want to use ReadP
17:40:40 <dolio> For the first order case?
17:40:47 <gnoi> > parse occP "" "abc abc"
17:40:47 <gnoi> Left (line 1, column 8):
17:40:47 <gnoi> unexpected end of input
17:40:47 <gnoi> expecting "abc"
17:40:48 <lambdabot>   Not in scope: `parse'Not in scope: `occP'
17:40:52 <jfischoff> how does the propositional logic of djinn relate to the lambda cube?
17:40:55 <roconnor> dolio: yes
17:41:59 <gnoi> dmwit: but if "abc" is a separator, what is a right side value?
17:42:08 <gnoi> left side*
17:42:26 <gnoi> sepBy p sep parses zero or more occurrences of p, separated by sep
17:42:52 <gnoi> Why should I use "abc" as a separator? It makes no sense
17:43:00 <roconnor> dolio: this is what Epigram 2 does IIUC
17:43:36 <ion> I‚Äôm quite sure someone said GHCi 7.6 will let you run lines like ‚Äúa = 42‚Äù without ‚Äúlet‚Äù. A nightly snapshot of GHC doesn‚Äôt seem to work like that. I have trouble finding anything about it on Google. Anyone know anything about that?
17:43:44 <d-snp> dmwit: thanks for your advice, I'm thinking hard about what my types should look like
17:44:12 <d-snp> I'm not good at all with haskell types yet, and I was glad enough I got everything parsing correctly into haskell types
17:46:17 <hpc> ion: sounds like a pretty major change
17:46:39 <hpc> im gonna go with "i hope it doesn't happen"
17:46:59 <hpc> just to cut back on the list of exceptions in the "ghci is a giant do-block" explanation
17:47:24 <t7> @pl f x = u x >>= g
17:47:24 <lambdabot> f = (g =<<) . u
17:49:30 <gnoi> dmwit: how can I use "abc" as the separator? And what is the occurences p value then?
17:51:58 <roconnor> Did you mean the orange-red V-9247-KRE, the celadon V-9247-KRE, the green-yellow V-9247-KRE or the pale-brown V-9247-KRE?
17:52:02 <roconnor> oops wrong chan
17:52:32 <dolio> roconnor: Oh, that's what you mean.
17:56:31 <downloader> I have some bittorrent encoded data that is malformed. I would like to determine in where and why it is malformed. Is there an easy way to do that with the bencode library or otherwise?
17:56:48 <downloader> http://hackage.haskell.org/packages/archive/bencode/
18:02:18 <Ke> is there some lib to get sum of filesizes in a path
18:02:37 <JoeyA> downloader: import Data.BEncode \n import qualified Data.ByteString as B \n main = B.getContents >>= print . bRead   (replace \n with newline)
18:02:58 <JoeyA> Ke: Recursively?
18:04:45 <hpc> Ke: might be in some library that's a collection of handy functions
18:04:54 <hpc> i can think of a version that works in 4 lines
18:05:20 <Ke> in perl everything is a oneliner
18:05:23 <Ke> but yes
18:05:49 <hpc> Ke: in perl it's actually two lines
18:06:06 <hpc> one for the accumulator and another to call File::find with a closure over it
18:08:29 <dpratt71> Are delimited continuations hard to understand? Or is this more evidence that I'm not very bright?
18:09:28 <dmwit> gnoi: I'm not sure.
18:09:35 <dmwit> I've never tried to parse a regular language with Parsec before.
18:09:49 <hpc> dpratt71: it's tricky; there's some bad explanations out there, but not to the extent that Monad has
18:10:02 <hpc> http://hpc.dyndns-web.com:8000/blog/view.cgi?id=11 -- i like to think this is a good explanation
18:10:09 <hpc> at least, for a very specialized use of ContT
18:10:34 <dpratt71> hpc: I've been reading this: http://www.haskell.org/haskellwiki/Library/CC-delcont
18:10:55 <dpratt71> hpc: thanks for the link, I'll check it out
18:11:05 <hpc> delimited continuations are a bit fancier
18:11:28 <dmwit> gnoi: Perhaps you could try something like this:
18:11:54 <dpratt71> yeah, 'regular' continuations are not *so* bad
18:11:55 <dmwit> parseSingle = try (string "abc") <|> anyChar >> parseSingle
18:12:11 <dmwit> parseMany = many parseSingle
18:12:50 <gnoi> And how can I use it to get smth like : f "abc" "abcabc" == 2
18:12:52 <gnoi> ?
18:13:05 <gnoi> Or f "abcabc" == 2
18:13:13 <dmwit> gnoi: If that's your end goal, Parsec is not the right tool.
18:13:22 <gnoi> I know
18:13:31 <gnoi> Just interesting
18:13:44 <dmwit> Anyway, parseMany would give you a list as its parse result.
18:13:47 <dmwit> So just call "length".
18:14:12 <t7> oh wow hdbc checks for injection allready :D
18:14:48 <gnoi> cannot mix `<|>' [infixr 1] and `>>' [infixl 1] in the same infix expression
18:15:05 <dmwit> So put some parens.
18:15:36 <shachaf> 4
18:15:58 <gnoi> dmwit: but where?
18:16:39 <dmwit> moment
18:16:50 <zachk> (like <|> this) >> maybe
18:17:00 <dmwit> no, the other way
18:17:06 <gnoi> Type check failed
18:17:10 <dmwit> try (string "abc") <|> (anyChar >> parseSingle)
18:17:24 <anariyan> hhhhhh
18:19:23 <dmwit> Okay, this way is better.
18:19:35 <JoeyA> I think I had a lightbulb moment regarding delimited continuations.  With ordinary continuations, callCC gives you "the rest of the program".  This means I can do crazy things like run the rest of the program twice, or run it with uninterruptibleMask_, etc..  With delimited continuations, the continuation can be limited to a scope.
18:19:39 <JoeyA> Is that correct?
18:20:13 <gnoi> dmwit: still failed on "abcd" strings
18:21:17 <hpaste> dmwit pasted ‚ÄúcountOccurrences‚Äù at http://hpaste.org/65431
18:21:21 <dmwit> gnoi: ^^
18:21:36 <gnoi> oh
18:21:43 <HugoDaniel> how can i write this in a better way ? composeTuples (j, r) (j', r') = (j ++ j', r ++ r')
18:21:51 <JoeyA> Err, wait.  If you call a continuation (at least with ContT), that short circuits the rest of the flow, so a continuation can't be called twice to call the program twice.
18:22:15 <dmwit> HugoDaniel: composeTuples = mappend
18:22:31 <dmwit> > mappend ("abc", [1, 2, 3]) ("def", [4, 5, 6])
18:22:32 <lambdabot>   ("abcdef",[1,2,3,4,5,6])
18:22:42 <JoeyA> Ah, there's an instance (Monoid a, Monoid b) => Monoid (a, b) .  Good to know.
18:22:57 <HugoDaniel> :D
18:23:00 <HugoDaniel> great
18:23:28 <dmwit> ?hoogle [Either a b] -> ([a], [b])
18:23:29 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
18:23:37 <dmwit> :t length . fst . partitionEithers
18:23:38 <lambdabot> forall a b. [Either a b] -> Int
18:23:47 <dmwit> gnoi: ^^, too
18:31:46 <byorgey> JoeyA: re: delimited continuations, yes
18:36:04 <hpc> you could probably write "twice" by pattern-matching on ContT
18:36:24 <hpc> i think
18:37:09 <[weev]> hello
18:37:16 <JoeyA> So I suppose ContT is, in a sense, delimited by nature (where runContT delimits the continuation).  However, having multiple reset points requires stacking ContT over and over.
18:37:57 <[weev]> ok guys so here is my problem i was using rails/ruby for my high frequency trading system before but it was way too slow so i moved to haskell
18:38:04 <[weev]> do u guys have any ideas how to get the milliseconds down
18:38:27 <[weev]> my boss is about to fire me and said i should just use c but i heard haskell is faster than ruby and everyone likes ruby more than C
18:38:35 <Makoryu> Try achieving satori
18:38:36 <[weev]> does haskell have something like rails tho
18:38:39 <Makoryu> And read SICP
18:38:49 <[weev]> yeah my shit is like in an infinite recrusion
18:38:49 <[weev]> i
18:38:54 <Ke> hpc: having premade implementation might help you to overcome all the cornercases like broken symlinks
18:39:01 <[weev]> heard i want to use non blocking io
18:39:12 <[weev]> does haskell work on node.js
18:39:16 <Makoryu> Non blocking IO is enterprise web scale
18:39:18 <[weev]> i saw a talk on it at sxsw
18:39:27 <[weev]> the presenter had a cool beard
18:39:35 <[weev]> and later offered me a key bump in the bathroom
18:40:18 <JoeyA> [weev]: What operating system is your Haskell program running on?
18:40:30 <[weev]> gen2
18:40:40 <[weev]> so anyway
18:40:40 <JoeyA> Gentoo?
18:40:48 <[weev]> gen2 too
18:41:13 <JoeyA> I ask because GHC doesn't do IO very well on Windows.
18:41:26 <[weev]> ok well i told u
18:41:27 <[weev]> gen2
18:41:46 <JoeyA> I don't know what that is
18:41:50 <Makoryu> Yo he's a troll having some laughs it's not a serious question
18:41:59 <JoeyA> Good call.
18:42:28 <[weev]> it's just gentoo 2.0
18:42:31 <[weev]> i call it gen2
18:42:35 <[weev]> cause that's how we write it on twitter
18:42:44 <[weev]> anyway i think I'm in over my head like can u tell me what is a monad???
18:42:47 <sm> rails/ruby .. high frequency trading system <- joking around
18:42:51 <[weev]> i talk about it in meetings and people think I'm saying obscene
18:42:54 <[weev]> what dude i work for getco
18:42:59 <[weev]> we are fast but this is a new desk
18:43:01 <[weev]> for web trading
18:43:05 <[weev]> web 2.0
18:43:10 <[weev]> but also has to be high speed
18:43:30 <[weev]> it is the new economy of favs, followers and likes
18:43:32 <[weev]> this is web 2.0
18:43:40 <JoeyA> [weev]: I don't know how complex your program is, but you'll probably deliver faster if you do it in C (provided you know some C already).
18:43:47 <[weev]> so i need to know like is there any way u can help me increase my klout score like
18:43:52 <[weev]> with server side scripting
18:43:58 <HugoDaniel> what is swsx ?
18:44:02 <[weev]> i need to trade in the new economy of ad impressions and twitter "likes"
18:44:05 <[weev]> and Facebook retweets
18:44:06 <Makoryu> HugoDaniel: An anime convention
18:44:18 <[weev]> so like buy ads for less than i sell them for
18:44:30 <HugoDaniel> ok
18:44:33 <[weev]> so i don't have to be that fast but haskell takes like 30 seconds to parse one json query
18:44:36 <dmwit> ?where ops
18:44:37 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
18:44:46 <[weev]> maybe i am doing it wrong
18:44:46 <hpc> dmwit: nah, this is kind of hilarious
18:44:50 <[weev]> does haskell have non blocking io
18:44:58 --- mode: ChanServ set +o monochrom
18:44:58 <[weev]> and is it nosql also i heard that will help my speed
18:45:02 <HugoDaniel> [weev]: are you talking serious or do you wanna get blocked ?
18:45:07 <JoeyA> Yes
18:45:12 <[weev]> its a serious idea but if you don't like that one ill tell u another
18:45:26 <[weev]> its called "weeder" a platform for "text messages" where they are 420 characters EXACTLY
18:45:43 <[weev]> thats my side project for github
18:45:43 <HugoDaniel> please stay on topic
18:45:47 <[weev]> can i do that in haskell?
18:45:52 <[weev]> like are there web 2.0 frameworks?
18:45:58 <HugoDaniel> yes
18:45:59 <[weev]> i was on ruby before but like i said so slow
18:46:00 <Makoryu> [weev]: Yes! Haskell can do that!
18:46:02 <[weev]> ok tell me one then
18:46:06 <[weev]> haskell on hogs
18:46:09 <HugoDaniel> happstack, snap framework and yesod are the major ones
18:46:12 <[weev]> sounds like it would be slow and porcine
18:46:15 <JoeyA> > isTroll "[weev]"
18:46:15 <Makoryu> [weev]: Haskell is fully enterprise compliant and 110% web scale
18:46:17 <lambdabot>   True
18:46:30 <monochrom> just tell me what to do or not do
18:46:33 <[weev]> whoa "snap" framework sounds like it could be fast
18:46:36 <[weev]> yeah there is no try brah
18:46:44 <[weev]> I'm a tri state boolean
18:46:47 <[weev]> yes/no/try
18:46:52 <[weev]> Maybe True
18:47:07 <mauke> data Boolean = True | False | FileNotFound  -- FTFY
18:47:09 <dmwit> monochrom: On the one hand, I don't have anything else to discuss right now anyway...
18:47:17 <Makoryu> [weev]: It is called Snap because you just snap your fingers and the application writes itself. Even less work than Rails!
18:47:20 <[weev]> thx
18:47:21 <hpc> yeah, this was funnier when it was "rails HFT"
18:47:25 <[weev]> is there a screencast?
18:47:37 <mauke> sorry, no casts in haskell
18:47:38 <[weev]> well i need to read nasdaq itch data and build an order book
18:47:44 <[weev]> cause i use that to price my online ads
18:47:47 <[weev]> its a spread trade
18:47:55 <monochrom> I had a millisecond-trading system in GW-BASIC
18:48:08 <hpc> monochrom: pppsh, mine was TI-BASIC
18:48:13 <hpc> > "TI" > "GW"
18:48:14 <lambdabot>   True
18:48:23 <hpc> my logic is undeniable
18:48:27 <monochrom> but yeah I had to run it on the newest 3GHz CPU
18:48:45 <cmccann> monochrom, "do or not do" sounds suspiciously classical. how do you expect us to prove that constructively? :[
18:48:56 <[weev]> are there any girls here???
18:48:57 <hpc> > do or not do
18:48:58 <lambdabot>   <no location info>: parse error on input `do'
18:49:14 <mauke> @vixen
18:49:14 <lambdabot> Certainly in the next 50 years we shall see a woman president, perhaps sooner than you think. A woman can and should be able to do any political job that a man can do.
18:49:25 <monochrom> I believe in classical logic, actually
18:49:42 <Rotaerk> I didn't realize lambdabot made jokes
18:49:44 <[weev]> i believe in classical conditioning
18:49:52 <hpc> mauke: we are bumping up against that deadline, actually
18:51:27 <td123> [weev]: I see getting kicked for trolling in #ror was not enough :P
18:51:51 <[weev]> fool me once shame on me fool me twice and well thats pretty tuff
18:51:56 <[weev]> so i think those guys want me in their chat
18:51:59 <[weev]> but they just don't know it
18:52:07 <HugoDaniel> [weev]: be constructive :/
18:52:09 <[weev]> ok
18:52:19 <HugoDaniel> or better, be functional
18:52:25 <[weev]> well can i build my web app to find online influencers and buy their purchasing power for less than its worth in haskell
18:52:27 <[weev]> or is that rails only
18:52:30 <[weev]> like klout
18:52:45 <[weev]> ideally i would just give them badges or online trinkets that are worthless
18:52:56 <[weev]> any biz dev guys here to vet this idea cause at face value it sounds like a best practice
18:52:59 <[weev]> but circle back
18:53:00 <mog_> hi there, I got a problem understanding basic typing stuff in haskell. Is that an appropriate place to ask for help ?
18:53:00 <[weev]> thx
18:53:03 <hpc> HugoDaniel: nah, the superior alternative to constructive logic is intuitionist logic
18:53:10 <HugoDaniel> :)
18:53:16 <dmwit> mog_: Yup!
18:53:19 <hpc> (although they might actually be the same; i suck at that kind of math)
18:53:21 <HugoDaniel> intuitionism
18:53:45 <dmwit> Perhaps you meant "intuitionistic logic".
18:54:01 <cmccann> I don't think "constructive" is any specific kind of logic or such
18:54:06 <HugoDaniel> is there a better nub for lists of strings ? or the one on Data.List is the only one ?
18:54:09 <HugoDaniel> better as in faster
18:54:14 <hpc> mog_: perhaps you want to know where this place is? :P
18:54:17 <dmwit> HugoDaniel: Set.toList . Set.fromList
18:54:30 <HugoDaniel> :D
18:54:31 <HugoDaniel> amazing!
18:54:40 <HugoDaniel> man, thats just so simple!
18:54:48 <dmwit> HugoDaniel: A Trie-based one would probably be even faster for Strings.
18:54:49 <hpaste> i annotated ‚ÄúcountOccurrences‚Äù with ‚ÄúcountOccurrences (annotation)‚Äù at http://hpaste.org/65431#a65433
18:54:54 <gnoi> dmwit: how can I use arrow to avoid that case?
18:55:10 <HugoDaniel> oh yes, thats it, tries yes
18:55:16 <cmccann> also, wanting to use "nub" on a list is sometimes a sign that you should be using Data.Set in the first place
18:55:18 <dmwit> :t either -- gnoi
18:55:18 <HugoDaniel> well, the trie construction might kill it
18:55:19 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:55:40 <dmwit> :t either (const 0) (length . snd . partitionEithers)
18:55:41 <lambdabot> forall a a1 b. Either a [Either a1 b] -> Int
18:55:49 <aristid> cmccann: constructive logic and intuitionistic logic seem to be synonyms, so obviously constructive logic refers to a special kind of logic
18:56:25 <saml> hey, who maintains haskell package on archlinux? things are completely broken
18:56:38 <gnoi> dmwit: so, it will pe `parse ... >=>  either (const 0) (length . snd . partitionEithers)` ?
18:56:42 <hpc> cmccann: sometimes you only want set-like behavior in one part
18:57:08 <[weev]> dam this shit looooook complicated
18:57:46 <dmwit> gnoi: what
18:57:57 <dmwit> gnoi: It's just function application, why are you using (>=>)?
18:58:14 <gnoi> I wanna some flip <$>
18:58:21 <dmwit> why?
18:58:26 <mog_> blah nvm, just when I finished my pastebin, I checked with some added parenthesis and all went fine
18:58:32 <gnoi> either (const 0) (length ‚àò snd ‚àò partitionEithers) $ parse (parseMany substr) "" str
18:58:37 <dmwit> yes
18:58:40 <gnoi> It looks ugly
18:58:53 <dmwit> Make it prettier by naming some subexpressions.
18:58:56 <[weev]> so what is up
18:58:58 <hpc> mog_: we make good rubber ducks
18:59:04 <gnoi> dmwit: okay, thanks
18:59:08 <dmwit> Perhaps name the "either (...) (...)" thing or so.
18:59:13 <hpc> (https://duckduckgo.com/?q=rubber+duck+debugging)
19:04:08 <HugoDaniel> how can i say that my Int type is only made of prime numbers ?
19:04:28 <dmwit> Use Agda.
19:04:29 <HugoDaniel> is there any way that i can constrain a data type in its definition ?
19:04:34 <HugoDaniel> oh ok
19:04:38 <mauke> easy, treat every Int as an index into the list of primes
19:04:50 <HugoDaniel> oh
19:05:04 <HugoDaniel> but how do i make sure the compiler can guarantee me
19:05:13 <HugoDaniel> prime numbers on a given function
19:05:27 <mauke> every number is prime
19:05:39 <cmccann> HugoDaniel, no, use arbitrary Ints such that if the value is N, that means the Nth prime
19:05:50 <bd_> HugoDaniel: Create a newtype Prime = P Int. Don't export the constructor. Now make sure any functions that construct P in your module check your constraint
19:05:59 <cmccann> then you only have to enforce that it's non-negative :P
19:05:59 <dmwit> All you people saying Int probably mean Word. ;-)
19:06:01 <bd_> any code outside of that module cannot violate the constraint in question
19:06:12 <bd_> okay, P Word then :)
19:06:14 <bd_> or P Integer
19:06:21 <dmwit> Yes, practically speaking, bd_ has given the current best practice.
19:06:28 <dmwit> It's not a compiler check, but it's Pretty Darn Good.
19:06:53 <bd_> dmwit: any time you have a convertArbitraryValueToPrimeType :: Word -> Prime, you need a runtime check :)
19:07:01 <HugoDaniel> :D
19:07:08 <bd_> (ideally, Monad m => Word -> m Prime I guess)
19:08:24 <cmccann> bd_'s suggestion is basically a compiler check to ensure you do the necessary runtime check
19:08:44 <cmccann> which can get you pretty far in many cases
19:09:27 <bd_> The problem with pure compiler checks is when you have a conversion from an unconstrained type to a constrained type, you find that you suddenly need a runtime check and all that compiler check madness was pointless :)
19:09:34 <cmccann> at least with prime numbers you don't need to worry about stuff like arithmetic because those will never work
19:10:15 <bd_> I mean, sure, you could define data Z; data S n; and a bunch of incoherent instances and other madness that would make oleg proud to prove at compile time that your numbers can never be non-prime
19:10:20 <bd_> or you can do an easy runtime check :)
19:10:29 <cmccann> unlike say "nonzero numbers" where addition causes headaches
19:11:16 <bd_> cmccann: well, that just means there is no addition operator, as addition is normally defined
19:11:48 <bd_> since it's no longer an abelian group
19:12:52 <cmccann> yes, but addition is something you're likely to want to do anyway and there will often be cases where you know (but can't easily encode with types) that your results will be nonzero still
19:13:33 <cmccann> whereas adding two prime numbers is very rarely going to give you another prime
19:14:22 <mauke> often enough
19:14:55 <siracusa> infinitely often?
19:15:09 <dmwit> That's a conjecture. =)
19:15:12 <cmccann> heh
19:15:24 <dmwit> (Or has that one been (dis)proven by now?)
19:15:32 <siracusa> that's not rarely then :-P
19:16:05 <elliott> dmwit: nope
19:16:33 <c_wraith> twin primes still aren't known to be infinite or not? boo.
19:17:40 <[weev]> one laptop per child molester
19:19:18 <dmwit> You really are a colorful one.
19:19:42 <[weev]> lol
19:19:46 <[weev]> fuck u nigga
19:19:47 <elliott> does this have something to do with haskell?
19:19:55 <elliott> @where ops
19:19:55 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
19:19:57 <cmccann> no, just another troll
19:20:02 --- mode: ChanServ set +o mauke
19:20:02 --- mode: mauke set +q *!*@96.25.129.108
19:20:23 <mauke> noise reduction activated
19:20:24 <HugoDaniel> eh
19:20:28 <HugoDaniel> just plain offensive
19:20:34 <HugoDaniel> he didn't even try to be funny :/
19:20:45 <cmccann> it was mildly amusing earlier
19:21:01 <elliott> don't give feedback
19:21:14 <elliott> they might take it :
19:21:16 <elliott> *:p
19:21:42 <c_wraith> If feedback results in trolls that are actually entertaining, what's wrong with that?
19:22:02 --- mode: mauke set -o mauke
19:22:05 <cmccann> this one didn't seem smart enough to actually troll effectively anyhow
19:22:17 <c_wraith> sadly common
19:22:22 * hackagebot majordomo 0.1 - Majordomo protocol for ZeroMQ  http://hackage.haskell.org/package/majordomo-0.1 (MarkWotton)
19:22:24 <elliott> #haskell's signal-noise ratio will suffer for trolls no matter how funny thewy are
19:22:27 <cmccann> yeah the quality of trolls has really gone down these days
19:23:09 <cmccann> like that joker I banned on reddit, that was just sad
19:23:43 <elliott> the stability one?
19:23:49 <cmccann> yes
19:24:06 <elliott> at least they put chart-making effort in
19:24:32 <cmccann> well yeah, ok, I'll give it a C for effort
19:24:39 <cmccann> but otherwise it was pretty lame
19:24:56 <mauke> that sounds interesting
19:25:09 <mauke> context?
19:25:26 <cmccann> http://www.reddit.com/r/haskell/comments/qqacn/distribution_of_hackage_packages_over_categories/
19:28:35 <rasfar> i don't really know redit, but it seems to say the article is removed; only the comments remain...
19:28:58 <elliott> only cmccann can see the text
19:29:03 <elliott> well+ other mods
19:29:12 <cmccann> oh I thought it still showed that if you had the direct link
19:29:14 <cmccann> oops
19:29:50 <cmccann> here's the image elliott mentioned: http://i.imgur.com/yIsb3.png
19:30:19 <cmccann> the text was basically "based on this chart do you think Haskell has avoided success like SPJ said"
19:31:40 <rasfar> interesting.  i just recently uploaded my first package, and marked it "Provisional" b/c i like the way it sounds, but admit i have no idea what it means and didn't find a glossary.
19:31:52 <cmccann> haha
19:31:54 <c_wraith> rasfar: they really don't mean anything.
19:31:58 <cmccann> yeah
19:32:20 <rasfar> okay that's a relief; i really tried to "do it right" in other respects!
19:32:22 * hackagebot majordomo 0.1.1 - Majordomo protocol for ZeroMQ  http://hackage.haskell.org/package/majordomo-0.1.1 (MarkWotton)
19:32:41 <dolio> Provisional is like temporary, expected to be replaced in the future.
19:32:48 <elliott> can't you omit the field
19:32:56 <elliott> if so, just do that
19:33:22 <c_wraith> I should work on lrucache some more.  It needs some love.  And completely unnecessary api-breaking changes (to go along with the necessary ones).
19:33:23 <rasfar> "Experimental" would be more appropriate really.  I may omit the field in the next version.
19:33:56 <t7> its called snap because thats the sound your bones make when you bash the table with your fist
19:34:28 <c_wraith> I really wish state and modifyMVar expected the result tuple in the same order
19:34:47 <t7> @hoogle (a, b) -> (b, a)
19:34:47 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
19:34:48 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
19:34:48 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
19:35:28 <c_wraith> t7: it's not about being hard to convert between them - it's about picking the order that's natural for one use means picking the order that's unnatural for the other
19:35:58 <t7> i have had a bit of that today
19:36:02 <elliott> i hold one of them to be superior
19:36:08 <elliott> which, i forget
19:36:09 <t7> not tuples specifically
19:36:21 <c_wraith> elliott: not a strongly-held position, then :)
19:43:03 <t7> :t sequence
19:43:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:43:42 <t7> :t maybe
19:43:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:43:54 <HugoDaniel>     GHC stage restriction: m'
19:43:55 <HugoDaniel>       is used in a top-level splice or annotation,
19:43:55 <HugoDaniel>       and must be imported, not defined locally
19:43:58 <HugoDaniel> oh darn :/
19:44:35 --- mode: monochrom set -o monochrom
19:45:14 <rasfar> @seen Heffalump
19:45:14 <lambdabot> Unknown command, try @list
19:46:44 <t7> :liftM2
19:46:48 <t7> :t liftM2
19:46:49 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:47:19 <rasfar> preflex: xseen Heffalump
19:47:20 <preflex>  Heffalump was last seen on freenode/#darcs 7 hours, 57 minutes and 58 seconds ago, saying: and when I tried hacking one up it didn't fix the problem, and I haven't had time to investigate further yet
19:47:49 <t7> @hoogle (m a, m b) -> m (a, b)
19:47:49 <lambdabot> No results found
19:48:14 <rasfar> preflex: xseen xerox
19:48:15 <preflex>  xerox was last seen on freenode/#perl 180 days, 13 hours, 12 minutes and 34 seconds ago, saying: woldrich: do you know how to nuke everything and start over with the perl modules via aur
19:49:48 <HugoDaniel> sleep now
19:50:10 <copumpkin> t7: uncurry (liftM2 (,))
19:50:39 <copumpkin> or liftA2 if that floats your boat :)
20:02:15 <Modius> Why do I get a warning from surface (Circle _ _ r) = pi * r ^ 2    :  "Warning: Defaulting the following constraint(s) to type `Integer'
20:02:15 <Modius>            (Integral b0) arising from a use of `^' at a.hs:7:33
20:02:15 <Modius>            (Num b0) arising from the literal `2' at a.hs:7:35"
20:04:11 <t7> can i get a String from ByteString
20:04:13 <t7> ?
20:05:49 <elliott> const ""
20:06:05 <dmwit> t7: Yes, decode it using
20:06:08 <dmwit> ?hackage encoding
20:06:08 <lambdabot> http://hackage.haskell.org/package/encoding
20:06:09 <dmwit> or similar
20:06:25 <t7> is http ascii?
20:06:38 <elliott> you can get a String composed of Chars whose codepoints are equal to the values of each Word8 in the ByteString, too, with Data.ByteString.Char8.unpack. however, this is unlikely to be what you want unless you are dealing with plain ASCII text.
20:06:40 <dmwit> I don't believe http specifies an encoding.
20:06:52 <elliott> erm i'm pretty sure the http byte protocol is ascii.
20:06:58 <dmwit> It is very unlikely to be what you want if you are dealing with ASCII text.
20:07:08 <dmwit> However, it *might* be what you want if you are dealing with latin-1 text.
20:07:21 <elliott> fair enough
20:08:13 <copumpkin> > abs (minBound :: Int)
20:08:14 <lambdabot>   -9223372036854775808
20:08:17 <dmwit> Ah, the protocol bits might be in ASCII, yeah.
20:08:26 <dmwit> The payload probably isn't, though.
20:08:37 <dmwit> I think there's even a header telling what encoding to use to read the payload. =P
20:08:54 <t7> post params are likely to be utf8?
20:09:16 <elliott> the browser tells you what encoding they're in
20:09:23 <td123> copumpkin: why is that?
20:09:30 <copumpkin> td123: two's complement
20:11:03 <td123> ah right, abs(minBound) > abs(maxBound)
20:11:16 <Modius> I got rid of that warning with -fno-warn-type-defaults  - thoughts on disabling that warning?
20:11:47 <elliott> Modius: specify the types.
20:11:49 <elliott> but, what warning?
20:11:57 <elliott> if you hpasted, it didn't link
20:13:33 <hpaste> Modius pasted ‚Äútype default warning‚Äù at http://hpaste.org/65436
20:14:04 <elliott> oh
20:14:04 <elliott> r ^ 2
20:14:05 <elliott> :t (^)
20:14:06 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
20:14:10 <elliott> (^) has a really stupid type.
20:14:17 <elliott> write r ^ (2::Int). or just r*r
20:14:25 <elliott> basically 2 is unconstrained there. it could be any Integral.
20:14:33 <elliott> so the compiler just picks Integer for you, since you didn't specify otherwise.
20:15:20 <copumpkin> what type would you give it?
20:15:41 <Modius> Aah, I get it - any int type will do; but if you don't force one it'lll pick a default, which is in and of itself fine; but then warn.
20:15:45 <cmccann> > 2 ^ (-2)
20:15:46 <lambdabot>   *Exception: Negative exponent
20:15:51 * cmccann suggests "Natural"
20:16:02 <copumpkin> if only we had such a thing :)
20:16:24 <cmccann> yes but fortunately I'm not going to start complaining about that again
20:18:11 <elliott> <copumpkin> what type would you give it?
20:18:14 <elliott> <elliott> write r ^ (2::Int). or just r*r
20:18:20 <elliott> ::Int is less typing to appease the compiler :p
20:18:47 <elliott> cmccann: didn't you hear? unless we eliminate runtime errors entirely, Natural is pointless! ;)
20:18:56 <NemesisD> anyone ever use wai-test?
20:19:13 <cmccann> elliott, hmmm yes I seem to recall someone arguing about that at great length in here a while back
20:19:36 <elliott> if by "a while" you mean "a few days ago"
20:20:02 --- mode: ChanServ set +o mauke
20:20:02 --- mode: mauke set -q *!*@96.25.129.108
20:20:07 <cmccann> oh, I thought you were referring to one of my diatribes on the matter
20:21:27 <elliott> haha no.
20:21:39 <cmccann> ok.
20:21:57 <elliott> i was referencing a silly argument about whether take should take Natural instead of Integer a few days ago, which will probably restart now that i've explicitly mentioned it :p
20:22:02 --- mode: mauke set -o mauke
20:22:38 <cmccann> because I know I've complained at tedious length about not being able to define a Natural type sensibly even with RebindableSyntax &c.
20:22:49 <cmccann> ah
20:23:31 <elliott> what we really need is (1) TH not to suck and (2) fromInteger :: Integer -> Tagged a (Q Exp)
20:23:38 <cmccann> also, obviously it should be something like "take :: (ToNatural n) => n -> [a] -> [a]"
20:23:59 <elliott> fromInteger n | n < 0 = fail "Negative natural literal." | otherwise = [| Natural n |] or the like
20:24:39 <elliott> actually, i bet that'd break if you don't export the Natural constructor.
20:24:51 <elliott> we need lexically-scoped TH!
20:25:20 <cmccann> a lot of desugaring would be nicer if it could be replaced using TH instead of how RebindableSyntax works but I'm sure that would create other headaches
20:26:06 <elliott> it would be especially nice for OverloadedStrings.
20:26:12 <elliott> string literals causing runtime errors is just wrong.
20:26:15 <cmccann> although you'd probably lose "nice" "features" like being able to shadow (>>=) in local scope to make do blocks mean different things in different places
20:26:36 <elliott> well you can't do that in standard Haskell anyway
20:26:44 <cmccann> yeah, I mean with RebindableSyntax
20:26:47 <elliott> yeah
20:26:50 <elliott> well...
20:26:52 <elliott> you could make it work
20:26:53 <cmccann> where it really is "whatever is in scope"
20:27:02 <elliott> let's say it uses desugarDoNotation :: [Stmt] -> Q Exp
20:27:12 <elliott> it just has to look at the lexical scope to determine which desugarDoNotation to use
20:27:21 <elliott> so let desugarDoNotation = ... in do { ... } should work just fine
20:27:23 <cmccann> that sounds kinda horrifying.
20:27:26 <cmccann> I like it.
20:27:30 <elliott> oh wait no
20:27:32 <elliott> stage restriction
20:27:33 <elliott> boo
20:27:40 <elliott> ok first we remove the stage restriction...
20:27:42 <cmccann> yes
20:27:46 <cmccann> this is a good plan.
20:27:52 <elliott> i mean apart from the stage restriction that's how TH splices work anyway
20:29:34 <Modius> Anyone do Haskell and F#/OCaml back to back?  Wonder how much of a pain it is to flick back and forth between the different-syntax similar aspects of them. .  .
20:29:57 <cmccann> in my limited experience with F# it's easy to switch back to haskell
20:30:08 <cmccann> because you'll always be remembering it because of all the features F# lacks
20:30:43 <elliott> haha
20:31:24 * cmccann wonders if there's anything on hackage designed for incremental parsing of tag-length-value binary formats
20:31:35 <cmccann> or is that too specialized for anyone to care :T
20:31:47 <elliott> wouldn't attoparsec work?
20:31:49 <elliott> i mean, it's monadic.
20:32:04 <cmccann> it's not so much on incremental output I think
20:32:10 <elliott> oh, i see
20:32:25 <elliott> incremental output is tricky with nested structures anyway
20:32:41 <elliott> i mean, error handling becomes awful
20:32:57 <elliott> either you wrap everything in Either ParseError recursively or use "error"
20:34:04 <cmccann> well, there shouldn't be parse errors unless the input stream is corrupted
20:35:17 <elliott> cmccann: that doesn't mean you don't have to handle them
20:35:22 <elliott> but if you really don't then, yeah, error should work fine
20:35:29 <cmccann> this sort of format is mostly about non-human-readable data designed to be read without having to jump around in a file or retain earlier chunks
20:35:45 <elliott> right. but that doesn't mean a server that takes requests in that format is allowed to just crash if someone feeds it invalid input
20:36:35 <cmccann> yeah but it means that often you can "recover" by just throwing away whatever part confused it
20:37:15 <cmccann> anyway, incremental output is relatively easy in these formats because it's very explicit about when a chunk is "done"
20:37:44 <elliott> right, i just mean that e.g. something that represents the same objects as JSON doesn't lend itself well to that kind of thing
20:37:51 <cmccann> you'll always know exactly how many bytes you need before you can produce some data
20:38:50 <cmccann> yes, which is why I'd like something more specialized for this kind of format
20:38:58 <cmccann> because it does make incremental output easy :P
21:02:28 * hackagebot plumbers 0.0.1 - Pointless plumbing combinators  http://hackage.haskell.org/package/plumbers-0.0.1 (MichaelSloan)
21:06:18 <edwardk> mgsloan: yeow
21:07:39 <dmwit> Man. Hackage should just build documentation right away.
21:07:51 <dmwit> How are we supposed to get excited about these announcements when we can't even look inside?
21:08:49 <edwardk> dmwit: follow the repo link and peek inside
21:08:57 <edwardk> i thought i had some complicated operator names =)
21:09:09 <edwardk> https://github.com/mgsloan/plumbers/blob/master/src/Control/Plumbers/Monad.hs
21:09:12 <dmwit> That's what I'm doing, but it's all TH, so not even any type signatures.
21:09:18 <mgsloan>  :)
21:09:59 <edwardk> so is ><> supposed to be pronounced 'fish' or is that the >><> operator? I get confused
21:10:01 <edwardk> =)
21:10:22 <mgsloan> http://www.mgsloan.com/wordpress/?p=148
21:10:28 <edwardk> and some of those operators are clearly pornographic
21:10:41 <elliott> edwardk: btw, did anything come of your iteratee-type stuff yet?
21:10:43 <dmwit> yaaaay
21:11:25 <edwardk> elliott: yes and no. yes, it did, but no its not really public. =( it wound up being an in house dsl for describing some iteratee-like problems, but they aren't really iteratees or very general purpose
21:12:08 <elliott> edwardk: aw, ok then
21:12:15 <elliott> cmccann: did anything come of yours? :P
21:12:34 <elliott> mgsloan: "In practice, only plumbers up to arity 3 are defined by default" -- this is as disappointing as when I realised Scheme doesn't let you use an arbitrary number of as and ds between "c" and "r"
21:13:06 <mgsloan> elliott: yeah, I was thinking about proposing a haskell extension for context-free name generators
21:13:07 <mgsloan> :)
21:13:42 <Jafet> One for APL operators should suffice.
21:14:03 <cmccann> elliott, haven't had much time unfortunately
21:14:42 <rasfar> wow, just realised all the tunes logs pre-2011 are available as a single download, sweet!
21:14:58 <elliott> mgsloan: that pnorm example is surprisingly readable.
21:15:10 <dmwit> mgsloan: No offense, but I hope this doesn't catch on.
21:15:13 <cmccann> elliott, still stuck on getting one of the stream combining operations to work correctly
21:15:26 <elliott> dmwit: here i was thinking i might even use it
21:15:35 <elliott> cmccann: hm, which one?
21:15:44 <dmwit> I might, too.
21:16:03 <mgsloan> elliott: thanks!
21:16:08 <elliott> mgsloan: error in blog post: "(.::) ::"
21:16:43 <cmccann> elliott, the one that lets me encode functions as a stream of in/out pairs that can be manipulated independently
21:16:49 <mgsloan> dmwit: yeah, I'm not sure if I want it to catch on either
21:16:59 <cmccann> which is slightly trickier than it sounds
21:17:00 <Jafet> (.::) blissful hindu god
21:17:31 <elliott> cmccann: that sounds like one of the operations which might be slightly too powerful to actually be possible, or something like that
21:17:47 * cmccann considers the merits of mgsloan's library vs. data-aviary
21:17:47 <elliott> what's the type? (I guess this isn't too useful seeing as I don't know your library's types :P)
21:18:13 <cmccann> it's a CPS-encoding behind the scenes, so it's possible enough
21:19:05 <elliott> mgsloan: not to mention "Fatal error: Call to undefined function e_() in /f5/mgsloan/public/wordpress/wp-content/themes/notes-blog-core-theme/comments.php on line 52"
21:19:11 <cmccann> it's things like the associativity law that have been tricky to write
21:19:50 <cmccann> elliott, but in the end it's doing something like turning (a -> b) into (Either (a -> r) b -> r) -> r
21:20:27 <elliott> hm, ok. is that forall r?
21:20:34 <cmccann> note that id becomes (Either (a -> r) a -> r) -> r which if you squint a bit to ignore the CPS crap is basically the law of the excluded middle
21:20:43 <cmccann> not really
21:20:53 <cmccann> which is why it's trickier
21:21:04 <elliott> how can it be trickier with more freedom in the result?
21:21:14 <cmccann> no, less freedom
21:21:36 <cmccann> because I can't just have a final result value
21:22:08 <cmccann> the "r" basically has to be the remainder of the stream
21:22:11 <elliott> i think you're misinterpreting me
21:22:12 <elliott> if you cani mplement
21:22:21 <elliott> (a -> b) -> (forall r. (Either (a -> r) b -> r) -> r)
21:22:31 <elliott> then it's impossible for more freedom as to the choice of r to make the job harder
21:22:36 <elliott> because you can just re-use that implementation
21:23:23 <cmccann> right, but I can't actually use that implementation
21:23:49 <elliott> ok
21:23:49 <cmccann> because the actual representation I'm using is more complicated
21:23:53 <elliott> right
21:24:06 <elliott> well, it'll be interesting to see whenever it's ready :p
21:25:35 <mgsloan> elliott: thanks for noticing the omitted sig!  I think this library provides most of the aviary, but with a consistent naming scheme
21:25:42 <cmccann> the actual type, using a name that may or may not make sense anymore, would look like "(f `Join` g) r" where f, g, and (f `Join` g) are all Functors
21:25:59 <mgsloan> my hope is that these will be convenient for making one or two operator pipelines
21:26:09 <mgsloan> anything more would be overkill
21:26:35 <elliott> cmccann: so blah :: (a -> b) -> (f `Join` g) r?
21:26:40 <elliott> erm
21:26:41 <sanjoyd> Is it correct to say that Haskell is not as powerful as System F without RankNTypes.
21:26:42 <sanjoyd> ?
21:26:44 <elliott> cmccann: so blah :: (Functor f, Functor g) => (a -> b) -> (f `Join` g) r?
21:27:27 <elliott> mgsloan: honestly i have a large temptation to write anything that isn't something like a mathematical formula or imperative-ish glue code in point-free style. so this package may be very unhealthy form e
21:27:29 <elliott> *for me
21:27:40 <elliott> cmccann: wait, of course not, that discards a and b
21:27:40 <cmccann> it'd be (a -> b) -> (In a `Join` Out b) () probably
21:27:54 <cmccann> or Stream (In a `Join` Out b) for a constant stream
21:28:26 <cmccann> but that's still easy enough
21:28:54 <cmccann> it's things like "(f `Join` (g `Join` h)) r -> ((f `Join` g) `Join` h) r"  that are tricky
21:29:35 <mgsloan> elliott: :D me too.  I've largely tempered this temptation, but yeah, I hope people don't go too crazy with it
21:29:39 <cmccann> or "(f `And` (Not f `Join` g)) r -> g r", that's fun too
21:31:04 <cmccann> anyway, one reason it's tricky is that both inputs and outputs need to carry the "future" of the stream, yet both And and Join essentially require one shared "future" between both halves
21:31:38 <elliott> cmccann: what's Not f there?
21:31:53 <elliott> mgsloan: i mean i'm not entirely convinced it's a bad thing. but probably haskell isn't the language to realise that dream
21:31:54 <cmccann> a type family
21:32:22 <cmccann> Not (In x) = Out x, Not (f `And` g) = Not f `Join` Not g, &c.
21:33:05 <elliott> Join = Or, then?
21:33:15 <mgsloan> elliott: perhaps, but a different representation of haskell / a better depiction of this particular device could make it pretty nice.  Of course, that leaves those that don't use that depiction looking at a symbol soup..
21:33:26 <hpaste> sanjoyd pasted ‚Äúrank2‚Äù at http://hpaste.org/65439
21:33:28 <cmccann> anyway with And it's always created from two things that have their own "futures", so I hide that in an existential
21:33:38 * elliott would probably name it like (f :&: (Not f :|: g)) r -> g r, but perhaps that's less readable :p
21:33:51 <cmccann> well my names are kind of weird at this point
21:33:53 <mgsloan> (by representation I mean some rich, non-text representation that's convertible to / from ascii code)
21:34:01 <cmccann> because I retained them from an earlier version of the library
21:34:04 <elliott> mgsloan: a dataflow-y haskell ide would be fun
21:34:07 <sanjoyd> For instance, in the above example, is the RankNTypes extension really needed, or is only adding some kind of syntactic sugar (and not changing anything deep)?
21:34:14 <ClaudiusMaximus> Executable smbrosiii Build-deps: base, containers, plumbers
21:34:15 <rasfar> mgsloan, interesting... data-aviary also nifty... combinators, yummy!
21:34:34 <elliott> cmccann: since you have very logic-looking laws like that, I wonder if there's some underlying logic to this
21:34:36 <mgsloan> elliott: yup, I'm hoping to work on something like that sooner or later
21:34:41 <cmccann> elliott, linear logic
21:34:43 <elliott> like the FRP <-> linear temporal logic thing
21:34:59 <elliott> cmccann: just plain linear logic?
21:35:01 <cmccann> And and Join are the multiplicative connectives
21:35:03 <cmccann> yes
21:35:05 <elliott> ok
21:35:17 <elliott> (what do In and Out correspond to? I don't know as much linear logic as I'd like)
21:35:32 <cmccann> propositional variables
21:35:52 <cmccann> with In x = Not (Out x)
21:36:03 <elliott> ok
21:36:08 <cmccann> since I have a more interesting notion of negation here
21:36:30 <elliott> shouldn't you just be able to steal standard linear logic proofs for your implementations, then?
21:36:34 <cmccann> i.e. a stream that accepts values of that type, not just an uninhabited type
21:36:46 <elliott> i guess that doesn't help with implementing the axioms
21:37:11 <cmccann> it's the representation of Join that's at issue
21:39:01 <elliott> well, let me know if you put anything on github :P
21:39:26 <cmccann> yeah
21:39:53 <cmccann> unfortunately it's kind of awkward to not have this part working correctly
21:40:18 <erroneous> hello
21:41:23 <cmccann> I did find one representation that... almost works, so I'm tempted to just stick with that for now. but it's not very satisfying.
21:41:38 <elliott> I love things that almost work.
21:42:04 <elliott> you basically just need a translation from classical linear logic propositions into intuitionistic propositions, right?
21:42:11 <elliott> i guess the stream thing complicates things
21:42:19 <elliott> but it seems like you should be able to reuse most of it
21:42:28 * hackagebot plumbers 0.0.2 - Pointless plumbing combinators  http://hackage.haskell.org/package/plumbers-0.0.2 (MichaelSloan)
21:42:38 <cmccann> the stream thing complicates it in peculiar ways, yeah
21:42:39 <php_on_rails> hey
21:42:55 <rasfar> sanjoyd: i hear you, but i'm not the person to give any answer
21:43:26 <elliott> php_on_rails: aaah! it's a monster!
21:43:31 <gaze__> hey, does anyone know of a function like mapM only for hashmaps, or how I'd go about creating one? In other words, I want to send (a -> b) -> Map k v1 -> Map k v2 to (a -> m b) -> map k v1 -> m ( map k v2 )
21:43:39 <elliott> gaze__: Data.Traversable.mapM
21:44:52 <cmccann> elliott, also note that there's a pretty impressive pile of equations for linear logic connectives. the annoying thing is that the almost-working implementation is fine for everything except like... one and a half distributive laws. and I have to cheat for another.
21:45:06 <mzero> php_on_rails: welcome
21:45:48 <gaze__> elliott: Geez that was fast! Thanks!
21:45:51 <elliott> cmccann: have you tried unsafePerformIO?
21:45:55 <elliott> gaze__: np :)
21:46:43 <elliott> gaze__: Hoogle and Hayoo are helpful for finding things like that, btw, although Hoogle doesn't help in this case
21:46:53 <cmccann> in total I need commutativity, associativity, distributivity/factoring for the compatible additive connective, an identity value, and semi-distributivity or whatever that's called for the multiplicative conjunction
21:47:06 <elliott> didn't try hayoo
21:47:11 <gaze__> ooh, as long as I'm here... I'm a bit confused about how I might store a thunk somewhere to be run in another thread... as in, if I have some function f :: a -> b -> IO (c), and I want to fork and evaluate it some other place
21:47:15 <gaze__> and I tried hoogle
21:47:23 <elliott> "evaluation" and "thunks" are unrelated to IO
21:47:29 <elliott> you want to store an IO action elsewhere to execute it later, right?
21:47:38 <elliott> :t forkIO
21:47:39 <lambdabot> Not in scope: `forkIO'
21:47:41 <elliott> ugh
21:47:43 <elliott> @hoogle forkIO
21:47:43 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
21:47:43 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
21:47:43 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
21:47:51 <elliott> so e.g. forkIO (f 1 2)
21:48:13 <elliott> i mean, there's no storing to do
21:48:16 <elliott> IO actions are first-class in Haskell
21:48:35 <elliott> cmccann: dare I ask if anything's happened with hackage2?
21:48:44 <mzero> of course, if you want to fork off something, and "store" IO actions for that thread to pick and execute
21:48:52 <cmccann> haha, haven't had time for any of that
21:48:55 <mzero> you can just plunk IO actions into MVars
21:49:13 <mzero> I've been known to do that
21:49:22 <elliott> or a Chan might be more appropriate
21:49:35 <elliott> startExecutor :: IO (IO a -> IO a)
21:49:36 <mzero> indeed, depending on the passing semantics you need
21:49:50 <cantbrain> Is there a way to get a ByteString from a Source IO ByteString?
21:49:56 <gaze__> mzero: yes that's more what I mean to do
21:50:49 <elliott> startExecutor = do { ch <- newChan; forkIO . forever $ do { (m,v) <- readChan ch; m >>= putMVar v }; return $ \m -> do { v <- newEmptyMVar; writeChan ch (m,v); takeMVar v } }
21:50:50 <elliott> or something.
21:50:53 <cmccann> elliott, at any rate other than the headaches involving multiplicative disjunction I just have a bunch of these functors, build streams by stacking up continuations in a free monad, then take a fixpoint for a complete stream, it's all very tidy
21:50:57 <elliott> cantbrain: depends what ByteString you want
21:50:59 <elliott> cantbrain: conduit, right?
21:51:05 <cantbrain> yep
21:51:09 <elliott> you probably want to compose things together with the conduit operators rather than doing that directly
21:51:21 <elliott> cmccann: yeah, it sounds very nice
21:51:26 <cmccann> all the linear logic identities are natural transformations
21:51:43 <cmccann> it's pretty fun to play with
21:51:44 <cantbrain> I can't figure out how to use a Sink to get at the ByteString with ($$)
21:51:57 <elliott> cmccann: would it generalise to allowing monadic effects (i.e. streams that need to run monadic actions to get their values, etc.) easily?
21:52:13 <elliott> cantbrain: what problem are you trying to solve?
21:52:53 <cantbrain> I want to get the body of an HTTP response, which I get with Data.HTTP.Conduit's http function
21:52:57 <cmccann> elliott, interleaving any Functor is pretty much trivial
21:53:07 <cantbrain> The body comes back as Source IO ByteString in this case
21:53:24 <elliott> cantbrain: okay. so you don't just want the next ByteString from the source, you want all of them concatenated together
21:53:37 <cmccann> it only needs to be a monad if you want to "run" a stream in one go instead of stepping it manually
21:54:00 <cantbrain> That sounds about right.
21:54:03 <elliott> cantbrain: you can use consume to get a [ByteString]: http://hackage.haskell.org/packages/archive/conduit/0.2.2/doc/html/Data-Conduit-List.html#v:consume and then concatenate that
21:54:09 <elliott> however, are you sure you want to read it all into memory at once?
21:54:15 <elliott> the advantage of conduit is that you can do incremental processing
21:54:20 <cantbrain> For now, yes.  It's a tiny response.
21:54:26 <cmccann> elliott, though I think it might need Applicative in some cases for merging two existing streams
21:54:32 <elliott> cantbrain: that doesn't mean someone can't crash your server by feeding a huge one, but sure
21:54:46 <elliott> cmccann: right -- so the standard file->stream and stream->file stuff should work fine
21:55:09 <mzero> cantbrain: use CL.consume
21:55:25 <mzero> so
21:55:31 <cantbrain> elliott, mzero - thanks!
21:55:39 <mzero> body <- fromChunks <$> (requestBody req $$ CL.consume)
21:55:47 <mzero> right from my request body parsing code!
21:56:05 <elliott> actually, Data.Conduit.Lazy.consume might be more appropriate
21:56:11 <cmccann> elliott, yep, though it needs a bit of care in how it's expressed because of the linearity aspect
21:56:15 <elliott> *lazyConsume
21:56:27 <cmccann> I'm trying to decide if I need the exponential modal operators to make this useful
21:56:27 <elliott> (I think it'd use less memory concatenating)
21:56:30 <elliott> (but I might be wrong)
21:57:46 <elliott> cmccann: out of curiosity, what would the corresponding types of the analogies of `streamHandle :: Handle -> Stream IO Char` and `writeToHandle :: Handle -> Consume IO Char` be?
21:57:55 <mzero> cantbrain: any chance your request body is JSON?
21:58:46 <cantbrain> Indeed it is.
21:59:05 <cantbrain> Data.Conduit.Lazy.consume is working
21:59:19 <elliott> Data.Conduit.Lazy.consume doesn't exist
21:59:20 <hpaste> mzero pasted ‚ÄúJsonApplication‚Äù at http://hpaste.org/65440
21:59:21 <elliott> so that's surprising.
21:59:33 <mzero> you might find that little snippet useful
21:59:37 <cantbrain> s/Lazy/List/
21:59:38 <cmccann> elliott, possibly something like "Stream (Run IO `Or` Out Char)"
21:59:48 <cmccann> or "In Char" as appropriate
21:59:56 <mzero> it lets me define my web applications in terms of JSON -> JSON
22:00:06 <elliott> cmccann: cool
22:00:07 <cmccann> maybe Join instead of Or depending on exactly how that works out
22:00:34 <cmccann> this is the part where I'm not sure if I need the modal operators to give it a sensible encoding
22:00:45 <cmccann> since those obviously would make a lot of sense for things like IO
22:00:58 <cantbrain> Thanks a lot for the help, I think this will do for now.
22:02:03 <mzero> sure, let me know if that code isn't clear or if you need more
22:02:34 <mzero> are you using Yesod, or just Warp directly? I'm doing the later
22:03:08 <cantbrain> I'm actually just working on a client, so neither.
22:03:22 <mzero> aha
22:03:24 <cmccann> elliott, there are a lot of fine distinctions possible with the linear logic stuff, but that also makes it a bit tricky to figure out what the encoding of other stream approaches should be
22:04:28 <cmccann> for instance I don't think "In i `Join` Out o" is quite the same as "Automaton i o" even though it seems like it should be
22:05:03 <cmccann> then again I don't have a working implementation for Join yet so eh
22:07:14 <cmccann> I have functor composition in there as well but it doesn't seem to fit into the linear logic setting directly, it behaves as some sort of degenerate, non-commutative multiplicative thingie
22:07:33 <elliott> well, if (In i `Join` Out o) means you can e.g. read three is and then output one o, it's obviously not Automaton
22:07:38 <elliott> or does Join force you to balance them?
22:07:42 <cmccann> yes
22:07:45 <elliott> right
22:07:46 <cmccann> that's the linearity
22:08:10 <cmccann> whereas (In i `Or` Out o) means you can do one or the other at each step, but not both at once
22:08:18 <cmccann> which is also not Automaton
22:08:35 <cmccann> though (In i `Or` Out o `Or` Run m) is basically Pipe I think
22:09:23 <cmccann> but composition is not trivial there because the inputs/outputs aren't guaranteed to match up neatly
22:10:28 <elliott> how does the finaliser/resource management stuff fit into this picture?
22:11:01 <cmccann> not sure yet, that hinges on too many things that I'm still ironing out the details for
22:11:49 <elliott> yeah
22:11:50 <cmccann> but I'd expect it to be able to encode resource management pretty well
22:11:54 <elliott> seems like the linearity would help
22:12:01 <cmccann> because the linear logic aspect gives lots of expressive power that would be useful
22:12:17 <cmccann> though I'm almost certain I'll need the modal operators there
22:13:20 <elliott> hmm... does linear implication desugar into being a stream transformer?
22:13:33 <elliott> I guess so, if I understand your types correctly
22:13:51 <cmccann> linear implication (A -o B) translates to (not A | B)
22:13:54 <elliott> yeah
22:13:58 <cmccann> where | is "par", the upside down ampersand
22:14:02 <cmccann> which I call Join
22:14:06 <elliott> right
22:14:09 <cmccann> i.e. what is giving me headaches
22:14:21 <elliott> so it's a length-preserving stream transformer?
22:14:55 <cmccann> well, it's also a stream itself
22:15:12 <elliott> well, yeah
22:15:38 <cmccann> if you have a stream (A -o B) and a stream of A you can basically zip them as (A * (A -o B))
22:15:44 <cmccann> and then get a stream of B as you'd expect
22:15:44 <elliott> but I mean, thinking in terms of other streaming data solutions, it's basically a conduit/enumeratee/whatever, except that produces 1 output for 1 input
22:15:49 <elliott> thanks to the use of join
22:16:09 <cmccann> right, at least in the absence of the modal operators
22:16:21 <elliott> whereas if I'm understanding correctly (In A `Or` Out B) wouldn't have any guarantees as to what happens to the length, i.e. it could never output or output a thousand times more or whatever
22:16:24 <elliott> or never even request input
22:17:05 <cmccann> well, Or is the coproduct here
22:17:26 <augur> is there a good equivalence-class library?
22:17:31 * hackagebot FilePather 0.1.7 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.1.7 (TonyMorris)
22:17:49 <cmccann> so there's the usual injections f r -> (f `Or` g) r
22:17:53 <cmccann> for any g
22:17:59 <elliott> yeah
22:18:39 <cmccann> the product is With, which offers either but only one can be used at each step
22:18:40 <elliott> (In a `Join` Out b) is like the ST stream transforming arrow, (In a `Or` Out b) is like a pipe (ignoring the monad stuff)
22:19:07 <cmccann> give or take yeah
22:19:36 <cmccann> like I said the details are tricky and I haven't finished fleshing things out
22:19:44 <cmccann> but that's the gist of it
22:19:50 <elliott> do the ? and ! things factor into this?
22:20:01 <cmccann> those are the modal operators I keep mentioning, yes
22:20:05 <elliott> ah
22:20:45 <cmccann> and they're basically a way to specify restricted areas of nonlinearity
22:22:10 <cmccann> you've got "(?A `Join` ?A) -> ?A" and "f -> (f `Join` ?A)" to horrifically mix notation here
22:22:59 <elliott> i like the part where (->) became natural transformation
22:23:16 <cmccann> and dually "!A -> (!A `Join` !A)", "(f `Join` !A) -> f"
22:23:27 <cmccann> yeah it's kind of hilarious how much notation I'm mixing up there
22:23:51 <elliott> i think i have a basic intuition about what the other stuff means in terms of stream processing, but i have absolutely no idea what ? and ! "do" here :P
22:25:22 <cmccann> well, non-linearity, obviously
22:25:55 <cmccann> allowing more inputs than outputs or v.v.
22:26:09 <elliott> well, I said "in terms of stream processing" -- i.e. operationally i have no idea what ! and ? are doing
22:26:16 <elliott> but yeah, i see
22:26:30 <cmccann> well, I'm not sure exactly how I'll handle them
22:27:17 <elliott> "operationally" in terms of "how the data flows through in practice", not as in your specific implementation
22:27:22 <cmccann> but you can probably recognize the shape of what I wrote above as giving (co)monad structure
22:27:45 <causative> ideally you shouldn't have to worry about connecting up the wires in the right order
22:27:53 <rasfar> augur: perhaps Data.Equivalence.* http://hackage.haskell.org/packages/archive/equivalence/0.2.2/doc/html/Data-Equivalence-STT.html
22:27:58 <causative> they should be able to connect themselves up so that the types match
22:28:05 <augur> rasfar!
22:28:14 <causative> only requiring a hint from you when it's ambiguous based on the types
22:28:15 <elliott> i think haskell programmers are used to connecting up things in a way that matches their types.
22:28:27 <elliott> even if there are other isomorphic structures they didn't choose
22:28:37 <causative> you should be able to just specify a bunch of values of various types as parameters to a function, in no particular order
22:29:00 <elliott> causative: well that would be awful.
22:29:02 <causative> and if there's a unique parameter with a matching type, it should go there
22:29:03 <elliott> i'm glad haskell's not like that
22:29:29 <causative> and curry it if possible
22:29:42 <cmccann> elliott, well, that depends on the semantics they end up having, but since a stream of "!A" means "at each step, you can have as many A as you want" that gives you a rough idea
22:29:44 <causative> it would be so much more concise and it would mean you wouldn't have to remember which order the parameters were in
22:29:52 <causative> unless there's ambiguity
22:29:54 * elliott can't tell whether causative is serious or not
22:29:59 <causative> I'm perfectly serious
22:30:02 <cmccann> causative, that sounds fun with polymorphic parameters
22:30:07 <elliott> ok, i'll keep you away from the committee then
22:30:08 <cmccann> ambiguity everywhere, yay!
22:30:11 <causative> name one downside to the scheme I suggested
22:30:19 <elliott> 1. everything
22:30:28 <causative> if there is ambiguity cmccann then you'd have to specify which parameter goes with which
22:30:30 <cmccann> causative, ambiguity will be much more common than you think
22:30:46 <elliott> for there to be downsides, there have to be upsides. this destroys readability, maintainability, forwards-compatibility, and creates rampant ambiguity
22:30:55 <cmccann> causative, it'd be a massive headache in practice I guarantee
22:30:58 <rasfar> augur: cheers; & oops, that was old API, the package is http://hackage.haskell.org/package/equivalence
22:31:02 <elliott> readability - it's impossible to know how the arguments are being plugged in without knowing the function's precise type
22:31:22 <elliott> maintainability - whoops! i add an argument to an application and it breaks because it was relying on the unambiguity that i just ruined
22:31:34 <augur> rasfar: so did we talk about this paradigm detection stuff?
22:31:36 <elliott> forwards-compatibility - changing API in a way that e.g. swaps parameters or the like -> silent breakage
22:31:41 <elliott> ambiguity -> like cmccann said
22:31:53 <cmccann> elliott, or because something indirectly changed some type defaulting and an Integer is now a Double
22:32:21 <elliott> cmccann: imagine applying (^) in this world
22:32:22 <rasfar> ah, that /was/ an exclamation of familiarity!  i'd forgotten -- you had asked about detecting language paradigm based on hardware behaviour, right?
22:32:27 <elliott> _that_ would be a recipe for fun
22:32:33 <cmccann> unless you forbid type defaulting with these magic parameters, in which case you can't use numeric literals with them
22:32:43 <elliott> oh, it'd break the open world assumption!
22:32:48 <cmccann> haha
22:32:49 <causative> suppose that instead of having to remove ambiguity especially, the argument is simply supplied to the parameter with a matching type that comes first
22:32:54 <elliott> imagine if only one of your types had an Integral instance
22:32:57 <elliott> so the application of (^) was unambiguous
22:33:01 <elliott> then you added an Integral instance for the other
22:33:04 <elliott> and suddenly it's ambiguous!
22:33:09 <rasfar> unfortunately we will be swamped by the ongoing linear logic discussion
22:33:13 <elliott> causative: ooh, now it has even more silent breakage :)
22:33:22 <elliott> rasfar: the linear logic discussion stopped, hehe
22:33:31 <elliott> i'll try to be less swampy ;)
22:33:44 <augur> rasfar: yeah
22:33:47 <rasfar> sorry, i'm reading La vie de Franz Liszt and didn't notice...
22:34:01 <augur> rasfar: blah maybe?
22:34:10 <cmccann> obviously if IRC had linearity constraints elliott wouldn't be able to talk more than everyone else
22:34:10 <augur> #haskell-blah
22:34:11 <causative> yes, that is a downside that the values could change their type
22:34:21 <rasfar> sure, see you in blah...
22:34:29 <causative> perhaps there is a way to fix it
22:34:51 <elliott> cmccann: I propose turn-based IRC
22:35:06 <elliott> IRC-by-mail
22:35:12 <cmccann> great plan
22:35:47 <rwbarton> i could imagine an IDE doing some of this for you based on the instances it knows about at a particular time plus input from the programmer
22:35:56 <rwbarton> but not a language
22:36:35 <causative> perhaps only do the type matching if the type is known to be unambiguous and unable to change in the future
22:36:40 <rwbarton> I think that would give you most of the upside without most of the downside, now it is just a small matter of implementing it so that it actually works :)
22:37:06 <causative> so if your function takes two parameters, one is a tree and the other is a list, there's no way either could subtly change behind the scenes
22:37:13 <cmccann> elliott, anyway, the modal operators are less constrained than other stuff in that you can't prove that ! and !' are identical even if they follow the same laws
22:37:23 <causative> and you can match them up in the correct order with no possible problem
22:38:10 <causative> for more complicated types they could be matched manually
22:38:12 <elliott> i'm not exactly sure what the upside is here. you can write map [1,2,3] instead of flip map [1,2,3]?
22:38:21 <causative> yes
22:38:26 <elliott> that is so not worth it.
22:38:31 <causative> you don't need any of the plumbing to switch around parameters
22:38:36 <elliott> and it basically destroys type-based reasoning
22:38:38 <causative> haskell has a lot of that stuff
22:38:54 <elliott> i.e. i can't reason about an application of a function based on its type
22:39:11 <cmccann> it also wouldn't work with fmap
22:39:34 <cmccann> because both arguments are always Functor instances
22:39:46 <causative> so you have to remember the order for that one
22:40:04 <causative> elliott, what do you mean, you could still reason about it
22:40:25 <cmccann> right, it wouldn't help with generic combinators
22:40:28 <cmccann> not like we use those much
22:40:32 <causative> the compiler would just switch the parameter order based on available local information, you could mentally do the same thing
22:41:00 <elliott> this is really silly. like having to present counterargument after counterargument for not writing all our code in Perligata.
22:41:06 <elliott> in fact, doesn't Perligata do exactly this?
22:41:53 <rwbarton> but why should i have to do the same thing?
22:41:53 <cmccann> just sounds like something that offers trivial convenience for trivial cases, and doesn't help at all or makes things worse for anything that isn't a toy example
22:42:37 <causative> it helps most for functions that have a lot of parameters
22:42:47 <causative> of distinct types
22:43:14 <cmccann> and how many of those are there, really?
22:43:24 <cmccann> hint: the answer isn't "lots"
22:43:37 <causative> well I don't write Haskell for a living, but I did used to work as a medical software developer
22:43:47 <causative> and there were a lot of functions with 10+ parameters
22:44:08 <elliott> those are called bugs in haskell.
22:44:15 <elliott> they should usually be functions taking a single record
22:44:16 <cmccann> usually a sign that you need better data types
22:44:18 <elliott> or, better, a combinator library
22:44:19 <causative> because they started out with 5 parameters but people wanted it to be able to do more
22:44:24 <elliott> 10-parameter functions are vanishingly rare in Haskell
22:44:39 <elliott> heck, 5-parameter functions are pretty rare too
22:44:52 <causative> I suspect that depends on what kind of program you are writing
22:44:55 <elliott> nope
22:45:13 <causative> if the subject domain is complicated with a lot of different possibilities, your functions will be complicated too
22:45:20 <elliott> i can't think of a single case where a 10-parameter function would be the single most idiomatic solution to accomplish anything in haskell (outside of the internals of an FFI library, i.e. external libraries that have 10 arguments)
22:45:28 <elliott> yes, but that doesn't translate to number of parameters
22:45:37 <cmccann> I can't think of many cases where that would be idiomatic in any language really
22:45:41 <elliott> like i said, one parameter being a 10-field record
22:45:46 <elliott> or a combinator approach
22:45:51 <elliott> or heck, a reader monad over that record
22:46:03 <c_wraith> one parameter being an object with way more than 10 fields isn't uncommon, though
22:46:06 <causative> for example suppose you would like to calculate the price of a certain charge
22:46:08 <elliott> cmccann: probably not all that rare in C, since they don't really have all that much choice
22:46:21 <cmccann> c_wraith, which is pretty much the "use a record" approach
22:46:23 <causative> sounds simple, but this is actually a vastly complicated operation in medical billing
22:47:02 <causative> dependent on many different sources of data, various codes and diagnoses associated with the charge, the insurance's fee schedule, contracts, etc
22:47:22 <elliott> sounds like you want to use a reader monad there
22:47:25 <elliott> definitely
22:47:31 <causative> and in a large medical software program you will want to calculate this price in 50 different contexts, most of which have only _part_ of this information about the charge
22:47:49 <elliott> ah, then you'd want to separate each piece of information into its own monad typeclass
22:47:57 <elliott> so that you can specialise with relevant reader monads at use-time
22:48:00 <elliott> anyway no haskell programmer would write a 10-parameter function as a solution to this problem
22:48:19 <cmccann> or have everything in a record and use local environments in Reader or whatever
22:48:46 <cmccann> but none of that is something you'd want a huge pile of parameters for
22:48:56 <causative> what was actually done where I used to work, is having the equivalent of a 50 parameter function for all the different options, except it's passed as a big hash table
22:49:14 <causative> any calling code would have to translate its data to make this hash table in order to calculate the price
22:49:33 <elliott> yes, the monad typeclass solution completely avoids that problem.
22:49:34 <causative> and in addition to that, there were 10+ regular parameters
22:49:47 <elliott> if you have the information in a certain context, you could adapt it for this 50-parameter-function-equivalent by giving instances
22:49:51 <elliott> and require no translation at all
22:50:20 <causative> because the big hash table is supposed to be for a certain kind of data, say billing information about the charge
22:50:35 <causative> and isn't supposed to have miscellaneous other tidbits
22:50:46 <causative> so those other tidbits become actual function parameters
22:51:12 <causative> if there are _enough_ tidbits, then you pass in a second hash table, but rewriting the code to do that is a gigantic piece of work
22:51:16 <elliott> this is silly, there's no obstacle to doing any of this nicely in haskell without functions with huge numbers of parameters at all
22:51:31 <elliott> it's just problems that other languages face that aren't applicable to haskell
22:52:06 <causative> has anyone written a large billing application in haskell?
22:52:28 <cmccann> why does that matter?
22:52:44 <causative> or any large business app in haskell?
22:53:10 <elliott> well this is verging on trolling
22:53:13 <causative> it gets complicated when you have to deal with real-world junk business logic
22:53:22 <elliott> plenty of people solve real, complicated problems every day in haskell
22:53:27 <cmccann> yes, and Haskell has better tools for managing that complexity than most languages
22:53:36 <elliott> it never requires 50-parameter functions, and I've proposed several ways to turn tangly things like that into managable things
22:53:53 <elliott> with strong static guarantees on what components can access etc. and without any ugly conversion
22:54:02 <elliott> but you've just kept saying the same things in response, so... whatever
22:54:40 <cmccann> real-world business logic is not difficult and it's not anything special
22:54:45 <causative> there's a parameter which gets passed a _lot_ in medical billing, which is whether the code is being called from professional billing (aka doctor billing) or from hospital billing (facility billing)
22:54:57 <causative> the behavior is slightly different between these two cases
22:55:05 <elliott> class MonadBilling m where billingType :: m BillingType
22:55:11 <elliott> data BillingType = Professional | Hospital
22:55:22 <elliott> provide instances wherever applicable, include in contexts wherever needed; complexity managed
22:55:44 <causative> so instead of writing two functions, one for professional and one for hospital, because the function is large, you pass the parameter
22:56:10 <causative> and then in certain places in the function you have code that says if(HB) { do something} else {do something else}
22:56:22 <cmccann> causative, I don't know why you're making this out to be something really significant
22:56:34 <cmccann> this is a trivial problem to solve
22:56:38 <elliott> i think causative just doesn't understand the proposed solutions
22:56:41 <elliott> causative: how much haskell do you know?
22:56:46 <causative> a little
22:57:04 <elliott> right... you seem to be equating "I don't understand the solutions being proposed" with "they don't understand the problem"
22:57:16 <cmccann> there are better approaches in OO languages for that matter
22:57:53 <causative> what would you do with this PB/HB parameter in an OO language?
22:58:04 <cmccann> that's a wrong question
22:58:14 <cmccann> you would take three steps back and fix the design first
22:58:25 <causative> what would you do to it?
22:58:33 <cmccann> use OO design?
22:58:39 <causative> the PB/HB difference is mandated by legislation
22:58:41 <causative> you can't get rid of it
22:58:45 <cmccann> doesn't matter
22:58:47 <elliott> cmccann didn't say get rid of it
22:58:59 <causative> but what would you do with OO design to manage it?
22:59:15 <andares> PB/HB?
22:59:17 <cmccann> causative, it's 2am, I don't feel like explaining the principles of OO design in #haskell right now :P
22:59:30 <andares> does Haskell really need OO design?
22:59:35 <cmccann> no
22:59:50 <andares> I mean, objects are inherently stateful.
22:59:55 <cmccann> no they're not
23:00:04 <elliott> cmccann was talking in the context of OOP languages.
23:00:04 <cmccann> immutable objects are fine
23:00:07 <elliott> but it's untrue that OOP is inherently stateful
23:00:09 <edwardk> andares: i work with immutable objects a lot
23:00:39 <edwardk> OOP as a design pattern tends to cause you to build big mutable messes of state, but it doesn't have to
23:01:13 <elliott> hey, GHC programs often allocate gigabytes/sec right? I said so and then started doubting myself
23:01:21 <elliott> I distinctly recall someone saying they managed a terabyte in a few second
23:01:22 <elliott> s
23:01:32 <andares> how are member functions different from typeclasses then?
23:01:38 <andares> *typeclass functions
23:01:45 <cmccann> dunno about "often" but that doesn't seem unreasonable
23:02:03 <cmccann> andares, how is a porcupine different from a windmill?
23:02:06 <edwardk> typeclasses have a 'confluence' property that member functions lack for one
23:02:21 <edwardk> i really don't quite know how to even start answering that
23:02:32 <elliott> andares: class Foo a where foo :: Integer -> a
23:02:47 <elliott> you can't do return-type polymorphism like that with OOP.
23:02:48 <edwardk> typeclasses in haskell are kind of like 'vtables' for classes in c++, separated from the thing they are a vtable for
23:02:52 <elliott> heck, even
23:02:56 <elliott> class Foo a where foo :: a -> a -> IO ()
23:03:00 <causative> nah it's essential complexity, you can't really do anything about it that doesn't make the code twice as long
23:03:02 <elliott> which a would you callt he method on?
23:03:19 <elliott> causative: I proposed a concrete way that eliminates passing the parameter around anywhere
23:03:22 <cmccann> causative, I doubt that
23:03:35 <edwardk> however, we use a different mechanism to figure out which vtable should be used, which lets you retroactively apply them to other data types
23:03:35 <elliott> unless you invalidate my constructive proof, you're just in denial :p
23:03:44 <causative> elliott, the issue is not just passing the parameter, it's what you do with it once you have it
23:03:54 <edwardk> and which lets you deal with things that have no oop analog like MPTCs, etc.
23:03:55 <cmccann> elliott, ever heard of the curiously recurring template pattern?
23:04:04 <elliott> cmccann: yes
23:04:04 <andares> elliott: it seems then that typeclasses are more general than object methods. can all object methods be expressed as typeclass methods then?
23:04:06 <causative> functions that are trying to handle two slightly different things at once
23:04:40 <elliott> andares: the natural encoding of an OOP object is a data type.
23:04:46 <elliott> the similarity of "class" and "typeclass" is a misnomer.
23:04:48 <elliott> "instance" too
23:04:57 <cmccann> elliott, you can encode stuff like (a -> a -> IO ()) sorta using similar tricks
23:04:59 <elliott> they are very unrelated
23:05:09 <causative> what's the largest application written in Haskell?
23:05:11 <elliott> cmccann: true. but that isn't really quite part of pure "OOP" to me.
23:05:24 <cmccann> causative, whatever it is it's probably very proprietary
23:05:29 <elliott> causative: nobody knows, since plenty of places use haskell internally
23:05:31 <cmccann> elliott, eh, true
23:05:32 <elliott> like standard chartered
23:05:41 <causative> well what's the largest haskell application that we know about?
23:05:52 <cmccann> causative, anyway, define "large"
23:05:59 <causative> lines of code
23:06:02 <elliott> galois have probably done a lot of large things anyway
23:06:03 <cmccann> that's a terrible metric.
23:06:07 <elliott> causative: lines of code is an inaccurate metric
23:06:11 <causative> all metrics are terrible and inaccurate
23:06:14 <elliott> more experienced at haskell -> fewer lines of code
23:06:14 <andares> elliott: typeclass and interface are similar ideas though. I was imagining that instead of using OOP in Haskell, you could use just regular functions on their own, and typeclasses to define the "class structure" (i.e. member functions)
23:06:19 <andares> but I see that's wrong.
23:06:19 <elliott> since you can heap on the abstractions
23:06:19 <cmccann> yes, but LOC is actively bad
23:06:21 <rasfar> you need to multiply x50 to get equivalent lines of C++ code
23:06:31 <causative> what measure of size do you prefer?
23:06:46 <elliott> i don't prefer any, you're the one insinuating haskell isn't used in any huge systems
23:07:15 <cmccann> causative, there's also the matter that size biases toward giving horrifically misengineered monolithic tarpits more significance than they deserve
23:07:48 <rasfar> xmonad was one of the larger a few years ago; compare it to # lines of even the smallest WM's written in C...
23:08:19 * cmccann suspects GHC is the largest widely-used haskell program, but isn't sure
23:08:23 <elliott> i don't think xmonad is even close to being one of the largest haskell projects
23:08:27 <elliott> darcs is almost certainly larger
23:08:30 <elliott> GHC is gigantic in comparison
23:08:35 <elliott> indeed, xmonad's marketing focuses on how tiny it is in part
23:08:45 <andares> oh, as long as we're on a similar subject.
23:08:46 <elliott> causative: GHC is some 100k lines of code or something
23:08:49 <rasfar> tiney relative to C yes
23:08:53 <andares> are there any Haskell compilers/interpreters written in Haskell?
23:08:57 <cmccann> GHC?
23:09:04 <causative> my former employer's server-side code was 27 million lines
23:09:10 <causative> the client-side code was about twice that
23:09:12 <elliott> your former employer's server-side code was a mess
23:09:14 <andares> ‚Ä¶ wow, sorry.
23:09:18 <cmccann> causative, that's terrible
23:09:19 <elliott> btw, GHC would be a lot more than 100k lines if it wasn't written in haskell
23:09:22 <andares> for some reason I really thought ghc was C.
23:09:22 <elliott> so your comparison is again ridiculous
23:09:32 <cmccann> andares, the runtime is C I think?
23:09:37 <cmccann> but GHC itself is Haskell
23:09:40 <elliott> the RTS is C and some C-- i think
23:09:54 <elliott> that 100k figure might include the boot libs. not sure
23:09:57 <andares> I'll have to check out the code some time.
23:10:01 <andares> RTS?
23:10:03 <rasfar> oops gotta go, g'night!
23:10:03 <elliott> runtime system
23:10:05 <cmccann> it's been self-compiled for ages which is why you need GHC to compile GHC and the first thing it does is bootstrap itself and then recompile the new GHC using the new GHC
23:10:13 <elliott> anyway this discussion is not going anywhere
23:10:19 <elliott> (not the one about GHC, the one that spawned it)
23:12:55 * hackagebot yesod-test 0.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.1 (GregWeber)
23:32:55 * hackagebot test-shouldbe 0.1.0 - Catchy combinators for HUnit  http://hackage.haskell.org/package/test-shouldbe-0.1.0 (SimonHengel)
