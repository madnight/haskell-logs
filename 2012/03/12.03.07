00:00:19 <mikeplus64> odd, does gnome 3's compositing and all that jazz play nice with openbsd?
00:01:40 <mrcarrot> mikeplus64: depends on the graphic card as 3d is slow on some cards
00:02:27 <mrcarrot> <3 xmonad
00:06:31 <DrAwesomeClaws> it sounds cheesy but xmonad has me excited about using my computers again in a way I don't remember feeling since I was little playing with my first 286.  Feeling like I'm controlling this fantastic machine.  I think it's time for bed for me, haha.  Saying silly things now, but it's true.
00:08:25 * albel727 agrees with dr.
00:08:41 <mrcarrot> DrAwesomeClaws: for me it is not like that... i had no real wow feeling from starting to use xmonad, more a feeling that i am missing automatic tiling when i am using other peoples computers
00:09:55 <mrcarrot> haskell on the other hand gave me such feelings :) (allthough i am just a returning beginner)
00:10:07 <mrcarrot> i had lost the joy of writing code...
00:10:55 <DrAwesomeClaws> I've only been using it a few days, so haven't experienced that yet.  But I'm contemplating wiping out my OS X install on my macbook and just throwing ubuntu on there.  Probably won't though, it's useful / easier to have OS X (to run unity3d) and just run an ubuntu on top.  But I find myself wanting to be in xmonad at all times
00:11:05 <albel727> that "missing automatic tiling" sense becomes almost unbearable at times.
00:11:15 <DrAwesomeClaws> and shunning my mouse/trackpad
00:12:12 <mrcarrot> hello Athas
00:13:37 <Athas> Hello mrcarrot.
00:13:44 <DrAwesomeClaws> Haskell is tying in well with my other activities.  I've been relearning mathematics, and diving into physics / other sciences.  It's fun to write little haskell functions that model whatever I'm learning about.  Though I'm also a complete beginner for the most part
00:14:18 <tomprince> I find the jack sensing nice.
00:15:01 <DrAwesomeClaws> I'm about to sit in bed with my lap top and play around with generalizing genetic algorithms.  Just a bunch of functions, will be fun to play with
00:15:28 * hackagebot cabal-nirvana 0.2.1 - Avoid Cabal dependency hell by constraining to known good versions.  http://hackage.haskell.org/package/cabal-nirvana-0.2.1 (MichaelSnoyman)
00:16:28 <miogaruna> Hello #haskell, I have a Cabal dependency problem I am trying to deal with
00:16:43 <miogaruna> I'm trying to install xmonad-utils from Cabal in order to get the program hhp
00:16:54 <miogaruna> (for xmonad, unclutter causes focussing errors)
00:17:21 <miogaruna> xmonad-utils depends on base<4
00:17:52 <miogaruna> but can't install the two versions of base lower than 4 because of the error "top level dependency"
00:18:46 <DrAwesomeClaws> I don't know enough to help you but just saying hi so you don't feel ignored
00:19:06 <hpaste> miogaruna pasted “xmonad-utils dependency error” at http://hpaste.org/64917
00:19:20 <miogaruna> ^ like that
00:19:37 <idnar> @src sum
00:19:37 <lambdabot> sum = foldl (+) 0
00:20:32 <Cale> miogaruna: looks like xmonad-utils hasn't been updated for whichever GHC you're running
00:21:12 <Cale> miogaruna: however, you should still be able to do cabal unpack xmonad-utils and just try editing the xmonad-utils.cabal file in there to relax the base dependency
00:21:24 <Cale> (It's unlikely that there's a real version issue)
00:22:06 <Cale> and then just run "cabal install" from that directory where it got unpacked to
00:22:15 <franco00> I want to import a module Xxx.Yyy, from a file which lies in the same folder os the module I am loading. I tried import Xxx.Yyy and import Yyy without success... Is that even possible_
00:22:19 <franco00> *?
00:22:50 <Cale> franco00: the former should work, but make sure that you run ghc from the directory which contains the directory Xxx
00:23:18 <franco00> Cale: so I guess ghci won't do, right?
00:23:22 <miogaruna> Cale: I don't think it worked, it's trying to import a version of Control.Monad which doesn't have the ExitException
00:23:26 <Cale> franco00: or ghci
00:23:44 <Cale> franco00: you should be able to  ghci Xxx/Zzz.hs
00:23:59 <Cale> miogaruna: ah
00:24:11 <Cale> miogaruna: okay, then it really does need proper updating
00:24:31 <Cale> Maybe another xmonad user here can help?
00:24:37 <Cale> (I don't use xmonad myself)
00:24:51 <DrAwesomeClaws> blasphemy!
00:25:16 <Cale> I can't stand tiling WMs
00:25:28 * hackagebot xturtle 0.1.3 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.3 (YoshikuniJujo)
00:26:29 <DrAwesomeClaws> haha.  Tiling WMs are all shiny and new for me.  I knew about them, but never gave them much though until recently
00:26:32 <franco00> which WM do you use Cale
00:26:58 <Cale> franco00: Metacity
00:27:01 <DrAwesomeClaws> Packard Bell Navigator?
00:27:11 <Cale> (the Gnome 2 version)
00:27:41 <franco00> you probably don't use a 10" screen
00:27:51 <Cale> That's right
00:27:52 <franco00> xmoand is a gift from God there
00:28:11 <Cale> I have a 24" LCD
00:28:13 <mrcarrot> Athas: out of curiousity, do you use xmonad or dwm?
00:28:13 <miogaruna> XMonad is a gift from God for all laptops
00:28:51 <franco00> true words
00:28:57 <Cale> At some point I might have to get a laptop. I always have a really hard time justifying the extra expense of it for the same computational power.
00:29:09 <franco00> portability
00:29:21 <Cale> yeah, if I ever want to travel :)
00:29:37 <franco00> travel to milan, I'll offer you a pizza
00:34:59 <mrcarrot> franco00: how much is a pizza typically costing in italy?
00:35:48 <franco00> depends, on the pizza and on the place. On average something around 8 euros.
00:36:00 <franco00> In Milan, rather
00:37:48 <miogaruna> franco00: Out of curiosity, which browser do you use on your 10" screen?
00:38:21 <franco00> Cale: I might have misunderstood you. I am in \Ancillaries folder, editing string.hs. In there I put import List ( revFun ). And then I should, call ghci string.hs, right? Becuase it complains, expecting List and finding Ancillaries.List
00:38:33 <Athas> mrcarrot: xmonad.
00:38:45 <franco00> miogaruna: iceweasel + pentadactyl. Midori isn't bad too.
00:39:39 <MostAwesomeDude> Midori behaves a little better than Fx on constrained systems, if you disable JS.
00:39:54 <franco00> I always disable js XD
00:40:02 <Cale> franco00: no, you should run  ghci Ancillaries/String.hs
00:40:26 <Cale> franco00: i.e. go up a level and then run ghci on it
00:40:28 * hackagebot cabal-nirvana 0.2.2 - Avoid Cabal dependency hell by constraining to known good versions.  http://hackage.haskell.org/package/cabal-nirvana-0.2.2 (MichaelSnoyman)
00:41:00 <Cale> and you should be importing Ancillaries.List
00:41:00 <Athas> Technically, nirvana should be not using dependencies at all!
00:41:09 <shergill> snoyman is on a roll
00:41:13 <MaskRay> pentadactyl's failure to expose cmdline in my firefox obliged my switching to vimperator
00:41:45 <cheater__> MaskRay: maybe you were using a plugin that was breaking the browser window?
00:41:48 <cheater__> i've had that too.
00:42:00 <cheater__> i had to use a different plugin for vertical tab layout.
00:42:02 <miogaruna> is vimperator still updated for ff>4?
00:42:08 <franco00> yeah, sounds strange miogaruna
00:42:16 <cheater__> yes miogaruna
00:42:47 <MaskRay> cheater__: the culprit may be tree style tab
00:43:21 <cheater__> no tst works
00:43:35 <cheater__> VerticalTabs didn't work for me
00:43:41 <MaskRay> miogaruna: works well with firefox-10.0.2
00:43:44 <cheater__> in fact any other plugin that does vertical tabs did not work
00:43:58 <cheater__> they messed up the pentadactyl commandline
00:44:05 <cheater__> but i think they might have done the same to vimperator
00:44:30 <cheater__> but, it was still visible
00:44:33 <cheater__> it wasn't hidden
00:44:40 <cheater__> just.. yeah, messed up
00:45:08 <miogaruna> Actually, what's the difference between vimperator and pentadactyl now?
00:45:36 <cheater__> pentadactyl is newer.
00:45:45 <cheater__> seems better made altogether.
00:46:06 <merijn> One is used by cool people, one is used by scrubs. Which is which depends on what you are currently using :>
00:47:40 <maus> I got a strange error trying to build encoding with ghc-7.0.3 http://hpaste.org/64918 on ubuntu-12.04. Can someone comment on it?
00:53:44 <hpaste> osager pasted “How to test code in ghci” at http://hpaste.org/64920
00:53:55 <franco00> works like a charm Cale
00:54:40 <merijn> osager: This is wrong "print $ show x", or rather it doesn't do what you expect, since "print = putStrLn . show"
00:55:02 <merijn> So it ends up doing "putStrLn . show . show" which works, but is probably not what you intended :p
00:55:38 <osager> thanks i'll try putStrLn
00:55:40 <merijn> osager: Also, the error comes from doing "main "hi""
00:55:53 <merijn> main takes no arguments, so giving main arguments is a type error
00:56:02 <osager> i get that
00:56:05 <merijn> It should work if you compile it and run it from the commandline, though
00:56:10 <osager> but i saw some example code
00:56:16 <merijn> (getArgs returns the commandline arguments)
00:56:27 <osager> so how can i test the code in ghci ?
00:57:20 <osager> i mean test commandline arguments
00:57:41 <merijn> osager: I'm not sure you can?
00:58:08 <osager> so we can not test commandline arguments in ghci ? they should put that on the box
00:58:26 <mauke> setArgs
00:58:45 <mauke> oh, doesn't exist
00:58:50 <mauke> withArgs [...] main
01:00:06 <osager> withArgs..
01:00:15 <osager> let me take a look
01:00:23 <merijn> osager: You can just run the code that gets called with the results of getArgs as test, no?
01:00:55 <Enigmagic> osager: run ":main hi" instead
01:01:19 <osager> thank you Enigmagic
01:01:23 <osager> that solved the problem
01:01:24 <osager> lol
01:01:48 <Enigmagic> np :)
01:02:02 <mauke> and withArgs didn't?
01:02:25 <osager> i didnt try... havn't found the doc
01:02:27 <osager> on it
01:02:38 <Enigmagic> :main is always in scope in ghci
01:02:49 <osager> ok found it
01:02:51 <merijn> osager: Simple: http://www.haskell.org/hoogle/?hoogle=withArgs
01:02:53 <osager> ok
01:03:07 <osager> so :main means run external program ?
01:03:30 <osager> and just main means
01:03:35 <osager> what's the difference
01:04:33 <Enigmagic> osager: :main is a ghci command that calls a main function with arguments
01:04:46 <mauke> except main is not a function
01:05:07 <Enigmagic> sure it is
01:05:35 <mauke> no
01:06:00 <imc> 'no' it's a good start... (sorry, out of context)
01:06:01 <Enigmagic> really? last time I checked IO was a newtype wrapper around a function
01:06:11 <mauke> Enigmagic: not in Haskell
01:06:13 <imc> :)
01:06:18 <Enigmagic> :t IO
01:06:19 <lambdabot> Not in scope: data constructor `IO'
01:06:40 <ivanm> Enigmagic: that used to be used as a way of explaining IO
01:06:42 <Enigmagic> *Main System.IO> :info IO
01:06:42 <Enigmagic> newtype IO a = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
01:06:42 <redheadphones> anyone use hint (http://darcsden.com/jcpetruzza/hint) and know how to pass it a String to eval/interpret from another function?
01:06:56 <mauke> Enigmagic: implementation details of ghc
01:06:58 <ivanm> and IIRC before Monads it *was* a function
01:06:59 <merijn> Enigmagic: Irrelevant implementation detail
01:07:08 <Enigmagic> well it's still a function
01:07:11 <mauke> no
01:07:16 <merijn> ivanm: Main used to be [String] -> [String] I think
01:07:28 <ivanm> merijn: yeah, though with type aliases
01:07:36 <merijn> Enigmagic: "It's implemented as a function" != "It's a function"
01:08:00 <Enigmagic> merijn: i have to write code that uses it as a function, so i think it's safe to assume it's a function
01:08:05 <merijn> I can implement OOP objects as closures, doesn't mean objects are functions
01:08:12 <Enigmagic> otherwise it wouldn't type check
01:08:16 <merijn> Enigmagic: No, you will only confuse yourself later
01:08:30 <merijn> IO a is an action which can be run
01:08:37 <mauke> Enigmagic: you can't write code that uses it as a function
01:08:42 <Enigmagic> yes you can
01:08:45 <mauke> show me
01:08:52 <merijn> You can't "use an IO a" as a function since IO doesn't return anything
01:09:10 <merijn> Or doesn't take any arguments, is probably more accurate
01:09:14 <ivanm> unsafeCoerce! :p
01:09:26 <hpaste> Enigmagic pasted “hmm” at http://hpaste.org/64921
01:09:50 <mauke> Enigmagic: that doesn't use IO as a function
01:09:58 <Enigmagic> mauke: oh?
01:10:00 <ivanm> Enigmagic: just because you can doesn't mean you *should*
01:10:04 <ivanm> mauke: the last line?
01:10:11 <mauke> ivanm: unwraps IO to get a function
01:10:14 <ivanm> oh, right
01:10:21 <ivanm> Enigmagic: you're not using IO *itself* as a function
01:10:28 <ivanm> you're using the internal function from IO
01:10:37 <ivanm> also, that's evil
01:10:59 <Enigmagic> so?
01:10:59 <osager> what's the use of withArgs ?
01:11:08 <ivanm> and I would question why anyone would want to write such a thing
01:11:11 <ivanm> @hoogle withArgs
01:11:11 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
01:11:24 <Enigmagic> ivanm: it was written for a very particular reason
01:11:33 <Enigmagic> however there is a lot of code in GHC that does the same thing
01:12:01 <ivanm> osager: well, for starters you can choose whether or not to evaluate that IO depending on whether an arg is passed
01:12:03 <franco00> I know this ain't #vim, buuuut, :nnoremap <space>   o<Esc> <-- is space used for anything meaningful in normal mode?
01:12:11 <ivanm> Enigmagic: pray tell?
01:12:24 <ivanm> (why it was written, that is)
01:12:32 <Enigmagic> ivanm: because it's faster than the alternatives.
01:12:32 <shachaf> franco00: #vim would probably have a good answer. :-)
01:12:35 <osager> ok
01:12:46 <osager> thanks i'll think about what you just said
01:12:47 <ivanm> Enigmagic: at doing what?
01:12:47 <franco00> xD indeed indeed shachaf , mea culpa
01:12:49 <zomg> franco00: at least if you want to use it in motions
01:12:52 <ivanm> and faster -/-> better
01:12:59 <ivanm> since that looks notoriously unstable
01:13:08 <Enigmagic> ivanm: at converting an Integer to a ByteString, and it works just fine and has unit tests.
01:13:09 <Enigmagic> :P
01:13:15 <Enigmagic> thanks for your concern
01:13:41 * ivanm starts looking up the number for the nice white men to take Enigmagic away
01:14:10 <merijn> Abusing internal implementation details for low level performance hacks is hardly a basis for saying IO is a function
01:14:28 <merijn> That's like saying Haskell values are not immutable since I can use the FFI interface to change arbitrary memory locations
01:14:33 <Enigmagic> merijn: are you saying IO is not a newtype wrapper around a function?
01:14:46 <ivanm> Enigmagic: by the specification it isn't
01:14:48 <merijn> Enigmagic: No, I'm saying that implementation details are irrelevant for semantics
01:14:51 <ivanm> by implementation in GHC it currently is
01:15:00 <ivanm> but newtype wrapper around a function /= a function
01:15:02 <merijn> Enigmagic: One can implement IO without a newtype wrapper
01:15:06 <Enigmagic> ok, so why do you use the Prelude?
01:15:21 <mauke> because there's no way I can't
01:15:24 <ivanm> Enigmagic: huh? what's the prelude got to do with it?
01:15:31 <ivanm> mauke: you could use an alternate one...
01:15:35 * merijn rings the troll bell
01:15:53 <ivanm> merijn: owww!!! no need to ring it so loudly! :p
01:15:57 <Enigmagic> ivanm: i dunno, i guess because they do the same thing in the Prelude and nobody complains about that?
01:16:07 <mauke> Enigmagic: again, implementation details
01:16:15 <Enigmagic> *shrug*
01:16:17 <ivanm> Enigmagic: do what, that kind of hackery?
01:16:20 <ivanm> GHC does it internally
01:16:26 <ivanm> if they change it, they can fix it
01:16:41 <ivanm> s/it/the implementation/
01:16:49 <Enigmagic> yah, and if they change it i'll fix my code too, big deal
01:17:15 <mauke> if IO was a function, you wouldn't have to change anything
01:17:37 <mauke> but IO is currently a newtype wrapper around a function in ghc
01:18:37 <Enigmagic> yep, this is true.
01:19:07 <ivanm> and that specific implementation is only in GHC, so when UHC takes over Real Soon Now you'll have problems! :p
01:19:51 <Enigmagic> that way i can run all my code in Chrome :D
01:20:55 <quicksilver> I'm happy to say that IO is not a newtype wrapper around a function.
01:21:06 <quicksilver> IO is not a newtype wrapper around a function. Not even in GHC.
01:21:13 <Enigmagic> what is it?
01:21:24 <quicksilver> In GHC, IO is a newtype wrapper around an internal thing which is definitely not a function, since its' not pure.
01:21:28 <quicksilver> it's not even haskell.
01:21:29 <ivanm> a Monad, durrrrr :p
01:21:38 <quicksilver> it's another language which GHC uses to implement haskell.
01:21:39 <ivanm> quicksilver: heh, good point
01:21:50 <mauke> what, you mean there is no RealWorld?
01:22:05 <ivanm> mauke: only if you take the red pill
01:22:05 <merijn> mauke: Sure there is, I just looked outside and it's right there...
01:22:11 <ivanm> merijn: LIES!
01:22:16 <MostAwesomeDude> I just found out there's no such thing as the RealWorld.
01:22:29 <merijn> Office with windows, aren't I fancy? :>
01:23:46 <mauke> sounds like microsoft
01:24:12 <merijn> I wonder if they let you use macbook's at MSR...
01:24:34 <Enigmagic> yes they do
01:24:47 <Enigmagic> lots of people have them at MS and MSR
01:24:57 <mauke> inb4 ballmer
01:25:40 <cheater__> is msr this oppressive regime kind of thing
01:25:56 <cheater__> or is it actually remote from any microsoft related bullshit
01:26:16 <ivanm> cheater__: pretty much the latter
01:26:25 <cheater__> is this first hand experience ivanm
01:26:35 <merijn> cheater__: Simon Marlow and SPJ work for MSR
01:26:40 <cheater__> so what
01:26:45 <ivanm> cheater__: no, but what I've been told by others
01:26:50 <cheater__> jesus worked in transport
01:26:56 <merijn> cheater__: They also do some really nice deep research into MSR
01:26:57 <cheater__> he hauled crosses
01:26:58 <merijn> eh
01:26:59 <merijn> PLT
01:27:17 <merijn> Yes, MSR researches MSR!
01:27:33 <mauke> meta-msr
01:27:36 <cheater__> i don't think the fact of one or two people working somewhere makes the whole place great to be at
01:27:43 <Enigmagic> quicksilver: what's your read on this ? https://github.com/ghc/packages-ghc-prim/blob/master/GHC/Types.hs#L76
01:28:05 <cheater__> i worked at tens of companies where there were fascinating individuals, probably more so than the people you named, but the places still sucked for the rest
01:28:32 <merijn> MSR seems one of the more interesting places to be
01:28:44 <cheater__> why
01:28:50 <cheater__> people say the same thing about google
01:28:55 <cheater__> i went to talk to some google employees
01:29:12 <merijn> cheater__: MSR does some pretty fundamental hardcore theoretical CS
01:29:14 <cheater__> it was during a job fair kind of thing
01:29:21 <cheater__> google does some pretty hardcore internet
01:29:27 <mauke> so do I
01:29:28 <ivanm> internet /= CS research
01:29:33 <cheater__> or is it
01:29:43 <ivanm> mauke: oh, you like the hardcore stuff on the internet? :p
01:29:45 <Kaidelong> MSR also works on practical, successful, popular things, like haskell, don't they?
01:30:03 <cheater__> besides does the thing which a company works on actually make it less eligible towards being oppressive
01:30:07 <Enigmagic> Kaidelong: yeah and they also do IP licensing
01:30:11 <cheater__> and disheartening
01:30:18 <merijn> On related note
01:30:24 <ivanm> Kaidelong: I think technically they're working on GHC as a compiler, etc. and language design rather than Haskell per se
01:30:37 <merijn> F* has to be the least Googlable programming language name
01:30:52 <Kaidelong> that's the new dependently typed programming language from MSR right?
01:30:53 <cheater__> i went to that google fair and what i found was that there was one or two guys doing recruitment *watching over* the other employees so that they don't say anything bad. then those people secretly told me i should run as fast as i could.
01:30:59 <merijn> Kaidelong: Yeah
01:31:00 <Kaidelong> that somehow manages to live inside of .NET
01:31:00 <cheater__> i saw people so sleep deprived they lost weight.
01:31:10 <cheater__> other people who were certainly difficult to work with
01:31:15 <ivanm> merijn: I thought "go" was?
01:31:34 <Kaidelong> I think go was google's revamp of C
01:31:52 <Kaidelong> to put it extremely simply and inaccurately
01:31:56 <merijn> ivanm: Go actually gets me the programming language in the top 5 on google and DDG
01:32:03 <cheater__> i saw people glorifying dumb work, like this: "right so over in usa they do this cool new thing with the chrome engine. What we do here? we do.. uh, linux packages. it's ... cool."
01:32:03 <merijn> Kaidelong: He meant "least googlable name"
01:32:06 <quicksilver> Enigmagic: ist' not haskell.
01:32:08 <Kaidelong> oh
01:32:13 <cheater__> still, there were amazing people there.
01:32:22 <quicksilver> Enigmagic: it's an impure language which has a strong syntactic resemblence to haskell
01:32:32 <quicksilver> Enigmagic: which GHC uses as the highest level "backend" for haskell.
01:32:38 <ivanm> merijn: for me on google, the first is a TV channel, then the wiki page on the game, then a master card, and then an australian tourism site
01:32:44 <Kaidelong> what about M
01:32:46 <Enigmagic> quicksilver: so it's haskell but written in GHC haskell instead of standard haskell?
01:32:46 <Kaidelong> or J
01:32:55 <ivanm> wait, that's 4: no. 5 is the IMDB page for a 1999 movie called Go
01:33:02 <quicksilver> Enigmagic: not it's not haskell at all.
01:33:07 <quicksilver> Enigmagic: it's a really very different language.
01:33:13 <cheater__> you just google for "google go" or "k&r c"
01:33:14 <quicksilver> Enigmagic: haskell is pure and this is one of its important
01:33:19 <cheater__> and there you go, googlable
01:33:20 <quicksilver> properties. That language is impure.
01:33:29 <Enigmagic> quicksilver: how can the compiler tell the difference between the two? it's a .hs file and doesn't have any weird language pragmas up top
01:33:29 <quicksilver> it *resembles* haskell syntactically.
01:33:33 <quicksilver> and it contains haskell
01:33:54 <quicksilver> Enigmagic: it's an implementation trick GHC uses, basically.
01:33:55 <merijn> ivanm: I get "go.com, Go (wiki page), GO transist, Go.com.mt, golang.org"
01:34:14 <ivanm> merijn: currently on the 5th page of google's search results searching for "go", and no mention of the language...
01:34:21 <ivanm> do you have web history enabled? I don't...
01:34:23 <quicksilver> it primarily compiles that language (which contains haskell as a subset) and it has the property (hopefully, if there are no bugs) that the semantics it assigns to the haskell subset are, well, the right ones.
01:34:40 <merijn> ivanm: Maybe?
01:34:47 <ivanm> heh
01:34:49 <ivanm> that could be why
01:34:59 <ivanm> or else it's the fact that I'm on the google australia site
01:35:13 <merijn> ivanm: This is the reason I've mostly switched to DDG these days
01:35:14 <Enigmagic> quicksilver: ok
01:35:34 <ivanm> merijn: what, to avoid web history or that the search results seem more relevant?
01:35:35 <Enigmagic> sounds reasonable
01:35:36 <merijn> ivanm: Second top disambiguation entry for "go" is "Go (programming language)"
01:35:50 <ivanm> I disabled web history ages ago, and I've tried DDG and didn't like what it came up with
01:35:54 <merijn> ivanm: No, helpful disambiguation of terms
01:36:38 <merijn> ivanm: It depends on which queries, for some more obscure technical queries Google has better mailing list coverage. But for quick high level searches like webpages you forgot the URL of it is much better than Google in my experience
01:37:06 <merijn> Good enough to be the default for about 80-90% of my searches. The remainder I switch to Google for if it doesn't turn up anything
01:37:24 <quicksilver> I used DDG for a couple of months
01:37:36 <quicksilver> I came to the conclusion it's awesome, but it's slow, and bad at searching.
01:37:44 <Enigmagic> quicksilver: so i'm guessing has to materialize the RealWorld variable as necessary then when a function takes it as a parameter?
01:37:46 <quicksilver> I just taught myself to put !g before every search I made, in the end.
01:37:57 <ivanm> quicksilver: heh
01:38:00 <quicksilver> Enigmagic: the realworld is just a trick to make you string the functions together.
01:38:11 <opqdonut> yeah the slowness is a big issue
01:38:13 <merijn> quicksilver: Really?Loads nearly instantly for me
01:38:14 <quicksilver> it's not the only possible trick, but it's good enough
01:38:19 <ivanm> I went through every single option I could find in google and disabled any tracking stuff, etc.
01:38:20 <flux> quicksilver, same, except speed wasn't really an aissue for me
01:38:35 <merijn> quicksilver: How long ago was this? They've gotten more money in popularity recently so they've scaled up quite a bit
01:38:45 <quicksilver> this year, certainly
01:38:47 <mauke> DDG is still terrible
01:38:50 <merijn> Odd
01:38:51 <ivanm> realistically, one of google's biggest selling points atm is it's web index
01:38:53 <mauke> worst search engine I've ever seen
01:39:09 <ivanm> mauke: I think I've seen worse
01:39:16 <merijn> mauke: Altavista?
01:39:18 <ivanm> admittedly, can't recall which ones off the top of my head :p
01:39:46 <merijn> Google and DDG load equally fast (or at least a speed difference that is indistinguishable to me)
01:39:47 <mauke> merijn: no, altavista looks much nicer
01:40:15 <Enigmagic> quicksilver: well i'm mostly curious if it actually compiles it away most of the time or if it takes up a register at runtime
01:43:29 <Enigmagic> suppose i could just check but it seems like would need to take up a register for regular calls to make the ABI sane
01:48:32 <dncr> is there a way to write "C a" in type signatures to mean "Cantana Char String () a"
01:49:07 <merijn> type C a = Cantana Char String () a
01:49:37 <tdammers> google started to lose me when they helpfully tried to guess my language based on my IP
01:49:51 <dncr> hm.. Not in scope: type constructor or class `Cantana'
01:49:52 <merijn> tdammers: You can turn that off, but I forgot how I did it
01:50:02 <tdammers> merijn: yes, but it's a pain
01:50:11 <tdammers> that's what the Accept-Language header is for
01:50:43 <gadtfly> Would "number = read <$> (many $ choice [digit, char '.'])" be a sound way to parse a simple decimal number in Parsec?
01:51:01 <dncr> oh i can't spell
01:51:03 <tdammers> all the major browsers support it, and you'd always get the google version you ask for
01:51:06 * dncr runs away
01:52:29 <mroman> gadtfly: Wouldn't that allow 3.1.4.1.5.9?
01:52:33 <llano> how to flush a textView buffer? I am using GTK2HS
01:52:57 <gadtfly> Probably.  What would be a better way then?
01:53:21 <llano> it appears only the last seeting  of a textBuffer can be shown
01:53:33 <tdammers> also, ddg's bang-tags are awesome
01:53:50 <gadtfly> Seems like it would be a common enough case, but I haven't found anything yet.
01:53:53 <mroman> many1 digit; char '.'; many1 digit;
01:54:45 <merijn> mroman: Scientific notation? (not sure whether you want to support that for decimals)
01:54:52 <mroman> and another one for integers.
01:55:03 <mroman> or make the char '.'; many1 digit; optional
01:55:09 <merijn> mroman: Also, yours accepts numbers starting with 0, which may not be what you want
01:56:01 <mroman> Agreed.
01:56:38 <merijn> In regex you probably want something like "(0|[1-9][0-9]*)(.[0-9]*)?" (lacks support for scientific notation etc)
01:56:45 <merijn> Parsing numbers is fairly non-trivial
01:57:10 <digitteknohippie> hi, quick q.  can i have variables n lists n stuff read from files?  like, instead of some static variable in my code, i'd have some file with a word or a list or whatever fit for the task, and it would read that with just a simple directory location in the code?  or does it need something fancy?
01:57:13 <gadtfly> The guess I started with /seemed/ to work for my limited current purpose, but it's part of a slightly larger parser that has been stumping me terribly so I wanted to rule it out as a problem.
01:58:07 <mroman> If you don't want leading zeroes you could use noneOf "0"
01:58:07 <gadtfly> No scientific notation.  Just want to capture 2, or 3.5.
01:58:51 <merijn> Then I think my regex captures everything, of course it accepts any digit, even those to big to represent
02:00:28 <pozic> How can I load any file name into ghci, not just those that end in .hs/.lhs?
02:00:38 <gadtfly> It just seems like such a common thing for a parser to need to capture.  The fact that I haven't found any canonical way to do it with the widely-preached parsing staple of Haskell, is frustrating.
02:02:05 <mauke> /^[+-]?(?=\.?\d)\d*\.?\d*(?:e[+-]?\d+)?\z/i
02:02:19 <mauke> here's a regex. translation to parsec left as an exercise for the reader
02:02:26 <gadtfly> Oh dear god
02:02:58 <mauke> slightly simplified: [+-]?(?=\.?\d)\d*\.?\d*(?:[eE][+-]?\d+)?
02:03:08 <Enigmagic> i just do it in C
02:03:09 <pozic> I bet formal verification for that one is easy.
02:03:25 <gadtfly> Hmm... it looks like there's a "decimal" thing in Text.Parsec.Token.  Doesn anybody know a good tutorial on how to use Text.Parsec.Token?
02:03:25 <pozic> gadtfly: I think everyone has written their own version.
02:05:12 <mroman> on the cheap: http://codepad.org/FkxD5udA <- parses Floats/Integers using try
02:05:32 <mroman> optional discards the result.
02:05:33 <cheater__> "gadtfly"... nice nick
02:05:56 <gadtfly> mroman: thanks... what is this Value type?
02:06:14 <mroman> data Value = ValInt Int | ValFloat Float
02:06:33 <gadtfly> cheater: thanks... I feel like I'm wasting it, being a total noob and all
02:06:54 <gadtfly> What is walint?
02:06:59 <mroman> ValInt?
02:07:00 <gadtfly> *ValInt etc?
02:07:08 <mroman> A type constructor.
02:07:13 <gadtfly> Oh yeah
02:07:31 <pozic> mroman: no, it isn't.
02:07:32 <gadtfly> Ah, I get your thing now.  Thanks
02:07:46 <pozic> mroman: ValInt is a constructor.
02:07:46 <mroman> A data constructor, then?
02:08:04 <mroman> I'm not exactly sure in terminology.
02:08:12 <pozic> The type constructor is the thing that builds types.
02:08:21 <pozic> In this case it is a trivial type constructor.
02:08:25 <pozic> Value
02:09:23 <pozic> gadtfly: if you want to learn Haskell, read the same books that major universities use.
02:09:28 <mroman> Value is the type constructor?
02:09:48 <pozic> mroman: yes
02:10:01 <mroman> and ValInt would be the data constructor
02:10:04 <pozic> Usually these things take arguments.
02:10:20 <pozic> So, it could be ValueWithArg::* -> *
02:10:32 <pozic> The *'s are types.
02:11:18 <pozic> This way you can also have type-constructors which themselves take type-constructors as their arguments.
02:11:54 <pozic> Then you would get data Foo (a::* -> *) = ...
02:12:07 <pozic> I don't use that a lot myself, so I could be wrong on it, but I understand its purpose.
02:12:23 <pozic> Often those things can be derived too.
02:12:23 <mroman> Type magic is yet beyond my horizon.
02:13:43 <mroman> Especially generic deriving and such.
02:14:34 <franco00> I am using Monad and fail to pass errors in my function. One question: in one of my function I call myOtherFun, which can fail. How to know wheter it failed or not? I thought of checking via Just / Nothing, but I can't be sure in advance the chosen monad will be a Maybe one!
02:14:49 <franco00> type sig is:  evaluateTextPart :: (Monad m) => GameVars -> TextPart -> m String
02:14:59 <ivanm> franco00: use a MonadPlus?
02:15:13 <ivanm> @src MonadPlus
02:15:13 <lambdabot> Source not found. My brain just exploded
02:15:15 <ivanm> bah
02:15:18 <ivanm> @hoogle MonadPlus
02:15:18 <lambdabot> Control.Monad class Monad m => MonadPlus m
02:15:25 <franco00> is there a (check if there is an error now) functi- ivanm , I must admit you caught me a bit off guard...
02:15:47 <franco00> I know monadplus is monoid + monad... but how will that help me?
02:15:57 <ivanm> it isn't *quite* monoid
02:16:08 <ivanm> but MonadPlus specifies Monads for which fail /= error
02:16:24 <Enigmagic> franco00: some Monads throw exceptions (like IO)..
02:16:26 <ivanm> oh, it doesn't actually let you specify whether it's the error or not
02:16:36 <ivanm> franco00: not sure if what you want is possible actually
02:16:48 <ivanm> unless you can use mplus in such a way to guarantee it
02:17:01 <ivanm> franco00: better idea: don't use fail in the first place!
02:17:15 <ivanm> explicitly use Maybe or Either (wrapped in your Monad if necessary)
02:17:23 <Tinned_Tuna> I hate fail.
02:17:44 <ivanm> the only valid time I know of to use fail is with a parsing library
02:17:47 <franco00> I will rephrase: if the operation fails, I would like to execute if (there is some LEft, or Nothing, or the thing failed), fail "another, more sensible error"
02:18:21 <franco00> is that possible? more in general, what is the One True Approach to error handling in haskell? ;)
02:18:32 <ivanm> franco00: specify an actual type rather than being a generic Monad, or use an explicit Maybe/Either in there
02:18:40 <merijn> franco00: What sort of errors?
02:18:48 <ivanm> franco00: use Maybe/Either if you want to catch it in pure code
02:18:57 <Saizan> ivanm: or use MonadError
02:19:06 <franco00> merijn: good question. Things from which you can recover, non IO.
02:19:06 <Saizan> franco00: or use MonadError
02:19:15 <ivanm> if catching it in IO is OK, there's Control.Exception
02:19:17 <ivanm> Saizan: oh, right
02:19:18 <merijn> You could also use Control.Exception if you don't insist on being pure
02:19:25 <ivanm> didn't ezyang do a blog post on this last year?
02:20:20 <ivanm> http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
02:20:38 <franco00> now, that is interesting
02:20:41 <merijn> franco00: For game errors you could also (theoretically) avoid some classes of errors via STM rather than error checking
02:22:25 <franco00> that's a great article
02:24:56 <t7> is haskell webscale 3.0 yet?
02:25:58 <ivanm> t7: I think we've decided to skip 3.0 and go straight to 4.2
02:29:12 <t7> in the clouds?
02:29:29 <ivanm> forget clouds!
02:29:32 <ivanm> the *aether*!!!!
02:29:42 <albel727> hehehe
02:39:30 <osager> can i use filter on IO[FileNames] ? i want to filter the resutls returned by getDirectoryContents
02:39:56 <osager> and i think there should be a way without going to pure code and back again
02:40:08 <merijn> osager: Use do notation, >>= or fmap?
02:40:31 <osager> i did use >>=
02:40:42 <osager> problem is what follows the >>=
02:40:45 <osager> i can't use filter
02:40:56 <shachaf> Sure you can.
02:40:58 <osager> i tried filterM
02:41:00 <merijn> osager: Oh, you want fmap then
02:41:03 <merijn> :t fmap
02:41:03 <shachaf> filter blah <$> getDirectoryContents "foo" -- would work
02:41:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:41:10 <shachaf> But you should be able to figure out how to do it without fmap
02:41:30 <osager> i dont know about the <$>
02:41:38 <osager> let me check
02:41:50 <shachaf> osager: You don't need to know about the <$>
02:41:56 <merijn> osager: Alternatively, you can do "getDirectoryContents >>= return . filter f"
02:42:04 <shachaf> Figure out how to do it using just the operators you know. It's a good exercise.
02:42:11 <shachaf> ...Even if people in IRC will just give you the answer.
02:42:34 <osager> ok. whenever i see a new operator i have an urge to learn it
02:42:38 <merijn> shachaf: Whoops? :p
02:42:45 <osager> thank merijn i think that would work
02:42:53 <osager> with the return statement
02:44:43 <osager> hi merijn
02:45:07 <osager> what getDirectoryContents >>=  passes on is IO[Filenames]
02:45:17 <osager> why can return.filter accepts it
02:45:19 <osager> ?
02:45:35 <osager> because filter accepts [filenames]
02:45:42 <osager> not IO [FileNames]
02:45:58 <shachaf> osager: Because of (>>=)
02:46:05 <shachaf> osager: You should probably read an introduction to IO in Haskell.
02:46:06 <merijn> That's not what >>= does
02:46:11 <merijn> :t (>>=)
02:46:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:46:19 <shachaf> @google introduction to IO in Haskell
02:46:20 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
02:46:21 <lambdabot> Title: Introduction to IO - HaskellWiki
02:46:35 <osager> i read the chapter on realworld haskell
02:46:47 <osager> but apparently i didnt understand
02:46:56 <shachaf> You should read that link.
02:47:05 <shachaf> Or the FAQ; it has entries about this.
02:47:08 <osager> i thought >>= passes on things in the monad domain
02:47:15 <merijn> osager: Did you read Learn You a Haskell? I think it's a better/more fundamental explanation of monads and IO
02:47:16 <osager> ok
02:48:15 <osager> actually i've read the fundamentals but when i start practising, there's all sorts of troubles
02:48:22 <t7> http://i.imgur.com/VULna.png
02:48:50 <t7> that is a great troll
02:49:00 <merijn> t7: I agree though
02:49:10 <merijn> The more I grok the IO monad, the more I think it is sheer brilliance
02:49:22 <merijn> Probably not the best feature, but still awesome
02:49:33 <merijn> osager: What is the type of getDirectoryContents? What is the type of "return . filter f"?
02:50:33 * hackagebot equivalence 0.2.3 - Maintaining an equivalence relation implemented as union-find using STT.  http://hackage.haskell.org/package/equivalence-0.2.3 (PatrickBahr)
02:50:33 <osager> getD takes a FileName and returns IO[FileNames]
02:50:52 <osager> filter can take [Filenames]
02:50:58 <osager> but not IO [FileNames]
02:51:20 <osager> and return wrap the [FileNames] back to IO
02:51:27 <merijn> No
02:51:43 <merijn> Actually, yes
02:51:45 <merijn> My bad
02:52:13 <osager> what >>= passes on is still IO [FileNames]
02:52:14 <osager> i think
02:52:23 <merijn> So, "filter f :: [FileNames] -> [FileNames]" and "return . filter f :: [FileNames] -> IO [FileNames]", right?
02:52:33 <osager> yes
02:53:01 <ChristianS> osager: >>= passes on [FileNames] (in the context of the IO monad)
02:53:17 <merijn> osager: What's going on is this "getDirectoryContents" is a computation that (when run) produces a list of FileNames
02:53:53 <merijn> osager: "return . filter f" is a function that (when given a list of FileNames) returns a computation that (when run) returns a list of FileNames
02:54:11 <osager> i understand all that
02:54:28 <osager> but i dont understand why filter f can take IO[FileNames]
02:54:45 <osager> i thought it should be just [Filenames]
02:55:18 <merijn> "(>>=) :: m a -> (a -> m b) -> m b", in other words, >>= takes a computation that produces an "a", a function that takes an "a" and returns a computation that produces a "b", then returns a single new computation that returns a "b"
02:55:34 * hackagebot loch-th 0.2 - Support for precise error locations in source files (Template Haskell version)  http://hackage.haskell.org/package/loch-th-0.2 (TomasJanousek)
02:55:40 <merijn> You are basically building bigger computations out of smaller computational legos.
02:55:56 <merijn> osager: Do you have experience with other languages? Which ones?
02:56:11 <osager> python,c etc
02:56:20 <merijn> osager: Ah, you know python's twisted?
02:56:21 <osager> but i'm not professional
02:56:44 <osager> no, but i think i must have misunderstood the meaning of >>=
02:56:47 <merijn> (or event driven programming?)
02:57:00 <osager> i will dig on this operator a bit more before coming here
02:57:07 <osager> thanks guys
02:57:55 <Jafet> Python's twisted.
02:58:00 <quicksilver> Enigmagic: it doesn't need a register, no.
02:58:14 <quicksilver> Enigmagic: it's not a real thing. There is no need to generate code for it.
02:58:32 <shergill> are there any environment variables which can affect ghc compilation?
02:59:02 <cheater__> merijn: how is twisted similar to haskell monads
02:59:09 <merijn> osager: You can think of "IO a" as an event that produces an "a" (at some point) and "foo >>= f" as installing a callback that (turns the foo event that produces an a) into a new event that produces a "b"
02:59:11 <cheater__> is that another one of those "monads are like" thing?
02:59:17 <ChristianS> osager: actually  getDirectoryContents dirname >>= filter myfunc  is the de-sugared version of do files <- getDirectoryContents dirname; filter myfunc files
02:59:34 <merijn> cheater__: No, I was going to say that ">>=" in IO can be though of in terms of callbacks/deferred's
02:59:42 <shachaf> osager: Did you read the link I linked to?
02:59:50 <cheater__> i don't think that's a good idea
03:00:07 <cheater__> @type (>>=)
03:00:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:00:11 <osager> not yet
03:00:17 <merijn> cheater__: Why not? It's a pretty solid analogy for IO (not for monads in general)
03:00:18 <osager> i'm rereading realworld haskell
03:00:24 <ChristianS> (oops, i guess i missed some { ... } in the do block -- in real life, you use layout instead)
03:00:29 <merijn> osager: I would recommend LYAH instead
03:00:42 <merijn> I thought it was a better intro text (ymmv, etc)
03:00:45 <merijn> @where lyah
03:00:45 <lambdabot> http://www.learnyouahaskell.com/
03:00:47 <osager> i tried that book but i lost patience with it
03:00:48 <shachaf> osager: You should read it. Otherwise people are just going to type in the same information into IRC, line by line.
03:01:09 <cheater__> i thought the community had already learnt that monad analogies never work out
03:01:11 <osager> OK
03:01:13 <cheater__> can't we all give it a rest
03:01:14 <merijn> osager: Around where? The later chapters ramp up rather nicely, I though
03:01:18 <Saizan> merijn, cheater__: (>>=) is an higher order function, and "taking a callback" is how that's described in many imperative langs
03:01:31 <merijn> cheater__: I wasn't making a monad analogy
03:01:34 <Saizan> so it's not even a monad analogy
03:01:35 <merijn> I was making an IO analogy
03:01:54 <osager> merijn, around the whole thing. what i need is a distilled version of the book
03:01:55 <cheater__> gray area i suppose
03:02:00 <osager> just explain the bare bones
03:02:15 <cheater__> osager: i have some short and to-the-point tutorials on my blog, maybe check them out
03:02:28 <merijn> osager: That's a shame, because when I read RWH I ran into some problems because it glossed over some fundamental details
03:02:36 <cheater__> they're for beginners
03:02:37 <osager> something like the standford course on haskell
03:02:55 <osager> it's very compact and saves a lot of time
03:03:09 <osager> except that the standford course is way too difficult
03:03:12 <cheater__> see here: http://cheater.posterous.com/
03:03:18 <osager> thhanks cheater___
03:03:22 <osager> i'll take a look
03:05:59 <osager> just for everyone's reference
03:06:00 <osager> http://www.scs.stanford.edu/11au-cs240h/notes/
03:06:04 <osager> anyway
03:07:02 <cheater__> hey that's a nice link
03:07:03 <cheater__> thanks
03:09:18 <osager> no problem. i plan to read the whole lecture after i get my hands warmer with haskell
03:09:30 <osager> because it explains really the internals of the language
03:09:41 <osager> still too difficult for me
03:11:42 <Saizan> that course seems to spend a lot of time to the little quirks and not enough on fundamental aspects like the use of higher order functions and typeclasses
03:11:59 <Saizan> s/to the/on the/
03:13:01 <osager> maybe, the they show and explain some c implementations under the hood which is very enlighting
03:13:12 <osager> enlightening
03:14:27 <Saizan> yeah, that helps with lazy eval
03:15:06 <merijn> Saizan: The course doesn't seem to be aimed at teaching haskell, though. Since it refers to the haskell tutorial and other things
03:15:23 <t7> does a ghc binary start evaluating if a thunk gets too large?
03:15:46 <Saizan> t7: no
03:17:56 <t7> i guess theres no way to tell if evaluation would reduce anything
03:18:13 <quicksilver> it's very hard, certainly
03:18:14 <tdammers> it would also break the semantics
03:18:23 <quicksilver> lots of papers have been written about speculative evaluation.
03:18:39 <quicksilver> tdammers: it wouldn't if it was careful to avoid non-termination.
03:19:00 <tdammers> yeah, with speculative evaluation it could work, theoretically
03:19:05 <merijn> quicksilver: Good idea, now we just have to check that the computation terminates :>
03:19:18 <quicksilver> merijn: no you don't, you just have to limit the amount of work you do.
03:19:32 <merijn> Ah, true
03:19:44 <tdammers> if it takes too long, fall back to fully lazy
03:19:47 <merijn> And hope things get better in that time, no?
03:20:24 <quicksilver> "fully lazy" not quite the right term.
03:20:33 <quicksilver> it's more like "fully demand-driven"
03:24:15 <hiptobecubic> I don't understand how random number generators work in Haskell
03:24:18 <tdammers> ok then, "fall back to the current behavior" ;-)
03:24:31 <tdammers> hiptobecubic: just like in any other programming language
03:24:43 <hiptobecubic> you have to make a Vector with your seed in it?
03:24:44 <tdammers> only the way state is handled and maintained is different
03:25:09 <hiptobecubic> tdammers, i understand the 'functional' aspect of how it works, just not the api :)
03:25:28 <ivanm> hiptobecubic: which particular PRNG are you looking at?
03:25:37 <ivanm> because AFAIK none of them require a Vector...
03:26:28 <int-e> oh, I should try and implement a mersenne twister using vector.
03:28:23 <hiptobecubic> ivanm, Well what's the one that everyone normally uses? This is the first time i've tried doing anything with them in Haskell.
03:28:38 <ivanm> System.Random is the default one, but slow
03:28:40 <hiptobecubic> twister would be nice, but anything is probably ok for now, as long as it isn't based on randu
03:28:47 <ivanm> I believe mwc-random is the one most often touted/used nowadays
03:29:06 <t7> is uhc still being developed ?
03:29:12 <hiptobecubic> ivanm, yeah that's what i'm looking at. because Statistics.Distribution needs a Gen, which apparently comes from there?
03:29:12 <ivanm> mersenne twister doesn't really fit the functional mold to well, and the pure variant is much slower than the impure one
03:29:16 <ivanm> t7: I believe so
03:29:27 <int-e> (to have a pure Haskell counterpart to http://hackage.haskell.org/package/mersenne-random-pure64 )
03:29:33 <ivanm> hiptobecubic: I would guess that's from mwc-random, as the statistics library uses it
03:29:41 <tdammers> you could take a mt implementation in C and make haskell bindings...
03:29:50 <ivanm> tdammers: we have that
03:30:03 <tdammers> right
03:30:25 <hiptobecubic> well their example doesn't actually work
03:30:36 <hiptobecubic> intialize (singleton 42)
03:31:14 <hiptobecubic> Well it does, but it's underspecified. I need to restrict the type somehow
03:31:33 <hiptobecubic> :t initialize (singleton 42)
03:31:33 <hiptobecubic> initialize (singleton 42)
03:31:33 <hiptobecubic>   :: Control.Monad.Primitive.PrimMonad m =>
03:31:33 <hiptobecubic>      m (Gen (Control.Monad.Primitive.PrimState m))
03:31:34 <lambdabot> Not in scope: `initialize'
03:31:34 <lambdabot> Not in scope: `singleton'
03:31:44 <int-e> ah mwc-random uses vector :)
03:31:44 <Na-Fiann> Hi, how do I install data.hashmap.strict? I have cabal, but no idea what it is called in cabal...
03:31:44 <lambdabot> Na-Fiann: You have 1 new message. '/msg lambdabot @messages' to read it.
03:31:52 <ivanm> I believe you want the ST monad
03:32:10 <hiptobecubic> Na-Fiann, "cabal list hashmap" or something similar
03:32:14 <ivanm> Na-Fiann: according to hayoo, there's no such module :s
03:32:48 <ivanm> Na-Fiann: oh, unordered-containers is what you want
03:32:54 * ivanm wonders why hayoo didn't find it
03:34:22 <Na-Fiann> thanks :)
03:34:24 <Na-Fiann> got it
03:36:24 <nomeata> Hi. Is there a way to force gargabe collection from within the Haskell program?
03:36:37 <hiptobecubic> ivanm, I am flabbergasted
03:36:45 <ivanm> nomeata: I seem to recall seeing a GHC.<something> module with something like that
03:36:48 <ivanm> hiptobecubic: about?
03:36:58 <nomeata> ivanm: so do I, but I can’t find it...
03:37:49 <hiptobecubic> ivanm, how this thing works :)
03:38:23 <Jafet> @hoogle performGC
03:38:23 <lambdabot> System.Mem performGC :: IO ()
03:38:29 <Saizan> hiptobecubic: look at the instances for PrimMonad
03:38:39 <Saizan> hiptobecubic: you'll find at least IO and ST
03:38:44 <nomeata> merci
03:38:50 <ivanm> there's GHC.Stats as well
03:38:58 <ivanm> in case you want info about what it's doing
03:39:45 <nomeata> ivanm: no, performGC is fine, I just want to get rid of all BLACKHOLEs
03:40:30 <Jafet> I doubt performGC magically solves multiprocessing problems.
03:40:41 <Jafet> Perhaps it magically solves yours.
03:41:35 <nomeata> Jafet: I’m not multiprocessing, but rather learning more about GHC’s RTS data representation
03:42:35 <Enigmagic> nomeata: what do you plan on replacing the blackholes with?
03:43:16 <nomeata> Enigmagic: BLACKHOLES stay around until the GC runs, and just for simplicity, I’d like them to be removed by the GC before looking at the heap.
03:44:09 <hiptobecubic> Saizan, so I need to do this in the State monad?
03:44:31 <Saizan> hiptobecubic: ST is not the State monad
03:44:39 <Enigmagic> nomeata: there will still be some leftover iirc as they're used during thunk evaluation
03:44:44 <hiptobecubic> Saizan, oh. Good to knwo
03:45:17 <hiptobecubic> What i'm really trying to do here, is generate an infinite list of standard normal variates
03:45:28 <hiptobecubic> But this is tricky :)
03:45:30 <nomeata> Enigmagic: yes, but in the case I am looking at, I am forcing the evaluation of the expression before, so the blackhole will be replaced.
03:46:53 <Saizan> hiptobecubic: an infinite list is a bit tricky with mwc-random, maybe you could stick with System.Random for now
03:47:01 <stj> are getter functions (in record syntax) real functions or GHC is smart enough to optimize them?
03:47:23 <Enigmagic> nomeata: ah right on
03:47:25 <mauke> what do you mean by "real functions"?
03:47:37 <ivanm> mauke: apply to real numbers? :p
03:47:42 <hiptobecubic> Saizan, ok.
03:48:32 <ivanm> e.g. sin, sqrt
03:48:48 <mauke> > sqrt (0 :+ 1)
03:48:49 <lambdabot>   0.7071067811865476 :+ 0.7071067811865475
03:49:12 <Jafet> Surreal functions
03:49:16 <ivanm> mauke: I said they apply to real numbers, not they apply *only* to real numbers!
03:49:32 <ivanm> not that I'm being revisionist or anything...
03:49:41 <mauke> Jafet: http://en.wikipedia.org/wiki/Surreal_number
03:50:22 <stj> I'm curious if such a function is literally a function, that would mean simply getting a member within a data would be quite slow
03:50:50 <rostayob> stj: "quite slow"? why?
03:50:58 <mauke> stj: what do you mean by "literally a function"?
03:51:18 <rostayob> stj: you can see it as a function that matches on the constructor and extracts whatever element
03:51:22 <ivanm> stj: it's a function
03:51:26 <ivanm> doesn't mean it has to be slow though
03:51:29 <rostayob> I have no idea why you would think that that's slow
03:51:33 <ivanm> it's equivalent to pattern matching
03:52:22 <rostayob> and GHC probably inlines it anyways
03:52:33 <stj> um, all right :) I'm trying to get some insight into what assembly code GHC produces
03:52:38 <stj> that's cool
03:52:38 <mauke> hah
03:53:00 <stj> well, it's not "hah", 5x slower code is noticeable :)
03:53:12 <mauke> stj: are you going to answer any of my questions?
03:53:19 <ivanm> stj: you can always look at the core output if you really want to...
03:54:08 <Enigmagic> you can also look at the disassembly if you want to
03:54:27 <rostayob>  the "disassembly"?
03:54:32 <Enigmagic> assembly
03:54:41 <mauke> ghc -S
03:54:43 <stj> make: I'm sorry, literally a function is a part in assembly code that requres two jumps and pushing something onto stack
03:55:14 <mauke> stj: I don't know if ghc generates any functions
03:55:27 <rostayob> stj: so you're worrying that function calls are slowing your program down by a factor of 5.
03:55:31 <stj> I should better learn more about GHC and optimization in haskell
03:55:41 <t7> why would anyone not use cmake these days?
03:55:50 <ivanm> t7: because Cabal is nicer
03:55:53 <rostayob> stj: I really doubt that record functions are slowing anything down
03:55:55 <mauke> t7: because I'm writing irssi scripts
03:56:00 <ivanm> or, if you're not using Haskell, I've heard good things about waf, etc.
03:56:11 <ivanm> stj: sure you're not worrying about premature optimisation?
03:56:15 <Enigmagic> waf also works just fine with Haskell
03:56:27 <stj> ivanm: I am :)
03:56:29 <ivanm> Enigmagic: sure, but if you're using just Haskell, why not use Cabal?
03:56:30 <t7> uhc uas
03:56:42 <t7> uhc uses ./configure :(
03:57:01 <Enigmagic> ivanm: i have 300 modules across 60 packages to maintain
03:57:24 <ivanm> t7: so does GHC
03:57:39 <ivanm> Enigmagic: ... so ?
03:57:51 <ivanm> that's only 5 modules per package on average
03:57:55 <stj> anyone tried solving problems on project euler using haskell?
03:58:00 <Enigmagic> ivanm: how does Cabal work for rebuilding dependencies in order?
03:58:03 <ivanm> stj: a lot of people
03:58:25 <ivanm> Enigmagic: cabal-dev can do that, can't it?
03:58:34 <Enigmagic> in parallel?
03:58:47 <Enigmagic> it sorta can in serial but it's ghetto
03:58:55 <srhb> Can I define my own type that is only natural numbers?
03:59:11 <rostayob> srhb: of course
03:59:12 <mauke> yes, but no
03:59:19 <ivanm> Enigmagic: cabal-sort has that functionality now IIRC
03:59:20 <rostayob> mauke: ?
03:59:25 <ivanm> kfish added it
03:59:36 <ivanm> srhb: why not use an existing one?
03:59:39 <Enigmagic> ivanm: yes, i'm aware
04:00:08 <ivanm> I dunno if cabal-dev can use it or not though
04:00:24 <srhb> ivanm: I was curious about the pattern really. Creating a type that is restricted to a subset of an existing type's values.
04:00:29 <Enigmagic> ivanm: either way, i get faster builds with waf and i'll continue to use it until i finish our mostly written replacement for cabal-install that uses shake/cabal
04:00:36 <srhb> Natural numbers seemed like a good and simple example
04:00:38 <mauke> srhb: that's not how you do it
04:00:41 <srhb> Oh.
04:00:48 <danr> srhb: can you be more specific? you can come close by data Nat = Zero | Succ !Nat, but it will still contain bottom
04:00:56 <rostayob> mauke: what? why not?
04:00:56 <ivanm> srhb: if you must (which isn't that great an idea), newtype it, redefine all operations to wrap accordingly
04:01:07 <mauke> rostayob: because that's impossible
04:01:10 <rostayob> danr: every haskell type will contain bottom unfortunately :P
04:01:35 <danr> rostayob: true, maybe data Nat = Succ !Nat would do, and have bottom as zero :)
04:01:36 <rostayob> mauke: why? the classic Nat is defined how danr said
04:01:41 <ivanm> Enigmagic: rather than try and add support to cabal-{install,dev,sort,...} ?
04:01:47 <Saizan> rostayob: read again what srhb wrote
04:01:50 <ivanm> rostayob: Int# ? :p
04:01:51 <Enigmagic> ivanm: yes
04:02:05 <Saizan> rostayob: he wants something like restricting Int to the positive segment
04:02:15 <rostayob> Saizan: well but I didn't take it as "using int and restricting it to positives"
04:02:23 <rostayob> well maybe I misunderstood
04:02:27 <ivanm> which you can do, but is a bad idea
04:02:28 <mauke> rostayob: <srhb> ivanm: I was curious about the pattern really. Creating a type that is restricted to a subset of an existing type's values.
04:02:31 <danr> newtype Natural = Natural { unnatural :: Integer } -- invariant: the integer is >0
04:02:36 <ivanm> rostayob: " Creating a type that is restricted to a subset of an existing type's values."
04:02:59 <rostayob> ok, I thought he meant creating another type which is a subset
04:03:22 <srhb> That is probably what I meant, but I can see a lot of the terminology involved goes over my head.
04:04:16 <rostayob> danr: also, there is a useful divergin Nat, 'infinity = Succ infinity'
04:04:17 <Saizan> srhb: the point is that there isn't a specific feature to define a type like "Int but only >=0" though you can fake it with abstract types
04:04:27 <rostayob> *diverging
04:04:31 <srhb> Saizan: So the word is "abstract types"
04:05:27 <Saizan> srhb: yeah, by abstract type i mean one define in a module that doesn't export its constructors but only functions to manipulate it, so that those can maintain the invariants
04:05:33 <rostayob> @quote kmc curry
04:05:33 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
04:05:45 <danr> rostayob: yeah but fix Succ = _|_ if Succ is strict, hence Succ !Nat in the data type definition
04:05:54 <Saizan> srhb: *defined
04:05:57 <rostayob> danr: yep
04:07:57 <srhb> I think I need to find some literature on type level programming to understand this better. Is there any good literature out there?
04:08:11 <rostayob> srhb: yes.
04:08:14 <rostayob> @where TaPL
04:08:15 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
04:08:20 <mauke> but this isn't type-level programming
04:08:21 <rostayob> @where TTFP
04:08:22 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
04:08:26 <srhb> It's not?
04:08:27 <rostayob> srhb: but you don't need this
04:08:30 <mauke> no
04:08:33 <rostayob> to understand why you can't have the type you want :P
04:08:38 <rostayob> well
04:08:48 <srhb> Well, perhaps it will make me see why it is not what I need. :P
04:09:13 <rostayob> srhb: what do you need to do?
04:10:00 <srhb> On a higher level I think I was looking for some way to make sure that some functions I define operate on specifically non-negative numbers, by making sure every other integer is a type error.
04:10:07 <Saizan> srhb: well, you're right that this could be done with dependent types, but in Haskell that's not really feasible
04:10:09 <srhb> I suppose this is actually quite a lot simpler
04:10:32 <rostayob> if you need a "natural numbers" type it's pretty tricky in haskell. if you need them to be performant the only way is 'newtype Nat = Nat Integer; zero = Nat 0; succ (Nat n) = Nat (n + 1)'
04:11:46 <ivanm> rostayob: there are at least two implementations that i know of already though... Natural and Nat if I recall their names properly
04:11:57 <rostayob> srhb: you can do that with dependent types as Saizan says, since you can carry around proofs that numbers are >= 0
04:12:34 <srhb> Dependent types sound exciting. I'll look up that succ, since I haven't encountered it before and it appears to play a key role here.
04:13:05 <rostayob> srhb: in your case if you had an "integer" type, your type would be 'Σ ℕ (λ n → n ≥ 0)'
04:13:21 <rostayob> which means "I have an integer and a proof that it's greater than 0"
04:13:24 <rostayob> sorry
04:13:30 <mauke> srhb: succ x = x + 1
04:13:42 <srhb> mauke: Well that wasn't very exciting. :-)
04:13:46 <rostayob> that N sould be a Z
04:13:52 <Saizan> srhb: succ is short for successor :)
04:13:55 <slom> @help
04:13:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:13:57 <srhb> Makes sense.
04:14:19 <srhb> rostayob: Google tells me that what I want is the Omega language. Boo. :-)
04:14:39 <Saizan> srhb: or Agda, or Coq, or Idris
04:14:40 <rostayob> srhb: no, the Omega language wouldn't help iirc. what you want is Coq, or Agda
04:14:45 <srhb> Aha.
04:15:05 <rostayob> srhb: ah no sorry
04:15:06 <Saizan> Idris might be the most appropriate at this point
04:15:10 <slom> @pl \ m x -> m >>= (return . ($ x))
04:15:11 <lambdabot> flip (fmap . flip id)
04:15:12 <rostayob> the Omega language might do what you want :P
04:15:29 <srhb> At this point I'm not sure I want it anymore. :-)
04:16:10 <rostayob> srhb: types are cool!
04:17:00 <srhb> rostayob: Yes, and I was mostly kidding, I need to learn more about this for sure. Thanks for the guiding hand so far.
04:17:34 <rostayob> srhb: if you choose Agda, the people on #agda are very friendly
04:17:51 <rostayob> srhb: (btw, this won't make you a better programmer, but it's very interesting)
04:18:01 <srhb> rostayob: I have so much of Haskell to explore yet, and I want to reach a competency level first, but it's on my notes now, thanks. :-)
04:18:09 <merijn> This'll make you a worse programmer :p
04:18:13 <srhb> Haha.
04:18:28 <merijn> Because all you'll be doing is scribbling on whiteboards and papers and shout things ending in morphism
04:18:43 <rostayob> lol that's category theory
04:18:50 <merijn> pffft
04:19:23 <merijn> As if the set of people who learn Agda and category theory don't overlap for like 90% >.>
04:19:45 <merijn> (Actually, there's probably a lot of math people who learn the latter and not Agda, but shush)
04:19:53 <rostayob> merijn: I learn agda and I don't know a thing about CT
04:19:59 <slom> @pl \  x m -> m >>= (return . ($ x))
04:19:59 <lambdabot> fmap . flip id
04:20:11 <Na-Fiann> @ChristianS: Thanks for posting the annotations
04:20:11 <lambdabot> Unknown command, try @list
04:20:38 <rostayob> merijn: I mean they have points of contact but they're not that close, afaik (type theory and ct)
04:20:45 <merijn> I know
04:20:47 <rostayob> but I'm very ignorant so :P
04:20:52 <danr> I would definitely say that Agda can make you a better programmer.
04:20:55 <merijn> I at least know the basics of type theory :p
04:21:05 <merijn> Can't say the same for ct
04:21:13 <rostayob> danr: how so?
04:21:23 <rostayob> maybe the structural recursion stuff
04:21:33 <merijn> Whenever I get uppity I just google an arbitrary PLT paper and am humbled again >.>
04:21:36 <rostayob> but dependent types... I'm not sure
04:22:44 <ChristianS> Na-Fiann: no problem -- did you already try some of them?
04:24:03 <Na-Fiann> yeah
04:25:00 <Na-Fiann> the strictlines trick helped a bit I think, but I'm now trying to figure out why the char8 version craps out on my data, where python just chugs along
04:26:08 <ChristianS> Na-Fiann: it does, oops? but the Data.Text version is fine? what exactly goes wrong?
04:26:09 <ChristianS> bbl
04:31:29 <Na-Fiann> ChristianS: it's because of the use of unwords. It treats 0xa0 as whitespace, where python's split() doesn't. A bit annoying that, though I suppose it's more correct
04:33:18 <merijn> It's remarkable how becoming smarter and feeling dumb and confused feel very similar >.>
04:41:53 <tdammers> merijn: the biggest share of things you learn is knowing what else you haven't learned yet
04:42:56 <merijn> tdammers: Reading up on arrows now ("Generalising monads to arrows") and each new code snippet takes me like 20 minutes to decipher (although this would be significantly easier if they were all annotated with types...)
04:45:56 <srhb> Is there a good reason that the version of Data.List is not defined (last case) as.. transpose xss = [ h | (h:_) <- xss ] : transpose [ t | (_:t) <- xss ]
04:45:56 <srhb>  
04:46:06 <srhb> It seems clearer, to me. But perhaps there are performance issues?
04:47:22 <srhb> Oh, I guess it is because their version of the last pattern explicitly indicates that the first element does not have zero elements.
04:51:18 <Peaker> Hey, in http://augustss.blogspot.com/2007_11_01_archive.html -- augustuss adds "let" as a special construct, instead of using applied-lambda. Then he adds a specific handling of "let" in the type-checker, instead of handling all redexes.. Any idea why handle let specifically?
04:51:53 <Peaker> Is it to avoid having to reduce everything to normal form, and use "let" as a hint of what values we do want reduced?
04:52:42 <b0fh_ua> Hi all! I have value of type [XmlTree], which has set of XText content (extracted text of attributes), now how do I convert it to [String]?
04:55:22 <rostayob> Peaker: no particular reason I think, and btw he actually desugars them into \ abstractions and application when doing substitution
04:58:09 <Peaker> rostayob: But not when doing type checking, see later
04:58:10 <cwl> I have installed haskell-platform-2011.2.0.0-4-x86_64.pkg.tar.xz months ago
04:58:13 <donri> b0fh_ua: deep getContents
04:58:26 <donri> or was that getText?
04:58:27 <cwl> But it no longer exists
04:58:31 <donri> i forget.
04:58:32 <cwl> how to upgrade it?
04:58:51 <cwl> pacman -Syu failed to resolve dependencies
04:59:09 <b0fh_ua> donri: getAttrValue in fact
04:59:10 <b0fh_ua> thanks!
04:59:33 <rostayob> Peaker: well maybe the let is polymorphic then
04:59:41 <rostayob> Peaker: and he needs a let for the same reason that ML needs a let
04:59:48 <rostayob> (but I haven't read)
05:00:06 <Peaker> no, he says at first that let is just sugar, and later he writes code that is specific for let
05:00:10 <Peaker> (not sugar anymore?)
05:00:44 <cwl> Have anyone met the same problem?
05:01:32 <rostayob> Peaker: I don't have time to read the entire post right now, I might later :)
05:04:51 <merijn> Is the do notation for Arrows in common use? (As far as arrow usage is common :p)
05:07:57 <rostayob> merijn: do notation? you mean proc notation?
05:07:59 <Saizan> Peaker: is there a post where he shows how applications are typechecked?
05:09:17 <merijn> rostayob: The paper I read refers to the arrow sugar as do notation, maybe the implementation uses proc instead?
05:10:35 <merijn> So read "do notation" as "whatever the arrow syntactic sugar is called fo' real"
05:12:13 <rostayob> merijn: uh ok, you use do actually but is starts with "proc"
05:12:42 <donri> arrow notation http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
05:12:44 <rostayob> merijn: anyways, I've seen it in Arrow-heavy code
05:12:54 <donri> i use it with hxt
05:13:33 <rostayob> merijn: e.g. the "arrows" package, or netwire
05:13:50 <merijn> donri: Yeah, I found that. Was just wondering whether investing the time to grok it is worth it. If it's actually moderately used then I have reason to invest a bit more time in it rather than skipping to the next sections
05:14:18 <rostayob> merijn: I feel you, it's much more complex than the do notation
05:14:34 <donri> it makes some arrow stuff easier / more clear, some not
05:14:37 <donri> just like do notation
05:14:47 <merijn> rostayob: Yeah, but the example arrow code (without sugar) in the Hughes paper isn't very readable either
05:15:04 <merijn> Or I'm just not desensitised enough with regards to abstraction :p
05:15:12 <rostayob> merijn: wait until you get to banana brackets
05:16:48 <magicman> I still don't *really* understand what those do >_<
05:17:04 <donri> http://www.haskell.org/haskellwiki/HXT/Practical has examples of arrow notation
05:17:14 <Saizan> Peaker: the point is that in "let x :: t; x = a in e" you might have an e that typechecks only by knowing x is a, so (\(x :: t) -> e) wouldn't typecheck because you only know x's type
05:18:42 <rostayob> ok, so it has to do with dependent types
05:19:46 <ChristianS> Na-Fiann: oh, i see, though i didn't realize that 0xa0 does even occur in UTF-8. but in that case you could probably role your own split function that splits at '\t', as you did before?
05:20:22 <ChristianS> Na-Fiann: if that's not good enough, you'll probably have to stick with Data.Text, though there will be some performance penality for decoding+encoding.
05:26:51 <Radziu> hi, i'm trying to write some udp server but i have a problem with recvFrom as it throws exceptions when my app receives an empty packet, i can of course catch this exception and handle it but the problem is that i haven't figured out how to get the remote address which sent the packet, is there any way? thank you in advance!
05:28:08 <teneen> Can top-level type families replace Funcitonal dependecies? like associated types
05:28:59 <merijn> Radziu: Which recvFrom do you refer to?
05:29:13 <merijn> Network.recvFrom, Network.Socket.recvFrom or Network.Socket.ByteString.recvFrom?
05:29:45 <Radziu> merijn: i tried both Network.Socket and Network.Socket.ByteString
05:31:04 <merijn> Radziu: Network.Socket.recvFrom and Network.Socket.ByteString.recvFrom both return tuples containing SockAddr, which you can use to look up the sender
05:31:17 <merijn> Network.recvFrom doesn't provide that info, I think
05:31:19 <qnikst> what is the best way to make, forver' :: m () -> m () for monadic action that can throw exeptions?
05:31:53 <merijn> qnikst: You mean that ignores any exceptions that are thrown in the initial action?
05:32:23 <qnikst> yep, reload action if exception occures
05:32:32 <Radziu> merijn: yes, i know but how can i do this if it throws an exception? the tuple doesn't seem to be accessible in the error handler :<
05:32:36 <qnikst> and reload it if there was no exception
05:33:04 <merijn> Radziu: Ah
05:33:28 <qnikst> I've done:
05:33:28 <qnikst> simpleReload :: MonadControlIO m => m a -> m ()
05:33:29 <qnikst> simpleReload action = catch (action >> return ()) (\(SomeException _) -> return ()) >> simpleReload action
05:33:36 <qnikst> but it seems not work
05:33:55 <merijn> qnikst: "forever' action = forever $ action `Prelude.catch`(\x -> return ())"?
05:34:48 <merijn> That just repeats "action" forever and ignores any IO errors thrown by action by aborting and ignoring the action
05:35:19 <qnikst> Prelude.catch loses some excetions, but I'll try with one from Control.Excetion
05:35:28 <merijn> Radziu: Looks like the only solution is to write your own recvFrom
05:35:55 <merijn> qnikst: Yeah, it only catches IO exceptions, you can probably hack something similar using Control.Exception
05:36:19 <merijn> Radziu: I looked at the source and there's no way to get the info
05:36:23 <qnikst> thanks
05:36:48 <Radziu> merijn: yeah, i did look there too, and in many other places too :<
05:37:54 <Radziu> merijn: i've also found this discussion: http://haskell.1045720.n5.nabble.com/Coming-up-with-a-better-API-for-Network-Socket-recv-td3128122.html
05:38:07 <Radziu> merijn: but it looks dead now
05:38:26 <merijn> Radziu: Yeah, the API is pretty awful
05:39:17 <merijn> Radziu: I was motivated to write a new library for 10 minutes, then I found out it's windows compatible and realised I would probably have to make a windows compatible replacement to gain traction :p
05:40:28 <Radziu> merijn: what's wrong with windows compatibility? ;p
05:40:45 <merijn> Radziu: Nothing, but windows socket programming sucks donkey balls
05:41:12 <Radziu> merijn: i'm actually from the winsock part of the world
05:41:14 <merijn> So I'm personally not motivated enough to do it :p
05:41:45 <merijn> But I'd be happy to contribute some help if someone else feels motivated to create a nicer networking library :p
05:42:40 <Radziu> i would vote for replacing the current one, it's irrational to throw eof error in such a case :S
05:43:32 <merijn> (While I'm doing wishful thinking I want to be able to block on boths Chan's and Handles (i.e. sockets/files))
05:44:13 <qnikst> hm.. it seems MonadError in monad stack does it's dirty work, and computation stops
05:45:58 * hackagebot binary 0.4.5 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.4.5 (KetilMalde)
05:46:06 <Radziu> anyway, i'm glad i haven't missed anything in my search for an answer before i asked it here
05:48:46 <ChristianS> Na-Fiann: frankly, i think that Char8.words breaking at 0xa0 (NBSP) is a mistake even for latin1 text, sind that's explicitly supposed to be a "NON-BREAKING space". in any case it means that Char8.words will indeed corrupt UTF-8 text.
05:49:03 <ChristianS> Na-Fiann: so you either have to role your own split function or go the Data.Text route.
05:55:35 <Na-Fiann> ChristianS, do you think we should report it somewhere?
05:56:36 <astor> how cand I convert from Fractional to Double?
05:57:49 <ChristianS> Na-Fiann: i think it would make sense to report it as a bug, but i don't know where to report bugs for the bytestring package -- anybody here can help out?
05:58:03 <ChristianS> in any case that won't help you in the short term.
05:58:11 <Tinned_Tuna> ChristianS: I just report bugs to the package maintainer as specified on hackage.
05:58:11 <Zamarok> So I may have typed "and $ cycle [True]" into GHCI, and now I can't seem to break out whatever infinite operation is being performed.
05:58:31 <Zamarok> Do I have to kill the process? Or is there another way?
05:58:45 <ChristianS> Tinned_Tuna: ok, thanks
05:59:11 <hiptobecubic> is there a way to have ghci tell me when something becomes NaN?
05:59:12 <Na-Fiann> No, but it would be the right thing to do
05:59:17 <merijn> Zamarok: ctrl-c, and if that doesn't work: kill the process
05:59:21 <ChristianS> Na-Fiann: ok, there are two maintainers listed at http://hackage.haskell.org/package/bytestring , should i report it or will you do it?
05:59:41 <hiptobecubic> like halt execution once NaN appears somewhere?
06:00:03 <Zamarok> merijn: yea CTRL+c does nothing. What is the name of GHCI processes?
06:00:21 <Zamarok> cause "killall ghc" doesn't work
06:00:27 <merijn> No clue "ps uax | grep ghc"?
06:00:30 <Na-Fiann> I can do it :)
06:00:43 <merijn> killall only kills processes that match the name exactly, I think?
06:00:45 <ChristianS> Na-Fiann: great, thanks
06:00:47 <Tinned_Tuna> Hold control-C down, Zamarok
06:00:48 <merijn> And ghci /= ghc
06:01:15 <Saizan> ghci is ghc --interactive
06:01:22 <Zamarok> Yea only one GHC process is running, and "kill ghc" doesn't seem to actually kill it cause it still exists after that
06:01:24 <merijn> hmm
06:01:40 <Zamarok> Tinned_Tuna: that just fills the terminal with "^C", but doesn't do anything
06:01:41 <Saizan> Zamarok: try killall -s KILL ghc
06:01:56 <Tinned_Tuna> Zamarok: find the pid using ps aux | grep ghci
06:02:01 <Tinned_Tuna> then use kill -9 <pid>
06:02:05 <merijn> ps uax | awk '{echo $2}' | xargs kill -9
06:02:07 <Tinned_Tuna> (from a different terminal)
06:02:07 <Zamarok> Saizan: ahh yep, that did it. Thanks
06:02:09 <merijn> eh
06:02:14 <merijn> grep ghc in there
06:02:31 <mux> or just ^Z ghci and then kill %%
06:02:33 <osa1> I've installed http-conduit but I still can't import Network.HTTP.Conduit, can anyone help me?
06:02:37 <merijn> Unless you hate all processes :p
06:02:42 <mux> or use the much nicer pgrep/pkill commands
06:02:48 <tdammers> you can also use top to kill processes
06:03:15 <tdammers> or xkill, if it has an X11 window
06:03:16 <Zamarok> I tried everything I knew, but only passing the actual KILL sigterm signal worked
06:03:21 <Zamarok> like Saizan said
06:03:40 <Saizan> KILL is sigkill not sigterm :)
06:03:57 <tdammers> yeah, sometimes a process is stuck beyond honoring graceful termination requests
06:04:00 <Zamarok> yea that ^^
06:04:01 <merijn> SIGTERM can be discarded, SIGKILL cannot
06:04:06 <mux> next time try to suspend it with ^Z as I said, it's likely to work and is more convenient because you don't need to switch to another terminal
06:04:21 <Zamarok> I think killall has a very misleading name.
06:04:21 <tdammers> i.e., it traps sigterm and gets stuck handling it
06:04:24 <merijn> mux: Since when is terminal switching inconvenient? :p
06:04:34 <mux> merijn: since about forever?
06:04:41 <merijn> Zamarok: Depends on whether you're on SYSV or BSD based systems :p
06:04:51 <mux> this is why I only use pkill.
06:04:54 <merijn> mux: I always have extra terminals in tmux open anyway
06:04:54 <mux> it's nicer too
06:05:19 <mux> merijn: maybe he doesn't
06:05:43 <merijn> mux: Seems like a situation which he should remedy soon, then :>
06:06:00 <mux> ok, so it isn't more convenient to avoid the need for switching terminals, fine
06:06:39 <osa1> does anyone here know which cabal package contains Network.HTTP.Conduit?
06:07:15 <astor> a simple haskell question between all the 1337 unix admin stuff :-) can you guyus help me convert from Fractional to Double?
06:07:35 <rwbarton> osa1: http://hackage.haskell.org/package/http-conduit indicates it is the one you are looking for. what do you mean "can't import"
06:07:52 <rwbarton> do you have a ghci session from before the package was installed possibly?
06:08:30 <osa1> rwbarton: I already have that package installed but I'm still getting "can't find module" error
06:08:30 <Saizan> astor: Fractional is a class, and Double is an instance of it, so your problem must be something else
06:08:49 <osa1> rwbarton: no I restarted the ghci
06:09:07 <Saizan> astor: typical conversion functions are fromIntegral, realFrac, and round/truncate/ceiling
06:09:51 <Saizan> astor: i meant  realToFrac
06:09:51 <astor> Saizan: If I have  printDouble :: Double -> IO () and another one fun2 :: Fractional a => a -> IO ()  in fun2 I should be able to call printDouble somehow.
06:11:00 * hackagebot layout-bootstrap 0.2.2 - Template and widgets for Bootstrap2 to use with Text.Blaze.Html5  http://hackage.haskell.org/package/layout-bootstrap-0.2.2 (AlexanderBondarenko)
06:12:20 <rwbarton> osa1: are you in a source directory for http-conduit by any chance?
06:12:45 <rwbarton> what does "ghc-pkg list http-conduit" say?
06:12:52 <Saizan> astor: yeah, that's done with realToFrac
06:13:06 <osa1> rwbarton: no. I've also tried --reinstall
06:13:20 <osa1> rwbarton: it prints 2 folders
06:13:25 <rwbarton> that means it's not installed
06:13:48 <Saizan> astor: nope, i'm wrong
06:13:52 <rwbarton> if it were installed you'd see a line like   http-conduit-<version>
06:13:54 <osa1> rwbarton: I installed it 3 times now
06:13:58 <osa1> hmm
06:14:25 <osa1> rwbarton: I have http-conduit folder in my .cabal
06:14:51 <rwbarton> you mean in .cabal/packages/ ?
06:14:58 <rwbarton> packages/...
06:14:59 <rwbarton> or what
06:15:03 <Saizan> astor: you can if you change fun2's type to (Real a, Fractional a) => a -> IO ()
06:15:16 <osa1> rwbarton: /home/sinan/.cabal/lib/http-conduit-1.2.6
06:15:42 <osa1> rwbarton: also /home/sinan/.cabal/packages/hackage.haskell.org/http-conduit
06:15:43 <astor> Saizan: I see.  Fractional seems like a dead-end.. impossible to get out of :-)
06:15:44 <rwbarton> hmm, but evidently ghc doesn't know about it
06:17:46 <rwbarton> osa1, what's in /home/sinan/.cabal/lib/http-conduit-1.2.6 and does it match the ghc version you're using?
06:18:06 <osa1> rwbarton: yes
06:18:36 <osa1> oh, and it's 7.0.4
06:18:53 <Saizan> if ghc-pkg list http-conduit lists it, then you want to check ghci -v for related warnings
06:19:09 <osa1> Saizan: no it doesn't list it
06:19:19 <rwbarton> no idea then, but apparently it wasn't registered with ghc. good luck, i have to go
06:19:21 <astor> (Real a, Fractional a) is basically RealFrac a
06:20:05 <Saizan> osa1: which command are you using to install it, exactly?
06:20:21 <osa1> Saizan: cabal install http-conduit
06:20:33 <Saizan> osa1: no sudo or similar?
06:20:40 <Saizan> osa1: and it doesn't report any error?
06:21:03 <Saizan> (this is not usggesting you should use sudo)
06:21:44 <osa1> Saizan: no I'm not using sudo when installing packages(this is first time I'm having trouble with cabal install without sudo)
06:24:25 <Saizan> good
06:25:13 <Saizan> though if the installation goes through without errors i don't see what could be the problem, unless maybe if you have more than one ghc installed
06:25:39 <osa1> Saizan: does this help? http://paste.pocoo.org/show/562394/
06:25:47 <osa1> no I have only one ghc installed
06:26:28 <adnauseam> htm, in
06:26:35 <kstt> hey, let's pretend I have a 'f :: (a -> m b)' function and a 'x :: m a' computation. I can easily run 'f' on the outcome of 'x' with '>>=' : x >>= f . Cool. Now let's pretend 'f :: (a -> b -> m c)' and 'x :: m a' and 'y :: m b'. What would be the best way to apply 'f' without naming intermediate monadic outcomes ?
06:27:48 <Saizan> kstt: one way is: join $ liftM2 f x y
06:28:08 <kstt> I've hoped to avoid explicit joining
06:28:14 <kstt> but thank you for carring !
06:28:32 <t7> i use that pattern alot, join . liftM2
06:28:40 <kstt> ok
06:29:11 <kstt> I don't liftM much but I `ap` a lot, guess that does not make any difference
06:29:13 <Saizan> osa1: it seems fine but that warning might be it
06:29:59 <kstt> I don't know why I don't whant to join ... It seems that I barely encounter 'join' in people code so I'm not sure if using it is a smell or not.
06:30:08 <Saizan> you can define jap f x = join (f `ap` x) and write f `ap` x `jap` y
06:30:57 <kstt> I don't like jap'ing on the last parameter :)
06:31:31 <Saizan> there isn't much you like, it seems :)
06:31:38 <kstt> Saizan: good point :)
06:32:00 <kstt> Saizan: actually, all your proposals are very valid and certainly good.
06:32:07 <osa1> Saizan: can compiling the package from source solve my problem?
06:32:33 <kstt> The problem simply is that I don't encounter this pattern very often so I doubt of my approach
06:32:38 <Saizan> osa1: if by package you mean http-conduit that's what you're doing
06:35:01 <aristid> osa1: did you ever do something like cabal install time?
06:35:02 <Saizan> kstt: (x >>= \ .. -> y >>= \ .. -> f ...) might be a little more efficient than the join way because you combine two passages through the monad into one
06:35:24 <kstt> but that requires explicit naming
06:35:32 <Saizan> yeah
06:35:45 <kstt> I'm not creative enough to find names
06:35:58 <Saizan> but that little less efficiency is the only downside of join i can think of
06:36:02 <kstt> I fear the moment where I'll have to do so for childrens :)
06:38:00 <osa1> aristid: yeah I think I've done that when I first installed ghc and cabal
06:40:38 <osa1> aristid: how is that related with my problem?
06:40:58 <aristid> osa1: well, that was a mistake :) time comes with ghc and should not be updated. i think more recent versions of cabal-install protect against that (cabal-install CAN be upgraded safely)
06:47:13 <Gr3yFox> hi
06:48:34 <osa1> strange, I have file named /home/sinan/.ghc/x86_64-linux-7.0.4/package.conf.d/http-conduit-1.2.6-b4778fde79cb673f658ac42fe08efb0f.conf
06:48:55 <osa1> wait, ghc-pkg list http-conduit printed a result
06:50:08 <Gr3yFox> I'm searching for some concurrency libraries, is there anyone with some knowledge on the topic please?
06:50:24 <merijn> Gr3yFox: What do you plan to do?
06:50:58 <merijn> There's tons of libraries/concurrency tools around, depending on what you need
06:54:15 <osa1> is there a quick way to fix these problems http://paste.pocoo.org/show/562409/
06:55:38 <quicksilver> package random-1.0.0.3-7511feaba03eecc22356464da8976c7e is shadowed by package random-1.0.0.3-2053f22788f7973276c8e9429ecdab8f doesn't look good.
06:56:20 <quicksilver> random is a core package, so you hsouldn't have two copies of it.
06:56:42 <quicksilver> that might be the source of all the problems?
06:56:55 <osa1> quicksilver: yeah how can I solve that?
06:57:15 <osa1> dude I have cabal, I've just installed ghc and cabal and only command I used after that was cabal install
06:57:19 <Gr3yFox> merijn: Hi, thanks. I want to lauch several independent but communicating actions (with a StateT codomain), one per thread. Each action should have an identifier (e.g. a string), and  should be able to send messages (i.e. values of a fixed data type) to the other ones in a non-blocking way, like channels do in example. Should I write this down from scratch, or is there some infrastructure that could fit?
06:57:22 <osa1> and now I have this problems
06:57:27 <osa1> s/have/hate
06:57:32 <quicksilver> well I wonder how random-1.0.0.3-2053f22788f7973276c8e9429ecdab8f got installed.
06:57:49 <quicksilver> you could try hiding/deleting it
06:58:10 <osa1> quicksilver: by deleting do you mean deleting the files? or does cabal have a command for it?
06:58:24 <quicksilver> it's masking the correct version of random which all the other packages there want to use.
06:58:50 <quicksilver> however I think to solve this you're going to need to understand why the new random got installed in the first place
06:58:57 <quicksilver> conceivably other things got installed along with it.
06:59:12 <osa1> quicksilver: I only have random 1.0.0.3 in .cabal/packages
06:59:18 <quicksilver> osa1: can you show us ghc-pkg list?
06:59:48 <osa1> quicksilver: http://paste.pocoo.org/show/562411/
07:01:11 <quicksilver> I think you just have two base packages reinstalled
07:01:19 <quicksilver> random and time
07:01:32 <quicksilver> you should use 'ghc-pkg unregister' to get rid of them
07:01:46 <osa1> quicksilver: what I can't understand is why did cabal installed another one if I had already had another one
07:01:58 <quicksilver> I also can't understand that
07:02:00 <osa1> quicksilver: ghc-pkg unregister random ?
07:02:03 <quicksilver> no
07:02:06 <quicksilver> the full pkgid
07:02:12 <quicksilver> random-1.0.0.3-2053f22788f7973276c8e9429ecdab8f
07:02:18 <osa1> so ghc-pkg unregister random-1.0.0.3-2053f22788f7973276c8e9429ecdab8f ?
07:02:21 <quicksilver> yes
07:02:30 <quicksilver> and also time-1.4.0.1
07:02:32 <osa1> quicksilver: do I need something like that for time too?
07:02:35 <osa1> ah, ok
07:02:43 <quicksilver> no, because it's only copy with that version number
07:02:53 <quicksilver> the roblem with random is you have two copies of 1.0.0.3
07:03:02 <osa1> quicksilver: holy shit! ghc-pkg: cannot find package random-1.0.0.3
07:03:09 <quicksilver> I also can't understand why cabal installed another one, although it must have had a reason.
07:03:31 <quicksilver> now we abandon all hope and pray only for the appearance of dcoutts . or maybe Saizan.
07:04:57 <osa1> quicksilver: how good is the idea of removing random and time packages' files inside of ~/.ghc and ~/.cabal manually?
07:05:32 <dcoutts> hah hah
07:05:53 <osa1> dcoutts: and here comes my hero, I think
07:05:57 <dcoutts> cabal install blah -v --dry-run will usually list the reason for reinstalling something
07:05:58 <osa1> dcoutts: do you have any ideas?
07:06:08 <dcoutts> it's usually because of a changed dependency
07:06:19 <dcoutts> that other packages need to be rebuilt to be consistent
07:06:31 <quicksilver> why can't he unregister the bogus random though?
07:07:35 <dcoutts> you should be able to just do $ ghc-pkg unregister --user random-1.0.0.3
07:07:51 <dcoutts> and that will not be ambiguous, no need for full package id
07:08:08 <dcoutts> indeed I'm not 100% sure how ghc-pkg handles full package ids
07:08:13 <osager> what does this operator mean ? &=
07:08:21 <quicksilver>   ghc-pkg unregister {pkg-id}
07:08:24 <osager> used here: https://github.com/ivanperez-keera/clean-home/blob/master/src/Args.hs
07:08:26 <quicksilver> says the docs
07:08:28 <quicksilver> perhaps they lie :)
07:08:50 <quicksilver> osa1: it's a CmdArgs thing
07:09:04 <dcoutts> quicksilver: it's not clear what "pkg-id" refers to there
07:09:15 <dcoutts> quicksilver: before we had the big hashes, foo-1.0 was a package id
07:09:16 <osa1> dcoutts: I get a warning saying that unregistering random will break some dependencies
07:09:20 <osager> i can not understand the syntaxs of chArgs
07:09:31 <quicksilver> osa1: me neither. I don't use it. This may not help you :P
07:09:46 <dcoutts> osa1: ok there you go, and is that the stuff that cabal installed on top of the new random?
07:10:22 <quicksilver> oops that was for osager
07:10:30 <dcoutts> osa1: so if you use --force then it'll unregister leaving the other things broken. cabal can cope with broken packages it just treats them as if they did not exist.
07:10:32 <osager> got it qucksilver
07:10:36 <osager> i'll take a look
07:10:45 <osa1> dcoutts: I don't know. ok I've just run unregister
07:12:02 <osa1> dcoutts: Conduit works :)
07:12:48 <osa1> dcoutts: thanks. I still hate cabal, I never had problems like that with python's pip or common lisp's quicklisp
07:13:10 <osa1> or clojure's lein
07:13:41 <dcoutts> osa1: do they handle multiple versions of things installed at once?
07:14:35 <eyebloom> Would anyone be able to look at this code, I can't figure out why my add function compiles by itself but my Leq function does not.
07:14:58 <osa1> dcoutts: I'm not sure but it wasn't the problem I had with cabal. I had two same versions installed at once(I think one was system-wide and one was not)
07:15:33 <dcoutts> osa1: the next release will address that issue rather better
07:15:43 <hpaste> eyebloom pasted “Ambiguous quandary” at http://hpaste.org/64922
07:16:04 <osa1> glad to hear! thanks for your time
07:16:59 <ronankde> preprocessor in haskell
07:17:01 <ronankde> how it works?
07:17:17 <stj> I have a data type and two constructors with a lot of fields... can I use pattern matching (to match one of those constructors) without typing all those boring underscores?
07:18:00 <mauke> stj: record syntax
07:18:09 <mauke> oh
07:18:10 <eyebloom> I think it has something to do with the difference between Ord and Num constraints , but I haven't fully figured it out.
07:18:23 <Philippa> record patterns, then
07:18:23 <mauke> stj: ConstrA{}
07:18:43 <Philippa> (with or without fields as appropriate)
07:19:34 <stj> mauke: thanks
07:20:55 <quicksilver> eyebloom: monomorphism restriction.
07:21:09 <quicksilver> eyebloom: give nvLeq a type signature; or turn the monomorphism restriction off.
07:22:48 <quicksilver> hmm actually I'm not so sure I'm right about that.
07:23:04 <eyebloom> I hoping not to give it a type signature, but NoMonomorphismRestriction doesn't do it.
07:23:19 <mauke> I thought it was because the result doesn't depend on the inputs
07:23:45 <quicksilver> the result type has no dependency on the types of 'x' and 'y'
07:23:51 <saml> hey is there a good hierarchical database?
07:23:55 <quicksilver> so the inferred Ord constraint can't be satisfied.
07:24:27 <saml> something like normal filesystem but have transaction and things are indexed for fulltext search
07:25:09 <eyebloom> What is it about the Ord typeclass constraint that makes it require a type signature?
07:25:27 <mauke> Bool
07:25:28 <quicksilver> that was a red herring, eyebloom
07:25:44 <quicksilver> the point is that the type of nvLeq doesn't expose the type of x and y anywhere
07:25:54 <davean> willb: 23
07:26:04 <quicksilver> so there is no way to impose the constraint that x and y belong to a type which is a member of ORd
07:26:32 <eyebloom> Isn't that the same in my nvAdd function. Any Num instance can be inferred from x and y.
07:26:41 <Gr3yFox> merijn: cound Control.Concurrent.CHP be a good choice?
07:26:45 <quicksilver> eyebloom: no.
07:26:52 <quicksilver> Num instances shortcircuit via the magic of defaulting
07:26:59 <quicksilver> so it assumes Integer, there.
07:27:36 <eyebloom> Ah, that explains a lot.
07:28:26 <eyebloom> It all seemed clearly ambiguous to me but I couldn't figure out why some of my test functions were still compiling.
07:28:43 <eyebloom> Is there a place to read on defaulting?
07:28:56 <quicksilver> it's in the haskell report and also covered in the GHC manual
07:29:06 <quicksilver> I'm still confused though
07:29:14 <quicksilver> in my GHCi, I can infer as follows:
07:29:28 <quicksilver> let nvLeq () = lam "x" (\x -> lam "y" (\y -> app2 (ext leq_) x y)) in nvLeq :: (Calculus repr, Ord a) => () -> repr (a -> a -> Bool)
07:29:43 <quicksilver> I don't see why it can't infer that for your nvLeq
07:29:52 <quicksilver> mauke: ?
07:30:31 <pozic> How do I get Text.Regex? I don't care about the package or speed as long as it works.
07:32:13 <pozic> I got it already.
07:32:53 <eyebloom> For the time being I'm not really interested in evaluating this higher order syntax, I'm interested in transformations, that's why I was reluctant to fully type it.
07:35:30 <quicksilver> eyebloom: OK so it turns out that nvLeq is perfectly inferrable
07:35:35 <quicksilver> it has the type I pasted just above.
07:35:50 <quicksilver> eyebloom: the problem is testFunctions.
07:35:55 <quicksilver> Comment out testFunctions and your code compiles.
07:36:15 <eyebloom> I see
07:36:30 <quicksilver> so the problem is that AnyNaive erases the type "a" entirely
07:36:32 <quicksilver> but that can't work
07:36:41 <quicksilver> because nvLeq needs an Ord instance
07:36:49 <quicksilver> if you erase it, it doesn't know which one to choose.
07:37:04 <pozic> What package contains Lennart's CReals?
07:37:12 <quicksilver> pozic: numbers
07:37:19 <quicksilver> or was it Numbers
07:37:21 <quicksilver> one of the two.
07:37:47 <eyebloom> Is there a way that I can create a list with many of these Hoas functions in it?
07:37:50 <quicksilver> eyebloom: consider the type of your constructor "AnyNaive"
07:37:51 <quicksilver> AN :: (Calculus repr) => (() -> repr a) -> AnyNaive repr
07:38:07 <quicksilver> hmmm
07:38:23 <quicksilver> it has to work polymorphically
07:38:27 <quicksilver> a is unbounded
07:38:32 <t7> whats the complexity of traveling salesman? O(n*n) ?
07:38:42 <funktronic> t7: O(2^n)
07:39:02 <quicksilver> so you can't pass it a function like nvLeq
07:39:03 <t7> 2^n is called exponential ?
07:39:24 <quicksilver> which only works on Ord types
07:39:38 <funktronic> t7: yes. it's a np-hard problem
07:41:07 <eyebloom> a in the AnyNaive definition is actually the type of each HOAS function.
07:41:17 <quicksilver> eyebloom: I'm still wrong
07:41:22 <quicksilver> eyebloom: and I'm still confused :)
07:41:40 <quicksilver> oh but now I'm getting bitten by ghci's extended defaulting.
07:42:36 <eyebloom> Basically I would need to constrain type variables within AnyNaive's a to be Ord.
07:42:45 <pozic> t7: nobody knows.
07:42:46 <quicksilver> ok so the point is the caller of AN has to fix the type.
07:43:09 <quicksilver> nvLeq has type (Ord a, Calculus repr) => () -> repr (a -> a -> Bool) while AN has type (Calculus repr) => (() -> repr a) -> AnyNaive repr
07:43:33 <quicksilver> so when you call AN you have to fix a, at a type which definitely supports Ord
07:43:36 <pozic> t7: travelling salesman problem has basically been solved in practice, AFAIK.
07:43:39 <quicksilver> to make "AN nvLeq" typecheck
07:43:51 <t7> pozic: you have to brute it
07:44:06 <t7> so thats every combination of routes
07:44:25 <pozic> t7: i.e. if you want to plan a trip to 30000 cities with a 99.99% solution quality, that already works.
07:44:45 <pozic> t7: no, that's just what humanity has been able to come up with thusfar.
07:45:15 <eyebloom> Ok, it's what I'm trying to avoid. In my larger program I dump these HOAS's into a list and then process them all into dynamic representations.
07:45:31 <eyebloom> I'm not evaluating them directly so typing them is difficult.
07:45:46 <t7> pozic: well yer... :)
07:45:47 <pozic> Where should I get hPutStrLn from?
07:46:20 <eyebloom> The hidden perils of embedded syntax.
07:46:54 <pozic> Can I use haskell98 and haskell2010 in the same program?
07:48:24 <roconnor> pozic: as in different modules?
07:48:25 <cheater__> why would you?
07:48:41 <eyebloom> I added the signature    nvLeq :: (Calculus repr) => () -> repr (Int -> Int -> Bool)
07:49:15 <eyebloom> That makes it compile. I'll see if it causes problems down the road.
07:49:18 <eyebloom> Thanks for your help.
07:49:56 <pozic> roconnor: yes
07:52:50 <stj> I've just written an inorder traversal of a tree (it looks like this: = in left ++ [x] ++ in right) and as you can see the algorithm is not O(n)... what would be the most elegant way to make it O(n)?
07:53:08 <pozic> roconnor: I want the function hPutStrLn function which takes a String and a Handle. I was using the one from the haskell98 package, but where can I find it now?
07:53:42 <pozic> stj: why do you think it is not O(n)?
07:54:19 <pozic> stj: difference lists can do it.
07:54:34 <pozic> stj: or likely some vector type,
07:55:48 <pozic> stj: and indeed it is not O(n)
07:56:39 <Saizan> @hoogle hPutStrLn
07:56:39 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
07:56:39 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
07:56:39 <lambdabot> Data.ByteString.Char8 hPutStrLn :: Handle -> ByteString -> IO ()
07:56:47 <pozic> Saizan: odd, I just was there.
07:56:49 <stj> pozic: too bad it's impossible to append stuff to the end of a list in O(1) :(
07:56:57 <pozic> stj: sure you can.
07:57:02 <pozic> stj: that's called snoc.
07:57:13 <pozic> stj: except they are not usual lists.
07:57:32 <pozic> stj: if you don't want to care about these details, just use Data.FingerTree
07:57:44 <mux> did you mean Data.Sequence?
07:57:55 <pozic> mux: FingerTree is more general.
07:57:58 <mux> no need to use a finger-tree if you just want O(1) append
07:58:06 <stj> I agree with mux
07:58:07 <mux> more general doesn't necessarily mean it's better
07:58:09 <pozic> I think a high-level language should allow the user to use a generic data structure for everything.
07:58:09 <Saizan> Data.Sequence requires less care
07:58:28 <pozic> Haskell compilers should see "hey, that guy is only using those operations. "
07:58:39 <pozic> Then the compiler can use a list if it thinks it is faster.
07:58:45 <pozic> Or mutable arrays or...
07:59:13 <Saizan> pozic: performance aside, Data.Sequence has a simpler API
07:59:18 <pozic> The compiler is there to turn explanations how to turn one input into an output into one that works faster.
07:59:20 <Saizan> for this purpouse at least
07:59:48 <pozic> That's a completely different view point than 'just something which provides machines portability' which most people seem to want.
08:00:35 <pozic> machine portability, even.
08:01:33 <ousado> pozic: into one that works faster? or just one that works?
08:01:52 <pozic> ousado: it already does the latter one.
08:02:08 <pozic> How can I cat something to a main function in ghci?
08:03:07 <stj> is complexity of length O(n)?
08:03:35 <tromp__> stj: affirmative
08:06:41 <stj> hmmm, how would you implement a Fenwick tree in Haskell?
08:08:02 <stj> has anyone tried coding it?
08:18:51 <stj> or maybe interval tree? anyone? :)
08:20:27 * mike1703 is away: I'm busy
08:21:55 <Na-Fiann> when outputting a string containing unicode using normal strings, haskell outputs some numbers I don't quite understand. Can someone tell me where the number \352 comes from in a string containing the sequence 0xC5 0xA0 ()?
08:22:39 <mauke> uh. '\352' is Š
08:23:24 <Na-Fiann> ? in what encoding?
08:23:42 <mauke> none
08:23:45 <merijn> Na-Fiann: \352 is a unicode code point
08:23:57 <merijn> Encoding is irrelevant
08:25:04 <merijn> So apparently '0xC5 0xA0' maps to  in whatever encoding your reading data in in (haskell defaults to UTF-8, iirc)
08:26:10 <zero___> is there any de facto coding standard for haskell programs?
08:26:32 <mauke> merijn: ?
08:26:53 <parcs`> zero___: you mean coding style?
08:26:56 <zero___> coding style*
08:26:58 <zero___> yes sorry
08:27:51 <Na-Fiann> hmm.. I can't find that mapping in any kind of table
08:28:03 <mauke> have you tried unicode
08:28:13 <merijn> mauke: Am I saying really dumb things?
08:28:20 <Na-Fiann> ahh
08:28:22 <Na-Fiann> ffs
08:28:31 <mauke> merijn: where did you get ¦ from?
08:29:09 <Na-Fiann> never mind
08:29:13 <Na-Fiann> I'm being silly
08:29:31 <Na-Fiann> I didn't realize haskell used unicode by default
08:29:33 <parcs`> zero___: there're https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md and http://urchin.earth.li/~ian/style/haskell.html both of which are made by two prominent haskell developers
08:29:51 <merijn> mauke: I just copy pasted the character you mentioned
08:30:07 <merijn> mauke: Apparently one of our clients is fucking up the encoding? :p
08:30:08 <zero___> parcs`: thank you very much =)
08:30:40 <mauke> merijn: what do you see here: é ; €
08:30:48 <tgeeky>  é ; â¬
08:31:03 <merijn> e with right tick and euro sign
08:31:06 <mauke> tgeeky: very unhelpful
08:31:07 <tgeeky> mauke: I hope that wasn't informative
08:31:25 <merijn> tgeeky shows e right tick, a roof and logical negation
08:31:40 <mauke> merijn: good. what do you see here: Š
08:31:47 <tgeeky> I see an A with a tilde above it, a copyright, an lowercase a with a hat, and a logical negation
08:32:22 <merijn> S with inverted roof (maybe it's curved rather than angled, hard to tell)
08:32:24 <mauke> tgeeky: your client interprets utf-8 as latin-1 or something
08:32:51 <tgeeky> mauke: it's Windows.
08:32:59 <tgeeky> windows -> cygwin -> irssi
08:33:08 <mauke> merijn: you're reading things correctly but what you sent looked like a broken bar (| with a hole in the middle)
08:33:43 <merijn> mauke: When you copied it to ask the question I also saw a broken bar
08:34:11 <merijn> Then again, I don't believe there's an encoding setting for IRC...
08:34:12 <mauke> yes, because your client works fine for reading
08:34:27 <merijn> Currently my client is set on auto-detect
08:34:40 <merijn> Changed it to UTF-8 now, let's see what happens if I copy again
08:34:51 <quicksilver> IRC is just streams of bytes, but a strong defacto convention these days to treat them as utf-8
08:34:52 <merijn> 
08:34:55 <quicksilver> encoding isn't part of the protocol.
08:35:07 <mauke> <merijn> ¦
08:35:11 <merijn> damn
08:35:34 <rwbarton> ooh, can I play? Š
08:35:35 <merijn> I wonder what encoding it's sending...
08:36:12 <Na-Fiann> ßðđðħe¶æßðđħn↓ĸ→łßđ¢“
08:36:15 <Na-Fiann> yaaay
08:36:17 <Na-Fiann>  :p
08:36:21 <rwbarton> > text "Š"
08:36:22 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
08:36:22 <Na-Fiann> sorry, I'll leave now
08:36:28 <rwbarton> blah
08:36:33 <mauke> merijn: not utf-8
08:36:40 <mauke> you sent a single byte
08:36:54 <mauke> which my client interpreted as latin-1
08:37:43 <Na-Fiann> `
08:38:36 <mauke> merijn: ISO-8859-15
08:38:43 <mauke> a.k.a latin-9
08:45:47 <MagneticDuck> Hey, what's the best function that will delete an element in an array based on index?
08:46:06 * hackagebot string-conversions 0.1 - Simplifies dealing with different types for strings  http://hackage.haskell.org/package/string-conversions-0.1 (SoenkeHahn)
08:46:14 <mauke> none
08:46:21 <MagneticDuck> Okay.
08:46:25 <MagneticDuck> Should I just make one, or what?
08:46:29 <mauke> what do you mean by "delete"?
08:46:36 <MagneticDuck> I mean:
08:46:46 <MagneticDuck> delete [1, 2, 3, 4] 2 == [1, 3, 4]
08:46:54 <MagneticDuck> Actually,
08:46:59 <mauke> arrays don't change size
08:47:07 <MagneticDuck> Sorry, meant list.
08:47:34 <mauke> oh, dunno. something with splitAt maybe?
08:47:43 <MagneticDuck> Yeah, I could just do that.
08:47:51 <MagneticDuck> I was wondering if there was anything in Prelude.
08:47:54 <mauke> > splitAt 4 "foobar"
08:47:54 <lambdabot>   ("foob","ar")
08:48:07 <MagneticDuck> Yeah, I could do this:
08:48:10 <mauke> > fmap (drop 1) $ splitAt 4 "foobar"
08:48:10 <lambdabot>   ("foob","r")
08:48:20 <mauke> > uncurry (++) . fmap (drop 1) $ splitAt 4 "foobar"
08:48:22 <lambdabot>   "foobr"
08:48:32 <albel727> > drop
08:48:33 <lambdabot>   Overlapping instances for GHC.Show.Show
08:48:33 <lambdabot>                              (GHC.T...
08:48:40 <albel727> :t drop
08:48:41 <lambdabot> forall a. Int -> [a] -> [a]
08:49:10 <albel727> :t splitAt
08:49:10 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:49:11 <MagneticDuck> > let (deleteInd xs ind = (take (ind - 1) xs) ++ (drop ind xs)) in deleteInt [1, 2, 3, 4] 2
08:49:12 <lambdabot>   <no location info>: parse error on input `='
08:50:49 <MagneticDuck> Okay, cool.
08:51:05 <adnauseam> guys does this look ok:
08:51:05 <adnauseam> addToPhoneBook :: PhoneName -> PhoneNumber -> PhoneBook -> PhoneBook
08:51:06 <adnauseam> addToPhoneBook name pnumber pbook = Assoc.addToAL (pname,pnumber) pbook
08:51:38 <adnauseam> s/name/pname
08:54:12 <dhun_233> hello everybody, I made the strange observation that I can now read first year math books, after I spent two years doing haskell which I could not read before
08:56:07 * hackagebot universe-th 0.0.0.3 - Construct a Dec's ancestor list.  http://hackage.haskell.org/package/universe-th-0.0.0.3 (JonathanFischoff)
08:57:05 <srhb> When people yell about monad fail, is the grudge with those monads that use error, or the fail mechanism in general?
08:57:28 <quicksilver> one grudge is that not all monads have a sensible notion of failure
08:57:35 <quicksilver> so it doesn't make sense to have it as a method in all monads.
08:57:46 <srhb> And it must be there for all monads as it is now?
08:57:50 <quicksilver> second grudge is the arbitrariness of giving it a string parameter.
08:58:00 <srhb> Ah yes. That does seem strange.
08:58:17 <quicksilver> but wanting to convey some information with the failure is natural
08:58:23 <quicksilver> and there is no obvious universal type
08:58:35 <quicksilver> and when it was designed such mechanisms as fundeps or type families didn't exist
08:58:40 <cmccann> I think "using error for monads without a sensible implementation, because it's required to be there" covers everything pretty well
08:58:46 <quicksilver> so it's possible to understand why that compromise might be selected.
08:58:57 <srhb> I see.
09:01:19 <acowley> Does anyone know how to stop ghc-mod from making my favorite keyboard navigation commands open selections?
09:01:24 <acowley> (emacs)
09:02:17 <pqmodn> is there a consensus on a better approach to error handling? when is Either not sufficient?
09:05:07 <acowley> pqmodn: Maybe "not sufficient" isn't the right question. One might use error directly, for example, if there is no possible recovery.
09:05:47 <ChristianS> pqmodn: Either is fine, especially in a library, i would say. in app code, when i don't want to catch it, i just use error.
09:06:49 <pqmodn> ChristianS: that makes sense, i was thinking in terms of libraries. yeah, in app code i agree.
09:08:13 <pqmodn> acowley: by not sufficient, i meant i've seen other mechanisms like Error monad and exceptions but i'm not sure if one subsumes another
09:08:13 <quicksilver> pqmodn: error might be appropriate for things which should be impossible (that is, if this happens there is *bug* in the library)
09:08:43 <ChristianS> pqmodn: or if the error reason is so obvious it doesn't need a description, you can use Maybe instead of Either.
09:08:54 <quicksilver> arguably if there is a bug in the library then there is no point continuing because everythign is suspect
09:09:00 <quicksilver> however this is a fairly hardline view :
09:09:01 <quicksilver> :)
09:09:25 <quicksilver> pqmodn: exceptions are very much like the Error monad except they are "built-in" to the IO monad
09:09:32 <quicksilver> they're like "IO's secret hidden Error monad"
09:09:41 <quicksilver> and they have some kind of subtyping trick
09:09:51 <quicksilver> which is a bit like java's exception hierarchies
09:09:55 <acowley> pqmodn: other than asynchronous exceptions, these are all viable options with their advantages and disadvantages. That's why I think trying to find the most general isn't the right strategy. Use Maybe if there's one failure mode, error if you can't recover, Either…. and so on.
09:12:11 <pqmodn> quicksilver: interesting about subtyping, i'll have to look at that. is it just qualified type classes?
09:12:30 <quicksilver> well it's just type classes, yes.
09:12:36 <quicksilver> I'm not sure what you mean by qualified.
09:12:47 <Eduard_Munteanu> "subtyping"
09:12:56 <quicksilver> there is no reason why you couldn't use the same trick with Either
09:13:21 <pqmodn> oh, instance (Exception a) => SpecificException a where ...
09:13:28 <quicksilver> the "trick" part is that exception handlers infer their own type and automatically only catch the right kind of exceptions
09:13:37 <quicksilver> which is cute, when it works without extra annotation.
09:14:34 <Eduard_Munteanu> I think the idea is getting an open (one which you can add to) set of exceptions, no?
09:15:05 <quicksilver> yes. But you get a hierarchy too don't you?
09:15:13 <Eduard_Munteanu> Yeah.
09:15:22 <quicksilver> so that's slightly cleverer than just an open set
09:20:41 <kallisti> if I'm using ErrorT, does it make sense to still throw async IO exceptions?
09:20:55 <kallisti> for example, for exceptions that aren't intended to ever occur except during testing and development?
09:23:32 <Eduard_Munteanu> kallisti: that doesn't seem like a really good reason. Instead, why not make things fail "gracefully" at all times?
09:23:34 <quicksilver> possibly, but you'd need a good reason why
09:23:52 <quicksilver> why not just throw a proper error which somehow encodes "Oh dear this wasn't supposed to happen"
09:24:21 <Eduard_Munteanu> E.g. if you quickcheck some function, make it handle error conditions properly even if those inputs aren't likely to occur normally.
09:24:37 <kallisti> hmm, okay.
09:26:08 * hackagebot archiver 0.6.0 - Archive supplied URLs in WebCite & Internet Archive  http://hackage.haskell.org/package/archiver-0.6.0 (GwernBranwen)
09:28:34 <kallisti> if my error type ends up having a large number of constructors, should I consider a different design?
09:29:01 <kallisti> I may have 5+ constructors
09:29:04 <redheadphones> > let xs = [1..5]
09:29:05 <lambdabot>   not an expression: `let xs = [1..5]'
09:29:44 <kallisti> perhaps use Control.Exception and make "subtypes"?
09:30:21 <quicksilver> there is nothing wrong with 5+ constructors per se.
09:30:28 <Eduard_Munteanu> kallisti: you don't have to use the same datatype to describe errors everywhere
09:30:59 <Eduard_Munteanu> In fact, you don't need Either/Error everywhere, Maybe is a sensible approach in many cases.
09:31:16 <kallisti> Eduard_Munteanu: yes, but there are upwards 5 errors that can occur in the same place.
09:31:45 * Eduard_Munteanu points kallisti to the errno(3) manpage   :P
09:33:05 <saml> i wanna web scale
09:33:36 <kallisti> ah nevermind.
09:33:39 <kallisti> I can use one constructor
09:33:53 <kallisti> with a "status code" field.
09:33:58 <quicksilver> there is nothign wrong with five constructors.
09:34:00 <kallisti> as they share a lot of information.
09:34:13 <quicksilver> however it may well make sense to share information that can be shared
09:34:21 <kallisti> yes
09:34:22 <quicksilver> however, don't use an Int status code.
09:34:27 <kallisti> of course.
09:34:29 <quicksilver> use a 5-constructor type for that :P
09:34:46 <kallisti> that was implied.
09:36:04 <adnauseam> hrm, how do i go about adding to an association list ?
09:36:09 * hackagebot ekg 0.3.0.2 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.3.0.2 (JohanTibell)
09:36:20 <mauke> ++
09:36:39 <adnauseam> thank you! =]
09:36:51 <saml> [(1,'a')] ++ []
09:36:52 <ChristianS> or : to add an item at the front. just like any list.
09:37:23 <adnauseam> an how do i remove from it ?;p
09:37:24 <adnauseam> -- ?
09:37:34 <saml> no, pattern matching
09:37:38 <saml> !!
09:37:55 <adnauseam> hrm , i'll look that up
09:38:01 <ChristianS> adnauseam: assoc lists are just lists.
09:38:10 <saml> you might need an array if you want to remove..
09:38:17 <ChristianS> and i wouldn't generally use !! on lists
09:38:48 <saml> waht do you mean by association list?
09:38:54 <saml> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.4.2.1/Data-Map.html   ?
09:38:58 <adnauseam> hrm, i'm just fiddling with the idea of a phonebook from LYAH
09:39:22 <saml> use Data.Map  it has insert and delete function
09:39:22 <ChristianS> saml: an association list is just a list of (name,value) tuples.
09:39:36 <pqmodn> adnauseam: here's a hint on removing items, filter (/= 'd') "abcdef"
09:39:48 <adnauseam> a filter!
09:39:51 <adnauseam> :o
09:39:53 <saml> or look at Data.List. it has various usaeful functions
09:39:55 <kallisti> I feel like this complicated my error structure.
09:40:01 <kallisti> ah well.
09:40:15 <kallisti> perhaps it should.
09:40:17 <saml> don't complicate things
09:40:19 <saml> make it simple
09:41:52 <kallisti> oh, simple you say? thanks.
09:41:56 * kallisti hadn't thought of that. :P
09:41:59 <ChristianS> adnauseam: for serious applications, i would indeed recommend Data.Map (or even Data.HashMap.Strict) over assoc lists, as saml pointed out.
09:42:21 <adnauseam> i'm only starting out - far from going anywhere near serious applications
09:42:56 <adnauseam> but i'll look into doing it with a hashmap and see how that goes
09:43:48 <ChristianS> hashmap might require installing the unordered-containers package. Data.Map is part of the base library so you should already have it.
09:45:11 <adnauseam> Data.Map it is!
09:57:17 <kallisti> @hoogle (<:>)
09:57:17 <lambdabot> No results found
10:01:35 <scooty-puff> given the update to unordered-containers, would using IntMap not make so much sense, if i'm just wrapping it to use with another wrapper around Int?
10:03:41 <ChristianS> scooty-puff: don't quite understand just question, but in general IntMap is better than HashMap, if you keys are Int.
10:04:40 <scooty-puff> so i have newtype Ident = Ident { unIdent :: Int }, and newtype IdentMap a = IdentMap { unIdentMap :: IntMap a }
10:04:55 <scooty-puff> i had heard, with the update to 0.2.0.0 of unordered containers
10:04:57 <scooty-puff> that:
10:05:28 <scooty-puff> The old implementation is basically IntMap (slightly improved.) The old HashMap Int a performs almost exactly as IntMap a.
10:05:44 <scooty-puff> hopefully, tibbe does not mind that i am quoting him
10:06:34 <ChristianS> scooty-puff: hmm, i recently did some tests where IntMap performed significantly better than HashMap Int.
10:07:03 <sclv> well there's some extra hashing involved
10:07:08 <scooty-puff> might depend how recent (and if pulled from git or from hackage) - looks like it was updated today
10:07:16 <scooty-puff> (on hackage)
10:07:35 <sclv> + if your ints are distinct to begin with then you might be introducing collisions where none existed before.
10:07:48 <scooty-puff> k
10:07:53 <sclv> (although tibbe might have done int hashing as a no-op -- i forget)
10:07:53 <ChristianS> well, my tests where not that recent.
10:08:00 <zero___> does anyone know if there's an easy way to work with indexes without using the !! operator?
10:08:10 <scooty-puff> and i guess the complexity is what it is - aren't IntMap's bounded?
10:08:22 <scooty-puff> O(min(n, W)) in many cases?
10:08:25 <sclv> zero___: specify how you want to use them?
10:09:02 <sclv> usually if you're working with indexes into lists, whether you use the !! operator or not, you're taking the wrong approach.
10:09:21 <sclv> but sometimes working with indexes into lists in a streaming fashion makes sense, so...
10:09:56 <zero___> sclv: sclv http://pastebin.com/mPEW75Pt
10:09:58 <mauke> The paste mPEW75Pt has been copied to http://hpaste.org/64929
10:10:43 <zero___> sclv: yes, i was thinking of using indexes in a zip list [1..] way.. but I thought that would be too troublesome
10:10:55 <rwbarton> use zip
10:11:01 <rwbarton> yes like that
10:11:23 <sclv> (cx, x) <- zip gen [0..]
10:12:39 <zero___> I guess I'll just use the zip then
10:12:42 <zero___> thanks
10:13:13 <sclv> it reduces your complexity by an order, so yeah you really should :-)
10:13:34 <pozic> Is there an option to get GHC to understand that when I am in parsing code that try means the Parsec try and not some exception type (which wouldn't fit there anyway)?
10:13:47 <rwbarton> it looks like the zip solution will end up simpler anyways
10:14:18 <sclv> ?hoogle try
10:14:18 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
10:14:18 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
10:14:19 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
10:14:31 <sclv> import System.IO.Error hiding (try) :-)
10:14:40 <pozic> sclv: that is not what I meant.
10:14:53 <sclv> -f-dowhat-i-mean-please
10:15:04 <pozic> I remember there is a feature in GHC which sort of does this.
10:15:27 <sclv> right. an import list.
10:15:56 <sclv> there was a proposal for type directed name resolution that never went anywhere because it couldn't be defined cleanly as interacting with everything else.
10:16:07 <pozic> Is it such a good thing to first build lazy lists then expect a complicated rules system to come up with the exact right optimizations only to create an optimized loop that you were thinking of anyway?
10:16:24 <byorgey> yes.
10:16:26 <pozic> That's essentially what GHC aims to deliver, but then with all kinds of edge cases.
10:16:40 <tromp__> i just registered on FP Lunch, but got no passwd email in 5 mins
10:16:40 <zero___> yes the zipping is a lot faster, and clearer too, thanks again
10:17:51 <byorgey> pozic: is it such a good thing to first build a program in an abstract language and then expect a complicated rules system to come up with the exact right transformations to create optimized machine code that you were thinking of anyway?
10:18:06 <byorgey> let's just all write directly in machine code.
10:18:49 <pozic> byorgey: the only real objection I have is that the rules system does not always work.
10:18:55 <pozic> byorgey: and that it is slowish.
10:19:08 <byorgey> pozic: compilers don't always work either.  sometimes they output really inefficient machine code.
10:19:48 <pozic> byorgey: C compilers with good register allocation parts cannot really do much wrong.
10:19:58 <gentleben> byorgey: that is not the general case
10:20:00 <pozic> byorgey: because they don't do a lot.
10:20:34 <pozic> C is a terrible language (not because of the notation, but because of its meaning).
10:20:34 <byorgey> my point is, there is always a tradeoff between abstraction and performance.  if you don't like it, use a less abstract language.
10:21:12 <pozic> For example STM could provide performance improvements to systems, but due to the historical bad implementations this has never materialized.
10:21:35 <pozic> So, while the language of STM is a good idea, using it in a practical system is not.
10:21:50 <pozic> (until someone writes a better STM implementation)
10:22:16 <kallisti> the problem isn't STM, it's the lack of TM support in most architectures.
10:22:30 <gentleben> byorgey: it is unlikely that you can generate more efficient machine code than a compiler in more than a handful of contrived cases
10:23:35 <byorgey> gentleben: and I would argue the same is true for programs manipulating lazy lists.
10:23:38 <rwbarton> i've seen llvm produce code that was over 5 times as fast as gcc
10:23:44 <rwbarton> so I don't see how that kind of statement is credible
10:24:21 <gentleben> byorgey: i am not sure i see the connection
10:25:08 <byorgey> I am not even sure what we are arguing about anymore.  never mind =)
10:25:14 <rwbarton> (in this case the cause was simple, gcc was not inlining aggressively enough. but the point remains--even well-established compilers like gcc are unreliable)
10:26:14 <pozic> Another problem with compilers is that they don't guarantee correctness yet.
10:27:00 <rwbarton> Nor do they solve world hunger.
10:27:34 <pozic> World hunger isn't a problem.
10:27:37 <rwbarton> (sorry, will stop feeding the troll)
10:27:53 <pozic> It provides a solution to another problem.
10:28:12 <pozic> But I suppose that's just the way the ultra-elite sees things.
10:28:23 <tgeeky> maybe if we didn't send all that food to trolls, wold hunger wouldn't be a problem!
10:28:33 <byorgey> hahaha
10:28:39 <rwbarton> tgeeky++
10:30:29 <sclv> somebody think of the trolls. for just two responses a day, you can feed and clothe a needy troll...
10:36:38 <Eduard_Munteanu> rwbarton: in a way, it's the C compilation model's fault. Link-time optimization attempts to fix some of that.
10:37:03 <rwbarton> that doesn't help for sure, but in this case it was a single .c file
10:37:10 <Eduard_Munteanu> Ah.
10:37:50 <rwbarton> though the function wasn't marked static, so maybe link-time optimization could have noticed that it wasn't used anywhere
10:37:59 <rwbarton> I mean, from any other object file
10:38:04 <oz__> can anyone dechiper this error massage? Expecting one more argument to `Num'
10:38:05 <oz__>     In the type `Num'
10:38:05 <oz__>     In the definition of data constructor `Address'
10:38:05 <oz__>     In the data type declaration for `Proposition'
10:38:05 <oz__> Failed, modules loaded: none.
10:38:55 <byorgey> oz__: Num is not a type
10:39:12 <Eduard_Munteanu> rwbarton: -O3? I'd think the compiler can emit separate inline and standalone definitions for that.
10:39:17 <byorgey> oz__: you probably have something like    data Proposition = Address Char Num String | ...
10:39:29 <oz__> yep
10:39:31 <rwbarton> I might have only been using -O2
10:39:47 <oz__> so what should I write instead of num?
10:39:58 <byorgey> oz__: well, what do you want to be stored there?
10:40:02 <Eduard_Munteanu> Ah, -O2 is quite conservative on inlining AFAIK.
10:40:07 <oz__> a number
10:40:15 <Eduard_Munteanu> (for good reasons in some cases, though)
10:40:18 <byorgey> oz__: what kind of number? an integer? a floating-point number? ...?
10:40:41 <oz__> an integer, so I guess its Int?
10:40:53 <byorgey> oz__: Int or Integer
10:41:10 <byorgey> oz__: Int is a machine-sized integer, Integer can be arbitrarily large
10:41:40 <oz__> thank you
10:41:50 <oz__> I'll try it
10:44:15 <pozic> I prefer either Integer or some fixed size Int, like Int64.
10:44:33 <pozic> Int doesn't really mean anything.
10:45:12 <Eduard_Munteanu> pozic: it does, for things such as file descriptors which scale accordingly.
10:45:36 <pozic> Eduard_Munteanu: a file descriptor shouldn't be an Int.
10:45:41 <pozic> Eduard_Munteanu: it should be a FD.
10:45:55 <Eduard_Munteanu> But yeah, generally, it's a good idea to use a known-size type.
10:45:55 <pozic> Or preferably FileDescriptor.
10:47:00 <Eduard_Munteanu> Sure, there are better ways probably. It doesn't help when interfacing POSIX though.
10:47:26 <ben> Int isn't CInt, anyway ;)
10:47:38 <Eduard_Munteanu> Hm, fair.
10:48:15 <Eduard_Munteanu> Much of that variable-sized stuff doesn't apply to Haskell, yeah.
10:53:15 <kmels> hi, ghc tells me that it could not found the module "Locale" but 'old-locale' is listed by 'ghc-pkg list'. How can i debug the problem further? here is some output http://pastebin.com/hHP3g9pm
10:53:18 <mauke> The paste hHP3g9pm has been copied to http://hpaste.org/64932
10:53:51 <rwbarton> well old-locale includes System.Locale
10:54:24 <rwbarton> hard to guess what plain old "Locale" is, surely not Haskell 98 Locale?
10:54:33 <kmels> rwbarton, could it be because I've installed two haskell-platforms?
10:54:51 <kmels> well, that line says "import Locale"
10:55:03 <rwbarton> what is "hakyll.hs"?
10:55:14 <rwbarton> is this some ancient version of something?
10:55:37 <kmels> it comes from hakyll (http://jaspervdj.be/hakyll/), the same file compiles in other computer
10:56:23 <kmels> maybe I should reinstall everything again, I did "try" some different versions
10:56:33 <rwbarton> yes I recommend that
10:56:42 <kmels> okay, cheers :)
10:56:51 <rwbarton> install ghc 7.0.4 and then try cabal install hakyll
10:57:09 <rwbarton> or...
10:57:23 <Saizan> the point is that with newer ghc the haskellXX package is hidden
10:57:43 <rwbarton> it looks like it is perhaps not only hidden, but broken?
10:57:51 <Saizan> i'd just s/Locale/System.Locale/ first
10:58:17 <Saizan> package haskell98-1.0.1.1-4d2891ad99eae334ff8234bcfbddce06 is unusable due to missing or recursive dependencies: random-1.0.0.2-f4208c3677aeaaaf41e4d36309c0b4ff <- that too
10:58:31 <rwbarton> I guess I don't really understand why you are manually compiling something from hakyll at all rather than using cabal
10:58:46 <rwbarton> but maybe this is a special hakyll-ism, since the web page does mention doing this
10:58:50 <kmels> rwbarton, I couldn't install 7.0.4, this machine is running debian lenny, a bit old I think
10:59:16 <Saizan> try calling ghc with the flag: -package-id haskell98-1.0.1.1-4d2891ad99eae334ff8234bcfbddce06
10:59:16 <rwbarton> hmm
10:59:34 <rwbarton> probably you can still install it from the binary package from the GHC web site
11:00:30 <kmels> Saizan, that works, now it reports another missing library, which I also have installed, hehe
11:01:22 <lispy> hello
11:04:16 <rwbarton> was ghc 6.12 supposed to include two versions of base?
11:04:46 <byorgey> rwbarton: yeah, I seem to recall it did
11:05:01 <byorgey> in order to help with the transition from base-3 to base-4
11:05:50 <dcoutts> rwbarton: yes
11:05:54 <rwbarton> okay
11:06:32 <dcoutts> both ghc-6.10 and 6.12 had base 3 and 4
11:07:24 <dcoutts> if you were around during the transition from base 2 to 3, you'll recall the screaming and gnashing of teath
11:07:34 <dcoutts> teath/teeth
11:10:37 <Saizan> kmels: the root of your problem seems to be that you have two installations of random-1.0.0.2
11:10:49 <Luke> I'm having an issue where i'm defining a function and then trying to call it on the next line down and it's saying source isn't available. I'm using slime to compile it and confirm it gets bound to a variable. any ideas why it'd bind correctly and then claim the source isn't available on the next line?
11:10:56 <Luke> oops wrong channel - sorry
11:11:14 * hackagebot fb 0.7.4 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.7.4 (FelipeLessa)
11:11:16 * hackagebot fb 0.7.4.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.7.4.1 (FelipeLessa)
11:11:27 <Saizan> kmels: and since ghc can't use both at once, it also can't use the packages that are built against one together with the ones built against the other, recursively
11:12:06 <kmels> Saizan, I'm on that exactly, what's the best solution? leaving the global installed and re install the packages that depend on the local one?
11:12:28 <Saizan> kmels: that's what i'd try
11:12:45 <kmels> ok, thank you Saizan
11:13:21 <Saizan> kmels: though make sure cabal doesn't go and installs random again when you reinstall the others, you can check by running --dry-run -v first
11:14:19 <hpaste> jackhill pasted “failure of cabal installl file-embed” at http://hpaste.org/64933
11:14:56 <jackhill> Hi, could someone take a look at the above error and point me in the right direction for resolving it?
11:15:21 <dcoutts> jackhill: what does ghc --info say? add it to the paste
11:16:49 <hpaste> jackhill annotated “failure of cabal installl file-embed” with “failure of cabal installl file-embed (annotation)” at http://hpaste.org/64933#a64934
11:16:59 <jackhill> dcoutts: added
11:19:42 <dcoutts>  ,("Have interpreter","NO")
11:20:00 <dcoutts> jackhill: unfortunately you need GHCi support on your platform to use TemplateHaskell
11:20:32 <dcoutts> jackhill: you'll have to look into why there isn't GHCi support on ppc for 7.0.4
11:20:56 <jackhill> Oh, okay, thanks.
11:21:26 <dcoutts> jackhill: so the error message is wrong, it's not a stage-1 issue, it's the lack of interpreter support
11:25:26 <_Mikey> Hey guys
11:25:46 <_Mikey> is there a way to generate a list of infinite random numbers outside of the IO monad?
11:27:14 <gwern> _Mikey: sure. [1..] <-- this sequence is exactly as probable as any other sequence, and pure too
11:27:15 <jackhill> dcoutts: looks like I'm out of luck for the time being: http://hackage.haskell.org/trac/ghc/ticket/4244
11:27:28 <jackhill> I guess I could try some hack with qemu…
11:27:35 <andares> hey, is there a good list of haskell problems somewhere?
11:27:44 <andares> I keep not being able to retain based on LYAH alone.
11:27:50 <_Mikey> aww
11:28:13 <gwern> _Mikey: or you could use seeds
11:28:32 <_Mikey> stdGen?
11:28:36 <andares> ooh, good point.
11:30:21 <pozic> How do find the most recent file ending in .foo in a given directory in Haskell? I.e. is there some higher level library which already does this?
11:31:07 <td123> andares: rwh has lots of practice problems
11:31:19 <td123> some of it is bitrotting though
11:31:25 <andares> bitrotting?
11:32:49 <td123> some things that the book says are outdated
11:33:36 <pozic> Even Haskell98 has bitrotted.
11:33:41 <sm> pozic: perhaps the directory package
11:34:10 <pozic> A program written for Haskell 98 doesn't work on a Haskell compiler without modifications.
11:34:21 <pozic> It is trivial to get it to work, but technically it doesn't.
11:34:47 <pozic> That's one of the disadvantages of Haskell; Common Lisp code will likely work forever.
11:35:15 <hpaste> scooty-puff pasted “cast to type class instance” at http://hpaste.org/64935
11:35:24 <scooty-puff> is this possible?
11:35:59 <scooty-puff> (without using something like SomeA = forall a . HasA a => SomeA a
11:36:01 <scooty-puff> )
11:36:49 <scooty-puff> basically i have something that logs error messages, not all error messages have location information - in that case, they just inherit the last error message's location
11:37:19 <scooty-puff> but i would prefer to to specify how the location may be contained - i.e. not f Location, or whatever
11:40:22 <scooty-puff> hmm, will just restructure it
11:41:58 <Peaker> Saizan: You still there?
11:43:26 <Peaker> Saizan: "let" was supposed to be sugar -- so I understand why type-checking needs to handle "let", but why not other redexes?
12:01:39 <cmasseraf> Hello! Anyone know of a good introduction to Formal Methos Software Verification?
12:04:10 <pqmodn> cmasseraf: dunno if its introductory or directly on-topic, but this looks promising http://www.cis.upenn.edu/~bcpierce/sf/
12:13:08 <pqmodn> is it generally true than for newtype T = C { d :: a }, that d . C == id ?
12:13:46 <pqmodn> you're just wrapping then unwrapping?
12:15:48 <Botje> yes.
12:20:08 <shachaf> pqmodn: In fact, C and d are also each == id, implementationwise. Only the type is different.
12:24:56 <monochrom> this evening I am going to the Toronto haskell meeting!
12:25:13 <monochrom> shachaf you should come to Toronto :)
12:25:49 <shachaf> monochrom: Huh?
12:26:06 <monochrom> Toronto has a haskell meeting this evening!
12:26:10 <JoeyA> Why didn't anyone tell me that there's a getOpt function in base?
12:26:11 <dolio> People get mugged in Toronto.
12:26:17 <nyingen> does xmonad have its own irc channel?
12:26:28 <bru`> nyingen:  #xmonad
12:26:50 <JoeyA> More than once have I been surprised to find features in base I didn't even know were there.
12:26:55 <JoeyA> Last one was Data.Unique, I think.
12:27:35 <JoeyA> Actually, last one was the First and Last from Data.Monoid
12:27:39 <shachaf> monochrom: If I was in Toronto or nearby, maybe I'd go!
12:27:46 <monochrom> I volunteer to inform you that base doc is installed along with GHC on your hard disk, too
12:28:03 <lpsmith> Yay for toronto haskell meetings!
12:29:12 <monochrom> <prefix>/share/doc/ghc/html/libraries/index.html
12:36:51 <rata_> hi
12:37:19 <rata_> does anyone know the associativity of (Data.Vector.//)?
12:39:31 <Phlogistique> http://mobile.twitter.com/pltalaindeb/status/177492414666252288 "I know two things about monad tutorials: 1) everyone hates them 2) they are like a monster in a spacesuit eating a warm fuzzy burrito."
12:42:17 <monochrom> you can use ghci to :info // to find out
12:44:05 <stj> this is probably a very common pattern with Maybes, but I can't find the standard function that does this: http://pastebin.com/6JVVSBjX What is the name of function?
12:44:07 <mauke> The paste 6JVVSBjX has been copied to http://hpaste.org/64936
12:44:20 <alpounet> stj, fmap
12:44:29 <stj> th
12:44:31 <stj> x
12:44:31 <alpounet> > fmap (+1) (Just 4)
12:44:32 <lambdabot>   Just 5
12:44:41 <stj> awesome :)
12:44:50 <alpounet> also often written as (+1) `fmap` (Just 4)
12:45:03 <hpc> also written as (+1) <$> (Just 4)
12:45:12 <alpounet> yeah, too
12:45:19 <hpc> or in lambdabot, (+1) . (Just 4)
12:45:26 <hpc> but don't ever use that, because it's confusing :P
12:46:41 <rata_> monochrom: I did that first, but for some reason ghci doesn't want to tell me
12:47:41 <stj> hpc: how does that work? It doesn't work in GHCi
12:48:48 <rata_> stj: you mean the one using the dot?
12:48:59 <stj> rata_: yes
12:49:05 <rata_> don't use that
12:49:07 <monochrom> then probably it's the default infixl 9
12:49:18 <rata_> thanks monochrom =)
12:49:34 <rata_> stj: that's only for lambdabot
12:49:38 <mauke> stj: import Prelude hiding ((.)); f . m = fmap f m
12:49:44 <rata_> ie, not for ghci
12:49:51 <mauke> that's how it's done
13:08:56 <WallFace> If friend tells his psychiatrist he's going to kill himself what can the psychiatrist do?
13:09:03 <WallFace> what will he do?
13:09:42 <zip> That may vary by country
13:09:53 <zip> But if it's a credible threat, I suspect they'd section him?
13:10:51 <pqmodn> i think in the US you get involuntarily admitted for 24-hour observation
13:11:00 <pqmodn> at least based on TV shows
13:12:44 <zip> I once heard that if people aren't talking specific techniques you're probably okay
13:12:59 <zip> and in my experience the one time I was serious I made sure nobody would find out so they wouldn't stop me
13:14:18 <zip> most useful thing I can think of is http://www.reddit.com/r/suicidewatch
13:16:55 <andares> pqmodn: yeah, under the Baker act.
13:17:45 <andares> hey, so I'm trying to come up with a formulation for the list of the fibonacci sequence.
13:18:07 <andares> I was thinking I'd have to use a list comprehension, but I don't think it'll do what I want.
13:18:22 <WallFace> ofcourse
13:18:28 <zip> WallFace: this may be useful: http://www.reddit.com/r/SWResources/comments/ch7jn/risk_factors_do_you_worry_that_someone_you_know/
13:18:52 <andares> I was thinking a pattern like fib x:y:ys = y+head ys or something.
13:18:53 <zip> andares: let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)
13:19:01 <byorgey> andares: anything you can do with a list comprehension you can also do without.
13:19:36 <zip> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)
13:19:37 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)'
13:19:44 <zip> oh I can't lambdabot
13:19:46 <andares> zip: whoa. but how does it deal with fibs and drop 1 fibs being different sizes?
13:19:49 <zip> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) in take 10 fibs
13:19:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
13:20:03 <byorgey> andares: they are not different sizes, they are both infinite =)
13:20:09 <zip> that's one of my favourite bits of code just because it's such a headfuck
13:20:24 <andares> but… it... whoa.
13:20:39 <andares> that is cool, thanks!
13:20:52 <zip> it works because it's lazily evaluated
13:21:07 <byorgey> andares: a more understandable method is to first write a function  (Integer,Integer) -> (Integer,Integer)  which takes  (F_n, F_n+1) and returns (F_n+1, F_n+2)
13:21:21 <zip> see also: http://www.haskell.org/haskellwiki/Blow_your_mind#Mathematical_sequences.2C_etc
13:21:25 <byorgey> andares: i.e. it takes (2,3) and gives you (3,5), or takes (3,5) and gives you (5,8), and so on
13:21:34 <byorgey> andares: then you can iterate that function
13:22:31 <byorgey> I should have said "more easily understandable".  The zipWith solution is quite understandable too, once you understand it =)
13:22:42 <kallisti> @hoogle JSON a => String -> a
13:22:42 <lambdabot> Warning: Unknown class JSON
13:22:42 <lambdabot> Prelude error :: [Char] -> a
13:22:42 <lambdabot> Debug.Trace trace :: String -> a -> a
13:22:52 <kallisti> @hoogle JSON a => String -> Result a
13:22:53 <lambdabot> Warning: Unknown class JSON
13:22:53 <lambdabot> Network.Stream failMisc :: String -> Result a
13:22:53 <lambdabot> Network.Stream failParse :: String -> Result a
13:22:58 <kallisti> oh
13:23:10 <andares> hm
13:23:32 <kallisti> found it.
13:29:57 <deggis> i guess i'm shooting myself to leg with lazy evaluation or some antipattern here http://hpaste.org/64937
13:31:25 <ben> why are you seq'ing 1
13:31:34 <deggis> goal is to have that read doubles from stdin and instantly send UDP packages. i'm somehow making that not to be realtime, packages go in big bursts
13:31:57 <deggis> ben: no reason i guess (didn't help)
13:32:31 <Saizan> buffering issues have nothing to do with lazy eval
13:32:48 <Saizan> is there a flush for sockets?
13:32:54 <stj> stj: I don't quite get why doesn't this compile -- http://pastebin.com/ranDEyAg -- can someone help out?
13:32:57 <mauke> The paste ranDEyAg has been copied to http://hpaste.org/64938
13:33:09 <deggis> my wording isn't anywhere correct, but that flushing might help!
13:33:56 <rwbarton> stj, you're not using the right foldr
13:34:16 <stj> rwbarton: Reid Barton?
13:34:27 <rwbarton> yes
13:34:36 <Saizan> Peaker: it's a matter of expectations, really
13:34:37 <stj> awesome :)
13:34:40 <Azel> stj: Given you imported Data.Foldable qualified, if you don't qualify foldr you using the one from Prelude
13:34:43 <pqmodn> when reading code like "fmap f = MaybeT . fmap (fmap f) . runMaybeT", is there a technique for understanding it besides working it out on paper? ideally i could click on one of the fmap calls to see which Functor instance its defined by.
13:35:03 <stj> I see, thanks
13:35:40 <alpounet> pqmodn, the types
13:36:15 <alpounet> "what's the type of runMaybeT? ok then, what type does it imply on "fmap (fmap f)" when composed with" etc
13:36:39 <Saizan> Peaker: for "(\(x : t) -> e) a" you don't expect the typechecking of the lambda to depend on what "a" is, because we expect modularity, while let .. = .. in .. is a single construct and we expect the compiler to see through it
13:36:54 <pqmodn> alpounet: hmm, is there a way to have the compiler annotate subexpressions for me?
13:37:15 <deggis> Saizan: while flushing might help (didn't find flushing for sockets yet), i guess those printed lines should come realtime as well (they're not). so i guess there's something else i'm doing wrong
13:37:16 <pqmodn> alpounet: i guess i can add annotations to check if i've mentally inferred them correctly
13:37:38 <alpounet> hmm there's an extension with "?" i believe, but that's more for variables
13:37:42 <ClaudiusMaximus> deggis: buffering on stdin?
13:37:43 <alpounet> i guess the best is to do it by hand
13:37:49 <alpounet> @type runMaybeT
13:37:50 <lambdabot> Not in scope: `runMaybeT'
13:37:52 <pqmodn> fair enough
13:37:54 <alpounet> yeah hm
13:37:59 <deggis> ClaudiusMaximus: ah, that could be
13:38:12 <alpounet> you can just type :t fmap (fmap f) . runMaybeT in ghci
13:38:15 <Saizan> deggis, ClaudiusMaximus: i'd expect stdout would matter more
13:38:20 <pqmodn> :t Control.Monad.Trans.Maybe.runMaybeT
13:38:21 <lambdabot> forall (m :: * -> *) a. Control.Monad.Trans.Maybe.MaybeT m a -> m (Maybe a)
13:38:24 <Saizan> deggis: there's hFlush for Handle's
13:39:49 <deggis> hFlush doesn't work for input handles (the output is flowing steadily from C prog). but the buffer size might be an issue
13:42:34 <Saizan> hFlush stdout after the print l doesn't make a difference?
13:42:49 <deggis> there's no stdout involved
13:43:08 <Saizan> print uses stdout
13:43:47 <deggis> Saizan: uh, true. so true
13:45:00 <deggis> no improvements with that. setting stdin buffering to NoBuffering didn't help either
13:47:30 <Saizan> deggis: what are you seeing exactly, and what do you expect instead?
13:48:09 <Peaker> Saizan: thanks
13:49:01 <deggis> Saizan: i'm expecting several printed values & sent udp packages per second, instead i'm first waiting 10s and then seeing many printed lines & sent udp packages at once, then again waiting
13:49:50 <Saizan> deggis: so you're feeding this program with another?
13:50:07 <deggis> i'm not familiar with network sockets and reading stdin. i'm asking since there could be something "don't do that" in many places :)
13:50:30 <Saizan> there's nothing obviously wrong in your program
13:50:48 <deggis> Saizan: yes, essentially a C program that prints "0.15123" and such lines every 0.3 s or so
13:51:10 <Saizan> deggis: are you flushing after each number in your C program?
13:52:10 <deggis> at least they appear at console as a steady flow. no explicit flusing, it seems
13:52:26 <acowley> any ghc-mod users around?
13:52:30 <deggis> i'll try adding flushing there
13:52:32 <Saizan> console is one thing, piping into another program is another
13:53:00 <Saizan> on the terminal the default is line-buffering, in a pipe it's block-
13:53:26 <deggis> uh. that would explain everything
13:54:19 <deggis> and that was it
13:54:53 <Saizan> cool :)
13:55:17 <deggis> i salute to you. thanks :)
13:55:34 <Saizan> np
13:58:47 <deggis> Saizan: unnecessary details: the setup that you assisted to get working is this: C program reads music beats from Jack, prints them, Haskell prog reads those and sends UDP packages to nodejs UDP DMX abstraction. in short: 50 Led PAR lights are going to according to music this weekend in one party
13:59:06 <deggis> and yes, there's easier way to do everything :D
13:59:23 <Saizan> hah, cool indeed then :)
13:59:42 <sm> I'd like cabal configure -fNOSUCHFLAG to give a warning
13:59:51 <drdo> deggis: You clearly need more stuff, that's not Web Scale enough!
14:00:11 <pqmodn> if MaybeT had its type parameters reversed, ie MaybeT a m, could you still somehow express what used to be "Monad (MaybeT m)"?
14:00:20 <deggis> drdo: yes! we need clouds
14:00:57 <qued_____1> rev (x:xs) = (rev xs) : x                error: Expected type: [a]     In the expression: (rev xs) : x
14:00:58 <qued_____1> Why ?
14:01:17 <Saizan> pqmodn: nope, you'd have to wrap it with another newtype to reverse the arguments and make that a Monad
14:01:29 <qued_____1> xs is a list, and x is a list-element .... what's wrong?
14:01:38 <Saizan> ?type (:)
14:01:38 <ClaudiusMaximus> :t (:)
14:01:38 <lambdabot> forall a. a -> [a] -> [a]
14:01:39 <lambdabot> forall a. a -> [a] -> [a]
14:01:43 <drdo> qued_____1: rev xs ∷ [a] , x ∷ a, (:) ∷ a → [a] → [a]
14:02:40 <pqmodn> Saizan: ah, thanks
14:02:56 <Saizan> qued_____1: (:) takes an element and a list, not two lists or two (element or list)
14:03:24 <Saizan> qued_____1: you need:  rev xs ++ [x]
14:03:28 <pqmodn> drdo: how do you get unicode output from ghci like that?
14:03:52 <drdo> pqmodn: I don't, i typed that
14:05:10 <pqmodn> drdo: did you memorize the key combos? i've been copy/pasting unicode symbols and its too tedious
14:05:17 <drdo> pqmodn: xmodmap
14:05:27 <pqmodn> drdo: sweet, thanks!
14:05:33 <drdo> I have nice keys for such symbols since i used them all the time
14:05:37 <Guest73645> when will code pasted at hpaste will be deleted from the servers / not be accessible?
14:05:37 <drdo> *use
14:05:57 <qued_____1> Saizan: but x is a list-element in (x:xs), and "rev xs" gives a list? not this way?
14:06:56 <Saizan> qued_____1: the order of arguments matter, the first argument has to be the element, also because the resulting list will have it in front
14:06:59 <drdo> qued_____1: (:) takes an element and a list, you're giving it a list and an element
14:07:09 <qued_____1> ah okay.... (:) only works for element:list,    not for list:element
14:07:19 <qued_____1> ty
14:08:02 <qued_____1> drdo: any std operation for the symmetric version of (:) ?
14:08:13 <mauke> ++
14:08:17 <qued_____1> okay...
14:08:20 <Eduard_Munteanu> pqmodn: you probably want to use something like SCIM with the Latex (or even custom) tables.
14:08:29 <Eduard_Munteanu> Although I don't think there's an ideal solution for that.
14:08:45 <Saizan> Guest73645: it stays there forever
14:09:24 <drdo> qued_____1: You don't want to do that, do you understand how linked lists work?
14:09:33 <Guest73645> saizan: thanks
14:09:50 <Veinor> qued_____1: you mean like
14:09:53 <Veinor> > [1,2] ++ [3,4]
14:09:55 <lambdabot>   [1,2,3,4]
14:10:02 <pqmodn> Eduard_Munteanu: i'm unfamiliar with both, what distinguishes SCIM from xmodmap?
14:11:00 <Eduard_Munteanu> pqmodn: you don't bother setting up combos, you just type e.g. \alpha for α and you get a window with possible substitutions as you type.
14:11:06 <drdo> pqmodn: xmodmap just lets you defined keybinds, i.e. what character a key combination should be
14:11:10 <drdo> *define
14:11:16 <drdo> Don't know about SCIM
14:11:17 <pqmodn> oh, nice
14:11:43 <drdo> Eduard_Munteanu: What's the point of that though? That'll be harder to type than just not using unicode
14:12:15 <pqmodn> more characters to type but less memorization?
14:12:20 <Eduard_Munteanu> drdo: it helps if you know Latex equivalents and you don't need to memorize arbitrary key combos
14:12:37 <Eduard_Munteanu> Besides you get some autocompletion support.
14:13:00 <drdo> Eduard_Munteanu: Eh, i use this constantly, so any memorization overhead is negligible
14:13:06 <Eduard_Munteanu> You can certainly set up a few combos, but I guess that's a problem if you want to use lots of symbols.
14:13:45 <Eduard_Munteanu> I should convert the agda-mode symbol table to SCIM sometime.
14:15:54 <drdo> Eduard_Munteanu: Almost all AltGr combinations are free to use, so i might as well use them
14:21:28 <hpaste> fiskan pasted “loop” at http://hpaste.org/64939
14:26:15 <rostayob> not strictly an haskell question: what name do I have to search for algorithms that measure the similarity between two variable-length strings?
14:26:25 <rostayob> e.g. like hamming distance but for variable length
14:26:57 <hpaste> fishie pasted “test” at http://hpaste.org/64940
14:27:06 <tromp__> edit distance
14:27:12 <path[l]>  Levenshtein distance
14:27:12 <path[l]> ?
14:27:29 <rostayob> oh damn, of course. I actually have implemented that more than once...
14:27:55 <rostayob> path[l], tromp__: thanks
14:28:01 <path[l]> sure
14:31:50 <adimit> @pl \a b -> f (p a b)
14:31:50 <lambdabot> (f .) . p
14:33:42 <adimit> does lambdabot compile with GHC 7.0.4?
14:34:36 <adimit> well, it doesn't for me. While compiling Plugin.Pl.Common, I get tons of "Assembler messages" like "Error: .size expression for PluginziPlziCommon_operators19_entry does not evaluate to a constant"
14:34:44 <adimit> no idea what to do about tha.
14:50:46 <lorem0> hello all. is there a way to put GHC 7.4 into a standards-complaint mode so it will accept, for example, programs where Num a implies Show a?
14:52:00 <shachaf> lorem0: Not as far as I know. :-(
14:52:16 <lorem0> it's pretty ridiculous
14:52:33 <lorem0> only one haskell compiler worth using and it doesn't even have the standard prelude
14:52:42 <shachaf> Embrace progress! Standards are for ivory-tower languages like C.
14:52:53 <adimit> lorem0: just use 7.0.4.
14:52:55 <sclv> just wait a bit.
14:52:57 <lorem0> not sure how people can write software and expect it to keep working over point releases
14:53:01 <sclv> and they will update the standard!
14:53:17 <ivanm> lorem0: the Show requirement has been a wart for quite a while...
14:53:18 <adimit> to be fair, Num implying Show is pretty silly.
14:53:27 <Veinor> ghc: the actual haskell standard
14:53:27 <sclv> actually, as i recall, you can just use the haskell98 package
14:53:33 <Veinor> it's the haskell standard that doesn't comply with ghc!
14:53:45 <sclv> except that one instance might be the single exception.
14:53:56 <lorem0> sclv: doesn't seem to work with -hide-all-packages -package haskell98
14:54:03 <sclv> the num instance?
14:54:07 <lorem0> aye
14:54:11 <sclv> yeah. i think they made an exception just for that.
14:54:19 * lorem0 bursts
14:54:20 <sclv> because doing otherwise would have been mad work.
14:54:32 <sclv> it's freaking easy to add your own show constraints where necessary though.
14:54:38 <sclv> and the resultant code is still h98 compliant
14:54:48 <sclv> so it doesn't kill cross-compat at all!
14:55:03 <lorem0> it just breaks even the most conservative existing code
14:55:04 * mgsloan thinks that breaking changes like that should have been an excuse to do a more sweeping revamp
14:55:08 <sclv> nope.
14:55:23 <sclv> it just breaks existing code that didn't have show constraints to begin with.
14:55:42 <sclv> and were written with functions that showed polymorphic nums
14:55:49 <mgsloan> yes, but still breaking changes.  I've forked a number of projects fixing it
14:55:50 <drdo> Break everything and do a cleanup of base!
14:56:01 <lorem0> right, programs written strictly to the standard just released a year ago don't work
14:56:06 <sclv> drdo: its called idris :-)
14:56:20 <mgsloan> Yeah, if you break some stuff, might as well break everything, and maybe provide an automated fixer utility
14:56:37 * hackagebot xturtle 0.1.4 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.4 (YoshikuniJujo)
14:57:28 <ClaudiusMaximus> http://www.haskell.org/pipermail/libraries/2011-November/017137.html has a little discussion about the awkwardness involved in duplicating the Num class
14:57:57 <lorem0> the problem is that haskell's type classes have the same fragile inheritance problem as you get in your typical OO language.. if the hierarchy is "wrong", there's no way to fix it later without smashing everything
14:58:31 <mgsloan> I really really want something like HaRe (Haskell refactorer), that has a specification format for rewrite rules to apply.  Then, breaking updates to libraries can be paired with a set of upgrade rewrites.  It doesn't need to do all the work, but this would encourage not being shy about changing names that should really change
14:59:28 <ivanm> people actually relied on that behaviour?  I think I've used the Num implies Eq, but not Num implies Show :s
14:59:34 <mgsloan> So, GHC 7.4.1 could be released with rules to transform (Num a) => (Num a, Eq a, Show a)
14:59:46 <mgsloan> Yeah, I saw Eq show up more
15:00:05 <lorem0> mgsloan: that's a pretty absurd solution to what should be a non-problem
15:00:06 <drdo> I fail to see why Num ⇒ Show is sensible
15:00:10 <lorem0> just implement the standard, not that hard
15:00:28 <mgsloan> lorem0 - that's not an absurd solution.
15:00:44 <mgsloan> this is a general solution that solves an entirely other class of problems as well
15:01:01 <mgsloan> and grants library developers a degree of flexibility they've never had before
15:01:24 <lorem0> drdo: it's not
15:01:57 <lorem0> mgsloan: i'd just be happy if i had libraries to use in hackage that weren't marked experimental and had build failures whenever a new slightly-major version of ghc was released
15:02:18 <mgsloan> One issue in this particular case is that (Eq / Show) aren't actually needed.  Now my solution is getting more absurd - speculatively compile the module without Eq / Show, and parse GHC errors to find out which declarations need the constraints added
15:02:32 <mgsloan> I already have code that does most of the work for this, sans the actual code edit
15:02:59 <drdo> I actually dislike language standards
15:03:34 <drdo> They get in the way of progress
15:04:18 <pqmodn> but not having a standard results in 45 different LISPs, which deters progress in other ways
15:04:23 <lorem0> in the same way laws against murder get in the way of progress
15:04:29 <mgsloan> lorem0: GHC hasn't had breaking changes like this for a long while.  I am totally in favour of this change, as it improves the language.  While Haskell is a language that can be used for practical development, you have to put up with being on the frontier of an experimental language
15:04:51 <mgsloan> it's often said that haskell is avoiding success at all costs, so that it can maintain this sort of agility
15:04:56 <lorem0> mgsloan: it's been almost 15 years now
15:05:12 <mgsloan> so?  That's how fast languages move
15:05:12 <Runar> You could always use an old version
15:05:30 <mgsloan> A ton of development is still done in 40 yr old langugaes
15:05:36 <Saizan> lorem0: the standard is changing every year now :)
15:05:45 <drdo> pqmodn: I'm ok with the language being defined by an implementation and that implementation changing major version when introducing breaking changes
15:06:05 <lorem0> Saizan: what's the point of standards that are valid for only a year and that people don't care about anyway?
15:06:15 <sclv> everytime there's a new big release, lots of libraries need lots of little updates.
15:06:19 <sclv> its been like that forever
15:06:28 <mgsloan> 15yrs is a short period of time when it comes to something as core to the practice of a discipline as the actual notation used for the discipline
15:06:31 * clintm thinks of ASN.1 automatically...
15:06:51 <sclv> we have good maintainers and by the time the platform hits, usually everything core is in shape
15:06:54 <drdo> mgsloan: 15years is a short period? Are you aware of how long humans live?
15:07:01 <sclv> and the old unmaintained code bitrots unless it gets love
15:07:04 <Saizan> lorem0: mostly to document stuff outside of the code implementing it
15:07:16 <jedai> lorem0: As long as the standard are mostly backward compatible, that's okay I guess
15:07:18 <sclv> so it was, and so it shall be.
15:07:23 <mgsloan> drdo - yes. A relatively short period of time.  We really have to hussle to get anything of value done
15:07:36 <Runar> Want a language that has stagnated on a standard for fear of breaking stuff? Switch to Java.
15:07:41 <sclv> 'tis the law of the jungle.
15:07:56 <lorem0> Runar: at least the libraries work
15:08:03 <Runar> for some value of work
15:08:05 <sclv> sunrise, sunset. swiftly flow the catamorphisms...
15:08:13 <drdo> I don't see the problem really, if you want to keep using 10 year code without doing a few easy changes, just use an old version
15:08:33 <lorem0> drdo: it's one year old code
15:08:41 <jedai> lorem0: Yes, and a lot of them would be much easier to use if they agreed on a support of closures a long time ago
15:08:45 <Runar> The problem comes when you want to mix new and old code
15:08:51 <lorem0> jedai: but they work!
15:08:54 <sclv> one point release into another, filled with hylos and um..
15:09:00 <lorem0> jedai: you tried doing work with xml in haskell lately?
15:09:04 <jedai> lorem0: Just like Cobol libraries !
15:09:09 <Runar> work? or compile?
15:09:16 <lorem0> Runar: work. do you use java?
15:09:23 <Runar> Yes, unfortunately.
15:09:53 <jedai> Runar: Work, Java can't afford to break any major libraries (given the industrial use)
15:10:32 <jedai> lorem0: Not really, but it didn't seems to be such a moving area to me ? What was broken recently ?
15:10:58 <sclv> industrial users usually just stick to two-versions-ago java compat anyway :-(
15:11:28 <jedai> sclv: Yes, and their code works.
15:11:45 <sclv> that's debatable.
15:11:58 <pqmodn> jedai: what's the value of backward compatibility if users don't care to upgrade anyway?
15:12:15 <jedai> But I would argue that an enormous majority of the code on Hackage wasn't broken by GHC changes, though the few breakages hurts
15:12:17 <sclv> or at least far from universal
15:12:30 <jedai> sclv: I didn't say they worked _well_
15:13:05 <lorem0> part of the reason hackage has so much breakage is that you can't attract serious users if the community doesn't take standards and compatibility seriously
15:13:16 <jedai> pqmodn: You don't understand, they upgrade, they just upgrade from a 15 yo version to a 10 yo...
15:13:28 <mgsloan> Ideally we can come up with a nice set of well thought / integrated core libraries, consolidating the experiences accumulated over the past 15 years of FP development.  Or at least, a large, quality set of libraries separated from the simpler base.
15:14:05 <Saizan> lorem0: it's not like compatibility gets broken on a whim
15:14:15 <jedai> That was supposed to be the Haskell platform but it wasn't very ambitious, not enough for most
15:14:16 <Saizan> lorem0: but some warts need to be fixed
15:14:46 <mgsloan> lorem0: serious users can either afford the day, max, to pay one engineer to fix the problems, or they can remain on a prior version of GHC
15:15:07 <pqmodn> jedai: i understand that part, but why not just upgrade to the latest? i've see it before, i work on a Java 1.4 codebase that just went to 1.6, but i don't understand the reason to stay perpetually 10 years back when you have backward compatibility.
15:15:08 <jedai> so now we have "nirvana", which is more Yesod-centered than anything else, I guess ?
15:15:11 <mgsloan> newer versions breaking your code is just one of those things software developers put up with
15:15:41 <mgsloan> (e.g. with libraries)
15:16:34 <jedai> pqmodn: Because old versions have been "tested extensively" (which mostly means that their mistakes were corrected in later versions but most directions don't see it that way)
15:18:39 <jedai> The Haskell community is a bit strange about that, they would like their platform to be more stable, but on the other hand they often install the latest GHC instead of waiting for the next iteration of the Haskell platform at least or even a bit more like most communities do when new versions of their languages are released
15:19:20 <jedai> Then they complain that this untested in the wild GHC version break some packages...
15:19:28 <Saizan> heh
15:19:42 <kallisti> what exactly is the purpose of the Error typeclass?
15:19:49 <jedai> Not that I'm innocent of that either... ;-)
15:20:06 <Saizan> jedai: some complain when they are using HEAD
15:20:07 <kallisti> it doesn't make any sense for my error type to have a strMsg implementation.
15:20:17 <kallisti> unless I just pick a constructor at random.
15:20:42 <Saizan> kallisti: it is/was just to cater to fail
15:20:58 <kallisti> hm, okay.
15:21:19 <kallisti> so, pick one at random, or use undefined and error? :P
15:21:22 <ezyang> What's a good amount of time to extend the deadline for TMR submissions?
15:21:26 <lorem0> kallisti: it sucks, write your own
15:21:38 <ezyang> (I only have one submission, and one possible one that needs another week)
15:21:39 <jedai> Saizan: Yes, I think in a way, we're spoiled by the language and would like to get the same independance between composant of our platform as we get between independent pure functions
15:21:40 <kallisti> uh, write my own ErrorT?
15:21:46 <lorem0> .. i would
15:22:15 <kallisti> not sure that's such a good idea.
15:22:22 <monochrom> ezyang: then, 2 weeks :)
15:22:25 <ezyang> OK.
15:22:44 <lorem0> kallisti: why not?
15:22:57 <Saizan> implementing your own ErrorT would be quite a chore if you need all the instances
15:23:12 <jedai> kallisti: You can use Failure (though I don't have any idea if that's a better idea)
15:23:13 <rwbarton> you still have to make some decision about fail anyways
15:23:15 <Saizan> i'd make a fake Error instance first
15:23:25 <kallisti> that's what I'm doing.
15:23:33 <hpaste> jay_gridley pasted “Testing Parsec parsers errro” at http://hpaste.org/64942
15:23:36 <kallisti> no point in using nonstandard ErrorTs just because of one instance that isn't going to be used anyway.
15:23:43 <kallisti> and Error may eventually be removed.
15:25:10 <kallisti> @hoogle Response
15:25:11 <lambdabot> Network.HTTP.Base Response :: ResponseCode -> String -> [Header] -> a -> Response a
15:25:11 <lambdabot> Network.HTTP.Base data Response a
15:25:11 <lambdabot> Network.HTTP.Base type Response_String = Response String
15:25:29 <lorem0> kallisti: i just use a monad with an error and an optional state.. no Error class to write each time i want to use it
15:25:35 <jay_gridley> hello foks, I am playing with Parsec parsers from this example (http://hpaste.org/64942), but when I try to test parser for reserved operators (reservedOp) (ex: ghci>parseTest reservedOp "+") a get this error...Couldn't match expected type `ParsecT
15:25:35 <jay_gridley>                                     s0 () Data.Functor.Identity.Identity a0'
15:25:35 <jay_gridley>                 with actual type `String
15:25:35 <jay_gridley>                                   -> ParsecT String () Data.Functor.Identity.Identity ()'
15:25:35 <jay_gridley>     Expected type: Parsec s0 () a0
15:25:36 <jay_gridley>       Actual type: String
15:25:36 <jay_gridley>                    -> ParsecT String () Data.Functor.Identity.Identity ()
15:25:37 <jay_gridley>     In the first argument of `parseTest', namely `reservedOp'
15:25:37 <jay_gridley>     In the expression: parseTest reservedOp "+"
15:25:46 <jay_gridley> why is that?
15:25:53 <kallisti> http://hpaste.org/
15:25:56 <kallisti> for large pastes.
15:25:57 <jay_gridley> oooups, sorry for that spam ^^
15:26:16 <kallisti> hmmm, I'm confused by this error:
15:26:17 <kallisti> Expected kind `??', but `Response' has kind `* -> *'
15:26:40 <kallisti> (Response /should/ be from Network.HTTP, as far as I can tell...)
15:26:53 <kallisti> and it should have 0 type parameters..
15:27:41 <lorem0> kallisti: Network.HTTP.Base is * -> *
15:27:50 <lorem0> .. Network.HTTP.Base.Response
15:27:58 <geekosaur> jay_gridley, my gues sis you're missing parens.  parseTest (reservedOp "+")
15:28:03 <Saizan> "data Response a"
15:28:36 <kallisti> I must be looking at out of date docs then?
15:28:40 <geekosaur> expected type is a parser, actual type is (String -> a parser), in "reservedOp" (which I would expect to take a string)
15:28:56 <kallisti> http://hackage.haskell.org/packages/archive/HTTP/3000.0.0/doc/html/Network-HTTP.html#t%3AResponse
15:29:18 <lorem0> kallisti: yep, out of date
15:29:23 <Saizan> jay_gridley: parseTest (reservedOp "+") "+"
15:29:35 <lorem0> kallisti: isn't a lack of backwards compatibility fun?
15:29:58 <kallisti> wait what, why does it use Show.
15:29:59 <pqmodn> heh
15:30:00 <kallisti> I don't want to use Show.
15:30:11 <jay_gridley> geekosaur, Saizan: thanks, got it :-)
15:32:22 <jedai> lorem0: That's in a library, which properly followed the pvp convention when it did it (I remember the announcement, that was _the_ breaking change, and sometimes you have to break the API if there's something wrong with it)
15:32:59 <kallisti> I don't really understand how this works without using the Read instance.
15:33:15 <pqmodn> perhaps "fixing change" is an appropriate phrase
15:33:18 <Saizan> "this" being?
15:33:29 <kallisti> Saizan: the new Response type.
15:34:22 <Saizan> kallisti: it uses the HStream class, which is nothing like Read
15:34:37 <kallisti> oh I see
15:34:40 <jedai> That was in 2008 too, not exactly a recent change, and it's not like the HTTP library changed API often, there's only two major versions
15:35:03 <Saizan> kallisti: anyhow i believe you can use Response_String to get the old String behaviour (or type at least)
15:35:26 <kallisti> that's just Response String
15:35:33 <kallisti> so isn't Show going to add quotes to my string?
15:36:40 <Saizan> don't know about that, it might
15:37:58 <kallisti> oh, no.
15:38:02 <kallisti> the body isn't even included apparently.
15:38:20 <kallisti> in the Show instance for Response a
15:38:39 <kallisti> okay nevermind this is fine.
15:40:10 <jedai> kallisti: makes a kind of sense in fact, since this Show instance is mostly for testing, so seeing the headers is probably more informative than big html pages (often minified today)
15:51:38 <incomprehensib-1> does anyone have suggestions for papers about I/O in functional programming?
15:52:47 <eyebloom> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
15:53:00 <eyebloom> That's a good place to start.
15:56:52 <eyebloom> Also google: Lazy Functional State Threads, John Launchbury
15:57:20 <eyebloom> Those are basically the originals as far as I can tell.
15:57:45 <incomprehensibly> cool, thanks
15:58:18 <eyebloom> Real World Haskell is also a good place to learn.
16:22:32 <hpaste> stj pasted “Pythagoras” at http://hpaste.org/64945
16:22:44 <hpaste> stj pasted “Pythagoras” at http://hpaste.org/64946
16:23:53 <stj> this code is about 20 times slower than C++ equivalent -- do you have an advice on how to speed up such a trivial example?
16:24:15 <DanBurton> does the c code really do a triple for loop?
16:24:27 <stj> it does
16:24:29 <DanBurton> it would be more efficient to do a double for loop
16:24:38 <DanBurton> and check if a^2 + b^2 is a square
16:24:40 <ben_m> Are you compiling with -O2?
16:24:43 <stj> sure, this is just for testing purposes
16:24:46 <stj> yes, both with -O2
16:25:46 <danharaj> It's not apparent whether the slowdown is in the list creation or in the io.
16:26:02 <rwbarton> you should add some ":: Int" somewhere
16:26:07 <danharaj> oh yeah
16:26:11 <danharaj> definitely the default is :: Integer
16:26:19 <stj> good idea, I'll try
16:26:45 <DanBurton> @hoogle ^
16:26:45 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
16:26:45 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
16:26:46 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
16:28:25 <stj> hmm, now it's about 5.5 slower... still pretty slow :/
16:28:27 <ClaudiusMaximus> a*a is probably faster than a^2  (which will probably default the 2 to Integer, and possibly not be inlined as (^) is quite big)
16:28:57 <ion> > a^2
16:28:57 <lambdabot>   a * a
16:29:00 <ivanm> ClaudiusMaximus: would it really be all that much faster?
16:29:05 <danharaj> trust not the lambdabot
16:29:08 <ivanm> @src (^)
16:29:08 <lambdabot> x ^ 0            =  1
16:29:08 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
16:29:08 <lambdabot>   where f _ 0 y = y
16:29:08 <lambdabot>         f x n y = g x n
16:29:08 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
16:29:09 <DanBurton> only one way to find out
16:29:10 <lambdabot>                       | otherwise = f x (n-1) (x*y)
16:29:12 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
16:29:19 <stj> ClaudiusMaximus: didn't help at all, still the same running time
16:29:35 <ClaudiusMaximus> then praise be to -O2 :)
16:29:49 <stj> I suppose GHC is smart enough to convert a^2 to a*a
16:30:11 <ivanm> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Real.html#^
16:30:47 <ivanm> there would be *some* overhead, but it appears to be minimal
16:31:28 <ivanm> no, wait, they have RULES that transform it for you
16:31:36 <jfischoff> are list comprehensions desugared to MonadPlus actions?
16:31:40 <ivanm> for ^2 ... ^5
16:31:52 <ivanm> jfischoff: I don't think so
16:31:57 <ClaudiusMaximus> ivanm: ooo, nixce
16:32:02 <ClaudiusMaximus> -x
16:32:02 <ivanm> I think they're desugared into concatMap, filter, etc. directly
16:32:03 <danharaj> jfischoff: they're not
16:32:26 <danharaj> Someone pointed out that they're more efficient than equivalent monadic actions because they desugar into a form that gets stream optimizations.
16:32:50 <stj> so basically there's no help, I have to accept that Haskell is ~ 5 times slower? :(
16:32:54 <danharaj> not yet
16:33:20 <danharaj> I'm wondering if there are gains to be had by using unboxed types.
16:33:20 <DanBurton> stj: 5x slower for this particular use case
16:33:27 <jfischoff> danharaj: makes sense, but there goes my idea
16:33:40 <danharaj> Which is no longer Haskell but GHC Haskell but meh same difference.
16:33:41 <ivanm> put it this way: is the algorithm exactly the same?
16:34:19 <ivanm> danharaj: doesn't -O2 do that?
16:34:22 <stj> yes, it is
16:34:23 <Saizan> stj: print uses Show, and Show is not exactly meant to be fast
16:34:44 <ivanm> stj: are you using Int or Integer ?
16:34:58 <ivanm> Saizan: oh, so use the stuff from Numeric ?
16:35:03 <danharaj> ivanm: I'm not sure. I wouldn't be surprised. Really to optimize this we should look at the core output.
16:35:05 <ben> removing print doesn't seem to make it faster
16:35:06 <hpaste> stj pasted “New version” at http://hpaste.org/64947
16:35:11 <rwbarton> you're not going to be printing that many things
16:35:30 <ivanm> that's going to keep [1..500] in RAM...
16:35:31 <ClaudiusMaximus> some of the [1..500] will probably be kept around as a list in memory, when it could be better recomputed afresh each time
16:35:32 <stj> all right, printing/showing is definitely not the bottleneck... nothing changed much
16:35:45 <ben> Did you post the C++ version?
16:36:09 <hpaste> stj pasted “Here goes the C++ version” at http://hpaste.org/64948
16:36:14 <ben> cheers
16:36:38 <jfischoff> @source sum
16:36:38 <lambdabot> sum not available
16:36:41 <ivanm> stj: so in C++ you're also going (using pseudocode): for a <- xs; for b <- xs; for c<- xs; ... ? (i.e. nested loops)
16:37:00 <DanBurton> yes that's what he said earlier
16:37:10 <stj> yes, just nested loops, there are no arrays/lists
16:37:19 <ivanm> I think using explicit forM + guards might improve it, as you won't have the list concatenation (if you go back to printing individual values)
16:37:43 <ivanm> yeah, it's not quite the same due to repeated list concatenation
16:38:08 <ivanm> @hoogle forM
16:38:08 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
16:38:08 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
16:38:09 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
16:39:19 <acowley> what list concatenation?
16:40:03 <acowley> I would hope the only list in that program is the [1..500]
16:40:06 <ClaudiusMaximus> personally i'd try this dirty fragile hack that's liable to break when ghc gets more clevers to force not sharing the lists: ... | a <- [1..500], b <- [a+1-a..500], c <- [b+1-b..500], ...
16:40:07 <pqmodn> i think he meant the haskell version is building a list and summing it
16:40:35 <DanBurton> ClaudiusMaximus: o_O interesting..
16:41:04 <acowley> shouldn't sum deconstruct the list its fed while the comprehension is building it?
16:41:56 <pqmodn> yes, and the C implementation is not constructing/destructing.
16:42:19 <acowley> well, what I mean is that it shouldn't be constructed at all if everything fires properly
16:42:38 <stj> nothing interesting in profiling report - main takes 100% time
16:42:43 <danharaj> 'd really like to see the core output
16:42:52 <acowley> ClaudiusMaximus: that's the Haskell version of adding a ?foo to a URL to defeat caching
16:43:34 <rwbarton> is there a way to see the post-RULES code? or does that not really make sense
16:43:44 <jfischoff> does GHC ever convert recursive calls into direct jumps? Can it deduce that type of optimization?
16:43:57 <danharaj> stj: compile with the flag -fext-core and paste the .hcr file ghc produces.
16:44:03 <pqmodn> jfischoff: isn't that just tail call optimization?
16:44:44 <jfischoff> could be. I don't really understand what tail call optimization is exactly
16:45:06 <hpaste> stj pasted “Core outpuj” at http://hpaste.org/64949
16:45:12 <acowley> it's when you "convert recursive calls into direct jumps" :P
16:45:26 <jfischoff> well there you go :)
16:45:41 <ben> ClaudiusMaximus: wow, that took it to 20% slower than C for me
16:45:59 <byorgey> jfischoff: it's not as relevant as you would think given the GHC runtime's non-traditional organization.
16:46:04 <danharaj> ben: wow really? that pretty much solves it.
16:46:04 <acowley> oof, sharing bites again
16:46:12 <byorgey> jfischoff: it doesn't work like you might be used to, with function calls pushing a frame onto a stack, etc.
16:46:54 <jfischoff> byorgey: because of lazyness, or for additional reasons?
16:46:57 <ben> is ghc-core the "best" way to manually look at core to figure out performance issues?
16:47:01 <byorgey> it uses highly optimized graph reduction.  I don't really know much of the details though.
16:47:17 <byorgey> jfischoff: mostly because of laziness, yes
16:47:38 <acowley> ben: the profiler is usually the best first step to at least know what core you might want to look at
16:47:58 <ben> yeah I meant compared to -fext-core
16:48:03 <ben> or whatever else there might be :)
16:48:11 <acowley> oh, sorry
16:48:37 <ben> i should have clarified meant the 'ghc-core' tool
16:48:40 <danharaj> I didn't realize -fext-core was not the same output as ghc-core :3
16:48:42 <acowley> I can't say what the best is, but ghc-core is what I use
16:49:37 <hpaste> stj pasted “C++ version with linked list” at http://hpaste.org/64950
16:49:49 <stj> Haskell still 4x slower :/
16:50:49 <tgeeky> clearly someone hasn't numberwang.
16:50:52 <danharaj> why does sharing kill the performance?
16:50:54 <andares> hey, I'm trying to construct the sieve of erosthenes in haskell.
16:50:59 <Jafet> stj: perhaps the flux capacitor is broken.
16:51:14 <andares> so I was going to have something like let sieve = 2 : filter (\z -> z `mod` (head sieve) /= 0) (tail sieve)
16:51:37 <andares> so basically, start with the front of the list "sieve" being 2, then have the rest of the elements be that mod the head etc.
16:51:46 <quintessence> danharaj: in order to share the list the list has to exist in the first place, so it can't get fused away into a loop
16:51:55 <danharaj> ah I see.
16:51:56 <andares> so that recursively, it's 2: (next prime after 2) : recurse with everything filtered out that mods 2 evenly, etc.
16:51:59 <acowley> danharaj: I would guess that without sharing you might avoid building the [1..500] list altogether. With sharing, you do build it and then must follow pointers as you traverse it each time.
16:52:06 <andares> but I don't know the construction that I want to use.
16:52:19 <danharaj> I'm surprised GHC shares like that, since it doesn't really like sharing in most contexts.
16:52:32 <acowley> it's sharing because the programmers asked for it
16:52:48 <danharaj> how did they ask for it :\
16:52:56 <acowley> GHC doesn't do CSE which would add more sharing than you asked for, but if you name an intermediate value and re-use the name, you've asked for sharing
16:53:03 <ben> uhm
16:53:15 <Jafet> A 4x slowdown seems par for the course.
16:53:33 <danharaj> oh
16:53:38 <danharaj> they did ask for sharing
16:53:57 <ben> -fext-core makes my ghc panic :'(
16:53:58 <rwbarton> how?
16:54:08 <danharaj> let xs ....
16:54:38 <stj> ben: did really ClaudiusMaximus's hack work? it doesn't work for me
16:55:59 <ben> stj: oh, that and forcing the numbers to be Ints instead of Integers, sorry
16:56:23 <ben> and I made it print the sum like the c++ version rather than every entry because it was scrolling my terminal away :(
16:56:23 <stj> ben: could you post your code, if you still have it?
16:56:29 <rwbarton> danharaj: oh I didn't see the explicitly shared version. assumed that stj just added a single ":: Int" somewhere
16:56:48 <tgeeky> andares: I'm thinking about it.
16:57:02 <hpaste> ben annotated “Pythagoras” with “Pythagoras (annotation)” at http://hpaste.org/64945#a64951
16:57:43 <ben> That runs in 0.178 seconds for me while the c++ version with g++ -O3 runs in 0.158 seconds
16:57:52 <andares> argh, got disconnected.
16:58:04 <hpaste> pqmodn annotated “New version” with “Much slower” at http://hpaste.org/64947#a64952
16:58:07 <ben> I didn't see an explicitly sharing version either :3
16:58:08 <andares> tgeeky: is there a way to define a list in terms of a recurrence relation?
16:58:40 <tgeeky>  andares: if I understand you right, I think so.
16:58:57 <pqmodn> andares: see the classic fib example, http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Canonical_zipWith_implementation
16:59:13 <tgeeky> pqmodn: a sieve is a little more complicated than fib
16:59:15 <stj> ben: thanks... also, we could do the same thing in C++ code
16:59:42 <pqmodn> tgeeky: i think i misunderstood the question then :]
17:00:00 <rwbarton> ben: odd. your code takes 19 seconds here (!)
17:00:01 <ben> hm?
17:00:48 <pqmodn> i'm surprised how mine is about 6 times slower... is it obvious? http://hpaste.org/64947
17:01:06 <stj> sorry if I missed it, but why is that faster than the previous version?
17:01:27 <ben> stj: my one?
17:01:32 <pqmodn> oh, mine's wrong
17:01:42 <rata_> archlinux got ghc7.4.1 =)
17:01:53 <tgeeky> andares: I'm assuming that you're doing this for learning, so I haven't given you links to the (at least 4) different implementations
17:02:08 <stj> ben: yes
17:02:27 <hpaste> “maybe fasta” annotated “Pythagoras” with “Pythagoras (annotation)” at http://hpaste.org/64946#a64953
17:02:27 <acowley> this is interesting
17:02:50 <acowley> if you use a literal [1..500] expression for each list, you still need to give GHC -fno-full-laziness to get the not-dumb version
17:02:52 <stj> ben: the one with b+1-b and a+1-a
17:03:11 <danharaj> that seems like a defect
17:03:17 <acowley> when you do so, you get performance like the ClaudiusMaximus ?foo hack
17:03:30 <tgeeky> andares: ok, I think -- for sure, you're going to want (nay, need! -- I think) "@" patterns
17:03:45 <acowley> danharaj: the need to disable that particular flag comes up on mailing lists or SO every so often and everyone is always annoyed :/
17:04:07 <ben> stj: ghc made a list, stored it and stepped through it three times instead of just doing the moral equivalent of a loop
17:04:18 <tgeeky> andares: you are interested in a naive implementation, not a fast one, right?
17:04:40 <acowley> it would be nice if we could give an in-source annotation where that optimization should be disabled
17:04:44 <DanBurton> @google fno-full-laziness ghc
17:04:46 <lambdabot> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/options-optimise.html
17:04:46 <lambdabot> Title: 4.10.�Optimisation (code improvement)
17:04:58 <stj> ben: yeah, but how does this version tell it to do a loop?
17:05:17 <ben> acowley: -fno-full-laziness gets it down to ~0.190s for me, so it's almost there
17:05:22 <acowley> stj: you can get the same result by disabling the full-laziness optimization
17:05:33 <stj> I see
17:05:39 <acowley> s/same/similar
17:06:03 <DanBurton> the problem with microbenchmarks is they are usually nothing like useful code...
17:06:05 <andares> tgeeky: speed doesn't matter terribly much, as long as it's not exponential or anything.
17:06:11 <incomprehensibly> eyebloom: what about moggi's notions of computation and monads?
17:06:52 <eyebloom> That's going way back.
17:07:02 <eyebloom> What's your goal here?
17:07:05 <rwbarton> what am I doing wrong? when I try with -fno-full-laziness it took 86 seconds
17:07:13 <incomprehensibly> I'm writing a paper about I/O in functional programming, and I just need some sources
17:07:33 <acowley> rwbarton: are you running this on a calculator watch?
17:07:38 <rwbarton> :(
17:07:43 <incomprehensibly> going to be talking about monads in Haskell, probably whatever they did before that, uniqueness typing in Clean, and future directions like FRP
17:07:46 <acowley> rwbarton: you still need to pass -O2
17:07:48 <ben> Maybe it's the ghc version?
17:07:49 <rwbarton> yeah I have that
17:07:52 <rwbarton> ghc 7.0.4
17:07:59 <rwbarton> on x86_64 linux
17:08:07 <rwbarton> anyone have that combination?
17:08:11 <eyebloom> It's really Philip Wadler who put it all together with Haskell.
17:08:15 <acowley> hm, I'm on 7.4.1 x86_64 mac
17:08:22 <shachaf> rwbarton: I have that installed -- what's the question?
17:08:26 * shachaf looks at backlog.
17:08:29 <acowley> my perf isn't as good as ben's, but it's a 6 year old laptop
17:08:42 <rwbarton> build http://hpaste.org/64945#a64951 with ghc -O2 and how fast is it
17:08:45 <ben> I think I have 7.0.x on another machine
17:08:46 <rwbarton> for a start
17:08:50 <DanBurton> shachaf: number twiddling microbenchmark Haskell vs C++
17:08:51 <incomprehensibly> eyebloom: all right, thanks
17:09:08 <shachaf> The annotation?
17:09:11 <rwbarton> Yeah.
17:09:55 <acowley> rwbarton: that one's ~0.4s for me
17:09:58 <shachaf> Runs in 7.7 seconds here.
17:10:06 <ben> 9s on 7.0.3/x86_64
17:10:14 <shachaf> In GHC 7.4.1 it's ~0.2 seconds.
17:10:24 <rwbarton> okay, I have 19 s which is reasonable since the C++ program takes 0.5 s
17:10:39 <rwbarton> pretty big improvement in 7.4 i'd say!
17:10:45 <acowley> so Mr. Marlowe's competence is causing confusion
17:10:45 <shachaf> I didn't realize GHC 7.4.1 made such significant performance improvements in anything.
17:11:10 * DanBurton bets it's some random optimization that is turned on by default now or something
17:12:12 <shachaf> Clearly 2012 is the year of GHC on the desktop.
17:12:22 <rwbarton> DanBurton: probably yeah
17:13:00 <DanBurton> *GHC on the Enterprise Server
17:13:38 <acowley> LLVM on a non-shared version is faster than NGC for me, too
17:13:41 <acowley> by a smidgen
17:14:38 <shachaf> I wonder why the OS keeps changing which CPU to run a 100% CPU process on.
17:15:03 <rwbarton> heat balancing? :)
17:15:18 <tgeeky> andares: ok, I don't know how to teach this to you (because I don't understand it myself)
17:15:24 <tgeeky> andares: try: http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)#chunk def:primes_naive
17:15:29 <shachaf> That must be it.
17:15:54 <shachaf> I was trying to compare -O0 performance, but it looks like it takes the same amount of time with 7.0.4 and 7.4.1.
17:15:57 <shachaf> I.e., "too long".
17:16:11 <shachaf> (So I have no idea.)
17:17:30 <DanBurton> how seriously maintained is the Clean programming language?
17:20:40 <Urchin> I've started checking out tutorials for haskell, but I'm really interested in using it for a project of mine, I want to develop a wargame
17:21:12 <Urchin> any pointers anyone can give?
17:21:37 <ben_m> That's a pretty generic question.
17:21:45 <ben_m> Not generic, uh, unspecific.
17:22:02 <Jafet> Why aren't there any peacegames
17:22:28 <DanBurton> what kind of war game? 3D? turned based? online?
17:22:29 <ben_m> There are!
17:22:37 <Urchin> turn based hex game
17:22:56 <DanBurton> @wiki games
17:22:56 <lambdabot> http://www.haskell.org/haskellwiki/games
17:22:57 <Urchin> prefference online and pbem
17:23:01 <danharaj> haskell has sdl bindings and opengl bindings
17:23:25 <ben_m> I wish I could script Unity with Haskell.
17:23:30 <andares> tgeeky: thanks anyway!
17:23:48 <Urchin> ok, I'm thinking 2D graphics
17:24:05 <Urchin> no use for 3D whatsoever
17:24:27 <DanBurton> ben_m: write a Haskell DSL that compiles to unityscript?
17:24:54 <ben_m> That sounds really tricky.
17:25:04 <DanBurton> indeed
17:25:23 <DanBurton> the #haskell-game irc channel exists but it's pretty quiet
17:25:40 <Urchin> ok, thanks
17:25:43 <kallisti> :t (=<<).(,)
17:25:44 <lambdabot> forall b a. (Monad ((,) a)) => a -> (a, b) -> (a, b)
17:25:55 <kallisti> hm, no.
17:27:05 <kallisti> @pl (\a b -> (a,) =<< b)
17:27:05 <lambdabot> (line 1, column 12):
17:27:05 <lambdabot> unexpected ","
17:27:06 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
17:27:12 <kallisti> @pl (\a b -> (,) a =<< b)
17:27:12 <lambdabot> (=<<) . (,)
17:27:53 <DanBurton> reading idris release notes from 2 weeks ago: "case expressions now allowed in type signatures". wat.
17:28:27 <ben> hm, i tried to hand-write those for-loops and now it stackoverflows only when i use ints instead of integer, that sounds fishy
17:28:30 <rostayob> DanBurton: what's wrong with that? dependent types, remember :)
17:28:41 <andares> huh, what does `minus` do?
17:28:46 <andares> ghc can't seem to find it.
17:28:46 <DanBurton> rostayob: nothing wrong...just...wat
17:28:50 <rostayob> iirc agda has case-lambdas as well
17:29:47 <rostayob> DanBurton: you get used to that powerrrrrr pretty quickly :P
17:29:56 <tgeeky> andares: minus is defined on the page
17:30:08 <andares> d'oh. sorry tgeeky.
17:30:16 <kallisti> > zipWith ((=<<).(,)) [1, 3] [Just 2, Nothing]
17:30:16 <lambdabot>   Couldn't match expected type `(a, b)'
17:30:17 <lambdabot>         against inferred type `Data.M...
17:30:47 <kallisti> erm, what.
17:31:45 <c_wraith> (a,) isn't a Monad instance
17:31:52 <kallisti> I don't want that monad.
17:31:54 <kallisti> :t zipWith (\a b -> (,) a =<< b)
17:31:55 <lambdabot> forall a a1. (Monad ((,) a)) => [a] -> [(a, a1)] -> [(a, a1)]
17:32:12 <c_wraith> then don't say (=<<).(,)
17:32:15 <Hemite_> Does anyone know where I can find beginner practice problems? Maybe not in Haskell but those that I could apply to that language?
17:32:25 <rostayob> Hemite_: 99 problems?
17:32:35 <kallisti> c_wraith: isn't b the monad in that expression?
17:32:44 <kallisti> have I lost it?
17:32:53 <DanBurton> @google haskell 99 problems
17:32:54 <lambdabot> http://www.haskell.org/haskellwiki/99_questions
17:32:54 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
17:33:00 <rwbarton> I would be inclined to say that you should never say (=<<).(,)
17:33:04 <DanBurton> @google haskell 20 intermediate
17:33:06 <lambdabot> http://blog.tmorris.net/20-intermediate-haskell-exercises/
17:33:06 <lambdabot> Title: λ Tony’s blog λ » Blog Archive » 20 Intermediate Haskell Exercises
17:33:07 <Hemite_> @rostayob Yea I saw those but I wasn't sure what level they were intended for
17:33:07 <lambdabot> Unknown command, try @list
17:33:09 <DanBurton> those are good
17:33:16 <rostayob> Hemite_: they're meant for beinners
17:33:17 <kallisti> (\a b -> (,) a =<< b)
17:33:19 <c_wraith> kallisti: oh, I think you're right.
17:33:23 <Hemite_> allright thanks guys
17:33:29 <kallisti> ..why is it saying that the Monad instance is (,) a
17:33:33 <kallisti> and not Monad m
17:33:39 <rwbarton> it looks like you are using the (,) a monad to me
17:33:48 <rwbarton> ... what's the type of (,) a?
17:33:53 <rwbarton> and what's the type of (>>=)?
17:33:56 <ion> join :: Monoid a => (a, (a, b)) -> (a, b); join (a0, (a1, b)) = (a0 <> a1, b)  -- :-P
17:33:58 <kallisti> :t zipWith (\a b -> (,) b >>= (,) a)
17:33:59 <lambdabot>     Couldn't match expected type `b1 -> b'
17:33:59 <lambdabot>            against inferred type `(a, (b2, b1))'
17:33:59 <lambdabot>     In the second argument of `(>>=)', namely `(,) a'
17:34:07 <kallisti> :t zipWith (\a b -> b >>= (,) a)
17:34:08 <lambdabot> forall a a1. (Monad ((,) a)) => [a] -> [(a, a1)] -> [(a, a1)]
17:34:11 <kallisti> rwbarton: =<< not >>=
17:34:23 <rwbarton> and, what is the relationship between (=<<) and (>>=)?
17:34:32 <shachaf> (,) a :: forall b. b -> (typeof a, b)
17:34:53 <kallisti> oh.
17:34:58 <kallisti> right
17:35:08 <kallisti> :t zipWith (\a b -> (,) a <$> b)
17:35:09 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => [a] -> [f a1] -> [f (a, a1)]
17:35:17 <kallisti> @pl zipWith (\a b -> (,) a <$> b)
17:35:18 <lambdabot> zipWith ((<$>) . (,))
17:35:20 <kallisti> there we go.
17:35:38 <kallisti> I make the >>= vs. <$> surprisingly often.
17:35:42 <kallisti> they're only a return different.
17:36:05 <rostayob> and the arguments are flipped
17:36:11 <kallisti> well that's not a problem.
17:36:16 <kallisti> for me
17:36:30 * kallisti is probably going about this the entirely wrong way.
17:36:54 <rostayob> kallisti: I don't know what your problem :P
17:42:33 <singpolyma> Can someone explain to me why in http://pastie.org/3545438  the append2 function works fine on infinite lists, but the append does not?
17:43:28 <shachaf> singpolyma: Note that append2 isn't recursive -- it's calling append.
17:43:31 <shachaf> So that's kind of odd.
17:43:35 <shachaf> Which list is infinite?
17:43:49 <singpolyma> shachaf: oh... that might be causing something strang
17:44:23 <singpolyma> so, test case :    take 5 (foldr append2 [] [[1,2..] | x <- [1,2..]])
17:44:45 <singpolyma> I just tested, it's the same if I make append2 recursive.  append runs forever, append2 terminates
17:45:18 * shachaf looks again.
17:45:32 <singpolyma> huh, just passing standard infinite lists seems to work on both, but that test case does not
17:45:35 <hpaste> ben pasted “stack overflow” at http://hpaste.org/64954
17:45:36 <ben> I'm still playing around with the three-nested-loops-from-1-to-500 example and tried to write out the loops, but I get a stack overflow only with that ::Int annotation. Any idea what the deal is?
17:47:17 <singpolyma> simpler case that causes it: take 5 (foldr append [] (repeat [1,2..]))
17:47:35 <c_wraith> ben: well, the bang patterns on the first 3 arguments of go are redundant.  those arguments are already forced by pattern matching
17:48:40 <shachaf> singpolyma: That's not a simpler case -- it's the same case. :-)
17:49:12 <singpolyma> shachaf: sure, it's a less stupid version of the same case ;)  (I did not write the original)
17:49:31 <shachaf> singpolyma: The reason it's not working is that append is examining its second argument.
17:50:01 <singpolyma> and examining the second argument does something to the first argument?
17:50:29 <shachaf> No, but it means the function is strict in its second argument.
17:50:32 <shachaf> So foldr won't terminate.
17:50:47 <ben> c_wraith: Okay, I went overboard there, but I still don't see what's wrong :(
17:51:39 <shachaf> singpolyma: (What makes foldr work with infinite lists is laziness -- if it examines its second argument in every case, you lose that.)
17:51:57 <shachaf> For example:
17:52:06 <singpolyma> wait, so, checking if a list is empty forces the whole list?
17:52:09 <shachaf> > foldr (\x y -> 'a' : y) "" [1..]
17:52:10 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
17:52:11 <shachaf> > foldr (\x !y -> 'a' : y) "" [1..]
17:52:12 <lambdabot>   "*Exception: stack overflow
17:52:46 <kallisti> @hoogle showString
17:52:46 <lambdabot> Prelude showString :: String -> ShowS
17:52:46 <lambdabot> Text.Show showString :: String -> ShowS
17:53:14 <singpolyma> but, then, passing in two infinite lists works... so this is a foldr specfic thing more
17:53:33 <shachaf> It's happening because of the foldr, yes.
17:53:45 <Cale> singpolyma: no, but if you do it repeatedly on every tail of the list, you'll force the whole spine.
17:53:56 <singpolyma> Ooooh!
17:54:00 <shachaf> foldr append [] [a,b,c,d,...] = append a (append b (append c (append d (...))))
17:54:01 <singpolyma> of course
17:54:21 <Cale> (that was in reply to whether checking if a list is empty forces the whole thing)
17:55:25 <shachaf> singpolyma: That's why it was working for the nonrecursive append, by the way.
17:55:54 <singpolyma> right, it got caught at the top level
17:56:08 <c_wraith> ben: works for me without any annotation, at least with -O2
17:56:46 <ben> Yeah but I want it faster <:)
17:56:54 <dat_eyesocket> Cale, does your name mean anything?
17:57:05 <Cale> dat_eyesocket: It is my real name.
17:57:11 <Cale> (Cale Gibbard)
17:57:13 <dat_eyesocket> It's a first name?
17:57:14 <dat_eyesocket> Ahhh
17:57:15 <Cale> yes
17:57:19 <dat_eyesocket> that explains it
17:57:31 <c_wraith> ben: why would it be faster? That's a rather computationally-intensive (and large) loop?
17:57:38 <ClaudiusMaximus> ben: with the paste as written and ghc-7.4.1 -O2 i get a stack overflow - which is puzzling
17:58:06 <dat_eyesocket> Hi CAle, I'm dat_eyesocket Reginald Wilberforce Humberdale.
17:58:21 <ben> c_wraith: I figured Ints are faster than Integers and it defaults to Integers if I don't annotate it?
17:58:38 <DanBurton>  /whois Cale
17:59:04 <ben> ClaudiusMaximus: Yeah, same here
17:59:06 <c_wraith> ben: that much is true (though there are correctness issues with large numbers), but that's not a stack overflow
17:59:08 <Cale> ben: slightly
17:59:25 <ben> c_wraith: I get a stack overflow with the paste as-is, is what I mean
17:59:28 <Cale> You can create stack overflows by using Int where you need Integer sometimes :)
17:59:44 <c_wraith> not in that case, though.
17:59:45 <rwbarton> what happens with Integer?
17:59:46 <ben> It's arguably much faster if it terminates with a stack overflow but that wasn't quite was I was getting at
17:59:54 <rwbarton> eventually completes normally?
17:59:54 <ben> rwbarton: It takes a while and works fine
17:59:58 <c_wraith> It won't even overflow
18:00:06 <c_wraith> the result isn't that large
18:00:36 <DanBurton> is it just me, or is github down?
18:00:43 <Cale> You can get into infinite loops when things roll over sometimes (I haven't looked at your code though)
18:00:55 <Cale> Or much longer loops than you'd otherwise be in.
18:01:01 <duairc> Is it possible to give a default instance for an associated type?
18:02:08 <hpaste> jackhill pasted “template-haskell build failure” at http://hpaste.org/64957
18:02:44 <edwardk> preflex: xseen lispy
18:02:44 <preflex>  lispy was last seen on freenode/#haskell 7 hours, 1 minute and 22 seconds ago, saying: hello
18:03:13 <jackhill> does anyone have suggestions for how to get past this build error: http://hpaste.org/64957
18:03:21 <edwardk> anyone interested in mentoring this year for the google summer of code?
18:03:31 <edwardk> i'm about to send out a general inquiry
18:04:03 <c_wraith> jackhill: you can't replace the version of TH that comes with your version of ghc.  Attempts to do so usually indicate cabal has gone insane
18:06:29 <DanBurton> not that I'm qualified, but curious: what are the qualifications for being a Haskell gsoc mentor?
18:07:12 <DanBurton> edwardk: or are you asking if anyone is interested in being mentored?
18:07:22 <ClaudiusMaximus> ben: with -O0 it takes 3m45s and doesn't stack overflow....
18:07:33 <ben> :(
18:07:34 <edwardk> well, a bit of both. i'm more looking for mentors at this exact moment ;)
18:07:59 <jackhill> c_wraith: Ah, I had installed ghc and cabal from my distro (OpenSuSE 12.1; doesn't seem to have a haskell-platform package), and then tried to cabal install something that dependedon TH, causing the build to fail.
18:08:23 <ClaudiusMaximus> ben: with -O1 it overflows, so - something between 0 and 1 makes it go bananas
18:08:24 <jackhill> Installing my distro's TH package and then cabal installing works. Thanks!
18:08:25 <c_wraith> jackhill: you'll need to get TH from your distro's packaging, then
18:08:38 <c_wraith> jackhill: ah, you already did.  even better :)
18:08:59 <byorgey> edwardk: I might be
18:09:09 <NemesisD> i'm in dependency hell, need rescue. i'm trying to install SHA-1.5.0.0, cabal complains "there is no available version of aeson that satisfies ==0.6.0.0", aeson is not a dependency of SHA or anything related to it
18:09:40 <edwardk> byorgey: great =)
18:10:12 <edwardk> i'll be fixing up the 'people' page on the wiki momentarily, so i was trying to figure out who i'm seeding it with ;)
18:10:52 <ben> I can't find in the manual where it lists what optimizations come at what -O level and I gotta leave for now
18:10:54 <ion> Someone should implement a generic dependency resolver that Doesn’t Suck™ and every single package manager out there should be implemented based on it.
18:10:56 <ben> maybe I can track it down tomorrow :(
18:10:58 <DanBurton> NemesisD: how odd
18:11:04 <ben> thanks for looking at it
18:11:16 <DanBurton> ion: so...Nix then?
18:11:19 <NemesisD> DanBurton: yeah. i use aeson on other projects but i'm not even trying to install it here. trying to install HUnit, which needs SHA
18:11:59 <amindfv> anyone know a good tutorial/walk-thru for haskell-src?
18:12:50 <DanBurton> NemesisD: perhaps try to just "cabal install SHA"
18:12:58 <DanBurton> NemesisD: does that produce the same error?
18:13:13 <NemesisD> DanBurton: yup. happens when resolving deps
18:13:54 <hpaste> NemesisD pasted “sha needs aeson?” at http://hpaste.org/64958
18:14:01 <DanBurton> NemesisD: you have the typical Haskell Platform libs installed? SHA 1.5 doesn't stray from them, so it's insane that cabal would think you need anything else
18:14:27 <NemesisD> i have ghc from arch's package manager i believe
18:15:06 <NemesisD> yeah. 7.4.1-2, everything  else installed with cabal
18:15:14 <NemesisD> am i going to have to nuke everything
18:15:16 <DanBurton> grasping at straws for why that would happen...but have you done a cabal update recently?
18:19:12 <NemesisD> DanBurton: yessir
18:20:27 <hpaste> DanBurton annotated “sha needs aeson?” with “sha needs aeson? (not for me)” at http://hpaste.org/64958#a64959
18:20:40 <td123> NemesisD: I just installed sha w/o problems on arch using cabal, so it could be something specific for you
18:21:13 <DanBurton> yeah something really weird is going on xP I wonder if cabal-nirvana would help
18:21:26 <NemesisD> so what im hearing is nuke it
18:21:32 <NemesisD> also i don't understand what nirvana exactly does
18:21:56 * dcoutts is pretty much stumped too
18:22:06 <DanBurton> neither do I...Michael just barely wrote it like yesterday
18:22:19 <dcoutts> oh is that the thing that fiddles with the cabal index?
18:22:28 <DanBurton> @where nirvana
18:22:28 <lambdabot> I know nothing about nirvana.
18:22:35 <DanBurton> @hackage cabal-nirvana
18:22:35 <lambdabot> http://hackage.haskell.org/package/cabal-nirvana
18:23:37 <DanBurton> @where+ nirvana Hack cabal-install to use only Father Snoyman's blessed versions http://hackage.haskell.org/package/cabal-nirvana
18:23:37 <lambdabot> It is forever etched in my memory.
18:25:14 <DanBurton> hrm no one at #idris is responding. Anyone know if there is an emacs mode for idris? Maybe I should just try Haskell mode with it?
18:29:20 <lispy> edwardk: ping
18:29:38 <lispy> edwardk: I registered a few days ago on the melange site. I just logged in again to double check.
18:29:47 <lispy> edwardk: are you having trouble finding my account?
18:29:57 <edwardk> i tried 'lispy' was it something else?
18:30:05 <edwardk> =)
18:30:07 <lispy> edwardk: :)  Yes, dagitj
18:30:09 <edwardk> hah
18:30:15 <edwardk> silly person trying to become a grownup
18:30:22 <lispy> actually, try just dagit
18:30:48 <edwardk> that worked
18:30:50 <shachaf> lispy: jasond is the way things work around here.
18:30:51 <lispy> sweet
18:31:14 <lispy> shachaf: what would jason dusek use?
18:31:31 <lispy> my last name is significantly less ambigious :)
18:32:39 <shachaf> lispy: First-come, first-serve.
18:32:59 <edwardk> second person with the same last initial has to leave the channel, forever
18:33:13 <hpaste> kallisti pasted “approximately how horrible is this?” at http://hpaste.org/64960
18:34:56 <lispy> edwardk: anyway, thanks for taking care of that
18:35:08 <acowley> DanBurton: I gather expected usage relies heavily on the interactive mode
18:35:08 * lispy thinks it's time to relocated to home
18:35:21 <edwardk> later man
18:35:52 <NemesisD> ok how do i safely nuke cabal?
18:36:01 <acowley> DanBurton: although, Edwin Brady is very accessible on twitter so you could ask him what he uses
18:36:32 <DanBurton> NemesisD: safePerformIO fireMissiles ;)
18:36:35 <acowley> NemesisD: 1) put on some goggles  2) rm -rf ~/.cabal
18:36:53 <td123> NemesisD: rm -rf ~/.cabal ~/.ghc
18:37:17 <acowley> oops, yes, ~/.ghc must fall during the nuclear devastation, too
18:37:32 <DanBurton> ^ assuming, of course, that you have it set up to install to your userspace
18:37:34 <acowley> I'm not sure if the goggles do anything, btw
18:37:40 <td123> heh, I have lots of experience nuking cabal :P
18:38:19 <MaskRay> removing ~/.ghc/x86_64-linux-7.4.1/ should work
18:38:22 <hpaste> kallisti annotated “approximately how horrible is this?” with “approximately how horrible is this? (part TWO)” at http://hpaste.org/64960#a64961
18:38:31 <acowley> nuking cabal is always emotional for me: either I'm very angry at it and relish throwing it all away, or I'm very sad to contemplate how long recompiling everything is going to take
18:38:50 <DanBurton> acowley: heh, looks like he answered that very question on twitter the other day. He just uses Haskell mode -_-
18:39:00 <MaskRay> i didn't see how it helps to remove the .cabal dir as you have to redownload packages
18:39:42 <acowley> MaskRay: See my comment about anger. Your refined technique is a relic from a more civilized age.
18:39:45 <DanBurton> in my experience, the download time is insignificant compared to the compile time
18:40:40 <acowley> DanBurton: I really wish there was a Haskell-Idris interop story. Everytime I program in something other than Haskell I feel phantom pains where hackage should be.
18:41:38 <DanBurton> Given how similar Idris is to Haskell, it seems like it should be able to take advantage of the Haskell ecosystem immediately. Alas, reality is not so kind.
18:46:27 <hpaste> kallisti annotated “approximately how horrible is this?” with “approximately how horrible is this? (the REAL part two)” at http://hpaste.org/64960#a64962
18:47:08 <cbarrett> I'm having some trouble with cabal-install's bootstrap script. Am I in the right place?
18:47:25 <acowley> cbarrett: yes you are, what's the trouble?
18:49:20 <cbarrett> So I'm attempting to stand up a Haskell environment on a shared host.
18:49:58 <cbarrett> Their install of libgmp is messed up, so I had to install it myself ($HOME/prefix). GHC was pretty easy, download the binary and change the rpath with patchelf.
18:50:39 <cbarrett> But I'm having trouble figuring out the right flags to pass to the cabal-install bootstrap script to tell it to look for gmp in $HOME/prefix/lib
18:51:51 <dcoutts> cbarrett: it shouldn't need to, once ghc knows where it is
18:52:16 <cbarrett> Hm.
18:52:21 <dcoutts> cbarrett: I think you may need to edit one of the registered packages, integer-gmp to have it link to gmp from the right place
18:52:33 <dcoutts> it's not just the rpath in the binaries
18:52:44 <cbarrett> Ah-ha.
18:52:45 <dcoutts> ghc-pkg has a database of all registered ghc packages
18:52:53 <dcoutts> which includes what C libs they link to
18:53:26 <dcoutts> ghc-pkg describe integer-gmp > integer-gmp.pkg
18:53:42 <dcoutts> vi integer-gmp.pkg
18:53:42 <dcoutts> ghc-pkg --global update integer-gmp.pkg
18:54:42 <DanBurton> dcoutts++
18:54:49 <cbarrett> awesome
18:55:05 <cbarrett> dcoutts++
18:55:25 <ben> If my program works with -fno-strictness but stackoverflows without it, what am I doing wrong :V
18:55:25 <dcoutts> cbarrett: once you do that, you might like to check that you can compile a trivial hello world prog, or one that uses type Integer
18:55:41 <dcoutts> ben: yes
18:55:51 <DanBurton> ben: erm...too much strictness?
18:55:58 <dcoutts> oh, "what", not "are you doing in wrong" :-)
18:56:14 <ben> It's a very strict function already :)
18:56:23 <dcoutts> oh, I was assuming -fno-strictness-analysis
18:56:37 <acowley> can we give dcoutts some kind of #haskell MVP award?
18:56:48 <kallisti> @hoogle String -> JSValue
18:56:48 <lambdabot> Warning: Unknown type JSValue
18:56:49 <lambdabot> Prelude error :: [Char] -> a
18:56:49 <lambdabot> Debug.Trace trace :: String -> a -> a
18:57:48 <DanBurton> lambdabot needs a command that is the opposite of @slap
18:58:17 <dcoutts> ben, DanBurton: right, -fno-strictness means no strictness analysis
18:58:58 <dcoutts> so it means if you have to have strictness analysis turned on to avoid stack overflow, then your function is too lazy
18:59:06 <dcoutts> consider foldl (+) 0
18:59:24 <DanBurton> I thought he said the opposite
18:59:31 <ivanm> dcoutts: why does Hackage have links to modules that have {-# OPTIONS_HADDOCK hide #-} in them (and thus the links don't go anywhere) ?
18:59:46 <dcoutts> DanBurton: oh yes, mm
19:00:06 <dcoutts> ivanm: hackage doesn't know that they're hidden, only haddock knows that
19:00:16 <dcoutts> ivanm: they're exposed modules
19:00:49 <cbarrett> Test program that used Integer did not link. Want me to paste the output of ghc-pkg describe?
19:00:59 <cbarrett> er, that was at dcoutts
19:01:20 <DanBurton> so the problem is that ghc is performing a strictness analysis "optimization" that decides to eat up tons of memory?
19:01:51 <DanBurton> ben: can you hpaste it?
19:02:08 <ben> I kept trying to make it fit one line, but oh well
19:02:09 <dcoutts> cbarrett: sure, and your new package description for integer-gmp
19:02:35 <hpaste> ben pasted “stack overflow at -O without -fno-strictness” at http://hpaste.org/64963
19:02:48 <ben> ghc 7.4.1 on x86_64, sorry
19:03:44 <AtnNn> has anyone tried to implement TDNR?
19:04:02 <acowley> ben: that is strange
19:04:25 <acowley> ben: if you manually make it strict with bangs do you still get the variable behavior with -fno-strictness?
19:04:34 <ClaudiusMaximus> ben: ha, just reached the same conclusion this very second
19:05:29 <ben> acowley: yeah. I had bangs there initially until c_wraith pointed out that they are redundant
19:05:58 <DanBurton> right, because you pattern match on the literals, which makes it strict anyways
19:06:40 <cbarrett> dcoutts: ah-ha, seems like I was looking at the cabal docs, which has an "extra-lib-dirs" directive, where ghc-pkg does not.
19:06:48 <acowley> DanBurton: good point
19:06:49 <DanBurton> I can reproduce the same behavior. stackoverflow with -O, but no problem with -O -fno-strictness
19:06:58 <acowley> yeah, same behavior here, too
19:07:07 <DanBurton> bug report?
19:07:09 <ben> My favorite thing is that the overflow depends on the value being printed being an Int
19:07:12 <cbarrett> dcoutts: going to give "ld-options: -L/path/to/my/lib" a try.
19:07:26 <ben> the go arguments being Ints or Integers does not seem to influence it at all
19:08:08 <acowley> ben: this seems like an issue the GHC devs should be made aware of
19:08:15 <ben> That's what I was afraid of :)
19:08:32 <acowley> ben: on the bright side, you've got an excellent test case already
19:08:39 <cbarrett> Yay, that works now.
19:08:40 <DanBurton> reproducible
19:08:53 <dcoutts> cbarrett: you'd want library-dirs, but ld-options should work too
19:09:04 <acowley> ben: it's so much worse when you hit a bug in some monstrous code base then just have to beg simonmar to bear with you :/
19:09:11 <dcoutts> ben: I am mightily surprised
19:09:17 <cbarrett> dcoutts: ah-ha, missed that. thanks.
19:09:25 <ben> I suppose I should try to compile ghc from the repository to see if it got fixed since
19:09:26 <dcoutts> ben: I get different behaviour for ghc-6.12 vs 7.0 and 7.4
19:10:24 <ClaudiusMaximus> ben: btw, i gave one version an +RTS -K1000m and it crashed with 'out of memory' on a machine with 4GB ram...
19:10:26 <dcoutts> ben: make sure you report the bug
19:10:43 <cbarrett> dcoutts++ thanks again
19:11:31 <ben> I'll have a look through the existing tickets and then file it
19:13:01 <ClaudiusMaximus> (the latest paste seems not to do that, with -K1000m it prints 0)
19:13:58 <ben> ClaudiusMaximus: It's a bit smaller since I reduced it by one variable and just multiplied the next one's limit by the removed one's limit, which doesn't seem to quite preserve the behavior - it doesn't occur with just on variable up to 500^3
19:14:48 <ClaudiusMaximus> > 500^2
19:14:49 <lambdabot>   250000
19:15:03 <ben> oh dear did i miss a zero
19:15:06 <ben> i'm the worst at math
19:16:47 <kallisti> are there any good examples of how to use Text.JSON?
19:22:20 <DanBurton> I think aeson is the cool way to do JSON these days
19:23:38 <JoeyA> Has anyone made something like MonadCatchIO that supports the new mask interface?
19:24:20 <JoeyA> MonadCatchIO-mtl uses block and unblock, which is soo base-4.2
19:25:13 <c_wraith> no one really is all that happy with MonadCatchIO anymore.
19:26:51 <JoeyA> Why so?
19:27:47 <drbean> The mechanics of converting code to use Maybe to handle errors is in the type declaration to stick 'Just' in front of the data constructor and add another, 'Nothing'
19:28:09 <drbean> And in the function definitions to stick 'Just' in front of the LHS?
19:28:30 <edwardk> JoeyA: ezyang has a screed against it somewhere
19:28:41 <c_wraith> my main complaint is "bracket is broken"
19:29:10 <c_wraith> which, inevitably, leads to "it feels really ad-hoc to make everything part of the class"
19:29:16 <c_wraith> When you start talking about how to fix it
19:29:41 <thoughtpolice> edwardk: wasn't ezyang talking about monad-control, not the MonadCatchIO* libraries?
19:30:08 <drbean> s/LHS/RHS/
19:31:07 <JoeyA> c_wraith: How is bracket broken?
19:31:29 <c_wraith> JoeyA: It can't guarantee the finish action will be executed
19:32:13 <JoeyA> c_wraith: Is that because of some monad transformers, or does it apply to plain IO as well?
19:32:27 <c_wraith> it's a property of any transformer that modifies control flow
19:32:56 <c_wraith> since bracket is defined in terms of the transformer's implementation of (>>=)
19:35:37 <JoeyA> It seems to me that one or more applications of ReaderT, WriterT, StateT to IO retains the guarantee that bracket will work properly.  However, I'm not sure about ErrorT and ContT.
19:36:06 <c_wraith> ContT can't even implement catch correctly, so it's no surprise it can't implement bracket
19:36:58 <JoeyA> I should point out that an exception causes state or written data to be rolled back, but IO is not rolled back (because the universe doesn't work that way).
19:37:07 <c_wraith> But yes, ErrorT is broken, as is MaybeT, ExceptionalT, and anything else that includes short-circuit evaluation
19:37:23 <JoeyA> Thanks for pointing that out.
19:37:41 <c_wraith> and those all *can* implement bracket sanely.
19:38:03 <c_wraith> Just not without either changing the approach entirely, or adding bracket to the class
19:39:11 <JoeyA> In any case, I still believe it is useful to lift bracket to RWS.  That's what I'm about to do in a program, so I'm implementing a MonadException class so I can.
19:39:18 <kallisti> :t fmap
19:39:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:39:33 <kallisti> @hoogle Functor f => f a -> (a -> b) -> f b
19:39:33 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
19:39:34 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
19:39:34 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
19:39:57 <startling> what's the way to get lambdabot to refactor to pointfree?
19:40:02 <kallisti> @pl
19:40:03 <lambdabot> (line 1, column 1):
19:40:03 <lambdabot> unexpected end of input
19:40:03 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
19:40:07 <kallisti> er, yeah.
19:40:08 <parcs`> JoeyA: have you seen lifted-base?
19:40:40 <startling> @pl unfoldr (\(prev, cur) -> Just (prev, (cur, prev+cur))) (0, 1)
19:40:40 <lambdabot> unfoldr (uncurry ((Just .) . liftM2 (.) (,) (ap (,) . (+)))) (0, 1)
19:41:44 <JoeyA> parcs`: Perhaps I'll use that.  Thanks!
19:43:36 <Makoryu> @pl \n xs -> unfoldr (Just . splitAt n) xs
19:43:36 <lambdabot> unfoldr . (Just .) . splitAt
19:44:06 <kallisti> @src (.:)
19:44:06 <lambdabot> Source not found.
19:44:36 <kallisti> (f .: g) x y = f (g x y)
19:45:08 <cbarrett> So I installed GHC 7.4.1. I'm attempting to install cabal-install 0.10.2, but it's not working.
19:45:32 <cbarrett> It's bailing about it not being able to meet its deps. I'm just doing `sh boostrap.sh`
19:45:36 <cbarrett> First off, it's weird to me that it's trying to download an older version of Cabal (the lib) than what came w/ GHC (1.10.1.0 vs 1.14.0)
19:45:38 <otters> @pl (f .: g) x y = f (g x y)
19:45:38 <lambdabot> (line 1, column 14):
19:45:38 <lambdabot> unexpected "="
19:45:38 <lambdabot> expecting variable, "(", operator or end of input
19:45:58 <DanBurton> I think most people on 7.4.1 have to install cabal-install from the git repo
19:46:02 <DanBurton> I did, anyways
19:46:10 <DanBurton> *darcs
19:46:22 <kallisti> otters: it's  (f .) . g
19:46:37 <kallisti> I believe
19:46:39 <kallisti> :t (.:)
19:46:39 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:46:47 <DanBurton> @pl let (f .: g) x y = f g x y) in (.:)
19:46:47 <lambdabot> (line 1, column 5):
19:46:47 <lambdabot> unexpected "("
19:46:47 <lambdabot> expecting "()", natural, identifier or "in"
19:46:52 <DanBurton> wat :(
19:46:56 <kallisti> :t (?f.).?g
19:46:57 <lambdabot> Not in scope: `.?'
19:47:03 <cbarrett> Dan: Hm. Well, I don't *have* to be using 7.4.1. It was just the latest version on the website.
19:47:04 <kallisti> :t (?f.). ?g
19:47:04 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (?f::a -> b, Functor f, ?g::f1 (f a), Functor f1) => f1 (f b)
19:47:07 <rwbarton> you have an extraneous )
19:47:08 <cbarrett> er, DanBurton:
19:48:16 <DanBurton> @pl \f g x y -> f (g x y)
19:48:16 <lambdabot> (.) . (.)
19:51:59 <DanBurton> D: idris uses <$> for <*> T_T
19:53:02 <cbarrett> DanBurton: It makes sense, since Idris has overloading.
19:53:36 <cbarrett> (Actually, now that I think about it, I'm not sure what the Functor definition in Idris looks like)
19:54:23 <andares> hey, is there a way to define the infinite list of primes in Haskell?
19:54:36 <DanBurton> @hackage primes
19:54:36 <lambdabot> http://hackage.haskell.org/package/primes
19:54:46 <DanBurton> andares: yep ^
19:55:05 <andares> is it easy to understand how it works?
19:55:12 <ben_m> Pretty much, yes.
19:55:13 <DanBurton> probably not ;)
19:55:13 <andares> I'll just download it and peek inside I guess. :p
19:55:18 <andares> hehe
19:55:42 <DanBurton> andares: the easy way to define it is `filter isPrime [2..]', for some suitable definition of isPrime
19:56:15 <cbarrett> incremental sieve of eratosthenes!
19:56:23 <andares> cbarrett: see, I tried that!
19:56:28 <andares> but I couldn't figure out how to do it.
19:56:38 <andares> I'm very new to haskell though.
19:56:38 <cbarrett> this paper has two haskell implementations, in theory
19:56:39 <cbarrett> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
19:56:52 <DanBurton> andares: actually, you don't have to download it. You can see the source from the hackage repo. Or read the paper.
19:57:04 <DanBurton> although technically looking at a webpage means you've downloaded it
19:58:40 <andares> huh, the introductory algorithm is really simple. I fail.
19:59:03 <DanBurton> but the introductory algorithm is the FAKE sieve!
19:59:47 <mm_freak> andares: for exercise or for usage?
20:00:05 <andares> well, for exercise mostly.
20:00:09 <andares> for some reason I couldn't see it before.
20:00:14 <mm_freak> ok
20:15:28 <andares> the wheel is.. cool.
20:16:06 <dmwit> The dots make it... dramatic. ;-)
20:18:11 <andares> indeed. I'm still not sure why starting at 5 and alternatingly adding 2 and 4 works, or what the pattern behind wheel design is.
20:24:26 <mm_freak> andares: the basic idea is that of the sieve of eratosthenes
20:24:38 <mm_freak> if 2 is a prime, no multiple of 2 can be a prime
20:24:51 <mm_freak> so you can go in steps of 2:  [3, 5, 7, 9, …
20:25:20 <mm_freak> if 3 is a prime, no multiple of 3 can be a prime, so you can go in steps of 3 starting from 3
20:25:30 <mm_freak> the [2, 4] wheel gives you exactly that
20:26:45 <rwbarton> basically you can pick any set of small primes, here 2 and 3, and look for which numbers are not divisible by any of them
20:27:00 <rwbarton> that pattern is going to repeat every 2*3 numbers
20:27:06 <mm_freak> that way in fact you can generate arbitrary size wheels, but with every additional prime number the effect will be smaller…
20:27:30 <rwbarton> so you can check which numbers modulo 6 are not multiples of 2 or 3, and it turns out to be 6n+1, 6n+5
20:27:45 <mm_freak> the wheel for 2, 3 and 5 should be sufficient…  additional primes will have a neglible effect
20:29:10 <andares> is there a way to start at the end of a list and go forward?
20:29:20 <andares> *back
20:29:24 <mm_freak> andares: yes, but no efficient way
20:29:31 <andares> hm, that's unfortunate.
20:29:40 <mm_freak> if you want a list with two ends, you need to use Data.Sequence
20:29:53 <mm_freak> no, it's fortunate for the things you should use lists for =)
20:30:06 <mm_freak> you really don't /want/ [] to have two ends
20:30:13 <andares> well, I'm solving a project euler problem at the moment.
20:30:21 <andares> and I'm trying to find the largest prime factor of a number.
20:30:49 <andares> so I've defined an infinite list of primes, and I was going to try to start with the one closest to the square root of the number and work down the list.
20:30:55 <andares> until I find one that divides.
20:31:11 <ezyang> Way late to the party, but JoeyA, edwardk, thoughtpolice http://blog.ezyang.com/2012/01/modelling-io/
20:31:24 <mm_freak> for the largest prime factor of n you should probably start at n/2
20:31:39 <mm_freak> and work backwards
20:31:41 <ezyang> I do talk about MonadCatchIO, and I think that there are simple changes that can make it more modern and more reasonable.
20:32:00 <andares> mm_freak: should I use binary search to find what prime is closest to n/2?
20:32:03 <mm_freak> also trying only primes is going to be less efficient than using a wheel
20:32:24 <andares> the wheel implementation requires me to build a priority queue though.
20:32:29 <mm_freak> you can't use a search…  finding the largest prime factor is as hard as factoring the number
20:32:43 <mm_freak> you don't need a priority queue
20:33:02 <andares> I can search for the prime closest to n/2 in the list of primes.
20:33:03 <mm_freak> > scanl (+) 5 . cycle $ [2,4]
20:33:05 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
20:33:20 <mm_freak> that's a perfectly fine fast wheel =)
20:34:02 <andares> I still have to find a starting point in that list somehow.
20:34:21 <andares> since the list is infinite, I was thinking of doubling each time until I overshoot, then going back. binary search.
20:34:28 <mm_freak> select a number 6n + 1 or 6n + 5 for a natural number n
20:34:45 <mm_freak> if you select 6n + 1, start with the increment -2, otherwise start with -4
20:35:06 <mm_freak> > scanl (+) (6*100 + 1) . cycle $ [-2, -4]
20:35:07 <lambdabot>   [601,599,595,593,589,587,583,581,577,575,571,569,565,563,559,557,553,551,54...
20:35:17 <mm_freak> > scanl (+) (6*10 + 1) . cycle $ [-2, -4]
20:35:18 <lambdabot>   [61,59,55,53,49,47,43,41,37,35,31,29,25,23,19,17,13,11,7,5,1,-1,-5,-7,-11,-...
20:36:29 <andares> why can you start at 6n+1?
20:36:44 <mm_freak> another way to find the largest prime factor, which should be roughly the same in speed, is to factor out all small numbers, until a prime remains
20:37:04 <mm_freak> 6n + 1 - 2 = 6(n-1) + 5
20:37:12 <mm_freak> 6n + 5 - 4 = 6n + 1
20:37:22 <mm_freak> all numbers you reach are of the form 6n + 1 or 6n + 5
20:37:32 <andares> ah, and you start at n=1 so 7 is a prime, so it'll hit correctly.
20:37:54 <rwbarton> I mean, you just check that the others aren't prime.
20:38:14 <rwbarton> 6n is even (and a multiple of 3), 6n + 2 is even, 6n + 3 is a multiple of 3, 6n + 4 is even. that leaves 6n + 1 and 6n + 5
20:38:21 <mm_freak> yeah
20:38:36 <mm_freak> you "cross out" all numbers that are multiples of 2 or 3
20:41:04 <andares> rwbarton: huh, so you're actually looking at the equivalence classes of N mod 6. interesting.
20:41:12 <dmwit> 30n+1, 30n+7, 30n+11, 30n+13, 30n+17, 30n+19, 30n+23, 30n+29
20:41:29 <andares> oh, that's why the wheel is shaped the way it is.
20:41:48 * hackagebot network-protocol-xmpp 0.4.1 - Client library for the XMPP protocol.  http://hackage.haskell.org/package/network-protocol-xmpp-0.4.1 (JohnMillikin)
20:42:27 <mm_freak> andares: not at the full classes…  the prime numbers themselves need to be checked explicitly
20:42:35 <mm_freak> you need to try 2 and 3 and then use the wheel
20:42:50 <andares> mm_freak: of course.
20:43:08 <andares> is the best primality test just checking square root of the factor down to 2?
20:43:29 <danharaj> no
20:44:10 <danharaj> http://en.wikipedia.org/wiki/AKS_primality_test
20:44:15 <danharaj> (Current best)
20:44:46 <monochrom> heh
20:45:35 <NemesisD> any of you guys use hspec?
20:46:48 * hackagebot gsasl 0.3.3 - Bindings for GNU SASL  http://hackage.haskell.org/package/gsasl-0.3.3 (JohnMillikin)
20:49:32 <NemesisD> can't figure out how to do IO tests in hspec/hunit
20:55:33 <Clint> NemesisD: i don't know anything about hspec, but in hunit you just do them
20:57:45 <NemesisD> Clint: just do it?
20:57:50 <andares> can I not use sqrt on Integers?
20:58:02 <andares> if not, what's the appropriate conversion method?
20:58:09 <geekosaur> fromIntegral
20:58:23 <andares> hm, okay.
20:58:43 <geekosaur> haskell is very strict about types, although some things about it may obscure it at times
20:58:53 <geekosaur> :t sqrt
20:58:54 <lambdabot> forall a. (Floating a) => a -> a
20:59:20 <Clint> NemesisD: test1 = TestCase (ioblockWithAssert)
20:59:27 <andares> so I currently have something in my code like num = 123, then I try to do ceiling . sqrt num and it freaks out.
20:59:34 <andares> it also won't work with fromIntegral
20:59:49 <rwbarton> what's the code with fromIntegral?
20:59:56 <NemesisD> ahh yes i see
21:00:04 <andares> num = 123, then sqrt . fromIntegral num
21:00:06 <rwbarton> "ceiling . sqrt num" isn't right anyways
21:00:17 <andares> how so?
21:00:22 <rwbarton> should be (ceiling . sqrt) num or one of many other options
21:00:26 <JoeyA> lpsmith: Quick question about postgresql-simple: It looks like BYTEA support e.g. (instance Param (Binary SB.ByteString)) uses hex escape format, which is not recognized by PostgreSQL < 9.0.  This means BYTEA support will not work for Postgres 8.4 and earlier.  Is my assessment correct?
21:00:39 <geekosaur> you might want to give num the explicit type Double; the monomorphism restriction is defaulting it to Integer
21:00:55 <ClaudiusMaximus> @check \i -> ((^2) . ceiling . (id :: Double->Double) . sqrt . fromInteger) i == i
21:00:56 <lambdabot>   "Falsifiable, after 1 tests:\n-1\n"
21:01:27 <geekosaur> i yi yi? :p
21:01:36 <lpsmith> JoeyA, yes that is correct, IIRC
21:01:56 <lpsmith> JoeyA, if you'd like to work on fixing that,  I'd be happy to review a patch =)
21:01:59 <JoeyA> lpsmith: I could fix it, but a) I don't know if it's worth it, and b) I'm not sure how to do it gracefully given that it's an instance, and the Connection object is not handy.
21:02:23 <ClaudiusMaximus> @check \i -> ((^2) . ceiling . (id {-for geekosaur-} :: Complex Double->Complex Double) . sqrt . fromInteger) i == i
21:02:24 <lambdabot>   No instance for (GHC.Real.RealFrac
21:02:25 <lambdabot>                     (Data.Complex.Comple...
21:02:33 * ClaudiusMaximus should sleep...
21:02:51 <JoeyA> lpsmith: I'm maintaining my own fork of the libpq package along with my own DB stack, but I'd eventually like to switch my application to postgresql-simple.
21:03:02 <lpsmith> JoeyA, probably the thing to do would be to add a rendering action
21:03:02 <JoeyA> My app is running on Postgres 8.4.
21:03:45 <JoeyA> I really wish postgresql-simple would use parameterized queries instead, but I imagine that's hard to do.
21:04:15 <lpsmith> Actually it's not that hard to do; that's more just the fact that postgresql-simple is a quick port of mysql-simple
21:04:18 <geekosaur> ClaudiusMaximus, I was kidding, you need complex numbers for the -1 case to work
21:04:56 <lpsmith> JoeyA, but yeah, I would add a case in the Param.Action datatype,  to cover BYTEA
21:05:22 <JoeyA> lpsmith: What if we made a BinaryOct newtype instead?
21:06:09 <lpsmith> well, I suppose you could do that,  but you don't need to modify postgresql-simple for that,  if I understand your intention correctly
21:06:51 <JoeyA> Ah, got it.  I see why an action would be better.
21:07:14 <JoeyA> There ought to be an action for hex-escape, too, rather than it using Plain.
21:07:43 <lpsmith> JoeyA, the one thing I don't like about parameterized queries is that you can't bunch multiple statements into one request;  it's a silly restriction in the protocol
21:07:57 <JoeyA> Good point.
21:08:33 <lpsmith> but that may not be as important as parameterized queries, to be honest,  because of the advantages of binary transmission of parameters and results.
21:08:56 <andares> so I have cands n = scanl (+) 6*(ceiling (n/12))+1 . cycle $ [-2, -4]
21:09:02 <JoeyA> lpsmith: I also implemented COPY FROM support, with BYTEA support that I've stress tested on Postgres 8.4.
21:09:13 <lpsmith> and that restriction may not be that big of a deal if I manage to implement the auto-pipelining library I'd like to.
21:09:14 <andares> but any time I try to use it it says there's no instance arising from a use of cands
21:09:20 <andares> so like cands 100 won't work.
21:09:33 <lpsmith> JoeyA, I'm definitely interested in that.
21:09:59 <JoeyA> COPY FROM is for bulk insertion.  By my testing, I was able to insert rows 15x faster with COPY FROM, with each row having a 2000-4000-byte datum.
21:10:38 <andares> what causes the "no instance arising from…" error?
21:10:39 <JoeyA> It uses 8.4 syntax, so each escaped string will be up to 5x larger.
21:10:57 <JoeyA> Could use binary format, but I don't like it.  It's not portable across versions and architectures.
21:11:09 <lpsmith> oh yeah,  I am aware, and I definitely want to get around to proper COPY IN/COPY OUT support at some point.
21:11:49 <JoeyA> I don't think COPY IN is as important, since Postgres can already retrieve rows efficiently using the CURSOR mechanism.
21:12:05 <JoeyA> err, COPY TO*
21:12:40 <JoeyA> COPY_IN is for bulk insertion, and is definitely useful.
21:12:47 <lpsmith> I haven't investigated all the vagaries of binary transmission,  but I'm sure it would be well worth it for certain kinds of data, especially integers and geometries and the like.
21:13:56 <lpsmith> floats
21:14:47 <andares> is there a division function that has typeclass Integral?
21:14:54 <andares> i.e. doesn't need something to be a RealFrac?
21:15:09 <lpsmith> div, mod, divMod, quot, rem, quotRem
21:15:17 <JoeyA> lpsmith: My COPY FROM code uses exceptions to deal with errors.  Unfortunately, the libpq package didn't define an exception type.
21:15:37 <JoeyA> I can't find a clean way to define my withCopyFrom function without exceptions, though.
21:15:51 <lpsmith> andares, ^^^
21:16:01 <andares> oh cool. thanks.
21:16:42 <lpsmith> andares, also,  ghci> :info Integral    will show you all the methods of the class.
21:17:53 <JoeyA> Hmm, I guess I'll just define accessors.  That means more MVar overhead, though.
21:20:28 <lpsmith> unfortunately,  receiving binary parameters is an all-or-nothing proposition
21:21:24 <andares> I'm trying to convert an Integer into a Floating, so I can sqrt it. fromIntegral doesn't seem to do that though.
21:21:56 <lpsmith> andares, fromIntegral should work
21:22:20 <lpsmith> I don't think you've correctly diagnosed the problem you are faced with.
21:22:25 <andares> indeed.
21:22:28 <ClaudiusMaximus> :t sqrt . fromIntegral
21:22:29 <lambdabot> forall a a1. (Floating a, Integral a1) => a1 -> a
21:22:32 <NemesisD> given [(a -> b)], how can i apply an argument over the list?
21:23:12 <andares> it can't match my Integer with GHC.Real.Ratio Integer, it says.
21:23:28 <NemesisD> is this a job for one of [a]'s instances?
21:24:21 <NemesisD> sequence perhaps
21:24:55 <lpsmith> andares, it sounds like you are trying to convert a Rational to a floating point to take the square root
21:25:03 <andares> yep.
21:25:10 <lpsmith> Not an integer
21:25:10 <BMeph> :t flip map . flip id
21:25:11 <lambdabot>     Couldn't match expected type `[a1 -> a]'
21:25:11 <lambdabot>            against inferred type `a2 -> a2'
21:25:11 <lambdabot>     In the first argument of `flip', namely `id'
21:25:15 <lpsmith> then fromIntegral won't work
21:25:22 <BMeph> :t map . flip id
21:25:22 <lambdabot> forall b a. a -> [a -> b] -> [b]
21:25:38 * BMeph nods in approval.
21:25:39 <lpsmith> because Rational isn't a floating
21:25:52 <ClaudiusMaximus> > [show]<*>"show"
21:25:53 <lambdabot>   ["'s'","'h'","'o'","'w'"]
21:26:08 <lpsmith> although,  maybe you should be finding a rational approximation of the square root instead?
21:26:19 <lpsmith> via e.g. continued fractions
21:26:23 <andares> lpsmith: it is an integer. but I do fromRational on it.
21:26:30 <andares> so that I can convert it into something compatible with sqrt.
21:26:38 <andares> oh.
21:26:50 <BMeph> lpsmith: Don't you mean that it won't work, because Rational isn't an Integral? :)
21:27:07 <lpsmith> BMeph, err, yes
21:27:14 <andares> lpsmith: isn't it underlyingly represented as a mantissa and all?
21:27:29 <andares> so it's a rational sum of a finite number of powers of 1/2^i
21:27:32 <lpsmith> Rational is a pair of integers, numerator and denominator
21:27:41 <lpsmith> no
21:27:48 <BMeph> NemesisD: Try "map . flip id". It should treat you right. :)
21:28:16 <lpsmith> rational can represent any reasonable rational number exactly
21:28:56 <lpsmith> andares, ignore my rational approximation comment.  I'd just not convert your integer to rational
21:29:05 <lpsmith> go straight to floating point using fromIntegral
21:29:41 <NemesisD> BMeph: i thought i got it going with sequence
21:30:15 <andares> lpsmith: I have a num = 123123213 such that num :: Integer, then I do (toInteger . sqrt . fromRational)
21:30:22 <andares> num*
21:30:43 <lpsmith> You want  (sqrt . fromIntegral)
21:30:51 <andares> ohh. d'oh
21:30:54 <lpsmith> or maybe  (floor . sqrt . fromIntegral)
21:31:09 <NemesisD> BMeph: weirdly, in my code this compiles but not in a separate file: applyToList :: [(a -> b)] -> a -> [b]; applyToList = sequence
21:31:11 <andares> this seems rather cumbersome. is this standard?
21:31:15 <lpsmith> although such an expression isn't guaranteed to compute the floor of the square root exactly
21:31:42 <ClaudiusMaximus> NemesisD: do you import Control.Monad.Instances ?
21:31:47 <lpsmith> andares, yeah sometimes I prefer Scheme's numerical tower for stuff like this
21:31:50 <lpsmith> Or Python3
21:32:20 <lpsmith> (I hate the way python < 3 deals with integer division)
21:32:35 <NemesisD> ClaudiusMaximus: there we go
21:32:50 <NemesisD> man sequence and the list monad confuse the hell out of me
21:33:28 <ClaudiusMaximus> that's the (->)a monad, not the list monad, if i understand correctly
21:34:12 <lpsmith> although,  in theory,  you could implement Scheme's numerical tower as a Haskell datatype
21:34:44 <lpsmith> Though I don't know how efficient that'd be,  or if there would be some cases that are tricky to handle.
21:39:56 <elliott_> edwardk: Reducer says "Minimal definition: unit or snoc", but unit has no default definition. is this correct?
21:53:28 <koala_bot> I'm being asked to show that (foldr f e . map g) is essentially equivalent to (foldr (f . g) e) but am having trouble as I step through the right hand side; g, according to the left side, should only take one argument whereas on the right it seems it will be applied to 2. Am I wrong?
21:53:53 <Cale> koala_bot: that property is type correct
21:54:02 <Cale> g is only going to be applied to one parameter
21:54:53 <dmwit> (Though (f . g) will be applied to two.)
21:55:03 <koala_bot> That is where I'm getting stuck
21:55:14 <dmwit> ?src (.)
21:55:14 <lambdabot> (f . g) x = f (g x)
21:55:14 <lambdabot> NB: In lambdabot,  (.) = fmap
21:55:17 <Cale> remember, f is a function which produces a function as its result
21:55:27 <Cale> when applied to its first parameter
21:55:32 <dmwit> (f . g) x y = ((f . g) x) y = (f (g x)) y = f (g x) y
21:55:53 <koala_bot> dmwit: so g wil only be applied to the first argument?
21:55:56 <dmwit> The first and last equalities are just by precedence, and the middle equality is by the definition of (.).
21:56:03 <elliott_> koala_bot: There's no real "first argument".
21:56:08 <elliott_> Remember that all functions take one argument in Haskell.
21:56:12 <dmwit> koala_bot: mu =)
21:56:22 <koala_bot> elliott_: Ah that's true :) I'm coming from Java so this makes my head spin sometimes.
21:56:25 <elliott_> (f . g) === (\x -> f (g x)), in this case, that's === (\x y -> f (g x) y)
21:56:35 <elliott_> eta-expansion: f === (\x -> f x)
21:56:45 <elliott_> so (\x -> f (g x)) === (\x y -> f (g x) y) (as long as the type fits)
21:57:19 <koala_bot> so if g happened to be a func that took two argumnts, (f.g) x e would be evaluated f ( g x e)?
21:57:29 <elliott_> there are no functions that take two arguments
21:57:36 <elliott_> (f.g) x e is f (g x) e, always
21:57:40 <elliott_> @src (.)
21:57:40 <lambdabot> (f . g) x = f (g x)
21:57:40 <lambdabot> NB: In lambdabot,  (.) = fmap
21:57:46 <elliott_> (f . g) x = f (g x)
21:57:48 <elliott_> (f . g) x e = f (g x) e
21:58:01 <koala_bot> ack. I did that again.
21:58:18 <andares> http://pastebin.com/Cy7W3YbV hey, could someone help me with this?
21:58:21 <mauke> The paste Cy7W3YbV has been copied to http://hpaste.org/64965
21:58:32 <andares> I'm trying to find the largest prime factor of ano-- oh, cool. -- a number.
21:58:38 <Cale> tab warning
21:58:43 <andares> it's terribly inefficient though.
21:59:03 <Cale> There are tabs in your code, remember to configure your text editor to convert them into spaces automatically.
21:59:16 <dmwit> Tabs are used consistently. No warning is warranted.
21:59:29 <andares> Cale: I think I have soft tabs set up in vim. not sure why it's warning.
21:59:30 <Cale> dmwit: But they're used
21:59:32 <dmwit> Configure your text editor as you like.
21:59:35 <koala_bot> elliott_, Cale, dmwit thank you
21:59:41 <dmwit> Cale's opinion is just one opinion in many.
22:00:02 <Cale> Tab characters while technically legal in Haskell code, probably ought to be lexical errors
22:00:14 <elliott_> andares: The option to set is "expandtabs" if you want that.
22:00:22 <elliott_> Or was it just expandtab...
22:00:26 <dmwit> Please don't start this fight. Let andares make his own choice; I'm sure he's heard all the usual arguments for and against.
22:00:37 <Cale> set expandtab
22:00:44 <andares> right.
22:00:51 <Cale> dmwit: All must bend to the will of spaces.
22:00:59 * dmwit will not bend
22:01:08 <elliott_> I don't see anyone fighting.
22:01:34 <elliott_> It's reasonable to inform people that tabs aren't quite as clear-cut in Haskell as in other languages due to the layout-based syntax.
22:01:37 <andares> anyway, so the algorithm I'm using apparently takes forever.
22:01:43 <dmwit> elliott_++
22:01:47 <dmwit> That is a fine way to say it.
22:01:58 <andares> it seems that isPrime is really slow. I'm not sure if there's anything much better than isPrime though.
22:02:20 <dmwit> andares: Have you seen the wiki page on generating primes?
22:02:25 <dmwit> ?wiki prime numbers
22:02:25 <lambdabot> http://www.haskell.org/haskellwiki/prime_numbers
22:02:29 <Cale> andares: why not only check for prime factors? ;)
22:02:40 <Cale> andares: after all, you have a list of them :)
22:02:41 <elliott_> Overloading is probably not helping your code's speed, andares.
22:02:52 <andares> overloading?
22:02:54 <elliott_> Try adding type signatures to all top-level definitions, and e.g. give primes a monomorphic type.
22:02:57 <elliott_> That might not help, but it's good practice anyway.
22:03:02 <Cale> oh, yes
22:03:05 <elliott_> andares: "(Integral a) => ...". Polymorphism.
22:03:09 <elliott_> Are you compiling with -O2?
22:03:13 <andares> ah.
22:03:16 <elliott_> However, it's true that your algorithm sucks :)
22:03:20 <MostAwesomeDude> So, uh. Why not just call msieve? :3
22:03:21 <andares> uh, compiling? I was just running it from ghci
22:03:26 <elliott_> Ah.
22:03:32 <elliott_> GHCi is not fast.
22:03:54 <andares> still, this feels asymptotically awful.
22:03:56 <elliott_> It is an interpreter; it optimises speed of loading code over execution speed.
22:04:05 <andares> Cale: I am only checking for prime factors aren't I?
22:05:15 <Cale> andares: in isPrime
22:05:20 <Cale> andares: you're testing all the k
22:05:43 <dmwit> I'm surprised about this "cands" thing starting high and going low, and about "cands" or "primes" not being used during factor-checking.
22:05:51 <Cale> also, you're starting with large k, which is slow, because things are more likely to be divisible by small numbers
22:06:37 <dmwit> As usual, Cale explained the issue more clearly and sooner. =P
22:06:39 <andares> dmwit: it starts high because I need to find the largest prime factor.
22:06:50 <andares> I can't just plug primes in instead of k though, can I?
22:08:28 <dmwit> andares: If you let the candidates start low, then you can use "primes" as a list of factors to check, rather than [1..] as you are using here.
22:08:32 <dmwit> [2..], I guess
22:09:02 <dmwit> You're using [2..n] implicitly by starting at n and subtracting one during each recurrence.
22:09:28 <andares> dmwit: but then I won't be able to start with the largest possible prime factor first, right?
22:09:37 <andares> since I can only split head : tail
22:09:43 <dmwit> I'm not sure I understand this requirement.
22:09:45 <dmwit> yet
22:10:17 <Skola_> this requirement == project euler
22:10:36 <andares> yep :)
22:10:43 <dmwit> If you want to write a factoring algorithm that returns factors in reverse-sorted order, the most efficient way to do this is probably to write an efficient factoring that returns it in the usual order, and then reverse that list.
22:10:51 <elliott_> (a) Is the problem seemingly utterly pointless? (b) Does the problem involve primes, or reversing the decimal representation of numbers?
22:11:01 <elliott_> --> Project Euler
22:11:11 <dmwit> (Because the usual order can be made lazy, which plays to Haskell's strengths.)
22:11:34 <andares> dmwit: but reversing it causes it to be un-lazy, correct?
22:11:36 <andares> I guess that's okay.
22:11:36 <elliott_> andares: By the way, you should probably call run "main".
22:11:42 <andares> ah, okay
22:11:45 <Skola_> while we're on the subject: are there more interesting problem sites than project euler?
22:12:09 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p * p <= n) primes); leastPrimeFactor k = find (\p -> k `mod` p == 0) primes; greatestPrimeFactor k = case leastPrimeFactor k of Nothing -> k; Just n | k == n -> k | otherwise -> greatestPrimeFactor (k `div` n) in greatestPrimeFactor 600851475143
22:12:10 <lambdabot>   6857
22:12:31 <Cale> ^^ that way might be a little quicker
22:12:42 * andares breaks down into tears.
22:12:45 <Cale> I just used the cutesy version of primes and isPrime
22:12:47 <Skola_> :[]
22:12:51 <ClaudiusMaximus> this holds?  gpf (a * b) = gpf a `max` gpf b
22:12:54 <Cale> which is mutually recursive :)
22:13:05 <Cale> You can do a lot better if you're willing to do proper sieving.
22:13:16 <Cale> (with priority queues or something)
22:13:23 <dmwit> ClaudiusMaximus: Yes, every prime factor of (a * b) is either a factor of a or a factor of b.
22:15:10 <BMeph> a prime factor of a or b, even.
22:15:34 <dmwit> Becoming a factor of another number doesn't change a number's prime-ness, no. =)
22:16:05 <elliott_> But wouldn't it be gerat if it did?
22:16:48 <Cale> That would make for a lot of primes
22:16:53 <_ttoille> elliott_, you're British right?
22:16:56 <ClaudiusMaximus> hmm, i can't seem to find a soft-float package - i don't need much precision, but the range of Double isn't enough - any ideas?
22:16:57 <andares> Cale: how do you do otherwise -> rather than otherwise = ?
22:17:12 <Cale> andares: that's inside a case expression
22:17:17 <Cale> andares: in a guard
22:17:31 <Cale> I guess I could also have used a pattern guard here
22:17:53 <dmwit> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p * p <= n) primes); factorize = factorize' primes; factorize' _ 1 = []; factorize' (p:ps) n | n `mod` p == 0 = p : factorize' (p:ps) (n `div` p) | otherwise = factorize' ps n in last (factorize 600851475143)
22:17:54 <lambdabot>   6857
22:17:57 <andares> but the syntax of guards is | foo = bar, right?
22:18:14 <Cale> andares: not inside a case expression
22:18:18 <dmwit> andares: The syntax of guards is "| foo", where "foo" is an expression of type Bool.
22:18:24 <BMeph> dmwit: All prime factors are factors. Not all factors are prime factors. Retaining the condition of being a prime factor is information that might be useful to keep. Just sayin'...
22:18:29 <dmwit> ...oh, I misunderstood the question.
22:18:30 <Cale> andares: the result of a case expression comes after -> not =
22:19:46 <andares> Cale: so you have two cases, Nothing and Just n, and for Just n you have two guards.
22:19:52 <Cale> andares: yeah
22:20:23 <BMeph> dmwit: Eh, I'm sure it was me, not you. I didn't know there was a question to answer. :)
22:20:33 <andares> so guards have the syntax <start of some expression> | <conditional statement> <rest of the expression>
22:20:47 <andares> which makes them more general than I thought.
22:21:22 <dmwit> Guards in definition blocks have the syntax "pattern (| condition = value)*", and guards in case blocks have the syntax "pattern (| condition -> value)*".
22:21:45 <dmwit> Here the parentheses and * are meta-syntax.
22:22:00 <andares> ah, okay, so there's no generalization between those two types of guards.
22:22:07 <dmwit> Correct.
22:22:09 <andares> that's kind of ugly, actually.
22:22:13 <Cale> http://www.haskell.org/onlinereport/exps.html#case
22:22:16 <elliott_> H_ekiM: Yes.
22:22:30 <dmwit> I wonder if there's a good reason to use "->" instead of "=" in cases.
22:22:33 <dmwit> Probably not.
22:23:01 <elliott_> I've occasionally wished = was used, but then I realise how confusing
22:23:06 <elliott_> case foo of
22:23:09 <elliott_>   Just y = ...
22:23:10 <elliott_> would look.
22:23:19 <ivanm> dmwit: probably some historical reasons
22:23:28 <ivanm> elliott_: why confusing?
22:23:46 <Cale> Because it's not an equation
22:23:52 <Cale> You're not equating Just y with something
22:23:58 <elliott_> ivanm: It looks like you're assigning something to Just y.
22:24:00 <elliott_> Like let Just y = ...
22:24:02 <ivanm> ahhh, right
22:24:04 <dmwit> elliott_: Yes, trading aesthetics and consistency is a hard choice.
22:24:06 <elliott_> Also it's ugly.
22:24:14 <ivanm> though arguably you can say the same thing about guards :p
22:24:36 <elliott_> dmwit: Lisp is the act of convincing people they're the same thing.
22:24:45 <kallisti> guards work more like a piecewise function but slightly backwards.
22:24:54 <kallisti> so = still makes sense there.
22:24:58 <kallisti> to a degree.
22:25:01 <dmwit> I'm not sure I buy into Lisp's aesthetic.
22:25:06 <Cale> Yeah, guards were originally written after the result
22:25:08 <dmwit> Humans just aren't as good as computers at parsing.
22:25:22 <kallisti> o_O?
22:25:29 <Cale> But it was discovered that in many programs the guards were much shorter than the definition of the result
22:25:31 <kallisti> so how about that natural language.
22:25:36 <Cale> and so placing them first made the code easier to read
22:25:56 <ivanm> Cale: I know Miranda has the guards after the result, but did Haskell originally have that as well?
22:26:10 <dmwit> kallisti: Humans are pretty crap at deeply-nested natural language, too.
22:26:21 <dmwit> So we don't say deeply-nested sentences.
22:26:38 <homie> lol
22:27:19 <kallisti> hm, I suppose humans and computers both excel at different kinds of parsing.
22:27:28 <dmwit> I suppose that's probably accurate.
22:28:17 <kallisti> humans have all this extra environment and implicit stuff lying around.
22:28:35 <kallisti> (true facts. technical terms)
22:31:47 <kallisti> so, reading JSON into Haskell data structures is really tedious..
22:31:50 <Cale> ivanm: Ah, yeah, I was actually referring to Miranda... I'm actually not sure if Haskell ever had it the other way, but I'm thinking not.
22:31:51 * hackagebot postgresql-libpq 0.7.1 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.7.1 (LeonSmith)
22:35:21 <dmwit> kallisti: I suppose you've found some of the Hackage packages for this already, and find it tedious anyway?
22:35:45 <kallisti> Text.JSON is the one I'm using.
22:36:04 <kallisti> I don't suppose there's a better one?
22:36:20 <dmwit> I've heard good things about aeson.
22:36:25 <dmwit> I've never used any of them myself, though.
22:36:34 * dmwit awaits Hackage2's rating system with bated breath
22:37:03 <elliott_> I'm pretty sure ~everyone uses aeson.
22:38:49 <dmwit> ...huh
22:38:56 <kallisti> it may be too late for that.
22:39:04 <kallisti> but it basically looks like Text.JSON but better.
22:40:18 * DanBurton wonders if cabal-nirvana and Hackage2 will join up or remain separate
22:40:19 <kallisti> also DeriveGeneric. ;_;
22:40:22 <kallisti> I should have found this sooner.
22:41:12 <DanBurton> oh btw, aeson comes with some nice Template Haskell for deriving ToJSON and FromJSON instances
22:41:27 <kallisti> oh thanks!
22:41:51 * hackagebot numbering 0.2 - Combinators for creating bijections from some type to the natural numbers.  http://hackage.haskell.org/package/numbering-0.2 (DanielSchuessler)
22:42:13 <elliott_> DanBurton: I don't think there is any overlap between the two.
22:42:50 <DanBurton> right, good clarification. I mean the ToJSON and FromJSON classes defined in aeson itself. http://hackage.haskell.org/packages/archive/aeson/0.6.0.0/doc/html/Data-Aeson-TH.html
22:43:32 <elliott_> DanBurton: Er, I meant cabal-nirvana/Hackage2.
22:44:04 <DanBurton> oh lol
22:44:32 <DanBurton> dmwit mentioned the mythical Hackage2 rating system, which made me think of cabal-nirvana
22:45:02 <elliott_> I think everyone working on Hackage2 doesn't like the idea of a direct rating system anyway :P
22:45:37 <kallisti> I think Hackage2 needs more Facebook integration.
22:45:55 <DanBurton> I had the impression that Hackage2 was about to roll out soon...are they still waiting for something?
22:46:27 <elliott_> I don't think it's even vaguely close to rolling out.
22:46:33 <ivanm> yeah
22:46:45 <elliott_> People said it was, because they hadn't actually looked at it yet.
22:47:04 <astor> hackage.factisresearch.com seems to have been usable for the last couple of weeks.  so you can try hackage2 out now if you wish.
22:47:05 <kallisti> hm, can top-level TH have a where clause?
22:48:02 <DanBurton> astor: yes, that's what gave me the impression that it was coming soon to a hackage.haskell.org near you
22:49:31 <elliott_> That's just a development site. It's undergoing a fairly major restructuring (at least unless cmccann gave up), and there is at least one thing it absolutely needs before it'll be viable to put it up live.
22:49:36 <astor> DanBurton: but you can just use factisresearch.com.  Do you really need hackage.org to point to it?  Just reconfigure cabal.
22:49:42 <elliott_> I don't think anyone is rushing to deploy it, since Hackage1 works just about fine.
22:49:53 <gentleben> what problems is it solving? my impression is the it had the same functionality
22:49:58 <elliott_> i.e. until Hackage2 actually gets more than feature parity.
22:50:06 <elliott_> (OK, it has slightly more than that right now, but only slightly.)
22:50:40 <elliott_> gentleben: Hackage1 doesn't really scale to the number of packages we have now and it isn't really viable to add new features to it.
22:50:52 <astor> changing to a code base people are willing to work on is a net win - even if some features are *lost*.
22:51:53 <gentleben> well its not like hackage has a lot features
22:52:12 <gentleben> if its a scaling thing that shouldn't be that big a deal
22:52:30 <gentleben> even the brogrammers man get websites to scale
22:52:45 <gentleben> are there a list of issues compiled somewhere?
22:52:50 <elliott_> It's a pile of CGI (or was it FastCGI?) scripts.
22:52:52 <elliott_> Anyway, Hackage2 is mostly written.
22:52:57 <elliott_> So there's no point going back to Hackage1 now.
22:53:13 <gentleben> so its shipping?
22:53:16 <elliott_> No.
22:53:19 <elliott_> I said "mostly".
22:53:24 <elliott_> It works: http://hackage.factisresearch.com/
22:53:29 <elliott_> But it's not ready for prime-time.
22:53:49 <gentleben> whats the issue?
22:53:54 <gentleben> issue(s)
22:53:57 <astor> If you're a client, just point your cabal config to hackage.factisresearch.com.  It works fine.  It is mirroring hackage.org AFAIK.
22:54:19 <elliott_> One is that anyone can sign up and upload a package without even passing a CAPTCHA.
22:54:36 <elliott_> astor: I don't think there are any advantages to pointing your client to a development test server.
22:54:43 <kallisti> hm, so, in deriveJSON, I wonder if returning an empty string will skip that field...
22:54:47 <elliott_> Unless you specifically want to test Hackage2.
22:54:57 <kallisti> it doesn't document it so I don't know that it does.
22:55:01 <gentleben> it looks the same, is it just backend changes?
22:55:23 <astor> elliott_: I think there are.  Since I have been using it for a while, I can answer whether "it works" when people regularly ask on irc.  It works for me. :-)
22:55:51 <elliott_> gentleben: There are some differences.
22:55:58 <elliott_> But yes, it's mostly a backend rewrite.
22:56:03 <DanBurton> kallisti: no clue. I've only used it casually, in situations where a server and client used the same data definition file with the same derived JSON.
22:56:31 <DanBurton> it was very painless to serialize to and from JSON that way
22:56:34 <astor> couldn't hackage2 simply add the OpenID stuff that haskellers.org uses, and for a while only have openid-accounts.  It would solve a whole lot of issues.  Then a whole lot of user administration stuff wouldn't have to be implemented.
22:56:49 <DanBurton> but I'm not sure if it would be so painless to have to deal with JSON coming from a foreign source
22:57:07 <elliott_> astor: It already has an account infrastructure. Adding a CAPTCHA and a basic admin-approval process would be simpler than that.
22:57:16 <elliott_> And, of course, OpenID gives much less guarantees
22:57:21 <kallisti> DanBurton: it's not too bad. it's a HTTP + JSON-based protocol.
22:57:36 <elliott_> (you can trivially set up an open OpenID server and use it to spam things -- probably not likely that anyone would bother, but still)
22:57:42 <kallisti> but I abstract over it and so there are fields that don't correspond directly to the lower-level JSON.
22:57:43 <astor> OpenID with a list of providers
22:58:38 <astor> Most OpenID-based sites have a whitelist.  And the large guys have *a lot* of people on staff to deal with account spam.
22:58:55 <elliott_> So you want OpenID without the advantages of OpenID and more work? :p
22:59:02 <elliott_> I mean, OpenID + a CAPTCHA would be fine.
22:59:09 <elliott_> But I don't see how OpenID solves the immediate problem Hackage2 faces at all.
22:59:44 <DanBurton> what's "the immediate problem"?
22:59:46 <kallisti> I'm not seeing anything that resembles a [] checking thing in the TH code
22:59:49 <kallisti> but I can't read TH very well.
22:59:52 <astor> What are the advantages of OpenID again? And what are the immediate problems Hackage2 faces?
23:00:21 <elliott_> <elliott_> One is that anyone can sign up and upload a package without even passing a CAPTCHA.
23:00:33 <elliott_> astor suggested OpenID in response
23:00:36 <astor> Yes and OpenID with a whitelist solves that.
23:00:57 <DanBurton> Is that really a serious problem though? I mean theoretically it could be, but has it ever happened?
23:01:03 <elliott_> http://hackage.factisresearch.com/users/register do you really think adding a CAPTCHA to this page is less work than implementing OpenID and adding a whitelist?
23:01:44 * DanBurton votes for OpenID *and* a captcha for new users
23:01:54 <astor> Maybe not.  But it is definitively a better solution to the implied problem of spam.
23:02:03 <elliott_> DanBurton: well, automated bots probably aren't a problem, although they *will* flood the user list if you put a form like that on the open web. however a basic admin approval of accounts is generally desirable as a short-term solution to discourage the upload of malicious packages
23:02:13 <elliott_> it's not much, but it's a modicum of accountability
23:02:22 <elliott_> anyway if you have opinions on this put it on the bug tracker issue for it
23:02:44 <elliott_> but you'll have a hard time convincing anyone that implementing OpenID is the simplest solution when there's a trivial, known solution already :p
23:03:58 <koala_bot> Would someone kindly explain what the arrow on the right side of this statement is doing?      type Image color = Point -> color
23:04:19 <astor> Ok.  I guess if it is a trivial issue, then it isn't really a blocking issue for deployment, because at the time when someone starts spamming, it is a few minutes of work to fix it.  I guess it is more like finding a way to rationalize why it hasn't been deployed.
23:04:27 <shachaf> koala_bot: Would parentheses help? type Image color = (Point -> color)
23:04:47 <elliott_> astor: it is not really all that much about spam. the admin approval of accounts for upload is much more important
23:04:49 <shachaf> It's just saying that an Image, for some type "color", is a function from a Point to a color.
23:04:56 <Cale> koala_bot: It's saying that for any type color, the type  Image color  is an alias for the function type  (Point -> color)
23:05:02 <elliott_> astor: but anyway that's a really unfair way of putting it. there is no rationalisation
23:05:24 <Cale> koala_bot: That is, an Image color is a function which takes a point and gives a value of type color as a result.
23:05:59 <koala_bot> Thanks you guys... That was my first guess, but it didn't make sense to me why you might do something like that. Could you say that an Image is just a mapping of colors to points?
23:06:13 <shachaf> Cale: I like how I used "for some" and you used "for any".
23:06:18 <shachaf> (With the appropriate swapping.)
23:06:24 <astor> elliott_: Yes that was unfair.  I am not the one doing work for free.  Why is admin approval important?
23:06:42 <shachaf> koala_bot: Keep in mind that "color" can be a lot of things.
23:07:14 <shachaf> koala_bot: It's not some concrete type "Color"; it could be a Bool, for example.
23:07:31 <koala_bot> shachaf: So it could've just as well said 'a' then?
23:07:40 <DanBurton> shachaf: when the correct answer is clearly "for all"!
23:07:46 <Cale> koala_bot: indeed
23:07:55 <elliott_> astor: well, right now the very thin amount of accountability hackage has is that you have to email the admin asking for an account and you get it with your real name. from a technological perspective, this does absolutely nothing to prevent people uploading malicious packages (remember: a "cabal install foo" can wipe your $HOME), but it suffices as a basic barrier to keep riff-raff out.
23:08:14 <koala_bot> So Image is a type which maps points to some other type, specified by Image's argument?
23:08:23 <shachaf> koala_bot: Yes, it could've been "a".
23:08:24 <elliott_> obviously, it's not a long-term solution: but in the short-term, it would be nice not to regress to someone being able to fill out one tiny form with no identifying information, and upload a malicious tarball immediately that anyone can install
23:08:38 <shachaf> But someone decided to use a long-hand name, which means that they're now banned from #haskell forever.
23:08:53 <shachaf> One lowercase Unicode character should be enough for everybody.
23:10:06 <elliott_> astor: there's also a disk space issue (a ten-line shell script can fill up hackage's RAM and disk) -- of course, that can easily be solved by rate limiting, but it's also solved with a simple admin account approval process, so it's easier to just do the one in the short-term
23:13:52 <astor> If hackage used something like S3, and objects with versioning, then cost distribution would be flexible.  If hackage didn't want to pay, you could just point to an S3 object.
23:14:05 <elliott_> You're welcome to implement Hackage3.
23:14:30 <astor> Well, S3 is just an URL right.  Simpler than implementing Captcha.
23:15:03 <elliott_> Exactly. So it should be pretty easy for you ;)
23:15:52 * DanBurton starts sketching out architecture for Hackage7
23:15:55 <astor> Yes. :-) What I am saying is that if hackage did less, it could be more flexible.  Other services are really good at what they do - storage of objects (S3), user account fraud (OpenID) etc.
23:16:47 * astor wipes that whiteboard behind him.
23:16:48 <elliott_> I do not really think we need as much flexibility as you think.
23:17:14 <elliott_> Hackage1's major problems are scaling, and the inability to find good packages (i.e. sort the crap out).
23:17:26 <elliott_> Hackage2 solves the former and can easily be extended to do the latter by design.
23:20:26 <astor> How does the scalability issue with hackage1 manifest itself? Is it related to storage of the large blobs?
23:21:28 <elliott_> I don't know the details of Hackage1's problems. That brain space is devoted to Hackage2's.
23:25:35 <adnauseam> does calling a data type algebriac mean it's Ordered ?
23:25:56 <shachaf> No.
23:30:11 <c_wraith> an algebraic data type consists of products and sums.  Products are constructors that take multiple arguments, sums are multiple different constructors for the same type
23:31:41 <adnauseam> hmm - yeah i'm starting to understand it
23:31:55 <dreixel> anyone here uses eclipseFP?
23:32:18 <dreixel> or Leksah?
23:32:42 <tikhonjelvis> I tried Leksah once. That has to count for something :)
23:33:52 <dreixel> more generally, even, anyone here uses eclipse for any language?
23:33:58 <BMeph> I tried Leksah once...once. ;)
23:34:04 <tikhonjelvis> I used it with Java for a while.
23:34:12 <adnauseam> it's a massive hulk of bloat
23:34:14 <dreixel> actually so did I, but it was so long ago...
23:34:23 <dreixel> I'm wondering what it does when your program does not compile
23:34:34 <dreixel> besides showing where the error is, can it still give you contextual information?
23:34:35 <tikhonjelvis> lag
23:34:56 <dreixel> does it try to fix it in some way on the background?
23:34:56 <DanBurton> I used eclipse back in my Java days. Dark times, they were.
23:35:27 <adnauseam> DanBurton: what would you use to develop for something like the android  ?
23:35:31 <tikhonjelvis> I'm not sure what's more annoying--Eclipse or that Java requires something like that.
23:35:32 <dreixel> I'm equally curious about how visual studio deals with this.
23:35:46 <DanBurton> adnauseam: oh if you're developing for android Eclipse is a must.
23:36:05 <adnauseam> yeah - i was afraid i is
23:36:08 <adnauseam> it is*
23:36:24 <Enigmagic> dreixel: they spent a long time working on parsers that handle errors
23:36:24 <DanBurton> I mean, it's either Eclipse or learning a bunch of obscure little command line quirks
23:36:39 <tikhonjelvis> Could you use IntelliJ for Android?
23:36:44 <dreixel> Enigmagic: right, but imagine it's a type error
23:37:08 <Enigmagic> dreixel: ghc has an extension to allow some type errors to compile
23:37:11 <DanBurton> tikhonjelvis: possibly, but Google put a lot of Android love into Eclipse extensions.
23:37:45 <dreixel> Enigmagic: lol, yes, that's exactly why I'm asking this. I'm looking for related work :)
23:38:21 <NemesisD> could someone take a look at this? i tried to write a cleanup function that runs an IO action and then does cleanup. the io action runs but the cleanup does not
23:38:23 <hpaste> NemesisD pasted “spec cleanup” at http://hpaste.org/64966
23:38:50 <NemesisD> wait const doesn't evaluate its second argument does it
23:39:00 <DanBurton> correct
23:39:26 <Enigmagic> dreixel: looking to implement better features for this in GHC?
23:39:45 <dreixel> I actually found a good description for visual basic: http://msdn.microsoft.com/en-us/magazine/cc163781.aspx
23:39:54 <dreixel> Enigmagic: I think this could be very useful in IDEs
23:40:00 <DanBurton> NemesisD: hence the hlint suggestion to replace `const io $ runredis conn cleanup' with simply `io'
23:40:19 <NemesisD> finally i think is what i want
23:40:28 <Enigmagic> dreixel: that's why they do it. the f# compiler source was/is available online, might be worth taking a look at
23:41:15 <DanBurton> NemesisD: if you want to perform `io' and then `runRedis conn cleanup', then just stick `>>` between them, which can be read "and then"
23:42:34 <dmwit> ?go the io monad for people who simply don't care
23:42:34 <lambdabot> Maybe you meant: google googleit do
23:42:40 <dmwit> ?google the io monad for people who simply don't care
23:42:42 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
23:42:42 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
23:43:09 <dmwit> Can somebody who understands lambdabot just add a plugin that reinstates ?go, please? =P
23:43:17 <shachaf> ?go a
23:43:17 <lambdabot> Maybe you meant: google googleit do
23:43:30 <shachaf> dmwit: That's pretty easy.
23:43:56 <shachaf> But writing the plugin and getting it into what Cale runs is not equivalent.
23:44:00 <shachaf> You'd better ask Cale to do it.
23:44:06 <shachaf> @googleit a
23:44:07 <lambdabot> http://letmegooglethatforyou.com/?q=a
23:44:24 <NemesisD> DanBurton: the only wrinkle that made me go with finally is that i need to run the first one, then the second, then return the result of the first
23:44:49 <tikhonjelvis> Heh, lambdabot has a command for being condescending.
23:47:49 <dmwit> NemesisD: (<*)
23:47:59 <dmwit> :t (<*)
23:48:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
23:48:01 <dmwit> :t finally
23:48:02 <lambdabot> Not in scope: `finally'
23:48:07 <dmwit> ?hoogle finally
23:48:07 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
23:48:07 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
23:48:07 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
23:48:44 <dmwit> "finally" and "(<*)" treat exceptions differently, so pick the one that matches what you want to do in case of an exception.
23:49:10 <dmwit> "finally" always runs its second argument; "(<*)" only runs its second argument when the first doesn't throw an exception.
23:50:38 <NemesisD> dmwit: finally should re-raise the exception though right?
23:51:57 <kallisti> anyone here used Aeson before?  I can't figure out how to do  FromJson a => ByteString -> Result a
23:52:01 <kallisti> *FromJSON
23:52:16 <kallisti> decode returns a Maybe, but I want error information as well.
23:52:32 <kallisti> I think I'm supposed to use parse, but also can't figure out what argument to give it.
23:52:32 <ChristianS> NemesisD: sure
23:52:39 <NemesisD> kallisti: parse json
23:53:21 <NemesisD> dmwit: ChristianS i'm going to keep <* in my pocket because it sounds handy. technically i think i want finally here since its test cleanup. if it doesn't run, the next run of the test will fail
23:53:42 <kallisti> NemesisD: I don't think json is the right type there...
23:55:46 <NemesisD> oh sorry, thats not it
23:56:38 <NemesisD> Data.Attoparsec.ByteString has parse :: Parser a -> ByteString -> Result a
23:56:53 <NemesisD> so parse json str
23:57:23 <kallisti> ah, yep.
23:57:23 <QinGW`> what is lift?
23:57:23 <dmwit> NemesisD: Yes, finally should re-raise the exception after executing the second action.
23:57:25 <NemesisD> then you could use eitherResult :: Result r -> Either String r
23:57:26 <kallisti> I just found it in source as well.
23:57:36 <kallisti> NemesisD: no need for that.
23:57:46 <kallisti> I'm converting the Result directly to an Error type.
23:58:25 <NemesisD> cool
23:58:39 <kallisti> kind of strange that aeson doesn't expose that.
23:58:46 <kallisti> since it uses code similar to that internally.
23:59:34 <NemesisD> the docs aren't great on the matter. it took some struggling for me to figure out i had to look at another library to get things going
