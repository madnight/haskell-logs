00:02:18 <xrl> would it be a bad idea to catch socket errors (connect failing) and turn them in to Maybe?
00:03:08 <kaitocracy> I'm a Haskell noob but I'm going to guess no
00:04:37 <xrl> kaitocracy: now that I think about it... how would I handle connections just dying after connecting... looks like I will have to handle errors
00:05:25 <kaitocracy> xrl: Does it matter? Either way you can'r use the socket
00:06:04 <xrl> then maybe start's creeping every where?
00:07:22 <kaitocracy> xrl: No problem dude, just code everything monadically
00:07:33 <kaitocracy> Okay don't listen to anything I have to say
00:07:37 <cy1> I like to think of Maybe as "can't tell yet"
00:07:48 <kaitocracy> I'm a pretty serious noob
00:07:50 <cy1> your socket had an error, you don't have a connection, no Maybe about it!
00:08:42 <xrl> cy1: ya, that's kind of how I think about it. I should probably find some existing code and study it... warp server perhaps? :)
00:08:58 <cy1> Never looked at that server actually.
00:13:55 <xrl> Warp uses iteratees to do IO: http://steve.vinoski.net/pdf/IC-Warp_a_Haskell_Web_Server.pdf
00:14:18 <nart> xrl: the new "cool" way to do it is through conduit or pipes
00:14:38 <xrl> nart: are conduits or pipes as 'fast' as iteratee?
00:14:41 <Enigmagic> warp uses conduits now
00:14:43 <xrl> some sick numbers in that PDF :)
00:14:48 <xrl> ah
00:15:04 <nart> xrl: no idea, but i think so because everyone is using it
00:15:18 <cy1> Oh, so the problem is with the ghc -package argument...
00:16:46 <kaitocracy> Speaking of warp should I bother to use conduits if all I'm doing is hitting the DB for some simple queries and displaying it using blaze-html?
00:17:06 <cy1> does anyone know what it means to "expose" a package, and why trying to do that to a package named Cabal-1.14.0 would error out with the above error?
00:17:06 <kaitocracy> Or is responseLBS fine?
00:17:49 <Enigmagic> responseLBS is fine for simple stuff like that, unless the queries return a lot of data
00:18:32 <cy1> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/packages.html seems to answer that...
00:18:36 <kaitocracy> How would I even use blaze-html with conduits?
00:19:20 <Enigmagic> cy1: i'd reinstall and uhm don't install packages with --global
00:20:00 <cy1> Don't use --global? o.O But they take so long to compile for every user...
00:20:14 <Enigmagic> kaitocracy: blaze-builder-conduit ?
00:20:18 <nart> kaitocracy: i don't see how they're related
00:20:23 <kaitocracy> Why not use your distro cy1
00:20:46 <cy1> kaitocracy: It uses cabal :/ Gotta love AUR
00:20:58 <Enigmagic> cy1: okay, then be more careful about using cabal-install ... try using "cabal install <packagename> --dry-run -v" and make sure it's not going to downgrade a package before installing it
00:21:00 <kaitocracy> cy1: Wait you're an archer?
00:21:08 <cy1> Only on my laptop!
00:21:14 <kaitocracy> cy1: Dude just use Arch-Haskell
00:21:32 <cy1> ...that different from ghc?
00:22:04 <kaitocracy> cy1: Arch-Haskell is a binary repo of haskell packages
00:22:12 <kaitocracy> They've got almost all of hackage
00:22:16 <cy1> Enigmagic: It does downgrade some packages. Cabal-1.14.0 is the most recent, and it requires directory<1.2 which downgrades directory and process. Then fails.
00:22:38 <Enigmagic> cy1: Cabal should come with ghc and doesn't need to be installed from hackage
00:22:39 <cy1> kaitocracy: I don't mind compiling it once.
00:23:01 <cy1> Enigmagic: Yes I have cabal, just it won't install syb.
00:23:33 <kaitocracy> cy1: I mean cabal isn't a package manager; Arch-Haskell basically ports cabal packages to Arch packages so you can install and manage with pacman
00:23:34 <cy1> syb depends on Cabal-1.14.0 which depends on an old directory, which depends on an old process. Once it's installed all that, it claims none of it can be used.
00:23:55 <kaitocracy> cy1: All you have to do is add two lines to your pacman.conf
00:23:55 <cy1> kaitocracy: Uh, so oh so it's an overlay type thing?
00:24:08 <cy1> How do they compile it though?
00:24:13 <kaitocracy> cy1: Yeah it's an unofficial repository
00:24:20 <kaitocracy> cy1: They use devtools
00:24:30 <kaitocracy> cy1: Everything is compiled in clean chroot
00:25:06 <cy1> That'd still fail to compile syb, according to what I see here. I don't know exactly what I'm doing wrong.
00:25:26 <cy1> I guess I can use their copy though. It irks me to be totally unable to compile it though.
00:25:47 <cy1> it's not a good idea to use something that you can't read, or derive from what you can read.
00:26:01 <Enigmagic> cy1: install an older version of syb or build cabal-install from darcs and use the --solver=modular option.
00:26:28 <kaitocracy> cy1: Bro just pacman -S haskell-syb
00:26:28 <kaitocracy> It's an official package in community
00:26:32 <kaitocracy> http://www.archlinux.org/packages/community/x86_64/haskell-syb/
00:26:40 <cy1> Enigmagic: But older packages would even install
00:26:50 <kaitocracy> You can check the PKGBUILD to see if they do any magic
00:27:01 <cy1> kaitocracy: Haha I guess it is. I didn't notice. I was trying to install haskore, which is not official outside of AUR.
00:27:20 <Enigmagic> cy1: the cabal-install version that ships with the platform is a piece of crap (imo)
00:27:56 <Enigmagic> and for some reason they haven't made an official release with the better version stuff in it that doesn't break packages by default.
00:28:29 <cy1> Enigmagic: huh...
00:29:14 <Enigmagic> cy1: the version of cabal-install you have will try to install the newest version of whatever library you wanted it to build, even if it breaks all your existing packages
00:29:42 <cy1> Enigmagic: That it will. Seems like I had physically forced it to downgrade everything to the point it was all agreed though...
00:30:07 <cy1> Anyway if the darcs cabal works better I'll go for it.
00:30:20 <Enigmagic> cy1: the newer version is a bit less retarded
00:30:39 <Enigmagic> just use the --solver=modular arg and it seems to do the right thing
00:31:01 <cy1> is 1.14.0 really an older version? Hm...
00:31:41 <Enigmagic> that's the most recent version of Cabal
00:31:55 <Enigmagic> you probably have cabal-install 1.10 or 1.12
00:32:23 <cy1> Versions installed: [ Unknown ]
00:32:25 <cy1> <_<
00:32:33 <Enigmagic> run "cabal --version"
00:32:43 <cy1> shit
00:32:52 <cy1> cabal-install version 0.10.4 using version 1.14.0 of the Cabal library
00:33:31 <ivanm> the "newer version" is the one that hasn't been released yet
00:33:56 <cy1> cabal install --global cabal-install requires base<4.4 hm...
00:34:11 <ivanm> cy1: don't use global!
00:34:14 <cy1> So if I downgrade base, then install cabal-install, then it'll allow me to upgrade without breaking shit
00:34:21 <ivanm> cy1: you can't downgrade base
00:34:23 <Enigmagic> you can't downgrade base
00:34:33 <cy1> ivanm: DON'T YOU TELL ME WHAT TO I mean why not use global?
00:34:48 <ivanm> cy1: because it leads to too many cases of breakage
00:34:59 <cy1> Why would it be different from a per-user directory?
00:35:07 <ivanm> unless you *really* need to install it for multiple users
00:35:14 <ivanm> cy1: per-user, you can just wipe it and re-install
00:35:28 <cy1> oh
00:35:29 <ivanm> if it's global, you have to be more careful about wiping it
00:35:48 <cy1> ivanm: so there's no place like in python site-packages that you can just delete, while keeping core libraries.
00:35:57 <ivanm> not really
00:36:04 <cy1> I guess I could just rsync .cabal to every user that uses it.
00:36:13 <cy1> That way only compiles once.
00:36:19 <ivanm> cy1: which distro is this for?
00:36:27 <cy1> Arch ._.
00:36:41 <cy1> and yes I know there's a bunch of compiled stuff for Arch
00:36:42 <ivanm> or else consider using something like stow that allows you to more safely "install" arbitrary stuff
00:36:48 <ivanm> cy1: so why not use it?
00:37:01 <cy1> Because I want to be able to compile it!
00:37:03 <cy1> Um...
00:37:14 <ivanm> doesn't arch let you compile stuff if you really want to?
00:37:27 <cy1> Sure, but not for... oh actually yeah...
00:37:49 <cy1> But what I mean to say is I already kind of screwed up my global package directory for ghc, not knowing not to use --global.
00:38:35 <ivanm> cy1: if nothing else, by default haskell executables are statically linked, so you can compile cabal-install as a user and then just copy the binary somewhere in the global PATH
00:38:35 <cy1> I'll just fix that and use that Arch-Haskell repository I guess.
00:38:38 <ivanm> *tsk, tsk*
00:38:39 * colock uses --global
00:39:03 <cy1> and by fix I mean delete indiscriminantly
00:39:12 <cy1> reinstall ghc...
01:00:11 <cy1> And Arch-Haskell doesn't have haskore.
01:01:58 <cy1> Or cabal.
01:02:13 <Enigmagic> Cabal comes with ghc
01:02:28 <Enigmagic> (with a capital C)
01:02:35 <Enigmagic> cabal-install does not
01:03:19 <cy1> Well I need cabal-install to install haskore, right?
01:03:32 <Enigmagic> probably
01:04:02 <liyang> cabal install cabal-install … oh wait.
01:04:09 <liyang> WE MUST GO DEEPER!
01:04:29 <cy1> I can install cabal-install from Arch, but it's not in the Arch-Haskell repository. And is old.
01:04:45 <cy1> But once I have cabal installed, "cabal install cabal-install" fails saying my base is too new.
01:05:02 <Enigmagic> yes you'd need to pull cabal-install from darcs or git
01:05:23 <cy1> Some links would be nice.
01:06:07 <cy1> Sorry I dunno where the darcs or git would be.
01:06:29 <Enigmagic> how do you think i'd find it? :P
01:07:29 <cy1> You're all haskelly and stuff!
01:07:36 <cy1> http://www.haskell.org/cabal/code.html anyway
01:08:24 <Enigmagic> there's also a mirror here if you don't want to install darcs http://darcs.haskell.org/packages/Cabal.git/
01:10:22 <cy1> I've already got darcs at least.
01:19:52 <hpaste> sohum pasted “slow array function” at http://hpaste.org/66216
01:20:50 <sohum> I really don't know why http://hpaste.org/66216 is taking about 18 seconds. it's being called about 230k times, to be fair, but still.
01:21:05 <sohum> sorry, 25 seconds
01:21:36 <ciaranm> ! is slow
01:21:45 <cy1> ugh
01:21:49 <sohum> is it?
01:21:59 <cy1> I had broken binary packages in /root/.ghc cache
01:22:11 <cy1> now the recursive etc error just sort of vanished
01:22:35 <Jaak> @t unsafeRead
01:22:35 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
01:23:13 <sohum> unsafeAt, you mean?
01:23:14 <sohum> hm
01:25:30 <sohum> isn't really saving time
01:25:54 <sohum> its %alloc numbers are also high, but I'm assuming it's just because the ws array is being passed to it
01:29:07 <sohum> yea, unsafeAt is making almost no difference, and seems to be reliably slightly slower (?!)
01:32:26 <edwardk> dumb ffi question. if i have a c function that actually returns a structure, i'm basically forced to wrap it for ffi purposes, right?
01:33:51 <edwardk> i could make a custom foreign prim or something
01:34:29 <cy1> edwardk: technically c functions can only return pointers to structures, not actual structures... it's a pointer-sized limit to the return data.
01:35:16 <cy1> Well I got the new cabal installed 0.15, and tried installing haskore again. "directory-1.1.0.2 (reinstall) changes: filepath-1.3.0.0 -> 1.2.0.1" anything horribly awry about that?
01:35:25 <cy1> I got a message cabal: The install plan contains reinstalls which can break your GHC
01:35:49 <edwardk> cy1: http://opensource.apple.com/source/CF/CF-476.10/CFBase.h __CFRangeMake is the culprit at hand
01:35:52 <cy1> --avoid-reinstalls fails because the old version of directory it installs is broken for new haskells
01:36:03 <cy1> apple.com
01:36:06 <cy1> >ohshit.jpg
01:36:44 <edwardk> which is definitely returning a whole struct =)
01:36:58 <cy1> well, sort of
01:37:12 <cy1> technically that should fail on compilers that don't support long longs
01:37:22 <edwardk> sure. i'm not worried about those
01:37:24 <cy1> but hey if it works for apple, who cares about anything else!
01:37:53 <edwardk> well, they use it for every single indexing operation on a CFString, so they kinda care about the performance for this one primitive ;)
01:38:16 <edwardk> but that is a good point
01:38:28 <edwardk> i can just smash it into a long long
01:38:36 <edwardk> well
01:38:56 <edwardk> i probably can't do that through the ffi either =)
01:39:36 <cy1> if they kinda cared about the performance they wouldn't use longs for byte array indices.
01:42:01 <edwardk> hrmm, not seeing how that packs, the two CFIndexes are both signed longs, and a long long on an LP64 platform is also 64 bit
01:42:46 <cy1> huh
01:42:49 <cy1> no clue then
01:43:16 <cy1> write a program that generates a pre-baked range and then analyzes it in haskell to find the byte order etc :|
01:43:35 <edwardk> probably http://llvm.org/releases/2.3/docs/ReleaseNotes.html
01:43:42 <edwardk> the Multiple Return Value support
01:43:49 <edwardk> but CFRange has been around for a long long time
01:43:53 <edwardk> so that seems odd to me
01:44:17 <edwardk> mayotoh that was 2008 or so
01:44:26 <Enigmagic> cy1: uhm edit the version constraints on the haskore.cabal file and try again
01:44:32 <edwardk> trying to remember when the macs went 64 bit
01:45:16 <cy1> Enigmagic: Sure, let me just get that file...
01:45:16 <t7> when will it be my turn for apple mac?
01:45:32 <Enigmagic> cy1: run "cabal unpack packagename" and it'll do it for you
01:45:32 <sohum> so yea, don't know why http://hpaste.org/66216 is taking about 25 seconds and hitting 75% alloc. it's being called about 230k times, to be fair, but still. and switching to unsafeAt doesn't help.
01:45:53 <edwardk> looks like it was shortly thereafter
01:46:12 <Enigmagic> edwardk: does it need to be portable or fast?
01:46:15 <cy1> Enigmagic: I've already got the darcs for haskore, actually <.<
01:46:28 <edwardk> enigmagic: i like fast. portable is negotiable ;)
01:46:31 <cy1> Man, so many upper bounds.
01:46:53 <cy1> Is it standard for Haskell programmers to assume their program will break in higher versions, instead of waiting for it to break before inserting blocks on upgrades?
01:47:05 <Enigmagic> edwardk: i mean, portable to other peoples computers? :) you could take a look at http://breaks.for.alienz.org/blog/2012/02/09/parsing-market-data-feeds-with-ragel/ if not
01:47:15 <edwardk> anyways, this makes sense, they'd been using the struct packed into a 64 bit register when the indices were 32 bit, and lost that invariant when they went 64 bit
01:47:20 <t7> cy1: it will break on a major version
01:47:27 <t7> you should assume
01:47:47 <Enigmagic> that policy works fine if everyone upgrades their packages :P
01:48:02 <cy1> t7: I see >1.0 && <1.1 though, not the greatest design IMO
01:48:02 <edwardk> Enigmagic: yeah, i've actually thought about spitting out llvm for some other purposes with this
01:48:39 <cy1> I'll try changing it to >1.0 && <2.0
01:48:54 <cy1> though =1 would be clearer I think.
01:49:32 <Enigmagic> cy1: ==1.*
01:49:50 <cy1> Ah, gotcha Enigmagic.
01:49:51 <edwardk> Enigmagic: i've written a bunch of custom primops for dealing with mpfr, i'd just thought i'd gotten away from that sort of thing
01:50:25 <Enigmagic> edwardk: you could write a plugin for clang or llvm that does the fixups ..
01:50:37 <Enigmagic> or fix the ffi system to support more types
01:50:38 <Enigmagic> :)
01:50:45 <edwardk> i may have to, if i want to be able to dispatch a large number of the selectors that exist on a 64 bit machine =(
01:51:04 <edwardk> since many of these selectors seem to be pretty big
01:51:15 <edwardk> or rather to take pretty big structs
01:51:30 <edwardk> passing CFRanges around seems to be half of what CFString doe
01:51:38 <cy1> "Could not deduce (Eq a) arising from the literal `0' from the context (Num a)" x.x
01:51:49 <edwardk> and i can manage them individually for CFString
01:52:04 <cy1> fringe :: Num a => a -> Cluster -> [SNote]
01:52:19 <edwardk> but I can't do that for all the other objective c bindings, since that invalidates my assumption that i can actually ffi out to this stuff
01:52:22 <cy1> fringe 0 (Cl n _)   = [n]
01:52:27 <adnauseam> alo - how does one go about proving the Monadic laws for Maybe? (not looking for a solution, just a couple of pointers)
01:52:30 <cy1> so Num a => a doesn't apply to 0?
01:52:33 <cy1> that doesn't make sense.
01:53:08 <Enigmagic> cy1: make it say "(Eq a, Num a)"
01:53:18 <Enigmagic> Num no longer implies Eq
01:53:31 <cy1> Enigmagic: o.O gotcha...
01:54:35 <cy1> aw crap, now every Num a in there has to be replaced with Eq a, Num a
01:54:41 <Enigmagic> yep
01:54:50 <Enigmagic> enjoy :)
01:54:59 <edwardk> yeah it looks like i'm going to have to actually build a magic llvm binder to call out to those things
01:55:11 <cy1> (Num a, Num b) => (Eq a, Num a, Eq b, Num b) ?
01:55:12 <edwardk> since i can't actually bind to them through libffi even
01:55:23 <edwardk> so even if ghc wanted to they don't have a path ;)
01:55:28 <Enigmagic> cy1: yes
01:56:10 <edwardk> cy1: its worth it in the end, you get lots of new valid Num instances to play with
01:56:11 <cy1> So Haskell no longer assumes that 0 is a number...
01:56:22 <cy1> Or is it for weird numbers or something?
01:56:24 <edwardk> no, 0 is a number, we just no longer assume that we can compare numbers
01:56:37 <edwardk> you have to have something else to tell you that
01:56:48 <cy1> Oh, so like you can't compare a... I can't think of two numbers that can't be compared.
01:56:58 <cy1> Even complex numbers just convert the real to complex.
01:57:08 <edwardk> lemme give you an example of an interesting case
01:57:14 <Enigmagic> floating point numbers shouldn't be compared for equality most of the time
01:57:28 <edwardk> instance Num a => Num (e -> a) where f + g = \a -> f a + g a
01:57:41 <edwardk> how can i compare f and g for equality?
01:58:05 <cy1> I don't understand what "Num (e -> a)" means... shouldn't it be "(Num e->a)"?
01:58:06 <edwardk> what about computable reals where i have infinite precision and equality often will provably bottom out?
01:58:27 <edwardk> No, I'm saying any function from e -> a is a number as long as a is a number
01:58:49 <edwardk> you can multiply two functions that return numbers as and get a new function. the arg you get you pass to both
01:59:03 <cy1> a function can be a number...?
01:59:06 <edwardk> f * g = \a -> f a * g a
01:59:21 <edwardk> then 2 * g   works even when g is a function
01:59:23 <cy1> Oh, the distributive property...
01:59:39 <edwardk> we can do everything we need to make a Nu
01:59:40 <edwardk> er Num
01:59:49 <edwardk> we have abs, + * - signum and fromInteger
02:00:07 <edwardk> all can be implemented for functions from something to a value for which there is a Num
02:00:15 <cy1> So Num is more duck typed than strictly typed?
02:00:18 <adnauseam> cyl; think more in the direction of that things can be compared only if they belong to the same group and are defined as ordered. you can't really compare 3 to 4 in the sense that you can't go comparing the attributes of 3 eggs to 3 lumps of concrete. you can't just arbitrarilly say 3 eggs are equal to 3 lumps of concrete. even if you had 4 eggs - you'd still be missing the context. context in our case would "naturally" mean quantity, but it's a bit un
02:00:19 <edwardk> as a result functions of multiple arguments are also nums, by induction
02:00:34 <edwardk> no this is a strict type. all the laws we'd want a Num to have still hold
02:00:39 <edwardk> it still acts ring-like
02:00:47 <edwardk> i say like
02:01:02 <cy1> adnauseam: You can specify a unit for a number? I'd think you'd have to make a Unit type of that.
02:01:11 <edwardk> Num used to have two extra bits of functionality shoehorned in
02:01:17 <edwardk> it used to require that you can show them
02:01:24 <edwardk> and it used to require that you can compare them for equality
02:01:35 <cy1> Ah, yeah showing pi might not be all that do-able...
02:01:39 <edwardk> neither one is a good idea
02:02:03 <adnauseam> cy1: you can specify anything as anything as long as you specify, the action of actively defining being the main focus here, yeah
02:02:11 <edwardk> well, showing a function \ a -> case a of Foo -> 1; _ -> 2     is also not a good idea ;)
02:02:16 <adnauseam> it's sort of a philosophical argument really
02:02:31 <cy1> Comparing two algorithms for generating pi would be an infinite loop, provided the algorithms only vary in speed of precision not getting any digits actually wrong.
02:02:44 <edwardk> cy1: yeah thats the computable real example i mentioned
02:03:05 <edwardk> CReal's in haskell hunt and just claim they are equal after 40 decimal places or so
02:03:08 <edwardk> er punt
02:03:18 <cy1> I would rather the infinite loop honestly, than assume that some numbers cannot be compared...
02:03:32 <edwardk> yes, but i can't even ENUMERATE the arguments to a function to try them
02:03:50 <cy1> But eh... I guess it's a good idea to avoid tempting implementors to punt.
02:03:52 <edwardk> from the perspective of inside the language they can be uncountably infinite
02:04:17 <edwardk> Num is and always has been a wart. This change just made it less warty
02:05:12 <cy1> Something needs to satisfy Eq in order to be used in one of those case-lambda style function definitions? Like 0-> something\n1 -> somethingelse\nm -> otherstuff
02:05:33 <edwardk> fyi you pick the Eq constraint up the moment you get to Integral, so many use cases didn't change
02:06:06 <edwardk> not in general, but for the numeric literal syntax, yes. normally its a pattern match on the constructor
02:06:11 <cy1> Ah, so integers have Eq as a requirement, but not numbers in general, because of the infinite loop problem with comparing infinite precision real numbers.
02:06:29 <edwardk> well that isn't the example i'd use
02:06:38 <cy1> I suppose the various forms of infinity could also be numbers, and not really comparable...
02:06:45 <edwardk> the one i'd use is the function from something to a number
02:06:58 <edwardk> that is not something you can even try to loop over!
02:07:15 <cy1> How is the function from something to a number, a number?
02:07:42 <ciaranm> category theorists think sets don't have elements, and that an element of a set is just a function to that set
02:08:22 <edwardk> > let f x = 1 + x; g x = 2 * x in (f + g) 12
02:08:23 <lambdabot>   37
02:08:27 <adnauseam> what do sets have ? o_0
02:08:28 <edwardk> > let f x = 1 + x; g x = 2 * x in (f * g) 12
02:08:29 <lambdabot>   312
02:08:36 <PatrickRobotham> That's groovy.
02:08:37 <adnauseam> sets only have functions ?
02:09:04 <edwardk> i can multiply and do multiply functions all day long as a mathematician.
02:09:07 <PatrickRobotham> adnauseam: Category Theorists like to describe everything in terms of dots and arrows.
02:09:24 <ciaranm> an element of a set is just a function from the one element set to that set. a "generalised element" is just a function to that set. it's surprisingly useful to think that way.
02:09:37 <PatrickRobotham> adnauseam: The notion of "element" requires concepts which don't involve arrows.
02:10:02 <ciaranm> doesn't require it at all. it works fine in terms of arrows.
02:10:04 <adnauseam> hrm, interesting
02:10:06 <PatrickRobotham> adnauseam: But we can arrowfy this concept by saying an element of X is an arrow from a singleton set {x} to X.
02:10:29 <PatrickRobotham> ciaranm: Ok, it's traditionally presented using non-arrowy concepts.
02:10:36 <edwardk> ciaranm: notice in that case the 'argument' to my functions was another number, but it doesn't have to be
02:10:41 <edwardk> the same construction works with anything
02:10:47 <adnauseam> how woudl a concrete example be like? say, if i wanted to say that i see three chickens ?
02:11:03 <edwardk> > let f () = 12; g () = 4 in (f + g) ()
02:11:04 <lambdabot>   16
02:11:17 <PatrickRobotham> adnauseam: Let C be the set of chickens.
02:11:19 <ciaranm> adnauseam: then you'd have three functions from 1 to the set of stuff you can see
02:11:30 <edwardk> > let f xs = length xs + 12; g xs = sum xs in (f + g) [1,2,3]
02:11:31 <lambdabot>   21
02:11:41 <ciaranm> adnauseam: and those functions would be called "dinner", "breakfast" and "stew"
02:11:44 <PatrickRobotham> Let f: 1-> C, g:1->C, h:1->C be such that f != g, f!=h and g != h.
02:12:09 <PatrickRobotham> If z:1 -> C is a morphism then either z = f, z=g or z = h.
02:12:28 <PatrickRobotham> (morphism is another word for arrow)
02:12:39 <PatrickRobotham> 1 is the set {x}
02:12:55 <adnauseam> hmm
02:12:59 <edwardk> cy1: if you want to play with the idea further, including the stuff PatrickRobotham  is talking about now, take a look at lawvere and schanuel's conceptual mathemetics
02:13:20 <ciaranm> or don't!
02:13:24 <edwardk> he spends a lot of time in a world without objects
02:13:37 <ciaranm> "sets for mathematics" might be less annoying, depending upon your background
02:13:40 <PatrickRobotham> An object? That sounds like a fancy name for an identity arrow! :P
02:13:48 <edwardk> PatrickRobotham: =)
02:14:09 <edwardk> ciaranm: i was mostly figuring given the context of the discussion that he could use the drill
02:14:19 <PatrickRobotham> Actually, I'm still trying to learn category theory.
02:14:21 <cy1> yay I got haskore running!
02:14:26 <edwardk> L&S is pretty good at that part at least
02:14:38 <PatrickRobotham> I'm currently trying to get the hang of adjunctions.
02:14:39 <cy1> and... I can generate complex serialized text that represents midi events...
02:14:45 <cy1> but play is not in scope
02:14:50 <cy1> ehehe
02:15:06 <edwardk> ok, going to go beat my head against a wall and figure out the llvm binding issue
02:15:12 <ciaranm> i didn't get adjunctions until i read tom leinster's notes
02:16:05 <adnauseam> looks like i've got my day cut out for me today. i'll take a look into category theory and see what it's about
02:16:52 <PatrickRobotham> ciaranm: Can you link me to to Leinster's notes?
02:17:59 <ciaranm> PatrickRobotham: there's an older version at http://www.maths.gla.ac.uk/~tl/msci/ . you *might* be able to use the guest login on the "Moodle" link on that page to get the newer ones. maybe.
02:18:21 <PatrickRobotham> edwardk: What book would you recommend after Conceptual Mathematics?
02:18:42 <ciaranm> poison
02:19:05 <PatrickRobotham> Who's it by? :P
02:19:07 <ciaranm> (don't mind me, that book just annoyed the crap out of me)
02:19:30 <ciaranm> awodey's pretty good if you've got the background for it
02:21:12 <edwardk> PatrickRobotham: categories for the working mathematician
02:21:33 <edwardk> Conceptual Mathematics is good if you need drill and to get the concepts, and haven't seen categories before
02:21:39 <PatrickRobotham> edwardk: I've heard that book eats men's souls!
02:21:56 <edwardk> CftWM has awesome idea density
02:22:03 <edwardk> other folks swear by awodey
02:22:11 <edwardk> and i don't mind it
02:22:19 <PatrickRobotham> Ok. Well I'll check both of them out. Thank you.
02:22:21 <ciaranm> awodey doesn't have "all of maths" as a prerequisite
02:22:32 <edwardk> but CftWM is awesome because you can always reread it
02:22:43 <edwardk> another good supplement is Serge Lang's Algebra
02:23:26 <edwardk> which is nice if you want to learn more general math anyways. he goes out of his way to introduce categorical tools as he works through it, so you can see them used to tackle problems in algebra.
02:23:52 <ciaranm> there's also aluffi if you want category theory and algebra at the same time
02:24:14 <edwardk> don't think i have that one.
02:24:15 <ciaranm> any book that has "Definition 1.1: a group is a groupoid with a single object" has to be good
02:24:21 <edwardk> heh
02:24:24 <edwardk> bah
02:24:33 <edwardk> it didn't start with a category is a semigroupoid with identity arrows ;)
02:25:26 <PatrickRobotham> And they say math is hard to follow!
02:35:24 <thelastnode> I'm trying to install the portaudio package with cabal, but I'm getting an error saying "Could not find module `Prelude'", any idea what's up?
03:38:43 <_mpu> Hi, how can I lift a function (f :: a -> m b) to (f :: Maybe a -> m (Maybe b)) in the intuitive way?
03:40:40 <_mpu> @pf \x -> x
03:40:40 <lambdabot> Maybe you meant: bf pl
03:40:50 <_mpu> @pl \x -> x
03:40:50 <lambdabot> id
03:40:51 <merijn> "return . \x -> f x"? Might be a nicer way (of course this doesn't really restrict it to "Maybe a -> m (Maybe b)"
03:41:02 <merijn> @pl return . \x -> f x
03:41:02 <lambdabot> return . f
03:41:12 <merijn> oh, wait
03:41:14 <merijn> That's not right
03:41:52 <merijn> :t return . (f . return)
03:41:53 <lambdabot> forall a (m :: * -> *) a1 (m1 :: * -> *). (Monad m, Show (m1 a1), SimpleReflect.FromExpr a, Monad m1) => a1 -> m a
03:42:32 <_mpu> @pl \x -> case x of { Nothing -> return Nothing ; Just x -> f x >>= return.Just }
03:42:32 <lambdabot> (line 1, column 17):
03:42:32 <lambdabot> unexpected "{"
03:42:32 <lambdabot> expecting variable, "(", operator or end of input
03:43:08 <merijn> return . (\x -> x >>= f)
03:43:25 <_mpu> Yes, that's it I think
03:43:27 <merijn> :t return . (\x -> x >>= (:[]))
03:43:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m [a]
03:43:31 <merijn> \o/
03:43:52 <merijn> (Of course this one will work for everything, not just Maybe. Depending on the type of f)
03:44:26 <merijn> @djinn (a -> m b) -> Maybe a -> m (Maybe b)
03:44:26 <lambdabot> -- f cannot be realized.
03:44:47 <merijn> @pl return . (\x -> x >>= f)
03:44:47 <lambdabot> return . (f =<<)
03:45:16 <mun> in logic, what is meant by a 'dependent function'?
03:45:40 <merijn> mun: A function whose result type depends on the input value
03:45:57 <merijn> mun: I think, it depends on the context a bit
03:45:58 <mun> merijn, but are there non-dependent functions?
03:46:14 <_mpu> :t \f ->  return . (\x -> x >>= f)
03:46:15 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a b. (Monad m, Monad m1) => (a -> m1 b) -> m1 a -> m (m1 b)
03:46:25 <merijn> mun: Is this a pure logic context or more of a logic + curry-howard type theory context?
03:46:43 <mun> merijn, um i'd say pure logic
03:46:44 <_mpu> merijn, that was wrong.
03:47:35 <merijn> _mpu: What's wrong about it? Looks like you're original type signature...
03:48:30 <merijn> mun: Then I probably don't know enough to answer I think
03:48:54 <mun> merijn, "A function whose type depends on the input value" so does that mean a dependent function could return values of different types?
03:49:10 <mun> merijn, how about in the type theory context?
03:49:39 <_mpu> merijn, no, watch closer. m1 must be Maybe and m at the same time.
03:49:59 <_mpu> merijn, hoogle told me to look at Data.Traversable.
03:50:11 <_mpu> mapM will do
03:50:27 <merijn> mun: In type theory you have dependent type systems where the return type can depend on the input VALUE. For example: the function foo could have different result types when the input was an empty list vs a non-empty list
03:51:13 <mun> merijn, would foo then have to be polymorphic?
03:51:26 <merijn> No, not necessarily
03:52:11 <_mpu> :t mapM
03:52:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:52:28 <merijn> Or you could have a function that takes an int and some arbitrary value and then returns a tuple with number of elements equal to the int. So that "foo 1 a" returns (a), "foo 2 a" returns "(a, a)", etc.
03:52:38 <mun> merijn, hmm how come? isn't the return type polymorphic?
03:52:56 <_mpu> can I import a function "as" another name?
03:53:12 <merijn> _mpu: Yes, I think the "as" is even the correct syntax
03:53:38 <_mpu> import Foo (bar as x)
03:54:08 <merijn> mun: No, because it always returns the same type for the same function. It is up to the type checker to verify that if you use foo in a context that expects return type (a, a) that foo's input is restricted to values that will produce output type (a,a)
03:55:54 <merijn> mun: The type signature of foo encodes the possible different result types for foo, so you can verify that your program type checks, even if the different return types of foo are not polymorphic
03:57:25 <mun> hmm
03:58:46 <merijn> One of the downsides of this is that type inference is no longer decidable. So you can type-check your code, but you will have to manually specify types in some (or even most) scenarios.
04:01:19 <merijn> mun: It mostly becomes interesting with some sort of constraint typing system. Where you're type checker sees that a list gets compared with the empty list and can then infer that in one branch of if/else the list is guaranteed to be empty and in the other it is guaranteed to be non-empty. It allows you to encode much stronger invariants in your types.
04:03:39 <merijn> If that sorta thing interest you then "Introduction to Generalized Type Systems" by Barendregt is a reasonably good starting paper (if you're already a little familiar with type theory), followed by "An Extended Calculus of Constructions" by Luo (there might be better/easier papers, these are just the ones I started with)
04:07:34 <mun> merijn, hmm i guess i got a bit of reading to do then
04:07:41 <mun> thanks though
04:09:05 <merijn> mun: Conor McBride has some interesting stuff in his PhD thesis (Dependently Typed Functional Programs and their Proofs) about what you could use dependent types for. It's quite interesting, but his papers can be...difficult to get through, to say the least
04:09:34 <merijn> His thesis is pretty readable, provided you first get a basic understanding of type theory/lambda cube/calculus of constructions
04:51:01 <merijn> Hmm, need some data type design help, I have something like "data Location = Location { foo :: Maybe a, sublocs :: [(SubLocation, Maybe a)]}", there is (at most) one 'a' per location (this includes those possibly at a sublocation), is there a nicer way to store this info in an ADT?
04:51:29 <hpc> sublocs :: Map SubLocation a?
04:51:46 <hpc> then come up with a token ordering for it, if you haven't already
04:51:56 <hpc> so you can actually make values of it
04:52:42 <merijn> hpc: And then just suck it up and deal with the extra top level Maybe a?
04:52:51 <mun> does the ML-style polymorphism have type classes?
04:53:46 <hpc> merijn: probably, yeah
04:54:09 <hpc> i bet you could get more sophisticated if you try and refactor SubLocation at the same time
04:54:29 <hpc> but "maybe a thing, and a map of sublocations to things" isn't too bad
04:54:48 <merijn> Actually, maybe I'm thinking about it wrong and I should just have "foo :: Maybe (a, SubLocation)" because I'm more interested in "where is a?" then "is a at x?"
05:07:20 <hpc> preflex: seen BONUS
05:07:20 <preflex>  BONUS was last seen on #haskell 334 days, 16 hours, 39 minutes and 21 seconds ago, saying: yeah i think that's better as well
05:07:45 <hpc> what does he do now that LYAH is done?
05:08:22 <merijn> hpc: Write enterprise Java
05:08:26 <ivanm> he's prepping for LYAH2: the rhinoceros beetle strikes back!
05:08:32 <hpc> lol
05:08:39 <hpc> i can't tell which of you is serious
05:08:51 <ivanm> you thought I was serious? :o
05:08:52 * merijn high-fives ivanm
05:09:27 <hpc> ivanm: there's definitely enough haskell for a second book
05:09:52 <ivanm> the name I gave didn't at all sound ridiculous?
05:09:56 <hpc> it did
05:10:04 <hpc> that's why it was so believable
05:10:09 <ivanm> oh, wait, I forgot: LYAH *is* ridiculous
05:12:01 * hpc would probably have gone with LYAH2: Electric Boogaloo
05:14:35 <mun> is there an easy to read paper on the semantics of simply typed lambda calculus?
05:15:11 <azaq23> you accidentally
05:17:07 <merijn> I have a PDF of course notes which is pretty readable
05:17:26 <merijn> Not just STLC, though. It expands into some other related LCs
05:17:49 <hpc> and all for the low, low price of getting into the uni where merijn teaches!
05:18:04 <hpc> ;)
05:18:06 <merijn> I don't teach (yet!)
05:18:12 <hpc> well hurry up then!
05:18:18 <hpc> he's waiting on those notes
05:18:58 <merijn> mun: http://www.few.vu.nl/~mvn540/Van%20Raamsdonk%20-%20Logical%20Verification%20Course%20Notes.pdf
05:20:05 <merijn> Covers 1st order propositional logic, STLC, inductive types, 1st order predicate logic, dependent LC, 2nd order propositional logic and polymorphic LC
05:20:20 <mun> looks good
05:20:20 <mun> thanks
05:21:14 <mrcarrot> i hope BONUS is working on a good set of exercises rather than a LYAH2
05:21:19 <hpc> those notes are nicely laid out
05:21:40 <merijn> Nothing says "academia" like extremely casual copyright infringement :>
05:21:41 <hpc> the font choice sucks significantly less than other papers using that kind of notation
05:22:21 <hpc> (the top/bottom deduction-whatever thing)
05:22:45 <hpc> er, implication rules
05:22:58 <merijn> @remember anonymous Caveat implementor.
05:22:58 <lambdabot> Done.
05:23:21 <hpc> i can actually tell that the deductions are supposed to be read downard
05:23:27 <hpc> instead of as some kind of wonky division
05:23:51 <merijn> hpc: proof.sty is your friend
05:24:25 <merijn> Although I think she used some other custom scheme for these notes, not sure
05:24:58 <hpc> i need to actually use tex one of these days
05:25:04 <hpc> everything i know i learned from agda-mode
05:25:12 <hpc> and some random phpbb boards
05:25:30 <companion_cube> I used bussproofs.sty
05:25:32 <merijn> hpc: You really mean TeX or just LaTeX + friends in general?
05:25:37 <hpc> in general
05:25:55 <hpc> and by "learn", i mean enough to make a document that looks nice
05:25:56 <merijn> I recommend making sure you get XeTeX
05:26:18 <merijn> unicode + OpenType/TrueType font support for (La)TeX
05:27:17 <hpc> oh, i do have xetex
05:49:42 <Peaker> acid-state is for in-memory structures only, right?
05:50:14 <Entroacceptor> yes
05:51:12 <Entroacceptor> but what other structures do you want to use?
05:52:12 <hiptobecubic> bitonic, sorry to ping you but you are using ghc-mod in vim yes? Do you use it /with/ haskell-mode or what?
05:52:46 * hackagebot tup-functor 0.1 - Homogeneous tuples  http://hackage.haskell.org/package/tup-functor-0.1 (BalazsKomuves)
05:56:20 <Peaker> Entroacceptor: Large on-disk structures, of the kind sql/nosql databases typically store
05:56:39 <osager> Hi all, how can i check a cabal package's dependencies ?
05:56:54 <alpounet> osager, it's via the Cabal library
05:57:04 <Peaker> osager: cabal info ?
05:57:17 <osager> ok
05:57:22 <osager> thanks for cabal info
05:57:38 <alpounet> ohhh, through the command line
05:58:00 <alpounet> was about to give you pointers to a module in the cabal library
06:00:20 <bitonic> hiptobecubic: hell no, I use emacs!
06:01:20 <Entroacceptor> Peaker: the idea is that most sql/nosql setups end up with complex caching solutions and keep their data in RAM anyway
06:02:09 <bitonic> hiptobecubic: but I'm pretty sure ghc-mod works with vim as well
06:02:32 <Peaker> Entroacceptor: Just the indexes, no?
06:02:32 <Entroacceptor> http://acid-state.seize.it/#faq
06:02:50 <Peaker> Entroacceptor: Also, with SSDs, the trade-offs have changed
06:04:33 <Entroacceptor> I don't think they've changed that much
06:04:33 <Peaker> Entroacceptor: Keeping just indexes in RAM should cover latency, and a RAID or SSDs should have no problem with throughput, either
06:04:56 <Peaker> Entroacceptor: latency of random disk I/O is ~10ms, and for SSD that is ~20us
06:04:59 <Entroacceptor> Peaker: but that's the solution the FAQ mentions ;)
06:05:54 <Entroacceptor> but I'm sure Lemih is thankful for code that does right that ;)
06:06:04 <Peaker> "The only reason anyone would choose to use disk over RAM is because it is cheaper." <-- and because it is non-volatile? :P
06:06:07 <Entroacceptor> I'm not really an expert, just lurking in #happs
06:06:43 <Entroacceptor> there are RAM-"harddisks" with batteries =)
06:07:06 <osfameron> non-volatile is relative ;-)
06:07:44 <hiptobecubic> bitonic, :D haha
06:07:53 <hiptobecubic> bitonic, yes it works with vim just fine thank you
06:14:44 <bitonic> hiptobecubic: :)
06:22:50 * hackagebot buildwrapper 0.5.1 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.5.1 (JeanPhilippeMoresmau)
06:27:52 * hackagebot haskell-src-meta 0.5.1.2 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.5.1.2 (BenMillwood)
06:27:54 * hackagebot scion-browser 0.2.8 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.8 (JeanPhilippeMoresmau)
06:38:45 <Entroacceptor> does cabal warn you if you embed GPL code with not compatible licenses?
06:39:07 <dcoutts> Entroacceptor: there's been some discussion about this
06:39:34 <dcoutts> the plan was to report the set of licenses used by the package and it's dependencies transitively
06:39:43 <elliott> I'm turning on ImpredicativeTypes. Wish me luck.
06:40:14 <dcoutts> Entroacceptor: but it'd only tell you it was incompatible if you mixed GPL with AllRightsReserved
06:41:30 <dcoutts> all other combinations are valid, including BSD code depending on GPL code (the result is you must comply with [BSD, GPL]), but we might warn when the set of effective licenses is more than the top level license
06:41:51 <dcoutts> Entroacceptor: or the short answer is "no, not currently"
06:44:29 <Entroacceptor> thanks
07:12:02 <i1126> Hello! What's the proper place to "talk about" issues with cabal-installing xmobar?
07:12:39 <ciaranm> i recommend consulting a trained professional
07:13:13 <bitonic> i1126: this is a good place for cabal issues
07:13:32 <i1126> ciaranm: thanks :P
07:14:00 <i1126> bitonic: Okay, great.. I tried to do the following: "cabal install xmobar --flags="all_extensions" and it failed.
07:14:21 <bitonic> i1126: pasting the error somewhere would be useful :P
07:14:27 <i1126> Actually, it failed two times: one due to with_mpd, the other due to with_inotify.
07:15:13 <i1126> I'
07:15:19 <i1126> I'm working on it..
07:16:27 <MasseR> Hah, I love university <3. Had a random discussion about haskell with a guy sitting next to me
07:16:40 <bitonic> i1126: yeah, we can't really help you without knowing what's wrong :)
07:17:03 <MasseR> He hasn't followed haskell news for many years now (compiling to c was the new thing at the time) and asked me to revise what's happened since :D
07:17:14 <hpaste> 1126 pasted “xmobar with_mpd” at http://hpaste.org/66220
07:17:49 <MasseR> Well, what he said was that the c generator generated 'good readable code', not sure if it's the same as the -fvia-c
07:18:08 <hpaste> 1126 pasted “xmobar with_inotify” at http://hpaste.org/66221
07:18:22 <i1126> bitonic: Okay, here you are.. ;)
07:18:36 <i1126> I had to ssh into my laptop first... sorry for the delay ;)
07:20:16 <bitonic> i1126: ugh, that looks like a problem in the code, or not strict enough dependencies constraints
07:20:25 <bitonic> probably the latter
07:21:52 <bitonic> i1126: for some reason Plugins.Mail is re-defining modifyTVar.
07:22:07 <bitonic> probably because it wasn't there in some previous versions of STM
07:22:22 <solirc> Is it sane to special case mempty when defining a Monoid instance?
07:22:29 <solirc> say: http://hpaste.org/66222
07:22:38 <bitonic> i1126: anyways, the quick solution is to get the source and remove that definition
07:22:54 <i1126> bitonic: okay, and the best solution? ;)=
07:23:01 <bitonic> i1126: file a bug and have it changed
07:23:07 <i1126> That's great :)
07:23:17 <solirc> it holds the monoid laws, but still feels somewhat strange
07:23:24 <i1126> And what do you think of the with_mpd-failure?
07:23:47 <bitonic> i1126: ah. that's because the code is not up to date with the changed in ghc 7.4.
07:23:49 <elliott> solirc: don't the laws hold without that?
07:23:56 <bitonic> i1126: in other words, another bug
07:24:15 <elliott> oh, they don't
07:24:16 <bitonic> i1126: since Num does not imply Show anymore
07:24:16 <solirc> Eliel: don't think so
07:24:28 <elliott> solirc: that last clause makes me worry a bit, I'm not sure this Monoid instance will behave sanely
07:24:37 <solirc> Eliel: sorry did mean elliott
07:24:39 <roconnor> solirc: your code is incoherent IMHO.
07:24:47 <elliott> solirc: does it follow the associativity law, even?
07:24:57 <i1126> Okay, would you mind pasting it? Or should I grab the chance and learn how to do it? ;)
07:24:59 <solirc> I wrot qc properties
07:25:19 <bitonic> i1126: I can even send you a patch if you want... it'll take 2 mins
07:25:58 <bitonic> i1126: but first check if the code in the git repo fixes that
07:25:58 <solirc> roconnor: toList (ListZipper prev next) = reverse prev ++ next
07:26:09 <solirc> roconnor: if you meant that
07:26:12 <roconnor> solirc: elliott makes a good point.  I doubt this is associative.
07:26:37 <solirc> roconnor: can you prove it?
07:27:05 <i1126> Okay, I
07:27:06 <roconnor> solirc: Um, that's your responsibility, not mine.
07:27:12 <i1126> ... hate my keyobard ;
07:27:15 <i1126> I'll try.
07:27:27 <bitonic> i1126: the Show issue is fixed in the git repo. The modifyTVar thing doesn't seem to be
07:27:43 <roconnor> solirc: you said you quickchecked associativity?
07:27:43 <solirc> roconnor: I mean this QC property holds: \x y z -> (x `mappend` y) `mappend` z == x `mappend` (y `mappend` z :: ListZipper Int)
07:28:29 <bitonic> i1126: one thing about haskell, is that it moves fast!
07:28:59 <roconnor> hmm
07:29:21 <solirc> it works, because I look at the mempty values
07:30:13 <i1126> bitonic: good and bad alike, hm? ;)
07:30:40 <i1126> bitonic: do you report the modifyTVar-thing?
07:31:04 <bitonic> i1126: mostly good
07:31:07 <bitonic> mhm?
07:31:34 <bitonic> i1126: what you should try to do is delete modifyTVar here: https://github.com/jaor/xmobar/blob/master/src/Plugins/Mail.hs
07:31:48 <bitonic> actually the nicest thing would be to check against GHC's version
07:31:59 <bitonic> but whatever, don't worry about that
07:34:06 <i1126> Okay, I'll do it.. :) Thanks a lot for your help!
07:34:18 <bitonic> i1126: yw
07:36:13 <elliott> solirc: how long does ith old for? :P
07:36:16 <elliott> *it hold
07:36:34 <solirc> elliott: what do you mean
07:36:47 <solirc> I only tried the with QCs defaults
07:36:54 <solirc> so it is not battle tested
07:38:49 <elliott> solirc: what semantics do you want your monoid to have, exactly?
07:39:15 <solirc> elliott: I'm manly interested in mempty
07:39:35 <solirc> elliott: but of course, I'm not going to add a broken instance for that
07:39:50 <roconnor> solirc: Okay, I believe it is a monoid, a strangely biased monoid, but a monoid.
07:40:07 <solirc> roconnor: strange for sure
07:40:12 <roconnor> solirc: possibly no worse than First
07:40:28 <solirc> roconnor: Fist?
07:40:31 <solirc> ^r
07:40:34 <roconnor> @hoogle First
07:40:34 <lambdabot> Data.Monoid First :: Maybe a -> First a
07:40:35 <lambdabot> Data.Monoid newtype First a
07:40:35 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
07:40:40 <elliott> solirc: well, don't instantiate Monoid just because you want a distinguished value :P
07:41:02 <roconnor> elliott: that is what Default is for :D
07:41:19 <solirc> roconnor: true, but it is an additional dependency
07:41:29 <elliott> roconnor: yes! then you can be _honestly_ meaningless
07:41:40 <elliott> solirc: can't you just call it empty = ZipperList [] []? :p
07:41:43 <roconnor> elliott: I wanted to use Default the other day
07:41:55 <roconnor> elliott: and I ended up using Monoid instead :D
07:42:10 <solirc> elliott: yes
07:42:21 <solirc> elliott: that is what I thought I would have to do
07:42:39 <solirc> but then I realized that it is possible to make it a monoid..
07:43:44 <ClaudiusMaximus> would   mappend _ _ = mempty   make a valid (though rubbish) Monoid?
07:44:14 <elliott> no
07:44:17 <elliott> mappend a mempty = a
07:44:23 <ciaranm> you can make anything a monoid!
07:44:24 <ClaudiusMaximus> ah ok
07:44:35 <danr> ClaudiusMaximus: I guess you need to specify what equality you intend, but there's a trivial monoid with only one element
07:44:47 <elliott> roconnor: did you use mempty, or did you just want to know it was there? :P
07:46:44 <ClaudiusMaximus> danr: i was intending '=' as a definition (like  instance Monoid T where mempty = someT ; mappend _ _ = mempty  ) but as elliott pointed out, mempty is an identity element not a zero element
07:47:22 <ClaudiusMaximus> danr: so it would only be valid for the trivial monoid
07:55:55 <i1126> bitonic: Can confirm that it builds when I remove modifyTVar.
07:56:09 <i1126> Had to add X11-xft to the build-depends in the .cabal though.
07:57:25 <nart> how can i send a connectionless (UDP) packet with 4 OOB header bytes (0xff) and the text string getstatus. ?
07:58:11 <roconnor> elliott: for a partial lens, there is a nice function (Monoid o) => PLens a b -> (b -> o) -> (a -> o)
07:58:20 <roconnor> elliott: however, only mempty is needed for this
07:59:02 <roconnor> elliott: (actually this can be generalized to pointed functors, of which Default d => (Const d) is an instance).
07:59:23 <ClaudiusMaximus> f _ _ _ = mempty ?
07:59:37 * roconnor wants to know the answer for nart's question too
08:00:32 <elliott> roconnor: Default is nicer than Monoid there
08:00:39 <roconnor> yep
08:00:41 <elliott> it's the /default/ for if the lens doesn't give you anything, no?
08:00:47 <hpaste> yasar pasted “untitled” at http://hpaste.org/66223
08:01:06 <roconnor> I used to think Default was a silly class;  I'm not so sure anymore though.
08:01:16 <roconnor> elliott: indeed
08:01:21 <yasar> I am trying to write (#) in terms of (#>) but I am stuck, can anyone give any pointers?
08:01:35 <roconnor> elliott: for mutli-lens, I will make use of the full monoid structure.
08:01:59 <yasar> To be more spesific : "Define the operator # using #>. The solution should not contain Just or Nothing."
08:02:39 <elliott> roconnor: well you're using Default as just a parameter you don't have to write out there really
08:02:44 <roconnor> elliott: so, for example, ListZip [] [] would be nice to use as a default for this partial lens function.
08:03:06 <elliott> turning "PLens a b -> o -> (b -> o) -> (a -> o)" into "(Default o) => PLens a b -> (b -> o) -> (a -> o)" is ok but it's kind of annoying we have to define a typeclass to do that in the first place
08:03:48 <danr> yasar: did you consider something like m #> \m_parsed -> ...
08:04:03 <roconnor> elliott: I'll probably provide both the monoid thing, and the PLens a b -> o -> (b -> o) -> (a -> o) version
08:04:44 <roconnor> elliott: but for pointed-functor, you need rank-2 polymorphism if you want to avoid the type class :/
08:04:53 <yasar> danr: I have considered using lambdas, tried one or two things, but types didn't checked out.
08:05:16 <roconnor> elliott: Functor f => PLens a b -> (forall c. c -> f c) -> (b -> f b) -> (a -> f a)
08:05:23 <roconnor> elliott: not very Haskel 2010
08:05:54 <danr> so if (m :: Parser a), what is the type of m_parsed in m #> \m_parsed -> ...
08:06:28 <yasar> wait a sec :)
08:06:44 <yasar> a -> Parser b ?
08:06:59 <danr> yasar: not quite, that would be the type of the whole expression "\m_parsed -> ..."
08:07:03 <yasar> ohh wait, just a
08:07:08 <danr> exactly
08:07:14 <elliott> roconnor: meh, more like Crapskell 2010
08:07:25 <elliott> they should ban polymorphism from typeclasses for consistency
08:07:25 <roconnor> elliott: okay
08:07:29 <roconnor> elliott: not very Haskel 1.4
08:07:42 <yasar> danr: Ok, I am trying to figure out the rest :)
08:08:13 <danr> yasar: good luck :)
08:08:22 <elliott> roconnor: I hear Haskell's much better than Haskel
08:08:27 <elliott> maybe it has rank-2 polymorphism
08:08:50 <roconnor> opps
08:08:57 <roconnor> the first was a typo
08:09:04 <roconnor> the second was "cut-and-paste"
08:09:05 <danr> yasar: i guess this is homework, but one handy combinator that you might want to make that I am quite sure won't be frowned upon is a function with type "a -> Parser a" (the so-called return in Haskell monad jargon)
08:09:40 <yasar> It is actually parser tutorial with exercises mixed up :)
08:11:22 <danr> yasar: alright :)
08:11:37 <uniquenick> is there a way to map over the fields in records?
08:12:14 <yasar> danr: I am an economics major, they don't teach us this kind of stuff in school :)
08:13:54 <eacameron> what's the difference between regex-pcre and regex-pcre-builtin packages?
08:14:39 <clsmith> hmm. does it make sense to have a strict pure functional language? my intuition says yes
08:15:53 <c_wraith> clsmith: yeah, that makes perfect sense.  What doesn't is non-strict non-pure
08:16:15 <clsmith> ah, true
08:16:38 <eacameron> clsmith: does a pure langauage require defined execution order?
08:16:40 <clsmith> hmm, would that be a lot more efficient? i know haskellers often ! things
08:17:12 <c_wraith> clsmith: see disciple for an example
08:17:14 <clsmith> eacameron: true
08:17:44 <geekosaur> uniquenick, not without generics
08:17:51 <clsmith> c_wraith: hmm, disciple suggests it's impure?
08:17:51 <eacameron> clsmith: how can that be? Haskell is lazy for that reason, isn't it? Haskell doesn't define an execution order, or does it?
08:18:11 <clsmith> eacameron: oh, i thought your question was rhetorical :p the answer is no
08:18:17 <clsmith> although
08:18:23 <clsmith> haskell does define lazy i think
08:18:26 <c_wraith> clsmith: it has typed effects. The type system allows you to prove code is pure
08:18:32 <clsmith> but an arbitrary pure language needn't be lazy
08:18:48 <clsmith> c_wraith: hmm, i see
08:18:55 <eacameron> clsmith: ah...that makes sense
08:18:56 <elliott> clsmith: disciple has effect typing
08:19:12 <elliott> so it's no more impure than Haskell is because of IO, really
08:19:44 <uniquenick> geekosaur: is that one of those {-# crazythinghere #-} features?
08:19:49 <elliott> clsmith: anyway, strictness may be more performant but it limits your abstraction
08:20:07 <elliott> quite severely; see e.g. http://augustss.blogspot.co.uk/2011/05/more-points-for-lazy-evaluation-in.html
08:20:30 <eacameron> Philip Wadler said: "I think it would be better to be eager by default but make it easy to be lazy when you want." (From 7 languages in 7 weeks by Bruce Tate, interview with Wadler)
08:20:31 <elliott> for instance, in a strict language you can't construct an infinite tree of all possible results, and then just walk it to pick out the one you want, you have to intertwine those two algorithms together
08:20:53 <ciaranm> couldn't you just have a Lazy functor?
08:20:59 <Botje> elliott: what about force/delay in scheme?
08:21:03 <geekosaur> uniquenick, and/or one of several crazy libraries.  records in Haskell are not containers and can't be iterated over easily
08:21:35 <elliott> Botje: sure, you can emulate it
08:21:36 <elliott> but it's noisy
08:21:45 <elliott> similarly, like augustss says you can emulate lazy (&&) in a strict language
08:21:50 <elliott> but you have to put the force/delay primitives everywhere
08:22:19 <mm_freak> as far as i've seen disciple is not pure
08:22:35 <mm_freak> it has evaluation effects, which haskell lacks
08:22:52 <uniquenick> is there a more haskelly way to do it, or is generics the right way?  I basically want to do something like a generic toJson function that works on any record
08:23:00 <elliott> mm_freak: but they're typed, are they not?
08:23:05 * hackagebot BiobaseXNA 0.6.2.3 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.6.2.3 (ChristianHoener)
08:23:05 <mm_freak> they are
08:23:14 <mm_freak> but that doesn't make them pure
08:23:25 <mm_freak> haskell has no evaluation effects (disregarding unsafePerformIO)
08:23:26 <nart> type HostAddress = Word32 ... so how exactly should i encode the ip ?
08:23:41 <elliott> mm_freak: well, imagine if we had idiom brackets where the brackets themselves were implicit
08:23:43 <elliott> would haskell be impure?
08:23:50 <elliott> I think "evaluation effect" is a bit ill-defined
08:23:55 <elliott> uniquenick: generics would be the best way to do that (but note that there are libraries that can do that already)
08:24:19 <mm_freak> elliott: no, because you are still just defining actions…  execution is not part of that definition
08:24:39 <uniquenick> "can do that" as in convert records to json?  That's not actually what I want to do, just the best example to describe the kind of thing I am aiming for
08:24:44 <mm_freak> it's not (| x + y |) that could result in 3 this time and 4 the next time
08:24:55 <mm_freak> it's "run (| x + y |)"
08:25:01 <hpaste> yasar annotated “untitled” with “untitled (annotation)” at http://hpaste.org/66223#a66224
08:25:09 <elliott> mm_freak: ok, so we have idiom brackets implicit anywhere
08:25:24 <elliott> so we have applicative-style code that has all sorts of effects going on under the hood
08:25:38 <elliott> so "random + random" _can_ "be 3 this time and 4 the next time"
08:25:42 <mm_freak> what kind of effects?
08:25:51 <elliott> mm_freak: Applicative effects
08:25:53 <elliott> that's what idiom brackets do
08:25:57 <mm_freak> State effects?  IO effects?
08:26:02 <elliott> any applicative
08:26:03 <roconnor> nart: using inet_addr ?
08:26:05 <elliott> with disciple, the equivalent of the applicative functor is just encoded into the effect type
08:26:11 <roconnor> @hoogle inet_addr
08:26:11 <lambdabot> Network.Socket inet_addr :: String -> IO HostAddress
08:26:20 <elliott> I don't see a real difference between these two.
08:26:20 <nart> damn, i missed it
08:26:25 <nart> roconnor: thanks
08:26:28 <roconnor> :)
08:26:30 <mm_freak> elliott: that would only make sense for IO, because otherwise it would be impossible to observe the effects
08:26:49 <mm_freak> elliott: do you see why IO is pure?
08:27:49 <elliott> mm_freak: i don't see how that "only makes sense for IO". and I don't really believe IO is "pure" (don't assume this is out of ignorance; see e.g. http://conal.net/blog/posts/the-c-language-is-purely-functional)
08:28:02 <mm_freak> elliott: "unsafePerformIO (randomIO)" has an evaluation effect…  it causes side effects on evaluation
08:28:30 <mm_freak> let's define "pure" first…  my definition is:  pure = referentially transparent
08:28:36 <mm_freak> are we agreeing on that?
08:30:34 <elliott> mm_freak: Yes.
08:30:48 <nart> how can i cons four 0xFF bytes to a bytestring ?
08:30:48 <elliott> mm_freak: In which case, idiom brackets embed an impure language, because you can say (| randomIO + randomIO |) :: IO Whatever.
08:31:02 <elliott> mm_freak: Yet if that is impure, I do not see how (+) <$> randomIO <*> randomIO is not impure either, it is a very trivial sugar.
08:31:13 <mm_freak> elliott: then haskell is pure and C is not, because you can replace 'putStrLn "blah"' by its result in haskell, but you can't replace 'puts("blah")' by its result in C
08:32:01 <elliott> mm_freak: Really? What is (putStrLn "blah")'s result?
08:32:09 <mm_freak> an action of type IO ()
08:32:23 <ClaudiusMaximus> @hoogle [Word8] -> ByteString
08:32:24 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
08:32:24 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
08:32:24 <lambdabot> Data.ByteString.Lazy repeat :: Word8 -> ByteString
08:32:29 <mm_freak> (| randomIO + randomIO |) is pure
08:32:36 <mm_freak> its result is the same whereever you write it
08:32:37 <ClaudiusMaximus> @hoogle ByteString -> ByteString -> ByteString
08:32:38 <lambdabot> Data.ByteString append :: ByteString -> ByteString -> ByteString
08:32:38 <lambdabot> Data.ByteString.Char8 append :: ByteString -> ByteString -> ByteString
08:32:38 <lambdabot> Data.ByteString.Lazy append :: ByteString -> ByteString -> ByteString
08:32:47 <mm_freak> note:  the result is /not/ of type Whatever
08:32:51 <mm_freak> it's of type IO Whatever
08:33:41 <roconnor> I didn't like conol's article.  Purely function is about the semantics of (->), and he didn't even talk about (->).
08:34:16 <roconnor> To me it doesn't even make sense to talk about whether or not IO is pure, since there is no (->) invovled.
08:34:16 <JamesJRH> Anyone know how to run Happstack alongside Apache?
08:34:50 <roconnor> A function a -> IO b is pure because in Haskell the (->) is pure
08:34:58 <mm_freak> roconnor: referential transparency extends beyond functions:  x = getLine
08:35:06 <mm_freak> you can replace any occurence of getLine by x
08:35:15 <roconnor> A function a `Kleisli IO` b is not pure because the `Kleisli IO` arrow is not pure.
08:35:44 <mm_freak> JamesJRH: i use warp alongside nginx…  just proxy the requests to the haskell application
08:35:54 <ClaudiusMaximus> JamesJRH: i never used happstack, but i'm guessing something like run happstack on a port other than the apache port, and use an apache reverse proxy to happstack
08:36:01 <mm_freak> roconnor: huh?  why wouldn't that be pure?
08:36:26 <mm_freak> roconnor: if a -> IO b is pure, then trivially Kleisli IO is also pure, because it builds on that in pure haskell with no magic involved
08:37:09 <elliott> <mm_freak> an action of type IO ()
08:37:16 <elliott> mm_freak: You think you can replace (putStrLn "blah") with its result?
08:37:21 <elliott> Please tell me what I'd replace it with.
08:37:26 <dolio> IO is an impure language embedded in a pure language.
08:37:38 <elliott> <mm_freak> note:  the result is /not/ of type Whatever
08:37:38 <elliott> <mm_freak> it's of type IO Whatever
08:37:39 <otters> returnIO ()
08:37:41 <elliott> Again, please don't assume I'm ignorant...
08:37:48 <elliott> I'm fully aware of how Haskell's IO model works.
08:37:50 <mm_freak> elliott: doesn't matter whether there is code for it or not…  the construct that is the result is always the same
08:38:00 <elliott> mm_freak: How do you define equality for IO actions?
08:38:00 <JamesJRH> mm_freak, ClaudiusMaximus: Ah, that's what I was looking for, thanks. I'll search for proxying Apache.
08:38:16 <dmwit> Hey, this isn't quite a Haskell question, but rather a math question.
08:38:17 <dolio> If the article is the one I'm thinking of, it tries to claim that that is the same as C being an impure language embedded in the pure CPP language.
08:38:21 <dolio> Which is disingenuous at best.
08:38:23 <mm_freak> elliott: particularly when you see 'putStrLn "blah"' twice in your code, you can define x = putStrLn "blah" and replace each occurence by x
08:38:29 <mm_freak> that's the point of referential transparency
08:38:37 <elliott> dolio: It's obviously not argued sincerely.
08:38:57 <roconnor> mm_freak: lets say that an arrow is pure if (f &&& f) = f . (id &&& id)
08:39:00 <mm_freak> elliott: that's not equality, it's referential transparency…  the notions are related, but not the same
08:39:11 <dmwit> Is there a term for a set with: two commutative monoid structures, together with an operation that translates between them? For example, reals with addition or multiplication, together with the exp/ln operations, or subsets of a universe with union or intersection, together with the universe-complement operation.
08:39:15 <roconnor> mm_freak: (i've made this up on the spot, so it reserve the right to take this back)
08:39:21 <elliott> mm_freak: What is your definition of referential transparency? Mine is "you can replace something with its result and it will be the same". That depends on a notion of "same".
08:39:40 <mm_freak> roconnor: that's a type error
08:40:23 <hpaste> yasar annotated “untitled” with “untitled (annotation) (annotation)” at http://hpaste.org/66223#a66226
08:40:28 <ClaudiusMaximus> dmwit: monoid isomorphism ? http://en.wikipedia.org/wiki/Monoid#Monoid_homomorphisms
08:40:28 <mm_freak> roconnor: it won't change the semantics of the program
08:40:46 <mm_freak> two expressions are referentially transparent, if they have the same semantics
08:40:56 <dmwit> ClaudiusMaximus: Not bad. Maybe "automorphism" is what I'm looking for.
08:41:08 <dmwit> err... no
08:41:10 <dmwit> not automorphism
08:41:29 <dmwit> It's something categorically unsettling: a monoid isomorphism between monoids who happen to be backed by the same set.
08:41:55 <mm_freak> roconnor: in haskell when you write x = y, then x and y have the same semantics
08:41:57 <mm_freak> this is not true for C
08:42:54 <roconnor> @type \f -> (f &&& f)
08:42:55 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
08:42:57 <elliott> in C when you write typeofy x(void) { return y; } then x() and y have the same semantics
08:43:07 * hackagebot BiobaseXNA 0.6.2.4 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.6.2.4 (ChristianHoener)
08:43:09 * hackagebot BiobaseTurner 0.2.2.3 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.2.2.3 (ChristianHoener)
08:43:10 <mm_freak> oh lol
08:43:17 <roconnor> @type \f -> f . (id &&& id)
08:43:18 <lambdabot> forall b b1. ((b1, b1) -> b) -> b1 -> b
08:43:19 <mm_freak> the last was for elliott, not roconnor =)
08:43:32 <sipa> elliott: no, the first one is an rvalue, the latter an lvavlue
08:43:41 <elliott> sipa: y is an expression here
08:43:42 <elliott> not an lvalue
08:43:53 <roconnor> @type \f -> f . (pure id &&& pure id)
08:43:54 <lambdabot> forall b a (a1 :: * -> * -> *) b1 a2. (Applicative (a1 b1), Arrow a1) => ((a -> a, a2 -> a2) -> b) -> a1 b1 b
08:44:02 <ClaudiusMaximus> dmwit: well i think the +exp*log on R is a bit of an odd example for that, because log is only defined on positive reals
08:44:04 <dolio> roconnor: I think you have the f in the wrong spot.
08:44:07 <roconnor> ah
08:44:10 <roconnor> stupid backwards
08:44:13 <dolio> (id &&& id) . f
08:44:14 <mm_freak> elliott: in short, referential transparency has to do with equal semantics, not with equal representation
08:44:16 <roconnor> @type \f -> (id &&& id) . f
08:44:16 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
08:44:23 <elliott> mm_freak: i do not believe IO has any known semantics
08:44:26 <elliott> let me clarify my position
08:44:30 <roconnor> @type \f -> (id &&& id) (Contorl.Category..) f
08:44:30 <lambdabot> Couldn't find qualified module.
08:44:31 <dmwit> ClaudiusMaximus: Yeah. I guess it turns out I don't really care that it happens to be backed by the same set.
08:44:32 <mm_freak> you don't need a concrete represention of either x or y to say that x and y have the same semantics
08:44:34 <roconnor> @type \f -> (id &&& id) `Contorl.Category..` f
08:44:34 <elliott> I do not believe C is pure. I believe Haskell is pure (even with IO).
08:44:35 <lambdabot> parse error on input `Contorl.Category..'
08:44:38 <dmwit> ClaudiusMaximus: Isomorphism it is, then, thanks!
08:44:38 <roconnor> @type \f -> (id &&& id) `Control.Category..` f
08:44:39 <lambdabot> parse error on input `Control.Category..'
08:44:39 <elliott> I do not believe that IO, an embedded language, is pure.
08:44:58 <roconnor> @type \f -> (id &&& id) Control.Category.. f
08:44:59 <lambdabot> forall b a. (a -> b) -> a -> (b, b)
08:45:06 <elliott> People who say "IO is pure" tend to defend it by proving that Haskell is pure. I think that's rather silly.
08:45:38 <roconnor> okay screw this
08:45:47 <roconnor> @type \f -> f >>> (id &&& id)
08:45:48 <lambdabot> forall a b. (a -> b) -> a -> (b, b)
08:45:53 <roconnor> oh right
08:46:01 <roconnor> @type \f -> (pure id &&& pure id) . f
08:46:02 <lambdabot> forall a a1 a2 (f :: * -> *). (Functor f) => f a1 -> f (a -> a, a2 -> a2)
08:46:07 <roconnor> arg
08:46:11 <roconnor> @type \f -> (pure id &&& pure id) Control.Category.. f
08:46:12 <lambdabot> forall a (cat :: * -> * -> *) b a1 a2. (Applicative (cat b), Arrow cat) => cat a2 b -> cat a2 (a -> a, a1 -> a1)
08:46:15 <dolio> elliott: By the way, I think when defining referential transparency, it's better to talk about replacing references with expressions and vice versa. Ala 'f e e vs. let x = e in f x x'.
08:46:18 <mm_freak> elliott: why is that silly?  i'm saying IO is pure
08:46:26 <ssbr_> Can one not define datatypes in ghci ?
08:46:41 <dolio> Rather than 'values' or 'results'. Unless that's what you mean by 'result.'
08:46:57 <mm_freak> roconnor: you can't say that a -> IO b is pure while saying that Kleisli IO is impure at the same time
08:47:19 <roconnor> mm_freak: yes I can, because purity is a quaifier for arrow
08:47:28 <mm_freak> roconnor: note that no magic is involved in defining Kleisli
08:47:39 <mm_freak> Kleisli is just as referentially transparent as a -> IO b
08:47:40 <fryguybob> ssbr_: It was recently added.
08:47:45 <mm_freak> or a -> m b
08:47:48 <roconnor> @type \f -> f >>> (pure id &&& pure id)
08:47:49 <lambdabot> forall (cat :: * -> * -> *) a b a1 a2. (Applicative (cat b), Arrow cat) => cat a b -> cat a (a1 -> a1, a2 -> a2)
08:47:51 <ssbr_> fryguybob: Heh. Alright, thank you.
08:47:51 <elliott> dolio: Yes, that's reasonable.
08:47:54 <sipa> elliott: assuming y is no rvalue, and not an array, i suppose it's correct
08:47:54 <roconnor> @type \f -> f <<< (pure id &&& pure id)
08:47:55 <lambdabot> forall (cat :: * -> * -> *) c a a1 a2. (Applicative (cat a1), Arrow cat) => cat (a -> a, a2 -> a2) c -> cat a1 c
08:48:06 <roconnor> dolio: why can't I type this?
08:48:11 <elliott> dolio: But then I can just make an impure language where "let x = ..." doesn't do that.
08:48:11 * hackagebot BiobaseVienna 0.2.2.4 - Import Vienna energy parameters  http://hackage.haskell.org/package/BiobaseVienna-0.2.2.4 (ChristianHoener)
08:48:13 * hackagebot RNAFold 1.99.1.1 - RNA secondary structure prediction  http://hackage.haskell.org/package/RNAFold-1.99.1.1 (ChristianHoener)
08:48:14 <roconnor> oh it isn't pure it is arr
08:48:15 * hackagebot Nussinov78 0.0.1.1 - Nussinov78 using the ADPfusion library.  http://hackage.haskell.org/package/Nussinov78-0.0.1.1 (ChristianHoener)
08:48:15 <c_wraith> ssbr_: you can with ghc 7.4.  not with any earlier version
08:48:19 <elliott> dolio: e.g., that turns x into a "macro".
08:48:21 <roconnor> stupid name changes
08:48:34 <elliott> roconnor: Was it ever pure?
08:48:40 <roconnor> @type \f -> f >>> (arr id &&& arr id)
08:48:41 <lambdabot> forall (cat :: * -> * -> *) a b. (Arrow cat) => cat a b -> cat a (b, b)
08:48:44 <roconnor> elliott: I'm pretty sure it was
08:49:13 <elliott> I think roconnor's view of purity as a property of arrows is reasonable.
08:49:37 <dolio> elliott: Doesn't do what?
08:50:08 <roconnor> @type \f -> f >>> (Control.Category.id &&& Control.Category.id)
08:50:08 <lambdabot> forall (cat :: * -> * -> *) a b. (Arrow cat) => cat a b -> cat a (b, b)
08:50:12 <elliott> dolio: Okay, let me rephrase.
08:50:40 <roconnor> I'd define an arrow (category) is pure if (f &&& f) = f >>> (Control.Category.id &&& Control.Category.id)
08:50:45 <fryguybob> ssbr_: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/interactive-evaluation.html#ghci-decls
08:50:47 <elliott> dolio: I take standard, strict, impure ML. I redefine "let x = y in z" to mean "let q () = y in z[x -> q ()]".
08:50:50 <roconnor> when people say Haskell is pure they mean that (->) is pure
08:51:02 <roconnor> when people say IO isn't pure they mean that (Kleisli IO) isn't pure
08:51:02 <elliott> dolio: (Okay, you can subvert that by passing x to a function.)
08:51:20 <elliott> (But my point is that depending on a feature of the language you're analysing to define a property about it is a bit vague for my tastes.)
08:51:23 <dmwit> roconnor: That is beautiful.
08:51:25 <roconnor> according to my particular definition of pure (for an arrow (category))
08:51:29 <ssbr_> fryguybob: no, it's fine, I don't have a recent ghci
08:51:36 <ssbr_> (because Fedora.)
08:51:48 <roconnor> dmwit: maybe I should make it a blog post
08:51:58 <dolio> elliott: If that's the only sort of reference you have in the language, then you have referential transparency.
08:52:02 <elliott> roconnor: That reads better with dup :: a x (x,x) I think.
08:52:11 <roconnor> elliott: diag?
08:52:32 <elliott> roconnor: Purity: forall f, dup >>> first f >>> second f === f >>> dup
08:52:35 <elliott> Or such.
08:52:46 <elliott> I dunno, id &&& id is just ugly.
08:52:49 <dmwit> ?remember roconnor An arrow (category) is pure if (f &&& f) = f >>> (id &&& id). When people say Haskell is pure they mean that (->) is pure. When people say IO isn't pure they mean that (Kleisli IO) isn't pure.
08:52:49 <lambdabot> Good to know.
08:52:58 <roconnor> elliott: sounds resonable.
08:53:01 <elliott> dolio: Well, not quite, because, like I said, if you pass "x" to a function in "z", it'll execute once.
08:53:03 <dmwit> I hope you don't mind the mild misquoting.
08:53:16 <mm_freak> roconnor: f &&& f and f >>> (id &&& id) are not the same computation
08:53:24 <elliott> dolio: You're still missing all the reasoning properties of purity -- but your proposed property holds.
08:53:30 <dolio> That's because function abstraction is using a different kind of reference.
08:53:37 <roconnor> mm_freak: they are equivalent when the arrow is (->)
08:53:39 <elliott> dolio: Well, okay.
08:53:49 <mm_freak> roconnor: that's a null statement
08:53:52 <elliott> dolio: I think your definition makes an impure, call-by-name language pure.
08:53:53 <ssbr_> Ugh, mind if I check a stupid question? When defining a datatype, something like data Foo a b = Bar a | Baz b | Quux (Foo a b) --- the "data Foo a b" says that we're defining the type Foo in terms of the types a and b? And then the RHS, we can have value constructors in terms of types?
08:54:02 <dolio> (\x -> e) e' = e[x := e'] is another thing that must hold for referential transparency to work.
08:54:05 <mm_freak> roconnor: obviously some arrows are going to have that property, but only very few
08:54:10 <elliott> mm_freak: So you can say whether the semantics of two IO computations are the same, but not whether two arrow computations are the same?
08:54:14 <mm_freak> and they don't have to be kleisli arrows for that
08:54:15 <nart> roconnor: regarding my question before, if you want to "append byte" just use the numeric value of the byte and add \ before it,,,  "\255\255\255\255 getstatus"
08:54:19 <dmwit> mm_freak: Yes, and those ones that have it are pure.
08:54:25 <dolio> elliott: I'm talking about referential transparency. Purity is not the same thing.
08:54:30 <ssbr_> (i.e., Bar takes one value of type a. Or if it was Bar [a], one value of lists of a)
08:54:36 <mm_freak> all arrows are pure
08:54:38 <elliott> dolio: Is there a non-subjective definition of purity other than RT?
08:54:43 <dolio> Yes.
08:54:46 <roconnor> mm_freak: we are using different definitions of pure
08:54:48 <elliott> dolio: What is it?
08:54:52 <dmwit> mm_freak: Not if you define "pure" to mean "those arrows that have that property". ;-)
08:54:57 <roconnor> mm_freak: feel free to call my definition quux
08:55:05 <mm_freak> roconnor: i'm not seeing the usefulness of your definition
08:55:08 <elliott> mm_freak: i contend that your definition of pure is useless, because it does not let you distinguish where you can apply the nice reasoning properties we like about purity
08:55:17 <elliott> roconnor's does: it tells us when we can do that transformation
08:55:20 <dolio> It means that all evaluation strategies of expressions produce the same thing up to bottoms.
08:55:38 <elliott> dolio: Fair enough. (Now I want to sneak the side-effects into the bottoms.)
08:55:45 <ssbr_> dolio: "assuming they all halt"
08:55:49 <mm_freak> elliott: the whole haskell language is built on that definition's usefulness…  so you question haskell as a language that you can reason about?
08:55:51 <dmwit> Is there a canonical package that defines the "Iso" type once and for all?
08:55:53 <elliott> ssbr_: "up to bottoms"
08:55:54 <ssbr_> oh right, bottoms
08:55:55 <ssbr_> I can't read
08:55:58 <elliott> mm_freak: No.
08:56:10 <elliott> mm_freak: I can reason about Haskell code like it's pure. I can't reason about code inside the Kleisli IO arrow like it's pure.
08:56:20 <mm_freak> why not?
08:56:20 <ssbr_> so what if side effects are defined to be bottom in e.g. lazy evaluation?
08:56:23 <mm_freak> i can
08:56:26 <elliott> mm_freak: Because that will result in all my IO being duplicated.
08:56:37 <elliott> Anyway, I don't think I will be able to dissuade you of your preconceptions.
08:56:43 <ssbr_> (I was reading the Disciple thesis the other day, I'm not sure if its conclusions are mainstream in the haskell community)
08:56:44 <mm_freak> if you duplicate the action, yes, your actions will be duplicated
08:57:15 <elliott> I'll defer to roconnor, he is much better at arguing this than me.
08:57:31 <mm_freak> that's the same as trying to say:  a monad is pure, if "fmap (\x -> (x, x)) c = liftM2 (,) c c"
08:57:35 <mm_freak> that's obviously bullshit
08:57:41 <dolio> elliott: There's a paper on this. It's rather more rigorous than the definition I just gave, but that's the gist.
08:57:57 <roconnor> elliott: I don't know what else to say to mm_freak.  I do understand what he is saying, but I don't know to get him to see my point.
08:58:15 <dolio> A language is pure if all evaluation strategies produce weakly equivalent results.
08:58:30 <mm_freak> roconnor: i see your point, but i wonder if you see the point in arrows
08:58:54 <elliott> roconnor: I agree.
08:59:06 <elliott> roconnor: That's why I delegated to you, so you'd have that problem and not me :)
08:59:40 <elliott> mm_freak: Arrows model types of computation. roconnor is giving a definition of purity for those types of computation, by using the model.
08:59:54 <elliott> Kleisli IO is not pure. That does not mean that Haskell is impure because it has Kleisli IO.
08:59:56 <roconnor> mm_freak: I'd be inclined to define a pure monad that way.
09:00:04 <elliott> It means that Haskell models the impure type of computation known as Kleisli IO.
09:00:05 <glguy> Without going back through all the arguments, could someone tell me what you 4 are discussing?
09:00:19 <dmwit> glguy: "Define pure."
09:00:20 <elliott> <mm_freak> that's the same as trying to say:  a monad is pure, if "fmap (\x -> (x, x)) c = liftM2 (,) c c"
09:00:21 <elliott> yep, reasonable
09:00:25 <dmwit> glguy: and this one:
09:00:26 <elliott> in fact, isn't that the definition of commutative monad?
09:00:28 <dmwit> ?quote roconnor pure
09:00:28 <lambdabot> roconnor says: If one wants to go swimming with sharks, or program in a non-pure language, I suppose that is one's choice
09:00:29 <mm_freak> glguy: this is yet another discussion on the definition of purity
09:00:30 <elliott> I think it is
09:00:30 <roconnor> glguy: whether IO in haskell is pure or not, and what does that question even mean.
09:00:34 <dmwit> ?quote roconnor pure
09:00:34 <lambdabot> roconnor says: If one wants to go swimming with sharks, or program in a non-pure language, I suppose that is one's choice
09:00:37 <dmwit> bleh
09:00:41 <elliott> ?quote roconnor arrow
09:00:42 <lambdabot> roconnor says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
09:00:44 <elliott> ?quote roconnor arrow pure
09:00:44 <lambdabot> No quotes match.
09:00:49 <elliott> ?quote roconnor &&&
09:00:49 <lambdabot> roconnor says: An arrow (category) is pure if (f &&& f) = f >>> (id &&& id). When people say Haskell is pure they mean that (->) is pure. When people say IO isn't pure they mean that (Kleisli IO)
09:00:49 <lambdabot> isn't pure.
09:01:08 <mm_freak> roconnor: i'm not entirely sure, but i'd say your definition is related to commutativity, not purity
09:01:17 <aristid> roconnor: so i have to either swim with sharks or program in a non-pure language? :/
09:01:18 <mm_freak> i don't see why you would need a second definition of purity
09:01:19 <glguy> OK, thanks.
09:01:38 <roconnor> mm_freak: more like idemponency than commutativity.
09:02:10 <roconnor> mm_freak: might be equivalent to an idempontent monad.
09:03:24 <JoeyA> The web-encodings package is marked obsolete.  What package(s) replace it?  (In particular, I'm interested in decoding HTML entities)
09:03:31 <roconnor> aristid: swimming with sharks is safer ... fewer segfaults.
09:03:49 <mm_freak> well, i think that liftM2 (,) c c = fmap (\x -> (x,x)) c is a property that lets us reason about the effects, but it doesn't even require absence of effects
09:03:52 <mm_freak> Maybe has effects, too
09:03:58 <mm_freak> and that property is true for Maybe
09:04:44 <aristid> roconnor: ok
09:05:03 <aristid> roconnor: i hear sharks are not as dangerous as commonly believed, too
09:05:06 <elliott> mm_freak: Kleisli Maybe's effect is the same as (->)'s effect in a way
09:05:11 <elliott> mm_freak: _|_
09:05:27 <elliott> Maybe models partiality, Haskell just happens to have it built-in too
09:05:33 <elliott> I would call Maybe pure.
09:05:46 <mm_freak> elliott: no, it's not the same
09:05:51 <mm_freak> note <|>
09:06:04 <mm_freak> you can observe Nothing, but you can't observer ⊥
09:06:10 <elliott> you can't observe Nothing from inside Maybe
09:06:12 <elliott> only from outside
09:06:19 <elliott> similarly you can observe some _|_s from outside Haskell
09:06:24 <elliott> just not inside (ignoring exception handling)
09:06:41 <elliott> as a citizen in the monad of Maybe, you will never encounter a Nothing
09:07:23 <mm_freak> as a citizen in the monad of State s you will never encounter a state change, what's your point?
09:09:30 <ClaudiusMaximus> JoeyA: that's non-trivial, as you can define your own entities in your html page
09:09:31 <Botje> so you're saying monads are like soviet russia?
09:09:44 <roconnor> mm_freak: you are right, my definition of pure is was too weak.  I need to add something like const <$> x <*> y = x, except expressed in arrow langauge.
09:10:13 <ClaudiusMaximus> JoeyA: i don't know the answer though
09:10:24 <JoeyA> ClaudiusMaximus: Thanks, didn't know that.
09:10:32 <mm_freak> roconnor: again i'm not sure, but i think only (->) has that property
09:10:43 <mm_freak> because it effectively requires that the arrow has no effects at all
09:11:00 <JoeyA> It doesn't need to be perfect.  I'm about to just write the equivalent of s/&nbsp;/ /g and be done with it.
09:11:27 <dmwit> roconnor: (f &&& g) >>> first = f, perhaps?
09:11:35 <roconnor> mm_freak: I think Kleisli Set would have this property if we had an unordered set monad in Haskell.
09:11:46 <roconnor> dmwit: that sounds reasonable.
09:12:29 <elliott> roconnor: you can make a Set monad, btw
09:12:33 <elliott> with that Codensity trick
09:12:37 <elliott> it's just really, really inefficient
09:12:54 <roconnor> elliott: does it have these two properties?
09:12:55 * dmwit just typed "cabal update &&& cabal install foo" by accident
09:13:13 <elliott> roconnor: dunno.
09:13:14 * hackagebot applicative-quoters 0.1.0.4 - Quasiquoters for idiom brackets and an applicative do-notation  http://hackage.haskell.org/package/applicative-quoters-0.1.0.4 (BenMillwood)
09:13:22 <ClaudiusMaximus> JoeyA: perhaps http://hackage.haskell.org/packages/archive/tagsoup/latest/doc/html/Text-HTML-TagSoup-Entity.html
09:13:28 <elliott> roconnor: i can find the definition if you want to play with it
09:13:48 <roconnor> elliott: don't bother :)
09:14:02 <eacameron> I'm new to ByteStrings: All the functions for ByteStrings operate on [Word8]s, but I have [Char]s. How can I convert [Char]s to [Word8]s?
09:14:06 <elliott> roconnor: too late http://www.haskell.org/pipermail/haskell-cafe/2010-June/079488.html
09:14:15 <dmwit> eacameron: Use the "encoding" package, or similar.
09:14:18 <dmwit> ?hackage encoding
09:14:18 <lambdabot> http://hackage.haskell.org/package/encoding
09:14:21 <elliott> further http://www.haskell.org/pipermail/haskell-cafe/2010-June/079498.html http://www.haskell.org/pipermail/haskell-cafe/2010-June/079504.html
09:16:59 <eacameron> the example in the encoding package does this: main = do { let ?enc = UTF8 ... } what does "?enc" mean? I've never seen a ? before a identifier before
09:17:14 <sipa> i believe it's an implicit parameter
09:17:21 <elliott> encoding uses implicit parameters?
09:17:21 <elliott> wtf
09:17:44 <elliott> so it does
09:17:47 <elliott> gross
09:17:58 <dmwit> Where?
09:18:07 <dmwit> I've used encoding successfully before without implicit parameters.
09:18:10 <JoeyA> ClaudiusMaximus: Thanks.  I probably won't use that verbatim, but at least I can use it for reference.  Also, I like the * shadowing trick used for listing the tables.
09:18:15 <dmwit> Oh, in the IO stuff.
09:18:19 <dmwit> huh
09:18:40 <dmwit> None of the pure functions use implicit parameters.
09:18:46 <JoeyA> eacameron: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
09:19:04 <roconnor> eacameron: implicit parameters are very rarely used
09:19:08 <ClaudiusMaximus> JoeyA: me too! i'll use it next time i need a big literal [(a,b)]
09:19:09 <eacameron> JoeyA: ahh ok
09:26:21 <ski> elliott : you can't observe `_|_', you can just observe that, as far as you know so far, the computation is `_|_'
09:26:42 <ski> in case noone has mentioned it yet, see
09:26:43 <ski> @where purely-functional
09:26:43 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
09:26:49 <glguy> eacameron: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/other-type-extensions.html#implicit-parameters
09:27:05 <elliott> ski: nope
09:27:11 <elliott> ski: (error "foo") :p
09:27:22 <eacameron> glguy: roconnor: I
09:27:46 <bitonic> > unamb undefined 1
09:27:47 <lambdabot>   Not in scope: `unamb'
09:27:50 <eacameron> glguy: roconnor: I've been reading that link and I dont think I understand
09:27:50 <bitonic> tsk
09:28:47 <glguy> eacameron: Do you know what the Reader monad is?
09:29:29 <eacameron> glguy: I have a foggy notion...the "I" part of the IO monad, no? A monad only allowing reads?
09:29:33 <dmwit> eacameron: What's the first part of the link you don't understand?
09:30:05 <eacameron> dmwit: haha the link itself or the page that the link goes to?
09:30:16 <eacameron> dmwit: ;(
09:30:23 <JoeyA> ImplicitParams is a language extension that provides dynamic scope, which can be used to avoid having to manually marshal context down to functions that need them.  However, it's not very useful, since you still have to write long type signatures (and sometimes, you even have to use higher-rank types).  ReaderT achieves the same effect; it just does it better.
09:30:26 <glguy> Be more specific about what you don't understand so we can be more specific in our response
09:30:39 <eacameron> dmwit: I'm not sure how the sortBy vs. sort is working
09:30:49 <ski> elliott : it was a general statement, including all kinds of non-terminations in `_|_'
09:30:52 <glguy> JoeyA: just odn't write as many type signatures :)
09:31:12 <JoeyA> glguy: They aren't optional when you want to use dynamically scoped variables.
09:31:17 <JoeyA> (as far as I know)
09:31:31 <elliott> adding a type signature can change the value of implicit params code
09:31:33 <glguy> JoeyA: that doesn't sound right. Can you give an example?
09:31:34 <elliott> it's perverse
09:32:27 <JoeyA> Well, let's simplify.  Suppose you have an Encoding value you need to share down (the Encoding package uses a type class, rather than a concrete Encoding type).
09:32:41 <JoeyA> Now consider a "with" function that calls a callback.
09:32:42 <ski> elliott : the fact that you can observe some `_|_'s doesn't detract that you can't do it in general
09:32:48 <eacameron> elliott: that's what it looks like. the implicit param is in the type signature, which means if you provide your own type sig you change the functions type???
09:32:57 <tazjin> Is anyone actively working on Haskell <-> Cocoa bindings? I know that hoc was around a while ago but it seems to be dead
09:33:04 <elliott> eacameron: "change the function's type"? well you can do that just by supplying a more specific type signature in any case
09:33:07 <dmwit> eacameron: No, the type signature is written there as documentation.
09:33:09 <elliott> changing the semantic meaning is something else entirely
09:33:12 <elliott> ski: that's true, of course
09:33:12 <JoeyA> With ReaderT, you'd say: withFoo :: Foo -> ReaderT Encoding IO a -> ReaderT Encoding IO a
09:33:18 <ski> (i'm sorry if my original statement was unclear)
09:33:30 <dmwit> eacameron: Writing "sortBy ?cmp" would infer that type, given that "sortBy" had the type given.
09:33:48 <hpc> :t sortBy ?cmp
09:33:50 <lambdabot> forall a. (?cmp::a -> a -> Ordering) => [a] -> [a]
09:33:55 <JoeyA> Using ImplicitParams instead of ReaderT, you'd say: withFoo :: Foo -> ((?enc :: Encoding) => IO a) -> IO a
09:34:00 <JoeyA> This withFoo is a rank-2 type...
09:34:55 <hpc> implicit params are dark magic from an ancient time of lisp machines and symbol lists
09:35:09 <hpc> (ie, dynamic scope)
09:35:52 <JoeyA> Naw, dynamic variables are just not very useful when you have to give explicit type signatures to use them, and don't have type aliases or monadic binding to do most of the legwork for you.
09:36:15 <hpc> heh
09:36:32 <hpc> implicit params in agda however...
09:36:33 <eacameron> dmwit: ...processing in my brain... i think i'm catching on
09:36:37 <hpc> those are the stuff
09:37:13 <ski> JoeyA : not `withFoo :: (?enc :: Encoding) => Foo -> ((?enc :: Encoding) => IO a) -> IO a', then ?
09:37:18 <eacameron> JoeyA: Yeah...ReaderT seems like a way nicer way of doing it than implicit params
09:37:31 <JoeyA> ski: Yeah, that's what I meant.
09:37:39 <JoeyA> (forgot the context for withFoo itself)
09:38:28 <dmwit> These types aren't even well-formed, as far as I can tell.
09:38:50 <dmwit> Did you not mean something like
09:39:11 <dmwit> withFoo :: (?enc :: Encoding) => someTypeSayingHowToGetAFoo -> (Foo -> IO a) -> IO a
09:39:16 <dmwit> ?
09:39:36 <ski> ?
09:39:57 <JoeyA> Foo ~ someTypeSayingHowToGetAFoo
09:40:17 <dmwit> JoeyA: Not necessarily.
09:40:18 <JoeyA> Or perhaps MVar Foo would be a better example.
09:40:19 <dmwit> :t withFile
09:40:20 <lambdabot> Not in scope: `withFile'
09:40:34 <dmwit> ?hoogle withFile
09:40:34 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
09:41:01 <dmwit> FilePath /~ Handle
09:41:33 <mm_freak> in many cases even explicit passing is better than ReaderT
09:41:50 <ski> i think JoeyA wanted an example where the operation changed the dynamic context of the callback action
09:42:05 <mm_freak> note how /using/ explicit arguments is much easier than using the implicit ReaderT argument
09:46:28 <JoeyA> mm_freak: You mean rather than ImplicitParams?
09:46:42 <mm_freak> rather than ReaderT
09:46:56 <mm_freak> using implicit parameters is easier than using the ReaderT environment
09:48:31 <JoeyA> Note that the signature is:  withFoo :: (?enc :: Encoding) => MVar Foo -> ((?enc :: Encoding) => Foo -> IO a) -> IO a
09:48:33 <roconnor> mm_freak: ah yes, Reader r is another "pure" monad.
09:48:47 <roconnor> how could I forget about the nices monad ever
09:48:52 <roconnor> *nicest
09:49:06 <JoeyA> It is easy to *use* this withFoo, but when you have to define similar functions in your own project, it gets ugly fast.
09:49:35 <mm_freak> roconnor: true…  Reader shares many properties with the identity monad
09:51:51 <elliott> roconnor: are you sure your definition of pure differs from commutative monad?
09:51:59 <elliott> Reader is commutative :P
09:52:25 <elliott> oh, hmm, not quite
09:52:30 <elliott> since Rand is commutative, but doesn't obey your property
09:54:01 <roconnor> reader is commutative
09:54:17 <elliott> yeah
09:54:24 <elliott> roconnor-purity seems stronger than commutativity
09:54:41 <ski> JoeyA : how would the encoding be changed by `withFoo' ?
09:54:42 <elliott> commutativity lets you reorder, roconnor-purity lets you CSE
09:55:11 <ski> s/roconnor-purity/idempotence/ ?
09:55:49 <roconnor> ski: I haven't yet checked that my definition is equavlent to idempotence, but since we added (f &&& g) . first = f, it seems stronger than idempotency now.
09:56:05 <elliott> well i was talking about roconnor's monad definition
09:56:10 <JoeyA> ski: It wouldn't, but if you wanted to define the callback separately, it would have to have (?enc :: Encoding) in its context.
09:56:15 <elliott> which was just liftM2 (,) m m = fmap (join (,)) m afaik
09:56:26 <elliott> join (liftM2 (,)) = fmap (join (,))  -- nicer
09:56:32 <kallisti> is it possible that lazy StateT is causing my lift-base catch handlers to behave non-deterministically?
09:56:33 <roconnor> I suspect roconnor-purity implies commutativity
09:56:39 <kallisti> *lifted-base
09:56:42 <JoeyA> Hmm, I wonder if the caller of withFoo can parameterize it.
09:56:56 <ski> JoeyA : yes, but i think `withFoo :: (?enc :: Encoding) => MVar Foo -> (Foo -> IO a) -> IO a' would suffice in such cases
09:57:14 <JoeyA> Yeah, that's what I'm seeing now.
09:57:18 <roconnor> elliott: yep, I like thinking in terms of B C K W -calculus
09:57:21 <ski> roconnor : itym s/./>>>/
09:57:40 <roconnor> elliott: roconnor purity imples the monad "perserves" K & W
09:57:42 <JoeyA> I still have some ground left: a "run" function will need to be rank-2.
09:57:50 <ski> .. and s/first/arr fst/
09:57:55 <roconnor> elliott: commutativity imples that the monad "preserves" C
09:58:04 <JoeyA> withEncoding :: Encoding -> ((?enc :: Encoding) => IO a) -> IO a
09:58:21 <JoeyA> err, "with"
09:58:32 <roconnor> elliott: and maybe every monad preserveres B ?
09:58:35 <JoeyA> err, a function that provides context to a callback.
09:58:43 <ski> JoeyA : yes .. at least assuming you don't have a global binding for `?enc'
09:59:08 * ski doesn't recall whether it's possible to day `?enc = ...' at module toplevel
10:00:38 <kallisti> is there any reason to prefer strict StateT IO over lazy StateT IO  ??
10:00:41 <kallisti> this bug is puzzling.
10:01:03 <ski> JoeyA : hm, for `withEncoding e ma', one'd probably write `let ?enc = e in ma' instead
10:01:42 * ski would think it depends on what the state is
10:02:07 <kallisti> the state is a record type containing a host, port, and session ID
10:02:14 <kallisti> which is used when communicating over HTTP
10:02:31 <ski> then i think strict state isn't much use
10:02:43 <ski> (maybe if your fields are strict)
10:03:12 <kallisti> perhaps it's a less innocuous bug that I haven't noticed, but it seems as though my exception handlers are being evaluated out of the order I would expect them to.
10:04:23 <killy9999> http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html
10:04:34 <killy9999> can someone tell me how to create an instance of UTCTime?
10:04:43 <roconnor> killy9999: what do you have
10:04:44 <kallisti> how do you want to make one?
10:04:48 <elliott> <kallisti> is there any reason to prefer strict StateT IO over lazy StateT IO  ??
10:04:50 <elliott> don't use lazy State
10:04:51 <kallisti> do you want to convert something else into it, do you want to get the current time, etc.
10:04:55 <hpc> @hoogle utctime
10:04:55 <lambdabot> Data.Time.Clock UTCTime :: Day -> DiffTime -> UTCTime
10:04:55 <lambdabot> Data.Time.Clock data UTCTime
10:04:55 <lambdabot> Data.Time.Clock.POSIX utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
10:04:59 <elliott> it's almost always way too lazy
10:05:13 <killy9999> how do I pass params to the constructor?
10:05:19 <kallisti> elliott: could it possibly be causing exception handlers to evaluate "out of order" ??
10:05:24 <elliott> killy9999: same way you pass paramd to a function (it is a function)
10:05:27 <elliott> kallisti: uh, probably not.
10:05:28 <killy9999> I can't figire it out
10:05:33 <roconnor> kallisti: UTCTime is rarely created using the constructor
10:05:35 <roconnor> oops
10:05:39 <roconnor> killy9999: UTCTime is rarely created using the constructor
10:05:41 <mm_freak> elliott: i use lazy StateT all the time…  it's usually faster than the strict version
10:05:53 <killy9999> yes, but I'm having problems understanding the parameters
10:06:12 <killy9999> hmmm... in my program I'll be creating it from parsing a String
10:06:14 <kallisti> killy9999: what do you have that you want to turn into a UTCTime
10:06:19 <kallisti> you likely don't need the constructor.
10:06:27 <elliott> mm_freak: well, depends how often you look at your state
10:06:28 <killy9999> perhaps
10:06:36 <elliott> mm_freak: Lazy.State Int is probably a big mistake, for instance
10:06:53 <killy9999> I wanted to get an instance of UTCTime to test how it is shown
10:07:04 <ski> elliott : well, i think in this case strict state wouldn't be strict enough anyway
10:07:09 <roconnor> killy9999: use getCurrentTime
10:07:13 <kallisti> I look at my state everytime I perform most actions within the monad..
10:07:31 <mm_freak> elliott: well, i think if seq /= deepseq for your state type, then lazy state well makes sense…  in fact sometimes even deferred calculation is pretty useful
10:07:35 <killy9999> roconnor: thanks, that should be fine
10:08:01 <ski> elliott : for small stuff like `Int', it's usually best to be strict -- for larger stuff, lazy might be preferable, depending ..
10:08:04 <danharaj> edwardk: Just reinstalled the comonad package. Thought you'd like to know that it compiles with a warning about mkTyCon being deprecated on ghc 7.
10:08:40 <ski> killy9999 : s/instance/value/
10:09:11 <killy9999> mhm
10:09:24 <killy9999> right, instance is a different thing in Haskell
10:09:50 <rizlah> Why is GHC so big?
10:10:08 <kallisti> big in what sense?
10:10:29 <alpounet> on disk, i guess
10:10:56 <rizlah> On disk.
10:11:21 <elliott> it's not
10:11:26 <elliott> well it is and it isn't
10:11:36 <elliott> it is because we have to build our libraries N times, and GHC statically links by default
10:11:47 <elliott> meaning you actually have about 3 to 5 GHCs :p
10:12:03 <elliott> and it isn't because it comes with lots of libraries and isn't actually much bigger than most other things
10:12:07 <elliott> see http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
10:12:42 <Botje> is 'the GHC' now a unit of measure?
10:13:25 <alpounet> "they have been caught with 10 GHCs of cocaine"
10:13:37 <elliott> alpounet: "my brain just exploded"
10:13:48 <alpounet> haha
10:13:53 <elliott> don't do GHC, kids
10:14:44 <edwardk> danharaj: yes. i can either clutter up all my packages with #ifdef around using the new Typeable or i can wait a generation until we have a Haskell Platform that ships with 7.4.1 whereupon mkTyCon3 will have actually shipped in a compiler that people can reasonably be expected to use and then I can just change 5 characters
10:14:44 <danharaj> GHC is the unit of type extensions.
10:15:09 <danharaj> edwardk: Oh. Sorry. I always forget that the Haskell Platform lags a few months behind the latest GHC.
10:15:10 <edwardk> danharaj: in the meantime i'm taking a somewhat mixed approach.
10:15:23 <parcs`> ghc is big because it is awesome, simple as that
10:15:25 <edwardk> its lagged the better part of a year this time
10:15:26 <companion_cube> so hugs is about 1/4 GHC?
10:15:28 <danharaj> Also I'm not sure when the change to mkTyCon3 happened.
10:15:33 * kallisti wonders why there isn't a haskell compiler named THC.
10:15:39 <rizlah> Also, why does GHC use CamelCase? HardToReadAndLooksStupid, AlongWithBeingAnnoyingToType
10:15:46 <rizlah> Uh, s/GHC/Haskell/
10:16:06 <ski> @quote milli-oleg
10:16:06 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
10:16:06 <edwardk> it was a new change. its good. i understand why, its just annoying because the deprecation warnings make for an ugly upgrade path
10:16:10 <danharaj> I've never heard a *language* using CamelCase.
10:16:12 <kallisti> rizlah: that's just like, your opinion man.
10:16:24 <elliott> danharaj: 7.4 introduced mkTyCon3 and deprecated the old one
10:16:25 <ciaranm> danharaj: ruby comes close
10:16:38 <elliott> danharaj: so now it gives big warnings saying STOP SUPPORTING 7.2 AND BELOW
10:16:54 <edwardk> rizlah: *shrug* they had to pick something. just find ways to never use more than one word in a variable name ;)
10:17:04 <kallisti> danharaj: also because_its_less_annoying_than_this  and-subtraction-is-more-important-than-this
10:17:04 <rizlah> danharaj: When the standard library of a language uses CamelCase, it means the language itself uses camel case, because it makes people use it.
10:17:13 <elliott> ciaranm: huh?
10:17:14 <parcs`> i would like to be able to use - in identifiers, it's much prettier than _
10:17:16 <elliott> ruby doesn't use camel case
10:17:18 <danharaj> fuck the police.
10:17:25 <elliott> rizlah: Haskell uses camelCase mainly.
10:17:28 <edwardk> rizlah: its also in the style guidelines
10:17:30 <elliott> CamelCase also, but mostly camelCase. different!
10:17:39 <elliott> rizlah: Oleg uses quote'case sometimes
10:17:45 <elliott> some libraries use under_scores
10:17:58 <elliott> ideally we could use hyphen-ation, but camelcase is nicer than underscores and quotes
10:17:59 <ski> parcs` : that would be nice
10:18:04 <ciaranm> elliott: RubyUsesCamelCaseForConstantsAndTheInterpreterMoansIfYouDeviateTooMuch
10:18:04 <danharaj> some libraries use unicode symbols.
10:18:07 <elliott> parcs`: ski: hi5
10:19:34 <ClaudiusMaximus> anything is better than that used in http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Constants.html
10:21:10 <rizlah> lol.
10:21:49 <elliott> ClaudiusMaximus: wHAT_ARE_YOU_TALKING_ABOUT
10:22:36 <donri> also, constants in ruby aren't constant
10:23:13 <ClaudiusMaximus> elliott: you forgot to mix in some camelCase at random
10:23:16 <killy9999> I want to read a value of my ADT. If it succeds I want to get Just sth, if not I want Nothing. I've found maybeRead in Network.CGI.Protocol that does exactly that, but it requires a lot of libraries I wouldn't like to include in my project just to get this result
10:23:24 <killy9999> any alternative to maybeRead?
10:23:42 <Botje> the reads function?
10:23:46 <kallisti> killy9999: you mean you want to catch an exception and return Nothing as a result?
10:23:52 <kallisti> in the event that the field is undefined?
10:24:11 <shergill> kallisti: you mean _infix_ subtraction is more important-than-this
10:24:17 <kallisti> shergill: yes
10:24:58 <killy9999> I want to parse a value given by the user
10:25:04 <elliott> ClaudiusMaximus: sORRY_illMakeSureToDoSoInFuture
10:25:04 <kallisti> oh, yes, then you use reads
10:25:04 <shergill> i dunno, i think haskell could've gone the lisp way too. i wouldn't have minded in the least
10:25:13 <killy9999> if it succeds I want Just sth, else Nothing
10:25:18 <kallisti> > reads "2   2 2 2 2"  :: [(Int, String)]
10:25:19 <lambdabot>   [(2,"   2 2 2 2")]
10:25:29 <kallisti> > reads "what is this I don't even"  :: [(Int, String)]
10:25:30 <lambdabot>   []
10:25:33 <killy9999> OK
10:25:34 <elliott> to hell with subtraction
10:25:40 <elliott> HYPHEN and MINUS SIGN are different unicode characters
10:25:56 <znhxr> ndash
10:26:04 <kallisti> elliott: luckily I have a full Unicode keyboard.
10:26:06 <elliott> yeah en dash in names would be fine too
10:26:14 <elliott> wait
10:26:15 <elliott> is that legal?
10:26:18 <elliott> that might even be legal
10:26:19 <ciaranm> it's a shame SNOWMAN isn't an identifier character
10:26:36 <elliott> > let please–let–this–work = () in ()
10:26:37 <lambdabot>   <no location info>: parse error on input `
10:26:40 <Elemir> full Unicode keyboard?
10:26:41 <parcs`> what is it? punctuation?
10:26:41 <elliott> hmph
10:26:50 <ski> > (reads :: ReadS Int) "2   2 2 2 2"  -- kallisti, nicer to write like this
10:26:51 <lambdabot>   [(2,"   2 2 2 2")]
10:26:54 <ciaranm> the snowman is a symbol
10:26:58 <kallisti> ski: oh that's what that's for...
10:27:06 <Elemir> What size has a full unicode keyboard?
10:27:12 <kallisti> ski: should probably have directed that at killy9999 as well.
10:27:40 * elliott imagines a 3d unicode cube, big enough to walk around in
10:27:40 <kallisti> Elemir: my keyboard has over 100,000 keys. what's the problem?
10:27:43 <ski> kallisti : oh, didn't notice killy9999 was involved
10:27:50 <killy9999> > reads "123" :: [(Int,String)]
10:27:50 <lambdabot>   [(123,"")]
10:27:59 <killy9999> > reads "Abc" :: [(Int,String)]
10:28:00 <lambdabot>   []
10:28:05 <kallisti> killy9999: ReadS Int is a type synonym for that
10:28:07 <ski> > (reads :: ReadS Int) "123"
10:28:08 <lambdabot>   [(123,"")]
10:28:11 <Elemir> > 2 ^ (3 * 8)
10:28:12 <lambdabot>   16777216
10:28:20 <ski> > (reads :: ReadS Int) "123Abc"
10:28:21 <lambdabot>   [(123,"Abc")]
10:28:27 <killy9999> why the second case returns [] ?
10:28:38 <ski> kallisti : because no parse
10:28:43 <killy9999> mhm
10:28:44 <Elemir> kallisti: Over 1,000,000 keys
10:28:49 <kallisti> killy9999: on "Abc"?  because that can't be interpreted as an integer.
10:28:51 <byorgey> maybeRead x = case reads x of [(v,"")] -> Just v; _ -> Nothing
10:28:54 <kallisti> [] is your failure case here.
10:29:01 <kallisti> think of it as being the same as Nothing.
10:29:06 <killy9999> OK
10:29:34 <kallisti> killy9999: the string in the tuple is the trailing stuff after parsing. So if you want to be strict you could enforce that to be empty.
10:29:36 <byorgey> killy9999: see readMay from http://hackage.haskell.org/packages/archive/safe/0.3.3/doc/html/Safe.html
10:30:08 <parcs`> > logBase ((26 + 10 + 11) * 2) (2 ^ 24)
10:30:08 <lambdabot>   3.6615568944278225
10:30:33 <kallisti> are there any reads calls that evaluate to something other than a 0 or 1-length list?
10:30:47 <elliott> not in base afaik
10:30:53 <elliott> they're all constructed from ReadP which doesn't do that
10:31:01 <elliott> reads should really disappear and be replaced with a readMaybe
10:31:29 <nart> hi
10:31:37 <nart> i'm trying to parse this stuff with parsec http://hpaste.org/66231
10:31:43 <nart> without success :S
10:32:37 <nart> need to get all the stuff inside \\<word>\\
10:32:58 <nart> and with sepBy i can get without any difficulties
10:33:06 <Botje> nart: wow, that is a horrible format.
10:33:11 <kallisti> you know, now would be a good time for someone to capitalize on custom Haskell keyboards, with various useful Unicode symbols.
10:33:27 <nart> Botje: i know :S
10:33:42 <Botje> nart: so what seems to be the problem?
10:33:47 <nart> the problem here is that when the parser
10:33:48 <kallisti> you could even put a Haskell logo on them. owning one would give you mad Haskell cult cred.
10:33:57 <killy9999> byorgey: thanks
10:33:58 <nart> arrives here: "\\pswrd\\0\\mod\\1\n0"
10:34:06 <nart> you see after the 1 there's no \\
10:34:20 <nart> so it gets eveything after it, but it should stop at 1
10:35:15 <Botje> nart: oh, and you're using something like foo `sepBy` string "\\\\" ?
10:35:34 <nart>          (sepEndBy1 word (char '\\'))
10:35:52 <nart> where word is word = many1 (alphaNum <|> symbol <|> space)
10:36:33 <kallisti> a linked list that tracked length would be pretty swell.
10:36:34 <Botje> nart: you could do a sep(End)by newline first?
10:36:46 <kallisti> it would even be pretty convenient to use with OverloadedSequences(tm)
10:37:24 <tilman> from [IO (a)] i want to retrieve the first element for which a predicate a->Bool returns true. i need to pull out the values from the IO monad from left to right. any pointers on how to achieve that?
10:37:44 <nart_> damn, i disconnected :S
10:37:50 <Botje> nart: you could do a sep(End)by newline first?
10:37:58 <Botje> tilman: does it matter if all of them are executed?
10:38:27 <tilman> Botje: yes, i only want to exec as few as possible
10:38:45 <Botje> tilman: then a tail-recursive function is probably easiest.
10:38:45 <tilman> Botje: i know i can use sequence to execute them all (too easy :p)
10:39:08 <tilman> Botje: mmh. maybe i should look at how sequence is implemented
10:39:10 <mornfall> tilman: Well, you can spell out the loop.
10:39:39 <kallisti> tilman: I believe sequence would strictly evaluate all of the IO actions, but the actual data isn't necessarily forced.
10:39:43 <kallisti> I may be wrong though
10:40:21 <Botje> tilman: yes, that's a nice starting point.
10:40:25 <mornfall> Well, the sideffects will happen if you sequence, which you don't want.
10:40:41 <Botje> sequence_ is probably better still
10:41:18 <nart_> Botje: mmm not working
10:41:37 <kallisti> @src sequence
10:41:37 <lambdabot> sequence []     = return []
10:41:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:41:37 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
10:41:41 <Botje> nart_: what isn't ?
10:42:13 <kallisti> tilman: you could just use fine to get a Maybe (IO a)
10:42:16 <kallisti> *find
10:42:19 <tilman> kallisti: ah, thanks. i was looking at the definition given by the 'a tour of the haskell monad functions', which looks more intimidating =)
10:42:27 <mornfall> tilman: http://stackoverflow.com/questions/1133800/haskell-monadic-takewhile
10:42:31 <ski> @src sequence_
10:42:31 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
10:42:49 <parcs`> well IO is not an Alternative but for Alternatives:
10:42:49 <Botje> kallisti: you can't quite get the a out of IO a though.
10:43:01 <kallisti> you can within an IO action...
10:43:02 <parcs`> :t let predicate = undefined :: a -> Bool in foldr ((<|>) . guard . predicate) mzero . map (fmap ($ predicate))
10:43:03 <kallisti> ?
10:43:03 <lambdabot> forall (f :: * -> *) b a (f1 :: * -> *). (Alternative f, MonadPlus f, Functor f1) => [f1 ((a -> Bool) -> b)] -> f ()
10:43:10 <kallisti> oh you mean in find.
10:43:20 <elliott> @hoogle fndM
10:43:20 <lambdabot> No results found
10:43:21 <elliott> @hoogle findM
10:43:21 <lambdabot> Data.IntMap findMax :: IntMap a -> (Key, a)
10:43:22 <lambdabot> Data.IntSet findMax :: IntSet -> Int
10:43:22 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
10:43:24 <elliott> huh
10:43:27 <nart_> Botje: i think i have found the solution, ty
10:43:28 * hackagebot hlint 1.8.27 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.27 (NeilMitchell)
10:43:30 <ski> @hoogle+
10:43:30 <lambdabot> Data.Set findMax :: Set a -> a
10:43:31 <lambdabot> Data.IntMap findMin :: IntMap a -> (Key, a)
10:43:31 <lambdabot> Data.IntSet findMin :: IntSet -> Int
10:43:32 <parcs`> :t let predicate = undefined :: a -> Bool in foldr ((<|>) . guard . predicate) mzero . map (fmap predicate)
10:43:33 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Alternative f, MonadPlus f, Functor f1) => [f1 a] -> f ()
10:43:48 <elliott> kallisti: "you can within an IO action..." indeed, you can take the IO a out of IO a
10:43:51 <ciaranm> @binh
10:43:51 <lambdabot> Maybe you meant: bid kind ping
10:44:13 <parcs`> aw, well you can use 'guard' and '<|>' to get the first Alternative thing in a list that satisfies a predicate without explicit recursion
10:44:31 <kallisti> guard on IO? that's going to deprecate isn't it?
10:44:48 <parcs`> yeah, doesn't work for IO :(
10:45:15 <parcs`> perhaps you can conjure something up with exceptions :P
10:45:19 <kallisti> this is why MonadPlus needs to be fixed.
10:45:44 <kallisti> so that IO can have a monoid that doesn't have to obey all of the laws.
10:46:21 <hpaste> ClaudiusMaximus annotated “ghci slow with long module names” with “ghci slow with long module names (annotation)” at http://hpaste.org/66183#a66232
10:46:23 <ski>   forall f :: IO (Maybe a) -> Maybe (IO a). (f = const Nothing) \/ (exists g :: IO (Maybe a) -> IO a. f = Just . g)  -- hm ?
10:46:25 <tilman> thanks for the suggestions
10:46:52 <ClaudiusMaximus> those asymptotics puzzle me...
10:47:20 <parcs`> :t let foo predicate = foldr (\m a -> (guard (predicate m) >> return m) `mplus` a) mzero in foo
10:47:21 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> [a] -> m a
10:48:55 <ClaudiusMaximus> @hoogle findM +monad-loops
10:48:55 <lambdabot> Could not find some databases: monad-loops
10:48:56 <lambdabot> Searching in:
10:48:56 <lambdabot>   .
10:49:09 <elliott> @hayoo pls
10:49:09 <lambdabot> Unknown command, try @list
10:50:08 <kallisti> I'm guessing base64-bytestring is for strict bytestrings only.
10:50:27 <roconnor> edwardk: if you removed #ifdefs around your Typeable instances, I will stop using your packages.
10:50:50 <elliott> what's wrong with Typeable instances?
10:50:53 <edwardk> roconnor: ? i have no intention of breaking my code on 7.0
10:51:22 <edwardk> roconnor: so i'm not sure where that is coming from
10:52:47 <edwardk> i was simply stating that there isn't a way that i can support mkTyCon3 and make those warnings away without adding more of them or waiting sufficiently long that a haskell platform has shipped with mkTyCon3 in it
10:53:30 <edwardk> elliott: nothing. the issue is just that the way you make them manually changed in 7.4, and it shouts deprecations at everyone
10:53:50 <elliott> oh, ok, i thought roconnor was talking about the GLASGOW_HASKELL ifdefs or something
10:53:53 <edwardk> arguably the deprecation was premature
10:53:56 <elliott> agreed
10:54:08 <elliott> deprecating something simultaneously with introducing its replacement is just absurd
10:54:22 <edwardk> oh, those aren't going away in the core packages any time soon, because i need TypeableN
10:54:27 <roconnor> edwardk: i see I misread what you wrote
10:55:11 <edwardk> elliott: yeah i would have expected mkTyCon3 to be introduced, a platform to be shipped and for the next version to include the deprecation
10:55:36 <edwardk> but i can see why they just wanted to rip off the bandaid ;)
10:57:24 <kallisti> yeah I think as an abstraction over IO, with a very simple state type, it makes sense to use strict StateT.
10:58:10 <kallisti> but I haven't really done any performance tests. Most of the operations are network-bound anyway.
10:58:21 <kallisti> in fact, all of them.
11:00:38 <eacameron> The encoding package failed to install for me. I'm still trying to figure out how to go from [Char] to [Word8]. Thougths?
11:01:01 <kallisti> eacameron: are you working with ByteStrings?
11:01:28 <monochrom> perhaps you should fix the installation error. highly likely you can't install any other package.
11:01:43 <eacameron> kallisti: I want to be! But i'm still in [Char] land!
11:01:48 <kallisti> there's Data.ByteString.*.Char8  which uses Char instead of Word8
11:02:25 <eacameron> monochrom: actually, I've installed several other packages today...not sure what "encoding"s problem is
11:02:26 <kallisti> not sure how it handles encoding to ByteString though.
11:02:52 <kaitocracy> hi I'm using conduits and I've got a sourceFile which I need to push into a sinkFile after I've dropped the first line
11:02:56 <monochrom> oh, the more packages you install, the closer you get to installation errors later
11:03:04 <kaitocracy> what is a good way to do this?
11:03:26 <eacameron> monochrom: uggg...
11:03:30 * hackagebot PDBtools 0.0.1 - A library for analysis of 3-D protein coordinates  http://hackage.haskell.org/package/PDBtools-0.0.1 (GrantRotskoff)
11:03:33 <monochrom> past success is not evidence for future success. actually the opposite
11:04:26 <eacameron> monochrom: i just installed glob as a test and it worked...
11:04:47 <kallisti> kaitocracy: are you using Text or Strings?
11:04:58 <monochrom> in particular "I have successfully installed 2 instances of network-2.3.0.0, 3 instances of network-2.3.0.1, and 1 instance of network-2.3.0.2, \o/" is a recipe for disaster
11:05:07 <eacameron> kallisti: what's the difference?
11:05:22 <elliott> Text is like String but faster and uses much less memory (it's also strict).
11:05:31 <elliott> You shouldn't be using ByteString if you are dealing with Unicode.
11:05:42 <kallisti> eacameron: String is a linked list of unicode characters, thus it can be infinite in size but is also evaluated linearly.
11:05:46 <kaitocracy> kallisti: um ByteStrings
11:05:50 <kallisti> kaitocracy: oh
11:05:53 <kaitocracy> kallisti: since all I need to do is drop the first line of the file
11:06:23 <kallisti> kaitocracy: I believe you can use a Funcotr instance somewhere to apply a "lines" function, then use drop from Data.Conduit.List and then unlines.
11:06:30 <eacameron> kallisti: ahhh ok...so how do I go about creating a ByteString or Text?
11:06:37 <kaitocracy> kallisti: is that efficient?
11:06:39 <kallisti> eacameron: from...?
11:06:54 <eacameron> kallisti: from some literal "Some literal"
11:07:01 <kallisti> import Data.String
11:07:12 <kaitocracy> kallisti: would it read the whole list into memory?
11:07:15 <kallisti> text :: Text; text = fromString "hello"
11:07:24 <kallisti> alternatively, you can use OverloadedStrings
11:07:33 <kallisti> which performs the fromString call automatically.
11:07:38 <kallisti> similar to Num overloading.
11:08:03 <eacameron> kallisti: ahhh...clarity is refreshing! thanks
11:08:58 <Guest73575> How do I make 'LitE (IntegerL (2))' ExpQ ?
11:09:04 <kallisti> kaitocracy: I'm not sure really.
11:09:17 <kallisti> I don't see a "lines" function in the conduit library.
11:09:18 <elliott> eacameron: kaitocracy: please don't use ByteString if you want to use string literals.
11:09:25 <elliott> that means you should use Text, not ByteString, which is for binary data.
11:09:44 <elliott> Guest73575: return :: Exp -> Q EXp
11:09:45 <elliott> *Exp
11:09:46 <elliott> and thus ExpQ
11:09:49 <kaitocracy> elliott: not string literals, just need to pipe an input file to an output file with the first line removed
11:09:53 <elliott> p.s. please change your name, it's very hard to keep track of "Guest####"
11:10:01 <eacameron> elliott: ahh ok...well I'm working with this pcre-light library which only takes ByteStrings
11:10:05 <elliott> kaitocracy: oh, ok. i mixed up you and eacameron.
11:10:09 <eacameron> elliott: or so it appears
11:10:14 <elliott> kaitocracy: but Conduit can do Text too.
11:10:26 <elliott> eacameron: oh, yeah, that's old. 2010
11:10:31 <monochrom> there is only one Guest##### right now
11:10:46 <elliott> monochrom: " Guest73575 Guest25308 Guest32898 Guest3811 Guest59150 Guest69499 Guest7734 Guest81617"
11:10:50 <elliott> by keep track of, i mean tab complete
11:10:59 <kallisti> kaitocracy: I think if you're using lazy ByteStrings then "lines" will be efficient.
11:11:09 <monochrom> haha ok
11:11:10 <eacameron> elliott: better library out there?
11:11:10 <Guest32898> we are anonymous, we are legion
11:11:20 <kallisti> kaitocracy: I'm not really a conduit guru, so I don't know for sure.
11:11:26 <kaitocracy> ahh
11:11:31 <kallisti> you could probably roll your own lines function of some kind.
11:11:32 <monochrom> doesn't your tab-complete has "most recently spoken" order? weak. weak.
11:12:01 <elliott> monochrom: yes, it does
11:12:08 <elliott> it still gives up if there's that much ambiguity, apparently
11:12:10 <kallisti> kaitocracy: oh wait there's dropWhile duh
11:12:16 <kallisti> takeWhile :: Resource m => (Word8 -> Bool) -> Conduit ByteString m ByteString
11:12:29 <kallisti> ...er
11:12:39 <kallisti> and, unrelatedly, takeWhile. :P
11:12:41 <elliott> for instance i type mon and get monochrom, despite mononofu.
11:12:46 <elliott> but guest<tab> just gives me a list.
11:13:01 <kaitocracy> I think I just realized how to do this with dropWhile
11:13:02 <kaitocracy> thanks!
11:13:15 <kallisti> kaitocracy: oh and lines. wow I should have just looked at the Binary submodule. :P
11:14:09 * kallisti wonders why dropWhile is a Sink while takeWhile is a Conduit.
11:15:14 <kallisti> I guess it needs to make use of SinkNoData at some point, since that's the primary difference. otherwise it would make more sense as a Conduit.
11:16:39 <kallisti> oh I think it's so that dropWhile can pass on the remaining input once the connection closes.
11:16:47 <kaitocracy> yeah I think that's how I'm going to do it
11:17:39 <kallisti> how... imperative. :P
11:18:21 <Guest58141> if IntegerL is for Integer then what is for Int ?
11:18:57 <kallisti> @hoogle IntegerL
11:18:57 <lambdabot> Language.Haskell.TH.Syntax IntegerL :: Integer -> Lit
11:18:57 <lambdabot> Language.Haskell.TH IntegerL :: Integer -> Lit
11:18:57 <lambdabot> Language.Haskell.TH.Lib integerL :: Integer -> Lit
11:19:10 <kallisti> integer literals are overloaded.
11:19:20 <kallisti> so... it works for either
11:20:04 <kallisti> oh you mean how do you pass an Int? use toInteger
11:20:39 <kallisti> @hoogle IntL
11:20:40 <lambdabot> GHC.Constants mAX_INTLIKE :: Int
11:20:40 <lambdabot> GHC.Constants mIN_INTLIKE :: Int
11:20:40 <lambdabot> package pointless-haskell
11:20:43 <kallisti> yeah.. no.
11:20:50 <kallisti> just convert the Int to Integer.
11:21:36 <monochrom> conduit is a bit imperative (internal state) iirc
11:21:51 <kallisti> monochrom: well the interface itself is a bit of mixture.
11:21:53 <luite> it doesn't have much internal state anymore
11:22:00 <kallisti> not that there's anything wrong with imperative style (in a high-level language)
11:22:07 <luite> there is one particular case where it still has
11:22:30 <kallisti> *high-level lazily evaluated function language  :P
11:22:38 <elliott> monochrom: it's not any more, apart from BufferedSource
11:22:41 <luite> where i mean mutable state :)
11:23:16 <elliott> (in fact it's basically pipes with a lot of duplication, as evidenced by the fact that it's almost certainly unifying the types with a pipe-based model next release.)
11:23:33 <luite> elliott: that's already done
11:23:40 <luite> and will be part of the upcoming yesod 1.0 release
11:26:44 <Guest58141> why doesn't this work: LitE (IntegerL( fun s)) ?  fun has this signature: fun :: String -> Int
11:27:36 <luite> IntegerL requires Integer, not Int
11:27:41 <luite> you can use fromIntergral (fun s)
11:27:45 <luite> fromIntegral
11:28:49 <Guest58141> luite: thanks. That worked.  I was just told that IntegerL is overloaded
11:29:11 <elliott> Guest58141: it is.
11:29:18 <elliott> Guest58141: an IntegerL represents a literal of any numeric type
11:29:23 <elliott> inside LitE
11:29:34 <elliott> that is, the haskell program that LitE (IntegerL 123) represents has type (Num a) => a
11:29:40 <monochrom> I think you just misunderstood, and furthermore read incompletely.
11:30:35 <monochrom> "<kallisti> integer literals are overloaded." this means if you have "15" in source code, it's overloaded. this doesn't pertain to your question though. what pertains to your question is, immediately right after,
11:30:35 <elliott> Guest58141: (I don't suppose I could convince you to change your nick either? :P)
11:30:46 <monochrom> "<kallisti> oh you mean how do you pass an Int? use toInteger"
11:37:30 <kallisti> oh dear, I've been quoted.
11:37:35 <kallisti> that's never good.
11:45:30 <ClaudiusMaximus> big-O question - if the size of the input increases by a factor of k and the corresponding output increases by a factor of k^2, what's the big-O class of the operation?
11:47:40 <c_wraith> ClaudiusMaximus: depends on what you define it as.
11:48:39 <c_wraith> ClaudiusMaximus: the "problem size" for NxN matrix multiplication, for instance, is defined to be N.  so even the size of the input is O(n^2)
11:49:28 <byorgey> ClaudiusMaximus: O(n^2) I think.  Because if f(n) = n^2  then  f(kn) = (kn)^2 = k^2 n^2 = k^2 f(n).
11:50:39 <ClaudiusMaximus> thanks  :)
11:52:09 <ClaudiusMaximus> my testing shows that ghci's module name parser is O(n^2) (where n is the length of the module name...
11:52:27 <hpc> ClaudiusMaximus: um what
11:52:37 <dmwit> f(kn) = k^2 f(n) implies f(k) = k^2 by choosing n=1
11:53:04 <byorgey> ClaudiusMaximus: hehehe
11:53:53 <elliott> ClaudiusMaximus: haha
11:54:28 <blippdude> is Haskell a programming language for beginners?
11:54:28 <hpaste> ClaudiusMaximus annotated “ghci slow with long module names” with “ghci slow with long module names (annotation) (annotation)” at http://hpaste.org/66183#a66234
11:54:28 * dmwit is pleasantly surprised that "deriving instance Context => Head" actually worked
11:54:45 <dmwit> StandaloneDeriving actually lets you derive more things than inline deriving!
11:55:03 <kallisti> nice
11:55:04 <elliott> yeah, it does
11:55:05 <elliott> it's useful
11:55:12 <elliott> even gadts and the like
11:55:12 <hpaste> ClaudiusMaximus annotated “ghci slow with long module names” with “ghci slow with long module names (annotation) (annotation) (annotation)” at http://hpaste.org/66183#a66235
11:55:19 <elliott> blippdude: a beginner can certainly learn haskell as their first language
11:55:22 <byorgey> blippdude: it is not a language specifically for beginners.  But there is no reason a beginner couldn't learn it.
11:55:26 <elliott> blippdude: it will be tough, but rewarding
11:55:54 <elliott> note that haskell is very unlike the vast majority of programming languages out there
11:56:38 <blippdude> Im wondering to start programming my own programs I also have a android phone, does it support android?
11:56:58 <elliott> there's preliminary support i think but definitely nothing polished or ready for prime-time yet
11:57:01 <elliott> in GHC
11:57:04 <elliott> i may be wrong though
11:57:49 <hpc> you can compile to javascript if your definition of "support" is useless enough
11:58:09 <hpc> that's about it afaik
11:58:14 <elliott> well there's ARM support
11:58:23 <elliott> so you should be able to run GHC-compiled stuff on Android
11:58:29 <elliott> but you won't have any of the GUI libraries or the like :P
11:58:32 <elliott> that'll require Java interop
11:58:36 <dmwit> If "Additive" and "Multiplicative" are data families, can "instance (Show (Additive v), Show (Multiplicative v)) => Show (Both v)" really lead to undecidable instances? (data Both v = Both (Additive v) (Multiplicative v))
11:58:39 <thoughtpolice> there's some basic cross compilation functionality in the build system proper that blackh wrote, but in practice there's a bit more than that necessary for a usable cross compiler
11:58:45 <dmwit> Or can I safely add that extension in this case?
11:58:46 <hpc> elliott: or just ffi now, i think
11:58:49 <thoughtpolice> (mostly boring toolchain related issues rather than anything intrinsically difficult)
11:58:58 <hpc> you can write native android apps
11:59:14 <hpc> didnt know ghc did arm
11:59:15 <thoughtpolice> blackh also did update his iOS patches for GHC, but they're not integrated. he plans on following up with android support afterwords
11:59:18 <hpc> very cool
11:59:20 <thoughtpolice> hpc: only via llvm
11:59:27 <thoughtpolice> (there's no arm NCG)
11:59:29 <hpc> makes sense
11:59:40 <elliott> <dmwit> If "Additive" and "Multiplicative" are data families, can "instance (Show (Additive v), Show (Multiplicative v)) => Show (Both v)" really lead to undecidable instances? (data Both v = Both (Additive v) (Multiplicative v))
11:59:43 <elliott> dmwit: that one is fine
11:59:50 <elliott> i think
11:59:57 <elliott> although maybe if you added instance (Show (Both v)) => Show (Additive v)
11:59:57 <hpc> android is a horrible place to learn though
11:59:59 <hpaste> “pickN again” pasted “kallisti” at http://hpaste.org/66236
12:00:19 <kallisti> any suggestions on how to improve this code? it doesn't need to be particularly fast.
12:00:25 <kallisti> just curious
12:01:53 <hpc> blippdude: i recommend you dont start your programming experience with android; it is a bit of a nightmare to get stuff to run on a phone
12:01:54 <dmwit> elliott: ah, yes, so it is still scary
12:01:55 <kallisti> also hlint suggests forM over mapM?  for shame.
12:02:10 <dmwit> elliott: Okay. I'll still turn it on and let it be dangerous.
12:02:11 <elliott> dmwit: well... UndecidableInstances does not scare me
12:02:17 <hpc> forM puts the continuation last
12:02:30 <hpc> makes anonymous actions much nicer
12:02:49 <kallisti> this anonymous action is not particularly large. I like the current style.
12:03:04 <kallisti> mapM (\(i,x) -> V.write v i x) . zip [0..] $ ls
12:03:52 <dmwit> ?index on
12:03:52 <lambdabot> bzzt
12:04:10 <elliott> ?index off
12:04:10 <lambdabot> bzzt
12:04:12 <elliott> ?index offSKL;ASD
12:04:13 <lambdabot> bzzt
12:04:15 <elliott> What.
12:04:21 <hpc> @index
12:04:22 <lambdabot> bzzt
12:04:25 <elliott> ?insect
12:04:25 <lambdabot> Unknown command, try @list
12:04:32 <hpc> heh
12:04:38 <dmwit> bzzt is what it says when it doesn't know the answer, elliott.
12:05:04 <elliott> @index d
12:05:04 <lambdabot> bzzt
12:05:05 <elliott> @index dmwit
12:05:06 <lambdabot> bzzt
12:05:09 <elliott> Pah.
12:05:11 <hpc> @index can haskell dance?
12:05:12 <lambdabot> bzzt
12:05:19 <hpc> @faq can haskell dance?
12:05:19 <lambdabot> The answer is: Yes! Haskell can do that.
12:05:25 <hpc> AHA!
12:05:43 <kallisti> @faq can Haskell overload list syntax and constructors?
12:05:44 <lambdabot> The answer is: Yes! Haskell can do that.
12:05:49 <kallisti> lies.
12:06:21 <Elemir> @faq Mammoth is like biiig cat, isn't it?
12:06:21 <lambdabot> The answer is: Yes! Haskell can do that.
12:06:54 <magicman> I see that Text.Parsec.Text re-exports Text.Parsec.String. Any way to not do that, but use Text.Parsec.Text instead?
12:11:01 <dmwit> magicman: I don't understand the question.
12:11:22 <dmwit> Can you fit it into the magical format? "I do X, expecting Y to happen, but Z happens instead."
12:12:33 <magicman> But what I expect to happen is what actually happens. It is not what I want to happen.
12:12:54 <monochrom> cool, s/expecting/wanting/
12:13:01 <dmwit> I wouldn't mind if you changed the format to "I do X, wanting Y to happen, but Z happens instead."
12:13:35 <elliott> I do A, Bing C to happen, but D happens instead.
12:13:52 <elliott> I A B, Cing D to E, but F Es instead.
12:14:02 <magicman> I import Text.Parsec, which re-exports type synonyms in Text.Parsec.String. However, I want to use the type synonyms from Text.Parsec.Text instead of those in Text.Parsec.String.
12:14:31 <elliott> import Text.Parsec hiding (The, Synonyms)
12:14:33 <elliott> import Text.Parsec.Text
12:14:49 <magicman> ... d'oh, yes >_<
12:14:53 <magicman> Thanks :)
12:16:11 <dmwit> Are type annotations firmer than inferred types somehow?
12:16:22 <ClaudiusMaximus> sadly "import Text.Parsec hiding (module Text.Parsec.String)" says "illegal import item" :(
12:16:25 <monochrom> yes
12:16:29 <dmwit> neat
12:18:39 <misterbeebee> Microsoft has the Simons PJ and M in the GHC lab, and Facebook hired Bryan O'Sullivan recently. Does Google have any majorly active Haskellers?
12:18:40 <lambdabot> misterbeebee: You have 1 new message. '/msg lambdabot @messages' to read it.
12:18:58 <elliott> guido van rossum
12:18:59 <ssbr_> my favorite thing: showing a tutorial room how to eta-reduce "map \x (2 + x) somelist" into map (2+) somelist
12:19:23 <znhxr> map (\x -> 2 + x)
12:19:29 <misterbeebee> wow, I did not know Guide van Rossum did Haskell
12:19:37 <yasar> me too.
12:19:38 <ssbr_> znhxr: sorry yes
12:19:45 <znhxr> misterbeebee: I doubt he does
12:19:59 <ssbr_> (I actually did the eta reductions in scheme, and then was like, "oh, yeah, and this is what it looks like in haskell)
12:20:04 <ssbr_> (because organization is what?)
12:20:04 <yasar> No wonder why there is list comprehensions in python :D
12:20:08 <misterbeebee> he's been mentioning it on his G+ page recently, it seems
12:20:10 <elliott> misterbeebee: I was kidding :P
12:20:18 <elliott> Guido van Rossum is rather ignorant of functional programming.
12:20:33 <elliott> I don't think he's the one who took list comprehensions from Haskell, even.
12:20:39 <misterbeebee> https://plus.google.com/115212051037621986145/posts/5zE7CNBNB4F
12:20:39 <misterbeebee> https://plus.google.com/115212051037621986145/posts/9bQZudT42Gx
12:20:45 <misterbeebee> "I am educating myself about Haskell as we speak, maybe next week I can explain all this. :-) ]" - Nov 20, 2011
12:21:00 <ssbr_> znhxr: (unfortunately I was doing a tutorial on haskell without knowing haskell. stuff sucks when people do last minute cancellations <_<)
12:21:41 <elliott> misterbeebee: ha, so i was accidentally right.
12:21:46 <misterbeebee> :)
12:22:16 <misterbeebee> It doesn't seem like he actually does any more Haskell than a dabbler like me, though.
12:22:33 <elliott> "They pride themselves that Haskell has no while-loops -- but they have infinite lists."
12:22:47 <elliott> "I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a remark."
12:23:46 <znhxr> while c b = loop where loop = do { x <- c; if x then b >> loop else return () }
12:24:07 <dmwit> ?src until
12:24:07 <lambdabot> until p f x | p x       = x
12:24:07 <lambdabot>             | otherwise = until p f (f x)
12:24:12 <misterbeebee> The only other Haskell reference I've seen connected to a Googler is that Team Smartass used it in ICFP 2006, alongside C++. But from other years, I gather that they prefer C++ by far (for ICFP at least).
12:24:25 <elliott> those Pythoners are so weird, they pride themselves on having no type system, but they have intgers!
12:24:26 <misterbeebee> I figured with so many engineers, and with Google's penchant for hiring the tech-famous, that they would have snagged someone in the Haskell community.
12:24:50 <elliott> well google are very devoted to c++/java/python/go as i understand it
12:25:27 <ssbr_> elliott: :(
12:25:29 <monochrom> I certainly don't pride myself that Haskell has no while-loops.
12:25:47 <ssbr_> they pride themselves on having everything be all ad-hoc polymorphism all the time
12:25:57 <monochrom> but I pride that while-loops can be user-defined, not God-given or Guido-given
12:26:06 <misterbeebee> Yeah, but the GHC team in MSR does their thing that Microsoft doesn't use for any business purpose, apparently MSFT pays them just to keep Eric Lippert company.
12:26:12 <monochrom> Yes! I pride myself that Haskell has no Guido!
12:26:26 <misterbeebee> I thought Google might do similar, like they do with their self-driving car project.
12:26:45 <elliott> misterbeebee: well Microsoft Research is Microsoft's self-sufficient goodwill generator :)
12:28:35 <monochrom> oh! it's Guido's post. so it is not so nice to comment "I pride that we have no Guido" I suppose :)
12:29:25 <dmwit> while-loops are codable in Python in basically the same way
12:29:37 <znhxr> not quite
12:29:42 <causative> is there a theoretical programming language that models the idea of distributing code between computers, and recompiling dynamically at different locations?
12:29:42 <znhxr> in fact, not at all
12:29:43 <ssbr_> dmwit: except that they wouldn't support statements, and there's no TCO or anything
12:29:54 <elliott> monochrom: it's true, though ;)
12:29:54 * monochrom frowns. it's more cumbersome in python
12:30:08 <kaitocracy> anyone have any experience with HDBC? I need to do a COPY FROM STDIN in PostgreSQL
12:30:51 <kallisti> kaitocracy: I'm somewhat familiar.
12:31:14 <kaitocracy> kallisti: any idea how to do that? execute a COPY FROM STDIN?
12:32:11 <kallisti> kaitocracy: I'm not entirely sure how to communicate with the stdin of the postgres server.
12:32:13 <ssbr_> BTW, does anyone else teaching functional programming find that recursion is actually the easy bit? It's HOFs that seem to trip people up
12:32:26 <kallisti> kaitocracy: but to actually run the command it should just be a call to "run"
12:32:44 <ssbr_> it contradicts what I've been told by people that teach imperative programming in universities. They insist recursion is very hard
12:32:55 <kaitocracy> kallisti: yeah I can't figure out how to communicate with stdin
12:33:38 <monochrom> ah, I can certainly make my acidic-to-Guido comments on my own turf!
12:35:21 <monochrom> ssbr_: my understanding of why recursion is "hard" and looping is "easy": http://groups.google.com/group/comp.lang.functional/msg/51df24fbf33b7059
12:35:39 <gzmask> I am newb and stupid, but why type synonyms? why not just use: data String = [Char]  instead of type String = [Char] ? So haskell just invent type synonyms for the sake of using list/tuple in type system?
12:35:53 <monochrom> in short, it's really easy to execute looping, and people are taught to understand programs by executing
12:36:12 <dmwit> gzmask: type String = [Char] is more and more being considered a mistake.
12:36:27 <monochrom> and to come up with programs in the first place by drafting, executing, fixing
12:36:29 <kallisti> kaitocracy: there doesn't appear to be a way to do so. I notice that HDBC has very little support for postgres specific features.
12:36:41 <kallisti> kaitocracy: you could use temp files though
12:36:46 <kallisti> but that's a bit of a hack.
12:36:50 <dmwit> gzmask: An abstract String data type (whose constructors weren't exported) would be a very nice future direction for the Prelude.
12:36:57 <byorgey> gzmask: are you asking about the *syntax* of type synonym declarations, or about the *purpose* ?
12:37:01 <ssbr_> monochrom: OK. Whereas this course focues on building a solution. The prof even wants to mark people down if they have to run their program multiple times ;)
12:37:03 <ssbr_> if he can find a way
12:37:10 <kaitocracy> kallisti: I can't, I can't guarantee the PostgreSQL server will be able to read the tempFile
12:37:13 <gzmask> byorgey: purpose
12:37:20 <roconnor> dmwit: it is funny how Haskell was originally praised for making a String a list of Chars, however I think you are right.
12:37:22 <kallisti> kaitocracy: ah because it could be over network.
12:37:30 <kallisti> right?
12:37:36 <monochrom> if you use problem-solving heuristics such as divide and conquer, recursion is easier
12:37:47 <kaitocracy> kallisti: basically
12:37:59 <kaitocracy> kallisti: unsecure server, not sure if deployment target supports ACLs
12:38:05 <dmwit> roconnor: Well, [Char] is better than what most languages do in a lot of ways. It's worse in some important ways, though.
12:38:06 <byorgey> gzmask: the purpose is just to be able to give alternate names to types, e.g. for documentation purposes, or for abbreviation.   data String = Foo [Char]  is not the same since it requires an extra Foo constructor to be stored alongside every String.
12:38:09 <kallisti> kaitocracy: hmmm, well, what's the file format? you could just interpret the file manually...
12:38:35 <elliott> <gzmask> I am newb and stupid, but why type synonyms? why not just use: data String = [Char]  instead of type String = [Char] ? So haskell just invent type synonyms for the sake of using list/tuple in type system?
12:38:39 <monochrom> now, higher-order functions. that's just people not taking recursion to its logical conclusion. surely, if "Type0 -> Type1" is a legit type, nothing says that "(A->B)->Type1" isn't? just put Type0 = A->B
12:38:39 <elliott> gzmask: data String = [Char] is invalid.
12:38:39 <kaitocracy> kallisti: I might have to do that
12:40:01 <gzmask> byorgey: thanks, that's the answer I am looking for =.= b
12:40:03 <monochrom> after all, even in most people's mother tongue, if "noun verb noun" is allowed, next you allow "('that' noun verb noun) verb noun", it's just natural recursion
12:40:21 <kallisti> kaitocracy: maybe you could try to find the postgres servers PID and write directly to its stdin via procfs? :P
12:40:24 <roconnor> dmwit, BTW, I was told to talk to you about categorical properties of Lenses;  dibblego wants to add (***) and (|||) operators, I'm hesitant to add (|||) since there is no isomorphism between (Lens a b, Lens b c) and (Lens (Either a b) c) (notwithstanding the crap that Arrow has); (***) I'm okay with in principle; but how to name the class?
12:40:43 <kallisti> kaitocracy: actually there's probably a high-level interface for that, if you have the PID.
12:40:48 <dmwit> :t (|||)
12:40:49 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
12:41:32 <dmwit> :t (***)
12:41:32 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:41:43 <dmwit> Oh, yes, (***) seems perfectly reasonable.
12:42:03 <roconnor> dmwit: byorgey claimed you had thought about the categorical properties of lenses
12:42:15 <dmwit> Yes, indeed.
12:42:29 <dmwit> Well, symmetric lenses, anyway. But I know enough to think about asymmetric lenses.
12:43:02 <dmwit> TensorProduct seems like a reasonable if longish hname.
12:43:06 <roconnor> dmwit: I want to make a class for (***) whose laws are (fl *** fr) . (gl *** gr) = (fl . gl) *** (fr . gr) and id *** id = id ... notwithstand the fact that (***) from arrow doesn't statify this.
12:43:27 <kaitocracy> kallisti: I have no guarantee the PostgreSQL process is even local
12:43:29 <dmwit> Those laws are exactly the laws for any tensor.
12:43:34 <ClaudiusMaximus> causative: not sure about theory, but there are a couple of implementations of vaguely related ideas that i'm aware of: http://www.netpd.org/About https://github.com/supercollider-quarks/Republic  (maybe also look at OpenCL ?)
12:43:39 <dmwit> (Actually, any functor from C x C to C.)
12:43:47 <dmwit> (...which is one definition of a tensor.)
12:43:50 <roconnor> dmwit: alternative names I've though of (well arguably ski though of)are CrossProduct and simply Cross
12:44:15 <roconnor> dmwit: Tensor also seem reasonable.
12:44:16 <dmwit> CrossProduct sounds to Set-y to me.
12:44:20 <dmwit> s/to/too/
12:44:24 <kallisti> kaitocracy: yeah then you can't reliably write to stdin, I would think. if there's no library interface for it.
12:44:36 <kallisti> kaitocracy: what kind of file format?
12:44:51 <dmwit> You have to be careful that you don't imply that you have the other product operations (notably diagonal).
12:44:52 <roconnor> dmwit: is a symetric lens simply an isomorphism?
12:45:05 <dmwit> roconnor: Not quite; you get an existentially quantified state on the side.
12:45:09 <roconnor> dmwit: exactly; (&&&) doesn't fit on lenses
12:45:17 <roconnor> dmwit: ?
12:45:28 <roconnor> can you write out a type for symetric lenses?
12:45:37 <dmwit> roconnor: For people who understand asymmetric lenses, the ten-second explanation is that an asymmetric lens can "lose information" only going from source to view; symmetric lenses may lose information in both directions.
12:45:46 <dmwit> (But store it in a complement off to the side that's not user-visible.)
12:45:55 <roconnor> dmwit: I see
12:46:01 <dmwit> let's see...
12:46:05 <causative> ClaudiusMaximus, thanks but I was thinking of something more like the actor model + dynamic compilation
12:46:31 <dmwit> type Lens a b = exists c. ((a,c) -> (b,c), (b,c) -> (a,c)) + some laws of course
12:46:48 <roconnor> okay, your ten-second explanation helped
12:46:49 <dmwit> err
12:47:14 <dmwit> needs an extra "c" in there to "start the pump" so to speak
12:47:26 <dmwit> exists c. (c, (a,c) -> (b,c), (b,c) -> (a,c))
12:47:33 <roconnor> Okay, so what are good names for the typeclass for (***) (excluding Arrows) and (&&&) (excluding Arrows).
12:47:42 <elliott> Starry, Andy
12:47:42 <dmwit> ah...
12:47:44 <dmwit> :t (&&&)
12:47:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:48:00 <dmwit> I suppose (&&&) implies a real product.
12:48:00 <roconnor> presumably (&&&) inherits from (***) which interhets from Cat
12:48:03 <kallisti> kaitocracy: it would be nice if HDBC came with a Reader interface but it doesn't..
12:48:05 <dmwit> So Tensor and Product, maybe?
12:48:17 <roconnor> since (&&&) needs (***) for its laws and (***) needs (.) for its laws
12:48:26 <roconnor> dmwit: I'm okay with that
12:48:31 <dmwit> You might want to say TensorProduct, though, since there's a reasonable TensorSum as well that looks a bit like either.
12:48:37 * hackagebot strict-io 0.2.1 - A library wrapping standard IO modules to provide strict IO.  http://hackage.haskell.org/package/strict-io-0.2.1 (NicolasPouillard)
12:48:40 <kallisti> kaitocracy: takusen uses a monadic interface. so I think for my next DB project I'll try it out.
12:48:49 <dmwit> ?hoogle a b c -> a d e -> a (Either b d) (Either c e)
12:48:49 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
12:48:53 <roconnor> dmwit: I can probably put both classes in the same module called "Data.Category.Product"
12:48:56 <dmwit> ...that looks like that one
12:49:05 <dmwit> Ah, yeah, that sounds reasonable.
12:49:17 <roconnor> dmwit: what sounds reasonable
12:49:26 <dmwit> Putting them both in a module that has Product in the name.
12:49:33 <dmwit> Then "Tensor" alone is perfectly descriptive.
12:49:36 <roconnor> :)
12:49:53 <elliott> roconnor: just checking, does bifunctors not have what you want?
12:50:01 <roconnor> elliott: is it Haskell 98?
12:50:23 <elliott> roconnor: It's edwardk, so probably?
12:50:24 <elliott> Yes, it is.
12:50:32 <roconnor> elliott: I don't belive you; link?
12:50:34 <dmwit> The funny thing about "products" in the lens world is that not only do you ask the usual diagrams to commute, but you also have on the side a mapping from objects in your lens category to objects in Set, and you ask that the mapping preserve products.
12:50:36 <edwardk> ?
12:50:40 <elliott> roconnor: http://hackage.haskell.org/package/bifunctors
12:50:46 <edwardk> what are you looking for?
12:50:48 <elliott> It says "Haskell 98" right there.
12:50:51 * edwardk looks up
12:50:59 <roconnor> elliott: so it is
12:51:01 <elliott> edwardk: roconnor is putting (***) and (&&&) with some laws in typeclasses
12:51:13 <dmwit> Bifunctors are not quite the same as a functor from C x C to C.
12:51:16 <edwardk> (***) is just bimap, and is perfectly haskell 98 and is in bifunctors
12:51:25 <edwardk> (&&&) would be a subclass
12:51:57 <LambdaDusk> hi, how can I do an HTTPS POST request in Haskell?
12:52:01 <dmwit> :t (***)
12:52:01 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:52:18 <dmwit> bimap doesn't look like (***) to me. bimap specializes the arguments to (->)
12:52:22 <edwardk> but ultimately lenses fail lots of the usual laws you'd want to apply
12:52:27 <roconnor> elliott: no wait, bifunctors isn't abstract over the category
12:52:31 <elliott> oh, right
12:52:42 <edwardk> dmwit: correct
12:53:08 <kallisti> lambdabot: you may be interested in the HTTP package. docs are on hackage.
12:53:11 <kallisti> ...um
12:53:13 <kallisti> LambdaDusk: ^
12:53:13 <edwardk> the version in bifunctors is specialized to (->) the version in categories is the more general construction, but can't be 98 because its polymorphic in both the category and the functor
12:53:23 <roconnor> edwardk: right
12:53:31 <edwardk> if you need to go through and make a weaker arrow-like (&&&) in order to remain 98, knock yourself
12:53:36 <edwardk> er knock yourself out ;)
12:53:42 <roconnor> so I want to flips side, abstract over the category, but concrete on the (,) product
12:53:47 <LambdaDusk> kallisti: I've tried HTTP and got "https not supported"
12:53:51 <elliott> LambdaDusk: http-conduit is nicer than HTTP
12:53:51 <edwardk> yeah
12:53:56 <elliott> but i don't know if it does https. i think it might
12:53:59 <edwardk> in that case i have nothing that can help you
12:54:02 <elliott> it depends on tls
12:54:05 <edwardk> so feel free to build it right into lens
12:54:06 <elliott> so I hope so
12:54:08 <roconnor> edwardk: thanks for your input
12:54:14 <roconnor> final question
12:54:22 <elliott> roconnor: do you really need a typeclass?
12:54:24 <elliott> just curious
12:54:37 <roconnor> elliott: I have lenses, partial lenses, and coming soon, multilenses
12:54:42 <dmwit> (Though bifunctor seems like a fine name to me, too, if you want to use that instead of tensor.)
12:54:48 <elliott> roconnor: ah, right
12:54:58 <edwardk> tensor is pretty good
12:55:13 <edwardk> and avoids conflicts
12:55:16 <gzmask> byorgey: what's the difference between data String = String [Char] and type String = [Char] ? is that data String = String [Char] more expensive or can't not be pattern matched like the type synonym form?
12:55:45 <kallisti> firstly data String = [Char]  is not possible
12:55:55 <roconnor> Last question: on a scale of Don't do it to Acceptable Hack for Now, how bad is it to put a module named Control.Category.Product in a package calle data-lens?
12:56:00 <elliott> gzmask: in the latter, String is just an alias for [Char]
12:56:04 <elliott> you can use all list functions on it, etc.
12:56:06 <dmwit> gzmask: You might think "data String = String [Char]" is isomorphic to "[Char]", since you can write "from (String s) = s" and "to s = String s".
12:56:07 <edwardk> gzmask: data String = String [Char] has an extra 'box' around it. newtype String = String [Char] is more comparable to type String = [Char] in terms of runtime overhead (0)
12:56:14 <newtrekemotion> hi everyone, I'm having a bit of an issue with figuring out some RPC stuff. Basically I want clients to be able to register on a server and the server keep a table of the clients. I've been trying to use haxr from hackage.
12:56:14 <elliott> in the former, String is an entirely new data type.
12:56:18 <elliott> it just happens to contain a single field, a [Char].
12:56:27 <dmwit> gzmask: But "data String = String [Char]" has an extra value: "String undefined". This value has no corresponding value in the type "[Char]".
12:56:40 <edwardk> gzmask: but then the second problem with making String a full data type is you can't just use the sugar we know for lists to pattern match on it
12:56:45 <kallisti> gzmask: oh, my mistake.
12:57:24 <dmwit> You might alternately view "undefined" as the extra value. Both "from undefined" and "from (String undefined)" are "undefined".
12:58:02 <dmwit> roconnor: I struggled with that kind of question myself.
12:58:18 <dmwit> roconnor: I was just asking earlier today if there was a canonical package providing the Iso data type.
12:58:22 <elliott> roconnor: well you're adding things to the categories support for haskell
12:58:24 <elliott> roconnor: so
12:58:26 <elliott> roconnor: how about category-extras?
12:58:28 <yasar> Can I derive show instance for Data constructors?
12:58:31 <elliott> :D
12:58:31 <dmwit> Seems every package that needs isomorphisms just reinvents them from scratch. =(
12:58:36 <elliott> that would be the *perfect* name
12:58:38 <kallisti> gzmask: defining type aliases is a pretty common feature of statically typed languages.
12:58:51 <roconnor> elliott: I don't think it is taken, so okay.
12:59:41 <edwardk> dmwit: want me to just go make one?
12:59:55 <kallisti> gzmask: another common feature is the ability to define complex data types from simpler data types. These are very different semantically. Perhaps you're confused because type and data declarations look very similar.
13:00:20 <dmwit> edwardk: Sure!
13:00:30 <dmwit> edwardk: I'll file bug reports against all the packages that don't depend on it. =D
13:00:31 <roconnor> edwardk: and make dmwit the maintainer
13:00:38 <dmwit> ... lol
13:00:38 <edwardk> muahahaha
13:00:46 <dolio> Call it 'iso'
13:01:04 <dolio> That way you conflict with people writing stuff to manipulate CD images.
13:01:09 <edwardk> hah
13:01:26 <edwardk> well, i was leaning towards isomorphisms or morphisms depending on if i wanted to leave the door open to adding more stuff
13:02:12 <edwardk> oh, i do have it
13:02:13 <edwardk> http://hackage.haskell.org/packages/archive/groupoids/0.1.1.2/doc/html/Data-Groupoid-Isomorphism.html
13:02:37 <dmwit> Wunderbar!
13:02:58 <edwardk> it really should just be a Data.Isomorphism
13:03:04 <edwardk> i'll rename that module
13:03:08 <edwardk> but keep it in that package
13:03:31 <dmwit> "Safe-Infered" is bothering me
13:03:35 <kallisti> elliott: I was considering using http-conduit until I saw this:
13:03:37 <kallisti> Accept-Encoding (not currently set, but client usage of this variable will cause breakage).
13:03:38 <dmwit> Is that haddock's fault?
13:03:44 <kallisti> elliott: I really need to be able to set that.
13:04:12 <dolio> Stand by for 78 package releases.
13:04:13 <roconnor> dmwit: if it only has safe dependencies and is safe, doesn't that make it safe infered?
13:04:20 <edwardk> dolio: *groan*
13:04:22 <elliott> kallisti: are you sure?
13:04:31 <kallisti> positive.
13:04:32 <dmwit> roconnor: I think it's spelled "inferred".
13:04:32 <elliott> you can still set all the other Accept headers
13:04:35 <elliott> just not Accept-Encoding.
13:04:45 <kallisti> elliott: oh.. wait.
13:04:47 <roconnor> edwardk: I didn't realize you had so many Haskell 98 packages
13:04:51 <kallisti> yeah I don't need Accept-Encoding
13:05:00 <elliott> roconnor: they started being 98 when category-extras exploded
13:05:02 <elliott> :
13:05:02 <elliott> :p
13:05:14 <edwardk> roconnor: i tried to keep the core 98
13:05:19 <roconnor> elliott: I think that is partly due to my prodding; I didn't think it was so extensive though.
13:05:24 <edwardk> its only the crazy stuff on top that needs lots of extensions
13:05:47 <edwardk> ok, groupoids 0.2 released
13:06:10 <roconnor> edwardk: what are the new features?
13:06:14 <elliott> if only standard Haskell wasn't so terrible
13:06:20 <edwardk> Data.Groupoid.Isomorphism renamed to Data.Isomorphism
13:06:30 <roconnor> edwardk: I don't think it is *so* terrible
13:06:33 <roconnor> opps
13:06:36 <roconnor> elliott: ^^
13:07:29 <elliott> roconnor: did you know that this isn't valid haskell? class C a where x :: (D a) => r
13:07:32 <elliott> erm
13:07:35 <elliott> roconnor: did you know that this isn't valid haskell? class C a where x :: (D a) => a -> () say
13:07:48 <elliott> you're not allowed to constrain variables from the head in a member
13:07:50 <elliott> I have no idea why
13:08:15 <roconnor> elliott: I wasn't aware of that; seems vague reasonable though.
13:08:18 <znhxr> does that even make sense?
13:08:18 <edwardk> complicates the type checker
13:08:37 * hackagebot groupoids 0.2 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-0.2 (EdwardKmett)
13:08:39 <kallisti> elliott: I'm not sure I would get anything out of switching to http-conduit though
13:08:46 <hpc> it's because you can't define x for all a
13:08:53 <kallisti> unless I can somehow get constant memory usage while parsing JSON via Aeson.
13:08:57 <elliott> it's still weird :P
13:08:58 <hpc> imagine a was in C but not D
13:08:59 <znhxr> I mean, isn't it equivalent to class (D a) => C a where x :: a -> ()?
13:09:15 <edwardk> znhxr: not always
13:09:23 <znhxr> why not?
13:09:25 <edwardk> znhxr: because that may incur type checking cycles that this won't
13:09:34 <edwardk> and not every method may have that extra D constraint
13:09:40 <znhxr> I don't see it
13:09:46 <zeta-> cabal update fails;
13:09:47 <zeta-> cabal: Failed to download http://www.haskell.org/00-index.tar.gz : ErrorMisc
13:09:49 <zeta-> "Unsucessful HTTP code: 404"
13:09:50 <edwardk> this allows you to have the C instance always, but have some other methods that only work when you also have a D instance
13:09:51 <zeta-> ???
13:10:12 <znhxr> edwardk: that's not how I understand it
13:10:37 <edwardk> znhxr: trust me on this one. =) there are some cases with constraint kinds where the ONLY way to state something that works is to carry around a witness member like that
13:10:49 <gzmask> thanks for the clarifications folks. I am kinda running slow in the brain to digest so much in just couple of days since I started haskell. I think I kind of got it, but for now I will replace type synonyms with list/tuple of 'data' for easier understanding whenever I see it .
13:10:58 <znhxr> edwardk: if it isn't valid haskell, how can it work?
13:11:15 <edwardk> its not valid haskell _98_, its fine with extensions
13:11:16 <luite> zeta-: do you have the correct remote-repo line in your ~/.cabal/config?  remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
13:11:29 <edwardk> haskell 98 is alarmingly restrictive about a lot of things
13:11:33 <hpc> i would rather have class C a, D a => E a where x :: a -> ()
13:11:36 <dmwit> edwardk++
13:11:55 <dmwit> That's what the PVP is for!
13:12:07 <hpc> having a type class where some methods magically aren't defined is questionable to me
13:12:17 <edwardk> @hpaste
13:12:17 <lambdabot> Haskell pastebin: http://hpaste.org/
13:12:44 <znhxr> hpc: prezactly
13:13:19 <hpaste> edwardk pasted “see 'both'” at http://hpaste.org/66238
13:13:43 <hpc> even if it fails at compile-time, it looks ridiculous and anti-modular
13:13:44 <elliott> dmwit: (What's the ++ for?)
13:13:46 <gzmask> dmwit++ kallisti++ elliott++ edwardk++ byorgey++
13:13:50 <yasar> say I have a data type Expr, how can I make show instance for (Expr -> Expr -> Expr)
13:13:54 <elliott> yaaaaay
13:13:56 <plat0> Is there a decent textmode irc client in haskell?
13:14:00 <elliott> gzmask++
13:14:14 <yasar> It says Illegal instance declaration for `Show (Expr -> Expr -> Expr)'
13:14:15 <hpc> yasar: first, make a gun, then shoot your foot with it
13:14:25 <gzmask> I heard that ++ is a tradition for haskell IRC channel
13:14:28 <dmwit> elliott: For fixing the name of Data.Isomorphism just because it was wrong and saying "screw you" to backwards compatibility.
13:14:34 <hpc> yasar: also see the GHC manual section on type class extensions
13:14:50 <kallisti> elliott: I feel like a better person now that this arbitrary virtual score has incremented
13:14:54 <dmwit> It's a scary thing to do, even when you don't think you have users. =)
13:15:01 <yasar> Does that mean it's something non-trivial?
13:15:08 <znhxr> preflex: karma kallisti
13:15:08 <preflex>  kallisti: 3
13:15:35 <hpc> yasar: more that it's scary and you probably don't want it :P
13:16:16 <elliott> huh?
13:16:20 <elliott> FlexibleInstances is ok
13:16:45 <dmwit> FlexibleInstances can be a bit frustrating.
13:16:58 <xplat> > let thisǀcaseǀworksǃ = 1 in thisǀcaseǀworksǃ
13:16:59 <lambdabot>   1
13:17:03 <dmwit> Usually the ~ version is much better.
13:17:09 <kallisti> FlexibleInstances is fine, I would just be wary of Show instances for functions.
13:17:12 <zeta-> luite: cabal-src:http://www.haskell.org/
13:17:22 <dmwit> e.g. instance (a ~ Expr, b ~ Expr -> Expr) => Show (a -> b)
13:20:35 <ion> There’s a latin letter dental click? :-D
13:21:06 <znhxr> ǀ.ǀ
13:21:35 * znhxr hits ion with a CANADIAN SYLLABICS CARRIER DENTAL S
13:37:07 <xplat> dmwit: isn't that much more vulnerable to overlapping?
13:39:16 <kallisti> hm, keep-alive could be useful to me.
13:39:34 <kallisti> I think I'll switch to http-conduit in a later release. I need to get a first release. :P
13:44:28 <kallisti> would it be possible to stream data to Aeson with constant memory usage?
13:44:46 <kallisti> maybe with attoparsec-conduit?
13:45:15 <kallisti> aha, yes I think I can use sinkParser
13:45:44 <kallisti> that would be gravy.
13:46:46 <dmwit> xplat: Yes, definitely.
13:46:50 <dmwit> xplat: It doesn't always work.
13:47:08 <dmwit> xplat: But when it does, you need way, way fewer type annotations in code using those instances.
13:48:41 * hackagebot eq 0.3.4.3 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.4.3 (EdwardKmett)
13:51:36 <edwardk> dmwit: it should be propagated through everything now
13:53:45 * hackagebot semigroupoid-extras 0.2.6.2 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.6.2 (EdwardKmett)
13:57:49 <dmwit> \o/
13:58:47 * hackagebot profunctor-extras 0.3.1.6 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.3.1.6 (EdwardKmett)
14:01:43 <c_wraith> where are the amateur functors?
14:03:57 <hpc> c_wraith: the ones that don't understand monads
14:05:26 <alpounet> oh, it's the edwark package dance again yay
14:06:25 * Botje shifts one seat to the left
14:08:48 <elliott> edwardk: do you have a program to automatically propagate dependency updates?
14:08:53 <edwardk> nope
14:08:59 <elliott> you need one :P
14:09:02 <edwardk> i agree
14:09:08 <edwardk> bit its hard to cover all the special cases
14:10:07 <dmwit> Well, he has a dependency graph, at least.
14:10:16 <edwardk> dmwit: for part of it
14:10:25 <edwardk> you refused to do the whole kit and kaboodle ;)
14:10:36 <dmwit> Oh, right.
14:10:41 <edwardk> my dependency graph is that i keep all my packages in my haskell folder
14:10:53 <edwardk> and when i update a package i grep for it in */*.cabal
14:11:22 <elliott> edwardk: how many disks do you have backing that folder?
14:11:29 <elliott> gotta be a few petabytes
14:11:48 <edwardk> heh, most of that is up on github =)
14:13:15 <thoughtpolice> i thought i had a lot of github repos, but edwardk easily doubles me :P
14:13:29 <Enigmagic> edwardk: are you just looking for version range errors or do you build all the packages too?
14:13:44 <edwardk> i build everything as i go to make sure i can get a consistent repo
14:14:03 <edwardk> then i usually flush my cabal folder and pull from hackage once and make sure i can build something at the top of te food chain like trifecta or kan-extensions
14:14:13 <eacameron> so I'm back to this liftM thing I keep pondering (i'm a noob if it hasn't already been obvious)...I'm doing some monadic operating in ghci (which is already in a monad, no?), but I don't want to have to write all my repl commands within "do" blocks. Can I just take monadic commands that I'm running and "merge" them into the repl monad? Is that what liftM does???
14:14:22 <Enigmagic> edwardk: it's not really ready for wide consumption but i hacked a little thing into our build engine that will build a whole tree of *.cabal files in the correct order
14:14:25 <Enigmagic> edwardk: https://github.com/alphaHeavy/shake-install
14:14:36 <edwardk> Enigmagic: bookmarked
14:14:50 <dcoutts> btw, remember that a cheap and cheerful way is to use: cabal install dir1/ dir2/ etc
14:15:01 <Enigmagic> edwardk: just go to the root directory and run "shake build --recursive"
14:15:18 <dcoutts> or foo/foo.cabal, or blah.tar.gz
14:15:30 <Enigmagic> or "shake build --recursive -j4" :)
14:15:35 <Enigmagic> for parallel
14:15:43 <edwardk> fixing up 'categories' while i'm at this, damn you dmwit ;)
14:16:05 <dmwit> eacameron: You can think of ghci as being in a top-level IO block, yes. Not just any monad, though.
14:16:37 <dmwit> I'm not sure I understood the comment about writing all your repl commands within do blocks, nor the question about merging.
14:17:01 <dmwit> edwardk: Hey man, I didn't ask you to change the name!
14:17:04 <dmwit> =P
14:17:16 <edwardk> dmwit: well, mostly just for making me think categorically
14:17:21 <gzmask> in http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures , do I need to define 'Cons/:-:' function, or it's automatically known by haskell that it's a concatenation operation?
14:17:31 <monochrom> the question pattern "what did you input, what was the output, what output do you want instead" is very powerful. use it.
14:18:03 <dmwit> gzmask: The declaration "data List a = Nil | Cons a (List a)" defines Cons.
14:18:13 <edwardk> i needed to fix this stuff up anyways, since spj wants to change the way type level operator variable bindings work, so i might as well future proof myself
14:18:16 <dmwit> gzmask: Similarly for the later one involving :-:.
14:18:16 <eacameron> dmwit: I figured i was being confusing :( so within the ghci repl (top-level IO monad, as you said), I'll something like "let contents = downloadWebPage" which gives me "contents :: IO ByteString"
14:18:35 <eacameron> but now if I want to work with "contents", I have to do it all in a monad WITHIN the top-level monad
14:18:46 <dmwit> eacameron: Just write "contents <- downloadWebPage" instead.
14:19:02 <eacameron> dmwit: why didn't I ever think of that??
14:19:25 <eacameron> dmwit: so I guess that's not what liftM is for then! crap! I still don't understand liftM!
14:19:32 <luite> Enigmagic: cool! what are its limitations?
14:20:52 <monochrom> liftM is for "n <- liftM length getLine". now n is the length of user's input, and you have also lost the details of user's input, you only have its length
14:21:10 <luite> Enigmagic: I work on Yesod sometimes, which is basically 4 git repo's with lots of packages. changing a single file can cause a lot of packages to be reinstalled, does it automatically do that?
14:21:22 <eacameron> monochrom: ahh, so it pulls pure functions into monad world?
14:21:38 <monochrom> of course, a more information-preserving use is "s <- liftM reverse getLine". now s is user's input, complete, but reversed
14:21:43 <monochrom> yes
14:22:12 <eacameron> monochrom: I saw the light!
14:22:14 <gdoteof> http://hpaste.org/66241
14:22:32 <Eridius> liftM is fmap for Monads
14:22:46 <Enigmagic> luite: it doesn't install to the user cabal database, it puts everything in ./build
14:22:48 <gzmask> dmwit: hmmm, it is not very obvious how does Cons function got defined there? Isn't that it needs a '=' for function definition?
14:22:52 <gdoteof> i am getting an error there on line 14 .   Expected type: [Int] -> [Int] -> [Int]
14:22:52 <dmwit> Eridius: Helpful iff one first understands what fmap is for.
14:22:52 <monochrom> it uses one line to replace two lines: "pre's <- getLine; let s = reverse pre's". if you don't care about pre's, using liftM saves some code
14:22:55 <gdoteof>       Actual type: [Int] -> [[Int]] -> [Int]
14:22:57 <gdoteof> sry for double post
14:22:59 <Eridius> dmwit: true
14:23:11 <dmwit> gzmask: There *is* an =. =)
14:23:25 <dmwit> gzmask: data List a = {- right here! -} Nil | Cons a (List a)
14:23:37 <Enigmagic> luite: but it will track dependencies between packages and build them in order (and in parallel)
14:23:42 <dmwit> gzmask: Anyway, Cons isn't a function in the traditional sense.
14:23:52 <Botje> gdoteof: can you annotate your paste with the error? that way we don't have to switch between here and there
14:23:59 <luite> Enigmagic: and it will also reuse compiled files from prev runs?
14:24:05 <Enigmagic> luite: yes
14:24:10 <luite> Enigmagic: great
14:24:13 <gdoteof> Botje: ya one sec
14:24:18 <dmwit> gzmask: Or rather, it is a function, but it's also even more special than a function. It's a constructor.
14:24:48 <hpc> @hoogle [a] -> [a] -> [a]
14:24:48 <Enigmagic> luite: we use a slightly different variant (using files called Shakefile.hs that describe child directories and .cabal files to build) so i haven't really tested the --recursive option much
14:24:48 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
14:24:49 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
14:24:49 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
14:24:51 <hpaste> gdoteof annotated “1.hs” with “1.hs (annotation)” at http://hpaste.org/66241#a66242
14:24:56 <dmwit> gzmask: The declaration "data List a = Nil | Cons a (List a)" says: there are two kinds of lists. "Nil" is one of the two kinds. All other lists are of the form "Cons x xs" where "x" is an "a" and "xs" is a "List a".
14:25:01 <hpc> @hoogle a -> [a] -> [a]
14:25:01 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:25:01 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:25:02 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:25:20 <gdoteof> Botje: does it make sense what i am trying to do there?
14:25:23 <Botje> gdoteof: a ++ head b sounds suspicious
14:25:36 <dmwit> gzmask: You can think of "Nil" and "Cons" as being brand new constants introduced by the "data" declaration.
14:26:01 <Botje> especially since b = [newSeat] :: [Int]
14:26:10 <Botje> didn't you just want a ++ b ?
14:26:15 <gzmask> dmwit: I see. It still appears to me that Cons got defined without a '='
14:26:29 <dmwit> gzmask: Where your language used to have constants like 0, 1, 2, ..., True, False, now it has all those constants plus two new ones named Nil and Cons.
14:26:37 <luite> Enigmagic: ah, yesod has some scripts (was bash, now haskell shelly) to build the packages, but they are hacks, really, and no parallel builds. using shake sounds like a much better idea
14:26:51 <dmwit> gzmask: You may be getting confused because you're used to functions "doing something" -- performing some computation.
14:27:05 <dmwit> gzmask: The "Cons" "function" doesn't do any computation. It's just a constant.
14:27:10 <gdoteof> Botje: uhhh it looks like maybe i did.  i had that head in there because i was having problems combining an int to a [int] so i cast it as an [int] and just took the 'head'
14:27:17 <dmwit> "Cons x xs" doesn't reduce at all.
14:28:07 <gzmask> dmwit: can I use lambda function to replace 'Cons' there? like '\ x xs'
14:28:15 <dmwit> gzmask: Nope!
14:28:22 <Enigmagic> luite: well go kick the tires a bit, i don't have time right now to work on features for it but i'll accept pull requests
14:28:25 <dcoutts> Enigmagic: how is it building each individual package, is that via shake or by calling cabal?
14:28:27 <dmwit> gzmask: Cons is a brand new constant that doesn't behave like any of the other constants that used to exist in the language.
14:28:51 <dmwit> gzmask: Just like you can't replace "0" with some other value that behaves like 0.
14:29:11 <Enigmagic> dcoutts: it uses Cabal unless there is a requirement TemplateHaskell (Cabal doesn't let me set the cwd or environment) or Custom build
14:29:22 <Enigmagic> in which case it falls back on using cabal-install
14:29:34 <luite> Enigmagic: ok, I'm not sure how much time I have to work on those features myself, but I'd really love to have parallel builds to speed up installing all yesod packages when testing changes
14:29:55 <dcoutts> Enigmagic: oh you mean it uses the Cabal lib directly
14:30:00 <Enigmagic> dcoutts: yes
14:30:10 <hpaste> gdoteof annotated “1.hs” with “1.hs (annotation) (annotation)” at http://hpaste.org/66241#a66243
14:30:29 <gzmask> dmwit: It sounds like a new rule for me. So the haskell compiler knows that when there is a new word 'Cons' there, the right hand side is going to be some sort of definition for it, right?
14:30:51 <gdoteof> that annotation is bad
14:30:52 <dcoutts> Enigmagic: so what it adds over "cabal install ./foo ./bar"  is parallel builds, and that you can configure a list of projects in a file, rather than listing them on the command line all the time (plus using a local db and install location by default)
14:31:16 <dcoutts> Enigmagic: have I got that right? anything else?
14:31:28 <dmwit> gzmask: No, the compiler doesn't know about Cons; it knows about the "data" keyword.
14:31:39 <dmwit> gzmask: When it sees a "data" keyword, it knows you're about to define some new constants.
14:31:47 <gdoteof> http://hpaste.org/66244
14:31:49 <Botje> gdoteof: ah, the dreaded DMR.
14:31:59 <dmwit> gzmask: (And a new type constant, too! Here, that new type constant is "List".)
14:32:00 <gdoteof> DMR?
14:32:05 <Enigmagic> dcoutts: for our haskell code, yes. it's a large number of files that describe the tree structure though, not one top level file
14:32:24 <Botje> gdoteof: can you verify the types of  t1Seats and t2Seates
14:32:27 <Enigmagic> dcoutts: it also builds non-haskell code (that part isn't checked in to the public repo)
14:32:42 <gzmask> dmwit: I finally get it, lol, thanks!
14:32:45 <gzmask> dmwit++
14:32:59 <dcoutts> Enigmagic: ok, I'm just wondering as it helps us to prioritise feature work
14:33:11 <Botje> gdoteof: I'm guessing they're [Integer] instead of [Int], as you expected
14:33:15 <gdoteof> Botje: yep: [Integer]
14:33:30 <Botje> yeah, haskell doesn't do automatic type promotion
14:33:34 <m_hawke> I'd like some sort of Traversable instance for Data.Tree, except that I'd like to be able to use the information in the nodes; is there a standard way of doing this?
14:33:35 <Botje> just stick a type annotation in there
14:33:41 <Botje> t1Seats, t2Seats :: [Int]
14:33:43 <Botje> should fix you up
14:33:50 <osager> hi all i'm using eclipse ide, by default i can not import any system packages, such as System.Directory, saying that it can not find the packages in the path
14:33:51 <gzmask> dmwit: the BNF thing I learned from my CS degree 5 years ago kicks in...
14:33:58 <osager> where shall i set the path ?
14:34:09 <dmwit> gzmask: =)
14:34:17 <Enigmagic> dcoutts: the other thing we do is want a centrally configured build directory that doesn't touch the user or global package databases. so at the root you can say "shake configure" and give it builddir root that is used for all packages
14:34:26 <dcoutts> Enigmagic: sure
14:34:44 <Enigmagic> dcoutts: so builds will go into ./build/package1/ ./build/package2 etc and share a single package database called ./build/package.conf.d
14:35:17 <dmwit> osager: Dunno for sure, but "ghc-pkg list" will print the location of the package database, if that helps.
14:35:17 <dcoutts> Enigmagic: and I presume if you wanted to, you could do several such separate builds without writing anything into the source trees
14:35:35 <dcoutts> Enigmagic: so this relies on the cabal --package-db and --build-dir right?
14:35:39 <gdoteof> Botje++
14:36:24 <Botje> gdoteof: if you ever directly use those variables in combination with addSeated, ghci will notice
14:36:36 <Enigmagic> dcoutts: sorta yea, the api equivalent though
14:36:54 <dcoutts> right
14:37:06 <Enigmagic> dcoutts: except for ghc-pkg which gets called directly https://github.com/alphaHeavy/shake-install/blob/master/Development/Shake/Install/Rules.hs#L281
14:38:07 <dcoutts> Enigmagic: any particular reason? cabal can register into the target db
14:38:25 <Enigmagic> dcoutts: i found that it was faster
14:38:32 <Enigmagic> but could be wrong
14:38:35 <dcoutts> it doesn't look like you're doing anything special
14:38:49 <dcoutts> faster? hmm, I'm surprised
14:40:03 <Enigmagic> maybe i was doing something wrong but the registration step had to be serialized to prevent the cache from being corrupted
14:40:17 <Enigmagic> and ghc-pkg was faster
14:43:00 <dcoutts> Enigmagic: still surprising, since the only difference I can think of is that you're getting Cabal lib to write the package reg to a file and calling ghc-pkg, where as the usual path Cabal lib calls ghc-pkg and pipes the package reg over
14:43:12 <dcoutts> both should be the same, and quick
14:43:28 <dcoutts> but yes, registration step does need to be serialised
14:44:37 <Enigmagic> dcoutts: either way it would be easy to change, i did all that work back for the waf (python) based build system and haven't revisited it since we migrated to shake
14:45:42 <osager> thanks dmwit
14:58:05 <edwardk> dmwit: categories is now a lot cleaner
14:58:47 * hackagebot categories 1.0 - Categories  http://hackage.haskell.org/package/categories-1.0 (EdwardKmett)
15:05:57 <dmwit> edwardk: Oh, really? Huh, what's cleaner?
15:06:10 <elliott> the version number
15:06:12 <edwardk> Monoidal and "Comonoidal" mashed together, Associative and Disassociative
15:06:17 <elliott> compare: 0.59, 1.0
15:06:26 <edwardk> default definitions for first and second
15:06:41 <edwardk> removed PreCartesan/PreCoCartesian
15:07:20 <edwardk> removed all the uses of operators in type variabe binding position, so it can be compatible when SPJ takes those away from us
15:07:46 <dmwit> Wait, what?
15:08:12 <dmwit> I won't be able to do "forall (~>). Arrow (~>) => (a ~> a)" any more? =(
15:08:31 <elliott> edwardk: spj is taking them away from us?
15:08:54 <edwardk> elliott: its ok, in exchange you'll get the ability to use any operator as a type name!
15:09:06 <edwardk> type (+) = Either, etc.
15:09:10 <danharaj> wait
15:09:11 <edwardk> rather than the :+ mess
15:09:12 <elliott> edwardk: huh? is that backed up by the standard?
15:09:18 <danharaj> that's amazing.
15:09:26 <elliott> i mean it is. but it doesn't sound standard.
15:09:32 <dmwit> Oh boy, bifunctor isn't (->)-specialized any more!
15:09:36 <edwardk> elliott: type operators aren't in the standard, note these are type constructors, not data constructors
15:09:47 <elliott> well ok new question
15:09:48 <edwardk> dmwit: well, bifunctor is, but the one in categories isn't
15:09:51 <elliott> is "(Arrow (~>))" not standard?
15:09:55 <dmwit> oh, oh
15:10:02 <edwardk> elliott: that is the one casualty
15:10:07 <elliott> but is it standard!
15:10:09 <dolio> No it is not standard.
15:10:09 <edwardk> elliott: its a convention
15:10:17 <elliott> ok, thanks
15:10:21 <edwardk> like m for Monad and f for Functor
15:10:25 <elliott> um
15:10:27 <edwardk> but conventions can change ;)
15:10:29 <elliott> i meant is it standard to use operator names like that.
15:10:34 <edwardk> no
15:10:38 <elliott> standard as in permitted by the report
15:10:42 <edwardk> that is a {-# LANGUAGE TypeOperator #-}
15:10:45 <elliott> ah, ok
15:10:46 <dmwit> Oh, definitely no.
15:11:02 <edwardk> the behavior of that extensions is what is proposed to change
15:11:10 <mgsloan1> this probably won't be a popular suggestion.. but what about mixfix type operators?
15:11:12 <elliott> arrow really suffers from being unable to use an operator though
15:11:18 <mgsloan1> * type constructors
15:11:31 <mgsloan1> so that we can do "x * y * z" tuples
15:11:32 <elliott> can we do "forall (:~>). (Arrow (:~>)) => ..." in replacement? :P
15:11:50 <elliott> mgsloan1: You're a camel!
15:11:52 <edwardk> mgsloan1: good luck. implementation is the hard part and haskell has enough parsing problems with infix operators since you cant associate them properly til you're done parsing
15:12:01 <danharaj> It's weird that the types in an indexed comonad change contravariantly...
15:12:11 <edwardk> remember you can have fixitiy declarations after the definitions, and mixfix makes that pretty hard
15:12:22 <mgsloan1> elliott: :D I've actually never used Ocaml
15:12:28 <edwardk> danharaj: did you make your own?
15:12:42 <mgsloan1> just kinda like the parens-less tuples
15:12:53 <edwardk> danharaj: you can set up the polarity of it whichever way you want
15:13:10 <danharaj> edwardk: No, I'm just implementing various ones to get a feel for them. I'm following the convention of the indexed package.
15:13:22 <kaitocracy> I have a bit of code that looks like
15:13:32 <edwardk> but its interesting that you apparently cant have something that is simultaneously both an indexed monad and an indexed comonad, though you can often find a monad compatible with the indexed comonad and vice versa
15:13:32 <kaitocracy> liftM a $ liftM b $ liftM c mymonad
15:13:35 <kaitocracy> is there a way to improve that?
15:13:43 <dmwit> liftM (a . b . c) mymonad
15:13:49 <kaitocracy> ahh thanks
15:13:56 <elliott> kaitocracy: btw if you import Control.Applicative you can spell liftM as (<$>)
15:14:02 <kaitocracy> huh
15:14:11 <elliott> (not for all monads, for all instances of Applicative, but all monads should have an instance of that)
15:14:17 <kaitocracy> I see
15:14:17 <edwardk> elliott: yeah but it doesn't help much for the a . b . c example
15:14:26 <danharaj> edwardk: I have to wonder whether indexed monads are related to higher categories because they're modelled on categories the same way monads are modelled on monoids. And everyone knows a category is just a monoidoid.
15:14:27 <elliott> kaitocracy: this also lets you lift functions of multiple arguments: foo <$> bar <*> baz is do { x <- bar; y <- baz; return (foo x y) }
15:14:36 <elliott> edwardk: yeah, but while we're giving lifting tricks :P
15:14:48 <elliott> kaitocracy: which is very very handy, you'll likely see it all over the place reading code
15:14:48 <edwardk> danharaj: ddarius has a nice shpiel on how they are related
15:15:12 <elliott> Categories are just monoids in the category of oids.
15:15:13 <dmwit> kaitocracy: fmap f . fmap g = fmap (f . g) -- this is one of only two laws that functors must satisfy (when restricted to Hask)
15:15:19 <elliott> What's the problem?(TM)
15:15:28 <danharaj> edwardk: does he have a blog?
15:15:38 <edwardk> nah
15:15:50 <edwardk> he's usually on here, but he seems to have gone hermit for a while
15:15:53 <dolio> Not higher categories. Indexed categories.
15:16:07 <elliott> Has anyone founded a Haskell startup and/or band named Monoid in the Category of Endofunctors yet?
15:23:49 * hackagebot algebra 2.1 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.1 (EdwardKmett)
15:39:52 <mojo_> hi all`
15:45:53 <yan_> are there a few projects that are accepted to be written "well" that one can use to get a feel for haskell used in a real, medium-sized project?
15:46:21 <hpaste> lifestream pasted “doubleEveryOther needs a list from toDigits!” at http://hpaste.org/66250
15:46:27 <lifestream> Could you please look at my code, I'm still where I was yesterday, I need to pass the list from toDigits into doubleEveryOther. (Exercise assumes we are up to chapter 2 of RWH and LYAH). Atleast I assume the teacher wants us to pass the list from toDigits to doubleEveryOther! I know I'm dumb (health condition ruined brain) but I've been at it for 2 days now and that's all I have to show... doubleEveryOther must be [Integer] -> [Integer]
15:46:59 <tazjin> yan_: Quite a few, I think. What kind of project?
15:47:23 <tazjin> yan_: e.g. Xmonad (a window manager) or the Yesod web framework
15:47:26 <yan_> tazjin: anything really. i looked at xmonad and ghc briefly.. ghc is a bit larger than the scope i'm looking for, but interesting nonetheless
15:48:01 <yan_> tazjin: i saw yesod, snap and happstack as frameworks.. are any of them more 'mature' than others?
15:48:58 <tazjin> yan_: Yesod > Happstack > Snap in terms of maturity, I'd say. Though some would probably put Happstack on a level with Yesod
15:49:39 <dmwit> lifestream: That code looks good. What's the question?
15:49:45 <elliott> Is Yesod not newer than Snap, and Snap much newer than Happstack?
15:49:58 <elliott> OK, age =/= maturity, but Happstack has been around in various forms for a looong time by now.
15:50:26 <lifestream> Hi dmwit, doubleEveryOther should take the list created by toDigitsRev
15:50:41 <lifestream> And I can't figure out how to do that
15:50:53 <dmwit> Just... call it.
15:51:05 <dmwit> doubleEveryOther (toDigits 30005)
15:51:20 <tazjin> elliott: Yes, Yesod and Happstack are both really nice frameworks. I think it's hard to objectively judge code quality though
15:51:22 <lifestream> dmwit: but then I would have to hard code that number in my source file, rather than it being user input
15:51:34 <dmwit> Oh, so the question is really about user input, then?
15:51:49 <elliott> lifestream: What do you mean by input?
15:51:52 <elliott> Do you just mean input in GHCi?
15:51:56 <elliott> Or do you want to write a standalone program?
15:51:59 <dmwit> Yeah, that was my next question.
15:54:02 <lifestream> elliott: dmwit, in ghci I loaded the source file then typed in:  toDigitsRev 123456.  I'm not sure, really, I think the professor wants us to pass the array created by toDigitsRev into doubleEveryOther? And I guess the credit card number would be different depending on the user of the program... so... I don't know.
15:54:16 <lifestream> (I'm not taking the class, I just found his lessons available on his web-site)
15:55:27 <elliott> Not array, list.
15:55:33 <dmwit> If you're just looking to write a function that does both toDigits and doubleEveryOther at once, write it. It's easy.
15:55:43 <lifestream> array, hahahaha :)
15:55:44 <dmwit> doBothAtOnce n = doubleEveryOther (toDigits n)
15:55:46 <lifestream> Sorry, I'
15:55:52 <lifestream> I'm so tired, been working at this so long.
15:56:29 <dmwit> If you're feeling fancy, you can write it as doBothAtOnce = doubleEveryOther . toDigits instead.
15:56:33 <dmwit> They mean the same thing.
15:57:26 <elliott> lifestream: Can you describe the exact behaviour you are trying to achieve?
15:57:31 <elliott> Without knowing what your problem is, it's hard to give a solution.
15:57:41 <lifestream> Ah, I wonder if that's what the professor expects, I was thinking something like that. I thought the "do everything" (that is, validate the credit card number) would come at the end when we finally implement main = ...
15:58:14 <dmwit> If you're doing this for yourself, don't worry so much about what the professor wants.
15:58:20 <dmwit> Figure out what you want, and we'll help you do that.
15:58:24 <lifestream> elliott: seen the paste? It has comments explaining.  http://hpaste.org/66250 and here's the exercise: http://www.cis.upenn.edu/~cis194/static/hw1.pdf
15:58:34 * elliott thinks lifestream might want to read a book like LYAH rather than $random_professor's web resources
15:58:46 <elliott> lifestream: Yes, I saw the paste.
15:58:50 <elliott> I still had the questions I asked after reading it.
15:59:06 <monochrom> the better profs recommend LYAH anyway
15:59:11 <dmwit> lifestream: The second document you pasted is very clear about what you're supposed to write.
15:59:30 <lifestream> Well I trust that the proffessor has a good reason for asking that the function be done like that (though I dont understand why he sets the function [Integer] -> [Integer], wouldn't [Int] be sufficient for a digit?  (And yes, the professor recomends ch 1 and 2 of both LYAH and RWH)
15:59:49 <dmwit> You've written toDigits and doubleEveryOther. Now write sumDigits and validate.
15:59:58 <elliott> I recommend chapters 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 and 14 of LYAH.
16:00:20 <lifestream> Thats why I feel so silly for asking for help dmwit, I feel like he's already spoon feeding me!
16:00:35 * elliott really has no idea what lifestream's question or problem is at all
16:00:39 <dmwit> lifestream: So, what have you tried for writing sumDigits?
16:00:57 <elliott> What are you trying to write, and what is giving you difficulty?
16:01:43 <lifestream> dmwit: not yet, wanted to get doubleEveryOther right (and have it take the list created by toDigits) <- elliott  that's what I'm trying to do. dmwit told me how now, so I guess I will do that regardless of what the professor expects.
16:02:08 <lifestream> (pass list created by toDigits into doubleEveryOther, does it not make sense?)
16:02:13 <dmwit> lifestream: The exercise makes no mention of having doubleEveryOther take the output of toDigits.
16:02:33 <dmwit> There's no reason to couple those two functions.
16:02:55 <lifestream> dmwit: but then the end user would have to type something awkward like doubleEveryOther [1,2,3,4,5,6,7,8,9], who the heck types their credit card number like that? :P
16:03:03 <lifestream> But you are right anyway.
16:03:10 <dmwit> lifestream: The end user will use validate.
16:03:16 <lifestream> I suppose.
16:03:19 <dmwit> Which you can't write yet, because you don't have all the pieces.
16:03:50 <dmwit> validate will, indeed, need to pass along arguments between the three previous functions.
16:03:53 <lifestream> So as usual, lifestream was making things more complicated than they are :D
16:04:00 <dmwit> Let us know if you have trouble writing that.
16:04:18 <lifestream> Will do, thanks a bunch :)
16:04:19 <danharaj> edwardk: Your presentation of IxStore threw me off for a moment. I think the indexing types are backwards from the convention used in indexed.
16:04:30 <edwardk> probably
16:04:37 <danharaj> I was like "This is the opposite of satisfiable."
16:04:51 <edwardk> depends on how you build it
16:04:57 <edwardk> both are usable
16:05:35 <edwardk> its funny when you look at indexed store you are 'working towards the center' whereas with an indexed state you are building up on either side
16:05:43 <edwardk> if that makes any sense
16:06:38 <edwardk> in the comonad you are trying to make it to the center where you have w i i a  so you can extract. in the monad you can always return and glom it on either side of the computation
16:07:07 <danharaj> ah hmm
16:07:21 <edwardk> the i and j indices for w i j a in some sense tell you 'how far apart you are from filling in the hole
16:07:56 <edwardk> at first i thought they'd be very similar to how the monads get used
16:08:05 <edwardk> did i paste you a bunch of indexed examples?
16:08:53 <edwardk> @hpaste
16:08:54 <lambdabot> Haskell pastebin: http://hpaste.org/
16:09:11 <hpaste> edwardk pasted “indexed comonads” at http://hpaste.org/66253
16:09:18 <danharaj> thanks.
16:09:56 <edwardk> data Store i j a = Store (j -> a) i
16:10:02 <edwardk> is that the version i blogged?
16:10:33 <danharaj> No, i and j are switched in the blog post.
16:10:35 <edwardk> extend :: (w j k a -> b) -> w i k a -> w i j b
16:11:02 <edwardk> its the extend that matters
16:11:28 <elliott> indexed comonads always remind me of W dIJKstrA
16:11:41 <edwardk> i tried it both ways, but this is the one i think i recall liking better
16:15:15 <playtester> I do the tryhaskell.org tutorial, in this statement (Step32)      map :: (a -> b) -> [a] -> [b]        I get error. No instance for GHC.Show.Show((a->b) -> [a] -> [b])) ... any ideas?
16:15:56 <elliott> playtester: that's because you entered a function
16:16:00 <elliott> GHCi displays everything you enter into it
16:16:03 <elliott> but functions can't be displayed
16:16:11 <elliott> try applying map to some values instead
16:16:38 <hpaste> angstrom pasted “any idea on how to refactor this?” at http://hpaste.org/66254
16:16:55 <playtester> Oh, thanks, still learning Haskell.
16:17:46 <elliott> playtester: after you're finished with the tryhaskell tutorial, check out Learn You a Haskell :)
16:17:47 <elliott> @where lyah
16:17:47 <lambdabot> http://www.learnyouahaskell.com/
16:18:21 <elliott> (or does tryhaskell already point people there?)
16:18:22 <elliott> (not sure)
16:19:17 <angstrom> I like the readability, but the extremely long lines bug me :\
16:19:18 <playtester> Thanks for suggestion. Yes it says for Real World Haskell and Haskell For A Great Good. Amazing books!
16:19:46 <hpaste> slack1256 pasted “Maxima Parser” at http://hpaste.org/66255
16:20:52 <slack1256> guy. i got a problem with a parser for Maxima code.
16:21:10 <slack1256> i don't know how to combine different datatype and different parser
16:21:40 <slack1256> should i use different little datatype or just one big datatype?
16:21:56 <adnauseam> alo - can one shed light on the state monad? i could use another explanation
16:22:46 <slack1256> adnauseam: do you have problems only with the state monad or with all monads?
16:22:47 <dmwit> angstrom: I would recommend writing separate runStop, runAdd, runSub functions, since the majority of the width comes from aligning the patterns other than the third argument.
16:23:31 <adnauseam> i dont understand the type definitions of runState for example  - how can the monad's definition as "data State s a" be used here as runState  :: State s a -> s -> (a, s) ?
16:23:36 <kaitocracy> wtf is cabal section syntax?
16:23:39 <kaitocracy> I can't find it anywhere online
16:23:43 <adnauseam> slack1256: i understand Maybe and []
16:23:46 <dmwit> adnauseam: http://scienceblogs.com/goodmath/2007/01/more_monads_stateful_programmi_1.php
16:23:48 <adnauseam> for now it's just state
16:23:56 <adnauseam> dmwit: checking it out
16:23:56 <elliott> adnauseam: data Foo a b = ...
16:23:57 * hackagebot grm 0.1.1 - grm grammar converter  http://hackage.haskell.org/package/grm-0.1.1 (BrettLetner)
16:24:01 <dmwit> adnauseam: The AAM article about it is good, too.
16:24:01 <elliott> bar :: Foo a b -> ...
16:24:02 <dmwit> ?where aam
16:24:02 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
16:24:18 <dobblego> I think I just walked into a "let's use the word container when talking about monads" discussion
16:24:40 <dcoutts_> kaitocracy: see the examples in the user guide http://www.haskell.org/cabal/users-guide/#packages
16:24:57 <kaitocracy> dcoutts_: that's exactly what I'm doing
16:25:16 <dmwit> kaitocracy: "section syntax"?
16:25:18 <angstrom> dmwit: so I'd have something like `run s e c d = case c of (ADD:_) -> runAdd s e c d ; (SUB:_) -> runSub s e c d ; ...'?
16:25:20 <adnauseam> elliott: having a hard time grasping the abstract`isms, i'm used to seeing constraints with =>, not ->
16:25:41 <kaitocracy> dmwit: yeah that's what cabal says when I run cabal build
16:25:51 <elliott> adnauseam: it is not a constraint
16:25:55 <elliott> it's just a regular data type
16:25:59 <elliott> [Int], State Int String, same thing
16:26:11 <dmwit> angstrom: I would expect something more like "run (ADD:xs) = runAdd xs; run (SUB:xs) = runSub xs", etc.
16:26:40 <dmwit> kaitocracy: Maybe you'd better post your cabal file and the exact error message you get, instead of this inscrutable and adversarial question.
16:26:45 <adnauseam> elliott: it'll just take me a bit to grasp this
16:27:25 <angstrom> dmwit: hm. then I'd have to rearange the argument-order
16:27:45 <dmwit> angstrom: Call it run' and write run s e c d = run' c s e d, if you must.
16:27:58 <angstrom> fair enough
16:28:05 <slack1256> adnauseam: give me 1 minute
16:28:08 <angstrom> I'll give it a try. thanks
16:29:06 <hpaste> slack1256 pasted “basic state monad” at http://hpaste.org/66256
16:29:42 <slack1256> adnauseam i hope that paste helps you, is ultra basic on how to use the state monad
16:29:59 * elliott thinks a presentation using state over get/set and (>>=) over do notation is unlikely to help much.
16:30:36 * dmwit == elliott
16:31:47 <elliott> dmwit: That explains so much!
16:31:49 <elliott> I think.
16:32:15 <crocoro> @pl (\x f -> f x ++ [x])
16:32:15 <lambdabot> ap (flip . ((++) .) . flip id) return
16:32:42 <crocoro> @pl (\f x -> f x ++ [x])
16:32:42 <lambdabot> (`ap` return) . ((++) .)
16:32:54 <dobblego> when I talk about state, I talk about problems that programmers are used to, and pseudo-solutions too -- such as "dependency injection"
16:33:11 <dobblego> then I say, watch me solve your problem, with the critical difference, that it will work
16:33:38 <adnauseam> slack1256: checking it out man
16:36:21 <slack1256> adnauseam: an advice. play with every monad. haskell is like buddishm, if you find a monad-tutorial on your road, kill it, it isn't a true monad-tutorial
16:36:25 <slack1256> or something along the lines
16:37:21 <elliott> Every monad?
16:37:26 <elliott> That would take an awfully long time.
16:37:45 <irene-knapp> sequence monads play
16:37:49 <irene-knapp> wait
16:37:49 <c_wraith> even the ones that haven't been implemented yet
16:37:51 <irene-knapp> mapM monads play
16:37:52 <irene-knapp> wait
16:37:56 <irene-knapp> mapM play monads, there we go
16:38:03 <elliott> don't you mean mapM_?
16:38:07 <irene-knapp> I suppose I do
16:39:29 <monochrom> "if you see Buddha, kill Buddha. if you see Wadler, kill Wadler"
16:39:50 <crocoro> @pl (\x f -> (\z -> f z ++ [x]))
16:39:50 <lambdabot> flip (flip . ((++) .)) . return
16:39:51 <slack1256> monochrom: that is it.
16:42:53 <elliott> @remember monochrom "if you see Buddha, kill Buddha. if you see Wadler, kill Wadler"
16:42:53 <lambdabot> Okay.
16:47:10 <jhance> Using the bytestring wrapper for alex always gives an openFile error. Any solutions?
16:47:27 <jhance> The openfile error occurs at compiletime not runtime. In the x -> hs stage
16:48:21 <MenTaLguY> howdy, can anyone familiar with pipes point me to some examples of multiple producers/consumers in a pipeline?
16:51:34 <hpaste> gdoteof pasted “gdoteof is a noob that doesn't understand haskell syntax” at http://hpaste.org/66257
16:51:42 <gamowaxaky> can any1 show me how to input binary number in ghci ?
16:52:08 <gamowaxaky> with hex number it will 0x134
16:52:13 <gamowaxaky> how a bout binary number
16:54:14 <gamowaxaky> is any1 here?
16:54:35 <elliott> no
16:54:49 <elliott> > 0b1011 -- i forget if we have these
16:54:50 <lambdabot>   Not in scope: `b1011'
16:54:53 <elliott> gamowaxaky: no binary literals, sorry.
16:55:06 <geekosaur> I don't recall binary literals existing
16:55:14 <elliott> MenTaLguY: I think you, by definition, only have a producer at the start and a consumer at the end, no?
16:55:27 <elliott> MenTaLguY: since otherwise you've got something feeding Voids in the middle.
16:55:48 <gamowaxaky> can any1 show me how to input binary number in ghci ?
16:56:18 <elliott> gamowaxaky: i just told you there is no syntax for it.
16:56:25 <geekosaur> gamowaxaky, you have just been told twice that you can't enter a binary literal
16:56:38 <elliott> there is probably a function in Numeric that can read it in from a string, though.
16:56:54 <gamowaxaky> no such a function
16:57:14 <dmwit> Yes, there is such a function.
16:57:17 <dmwit> Look harder.
16:57:27 <elliott> @hoogle [a] -> a -> Maybe Int
16:57:27 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
16:57:28 <lambdabot> Data.ByteString findSubstring :: ByteString -> ByteString -> Maybe Int
16:57:28 <lambdabot> Data.ByteString.Char8 findSubstring :: ByteString -> ByteString -> Maybe Int
16:57:38 <elliott> > readInt 2 (`elem` "01") (fromJust . elemIndex) "01011111"
16:57:39 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
16:57:39 <lambdabot>         again...
16:57:44 <gdoteof> @hoogle Binary
16:57:44 <lambdabot> package binary
16:57:44 <lambdabot> package binary-bits
16:57:45 <lambdabot> package binary-communicator
16:57:47 <elliott> > readInt 2 (`elem` "01") (fromJust . (`elemIndex` "01")) "01011111"
16:57:49 <lambdabot>   [(95,"")]
16:57:54 <elliott> ugly, but there you go
16:57:57 <monochrom> RecordWildCards is a pretty magical extension!
16:58:04 <elliott> bizarrely there is no readBin in Numeric.
16:58:06 <elliott> monochrom: :(
16:58:09 <dmwit> monochrom: yeah!
16:58:21 <elliott> Et tu?!
16:58:48 <kaitocracy> any way to use a @ expression in a case statement?
16:58:59 <monochrom> assume "data X = X{x :: Int, y :: Bool}". you can now write \X{..} -> if y then x+4 else x-2. x and y refers to the fields!
16:59:13 <znhxr> kaitocracy: yes
16:59:15 <jhance> do @ expressions not natively work in a case? Never tried but assumed they did
16:59:24 <znhxr> you can only use them in case statements
16:59:26 <elliott> monochrom: yes, it's horrible!
16:59:27 * monochrom read a use of this in hIsEOF source code!
16:59:35 <kaitocracy> okay
16:59:36 <elliott> invisible binds!
16:59:43 <elliott> and forced shadowing
16:59:50 <geekosaur> > case (1,2) of { x@(_,_) -> "yes"; otherwise -> "no" }
16:59:51 <lambdabot>   "yes"
16:59:52 <monochrom> I was like "where the hell does haCharBuffer come from!"
17:00:03 <elliott> oh, good, you're using "magical" in the proper sense
17:00:07 <elliott> I thought you were singing its praises
17:00:09 <MenTaLguY> elliott: well, let's say that I wanted to write a function with a type like: Monad m => Pipe i a m r -> Pipe i b m r -> Pipe i (a, b) m r
17:00:18 <MenTaLguY> elliott: how would I go about doing that?
17:00:33 <monochrom> I really don't know whether it's amazing or horrible!
17:00:36 <elliott> MenTaLguY: i don't think such a function is meaningful without further specification: there is no guarantee that the two pipes will "match up"
17:00:46 <elliott> MenTaLguY: what if the first one outputs 3 as but the latter outputs 10 bs?
17:00:50 <teneen> How to specify the package from which a module gets imported?
17:00:56 <teneen> in ghci
17:01:04 <MenTaLguY> elliott: let's assume zip-like semantics, it terminates once the first one runs out of data
17:01:06 <elliott> you could phrase it as, e.g. "read one from left, read one from right, stop if either of them has nothing to offer, output, rinse, wash, repeat"
17:01:13 <dmwit> teneen: import "foo" Baz.Quux
17:01:20 <dmwit> teneen: :set -XPackageImports first, of course
17:01:22 <MenTaLguY> elliott: concretely, how would I implement that?
17:01:25 <dmwit> teneen: Also, use GHC 7.2 or newer.
17:01:43 <elliott> MenTaLguY: ok. well, you could do it through pattern-matching, at least
17:01:50 <dmwit> teneen: I guess I sort of listed the requirements in reverse order there. Sorry about that. =P
17:01:55 <elliott> MenTaLguY: I don't think the pipes package has anything particular for combining two Pipes in that way, probably because the "zipping" semantics are kind of weird
17:02:04 <teneen> dmwit: Thanks a lot
17:02:05 <dmwit> (First, get GHC >= 7.2. Then :set -XPackageImports. Then import "foo" Baz.Quux.)
17:02:05 <hpaste> gdoteof annotated “gdoteof is a noob that doesn't understand haskell syntax” with “gdoteof is a noob that doesn't understand haskell syntax (shameless bump)” at http://hpaste.org/66257#a66258
17:02:05 <elliott> (otoh i don't think any of the other streaming data packages do it either)
17:02:32 <teneen> dmwit: Importing ambigous modules is not possible in predecessors of GHC 7.2?
17:02:48 <MenTaLguY> elliott: it turned out to be fairly straightforward to implement with Conduits though
17:02:54 <dmwit> teneen: It is in files, but not in ghci.
17:02:56 <elliott> teneen: why not "ghc-pkg hide" the one you don't like?
17:03:02 <MenTaLguY> elliott: so now I'm trying to sort out the pipes equivalent
17:03:06 <hpaste> lifestream pasted “Why can't I build the toDigits list? ERROR!” at http://hpaste.org/66259
17:03:07 <lifestream> Could someone check out the "expected type" error I get on the paste above?
17:03:10 <elliott> MenTaLguY: well, here's a rough implementation with what the pipes package has now:
17:03:23 <elliott> MenTaLguY: oh, wait, where does the "r" result come from?
17:03:29 <elliott> whichever pipe terminates first? what if they both terminate simultaneously?
17:03:33 <elliott> perhaps better to set r = ()?
17:03:34 <znhxr> lifestream: because you don't understand what : does
17:03:35 <dmwit> lifestream: Because (:) takes an element first and a list second.
17:03:43 <dmwit> lifestream: There's nothing more to it than that.
17:03:54 <MenTaLguY> elliott: for our purposes, we'll say the choice in the case of simultaneous termination is arbitrary
17:03:57 <lifestream> I misread the wiki page then, oops :)
17:03:57 <dmwit> :t (:)
17:03:58 <lambdabot> forall a. a -> [a] -> [a]
17:03:58 <jhance> Okay now I got alex to preprocess the .x but I then get an error about act not taking two parameters in the generated code... :(
17:04:04 <teneen> elliott: nice one, thanks!
17:04:14 <MenTaLguY> elliott: but if we start with r = () that's fine
17:04:25 <teneen> dmwit: I see. I have GHC 7.4.1 anyways. But it's weird that I can't do this in previous versions
17:05:18 <elliott> MenTaLguY: okay, what about if one pipe requests input and the other doesn't?
17:05:29 <elliott> presumably you buffer the input to give to the other pipe when it next requests input?
17:05:33 <lifestream> znhxr: dmwit, how come toDigitsRev works, then? I don't have a list there either.
17:05:41 <teneen> dmwit: It does not import :(
17:05:49 <znhxr> lifestream: yes, you do
17:05:57 * elliott isn't sure how this could have been straightforward with conduits either :)
17:06:02 <znhxr> lifestream: toDigitsRev (div n 10) :: [Integer]
17:06:03 <MenTaLguY> elliott: presumably so
17:06:12 <hpaste> gdoteof annotated “gdoteof is a noob that doesn't understand haskell syntax” with “how do i define something in a `where` with 'multiple steps'” at http://hpaste.org/66257#a66260
17:06:52 <MenTaLguY> elliott: this is what I ended up with with conduits; untested, though: https://gist.github.com/2255286
17:06:52 <elliott> MenTaLguY: ugh, you need four buffers actually
17:06:58 <elliott> input for left, input for right, output from left, output from right
17:07:22 <elliott> MenTaLguY: oh, you only do it for sources?
17:07:36 <elliott> not a fair comparison then, since you're asking for the equivalent for Conduit here
17:07:38 <lifestream> znhxr: so I'm better off, for toDigits, doing   reverse $ toDigitsRev ?  To me that's cheating since in the lesson I'm following, we haven't learned $ yet.
17:07:43 <elliott> since sources can't request input
17:07:46 <kaitocracy> is there a better way to write: do { a <- f; b a; c a }
17:07:56 <MenTaLguY> elliott: well, let's do it with pipes producers then
17:08:02 <dmwit> teneen: Why don't you hpaste a log showing exactly what you did and the exact error message?
17:08:05 <pcapriotti> MenTaLguY: you can zip producers
17:08:11 <znhxr> lifestream: so don't use $
17:08:15 <pcapriotti> MenTaLguY: there's a zip function in pipes-extra
17:08:19 <elliott> MenTaLguY: OK, that makes it easier
17:08:19 <znhxr> lifestream: you never need $
17:08:23 <elliott> aww, pcapriotti beat me to writing it :)
17:08:42 <MenTaLguY> okay, great
17:08:42 <elliott> zip_ :: Monad m => Producer a m r -> Producer b m r -> Producer (Either a b) m r
17:08:44 <elliott> that's not quite it though
17:08:48 <elliott> MenTaLguY wants (a, b)
17:09:13 <teneen> dmwit: There's not any error. It just doesn't import anything in ghci. I entered ":set -XPackageImports" then "import "mtl-2.0.1.0" Control.Monad.State"
17:09:19 <pcapriotti> you can have (a, b) if you want, but it's not as clean
17:09:21 <MenTaLguY> it's fairly straightforward to get to (a, b) from that though
17:09:28 <MenTaLguY> you'd have to be willing to buffer, obviously
17:09:36 <pcapriotti> you can add a zipper pipe after that with a size 1 buffer
17:09:54 <lifestream> znhxr, I see, I needed to use ++. I was reading the page and I completely misunderstood what it was saying http://www.haskell.org/haskellwiki/How_to_work_on_lists#Adding Thank you for your help :)
17:10:10 <hpaste> elliott pasted “for MenTaLguY” at http://hpaste.org/66261
17:10:13 <znhxr> lifestream: do you understand what $ does?
17:10:17 <mgsloan> what you really want is https://github.com/isomorphism/these  zip_ :: Monad m => Producer a m r -> Producer b m r -> Producer (These a b) m r
17:10:19 <dmwit> teneen: Will you paste a transcript anyway?
17:10:32 <MenTaLguY> pcapriotti: you'd need a arbitrarily large buffer after this, actually
17:10:33 <mgsloan> well, maybe not, but that could be an interesting way to slice it
17:10:54 <pcapriotti> MenTaLguY: well, zip is guaranteed to alternate yields
17:10:55 <elliott> mgsloan: not... really
17:10:59 <mgsloan> (note: these library does not do anything pipes related)
17:11:06 <MenTaLguY> pcapriotti: thinking about this, the trouble with Either a b is that you end up consuming bs even when you're not ready for more
17:11:07 <elliott> mgsloan: since "simultaneity" is a bit weird here
17:11:11 <MenTaLguY> if your use case is pairing the up
17:11:12 <elliott> in that it's as much a function of chance as anything else
17:11:17 <elliott> lifting return () can change it
17:11:29 <elliott> MenTaLguY: did you see the above paste? it should do what you want for the Producer type in pipes (not pipes-core)
17:11:30 <mgsloan> (just an either alternative for zipping sparse / finite structures)
17:11:34 <pcapriotti> there's a fundamental problem here in that the synchronization point for producers is in general not well defined
17:11:40 <elliott> argh, zap a (M m) xs ys = M (liftM (\a -> zap a b xs ys) m) should be zap a (M m) xs ys = M (liftM (\b -> zap a b xs ys) m)
17:11:59 <MenTaLguY> elliott: hmm
17:12:14 <elliott> MenTaLguY: it's ugly because with conduit, a Source is something you control
17:12:25 <elliott> whereas a Pipe just kinda wanders around doing its own thing in as many steps as it pleases :)
17:12:58 <pcapriotti> well, it means that zipping is not so easily defined, there are multiple ways to go about it
17:13:00 <elliott> well the conduit one isn't all that nice either. but zap has four parameters, that's like one more than you should ever need
17:13:01 <lifestream> znhxr: Processes the right first, before applying the left part? Just got a general idea. For example if you had to do    map drop 2 ... and you had to get the lists from a function, you'd do map drop 2 $ (function that returns lists) ?
17:13:15 <gnoi> How can I get output of some shell command like IO Maybe String
17:13:16 <gnoi> ?
17:13:19 <znhxr> @src ($)
17:13:19 <lambdabot> f $ x = f x
17:13:23 <elliott> lifestream: f $ x is just f x
17:13:23 <znhxr> lifestream: $ literally does nothing
17:13:25 <elliott> except that f and x can be big
17:13:33 <elliott> a b c $ d e f === a b c (d e f)
17:13:36 <elliott> it's just a syntactic convenience
17:13:39 <elliott> to avoid lots of nested parentheses
17:13:49 <dmwit> gnoi: Have a look through http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html
17:13:49 <elliott> so if you see e.g. "take 2 $ foo bar" that's just take 2 (foo bar)
17:13:51 <hpaste> teneen pasted “Importing Ambigous Modules in GHCi” at http://hpaste.org/66262
17:14:03 * hackagebot pec 0.2.3 - pec embedded compiler  http://hackage.haskell.org/package/pec-0.2.3 (BrettLetner)
17:14:23 <MenTaLguY> elliott: hmm. It seems like this should be possible to do without buffering arbitrarily large amounts of data
17:14:24 <lifestream> Well, that's interesting...
17:14:34 <MenTaLguY> in the Producer/Producer case anyway
17:14:42 <lifestream> But if it replaces the nested parentheses (as I thought), then it does something?
17:14:52 <dmwit> teneen: What's your ~/.ghci look like?
17:15:00 <znhxr> lifestream: it affects parsing on account of it being an infix operator
17:15:06 <dmwit> teneen: (It works here with ghci-7.4.1.)
17:15:07 <gnoi> dmwit: with system I can get only exit code of the command and cannot put it's respone to the other function
17:15:08 <pcapriotti> MenTaLguY: what are you looking for exactly?
17:15:18 <elliott> MenTaLguY: I disagree.
17:15:19 <pcapriotti> how should the zipped pipe behave?
17:15:23 <elliott> MenTaLguY: Consider a really slow left pipe.
17:15:35 <elliott> MenTaLguY: Oh, hmm...
17:15:38 <elliott> Yes, ok, you are right.
17:15:56 <elliott> You can phrase it as forcing the left pipe to produce one output, suspending it, forcing the right pipe to produce one output, suspending it, yielding both, and continuing.
17:16:01 <elliott> Rather than the lock-step here.
17:16:12 <pcapriotti> elliott: yeah, that's what zip_ does
17:16:20 <elliott> It'd be trivial with
17:16:20 <gnoi> @t zip_
17:16:21 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:16:33 <gnoi> :t zip_
17:16:33 <lambdabot> Not in scope: `zip_'
17:16:46 <elliott> strain :: (Monad m) => Producer a m r -> m (Either (a, Producer a m r) r)
17:16:47 <elliott> or such
17:17:02 <pcapriotti> elliott: Control.Pipe.Coroutine in pipes-extra
17:17:05 <elliott> lift (strain left), lift (strain right), combine, repeat
17:17:09 <pcapriotti> it's pretty much like that
17:17:14 <elliott> pcapriotti: heh, I'll just continue to reinvent pipes-extra I guess
17:17:18 <teneen> dmwit: I do not have a ~/.ghci
17:18:07 <teneen> dmwit: perhaps I need to create one?
17:20:19 <pcapriotti> uhm... I think it might be possible to use These instead of Either in zip
17:20:41 <elliott> pcapriotti: i would recommend against that
17:20:48 <pcapriotti> elliott: why?
17:20:51 <gdoteof> http://hpaste.org/66263 <- can someone tell me what i am not understanding in how to use a `where`
17:20:52 <elliott> if two producers happen to yield simultaneously, isn't that kind of arbitrary?
17:20:54 <elliott> or, hmm
17:20:59 <elliott> do you do the left, then right, then left, then right thing i suggested?
17:21:00 <gdoteof> the error is at the bottom
17:21:06 <elliott> in which case it makes sense i guess... but still seems less uniform
17:21:17 <ClaudiusMaximus> teneen: ghci -hide-package monads-tf
17:21:21 <pcapriotti> well, they alternate yield
17:21:46 <pcapriotti> so right now I have an Either with the invariant that it alternates between Left and Right first, then always Right or always Left
17:22:13 <mgsloan> pipes can run out of information, right? "These" would encode that possibility
17:22:30 <mgsloan> so you still get data from one pipe if the other runs out
17:22:46 <teneen> ClaudiusMaximus: This worked, thanks a lot!
17:22:47 <pcapriotti> mgsloan: yes
17:23:23 <MenTaLguY> hm
17:23:25 <elliott> pcapriotti: yes, i suppose these would be nicer in terms of invariants
17:23:28 <elliott> it's not actually on hackage yet though!
17:23:33 <elliott> ask cmccann if you want it to be :p
17:23:49 <teneen> elliott: I think monads-tf was downloaded as a dependency for happstack. Can "ghc-pkh hide" affect happstack or other packages?
17:23:54 <elliott> pcapriotti: otoh you then have the invariant "no These after the first non-These"
17:24:00 <pcapriotti> yeah
17:24:00 * mgsloan likes the naming in These :)
17:24:06 <MenTaLguY> so the other question I have -- there's no way to have a consumer quit early in a strict way, is there?
17:24:06 <elliott> teneen: nope, just ghci and ghc without any explicit package params
17:24:22 <elliott> teneen: using happstack will still work and you can import monads-tf modules (as you're likely to want to do when using happstack, perhaps) by using cabal or similar
17:24:25 <mgsloan> elliott: better yet "the same non-These after the first non-These"
17:24:30 <elliott> you can also adjust it within ghci per-session
17:24:31 <MenTaLguY> like, say you're scanning a file looking for something, and you find it and are done, it seems like pipes requires you to read the whole rest of the file in order to close it
17:24:39 <gdoteof> i have tried a bunch of different attempts at using a `where` with more than "one line" and all of them are giving me parse errors
17:24:46 <pcapriotti> but I think it's easier to write consumer pipes for These then for Either, given the respective invariants
17:24:51 <elliott> MenTaLguY: i think that's something that's in flux a lot with the revised pipes coming out soon
17:24:56 <elliott> i don't know how pipes-core handles it
17:25:04 <MenTaLguY> discard, as far as I can tell
17:25:09 <pcapriotti> no, you can close it early
17:25:20 <teneen> elliott: great, thanks!
17:25:42 <pcapriotti> as soon as the pipeline terminates, the file is closed
17:25:51 <MenTaLguY> ah, right, and the consumer can terminate things
17:26:18 <pcapriotti> with zipped producers there is a mechanism to close just one file, but it's not really pretty at this point
17:26:35 <MenTaLguY> it still seems like there should be a simpler approach for zip
17:26:35 <pcapriotti> there are some examples in pipes-core, copied from oleg
17:26:47 <pcapriotti> sorry, pipes-extra
17:26:56 <pcapriotti> MenTaLguY: yeah, maybe
17:27:00 <gdoteof> let me ask a different question.  is it possible to use a case statement within a where?
17:27:21 <MenTaLguY> of course
17:28:13 <gdoteof> MenTaLguY: that is what i thought
17:28:57 <gdoteof> so, why do i get a syntax error here on line 67 http://hpaste.org/66263
17:29:23 <adnauseam> does state in haskell resemble a state in an automaton ? is that how am i supposed to think about it ?
17:29:57 <MenTaLguY> gdoteof: layout being finnicky
17:30:10 <MenTaLguY> tried parenthesizing?
17:30:28 <geekosaur> I would expect layout wants it indented past the first letter of "seat"
17:30:41 <geekosaur> "do" is somewhat lenient in that regard, as a GHC extension
17:30:57 <geekosaur> (although I think that extension may have made the 2010 standard)
17:31:01 * MenTaLguY nods
17:31:27 <gdoteof> MenTaLguY: what would i parenthize; identing farther had no effect
17:31:43 <MenTaLguY> oh, just the entire case expression
17:32:37 <gdoteof> MenTaLguY: same error with the whole thing parenthized
17:33:27 <gdoteof> MenTaLguY: hrm.  keeping the parenthesis and joining the case line and the line above seems to have fixed it
17:36:20 <geekosaur> oh, you have a silent logic error there as well:  "otherwise" just happens to work, shadowing the Prelude binding for it.  more correct would be "_" in place of "otherwise"
17:36:32 <elliott> (-Wall catches this)
17:47:05 <shapr> Why does System.Directory show directory Permissions as False?
17:48:18 <znhxr> what do you mean?
17:48:32 <geekosaur> "For directories, the executable field will be False, and for files the searchable field will be False."
17:48:45 <elliott> is that for Windows?
17:48:49 <elliott> or just to be different?
17:49:12 <shapr> I dunno, I need to check/modify the executable field.
17:49:22 <geekosaur> Windows doesn't really have either concept.  I believe VMS and OS/400 do; also some network filesystems (notably AFS)
17:49:30 <shapr> I'm reading http://hackage.haskell.org/packages/archive/directory/1.1.0.2/doc/html/System-Directory.html#g:5
17:49:32 <elliott> does GHC even run on VMS?
17:49:38 <geekosaur> that is, they are distinct concepts in those systems
17:49:56 <scooty-puff> this is probably an odd question, but i'm trying to print a syntax tree that includes lambdas abstractions, function application, etc., and was wondering, were you to want to print such a thing haskell, what prec would it have (as in for showPrec)?
17:50:05 <geekosaur> no idea, but they may be leaving the way open rather than coding something not directly portable to them into a portable APU
17:50:07 <geekosaur> API
17:50:20 <elliott> scooty-puff: Show should only be used to produce syntactically valid haskell
17:50:26 <elliott> so you shouldn't use it for your pretty-printing
17:50:28 <geekosaur> I also doubt GHC makes any attempt to handle AFS semantics, for that matter :)
17:50:32 <shapr> So, should I be using a different library to check file permissions?
17:50:34 <ivanm> elliott: modulo imports...
17:50:44 <elliott> ivanm: fair enough
17:50:52 <ivanm> scooty-puff: there are quite a few pretty-printing libraries available
17:50:53 <elliott> shapr: Can't you just check the searchable bit?
17:50:56 <elliott> executable = searchable on Unix.
17:51:01 <scooty-puff> i am using wl-pprint-extras right now
17:51:07 <ivanm> you can use one with a typeclass, use a custom typeclass, or ignore typeclasses altogether
17:51:14 <scooty-puff> with a PrettyPrec type class having prettyPrec :: Int -> a -> Doc e
17:51:17 <elliott> ah
17:51:20 <elliott> ask edwardk :P
17:51:24 <elliott> but i suspect you can just pick your own scale
17:51:25 <geekosaur> shapr, what are you trying to do?  conflating searchable with executable is a Unix-ism (and not even reliable there; AFS and NFS both throw curveballs of different kinds)
17:51:30 <scooty-puff> k
17:51:30 <elliott> if it never interacts with other documents
17:51:35 <edwardk> ?
17:52:08 <shapr> geekosaur: I'm trying to check that all the music I've copied to /home/Music is readable by all users on this system.
17:52:40 <shapr> So I figured I'd set each dir to ugo+xr and every file to ugo+r ugo-x go-w
17:52:42 <edwardk> scooty-puff: have you seen wl-pprint-terminfo?
17:53:04 <scooty-puff> i have, though i am only using small parts of it - most of the instances i have are still just Pretty's
17:53:11 <edwardk> kk
17:53:19 <elliott> edwardk: scooty-puff is wondering about prettyPrec
17:53:27 <elliott> what precedences to use for pretty-printing an AST (not in Haskell form)
17:53:55 <edwardk> scooty-puff: the usual rule of thumb is that you don't use precedence for the lambdas themselves, just when you are recursing into the type or expression system
17:53:56 <geekosaur> (aside from missing what "w" is on directories that seems fine; but if you're doing it from Haskell you want searchable instead of executable)
17:54:03 <scooty-puff> though the AST just a few basic things - let's, lambdas, literals, etc.
17:54:06 <edwardk> the idea is that precedence levels aren't 'always on'
17:54:08 <scooty-puff> k
17:54:17 <edwardk> which is why its kind of awkward to have it in the pretty printing monad
17:54:44 <edwardk> the usual approach is to just pass in a current precedence level as a function argument, since its only a reader transform anyways
17:55:50 <elliott> oh, is prettyPrec something scooty-puff invented?
17:55:56 <edwardk> elliott: yeah
17:56:17 <scooty-puff> forgot the channel: http://hpaste.org/66266
17:56:22 <scooty-puff> yes
17:56:57 <elliott> ok then
17:57:00 <elliott> just make stuff up :P
17:57:17 <edwardk> you can always go negative but its a hack and won't fit all grammars
17:57:47 <edwardk> the precedence level is just for the operator precedence part of the pretty printer, which is sandwiched in between the usual recursive parts
17:58:28 <int80_h> I want to keep a TVar globally. The values inside the TVar will change, but I won't be swapping out the TVar for another. Would it make sense to use a Reader Monad?
17:58:40 <edwardk> the printing of abstractions is in 'those recursive parts' which is why precedence seems so awkward -- its because its unrelated ;)
17:59:00 <scooty-puff> its not so important to me that it be parseable again - this is just to dump a rewrite - but would like it to make a decent amount of sense
17:59:06 <elliott> int80_h: yes
17:59:12 <scooty-puff> k
17:59:13 <scooty-puff> hmm
17:59:27 <int80_h> elliott: cool. I think I'm starting to catch on.
17:59:38 <scooty-puff> let me just try assigning good enough seeming values to see if it at least looks sane
18:03:55 <edwardk> usually i'd say something like prettyTerm d (Abs patterns body) = paren ... $ text "\" <+> fillSep (prettyPattern 11) <$> patterns <> text "." <+> prettyTerm 0 body
18:04:24 <edwardk> er fillSep (prettyPattern 11 <$> patterns) <> text "." ...
18:05:48 <edwardk> where you set the parentheses around it such that if you app the lambda it'll be surrounded in parens, but otherwise left alone
18:06:58 <scooty-puff> k
18:08:37 <shapr> I'm confused, if I chmod ugo-x a directory, then System.Directory.Permissions shows as searchable = False. So, are the docs misleading, confused, or what?
18:10:54 <kaitocracy> okay I'm super confused, I have x :: ResourceT IO (Maybe (FileInfo ByteString)); and a function f :: FileInfo ByteString -> ByteString, how do I get a ResourceT IO (Maybe ByteString) from x and t?
18:10:56 <c_wraith> shapr: if I'm read that right right, that should mean not searchable
18:11:35 <parcs`> kaitocracy: fmap . fmap
18:11:46 <kaitocracy> oh
18:12:08 <parcs`> one fmap for the ResourceT IO, another for the Maybe
18:12:18 <kaitocracy> man these types get confusing very quickly
18:12:40 <c_wraith> shapr: I'm not seeing anything in the docs that contradicts taht
18:13:09 <danharaj> woo, I'm starting to Grok edwardk's construction for IO.
18:13:20 <edwardk> =)
18:13:32 <danharaj> By the way, the theme on your blog cuts off a very important type!
18:13:41 <edwardk> which one?
18:13:47 <danharaj> the type for Iterator.
18:13:50 <edwardk> k
18:13:55 <edwardk> which post?
18:13:58 <edwardk> yielding io?
18:14:11 <danharaj> Yessir.
18:14:38 <edwardk> must be your browser font size settings. i can tune it though
18:15:39 * shapr cleans brain of C++ cruft
18:15:44 <danharaj> Ah, I haven't tried it on another browser. (On Opera default settings)
18:16:31 <edwardk> i tweaked it a bit
18:18:00 <danharaj> now it puts everything after runIterator :: on a newline in a rather pleasing way, although it doesn't look like Haskell layout so it could be a little misleading.
18:19:27 <danharaj> There are a few other types that are cut short, but they're less important than the type of Iterator.
18:22:10 <bmatt3> hj
18:22:42 <zzo38> Can you please tell me how to fix the applyMoveReg?  http://sprunge.us/gfVZ
18:22:50 <shapr> So System.Directory only lets me view/edit permissions for the owner. How can I edit permissions for group and other from Haskell?
18:23:38 <shapr> zzo38: How do you like Maryland?
18:23:58 <zzo38> shapr: I have never been a Maryland.
18:24:16 <zzo38> s/been a /been at /
18:24:39 * Clint squints.
18:25:44 <elliott> zzo38: You're more likely to get help if you reduce your problem and explain it to us, rather than just linking to your complete source code.
18:26:15 <zzo38> elliott: The problem is applyMoveReg it is incomplete
18:26:36 <zzo38> The way it is now make the file too large output, it should be fix to don't do that anymore
18:27:12 <elliott> Well, we don't know what applyMoveReg is meant to do, because we don't know what your program is trying to do, so it's very unlikely anyone will be able to help you without more details.
18:28:19 <zzo38> It says right there: "Next is to apply movement registers to the movement commands.
18:29:01 <elliott> That's not a very helpful description. Maybe it'd make sense after reading the rest of your program, but... that's a lot to expect for a single question on IRC.
18:29:24 <zzo38> That is, the DVI has four extra registers called w,x,y,z, which are used as shortcut to tell it to move the cursor by the same distance as moving before.
18:29:42 <monochrom> programmers think that their docs are self-explanatory
18:30:08 <zzo38> Probably the best way to understand is to look at the documentation for DVI file format.
18:30:24 <elliott> zzo38: Well, that makes it a Haskell and DVI question.
18:30:26 <zzo38> (Which isn't very long; DVI is a relatively simple format.)
18:30:30 <elliott> It's unlikely there are many DVI experts here.
18:30:39 <elliott> It would be best if you applied your knowledge of the DVI format to turn it into just a Haskell question.
18:30:50 <elliott> i.e., tell us exactly what the function has to do, and why you're having difficulty writing it.
18:33:25 <zzo38> OK. The function has to, for example if you are moving 6 5 4 5 5 5 5 6 6 6 2 6 6 9 9 9 9 9 9 9 9 then maybe you assign x to 6, w to 5, and then later on perhaps y become 9 instead
18:33:52 <zzo38> Can you understand it?
18:34:12 <elliott> No. As someone who knows nothing about DVI or your program, your explanation doesn't tell me exactly what you're trying to accomplish or, more importantly, what you've already tried and had problems with.
18:34:20 <elliott> What is your Haskell-related problem?
18:35:27 <zzo38> The problem is the proper algorithm to make that in Haskell.
18:36:26 <elliott> You really need to ask your question in such a way that someone can answer it without having to read your entire program or know about DVI. As it is, I have no idea how to answer, and I expect the same applies to others.
18:39:04 <zzo38> I explained what needs to be done; if I know how to make such an algorithm then I might do it. Actually there is also stack but I know how to do that as a tree instead so I can ignore that for now and then I make it to work
18:43:00 <kallisti> is there a way to delimit a hex escape in a string literal?
18:43:07 <kallisti> \x{...}  something like this?
18:43:18 <zzo38> kallisti: \& will stop a hex escape
18:43:25 <kallisti> ah okay.
18:43:30 <zzo38> Or any other escape too
18:43:49 <zzo38> (One of the features I very much like in Haskell)
18:45:36 <monochrom> \& can be viewed as notation for the empty string
18:46:10 <monochrom> its presence is precisely for "\x4aa\&bcc"
18:46:36 <znhxr> \& is syntactic sugar for \ \
18:52:44 <lifestream> In hpaste I can highlight a line with @@ before it, right?
18:57:38 <dmwit> gnoi: Don't use system, then. There's about 30 functions in the module I linked you to.
18:58:29 <dmwit> ?tell teneen You shouldn't need a .ghci for :set -XPackageImports to work. (I don't have one, either.) I really don't know what went wrong; the exact same sequence of commands on the exact same version of GHC(i) has a different effect here. That's very weird.
18:58:29 <lambdabot> Consider it noted.
19:01:00 <Elemir> preflex: seen iportnov
19:01:00 <preflex>  Sorry, I haven't seen iportnov
19:01:03 <Elemir> preflex: seen portnov
19:01:03 <preflex>  portnov was last seen on #xmonad 13 days, 7 hours, 14 minutes and 18 seconds ago, saying: elemir: for Wayland?
19:01:03 <dmwit> Hm, actually, that's not quite true.
19:01:13 <dmwit> I didn't do the exact same sequence, I skipped around a bit.
19:01:23 <dmwit> When I try that exact sequence, I have to say I'm very confused by what happens.
19:01:31 <dmwit> I think this is probably a bug.
19:01:55 <elliott> yay, bugs
19:02:23 <parcs`> i don't think ghci can parse import statements with a package-import thing
19:02:33 <dmwit> parcs`: It can.
19:02:48 <dmwit> ghci-7.2 and ghci-7.4 can, at least. ghci-7.0 can't
19:03:46 <monochrom> but 7.2's import command has bugs
19:03:54 <monochrom> I forgot what the bugs did
19:03:56 <dmwit> 7.4 as well, it seems
19:04:20 <hpaste> dmwit pasted “explain this!” at http://hpaste.org/66269
19:07:36 <monochrom> oh! that's fun. especially an inability to succeed after a failure :)
19:07:53 <monochrom> it is as though the first, failing command has corrupted some mutable state
19:08:02 <dmwit> right
19:08:10 <dmwit> That was how I read it, too.
19:08:53 <parcs`> hmm, i have a recent build of ghc head.. /tries
19:09:18 <dmwit> ?tell teneen Actually, after a bit more playing, it may be a bug. I've made a report here: http://hackage.haskell.org/trac/ghc/ticket/5979
19:09:18 <lambdabot> Consider it noted.
19:09:30 <parcs`> yeah, fails in ghc head too
19:09:44 <monochrom> it's why I still do not use the import command
19:10:00 <dmwit> You knew about this?
19:10:08 <shergill> how do you read the ~ symbol, seen in type signatures. eg. data EBuffer a = forall c. (Buffer c, El c ~ a) => EBuffer c
19:10:14 <monochrom> no, I saw another bug in 7.2
19:10:16 <dmwit> shergill: type equality assertion
19:10:24 <monochrom> and I forgot what the bug did
19:10:38 <dmwit> shergill: You should read it the same as "=", but with a different name because there's too many meanings of "=" already.
19:10:48 <dmwit> lol
19:11:04 <shergill> dmwit: ah k. yeah just wanted to confirm
19:11:57 <kaitocracy> are there any functions with this type signature?
19:12:07 <kaitocracy> n (m a) -> (a -> n (m b)) -> n (m b)
19:12:19 <dmwit> :t lift
19:12:20 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
19:12:41 <dmwit> kaitocracy: Perhaps, if you add some constraints.
19:13:04 <kaitocracy> what kind of constraints?
19:14:16 <dmwit> You'd probably need a pair of monads that commute.
19:14:20 <parcs`> dmwit: it doesn't even work when compiling source a fil
19:14:21 <parcs`> e
19:14:36 <dmwit> parcs`: What, the "mtl-2.0.1.0" version?
19:14:57 <kaitocracy> ahh
19:14:58 <parcs`> yeah
19:15:11 <dmwit> I'm not sure it's supposed to, is it?
19:15:24 <kaitocracy> one of them is IO
19:15:46 <parcs`> it's not?
19:16:03 <dmwit> parcs`: The user's guide doesn't mention anything about picking a specific version.
19:16:06 <znhxr> One of Them is Hope
19:16:22 <dmwit> kaitocracy: Perhaps it is time for you to learn about monad transformers.
19:16:22 <kaitocracy> I've got a function that returns an :: IO (Maybe a) and another that is an :: a -> IO (Maybe a)
19:16:29 <danharaj> edwardk: I'm a little confused by the type of Iterator. I get that the first argument is the final bit of the continuation and I think the second is the function driving the iterator, but I'm not sure how to write such a function. In particular the (i -> r) bit puzzles me.
19:16:32 <kaitocracy> trying to figure how to chain those together
19:16:38 <kaitocracy> and monad transformers are mad confusing
19:16:39 <dmwit> ?unmtl MaybeT IO a
19:16:39 <lambdabot> IO (Maybe a)
19:17:21 <kaitocracy> well I'll give that a go and see what happens thanks!
19:20:01 <dmwit> ...yes, and of course when "n" and "m" are more concrete than type variables, you can do much more.
19:20:36 <dmwit> So, you can certainly write something of type IO (Maybe a) -> (a -> IO (Maybe b)) -> IO (Maybe b); and doing so amounts to implementing the MaybeT monad transformer.
19:21:06 <dmwit> So now you know what good monad transformers are, and hell, you can probably even write one with a bit of thought.
19:21:48 <dmwit> Hm, djinn doesn't do rank-2 types, does it? I guess I can't show that it could be done mechanically. =P
19:25:57 <kallisti> I find it strange that converting a lazy bytestring to strict produces a list of chunks.
19:26:02 <elliott> djinn can't do rank-2 types as i understand it
19:26:07 <kallisti> seems like an unnecessary low level detail.
19:26:07 <elliott> well not fully anyway
19:26:21 <elliott> kallisti: because that's efficient
19:26:28 <elliott> concatenating them after wouldn't work for e.g. an infinite bytestring
19:26:43 <kallisti> hm okay.
19:28:17 <kallisti> elliott: the problem I'm having is that base64-bytestring only works with strict ByteStrings
19:28:25 <kallisti> meanwhile all of my stuff is lazy ByteStrings
19:28:48 <kallisti> I guess I could return a strict bytestring in this one case.
19:29:22 <kallisti> with Aeson I'm pretty sure that just does the conversion for me.
19:42:21 <monochrom> no
19:42:30 <monochrom> err, lag
19:47:41 <elliott> monochrom: yes
19:47:46 <danharaj> edwardk: Iterator is so clean and nifty. It's amazing how you can throw categorical constructions together and what you get out is often something of profound expressiveness and elegance.
19:47:58 <danharaj> And in a sense, canonical!
19:48:10 <edwardk> =)
19:49:21 <Cale> What Iterator is this?
19:49:39 <monochrom> must be edwardk's evil invention
19:50:13 <danharaj> Iterator i o a = Iterator { runIterator :: (a -> r) -> (o -> (i -> r) -> r) -> r }
19:50:30 <edwardk> http://comonad.com/reader/2011/free-monads-for-less-3/
20:14:51 <scooty-puff> what is the best way to diagnose a seg fault from what appears to be a safe haskell program (other than some uses of template haskell and gen newtype deriving - though i don't mean the new safety stuff)
20:15:03 <parcs`> dmwit: it's fixed!
20:15:10 <scooty-puff> i'm doing no ffi, and no unsafe<...>, so to rule out my program, are there any good tools?
20:15:24 <scooty-puff> normally i would go with valgrind, where normally is "for c"
20:15:35 <dmwit> parcs`: Yeesh, fast work!
20:16:39 <dmwit> scooty-puff: Do a clean build from scratch.
20:16:46 <parcs`> haha, luckily i was already somewhat familiar with that part of ghc
20:17:13 <scooty-puff> due to a bug i have yet to report, i have to do cabal clean, configure, build each time - otherwise a panic from ghc
20:18:18 <scooty-puff> found a wiki related to debugging this kind of stuff, will work through that
20:19:13 * hackagebot gloss 1.7.1.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.1.1 (BenLippmeier)
20:26:36 <elliott> scooty-puff: refine the testcase and report as a bug in ghc?
20:26:43 <elliott> but it may be that a library you are using is broken
20:34:23 <scooty-puff> meh, computer overheated..
20:34:49 <monochrom> haha
22:08:37 <Yrogirg> hello, is there a way to declare type constraint on a synonym?
22:08:38 <Yrogirg> type (Vector v) => Dual v = v -> Double
22:10:05 <dmwit> No.
22:12:57 <nyingen> @quote
22:12:57 <lambdabot> pikhq says: compiling C++ is equivalent to solving the halting problem. Thus, C++ has never been implemented.
22:14:52 <shachaf> Yrogirg: You can declare type Dual v = Vector v => v -> Double
22:14:57 <shachaf> That might not be what you want, though.
22:20:02 <Sgeo> What.
22:21:22 <cheater_> what can this be used for? http://en.wikipedia.org/wiki/Vector_clock
22:26:03 <Enigmagic> cheater_: go look at amazon's dynamo
22:38:13 <nyingen> @quote
22:38:13 <lambdabot> edwardk says: i just got bitten in the ass by the lack of a notion of commutative monad for a in a toy kind of memoizing hylomorphism that now has way too much 'ordering' baked into it
22:44:03 <dmwit> ?quote
22:44:04 <lambdabot> TacticalGrace says: #haskell in action: discussion about first-year teaching turns into an argument about CT and Kan extensions
23:41:51 <xarch> why isn't it possible to make state a free monad?
23:42:07 <danharaj> Because it isn't a free monad.
23:42:12 <xarch> using the type data S s x = Get (s -> x) | Put s x for example ?
23:42:13 <xarch> -?
23:45:19 <dobblego> when I use polyparse, I find that a lot of basic combinators are missing -- are they hiding elsewhere or is it just incomplete?
23:47:28 <shergill> a state is the opposite of what free signifies.
23:59:45 <cheater_> Enigmagic: thanks
