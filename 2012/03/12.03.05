00:19:08 <hyperCC> ..
00:22:39 <hpaste> latros pasted “freqsort” at http://hpaste.org/64781
00:22:52 <latros> anyone care to help me figure out why that won't typecheck :(
00:23:23 <latros> somehow it wants gismuSrana to be [String], but there doesn't seem to be any reason why it must be
00:23:32 <latros> afaict
00:25:17 <latros> oh, deleteBy' has the type of filter
00:30:28 <ChristianS> latros: freqSortGismuSrana [] gismuSrana = gismuSrana -- that tell's ghc that gismuSrana must be a String
00:30:48 <ChristianS> [String]*
00:30:56 <latros> ...oh
00:30:58 <latros> derp
00:30:59 <latros> thanks
00:31:16 <latros> the useless case makes it fail to typecheck >.>
00:31:24 <latros> how ironic
00:43:38 <ChristianS> latros: for the "useless case" (pattern match completeness) i would generally write something like: error "First argument must not be empty"
00:44:13 <latros> I actually noticed that it can be rolled into the accumulator helper
00:44:34 <latros> it results in empty output, but oh well
00:44:43 <latros> but yeah that might be better
00:46:12 <Hail_Spacecake> why are type and data two separate things?
00:46:27 <latros> data makes the compiler actually do quite a bit of work
00:46:31 <latros> as it happens
00:46:40 <ChristianS> data defines a new data type, type is just an alias for an existing type
00:46:48 <Hail_Spacecake> why doesn't it make sense to have, both, say type BookIndex = Int and type Book = BookIndex BookTitle deriving(show)
00:46:48 <Hail_Spacecake> ?
00:46:49 <latros> type doesn't actually do anything at all
00:47:16 <latros> as in, you could parse away the effects of type, if all extensions are off
00:47:22 <latros> rather effortlessly
00:47:37 <latros> anyway, I think the point is that that'd be ambiguous?
00:48:17 <latros> or if not ambiguous, less clear
00:49:43 <ChristianS> type defines just an alias, so the type must already exist
00:49:56 <rata_> hi
00:49:57 <Hail_Spacecake> oh
00:49:58 <Hail_Spacecake> okay
00:50:48 <ChristianS> Hail_Spacecake: you *could* always use data, e.g. data BookIndex = BookIndex Int
00:51:22 <rata_> how do I prevent this type error
00:51:23 <ChristianS> but that causes an additional level of indirection, which is not there if you just use type to define an alias
00:51:24 <rata_> > :t fst . flip (+)
00:51:26 <lambdabot>   <no location info>: parse error on input `:'
00:51:33 <rata_> > fst . flip (+)
00:51:34 <lambdabot>   Couldn't match expected type `(a, a1 -> b)'
00:51:35 <lambdabot>         against inferred type `...
00:51:43 <latros> um
00:51:50 <latros> you can't apply + to a tuple
00:51:55 <Hail_Spacecake> why not data BookIndex = Int?
00:52:03 <rata_> (+) is just for reference
00:52:08 <latros> both data and newtype declare data constructors
00:52:10 <ChristianS> rata_: what are you trying to do?
00:52:11 <rata_> but it's a bad example
00:52:26 <rata_> let f a b = (a, b) in fst . flip f
00:52:27 <ChristianS> Hail_Spacecake: oh, because Int is a type, not a type constructor
00:52:34 <rata_> > let f a b = (a, b) in fst . flip f
00:52:35 <lambdabot>   Couldn't match expected type `(a, a1 -> b)'
00:52:35 <lambdabot>         against inferred type `...
00:52:53 <ChristianS> @src Maybe
00:52:54 <lambdabot> data Maybe a = Nothing | Just a
00:52:59 <rata_> I'd expect the type of that to be a -> b -> a
00:53:06 <rata_> not a type error
00:53:13 <mauke> rata_: your expectations are wrong
00:53:16 <ChristianS> Maybe is a type, Nothing and Just are type constructors
00:53:17 <latros> > let f a b = (a,b) in fst . f
00:53:18 <mauke> :t (fst .) . flip ?f
00:53:18 <lambdabot>   Couldn't match expected type `(a, b)'
00:53:18 <lambdabot>         against inferred type `t -> (...
00:53:19 <lambdabot> forall a b (f :: * -> *) a1. (Functor f, ?f::f (a1 -> (a, b))) => a1 -> f a
00:53:36 <mauke> :t (fst .) . flip (,)
00:53:37 <lambdabot> forall a b. b -> a -> a
00:53:47 <latros> oh oh
00:53:50 <latros> now I see the problem
00:53:53 <latros> composition is *unary*
00:54:07 <Krez> Man I love this language.
00:54:14 <rata_> latros: can i work around that?
00:54:25 <latros> you can, but it is ugly
00:54:28 <ChristianS> Hail_Spacecake: in data BookIndex = BookIndex Int , BookIndex (to the left) is the type, while BookIndex Int (to the right) is the type constructor.
00:54:35 <Hail_Spacecake> ah
00:54:38 <latros> because you have to pass both arguments to f
00:54:39 <mauke> rata_: I just did
00:54:41 <latros> which means you have to use two .
00:54:44 <Hail_Spacecake> when is it ever useful to maek those different, though?
00:54:45 <latros> as mauke did
00:54:53 <Hail_Spacecake> it seems like that would be confusing, and perhaps the langauge shouldn't allow it
00:55:11 <Hail_Spacecake> if there is a type SomeType then SomeType should always be the constructor?
00:55:26 <Hail_Spacecake> is that good practice that's just not codified into the langauge or is there a reason to ever not do it like that?
00:55:47 <merijn> Hail_Spacecake: What if you have multiple constructors?
00:55:51 <merijn> See:
00:55:53 <merijn> @src Maybe
00:55:54 <lambdabot> data Maybe a = Nothing | Just a
00:56:03 <rata_> mauke: what's the logic behind that?
00:56:10 <Hail_Spacecake> oh
00:56:20 <latros> (.) f g = \x -> f (g x)
00:56:27 <Hail_Spacecake> so wait, in that kind of constructor, is the type Maybe a or just Maybe?
00:56:30 <latros> NOT \x y -> f (g x y)
00:56:35 <Hail_Spacecake> i.e. does the tyep variable count as part of the type name?
00:56:45 <merijn> Hail_Spacecake: The type is "Maybe a"
00:57:07 <Hail_Spacecake> so I could just as well define type Maybe = Int if I wanted, and that wouldn't confuse anything?
00:57:08 <srhb> @type Just "foo"
00:57:09 <lambdabot> Maybe [Char]
00:57:14 <rata_> latros: I see that... my question was why the (fst .) . flip f works
00:57:21 <merijn> Hail_Spacecake: i.e. a function that works on "Maybe a" will work on Maybe Int, Maybe String, etc
00:57:35 <latros> try passing in an argument yourself
00:57:50 <latros> (fst .) . flip f = \x -> (fst .) (flip f x)
00:58:28 <latros> = \x -> (\y -> fst (flip f x y))
00:58:35 <merijn> Hail_Spacecake: Well, you'd confuse every programmer ever by doing that, but in theory you could do that. (Note: you're defining a type Maybe with one constructor, which is "Int". Not a type that accepts an Int)
00:59:01 <Hail_Spacecake> oh
01:00:08 <Jafet> @unpl (fst .) . flip f
01:00:09 <lambdabot> (\ h k -> fst (f k h))
01:01:00 <merijn> Hail_Spacecake: If you want to just define a new name you can use "type" instead. "type URL = String"
01:01:25 <merijn> Hail_Spacecake: The canonical example would be String, which is just "type String = [Char]"
01:01:37 <Hail_Spacecake> is there a wya to define types in ghci?
01:01:41 <rata_> latros: how did you get the second transformation?
01:02:12 <ChristianS> Hail_Spacecake: you know two ways already, type and data.
01:02:12 <latros> you can also look at it as \x -> (\y -> fst ((flip f x) y))
01:02:15 <latros> does that help?
01:02:17 <merijn> Hail_Spacecake: I don't think so, but you can use ":l" (load) and ":r" (reload) to open a file and work with its contents
01:02:46 <merijn> I usually have two terminals, one with vim and one with ghci and then I write types in vim and use ghci to play around with them
01:03:12 <Jafet> I write everything with Fix, Either, and tuples
01:03:16 <ChristianS> Hail_Spacecake: oops, ignore me, merijn is right
01:04:03 <Enigmagic> Hail_Spacecake: you can define them in ghci 7.4.1
01:04:09 <Hail_Spacecake> how?
01:04:31 <Enigmagic> > data Foo1 = Bar | Baz
01:04:31 <Hail_Spacecake> huh, my distro only has 7.0.3
01:04:32 <lambdabot>   <no location info>: parse error on input `data'
01:04:47 <Enigmagic> :info Foo1 = data Foo1 = Bar | Baz -- Defined at <interactive>:65:6
01:05:09 <merijn> Hail_Spacecake: 7.4 is the experimental development version, I think
01:05:20 <Enigmagic> 7.2.x was the experimental development version
01:05:31 <Enigmagic> 7.4.1 or 7.4.2 will be in the next haskell platform
01:06:30 <Jafet> No, merijn, that's 7.6.
01:06:30 <rata_> latros: not much
01:07:09 <latros> ok, um
01:07:22 <rata_> I don't get how you expand something like (asdf .)
01:07:23 <latros> (fst .) (flip x y) = fst . (flip x y)
01:07:35 * merijn stands corrected
01:08:14 <merijn> rata_: "(asdf .)" is just shorthand for "\x -> asdf . x"
01:08:21 <rata_> ok, so that trick is only useful for functions of two arguments
01:08:30 <latros> nope
01:08:36 <latros> you can keep doing it indefinitely
01:08:45 <merijn> It just becomes unreadable :p
01:08:46 <latros> it becomes horrifying past about two arguments however
01:08:53 <latros> ((f .) .) . g
01:08:56 <rata_> ok
01:09:17 <rata_> indeed it's horrifying already for two arguments
01:09:35 <latros> you can define your own higher arity composition operators though
01:09:51 <rata_> too bad there's no general way
01:10:19 <latros> there is for sufficiently simple setups
01:10:22 <latros> but that uses typeclass-foo
01:10:41 <Jafet> No one needs the general way, so it is not written.
01:11:11 <rata_> no one should include also me right?
01:11:28 <Jafet> Do you?
01:11:28 <hpaste> latros pasted “predicate” at http://hpaste.org/64783
01:11:31 <rata_> I mean, no one is quite a generalising statement
01:11:55 <latros> this compiles and lets you negate predicates of arbitrary arity
01:11:56 <rata_> well, indeed I needed it several times
01:12:30 <Jafet> So, did you write it?
01:12:50 <latros> there wouldn't be a general way
01:12:59 <latros> for the same reason as there isn't a general way to deal with tuples
01:13:00 <rata_> Jafet: what? the general one?
01:13:08 <latros> (without templates, which are "cheating")
01:13:10 <rata_> no, I didn't know how to write one
01:13:51 * Jafet needs to revise that quantifier then... but won't
01:14:04 <Botje> you rebel.
01:14:41 <merijn> rata_: The same way you would write something like (.)
01:16:17 <rata_> merijn: commonly it's just easier to write the function in a non point-free way
01:16:28 <rata_> but I don't like that way either
01:16:59 <Jafet> import DWIW
01:17:08 <merijn> rata_: Pretty sure the implementation of (.) isn't point-free either
01:17:12 <merijn> @src (.)
01:17:12 <lambdabot> (f . g) x = f (g x)
01:17:13 <lambdabot> NB: In lambdabot,  (.) = fmap
01:17:51 <danr> f . g = \x -> f (g x) -- to enable inlining when (.) only has two arguments
01:18:36 <Jafet> This is your captain speaking: welcome to Glasgow
01:19:18 <merijn> rata_: I would just write the function in a non point-free way, then if it's ugly come up with a fictional function that makes it pretty. Then you just need to recurse and implement this fictional function following the same steps
01:19:36 <rata_> merijn: I mean, just write it in place non point-free, like (\x y -> fst $ addY x y) instead of (fst . flip addY)
01:19:42 <merijn> Repeat until your program is beautiful or you've implemented a new functional language
01:20:02 <merijn> I'm a big fan of write first, beautify later
01:20:12 <merijn> Mostly because I find writing from scratch hard, but cleaning up easy
01:25:16 <mjrosenb> merijn: i find just the opposite
01:25:37 <merijn> mjrosenb: Sure, it's very personal I guess
01:25:40 <mjrosenb> merijn: writing code and solving a problem is interesting, whereas cleaning up is tedious and boring
01:25:42 <rata_> ok guys, too late for me... see you soon
01:25:50 <mjrosenb> essential, but boring.
01:25:54 <mjrosenb> like taxes :(
01:26:00 <merijn> mjrosenb: "cleaning up" in my case can be a complete rewrite :p
01:26:42 <merijn> I just mean that I find it easier to start when there is code that sorta/kinda looks like what it's supposed to do
01:26:55 <merijn> Stops me from getting empty editor screen paralysis :p
01:27:44 <Jafet> Rewriting code is pretty natural to me.
01:27:56 <Jafet> Think of it as being your own copywriter.
01:30:03 <latros> um
01:30:06 <latros> what
01:30:11 * latros is very very confused
01:30:49 <hpaste> latros pasted “readfile fail” at http://hpaste.org/64784
01:31:14 <latros> this compiles and then says jbovlaste.xml: hGetContents: invalid argument (invalid byte sequence)
01:31:27 <latros> oh....wait
01:31:32 <latros> dos format, that's probably why?
01:31:34 <Jafet> jbovlaste.xml does not contain valid UTF-8 text
01:31:45 <latros> hmm
01:32:03 <latros> I thought I saved it as unicode in the first place
01:32:13 <merijn> You can't "save as unicode"
01:32:20 <Jafet> There is no encoding named unicode
01:32:26 <latros> er, yeah, sorry
01:32:28 <latros> as UTF-8
01:32:57 <latros> [noeol][converted][dos]
01:32:58 <shachaf> Sure you can save as Unicode.
01:33:03 <latros> that's...probably the problem?
01:33:05 <shachaf> It's not a byte encoding but it's a character encoding.
01:33:13 <cemycc> Can someone explain how can I write the extended euclidean algorithm in Haskell ?
01:33:39 <latros> I saved this file on windows but I was pretty damn sure I saved it as UTF-8
01:33:42 <latros> :(
01:33:59 <latros> (it's troubling because now I have to dump it again, which takes several minutes)
01:34:00 <mauke> latros: what does ':set fenc?' say?
01:34:01 <latros> (oh well)
01:34:12 <latros> fileencoding=utf-16le
01:34:16 <mauke> there we go
01:34:22 <mauke> :set fenc=utf8
01:34:23 <mauke> :w
01:34:32 <mauke> or is it fenc=utf-8?
01:34:33 <Jafet> cemycc: probably the same way you write it in any other language
01:35:10 <shachaf> cemycc: The solution to Project Euler problem 134 is (apparently) 18613426663617118
01:35:19 <shachaf> There, you're done.
01:36:04 <AfC> Just throw some ± error bars on that number and you're sure to hit it.
01:37:03 <shachaf> (If that's not what you're doing, my apologies. :-) )
01:37:19 <Jafet> Submit 18613426663617118 programs
01:39:59 <cemycc> shachaf: Is not that :) Just trying to learn some haskell, writing math algoritmhs
01:40:25 * merijn personally thinks that Project Euler is not well suited to learning new languages
01:41:22 <srhb> cemycc: The wikipedia article on the subject basically hands you the pseudocode.
01:50:10 <cemycc> srhb: the problem is that I don't know how to write that pseudocode in haskell, for example in pseudocode we have: (s, t) := extended_gcd(b, r) How can I write this in haskell but not on returning values ?
01:50:18 <latros> ...is it idiomatic to get things in the order that you want them in at the end, prepend them in that order, and then reverse at the end?
01:50:37 <latros> cemycc: there should be a recursive implementation
01:50:40 <merijn> latros: In lists you mean? Sure
01:50:52 <shachaf> latros: That is an idiom that exists. In some cases it's a reasonable thing to do.
01:51:18 <latros> I'll paste this then
01:51:27 <latros> it's....kinda horrible
01:51:28 <latros> but
01:51:29 <latros> oh well
01:51:55 <hpaste> latros pasted “freqsort” at http://hpaste.org/64786
01:52:20 <latros> you probably don't want to sift through all of that
01:52:35 <latros> but if you're willing to, and can suggest a non-reversed way to do this, that would be appreciated
01:52:44 <cemycc> latros: That is the recursive implementation. http://codepad.org/E5nC6iIj
01:52:57 <latros> hm
01:53:08 <latros> I thought there was a purely recursive one
01:53:31 <merijn> latros: How is that not "purely recursive"?
01:53:39 <merijn> What does "purely recursive" even mean?
01:53:41 <latros> ah wait nvm
01:53:43 <latros> you can do lets
01:53:45 <latros> for that
01:54:21 <latros> sorry, I'm tired and was thinking that you would need actual variable assignments
01:54:30 <latros> which is not true, because none of the variables change value within a given scope
01:54:49 <azaq23> cemycc: note that the extended algorithm can be rewritten as a matrix multiplication problem using the recursive formula, which is pretty neat considering you can simultaneously make the problem a
01:54:49 <azaq23> lot easier to approach and prove the bezoat identity
01:54:50 <cemycc> so I will need to use lets for the temp variables ?
01:54:51 <latros> so, cemycc, you can pretty much follow that pseudocode verbatim
01:55:04 <latros> I would use let or where, yes
01:55:17 <merijn> cemycc: I prefer "where" for these cases, but yes.
02:03:28 <latros> there isn't a predicate version of && is there?
02:03:40 <mauke> huh?
02:03:49 <latros> both :: (a->Bool) -> (a->Bool) -> (a->Bool)
02:03:58 <latros> both p1 p2 x = p1 x && p2 x
02:04:04 <latros> this doesn't already exist, does it?
02:04:14 <mauke> I don't think so
02:04:16 <mauke> :t all
02:04:16 <vodik> liftA2 (&&)
02:04:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:04:20 <vodik> :t liftA2 (&&)
02:04:21 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
02:04:25 <latros> oh
02:04:28 <latros> thanks
02:04:35 <vodik> np
02:04:50 <vodik> i just "discoverd" this on my own earlier today
02:04:50 <Jafet> :t \x -> all ($x)
02:04:51 <lambdabot> forall a. a -> [a -> Bool] -> Bool
02:04:52 <Ragnaroek> is it possible to make an monadic function an instance of Typeable?
02:05:09 <quicksilver> that doesn't make sense Ragnaroek
02:05:15 <quicksilver> types are instances of Typeable
02:05:17 <quicksilver> not values
02:05:19 <Ragnaroek> why?
02:05:26 <timthelion> Is there a way to use conditionals in Haskell patern matching?  Like f x>0 = show x;f x = "_"++(show x)?
02:05:37 <latros> that can't just be liftM2, can it?
02:05:39 <vodik> timthelion: guards
02:05:42 <srhb> :t ((&&) .)
02:05:43 <lambdabot> forall (f :: * -> *). (Functor f) => f Bool -> f (Bool -> Bool)
02:05:49 <quicksilver> monadic function types (like Int -> IO Char, perhaps) are certainly instances of Typeable though.
02:05:49 <latros> @src liftA2
02:05:49 <lambdabot> liftA2 f a b = f <$> a <*> b
02:05:54 <latros> @src liftM2
02:05:54 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:06:00 <timthelion> vodik: thanks
02:06:05 <latros> are those equivalent?
02:06:10 <latros> (assuming your type is a monad)
02:06:15 <Ragnaroek> of then the monadic function type an instance of Typeable?
02:06:17 <vodik> :t liftM2 (&&)
02:06:18 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
02:06:23 <quicksilver> > typeOf (\x -> putStrLn (chr x : []))
02:06:23 <Ragnaroek> -of +ok
02:06:24 <lambdabot>   Int -> IO ()
02:06:26 <latros> types are the same, I knew that
02:06:34 <vodik> latros: depends, applicative are more general
02:06:34 <quicksilver> Ragnaroek: yes, for example ^^
02:06:36 <latros> yeah
02:06:38 <latros> I knew that
02:06:41 <merijn> latros: Not necessarily, but they should be for any code whose author doesn't want to get lunched :)
02:06:42 <latros> but assuming both are monads
02:06:44 <latros> ah
02:06:47 <latros> k
02:06:50 <merijn> Eh, lynched
02:06:53 <mauke> latros: http://mauke.hopto.org/tmp/flow.png
02:07:01 <vodik> latros: liftA (&&) should work on pure functions actually, but without the short ciructing, iirc
02:07:02 <merijn> Although I guess getting "lunched" is also not very pretty
02:07:03 <quicksilver> Ragnaroek: all non-polymorphic types shoudl be typeable.
02:07:21 <mauke> vodik: all functions are pure
02:07:42 <vodik> right, but compared to liftM2?
02:07:43 <latros> I think I want the shortcircuiting, actually
02:07:50 <latros> so I think I'll do this directly
02:07:59 <latros> (these tests are a teeny tiny bit expensive)
02:08:02 <mauke> vodik: huh?
02:08:06 <vodik> nm
02:08:13 <cemycc> latros, merijn: I am trying to use where, but i am doing something wrong: http://codepad.org/qXgnM9Zx Can you please check ?
02:08:37 <latros> you need the where on the next line
02:08:38 <Jafet> > liftM2 (&&) (odd . head) (even . tail) [2,undefined]
02:08:39 <lambdabot>   No instance for (GHC.Real.Integral [a])
02:08:39 <lambdabot>    arising from a use of `GHC.Real....
02:08:44 <Jafet> > liftM2 (&&) (odd . head) (even . last) [2,undefined]
02:08:48 <lambdabot>   mueval-core: Time limit exceeded
02:08:56 <Ragnaroek> so it makes some sense. I have to understand TypeRep then :)
02:08:56 <Jafet> @slap lambdabot
02:08:56 * lambdabot loves lambdabot, so no slapping
02:09:01 <Jafet> > liftM2 (&&) (odd . head) (even . last) [2,undefined]
02:09:03 <lambdabot>   False
02:09:05 <mauke> cemycc: why do you think you're doing something wrong?
02:09:39 <cemycc> mauke: Because when I load the source code, I get this error: Occurs check: cannot construct the infinite type: a0 = a0 -> t0
02:09:51 <mauke> cemycc: what is the type of egcd supposed to be?
02:09:52 <latros> ah so it isn't a syntax error
02:10:03 <merijn> cemycc: What's the type of "t"?
02:10:13 <merijn> t (s-(q*t)) <-- suspicious line
02:10:22 <merijn> I suspect t is not supposed to be a function...
02:10:37 <latros> he meant to make a tuple
02:10:39 <mauke> merijn: line 1 is also suspicious
02:10:41 <latros> I think
02:10:53 <latros> line 1 is correct
02:10:56 <mauke> latros: no
02:11:13 <latros> at least if he's following the wiki example
02:11:15 <latros> oh wait no sorry
02:11:18 <latros> needs to return tuples
02:11:19 <latros> nvm
02:11:19 <merijn> mauke: Yeah, you're right
02:11:22 <latros> tired
02:11:33 <latros> have been playing with this for way too long
02:11:40 <latros> should have slept 3 hours ago
02:12:02 <cemycc> mauke: get 2 integers and return 2 integers, "t" is a member of a tuple
02:12:11 <mauke> cemycc: that's not a type
02:14:15 <Saizan> cemycc: to return a pair of integers you have to contruct it with (,)
02:14:34 <Saizan> > (1,2)
02:14:34 <lambdabot>   (1,2)
02:14:45 <quicksilver> mauke: if ditaa was slightly better it would be great for diagrams like that - http://bit.ly/zPccya
02:14:52 <quicksilver> mauke: the text alignment is a bit ugly though
02:15:30 <Saizan> cemycc: so you probably want "egcd a b = (t , s-(q*t)) ..."
02:16:15 <Saizan> cemycc: also, if you return a tuple in one case you have to do so in all of them, so "egcd a 0 = 1" is wrong
02:16:33 <Saizan> cemycc: because 1 is not a tuple
02:18:10 <cemycc> Saizan: I understood now, thanks for the help
02:18:21 <Ragnaroek> I can derive Typeable, nice :)
02:18:34 <quicksilver> Ragnaroek: yes, and you should :)
02:18:44 <quicksilver> Ragnaroek: writing your own instances is fiddly and you might make a mistake.
02:18:53 <quicksilver> probably it shouldn't really allow custom instances
02:19:15 <Ragnaroek> that's what I tried, but it is hard to do it
02:21:39 <Rc43> Hi, guys.
02:22:04 <Saizan> cemycc: np
02:22:07 <Rc43> Anybody has used cairo/diagrams on windows?
02:33:39 <MaskRay> are there any blogs/tutorials/guides on language-c?
02:36:50 <merijn> MaskRay: language-c?
02:37:48 <MaskRay> merijn: http://www.sivity.net/projects/language.c/
02:38:32 <merijn> oh, that looks interesting
02:41:53 <Ragnaroek> how do they handle macros?
02:42:42 <Phlogistique> Ragnaroek: with an external preprocessor
02:42:45 <MaskRay> I want to make the C src generated by jhc compiled by C89 or C++2003
02:44:29 <Ragnaroek> so there will be no correspondence between non-preprocessed and preprocessed code?
02:44:52 <Phlogistique> so it seems.
02:45:00 <MaskRay> Ragnaroek: it seems to use external c preprocessor
02:46:48 <Rc43> Is there a graphics library for haskell without any problems with windows and not too old?
02:47:33 <Rc43> And what do you think about qt bindings? Is it convinient?
02:48:20 <Rc43> There are some pretty looking libs, but there pain with installing on windows with it.
02:49:01 <_Mikey> Hi guys, what are the most common development methods in Haskell?
02:49:16 <_Mikey> I know of Data Driven programming, but are there any others?
02:49:16 <Rc43> I liked `diagrams`, but installing it is pain.
02:50:14 <Phlogistique> _Mikey: what's "Data Driven programming"?
02:50:47 <RichyB> Rc43, generally, if it's not on Hackage then there isn't a good Haskell library for it.
02:50:59 <_Mikey> where you focus on the types of each function make sure they all match and everything compiles and you have a function for everything you want to do.
02:51:11 <Rc43> RichyB, there are on hackage
02:51:11 <_Mikey> Then tie everything together.
02:51:32 <RichyB> Rc43, AIUI nobody has made any Haskell bindings for Qt. I can't see any on http://hackage.haskell.org/packages/archive/pkg-list.html
02:51:34 <Rc43> RichyB, but I have to install cairo and cairo bindings etc in example with `diagrams`
02:51:46 <latros> any hackish suggestions for how to retrieve just a single field from a line of XML?
02:51:46 * hackagebot xturtle 0.1.2 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.2 (YoshikuniJujo)
02:51:49 <chu> Have you looked at gloss? Not sure if it matches what you want...
02:51:53 * latros doesn't want to learn how to use an XML library right now
02:52:09 <chu> Rc43: http://hackage.haskell.org/package/gloss
02:52:09 <Rc43> RichyB, about qt: http://qthaskell.berlios.de/ didn't look it on hackage
02:52:39 <Rc43> chu, will look now
02:53:12 <Rc43> chu, looks fine, have you used it?
02:53:57 <Rc43> ooo, http://dac4.designacourse.com:8000/
02:53:59 <Rc43> cool
02:54:16 <chu> Nah, sorry. I just know it's used for the first year assignments here.
02:55:43 <Rc43> chu, sorry, what do you mean by `first year assignments`? (Is it an idiom?)
02:56:38 <chu> Ahh, there's a first year course on Haskell here, and they use gloss for the assignments (it's usually something like write Conway's game of life, etc)
02:57:52 <Rc43> chu, ok, anyway thanks
03:01:16 <chu> There's probably some example code here if you want: http://cs.anu.edu.au/student/comp1100.2009/assignments.php
03:05:46 <ChristianS> if people talk about the State monad, do they mean Control.Monad.State from the mtl package?
03:05:55 <shachaf> ChristianS: Usually.
03:06:28 <ChristianS> shachaf: ok, thanks
03:08:50 <ChristianS> there is a lazy and a strict version of the State monad, is there a reason (in general) to prefer one over the other?
03:09:37 <quicksilver> well naturally there are reasons :)
03:09:50 <quicksilver> it's probably more often the case you want the strict one
03:09:57 <quicksilver> that avoids building up thunks in the state parameter
03:10:05 <quicksilver> which can make long calculations waste memory / stack space
03:10:56 <quicksilver> the lazy one lets you do clever tricks such as building up a long and complicated (indeed, infinite) operation and then only demanding enough computation to satisfy the information you actually extract.
03:11:10 <quicksilver> this is clever but in my limited experience the less common situation.
03:11:12 <ivanm> preflex: seen chrisdone
03:11:12 <preflex>  chrisdone was last seen on #haskell 11 days, 23 hours, 15 minutes and 47 seconds ago, saying: alpounet: without sounding obnoxious, something like shell "find" [".","-name *.hs"]?
03:11:34 <Saizan> btw, to not build up thunks with the strict one you've to make sure to observe the state regularly
03:12:10 <Saizan> and make the evaluation of the next action depend on that observation
03:13:52 <ChristianS> quicksilver: i see, thanks
03:14:21 <ChristianS> Saizan: hm, i would have supposed the strict version to avoid thunks anyway?
03:15:03 <Saizan> ChristianS: no, because it's only being stricter in how it takes apart the tuple holding the state and the result
03:15:20 <stefanp> Hi, I'm tryinh to build haskell-platform 2011 on os x lion / homebrew and get tons of "warning: missing terminating ' character"
03:15:23 <ChristianS> ah, ok
03:15:26 <stefanp> anyone seen this?
03:15:53 <merijn> stefanp: Why not just install the OSX version of haskell platform?
03:16:04 <merijn> Rather than compiling from scratch
03:16:19 <srhb> stefanp: I think I saw it when i tried to install the homebrew version. I just downloaded the package instead, worked flawlessly.
03:16:38 <stefanp> well it should work, right? and I prefer to have it integrated with my regular package management.
03:16:54 <srhb> What is your regular package management?
03:16:55 <stefanp> ok will go for this now, on this box im installing it only to get pandoc
03:17:00 <stefanp> homebrew
03:17:25 <stefanp> what you do these days on os x if you need unix tools and frequently build other stuff from source, IMHO
03:17:28 <srhb> stefanp: Yeah, there's been lots of breakage there, also with Haskell.
03:17:57 <srhb> stefanp: Cry silently and consider switching to Linux every day. At least, that's what I do. I remember when homebrew used to be good and macports was crap. Now Homebrew is suffering from the exact same problems, and it just keeps getting worse.
03:18:12 <Rc43> Can I update ghc with cabal? I am on windows.
03:18:56 <rostayob> it's funny because mac people always tell me "this is great, that is great, and you have all the unix tools!"
03:18:58 <merijn> srhb: Which problems does macports suffer from? I've never run into any
03:19:13 <srhb> rostayob: Yep, I remember those days..
03:19:24 <merijn> rostayob: It is great and I have all the unix tools! :>
03:19:52 <stefanp> srhb he.. I will if the gnome and kde guys ever get their act together to deliver a decent user experience... maybe after wayland becomes the default but I doubt it there seems to be darn tricky freedom-quality of integration tradeoff involved
03:19:53 <merijn> I've never had any problems whatsoever using macports
03:19:54 <rostayob> merijn: except little details like an up to date gcc?
03:20:01 <rostayob> (from what I hear)
03:20:03 <srhb> merijn: Stale versions, incompatibilities, mucking up paths, incompatibilities with the regular OS X toolchains, etc. etc. All the things Homebrew professed to fix.
03:20:08 <merijn> rostayob: You can install that from macports
03:20:26 <merijn> Although, tbh I'm slowly switching to clang anyway
03:20:32 <merijn> Because f gcc
03:20:36 <rostayob> all i know is that people are continuously complaining about developing on gcc
03:20:37 <srhb> But nevermind, I'm just venting. Everything used to work, and I had all the UNIX tools! :'\
03:20:50 <rostayob> *with gcc, on mac
03:21:08 <merijn> rostayob: Well, sure if you're doing stupid GNU extension stuff it's probably an issue
03:21:37 <merijn> rostayob: But I come from a BSD background anyway, so I never got into bad GNU habits
03:21:51 <rostayob> also, the whole clang story is a disaster because clang is not GPL. I can already imagine companies publishing binary blobs as clang backends for their architectures or stuff like that
03:22:40 <merijn> Meh
03:23:24 <merijn> What's the motivation to pushing binary blob backends? (I guess maybe in embedded? But I'm not really involved in embedded stuff)
03:23:44 <merijn> In my experience so far clang is just a much more pleasant compiler to work with
03:23:57 <rostayob> merijn: yes, for example embedded. the point is that with gcc that stuff can't happen
03:24:11 <mux> it's high time to realize that GPL never ever helped preventing companies from releasing closed-source stuff, there's like several decades worth of example already...
03:24:34 <rostayob> mux: what? that's not true
03:24:43 <merijn> rostayob: As I said, I come from a BSD background so I've never been that into the GPL stuff anyway
03:25:27 <rostayob> it's not about GPL or BSD "background", I think the programming world is a better place is the standard compiler is GPL
03:25:40 <rostayob> but anyways this is not a discussion for #haskell
03:25:40 <mux> and we are many to disagree on that
03:25:44 * mux nods
03:26:06 <mux> some of us are actually pushing for clang specifically because it's not GPL.
03:26:23 <rostayob> mux: can we move this to -blah?
03:26:33 <mux> rostayob: sure, I'm done anyways
03:27:07 <rostayob> mux: I'm really curious to know why BSD would be better than GPL for a compiler. what are the advantages?
03:27:14 <rostayob> a link will suffice ehe
03:28:15 <Axman6> "also, the whole clang story is a disaster because clang is not GPL. I can already imagine companies  publishing binary blobs as clang backends for their architectures or stuff like that"
03:28:49 <rostayob> Axman6: well that's why the GPL is better, not worse
03:29:16 <Axman6> like nvidia's PTX backend? or all the other manufacturers who've contributed their code to the LLVM project?
03:29:16 <geekosaur> if your reluigion is that GPL is the only good, nothing will convince you.  if you think being able to use something without having to check the license first is important, you just might want to avoid the GPL
03:29:46 <mauke> you can never just use something without checking
03:29:50 <stefanp> even when using cabal to install pandoc, i still get these weird "warning: missing terminating ' character" errors, seemingly coming from happy
03:29:52 <geekosaur> but since the GPL religion is that without GPL everything will always be released as proprietary (that is, BSD actually doesn;t exist at all in their mythology)...
03:29:59 <Axman6> rostayob: the GPL is a cancer that stops companies that need to make a profit from contributing to open source code
03:30:01 <mauke> (but if the license is the gpl, then you can indeed just use it)
03:30:13 <rostayob> geekosaur: no, I don't say that, for a lot of libraries something more liberal makes more sense
03:30:23 <merijn> People: -blah?
03:30:25 <rostayob> but for something like gcc (or linux) the GPL makes much more sense
03:30:28 <mauke> yes
03:30:34 <Axman6> the Clang project is almost completely made of libraries
03:30:34 <stefanp> now installing the macpors binary package over my homebrew system... sigh
03:32:09 <Axman6> the whole LLVM project is designed to be a set of easy to use libraries. almost all the work in the project has been done by the biggest companies in the tech industry: Apple, Google, Adobe, nvidia, AMD. the idea that the GPL is necessary for open source work to come from big companies is utter nonsense, and obviously just untrue
03:33:53 <mauke> Axman6: #haskell-blah
03:33:54 <Axman6> rostayob: why should Apple be forced to release _all_ their Xcode source, because they decided to use a GPL'd project? There are many good reasons for not doing such a thing (one of which is to avoid fragmentation, which is something the GPL causes all the time)
03:33:57 <mauke> Axman6: #haskell-blah
03:34:08 <quicksilver> Axman6: off this channel
03:34:08 <Axman6> sorry, wasn't sure if the discussion had moved =)
03:35:08 <ivanm> so I've worked out why my attoparsec parser worked and my parsec and polyparse ones failed...
03:35:29 <ivanm> in Char-based parsers, (/= '0') isn't equivalent to (/= 0) in Word8-based parsers :s
03:35:50 <mauke> duh?
03:36:13 <ivanm> yeah, shuddup :p
03:36:21 <mauke> > '\48'
03:36:22 <lambdabot>   '0'
03:37:30 <ivanm> I haven't done all that much binary stuff
03:38:01 <Philippa> ...and there was me about to comment that the world's a better place when the standard compiler isn't intentionally obfuscated. Oh well.
03:38:40 <Philippa> oh, right, -blah, sorry
04:06:39 <b0fh_ua> Hi! I'm trying to install cabal-install and getting missing dependencies: http://hpaste.org/64791
04:06:50 <b0fh_ua> what exactly it miss here?
04:07:15 <b0fh_ua> version of GHC is 7.4.1
04:08:52 <mauke> base >=4 && <3
04:08:55 <mauke> you're screwed
04:09:08 <adimit> I'm not sure cabal-install actually compiles with 7.4.1
04:09:14 <b0fh_ua> nice :)
04:09:27 <adimit> you'll have to compile cabal-install with 7.0.4 or so.
04:09:41 <b0fh_ua> awesome
04:09:48 <quicksilver> fortunately, cabal-install doesn't have to be compiled with the same version you're using
04:09:51 <quicksilver> (unlike libraries)
04:10:00 <adimit> then you can upgrade your compiler. If you ask me, it's not worth it, just stick with 7.0.4, unless you have to use some features of 7.4.`
04:10:05 <adimit> *7.4.1
04:10:06 <quicksilver> but yes you need cabal-install 0.8 or later compiled by some earlier version.
04:10:36 <quicksilver> new GHC versions are not normally worth the hassle until someone has upgraded the more important libraries for the new release
04:10:52 <Axman6> why isn't cabal-install part of the GHC release anyway? it seems to break for each new release, why not make sure they work together?
04:12:03 * b0fh_ua will try to go with 7.2
04:12:17 <quicksilver> they try to minimise deps Axman6 but personally I agree that would be a good idea.
04:13:58 <adimit> the most annoying thing about 7.0.4, which makes me want to switch to 7.4 asap, are these endless SpecConstr warnings I get with -Wall.
04:15:55 <b0fh_ua> damn, it doesn't build with 7.2 as well
04:16:15 <adimit> b0fh_ua: afaik, 7.0.4 is the last it built on.
04:16:32 <b0fh_ua> brilliant :)
04:17:34 <b0fh_ua> I suspected that haskell is mostly for academic purposes - not for production, now I start to believe in it.
04:17:48 <merijn> Why?
04:18:33 <b0fh_ua> merijn: because cabal is something which supposed to be a package manager, and nobody cares of making it working with last versions of language itself.
04:18:40 <merijn> Just a matter of "don't try and use the bleedingest edge version when you're not actually developing"
04:18:48 <Ywen> /join #haskell-fr
04:19:00 <b0fh_ua> 7.2 is bleeding-edge?
04:19:10 <chu> Therefore is an academic language. QED.
04:19:18 <mauke> b0fh_ua: yes
04:19:27 <b0fh_ua> and 7.0 is mature?
04:19:29 <merijn> chu: Yeah, because people are not still using python 2.3/2.4
04:19:39 <merijn> b0fh_ua: 7.2 is the experimental release series
04:19:53 <merijn> 7.4 will be stable, but you probably shouldn't use it until Haskell Platform is updated to use it
04:20:04 <chu> merijn: I don't agree with the claim at _all_ but I disagree with his (her?) complaint.
04:21:09 <Philippa> "they" is a handy gender-neutral pronoun that's widely understandable and in use all over the 'net, btw
04:21:10 <merijn> b0fh_ua: In general I just use whatever the latest version of Haskell Platform uses. That is usually (almost always?) as new as you need
04:21:43 <Philippa> yeah, any version of GHC that's not part of the platform should be considered a beta with respect to the rest of the ecosystem
04:21:44 <chu> Yeah true Philippa.
04:23:26 <Philippa> it's annoying when you want to use the latest type system features, but really that's life. Anyone feel like organising some kind of fund for a "platform-like" release based on newer GHC releases?
04:24:20 <merijn> The cutting-edge features tax :p
04:24:50 <Philippa> well, the /other/ cutting-edge features tax. The current one is to do the build work yourself
04:25:49 <Philippa> b0fh_ua: if you want to do production work, you should be using the Platform. Or failing that, taking on the responsibility for keeping your own setup stable. That's what the Platform's for, it's not /just/ a batteries-included setup
04:28:07 <Philippa> (I'm saying this and I have a /huge pile/ of stuff to play with using ConstraintKinds myself, FWIW)
04:29:23 <Philippa> 'lo edwinb
04:31:27 <b0fh_ua> okay, thanks
04:31:34 <b0fh_ua> so platform is "stable"
04:31:44 <b0fh_ua> anything else is "beta" and out of support ;)
04:32:04 <Jafet> The platform has support?
04:35:53 <b0fh_ua> http://www.haskell.org/ghc/download the 7.4.1 is called "stable release" here
04:35:57 <edwinb> hi Philippa. I forgot I'd dropped off here ;)
04:36:19 <adimit> b0fh_ua: the *compiler* is stable. The ecosystem is another matter.
04:36:29 <merijn> b0fh_ua: It's a stable release of the compiler, yes. But the compiler authors don't fix all the software packages
04:36:37 <adimit> kinda like python 3.x has stable releases, but most of hte environment doesn't support it.
04:36:53 <b0fh_ua> okay, that's fair
04:36:57 <merijn> b0fh_ua: Sorta like how clang is stable, but most stuff still doesn't compile with it
04:37:14 <merijn> b0fh_ua: The explicit goal of Haskell Platform is to test and make sure all major packages compile and work
04:37:30 <merijn> b0fh_ua: Next release of platform will probably move to 7.4, I guess?
04:37:33 <ChristianS> cabal doesn't yet support ghc 7.4.?
04:37:48 <adimit> ChristianS: it doesn't build on it, no.
04:38:19 <ChristianS> b0fh_ua: i don't care much for the platform, but you *should* stick with the latest stable ghc version that works with cabal. cabal is essential.
04:39:47 <b0fh_ua> ChristianS: it seems that cabal itself needs to be only built somehow with some old version, and then it's ok to use latest version of GHC with cabal
04:40:33 <quicksilver> b0fh_ua: you mean cabal-install.
04:40:43 <quicksilver> ChristianS: and so do you.
04:40:49 <quicksilver> all versions of GHC come with cabal.
04:40:54 <b0fh_ua> quicksilver: yep
04:40:55 <ChristianS> quicksilver: true
04:41:06 <quicksilver> it's regrettable that the manifestion of 'cabal-install' is a tool called 'cabal'
04:41:16 <quicksilver> naming errors - they haunt you forever.
05:02:06 <t7> has anyone got the regex to parse haskell source ?
05:02:25 <merijn> regex to parse haskell source?
05:02:49 <t7> yeah
05:02:51 <quicksilver> nice try, no cigar, please troll again soon.
05:02:52 <merijn> Such a regex can't exist, since haskell is not a regular grammar...
05:03:00 <Jaak> "regex to parse" wut
05:03:07 <t7> troloool
05:03:16 <t7> 10 points
05:03:33 <mauke> t7: yes, here: http://mauke.hopto.org/stuff/perl/hscomm.pl
05:04:27 <quicksilver> 20 points to mauke.
05:07:08 * hackagebot egison 1.1.0 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.1.0 (SatoshiEgi)
05:22:10 * hackagebot textPlot 0.2 - Plot functions in text.  http://hackage.haskell.org/package/textPlot-0.2 (WilliamMurphy)
05:22:25 <t7> satoshi... ?
05:37:09 <etpace> What's the difference between WHNF and HNF?
05:38:05 <Philippa> any lambda at top level is in WHNF
05:39:19 <hiptobecubic> so a lexer converts a text stream to tokens and a parser reads them and interprets them?
05:39:19 <lambdabot> hiptobecubic: You have 1 new message. '/msg lambdabot @messages' to read it.
05:39:38 <Philippa> hiptobecubic: that's one standard usage, yes
05:39:45 <Philippa> (some parsers just use characters as tokens, though)
05:40:01 <Philippa> also, where "interprets" really means "figures out how they fit a grammar"
05:40:22 <Axman6> anyone know if repa can be made to work on 7.4?
05:40:34 <Philippa> (though that gets generalised - you can do rather more than fit to a parse tree with something like Parsec)
05:41:51 <Philippa> etpace: it appears that another way of defining HNF might be that the top level isn't a redex, and if it's a lambda then the lambda's body is also in HNF
05:42:00 <Philippa> WHNF doesn't have the latter requirement
05:42:11 <hpaste> Axman6 pasted “Repa install error” at http://hpaste.org/64792
05:42:21 <Axman6> anyone know how to fix that?
05:46:50 <hiptobecubic> What is "Overture"?
05:48:19 <applicative_> Axman6: http://repa.ouroborus.net/#Fromthesourcerepo I remember one  or two of the repa-blah subdirectories had a cabal curiosity
05:49:12 <_Mikey> Hey,
05:49:28 <_Mikey> how does one go about modelling a program in a functional language??
05:49:37 <_Mikey> s /?? /?
05:50:52 <Botje> what do you mean by 'modelling' ?
05:50:52 <osfameron> _Mikey: that's a good broad question ;-)  You could try looking at Real World Haskell, which has several examples of that.
05:51:07 <osfameron> ah, good question.  Perhaps I misinterpreted "modelling"
05:51:19 <Botje> representing source code? code flow? data flow? generating UML diagrams? evaluating them?
05:51:35 <Botje> all of the above? ;)
05:51:58 <_Mikey> yes
05:52:01 <_Mikey> like UML
05:52:14 * hackagebot happstack-server 6.6.4 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.6.4 (JeremyShaw)
05:52:16 * hackagebot happstack-server-tls 6.0.1 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-6.0.1 (JeremyShaw)
05:52:23 <mauke> who uses UML?
05:52:26 <_Mikey> a lot of what I'm reading is telling me use Data types in Haskell and then quick checks
05:52:37 <_Mikey> mauke, imperative people?
05:52:45 <mauke> no
05:52:54 <_Mikey> but I'm wondering if I can find that written down in a book somewhere,
05:53:00 <efie> UML is not limited to OOP?
05:53:04 <Philippa> poor bastards whose bosses want them to. Also, a lot of unis still teach it
05:53:29 <Philippa> efie: it's founded in OOA/D, though
05:53:44 <Philippa> obviously you can adapt a long way
05:53:56 <Botje> _Mikey: your data structures are typically determined by the operations you want to do on them, so what kind of UML model do you want to make?
05:54:33 <Philippa> _Mikey: mostly we do old-school structured programming stuff, except we've got more ability to abstract
05:54:39 <_Mikey> Botje: I'm aiming to model the code flow of my application.
05:54:44 <Philippa> we also use a lot of EDSLs though, which can be good for modelling
05:55:06 <Botje> _Mikey: on the function/method level? or finer than that?
05:55:19 <_Mikey> Philippa, ok, do you mean using Type signatures to lay out a structure?
05:55:27 <Philippa> and what do you want to be able to do with your model? Just introspect it as source, or something more involved?
05:55:41 <_Mikey> Botje, on the function level would be fin.
05:56:16 <_Mikey> Philippa, just for documentation of my project really.
05:56:20 <Philippa> _Mikey: really I mean a collection of techniques that were around prior to the big 90s OO craze. Modular design, various flow diagrams etc etc
05:56:48 <Philippa> you might find a function-level dependency graph useful, for example
05:57:04 <Philippa> (which will be a partial model of code flow as well, just one with no notion of 'time')
05:57:08 <_Mikey> Philippa, ok, thanks!
05:58:11 <Philippa> using type signatures and stub functions can also be useful if you're after that kind of model of course
05:58:40 <_Mikey> Yea, I've found that really useful during development
05:58:40 <DrSyzygy>  
05:59:10 <_Mikey> Philippa, but I was just wondering if there is a standard 'Haskell' way of doing things
05:59:20 <Philippa> there's no single standard
05:59:40 <Philippa> really, Haskell's community has a TIMTOWTDI approach to things
06:00:03 <efie> are there excercises from which one can learn how do deal with / how to develop own monad instances? Like "Imagine situation X. Find a proper data type. Make it an instance of funktor / monad, proof that the 3 laws hold true. Using the monad, solve the following ... " and so on + solutions
06:00:28 <deggis> Axman6: i guess the traditional way to install a hackage package with an upper bound (requires 4.4.*, you have 4.5) is to download the package to disk, change the upper bound, try installing and see if it works
06:00:52 <Philippa> efie: for building out of monad transformers, or building from scratch? I find it's easiest to approach the latter as straight-up language design
06:00:57 <Axman6> deggis: yeah, that's what i ended up doing
06:01:04 <Philippa> you can even write your first implementation as an interpreter if you want to
06:01:11 <deggis> Axman6: i'm also interested in using repa with 7.4. did it work?
06:01:15 <applicative_> Axman6, no I see all of the packages in repa-head (repa-3.0.0.0) seem to have built
06:01:38 <Axman6> deggis: from my very limited testing yes
06:01:47 <Philippa> on a separate note, did anyone ever propose a sensible "codo" notation?
06:02:31 <efie> philippa: I'm uncertain when to make own monad instances / how to really do it (though i read some examples) and I'd like to practise this
06:02:44 <deggis> Axman6: oops. i should've learned this by now. instead of taking the newest hackage package and doing that, a better way is to darcs get repa from http://repa.ouroborus.net/
06:03:13 <deggis> hackage knows repa 2.3, newest repa-head is 3.0 :o
06:04:44 <deggis> Axman6: repa 3.0 requires base 4.5.* as applicative_ hinted
06:05:00 <Axman6> ah, well that's good to hear actually =)
06:05:05 <Philippa> did I miss anything?
06:05:10 <deggis> solved my problem as well, yay
06:05:11 <Axman6> means it's using some of the advances in the latest release
06:07:14 <Philippa> efie: fair enough. I don't have a good set of exercises to hand. Personally I recommend building a new instance the moment you want something that's not covered by existing instances but should make an okay "haskell-like language" (definition to be supplied) and covers how you want to express your code. Mileage varies on that. I also recommend building instances from existing instances where
06:07:15 <Philippa> possible! Wrapping existing monads or transformer stacks is pretty effective
06:08:00 <Philippa> writing an interpreter for a language and bolting on features is a good way to explore the monad transformers from the libs, at least
06:08:16 <Philippa> feel free to skip writing a parser in favour of just building AST nodes in Haskell!
06:08:57 <efie> I don't think I'm ready for transforms and such thanks
06:08:58 <efie> thanks :)
06:09:00 <Philippa> if you write yourself a typechecker that does inference for the simply-typed lambda calculus or Hindley-Milner you'll quickly find yourself wanting a monad to pipe around your typing problem too
06:09:03 <efie> things*
06:09:11 <Philippa> transformers're actually easier than writing your own instance from scratch
06:09:20 <_Mikey> is there a specific chapter in RWH which focuses on the design of programs? other than the JSON library chapter
06:09:23 <Botje> efie: I wrote some exam questions that were basically 'implement a monad that does x'
06:09:32 <Botje> but I can't really give them away :
06:09:40 <Philippa> Botje: or at least, not yet I assume
06:10:09 <efie> botje: exam questions? are they for university?
06:10:23 <Botje> efie: yes, I'm the TA for a course on functional programming.
06:10:33 <Philippa> _Mikey: aside from having to build 'dataflow piping' of various sorts, you can treat it just like old-school procedural programming and it'll work out
06:10:35 <efie> okay
06:10:35 <efie> :)
06:11:03 <_Mikey> Philippa, ok thanks.
06:11:07 <Philippa> I guess I count as an old fart now if I can say something like that and have to realise there's plenty of programmers out there who never met that stuff, though :-)
06:11:22 <_Mikey> hehe
06:12:01 <Philippa> efie: does it make sense when I say "write an interpreter"?
06:12:06 <Philippa> (to implement a new monad)
06:12:15 <Jafet> Mikey: ...most of them?
06:14:36 <hiptobecubic> Philippa, it doesn't really make sense to me.
06:15:12 <Philippa> hiptobecubic: okay, guess I get to write the identity monad as a deep embedding yet again :-)
06:15:47 <Philippa> data Identity a where Return :: a -> Identity a; Bind :: Identity a -> (a -> Identity b) -> Identity b
06:15:50 <hiptobecubic> Philippa, i'm still learning about monads and categories. Had a nice long talk last night with DrSyzygy about it :)
06:15:54 <_Mikey> Jafet, I'm looking for something which says "It's a good Idea to model your haskell programs like this...."
06:16:01 <Philippa> there's the syntax for the lang corresponding to the identity monad
06:16:01 <_Mikey> It doesn't really do that.
06:16:44 <Philippa> _Mikey: one good way is as lots of programs in DSLs, interacting via thin layers of glue code. Think *nix shell scripting, in Haskell
06:17:00 <Axman6> _Mikey: many people tend to start with the data types they're going to need. then implement the functions for working with them, then writing modules that bring it all together. how you do that will probably be different for each project however
06:17:36 <Philippa> hiptobecubic: when you come to write your class instance, return = Return, (>>=) = Bind and you have to hide Identity's constructors to avoid breaching the monad laws. Need to see the interpreter as well?
06:17:41 <Jafet> I've seen many different ways to model Haskell programs
06:18:06 <Jafet> There is nothing you can look at that will instantly convey how to design software
06:18:06 <Philippa> Jafet: yeah, there's a lot and most have their uses. That's one reason there aren't many "just do this" recommendations
06:18:33 <osfameron> probably most of the advice in, say, Code Complete, applies as much to FP as to imperative/OO programming
06:18:50 <osfameron> it's all about how you decompose the problem
06:20:20 <Philippa> having pervasive, cheap parametric polymorphism does change things a little though
06:20:42 <_Mikey> Philippa, I like the DSL idea,
06:20:58 <Philippa> but I think the biggest piece of advice I'd offer is to try to write code that's high level in the Perlis sense
06:21:05 <Philippa> (plus the code needed to enable that)
06:22:15 * hackagebot layout-bootstrap 0.2 - Template and widgets Bootstrap2 to use with Text.Blaze.Html5  http://hackage.haskell.org/package/layout-bootstrap-0.2 (AlexanderBondarenko)
06:22:59 <Philippa> parametric polymorphism's also remarkably effective at helping strip out the irrelevant
06:26:08 <merijn> _Mikey: I think this is a nice walkthrough of (one possible way of) constructing a haskell program: https://www.youtube.com/watch?v=045422s6xik
06:26:21 <merijn> (screencast)
06:26:45 <osfameron> Philippa: what do you mean about "pervasive, cheap parametric polymorphism" changing things?
06:27:56 <Philippa> osfameron: the stuff you get from having an H-M-derived type system rather than, say, STLC
06:28:16 <Philippa> we don't even think about having it most of the time, because the system just figures out where we've got it
06:28:33 <Philippa> but once we know it's there, we can use it to make sure we don't overconstrain ourselves
06:29:21 <osfameron> Philippa: sure.  but does that change the *way* you build programs?
06:29:28 <merijn> osfameron: Compared to say Java/C? Sure.
06:29:54 <timthelion> Hello, when I run Clock.hs http://code.haskell.org/gtk2hs/cairo/demo/ I get "Invalid access/enterance to memory (SIGSEGV)"(rough translation from Czech)
06:29:55 <Philippa> massively, unless your starting point is dynamic typing where you can pretend you've got the same and hope nobody breaks it
06:29:59 <deggis> uh. it seems installing c2hs with ghc 7.4.1 fails with src/Data/Attributes.hs:174:6: "Illegal datatype context (use -XDatatypeContexts): Attr a =>" any hints? (tried newest version from darcs)
06:30:13 <merijn> Much easier to define nice generic combinators to combine your code, which you cannot do in C
06:30:14 <timthelion> Does anyone know if there is some problem with gtk2hs on arch linux?
06:30:31 <timthelion> Given that the example code won't run.
06:30:32 <Jafet> deggis: add DatatypeContexts to the file and rebuild?
06:31:00 <osfameron> Philippa: ah, gotcha.  cos I mostly write in dynamic typed languages, it's very much the same process
06:31:20 <deggis> Jafet: uh, that works. it seems that also cabal install --ghc-options="-XDatatypeContexts" c2hs does too
06:31:22 <_Mikey> thanks merijn!
06:31:24 <merijn> timthelion: The usual Arch wants to be on the bleeding edge problem seems to be a good starting point. Which version of GHC are you using?
06:31:26 <osfameron> again though, I'm not sure it's that different in process from writing Java/C in terms of design of code
06:31:31 <osfameron> it's just faster
06:31:48 <timthelion> Glasgow Haskell Compiler, Version 7.4.1, stage 2 booted by GHC version 7.4.1
06:31:49 <deggis> Jafet: thanks :)
06:31:57 <timthelion> merijn: 7.4.1
06:32:05 <merijn> timthelion: GHC 7.4 is not really that well supported yet by the ecosystem
06:32:08 <Philippa> hah. No, people do dirty shit in langs without parametric polymorphism, or they don't push it as far if it's not cheap and pervasive
06:32:23 <merijn> timthelion: So my blind guess is that gtk2hs just doesn't work with 7.4 yet
06:32:36 <timthelion> merijn: hmph :(
06:32:40 <Philippa> there are subcultures around C that act like they've got it to some extent, but you don't see the same kind of stuff that you do in Haskell there
06:32:46 <merijn> I could be massively wrong, though
06:33:05 <merijn> Philippa: You just hack it in with CPP :D
06:33:16 <timthelion> merijn: I didn't realise that after so many decades of development ghc was still under "rapid development"
06:33:20 <_Mikey> whats CPP?
06:33:32 <merijn> _Mikey: C Pre-Processor
06:33:42 <_Mikey> ahh ok
06:33:43 <merijn> i.e. C macro's
06:34:22 <Jafet> Software that gets used gets developed.
06:34:51 <DrSyzygy> you mean like TeX with its convergent version numbering scheme?
06:35:06 <Jafet> Eh, who uses TeX?
06:35:21 <DrSyzygy> ...
06:35:25 <merijn> The thing stopping people from hacking TeX is lack of Pascal chops :p
06:36:44 <timthelion> Jafet: blind mathematicians.
06:36:46 * osfameron remembers trying to write a presentation in latex-beamer, gibbers in terror
06:36:54 <merijn> Really?
06:37:01 * DrSyzygy routinely writes ALL his presentations in beamer.
06:37:06 <merijn> I rather like beamer
06:37:12 <osfameron> it had some very cute features
06:37:19 <osfameron> I didn't like *debugging* my documents though
06:37:27 <merijn> Compared to the pain I used to have with powerpoint, etc.
06:37:27 <DrSyzygy> *snrk*
06:37:30 <osfameron> especially as the debugger and error messages were very hostile
06:37:32 <DrSyzygy> osfameron: you're weak. :-)
06:37:51 <osfameron> also the hoops you had to go through to do complex stuff like... er... insert pictures
06:38:02 <DrSyzygy> osfameron: What hoops are you talking about?!
06:38:09 <DrSyzygy> \includegraphics{picturenameslug}
06:38:11 <DrSyzygy> Done
06:38:17 <DrSyzygy> If you want to be picky, then
06:38:24 <quicksilver> the error messages are hostile, in many cases
06:38:26 <DrSyzygy> \includegraphics[width=\textwidth]{picturenameslug}
06:38:26 <osfameron> DrSyzygy: I think I had to convert them to some random graphics format I hadn't heard of.  .eps maybe?
06:38:29 <merijn> osfameron: Yeah, if I had a time machine I would go back in time and tell Knuth and Lamport "In 40 years the code you are writing now is the sole program used to typeset CS papers, are you sure you don't want to invest more time in the error messages?"
06:38:41 <DrSyzygy> osfameron: Oooooh, yeah, don't compile beamer with old LaTeX engines.
06:38:50 <DrSyzygy> osfameron: PDFLaTeX or XeLaTeX are your friends here.
06:38:52 <merijn> osfameron: If you use pdflatex you don't need to do
06:39:05 <osfameron> ah
06:39:15 <osfameron> I just apt-got something with latex-beamer in the name
06:39:16 <DrSyzygy> XeLaTeX additionally makes truetype fonts and unicode dead easy to access.
06:39:18 <merijn> Last I checked all common formats work there
06:39:38 <osfameron> this was maybe 5 or so years back
06:39:48 <merijn> Although, to be fair TeX errors are pretty decent. It's just the layer of LaTeX macro's on top that result in unreadable errors
06:39:49 <DrSyzygy> osfameron: Yeeeeeah, things have gotten better since.
06:40:08 <osfameron> I've occasionally felt like using latex again.  Then I just use HTML / MarkDown or OpenOffice till the feeling goes away.
06:40:17 <killy9999> @src Num
06:40:17 <lambdabot> class  (Eq a, Show a) => Num a  where
06:40:17 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:40:18 <lambdabot>     negate, abs, signum     :: a -> a
06:40:18 <lambdabot>     fromInteger             :: Integer -> a
06:40:54 <timthelion> what popular lightweight gtk apps have been written in Haskell?  So that I could test if gtk2hs works at all on my system...
06:41:05 <DrSyzygy> HTML/Markdown or OpenOffice both don't provide the notational power I need.
06:41:13 <DrSyzygy> I routinely write mathematics...
06:41:39 <applicative_> osfameron I notice the new version of pandoc makes beamer slides
06:41:41 <timthelion> DrSyzygy: hehe, you write mathematics :D
06:41:49 <DrSyzygy> timthelion: ... yes.
06:42:02 <timthelion> DrSyzygy: The notation you mean.
06:42:24 <DrSyzygy> timthelion: Well, seeing as I am a research mathematician, I routinely write texts that constitute new knowledge within the field of mathematics.
06:42:25 <statusfailed> Do I need to import something to get the Num instance for Vector from hmatrix?
06:42:26 <osfameron> applicative_: interesting
06:43:10 <statusfailed> this doesn't work for me: let x = fromList [1.0..3.0] in x - x
06:43:41 <timthelion> DrSyzygy: you must be an exceptionally good mathematician if you routinely discover anything that is actually new...
06:44:00 <DrSyzygy> timthelion: How aware are you of the day-to-day business of research?
06:44:20 <DrSyzygy> timthelion: I _have_ to discover actually new things all the time in order to build my career sensibly.
06:44:33 <DrSyzygy> They do not have to be _earthshattering_ new pieces of knowledge, but they do indeed have to be new.
06:44:34 <timthelion> DrSyzygy: matematical reaserch is not my specialty.
06:45:33 <DrSyzygy> my point anyway, regardless of actual density of new knowledge, is that I - on a daily basis - have to write about mathematics, using mathematical notation, and that in Every Single Presentation I give, I have to deal with actual mathematical text.
06:45:43 <DrSyzygy> So OO and HTML/Markdown are horrendously inferior tools.
06:48:14 <applicative_> osfameron, I just tried it with jpeg and png images.  One of them would need to be resized somehow, but otherwise no problem
06:48:45 <applicative_> DrSyzygy: markdown is independent of math, it replaces the latex framing \begin{quote} etc
06:49:10 <DrSyzygy> applicative_: ... so how do I smoothly, and with as good results, insert arbitrary math in a markdown document?
06:49:29 <applicative_> $ $ and $$ $$
06:49:42 <osfameron> presumably it depends in part on what backend you target
06:49:44 <DrSyzygy> and align*? and tikzpicture?
06:49:51 <applicative_> then make a pdf via latex, and html with mathjax etc
06:50:03 <osfameron> if it targets HTML, it'd have to use some library that turns latex to mathml or png ?
06:50:28 <applicative_> mathjax , does the usual AMS things
06:50:41 <merijn> If I want to do awful stuff like "fork, exec, transfer open sockets to new program invocation" I'm better of writing the low stuff in C and using the FFI to start up from there, I guess?
06:50:43 <applicative_> it's actually better looking the tex, i think
06:51:28 <statusfailed> merijn: Transfer open sockets? I didn't even know you could do that :P
06:51:30 <statusfailed> (in C)
06:52:00 <merijn> statusfailed: exec doesn't close sockets, so if you fork then exec you never terminate the sockets
06:52:19 <mauke> but you can also transfer file descriptors to other processes
06:52:27 <mauke> it's black magic
06:52:27 <merijn> As a result you can switch over to a new version of your program without dropping client connections (although there will probably be some lag)
06:52:37 <statusfailed> consider me learninated :D
06:52:40 <statusfailed> that's pretty cool
06:52:42 <Phlogistique> it would be so nice if text editors could format haskell as nicely as it is formatted in research papers
06:52:48 <applicative_> DrSyzygy: here's a ridiculous demo i was helping some biologist with the other day http://scriptogr.am/michaelt the same underlying file makes excellent pdf via latex
06:53:00 <Phlogistique> concealing with vim is ugly because characters are monospace
06:53:32 <applicative_> DrSyzygy: or rather http://scriptogr.am/michaelt/post/using-mathjax-and-pandoc-with-scriptogr.am
06:53:38 <merijn> mauke: That sorta thing is probably unwise to try and implement from Haskell though, isn't it?
06:53:47 <mauke> I don't know
06:53:55 <merijn> Actually...
06:54:00 <merijn> Might not even be that bad
06:54:23 <merijn> I was worrying about shared state going stale (as mentioned in the docs), but of course that's completely irrelevant after doing exec...
06:54:23 <applicative_> DrSyzygy: check out the bibliography support also transfers to html
06:54:51 <statusfailed> merijn: i'd be really interested to see what you come up with
06:56:14 <BlankVerse> i have type Id = String , how do i convert a String type to ID type?
06:56:42 <applicative_> you dont convert the values BlankVerse
06:56:48 <rwbarton> you don't have to, Id and String are the same type
06:56:50 <merijn> BlankVerse: You don't need to, they're just aliases
06:56:56 <applicative_> you just renamed the type
06:57:08 <merijn> BlankVerse: If you want to enforce manual conversion you want newtype rather than type
06:57:14 <BlankVerse> does haskell not follow name equivalence?
06:57:38 <applicative_> unrelentingly
06:58:22 <mauke> what is "name equivalence"?
06:58:56 <ChristianS> BlankVerse: newtype Id = String  will actually give you a new type, type defines just an alias. depends on what you want.
06:59:07 <BlankVerse> thanks guys , got it
06:59:43 <quicksilver> that should be newtype Id = Id String
06:59:56 <merijn> @hoogle Handle -> Fd
06:59:57 <lambdabot> System.Posix.IO handleToFd :: Handle -> IO Fd
06:59:57 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:59:57 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:00:01 <quicksilver> or newtype Id = ChooseSomeConstructorNameWhichMakesYouHappy String
07:00:09 <ChristianS> quicksilver: oops, right
07:02:58 <merijn> statusfailed: Ok, basic outline to the approach would be: fork, collect the handles of all open sockets, use handleToFd to get the file descriptors, pass all the file descriptors as arguments to exec, in the new process use fdToHandle to create handles for each file descriptor and proceed to update your state so you can continue running
07:03:35 <merijn> (You probably want some pipe/file based mechanism to transfer state between the old and new process so you know how to carry on)
07:07:33 <earthy> middag
07:12:09 <DxBlueIce> hey, can anyone help creating a 3d room using a textfile with hopengl?
07:12:15 <merijn> @pl (f $ g $ h)
07:12:16 <lambdabot> f (g h)
07:12:17 * hackagebot Unixutils-shadow 1.0.0 - A simple interface to shadow passwords (aka, shadow.h)  http://hackage.haskell.org/package/Unixutils-shadow-1.0.0 (JeremyShaw)
07:12:50 <merijn> @pl f $ (g $)
07:12:50 <lambdabot> f g
07:14:18 <ChristianS> DxBlueIce: better ask about your specific problem if you have some, the channel won't write your programs for you.
07:17:17 * hackagebot layout-bootstrap 0.2.1 - Template and widgets Bootstrap2 to use with Text.Blaze.Html5  http://hackage.haskell.org/package/layout-bootstrap-0.2.1 (AlexanderBondarenko)
07:17:19 * hackagebot Unixutils 1.48.1 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.48.1 (JeremyShaw)
07:17:21 * hackagebot system-fileio 0.2.6 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.2.6 (JohnMillikin)
07:24:32 <timthelion> if I cannot get haskell working well with Arch linux, which distribution should I use?
07:24:41 <mroman> Debian.
07:24:44 <mroman> Ubuntu.
07:24:48 <mroman> They both work fine.
07:25:23 <timthelion> I moved to arch from Ubuntu, after I got tired of having to worry about releases...
07:25:28 <mroman> timthelion: Did you try to build the haskell plattform?
07:25:36 <mroman> That should work on almost any distribution.
07:25:54 <mroman> Takes some hours to finish compilation, though.
07:26:06 <mroman> Depending on your hardware, of course.
07:26:22 <timthelion> mroman: well the problem with the way haskell is set up in Arch, is that arch always uses the most up to date release packages.  But things like leksah only work with the outdated packages.
07:26:51 <timthelion> and it seems like a lot of work to install two versions of everything.
07:27:17 * hackagebot system-fileio 0.3.6 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.6 (JohnMillikin)
07:27:27 <rostayob> timthelion: just install the GHC binaries
07:27:28 <lambdabot> rostayob: You have 1 new message. '/msg lambdabot @messages' to read it.
07:27:31 <rostayob> ah right you can't with arch
07:27:40 <mroman> leksah?
07:28:00 <timthelion> mroman: some IDE written in haskell
07:28:14 <mroman> Why does the IDE have problems with packages?
07:28:32 <timthelion> rostayob: what do you mean, of course I can install the binaries with Arch.  The problem is, that my binaries are too new.
07:28:51 <timthelion> mroman: well I need to build it, since there isn't a binary package on arch for it.
07:29:49 <mroman> Ic.
07:30:00 <timthelion> mroman: I understand correctly, that debian is like ubuntu, in that you have to reinstall everything every year or two when they change the version number, and you have to wait a year or two for the packages to be updated(excluding security updates)
07:30:54 <mroman> Pretty much.
07:31:00 <timthelion> mroman: that sucks
07:31:02 <mroman> Except you can run dist-upgrade.
07:31:17 <mroman> That's why I compiled the haskell plattform myself ;)
07:31:37 <timthelion> mroman: I remember dist-upgrade from ubuntu. I never once found it more convenient than simply burning a new ISO
07:31:54 <adimit> idd, ubuntu's dist-upgrade usually fails.
07:32:54 <mroman> dist-upgrade ruins your system with a 1:5 chance :)
07:33:16 <mroman> timthelion: Which version of ghc does arch linux ship?
07:33:24 <hpaste> timthelion pasted “leksah” at http://hpaste.org/64794
07:33:46 <timthelion> mroman:  7.4.1
07:33:54 <rostayob> xplat: thanks,  I thought it was something like that but I had guessed that it could recognise the 'y :: xs'
07:34:01 <timthelion> that is what cabal tells me when I try to build leksah :O
07:34:10 <mroman> You never run cabal update?
07:34:14 <mroman> *ran
07:34:36 <timthelion> mroman: you are correct.
07:34:43 <merijn> Hmm, listenOn in Network always binds all IP's?
07:35:00 <timthelion> mroman: I guess I'll tough it out and stick with Arch.
07:35:02 <mroman> Why don't you install the version directly from hackage?
07:35:16 <timthelion> mroman: of ghc?
07:35:21 <mroman> No, of leksah.
07:35:29 <mroman> cabal update && cabal install leksah
07:36:13 <timthelion> mroman: because I'm a doofus...  Nah, because I wanted to see if I couldn't build myself an arch package and then post it to the AUR(ch) servers for others to use.
07:37:05 <MaskRay> ski: https://github.com/sjoerdvisscher/blog/blob/master/2012/2012-03-03%20how%20to%20work%20generically%20with%20mutually%20recursive%20datatypes.md is great, which is exactly what i need
07:37:20 <mroman> Seems like you don't have the correct dependencies available to build leksah.
07:37:31 <timthelion> mroman: thank you for your help.  I think I'll just install through cabal and ignore the arch package manager completely.  But I must go now, since that little orange battery light is blinking and if I don't sleep my laptop within 5 minutes time I'll lose everything in RAM :D
07:37:34 <mroman> (which cabal would automatically do)
07:37:43 <cwl> Have you installed poppler haskell binding?
07:37:54 <cwl> I have problems install it.
07:38:21 <mroman> When it comes to haskell, I recommend not using the distribution's package manager
07:38:31 <mroman> their usually outdated anyway.
07:38:42 <mroman> and it saves a lot of trouble.
07:38:59 <cwl> I've post it here http://stackoverflow.com/questions/9568703/failed-to-cabal-install-poppler
07:39:46 <covi> Hi guys, what is the complexity of  sum . filter (`notElem` List1) $ List2?
07:40:03 <mauke> type error
07:40:11 <mroman> and you need gtk2hs-bulidtools
07:40:19 <mroman> *buildtools
07:40:24 <mroman> and libgtksourceview
07:40:53 <mauke> O(n*m)
07:41:07 <mroman> Hm.
07:41:07 <cwl> covi: len List2 * len List1 + len (List2 - List1)
07:41:18 <mroman> Apparently leksah really does not build on my haskell plattform o_O
07:41:36 <mroman> oh
07:41:46 <mroman> I should probably add cabal-bin to my path.
07:41:51 <covi> So elem and notElem are O(n) algorithms?
07:42:09 <mauke> @src elem
07:42:09 <lambdabot> elem x    =  any (== x)
07:42:14 <mauke> @src any
07:42:15 <lambdabot> any p =  or . map p
07:42:21 <covi> num [1,2]
07:42:26 <mauke> @src or
07:42:26 <lambdabot> or    =  foldr (||) False
07:42:27 <covi> nub [1,2]
07:43:10 <covi> mauke: thanks
07:43:18 <covi> why is  nud  not in my ghci..
07:43:27 <covi> @src nub
07:43:28 <lambdabot> nub = nubBy (==)
07:43:35 <covi> @src nubBy
07:43:35 <lambdabot> nubBy eq []             =  []
07:43:36 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
07:44:31 <covi> So nub is O(n).
07:44:47 <copumpkin> no
07:44:49 <mux> clearly not
07:44:52 <mux> look at the filter call
07:44:53 <covi> ....
07:44:58 <copumpkin> it's O(n^2)
07:45:01 * mux nods
07:45:04 <copumpkin> or rather
07:45:08 <copumpkin> O(n) for each additional element
07:45:14 <mux> that's O(n^2)
07:45:17 <copumpkin> I know
07:45:33 <copumpkin> but talking incrementally makes more sense in a lazy context
07:48:10 <covi> Will Haskell calculate  sum [1..n] in O(1) time?
07:48:33 <cwl> @src sum
07:48:33 <lambdabot> sum = foldl (+) 0
07:49:34 <ChristianS> covi: sum won't get better than O(n), obviously
07:49:35 <covi> cwl: thx
07:49:41 <rwbarton> it might conceivably with the llvm backend I suppose
07:49:54 <MaskRay> foldl instead of foldl'?
07:50:10 <quicksilver> remember that @src is a work of fiction
07:50:10 <covi> ChristianS: but things like [n..m] obviously should be handled in O(1) time
07:50:23 <covi> it only requires a little more chars in the codes
07:50:25 <osfameron> how would you improve on O(n) with a different backend?
07:50:28 <quicksilver> it bears no resemblance to any implementation of haskell past present or future.
07:50:30 <MaskRay> much memory usage could be avoided with foldl'
07:50:43 <quicksilver> osfameron: you'd solve the arithmetic progression.
07:50:53 <quicksilver> I've never heard of a compiler solving arithmetic progressions
07:50:59 <t7> is there a package that implements a quantum walk?
07:51:00 <quicksilver> it seems like a rather "special purpose" optimisation.
07:51:04 <osfameron> oh, sure
07:51:25 <mroman> ok. it's compiling.
07:52:48 <merijn> quicksilver: Well, I did see one example of the haskell llvm backend reducing a loop to a constant value. Granted that was in an "ultimate optimisation fiddling" blog post
07:53:19 <merijn> It seems unlikely to happen in real code, but it could happen
07:57:18 <covi> What's the diff between  rem  and  mod ?
07:57:36 <quicksilver> the way they behave with negative numbers
07:57:57 <quicksilver> > ((-8) `mod` (-3),(-8) `rem` (-3))
07:57:58 <lambdabot>   (-2,-2)
07:58:05 <quicksilver> > ((-8) `mod` (3),(-8) `rem` (3))
07:58:06 <lambdabot>   (1,-2)
07:58:09 <quicksilver> that one :)
07:58:42 <covi> quicksilver: thanks :)
08:06:13 <ronankde> Today I saw a comment where he spoke in the Haskell and partly financed by Microsoft, right?
08:06:31 <Botje> ronankde: your sentence a verb.
08:06:44 <Botje> and a noun, come to think of it
08:07:28 <merijn> I'm getting "Main.hs:9:14: Not in scope: data constructor `PortNumber'" even though I have "import Network (PortNumber)" at the top of my module. Am I missing something?
08:07:38 <ronankde> I am Brazilian and my English is very bad
08:07:53 <rostayob> ronankde: Microsoft pays the lead devs of GHC.
08:08:00 <Botje> *Microsoft Research
08:08:13 <Tinned_Tuna> rostayob: Peyton-Jones works at MS Research Cambridge, iirc...
08:08:25 <Saizan> merijn: you're importing the type PortNumber there
08:08:30 <merijn> Tinned_Tuna: So does Simon Marlow
08:08:35 <Saizan> merijn: the constructor is from another type btw, iirc
08:08:35 <Tinned_Tuna> * ronankde ...
08:08:51 <ronankde> try to understand my English is not very good
08:08:58 <merijn> Saizan: It boils down to "I want to convert a number to a PortID", this shit shouldn't be so difficult :(
08:09:10 <Saizan> merijn: fromIntegral?
08:09:14 <Botje> practice makes perfect :)
08:09:52 <merijn> "No instance for (Num PortID)"
08:10:12 <merijn> PortID wants a PortNumber (type) as argument for PortNumber (constructor)
08:10:19 <Saizan> right
08:10:21 <merijn> The type supports fromIntegral
08:10:31 <Saizan> so PortNumber (fromIntegral x)
08:10:36 <ronankde> I want to know and the microsoft is funding the Haskell
08:10:55 <rostayob> ronankde: yes.
08:10:58 <Saizan> merijn: import Network (PortID(PortNumber))
08:11:04 <ronankde> I saw a comment about it
08:11:13 <ronankde> why?
08:11:29 <ronankde> Internet Explorer
08:11:38 <merijn> Saizan: Thanks
08:11:53 <ronankde> is written in haskell
08:12:11 <merijn> Saizan: This is stupid library design...it shouldn't take me 7 minutes to figure out how to give a portnumber to listenOn :\
08:13:03 <roconnor> the network library is even worse than you think IMHO.
08:13:23 <roconnor> I wish someone would make new bindings from scratch
08:13:27 <rwbarton> AFAICT llvm really did optimize sum [1..n] to a constant time calculation
08:13:34 <roconnor> perferably somone who knows networking.
08:13:38 <roconnor> (so not me)
08:13:43 <Saizan> merijn: it isn't so bad if you read the haddock, though the PortNumber constructor is badly named
08:14:01 <merijn> Saizan: There should just be a direct fromIntegral implementation for PortID
08:14:15 <hpaste> DGel pasted “Slow” at http://hpaste.org/64795
08:14:26 <Na-Fiann> Hi, I'm trying to learn haskell, and as such wanted to write a simple program to process some text. However my solution is much slower than the program I wrote in python which does something similar (but obviously not really. Can people give me some pointers on how to make it better?
08:14:32 <merijn> roconnor: What's the chances of something like that replacing the existing Network if it gets written?
08:14:32 <Na-Fiann> I've already figured that using interact and unlines is not the best way to go, but no idea what else to do. http://hpaste.org/64795
08:14:35 <Saizan> merijn: doesn't make much sense considering the current number hierarchy
08:15:02 <roconnor> merijn: If it gives me the ability to set timeouts, I will use it.
08:15:19 <merijn> roconnor: It pissed me off last time I was writing something too, I might as well try and write something non-sucky as a project
08:15:46 <roconnor> merijn: generally I think something needs to be about 10x better to replace a well entrenched competitor.
08:15:47 <merijn> I'm not really a networking expert, but I have done enough networking to think "how hard can it be?"
08:15:50 <Na-Fiann> It just splits lines into columns, takes the second columns and forms sentences from that. sentences are delimited by empty lines in the input
08:16:02 <roconnor> merijn: with the current networking library, I think this is 10x mark is achievable
08:16:17 <rwbarton> oh, I lied, it optimized an explicit loop to sum the numbers 1..n to the formula, but it couldn't deal with "sum [1..n]" for some reason
08:16:36 <jfischoff> Na-Fiann: don't pack and unpack the string. Use a function that runs on strings
08:17:18 <merijn> roconnor: Oh well, I wanted a non-trivial project and an excuse to learn the FFI anyway :p
08:17:23 <ChristianS> Na-Fiann: in general, interact and unlines should be fine. but you should try using Text generally instead of String.
08:17:38 <Na-Fiann> jfischoff, is there a standard trim or strip function that works on strings?
08:17:57 <jfischoff> Na-Fiann; ChristianS answer is better
08:18:39 <jfischoff> Na-Fiann: check out Hayoo http://holumbus.fh-wedel.de/hayoo/hayoo.html
08:19:04 <Na-Fiann> jfischoff, thanks, didn't know about that!
08:19:35 <jfischoff> hayoo is awesome, also there is hoogle
08:19:52 <applicative_> what does strip do?
08:20:02 <Na-Fiann> ChristianS, do you mean using Text directly on the input?
08:20:28 <applicative_> Na-Fiann: that might be a good idea.  there is T.interact by the way
08:22:10 <ChristianS> Na-Fiann: yes, there is Data.Text.Lazy.IO for IO (contains the interact for Text which applicative_ mentioned).
08:22:27 <ChristianS> though they state: "If you know in advance that you will be working with data that has a specific encoding (e.g. UTF-8), and your application is highly performance sensitive, you may find that it is faster to perform I/O with bytestrings and to encode and decode yourself than to use the functions in this module."
08:23:22 <poehls> All, I'm curious if there is a Haskell equivelant of Erlang's pool module (sets up a multi-machine cluster, http://www.erlang.org/doc/man/pool.html)? Any links, comments would be great.
08:23:52 <Na-Fiann> ooh thanks, I will look that up then. The lazy.IO one, I mean
08:24:55 <ChristianS> Na-Fiann: what i usually do is to use the I/O functions and the lines/unlines functions from Data.ByteString.Lazy.Char8 and then use Data.Text.Encoding (decodeUtf8, encodeUtf8) to convert individual lines into Text.
08:25:25 <ChristianS> Na-Fiann: but probably better try Data.Text.Lazy.IO first, might be slightly easier.
08:27:30 <ajhobbs> Anyone have a pointer or link for getting a working toolchain for ghc 7.4.1 or 7.2 with Repa installed on a Mac?  I've got Repa installed with Haskell Platform, which works for ghci but fails to compile sample code with ghc.  Alternately, best system/platform for pain free Repa development?  /sorry for the wall of text
08:29:50 <hpaste> applicative annotated “Slow” with “Slow (annotation)” at http://hpaste.org/64795#a64798
08:30:56 <applicative_> Na-Fiann: I tried to textify it, but I introduced a bug I think, anyway, it gives the idea, I think.  The use of !! 1 and so on isn't safe, but I may have misunderstood it
08:31:22 <merijn> roconnor: Would reusing the module naming (Network.Socket, etc) introduce problems?
08:31:51 <ChristianS> merijn: yes, re-using module names is evil!
08:31:54 <hpaste> applicative annotated “Slow” with “Slow (annotation) (annotation)” at http://hpaste.org/64795#a64799
08:31:57 <Na-Fiann> applicative_, if by unsafe you mean that it might cause a crash: yes, but in that case the data is malformed anyway :)
08:32:16 <Na-Fiann> applicative_, thanks btw :)
08:32:24 <applicative_> oh okay, anyway, i pasted the wrong one now it's right
08:34:57 <ajhobbs> For ghc-64bit, would Arch Linux be the preferred platform, or does another have better packaging these days?
08:35:41 <roconnor> merijn: I would only do it if it was (almost) compatible with the existing module.
08:36:11 <merijn> roconnor: Makes me wish the original author picked somewhat less generic names >.>
08:36:25 <roconnor> merijn: call it Networking.Socket
08:36:46 <applicative_> merijn  Network.Socket.DeLuxe
08:36:55 <roconnor> or Data.Network.Socket :^)
08:36:57 <ChristianS> roconnor: i wouldn't do it even then. there are two Data.HashMap's which is quite annoying, even though their api is very close.
08:37:01 <merijn> Network.NonSucky might be a tad passive aggressive ;)
08:37:05 <Na-Fiann> applicative_, thanks it seems to work, and is quite a bit faster. I'm surprised the standard python functionality is so much faster though, I expected haskell to be _fast_. Then again, it's probably my programming :p
08:37:31 <ChristianS> but i first used the Data.HashMap from the wrong package and wasn't happy about it when i found out.
08:37:57 <applicative_> Na-Fiann, I expect this could be optimized a bit.  The mixing of list code with Data.Text can trip me up a bit.
08:38:43 <merijn> roconnor: Hmm, if I name the package network and the module networking then networking will export network and network will export networking, to enhance the confusion :>
08:39:13 <applicative_> Na-Fiann: in general, if you are working with lots of short bits of string, it is said that Data.Text might not be so great.
08:39:27 <applicative_> Na-Fiann, are you compiling with optimization and all that?
08:39:32 <Na-Fiann> hmm
08:39:33 <roconnor> merijn: perfect.
08:39:40 <Na-Fiann> ooh ffs -_- no
08:40:02 <Na-Fiann> but doesn't make much of a difference
08:40:07 <applicative_> ghc --make -O2 blah.hs -o blah is okay
08:41:12 <applicative_> oh also , ghc --make -O2 blah.hs -fforce-recompile -o blah
08:41:32 <applicative_> if it takes a microsecond to recompile, it didnt recompile, Na-Fiann
08:43:09 <applicative_> or rather ghc --make -fforce-recomp -O2   ( I use a different method)
08:43:11 <merijn> Is there a quick way to look up the documentation of pragma's?
08:43:28 <applicative_> which ones language pragmas
08:44:03 <ChristianS> Na-Fiann: could you post your python version for comparison? also, what kind of input do you use for testing (especially, how big)?
08:44:21 <Na-Fiann> applicative_, ahh thanks, didn't realize. But still no dice
08:44:22 <ChristianS> i may play around with it a bit, though probably not before tomorrow.
08:44:27 <merijn> applicative_: In this case {-# LANGUAGE x #-}, but in general would be nicer
08:45:01 <ChristianS> Na-Fiann: in order to force recompilation, use  touch sourcefile.hs
08:45:20 <applicative_> maybe someone should make a cheat sheet so to say, merijn.  it's all in the docs but not ideal for searching
08:46:05 <Na-Fiann> ChristianS, just 8MB, 205k lines, 1.7M words
08:46:09 <Na-Fiann> not massive
08:48:02 <Na-Fiann> it's conll files, linguistically annotated sentences, and I'm extracting the sentences only. python code is here http://pastebin.com/F3YzmkWe
08:48:04 <mauke> The paste F3YzmkWe has been copied to http://hpaste.org/64801
08:49:02 <Na-Fiann> *by words, I mean tokens
08:49:21 <Na-Fiann> obviously, theres fewer than 205k words to extract
08:49:34 <ChristianS> Na-Fiann: will try it occasionally, thanks
08:50:01 <Na-Fiann> no prob
08:50:06 <ChristianS> Na-Fiann: hmm, with 205k lines and one word per line to extract, i would have expected 205k words?
08:50:08 <Na-Fiann> thank you, actually :)
08:50:22 <Na-Fiann> no, there's empty lines to denote sentence ending
08:50:28 <ChristianS> no prob, curious myself :-)
08:51:48 <rwbarton> ghc can also optimize V.sum (V.enumFromN 1 n) to a constant time computation
08:51:58 <applicative_> oh i see it was a really direct translation i guess.  what is this doing exactly?  i cant read it
08:52:19 <applicative_> Na-Fiann: what is does the condition beginning if cur: ... mean
08:52:20 <ChristianS> rwbarton: with n being specific at runtime?
08:52:21 <quicksilver> rwbarton: or DPH can, depending on your perspective
08:52:32 <Na-Fiann> ahh
08:52:37 <rwbarton> well really llvm can, I assume
08:52:46 <Na-Fiann> applicative_, empty lists have a boolean value of false in python
08:52:47 <rwbarton> ChristianS: obtained at runtime
08:52:49 <quicksilver> rwbarton: but while this is cute, is this kind of optimisation ever useful?
08:52:59 <applicative_> thats what i figured
08:53:02 <ChristianS> rwbarton: pretty cool
08:53:11 <rwbarton> quicksilver: beats me
08:53:18 <rwbarton> also, it seems unreliable
08:53:37 <tromp__> same in perl
08:54:00 <Na-Fiann> applicative_, and yes, you're right about the direct translation: I'm new to haskell and was mainly doing this as an exercise, but then was surprised it was so much slower (3-4x slower actually)
08:54:55 <hpaste> rwbarton pasted “sum [1..n] in constant time” at http://hpaste.org/64802
08:55:15 <rwbarton> it only works with the NOINLINE
08:56:16 <Elemir> Why safe lazy IO isn't really popular in haskell?
08:56:24 <applicative_> when you say "It just splits lines into columns, takes the second columns and forms sentences from that. sentences are delimited by empty lines in the input"
08:56:36 <Elemir> @hackage safe-lazy-io
08:56:36 <lambdabot> http://hackage.haskell.org/package/safe-lazy-io
08:57:07 <Elemir> It sucks
08:57:08 <applicative_> does that mean, it drops the first word so to say, and makes a sentence of the rest? and then puts them between blank lines?
08:57:19 <applicative_> Na-Fiann: ^^^
08:57:24 * hackagebot system-fileio 0.2.7 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.2.7 (JohnMillikin)
08:57:26 * hackagebot cabal-install-ghc74 0.10.4 - Temporary version of cabal-install for ghc-7.4  http://hackage.haskell.org/package/cabal-install-ghc74-0.10.4 (AndreasAbel)
08:57:28 * hackagebot system-fileio 0.3.7 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.7 (JohnMillikin)
08:58:09 <ChristianS> Elemir: lazy IO is already the default, but i never heard about that package. looks like an abandoned one-time attempt.
08:58:44 <Elemir> Default IO isn't really lazy
08:58:52 <applicative_> ChristianS: yes it is a defense of lazy IO from the period of the First Iteratee Wars
08:59:13 <Elemir> There is no way to use it normally with unsafeInterleave
08:59:23 <Elemir> *without
09:01:32 <Na-Fiann> applicative_, no: each line is either empty or consists of (9 or 10) fields, separated by tabs. the program takes the second field of each consecutive non-empty line and makes a new line out of that
09:02:25 * hackagebot happstack-server-tls 6.0.2 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-6.0.2 (JeremyShaw)
09:02:44 <Elemir> ChristianS: look at source of lazyRead, for example
09:02:58 <applicative_> ok.  so we unlines, we split on tabs.  What happens if there is only one field?
09:03:50 <ChristianS> applicative_: if the input is well-formed, that won't happen.
09:04:36 <Na-Fiann> applicative_, example http://pastebin.com/rVP2x68s
09:04:38 <mauke> The paste rVP2x68s has been copied to http://hpaste.org/64803
09:05:14 <Na-Fiann> applicative_, we exit with an error message: there should never be only 1 field
09:05:30 <applicative_> then we filter null lines out and then take the second element of the tab-broken lines.
09:05:56 <Na-Fiann> null lines should be a newline in the new outpu
09:10:36 <merijn> @hoogle IO a -> IO ()
09:10:36 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
09:10:36 <lambdabot> Control.Exception.Base block :: IO a -> IO a
09:10:36 <lambdabot> Control.Exception block :: IO a -> IO a
09:10:55 <efie> is there a way to enable that the status messages (changed nick to... joined channel...) won't be displayed?
09:11:51 <Botje> if you're using irssi .. /ignore #haskell JOINS PARTS QUITS
09:11:54 <Botje> i think
09:12:22 <Elemir> Is there another irc clients?
09:12:28 <latros> lots
09:12:34 <Elemir> telnet!
09:13:36 <efie> thanks
09:13:38 <Elemir> How about lazy IO? IMHO unsafeInterleaveIO is ugly crutch, isn't it?
09:14:41 <_Mikey> Guys, I'm having a weird bug in Cabal
09:14:46 <hpaste> “_Mikey” pasted “Error” at http://hpaste.org/64804
09:15:19 <_Mikey> when I include wxdirect in my path it still errors.
09:15:19 <cmccann> Elemir, well, there are some specific scenarios where lazy IO does work well
09:17:11 <hpaste> “_Mikey” annotated “Error” with “Error (annotation)” at http://hpaste.org/64804#a64805
09:17:23 <Elemir> cmccann: I want to use lazy IO everythere with forcing some actions (such as writing to file). Is it bad?
09:17:30 <applicative_> Na-Fiann: this is more ye olde Data.List way
09:17:33 <applicative_> > let a = dropWhile isSpace >>> dropWhile (not . (== '\t')) >>> tail >>> takeWhile (not . (== '\t')) in map a $ lines  "1\tHello\tgreeting\n1\t world \t noun"
09:17:34 <lambdabot>   ["Hello"," world "]
09:17:50 <dmwit> _Mikey: Did you remember to export PATH after changing it to include wxdirect?
09:18:22 <_Mikey> dmwit, I used export PATH=$HOME/.cabal/bin:$PATH
09:18:44 <Elemir> _Mikey: show your "where wxdirect"
09:18:52 <dmwit> Alright. (And I guess wxdirect is in $HOME/.cabal/bin?)
09:18:54 <cmccann> Elemir, in general it's probably a bad idea. lazy IO means giving up control over how and when that IO is performed
09:19:19 <_Mikey> I don't have where
09:19:28 <_Mikey> it is in bin though I'm sure of it.
09:19:40 <Na-Fiann> applicative_, okay, this is going to sound dumb I'm sure, but what does  >>> do?
09:19:55 <td123> _Mikey: he probably meant which
09:19:55 <dmwit> You don't have where? What kind of backwards shell are you using?
09:20:05 <cmccann> Elemir, so if you're reading a file and don't care about the details of how the reads occur, lazy IO lets you ignore that
09:20:10 <applicative_> its just flipped composition, (.)
09:20:12 <applicative_> > let a = dropWhile isSpace >>> dropWhile (not . (== '\t')) >>> tail >>> takeWhile (not . (== '\t')) ; process = map a . filter (not.null) . lines in process "1\tHello\tgreeting\n1\t world \t adjective\n\n\n3 \t leaders\t noun\n"
09:20:13 <lambdabot>   ["Hello"," world "," leaders"]
09:20:31 <applicative_> > unwords ["Hello"," world "," leaders"]
09:20:31 <Elemir> cmccann: MLists say it about every lazy computations.
09:20:32 <lambdabot>   "Hello  world   leaders"
09:20:41 <applicative_> so we still need strip
09:21:29 <cmccann> Elemir, laziness in a pure computation is an entirely different matter
09:22:00 <_Mikey> Elemir, I'll paste my which
09:22:10 <hpaste> “_Mikey” annotated “Error” with “Error (annotation)” at http://hpaste.org/64804#a64806
09:22:30 <hpaste> latros pasted “groupsort” at http://hpaste.org/64807
09:22:37 * latros wonders why this generates duplicates
09:22:52 <rwbarton> _Mikey: it looks like you broke some other environment variable controlling the path for shared libraries?
09:23:20 <_Mikey> hmm.
09:23:28 <_Mikey> rwbarton, is it possible to reset that?
09:23:54 <rwbarton> well i don't really know what you are doing there, but opening a new shell should work
09:23:59 <latros> er
09:24:01 <Elemir> cmccann: IO shoudn't break purity.
09:24:02 <latros> typo
09:24:04 <latros> sorry
09:24:07 <cmccann> Elemir, anyway, the main thing is that unsafeInterleaveIO is kind of hackish but behaves in a well-defined way that's useful for certain things
09:24:27 <dmwit> latros: deleteAllBy p = filter (not . p) -- ?
09:24:49 <latros> ...in this case that works, yes, earlier I was doing single deletion in that style
09:24:54 <latros> thanks
09:25:09 <latros> (this has gone through a lot of revision, all of which was at like 3 am)
09:25:21 <Elemir> All hacks in products means miss-projecting of it.
09:25:53 <gridaphobe> are there any good books on writing compilers in haskell?
09:26:03 <cmccann> Elemir, there's actually no way to observe breaks in purity from using unsafeInterleaveIO except from an external perspective. that's why it has well-defined behavior
09:26:28 <cmccann> but it's still not a very satisfying approach and I'd rather it be avoided entirely, myself
09:27:08 <gridaphobe> i've decided to use haskell for my compilers course, but the prof is using C and I'm a bit worried about trying to convert impertive -> functional on my own
09:27:17 <cmccann> Elemir, does that help at all? I'm not really sure what you're getting at.
09:27:46 <_Mikey> I have wxdirect installed
09:27:51 <_Mikey> but which doesn't find it.
09:27:57 <cmccann> gridaphobe, as a rule of thumb writing a compiler in Haskell is likely to be a bajillion times easier than in C
09:28:41 <gridaphobe> cmccann: so I've heard :-) it would still be nice to have a good book for reference though
09:28:56 <cmccann> gridaphobe, you know that GHC itself is written in Haskell, right?
09:29:06 <Phlogistique> GHC is rather... big.
09:29:10 <gridaphobe> hehe yea
09:29:14 <hpaste> applicative annotated “Slow” with “Slow (annotation) (annotation) (annotation)” at http://hpaste.org/64795#a64808
09:29:30 <Phlogistique> there are a gajillion of compilers in OCaml
09:29:30 <cmccann> and SPJ has all kinds of papers and stuff about implementation
09:29:41 <applicative_> Na-Fiann: try this one ^^ it's the most naive haskell version, I'd think
09:30:05 <applicative_> Na-Fiann: except I use (>>>) instead of (.) for the heck of it
09:30:20 <cmccann> gridaphobe, cf. http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
09:31:48 <hpaste> latros pasted “groupsort” at http://hpaste.org/64809
09:31:58 <latros> fixed some things, still seems to generate duplicates
09:32:02 <cmccann> (I don't recommend looking at GHC itself though, it's a huge and somewhat... peculiar codebase, since it predates a great deal of modern Haskell)
09:32:46 <jfischoff> gridaphobe: http://augustss.blogspot.com/2009/06/more-llvm-recently-someone-asked-me-on.html not the simplest example, but not terribly complicated either
09:33:14 <latros> ack, needed another '
09:33:22 <hpaste> latros pasted “groupsort” at http://hpaste.org/64810
09:33:36 <Boscop> how does the haskell compiler distinguish type variables and references to actual types in function signatures?
09:33:46 <latros> ok yeah now I have a test case that I don't get....
09:33:53 <gridaphobe> cmccann: thanks, http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/ looks promising :)
09:33:54 <latros> *Main> groupSortWithOrderList "abc" [('a',"efb"),('c',"gfs")]
09:33:54 <latros> "bfeasfgc"
09:34:00 <latros> there should only be one f
09:34:27 <latros> oh....wow I'm an idiot
09:34:31 <latros> nvm
09:35:02 <Na-Fiann> applicative_, sorry was away for a bit, will try
09:35:04 <Boscop> e.g. foo :: a -> b // how does the compiler know whether a and b are type variables or already defined types?
09:35:25 <monochrom> lower case: type variable
09:35:39 <Boscop> ah
09:36:48 <cmccann> jfischoff, should probably emphasize that augustss is an excellent person to be learning from, since he doesn't exactly plaster his qualifications all over his blog
09:37:36 <Na-Fiann> applicative_, it doesn't do the quite the right thing, it doesnt add newlines in between individual sentences :(
09:37:52 <Na-Fiann> on the plus side, it is faster than the Data.Text implementation ;)
09:37:58 <applicative_> oh i forgot about that
09:38:35 <jfischoff> cmccann: Do doubt.
09:39:03 <latros> \o/ fixed
09:39:34 <hpaste> applicative annotated “Slow” with “Slow (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/64795#a64811
09:39:42 <latros> ....or not, overzealously fixed apparently
09:39:54 <applicative_> Na-Fiann: I wrote unwords meaning unlines
09:44:21 <applicative_> Na-Fiann: youre right, i didn't study the exapmle closely enough
09:46:19 <lorgrin> ciao
09:46:25 <lorgrin> !list
09:47:36 <Boscop> is the composition operator overloaded for lists of functions?
09:48:16 <pqmodn> Boscop: no, you could fold over the list with (.) though
09:50:21 <Boscop> I was just wondering because in the paper "An n-ary zipWith in Haskell" they use . to concatenate lists of functions
09:51:52 <pqmodn> Boscop: the (.) from Prelude doesn't, but you can define your own (or perhaps they import it from another library)
09:52:13 <Boscop> I thought operator overloading like that isn't possible in haskell
09:52:33 <nand`> Boscop: it isn't
09:52:39 <nand`> he's talking about redefining the operator, not overloading it
09:52:43 <Boscop> ok
09:52:51 <Rc43> Hi, guys.
09:53:08 <Rc43> How can I upgrade base package with cabal?
09:53:15 <rwbarton> nonono
09:53:30 <ChristianS> Rc43: don't do it, thinks will break.
09:53:34 <rwbarton> the base package version is closely associated to your version of GHC
09:53:49 <Rc43> ok, how I can upgrade haskell platform in a good way?
09:54:04 <Rc43> Just install new ghc over current?
09:54:17 <td123> Rc43: is this windows or linux?
09:54:27 <cmccann> how to upgrade base with cabal: 1) create a .cabal file to build GHC 2) build GHC 3) install GHC along with a new base package
09:54:27 <Rc43> td123, windows
09:54:51 <Rc43> td123, but if you can say for linux - it would be useful too for a future, windows isn't my main platform
09:55:09 <ChristianS> btw, whenever i run  cabal update , cabal tells me: "Note: there is a new version of cabal-install available. To upgrade, run: cabal install cabal-install". i presume i shouldn't do that either?
09:55:49 <hiptobecubic> Where did cabal get its name?
09:55:57 <cmccann> ChristianS, the cabal-install executable is basically independent of everything else
09:56:29 <hpaste> theA3Guy pasted “randomCode” at http://hpaste.org/64812
09:56:47 <ChristianS> cmccann: which means i could safely update it, without ruining my haskell installation?
09:56:48 <td123> Rc43: HP provides a windows installer so just dl that and install?
09:57:02 <theA3Guy> hi, in the code I just posted, how is "something" stored in the "things" value
09:57:11 <theA3Guy> is "something" replicated or just pointed to?
09:57:11 <Rc43> td123, so installing new HP over current is normal?
09:57:23 <Rc43> td123, there won't two versions?
09:57:26 * hackagebot git-annex 3.20120230 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120230 (JoeyHess)
09:57:56 <cmccann> ChristianS, as safely as any other executable package you might want to install
09:58:14 <Rc43> Btw, HP windows version is 2011.4.0
09:58:23 <cmccann> as always the caveats of "don't let it reinstall boot packages" applies, but that's not specific to cabal-install
09:58:24 <rwbarton> in my experience with installing multiple ghc versions on linux, the versions happily coexist and nothing has ever gone wrong
09:58:47 <rwbarton> "ghc" will pick the latest one by default, but the others are available under "ghc-7.0.4" etc.
09:58:59 <rwbarton> you'll have to reinstall all your libraries with Cabal for each new version
09:59:05 * cmccann has about a dozen ghc verisons installed, btw
09:59:14 <hiptobecubic> cmccann, why?
09:59:24 <ChristianS> cmccann: hm, i was under the impression that if some package has already been installed from my package repo (apt-get), it's not a good idea to reinstall it via cabal...
09:59:26 <rostayob> rwbarton: the latest installed
09:59:32 <rwbarton> yes
09:59:35 <cmccann> hiptobecubic, because of no reason to remove old versions mostly
09:59:43 <rostayob> I've got everything from GHC 6 installed as well, no problems.
09:59:57 <hiptobecubic> cmccann, fair enough. I have space constraints :)
10:00:25 <cmccann> hiptobecubic, note that more than half are build snapshots and other non-major releases
10:00:49 <cmccann> either for playing with upcoming features ahead of time, or for tracking down a possible compiler bug, or whatnot
10:00:52 <td123> Rc43: I don't know how it works on win. so maybe just uninstall before installing?
10:01:27 <hiptobecubic> cmccann, ah.
10:01:40 <Rc43> td123, anyway, the version is old for windows isntaller
10:01:46 <hiptobecubic> cmccann, are the creator of "Overture"?
10:01:49 <hiptobecubic> are you*
10:02:04 <cmccann> ChristianS, I think it's mostly that you shouldn't do that with libraries, and shouldn't mix things installed both ways
10:02:13 <cmccann> hiptobecubic, yeah though I've been neglecting it lately :[
10:02:27 <hiptobecubic> cmccann, ah. because I tried to install it today but i couldn't find "these"
10:02:49 <cmccann> hiptobecubic, see the repo on my github by the same name :]
10:03:05 <hiptobecubic> ChristianS, my experience is let the package manager install ghc and cabal, then do everything with cabal from then on and screw the distro packages.
10:03:21 <hiptobecubic> cmccann, ah, it's a different repo entirely, ok
10:03:33 <ChristianS> cmccann: ok, maybe i'll try updating cabal-install when i can gather the courage...
10:03:52 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml#unsafeInterleave has the problem of interleaving "apt-get install" and "cabal install"
10:04:02 <hiptobecubic> ChristianS, that way you always have the latest, as well.
10:04:25 <cmccann> ah, and here's monochrom, saving me the effort of finding the link to his web page
10:04:30 <hiptobecubic> anyway i'm off. good luck
10:05:09 <monochrom> it is safe to have, chronologically, a bunch of purely "apt-get install", then a bunch of purely "cabal install"
10:05:36 <cmccann> monochrom, ChristianS was specifically asking about installing cabal-install with cabal after previously getting it from apt
10:05:55 <cmccann> which shouldn't be any sort of problem at all, as far as I know
10:06:14 <monochrom> right. but then PATH has precedences
10:06:38 <cmccann> true, though that's an orthogonal concern really
10:07:06 <ChristianS> so the general advice would be to install as much via cabal as possible?
10:07:48 <cmccann> ChristianS, that's usually what you want, other than any initial setup like e.g. installing the haskell platform
10:08:00 <ChristianS> i see, thanks
10:08:45 <Na-Fiann> how do you use Word8 literals in your code? for example, Data.Bytestring.split expects a word8 as parameter, how do I type it?
10:09:10 <mach7> Na-Fiann, if you need it for text, use Data.ByteString.Char8
10:09:31 <monochrom> 45 is a Word8
10:09:32 <mach7> Word8 can be used like a number
10:09:39 <mauke> Na-Fiann: Word8 is a number
10:09:42 <Na-Fiann> ahhh
10:09:43 <Na-Fiann> I see
10:09:53 <Na-Fiann> so, Char8 it is then :p
10:10:11 <mach7> Data.ByteString.Char8 or Data.ByteString.Lazy.Char8, depending on what you need
10:10:33 <ChristianS> Na-Fiann: Char8 should be fine if you test is completely ASCII, i thought about it too.
10:10:57 <mach7> But if you are really serious about having human-readable text, use Data.Text instead
10:11:17 <ChristianS> Na-Fiann: or even if it's utf8, but you need just the basic ascii stuff such as [un]words, [un]lines, == '\t'. but beware of it in other situations!
10:11:21 <mach7> it is much like ByteString, just optimised for text
10:11:44 <_Mikey> fixed it!
10:11:48 <Na-Fiann> thanks!
10:12:21 <mach7> Data.Text also comes with encoding and decoding functions
10:12:22 <ion> ByteStrings and Text are completely different things. ByteStrings represent strings of bytes and text represents text.
10:12:28 * hackagebot fb 0.7.3 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.7.3 (FelipeLessa)
10:12:31 <ion> Also, Strings represent text.
10:12:51 <ion> ByteStrings are akin to [Word8], Text is akin to [Char].
10:13:21 <mach7> ByteString.Char8 would then be akin to [Char] too
10:13:34 <mauke> I hear Text uses UTF-16 internally
10:13:42 <rostayob> mach7: no, Char8 truncates everything above 255
10:13:44 <byorgey> mach7: no.
10:13:51 <mach7> ah, ok
10:13:53 <rostayob> for obvious reasons
10:13:54 <ion> mach7: no.
10:13:54 <byorgey> mach7: Char can consist of several bytes.
10:13:58 <mach7> so it's ascii only
10:14:04 <byorgey> Char8 is, yes
10:14:05 <rostayob> mach7: yes
10:14:31 <ChristianS> Char8 is just meant for ascii, or latin1.
10:14:34 <byorgey> > maxBound :: Char
10:14:35 <lambdabot>   '\1114111'
10:15:32 <byorgey> > (==) `ap` reverse . init . drop 2 . show $ (maxBound :: Char)
10:15:33 <lambdabot>   Precedence parsing error
10:15:33 <lambdabot>      cannot mix `Control.Monad.ap' [infixl 9] and ...
10:15:35 <Jafet> Char8 is a reason to despise humanity
10:15:43 <byorgey> > ((==) `ap` reverse) . init . drop 2 . show $ (maxBound :: Char)
10:15:44 <lambdabot>   True
10:15:45 <rwbarton> for creating unicode?
10:15:46 <byorgey> =)
10:16:20 <mach7> > show $ (maxBound :: Char)
10:16:21 <lambdabot>   "'\\1114111'"
10:16:25 <mach7> oops :)
10:16:38 <DanBurton> > text [maxBound :: Char]
10:16:38 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
10:16:43 <DanBurton> o.o
10:17:10 <rostayob> DanBurton: what's 'text'?
10:17:25 <DanBurton> it causes lambdabot to display a String the way nature intended
10:17:26 <mach7> :t text
10:17:27 <lambdabot> String -> Doc
10:17:35 <DanBurton> > text "foo\nbar"
10:17:36 <lambdabot>   foo
10:17:36 <lambdabot>  bar
10:17:48 <rostayob> oh, it's from pretty.
10:17:58 <rostayob> DanBurton: show works like that on strings for a reason
10:18:06 <mach7> > text "\52"
10:18:07 <lambdabot>   4
10:23:11 <dbelange> why isn't this ##haskell
10:23:40 <t7> because its official
10:23:51 <t7> did i spell that right first try?
10:24:26 <td123> dbelange: http://freenode.net/policy.shtml#channelnaming
10:24:27 <rwbarton> nope. should be "it's" :P
10:24:28 <_Mikey> Hi guys, does anyone know where examples of use for the Haskell Phooey library can be found?
10:24:33 <t7> i get worried my spell check is broken when i get hard words right
10:24:53 <_Mikey> t7, me too
10:25:02 <dbelange> is haskell an international FOSS project
10:25:13 <DanBurton> t7: you should just intentionally misspell them
10:25:16 <dbelange> I thought it was a programming language
10:25:24 <t7> intergalactic FOSS project
10:25:30 <ChristianS> dbelange: actually, it's both
10:25:34 <DanBurton> interdimensional
10:25:37 <mauke> dbelange: it is an international project
10:26:01 <dbelange> oh is this channel for discussing the haskell platform
10:26:13 <mauke> not specifically
10:26:24 <DanBurton> it's for discussing anything vaguely haskell-related
10:26:33 <dbelange> so it should be ##haskell
10:26:39 <dbelange> since it's a topical channel
10:26:43 <dbelange> http://freenode.net/policy.shtml#channelnaming
10:27:03 <cheater_> maybe you should try /part
10:27:20 <cheater_> since we're talking about perfect-world situations
10:28:03 <rostayob> dbelange: I guess it doesn't really matter. also, GHC and the HP are international FOSS projects
10:28:16 <dbelange> well there's #hugs and #ghc
10:28:46 <mauke> dbelange: and where should haskell itself be developed and discussed?
10:28:49 <parcs`> cheater_++
10:28:53 <rostayob> dbelange: why is this relevant?
10:29:11 <DanBurton> whoa #hugs is barren
10:29:20 <parcs`> @remember cheater_ maybe you should try /part since we're talking about perfect-world situations
10:29:20 <lambdabot> It is stored.
10:29:29 <Elemir> http://www.haskell.org/haskellwiki/IRC_channel
10:29:35 <rostayob> DanBurton: if you really want this could fall into "standards organizations".
10:29:39 <mauke> parcs`: not very funny
10:29:40 * cmccann suspects that irrelevant nitpicking about freenode policy isn't really on topic for this channel
10:29:40 <ChristianS> dbelange: since the #haskell channel is the biggest meeting place of haskellers world-wide (i would presume), anyone who sets out to claim that they have a better claim on the name haskell will have a hard time, i guess...
10:30:01 <MostAwesomeDude> dbelange: I should just point out that Freenode's policy on channel names is being followed; this is *the* official Haskell channel.
10:30:13 <MostAwesomeDude> It's similar to how #python is blessed by PSF.
10:30:15 <parcs`> mauke: it is to me :P feel free to delete if my opinion is the minority
10:30:39 <dbelange> python is also the name of the interpreter
10:30:48 <Elemir> No
10:30:52 <ChristianS> dbelange: that's hardly relevant
10:30:56 <mauke> dbelange: which interpreter?
10:31:02 <rostayob> MostAwesomeDude: or #sml, or #erlang, or #scheme...
10:31:02 <mauke> there's a few
10:31:06 <ibid> i believe #haskell predates that naming standard
10:31:07 <Elemir> The name of the interpreter is *C*python
10:31:08 <byorgey> OK, let's stop discussing this please.
10:31:09 <dbelange> dbelange@natedogg:~$ haskell
10:31:09 <dbelange> bash: haskell: command not found
10:31:14 <Rc43> So how to get fresh haskell? HP is not fresh!
10:31:24 <byorgey> dbelange has successfully trolled #haskell.  Let's move on.
10:31:26 <hpaste> applicative annotated “Slow” with “Slow (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/64795#a64814
10:31:32 <MostAwesomeDude> dbelange: Hm, strange; on my machine, my Python is called "pypy". Go figure. >:3
10:31:32 <Rc43> 2011.4.0.0 is currently installed and I need newer
10:31:34 <rwbarton> if you mean fresh ghc, then http://www.haskell.org/ghc/download_ghc_7_4_1
10:31:39 <cheater_> ok troll alert
10:32:00 <Elemir> Just ban this green creature
10:32:10 <DanBurton> applicative_: at this point just annotate it "Slow (annotation^5)"
10:32:24 <dbelange> yeah there's a new naming standard
10:32:25 <applicative_> hah, indeed
10:32:35 <dbelange> are you just "lazy evaluating" it
10:32:36 <_Mikey> Hi guys
10:32:39 <lispy> hi
10:32:48 <_Mikey> sometimes when I'm browsing around on haskell wiki
10:32:53 <_Mikey> I get dead links
10:33:03 <Rc43> rwbarton, `cannot configure gloss-1.6.1.1. It requires base ==4.5.*`
10:33:07 <_Mikey> especially for things on darcs
10:33:09 <Rc43> rwbarton, is it ghc only?
10:33:15 <_Mikey> did everything move?
10:33:17 <lispy> Rc43: are you using ghc 7.4?
10:33:18 <rwbarton> what is that in reference to?
10:33:19 <Rc43> rwbarton, btw there is msg about `-any` flag
10:33:22 <_Mikey> http://darcs.haskell.org/packages/phooey/doc/html/src.Graphics.UI.Phooey.Applicative.hs.html for example
10:33:27 <Rc43> lispy, 7.0.4
10:33:40 <lispy> hmm
10:33:42 <cmccann> _Mikey, the wiki has been somewhat neglected I think :T
10:33:49 <Rc43> rwbarton, cabal install gloss
10:33:49 <rostayob> Rc43: gloss requires ghc 7.4
10:33:50 <_Mikey> :(
10:33:58 <byorgey> _Mikey: darcs.haskell.org isn't used much anymore
10:33:59 <lispy> rostayob: really?
10:34:00 <Rc43> rostayob, ok, how to get it??
10:34:01 <rostayob> the last version anyways
10:34:08 <rostayob> lispy: well, it has base == 4.5.*
10:34:17 <DanBurton> I've noticed various links to some dons profile somewhere that has since been deleted
10:34:19 <_Mikey> byorgey, do you know where it might be hosted now?
10:34:21 <lispy> That seems wrong :)
10:34:24 <rostayob> Rc43: download the binaries
10:34:25 <byorgey> _Mikey: you can try looking on code.haskell.org, but if something is still linked on darcs.haskell.org it's probably old and bitrotted
10:34:27 <rostayob> lispy: http://hackage.haskell.org/package/gloss
10:34:27 <Rc43> http://www.haskell.org/ghc/download just install over HP?
10:34:34 <lispy> (I mean, it seems wrong to require 4.5.*
10:34:39 <rostayob> lispy: why?
10:34:40 <rwbarton> I would just try somethng like cabal install gloss-1.6.0.1
10:34:50 <rostayob> rwbarton++
10:34:50 <_Mikey> byorgey, ok thanks.
10:34:53 <lispy> rostayob: the HP doesn't even ship that version of base yet
10:35:03 <rostayob> lispy: base is shipped with GHC not with the HP
10:35:03 <Elemir> Someone uses http://darcs.haskell.org for *git* repositories. Is it normal?
10:35:18 <lispy> rostayob: yes, but what version of ghc does the HP ship?
10:35:23 <lispy> rostayob: it's not 7.4
10:35:38 <cheater_> 7.2.1 i think?
10:35:39 <byorgey> Elemir: sure, it was just a place to host repositories.  When it was created everyone used darcs, but I don't think there was ever a policy requiring you to use darcs.
10:35:39 <cheater_> perhaps?
10:35:41 <lispy> Elemir: github would probably be more normal :)
10:35:41 <rostayob> lispy: yes, but you still have the older versions. I'm sure the author knows what he's doing
10:35:52 <DanBurton> HP ships 7.0.4 ships bas 4.4.?
10:35:53 <oz__> case isPropositionAlreadyThere(args) == False propositiontree:args
10:36:03 <oz__> is this correct grammer?
10:36:20 <oz__> if propositiontree = []
10:36:28 <rwbarton> not in haskell
10:36:41 <DanBurton> oz__: http://learnyouahaskell.com/syntax-in-functions#case-expressions
10:36:46 <byorgey> oz__: no, perhaps you want   case isProp... args of  False -> propositiontree:args  ?
10:36:52 <lispy> DanBurton: I would guess that's the version of base, but I'd have to check
10:37:03 <rwbarton> (or an "if" expression)
10:37:10 <byorgey> base 4.3 comes with 7.0.4
10:37:16 <applicative_> _Mikey: it looks like phooey isn't haddocked anyway
10:37:17 <byorgey> 4.4 is with  7.2
10:37:26 <oz__> thank you very much guys, I'll look into it
10:38:09 <Rc43> byorgey, now not ghc ships with base, but base with ghc? :)
10:38:28 <dbelange> hello may I speak to the channel founder
10:38:41 <mauke> dbelange: why?
10:38:49 <ciaranm> the channel founder is no longer with us
10:38:59 <DanBurton> RIP Haskell Curry?
10:39:04 <ciaranm> he either entered politics or went to work for microsoft
10:39:08 <byorgey> what?
10:39:42 <lispy> Didn't lambdabot found this channel?
10:39:43 <ciaranm> or possibly just got old and retired
10:39:48 <dbelange> I need to know why there is only one # in #haskell
10:39:51 <rwbarton> lispy: iirc vixen
10:39:55 <applicative_> who is the channel founder
10:39:58 <_Mikey> applicative_, thanks!
10:40:06 <lispy> I heard that lambdabot only sleeps 2 hours a night and was born in a mental asylum
10:40:12 <copumpkin> dbelange: because it is the OFFICIAL channel! SPJ hath blessed it
10:40:14 <mauke> dbelange: no, you don't
10:40:27 * Clint squints.
10:40:29 <cmccann> dbelange, I don't think you need to know, nor do I think you even care
10:40:40 <DanBurton> isn't there some command to discover who the channel founder is?
10:40:42 <dbelange> my project is due tomorrow
10:40:58 <ciaranm> /quote cs info #haskell
10:41:02 <ciaranm> says it's dons
10:41:03 <byorgey> DanBurton: yes, the command is called @get-shapr
10:41:13 <byorgey> it isn't dons.
10:41:20 <applicative_> dbelange: we have many other esoteric channels beginning ## and ### and ####
10:41:25 <cheater_> will the timespace continuum diverge if you don't find out why there is only one # in #haskell until the day after tomorrow
10:41:41 <byorgey> what is it with people from the U Waterloo CS club?
10:41:44 <cmccann> pretty sure this is still just trolling, guys
10:41:55 <dbelange> applicative_: for other esoteric languages or just this one
10:42:08 <DanBurton> byorgey: I believe #haskell predates even shapr http://www.haskell.org/haskellwiki/IRC_channel#History
10:42:25 <DanBurton> well FSVO "predates"
10:42:34 <cheater_> as in "feeds on"?
10:42:49 <byorgey> DanBurton: oh, I see, indeed.  shapr is the "father" of #haskell then, if not the "founder" =)
10:42:57 <DanBurton> byorgey: yeah
10:43:48 <applicative_> > map ((++ "haskell") . flip replicate '#') [0..]
10:43:50 <lambdabot>   ["haskell","#haskell","##haskell","###haskell","####haskell","#####haskell"...
10:43:56 <roconnor> byorgey: you make it sound as if shapr was cuckolded
10:44:02 <lispy> :t flip replicate
10:44:03 <lambdabot> forall a. a -> Int -> [a]
10:44:03 <byorgey> hahaha
10:44:29 <lispy> :t iterate
10:44:30 <lambdabot> forall a. (a -> a) -> a -> [a]
10:44:33 <applicative_> he was the natural father of #haskell
10:44:34 <byorgey> > fix (("haskell":) . map ('#':))
10:44:36 <lambdabot>   ["haskell","#haskell","##haskell","###haskell","####haskell","#####haskell"...
10:44:40 <t7> > let x = '#' ;
10:44:41 <lambdabot>   not an expression: `let x = '#' ;'
10:44:43 <lispy> byorgey: nice
10:44:44 <t7> oh boy here we go
10:45:04 <lispy> ?let x = '#'
10:45:05 <lambdabot>  Defined.
10:45:06 <lispy> > x
10:45:07 <lambdabot>   Ambiguous occurrence `x'
10:45:08 <lambdabot>  It could refer to either `L.x', defined at <local...
10:45:11 <lispy> > L.x
10:45:13 <lambdabot>   '#'
10:45:24 <DanBurton> o_O
10:45:29 <byorgey> > fix (("haskell" :) . map ('#' :)  )  -- make the smileys more apparent
10:45:29 <Elemir> :3
10:45:30 <lambdabot>   ["haskell","#haskell","##haskell","###haskell","####haskell","#####haskell"...
10:45:31 <mauke> @undefine
10:46:25 <DanBurton> > x * y
10:46:25 <lambdabot>   x * y
10:47:16 <mauke> > x ^ 3
10:47:17 <lambdabot>   x * x * x
10:47:28 <tristes_tigres> Greetings, am looking for recommendations of Haskell library to crawl a set of web pages and extract data (a set of tables) from them
10:48:26 <DanBurton> by "crawl" do you actually mean crawl as in discover the links as you go, or is the sest of pages already known beforehand?
10:48:26 <sclv> tristes_tigres: http://hackage.haskell.org/package/shpider
10:49:17 <tristes_tigres> DanBurton: A set of pages linked two levels from the main page
10:49:39 <tristes_tigres> sclv: thanks, will take a look
10:49:57 <applicative_> tristes_tigres: let the sphider monad help you
10:50:38 <tristes_tigres> applicative_: shpider looks interesting
10:52:06 <DanBurton> is tagsoup the recommended way to turn an HTML document into a tree of tags? Or is there a library more tailored to that purpose?
10:52:23 <lispy> tristes_tigres: tagsoup
10:52:34 <DanBurton> (schpider uses tagsoup)
10:52:35 <Rc43> How to bind cabal to custom-installed ghc? Will it be done automatically?
10:52:47 * applicative_ wonders if you can recursively fill out every form on the internet by a shpider action
10:53:10 <tristes_tigres> lispy: I see tagsoup n the dependencies of spider
10:53:41 <lispy> tristes_tigres: cool.  I did this recently to export an html page to excel. Look at SpreadsheetML on hackage if you need to generate excel.
10:53:43 <DanBurton> applicative_: it would be quite trivial to write such code
10:53:55 <lispy> tristes_tigres: I didn't know about shpider but I did use tagsoup
10:54:54 <applicative_> DanBurton, I suppose it is, the thought is too alarming to have occurred to me til I saw the example in the docs
10:56:11 <_Mikey> applicative_, I'm having another issue with packages
10:56:16 <roconnor> data ForkS a =
10:56:17 <applicative_> here's an unnecessarily dismal do block  do {"occupation" =: "unemployed Haskell programmer" ; "location" =: "mother's house"}
10:56:18 <roconnor>   forall f b . Executable f => Fork (IOSpec f b) (ThreadId -> a)
10:56:18 <rasfar> tagsoup is good for parsing messy html, but if you want to work with the tree structure you will want HXT rather than TagSoup.Tree...
10:56:18 <lambdabot> rasfar: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:56:23 <roconnor> how do I read that data type?
10:56:29 <rasfar> oh my!...
10:56:31 <applicative_> what package _Mikey
10:56:31 <hpaste> “_Mikey” pasted “Error” at http://hpaste.org/64815
10:56:34 <Na-Fiann> applicative_, I've made a version that slightly outperforms python, although it's probably not the nicest solution (and probably has errors still). I've tried to do the same using Data.Text, but for some reason it just uses ridiculous amounts of memory
10:56:44 <_Mikey> wxHaskell
10:57:10 <_Mikey> its complaining about stdc++ a .so file
10:57:31 <_Mikey> or sorry
10:57:46 <_Mikey> .so/.DLL directory couldn't be found
10:57:52 <ChristianS> Na-Fiann: you probably should use Data.Text.Lazy instead
10:58:02 <ChristianS> Na-Fiann: did you paste your new version?
10:58:28 <Na-Fiann> ChristianS, I am, sorry. it's also very slow, so it's just doing something wrong
10:58:29 <byorgey> roconnor: how do you read it, in what sense?
10:58:39 <roconnor> is that an existential?
10:58:53 <byorgey> roconnor: yes, it existentially quantifies over f and b
10:59:05 <roconnor> and Fork is the constructor name then?
10:59:11 <byorgey> roconnor: yes
10:59:23 <hpaste> DGel annotated “Slow” with “Slow (annotation) (annotation) (annotation)” at http://hpaste.org/64795#a64816
10:59:26 <applicative_> _Mikey: it cant find libstdc++.so I guess you must have it somewhere
10:59:47 <byorgey> roconnor: and the Fork constructor packages up three things: an IOSpec f b, a (ThreadId -> a), and an Executable dictionary for f
11:00:09 <roconnor> data ForkS a where Fork :: Executable f => (IOSpec f b) -> (ThreadId -> a) -> ForkS a ?
11:00:21 <applicative_> _Mikey: did you install the wxwidgets library already?
11:00:22 <hpaste> DGel annotated “Slow” with “Slow (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/64795#a64817
11:00:26 <byorgey> roconnor: yes, that is equivalent
11:00:33 <_Mikey> hmm not explicitly
11:00:33 <byorgey> s/equivalent/identical
11:00:41 <_Mikey> I didn't know it was a dependancy
11:00:46 <_Mikey> I could try that though
11:00:53 <roconnor> byorgey: thanks.
11:01:03 <byorgey> roconnor: you're welcome
11:04:47 <Na-Fiann> ChristianS, any ideas why the last version doesn't work?
11:05:12 <_Mikey> applicative_, I can't find the wxwidgets library
11:07:33 <pdxleif> Anyone know anything about getting this error: http://stackoverflow.com/questions/8490796/c-ath-c193-gcry-ath-mutex-lock-assertion-lock-ath-mutex-t-0-fail when using the curl bindings?
11:09:58 <applicative_> _Mikey what operating system are you using
11:12:37 <Rc43> How to make cabal to use custom-installed ghc?
11:13:02 <DanBurton> @google cabal user guide
11:13:04 <lambdabot> http://www.haskell.org/cabal/users-guide/
11:13:05 <lambdabot> Title: Cabal User Guide
11:13:17 <DanBurton> Rc43: I'm not sure, but this might help ^
11:15:03 <ChristianS> Na-Fiann: the Char8 (next-to-last) version is the fastest one so far?
11:15:53 <rwbarton> Rc43, cabal install --help | grep compiler
11:16:11 <rwbarton> actually
11:16:27 <Rc43> rwbarton, nothing
11:16:37 <Rc43> rwbarton, oooh
11:16:49 <_Mikey> applicative_,  debian
11:16:51 <Na-Fiann> ChristianS, yes
11:16:55 <Rc43> rwbarton, `register` isn't obvious name
11:17:01 <DanBurton> rwbarton++
11:17:01 <Na-Fiann> but I'm not sure if it does the right thing
11:17:06 <applicative_> there should be some debian wx package.
11:17:16 <mhitza> hey guys; given a string how could I check if it is a valid path for a file?
11:17:16 <_Mikey> ok
11:17:19 <Rc43> rwbarton, and it is not register
11:17:22 <rwbarton> Rc43, no idea what you are talking about
11:17:27 <Na-Fiann> for example, can I assume it will handle utf-8 data just fine? like I might using stings in c++?
11:17:31 <Na-Fiann> *strings
11:17:39 <Clint> mhitza: valid in what sense?
11:17:46 <applicative_> _Mikey: hm maybe wxcommon
11:17:46 <mhitza> Clint, if the file exists
11:18:06 <_Mikey> no luck
11:18:27 <hpaste> jay_gridley pasted “Decimal number parser (using Parsec)” at http://hpaste.org/64819
11:18:37 <rwbarton> I'm actually not 100% sure --with-compiler will do the right thing, but I remember achieving this before
11:18:44 <Clint> @hoogle doesFileExist
11:18:44 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
11:18:45 <rwbarton> Rc43: what are you talking about with "register"
11:18:57 <mhitza> Clint, thanks :)
11:19:03 <Rc43> rwbarton, just missed `install` word in `cabal install --help | grep compiler`
11:19:15 <rwbarton> oh
11:19:18 <mhitza> was lookin in System.IO but apparently that wasn't the place to look for
11:19:19 <_Mikey> applicative_, I'm using GHC Version 7.0.4 should I upgrade?
11:19:21 <Rc43> rwbarton, forget about it, thought that `register` takes an arg
11:19:37 <applicative_> no, thats not it
11:19:57 <Rc43> rwbarton, btw, thanks
11:20:00 <applicative_> it is just that you are trying to link with a complicated nonhaskell library.  first you need the library, then to link
11:20:38 <applicative_> it says you need wx >= 2.8 from your distro
11:21:32 <jay_gridley> hello guys, I have (maybe small problem) with parsing decimal numbers using Parsec library. I am trying to redefine Parsec default natural parser to parse only numbers (default parser accepts "1a" as number 1), but I want to return error, when there is also other char then 0-9 in that number (see that a in "1a"). How can I do that (code here http://hpaste.org/64819)? Thanks!
11:21:43 <applicative_> _Mikey: it looks like http://packages.debian.org/squeeze/wx-common has everything imaginable, maybe too much
11:21:53 <_Mikey> I have that ;)
11:22:00 <_Mikey> I just checked
11:22:19 <rwbarton> _Mikey: you probably need a debian package with a name like libwx<something>-deev
11:22:22 <rwbarton> *-dev
11:23:27 <dmwit> jay_gridley: You probably just want (whateverParsecCallsItsNumberParser <* eof).
11:23:32 <hpaste> “_Mikey” annotated “Error” with “Error (annotation)” at http://hpaste.org/64815#a64820
11:23:43 <_Mikey> I've got that.
11:24:44 <jay_gridley> dmwit: can you be more specific? I did not get your answer :-( sorry
11:25:26 <ChristianS> Na-Fiann: yes, the Char8 version should work fine, since all you do is stuff like c == ' ' and such. wouldn't work if you where checking general properties of chars such as isAlpha, but you don't do that.
11:25:36 <jay_gridley> dmwit: I simply want this... "1" -> ok  "1a" -> error
11:26:02 <rwbarton> _Mikey: looks like you may need libstdc++6 also
11:26:39 <rwbarton> or, possibly it just won't work in ghci. have you tried compiling?
11:27:08 <_Mikey> :O
11:27:15 <_Mikey> it's working!!
11:27:26 <_Mikey> didn't compile with ghc
11:27:30 <_Mikey> but with ghc --make
11:27:34 <_Mikey> bingo
11:27:50 <dmwit> jay_gridley: By default, Parsec parsers aren't required to consume the entire string they're parsing. "eof" is a parser that asserts that the entire string has been consumed. Therefore, (parsecNumberParser <* eof) is a parser that parses a number, but only if the entire string is part of the number.
11:27:55 <dmwit> jay_gridley: Try it. =)
11:28:10 <_Mikey> thanks rwbarton and applicative_
11:28:41 <dmwit> jay_gridley: (To a first approximation, "a <* b = do { v <- a; b; return v }", in case you didn't know that combinator.)
11:28:45 <dmwit> :t (<*)
11:28:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
11:28:58 <Na-Fiann> ChristianS, thanks for all the help. I have to say though, Haskell doesn't make text processing easy. Then again, comparing to python is probably not fair
11:29:03 <Na-Fiann> Have to go now in any case
11:29:08 <Na-Fiann> thanks again
11:29:15 <applicative_> oh, _Mikey, yeah, you need --make  I heard they are making it okay to just do ghc Main.hs maybe in 7.4?
11:29:25 <ChristianS> Na-Fiann: i'll give it a try myself.
11:29:37 <_Mikey> can't wait :)
11:29:41 <ChristianS> Na-Fiann: you'll be back later/tomorrow?
11:30:54 <Na-Fiann> ChristianS, yeah probably will be hacking a bit later in the evening
11:31:28 <ChristianS> Na-Fiann: ok, see you later then
11:35:54 <rasfar> @tell dreixel Thanks for the annotations.  I'm going to keep studying SYB papers (this is badly needed) and in a few days perhaps I'll be able to get that example to work.  I think it is broken as it stands, since it returns Nothing with that test...
11:35:54 <lambdabot> Consider it noted.
11:42:51 <roconnor> functionLens :: i -> Lens (i -> a) a
11:43:40 <roconnor> representableLens :: Representable f => Key f -> Lens (f a) a  ?
11:45:48 <byorgey> roconnor: looks reasonable
11:46:06 <timthelion> my my, gtk2hs really doesn't work with GHC 7.4.1 on arch.  It always SIGSEGV's when I run any of the sample apps.  Where do I report this?
11:46:13 <KorriX> what is the best haskell buildsystem ( except cabal) [something like rake for ruby] ?
11:46:34 <roconnor> [Wednesday 24 August 2011] [13:02:02] <roconnor>        edwardk: actually even better woudl be (Representable f) => f (Lens (f a) a)
11:46:40 <roconnor> looks like I've been here before
11:46:40 <adimit> KorriX: cabal.
11:46:43 <byorgey> timthelion: what version of gtk2hs are you using?
11:46:47 <timthelion> And what on earth are they doing to GHC so much now that's breaking backwards compat?
11:46:50 <mekeor> KorriX: why 'except cabal' ?
11:46:55 <byorgey> roconnor: aha, nice
11:46:57 <timthelion> byorgey: how do I get that number?
11:47:09 <byorgey> timthelion: the same thing they've always been doing to GHC. research.
11:47:10 <KorriX> too much rubbish it maskes
11:47:14 <mekeor> KorriX: Setup.hs is like a Rakefile, afaik.
11:47:19 <KorriX> thanks
11:47:28 <byorgey> timthelion: how did you install it?  just via arch?
11:47:39 <timthelion> byorgey: yes via arch: [timothy@timothy gtkbuilder]$ ./gtkbuildertest
11:47:39 <rudyl313> I want to compute CDF values for a Gaussian given a mean and variance... whats the highest performance cabal package I can use to do so (I'm guessing something that wraps gsl or something)?
11:47:40 <mekeor> KorriX: Setup.hs is cabal…
11:47:46 <Enigmagic> KorriX: or look at shake
11:47:49 <timthelion> oops, wrong paste
11:47:52 <Enigmagic> @hackage shake
11:47:52 <lambdabot> http://hackage.haskell.org/package/shake
11:47:53 <KorriX> i will look
11:47:59 <KorriX> thanks
11:47:59 <timthelion> haskell-gtk 0.12.2-2
11:48:03 <timthelion> I think?
11:48:10 <roconnor> byorgey: [Wednesday 24 August 2011] [13:02:28] <edwardk> Representable f => f (forall a. Lens (f a) a)
11:48:26 <byorgey> timthelion: generally speaking you can report bugs here: http://hackage.haskell.org/trac/gtk2hs
11:48:34 <dreixel> rasfar: can you show me the link for the code again?
11:48:34 <lambdabot> dreixel: You have 1 new message. '/msg lambdabot @messages' to read it.
11:48:36 <byorgey> timthelion: however there should be a new version of gtk2hs out soon
11:49:07 <timthelion> byorgey: thanks.  Will the new version use GTK3?
11:49:19 <byorgey> timthelion: I don't think so
11:49:36 <byorgey> roconnor: ah, indeed
11:49:56 <roconnor> I don't think this is implemented anywhere at the moment :(
11:50:35 <cgroza> Is there a function that calculates an arbitrary root of numbers? Something like root 256 12 ?
11:50:53 <byorgey> roconnor: oh, that's too bad. shouldn't be too hard to write though?
11:51:08 <ClaudiusMaximus> > 12 ** (1/256)
11:51:09 <lambdabot>   1.0097539290856021
11:51:38 <cgroza> ClaudiusMaximus: would that work for any root?
11:51:46 <timthelion> byorgey: pitty.  The whole libraries thing is chaos at the moment.  In my other life, I'm writing a driver for a device, I threw together a prototype in python, and had to use the 4 years replaced python2, because python3 doesn't have xlibs.
11:51:51 <Botje> any real root, at least
11:52:25 <byorgey> timthelion: ouch.
11:52:29 <timthelion> byorgey: When I was yonger, working on things like 5 years ago, this wasn't such a problem on linux.  Development was slower then I guess.
11:52:37 <cgroza> > 4 ** (1/4) = 1.41
11:52:38 <lambdabot>   <no location info>: parse error on input `='
11:52:46 <cgroza> > 4 ** (1/4)
11:52:46 <lambdabot>   1.4142135623730951
11:53:10 <cgroza> ClaudiusMaximus: did not work in this case.
11:53:14 <byorgey> timthelion: however, GHC 7.4 has only been out a couple months.  A humongous, monolithic package not having been updated for it yet hardly constitutes "chaos" =P
11:53:20 <rwbarton> cgroza: why do you say that
11:53:32 <cgroza> rwbarton: my bad.
11:53:41 <cgroza> rwbarton: Confused it with square root
11:53:45 <timthelion> byorgey: :)
11:53:45 <cgroza> :D
11:54:24 <ClaudiusMaximus> cgroza: sure: (a ** b) ** c = a ** (b * c)  so (a ** (1/b)) ** b = a  (modulo rounding error)
11:54:37 <roconnor> byorgey: I have this problem where I sometimes feel I'm writing functions for the sake of writing functions.
11:54:54 <cmccann> byorgey, not to mention that GHC 7.4 adds more new features compared to 7.0 than most languages add over decades :P
11:55:14 <byorgey> roconnor: hehe
11:55:14 <cmccann> roconnor, isn't that called "programming"?
11:55:28 <byorgey> roconnor: all things considered, there are much worse reasons for writing functions.
11:55:43 <byorgey> cmccann: that too.
11:55:54 <roconnor> byorgey: the other times I feel I'm writing functions for the sake of destroying the world!
11:56:00 <tgeeky_> like writing functions to free your hostage-taken family
11:56:11 <byorgey> tgeeky_: that sounds like a better reason.
11:56:19 * cmccann writes the functions he must, because he can
11:56:21 <timthelion> roconnor: What's wrong with writting functions for the sake of writting functions?  GHC will optimize anything superfluous out of existence anyways.
11:56:45 <tgeeky_> You WILL write me the fibionacci function 25 different ways, or Little Yippers gets it!
11:57:51 <roconnor> cmccann: for the good of all of us.
11:57:53 <byorgey> noooo not Little Yippers!
11:58:06 <byorgey> heh, writing the fibonacci function 25 different ways sounds like a fun challenge
11:58:21 <tgeeky_> I thought it had been done by someone, and in haskell
11:58:42 <cmccann> what did "evolution of a haskell programmer" use?
11:58:46 <pqmodn> wasn't it the post about people in various stages of understanding of haskell -- recursive, tail-call, etc
11:58:48 <cmccann> that was factorial I think, not fib
11:58:48 <ion> Combinations of trivial variations would yield that very quickly.
11:58:50 <byorgey> tgeeky_: perhaps you are thinking of http://www.willamette.edu/~fruehr/haskell/evolution.html , which involves factorial
11:58:57 <tgeeky_> byorgey: oh. :?
11:59:04 <cmccann> yeah
11:59:08 <pqmodn> byorgey: yeah, that's it
11:59:24 * cmccann wonders if he could write a type-level factorial using only type synonyms
11:59:31 <byorgey> however you could probably write a fibonacci variant corresponding to each factorial version on that page
11:59:42 <byorgey> plus there are actually more interesting ways to compute fibonacci numbers
12:00:15 <byorgey> for example see http://www.cis.upenn.edu/~cis194/static/hw6.pdf  =)
12:01:00 <dzhus> is using UTF-8 literals in source code leads to broken ByteStrings when using OverloadedStrings extension?
12:01:03 <cmccann> last time I tried doing type arithmetic with synonyms even doing exponentiation was awkward but I think polykinds will help with that
12:01:20 <basvandijk> Hello, quick question: I need to have a Monoid-like class without the mempty method. I'm sure Edward Kmett has something like that on Hackage. Anyone have an idea which package I need?
12:01:41 <cmccann> sadly I think I'd need higher-rank kind polymorphism to do really interesting stuff
12:01:56 <cmccann> basvandijk, semigroup?
12:02:05 <cmccann> http://hackage.haskell.org/package/semigroups
12:02:23 <scooty-puff> semigroupoids is pretty useful too
12:02:33 <cmccann> basvandijk, and yes, you've guessed the author correctly ;]
12:02:47 <cmccann> scooty-puff, that's Category without id, right?
12:02:48 <basvandijk> cmccann: thanks!
12:02:57 <scooty-puff> i believe so
12:06:02 <scooty-puff> last used a semigroupoid wrapper to category with a writer - so you tell'ed categories, but in the case i had, there was no good id, so warpped it in a GADT with Id :: k a a, then had unwrap<...> :: WrappedSemigroupoid k a b -> k a b -> k a b
12:06:17 <scooty-puff> or something like that - though i look at the source now and didn't make it as general as i could
12:06:18 <scooty-puff> https://github.com/sonyandy/glyph/blob/develop/src/Language/Glyph/Hoopl.hs#L73
12:07:54 <scooty-puff> (and if interested: https://github.com/sonyandy/glyph/blob/develop/src/Language/Glyph/Hoopl/Monad/Writer/Internal.hs#L73)
12:08:57 <rasfar> sorry dreixel, actually give me 5 minutes and I'll clean it up a bit to make my intentions more clear...
12:09:03 <dzhus> does only mtl export when??
12:09:55 <byorgey> cmccann: yes, Semigroupoid = Category without id, and that package also defines other things like Apply (Applicative - pure), Bind (Monad - return), Traversable1, and Foldable1
12:10:20 <dreixel> rasfar: no hurry
12:10:30 <tgeeky_> byorgey: I think I mindlessly copied the solutions for most of the things in this homework in my rivers package
12:10:39 <tgeeky_> and I even non-mindlessly copied (understood) a few of them :O
12:10:47 <byorgey> tgeeky_: =)  nice!
12:11:34 <DxBlueIce> hey guys, can anyone help creating a 3d room via textfile with hopengl?
12:12:50 <Botje> which part are you having trouble with?
12:13:54 <KorriX> how to change working directory of ghc ?
12:14:04 <rwbarton> :cd /
12:14:17 <danr> on which emailing list is it most appropriate to ask GHC API related questions?
12:14:17 <dmwit> DxBlueIce: I'm sure you didn't intend it that way, but that question is a bit rude. It comes off as "will somebody write my code for me?". A better style is to say, "I've tried X, Y, and Z, but these approaches had some drawbacks, like A, B, and C. Can you help me fix them? Here's some relevant code."
12:14:19 <byorgey> that's ghci
12:14:21 <KorriX> not ghci
12:14:24 <KorriX> ghc
12:14:31 <rwbarton> oh
12:14:40 <axx__> hello from axx_
12:14:47 <byorgey> KorriX: you can use  -i to tell it additional places to look for code; does that help?
12:14:47 <dmwit> DxBlueIce: (Sometimes the drawback is, "I couldn't get it to compile." =)
12:14:48 <rwbarton> (cd /; ghc)
12:15:03 <KorriX> thanks
12:15:03 <byorgey> hi axx__
12:15:15 <axx__> wanting to knw ,any tutorials to start off with #haskell
12:15:31 <axx__> hi byorgey
12:15:38 <byorgey> @where lyah
12:15:38 <lambdabot> http://www.learnyouahaskell.com/
12:15:39 <cheater_> @where lyah
12:15:40 <lambdabot> http://www.learnyouahaskell.com/
12:15:41 <byorgey> axx__: try that one
12:15:43 <cheater_> heheh
12:16:02 <axx__> thanks
12:16:23 <rwbarton> I wonder whether you can "change the working directory of ghc" with Template Haskell, and how confused that makes ghc. :)
12:16:56 <byorgey> hehe
12:25:27 <hpaste> rasfar pasted “SYB join -- the saga contiues...” at http://hpaste.org/64823
12:25:42 <dreixel> :)
12:26:05 <rasfar> dreixel, I really don't mind tackling it myself from here ... it's my favourite problem at the moment....
12:26:12 <k0ral> @hoogle wordsBy
12:26:12 <lambdabot> No results found
12:26:20 <DxBlueIce> dmwit: its a bit more complicated, i cant post the code here in the channel
12:26:23 <rasfar> but as you've already invested in it, you're welcome to continue!
12:27:12 <dreixel> rasfar: well, this can be fun :P
12:27:50 <rasfar> it can, but grappling with my ignorance, reading these syb papers etc. doesn't always feel fun precisely
12:28:15 <dreixel> rasfar: well, learning can be fun :)
12:28:24 <k0ral> hey, is there something like the words function but for an arbitrary Char instead of a white space ?
12:28:34 <tristes_tigres> simpleHTTP (getRequest "http://www.haskell.org/haskellwiki/index.php?title=Haskell") >>= getResponseBody >>= writeFile "tmp.html"
12:28:35 <tristes_tigres> *** Exception: tmp.html: commitBuffer: invalid argument (character is not in the
12:28:35 <tristes_tigres> code page)
12:28:35 <tristes_tigres> WTF?
12:29:20 <rasfar> okay i'm going to embrace masochism and this is going to be fun!
12:29:37 <jay_gridley> dmwit: I tried use what have you suggested in my code, but no success (I do not know how to apply it, I am new to haskell), can you give me some snippet of use of <* eof<
12:29:41 <dreixel> rasfar: but I don't understand your examples
12:29:53 <adimit> k0ral: you're looking for splitOn
12:29:57 <adimit> @hoogle splitOn
12:29:57 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
12:29:57 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
12:30:00 <dreixel> isn't "join test :: Maybe A == Nothing" ok?
12:30:12 <adimit> … well, there's also something that doesn't actually need Text...
12:30:24 <rasfar> the only problem with my example is that I'm asking to give a type argument to a function.  you can give a term of the type instead i guess...
12:30:26 <dmwit> tristes_tigres: You're not being careful about encodings, and using your system's default encoding instead of what the page reports itself to be.
12:30:29 <Botje> DxBlueIce: don't /msg me. keep chat in-channel.
12:30:31 <k0ral> adimit: how comes such a basic function isn't part of base ?
12:30:41 <rasfar> what don't you understand about the example?
12:30:43 <adimit> k0ral: dunno. Look at Data.List.Split
12:30:48 <adimit> has what you need.
12:30:57 <k0ral> thank you
12:30:58 <adimit> it's in the split package.
12:31:03 <dmwit> jay_gridley: Can you give a snippet that shows how to retrieve Parsec's natural parser that doesn't do what you want?
12:31:13 <dreixel> rasfar: isn't "join test :: Maybe A == Nothing" ok?
12:31:17 <rwbarton> k0ral, because there are many possible variations. consider the differences between words and lines for example
12:31:48 <tristes_tigres> dmwit: String cares about encoding?
12:31:53 <rasfar> there's two problems with that -- the call has no information about T of interest, and also it should return one of the A nodes as there's no shortage of them!
12:32:04 <dmwit> tristes_tigres: No, but writeFile (and probably simpleHTTP) do.
12:32:13 <dmwit> tristes_tigres: Since they are fundamentally dealing with bytes, not Haskell values.
12:32:16 <k0ral> rwbarton: so ? there are a lot of "by" functions in Data.List, I'm really surprised not to see a "wordsBy"
12:32:21 <dreixel> rasfar: oh, right, A4 is the join
12:32:29 <tristes_tigres> dmwit: simpleHTTP by itself works just fine
12:32:32 <dreixel> yes, I'm missing the very first node. forgot that.
12:32:32 <rwbarton> k0ral: I think you missed my point, but never mind.
12:32:35 <rasfar> A2 is the join over nodes of type C
12:32:41 <dreixel> no, it isn't
12:32:41 <dmwit> tristes_tigres: Then you've narrowed it down to writeFile. =)
12:32:48 <rasfar> yes, it is :)
12:32:48 <dreixel> A2 is of type A, so it can't be a join of type C.
12:33:00 <dmwit> ?hoogle hSetEncoding
12:33:00 <lambdabot> System.IO hSetEncoding :: Handle -> TextEncoding -> IO ()
12:33:01 <lambdabot> GHC.IO.Handle hSetEncoding :: Handle -> TextEncoding -> IO ()
12:33:10 <rasfar> well, yeah it can.  the join need not (and generally won't) be of the same type
12:33:10 <dekuked> hey, I just saw the yesod warp benchmark, and it's amazing
12:33:17 <dreixel> I think I still don't understand your definition of join.
12:33:17 <k0ral> rwbarton: won't you take time to enlighten me ?
12:33:30 <dekuked> I'm not much of a networking guy, but with that level of performance why bother using apache/nginx?
12:33:32 <rwbarton> I have better things to do, sorry
12:33:47 <k0ral> I understand, no problem
12:34:19 <hpaste> jay_gridley pasted “Decimal number parser (using Parsec)” at http://hpaste.org/64824
12:35:07 <tristes_tigres> dmwit: writeFile doesn't seem to have any way to specify encoding, though
12:35:08 <rasfar> dreixel: http://en.wikipedia.org/wiki/Join_%28mathematics%29
12:35:20 <dmwit> tristes_tigres: Did you see my hoogle query, above?
12:35:25 <dreixel> oh, but I know what a join is for a lattice.
12:35:32 <dmwit> tristes_tigres: Oh, yes, I understand what you mean, now.
12:35:51 <tristes_tigres> dmwiit: Ah, OK, missed it
12:35:52 <rasfar> i believe you.  so how can A2 not be the join of the C nodes?
12:36:03 <dreixel> oh
12:36:08 <dreixel> so you're not taking types into account?
12:36:43 <rasfar> well ... it just happens that the join may not be of the same type.  i'm interested in getting the smallest subtree containing all the T's.
12:36:44 <dmwit> tristes_tigres: By default, GHC checks out your system's encoding; see the documentation for hSetEncoding for more details.
12:37:04 <dreixel> oh that's a much easier definition.
12:37:15 <rasfar> fair enuf
12:37:32 <dmwit> jay_gridley: natural' <* eof
12:37:38 <dreixel> rasfar: maybe it's my fault, but it's really much clearer now
12:37:53 <rasfar> no you're right, that is a clearer problem statement.
12:37:56 <dreixel> I can try to adapt the code, if you want, or I can let you do it and help you out if you run into problems
12:38:05 <rasfar> i got thinking joins because of the algorithm i had in mind
12:38:34 <dmwit> ?tell jay_gridley Use "natural' <* eof".
12:38:34 <lambdabot> Consider it noted.
12:38:41 <DxBlueIce> i got a textfile with different chars where '|' & '-' stand for a wall and ' ' for a "free zone"(no wall). i wrote a function which reads the textfile and gives me an output like this: [((Int,Int),Char)], e.g. [((1,1),'|'),((1,2),'-')]. how can i use this to create a 3d room using the given positions and "walltypes"?
12:38:49 <dmwit> ?tell jay_gridley Don't forget to import Control.Applicative.
12:38:49 <lambdabot> Consider it noted.
12:39:01 <tristes_tigres> dmwit: just gotta copypaste source for writeFile and add hsetencoding there, I guesss
12:39:28 <dmwit> tristes_tigres: Yes, you can do that, or set your environment variable to a more Unicode-friendly encoding.
12:39:35 <jay_gridley> l
12:39:35 <lambdabot> jay_gridley: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:39:36 <rasfar> i'd like to see this general statement solved, but in fact in my particular application i *do* know the type of the join, and also all the C's are the same constructor.
12:40:00 <dreixel> rasfar: you can try to do a special case first, and then generalise
12:40:13 <dmwit> tristes_tigres: See also setLocateEncoding.
12:40:18 <rasfar> yeah
12:40:32 <dmwit> tristes_tigres: That's probably the right way to do it from inside the program. (Env variables are for from outside the program.)
12:40:41 <rasfar> can i chew on this for a bit, or do you want to get into it right now?
12:41:31 <tristes_tigres> dmwit: makes sense, thanks
12:41:45 <Botje> DxBlueIce: you could start by assembling the | and - sections into a wall.
12:42:04 <Botje> (eg. a closed polygon.)
12:42:08 <dreixel> rasfar: take your time
12:42:15 <dreixel> rasfar: this is not easy at all, btw
12:42:16 <rasfar> i know how to solve it if I can get SYB "twins" working the way I want, but honestly I need to study the area more, it's just floundering in the dark at this point.
12:42:20 <tristes_tigres> dmwit: Missing third letter i in your nick makes all the diference :)
12:42:42 <rasfar> dreixel: thanks, it helps me to hear that.
12:43:19 <dmwit> =)
12:43:28 <DxBlueIce> Botje: could you give me a function definition? like what goes in and what would be the output
12:44:12 <Botje> DxBlueIce: the output would be a closed polygon: a set of (x,y) points.
12:44:12 <jay_gridley> dmwit: Thank you very much! I am much more happy now :)
12:44:48 <DxBlueIce> Botje: well i need 3d, so (x,y,z) points?
12:45:18 <Botje> DxBlueIce: i'm guessing from your information that you're given a top-down view.
12:45:37 <DxBlueIce> Botje: yes
12:45:48 <Botje> DxBlueIce: in which case the z coordinate (up-down) doesn't matter for constructing the outline of the room.
12:46:14 <Botje> at least not yet.
12:46:56 <tristes_tigres> ?hoogle setLocaleEncoding
12:46:56 <lambdabot> No results found
12:50:03 <DxBlueIce> Botje: ok thanks so far, ill try i
12:50:03 <DxBlueIce> t
12:50:05 * edwardk looks up and sees his name mentioned
12:50:08 <dmwit> tristes_tigres: http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-IO-Encoding.html#v:setLocaleEncoding
12:50:34 <edwardk> roconnor: i vaguely remember saying that
12:50:57 <tristes_tigres> dmwit: thanks, did found it already
12:54:43 <roconnor> edwardk: when you say Tries from representations of polynomial functors , how polynomial are these polynomial functors?
12:55:08 <roconnor> edwardk: http://ncatlab.org/nlab/show/polynomial+functor  <- this polynomial?
12:56:02 <tgeeky_> roconnor: oh, no, no, no -- no way man. That's not nearly enough nomial.
12:56:18 <roconnor> nom nom nom
12:57:30 <tristes_tigres> Prelude GHC.IO.Encoding> :t setLocaleEncoding
12:57:31 <tristes_tigres> <interactive>:1:1: Not in scope: `setLocaleEncoding'
12:58:00 <Elemir> :t setLocalEncoding
12:58:00 <lambdabot> Not in scope: `setLocalEncoding'
12:58:04 <Elemir> :t setLocaleEncoding
12:58:05 <lambdabot> Not in scope: `setLocaleEncoding'
12:58:50 <Elemir> =(
12:59:42 <tristes_tigres> ?hoogle setFileSystemEncoding
12:59:42 <lambdabot> No results found
13:00:10 <jay_gridley> .
13:00:11 <tristes_tigres> ?hoogle  setLocaleEncoding
13:00:11 <lambdabot> No results found
13:00:31 <Elemir> Heh
13:00:32 <tristes_tigres> http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-IO-Encoding.html#v:setLocaleEncoding
13:00:52 <Elemir> This base is just very new
13:00:53 <tristes_tigres> WTF?
13:00:55 <Elemir> http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/GHC-IO-Encoding.html
13:01:21 <Elemir> There is no setLocaleEncoding in 4.4.1.0
13:02:38 <edwardk> roconnor: er it might be, can't really make heads or tails out of that on first reading. =) in my case i meant, 'built out of 0,1, x, + and *', not ->
13:03:33 <roconnor> edwardk: do you have a blog post about representable-tries?
13:03:37 <Botje> DxBlueIce: if you have any questions, you're free to ask
13:03:40 <roconnor> I don't get them yet
13:03:55 <edwardk> i acquired the term polynomial from the bananas in space paper
13:04:06 <edwardk> how so?
13:05:07 <dreixel> rasfar: there's a slight problem with your specification. How do you know, in general, the return type of join?
13:05:36 <edwardk> a representable functor is a functor f such that there exists an x such that f a is isomorphic to (x -> a). A representable trie for 'x' is a polynomial (sum-of-products) functor f such that f a is isomorphic go x -> a
13:05:56 <edwardk> er isomorphic to
13:06:50 <edwardk> the fact that its build out of products sums, x's and 1s mean that it gets memoized for you
13:07:17 <rasfar> dreixel: that's just it, you don't in general -- generics to the rescue no?
13:08:30 <roconnor> edwardk: okay
13:09:04 <jay_gridley> let the #haskell and all people here live forever! thanks all and see ya soon :)
13:09:24 <roconnor> edwardk: Maybe you should write that in your description of the representable-trie package :)
13:09:26 <rasfar> well, for starters we can assume the return type is A.  that would also suffice in my application (free sections) where the return type is always Exp.
13:09:44 <edwardk> roconnor: now, since a representable functor is a big pain in the butt to define (lots of classes), and because i couldn't put superclass equality constraints in until recently, the class HasTrie uses an embedding and projection into the type of the trie
13:09:47 <roconnor> edwardk: BTW, AFAIU, a polynomial functor in category theory means an indexed container.
13:10:18 <edwardk> well, these meet that definition, you can always index your way to each of the 'x's
13:11:57 <dreixel> rasfar: well, you can either consume a term generically, or produce one
13:12:12 <dreixel> rasfar: you don't consume and produce two different types generically.
13:12:28 <dreixel> rasfar: or, well, at least I've never done so :)
13:12:35 <rasfar> @tell quintessence By the way, thanks for your questions when we were discussing "generalised sections", I was very distracted at the time (had just been served food in a very chatty environment) when the whole thing went down.
13:12:35 <lambdabot> Consider it noted.
13:14:24 <Saizan> edwardk: is there a type whose trie would be defined with +?
13:14:46 <edwardk> saizan: actually no
13:15:06 <nimred> hello
13:15:13 <edwardk> the 'x's have +'s that get turned into *'s
13:15:16 <nimred> what's wrong when getting:
13:15:18 <nimred> http://sprunge.us/ZJRU
13:15:30 <dzhus> is using UTF-8 literals in source code leads to broken ByteStrings when using OverloadedStrings extension?
13:15:47 <rasfar> dreixel: i think my strategy will be to traverse the whole tree with a state monad in tow, building up a parallel structure containing necessary info, then a second, twin traversal to use it.
13:16:11 <Saizan> dzhus: yeah, because they just truncate
13:16:25 <rasfar> in the end it may turn out a single pass will be possible!
13:18:13 <dreixel> rasfar: what will the type of the function be?
13:18:30 <rasfar> dreixel: I really don't know :(
13:19:01 <dreixel> rasfar: I think you have to start with that.
13:19:10 <roconnor> edwardk: no HasTrie Integer ?
13:19:13 <DxBlueIce> Botje: still there???
13:20:02 <byorgey> nimred: it just means some of the documentation interface files were generated by a different version of Haddock
13:20:27 <byorgey> nimred: it just means that some of the documentation that's getting built will have some missing links to other packages
13:20:42 <rasfar> join :: forall a b. (Data a, Typeable b) => a -> b -> a ?
13:20:52 <byorgey> sadly I can't explain exactly why this happens and/or the canonical way to fix it, I don't quite understand it myself.
13:21:38 <nimred> byorgey: ok but packages will work, won't it?
13:21:43 <rasfar> joinAllOfType would be a better name
13:21:56 <byorgey> nimred: yes, those errors only have to do with documentation.
13:23:31 <nimred> byorgey: ok. Thanks :)
13:25:12 <rasfar> or leastCommonAncestorOfAllType
13:25:21 <Botje> DxBlueIce: what's up?
13:26:02 <DxBlueIce> Botje: i wrote a function whichs takes a String of four Points(x,y,z) and then builds a wall
13:26:03 * rasfar returns to "Scrap Your Zippers"...
13:26:11 <deech> Hi all, I'm learning to bind Haskell to C. So far I've got it where functions in "math.h" are accessible, but I can't get it to find my header file located at "./include/wrapper.h" relative to my source file.
13:26:12 <DxBlueIce> Botje: how to go on now?
13:26:28 <Botje> a string of four points? O_o
13:26:42 <Botje> can you show what you have on hPaste?
13:26:53 <DxBlueIce> Botje: sure sec ;)
13:27:05 * totimkopf loves the little bot
13:27:26 <DxBlueIce> give me 2min
13:29:02 <DxBlueIce> Botje: http://pastebin.com/yKgQW94g
13:29:04 <mauke> The paste yKgQW94g has been copied to http://hpaste.org/64829
13:30:17 <DxBlueIce> Botje: where are you from? i think i should rename the variables and functions to english; its german atm ;)
13:30:19 <hpaste> ChristianS annotated “Slow” with “Slow (idiomatic and faster version)” at http://hpaste.org/64795#a64830
13:30:50 <Botje> .be
13:31:07 <Botje> and yes, if you're asking for help it's best to use english text.
13:31:10 <ChristianS> preflex: xseen Na-Fiann
13:31:10 <preflex>  Na-Fiann was last seen on freenode/#haskell 2 hours and 16 seconds ago, saying: ChristianS, yeah probably will be hacking a bit later in the evening
13:31:50 <DxBlueIce> Botje: ok give me a few min, ill rename them
13:32:09 <Botje> shrug, i can read it.
13:32:10 <jfischoff> ChristianS: how much faster were you able to get it?
13:32:37 <Botje> also, there's nothing after baueevel
13:32:43 <Botje> *baueLevel
13:33:06 <DxBlueIce> Botje: ok :) yea i dont know how to continue there -> i think thats the part where my extracted textfile comes in
13:34:35 <monochrom> I am impartial to function names
13:34:56 <ChristianS> @tell Na-Fiann i pasted a new version at http://hpaste.org/64795#a64830 , which is about twice as fast as the python version (for me) and 30% faster than your Bytestring version.
13:34:56 <lambdabot> Consider it noted.
13:35:00 <ChristianS> @tell Na-Fiann it's also easier to understand than your version (i think), once you get the grip of haskell.
13:35:00 <lambdabot> Consider it noted.
13:35:11 <ChristianS> jfischoff: i just told.
13:35:33 <Botje> DxBlueIce: well, start by reading the text file into a data structure you're comfortable with.
13:35:51 <ChristianS> much of what i did was actually about improving readability, not about improving speed.
13:36:12 <Botje> a Data.Array or Data.Map would be my choice
13:36:36 <DxBlueIce> Botje: i wrote a function which gives me a string; sec
13:37:29 <DxBlueIce> Botje: http://pastebin.com/f6DtdZE0
13:37:31 <mauke> The paste f6DtdZE0 has been copied to http://hpaste.org/64831
13:38:58 <Botje> DxBlueIce: okay. so find the first non-empty space in the map and start following it.
13:39:09 <tazjin> I've just installed EclipseFP out of curiosity, however when I try to use it to create a project I'll get this error over and over again, until I kill eclipse (there's no GUI-way to quit this, apparently): http://hpaste.org/64832
13:40:29 <DxBlueIce> Botje: this is what i get for the "level" im using atm: [((0,1),'-'),((1,0),'|'),((1,2),'|'),((3,0),'|'),((3,2),'|'),((5,0),'|'),((5,2),'|'),((7,0),'|'),((7,2),'|'),((9,0),'|'),((9,2),'|'),((10,1),'-')]
13:41:46 <DxBlueIce> Botje: (0,1) is the position in the textfile: here: 0. line, 1. column
13:42:04 <DxBlueIce> Botje: lines and columns start at 0
13:42:28 <DxBlueIce> Botje: and the char after the position is the char i get on that position
13:44:27 <Botje> DxBlueIce: yes. so walk your file top-to-bottom, left-to-right, and find the first non-empty spot.
13:45:08 <DxBlueIce> Botje: this is the textfile: http://pastebin.com/WGYx5XYi
13:45:09 <mauke> The paste WGYx5XYi has been copied to http://hpaste.org/64833
13:45:19 <DxBlueIce> Botje: this string is already the extraction of the textfile
13:48:32 <dropdrive> Which package(s) should I use for writing a parser for MATLAB .m files?
13:49:13 <Botje> DxBlueIce: why did you not include the plus signs?
13:49:21 <Botje> DxBlueIce: they are the vertices you're after!
13:49:56 <DxBlueIce> Botje: ok sec ill include them
13:50:59 <DxBlueIce> Botje: ok, thats the output now: [((0,0),'+'),((0,1),'-'),((0,2),'+'),((1,0),'|'),((1,2),'|'),((2,0),'+'),((2,2),'+'),((3,0),'|'),((3,2),'|'),((4,0),'+'),((4,2),'+'),((5,0),'|'),((5,2),'|'),((6,0),'+'),((6,2),'+'),((7,0),'|'),((7,2),'|'),((8,0),'+'),((8,2),'+'),((9,0),'|'),((9,2),'|'),((10,0),'+'),((10,1),'-'),((10,2),'+')]
13:51:48 <DxBlueIce> Botje: so how can i use this now to build the different walls at their coordinates?
13:52:42 <Botje> DxBlueIce: start from (0,0). that's your first point. walk right until you find a second +, that's your second point.
13:53:00 <srhb> dropdrive: The binary ones?
13:53:06 <Botje> then look at the spaces around your second + and find a new wall.
13:53:15 <srhb> dropdrive: I just did that using Data.Binary and the Get monad.
13:53:37 <Botje> continue until you end up at (0,0) again.
13:53:39 <srhb> Perhaps I should clean it up...
13:54:10 <DxBlueIce> Botje: but (0,0) is just 2D, how can i transform this to 3D? just adding a 0 as the 3. coordinate to every tuple?
13:55:03 <Botje> DxBlueIce: you instantiate a given (x,y) point twice wich different z values..
13:55:20 <edwardk> roconnor: got bored and packaged up what i had ;)
13:55:23 <luxurymode> how can i combine the result of last list and init list into a single list?
13:55:38 <edwardk> roconnor: plus the tries for most numeric types are somewhat suboptimal in that they have too many entries
13:56:59 <roconnor> edwardk: how can a trie have too many entries?
13:57:52 <edwardk> roconnor: because they use a list of bits or something as the representation
13:57:56 <dougransom> I am struggling to understand the purpose of main-is: in cabal files, if main can only exist in Main.hs.  For example, the main-is:s  in http://hpaste.org/64762 do not work.    File name does not match module name:  in the hs file.
13:58:00 <DxBlueIce> Botje: i know what you mean but technically i dont see this working... e.g. (0,1): i would instantiate this 4 times because i need 4 points for a wall, like 2x(0,1,0) and 2x(0,1,5) e.g.?
13:58:01 <edwardk> or rather they convert to and from a list of bits
13:58:11 <edwardk> so there are keys in the target trie that can't be generated
13:58:18 <edwardk> which makes the traversable lie through its teeth
13:58:22 <edwardk> i just haven't had time to fix it
13:58:50 <roconnor> edwardk: okay, now I understand
13:58:55 <pdxleif> Getting a crash from an assertion in libgcrypt failing, though I only see "curl" in the cabal file.  Any idea how I can search through the code to determine how code in gcrypt is being called?
13:59:00 <roconnor> edwardk: doesn't GHC support 64-tuples?
13:59:06 <pdxleif> A sort of stacktrace?  Think gdb would be of any help?
13:59:56 <edwardk> roconnor: heh, well, you can do pretty well just converting to an array or vector i just copied what conal was doing though
14:00:23 <DxBlueIce> Botje: theres no height then, i also need to change the y-coord?!
14:00:32 <ChristianS> dougransom: i would suppose that your module must be called FuzzyTest, while main-is marks that module as the main module.
14:00:41 <edwardk> i was also starting to build skew binary nats and the associated vector used to trie them, and the trie for those vectors
14:00:46 <edwardk> then i ran out of steam
14:01:06 <Botje> DxBlueIce: no .. you would instantiate two points two times with different z values.
14:01:25 <edwardk> roconnor: re data-lens, any thoughts on some docs to put at the top to make it less scary?
14:01:42 <edwardk> e.g. the laws, etc.
14:01:44 <DxBlueIce> Botje: but isnt that justa line then?
14:01:49 <Botje> DxBlueIce: so {(0,0,0), (0,0,1), (2,0,1), (2,0,0)} for example.
14:02:04 <Botje> or the other way round, depending on which winding opengl wants.
14:02:08 <roconnor> edwardk . o ( skew binary nats .. associated vectors ... tries for those vectors ... ooh, pretty gibbs sampling )
14:02:11 <scooty-puff> :t (<>)
14:02:12 <lambdabot> Doc -> Doc -> Doc
14:02:14 <luxurymode> how do i add one list to another? in other append it o the other?
14:02:20 <luxurymode> in other words*
14:02:29 <roconnor> edwardk: ya I'll do the docs. ... "real soon now"
14:02:38 <edwardk> roconnor: yep
14:02:39 <Botje> DxBlueIce: you're already drawing quads, which expect 4 vertices per piece.
14:02:42 <scooty-puff> with which version of ghc will (<>) :: Monoid a => a -> a -> a be added?
14:02:54 <edwardk> roconnor: actually there were quite a few tangents in between ;)
14:03:11 <edwardk> besides i'm using hamiltonian monte carlo rather than gibbs sampling whereever possible now. i've evolved
14:04:47 <DxBlueIce> Botje: ok, i'll give it a try now... i understand what you said, hopefully i can do this technically. thank you very much!
14:04:49 <edwardk> scooty-puff: its in 7.4.1
14:05:05 <edwardk> scooty-puff: i should know i had to fix a dozen places that i missed in my semigroups cleanup ;)
14:06:13 <scooty-puff> k, thanks - are you just doing a CPP check - o, nevermind, guess you can just explicitly import from Monoid
14:06:37 <Jamie> Hello!
14:07:48 <Jamie> Anybody has any clue how I can replace asterisk (*) to the text file which gets the input at cmd ?
14:08:14 <tgeeky_> s/\*/<input>/g
14:08:26 <tgeeky_> but, you know, in Haskell
14:08:40 <Jamie> i.e. if the text file contains words amazing.. if i enter amazing at the cmd it will replace it with *
14:09:23 <Jamie> tgeeky : What's the first line about?
14:09:49 <scooty-puff> sed expression
14:10:25 <scooty-puff> ("man sed" and "info sed" will give you more than you may care to know about using sed)
14:11:11 <scooty-puff> but if for haskell, and your input is a string, and you don't want to use pcre, etc., then you may want to make use of view patterns or pattern guards here
14:11:43 <Jamie> ye
14:11:53 <Jamie> something like that
14:12:05 <Jamie> How would I define the syntax?
14:12:06 <Jamie> any clue?
14:12:32 <quintessence> Jamie: have you thought about how to break it into smaller problems?
14:12:32 <lambdabot> quintessence: You have 1 new message. '/msg lambdabot @messages' to read it.
14:12:45 <scooty-puff> so you just want a function that scans a string for * and replaces it with some input value?
14:13:01 <scooty-puff> :t let f ('*':xs) ys = ys ++ f xs in f
14:13:02 <lambdabot>     Occurs check: cannot construct the infinite type: m = m -> t
14:13:02 <lambdabot>     Probable cause: `f' is applied to too few arguments
14:13:02 <lambdabot>     In the second argument of `(++)', namely `f xs'
14:13:05 <scooty-puff> meh
14:13:13 <scooty-puff> :t ('*':xs) ys = ys ++ f xs ys
14:13:13 <lambdabot> parse error on input `='
14:13:20 <Jamie> hmm not :(
14:13:24 <scooty-puff> i swear, i've done this before
14:13:32 <luxurymode> when i pass last x ++ init x to my function, compiler complains that my function only expects one argument...
14:13:36 <quintessence> scooty-puff: he wants to do the opposite: he has an input word and wants to replace it with asterisks in a file
14:13:43 <scooty-puff> o, ok
14:13:45 <Jamie> yes
14:13:57 <Jamie> quintessence is right
14:14:01 <monochrom> add parentheses. (last x ++ init x)
14:14:23 <Jamie> but perhaps i may only want to display the text at terminal
14:14:26 <monochrom> of course, there may be still a type error
14:14:44 <Jamie> it's fine if am not able to change in file itself
14:15:11 <Jamie> so if i type
14:15:37 <Jamie> cat text.txt | ./asterisk amazing
14:16:01 <Jamie> this would display asterisk to the word amazing in text file and it would display at the terminal
14:17:44 <dougransom> ChristianS:I continued reading the docs on cabal and I still can't figureit out.  main-is in the examples on http://www.haskell.org/cabal/users-guide/index.html#test-suites show a haskell file named something other than Main.hs.
14:18:12 <hpaste> Dodek pasted “Fuel monad” at http://hpaste.org/64835
14:18:23 <Dodek> hey, what do you think of this code?
14:18:37 <Dodek> do you see any better way to do this?
14:18:48 <ivanm> hmmmm, I just did some benchmarks, and polyparse and parsec have similar times whereas attoparsec is about half that
14:18:55 <scooty-puff> maybe a newtype wrapper around MaybeT and StateT, to make a FuelT
14:19:04 <scooty-puff> and then type Fuel = FueldT Identity
14:19:25 * ivanm blames the Word8 -> Char -> Word8 conversions going on in the former two
14:19:29 <scooty-puff> maybe sure to get the monad transformer order right though
14:19:30 <dmwit> Dodek: That doesn't look like it satisfies the monad law (return >=> f) = f
14:19:32 <scooty-puff> *maybe -> make
14:19:40 <Jamie> quintessence : would you reckon breaking them down into smaller function ?
14:19:46 <scooty-puff> o, heh, maybe i should read more than the first 3 lines
14:20:04 <Dodek> dmwit: hmm.
14:22:15 <Dodek> dmwit: there's an underlying assumption that Just (_, 0) is never returned.
14:22:36 <Dodek> or Just (_, n) for n <= 0
14:22:55 <hpaste> “_Mikey” pasted “weird” at http://hpaste.org/64837
14:22:56 <hpaste> “_Mikey” pasted “weird” at http://hpaste.org/64838
14:24:21 <quintessence> Jamie: well, ignoring IO, it seems like you need to be able to break a string into words, replace certain words with asterisks, and put the list of words back together
14:24:55 <Jamie> so that would be words it
14:25:45 <totimkopf> I was wondering about that the other day, how would you be able to pipe to a haskell program?
14:25:48 <Jamie> and then use guarded syntax to replace if the args== something in text file
14:26:07 <totimkopf> Jamie,  are you able to get input from the pipe?
14:26:15 <srhb> totimkopf: using hGetContents?
14:26:20 <totimkopf> ooooo
14:26:28 <totimkopf> I didn't know about that :)
14:26:31 <Jamie> yh
14:26:50 <totimkopf> yh ?
14:27:06 <dmwit> Dodek: If you make that assumption, then all the (<=0) comparisons can be elided from the code. If you claim those checks are important to the functioning of the code, then you must not believe your own assumption.
14:27:28 <srhb> totimkopf: In fact, getContents reads stdin. So that would suffice.
14:27:29 <Jamie> as arguements after the name of the program
14:27:47 <totimkopf> srhb, nice, thank you
14:27:55 * hackagebot clean-home 0.0.1 - Keep your home dir clean by finding old conf files  http://hackage.haskell.org/package/clean-home-0.0.1 (IvanPerez)
14:28:21 <Dodek> dmwit: hmm.
14:28:26 <ion> cleaner-home – keep your home dir clean by finding all files
14:29:42 <Dodek> dmwit: yeah, you're right. they're remnants of past code.
14:32:11 <dmwit> ?unmtl StateT Int Maybe a
14:32:11 <lambdabot> Int -> Maybe (a, Int)
14:32:25 <dmwit> Dodek: If you elide all the checks, it looks a lot like StateT Int Maybe a. =)
14:32:26 <ivanm> ion: heh
14:32:40 <Dodek> dmwit: hah. :)
14:34:35 <DxBlueIce> Botje: still there? :P
14:35:30 <dmwit> You Could Have Invented the State Monad (and Maybe You Already Have)
14:36:38 <Botje> DxBlueIce: for about ten minutes.
14:36:57 <monochrom> how to invent the State Monad: http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
14:37:27 <DxBlueIce> i want to transform a tuple (x,y) into (x,y,0) - whats wrong with this map? make3of2Front = map (\(x,y)->(x,y,0))
14:37:56 * hackagebot clean-home 0.0.2 - Keep your home dir clean by finding old conf files  http://hackage.haskell.org/package/clean-home-0.0.2 (IvanPerez)
14:39:20 <td123> DxBlueIce: that looks fine..
14:39:27 <dmwit> DxBlueIce: Your error is elsewhere.
14:39:39 <dmwit> > map (\(x,y) -> (x,y,0)) [(1,1), (2,3)]
14:39:40 <lambdabot>   [(1,1,0),(2,3,0)]
14:40:35 <DxBlueIce> ahh i didnt give it a list, doh!
14:40:42 <DxBlueIce> ty!! :)
14:42:02 <ehy_> > fix (\(x, y) -> (2, x))
14:42:06 <lambdabot>   mueval-core: Time limit exceeded
14:42:16 <Dodek> dmwit: yeah, this is precisely it
14:42:18 <Dodek> :)
14:42:46 <ehy_> > fix (\t -> (,) 2 (case t of (x, y) -> x))
14:42:47 <lambdabot>   (2,2)
14:46:53 <DxBlueIce> whats wrong with this? baueInputWand:: MapCoord -> IO ()
14:46:53 <DxBlueIce> baueInputWand mapCoord = do
14:46:53 <DxBlueIce>   make3of2Front mapCoord
14:47:13 <DxBlueIce> type MapCoord = [(Int,Int)]
14:47:32 <DxBlueIce> make3of2Front = map (\(x,y)->(x,y,0))
14:47:56 * hackagebot clean-home 0.0.3 - Keep your home dir clean by finding old conf files  http://hackage.haskell.org/package/clean-home-0.0.3 (IvanPerez)
14:48:05 <ivanm> @hpaste
14:48:05 <lambdabot> Haskell pastebin: http://hpaste.org/
14:48:07 <ivanm> DxBlueIce: ^^
14:48:11 <ivanm> also, error messages help
14:48:12 <shachaf> I think "map (\(x,y)->(x,y,0))" might be a better name than "make3of2Front"
14:48:40 <ivanm> but looking at your code, I'm going to randomly guess the fact that baueInputWant has nothing to do with IO
14:48:44 <ivanm> shachaf: agreed
14:48:48 <ivanm> unless it gets used a lot
14:49:35 <shachaf> It depends on the context. It's a bit of a weird function.
14:49:40 <DxBlueIce> http://pastebin.com/QwDFz6P9
14:49:42 <mauke> The paste QwDFz6P9 has been copied to http://hpaste.org/64842
14:50:09 <DxBlueIce> its not complete yet, just wanted to test it
14:51:27 <ivanm> DxBlueIce: and the error would still be in baueInputWand because its type is wrong
14:52:08 <DxBlueIce> whats wrong with the type?
14:52:34 <ivanm> DxBlueIce: put it this way... what's your error message?
14:52:47 <DxBlueIce> src\Wand.hs:35:3:
14:52:47 <DxBlueIce>     Couldn't match expected type `IO ()'
14:52:47 <DxBlueIce>                 with actual type `[(t1, t2, t0)]'
14:52:47 <DxBlueIce>     In the return type of a call of `make3of2Front'
14:52:47 <DxBlueIce>     In the expression: make3of2Front mapCoord
14:52:47 <DxBlueIce>     In the expression: do { make3of2Front mapCoord }
14:53:03 <ivanm> now you know what I mean :)
14:53:17 <ivanm> DxBlueIce: how does "make3of2Front mapCoord" have anything to do with IO?
14:53:32 <DxBlueIce> oh i see lol
14:53:47 <tristes_tigres> anyone managed to install curl from hackage on windows?
14:54:03 <DxBlueIce> that was stupid
14:54:12 <DxBlueIce> ty
14:54:22 <Botje> DxBlueIce: don't paste stuff into the channel, use a pastebin.
14:54:34 <Botje> DxBlueIce: and if you use hpaste you can nicely annotate your code with errors and/or new versions.
14:56:31 <DxBlueIce> ok, whats hpaste
14:56:44 <monochrom> hpaste.org
14:56:49 <DxBlueIce> i see
15:01:41 <JoeyA> How do you pronounce Kleisli?
15:02:25 <DxBlueIce> gn8 all :) tyvm everyone who helped me!
15:03:08 <koala_bot> Hey #haskell :)
15:04:36 <maxxe> any good book for beginners with haskell that is recommended?
15:04:50 <koala_bot> Learn You A Haskell was good for me
15:05:05 <Elemir> TAPL :3
15:05:26 <ChristianS> dougransom: in my own cabal file, i have several entries of the form  Executable respell\n  Main-is: respell.hs , and it works fine.
15:09:20 <maxxe> koala_bot: thanks
15:09:29 <maxxe> koala_bot: looks good
15:09:42 <koala_bot> :)
15:10:13 <koala_bot> Would someone be able to help me with Maybe? I'm trying to declare a function which takes a list of integers and maybe returns an integer, but I'm apparently not declaring that correctly.
15:10:44 <maxxe> just found out xmonad. written in haskell. really rocks. so i got intrested in this language, maybe i should learn it =)
15:11:32 <koala_bot> There are certainly a lot of people coming and going in here... pretty wild.
15:12:19 <maxxe> =)
15:12:34 <Botje> koala_bot: some_function :: [Integer] -> Maybe Integer
15:13:15 <Botje> i guess?
15:13:15 <koala_bot> Botje: That was what I originally had, to little success. I have instead tried this and still am nowhere: getMinEven :: Integral a => a -> [a] -> Maybe a
15:13:17 <Botje> << sleep
15:13:46 <Botje> koala_bot: looks fine to me. what is the compiler complaining about?
15:14:00 <Elemir> @hoogle [a] -> Maybe a
15:14:00 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
15:14:00 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:14:01 <lambdabot> Prelude head :: [a] -> a
15:14:10 <Elemir> 03:14 < lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
15:14:12 <Elemir> This?
15:14:32 <koala_bot> "Couldn't match expected type '[a] -> Maybe a' with actual type 'Maybe a0'
15:14:46 <Botje> koala_bot: some code to go with that should be nice.
15:15:09 <Botje> koala_bot: sounds like you're giving a parameter too much or too few
15:15:55 <hpaste> koala_bot pasted “Maybe” at http://hpaste.org/64843
15:17:07 <Elemir> :t minimum
15:17:07 <lambdabot> forall a. (Ord a) => [a] -> a
15:17:31 <koala_bot> :t minimum (filter even [1,2,3])
15:17:32 <lambdabot> forall a. (Integral a) => a
15:17:36 <Elemir> :t minimum (filter even ns)
15:17:36 <lambdabot> Not in scope: `ns'
15:17:41 <Elemir> Auch
15:17:41 <koala_bot> ;)
15:18:10 <Botje> koala_bot: minimum will return an element, not a Maybe value.
15:18:16 <Elemir> Just $ minimum (filter even ns)
15:18:19 <Elemir> for example
15:18:21 <Botje> so that should be Just (minimum (filter even ns))
15:18:24 <Botje> *however*
15:18:39 <Botje> it's possible that filter removed all numbers from ns, and minimum [] is an error.
15:19:21 <Botje> so you want something like "case filter even ns of [] -> Nothing; xs -> Just xs"
15:19:52 <koala_bot> This is getting beyond the syntax I am expected to know for this assignment, which is a red flag
15:20:28 <Elemir> Botje: "case filter even ns of [] -> Nothing; xs -> Just (minimum xs)"
15:20:45 <koala_bot> It of course does not help that my professor seems to be under the impression that Haskell has no exceptions
15:20:50 <koala_bot> http://web.cecs.pdx.edu/~antoy/Courses/CS558/homework/exceptions.html Problem 2
15:21:13 <Elemir> Haskell has many variants of exceptions
15:21:15 <rostayob> koala_bot: Exceptions are problematic in haskell
15:21:28 <koala_bot> So I see :P
15:21:42 <Elemir> They aren't. ErrorT is nice
15:21:42 <rostayob> koala_bot: in the sense that there is no "one" way to have exceptions
15:21:54 <rostayob> they're not a language constructor
15:22:01 <Botje> koala_bot: i'm just stringing together basic functions.
15:22:14 <rostayob> Elemir: well, nice. it forces you to use a monadic interface
15:22:18 <rostayob> it's one way of doing things
15:22:23 <Botje> koala_bot: you *could* separate the minimum and filter steps and put a function inbetween.
15:22:31 <Botje> of course I have no idea how much haskell you actaully know.
15:22:36 <rostayob> it depends on what you need to do really, from Maybe to ErrorT to Control.Exception
15:22:39 <Botje> and now I'm off to bed.
15:22:45 <koala_bot> rostayob: I understand that, but the vernacular in the problem description is frustrating...
15:23:02 <koala_bot> Botje: I can create functions and whatnot but there are some constructs that I haven't worked with
15:23:18 <rostayob> koala_bot: did your professor write "Haskell has no exception, no arrays, and no methods."?
15:23:27 <koala_bot> Yes
15:23:35 <rostayob> yeah that's a silly phrase.
15:23:44 <monochrom> exactly wording from that page
15:23:55 <rostayob> monochrom: yeah I copy pasted
15:23:57 <Botje> koala_bot: okay, so feed the result of filter even ns to a function of your own
15:24:06 <rostayob> koala_bot: maybe he's joking
15:24:10 <Botje> .. which does what I put in the case expression :)
15:24:27 <koala_bot> rostayob: I've hoped so in previous cases and been disappointed.
15:24:28 <rostayob> koala_bot: a lot of relevant haskellers come from pdx!
15:25:02 <monochrom> however, "no exception" is a useful first approximation. you can have exceptions if you get IO involved, but this homework avoids IO, so, may as well ignore exceptions
15:25:17 <koala_bot> I agree - my actual Haskell/functional langs professor is fabulous. But this course is a programming language paradigms course and the prof seems.... behind the times/misinformed some times
15:25:30 <rostayob> koala_bot: the function he's asking is '[Integer] -> Maybe Integer'... and it's a short one liner
15:25:39 <monochrom> most profs who use haskell in class are outdated
15:25:46 <hpaste> Elemir pasted “Data.Binary and laziness” at http://hpaste.org/64844
15:25:55 <koala_bot> rostayob: i agree and have the logic, but i'm having a failure of syntax more than a failure of concept i think
15:26:07 <monochrom> but not to the point of "no arrays"
15:26:15 <rostayob> if minimum returned a Maybe it'd be 'minimum . filter even'
15:26:25 <rostayob> but it doesn't, so you have to get around that
15:26:40 <rostayob> also, I fail to see how arrays matter in this context.
15:26:52 <rostayob> or "methods" (I suppose he's talking about OO methods)
15:26:58 <rasfar> JoeyA: I've only heard Kleisli pronounced as "kleezly" although this goes against the usual rule I follow that "ei" is pronounced like "eye".  And Klein/Kleine is more "eye" than "ee".  Anyone?
15:27:21 <rwbarton> kleyeslee
15:27:26 <Elemir> Guys, whats wrong with my code?
15:27:35 <rasfar> okay, thanks
15:27:47 <monochrom> well, Problem 1 mentions "method". OTOH, that is totally unnecessary too. you don't need method in C++ for this homework either.
15:28:09 <deech> Hi all, is there a tutorial or an example package on Hackage that shows how to bundle xxx.so or xxx.dll?
15:28:13 <merijn> rasfar: I would say its like eye (at least that's the usual Dutch/German pronunciation of the digraph, I'm not sure where he's from, though)
15:29:30 <rasfar> okay, the rule holds then.  although he is USA so there's always the chance of a change that way.  rwbarton seems certain, we can go with that I think.
15:29:36 <solidsnack> deech: http://www.well-typed.com/blog/30
15:29:46 <solidsnack> However, this leaves many things to the imagination...
15:30:03 <solidsnack> A while back I put this together: https://github.com/solidsnack/hso/tree/master/well-typed
15:30:12 <rostayob> Elemir: nothing
15:30:22 <tristes_tigres> Has anynone successfully installed curl from hackage on Windows?
15:30:24 <Elemir> Но-но. It locks
15:30:27 <solidsnack> deech: There is a Makefile and some notes.
15:30:29 <Elemir> *No-no
15:30:40 <rostayob> Elemir: it works for me, I didn't read closely
15:30:45 <deech> solidsnack: Thanks!
15:30:55 <Elemir> It wait 10 sec and when output [49,50,51,10]
15:31:03 <Elemir> *waits, outputs
15:31:22 <solidsnack> deech: Beware, this is hard.
15:31:29 <rostayob> Elemir: well of course, how would getWord8List know when it has to stop reading?
15:32:09 <Elemir> Em?  It must generate lazy list, no?
15:32:19 <solidsnack> deech: I also have a process for making static binaries on Linux, for my Arx tool. I have to update this crazy linker script each time GHC changes: https://github.com/solidsnack/arx/blob/master/ubuntu/link.sh
15:32:33 <solidsnack> deech: On OS X it all works magically, though.
15:32:33 <deech> solidsnack: I was looking over the article, and maybe I wasn't clear but I was bundle a pre-compiled C++ library into a Haskell project so the user doesn't have to build it themselves.
15:33:10 <deech> s/was/want to/
15:33:26 <rostayob> Elemir: so you're expecting "print" to start printing the list and then finally terminate later?
15:33:27 <hpaste> koala_bot pasted “Guards” at http://hpaste.org/64846
15:33:27 <solidsnack> deech: When you say bundle, do you mean, statically link?
15:33:32 <Elemir> yes
15:33:39 <rostayob> Elemir: binary is strict
15:33:40 <koala_bot> rostayob: would you mind taking a look at that?
15:33:42 * tristes_tigres hates curl package
15:34:08 <deech> solidsnack: I mean I want to include xxx.so in the distribution so that the user doesn't need to have it present in /usr/local/lib/... or whatever.
15:34:23 <rostayob> koala_bot: that should work, but it's not the best way to write that
15:34:43 <Elemir> Why does it use *lazy* bytestring?
15:34:48 <rostayob> koala_bot: also, the type signature is wrong
15:34:54 <koala_bot> Oh?
15:34:57 <Elemir> Is there lazy version of data-binary?
15:35:11 <rostayob> Elemir: the lazy bytestring has nothing to do with how strict binary is
15:35:32 <solidsnack> deech: Okay. Will they build the Haskell files, too?
15:35:39 <rostayob> koala_bot: it should be [a] -> Maybe a, not a -> [a] -> Maybe a
15:36:46 <solidsnack> deech: You could use linking with rpaths...
15:36:49 <koala_bot> Fix that, add some parentheses, and I'm compiled :) Thank you rostayob. That was obfuscating another issue.
15:37:15 <rostayob> koala_bot: hint: you only need one case in the function
15:37:22 <rostayob> and you don't need to run 'filter' twice.
15:38:04 <koala_bot> I know I can take the first empty list check out, but i'm not sure why I don't need to run filter twice
15:38:11 <koala_bot> nevermind.
15:38:14 <koala_bot> I see :)
15:38:17 <deech> solidsnack: Yes, so specifically I'm writing bindings to an existing C++ library that compiles down into a single small library file. I want to include that platform-compiled versions of that file in my hackage package so that the user doesn't need to have the library present on their system.
15:38:58 <rostayob> koala_bot: and tell your professor that haskell has arrays, exceptions, and certainly doesn't need java-style objects!
15:39:00 <koala_bot> actually, rostayob how do I maintain the filtered list without calling filter again?
15:39:11 <rostayob> koala_bot: do you know how the "case" construct works?
15:39:29 <solidsnack> deech: Okay, maybe you want to use rpaths...
15:39:30 <rostayob> (or you could also define an auxiliary function)
15:39:37 <koala_bot> No I don't, which is why I went this route rather than following the advice above
15:39:51 <deech> solidsnack: I don't know what those are but I'll look into it. Thanks for your help!
15:40:07 <koala_bot> This isn't elegant, but it seems to be doing what I need... is there something blatantly bad about how I'm going about this?
15:40:15 <rostayob> koala_bot: well you should read up about haskell a bit more then :). you don't need a case anyways, another function is enough
15:40:29 <rostayob> koala_bot: calculating filter twice is useless
15:40:40 <koala_bot> ha, rostayob :) I would if I had the time! I've got to prioritize and getting ahead of my class won't do me much good.
15:40:47 <deech> solidsnack: Will cabal's "Include-Dirs" handle something like this?
15:40:56 <solidsnack> deech: I do not know.
15:41:02 <deech> solidsnack: Thanks!
15:41:02 <solidsnack> deech: That sounds like headers.
15:41:15 <rostayob> koala_bot: of course it will, you can play *that* guy who knows more than the professor and annoys everyone else
15:41:32 <koala_bot> No time :)
15:41:40 <solidsnack> deech: I did something for this a long time ago. Bundling a Haskell program with libffi and using rpath so the linker would find it.
15:41:42 <koala_bot> Another class needs this room for now so I'd better go, but thanks for your help!
15:41:47 <rostayob> koala_bot: eheh bye
15:41:51 <solidsnack> deech: Maybe Cabal also supports this.
15:42:59 * hackagebot hR 0.1.1 - R bindings and interface  http://hackage.haskell.org/package/hR-0.1.1 (DylanSimon)
16:00:23 <tristes_tigres> OK,  here's instruction how to install curl on windows
16:00:24 <tristes_tigres> http://haskell.forkio.com/Home/curl-win32
16:00:37 <tristes_tigres> maybe someone will find useful
16:00:47 <tristes_tigres> worked for me
16:09:32 <srhb> Why is map \x -> 2 [1,2,3] a parse error?
16:09:58 <srhb> is it because of -> ?
16:10:03 <irene-knapp> > map $ \x -> 2 [1, 2, 3]
16:10:04 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [b])
16:10:05 <lambdabot>    arising from a use ...
16:10:06 <t7> its the \x
16:10:15 <irene-knapp> well, that's correct syntax at least
16:10:19 <irene-knapp> it needs the $ or parentheses
16:10:30 <t7> no its not, 2 is applied to [1,2,3]
16:10:40 <irene-knapp> oh, duh
16:10:45 <ion> > 2 [1,2,3]  -- not invalid syntax
16:10:46 <lambdabot>   2
16:10:51 <irene-knapp> > map (\x -> 2) [1, 2, 3]
16:10:51 <lambdabot>   [2,2,2]
16:10:52 <ion> Just another kind of an error.
16:10:53 <shachaf> Applying 2 to to [1,2,3] is correct syntax.
16:10:55 <totimkopf> so its a precedence thing ?
16:11:05 <shachaf> No, but it's a syntax thing.
16:11:14 <shachaf> You can't say f \x -> y
16:11:36 <ion> I’d prefer that you could, though.
16:11:39 <shachaf> Both "map (\x -> 2 [1,2,3])" and "map (\x -> 2) [1,2,3]" are syntactically valid.
16:11:56 <shachaf> The former is closer to what srhb wrote; the latter is probably what srhb meant, but GHC isn't a mind reader.
16:16:10 <edwardk> preflex: xseen thoughtpolice
16:16:10 <preflex>  thoughtpolice was last seen on freenode/#haskell-blah 1 hour, 46 minutes and 23 seconds ago, saying: yeah
16:17:39 <losvedir> preflex: xseen losvedir
16:17:39 <preflex>  losvedir was last seen on freenode/#haskell 10 days, 4 hours, 22 minutes and 14 seconds ago, saying: :t mapMaybe
16:18:04 * hackagebot isohunt 0.1 - Bindings to the isoHunt torrent search API  http://hackage.haskell.org/package/isohunt-0.1 (ReinerPope)
16:18:12 <losvedir> aw, i'm somewhat disappointed it didn't include that command itself
16:18:55 <ivanm> @ask chrisdone how do I disable the auto-expansion of "if" into "(if then else)" ?  the parens aren't always needed, I want it split over a few lines and it doesn't do what it's meant to in some cases I've found
16:18:55 <lambdabot> Consider it noted.
16:18:57 <otters> :t mapMaybe
16:18:58 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
16:19:32 <Elemir> :t runMaybe
16:19:33 <lambdabot> Not in scope: `runMaybe'
16:19:35 <Elemir> :(
16:19:57 <byorgey> :t maybe
16:19:58 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:20:01 <byorgey> Elemir: ^^
16:23:40 <ivanm> @ask chrisdone is it just a matter of specifying it with a defvar in my own config?
16:23:40 <lambdabot> Consider it noted.
16:25:22 <tazjin> I just saw this on Reddit, and I don't get it. http://i.imgur.com/VULna.png
16:27:27 <ivanm> tazjin: I'm going to guess it's by someone that doesn't like Haskell
16:27:49 <levi> Reddit is pretty lame these days.
16:28:27 <tazjin> ivanm: Well, I got that far - but what exactly is he trying to say? I just don't get the content at all
16:28:47 <ivanm> tazjin: that I/O in Haskell is really bad
16:28:50 <ivanm> and different
16:28:54 <byorgey> he appears to be trying to say "fudge", but he can only get the first two letters out
16:28:56 <ivanm> and difficult to understand or do right
16:29:00 <ivanm> byorgey: heh
16:29:07 <ivanm> byorgey: mouth too full? :p
16:29:12 <byorgey> probably
16:29:35 <levi> Too deformed to properly enunciate words.
16:29:46 <rostayob> tazjin: I don't get it either
16:29:52 <solidsnack> It's funny because actually many things about Haskell I/O and side-effects, &c., are really nice and controllable.
16:29:59 <rostayob> and I've been using Haskell for a while
16:30:05 <rostayob> but I have no sense of humor :(
16:30:35 <roconnor> > let fibs = 1:1:(zipWith(+)`ap`tail) fibs; rpt = flip take . repeat in zipWith((. rpt 'u').(++).rpt 'f')`ap`tail $ fibs
16:30:37 <lambdabot>   ["fu","fuu","ffuuu","fffuuuuu","fffffuuuuuuuu","ffffffffuuuuuuuuuuuuu","fff...
16:30:38 <jfischoff> he just needed to read this http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
16:30:46 <solidsnack> For example, not too long ago I was using Ruby's File#flock to hold a POSIX lock...but because the handle was not returned from the lock function, it was GC'd and the lock disappeared while the process kept running.
16:30:56 <roconnor> c/o [Wednesday 14 December 2011] [13:35:58] <xplat>
16:30:59 <rostayob> jfischoff: that's a bit outdated on the current practices
16:31:01 <rostayob> still a good read
16:31:17 <rostayob> jfischoff: but what you read probably doesn't apply now :P
16:31:31 <tazjin> roconnor: You just won 87 internets
16:31:48 * roconnor hands the prize to xplat
16:32:56 <rostayob> roconnor: fibonacci, found everywhere in nature, from shell spirals to rage comics.
16:33:03 <roconnor> *L*
16:33:19 <ivanm> is one reason why attoparsec is faster when parsing lazy bytestrings because it uses the internal's of bytestring to get the individual chunks?
16:34:12 <rostayob> ivanm: faster than what?
16:34:21 <ivanm> rostayob: parsec or polyparse
16:34:32 <ivanm> I'm doing some benchmark comparisons
16:34:42 <ivanm> parsec and polyparse are roughly the same in my use-case
16:34:47 <ivanm> attoparsec is twice as fast
16:34:58 <rostayob> ivanm: attoparsec is faster than parsec for various reason
16:35:09 <ivanm> right
16:35:12 <rostayob> I wouldn't think that acessing the bytestrings internal would make such a difference, but maybe it does
16:35:16 <solidsnack> ivanm: Are you using Char or Word8 token type?
16:36:04 <ivanm> solidsnack: I've just ported polyparse's bytestring parser to using Word8 (and malcolmw said he's do that in the next release); it drops the average runtime via criterion from 2.6 to 2 seconds
16:36:20 <solidsnack> ivanm: Hmm, okay.
16:36:21 <ivanm> in comparison, parsec is about 2.8 and attoparsec is about 1s
16:37:03 <ivanm> I was digging through attoparsec's guts, and it seems to explicitly parse the various chunks in a lazy bytestring, and then use unsafe variants of head/tail rather than just uncons like polyparse does
16:38:03 <ivanm> then again, bytestring's uncons uses the unsafeHead/unsafeTail functions internally, so that can't be it on its own
16:38:05 <rostayob> ivanm: in general, attoparsec is tailored around bytestrings. parsec is much more general
16:38:18 <ivanm> rostayob: right, I don't care about parsec itself that much
16:38:33 <rostayob> so I'd guess that that already gives GHC much more space to optimize
16:38:43 <ivanm> I'm used to polyparse, but I have to do some bytestring parsing, so I wanted to see whether the speed difference was all that great
16:38:55 <ivanm> (between polyparse and attoparsec)
16:39:12 * ivanm wonders whether a few commits would make a difference in the polyparse runtime
16:39:49 <luxurymode> How can I define functions inside of GHCI?
16:40:16 <rostayob> ivanm: it looks like it could, since apparently polyparse defines a datatype specificallyf for ByteStrings
16:40:30 <rostayob> and the interface is really similar iirc
16:40:49 <donri> luxurymode: let x = y
16:40:51 <ivanm> luxurymode: ghc < 7.4, use let foo x = ...
16:41:01 <ivanm> as of 7.4, I believe you can define them as you would in a source file
16:41:01 <donri> i don't think 7.4 helps
16:41:11 <Cale> no you can't
16:41:13 <luxurymode> 7.4 does help is what ive been told
16:41:13 <donri> it only adds ability to do statements like data, newtype etc
16:41:16 <luxurymode> but i dont have 7.4
16:41:17 <ivanm> Cale: oh?
16:41:25 <ivanm> I thought 7.4 let you define anything you wanted in ghci
16:41:29 <Cale> You still need to use let to make definitions in 7.4.1
16:41:37 <ivanm> ahhh
16:42:02 <timemage> luxurymode,  let x = (\y -> y * 2)     -- i can do that in 7.0   dunno if that helps at all.
16:42:19 <Cale> Or even  let x y = y * 2
16:42:27 <timemage> ah
16:42:45 <axx__> hi
16:42:46 <axx__> Question: Why is product [] = 1
16:43:11 <axx__> excuse...Newbie here
16:43:19 <Rotaerk> axx__, identity of multiplication is 1
16:43:20 <tazjin> @src product
16:43:20 <lambdabot> product = foldl (*) 1
16:43:39 <Axman6> axx__: what do you think the product of [] should be instead?
16:43:44 <byorgey> axx__: think about defining product recursively.   product (x:xs) = x * product xs;  product [] = ?
16:43:56 <Rotaerk> axx__, the question is equivalent to "why is product [x] = x"
16:44:00 <tromp__> because product (x:xs) should be x * product xs
16:44:03 <byorgey> axx__: so product [2,3] = 2 * 3 * product []
16:44:13 <Rotaerk> product [2,3] = 1 * 2 * 3
16:44:25 <Rotaerk> yea that
16:44:41 <axx__> yes. thats it..thanks
16:44:59 <byorgey> axx__: don't feel bad asking newbie questions, you just have to be prepared to get 17 answers ;)
16:45:22 <ivanm> rostayob: maybe it needs some more INLINE pragmas or something...
16:45:23 <axx__> what 17 answrs?..
16:45:26 <rostayob> > mappend . map Product [1..10]
16:45:27 <lambdabot>   Overlapping instances for GHC.Show.Show
16:45:27 <lambdabot>                              (Data....
16:45:31 <rostayob> > mappend . map Product $ [1..10]
16:45:32 <lambdabot>   Overlapping instances for GHC.Show.Show
16:45:32 <lambdabot>                              ([Data...
16:45:39 <ivanm> axx__: you got off lucky this time, that's all :p
16:45:40 <byorgey> axx__: I just mean 17 people answering you at once, not 17 different answers =)
16:45:42 <rostayob> > mconcat . map Product $ [1..10]
16:45:43 <lambdabot>   Product {getProduct = 3628800}
16:45:50 <axx__> lol
16:45:51 <monochrom> my http://www.vex.net/~trebla/homework/empty.html explains why empty product is 1 etc
16:45:56 <ion> > ala Product Data.Foldable.foldMap [1..10]
16:45:56 <lambdabot>   3628800
16:46:21 <monochrom> but yes it comes down to the identity element for the operator
16:46:59 <rostayob> axx__: guess what 'sum []' is
16:47:05 <axx__> 0
16:47:08 <rostayob> axx__: if that makes sense, than 'product []' makes sense
16:47:22 <axx__> yes..very clearly it does
16:47:44 <ivanm> though IIRC, don't some mathematicians think that's a bad definition? :p
16:48:05 <monochrom> rostayob: it begs the question of what "sense" means. some people have this sense: 0 means "empty", therefore the answer is 0 for empty sum, empty product, empty everything
16:48:42 <monochrom> or rather, 0 "means" "empty"
16:48:43 <rostayob> monochrom: well "sense" in the algebraic sense
16:49:04 <monochrom> well then you have to explicitly say "algebraic"
16:49:25 <rostayob> axx__: if that makes sense in the algebraic sense, than 'product []' makes sense in the algebraic sense.
16:49:51 <roconnor> sum [] is 0 because sum "is" foldr (+) 0
16:50:12 <rostayob> product [] is 1 because product "is" foldr (*) 1
16:50:18 <roconnor> yep
16:50:25 <axx__> rostayob: it made sense in all possible worlds
16:50:36 <axx__> foldr
16:50:42 <rostayob> product [] is 42 because product "is" foldr (*) 42
16:51:06 <roconnor> rostayob: foldr (*) 42 doesn't give you the product of a list of numbers.
16:51:08 <Axman6> foldr? really? sure it's not foldl?
16:51:17 <niteria> it makes sense because [] 0 1 neutral elements in their respective groups (?)
16:51:22 <roconnor> Axman6: foldr is the catomorphism, not foldl
16:51:23 <rostayob> roconnor: yeah I was joking :)
16:51:44 <niteria> dunno about [] being a group, I meant empty set
16:51:47 <roconnor> rostayob: my comment was really for the 859 member audience
16:52:00 <ion> product clearly should take the identity value as a parameter.
16:52:12 <monochrom> this is why my explanation does not mince words like "mean", "sense". a formula is worth a thousand pictures. if you want product xs * product ys = product (xs ++ ys) to work, even when ys=[], then the answer is forced. clear and motivating.
16:52:25 <roconnor> niteria: respective monoids
16:52:52 <magicman> ion: And also the multiplication operator to be used, while we're at it :p
16:53:13 <ion> magicman: indeed
16:54:18 <thoughtpolice> edwardk: pong
16:54:30 <thoughtpolice> blasted naps
17:04:38 <koala_bot> This channel has a truly amazing number of people coming and going in any 5 minute time frame
17:06:36 <nand`> koala_bot: you may wish to consider turning off join/part/quiet messages. Makes channels much more conversation friendly. :)  (am I replying to a bot?)
17:07:06 <koala_bot> nand: I'm in the web client for the moment - is there a command to do that independent of the environment?
17:08:48 <niteria> not really
17:08:55 <koala_bot> Ah. Thanks niteria.
17:09:27 <nand`> koala_bot: no, but if you use the free client weechat I could help you, you may wish to consult the documentation of whichever client you are using and/or ask in that client's IRC channel
17:09:29 <niteria> depends on a client, I can tell you the incantations if you use irssi
17:09:46 <nand`> And that covers the two best clients ;)
17:09:59 <koala_bot> I've got kvIRC, but not in the mood to fight with it at the moment. It's dinner time :)
17:13:13 <niteria> if you were to implement Data.Array in pure Haskell what would you use (which data structure)?
17:13:29 <niteria> it's my homework
17:14:08 <niteria> I considered splay tree
17:14:30 <Cale> Probably Data.IntMap, haha
17:14:54 <JoeyA> Good question.  IntMap seems like a fine choice, but is there something better?
17:14:56 <niteria> that's cheating
17:15:02 <JoeyA> Why is IntMap cheating?
17:15:19 <JoeyA> Oh, you have to implement the search tree or whatever yourself, right?
17:15:26 <niteria> yeah
17:15:44 <niteria> btw, is IntMap pure haskell?
17:15:57 <Cale> yeah
17:16:40 <niteria> oh, patricia tree
17:16:43 <JoeyA> niteria: Does it have to be immutable?
17:16:53 <JoeyA> err, mutable
17:16:57 <JoeyA> Does it have to be mutable?
17:17:01 <niteria> immutable
17:17:19 <JoeyA> Does it have to support efficient update (which Data.Array does not, if I'm not mistaken)
17:17:31 <niteria> but same interface as Data.Array, so IntMap is to specific
17:17:42 <niteria> not really, just lookup
17:17:51 <Cale> IntMap is easily wrapped to provide the same interface as Data.Array
17:19:19 <niteria> IntMap should be faster than any BST?
17:20:24 <JoeyA> niteria: You could build a balanced binary search tree by cutting the list in half.
17:21:09 <JoeyA> So if you're converting [1,2,3,4,5,6,7] to an array, start by creating a node whose value is 4, whose "left" is fromList [1,2,3] and whose "right" is fromList [5,6,7]
17:21:18 <JoeyA> The fromList function would be recursive.
17:21:30 <niteria> I think ezyang had a blog post on that
17:21:38 <JoeyA> Might not be fastest, but it's simple.
17:21:43 <niteria> with nice pictures
17:22:39 <niteria> http://blog.ezyang.com/2012/02/visualizing-range-trees/
17:23:07 * hackagebot xss-sanitize 0.3.1.1 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.1.1 (GregWeber)
17:24:04 <niteria> oh, it was quicksort tree building
17:25:38 <niteria> JoeyA: your idea seems like it's the simplest thing that works
17:26:03 <niteria> I'll go with that
17:26:42 <JoeyA> Hurray, I'm useful!  ( http://www.youtube.com/watch?v=le6Rvy5Ccb0 )
17:27:18 <niteria> ^^
17:35:17 <latros> quick stupid question
17:35:39 <latros> if I have a [[String]], how do I make a String that prints each list on a line?
17:35:51 <JoeyA> unlines
17:35:54 <latros> I thought unlines . map show would do it but that doesn't seem to even typecheck
17:36:03 <latros> no, [[String]]
17:36:22 <JoeyA> What how is each [String] supposed to be printed?
17:36:35 <JoeyA> If you have [["a","b"],["c","d"]], what should it print?
17:36:38 <latros> the same way as show (or something sufficiently analogous that I can do that
17:36:39 <latros> )
17:36:55 <latros> the first line should be ["a","b"]
17:36:57 <JoeyA> okay
17:37:03 <latros> (actually ideally it would be [a,b], but I can work with this)
17:37:16 <JoeyA> :t unlines . map (map show)
17:37:17 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
17:37:17 <lambdabot>     In the first argument of `map', namely `show'
17:37:17 <lambdabot>     In the first argument of `map', namely `(map show)'
17:37:30 <latros> :t unlines . map show
17:37:31 <lambdabot> forall a. (Show a) => [a] -> String
17:37:34 <latros> wait what
17:37:37 <JoeyA> err, map show
17:37:41 <latros> I was sure it wasn't working before
17:37:50 <latros> in fact that it wasn't even typechecking
17:38:09 <JoeyA> An easier way (assuming you're in the IO monad): mapM_ print
17:38:10 <quintessence> > unlines . map show $ [["a", "b"], ["c", "d"]]
17:38:12 <lambdabot>   "[\"a\",\"b\"]\n[\"c\",\"d\"]\n"
17:38:16 <JoeyA> e.g. mapM_ print [["a","b"],["c","d"]]
17:38:40 <latros> the IO monad is at least around
17:38:59 <latros> like, this is being written to a file
17:39:05 <latros> etc.
17:39:10 <JoeyA> mapM_ (hPrint h) ;-)
17:39:22 <latros> gah, I haven't learned handles yet
17:39:32 <latros> I was just using readFile/writeFile
17:40:33 <JoeyA> E.g.: withFile "filename.txt" WriteMode $ \h -> mapM_ (hPrint h) xs
17:40:42 <JoeyA> You'll need to import System.IO for that.
17:40:51 <latros> mmk
17:40:59 <latros> why is some of the IO library not in base?
17:41:12 <latros> er
17:41:13 <latros> Prelude
17:41:13 <JoeyA> base?  You mean prelude?
17:41:32 <JoeyA> There's a lot of stuff I wished was in Prelude and didn't have to keep importing.
17:41:41 <MostAwesomeDude> Hey, if I want to do async stuff, how reliably non-blocking are the various GUI toolkits when coupled with things like sockets?
17:41:53 <MostAwesomeDude> (Especially when Win32 is involved?)
17:42:15 <shachaf> "the various GUI toolkits" is a bit vague.
17:42:27 <MostAwesomeDude> Let's say GTK+, Qt, and Wx.
17:42:38 <MostAwesomeDude> Also Tk if there are working Haskell bindings, but I didn't think there were.
17:42:39 <shachaf> In general the FFI handles blocking calls for you in a reasonable way.
17:42:47 <latros> withFile "freqsorted_groups.txt" WriteMode $ \h -> mapM_ (hPrint h) $ (map (take 5) $ lines freqRaw) (jbovprep jbovlasteRaw)
17:42:52 <latros> that's pretty snazzy
17:42:57 <latros> thanks JoeyA
17:42:59 <JoeyA> MostAwesomeDude: GHC doesn't have full IO manager support for Windows.  Socket send and recv are done through safe FFI calls on Windows.
17:43:24 <MostAwesomeDude> JoeyA: Hm. That's unfortunate but not surprising; Windows is pretty bonghits.
17:43:40 <JoeyA> MostAwesomeDude: This may be fine for most cases, but not if there's the possibility of a recv operation hanging indefinitely
17:43:53 <shachaf> I was under the vague impression that Windows does asynchronous I/O in a more reasonable way than Linux.
17:44:07 <JoeyA> Oh contraire
17:44:11 <MostAwesomeDude> shachaf: GTK+ is not as reasonable under Win32 as it is under Linux.
17:44:17 <MostAwesomeDude> Which is my main concern.
17:44:17 <shachaf> Oh, well, GTK+, sure.
17:44:19 <JoeyA> MostAwesomeDude: http://hackage.haskell.org/packages/archive/network-socket-options/0.2/doc/html/Network-Socket-Options.html#g:6
17:44:21 <shachaf> I thought you were talking about sockets.
17:44:29 <JoeyA> For now, you can work around the problem with socket timeouts.
17:44:53 <hasknoo> hi
17:44:57 <MostAwesomeDude> GUI + sockets. I'm considering some of the Twisted-based stuff I've built in Python, and how I'd do the same things in Haskell. Twisted has special support for various GUI toolkits to keep things non-blocking.
17:45:10 <hasknoo> I am kinda new
17:45:53 <JoeyA> MostAwesomeDude: I'm referring to sockets alone, not just GUI + sockets.
17:45:55 <hasknoo> I been playing with it for a few months
17:46:05 <MostAwesomeDude> JoeyA: Okay. Thanks.
17:46:28 <JoeyA> In a program compiled with -threaded, the following should hold: difficulty (GUI + sockets) == difficulty GUI + difficulty sockets
17:46:48 <hasknoo> Hopefully I can help some noobs
17:46:49 <hasknoo> :)
17:46:49 <MostAwesomeDude> Yeah, that'd be a nice property.
17:46:59 <JoeyA> That is you can do socket stuff in a separate thread.
17:47:10 <JoeyA> If a socket operation hangs or whatever, the GUI thread will be fine.
17:47:13 <MostAwesomeDude> A separate GHC thread, or a POSIX thread?
17:47:28 <JoeyA> If a socket operation hangs, it will pin down an OS thread.
17:47:39 <JoeyA> (on Windows)
17:47:40 <JoeyA> That applies to any FFI operation.
17:48:10 <JoeyA> But unless that happens 1000 times, it shouldn't be a problem.
17:48:10 <MostAwesomeDude> Ugh. Annoying. GHC can magically handle that though, right?
17:48:19 <MostAwesomeDude> Ah, 'k.
17:48:30 <JoeyA> If you're writing an end-user program, you'll probably not have too much of a problem.
17:48:52 <JoeyA> But do note that FFI operations block exceptions.
17:49:02 <MostAwesomeDude> It's both really cool that Haskell doesn't need a Twisted-like core for multiplexing, and annoying that Haskell's own multiplexing isn't quite as robust as Twisted's.
17:49:13 <JoeyA> If you killThread a thread busy with an FFI call, you'll have two threads blocked.
17:49:16 <MostAwesomeDude> 'k. Seems like I should look more at the FFI stuff.
17:49:24 <JoeyA> Fortunately, you can easily kill the thread calling killThread.
17:49:37 <c_wraith> it also depends on whether the FFI call is marked safe or unsafe.
17:49:41 <MostAwesomeDude> *bwong*
17:49:54 <MostAwesomeDude> Is FFI safety about the purity of the call?
17:49:57 <c_wraith> no
17:50:09 <c_wraith> it's about whether it needs to protect the runtime state
17:50:30 <c_wraith> safe FFI calls have more overhead, because they take a bunch of steps to ensure the runtime state is consistent.
17:51:06 <c_wraith> unsafe ones skip that, meaning they are much more dangerous, in a bunch of different cases.
17:51:37 <JoeyA> One example of such a case is an FFI call that blocks for a long time.
17:51:45 <JoeyA> e.g. connect() on a blocking socket.
17:52:14 <c_wraith> really, any FFI call that can block at all shouldn't be made unsafe.  But a bunch of FFI interfaces were written by people who don't know that.
17:52:52 <JoeyA> Fortunately, Network.Socket.connect is a safe FFI call (*cough* http://trac.haskell.org/network/ticket/44 *cough*)
17:53:05 <shachaf> c_wraith: I think the issue here is more than just an unsafe foreign import.
17:53:14 <JoeyA> Sorry, I have this weird head cold where my coughs sound like hyperlinks to Trac tickets.
17:53:44 <shachaf> Oh, maybe not.
17:54:01 <tazjin> @src head
17:54:02 <lambdabot> head (x:_) = x
17:54:02 <lambdabot> head []    = undefined
18:00:43 <koala_bot> Is there a good way to make this more condensed: http://hpaste.org/64846 ?
18:00:47 <JoeyA> MostAwesomeDude: I'd say that GHC can handle FFI and sockets "well enough", even on Windows.  Just bear in mind that an FFI call cannot be interrupted by an asynchronous exception.  The exception won't be delivered until the FFI call completes.
18:01:13 <MostAwesomeDude> JoeyA: Okay. I guess that's good enough. Maybe someday GHC will do WFMO or IOCP?
18:01:36 <JoeyA> What do those stand for?
18:02:21 <MostAwesomeDude> Wait For Multiple Objects; I/O Completion Ports.
18:02:34 <MostAwesomeDude> You learn...things...when hacking Twisted. Win32 things.
18:02:37 <c_wraith> it already does the latter.
18:02:45 <c_wraith> That's what the threaded runtime is built on
18:03:01 <MostAwesomeDude> Oh? But it just has some (b)locking issues, then?
18:03:11 <c_wraith> only with *asynchronous* exceptions
18:03:19 <c_wraith> which are part of the ghc runtime system
18:03:22 <c_wraith> not part of system IO
18:03:39 <JoeyA> On Windows, it still does I/O using FFI calls.
18:05:03 <MostAwesomeDude> Huh. Okay.
18:05:20 <c_wraith> asynchronous exceptions are exceptions delivered *from other GHC threads*. They are implemented as part of the GHC runtime. During an FFI call, the GHC runtime is not involved, so it can't deliver an asynchronous exception
18:06:58 <JoeyA> koala_bot: You can get rid of the first pattern (getMinEven [] = Nothing), as it is implied by the second pattern.
18:07:31 <koala_bot> JoeyA: Thanks. I didn't realize that wasn't an updated sample but I have taken that line out :)
18:07:33 <JoeyA> Also, you're computing filter even ns twice.
18:07:43 <koala_bot> I realize I am but I'm not sure how to cut it down to once.
18:08:07 <c_wraith> use a where clause
18:08:13 <JoeyA> You could say let ns' = filter even ns in if null ns' then Nothing else Just $ minimum ns'
18:08:20 <c_wraith> the names in a where clause are in scope in guards
18:08:34 <koala_bot> rostayob :) DIdn't see you
18:08:47 <JoeyA> I'm wondering if pattern guards would help here.
18:09:08 <koala_bot> c_wraith: I hadn't though about a where clause. Thank you
18:10:01 <koala_bot> JoeyA pattern guards?
18:10:16 <niteria> :t trace
18:10:17 <lambdabot> Not in scope: `trace'
18:10:34 <JoeyA> e.g. foo | Just x <- m, x == 3 = "three"
18:10:54 <latros> (that example is terrible, but pattern guards are amazing)
18:11:13 <latros> (that example being terrible because it's trivial to move the guard to the other side)
18:11:20 <xil> hi everyone. Does writefile override the contents of a file? I'm not sure what the distinction is between writefile and appendfile if not that
18:11:27 <latros> yes
18:11:36 <latros> having used writefile a jillion times in the last couple days yes it does
18:11:44 <xil> great, that's what I need =]
18:11:51 <latros> (this might be mode dependent, though)
18:11:55 <latros> (I'm a bit of a newb at IO)
18:12:33 <JoeyA> latros: When a pattern guard is matched, is it possible to have multiple patterns branch out after that?
18:12:38 <koala_bot> JoeyA: Thank you. would a subsequent guard be able to refer to x in that ase?
18:12:40 <koala_bot> case*
18:12:57 <latros> probably joeyA
18:13:03 <latros> it's been a while since I checked the semantics
18:13:10 <latros> (or used them at all)
18:13:17 <latros> my most recent program is freaking haskell98, lol
18:13:34 <latros> no monads other than the IO, too
18:13:44 <latros> or additional types, or ...
18:13:52 <latros> very dull program really
18:15:52 <latros> wait, koala_bot, a subsequent *guard*?
18:16:09 <koala_bot> latros: My terminology is terrible :\ bear with me?
18:16:10 <latros> a subsequent guard shouldn't ever actually do anything if the whole pattern matches
18:16:23 <latros> unless you mean that m matches Just x but x isn't equal to 3
18:16:28 <koala_bot> yes
18:16:29 <shachaf> Is there any reason other than performance that GHC's IO manager is written in C rather than Haskell?
18:16:29 <koala_bot> exactly that
18:16:41 <latros> I am not sure about that one, koala_bot
18:16:50 <latros> try it
18:16:54 <monochrom> there may also be bootstrapping. implement IO by... IO?
18:17:01 <koala_bot> I'm trying now but it's telling me that my x is not recognized/defined
18:17:08 <latros> you need {-# LANGUAGE PatternGuards #-} though
18:17:12 <latros> I think that's the syntax
18:17:18 <latros> um
18:17:23 <latros> what?
18:17:27 <latros> paste your code
18:17:32 <latros> (on hpaste)
18:17:54 <c_wraith> shachaf: is it? I got the impression the IO manager was mostly haskell code, except for the parts that interface with native APIs
18:18:43 <hpaste> koala_bot pasted “HW7P2” at http://hpaste.org/64848
18:19:05 <shachaf> c_wraith: Hmm, maybe I misunderstood.
18:19:16 <latros> uh
18:19:22 <latros> filter can't return a maybe
18:19:28 <latros> so that won't work
18:19:35 <monochrom> Just e <- (filter even ns) is not going to work. wrong type.
18:19:48 <monochrom> [] <- filter even ns
18:19:56 <latros> yeah, that
18:20:11 <monochrom> the whole logic of the whole thing is flawed
18:20:44 <hpaste> koala_bot pasted “HW7P2” at http://hpaste.org/64849
18:21:03 <koala_bot> This works fine, but I want to get down to calling filter only once. I'm unsure of how to do that
18:21:11 <latros> that should actually do that
18:21:13 <latros> in practice
18:21:20 <latros> due to how thunks work
18:21:24 <monochrom> sure, use a "where"
18:21:27 <latros> otherwise you can use a let or a where
18:21:34 <dgpratt> I have two functions, f :: String -> IO [String], g :: String -> IO ()
18:21:47 <monochrom> "let" won't span the two lines. "where" will.
18:21:47 <dgpratt> and I am composing them thusly: do { xs <- f x; mapM_ g xs; }
18:22:23 <dgpratt> which is fine, but I can't help but feel that there's a shorter version of that
18:22:29 <shachaf> mapM_ g <$> f x
18:22:45 <c_wraith> f >=> mapM_ g
18:22:54 <dgpratt> shachaf: ah
18:23:02 <shachaf> @. pl undo do { xs <- f x; mapM_ g xs; }
18:23:02 <dgpratt> c_wraith: also, ah
18:23:02 <lambdabot> mapM_ g =<< f x
18:23:05 <hpaste> monochrom annotated “HW7P2” with “HW7P2 (annotation)” at http://hpaste.org/64849#a64850
18:23:09 <monochrom> there
18:23:09 * hackagebot Javav 0.0.4 - A utility to print the target version of Java class files.  http://hackage.haskell.org/package/Javav-0.0.4 (TonyMorris)
18:23:10 <shachaf> c_wraith: That's if x is an argument, anyway. :-)
18:23:24 <c_wraith> shachaf: that's true.
18:23:37 <dgpratt> cool, thanks guys
18:25:11 <koala_bot> phew. Finally got my head out of my ass and put two and two together :) Thanks for your patience, folks. Bummed I had to add a line but I suppose that is an okay price for one fewer function calls
18:25:42 <monochrom> oh you can merge those 3 lines into 1.
18:25:56 <latros> you shouldn't, though
18:26:04 <monochrom> f ns | null e = Nothing | otherwise = Just (minimum e) where e = filter even ns
18:26:32 <koala_bot> That would probably make my prof very angry lol
18:26:38 <latros> as it should
18:27:05 <monochrom> that anger would be just religious zealotry
18:27:33 <monochrom> it is totally not like I go "f 0 = blah; f 1 = stuff"
18:28:00 <shachaf> f ns = case filter even ns of [] -> Nothing; e -> Just (minimum e)
18:28:34 <monochrom> i.e., until I bring in ";", it is still not an abuse of merging lines
18:28:41 <shachaf> f (filter even -> []) = Nothing; f (filter even -> e) = Just (minimum e) -- will only be computed once, I think.
18:28:55 <latros> what the
18:28:58 <latros> what is that
18:29:09 <latros> that must be some weird extension yes?
18:29:18 <shachaf> No, it's not that weird as extensions go.
18:29:22 <JoeyA> > reverse "PatternGuards"
18:29:22 <lambdabot>   "sdrauGnrettaP"
18:29:23 <latros> well
18:29:24 <latros> not weird
18:29:26 <latros> but
18:29:29 <monochrom> it is in Haskell 2010
18:29:32 <latros> huh
18:29:39 <JoeyA> Is (filter even -> []) a pattern guard?
18:29:43 <shachaf> No.
18:29:44 <aavogt> not the -XiewPatterns
18:29:51 <c_wraith> XiewPatterns?
18:29:53 <monochrom> err sorry, not in Haskell 2010
18:30:14 <JoeyA> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
18:30:34 <monochrom> I'm pretty sure your prof will be more angry at using filter and minimum rather than writing your own recursion
18:31:14 <luxurymode> sheesh, the font in my terminal is killing my eyes! currently using monaco. anyone have recommendations?
18:31:15 <koala_bot> Recursion is not the purpose of this assignment.
18:31:31 <shachaf> @ty let foo f z xs = case xs of [] -> z; _ -> f xs in foo
18:31:32 <lambdabot> forall t t1. ([t] -> t1) -> t1 -> [t] -> t1
18:31:46 <niteria> omg, how is [], [(k, v]), as non-exhaustive
18:32:19 <shachaf> It's a syntax error, for one.
18:32:31 <ronankde> Haskell how to connect with Python
18:32:51 <koala_bot> mismatched brackets look cool though
18:32:52 <monochrom> connect with C
18:33:24 <niteria> :D
18:35:57 <Axman6> >[(##]) <- nuclear bomb?
18:36:54 <niteria> http://hpaste.org/64851 I have no idea why this is wrong
18:38:24 <niteria> it's so simple
18:39:21 <latros> I think you have a fencepost problem
18:39:24 <latros> with the length
18:39:44 <latros> check what splitAt (length as `div` 2) as
18:39:44 <latros> is
18:39:46 <shachaf> niteria: You misspelled fromOrdKVList
18:39:48 <shachaf> In the last case.
18:39:56 <latros> oh
18:39:57 <latros> lol
18:39:59 <latros> nvm
18:40:09 <shachaf> latros: That problem may or may not exist but it wouldn't cause that error.
18:40:23 <niteria> OMG
18:40:26 <latros> well, I was thinking it might cause the let to fail to match
18:40:40 <latros> though that doesn't actually make any sense
18:40:44 <latros> now that I think about it
18:40:55 <ronankde> connects with C then with Python
18:41:02 <ronankde> http://wiki.python.org/moin/PythonVsHaskell
18:41:19 <niteria> thanks
18:42:40 <niteria> I should configure vim to highlight the word I have cursor at like eclipse does
18:46:05 <niteria> that's more annoying than I thought
18:54:04 <hpaste> deech pasted “Using A Shared C Library” at http://hpaste.org/64852
18:54:09 <deech> Hi all, I'm playing around with Haskell's FFI and am having trouble using a shared library. I have the code up on hpaste and was hoping someone could help me debug it.
18:55:10 <monochrom> firstly you probably need extern "C" { void hello_world(); }
18:56:53 <deech> monochrom: That was it! Thanks! Is there anything else there that's way off? I'm not a C programmer.
18:57:17 <monochrom> the rest is fine
18:57:26 <deech> monochrom: Thanks again!
18:57:36 <mauke> 'extern "C"' is not C
18:57:39 <mauke> (it's C++)
18:57:53 <mauke> also, don't compile C++ code with gcc
18:57:58 <monochrom> but you should be aware that GHC ignores HelloWorld.h even though you specify it in your "foreign import" command
18:57:59 <shachaf> That's not a shared C library.
18:58:14 <shachaf> Well, maybe it behaves like one if you use extern "C".
18:59:10 <deech> shachaf: AFAIK, the code is straight C. Even with the extern the gcc command in the paste compiles it to a .so file and I'm able to run it.
18:59:31 <deech> monochrom: Why does it ignore the header file?
18:59:33 <shachaf> deech: If it's straight C why does the filename end in .cc?
18:59:36 <mauke> it's in a file called .cc
18:59:42 <mauke> it can't be "straight C"
18:59:55 <deech> shachaf: A mistake on my part. Does the extension matter?
18:59:58 <monochrom> the GHC user guide has an explanation why GHC ignores C header files
19:00:00 <mauke> well, unless you compile with gcc -xc but then gcc ignores the name completely
19:00:08 <int-e> deech: yes it does
19:00:22 <shachaf> deech: Yes. It'll be treated as C++ this way.
19:00:39 <shachaf> Which is just going to be a huge mess.
19:00:45 <monochrom> C++ functions enjoy name mangling. it is why hello_world was not found
19:01:09 <monochrom> there are also calling convention issues and other implementation-defined issues
19:02:06 <monochrom> but I was trusting that in the future you really want C++ with a C interface (extern "C") for the sake of Haskell FFI
19:02:24 <shachaf> TRUST NO ONE
19:03:08 <int-e> shachaf: that's borderline paradoxical
19:03:44 <deech> Ah, I changed everything to a .c extension, removed the extern "C" and it worked.
19:04:06 <shachaf> deech: Much better.
19:05:09 <int-e> mauke: when you warned about compiling C++ with gcc, did you have ABI issues in mind or worse miscompilations?
19:05:13 <monochrom> consider extern "C" to be C++'s FFI :)
19:05:34 <mauke> int-e: linker errors, usually
19:05:57 <mauke> g++ links the C++ runtime libraries by default, gcc does not
19:06:06 <int-e> ah. the libstdc++ one.
19:06:22 <monochrom> gcc (compared to g++) misses out a lot of header files and yeah libs, i.e., fewer include directories and lib directories searched
19:06:46 <monochrom> #include <iostream> and try gcc
19:07:35 <deech> oops
19:07:43 <monochrom> but supposedly still ok for an OS kernel in C++! :)
19:07:49 <int-e> meh I totally misunderstood. yes, use g++ for compiling C++ code, but that's part of gcc to me (as in "GNU compiler collection")
19:08:05 <monochrom> oh, for that, say GCC :)
19:08:48 <gienah> then you would probably need to use the --verbose build option to debug the errors the Haskell code gets when it tries to link to the C++ library that does not have C++ shared library in the NEEDED library list
19:08:55 <dbelange> off topic
19:09:09 <monochrom> although I keep saying "ghc" all the time, which is also ambiguous: GHC-API's package name is also "ghc"
19:09:50 <niteria> @hoogle (a -> Bool) -> [a] -> ([a], [a])
19:09:50 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
19:09:51 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
19:09:51 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
19:09:54 <int-e> monochrom: Do you know that there are microkernels written in (a subset of) C++? :) (The limitation is that they don't use rtti (dynamic casts) nor exceptions, as far as I'm aware.
19:10:05 <monochrom> I think there is none :)
19:11:32 <int-e> monochrom: http://os.inf.tu-dresden.de/fiasco/build.html
19:12:00 <int-e> monochrom: (suggestive link, but yes it's used in the kernel proper)
19:12:29 <monochrom> interesting
19:30:39 <yshavit_> Is it possible to explicitly declare a function's type in a "where" clause, using a parameter defined in the outer function?
19:31:16 <monochrom> no, unless you turn on an extension, ScopedTypeVariables, and there is one more thing to do
19:31:19 <tgeeky> yshavit_: I think: yes to the first part, no to the second
19:31:50 <yshavit_> tgeeky: yeah, I was able to explicitly type, just not wit the parameter
19:31:53 <yshavit_> monochrom: thanks
19:32:08 <yshavit_> I'll just pull the "where" function out to a top-level function, then.
19:45:14 <tazjin> I'm teaching Haskell to a friend and we somehow ended up talking about why there's no safe version of head in the Prelude (e.g. [a] -> Maybe a); Is it because nobody would use it? Or would it violate some law in regards to functional programming?
19:45:59 <shachaf> @ty listToMaybe
19:45:59 <lambdabot> forall a. [a] -> Maybe a
19:46:15 <shachaf> tazjin: It's just for convenience. "head" is an evilish function.
19:47:21 <tgeeky> tazjin: careful, as well - 'safe' now (and in the future) has specific meaning
19:47:24 <monochrom> a better question IMO is why there is no safe fromJust
19:47:32 <shachaf> tazjin: Most code should never have "head" in it. Something like if null l then ... else ... (head l) (tail l) is an antipattern.
19:47:50 <shachaf> monochrom: unsafeCoerce works if you constrain its type.
19:48:00 <shachaf> unsafeCoerce :: a -> a.
19:48:06 <shachaf> Someone ought to give that function a name.
19:48:08 <monochrom> no, I mean this: safeFromJust :: Maybe a -> Maybe a
19:48:18 <shachaf> Yes, that's what I meant too.
19:48:50 <tazjin> Yeah, I've never actually used head, I was just wondering about it :P
19:49:03 <shachaf> @ty let safeFromJust :: Maybe a -> Maybe a; safeFromJust = unsafeCoerce -- safe
19:49:04 <lambdabot> <no location info>:
19:49:04 <lambdabot>     not an expression: `let safeFromJust :: Maybe a -> Maybe a; safeFromJust = unsafeCoerce'
19:49:08 <shachaf> @ty let safeFromJust :: Maybe a -> Maybe a; safeFromJust = unsafeCoerce in safeFromJust -- safe
19:49:09 <lambdabot> forall a. Maybe a -> Maybe a
19:49:14 <monochrom> head is useful and safe in map head . group blah
19:49:23 <monochrom> err, map head (group blah)
19:49:41 <shachaf> And tail is useful and safe in zip xs (tail xs)
19:49:52 <shachaf> But you have to prove that yourself rather than relying on the compiler to prove it.
19:49:56 <shachaf> Is that really safety?
19:50:10 <monochrom> safe version of head is subsumed by pattern-matching
19:50:17 <tgeeky> shachaf: that depends on how big your Coq is.
19:51:02 <monochrom> what is safety?
19:51:27 <tgeeky> I'm surprised to see how small this list is: http://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-5000
19:51:36 <tgeeky> (the extensions) list
19:52:41 <gentleben> shachaf: i go back and forth on that. I have basically settled on all code not in a utility program (e.g. for business code and not one off stuff) may not use unsafe code like fromJust, head, etc...
19:52:41 <shergill> tgeeky: it's not the size of ones coq, but more how one puts it to use
19:53:28 <tgeeky> shergill: true. Personally, I don't even have a handle on my Coq. I wouldn't know what to do with it.
19:54:06 <shergill> heh
19:54:46 <shachaf> Well done, tgeeky. You've brought #haskell to an exciting new level of discourse.
19:55:30 <tgeeky> shachaf: Exciting, but unforunately less hard. #haskell is a place to challenge onself, and be challenged.
19:55:40 <tgeeky> and the second part is not in <ennuendo>
19:57:10 <shergill> shachaf: there's still a ways to go before we're able to match #emacs. i'm not sure whether that is a good thing or bad
19:57:31 <shergill> tazjin: you may also look into http://hackage.haskell.org/package/safe
19:58:51 <hpaste> scooty-puff-sr pasted “Which one looks better?” at http://hpaste.org/64859
19:59:13 <tgeeky> I was just messing around, but the code snippets in http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html#7.3.4 Pattern guards look exactly like what we're talking about
19:59:22 <hpaste> scooty-puff-sr annotated “Which one looks better?” with “Which one looks better? (annotation)” at http://hpaste.org/64859#a64860
20:05:14 <tazjin> shergill: thanks for that :]
20:05:29 <shergill> tazjin: np
20:16:59 <hpaste> ghorn pasted “llvm-base link error in ghci” at http://hpaste.org/64861
20:17:30 <ghorn> i'm getting that on osx and linux
20:17:44 <ghorn> does llvm not work in ghci?
20:18:14 <ghorn> and why is it trying to find a library with no name?
20:19:55 <ivanm> do you have the llvm-base library installed?
20:24:48 <ghorn> yes
20:25:25 <ghorn> i've tried reinstalling both lllvm and llvm-base with llvm2.8/2.9 linux, 2.9/3.0 osx
20:30:48 <ivanm> ghc-pkg list llvm
20:30:49 <ivanm> ghc-pkg list llvm-base
20:31:19 <ghorn> $ ghc-pkg list llvm
20:31:19 <ghorn> /usr/local/lib/ghc-7.4.1/package.conf.d
20:31:19 <ghorn> /home/greg/.ghc/x86_64-linux-7.4.1/package.conf.d
20:31:19 <ghorn>    llvm-3.0.0.0
20:31:19 <ghorn> $ ghc-pkg list llvm-base
20:31:19 <ghorn> /usr/local/lib/ghc-7.4.1/package.conf.d
20:31:20 <ghorn> /home/greg/.ghc/x86_64-linux-7.4.1/package.conf.d
20:31:20 <ghorn>    llvm-base-3.0.0.0
20:31:37 <ivanm> in ghci, does ":module +LLVM.FFI.Analysis" work ?
20:32:36 <ghorn> it is loading fine
20:33:50 <ghorn> Prelude> :module +LLVM.FFI.Analysis
20:33:50 <ghorn> Prelude LLVM.FFI.Analysis>
20:34:19 <ivanm> where do you have the LLVM C libraries installed to?
20:35:59 <ghorn> /usr/lib/llvm-2.8/lib
20:36:06 <ghorn> and llvm-config knows this
20:36:29 <ghorn> llvm-config is being found correctly during llvm-base installation
20:36:58 <ivanm> does "ghc-pkg check" complain?
20:37:02 <ivanm> and which distro?
20:37:37 <ghorn> ubuntu x86_64
20:37:47 <ghorn> ghc-pkg check does not complain
20:38:30 <ghorn> i think i have a later Cabal than normal
20:40:23 <ghorn> yes i installed Cabal 1.14.0 in the process of getting libraries working under ghc 7.4.1
20:40:43 <ivanm> yeah, that's not a problem
20:41:04 <ivanm> your error is a little weird then... maybe try rebuilding llvm and llvm-base?
20:41:47 <ghorn> I did that around 10 times trying different configurations last night
20:44:21 <ghorn> it seems like "-L/blahblah -l" is being called somewhere in order for ghci to try and link "lib.so"
20:45:58 <ghorn> i was trying to trace this and the cabal build was over my head, there are extra-ghci-libraries which are set up with build hooks, and I feel like there is special magic to get libstdc++ and -pgml g++ to work in libraries that don't have -pgml g++
20:47:43 <td123> if you run out of options, another place to look for answers might be the source for the package at http://packages.debian.org/sid/ghc
20:48:14 <td123> it looks like it supports llvm 3 with ghc 7.4
20:52:23 <ghorn> what LLVM is the standard linux x86_64 ghc 7.4.1 distribution built against?
20:52:46 <ghorn> you think incompatible versions could cause problems?
20:52:53 <ivanm> don't think it is
20:52:58 <ivanm> but I'm quite possibly wrong :p
21:04:40 <Axman6> ghorn: 2.9 works i believe
21:05:18 * gienah has the same error with llvm 2.9 ghc 7.4.1 on gentoo
21:07:06 <td123> maybe you need llvm 3?
21:07:56 <ghorn> i'll try that
21:09:02 <ghorn> i probably should have emphesized this btw: this is a ghci only problem
21:09:17 <ghorn> i can build and run examples with ghc --make just fine
21:09:51 * gienah since I have dev-haskell/llvm-base-3.0.0.0 it seems to make sense that I should have llvm 3.0
21:36:17 <rekahsoft> hi all..just installed ghc 7.4.1 (i'm on parabola (libre archlinux)) anyways been getting a error when i "import IO"..ghc says "could not find Module 'IO' it is a member of hidden package haskell98..."
21:37:24 <rekahsoft> now in ghci 'import IO' works no issue..also the same thing with the Monad module..really anything from the haskell98 module..
21:37:38 <rekahsoft> it the haskell98 module depreciated?
21:37:44 <adu> rekahsoft: no
21:38:00 <adu> but iirc, they're implemented elsewhere
21:38:29 <rekahsoft> then whats up i wonder..any ideas?
21:39:54 <adu> rekahsoft: try replacing them with System.IO and Control.Monad
21:41:14 <Jafet> rekahsoft: -package haskell98
21:42:20 <rekahsoft> adu: alright that worked..now why did it happen?
21:42:49 <rekahsoft> Jafet: i tried that earlier and it said the Prelude module was ambigious
21:43:04 <rekahsoft> i figured i had to hide the base module in that case
21:43:15 <Jafet> I suppose you also had to not use haskell2010.
21:43:30 <Jafet> The new namespace is enshrined in the haskell2010 standard.
21:43:37 <rekahsoft> i went looking but then wondered why haskell98 was hidden by defaul after i installed ghc 7.4.1
21:43:56 <Jafet> haskell98 has not been used exclusively for many years.
21:46:11 <shachaf> mzero: Wait, BayHac is "full"?
21:48:02 <gentleben> i just got that too, seems odd
21:53:15 * hackagebot base64-bytestring 0.1.1.1 - Fast base64 encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base64-bytestring-0.1.1.1 (BryanOSullivan)
21:53:15 <ivanm> OK, I think I give in: polyparse can't seem to match attoparsec's speed whilst it still uses lazy bytestrings by default
21:54:03 <ivanm> bos: am I correct in assuming that getting the individual chunks from a lazy bytestring in attoparsec does indeed have a lot to do with it's performance?
21:54:57 <bos> ivanm: uh, maybe?
21:54:57 <lambdabot> bos: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:55:01 <ivanm> heh
21:55:37 <ivanm> because I've been tweaking polyparse's bytestring parser, trying to take what I can from attoparsec, but there's still about a 2.5 factor in difference for code that's almost identical :s
22:07:06 <mzero> shachaf & gentleben -- yes, sadly, BayHac is currently full
22:08:01 <shachaf> mzero: What does that mean?
22:08:26 <mzero> It means we can have 35 people max at the venue - and we have 35 people signed up
22:08:51 <shachaf> What would happen if I just showed up?
22:09:09 <shachaf> Would they get mad at you and say you can't have any more BayHacs there?
22:09:10 <mzero> If there were 35 people there (and I'm required to count) I would have to turn you away
22:09:15 <shachaf> Oh.
22:09:45 <mzero> right now, the Hacker Dojo is under a strict capacity limit from the City of Mtn. View
22:10:06 <mzero> (mind you, any venue is actually under some capacity limit from the local municipality)
22:11:43 <mzero> so - I could start looking for an alternative place to hold it - but it isn't clear to me that we'll actually get more than 35 to show
22:11:55 <mzero> and then it would be a lot of work, and some disruption of plans, for no value
22:12:01 <shachaf> Well, I just signed up for the waitinglist thing.
22:12:05 <shachaf> So now you have at least 36.
22:12:38 <mzero> mind you - if like 20 people sign up on the wait list - then it is a different story - but there is still no certainty I can find another appropriate spot
22:13:23 <mzero> shachaf: you weren't already on that list?  :-(    (though how did you find out it was full?)
22:13:35 <shachaf> mzero: By going to the sign-up page.
22:13:47 <mzero> oh - bad timing - we hit 35 like two hours ago
22:13:53 <shachaf> I didn't realize there was a sign-up page until now.
22:14:04 <mzero> (oh dear)
22:14:23 <shachaf> What about the place where they just had the SHDH thing? That had more than 35 people.
22:14:25 <gentleben> mzero: corporate sponsor maybe?
22:14:52 <mzero> or perhaps Stanford
22:15:04 <gentleben> let me know how it goes
22:15:11 <mzero> the key would be that we'd really like a space that is walking distance from CalTrain
22:15:16 <gentleben> yeah
22:15:17 <mzero> since that is how we got a number of SF folks last time
22:15:19 <gentleben> i hear that
22:15:27 <gentleben> since i am one of them
22:15:45 <shachaf> Stanford has a Caltrain shuttle, I think.
22:15:45 <mzero> we're cool for Friday - it is Saturday and Sunday we'd need a spot for
22:15:59 <mzero> and it *is* walkable, though far
22:16:09 <mzero> not sure about weekends for Stanford
22:17:12 <shachaf> Palantir has excellent Caltrain positioning. :-)
22:17:18 <mzero> true dat
22:17:28 <Enigmagic> shachaf: yes, the stanford shuttle is free and goes to the caltrain station
22:17:35 <Enigmagic> the margurite line or something like that
22:17:49 <shachaf> Yes, I seem to see those shuttles everywhere*.
22:19:32 <Enigmagic> i've never actually taken it but they sit at the caltrain station
22:19:49 <gentleben> yeah, they are always there
22:19:57 <gentleben> or were when i rode the train
22:21:50 <adnauseam> hrm. can someone help me understand this definition on :: (b -> b -> c) -> (a -> b) -> a -> a -> c    ?
22:22:33 <adnauseam> two functions that take two parameters and produce a result of the second function's type ?
22:23:05 <adnauseam> wait, i think i understand now
22:23:10 <adnauseam> just had to say it outloud =P
22:23:16 <gentleben> hehe
22:23:20 <gentleben> that helps
22:23:45 <adnauseam> heh aye - especially if you've been looking atcode for the past hour going ''wat is THIS!!'
22:24:10 <gentleben> yeah
22:24:12 <mzero> nice thing about Haskell: given just that type, I can write the function for you - as it is the *only possible* definition
22:24:12 <gentleben> i know
22:24:14 <Enigmagic> mzero: your email went straight to my gmail junk folder btw
22:24:31 <mzero> :t \f g x y -> f (g x) (g y)
22:24:32 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
22:24:44 <adnauseam> true that's it :o
22:25:03 <mzero> Enigmagic: is there any way I could have stopped that? Do I just write like a spammer?  :-)
22:25:29 <adnauseam> how does haskell differentiate between a function and a variable ?
22:25:34 <adnauseam> are f and g reserved letters ?
22:25:46 <mauke> adnauseam: f and g are variables
22:25:49 <shachaf> adnauseam: "function" and "variable" are two different classes of things.
22:25:51 <mauke> adnauseam: their values may be functions
22:25:55 <Enigmagic> mzero: complain to the gmail folks :)
22:26:05 <adnauseam> oh
22:26:09 <shachaf> A function is a specific kind of value (one that has type (something -> somethingelse)).
22:27:00 <gentleben> Enigmagic: google hates you
22:27:13 <shachaf> Or maybe Google hates mzero.
22:27:25 <Enigmagic> gentleben: did yours get junked?
22:27:56 <adnauseam> so given something like \f x = x, if i give (==) 5 to f it'd be treated as a functoin acting on x, where as if i give it something like (4) 5 it'll just have t wo numbers standing next eachother and do nothing with them ?
22:28:28 <mzero> well, adnauseam: in   \f x = x    f is unused
22:28:35 <mzero> so really, Haskell doesn't care what it is at all
22:28:37 <mauke> adnauseam: \f x = x is a syntax error
22:28:53 <mauke> do you mean 'f x = x' or '\f x -> x'?
22:28:57 <gentleben> Enigmagic: no
22:28:59 <mzero> > (\f x = x) (==) 5
22:29:00 <lambdabot>   <no location info>: parse error on input `='
22:29:09 <mzero> > (\f x -> x) (==) 5
22:29:10 <lambdabot>   5
22:29:16 <mzero> okay - so -> is what he meant
22:29:18 <mzero> I think
22:29:20 <Enigmagic> gentleben: hmmm
22:29:24 <Enigmagic> stupid spam filters
22:29:31 <gentleben> Enigmagic: see google hates you, or maybe just larry
22:29:34 <mauke> mzero: that fits "give (==) 5" but not "to f"
22:29:36 <Enigmagic> i guess so
22:29:54 <adnauseam> hrm, i'm trying to understand how haskell sees a function - i know that a fucntion is also defined as such. when i define something, do i simply make the promise of suppling functions for f\g and paramters of a\b\x etc ?
22:30:05 <mauke> adnauseam: what?
22:30:07 <mzero> okay - let's start from the top, adnauseam
22:30:31 <adnauseam> heh, sorry, i'll just do more reading - i think my questions are bit too confusing since im confused myself at the moment.
22:30:43 <adnauseam> at least i got what on's definition means now
22:30:44 <yitz> > (\f x -> x) (error "Help! Heeellp!!") 5
22:30:45 <lambdabot>   5
22:30:55 <adnauseam> :o
22:30:57 <mzero> let's look at       (\f -> f 8)
22:31:05 <mauke> adnauseam: numbers are values. strings are values. functions are values.
22:31:14 <mauke> adnauseam: you can give those values names, using variables
22:31:20 <mzero> from that - Haskell can tell, that is a lambda that takes one argument, called f, and in the body, f is applied to 8
22:31:35 <mzero> ... so.... Haskell infers....   f must be a function that takes numbers
22:31:58 <adnauseam> :o i see
22:32:05 <mauke> > (\x -> x 8) sqrt
22:32:06 <lambdabot>   2.8284271247461903
22:32:06 <mzero> it doesn't matter if we write it      (\q -> q 8)    or (\a -> a 8)
22:32:09 <mzero> all the same thing
22:32:24 <adnauseam> hah
22:32:32 <mzero> now... if we write      (\x -> 3 * x + 7)
22:32:34 <adnauseam> > (x -> x 8) 5
22:32:34 <lambdabot>   Pattern syntax in expression context: x -> x 8
22:32:42 <adnauseam> bnecuase 5 8 does nothing :o
22:32:49 <adnauseam> > (x -> x 8) + 5
22:32:50 <lambdabot>   Pattern syntax in expression context: x -> x 8
22:33:08 <mauke> adnauseam: you can't just put -> in the middle of an expression
22:33:15 <mauke> you need \ or case..of somewhere
22:33:25 <mzero> haskell says ....  a this is a lambda that takes one argument, called x, and well, x must be something that we multiply by 3 and then add 7 to... so .... haskell reasons.... x must be a number
22:33:30 <adnauseam> oh yeah, to tell haskell that's an anonymous function
22:33:32 <adnauseam> forgot that
22:33:47 <adnauseam> > (\x -> x 8) (5+)
22:33:48 <lambdabot>   13
22:33:50 <mzero> again....   (\f -> 3 * f + 7)   or   (\q -> 3 * q + 7)   are all the same thing
22:33:52 <adnauseam> :O
22:34:01 <shachaf> > let f (id -> x) = x in f 5
22:34:02 <lambdabot>   5
22:34:06 <mauke> heh
22:34:07 <shachaf> Sorry, ignore that previous line.
22:34:19 <shachaf> I was just being unuseful.
22:34:19 <taiyal> is Haskell decently equipped for general-purpose scripting or is it strictly mathematical?
22:34:35 <gentleben> taiyal: you can build real software with it
22:34:41 <taiyal> ah, okay
22:34:47 <pikhq_> You can even build Real Software™ with it.
22:34:50 <mzero> and it isn't even specialized for mathematics at all
22:34:52 <gentleben> i would not replace python scripting with it
22:34:57 <mzero> I would
22:34:59 <mzero> :-)
22:35:03 <gentleben> hehe
22:35:06 <raichoo> So would I :D
22:35:06 <mauke> taiyal: such as a compiler, version control system, text editor, window manager, or irc bot :-)
22:35:07 <gentleben> i would not
22:35:10 <adnauseam> haskell is as fast as C and can pretty much do anything with it. build desktops, websites, ircBots
22:35:13 <adnauseam> etc
22:35:21 <mbernstein> I'd replace anything with ducktyping with haskell any day.
22:35:27 <pikhq_> adnauseam: Not necessarily "as fast as C".
22:35:28 <Enigmagic> it can be as fast as C, it's not generally as fast as C
22:35:29 <companion_cube> as fast as C? hmmmm
22:35:29 <gentleben> you mean haskell can be as fast as c
22:35:36 <gentleben> hehe
22:35:40 <pikhq_> But certainly, fast enough in the general case.
22:35:45 <shachaf> @quote monochrom einstein
22:35:46 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
22:35:53 <Enigmagic> ruby is fast enough for many cases too
22:36:02 <adnauseam> pikh - from what i've read it's faster than C++, and it's catching up to C, where in it's slower at some tasks, and faster at others
22:36:02 <gentleben> most cases are not perf bound
22:36:13 <pikhq_> (but then, even obscenely inefficient languages are fast enough in the general case, so that's not saying much)
22:36:26 <gentleben> its often harder to reason about complex code
22:36:34 <gentleben> for perf, due to laziness
22:36:58 <pikhq_> Still, you're most likely IO bound.
22:37:00 <Enigmagic> adnauseam: C and C++ for many applications are identical in perf.
22:37:13 <adnauseam> true
22:37:26 <Enigmagic> i'm not sure how haskell could be faster than one but not the other
22:37:27 <adnauseam> i wonder how functional C would be like
22:37:56 <adnauseam> from what i've read - any functional version of a language is faster than the non functional one
22:38:08 <pikhq_> Enigmagic: C and *PHP* are identical in performance in many applications.
22:38:16 <adnauseam> it seems to have  to do with state flow
22:38:36 <pikhq_> adnauseam: https://github.com/pikhq/clambda-demo I doubt this is faster than non-functional C. :)
22:38:39 <Enigmagic> adnauseam: where have you read that?
22:38:53 <adnauseam> let me find it again
22:39:20 <mbernstein> pikhq_: What do you define performance as?  Memory usage?  CPU time?  I guarantee well written C has a much better performance profile than php.
22:39:47 <Enigmagic> pikhq_: saying C++ is faster or slower than C is kinda silly since they almost universally are the same compiler
22:39:58 <adnauseam> https://www.readwriteweb.com/hack/2012/01/infographic-php-vs-python-vs-r.php
22:40:05 <adnauseam> it says nothing about haskell btw
22:40:08 <adnauseam> just makes you think
22:40:27 <gentleben> uhhh, all those are slow
22:40:36 <mbernstein> They're all *really* slow.
22:41:15 <adnauseam> i'm not comparing them to haskell - i am inferring though - that writing code functionally is generally faster due to the flow of states
22:41:16 <pikhq_> mbernstein: Perceived performance.
22:41:29 <gentleben> thats like saying that your volt should be compared to my 911 turbo
22:41:31 <pikhq_> mbernstein: Y'know, the subjective but actually valuable metric. ;)
22:41:39 <adnauseam> you can see a 3-4 second difference between nonfunctional and functional code
22:41:55 <gentleben> adnauseam: what does that even mean? either its slower or not
22:41:59 <adnauseam> so writing functional php should be more efficient than writing php the good old fashioned way
22:42:21 <adnauseam> gentleben: hmm ?
22:42:32 <adnauseam> what does what mean ? the fact functional code is faster ?
22:42:34 <Enigmagic> just because it may have more information available for optimization doesn't imply the compiler makes use of this information at all
22:42:58 <gentleben> when writing php you should optimize for php
22:43:02 <Enigmagic> C compilers do a pretty good job of making faster applications than GHC
22:43:17 <gentleben> especially intel
22:43:33 <shachaf> Enigmagic: When compiling to x86 machine code, anyway. :-)
22:43:56 <shachaf> If you were compiling to Lazy K, I imagine that Haskell compilers might generate faster code than C compilers.
22:44:11 <Enigmagic> shachaf: fair enough
22:44:13 <adnauseam> i wonder how GHC will be tweaked in the future - the language is still maturing
22:44:21 <mauke> oh god, that reminds me of the haskell compiler that targets brainfuck
22:44:39 <mauke> (subset of haskell but still)
22:44:41 <shachaf> mauke: "haskell"
22:44:46 <pikhq_> And I thought I was impressed by a halfway-finished GCC backend for Brainfuck.
22:45:01 <mauke> enjoy your brainfuck GC
22:45:12 <gentleben> adnauseam: ghc can be made faster
22:45:18 <shachaf> mauke: GC is not a required part of implementing Haskell...
22:45:27 <gentleben> just a question of man hours for optimization
22:46:19 <pikhq_> And it's not like GC would be impossible in Brainfuck, you'd just go slightly mad writing it by hand.
22:46:32 <pikhq_> (writing it with, say, a macro language, would be quite feasible)
22:48:11 <gentleben> you should get right on that
22:48:19 <pikhq_> I'd rather not.
22:48:35 <pikhq_> I've done enough insane tricks with Brainfuck already. :P
22:52:52 <latros> is there something syntactically subtle about constructing values with functions in fields?
22:53:01 <latros> for example, why does this not work
22:53:08 <latros> distant_protons = QS {temperature = 77
22:53:08 <latros>                         , energy i = 5e-22+2.5e-22*i
22:53:08 <latros>                         , degeneracy i = i
22:53:08 <latros>                         , tol = 1e-8
22:53:08 <latros>                         , indices = [1..]}
22:53:26 <shachaf> Yes, you have to use a lambda.
22:53:34 <latros> damn, k
22:53:44 <shachaf> Or you can define the function separately and use that name, I guess.
22:55:32 <Cale> Yeah, I wish you could do that too.
22:56:05 <mzero> latros: you'll want things like    energy (\i -> 5e-22+2.5e-22*i)
22:56:08 <mzero> er
22:56:15 <mzero> energy = (\i -> 5e-22+2.5e-22*i)
23:11:06 <Tahani> Hello
23:12:53 <gentleben> hello
23:13:32 <Tahani> what's ur level
23:13:38 <gentleben> 37
23:14:10 <monad> 42
23:14:34 <gentleben> plus he is a monad
23:14:39 <monad> =O
23:14:45 <gentleben> ;-)
23:14:52 <Krezack> Gentlemen!
23:18:48 <gentleben> Sir!
23:22:37 <mzero> well *that* was random
23:23:10 <monad> Totally.
23:38:18 * hackagebot clientsession 0.7.4.2 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.7.4.2 (MichaelSnoyman)
23:45:53 <dp_wiz> How to convert from ByteString.Lazy.ByteString to Data.Text.Text?
23:46:20 * dp_wiz tries to dump aeson's output into html page with blaze...
23:46:43 <ChristianS> dp_wiz: aeson can also output Text, as far as i know?
23:47:38 <dp_wiz> I see only this in docs: encode :: ToJSON a => a -> ByteString
23:48:09 <dp_wiz> ToHtml can deal with Text, but not with BS
23:50:26 <ChristianS> dp_wiz: decodeUtf8 Data.Text.Encoding or Data.Text.Lazy.Encoding decodes a bytestring to Text. then all you have to do is fix the laziness.
23:52:30 <elmpn> hello world
23:52:37 <dp_wiz> instance H.ToHtml BSL.ByteString where toHtml lazybs = toHtml . decodeUtf8 $ lazybs -- this works!
23:52:43 <dp_wiz> ChristianS: thanks!
23:54:17 <Enigmagic> dp_wiz: or perhaps (toHtml . toLazyText . fromValue . toJSON)
23:54:38 <Enigmagic> which would skip the text->utf8->text conversion
