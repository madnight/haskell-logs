00:00:04 <JamesJRH> The old shell still says could not find module, but new shells import it sucessfully.
00:02:33 <wagle> JamesJRH: how are you loading it?
00:02:44 <JamesJRH> import Data.Number.CReal
00:03:00 <wagle> huh..  doesnt work for me
00:03:03 <JamesJRH> Works in the new shell not the existing.
00:03:11 <wagle> right
00:03:31 <JamesJRH> Existing being open before the install.
00:04:11 <JamesJRH> Annoying, there's got to be a way of reloading the existing.
00:04:19 <wagle> HAha!  </nelson>
00:05:16 <wagle> "cabal install Numbers" doesnt work, but "cabal install numbers" does
00:05:29 <JamesJRH> /nelson? Lol.
00:05:45 <JamesJRH> Yes.
00:06:08 <JamesJRH> I didn't try 'Numbers'
00:06:55 <JamesJRH> Why the mismatch between numbers and Number?
00:07:49 <wagle> dunno
00:08:46 <zzo38> There is a lot of program in Haskell but no ephemeris program? I want to do it, ephemeris program, geometry, physics, date/time, and draw diagram.
00:11:40 <JamesJRH> :r doesn't reload the 'cache' of what modules are installed.
00:13:21 * wagle stops biting tongue
00:13:27 <wagle> owww
00:13:47 <wagle> i'm heading for bed, g'night
00:14:19 <JamesJRH> wagle: Did you install it?
00:14:27 * hackagebot HaskellForMaths 0.4.4 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.4.4 (DavidAmos)
00:14:27 <wagle> yeah, it works
00:14:54 <JamesJRH> wagle: But only in a new shell, right?
00:15:15 <wagle> new ghci..  didnt have one open
00:16:06 <JamesJRH> wagle: Yeah. I'm trying to work out how to reload my existing GHCi shell.
00:17:19 <JamesJRH> wagle: Good night.
00:20:31 <wagle> :reload could possibly work?
00:57:33 <mikeplus64> is this http://www.mgsloan.com/wordpress/?p=148 tongue in cheek?
01:02:04 <Cale> mikeplus64: I don't think it's entirely a joke. :)
01:02:30 <Cale> mikeplus64: Whether it's wise is an open question, but it's interesting to look at :)
01:03:13 <mikeplus64> is this one of those times where you just suspend disbelief? lol
01:03:23 <Cale> mikeplus64: In case you're unaware of it, the term 'pointless' or 'points-free' comes from topology
01:03:55 <mikeplus64> it seems to me like a nice example of why KISS prevails and over-engineering
01:04:08 <Cale> (a style in which you talk about spaces and maps without saying exactly what happens to the points in them)
01:05:20 <mikeplus64> yeah, something that should be used with utmost caution, because it's a very nice way to obfuscate your code
01:05:46 <Cale> well, obviously you don't use it in cases where it makes things worse
01:05:54 <Cale> lambda exists for a reason
01:07:32 <cafesofie> pointfree style doesn't strike me as overengineering
01:07:45 <mikeplus64> I mean, stuff like reconnect = disconnect >=> connect, or putStrLn . show . (+43) or something are all good, but (pow $> (1/)) $&> sum $>> map $> pow scares me to death
01:08:26 <cafesofie> that is pretty scary though :P
01:08:29 <mikeplus64> not pointfree, that blog post's compositional operators
01:09:16 <Cale> the fact that it's significantly longer than  pnorm p = pow (1 / p) . sum . map (pow p)
01:09:20 <Cale> kinda kills it
01:10:02 <Cale> If it were more concise, it would be more enticing to try to get used to :)
01:10:20 <Cale> I'm sure it's possible to get used to working with those combinators though
01:10:30 <Cale> They're very systematically defined
01:11:09 <mikeplus64> if I saw that in "real" haskell code I'd start looking at a lisp-like language with parenthesis everywhere
01:11:54 <ChristianS> what's all these strange operators, and where are they defined? $> $&> $>> $>
01:12:22 <mikeplus64> I think, if someone wanting to learn haskell saw it, they'd quiver in fear
01:12:53 <ChristianS> (not that i want to use them [i think], i already complained about "don't use too many obscure operators" some days ago.)
01:13:07 <mikeplus64> http://www.mgsloan.com/wordpress/?p=148
01:13:12 <blackdog> mikeplus64: all in the grand tradition of avoiding success at all costs
01:13:33 <ChristianS> mikeplus64: thanks
01:13:59 <mikeplus64> blackdog: right
01:17:16 <blackdog> Veinor: would i be right in thinking that askitter doesn't support posting images?
01:17:36 <Veinor> possibly! i haven't touched askitter in ages, it's one of the things i've been meaning to
01:18:34 <blackdog> Veinor: they've got some funky "update_with_media" endpoint
01:18:35 <blackdog> https://dev.twitter.com/docs/api/1/post/statuses/update_with_media
01:19:07 <Veinor> ah
01:19:41 <blackdog> blergh. i'd have a hack myself, but i think my brain has completed the transition to mush
01:19:58 <blackdog> so close to getting this whole demo working... :/
01:34:39 <eyu> ping
01:34:43 <eyu> > 1 + 2
01:34:44 <lambdabot>   3
01:37:23 <Franciman> hey gents, why can't I instance a typeclass with lists ?
01:37:33 <Franciman> for example : instance MyTC [Int]
01:37:53 <Saizan> the error message says it all
01:38:25 <Franciman> but why isn't [Int] a type variable?
01:38:34 <Saizan> Int is not a type variable
01:38:51 <Saizan> because it's a concrete type
01:39:11 <Franciman> ahh
01:39:42 <Franciman> so to match constructors I must use type variables?
01:39:48 <Saizan> ([Int] is not a type variable either but that's not relevant)
01:40:11 <Saizan> what do you mean by constructors here?
01:40:26 <Franciman> [] and ()
01:40:43 <Saizan> anyhow, an instance like "instance MyTC [a]" would have worked
01:40:47 <Franciman> yeah those aren't exactly constructors
01:40:53 <Franciman> but why?
01:40:58 <Franciman> I don't understand
01:41:23 <Saizan> it's just an arbitrary restriction that was put there to be conservative
01:41:41 <Saizan> (well, not so arbitrary, it makes instance selection simpler)
01:41:53 <Saizan> you can lift it with the FlexibleInstances extension
01:42:19 <Franciman> oh ok, thanks for the explaination
01:59:27 <cetinsert> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Licenses is unclear (not 100% clear) about whether all hackage licenses should be OSI-/FSF-approved licenses or whether shared source only licenses with no permissions to modify / reuse code are also welcome.
02:18:18 <ChristianS> i don't see a restriction to FOSS licenses there, though they are clearly preferred.
02:20:37 <geekosaur> my understanding is that while non-FOSS will be considered, in practice there is a very strong bias toward FOSS, and specifically toward BSD-like licenses
02:27:51 <kodoque> hi, I'm interested in the gsoc concurrent data structure project, but I have not an ACM account to read the paper by nir shavit given by rrnewton
02:28:19 <kodoque> Is there any other good summary?
02:39:34 <jfischoff> is it possible to encode the lens laws into Djinn?
02:49:02 <int-e> kodoque: you might find the whole march 2011 issue of the cacm on scribd. (I don't know, of course. Just a hunch. ;-) )
02:49:58 <kodoque> thanks :)
02:57:37 <Taneb> I still haven't worked out if my fancy complicated factorial program is any more efficient than product . enumFromTo 1
02:57:56 <Taneb> It seems to be quicker, but...
03:02:57 <ksf_> @hoogle (a -> IO b) -> Maybe a -> Maybe b
03:02:58 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:02:58 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
03:02:58 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
03:03:35 <ksf_> @hoogle (a -> IO b) -> Maybe a -> IO( Maybe b)
03:03:36 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:03:36 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
03:03:36 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
03:03:38 <c_wraith> ksf_: that type signature seems...  bad.
03:03:44 <c_wraith> oh, that one's better :)
03:04:16 <ksf_> traverse, seriously?
03:04:29 <c_wraith> or mapM
03:04:44 <ksf_> yep mapM looks better.
03:14:41 * hackagebot hakyll 3.2.6.2 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.6.2 (JasperVanDerJeugt)
03:55:05 <Taneb> Infinite lists are functors, but I don't think they are applicatives or monads
03:55:19 <Taneb> Unless you cheat
03:55:22 <Taneb> brb
03:56:19 <c_wraith> infinite lists are both
03:56:25 <ksf_> hmm can't that Functor/Applicative/Monad pain be solved now that we have default class method signatures?
03:56:41 <Jafet> Depends on how much salsa you add.
03:56:44 <ksf_> lists even give raise to two applicative functors.
03:56:44 <c_wraith> no, because the dependencies that people want go the wrong way
03:56:58 <c_wraith> people want to define fmap = liftM
03:57:05 <ksf_> yes.
03:57:05 <c_wraith> as the default implementation
03:57:25 <ksf_> default fmap :: Monad m => ...
03:57:49 <mikeplus64> wouldn't it be more appropriate to call it uh mmap then?
03:58:04 <ksf_> it *ought* to be called just map.
03:58:05 <Taneb> Back
03:58:08 <mikeplus64> because fmap is generalised to functors, mmap is generalised to monads?
03:58:30 <geekosaur> every monad is a functor, is the point
03:58:38 <geekosaur> so every monad can use fmap already
03:59:15 <elemir> In theory monad is a functor, yes. But not in haskell
03:59:22 <geekosaur> (except it can't because for historical reasons, while every Monad is necessarily a Functor, not every Monad is automatically a Functor in Haskell)
03:59:35 <mikeplus64> yeah, I don't think I've ever used fmap in a special functor-only situation (are there any?)
04:00:08 <ksf_> maybe?
04:00:15 <c_wraith> sure.
04:00:20 <c_wraith> (,) a
04:00:20 <geekosaur> there are, but the most common situations are things that are also monads (whether they need to be or not)
04:00:21 <ksf_> either?
04:00:27 <ksf_> though either is a bifunctor.
04:00:37 <Jafet> @instances Monad
04:00:38 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
04:00:39 <ksf_> functions too, of course.
04:00:47 <geekosaur> (rephrase:  whether you care that they are or not)
04:01:00 <mikeplus64> ok
04:01:00 <c_wraith> ((,) a) is a functor, but neither applicative nor a monad.  In both cases, because it can't implement pure/return
04:01:01 <ksf_> in disciple, there's no fmap either, just map.
04:01:37 <ksf_> (with the wonderfully concise type map     :: forall a b !e1 $c1 !e2 $c2                .  (a -(!e1 $c1)> b) -> f a -(!e2 $c2)> f b                :- !e2 :> !ReadT (f a) + !e1                ,  $c2 :> ${f : $c1}  )
04:01:59 <ksf_> (which is only unreadable due to ascii)
04:01:59 <osa1> do we have a wiki page or something which has list of haskell gsoc ideas, mentors, etc.?
04:02:05 <geekosaur> ksf_, as Cale is fond of reminding us, fmap shouldn;t even be map, it should be (.)
04:02:13 <ksf_> :t map
04:02:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:03:35 <Taneb> Wow, I really sparked a conversation
04:03:44 <elemir> > Disciple is a dialect of Haskell that uses strict evaluation as the default
04:03:45 <lambdabot>   <no location info>: parse error on input `of'
04:03:59 <ksf_> that's only a taste thing, though.
04:04:02 <elemir> Strict evalution is painful =(
04:04:17 <ksf_> it could equally well be lazy by default, the type system doesn't care.
04:04:30 <mikeplus64> elemir: eh, there are times when yelling at the type signatures in haskell are the only appropriate thing to do
04:04:43 <ksf_> ...just put @ (the opposite of "seq") everywhere and you're done.
04:04:46 * hackagebot xml-catalog 0.5.0.2 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-0.5.0.2 (MichaelSnoyman)
04:04:58 <mikeplus64> (as in !a ;))
04:05:04 <ksf_> the actual difference between disciple and haskell is that the former doesn't need monads to do IO
04:05:19 <ksf_> ! means an effect.
04:05:23 <ksf_> $c is closure.
04:05:27 <ksf_> % is region.
04:05:38 <ksf_> if you ignore everything inside the arrows the type becomes trivial.
04:06:08 <ksf_>  (a -(!e1 $c1)> b) -> f a -(!e2 $c2)> f b    -->>  (a -> b) -> f a -> f b
04:07:13 <ksf_> ...where the effect !e2 may read what's in some f a in addition to doing what !e1 does.
04:07:35 <elemir> ksf_: Why they use function arrow for second arguments?
04:07:40 <ksf_> ...and the closure types tell you about how things scope and nest.
04:07:57 <elemir> Why not three arrows?
04:08:06 <ksf_> :t fmap
04:08:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:08:11 <ksf_> it's the same as in haskell.
04:09:05 <nand`> ksf_: looks like perl
04:09:12 <nand`> the syntax
04:09:19 <nand`> (just as unnecessarily complicated)
04:09:20 <ksf_> effect, closure and region types are inside the arrows because those things occur only when something is applied.
04:09:31 <elemir> Concrete types are unneeded at all
04:09:41 <ksf_> err effect and closure types only, region types are arguments to normal types.
04:10:07 <ksf_> nand`, in general you don't need to mention the advanced stuff, it can be inferred.
04:10:27 <ksf_> on the plus side, you won't ever see IO ()
04:10:48 <geekosaur> ...but you may wish you had by the time you finish digesting the type signature
04:11:00 <nand`> I think IO () is very straightforward
04:11:23 <osa1> do we have a wiki page or something which has list of haskell gsoc ideas, mentors, etc.?
04:11:42 <nand`> Haskell made it into the GSOC?
04:11:46 <geekosaur> yes
04:11:48 <nand`> nice
04:11:57 <elemir> There is only one problem with IO — real world doesn't write at haskell
04:12:00 <nand`> That's two of my favorite projects already :)
04:12:01 <ksf_> ...the equivalent disciple type is () -(!File)> ()
04:12:40 <ksf_> ...or some other effect type.
04:12:53 <elemir> So we must use one ugly monad expect of little domain-specific nice monad
04:13:01 <geekosaur> osa1, the discussionhas been mostly on the haskell-cafe list, I am under the impression that there is a wiki page but it's a little out of date
04:13:33 <ksf_> elemir, yep, IO's specialness makes it hard to split up easily.
04:13:40 <osa1> geekosaur: so do I have to ask in haskell-cafe to know gsoc projects and mentors?
04:13:42 <ksf_> you could do it, but then composition becomes awkward.
04:15:04 <elemir> Problem may be solved with pure OS, IMHO
04:15:27 <geekosaur> hm, feature gmail needs, if it knows theres  amailing list it should be able to give me a public url for a mailing list message.  especially if said list is mirrored in a google group already...
04:15:39 <ksf_> whats the state of art regarding the expression problem/evolutivity, btw?
04:15:56 <ksf_> are there any solutions yet that don't need multiple views on the source?
04:16:10 <geekosaur> http://groups.google.com/group/haskell-cafe/msg/6d75f1c5b0320589 re GSoC
04:17:01 * geekosaur thought the real problem with splitting up IO was that it'd be a world-shattering bikeshed...
04:17:50 <ksf_> yep. a gazillion of incompatible restrictions of IO.
04:18:20 <ksf_> though nowadays it might be feasible, mtl seems to have settled down.
04:20:46 <elemir> Is there whole optimimizer extension for ghc?
04:22:24 <geekosaur> whole-program optimization?  not that I know of
04:22:47 <c_wraith> ghc keeps getting closer, though, with the addition of more and more pragmas allowing cross-module optimization
04:22:51 <ksf_> there's some projects to that effect
04:23:30 <ksf_> like http://community.haskell.org/~ndm/supero/
04:23:33 * elemir heard about jhc
04:23:51 <elemir> Are they useful?
04:23:57 <ksf_> I don't think there's a single project do do mere whole-program optimisation
04:24:03 <ksf_> elemir, research prototypes.
04:24:15 <c_wraith> there's a branch of ghc that is using supero as a prototype
04:24:21 <geekosaur> it's been vaguely discussed but I think it only became possible recenty with compiler plugins and I've seen no mention of anyone actually working on it since
04:24:22 <ksf_> that is, if you treat them well they might compile something small for you.
04:24:24 <c_wraith> But it's moving slowly
04:24:27 <geekosaur> ah
04:25:23 <ksf_> http://hackage.haskell.org/trac/ghc/wiki/Supercompilation
04:25:23 <elemir> It's sad =(
04:37:23 <hpaste> hacker annotated “Cabal frustration” with “Cabal frustration (annotation)” at http://hpaste.org/47863#a65497
04:37:54 <cafesofie> is Yi still alive?
04:43:24 <ksf_> according to github that's the latest patch: https://github.com/coreyoconnor/yi/commit/1762ceb8137b985c519154cc7e8b4a89e47d8f84
04:44:19 <ksf_> there seem to be people using it, but not necessarily hacking on it.
04:44:27 <ksf_> ...beyond keeping it from bitrotting.
04:45:05 * elemir wan't to hack it, but Yi at my netbook is something like Maple at calculator
04:45:33 <ksf_> it surely is more lean than emacs...
04:45:39 <ksf_> (if compiled)
04:45:59 <cafesofie> i had an urge to use it out of anger at elisp's dynamic typing :(
04:46:04 <elemir> 1. I'm happy ed^wvim user
04:46:16 <elemir> 2. Emacs is faster than Yi
04:46:25 <ksf_> I had the same urge, but then was put back by the poor vi support
04:46:50 <ksf_> and proper vi support is a huge task. starts with implementing the full posix ex.
04:47:24 <ksf_> which never looked like that big a task, but then I looked at the spec.
04:47:30 <elemir> POSIX ex isn't really powerful
04:47:34 <ksf_> 90% of the time is wasted on trying to make sense of it.
04:48:02 <ksf_> its *very* powerful.
04:48:15 <ksf_> ...for a line-based editor running on a dumb terminal.
04:48:33 <elemir> Heh
04:48:45 <ksf_> practically all whole-file vi features depend on it.
04:48:48 <elemir> Btw, vim ex is more powerful
04:49:28 <ksf_> of course, but vim's ex without posix ex isn't.
04:49:33 <yitz> i'm thinking of writing teco bindings for yi. not at the top of my todo list though...
04:50:36 * elemir thinking of making yi more AST
04:50:57 <ksf_> the spec reads like an accountant interpreted the source of some implementation of ex.
04:51:27 <yitz> elemir: on a modern machine, i haven't noticed any delay in any operation i ever do in day to day editing in either emacs or vim. haven't tried yi - is it *that* slow?
04:51:34 <geekosaur> that;s about par for POSIX
04:52:02 <ksf_> I could live with that, but there's portions which clearly make no sense at all. they're just wrong.
04:52:15 <ksf_> that is, they contradict something else in the spec.
04:52:22 <elemir> yitz: It's slower than firefox. So it is.
04:52:36 <ksf_> which tells you about the value of a "posix certified" rubber stamp.
04:52:38 <yitz> elemir: haven't used firefox lately either
04:52:59 <ksf_> I think there are a couple of leaks left in yi.
04:53:01 <geekosaur> I have not looked at the POSIX ex spec, but I suspect they tried to reconcile the original BSD and later AT&T versions and failed
04:53:10 <ksf_> if you restart regularly it shouldn't be slow...
04:54:13 <ksf_> I have one very good reason to have implementing ex on my todo list, though: the configuration variable "posix_me_harder"
04:54:17 <yitz> geekosaur: maybe they did the default merge using cvs, then filtered out the confict marks using ex
04:54:32 <ksf_> ...that enables all the behaviour that's insane or gives raise to contradictions.
04:54:32 <elemir> yitz: IMHO editor should be faster than big ugly browser.
04:54:51 <yitz> elemir: sounds like a reasonable requirement :)
04:54:53 <geekosaur> yitz: that would probabky be saner.  one word:  committee
05:21:13 <damowe> hi :)
05:21:24 <damowe> how can I remove deprecated packages in cabal installs?
05:23:37 <kraghen> last i checked the only way is to use 'ghc-pkg unregister pkgname' and then manually remove the relevant files
05:24:37 <elemir> cave uninstall -x dev-haskell/pkgname :3
05:25:50 <damowe> thanks
05:27:59 <elemir> Hem. Let's I have newtype "MyNewType a" and typeclass "MyTypeClass a". How can I automate instance "MyTypeClass a => MyTypeClass (MyNewType a)"?
05:31:13 <geekosaur> you can't per se, but with some ghc option you may be able to add `deriving MyTypeClass' to the definition?  that said, the usual ting about typeclasses applies (i.e. are you sure they're what you really want?)
05:33:09 <elemir> I want something like polymorphic deriving
05:34:06 <elemir> With typeclass predicate
05:37:05 <ksf_> yes, you can!
05:37:10 <ksf_> use generic deriving.
05:37:18 <ksf_> -XDeriveGeneric
05:37:27 <ksf_> then use ... deriving (Generic)
05:38:45 <elemir> ksf_: http://www.haskell.org/haskellwiki/Generics ?
05:43:56 <dreixel> elemir: yes
05:43:56 <lambdabot> dreixel: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:57:09 <TedTedTedTed> Hi everyone
05:58:47 <TedTedTedTed> I'd like to apply for the Google Summer of Code and work for Haskell, but I don't know where to send my application
05:59:39 <TedTedTedTed> More specifically, I'd like to talk with Don Stewart, he's mentoring a project which seems interesting to me
06:00:04 <TedTedTedTed> Would someone have his e-mail adress, or a more generic one ?
06:02:17 <Eduard_Munteanu> @seen dons
06:02:17 <lambdabot> Unknown command, try @list
06:02:26 <Eduard_Munteanu> preflex: seen dons
06:02:26 <preflex>  dons was last seen on #haskell 62 days, 18 hours, 48 minutes and 26 seconds ago, saying: btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
06:03:43 <elemir> preflex: seen portnov
06:03:43 <preflex>  portnov was last seen on #xmonad 18 hours, 16 minutes and 58 seconds ago, saying: elemir: for Wayland?
06:03:59 <elemir> preflex: Stupid bot
06:04:41 <Eduard_Munteanu> TedTedTedTed: this one maybe? http://donsbot.wordpress.com/about/
06:05:09 <TedTedTedTed> Eduard_Munteanu: Yes, thank you very much
06:14:51 <Eduard_Munteanu> TedTedTedTed: I think you might want to ask around if any possible mentors are interested in what you're aiming.
06:15:10 <TedTedTedTed> Eduard_Munteanu: Yeah, you're probably right
06:15:38 <Eduard_Munteanu> dons doesn't seem listed in the http://hackage.haskell.org/trac/summer-of-code/wiki/People2012 page.
06:15:59 <TedTedTedTed> I think I can do a really good job on this project : http://hackage.haskell.org/trac/summer-of-code/wiki/People2012
06:16:17 <Eduard_Munteanu> Wrong link? I just pasted that :).
06:16:41 <TedTedTedTed> arg, i meant http://hackage.haskell.org/trac/summer-of-code/ticket/1555
06:17:31 * Eduard_Munteanu wonders if hackage.haskell.org is being flooded by GSoC people
06:17:32 <TedTedTedTed> I'm a 5-year-user of OCamL and I think I have a deep understanding of this language, which is in my country (France) what people use "instead of" Haskell
06:18:17 <Franciman> so it is in Italy
06:18:37 <Franciman> I do not understand why in a lot of universities they teach OCaml instead of Haskell
06:18:50 <Eduard_Munteanu> Heh, French people seem to like ML-ish stuff. /me thinks of inria, Coq, ... :)
06:18:58 <DaveNull> TedTedTedTed, i'm french and i prefer Haskell to OCaml...
06:19:22 <TedTedTedTed> And so, I think implementing a way to call Haskell from OCamL would be really useful for the spreading of Haskell
06:19:55 <DaveNull> But, that's true that french university are using caml for their PF classes
06:20:02 <TedTedTedTed> DaveNull: So am I, I think, but I've much more experience with OCamL
06:20:54 <TedTedTedTed> It would be much easier for me to implement a way to call Haskell in OCamL than a way to call OCamL in Haskell
06:24:32 <td123> i was taught with ocaml in my language design class, I think they use it because ocaml has some imperative programming concepts which make it easier for student to use what they already know
06:25:26 <DaveNull> that's exactly for this reason i've chosen Haskell ;)
06:25:32 <DaveNull> Rebelz:
06:26:17 <td123> DaveNull: heh, I know but I guess they justified using ocaml since it might take a smaller leap in thinking to use it
06:26:58 <Axman6> thats not a good thing
06:27:48 <td123> well I'm just guessing
06:28:34 <Axman6> it's why we use haskell for the course i tutor, everyonr starts out at the same level
06:28:38 <DaveNull> there's another reason, ihmo... There's no french book on Haskell...
06:29:08 <td123> ah, I was taught at an english university
06:29:09 <Eduard_Munteanu> Axman6: so you don't get smartasses there? :P
06:29:30 <DaveNull> and learning "hard concepts" in a tongue which is not its natural one is even more difficult
06:29:49 <Franciman> DaveNull and also OCaml originated in France
06:29:54 <DaveNull> yes
06:30:54 <Jafet> I suspect that may be the primary reason.
06:31:03 <Franciman> me too
06:31:11 <DaveNull> agree too
06:31:34 <Franciman> in italy it's just a : "follow our cousins" thing
06:31:42 <Jafet> INRIA seems to have a lot of pull in their country.
06:39:04 <BlankVerse> `code' is not defined;
06:39:07 <BlankVerse> perhaps you forgot to include "lhs2TeX.fmt"?
06:45:49 <Taneb> Is there anything with a similar type signature to atomicModifyIORef, but for STRefs?
06:46:55 <ksf_> > Just "foo" <> Just "bar"
06:46:56 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
06:46:56 <lambdabot>         agains...
06:47:00 <Taneb> :t \r f -> fmap f (readSTRef r) >>= \(a,b) -> writeSTRef r a >> return b
06:47:01 <lambdabot> forall a s t. STRef s a -> (a -> (a, t)) -> ST s t
06:47:04 <ksf_> > Just "foo" `mappend` Just "bar"
06:47:05 <lambdabot>   Just "foobar"
06:47:11 <ksf_> > Just "foo" `mplus` Just "bar"
06:47:12 <lambdabot>   Just "foo"
06:48:30 <ksf_> hoogle monadplus
06:48:33 <ksf_> @hoogle monadplus
06:48:34 <lambdabot> Control.Monad class Monad m => MonadPlus m
06:52:18 <kosmikus> BlankVerse: was that a question?
06:57:44 <db81> I'm a bit confuzed by Blaze. In their tutorial they use do-notation ( http://jaspervdj.be/blaze/tutorial.html ) and you can write things like p "foo" >> p "bar", but p is Html -> Html, I see no monads around.
06:58:19 <ion> Html is probably a type alias.
06:58:53 <BlankVerse> lhs2Tex is not very happy with haddock comments , what alternative do u suggest?
06:59:05 <db81> ion: this is the case, thanks
07:02:16 <sipa> Does it matter that it is a type alias?
07:02:55 <ion> sipa: Not seeing a type parameter seemed like the source of his confusion.
07:03:26 <db81> exactly
07:03:32 <sipa> oh yes, of course
07:08:32 <ksf_> strictly speaking, compiling some source via -c (with direct path), without that path being covered by an include directory, without the module name being mentioned in the file breaks building with -outdir
07:08:52 <ksf_> ...because the compiler simply can't infer what to call the .o etc.
07:09:49 <ksf_> -outpath directory/Module/Path would work, the compiler could then attach .o etc as needed.
07:12:55 <BlankVerse> how to do literate programming in latex style without discarding haddock comments ?
07:13:10 <BlankVerse> handdock comments seems to confuse lhs2Tex
07:13:38 <BlankVerse> matching `|' not found
07:23:54 <kosmikus> BlankVerse: lhs2TeX doesn't understand haddock, so I don't know of a good solution there
07:24:29 <BlankVerse> kosmikus: so we would have to remove haddock comments to use lhs2Tex
07:27:02 <kosmikus> BlankVerse: well, you should be able to hide them from lhs2TeX by using %if False / %endif if that's all you want
07:28:18 <ChristianS> BlankVerse: i would think that literate programming and haddock are usually alternatives. you use one or the other, but hardly both.
07:30:37 <kosmikus> ChristianS: it'd certainly nice to have a good LaTeX backend for haddock, and it might use some of lhs2TeX's functionality. it's been on my TODO list for what feels like centuries, but I've never needed it enough to actually do it.
07:32:42 <ChristianS> kosmikus: yes, that would be cool.
07:35:39 <MaybeJust> anyone know a android channel?
07:36:46 <hpc> when using ghc 7.4.1 you can't use the latest version of cabal-install on hackage?
07:36:58 <hpc> bootstrap.sh can't resolve all the dependencies
07:37:28 <ion> hpc: darcs get --lazy 'http://darcs.haskell.org/cabal/' && cd cabal/cabal-install && ./bootstrap.sh
07:38:29 <hpc> ion: yeah, i figured that much out
07:38:40 <hpc> just wondering if i can't use hackage's copy at all
07:42:23 <hpc> cabal has a lot of dependencies for something that has to be bootstrapped
07:43:38 <MaybeJust> hi
07:43:50 <MaybeJust> d
07:44:13 <rwbarton> guess he had Nothing to say
07:45:06 <MaybeJust> q
07:47:46 <kosmikus> hpc: you can use and old cabal binary with ghc-7.4.1, if you have one lying around; but using the development version is better
07:48:12 <kosmikus> hpc: most people get cabal-install via the Haskell Platform, and then bootstrapping is not needed
07:49:00 <dcecile> @hoogle :: [a] -> [a] -> [[a]]
07:49:01 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
07:49:01 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
07:49:01 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:50:11 <dcecile> Hi, could anyone shed light on why my search here didn't work?
07:51:10 <ion> Because a function of that type wasn’t found by hoogle.
07:51:13 <ksf_> it worked. hoogle is just fuzzying a bit.
07:51:49 <ksf_> :t \x y -> x:y:[]
07:51:51 <lambdabot> forall a. a -> a -> [a]
07:52:19 <dcecile> OK, that's fine. Thanks!
07:52:34 <hpc> kosmikus: i need 7.4.1 because of some stupid dependency stuff with lambdabot
07:52:44 <ksf_> it's hard to come up with a function that is limited to [a] in the first two arguments.
07:52:56 <hpc> im trying to document EXACTLY what needs to be done to install lambdabot on a fresh debian testing
07:53:00 <ksf_> ...sensible ones, that is.
07:53:20 <ksf_> hpc, try gentoo.
07:53:32 <hpc> don't know gentoo
07:53:32 <Franciman> hey why am I getting not in scope errors for c, cs and charClass in this line : globToRegex' ('[':'!':c:cs) "[^" ++ c:charClass cs ?
07:53:34 <ksf_> also, your cabal-install doesn't need to be up to date.
07:53:39 <Franciman> of course charClass is defined
07:54:01 <ksf_> Franciman, because they're not in scope.
07:54:07 <ksf_> the compiler is always right.
07:54:09 <Franciman> oh my god
07:54:11 <hpc> i might try that later, but my ultimate goal is to get lambdabot to the point where "apt-get install ghc && cabal install lambdabot" just works
07:54:25 <Franciman> I forgot the equal
07:54:36 * Franciman beats himself
07:54:40 <Franciman> thanks
07:54:41 <hpc> and ideally also get the code itself back to a maintainable state
07:54:46 <kosmikus> hpc: lambdabot requires 7.4.1?
07:55:01 <hpc> kosmikus: not technically, but using it solves some impossible deps
07:55:13 <hpc> im sure some deep magic could get those deps fixed
07:55:37 <hpc> one already is, with a mueval update a couple of days ago
07:56:03 <kosmikus> hpc: ok. if you now have the development version of cabal-install, you could try using that with --solver=modular and an older ghc.
07:56:13 <kosmikus> hpc: the solver should be better at finding solutions.
07:57:48 <SoleSoul> Hi. A hint on functional thinking. I have a [String] and a [(index, chars)] which is of type [(Int,String)]. For each tuple, I want to concatenate the chars to the String in "index". It's easy with loops but how to you do in functionally?
07:58:51 <hpc> SoleSoul: what would you get if you evaluated
07:59:05 <hpc> foo ["abc"] [(15, "xyz")]
07:59:06 <hpc> ?
07:59:15 * hpc is confused about what you want it to do
07:59:48 <SoleSoul> hpc: the [String] has only one string in it so there is no index 15. Nothing would happen
07:59:55 <hpc> oooooh
08:00:00 <hpc> i see
08:00:18 <SoleSoul> hpc: ["abc"] [(1, "xyz")] would be ["abcxyz"]
08:00:29 <parcs`> not 0?
08:00:36 <SoleSoul> doesn't matter
08:01:04 <parcs`> how does it not matter?
08:01:18 <hpc> foo strings assList = foo' strings (Map.FromList assList)
08:01:28 <hpc> foo' [] map = []
08:01:29 <SoleSoul> parcs`: I can decide arbitrarily if it will be 1 or zero based because I use it internally
08:01:36 <hpc> er
08:01:45 * hpc will paste
08:01:56 <db81> I'm on windows with Haskell Platform and I just compiled pcre (the C library) for the haskell pcre. I have MinGW installed side by side with HP. I'm wondering where it's better to put the *.a and includes now.
08:02:35 <ksf_> where they're going to be found.
08:02:58 <ksf_> if there's no such place, put them somewhere where also the cabal packages get installed.
08:03:26 <db81> how can I tell GHC to always look for includes somewhere?
08:03:39 <db81> like in my MinGW include folder
08:04:37 <ksf_> ghc shouldn't be a binary, but a script, that calls the real ghc in <somewhere>/lib/ghc and passes all kinds of parameters.
08:04:46 <hpc> http://hpaste.org/65501 -- SoleSoul
08:04:48 <ksf_> that's only ghc, though, you'll want cabal to find things.
08:04:55 <db81> right
08:05:27 <ksf_> extra-lib-dirs in the cabal config might be what you want.
08:05:35 <hpc> SoleSoul: i change the list to a Map, for a bit of speed, and then call foo', which carries the index as an extra parameter
08:05:36 <SoleSoul> hpc: ooo Thank you very much. I might take me a few minutes to understand it before use :)
08:05:45 <hpc> if you call foo' with 1 instead of 0, it will be 1-indexed
08:06:12 <parcs`> :t let f a = let m = Map.fromList (zip [0..] a) in map (\(i, s) -> (i, fromMaybe "" (Map.lookup i m) ++ s)) in f
08:06:13 <lambdabot> Couldn't find qualified module.
08:06:23 <parcs`> :t let f a = let m = Data.Map.fromList (zip [0..] a) in map (\(i, s) -> (i, fromMaybe "" (Data.Map.lookup i m) ++ s)) in f
08:06:24 <lambdabot> forall t. (Ord t, Enum t, Num t) => [[Char]] -> [(t, [Char])] -> [(t, [Char])]
08:07:40 <ksf_> db81, haskell support on windows is generally a bit weak because there's just not enough contributors to it.
08:07:47 <parcs`> if you make the second list a map then duplicate indices will get removed. not sure if that's intended behavior
08:08:03 <ksf_> dunno if interix, cygwin or somethings fixes the situation for windows people.
08:08:26 <db81> ksf_: thanks for the hint on extra-lib-dirs, I guess it's going to work now
08:10:35 <db81> yeah, that's much better
08:14:25 <parcs`> :t M.lookup
08:14:26 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
08:17:44 <parcs`> :t let f a = let m = M.fromList (zip [0..] a) in catMaybes . map (\(i, s) -> (++ s) <$> M.lookup i m) in f
08:17:45 <lambdabot> forall a t. (Monoid a, Ord t, Enum t, Num t) => [a] -> [(t, a)] -> [a]
08:41:24 <JamesJRH> Wow, I've barely started with Haskell and I can already feel it's total awesomeness! :-D
08:43:55 <cjay> :)
08:44:01 <zmoazeni> Hi folks, is there an alternative to escaping double quotes within a string? For instance, if I want to type the json string in the console: "{\"foo\":1}" in ruby I can do '{"foo":1}' (single quote which I know means Char in haskell) or %Q({"foo":1}) and it will auto escape the quotes. Google is failing me, so I doubt something exists, but I thought I'd ask.
08:44:31 <benmachine> zmoazeni: quasiquoting can sort of do that, but it's a bit overkill
08:44:31 <zmoazeni> Manually escaping every time is becoming a pain
08:45:36 <zmoazeni> benmachine: Interesting. Yeah that does seem powerful. This is mostly for convenience in ghci
08:46:09 <benmachine> zmoazeni: http://hackage.haskell.org/package/string-qq
08:47:19 <rwbarton> I was going to suggest doing "x <- getLine" and then typing in the string on the next line, but that leaves the console in some raw mode where you can't do any line editing at all
08:47:45 <tromp__> > show  "{\"foo\":1}"
08:47:46 <lambdabot>   "\"{\\\"foo\\\":1}\""
08:49:45 <tromp__> > putStrLn $ show  "{\"foo\":1}"
08:49:46 <lambdabot>   <IO ()>
08:50:37 <hpc> tromp__: sorry, your remote code exploit is in another castle
08:50:49 <hpc> ;)
08:52:47 <benmachine> hmm
08:53:38 <zmoazeni> Cool, http://hackage.haskell.org/packages/archive/string-qq/0.0.2/doc/html/Data-String-QQ.html worked. You just have to start ghci with -XQuasiQuotes (unless there's a way to enable the extension after it's launched)
08:54:09 <rwbarton> try :set -XQuasiQuotes
08:54:10 <benmachine> zmoazeni: you can use :set -XQuasiQuotes
08:54:15 <benmachine> it even has tab-completion
08:54:15 <zmoazeni> Ah
08:54:31 <benmachine> zmoazeni: also, here's a lighter-weight, less powerful solution
08:54:34 <benmachine> one sec
08:55:42 <hpaste> benmachine pasted “autoquoting strings in ghci” at http://hpaste.org/65504
08:56:00 <benmachine> zmoazeni: http://hpaste.org/65504 making use of the magic 'it' variable, and :def
08:56:07 <zmoazeni> hrm, reading
08:56:46 <zmoazeni> Ahh, I see now
08:56:53 <zmoazeni> hehe
08:56:58 <zmoazeni> clever
08:57:25 <benmachine> zmoazeni: with a bit more work I could make a command that you do :string s this is a string and it sets s to the relevant string
08:57:28 <benmachine> but that sounds hard :P
08:57:53 <zmoazeni> Nah, both of these are pretty good. Thanks for the help!
08:58:05 <benmachine> np :)
08:58:14 <zmoazeni> Small json strings are alright to manually quote, it's the larger ones that give me fits
09:05:08 <hpaste> zmoazeni pasted “lazy io” at http://hpaste.org/65505
09:05:33 <zmoazeni> Another question, if I may. In that paste there: are the lines lazily read from that file?
09:05:34 <hpc> lambdabot depends all installed and configured right
09:05:35 <hpc> :D
09:05:55 <hpc> now im adding FlexibleInstances to the top of plugins one by one
09:06:20 <zmoazeni> I've read data is lazily read using that method, but I didn't quite grok if that would work with the "lines" function
09:06:53 <Botje> zmoazeni: yes, lines will lazily produce a list of lines.
09:07:48 <zmoazeni> Thanks Botje.
09:08:24 <ski> zmoazeni : yes it will, because the list `contents' is lazily&incrementally (read and) created (and therefore `contentLines' is as well, since `lines' is incremental)
09:09:33 <zmoazeni> I think it was warping my mind that the values in an array were lazily added. Still new to this concept
09:09:34 <ski> (`reverse' otoh isn't incremental, it's a buly operation, so if you would have applied that to `lines' (and forced the result), then it would at that point read the whole file into memory)
09:09:44 <ski> it's not an array, it's a list
09:09:50 <zmoazeni> Sorry, right. List
09:09:56 <unlink> How do I propagate a Maybe across a composition of lenses? (e.g. resulting from a mapLens)
09:10:07 <ski> and it's not really that they are added, it's more like they are discovered to be there
09:10:29 <ski> (i mean, it's not like you can see that before there's three elements, and afterwards there's four)
09:10:43 <zmoazeni> I assume it's something similar to the concept of [1..]
09:10:46 <ski> unlink> :t mapLens
09:10:52 <ski> zmoazeni : indeed
09:12:00 <ski> zmoazeni : however, it *is* also possible to have lazy arrays (and that can be quite useful sometimes) -- however in this case all the cells are created at the same time -- the array doesn't change size -- it's just that not all the elements of the cells are evaluated directly (or at all)
09:13:06 <zmoazeni> I'm working on an http service and came across http://stackoverflow.com/questions/5892653/whats-so-bad-about-lazy-i-o - does lazy io (or lazy operations for that matter) usually crop up in hard-to-debug ways?
09:13:40 <zmoazeni> As you mentioned, if I had called reverse and wondered why my program was slurping up so much memory
09:14:40 <jmcarthur> lazy io in particular can be hard to debug, in my opinion
09:14:40 <hoarser2> newbie questin: how do you pull a value out of IO without using do?
09:14:41 <zmoazeni> I guess, I should clarify my question. It is common to find difficult-to-debug problems that are caused by lazy evaluation?
09:14:56 <jmcarthur> lazy evaluation of pure expressions isn't so hard to reason about, to me
09:15:01 <unlink> ski: eh?
09:15:17 <zmoazeni> hoarser2: You can use >>=
09:15:35 <jmcarthur> hoarser2: how do i pull the IO out of a value?
09:15:37 <Botje> hoarser2: you can't.
09:15:51 <unlink> I guess I'm looking for some kind of monadic lens. Whoops.
09:15:56 <jmcarthur> hoarser2: pardon if that seems an odd thing to say. i say it to point out that pulling a value out of IO is just as odd
09:16:49 <jmcarthur> hoarser2: because a value of type (IO a) does not contain a value of type (a) within it
09:16:50 <ski> > let fibsUpTo n = arr where arr = listArray (0,n) [fib i | i <- [0 .. n]]; fib 0 = 0; fib 1 = 1; fib n = arr ! (n - 2) + arr ! (n - 1) in fibsUpTo 12
09:16:52 <lambdabot>   array (0,12) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34...
09:17:08 <ski> unlink : i was asking you what the type of `mapLens' was ..
09:17:33 <jmcarthur> hoarser2: but in your defense, it's a common phrasing among those new to the idea
09:17:35 <zmoazeni> You guys are all right, with my own newbie (and incorrect language) I see hoarser2's question as "If I have IO String and need access to that string, and don't want to use the "do" construct, how can I touch it?" Chaining functions with >>= works, which is really what the do-syntax does under the covers.
09:18:03 <zmoazeni> *my own newbie eyes
09:18:22 <ski> zmoazeni : the above ^ is a simple example of writing a lazy cyclic array, defined in terms of itself -- in more complicated examples one would often only extract a single element at the end, letting the rest of the elements which are needed be calculated, and the others's not
09:18:25 <opqdonut> or fmap/liftM
09:18:28 <jmcarthur> zmoazeni: the wording that people use often betray some fundamental misunderstandings that i think are best to tackle as early as possible
09:18:39 <ski> zmoazeni : so, doing this is a way to cache intermediate results, to e.g. do dynamic programming
09:19:27 <zmoazeni> ski: Ah right on
09:19:36 <ski> @wiki Introduction to IO
09:19:37 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
09:19:41 <ski> hoarser2 ^
09:20:18 <zmoazeni> jmcarthur: Yeah, that's understandable. But as a guy who is on his 5th attempt at groking haskell, being able to move forward with even an incorrect understanding helps someone move forward. Not ideal, but also not as frustrating.
09:20:43 <ski> zmoazeni : one nice thing about this way of dynamic programming is that you con't have to manually "evaluate the levels", instead exactly those of the intermediate results which are actually *needed* will be evaluated :)
09:21:38 <ski> @quote /bin/ls
09:21:39 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:21:46 <ski> hoarser2 : that ^ too
09:22:54 <ski> zmoazeni : yeah, we see your POV
09:23:04 <zmoazeni> ski: What is the reasoning behind the strictness in:  fib n = arr ! (n - 2) + arr ! (n - 1) ?
09:23:13 <ski> no strictness there
09:23:15 <zmoazeni> I'm trying to grok it piece by piece and failing
09:23:26 <ski> @type (!)
09:23:28 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
09:23:28 <zmoazeni> oh I thought the "!" meant to strictly evaluate the right side
09:23:29 <Botje> zmoazeni: arr ! x is an array index.
09:23:31 <zmoazeni> Ahh
09:23:33 <ski> `!' there is array indexing
09:23:44 <ski> cf.
09:23:47 <ski> @type (!!)
09:23:48 <lambdabot> forall a. [a] -> Int -> a
09:24:11 <Botje> zmoazeni: but since you asked, the array is filled with unevaluated expressions ("thunks"), which are evaluated the first time they are accessed
09:24:32 <unlink> ski: oh. mapLens :: Ord k => k -> Lens (M.Map k v) (Maybe v)
09:24:37 <ski> zmoazeni : `arr' is defined as an array of a certain size, where each element is defined by passing the current index to the function `fib'
09:24:38 <zmoazeni> I kind of comprehend that (to a point). The expressions are replaced all the way down until one *has* to be evaluated
09:24:44 <hoarser2> Thanks guys, but let me phrase it more simply.
09:25:07 <hoarser2> In the repl, I want to assign to some variable 't' the result of, say, getLine.
09:25:19 <hoarser2> getLine returns IO String.
09:25:23 <hoarser2> I want just the String.
09:25:25 <ski> zmoazeni : now `fib' is crucially defined in a mutually recursive way with `arr', which means that to compute `fib i', (except for the first two `i's), it will look back into the array for the two previous results which where cached there
09:26:00 <zmoazeni> It's like understanding basic math (1 + 2) and then looking at a calculus expression. I sorta see how it builds on that concept, but it takes work to make it click comfortably in my head.
09:26:06 <ksf_> t <- getLine
09:26:20 <ski> zmoazeni : however, note that if i had only done `fibsUpTo 12 ! 5' at the end, that would only have triggered the first six elements of the array to be evaluated (and cached)
09:26:33 <ksf_> ghci is basically a big do block.
09:26:57 <zmoazeni> ski: Ok, now it's clicking. You're using the array as dynamically cached values instead of having to recurse all the way
09:26:58 <ksf_> if that's not what you want, getLine >>= \t -> ... is the other option.
09:27:04 <hoarser2> ksf_: beautifully answered, thank you.
09:27:42 <ski> zmoazeni : if there was no caching (i.e. no intermediate array in which to store the results), then `fib 5' would trigger `fib 4' and `fib 3', which would trigger `fib 3',`fib 2',`fib 2',`fib 1',&c. in the end reevaluating previous answers *many* times (very inefficient) -- the point of thte array here is to cache these results so that they aren't evaluated more than once
09:27:49 <ski> zmoazeni : exactly ! :)
09:28:09 <ski> zmoazeni : and note how this works just fine with *immutable* arrays :)
09:28:52 <zmoazeni> hoarser2: As another guy who has been recently struggling with this stuff. I'd recommend reading up on the reasoning behind do and "<-" and ">>" and ">>=". You can sorta gloss over the monad concept as a container (probably bad language). That helped stuff click in my head a lot easier. The do-syntax is just sugar over ">>" and ">>="
09:28:55 <ksf_> hoarser2, if you have a function you call again and again in the repl (eg. reading in and processing a file) and you don't want to t <- all the time, you can use an IORef to store stuff.
09:29:00 <jmcarthur> zmoazeni: i think people often try to move too quickly without paying attention to the fundamentals
09:29:17 <ksf_> though reading an ioref is an io action again, of course.
09:29:18 <jmcarthur> zmoazeni: it's like trying to skip calculus I and II and go straight to III
09:29:36 <jmcarthur> it usually doesn't work out at all, and you end up having to try five times
09:29:57 <ski> hoarser2 : alternatively `do t <- getLine; ..t..'
09:30:04 <zmoazeni> jmcarthur: That's fair. But there's also something to be said about trial/error and quick wins :)
09:30:09 <jmcarthur> zmoazeni: yes, the container analogy is, in my opinion, very misleading
09:30:37 <ksf_> it's best to imagine monads as burritos.
09:30:45 <zmoazeni> delicious
09:30:55 <ski> @undo do l <- getLine; let {r = reverse l}; putStrLn r
09:30:55 <lambdabot> getLine >>= \ l -> let { r = reverse l} in putStrLn r
09:31:04 <ski> @undo do l <- getLine; putStrLn (reverse l)
09:31:05 <lambdabot> getLine >>= \ l -> putStrLn (reverse l)
09:31:17 <sanjoyd> `IO x`'s are like motors which can turn on another `IO x`.  But since you can't turn them on, you stick them in some configuration and have GHC turn on the first one.
09:31:28 <ksf_> @pl getLine >>= \ l -> putStrLn (reverse l)
09:31:29 <lambdabot> putStrLn . reverse =<< getLine
09:31:39 <ski> hoarser2 : you can use `undo' as above to check what the primitive syntax behind `do'-notation is
09:31:57 <ksf_> @pl getLine >>= \ l -> let { r = reverse l} in putStrLn r
09:31:58 <lambdabot> (line 1, column 24):
09:31:58 <lambdabot> unexpected "{"
09:31:58 <lambdabot> expecting "()", natural, identifier or "in"
09:32:09 <ksf_> @pl getLine >>= \ l -> let  r = reverse l in putStrLn r
09:32:10 <lambdabot> putStrLn . fix . const . reverse =<< getLine
09:32:18 <zmoazeni> ski: Am I able to perform that 'undo'-like operation locally in the terminal?
09:32:28 <zmoazeni> using ghc or ghci
09:32:34 <ksf_> :t fix . const
09:32:35 <lambdabot> forall a. a -> a
09:32:50 <ksf_> > fix . const $ 1
09:32:52 <lambdabot>   1
09:33:01 <ksf_> now that's charming.
09:33:13 <sanjoyd> > fix error
09:33:15 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
09:34:24 <ski> @wiki Monads as containers
09:34:25 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_containers
09:34:26 <ksf_> zmoazeni, I think you need to install lambabot for that
09:34:28 <ski> @wiki Monads as computation
09:34:29 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
09:34:44 <ksf_> http://www.haskell.org/haskellwiki/What_a_Monad_is_not
09:35:03 * ski nods
09:36:40 <hoarser2> ski: actually that just gives a parse error.
09:37:47 <ChristianS> zmoazeni: you can also query lambdabot privately (/query lambdabot) if you want her help without disturbing the channel.
09:38:04 <zmoazeni> ChristianS: Ah thanks. That was actually my goal
09:38:04 <ski> hoarser2 : which ?
09:39:30 <hoarser2> ski: this produces a parse error: @undo do t <- getCurrentTime
09:39:40 <teneen> Why does "interact reverse" does nothing in ghci?
09:39:49 <dmwit> hoarser2: The last line of a do block must be an expression, not a binding.
09:40:00 <dmwit> ?undo do t <- getCurrentTime; return 35
09:40:01 <lambdabot> getCurrentTime >>= \ t -> return 35
09:40:09 <glguy_> teneen: what would you expect it to do?
09:40:10 <ski> hoarser2 : notw how i said `do t <- getLine; ..t..', the `..t..' here representing one or more `IO'-commands potentially using `t'
09:40:22 <JamesJRH> I have a list of pairs which I want to plot. Is there an Octave/Mathematica/MatLab equivalent for Haskell?
09:40:27 <hoarser2> ski and dmwit: this produces a parse error:  @undo do { t <- getCurrentTime; return t }
09:40:30 <teneen> glguy: To reverse the given input string?
09:40:40 <dmwit> @undo do { t <- getCurrentTime; return t }
09:40:41 <lambdabot> getCurrentTime >>= \ t -> return t
09:40:44 <dmwit> hoarser2: ...no it doesn't?
09:40:50 <hoarser2> ski: I'm afraid I couldn't (humanly) parse the last thing you said.
09:40:52 <ski> hoarser2 : the last command in a `do'-block can't be of shape `foo <- bar', it must be an expression (commonly something like `return (...)')
09:41:04 <ski> s/notw/note/
09:41:15 <hoarser2> ski: please see my last code snippet; it does end with a return.
09:41:16 <glguy_> teneen: You need to tell it when you are done so it knows what the first output character should be
09:41:25 <glguy_> teneen: try this:  "ghc -e "interact reverse"
09:41:27 <dmwit> hoarser2: Your last code snippet ends with a return, and also works.
09:41:33 <ski> @undo do { t <- getCurrentTime; return t }
09:41:34 <lambdabot> getCurrentTime >>= \ t -> return t
09:41:35 <glguy_> teneen: and then type some stuff and press Control-D
09:41:42 <dmwit> hoarser2: Wait, are you literally giving the "@undo" to GHC?
09:41:54 <ski> hoarser2 : `undo' is lambdabot-command, not a GHCi-command
09:41:54 <zmoazeni> hoarser2: FYI, don't put "@undo" in the ghci terminal. Just the stuff after it
09:42:17 <hoarser2> ski: Ah, thanks.
09:42:53 <ski> hoarser2 : if you want to try `undo' in private, try something like `/msg lambdabot @undo do t <- getCurrentTime; return t' (without the quotes)
09:42:53 <Franciman> hey, can a ternary operator be used in infix notation?
09:43:02 <teneen> glguy_: thanks it works, but can you tell me what the "-e" option does?
09:43:15 <mauke> Franciman: yes
09:43:26 <Franciman> and how does it look like=?
09:43:27 <glguy_> teneen: it runs its argument as a program and imports some set of default modules
09:43:37 <mauke> Franciman: (x ? y) z
09:44:03 <Franciman> ah yes using curring
09:44:05 <zmoazeni> If you guys are alright with another noob question. Is a and b in this last expression visible due to closure semantics?
09:44:05 <zmoazeni> @undo do a <- getLine; b <- getLine; putStrLn a ++ b
09:44:06 <lambdabot> getLine >>= \ a -> getLine >>= \ b -> putStrLn a ++ b
09:44:06 <Franciman> stopid me
09:44:07 <Franciman> thanks
09:44:07 <teneen> glguy_: Is there any way to make it work with ghci?
09:44:32 <mauke> zmoazeni: a yes, b is just a function parameter
09:44:34 <ski> @let (!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]; (as !!<- i) f = front ++ f a : back where (front,a:back) = splitAt i as
09:44:35 <lambdabot>  <local>:8:120:
09:44:36 <lambdabot>      Couldn't match expected type `Int' against inferred type...
09:44:42 <ski> @let (!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]; (as !!<- i) f = front ++ f a : back where (front,a:back) = genericSplitAt i as
09:44:44 <lambdabot>  Defined.
09:44:50 <glguy_> teneen: You'd have to be able to close stdin , which would make GHCi unusable after that point, so probably not
09:44:56 <Franciman> mauke also can I define it like : arg1 (<><>) arg2 arg3 ?
09:45:05 <zmoazeni> mauke: Thanks. I thought that was the case, but wanted to validate
09:45:08 * hackagebot gt-tools 0.1.4.2 - Console and GUI interface for Google Translate service  http://hackage.haskell.org/package/gt-tools-0.1.4.2 (SergeiTrofimovich)
09:45:10 * hackagebot bbdb 0.4 - Ability to read, write, and examine BBDB files  http://hackage.haskell.org/package/bbdb-0.4 (HenryLaxen)
09:45:23 <teneen> glguy_:Oh I see, thanks
09:45:48 <mauke> Franciman: no, that would define arg1
09:45:52 <ski> > let ass = [[],[0],[1,2],[3,4,5],[6,7,8,9]] in (ass !!<- 3) $ \as -> (as !!<- 1) $ \a -> a^3
09:45:53 <mauke> and (<><>) would be a parameter
09:45:54 <lambdabot>   [[],[0],[1,2],[3,64,5],[6,7,8,9]]
09:46:06 <ski> Franciman : the above is an example
09:46:18 <Franciman> oh ok
09:46:32 <zmoazeni> mauke: Ah yeah, "a" was the only one visible due to the closure.
09:47:03 <ski> Franciman : in general, you have to type `(foo +-+ bar) baz', if the operator is `+-+'
09:47:20 <Franciman> yes
09:47:30 <Franciman> got that :9
09:47:33 <Franciman> :)*
09:47:34 <ski> Franciman : so, it's really here an ordinary binary operator which returns a *function* which is then applied to an argument
09:47:46 <Franciman> yeah
09:47:49 <ski> > (if 2 > 3 then sin else cos) (pi/4)
09:47:50 <lambdabot>   0.7071067811865476
09:48:15 <ski> note that function expressions in an application can be complex, even though they commonly are not
09:48:16 <rwbarton> not a very compelling example :)
09:48:36 <rwbarton> > sin (pi/4)
09:48:37 <lambdabot>   0.7071067811865475
09:48:48 <ski> > (let f = sin . cos; g = f . f in g) (pi/4)
09:48:51 <lambdabot>   0.7147757953513574
09:49:00 <dmwit> > sin (pi/4) == cos (pi/4)
09:49:01 <lambdabot>   False
09:49:04 <dmwit> rwbarton: checkmate
09:49:29 <hpc> > let abs' x = if x > 0 then id else negate in abs' 5 5
09:49:30 <lambdabot>   5
09:49:34 <hpc> > let abs' x = if x > 0 then id else negate in abs' (-5) 5
09:49:35 <lambdabot>   -5
09:49:50 <hpc> a slightly more compelling example, with a terrible name :P
09:50:06 <ski> zmoazeni : btw, re "If you guys are alright with another noob question.", we're always alright with that :)
09:50:27 <hpc> a more useful example would be the Reader monad, but that's probably above the level of this question
09:50:47 <zmoazeni> ski: Thanks. It's difficult to form a question without feeling awkward about butchering proper terms/language.
09:50:49 <ChristianS> zmoazeni: and not everyone here is male.
09:51:10 <hpc> can someone else who has hoogle run 'hoogle data'?
09:51:28 <hpc> wget should hang with no dl speed
09:51:33 <zmoazeni> ChristianS: Right on. I'm from Michigan where "guys" is used gender agnostic.
09:51:36 <hpc> or just not connect
09:51:47 <ski> zmoazeni : we understand. as long as you try your best, it's not a problem
09:52:07 <zmoazeni> ChristianS: (in my parts that is)
09:52:58 <ChristianS> zmoazeni: ah, i see :-)
09:55:57 <teneen> is there a function which converts (a -> mb) to (ma -> mb) ?
09:56:36 <rwbarton> :t flip (>>=)
09:56:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
09:56:55 <rwbarton> :t (=<<) -- or indeed this
09:56:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:57:26 <ski> @type putStrLn =<< getLine
09:57:28 <lambdabot> IO ()
09:58:00 <dmwit> teneen: You can ask Hoogle that kind of question yourself!
09:58:06 <dmwit> ?hoogle (a -> m b) -> (m a -> m b)
09:58:07 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
09:58:07 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
09:58:07 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:58:26 <dmwit> Just gotta spell the type right. =)
10:01:26 <ksf_> what's up with haskell.org?
10:02:55 <zmoazeni> ksf_: I was noticing the same thing.
10:03:04 <teneen> dmwit: thanks :)
10:05:43 <monochrom> yikes, http://downforeveryoneorjustme.com/ can't connect to www.haskell.org either
10:07:53 <cbm80> ah same here
10:08:50 * ski noticed some problems some half hour ago, too, but the pages i wanted eventually got fetched
10:10:59 <snhmib> noooooooooooo
10:11:19 <snhmib> ?hoogle Float -> Double
10:11:19 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:11:19 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
10:11:19 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
10:11:49 <benmachine> wow, those are some awful suggestions :P
10:11:58 <benmachine> @type realToFrac
10:11:59 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
10:12:10 <snhmib> thanks :)
10:12:27 * snhmib is lost without hoogle
10:13:44 <_Mikey> If you're trying to write a test case for quickcheck
10:14:15 <_Mikey> and want to generate numbers between 1 and 100 only. How can you do it if the function takes Ints.
10:16:36 <mzero> _Mikey: you can use the  ==> operator to reject test cases that are out of range
10:16:54 <mzero> or, the canonical thing to do would be to define a newtype around Int
10:17:09 <mzero> create a Gen instance for it
10:17:24 <mzero> and the have your test case take your newtype, not Int   ---
10:17:38 <mzero> unwrapping the newtype as part of the pattern constructor
10:18:56 <mzero> sorry, er, an instance of Arbitrary
10:20:22 <_Mikey> mzero, Ok, I've tried defining a new instance for Arbitrary
10:20:32 <_Mikey> but it will affect all other instances right?
10:20:44 <mzero> _Mikey:   did you define instance Arbitrary Int?
10:20:52 <mzero> or some newtype that you created?
10:21:12 <_Mikey> ohh not a new type
10:21:17 <_Mikey> for Int
10:21:23 <mzero> yeah, don't do that1
10:21:28 <_Mikey> but I don't think its going to compile
10:21:29 <_Mikey> XD
10:21:30 <_Mikey> ok
10:22:06 <_Mikey> will I need to rewrite ALL my functions to be of the newtype?
10:22:21 <_Mikey> or will they pick it up type synonym style?
10:22:38 <mzero> no, not a synonym, a newtype - so yes, you need to rewrite to use it
10:22:43 <mzero> but not your apps functions
10:22:48 <mzero> just the quick check properties
10:22:55 <mzero> hang on, I'm typing into hpaste
10:23:39 <_Mikey> ahh cheers! I'll paste what I have at the moment if you like
10:25:22 <hpaste> “_Mikey” pasted “quickcheck” at http://hpaste.org/65509
10:26:20 <hpaste> mzer pasted “limiting range” at http://hpaste.org/65510
10:27:10 <_Mikey> Thanks..
10:27:17 <_Mikey> trying to see where I was going wrong
10:27:24 <_Mikey> Ahh
10:27:34 <_Mikey> I was declaring newtype wrong.
10:27:40 <_Mikey> thanks sir!
10:27:45 <mzero> I've annotated yours too -- notice the technique of unpacking the newtype in the property function definition
10:28:17 <mzero> This is pretty common - as if you don't want to actually limit your function, just the testing, then this way keeps the "limiting type" localized to your quick check code
10:28:39 <_Mikey> Ahh ok.
10:28:41 <mzero> Also, the trick of using fmap  (or equivalently liftM
10:29:33 <mzero> if you had to, say, pick a point   you might see       arbitrary = liftM2 Point (choose (0.0) (1.0) (choose (0.0) (1.0))
10:29:35 <mzero> or even
10:29:51 <mzero> arbitrary = Point <$> choose (0.0, 1.0) <*> choose (0.0, 1.0)
10:30:03 <mzero> those operators are worth learning, as they make things like this very clear
10:30:21 <_Mikey> ah so you're applying Point to the values generated by choose.
10:32:16 <mzero> right
10:32:40 <mzero> it is like you did:    do { x <- choose (0.0, 1.0); y <- choose (0.0, 1.0); return $ Point x y }
10:33:26 <mzero> but not only is it just one line instead of four (if you did normal layout do) --- it reads to me very clear: Point of these two things -- which just happen to be monadic
10:34:17 <hpaste> mzero annotated “quickcheck” with “quickcheck (annotation)” at http://hpaste.org/65509#a65511
10:35:21 <_Mikey> thats makes sense now XD
10:38:19 <koala_bot> Can anyone recommend a good resource for how to access URLs with Haskell? Google is pulling back everything that mentions "url" even in passing.
10:42:08 <cheater> @hoogle url
10:42:08 <lambdabot> Text.Html type URL = String
10:42:09 <lambdabot> Text.XHtml.Strict type URL = String
10:42:09 <lambdabot> Text.XHtml.Frameset type URL = String
10:42:27 <cheater> @hayoo http
10:42:27 <lambdabot> Unknown command, try @list
10:42:34 <cheater> @hoogle http
10:42:34 <lambdabot> package HTTP
10:42:34 <lambdabot> package http-date
10:42:35 <lambdabot> package http-enumerator
10:42:52 <koala_bot> thank you cheater - I was hoping for something a bit more robust than just type or package documentation. Maybe a tutorial or something.
10:43:16 <cheater> yeah no idea, sorry
10:43:20 <koala_bot> alright :)
10:43:23 <cheater> never actually done that but those are some leads
10:43:27 <cheater> have you looked in RWH?
10:44:33 <koala_bot> RWH?
10:44:39 <koala_bot> (I'm pretty new with Haskell)
10:45:10 <ChristianS> @where RWH
10:45:11 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:45:40 <koala_bot> oh :) I like the look of that. Thanks you guys. A good start to the day!
10:50:22 <jearldouglas> How can I do a qualified import of a specific function?
10:50:29 <jearldouglas> Something like this: import qualified Data.Aeson as A (encode)
10:50:55 <jearldouglas> Or do I have to leave it at import qualified Data.Aeson as A ?
10:51:30 <jearldouglas> Now that I think about it, only the latter case makes sense.
10:51:44 <jearldouglas> Rubber duck debugging FTW.
10:52:12 <losvedir> jearldouglas: random guess here, but what about import qualified Data.Aeson (encode) as A ?
10:54:56 <jearldouglas> losvedir: I think that has the same conceptual problem that I was facing to begin with.
10:55:01 <tazjin> jearldouglas: import qualified Data.Aeson as A (encode) should work alright. It doesn't make much of a difference here whether you just import a single function or the whole thing. Why do you want to do that?
10:55:28 <geekosaur> the original one is correct
10:55:36 <jearldouglas> tazjin: You're right, it doesn't make a difference here.
10:55:42 <losvedir> jearldouglas: ah, indeed. bit slow this morning… i see the conceptual issue now. thanks.
10:57:10 <Authoritarianism> Hello. One question. How do I define a data type whose values are 0, 1, 2 and 3, with an increment operation such that Increment 0 = 1, Increment 1 = 2, Increment 2 = 3, Increment 3 = 0?
10:57:54 <Authoritarianism> Basically, I want to define the type of rotations by 90 degrees.
10:59:13 <Authoritarianism> Is there any way to "reuse" an existing integral type under the hood, or do I have to define everything from scratch?
11:01:10 <jearldouglas> This might be overly naive, but are you just looking for a type alias plus a function? http://hpaste.org/65512
11:01:11 <geekosaur> you want subtyping, which is not really supported although there are various ways to fake it
11:03:49 <Authoritarianism> geekosaur: I am not looking for subtyping exactly.
11:03:55 <Authoritarianism> jearldouglas: Let me see.
11:04:32 <Authoritarianism> jearldouglas: If I understand correctly, "type Rotation = Int" just creates an alias for the type "Int".
11:04:47 <Authoritarianism> jearldouglas: Which means 4, 5, etc. are valid values. And that is something I want to avoid.
11:04:54 <jearldouglas> Authoritarianism: Right
11:05:59 <Authoritarianism> jearldouglas: If I understand correctly "0" is just a type constructor, right?
11:06:15 <Authoritarianism> I mean, a type constructor for "Int".
11:06:42 <geekosaur> data constructor
11:06:46 <theldoria> hello all
11:07:10 <geekosaur> the type constructor for Int is hidden (in ghc it's I#)
11:07:21 <mauke> the type constructor for Int is Int
11:07:29 <geekosaur> (I think?  might be for Integer with small vals)
11:07:43 <hpaste> “#haskell” annotated “Rotation” with “Rotation (annotation)” at http://hpaste.org/65512#a65513
11:07:46 <geekosaur> mmm right Im being silly
11:07:55 <geekosaur> I# is a data constructor, just hidden
11:08:01 <nart> hi
11:08:15 <geekosaur> in any case 0 isn't even really a data constructor because it turns into a call to fromIntegral
11:08:29 <Authoritarianism> Oh.
11:08:53 <Authoritarianism> In any case, from my n00b point of view, what I see is that 0 is both an equally valid Int and Integer.
11:09:06 <mauke> and Double and Float and Rational
11:09:14 <Authoritarianism> And I would like to make it a valid Rotation as well.
11:09:47 <Authoritarianism> Is there any way to do that?
11:10:15 <mzero> Authoritarianism: you might try      data Steps = One | Two | Three | Four  deriving (Eq, Ord, Enum, Bounded)
11:10:34 <mzero> Ord gives you succ and pred functions --- Enum lets you convert back and forth to Int
11:10:44 <shachaf> Authoritarianism: There is a way to do that, yes. But the advantage is relatively small -- it just saves you writing "toRotation" in front of a few numbers in your program, or writing out constructors explicitly.
11:11:30 <Authoritarianism> shachaf: I am not just interested in feasible and correct computations. I am also interested in elegance.
11:11:57 <shachaf> Overloading numeric literals isn't elegance. It's just convenience.
11:12:11 <Authoritarianism> mzero: Can I make "succ" and "pred" circular?
11:12:44 <shachaf> You can define succ and pred to be circular, but you probably shouldn't. It most likely violates some laws.
11:12:45 <mzero> if you don't derive Enum
11:12:50 <shachaf> (Certainly if you have Bounded.)
11:12:51 <mzero> but instead write your own instance, sure
11:13:06 <Authoritarianism> Okay.
11:13:11 <mzero> (misspoke above, it is Enum that gives succ and pred, not Ord)
11:13:13 <shachaf> > succ True
11:13:14 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
11:13:28 <Authoritarianism> I guess I am too addicted to C++-style operator overloading.
11:13:33 <mzero> but at that point why not just define your own pair of functions,,,   nextStep  prevStep
11:13:46 <Authoritarianism> mzero: Yeah, that could work as well.
11:14:02 <mzero> if you are Enum, though, then you can use  [x..y]
11:14:04 <mzero> notation
11:14:05 <mzero> !
11:14:18 <Authoritarianism> mzero: What is that? :O
11:14:20 <shachaf> mzero: But not circularly.
11:14:21 <tromp__> http://stackoverflow.com/questions/5684049/is-there-some-way-to-define-an-enum-in-haskell-that-wraps-around
11:14:30 <Authoritarianism> tromp__: Let me see.
11:14:30 <mzero> > [2..8]
11:14:32 <lambdabot>   [2,3,4,5,6,7,8]
11:14:40 <mzero> > ['d'..'k']
11:14:41 <lambdabot>   "defghijk"
11:15:18 <shachaf> Authoritarianism: You've fortunate that, unlike C++, you can define your own operators rather than have to use the few that happen to be predefined in the language.
11:15:22 <mzero> shachaf: I suppose you could "abuse" Enum and define enumFrom in your Enum instance to work circularly
11:15:49 <Authoritarianism> tromp__: That is a neat solution! Thanks.
11:15:57 <shachaf> mzero: But there are a bunch of new questions in that case. Does [1..3] mean [1,2,3] or [1,2,3,0,1,2,3]?
11:16:12 <mzero> shachaf: yes, yes there are.... I did say "abuse"!
11:16:27 <Authoritarianism> Oh, now I see why making circular versions of succ and pred is wrong.
11:16:49 <Authoritarianism> next and prev should definitely be separate functions.
11:17:51 <Authoritarianism> But I still feel like I want to reuse the symbols 0, 1, 2, 3.
11:18:25 <mzero> well - again, you could "abuse" Num  -- and make your type an instance of that
11:18:29 <mzero> :t 2
11:18:30 <lambdabot> forall t. (Num t) => t
11:18:42 <mzero> Notice that 2, as written in a source, can become anything that is Num
11:20:14 <mysticc> I am writing ByteString to a File but I want it to pad it with something so that it is always of fixed size if it is lenght .. How to do it .. I can not use \NUL to pad it as it is used by some encodings while serializing .. ?
11:20:50 <Authoritarianism> mzero: So how should I declare it so that I reuse the symbols 0,1,2,3?
11:20:55 <geekosaur> mysticc, your serialization needs to deal with it
11:21:00 <dmwit> You want us to pick a padding byte without knowing what encodings and serialization protocols you're using?
11:21:16 <Authoritarianism> I have "data Rotations = <???> deriving (Bounded, Enum, Eq, Integral, Num, Ord)
11:21:17 <mysticc> dmwit: I was using Data.Serialize ..
11:21:19 <zzo38> I have once done an abuse of Num, making   instance Num (Q Type)   you can do other things too, but yes it is still an abuse of notation
11:21:34 <shachaf> Authoritarianism: You're unwilling to take people's assurance that it's abuse?
11:21:38 <mysticc> dmwit: default serialization for lists etc ..
11:22:00 <shachaf> Authoritarianism: I recommend that you at least get to the point where you learn what type classes are, so you can figure it out yourself. :-)
11:22:03 <mysticc> @hoogle Data.Serialize
11:22:04 <lambdabot> package genericserialize
11:22:04 <lambdabot> package graph-serialize
11:22:04 <lambdabot> package gtk-serialized-event
11:22:06 <Authoritarianism> shachaf: Okay.
11:22:16 <dmwit> mysticc: Perhaps you'd better look at the documentation for Data.Serialize, then.
11:22:27 <shachaf> Authoritarianism: ("deriving" is a convenient shorthand, not the standard way to deal with type classes.)
11:22:30 <Lemmih> mysticc: Write an instance of Serialize that does what you want.
11:22:48 <zzo38> Authoritarianism:  instance Num X where { fromInteger = ([X0, X1, X2, X3] !!); };   if you replace X and X0 and so on to make it use the symbols 0, 1, 2, 3
11:23:13 <Authoritarianism> zzo38: :O
11:23:16 <shachaf> :-(
11:23:17 <mysticc> Lemmih: I just want to have something with which I can pad.. So is it necessary to change the serialization method ..
11:23:26 <shachaf> zzo38: That won't even type-check.
11:23:38 <shachaf> It'll also make GHC raise warnings, once you do fix it to type-check.
11:23:55 <Lemmih> mysticc: I don't understand what you want.
11:23:59 <zzo38> shachaf: Yes, I know I realized now, you are correct
11:24:09 <zzo38> I forgot  . fromInteger
11:24:38 <mysticc> Lemmih: suppose I have a ByteString which is of 900 Bytes .. But I want it to take 1024 Bytes on harddisk ...
11:25:14 <shachaf> There are a bunch of other things...
11:25:15 <mysticc> Lemmih: So I thought of padding it with some Word8 character and remove it while reading ..
11:25:15 <Lemmih> mysticc: Just adding (1024-900) times NUL solves that.
11:25:58 <mysticc> Lemmih: Yeah .. Now problem comes when I am serializing a list of say Ints .. [Int] .. Data.Serialize uses \NUL in its encoding
11:26:25 <shachaf> Authoritarianism: If you're going to go ahead and make it a Num anyway, it's considered polite to at least make it behave like a Num, to the extent that you can.
11:26:26 <Lemmih> mysticc: Serialize ignores extra data.
11:26:54 <Authoritarianism> shachaf: It is not my intention not to make it behave like a Num.
11:26:59 <mysticc> Lemmih: what do you mean ignores extra data ?
11:27:37 <Lemmih> mysticc: 'decode (encode var ++ extra_data)' will decode 'var' correctly.
11:27:37 <shachaf> For example, your Rotation is probably a group, so you probably want to define (+), (-), negate, etc.
11:27:37 <mysticc> Lemmih: So how do I know when I read back the string , that it is supposed to be of 900 Bytes .
11:27:48 <geekosaur> if you are serializing properly then you have a count of instances in the serialized format; that just means you'll have extra stuff left after decoding
11:27:51 <zzo38> The Haskell "gloss" library ("Gloss hides the pain of drawing simple vector graphics behind a nice data type and a few display functions.") but doesn't have some function might also be wanted such as:   playIO :: forall m r world. MonadIO m => Display -> Color -> Int -> world -> (world -> Picture) -> (Event -> world -> m (Either r (Int, world))) -> (Float -> world -> m (Either r (Int, world))) -> IO r;
11:27:57 * shachaf sighs. This is kind of pointless.
11:28:03 <Lemmih> mysticc: Strings are encoded by first writing down the length and then the contents.
11:28:07 <zzo38> Oops, it should be    -> m r;    at the end
11:28:25 <Lemmih> mysticc: Adding extra zeroes afterwards doesn't do anything.
11:28:36 <mysticc> ohh .. thanks ..
11:28:43 <shachaf> #haskell: Giving you detailed instructions for shooting yourself in the foot since 2010.
11:29:01 <zzo38> Is there any Haskell with something like I describe or if the people making gloss library can add such functions?
11:29:14 <hpc> @djinn a -> a
11:29:15 <lambdabot> f a = a
11:29:25 <hpc> @djinn-ver
11:29:26 <lambdabot> ersion 2009-09-04.
11:29:59 <elemir> @djinn [a] -> [b]
11:29:59 <lambdabot> Error: Undefined type []
11:30:23 <hpc> tracking down some funny behavior in lambdabot's djinn output parsing
11:30:34 <Authoritarianism> shachaf: Yes my Rotation data type is a group.
11:30:43 <hpc> near as i can tell, older versions of djinn have an extra line of crap at the top of the output, probably a type signature
11:30:56 <hpc> and newer versions don't, so it decides djinn wasn't installed
11:32:19 <Saizan> shachaf: oh, it's fine, it's been done much earlier than that
11:32:40 <shachaf> Saizan: Did people do it back in 2007?
11:33:05 <shachaf> Or whenever it was when #haskell was good. Was #haskell ever good?
11:33:18 * shachaf is pretty sure the grass was greener in those days.
11:33:59 * shachaf is pointlessly bitter for some reason.
11:34:07 <shachaf> It's silly.
11:34:09 * shachaf stops.
11:34:15 <Saizan> :)
11:35:35 <zzo38> Do you know if they can fix gloss to have such a function as this?
11:36:09 <zzo38> Or anything else similar?
11:38:32 <danharaj> Yoneda's Lemma is kind of really cool.
11:41:04 <zzo38> play d c i w p e f = playIO d c i w p (\x y -> case x of { EventKey (SpecialKey KeyEsc) _ _ _ -> return $ Left (); _ -> return $ Right (i, e x y); }) (\x y -> return $ Right (i, f x y));
11:42:35 <timthelion> Does anyone know if with Cairo, I can use drawingArea as a container for Gtk widgets?  I would like to include buttons and text edit buttons in my diagram.
11:46:15 <koala_bot> Would some please explain this output type: downloadURL :: String -> IO (Either String String)
11:46:16 <dmwit> timthelion: The documentation knows!
11:46:17 <JamesJRH> How do I map a 2-parameter function?
11:46:34 <JamesJRH> Onto a list of pairs?
11:46:35 <dmwit> timthelion: Since "data DrawingArea" is not a member of "ContainerClass", the answer is no: you can't use DrawingArea as a container.
11:46:37 <timthelion> dmwit: the documentation told me that it's not a container.
11:46:46 <dmwit> timthelion: There you go!
11:46:56 <dmwit> :t uncurry -- JamesJRH
11:46:57 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
11:47:02 <timthelion> dmwit: The documentation didn't, however, give me any bright ideas how to get arround that fact :D
11:47:14 <ben> koala_bot: It is an IO thingy that results in either a String or a String
11:47:27 <ben> If it's the left String, it's probably an error message, if it's the right string, it's probably the result.
11:47:46 <koala_bot> if it returns a String either way, what is the purpose of Either?
11:48:08 <timthelion> dmwit: this is really rather important though, since if I do all the drawing and event handling myself, then I'll also have to do at-spi myself(for accessability) and that makes what should be a weekend project into a lifetime of dedication :(
11:48:08 <dmwit> koala_bot: ...so you can tell if it's an error or not!
11:48:10 <ben> It will return either a Left somestringgoeshere, or Right somestringgoeshere
11:48:20 <ben> the convention is that Left is when something bad happened
11:48:49 <dmwit> timthelion: You don't draw on a DrawingArea anyway, you draw on a DrawWindow.
11:49:03 <dmwit> timthelion: So just get the DrawWindow of whatever it is you want to draw on and draw on it. ;-)
11:49:19 <koala_bot> ben: Why isn't it Either Left Right, then? I realize that might be a stupid question
11:49:37 <dmwit> ben: Left and Right aren't types.
11:49:40 <dmwit> eh
11:49:43 <dmwit> koala_bot: That was meant for you.
11:49:56 <timthelion> dmwit: OK, I'll try that.  I didn't see any good examples in the demo folder.  The only one with text was using cairo's text drawing capability and not a gtk label.
11:50:00 <koala_bot> I figured :)  I guess I don't understand then still how we know between a Left string or a Right string.
11:50:11 * hackagebot snap 0.8.0.2 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.8.0.2 (DougBeardsley)
11:50:13 * hackagebot vector-conduit 0.1.0.0 - Conduit utilities for vectors  http://hackage.haskell.org/package/vector-conduit-0.1.0.0 (JaredHance)
11:50:13 <Mathnerd314> why is data Rose = Rose a [Rose a] called a rose tree as opposed to simply a tree?
11:50:23 <dmwit> koala_bot: The piece of data you're handed has a Left or Right tag. You pattern match to tell which it is.
11:50:24 <shachaf> Mathnerd314: Because there are other sorts of trees.
11:50:29 <ben> koala_bot: The definition is "data Either a b = Left a | Right b" or something
11:50:43 <ben> so if you have an Either a b, you can check whether it's the left thing or the right thing, whatever a or b are
11:50:46 <shachaf> Mathnerd314: Why should this particular sort of tree have a better name than all the rest?
11:50:56 <dmwit> > let x :: Either String String; x = Left "i'm on the left, lol" in case x of Left s -> "it was a left!"; Right s -> "it was a right!" -- koala_bot
11:50:57 <lambdabot>   "it was a left!"
11:50:57 <hoarser2> any opinions on the stability of Data.Time and Data.IntervalMap?
11:51:12 <koala_bot> Oh I see. I didn't realize Left and Right were specified in Either. Thanks you guys.
11:51:17 <Mathnerd314> shachaf: what would a generic tree look like?
11:51:43 <shachaf> Mathnerd314: What does "generic tree" mean?
11:51:44 <dmwit> Mathnerd314: Why is data BinaryTree a = Leaf | Branch a (BinaryTree a) (BinaryTree a) called a binary tree as opposed to simply a tree?
11:52:12 <dmwit> Mathnerd314: Why is data FingerTree a = Digit a | Branch (Digit a) (FingerTree (Digit a)) (Digit a) called a finger tree as opposed to simply a tree?
11:52:12 <Mathnerd314> dmwit: because it has two branches
11:52:44 <dmwit> The answer in all three cases is because the longer term is more descriptive than "tree".
11:53:13 <Mathnerd314> that definition is incomplete, what's Digit a?
11:53:22 <dmwit> unimportant to the question at hand
11:53:31 <rwbarton> no, it's not
11:53:37 <rwbarton> oh wait
11:53:41 <rwbarton> *that* Digit a
11:54:36 <dmwit> If you really want to know more about finger trees, there's half a dozen excellent papers. The point is that there are various subclasses of trees, and it makes sense to indicate which subclass you're talking about in the name of the type.
11:55:02 <mysticc> @hoogle :: Int -> Word64
11:55:02 <Mathnerd314> so... what do the classes of tree share in common?
11:55:03 <lambdabot> Prelude (!!) :: [a] -> Int -> a
11:55:03 <lambdabot> Data.List (!!) :: [a] -> Int -> a
11:55:03 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
11:55:11 <dmwit> No cycles.
11:55:12 * hackagebot arrowapply-utils 0.2 - Utilities for working with ArrowApply instances more naturally  http://hackage.haskell.org/package/arrowapply-utils-0.2 (AndrewMiller)
11:55:43 * benmachine proposes lists be renamed unary-trees
11:56:55 <Mathnerd314> dmwit: what *operations* do they share in common?
11:57:16 <dmwit> I dunno.
11:57:25 <dmwit> Head, maybe.
11:57:39 <monochrom> data LikeFingerTreeExceptArityIs14to17AndWeUseBalancingAlgorithmInTarjan1998 a = ...
11:57:40 <dmwit> fmap?
11:58:04 <benmachine> head is going to be partial on some trees
11:58:21 <hpc> http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13 -- a partial guide to installing and running lambdabot from darcs
11:58:24 * benmachine wonders if data Tree = Leaf | Branch Tree Tree is considered useful
11:59:02 <dmwit> monochrom: Yep, there's a tradeoff to make in naming, as in all thing.s
11:59:28 <hpc> benmachine: i wonder what kind of a thing such a value would encode
11:59:36 <byorgey> it's a binary tree shape.
11:59:39 <Lemmih> benmachine: And its sister structure: data List = Cons List | Nil
11:59:39 <hpc> (like how a data-less [] encodes Nat)
11:59:47 <byorgey> I could imagine it being occasionally useful.
11:59:48 <Mathnerd314> benmachine: it's equivalent to Tree () for a more useful definition of Tree... (ignoring effects)
12:00:10 <byorgey> what effects?
12:00:12 <rwbarton> effects?
12:00:18 <rwbarton> is that what the cool kids call _|_ these days?
12:00:21 <hpc> byorgey: unsafePerform'd effects
12:00:25 <Mathnerd314> rwbarton: yes :p
12:00:28 <hpc> also _|_
12:00:36 <monochrom> in practice we use the worst names: data TarjanKruferPattonFingerTree a = ...
12:01:12 <benmachine> monochrom: in practice we use hyperbole; that's not really the worst name :P
12:01:29 <monochrom> now the reader has to hunt down a Tarjan-Krufer-Patton paper. or perhaps it's just a Krufer-Patton paper
12:01:58 <aristid> monochrom: actually referencing the paper in the documentation would be in poor taste
12:02:35 <hpaste> “realworldhaskell.com” pasted “downloadURL” at http://hpaste.org/65521
12:03:00 <koala_bot> Would it be possible to make this not an IO type so that I could work with the String just as a normal String type?
12:03:10 <monochrom> we say "Boolean algebra" and "Noetherian ring" to make sure that "outsiders" do not gain any information from the names. they have to take our courses and read our papers first.
12:03:32 <rwbarton> oh come on
12:03:40 <zzo38> koala_bot: How do you mean?
12:03:42 <rwbarton> what do you suggest for Noetherian ring
12:03:47 <monochrom> whereas if you say "binary" people can guess, or "... finitely generated ..." people can guess
12:04:00 <osfameron> monochrom: like a subscription model for academia... first one is free!
12:04:06 <benmachine> there are finitely generated rings that aren't noetherian
12:04:14 <koala_bot> zzo38: I don't want the contents of the URL to be output to console, but rather just be returned as String data
12:04:18 <koala_bot> which I can then operate on normally
12:04:24 <monochrom> right, see the "..."
12:04:34 <Saizan> monochrom: weren't you against the search for meaningful names?
12:04:44 <monochrom> I'm just too lazy to look it up and complete the blanks in "..."
12:05:13 <byorgey> koala_bot: it is not possible to get the contents of a URL without it involving the IO type.  However, it is possible to work with those contents "normally", i.e. using a non-IO function.
12:05:22 <rwbarton> probably a good sign that Noetherian is actually a good name then!
12:05:24 <benmachine> monochrom: well, I can't think of a concise way of expressing it
12:05:41 <Mathnerd314> so anyways: head, Traversable, Monad, Monoid... anything else a tree supports?
12:05:59 <benmachine> Mathnerd314: head doesn't count, replace it with treeToMaybe :P
12:06:01 <koala_bot> byorgey I could pass the results of that function then to a function of type String -> a?
12:06:05 <zzo38> koala_bot: You can use fmap to apply non-IO functions to the stuff in IO. For example to apply a (String -> Bool) to (IO String) to result in (IO Bool).
12:06:17 <koala_bot> hm.
12:06:19 <koala_bot> Thank you
12:06:21 <benmachine> Mathnerd314: possibly children :: Tree a -> [Tree a]
12:06:32 <byorgey> koala_bot: yes.  You just have to be careful about the context in which you use the result of that function.
12:07:16 <byorgey> koala_bot: do res <- downloadURL "foo.com"; case res of Left err -> ... ; Right contents -> print (process contents)    for example
12:07:27 <byorgey> koala_bot: where process :: String -> A  for some type A
12:08:04 <zzo38> koala_bot: The result can even be another I/O action; in that case, join will join them together. But usually it is convenient to use >>= as a shortcut to do fmap and join together. And if you need a value afterward with no action, that is what return is for.
12:08:22 <byorgey> koala_bot: note you could not just put "process contents" in place of "print (process contents)" because there has to be an IO action there.
12:08:34 <byorgey> but of course you could do lots of other things besides print.
12:09:00 <Mathnerd314> benmachine: trees are required to have roots, IIRC, so [] couldn't be a tree but data UnaryTree a = Single a | Cons a (UnaryTree a)  is a distinct possibility
12:09:13 <zzo38> koala_bot: Is understand?
12:09:22 <koala_bot> hmmmm... You guys are great. I'll need to work with it to have better understanding though of what you all have said
12:09:33 <benmachine> Mathnerd314: a tree in my head is an acyclic graph
12:09:45 <Mathnerd314> benmachine: children should follow from Traversable and Monad instances
12:09:46 <benmachine> a connected acyclic graph
12:10:01 <benmachine> Mathnerd314: I meant 'immediate children'
12:10:14 <benmachine> unless that's what you meant as well in which case, okay
12:10:21 <byorgey> The class "tree" does not, to me, imply "non-empty".
12:10:27 <benmachine> byorgey: agreed
12:10:36 <byorgey> hence [] can indeed be seen as a degenerate tree.
12:10:57 <hpc> byorgey: type-level [] and value-level []! :D
12:10:57 <rwbarton> connected should imply non-empty though
12:11:12 <byorgey> in fact, in some sense ALL algebraic data types are (possibly degenerate, multi-sorted) trees ;)
12:11:13 <benmachine> rwbarton: hmmm
12:11:18 <benmachine> rwbarton: yeah, okay
12:11:20 <rwbarton> e.g. "every forest is uniquely (up to reordering) a disjoint union of trees"
12:11:20 <Mathnerd314> ah, so we have disagreements about whether it's the leaves or the nodes that are labeled
12:11:47 <benmachine> rwbarton: you can just throw "nonempty" in there :P
12:11:51 <dmwit> Wait, doesn't connected mean "forall pairs (A, B). exists path from A to B"?
12:11:58 <rwbarton> I could just throw in connected too
12:11:59 <dmwit> That seems trivially satisfied by the empty graph.
12:12:06 <hpc> byorgey: depends on how you interpret tying the knot, though that ends up being a debate between "everything is trees" and "nothing is trees"
12:12:08 <benmachine> dmwit: that's one way of putting it
12:12:09 <rwbarton> the point is I don't have to
12:12:28 <byorgey> hpc: sure.
12:12:38 <benmachine> dmwit: I guess it's similar to the discussion of whether or not 1 is a prime; you pick whatever makes the theorems convenient
12:12:44 <zzo38> koala_bot: An example just with text input from the console, for example:  f = fmap reverse getLine;   Now   f :: IO String; because the function reverse :: String -> String applied. Now:  g = fmap putStr f;   g :: IO (IO ());  since  putStr :: String -> IO ();   Now:   main = join g;   main :: IO ();  But it can be written more simply:  main = getLine >>= putStr . reverse;
12:13:12 <byorgey> semantically, tying the knot is neither here nor there, since (Andy Gill's tricks aside) you can never tell whether knot-tying was used to construct something.
12:13:18 <Saizan> hpc: maybe you should link to a patch rather than describe the required editing :)
12:13:26 <Mathnerd314> data ???Tree = ??? a (Traversable t => t a)
12:13:35 <koala_bot> thanks zzo38
12:13:37 <byorgey> by "semantically" I mean "denotational-semantically"
12:13:43 <hpc> zzo38: or in a more "compositional" style, main = putStr . reverse =<< getLine
12:14:04 <zzo38> hpc: Yes that works too, if you prefer it that way.
12:14:12 <zzo38> koala_bot So, is understand now?
12:14:31 <koala_bot> I think so. Playing with it a bit now :)
12:14:58 <Mathnerd314> *edit: data ???Tree = ??? a (forall t. Traversable t => t a)
12:16:38 <zzo38> koala_bot: In case you have another question, you can still ask on this channel someone might answer. (Note: To use "join" directly you need to import Control.Monad but >>= works without it)
12:17:16 <Mathnerd314> *edit: data ???Tree a = ??? a (forall t. Traversable t => t (???Tree a))
12:17:34 <shachaf> Ew, Traversable.
12:18:54 <rwbarton> Why isn't Traversable legit?
12:19:01 <rwbarton> Not using it like that, of course
12:19:11 <benmachine> Mathnerd314: what's your objective?
12:19:26 <rwbarton> actually I don't really know about exists t. Traversable t => t a
12:19:30 <rwbarton> but it sounds suspect
12:19:46 <benmachine> mm
12:19:56 <benmachine> it's not completely useless, you can get [a] out of it
12:20:07 <benmachine> unsure whether there's more to it than that
12:20:15 <aristid> benmachine: that's from Foldable
12:20:22 <Mathnerd314> benmachine: my objective is to figure out an API for trees
12:20:26 <benmachine> aristid: sure, and Traversable => Foldable
12:20:29 <shachaf> Foldable alone is somewhat suspect.
12:20:31 <benmachine> Mathnerd314: why?
12:20:41 <aristid> benmachine: no, Foldable => Traversable.
12:20:46 <benmachine> Mathnerd314: not that you have to justify yourself to me, I'm just curious :P
12:21:07 <benmachine> aristid: I'm using => as "implies", sorry :P
12:21:18 <benmachine> if something is Traversable it is Foldable
12:21:24 <benmachine> :t foldMapDefault
12:21:26 <lambdabot> Not in scope: `foldMapDefault'
12:21:28 <benmachine> oh
12:21:30 <benmachine> well, whatever
12:21:43 <Saizan> :t Data.Traversable.foldMapDefault
12:21:44 <lambdabot> forall a m (t :: * -> *). (Data.Traversable.Traversable t, Monoid m) => (a -> m) -> t a -> m
12:21:49 <aristid> benmachine: and i was using haskell typeclass syntax.
12:22:00 <benmachine> aristid: well, ish.
12:22:10 <aristid> benmachine: yeahish
12:22:26 <koala_bot> I guess I'm not getting it. The syntax of getting a String -> A function to apply to the result of downloadURL "SomeURL.com" is unclear. I'm just working in the console right now rather than in a file trying to test this out and so far have nothing but type mismatch errors
12:22:36 <Mathnerd314> benmachine: I'm attempting to code up Harper's "Practical foundations for Programming Languages". He starts out by defining an AST as "an ordered tree"
12:22:56 <benmachine> Mathnerd314: oh, curious
12:23:19 <benmachine> wait no that makes sense
12:23:21 <rwbarton> a rose tree is what I'd call an ordered rooted tree
12:23:37 <rwbarton> well plus some data associated to the leaves
12:23:38 * benmachine roots rwbarton 
12:23:49 <Saizan> koala_bot: if you have f :: String -> A, then you can do "downloadURL >>= \ str -> f str"
12:23:51 <_Mikey> XD
12:24:04 <Saizan> koala_bot: if you have f :: String -> A, then you can do "downloadURL >>= \ str -> return (f str)" -- sorry
12:24:41 <koala_bot> is there a way to do it without the lambda notation (out of curiosity)?
12:24:59 <benmachine> yes
12:25:00 <Saizan> koala_bot: you want just downloadURL >>= f in the case f :: String -> IO B and you want to execute the side effects resulting from f
12:25:05 <aristid> rwbarton: there are unrooted trees?
12:25:24 <rwbarton> to me "tree" without context would just be a connected acyclic undirected graph
12:25:32 <shachaf> rwbarton: You wouldn't call it "the cofree comonad of []" like all the cool kids these days?
12:25:36 <shachaf> "cotree comonad"
12:25:36 <Saizan> koala_bot: oh, i forgot the argument to downloadURL in these cases, sorry again
12:25:37 <rwbarton> cocool
12:25:45 <franco00> getCPUTime >>= \timeInit -> -- is there a quick and dirty way to make this 'strictly' evaluated?
12:26:09 <koala_bot> downloadURL "http://google.com" >>= return head    should work, no?
12:26:18 <ksf_> franco00, why wouldn't it be strict?
12:26:24 <ksf_> @hoogle getCPUTime
12:26:25 <lambdabot> System.CPUTime getCPUTime :: IO Integer
12:26:28 <Saizan> koala_bot: no, you want return . head there
12:26:34 * koala_bot gives it a shot
12:27:18 <koala_bot> Type error
12:27:34 <franco00> ksf_: when I get two times and do ta - tb and putstrln it I get 0 (and there is some getLine between them, so I expect at least a few seconds). I thought it was lazyness, am I wrong ksf_ ?
12:27:35 <lispy> which type error?
12:28:00 <ksf_> franco00, I'd say it's your cpu timer not having enough resolution.
12:28:03 <koala_bot> "Could match expected type 'Either Sring String' with actual type '[a0]'. Expected type: Either String String -> b0. Actual type [a0] -> a0"
12:28:03 <Saizan> koala_bot: downloadURL "http://google.com" >>= return . head is a type error?
12:28:08 <ksf_> try waiting a bit in between, or doing something.
12:28:16 <ksf_> oh.
12:28:18 <ksf_> nvm.
12:28:30 <rwbarton> franco00: hpaste your program?
12:28:49 <Saizan> koala_bot: ah, yeah, sorry, i though downloadURL was simply String -> IO String
12:28:55 <koala_bot> :)
12:29:02 <koala_bot> Boy do I wish it was
12:29:53 <koala_bot> How do I handle this "Either" business properly so I can apply normal String functions to the result of the download?
12:30:08 <Saizan> koala_bot: you pattern match on it
12:30:09 <ksf_> either is just a data type.
12:30:27 <koala_bot> so I'd have to write a function to handle it? There's no way to just do it inline ?
12:30:39 <ksf_> you could use fmap
12:30:44 <Saizan> koala_bot: \e -> case e of Left e -> ...; Right str -> return (head str)
12:30:51 <ksf_> > fmap (+1) (Either "foo" 2)
12:30:52 <lambdabot>   Not in scope: data constructor `Either'
12:30:58 <Saizan> koala_bot: the one above is a case expression
12:31:00 <ksf_> erm.
12:31:05 <Saizan> koala_bot: and can be done inline
12:31:07 <ksf_> > fmap (+1) (Right 2)
12:31:08 <lambdabot>   Right 3
12:31:16 <ksf_> > fmap (+1) (Left "foo")
12:31:17 <lambdabot>   Left "foo"
12:32:01 <koala_bot> I wish I was better with syntax :( Where would doanloadURL u even go?
12:32:13 <rwbarton> the most straightforward way would be
12:32:18 <rwbarton> do result <- downloadURL myURL
12:32:21 <rwbarton>    case result of
12:32:27 <rwbarton>      Left err -> ...
12:32:35 <rwbarton>      Right contents -> ...
12:33:24 <Saizan> koala_bot: an example would be: downloadURL "url" >>= \result -> case result of Left err -> error err; Right contents -> return (head contents)
12:33:35 <franco00> ok rwbarton & ksf_ http://hpaste.org/65523 sorry for the very messy style, I was aiming for something quick and dirty
12:33:47 <koala_bot> can I just omit the Left case if I don't wish to do anything with it at the moment or are cases required to be comprehensive?
12:34:06 <rwbarton> you can
12:34:51 <koala_bot> Hey! We have  a small victory :) Thanks everybody
12:35:02 <mroman> http://hackage.haskell.org/package/shake-0.2.8
12:35:06 <rwbarton> franco00: cpu time means cpu time
12:35:13 <dmwit> koala_bot: You will get an exception if your case is not comprehensive and that case comes up at runtime.
12:35:16 <rwbarton> not how long the program was waiting for you to enter input
12:35:35 <mroman> found it.
12:35:45 <franco00> mhhhhhhhh silly me... thanks. Which wuold be the correct function to call then?
12:35:46 <koala_bot> dmwit: I would hope that would the case :) Luckily I'm just trying to feel out how all of these pieces fit together for right now. Thanks for the info!
12:37:50 <franco00> as in, some kind of getTimestamp or something, rwbarton
12:38:53 <Saizan> @hoogle getClockTime
12:38:54 <lambdabot> System.Time getClockTime :: IO ClockTime
12:39:15 <franco00> thanks
12:39:22 <ksf_> *in principle*, that shoud work.
12:40:13 * hackagebot vector-conduit 0.1.0.1 - Conduit utilities for vectors  http://hackage.haskell.org/package/vector-conduit-0.1.0.1 (JaredHance)
12:40:15 * hackagebot fdo-trash 0.0.0.0 - Utilities related to freedesktop Trash standard.  http://hackage.haskell.org/package/fdo-trash-0.0.0.0 (EmilKarlson)
12:40:18 <ksf_> getCPUTime's precision is implementation-dependent, your system might just not support it.
12:40:33 <franco00> ARM (efika)
12:40:44 <ksf_> what does cpuTimePrecision say?
12:40:55 <franco00> I am gonna try it right now
12:42:12 <parcs`> @hoogle cpuTimePrecision
12:42:12 <lambdabot> System.CPUTime cpuTimePrecision :: Integer
12:42:20 <jhance> Is there a simple way to combine a sink and an operation to be perfomed on the result of the sink to form a new sink? Conduit doesn't apply after the sink occurs :(
12:42:26 <rwbarton> > System.CPUTime.cpuTimePrecision
12:42:27 <ksf_> on my amd64 it uses getrusage, ymmv.
12:42:27 <lambdabot>   Not in scope: `System.CPUTime.cpuTimePrecision'
12:42:29 <rwbarton> aw
12:43:31 <parcs`> what unit is the value of cpuTimePrecision in?
12:44:05 <franco00> 10^10 ksf_
12:47:16 <ksf_> franco00, https://github.com/ghc/packages-base/blob/master/System/CPUTime.hsc
12:47:40 <ksf_> your options are a) hoping that your system provides getrusage and it's just a configuration hiccup and b) despair
12:48:07 <ksf_> (or use getCurrentTimeOfDay, which is less precise)
12:50:25 <gdoteof>  http://pastie.org/3622903 i am getting "last staement of do must be an expression" on line 9
12:50:35 <franco00> ksf_: I give little about precision (as I should measure my time to solve those questions, not the time it takes to the machine to think them), so I will abuse getcurrenttimeoftheday
12:51:36 <ksf_> gdoteof, are gs and defaultLayout as lined up in your source as it appears there?
12:51:44 <ksf_> (note that tabs are 8 spaces, always)
12:51:51 <dmwit> Incorrect.
12:52:09 <ksf_> if you ask ghc, yes, they are.
12:52:10 <dmwit> Tabs pad out to the next column that is a multiple of eight, no matter how many spaces that is.
12:52:10 <gdoteof> ksf_: yes; its all spaces no tbas
12:53:40 <ksf_> well, it should work. only thing I can think of is that TH messes things up, there.
12:53:52 <ksf_> you could try explicit {;} and see what that does
12:54:04 <gdoteof> ksf_: 'TH' ?
12:54:15 <aristid> gdoteof: the hamlet quasiquotes
12:54:34 <ksf_> line 19 is missing a |, btw.
12:54:37 <ksf_> template haskell
12:56:41 <franco00> where is getcurrenttimeofday defined, ksf_ ? I am a bit lost (hoogle too, it seems)
12:57:08 <ksf_> oh, it's getcurrenttime
12:57:14 <ksf_> data.time.clock
12:57:44 <franco00> thanks
13:03:02 <gdoteof> deleting the TH does not fix it
13:04:01 <hoarser2> Anyone know why the new Data.Time library doesn't define constants that name the days of the week, and months?
13:04:30 <rwbarton> :t ?x do { ?y } ?z
13:04:31 <lambdabot> parse error on input `do'
13:04:56 <rwbarton> gdoteof: line 10 is probably causing an error, all the do/return stuff is unnecessary anyways
13:05:09 <rwbarton> the entire line should just be getCurrentTime
13:05:38 <rwbarton> (that is probably going to be a type error I suppose)
13:06:16 <rwbarton> wait
13:06:21 <kaitocracy> um quick question why doesn't Data.Set derive Functor?
13:06:26 <rwbarton> you don't have a return
13:06:44 <_Mikey> Hi guys
13:06:47 <rwbarton> so that line is join getCurrentTime, which is even more of a type error
13:07:00 <_Mikey> I've got a message on ghci saying that Quickcheck is a hidden package
13:07:10 <_Mikey> QuickCheck.Batch even.
13:07:15 <_Mikey> how do I unhide it?
13:07:34 <rwbarton> kaitocracy: because if it was, you could produce a Set x for a type x which wasn't an instance of Ord or even Eq
13:07:37 <rwbarton> using fmap
13:07:41 <rwbarton> and that can't work
13:08:01 <kaitocracy> rwbarton: oh I see
13:09:08 <rwbarton> :t do x <- ?y do { ?z }
13:09:09 <lambdabot>     The last statement in a 'do' construct must be an expression
13:09:36 <rwbarton> gdoteof: I guess the illegally placed 'do' on line 10 ends the do block that began on line 8
13:10:12 <gdoteof> rwbarton: even deleting that do{..} i get the same error
13:10:13 <rwbarton> gdoteof: you could put line 10 in parentheses
13:10:29 <gdoteof> http://pastie.org/3622903 is the same
13:10:30 <rwbarton> "deleting" is too vague for me. can you paste new source?
13:10:34 <gdoteof> ^^
13:10:38 <rwbarton> thanks
13:11:03 <rwbarton> you still have invalid TH on the last line btw
13:11:18 <rwbarton> should be [whamlet|<h1>Hi|]
13:11:18 <ksf_> rwbarton, but that's still a statement.
13:12:22 <rwbarton> what is
13:14:05 <gdoteof> http://pastie.org/3623377
13:14:06 <rwbarton> gdoteof, I don't believe you
13:14:08 <gdoteof> same
13:14:20 <gdoteof> rwbarton: you don't believe me =D what part
13:14:35 <gdoteof> rwbarton: i am making these pastes direct from buffers
13:14:41 <rwbarton> wait are pastes mutable??
13:15:05 <gdoteof> rwbarton: yeah they are
13:15:10 <rwbarton> anyways I copied some of your stuff and it didn't have a parse error but now it changed so .........
13:15:34 <gdoteof> sry.  i will use a new number each time from now on to be clear
13:16:21 <rwbarton> oh maybe the quasiquotation syntax changed?
13:16:50 <rwbarton> oh no, you just didn't listen
13:17:02 <rwbarton> apparently [whamlet |<h1>Hi|] is not the same as [whamlet|<h1>Hi|]
13:17:02 * gdoteof facepalm sorry iam editing the wrong file
13:17:09 <gdoteof> i think that is the ussie
13:17:11 <gdoteof> issue
13:17:20 <gdoteof> you were right to not believ eme
13:18:41 <gdoteof> i renamed Session to GamingSession and had been editing/saving/retrying the Session.hs file
13:18:55 <hoarser2> What is the type of (1,2,3)?
13:19:02 <Franciman> :type (1,2,3)
13:19:13 <Franciman> :t (1,2,3)
13:19:14 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => (t, t1, t2)
13:19:15 <geekosaur> under what circumstances?
13:19:31 <hoarser2> Let me ask the real question: how do I index into (1,2,3)?
13:19:37 <geekosaur> you don't
13:19:42 <geekosaur> you can pattern match against it
13:19:48 <hoarser2> ok, thx.
13:19:49 <Franciman> exactly
13:20:08 <geekosaur> Haskell tuples are actual tuples.  If youre thinking like Python tuples, those are really a form of linked list and can be indexed
13:20:16 <geekosaur> but are not really tuples
13:20:19 <ksf_> well, there's nthable.
13:20:38 <ksf_> http://hackage.haskell.org/packages/archive/nthable/0.1/doc/html/Data-Nthable.html
13:23:56 <Franciman> hey what is that `|`
13:23:58 <Franciman> class Pos n => Nthable t n a | t n -> a
13:24:03 <Franciman> ?
13:24:08 <ksf_> a functional dependency.
13:24:26 <ksf_> means that for one type n there can only be one type a.
13:24:36 <ksf_> so if you know what n is you know what a is.
13:24:40 <ksf_> the reverse isn't true.
13:24:56 <Franciman> wow
13:24:58 <ksf_> er, when you know t and n you know a.
13:25:21 <elemir> Why does people use functional dependencies expect of type families?
13:25:22 <ksf_> that enables prolog on the type level.
13:25:41 <ksf_> sometimes they're more elegant, sometimes type families make ghc panic on you.
13:26:03 <ksf_> don't work well with -XDeriveGeneric and/or PolyKinds, for example.
13:26:21 <ksf_> quite a lot of unimplemented rough edges.
13:26:21 <elemir> Hem…
13:26:48 <elemir> Typical free software =(
13:26:53 <Franciman> lol
13:27:16 <rwbarton> it's hardly fundeps' fault that they don't work with features from just a few months ago :)
13:27:41 <ksf_> well no, what I wanted to do made type families panic, not fundeps.
13:28:04 <Franciman> oh but, which new features has the new haskell standard introduced ?
13:28:04 <gdoteof> hrm closer. back to a problem i had before geting IO UTCTime instead of UTCTime
13:28:10 <ksf_> fundeps, otoh, were utterly verbose in that situation.
13:28:12 <gdoteof> http://pastie.org/3623460
13:28:22 <deggis> thanks guys. i already pasted my problematic code with lazy evaluation to hpaste and while forming the question here, i anticipated someone pointing out that HDBC API might contain strict versions
13:28:23 <ksf_> Franciman, not a lot.
13:28:28 <ksf_> very few, to be precise.
13:28:28 <rwbarton> oh sorry, I mis/didn't read
13:28:40 <ksf_> the standard is quite conservative.
13:28:54 <elemir> Quite?
13:29:11 <ksf_> read that with british semantics.
13:29:11 <elemir> Haskell standard is ultraright
13:29:14 <ksf_> that is, "utterly".
13:31:06 * elemir really can understand standard writers. GHC extensions is a forest of crutches
13:31:09 <koala_bot> Has anyone used TagSoup?
13:31:28 <ksf_> don't if you can avoid it.
13:31:39 <hiptobecubic> why is 0.05 * 3 > 0.15, but they all show up as being exact in ghci?
13:31:55 <elemir> But they should add System F in a standard
13:32:03 <ksf_> ...that is, if you stand a chance of getting sane input, use a proper sgml/xml parser
13:32:06 <rwbarton> > 0.05 * 3
13:32:07 <lambdabot>   0.15000000000000002
13:32:23 <hiptobecubic> rwbarton, yes but why?  0.05 looks exact, 3 is exact
13:32:26 <hiptobecubic> > 0.05
13:32:27 <lambdabot>   5.0e-2
13:32:28 <Cale> hiptobecubic: that doesn't happen in my ghci
13:32:31 <geekosaur> hiptobecubic, because floating point is inherently inexact
13:32:33 <koala_bot> ksf_: I need to do some really basic html parsing and can't really figure out how to parse things myself, and tag soup looks to be the only html parser with any following
13:32:34 <rwbarton> what does "all show up as being exact in ghci" mean
13:33:03 <rwbarton> the reason 0.05 produces 5.0e-2 is because 5.0e-2 is a valid literal that will evaluate to the same value as 0.05
13:33:15 <ksf_> koala_bot, well, use it. with "proper" I mean parsing valid xhtml
13:33:17 <rwbarton> that doesn't mean anything is "exact"
13:33:27 <ksf_> for which you can use any xml parser and the official dtd
13:33:43 <hiptobecubic> rwbarton, it could display the actual value and it isn't.
13:33:52 <koala_bot> ksf_: If I'm only look to pull out one type of tag, would it be easier to just implement my own parsing than try to use tag soup? I really don't even know how to use it at this point.
13:33:54 <rwbarton> no programming language ever displays the actual value
13:33:58 <koala_bot> looking*
13:34:04 <rwbarton> this is standard floating point behavior
13:34:11 <ksf_> nah, don't implement your own parsing, that's madness.
13:34:20 <ksf_> either tagsoup or an xml library.
13:34:20 <hiptobecubic> rwbarton, then why doesn't it display 0.15 instead of 0.15000000000000002 ?
13:34:23 <rwbarton> the normal thing is to produce the simplest literal that will produce the same actual value
13:34:33 <rwbarton> because 0.15 and 0.15000000000000002 are different actual values
13:34:39 <rwbarton> > 0.15000000000000002 - 0.15
13:34:40 <lambdabot>   2.7755575615628914e-17
13:34:43 <koala_bot> ksf_: Do you have a recommendation? I'm building a really basic web crawler.
13:34:50 <rwbarton> > decodeFloat 0.15
13:34:50 <lambdabot>   (5404319552844595,-55)
13:34:52 <ksf_> use tagsoup.
13:34:59 <geekosaur> hiptobecubic, I think I want tosuggest that you go read up on floating point math
13:35:05 <ksf_> html on the web can't be trusted to be valid, so it's your only chance.
13:35:14 <rwbarton> > 5404319552844595 * 2^^(-55) :: CReal
13:35:15 <lambdabot>   0.1499999999999999944488848768742172978818
13:35:20 <koala_bot> Alrighty thanks. Now to figure out how to use it...
13:35:20 <rwbarton> there is the actual value
13:35:37 <rwbarton> (well, there are a few more digits I guess)
13:35:46 <hiptobecubic> > decodeFloat 0.05
13:35:47 <lambdabot>   (7205759403792794,-57)
13:35:53 <rwbarton> > showCReal 100 $ 5404319552844595 * 2^^(-55)
13:35:54 <lambdabot>   "0.1499999999999999944488848768742172978818416595458984375"
13:36:00 <rwbarton> the actual, actual value. :)
13:36:00 <geekosaur> > decodeFloat 3
13:36:00 <lambdabot>   (6755399441055744,-51)
13:36:26 <ksf_> rwbarton, are you sure?
13:36:33 <rwbarton> sure about what
13:36:36 <ksf_> show CReal chops stuff off.
13:36:41 <ksf_> ...because it wants to terminate.
13:36:51 <rwbarton> i asked for 100 digits and it's of the form an integer times 2^(-55)
13:36:52 <rwbarton> so yes
13:36:56 <geekosaur> 6755399441055744 * 2^^(-51) :: CReal
13:37:01 <geekosaur> oops
13:37:05 <geekosaur> > 6755399441055744 * 2^^(-51) :: CReal
13:37:06 <lambdabot>   3.0
13:37:15 <ksf_> > length "0.1499999999999999944488848768742172978818416595458984375
13:37:16 <lambdabot>   <no location info>:
13:37:16 <lambdabot>      lexical error in string/character literal at end o...
13:37:17 <ksf_> > length "0.1499999999999999944488848768742172978818416595458984375"
13:37:18 <hiptobecubic> so the question is why 0.15 and not 0.14999999999... if 0.05*3 is 0.1500000000000002?
13:37:18 <lambdabot>   57
13:37:20 <ksf_> yep.
13:37:28 <rwbarton> > 6755399441055744 `divMod` (2^51)
13:37:29 <lambdabot>   (3,0)
13:37:57 <rwbarton> hiptobecubic, I explained it earlier
13:38:02 <geekosaur> hiptobecubic, some of that is just the default rounding done by ghci vs. mueval or whatever
13:38:06 <geekosaur> but it's not exact
13:38:08 <rwbarton> no programming language produces 0.1499999999999999944488848768742172978818416595458984375 when you ask it to print 0.15
13:38:24 <ksf_> > 1.0/3
13:38:25 <lambdabot>   0.3333333333333333
13:38:27 <hiptobecubic> rwbarton, so because we're doing some math with the number, it stops nicely rounding it?
13:38:30 <rwbarton> no
13:38:43 <geekosaur> hiptobecubic, you are entering numnes in base 10
13:38:46 <rwbarton> it only rounds to the extent that the number will be unchanged if you entered that number as a literal
13:38:46 <geekosaur> the internal format is base 2
13:38:50 <rwbarton> > 0.1499999999999999944488848768742172978818416595458984375 == 0.15
13:38:51 <lambdabot>   True
13:39:02 <rwbarton> > 0.1499999999999999944488848768742172978818416595458984375 == 0.15000000000000002
13:39:03 <lambdabot>   False
13:39:07 <geekosaur> fractions that are exact in base 10 often are repeating or inexact in base 2
13:39:20 <geekosaur> it's a simple fact of mathematics and of the way computers work
13:39:31 <ksf_> > 0.0001
13:39:32 <lambdabot>   1.0e-4
13:40:19 <hiptobecubic> geekosaur, yes i'm aware of that. It just looked to me like it was displaying the actual floating point value in some cases and not others. I didn't expect that to be true. rwbarton's example clarifies.
13:40:21 <alistra> > 0.1499999999999999944488848768742172978818416595458984375
13:40:22 <lambdabot>   0.15
13:40:27 <alistra> > 0.14999999999999999444888487687421729788184165
13:40:28 <lambdabot>   0.15
13:40:31 <alistra> > 0.14999999999999999444888487
13:40:32 <lambdabot>   <no location info>: lexical error at character '\DEL'
13:40:44 <alistra> > 0.1499999999999999944
13:40:45 <lambdabot>   0.15
13:41:04 <alistra> > 0.149
13:41:04 <lambdabot>   0.149
13:41:09 <alistra> lol
13:41:20 <alistra> floating point arithmetic is the shit
13:41:22 <gdoteof> http://pastie.org/3623541 this also doesn't work.  i am clearly missing something fundamental
13:41:56 <hiptobecubic> python:     In [16]: (0.05, 0.15)     Out[16]: (0.050000000000000003, 0.14999999999999999)
13:42:05 <hiptobecubic> That is what prompted my question.
13:42:12 <rwbarton> oh wow
13:42:19 <hiptobecubic> i much prefer that
13:42:21 <rwbarton> okay, I guess what I say about every programming language is not true
13:42:30 <rwbarton> 0.14999999999999999 is not the real value either though
13:42:37 <rwbarton> just a lazy implementation probably
13:42:40 <geekosaur> output format also matters
13:42:42 <hiptobecubic> Then you aren't caught by comparisons failing later on
13:42:50 <geekosaur> python uses a larger precision for default output
13:43:00 <alistra> gdoteof: what's the type of GamingSession
13:43:19 <rwbarton> in python if I enter 0.37 it prints 0.37
13:43:23 <rwbarton> so it is not immune to this effect
13:43:48 <rwbarton> > decodeFloat 0.15
13:43:49 <lambdabot>   (5404319552844595,-55)
13:43:57 <rwbarton> > encodeFloat (5404319552844596,-55)
13:43:58 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
13:43:58 <lambdabot>         against inf...
13:44:04 <rwbarton> > encodeFloat 5404319552844596 (-55)
13:44:05 <lambdabot>   0.15000000000000002
13:44:12 <geekosaur> (a lot of unixy things use a default printf format of %.6g)
13:44:30 <hiptobecubic> rwbarton, you're right. strange. So we're back to my original question. What motivates it to show you actual values vs the value you're expecting?
13:44:31 <t7> http://www.reddit.com/r/programming/comments/r2byj/why_systems_programmers_still_use_c_and_what_to/c42cn3e
13:44:39 <rwbarton> hmm?
13:44:47 <gdoteof> alistra: UTCTime Maybe UTC Time PlayerId TableId Int
13:44:56 <_Mikey> Hey guys
13:45:01 <hiptobecubic> > decodeFloat 0.37
13:45:02 <lambdabot>   (6665327448508334,-54)
13:45:25 <rwbarton> I would consider python's behavior to be a quality of implementation "bug"
13:45:25 <exFalso2> gdoteof: you are passing in a (IO a) for UTCTime
13:45:58 <gdoteof> exFalso2: thanks yeah i know.  i want to bind the UTCTime itself to something and pass that
13:46:03 <gdoteof> but i don't get how
13:46:16 <exFalso2> gdoteof: i think Handler is MonadIO
13:46:17 <ksf_> gdoteof, that ; there is dodgy.
13:46:35 <alistra> in 12 line do
13:46:40 <ksf_> ...just replace the whole line with getCurrentTime
13:46:42 <alistra> time <- io $ getCurrentTIme
13:46:45 <alistra> or something
13:46:57 <exFalso2> yep
13:47:04 <ksf_> yep, a liftIO might be needed.
13:47:06 <alistra> and then just replace the current line 13 with "time"
13:47:25 <_Mikey> I guys
13:47:30 <alistra> :t io
13:47:31 <lambdabot> Not in scope: `io'
13:47:37 <_Mikey> I have quickcheck installed
13:47:39 <alistra> :t liftIO
13:47:39 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
13:47:47 <rwbarton> hiptobecubic, like I said earlier. haskell prints whatever is the shortest literal that has the same value
13:47:49 <alistra> yup
13:47:52 <_Mikey> and I'm trying to use listof and Gen
13:47:58 <alistra> io is in xmonad or whatever?
13:48:04 <_Mikey> but they're just erroring saying not in scope
13:48:06 <mysticc> I was following RWH for profiling and when I gave my program +RTS -sstderr it gave following message instead of printing memory usage "Most RTS options are disabled. Link with -rtsopts to enable them."
13:48:10 <_Mikey> I've imported the module too.
13:48:19 <rwbarton> > showCReal 100 $ 5404319552844596 * 2^^(-55)
13:48:20 <lambdabot>   "0.15000000000000002220446049250313080847263336181640625"
13:48:26 <ksf_> runInputPost :: FormInput sub master a -> GHandler sub master a
13:48:29 <exFalso2> io is usually defined as an alias for liftIO specifying the monad type iirc
13:48:38 <ksf_> I don't think GamingSession is of type FormInput
13:48:43 <geekosaur> mysticc, yes, that was added to ghc after RWH was published
13:49:03 <Saizan> mysticc: yes, RWH is outdated there
13:49:13 <rwbarton> hiptobecubic: the reason 0.1499999999999999944488848768742172978818416595458984375 is displayed as 0.15 and 0.15000000000000002220446049250313080847263336181640625 is displayed as 0.15000000000000002 is just that 15/100 happens to evaluate to the former rather than the latter
13:49:18 <mysticc> Saizan: So what option I need to use ..
13:49:21 <rwbarton> does that make sense?
13:49:24 <gdoteof> alistra: http://pastie.org/3623605
13:49:28 <gdoteof> like that ^^
13:49:29 <gdoteof> ?
13:49:40 <exFalso2> no
13:49:51 <Saizan> mysticc: you need to build with -rtsopts and then you can use +RTS -sstderr when running the program
13:50:35 <mysticc> Saizan: Thanks
13:50:39 <gdoteof> ksf_: replacing the whole line with getCurrentTime doesn't work either
13:50:57 <ksf_> gdoteof, your code is fundamentally broken type-wise, anyway.
13:50:58 <exFalso2> http://hpaste.org/65526
13:51:00 <exFalso2> like that
13:51:01 <absence> if i have the latest haskell platform installed in windows, is there an easy way to get ghc 7.2 or later?
13:51:07 <ksf_> runInputPost doesn't accept what you're passing.
13:51:17 <rwbarton> > 0.1499999999999999944488848768742172978818416595458984375 - 0.14999999999999999 :: CReal
13:51:18 <lambdabot>   0.0000000000000000044488848768742172978818
13:51:22 <ksf_> it wants a FormInput.
13:52:37 <Authoritarianism> How do I define the type of all positive integers in Haskell?
13:52:53 <alistra> @hoogle liftIO
13:52:53 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
13:52:53 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
13:52:53 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
13:53:11 <Mathnerd314> Authoritarianism: data Nat = One | S Nat
13:53:23 <ksf_> ...or with a newtype and a smart constructor.
13:53:36 <geekosaur> absence, not really.  the platform specifies a compiler, and later compilers may not work (in this case 7.2 *won;t* work and 7.4 requires newer versions of everything else and will likely break other things)
13:53:45 <Authoritarianism> Mathnerd314: Thanks.
13:53:45 <ksf_> not accepting negative literals doesn't work, though.
13:54:09 <Mathnerd314> Authoritarianism: why do you need it?
13:54:15 <alistra> gdoteof: http://dpaste.com/718349/
13:54:19 <alistra> like this
13:54:39 <Authoritarianism> Mathnerd314: I do not know how to explain this.
13:54:59 <absence> geekosaur: i see, thanks. guess the latest version of repa will have to wait for the next haskell platform version then :)
13:55:09 <Taslem> What about Church numerals?
13:55:37 <alistra> gdoteof: you can't like 'execute' the monad inside of the argument for the constructor, because with return it always be of M a type
13:56:02 <alistra> gdoteof: when you bind it to a value earlier, than you can use it as type a
13:56:29 <ksf_> alistra, GamingSession could very well take IO a as parameter.
13:56:34 <koala_bot> I'm trying to build a web crawler but want to avoid cycles. In other languages it is possible to keep a global data structure containing a list of visited sites - but how would I approach this problem in Haskell?
13:56:49 <alistra> ksf_: that's why i asked about gaming session type
13:56:50 <ksf_> you keep a global list of visited sites.
13:57:00 <alistra> 21:42:38    alistra> gdoteof: what's the type of GamingSession
13:57:05 <alistra> 14 minutes ago
13:57:15 <alistra> nobody answered
13:57:17 <exFalso2> koala_bot: you can use an IORef or State or whatever to keep the list around
13:57:17 <ksf_> uris, actually.
13:57:24 <gdoteof> alistra: ahhhhh i see
13:57:34 <koala_bot> exFalso2 I'm not familiar with how that would work x.x
13:57:35 <ksf_> koala_bot, or you can just pass it around manually.
13:57:54 <Mathnerd314> Authoritarianism: I ask because there are other languages like Agda / Coq / Epigram / Idris that come with Nat predefined
13:58:27 <geekosaur> absence, if you stick to the platform, yes.  you can download a newer compiler sans platform (http://haskell.org/ghc) but you have to install and mamage packages yourself (which is what the platofmr is trying to helo you with)
13:59:04 <exFalso2> koala_bot: if you dont want to get into monads then you could just pass around the list as a parameter
13:59:30 <Authoritarianism> Mathnerd314: The definition of Nat you gave, if implemented naïvely, is just a linked list of Ones, which means numbers are given in unary.
13:59:35 <alistra> gdoteof: and Handler is also a monad that is capable of running io inside, so you can do a liftIO
13:59:45 <Authoritarianism> Mathnerd314: Does it get compiled to something more efficient?
13:59:51 <geekosaur> not really, no
14:00:06 <ksf_> Authoritarianism, nope.
14:00:08 <geekosaur> haskell does not have dependent types, so that kind of Nat is pretty much it
14:00:12 <absence> geekosaur: yes, that will entangle me in more details than i'd like :) thanks thougn
14:00:27 <rwbarton> depending on your use (is it a secret or something?) you could use a fixed-size word type like Word32/Word64
14:00:30 <ksf_> Authoritarianism, newtype Natural = Natural Integer
14:01:02 <Authoritarianism> ksf_: ?
14:01:13 <Authoritarianism> ksf_: Sorry, I am a n00b to functional programming.
14:01:26 <Authoritarianism> ksf_: Maybe I should get some practice by solving toy problems for a while.
14:01:30 <ksf_> then do Integer -> Maybe Natural and Natural -> a -> a -> a
14:02:07 <ksf_> well, the idea is to restrict Integer to only positive values, and enforce that by only exporting functions that keep that invariable.
14:02:14 <benmachine> invariant
14:02:17 <ksf_> yep.
14:02:24 <exFalso2> Authoritarianism: they are trying to say that you cannot get a compile time guarantee that your integer is unsigned
14:02:25 <ksf_> I *knew* it was wrong as I typed it.
14:02:34 <benmachine> exFalso2: well, you sort of can
14:02:49 <benmachine> exFalso2: the Real Question (tm) is what 5 - 7 is when 5 and 7 are naturals
14:03:03 <ksf_> it isn't anything, you just don't implement -
14:03:04 <exFalso2> Authoritarianism: you -can- use Words the same way as you'd use unsigned ints in C
14:03:13 <ksf_> you implement pattern matching on S and Z
14:03:29 <benmachine> you can also use a representation more efficient than Z | S Nat
14:03:33 <exFalso2> but the same way as you can have "unsigned int c = -1", you can have negative literals as well
14:03:36 <Authoritarianism> exFalso2: Is there a Word type?
14:03:42 <benmachine> there is indeed a Word type
14:03:45 <exFalso2> Authoritarianism: Data.Word
14:03:47 <ksf_> exFalso2, yes.
14:03:48 <benmachine> but imo overflow bugs are not worth it
14:03:49 <Authoritarianism> Ah!
14:03:57 <rwbarton> Word is just a machine-sized word though
14:04:03 <benmachine> I'd just use Integer and maintain positivity manually
14:04:04 <rwbarton> it's like Int, not Integer
14:04:05 <ksf_> but you can have Integer -> Maybe Natural and be sure that all Naturals are, indeed, Naturals.
14:04:22 <benmachine> the trouble with Word is that 5 - 7 :: Word isn't even a runtime error
14:04:25 <exFalso2> dependent typing allows for compile time checking of the sign
14:04:46 <ksf_> haskell is powerful enough to do the checking in most of the cases, though.
14:04:54 <Authoritarianism> I want to program in such a way that the type of a variable is truly the set of all possible values the variable can assume, no more, no less.
14:04:57 <ksf_> ...you just have to restrain your input manually.
14:05:40 <Authoritarianism> e.g., if I have an array A, then there is the type of valid indices of A elements, which is *not* int.
14:05:44 <ksf_> Authoritarianism, http://hackage.haskell.org/packages/archive/ranges/0.2.4/doc/html/Data-Ranges.html
14:06:24 <Authoritarianism> ksf_: Nice.
14:06:28 <ksf_> and arrays come with bounds.
14:06:34 <ksf_> you can query those.
14:06:54 <exFalso2> Authoritarianism: you cannot catch out of bounds errors at compile time
14:07:29 <Authoritarianism> exFalso2: I want types in some way to codify the proof that my program is correct.
14:07:31 <ksf_> unless you want to do *a lot* of typeclass hackery.
14:07:48 <ksf_> Authoritarianism, welcome to the dark side of haskell.
14:07:52 <Authoritarianism> exFalso2: modulo unreachable operations
14:08:06 <benmachine> ah, unreachable operations, eh
14:08:07 <Authoritarianism> ksf_: What does this dark site consist of?
14:08:08 <exFalso2> Authoritarianism: that would solve the halting problem im afraid
14:08:15 <benmachine> exFalso2: not necessarily
14:08:19 <benmachine> exFalso2: in fact, not at all
14:08:23 <ksf_> Authoritarianism, -XUndecidableInstances, -XOverlappingInstances
14:08:34 <benmachine> ksf_: you probably don't need overlapping
14:08:35 <rwbarton> Authoritarianism: sounds like you might want agda/etc.
14:08:38 <ksf_> -XTypeFamilies -XFunctionalDependencies -XPolyKinds
14:08:52 <ksf_> -XIncoherentInstances
14:09:04 <ksf_> -XDontAskCompile
14:09:05 <benmachine> ksf_: if you ever need incoherent you're probably doing something wrong :P
14:09:06 <Authoritarianism> rwbarton: Actually, I want to learn as much as I can, so I can design an imperative language that lets me compute types.
14:09:14 <Mathnerd314> benmachine: it would solve problems equivalent to the Halting Problem :p
14:09:16 <exFalso2> benmachine: would this compile?: x = (let f = f in f) :: Natural
14:09:18 <hiptobecubic> this feels like dark voodoo
14:09:19 <benmachine> Mathnerd314: nope
14:09:22 <ksf_> -XSafeUnsafeCoerce
14:09:23 <benmachine> exFalso2: no
14:09:27 <Authoritarianism> rwbarton: I want to be able to say, e.g., "type tuple = firstComponentType * secondComponentType;"
14:09:32 <benmachine> exFalso2: proving that that does not terminate does not mean solving the halting problem
14:09:34 <Mathnerd314> benmachine: *subsets of the Halting Problem
14:09:37 <benmachine> Mathnerd314: yes!
14:09:41 <benmachine> Mathnerd314: huuuuge difference :)
14:10:05 <exFalso2> benmachine: yes, but in general it is impossible to do
14:10:12 <benmachine> exFalso2: *in general* of course
14:10:24 <exFalso2> benmachine: which is what the compiler has to do
14:10:28 <benmachine> exFalso2: but you can do *a lot* of useful stuff without full generality
14:10:40 <benmachine> exFalso2: no! you just accept the possibility of false positives
14:10:44 <benmachine> or false negatives or whatever
14:10:50 <Authoritarianism> One question. It is related to the halting problem, but it is not the halting problem.
14:10:57 <alistra> or you can solve it for well-typed agda programs
14:11:09 <ksf_> Authoritarianism, if you want to do a lot of type-level, in particular dependently-typed stuff, have a look at agda, idris, epigram, coq, you name it.
14:11:09 <shapr> ezyang: wonderful blog post! I feel that applies to many discussions of monads vs objects, or my trig class where we memorize lots but understand little. Thanks for writing that!
14:11:10 <alistra> (\_ -> True)
14:11:11 <exFalso2> benmachine: then your type checking would become a heuristic, similar to the termination checker in Agda
14:11:43 <benmachine> exFalso2: is that so terrible?
14:11:45 <Authoritarianism> ksf_: I do not even understand Haskell. How could I stand a chance to understand something a language with dependent types?
14:11:46 <ksf_> Authoritarianism, well, to make the haskell type level turing complete, that is, powerful enought to express what you want, you have to disable its termination checker.
14:11:49 <benmachine> exFalso2: what do you mean by heuristic?
14:11:50 <Mathnerd314> benmachine: actually, you have a frontier: there are well-typed programs, and non-well-typed programs, and programs where the type checker gives up
14:12:01 <benmachine> Mathnerd314: right
14:12:30 <ksf_> Authoritarianism, well, you stand more chances understanding dependent types in those languages than the arcanity that is used to do similar stuff in haskell.
14:12:39 <ksf_> haskell is'nt built to prove everything about your programs.
14:12:40 <exFalso2> benmachine: heuristic=arbitrary way of checking type correctness, without ever covering all the types that you -should- be able to accept
14:13:09 <benmachine> exFalso2: it's not necessarily arbitrary; you have a well-defined set of programs or types for which your algorithm correctly determines that they are terminating
14:13:23 <benmachine> exFalso2: then the rest are "cannot prove termination"
14:13:47 <benmachine> exFalso2: the goal is to make that latter set as small as possible; it is my opinon that existing work has already made it pretty small
14:14:06 <rostayob> benmachine: what exFalso2 means is that there will be total programs that will not pass the termination checker.
14:14:23 <rostayob> that's all he's saying
14:14:24 <benmachine> rostayob: I don't disagree
14:14:29 <benmachine> but I don't think that makes it arbitrary
14:14:38 <ksf_> are total programs even enumerable?
14:14:43 <benmachine> I don't think that's a particularly terrible fate
14:14:43 <rwbarton> also, even when the checker cannot prove that the program terminates, perhaps the programmer can add some hints to show the checker that it does
14:14:56 <rostayob> well, you can choose various way of checking termination, so in that way it's kind of arbitrary
14:15:04 <exFalso2> ksf_: of course, turing complete programs are
14:15:08 <Draconx> ksf_, yes.
14:15:12 <benmachine> rostayob: you can choose various ways of checking types :P
14:15:13 <rostayob> you can offer primitives for recursion, or check that the arguments of the recursive calls are smaller
14:15:34 <rostayob> benmachine: not really once you define the type system before
14:15:47 <rostayob> while "totality" has one possible meaning and you can use various way to prove it
14:16:09 <ksf_> ghc is usually quite bad at doing that
14:16:09 <rostayob> in the end
14:16:09 <benmachine> rostayob: I see what you mean. but to me the choice of termination checker seems analogous to the choice of type system
14:16:18 <rostayob> checking types is just one step in checking totality
14:16:27 <ksf_> you have to enable -XUndecidableInstances for simple things like multiplication.
14:16:27 <rostayob> yes, I agree in that.
14:16:31 <JamesJRH> Can I make an infinite recursive function where each depth level is another step behind? I'm trying to make use of the lazy optimisation. I'm experimenting with primes but this isn't working:
14:16:35 <JamesJRH> let isnextprime ps c = [n | n <- ps, (c `mod` n) == 0] == []
14:16:41 <JamesJRH> let primes = [n | n <- [1..], (if n > 1 then isnextprime (take (n - 1) primes) n else False)]
14:17:08 <benmachine> Authoritarianism: anyway, in an attempt not to lose you entirely, the upshot is that Haskell is bad at "subtyping" (i.e. creating a type that can take some of the values of another type); you can create a wholly new type to do what you want but it's probably unpleasant
14:17:24 <benmachine> Authoritarianism: this is due to design choices in haskell's type system and the way it works
14:17:37 <rostayob> what was Authoritarianism original problem?
14:17:40 <Authoritarianism> benmachine: I am personally not a fan of subtyping either.
14:17:43 <benmachine> Authoritarianism: there are other languages that can do what you want, but I found agda challenging to learn even after I knew haskell
14:17:53 <rostayob> I doubt that subtyping would be the answer, unless he's asking for records
14:17:57 <JamesJRH> primes is an infinite list used by: take 10 primes
14:18:01 <exFalso2> JamesJRH: try n <- takeWhile (< n) ps
14:18:13 <ksf_> I think if you want to go into that direction, starting with coq isn't the worst idea.
14:18:18 <benmachine> Authoritarianism: I see no reason to suppose dependently-typed languages are in general harder, but that was my experience with that particular one
14:18:25 <ksf_> it's got the tutorial, and it's got *a theorem assistant*
14:18:47 <rostayob> dependently typed language are not harder, programming total programs is harder :P
14:18:51 <benmachine> Authoritarianism: anyway, people using haskell will more usually just use the larger type, but not provide its constructors, using functions to ensure only some values can be constructed
14:18:52 <rostayob> *languages
14:18:55 <ksf_> because every termination-checking programming language will make you feel *extremely* stupid.
14:19:15 <Authoritarianism> benmachine: Wow. Not very differently than the way it would be done in C++.
14:19:19 <rostayob> ksf_: for me it's the other way. the termination checker is stupid, not me!
14:19:28 <rostayob> Authoritarianism: what was your question?
14:19:41 <Mathnerd314> <Authoritarianism>	How do I define the type of all positive integers in Haskell?
14:19:42 <rostayob> since it generated all this mess I'm interested now :P
14:19:59 <ksf_> rostayob, but not being able to explain it to someone who is eagerly listen makes *you* dumb...
14:20:21 <rostayob> oh ok. you suggested data Nat = Zero | Succ Nat and he complained that you can't use them interchangeably with integers
14:20:23 <Authoritarianism> rostayob: I want types that only allow a subset of the values of a larger type, that satisfy a predicate.
14:20:48 <benmachine> rostayob: I find agda harder work than haskell, I think it genuinely is a more complex language
14:20:52 <benmachine> but maybe I'm just using it wrong
14:20:57 <exFalso2> Authoritarianism: you -can- make a mapping from Nat -> Integer which will make it safe
14:20:58 <Authoritarianism> rostayob: For instance, yesterday I was solving a problem and I found that I needed a type that represented all integers of the form 6x+1 or 6x-1, with x >= 1.
14:21:00 <ksf_> oh, there's http://hackage.haskell.org/package/Ranged-sets-0.3.0 , too, btw.
14:21:01 <ksf_> it's better.
14:21:07 <rostayob> Authoritarianism: well but in this case, subtyping wouldn't help
14:21:17 <Authoritarianism> rostayob: I do not want subtyping.
14:21:20 <ksf_> as in you can do 1..infinity etc.
14:21:21 <rostayob> ok :)
14:21:28 <benmachine> it was me who said subtyping and I think I was using the wrong word
14:21:29 <Authoritarianism> rostayob: I want… types defined by another type and a predicate.
14:21:30 <exFalso2> Authoritarianism: you can even use a binary definition of Naturals that will have a logN mapping function
14:21:33 <benmachine> I meant... subsetting, I suppose
14:21:35 <JamesJRH> exFalso2: Doesn't seem to help.
14:21:38 <rostayob> Authoritarianism: yes, you want depende types.
14:21:42 <rostayob> *dependent
14:21:44 <benmachine> types built by separation :P
14:21:57 <rostayob> Authoritarianism: you want types dependent on values
14:21:57 <benmachine> rostayob: I don't think dependent types are strictly necessary for that notion
14:22:16 <rostayob> yes you do unless you do all the calculations at the type level to begin with
14:22:26 <benmachine> well, but I see no reason that can't be done here
14:22:41 <rostayob> you can? then yeah
14:22:42 <Authoritarianism> Anyway, I solved my 6x+1 or 6x-1 type need by using an integer-bool tuple.
14:22:46 <benmachine> you don't need dependent types to say "integers greater than 0"
14:22:51 <benmachine> just "integers greater than n"
14:22:56 <Authoritarianism> But I want the compiler to determine out that stuff for me!
14:23:01 <Authoritarianism> s/determine out/determine/
14:23:14 <benmachine> Authoritarianism: well, haskell can't do it, unfortunately
14:23:17 <exFalso2> JamesJRH: ah i think the problem is with taking n - 1 from primes
14:23:21 <rostayob> benmachine: I don't follow. it really seem like he wants dependen types
14:23:54 <benmachine> rostayob: to me the term "dependent type" means you can have a function which takes a value and returns a value whose type depends on the input
14:23:57 <JamesJRH> exFalso2: If I take 0, does it evaluate?
14:24:06 <ksf_> haskell *can* do it. it just sucks at dependent types, that's all.
14:24:26 <ksf_> if you parse your input into different types properly, there's your dependent types.
14:24:58 <benmachine> rostayob: you can easily imagine you might have a language which supports "values satisfying P" as a type, *as long as P is specified at compile time*
14:25:01 <ksf_> haskell then doesn't support a high enough sophistication of type-level programming to make working with them not awkward, though.
14:25:06 <rostayob> benmachine: what he wants is 'exists n. exists m. m * 6 + 1 == n'
14:25:08 <Authoritarianism> benmachine: Exactly!
14:25:35 <rostayob> where == : Nat -> Nat -> Set
14:25:40 <benmachine> rostayob: that's a weird phrasing. you've specified a sentence, not a predicate
14:26:02 <rostayob> benmachine: that does exactly what he wants, carries two numbers and a proof
14:26:08 <Authoritarianism> benmachine: Of course, if P can only be determined at compile time, then the type itself has to be computed at compile time, and the language would require some sort of interpreter/JIT compiler.
14:26:30 <ksf_> Authoritarianism, you can carry code around that is proven to keep the invariant.
14:26:35 <benmachine> rostayob: well anyway, it's not a dependent type in my book, because the information is all specified in the type
14:26:45 <ksf_> that is, the only operations possible on these types are those that keep the invariant.
14:26:46 <benmachine> Authoritarianism: do you mean if P can only be determined at runtime?
14:26:55 <Authoritarianism> benmachine: Yes, sorry.
14:26:56 <benmachine> ksf_: it depends what you consider a proof, in that case, I think
14:27:01 <JamesJRH> exFalso2: It should finish with take 0 primes for each number. take 0 primes is just [].
14:27:05 <ksf_> increase n by one, bang, m gets increased by 1/6th or it doesn't happen.
14:27:09 <Authoritarianism> s/compile time/runtime/
14:27:13 <rostayob> benmachine: yes but the type depends on a *value*
14:27:35 <ksf_> no it doesn't.
14:27:43 <benmachine> rostayob: it depends what you mean by value – the value is one specified in the program, not one discovered by it
14:27:43 <ksf_> not in the strict sense, that is.
14:28:03 <rostayob> yes it does, it depends on two numbers in this case
14:28:29 <ksf_> the example is bad, anyway, as basic arithmetic is easy enough to be completely doable without any fancy termination checking.
14:28:32 <benmachine> rostayob: I think we are only arguing over definitions, here
14:29:00 <rostayob> benmachine: no we're not, that's a classic example of dependent existential quantification, where you carry something and some proof related to that something
14:29:02 <koala_bot> ksf_: Would it be possible to get a brief "quick start guide" on tag soup? I'm looking at the tagsoup.htm documentation and it's got info for use but not for setup, which is what I need as a noob
14:29:26 <exFalso2> JamesJRH: ok i got it
14:29:30 * geekosaur notes that "dependent type" has a standard meaning
14:29:32 <exFalso2> one sec
14:29:34 <ksf_> koala_bot, what do you mean with "setup"?
14:29:43 <rostayob> in Authoritarianism case he wants a number together with a proof that there is another number that multiplied by 6 is equal to the original number :P
14:29:47 <benmachine> geekosaur: what is it, then?
14:29:56 <geekosaur> you were just told what it was
14:30:11 <koala_bot> I'm not sure what I need to do in order to be able to interface with it
14:30:11 <benmachine> geekosaur: if it's "types depend on values" then I want to know what you mean by values
14:30:13 <Authoritarianism> rostayob: Together with a proof that the number is either of the form 6x+1 or of the form 6x-1.
14:30:23 <exFalso2> http://hpaste.org/65528
14:30:26 <rostayob> Authoritarianism: yes, that would work as well.
14:30:29 <Authoritarianism> rostayob: And the proof consists in the value of x and the sign in front of the 1.
14:30:31 <ksf_> also, http://community.haskell.org/~ndm/darcs/tagsoup/tagsoup.htm
14:30:35 <geekosaur> the fact that it doesn;t match what you'd lik it to be means you have an argument with many type theorists
14:30:45 <exFalso2> JamesJRH: also put in a sqrt
14:30:52 <Authoritarianism> rostayob: And since the proof consists in x and the sign, the type's values are encoded as (x, sign) pairs.
14:31:02 <ksf_> koala_bot, parseTags :: StringLike str => str -> [Tag str]
14:31:04 <koala_bot> ksf_: As I said, that's what I'm reading and it gives examples of how to use it, but not how to get your code set up to start using it
14:31:08 <benmachine> geekosaur: I don't have any preferences as to what it should mean, only what I've understood it to mean up to this point
14:31:09 <koala_bot> importing or whatnot
14:31:14 <benmachine> geekosaur: I might be wrong, in which case correct me
14:31:18 <ksf_> ...you need something stringlike.
14:31:52 <ksf_> koala_bot, http://hackage.haskell.org/package/HTTP-4000.2.2  might help with getting that string.
14:32:01 <JamesJRH> exFalso2: Yes, hadn't got round to the sqrt yet.
14:32:18 <koala_bot> no no - like I said, I need to know if I need to import something or how my files need to be set up in my filesystem etc for my code to be able to use tag soup
14:32:27 <exFalso2> JamesJRH: http://hpaste.org/65528 if you missed it
14:32:34 <rostayob> Authoritarianism, benmachine: in Agda, your type could be expressed like this: foo = Σ ℕ (λ n → Σ ℕ (λ m → 6 * m + 1 ≡ n))
14:32:40 <rostayob> which is actually not too hard to read
14:32:51 <ksf_> koala_bot, you need to import the module, sure.
14:32:55 <ksf_> and cabal install tagsoup.
14:33:06 <rostayob> Sigma takes a type and a type-level function from something of the provided type to another type
14:33:19 <Authoritarianism> rostayob: How would I encode it if I want to include values of the form 6x-1?
14:33:23 <benmachine> rostayob: I know what sigma means, but I'm not used to it, so just give me a sec to read
14:33:29 <koala_bot> I'm not sure how to do the import if they're in different directories, and idk what cabal install means
14:33:38 <benmachine> Authoritarianism: presumably with an either-like type
14:33:40 <rostayob> Authoritarianism: you can simply use an or
14:33:49 <ksf_> cabal is a program you should have if you have installed the haskell platform.
14:34:24 <ksf_> just do "import Text.HTML.TagSoup", ghc will find it if it's installed.
14:35:14 <ksf_> koala_bot, http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
14:35:15 <rostayob> Authoritarianism: well with "an or" I mean a sum, so you can either have a proof of the + 1 or the - 1
14:35:21 <rostayob> anyways, hopefully you get the idea.
14:35:32 <koala_bot> Thanks ksf_
14:35:37 <Authoritarianism> rostayob: Ah.
14:35:37 <rostayob> but what you want is totally a depende type (unless all the numbers are at the type level)
14:35:46 <rostayob> *dependent
14:35:50 <benmachine> rostayob: why can't all the numbers be at the type level?
14:36:01 <rostayob> well you could but then you can't use them as values.
14:36:04 <rostayob> it depends what you need to do.
14:36:11 <benmachine> oh, you mean including the actual thing
14:37:05 <rostayob> most of the times having them all at the type level would be pretty useless... unless you're indexing vectors with DataKinds or whatever :P
14:37:20 <exFalso2> DataKinds hell yeah
14:37:36 <benmachine> rostayob: what I'm imagining is a language where {n : P(n)} is a type, and you can construct elements of it by proving P for those elements
14:38:00 <benmachine> rostayob: it seems to me like in that case, the type is always the same type, so it doesn't really depend on a value
14:38:08 <exFalso2> benmachine: which is exactly what Agda is
14:38:24 <benmachine> exFalso2: except that Agda also allows types to be constructed at runtime, as it were
14:38:31 <benmachine> (if I understand correctly)
14:38:42 <exFalso2> benmachine: although you have to use constructive logic
14:38:42 <rostayob> benmachine: ? no
14:38:50 <exFalso2> benmachine: no, everything is compile time
14:38:59 <benmachine> you can have functions in agda which say, give me an integer n and I'll give you an integer of type integers-less-than-n
14:39:06 <exFalso2> unless you postulate some things
14:39:25 <rostayob> benmachine: yes but so?
14:39:31 <exFalso2> benmachine: and the fact that they are less than n is checked at compile time
14:39:43 <exFalso2> its magic
14:39:46 <benmachine> okay but the function's return type changes depending on its inputs
14:40:07 <benmachine> a language could support types of the kind I described without supporting the ability to do that
14:40:30 <rostayob> 1) I don't get what you mean with {n : P(n)}
14:40:54 <rostayob> I guess that P is a normal value-level function right?
14:40:57 <Philonous> Why are there no convenient functions to convert between lazy and strict ByteStrings?
14:40:58 <rostayob> what's the type of P?
14:41:04 <ksf_> nah, a type-level predicate.
14:41:07 <benmachine> P is a predicate of some kind
14:41:11 <rostayob> no, it's important
14:41:12 <benmachine> it's informally-specified
14:41:18 <rostayob> because if P returns a type
14:41:25 <rostayob> and accepts a value (n)
14:41:26 <exFalso2> bemachine: P(n) will make the type it dependent
14:41:28 <rostayob> you already have a dependent type
14:41:45 <ksf_> you both should stop arguing and start coding
14:41:48 <benmachine> say P returns a bool
14:41:55 <rostayob> benmachine: then it's not a type
14:42:01 <benmachine> rostayob: I didn't say P was a type
14:42:02 <rostayob> bool is a value
14:42:03 <exFalso2> lal
14:42:05 <rostayob> yes you did
14:42:09 <rostayob> you wrote 'n : P(n)'
14:42:13 <benmachine> oh
14:42:19 <benmachine> that's not what I meant by :, sorry
14:42:22 <JamesJRH> exFalso2: I got it, thanks. :-) Wow, it's /way/ faster and /way/ shorter than the equivalent implementation of that algorithm I did in Python about 3 years ago. :-D
14:42:29 <benmachine> I meant it in the set-theoretic "such that" sense
14:42:37 <rostayob> mhm?
14:42:40 <benmachine> I don't think in agda so I didn't realise that was confusing :P
14:42:52 <benmachine> {n | P(n)} if you prefer?
14:43:04 <exFalso2> JamesJRH: great! :)
14:43:04 <rostayob> ok, so that's a value itself
14:43:19 <benmachine> rostayob: right
14:43:26 <rostayob> but you said
14:43:33 <rostayob> "what I'm imagining is a language where {n : P(n)} is a type"
14:43:41 <benmachine> yes
14:43:45 <JamesJRH> Primes below 10000000 already! Wow! Python would still be chugging at ~100000! :-D
14:43:49 <rostayob> anyways it doesn't matter, and I need to study for a stupid business course...
14:43:49 <benmachine> hm
14:43:54 <exFalso2> rostayob: {} is a set comprehension
14:43:55 <benmachine> oh, suit yourself
14:43:59 <rostayob> exFalso2: yeah I got that ehe
14:44:07 <rostayob> but then that's a value, and he's calling it a type
14:44:15 <exFalso2> so he wants to refer to types explicitly as sets
14:44:20 <ksf_> values are types are kinds are sorts.
14:44:29 <ksf_> curry = howard, remember.
14:44:41 <ksf_> the question is what you get erased and what not.
14:44:47 <exFalso2> rostayob: no, it -is- a set
14:44:53 <exFalso2> well in total languages anyway
14:45:02 * rostayob goes away
14:45:08 <exFalso2> noooo
14:45:15 <benmachine> ksf_: I think this is relevant to my argument, I think agda necessarily can't erase everything
14:45:35 <ksf_> you can't argue about the whole thing on a level of algebra, you need to specify a semantic for a partial evaluator.
14:45:40 <benmachine> ksf_: whereas I could imagine a language that erased all types but still supported a type of natural numbers as a subset of integers
14:45:45 <ksf_> what does it evaluate at compile time, what afterwards?
14:46:04 <ksf_> of course it can't erase everything, it's dependently typed :)
14:46:47 <benmachine> ksf_: if you think dependent typing => can't erase everything, then do you agree with me that my language is not dependent, or do you think that it can't exist?
14:46:51 <benmachine> or c. other
14:47:16 <ksf_> you never properly defined your language.
14:47:18 <rostayob> I think this is all really vague
14:47:20 <exFalso2> benmachine: it is dependent!
14:48:39 <koala_bot> ksf_: That import isn't working (Could not find module 'Text.HTML.TagSoup') - How do I found what it should be? I've already completed the cabal tag soup install
14:48:42 <exFalso2> benmachine: in non-dependent languages when you write P(n) P can only say "constructed with P's constructors", if you can define P explicitly to be any predicate then you get dependent typing
14:49:06 <benmachine> ksf_: no, but I specified a property it must have; any language with that property will do
14:49:06 <ksf_> koala_bot, http://hackage.haskell.org/packages/archive/tagsoup/0.12.6/doc/html/Text-HTML-TagSoup.html
14:49:09 <rostayob> but what Authoritarianism described it's a classic example of a dependent existential. you could probably define some subtyping on the construtors of the data type or something like that, but it'd be much more restrictive (you definitely can't have the type of numbers for which exists m. 6 * m + 1 == n)
14:49:16 <ksf_> it's clearly called Text.HTML.TagSoup
14:49:25 <ksf_> what does 'ghc-pkg list tagsoup' say?
14:49:44 <koala_bot> What is that?
14:49:59 <ksf_> ghc-pkg is the program that manages ghc's package database.
14:50:04 <ksf_> you have it if you have ghc.
14:50:04 <benmachine> rostayob: my inclination is that there's subtlety to what P can be and the type still be dependent or otherwise
14:50:08 <koala_bot> How do I access that
14:50:17 * hackagebot vector-conduit 0.2.0.0 - Conduit utilities for vectors  http://hackage.haskell.org/package/vector-conduit-0.2.0.0 (JaredHance)
14:50:17 <benmachine> rostayob: possibly 6m+1 is too clever, but I reckon >= 0 is simple enough
14:50:30 <ksf_> just like cabal install, with a terminal and a shell.
14:50:42 <rostayob> benmachine: ok this is all pretty formal and unsubtle. you still haven't told me if P(n) is a value or a type.
14:51:00 <exFalso2> rostayob: it is a type
14:51:04 <tauntaun> lkllklCool, dSounds
14:51:05 <benmachine> rostayob: I don't particularly care what P(n) is :P whatever it might be that makes the thing work
14:51:20 <exFalso2> and >= makes it dependent
14:51:25 <benmachine> rostayob: I thought you were going, anyway
14:51:28 <exFalso2> unless >= is a constructor ofc
14:51:33 <rostayob> benmachine: makes what work? if you want it to be a type (what Authoritarianism asked) then it's dependent. if it's a value, then what do you do with it?
14:51:33 <koala_bot> C:\Program Files (x86)\Haskell Platform>ghc-pkg list tagsoup
14:51:34 <koala_bot> WARNING: cache is out of date: C:/Program Files (x86)/Haskell Platform/2011.4.0.
14:51:34 <koala_bot> 0\lib\package.conf.d\package.cache
14:51:34 <koala_bot>   use 'ghc-pkg recache' to fix.
14:51:34 <koala_bot> C:/Program Files (x86)/Haskell Platform/2011.4.0.0\lib\package.conf.d:
14:51:34 <koala_bot>  
14:51:35 <koala_bot> C:\Users\Jess\AppData\Roaming\ghc\i386-mingw32-7.0.4\package.conf.d:
14:51:35 <koala_bot>     tagsoup-0.12.6
14:51:43 <rostayob> benmachine: can't resist :(
14:51:44 <exFalso2> hpaste.org
14:51:51 <koala_bot> sorry folks.
14:51:51 <benmachine> rostayob: then I will resist for you :)
14:52:00 <benmachine> my point wasn't terribly important one way or the other
14:52:37 * rostayob goes for real
14:52:44 <ksf_> koala_bot, well, do ghc-pkg recache
14:52:49 <ksf_> the package is there, so it should work.
14:52:59 <ksf_> (dunno why the cache is out of date)
14:53:14 <koala_bot> ksf_: I have and it now shows two filepaths then tagsoup-0.12.6
14:53:51 <ksf_> does compiling your code work?
14:54:26 <koala_bot> without trying any imports for tag soup it compiles fine.
14:54:50 <koala_bot> ah, and now that the cache has been updated it's compiling with the import you provided :)
14:55:02 <koala_bot> fantastic thank you.
14:55:23 <JamesJRH> exFalso2: Not sure what the name is of that method of prime searching. I figured it out myself because the sieve method I learned at school seemed very inefficient, and needed to be restarted for a larger range of numbers. I realised that previously found primes could be used in the testing of the next prime to avoid retesting prime factors, and I devised that method that can run indefinitely.
14:57:40 <JamesJRH> Ha! The millionth Prime: 15485863
14:58:31 <JamesJRH> Just... wow.
15:00:09 <JamesJRH> And that's with my ~4-year-old computer! :-)
15:00:16 <dmwit> Conclusion: approximately one fifteenth of all positive integers are prime.
15:01:27 <JamesJRH> dmwit: Approximately 0%, but there is a higher distribution in lower numbers.
15:01:41 <JamesJRH> dmwit: I think it's logarithmic.
15:01:53 <JamesJRH> (approx.)
15:02:18 <gnoi> Trying to understand how `zipWith (-) <*> tail :: [c] -> [c]` actually works. (<*>) :: f (a->b) -> f a -> f b. But zipWith (-) :: [c] -> [c] -> [c]
15:02:37 <gnoi> So how can it be applied as first argument to <*>?
15:02:52 <benmachine> gnoi: the short version is, f = ([c] ->), a = [c], b = [c]
15:02:58 <dmwit> Easy. Let "f = (->) [c]".
15:04:37 <hpaste> “_Mikey” pasted “escaping the monad” at http://hpaste.org/65534
15:04:43 <_Mikey> hey
15:05:00 <_Mikey> am I totally on the wrong path here?
15:05:15 <benmachine> _Mikey: what's choose?
15:05:20 <benmachine> oh
15:05:22 <benmachine> hmm
15:05:23 <_Mikey> it makes a Gen
15:05:28 <dmwit> _Mikey: Yes, you're on the wrong path.
15:05:31 <benmachine> your return type is wrong
15:05:34 <dmwit> You cannot escape from an arbitrary monad.
15:05:40 <_Mikey> oh
15:05:45 <benmachine> dmwit: that's not really what he's trying to do, to be fair
15:05:48 <gnoi> dmwit: so f (a->b) is [a] -> [b] -> [c] if f = [c] -> ?
15:05:55 <dmwit> I have no idea what he's trying to do.
15:05:57 <koala_bot> What does this mean: "Warning: changing directory causes all loaded modules to be unloaded, because the search path has changed."?
15:06:01 <_Mikey> is quickCheck ok with me returning monadic values
15:06:11 <benmachine> gnoi: no
15:06:12 <dmwit> But his title is "escaping the monad", and he's writing a type with no monads but that's implemented with "do" notation.
15:06:29 <benmachine> _Mikey: depends on which monad
15:06:33 <benmachine> _Mikey: if Gen then yes
15:06:42 <hpc> koala_bot: it means whatever you just did, you probably don't want to do it
15:06:47 <_Mikey> ok thanks benmachine
15:06:52 <koala_bot> all I did was load my file...
15:06:55 <hpc> oh
15:06:55 <gnoi> benmachine: but what?
15:07:01 <benmachine> _Mikey: I think! it turns out I don't actually have QC installed atm
15:07:07 <benmachine> gnoi: sorry, there's only one of me :P
15:07:10 <hpc> koala_bot: can you paste exactly how you did that?
15:07:13 <hpc> @where hpaste
15:07:13 <lambdabot> http://hpaste.org/
15:07:36 <benmachine> gnoi: if f = ([c] ->) then f (a -> b) is [c] -> a -> b
15:07:58 <hpaste> koala_bot pasted “Using the GUI load in WinGHCi” at http://hpaste.org/65535
15:08:09 <benmachine> gnoi: ([c] ->) isn't real haskell syntax, in haskell you'd say (->) [c],
15:08:23 <benmachine> but it's easier to read it the way I write it imo
15:08:46 <hpc> koala_bot: about what i expected - the warning is because you :cd'd
15:08:54 <hpc> koala_bot: imagine you were in c:/foo
15:09:02 <hpc> you imported module Bar
15:09:14 <hpc> then you cd'd to c:/schnoz
15:09:25 <hpc> it would unload Bar because you're in a different directory now
15:09:58 <koala_bot> The only thing I changed was I added an additional import. Why would the others work but not this one?
15:10:27 <benmachine> _Mikey: QuickCheck is happy to check anything in the Testable class; the key thing is there's an instance Testable prop => Testable (Gen prop)
15:10:49 <_Mikey> Ahh cool,
15:10:59 <_Mikey> I'm returning a Gen Bool now
15:11:02 <_Mikey> and it compiled
15:11:10 <_Mikey> but when I run the test Boom! errors
15:11:18 <_Mikey> about show suprisingly :s
15:11:29 <hpc> _Mikey: ambiguous occurrence?
15:12:22 <_Mikey> hpc, no just no instance for show.
15:12:25 <koala_bot> hpc: How do I fix this? I simply added the import to my file (amongst a few others that did not have this problem), and used the load file picker in the WinGHCi GUI
15:12:51 <_Mikey> hpc, did you write the haskell program coverage library?
15:13:07 <hpc> koala_bot: it's just a warning
15:13:35 <hpc> _Mikey: i wish; it's a shortening of an old nickname
15:13:54 <_Mikey> ohh, I would have had to buy you a beer if you did :p
15:13:55 <koala_bot> So I should just ignore it?
15:13:56 <hpc> koala_bot: it looks to me like your file loaded just fine
15:14:01 <hpc> _Mikey: in that case...
15:14:10 <_Mikey> :p
15:14:25 <hpc> koala_bot: yeah; all it means is if you had anything imported BEFORE you did the :cd, it might vanish
15:14:31 <hpc> but you didn't, so it's cool
15:14:39 <koala_bot> okie dokie. Thanks.
15:15:23 <hpc> _Mikey: i am currently working on getting lambdabot back to maintainability, so feel free to get me stuff for that ;)
15:15:52 <_Mikey> ahh thats a good cause right there!
15:16:32 <hpaste> “Eduardo León” pasted “Symbolic differentiation” at http://hpaste.org/65536
15:17:22 <Authoritarianism> Hello, I need some help.
15:18:42 <Authoritarianism> Is it necessary that every Haskell source code file contain a main function?
15:19:01 <jfhall> Authoritarianism: no
15:19:08 <rostayob> Authoritarianism: no. only the Main module needs to
15:19:23 <jfhall> Authoritarianism: only if you are creating an executable, then the main module needs it
15:19:25 <Authoritarianism> jfhall, rostayob: Then why does my paste not compile?
15:19:29 <hpc> Authoritarianism: you can run functions from files without main using ghci
15:19:38 <hpc> (and files with main, too)
15:19:39 <Authoritarianism> hpc: How?
15:19:42 <jfhall> Authoritarianism: what's your paste?
15:19:50 <Authoritarianism> http://hpaste.org/65536
15:19:53 <hpc> ghci Lib/LibraryFullOfStuff.hs
15:20:02 <hpc> λ> functionInTheLibrary 5
15:20:07 <hpc>   171.3
15:20:11 <Authoritarianism> hpc: Thanks!
15:20:26 <hpc> ghci is basically a giant IO do-block
15:20:32 <hpc> except for all the ways in which is isn't like one
15:20:36 <rostayob> it's GIANT
15:20:38 <Authoritarianism> lolwut
15:21:58 <hpc> Authoritarianism: basically, type an expression into ghci and it will execute it if it's an IO action
15:22:03 <hpc> or print it if it isn't
15:22:24 <hpc> if you do "foo <- ioAction", the result of the action is named foo
15:22:32 <jfhall> Authoritarianism: btw, your code loads in ghci fine.
15:22:48 <jfhall> Authoritarianism: you can also start ghci and call :load file
15:22:59 <Authoritarianism> jfhall: Nice.
15:23:07 <Authoritarianism> jfhall: Can I also unload files I am done with?
15:23:15 <hpc> yes
15:23:20 <hpc> type :h in ghci
15:23:28 <hpc> (and maybe scroll up a bit)
15:23:46 <hpc> ((it's a fair bit of text all at once))
15:24:18 <Authoritarianism> Wow, amazing.
15:24:29 <Authoritarianism> I did not even have to write any code converting Function to string!
15:24:32 <Authoritarianism> :D
15:24:50 <Authoritarianism> (Except adding "deriving (Show)" at the end of both Rotation and Function)
15:25:01 <Modius> I've been prodding at climbing mount Haskell on and off over the eons as though it were a greased icy cliff face . . . .  I believe "Learn you a haskell" to be by far the best noob starting point.
15:25:12 <hpc> Modius: indeed
15:25:28 <danharaj> My learning text was Gentle Introduction.
15:25:29 <hpc> (im not just saying that because i got the book for free)
15:25:32 <danharaj> (Spoilers it is not gentle).
15:25:37 <hpc> danharaj: lol
15:25:54 <danharaj> oh, also by working through the examples in TAPL.
15:26:14 <danharaj> So I grokked STLC and its extensions at the same time as Haskell.
15:26:19 <dbelange> Authoritarianism: http://www.iterasi.net/openviewer.aspx?sqrlitid=ixx7fcluvek_9lfolsxr_g
15:26:20 <hpc> Modius: i learned with a combination of LYAH, the wikibook, and assorted randomness from the haskell wiki
15:26:23 <hpc> @where wikibook
15:26:23 <lambdabot> http://en.wikibooks.org/wiki/Haskell
15:26:25 <hpc> @where wiki
15:26:25 <lambdabot> I know nothing about wiki.
15:26:30 <hpc> pah
15:26:30 <Cale> > until (\x -> x == x+1) (+1) 16000000 :: Float
15:26:32 <lambdabot>   1.6777216e7
15:26:50 <hpc> Cale: heh
15:27:29 <danharaj> There should be a contest to see who can show Floats are broken in the most flagrant way.
15:27:34 <danharaj> The Enum instance is banned.
15:27:42 <ksf_> Authoritarianism, now do recursive functions ;)
15:27:55 <Authoritarianism> ksf_: Like…?
15:28:05 <ksf_> > let x = x in x
15:28:05 <Authoritarianism> I think my "der" function is recursive.
15:28:10 <lambdabot>   mueval-core: Time limit exceeded
15:28:16 <Authoritarianism> ksf_: ???
15:28:17 <ksf_> nah, recursive Functions.
15:28:28 <Authoritarianism> ksf_: What happens when you do that?
15:28:29 <kaitocracy> what function names are valid in Haskell?
15:28:38 <ksf_> foo = Comp foo foo
15:29:09 <danharaj> Authoritarianism: Take your Function type and extend it to include recursive definitions.
15:29:10 <Authoritarianism> ksf_: That seems like a circular data structure.
15:29:15 <hpc> > floor (0 / 0) :: Integer -- danharaj
15:29:16 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
15:29:21 <ksf_> well, yes, it's recursive.
15:29:23 <Authoritarianism> danharaj: What do you mean?
15:29:50 <ksf_> you can use http://hackage.haskell.org/package/data-reify to break the loops and get an analysable graph.
15:29:52 <benmachine> kaitocracy: this is in the Report somewhere, but it's something like, any lowercase letter or an underscore followed by lowercase/uppercase/numbers or ' or _
15:30:10 <benmachine> kaitocracy: err, that is, it has to start with any lowercase letter or an underscore
15:30:15 <otc> What's a good functional programming exercise once you're done with learnyouahaskell?
15:30:23 <benmachine> kaitocracy: after which it can have lowercase/uppercase/numbers or ' or _
15:30:35 <benmachine> kaitocracy: and of course reserved words are not valid function names
15:30:35 <otc> I just did some basic dynamic programming thing.
15:30:37 <danharaj> Authoritarianism: Your Function type doesn't have recursion. An element of Function is just a tree of function calls.
15:30:37 <hpc> otc: write an irc bot, is what i did
15:30:48 <hpc> if you're creative enough you can get a lot of mileage out of it
15:30:56 <Authoritarianism> danharaj: That is right.
15:31:03 <benmachine> otc: project euler is a common one, but it's a very specific set of tasks
15:31:07 <kaitocracy> benmachine: there's got to be a page with the rules right?
15:31:16 <kaitocracy> benmachine: because I can't find it
15:31:26 <danharaj> Authoritarianism: So extend it with recursion!
15:31:29 <benmachine> kaitocracy: somewhere in here is the official version http://www.haskell.org/onlinereport/haskell2010/
15:31:30 <Authoritarianism> danharaj: I have absolutely no idea how to do that. :(
15:31:40 <kaitocracy> benmachine: oh thanks
15:31:45 <danharaj> Authoritarianism: That's the point, is it not? Find out :p
15:31:51 <kaitocracy> benmachine: ahh found it
15:33:10 <benmachine> otc: if you have a webhost, writing CGI scripts is a nice way to play with things
15:33:17 <benmachine> otc: I wrote one which rolls dice and records the results
15:33:24 <Authoritarianism> danharaj: I think a simple recursive function can be represented in terms of two cases: the terminating case, and the recursive case.
15:33:42 <Authoritarianism> danharaj: Although, well, that is the simple case.
15:33:49 <ksf_> all terminating ones can, in fact.
15:34:01 <ksf_> (you just have to use the recursive one smartly enough)
15:34:13 <ksf_> :t fix
15:34:14 <lambdabot> forall a. (a -> a) -> a
15:34:16 <ksf_> that's all you need.
15:34:23 <danharaj> @src fix
15:34:24 <lambdabot> fix f = let x = f x in x
15:34:28 <ksf_> > fix error
15:34:29 <danharaj> BEHOLD
15:34:29 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:34:33 <ksf_> see?
15:34:35 <Authoritarianism> ksf_: :O
15:34:39 <ksf_> it's an infinite chain of exceptions.
15:34:49 <Authoritarianism> ksf_: Yes, I see that.
15:34:49 <danharaj> Exceptions all the way down.
15:35:09 <benmachine> otc: also, writing parsers is really nice in haskell
15:35:16 <Authoritarianism> I guess in order to implement that, I have to read some theory.
15:35:19 <benmachine> otc: try to think of something you need parsed, and then parse it :P
15:35:22 * Authoritarianism has no formal background in CS.
15:35:51 <ksf_> that's no problem.
15:35:59 <ksf_> haskell is a formal background.
15:36:10 <Jafet> > fix $ error . (":-) "++)
15:36:12 <lambdabot>   "*Exception: :-) *Exception: :-) *Exception: :-) *Exception: :-) *Exception...
15:36:24 <Authoritarianism> :O
15:36:33 <JamesJRH> Hey, hpaste has reached the 65536 mark. :-)
15:36:38 <JamesJRH> > 2^2^2^2
15:36:39 <lambdabot>   65536
15:36:52 <Authoritarianism> Yay! That was my paste.
15:36:54 <rostayob> > also
15:36:55 <lambdabot>   Not in scope: `also'
15:36:57 <rostayob> > ((++" Batman!").take 47.cycle.show)(0/0)
15:36:59 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNa Batman!"
15:37:00 <rostayob> and
15:37:11 <JamesJRH> Authoritarianism: :-)
15:37:16 <dylukes> rostayob: You're a sick, sick, puppy
15:37:20 <dylukes> >_>
15:37:38 <dylukes> Why not just
15:37:41 <hpaste> hpc pasted “65537” at http://hpaste.org/65537
15:37:55 <rostayob> > stripPrefix "Rais" "Raisin Timberlake"
15:37:55 <danharaj> hahaha
15:37:56 <lambdabot>   Just "in Timberlake"
15:38:00 <Authoritarianism> lol
15:38:06 <dylukes> > ((++" Batman!") . take 20 . cycle . take 2 . show) (0/0)
15:38:08 <lambdabot>   "NaNaNaNaNaNaNaNaNaNa Batman!"
15:38:25 <zerax> cute
15:38:36 <dylukes> ((++" Batman!") . take 18 . cycle . take 2 . show) (0/0)
15:38:40 <dylukes> actually, that's correct.
15:38:45 <hpc> <3 watman
15:39:16 <dylukes> > ((++" Na na na naaaa!") . take 50 . cycle . take 2 . show) (0/0)
15:39:18 <lambdabot>  Terminated
15:39:37 <dylukes> @let pickett =  ((++" Na na na naaaa!") . take 30 . cycle . take 2 . show) (0/0)
15:39:39 <lambdabot>  Defined.
15:39:40 <dylukes> > pickett
15:39:42 <lambdabot>   "NaNaNaNaNaNaNaNaNaNaNaNaNaNaNa Na na na naaaa!"
15:39:52 <hpc> > length [1..100000] `seq` text "Terminated" -- did it finish? did it get terminated?
15:39:53 <lambdabot>   Terminated
15:40:02 <rostayob> who knows...
15:40:11 <benmachine> the latter
15:40:12 <benmachine> er
15:40:13 <benmachine> no
15:40:13 <hpc> ^
15:40:14 <benmachine> former
15:40:15 <dylukes> > length [1..100000] `seq` text ":D" -- did it finish? did it get terminated?
15:40:17 <benmachine> because three spaces
15:40:17 <lambdabot>   :D
15:40:20 <hpc> 18:38 < lambdabot>  Terminated
15:40:24 <hpc> 18:38 < lambdabot>   Terminated
15:40:30 <hpc> it finished
15:40:30 <benmachine> :>
15:40:41 <rostayob> the other thing that makes me laugh is pl/unpl
15:40:52 <dylukes> It's good for obfuscation.
15:40:59 <rostayob> > pl \f g (a,b) -> (f a, g b)
15:41:00 <lambdabot>   <no location info>: parse error on input `\'
15:41:03 <dylukes> @. pl unpl ((++" Batman!") . take 18 . cycle . take 2 . show) (0/0)
15:41:03 <lambdabot> take 18 (cycle (take 2 (show (0 / 0)))) ++ " Batman!"
15:41:05 <rostayob> @pl \f g (a,b) -> (f a, g b)
15:41:05 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
15:41:15 <rostayob> @unpl  flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
15:41:16 <lambdabot> (\ aa f -> (\ p w -> ((,)) (aa (fst p)) (f w)) >>= \ af -> snd >>= \ ae -> return (af ae))
15:41:21 <rostayob> yay.
15:41:23 <dylukes> @. unpl pl \f g (a,b) -> (f a, g b)
15:41:24 <lambdabot> (\ aa f -> (\ p w -> ((,)) (aa (fst p)) (f w)) >>= \ af -> snd >>= \ ae -> return (af ae))
15:41:26 <dylukes> Easier form.
15:41:34 <rostayob> yeah much better
15:41:34 <hpc> @@ unpl pl \x y z -> z y x
15:41:34 <lambdabot>  unpl pl \x y z -> z y x
15:41:41 <hpc> @. unpl pl \x y z -> z y x
15:41:42 <lambdabot> (\ b c f -> f c b)
15:41:42 <dylukes> @@ unpl pl (\ aa f -> (\ p w -> ((,)) (aa (fst p)) (f w)) >>= \ af -> snd >>= \ ae -> return (af ae))
15:41:42 <lambdabot>  unpl pl (\ aa f -> (\ p w -> ((,)) (aa (fst p)) (f w)) >>= \ af -> snd >>= \ ae -> return (af ae))
15:41:49 <dylukes> @@ unpl pl (\ b c f -> f c b)
15:41:49 <dylukes> lambdabot:
15:41:49 <dylukes> unpl pl (\ aa f -> (\ p w -> ((,)) (aa (fst p)) (f w)) >>= \ af -> snd >>= \ ae -> return (af ae))
15:41:49 <lambdabot>  unpl pl (\ b c f -> f c b)
15:41:55 <hpc> @. pl unpl \x y z -> z y x
15:41:55 <lambdabot> flip (flip . flip id)
15:42:03 <dylukes> agh stop it
15:42:05 <hpc> wow, lambdabot composes backwards
15:42:12 <Jafet> @yow
15:42:12 <lambdabot> Couldn't find fortune file
15:42:21 <dylukes> @quote Jafet
15:42:21 <lambdabot> Jafet says: <Jafet> Wouldn't that violate the laws of thermodynamics? <ski> not if you indent the `|' properly
15:42:26 <dylukes> @quote hpc
15:42:26 <lambdabot> hpc says: appEndo sounds like a harry potter spell
15:42:31 <dylukes> @quote dylukes
15:42:31 <lambdabot> dylukes says: In 200 years the field of computing will be dominated by terms such as curry/korma/paneer/masala, etc... it will be utterly impossible to differentiate a CS conference and an indian
15:42:32 <lambdabot> buffet.
15:42:38 <dylukes> what the fuck
15:43:19 <danharaj> :3
15:43:27 <hpc> @quote hpc
15:43:28 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
15:43:31 <Jafet> @quote integerToBreakfast
15:43:32 <lambdabot> integerToBreakfast says: = (["Cornflakes", "Strawberry jam toast", "Grapefruit", "Cup of tea and a biscuit, gotta dash", "Bacon, eggs, toast, tomato and mushroom. You deserve it", "Waffles", "
15:43:32 <lambdabot> Porridge of some description", "Orange juice and muffins", "Apples, pears, mango and kiwi", "A selection of cold meats with crisp bread", "Headache pills and water", "Leftover pizza", "Leftover
15:43:32 <lambdabot> vindaloo curry"] !!)
15:43:34 <rostayob> @quote rostayob
15:43:35 <lambdabot> merijn says: rostayob: I used to be a functional programmer like you, but then I took an UML diagram to the knee >.>
15:43:41 <rostayob> oh.
15:43:52 <hpc> @quote internet
15:43:52 <lambdabot> pumpkin says: makes the next internet hit video, 2 natural transformations, 1 functor
15:44:00 <rostayob> @quote potato
15:44:01 <lambdabot> No quotes match. I am sorry.
15:44:05 <hpc> @quote news
15:44:05 <lambdabot> roconnor says: <roconnor> is NAN a valid value to put on my taxes? <newsham> i think IRS wants fixed-point  <roconnor> this is california
15:44:25 <dylukes> <3
15:44:26 <danharaj> @quote quote
15:44:26 <lambdabot> command says: lambdabot will say 'it is forever etched into my memory' and then forget the quote by tomorrow.
15:44:29 <dylukes> Welcome to USB 3.0 hell: http://cl.ly/F8WU
15:44:31 <dylukes> USB 2.0 *
15:44:32 <hpc> lambdabot's qdb is lacking in the "random crap" department
15:44:40 <rostayob> @quote random.crap
15:44:41 <dylukes> my Firewire 800 cable is apparently faulty.
15:44:41 <lambdabot> No quotes match. You speak an infinite deal of nothing
15:44:45 <_Mikey> omg
15:44:52 <exFalso1> @quote fibonacci
15:44:53 <lambdabot> Catfish_Man says: Well, at a first approximation Haskell is an overpowered DSL for generating Fibonacci numbers.
15:44:53 <_Mikey> that awesome moment when your code compiles
15:45:03 <Saizan> dylukes: btw, this is not -blah
15:45:04 <_Mikey> and all your tests run and complete
15:45:13 <dylukes> rofl, I wasn't aware Catfish_Man even came in here.
15:45:20 * hackagebot vector-conduit 0.2.1.0 - Conduit utilities for vectors  http://hackage.haskell.org/package/vector-conduit-0.2.1.0 (JaredHance)
15:45:25 <dylukes> @quote Catfish_Man
15:45:26 <lambdabot> Catfish_Man says: Well, at a first approximation Haskell is an overpowered DSL for generating Fibonacci numbers.
15:45:28 <dylukes> @quote mikeash
15:45:29 <lambdabot> mikeash says: you may have noticed that templates being turing complete theoretically allows you to add any language capability to C++.... so did the boost guys.
15:45:33 <dylukes> amusing.
15:45:42 <dylukes> @quote jweinberg
15:45:43 <lambdabot> No quotes match. There are some things that I just don't know.
15:46:07 <exFalso1> @quote hylomorphism
15:46:08 <lambdabot> edwardk says: i just got bitten in the ass by the lack of a notion of commutative monad for a in a toy kind of memoizing hylomorphism that now has way too much 'ordering' baked into it
15:46:32 <dylukes> If you have ANY idea what edwardk is talking about
15:46:34 <dylukes> 1) you're insane
15:46:42 <danharaj> 2) you are edwardk
15:46:46 <hpc> 3) both
15:46:55 <dylukes> 2) Galois/Clear-whateverplacekmcandedwardkwork would like to have you over for a job interview.
15:46:55 <exFalso1> haha
15:46:58 <downloader> I am trying to use BEncode to find the error in a malformed bittorrent data. Someone in this channel had told me that "import qualified Data.ByteString as B ; main = B.getContents >>= print . bRead s" should work but I am getting a type error since bRead returns Maybe BEncode. I am a haskell novice and I could use a hand determining how to fix the problem.
15:47:05 <rostayob> who hasn't bitten in the ass by the lack of notion of communative monad etc.
15:47:56 <Saizan> kmc and edwardk work at the same place now?
15:48:06 <dylukes> er, was that copumpkin and kmc?...
15:48:08 <rostayob> downloader: the Maybe type of that function indicates that the parsing might or might not succeed. you need to do something in the case it doesn't succeed.
15:48:21 <dylukes> I'm pretty sure copumpkin, dolio and edward are in the same place in Bosto.
15:48:32 <Saizan> yeah
15:48:36 <rostayob> clarifi
15:48:41 <dylukes> yeah that place
15:48:44 <hpc> downloader: bRead :: ByteString -> Maybe BEncode?
15:49:04 <exFalso1> @hoogle bRead
15:49:04 <lambdabot> No results found
15:49:07 <hpc> downloader: "main = B.getContents >>= (print . bRead)" -- should work, i think
15:49:20 <Saizan> maybe BEncode is not an instance of Show?
15:49:27 <hpc> or that
15:49:37 <downloader> hpc: Yes, but lazy bytestring
15:49:38 <Saizan> downloader: what is the error you get?
15:49:40 <hpc> downloader: can you hpaste the whole thing, and errors?
15:49:45 <hpc> @where hpaste
15:49:45 <lambdabot> http://hpaste.org/
15:49:45 <downloader> yes,
15:50:17 <exFalso1> import Data.ByteString.Lazy as B for lazy bss
15:50:20 * hackagebot gps 1.0.3 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-1.0.3 (ThomasDuBuisson)
15:50:22 * hackagebot osm-download 0.3.3 - Download Open Street Map tiles  http://hackage.haskell.org/package/osm-download-0.3.3 (ThomasDuBuisson)
15:50:23 <hpaste> downloader pasted “bencode” at http://hpaste.org/65539
15:50:26 <dylukes> Am I the only one who's oddly calmed by the hum of server rooms and such?
15:50:45 <downloader> by calmed do you mean deafened
15:50:46 <downloader> ?
15:50:52 <dylukes> well, smaller quieter ones.
15:50:57 <dylukes> where it actually is a hum.
15:50:59 <hpc> haha
15:51:02 <dylukes> and not a deafening drone.
15:51:07 <exFalso1> downloader: you don't need the s
15:51:36 <downloader> exFalso1: The actual string will be much longer, I think it will be clearer
15:51:49 <rwbarton> downloader: your program is a bit undecided about what it's doing
15:52:05 <rwbarton> B.getContents is for reading from stdin, but then you have a string literal, what do you want to do?
15:52:07 <exFalso1> downloader: you can either use that literal string or the input from stdin
15:52:13 <exFalso1> not both
15:52:35 * exFalso1 needs to type faster
15:52:55 <rwbarton> if you want to read from stdin, delete everything after bRead
15:53:21 <downloader> And if I want to use s?
15:53:29 <exFalso1> then dont use the getContents
15:53:41 <downloader> main = bRead >>= bRead s?
15:53:47 <downloader> main = print >>= bRead s?
15:54:00 <exFalso1> print $ bRead s
15:54:33 <exFalso1> :t (>>=)
15:54:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:54:36 <koala_bot> Is there a function in Haskell which will output lists in a newline format, similar to php's print_r() ?
15:54:59 <exFalso1> not sure about print_r but try unlines
15:55:04 <exFalso1> :t unlines
15:55:05 <lambdabot> [String] -> String
15:55:11 <parcs`> :t mapM_ print
15:55:11 <lambdabot> forall a. (Show a) => [a] -> IO ()
15:55:13 <geekosaur> don't understand "newline format"
15:55:22 <geekosaur> mapM_ putStrLn?
16:01:43 <danharaj> :q
16:01:44 <danharaj> :o
16:01:55 <danharaj> I made ghci misplace an object file.
16:02:37 <exFalso1> it will compile if it cant find the object file
16:02:59 <danharaj> <interactive session>:     cannot find object file for module `main:GUI.Menu.View.Spinner'     while linking an interpreted expression
16:02:59 <exFalso1> and put it in cwd iirc
16:05:21 * hackagebot network-data 0.2.1 - Library for network data structures (ex: ip/udp/tcp headers and helper functions)  http://hackage.haskell.org/package/network-data-0.2.1 (ThomasDuBuisson)
16:22:47 <Authoritarianism> Hello. One question.
16:23:41 <Authoritarianism> In my paste (http://hpaste.org/65536), I want to change Function so that the Const constructor takes any Floating value, not just a double.
16:23:44 <Authoritarianism> How do I do that?
16:25:11 <dmwit> Authoritarianism: You don't.
16:25:18 <dmwit> Authoritarianism: Instead, you write something like
16:25:24 <dmwit> data Function a = Const a | ...
16:25:42 <dmwit> Then, as necessary, you write functions with type Floating a => ... Function a ...
16:25:55 <Authoritarianism> dmwit: I tried that, but I got an error.
16:26:02 <geekosaur> (well.  there are GADTs)
16:26:07 <dmwit> Perhaps you'd better show what you tried and what error you got, then.
16:26:22 <dmwit> geekosaur: Let him at least learn H98 before you throw him in the deep end.
16:26:50 <Authoritarianism> dmwit: Oh, dang, I am dumb!
16:26:53 <dmwit> From the code, it looks pretty clear that GADTs are an enticing but incorrect direction to take his efforts.
16:26:54 <Authoritarianism> dmwit: Forget it, forget it.
16:28:05 <Authoritarianism> dmwit: I forgot to update the Comp, Prod and Sum constructors.
16:28:13 <dmwit> Ah, yup. =)
16:28:14 <Authoritarianism> dmwit to Comp (Function a) (Function a), etc.
16:28:17 <hoarser2> Newbie question...
16:28:33 <Authoritarianism> Dang, this one was supposed to be easy.
16:28:49 <hoarser2> It is said that Haskell's IO monad preserves the language's purity, but separating out effectful computations.
16:28:54 <_Mikey> what is the best way to express x is not an empty list
16:29:05 <_Mikey> x /= []
16:29:08 <_Mikey> ?
16:29:15 <dmwit> _Mikey: not (null x)
16:29:17 <Cale> hoarser2: sorta kinda true
16:29:26 <hoarser2> But exactly how does it do this?  Is it because a named class ("IO Monad") allows human beings to make the separation, conceptually?
16:29:31 <_Mikey> dmwit, thanks!
16:29:47 <dmwit> _Mikey: (Or just by pattern matching, of course.)
16:29:50 <hoarser2> Or is it because the logic of the monad class actually creates the separation?
16:29:54 <Cale> hoarser2: Ignore the fact that it's a monad for now, that just says something about the structure of the API for combining and composing values of that type
16:30:13 <Peaker> hoarser2: the fact that IO is a "monad" and all the "monad" talk in this topic just confuses matter, IMO.  The idea is simply separation of mathematical functions (a->b) from procedures with effects (IO a)
16:30:21 <koala_bot> does anyone know how I might access the attribute values of a Tag in tagsoup?
16:30:36 <Cale> hoarser2: What's more important is that values of type (IO t) are just concrete representations of effectful things (including input and output) which can be done to produce a value of type t
16:31:07 <hoarser2> Peaker: so you're saying the separation is not so much performed mechanically by the logic, but lies merely in a different naming.
16:31:15 <dmwit> koala_bot: It's the second field of the TagOpen constructor.
16:31:28 <exFalso1> hoarser2: for now think of it as a way to encapsulate side-effecting code which cannot be embedded in pure code
16:31:38 <kfish> koala_bot, http://blog.kfish.org/2007/06/review-tagsoup.html
16:31:39 <Peaker> hoarser2: the separation is having different types for the different things -- it's a different "mechanical logic" if I understand you correctly
16:32:03 <Peaker> hoarser2: most languages have "functions" which are really procedures that also have data inputs (so they are functions+procedures at the same time)
16:32:13 <Cale> hoarser2: Well, the function type in Haskell consists of only pure functions -- ones which when evaluated don't "do" anything except to produce a value as their result.
16:32:37 <Peaker> hoarser2: Haskell's functions are mathematical functions, and it has procedures too, and the two constructs are both used to form Haskell programs
16:32:54 <Cale> hoarser2: We use functions to manipulate (still pure) descriptions of I/O to be performed, called IO actions
16:33:07 <koala_bot> kfish: I see ways of partitioning a site or grabbing tags based on those attributes, but I sort of want to do the opposite. Given a list of Tags, I want to then go through a list their attribute's values
16:33:25 <hoarser2> I guess I can ask it another way: does Haskell permit mutation?
16:33:29 <koala_bot> dmwit: I'm not sure what that means for me
16:33:32 <Cale> hoarser2: and then those IO actions, or more specifically, the one IO action designated as 'main', actually gets executed.
16:33:40 <exFalso1> hoarser2: yes and no :)
16:33:41 <Cale> hoarser2: and execution is effectful
16:33:55 <exFalso1> hoarser2: it allows the -description- of mutation
16:33:59 <Peaker> hoarser2: yes, in procedures, no in functions
16:34:03 <Cale> There are two interleaved processes which go on when a Haskell program runs
16:34:09 <Cale> execution, which has effects
16:34:21 <hoarser2> Peaker: how does one define a procedure, then?  And which Haskell command performs mutation?
16:34:22 <dmwit> koala_bot: You pattern match on a tag. If it's a TagOpen, the pattern brings the attributes into scope.
16:34:22 <Authoritarianism> Hello. How do I place restrictions on the parameters of a type constructor?
16:34:27 <dmwit> koala_bot: There's not much more to it.
16:34:32 <Cale> and evaluation, which doesn't (it simply means computing the values of expressions)
16:34:38 <exFalso1> :t newIORef
16:34:39 <lambdabot> Not in scope: `newIORef'
16:34:45 <Peaker> hoarser2: The "IO" type is the type of procedures. You define procedures by combining existing procedures with operators that build larger procedures from small ones
16:34:46 <Cale> hoarser2: do you follow what I'm saying?
16:35:05 <kfish> koala_bot, f (TagOpen tag attrs) = print attrs
16:35:08 <hoarser2> Cale: I think so.
16:35:08 <exFalso1> :i IORef
16:35:20 <exFalso1> whah
16:35:26 <dmwit> koala_bot: Here's a simple example I whipped up for a related StackOverflow question: http://stackoverflow.com/questions/6918069/how-do-reimplement-this-python-xml-parsing-function-in-haskell/6918258#6918258
16:35:26 <Cale> hoarser2: So when a Haskell program runs, the IO action called main is first evaluated enough to determine what it says to do, and then it is executed.
16:35:26 <koala_bot> Ah
16:35:32 <Mathnerd314> exFalso1: lambdabot isn't GHCi
16:35:39 <exFalso1> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
16:35:49 <Peaker> hoarser2: so you can define a procedure like:   echoTwice = getLine >>= (\line -> putStr line >> putStr line)   (<-- this is ugly syntax, there is sugar to make it nicer, but it would only obfuscate the point in this case)
16:35:51 <hoarser2> Cale: that last part confused me.
16:36:25 <koala_bot> I think that'll get me goin :) Thanks you guys
16:36:31 <Cale> hoarser2: okay
16:36:39 <hoarser2> Cale: are you able to relate what you're saying to Peaker's 'echoTwice' example?
16:36:39 <exFalso1> hoarser2: check out the link above for mutation
16:36:40 <Cale> hoarser2: Well, let's just look at some examples of IO actions
16:36:41 <Peaker> hoarser2: so basically we take existing procedures ("getLine" and "putStr")  and compose them into a larger procedure using the >>= and >> operators
16:37:07 <Cale> hoarser2: oh, okay
16:37:12 <hoarser2> Peaker: that I understand.  But I'm not clear about Cale's distinction between 'procedure' and 'function'.
16:37:17 <hoarser2> (Of course I know what a pure function is.)
16:37:34 <hoarser2> Rather, I'm not clear about Cale's distinction between 'exectuion' and 'evaluation.'
16:37:44 <Cale> hoarser2: A function takes values in some domain, and produces corresponding values in some codomain, and that is all.
16:37:51 <hoarser2> Cale: fine so far.
16:37:52 <exFalso1> hoarser2: functions are referentially transparent, that is replacing the function call with the value doesn't change the program
16:37:56 <Peaker> hoarser2: a procedure is a recipe for generating a value with effects... A function is a pure mathematical function.. Often the two are composed to generate a parameterized procedure:
16:37:59 <hoarser2> exFalso1: yes, fine.
16:38:03 <Cale> Functions cannot read from the keyboard or write to files or do network stuff, or mutate memory
16:38:17 <hoarser2> Peaker: I think you just began to contradict yourself?
16:38:23 <Cale> They simply define a way to compute some values from others
16:38:26 <Cale> hoarser2: okay?
16:38:33 <Peaker> hoarser2: what contradiction do you see?
16:38:42 <hoarser2> Cale: yes.  But you lost me when you said Haskell does some evaluating first, and then does some executing.
16:38:52 <exFalso1> you can embed functions in procedures, not the other way around
16:39:08 <Cale> hoarser2: IO actions, or what Peaker has been calling procedures, are descriptions of "stuff to do", which can include all of those things I mentioned
16:39:09 <hoarser2> Peaker: to me it sounds strange to say that the composition of two functions is a procedure.
16:39:09 <Peaker> hoarser2: for example, "putStr" is a pure mathematical function from a String to a procedure that has the effect of printing the string...  putStr :: String -> IO ()       (pure function from String to procedure yielding unit)
16:39:32 <Peaker> hoarser2: the composition of a function and a procedure (e.g: "String -> IO ()") is a parameterized procedure.. I didn't say composition of two functions is a procedure
16:39:43 <Cale> hoarser2: Well, evaluation means turning an expression into a constructor value which can be pattern matched on
16:39:45 <hoarser2> Peaker: Ah, ok.
16:39:56 <Authoritarianism> Hello. Is it possible to restrict the parameters of a type constructor, and, if so, how?
16:40:05 <Peaker> hoarser2: do you know Python or C?
16:40:17 <hoarser2> Peaker: of course :)
16:40:26 <exFalso1> Authoritarianism: yes, with explicit kinding
16:40:29 <hoarser2> ...though those are two very different languages.
16:40:44 <Cale> hoarser2: Haskell makes them look similar ;)
16:40:45 <Authoritarianism> exFalso1: How does that work?
16:40:49 <exFalso1> however the kind system is not really powerful to express many properties
16:40:55 <hoarser2> Cale: indeed!
16:41:11 <Peaker> hoarser2: in C,  the function:   void f(int x)    takes an "x" and then returns what effects to perform given that x.  In Haskell that is expressed explicitly:   f :: Int -> IO ()
16:41:28 <exFalso1> Authoritarianism: for example
16:41:28 <exFalso1> type Asd (a :: * -> *) = a Int
16:41:31 <Peaker> hoarser2: well, in C you don't really view it as "returning" the effects :) But In Haskell you do
16:41:33 <hoarser2> Peaker: OK.
16:41:36 <exFalso1> puts a restriction on a
16:41:59 <Cale> actually, I think Peaker's statements might confuse things a little here
16:42:06 <exFalso1> if you enable DataKinds (ghc 7.4+) then you can define your own kinds
16:42:08 <hoarser2> Peaker & Cale: all good so far.  But I'm trying to understand why evaluation is said to happen _before_ execution.
16:42:30 <Cale> because in C, there's no way to take the effects computed by f and work with them without immediately making them occur
16:42:32 <Authoritarianism> exFalso1: What I want to do is "data Function a = …" where a must always be an instance of Floating.
16:42:33 <Cale> they happen immediately
16:42:38 <Cale> not in a deferred fashion
16:42:53 <Cale> A value of type IO t just *describes* some stuff which could be done
16:42:53 <hoarser2> Cale: by 'deferred' do you mean 'lazy'?
16:42:55 <Cale> no
16:43:05 <Cale> lazy has a technical meaning related to evaluation
16:43:10 <hoarser2> yes, I know.
16:43:12 <exFalso1> Authoritarianism: you can do something similar
16:43:16 <Cale> and this is more about execution, which is separate from evaluation
16:43:20 <Authoritarianism> exFalso1: How?
16:43:24 <exFalso1> you can put a restriction on the -constructors-
16:43:52 <Cale> IO actions are never* executed during evaluation of an expression
16:44:03 <exFalso1> however, it wont change the fact that you have to put the context in front of every function that uses taht type
16:44:22 <Cale> (* some low-level primitives that you shouldn't use notwithstanding)
16:44:24 <Authoritarianism> exFalso1: Do you mean I place a restriction in the data constructors?
16:44:44 <hoarser2> Cale: and this is because they are forced to happen in a 'do' block?
16:44:49 <mauke> hoarser2: no
16:44:54 <exFalso1> ghc disabled that feature by default, there is a flag give me a sec
16:44:55 <mauke> hoarser2: actions aren't executed in a do block
16:44:58 <Cale> hoarser2: do-blocks are a way to take multiple actions and glue them together into a larger one
16:45:26 <Authoritarianism> exFalso1: Okay.
16:45:28 <exFalso1> Authoritarianism: DatatypeContexts
16:45:30 <Cale> For example,  getLine :: IO String, and  putStrLn :: String -> IO ()  and we have  (do x <- getLine; putStrLn x) :: IO ()
16:45:35 <exFalso1> with this you can say
16:45:36 <hoarser2> If you're saying that something like putstrLn happens 'atomically', without overlapping with neighboring evaluations, then ... isn't that obvious?
16:45:51 <exFalso1> data (SomeClass a) => Type a = Constructor a
16:46:01 <exFalso1> however this is not recommended
16:46:09 <Authoritarianism> exFalso1: Oh.
16:46:09 <Cale> There's a difference between *finding out that we're going to print something on the screen*, and *actually printing it on the screen*
16:46:14 <hoarser2> Maybe I should spend some time reading a good explanation somewhere?
16:46:22 <mauke> hoarser2: putStrLn doesn't "happen"; it's just a function
16:46:25 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
16:46:29 <Authoritarianism> exFalso1: Why is it not recommended?
16:46:32 <exFalso1> it will behave the same as before
16:46:43 <hoarser2> hmmm
16:46:58 <exFalso1> you can still give a type signature like (Type Int) where Int is not an instance of SomeClass
16:46:58 <Cale> A value of type IO a is a thing which if executed would produce a value of type a
16:47:13 <mauke> the critical bit is that you can't execute stuff
16:47:19 <Cale> and may also describe some effects to be performed during that execution
16:47:19 <Peaker> hoarser2: putStrLn is a function that takes a String, and returns (without printing anything!) a recipe/procedure that *explains* how to print that String. You have to actually execute that explanation for anything to be printed. This execution phase is separate from the "evaluation" (computation) phase
16:47:28 <exFalso1> it only says that you cannot -construct- Type with Constructor unless a is SomeClass
16:47:41 <hoarser2> Cale: again I sense that laziness is at play here.  After all, why else would type IO a not mean that the thing has already executed?
16:47:54 <Cale> hoarser2: Laziness is about the order in which expressions are evaluated
16:47:59 <mauke> hoarser2: laziness is irrelevant
16:48:00 <Authoritarianism> exFalso1: Anyway, the syntax you gave me worked fine! Thanks!
16:48:02 <exFalso1> which means that the class contexts that i assume you wanted to get rid of will stay :)
16:48:03 <Cale> hoarser2: and has nothing to do with this
16:48:08 <mauke> hoarser2: IO means what it means because that's how the library defines it
16:48:35 <Cale> hoarser2: You can think of a value of type IO a as being internally represented as the source code of a C program for computing a value of type a
16:48:46 <mauke> hoarser2: if it had already been executed, you'd have an 'a', not an 'IO a'
16:48:49 <Cale> hoarser2: and do-notation is a syntax sugar for gluing C programs together
16:49:14 <Cale> hoarser2: and evaluating the IO action doesn't cause those programs to run any more than opening the source code in a text editor would cause the program to run
16:49:34 <Peaker> evaluating an IO action is more like generating a .c file :)
16:49:36 <mauke> I think "evaluating the IO action" is misleading words and also a no-op
16:49:41 <hoarser2> Then at exactly what point does the action get triggered?
16:49:51 <mauke> hoarser2: from the point of view of the haskell code: never
16:50:02 <Cale> hoarser2: In a compiled Haskell program, the special IO action called main is executed
16:50:14 <Cale> hoarser2: and in turn, it will be built up from other IO actions
16:50:51 <Cale> hoarser2: on the ghci commandline, you can also directly type in an IO action, and ghci will notice that it's an IO action and execute it for you
16:50:55 <hoarser2> Can we step through a trivial effectful program in real time?
16:51:00 <Cale> okay
16:51:07 <hoarser2> I'm at the ghci repl.
16:51:14 <hoarser2> I say 'getLine'
16:51:26 <Cale> okay
16:51:31 <hoarser2> it has type IO String
16:51:35 <Cale> mhm
16:51:45 <ben> the repl is basically cheating in order to be a repl
16:51:49 <hoarser2> When I hit return, Haskell evaluates 'getLine' to a value of type IO String.
16:51:50 <Cale> that means that if we execute it, it'll do some stuff and have a String result
16:51:54 <Cale> yep
16:52:07 <Cale> and then it actually executes the IO String that it computed
16:52:10 <hoarser2> Cale: yes, but at exactly which point does the input from the keyboard get read?
16:52:16 <hoarser2> which point in time?
16:52:16 <Cale> during the execution
16:52:29 <hoarser2> But this is a contradiction.
16:52:31 <mauke> hoarser2: "evaluating getLine" isn't much real work; it's a constant
16:52:37 <hoarser2> You just said that execution and evaluation are disjoint.
16:52:48 <exFalso1> hoarser2: yes, ghci cheats:)
16:52:49 <Cale> hoarser2: well, they're interleaved
16:52:59 <Cale> exFalso1: I don't want to talk about how GHC cheats :)
16:53:02 <mauke> hoarser2: ghci automatically executes IO actions instead of trying to print them like other values
16:53:04 <hoarser2> Cale: ok, but you all said above that the interleaving does *not* happen.
16:53:24 <ben> mauke: Are we pretending it's a name for some sort of IO value constructor?
16:53:25 <Cale> hoarser2: Are you familiar with algebraic datatypes yet?
16:53:26 <Peaker> hoarser2: ghci is somewhat magical -- it evaluates whatever you feed it, and then if the result of that evaluation is of type "IO a", then it also executes that IO action.  evaluation, then execution.
16:53:33 <mauke> ben: no
16:53:38 <Cale> hoarser2: or GADTs (if I'm extremely lucky...)
16:53:38 <hoarser2> Cale: of course, I've been writing lots of Haskell
16:53:40 <Cale> okay
16:53:54 <hoarser2> Peaker: you're beginning to shed some light.
16:53:54 <Cale> So imagine that IO is internally like this:
16:53:58 <Cale> data IO a where
16:54:03 <Cale>   Return :: a -> IO a
16:54:12 <Cale>   Bind :: IO a -> (a -> IO b) -> IO b
16:54:13 <Peaker> hoarser2: the execution of the IO action might actually execute multiple actions inside it -- which are glued with pure functions in between, so between executions, you'll get more evaluation, that's why execution and evaluation are interleaved
16:54:17 <exFalso1> hoarser2: ghci does different things depending on whether you want to evaluate a pure computation or an IO action
16:54:17 <Cale>   GetChar :: IO Char
16:54:21 <hoarser2> Cale: do you mean 'class' rather than 'data'?
16:54:24 <Cale>   PutChar :: Char -> IO ()
16:54:30 <exFalso1> hmm i think too many of us are trying to explain
16:54:33 <benmachine> hoarser2: no, this is a GADT
16:54:35 <Cale> hoarser2: no, I want to use the GADT extension
16:54:37 <Peaker> Cale: I don't think he knows GADTs yet
16:54:40 <Cale> hoarser2: So these are data constructors
16:54:50 <Cale> hoarser2: and I'm saying exactly what the types of the data constructors are
16:55:01 <Cale> and then we can build a data value like...
16:55:04 <hoarser2> Cale: fine so far.  It's just a monad.
16:55:05 <exFalso1> why do you bring up gadts
16:55:21 <exFalso1> hoarser2: ah you know about monads!
16:55:31 <exFalso1> yeah IO is a monad
16:55:33 <Peaker> hoarser2: an IO action may be some primitive in a library, or it may be a composition of "action, function, action"  (execute first, process result with function, execute action that returned from function)
16:55:35 <Cale> Bind GetChar (\c -> Bind GetChar (\d -> Return [c,d]))
16:55:45 <Cale> hoarser2: see how that's just a value?
16:56:07 <Cale> GetChar doesn't intrinsically have anything to do with the keyboard, it's just a pure value
16:56:19 <Peaker> Cale: he said he was a newbie, that syntax probably takes some explanation
16:56:24 <Cale> okay
16:56:31 <hoarser2> Cale: it's a monadic value.
16:56:34 <Cale> hoarser2: nope!
16:56:41 <Cale> because we haven't defined a Monad instance yet
16:56:52 <Cale> Just a datatype with some data constructors
16:56:55 <ben> But it says Bind and Return right there ;)
16:56:58 <Cale> hehe
16:57:09 <Cale> yeah, the manner in which to make this into a monad is semi-obvious
16:57:11 <hoarser2> You're just doing getChar >>= (\c -> getChar >>= (\d return [c,d]))
16:57:15 <mauke> hoarser2: no
16:57:27 <Cale> hoarser2: yeah, but I'm uppercasing some letters and it makes a big difference
16:57:34 <mauke> the point is that this is all just a normal Haskell data structure
16:57:36 <Cale> Because now we can pattern match on those values
16:57:44 <mauke> no IO, no monad interface
16:57:46 <Cale> and you can see that this is just a normal datastructure
16:58:00 <hoarser2> Cale & mauke: ok, I'll pretend it's not a monadic value. Please continue.
16:58:12 <mauke> you don't have to pretend. it isn't.
16:58:20 <hoarser2> Understood.
16:58:38 <hoarser2> What you have is a value constructor, Return, that produced Return [c,d]. Fine.
16:59:11 <Peaker> in Python:  class Bind: def __init__(self, action, compute_next_action): ...self.x=x boilerplate here..   ;   class Return: def __init__(self, x): self.x=x    class GetChar: pass     Bind(GetChar(), lambda c: Bind(GetChar(), lambda d: Return([c,d])))
16:59:13 <hoarser2> So now we pattern mathc.
16:59:26 <hoarser2> Argh!  Don't show me Python!
16:59:32 <exFalso1> +
16:59:36 <hoarser2> It is an abomination!
16:59:43 <hoarser2> (j/k)
16:59:47 <mauke> doesn't even look like a helpful abomination
17:00:02 <ben> But we aren't that far, it's still basically the Bind constructor that has a GetChar constructor and some lambda in its fields
17:00:11 <hoarser2> Anyway, so we pattern match on the constructors of your IO GADT.
17:00:26 <Peaker> mauke: I think it can be helpful because learning a very foreign syntax and foreign concepts in the same time may be hard -- and it seemed like the point not getting across was that it was just a data structure
17:00:34 <hoarser2> The point is that I feel we're dodging the issue: what is GetChar, and when does it read from the keyboard?
17:00:34 <Peaker> hoarser2: we didn't pattern match yet -- we just built a value
17:00:37 <mauke> Peaker: your code makes it worse
17:00:45 <mauke> hoarser2: it doesn't read from the keyboard
17:00:46 <Peaker> mauke: why?
17:01:07 <hoarser2> mauke: then please explain to me when/why/how the keyboard is actually read :)
17:01:09 <mauke> Peaker: because python is foreign syntax to me and python can do I/O anywhere
17:01:11 <mauke> hoarser2: it isn't
17:01:18 <hoarser2> oh for heaven's sake...
17:01:18 <mauke> Peaker: even in the middle of a class definition
17:01:21 <hoarser2> ;)
17:01:23 <Peaker> mauke: but he said he knew Python
17:01:40 <mauke> they also said they knew haskell
17:01:43 <exFalso1> hoarser2: the compiler will take this description and turn it into actual instructions
17:01:54 <Peaker> hoarser2: What is "True" or "False"? They're just values that can be pattern-match against later.  Same as "GetChar" -- it is just a name for a value. Maybe later some function will give it a meaning of getting chars from keyboard
17:02:12 <exFalso1> hoarser2: getChar will be hooked up with a foreign function call to C afaik
17:02:13 <mauke> is Cale gone?
17:02:29 <Peaker> hoarser2: but the definition Cale wrote is just making a name "GetChar" -- without yet assigning it any useful meaning
17:02:59 <hoarser2> Peaker: fine.  Now let us return to the question: when/where/how is the reading of the keyboard triggered?
17:03:15 <mauke> hoarser2: you mean in reality? in the runtime system
17:03:29 <hoarser2> mauke: yes, let's try that.
17:03:59 <mauke> (disclaimer: this is just my model of Haskell. I use it because it works, not because it necessarily matches any particular implementation)
17:04:05 <hoarser2> When I write 'getc' in C, I know exactly where and when the keyboard will be read.
17:04:07 <Cale> sorry, have to take a call, brb
17:04:22 <hoarser2> By contrast, you are all telling me that Haskell's (or Cale's) GetChar is some kind of phantom. :)
17:04:28 <exFalso1> hoarser2: your job as the compiler is to take the pure IO description and turn it into dirty side effecting instructions, including making the call to the relevant C function (getc in this case)
17:04:40 <mauke> hoarser2: ok, so you have a program that defines variables like 'main'
17:04:59 <mauke> hoarser2: the compiler generates code to evaluate stuff. it then looks at the value of 'main'
17:05:20 <mauke> hoarser2: that value is a data structure describing side effects (somehow)
17:05:33 <mauke> hoarser2: the runtime system then interprets that data structure to actually execute stuff
17:05:55 <hoarser2> mauke: and does that 'interpretation' happen when GetChar is 'evaluated'?
17:05:59 <mauke> hoarser2: no
17:06:01 <Peaker> hoarser2: Cale's "GetChar" and entire definition of a fake "IO" type was meant to illustrate the view of "IO" as a data structure whose effects are not carried out by building of the data structure, but by some "executioner" -- which in Haskell is the runtime system
17:06:02 <hoarser2> ('executed'??)
17:06:05 <mauke> hoarser2: no
17:06:21 <mauke> hoarser2: GetChar is a constructor. it builds a data structure
17:06:25 <mauke> there is no magic here
17:06:45 <mauke> (in fact, there is no magic at all)
17:06:57 <hoarser2> OK, where is the magic?  It sounds like it's in some dark antechamber of ghci.  Where in the pure code does that antechamber get accessed?
17:07:03 <ben> nowhere
17:07:04 <mauke> hoarser2: nowhere
17:07:13 <ben> the antechamber accesses the pure values and decides what to do
17:07:22 <ben> the pure values don't get to say, hey, i need io here
17:07:25 <mauke> hoarser2: again, if you're Haskell code, you don't see any execution happening
17:07:26 <hoarser2> OK guys.  Reality check.  When I do getLine in ghci, it really does read what I type.
17:07:34 <ben> getLine doesn't read what you type
17:07:38 <mauke> hoarser2: yes, because ghci isn't in haskell
17:07:44 <ben> ghci notices you said getLine and says, hey, i guess I can read some line here
17:07:53 <hoarser2> ben: you are surely trying to make me crazy.
17:08:14 <hoarser2> ;)
17:08:18 <mauke> hoarser2: when you type a line into ghci, it is first evaluated. this yields some value.
17:08:31 <hoarser2> Yes, suppose that line is 'getLine'
17:08:52 <mauke> hoarser2: ghci then checks if that value has the type IO something. if so, it executes ("interprets") it. otherwise it converts it into a string (by calling 'show') and outputs that.
17:09:35 <mauke> so if you type "2 + 2", you get 4 :: Integer, ghci sees that it's not IO something, and prints the result of 'show 4'
17:09:36 <hoarser2> So it sounds like execution happens after evaluation.
17:09:50 <ben> Maybe someone ought to write a ~monad tutorial~ where you use C or python or whatever to interpret some representation of a haskell IO gadt thingy ;)
17:09:52 <mauke> but if you type 'getLine', you get ...something... :: IO String
17:09:59 <Cale> hoarser2: GHCi does both evaluation and execution
17:10:06 <mauke> ben: but that wouldn't be a monad tutorial, it would be an IO tutorial
17:10:19 <hoarser2> Cale: yes, but mauke seems to be suggesting that execution happens _after_ evaluation.
17:10:34 <hoarser2> ben: monads are easy.  IO is not.
17:10:35 <mauke> hoarser2: in the beginning, yes
17:10:42 <mgsloan> ben: ghci could force you to write "print" in front of everything that's not IO, but it doesn't.
17:10:52 <ben> mauke: Yeah but people read monad tutorials so they can do IO, really ;)
17:10:55 <mgsloan> and that's pretty much the summary of it
17:10:58 <hoarser2> When you say that ghci 'checks' for IO values, are you saying that the type checker is doing the 'checking'?
17:11:02 <mauke> hoarser2: the trick is of course that actions can call back into Haskell code
17:11:10 <hoarser2> ben: not so!
17:11:13 <Cale> hoarser2: yeah, well, they get interleaved a bit, because every Bind will have a function on the right, and the result of the previous action will have to have that function applied to it and then evaluated to determine what to execute next
17:11:19 <mgsloan> hoarser2: yes.  First it type checks the expression in order to know what to do with it
17:11:30 <Cale> So, if we were to write an interpreter for my IO type in Haskell
17:11:34 <hpaste> Peaker pasted “ghci evaluation” at http://hpaste.org/65541
17:11:35 <Cale> it would look something like this:
17:12:15 <Cale> execute (Bind x f) = do v <- execute x; execute (f v)
17:12:36 <Cale> execute GetChar = getChar
17:12:42 <Cale> etc. etc.
17:12:58 <mauke> that seems backwards
17:13:01 <Cale> and see, the pattern matching which execute does
17:13:07 <Cale> is what triggers evaluation
17:13:21 <mauke> yeah, but no one uses your IO
17:13:32 <mauke> and your IO is implemented on top of Prelude.IO
17:13:39 <Cale> mauke: I'm trying to give hoarser2 a good mental model :)
17:13:44 <mauke> which doesn't really help if you don't understand Prelude.IO
17:13:54 <hoarser2> Peaker: thanks for the paste.
17:13:56 <Cale> You can also imagine implementing this in O'Caml or whatever
17:13:58 <parcs`> ghci typechecks three version of your input: 1) 'it <- e; print it' 2) 'it <- e; return ()' and 3) 'let it = e; print it'
17:14:07 <Cale> (this execute thing)
17:14:26 <Cale> whatever language we're implementing our Haskell runtime system in
17:14:33 <Peaker> hoarser2: sure.. is it a good explanation?
17:14:43 <hoarser2> Peaker: the first 6 lines are helpful.
17:14:46 <Cale> hoarser2: does that help at all?
17:15:25 <mauke> I missed the beginning. hoarser2: do you happen to know javascript?
17:15:29 <Cale> hoarser2: It might help to have a good handle on how evaluation works too
17:15:36 <hoarser2> mauke: a little js, yes.
17:15:40 <mauke> hoarser2: XMLHttpRequest?
17:15:43 <hoarser2> Cale: evidently.
17:15:51 <hoarser2> mauke: perhaps (?)
17:16:02 <hoarser2> mauke: please give it a try, if it won't take up too much of your time.
17:16:15 <mauke> huh?
17:16:33 <mauke> did I miss a step somewhere?
17:16:33 <hoarser2> mauke: I meant feel free to try explaining things to me in terms of XMLHttpRequest.
17:16:42 <Cale> hoarser2: In most languages, if you have a function application like  f x  you typically evaluate x, and then f, and then substitute the value you computed for x into the body of f, yeah?
17:16:57 <hoarser2> Cale: yes of course, standard eager evaluation.
17:16:58 <Cale> hoarser2: for example, (haha, who knows which example is coming now?)
17:17:01 <mauke> hoarser2: well, it's asynchronous!
17:17:06 <Cale> if we have  double x = x + x
17:17:20 <Cale> then we get the evaluation steps
17:17:23 <Cale> double (double 5)
17:17:26 <Cale> -> double (5 + 5)
17:17:28 <hoarser2> mauke: so you're saying that Haskell's IO actions are asynchronous?
17:17:31 <Cale> -> double 10
17:17:33 <Cale> -> 10 + 10
17:17:34 <Cale> -> 20
17:17:40 <mauke> hoarser2: oh, you haven't noticed?
17:17:45 <mauke> hoarser2: look at the type of >>=
17:17:46 <hoarser2> Cale: all fine.
17:17:48 <mauke> hoarser2: it registers a callback
17:18:40 <hoarser2> mauke: if memory serves, >>= has type m a -> (a -> m b) -> m b
17:18:44 <mauke> yes
17:18:52 <exFalso1> :t (>>=)
17:18:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:18:53 <mauke> the second argument is the function to call on success
17:19:04 <hoarser2> mauke: i presume the callback is (a -> m b)?
17:19:34 <exFalso1> yes
17:19:56 <Cale> but this isn't the only way to carry out the evaluation, we could also just immediately substitute the parameter into the body of the function
17:20:03 <Cale> (without evaluating it first)
17:20:09 <Cale> If we do that, we'd get:
17:20:13 <Cale> double (double 5)
17:20:23 <Cale> -> (double 5) + (double 5)
17:20:24 <hoarser2> Cale: yes, I know about different evaluation strategies, and you're now talking about laziness.
17:20:30 <Cale> yeah
17:20:38 <Cale> laziness is actually a little different again
17:20:43 <Cale> It's outermost-first like this
17:21:08 <hoarser2> Cale: whatevs :) Pierce's TAPL enumerates about 4 different eval strategies.
17:21:19 <Cale> but there's sharing
17:21:19 <hoarser2> I get the general point, I think...
17:21:27 <hoarser2> Cale: you mean memoizing?
17:21:37 <mauke> (it's not memoizing!)
17:21:39 <exFalso1> no
17:21:42 <Cale> in that any parameter to the function which occurs more than once in the body shares any evaluation done to it between the occurrences
17:21:53 <exFalso1> how did we end up at laziness?
17:21:54 <Cale> It's a *kind* of memoisation which is highly restricted
17:21:57 <hoarser2> that's memoizing!
17:22:01 <mauke> hoarser2: no
17:22:05 <exFalso1> no its not
17:22:15 <Cale> It's not what we usually mean when we speak of memoising the function
17:22:19 <hoarser2> let's spell it out ,then.  You're saying the eval is done just once, right?
17:22:36 <Cale> The evaluation of any function parameter is done at most once
17:22:38 <mauke> none of this matters for IO, btw
17:22:44 <hoarser2> You're talking about 'call by need'?
17:22:50 <Peaker> yeah, why did you jump from IO to laziness/evaluation?
17:22:51 <mauke> you could define IO in C or whatever and it'd work the same way
17:22:52 <Cale> But we *don't* save the results of function applications
17:22:59 <Cale> (we never build memo tables)
17:23:18 <hoarser2> Cale: ok, then, I'll remember to keep using 'let' :)
17:23:32 <exFalso1> basically a value can either be in weak head normal form -or- an unevaluated "thunk"
17:23:36 <mauke> hoarser2: do you know why you can't define "sleep" in javascript?
17:23:37 <downloader> Why doesn't 'import qualified Data.ByteString.Lazy as L; s = L.ByteString "foo"' create a ByteString?
17:23:58 <mauke> downloader: because there is no ByteString data constructor
17:24:15 <hoarser2> mauke: sleep?  As in, the function that suspends a thread for a given period of time?
17:24:18 <mauke> hoarser2: yes
17:24:20 <exFalso1> mauke: there is, its just not called ByteString
17:24:30 <mauke> exFalso1: is it exported?
17:24:32 <hoarser2> mauke: no, I don't.  What's the reason?
17:24:32 <Peaker> exFalso1: don't be pedantic :)
17:24:34 <downloader> exFalso1: What is it called
17:24:39 <downloader> ?
17:24:46 <exFalso1> if you want to convert a String to a ByteString use encode
17:24:54 <exFalso1> :t encode
17:24:55 <lambdabot> Not in scope: `encode'
17:25:01 <downloader> Why does the first line in "Synopsis" say "data ByteString"? http://hackage.haskell.org/packages/archive/bytestring/0.9.0.4/doc/html/Data-ByteString-Lazy.html#t%3AByteString
17:25:04 <hoarser2> OK, we seem to be drifting further away... ;)
17:25:10 <Cale> hoarser2: If we did build memo tables, nothing would ever become garbage, and memory usage would be obscene :)
17:25:28 <mauke> hoarser2: because browsers don't provide it as a primitive, only setTimeout
17:25:28 <Cale> hoarser2: I just felt it good to be 100% clear about what evaluation means :)
17:25:34 <downloader> exFalso1: What module is that in? Does that create a lazy ByteString?
17:25:34 <hoarser2> Cale: I'm perfectly fine with no memoization.  You were in the middle of an explanation...
17:25:35 <Cale> hoarser2: and what laziness is really about
17:25:42 <Peaker> :t Data.ByteString.UTF8.encode
17:25:43 <lambdabot> Not in scope: `Data.ByteString.UTF8.encode'
17:25:44 <exFalso1> downloader: one sec
17:25:48 <Peaker> :t Data.ByteString.UTF8.fromString
17:25:49 <lambdabot> String -> BSC.ByteString
17:25:52 <Cale> hoarser2: Would you like me to continue with that? You seem to be reasonably familiar
17:26:04 <exFalso1> sorry its called unpack
17:26:07 <exFalso1> *pack
17:26:08 <mauke> hoarser2: that is, instead of suspending yourself for N seconds, you tell the runtime to call you back in N seconds
17:26:10 <exFalso1> http://hackage.haskell.org/packages/archive/bytestring/0.9.2.1/doc/html/Data-ByteString-Lazy-Char8.html
17:26:10 <hoarser2> Cale: yes, please do continue, if it will shed light on my questions about IO...
17:26:33 <Peaker> downloader: what kind of translation do you want?  Is your String purely ASCII?
17:26:49 <Cale> okay
17:26:54 <downloader> Peaker: No, I don't think so.
17:27:11 <Cale> so let me finish that plain outermost first evaluation, to help remind us why lazy evaluation is good :)
17:27:15 <exFalso1> downloader: check the link
17:27:17 <Peaker> downloader: btw:  "data ByteString = ..." defines a type ByteString, not a data constructor ByteString. If it said: "data ByteString = ByteString .." it would define a data constructor "ByteString"
17:27:17 <Cale> double (double 5)
17:27:22 <Cale> -> (double 5) + (double 5)
17:27:27 <Cale> -> (5 + 5) + (double 5)
17:27:31 <Cale> -> 10 + (double 5)
17:27:34 <Cale> -> 10 + (5 + 5)
17:27:37 <Cale> -> 10 + 10
17:27:39 <Cale> -> 20
17:27:43 <hoarser2> Fine.
17:27:50 <mauke> Cale: boring
17:27:50 <Peaker> downloader: ByteString is basically a sequence of Word8's -- and a String is a sequence of Unicode code points.. different things, so you need to decide how to translate
17:27:53 <downloader> Peaker: thanks
17:27:54 <Cale> So in lazy evaluation, we do sharing, which I can represent with let
17:28:01 <Cale> double (double 5)
17:28:11 <Cale> -> let x = double 5 in x + x -- still outermost first though
17:28:18 <Cale> -> let x = 5 + 5 in x + x
17:28:23 <Cale> -> let x = 10 in x + x
17:28:25 <downloader> Peaker: So I can't just give unpack a UTF-8 string?
17:28:28 <Cale> -> 10 + 10
17:28:29 <Cale> -> 20
17:28:38 <Peaker> downloader: Do you know what UTF8 is?
17:28:41 <hoarser2> OK, and now the bit about IO?
17:28:58 <Peaker> downloader: it may be helpful to read this: http://www.joelonsoftware.com/articles/Unicode.html
17:29:05 <Cale> okay, so IO in Haskell is separate from this process of reducing expressions to values
17:29:24 <Cale> apart from the fact that we have some values whose purpose is to describe IO to be executed
17:29:28 <mauke> (that is, Haskell is "pure")
17:30:34 <hoarser2> Cale: yes, fine.
17:30:44 <Peaker> hoarser2: execution of an action is a recursive process, because an action can be a composition/glue of actions (which will recursively execute) and functions (which will recursively evaluate).  So it is enough to just execute "main" to get everything else recursively executed
17:30:45 <Cale> So you have some expression which defines an IO action, it gets evaluated (enough to pattern match and begin to execute), and then that gets executed
17:30:58 <downloader> Peaker: Okay. So can I give pack a UTF8 encoding or not?
17:31:22 <Cale> and in the case of bind, the execution involves applying a function, and executing the result, and we'll end up needing to evaluate that function application before we know which IO action to execute
17:31:27 <hoarser2> OK, I think that makes sense.
17:31:34 <Cale> So execution and evaluation get interleaved like that
17:31:52 <hoarser2> Fine, that's not surprising.
17:31:54 <Peaker> downloader: When you go from String (code points)   to  ByteString (bytes)  that's when you need to encode.  From bytes to code points, you need to decode
17:32:43 <exFalso1> encode/decode is used in Data.Text, pack/unpack is used in Data.ByteString
17:32:44 <Peaker> downloader: you want to go from code points to bytes, so you need to encode.  One possible encoding is truncating all code points to the range 0..255 (not recommended!) and is what the Data.ByteString[.Lazy].Char8.pack  does
17:33:35 <Peaker> downloader: another possible encoding is UTF8. Inside Data.ByteString[.Lazy].UTF8 you have "toString :: ByteString -> String" and "fromString :: "String -> ByteString"
17:33:45 <Cale> hoarser2: okay, good :)
17:34:05 <Cale> hoarser2: So a nice consequence of this is that we can build our own control structures for IO really easily
17:34:28 <hoarser2> Cale: ok, I'm listening...
17:34:28 <Cale> hoarser2: because IO actions are values and can be passed around easily without fear of having them execute accidentally
17:34:33 <Cale> So for example
17:34:47 <downloader> Peaker: Okay, I think that is the information I need. Thanks
17:34:59 <Cale> times :: Int -> IO a -> IO [a]
17:35:03 <Cale> let's implement this
17:35:10 <hoarser2> ok
17:35:11 <Cale> It takes a number of times to run something
17:35:15 <Cale> and an action
17:35:26 <Cale> and it produces an action which does it that many times and gives a list of the results
17:35:38 <Cale> times 0 x = return []
17:35:44 <Cale> ^^ it's easy to run something 0 times
17:35:53 <hoarser2> let me guess the rest.
17:35:56 <Cale> okay :)
17:35:57 <hoarser2> gimme a sec.
17:36:50 <hoarser2> times n x = do { v <- x; return v:(times (n-1) x) } ?
17:37:05 <mauke> that's two type errors
17:37:09 <mauke> one: precedence
17:37:12 <hoarser2> Wait, that can't be right.
17:37:21 <mauke> return v : ... is parsed as (return v) : ...
17:37:30 <hoarser2> times n x = do { v <- x; vs <- times (n-1) x; return (v:vs) }
17:37:37 <Cale> there you go!
17:37:51 <hoarser2> OK, let's continue with the explanation.
17:38:47 <Cale> We can also have things like sequence :: [IO a] -> IO [a], and use that to implement times, which is actually known in the library as replicateM.
17:39:53 <hoarser2> OK...
17:40:27 <hoarser2> I guess I'd like to 'regroup' and rephrase the paradox.
17:40:59 <hoarser2> On the one hand, it is said that IO allows Haskell to break referential transparency, obviously because the result of the invocation is allowed to be nondeterministic.
17:41:12 <mauke> no, that's not why
17:41:18 <hoarser2> On the other hand, several of you keep saying "IO is a pure value."
17:41:18 <mauke> and it doesn't break referential transparency
17:41:31 <mauke> (yeah)
17:41:49 <hoarser2> Do you at least see the paradox, see why I'm confused?
17:41:53 <mauke> no
17:42:02 <hoarser2> oh come one..
17:42:05 <hoarser2> *on
17:42:11 <mauke> forget "it is said"
17:42:14 <mauke> problem solved
17:42:28 <Cale> hoarser2: There are some un-careful explanations of what Haskell is like where referential transparency gets broken :)
17:42:40 <koala_bot> What is the difference between isURI and isAbsoluteURI in Haskell.URI? The descriptions seem to say the same thing
17:42:47 <Cale> hoarser2: after all, you can think of a function  a -> IO b  as being *like* an effectful function
17:43:13 <Cale> hoarser2: and sort of mash the evaluation and execution together in your head and it looks not-referentially-transparent anymore
17:43:39 <Cale> hoarser2: but if you actually pick it apart, all the evaluation is referentially transparent, but of course, the results of execution are not
17:43:51 <hoarser2> Cale: sure, but according to the vocabulary we established above (function vs. procedure), 'effectful function' is a contradiction of terms.
17:43:58 <Cale> (executing the same action twice can have different results)
17:44:01 <Cale> yeah
17:44:49 <exFalso1> hoarser2: its an abuse of terminology
17:45:03 <hoarser2> Perhaps we should just stop here, and I could take a look at the URLs you guys pointed me to above.
17:45:08 <Peaker> that's why I said: "parameterized procedure" (function that returns a procedure)
17:45:18 <Peaker> rather than "effectful function"
17:45:30 <hoarser2> hmm
17:54:15 <vyom> This line is failing in ghc 7.0.3 but works on 7.4 https://github.com/deepakjois/diagrams-svg/blob/master/src/Diagrams/Backend/SVG.hs#L37
17:54:47 <hoarser2> I should say thank you to all of you who took the time to explain things!
17:55:32 <hoarser2> Cale, Peaker, mauke, exFalso1: many thanks.
17:55:56 <vyom> here is the Travis CI output which alerted me to the problem : http://travis-ci.org/#!/deepakjois/hs-logo/builds/896547/L417
18:01:25 <vyom> any better fixes other than replacing "<>" with "mappend"
18:01:28 <vyom> ?
18:04:48 <hpaste> “Eduardo León” pasted “Symbolic differentiation” at http://hpaste.org/65542
18:04:58 <Authoritarianism> Hello, I need more help.
18:06:09 <Authoritarianism> I am trying to extend my symbolic differentiation system in order to provide expression simplification. (e.g., reduce "x + 2x" to "3x").
18:06:24 <Authoritarianism> However, I am… stuck.
18:08:49 <edwardk> Authoritarianism: have you ever tried ad? =)
18:08:50 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
18:09:04 <Authoritarianism> edwardk: What is that?
18:09:19 <edwardk> Authoritarianism: Also, Debug.Traced from the traced package does simplification, when paired with 'ad' it can do symbolic differentiation already
18:09:29 <edwardk> cabal install ad
18:10:03 <edwardk> Numeric.AD.grad (\[x,y] -> x * sin y) [1,2] -- will compute the gradient at that point using automatic differentiation
18:10:25 <Authoritarianism> edwardk: I do not need numeric differentiation.
18:10:28 <edwardk> but you can also do symbolic differentiation by feeding it values out of Debug.Traced
18:10:30 <edwardk> its not numeric
18:10:47 <Authoritarianism> edwardk: Anyway, I am doing this just as a proof of concept, so I would like to know how to do it by hand.
18:11:03 <Authoritarianism> edwardk: Of course, if I ever need to do this IRL, I will just take an existing proven solution. :P
18:11:35 <edwardk> ghci> showAsExp $ diff sin $ unknown "x"  => cos x * 1.0
18:12:01 <edwardk> diff comes from 'ad', showAsExp and unknown come from traced =)
18:12:32 <Authoritarianism> edwardk: Wow. So it just performs pattern matching on existing (Floating t) => t -> t functions?
18:13:29 <edwardk> not pattern matching, but I provide instances that are capable of doing forward and reverse mode AD. they can take multiple arguments, return multiple arguments, as well
18:13:51 <edwardk> by asking for the gradient, jacobian, hessians, or even the jet of all derivatives in a tower
18:14:02 <Authoritarianism> Wow.
18:14:14 <Authoritarianism> Impressive.
18:14:54 <Authoritarianism> Is it possible to perform pattern matching on lambdas?
18:16:06 <edwardk> the idea of automatic differentiation is you make a new numeric type, in forward mode you augment with an extra number, for the derivative with respect to one of your inputs. and then you use the product rule, the chain rule, etc. on that.
18:16:21 <edwardk> An you can make a pretty naive traced number type that just builds up an AST
18:16:47 <edwardk> so when you use AD to transform a traced number, you get to look at the trace of the operations applied to the derivative, which is ultimately just symbolic differentiation
18:17:17 <edwardk> now, this doesn't let you _pattern match_ on lambdas, per se, but it does let you see what was done, by virtue of the fact that you supplied the instances yourself and built up the syntax tree as you went
18:17:53 <edwardk> now, the next tricky part is that the syntax tree isn't a tree, its really a directed graph
18:18:05 <Authoritarianism> edwardk: That makes sense.
18:18:10 <edwardk> and if you screw that up, then when you compute x^100, you'll feel the pain ;)
18:18:47 <Authoritarianism> Precisely because I have foreseen that problem, it is that I want to simplify the expressions at hand the most that I can.
18:18:48 <edwardk> because instead of doing O(log 100) operations, you'll do O(2^log 100) ;)
18:18:59 <edwardk> this is what observable sharing is for
18:19:04 <edwardk> I do that in the reverse mode
18:19:31 <edwardk> And Lennart's traced also lets you recover sharing in his expressions using a similar technique
18:20:44 <edwardk> Forward mode worsens the asymptotics of your code when you have more inputs than outputs.
18:20:54 <edwardk> Reverse mode retains the same asymptotics as the original algorithm
18:21:07 <Authoritarianism> edwardk: I am dealing with functions of one variable only.
18:21:15 <Authoritarianism> One real variable.*
18:21:46 <edwardk> and typically runs about 3x slower, in exchange for giving you the derivative if it exists (well, technically if you'd need to apply L'Hopital's rule, reverse mode will screw up, but forward mode can be fixed to work)
18:22:57 <edwardk> Forward mode retains the same space behavior as the original algorithm, while reverse mode needs to store a tree that is the size of the set of computations you ran, that you turn back into a graph and walk backwards. This makes your old time complexity into your new space complexity.
18:24:33 <edwardk> Ultimately, I'd be hard pressed to recommend using a real 'symbolic derivative' to anyone, because of the asymptotics. You can compute an automatic derivative with the same computation time as the original algorithm, but to represent the symbolic derivative can take up an explosive amount of space. (consider the expansion involved in the derivative of x*e^x)
18:25:11 <Authoritarianism> :O
18:25:17 <Authoritarianism> Yes.
18:25:55 <augur> edwardk: beep
18:26:04 <edwardk> But, I can understand how someone would want to do this as a learning exercise ;)
18:26:12 * edwardk is beeped.
18:27:00 <augur> edwardk: do you know of anything that relates global properties of graphs to local properties of "higher level" graphs?
18:27:16 <edwardk> higher level in what sense?
18:27:44 <augur> like, maybe a derived graph that is enriched in some way
18:28:01 <edwardk> i need something more specific =P
18:28:21 <edwardk> because right now that description is too fuzzy for me to make out ;)
18:28:25 <augur> :p
18:28:43 <augur> well, the best example i have is from physics, but its not a perfect example because its not really graph-y but
18:29:48 <augur> principles of least action in physics are global properties of paths in a state space, but you can also get the same effects by looking only at local properties of each state
18:30:10 <augur> which i guess is sort of like looking at a different graph where the states are enriched with different information
18:31:23 <edwardk> like geodesics vs. the curvature of the manifold
18:31:38 <augur> sure
18:32:09 <augur> but really im just interested in simpler systems
18:32:17 <edwardk> i don't really think about those in terms of graphs though
18:32:23 <augur> i dont have concrete examples because i dont know of any but
18:32:27 <augur> you get the idea, i think, no?
18:32:51 <edwardk> well, i get that differential geometry example i coughed up pretty well ;)
18:33:08 <edwardk> but i don't know of any good applicable tools from graph theory
18:34:00 <rasfar> augur: you led me off into #blah the other day only to abandon the discussion
18:34:18 <edwardk> rasfar: yeow. and you made it out alive?
18:34:22 <edwardk> they are brutal in there
18:34:40 <edwardk> He might have been trying to have you killed
18:34:43 <rasfar> with the happy side effect that i wasn't watching #haskell and didn't spring to the defence of <causative> which i otherwise surely would have
18:35:00 <rasfar> poor guy had a decent idea and got trammelled into the earth mercilessly
18:35:28 <rasfar> (yeah, i'm still here amn't i?)
18:35:35 <rasfar> anyways...
18:35:50 <rasfar> haha
18:36:08 <rasfar> honestly it was far more hostile in #haskell at that juncture
18:36:49 <edwardk> Not used to #haskell being referred to as a hostile place. Shapr would be sad to hear.
18:36:57 <augur> rasfar: :p
18:37:45 <rasfar> hostile isn't quite the word, although that day ... honestly, the troll that got kicked 10 minutes before had the red carpet treatment compared to <causative> (who I'm sure won't be back)
18:39:03 <rasfar> shapr was the first person i met on my first visit here in April 2005...  I just found the archive of all the pre-2011 tunes logs.
18:39:23 <rasfar> have there been any cool projects mining the logs?
18:40:06 <edwardk> dons used to post up a bunch of channel stats
18:40:18 <edwardk> most talkative, quotes, etc.
18:40:50 <rasfar> my first words on the channel:   /msg nickserv link rasfar vfy321cdq
18:41:21 <shapr> rasfar: oh hi!
18:41:22 <rasfar> talk about stumbling in through the door :)  shapr swiftly came to the rescue
18:41:30 <edwardk> mine were probably me looking for audreyt
18:41:31 <rasfar> hi shapr!
18:41:44 <augur> edwardk: so nothing like that sounds familiar tho, ey?
18:41:54 <edwardk> augur: i got nuthin
18:41:58 <augur> :(
18:42:04 <shapr> It does seem like #haskell is becoming more hostile, and I don't have time to clean up.
18:42:34 <edwardk> shapr: come on, dump the girl, and spend all your time in here like you used to
18:43:03 <rasfar> i think it's just, there some very bright people and the tolerance level is a bit lower than maybe the gentler types would like...
18:43:05 <luite_> or get her to do some cleaning up here
18:43:07 <edwardk> I'm sure she'd understand
18:44:14 <augur> edwardk: would you be interested in trying to work out the relevant math for that sort of thing? :D
18:44:24 <edwardk> I can see the dialog between her and her parents, now. "He left you because you irked him?" "No, dad, he left me for IRC!"
18:44:29 <edwardk> augur: not my cup of tea ;)
18:44:33 <augur> :(
18:45:01 <Saizan> tbf, it's hard to go easy on the kind of overloading that was proposed, maybe even SPJ would get it rough wrt TDNR?
18:45:53 <rasfar> Saizan: you talking about the <causative> thing?
18:46:11 <edwardk> Saizan: what was the crime of this causative fellow, anyways? I'm just hearing about all this now
18:46:20 <Saizan> rasfar: yep, but half-seriously
18:46:57 <Saizan> edwardk: that you should be able to pass arguments to functions in any order as long as the types can disambiguate
18:46:59 <rasfar> Well, he was listening, gah -- who was it, elliott and cmccann were having a long discussion about linear logic, and the difficulties of "connecting things up"
18:47:11 <edwardk> saizan: oh hell no
18:47:25 <rasfar> that was the context, and causative observed that the need to connect things up can sometimes be ameliorated by looking at types.
18:47:49 <rasfar> i've had similar thoughts.  rwbarton as usual made some sensible constructive comments.
18:48:02 <rasfar> (i probably should stop this, i'm obviously in a mood...)
18:48:26 <rasfar> but one person in particular took it way too seriously, like this was a round table for Haskell' or something...
18:49:00 <rasfar> i think part of the problem was <causitive> is not quick on the keyboard, so spent too much time trying to express themselves and missed a few remarks until too late.
18:49:28 <edwardk> well, when you start talking about named arguments or type directed arguments, you start wanting optional arguments as well, and the whole thing gets very messy very fast
18:49:38 <cmccann> it was a terrible idea proposed with good intentions that resulted in getting dogpiled by like three or four people explaining how bad the idea was
18:49:39 <rasfar> anyway, i'm relieved to have had a say.  i like the way he thinks, and it was apropos to the previous conversation.
18:50:12 <cmccann> which yeah in hindsight really wasn't the right way to respond
18:50:16 <rasfar> well, as rwbarton pointed out (sadly causitive missed his comments I think), it might be useful in an IDE, but not in the language proper.
18:50:25 <edwardk> and i can see how it would lead to passions rising on both sides
18:50:42 <shapr> and passions rising leads to intelligent discussion falling over and dying.
18:50:44 <rasfar> despite the heated tone, it was very interesting to me.
18:50:51 <cmccann> also, the linear logic discussion was entirely unrelated pretty sure
18:51:24 <edwardk> rasfar: i suppose one issue is there really aren't a lot of haskell functions that take more than a couple of arguments
18:51:56 <rasfar> well, ... i'd have to look back (and I don't know linear logic) but it was "connecting things up" that was due to arbitrary linear orderings that motivated causative's comments
18:52:04 <edwardk> and with parametricity, the potential for huge surprises is quite high
18:52:22 <mgsloan> OK, lesson learned from the hackage outtage: don't retarget your hackage url.
18:52:37 <rasfar> edwardk: yeah; hearing the objections was very sobering for me, too
18:53:02 <mgsloan> it seems to introduce a whole 'nother subdirectory / set of packages, but maybe that's just for me
18:53:15 <edwardk> then you'd get things where changing the type of something way down the line would change the meaning of whole chains of code up above.
18:53:20 <rasfar> however, related question: when searching by types with hoogle, does anyone ever find it frustrating that you need to guess the order of the args?
18:53:28 <dmwit> No.
18:53:34 <rasfar> how come?
18:53:37 <dmwit> Since Hoogle automatically fixes the order for me when I get it wrong.
18:53:43 <rasfar> it does?
18:54:00 <dmwit> ?hoogle [a] -> (a -> Bool) -> [a]
18:54:01 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
18:54:01 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
18:54:01 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
18:54:04 <dmwit> see?
18:54:05 <dmwit> =)
18:54:07 <rasfar> cool!
18:54:26 <cmccann> rasfar, hmm actually maybe it did start from that, but the relevance is pretty minimal anyway
18:54:29 <rasfar> but you see, it is a related problem; and if hoogle didn't do that someone would make it do that...
18:54:59 <rasfar> that's great; i didn't know hoogle did that.
18:55:44 <rasfar> yeah, the relevance couldn't be more than minimal as i'm pretty sure causative wouldn't know linear logic, given his stated background :)
18:55:53 <cmccann> the log is http://tunes.org/~nef/logs/haskell/12.03.16 with linear logic starting around 21:10, the parameter reordering stuff around 22:27
18:56:28 <dbelange> you talked for an hour about linear logic
18:56:56 <rasfar> (that really makes me laugh out loud)
18:57:03 <dbelange> why don't you just get married and raise a family and die in each other's arms in the plague of 2027
18:57:35 <Saizan> ..talking about hostile
18:57:41 <shapr> yah, dbelange, be nice dude.
18:58:02 <dbelange> ok the plague of 2067
18:58:26 --- mode: ChanServ set +o shapr
18:58:28 <cmccann> pretty sure dbelange is a troll fyi
18:58:32 <shapr> dbelange: be nice or else
18:58:35 <cmccann> if you google for the username
18:58:36 <Peaker> I wonder if IDE's just giving "named arg" sugar for functions-of-records is enough
18:58:40 <Peaker> I think it should be
18:58:57 <dbelange> 2112?
18:59:02 --- kick: dbelange was kicked by shapr (Kicked by shapr)
18:59:16 <copumpkin> the shapr bootprint
18:59:23 <rasfar> fast reflexes!
18:59:33 <shapr> dbelange: that was a hint.
18:59:35 <edwardk> The shape in shapr is obviously a bootprint
18:59:42 <cmccann> at any rate, I didn't spend an hour talking about linear logic, elliott and I spent an hour or so between us. can't very well both converse simultaneously, that would duplicate the conversation which linear logic doesn't allow.
18:59:54 <copumpkin> lol
19:00:01 <dbelange> shapr, how's the missus
19:00:15 <copumpkin> ಠ_ಠ
19:00:20 * shapr sighs
19:00:50 <shapr> I have to go to all the trouble of figuring out how banning works again. I hate it when that happens.
19:01:12 <augur> edwardk: any advice what i might want to look at?
19:01:18 <cmccann> hey, I figured out how to ban somebody on reddit, IRC can't be that much harder
19:01:36 <rasfar> ah yes, the bar graph...
19:02:41 <cmccann> was kinda sad how easily the same joker could troll /r/lisp though, they just kept encouraging him
19:02:43 <edwardk> augur: not really, the goal is a bit too fuzzy for me to make much sense out of it.
19:02:51 <shapr> /mode #haskell +q *** downloader (~user@bas1-montreal46-2925426996.dsl.bell.ca) has quit: Remote host closed the connection
19:02:51 <shapr> ERC> /mode #haskell +q dbelange!*@*
19:02:54 <shapr> poo
19:02:58 <augur> edwardk: :(
19:02:58 <augur> ok
19:03:14 <augur> ok, im off to play some DE. chow.
19:03:21 --- mode: shapr set +q dbelange!*!@*
19:03:28 <shapr> let's see if that works
19:03:33 <edwardk> not exactly the most thorough host mask
19:03:43 * BMeph coughs: "+b"...sorry, must be all this rain giving me a cold. ;)
19:03:56 <shapr> Well, I like to give people a chance to figure out how to be nice :-)
19:04:10 <irene-knapp> besides, if he does come back, you have him on ban evasion :D
19:04:25 <shapr> dbelange is sending me some private messages now, I wonder if he's saying "I would like to be a useful member of this community, and will try to stay on topic".
19:04:32 <shapr> Or is that only my fantasy? :-)
19:04:40 <Saizan> that mask doesn't actually match, there's a ! too many
19:04:44 <rasfar> whoa, that's a bit close to home (montreal) wonder if he's in this cafe?
19:04:46 <shapr> aw man
19:04:52 <rasfar> well, i'm still here so probably not
19:05:00 <irene-knapp> that would be priceless
19:05:15 <irene-knapp> <troll> Ha ha, you don't know where I am!
19:05:22 <dbelange> rasfar: yes I'm in #mcgill
19:05:23 <irene-knapp> * antitroll has punched troll in the face
19:05:44 <shapr> dbelange: So, do you swear to stay on topic and be nice to people?
19:06:03 <rasfar> i'm on st-laurent, so go ahead, get banned for all i care ya *#&@* ... :)
19:06:31 --- mode: shapr set +q dbelange!*@*
19:06:38 <shapr> dbelange: That might work better.
19:09:07 <rasfar> i would like to be a useful member of this community.  what should i do?  free sections was not the answer apparently.
19:09:11 <mietek> Does anyone know what's the latest on GHC-iPhone?
19:10:18 <irene-knapp> mietek: no clue.  I would like it if GHC would even work on Mountain Lion at all :(
19:10:22 <rasfar> (i think i'll go read some tickets now)
19:10:42 <mietek> irene-knapp: well, is it released yet? :)
19:10:55 <irene-knapp> well, no, but… heh
19:11:37 <irene-knapp> the fact that it doesn't work severely constrains my ability to develop in Haskell, since I don't have a Lion system anymore
19:11:47 <irene-knapp> (and I can't virtualize because that stuff is broken too)
19:11:56 <mietek> Dual-boot.
19:11:58 <irene-knapp> I can only code Haskell /at all/ on my linode,
19:12:08 <irene-knapp> if I wanted to boot into Windows I would have bought a Windows box
19:12:19 <shapr> dual-boot linux?
19:12:29 <mietek> Dual-boot with OS X 10.7 and 10.8.
19:12:34 <mietek> That's such an uninteresting problem to have.
19:12:38 <irene-knapp> mietek: nice theory, but not a supported configuration
19:12:52 <cafesofie> thanks for the warning not to upgrade to ML
19:12:56 <irene-knapp> welcome
19:13:09 <cafesofie> i don't know what i was thinking getting a macbook really
19:13:13 <AfC> irene-knapp: (can you not run a VirtaulBox | Parallels | VMware type virtualization with a Linux VM locally to develop in?)
19:13:21 <cafesofie> i could have seen apple's future behavior coming
19:13:32 <irene-knapp> AfC: none of those three run successfully on ML
19:13:39 <mietek> irene-knapp: what theory? Just get an external hard disk.
19:13:54 <AfC> irene-knapp: (vs dual boot or remote development; or, rather, if you're developing on a remote server you could also develop on a remote server ... locally)
19:14:17 <irene-knapp> AfC: well, GHC can't cross-compile, and most of what I want to write are GUI apps
19:14:27 <irene-knapp> AfC: which kinda kills the develop on a remote server theory
19:14:29 <AfC> irene-knapp: Ok. Good to know. We don't use Apple products here.
19:14:47 <AfC> irene-knapp: ah, yes, that is the show stopper for sure.
19:14:47 <irene-knapp> dual boot is a good thought which I hadn't considered, but, meh, it sounds like a lot of work on an ongoing basis
19:14:57 <irene-knapp> I'd rather just be depressed and not write code at all :)
19:15:13 <luite_> make it a web gui!
19:15:18 <irene-knapp> mrrrr
19:15:28 <luite_> though that might just make you more depressed ;)
19:15:32 <irene-knapp> hahaha yeah
19:15:32 <AfC> Yeah. I do package building on a remote server, of course, but frequently shuttle branches to my laptop just so I can do `bzr visualize` (GTK GUI) on it
19:16:05 <AfC> switching from remote server command line to local GUI is a pain. And if you're developing a GUI, well, that's that.
19:16:11 <irene-knapp> yes
20:05:28 * hackagebot diagrams-svg 0.3.2 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.3.2 (DeepakJois)
20:14:13 <JoeyA> What version of GHC is the next version of the Haskell Platform (due May 2012) going to come with?
20:18:51 <JoeyA> Neat, I just learned that base 4.5 added an infix <> operator as short-hand for mappend.
20:20:24 <eyebloom> Has anyone had success using ghci to locate infinite loops recently?
20:24:03 <koala_bot> Would someone be willing to walk through some code with me to get my types tidied up (ideally PM)?
20:24:16 <eyebloom> Sure
20:27:56 <eyebloom> koala_bot: Paste your code on hpaste.org
20:28:16 <koala_bot> http://hpaste.org/65546  I built the functions I needed with the data types as I"d expect them without any IO to do, but know that I need the bottom lowered function which performs IO early on. I need help updating the new functions with appropriate types and perhaps syntax in some areas.
20:29:17 <eyebloom> Where is main?
20:29:39 <koala_bot> I'm just planning to call generateSitemap on a String
20:29:51 <sohum> @hoogle (a -> b -> c) -> (a -> b -> d) -> a -> b -> (c,d)
20:29:52 <lambdabot> No results found
20:30:39 <sohum> @hoogle (a -> c) -> (a -> d) -> a -> (c,d)
20:30:40 <lambdabot> No results found
20:30:46 <sohum> wait, what?
20:31:13 <eyebloom> ok trying to get it to compile over here.
20:31:43 <koala_bot> I appreciate the help
20:32:10 <eyebloom> What package is tagsoup in?
20:32:59 <sohum> @pl \f g a b -> (,) (f a b) (g a b)
20:33:00 <lambdabot> liftM2 (liftM2 (,))
20:33:02 <eyebloom> answered my own question: tagsoup
20:33:22 <koala_bot> :)
20:37:07 <eyebloom> Why use Either String String
20:37:35 <koala_bot> I asked that as well, since it is not my code
20:37:42 <koala_bot> I was told that it's a means of tracking errors
20:38:20 <koala_bot> A return of Left someString indicates some error had occured, whereas a return of Right somestring will be actual results, error-free
20:38:26 <eyebloom> I see so a Left string is an error. Right String is data
20:38:46 <koala_bot> That's what I was told
20:41:09 <Peaker> you could use (Bool, String) instead, which is very similar, but then you wouldn't have a nice Monad instance
20:41:30 <koala_bot> I'd like to not touch that function if I can help it. My trouble is that I just don't know enough about how IO types are handled, and how to work with them.
20:42:59 <eyebloom> I think the problem is in your filter expression in parse
20:43:33 <koala_bot> I'm sure it is :) I just don't know what to do
20:43:39 <eyebloom> return is putting it back into the monad
20:44:07 <koala_bot> I don't know that I can get rid of IO once i've got it
20:44:20 <eyebloom> You can't
20:44:41 <eyebloom> You can have a pure function inside IO but you can
20:44:50 <koala_bot> ...?
20:44:51 <eyebloom> 't have IO inside a pure function
20:44:57 <koala_bot> ah
20:45:13 <koala_bot> that's why I'm tryin to figure out how I need to changem y types up to accomodate
20:45:46 <eyebloom> So parse linkLocs and crawl all need to use IO
20:47:20 <Peaker> "Can't have IO inside a pure function" is a bit vague. You can use IO values inside pure functions. You just can't execute them
20:48:43 <koala_bot> I'm very confused on what needs to happen here.
20:52:47 <eyebloom> I'm just trying to get it to compile.
20:53:02 <eyebloom> The first thing I did was comment out your type annotations.
20:53:42 <eyebloom> hoping I could get the compiler to infer some things.
20:55:24 <koala_bot> linkLocs is missing some necessary logic, I realize. Let me clean that up and repost
20:58:01 <Peaker> koala_bot: also note the hlint warnings...
20:58:10 <koala_bot> hlint?
21:00:12 <Peaker> koala_bot: at the bottom of the paste -- it's a program that warns you about weird style or repetitions/etc
21:00:59 <koala_bot> Ah yeah. I know my syntax is crap. That's what I'm trying to get hammered out atm. I'm not new to programming but am new to Haskell so it's pretty... weird. ha
21:02:45 <toshi_> anyone have any ideas? I've been trying to write a simple function in haskell "getItem x [y] = [y] !! x" but it won't work T_T
21:02:50 <Peaker> koala_bot: hlint didn't have that much to say :)
21:03:07 <ben> lose the []
21:03:27 <Peaker> toshi_: the way it's written, getItem is pattern-matching its second argument as a list of 1 item
21:03:28 <eyebloom> Ok so try this for the last line of parse: Right doc -> filterM (return . (~== TagOpen "a" [("class","")])) (parseTags doc)
21:03:53 <Peaker> toshi_: Put a {-# OPTIONS -Wall #-} at the top of your file, or if you use ghci, run ghci -Wall.  Then make sure you don't get warnings
21:04:08 <toshi_> wow, it works
21:04:12 <toshi_> thanks a lot *_*
21:05:24 <koala_bot> eyebloom: Not in scope: `filterM'
21:05:39 <otters> @where filterM
21:05:39 <lambdabot> I know nothing about filterm.
21:05:55 <eyebloom> Import Control.Monad
21:06:10 <otters> seriously why does lambdabot not know the standard library
21:06:30 <quintess`> @help where
21:06:30 <lambdabot> where <key>. Return element associated with key
21:06:48 <ski> koala_bot : if `parse' is going to call `downloadURL', then it needs to have type `String -> IO [String]'
21:07:03 <koala_bot> Yes it does :) let me post a new hpaste...
21:07:25 <ski> @index filterM
21:07:26 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:07:30 <ski> otters ^
21:07:41 <ski> @help index
21:07:42 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
21:07:43 <otters> oh
21:07:44 <ski> @help where
21:07:44 <lambdabot> where <key>. Return element associated with key
21:07:44 <otters> ofc
21:07:47 <hpaste> koala_bot pasted “Update: Sitemap Generator” at http://hpaste.org/65547
21:09:01 <ski> koala_bot : next time, annotate the original paste, by using the "Annotate" button
21:09:09 <koala_bot> okie dokie
21:09:49 <ski> btw, the `;' at the end of `makeMap' is redundant
21:11:06 <koala_bot> Whoops. habit :)
21:12:47 <ski> `hrefs <- assocLookup "href" urls' together with `return hrefs' should be replaced by `return (assocLookup "href" urls)' (or by `let hrefs = assocLookup "href" urls' together with `return hrefs', if you prefer)
21:12:59 <eyebloom> The url list type is Tag String instead of String
21:13:33 <koala_bot> eyebloom: even with the added code to linkLocs?
21:15:19 <ski>   crawl [    ] visited = do return visited
21:15:23 <ski>   crawl (u:us) visited = do newURLs <- linkLocs u visited
21:15:24 <ski>                             crawl (newURLs ++ us) (u : visited)
21:16:04 <ski> this is because `linkLocs' is in `IO', so therefore `crawl' must be as well, so `do' (or other monadic operators) must be used
21:18:48 <eyebloom> There is still a type mismatch there yes.
21:18:52 <ski> `generateSitemap' also needs to be unnested as well, since it calls the `IO'-monadic `crawl' (in addition to `writeFile')
21:19:49 <ski> (i.e. have `visited <- crawl [url] []' in `generateSitemap')
21:20:04 <hpaste> eyebloom annotated “Update: Sitemap Generator” with “Update: Sitemap Generator (annotation)” at http://hpaste.org/65547#a65548
21:20:28 <eyebloom> Unfortunately I haven't figure it out entirely.
21:20:39 <eyebloom> I'm working backwards.
21:20:54 <eyebloom> I have to log off.
21:21:08 <koala_bot> Thanks eyebloom :)
21:21:58 <ski> koala_bot : note eyebloom forgot to (or didn't notice the suggestion to) fix the `assocLookup' call mentioned above
21:22:19 <eyebloom> Generally the thing to do with IO is to make the IO a thin shell around pure code.
21:22:56 <ski> yeah, only the functions that need to do I/O should be in `IO'
21:23:18 <eyebloom> So really downloadURL should be called first and it's result should be fed into pure versions of crawl, linkLocs, etc.
21:23:21 <ski> typically as large part as possible (within reason) should be kept pure
21:23:59 <ski> eyebloom : well, it's hard to do that for `crawl', at least
21:24:21 <eyebloom> I'd suggest you make what you have compile as an exercise.
21:24:27 <ski> since the point is that `crawl' will fetch many pages, and which it fetches depends on the content of previously fetched pages
21:24:39 <koala_bot> If I didn't have a 10am deadline, I might eyebloom lol
21:25:20 <ski> however, you could pull `parse' out of `linkLocs', and then being able to make it not use `IO'
21:25:45 <koala_bot> I'm not sure how else I would structure that then ski
21:25:56 <vodik> t
21:25:56 <ski> (s/IO()/IO ()/)
21:26:43 <ski> koala_bot : well, you could call `parse' in `crawl' instead of in `linkLocs'
21:26:44 <hpaste> koala_bot annotated “Update: Sitemap Generator” with “Update: Sitemap Generator (annotation) (annotation)” at http://hpaste.org/65547#a65549
21:27:16 <koala_bot> wouldn't that just be moving IO from one func to the other?
21:28:17 <ski> it would, yes
21:28:33 <ski> and doing so, `linkLocs' wouldn't need to be in `IO' anymore
21:28:55 <ski> it's probably not that important in this case, but it's a good thing to consider these kinds of things generally
21:29:28 <ski> (probably not that important since `linkLocs' is short, and isn't involved in complicated (mutual) recursion)
21:29:32 <koala_bot> If possible I'd like to leave it alone for now because at this point I'm understand how I want my information to flow :)
21:29:44 <koala_bot> but not how to type.... ha. understanding*
21:29:46 <ski> sure
21:30:10 <ski> i'm just trying to point out how one could make a smaller part of the program be in `IO'
21:30:24 <ski> the point was the general idea of doing this
21:30:33 <ski> koala_bot : does it type-check yet ?
21:30:39 <koala_bot> not at all lol
21:31:18 <ski> could you annotate with the type errors you get ?
21:32:19 <hpaste> koala_bot annotated “Update: Sitemap Generator” with “Update: Sitemap Generator (annotation) (annotation) (annotation)” at http://hpaste.org/65547#a65550
21:33:04 <ski> er, right
21:33:47 <ski> koala_bot : the base case in `crawl' should be `return visited' (optionally with a `do' before that), not just `visited'
21:34:25 <koala_bot> ah
21:34:35 <koala_bot> Alright, that leaves line 25 :/
21:35:58 <ski> yeah, i'm pondering that one
21:36:17 <koala_bot> I'm not sure where it's getting that tuple
21:36:56 <ski> apparently `parse' returns `[Tag String]' instead of `[(String,String)]'
21:37:30 <ski> you might get slightly better error messages if you added back type signatures for some operations
21:37:42 <rwbarton> filterM (return . ...) ?
21:38:12 <koala_bot> idk
21:38:13 <ski> (also, the type of `assocLookup' isn't right, the second argument can't be a list of strings, there)
21:38:32 <koala_bot> ski, why not?
21:38:54 <ski> because you say  (k', v ) <- dict
21:39:05 <ski> this means that `dict' must be a list of pairs, at the very least
21:39:13 <koala_bot> right but you're only returning v
21:39:29 <ski> doesn't matter re this
21:39:42 <koala_bot> it's a list of all v such that v is paired with the argument k, isnt it?
21:40:05 <ski> i'm not sure if you mean to pass in a list of strings, converting each string to a key and a value, or if you mean to pass in a list of key-value pairs
21:40:13 <koala_bot> it's a list of pairs
21:40:40 <koala_bot> parseTags returns a list of TagOpen "string" ("attribute","value")
21:40:45 <rwbarton> and a list of pairs is not a list of strings
21:40:45 <ski> as is very common with type inconsistencies, you can correct the inconsistency in more than one place
21:41:10 <ski> ok, so `assocLookup :: String -> [(String,String)] -> [String]', then
21:41:19 <rwbarton> ski is talking about the commented-out type signature
21:41:47 <koala_bot> I realize, rwbarton. I'm just confused on the syntax why it would be returning a tuple if I'm only pulling one item from the tuple into the list
21:42:09 <ski> (though i would probably consider generalizing it to `assocLookup :: Eq key => key -> [(key,value)] -> [value]' -- however, you choose whichever you think is more clear for you)
21:42:10 <rwbarton> he didn't say "returning"
21:42:14 <rwbarton> he said "second argument"
21:42:43 <koala_bot> my vernacular is no good for this. But I don't see why that function results in a list of tuples
21:43:05 <rwbarton> nobody is talking about the result
21:43:43 <koala_bot> I'm sorry, I'm failing to see what we're talking about then. It's been a long day
21:44:49 * koala_bot scrolls up and tries again
21:45:23 <ski>   --assocLookup :: String -> [String] -> [String]
21:45:26 <ski>                              ^^^^^^^^
21:45:29 <koala_bot> Yes, I see now
21:45:31 <ski> koala_bot : that ^ argument
21:45:46 <koala_bot> I'm not worried about correcting the type declarations at this point because I know I have implementation issues to fix before I can do any typing
21:45:49 <koala_bot> that's why it's all commented out
21:46:14 <koala_bot> I've gotta get this puppy compiling
21:46:20 <ski> yeah, but it's a good idea to add, step-by-step, back the type signatures you're sure above, to help hunting down the source of the type error
21:47:06 <koala_bot> okie dokie
21:47:13 <koala_bot> Thank you
21:47:27 <ski> the type signatures that you're not sure about is good to comment out, but the one's you're sure (or think you're sure about) are good to keep it, since that will make the reported position of the type error be closer to the conceptual error in the code that you have to fix
21:48:28 <ski> (as far as the compiler is concerned, there are usually several positions out of which one (or a few) could be changed to fix the type error, and the compiler has no idea which of these is the actual place that you want to correct (i.e. the place of the conceptual error you made))
21:49:05 <koala_bot> I see.
21:49:18 <koala_bot> Could you please explain this line? Right doc -> filterM (return . (~== TagOpen "a" [("href","")])) (parseTags doc)
21:49:18 <ski> koala_bot : so, afaiu, you agreed that the second argument of `assocLookup' should be a list of pairs (of strings)
21:49:35 <koala_bot> yes ski. Sorry about the confusion. I've been at this for almost 12 hours
21:50:00 * ski doesn't really know what this `Tag' business is -- it's probably something specific to the library in question which you use
21:50:14 <ski> koala_bot : anyway, having made sure you meant to pass a list of pairs there, now we turn to where this is called, i.e. in `linkLocs' -- either `urls' here have to be converted to a list of pairs at this place, or `urls' itself is a list of pairs, and then you need to change `parse' so that it returns a list of pairs -- which option would you prefer ?
21:51:21 <ski> you have to make the conversion at some point in the code -- which means either in `linkLocs' or in `parse', relative your current code
21:51:42 <koala_bot> I'm using tagsoup to find html elements in a page, and parseTags will return a list of Tag "element" [("attribute","value")]. I'm unsure of how to only grab the (attribute,value) from that data, but I'd like to do that in parse
21:52:13 <koala_bot> I feel like I'm in a foreign country without knowing the language right now ha
21:52:14 <ski> if you don't have any preference, then i suppose i would do the conversion as soon as possible after `parseTags', which then means doing it in `parse'
21:52:25 <koala_bot> Yes, that's my preference.
21:52:26 <toshi_> anyone know how I can convert a [Char] -> Int, like "-1" to -1 ?
21:52:34 * ski doesn't know this library, is just following the type errors atm
21:52:45 <ski> > read "-1" :: Int
21:52:46 <lambdabot>   -1
21:53:06 <toshi_> ski: will that only work in ghci, or I can put that into a file as well?
21:53:06 <ski> toshi_ : also, `[Char]' is the same as `String'
21:53:13 <ski> toshi_ : both
21:53:21 <toshi_> thanks
21:53:28 <ski> > read "jkdhfgjk" :: Int
21:53:29 <lambdabot>   *Exception: Prelude.read: no parse
21:53:39 <ski> it will give an exception if it doesn't parse, though
21:54:29 <ski> > case (reads :: ReadS Int) "-1\n23" of [(n,rest)] -> (n,rest); _ -> error "parse error"
21:54:30 <lambdabot>   (-1,"\n23")
21:54:35 <toshi_> can the read function be mapped over a list?
21:54:37 <ski> > case (reads :: ReadS Int) "hsdfsdf\n23" of [(n,rest)] -> (n,rest); _ -> error "parse error"
21:54:38 <lambdabot>   *Exception: parse error
21:55:00 <ski> toshi_ : you can use `reads' like above if you want to catch and handle parse errors in your program
21:55:19 <ski> toshi_ : yes, every function can be mapped over a list, and `read' is an ordinary function
21:55:28 <toshi_> k, thanks a lot :D
21:56:01 <ski> > case (reads :: ReadS Int) "hsdfsdf\n23" of [(n,rest)] -> Just (n,rest); _ -> Nothing
21:56:03 <lambdabot>   Nothing
21:56:40 <ski> koala_bot> :t parseTags
21:56:57 <ion> > listToMaybe [ a | (a,"") <- reads "asdf" ] :: Maybe Integer
21:56:58 <lambdabot>   Nothing
21:57:01 <ion> > listToMaybe [ a | (a,"") <- reads "42" ] :: Maybe Integer
21:57:02 <lambdabot>   Just 42
21:58:00 <ski> koala_bot : i suspect there's some function of type `Tag a -> String' and `Tag a -> a' for extracting the name and value of a tag -- could you find them for me ?
21:58:52 <ski> hm
21:59:53 <koala_bot> ski Thisis really the only documentation I've been able to find :( http://community.haskell.org/~ndm/darcs/tagsoup/tagsoup.htm
21:59:54 <ski> hmmm
22:00:02 <koala_bot> THat's part of why I'm having so much trouble
22:00:16 * ski is currently looking at <http://hackage.haskell.org/packages/archive/tagsoup/0.12.6/doc/html/Text-HTML-TagSoup.html>
22:01:11 <koala_bot> I wish i'd seen this a few hours ago. argh
22:01:51 <ski> koala_bot : actually, i'm not sure i see the point of (/ reason why eyebloom suggested) using `filterM' over `filter', here
22:02:24 <ski> `filterM' is for when you want to do some a monadic effect during the condition running on each element of the list
22:02:40 <koala_bot> ski: Would "fromAttrib" do what  we need? The type dec on it is confusing but its description seems promising
22:03:42 <ski> iow, `filterM (return . isFoo) bars' is the same as `return (filter isFoo bars)' -- maybe eyebloom intended to add something more in there, otherwise i don't see the reason to change to `filterM'
22:03:59 <koala_bot> fromAttrib might make assocLookup irrelevant, which isn't bad
22:07:22 <ski> hm, yes, that sounds promising
22:07:54 <ski> you probably want to filter away the empty strings it apparently can return, to avoid looking up empty URIs
22:08:37 <ski> so i assume you pass `"href"' to `fromAttrib', then
22:08:52 <koala_bot> I'll have to a lot of filtering once this is working on a basic level - it's intended to work for only one domain or subdomain at a time
22:08:53 <koala_bot> haha
22:08:56 <koala_bot> I've got a ways to go :)
22:12:57 <ski> i think a list comprehension could be appropriate here, instead of `filter's and `maps'
22:13:13 <ski> koala_bot : try replacing the `filter'/`filterM' stuff with
22:13:15 <ski>   return [uri | tag <- parseTags doc , tag ~== TagOpen "a" [("class","")] , let uri = fromAttrib "href" tag , not (null uri)]
22:13:45 <koala_bot> I have changed it to    map (fromAttrib "href") (filter (~== "<a>") (parseTags doc))
22:13:47 <otters> :where (~==)
22:13:51 <otters> @where (~==)
22:13:51 <lambdabot> I know nothing about (~==).
22:13:52 <otters> damn it
22:13:59 <koala_bot> otters it's in my package
22:14:01 <ski> @index (~==)
22:14:01 <lambdabot> bzzt
22:14:05 <otters> ho
22:14:07 <otters> ofc
22:14:08 <ski> @hackage tagsoup
22:14:09 <lambdabot> http://hackage.haskell.org/package/tagsoup
22:14:11 <ski> there
22:14:18 <koala_bot> ski: is there any obvious reason why what I have won't work?
22:14:56 <ski> koala_bot : it will work (though i'd add an extra `filter' outside to take away empty uris), but i think my list comprehension is nicer :)
22:15:40 <koala_bot> :) Since i still have to build off it quite a bit I'm trying to go with what's both correct and intuitive (however bad form it may be), as leaving in code that I can't understand will be impossbile to build on as I complete this project
22:15:47 <koala_bot> And probably even harder to explain in the accompanying report lol
22:17:02 <ski> koala_bot : i'm not sure why you had the `"class"' in the original paste, but i don't think `"<a>"' will include that
22:17:40 <koala_bot> "class" was supposed to say "href" but I had forgotten to change it in the original paste. I didn't figure I would need to declare "href" in the original filter if I"m using fromAttrib to only pull "href" values anyway
22:17:54 <ski> (it depends on what exactly `parseTags "<a>"' returns, which i don't know)
22:18:02 <ski> oh
22:18:15 <ski> well, not all `a' tags include a `href'
22:18:25 <koala_bot> And I want to ignore those anyway :)
22:18:38 <ski> (e.g. `<a name="foo">Foo</a>')
22:18:48 <koala_bot> i'm not convinced that putting the href="" constraint would pull only anchors with href attributes
22:18:51 <ski> yeah, so probably use `TagOpen' then
22:19:13 <ski> well, i looked at the source of `(~==)' and it looks like that's what it'll do
22:19:23 <koala_bot> "We write "<div class=printfooter>" as syntactic sugar for TagOpen "div" [("class","printfooter")]."
22:20:14 <ski> ok, so maybe you can write something like `tag ~== "<a href=>"' or `tag ~== "<a href=\"\">"', then ..
22:20:45 <koala_bot> Theres' really no reason to. fromAttrib will still work if the attribute is not present.
22:20:52 <koala_bot> It just returns "" as if it had been href=""
22:21:10 <ski> oh, right
22:21:13 <koala_bot> :)
22:21:35 <ski> yeah, i suppose you could filter away both of these things at the same time
22:21:40 <koala_bot> SiteMapper.hs:32:24:     Couldn't match expected type `IO b0' with actual type `[b1]'     In the return type of a call of `map'
22:21:50 <ski> expression ?
22:22:09 <koala_bot> map (fromAttrib "href") (filter (~== "<a>") (parseTags doc))
22:22:30 <ski> i think you forgot to wrap this in `return'
22:22:50 <ski> also, you should wrap it in `filter (not . null)' before that, to actually remove the empty strings
22:22:56 <koala_bot> Wasn't sure if I needed to or not :) I'm not entirely following what return does
22:23:02 <ski> .. alternatively, write the list comprehension :)
22:23:16 <koala_bot> I will have to filter on a bunch of different factors in this function before I'm finished, so I'm just going to handle all of that later
22:23:17 <ski> `return' (here) converts from a type `Foo' to a type `IO Foo'
22:23:29 <koala_bot> I just need this basic version to compile so I can test before I move forward
22:23:57 <ski> since `parse :: String -> IO [String]' has `IO' in the result, you need `return' if you want to return a non-`IO'-value at the end
22:24:15 <ski> `return' is from wrapping a value in a monadic action (doing nothing except returning that value)
22:24:42 <ski> any type errors left ?
22:24:47 <koala_bot> SiteMapper.hs:19:35:     Couldn't match expected type `[t0]' with actual type `IO [[Char]]'     In the first argument of `(++)', namely `newURLs'     In the first argument of `crawl', namely `(newURLs ++ us)'     In the expression: crawl (newURLs ++ us) (u : visited)
22:25:47 <ski> btw, you should uncomment the rest of your type signatures, if you haven't done that yet
22:25:57 <ski> if you do that, does the error change ?
22:26:35 <koala_bot> type signature for everything but the bottom function are commented out. The error does not change. Should that line have a return?
22:26:43 <ski> which line ?
22:26:48 <ski> which function ?
22:27:00 <ski> hm
22:27:19 <ski> for some reason it seems to think `newURLs' is an `IO'-action
22:27:35 <ski> this must be (directly or indirectly) the fault of `linkLocs'
22:28:02 <ski> could you paste/annotate with your current code ?
22:28:32 <koala_bot> If I put in parentheses like this: linkLocs url visited = return (parse url)     my type error changes
22:28:50 <ski> yeah, `return' is a normal function, you have to use brackets there
22:29:01 <koala_bot> SiteMapper.hs:19:35:     Couldn't match expected type `[String]'                 with actual type `IO [[Char]]'     In the first argument of `(++)', namely `newURLs'     In the first argument of `crawl', namely `(newURLs ++ us)'     In the expression: crawl (newURLs ++ us) (u : visited)
22:29:12 <ski> .. except that you shouldn't use `return' in that place, that is
22:29:13 <koala_bot> oh
22:29:19 <koala_bot> no?
22:29:35 <koala_bot> without it it compiles :)
22:29:42 <ski> but *when* you use `return' on a complicated expression, you need to wrap the expression as usual, since `return' is just a normal function
22:30:21 <ski> koala_bot : could you annotate the paste with your latest code ?
22:30:59 <hpaste> koala_bot annotated “Update: Sitemap Generator” with “Sitemap Generator (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/65547#a65552
22:32:09 <ski> looks fine to me
22:32:24 <ski> be sure to check that uncommenting the type signatures doesn't lead to a type error
22:32:54 <ski> also, heed the hlint warnings/errors at the end !
22:33:59 * ski . o O ( "Make haste, but take heed." )
22:34:06 <ski> koala_bot : ok ?
22:34:18 <koala_bot> :) Yes.
22:34:21 <koala_bot> I have a question though
22:34:26 <ski> ok ?
22:34:59 <koala_bot> just a sec - finding an exmaple again
22:35:19 <koala_bot> okay
22:35:41 <koala_bot> pages with no anchor tags at all just don't return anything when I run the main func, but it seems all other pages are throwing an exception
22:36:20 <ski> possibly this is occuring in `parse'
22:36:33 <koala_bot> *** Exception: Maybe.fromJust: Nothing
22:36:43 <ski> (since you have commented out the `Left err -> ..err..' case there)
22:36:44 <ski> oh
22:37:07 <ski> there's only one `fromJust' in your code
22:37:09 <ski>   uri = fromJust $ parseURI url
22:37:12 <ski> at the end
22:37:31 <ski> so it appears that is failing
22:37:51 <ski> (or one of the libraries you use is calling `fromJust')
22:38:30 <ski> so, you could first try replacing that with
22:38:47 <ski>   uri = fromMaybe (error "testing") $ parseURI url
22:38:56 <ski> and see if the error changes
22:39:04 <ski> if it does, that is the place
22:39:18 <koala_bot> calling the downloadURL func directly on the URLs causing the exception does not produce the exception
22:40:26 <ski> and in that case, you either need to add more checking there (maybe do something different) -- or there's something wrong with the `url's passed to `downloadURL' : you should probably check this to make sure if that is the case or not
22:41:00 <ski> is there any redirects on the pages you get the error for ?
22:41:09 <koala_bot> no
22:41:16 <mgsloan> so, I may have done something quite stupid to my haskell packages.  I had issues with a user space and global packages, so I unregistered it.  After reinstalling, now my ghc-7.4.0 package depends on the old one..  I suppose I need to install ghc again?
22:41:34 <mgsloan> * user space and global template-haskell packages
22:41:36 <ski> ok, so i suppose there's some more cleaning that you need to do on the extracted urls
22:41:52 <ski> maybe there's initial and terminal quotes you need to replace ?
22:41:56 <ski> maybe something else
22:42:02 <koala_bot> ski: that's the thing - there shouldn't be any extracted urls :P    I'll fiddle with it.
22:42:28 <ski> koala_bot : yeah -- hopefully should should be able to keep going for some while now ..
22:42:33 * ski is pretty tired atm
22:42:42 <koala_bot> I really appreciate your help :) You're fantastic
22:42:49 * ski bows
22:45:17 <ski> koala_bot : i suppose i would enter code to make it print out the extracted URLs, to see what it's passing to `downloadURL'
22:45:34 * ski should go to sleep now, though
22:45:56 <koala_bot> :) Sweet dreams, oh helpful stranger.
22:46:45 <danharaj> Sometimes I peek into /r/programming to laugh at how inane the submissions are, or the comments.
22:46:58 <danharaj> This makes me feel slightly hypocritical ._.
22:47:38 <koala_bot> lol what's in r/programming, danharaj
22:48:11 <danharaj> bad programmers
22:48:18 <koala_bot> lol
22:48:38 <koala_bot> not unlike myself ;)
22:48:45 <ion> Please, share the best badness on -blah. :-)
22:49:07 <danharaj> No thanks I make a point of my derision being impersonal and abstract.
22:56:16 <koala_bot> Is there an easy way to check if a value exists in a list or not?
22:56:41 <c_wraith> :t elem
22:56:42 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
22:56:51 <koala_bot> thank you :)
22:59:38 <Peaker> @hoogle Eq a => a -> [a] -> Bool
22:59:39 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
22:59:39 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
22:59:39 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
23:01:39 <koala_bot> Peaker I'm having trouble getting that into a form that I can use as a filter
23:01:51 <koala_bot> like, remove all items in a list which appear in my other list
23:02:31 <Peaker> > [1,2,3] \\ [2,5]
23:02:32 <lambdabot>   [1,3]
23:02:46 <Peaker> > filter (`notElem` [2,5]) [1,2,3]
23:02:47 <lambdabot>   [1,3]
23:02:54 <Peaker> @type (\\)
23:02:55 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
23:03:35 <koala_bot> You're wonderful!
23:05:35 <Yigabu> tired of niggers?
23:05:37 <Yigabu> I am!
23:05:42 --- mode: ChanServ set +o Saizan
23:05:43 <Yigabu> However, I want a nigger with a big dick!
23:05:46 --- mode: Saizan set +b *!*Yigabu@*.170.67.163.dsl.dyn.telnor.net
23:05:47 --- kick: Yigabu was kicked by Saizan (Yigabu)
23:05:57 --- mode: Saizan set -o Saizan
23:06:31 <danharaj> I have no idea
23:06:36 <danharaj> why the Internet thinks racism is funny.
23:06:42 <danharaj> (But that's for -blah)
23:06:53 <koala_bot> is there any reason a filter expression should be causing a type error?
23:06:59 <koala_bot> :(
23:07:01 <danharaj> koala_bot: what's the error?
23:07:31 <koala_bot> Couldn't match expected type `IO [String]' with actual type `[a0]'     In the return type of a call of `filter'     In the expression:       filter ((/= "") . (`notElem` visited)) (parse url)     In an equation for `linkLocs':         linkLocs url visited           = filter ((/= "") . (`notElem` visited)) (parse url)
23:07:37 <danharaj> @where hpaste
23:07:37 <lambdabot> http://hpaste.org/
23:07:44 <danharaj> paste your code and the error there
23:08:24 <danharaj> Also I think you can figure out what the error is. :3
23:08:35 <hpaste> koala_bot annotated “Update: Sitemap Generator” with “Sitemap Generator (annotation) (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/65547#a65554
23:09:21 <danharaj> so filter returns a list right?
23:09:33 <danharaj> but you aren't returning a list, you are returning a list in IO.
23:10:42 <koala_bot> The only thing I could think to do it put a return around it but that throws errors as well
23:10:45 <koala_bot> is*
23:11:12 <Eduard_Munteanu> You're also giving a IO [String] to filter.
23:11:32 <koala_bot> i take it that's a no no?
23:11:52 <Saizan> ?type filter
23:11:53 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
23:12:01 <Saizan> the second argument is a list
23:12:22 <Saizan> so it can't match IO [String]
23:12:32 <koala_bot> I don't know how to do this then x.x
23:13:11 <koala_bot> is there a filter I can use with IO arguments?
23:13:26 <Saizan> linkLocs url visited = do parsed <- parse url; return (filter ((/= "").(`notElem` visited)) parsed)
23:14:16 <astor-> Whenever you go from IO  something to a pure function like filter you need to "unwrap" the value inside the IO to grab the String in your case.
23:15:17 <koala_bot> Saizan, that still throws an error
23:15:32 <koala_bot> astor: is saving it with <- generally how that unwrapping is done?
23:16:37 <danharaj> <- is just sugar.
23:16:58 <Saizan> koala_bot: which error?
23:17:04 <astor-> Yes what Saizan wrote. After his return statement you can stash all your pure transformation functions.
23:17:38 <Saizan> ah yeah ((/= "").(`notElem` visited)) is ill-typed
23:17:49 <hpaste> koala_bot annotated “Update: Sitemap Generator” with “Sitemap Generator (annotation) (annotation) (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/65547#a65555
23:18:58 <Saizan> koala_bot: ((/= "").(`notElem` visited)) = \str -> str `notElem` visited /= ""   and there you're trying to compare the result of notElem which is a Bool with a String
23:19:06 <Saizan> koala_bot: which won't work
23:19:10 <astor-> You can also use >>= but it can be confusing. You'll likely go back and read one more monad tutorial to make progress.
23:19:39 <Saizan> koala_bot: i guess you meant (\str -> str `notElem` visited && str /= "") ?
23:19:41 <koala_bot> astor if I had the time you bet I would :) Unfortunately I'm under some constraints that make youwonderful folks a lot faster of a resource as long asy ou'll tolerate me
23:21:37 <astor-> Simple solution is to always use <- to get rid of IO and use return if you need it back.
23:21:40 <koala_bot> So is it not possible to have a single filter call use multiple ->Bool functions to make a determination on the final list?
23:21:45 <koala_bot> Thanks astor :)
23:22:16 <astor-> all does that iirc
23:22:46 <koala_bot> ?
23:23:33 <astor-> ?type all
23:23:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
23:23:47 <astor-> No
23:24:45 <koala_bot> could I do (filter /="").(filter (`notElem` visited)) (parse url)?
23:25:11 <Saizan> koala_bot: i showed you how to do this with &&
23:25:25 <koala_bot> Saizan I'm sorrythat just didn't make sense to me, I'm afraid
23:25:43 <Saizan> koala_bot: (&&) is just the and operator
23:25:48 <Saizan> ?src (&&)
23:25:49 <lambdabot> True  && x = x
23:25:49 <lambdabot> False && _ = False
23:26:00 <koala_bot> I realize, but I wasn't sure how you were using it
23:26:25 <Saizan> to take the and of both conditions
23:26:58 <koala_bot> right but you were using lambda to apply to a specific string. Was that supposed to go into a list comprehension or something?
23:27:07 <Saizan> (filter p . filter q) is the same as (filter (\x -> q x && p x))
23:27:10 <astor-> all_funcs_true = foldr1 (&&) ??
23:27:29 <koala_bot> I've never seen a lambda used inside a filter before, Saizan. I see what you mean now.
23:27:46 <koala_bot> If it's all the same, though, I'll tick to the former as to me it's more intuitive and will be easier for me to write a report on in the morning :)
23:27:49 <koala_bot> stick*
23:27:52 <Saizan> you can use lambdas everywhere a function it's expected
23:28:05 <Saizan> s/it's/is/
23:28:07 <Peaker> astor-: why foldr1 and not foldr (&&) True ?
23:28:24 <Saizan> yeah, ok, as long as you get the composition right :)
23:29:17 <koala_bot> Which I'm currently not doing acording to the comipler :P Dangit Haskell!
23:30:46 <Saizan> linkLocs url visited = do parsed <- parse url; return ((filter (/= "") . filter (`notElem` visited)) parsed)
23:31:35 <koala_bot> weird, that's exactly what I have
23:31:37 <koala_bot> still an error
23:32:19 <Saizan> we're both missing a paren :)
23:32:46 <Saizan> actually, no
23:33:07 <hpaste> koala_bot annotated “Update: Sitemap Generator” with “Sitemap Generator” at http://hpaste.org/65547#a65556
23:33:41 <koala_bot> I type checked mine in prelude before pasting it into my file, so I'm not sure what the rpoblem is
23:34:45 <cheater_> type inference
23:34:55 <Saizan> koala_bot: return ((filter (/= "") . filter (`notElem` visited)) parsed)
23:34:55 <cheater_> give it a type signature to see where the type inference problem comes from
23:35:07 <Saizan> koala_bot: you missed the parens around the composition
23:35:27 <cheater_> interesting
23:35:50 <Saizan> koala_bot: function application takes precedence over any operator, so what you wrote was parsed as return (filter (..) . filter (..) parsed)
23:36:03 <koala_bot> Ah so I see :) Good catch thank you
23:37:00 <Saizan> koala_bot: if you're ok with ($) it'd be maybe better to write this as: return . filter (/= "") . filter (`notElem` visited) $ parsed
23:37:10 <Saizan> so there are less parens to get wrong
23:37:28 <koala_bot> I think I'm just going to avoid touching it anymore :P
23:37:34 <koala_bot> I feel like I'm building a house of cards
23:37:35 <koala_bot> lol
23:38:33 <Saizan> well, it's not that fragile once you had time to learn to pay attention to types and are more familiar with the syntax
23:39:16 <koala_bot> hehe. Definitely short on that kind of time. This functioning thing plus a write up is due in t-minus 8 hours.
23:39:18 <koala_bot> Gotta love that.
23:40:06 <koala_bot> I"m getting weird exceptions though when I try to run it
23:40:24 <koala_bot> *** Exception: Maybe.fromJust: Nothing   What kinds of things cause that?
23:43:33 <Saizan> probably your use of fromJust
23:43:49 <akosch> koala_bot: have you used the Maybe monad before?
23:44:15 <Saizan> akosch: i don't think we'd have time to introduce the Maybe monad :)
23:44:18 <koala_bot> Only a couple of times, and the use of fromJust is in the function that I have borrowed from elsewhere. I'm not familiar with how that is working
23:44:30 <Saizan> ?src fromJust
23:44:30 <lambdabot> fromJust Nothing  = undefined
23:44:30 <lambdabot> fromJust (Just x) = x
23:44:30 <akosch> Saizan: oh, ok :)
23:44:41 <koala_bot> My understanding is it allows a function to return either a type or the Nothing type
23:44:51 <Saizan> koala_bot: basically fromJust throws an exception if it's given Nothing
23:45:01 <koala_bot> ah
23:45:07 <koala_bot> I wonder how that's happening then
23:45:34 <Saizan> this could also be cause by another use of fromJust in one of the libraries you are using
23:45:56 <koala_bot> I don't suppose it tells you where it originated from?
23:46:04 <koala_bot> is there a trace setting somewhere? :P
23:46:19 <Saizan> you could replace that line with uri = fromMaybe (error "it came from here!") $ parseURI url
23:46:23 <Saizan> to make sure
23:47:07 <koala_bot> SiteMapper.hs:53:23: parse error on input `='
23:47:09 <koala_bot> it didn't like that at all :P
23:48:19 <akosch> koala_bot: if it's in your libraries you can get an idea where it's coming from if you compile with profiling and use the -xc RTS flag
23:48:30 <koala_bot> compile with profiling?
23:48:51 <akosch> koala_bot: -prof -auto-all flags for ghc
23:49:29 <akosch> koala_bot: but you'd need to have profiling versions of your libs as well
23:49:46 <koala_bot> I don't know how to do any of that. Typing that in was not effective.
23:50:56 <akosch> koala_bot: I would just stick to Saizan's method then, replace all occurrences of fromJust in your code with a more verbose version
23:51:09 <koala_bot> I've tried what he gave me but it won't compile
23:51:23 <koala_bot> oh hang on
23:51:55 <koala_bot> I keep forgetting that my text editor automatically indents with tabs when I start a new line
23:52:00 <koala_bot> it's been messing me up a lot :/
23:52:32 <koala_bot> Saizan: It indeed did "come from here!" so somehow I'm getting a Nothing all the way down there
23:53:21 <akosch> koala_bot: you could use Debug.Trace.trace to find out what's going on
23:54:32 <koala_bot> I think I can get it since it's in that part of the code rather than somewhere else.
23:54:41 <koala_bot> just have to remember how to print without messing up the rest of it
23:54:42 <koala_bot> lol
23:54:48 <Peaker> indenting with \t by default is one of the most horrible defaults in computing
