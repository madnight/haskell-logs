00:16:29 <kallisti> hmmm DSH is pretty interesting.
00:16:33 <kallisti> anyone used it?
00:16:50 <kallisti> it basically looks like a EDSL for database queries.
00:21:35 <DanBurton> @hackage DSH
00:21:35 <lambdabot> http://hackage.haskell.org/package/DSH
00:26:14 <shergill> are there functions to convert between rfc-2822/rfc-3339 (those outputted by the linux date command) to UTCTime?
00:27:03 <dmwit> ?hoogle parseTime
00:27:04 <lambdabot> Data.Time.Format class ParseTime t
00:27:04 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
00:27:22 <shergill> ah
00:27:24 <kallisti> also Takusen is interesting, but I don't know that I need that amount of safety.
00:29:57 <kallisti> I may give Takusen a try for my next DB-related project, rather than using HDBC.
00:33:08 <kallisti> http://hackage.haskell.org/packages/archive/Takusen/0.8.7/doc/html/Control-Exception-MonadIO.html#t:CaughtMonadIO
00:33:18 <kallisti> aha. look at that. The solution to the problem I was having earlier
00:33:25 <kallisti> attempting to catch IO exceptions within a MonadIO instance.
00:35:22 <Enigmagic> kallisti: also http://hackage.haskell.org/packages/archive/lifted-base/0.1.0.3/doc/html/Control-Exception-Lifted.html
00:35:37 <kallisti> oh... yes.
00:39:28 <kallisti> lifted-base is a good project.
00:42:15 <mekeor> > isUpper "1" -- numbers should be seen as upper case because they are (value) constructors (i mean like 'Bar 'in 'data Foo = Bar')...
00:42:16 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:42:16 <lambdabot>         against inferred type...
00:42:26 <mekeor> > isUpper '1'
00:42:27 <lambdabot>   False
00:42:31 <mekeor> bummer.
00:42:33 <kallisti> mekeor: what?
00:42:57 <kallisti> isUpper is based on Unicode standards, not on Haskell syntax.
00:43:02 <mekeor> 1 or 123 or 12341234 are values like Bool, False, etc.
00:43:07 <mekeor> kallisti: ah, ok
00:43:26 <mekeor> kallisti: so, unicode defines that '1' is lower case?
00:43:27 <dmwit> Also, 1 is not a constructor.
00:43:36 <dmwit> > isLower '1' -- I don't think so
00:43:37 <lambdabot>   False
00:43:42 <mekeor> oh
00:43:46 <mekeor> kay
00:43:50 <kallisti> the case of numerals is undefined.
00:43:55 <kallisti> so they're both false.
00:43:59 <mekeor> ok
00:44:14 <mekeor> (me "undefined" was a wrong term though...)
00:45:02 <mekeor> dmwit: why is 1 not a constructor? (with "constructor" i mean something like 'Bar' in 'data Foo = Bar | Baz')
00:45:12 <imc> hello :)
00:46:12 <kallisti> dmwit: I'm pretty sure numeric literals are considered a special case of overloaded constructors.
00:46:18 <bcoppens> @tell rasfar well coding crypto correctly is tricky, and while coding my own SSH client is fun, I don't think it's good practice to recommend using it for real stuff (plus, it still has some known bugs ;))
00:46:19 <lambdabot> Consider it noted.
00:47:27 <kallisti> thus why you can pattern match on them.
00:47:38 <mekeor> dmwit: :P
00:47:53 <kallisti> (interestingly you can also pattern match on IsString instances with OverloadedStrings on, making string literals a kind of overloaded constructor)
00:51:04 <kallisti> but it would be wrong to say that numeric literals are an "ordinary" constructor. They're even less ordinary than () and [] because they don't correspond to concrete types.
00:51:15 <kallisti> it's certainly incorrect to say that numerals are upper case as a result.
00:54:44 <kallisti> I would actually be interested to see other syntactic constructs overloaded. list syntax for example could easily be converted into a typeclass with a fromList method.
00:54:47 <hpaste> mmcdermo pasted “Query (Monad?)” at http://hpaste.org/65988
00:55:48 <kallisti> ideally (:) could be overloaded too, so that you can do "uncons" in patterns of arbitrary sequence types. The problem with that is the Haskell Report's definition of : as an uppercase symbol.
00:56:05 <shachaf> mmcdermo: join and fmap together are just (>>=)
00:56:10 <mmcdermo> I want to be able to provide a chain of functions, that act on "Database Responses" and offer up new "Queries" that then get executed
00:56:20 <mmcdermo> That's what I was thinking schachaf
00:56:41 <mmcdermo> I feel like I'm missing something though
00:56:47 <shachaf> I mean that join (fmap genOutput exe) === exe >>= getOutput
00:57:06 <mmcdermo> I knew writing bind felt familiar, but is genOutput something more general?
00:57:38 * shachaf didn't look at what this function actually does. :-)
00:58:19 <mmcdermo> =D well I appreciate the simplification none the less
00:58:23 <kallisti> mmcdermo: this highly resembles iteratees, enumerators, and other stream processing constructs.
00:58:30 <mmcdermo> figures =D
00:59:00 <kallisti> in fact if you look at Takusen you can see an example of a DB library that uses iteratees.
00:59:00 <shachaf> I think it's simpler than that.
00:59:03 <kallisti> yes.
00:59:18 <shachaf> Iteratees are not the answer to everything.
00:59:30 <kallisti> I don't think that was ever considered. :P
00:59:30 <mmcdermo> Well thanks kallisti, I'll take a look into Takusen at least to get some inspiration
01:00:16 <kallisti> also this may not be helpful to you, but Executor is equivalent to ReaderT Query IO QueryResponse
01:01:02 <mmcdermo> Sweet thanks kallisti
01:01:26 <kallisti> as to whether that's a useful abstraction, it depends on how you're using it.
01:01:39 <mmcdermo> I just got the feeling when writing this that I'm rewriting something more general
01:06:26 <kallisti> mmcdermo: also http://www.yesodweb.com/blog/2011/12/conduits
01:06:38 <kallisti> some more examples of stream processing
01:11:05 <mmcdermo> kallisti: perfect, looks current and fairly elegant
01:11:36 <kallisti> well, the implementation isn't quite so elegant, but yes it's quite nice.
01:12:29 <mmcdermo> It'd be ironic if I ended up using conduits, since this project also uses the snap framework instead of yesod
01:20:53 <mreh> can one define types via temlate haskell?
01:20:58 <mreh> can one define types via template haskell?
01:21:04 <mreh> that's better
01:22:36 <Saizan> you can create declarations in general
01:23:29 <mreh> excellent
01:23:59 <mreh> all I need now is some kind of first class labels
01:25:32 <hpaste> “ ” annotated “Query (Monad?)” with “Query (Monad?) (annotation)” at http://hpaste.org/65988#a65989
01:25:47 <shachaf> mmcdermo: You could probably turn your code into something like that, by the way. :-)
01:26:08 <shachaf> Actually the type that I defined is probably less good than your type.
01:26:22 <shachaf> ((a -> Either b c) vs. (Either (a -> b) (a -> c)).)
01:28:19 <mmcdermo> schachaf: I love the how succinct your solution is, though
01:29:00 <shachaf> The goal of #haskell is to turn any code sample provided into a one-liner.
01:29:31 <mmcdermo> Well then you achieved the #haskell ideal ;)
01:29:54 <shachaf> Well, but I made the type worse in the process.
01:30:56 <mmcdermo> In what sense though? Since the first parameter is unlikely to change when would problems arise in development
01:31:56 <shachaf> Well, the type Either (QueryResponse -> OutputGenerator) (QueryResponse -> Output) is better than the type QueryResponse -> Either OutputGenerator Output, if you can use it.
01:32:15 <shachaf> Because, for example, you can tell which fork of the Either it is without providing it a QueryResponse.
01:32:37 <mmcdermo> Ahhhh I see what you mean.
01:32:37 <shachaf> Whereas the latter type can *decide* which fork of the Either it is based on the QueryResponse.
01:33:31 <shachaf> Which is more flexible, of course, but the goal of types is to have as little flexibility as you can. :-)
01:34:11 <mmcdermo> Those are probably my favorite things so far learning haskell
01:34:39 <mmcdermo> Replacing "control flow" with pattern matching / Either / Maybe and the fact that most of my errors are caught at compile time
01:45:14 <|Steve|> Is (return . return) considered bad form?
01:45:36 <|Steve|> I could use \x -> return [x] in this particular case.
01:46:09 <kallisti> if there's no need for the generalization of return then sometimes it's clearer to use more specific constructors
01:46:11 <shachaf> return . (:[]) might be more polite.
01:46:23 <kallisti> but return . return in itself is not bad, no.
01:46:24 <nicoo> |Steve|: Well, (return . return) is point-free, but perhaps less readable than (return .(:[]))
01:46:28 <edwardk> |Steve| its fine
01:46:32 <merijn> If we're listing alternatives: fmap return :p
01:46:44 <|Steve|> Heh, . (:[]) just looks ridiculous.
01:46:50 <nicoo> It's fine, just depends on context
01:46:51 <shachaf> (:[]) is a pretty common idiom.
01:46:52 <merijn> nicoo: I strongly disagree, I think "(return . (:[]))" is completely unreadable
01:47:05 <shachaf> return . return might be OK too -- depends on the context.
01:47:18 <shachaf> @quote eat.a.comment
01:47:19 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
01:47:28 <nicoo> merijn: Well, depends on context too; (:[]) is pretty idiomatic in some stuff
01:47:30 <edwardk> shachaf: =)
01:47:41 <kallisti> > (:[])>=>(:[])>=>(:[]) $ "cookies"   -- totem pole operator
01:47:42 <lambdabot>   ["cookies"]
01:47:49 <edwardk> (:[]) is a rather verbose way to write 'pure' =)
01:47:55 <nicoo> xD kallisti
01:47:59 <kallisti> also 'return'
01:48:08 <kallisti> well, minus the verbose part.
01:48:16 <mux> return . pure ? :)
01:48:23 <|Steve|> What is pure?
01:48:28 <quicksilver> merijn: (return . (:[])) is much more readable than (return . return)
01:48:30 <shachaf> edwardk: Polymorphism isn't always a good thing...
01:48:31 <merijn> :t pure
01:48:31 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
01:48:32 <edwardk> pure is 'return' for Applicatives
01:48:54 <edwardk> which would logically be a superclass for Monad if we could ever get that through the language spec
01:48:56 <shachaf> More polymorphism means that the reader has to do a bit of type inference for themselves to figure out what's going on.
01:49:05 <shachaf> Also, the name "pure" annoys me.
01:49:15 <edwardk> usually i'd just write return [x] inside of do notation
01:49:29 <shachaf> That's good too.
01:49:46 <edwardk> that has the benefit of being maximally legible
01:49:57 <kallisti> :t fix (:[])>=>) -- obligatory infinite totem pole operator
01:49:59 <lambdabot> parse error on input `)'
01:50:00 <edwardk> i tend not to go point free when [] is involved
01:50:06 <kallisti> :t fix ((:[])>=>) -- obligatory infinite totem pole operator
01:50:07 <lambdabot> forall b c. b -> [c]
01:50:35 <edwardk> wow installing wxhaskell on macosx is a pain in the behind
01:50:46 <shachaf> edwardk: s/on macosx //, in my experience.
01:51:16 <edwardk> silly me thinking i was just going to slap up a ui window ;)
01:51:26 <Saizan> edwardk: i thought you'd be using your class for monoids over some set
01:51:40 <edwardk> saizan: there is that
01:52:12 <merijn> edwardk: Every time I think "I'll just slap a UI on this code so my non-programmer friends can use it" I always decide "f- it, not worth it for something I don't get paid for" within an hour :p
01:52:19 <edwardk> hah
01:52:32 <quicksilver> WX makes it fairly easy IME
01:52:33 <shachaf> Some environments make it very easy to slap up a UI window.
01:52:36 <edwardk> i mostly just want to be able to put up a nice window and watch it draw, and i hate glut
01:52:43 <Enigmagic> i just do it in html
01:52:52 <quicksilver> I wrote a image resizer in WX quite quickly
01:53:04 <shachaf> HTML is pretty popular for that these days, yes.
01:53:11 <shachaf> But then there are other complications.
01:53:21 <merijn> Enigmagic: That's one thing I've been thinking of defaulting to, but then again HTML has it's own set of complications
01:53:21 <edwardk> Enigmagic: yeah but its rather annoying to render a super high quality metropolis light transport image as a multiframe gif just to add samples as i run ;)
01:53:33 <edwardk> and deal with palette quantization of course ;)
01:53:46 <shachaf> edwardk: You don't need to use a GIF!
01:53:52 <shachaf> It's a horrible format. There are better ways to do animation.
01:54:04 <edwardk> shachaf: ok, well, motion png, etc.
01:54:07 <shergill> hey, edwardk is being tumblr compliant
01:54:13 <shergill> gifs all the way!
01:54:21 <Enigmagic> edwardk: depends on how fast it needs to run? i just dump stuff down to the browser and glue up a little javascript
01:54:43 <shachaf> edwardk: You could probably generate an actual video file these days...
01:54:47 <edwardk> enigmagic: ~40 million rays a second
01:55:03 <shachaf> Or a set of frames, or whatever you want.
01:55:11 <shachaf> Anyway, yes, it's annoying.
01:55:16 <Enigmagic> edwardk: guess you're boned then
01:55:22 <edwardk> shachaf: well, interactivity is preferred ;)
01:56:44 <Jafet> https://saywh.at/jafet/mb.mkv dumped JPEG files from an SDL program and stitched them with ffmpeg
01:57:13 <edwardk> that wants a password =P
01:57:23 <Jafet> The problem with GUI toolkits is that none of them aid proper UI design in any way.
01:57:44 <Jafet> Wait, you don't know my password?
01:57:59 <mux> @faq Can haskell enforce HIGs at the type-level?
01:57:59 <lambdabot> The answer is: Yes! Haskell can do that.
01:58:08 <ivanm> edwardk: got a minute?
01:58:20 <edwardk> ivanm: bout to head to bed, but a quick one, sure
01:58:20 <shachaf> Jafet: I don't want to type your password! The certificate is issued by some weird organization.
01:58:58 <ivanm> edwardk: if parsec has try-based semantics and polyparse has commit-based, what does attoparsec have?  It has try = id, and no commit...
01:59:15 <edwardk> attoparsec has always backtracking semantics
01:59:27 <edwardk> which is fine because it doesn't try to report errors in a meaningful way
01:59:32 <ivanm> *nod*
01:59:37 <edwardk> and its used in short snippets in practice
01:59:58 <ivanm> whereas in polyparse the point of commit is to improve performance by stating not to do any backtracking?
02:00:01 <Jafet> https://saywh.at/mb.mkv
02:01:57 <edwardk> ivanm: yeah
02:02:04 <ivanm> *nod*
02:02:17 <edwardk> bos added a smarter try at one point to attoparsec but it slowed his benchmarks down
02:02:28 <ivanm> edwardk: so why wouldn't you use attoparsec for longer snippets?
02:02:49 <edwardk> because of the lack of backtracking. ;) its a remarkably circular argument
02:02:51 <ivanm> just because parsec can tell you exactly where the error occurred?
02:02:58 <edwardk> er because of the over-backtracking
02:03:02 <ivanm> heh
02:03:17 <ivanm> how could it over-backtrack?
02:05:06 <quicksilver> the performance hit from backtracking only matters when it matters
02:05:15 <edwardk> well because if a parser was rejected after consuming input, it could go back up and try another branch. this means you can get weird successes, and also that it can't gc those possible backtracking opportunities
02:05:20 <ivanm> quicksilver: heh
02:05:29 <ivanm> edwardk: *nod*
02:05:38 <ivanm> so it could depend on the actual format or parser implementation?
02:05:45 <edwardk> yes
02:05:52 <quicksilver> which is to say, it matters much more in some grammars than others, and even then whether it matters depends on your workload (size of typical input to parse, and the speed of parsing you require)
02:06:17 <quicksilver> there are definitely workloads when the difference between a 10ms parse and 60ms parse is uninteresting.
02:06:18 <Ptival> Jafet: looks Mandelbrot-cool :3
02:07:03 <osa1> I'm writing a websocket server with haskell, I'm planning to give each user an unique ID and save userSockets using IDs as keys, what data structure are good for this? Data.Map?
02:10:24 <merijn> osa1: Should be fine, I think. If IDs can be Int's you can be slightly faster using Data.IntMap. But other than that, don't over-optimise before profiling
02:11:10 <osa1> merijn: oh I didn't know we have Data.IntMap. thanks.
02:19:29 * hackagebot doctest 0.6.0.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.6.0.1 (SimonHengel)
02:37:13 <osa1> is there a case-insensitive version of `string` in parsec?
02:38:16 <quicksilver> no. you could fold case in a lexing stage
02:38:46 <ivanm> quicksilver: though wouldn't that cause issues if you need to parse other aspects in a case-sensitive manner?
02:39:24 <ivanm> I had something similar for graphviz where I was tempted to use Text's foldedCase mode, but as I need to parse in the actual strings provided for labels, etc. it wasn't feasible
02:39:32 <quicksilver> indeed.
02:40:04 <quicksilver> hard to give parser advice without knowing more about the use case :)
02:40:25 <quicksilver> in a typical case-insensitive programming language, keywords are case insensitive but string literals obviously aren't
02:40:34 <quicksilver> so you can separate that at lex time.
02:41:06 <osa1> quicksilver: I'm parsing commands coming over a websocket as Data.Text. command names are case-insensitive but command params may be case sensitive
02:42:46 <Philippa> osa1: it's probably easier to start with a case-insensitive version of char, then reimplement string in terms of it
02:43:24 <ivanm> yeah, I've done that
02:43:52 <quicksilver> if the command name is always the first token on the line then you may indeed be able to solve this one at lex time.
02:44:08 <quicksilver> there is nothing wrong with writing a case-insensitive version of string though :)
02:47:21 <Philippa> disclaimer: I'm assuming that you're using a notion of case that works character-at-a-time, otherwise I suspect you're in for hard work
02:47:38 <osa1> yeah it's always the first token. I didn't have a lexer though, where can I know more about parsec lexers?
02:48:06 <quicksilver> I have tended to write lexers by hand
02:48:18 <ivanm> yeah, if you can assume that you're only parsing ASCII for keywords, then case-insensitive-character-at-a-time is OK
02:48:22 <quicksilver> with type (String -> [Token]) or (Text -> [Token])
02:48:37 <quicksilver> and then write a parsec parser over Tokens instead of strings.
02:48:40 <ivanm> quicksilver: rather than just trying to merge the lexing stage with the parsing stage?
02:48:49 <quicksilver> yes, I find this way more pleasant
02:48:54 <ivanm> (as most parsec/polyparse/attoparsec/etc. parsers tend to be)
02:48:56 <ivanm> hmmm
02:49:06 <quicksilver> especially when dealing with string literals with escaped internal quotes
02:49:08 <quicksilver> that kind of thing.
02:49:24 <Philippa> yeah, I use explicit lexing for PL implementations
02:49:43 <Philippa> merged works in a pinch, but it's slightly more error-prone
02:49:49 <quicksilver> it's independently testable
02:49:57 <quicksilver> and it makes the actual parser look a lot simpler
02:50:00 <Philippa> rather: slightly more prone to errors you'll have a hard time spotting
02:50:15 <osa1> ok, thanks everyone, I'm away for lunch
02:50:28 <Philippa> well, it sure saves you a lot of headscratching about try if you have a lang that's LL(1) post-lex but not pre
02:57:12 <vivekn> Are referentially transparent functions automatically memoised in haskell
02:57:41 <Tomsik> Nope
02:58:04 <Jafet> They're referentially transparent, so they can't go to the store and buy you more memory.
02:59:48 <vivekn> Thanks
03:01:48 <captmario> ciao a tutti
03:01:53 <captmario> lista!
03:02:45 <quicksilver> perhaps you are after pirated software or movies. Maybe you could consider, instead, learning haskell. It's really great, and ultimately much more enjoyable than consuming illegal content.
03:03:06 <Tomsik> What.
03:04:13 <Saizan> Philippa: what do you use as the token type? something like data Token = Paren Bool | Keyword String | Var String | Literal Lit or simpler?
03:07:06 <zhulikas> ehh, that cabal...
03:07:10 <zhulikas> with all the broken dependences
03:07:10 <zhulikas> :|
03:07:31 <zhulikas> it's so tiring
03:07:58 <zhulikas> does anybody know a fast solution?
03:08:13 <zhulikas> wrong package versions, updating packages and stuff...
03:09:49 <zhulikas> just deleted the whole ~/.cabal...
03:09:56 <yasar> what is this mean: Basically, a monad is a way of saying "we'll be carrying along and combining, in some specific manner, values with some extra information attached to them, which most functions don't need to worry about".
03:11:47 <shurikas> yasar, monad is a container for data. Also monad has some special way of manipulating that data
03:12:37 <shachaf> shurikas: Please don't spread these rumours. :-(
03:12:45 <shachaf> yasar: Also you.
03:13:00 <mux> here we go again. I was waiting for someone to object to the container analogy
03:13:08 <shachaf> x :: M a for some monad M isn't an "a" "with some extra information".
03:13:21 <shachaf> It just doesn't contain an "a". To say that it contains an "a" is misleading.
03:13:26 <yasar> shachaf: what?
03:14:05 <liyang> What about the one with monads being containers for computations?
03:14:22 <shachaf> Containers for computations?
03:15:26 <shurikas> shachaf, well, that's not a rumour, that's how I understand it
03:15:31 <shurikas> so please, explain it to me as well :D
03:15:39 <Tomsik> data X a = X; instance Monad X where (>>=) a b = X; return a = X
03:15:43 <yasar> I didn't understand it at all :)
03:15:47 <shachaf> shurikas: getLine :: IO String does not contain a String.
03:15:51 <liyang> (Monad m => m a) is a computation that when run (and if it ever returns), delivers you a result of type a.
03:15:55 <shurikas> oh please, no IO
03:16:01 <shurikas> take any other monad
03:16:01 <shachaf> shurikas: State S String
03:16:01 <ChristianS> monads are not containers
03:16:05 <shachaf> r -> String
03:16:11 <shachaf> The moand Tomsik mentioned.
03:16:13 <shachaf> Parser String
03:16:34 <liyang> return gives you the trivial computation. >>= gives you a way to chain computations together.
03:16:35 <shachaf> Cont r String (sometimes)
03:16:43 <shachaf> Maybe String
03:16:44 <shachaf> [String]
03:16:52 <shachaf> ST s String
03:17:01 <shachaf> Either e String
03:17:23 <cwl> In TimeoutManager of Snap, I saw @_ <- tryPutMVar morePlease ()@
03:17:28 <liyang> But definitely not data containers. That analogy breaks down pretty quickly.
03:17:29 <cwl> what does it do
03:17:32 <cwl> http://stackoverflow.com/questions/9869763/timeoutmanager-uses-tryputmvar-to-put-nothing
03:17:41 <shachaf> liyang: OK, for an appropriate definition of "computation" and "run".
03:18:01 <shachaf> liyang: That analogy is OK if properly explained/qualified, but there's no real reason to use the word "container" in it.
03:18:29 <shachaf> cwl: Are you asking what tryPutMVar does?
03:18:53 <shachaf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html answers that.
03:19:15 <edwardk> cwl: it isn't putting 'nothing' in it. its putting a () in it. someone may be blocked waiting for that mvar
03:19:24 <cwl> shachaf: I know what it does, but it seems useless in timeoutmanager
03:19:33 <edwardk> putting something in it lets them get it and continue on their way
03:19:34 <liyang> shachaf: You're right. I think 'container' is possibly redundant. Probably put there because people have problems thinking of computations (rather than their result) as values.
03:19:49 <cwl> edwardk: aha, for blocking purpose
03:20:14 <shachaf> cwl: Yes, that's generally the meaning you can expect when you see MVar ()
03:20:16 <yasar> When you monad, do you mean something like functions in imperative languages?
03:20:20 <shachaf> Since that can be ither "empty" or "full".
03:20:35 <shachaf> yasar: No.
03:21:23 <yasar> As much as I understand, they do stuff and may or may not return a value like functions in imperative languages.
03:21:34 <ChristianS> yasar: no
03:21:50 <edwardk> yasar: that is _one_ application of them, but monads are much broader than that
03:22:33 <yasar> How much haskell do I need to know in order to get to know them?
03:22:33 <shachaf> It's correct, strictly speaking, given an appropriate definition of "do stuff" and "return a value" and "functions in imperative languages".
03:22:48 <shachaf> But that's probably not the definition you were thinking of.
03:22:59 <edwardk> yasar: a day or two worth of going through "Learn You a Haskell" will probably get you to them.
03:23:22 <shachaf> yasar: The FAQ is also good.
03:23:23 <shachaf> @where faq
03:23:24 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
03:23:36 <shachaf> I wish it had better GoogleRank.
03:23:57 <Tomsik> It's easiest to get that that monad buisness is about by just getting to know a few concrete examples
03:24:06 <shachaf> == Tomsik
03:24:27 <timthelion> yasar: you don't need to know anything of Haskell.  Here's the thing, functions, in generall, have fairly arbitrary order of evaluation.  Monads are functions which have deterministic order of evaluation.  Monadic functions are a subset of all functions.  Since they have an order of evaluation they seem like imperitive functions.
03:24:29 <Tomsik> like lists, state, reader, IO, ST etc.
03:24:58 <edwardk> shachaf: i think mine has steadily drifted down over the years ;)
03:25:25 <shachaf> timthelion: What you just said was rather unhelpful, I think, to someone figuring out what monads are.
03:25:39 <edwardk> apparently comonad.com is down to 4 these days
03:25:45 <shachaf> Given that they have very little to do with order of evaluation in general.
03:26:14 <merijn> Tomsik: You forgot Maybe, which is I think by far the easiest of the bunch
03:26:31 <Tomsik> Oh, right
03:26:33 <Tomsik> and Either
03:27:04 <liyang> Monadic parsers are another example.
03:27:10 <liyang> But obviously.
03:27:51 <merijn> liyang: Yes, but those are far less trivial than Maybe, Either and List. Which is what makes those a good starting point
03:28:29 <shachaf> I think parsers and so on are a better starting point than Maybe/Either/[]
03:29:16 <liyang> Oh, and trees with substitution as bind.
03:29:27 * liyang feels like he's trolling here.
03:29:39 <shachaf> liyang: _Programming in Haskell_ starts with parsers.
03:29:49 <shachaf> Then it moves on to IO, and then says "oh, look, these two have something in common".
03:30:04 <liyang> shachaf: I know. I know that book fairly well.
03:30:18 <shachaf> It's a good book.
03:30:50 <ivanm> preflex: seen kolmodin
03:30:50 <preflex>  kolmodin was last seen on #ghc 98 days, 15 hours, 10 minutes and 50 seconds ago, saying: ping Igloo
03:31:27 <reinoud> the Programming in Haskell book is the O'reiley (spelling?) book?
03:31:44 <Tomsik> I've never used Haskell parsers actually, is it much different from usual parser generators like yacc?
03:32:01 <shachaf> reinoud: No.
03:32:04 <ivanm> reinoud: no, that's by Graham Hutton
03:32:10 <shachaf> Tomsik: Pretty different.
03:32:13 <ivanm> RWH is the O'Reilly one
03:32:28 <ivanm> Tomsik: happy is more like yacc IIUC
03:32:38 <Tomsik> IIUC?
03:32:41 <reinoud> tnx
03:32:43 <Tomsik> What's that?
03:32:43 <aristid> reinoud: useful tip: if you're not sure how to spell a word like o'reilly, just type it in google, and use the spelling it suggests :)
03:32:48 <ivanm> Tomsik: If I Understand Correctly
03:32:51 <reinoud> :-)
03:33:38 <liyang> Seriously though. If you're not comfortable with the idea of algebraic structures (monoids, groups, rings &c.) as many programmers aren't, then you're better off stick with concrete examples until you get that 'ah-hah!' moment (then you go dig deeper), instead of asking deep questions like "What is a monad?"
03:33:39 <reinoud> bbl
03:33:48 <liyang> aristid: O'Really?
03:34:18 <merijn> I agree, you're better of learning the haskell basics and understanding the type system
03:34:24 <aristid> liyang: haha :P
03:34:35 <merijn> Even if you don't understand monads the functions will be perfectly obvious when considered in context
03:34:54 <merijn> (After looking at their type signatures, of course)
03:35:11 <zhulikas> how can I unregister all ghc packages at once?
03:35:15 <aristid> and imagining the specialised type structure :P
03:35:26 <zhulikas> ghc-pkg
03:35:46 <aristid> zhulikas: only user packages? or really ALL of them?
03:35:48 <merijn> aristid: Manually doing the substitution is probably one of the best ways to start understanding monads anyway
03:35:56 <zhulikas> aristid, I guess user packages
03:36:03 <hiptobecubic> merijn, which substitution is that?
03:36:07 <zhulikas> yes, user packages.
03:36:13 <aristid> zhulikas: easiest way might be deleting the whole ~/.ghc directory :D
03:36:23 <zhulikas> I see...
03:36:29 <zhulikas> I already deleted ~/.cabal
03:36:35 <zhulikas> going after .ghc then
03:36:37 <zhulikas> thanks
03:36:37 <zhulikas> :|
03:36:42 <aristid> zhulikas: oh yeah, .cabal is just for cabal :)
03:36:44 <liyang> Take a backup.
03:36:46 <ivanm> anyone know what's happening about binary using blaze-builder?
03:36:53 <shachaf> aristid: Well, .ghc references .cabal usually.
03:37:02 <shachaf> Also, what liyang said. Don't delete, just rename.
03:37:06 <zhulikas> ok, setuping the environment again
03:37:08 <merijn> hiptobecubic: General monad type signature (i.e. return/>>=) to specialised, i.e. changing "a -> m a" into "a -> Maybe a" etc. especially for more complex and intermediate signatures
03:37:12 <zhulikas> meh. Deleted everything
03:37:16 <zhulikas> it's a VM anyway
03:37:19 <zhulikas> on my own laptop
03:37:32 <hiptobecubic> merijn, ah. sure.
03:55:07 <shergill> is there a haskell library which helps in figuring out, given a timezone (sans daylight savings annotation) and a date+time, whether daylight savings was active or not?
03:55:48 <edwardk> well that can vary even by county within the zipcode
03:55:55 <edwardk> er within the timezone
03:56:45 <ggreg> hi all
03:57:09 <ivanm> edwardk: I thought you had gone to bed...
03:57:17 <shergill> well they can vary by country sure, eg eastern time zone has different behavior (since 2007) between north america and south america
03:57:30 <merijn> shergill: Portable or will being OS specific suffice? POSIX probably has some locale based function that let you query this info
03:57:35 <edwardk> ivanm: i was waiting for the native gtk+ cocoa bindings to install. my mistake ;)
03:57:40 <ivanm> heh
03:57:55 <shergill> merijn: os specific works so long as os is linux
03:59:28 <edwardk> shergill:  i was referring to the fact that at least in Indiana, parts of the state split across timezones, and it at least used to be that parts of it switched to daylight savings time at different times
03:59:35 <edwardk> i think that latter part is no longer the case
04:00:40 <edwardk> it used to be something like 75% of the state was in the eastern time zone, but didn't observe daylight savings time
04:01:02 <liyang> shergill: it's a proven NP-Hard problem. :(
04:01:11 <edwardk> and other parts were EST with DST, and another part was central ;)
04:01:19 <ChristianS> usually the zoneinfo database is used for that kind of stuff: http://en.wikipedia.org/wiki/Tz_database , but i don't know if there is a haskell binding
04:01:31 <shergill> merijn: thanks for the thought/idea. i'll have more luck searching for options there
04:01:32 <shergill> edwardk: ah k
04:01:41 <merijn> shergill: Posix (and thus also linux) defines a "tm_isdst" which is to be non-zero when DST is active
04:02:05 <merijn> It's in the struct tm defined in time.h, maybe one of the haskell posix wrappers exposes it
04:02:12 <shergill> merijn: yep, that's what my googling yielded. specifically, http://stackoverflow.com/questions/5288275/detect-dst-flag-of-future-date-in-c
04:02:14 <merijn> If not, you can use the FFI and a small C function to get it
04:02:39 <edwardk> ok, real sleep time now =)
04:02:44 <merijn> shergill: Looks like "man localtime" gives a bunch of functions that return that struct
04:03:01 <merijn> So you just need to find one close to what you want and look up a haskell wrapper of write one yourself
04:03:09 <liyang> shergill, ChristianS: There is a library for this: http://hackage.haskell.org/package/timezone-olson
04:07:29 <liyang> I remember looking at it some time ago and deciding I frankly didn't care enough (neither of the two timezones I was dealing with at the time actually used DST) to deal with the complexity.
04:13:20 <adnauseam> ls
04:13:45 <ChristianS> not a directory: #haskell
04:13:50 <kallisti> adnauseam: bin   dev  home        lib    lib64  mnt  proc  run   selinux  sys  usr  vmlinuz
04:13:53 <kallisti> boot  etc  initrd.img  lib32  media  opt  root  sbin  srv      tmp  var
04:14:46 <merijn> kallisti: Hah, I would be very surprised by a number of those dirs if they suddenly showed up in my ls output :p
04:15:09 <kallisti> oh? which ones?
04:15:23 <adnauseam> kallisti - hah ;p  yea i kind of slipped and thought i was tabbing into my term ;p
04:15:40 <merijn> kallisti: lib32, lib64, proc, selinux, vmlinuz, initrd.img, srv, media
04:15:52 <kallisti> ah yes. many of those are empty actually.
04:16:34 <merijn> Actually, run and opt too now that I double check :p
04:16:37 <adnauseam> it is frightening what can we get away with not knowing and still make a box with this many wires run
04:17:17 <kallisti> merijn: what kind of distro are you running?
04:17:28 <kallisti> adnauseam: I do that fairly often.
04:17:56 <merijn> kallisti: NaA (Not an Answer) :p
04:18:12 <merijn> Flawed assumption that I'm running linux at all :p
04:18:27 <kallisti> merijn: ah.
04:18:38 <liyang> COMMAND.COM MSDOS.SYS IO.SYS CONFIG.SYS AUTOEXEC.BAT
04:18:41 <DMcGill> adnauseam: not frightning but inspiring that we can build on others' successes rather than spend our time understanding their work!
04:18:42 <merijn> The servers are all BSD/Solaris and my personal box is OSX :p
04:18:46 <liyang> (it's a slow machine.)
04:18:54 <kallisti> liyang: :_(
04:18:56 <merijn> liyang: hah
04:18:57 <DMcGill> human knowledge builds up and it'd take an awful lot to set it back
04:19:01 <adnauseam> DMcGill: too true. too true.
04:19:18 <adnauseam> see i fear that might be optimistic
04:19:24 <adnauseam> back in the day it took a torch
04:19:25 <merijn> In the grand scheme of things it doesn't take that much to set it back
04:19:45 <kallisti> :t lanchMissiles
04:19:46 <lambdabot> Not in scope: `lanchMissiles'
04:19:49 <merijn> A couple of big nukes or asteroids...
04:19:56 <kallisti> oops, typo.
04:20:02 <merijn> Which in the scope of a universe is barely a blip on the radar
04:20:05 <adnauseam> lucnh missiles!
04:20:20 <merijn> lunch missiles?
04:20:22 <DMcGill> It's off topic, but hpmor is a story set in the Potter universe and it explores the fact that the muggles are marching forwards and have been to the moon and so on while wizard society hasn't really changed in the last 500 years
04:20:23 <kallisti> anyone by chance interested in Selenium 2 bindings for Haskell?
04:20:31 <kallisti> I want some test subjects. :>
04:20:38 <liyang> kallisti: North Korea are planning on doing just that next month.
04:20:51 <kallisti> sounds good.
04:21:09 <adnauseam> merijn: well considering someone out there thought it a good idea to categorize pizza as being a salad - do lunch missiles really surprise you ?:P
04:21:19 <liyang> http://www.bloomberg.com/news/2012-03-25/obama-warns-north-korea-rocket-jeopardizes-future-negotiations.html if anyone cares.
04:21:26 <ChristianS> i hear they don't have much else to eat in north korea.
04:21:59 <adnauseam> liyang: what's more frightening is that souel is threatening n.korea that it would shoot the missile down
04:22:02 <merijn> adnauseam: I don't remember the exact context, so I can't clarify for you. But I do know that line while nice and catchy is completely out of context
04:22:16 <merijn> adnauseam: I remember reading up on it and not thinking it was such a dumb decision
04:22:32 <kallisti> liyang: nice photo op
04:22:41 <kallisti> I'm sure those binoculars help him see a lot.
04:23:27 <adnauseam> technically speaking, it's not too different from a greek salad with croutons, a bit heated up and melted but aye. still isn't as healthy and any frenchman out there would certanly froun at this :P
04:24:37 <liyang> kallisti: I'm sure he saw more than this guy: http://www.telegraph.co.uk/news/picturegalleries/worldnews/3274186/George-W-Bush-in-pictures.html?image=20
04:25:00 <kallisti> liyang: bahahahaha
04:35:36 <adnauseam> hrm, how would i create a list of all hours of the day in 24 hour format plus minutes and retrieve the ones with end with 3 similar digits o_0
04:35:46 <adnauseam> like 12:22, 13:33, 14:44
04:35:52 <ivanm> why create a list?
04:35:56 <ivanm> rather than generating them directly?
04:36:53 <adnauseam> with a list comprehension ?
04:37:54 <adnauseam> i don't know how to go about generating them directly, i think
04:38:09 <kallisti> I'm not even sure what "generate them directly" means.
04:38:48 * adnauseam hands kallisti a beer
04:38:52 <adnauseam> we in the same club, we
04:39:11 <Ptival> why generate all then filter, rather than generate intelligently
04:39:51 <adnauseam> training? since i think i don't know how to go about generate things intelligently yet :/
04:39:56 <Ptival> it's easy in this case to avoid generating all possible hours just to filter out a few ones
04:40:33 <quicksilver> > [ (h,m) | m <- [0..59], h<-[0..23], (==1) . length . nub . take 3 . reverse $ (show h ++ show m) ]
04:40:34 <lambdabot>   [(0,0),(1,1),(11,1),(2,2),(22,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),...
04:40:42 <kallisti> oh I didn't catch the filtering part.
04:40:48 <quicksilver> ^^ not actually right, although it does get the right answers
04:41:01 <adnauseam> oh that is brilliant quicksilver
04:41:06 <quicksilver> along with a bunch of wrong ones because it doesn't put the leading '0' on 1-digit minutes.
04:41:26 <adnauseam> hmm, would (h,mm) work you think?
04:41:26 <quicksilver> > [ (h,m) | m <- [0..59], h<-[0..23], (==1) . length . nub . take 3 . reverse $ (show h ++ (if m < 10 then "0":show m else show m) ]
04:41:27 <lambdabot>   <no location info>: parse error on input `]'
04:41:32 <quicksilver> > [ (h,m) | m <- [0..59], h<-[0..23], (==1) . length . nub . take 3 . reverse $ (show h ++ (if m < 10 then "0":show m else show m)) ]
04:41:32 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:41:33 <lambdabot>         against inferred type...
04:41:46 <adnauseam> > [ (h,mm) | m <- [0..59], h<-[0..23], (==1) . length . nub . take 3 . reverse $ (show h ++ show m) ]
04:41:47 <lambdabot>   Not in scope: `mm'
04:42:20 <adnauseam> i'll go play with that
04:42:21 <Ptival> > [ [a, b, ':', b, b] | a <- ['0', '1'], b <- ['0'..'5'] ]
04:42:22 <lambdabot>   ["00:00","01:11","02:22","03:33","04:44","05:55","10:00","11:11","12:22","1...
04:42:30 <adnauseam> woah
04:42:32 <adnauseam> nice
04:43:05 <kallisti> Ptival beat me to it. :P
04:43:10 <quicksilver> [ (h,m) | m <- [0..59], h<-[0..23], (==1) . length . nub . take 3 . reverse $ (show h ++ (if m < 10 then '0':show m else show m)) ]
04:43:14 <quicksilver> > [ (h,m) | m <- [0..59], h<-[0..23], (==1) . length . nub . take 3 . reverse $ (show h ++ (if m < 10 then '0':show m else show m)) ]
04:43:15 <lambdabot>   [(0,0),(10,0),(20,0),(1,11),(11,11),(21,11),(2,22),(12,22),(22,22),(3,33),(...
04:43:20 <quicksilver> ^^ dumb fix to my dumb method
04:43:31 <Ptival> oh I forgot the 20 to 23 :D
04:44:11 <kallisti> > [1,2 | x <-[1..10]]
04:44:12 <lambdabot>   <no location info>: parse error on input `|'
04:44:19 <kallisti> I'm remembering how to use list comprehensions...
04:44:22 <kallisti> > [[1,2 | x <-[1..10]]
04:44:23 <lambdabot>   <no location info>: parse error on input `|'
04:44:24 <kallisti> er
04:44:29 <kallisti> > [[1,2] | x <-[1..10]]
04:44:30 <lambdabot>   [[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2]]
04:44:35 <kallisti> > [1,2 | x <-[1..10]]
04:44:36 <lambdabot>   <no location info>: parse error on input `|'
04:44:44 <kallisti> hm, okay. so list comprehensions are not do notation.
04:45:06 <DMcGill> kallists: what do you mean by `1,2'?
04:45:07 <quicksilver> they are very close to it kallisti.
04:45:20 <quicksilver> the have an implicit return on the thing to the let of the |
04:45:25 <quicksilver> did you mean (1,2)?
04:45:31 <Ptival> > [ [a, b, ':', b, b] | a <- ['0'..'2'], b <- ['0'..'5'], a /= '2' || b < '4']
04:45:32 <lambdabot>   ["00:00","01:11","02:22","03:33","04:44","05:55","10:00","11:11","12:22","1...
04:45:45 <kallisti> almost
04:46:12 <kallisti> well, assuming you don't want things like "22:20"  that's correct
04:46:30 <Ptival> ["00:00","01:11","02:22","03:33","04:44","05:55","10:00","11:11","12:22","13:33","14:44","15:55","20:00","21:11","22:22","23:33"]
04:46:42 <Ptival> sorted out for free!
04:49:18 <DMcGill> how does pattern matching on things that aren't Eq work? Do constructors have an implicit test for equality that's called when matching the pattern?
04:49:30 <kallisti> Eq and pattern matching have nothing to do with each other
04:49:42 <kallisti> except that the Eq instance is often defined in terms of pattern matching on constructors.
04:49:58 <kallisti> but pattern matching is a primitive operation. it doesn't depend on Eq to work.
04:49:59 <DrSyzygy> DMcGill: it's not a (==) comparison on the constructors when you pattern match. It's a check for identicality for the constructors.
04:50:15 <DrSyzygy> DMcGill: Eq otoh is "just" a type class that happens to define the function ==.
04:50:40 <quicksilver> the ability to pattern match them is, in a manner of speaking, the defining attribute of constructors.
04:51:42 <Saizan> Eq is used only when pattern matching against numeric literals
04:52:05 <kallisti> is it explicitly specified that way? I always assumed it was just semi-magically.
04:52:07 <DMcGill> Is it possible to write your own instances of pattern matching i.e. define your own literals? I suppose XOverloadedStrings does it
04:52:18 <kallisti> not currently.
04:52:30 <kallisti> with the exception of IsString and Num, yes.
04:52:59 * kallisti would like to see OverloadedSequences
04:55:17 <DMcGill> it's still not too late to coerce a student into making it over the summer!
04:55:27 * kallisti is a student. >_>
04:55:40 <kallisti> but I have too many obligations as it is.
04:55:42 <DMcGill> coerce a mentor into paying you for it?
04:55:58 <kallisti> hm, no. I don't go to a good university. Also my GPA is horrible. :P
04:56:19 <DMcGill> maths & compsci course is best course
04:56:22 <Ptival> > (unsafeCoerce kallitsti) :: GSOC_student
04:56:23 <lambdabot>   Not in scope: type constructor or class `GSOC_student'Not in scope: `unsafe...
04:57:04 <kallisti> however I will pay YOU to test my Selenium 2 bindings.  (just kidding, I won't)
04:57:12 <kallisti> maybe like a dollar..
04:57:24 <kallisti> plus PayPal fees.
05:29:48 * hackagebot gact 0.1 - General Alignment Clustering Tool  http://hackage.haskell.org/package/gact-0.1 (KetilMalde)
05:38:02 <_mpu> How comes that this parsec parser "((many lower >> char '%' >> return True) <|> return False)" fails on "xy".
05:38:13 <_mpu> I would expect it to return false.
05:38:41 <mm_freak> the writer log of 'c' is still added to the overall log when using 'listen c', correct?
05:38:56 <mm_freak> _mpu: see 'try'
05:39:44 <mm_freak> _mpu: alternative parsec parsers try the second alternative only when the first alternative failed and did not consume any input
05:39:48 * hackagebot zlib-enum 0.2.2 - Enumerator interface for zlib compression  http://hackage.haskell.org/package/zlib-enum-0.2.2 (MalteSommerkorn)
05:40:20 <_mpu> mm_freak, This is to improve performance, isn't it?
05:40:35 <_mpu> mm_freak, Maybe I should factor my grammar.
05:41:08 <mm_freak> _mpu: it doesn't improve performance, but it makes the performance more predictable
05:41:43 <mm_freak> _mpu: a parser that never backtracks (by using 'try') consumes the input sequentially with O(1) memory
05:42:24 <_mpu> mm_freak, Factoring my grammar would avoid backtracking, in which cases should I do it?
05:44:50 * hackagebot gact 0.2 - General Alignment Clustering Tool  http://hackage.haskell.org/package/gact-0.2 (KetilMalde)
05:47:53 <dp_wiz> Is there a package providing buffered interface to serial ports? i'm using serialport package, but it has only basic send/recv/flush functions.
05:49:50 <kallisti> @src fix
05:49:50 <lambdabot> fix f = let x = f x in x
05:50:28 <Axman6> dp_wiz: you could do the buffering yourself using threads (just constantly read from the port and send the data into a Chan)
05:53:15 <kallisti> > fix error
05:53:16 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:53:46 <hpc> kallisti: if only i could fix all my errors that way!
05:53:50 <Axman6> the handy thing about fix error, is that it'll fix just about any type error =)
05:53:52 <hpc> > mzero :: IO ()
05:53:53 <lambdabot>   <IO ()>
05:54:10 <hpc> Axman6: no it won't :P
05:54:13 <hpc> :t fix error
05:54:13 <lambdabot> [Char]
05:54:34 <hpc> error :: String -> a
05:54:41 <hpc> unify with a -> a and get String -> String
05:54:50 <hpc> and feed to fix and get String
05:55:10 <Axman6> oh right, i forgot it wasn't type a >_<
05:55:33 <Axman6> i think i was thinking of fix id
05:57:36 <dp_wiz> > fix id
05:57:40 <lambdabot>   mueval-core: Time limit exceeded
05:58:54 <ClaudiusMaximus> ..ooOO( ghci-7.4.1> :m + Data.Function ; instance Show (a -> b) where show = const "lol" ; error ; fix it )
06:00:31 <tgeeky> ClaudiusMaximus: hehe. just because you can give a Show instance to functions, doesn't mean you should :o
06:00:54 <ClaudiusMaximus> tgeeky: it's necessary! otherwise 'it' isn't in scope :(
06:04:49 <_mpu> In parsec, is there a more idomatic way to do this: op <- Just <$> binop <|> return Nothing
06:05:03 <_mpu> (followed by a case)
06:05:48 <hpc> :t try
06:05:49 <lambdabot> Not in scope: `try'
06:05:52 <hpc> @hoogle try
06:05:52 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
06:05:52 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
06:05:52 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
06:05:59 <hpc> @hoogle parsec try
06:06:00 <lambdabot> No results found
06:06:12 <hpc> :(
06:06:34 <hpc> _mpu: follow the types, i would say
06:06:38 <ClaudiusMaximus> @hoogle try +parsec
06:06:38 <lambdabot> Text.ParserCombinators.Parsec.Prim try :: GenParser tok st a -> GenParser tok st a
06:06:38 <lambdabot> Text.Parsec.Prim try :: ParsecT s u m a -> ParsecT s u m a
06:07:03 <hpc> @hoogle ParsecT s u m a -> ParsecT s u m (Maybe a)
06:07:04 <lambdabot> Text.Parsec.Combinator optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)
06:07:04 <lambdabot> Text.ParserCombinators.Parsec.Combinator optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)
06:07:23 <hpc> optionMaybe?
06:07:23 <mm_freak> _mpu: depends:  backtracking is CPU-cheap, but memory-expensive
06:07:37 <mm_freak> _mpu: you refactoring may make the grammer CPU-expensive, memory-cheap
06:08:37 <mm_freak> it all depends on your grammar, but unless you expect huge backtrackings (try (many1 digit)) you should be fine
06:08:46 <_mpu> hpc, thanks.
06:09:02 <hpc> (all it does is match the type; i have no clue what it does)
06:09:18 <_mpu> mm_freak, ok, thanks I will stick with try.
06:09:25 <_mpu> hpc, the right thing :).
06:10:24 <mm_freak> _mpu: you could also use an arrow parser library, which essentially does exactly this refactoring automatically, but unfortunately i don't know of any mature arrow parser libraries out there
06:10:33 <mm_freak> PArrows is old and very limitedf
06:11:12 <_mpu> Parsec error messages are awesome.
06:11:22 <_mpu> (At least for my small grammar).
06:11:30 <ion> Yeah, they are indeed.
06:12:09 <dylukes> Who was the one working on that slick wiki thing?
06:12:14 <dylukes> with integrated sandboxed haskell?
06:12:56 <hpc> dylukes: wolfgang?
06:12:59 <hpc> uh
06:13:04 <hpc> luite, i think
06:13:08 <hpc> but i can't remember
06:13:53 <dylukes> luite: Was that you?
06:17:40 <dp_wiz> will monad calling itself crash with S.O. or it would apply tail recursion fine?
06:20:08 <merijn> dp_wiz: Tail recursion is not needed to avoid stack overflows in a lazy language
06:24:10 <quicksilver> merijn: myth BUSTED!
06:26:24 <merijn> quicksilver: I'm wrong? I'm right? (afaik at least partially right...)
06:26:31 <quicksilver> you're partially right.
06:26:41 <quicksilver> there are circumstances where tail recursion is not relevant.
06:26:57 <quicksilver> special tail-call optimisation is still useful though.
06:27:20 <quicksilver> if you're producing data as you go along then you consume the stack at the same rate you produce it so it doesn't matter
06:27:28 <merijn> Anyway, my point (before I got distracted from typing it out) was that it's hard to say whether tail recursion is relevant to the question without knowing more about the "monad calling itself" that he was talking about
06:27:35 <quicksilver> however if you're folding to a tight summary value, like with 'sum'
06:27:45 <quicksilver> then it is possible to blow the stack with a thunk
06:30:46 <quicksilver> second answer to http://stackoverflow.com/questions/4282382/accumulators-in-haskell helps explain a it
06:32:59 <mm_freak> the 'pass' operation is really misplaced in MonadWriter
06:33:03 <mm_freak> it should go into its own type class
06:33:53 <mm_freak> because it disallows me to write MonadWriter instances for Alternative functors
06:34:17 <mm_freak> i.e. what is 'pass (c *> empty)' supposed to mean?
06:35:04 <hpc> :t pass
06:35:04 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
06:35:16 <quicksilver> you're not the first person to observe that mm_freak
06:35:44 <quicksilver> it's a really peculiar method IMO
06:36:18 <mm_freak> well, it seems to be useful and the only way to alter the log in general
06:36:24 <quicksilver> why the (false?) generalisation? why not just make it (w -> w) -> m ()
06:36:39 <mm_freak> so i'd say it can be a useful operation for some people, but it's not useful in MonadWriter in general
06:36:52 <mm_freak> well, yes
06:36:57 <quicksilver> in some contexts the ability to prove the log cannot be altered could be seen as a powerful invariant, too.
06:37:08 <quicksilver> the kind you might intuitively expect from MonadWriter (if you hadn't noticed pass)
06:37:09 <mm_freak> the type is more complicated than necessary, but even the simplified type doesn't solve the problem
06:37:28 <mm_freak> true
06:38:25 <yasar> After studying haskell for couple of days, lambda usage in my Python code increased ten folds :D
06:38:27 <mm_freak> i'll just live without MonadWriter for now
06:38:53 <mm_freak> (i don't need it anyway, just thought i'd provide the non-lift interface for convenience)
06:39:13 <mm_freak> yasar: that's common =)
06:39:19 <merijn> Is it?
06:39:26 <mm_freak> you're also writing less loops i'd expect
06:39:29 <merijn> I still don't use lambda much, it's ugly in python
06:39:41 <hpc> i just don't use python
06:39:41 <merijn> I did start using generators/generator expressions a lot
06:39:42 <mm_freak> merijn: it's nice compared to most other languages
06:39:52 <hpc> ive started using lambdas a lot in perl though
06:39:56 <mm_freak> even the supposedl functional javascript has the ugliest lambda syntax you can imagine
06:40:06 <hpc> they have some interesting properties thanks to the args-array thing
06:40:15 <merijn> mm_freak: I'm sure Java's eventual lambda's will top it
06:40:35 <hpc> merijn: java kind of has lambdas in the form of anonymous subclasses
06:40:35 <mm_freak> yeah, likely
06:40:38 <yasar> mm_freak: yes, look at this monster :https://raw.github.com/yasar11732/stringutils/master/stringutils.py
06:40:57 <merijn> hpc: It was supposed to get real lambda's Real Soon Now (TM)
06:41:11 <mm_freak> yasar: http://ertes.de/python/fun/chlists.py
06:41:12 <mm_freak> =)
06:41:15 <mm_freak> my monster =)
06:41:50 <yasar> mm_freak: It smells very haskellish :D
06:42:02 <mm_freak> not really
06:42:10 <mm_freak> i wonder why haxe has such an ugly lambda syntax
06:42:11 <_mpu> Is there a reason why the syb-0.3.6 is hidden on my machine?
06:42:42 <baleft> _mpu: is it referenced in your cabal file?
06:42:53 <yasar> mm_freak: Are you from Turkey?
06:43:01 <_mpu> baleft, no.
06:43:03 <mm_freak> yasar: germany, but i am turkish
06:43:33 <baleft> _mpu: when i remember right any package you use has to be referenced in cabal.
06:43:48 <_mpu> baleft, oh ok, thanks.
06:44:07 <_mpu> baleft, this is a safe choice, by the way.
06:44:51 <mm_freak> lol i didn't notice the 'censor' function in mtl
06:45:00 <mm_freak> funny name, but very descriptive =)
06:45:10 <hpc> :t censor
06:45:11 <lambdabot> forall w (m :: * -> *) a. (MonadWriter w m) => (w -> w) -> m a -> m a
06:45:18 <hpc> heh
06:48:43 <djanatyn> is there a haskell library that can control the mouse and keyboard on windows?
06:49:00 <djanatyn> like, moving the cursor up and down, clicking, and typing things in.
06:49:58 <djanatyn> not accepting user input; actually manipulating and interacting with other programs running
06:50:43 <baleft> djanatyn: your searching some remote control function?
06:50:50 <djanatyn> Yes, kind of.
06:51:18 <djanatyn> I mean typing a function like "moveMouse (100,100)" that will move the mouse to that coordinate
06:51:33 <baleft> don't know any unfortunately
06:51:37 <djanatyn> or, "moveUp 100" that moves the mouse 100 pixels up
06:51:54 <djanatyn> I'm not sure if there is
06:52:24 <mm_freak> will 'fromException (SomeException (SomeException x))' always succeed?
06:52:44 <hpc> :t fromException
06:52:45 <lambdabot> Not in scope: `fromException'
06:52:49 <hpc> @hoogle fromException
06:52:50 <lambdabot> Control.Exception.Base fromException :: Exception e => SomeException -> Maybe e
06:52:50 <lambdabot> Control.Exception fromException :: Exception e => SomeException -> Maybe e
06:53:08 <mm_freak> :t E.fromException
06:53:09 <lambdabot> Couldn't find qualified module.
06:53:11 <quicksilver> djanatyn: is there some library that does that for *any* language?
06:53:15 <mm_freak> :t Control.Exception.fromException
06:53:16 <lambdabot> forall e. (GHC.Exception.Exception e) => GHC.Exception.SomeException -> Maybe e
06:53:20 <quicksilver> djanatyn: (if there is, then you want haskell bindings to it)
06:53:34 <quicksilver> djanatyn: but I very much doubt this will exist as a haskell-only project
06:53:40 <mm_freak> > Control.Exception.fromException (SomeException (userError "test")) :: Maybe SomeException
06:53:41 <lambdabot>   Not in scope: type constructor or class `SomeException'Not in scope: `Contr...
06:53:56 <mm_freak> > Control.Exception.fromException (Control.Exception.SomeException (userError "test")) :: Maybe Control.Exception.SomeException
06:53:57 <lambdabot>   Not in scope:
06:53:57 <lambdabot>    type constructor or class `Control.Exception.SomeException...
06:54:30 <hpc> lambdabot pipes into ghci for :t
06:54:33 <djanatyn> it looks like it might be in the win32 library
06:54:35 <hpc> and uses mueval for '> '
06:54:41 <djanatyn> quicksilver: there is in python.,
06:54:44 <hpc> so a lot of :t stuff isn't in scope
06:54:44 <mm_freak> ok, apparently if fromException returns a SomeException, it always succeeds
06:55:08 <tgeeky_> mm_freak: that's some exception!
06:55:09 <quicksilver> djanatyn: find out what the python one is a binding to. What is it called?
06:56:08 <djanatyn> you can use the win32 api for python to manipulate the mouse
06:56:08 <djanatyn> I think it's in the stnadard library
06:57:07 <mm_freak> tgeeky_: more than a decade of programming experience in side-effectful languages has made me wary to trust names
06:58:09 <quicksilver> djanatyn: even when other applications are in the front? interesting.
06:58:24 <djanatyn> it's called win32api
06:59:43 <imc> quicksilver: reading the suggested blog you pointed out earlier (http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/)... it's great, thanks!
07:01:41 <quicksilver> did I point that out?
07:01:45 <quicksilver> well it's definitely a great blog ;)
07:01:52 <quicksilver> so if I did, I was right.
07:01:53 <imc> quicksilver: indirectly :) by stack overflow
07:02:44 <imc> 15:30:24 < quicksilver> second answer to http://stackoverflow.com/questions/4282382/accumulators-in-haskell helps explain a it
07:05:30 <quicksilver> ;)
07:05:59 <djanatyn> I can't find any relevant functions in the Win32 modules
07:07:18 <djanatyn> nothing seems to be popping up on hoogle either
07:07:36 <imc> i'm pretty sure i don't have any Win32 module :)
07:07:49 <imc> would be strange on a non-win machine
07:08:36 <quicksilver> the win32 modules probablyu aren't complete :(
07:09:53 * hackagebot monadiccp 0.7.4 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-0.7.4 (TomSchrijvers)
07:12:15 <donri> djanatyn: http://hackage.haskell.org/packages/archive/Win32/2.2.2.0/doc/html/Graphics-Win32-Misc.html#v:setCursorPos ?
07:12:16 * Philippa waits for the haddock for monadiccp to generate
07:13:07 <djanatyn> :D that works
07:13:12 <djanatyn> thanks, donri
07:19:54 * hackagebot cash 0.1.0.1 - the Computer Algebra SHell  http://hackage.haskell.org/package/cash-0.1.0.1 (ChrisBrown)
07:25:23 <jonz> whats up
07:29:52 <deech> Hi all, I was just looking at the release notes for 7.4.1 and I notice that stack traces are available with profiling enabled. Is this the implementation that Simon Marlow was talking about?
07:30:02 <nart> please give me something cool to work on, the boredom is killing me :S
07:31:24 <Clint> nart: org-mode file parser
07:31:27 <Claudius1aximus> nart: language-dvdauthor including parser/printer for the dvd vm language and all the xml stuff surrounding it
07:32:10 <Claudius1aximus> (i asked some questions about this y'day but ended up creating my dvd.xml by hand using copy/paste/search/replace...)
07:32:16 <donri> nart: http://code.google.com/p/happstack/wiki/GoogleSummerOfCode
07:32:49 <deech> nart: Python bridge, right now you can only call from Haskell to Python
07:33:38 <nart> i forgot to say that i'm a beginner in haskell :S, but i appreciate these suggestions :D
07:33:39 <Claudius1aximus> nart: making http://hackage.haskell.org/package/nyan colour
07:35:44 <mm_freak> nart: write some cool graphics using gloss…  it's beginner-compatible and teaches you thinking pure while having fun
07:37:30 <mm_freak> note:  if you have GHC < 7.4.0 you'll need to install a pre-1.6 version of gloss
07:39:08 <nart> mm_freak: ty it seems really cool, btw i have no problem in thinking pure or functional :D
07:40:31 <nart> right now i would like to write a multithread networking app .... humm
07:40:44 <mm_freak> it teaches you thinking pure in haskell…  thinking pure in presence of laziness changes the way you think dramatically
07:40:54 <mm_freak> in that case learn concurrent programming
07:41:11 <Clint> write an irc server
07:43:01 <mm_freak> write a chat server first
07:43:09 <mm_freak> an IRC server requires somewhat more
07:43:11 <nart> Clint: that's exactly what i was thinking about, right now i have written an irc bot and i have never tried to build an irc server
07:43:33 <nart> mm_freak	: yep i think i'll start that way
07:45:44 <Clint> you can do a chat server in about 50 lines
07:47:53 <donri> chrisdone wrote an ircd in haskell
07:48:36 <nart> donri: yep i read the post on his blog :)
07:48:59 <mm_freak> nart: start with a simple broadcast echo server
07:49:09 <mm_freak> i.e. every connected client receives everything from every other client
07:49:14 <mm_freak> then add some client state
07:49:19 <mm_freak> let clients choose a nickname
07:49:35 <mm_freak> that covers most of what you need for concurrent programming
07:51:05 <nart> mm_freak: ty for the tips
07:52:39 <mekeor> @where darcsden -- probably the best alternative to github (especiall for haskell- (and thus darcs-) users)
07:52:40 <lambdabot> http://darcsden.com/
08:04:55 * hackagebot blaze-html 0.4.3.2 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.4.3.2 (JasperVanDerJeugt)
08:06:06 <mekeor> wow, blaze-html is updated very frequently.
08:11:53 <_mpu> mekeor, blazingly frequently.
08:11:55 <luite> dylukes: yes
08:12:28 <grozamorei> hello everyone. I have a trouble installing haskell platform on my ubuntu 10.10 32 bit. I tried to use apt repos, but find it difficult to install some libraries and update cabal, so I desided to compile from sources. I folowed haskell.org instructions, and downloas binaries http://www.haskell.org/ghc/download_ghc_7_4_1#x86linux from here, and made ./configure and make install on it. ghc then appear at my bash console. then, I tr
08:12:28 <dylukes> luite: Question...
08:12:36 <dylukes> You were doing wolfgang right?
08:12:47 <luite> yes
08:12:50 <grozamorei> haskell platform, but got message configure: error: Your installation of ghc does not appear to work.
08:13:05 <grozamorei> please, tell me what am I doing wrong.
08:15:47 <grozamorei> here is listing of ./configure answer http://pastebin.com/BVgxmCy5 please help.
08:15:50 <mauke> I have copied your paste BVgxmCy5 to http://hpaste.org/66007 - pray I don't copy it any further.
08:16:20 <grozamorei> mauke: ?
08:17:13 <mauke> grozamorei: so what's in config.log?
08:19:19 <ykm> grozamorei: it is pointing to a missing dependency....have u tried installing gmp
08:19:41 <mauke> ykm: what
08:20:00 <grozamorei> ykm: no such package in my repos
08:20:24 <grozamorei> mauke: i'm afraid I'm look stupid, but where is config.log?
08:20:31 <mauke> I don't know
08:20:52 <mauke> presumably in the directory you ran configure in
08:21:12 <ykm> huh?....have u tried searching?...apt-cache search?
08:22:27 <grozamorei> mauke: here's config.log
08:22:28 <grozamorei> http://pastebin.com/81f7Grk5
08:22:31 <mauke> The paste 81f7Grk5 has been copied to http://hpaste.org/66008
08:23:02 <mauke> yeah, the problem is a missing libgmp
08:23:36 <mekeor> mauke: how did you automatically copy pastebin to hpaste?
08:23:41 <mekeor> s/did/do
08:23:42 <mekeor> /
08:23:47 <mauke> with a script
08:23:56 <mekeor> what kind of script?
08:23:59 <grozamorei> ykm: you right, i should make a search
08:24:10 <mauke> grozamorei: probably libgmp3-dev
08:24:14 <mekeor> mauke: the script uses the same nickname as you do.
08:24:18 <mauke> mekeor: ?
08:24:38 <mekeor> mauke: so, you can login twice with the same nickname?
08:24:47 <mauke> I have no idea what you're talking about
08:25:02 <mekeor> mauke: about your script…
08:25:08 <mauke> yes?
08:25:17 <mekeor> how does it work? how did you wrote it? in haskell?
08:25:45 <mekeor> mauke: and, especially, how can your script use the same nickname as you do? (i mean, "mauke".)
08:26:02 <mauke> your questions make no sense
08:26:06 <grozamorei> mauke: thanks a lot, that helped, now it moves to another missing dependency :D
08:26:14 <mekeor> grozamorei: :D
08:26:33 <ykm> wat?.....i've completed LYAH....and not a trace of monads...or i'm missing something?
08:26:49 <ykm> is there any other source/
08:26:55 <hpaste> nart pasted “Simple echo server” at http://hpaste.org/66009
08:27:18 <nart> why ^^ it handles multiple clients ?
08:27:18 <mekeor> ykm: http://learnyouahaskell.com/chapters did you rly read all?
08:27:42 <mauke> ykm: http://learnyouahaskell.com/a-fistful-of-monads
08:27:43 <nart> ykm: http://learnyouahaskell.com/a-fistful-of-monads ??
08:28:01 <ykm> had a pdf....woah...certainly missed it
08:28:41 <mekeor> ykm: there's no free, legal, official PDF of LYAH, AFAIK…
08:28:59 <mekeor> but tell me, if you found one…
08:29:10 <jkff> Hi. Is there an implementation of unboxed int -> int maps somewhere?
08:29:53 <mekeor> jkff: what does "unboxed" mean in this case? <.<
08:30:33 <nart> http://hpaste.org/66009, why it handles multiple clients ? shouldn't only handle one client ?
08:30:40 <jkff> mekeor: I mean a map with int keys and int values, both of them strict and unboxed
08:30:54 <jkff> mekeor: basically I'm looking for best performance :)
08:31:19 <mauke> jkff: so like, an array?
08:31:29 <jkff> mauke: a sparse array if you wish
08:31:32 <mekeor> jkff: ah. there's Data.IntMap. it's from Int to anything…
08:31:38 <grozamorei> mekeor: thank you so much :3 i've been on installation all day, and finaly made ./configure
08:31:49 <jkff> mekeor: yep, I'm thinking about just copypasting Data.IntMap and tweaking it
08:31:55 <mekeor> jkff: it even seems strict…
08:31:56 <quicksilver> nart: yes, that only calls accept once, it should only establish one connection
08:32:14 <mekeor> jkff: you could fork it =)
08:32:24 <mekeor> grozamorei: no problem.
08:32:28 <mekeor> grozamorei: :D haha
08:32:42 <mekeor> grozamorei: you certainly meant mauke… ;)
08:33:07 <grozamorei> mekeor: yes i did. autocomplete made me do that :D
08:33:29 <mekeor> :)
08:35:42 <ykm> mekeor: well i found a free, illegal, incomplete, unofficial pdf...my bad :)
08:36:01 <mekeor> hehe
08:36:21 <mekeor> ykm: probably it wasn't up-to-date, too, btw… idk.
08:38:48 <nart> quicksilver: and why i can connect twice from the shell, and it works ? :S
08:39:56 * hackagebot vector-instances-collections 0.1.0.1 - Instances of the Data.Collections classes for Data.Vector.*  http://hackage.haskell.org/package/vector-instances-collections-0.1.0.1 (TobiasBrandt)
08:40:35 <quicksilver> nart: well the echo doesn't work, surely?
08:40:58 <nart> quicksilver: it works :S
08:41:04 <quicksilver> nart: the 2nd connection will be connect, but not do anything because it's sitting in a kernel queue waiting to be accept()ed
08:41:23 <quicksilver> nart: your computer must be being bombarded by cosmic rays.
08:41:29 <nart> awesome
08:41:38 <quicksilver> I run that code and whilst I can "telnet localhost 6000" in two windows
08:41:48 <quicksilver> only one of them has the property that if I type foo<RET> it gets echoed.
08:42:08 <quicksilver> (extra echo after telnet's built-in echo that is)
08:43:45 <nart> wut ?, if i connect from two shells from iterm it works only for one connection, but if i connect from a shell buffer in emacs it works
08:44:22 <lolfrenz> hey
08:44:47 <lolfrenz> when creating a type (using `data'), is there any way I can create a constructor that refers to a previous constructor?
08:45:01 <ben> Refers?
08:45:05 <bitonic> lolfrenz: what do you mean?
08:45:05 <nart> quicksilver: can you try to connect from the terminal *and* from emacs shell ?
08:45:09 <lolfrenz> data T = C1 Char | C2 (C1 x)
08:45:17 <quicksilver> nart: are you sure you're not being confused by emacs shell's own echoing?
08:45:18 <bitonic> lolfrenz: what's 'C1'?
08:45:18 <ben> No, a type goes there, not a constructor.
08:45:24 <bitonic> lolfrenz: what's 'x'?
08:45:33 <lolfrenz> ben, but I would like to restrict that type to being constructed with C1
08:45:47 <nart> quicksilver: lol, own echoing ? ahahha i'm such a n00b
08:45:54 <lolfrenz> bitonic, variable name, like in patterns
08:46:09 <bitonic> lolfrenz: newtype C = C Char, data T = C1 C | C2 C
08:46:13 <nart> quicksilver: now i understand why it was echoing three time instead of two before
08:46:20 <Lemmih> lolfrenz: Yes, you can do that with GADTs.
08:46:29 <quicksilver> nart: try making the echo function do something more visible like hPutStrLn h ("I hear you loud and clear" ++ line)
08:46:38 <quicksilver> I don't think that's what lolfrenz means.
08:46:45 <quicksilver> I think he simply means
08:46:51 <quicksilver> data T x = C1 x | C2 x
08:46:57 <quicksilver> -- ensure the type in the C2 is the same as the type in the C1 ?
08:47:54 <hpaste> bitonic pasted “lolfrenz & Lemmih” at http://hpaste.org/66010
08:48:02 <bitonic> Lemmih: ^^^ is this what you meant?
08:48:47 <lolfrenz> quicksilver, I want one of the parameters of the second ctor to be of the type I'm currently defining, and moreover constructed with a specific constructor
08:49:20 <bitonic> lolfrenz: you can't do that
08:49:23 <bitonic> not directly anyways.
08:49:25 <lolfrenz> for example, data Tree = Leaf Int | AlmostLeaf Leaf Leaf | Node Int Tree
08:49:47 <lolfrenz> where AlmostLeaf would be a tree with just one node having two leaves
08:49:53 <nart> quicksilver: better to use TVar or MVar to keep state across threads ?
08:49:56 <Tomsik> you can do that with GADTs and phantom types AFAIK
08:50:17 <lolfrenz> I don't know what either of those mean, but I'll look it up, thansk
08:50:20 <lolfrenz> thanks*
08:50:27 <bitonic> lolfrenz: yeah, you can't do that. You can have the desired effect in various ways. the easiest one is to split the datatype in two. you can also use GADTs as in the example I posted
08:50:44 <lolfrenz> bitonic, yes, I was looking at GADT-s atm
08:50:54 <bitonic> lolfrenz: did you check my paste?
08:51:34 <quicksilver> nart: no point using TVar unless you are using the transactionality of it.
08:52:04 <quicksilver> nart: MVar works fine but make sure you understand it.
08:52:08 <hpaste> bitonic annotated “lolfrenz & Lemmih” with “lolfrenz & Lemmih (corrected)” at http://hpaste.org/66010#a66011
08:52:15 <lolfrenz> bitonic, I am now, one moment
08:52:23 <bitonic> lolfrenz: actually the previous one was wrong. check the annotation
08:52:29 <lolfrenz> oh, ok
08:52:33 <nart> quicksilver: ty
08:52:35 <quicksilver> nart: even IORef is quite thread-safe, but you can certainly write broken algorithms because there is no protecton against two concurrent writers.
08:52:58 <bitonic> lolfrenz: but the most appropriate way is probably to split the data type in two.
08:54:21 <lolfrenz> bitonic, but then I won't learn anything new :D
08:54:39 <bitonic> lolfrenz: well do learn about GADTs, but don't use them just because you can :)
08:57:35 <lolfrenz> bitonic, will do, thanks
09:06:33 <yshavit> This may be an odd question, but is there a way to tell ghci to either not go as fast as it can, or to abort an evaluation after some amount of time? And if possible, to set this property as a default? I just jokingly asked it to evaluate something that would run forever, and it completely ground my system to a halt. Had to do a hard reboot (as in, push the power button down for five seconds).
09:06:55 <yshavit> I got what I deserved that time, but it'd be nice if I could avoid doing that by accident in the future :)
09:08:25 <ClaudiusMaximus> yshavit: you can limit maximum heap size with   ghci +RTS -M100M -RTS
09:08:55 <yshavit> ClaudiusMaximus: that'd be perfect, thanks.
09:09:15 <ClaudiusMaximus> yshavit: then ghci will abort on out of memory instead of consuming all ram and all swap and thrashing everything until some random process gets killed
09:09:32 <yshavit> ClaudiusMaximus: yup, that's exactly what happened.
09:09:59 <yshavit> ClaudiusMaximus: worked. Thanks!
09:10:00 <RainbowFactory> > sum [1..10]
09:10:01 <lambdabot>   55
09:10:12 <ClaudiusMaximus> (though, when ghci aborts you lose all the history from that session - not always fun!)
09:10:30 <quicksilver> ClaudiusMaximus: although, with -M100M you get some GC thrashing as it gets close to the limit, I fear
09:10:34 <yshavit> ClaudiusMaximus: the work that I do, I won't ever need 100M of heap!
09:10:35 <quicksilver> not as bad as whole-machiine thrashing.
09:10:50 <yshavit> for the record, read :: Int doesn't realize that 0.999... == 1 ;-)
09:10:52 <ClaudiusMaximus> sure, adjust according to how much ram you want to give ghci
09:11:55 <Lemmih> >read "0.999..."
09:11:57 <lambdabot> 1
09:12:08 <Lemmih> Works for me.
09:12:23 <Tomsik> Note that there are non-terminating computations that are constant-space :P
09:13:35 <yshavit> Lemmih: wait, what? that doesn't work for me. As you wrote it, it says it's ambiguous. When I do read "0.999..." :: Int, I get a parse error.
09:14:24 <Lemmih> yshavit: I am blessed by the Haskell gods. My code always does the Right Thing.
09:14:24 <Jaak> > reads "0.999..." :: [(Double, String)]
09:14:26 <lambdabot>   [(0.999,"...")]
09:14:26 <yshavit> I was doing (read ("0.9" ++ repeat '9') :: Int)  (and to reiterate, I was just joking around -- didn't actually expect it to return 1)
09:15:18 <Lemmih> yshavit: I'm also just joking around.
09:15:31 <yshavit> Lemmih: is lambdabot not actually a bot?
09:15:31 <ion> yshavit: It does return 1, just wait for the return value.
09:16:39 <lambdabot> I'm a sock puppet.
09:16:54 * yshavit feels trolled.... :)
09:22:10 <nart> how can i forkIO a function that has type Handle -> Server () where Server is  ... type Server a = ReaderT State IO a ?
09:23:05 <ChristianS> > L.read "2.3"
09:23:07 <lambdabot>   1
09:23:09 <quicksilver> manually, nart
09:23:17 <ChristianS> has lambdabot gone crazy?
09:23:28 <quicksilver> :t runReaderT
09:23:28 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
09:23:44 <yshavit> ChristianS: it won't open the bod bay door for me.
09:24:08 <quicksilver> nart: do { s <- ask; liftIO (forkIO (runReaderT act s)) }
09:24:29 <quicksilver> well let's include the h part as well
09:24:35 <quicksilver> nart: do { s <- ask; liftIO (forkIO (runReaderT (act h) s)) }
09:24:48 <quicksilver> where your function is  act :: Hander -> Server ()
09:24:59 <quicksilver> clearly you can define this as 'forkServer' if you want to.
09:25:03 <ion> @vixen have you gone crazy?
09:25:03 <lambdabot> Any change is resisted because bureaucrats have a vested interest in the chaos in which they exist.
09:25:14 <bitonic> ion: vixen is nixon :(
09:25:38 <nart> quicksilver: ty
09:31:29 <ChristianS> @type
09:31:30 <lambdabot> <no location info>: not an expression: `'
09:31:34 <ChristianS> sorry
09:31:44 <jfischoff> anyone familiar with lhs2tex?
09:33:11 <ClaudiusMaximus> jfischoff: i've used it once or twice, but what's your real question?
09:33:14 <bitonic> jfischoff: it's better to just ask.
09:34:33 <jfischoff> I have {-# LANGUAGE options} with many options and I although I have them on several lines in source, they are being laid out on one line.
09:34:50 <jfischoff> alternatively if there is a way to hide source code that might work too
09:36:33 <bitonic> jfischoff: an ugly solution is to have multiple {-# LANGUAGE ... #-}.
09:36:51 <jfischoff> works for me
09:36:57 <jfischoff> thanks
09:37:28 <bitonic> you see? I was able to answer without ever using lhs2tex! :)
09:37:36 <jfischoff> :)
09:40:08 <ion> I always use multiple {-# LANGUAGE … #-} lines.
09:40:17 <bitonic> why?
09:41:22 <ion> Mostly convenience because my editor isn’t smart enough. I can sort them easily (!ipsort) for instance.
09:41:46 <bitonic> oh ok.
09:42:23 <danharaj> So I have a type Foo a b ~ (a -> (Foo a b, [b])), state machines that return multiple outputs per input. They form an Arrow. I want to write an instance for ArrowLoop but I am not sure how. I'm pretty sure you can write an instance for it.
09:45:54 <bitonic> danharaj: let's see...
09:45:58 <Enigmagic> bitonic: it also allows for automatic merging between developers/branches
09:46:11 <Enigmagic> which is why we do it
09:47:43 <danharaj> loop :: Foo (a, c) (b, c) -> Foo a b
09:48:33 <bitonic> danharaj: how does your Category instance look?
09:49:29 <danharaj> g . f = f >>> g is: run f on the input, now feed the outputs of f one at a time into g, collect results in the order they are produced.
09:50:52 <bitonic> yeah but you also have to compose the (Foo a b) resulting from feeding the inputs into g. do you just compose them in the same order as they are generated?
09:53:41 <danharaj> bitonic: Feed the input into f. You get a resulting statemachine f' and a list of outputs. Now feed outputs into g one at a time producing g_1, g_2, ... g_n. Collect those outputs' and return (f' >>> g_n, outputs')
09:53:49 <danharaj> Perhaps I should paste the semantics of it isn't clear :3
09:54:29 <hpaste> bitonic pasted “danharaj” at http://hpaste.org/66014
09:54:47 <bitonic> danharaj: is it like this ^^^ ?
09:54:49 <mm_freak> 'loop' feeds back the result of the computation as an argument to it
09:55:02 <mm_freak> there are potentially multiple or no solutions, but only one argument
09:55:11 <mm_freak> so my first guess is:  it's impossible to write ArrowLoop for that one
09:55:28 <mm_freak> it just doesn't make sense
09:56:50 <danharaj> bitonic: You have to scan with f, not just apply it to each argument.
09:57:01 <danharaj> wait let me read that again
09:57:20 <bitonic> anyways I think I'm with mm_freak
09:58:15 <danharaj> What I'm thinking is that, if loop f is productive, it should produce something from (x, undefined). This gives a list of ys that can be plugged into the second slot. Maybe I can do something with that.
09:58:23 <danharaj> I don't know if that'd satisfy the loop laws.
10:01:06 <mm_freak> danharaj: any instance you write must work for zeroArrow
10:01:13 <mm_freak> the one that returns no results
10:01:38 <mm_freak> the type variable 'c' is fully polymorphic and you have no result…  so what do you feed back?
10:01:54 <mm_freak> there is no result and you can't construct one
10:02:32 <danharaj> hmm you are right.
10:02:45 <Mathnerd314> what's arr?
10:02:55 <bitonic> @type arr
10:02:56 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
10:02:57 <Tomsik> A pirate slang
10:03:01 <bitonic> that's harr.
10:03:36 <Mathnerd314> I mean for danharaj's type
10:03:47 <zhulikas> @hoogle harr
10:03:48 <lambdabot> Data.Data CharRep :: DataRep
10:03:48 <lambdabot> Foreign.Marshal.Array lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
10:03:48 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
10:04:17 <bitonic> Mathnerd314: (a -> b) -> (Foo a b)?
10:04:26 <yasar> How do I sum a set of Ints?
10:04:26 <Mathnerd314> yeah
10:04:32 <danharaj> arr f = AutoM (\x -> ([f x], arr f)) using the paste's names.
10:05:44 <danharaj> all the values you get from arr look like things in the list monad.
10:06:29 <Mathnerd314> hmm, so what does the extra reference buy you
10:07:14 <danharaj> Mathnerd314: state machines
10:07:23 <bitonic> danharaj: you can define a partial ArrowLoop, in the same way that mfix works for []
10:07:27 <bitonic> I think.
10:07:28 <danharaj> mm_freak: What if I replace [] with the type of lists with at least one element?
10:08:31 <bitonic> danharaj: yes you can probably do that discarding the rest of the lsit
10:08:31 <copumpkin> @remember thoughtpolice if there is a question, edwardk probably has the answer
10:08:32 <lambdabot> I will remember.
10:08:35 <ski> @arr
10:08:35 <lambdabot> Aye
10:08:40 <bitonic> not sure how much sense it makes
10:08:46 <mm_freak> danharaj: then what do you pass for two results?  the first or the second?
10:08:56 <statusfailed> aww, my program used 90% memory D:
10:09:37 <danharaj> mm_freak: both, in order, keeping the left input fixed through both invocations.
10:12:06 <ski> preflex: xseen blackdog
10:12:06 <preflex>  blackdog was last seen on freenode/#haskell 17 hours, 47 minutes and 13 seconds ago, saying: ski: turned out i was being too clever by half yesterday, btw. the conversion typeclass is rigid - if i have a datatype Foo { bar :: Int } , it'll work if i pass in the equivalent of "{'bar': 1}", but not "{'bar': 1, 'extraneous':2}"
10:12:25 <ski> blackdog
10:12:28 <ski> er
10:12:40 <danharaj> I'm thinking about this because I've been working with state machines modelled on Identity but dealing with multiple outputs has painful glue code, so I was hoping I could model on List and have multiple output handling built in.
10:13:45 <mm_freak> danharaj: i'm pretty sure that will diverge
10:15:18 <danharaj> mm_freak: yeah it doesn't seem like this can be realized. Which means I'm not actually sure what I want.
10:16:35 <statusfailed> Is Parsec likely to be the cause of memory usage when reading a ~500MB CSV file? i'm using the "CSV" package
10:17:02 <danharaj> statusfailed: yes. Use attoparsec.
10:17:13 <statusfailed> danharaj: is there an attoparsec CSV parser?
10:17:21 <danharaj> I dunno :(
10:17:42 <statusfailed> oh, there's bytestring-csv
10:17:44 <statusfailed> much better :)
10:17:45 <statusfailed> thanks
10:17:50 <statusfailed> .. I should have been using those anyway
10:17:59 <mm_freak> danharaj: that's likely the problem =)
10:18:47 <mm_freak> danharaj: of course you can define an ArrowLoop that throws an 'error' when there isn't exactly one result
10:18:53 <mm_freak> that's what i've done in netwire
10:19:00 <mm_freak> there you can have zero or one result
10:19:37 <mm_freak> the problem is:  with the second argument of the looping computation you are referring to an element that gets defined later in the composition chain
10:19:49 <danharaj> mm_freak: That might not actually be a bad idea. The semantics probably only make sense in that case anyway.
10:19:51 <mm_freak> however, if the chain breaks, then that element is undefined
10:20:07 <mm_freak> danharaj: of course, you can define it that way
10:20:21 <mm_freak> but you have to be careful when using 'loop' or do/rec when you do that
10:21:00 <may_r> hi
10:21:01 <danharaj> mm_freak: That's true anyway unless you enjoy temporal paradoxes.
10:21:22 <may_r> if i want to express that f is injective, could i have: ALL x y. f(x) = f(y) --> x = y?
10:21:57 <danharaj> may_r: what language are you asking about? If it's Haskell you can't do anything like that.
10:22:28 <danharaj> On the other hand, Agda could be right up your alley.
10:26:25 <zhulikas> how can I use type parameter from function definition as a type inside my function body?
10:27:26 <Younder> danharaj, axiom has a topolical type intercae. It is primarely a algebra engine, but is good at that sor of thing. God for defining new types of math too. Unlike matheatica.
10:27:36 <statusfailed> ok dumb question: How should I make a Num into a Bytestring directly?
10:28:03 <Younder> statusfailed, You, shouldn't
10:28:09 <statusfailed> oh, what should I do then?
10:28:15 <Enigmagic> zhulikas: enable ScopedTypeVariables and introduce the variable with a forall... so "{-# LANGUAGE ScopedTypeVariables #-}" then "foo :: forall a . a -> Int"
10:28:23 <bitonic> statusfailed: you can't do that just with methods in Num
10:28:30 <Younder> statusfailed, Well theres Unicode
10:28:54 <statusfailed> Younder: eh?
10:29:23 <statusfailed> bitonic: is there a method in bytestring?
10:29:30 <statusfailed> should I just make a string and then bytestringify it?
10:30:04 <bitonic> statusfailed: what do you need to do?
10:30:29 <statusfailed> I want to turn ["foo", "bar", "baz"] into "1, foo, bar, baz"
10:30:42 <statusfailed> quoted things should be bytestrings.
10:30:49 <sm> hey all.. when testing a project against multiple GHC versions, is there an easy way to make GHC automatically keep version-specific .o files ? -odir `ghc --version` sounds closest to what I want
10:31:21 <bitonic> statusfailed: foo bss = BS.concat (BS.pack "1" : bss)?
10:31:56 <sm> I'm not building with cabal, if that's relevant
10:32:10 <statusfailed> BS.pack! that's the one
10:32:52 <bitonic> statusfailed: I don't know what version of GHC you're using, but add an explicit 'Show' constraint if you're using 'Num'
10:33:24 <bitonic> since Num doesn't require Show anymore
10:34:37 <statusfailed> bitonic: 7.4- I don't think that's the problem though, that's not part of the type signature
10:36:18 <bitonic> statusfailed: since you asked "How do I turn a Num into a ByteString"...
10:39:44 <yasar> does ghci automatically cache functions' return values?
10:39:54 <mm_freak> yasar: no
10:39:59 <mm_freak> only when you use 'let'
10:40:00 * hackagebot yoko 0.3.2.2 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-0.3.2.2 (NicolasFrisby)
10:40:02 * hackagebot happstack-jmacro 6.0.3 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-6.0.3 (JeremyShaw)
10:40:21 <ClaudiusMaximus> it caches the last thing it printed, bound to 'it'
10:41:14 <ClaudiusMaximus> eg: ghci> 5\n5\nghci> it + it\n10
10:43:09 <yasar> With a function like this, http://codepad.org/gcrrVe1U , this expression takes too long to calculate: takeWhile (<4000000) (map fibonacci [1..]) , could I do something so that it caches previous values of fibonacci values, and doesn't always recurse to top?
10:43:45 <Lemmih> yasar: Yes.
10:44:07 <yasar> so, what is it?
10:44:20 <hrdinka> yasar: use a fold for eg.
10:45:41 <ClaudiusMaximus> yasar: http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.3/doc/html/Data-MemoCombinators.html is one nice way
10:46:04 <parcs`> @where fib
10:46:04 <lambdabot> I know nothing about fib.
10:46:06 <parcs`> @where fibs
10:46:07 <lambdabot> I know nothing about fibs.
10:46:13 <bitonic> ClaudiusMaximus: not in this case. unless he just wants to practice with memoization :P
10:46:22 <bitonic> yasar: that is the least efficient way of writing that function
10:47:03 <Mathnerd314> @src fib
10:47:03 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:47:05 <Mathnerd314> @src fibs
10:47:06 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:47:17 <Lemmih> yasar: Oh, I wouldn't want to ruin your fun by telling you.
10:47:26 <bitonic> yeah, me neither :P
10:47:40 <tazjin> We have an entire wiki article dedicated to the fibonaccy sequence iirc
10:48:00 <bitonic> yasar: do you want to experiment with memoization or do you want a better fibonacci function?
10:48:03 <parcs`> Lemmih: hey, i've been perusing your sdl bindings and i noticed that waitevent is implemented in terms of pollevent. why is that?
10:48:49 <Lemmih> parcs`: To not block the Haskell RTS, I think.
10:48:52 <yasar> bitonic: can I take both?
10:50:19 <davidd___> I saw some mentions online of Haskell Koans
10:50:22 <bitonic> yasar: well, for what concerns memoization, I like this post on SO: http://stackoverflow.com/questions/3208258/memoization-in-haskell/3209189#3209189
10:50:30 <tazjin> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in takeWhile (<4000000000) fibs
10:50:31 <davidd___> does anyone know of any haskell koans?
10:50:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:50:32 <parcs`> Lemmih: i believe only unsafe ffi imports block the rts.. perhaps if you import SDL_WaitEvent as safe you can implement waitEvent directly?
10:51:08 <bitonic> yasar: for what concerns fibonacci, you should "build up" to your values instead of recalculating the same thing multiple times
10:51:58 <dented42> @pl bwt a = map last (rots a)
10:51:58 <lambdabot> bwt = map last . rots
10:52:12 <bitonic> yasar: tazjin spoilt the fun :P
10:52:15 <dented42> @type map
10:52:16 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:52:48 <tazjin> bitonic: Pff, there's still more efficient versions to go after :P
10:52:57 <Lemmih> parcs`: Perhaps.
10:53:07 <yasar> Don't worry, I didn't get it anyways :D
10:53:21 <statusfailed> well that's annoying
10:53:24 <parcs`> Lemmih: i'll try it and report back to you
10:53:25 <statusfailed> ran out of memory again D:
10:53:27 <bitonic> yasar: you should work on it yourself, you'll learn more :)
10:53:35 <statusfailed> Does lazy IO hold everything in memory or something?
10:53:37 <ulfdoz> Wenn Oberweite oberhalb der Hfte meint, kommt das bestimmt hin.
10:53:40 <ulfdoz> ewin
10:53:45 <statusfailed> oh.... maybe I need lazy bytestrings
10:53:50 <dented42> @pl bwt a = map last (sort (rots a))
10:53:50 <lambdabot> bwt = map last . sort . rots
10:54:01 <Mathnerd314> @pl x >>= \r -> fromMaybe y (return r)
10:54:02 <lambdabot> fromMaybe y . return =<< x
10:55:06 <Mathnerd314> :t (<$>)
10:55:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:55:44 <Mathnerd314> :t (. return =<<)
10:55:45 <lambdabot> parse error on input `)'
10:56:19 <Mathnerd314> :t \x y -> x . return =<<y
10:56:20 <lambdabot> forall (m :: * -> *) b a (m1 :: * -> *). (Monad m1, Monad m) => (m1 a -> m b) -> m a -> m b
10:57:25 <Mathnerd314> arghh...
10:57:50 <byorgey> :t \x y -> return . x =<< y
10:57:51 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> m a1 -> m a
10:58:36 <otters> Is there a tool to add parentheses into a statement so you can figure out the precedence of its evaluation?
10:58:52 <byorgey> otters: yes, there is, let me find you the link
10:59:08 <Mathnerd314> @djjinn IO (Maybe a) -> IO a -> IO a
10:59:09 <lambdabot> Error: Undefined type IO
10:59:25 <byorgey> otters: http://bm380.user.srcf.net/prettyparsetree.cgi
10:59:26 <Mathnerd314> :t liftA2 fromMaybe
10:59:27 <lambdabot> forall a (f :: * -> *). (Applicative f) => f a -> f (Maybe a) -> f a
11:00:03 <c_wraith> Mathnerd314: that *probably* doesn't give you what you want, in IO.
11:00:07 <otters> byorgey: awesome
11:00:19 <c_wraith> Mathnerd314: it's likely you don't want the second action to be executed if the first one returned Just
11:00:29 <Mathnerd314> c_wraith: true.
11:05:49 <Mathnerd314> @undo do { r <- x; fromMaybe y (fmap return r) }
11:05:49 <lambdabot> x >>= \ r -> fromMaybe y (fmap return r)
11:06:04 <Mathnerd314> @pl x >>= \ r -> fromMaybe y (fmap return r)
11:06:04 <lambdabot> fromMaybe y . fmap return =<< x
11:06:18 <parcs`> Lemmih: yep, if you import it as safe it doesn't block other haskell threads. would you be willing to accept a patch that changes the current behavior?
11:06:22 <Mathnerd314> :t \y x -> fromMaybe y . fmap return =<< x
11:06:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m (Maybe a) -> m a
11:06:58 <Mathnerd314> @pl \y x -> fromMaybe y . fmap return =<< x
11:06:59 <lambdabot> (=<<) . (. fmap return) . fromMaybe
11:08:09 <Mathnerd314> probably nothing better I can do...
11:10:24 <Tomsik> You can always write a helper function
11:10:50 <Mathnerd314> well, it's only occurring 3 times
11:11:04 <Mathnerd314> do-notation is probably easiest
11:13:12 <Mathnerd314> :t liftA2 maybe
11:13:13 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f (a1 -> a) -> f (Maybe a1 -> a)
11:13:24 <Mathnerd314> :t liftA3 maybe
11:13:25 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f (a1 -> a) -> f (Maybe a1) -> f a
11:13:52 <Mathnerd314> :t \y x -> liftA3 maybe y id x
11:13:53 <lambdabot> forall a a1. ((a1 -> a) -> a) -> ((a1 -> a) -> Maybe a1) -> (a1 -> a) -> a
11:14:13 <Mathnerd314> :t \y x -> liftA3 maybe y (fmap id) x
11:14:14 <lambdabot> forall a a1. ((a -> a1) -> a1) -> ((a -> a1) -> Maybe a) -> (a -> a1) -> a1
11:14:40 <Mathnerd314> :t \y x -> liftA3 maybe y (return id) x
11:14:41 <lambdabot> forall a (f :: * -> *). (Monad f, Applicative f) => f a -> f (Maybe a) -> f a
11:15:18 <Mathnerd314> :t \y x -> liftA3 maybe y (pure id) x
11:15:18 <lambdabot> forall a (f :: * -> *). (Applicative f) => f a -> f (Maybe a) -> f a
11:16:04 <Mathnerd314> if Num can get a Show instance removed, can Monad get an Applicative instance added?
11:16:49 <xplat> roconnor: what is a multi-lens?
11:19:15 <roconnor> xplat: do you know what a lens and a partial-lens are?
11:21:07 <isaacbw> http://www.google-melange.com/gsoc/homepage/google/gsoc2012
11:21:08 <isaacbw> 40 minutes!
11:21:21 <isaacbw> wooo
11:21:42 <roconnor> isaacbw: you completed your gsoc project in 40 minutes?
11:21:52 <isaacbw> no, I mean student apps open in 40 minutes :P
11:23:50 <isaacbw> ooooooooh GEGL looks neat
11:24:04 <ski> @where+ lispifier Haskell Lispifier <http://bm380.user.srcf.net/prettyparsetree.cgi> -- Fully brackets an expression
11:24:04 <lambdabot> It is forever etched in my memory.
11:25:30 <hiworld> (\_ ->
11:25:40 <hiworld> (\_ -> 'a') (head [])
11:25:48 <hiworld> hi, how to run this code here?
11:26:43 <hiworld> or why it returs 'a' ?
11:26:51 <roconnor> xplat?
11:27:05 <hiworld> laziness?
11:27:11 <roconnor> xplat: I was going to explain multi-lens in relation to lenses and partial-lenses.
11:27:45 <geekosaur> hiworld, yes, laziness; since the lambda doesn't use its parameter, it never evaluates it
11:28:13 <hiworld> ok, so why there is no laziness here:
11:28:22 <hiworld> (\(_,_) -> 'a') (head [])
11:28:30 <gnoi> What is .: operator and where it from? Saw it here: http://codereview.stackexchange.com/questions/10327/avoiding-operator/10334#10334
11:28:34 <otters> :t \(_,_) -> 'a'
11:28:35 <lambdabot> forall t t1. (t, t1) -> Char
11:28:51 <hiworld> my ghci throws exception
11:28:54 <hiworld> (empty list)
11:29:00 <hiworld> in the second example
11:29:09 <geekosaur> because it's pattern matching to find a tuple
11:29:34 <hiworld> find it where? in the empty list?
11:29:48 <hiworld> so why patter matchig didn't try to find any character in the empty list?
11:29:50 <geekosaur> a bare type variable (or _) matches anything; (_,_) requires a tuple but doesn't match the contents of the tuple.  this requires it to revaluate the list
11:30:06 <hiworld> ok, see it
11:30:11 <Lemmih> parcs`: Did you try without -threaded?
11:30:22 <hiworld> so how to calculate the types of that two expressions?
11:30:30 <hiworld> the first one should be just Char?
11:30:45 <ski> > (\_ -> 'a') (head [])  -- hiworld, like this
11:30:46 <lambdabot>   'a'
11:31:07 <hiworld> > (\(_,_) -> 'a') (head [])
11:31:08 <lambdabot>   *Exception: Prelude.head: empty list
11:31:11 <geekosaur> the type of which?  nothing is known about the type of the list in the first case; in the second it's forall a b. [(a,b)] --- we don't know any more details.
11:31:24 <ski> > (\ !_ -> 'a') (head [])
11:31:25 <lambdabot>   *Exception: Prelude.head: empty list
11:31:47 <hiworld> :t (\_ -> 'a') (head [])
11:31:48 <lambdabot> Char
11:31:56 <hiworld> :t (\(_,_) -> 'a') (head [])
11:31:57 <ski> hiworld : to match an input with the `_' pattern (as well as matching it with a variable pattern), the input isn't forced
11:31:57 <lambdabot> Char
11:32:17 <ski> hiworld : to match it with a constructor pattern (like `(,) _ _'), the input is forced
11:32:17 <otters> > const undefined 1
11:32:18 <lambdabot>   *Exception: Prelude.undefined
11:32:35 <hiworld> but shoudn't the laziness define the types?
11:32:45 <hiworld> in the first example it should be just Char
11:32:51 <hiworld> in the second one, Char too
11:32:52 <osa1> so parsec's `parse` returning parsed text objects as strings, is there a way to get results as text or should I convert them with `Text.pack` ?
11:33:17 <ski> hiworld : the type is `Char' in all examples, no ?
11:33:48 <geekosaur> yes, the type of the entire expression is well defined in both cases.  not related to laziness; we can make the first one strict and it will still be well typed
11:33:55 <geekosaur> evne though it will diverge if evaluated
11:34:05 <hiworld> wait, i want to calculate the type of (\_ -> 'a') (head [])
11:34:18 <hiworld> and the type of that expression should be just Char
11:34:27 <hiworld> 'cos it's defined by lambda expression, right?
11:35:00 <ski> the type is `Char' since that's the type of the body expression in the abstraction, yes
11:35:28 <hiworld> what do You mean by "body expression"?
11:35:32 <hiworld> -> 'a' ?
11:35:49 <mauke> \ PARAMETER -> BODY
11:35:56 <inv__> hi all
11:35:57 <hiworld> ok
11:36:13 <hiworld> what about :t (\(_,_) -> 'a' ) (head []) ?
11:36:19 <weexplat> roconnor: i know what a lens is and i have a reference to what a partial-lens is, but i don't know what it is yet
11:36:23 <ski> hiworld : no difference
11:36:33 <ski> the type of the body expression is the same
11:36:36 <hiworld> even patter matching will throw the exception, the type is still Char, right?
11:36:41 <ski> yes
11:36:56 <weexplat> roconnor: sorry for the slow reply
11:37:02 <ski> type-checking is done before the code is even executed
11:37:03 <hiworld> so to calculate the type of any lambda function i need to check it's body type, right?
11:37:40 <ski> hiworld : to calculate the type of any *application* of a lambda expression, you need to check the body type
11:37:52 <hiworld> :t (\_ -> fun_body ) (another_func)  :: :t (fun_body) ?
11:37:52 <lambdabot> parse error on input `:'
11:38:05 <hiworld> i mean something like that
11:38:09 <ski> (and you also need to make sure that the type of the formal parameter is the same as the type of the actual parameter, otherwise it's not type-correct)
11:39:11 <hiworld> ok, thanks a lot for help :)
11:39:34 <rhubarb> could anyone who develops on mac osx give me some pointers, is homebrew the best way to go about setting up?
11:39:37 <hpaste> inv__ pasted “type-class” at http://hpaste.org/66018
11:39:58 <inv__> Hello, I made some example with type-classes
11:40:20 <inv__> I do not understand why it works for 2 parameters and does not work for three parameters.
11:40:42 <ski> hiworld : in general, to calculate the type of any application, you need to check the type of the operator expression, make sure it's of the form `t0 -> t1'; also check the type of the operand expression, making sure it has the *same* type `t1'; then the type of the whole application is `t1'
11:40:43 <inv__> No instance for (Apl Int Int a0)   arising from a use of `plus'
11:40:51 <geekosaur> rhubarb, using the official haskell platform installer is probably the best way to get set up.  homebrew is tolerable.  macports is not and will tend to bite you in the butt
11:41:19 <Kn|t3_> HI
11:41:24 <Kn|t3_> I am new to haskell
11:41:34 <inv__> but there is Int->Int->Int, why is it not ok for ghc?
11:41:36 <Kn|t3_> this is my first lhs script and I am using ghci
11:41:52 <Kn|t3_> http://codepad.org/qZTVk4uT is the code
11:42:07 <rwbarton> inv__: it doesn't know what result type to use
11:42:09 <ski> preflex: xseen therp
11:42:10 <preflex>  therp was last seen on freenode/#xmonad 245 days, 3 hours, 44 minutes and 39 seconds ago, saying: nicoo: well, I can trick xmonad, by echo '#!/bin/bash; if [ -e "triggerFileForFvwm]; then fvwm; else /usr/bin/xmonad "$*"; fi'  > bin/xmonad
11:42:12 <danharaj> inv__: What if I also defined instance Apl Int Int Banana?
11:42:17 <danharaj> How would GHC know which instance to use?
11:42:30 <Kn|t3_> it shows parse error on input cube, line 16:11
11:42:32 <Kn|t3_> can someone help me
11:42:47 <Kn|t3_> any idea what the error can be
11:42:53 <inv__> danharaj, but why I can make Int->Int and Int->String, for example?
11:43:28 <inv__> danharaj, If I understand correct, where is not different Int->Int->Int and Int->Int->String
11:44:10 <rwbarton> your questions seem to be missing a lot of words
11:44:12 <danharaj> inv__: You have to tell ghc what the type of r is so it knows what the return type is.
11:44:27 <danharaj> So it can pick the instance with the correct third type.
11:44:35 <ClaudiusMaximus> inv__: you possibly want fundeps so Apl a b c  knows that c is uniquely determined by a and b
11:44:39 <mekeor> Kn|t3_: does it work with "usual" (not-literal) haskell?
11:44:43 <hiworld> where is Your problem Kn|t3 ?
11:44:49 <Kn|t3_> mekeor: yes
11:44:51 <inv__> danharaj, yes, I know, but .. just a sec
11:44:58 <hiworld> just write Your lines into the file and use ghci :l this_file.hs
11:45:01 <mekeor> Kn|t3_: do you use codepad.org as compiler?
11:45:06 <Kn|t3_> if i remove those lines with cube, it works
11:45:12 <Kn|t3_> I am using ghci on my machine
11:45:26 <rwbarton> Kn|t3_: is this a .lhs file?
11:45:29 <hiptobecubic> hackage needs image support
11:45:42 <Kn|t3_> yes
11:45:46 <mauke> Kn|t3_: works here
11:45:46 <rwbarton> oh ok
11:45:49 <xplat> roconnor: and ... the reference to partial lenses doesn't work
11:45:53 <Kn|t3_> on ghci?
11:45:59 <xplat> (0-byte pdf)
11:46:02 <inv__> danharaj, the problem is that in this case it is possible to find correct instance: (+) Int->Int is ->Int
11:46:07 <mauke> Kn|t3_: yes
11:46:11 <Kn|t3_> mauke: so i save this file. and then I run ghci and then :l firstscript.lhs
11:46:12 <Kn|t3_> rite?
11:46:28 <osa1> can anyone help me? I was using websockets until few hours ago, now I can't import it and I started to get this error when I try to re-install http://paste.pocoo.org/show/571640/
11:46:33 <mauke> Kn|t3_: that's one way, yes
11:46:39 <Kn|t3_> mauke: what is another way
11:47:15 <inv__> danharaj, ok, sorry, looks like I understand the problem now :)
11:47:20 <mauke> Kn|t3_: ghci thatfile.lhs
11:47:25 <hiworld> Kn|t3 - what errors did you get?
11:47:28 <Kn|t3_> mauke, thanks
11:47:42 <rwbarton> inv__: that's not how it works. it figures out what instance it should look for based on the type and then checks whether that instance exists. it does not go browsing through the instances that happen to be at hand -- since then the program could break if a new instance is added
11:47:53 <Kn|t3_> firstscript.lhs:9:11: parse error on input `cube'
11:48:12 <Kn|t3_> but I just copied the code in another file and that works perfect. This is strange
11:48:35 <rwbarton> stop using tabs
11:48:46 <mauke> Kn|t3_: are you using tabs?
11:48:49 <inv__> rwbarton, are there any workaround? I would like to have something like APL functions, which work with arrays.
11:49:03 <Kn|t3_> yeah, but I have expandtab set. So it should be converted to spaces automatically.
11:49:19 <Kn|t3_> by the way, should I not use tabs? they aren't allowed in haskell?
11:49:21 <inv__> for example: plus which works with atom and array
11:49:36 <rwbarton> "firstscript.lhs:9:11:" strongly suggests you have a tab character on line 9
11:49:37 <mauke> Kn|t3_: they are technically allowed
11:49:39 <geekosaur> tabs are allowed but are not generally consistent between environments
11:50:06 <roconnor> weexplat: IRC died on me, so I don't know how much of what I said that you got.
11:50:07 <geekosaur> so they tend to cause problems if you switch editors or share your code
11:50:22 <mauke> Kn|t3_: the problem is that haskell insists on putting tabstops every 8 characters
11:50:40 <rwbarton> tabs are defined in Haskell to advance to the next multiple of 8 columns, most people who use tabs in their files don't have their editor set to a tab width of 8
11:50:49 <rwbarton> so what they see is not what the compiler sees
11:51:00 <Kn|t3_> ah ok.
11:51:05 <Kn|t3_> I think I get it now.
11:51:26 <osa1> can anyone help me? I was using websockets until few hours ago, now I can't import it and I started to get this error when I try to re-install http://paste.pocoo.org/show/571640/
11:51:47 <Kn|t3_> so even if I do expandtab, that would just mean that I see no tabs, but its the haskell compiler sees tabs with eight spaces.
11:51:56 <rwbarton> inv__: yes, you can use type families or functional dependencies
11:52:02 <mauke> no, expandtab puts spaces in the file
11:52:06 <mauke> so that is fine
11:52:34 <mauke> :set et sw=4 sts=4
11:52:37 <mauke> :retab!
11:53:54 <Kn|t3_> right, thanks mauke
11:55:09 * hackagebot jalla 0.1.0.1 - Higher level functions for linear algebra. Wraps BLAS and LAPACKE.  http://hackage.haskell.org/package/jalla-0.1.0.1 (ChristianGosch)
11:55:10 <inv__> rwbarton, thx, will google for it.
11:55:57 <osa1> how can I delete all packages installed by cabal? is deleting .cabal ok? I'll try installing them again
11:56:27 <c_wraith> osa1: delete ~/.ghc
11:57:18 <c_wraith> osa1: you can delete ~/.cabal also, but note that it contains binaries and the config file - so be careful if you want to keep them
11:57:19 <monochrom> deleting .cabal does almost nothing
11:57:55 <c_wraith> deleting .cabal can break packages badly, if you don't also delete ~/.ghc
11:58:15 <osa1> c_wraith: monochrom: thanks. I deleted both
11:58:37 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml describes the actual contents of those directories. verify, don't speculate.
11:59:41 <c_wraith> I mean, I've broken packages by deleting things inside .cabal recklessly.  I didn't care, but it was amusing.
11:59:45 <monochrom> and why you should never allow yourself two instances of network-2.3.0.5
12:00:35 <inv__> I added | a b -> c, and my example works fine, But I do not understand what does it mean: "This tells Haskell that c is uniquely determined from a and b."
12:01:15 <monochrom> if you let me know the class name, I can explain to you in concrete
12:02:04 <hpaste> inv__ pasted “class with func deps” at http://hpaste.org/66019
12:02:59 <inv__> monochrom, http://hpaste.org/66019
12:03:42 <monochrom> this means if you have "instance Char () Bool" you promise you will never have "instance Char () Double" or in general "instance Char () Anything_Other_Than_Bool"
12:03:53 <monochrom> subsequently, it helps type inference
12:04:44 <monochrom> if you write code "plus 'c' ()", the compiler just knows the type must be Bool, as per your promise
12:04:55 <inv__> clear: it just adds a restriction.
12:05:49 <inv__> thx, will google for type families then :)
12:06:03 <monochrom> in general, "a b -> c" means to the compiler: once a,b are known, it can just look up what c is, you promise there can only be 0 or 1 answer, not 2.
12:07:26 <inv__> ok, thx, got it.
12:09:12 <Prophec> are there any downsides to using haskell for long standing network servers?
12:09:27 <monochrom> no
12:09:39 <`Jake`> Can I start a program via a haskell program?
12:09:47 <Clint> yes
12:09:47 <exFalso1> `Jake`: yes
12:09:51 <monochrom> yes. look for System.Process
12:09:56 <`Jake`> thanks
12:11:39 <Prophec> supprised there are not more servers in haskell.  seems like being forced to flesh out all of your code paths would be a good thing for a stable service
12:18:25 <Mathnerd314> monochrom: so, from your SICP, it seems like the main problem is that GHC is really bad at detecting ABI changes...
12:18:43 <hpaste> shergill pasted “ffi example” at http://hpaste.org/66021
12:19:16 <monochrom> no, the opposite. it is very good at detecting ABI changes. the main problem is that ABI changes are too easy to get.
12:19:45 <shergill> could someone help me with the compilation error i'm getting in the above hpaste?
12:20:58 <hpaste> shergill pasted “ffi example” at http://hpaste.org/66023
12:21:13 <geekosaur> shergill, you need to tell ghc where to find the C isDst function
12:21:25 <monochrom> 6.10 and before did not detect ABI change at all. false sense of "no inconsistency" when there were plenty. libs crashed left right and centre
12:21:39 <shergill> geekosaur: how do i do that?
12:21:51 <geekosaur> "ghc --make" is not omnipotent, it will not build the C source for you nor find the .o file resulting
12:21:54 <Mathnerd314> monochrom: false positives and false negatives are both bad...
12:22:26 <monochrom> there are very few false alarms. if the hash changes, it is highly likely a real ABI change
12:22:42 <geekosaur> it only can follow properly registered Haskell modules, it doesn't know how to find C modules even in the same directory.  so you would need to compile that separately and list the .o on the ghc --make line
12:23:09 <shergill> geekosaur: ah ok
12:23:19 <geekosaur> also note that with the main() in the C source you'll get conflicting symbols
12:23:46 <monochrom> you do not accept this because you are experienced in C, only intra-procedural optimizations, changing optimizations flags does not change ABI, changing dependencies does not change ABI, etc etc. but GHC is not C
12:24:37 <monochrom> I have explained this in my article. if X depends on Y depends on Z, replacing Z code can change X's ABI, and it is a real change.
12:24:56 <monochrom> because GHC does almost-global optimizations aggressively
12:28:25 <Mathnerd314> ah, ok. nvm then
12:30:11 * hackagebot test-framework-doctest 0.2.1 - Test.Framework wrapper for DocTest  http://hackage.haskell.org/package/test-framework-doctest-0.2.1 (SakariJokinen)
12:37:09 <osa1> I'm having trouble setting up a warp websocket server, does anyone have any examples about it?
12:38:55 <Rc43> Hi, guys.
12:39:56 <Rc43> I am wondering why different libs are installed with pkg-config and I can view them with `pkg-config --list-all`; but there is no `PKG_CONFIG_PATH` variable.
12:40:09 <Rc43> How can they be remembered by pkg-config?
12:40:11 * hackagebot hmm 0.2.1.1 - A hidden markov model library  http://hackage.haskell.org/package/hmm-0.2.1.1 (MikeIzbicki)
12:40:54 <Rc43> I am interesting because I often find instructions to set up `PKG_CONFIG_PATH` manually.
12:41:07 <Rc43> (Now I am trying to isntall libxml for glade.)
12:43:09 <aleksi> this is pretty neat
12:44:25 <teneen> Why is it that in the Alternative instance of [], (<|>) = (++)? ... I think the instance should be similar to that of the Maybe type. If the left argument succeeds return it else return the right argument.
12:44:52 <monochrom> darn me. I make the mistake of rewriting "f (runST $ dodo)" to "(f . runST) $ dodo" :)
12:45:32 <dolio> Do we all love the $ special case?
12:45:38 <monochrom> haha
12:45:43 <dylukes> Hm?
12:45:55 <adnauseam> what''s $'s special case ? :o
12:45:58 <dolio> $ is special cased to work with runST $ ...
12:46:04 <dylukes> It is?
12:46:07 <dolio> Nothing else works with it. Only dollar sign.
12:46:11 <monochrom> you know how $ is made special just so as to help "runST $ dodo" to work
12:46:24 <dylukes> dolio: What do you mean nothing else works with it o.0
12:46:35 <adnauseam> > :t runST
12:46:36 <lambdabot>   <no location info>: parse error on input `:'
12:46:47 <monochrom> $ receives its own type rule, the same rule as function application. IOW, in the type checker, $ is considered built-in
12:46:51 <dolio> dylukes: I mean if you define your own apply function, named anything other than $, it won't work.
12:47:09 <dolio> The name $ is special cased in the type checker.
12:47:18 <dylukes> I see :\.
12:47:27 <monochrom> so for example "runST `id` dodo" does not enjoy the same privilege
12:48:24 <monochrom> it is a difficult story because runST has a rank-2 type. you either special-case something or you have to go real impredicative
12:52:49 <yzabtech> Hi guys
12:53:33 <bitonic> HI yzabtech
12:54:12 <yzabtech> Lol, in step5, I got Macehil as my evil memesis
12:54:16 <yzabtech> nemesis*
12:57:42 <mikkihiiri> hi there
12:58:42 <mikkihiiri> we have a weekly exercise in school that requires us to find a longest successor sequence from a list of integers.. I've been wondering about this for two nights now and I can't seem to find a solution. Could you point me to right technique?
12:58:51 <mikkihiiri> recursion? lambda? folding?
12:59:35 <exFalso1> mikkihiiri: well the easiest solution is to sort the list
12:59:36 <mikkihiiri> successor sequence is a sequence of integers like 1,2,3,4 etc
12:59:46 <exFalso1> oh successor
12:59:48 <danharaj> exFalso1: that would be wrong.
12:59:56 <exFalso1> well then just recurse on the list
13:00:11 * hackagebot test-framework-doctest 0.2.1.1 - Test.Framework wrapper for DocTest  http://hackage.haskell.org/package/test-framework-doctest-0.2.1.1 (SimonHengel)
13:00:17 <mikkihiiri> like if the list is 1,2,3,5,6,7,8,12,13 the function should return 4
13:00:50 <exFalso1> so you need to return the biggest difference between neighbouring numbers?
13:01:04 <mikkihiiri> recursion is not so easy.. i can get the count of first successor list or the last
13:01:16 <danharaj> exFalso1: no, the longest run is 5,6,7,8
13:01:22 <exFalso1> ah the longest run
13:01:48 <mikkihiiri> but somehow i should be able to "remember" the old sequences in order to find the longest
13:01:48 <exFalso1> ok... so you need to keep track of the longest so far and the length of the current one
13:01:53 <mikkihiiri> yeah!
13:02:09 <exFalso1> so do that :)
13:02:12 <danharaj> mikkihiiri: There's another thing you can try. What is true about two disjoint runs inside a list?
13:02:44 <mikkihiiri> exFalso1: but how? using let?
13:03:02 <mikkihiiri> if i use recursion I cant define variables inside the function
13:03:26 <mikkihiiri> danharaj: sorry don't understand.. disjoint?
13:04:01 <exFalso1> mikkihiiri: you need to pass around those arguments
13:04:27 <danharaj> mikkihiiri: What I'm getting at is that you can cut up the list into runs that don't overlap with each other.
13:04:30 <mikkihiiri> but i can't.. the exercise says that the only argument should be the list of integers
13:04:41 <danharaj> [Int] -> [[Int]]
13:05:13 <exFalso1> mikkihiiri: you can always define local functions
13:05:16 <mikkihiiri> danharaj: but the function should return just one integer
13:05:34 <danharaj> mikkihiiri: What can you do with the list of disjoint runs in order to get one integer?
13:05:37 <exFalso1> you can use "let" or a "where" clause
13:05:59 <danharaj> (There are lots of answers but one is useful to you)
13:06:24 <mikkihiiri> danharaj: mmm. folding? :D
13:06:35 <danharaj> mikkihiiri: Which fold would you like? :)
13:06:45 <mikkihiiri> dunno..
13:06:56 <mikkihiiri> we really haven't talked about those in our classes
13:07:33 <exFalso1> mikkihiiri: have you talked about map?
13:07:37 <mikkihiiri> yeah
13:07:48 <danharaj> hmm, is the point of the exercise to use what you already know or figure out new stuff?
13:07:55 <exFalso1> :t maximum
13:07:56 <lambdabot> forall a. (Ord a) => [a] -> a
13:08:17 <mikkihiiri> but using map returns a list doesn't it?
13:08:27 <exFalso1> can you think of a way to combine a map and maximum to get the answer?
13:08:44 <danharaj> pff, maximum is defined in terms of a fold.
13:08:53 <exFalso1> (given that you already have the list of runs)
13:09:02 <exFalso1> danharaj: i know but they havent covered it yet
13:09:19 <mikkihiiri> we have classes on monday and tuesday and on thursday we get exercises based on those two classes.. but last week we had so much new stuff that i'm confused what to use.. we had recursion, lambdas, folding etc.
13:09:56 <mikkihiiri> so i should use map to find lenght of all successor sequences and the use maximum to find the longest one?
13:10:02 <exFalso1> exactly
13:10:04 <danharaj> mikkihiiri: you got it.
13:10:17 <danharaj> mikkihiiri: Now you have to write a function to chop up the list into runs.
13:10:34 <danharaj> This will require recursion.
13:12:33 <ski> > successorStreaks [1,2,3,5,6,7,8,12,13]
13:12:35 <lambdabot>   [[1,2,3],[5,6,7,8],[12,13]]
13:12:39 <elliott> gwern: your irc client is broken
13:12:52 <danharaj> why is that function defined
13:13:02 <mikkihiiri> whoa :O
13:13:07 * ski just defined it
13:13:14 <danharaj> I didn't SEE you define it.
13:13:15 <danharaj> Are you a wizard?
13:13:22 <danharaj> Are you lambda bot?
13:13:24 <elliott> > isSkiAWizard
13:13:25 <lambdabot>   True
13:13:29 <danharaj> :o :o :o
13:13:30 <elliott> IT KNOWS EVERYTHING
13:13:31 * ski sometimes whispers secrets in lambdabot's ear
13:13:39 <mikkihiiri> :D
13:13:55 <elliott> The definitions are coming from inside the house.
13:14:10 <shapr> What's the irc channel for GSoC?
13:14:15 <ski> @where house
13:14:15 <lambdabot> http://programatica.cs.pdx.edu/House/
13:14:39 <ski> mikkihiiri : so, you need to define such a function ..
13:15:12 <mikkihiiri> yeah first.. then use maximum with that..
13:15:36 <mikkihiiri> easier said than done..
13:16:00 <ski> well, you just have to keep comparing adjacent elements
13:16:05 <mikkihiiri> yeah..
13:16:12 <shapr> ski: house is awesome :-)
13:16:18 <ski> so, make a helper function that is passed the previous element, together with the current tail
13:16:31 <ski> then you can compare them to see whether to break at this point or not
13:16:59 <ski> the general idea in
13:17:00 <ski> @src span
13:17:00 <lambdabot> span _ xs@[]                     =  (xs, xs)
13:17:01 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
13:17:01 <lambdabot>                   | otherwise    =  ([],xs)
13:17:05 <ski> might be helpful
13:18:06 <squark42> Hi. I am searching for a master thesis and want to do a compiler related project (not fronted, more backend like LLVM). Does anyone know a research group which works at compiler backends and uses Haskell?
13:18:11 <ski> (i.e. the idea of having the helper return a pair of results, which you add stuff to)
13:18:48 <DanBurton> @wiki compilers
13:18:48 <lambdabot> http://www.haskell.org/haskellwiki/compilers
13:18:58 <DanBurton> boo
13:19:00 <shapr> squark42: Have you seen UHC from ... I forget which Dutch uni.
13:19:15 <ski> @where UHC
13:19:15 <lambdabot> The Utrecht Haskell Compiler, implemented using attribute grammars, at <http://www.cs.uu.nl/wiki/UHC>
13:19:16 <shapr> squark42: Or NHC from one of the UK colleges.
13:19:22 <squark42> yeah, I know it's Utrecht university - but they are more interested in the frontent
13:19:27 <shapr> I heard about EHC, but I don't know if was ever released.
13:19:47 <squark42> in particular I think they think of C as a backend
13:20:03 <shapr> squark42: Your research is most likely to be integrated into wide use if you do something with GHC though.
13:20:27 <shapr> For example, GHC recently added native ARM support (well, 'registerized')
13:20:46 <elliott> oh, is unregistered a pun because it doesn't use the registers?
13:20:55 <shapr> yes, it is.
13:21:10 <shapr> standard evil programmers puns.
13:22:10 <yitz> > doesLambdabotListenToPrivateIRCMessages
13:22:11 <lambdabot>   True
13:22:58 <Claudius1aximus> there's the accelerate stuff if you're thinking of parallel/gpu backend
13:23:26 <squark42> yeah, that sounds all nice
13:24:45 <squark42> I also had the idea to do something like a toy c subset compiler but also integrate assembler and linker for the possibiliy of teaching a full compiler toolchain, but so far I did not find professors which find it interesting (and I agree, it's not research oriented, but I think it would be a nice example)
13:25:32 <squark42> so, if somebody knows somebody who would be interested in that, I would be glad to know :)
13:26:13 <kaitocracy> how do I do regular expression matching with Data.Text?
13:28:15 <squark42> btw. how does the main work on GHC?
13:29:36 <exFalso> squark42: yeah we had a very similar project in our uni
13:29:36 <exFalso> with a fictional language tho
13:30:11 <squark42> yeah, but I think it would be nice to do a whole toolchain
13:30:58 <squark42> e.g. I have the feeling that most of the compiler talking (involving FP languages) is always about parsers although I think the hard part would be the backend
13:31:57 <exFalso> squark42: we had to write the backend too, ia32
13:32:08 <Claudius1aximus> the atom stuff might also be interesting - http://hackage.haskell.org/package/atom
13:32:10 <squark42> that's cool
13:32:27 <mikkihiiri> seems I can't get it to work.. Gotta sleep now so I'll probably be back tomorrow. Thanks guys!
13:32:52 <exFalso> mikkihiiri: may the lambda be with you, always
13:36:06 <exFalso> squark42: so i guess what im saying is that this is more of a second year group project rather than a thesis, unless you come up with something special for the compiler. in our case it was a master student who came up with the language for example
13:36:26 <exFalso> (that was his thesis)
13:37:50 <squark42> coming up with a new language is of course even cooler, although the definition of "new" is hard ;)
13:38:14 <xplat> roconnor: turns out i don't know what partial lenses are either :(
13:39:32 <roconnor> xplat: a partial lens, PLens A B, is a reference to a particular substructre of type B in a superstructure of type A or it is a null reference.
13:39:52 <roconnor> xplat: basically it is a nullable Lens
13:40:15 <elliott> xplat: a -> Maybe (b, b -> a)
13:40:18 <elliott> unless i'm wrong :)
13:40:27 <elliott> as opposed to lens' a -> (b, b -> a)
13:40:28 <roconnor> xplat: that is the optimized represenation
13:41:02 <roconnor> xplat: the "real| representation is a -> (Either a (b, b -> a)) that satifies the get/set laws.
13:41:08 <roconnor> *"real"
13:41:40 <xplat> ah
13:42:30 <xplat> so you can write one nontrivial PLens (Maybe a) a
13:42:46 <xplat> sounds simple
13:42:55 <xplat> roconnor: so what's a multi-lens?
13:44:21 <elliott> roconnor: hmm, that's a strange "real" representation
13:44:24 <roconnor> right, the PLens (Maybe a) a is a type Maybe a -> Either (Maybe a) (a, a -> Maybe a) that satifies the get/set laws.
13:44:30 <danharaj> What the hell is a rigid skolem type variable and why is it escaping :\
13:44:33 <elliott> is it ever OK for lens a to be Left b for a =/= b?
13:44:44 <roconnor> xplat: in this case the value would be
13:45:05 <roconnor> maybeLens Nothing = Left Nothing -- indicating no a found and returning the value back.
13:45:39 <roconnor> maybeLens (Just x) = Right (x, Just) -- indicating a value a was found and returning the store containing the value found and the updating function.
13:46:05 <roconnor> xplat: We also have a headLens :: PLens [a] a
13:46:13 <xplat> danharaj: you probably won't understand that unless you read the OutsideIn(X) papers
13:46:20 <roconnor> headLens [] = Left [] -- no head value found
13:46:21 <xplat> well, one would do
13:46:42 <roconnor> headLens (x:xs) = Right (x,(:xs)) -- inducating a value was found.
13:46:48 <danharaj> xplat: Well I have to figure out why this isn't typing because of them :(
13:46:55 * elliott is guessing "no" at this point
13:46:59 <elliott> danharaj: hpaste?
13:47:07 <elliott> you can usually ignore the skolem part and concentrate on the escaping part
13:47:21 <danharaj> elliott: It's kind of complicated without context. I'll post and elaborate until it becomes intelligible.
13:47:51 <exFalso> arent skolem types the ones which are implicitly quantified? (rankN types?)
13:47:55 <roconnor> elliott: indeed, the "extract" coalgebra law implies that if a PLens returns Left, it must return the original value back.
13:48:20 <roconnor> elliott: this is why we can "optimize" away the Either clause and replace it with Maybe.
13:49:24 <exFalso> in natural deduction skolem variables are the ones which are used for forall-introduction and exists-elimination iirc
13:49:25 <roconnor> elliott: a -> Either a (b,b -> a) is the "real" represenation because it is the coalgebra for the (Identity :+: Store b) comonad.
13:49:43 <elliott> roconnor: Right. The Maybe representation seems a little more obvious, of course :)
13:49:51 <hpaste> danharaj pasted “blah” at http://hpaste.org/66027
13:50:08 <roconnor> Coalgebra (Identity :+: Store b) a = a -> (Identity :+: Store b) a = a -> Either a (Store b a) = a -> Either a (b,b -> a)
13:50:09 * elliott always wondered what type of lens lets you have Lens (IORef a) a.
13:50:12 <eacameron> I just discovered "unsafePerformIO" ... I feel that Haskell has been corrupted :(
13:50:26 <roconnor> elliott: I haven't considered that before.
13:50:29 <magicman> :t unsafeCoerce
13:50:30 <lambdabot> Not in scope: `unsafeCoerce'
13:50:33 <ion> eacameron: It doesn’t exist. You’re hallucinating.
13:50:34 <magicman> Awww.
13:50:39 <elliott> eacameron: it's used only when you can prove the net result is pure
13:50:41 <xplat> elliott: well, also from a programmatic perspective the 'real' rep is nice too, because you can drop the argument to the lens without looking at it and still not lose its value in the Left case
13:50:42 <exFalso> eacameron: i dont know what you're talking about
13:50:58 <danharaj> Basically, I have a thing that takes a stream of input and outputs multiple streams of data. The streams are indexed by a type (o a) which should be a GADT.
13:50:58 <elliott> eacameron: you can do lots of fancy "optimisations" using it... but 99% of the time you don't want or need it
13:51:07 <elliott> xplat: right
13:51:12 <roconnor> xplat: so think of a lens as a reference to a single substructure of type B, and a partial lense as a reference to 0 or 1 substructures of type B.
13:51:37 <roconnor> xplat: then a multi-lens is a reference to 0 or more disjoint substructures of type B.
13:51:38 <eacameron> elliott: optimizations? oh boy...optimize right out of the type system!
13:51:49 <elliott> eacameron: that's what unsafeCoerce is for
13:52:05 <roconnor> xplat: (which also happens to be "the same" as Biplates from Neil Mitchel's Uniplate library).
13:52:12 <elliott> anyway, Haskell is hardly so perfect as to be corrupted by unsafePerformIO. we still have head and tail.
13:52:25 <zhulikas> test :: Integral (forall a.a) -> a -> Int
13:52:25 <zhulikas> how should I rewrite this?
13:52:25 <zhulikas> it doesn't compile
13:52:25 <zhulikas> I mean ScopedTypeVariables
13:52:33 <elliott> zhulikas: that doesn't make any sense
13:52:39 <elliott> Integral is a class, for a start
13:52:41 <zhulikas> true
13:52:46 <eacameron> elliott: how are head and tail impure?
13:52:51 <zhulikas> but I have this situation
13:52:56 <elliott> eacameron: they're not impure, but they're ugly.
13:53:00 <zhulikas> where type variable is bounded to a class
13:53:15 <zhulikas> and I need to access that type through function body
13:53:25 <elliott> eacameron: anyway, you should be happy unsafePerformIO exists. it means that when we want efficient memoisation, we don't have to modify the compiler.
13:53:37 <elliott> or when we want arrays that automatically parallelise operations on them (see repa)
13:53:47 <exFalso> test :: forall a. Integral a => a -> Int
13:54:00 <danharaj> I think the SafeHaskell extension tames unsafePerformIO
13:54:01 <exFalso> and then you can use the type with ScopedTypeVariables
13:54:20 <xplat> roconnor: ah, so lens : ∂ :: multilens : e^∂
13:54:23 <elliott> danharaj: by forbidding it
13:54:51 <xplat> roconnor: how is it represented?
13:55:17 <Luke> I'm trying to use forkIO but I think my threads are stopping when the main thread stops. Is there an easy way to wait on the threads? I've seen it talked about but never really clearly explained
13:56:05 <tgeeky_> xplat: as in roconnor's package, multiplate
13:56:10 <Cale> Luke: Right, when the main thread ends, the entire program does.
13:56:11 <roconnor> xplat: a reference to 2 substructures would be Coalgebra (StoreT b (StoreT b Identity)) a = a -> StoreT b (StoreT b Identity) a = a -> (b,(b,b->b->a))
13:56:32 <Cale> Luke: Depending on what youyou can have the main thread
13:56:36 <Cale> oops
13:56:51 <roconnor> xplat: a reference to 1 or 2 substructures would be Coalgebra (StoreT b Identity :+: StoreT b (StoreT b Identity)) a = ...
13:56:51 <Cale> Luke: Depending on what you're doing, you can have the main thread take an empty MVar or something
13:56:56 <Luke> Cale: I'm just looking for an easy way to keep the threads running after the main thread exits really
13:57:08 <danharaj> I think the problem is that in the rank 2 type I'm passing in I am applying constructors to the variable?
13:57:13 <Luke> Cale: yeah I see that example in the docs - just seems like a lot of code =D
13:57:23 <roconnor> xplat: so a reference to 0 or more substructures would be Coalgebra (Identity :+: StoreT b Identity :+: StoreT b (StoreT b Identity) :+: ...)
13:57:36 <Cale> It shouldn't be too bad...
13:58:00 <Cale> You just want the main thread to block so that you can let the other threads work
13:58:02 <xplat> so Multilens A B would be iso to Lens a (Vec b n)
13:58:04 <xplat> ?
13:58:06 <Cale> (not exit)
13:58:12 <Luke> Cale: there's "preformUnsafeIO" etc going on
13:58:16 <Luke> Cale: i'm trying to avoid that
13:58:21 <Cale> What?
13:58:31 <Cale> You shouldn't need unsafePerformIO at all
13:58:40 <Luke> Cale: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#v:forkIOUnmasked
13:58:47 <Luke> the example's above that function def
13:59:03 <elliott> that's because it's using a global list
13:59:16 <elliott> you'll need to carry around your state in some other way
13:59:24 <elliott> e.g. by working on StateT [MVar ()] IO
13:59:26 <exFalso> danharaj: can you hpaste please?
13:59:28 <elliott> 8working in
13:59:31 <Luke> elliott: talking to me?
13:59:32 <danharaj> exFalso: I did.
13:59:33 <Cale> Luke: oh, you don't need to do that
13:59:50 <roconnor> xplat: Lens a (Vec b n) would let you change the number of occurances of B.  A multi-lens forces you to maintain the same number of B's however many they are.
13:59:56 <danharaj> http://hpaste.org/66027
13:59:57 <kaitocracy> so I have an IO [type1] and a function mapping :: type1 -> type2, what is the best way to get an IO [type2]?
14:00:07 <Cale> Luke: I'm just saying have a single MVar which you create in your main thread and take the MVar immediately after spawning all your child threads
14:00:08 <roconnor> xplat: similarly PLens a b and Lens a (Maybe b) are different.
14:00:11 <danharaj> I'm afraid it'll be completely obscure to someone else though.
14:00:12 <Claudius1aximus> main = do { forkIO worker ; takeMVar =<< newEmptyMVar }  -- will(?) crash with a "all threads blocked on mvar operation" exception when the worker dies, but otherwise should work ok?
14:00:30 <mauke> kaitocracy: fmap . fmap
14:00:38 <kaitocracy> ahh I was missing that second fmap
14:00:40 <roconnor> xplat: Lens a (Maybe b) would let you insert a new B when one doesn't exist, while PLens a b disallows this.
14:00:45 <xplat> roconnor: you may be thinking of Lens a [b] ... i did leave out an existential quantifier there, though, that fixes the number of bs to be the same for in and out
14:01:06 <Luke> Cale: what do I do with the MVar in the main thread to wait on all the child threads?
14:01:12 <mekeor> what does (<=<) do ?
14:01:19 <roconnor> xplat: ya, I think if you pull out the existential quantifier it is correct.
14:01:23 <Cale> Luke: take the MVar when it's empty
14:01:27 <roconnor> xplat: not 100% certain, but probably.
14:01:33 <Cale> Luke: or write to it when full
14:01:33 <roconnor> xplat: gotta go.
14:01:45 <xplat> ah, thanks for the explanation
14:01:59 <Luke> Cale: "take" the MVar?
14:02:02 <Cale> yes
14:02:03 <elliott> Luke: yes, i was
14:02:07 <Cale> takeMVar
14:02:07 <mekeor> i got it. the type signature explains everything.
14:02:17 <exFalso> danharaj: well those two types are not the same as you quantified them in different places
14:02:19 <Cale> :t takeMVar
14:02:20 <lambdabot> Not in scope: `takeMVar'
14:02:33 <Cale> :t Control.Concurrent.MVar.takeMVar
14:02:34 <lambdabot> forall a. GHC.MVar.MVar a -> IO a
14:02:41 <Luke> Cale: thanks
14:02:56 <Cale> It's not quite the same as waiting on all the children
14:02:59 <elliott> mekeor: it's (.) in the category Kleisli m :p
14:03:06 <exFalso> danharaj: why can't you quantufy a at the same place you quantify the others?
14:03:17 <Cale> It's really just waiting on one of the children to write the MVar which will cause the program to end immediately
14:05:13 <danharaj> exFalso: Because the type of the list returned should depend on the type of the index given.
14:05:22 <exFalso> danharaj: when you do scoped typing in (x :: o a) a will be a new type variable
14:05:39 <danharaj> That binding is superfluous it doesn't change anything.
14:05:43 <danharaj> I left it in the paste on accident.
14:06:23 <danharaj> anyway, the paste doesn't typecheck regardless so let me fix those errors first.
14:06:33 <danharaj> GHC just didn't get around to telling me it doesn't check.
14:10:12 <exFalso> danharaj: isn't that an impredicative type btw?
14:10:24 <danharaj> exFalso: It is indeed, I have ImpredicativeTypes enabled.
14:11:04 <exFalso> i always feel im doing something wrong when i enable impredicativetypes or incoherentinstances :D
14:11:05 <danharaj> The intention is that the function I give that produces output ranges over the values of a GADT o. The a parameter is supposed to determine the type of the output stream.
14:11:07 <rwbarton> can you wrap it in a newtype?
14:12:26 <byorgey> exFalso: if you enable IncoherentInstances you are definitely doing something wrong.
14:12:34 <byorgey> I'm not sure ImpredicativeTypes is that bad though.
14:13:04 <rwbarton> ImpredicativeTypes is more like, the compiler might randomly reject your program and you need to be cool with that.
14:13:06 <exFalso> byorgey: ive heard it causes a bit of headache to the compiler writers
14:13:16 <byorgey> right.
14:13:41 <byorgey> but if your program DOES compile it will behave sensibly.
14:13:45 <byorgey> unlike with IncoherentInstances.
14:13:51 <rajesh> hi community
14:14:10 <mauke> hi, Guest74635
14:14:18 <monochrom> I think it's just that it's very hard to fit in impredicative types
14:15:54 <rwbarton> anyways I recommend you wrap forall a. o a -> [a] into a newtype (newtype Trans f g = Trans (forall a. f a -> g a), it might make the problem go away, or the process of trying to do that might clarify what the real issue is
14:16:44 <rwbarton> I can't really make head or tail of your code because arrows.
14:17:09 <danharaj> yeah sorry. :3
14:20:15 <hpaste> zhulikas pasted “ScopedTypeVariables” at http://hpaste.org/66029
14:21:11 <Guest12289> exit
14:22:15 <zhulikas> any ideas?
14:23:01 <exFalso> zhulikas: whats approot?
14:23:10 <zhulikas> approot :: Approot a
14:23:42 <exFalso> so why are you saying (approot :: a)?
14:23:58 <zhulikas> what should I say?
14:24:14 <danharaj> can you even use a case statement with GADT's and have the branch type vary based on the case examined?
14:24:15 <exFalso> well it can't have both types:)
14:24:52 <exFalso> danharaj: i think so
14:25:03 <rwbarton> just like with a normal case
14:25:45 <danharaj> oh I see what the issue is.
14:26:57 <zhulikas> damn, wait.
14:27:03 <zhulikas> I made a mistake here
14:27:15 <zhulikas> I need to test it in other parts before complaining
14:27:15 <zhulikas> :D
14:28:16 <zhulikas> it should be (approot :: Approot a)
14:28:20 <zhulikas> building...
14:28:57 <elliott> <danharaj> can you even use a case statement with GADT's and have the branch type vary based on the case examined?
14:29:01 <elliott> danharaj: that's the point of GADTs
14:29:06 <elliott> or you couldn't write eval :: Exp a -> a
14:29:22 <danharaj> elliott: I wasn't sure if toplevel pattern matches were exactly the same as casing.
14:29:25 <elliott> (think data Exp a where { Const :: a -> Exp a; Add :: Exp Integer -> Exp Integer -> Exp Integer; Pair :: Exp a -> Exp b -> Exp (a,b) } etc.)
14:29:27 <elliott> danharaj: oh, ah
14:32:03 <dzhus> what is the best way to parse such format in Haskell: http://hpaste.org/66032 (a language with simple definitions and substitutions; a believe it has indexed grammar)?
14:33:01 <dzhus> I think of doing this with adding some state which will contain «lookup table» for defined symbols to attoparsec parser
14:36:20 <exFalso> dzhus: yes you might want to build up the symbol table while parsing
14:44:36 <danharaj> Managed to get everything type checked. Wrapping the types worked, but I have to annotate every producer.
14:44:45 <danharaj> Now I just have to deal with some catastrophic time leaks :3
14:46:33 <c_wraith> time leaks?
14:46:33 <lexande> what is the eilenberg-moore category of IO?
14:46:46 <c_wraith> Do you have a license for messing with time?
14:46:54 <danharaj> c_wraith: I have only done this once before.
14:47:10 <c_wraith> so you're saying my safety is not guaranteed?
14:47:26 <danharaj> GHC might panic.
14:48:00 <DrDiagoras> is there any sane way to call something of type "State a b" inside "StateT a IO b" monad?
14:48:11 <c_wraith> DrDiagoras: only with runState
14:48:31 <DanBurton> seems like there should be
14:48:38 <c_wraith> DrDiagoras: however, if it's written in terms of MonadState, then it's polymorphic across either case
14:48:47 <c_wraith> DrDiagoras: which is the preferred approach
14:48:50 <DrDiagoras> :-( that's terribly sad! very ugly code for obvious behavior
14:48:58 <ski> you could easily define `Monad m => State s a -> StateT s m a'
14:49:14 <elliott> c_wraith: I'm not sure that's necessarily preferred.
14:49:15 <DanBurton> @type runState
14:49:16 <lambdabot> forall s a. State s a -> s -> (a, s)
14:49:26 <elliott> Note that you can do
14:49:27 <c_wraith> :t modify
14:49:28 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
14:49:28 <elliott> @type state . runState
14:49:29 <lambdabot> forall s a. State s a -> State s a
14:49:31 <elliott> Uh.
14:49:37 <elliott> Sigh.
14:49:39 <elliott> edwardk was right.
14:49:44 <elliott> We need state in MonadState.
14:49:45 <DanBurton> @type StateT . fmap return . runState
14:49:45 <lambdabot> forall s (m :: * -> *) a. (Monad m) => State s a -> StateT s m a
14:49:51 <ski> @type StateT . return .: runState
14:49:52 <lambdabot> forall s (m :: * -> *) a. (Monad m) => State s a -> StateT s m a
14:50:40 <DanBurton> fortunately if you have a State s a, runState does not lose any information by transforming it into its function representation
14:50:40 <DrDiagoras> impressive! I need to meditate on this...
14:51:03 <DanBurton> @type stateT
14:51:04 <lambdabot> Not in scope: `stateT'
14:51:14 <DanBurton> @let stateT = StateT . fmap return
14:51:15 <lambdabot>  Defined.
14:51:19 <DanBurton> @type stateT
14:51:20 <lambdabot> forall s a (m :: * -> *). (Monad m) => (s -> (a, s)) -> StateT s m a
14:51:49 <edwardk> elliott: well, we're getting it ;)
14:52:03 <DanBurton> Is there something like stateT in the standard libs?
14:52:15 <elliott> state, once edwardk gets his way
14:52:51 <DanBurton> @type StateT
14:52:52 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
14:52:56 <edwardk> elliott: ross finally added it to transformers, so its pretty much on me now. I asked him to make a couple of other changes, but I think they may have stalled, so I need to decide if I'm willing to take what he gav me as good enough and just build on top
14:53:19 <edwardk> it just affects operations like modify that could avoid a round trip through the monad
14:53:33 <edwardk> and i'd rather have the modify operation from transformers agree with the one from mtl
14:53:41 <elliott> right
14:54:06 <edwardk> danburton: there is a more general notion available than stateT
14:55:04 <edwardk> you can view that as a special case of a class MonadHoist t where hoist :: (Monad m, Monad n) => (forall a. m a -> n a) -> t m a -> t n a
14:55:21 * hackagebot categorical-algebra 0.0.0.1 - Categorical Monoids and Semirings  http://hackage.haskell.org/package/categorical-algebra-0.0.0.1 (JonathanFischoff)
14:55:29 <edwardk> but that isn't haskell 98, that said, there does exist a canonical monad homomorphism from the identity monad into every monad over Hask, so we can make
14:55:30 * ski calls that `tmap'
14:55:51 <edwardk> class MonadHoist t where hoist :: Monad m => t Identity a -> t m a
14:56:06 <edwardk> and that doesn't require that you passed an actual monad homomorphism in
14:56:46 <edwardk> then in the state monad case that is hoist :: Monad m => State s a -> StateT s m a
14:57:14 <edwardk> and that notion _is_ haskell 98 ;)
14:57:26 <DrDiagoras> lol, looks like I asked of pretty bleeding edge subject :-) thank you for the solution - looking forward to see it in standard libs
14:57:48 * elliott . o O ( class Transform m n where { trans :: m a -> n a }; class MonadHoist t where { hoist :: (Monad m, Monad n, Transform m n) => t m a -> t n a })
14:57:52 <elliott> *} )
14:58:14 <edwardk> DrDiagoras: sorry i tuned in near the end, didn't realize there was an actual question being answered =)
14:58:21 <elliott> instance (Monad m) => Transform Identity m where { trans = return . runIdentity } etc.
14:58:58 <edwardk> the problem with Transform is it doesn't tell you what it is a homomorphism of
14:59:09 <elliott> yeah
14:59:10 <edwardk> we need an actual monad homomorphism there, not just a natural transformation
14:59:34 <DrDiagoras> no problem :-) I got the idea about MonadHoist and I find it really usefull. even if for my case stateT would be enough ;-)
14:59:45 <edwardk> then hoist is telling you that it turns a monad homomorphism from m ~> n into one from t m ~> t n
15:00:06 <edwardk> DrDiagoras: I do have the comonadic equivalent in comonad-transformers ;)
15:00:22 <edwardk> http://hackage.haskell.org/packages/archive/comonad-transformers/2.0.3/doc/html/Control-Comonad-Hoist-Class.html
15:01:41 <DrDiagoras> thanks, but I'm trying not to use things I do not understand. comonads for sure are in this class yet ;-)
15:02:41 <edwardk> DrDiagoras: fair nuff =)
15:06:15 <ozgura> Hi all! I am using a 'StateT Int [] Int', and want the state to be local to each branch (of the list). How can I achieve that?
15:06:43 <ozgura> let's make it 'StateT s [] a'
15:06:49 <c_wraith> @unmtl StateT Int [] Int
15:06:50 <lambdabot> Int -> [(Int, Int)]
15:07:04 <c_wraith> @unmtl ListT Int State Int
15:07:04 <lambdabot> Int [State] Int
15:07:14 * ski . o O ( "damn c_wraith and his fast fingers" )
15:07:20 <magicman> @unmtl ListT (State Int) Int
15:07:20 <lambdabot> Int -> ([Int], Int)
15:07:57 <ozgura> magicman: that one has to maintain a single state
15:08:11 <ski> ozgura : i think `StateT Int [] Int' should work fine
15:08:16 <ozgura> but to my surprise 'StateT s [] a' maintains one global state.
15:08:30 <ski> @unmtl StatT s [] a
15:08:30 <lambdabot> StatT s [] a
15:08:33 <ski> @unmtl StateT s [] a
15:08:34 <lambdabot> s -> [(a, s)]
15:08:37 <elliott> no it doe- yeah
15:08:38 <ski> ozgura : it doesn't
15:08:39 <elliott> -sn't.
15:08:44 <c_wraith> ozgura: that's not what the type says..
15:09:04 <c_wraith> the type says that each list element gets its own state
15:09:12 <danharaj> ...
15:09:13 <ski> ozgura : each branch has it own state. state is copied on branching, never to join again
15:09:13 <danharaj> GOD DAMN
15:09:28 <yitz> StateT [] is the classic backtracking monad
15:09:31 <danharaj> Isn't it fun chasing bugs around because you forgot there's two applicative list instances?
15:09:35 <ozgura> ski: OK I need to test a bit more.
15:10:07 <ozgura> I always assumed it to be that way, but was surprised to see different behaviour in my code now.
15:10:12 <ozgura> will look closer.
15:12:55 <danharaj> oh god I love when it's my complete stupidity that causes all my bugs.
15:13:05 <danharaj> All I have to do is remove me from the program and it works.
15:13:47 <elliott> @remember danharaj All I have to do is remove me from the program and it works.
15:13:47 <lambdabot> I will never forget.
15:15:03 <danharaj> I'm still puzzled why I had to wrap those function types with newtype in order to satisfy GHC.
15:15:14 <danharaj> I guess I don't understand ImpredicativeTypes that well.
15:15:17 <danharaj> (At all.)
15:15:44 <c_wraith> impredicative instantiation in GHC requires being exceptionally verbose in type annotations
15:16:59 <c_wraith> including ones you may not think about - functions you're applying to polymorphic values
15:17:06 <danharaj> c_wraith: I'm wondering why newtype wrapping reduced it from impredicative types to rank2types.
15:17:19 <c_wraith> danharaj: because the polymorphism is wrapped inside the newtype
15:17:38 <c_wraith> danharaj: so you need rank2types for the polymorphism inside the newtype
15:18:04 <c_wraith> danharaj: but the types passing the wrapper around see it as monomorphic, so don't need impredicative instantiation
15:18:13 <danharaj> ah.
15:19:44 <danharaj> One other thing that bothers me slightly is that I need to explicitly type a function over a GADT so GHC doesn't try to make the type too monomorphic.
15:21:02 <DrDiagoras> ok, another problem... now I need to do same thing with Rand and RandT monads from Control.Monad.Random - they do not have public data constructor like StateT
15:22:15 <c_wraith> > let m = modify (+1) >> lift [(), ()] in runStateT (replicateM 2 m) 0 -- ozgura: note that the number of results is not the same as the returned number. seems like pretty solid evidence the state is independent between branches
15:22:16 <lambdabot>   [([(),()],2),([(),()],2),([(),()],2),([(),()],2)]
15:23:40 <elliott> do we need "evidence"? the type proves it
15:24:16 <ozgura> elliott: I am convinced, and do not need evidence.
15:24:24 <ozgura> but I am still having trouble using it
15:24:47 <c_wraith> elliott: proofs sometimes lack the visceral feeling of actually *seeing* it.
15:25:23 <elliott> c_wraith: fair enough.
15:25:24 <ozgura> say i want to generate 2 results, and somehow inject different states to each
15:25:55 <c_wraith> ozgura: ah.  If you want to do that as a single step - yeah, that's ugly
15:26:02 <ozgura> c_wraith: in your example, I want the first () branch to have modify (+2) and the second modify (+1)
15:26:13 <ozgura> I am a bit puzzled now, so I may not make complete sense
15:27:21 <ozgura> let me rephrase: write a similar one-liner whose output doesn't have identical state values
15:27:33 <zhulikas> @hoogle Text -> String
15:27:33 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
15:27:34 <lambdabot> Data.Text.Internal showText :: Text -> String
15:27:34 <lambdabot> Data.Text.Lazy unpack :: Text -> String
15:28:02 <Luke> I can't seem to use getNumCapabilities from Control.Concurrent
15:28:08 <Luke> is there somethign special I need to do?
15:28:20 <nart> i would like to create my own monad capable of keeping state and that posses few methods but i don't know where to start, probably i'm unable to find good stuff on google this evening =(
15:28:42 <ski> DrDiagoras : yeah we'd need something like `randT . (return .) . runRand'
15:28:43 <c_wraith> ozgura: Yeah, I know what you mean. It's a bit tricky, because the output state is implicit
15:28:44 <Cale> haskell-prime has been really high-traffic lately
15:29:45 <Cale> This String != [Char] thing .oO(haha, why not /=) is getting so many posts.
15:29:50 <ozgura> c_wraith: OK. At least I am not missing something extremely trivial. Not this time :)
15:30:26 <Enigmagic> Luke: what version of GHC are you using?
15:31:35 <ski> > (`runStateT` 0) $ do b <- lift [True,False]; modify (+ if b then 2 else 1)  -- ozgura, like this ?
15:31:36 <lambdabot>   [((),2),((),1)]
15:31:53 <Luke> i guess it's been renamed to numCapabilities now
15:31:55 <ozgura> ski: wowz
15:32:13 <ozgura> hmmm, I see
15:32:31 <ski> in one branch `b' is `True', in the other it's `False'
15:32:34 <ozgura> thanks!
15:32:39 <Enigmagic> Luke: getNumCapabilities was defined later ... maybe in 7.2 or 7.4
15:32:47 <Enigmagic> since the number can change now
15:32:55 <ski> > (`runStateT` 0) $ do b <- lift [2,1]; modify (+ n)  -- is simpler, of course
15:32:56 <lambdabot>   [((),0 + n),((),0 + n)]
15:33:05 <ski> > (`runStateT` 0) $ do n <- lift [2,1]; modify (+ n)
15:33:06 <lambdabot>   [((),2),((),1)]
15:33:57 <ozgura> let me remember how this karma thing worked :)
15:34:01 <ozgura> ski++ is it?
15:34:03 <ozgura> ski++
15:34:10 <ozgura> ski+
15:34:13 <ski> maybe
15:34:15 <ski> @karma
15:34:15 <lambdabot> You have a karma of 3
15:34:27 <shachaf> preflex: karma ski
15:34:27 <preflex>  ski: 31
15:34:33 <ski> you can also say `@karma+ whoever'
15:34:41 <ski> @list karma
15:34:41 <lambdabot> karma provides: karma karma+ karma- karma-all
15:34:49 <ozgura> @karma+ ski
15:34:49 <lambdabot> ski's karma raised to 4.
15:36:09 <adnauseam> @karma
15:36:09 <lambdabot> You have a karma of 0
15:36:10 <adnauseam> :o
15:36:12 <adnauseam> :[
15:36:25 <nyingen> @karma-all
15:36:25 <lambdabot>  "("                    68
15:36:26 <lambdabot>  "C/C"                  67
15:36:26 <lambdabot>  "g"                    30
15:36:26 <lambdabot>  "dmwit"                20
15:36:26 <lambdabot>  "Notepad"              16
15:36:27 <lambdabot> [654 @more lines]
15:36:51 <nyingen> who would have guessed that the left paren would have the most karma of all
15:37:15 <adnauseam> :o
15:37:38 <hpaste> Clint pasted “failure to deduce” at http://hpaste.org/66036
15:37:42 <Clint> what am i doing wrong there?
15:38:03 <Enigmagic> C/C++
15:38:13 <nyingen> heh
15:38:24 * ski thought dons had more than a hundred points ..
15:38:51 <olsner> @karma dons
15:38:52 <lambdabot> dons has a karma of 1
15:39:00 <olsner> maybe it wrapped?
15:42:38 <Aune> @karma dons
15:42:38 <lambdabot> dons has a karma of 0
15:44:57 <Cale> weird
15:45:18 <Cale> I don't really keep track of the karma file very carefully
15:45:24 <Cale> preflex: seen dons
15:45:25 <preflex>  dons was last seen on #haskell 71 days, 4 hours, 31 minutes and 25 seconds ago, saying: btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
15:45:56 <aristid> well, that record has been beaten
15:46:14 <mauke> preflex: karma dons
15:46:14 <preflex>  dons: 40
15:50:43 <kaitocracy> anyone know the best way to perform regex on a Text?
16:01:24 <nyingen> @quote
16:01:24 <lambdabot> shillelagh says: <ivanm> so shillelagh == no significance? <shillelagh> yep!
16:02:50 <misterbeebee> I'm profiling a program, compiling with "-prof -auto-all"  and running with "+RTS -pa -RTS", and I have some explicit SCC tags (cost centres).
16:02:55 <misterbeebee> The result is that the bulk of my program is spent in "Data.Rope.uncons" from cabal-installed package "rope".
16:02:56 <misterbeebee> Is there a simple way to get more  detailed profiling of the innards of Data.Rope?
16:08:53 <Enigmagic> misterbeebee: you can rebuild that library with -auto-all and -caf-all
16:10:03 <misterbeebee> I can give those flags to cabal-install?
16:10:09 <misterbeebee> oh, just like "-p", I guess that makes sense.
16:13:15 <dgpratt>     where ys = (xs `zip` [0..])
16:13:37 <ski> no need for brackets there
16:13:57 <misterbeebee> ah, "cabal install -p --auto-all rope" didn't work, and I don't see profiling options or ways to set ghc options in the "cabal --help" output.  Do I need to edit the .cabal file itself (that seems weird, since cabal downloads it)
16:15:55 <misterbeebee> ah, --ghc-options. hidden under "--PROG-options"
16:16:17 <Enigmagic> misterbeebee: i either edit the .cabal file or use --ghc-options
16:16:28 <misterbeebee> thanks!
16:17:34 <misterbeebee> (sadly, I think the result of my analysis is going be "yup, Data.Rope.ucnons is a slow way to navigate the data. Try rewriting the program with a different data structure :-("
16:18:05 <Enigmagic> that's my suspicion
16:21:59 <misterbeebee> sweet, that worked. Data.Rope.Internal.splitAt is taking up half the program time. Looking at the code, it seems way more expensive than, say, "head".
16:22:30 <hpaste> aib pasted “arbitrary precision” at http://hpaste.org/66037
16:23:03 <misterbeebee> Anyone have  recommendations for a faster data structure / library for  iterating over and also cut-and-paste-and-splice sections from multi-MB text?
16:23:42 <misterbeebee> In the C++ world, STL Rope is a good choice, I think.
16:24:04 <parcs`> Lemmih: no, SDL_WaitEvent blocks without -threaded regardless of safe vs unsafe
16:25:06 <Enigmagic> misterbeebee: iterating over characters or words (or some other length..) ?
16:25:38 <misterbeebee> iterating over characters, but then cutting and pasting 1-100K at a time.
16:25:52 <aib> I have a function, http://hpaste.org/66037 which fails to seem with large input integers (wrapping around to -) when run with ghc or ghci, but ghci never fails from the interactive prompt (e.g. 3 billion * 3 gives 9 billion) - why?
16:26:02 <aib> seems to fail* :D
16:26:18 <Enigmagic> misterbeebee: how fast does it need to be?
16:27:34 <misterbeebee> I think I need about million copy-paste operations in a few minutes.
16:27:42 <misterbeebee> (checking my math now)
16:28:04 <Enigmagic> can you paste the code up somewhere?
16:28:14 <misterbeebee> (but that feels too demanding ask for)
16:28:25 <misterbeebee> sure, one moment
16:28:40 <elliott> misterbeebee: have you consi... wait, am I the person who made you use ropes in the first place?
16:28:54 <aib> oh boy, is it because of my Int -> Int signature that the arithmetic fails at around 2^31?
16:29:00 <danharaj> aib: yes
16:29:09 <danharaj> aib: use Integer for big numbers.
16:29:18 <aib> *headdesk* thanks
16:31:21 <misterbeebee> Enigmagic: I don't think the code is that useful. The slow part is basically this:  "f data = let Just(headChar,data') = Rope.uncons data,  then process headChar and recursively call   d data'
16:31:40 <misterbeebee> processing the whole few MB of data
16:31:53 <misterbeebee> Then modifying the data with cut-and-paste, and repeating a process
16:32:16 <misterbeebee> elliot: I don't know if you are? did you tell me? or write a popular blog post about it?
16:33:17 <Enigmagic> misterbeebee: how much worse was String?
16:34:42 <misterbeebee> I didn't bother to try String, because I think it's insane to try code like  "data 2 = (take 50000 data) ++ (take 100 . drop 100000  $ data)"
16:35:05 <misterbeebee> I guess this a good opportunity for me to practice good API design, and then implement a few different backends for data manipulation
16:35:20 <Enigmagic> uncons wouldn't be as slow ;)
16:35:34 <misterbeebee> yes :-)
16:37:00 <Enigmagic> if it's possible you could try enumerating over each char in the rope rather than calling uncons repeatedly
16:37:13 <misterbeebee> (If were writing my own implementation of rope-like thing for this with my limited skills, I'd probably try something like a List of ByteStrings.)
16:38:23 <misterbeebee> enumerating how? uncons is the only way I see to enumerate the chars on the rope: http://hackage.haskell.org/package/rope
16:38:30 <Enigmagic> like using Rope.foldl'
16:38:59 <misterbeebee> (BTW, I chose that package because I believe in the Edward Kmett brand, but I don't know if that is the best Rope library)
16:39:17 <edwardk>  uhoh
16:39:21 <misterbeebee> hi!
16:39:33 <edwardk> rope may not be a good investment ;
16:39:35 <misterbeebee> Rope.foldl' is in a different ropes package, http://hackage.haskell.org/packages/archive/data-rope
16:39:54 <Enigmagic> doh
16:39:58 <copumpkin> zomg
16:40:51 <misterbeebee> How many ropes library authors are active on this channel right now? :-)
16:41:03 <edwardk> what i mean is that my 'rope' package is pretty old and hasn't been updated
16:41:17 <edwardk> i have 3 of them, do i get to count myself 3 times?
16:41:21 <misterbeebee> heh
16:41:46 <misterbeebee> then maybe you are in a position to recommend a ropes library, or substitute string-like manipluation library?
16:41:48 <ben> What's the difference between a rope and a lazy bytestring again?
16:41:50 <edwardk> the main focus of 'rope' was on working with annotated ropes
16:42:00 <ben> i was confused about this before
16:42:06 <edwardk> ben: the versions i use are fingertrees of bytestrings rather than a lazy list of bytestrings
16:42:39 <ben> huh
16:42:40 <ben> ok
16:42:40 <edwardk> that means that append is O(log (min(n/C,m/C))) for example instead of linear
16:43:04 <edwardk> and that member access is O(log n)
16:43:30 <edwardk> in exchange, the way they are constructed precludes infinite ropes
16:43:34 * ski . o O ( `C' ? )
16:43:40 <edwardk> ski: the chunk size
16:44:04 <ski> is the chunk size fixed in the implementation ?
16:44:07 <edwardk> kept in there because it goes constant below that
16:44:16 <edwardk> depends on the version of the library
16:44:34 <edwardk> when i was using bytestrings to encode it, at one point i'd store whether or not there were utf-8 tail bytes in the chunks
16:44:34 <hpaste> “Joey Adams” pasted “padRight function” at http://hpaste.org/66038
16:44:49 <JoeyA> I'm tired of writing this function over and over.  Is there a Hackage module out there with it?
16:44:52 <edwardk> if there weren't, then the chunk could be any size, otherwise i bounded the size to something small, like 100 bytes
16:44:56 <JoeyA> Or should I upload one?
16:45:24 <edwardk> that way i could do the linear scan in amortizedly constant memory when i needed to split the chunk at a given character position, despite the flat rep
16:45:42 <edwardk> er constant time
16:46:19 <edwardk> and you want to accrete particularly small bytestring fragments on either end as well
16:46:36 <edwardk> there is something like 50 bytes of overhead to every one of them, so it makes sense to smash together small bytestrings!
16:46:50 <edwardk> even with reduced sharing you probably net a win
16:46:58 <edwardk> so there is a lower bound as well
16:47:06 <misterbeebee> Of 4 packages named "*rope*" that are not "*propert*", rope is the newest. http://packdeps.haskellers.com/feed?needle=rope
16:47:23 <misterbeebee> I guess I could try simple-rope, which takes a swipe at rope in its description: http://hackage.haskell.org/package/simple-rope
16:47:52 <misterbeebee> (oh.. rope 0.6.1.1 was 2011, but 0.6.1 was early 2010)
16:48:25 <edwardk> misterbeebee: well, rope was me experimenting with the notion of an 'annotated rope', where instead of doing what i did above, and storing trapped in the leaf the metainformation about the contents of the rope, what i did instead was pulled that out into a separate 'annotation', which is tied to the contents of the particular rope via a phantom type
16:48:59 <edwardk> then i could make an annotation that tracked, say, utf-8 tail bytes, and not have to tie the structure of the fingertree, to the dispersion of utf-8 tail bytes in the bytestrings
16:49:42 <misterbeebee> That sounds interesting, if muchly over my head :-)
16:49:45 <edwardk> and work with a comonad that let me throw away or generate other annotations as i saw fit, even updating them when i changed the content
16:50:43 <edwardk> at the time i was interested in building a graph api that behaved similarly, but the comonad was basically a reader comonad, and by the time you shuffle things around enough in a low mutation setting like that, you can get an equivalent monadic api, which is better for things like offline graphs anyways
16:50:56 <edwardk> so the graphs package on hackage was a direct offshoot of my thinking on ropes
16:52:05 <edwardk> misterbeebee: basically instead of having a fingertree of (Bytestring, annotation), rope uses (fingertree ByteString, annotation)
16:52:16 <edwardk> with some phantom types relating the two
16:53:11 <edwardk> the phantom type let me do things like:
16:53:14 <edwardk> break :: (BreakableAnn f, Breakable t) => (t -> Bool) -> Ann f a -> (forall n. Ann f (Take n a) -> Ann f (Drop n a) -> r) -> r
16:54:06 <edwardk> which would take a predicate and an annotated rope where the annotation knew how to split at a location, and generate a new pair of annotated ropes with new (related) phantom types and pass them to the continuation
16:54:50 <edwardk> and nicely, we can make it so that the concatenation of a rope annotated with Take n a and a rope annotated with Drop n a yields a rope annotated with a.
16:55:44 <edwardk> so if you compute the same operation on the same rope in different places then you could move annotations around using the strength of the functor)
16:56:02 <edwardk> and i just realized he left the channel in the middle of that
16:57:05 <c_wraith> wall of type application
16:57:06 <edwardk> @tell misterbeebee check http://tunes.org/~nef/logs/haskell/12.03.26 for the longer explanation i finished after you left ;)
16:57:06 <lambdabot> Consider it noted.
16:59:46 <parcs`> wall of ropes
17:00:56 <lispy> hello
17:01:19 <copumpkin> omg it's a lispy
17:01:57 * lispy is now known as OMG|lispy
17:02:38 <lispy> copumpkin: I looked at your agda routing code
17:02:46 <copumpkin> oh no
17:02:48 <lispy> copumpkin: Is an agda based IRC bot next?
17:03:14 <copumpkin> hah, perhaps :) I'm mostly thinking of programmy things that dependent types can actually help with
17:03:38 <shachaf> larrytheliquid showed me his Agda IRC bot.
17:03:51 <lispy> shachaf: cool
17:03:56 <lispy> shachaf: is it on his github page?
17:04:16 <lispy> copumpkin: You could code up darcs patch theory in Agda
17:04:26 <lispy> copumpkin: Igloo started doing that in Coq
17:04:27 <shachaf> lispy: Looks like it is.
17:04:35 <copumpkin> lispy: hah, sounds terrifying :)
17:04:40 <shachaf> It's kind of cheating, though.
17:04:42 <copumpkin> maybe someday :)
17:04:43 * lispy makes a note to look at it later
17:05:21 <lispy> Maybe someday when I get some time I'd like to attempt expressing darcs's commute operation in rewriting
17:05:35 <lispy> I think term rewriting is a natural fit for describing patch logic
17:06:00 <lispy> And not in the, possibly, obvious way. Instead of rewriting files you're rewriting history.
17:06:23 <lispy> That is, commute rewrites patches.
17:07:14 <lispy> And i think tihs way of looking at it could lead to algorithim optimizations or improved ways to prove things about algorithmic complexities
17:07:56 <edwardk> Whee. wxHaskell has some pretty big modules
17:08:24 <lispy> edwardk: are they autogenerated?[5~
17:08:31 <edwardk> i hope so!
17:08:38 <dylukes> edwardk: what about http://hackage.haskell.org/package/X11-1.5.0.1
17:08:40 <dylukes> ;P
17:09:06 <lispy> Better tools for autogenerating bindings would be good.
17:09:11 <lispy> I wonder if that would be a good gsoc project
17:09:23 <lispy> Take something like greencard and get it working again
17:09:46 <lispy> (I don't really know the state of greencard though)
17:10:48 <bill```> what is the hackage search command for lambdabot?
17:11:11 <lispy> ?hackage foo
17:11:11 <lambdabot> http://hackage.haskell.org/package/foo
17:11:15 <bill```> thanks :)
17:11:20 <lispy> bill```: but that's not a search
17:11:28 <lispy> ?hackage this is what I mean[5~
17:11:28 <lambdabot> http://hackage.haskell.org/package/this is what I mean[5~
17:11:34 <edwardk> i'd rather just start over with something like libclang, get it to parse c/c++ for you and generate ffi wrappers for classes/structs through that
17:11:45 <bill```> lispy: i see, thanks again :]
17:12:18 <lispy> edwardk: can libclang parse gcc?
17:12:27 <lispy> edwardk: one of the things I would like to autogenerate is a binding to gcc :)
17:12:33 <lispy> for authoring plugins
17:12:42 <dylukes> lispy: why not have libclang parse clang ^^?
17:12:46 <edwardk> lispy: i think so actually
17:12:55 <Enigmagic> i'm pretty sure i've seen gcc compile benchmarks using clang
17:12:58 <Enigmagic> so i'd say yes
17:13:11 <edwardk> lispy: i know for sure it can parse the linux and bsd kernels
17:13:13 <lispy> I've been meaning to do a short blog post showing people how to use ghc to build gcc plugins. The hard part is that you have to write so much ffi code to use anything in gcc.
17:13:33 <edwardk> (and even compile them)
17:14:03 <lispy> Although, I guess good Haskell support for gcc would be typeful.
17:14:09 <edwardk> lispy: anyways thats the ffi path i always wanted to take
17:14:21 <lispy> So you would still need a layer on top of the autogenerated FFI
17:14:34 <edwardk> sure
17:15:15 <lispy> Actually, working in gcc gives me an urge to write hcc, the Haskell C Compiler
17:15:42 <edwardk> hacc
17:15:55 <lispy> Getting all the low level details right would take forever, but I think you could get a much higher quality result.
17:16:29 <lispy> And you could still let gnu as and gnu ld do what they do best
17:16:44 <lispy> (that is, until you rewrite them in Haskell :)
17:17:09 <shachaf> Put them all together, they spell... HCKCPW / Which is just about what [GCC] means to me!
17:18:17 <jfischoff> hey edwardk, why isn't Data.Groupoid a Category?
17:19:06 <edwardk> jfischoff: because the groupoids i was interested in couldn't be expressed properly in haskell as Category instances. in particular sum and product semigroupoids
17:19:23 <nart> what's your thought about this piece of code ? http://hpaste.org/66039
17:19:38 <edwardk> can't be made into sum and product categories without product kinds ,which we got recently, but we gained no syntax for talking about polymorphic arguments to them
17:20:11 <edwardk> i'm currently waiting for a syntax to talk about polymorphic kinds to fix up a lot of stuff
17:21:06 <lispy> nart: I use 2 spaces for indentation, but what you've done looks good
17:21:37 <lispy> nart: on line 7, I would have started a new line with { on line 8
17:21:49 <jfischoff> sort of understand. Not clear on what a product and sum category is. But I feel better about writing my own groupoid class for *plug* http://takeittothelimit.wordpress.com/2012/03/26/categorical-semirings-2/
17:21:49 <lispy> nart: like you did with Client
17:22:16 <lispy> nart: I would be tempted to newtype Server and use generalized deriving for the instacnes you want to keep
17:22:31 <lispy> nart: I would also be tempted to newtype your Callback alias
17:23:04 <nart> what's bother me most, is the Data type, is it ok to use it that way ?
17:23:09 <lispy> nart: I think the "return ()" at the end of broadcast is redundant
17:23:26 <monochrom> copumpkin will rewrite Windows in Agda :)
17:23:32 <copumpkin> lol
17:23:35 <copumpkin> no thanks
17:23:42 <edwardk> a product category for two categories is a category where the objects are the choice of one object from each, the sum category of two categories is a category where the objects are the disjointed union of the objects from each, in the product case arrows are pairs of arrows, and in the sum case arrows are either an arrow from one category or an arrow from the other
17:23:44 <monochrom> the writing is on the wall!
17:24:12 <nart> lispy: thanks for the tips =)
17:24:20 * copumpkin tries to avoid writing on the wall
17:24:23 <copumpkin> it's a pain to clean up
17:24:57 <edwardk> instance (Category x, Category y) => Category (Prod x y) where id :: Prod x y (b,b') (c,c') -> Prod x y (a,a') (b,b') -> Prod x y (a,a') (c,c') -- works fine
17:25:03 <edwardk> so you can make the Semigroupoid
17:25:11 <edwardk> er sorry where (.) ::
17:25:20 <lispy> nart: I'm not sure how to comment on Data. I mean, it's perfectly fine haskell, but I guess it all depends on what you are trying to accomplish with it.
17:25:35 <edwardk> but the definition for 'id' is broken because the kind of the argument forces you to be able to make values of type
17:25:56 <edwardk> Prod x y a a for any choice of a, just things of the form Prod x y (a,b) (a,b)
17:26:40 <lispy> nart: does Data force the caller to have to deal with values that have no meaning for them?
17:26:47 <edwardk> hence why product categories cannot be made instances of Category in Hask. They are a category, but if the index for both of the categories was kind *, then the product category would be indexed by (*,*)
17:27:36 <edwardk> @hpaste
17:27:36 <lambdabot> Haskell pastebin: http://hpaste.org/
17:27:36 <lispy> nart: and a typeclass wouldn't really be the same because right now you could have a list that contains handles and strings.
17:27:57 <lispy> nart: and I don't really know if that's good or bad in your program
17:28:11 <hpaste> “why we can't have nice product categories” pasted “edwardk” at http://hpaste.org/66040
17:28:19 <lispy> heh, nice title
17:28:31 <lispy> "This is why we can't have nice things at the type level..."
17:29:01 <edwardk> lispy: =)
17:29:10 <jfischoff> haha
17:29:57 <edwardk> jfischoff: anyways, product groupoids and coproduct groupoids can be have, i just can't provide id for them til that issue gets resolved
17:29:58 <nart> lispy: mmm i think that for my program, it should be fine,  but it feels inelegant :S
17:29:58 <jfischoff> lispy: I heard Malory Archer when I read that
17:30:06 <BMeph> edwardk: So, what of Omega - overkill, or what? :)
17:30:07 <edwardk> ergo, no Category superclass ;)
17:30:14 <edwardk> BMeph: what of it?
17:30:25 <Beticious> Play the free game of sports bet, you can win a PS3 or 50$ paypal tickets for free http://www.beticious.com/es/register?ref=Trece30
17:30:27 * hackagebot Unixutils 1.50 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.50 (DavidFox)
17:30:52 <jfischoff> edwardk: I reading your stuff, thanks.
17:31:18 <lispy> Beticious: is it written in the Haskells?
17:31:23 <edwardk> for the most part we've stolen all the interesting bits =P
17:31:26 <lispy> We write things in the Haskells.
17:31:28 <BMeph> edwardk: For support of type-level hackery^W support of things like indexed and restricted class things?
17:31:38 <lispy> I can has types!
17:31:46 <c_wraith> edwardk: there's no theoretical reason that can't work, is there? It's just a matter of enhancing the relevant extensions until it works?
17:31:52 <edwardk> well, we'll get there (at least one more level)
17:31:55 <edwardk> c_wraith: correct
17:32:36 <edwardk> c_wraith: it works in the language we have here at clarifi. and thats just a quick back of the napkin extension to our type system to add polymorphic kinds
17:33:02 <edwardk> c_wraith: SPJ wants it, just needs to get someone to implement it
17:33:07 <edwardk> so i'm waiting
17:33:16 <c_wraith> You're not implementing it? :P
17:33:17 <lispy> edwardk: Is that an in-house language?
17:33:19 <edwardk> but in the meantime i can't really use the polymorphic kinds much until 7.6.1
17:33:22 <edwardk> lispy: yeah
17:33:47 <Omega> BMeph: ?
17:34:12 <edwardk> i sketched out a typechecker back when i was consulting here, and i went away for a few months, and Runar'd gone and build the damn language by the time i came back
17:34:28 <edwardk> er built
17:34:37 <c_wraith> edwardk: I know byorgey wasn't involved with the polykinds code, but he was involved with the related paper. Have you tried poking him with a pointy stick until the extension is done?
17:34:48 <edwardk> c_wraith: i poked him a few times ;)
17:34:51 <lispy> edwardk: haha, that's awesome
17:34:58 <edwardk> and i tease him about it mercilessly whenever i get the chance
17:35:28 * hackagebot debian 3.64 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.64 (DavidFox)
17:35:57 <edwardk> lispy: anyways, after i came on board we cleaned it up, fixed up the way we do higher rank types, and added layout and some polish and its now pretty nice
17:37:31 <lispy> cool
17:49:49 <Apocalisp> edwardk: It was a good sketch, I just painted by numbers.
17:50:31 <edwardk> Apocalisp: in some ways what you had was a less bug-prone approach than the one we took later
17:51:05 <Apocalisp> it was certainly very simple
17:51:36 <Apocalisp> but once I added rank-n, it all came apart
17:53:05 <Apocalisp> We should strive to open source this language.
17:53:10 <edwardk> i've _almost_ finished patching wxhaskell to work with 7.4.1 on a 64 bit mac
17:53:46 <edwardk> it is a haskell-like on the jvm, and users _do_ shine light on lots of bugs
17:54:05 <dibblego> when will those users be me !?
17:54:09 <edwardk> plus shame is a powerful motivation to get things done right ;)
17:57:58 <deej_> hey guys, I'm on the pattern matching section on LYAH. I'm having trouble getting things to work in ghci. I know how to do a mutli line statement :{ and :} but this pattern never compiles. What am I doing wrong?
17:58:00 <deej_> lucky :: (Integral a) => a -> String   lucky 7 = "LUCKY NUMBER SEVEN!"   lucky x = "Sorry, you're out of luck, pal!"
17:58:07 <deej_> parse error on input `='
17:58:39 <hpaste> deej pasted “p match” at http://hpaste.org/66042
18:02:34 <deej_> any help?
18:02:49 <mauke> you can't do that in ghci
18:04:10 <hpaste> Enigmagic annotated “p match” with “p match (annotation)” at http://hpaste.org/66042#a66043
18:04:21 <Enigmagic> looks like it works with a let
18:23:41 <exFalso> :t (\a -> mkName (show a) == a) 'map
18:23:41 <lambdabot>     lexical error in string/character literal at character 'a'
18:24:09 <exFalso> the above returns false, can anyone tell why?
18:24:35 <exFalso> mkName being a TH function
18:25:33 <Veinor> what does mkName (show 'map) evaluate to?
18:26:04 <exFalso> GHC.Base.map
18:26:41 <exFalso> Name has two fields and both are equal to the reconstructed name's respective fields
18:27:03 <exFalso> so im guessing there is some internal ghc uniqifying magic going on
18:27:18 <exFalso> im just not sure how to get back the original Name...
18:29:06 <bitonic> exFalso: the NameFlavour is different
18:30:14 <exFalso> bitonic: how can i check that?
18:30:56 <bitonic> exFalso: let Name occ1 flav1 = 'map; let Name occ2 flav2 = mkName (show 'map); flav1 == flav2
18:31:07 <bitonic> exFalso: it's probably NameQ and NameG
18:31:53 <exFalso> ah
18:32:11 <exFalso> :(
18:32:24 <exFalso> thanks, i'll figure out something without making everything a string:)
18:32:27 <bitonic> life's harsh.
18:32:58 <bitonic> on the other hand, mkName (show 'map) most certainly refers to the right thing
18:33:25 <bitonic> you could compare with 'show'
18:33:39 <bitonic> I'm not sure how safe is that. And I don't know what you're doing anyways
18:33:51 <exFalso> bitonic: i have it in a Map so i don't have explicit access to equality checking
18:34:09 <exFalso> grr
18:34:56 <bitonic> mh. just store always names produced with mkName then :P
18:34:59 <bitonic> and hope for the best
18:35:29 <exFalso> bitonic: thats neater then what my idea was, thakns
18:36:36 <ssss> d
18:37:19 <bitonic> exFalso: the thing is that when you use ', GHC "knows" what you're referring to, to the specific method - I think. While mkName doesn't check anything
18:37:28 <bitonic> it just parses the String
18:38:42 <deej_> Hey guys, why do most people use [Char] instead of String in their type signatures
18:39:07 <dibblego> deej_: most people do? that's news to me
18:39:16 <deej_> lol :)
18:39:21 <deej_> I read it somewhere...
18:39:32 <deej_> well you answered my question thanks
18:39:34 <exFalso> deej_: they think FlexibleInstances is nices than TypeSynonymInstances:)
18:39:39 <exFalso> *nicer
18:40:40 * bitonic should go to bed
18:41:40 <augur> so i feel that like..
18:41:41 <exFalso> bitonic: nah, the night is young
18:42:07 <exFalso> there is lambda to do
18:42:24 <augur> differentiation can be seen in two different ways -- one as an operation on expressions with variable terms, and another as an operation on functions in denotations
18:42:41 <augur> and that a lot of classical work on differentiation is viewing it in the former way
18:43:21 <exFalso> differentiation is an -operator- acting on functions
18:43:38 <augur> which is why people like sussman gripe about it -- it seems to be full of type errors because hey, f is a function, right? but when viewed as an operation on expressions, it type checks
18:43:56 <bitonic> exFalso: too tired for lambda! night
18:44:19 <augur> exFalso: no but what i mean is, you dont have to view it strictly as such -- if you view it in purely formal terms it just needs to operate on expressions containing variable terms
18:45:10 <exFalso> augur: what do you mean by "an expression with variable terms"? isnt that what a function is?
18:45:23 <exFalso> or do you refer to the syntax tree?
18:45:26 <augur> exFalso: not at all! an expression is a syntactic object
18:45:35 <exFalso> ah
18:45:35 <augur> a function is some widget out there in the world of math
18:46:35 <exFalso> well yes you could view it that way, but then differentiation becomes a "meta" operation, no?
18:46:56 <augur> exFalso: i mean, consider -- if we view this in functiony terms, then it makes no sense to ask what the d/dx of "a * f(x)" is unless we already understand this term involve some implicit lifting operations
18:47:30 <augur> dibblego: either including a "scalar multiple" lifting of multiplication, or including a lifting of * and a lifting of scalars to constant functions
18:48:10 <augur> both of which are of course entirely plausible -- this is what people do with combinatorial species and the like, even when doing purely formal differentiation
18:48:36 <augur> so it's not uncommon to see something like   KA *^ F   instead of just   A*F
18:48:44 <exFalso> well you might be able to do this syntactic definition for differentiation, but definitely not for integration, which imho makes it a but inconsistent
18:48:54 <exFalso> *bit
18:49:00 <augur> where KAX = A, and F *^ G = \X -> FX * GX
18:49:40 <augur> exFalso: well, integration is just anti-differentiation, so you can use a lot of syntactic techniques in many cases
18:49:54 <augur> dunno if you can get away with it for some fancier things like laplacian magic or whatever, tho
18:51:00 <augur> but if you look at things from a syntax-with-variable-terms view, the type errors sussman mentions are, i think mostly non-existant
18:51:31 <rwbarton> in math often the things you're differentiating are really not functions at all (or at least not in the obvious way)
18:51:35 <exFalso> d/dx :: (R -> R) -> (R -> R) i think this is the most consistent way of viewing it
18:51:39 <augur> rwbarton: ?
18:52:05 <augur> exFalso: overall, i think you're right. im just saying that it's also possible to view it as d/dx :: Exp -> Exp
18:52:11 <rwbarton> for example a polynomial over a ring should not be confused with the function from that ring to itself that it produces
18:52:16 <augur> at least in some cases
18:52:46 <danharaj> Really you just want your derivative operator to be linear and obey the leibniz rule.
18:52:47 <augur> rwbarton: is there a difference in what differentiation would produce if you took one view vs. the other?
18:52:48 <rwbarton> if I work modulo p then x^p = x for any x in Z/pZ, so the polynomials x^p and x are "equal as functions"
18:52:59 <rwbarton> but d/dx (x^p) = 0, while d/dx (x) = 1
18:53:05 <augur> danharaj: right, its just what is the _type_ of the operator
18:53:39 <augur> danharaj: because if its (X -> X) -> X -> X then you need to make various statements (usually implicitly, of course) about how you're living non-functions into functions
18:54:06 <danharaj> augur: Sorry I don't have the context for this conversation. :3
18:54:18 <augur> rwbarton: hm. why would that hold, the first one i mean -- d/dx (x^p) = 0
18:54:32 <danharaj> Fermat's little theorem.
18:54:33 <rwbarton> since d/dx (x^p) = p x^(p-1) and p = 0
18:54:35 <exFalso> augur: if you take the Exp -> Exp position you'll get no type safety at all, you can say that (1 + {}) :: Exp
18:55:11 <exFalso> (+) is Exp -> Exp -> Exp, 1::Exp, {}::Exp
18:55:19 <rwbarton> so all I am saying is in math, you are often forced to consider differentiation which is really not of the type (X -> X) -> (X -> X) at all
18:55:21 <augur> danharaj: there is no context :p except maybe sussman's comments (when talking about teaching calculus) that its hard to do because students get lost in the type mismatches
18:55:21 <exFalso> this is precisely what you want to avoid
18:55:48 <augur> exFalso: im not sure why that's not type safe..
18:56:03 <exFalso> augur: it will typecheck, but it shouldnt
18:56:16 <augur> rwbarton: im not sure why you have p = 0 tho..
18:56:23 <rwbarton> since I'm working mod p
18:56:26 <shapr> preflex: seen edwardk
18:56:26 <preflex>  edwardk was last seen on #haskell-blah 43 minutes and 42 seconds ago, saying: just remembered to purchase turbohaskell.com
18:56:27 <augur> exFalso: but _why_ shouldn't it?
18:56:29 <shapr> hrm
18:56:37 <augur> rwbarton: er.. im not sure i understand
18:57:02 <augur> rwbarton: oh, i see, ok, right.
18:57:07 <augur> rwbarton: interesting!
18:57:08 <exFalso> the whole point of typing is to ensure the safety of your operations and 1 + {} is not safe (unless you defined 1 in a weird way)
18:57:32 <augur> exFalso: but WHY isn't it safe? you just said {} :: Exp so i dont see why it's not safe
18:57:44 <danharaj> augur: I guess the most general definition would be a linear map between two algebras over a ring R.
18:57:52 <danharaj> That satisfies leibniz.
18:58:16 <augur> danharaj: well, there's this notion of a differential algebra which is any (semi)ring with an operator that's linear and satisfies the product law
18:58:22 <augur> danharaj: but my point is more subtle than that, right
18:58:51 <exFalso> augur: you argue that typecheck -> safety, however it should be the other way around as well
18:58:55 <augur> danharaj: because what does the operator apply to? elements of the algebra? or does it apply to endomaps on the algebra? or ...
18:59:08 <augur> exFalso: ok so where is it not safe. that's what i dont get
18:59:13 <danharaj> augur: elements.
18:59:27 <exFalso> augur: in the type system it is safe, mathematically its meaningless
18:59:41 <augur> danharaj: ah but then it's certainly not what we expect, because that means d/dx is a map from numbers to numbers -- nonsense!
18:59:46 <exFalso> so we need to refine our type system to catch this meaningless state
19:00:03 <exFalso> d/dx is a map from functions to functions
19:00:06 <augur> exFalso: well, it's not meaningless, unless you're presupposing some meaning for + and 1 that don't apply to {}
19:00:16 <rwbarton> augur: no, the algebra will be "differentiable functions from R to R", or "polynomials with coefficients in R"
19:00:43 <exFalso> yes, your semantics defines meaningful terms, and your typing should ensure that only meaningful terms can be typed
19:00:46 <danharaj> What rwbarton said.
19:01:14 <augur> rwbarton: fine, but then your algebraic operations must essentially "encode" the lifting operations i refered to earlier -- * isnt multiplication, its point-wise lifting of multiplication, etc.
19:01:33 <danharaj> augur: * isn't ring multiplication, it's the multiplication in your algebra.
19:01:41 <dibblego> augur: did you intend that for someone else?
19:01:43 <danharaj> There's two multiplications involved.
19:01:56 <rwbarton> it looks like "point-wise lifting of multiplication" when you try to interpret the elements of your algebra as functions, yes
19:02:33 <augur> danharaj: im not sure what you mean by that. the ring _is_ the algebra, surely
19:02:53 <exFalso> augur: yes mathematics is not as rigorous as it should be there is a lot of overloading, but usually the expressions are unambiguous
19:03:15 <augur> exFalso: no what im saying is that its actually more rigorous than people assume -- IF you think in terms of expressions!
19:03:17 <danharaj> augur: no, an algebra is a linear space over the ring equipped with a multiplication (doesn't even need to be associative)
19:03:49 <augur> danharaj: i dont follow.
19:03:56 <exFalso> augur: if you think in terms of expressions there is no point of typing! i can define a "rigorous" type system which types (+ (+) * 1 d/dx)
19:03:58 <danharaj> the word algebra is overloaded to hell.
19:04:04 <augur> danharaj: like, to the point where im not even sure what you're talking about :P
19:04:33 <augur> exFalso: of course there's a point of typing -- you still have to connect up to the semantics somehow
19:04:49 <augur> exFalso: and the differentiation operator should behave nicely there
19:04:52 <exFalso> danharaj: that is a very special algebra
19:05:06 <danharaj> No, that's an algebra.
19:05:24 <rwbarton> it's what people who do algebra call an algebra ;)
19:05:29 <exFalso> well a monoid doesnt fit your definition and a monoid is an algebra
19:05:30 <danharaj> :p
19:05:31 <augur> exFalso: im just saying that the syntactic view of differentiation is fine (at least for the cases where some people have said its not type-safe)
19:05:59 <danharaj> A monoid is not an algebra.
19:06:03 <danharaj> I defined what an algebra is.
19:06:08 <exFalso> haha
19:06:09 <augur> exFalso: the denotation of open expressions are still functions of course
19:06:33 <augur> danharaj: an algebra is a functor F with an map F U -> U!
19:06:34 <augur> :)
19:06:41 <danharaj> No, that's an F-Algebra!
19:06:44 <danharaj> :p
19:06:49 <augur> aka an algebra!
19:06:51 <augur> :D
19:06:56 <augur> thats all the algebra i need!
19:07:27 <copumpkin> augur: you'd hope it was an endofunctor in particular
19:07:37 <exFalso> augur: hmm interesting point, but i think that d/dx(1) shouldnt type check
19:07:41 <augur> exFalso: im really just commenting on the idea that differentiation is often used in a way that fails to type check -- it doesn't fail, if you think in terms of expressions
19:08:18 <augur> copumpkin: i imagine you could have pseudo-algebras that go cross category. ive heard of pseudo-monads (im not using the right term) that work like normal monads but are cross-category
19:08:34 <augur> exFalso: but why not?
19:08:56 <exFalso> because 1 is a number, and you can't differentiate a number...
19:08:57 <augur> exFalso: if you're viewing things syntactically, 1 :: Term, and d/dx :: Term -> Term, so why shouldn't d/dx(1) typecheck?
19:09:06 <rwbarton> "1" is already heavily overloaded...
19:09:18 <augur> exFalso: no but thats what im saying, in the syntactic view, 1 ISNT a number, it's a term in the syntax!
19:09:40 <exFalso> yes, i understand that if you weaken your type system more terms will typecheck
19:09:49 <Cale> augur: If 1 refers to a constant function, then that's both syntactically and semantically valid
19:09:52 <augur> no im not saying weaken anything, exFalso
19:09:54 <exFalso> what im saying is that you shouldne weaken your typing
19:09:59 <augur> Cale: thats what i said earlier :)
19:10:15 <augur> exFalso: dont weaken anything, just have syntax + semantics
19:10:22 <exFalso> you can't make the differentiation between 1 as a number and 1 as a constant function for example
19:10:38 <exFalso> well iwht that argument javascript is also safe
19:10:45 <Cale> I think I missed too much of the context of this discussion.
19:10:49 <rwbarton> 1 is already the standard notation for the multiplicative identity of an algebra... and d/dx(1) = 0 is one of the axioms for a differential operator
19:10:51 <exFalso> everything is one type, and the semantics defines the safety
19:11:09 <rwbarton> so you can take the viewpoint that you are just overloading the notation 1
19:11:23 <rwbarton> or you can say there is an implicit conversion from the integer 1 to an element of your algebra
19:11:52 <Cale> But I would like to say that in mathematics, the syntax is allowed to be somewhat ambiguous because the human reader is expected to be intelligent enough to disambiguate things a bit. In a programming language, that sort of thing isn't very desirable.
19:12:09 <exFalso> yes, but augur argues that by interpreting everything as expressions you can hide this ambiguity and still stay safe
19:12:16 <Cale> hmm
19:12:35 <augur> Cale: yeah, im just commenting on the idea that calculus is hard to learn because some things dont "make sense" in type terms, when i think they do, if you have the right type terms
19:12:54 <danharaj> Calculus is hard to learn because the types aren't given to the students.
19:12:57 <augur> exFalso: i suppose i see your point about the safety i guess
19:12:58 <Cale> Well, this is an example where it can be considered unambiguous because of type checking :)
19:13:02 <danharaj> You learn linear algebra *after* Calculus I.
19:13:03 <exFalso> danharaj:+
19:13:11 <rwbarton> arguably figuring out the way in which the types work out in calculus is harder than learning calculus itself, yeah
19:13:14 <augur> danharaj: hah, true, but "meanings" are, which i think is what sussman is really after
19:13:33 <danharaj> Everyone has an opinion on calculus pedagogy. :)
19:13:40 <Cale> danharaj: I learned linear algebra before any calculus where linear algebra applied.
19:13:41 <confab> :t =>
19:13:42 <lambdabot> parse error on input `=>'
19:13:47 <confab> :t (=>)
19:13:48 <lambdabot> parse error on input `=>'
19:13:51 <confab> hmm
19:13:52 <confab> guess not
19:14:01 <exFalso> :k (=>)
19:14:02 <augur> confab: => isn't an operator, it's part of type syntax
19:14:02 <danharaj> Cale: So before any calculus whatsoever? :p
19:14:02 <lambdabot> parse error on input `=>'
19:14:04 <Cale> My Calculus 1 course was mostly about sequences of reals.
19:14:24 <shergill> mathematics is littered with notational abuse. abuse which ordinarily wouldn't type-check. but i suppose one can consider it as syntactic sugar
19:14:24 <exFalso> with constraintkinds it should have kind Constraint -> * -> * no?
19:14:25 <danharaj> pff that's topology.
19:14:35 <Cale> yeah, it was basically intro to real analysis
19:14:39 <augur> Cale: oh wow, that was calc3 for me. calc1 was real functions of one varible, calc2 was about multivariable calculus
19:14:41 <confab> i think i walked in on a good conversation
19:14:48 <danharaj> Mathematics has decidable type checking though.
19:14:55 <danharaj> 1. infer types. 2. If that fails ask your advisor.
19:15:06 <exFalso> clearly terminating
19:15:32 <rwbarton> pretty sure the advisor-of relation is well-founded
19:15:38 <Cale> There was a bunch on continuous functions R -> R, and then maybe 1/4 of the course on differentiability and differentiation, and then a sliver at the end about the Darboux/Riemann integral.
19:15:47 <danharaj> yes but resolving that second step is unbounded nondeterministic.
19:15:51 <rwbarton> true
19:16:05 <augur> the only reason i really bring this issue up tho is because im trying to define a differential algebra for graphs and it dawned on me while looking at the differential algebra wikipedia page that \partial cant operate on the terms of the algebra itself
19:16:15 <Cale> and so long as you stick to functions R -> R, the relationship to linear operators can wait :)
19:16:25 <augur> which of course lead me to consider the typing question
19:16:27 <danharaj> augur: You need to use a word that is not algebra. When you're doing calculus algebra has a specific meaning. :3
19:16:36 <augur> danharaj: im using the standard term!
19:16:46 <augur> http://en.wikipedia.org/wiki/Differential_algebra
19:16:59 <augur> tho i guess here they're talking about algebras over fields
19:17:03 <augur> whatever :p
19:17:03 <Cale> If you want to generalise the derivative really nicely to maps R^n -> R^m, a bit about tensor product spaces is quite nice to have.
19:17:23 <Cale> (well, particularly if you want to do higher-order derivatives)
19:17:44 <danharaj> augur: By definition the operator must operate on the algebra.
19:17:51 <danharaj> (wow that sounds way dumber out loud)
19:18:27 <Luke> anyone having problems installing zlib-enum on ghc 7.4.1? "Codec/Zlib/Enum.hs:44:32: Not in scope: `withInflateInput'"
19:18:27 <augur> danharaj: well, thats the point im trying to make tho -- if it operators on the algebra, then the algebra must either have variable terms (so you have a syntactic view), or the elements of the algebra are functions
19:18:59 <danharaj> augur: You can define a derivation on algebras that aren't function spaces.
19:19:07 <Cale> augur: well, I don't think you're allowed to care much about what the elements of the algebra *are*...
19:19:41 <augur> danharaj, Cale: well ok, maybe they dont have to be functions per se
19:19:43 <danharaj> Also you might not want to try to define a differential algebra. For example, derivatives in multidimensional calculus are not.
19:19:46 <rwbarton> I think we basically agree, compare < rwbarton> augur: no, the algebra will be "differentiable functions from R to R", or "polynomials with coefficients in R"
19:19:50 <rasfar> A former teacher of mine has worked on categorical differentiation, maybe that could be interesting?  www.mat.uc.pt/~ct2011/talks/Cockett.pdf
19:19:50 <lambdabot> rasfar: You have 1 new message. '/msg lambdabot @messages' to read it.
19:20:05 <augur> rwbarton: yeah, i think we do. :p
19:20:27 <rwbarton> but I am a little skeptical about taking the syntactic point of view too far, e.g. I doubt you want to distinguish "x" from "x + 0"
19:20:46 <augur> danharaj: well, i need enough differential structure to get noether's theorem :p
19:20:48 <rasfar> (i just got here so not sure how relevant, but, "hey!", category theory and differentials together ought to appeal to a Haskeller!
19:21:00 <danharaj> augur: Do you have a topology?
19:21:25 <augur> rwbarton: well syntactically maybe not -- use an equivalence class if you want -- but the syntactic view will still work there, it'll just get noisy
19:21:29 <danharaj> I mean, I know a professor who once defined harmonic analysis on graphs so I'm sure there's something to be had here.
19:21:39 <augur> danharaj: ehh, i dont know. its hard to tell.
19:22:03 <danharaj> augur: What is the object you are studying as a category?
19:22:14 <augur> danharaj: damn good question. :)
19:22:54 <augur> danharaj: the graphs are finite (labeled) DAGs where the nodes have certain internal structure
19:23:13 <rasfar> funny, i was just doing something related earlier today!
19:23:47 <rasfar> (not specifically what you just said augur, but differentiable structures on directed graphs)
19:23:56 <Cale> augur: What is the problem that you are trying to solve?
19:25:10 <augur> danharaj: specifically, your nodes are sets of typed terms (lets just say typed constants, with the usual non-quantified types), maybe enriched with some graph-theoretic notions of structure on the terms, and the graphs that the nodes are part of are the spaces produced from rewriting these sets of terms using standard type inference rules
19:25:57 <augur> danharaj: so you have, for instance, the set {f : X -> X -> Y, a : X, b : X} and the space is all of the ways you can rewrite this set, building up larger structures
19:26:10 <augur> for instance, you can rewrite it to {faa : Y, b : X}
19:26:15 <augur> or to {fab : Y}
19:26:17 <augur> etc.
19:26:34 <danharaj> ok.
19:26:47 <augur> so this forms a DAG (with the edges labeled by the rewriting rule and the elements used, maybe)
19:26:58 <danharaj> are you sure it forms a dag?
19:27:33 <augur> pretty sure yeah. i mean, it's not going to be cyclic (modulo a "noop")
19:27:35 <exFalso> as long as you dont have equirecursive types yes
19:27:48 <augur> no even if you have recursive types
19:28:25 <rwbarton> it sounds like your rules are {a, b, c, ...} -> {ab, c, ...} and {a, b, ...} -> {a, a, b, ...}?
19:28:31 <augur> maybe im wrong about that, but i cant see how you could get loops
19:28:31 <rwbarton> subject to type checking
19:28:50 <exFalso> muX. (X -> X)
19:29:07 <augur> rwbarton: im not sure what thats supposed to mean
19:29:27 <augur> exFalso: ah ok. im just using simple types :)
19:29:39 <rwbarton> like you can either duplicate an element, or replace two elements with the application of one to another
19:30:10 <augur> rwbarton: oh, well, duplication maybe, but right now im not looking at cases with duplication
19:30:15 <augur> rwbarton: so its just reductive
19:30:31 <rwbarton> okay, well somehow you got faa, but anyways, carry on
19:31:01 <augur> oh, well, sorry, i should clarify that bit -- if you view the terms as graphs, then you just have one a, but it's got two incoming edges from f
19:31:36 <exFalso> so your nodes are graphs as well
19:31:40 <Cale> augur: So if we have   {f : N -> N -> N, 1 : N}, then the only reduction is to {f 1: N -> N} and then we can't go farther?
19:31:40 <augur> rwbarton: so you'd be reusing something, rather than duplicating it
19:31:46 <rwbarton> okay, i see
19:31:56 <Cale> ah
19:32:05 <augur> Cale: well you could "reuse" 1, which would have to be distinguished from _duplicating_ it
19:32:06 <Cale> So we probably shouldn't be removing things?
19:32:31 <augur> yeah, i mean, ideally you'd just view the whole thing as a graph and you're just adding edges
19:32:36 <augur> but graphs are hard to type in irc :)
19:32:38 <rwbarton> it sounds like you should just imagine a node for each given constant with an input half-edge (of specified type) for each argument and a single output half-edge and then you can connect whatever you feel like that type checks
19:32:45 <exFalso> or you could just leave the 1 there, you'd still have a decreasing path
19:32:48 <Cale> So the transition is from {f: N -> N -> N, 1 : N} to, say, {f 1: N -> N, f : N -> N -> N, 1: N}
19:33:06 <Cale> (and then maybe make it downward closed, so you can take any subset?)
19:33:11 <Cale> I dunno :)
19:33:28 <augur> sure, tho in the system that im using, it's important that the second f isn't really.. "there"
19:33:37 <exFalso> well if you leave f : N -> N -> N in there then your "inference" won't terminate necesserily
19:33:49 <augur> Cale: in that you dont want to be able to use it again and apply it to a second first-argument
19:33:50 <Cale> Well, it had better not
19:33:56 <rwbarton> do you have higher order function types? (like f : (N -> N) -> N)
19:34:03 <Cale> because there is an infinite chain of larger sets of terms here
19:34:05 <augur> Cale: like, you dont want to go {f, a, b} ->* {fa, fb}
19:34:24 <augur> rwbarton: eh maybe. im not sure it matters. assume so.
19:34:29 <Cale> f (f 1 1) (f (f 1 1) (f 1 1))
19:34:33 <rwbarton> can I assume not if I like? :)
19:34:38 <augur> rwbarton: sure!
19:34:42 <rwbarton> ok I am with you then.
19:34:43 <danharaj> It seems like you want a linearity restriction of some sort.
19:35:02 <Cale> I still don't really understand what we're trying to do
19:35:13 <augur> rwbarton: i mean, ultimately you can imagine it like this: you have a tree substitution grammar, where your "trees" can actually be DAGs
19:35:28 <rwbarton> yeah I think that is what I am imagining
19:35:36 <augur> danharaj: well sort of, but that's going to come out of other factors
19:36:12 <Cale> augur: http://www.cas.mcmaster.ca/~kahl/HOPS/doc.html -- perhaps something here might be of interest?
19:36:44 <augur> danharaj: well, the linearity of the function terms wont, that's just assumed. but if you view it as graph rewriting, you get that already -- your forests have nodes with holes in them, and you fill the holes, so obviously once you fill a hole, its filled! you cant refill it with something else
19:37:08 <danharaj> augur: ah gotcha. I think I have an idea of what we're talking about now.
19:38:12 <augur> Cale: maybe. i doubt it tho -- im trying to view these graphs as things that you can have configuration spaces over, where each configuration is one of these forrests -- and then you have paths through these configuration spaces
19:38:49 <augur> Cale: and these paths are subject to principles of least action -- in any given space, you define some PoLA that picks out a set of optimal paths
19:39:22 <augur> and im trying to figure out if its possible to port noether's theorem to this domain
19:39:54 <Cale> odd :)
19:40:00 <augur> it is odd!
19:40:04 <danharaj> wouldn't be surprised if you succeeded
19:40:08 <danharaj> Math is a big joke like that.
19:40:19 <augur> Cale: but its weird in that it seems to work
19:40:46 <Cale> So you're trying to describe evaluation mechanisms via a "Lagrangian" of some kind?
19:40:47 <augur> Cale: and by work i mean it seems to constrain the combinatorial operations of natural language to produce certain grammatical phenomena
19:41:17 <augur> ill brb.
19:41:37 <augur> remind me to explain an example to you when i get back
19:41:38 <augur> :p
19:42:10 <Cale> It should be possible to do it somehow, yeah
19:42:25 <Cale> At least, if my interpretation of what you're trying to do is correct
19:45:56 <confab> it bothers me that there are more intelligent conversations in #haskell than in ##math
19:46:33 <Cale> People don't come to #haskell to talk about elementary and highschool math.
19:47:10 <Cale> But there are just as intelligent conversations which happen in ##math
19:47:41 <confab> i didn't necessarily mean the content
19:47:55 <confab> just that it rarely ends in yelling
19:47:57 <confab> and cursing
19:47:57 <shergill> Cale: what are the evaluation mechanisms on? (i joined in late)
19:47:59 <Cale> heh
19:48:29 <dolio> Go read sci.math.
19:48:34 <dolio> Then ##math won't seem so bad.
19:48:37 <Cale> haha
19:49:54 <Cale> Is there a lot of yelling and cursing in ##math?
19:50:10 <Cale> I tend to look in there a bit more rarely these days than perhaps I should.
19:50:26 <confab> probably not as much as i think
19:50:53 <confab> but it seems like more than there should be
19:51:19 <Cale> I have operator status, so feel free to let me know if you see anything inappropriate in the future
19:52:03 <confab> nah, i dont like to make waves on the internet
19:52:07 <confab> only in real life ;)
19:53:53 <deej__> hey guys, I have a website I made with Snap, do my hosting and deployment options look like? So far Ive only seen someone use heroku and I see a lot of aws packages on hackage. What is the preferred haskell web app hosting solution
19:56:23 <deej__> any ideas for hosting?
19:56:28 <deej__> or is this the wrong place to ask
19:57:02 <ski> Cale : (at least some) regulars often respond in a confrontationary way when people aren't asking in a good way
19:58:50 <parcs`> deej__: just use a generic vps. linode is good
19:58:56 <parcs`> :(
19:59:03 <Cale> ski: :/
19:59:23 <parcs`> deej_: ^
20:01:20 <ski> (seen as recently as today)
20:10:35 * hackagebot blaze-svg 0.1.1 - SVG combinator library  http://hackage.haskell.org/package/blaze-svg-0.1.1 (DeepakJois)
20:13:57 <edwardk> preflex: xseen kowey
20:13:58 <preflex>  kowey was last seen on freenode/#darcs 15 hours, 25 minutes and 22 seconds ago, saying: and branch
20:16:35 <edwardk> ok, so apparently wxwidgets has a busted opengl frame, gtk2hs is a monster to install and qthaskell is ancient, am i seriously limited to either building an app in xcode and hand linking every library from the haskell world or using GLUT to do windowed applications on a mac with opengl?
20:17:10 <edwardk> er s/wxwidgets/wxhaskell
20:18:12 * ski thought Fudgets was ancient ..
20:19:54 <luite> hm, I could install gtk2hs with a macports gtk install without problems (haven't tested it much though)
20:21:43 <edwardk> luite: gtk2hs for 7.4.1 with a 64 bit mac sent me http://www.haskell.org/haskellwiki/Gtk2Hs/Mac which asks me to go grab an installer that doesn't exist
20:23:09 <edwardk> so then i wind up installing pretty much the entire universe to get it to install. and about 90% of the way through the install things start failing
20:24:50 <luite> hm, for me it was mor or less: sudo port install gtk, cabal install gtk2hs-buildtools, cabal install gtk2hs
20:25:14 <luite> but I did get an X11 build of gtk tat way, not a native Quartz one
20:25:23 <edwardk> yeah, i'm looking for a quartz build
20:25:35 * hackagebot persistent-protobuf 0.1.3 - Template-Haskell helpers for integrating protobufs with persistent.  http://hackage.haskell.org/package/persistent-protobuf-0.1.3 (MichaelStone)
20:25:46 <edwardk> since the whole point was to get a UI layer that didn't look like it was done by a 12 year old
20:26:27 <luite> hm, right, in that case, good luck, and please tell me how you did it if you succeed ;)
20:26:49 <edwardk> hah
20:27:06 <edwardk> well, at this point i'm about to just throw up my hands and go develop on my pc where its somewhat sane ;)
20:29:57 <rasfar> luite, did you and tgeeky figure out how to deal with your in-mem modules?
20:30:42 <luite> rasfar: no, but I found a way to load what I needed with GHC anyway, and most of the expression type-extraction code is also done now
20:30:43 <rasfar> (btw, i have since learned the project is Top Secret so i won't probe so deeply next time ;)
20:31:15 <luite> hehe my empty repository has more watchers now than my other repositories :p
20:31:17 <rasfar> nice when things move along.
20:31:23 <rasfar> lol
20:32:32 <mgsloan1> luite: yeah, the github empty repository message is perfect for an unreleased secret project
20:33:15 <rasfar> "Nothing to see here; move along" iirc
20:33:28 <luite> rasfar: actually this is real data from an earlier version: http://hdiff.luite.com/tmp/types2.gif , and a mockup of what the user interface might look like when it's done: http://hdiff.luite.com/tmp/typeinfo-mockup.png
20:33:39 <rasfar> i wasn't familiar enough with github to know it was a standard message
20:35:16 <luite> mgsloan says that I should also show http://hdiff.luite.com/tmp/q3.png
20:35:18 <luite> :p
20:35:30 <mgsloan> :D
20:35:42 <rasfar> alright, not the ones i'd seen (you posted some screenshots in a cafe thread about a web-based diagrams interface proposal)
20:36:14 <luite> hehe I'm not apfelmus
20:36:37 <rasfar> that one looks more familiar, but it is slightly different than the version i saw two days ago
20:37:01 <luite> the GSoC proposal has screenshots from a different system
20:37:11 <luite> that doesn't use diagrams btw, but dia
20:37:14 <dibblego> roconnor_: are you around?
20:37:27 <rasfar> ah
20:38:23 <luite> http://hackage.haskell.org/trac/summer-of-code/ticket/1609
20:38:27 <luite> that's the proposal
20:39:22 <rasfar> oh hey, one of them is animated, neat.  so Wolfgang will be unveiled soon i expect?
20:39:58 <rasfar> yep that's the proposal i was reading last time i was online
20:40:16 <luite> well the types things are delaying it bit, but I promised myself that I wouldn't add more features to it before at least setting up a public demo site :)
20:41:02 <rasfar> "seems reasonable" (as one of my favourite people never tires of saying)
20:41:55 <luite> I'm sure that it will take a while before it's really useful after that
20:42:36 <rasfar> i'm looking for some useful Haskell really get into; meanwhile i'm just reading stuff and trying to broaden/modernize my general knowledge.
20:42:47 <rasfar> s/Haskell/Haskell project/
20:43:30 <luite> mgsloan is also doing some interesting type visualization things
20:43:48 <mgsloan> yup, I'll post a screenie in ~10 min
20:43:55 <mgsloan> well not a screenie
20:43:57 <dylukes> The fun thing about the interactive values thing,
20:43:59 <mgsloan> better mockup
20:44:15 <dylukes> is that, internally, it ends up being the same thing as a spreadsheet (a data-flow language DSL)
20:44:22 <mgsloan> (I have some code too, but it's undergoing pretty much a rewrite)
20:44:25 <dylukes> ...Haskell invades yet another paradigm!
20:45:01 <luite> I'm afraid that that isn't possible with my implementation
20:45:02 <rasfar> byorgey suggested diagrams, but i'm really not that keen on vector drawing unfortunately, and none of the tickets really grabbed me
20:45:47 <luite> oh but byorgey is a nice guy and #diagrams is a really cool channel!
20:45:48 <rasfar> visualisation does interest me however; mgsloan do you use diagrams for that?
20:45:53 <mgsloan> yup
20:46:07 <mgsloan> for a long while I was doing straight cairo
20:46:17 <rasfar> hmmm... okay, i'll try again :)
20:46:33 <rasfar> no lookin' back?
20:46:44 <mgsloan> but the code turned way more informative when I made the diagrams switch
20:46:53 <mgsloan> yup
20:47:04 <Modius> Say, hypothetically, there's a toplevel variable representing a huge/infinite list, where it will be traversed for some reason thus caching a very large amount of data.  This ends up hogging memory.  Is there some way of specifying the toplevel var such that it won't try to cache this, or some way to ask the system to free it?
20:47:13 <rasfar> i like interactive graphics so i'm looking more towards GL
20:47:56 <Modius> a0 = map fst $ iterate (\(_,b) -> (b,b+1)) (0 :: Integer,1)         then    length $ take 10000000 a0                 <-- this hogs a big pile of ram
20:48:24 <magicman> Modius: As far as I'm aware, the canonical trick is to define "var :: () -> SomeType", and use "var ()" everywhere.
20:48:28 <luite> you could make it a function
20:51:50 <augur> hello!
20:51:55 <augur> Cale: so ya
20:52:34 <augur> one typical example of interest is sentences like "John saw Susan before leaving the party" where we understand it to be John who left the party, not Susan
20:52:44 <Axman6> @hoogle a -> [a] -> Vector a
20:52:45 <lambdabot> Warning: Unknown type Vector
20:52:45 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
20:52:45 <lambdabot> Prelude asTypeOf :: a -> a -> a
20:52:51 <Axman6> :(
20:53:03 <augur> Cale: and one idea about how this works is that "John" is actually in both places -- "John saw Susan before John leaving the party", and it's just not pronounced in both places
20:53:19 <roconnor_> dibblego: I'm about to go to bed.  I'll have to look at it in the morning
20:53:41 <dibblego> roconnor_: okey dokey, let me know if it can be improved
20:54:06 <augur> Cale: so then the question is, why couldnt it be Susan in two places at once? Well, one idea is that in the course of building this sentence, you have a number of options for what words you put where, and when you have a choice between using a word for the first time, and using a word again, you should choose to use a word for the first time
20:54:56 <augur> Cale: so for example if you've build "before John leaving the party", you cant them go on to build "saw John", because you'd be reusing "John" when you could have instead used "Mary" for the first time in this process
20:55:02 <augur> Cale: so you _must_ use "Mary"
20:55:25 <Cale> Couldn't it just as easily be associated the other way if context demands it?
20:55:46 <augur> Cale: I certainly cant get the other reading, and I don't know of anyone who can
20:57:20 <Cale> hmm
20:57:27 <augur> and the general view in the literature is that this interpretation -- John leaving, not Susan -- is the ONLY reading you get
20:57:48 <augur> so if thats true, its interesting that you can get this from a constraint that says "use new things when possible"
20:58:24 <augur> because now you've got a principle that works by comparing multiple ways of building a sentence
20:58:39 <augur> and assigns these different derivations different costs
20:58:57 <augur> and the one with the lowest cost -- how many unnecessary reuses you do -- is the right one
20:59:30 <Cale> Well, maybe, at least :)
20:59:47 <augur> yeah, i mean, assuming the facts are that way
21:00:18 <augur> bu the facts dont matter for the math of it
21:00:26 <Cale> okay
21:01:06 <Cale> Is there always one with lowest cost?
21:01:16 <augur> well there could be multiple ones
21:01:20 <augur> and they're all supposed to be good
21:01:46 <augur> also, usually its phrased in terms of a defeasible constraint tho -- obey this constraint up to the point of producing a single output tree at the end
21:01:58 <augur> but violate it if you cant otherwise produce a tree
21:02:17 <augur> we'd say the derivation has to converge
21:02:34 <augur> so now you might wonder, well, is convergence also a principle of least action? and it turns out you can phrase it as such
21:02:44 <augur> indeed, a LOT of interesting things seem to be least-action-y
21:03:11 <augur> so my main goal is to give some mathematical teeth to this idea
21:04:00 <Cale> It's mildly awkward here that you can only make use of something a natural number of times.
21:04:06 <augur> and to try to then ask, ok, if this is a principle of least action, can noether's theorem about symmetries and conservation laws apply?
21:04:18 <augur> because there are ALSO things that seem awfully like conservation laws
21:04:37 <augur> yeah -- its an awkward system to work in
21:04:55 <any-key> I've got an odd GHCI session I'm having trouble understanding: http://pastebin.com/47DLdKYk
21:04:57 <mauke> The paste 47DLdKYk has been copied to http://hpaste.org/66047
21:05:03 <OODavo> Is there a commonly-used operator defined as flip fmap? Seems it'd be useful in the midst of a monadic chain: monadicF >>= monadicF' flipped<$> pureF >>= monadicF''
21:05:07 <augur> oh if only words were fractional!
21:05:28 <Cale> augur: maybe you ought to force them to be :D
21:05:30 <any-key> For the life of me I cannot figure out why it freezes when referencing the Map
21:06:12 <augur> Cale: ;)
21:06:37 <Cale> any-key: you just defined a new map m1 (shadowing the old definition) in terms of itself
21:06:46 <Cale> any-key: your new definition for m1 is recursive
21:06:59 <Cale> m1 = Data.Map.insert 2 "hello" m1
21:07:01 <any-key> Cale: >.<
21:07:07 <any-key> thanks
21:07:09 <Cale> so m1 = Data.Map.insert 2 "hello" (Data.Map.insert 2 "hello" m1)
21:07:11 <Cale> etc.
21:08:36 <nkpart> So. hsenv or virthualenv?
21:09:15 <OODavo> Or would it be preferred just to write the monadic chain backwards with (=<<), as in monadicF'' =<< pureF <$> monadicF' =<< monadicF?
21:09:20 <nkpart> do I just pick the clone with the command name I prefer? :)
21:09:58 <mgsloan> http://www.mgsloan.com/mockup4.png
21:10:28 <Cale> augur: I should say what my interpretation of what you were talking about before is. I actually don't know very well how it fits in here, but perhaps you have a better idea than I do.
21:10:41 <augur> Cale: ;)
21:10:46 <augur> yeah, its hard to know how to make it work
21:11:01 <augur> generally i try to think of it somewhat abstracted from the particular problem
21:11:24 <augur> and just think in terms of derivation spaces as graphs
21:11:25 <Cale> augur: Suppose we have a reduction system like the lambda calculus. We can form a vector space (over R or C, say) whose basis is every term in the system.
21:11:41 <augur> but i think thats where i get stuck, because you need differentiation to make it work so
21:11:48 <rasfar> augur, could you possible introduce weights or something, to get beyond naturals?  something like frequencies?  excuse if that is inapplicable, i missed a fair chunk of the discussion i think
21:12:17 <rasfar> (wish i hadn't, it sounds really interesting)
21:13:19 <mgsloan> (for those who click that link, (#) = flip ($), it's a diagrams utility)
21:13:23 <Cale> and then we can try to put a Lagrangian on this space such that minimal trajectories essentially do evaluation :)
21:14:43 <rasfar> (mgsloan, i think you posted the link in #diagrams)
21:14:56 <mgsloan> I posted in both
21:15:06 <augur> Cale: hah. well, for my purposes the lagrangian is just measuring the cost of each operation
21:15:08 <rasfar> oh, sorry, i see it
21:15:29 <augur> Cale: ill let you work on the LC stuff :)
21:15:45 <augur> but its cool, right, because noether's theorem gives you some crazy stuff
21:16:03 <augur> like, time symmetries are the "reason" for conservation of energy
21:16:08 <Cale> Well, the important thing here being that you have a Banach space, and can talk about nice paths in it
21:16:09 <augur> like, where does THAT come from, thats nuts
21:16:12 <rasfar> (it might be reasonable that the cost decreases/is optimised based on frequency)
21:16:16 <Cale> rather than just discrete sets of points
21:16:20 <mgsloan> rasfar: no worries! here's the link again because I just updated it to be more concise http://www.mgsloan.com/mockup4.png
21:16:25 <augur> but its _cool_, so who knows what unexpected stuff you might get
21:16:29 <confab> augur: what is this for?
21:16:34 <Cale> Also, because it's a vector space, you naturally get superpositions of terms
21:16:42 <augur> confab: theoretical linguistics (syntax, specifically)
21:16:46 <Cale> (as linear combinations of the basis elements)
21:17:06 <augur> Cale: for what space, now?
21:17:12 <augur> or for what objects, rather
21:17:20 <augur> the lambda terms?
21:17:24 <Cale> sure
21:17:35 <Cale> or your terms describing the semantics of English sentences maybe?
21:17:47 <rasfar> ah well, better make better use of my online time than being ignored here...
21:18:41 <Cale> augur: it's quite a lot like quantum mechanics
21:19:04 <Cale> augur: in that you also probably want to projectivise this, and only care about these vectors up to scalar multiplication
21:19:12 <augur> Cale: i suppose. i prefer to think of it like classical mechanics
21:20:02 <augur> rasfar: eep. sorry. didnt see your comment.
21:20:09 <mgsloan> not to distract from the interesting discussion, but what do y'all think of the type explanation diagrams in the above link?
21:20:19 <augur> rasfar: im not sure probabilities would be useful for this particular issue
21:20:39 <Cale> mgsloan: they look interesting, but I don't know how to read them
21:21:19 <augur> i agree with Cale
21:21:24 <augur> sexy diagrams. no clue what they mean.
21:21:25 <rasfar> augur, np, i am moody but all in good fun.
21:21:36 <mgsloan> yup, I thought that might be the case.  I need to add a guide to the side of my mockups methinks :)
21:22:11 <rasfar> i think they look like dance steps for gnats, my 2 cents <whistle...>
21:22:21 <augur> Cale: really its not about the semantics tho. i mean, the effect is ultimately a semantic one, but it stems purely from the syntax
21:22:30 <rasfar> just kidding! okay i really better go.
21:22:39 <augur> you do your syntax and then just read the semantics off it
21:22:44 <mgsloan> so, they're type diagrams.  When the line is above, that's supplying a parameter to a function.  The downwards arrow is next to its result type.
21:23:17 <mgsloan> In the case that types are vertically stacked next to the arrow, they are read from top to bottom, and are a function result
21:23:59 <mgsloan> The funny U-turns and ellipsis things are just to give intra-line type flow information
21:24:16 <mgsloan> http://www.mgsloan.com/mockup4.png (repeated for locality to description)
21:24:57 <mgsloan> the funny loopy things are due to (#) = flip ($)
21:25:11 <Cale> that might have been nice to know
21:25:12 <Cale> heh
21:25:50 <Cale> It might help more to see this notation used in simpler cases
21:25:51 <mgsloan> yeah, I definitely should put that in the top right corner.. should pick something that's not diagrams DSL!
21:25:55 <mgsloan> yup
21:26:18 <ski> mgsloan : reminds me vaguely of a proof-net'sy-like notation i used for (linear) lambda terms ..
21:26:52 <DijkstraGroupie> Is there any operator like $ but left-to-right associative?
21:27:02 <mgsloan> yeah, I saw some vaguely familiar things in some of the student talks at OPLSS
21:27:09 <mgsloan> s/familiar/similar
21:27:23 <mgsloan> DijkstraGroupie: that's what # is!
21:27:32 <DijkstraGroupie> mgsloan: Yay! Thanks!
21:27:32 <mgsloan> it's used for applying attributes to diagrams
21:27:44 <mgsloan> (which means you'll find it in Diagrams.Utils...)
21:28:29 <rasfar> quite a coincidence (if that's what it is)
21:29:45 <mgsloan> rasfar - perhaps these are the footsteps of the typechecker gnat
21:30:01 <luite> rasfar: hm, if you use that AST printing code I upped to hpaste, you will not get all typeckecker evidence from it
21:30:20 <luite> since apparently it hasn't zonked some part, and you must use unsafePerformIO to print it
21:31:16 <rasfar> oh yeah? well, unsafePerformIO is safe enough for that, right?
21:31:55 <luite> I guess, it's only for debugging, but I don't know if it still modifies those things, maybe in de desugar pass
21:32:02 <rasfar> mgsloan: that would be cute in an educational software teaching about type systems!
21:32:56 <mgsloan> yeah, these type diagrams get even more powerful as visualizations of partially typeable expressions, thereby illustrating the source of type errors
21:33:09 <mgsloan> so, haskell education / development tool is the intention
21:33:22 <rasfar> for daily production use i might be reaching for the fly-swatter after a few weeks...
21:34:13 <mgsloan> there'll be customization out the whazoo, never fear
21:34:45 <rasfar> oh, it /is/ the intention. nice; and no doubt.
21:35:41 <rasfar> luite: you bring rather forcibly to mind the fact that I don't get any type-checker info to play with when using HSE.
21:36:14 <Cale> DijkstraGroupie: however, (#) isn't in the Prelude
21:36:21 <Cale> also, it's flipped
21:36:33 <Cale> (so you have to write the arguments backward)
21:36:41 <DijkstraGroupie> Cale: For example?
21:37:08 <Cale> Well, mgsloan said earlier that (#) = flip ($), which isn't really what you were asking for
21:37:47 <Cale> You wanted something where (#) = ($), but for example, f # x # y # z = ((f # x) # y) # z, right?
21:37:58 <Cale> I would actually like that to be $ itself
21:38:10 <augur> Cale: my current idea is to treat the configurations as multigraphs graphs with positive and negative edges
21:38:51 <augur> Cale: then addition can work out nicely
21:39:44 <augur> Cale: multiplication using graph tensor product gets multiplication to distribute over addition
21:40:16 <Cale> what's the addition?
21:40:25 <Cale> disjoint union?
21:40:31 <augur> sort of
21:40:43 <augur> i mean, since its a multigraph, you have multiple identical edges
21:40:52 <augur> so you just add the count of the edges
21:41:17 <augur> so like, if you have a graph with at least a and b as nodes, you might have an edge e : a -> b
21:41:40 <augur> but you can have it however many times, so addition is just something like a count on the edge
21:42:01 <augur> being summed, i mean
21:42:26 <augur> e + e is just two edges from a to b with the same label
21:43:06 <augur> so that gives enough structure to have functions into it that might satisfy the laws of differentiation
21:44:08 <augur> if your paths in the higher space are functions Fin n -> Forest  (where Forest is just the type of those kinds of graphs)
21:44:38 <augur> then you should be able to satisfy the right laws, modulo finding some definition of differentiating a path
21:45:20 <augur> the operations on the paths are just the lifted operations on the forests, so it should work
21:53:21 <ski> augur : subgraph addition ?
21:53:31 <ski> hm'
21:53:32 <augur> ski: ?
21:54:15 <ski> no, i thinkoed
21:57:18 <shapr> ha
21:58:15 * shapr hugs caligula__
21:58:16 <shapr> whoops
21:58:19 * shapr hugs Cale
21:58:57 <Cale> My connection's apparently being a little flaky :P
22:02:03 <Cale> or, maybe Freenode is just having trouble, judging by all the ping timeouts.
22:28:41 <cwl> http://stackoverflow.com/questions/9883791/why-is-writestref-faster-than-if-expression
22:29:11 <cwl> Why is if-expression slow?
22:30:08 <rwbarton> because in the test you are comparing two huge numbers
22:30:13 <rwbarton> possibly?
22:31:24 <rwbarton> you realize that the most expensive operation in your loop is the addition, right
22:31:26 <cwl> rwbarton: hmm...
22:31:52 <cwl> rwbarton: I am not sure if writeSTRef is expensive
22:31:56 <rwbarton> it is not
22:32:05 <cwl> why
22:32:14 <rwbarton> compared to adding thousand-digit numbers? really?
22:32:38 <cwl> aha, thousand-digit
22:32:43 <cwl> I think so
22:33:24 <cwl> most operation on thound-digit numbers should be slow
22:33:53 <cwl> so the comparation must be slow too
22:33:55 <liyang> I think the extra branching in fib4 makes it slower than fib3.
22:34:36 <rwbarton> writeSTRef should just amount to storing a pointer
22:35:22 <cwl> liyang: the first if-exp or the second ?
22:36:13 <liyang> cwl: the first, given that's used 20000 times.
22:36:35 <rwbarton> actually the comparison is not going to be all that slow, it just has to check the signs, lengths of the integers, and then their first words, but surely all that plus the branch will add up to more than the cost of one writeSTRef
22:36:51 <rwbarton> 0.3 ms / 20000 sounds plausible
22:36:53 <cwl> liyang: but it also save 20000 times of evaluate writeSTRef
22:37:21 <rwbarton> writeSTRef should be like one machine instruction
22:37:33 <liyang> cwl: I think writeSTRef boils down to just one (or two) STOREs to memory.
22:37:48 <liyang> What rwbarton said.
22:37:49 <rwbarton> it's like assigning through a pointer in C
22:37:59 <rwbarton> writeSTRef p x -- *p = x;
22:38:53 <cwl> writeSTRef is really fast
22:39:08 <rwbarton> In practice I don't know exactly what it will be translated to, but really it should be fast
22:39:19 <rwbarton> faster than doing three or so separate comparisons
22:40:09 <liyang> You can ask GHC to dump out the assembly code with some flags that I can never remember, or cabal install ghc-core.
22:41:09 <cwl> rwbarton: can I find the source of instance Ord Integer?
22:41:20 <cwl> http://hackage.haskell.org/packages/archive/integer-gmp/0.4.0.0/doc/html/src/GHC-Integer-Type.html#Integer
22:41:28 <cwl> this link is broken
22:41:34 <rwbarton> well it will use gmp
22:41:55 <rwbarton> oh yes also it has to do a case on the Integer constructor
22:42:00 <rwbarton> do you know how Integer is implemented?
22:42:06 <cwl> no
22:42:12 <rwbarton> @src Integer
22:42:12 <lambdabot> data Integer = S# Int#
22:42:12 <lambdabot>              | J# Int# ByteArray#
22:43:11 <rwbarton> S# is used for integers that fit in a machine word, larger ones are handled by gmp using the J# constructor, so Ord on Integer will have to check whether they're S# or J# integers and in the later case call whatever gmp function does integer comparison
22:43:13 <liyang> cwl: git clone http://darcs.haskell.org/packages/integer-gmp.git/
22:45:08 <cwl> thanks
23:21:46 <missingfaktor> I have had this question for a while: https://plus.google.com/u/0/109924404877416820675/posts/SEsTK3xTvLt. Any help will be appreciated.
23:24:53 <shachaf> missingfaktor: I don't know in what sense you mean "logical inconsistencies", but "Just Int" as the type of "Just 5" just doesn't make much sense.
23:25:42 * hackagebot zoom-cache 1.2.1.3 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-1.2.1.3 (ConradParker)
23:25:53 <missingfaktor> shachaf: Yes, but why? The question essentially is: what's wrong with representing data constructors with separate types?
23:26:30 <missingfaktor> shachaf: scala does algebraic types with subtyping. hence Some(5) is Some[Int] as well as Option[Int].
23:27:10 <shachaf> Well, Haskell doesn't do subtyping. :-)
23:27:47 <shachaf> Are you asking why?
23:27:51 <missingfaktor> shachaf: yeah, i know that. :-)
23:28:07 <missingfaktor> shachaf: so does the subtyping approach have any logical flaws? thats the question.
23:29:22 <missingfaktor> (for this specific case, i mean. not in general.)
23:52:42 <nkpart> Hey, I'm looking for a function FilePath -> IO FilePath that will expand "~" to "/Users/nkpart"
23:52:50 <nkpart> can't see anything in hoogle
23:53:06 <nkpart> I've done  scan thought unix/system-filepath/filepath
23:53:13 <nkpart> *scan through
23:53:48 <yasar> given an number "n" is there a simple way to say, there are at least k prime number below n?
23:53:53 <c_wraith> @hoogle canonicalize
23:53:54 <lambdabot> System.Directory canonicalizePath :: FilePath -> IO FilePath
23:54:01 <c_wraith> nkpart: did you try that one?
23:54:09 <nkpart> Yeah I did
23:54:32 <nkpart> Prelude System.Directory> canonicalizePath "~" -- "/Users/nkpart/p/x/hsenv/~"
23:54:52 <c_wraith> oh.  ~ expansion is a shell thing, not a file system thing.  That's why canonicalizePath doesn't work.
23:54:56 <nkpart> (which is my current working dir)
23:55:02 <nkpart> Ah
23:55:15 <hpaste> lifestream pasted “parse error on input `='” at http://hpaste.org/66049
23:55:15 <lifestream> I read so many web pages explaining, but I don't understand why I have that parse error. I'm using spaces (8 spaces) and the expressions are past the Do. I've tried so many variations! (see paste above)
23:55:51 <c_wraith> lifestream: the problem is that you can't declare a function inside a do block without using a let
23:56:18 <lifestream> Hahaha... looks like I need to go back to the beginning then! Thank you..
23:57:31 <nkpart> c_wraith: thanks :)
23:57:58 <c_wraith> nkpart: not a useful answer, but at least it explains the problem a bit more.
23:58:08 <c_wraith> nkpart: good luck finding a better answer
23:58:13 <nkpart> Yeah now I know why I wasn't getting anywhere
23:59:37 <ChristianS> lifestream: the findLast function would usually go at the top-level, i.e. not indented (though you could also define it in a where block). then you "only" need to invoke it from main.
