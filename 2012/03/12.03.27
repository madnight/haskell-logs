00:03:07 <lifestream> Right you are ChristianS, need some glue to make this stuff stick to my head
00:08:08 <ktosiek> Hi! I can't find foldl' for lists, where is it?
00:08:25 <Enigmagic> @hoogle foldl'
00:08:26 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
00:08:26 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
00:08:26 <lambdabot> Data.ByteString.Char8 foldl' :: (a -> Char -> a) -> a -> ByteString -> a
00:08:39 <ktosiek> thanks :-)
00:09:14 <ktosiek> was it ever in GHC Prelude? Or am I confabulating?
00:09:20 <c_wraith> never was
00:09:25 <c_wraith> foldl and foldr are, though
00:09:51 <ktosiek> oh, ok :-)
00:10:07 <Veinor> someone told me that c++'s type system is like haskell's type system except shitty
00:10:11 <Veinor> i'm not sure what to think about this
00:10:39 <c_wraith> Veinor: it's someone who's run into parametric polymorphism in haskell and in C++ templates
00:10:49 <c_wraith> Veinor: and decided the way C++ does it is really clumsy in comparison
00:13:36 <Cale> I agree with c_wraith's judgement here
00:14:42 <Cale> C++ templates are typically used to simulate parametric polymorphism badly. They're actually more powerful than parametric polymorphism in some ways, but also much more awkward to use.
00:15:29 <Veinor> i see.
00:19:25 <mikkihiiri> hi.. still wondering about the successor lists from last night
00:19:57 <Cale> mikkihiiri: could you repeat your question?
00:20:26 <mikkihiiri> if i have a list of integers, how will i find successor sequences (like 1,2,3 or 5,6,7) and return them as lists
00:20:46 <mikkihiiri> so (Integral a) => [a] -> [[a]] i think
00:21:31 <mikkihiiri> I got advice that I should use map, but i can't figure out how I can compare this and "next" values of a list using map
00:21:55 <shachaf> Did you want the actual sequence or just the length of the longest one?
00:22:00 <shachaf> Also, is this homework?
00:22:18 <mikkihiiri> part of it yeah
00:22:37 <ivanm> if you want to compare something to the next one, use zip`ap`tail
00:22:40 <ivanm> @type zip`ap`tail
00:22:41 <lambdabot> forall b. [b] -> [(b, b)]
00:22:50 <ivanm> > (zip`ap`tail) [1..10]
00:22:51 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
00:22:55 <mikkihiiri> I wanted the longest one, but I'd rather start with getting a list of all successor sequences
00:23:03 <shachaf> @quote zip`ap
00:23:03 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
00:23:04 <ski> milessabin : well, you shouldn't use `map' for this part
00:23:11 <ivanm> or use maximumBy with a schwarzian transform
00:23:16 <ski> mikkihiiri ^
00:23:27 <mikkihiiri> what is ap?
00:23:32 <ivanm> (if you're just trying to find a maximum)
00:23:34 <ivanm> @src ap
00:23:35 <lambdabot> ap = liftM2 id
00:23:39 <ivanm> @src liftM2
00:23:39 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:23:44 <ski> mikkihiiri : did you look at `span' ?
00:23:46 <shachaf> ivanm: I'm sure *that'll* help mikkihiiri...
00:23:50 <ivanm> shachaf: heh, yeah
00:24:08 <ivanm> mikkihiiri: ap f g x = f x (g x)
00:24:14 <ivanm> (for your purposes)
00:24:48 <ski> @type successorStreaks
00:24:49 <lambdabot> forall t. (Eq t, Enum t) => [t] -> [[t]]
00:24:56 <ivanm> @type \ f g x -> f x (g x)
00:24:57 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
00:25:12 <ski> > successorStreaks [1,2,3,5,6,7,8,12,13]  -- was the example
00:25:14 <lambdabot>   [[1,2,3],[5,6,7,8],[12,13]]
00:25:46 <Cale> I think as a beginner exercise, it's probably best to start out writing that recursively
00:26:02 <ktosiek> how to get stack overflow in ghci?
00:26:15 <ktosiek> I want things like foldl (+) 0 [1..100000000] to crash :-)
00:26:18 <mikkihiiri> I think that too.. And I'd like to as much of it by myself
00:26:23 <Cale> ktosiek: by having too many pattern matches waiting for their scrutinee to be evaluated
00:26:25 <shachaf> ktosiek: GHC grows the stack automatically these days, or something.
00:26:59 <ktosiek> can I limit it anyway?
00:27:03 <yitz> ktosiek: use -O0
00:27:04 <ivanm> ktosiek: ummm, why? :/
00:27:13 * ski wonders whether mikkihiiri saw ski's question
00:27:24 <Enigmagic> ktosiek: +RTS -K<size> iirc
00:27:31 <Enigmagic> -K128K should help
00:27:31 <mikkihiiri> haven't look at span
00:27:46 <shachaf> What Enigmagic said.
00:27:54 <shachaf> Though 128K is probably a bit small.
00:27:57 <ivanm> does ski often refer to ski in the third person?
00:27:57 <ktosiek> ivanm: I prefer to have some stupid code crash than trash my swap
00:27:59 <ivanm> ;)
00:28:04 <yitz> > let longestRun = maximum . map (succ . length) . groupBy ((==) `on` (== 1)) . (zipWith subtract <*> tail) in longestRun [1,2,3,5,6,7,8,12,13]
00:28:06 <lambdabot>   4
00:28:14 <Enigmagic> shachaf: not if your goal is a stack overflow
00:28:18 <Enigmagic> 128K might be a tad large
00:28:30 <ivanm> though I'm confused by what "longest run" refers to in this context
00:28:48 <shachaf> Enigmagic: For me, 128K causes a bunch of stack overflows before ghci ever gets to a prompt.
00:28:54 <ktosiek> Enigmagic: doesn't work
00:29:07 <ski> ivanm : only when using `/me'
00:29:07 <shachaf> Oh, that's only because my .ghci is huge and imports 50 files and dozens of extensions.
00:29:11 <ktosiek> looks like ghci ignored it?
00:29:12 * yitz understands that using /me sometimes forces one to refer to one's self in the third person
00:29:14 <shachaf> ktosiek: Works for me.
00:29:22 <ivanm> shachaf: :o
00:29:29 <ivanm> what does your .ghci file contain?
00:29:30 <shachaf> s/file/module/
00:29:36 <shachaf> Currently my .ghci contains:
00:30:01 <hpaste> shachaf pasted “current .ghci” at http://hpaste.org/66053
00:30:04 <ktosiek> oh, it's ghci 7.0.3 - maybe that's the problem?
00:30:13 <ski> @src span
00:30:13 <lambdabot> span _ xs@[]                     =  (xs, xs)
00:30:14 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
00:30:14 <lambdabot>                   | otherwise    =  ([],xs)
00:30:17 <ivanm> shachaf: well, the actual *file* is .ghci, is it not?
00:30:43 <ivanm> why do you have some lines importing two modules?
00:30:45 <yitz> ktosiek: implement a stack using a fixed size Array, then push too many things into it
00:30:53 <shachaf> ivanm: Why not?
00:30:59 <ski> mikkihiiri : well, `span' uses an idiom of getting a returned pair from the recursive call, which it modifies before returning again, which i think could be helpful your you
00:31:05 <ivanm> seems a bit inconsistent, that's all
00:31:07 <ski> mikkihiiri : consider
00:31:08 <shachaf> ivanm: It would be even longer if I only imported one per line.
00:31:12 <ski> > successorStreaks [1,2,3,5,6,7,8,12,13]
00:31:13 <lambdabot>   [[1,2,3],[5,6,7,8],[12,13]]
00:31:16 <ski> vs.
00:31:18 <ski> > successorStreaks [2,3,5,6,7,8,12,13]
00:31:20 <lambdabot>   [[2,3],[5,6,7,8],[12,13]]
00:31:29 <shachaf> ivanm: The idea originally was to keep similar imports grouped together, and wrap at 80 characters, or something like that. But I got lazy.
00:31:32 <ktosiek> yitz: I want to protect myself from my stupid code, not really create stack overflow simulator
00:31:36 <ivanm> shachaf: heh
00:31:47 <ski> mikkihiiri : you should think about how to define `successorStreaks (a:as)' in terms of `successorStreaks as'
00:32:01 <yitz> ktosiek: understood. :)
00:32:06 <ivanm> shachaf: I would imagine that this could cause issues if you decided to hack on a library that clashed with the prelude or something...
00:32:15 <ivanm> but otherwise... :o
00:32:29 <ivanm> haven't heard of LiberalTypeSynonyms before; what does it do?
00:32:36 <shachaf> I'm not sure.
00:32:46 <shachaf> http://hackage.haskell.org/trac/haskell-prime/wiki/LiberalTypeSynonyms
00:32:48 <ivanm> you're just using it anyway? :p
00:33:14 <shachaf> ivanm: I needed it once. So why not?
00:33:17 <ski> mikkihiiri : however, you will also need to compare adjacent elements
00:33:28 <yitz> ivanm: perhaps it allows you to use a type synonym without fully specifying all of its parameters?
00:34:13 <yitz> ivanm: that would be the first liberalization i would ask for, anyone.
00:34:13 <ski> mikkihiiri : often, the task of programming something amounts to figuring out for yourself what general method you would use when solving the problem by hand, and then figuring out how to code that
00:34:15 <yitz> anyway
00:34:34 <ivanm> yitz: seems like something like that according to the page shachaf linked to
00:42:08 <ktosiek> oh, well
00:42:20 <ktosiek> I had to limit heap, not stack
00:43:37 <shachaf> That sounds odd.
00:43:54 <shachaf> Limiting the heap resulted in a stack overflow?
00:43:59 <ktosiek> no :-P
00:44:05 <ktosiek> but in stopping evaluation
00:44:50 <ktosiek> I stated my problem wrong, because I was thinking I'm using too much stack, not heap
00:44:55 <shachaf> Oh, well, I'm not sure what that's supposed to prove.
00:45:11 <shachaf> The issue with foldl (+) 0 [1..10000000000000] *is* stack use, at least in GHC.
00:45:34 <Enigmagic> foldr stack overflows immediately
00:47:41 <alistra> > foldl (+) 0 [1..10000000000000]
00:47:48 <lambdabot>   mueval: ExitFailure 1
00:47:48 <lambdabot>  mueval: Prelude.undefined
00:47:51 <alistra> > foldl (+) 0 [1..10000000000000]
00:47:57 <lambdabot>   mueval: ExitFailure 1
00:47:57 <lambdabot>  mueval: Prelude.undefined
00:48:05 <alistra> > foldl' (+) 0 [1..10000000000000]
00:48:06 * imc likes this article http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/ also, explain a bit foldl / foldl' and strict accumulators to make computation run in registers with constant space
00:48:08 <lambdabot>   mueval-core: Time limit exceeded
00:48:45 <Enigmagic> > foldr (+) 0 [1..10000000000000]
00:48:46 <lambdabot>   *Exception: stack overflow
00:49:35 <shachaf> Sure -- for foldl it has to get to the end of the list before it starts evaluating thunks.
00:52:36 <alistra> is there an example where foldl' wouldn't work and foldl would?
00:52:54 <shachaf> Yes, on the wiki.
00:52:59 <shachaf> There's a wiki page describing all this.
00:53:06 <alistra> link?
00:53:08 <alistra> wiki?
00:54:14 <shachaf> You could probably find it approximately as easily as I could.
00:54:25 <imc> :)
00:54:41 <alistra> lambdabot: google foldl wiki
00:55:08 <shachaf> I hear they have Google right in your web browser these days.
00:55:19 <shachaf> @google foldl haskellwiki
00:55:21 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
00:55:21 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
00:56:53 <alistra> redexen is the plural of redex?
00:57:09 <alistra> i always thought redexes
00:57:18 <merijn> I'm used to redexes, but I think both are correct
00:57:52 <shachaf> "redexen" is probably about as correct as "boxen".
00:58:17 <ivanm> so a sample run of my program with certain inputs leads to a "Maybe.fromJust: Nothing" error... yet when I run it in ghci, no such error appears :s
00:58:36 <alistra> well i didn't learn anything new, i was asking did somebody actually encountered a real life problem, where foldl' would fuck up
00:59:15 <merijn> Of course not, people don't use haskell for real life problems :) </troll>
01:00:14 <imc> in real life problem you will not throw [1..10000000000000] on poor foldl''s face
01:00:23 <imc> you will do something smarter
01:00:38 <alistra> i mean't
01:00:46 <alistra> the question was
01:00:55 <alistra> where is foldl better than foldl'
01:01:16 <alistra> and the answer is, if you don't need the computation and it's lazily discarded
01:01:44 <alistra> and if computation had an exception, than the execution differs
01:01:57 <alistra> and my point is that you rarely do computations that you discard
01:02:28 <merijn> Maybe you do
01:02:58 <alistra> -> real life example
01:02:59 <merijn> But if you do something like backtracking you might end up with lots of unneeded computations
01:03:02 <alistra> my initial question
01:03:29 <imc> real life problem's solution do not involve programming :P
01:03:34 <imc> (trolling)
01:03:50 <t7> Poor grammar, sir!
01:04:06 <iainm> Are there a family of functions with signatures like (m a, m b) -> (a -> b -> c) -> m c?
01:04:09 <Saizan> alistra: it's hard to come up with an example where you want foldl', sometimes the extra strictness is just not needed though, like when defining reverse
01:04:22 <t7> iainm: yes
01:04:23 <Saizan> alistra: err, where you want foldl, i meant
01:04:25 <alistra> merijn: yeah, but you basically don't want exceptions in paths of backtracking
01:04:30 <ktosiek> dunno, finding first element that meets some criteria looks pretty common
01:04:33 <merijn> iainm: Looks like you want fmap + curry or something like that?
01:04:35 <iainm> (hoogle says no, but I'm hoping people can divine my intent from that signature and tell me where to find them)
01:04:43 <merijn> :t fmap
01:04:47 <Saizan> ?src reverse
01:04:47 <lambdabot> reverse = foldl (flip (:)) []
01:04:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:05:13 <merijn> Oh wait, maybe I'm thinking of lift...
01:05:49 <merijn> :t liftM2
01:05:50 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:06:50 <iainm> that looks pretty perfect. Thanks!
01:07:54 <merijn> :t uncurry . liftM2 -- wrong argument order, but close
01:07:55 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> (m a1, m a2) -> m r
01:08:20 <alistra> :t flip . uncurry . liftM2
01:08:20 <lambdabot> forall a b a1 a2. (a1 -> a2 -> b) -> a -> (a -> a1, a -> a2) -> b
01:08:43 <alistra> wait what
01:08:54 <solarus> :t flip $ uncurry . liftM2
01:08:55 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (m a1, m a2) -> (a1 -> a2 -> r) -> m r
01:09:09 <merijn> solarus: Damn, I tried that but ghci gave me an error
01:09:27 <merijn> oh, ambiguous type because it can't derive m...
01:09:37 <merijn> I guess it'd work in an actual program
01:18:49 <hpaste> chrisdone annotated “haskell-mode-bindings” with “haskell-mode-bindings (annotation)” at http://hpaste.org/65941#a66054
01:21:10 <quicksilver> hmm. chrisdone pasting stuff but not in channel? or bot acting up and repeating announces for old pastes
01:22:19 <quicksilver> preflex: seen chrisdone
01:22:19 <preflex>  chrisdone was last seen on #haskell 1 day, 17 hours, 45 minutes and 21 seconds ago, saying: k so no one interested in trying my emacs thing right now. i'm off
01:29:24 <t7> @pl \a b c e d f g -> d e a d b e e f
01:29:25 <lambdabot> ((const . (((const .) .) .)) .) . flip flip id . (liftM2 flip .) . flip flip id . (liftM2 flip .) . flip . (flip .) . flip flip id . (ap .) . flip (flip . flip id)
01:29:45 <t7> @djinn \a b c e d f g -> d e a d b e e f
01:29:45 <lambdabot> Cannot parse command
01:30:04 <t7> @djinn z a b c e d f g = d e a d b e e f
01:30:04 <lambdabot> Cannot parse command
01:30:13 <merijn> t7: djinn expects a type signature, I think?
01:30:35 <merijn> @djinn a -> b -> a
01:30:36 <lambdabot> f a _ = a
01:30:38 <t7> ah yeah :P
01:30:49 <t7> :t \a b c e d f g = d e a d b e e f
01:30:50 <lambdabot> parse error on input `='
01:30:55 <t7> :t \a b c e d f g -> d e a d b e e f
01:30:56 <lambdabot>     Occurs check: cannot construct the infinite type:
01:30:56 <lambdabot>       t = t3 -> t1 -> t -> t2 -> t3 -> t3 -> t4 -> t5
01:30:56 <lambdabot>     Probable cause: `d' is applied to too many arguments
01:31:17 <earthy> @djinn a -> b -> c -> d -> e -> f -> d e a d b e e f
01:31:17 <lambdabot> Error: kind error: (KArrow (KVar 4) (KVar 6),KVar 3)
01:32:42 <zhulikas> @djinn (a -> b) -> a -> b
01:32:43 <lambdabot> f a = a
01:35:48 <earthy> @djinn a -> (a -> b -> a) -> b
01:35:49 <lambdabot> -- f cannot be realized.
01:37:03 <imc> not bad
01:37:04 <Veinor> @djinn (a -> a) -> a
01:37:04 <lambdabot> -- f cannot be realized.
01:37:07 <Veinor> aw :(
01:37:16 <imc> we had a good moment on the first inference here at work :P
01:47:31 <mgsloan> http://www.mgsloan.com/mockup5.png <-- mockup of type explanation diagrams
01:52:47 <shachaf> mgsloan == luite?
01:52:54 <zhulikas> probably :D
01:53:04 <zhulikas> or someone promoting his work
01:53:16 <mgsloan> haha, naaaah, just using luite screenshots as mockup material
01:54:08 <mgsloan> The things were working on do some similar things, so he's been helping me a bit, and I'm hoping to get stuff like this integrated into the secret project
01:54:23 <mgsloan> (after it's publication of course)
01:54:27 <mgsloan> its
01:55:49 * hackagebot haskell-src-exts 1.12.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.12.0 (NiklasBroberg)
02:22:28 * mgsloan fixes a bunch of things in mockup5, reuploads
02:33:26 <mun> anyone here familiar with model theory?
02:33:44 <mun> just a basic question: what does |= a actually say about the sentence 'a'?
02:33:53 <mun> is it that every theory is a model of 'a'?
02:34:13 <quicksilver> that symbol is used in slightly different ways
02:34:27 <quicksilver> but a typical meaning is that "every possible model is a model of a"
02:34:50 <mun> so is a a tautology then?
02:35:34 <quicksilver> tautology is normally considered to be proof theoretic, not model theoretic.
02:35:42 <quicksilver> so |- P means P is a tautology.
02:35:55 <mun> right
02:36:08 <mun> so in what context would |= a be meaningful?
02:36:10 <quicksilver> if your logic is sound and complete then these two notions coincide
02:36:29 <quicksilver> but you can discuss model theoretic notions even when you don't have soundness and/or completeness.
02:37:34 <PatrickRobotham> I thought theorems were proof theoretic and tautologies were model theoretic.
02:37:46 <PatrickRobotham> Mun: When all models have a true.
02:40:00 <mun> so what would it mean if one has: T |- a & |=/= a?
02:40:18 <mun> a is a theorem of T but every possible model is not a model of a?
02:40:30 <mun> i.e. there's no model of a?
02:40:42 <mun> so a is a theorem of T but there's no model of a?
02:57:36 <quicksilver> mun: that would mean your logic is unsound
02:57:50 <quicksilver> mun: (it can prove things which have counterexamples)
02:58:04 <quicksilver> in general we try to avoid unsoundness.
02:58:14 <quicksilver> incompleteness, however, is harder to avoid in useful systems.
02:58:28 <mun> quicksilver, could T be 'faulty' rather?
02:59:10 <quicksilver> well I took T to mean your theory.
02:59:14 <mun> yeah
02:59:19 <quicksilver> It could simply mean that T is an inconsistent set of axioms, yes.
02:59:32 <quicksilver> the logic could be sound, but from inconsistent axioms you can prove anything.
03:00:04 <mun> quicksilver, could T still be consistent and the logic is sound, but it gives false theorems?
03:00:27 <quicksilver> no
03:00:56 <mun> say, T is supposed to be a theory about natural numbers, but it has one of the axioms wrong, yet it is still consistent?
03:23:24 <t7> edwinb: why did you choose strict by default for idris ?
03:25:20 <yasar> what does ( Nothing: ) do in here: highestClose = maximum . ( Nothing: ). map closing . L.lines
03:26:05 <t7> yasar: adds Nothing to the start of a list
03:26:23 <t7> > ( Nothing: ) [Just 1, Just 2]
03:26:24 <lambdabot>   [Nothing,Just 1,Just 2]
03:26:49 <yasar> Why it is necessary in this case?
03:28:54 <t7> :t maximum
03:28:55 <lambdabot> forall a. (Ord a) => [a] -> a
03:29:04 <t7> > maximum []
03:29:05 <lambdabot>   *Exception: Prelude.maximum: empty list
03:29:15 <t7> because an empty list gives an error
03:29:35 <t7> so we add one dummy element
03:29:52 <quicksilver> conveniently, the Ord instance for Maybe makes Nothing 'smaller than everythign else'
03:30:01 <quicksilver> this trick wouldn't work for minimum though.
03:31:12 <ykm> what does Just denotes....what is its value? ....pardon me for my imperative background
03:31:32 <quicksilver> Just doesn't have a value.
03:31:44 <quicksilver> it's part of the Maybe type
03:31:47 <PatrickRobotham> Just 4 is a value
03:31:55 <quicksilver> which is a way of making an 'optional' value
03:32:15 <quicksilver> an "Int" is definitely an Int, whilst a "Maybe Int" is either an Int, or Nothing.
03:32:20 <PatrickRobotham> data Maybe a = Nothing | Just a
03:32:23 <ykm> its confusing...so its just used for defining Maybe
03:32:42 <quicksilver> it's part of the definition of Maybe
03:32:47 <quicksilver> you need to use it when you're using Maybe.
03:32:49 <PatrickRobotham> quicksilver: Incidentally, is this valid haskell?
03:32:55 <quicksilver> PatrickRobotham: Yes.
03:33:03 <PatrickRobotham> data Maybe a = Nothing | {unjust :: a}
03:33:11 <quicksilver> you missed a Just.
03:33:21 <quicksilver> Nothing | Just {unjust :: a }
03:33:22 <quicksilver> is fine.
03:33:39 <quicksilver> Nothing | Just {fromJust :: a }
03:33:43 <quicksilver> would be more consistent with the prelude ;)
03:33:45 <PatrickRobotham> Ah, cheers.
03:34:47 <Saizan> ykm: Just itself is a data-constructor, which means it simply evaluates to itself
03:35:57 <Saizan> ykm: going a bit lower-level you could think of it as a tag you can inspect to distinguish it from Nothing
03:36:40 <ktosiek> I always think of constructors of type as containers for a set number of values
03:36:58 <kallisti> any logging libraries of SUPERIOR QUALITY out there?
03:37:00 <ktosiek> so Maybe a can be Nothing with no values or Just a with one
03:37:07 <nand`> Is there some name for a flipped version of ($)?
03:37:09 <ktosiek> is this analogy off?
03:37:10 <kallisti> first one I found is called hslogger. Checking it out right now.
03:37:17 <nand`> basically f :: a -> (a -> b) -> b
03:37:19 <kallisti> nand`: flip id
03:37:23 <kallisti> :P
03:37:31 <mikkihiiri> whois kallisti
03:37:36 <mikkihiiri> oops
03:37:43 <kallisti> haha
03:37:45 <harlekin> Hello. I don't know much about CPS and CPU emulation. However, I'd like to learn both topics. Would a 6502 emulator using CPS a good way to start or are there no benefits from CPS in the control flow of a CPU emulator?
03:37:58 <Saizan> ktosiek: not so off, but seems a bit limited, since a constructor can wrap values of different types
03:38:07 <nand`> kallisti: hmm, well that isn't a name; I'm looking for something I can use with ``
03:38:12 <nand`> I guess I'll define it manually
03:38:15 <mikkihiiri> kallisti: your nick sounds like a Finnish one so wanted to check
03:38:38 <kallisti> nah it's anglicized Greek, but I'm from the States.
03:40:07 <Saizan> ktosiek: also a single type can have more than one constructor with the same arity and they would still be different
03:40:13 <mikkihiiri> "he leaned" == kallisti in english
03:41:25 <ykm> Saizan: why a seperate keyword?...isnt having a value is enough to be differentiate from Nothing?
03:41:57 <kallisti> yes, but it doesn't differentiate a value of type a from a value of type Maybe a
03:42:14 <kallisti> and it's not a keyword.
03:42:18 <ktosiek> Just _must_ carry some value, and Nothing cannot
03:42:34 <ktosiek> and it's a constructor, not keyword
03:43:31 <kallisti> ykm: one of the benefits of the Maybe type is that you get a type-safe "null", so to speak. If you could just write 2 and interpret it as a Maybe Int, then you've completely lost that benefit, and your type system now works like Java.
03:44:08 <kallisti> where almost everything can be null'd
03:46:45 <ykm> kallisti: hmm...so u mean to say in Haskell, 2  = Maybe 2
03:46:50 <kallisti> no
03:46:53 <kallisti> not at all.
03:46:55 <kallisti> 2 is just 2
03:47:00 <kallisti> Just 2 :: Maybe Int
03:47:06 <kallisti> 2 :: Int
03:47:55 <kallisti> ykm: I may have jumped the gun a bit in my explanation of Maybe
03:48:22 <kallisti> Just is a constructor, it takes a value of type a, and produces a value of type Maybe a
03:48:29 <kallisti> a is a type variable, it can stand for any type.
03:48:48 <kallisti> so if you pass it a Bool, you end up with a value of type Maybe Bool
03:48:57 <kallisti> Char gives you Maybe Char, etc.
03:48:59 <kallisti> > Just 'a'
03:49:00 <lambdabot>   Just 'a'
03:49:05 <nand`> > map (\x->case(x`mod`3,x`mod`5)of(0,0)->"fizzbuzz";(0,_)->"fizz";(_,0)->"buzz";(_,_)->show x) [0..]
03:49:06 <lambdabot>   ["fizzbuzz","1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fi...
03:49:09 <nand`> how awful is my code?
03:49:16 <kallisti> it's beautiful. :_)
03:49:32 <nand`> oh, I can cut out another byte between map and (
03:49:32 <reinoud> hi
03:49:39 <nand`> and ) [
03:49:52 <reinoud> is there a way to notate an hex number ? say like 'c's 0xf99 ?
03:50:02 <kallisti> ykm: does that make sense?
03:50:11 <reinoud> > 0x56f
03:50:12 <lambdabot>   1391
03:50:15 <reinoud> yay :)
03:50:16 <ktosiek> reinoud: like 0xf99?
03:50:19 <ktosiek> :-)
03:50:22 <reinoud> i should just have tried!!!
03:50:25 <reinoud> doh!
03:50:37 <ykm> kallisti: so 'Just a' guarantees that the value cannot be nulled like in other languages?
03:50:43 <kallisti> incorrect
03:50:49 <kallisti> it's the opposite of that
03:51:04 <kallisti> normally types do not have an implicit null value that occupies them.
03:51:10 <kallisti> Maybe is a "nullable" type
03:51:29 <kallisti> Maybe Bool literally means "okay well this /might/ be a Bool"  :P
03:51:38 <kallisti> the possible values of type Maybe Bool are:  Just True, Just False, and Nothing
03:51:50 <reinoud> @hoogle IsoSurface
03:51:52 <lambdabot> No results found
03:52:00 <reinoud> @hoogle marching cubes
03:52:00 <lambdabot> No results found
03:53:24 <kallisti> ykm: Maybe a permits the value to possibly be empty. It can be Just a value, or it can be Nothing. that's all there is to it.
03:53:38 <janua> kallisti: So Maybe and Just are related?
03:53:47 <kallisti> janua: Just is a constructor of Maybe values
03:53:49 <kallisti> :t Just
03:53:50 <lambdabot> forall a. a -> Maybe a
03:54:01 <kallisti> Nothing is also a consturctor of Maybe values
03:54:02 <kallisti> :t Nothing
03:54:03 <lambdabot> forall a. Maybe a
03:54:06 <janua> You can use type in here!?
03:54:09 <kallisti> yep.
03:54:37 <janua> I just started last week, so i will come more often! Pretty cool
03:54:38 <nand`> > [max(show$x)(concat[n|(f,n)<-[(3,"Fizz"),(5,"Buzz")],x`mod`f==0])|x<-[0..]]
03:54:39 <lambdabot>   ["FizzBuzz","1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fi...
03:54:53 <janua> Ohhh
03:55:04 <nand`> (I won't take credit for this, not mine :( )
03:55:32 <kallisti> :t Just True
03:55:32 <lambdabot> Maybe Bool
03:56:08 <mikkihiiri> if i want to recursively create a list of lists, with what kind of syntax can i close inner list and start another one?
03:56:20 <ykm> :t Just Nothing
03:56:21 <lambdabot> forall a. Maybe (Maybe a)
03:56:51 <quicksilver> > join (Just Nothing)
03:56:52 <lambdabot>   Nothing
03:56:55 <reinoud> http://www.google.nl/url?sa=t&rct=j&q=marching%20cubes%20haskell&source=web&cd=8&ved=0CF8QFjAH&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.124.1098%26rep%3Drep1%26type%3Dpdf&ei=xZtxT5eNNdCWOvvQzcwO&usg=AFQjCNEl43lJWmLEF2evQ-UlbcYqDXlGqw&cad=rja
03:56:57 <kallisti> Nothing has type "Maybe a"... meaning that it can be any kind of Maybe value
03:56:59 <reinoud> neat
03:57:08 <janua> :t maybe
03:57:09 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:58:01 <kallisti> Nothing could be a Maybe Bool, or a Maybe Char, or a Maybe Int, or a Maybe (Maybe (Maybe (Maybe [[StateT (Chan Fd) IO ()]])))
03:58:56 <kallisti> this is similar to []
03:58:59 <kallisti> :t []
03:59:00 <lambdabot> forall a. [a]
03:59:04 <kallisti> :t Nothing
03:59:05 <lambdabot> forall a. Maybe a
03:59:07 <nand`> :t Left "foo"
03:59:08 <lambdabot> forall b. Either [Char] b
03:59:19 <nand`> :t Right "bar"
03:59:20 <lambdabot> forall a. Either a [Char]
04:00:44 <janua> What is the forall a. That lambdabot says?
04:00:57 <kallisti> it's explicitly declaring the scope of the type variable.
04:01:00 <kallisti> when you write "Maybe a"
04:01:05 <kallisti> what you really mean is forall a. Maybe a
04:01:15 <kallisti> it's normally implicit. lambdabot is just making it explicit
04:01:17 <nand`> not to be confused with Maybe (forall a. a)
04:02:13 <kallisti> yes, which is only allowed via certain GHC extensions.
04:02:24 <kallisti> so for the purposes of learning you can mostly ignore the forall for now.
04:02:38 <janua> So, nothing might be something?
04:02:44 <kallisti> forall a. a  is the same thing as "a"
04:02:47 <nand`> no
04:02:49 <kallisti> er...
04:02:50 <nand`> Nothing is never something
04:02:54 <kallisti> janua: what
04:03:03 <ktosiek> janua: Nothing is a Nothing
04:03:18 <nand`> (assuming by “something” you mean “Just <something>”
04:03:52 <janua> nand`: I think so
04:04:04 <janua> :t Just
04:04:05 <lambdabot> forall a. a -> Maybe a
04:04:30 <janua> So maybe might a might be nothing? But not the other way around?
04:05:03 <nand`> pretty much, “Maybe <something>” might be Nothing
04:05:06 <nand`> @src Maybe
04:05:07 <lambdabot> data Maybe a = Nothing | Just a
04:05:13 <quicksilver> kallisti: "forall a . Maybe a" also requires an extension.
04:05:29 <quicksilver> "Maybe a" is the correct haskell way to write it.
04:05:29 <kallisti> ah, indeed.
04:05:57 <quicksilver> but it "means" forall in a clear underlying sense, certainly.
04:06:57 <nand`> in other words: free type variables in a type expression are implicitly quantified with “forall” at the outermost layer
04:14:50 <timthelion> @hoogle third
04:14:51 <lambdabot> No results found
04:14:58 <timthelion> @hoogle snd
04:14:58 <lambdabot> Prelude snd :: (a, b) -> b
04:14:58 <lambdabot> Data.Tuple snd :: (a, b) -> b
04:14:59 <lambdabot> package sndfile-enumerators
04:15:03 <timthelion> @hoogle thrd
04:15:03 <lambdabot> No results found
04:15:06 <timthelion> @hoogle trd
04:15:06 <lambdabot> Foreign.C.Types data CPtrdiff
04:15:07 <lambdabot> package astrds
04:15:12 <timthelion> :(
04:15:14 <merijn> janua: Are you familiar with C? If so, it might be helpful to think of ADTs as struct containing a int tag (constructor) and union (the possible values for each constructor), but don't take that description to literally (if you don't know C, just ignore everything I said)
04:15:32 <timthelion> @hoogle thd
04:15:33 <lambdabot> System.IO openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
04:15:33 <lambdabot> System.IO openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
04:15:33 <lambdabot> Network.HTTP.Auth AuthDigest :: String -> String -> String -> String -> Maybe Algorithm -> [URI] -> Maybe String -> [Qop] -> Authority
04:15:48 <timthelion> Is there a third function for Tuples?
04:15:54 <Axman6> no
04:16:04 <merijn> @hoogle (a, b, c) -> c
04:16:05 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
04:16:05 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
04:16:21 <merijn> Hmm, maybe Hayoo will find something in a user lib for that
04:16:50 <timthelion> > (\(x,y,z) -> z) (1,2,3)
04:16:51 <lambdabot>   3
04:16:58 <timthelion> It's not so bad.
04:17:03 <timthelion> I'll suvive.
04:17:18 <kallisti> hmmm, hslogger apparently doesn't have a good rotating log handler.
04:18:18 <kallisti> perhaps I'll submit a patch for one later.
04:24:46 <janua> merijn: Thanks! I am familiar with C, but not entirely as i don't know unions
04:27:53 <merijn> janua: "union { int foo; double bar; }" is a piece of memory big enough to hold max(sizeof(int),sizeof(double)), i.e. you can use x.foo to access an int or x.bar to access a double. But unlike a struct they can't be both set at the same time.
04:28:36 <janua> merijn: I see, what happens if you try to set the other when the other is set?
04:28:43 <merijn> Data corruption
04:28:47 <merijn> They're the same memory area
04:28:55 <janua> Ah i see, you have to control it yourself.... Ah C !
04:29:04 <merijn> So you normally use an int tag (the constructor!) to check which is set
04:29:09 <elliott> (you usually bundle it with an enum to say which is set)
04:29:10 <elliott> right
04:29:26 <ciaranm> i've got an algorithm that can be parameterised by various heuristics (e.g. it can try sorting subsets of one of its inputs in various ways, or just leave them unordered). i need to run it a bunch of times with different combinations of heuristics on different data. what's the best way to handle that? pass the heuristics in as inputs, or do something clever with typeclasses?
04:29:38 <quicksilver> or you bundle it with a lucky rabbit's foot
04:29:53 <quicksilver> which guarantees that whenever you access the memory you, luckily, access it as the right type.
04:29:55 <Axman6> so, Either String Int might be thout of as something like struct { int tag; union {char * left; int right}}
04:30:05 <merijn> janua: Of course in GHC the compiler checks all that mess for you. So you just specify "number of alternatives" (constructors) and "content" (the data stored along side that constructor)
04:30:10 <quicksilver> haskell supplies such a lucky rabbit's foot for you - it's called the type-checker! woo!.
04:30:17 <quicksilver> ciaranm: inputs.
04:30:25 <quicksilver> ciaranm: "something clever with typeclasses" is never the right answer.
04:30:33 <ciaranm> no fun :(
04:30:39 <elliott> quicksilver: uh
04:30:53 <elliott> quicksilver: haskell does not eliminate the constructor tag of ADTs
04:30:53 <u_quark> hello ilias
04:31:12 <elliott> well
04:31:20 <elliott> s/haskell/ghc/ (oops)
04:31:25 <elliott> and i know that isn't, or at least didn't use to be, strictly true
04:31:32 <elliott> but it can't magically make a plain union work, anyway :)
04:31:53 <reinoud> ugh.. that paper has a strong instruction of different thinking into Haskell... ugh, its been long since i worked purely functional i notice!
04:32:18 <ciaranm> lines of pseudocode in the paper: 40. lines of java code in the reference implementation: 800. lines of haskell: 6. this is fun.
04:32:35 <merijn> elliott: Well, yes. But you don't need to manually check the tag with haskell
04:33:07 <ClaudiusMaximus> the thing haskell does is prevent you ignoring the tag and getting garbage
04:33:15 <ciaranm> also the haskell code runs faster without heuristics than the java one does with the clever stuff. i didn't realise haskell was supposed to be *that* fast...
04:33:17 <elliott> merijn: that's true
04:33:38 <merijn> ciaranm: Which paper is this?
04:33:50 <elliott> ciaranm: are you sure the problem size isn't missing a 0 or so :)
04:34:06 <elliott> (of course, it's entirely possible you got lucky :P)
04:34:15 <ciaranm> merijn: something something maximal clique that my supervisor has scribbled all over
04:34:16 <quicksilver> elliott: I was, mostly, being flippant.
04:34:39 <quicksilver> elliott: however the sense in which it's actually true is that there is no tag bit distinguishing a "Maybe Int" from a "[Char]"
04:34:48 <ciaranm> elliott: heh. it's NP something or other, so missing a 0 would probably add a week to the runtime...
04:34:58 <quicksilver> elliott: you can view the representation of generic heap objects as being an untagged union.
04:35:01 <elliott> quicksilver: true... but that applies in C too
04:35:09 <quicksilver> elliott: and that's the part which the type checker gets right for you.
04:35:12 <quicksilver> elliott: indeed.
04:35:13 <elliott> or do C programmers write most programs with a single union type of every type they use these days? :)
04:35:18 <elliott> that would be fun
04:35:32 <companion_cube> elliott: that's called void*
04:35:39 <merijn> elliott: Well, it's been a few weeks since I last committed something atrocious to our repo...
04:35:45 <ciaranm> oh, no, the java code's just really really really stupid.
04:36:05 <merijn> companion_cube: Nothing wrong with sticking everything in void* :>
04:36:24 <elliott> companion_cube: no! that has pointer overhead
04:36:32 <elliott> C needs a union type which just contains every possible type
04:36:37 <elliott> and is therefore as big as the biggest object possible
04:36:43 <merijn> Not if you cast your stuff directly to void* and hope it fits
04:37:02 <merijn> "(void*) 125L" *cross fingers*
04:38:02 <elliott> (void *) huge_struct
04:38:22 <companion_cube> elliott: but the biggest object possible is as large as memory :)
04:38:46 <ciaranm> companion_cube: technically not quite
04:39:16 <ciaranm> there's got to be a hole somewhere for NULL
04:39:22 <companion_cube> struct { char[0] foo; };  ← I think that can be as big as you ant?
04:39:27 <companion_cube> want*
04:39:36 <ciaranm> not actually legal!
04:39:50 <merijn> There's probably a max struct size defined somewhere in the spec
04:40:01 <merijn> But I'm to lazy to check
04:40:05 <elliott> <companion_cube> elliott: but the biggest object possible is as large as memory :)
04:40:07 <elliott> companion_cube: not necessarily!
04:40:15 <elliott> I don't think a compiler is required to support objects up to that size
04:40:15 <companion_cube> char foo[0];  sorry
04:40:25 <elliott> and there's nothing stopping it supporting objects larger than memory
04:40:30 <elliott> (they're just not very useful)
04:40:36 <companion_cube> yes, also
04:40:40 <elliott> companion_cube: char foo[0] isn't legal either
04:40:50 <ciaranm> the [0] thing is an extension that everyone supports
04:40:52 <elliott> char foo[1] is, but you're still not allowed to over-allocate and poke the "rest" of the elements
04:40:55 <companion_cube> in practice, you can still malloc() a very big block and cast it into such a structure
04:40:56 <elliott> it's undefined behaviour, even if it works everywhere
04:41:04 <elliott> char foo[] *is* ok to do that with, in C99
04:41:21 <companion_cube> elliott: char foo[0] is valid C
04:41:35 <ciaranm> companion_cube: no, it's supported by your compiler. not the same thing.
04:41:36 <elliott> no
04:42:12 <yasar> what does it mean if a function is strict or not?
04:42:15 <companion_cube> hmm, I thought that was the same thing... my mistake
04:42:27 <ciaranm> C is defined in ISO something or other
04:42:31 <elliott> yasar: a function f is strict if f _|_ = _|_
04:42:43 <elliott> yasar: _|_ is "bottom", it's an error on nontermination
04:42:47 <ciaranm> your compiler supports C with a bunch of extensions and probably some stuff missing
04:42:52 <elliott> like undefined, error "help", or an infinite loop
04:42:58 <elliott> yasar: basically, a strict function evaluates its argument
04:43:17 <elliott> > const 1 (error "abc") -- const isn't strict in its second argument
04:43:18 <lambdabot>   1
04:43:24 <elliott> > const undefined 42 -- but it's strict in its first
04:43:25 <lambdabot>   *Exception: Prelude.undefined
04:43:36 <yasar> elliott: I am kind of newbie, I couldn't follow.
04:44:04 <ciaranm> yasar: whoever told you that there were four functions Bool -> Bool is a liar
04:44:09 <companion_cube> I'm a bit surprised that no warning is raised on the char[0] stuff, though
04:44:19 <elliott> yasar: well, it's hard to help without knowing how much you know
04:44:19 <merijn> companion_cube: Hah
04:44:27 <elliott> companion_cube: -std=c89 -pedantic might.
04:44:34 <companion_cube> I code in C99...
04:44:51 <ciaranm> in C99 you want to use [] not [0]
04:44:59 <merijn> companion_cube: So use -std=c99 -pedantic :p
04:45:01 <companion_cube> but -pedantic works, indeed
04:45:11 <yasar> elliott: I am on chapter 8 on real world haskell, and chapter 7 on learn you a haskell. I am parrallel tutorialing :)
04:45:21 <companion_cube> -Wall, Y U suck? :/
04:45:26 <ClaudiusMaximus> -Wall -Wextra -Wno-unused-parameter
04:45:30 <merijn> companion_square: For extra points and amazement, try to compile your program using ICC or the Sun compiler
04:45:41 <elliott> yasar: well, you know how haskell is lazy?
04:45:49 <elliott> yasar: values aren't evaluated until they _need_ to be
04:45:51 <ciaranm> for extra extra points, try to write any C program that doesn't give warnings with ICC with -W -Wall
04:45:53 <yasar> elliott: yes.
04:45:54 <yitz> ciaranm: so you want to say that there are nine such functions, since the type Bool has three members including bottom?
04:46:00 <elliott> yasar: a strict function is one which *does* evaluate its argument
04:46:00 <merijn> err, s/companion_square/companion_cube
04:46:12 <ciaranm> yitz: nine? try again!
04:46:19 <elliott> > let ignore x = 42 in ignore (error "hello")
04:46:20 <lambdabot>   42
04:46:24 <elliott> yasar: so, ignore here doesn't evaluate its argument, it just ignores it
04:46:33 <elliott> > let don'tignore x = x + 1 in don'tignore 123
04:46:34 <lambdabot>   124
04:46:42 <elliott> yasar: but don'tignore _does_ evaluate its argument, to add one to it
04:46:48 <merijn> ciaranm: I know, trying to use ICC -W -Wall on open source code made me cry...
04:46:50 <elliott> so we say that don'tignore is strict, and ignore isn't
04:47:14 <yitz> ciaranm: i don't know how you are counting. i say either four, nine, or infinitely many, depending on whether you pay attention to bottom and whether you distinguish bottoms.
04:48:01 <elliott> yasar: does that help?
04:48:13 <yasar> elliott: I guess I get it.
04:48:23 <ciaranm> yitz: how would you write f = { _|_ |-> true, false |-> false, true |-> false} ?
04:49:00 <yitz> ciaranm: ah i see ok
04:49:01 <elliott> yasar: good enough :P
04:49:13 <elliott> ciaranm: ehhhh... that's not a good function
04:49:23 <Jerrie> hye guys :)
04:49:23 <ciaranm> elliott: that's my point!
04:49:31 <elliott> oh, I see
04:49:43 <ciaranm> elliott: the question was how many functions Bool -> Bool there are
04:49:55 <elliott> ciaranm: right, you're saying that non-monotonic functions aren't functions, rather than the other way around
04:49:59 <elliott> we're in agreement, then
04:50:27 <LOL___> lol
04:50:30 <LOL___> Hey guys
04:50:32 <elliott> ciaranm: (p.s. such a function would be very useful)
04:50:35 <LOL___> :)
04:50:43 <quicksilver> elliott: there is no spoon!
04:50:45 <LOL___> I'M IN CLASS! :D
04:51:00 <elliott> i'm in #haskell
04:51:01 <LOL___> Y DOES NOONE SAY  HI? :(
04:51:05 <mux> i don't care
04:51:06 <ciaranm> elliott: it'd let you solve the halting problem, wouldn't it?
04:51:09 <elliott> LOL___: do you have a question
04:51:09 <LOL___> :o
04:51:11 <Jerrie> lol elliott :D
04:51:19 <elliott> ciaranm: exactly!
04:51:19 <LOL___> yes
04:51:27 <elliott> we could solve so many pesky conjectures
04:51:52 <LOL___> HOW BOUT U STFU AND LISTEN TO ME
04:51:55 <LOL___> THIS IS A ROBBERY
04:51:57 <elliott> @where ops
04:51:57 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:51:59 <LOL___> GIVE MY MONEY
04:52:00 <LOL___> NOW
04:52:01 <AfC> LOL___: You're aware this is a public IRC channel with hundreds of people around the world? Do you have something related to Haskell to discuss?
04:52:04 --- mode: ChanServ set +o dcoutts
04:52:06 --- mode: ChanServ set +o quicksilver
04:52:10 <elliott> race!
04:52:11 --- mode: dcoutts set +b *!*54c3b2a8@gateway/web/freenode/ip.84.195.178.168
04:52:11 --- kick: LOL___ was kicked by dcoutts (LOL___)
04:52:18 <mux> dcoutts wins that one
04:52:19 <elliott> dcoutts wins
04:52:23 <dcoutts> woo!
04:52:29 <quicksilver> I was waiting to see if he answered afc
04:52:30 <elliott> better luck next time, quicksilver
04:52:41 * dcoutts is never sure if he's using the right kind of kickban however
04:52:49 <quicksilver> I'd have beaten dcoutts by quite a lot if I was in a hurry ;)
04:52:50 <mux> you're not
04:52:57 <mux> but it doesn't matter much I think :-)
04:53:11 <dcoutts> mux: corrections welcome
04:53:13 <AfC> quicksilver: damn, sorry, didn't mean to sabotage you :)
04:53:21 <elliott> i think that might block large portions of LOL__'s school
04:53:27 <elliott> assuming they were telling the truth
04:53:29 <quicksilver> > showHex 84 ""
04:53:30 <lambdabot>   "54"
04:53:33 <elliott> but that might be for the best :P
04:53:42 <mux> dcoutts: <nick>!<ident>@<host> and the "ident" part you match against allows many variations, so he could just change that and come back
04:53:56 <quicksilver> I wonder why freenode web gateways encodes the IP address twice
04:54:05 <quicksilver> mux: well, he's a clueless lab student using an IRC gateway on the web.
04:54:13 <quicksilver> mux: it's not all that likely he knows how to change his IP address.
04:54:17 <t7> my god, I thought you had to be clever to get into uni/college :P
04:54:20 <elliott> mux: * Jerrie (54c3b2a8@gateway/web/freenode/ip.84.195.178.168) has left #haskell
04:54:21 <mux> quicksilver: no argument there, I was answering dcoutts' question
04:54:30 <mux> elliott: and?
04:54:32 <merijn> t7: Hah! Clearly you never went to university then...
04:54:33 <dcoutts> mux: thanks
04:54:34 <elliott> mux: well, the webirc client doesn't let you change that
04:54:44 * dcoutts tries to work out again how to configure xchat
04:54:45 <quicksilver> and dcoutts banned that whole IP (in the context of freenode's webirc in particular, only)
04:54:49 <mux> the ident? are you sure it's not just random?
04:54:51 <elliott> so it's perfectly OK, since that ban only covers the web gateway
04:54:56 <quicksilver> the identy is the IP address again
04:54:58 <elliott> mux: * LOL___ (54c3b2a8@gateway/web/freenode/ip.84.195.178.168) has joined #haskell
04:55:00 <elliott> mux: * Jerrie (54c3b2a8@gateway/web/freenode/ip.84.195.178.168) has left #haskell
04:55:08 <elliott> it's a hash of the IP, I think.
04:55:15 <mux> that could well be it indeed
04:55:23 <elliott> anyway, problem solved
04:55:37 <quicksilver> 54c3b2a8 isn't a hash of the IP. It *is* the IP.
04:55:57 <quicksilver> > map (flip showHex "") [84,195,178,168]
04:56:01 <lambdabot>   mueval-core: Time limit exceeded
04:56:07 <elliott> quicksilver: that just means it's using a very trivial hash function
04:56:08 * quicksilver blinks
04:56:09 <quicksilver> > map (flip showHex "") [84,195,178,168]
04:56:11 <lambdabot>   ["54","c3","b2","a8"]
04:56:13 <elliott> but apparently one too computationally-expensive for lambdabot to reverse
04:56:15 <quicksilver> elliott: :P
04:56:45 <mux> I suppose he could still change his ident though; by registering a nickname; it'd get a ~ prepended to it IIRC
04:56:52 <mux> not that it matters, but all this got me thinking
04:57:21 <quicksilver> I don't think I've ever banned anyone from #haskell who attempted to get aorund the ban.
04:57:31 <yitz> (trembling) quicksilver, dcoutts, y-you d-don't n-need t-to b-be op anym-more
04:57:37 <quicksilver> they have almost all been trivial/boring spammers.
04:57:39 <t7> third attempt at implementing unification from wikipedia article... here we go
04:57:47 --- mode: ChanServ set -o dcoutts
04:58:05 <dcoutts> mux: hmm, so if we use a specific nick then they just come back with a new nick
04:58:13 <mux> put the shotguns back in the closter, he's gone ;-)
04:58:16 <mux> closet*
04:58:21 <mux> dcoutts: yeah
04:58:33 <elliott> quicksilver needs to stay op so we learn to fear him, even when he's not doling out the bans
04:58:37 <mux> no matter what you do they are ways to work around a ban
04:58:43 <mux> unless he has absolutely no other host to use
04:58:55 <elliott> but yeah, the solution is just to do whatever ban is easiest and then keep banning them until they get bored if they come back
04:58:56 <yitz> mux: hack another host
04:59:09 <mux> yitz: fair point
04:59:19 <ktosiek> and Tor
04:59:21 <mux> it might even be faster than changing one's nickname these days
04:59:22 <reinoud> can someone please help me to download this code: http://hackage.haskell.org/trac/PolyFunViz/wiki/IEEEVisCode ?
04:59:23 <mux> :D
04:59:27 <reinoud> i can't seem to find it
04:59:45 <elliott> how to evade an irc ban: abandon your current identity. move to a new country. start a new life. purchase an internet connection. connect to IRC and join the channel
05:00:08 <yitz> elliott: in other words, sign up for a new facebook account
05:00:09 <imc> elliott: a little drastic...
05:00:16 <elliott> yitz: :D
05:05:50 <_mpu> In this sentence "then assertions like C [a] can be neither reduced nor rejected"
05:05:51 <tech2> elliott: there's only ~200 countries though, what then?
05:06:02 <t7> how do i unify a construct?
05:06:04 <_mpu> what does "reduced" and "rejected" mean.
05:06:23 <t7> unify the first part, then apply the sub to the econd part and unify
05:06:30 <t7> and combine the two subs?
05:06:31 <_mpu> s/does/do/
05:06:54 <merijn> tech2: Wolfram|Alpha says 204 official countries according to the Montevideo Convention :p
05:07:36 <tech2> merijn: I was accurate to within 2%, that's good enough for me. :)
05:07:43 <elliott> tech2: well you have to rise to a position of power
05:07:52 <elliott> tech2: and start a brutal civil war
05:08:02 <elliott> eventually splitting off into a new, internationally-recognised country
05:08:09 <elliott> then, you just do the process, skipping step two
05:08:22 <elliott> i guarantee success
05:08:27 <tech2> elliott: ooooh, Or subdivide Antartica into multiple warring nation-states, and then move to my secret moon-base?
05:08:42 <elliott> tech2: that works, but be aware that the latency from the moon is not ideal.
05:08:52 <tech2> Damn, not so secret any more either :(
05:08:56 <elliott> and the copper wire tends to break.
05:09:14 <quicksilver> _mpu: context might help, but "reduced" probably means "simplified by applying rewrite rules" and "rejected" means "found to be impossible/inconsistent"
05:09:20 --- mode: quicksilver set -o quicksilver
05:10:23 <_mpu> quicksilver, I found this on the page dealing with the FlexibleInstances extension of ghc.
05:11:20 <elliott> I believe reduced would be finding an instance for C [a] that has some other requirements
05:11:24 <elliott> like (Num a), say
05:11:30 <elliott> which would reduce (C [a]) to (Num a)... but I'm not certain about this
05:11:41 <elliott> if I'm right, then rejected would be finding there's no instance
05:12:30 <t7> @hoogle (a -> a) -> [a] -> [a]
05:12:30 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
05:12:30 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
05:12:31 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
05:13:29 <reinoud> > 0x34f & f
05:13:30 <lambdabot>   Not in scope: `&'
05:13:43 <reinoud> @hoogle binary and
05:13:44 <lambdabot> No results found
05:14:01 <reinoud> @hoogle binary
05:14:02 <lambdabot> package binary
05:14:02 <lambdabot> package binary-bits
05:14:02 <lambdabot> package binary-communicator
05:14:07 <elliott> (.&.)
05:14:10 <elliott> from Data.Bits
05:14:22 <elliott>  @hoogle can't search descriptions, btw ;)
05:14:28 <elliott> @hoogle Int -> Int -> Int
05:14:28 <lambdabot> Test.QuickCheck.State computeSize :: State -> Int -> Int -> Int
05:14:28 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
05:14:28 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
05:14:30 <elliott> ha!
05:14:31 <reinoud> > 0x34f (.&.) 4
05:14:32 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:14:32 <lambdabot>    `Data.Bits.Bits a'
05:14:32 <lambdabot>      a...
05:14:35 <reinoud> :)
05:14:35 <elliott> I wasn't expecting it to get that
05:14:41 <elliott> why (.&.) and not (+), I wonder
05:14:50 <elliott> reinoud: (op) is how you name a binary operator
05:14:54 <elliott> > (+) 2 2
05:14:55 <lambdabot>   4
05:14:56 <elliott> > 2 + 2
05:14:57 <lambdabot>   4
05:14:57 <aristid> > 0x34f .&. 4
05:14:58 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:14:58 <lambdabot>    `Data.Bits.Bits a'
05:14:58 <elliott> :t (+)
05:14:58 <lambdabot>      a...
05:14:59 <lambdabot> forall a. (Num a) => a -> a -> a
05:15:00 <merijn> elliott: + is not Int, but Num a
05:15:06 <elliott> merijn: (.&.) is not Int, but Bits a
05:15:08 <aristid> > 2 (+) 2
05:15:09 <lambdabot>   2
05:15:12 <aristid> :D
05:15:20 <elliott> reinoud: ignore aristid, lambdabot has some weird... "quirks"
05:15:21 <merijn> elliott: You're right, I'm silly :(
05:15:42 <reinoud> this `porting' is going to be a challenge :)
05:15:45 <elliott> merijn: I guess Hoogle might exclude ubiquitous things like (+)
05:15:48 <aristid> elliott: yeah... we can't call it caleskell unfortunately, because Cale doesn't like that :D
05:15:55 <_mpu> elliott, thanks
05:15:58 <elliott> reinoud: ah... what language is the code you are trying to port in?
05:16:05 <reinoud> C
05:16:06 <elliott> reinoud: porting code to Haskell is usually a bad way to learn it, since it's so different
05:16:08 <elliott> yikes
05:16:10 <reinoud> to haskell
05:16:20 <elliott> I would gently suggest you find another project if you're new to the language
05:16:26 <ciaranm> > let 2 + 2 = 5 in 2 + 2
05:16:27 <lambdabot>   5
05:16:30 <elliott> or you'll just end up writing C in Haskell, and it'll be painful and ugly :)
05:16:44 <merijn> elliott: And probably slow
05:16:47 <reinoud> i got a nice marching cube algorithm in Haskell, but i can't seem to download it
05:17:02 <reinoud> http://hackage.haskell.org/trac/PolyFunViz/wiki
05:17:26 <reinoud> i could copy and paste from the paper, but the code is most likely not complete
05:17:48 <elliott> "This trac website is mainly for internal use of the project members. See  our official website for a more visitor-friendly experience." -> "The page you were looking for could not be found."
05:17:49 <elliott> heh
05:18:17 <ClaudiusMaximus> last modified 4 years ago - best bet would be to try to contact the authors?
05:18:21 <reinoud> its a 2006 project
05:18:24 <reinoud> i guess so :(
05:19:12 <t7> apply ss t = case ss of [] -> t; (s:ss) -> apply ss (go s t)       -- am i missing a prelude function here?
05:20:01 <ciaranm> t7: you're missing a go
05:20:15 <t7> yeah but i could pass that in
05:20:24 <t7> apply ss t go =
05:20:37 <t7> like iterate but finite
05:23:00 <elliott> :t fix (\apply ss t go -> case ss of [] -> t; s:ss' -> apply ss' (go s t))
05:23:01 <lambdabot>     Occurs check: cannot construct the infinite type:
05:23:01 <lambdabot>       t = (t1 -> t -> t) -> t
05:23:01 <lambdabot>     Probable cause: `apply' is applied to too few arguments
05:23:05 <elliott> :t fix (\apply ss t go -> case ss of [] -> t; s:ss' -> apply ss' (go s t) go)
05:23:06 <lambdabot> forall t t1. [t1] -> t -> (t1 -> t -> t) -> t
05:23:15 <elliott> :t foldr
05:23:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:23:20 <elliott> or is it foldl
05:23:22 <elliott> :t foldl
05:23:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:23:31 <elliott> t7: pretty sure it'd foldl
05:23:33 <elliott> *it's
05:23:40 <elliott> in which case you probably really want foldl'
05:24:11 <reinoud> sent mail, i hope it will come soonish
05:29:39 <reinoud> Colin Runciman?
05:32:53 <reinoud> colah?
05:52:03 <alexey> hi
05:57:10 <Jonno_FTW> hello
05:59:00 <t7> bitonic:
05:59:02 <t7> you there?
05:59:51 <yasar> Why is function compositing is called point free form? Any special reason?
06:00:02 <elliott> yasar: point = named variable
06:00:07 <quicksilver> it isn't, yasar
06:00:07 <elliott> point-free style has no points
06:00:16 <quicksilver> but specifying functions without naming their parameters is
06:00:19 <elliott> well, function composition itself isn't called point-free style
06:00:22 <quicksilver> (\x -> x) --- 'x' is the point
06:00:26 <quicksilver> id -- no points here.
06:00:27 <elliott> but point-free style is function composition style :P
06:00:30 <bitonic> t7: yes
06:00:59 <quicksilver> not necessarily. point-free style is the composition of combinators.
06:01:07 <quicksilver> (.) is just a particularly common combinator.
06:01:23 <quicksilver> liftM (+1) -- this is point free, no composition here.
06:01:59 <elliott> quicksilver: well, thus "style"
06:02:37 <quicksilver> elliott: it's a silly thing to argue about, but I don't agree.
06:02:54 <quicksilver> (\x -> map toUpper x) . reverse . take 5
06:03:04 <quicksilver> ^^ that's function composition style
06:03:07 <quicksilver> but it isn't point-free.
06:04:02 <elliott> well, ok.
06:12:53 <t7> bitonic: your inference code is a bit hard to read, so many monads
06:13:36 <bitonic> t7: really? it's just one monad
06:14:13 <t7> bitonic: what state do i need to pass around?
06:14:17 <t7> free variables
06:14:42 <t7> do i need to pass context, i mean do i unify inside?
06:15:09 <t7> i mean next free variable ofcourse
06:16:02 <bitonic> t7: just a sec
06:21:40 <bitonic> t7: well the only state I have in my monad is a list of integers to generate fresh variables
06:22:54 <bitonic> the context is a function argument
06:23:01 <bitonic> ([Assump])
06:23:43 <Ornedan> I'm trying to make a trie with parent references (dictionary for random text generation from dictionary decompression), but what I've got so far is fairly ridiculously inefficient: http://hpaste.org/66063
06:24:02 <Ornedan> Loading pizza & chilli 50Mb runs out of stack space
06:24:41 <elliott> Ornedan: I haven't looked at your code, but beware of "parent" pointers in functional data structures.
06:24:59 <elliott> They cause lots of problems, basically you have to completely rewrite the whole structure whenever you change anything... look into zippers.
06:25:08 <elliott> http://en.wikibooks.org/wiki/Haskell/Zippers
06:27:16 <t7> @hoogle (a, b, c) -> b
06:27:16 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
06:27:16 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
06:27:37 <elliott> \(_,b,_) -> b
06:27:49 <elliott> it's nowhere standard
06:27:53 <elliott> most people call it fst3.
06:27:56 <elliott> i call it "don't use three-tuples"
06:28:21 <dylukes> augur: as to your john/susan thing last night, there's a more fundamental reason.
06:28:26 <t7> maybe when you start writing big boy programs...
06:28:32 <dylukes> "John saw Susan before leaving the party"
06:28:43 <dylukes> If we wanted to shift who was leaving, it would become
06:28:57 <dylukes> "John saw Susan before she left the part"
06:29:01 <dylukes> which is the same as
06:29:09 <dylukes> "John saw Susan before Susan left the party."
06:29:41 <dylukes> why is that? because "John saw Susan" is the important part of the sentence. "before" is linking to another phrase entirely.
06:29:59 <elliott> t7: three-tuples aren't worth the fuss for toy programs.
06:30:21 <dylukes> "before leaving the party" implies John, since John is implicitly both the subject and the topic of the sentence.
06:30:52 <dylukes> "before (she) left the party" denotes Susan explicitly, since she's not the topic or subject of the sentence. She has to be denoted explicitly.
06:41:00 <tromp__> > [2..]
06:41:01 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
06:42:17 <gnoi> How many days should I wait for Hackage account?
06:42:51 <elliott> gnoi: not many
06:43:09 <elliott> i got my account in less than 10 minutes, some people have to wait a few days
06:43:10 <tromp__> > nubBy(((>1).).gcd)[2..]
06:43:12 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
06:43:15 <elliott> probably send another email off if it's been a week or something
06:43:36 <bitonic> gnoi: or you can just wait for hackage 2
06:44:35 <Entroacceptor> I compiled gitit on a computer, and copied to another one. Now if I start gitit, I always get "no such file or directory"
06:44:44 <elliott> bitonic: that will result in a wait considerably longer than any account creation delay.
06:45:01 <_mpu> Entroacceptor, probably because of the copy.
06:45:08 <_mpu> Entroacceptor, you should recompile it.
06:45:14 <elliott> Entroacceptor: ldd gitit -- it's probably trying to link with a library you don't have.
06:45:18 <Entroacceptor> I can't, not enough ram
06:45:19 <elliott> you could statically link it on the original computer.
06:45:47 <_mpu> elliott, sounds more like a binary incompatibility, no?
06:46:06 <Entroacceptor> ldd looks fine
06:46:12 <elliott> _mpu: perhaps
06:46:20 <elliott> Entroacceptor: they are the same architecture?
06:46:32 <elliott> if x86, both 32-bit or both 64-bit?
06:46:36 <Entroacceptor> elliott: yes, of course. I did this before
06:46:39 <Entroacceptor> both 64bit
06:46:42 <elliott> anyway, hpaste the exact error you get when running gitit
06:46:51 <elliott> or just paste it here if it's one line
06:46:53 <Entroacceptor> bash: /home/mad/bin/gitit: No such file or directory
06:47:08 <elliott> right
06:47:14 <Entroacceptor> file -i `which gitit` gives /home/mad/bin/gitit: application/x-executable; charset=binary
06:47:18 <elliott> well... hpaste the ldd output
06:47:37 <elliott> that "no such file or directory" is common when e.g. running 32-bit programs on 64-bit
06:47:58 <_mpu> Entroacceptor, you could run "file" on it and compare with an executable known to work on this computer.
06:48:05 <bitonic> elliott: what? I hear the hackage 2 team is great!
06:48:13 <hpaste> entro pasted “gitit” at http://hpaste.org/66065
06:48:43 <elliott> bitonic: the codebase isn't ready for prime-time yet
06:48:48 <elliott> that's nothing to do with the people working on it
06:49:00 <bitonic> yeah yeah, I'm just joking
06:49:18 <Entroacceptor> _mpu: it's the same
06:49:24 <Entroacceptor> ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, stripped
06:49:24 <elliott> Entroacceptor: oh well, --ghc-options="-optl-static -optl-pthread" on the host.
06:49:32 <elliott> that might help. or might not. who knows.
06:49:36 <Entroacceptor> elliott: thanks, I'll try
06:51:10 <Entroacceptor> I would compile it here, but compiling pandoc eats up too much RAM
06:51:26 <Entroacceptor> but it's time to upgrade, anyway
06:58:00 <Guest81924> hi, guys!
06:58:08 <c4th0d3r4y> ls
06:58:14 <c4th0d3r4y> how are you doing?
06:58:50 <Senmorta> hi
07:03:06 <Luke> Cale: in the forkIO + MVar example you were helping me with yesterday, would I need an MVar per fork?
07:03:14 <Luke> Cale: then map a take across the MVars?
07:10:53 <roconnor> @type (|||)
07:10:54 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
07:11:03 <roconnor> @type (***)
07:11:04 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:12:20 <roconnor> dibblego: you should hide Control.Comonad.StaredStore as well.
07:14:18 <Philonous> I'm trying to build the source distribution of a package, but "cabal sdist" fails with "cabal: dist/src/sdist.-7751/xml-types-pickle-0.1: does not exist". What am I doing wrong?
07:16:09 <roconnor> dibblego: another very very minor quibble.  I don't like the Control.Arrow dependency.  I'd prefer to write an auxillary helper function: second :: (a -> b) -> (c,a) -> (c,b) at the end of each file that uses it.  I know, I know, this quibble isn't entirely rational of me.  I just hate dependency bloat.
07:16:47 <roconnor> dibblego: maybe I'm being too insane, maybe using Control.Arrow is fine ...
07:17:11 <elliott> depend on bifunctors instead ;)
07:17:25 <elliott> roconnor: (but calling something in base a "dependency" is weird...)
07:17:37 <roconnor> elliott: isn't base a GHCism?
07:18:05 <roconnor> elliott: isn't base an arbitrary set of packages whose sole purpose is to build GHC and could change at any point in time?
07:18:12 <roconnor> maybe I'm mistaken.
07:19:16 <elliott> roconnor: well, it has ifdefs for Hugs and NHC, although I don't think it actually builds on anything other than GHC any more
07:19:20 <elliott> but I believe Control.Arrow is in jhc's base too
07:19:28 <elliott> roconnor: but GHC has dependencies beyond base
07:19:37 <elliott> so "whose sole purpose is to build GHC" is wrong
07:19:41 <roconnor> oh okay
07:19:45 <roconnor> so what about UHC?
07:19:51 <elliott> that's the boot packages as a whole, of which base is one
07:19:56 <roconnor> ah
07:19:56 <elliott> roconnor: dunno about UHC, sorry
07:20:16 <elliott> http://hackage.haskell.org/trac/ghc/browser/packages -- boot packages are those with a tag of -
07:20:31 <elliott> apparently GHC depends on xhtml!
07:20:42 <elliott> i guess because haddock uses it
07:20:44 <bitonic> is UHC still developed? the last release is in 2010...
07:21:33 <roconnor> dibblego: Okay, I take it back, Control.Arrow can stay.
07:23:05 <Elemir> bitonic: Hem?
07:23:10 <Elemir> http://www.cs.uu.nl/wiki/bin/view/UHC/WebHome
07:23:23 <Elemir> -> 2012 01 31 Version 1.1.3
07:23:34 <Elemir> > 2012 == 2010
07:23:35 <lambdabot>   False
07:24:42 <roconnor> dibblego: also, move the instances of Product and Choice and Codiagonal to their Data.Lens.Common and Data.Lens.Parital.Common respectively.
07:24:43 <bitonic> Elemir: ok. the "Release History" page is outdated.
07:25:21 <reinoud> oops ... one of the authors of that marching cube algorithm has lost the source, hopefully the others know
07:25:51 <roconnor> preflex: what time is it for dibblego?
07:28:23 <elliott> preflex speaks english?
07:28:39 <roconnor> preflex: time dibblego
07:28:45 <roconnor> preflex: help
07:28:45 <preflex>  try 'help help' or see 'list' for available commands
07:29:01 <Elemir> vithos: But uhc is a research compile, it can't rival ghc
07:29:05 <elliott> @time dibblego
07:29:07 <lambdabot> Local time for dibblego is Wed Mar 28 00:28:44
07:29:08 <Elemir> Argh
07:29:12 <Elemir> * bitonic
07:29:22 <roconnor> elliott: ah, thanks.
07:29:40 <elliott> np
07:29:42 <bitonic> Elemir: well, last time I checked it had most of GHC extensions
07:29:55 <bitonic> Elemir: jhc is one man's work and has a lot of extensions as well!
07:30:25 <reinoud> @time colah
07:30:27 <lambdabot> Local time for colah is Tue Mar 27 10:27:05 2012
07:30:47 <reinoud> ah, so he might just not be awake yet ;) its pre-coffee!
07:30:50 <elliott> @time lambdabot
07:30:50 <lambdabot> I live on the internet, do you expect me to have a local time?
07:31:00 <bitonic> @time rostayob
07:31:04 <bitonic> uff
07:31:07 <bitonic> @time bitonic
07:31:09 <lambdabot> Local time for bitonic is Tue Mar 27 15:30:46 2012
07:31:17 <Elemir> Of cause. Implementation of type systems is a interesting task, but not difficult for tru computer scientist.
07:31:45 <Elemir> 90% of compiler-writing work is a optimisations
07:32:02 <Elemir> s/a//
07:32:18 <roconnor> @type null
07:32:19 <lambdabot> forall a. [a] -> Bool
07:32:41 <tech2> Elemir: that kind of thought is what lead us to C++ :P
07:33:34 <t7> bitonic: holy crap my type inference works
07:33:40 <ClaudiusMaximus> reinoud: you might like http://www.sintef.no/hpmc if you just need an implementation... not haskell though   (i used an earlier version/branch/something of it once (nvision.sf.net), for a project that eventually got abandoned...)
07:33:41 <t7> praise the lord
07:33:56 <t7> i have no idea wtf its doing but it works
07:33:58 <hpaste> snhmib pasted “happy madness” at http://hpaste.org/66067
07:34:03 <bitonic> t7: eheh, good job
07:34:52 <hpaste> t7 pasted “type inference” at http://hpaste.org/66068
07:34:57 <nart> hi =)
07:35:15 <reinoud> Thanks :)
07:35:25 <dcoutts> Philonous: your cabal-install is built with the wrong version of the Cabal lib. You or someone has adjusted the .cabal file for cabal-install-0.10.x so that it'd build against Cabal-1.12 or later.
07:35:48 <t7> bitonic: how do i do let polymorphism?
07:35:53 <snhmib> could someone help me with this happy parser
07:35:53 <snhmib> if i do "parseIt "typedef int foo; foo bar;" it fails
07:35:53 <snhmib> but if i do "parseIt "typedef int foo; int x; foo bar;" it works :S
07:35:53 <snhmib> it's confusing me
07:35:58 <dcoutts> Philonous: that appears to work but gives that bug. Either use the older Cabal lib or use a newer cabal-install
07:36:25 <t7> oh i just dont unify ?
07:36:34 <reinoud> @last colah
07:36:34 <lambdabot> No module "colah" loaded
07:36:47 <bitonic> t7: you get the type of the expression that the let is binding and quantify all the free variables
07:36:49 <snhmib> the actual parser is lines 29-44, the rest is just very simple lexer + state monad
07:36:54 <reinoud> oh well... i'll stop poking him...
07:37:02 <snhmib> anybody know what could be wrong? / i don't understand about happy?
07:37:02 <bitonic> t7: and then you "freshen" the type each time it's used
07:37:14 <bitonic> t7: each time the expression is used
07:37:22 <t7> ah i think i get it
07:37:43 <bitonic> t7: freshen = replace all the quantified variables with fresh type variables
07:38:01 <elliott> reinoud: why not use @tell?
07:38:12 <reinoud> what is @tell?
07:38:17 <reinoud> @help tell
07:38:17 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
07:38:26 <reinoud> :)
07:40:27 <reinoud> @tell colah did you receive my email? i am also trying out some new ideas for marching cubes but i need to know how expensive it is to calculate a point's value, or should i try to not evaluate more points than necessary.
07:40:27 <lambdabot> Consider it noted.
07:41:07 <Philonous> dcoutts:  Oh, that's refreshingly specific. It's the version arch provides. I'll just install my own. Thanks!
07:41:25 <dcoutts> Philonous: right, sounds like they broke it
07:42:38 <nart1> hi
07:44:52 <roconnor> @hoogle Pointed
07:44:52 <lambdabot> package pointed
07:44:52 <lambdabot> package pointedlist
07:45:04 <roconnor> is there a standard Pointed Functor class?
07:45:42 <snhmib> any other place for happy questions?
07:46:24 <rata_> hi guys
07:46:32 <elliott> roconnor: see pointed package
07:46:43 <elliott> roconnor: although I get the impression edwardk would rather rid of it
07:49:05 <t7> anyone who uses their real name as their nick isnt a true internet geek
07:50:36 <rata_> do you know if there's a way to set up emacs so that when I press return in the haskell inferior buffer, it goes first to the last position and then inserts the newline?
07:50:41 <hiptobecubic> t7, my experience is that people who use their real names are the people who do real things. the rest of us are just screwing around
07:51:03 <t7> why do you hate privacy?
07:51:31 <_mpu> What tool is able to deal with the source-repository field of cabal files?
07:51:39 <t7> why do you hate our freedomz?
07:51:51 <bitonic> hiptobecubic: what does that even mean? "real" things? so simon marlow doesn't do "real" things
07:52:11 <flux> things other people wish they'd done?-)
07:53:02 <roconnor> is there a standard pointed-set typeclass :D  Maybe it is that infamous "Default" class :/
07:53:20 <roconnor> s/pointed-set/ponted-type/
07:53:38 <Philonous> dcoutts:  The newest version of cabal-install seems to be over a year old and requires Cabal < 1.11 . Is there a version for ghc 7.4.1 (i.e. Cabal 1.14) and I'm just missing it?
07:53:50 <hpc> Philonous: use the one in darcs
07:53:58 <Philonous> OK, thanks
07:54:08 <hiptobecubic> let me rephrase, in my experience the people who use their real names are more likely to be doing things which are difficult and beneficial to the community. There are many exceptions of course, because there are billions of internet users.
07:54:11 <td123> Philonous: http://hackage.haskell.org/package/cabal-install-ghc74
07:54:15 <dcoutts_> Philonous: there's no release yet that builds with the Cabal lib version released with ghc-7.4
07:54:33 <hiptobecubic> For example *I* never seem to be doing anything that anyone cares about :)
07:55:01 <hpc> hiptobecubic: you just don't have a PhD :P
07:55:21 <dcoutts_> Philonous: note the cabal-install-ghc74 td123 refers to has exactly the problem you hit
07:55:32 <hiptobecubic> hpc, i know lots of people with phds who aren't doing anything that anyone cares about ;)
07:55:46 <hpc> hiptobecubic: well duh, they have PhDs :P
07:55:51 * hpc unhelps
07:55:57 <bitonic> hiptobecubic: mah, that's not true. it's simply that they release the software under their real name and for that reason you don't connect it with the nickname
07:56:16 <dcoutts_> Philonous: the options are build the released version using older libs, or use the darcs version
07:56:21 <elliott> roconnor: yeah, that's Default
07:56:25 <dcoutts_> Philonous: we're planning a release for early April
07:56:28 <elliott> roconnor: or... instance Pointed (Constant a) :p
07:57:03 <snhmib> could anyone help me with happy parser?
07:57:25 <Philonous> dcoutts_:  I'll try the darcs version. Thanks!
07:58:51 <roconnor> elliott: rather Default a => Pointed (Const a)
07:58:58 <nart> ciao :)
07:59:02 <roconnor> elliott: in the same spirit as Monoid a => Applicative (Const a)
07:59:31 <elliott> roconnor: haha, is that latter instance actually defined?
07:59:53 <td123> dcoutts_: right, the one I pointed out is only updated only for compatibility with ghc 7.4.1
08:00:12 <dcoutts_> td123: aye
08:00:27 <hiptobecubic> bitonic, it wasn't really meant for the Internet Users' Handbook, just a comment that names like "zer0grvty" are usually not as helpful as, say, "greg".
08:00:28 <roconnor> elliott: yes, and it is very useful.
08:00:45 <roconnor> elliott: it is used throughout the original Applicative Functor paper.
08:01:33 <elliott> roconnor: guess I'm insufficiently imaginative, then
08:01:43 <bitonic> hiptobecubic: mah, I'm sure of that either :). Maybe I can agree on the 1337 nicknames :P
08:01:58 <snhmib> not if people use the same handle consistently
08:02:05 <hiptobecubic> bitonic, an acceptable middle ground.
08:02:09 <elliott> hiptobecubic: i think you're starting from a preconception and trying to find evidence to justify it :p
08:02:32 <roconnor> elliott: McBride (aka pigworker) is constantly crushing data; pun intended.
08:02:36 <hiptobecubic> elliott, that's exactly the kind of constructive comment i'd expect from a nick like 'elliott' :)
08:03:33 <elliott> hiptobecubic: :(
08:06:41 <elliott> roconnor: out of curiosity, how is it used in that paper? ...i suppose i should read it :) (actually, I swear I already did...)
08:08:29 <iwtu> test. please, response to me
08:08:40 <hiptobecubic> iwtu, responsing
08:08:45 <snhmib> plong iwtu
08:09:26 <elliott> @ping
08:09:26 <lambdabot> pong
08:09:34 <snhmib> @ping
08:09:34 <lambdabot> pong
08:09:38 <snhmib> :(
08:10:04 <bitonic> we should have a chatterbot-like functionality in lambdabot
08:10:15 <bitonic> I was thinking of writing a plugin
08:10:33 <iwtu> snhmib: you are not yellow like hiptobecubic
08:11:23 <snhmib> oh man, nobody can help me with happy AND i'm not yellow like hiptobecubic
08:11:26 <snhmib> that sucks
08:11:33 <snhmib> :(
08:11:49 <iwtu> snhmib: sorry man.. I've tried
08:12:24 <bitonic> hpc: how are the lambdabot efforts going?
08:12:26 <tech2> hiptobecubic: need more iodine?
08:12:41 <elliott> bitonic: we did have chatterbot-like functionality in lambdabot
08:12:47 <hiptobecubic> snhmib, the secret to happy is to avoid comparing yourself with others
08:12:53 <hiptobecubic> or pills
08:13:06 <Botje> just find someone more miserable than you
08:13:09 <Botje> instant happiness :P
08:13:14 <iwtu> :D
08:13:44 <bitonic> elliott: really? I mean cleverbot like. what happened to it?
08:13:45 <iwtu> snhmib: I will be meserable if you want to
08:13:49 <tech2> That'd be me... having to write functional specifications documentation :/
08:14:42 <snhmib> no it's fine i'll just drink coffee :)
08:15:32 <snhmib> but if somebody could look at happy parser and tell me why "typedef int foo; foo x;" won't "work" that'd make me like happy :)
08:15:34 <snhmib> http://hpaste.org/66067
08:15:38 <snhmib> :P
08:15:48 <elliott> bitonic: @vixen; it was removed after complaints.
08:19:03 <bitonic> elliott: that wasn't a chatterbot. and @nixon still exists, which is similar
08:19:20 <elliott>  @vixen _was_ a chatbot. @nixon just parrots quotes.
08:19:58 <bitonic> as far as I remember @vixen just parroted quotes as well... I'd try if installing lambdabot wasn't so hard
08:20:13 <elliott> it didn't, it synthesised new lines
08:20:31 <bitonic> and anyways I meant something that builds up some databases of answers and answers to questions
08:21:08 <ion> Good thing @vixen was removed so lambdabot won’t say anything offensive. <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
08:21:29 <bitonic> ion: that's @nixon right?
08:21:50 <ion> yes
08:22:02 <elliott> hey, i know, why don't we retread the exact same steps whenever @vixen comes up? that'll be fun!
08:23:11 <keep_learning> Hello all
08:24:19 <Saizan> i don't think @vixen created new lines, but it had some regexes to decide which line to use
08:24:44 <elliott> hmm, i thought it did. well, whatever
08:24:55 <bitonic> I definitely remember it using the same lines multiple times...
08:26:12 <keep_learning> I have a list ( containing more than 6 * 10 ^ 6 ) elements in from of [(  key , value )] where  key will be ( Int , Int ). Some of the keys will be repeated and I want to replace all the same key by one key and adding their values.
08:26:53 <keep_learning> I am looking for data structure to do this efficiently
08:27:09 <keep_learning> One idea is using HashMap
08:27:24 <rata_> keep_learning: why not Data.Map?
08:27:26 <ion> Data.Map
08:27:36 <elliott> nested Data.IntMap?
08:27:41 <elliott> I don't see why to use Map over HashMap here.
08:27:43 <elliott> or indeed in any case
08:28:04 <rata_> elliott: you mean the other way around right?
08:28:13 <snhmib> Data.Map is easy to use & pure
08:28:15 <elliott> no
08:28:23 <elliott> HashMap is easy to use and pure too, they have basically the same interface.
08:28:32 <elliott> are you thinking of Data.HashTable?
08:28:37 <snhmib> probably :)
08:28:43 <rata_> elliott: then why HashMap?
08:29:04 <elliott> rata_: because it's faster than Map (faster than IntMap for Int keys, even)
08:29:34 <rata_> elliott: is it in the standard lib?
08:29:43 <elliott> it's in unordered-containers -- not base, but very widely used
08:30:08 <elliott> 57 reverse dependencies incl. aeson, heist, snap, yesod, etc.
08:30:13 <rata_> ok... then if it's faster why there's Data.Map?
08:30:20 <quicksilver> because Data.Map is older
08:30:29 <parcs`> :t Data.Map.fromListWith (++) . map (second pure)
08:30:30 <lambdabot> forall k b (f :: * -> *). (Monoid (f b), Ord k, Applicative f) => [(k, b)] -> M.Map k (f b)
08:30:32 <bitonic> rata_: Data.Map is ordered
08:30:42 <bitonic> they're two different data structures
08:30:58 <bitonic> e.g. with Data.Map you can easily generate sorted lists
08:31:31 <elliott> bitonic: ???
08:31:41 <elliott> well
08:31:45 <bitonic> elliott: ?
08:31:49 <elliott> ok, it's "ordered" in that sense
08:31:50 <bitonic> what's not clear
08:32:00 <bitonic> what other sense there is?
08:32:01 <elliott> but how many people actually use toAscList or whatever?
08:32:07 <keep_learning> My priority is just adding the values which has same key and performance is important. Ordering is not important
08:32:18 <rata_> bitonic: but Data.Map need not be ordered... I think that's not a part of the definition of it iirc
08:32:20 <elliott> keep_learning: take a look at Data.HashMap.Strict.fromListWith
08:32:30 <parcs`> just use Data.Map. 10^6 is not a lot
08:32:34 <elliott> http://hackage.haskell.org/packages/archive/unordered-containers/0.2.1.0/doc/html/Data-HashMap-Strict.html#v:fromListWith
08:32:44 <bitonic> rata_: maybe you're right, the name only implies a key -> value mapping. still.
08:32:50 <keep_learning> elliott, and unordered-containers is Johan Tibell  library
08:33:01 <keep_learning> I was searching this and got his blog
08:33:08 <rata_> elliott: so HashMap would eventually replace Data.Map you think?
08:33:14 <bitonic> the true reason why it's in the HP is that it's been around for much longer, and the reason for that is that it's much easier to write Data.Map than to write a good HashMap
08:33:22 <bitonic> in Haskell anyways
08:34:21 <elliott> rata_: ideally, yes, same for Set and HashSet... but since ~everyone has unordered-containers anyway, it's not so much of a problem to have it separate
08:34:52 <keep_learning> elliott, It would be great to put this in core library
08:35:13 <keep_learning> elliott, some times for solving problems on online judge
08:35:18 <keep_learning> helps lot
08:35:29 <elliott> well, not even Data.Map is in base.
08:35:35 <bitonic> what's the "core library"? the HP?
08:35:58 <quicksilver> "core library" is quite often "what comes with GHC"
08:36:03 <quicksilver> and sometimes "what comes with the HP"
08:36:07 <quicksilver> Data.Map is both of those.
08:36:13 <keep_learning> bitonic, The libraries came with ghc compiler ( I am not Haskell expert so pardon me for my stupidity )
08:36:25 <bitonic> keep_learning: oh, ok. nothing to do with intelligence :P
08:36:33 <quicksilver> it would be nice for unordered-containers to be in the platform someday.
08:36:33 <keep_learning> bitonic, :)
08:36:50 <bitonic> yeah unordered-containers should definitely be in the HP... maybe the next one
08:37:06 <t7> why does haskell have function groups
08:37:12 <t7> why not just use case
08:37:44 <bitonic> t7: why does haskell have "where"? why not just "let"? why does it have optional colons and parens?
08:37:53 <geekosaur> less clutter?  especially when you're pattern matching multiple parameters sinumtaneously
08:37:57 * snhmib ponders ditching happy and using parsec
08:38:10 <bitonic> s/parens/braces
08:38:11 <Mathnerd314> function groups == type classes ?
08:38:15 <elliott> why does haskell have names
08:38:17 <elliott> why not just use lambda
08:38:19 <geekosaur> which would be either nested cases or making tuples to no point
08:38:29 <t7> elliott: u need let aswel in that case
08:38:37 <geekosaur> Mathnerd314:  foo (a:as) = ...; foo as = ...
08:38:43 <elliott> t7: no
08:38:51 <elliott> rewrite "let x = y in z" as "(\x -> z) y"
08:38:56 <Mathnerd314> geekosaur: ty
08:38:59 <t7> > (\id -> (id 1, id 'a')) (\x -> x)
08:39:00 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:39:00 <lambdabot>    arising from the literal `1...
08:39:05 <t7> see
08:39:12 <elliott> well, yeah. but then: why does haskell have types?
08:39:21 <t7> ...
08:39:22 <bitonic> t7: well but you can write every program without polymorphic let
08:39:25 <bitonic> they're just convenience
08:39:45 <bitonic> you only need lambda and fix to write every program
08:40:06 <bitonic> you don't even need fix without types! yeeee
08:40:13 <t7> you only need brainfuck
08:40:16 <bitonic> actually all you need is iota.
08:40:17 <elliott> you don't even need anything without programs!
08:40:34 <t7> my point was function groups are nearly the same as case
08:40:41 <quicksilver> they look nicer.
08:40:46 <quicksilver> that is, basically, the only reason.
08:40:58 <quicksilver> they mirror an attractive style of equational mathematics.
08:41:35 <quicksilver> complement Red = Green; complement Blue = Yellow; -- it's just aesthetic, tastes may vary.
08:42:10 <elliott> also, f x y z = case (x,y,z) of ... is ugly
08:42:11 <quicksilver> they do let you case over multiple args at once without inventing fictional tuples.
08:42:22 <elliott> ...and stops working after too many arguments :p
08:42:26 <quicksilver> but that is also mostly an aesthetic point.
08:42:31 <bitonic> t7: btw, there are programming languages that are much more minimalistic than haskell in that regard. the Haskell people chose syntax redundancy, which imho is a good thing
08:42:44 <quicksilver> although not entirely since GHC actually doesn't eliminate those fictional tuples :)
08:43:09 <dolio> I wouldn't be so sure about that.
08:43:13 <Mathnerd314> elliott: no, it desugars to something like case x of ... -> case y of ... ->
08:43:13 <bitonic> t7: you'll find a lot of people that will praise the lack of syntax of lisp, so... it's a matter of taste
08:43:14 <t7> do function groups get compiled down to case?
08:43:22 <Mathnerd314> t7: yes
08:43:25 <bitonic> t7: yes
08:43:48 <quicksilver> dolio: I'm not 100% sure, but GHC is quite poor at general deforestation.
08:44:01 <dolio> That one is pretty easy.
08:44:04 <quicksilver> sure.
08:44:09 <quicksilver> lots of optimisations are easy and not done.
08:44:21 <quicksilver> designing general frameworks for optimisations is hard.
08:44:24 <dolio> I think it handles immediate cases on constructors.
08:44:35 <quicksilver> there is SpecConstr
08:44:38 <dolio> I mean, it has an optimization for constructed product returns.
08:44:49 <dolio> Where a function returns a product that is immediately cased on.
08:44:50 <quicksilver> that doesn't always fire though
08:44:56 <quicksilver> although I can't remember when not
08:45:05 <quicksilver> (maybe it's better in GHC > 6.12, also)
08:45:08 <bitonic> Mathnerd314: yes but it's not so simple because it has to "escape" the case
08:45:14 <bitonic> if something goes wrong in the inner cases
08:45:33 <dolio> So I would hope that it would do the same when there isn't even a function call involved.
08:45:44 <dolio> But then, who knows?
08:46:00 <elliott> <Mathnerd314> elliott: no, it desugars to something like case x of ... -> case y of ... ->
08:46:05 <elliott> i meant the alternative writing of it is ugly
08:46:16 <elliott> you'd really write nested cases rather than case of tuple if we didn't have clauses?
08:46:26 <bitonic> I think Mathnerd314 was implying that you'd write cases like that, except you wouldn't
08:46:59 <Mathnerd314> \x -> case x of ... -> \y -> case y of ... ->
08:47:18 <bitonic> Mathnerd314: how do you escape the inner case if 'x' matches and 'y' doesn't?
08:47:29 <bitonic> which is what happens when matching multiple arguments in functions
08:48:07 <Mathnerd314> \x -> case x of { ... -> \y -> case y of {...}; ... -> \y' -> ...
08:48:12 <Mathnerd314> }
08:49:20 <Mathnerd314> or maybe that's not what you meant
08:50:21 <bitonic> Mathnerd314: my question is: how do you desugar easily 'foo [] [] = ...; foo (x : xs) (y : ys) = ...; foo _ _ = ...'
08:50:41 <bitonic> with the method you're suggesting it's a pain. with tuples is much more convenient
08:50:51 <bitonic> (using case)
08:51:24 <quicksilver> because there is no native haskell way for an innercase, having failed to match to say "try-next-match" to the enclosing case.
08:51:29 <bitonic> the fact that GHC actually desugars everything into one-level, one-argument cases is different
08:51:35 * Mathnerd314 compiles it to core and checks
08:52:06 <bitonic> Mathnerd314: what happens in Core doesn't matter. you can't do that easily in Haskell
08:52:49 <elliott> you can separate each match into a function of its variables etc.
08:52:53 <elliott> and just repeat the application for the duplicate cases
08:52:56 <elliott> but, painful
08:53:08 <rwbarton> you can produce quadratic blowup converting a case on a pair to nested cases
08:53:18 <quicksilver> there is no actual code duplication
08:53:25 <quicksilver> because, in core, everything is a toplevel function
08:53:31 <quicksilver> (FSOV "everything")
08:53:46 <quicksilver> all the bodies are toplevels so the duplication is, thus, sort of eliminated
08:53:48 <elliott> for some of values?
08:53:54 <quicksilver> FSVO.
08:54:05 <elliott> the sum of all values
08:54:22 <quicksilver> in fact I've never thought very hard about when core makes things toplevel ;)
08:54:38 <quicksilver> it does nest sometimes; I guess it makes things toplevel whenever they get passed around or duplicated.
08:57:31 <bitonic> ok, maybe an old question. is there any, even experimental, FRP web framework?
08:58:32 <elliott> bitonic: there's that netwire-based thing mm_freak did as an example
08:58:40 <elliott> http://hackage.haskell.org/package/webwire
08:58:49 <elliott> i gather it doesn't work with new netwire though
08:58:51 <bitonic> elliott: yeah, but it's an example and it doesn't work with the new interface
08:59:22 <bitonic> but the code is fairly short. if there's nothing else I might read it
08:59:32 <elliott> i think that ancient haskell on a horse thing was frpy.
08:59:55 <quicksilver> FRP would be unusual thing to want for a web framework
09:00:15 <quicksilver> I thik.
09:00:34 <quicksilver> you'd either need a single-process model (to share Behaviours)
09:00:52 <quicksilver> or you'd need magic externalisation of Behaviours to some kind of transactional shared store
09:00:58 <quicksilver> which sounds like difficult magic
09:02:18 <quicksilver> single-process model is fine for various small/fun examples but it's contrary to how web apps are normally designed to scale.
09:03:05 <bitonic> quicksilver: what you can definitely do is build javascript interfaces FRP-style, there was some node.js thing that did that
09:03:18 <bitonic> but I agree that's a different kind of thing
09:04:30 <quicksilver> yes, if it's more about plugging UI elements together
09:04:39 <quicksilver> that makes sense
09:05:03 <bitonic> I just want some outlet to play with FRP. What's something that FRP does really well apart from UI?
09:05:46 <quicksilver> I'm not sure many people know the answer to that bitonic
09:05:52 <elliott> games
09:05:53 <quicksilver> I have wanted to write a FRP IRC bot for a while
09:06:01 <elliott> i guess that is a kind of UI if you're boring :)
09:06:02 <quicksilver> but haven't found the time to play
09:06:24 <quicksilver> you would thing it would be good for real-time data feedback
09:06:42 <quicksilver> monitoring website/database/host statistics and allowing you to have access to live results at all times
09:07:28 <bitonic> mhm... I have a spare week now, enough time for a little project
09:07:48 <quicksilver> one thing I don't understand about FRP, and I think it requires practical experiments to understand
09:07:55 <quicksilver> is how you're supposed to cope with overload
09:08:13 <bitonic> and I've been reading about FRP for a while but I still haven't found any practical uses that suit my tastes
09:08:15 <quicksilver> suppose you have input Events/Arrows/whatever with DB statistics and you do something with them and display a result.
09:08:24 <quicksilver> what actually happens when the data comes in too fast?
09:08:28 <elliott> (Behaviours, surely)
09:08:29 <quicksilver> I mean, obviously, it will backlog
09:08:36 <quicksilver> and eventually pipes break
09:08:44 <quicksilver> but how, in practice, would you observe and control that behaviour.
09:09:00 <quicksilver> one of the problems with burying the semantics in the haskell semantics is they're not observable any more by code
09:09:06 <quicksilver> no hooks to control or limit it.
09:09:17 <elliott> i mean, a statistic counter /is/ a Behaviour
09:09:20 <quicksilver> yes.
09:09:28 <elliott> the only reason to use Events would be to control the execution of IO, which is what causes your overload problem
09:09:41 <quicksilver> incoming data is Events - it's discrete
09:09:42 <elliott> of course, modellign with Behaviour doesn't magically solve that problem
09:09:56 <quicksilver> Event (StructureWhichModelsOneSingleAccess)
09:09:59 <elliott> quicksilver: well... you can argue that everything is Event because it's discrete.
09:10:06 <elliott> a text box's contents is Event, because it only changes discretely.
09:12:02 <timthelion> If I write a web application in haskell, what are the (cheep, small scale, options) for hosting it?  It seems that most hosting companies "support PHP" or "support Java" or "support Microsoft Web Framework" or some such BS...
09:12:21 <timthelion> the last one, I don't even know if it actually exists.
09:12:43 <elliott> VPS
09:12:55 <elliott> that's how you should host (PHP|Java|whatever) apps too
09:13:34 <timthelion> elliott: VPS is different than a traditional virtual machine?  AKA there is no huge preformance problem?
09:14:06 <elliott> depends what you mean by "traditional". virtualisation has been around for years.
09:14:35 <elliott> the majority of consumer VM products use it. even qemu can do it
09:14:43 <timthelion> elliott: well, like a "Virtual Machine" such as VMWare, or Qemu has a preformance cost of several hundred procent.
09:15:21 <elliott> VMWare does virtualisation. qemu with KVM does virtualisation.
09:15:26 <elliott> most VPS providers use Xen.
09:15:32 <elliott> your information is out of date.
09:15:35 <elliott> the only overhead is in IO
09:15:41 <elliott> nowadays, thanks to hardware support.
09:15:47 <elliott> (more or less anyway)
09:16:00 <timthelion> oh, whenever I have used QEMU it has been unbareable...
09:16:25 <elliott> you presumably didn't use qemu-kvm, then.
09:16:36 <quicksilver> timthelion: dotcloud have "alpha" support for haskell
09:16:45 <quicksilver> I've not heard any reports on how it works.
09:16:49 <elliott> (though it's probably not the fastest even then.)
09:17:00 <timthelion> And what is the great advantage of a VM over a FakeRoot?
09:17:50 <bitonic> timthelion: that you can do what you want with it?
09:18:06 <jeff_s_> Is it possible to have a type synonym with kind (* -> *) -> * -> *? I'm trying to use one as an inner monad in a monad transformer, but keep getting a kind type error.
09:18:17 <timthelion> bitonic: I just want a personal website where I could host any web apps that I might write in haskell. nothing fancy...
09:18:26 <elliott> timthelion: it's not a hack?
09:18:37 <elliott> anyway, there are tons of good VPS providers. prgmr and linode are popular.
09:18:40 <jeff_s_> That or "Type synonym `QueryRunner' should have 1 argument, but has been given none"
09:18:57 <timthelion> elliott: FakeRoots are hardly a hack.  They are supported very fundumentally by unix
09:19:08 <timthelion> elliott: OK, cool.
09:19:13 <bitonic> jeff_s_: it's definitely possible to have a type synonym with that kind signature. what do you need to do?
09:19:32 <bitonic> e.g. type Foo a b = a b
09:19:54 <bitonic> jeff_s_: note that type synonyms can't be partially applied.
09:19:59 <bitonic> which I believe is your problem here
09:20:09 <bitonic> so it doesn't really make sense to talk of "kind signature"
09:20:18 <elliott> (linode are faster than prgmr, but prgmr gives you a bit more for your money.)
09:20:19 <jeff_s_> bitonic - I think the idea of type constructor variables is new to me.
09:20:24 <bitonic> they're just synonyms, that can be replaced easily
09:20:39 <elliott> oh, amazon EC2 is popular too.
09:20:43 <bitonic> jeff_s_: a type synonym is not a type constructor.
09:21:30 <bitonic> jeff_s_: what do you need to do?
09:21:31 <timthelion> elliott: Perhaps I'll use vpsfree.cz since it's local...
09:21:45 <timthelion> I can go beat up the owners if their servers are down, or they rip me off.
09:22:02 <bitonic> jeff_s_: I'm going to bet you want a newtype :P
09:22:12 <hpaste> “Jeff Shaw” pasted “type error” at http://hpaste.org/66069
09:23:01 <timthelion> jeff shaw, what is the type error?  All I see there is code...
09:23:20 <jeff_s_> Basically all I want to do is not have to constantly type "ReaderT conn m a" or whatever.
09:23:30 <jeff_s_> timthelion, one sec
09:23:38 <mikkihiiri> damn.. still fighting with the successor sequences
09:23:40 <bitonic> jeff_s_: yeah, you can't partially apply type synonym. there is an easy solution here
09:23:51 <bitonic> jeff_s_: just omit the 'm a' on both sides
09:23:52 <mikkihiiri> ski: you there?
09:24:37 <jeff_s_> I guess I've gotten to a point where I'm not getting kind errors. Just the error I mentioned earlier.
09:24:38 <bitonic> jeff_s_: and remove those constraints
09:25:15 <bitonic> jeff_s_: yes, you get the error you mentioned because.... you can't partially apply type synonyms! so the best you can do is type QueryRunnerT = ReaderT conn
09:25:43 <mun> in a sound logic, for every theory T if T |- a then |= a, right? i.e. if a is a theorem of any theory, then it has to be true.
09:25:44 <bitonic> actually no, you can't do what you're trying to do. you're using Rank2Types I guess
09:26:04 <mun> but how does one evaluate the truth of a sentence?
09:26:16 <mun> what's the reference for the truth?
09:26:45 <timthelion> mun, there is only one type of truth, and that is tautological truth.
09:27:05 <timthelion> mun is mun(is this true?)
09:27:17 <elliott> mun: "p" is true iff p :P
09:27:32 <quicksilver> elliott: EC2 is not your typical VPS. It's very expensive compared to a cheap VPS.
09:27:35 <bitonic> jeff_s_: what you're doing in your current code is to quantify the 'conn' inside the type synonym, but you most likely don't want that. the short answer is that you can't use type synonyms in this context
09:27:42 <timthelion> elliott: :)
09:27:43 <quicksilver> cloud VPS != boring hosted VPS.
09:27:52 <elliott> quicksilver: the "always-on" plans are only $20 or so more per month than typical VPSes, iirc.
09:27:53 <jeff_s_> bitonic - thanks for letting me know. I'll find another way.
09:28:08 <elliott> quicksilver: and yes, I hear amazon web services customers get lots of regular "fun"
09:28:09 <quicksilver> elliott: it was much more when I last did the sums, but maybe it's come down.
09:28:19 <timthelion> quicksilver: is that for the Cloud(tm) name, or is there a difference?
09:28:28 <mun> right
09:28:52 <quicksilver> timthelion: well you can spin up/spin down thousands of instances of your EC2 configuration
09:28:59 <bitonic> jeff_s_: there is no way to shorten 'ReaderT conn' really.
09:29:02 <quicksilver> timthelion: on demand, programmatically, when you need the load.
09:29:15 <quicksilver> timthelion: and there are APIs for sharing storage and DB services etc etc.
09:29:21 <mun> so if |= a, does the symbols of a have to be of the object-level vocabulary? how is the language used to express 'a' defined?
09:29:24 <quicksilver> timthelion: this is a different kind of thing to simply "having a virtual server"
09:29:34 <jeff_s_> Basically I want to not have to type "(IConnection conn) => EitherT [Error] (QueryRunner conn IO) SomeType" all the time. I'd like to reduce it to "EitherT [Error] QueryRunner SomeType".
09:29:37 <timthelion> quicksilver: so if I'm makerbot inc, and I'm going to be on CNN tonight I can buy server space for the next 12 hours...
09:29:49 <mun> for T |- a, the language for expressing a has to be the signature of T. but what about |= a?
09:30:24 <bitonic> jeff_s_: you can't.
09:30:53 <jeff_s_> Sorry, it's worse than that. What I have to type out is "IConnection conn => EitherT [Error] (ReaderT conn IO) SomeType".
09:30:57 <bitonic> because the constraint covers the whole type, not just the QueryRunner thig
09:31:09 <timthelion> mun: It's still the same thing I think.  a theorum is a deffinition.  It's like, is the statement "mun is a user named mun according to our theory of user naming" true according to our theory of user naming?
09:31:21 <jeff_s_> bitonic - how about if IConnection conn => conn becomes a concrete type?
09:31:27 <bitonic> well, you can definitely have 'type QueryRunner conn = EitherT [Error] (ReaderT conn IO) SomeType", but you'll have to put the constraint each time
09:31:32 <timthelion> mun: when our theory of user naming is that users are named what there user names are...
09:31:45 <bitonic> jeff_s_: yes that would solve things, at the cost of genericity :P
09:31:46 <mun> timthelion, but when i say |= a, there's no T or any reference for deriving the language.
09:32:02 <timthelion> mun: what are you working from?
09:32:20 <timthelion> s/there/their/
09:32:23 <jeff_s_> bitonic - I don't plan to use anything other than Database.HDBC.ODBC.Connection. I was just keeping it general because I thought I could.
09:32:42 <bitonic> jeff_s_: I don't think that putting that constraint when you need it is a big hassle really....
09:32:59 <mun> timthelion, i'm just looking through some slides. just confused about |= a
09:33:03 <bitonic> also, you can factor that ReaderT and EitherT out and use the relative typeclasses (MonadReader and MonadError)
09:33:28 <mun> timthelion, but |= a isn't attached to any theory, right?
09:33:50 <timthelion> mun: I don't know.  certainly without context I cannot tell you.  You'll have to ask someone else.
09:34:10 <rata_> guys, I sure there's some monadic magic to do this, but I don't see it yet... I have a list of lists and from each one I must take either an element or none and put it in another list... it's like the filterM (const [True, False]), but when True it takes every element and put it in a different list (instead of putting the whole list)
09:34:45 * timthelion is just the channel idiot.  Doesn't know category theory or abstract geometry or even the basics of topology
09:35:34 <Clint> rata_: so you want to filter each list into 0 or 1 elements and then join the lists?
09:36:00 * tech2 hugs timthelion, I thought I was the only one :D
09:36:26 <jeff_s_> bitonic - thanks, it looks like making IConnection conn => conn concrete is helping a lot.
09:36:31 <ciaranm> hrm. i need a Word256 to go with my fancy extra big registers.
09:36:45 <rata_> is it do lst <- lsts; b <- [True, False]; guard b; elt <- lst; return elt ?
09:36:49 <elliott> ciaranm: there's a package for big words
09:36:55 <rata_> Clint: I think yes
09:37:10 <ciaranm> elliott: oh, there is? happen to remember its name?
09:37:52 <elliott> ciaranm: http://hackage.haskell.org/package/largeword
09:37:57 <timthelion> tech2: I tried learning category theory.  I basically got as far as "if you look at different categories of things where there are arrows and we claim that these arrows have certain behaviors, then we can make generalizations about all groups of things.
09:38:04 <ciaranm> elliott: ta
09:38:06 <BrightChen> hello
09:38:28 <ciaranm> hrm. why didn't the hoogles find that?
09:38:38 * timthelion never figured out any concrete idea as to groups/categories of what kind of things, can banannas be a category?
09:38:43 <Clint> rata_: or you just want to return True for each list if the output of filter is non-empty and False otherwise?
09:39:02 <rata_> Clint: no, that's not
09:39:09 <ciaranm> timthelion: you can obviously form a discrete category on bananas
09:39:18 <ciaranm> timthelion: or an indescrete one, for that matter
09:39:27 <tech2> timthelion: <sotto voice>It's all bollocks anyway!</sotto voice>
09:39:43 <timthelion> ciaranm: is my basic fudging of the facts on the rigth track?
09:39:53 <ciaranm> timthelion: not really
09:40:01 <timthelion> :/
09:40:11 <Clint> rata_: then just do concat . map filter blahblah or something
09:40:31 <ciaranm> timthelion: what you really want to say is "if we have these things where there are arrows, and these other things where there are arrows, then we can put a thing between them using arrows and magic stuff happens"
09:40:34 <elliott> ciaranm: hoogle searches not much
09:40:35 <elliott> try hayoo
09:40:57 <timthelion> ciaranm: I studied through linear algebra in college, and then changed my major thinking math was too easy and that it would bore me... I assumed that I would teach myself the rest :O
09:41:10 <rata_> Clint: mmm no... it's like "transposing" the lists non-deterministically
09:41:14 <ciaranm> timthelion: you stopped just before it gets interesting
09:41:40 <Clint> rata_: maybe you should give sample input and output
09:42:08 <timthelion> ciaranm: pitty
09:43:06 <rata_> Clint: [[0,1],[2,3]] -> [[0],[1],[2],[3],[0,2],[0,3],[1,2],[1,3]]
09:48:20 <rata_> the order is not important
09:50:06 <bitonic> ok, then a more general question about web frameworks: is there any web framework with a different approach from the usual MVC kind of thing? for example the continuation-based web framework that Racket scheme has is quite cool iirc
09:53:29 <ciaranm> gah. Data.Bits.bitSize is dumb.
09:53:32 <mikkihiiri> still would like some help with my function
09:54:35 <elliott> > bitSize (0::Integer)
09:54:36 <lambdabot>   *Exception: Data.Bits.bitSize(Integer)
09:54:38 <bitonic> mikkihiiri: I don't think you've posted a question in th past 2 hours.
09:54:46 <yasar> After studying haskell for couple of days now, I have a feeling that you can't partially learn haskell. Everything is so interconnected that you either know it, or dont.
09:54:48 <ski> > (map catMaybes . sequence . map ((Nothing :) . map Just)) [[0,1],[2,3]]  -- rata_ ?
09:54:50 <lambdabot>   [[],[2],[3],[0],[0,2],[0,3],[1],[1,2],[1,3]]
09:55:25 <rata_> ski: yes, that is it! =D
09:55:45 <ciaranm> bitSize on an Integer should give me a bound of some kind, not a frickin' error
09:56:05 <mikkihiiri> I have an homework exercise: A successor sequence is a sequence of integers, where each integer is followed by its successor (e.g. 3 is followed by 4). Write a function which, given a list of integers, finds the length of the longest successor sequence in the list. E.g. for list [1,2,4,5,6,2,1] the function should return 3.
09:56:13 <adu> ski!
09:56:20 <mikkihiiri> now I don't expect an answer as I'd really like to learn!
09:56:29 <elliott> ciaranm: a bound?
09:56:34 <elliott> bitSize isn't the bitsize of its param
09:56:37 <elliott> it's the bitsize of the type
09:56:43 <adu> yasar: that's partially true, but there are lots of things I don't know about, and I've used Haskell a bit
09:56:54 <mikkihiiri> and I've come to the conclusion that first I need a list of lists where the successor sequences are.
09:56:57 <elliott> yasar: I don't agree at all.
09:56:58 <ski> adu ?
09:57:05 <ciaranm> elliott: i want to know a number that's at least as big as the number of bits that might be on...
09:57:06 <geekosaur> that got bikeshedded on the list, I think more recent libraries have a bitsize-of-parameter type function?
09:57:07 <elliott> yasar: It's more like you discover connections between things as you learn incrementally.
09:57:08 <adu> ski: just saying hi
09:57:14 <ski> ah
09:57:14 <mikkihiiri> I've written a function that will get the first successor sequence from the list
09:57:15 <ski> hi
09:57:23 <elliott> yasar: It's true that the initial learning curve is quite a slope. But after that it's a steady climb of knowledge.
09:57:24 <ciaranm> or the index of the highest bit, doesn't really matter
09:57:46 <mikkihiiri> but I can't change it to return list of lists instead of list..
09:57:51 <DMcGill> mikkihiiri: can't you just iterate over the list to find a successor sequence and each time one ends record the length
09:57:56 <adu> yasar: and by "a bit" I mean on and off for 10 years
09:58:34 <tech2> ciaranm: get the ceiling of the log base 10 of the number?
09:58:36 <ykm> mikkihiiri: have u tried solving with succ function
09:58:40 <yasar> adu: Wow, I thought you meant about 1-2 years :D
09:58:44 <mikkihiiri> DMcGill: don't know... sounds kind of iterative approach to me
09:58:47 <ciaranm> tech2: sloooooooooooooooow
09:58:55 <mikkihiiri> succ? let me check it out
09:59:00 <ykm> succ 1
09:59:14 <adu> yasar: I first started reading about Haskell in the summer of 1999
09:59:14 <elliott> <ciaranm> or the index of the highest bit, doesn't really matter
09:59:18 <elliott> fwiw i believe this was added recently
09:59:34 <ykm> wat?.....succ gives immediate succesor
09:59:40 <mikkihiiri> yeah it seems
09:59:43 <DMcGill> > succ 1
09:59:44 <lambdabot>   2
09:59:58 <geekosaur> elliott, I thought so too, but I didn't see it in the 7.4.1 Data.Bits
09:59:58 <DMcGill> :t succ
09:59:59 <lambdabot> forall a. (Enum a) => a -> a
10:00:05 <Azel> ciaranm: I don't think you have much choice for potentially unbounded types like Integer...but wouldn't that be the log base 2 rather than the log base 10 ?
10:00:12 <elliott> geekosaur: Maybe it was just GHC it was added to.
10:00:12 <ciaranm> elliott: hrm. i see popCount. don't see a biggest bit
10:00:18 <mikkihiiri> but it doesn't get me far... It's not a problem to find the successors, it's a problem to find out the longest sequence
10:00:20 <Baikonur> > succ 2.0
10:00:21 <lambdabot>   3.0
10:00:26 <DMcGill> succ maxInt
10:00:28 <DMcGill> > succ maxInt
10:00:29 <lambdabot>   Not in scope: `maxInt'
10:00:29 <geekosaur> I know it was discussed
10:00:40 <Baikonur> > succ 2.1
10:00:42 <lambdabot>   3.1
10:00:44 <Baikonur> ok
10:00:52 <DMcGill> > [succ True, succ False]
10:00:53 <lambdabot>   [*Exception: Prelude.Enum.Bool.succ: bad argument
10:01:02 <ciaranm> Azel: log shouldn't come into it at all. it's not a question of calculating it, it's a question of getting this *fast*, since i'll be calling it a trillion times or so
10:01:11 <geekosaur> DMcGill, there is no maxInt, there is maxBound :: Bounded b => b
10:01:28 <DMcGill> is there a succ that loops from the highest in the enum to the lowest again?
10:01:34 <geekosaur> no
10:02:41 <ski> mikkihiiri : maybe you'd like to paste the code you have so far ?
10:02:51 <ski> > succ maxBound :: Int
10:02:52 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
10:03:10 <Enigmagic> ciaranm: why don't you just unpack the Integer and take the array length directly.
10:03:11 <ski> > 1 + maxBound :: Int
10:03:12 <lambdabot>   -9223372036854775808
10:03:13 <DMcGill> my solution (with an enum of size six) was toEnum . `mod 6` . (+1) . fromEnum
10:03:19 <DMcGill> but that's not very nice
10:03:36 <ciaranm> Enigmagic: i'm trying to code this in such a way that i can use Integer or one of the fixed word things without having to change any code
10:03:52 <ciaranm> Enigmagic: Data.Bits has *nearly* everything i need
10:04:36 <Enigmagic> ciaranm: make a typeclass?
10:04:45 <ciaranm> Enigmagic: Data.Bits is that typeclass!
10:04:45 <mikkihiiri> ski: code is pretty messy but okay.
10:04:49 <elliott> DMcGill: suck x | x == maxBound = minBound | otherwise = succ x
10:05:07 <DMcGill> Enum doesn't imply Bounded though
10:05:29 <DMcGill> given that this was a tiny data type with 6 unit constructors I guess it doesn't really matter
10:05:35 <mikkihiiri> ski: http://pastebin.com/FWJNP2QR
10:05:40 <mauke> The paste FWJNP2QR has been copied to http://hpaste.org/66071
10:05:57 <Enigmagic> ciaranm: make another one... class Bits a => Bits2 a where bitSize2 :: a -> Int
10:06:05 <elliott> DMcGill: if it's not Bounded then there's no highest
10:06:19 <ciaranm> Enigmagic: i'm lazy :(
10:06:19 <mikkihiiri> i understand the problem with getAllSuccessorLists.. I can't use it recursively because it returns list of lists and not list
10:06:32 <Enigmagic> ciaranm: in the time you've spent on here you could have fixed it already :P
10:06:42 <ciaranm> pah
10:07:50 <T_S_> I am switching from arrow notation from a point-free style that uses >>> . Straightforward translation introduces a space leak. Anyone seen this phenomenon?
10:08:24 <T_S_> sorry "to arrow notation, from point-free"...
10:09:09 <bitonic> T_S_: the code generated with arrow notation can be quite ugly. it's not as straightforward as the do notation
10:09:32 <bitonic> that said, I haven't got much experience with arrows
10:09:52 <ski> @unproc proc a -> do b <- f -< a; returnA -< b
10:09:53 <lambdabot> Unknown command, try @list
10:12:22 <bitonic> T_S_: you might want to dump the generated code, see http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
10:12:33 <bitonic> probably -ddump-ds
10:12:47 <ezyang> Cool!
10:12:59 <ezyang> well, I guess I should train armor now...
10:13:19 <ezyang> how many levels is desirable?
10:13:22 <ezyang> mix
10:14:04 <nart> how can i apply (,) to 2+ arguments ? like (,) 1 2 3 4 -> (1,2,3,4)
10:14:06 <bitonic> T_S_: actually no sorry -ddump-ds spits out core already :P
10:14:11 <bitonic> :t (,)
10:14:12 <lambdabot> forall a b. a -> b -> (a, b)
10:14:17 <bitonic> nart: ^^^ you can't
10:14:22 <bitonic> :t (,,)
10:14:23 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
10:14:25 <bitonic> :t (,,,)
10:14:26 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
10:15:05 <nart> bitonic: thanks =)
10:15:23 <T_S_> bitonic: thx
10:19:19 <amindfv> How can I split text by a string in Parsec?
10:19:25 <amindfv> I can split by a character by saying, e.g.:
10:19:37 <amindfv> whole = sepBy (many (noneOf "\n")) (char '\n')
10:19:49 <amindfv> but I'd like to do:
10:20:01 <amindfv> whole = sepBy {something} (string "\n\n\n")
10:20:08 <bitonic> well you can do that
10:20:23 <elliott> what is something
10:20:47 <amindfv> elliott: that's my question - I don't know what to put there
10:21:00 <bitonic> :t sepBy
10:21:01 <lambdabot> Not in scope: `sepBy'
10:21:05 <bitonic> amindfv: another parser
10:21:08 <bitonic> @hoogle sepBy
10:21:08 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
10:21:09 <lambdabot> Text.ParserCombinators.ReadP sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
10:21:09 <lambdabot> Text.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
10:21:40 <elliott> amindfv: well, your question is rather vauge.
10:21:41 <elliott> vague.
10:21:53 <elliott> ah, i see what you mean.
10:22:03 <elliott> that might be a bit ugly.
10:24:04 <amindfv> elliott: what's vague? I'm pretty new to Parsec so I might be omitting details
10:25:09 <timthelion> Is it reasonably expected that a mathematician should know all or almost all of the vocabulary used in all branches of math(except for special vocabulary invented by individual authors?) or is mathematics too diverse for that?
10:26:03 <ski> i'd say it's too diverse
10:26:10 <geekosaur> far too diverse.  there is some commonality but a lot of divergence
10:26:20 <timthelion> pitty
10:26:40 <ski> category theory does some to ameliorate the divergence of vocabulary
10:26:46 * timthelion likes to finish things.
10:27:36 <timthelion> Well, the vocabulary of C programmers(for example) is very limited... So I had hoped...
10:27:42 <elliott> amindfv: it wasn't vague
10:27:46 <elliott> i just didn't understand it
10:28:01 <amindfv> essentially what I'm looking for is a function like noneOf which searches for Strings instead of Chars
10:28:10 <yasar> anyone here has any experince in lisp?
10:28:23 <timthelion> yasar: What do you need?
10:28:25 <tech2> timthelion: that's just C programmers, imagine "the vocabulary of programmers" in general.
10:28:55 <bitonic> and programming is *far* smaller compared to maths in terms of quantify of definitions
10:29:01 <bitonic> *quantity
10:29:02 <yasar> I was wondering how similiar / different haskell and lisp are. I have not meet lisp yet.
10:29:22 <timthelion> tech2: well even the vocabulary of all C like language programmers(C, C++, Java, C#) I think I'd understand most terms used in all publications on those langugages.(perhaps not java)
10:29:40 <solarus> amindfv: can't you do something like  sepBy (something <* notFollowedBy separator) separator
10:29:40 <timthelion> yasar: it depends on which lisp.
10:30:00 <yasar> timthelion: What do you mean?
10:30:09 <tech2> timthelion: right, but that's just a small family with similarities, imagine it as topology or something.
10:30:16 <geekosaur> yasar, that's a rather broad question.  (I have a fair amount of experience but it's mostly in Maclisp which is ancient... lots of stuff in CL)
10:30:25 <ciaranm> topologists don't even agree on what the axioms are
10:30:28 <bitonic> yasar: Haskell and Lisp share the main ideas of functional programming, but that's where the similarities end.
10:30:45 <bitonic> yasar: also, "Lisp" doesn't exist. It's a miryad of lisps :P
10:30:49 <geekosaur> topologists were who I was specifically thinking of with my lots of divergence comment...
10:31:12 <elliott> bitonic: not even that far
10:31:17 <elliott> i mean, common lisp is hardly "functional" :)
10:31:24 <elliott> scheme and haskell have at least that much in common, though
10:31:28 <bitonic> true
10:31:53 <solarus> amindfv: or hmm it wont work when "something" parses the separator
10:32:00 <ski> yasar : the lisps use regularity of (concrete) syntax to make code-manipulating code much easier (see macros) -- if you're wondering about one to try, i'd suggest Scheme
10:32:06 <bitonic> yasar: most importantly, lisp and haskell are completely different on types (which are central in haskell) and syntax (which is central is lisp)
10:32:21 <bitonic> *in lisp
10:32:23 <jeff_s_> Lisp has no syntax! (So I've heard.)
10:32:33 <bitonic> so you won't go very far comparing them :P
10:32:37 <keep_learning> elliott, any other language which treats mutation/IO similar to Haskell
10:32:55 <ski> lisps have abstract syntax, but not much concrete syntax
10:33:04 <tech2> Forth is amusing in that way
10:33:16 <amindfv> solarus: yeah, it's not working for me, at least when I use "many anyChar" as the "something"
10:33:27 <jeff_s_> I have a feeling that I'd love Forth too much if I learned it, so I avoid it.
10:33:28 <ski> you can e.g. shadow "keywords" in Scheme
10:33:44 <amindfv> solarus: but I hadn't seen the notFollowedBy function before - that might lead somewhere...
10:34:13 <timthelion> yasar: As an example, haskell has first class functions.  Elisp doesn't have "functions" in the pure sense at all, but it does have first class expressions.  You can pass an entire program as a paramiter, or sort it as a list :)
10:34:17 <solarus> amindfv: try lookAhead also
10:34:26 <solarus> amindfv: that should do it
10:35:28 <yasar> timthelion: That sounds weird...
10:35:31 <timthelion> yasar: a list program is, I guess, a tree which is written using parethesis.  Like XML...  And sometimes these lists can be executed by varios interpreters, or compiled.
10:35:53 <jeff_s_> I imagine Template Haskell has quite a lot more in common with lisp than Haskell.
10:36:00 <timthelion> yasar: it is the most natural thing in the world.  Though no one ever runs the sort function on a lisp program.
10:36:30 <timthelion> s/list/lisp/ in my previos remark :)
10:36:41 <amindfv> solarus: ok thanks - I'll chew through that documentation.
10:37:39 <ykm> timthelion: what about concepts like CLOS? any equivalent in haskell?
10:38:08 <timthelion> ykm: I don't know. I was an elisp programmer, but I don't know the word CLOS. :(
10:38:32 <elliott> ykm: we don't do objects
10:38:34 <elliott> or rather, we do
10:38:37 <eacameron> How does "Clean" compare to "Haskell"? From what I'm reading it's much faster, but SPJ still thinks Haskell is the most beautiful language on earth. Does Haskell win-out in terms of actual community size? Why?
10:38:44 <elliott> but we call them data-types with functions in them.
10:39:08 <elliott> eacameron: clean has a really tiny community compared to haskell, IIRC isn't really very maintained; ISTR the compiler has a weird license too
10:39:19 <elliott> eacameron: I think claims of Clean being massively faster are out of date. GHC has gotten a lot better in recent years.
10:39:39 <jeff_s_> It sounds like someone needs to rerun some benchmarks.
10:39:45 <elliott> Clean has more "warts" than Haskell IMO -- not that I've learned it, but just on the surface
10:39:53 <eacameron> elliott: could be, I'm reading from 1997 ;)
10:39:55 <timthelion> eacameron: the whole compairison of languages gets rather tough when we aren't talking imperitive...
10:39:57 <elliott> the uniqueness typing is neat, but complicates the type system for probably not a massive benefit
10:40:04 <elliott> "Some state that Clean is faster than Haskell,[2] but other research show that this depends on the kind of program that is tested.[3]"
10:40:07 <elliott> thanks, Wikipedia!
10:40:21 <jeff_s_> Ya, and how old is that reference?
10:41:17 <elliott> dunno
10:41:18 <elliott> http://www-users.cs.york.ac.uk/~mfn/hacle/index.html
10:42:31 <eacameron> elliott: thank you, very helpful!
10:42:49 <timthelion> elliott: There are "types of programs" for which python 2 may be about the fastest in the world...  Imagine a program that has to use a String based dictionary to run a DSL...  Python might do that quite as well as C with much much much less code, and would be almost certainly faster than Haskell.  But that's a problem specifically chosen for python2.
10:43:10 <timthelion> elliott: so the "types of programs" arguement may be a mute point.
10:43:23 <elliott> "almost certainly faster than Haskell"? I don't believe you
10:43:57 <timthelion> elliott: OK, but it could do it AS fast as haskell.
10:44:25 <elliott> I don't really believe that, either :) CPython is fast at some things, but you still have the not-inconsiderable bytecode interpreter overhead.
10:44:46 <tech2> elliott: and interestingly Pypy is about 5 times as fast as cpython
10:45:37 <ski> elliott : iirc, it's not available under GPL as well
10:46:03 <timthelion> elliott: if you where writting an interpreter for an DSL which was very similar to python, than the bytecode overhead would be little different than if you wrote the interpeter strait out in C.
10:46:32 <timthelion> elliott: but that was just a random example I pulled out of my ass to show a point, I'm probably wrong...
10:46:43 <ski> ykm : i think type classes are *vaguely* similar to some aspects of CLOS, but we don't really have anything like CLOS, no
10:47:22 <ziman> from my (limited) experience, haskell is far more comfortable and allows for more "modularization" than clean because you've got nice features in the language (most notably inline type annotations)
10:47:35 <ykm> hmm...that is what I suspected
10:47:51 <ski> timthelion : however, Scheme and CL distinguishes clearly between functions and lists representing code
10:48:15 <timthelion> ski: as I said, it depends on the lisp.  In elisp they are the same.
10:48:19 <ziman> I were never able to factor out IO boilerplate, for example
10:48:21 * ski nods
10:48:35 * ski wonders what's the case in AutoLisp
10:48:46 <koeien> hi. i'm trying to link to a C++ library. i suppose the easiest way is to use extern "C" and then link to that?
10:48:59 <whittle> I’m a little confused by infix notation: in chapter 5 of Real World Haskell, there is the expression "flatten x `Union` x". Is it possible to figure out the order of application just by looking at that expression, or do I need to consider the types of flatten and Union?
10:49:16 <koeien> whittle: this means (flatten x) `union` x
10:49:29 <Saizan>  419:44   tyrantul | changes nick to bmfx
10:49:54 <mikkihiiri> time is ending with my exercise
10:50:02 <ziman> and you barely find abstractions in the stdlib
10:50:02 <mikkihiiri> seems that I won't be able to finish it
10:50:27 <azm> seriosly you have to write an essay to the ide to get basic reading from file...
10:50:38 <elliott> azm: really?
10:50:43 <elliott> main = readFile "myFile" >>= putStr
10:50:47 <elliott> your essays must be really short
10:51:07 * ski wonders which IDE azm is talking about
10:51:13 <azm> elliott, oh sorry, I was ranting on Java\
10:51:15 <azm>  x)
10:52:14 <azm> haskell way is of course elegant
10:52:14 <ski> mikkihiiri : i think it would help if you defined a `helper :: Integral a => [a] -> ([a],[[a]])' function
10:52:34 <ski> mikkihiiri : which given a list returned a pair of the first streak, and the list of the rest of them
10:52:42 <roconnor> I keep forgetting about the existance of GHC.Event.
10:52:57 <ski> what is that ?
10:53:07 <roconnor> scalable event notification for file descriptors and timeouts.
10:53:26 * ski supposes it's not related to events in CML
10:54:01 <elliott> azm: oh, heh
10:54:20 <elliott> roconnor: why do you need to use GHC.Event specifically?
10:54:30 <elliott> roconnor: that's what underpins regular Handle IO, why not just do that wtih forkIO?
10:54:36 <elliott> (assuming you use the threaded runtime)
10:54:45 <roconnor> it's yet another way of doing network timeouts?
10:54:52 <elliott> ah
10:54:56 <elliott> didn't know that's what you were doing :)
10:55:16 <roconnor> acutally, right now I was just looking at various instances for Monoid
10:55:20 <roconnor> such as Event!
10:55:23 <mikkihiiri> ski: so i should use that recursively to find successor sequence and the rest?
10:55:40 <roconnor> I don't know what appending two Events does.
10:55:57 <ski> mikkihiiri : yeah, that's basically what i did, anyway
10:56:01 <ski> there might be other ways
10:56:08 <elliott> roconnor: merges them?
10:56:50 <ski> (and it would be possible to do it directly with the return type `[[a]]' instead of `([a],[[a]])', matching on `bs:bss' instead of on `(bs,bss)' -- but i think the pairs there are cleaner)
10:57:19 <mikkihiiri> but why returning pairs only?
10:58:21 <ski> because as you're trying to compute
10:58:22 <ski> > successorStreaks [1,2,3,5,6,7,8,12,13]
10:58:23 <lambdabot>   [[1,2,3],[5,6,7,8],[12,13]]
10:58:24 <ski> in terms of
10:58:29 <ski> > successorStreaks [2,3,5,6,7,8,12,13]
10:58:30 <lambdabot>   [[2,3],[5,6,7,8],[12,13]]
10:58:37 <ski> you want to add the `1' to the first list
10:59:07 <ski> and it's easier to do this if you actually get `([2,3],[[5,6,7,8],[12,13]])' from the recursive call
10:59:37 <mikkihiiri> man this exercise is hard...
10:59:44 <ski> namely, you match that with `(bs,bss)', add the element in front of `bs', returning a new pair with that new first list, but the same list of lists
11:00:06 <ski> however, i'm not saying one *has* to do it like this
11:00:17 <ski> this is just a hint for *one* way to do it
11:00:23 <mikkihiiri> yeah...
11:00:30 <ski> the real point is thinking recursively
11:00:56 <ski> figuring out how to bridge the gap from the result of the recursive call to the desired result of the current call
11:01:14 <ski> @src span
11:01:14 <lambdabot> span _ xs@[]                     =  (xs, xs)
11:01:14 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
11:01:15 <lambdabot>                   | otherwise    =  ([],xs)
11:01:29 <ski> shows another function which returns pairs in a similar way
11:01:59 <chrisdone> sup haters
11:02:11 <ski> note how here it matches the result of the recursive call on `(ys,zs)', replacing that result with `(x:ys,zs)' as the whole result
11:02:22 <ski> doing that by adding `x' in front of the first list result
11:02:35 <ski> i think you want to do something similar to that
11:02:39 <ski> lo chrisdone
11:03:18 <ski> the code for `helper' would be relatively similar to your `getFirstSuccessorList' code
11:03:48 <ski> but instead of returning only the first successor list, it would return a *pair* of that, and the list of all the rest of the successor lists
11:03:56 <ski> mikkihiiri : do you understand ?
11:04:15 <mikkihiiri> not quite....
11:04:40 <mikkihiiri> wondering why to return the pair if it's possible to return list of lists without the pairs
11:04:42 <chrisdone> did anyone try my session/interactive mode stuff i added to haskell-mode yet?
11:05:04 <ski> mikkihiiri : well, i think it might be slightly easier to think about returning a pair
11:05:10 <Philonous> chrisdone:  Hey, i've been trying yout additions to haskell mode and haskell-process-load-file seems to start ghci, but I never get a buffer to interact with it
11:05:19 <ski> if you feel you prefer the other way, i'm not stopping you :)
11:06:36 <chrisdone> Philonous: ok let's fix that. what happens? it prompts for a project right?
11:07:10 <Philonous> Yes, and for the working directory. twice
11:09:15 <chrisdone> Philonous: oh yeah, so it does. i've been starting it with C-`. let me fix it
11:09:57 <Philonous> To be more precise: It asks whether I want to start a new project, I hit 'y', then it asks for the cabal dir (and guesses it correctly), then it wants the current directory (twice)
11:10:54 <chrisdone> Philonous: right, it shouldn't do that. let me see why it's asking twice
11:11:18 <roconnor> > getAll $ fold []
11:11:19 <lambdabot>   Not in scope: `fold'
11:11:24 <roconnor> > getAll $ Data.Foldable.fold []
11:11:25 <lambdabot>   True
11:11:34 <roconnor> > getAny $ Data.Foldable.fold []
11:11:35 <lambdabot>   False
11:12:08 <shapr> Are there any "haskell in browser" implementations that primarily do evaluation in javascript?
11:12:29 <shapr> Or perhaps compiles the Haskell code on the server, but compiles to javascript to be executed on the client?
11:12:43 <shapr> chrisdone: Have you heard of such a thing?
11:12:54 * shapr looks at https://github.com/chrisdone/tryhaskell
11:13:07 <chrisdone> tryhaskell runs on the server
11:13:29 <olsner> I suspect that getting ghc itself cross-compiled to javascript might be tricky
11:13:33 <chrisdone> uhc or ghcjs can be used this way, as they both compile to js… i thought of making a server to take code snippets and compile
11:14:12 <chrisdone> but they aren't *quite* yet. uhc could be enough for your use case tho!
11:14:37 <shapr> chrisdone: friend of mine said it would be a neat way to do 'inventing on principle' - style coding.
11:14:46 <shapr> I do like that idea.
11:15:04 <c4th0d3r4y> qaD
11:15:31 <chrisdone> shapr: you mean the code on one side evaluation model on the other, or the 'code the running program on the fly' or both? :p i loved them both
11:16:10 <shapr> Whichever is easer to accomplish as a SoC project :-P
11:16:12 <chrisdone> http://chrisdone.com/posts/2012-01-06-uhc-javascript.html
11:16:22 * hackagebot happstack-server 6.6.5 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.6.5 (JeremyShaw)
11:16:23 <alpounet> i was really disappointed after watching that talk, 'cause I'd love to do both but we don't really have what's needed for that :(
11:16:44 <alpounet> but i'd love seeing this as a SoC project!
11:16:57 <chrisdone> shapr: ^ this lets you do uhc -tjs Foo.hs and you get a Main.html containing all the .js deps it needs and a Main.js. with this you could write a server to output code methinks
11:17:19 <shapr> chrisdone: Wow, I gotta try that!
11:17:40 <alpounet> shapr, will you potulate for the GSoC?
11:17:53 <alpounet> postulate*
11:18:05 <chrisdone> (https://github.com/johang88/haskellinjavascript and https://github.com/valderman/lambdascript/ might be interesting)
11:18:37 <snhmib> could someone help me out with making a happy parser (http://hpaste.org/66067)
11:18:48 <shapr> alpounet: I've put in a student application, but I'm trying to make sure I have a project idea I can actually implement in a summer.
11:19:05 <shapr> alpounet: I haven't written much Haskell in the past year or two, been doing way more C,C++, Arduino.
11:19:24 <snhmib> i.e. if i do 'parseIt "typedef int foo; foo bar;"' it throws an error but if i do 'parseIt "typedef int foo; int x; foo bar;"' it will parse correctly
11:19:38 <snhmib> i don't understand why the first one would fail :(
11:20:35 <alpounet> shapr, hmm, yeah but you won't have much trouble justifying a fair experience in Haskell :)
11:20:48 <geekosaur> snhmib, depending on how the grammar was written, the succeeding token may have already been lexed
11:21:04 <chrisdone> Philonous: sorry i was sorting this bug. /me gets back to it
11:21:14 <shapr> alpounet: That's true, but my skills are rusty :-)
11:21:15 <geekosaur> before the typedef is established for the lexer to refer to in order to return the right token
11:22:08 <alpounet> shapr, well, toying around with that "Haskell on Principle" (pretty good name right?! :p) thing would be a good way to make them come back
11:23:10 <shapr> Yes, I agree. I would like to pitch some in-browser Haskell...
11:23:23 <shapr> Especially something like "Haskell with Friends" if it doesn't already exist.
11:23:37 <snhmib> geekosaur: do you have any tips on how to rewrite this grammar so it doesn't happen? :P
11:24:02 <shapr> I'd like to have the ability to load a Haskell program into a brower page where multiple people can edit and evaluate code.
11:24:09 <anssik> what !Int means in "Ident String !Int NodeInfo" ?
11:24:15 <anssik> (Language.C)
11:24:23 <shergill> chrisdone: does your interactive/session mode stuff extract the ghc extensions from the cabal file? i had that working with haskell-mode, but it seems to have broken with some recent change i made on my end. if there's provision for something like that in your extension to haskell-mode i'll give it a try instead of hacking my way through my problem
11:24:23 <snhmib> make it strict i think
11:25:09 <shergill> chrisdone: or do you use directory local .ghci's to that end?
11:25:36 <anssik> ah, ok
11:25:40 <anssik> thanks
11:25:42 <shergill> eg. to enable quasiquotation etc. or do you just have those in the top of the haskell files?
11:26:41 <chrisdone> shergill: are you talking about a particular feature? extracting extension for what?
11:26:50 <alpounet> shapr, that would be neat! keep me posted about your proposal
11:26:55 <shapr> ok!
11:27:00 <snhmib> woohaa
11:27:13 <chrisdone> shapr: post me keeped too. i wanted such a thing too
11:27:21 <snhmib> geekosaur: nevermind random moving the place where ';'s are parsed seemed to solve it
11:27:26 <shapr> chrisdone: roger!
11:27:41 <snhmib> ++randomcoding
11:28:19 <geekosaur> snhmib, I was speraking kinda generically based on my experience with yacc and some other LALR(1) parser generators; I don't know details of how happy parsers work, so am unsure how to fix.
11:28:58 <shergill> chrisdone: i have a project. like ever good (lazy?) haskeller, i use cabal to keep track of the ghc language extensions which my project needs. in order to load those files in ghci (inferior-haskell-process) i would keep track of those extensions in two places (one in the cabal file, and another in a configuration file which i would make sure ghci would read). i was wondering if your extensions to haskell-mode had a less hacky way to deal wit
11:30:00 <alpounet> shapr, note that gloss/gloss-web can be nice for the graphical aspects
11:30:16 <geekosaur> ...and yes, that would work as long as the resulting grammar doesn't develop conflicts because the trailing ';' is needed to reliably parse the preceding token.  will work with a simple name, may be problematic with some others (e.g. typedef foo (*bar)() is valid C)
11:30:52 <chrisdone> shergill: ah. i tend to put my extensions in the files they apply to. if cabal-dev ghci does this then you get it for free, but i'm not sure off hand if it does
11:30:55 <ski> anssik : makes the data constructor strict in that argument
11:31:33 <chrisdone> shergill: i don't have such support by reading the cabal file at the moment but it could be added
11:31:52 <shapr> alpounet: That's a great suggestion!
11:32:01 <geekosaur> I think recent happy has an LR(1) mode as well as the LALR(1) mode, which might help because it's the lookahead that's causing the "caching"
11:32:18 <shergill> chrisdone: gotcha. if i get time i might send a pull request with that feature before long
11:33:10 <chrisdone> shergill: it's worth making a ticket for probably, it's a good idea
11:33:15 <donri> cabal-dev ghci does use the extensions listed in cabal, though NoImplicitPrelude doesn't work
11:33:42 <chrisdone> donri: nice one. shergill, see that? maybe that could satisfy your needs
11:33:54 <chrisdone> Philonous: so i just fixed, it think. do a git pull and retry?
11:34:02 <Philonous> sure, just a sec
11:34:20 <donri> also expect a "cabal repl" in a future release of cabal-install
11:34:22 <chrisdone> @quote agile
11:34:22 <lambdabot> kmc says: dryhumping is a key component of behavior-driven post-agile scrum development
11:34:22 <shergill> yeah, that should be enough. thanks donri
11:35:04 <aristid> @quote oleg
11:35:04 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
11:35:08 <aristid> antidote
11:35:09 <chrisdone> donri: i know duncan's been wanting to write that for some time, should be rather saucy
11:35:25 <donri> he said he was working on it a few days ago
11:35:28 <snhmib> geekosaur: i'll have a look, i don't have to parse C, just C-like (no function pointers). not sure. i'm not very happy with this anyway, i.e. typedef int foo -- now can't do "foo foo"; anymore, might drop happy for recdescent parsing anyhow :)
11:35:34 <Philonous> chrisdone:  OK, it asks only once now. Still does not create a buffer with inferior ghci
11:35:45 <snhmib> geekosaur: at least now this prob is outof the way :S
11:35:57 <chrisdone> Philonous: is there a buffer in your buffer list named *project*? where "project" is the name you gave it?
11:36:02 <Philonous> No
11:36:14 <geekosaur> 'foo foo' wouldn't work in real C either, IIRC.  you could make it work with a context dependent parser/lexer, which would be a lot more work
11:36:23 * hackagebot hlint 1.8.26 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.26 (NeilMitchell)
11:36:25 <Philonous> Only  *haskell-process-log*
11:36:35 <chrisdone> Philonous: no errors in *Messages*?
11:36:58 <snhmib> ok maybe i'm confused.. would be nice for it to work, but too much work now :)
11:37:01 <Philonous> chrisdone:  None
11:38:07 <chrisdone> Philonous: ahh. i've figured it out. it's the prompt. humm i should sort this. meanwhile, try adding the following to your ~/.ghci :set prompt "> "
11:38:35 <Philonous> chrisdone:  I was just going to ask whether it might be the prompt. I'll try it
11:38:46 <chrisdone> Philonous: it actually sets this prompt itself, but it seems it doesn't handle the initial handshake, i'll fix this
11:40:29 <Philonous> chrisdone:  That did the trick. Thanks!
11:41:03 <chrisdone> Philonous: alright sweet. :-) i'm working on fixing this now
11:41:15 <geekosaur> snhmib, as your lexer is currently written, it always returns a name which is a typedef as a type token instead of a name token.  you would need context dependence to tell the lexer when to return one vs. the other
11:43:43 <geekosaur> which means instrumenting the grammar so that the lexer will know when a type token is expected.  which brings back the same problems you had before making typedefs return distinct tokens, albeit in a different form which may be easier to deal with
11:43:44 <Philonous> chrisdone:  Oh, and haskell-format-import works, too. Splendid.
11:43:55 <chrisdone> shergill: make sure you run with (custom-set-variables '(haskell-process-type 'cabal-dev))
11:44:01 <chrisdone> Philonous: :D
11:44:52 <shergill> chrisdone: yep
11:46:14 <snhmib> yea i know, it sucks :) for now there's a little note somewhere "don't name variables after typedefs", it's enough to work :)
11:57:35 <chrisdone> Philonous: fixed it. so you shouldn't need the :set prompt line now
11:58:47 <koeien> is this a "safe" use of unsafeCoerce? data X = X Int; data Y = Y Int Int; unsafeCoerce (Y 3 2) :: X
11:59:25 <ski> koeien : i think not
11:59:27 <ClaudiusMaximus> koeien: i think the only safe use of unsafeCoerce is between newtypes
11:59:34 <ClaudiusMaximus> (of the same type)
11:59:56 <koeien> "it did not crash in a simple test", but yeah, that's a very weak guarantee of course.
12:02:09 <leino> hello people. what is the status with reactive programming in Haskell? the hackage package 'reactive' seems outdated, what do most people use?
12:02:27 <shergill> leino: look at reactive-banana
12:02:28 <chrisdone> there are a lot of packages
12:03:29 <rata_> what's reactive programming mainly for? I hear a lot about it here
12:03:38 <leino> documentation/examples is a big plus as well
12:04:06 <rata_> *used for
12:06:02 <xplat> https://github.com/xplat/potpourri/blob/bfe6f85d4124b7d50246b80505ade1ad0dfd66aa/Golforth.hs
12:06:48 <monochrom> reactive programming is for programming interactions functionally
12:07:08 <leino> shergill: why is 'reactive-banana' preferable to 'reactive'? :)
12:07:52 <xplat> leino: delicious banana flavor
12:08:55 <leino> also, cabal could install it for me
12:09:07 <shergill> leino: didn't say it was. but it is being maintained actively
12:09:12 <shergill> *maintained/developed
12:09:19 <shergill> also, what xplat said
12:12:31 <leino> shegrill: thanks for the suggestion! It seems more current and more documented than 'reactive'
12:13:39 <leino> I had seen it before, of course, but I instantly dismissed it because of the name :|
12:14:59 <chrisdone> Philonous: try this out (define-key haskell-mode-map (kbd "SPC") 'haskell-mode-contextual-space)
12:15:15 <chrisdone> Philonous: y'al have to git pull first
12:17:09 * chrisdone pounces on ivanm but misses and falls into a pile of jelly
12:17:52 <chrisdone> ivanm: did you try my haskell-mode changes yet?
12:22:36 <dmwit> mekeor, kallisti: re: why "1" is not a constructor (I know, I'm a few days late)
12:22:57 <dmwit> mekeor, kallisti: When you write what looks like a pattern match on numbers, it in fact is translated to a guard with an equality check.
12:23:48 <dmwit> I# is the constructor for Int, for example, not 1.
12:24:02 <Philonous> chrisdone:  That's pretty nifty, it takes a few seconds to gather the available module names, though.
12:25:21 <Philonous> chrisdone:  But only for the first time. So that's not a problem
12:25:49 <kallisti> dmwit: ah okay.
12:26:37 <chrisdone> Philonous: yeah, after that the filesystem probably caches
12:26:49 <kallisti> dmwit: that could be part of the rationale for why Num is an Eq subclass.
12:26:57 <kallisti> which is sometimes mentioned as a poor decision.
12:27:09 <chrisdone> Philonous: it's a naive implementation, only works on linux. but beats typing out modules for the time being
12:28:25 <dmwit> kallisti: Yes, that was exactly the reason.
12:28:26 <Philonous> chrisdone:  Oh, but apparently the inferior mode collects all output before printing it on the screen. That makes testing/playing with interactive programs in the inferior buffer impossible
12:28:44 <dmwit> kallisti: But the new way (only adding Eq constraints when you do a "pattern match") is much better.
12:29:00 <kallisti> new way? it's been changed?
12:29:07 <dmwit> yep
12:29:12 <kallisti> ah okay.
12:29:20 <dmwit> Eq and Show are no longer subclasses of Num. =D
12:29:40 <kallisti> what's the rationale for Show?
12:30:10 <dmwit> Smaller type signatures, I think. =P
12:30:17 <nart> i need some help implementing the mergesort algorithm,  call me stupid but i really don't understand what the merge fun as to do :S
12:30:19 <nart> *has
12:30:58 <dmwit> nart: Given two sorted lists, return a list with all the same elements as the two lists put together, but in sorted order.
12:31:05 <dmwit> nart: No fair calling sort during the process, though.
12:31:22 <chrisdone> Philonous: that's true. well, all commands have the possibility to read data "live" and so could be sent straight to ghci. i could make it so when the current command is "eval" it prints everything it gets immediately and sends the current line to the inferior process
12:31:58 <monochrom> to sort a list, cut up the list into two halves arbitrarily, subcontract someone to sort the two halves separately. now you are faced with the problem of combining the two halves, while preserving order
12:32:24 <roconnor> monochrom: just return [], which is sorted.
12:32:50 <roconnor> > Just return []
12:32:51 <lambdabot>   Couldn't match expected type `[a] -> t'
12:32:52 <lambdabot>         against inferred type `Data...
12:33:00 <chrisdone> Philonous: er, “sent straight to the buffer”
12:33:27 <Philonous> chrisdone:  That's what I read, anyway ;)
12:33:38 <chrisdone> Philonous: lemmie try…
12:34:06 <kallisti> dmwit: smaller type signatures? pah. who needs that.
12:34:13 * kallisti spends more time writing types than he does code.
12:34:18 <chrisdone> Philonous: in normal inferior-haskell it's pretty limited to just "send a line at a time" right?
12:34:41 <nart> ty
12:35:42 <Philonous> chrisdone:  I think so, I don't know for sure though. It would probably be enough
12:39:21 * kallisti is seriously surprised that there's no utility to automatically fills in missing top-level signatures, with other options like prompting the user to update existing signatures if they could be more general.
12:39:29 <bitonic> kallisti: there is
12:39:35 <bitonic> ghc-mod does that
12:39:42 <kallisti> oh excellent.
12:39:50 <chrisdone> inferior-haskell does that too
12:40:05 <chrisdone> C-u C-c C-t iirc
12:40:20 <kallisti> neato
12:45:03 <kallisti> chrisdone: hmm I tried doing that and says the function isn't in scope.
12:45:35 <kallisti> oh I bet it doesn't compile because it needs GHC options
12:45:38 <monochrom> you have to load that module first
12:45:58 <monochrom> the command simply just asks ghci ":type xxx"
12:46:10 <mroman_> @src fix
12:46:10 <lambdabot> fix f = let x = f x in x
12:47:09 <chrisdone> kallisti: try loading the module first. that'll load inf-haskell and probably that function
12:47:26 <mroman_> @type (\f -> (\x -> f(x x))(\x -> f(x x)))
12:47:27 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
12:47:27 <lambdabot>     Probable cause: `x' is applied to too many arguments
12:47:27 <lambdabot>     In the first argument of `f', namely `(x x)'
12:47:32 <mroman_> interesting.
12:49:00 <monochrom> unfortunately Y is untypable in haskell
12:49:17 <monochrom> it's also why haskell allows your own recursion to make up for it
12:49:18 <mroman_> I noticed.
12:49:35 <Qwl> So I read somewhere that the term point-free comes from topology, and I've actually taken topology and was interested if there's any sort of haskell-topology parallel article
12:49:49 <mroman_> In simply typed lambda calculus it does not have a type.
12:50:10 <mroman_> But I knew that Haskells fix has a type.
12:50:17 <mroman_> Which made me wonder how and why.
12:50:53 <monochrom> there is no parallel. point-free here simply means "don't mention parameters"
12:51:08 <byorgey> no, I think there actually is.
12:51:24 <Qwl> Yeah I understand the point-free topology parallel
12:51:24 <byorgey> it comes from the category theory idea of doing everything in terms of arrows
12:51:34 <byorgey> and category theory originally arose out of topology.
12:51:55 <monochrom> well I think that's very stretched
12:52:05 <byorgey> well, I don't.
12:52:13 <ion> TWSS
12:52:14 <Qwl> http://en.wikipedia.org/wiki/Pointless_topology
12:52:21 <Qwl> Check it
12:52:44 <Qwl> And you can have a topology over a set of functions
12:53:22 <Qwl> Depending on the properties they have
12:53:29 <byorgey> Qwl: anyway, there *are* connections between topology and haskell but they don't really correspond to the notion of 'point-free'.
12:53:44 <Qwl> Uh yeah it does
12:53:54 <monochrom> it's of the calibre of: Kasparov can play Chess blindfolded, Euler could factor numbers blindfolded, then suddenly you say there is a parallel between Chess and factoring numbers
12:53:55 <mgsloan> the main criticism of my pointless plumbers is that they don't give any additional abstraction power, but I don't think regular point free style gives any additional power
12:54:00 <Qwl> The variables or 'points' are exactly what points are in topology
12:54:33 <mgsloan> all it does is make referentially-transparent substitutions require less parameter substitutions, therefore can allow for somewhat more straightforward manipulation
12:54:44 <byorgey> monochrom: no, it would be like if Euler could factor numbers blindfolded and then later people noticed that Chess is really just a specialized kind of factoring.
12:55:06 <byorgey> and hence started calling Kasparov's feat the same as Euler's.
12:55:38 <monochrom> if there is any parallel, it is not because of the blindfolded part
12:55:52 <Qwl> I have a feeling people are getting really defensive here :X
12:55:55 <byorgey> Qwl: yes, I know.  that's not what I meant.  Just a minute, let me find you some links
12:56:25 <Qwl> I'm merely trying to approach Haskell from my mathematical background so that I can look at programming in a different mindset
12:56:39 <monochrom> I am the only defensive one here. everyone else just agrees with each other.
12:56:49 <mgsloan> Qwl: if you're saying that because of my comments, I'm just throwing in my 2 cents that I haven't yet thrown into a blog post
12:56:52 <ski> monochrom : there's "Y Combinator in Haskell" <http://r6.ca/blog/20060919T084800Z.html> of course ..
12:57:32 <nart> is it possible to add -Wall as a pragma ?
12:57:42 <tgeeky_> nart: yes
12:57:56 <byorgey> Qwl: http://xorshammer.com/2011/07/09/a-logical-interpretation-of-some-bits-of-topology/
12:57:56 <ByronJohnson> nart: The means of doing so is implementation specific
12:58:06 <ByronJohnson> nart: For GHC, you use the OPTIONS_GHC pragma
12:58:29 <chrisdone> generally just {-# OPTIONS -Wall #-}
12:58:43 <nart> thanks
12:59:06 <byorgey> Qwl: also, read up on Scott topology, Scott-continuous functions, etc.
12:59:17 <byorgey> Qwl: http://en.wikipedia.org/wiki/Scott_continuity
12:59:18 <Qwl> Thanks
12:59:39 <ski> byorgey : heh, a comment mentions "Topology Via Logic" by Steven Vickers, which i was just about to suggest :)
12:59:47 <mgsloan> Someone should give me an interesting chunk of code to make look like this www.mgsloan.com/mockup5.png
13:00:23 <lolwat> I`m having some trouble building the latest haskell platform,  network-2.3.0.5 fails to build. Any idea what that could be?
13:02:45 <monochrom> if you have a clean start, it should build fine. the haskell platform people have tested it.
13:02:57 <killy9999> does Haskell provide some standard data types like dates, days of the week, etc. or do I have to reinvent the wheel?
13:03:13 <killy9999> lolwat: what's the error message?
13:03:14 <monochrom> look for Data.Time
13:03:16 <ByronJohnson> killy9999: I'd take a look at the time package
13:03:21 <killy9999> perhaps a missing devel package?
13:03:24 <mikkihiiri> how can i cast Ord to Integral?
13:03:36 <dcoutts> donri, chrisdone: yes, still working on "cabal repl". Making progress.
13:03:58 <mikkihiiri> what i mean is that i can't return maximum from list if the return value in header is Integral
13:04:12 <monochrom> Ord cannot be cast to Integral
13:04:20 <ciaranm> why would code run faster when the data types are hidden in a module rather than in the same file?
13:05:18 <mikkihiiri> monochrom: so I'm forced to use int in my function?
13:05:32 <monochrom> no
13:05:49 <roconnor> Data.Time.Calendar.Easter.sundayAfter -- The next Sunday strictly after a given day.
13:07:01 <swarley> i just have a random question, sorry if it sounds stupid. but what is literate haskell?
13:07:05 <mikkihiiri> monochrom: then what?
13:07:13 <killy9999> Data.Time.Format seems to be what I'm looking for :)
13:07:14 <monochrom> I thought Integral already subsumes Ord?
13:07:38 <ciaranm> swarley: it's where everything is a comment except for things marked as code, as opposed to the usual way around
13:07:49 <mikkihiiri> pasting four lines of code.. sorry
13:07:53 <monochrom> @type \x -> quot x x > x
13:07:54 <lambdabot> forall a. (Integral a) => a -> Bool
13:07:59 <mikkihiiri> test :: (Integral a) => [a] -> a
13:07:59 <mikkihiiri> test [] = error "empty"
13:07:59 <mikkihiiri> test (x:[]) = x
13:08:00 <mikkihiiri> test (x:xs) = max (x:xs)
13:08:09 <mikkihiiri> the upper does not work...
13:08:10 <ciaranm> swarley: literate programming was invented in the olden days before people used long variable names and knew that documenting APIs is good and documenting internals is bad
13:08:19 <swarley> oh i see
13:08:20 <monochrom> "max (x:xs)" is an error
13:08:30 <mikkihiiri> what should it be?
13:08:48 <monochrom> max x (test xs) ?
13:09:11 <monochrom> maximum (x:xs) ?
13:09:36 <monochrom> anyway clearly "Ord vs Integral" is barking up the wrong tree
13:10:11 <mikkihiiri> well then what about this:
13:10:15 <mikkihiiri> getLongestSuccessorList :: [Int] -> Int
13:10:15 <mikkihiiri> getLongestSuccessorList [] = 0
13:10:15 <mikkihiiri> getLongestSuccessorList (x:[]) = 1
13:10:16 <mikkihiiri> getLongestSuccessorList (x:xs) = max (length (getFirstSuccessorList (x:xs))) (getLongestSuccessorList xs)
13:10:31 <mikkihiiri> works fine like that.. if I change it to Integral it stops working
13:10:50 <monochrom> because length blah is an Int, it's pinned
13:10:54 <monochrom> @type length
13:10:55 <lambdabot> forall a. [a] -> Int
13:10:59 <dmwit> :t genericLength
13:11:00 <lambdabot> forall b i. (Num i) => [b] -> i
13:11:31 <geekosaur> or just use fromIntegral
13:11:37 <swarley> i think im going to give haskell another try, anyone want to recommend a good book or tutorial? I tried reading the language specification a while back, but i couldnt learn from it
13:11:44 <dmwit> For future long pastes, please use hpaste.org or a similar paste-site.
13:11:58 <mikkihiiri> fromIntegral seems to work! Thanks a ton!
13:12:01 <dmwit> swarley: RWH, LYAH, and the Gentle Intro are all excellent.
13:12:10 <monochrom> @where LYAH
13:12:11 <mikkihiiri> finally finished this!
13:12:11 <lambdabot> http://www.learnyouahaskell.com/
13:12:32 <dmwit> swarley: lambdabot knows where they all are, just ask her as monochrom did.
13:12:41 <swarley> i bought LYAH maybe i should read that more
13:12:46 <swarley> @where RWH
13:12:46 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:13:01 <ski> swarley : also, ask in this channel :)
13:13:25 <killy9999> and is there a way to construct a data type that is enumeration of numbers from some given range?
13:13:43 <killy9999> s/numbers/integers
13:14:06 <monochrom> no
13:15:13 <ski> mikkihiiri : `getLongestSuccessorList :: Integral a => [a] -> Int' would probably also work fine
13:15:28 <killy9999> then I'm thinking the wrong way I guess
13:16:22 <monochrom> I disagree that documenting internals is bad. I only agree on where it should belong.
13:16:46 <chrisdone> i like the X.Internal module style
13:17:06 <chrisdone> like this http://chrisdone.com/ji/doc/html/ji/Graphics-UI-Ji-Internal-Types.html
13:17:34 <dmwit> killy9999: It's common to write a new data type like data Foo = A | B | C if it's a small range, and an abstract data type with smart constructors if it's a large (but still static) range.
13:17:50 <dmwit> killy9999: Dynamic ranges are harder, though having an abstract data type with a good interface can still help.
13:18:05 <xplat> mgsloan: did you see my https://github.com/xplat/potpourri/blob/bfe6f85d4124b7d50246b80505ade1ad0dfd66aa/Golforth.hs ?
13:18:06 <dmwit> killy9999: For static checks, you'll need a dependently typed language, like Agda or Coq.
13:18:08 <monochrom> there is too much religion about "readable" code. any highly optimized code is going to defy that religion. at that point, you will have to explain how you get to the highly optimized code and why it still gives the right answer. that's internal documentation.
13:18:52 <monochrom> you shouldn't expose it to end users (they don't care anyway), but you should still put it somewhere, as either comments or literate haskell
13:18:56 * mgsloan likes the idea of their being a naive reference impl in those cases
13:19:13 <mgsloan> * there
13:20:25 <monochrom> example: http://sources.redhat.com/cgi-bin/cvsweb.cgi/libc/string/strlen.c?rev=1.1.2.1&content-type=text/x-cvsweb-markup&cvsroot=glibc
13:21:14 <ivanm> chrisdone: nope
13:21:38 <mgsloan> xplat: awesome!  Not sure if I've seen yours in particular, but I did see the recent conversations about creating simply lifted, statically typed stack DSLs
13:22:17 <roconnor> @quote Stack_Calculator
13:22:18 <lambdabot> No quotes match. :(
13:22:22 <roconnor> @quote StackCalculator
13:22:22 <lambdabot> StackCalculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
13:22:33 <chrisdone> ivanm: TRY IT!!
13:22:45 <ivanm> about to go and tutor!!!
13:22:52 <chrisdone> ivanm: what you tutoring?
13:23:34 <killy9999> can anyone give me an example how to use parseTime or readTime from Data.Time.Format?
13:23:52 <ivanm> first year Haskell
13:26:03 <monochrom> hrm, you first need a TimeLocale value. I would start with defaultTimeLocale (System.Locale, package "old-locale")
13:26:18 <killy9999> yes, I used that
13:26:42 <killy9999> I'm experimenting, just got the monomorphism restriction error...
13:26:56 <dmwit> kallisti: parseTime defaultTimeLocale "%H" "12" :: Maybe UTCTime -- for example
13:26:59 <dmwit> eh
13:27:04 <dmwit> killy9999: That was meant for you.
13:27:13 <monochrom> then try: parseTime defaultTimeLocale "%m/%d/%y" "3/27/2012"
13:27:44 <monochrom> actually, parseTime defaultTimeLocale "%m/%d/%y" "3/27/2012" :: Day
13:28:22 <monochrom> of course there are many other types instead of Day you can use. any instance of ParseTime is fine
13:28:29 <killy9999> mhm
13:28:31 <chrisdone> > length "import Data.Default;parseTime def" > length "parseTime defaultTimeLocale"
13:28:32 <lambdabot>   True
13:28:35 <killy9999> I'll check that
13:28:37 <chrisdone> > length "import Data.Default;parseTime def" - length "parseTime defaultTimeLocale"
13:28:38 <lambdabot>   6
13:29:06 <monochrom> oh, sorry, not Day. it's a Maybe type
13:29:14 <monochrom> parseTime defaultTimeLocale "%m/%d/%y" "3/27/2012" :: Maybe Day
13:29:28 <dmwit> chrisdone: Wait, is there a Default instance for TimeLocale in there?
13:29:44 <monochrom> oh haha, that is Nothing, and rightfully so. %m wants two digits
13:30:02 <monochrom> and %y, 2 digits too, not 4
13:30:11 <dmwit> I don't have one.
13:30:15 <monochrom> parseTime defaultTimeLocale "%m/%d/%y" "03/27/12" :: Maybe Day
13:30:28 <chrisdone> dmwit: not in Data.Time. i asked for it in GHC but they rejected the ticket. i asked mauke to add it to Data.Default by email some weeks ago and didn't get a reply. so atm, doing it ourselves…
13:30:39 <monochrom> that results in "Just 1912-03-27". \∩/ for Y2K bugs!
13:31:29 <Botje> Y2K bugs are SO 1999.
13:31:52 <killy9999> OK, works, but holy cow - every single thing I need is in different module :/
13:32:10 <monochrom> just import everything
13:32:26 <monochrom> actually only two imports: Data.Time, System.Locale
13:32:26 <xplat> import * doesn't work :(
13:33:24 <killy9999> well, true - I was importing Data.Time.Format and Data.Time.Clock separately
13:33:33 <killy9999> so
13:33:35 <killy9999> parseTime defaultTimeLocale "%m/%d/%y" "13/27/2012" :: Maybe Day
13:33:58 <killy9999> sorry
13:34:01 <killy9999> I meant parseTime defaultTimeLocale "%m/%d/%y" "03/27/2012" :: Maybe Day
13:34:06 <killy9999> why does this produce Nothing?
13:34:18 <Clint> because your y is in the wrong case
13:34:29 <killy9999> mhm
13:34:34 <xplat> use %Y
13:34:39 <monochrom> as said, %y wants 2 digits, Y2K etc
13:34:45 <killy9999> gotcha
13:35:35 <McManiaC> how can I figure out why I get a buffer overrun?
13:35:47 <McManiaC> or stack space overflow
13:36:06 <monochrom> I wonder why %m insists on 2 digits
13:36:26 <ski> instead of at most ?
13:36:36 <Clint> because delimiters aren't guaranteed?
13:36:37 <monochrom> right, it rejects "3/27/12"
13:37:04 <ski> @hoogle scanf
13:37:05 <lambdabot> No results found
13:37:46 <monochrom> well, my real question is, %m insisting on 2 digits is fine, but there is not another format string for 1-or-2 digits
13:38:32 <monochrom> oh, there is, I just haven't read the whole doc
13:39:04 <McManiaC> can anyone see why this loop would case a stack space overflow? it should run in constant memory, shouldn't it? http://npaste.de/Urx/
13:39:27 <McManiaC> the other functions are pretty much basic list manipulations only
13:39:33 <chrisdone> there better not be laziness on this paste
13:40:03 <McManiaC> there probably is :S
13:40:09 <monochrom> no, there isn't. I thought "%-m" would be it, but no
13:41:05 <monochrom> the use of StdGen already adds laziness
13:41:29 <killy9999> yeap, just checked the same thing
13:41:35 <killy9999> %-m doesn't work
13:42:17 <Enigmagic> monochrom: unless it's improved recently, there isn't a way to parse months without a leading 0
13:42:25 <Enigmagic> i wrote my own parser instead :P
13:42:38 <dmwit> McManiaC: Make loop strict in l, or else you'll have a huge stack of if statements.
13:43:08 <dmwit> ...I think.
13:43:24 <dmwit> (It seems to already be strict in step, so that's good.)
13:43:25 <monochrom> and in g'', or else you'll have a huge thunk of StdGen usages
13:43:40 <dmwit> Yeah, probably.
13:44:02 <McManiaC> dmwit: that's a simple (!l) instead of "l" in the argument list, right?
13:44:08 <elliott> !l
13:44:10 <elliott> no need for parens
13:44:33 <McManiaC> dmwit: it doesnt overflow anymore, but still uses a couple of hundred MBs of ram
13:44:43 <McManiaC> so there probably is still some mem leak :(
13:44:58 <monochrom> what I said
13:45:14 <monochrom> and I refuse to call it a leak
13:45:16 <McManiaC> monochrom: ah ok
13:45:29 <timthelion> Is there any preformance difference between a recursive String building function f (x:xs) = x ++ (f xs) f [] = "" and a foldr (++) (map f' xs) f' x = x
13:45:32 <timthelion> ?
13:46:05 <McManiaC> monochrom: is there a strict randomgen?
13:46:08 <timthelion> on finite lists that is...
13:46:38 <monochrom> no, and I doubt if it would help
13:47:31 <cruelbob> hey
13:48:06 <timthelion> cruelbob: yeh
13:48:16 <McManiaC> monochrom: so... I have to live with it?
13:49:50 <cruelbob> do somebody know how to make a polyvariadic function?
13:50:02 <monochrom> interesting, I think there is a little trick we can do. a wrapper that makes things more eager. it is rare.
13:50:04 <killy9999> McManiaC: perhaps you could rework the algorithm not to use Stdgen explicitly
13:50:15 <timthelion> cruelbob: Does that mean, a function with multiple variables?
13:50:18 <killy9999> but I'm not sure if this would work
13:50:43 <McManiaC> killy9999: how? the only alternative I see is randomRIO and I doubt that's going to run smoother
13:51:00 <dmwit> timthelion: Well, for one thing, your recursive function doesn't use f.
13:51:05 <cruelbob> overloads of functions with different number of arguments
13:51:26 <dmwit> cruelbob: Look at how printf works.
13:51:27 <timthelion> dmwit: they should give the same output, f and the foldr
13:51:40 <elliott> cruelbob: You probably shouldn't. But what dmwit asid.
13:51:40 <dmwit> timthelion: f is id restricted to lists.
13:51:41 <elliott> said.
13:51:43 <dmwit> oh
13:51:51 <dmwit> No, f is concat, restricted to [String].
13:52:08 <monochrom> wrap d@(x,y) = x `seq` y `seq` d
13:52:20 <dmwit> And the other thing doesn't type-check.
13:52:35 <timthelion> dmwit: well my real function does a lot more than that.  It takes a tuple and adds some grammar around the bits before spitting them out.
13:52:55 <dmwit> Why don't you ask your real question?
13:53:03 <dmwit> "Is there a difference between these?" is too vague.
13:53:06 <monochrom> so for example you can write: let (i, g'') = wrap (randomR (0,1) g')
13:53:21 <rwbarton> wouldn't you still need a !
13:53:58 <monochrom> if you use i, g'' is also evaluated. or if you use g'', i is also evaluated
13:54:05 <timthelion> dmwit: I try to simplify my situation so I'm not asking you "How best would you write my program?"
13:54:15 <timthelion> dmwit: the foldr doesn't type check? Why?
13:54:23 <rwbarton> oh true, that may help
13:54:27 <monochrom> I don't need a ! there, I have handwritten seq's
13:54:30 <rwbarton> I was thinking adding !s before i and g''
13:54:32 <dmwit> timthelion: Because you're using f' as both a function and a list.
13:54:42 <dmwit> ...and then writing an equation... (?)
13:54:47 <elliott> timthelion: we'd really rather hear the X than the Y
13:54:53 <dmwit> timthelion: Anyway, why don't you identify the metrics that matter to you, to begin with?
13:55:10 <dmwit> Any two pieces of code that aren't byte-identical are different by some metric.
13:55:15 <timthelion> foldr (++) (map f' xs) where f' x = x, better?
13:55:47 <timthelion> dmwit: not necessarilly for example (a b c) === $ a b c
13:55:50 <ski> timthelion : s//[] / ?
13:55:52 <dmwit> timthelion: Perhaps you meant foldr (++) [] (map f' xs), in which case it's still just concat and you should just use concat.
13:55:57 <McManiaC> monochrom: hmmm doesn't change anything really
13:56:09 <ski> @pl foldr (++) []
13:56:09 <lambdabot> foldr (++) []
13:56:17 <dmwit> timthelion: No, a b c === ($) a b c is not correct. For one thing, they're not alpha-equivalent.
13:56:18 <timthelion> dmwit: oh, you're right, I'm an idiot!!!
13:56:18 <ski> @botsmack
13:56:18 <lambdabot> :)
13:56:41 <timthelion> dmwit: I meant concatMap f' xs... Sorry
13:56:49 <monochrom> the main laziness (and the only one you can solve) of StdGen is that in (x,g1) = random g0, g1 is postponed, even if you evaluate the tuple, even if you evaluate x. my wrapper fixes that exactly.
13:56:50 <timthelion> somehow I totally brain farted there.
13:56:58 <elliott> :t concatMap id
13:56:59 <lambdabot> forall b. [[b]] -> [b]
13:57:00 <elliott> aka concat
13:57:30 * ski joins the list
13:57:39 <timthelion> dmwit: alpha-equivalent?
13:57:58 <timthelion> dmwit: I wanted to know if there was a significant preformance difference.
13:57:59 <killy9999> McManiaC: perhaps randoms function would be useful?
13:58:29 <killy9999> I don't know, as I said this requires rewriting of code
13:58:30 <timthelion> since we "build the list" then rewrite the list concatinated, rather than just building it in it's concatinated form in the first place
13:59:12 <McManiaC> killy9999: randoms uses the same tuple/new randomgen thing I use
13:59:22 <McManiaC>   randoms  g      = (\(x,g') -> x : randoms g') (random g)
13:59:45 <killy9999> mhm, so it's not internally optimized...
13:59:48 <McManiaC> obviously, written like that it requires lazyness
13:59:51 <rwbarton> (\(x,y) -> ...) z is not the same as let (x,y) = z in ... though
13:59:58 <killy9999> yes, of course
14:00:10 <killy9999> @src randoms
14:00:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:00:27 <killy9999> @src System.Random.randoms
14:00:27 <lambdabot> Source not found. stty: unknown mode: doofus
14:00:57 <killy9999> oh well, no more ideas for today
14:01:06 <McManiaC> I could write my own randomgen ^^
14:01:10 * killy9999 goes to sleep
14:01:15 <monochrom> randoms is a class method. you will have to look at StdGen source
14:01:28 <monochrom> err, no, nevermind
14:01:40 <McManiaC> randoms is a standard definition though
14:01:55 <monochrom> yeah, and you have already shown it
14:38:05 <epsil> how do I sort a list of tuples by the second element in the tuple?
14:38:08 <chrisdone> Deep… in the Haskellian rainforest. The eldest of the tribe are sleeping, regaining their strength for the day of abstraction hunting that lies ahead. Observe the small functionista, which rests its head against a pile of carefully arranged lambdas—she sleeps with her Arrows in reach.
14:38:20 <chrisdone> damn it! you ruined my silence breaker!
14:38:32 <chrisdone> sortBy (comparing snd)
14:38:44 <epsil> chrisdone: sorry :S
14:38:46 <epsil> and thanks
14:38:48 <chrisdone> :p
14:39:26 <Cale> epsil: that's assuming they're pairs btw.
14:40:49 <chrisdone> if they're not pairs then you *cough* the *cough* with *cough*, alright? good.
14:41:08 * chrisdone brushes the ugly side of haskell under the carpet while nobody's looking
14:43:22 <Cale> Well, if they're not pairs, you can just use a lambda with a pattern match in it
14:43:33 <Cale> comparing (\(x,y,z) -> y)
14:44:02 <epsil> and returning GT, LT and EQ as appropriate?
14:44:53 <DMcGill> :t comparing
14:44:54 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:44:57 <chrisdone> comparing does that
14:45:17 <DMcGill> > comparing snd (2,3) (1,5)
14:45:18 <lambdabot>   LT
14:46:19 <Cale> Another thing perhaps worth pointing out is that there's a really nice monoid instance on Ordering (and there's a pointwise monoid instance for functions)
14:46:44 <Cale> If the left argument to mappend is LT or GT, then that's the result, otherwise, it's the right argument
14:46:47 <Cale> that is,
14:46:56 <Cale> EQ `mappend` y = y
14:47:03 <Cale> x `mappend` y = x
14:47:32 <Cale> which lets you do things like this:
14:47:56 <Ownez> good night, looking for someone with knowledge on jess
14:47:57 <Cale> > sortBy (comparing length `mappend` compare) (words "here are some words to sort by length and then alphabetically")
14:47:58 <lambdabot>   ["by","to","and","are","here","some","sort","then","words","length","alphab...
14:48:12 <donri> > (compare `on` snd) (2,3) (1,5)
14:48:13 <lambdabot>   LT
14:48:32 <shachaf> If only lambdabot had a short, infix name for mappend!
14:48:33 <chrisdone> Cale: that is nice
14:48:35 <magicman> Huh. I never could make sense of instance Monoid Ordering. Thanks for the example, Cale.
14:49:24 <teneen> The "interact" function does not work for me, can someone also confirm this?
14:49:26 <chrisdone> that particular example is the function instance
14:49:43 <chrisdone> teneen: words fine i used it today. maybe you should use mine?
14:49:45 <donri> teneen: got example code?
14:50:01 <magicman> That's instance Monoid (a -> a -> Ordering), based on instance Monoid (a -> Ordering), based on instance Monoid Ordering.
14:50:07 <Cale> right
14:50:53 <donri> hm, was <> mappend or mplus in new base?
14:51:21 <teneen> donri: interact reverse
14:51:40 <teneen> chrisdone: Which?
14:51:41 <donri> teneen: is the input finite?
14:51:48 <teneen> donri: yes
14:51:51 <DMcGill> @src (<>)
14:51:51 <lambdabot> Source not found. You untyped fool!
14:51:55 <teneen> donri: GHC 7.4.1
14:52:06 <chrisdone> i don't remember whether it was <+> or <> for monoid
14:52:11 <rwbarton> teneen: what does "does not work" mean
14:52:18 * chrisdone uses ++, am i right, haters?
14:52:34 <teneen> rwbarton: it never outputs, it just keeps accepting the input
14:52:38 <donri> i think i use mplus for ++
14:52:41 <rwbarton> of course
14:52:55 <teneen> rwbarton: I tried changing the buffering, but with no success
14:52:55 <Enigmagic> i use (.) for mappend
14:52:55 <chrisdone> :t (++)
14:52:56 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:53:03 <rwbarton> what are you expecting?
14:53:10 <rwbarton> interact passes the entire contents of stdin to your function
14:53:14 <chrisdone> Cale's on my side. got my back
14:53:21 <rwbarton> it's not line based for instance
14:53:32 <rwbarton> so...
14:53:32 <donri> but stdin is finite after EOF?
14:53:40 <Cale> I like ++ for mappend
14:53:41 <rwbarton> it sounds like he is never sending EOF
14:53:45 <donri> teneen: try ctrl+d
14:53:59 <Cale> It would be nice to promote the usage of monoid instances a bit more
14:54:09 <Cale> mappend is such an ugly and awkward name
14:54:16 <teneen> rwbarton: I change the buffering to LineBuffering and it still didn't work. I also trie NoBuffering
14:54:19 <chrisdone> yeah
14:54:25 <rwbarton> ...
14:54:31 <c_wraith> teneen: sounds like the function you're using isn't lazy
14:54:39 <chrisdone> monoids are cute in config files
14:54:42 <rwbarton> he said he is doing "interact reverse"
14:54:43 <chrisdone> s/files/values
14:54:53 <c_wraith> reverse is certainly not lazy
14:54:56 <donri> <elliott> |\/|/-\|-|-|=|\||} is my preferred mappend operator
14:54:57 <rwbarton> teneen: so...
14:55:14 <rwbarton> it needs to wait for the last line, before it can start producing any output...
14:55:35 <teneen> c_wraith: What's and example of a function which will work?
14:55:48 <c_wraith> teneen: a simple test is « id »
14:55:50 <teneen> c_wraith: but reverse works perfectly well when I use it with "getLine"!
14:55:59 <chrisdone> has anyone in here made a semantic wiki which uses a wysiwym instead of markup and saves to xml/json/a db?
14:56:01 <rwbarton> getLine gets a line
14:56:03 <rwbarton> no mystery here
14:56:04 <donri> "interact reverse" should work for piping finite data to the program
14:56:12 <rwbarton> interact gets the entire input
14:56:44 <teneen> c_wraith: id works
14:56:49 <rwbarton> if you don't hit ctrl-D or read from a file or let the program know that it is done reading from input... how can it produce output
14:56:55 <c_wraith> teneen: you could also do something like « interact $ map reverse . lines »
14:56:57 <teneen> c_wraith:but it's of no use :)
14:57:10 <chrisdone> i may have to add it to my project stream. too many projects ;_;
14:57:12 <donri> $ echo hello | ghc -e "interact reverse"
14:57:13 <donri> ^ that works
14:57:29 <c_wraith> oh, wrong type
14:57:52 <c_wraith> teneen: err, this instead « interact $ unlines . map reverse . lines »
14:57:59 <c_wraith> :t unlines
14:58:00 <lambdabot> [String] -> String
14:58:02 <c_wraith> yeah
14:58:09 <TheMG> is there some way to create a datatype formed only of certain strings?
14:58:20 <TheMG> such that i could create a function that only accepted those
14:58:31 <chrisdone> sure, use a newtype and smart constructors
14:58:42 <elliott> donri: hi
14:58:46 <donri> :)
14:58:47 <kaitocracy> can someone explain to me the difference between return and lift?
14:59:04 <elliott> :)
14:59:26 <ski> @let onLines :: ([String] -> [String]) -> (String -> String); onLines f = unlines . f . lines
14:59:28 <lambdabot>  Defined.
14:59:36 <chrisdone> lift is from MonadTrans for putting one monad in another
14:59:50 <ski> @let perLine :: (String -> String) -> (String -> String); perLine f = onLines (map f)
14:59:51 <lambdabot>  Defined.
14:59:54 <chrisdone> return is completely different, it just makes a value of some monad instance
14:59:59 <chrisdone> ski: hahaha
15:00:05 <chrisdone> ski: i was thinking of the EXACT same abstraction
15:00:12 <chrisdone> but thinking more of "with"
15:00:13 <ski> @type (interact . perLine) reverse
15:00:13 <kaitocracy> chrisdone: so return puts a value in a monad, and lift puts a monad in another monad?
15:00:14 <lambdabot> IO ()
15:00:34 <chrisdone> ski: the same pattern arises in here…
15:00:42 <ski> chrisdone : see conals <http://www.haskell.org/haskellwiki/TV#IO>
15:00:47 <chrisdone> > reverse . dropWhile isSpace . reverse . dropWhile isSpace $ "  hello world  "
15:00:48 <lambdabot>   "hello world"
15:01:39 <chrisdone> hey rtharper, where in the world are you now?
15:01:47 <rtharper> still Oxford =)
15:01:55 <chrisdone> kaitocracy: that sums it up in plain english yeah
15:02:34 <ski> kaitocracy : s/puts a value in a monad/puts a value in a monadic *action*/
15:02:36 <chrisdone> kaitocracy: probably you can ask more questions to find out the info. that's stopping you understanding the difference
15:02:37 <ski> kaitocracy : s/puts a monad in another monad/puts a monadic *action* in another monadic *action*/ (in fact in one whose monad is the monad of the previous one wrapped in a monad transformer)
15:02:47 <rwbarton> it would be better to say something like -- "lift" takes an action in the monad m and turns it into an action in the monad t m (which won't have any effects of the kind added by t)
15:03:07 <teneen> Thanks guys for the help :)
15:03:17 <rwbarton> while "return" takes a value and turns it into an action in a monad m (which won't have any effects at all)
15:03:17 <chrisdone> rtharper: ah. i saw a bunch of posts about learning… was it finnish?
15:03:22 <ski> kaitocracy : `return a' for a monad `m' is a monadic action that does no `m'-effects
15:03:25 <rtharper> chrisdone: no
15:03:33 <rtharper> chrisdone: I have been learning Swedish
15:03:35 <chrisdone> rtharper: i'm mistaking you for someone else?
15:03:38 <rtharper> chrisdone: and I speak Icelandic
15:03:45 <rtharper> so I post regularly in those languages
15:03:46 <chrisdone> ahh, heh, that's the confusion
15:04:09 <chrisdone> just for fun? :)
15:04:11 <ski> kaitocracy : `lift ma' for a monad transformer `m', given that `ma' is a `m'-action for a monad `m', is a monadic action that does no `t'-specific effects, only the `m'-effects present in `ma'
15:04:12 <Philippa> ski: I actually disagree with your usages there, FWIW
15:04:27 <ski> Philippa : elaborate ?
15:04:44 <rtharper> chrisdone: there's a chance I'll be living in Sweden by the end of the year, but yes, in general, for fun
15:04:48 <rwbarton> lift and return are actually somewhat related in this way, particularly if you replace return by return' :: Identity a -> m a
15:05:14 <Philippa> (they clash with the classic use of 'lifting', and if we're in nitpick mode then "putting into a monadic action" is pretty unspecific too)
15:05:15 <chrisdone> again, it's probably better to let kaitocracy to ask more questions rather than throwing factoids at him
15:05:30 <ski> rtharper : "Mastering Swedish - Part 1" <http://www.slayradio.org/home.php?news_item=15>
15:05:35 <Philippa> and yeah, ignore my nitpick to the extent it's not helping kaitocracy for now
15:05:36 <rwbarton> this is exactly an answer to his question
15:05:36 <rtharper> ski: have seen it, hehe
15:06:30 <rtharper> ski: I think my fave is, "Far, får får får? Nej, får får lamm"
15:06:41 <chrisdone> rtharper: ahh. :-) i might end up in sweden in june. from what i've seen swedish is a lot easier than italian
15:06:43 <ski> Philippa : well, which part of what i said did you disagree with ?
15:06:53 <Philippa> kaitocracy: I tend to think of lift as "accessing the underlying monad [that this one's built on top of]"
15:07:32 <rtharper> chrisdone: I think they're both pretty easy... Swedish pronunciation is much more challenging, but the tenses are more basic, as is verb conjugation (although noun pluralisation and gender is far less transparent)
15:07:50 <donri> får *får* får, fårskalle.
15:07:59 <ski> rtharper : yeah, that one's an old .. hm, "tongue-twister" isn't quite the right term, i think
15:08:11 <monochrom> lip-twister :)
15:08:29 <Philippa> ski: "putting into actions", basically
15:08:29 <monochrom> mouth-distorter :)
15:08:37 <rtharper> no, "Sju sjösjuka sjömän sköttes av sju sköna sjuksköterskor" is a tongue twister
15:09:06 <donri> typiskt västkustskt
15:09:07 <monochrom> saliva-propeller :)
15:09:09 <ski> rtharper : right, hence the "isn't quite the right term"
15:09:14 <rtharper> hehe
15:09:32 <Philippa> the problem is, /I/ know what you mean. I'm also definitely too tired to explain the semantic nitpick 'mafraid
15:10:06 <donri> chrisdone: hey where in swe?
15:10:09 <ski> Philippa : ok, that part i just borrowed from what kaitocracy said, focusing on fixing the more important terminology problem aisi :)
15:10:11 <Philippa> (but "return lifts a value into the monad" is old, well-established usage)
15:10:13 <chrisdone> rtharper: yeah i heard verb conjugation is "familiar" in the big three scandinavian languages to an english speaker. (in fact i've heard it claimed norwegian is the easiest language to learn for an english speaker) pronunication… fun :)
15:10:43 * ski wants to keep clear the distinction between "monad" and "monadic action"
15:10:45 <chrisdone> donri: stockholm
15:10:53 <rtharper> chrisdone: Many people claim Icelandic is extremely hard to learn, for example, but I found its pronunciation *far easier* than Swedish's
15:11:03 <rtharper> but Norwegian is a bit easier...
15:11:18 <donri> chrisdone: haskell?
15:11:20 <Philippa> *nod*. Yeah, kaitocracy's line was out of scrollback range. I see the problem as more than the usage is fine re return, but not re lift
15:11:20 <chrisdone> ski: betwen the type and the value? sure. i prefer monadic value, but you're the category theorist here :p
15:11:30 <Philippa> (it lifts the action into the other monad)
15:12:05 <chrisdone> donri: yush. that's a maybe, anyway. otherwishe, could be schtaying in the netherlandsch
15:12:06 <edwardk> preflex: xseen tibbe
15:12:08 <preflex>  tibbe was last seen on freenode/#ghc 6 hours, 11 minutes and 58 seconds ago, saying: * tibbe gotta work
15:12:14 <ski> Philippa : aye
15:12:19 * chrisdone loves how dutch people pronounce 's'
15:12:33 <luite> s?
15:12:49 <edwardk> @ask tibbe would it be possible to add an instance Hashable (Ptr a) -- just to hash the pointer itself, (not the contents)
15:12:49 <lambdabot> Consider it noted.
15:13:18 * hackagebot sandlib 0.0.1 - SAND data serialization and manipulation library  http://hackage.haskell.org/package/sandlib-0.0.1 (MahmutBulut)
15:13:44 <chrisdone> rtharper: yeah… didn't Daniel Tamet learn Icelandic because it is said to be one of the heardest languages in the world? :-) congrats on pronouncing *that*! i heard there is a legitimate sound which is a nasal snort of sorts :p
15:14:06 <rtharper> chrisdone: there are voiceless nasals, yes.  They're not that hard =p
15:14:45 <hpaste> nh2 pasted “why does force kill parallelism” at http://hpaste.org/66082
15:15:08 <elliott> edwardk: can you get an address from a ptr?
15:15:21 <elliott> seems ugly if not
15:15:23 <edwardk> elliot: i can ptrToIntPtr it to get an integral value
15:15:27 <elliott> ah
15:15:29 <elliott> fair enough then
15:15:39 <nh2> hey, can somebody explain me why my `par`allelism goes away if I use force to obtain the chunks to work on? http://hpaste.org/66082
15:15:39 <edwardk> and then i can fromIntegral it
15:16:58 <gnoi> How can I make module that would be union of another modules? When I use just import, ghci said, that this import is redundant
15:17:39 <Lemmih> gnoi: You have to export it as well.
15:17:52 <kallisti> --enable-library-profiling isn't on by default? are you kidding me?
15:18:10 <acowley> Does anyone have a ConstraintKinds restricted monad library with a work definition of Codensity? I'm fighting things and wouldn't mind if someone else solved this issue already.
15:18:41 <thoughtpolice> kallisti: no, and it's annoying sometimes for sure. the main problem is it doubles compilation time since it must rebuild all modules in profiling mode.
15:18:45 <edwardk> acowley: sadly, no
15:18:54 <thoughtpolice> (similar with dynamic libraries)
15:18:55 <edwardk> acowley: i stopped because i couldn't get product categories in it correctly
15:19:07 <edwardk> acowley: so i punted to 7.6.1
15:19:10 * monochrom contemplates aiming at pasting to hpaste at the right time so that the paste number is 68000, or 68020 etc
15:19:27 <acowley> edwardk: shoot, any advice for what I can do in the meantime?
15:19:31 <edwardk> monochrom: clearly that paste should be an emulator
15:19:46 <edwardk> harangue byorgey to get the feature i need? =)
15:20:04 <edwardk> you're closer, so physical harassment from you might work better than from me
15:20:05 <monochrom> haha 8088 is a lot of spam
15:20:13 <acowley> Yes, that is actually a reasonable request
15:20:48 <edwardk> besides you are armed with all sorts of crazy robot assassins
15:20:53 <acowley> edwardk: do you have an in-development version of such a thing anywhere?
15:21:02 <edwardk> i didn't do codensity in it
15:21:10 <acowley> our crazy robot assassins all seem to depend on motion capture rigs at the moment :(
15:21:45 <acowley> so unless we can lure byorgey into a motion capture setup, I'll have to fall back on the old fashioned verbal haranguing strategy
15:22:05 <edwardk> @hpaste
15:22:05 <lambdabot> Haskell pastebin: http://hpaste.org/
15:22:11 <danharaj> you could send him cookies with strongly worded requests written in frosting
15:22:20 <hpaste> edwardk pasted “for acowley” at http://hpaste.org/66084
15:23:04 <edwardk> i dunno, once you are trapped in a motion capture rig, i think you'd feel pretty vulnerable, so maybe you just need to get him into that and then bring out the bots
15:23:12 <monochrom> what is "force"? I can't find it
15:23:44 <acowley> If he'd sit really still on a small table we could use a surgery robot on him! We could poke him with q-tips with great precision.
15:23:48 <edwardk> acowley: that version has product categories and is polykinded and is restricted
15:24:17 <edwardk> acowley: but you can't build polykinded functor composition in that framework
15:24:21 <edwardk> rather you can
15:24:21 <gnoi> Lemmih: what do you mean "export well"?
15:24:30 <edwardk> but you can't make the category of small categories
15:24:32 <monochrom> q-tips and great precision are oxymoron
15:24:43 <macobo> ...
15:25:01 <acowley> edwardk: I'm just wrestling with making sure the right functor context is available in the Codensity wrapping atm
15:25:09 <c_wraith> So, what tool options are available for doing semi-manual mp3 playback from haskell on OS X? I'd like things that give enough flexibility to implement pause/resume..
15:25:12 <aristid> robot assassins, q-tips and polykinded functor composition... typical haskellers
15:25:17 <ski> edwardk : `Sub' ?
15:25:31 <edwardk> ski: thats subtyping
15:25:33 <c_wraith> Do I have options short of SDL?
15:25:49 <ski> edwardk : oh .. /me was thinking "subtraction !?"
15:25:49 <edwardk> c_wraith: wait until i get my objective c bindings written =P
15:26:05 <c_wraith> edwardk: to what, in particular?
15:26:06 <edwardk> ski: nah the :- is entailment
15:26:19 <c_wraith> edwardk: or do you mean generic objc bindings?
15:26:22 <edwardk> c_wraith: right now? i'm after cocoa bindings that don't suck and don't require me to install the universe
15:26:31 <c_wraith> ah.
15:26:44 <danharaj> Is the universe on hackage?
15:26:53 <edwardk> danharaj: yes, its called category-extras
15:26:57 <aristid> edwardk: the universe is already there, no need to install it
15:27:01 <edwardk> that installs a fairly small universe
15:27:05 <edwardk> aristid: deep =)
15:27:12 <aristid> edwardk: no, obvious :P
15:27:13 <c_wraith> now you're getting picky about universe sizes?
15:27:48 <edwardk> c_wraith: not picky, just being clear which universe you are getting. don't want to over sell it ;)
15:28:03 <monochrom> the universe comes with GHC. generally it's a bad idea to re-install anything that comes with GHC
15:28:29 <monochrom> see my blahblah-url-blahblah for more information :)
15:28:43 <c_wraith> does cocoa have a sane audio playback library?
15:28:47 <edwardk> sure, you only get one universe, and you pass it around in every single IO action. if you lose it we have to start all over with a new one.
15:29:05 <elliott> if ghc bundles the universe, what is the platform?
15:29:21 <monochrom> batteries for running the universe
15:29:25 <elliott> :D
15:29:59 <DMcGill> the IO monad can lose a world?!
15:30:04 <monochrom> need some electricity to spark the big bang, afterall. like cars.
15:30:23 <Enigmagic> DMcGill: i like to think of it as misplacing the world, not losing it.
15:30:28 <davean> DMcGill: it actually just gets garbage collected which is far more appropriate
15:30:35 <acowley> You should only make linear use of your universes; take advantage of the many-worlds theory. There are several episodes of Stargate one may consult for reference.
15:30:40 <ski> @where blahblah-url-blahblah
15:30:40 <lambdabot> I know nothing about blahblah-url-blahblah.
15:30:45 <danharaj> I just want to know
15:30:51 <danharaj> what computation forced the evaluation of the universe.
15:31:03 <danharaj> (I will quit Haskell if anyone makes a 42 joke)
15:31:36 <acowley> danharaj: I'd be shocked if it didn't include a use of unsafePerformIO
15:31:45 <DMcGill> surely looking up into the night sky forces at least half the universe's light emmitance to be evaluated
15:32:14 <acowley> Thankfully humans have weak heads, so the evaluation doesn't carry on forever
15:32:28 <monochrom> if you live long enough, you will find out. otherwise, you will be garbage-collected before you find out
15:32:45 <elliott> danharaj: 42 42 42 42 42 42
15:32:49 <elliott> danharaj: see you!
15:33:35 <monochrom> just like in "print (if b || not b then n else n)", n lives long enough to find out, but b doesn't
15:33:41 * DMcGill has quit (Testing the /me command)
15:34:04 <DMcGill> nobody noticed that right?
15:34:14 <danharaj> totally saw that.
15:34:38 <heatsink> Displays in a different color from server messages.
15:34:49 <monochrom> I saw "DMcGill has quit (Testing the /me command)" successfully
15:35:02 <heatsink> I will never learn Haskell.  Every time I think I have learned it, someone adds a new type system extension.
15:35:17 <ezyang> Don't worry, you don't need to know all the type extensions to Haskell to be effective at it.
15:35:24 <kallisti> > reads "2"  -- why does this not complain about ambiguous type variable?
15:35:25 <lambdabot>   []
15:35:31 <monochrom> but you have learned the old ones. isn't that good?
15:35:43 <c_wraith> kallisti: defaulting
15:35:54 <kallisti> to...?
15:35:59 <c_wraith> ()
15:36:03 <monochrom> because God knows whether you want a Char or a Bool or a UTCTime
15:36:05 <heatsink> Yeah, my knowledge has served me well so far.
15:36:27 <danharaj> The grind is pretty much over once you use GADTs and Rank2Types once.
15:36:31 <monochrom> this is the problem with being polymorphic at the return type
15:36:32 <kallisti> I wasn't aware there was ever a case that defaulted to ()
15:36:48 <c_wraith> kallisti: not in the haskell standard.  but there is in ghci
15:36:49 <monochrom> it's the same problem with maxBound. of Int? of Bool?
15:37:00 <kallisti> ahh
15:37:07 <DMcGill> > maxBound
15:37:08 <lambdabot>   ()
15:37:11 <heatsink> > show maxBound
15:37:11 <kallisti> I see
15:37:12 <lambdabot>   "()"
15:37:14 <kallisti> > read "2"
15:37:15 <lambdabot>   Ambiguous occurrence `read'
15:37:15 <lambdabot>  It could refer to either `L.read', defined at ...
15:37:24 <monochrom> @undefine
15:37:29 <kallisti> > read "2"
15:37:29 <monochrom> > read "2"
15:37:30 <lambdabot>   *Exception: Prelude.read: no parse
15:37:30 <lambdabot>   can't find file: L.hs
15:37:41 <monochrom> > read "2"
15:37:42 <lambdabot>   *Exception: Prelude.read: no parse
15:37:44 <kallisti> @let stuff = "things"
15:37:45 <lambdabot>  Defined.
15:38:01 <monochrom> lambdabot has a bit more default. it probably defaults to ()
15:38:06 <monochrom> > read "()"
15:38:07 <lambdabot>   ()
15:38:10 <monochrom> \∩/
15:38:18 <monochrom> ghci has a bit more defaulting, too
15:38:19 <kallisti> you don't say?
15:38:22 <t7> grim reaper ?
15:38:41 <monochrom> @check \x y -> x == y
15:38:42 <lambdabot>   "OK, passed 500 tests."
15:38:45 <monochrom> \∩/
15:38:58 <t7> grim reaper or darth vader
15:39:07 <c_wraith> @check \x -> x == reverse x
15:39:08 <lambdabot>   "OK, passed 500 tests."
15:39:09 <t7> who has their hands up monochrom ?
15:39:22 <monochrom> me. a robot
15:39:25 <kallisti> > reads "  2 2" :: [(Int, String)]
15:39:26 <lambdabot>   [(2," 2")]
15:39:35 <monochrom> ∩ is the robot's head
15:39:49 <t7> r2d2
15:39:52 <heatsink> @check \(x :: forall a. a -> a) -> x 1 == x (x 1)
15:39:52 <lambdabot>   Parse error at "." (column 16)
15:39:54 <t7> :)
15:40:04 <ski> > (reads :: ReadS Int) "2"
15:40:05 <lambdabot>   [(2,"")]
15:40:27 <DMcGill> so for check \x y -> x == y, the reason it returns true is that it's defaulting to ()?
15:40:33 <ski> yes
15:40:50 <DMcGill> @check \x -> False
15:40:50 <ski> @check (==)
15:40:51 <lambdabot>   "Falsifiable, after 0 tests:\n()\n"
15:40:51 <lambdabot>   "OK, passed 500 tests."
15:40:59 <ski> @check True
15:41:00 <lambdabot>   "OK, passed 500 tests."
15:41:03 <ski> @check False
15:41:04 <lambdabot>   "Falsifiable, after 0 tests:\n"
15:41:07 <ski> @check ()
15:41:08 <lambdabot>   "Arguments exhausted after 0 tests."
15:41:09 <t7> > let (^_^) x y = "animu" in undefined ^_^ undefined
15:41:10 <lambdabot>   <no location info>: parse error on input `)'
15:41:38 <DMcGill> that's a point - what are the rules on weird infix symbol function names?
15:41:54 <heatsink> The underscore is not an operator character
15:42:06 <DMcGill> normal functions are alphanum, underscore or apostrophies only right?
15:42:16 <heatsink> > let (^-^) x y = "happy" in undefined ^-^ undefined
15:42:17 <lambdabot>   "happy"
15:42:27 <kallisti> DMcGill: yes. also lowercase first letter.
15:42:29 <t7> DMcGill: cant start in apost i dont think
15:42:50 <magicman> > let ___ = "Hello" in [___]
15:42:51 <lambdabot>   ["Hello"]
15:42:55 <Phlogistique> @hoo@hoogle (m a -> m a) -> m a -> m a
15:42:55 <lambdabot> Unknown command, try @list
15:43:03 <DMcGill> so what about the wierd infix functions? (.:), (.), (:) and so on
15:43:05 <Phlogistique> @hoogle (m a -> m a) -> m a -> m a
15:43:05 <lambdabot> Test.QuickCheck.Arbitrary (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
15:43:06 <lambdabot> Test.QuickCheck (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
15:43:06 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (forall e. Data e => e -> e) -> (forall f. Data f => t f -> t f) -> d -> d
15:43:07 <donri> why isn't const needed for @check False etc?
15:43:47 <donri> i guess it treats non-functions as 0-arity functions?
15:44:01 <acowley> Can we not use constraint equality?
15:44:04 <acowley> argh
15:44:05 <t7> @check (< 10000)
15:44:06 <lambdabot>   "OK, passed 500 tests."
15:44:32 <acowley> Why won't GHC accept () as a constraint in an equality constraint?
15:44:39 <t7> @check (< 499)
15:44:40 <lambdabot>   "OK, passed 500 tests."
15:44:49 <t7> @check (< 498)
15:44:50 <lambdabot>   "OK, passed 500 tests."
15:44:55 <DMcGill> @check (<10)
15:44:56 <lambdabot>   "Falsifiable, after 35 tests:\n12\n"
15:45:02 <ski> DMcGill : see the `symbol' nonterminal at <http://www.haskell.org/onlinereport/haskell2010/haskellch2.html>
15:45:31 <ski> Phlogistique : what'cha looking for ?
15:46:07 <aavogt> @instances Testable
15:46:07 <lambdabot> Couldn't find class `Testable'. Try @instances-importing
15:46:08 <Phlogistique> ski: I have a tree-like type
15:46:10 <ski> @type let a :: () => Int; a = 5 in a
15:46:11 <lambdabot> Int
15:46:42 <Phlogistique> and a function similar to map which calls a function on every node and vertex
15:46:58 <ski> mhm
15:47:19 <Phlogistique> ski: http://sprunge.us/jPJD something like that
15:47:27 <aavogt> donri: it makes more sense (and works out better given what the restrictions are on instances) that there is a "instance Testable Bool" and "instance (Arbitrary a, Show a, Testable prop) => Testable (a -> prop)"
15:47:29 <Phlogistique> I was wondering if there is a name for that
15:47:54 <donri> Ah, figures
15:48:20 <Phlogistique> (the code I pasted doesn't parse nor typecheck though)
15:49:03 <ski> yeah, was just about to say it looks type-incorrect
15:49:23 <ski> maybe you meant `map (umap f)' instead of `umap (fmap f)' ?
15:49:25 <elliott> <acowley> Why won't GHC accept () as a constraint in an equality constraint?
15:49:30 <Phlogistique> here is the correct version: http://sprunge.us/AMMM
15:49:32 <Phlogistique> ski: indeed
15:49:33 <elliott> acowley: are you using PolyKinds or ConstraintKinds whatever?
15:49:36 <elliott> *or whatever
15:49:42 <acowley> elliott: ConstraintKinds
15:49:46 <elliott> acowley: ah, well I know there's hacks going on with () there because of its dual meaning
15:49:50 <elliott> since it's both :: * and :: Constraint
15:49:55 <elliott> same with (,)
15:50:06 * ski btw thinks there's no point in using `$' here
15:50:36 <acowley> elliot: I thought the hacks were all in place, but it seems not
15:50:49 <elliott> acowley: they are
15:50:54 <elliott> acowley: ask edwardk i think he's complained about the limitations
15:51:31 <acowley> I've bugged him enough about these things, and he's suggested I bug byorgey
15:51:47 <elliott> ah
15:51:49 <elliott> bug byorgey then
15:52:02 <acowley> I just need to limit the abstraction I'm aiming for
15:53:06 <ski> Phlogistique : hm, it reminds me of <http://hackage.haskell.org/packages/archive/multiplate/0.0.1.1/doc/html/Data-Generics-Multiplate.html#v:mapFamilyM>
15:56:28 <Veinor> are there any plans for gold (the alternative linker) support?
15:58:37 <elliott> Veinor: Support?
15:58:38 <elliott> It works.
15:58:49 <elliott> -pgml ld.gold or something, I forget the exact incantation, or just set gold as your default linker.
15:59:06 <Veinor> oh, neat
15:59:49 <shachaf> At one point GHC was broken with gold.
15:59:59 <Enigmagic> certainly didn't work with 7.0
16:03:35 <monochrom> eh? I didn't notice any breakage. have been using gold and ghc 6.12, ghc 7.0.3 and noticed nothing, almost forgot I'm using gold
16:03:48 <hiptobecubic> monochrom, why are you using gold?
16:04:09 <monochrom> but of course, I have gold on my PATH, in fact /usr/bin/ld symlinks to gold. I never use -pgml
16:04:38 <monochrom> because the standard linker is too slow when linking huge things like gtk
16:04:40 <shachaf> monochrom: I had to symlink /usr/bin/ld back to the original ld after the gold symlink broke GHC.
16:04:54 <Phlogistique> Is there a way or an haskell extension to define a function partially by pattern matching and partially directly?
16:04:56 <hiptobecubic> monochrom, it's very slow... yes.
16:05:27 <hiptobecubic> monochrom, is there any reason *not* to use gold that you know?
16:05:50 <monochrom> I only heard that gold can't do linux kernel yet. that is all.
16:05:51 <Phlogistique> for exemple, I'd like to write something like "idOrDouble 2 = 4; idOrDouble a = a" while using "id" for the second case
16:05:59 * monochrom is not a kernel builder
16:06:54 <aristid> Phlogistique: idOrDouble 2 = 4; idOrDouble a = id a :P
16:07:42 <monochrom> you can't yet. haskell wants all equations to have the same number of parameters
16:07:59 <monochrom> Haskell 2073 will probably support it
16:08:18 <monochrom> Haskell 2070 will be the one getting or-patterns
16:09:02 <Phlogistique> monochrom: what's an or-pattern?
16:11:21 <parcs`> something like 'foo :: Either a a -> a; foo (Left a | Right a) = a'
16:14:05 <copumpkin> figuring out if you have compatible bindings is a pain though
16:14:16 <copumpkin> preflex: seen ddarius
16:14:16 <preflex>  ddarius was last seen on #haskell 18 days, 21 hours, 6 minutes and 43 seconds ago, saying: BMeph: No.
16:19:09 <elliott> <Phlogistique> Is there a way or an haskell extension to define a function partially by pattern matching and partially directly?  <Phlogistique> for exemple, I'd like to write something like "idOrDouble 2 = 4; idOrDouble a = a" while using "id" for the second case
16:19:11 <elliott> see http://stackoverflow.com/questions/8745597/defining-a-function-by-equations-with-different-number-of-arguments
16:19:35 <elliott> tl;dr no, real reason is probably for simplicity (of specification and desugaring) and consistency, but there's a minor semantic quirk relating to _|_ too
16:22:48 <Phlogistique> elliott: thanks
16:36:57 <lifestream> Am I the only one who ever got so frustrated to the point of thinking of giving up learning Haskell? :O I was reading LYAH earlier today and I understood stuff (for once!) and now I go to put it into practice, and... brain freeze.
16:37:18 <lifestream> Actually today was the first time I read LYAH and understand what's going on
16:37:54 <parcs`> you probably weren't the only one
16:38:14 <elliott> No, everyone does that. Probably most people do actually give up.
16:38:36 <lifestream> Why did I have to fall in love with Haskell at first sight, ha!
16:39:30 <lifestream> Ah that's too bad elliott, too bad
16:39:48 <DMcGill> me learning Haskell was just list comprehensions as far as the eye can see
16:40:15 <lifestream> Hey, that sounds fun.
16:40:31 <DMcGill> slowing moving from explicit recursion to list comprehensions to more of a point free style
16:40:57 <DMcGill> slowly*
16:42:05 <monochrom> you need to learn a whole lot before you can practice non-trivial things
16:42:08 <lifestream> If I could just do that explicit recursion ATM I'd be somewhat happy :)
16:42:17 <DMcGill> @src Monad Either
16:42:17 <lambdabot> Source not found. Wrong!  You cheating scum!
16:42:23 <monochrom> but then that's a tautology. you can already practice what you have just learned
16:42:23 <DMcGill> @src Either Monad
16:42:23 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:42:37 <DMcGill> @instance Either Monad
16:42:38 <lambdabot> Maybe you meant: instances instances-importing
16:42:44 <DMcGill> @instance Monad Either
16:42:44 <lambdabot> Maybe you meant: instances instances-importing
16:42:49 <DMcGill> what do I mean to do?
16:42:56 <lifestream> Well, I just wanted to do the 99Haskell problems, figured I'd be able to do the first tree given that I've been reading and trying things non-stop for a week :)
16:43:49 <lifestream> But now I just want to smash the laptop into a wall then go for a 5km run, screaming :P
16:43:56 <DMcGill> > Right "r" >>= Just
16:43:57 <lambdabot>   Couldn't match expected type `Data.Either.Either a b'
16:43:57 <lambdabot>         against infer...
16:44:14 <monochrom> generally I think people rush too much. not too different from a 3-year-old saying "why is it so hard for me to write a movie review?"
16:45:19 <lifestream> Hmmm
16:45:29 <monochrom> (answer: it takes a few more years to comprehend how to use the word "sucks" properly. after that, you will be able to write a movie review)
16:47:03 <lifestream> Hmm, most 3 yr olds around here just stare at the TV drooling, with their zombie eyes.
16:48:00 <monochrom> well, sure, you can also consider a 30-year-old learning French the first time, expecting to write a French movie review after merely one month of beginning to learn French. I'm sorry, not going to work.
16:48:35 <monochrom> if French is too close to your mother tongue, try s/French/Japanese/ instead. totally different grammar.
16:49:19 <monochrom> this is why I am totally skeptic about the dive-in approach.
16:50:11 <lifestream> True, that's just silly, but all I really want to do for now is "find last element of a list", "find next to last element of a list", "find the nth element of a list", shouldn't be quite that difficult for a newbie?
16:50:49 <monochrom> last is easy. next-to-last is pretty different
16:50:54 <lifestream> (obviously implementing my own functions, not simply using the prelude functions)
16:51:08 <monochrom> nth is easy too
16:51:41 <shapr> edwardk: oh hey! I have GSoC project to suggest!
16:51:51 <edwardk> shapr: good, submit it!
16:51:58 <shapr> ok then!
16:51:58 <edwardk> student applications are open
16:52:00 <donri> "this movie sucks. like me. on boobies. hey boobies!"
16:52:01 <nh2> We still have this mysterious question in http://hpaste.org/66082: Forcing the "input list" before `par`ing off makes everything run on one thread
16:52:10 <monochrom> oh, I remember why it seems hard. you don't know how to derive programs. you only know how to execute programs.
16:52:18 <shapr> donri: srsly off topic
16:52:25 <donri> on topic to monochrom
16:52:40 <shapr> donri: Not to me.
16:52:55 <monochrom> I think it is unwise to argue with shapr :)
16:54:06 <monochrom> deriving a program by problem-solving heuristics: to find the last item of a list, there are only so many cases to consider:
16:54:38 <monochrom> if the list is empty, it is an error. you can ignore it, or you can write f [] = error "not going to work"
16:54:53 <monochrom> if the list has only one item, that's the answer. f [x] = x
16:54:55 <kallisti> error "hopefully something helpful"
16:55:11 <elliott> monochrom: next-to-last is pretty different from last?
16:55:55 <monochrom> if the list has more (of the form x:xs, x is head, xs is tail), the answer is the same as "the last item of the tail, which is the last item of xs". f (x:xs) = f xs
16:56:10 <monochrom> oh, I now see why next-to-last is easy too
16:56:44 <monochrom> note that in my thought process, I have paid absolutely no attention to how f is executed, "unfold the recursion" all that crap.
16:57:29 <lifestream> Oops, actually I did that, forgot to place something if empty.
16:57:58 <monochrom> unfolding the recursion is the job of computers. the job of computers is to follow orders, not designing orders. your job is designing orders. why would you use a slave's mindset to design a master's plan?
16:58:17 <ben> to make it faster
16:59:41 <lifestream> That's part of why I like Haskell so much, sick of the professors telling me "you have to tell the computer what to do", boy would it be annoying to do that in "real world" things!
16:59:47 <rwbarton> nh2: your program runs fine in parallel for me
16:59:52 <monochrom> ok sure, but making it faster is a an advanced lesson, and it still doesn't fully "use" a slave's mindset. you just "know", not "use", enough of a slave's mindset to help predict speed, that is all
17:00:00 <nh2> rwbarton: using ghc 7.4?
17:00:05 <hpaste> lifestream pasted “findLast” at http://hpaste.org/66087
17:00:11 <rwbarton> 7.2.1
17:00:37 <nh2> rwbarton: how do you determine if it runs in parallel? I used threadscope to get a graphical view
17:00:38 <DMcGill> :t getLine
17:00:39 <lambdabot> IO String
17:00:44 <monochrom> well, actually, in Haskell, you still have to tell the computer what to do. Haskell is not Prolog. if you write "x*2 = 10" it doesn't know you mean "x=5"
17:00:52 <rwbarton> I just used time
17:01:08 <rwbarton> real 0m27.829s / user 0m46.547s
17:01:21 <nh2> rwbarton: OK, let me try 7.2 before I make any other claims
17:01:48 <monochrom> my point is when designing what to tell the computer, you break down a large problem into smaller problems, you don't worry about what the computer thinks
17:01:53 <lifestream> monochrom: in that case x would have a value of some sort already, wouldn't it?
17:02:07 <monochrom> yes
17:02:20 <rwbarton> nh2: now granted it is far slower than the non-(-threaded) version, but that is another story
17:03:31 <nh2> rwbarton: do you get a speed-up with removing the "force"? Because for me, removing it shows 2 threads being used in threadscope and it also terminates significantly faster
17:03:50 <rwbarton> I assume I will
17:03:52 <rwbarton> let me test
17:04:52 <rwbarton> actually it was slightly slower but still using two processors
17:05:19 <aristid> seriously, haskell needs goals. i want my C-c C-c
17:05:25 <monochrom> oh, sorry, you're referring to "x*2=5"? no, does not even parse
17:05:38 <monochrom> err, "x*2=10"
17:05:40 <lifestream> Haaa.
17:05:47 <lifestream> Thought it was strange.
17:06:12 <monochrom> Haskell is not Prolog. not going to be declarative.
17:06:40 <aristid> monochrom: haskell really is quite low-level
17:06:54 <lifestream> Actually I just realize findNextToLast is pretty easy, I just peeked at a solution, thought about it all night, and still didn't undderstand. reverse "haskell" !! 1, how was THAT not obvious to me?
17:07:04 <elliott> that's a bad solution
17:07:08 <elliott> well
17:07:13 <elliott> it's not that bad
17:07:18 <monochrom> some people actually write "x = (x^2 + 1)/2" and expect Haskell to solve quadratic equations. sorry, Haskell disagrees.
17:07:22 <elliott> but i wouldn't recommend writing it that way...
17:07:59 <DMcGill> is there a safeHead in the Prelude?
17:08:01 <lifestream> Isnt there software that does that sort of thing anyway, monochrom
17:08:06 <parcs`> DMcGill: listToMaybe
17:08:09 <monochrom> this one actually parses. when you run it, it is an infinite loop
17:08:11 <aristid> monochrom: it can solve equations like x = 1 : x, so why not quadratic equations, too :P
17:08:36 <parcs`> > let x*2 = 5 in ()
17:08:37 <lambdabot>   ()
17:08:38 <monochrom> Haskell is not Mathematica
17:09:04 <nh2> rwbarton: ah, I actually found a difference! Running with +RTS -N4 -s for statistics, I get "SPARKS: 3 (0 converted, 0 dud, 3 GC'd, 0 fizzled)" for the force and "SPARKS: 3 (3 converted, 0 dud, 0 GC'd, 0 fizzled)" without. What is it for you?
17:09:09 <monochrom> ok, I erred, "x*2=5" parses, but it means defining * rather than defining x
17:09:14 <DMcGill> (listToMaybe >>= listToMaybe) . reverse $ [1,2,3]
17:09:17 <elliott> parcs`: your Prelude includes Data.List? :)
17:09:17 <DMcGill> > (listToMaybe >>= listToMaybe) . reverse $ [1,2,3]
17:09:18 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
17:09:18 <lambdabot>         against inferred ...
17:09:24 <nh2> ghc 7.2 vs 7.4 made no difference for me, though (I guess that's a good thing)
17:09:31 <elliott> or is it Data.Maybe
17:09:41 <parcs`> elliott: the Caleskell prelude does
17:09:55 <elliott> "is there an infix operator for fmap in the Prelude?" "yeah, (.)"
17:10:00 <rwbarton> nh2: which version of the program
17:10:55 <nh2> rwbarton: I mean: do you also get the sparks "converted" without force and "GC'd" with force?
17:11:00 <rwbarton> oh
17:11:32 <lifestream> So when you were just starting out, monochrom, what sorts of things did you do?
17:12:18 <monochrom> I read the Gentle Introduction. (there was no LYAH back then.) I keyed in its examples, and I mutated them slightly to make sure.
17:12:21 <DMcGill> what about a safe tail or a safe index?
17:12:22 <augur> is there a standard function Eq a => [a] -> [(a,Int)] or something like that which counts the number of occurrences of elements of a list?
17:12:32 <DMcGill> safeTail :: [a] -> Maybe [a]
17:13:10 <monochrom> the Prelude doesn't have those safe things
17:13:30 <monochrom> to people who want those safe things, I ask them to contemplate safeFromJust
17:13:39 <c_wraith> augur: if you can survive an Ord instance, you can do standard groupBy tricks
17:13:57 <c_wraith> :t map (head && length) . group . sort
17:13:57 <lambdabot>     Couldn't match expected type `Bool'
17:13:58 <lambdabot>            against inferred type `[a] -> a'
17:13:58 <lambdabot>     In the first argument of `(&&)', namely `head'
17:14:02 <rwbarton> monochrom++
17:14:04 <c_wraith> err, fail
17:14:11 <rwbarton> nh2: yes
17:14:17 <c_wraith> :t map (head &&& length) . group . sort
17:14:18 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
17:14:20 <augur> c_wraith: ok
17:15:11 <nh2> rwbarton: well, I guess that is the problem then, so we just have to find out why that happens. I cannot find a good reason why the force in that place should stop it from sparking
17:17:49 <DMcGill> @pl \x -> (listToMaybe =<< (\[] -> Just []) =<< Just (reverse x))
17:17:50 <lambdabot> (line 1, column 26):
17:17:50 <lambdabot> unexpected "["
17:17:50 <lambdabot> expecting pattern
17:19:32 <DMcGill> odd, that works in my terminal
17:19:58 <rwbarton> note that @pl is not ghc
17:20:17 <shachaf> It has no types, for one.
17:20:21 <rwbarton> in general @pl can't handle pattern matching
17:20:30 <shachaf> Well, except that it magically knows about some type classes.
17:20:32 <DMcGill> @pl \x -> (listToMaybe =<< temp =<< Just (reverse x))
17:20:32 <lambdabot> (listToMaybe =<<) . (temp =<<) . Just . reverse
17:20:37 <DMcGill> thanks!
17:21:03 <rwbarton> (it wouldn't have any way to rewrite \X -> y)
17:21:20 <DMcGill> @pl \x -> Just (reverse x) >>= temp >>= listToMaybe
17:21:20 <lambdabot> (listToMaybe =<<) . (temp =<<) . Just . reverse
17:27:41 <scooty-puff> probably a stupid question, but if i got ghc 7.4.1 right at the time it was released, could i expect bug fixes in the current 7.4.1 if i were to redownload it?
17:27:54 <scooty-puff> i guess what i'm asking is, will bug fixes go in without a version number change
17:28:04 <aristid> scooty-puff: i would hope not
17:28:13 <kallisti> that might introduce more bugs! :P
17:28:25 <scooty-puff> k, just checking
17:28:27 <kallisti> and then no one knows what version they're actually on.
17:28:27 <kallisti> etc
17:28:46 <scooty-puff> for some reason, when i use datakinds, i get the "the impossible happenned" messages unless i do a clean/recompile
17:29:02 <scooty-puff> anyways, was just wondering if worth trying to get it again
17:29:34 <scooty-puff> well, there's prob more to the issue then that, but thats how i have framed it anyways..
17:32:40 <elliott> scooty-puff: report it?
17:36:26 <jfischoff> Is there a name for MonadPlus in math speak? I'm looking for a good name for abstractions like ArrowPlus and MonadPlus, any suggestions?
17:36:30 <keep_learning> Hello all
17:36:59 <keep_learning> is this package is available at hackage http://www.johantibell.com/files/containers/Data-IntMap-Strict.html
17:37:28 <keep_learning> Currently I can see containers-0.4.2.1 with ghc-7.4.1
17:37:47 <keep_learning> so is it planned with future release of ghc
17:41:56 <scooty-puff> elliott, i still need to reduce it to a simple enough case - should soon
17:43:36 <jfischoff> I didn't see if anyone responded beccause I was booted, but I realize now, it is the absorption law at work.
17:49:01 <jfischoff> it seems like ArrowPlus need to have a dependency on Arrow. Is there something more general, perhaps in another module?
17:49:15 <jfischoff> opps s/need/doesn't need
17:53:05 <otters> what's the best FRP library?
17:53:40 <danharaj> FRP is not a solved problem.
17:53:53 <danharaj> Reactive-Banana looks like it's pretty nice.
18:03:15 <edwardk> whee! module Class where class Class a; instance Class Class
18:03:29 <edwardk> whats sad is i actually have a use for that
18:03:49 <monochrom> haha
18:04:03 <monochrom> just slightly better than saying Foo
18:04:17 <edwardk> toying with a nice way to make objective c bindings
18:04:42 <edwardk> and i wanted to reify the objective c class hierarchy using haskell's typeclasses
18:05:01 <byorgey> doesn't everyone?
18:05:13 <monochrom> heh
18:05:49 <edwardk> so I have a single type for objective c objects, which carry's a phantom type, so classes are values of type Ob Class -- and subclasses of Ob Class have the form Class p => Ob p
18:07:11 <edwardk> if that makes any sense
18:07:25 <edwardk> the classes are just witnesses permitting upcasting
18:07:31 <danharaj> so Class is a type and a typeclass?
18:08:04 <edwardk> danharaj: its just a typeclass, the type of the argument is kind Objective -> Constraint
18:08:08 <Elemir> And a constructor. For the great justice
18:08:10 <edwardk> er kind of the argument
18:08:25 <danharaj> ohh ok.
18:08:39 <danharaj> New kind of kind magic.
18:08:54 <edwardk> i wanted it to reduce the number of names i had to come up with for Class
18:09:14 <Elemir> Code in the studio
18:10:18 <edwardk> byorgey: it'd be cleaner if i had rank-2 kinds though ;)
18:10:57 <confab> :t (\=)
18:10:58 <lambdabot> Not in scope: `\='
18:11:06 <confab> why can i never do that right
18:11:12 <confab> :t (/=)
18:11:13 <lambdabot> forall a. (Eq a) => a -> a -> Bool
18:11:34 <edwardk> then you'd have something like upCast :: p p => Ob a -> Ob p
18:11:41 <monochrom> @quote monochrom kind
18:11:42 <lambdabot> monochrom says: rumour: SPJ will write a thick book "A New Science of Kind"
18:11:56 <edwardk> er p a => Ob a -> Ob p
18:13:18 <byorgey> edwardk: next you're going to be wanting rank-3, flavor-indexed polymorphic sorts
18:13:33 <edwardk> byorgey: you mean those aren't already in? I am disappoint!
18:14:13 <edwardk> byorgey: but you have to admit its a cute hack =)
18:14:44 <byorgey> I probably would if I made the effort to understand it =P
18:14:50 <byorgey> playing online bridge atm =)
18:17:28 <mokus_> edwardk: indeed it is... shouldn't be too hard to build on top of HOC either, as an alternate binding generator using the same FFI machinery
18:17:51 <irene-knapp1> except that HOC doesn't even compile
18:17:56 <mokus> it does now
18:17:58 <edwardk> mokus: nice. i'm playing with slightly different designs than hoc
18:18:10 <mokus> well, not the 'official' one, but the one on my github
18:18:16 <irene-knapp> oh!
18:18:18 <irene-knapp> nice!
18:18:27 <edwardk> in part because ObjC2 being a flag makes it awkward for me to reliably know it was installed
18:18:31 <irene-knapp> there is prior work on replacing it wholesale because my own assessment was that it wasn't worth fixing
18:18:44 <mokus> i'm probably gonna rip that flag out actually
18:18:52 <edwardk> yay!
18:18:53 <mokus> and not support < ObjC-2 on macs
18:18:57 <irene-knapp> Edward Amsden (don't know his nick in here, sorry) also did some stuff on replacing it, we collaborated a bit to make sure we weren't replicating work
18:19:18 <irene-knapp> do you have an approach to the dual-GC problem?  (ObjC 2 and Haskell both having GCs active, that is)
18:19:32 <mokus> i have some vague ideas, nothing concrete yet
18:19:49 <irene-knapp> hmmm okay
18:19:51 <mokus> at the moment my focus has been just getting it to build and run against the 64-bit ABI
18:19:55 <irene-knapp> right, fair enough
18:20:11 <irene-knapp> also, have you looked at the bridgesupport files that Apple provides?
18:20:27 <mokus> next step is getting the bindings generator working again, probably by replacing it with something based on bridgesupport parser
18:20:28 <irene-knapp> a lot of the API information that isn't available through reflection is available in those
18:20:39 <irene-knapp> right, okay.  I have a working bridgesupport parser which you're welcome to use.
18:20:41 <mokus> it will mean the bindings generated will probably look different though
18:20:44 <mokus> oh, cool
18:20:45 <irene-knapp> right
18:20:56 <irene-knapp> let me find it
18:21:36 <irene-knapp> darcs get http://ireneknapp.com/software/darcs/direct-cocoa/
18:21:43 <irene-knapp> sorry, no documentation, but it's not huge
18:21:58 <mokus> cool, thanks :)
18:22:06 <mokus> that'll definitely save me some time
18:22:20 <edwardk> i'll take a look myself
18:22:20 <edwardk> all i'm doing is trying to figure out the dumbest thing that works ;)
18:22:31 <irene-knapp> (you will notice when you dig into it that the commits are in the name of Dan Knapp, which is also me, my before-I-started-transition name.  heh.)
18:22:31 <mokus> i definitely understand the desire to start from scratch... HOC is complex and crufty
18:22:32 <edwardk> because i'm sick of having to require voodoo installation steps to do any gui work on a mac
18:22:36 <irene-knapp> yeah, indeed :)
18:22:37 <irene-knapp> agreed
18:23:03 <mokus> i probably wouldn't have tackled it if i hadn't done quite a bit of work on it a few years back
18:23:07 <irene-knapp> I also have a version of Cabal that I call Faction which can build hybrid ObjC/Haskell apps.  That's orthogonal to the bridge problem.
18:23:09 <mokus> i actually wrote the objc-2 support
18:23:14 <irene-knapp> oh, neat!
18:23:23 <mokus> so i was already familiar with its basic workings
18:23:25 <irene-knapp> then you're ideally situated to put everyone's work together and make things work
18:23:41 <irene-knapp> HOC almost put me off of Haskell entirely by being hard to understand :(
18:23:46 <mokus> heh
18:23:48 <irene-knapp> that was years ago, when it still worked, heh
18:23:55 <irene-knapp> today I understand how to use it
18:23:58 <mokus> well, it's especally hard because it has to do a lot of low level magic
18:24:01 <irene-knapp> yes
18:24:14 <mokus> debugging it over the last week was a nightmare
18:24:19 <irene-knapp> I see
18:24:39 <mokus> it's always rough when gdb can't even tell you where the stack frame that crashed was ;)
18:24:43 <irene-knapp> for sure
18:25:21 <mokus> anyway, i think i understand the whole thing well enough that i can 'refactor' it into something not half bad
18:25:27 <irene-knapp> great!
18:25:33 <irene-knapp> please keep us all informed of your progress
18:25:34 <edwardk>  i really just need the ability to talk to cocoa and spit out opengl to a window and use some nice dialog boxes to wrap the whole mess
18:25:38 <irene-knapp> is your github name also mokus?
18:25:43 <mokus> mokus0
18:25:51 <mokus> mokus was taken I guess
18:25:56 <irene-knapp> cool
18:26:04 <irene-knapp> I shall follow you there
18:26:16 <mokus> edwardk: you can probably do that much with the version as it stands on my github now
18:26:44 <roconnor> edwardk: how do you feel about seperate classes for (|||), codiagonal, and (***) ?
18:26:54 <mokus> the main limitations are that you'll have to hand-invoke the TH to generate the bindings (or write them by hand, ugh) and exceptions appear to be broken
18:26:55 <edwardk> roconnor: for lenses?
18:27:17 <roconnor> well, right now the classes are slated to appear in data-lens ... which isn't exactly satifying.
18:27:28 <edwardk> ick
18:27:29 <mokus> the test suite has some examples of hand-built imports
18:27:31 <roconnor> but I do like the operation names.
18:27:32 <irene-knapp> edwardk: if you really want the simplest thing that could possibly work, you don't want an ObjC binding
18:27:43 <edwardk> irene-knapp: i don't want the simplest thing
18:27:45 <edwardk> i want the right thing
18:27:48 <irene-knapp> edwardk: you just want a front-end written in ObjC and a back-end written in Haskell, communicating through the C ABI
18:27:49 <roconnor> maybe the solution is to get rid of the classes and just have the operators.
18:27:49 <irene-knapp> oh, okay
18:27:50 <bill```> how do you make lambdabot forget something that has been @let ?
18:27:58 <edwardk> irene-knapp: i've done that. it sucks ass
18:28:04 <edwardk> its a pain to deal with the xcode project
18:28:05 <irene-knapp> it does, yes, I've done it repeatedly
18:28:07 <irene-knapp> well
18:28:16 <irene-knapp> as I say, I have a version of Cabal that doesn't need an xcode project
18:28:24 <irene-knapp> because it can make a .app bundle from scratch
18:28:31 <edwardk> *nods*
18:28:36 <edwardk> cabal-macosx or something else?
18:28:44 <irene-knapp> no, that was an old attempt
18:28:52 <irene-knapp> Cabal seems to be maintained again, yay!  by new people
18:29:03 <irene-knapp> during the period when dcoutts clearly had no time for it, I had given up and decided to fork it
18:29:06 <irene-knapp> so mine is called Faction
18:29:36 <irene-knapp> (changing the name allows it to exist alongside Cabal - that is, on the same machine)
18:29:55 <mokus> btw, the latest GHCs all let you pass .m files via c-sources lines
18:29:55 <edwardk> anyways i figured i'd just take a stab at making a nice set of bindings (right before mokus revived hoc)
18:29:58 <irene-knapp> (it was a royal pain to find all the places the name was hardcoded, heh)
18:30:01 <irene-knapp> right
18:30:02 <edwardk> and see how it worked out
18:30:13 <irene-knapp> mokus: yes I know, but that doesn't solve the problem unfortunately
18:30:21 <mokus> not the whole problem, but a lot of it
18:30:24 <irene-knapp> or rather, it solves only one of about nine separate issues that I had to patch around
18:30:30 <mokus> it let me drop several dozen lines from Setup.hs
18:30:40 <irene-knapp> I made tickets, many of them with patches now attached to them, in the Cabal trac
18:30:46 <irene-knapp> to be the permanent note of my research
18:30:48 <roconnor> hmm, actually (***) is overloaded for Lens and PartialLens.
18:30:50 <irene-knapp> I believe they are still there, unmerged
18:31:10 <irene-knapp> as I say, Cabal is no longer totally unmaintained, but the new maintainer has to grow into the role a bit, heh
18:31:28 <edwardk> roconnor: well, i can break up the code in categories along those lines. find me a nice theoretical name for the split up versions ;)
18:31:29 <mokus> yea, and probably has a lot of catching up to do on older tickets
18:31:36 <irene-knapp> yes, for sure
18:31:38 <roconnor> actually they are all overloaded for Lens and partial lens.
18:31:45 <irene-knapp> anyway, edwardk, http://ireneknapp.com/software/darcs/Faction/ if you want it
18:31:58 <roconnor> edwardk: I thought these operations are defined in Arrows.
18:32:03 <edwardk> mokus: how close is hoc to just installing from cabal without any magic?
18:32:10 <mokus> it's pretty much there
18:32:17 <edwardk> roconnor: oh those versions
18:32:27 <mokus> once I rip out the objc2 flag there will be 0 magic in Setup.hs, I believe
18:32:27 <roconnor> edwardk: are there others?
18:32:46 <edwardk> http://hackage.haskell.org/packages/archive/categories/0.59/doc/html/Control-Category-Cartesian.html
18:33:09 <mokus> there's some stuff in there about finding paths for things, but I don't believe it's actually needed
18:33:39 <edwardk> mokus: hrmm
18:34:06 <irene-knapp> for the record, if you start to do the Cabal part of the problem at any point, mokus
18:34:18 <edwardk> i could get behind a 0 setup HOC
18:34:22 <irene-knapp> the approach I took was to add "App" as a new top-level thing that can exist alongside Library and Executable
18:34:37 <irene-knapp> because I had a specific scenario where I wanted to build both a command-line tool and a bundled GUI version
18:34:46 <roconnor> edwardk: interesting
18:34:49 <irene-knapp> and that would have been very annoying to build any other way
18:34:57 <edwardk> roconnor: that was what i was talking about splitting
18:35:03 <irene-knapp> of the new fields I added, some went into build-info and others went into App only
18:35:10 <roconnor> edwardk: I guess what I want is Arrow to be smashed into pieces
18:35:10 <irene-knapp> but I'm sure you can figure that part out
18:35:18 <roconnor> edwardk: like how Category was smashed out.
18:35:18 <edwardk> roconnor: thats what this package is
18:35:29 <roconnor> edwardk: where is (***)?
18:35:36 <edwardk> roconnor: its just a bifunctor
18:35:44 <mokus> edwardk: I just double-checked - aside from the objc-2 flag support, there's nothing other than some stuff to check paths for gnustep, which might be avoidable now with pkgconfig or a separate "paths-gnustep" optional dependency package or something
18:35:57 <edwardk> comes up way up in http://hackage.haskell.org/packages/archive/categories/0.59/doc/html/Control-Category-Associative.html#t:Associative
18:36:36 <edwardk> mokus: ok, so what is broken in the interface builder code?
18:36:53 <roconnor> edwardk: isn't having separate (***) and (+++) useful?
18:36:59 <edwardk> roconnor: why?
18:37:09 <mokus> edwardk: it hasn't been able to parse the headers properly since around Mac OS 10.5
18:37:13 <augur> hrmph. this is frustrating
18:37:17 <roconnor> edwardk: I don't know; to make type inference easier probably.
18:37:32 <roconnor> edwardk: anyhow, that package is a million miles from Haskell 98 anyways. :)
18:37:34 <edwardk> roconnor: doesn't help at all anywhere
18:37:43 <edwardk> roconnor: _that_ is true
18:38:05 <mokus> edwardk: it parses without using CPP, because it interprets a lot of the special macros apple puts in there to indicate things like compatibility, so it's a fragile parsec parser that breaks every other point release
18:38:11 <mokus> and nobody has fixed it in ages
18:38:20 <edwardk> the hardest thing to infer is the category for a bifunctor's left or right argument for first and second or left and right when you use proper bifunctors
18:38:26 <edwardk> thats why i have PFunctor and QFunctor
18:38:27 <mokus> so i'm hoping i can get the bridgespoort thing going without much trouble
18:38:33 <edwardk> it does help to make the default definitions easier to write
18:38:51 <edwardk> mokus: blech
18:38:55 <mokus> yea
18:39:06 <mokus> BridgeSupport is definitely the way to go
18:39:20 <edwardk> could we just cheat and #define all the macros we need?
18:39:28 <edwardk> and read them out of the wreckage?
18:39:35 <mokus> hmm, probably
18:40:09 <mokus> the nice thing about bridgesupport is that apple basically promises to maintain the parser
18:40:15 <edwardk> yeah
18:40:16 <irene-knapp> yes.
18:40:28 <irene-knapp> don't forget reflection as a source of information, either
18:40:42 <edwardk> shall we move this off channel? i just made #haskell-objc
18:40:48 <edwardk> lest we flood this place
18:41:08 <HugoDaniel> :D
18:43:55 <Pseudonym> There's #haskell-in-depth
18:44:36 <Pseudonym> Which is under-used, IMO.
18:48:02 <monochrom> yikes, the channel #define exists
18:48:31 <irene-knapp> haha
18:48:32 <irene-knapp> cute
18:48:36 <irene-knapp> what about #include
18:48:40 <irene-knapp> or #ifdef
18:48:51 <Pseudonym> #pragma
18:49:01 <mauke> #error
18:49:18 <Pseudonym> #!/bin/sh
18:49:28 <irene-knapp> illegal characters in that one
18:49:33 <Pseudonym> Yeah, I know,.
18:50:19 <monochrom> godawful, #include and #ifdef exist. #pragma needs a password
18:50:30 <mokus> #line ?
18:50:41 <Pseudonym> Now here's an idea: an IRC server which creates channels based on Twitter hashtags.
18:50:53 <augur> edwardk: can i throw a non-linguistic problem at you? :p
18:50:59 <Pseudonym> You join the room and see a real-time stream of everything with that tag.
18:51:00 <monochrom> #include may seem empty (apart from me being there now), but chanserv is actually there and keeping a topic line
18:51:06 <augur> just to get suggestions
18:51:20 <ben> ## already exists too, no token pasting operator channel for me :(
18:51:20 <edwardk> my attention is split a bit thin, but feel free -- if you dont mind a slow response
18:51:23 <monochrom> #line was empty
18:51:27 <augur> edwardk: ok
18:51:35 <irene-knapp> #ifdef had some people in it, I winked at them and left
18:51:56 <edwardk> Philippa: i was mostly looking for a place we could talk about this in the long term
18:52:05 <augur> edwardk: suppose i want to build sets of simple-typed, first-order lambda terms (lets say just variable/constant terms, nothing fancy)
18:52:17 * Pseudonym points out that joining an IRC channel with an obviously female nick, winking and leaving is an Internet cliche
18:52:18 <m3ga> i hang out in #pipe
18:52:46 <m3ga> for the us-ians, some people pronounce '#' as hash
18:53:04 <augur> edwardk: such that the set of terms _could_ possibly be reduced to a singleton
18:53:08 <ben> well yeah. hashtags. hashbang.
18:53:23 <augur> edwardk: is there an efficient way to do this without running into some horrendous combinatorial explosion?
18:53:26 <mm_freak> i write this pattern a lot:  ($ x0) . fix $ \again x -> …
18:53:27 <Pseudonym> It's usual in countries which have, or had, the pound as currency.
18:53:37 <monochrom> #!/usr/bin/env runhaskell is a haskbang :)
18:53:49 <mm_freak> does anyone have an idea how to write this more elegantly?  because it gets uglier with multiple variables
18:53:55 <xplat> roconnor: i kind of like the idea of separate classes for at least some of those things
18:53:59 <ben> no, that's a shebang >:[
18:54:17 <JoeyA> m3ga: I think we're learning that pronunciation now, since people talk about Twitter "hash tags"
18:54:17 <Pseudonym> Pound = £
18:54:20 <ben> a hashbang is the dumb thing in urls that breaks if you use noscript
18:54:24 <xplat> roconnor: they sound like they might turn out similar to garrows classes
18:54:35 <augur> edwardk: with no strict limit on the number of constants nor ground types
18:54:36 <JoeyA> So is Twitter just an adaptation of Ruby to the social networking scene?
18:54:53 <m3ga> JoeyA: i just joined a us company. the phone system keeps calling '#' pound.
18:55:02 <JoeyA> Indeed
18:55:03 <irene-knapp> Pseudonym: yes, it is an internet cliche, shrug :)
18:55:04 <edwardk> augur: good luck. ;)
18:55:05 <monochrom> I used to write "(fix (\f x y -> ...)) 0 1". now I just write a letrec.
18:55:05 <xplat> JoeyA: twitter is broadcast texting on the internets
18:55:10 <augur> edwardk: :p
18:55:19 <JoeyA> Please enter your password, then press pound!
18:55:20 <Pseudonym> irene-knapp: Not complaining, just pointing it out.
18:55:20 <roconnor> xplat: at the moment I'm thinking of accepting them in data-lens, making them really popular, and having them factored into base.
18:55:27 <mauke> I'mma call # "dollar"
18:55:31 <JoeyA> heh
18:55:47 <JoeyA> Then what are you going to call $, then?
18:55:56 <augur> edwardk: i just tried a naive approach, with fixed numbers of constants and types and fixed size on functional types, and ended up getting obnoxiously large numbers of possible initial sets
18:55:56 <xplat> # = 'dolla', $ = 'holla'
18:55:59 <Pseudonym> Telecom engineers call it "octothorp", which at least makes sense.
18:56:00 <JoeyA> s/then?/then, then?/
18:56:02 <JoeyA> (not enough thens)
18:56:05 <coeus> mm_freak, i usually write sth like this:   flip fix (1,2,3) $ \(a,b,c)->do
18:56:06 <irene-knapp> Pseudonym: haha okay then :D *grins*
18:56:06 <mauke> JoeyA: "big money"
18:56:12 <edwardk> augur: augur: that sounds quite likely =P
18:56:16 <coeus> hi@all, btw.
18:56:19 <augur> edwardk: mostly, i think, because of equivalences of initial sets
18:56:24 <irene-knapp> the dollar sign, clearly, is a hexathorpe
18:56:29 <xplat> i mostly call # octothorpe when i'm talking about c#
18:56:33 * Pseudonym also realises that "enters, winks and leaves" sounds like the punchline to a dumb joke
18:56:42 <mm_freak> coeus: thought about that, but i wonder whether GHC optimizes that tuple away
18:56:43 <irene-knapp> smirk
18:56:59 <augur> edwardk: like, {f : x -> y -> z, a : x, b : y} ~= {f : x -> y -> z, a : y, b : z}
18:57:03 <irene-knapp> (_Eats, Shoots and Leaves_ was a decent book.  er, a decent introduction.  I never read the rest of it.)
18:57:05 <xplat> since it makes it sound like some exotic invertebrate instead of a boring java clone with better generics :)
18:57:27 <JoeyA> mm_freak: Dumb question: what's wrong with using let notation for those situations?
18:57:44 <JoeyA> (referring to ($ x0) . fix $ \again x -> )
18:57:51 <edwardk> augur: well, you'll have combinatorial explosion in something, be it time to find equivalences, or space to store too many things
18:58:06 <mm_freak> JoeyA: i'm not particularly fond of using 'let' for functions in a do-block
18:58:39 <monochrom> I was not either. but I now give in
19:00:16 <augur> edwardk: i suppose i could do some sort of reverse construction -- build type-checking trees (with back-references to indicate reuse of a term) and then read off the initial terms used
19:00:29 <edwardk> augur: what is the goal?
19:00:37 <hpaste> xmlns pasted “Brainfuck Interpreter” at http://hpaste.org/66089
19:00:43 <augur> edwardk: and do it top down, left to right, to get an increasing set of "known" terms
19:00:53 <coeus> mm_freak, i think ghc will always optimize between tuples and curry form, it would be really bad otherwise.
19:00:57 <james-ubc> hey guys, is there a package simmilar to racket's 2htdp/image for haskell?
19:01:19 <coeus> and relatively easy to implement that optimisation.
19:01:25 <byorgey> james-ubc: gloss, diagrams
19:01:40 <mm_freak> coeus: you can't perform that optimization in general, because it changes semantics
19:01:48 <augur> edwardk: well, i need to general a bunch of possible such initial sets, and then test whether or not certain constraints on sequences of combinatorial operations does in fact yield something that has been claimed to be yielded
19:02:23 <mm_freak> coeus: GHC needs to perform strictness analysis to find that the function always forces the tuple to safely perform that optimization, that's why i wonder whether it does
19:02:31 <edwardk> augur: taking one step up, what are the sets representing
19:03:08 <edwardk> coeus: that optimization isn't always semantics preserving
19:03:10 <augur> edwardk: well, they're effectively what i described -- typed constant terms in the LC
19:03:35 <augur> edwardk: no higher order types, just n ground types -> ground type
19:03:38 <Pseudonym> This raises an interesting question, BTW. It'd be nice if a language like Haskell could give you some hard guarantees about which optimisations will be performed.
19:03:39 <edwardk> augur: ok, one level up from that, what are you modeling?
19:03:57 <coeus> hmm. maybe with bang patterns?
19:04:05 <augur> edwardk: Merge-Over-Move/Shortest-Move constraints on syntactic derivations :p
19:04:07 <Pseudonym> C++ gives you a few de facto (though not de jure) guarantees, such as the return value optimisation.
19:04:13 <mm_freak> coeus: the pattern match is sufficient, no need to bang here
19:04:19 <Pseudonym> And the empty base class optimisation.
19:04:32 <edwardk> augur: i'm trying to tackle the X Y problem here. You asked for X to solve Y, I can't give you X, I'm trying to move up to see if there is a better solution for Y. ;)
19:04:35 <Pseudonym> It'd be nice if the language could give you some hard guarantees.
19:04:35 <james-ubc> byorgey,  thianks!
19:04:38 <mm_freak> coeus: but GHC still needs to actually perform the strictness analysis to decide whether it's safe to perform the optimization
19:04:40 <edwardk> okay
19:05:03 <edwardk> that helps
19:05:05 <edwardk> hrmm
19:05:07 <augur> edwardk: well the thing is that it's been claimed that particular constraints on derivations yield a restricted set of possible output trees.
19:05:10 <byorgey> james-ubc: gloss is easier to get started with quickly, diagrams is more powerful.  if you try out diagrams and have questions feel free to drop by #diagrams.
19:05:23 <augur> edwardk: and after doing some hand simulations of key cases, i noticed that this is not strictly true
19:05:47 <augur> edwardk: for certain simple but paradigmatic examples, all possible trees are generable despite the constraint
19:06:04 <augur> so the constraint ends up being vacuous on the output of the derivations
19:06:15 <mm_freak> byorgey: can diagrams do animations?
19:06:28 <byorgey> mm_freak: yes
19:06:46 <edwardk> do you have an example translated into this form?
19:06:47 <byorgey> not (yet) interactive simulations/games though.
19:06:50 <augur> byorgey: can diagrams solve the halting problem?
19:06:57 <augur> edwardk: in what sense?
19:07:05 <byorgey> augur: yes
19:07:09 <augur> byorgey: :D
19:07:10 <edwardk> i was just trying to get a feel for the problem through a worked example
19:07:13 <coeus> mm_freak, yes, in general, but when we write/use it this specific way, i see no reason why the optimisation won't work.
19:07:21 <augur> edwardk: oh, sure
19:07:29 <mm_freak> byorgey: in real time on the screen?
19:07:44 <byorgey> mm_freak: no, not yet.
19:08:05 <mm_freak> coeus: sure, the question is:  does GHC actually go through the trouble to decide that, or does it simply not perform that optimization?
19:08:15 <augur> edwardk: so take the initial set   { f : X -> X -> Y -> Z,   a : X,   b : X,   c : X -> Y  }
19:08:25 <mm_freak> byorgey: what does it do?  save animation files?
19:08:39 * hackagebot derp 0.1.6 - Derivative Parsing  http://hackage.haskell.org/package/derp-0.1.6 (DavidDarais)
19:09:13 <shergill> lol +1 to david darais there
19:09:29 <mgsloan1> mm_freak: I've done realtime diagrams
19:09:33 <augur> edwardk: this can converge on a number of singleton sets:  { faa(cb) : Z }  { fab(cb) : Z }  { fba(cb) : Z }   plus the a <-> b swapped versions
19:09:37 <edwardk> you get [ f i j (c k) | i <- [a,b], j <- [a,b], k <- [a,b] ]
19:09:39 <coeus> mm_freak, that depens. i don't know about you, but i always compile with -O2.
19:09:47 <mgsloan> mm_freak: https://github.com/mgsloan/gtk-toy-diagrams
19:09:48 <byorgey> mm_freak: right now there's only a simple/experimental backend for animations that just saves a bunch of image files (one per frame)
19:09:57 <coeus> ;)
19:09:59 <mgsloan> in particular, ForceLayout is an interesting demo
19:10:07 <mgsloan> I should load it with a better set of points
19:10:11 <byorgey> mm_freak: but adding more sophisticated backends won't be too hard
19:10:25 <mgsloan> it's node + spring constraints, with the nodes draggable
19:10:25 <augur> edwardk: more or less
19:10:45 <augur> edwardk: but you dont want to reduce the set to { faa(ca) : Z, b : X }  for instance
19:10:50 <edwardk> yeahoh you need to use all
19:10:57 <edwardk> of course
19:10:57 <byorgey> well, sure, you can do real-time on-screen animation if the diagram is small enough to rerender completely every frame =)
19:11:00 <augur> edwardk: in some sense, sure, yeah
19:11:39 <byorgey> we could add that style of animation support to the gtk backend pretty easily too
19:11:44 <augur> edwardk: its a bit more subtle, because if by "use" you mean either "as an argument or as a function", then you dont want to get like.. { fa : X , gb : Y }
19:12:11 <mgsloan> byorgey - yup!  I think that it's really doable to do have some sort of "freezeCached" operation that caches the image, and uses it unless the parameter passed to the wrapped function is different
19:12:23 <augur> edwardk: really, you want to end with a singleton set
19:12:25 <edwardk> so do you have heuristics in place in your expander to do inlining whenever there is only a single place a rule can apply?
19:12:33 <edwardk> sure
19:12:45 <augur> edwardk: im not sure what you mean
19:12:46 <edwardk> so you want reductions that use all the elements, and end in a singleton
19:12:57 <mm_freak> byorgey, mgsloan:  ok, thanks
19:12:58 <augur> edwardk: yeah
19:13:15 <mm_freak> coeus: i compile with -O and often add -fno-cse
19:13:19 <augur> edwardk: now on top of that, we want to consider the _sequence_ of rewrites
19:13:22 <edwardk> potentially using something more than once, but its okay as long as everything gets used once
19:13:43 <edwardk> so contraction is okay, but weakening is not
19:13:58 <augur> right, sure
19:14:05 <edwardk> can you just use a relevant logic theorem prover?
19:14:21 <byorgey> mgsloan: oh, sure, but I'm also talking aout actual values of type  Animation b R2
19:14:23 <coeus> mm_freak, the docs say "Turns off the common-sub-expression elimination optimisation. Can be useful if you have some unsafePerformIO expressions that you don't want commoned-up."
19:14:38 <augur> well im sure it might be possible, but im not sure how
19:14:39 <edwardk> with X | Y | Z as your goal?
19:14:50 <edwardk> then relevance enforces the lack of weakening
19:15:04 <augur> byorgey: see, from the linear logic perspective, im not sure how to phrase it, because complex terms can be reused
19:15:26 <edwardk> this is relevant not linear
19:15:33 <edwardk> relevant permits contraction, which is reuse
19:15:49 <augur> relevant logic is a fragment of linear logic with the right exponentials! :)
19:15:58 <coeus> mm_freak, isn't it sufficient to tag that specific function foo that uses unsafePerformIO {-# NOINLINE foo #-} ?
19:16:38 <edwardk> when folks say linear logic they usually mean linear with the classical unrestricted modality. This is a substructural logic, but not a classic linear logic
19:16:48 <mm_freak> coeus: in four years of haskell experience i have used unsafePerformIO exactly once…  the reason i often turn off CSE is that sometimes GHC gets confused and uses the same thunk for multiple computations…  i'd like it to use different thunks, even though the underlying value is the same
19:16:51 <augur> edwardk: but the real point is that your proofs, when viewed as sequences of operations, not trees (just impose a total ordering over the partial order of the tree) have to satisfy certain constraints
19:16:51 <hpaste> monochrom pasted “de-tupling” at http://hpaste.org/66090
19:17:31 <mm_freak> coeus: that sometimes improves GC
19:17:33 <augur> edwardk: for instance, Merge-over-Move says that if at any point you could use something anew, you should -- only reuse when necessary to produce a converging proof
19:17:50 <edwardk> sure
19:18:09 <roconnor> mm_freak: I'm impressed that you turn off CSE,  I can barely get ghc to perform CSE at all.
19:18:13 <monochrom> my paste shows that with -O, fix (\again (x,y) -> ...) is turned into letrec again = \x y -> ...
19:18:19 <augur> edwardk: but so my observation was that the set of converging terms is infact just the set of all terms, at least for that example i gave you
19:18:34 <mm_freak> roconnor: that's fine…  it does perform it seldomly
19:18:35 <augur> edwardk: er, sorry, the set of MOM-satisfying terms
19:18:49 <edwardk> since in that case merge over move didn't restrict you
19:18:54 <coeus> mm_freak, interesting point. i wonder if we could use some {-# INLINE #-} pragma instead.
19:18:54 <augur> right
19:18:59 <mm_freak> roconnor: when i want sharing, i like to be explicit about it
19:18:59 <edwardk> rather it did but you could 'move around it'
19:19:30 <augur> edwardk: exactly -- you could always do the derivation in the right order to get around MOM. so my question was, does MOM *ever* constrain you?
19:19:31 <roconnor> mm_freak: when I want sharing, my arithmetic expressions become unreadable messes of let-ins
19:19:50 <edwardk> so then build a relevant logic theorem prover that builds up the trees and then, filter the trees when there exists no total ordering of their nodes that satisfies MOM
19:20:02 <edwardk> and then feed it a ton of sentences ;)
19:20:06 <mm_freak> roconnor: it takes some time to come up with a good style there…  i usually have:  f x' = x where …
19:20:09 <mm_freak> and then come the definitions
19:20:12 <monochrom> afterall, \(x,y) is clearly strict in the tuple, any computer knows
19:20:14 <edwardk> and at least rule out a false generalization
19:20:17 <augur> edwardk: but to test this for some relevant set of trees, i figured, ok, lets first build a bunch of initial sets and see
19:20:23 <edwardk> *nods*
19:20:24 <roconnor> mm_freak: I'll give it another try then.
19:20:31 <mm_freak> monochrom: thanks
19:20:42 <augur> edwardk: but obviously we should only look at those sets which have some hope of converging -- { f : X, g : X } is obviously a stupid place to start
19:20:45 <augur> because it could never converge!
19:20:46 <edwardk> sure
19:20:54 <edwardk> this is classic theorem prover territory
19:20:55 <augur> nor could an infinity of other such sets
19:21:02 <monochrom> whereas you may guess that the computer may or may not be smart enough for \~(x,y) -> (x,y) :)
19:21:04 <wo0kie> hmm
19:21:08 <wo0kie> well gentlement
19:21:09 <augur> but i dont know how to construct those sets efficiently
19:21:20 <wo0kie> it's that time where I ask for some assistance if anyone would care to help me :)
19:21:21 <mgsloan> byorgey: gotcha! BTW. have you tried using the MaclaurinTowers stuff to do automatic differentiation with diagrams?
19:21:24 <wo0kie> probably simple for you guys
19:21:26 <augur> edwardk: so im thinking maybe i could instead construct the trees -- if the trees are small enough, it'll be fine
19:21:30 <wo0kie> but I'm still learning haskell :o
19:21:38 <edwardk> build up something for which the relevant prover can solve it, then try to impart the linear orderings
19:21:51 <augur> edwardk: then i can assign types in the relevant ways and work from there
19:22:05 <wo0kie> http://pastebin.com/1vBjJ37t
19:22:08 <mauke> The paste 1vBjJ37t has been copied to http://hpaste.org/66091
19:22:14 <augur> edwardk: well, but it's not like i have some fixed set of initial terms in mind, right
19:22:15 <mm_freak> monochrom: since that's effectively 'id', i totally expect GHC's strictness analyzer to find that =)
19:22:19 <edwardk> sure, but you can work bottom up just making up trees as you go
19:22:20 <mgsloan> I may have to do some proper layout code soon, and it'd be pretty nifty if that was done with euler's method on the fitness function, or similar
19:22:36 <wo0kie> I'm trying to generate a complete binary tree based off the number of nodes desired
19:22:38 <augur> edwardk: not sure i follow
19:23:00 <wo0kie> using a treeUnfold function defined for us
19:23:11 <mm_freak> GHC is amazingly intellgent…  so intelligent that from time to time you have to tell it to calm down =)
19:23:12 <wo0kie> I'm having a bit of difficulty with the base cases I think
19:23:20 <edwardk> make a result X, and then make up a derivation in reverse, e.g. split it into { f y | f : Y -> X and y:  Y }
19:23:23 <coeus> lol
19:23:40 * hackagebot husk-scheme 3.5.4 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.4 (JustinEthier)
19:23:44 <edwardk> and when you need to make up a new argument, allow it to be one of the existing types you've seen or a new gensymed one
19:23:54 <edwardk> or a function in its own right
19:24:04 <wo0kie> treeBuild can't be defined recursively btw :)
19:24:11 <augur> edwardk: yeah, i think thats what im considering, so we're of like mind :D
19:24:13 <edwardk> and eventually you'll stop because everything will choose something you've seen
19:24:37 <augur> edwardk: but i figure the way to do this would be to use trees with backreferences to indicate reuse
19:24:39 <edwardk> or because you've reached a maximum size limit
19:24:39 <edwardk> and then using the types you derived check to see if it can satisfy MOM
19:24:43 <wo0kie> I will mention this is a hw question, so I'm not looking for an answer
19:24:46 <wo0kie> just some guidance
19:25:19 <edwardk> well, backreferences are cheap, just use a set of integer ids for the distinct leaves
19:25:29 <edwardk> or track a bunch of unification variables for them
19:25:30 <augur> edwardk: ya
19:25:33 <byorgey> mgsloan: no, I haven't tried any AD with diagrams
19:25:34 <edwardk> and occasionally decide to unify them
19:25:43 <edwardk> AD + diagrams?
19:25:46 * edwardk perks up
19:25:51 <byorgey> hehe
19:26:02 <edwardk> mgsloan: what are you doing with AD?
19:26:07 * byorgey has no specific plans
19:26:12 <augur> edwardk: ok. so i think we're agreed with the right way to approach this -- start from the things being built, then work out the sets that would build them
19:26:18 <byorgey> but I'm sure something cool could be done with the combination
19:26:19 <augur> byorgey, edwardk: AD??
19:26:21 <edwardk> augur: thats the obvious path
19:26:25 <edwardk> augur: automatic differentiation
19:26:29 <edwardk> augur: see my 'ad' package
19:26:29 <augur> ahh
19:26:51 <mgsloan> edwardk: The idea is that most layout problems are posed in terms of a function to optimize
19:26:59 <edwardk> had byorgey kept all the projective geometry stuff, AD could have won him an oscar like it did sigfpe =P
19:27:02 <augur> edwardk: in the sense of data D a = D a a as an instance of Num where yadda yadda do it as you build the thing etc.?
19:27:22 <edwardk> augur: thats the naive forward mode
19:27:28 <edwardk> augur: its not a good idea for production code
19:27:30 <augur> ok
19:27:38 <edwardk> augur: reverse mode is asymptotically more efficient in time
19:27:44 <edwardk> as long as you have fewer results than arguments
19:27:45 <mgsloan> so, if you can individual gradients for all of your input variables, you know where to move your current state to arrive closer to some minima
19:27:49 <edwardk> which is probably the case ;)
19:27:53 <augur> so not formal differentiation of formulae
19:28:01 <augur> but a numeric solution of sorts
19:28:07 <edwardk> augur: no
19:28:16 <edwardk> augur: its not symbolic and its not numeric ;)
19:28:16 <james-ubc> byorgey,  diagrams looks perfect! thanks again :D
19:28:22 <mgsloan> it's automatic :D
19:28:23 <edwardk> and its exact
19:28:24 <wo0kie> byorgey, would you be willing to help a young lad with his haskell a bit?
19:28:28 <augur> edwardk: well i dont mean literally numeric
19:28:37 <edwardk> its not a finite difference method either
19:28:40 <byorgey> edwardk: but nothing interesting is preserved by projective transformation =P
19:28:50 <augur> edwardk: but yeah no i know what you mean. i just wanted to make sure i was understanding what you meant! :p
19:28:53 <edwardk> byorgey: i agree. just giving you hell =)
19:29:01 <byorgey> wo0kie: in general yes, but I don't have time right now, sorry
19:29:02 <byorgey> ed	I know =)
19:29:13 <wo0kie> ok no problem byorgey :)
19:29:13 <augur> edwardk: i real conal's paper and learned about this tripartite approach to programmatic differentiation
19:29:26 <byorgey> james-ubc: great!
19:29:28 <coeus> what exactly do the acronyms AD and MOM stand for? (Attention Deficit and )
19:29:41 <edwardk> augur: to get one that doesn't suck you need to use observable sharing
19:29:52 <edwardk> conal's approach works well for toy examples
19:30:02 <augur> edwardk: hmm!
19:30:10 <augur> i just read a paper about observable sharing
19:30:14 <augur> well, started reading
19:30:15 <edwardk> and i actually use something substantially similar for narrow jets
19:30:35 <maloi> Graphics/UI/Fungen.hs:1:1: Ambiguous module name `Prelude':  it was found in multiple packages: base haskell98-2.0.0.1 how should i handle this? i use cabal-dev install fungen...so ghc-pkg hide haskell98 won't work, right?
19:30:38 <mgsloan> so, you could specify something very silly like "minimize  (\l -> sum $ zipWith (\x y -> bottomCoord x - topCoord y) l $ tail l)"
19:30:42 <edwardk> coeus: AD is automatic differentiation, its a nice way to compute all the derivatives of a function while you compute its answer
19:30:43 <augur> didnt really see how it was different than using haskell environments to tie things up
19:31:18 <hpaste> monochrom annotated “de-tupling” with “harder de-tupling” at http://hpaste.org/66090#a66092
19:31:43 <monochrom> success! I fooled -O into keeping the tuple. but -O2 is smarter.
19:31:49 <mgsloan> and use AD to perform euler's method to end up with the evenly-separated solution
19:31:56 <mgsloan> (very quickly, I think this problem would be one iter)
19:32:02 <edwardk> coeus: MOM is a linguistics thing
19:32:20 <byorgey> maloi: you'll have to edit fungen's .cabal file so it doesn't depend on the haskell98 package
19:32:34 <coeus> ah. ok. wikipedia knows AD, but Mother?
19:32:49 <maloi> byorgey: uff ok i'll try
19:32:58 <byorgey> maloi: which may require fixing a few things
19:33:07 <edwardk> coeus: Merge-over-Move, its not connected to AD in any way ;)
19:33:10 <byorgey> maloi: e.g. changin 'import List' to 'import Data.List' and so on
19:33:18 <coeus> like: i learned to speek thanks to MOM?
19:33:39 <edwardk> coeus: its connected to how you speak, or at least how you understand language
19:34:22 <edwardk> augur: http://hackage.haskell.org/packages/archive/ad/1.3.0.1/doc/html/Numeric-AD-Internal-Forward.html is a conal-style forward mode dual number AD
19:34:22 <coeus> ah, ok.
19:34:30 <augur> hm
19:34:40 <edwardk> augur: http://hackage.haskell.org/packages/archive/ad/1.3.0.1/doc/html/Numeric-AD-Internal-Reverse.html is my horrible reverse mode AD core
19:34:58 <edwardk> notice the tape, which is extracted from the reverse tree
19:35:14 <coeus> edwardk, thx. my computational linguistics studies in psychology did not cover this term.
19:35:16 <edwardk> then i topsort the graph from the answer and walk it
19:35:23 <mgsloan> edwardk: does this usage of AD seem doable?
19:35:40 <edwardk> mgsloan: rewinding and reading =)
19:36:15 <edwardk> mgsloan: yes. there is even a combinator for it
19:36:33 <mgsloan> so I don't need to know the number of input variables at compile time?
19:36:44 <edwardk> http://hackage.haskell.org/packages/archive/ad/1.3.0.1/doc/html/Numeric-AD-Newton.html#g:2
19:36:46 <edwardk> correct
19:36:55 <mgsloan> awesome :)
19:36:56 <edwardk> just give me a function from a list or something
19:37:04 <edwardk> gradientDescent works fine for that
19:37:25 <edwardk> i can add more complicated subgradient or conjugate gradient methods if you need them
19:37:57 <mgsloan> awesome, we'll see!
19:38:27 <edwardk> in general its pretty easy to work variadically with ad
19:38:39 <edwardk> ghci> grad (\[x,y,z] -> x * sin y * exp (x * z)) [1,2,3]     ==> [73.05490816266706,-8.358532650935372,18.263727040666765]
19:39:20 <edwardk> or vgrad (\ x y z  -> x * sin y * exp (x * z)) 1 2 3
19:40:15 <edwardk> (the latter is a smidge less type safe since i can't enforce the lack of perturbation confusion)
19:40:44 <edwardk> but that could only happen if you used ad on a function that used ad internally and didn't lift correctly
19:41:17 <mgsloan> your library looks excellent, unfortunately I might be going with http://hackage.haskell.org/packages/archive/vector-space/0.7.3/doc/html/Data-Maclaurin.html
19:41:30 <mgsloan> since diagrams is already using vector-space
19:41:39 <edwardk> *shrug*
19:41:43 <mgsloan> and I'm not sure if I'm going to be able to get your AD going on diagrams internals
19:42:46 <edwardk> note: maclaurin gives you the entire jet and be careful because it doesn't prevent perturbation confusion
19:43:02 <mgsloan> (e.g. I want to be able to get the derivative of the height of a diagram, based on changing input variables that vary its components)
19:43:22 <edwardk> is diagram polymorphic in the type you use for said height?
19:43:30 <mgsloan> for normal layout stuff, this will be a 1 if it's constrained on that var, 0 otherwise
19:43:35 <mgsloan> oh yeah
19:43:41 <edwardk> then either will work
19:43:52 <mgsloan> but I need vector-space instances for the FU type
19:44:23 <edwardk> not for FU, for (AD s) or for the f you apply to AD s a
19:44:26 <mgsloan> well, AD, right.
19:44:37 <mgsloan> I thought FU was a more humorous acronym :)
19:44:51 <edwardk> why do you need the vector space? AD s a is a num
19:45:50 <Axman6> so, i;ve stumbled onto some strange syntax i've not seen before, i thought it was implicit parameters, but ti seems it's not: foo :: (?bar :: A) -> (?baz :: B) -> C, what extension do i need to use that? (it;s from ANUPlot, the library Gloss came from)
19:46:02 <edwardk> so if you're polymorphic in that, constants defined for it should just work
19:46:28 <mgsloan> edwardk - right, but in order for (a, b) to be a VectorSpace, a and b need to be a VectorSpace
19:46:43 <edwardk> erm, AD s a is the scalar here
19:46:54 <edwardk> you make your vector spaces on top
19:47:29 <mgsloan> yeah, there really needs to be an existential wrapper in the vector-space library...
19:47:35 <mgsloan> but there isn't
19:47:40 <edwardk> ?
19:48:02 * Axman6 pokes Cale and quicksilver because he's pretty sure they'd know what this old syntax is
19:48:02 <edwardk> where is the dependency on Double or what not in vector-space?
19:48:02 <ion> There should be a High Definition version of AD.
19:48:10 <mgsloan> forall a. Num a => PlainVector a
19:48:17 <mgsloan> with VectorSpace instances defined
19:48:55 <Cale> Axman6: implicit parameters?
19:49:02 <edwardk> mgsloan: i don't grok why you keep seeing AD s a as the vectorspace over a though, rather than just building the entire vectorspace as some space over AD variables
19:49:06 <Cale> oh
19:49:08 <Cale> er
19:49:24 <mgsloan> edwardk: VectorSpace is explicity instantiated for Double
19:49:28 <Axman6> thats what i thought too, but i get: Predicate `?transColor :: (Word8, Word8, Word8)' used as a type
19:49:51 <geekosaur> yeh, they;d need to be in the context to be implicit params.  and IIRC linear implicits used %
19:49:51 <edwardk> as used by diagrams?
19:49:57 <Cale> yeah, that's weird
19:49:59 <mgsloan> edwardk: I need VectorSpace instances for AD.  It'll work, I just need to write them, and it's bullcrap that there's not a wrapper that does it
19:50:13 <edwardk> http://hackage.haskell.org/packages/archive/vector-space/0.8.0/doc/html/Data-VectorSpace.html is polymorphic is why i asked
19:50:21 <edwardk> type Scalar v can be anything
19:50:26 <geekosaur> (but I didn't think linear implicits ever got used, which is why they got killed)
19:51:04 <Cale> Axman6: where in the library is this code?
19:51:15 <edwardk> ah, so diagrams isn't polymorphic in that type
19:51:22 <edwardk> data R2, etc.
19:52:02 <byorgey> edwardk: diagrams itself is.  But the all the functions for doing stuff with specifically 2D diagrams are not.
19:52:36 <edwardk> the vectorspace instances for AD are pretty trivial. in fact http://hackage.haskell.org/packages/archive/ad/1.3.0.1/doc/html/Numeric-AD-Classes.html exposes all of them for you almost exactly
19:52:42 <Cale> Axman6: still here?
19:53:50 <edwardk> mgsloan: hrmm but the TwoD stuff has a lot of V a ~ R2 nonsense in it, so you may be hosed regardless
19:54:29 <mgsloan> edwardk: oof, good point.  It should at least work for diagrams-core, though
19:55:20 <mgsloan> thing is, we're already forced to not use the Cairo backend, because it expects R2 aswell
19:55:31 <edwardk> sure, but for vectorspace core you can just use the fact that you can have AD s a as the scalar type of your vector space ;)
19:55:37 <edwardk> er i mean for diagrams core
19:55:55 <edwardk> just need to fix TwoD to use a less restrictive R2 type, R2 a anyone?
19:56:20 <mgsloan> so, just use the "Default" backend, with an AD variant of R2
19:56:31 <edwardk> data SizeSpec2D a = Width a | Height a | Dims a a | Absolute, etc.
19:56:38 <byorgey> that would be a rather disruptive change, but I could be convinced if there are sufficiently cool applications =)
19:57:07 <edwardk> you aren't currently bothering to unbox them anyways
19:57:39 <mgsloan> maybe just have a "D2 a" constructor, and make R2 be a type synonym
19:57:58 <mgsloan> I think that would give all the benefits without the cost of breaking code
19:58:09 <edwardk> mgsloan: or that, though there are a number of other things, like that SizeSpec2D that need the generalized form as well
19:58:28 <mgsloan> right, there would still need to be a generalizing sweep through diagrams-*
19:58:34 <Axman6> Cale: sorry, teaching a tutorial. it was in Graphics.Plot.BMP, but i'm sure this code isn't in gloss any more. I'll paste the code, one sec
19:58:45 <Cale> Axman6: I found it
19:58:47 <Cale> Axman6: hmm
19:59:06 <Cale> Axman6: They're definitely being treated as implicit parameters, I'm not sure if that syntax was *ever* valid though.
19:59:11 <edwardk> is diagrams trying to be haskell 98?
19:59:14 <Cale> Or at least, ever documented
19:59:15 <Axman6> Cale: http://pastebin.com/LQ60vLLq
19:59:18 <mauke> I have copied your paste LQ60vLLq to http://hpaste.org/66093 - pray I don't copy it any further.
19:59:20 <mgsloan> edwardk: goodness no
19:59:21 <dmwit> timthelion: Profile it. Testing two versions with the two imlementations should be a snap.
19:59:22 <edwardk> guess not just found PolyType =)
19:59:30 <Axman6> Cale: well, it was certainly valid when i took the course in 2008 =)
19:59:38 <dmwit> timthelion: There's no other wyay to be absolutely certain.
19:59:38 <mgsloan> QDiagram b v a
19:59:40 <Cale> interesting
20:00:05 <byorgey> edwardk: hahaha, no =)
20:00:07 <edwardk> yeah the generalized version could permit some fun things
20:00:21 <edwardk> gradient descent placement, etc.
20:00:23 * mgsloan files a diagrams issue
20:00:31 <mgsloan> yup, layout stuff will be really pretty with this
20:00:41 <byorgey> sounds awesome
20:00:46 <mgsloan> which is what I'm going to try to work on now
20:00:47 * byorgey -> bed
20:00:52 <mgsloan> night!
20:00:56 <Cale> Axman6: In any case, it looks like it'll work if you just replace these with normal => implicit parameters
20:01:01 <edwardk> sounds good
20:01:29 <edwardk> if you need me to expose anything from AD lemme know, i'm pretty sure everything you need to do pretty much any sort of chicanery is available through the .Internal.* modules
20:02:22 <Axman6> Cale: so, foo :: (?bar :: A, baz :: B) => C?
20:02:27 <Cale> yeah
20:02:29 <Axman6> i haven't used them in a while
20:02:33 <Axman6> cheers
20:02:37 <Cale> with ?'s for each one
20:02:43 <Cale> (you missed the one on baz)
20:03:06 <mgsloan> hehe, my diagrams feature request title is "Generalize R2 to D2"
20:03:11 <Axman6> right, yes
20:03:21 <Cale> mgsloan: D2?
20:03:39 <mgsloan> Cale: newtype D2 a = D2 (a, a)
20:03:47 <Cale> ah
20:03:48 <mgsloan> D2 = two dimensional
20:04:22 <Cale> Has anyone else seen this weird syntax that Axman6 is seeing in this library before?
20:04:43 <Cale> I never knew that implicit parameters could ever be given with (?foo :: T) -> ...
20:05:07 <Cale> (i.e. not on the left of a => but just as an otherwise normal-looking function parameter)
20:05:11 <roconnor> I've read about that in GHC documentation before.
20:05:17 <Cale> Axman6: oh, were you using hugs?
20:06:08 <Cale> er, nope, its documentation doesn't say anything about that either
20:06:24 <Axman6> no
20:06:38 <edwardk> cale: neat
20:06:41 <edwardk> cale: does it work?
20:06:47 <Cale> edwardk: not at present
20:06:53 <Axman6> but it used to
20:06:56 <Cale> edwardk: but supposedly this code used to work :)
20:07:00 <Axman6> back in the 6.8 days i believe
20:07:24 <edwardk> probably worked because of a bug =)
20:07:58 <Axman6> can you see anythying wrong with http://pastebin.com/KGTgMrzA ? i'm just getting a parse error on input =>
20:08:00 <mauke> The paste KGTgMrzA has been copied to http://hpaste.org/66094
20:08:23 <Cale> tabs
20:08:29 <Axman6> urgh
20:09:00 <Axman6> still getting the same error
20:09:51 <Axman6> bah, i have my old working version on the student machines, i'll show the students that
20:10:04 <Cale> oh, there's an -> after =>
20:10:47 <Cale> Axman6: ^^
20:13:42 * hackagebot dns 0.3.3 - DNS library in Haskell  http://hackage.haskell.org/package/dns-0.3.3 (KazuYamamoto)
20:14:58 <bxc> woo my first patch in a hackage package
20:15:37 <tgeeky_> woohoo, hopefully it compiles
20:15:49 <bxc> heh
20:22:08 <MaskRay> Is http://hpaste.org/66095 a valid real-time queue implementation or am i missing something?
20:25:17 <wo0kie> can someone help me with this function of mine? :(
20:26:15 <ion> wo0kie: Add “a = 42” to the fourth line.
20:26:24 <maloi> byorgey: the fixed the deps in darcsden but not on hackage...it kinda works now
20:26:41 <wo0kie> lol ion
20:27:36 <wo0kie> http://pastebin.com/TqbhmKm4
20:27:37 <wo0kie> :(
20:27:37 <mauke> The paste TqbhmKm4 has been copied to http://hpaste.org/66096
20:27:45 <wo0kie> for some reason it keeps infinitely recursing
20:28:09 <wo0kie> when it is supposed to check the node value to see if it's less than the max size of the tree D:
20:28:16 <wo0kie> 2^h - 1
20:29:09 <ion> Try Debug.Trace.trace
20:29:37 <wo0kie> how do I do that? D:
20:30:17 <dmwit> wo0kie: What's 2 * 0?
20:30:22 <dmwit> (That's a hint.)
20:30:39 <wo0kie> well 0 :o
20:30:58 <dmwit> So, what's the left spine of your tree going to look like?
20:31:42 <wo0kie> one node with 0, no?
20:32:16 <dmwit> wo0kie: Is 0 < n? If so, won't it recurse? What argument will it recurse with? 2* 0, right?
20:32:38 <wo0kie> yeah I'm testing with treeBuild 3
20:32:54 <wo0kie> treebuild 2, sorry
20:32:57 <dmwit> I feel like if I give any more hints I'll just be feeding you the answer. =P
20:33:00 <wo0kie> which in theory should look like this
20:33:01 <wo0kie> treeBuild 2 ↝ Node (Node Leaf 0 Leaf) 1 (Node Leaf 2 Leaf)
20:33:05 <wo0kie> no I understand
20:33:08 <wo0kie> I don't want an answer :)
20:33:09 <wo0kie> it's hw
20:34:05 <Rotaerk> oo, squiggly-arrow
20:34:05 <dmwit> Try working out (by hand) what the left spine will be by executing the code as you've written it, with b = 0.
20:34:43 <zmoazeni> Hi folks, I'm slowly picking up haskell and I've worked through monadic actions to a degree (mentally mapping do-syntax and >>=/>>) however I'm starting to stumble with working with separate Monads. I could probably answer this myself if I keep digging/experimenting, but I need to cheat with some feedback. Does the do-syntax actions/functions expect to be tied to a specific type of Monad? Working with two distinct Monads is throwing m
20:34:44 <zmoazeni> brain a curveball
20:35:11 <dmwit> zmoazeni: Each block is an action in a single monad.
20:35:50 <fizzbang> what's the difference between -> and => in types? when i do ":t 1" in ghci i get that => symbol..
20:35:51 <zmoazeni> dmwit: I thought that was the case. Do I need to go down the path of monad transformers if I want to combine the results of one monad's actions within a different monad's actions?
20:35:54 <dmwit> The whole block may be polymorphic, and possible to monomorph into many different monads, but each time, the entire block is monomorphed into the same monad.
20:36:19 <dmwit> zmoazeni: Yes, if you want more than one kind of effect, you should use transformers.
20:36:46 <dmwit> fizzbang: (->) is the type constructor for functions; "=>" is the syntax that separates contexts from type schemes.
20:37:07 <dmwit> fizzbang: A context represents some class constraints on the type variables.
20:37:10 <zmoazeni> dmwit: Are there any better resources than http://en.wikibooks.org/wiki/Haskell/Monad_transformers and http://book.realworldhaskell.org/read/monad-transformers.html ? I keep rereading them and it's just not clicking
20:37:15 <dmwit> (Other constraints are possible, but for now you should ignore them.)
20:37:44 <dmwit> zmoazeni: I suppose LYAH and the Typeclassopedia are good, and I quite liked All About Monads and You Could Have Invented Monads.
20:37:48 <dmwit> ?where lyah
20:37:48 <lambdabot> http://www.learnyouahaskell.com/
20:37:51 <dmwit> ?where typeclassopedia
20:37:51 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
20:37:53 <dmwit> ?where aam
20:37:54 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
20:37:58 <dmwit> ?where sigfpe
20:37:59 <lambdabot> http://sigfpe.blogspot.com/
20:38:03 <fizzbang> dmwit: thanks
20:38:04 <dmwit> eh...
20:38:11 <dmwit> ?google sigfpe you could have invented monads
20:38:14 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
20:38:14 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
20:39:04 <zmoazeni> dmwit: Thanks, I'll try going through those. Aside from people first groking monads, are monad transformers a common stumbling block?
20:39:07 <nyingen> I preferred this article: http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html
20:39:30 <dmwit> zmoazeni: No. You'll be surprised at just how simple monad transformers are, once you grok monads.
20:39:37 <dmwit> s/grok monads/grok a few monads/
20:39:40 <nyingen> zmoazeni: I think so. I had trouble with them, until I read the article I just linked to. They're not as hard as they seem to use, and now I use them all the time
20:39:52 <zmoazeni> Right on. Thanks guys for the resources
20:43:45 <zmoazeni> Is there a way to use the PackageImports extension within ghci? I get using it from a file in the sense of: import "mtl" Control.Monad.State
20:44:00 <zmoazeni> I'm just trying to bring in a module via: :m +...
20:44:28 <Cale> zmoazeni: there are actually not so many different monad transformers that people use in practice, and their implementations are all pretty straightforward once you understand the implementation of the monads that they mimic (e.g. State for StateT)
20:45:09 <zmoazeni> Cale: This probably just means there's holes in my understanding of monads.
20:45:13 <Cale> zmoazeni: put {-# LANGUAGE PackageImports #-}  at the top of your file
20:45:44 <dmwit> Cale: Pretty sure he wants it in ghci...
20:45:58 <zmoazeni> Cale: Yeah I get that, using the pragma and then using an extended import statement of a file. I was wondering of importing a module from a package directly within ghci
20:46:03 <Cale> dmwit: Well, he won't have to do anything in GHCi if he adds the LANGUAGE pragma :)
20:46:05 <dmwit> zmoazeni: Does :set -XPackageImports work?
20:46:14 <dmwit> zmoazeni: And then import "mtl" C.M.S as usual?
20:46:14 <Cale> but you can do -XPackageImports, yeah
20:46:24 <Cale> oh, I don't know about it actually working on that
20:46:29 <Cale> hmm
20:46:31 <dmwit> Cale: Files and the ghci prompt have independent LANGUAGE flags.
20:46:51 <dmwit> This can be very surprising when, for example, you put LANGUAGE NoMR in your file.
20:46:51 <Cale> ghc-pkg hide monads-fd
20:46:57 <Cale> or whatever one you don't want
20:47:15 <Cale> and that way packages which need it will still be able to use it, but you won't get ambiguities
20:47:27 <zmoazeni> dmwit: I've never tried doing a direct import in ghci. But that didn't work. I did try that after doing :set -XPackageImports
20:47:30 <Cale> dmwit: indeed
20:47:51 <dmwit> zmoazeni: It works here. Perhaps you should upgrade GHC.
20:48:25 <zmoazeni> odd
20:48:36 <Cale> ah, yeah, the newest GHC allows basically any sort of declaration in ghci
20:48:56 <zmoazeni> dmwit: What version are you using?
20:49:01 <dmwit> 7.2.2
20:49:02 <zmoazeni> Ah
20:49:11 <zmoazeni> That might be it. I'm on v7.0.4
20:49:35 <dmwit> 7.4.1 is the most recent, but I haven't switched over from my distro's packages on this computer yet.
20:53:22 <zmoazeni> Ah I found a short term workaround from http://www.haskell.org/pipermail/haskell-cafe/2010-June/079551.html :set -hide-package abc then :m +Def
20:55:06 <wo0kie> is it possible to iterate over a data type definiton using list comprehensions or something else?
20:55:15 <wo0kie> like if I had data Suit = Clubs | Diamonds | Hearts | Spades deriving (Eq)
20:55:21 <wo0kie> is there a way to iterate over that?
20:55:49 <geekosaur> derive Enum?
20:55:55 <geekosaur> and possibly Bounded
20:56:07 <wo0kie> don't think I can change the definition :(
20:56:10 <wo0kie> not allowed
20:56:18 <dmwit> Use standalone deriving, or write the instance yourself.
20:56:32 <geekosaur> ...is this homework?
20:56:41 <wo0kie> yes it is, forgot to mention :)
20:58:23 <Cale> wo0kie: Well, you can just write  suits = [Clubs, Diamonds, Hearts, Spades]
20:58:34 <Cale> wo0kie: and then  map f suits
20:58:38 <Cale> or whatever
20:58:44 <wo0kie> isn't that cheating though lol
20:59:05 <Cale> Well...
20:59:11 <Cale> If you had an instance of Enum
20:59:21 <Cale> then you could write [Clubs..] to get all the suits
20:59:54 <Cale> and as dmwit suggests, you could use standalone deriving if you're not allowed to change the definition, however, that's an extension to Haskell
20:59:56 <wo0kie> http://pastebin.com/TWNwrKR3
20:59:58 <mauke> The paste TWNwrKR3 has been copied to http://hpaste.org/66097
21:00:03 <wo0kie> this is what the data type definition looks like
21:00:14 <wo0kie> it seems he uses some list comprehension here if I'm not mistaken
21:01:24 <wo0kie> like it has Show and Read
21:01:38 <wo0kie> but not if there's something I can use to iterate over those
21:01:53 <Cale> yeah, that's just basically how reads/readsPrec/lex/etc. work, they all take a string as input, and produce a list of parses, where each parse is a pair consisting of a value parsed off the beginning of the string, and the remainder of the string
21:02:19 <Cale> (most of the instances will only ever produce 0 or 1 element lists, but it can handle ambiguous parses like that)
21:02:30 <wo0kie> hmm
21:02:47 <Cale> There's no way off hand from that definition to iterate over them
21:02:50 <Cale> You just have to list them
21:03:00 <Cale> and then iterate over that list
21:04:13 <Cale> wo0kie: For example, try   reads "CHJKD" :: (Suit, String)
21:04:16 <Cale> in ghci
21:04:39 <Cale> You should get [(Clubs, "HJKD")]
21:05:02 <wo0kie> I get an error :O
21:05:06 <Cale> err...
21:05:08 <Cale> oh
21:05:09 <Cale> lex :)
21:05:23 <Cale> maybe try "C J K L P"
21:05:34 <Cale> > lex "C J K L P"
21:05:35 <lambdabot>   [("C"," J K L P")]
21:05:42 <Cale> yeah, that ought to work better :P
21:05:45 <Cale> > lex "     C J K L P"
21:05:46 <lambdabot>   [("C"," J K L P")]
21:05:59 <Cale> needs to be a space because of that :)
21:06:12 <Cale> oh, wait, you get an error?
21:06:13 <wo0kie> hmm
21:06:20 <Cale> what error?
21:06:24 <dmwit> Cale: Your type signature needs []
21:06:26 <wo0kie> when I did "CHJKD" :: (Suit, String)
21:06:28 <Cale> oh, derp
21:06:29 <Cale> yes
21:06:35 <Cale> reads "CHJKD" :: [(Suit, String)]
21:06:39 <Cale> but that'll give []
21:06:42 <Cale> reads "C HJKD" :: [(Suit, String)]
21:06:55 <Cale> that should get [(Clubs, " HJKD")]
21:07:19 <wo0kie> yeah that works
21:07:22 <wo0kie> :D
21:07:35 <wo0kie> reads is read string?
21:08:02 <Cale> I actually don't know why the s. Maybe it's kinda like the verb form?
21:08:16 <magicman> I've always interpreted that as being the plural.
21:08:32 <Cale> ah, that also works nicely :)
21:08:40 <Cale> all possible reads of the thing :)
21:08:52 <Cale> (in a list)
21:08:56 <wo0kie> hmm
21:08:57 <wo0kie> :)
21:09:05 <Cale> there's also shows though
21:09:14 <Cale> and it's not very pluralistic in nature
21:10:04 <Cale> shows x is a function which adds the string form of x to the beginning of another string
21:10:11 <Cale> > shows 56 " hello"
21:10:11 <lambdabot>   "56 hello"
21:10:13 <wo0kie> readsPrec d s = [ (suit,s') | (x,s') <- lex s, suit <- aux x ]
21:10:19 <wo0kie> what does this do?
21:10:51 <Cale> Okay, so that says to parse a Suit value from a string s (at precedence level d, which we don't care about)
21:10:52 <wo0kie> line 9 of http://pastebin.com/TWNwrKR3
21:10:52 <mauke> The paste TWNwrKR3 has been copied to http://hpaste.org/66097
21:11:19 <Cale> we let (x,s') be chosen from the list  lex s
21:11:30 <Cale> lex is a function which chops off the first "word" of a string
21:11:35 <Cale> roughly
21:11:49 <monochrom> also skips leading spaces
21:11:49 <Cale> It follows the rules of Haskell syntax more or less when it does that
21:11:52 <Cale> yeah
21:12:03 <wo0kie> interesting
21:12:12 <Cale> and then we let suit be picked from aux x
21:12:16 <monochrom> > lex "  Rex   tremendas   majestatis  "
21:12:17 <wo0kie> what is aux?
21:12:17 <lambdabot>   [("Rex","   tremendas   majestatis  ")]
21:12:24 <Cale> aux is the function defined just below
21:12:36 <Cale> which translates that first word of the string into a value of type Suit
21:12:43 <Cale> (a list of them, possibly empty)
21:12:56 <monochrom> darn, it's tremendae or something
21:13:12 <wo0kie> hmm
21:13:20 <Cale> So, when the word isn't one of these four suits "C", "H", "D", "S"
21:13:25 <Cale> we produce an empty list there
21:13:29 <Cale> (aux does)
21:13:33 <wo0kie> beginning to think I'm not cut out for this lol :\
21:13:37 <Cale> and there are no choices for suit
21:13:39 <wo0kie> but that makes sense
21:13:48 <Cale> and so the list comprehension gets an empty result
21:14:08 <Cale> reads "BLAH" :: [(Suit, String)]
21:14:12 <Cale> ^^ if you do that
21:14:15 <Cale> you should see []
21:14:23 <Cale> > lex "BLAH"
21:14:24 <lambdabot>   [("BLAH","")]
21:14:33 <wo0kie> ah
21:14:36 <Cale> so (x,s') is picked from that list
21:14:57 <Cale> and then aux "BLAH" = []
21:15:21 <Cale> and suit is picked from [] (which can't be done, so the list is empty)
21:15:48 <hpaste> zmoazeni pasted “Type confusion” at http://hpaste.org/66098
21:15:50 <zmoazeni> Am I making a boneheaded mistake in that paste?
21:16:30 <ion> (a,b) isn’t of type Integer.
21:16:55 <Cale> zmoazeni: yeah, State Integer Integer says that both the type of state being acted on and the result of the action are Integers
21:17:04 <Cale> you wanted  State Integer (Integer, Integer)
21:18:49 <Cale> > [(x :: Integer, y :: Double, z :: Char, s'') | (x,s) <- reads "1 2 'a' apple", (y,s') <- reads s, (z, s'') <- reads s']
21:18:50 <lambdabot>   [(1,2.0,'a'," apple")]
21:19:44 <zmoazeni> Thanks, that did work. Now to understand it
21:20:35 <wo0kie> god I have no idea how to do this...
21:20:45 <zmoazeni> Oh I see it. It's because of the "return"
21:20:48 <Cale> wo0kie: Well, what are you trying to do?
21:20:59 <wo0kie> well let me forwarn you and tell you it is hw
21:21:03 <wo0kie> so I don't want an answer
21:21:05 <Cale> sure
21:21:05 <wo0kie> just guidance
21:21:13 <Cale> But I can probably tell you something useful :)
21:21:13 <wo0kie> http://www.cs.rit.edu/~mtf/teaching/20113/psfp/homeworks/homework02/homework02.html
21:21:24 <wo0kie> under the Cards section, #1
21:21:26 <wo0kie> :)
21:21:43 <Cale> Right, so you'll have to list the *suits* somewhere
21:21:46 <wo0kie> I know it has to be a concatenation of rank and suit
21:21:47 <ion> Is Haskell/Standard ML like GNU/Linux?
21:22:17 <wo0kie> can I just define a new variable to hold a list of Suits?
21:22:25 <Cale> yes
21:22:35 <Cale> Or you can just use the list directly inside the definition of deck
21:22:42 <MierdaDeBerban> ayyy cale
21:22:45 <Cale> and you can use [1..13]
21:22:46 <MierdaDeBerban> tanta verga que tienes!
21:22:48 <iainm> ion, nope. Completely different languages.
21:22:50 <MierdaDeBerban> la quiero en mi culito
21:22:52 <MierdaDeBerban> siii siii sii
21:22:56 <MierdaDeBerban> la quiero la quiero la quiero
21:22:58 <Cale> I don't speak Spanish
21:22:59 <MierdaDeBerban> metemela a reves
21:23:02 <Cale> at all
21:23:03 <MierdaDeBerban> ohh yeahh cale
21:23:06 <wo0kie> "list directly inside the definition of deck"
21:23:09 <MierdaDeBerban> follame mi culito
21:23:10 <ion> iainm: (That was a joke.)
21:23:11 <wo0kie> trying to understand that
21:23:14 <MierdaDeBerban> :D
21:23:20 <MierdaDeBerban> te quiero un chingo buey
21:23:26 <MierdaDeBerban> no me vayas a fallar cale
21:23:34 <Cale> MierdaDeBerban: I don't understand you, please use English
21:23:43 <MierdaDeBerban> s que te gustara cogerte un culito de emo
21:23:45 <MierdaDeBerban> :D
21:23:50 <MierdaDeBerban> dame toda tu verga
21:23:55 <Cale> ???
21:23:57 <MierdaDeBerban> las 7 pulgadas completas
21:23:57 <wo0kie> ?
21:23:59 <MierdaDeBerban> ohh yeahh
21:24:01 <rwbarton> aren't you an op
21:24:02 <MierdaDeBerban> damela puto
21:24:05 <Cale> yes I am
21:24:07 <haus> mostly they are talking about fists in butts
21:24:07 <MierdaDeBerban> todo
21:24:07 <rwbarton> ...
21:24:08 <iainm> ion, oh.. guess I missed the context. Sorry.1
21:24:09 --- mode: ChanServ set +o Cale
21:24:20 <Cale> I have no idea what this guy is trying to say
21:24:24 <wo0kie> me neither
21:24:37 <haus> Cale: they're asking for sex in the ass
21:24:42 --- mode: Cale set +b *!*@201.170.98.88.dsl.dyn.telnor.net
21:24:43 --- kick: MierdaDeBerban was kicked by Cale (MierdaDeBerban)
21:24:47 --- mode: Cale set -o Cale
21:24:55 <Cale> haus: thanks
21:24:57 <wo0kie> lol
21:25:10 <haus> np, i knew that spanish would be useful someday
21:25:20 <zmoazeni> hah, I'm rather glad my spanish is more limited
21:25:26 <ion> haus: You should contact your teacher and thank him/her.
21:25:27 <wo0kie> Cale, you mentioned the list inside the definition of deck?
21:25:31 <Cale> wo0kie: right
21:25:41 <Cale> wo0kie: so, to make a card, you want to pick two things
21:25:52 <wo0kie> rank and suit, correct?
21:25:56 <Cale> wo0kie: you want to pick a suit, in all possible ways, and you want to pick a value from 1 to 13
21:25:57 <haus> ion: totally
21:25:58 <Cale> yeah
21:26:00 <flicker> Hello helpful Haskell channel. I have a small (9 line) script that I'm trying to write in Haskell, and it's exploding my computer's memory even though I feel like it should be super lazy. Would anyone be willing to take a look and see if I'm being an idiot?
21:26:07 <zmoazeni> ion / haus : haha. I'm sure they would be thrilled to know in what context their teaching became a utility
21:26:07 <Cale> flicker: sure
21:26:10 <wo0kie> 4 suits, 13 different cards
21:26:12 <wo0kie> makes sense
21:26:25 <flicker> Cale: http://pastebin.com/6vBvP9VH
21:26:27 <mauke> The paste 6vBvP9VH has been copied to http://hpaste.org/66099
21:26:39 <Recktum> cale
21:26:43 <Recktum> por qu no me quieres coger?
21:26:44 <Cale> wo0kie: List comprehensions are good at picking things in all possible ways
21:26:49 --- mode: ChanServ set +o Cale
21:26:50 <wo0kie> I'm wondering if there's a way I can somehow leverage the aux functions inside those instances?
21:26:52 <Recktum> me gustara tragarme tu vergota
21:26:52 --- mode: Cale set +b *!*@201.170.66.5.dsl.dyn.telnor.net
21:26:52 --- kick: Recktum was kicked by Cale (Recktum)
21:26:55 <wo0kie> yeah that's what I was thinking
21:26:56 <flicker> Cale: It's supposed to take all 10-element vectors with elements in [-10, 10] and find the sum of a small function on them
21:27:04 <wo0kie> it's just the syntax that's got me a bit wacky
21:27:33 <wo0kie> [ x | x meets some condition defined] = result list
21:28:01 <wo0kie> but is there a way to use those functions defined already in Read Card and Show Card to actually make a card?
21:28:04 <Cale> wo0kie: Well, you want to pick  suit from [Clubs, Hearts, Spades, Diamonds]
21:28:15 <Cale> wo0kie: and then you want to pick  rank from [1..13]
21:28:33 <Cale> and you want to produce  MkCard rank suit
21:29:13 <wo0kie> [MkCard x y | x <- [1..13], y <- [Clubs, Hearts, Spades, Diamonds] ]?
21:29:23 <wo0kie> I don't think the second condition would work lol :D
21:29:57 <Cale> wo0kie: did you try it?
21:30:08 <zmoazeni> wo0kie: If you haven't already, I'd heavily recommend working with ghci
21:30:19 <wo0kie> I do work with ghci :)
21:30:20 <Cale> flicker: hmm, there are a lot of 10 element vectors with elements in [-10,10]
21:30:26 <wo0kie> I can try it Cale, hold on :)
21:30:48 <Cale> flicker: specifically, there are 20^10 of them
21:30:50 <Cale> > 20^10
21:30:51 <lambdabot>   10240000000000
21:30:58 <flicker> Cale: I was hoping that via the magic of laziness, I could *actually* only generate one at a time, feed it to my function, store the sum in an accumulator (is haskell sum tail recursive?) and not worry about it
21:31:01 <Cale> that's going to take a very very long time
21:31:08 <wo0kie> whoa, it loaded without an error
21:31:13 <flicker> Cale: Hmm, maybe I'm just crazy then
21:31:20 <wo0kie> OMG IT WORKED
21:31:24 <wo0kie> DUDE
21:31:32 <Cale> flicker: well, okay, the problem here has to do with sharing
21:31:34 <wo0kie> mind = blown
21:32:02 <Cale> flicker: the list hypotheses is only computed once, and it's shared
21:32:14 <Cale> flicker: (because it's bound as a variable)
21:32:15 <wo0kie> Cale, you're a genius :)
21:32:46 <Cale> flicker: so the sum of the hypotheses list gets computed at the beginning, but those elements are not garbage, because we're mapping over that whole list
21:32:49 <flicker> Cale: So if I didn't bind it as a variable, it wouldn't keep old values around?
21:32:51 <wo0kie> had no idea I could use strings in list comprehensions lol
21:32:57 <wo0kie> #TIL
21:32:59 <wo0kie> lol
21:33:10 <flicker> Cale: i.e. map f (something generating hypotheses)
21:33:16 <Cale> wo0kie: You can use strings in list comprehensions, but those are not strings, they're data constructors
21:33:31 <wo0kie> defined in data Suit near the top?
21:34:03 <Cale> flicker: you'll want to use separate calls to allInRng when computing the inner sum from the one you're mapping over
21:34:32 <luite> does anyone know how to apply a class constraint to a Type if I have for example an (EvId $dNum) and a type variable?
21:34:49 <flicker> Cale: I can't map over the result, eh?
21:35:09 <Tijuanense> Are you sick of those niggers?
21:35:12 <Tijuanense> We are too!
21:35:14 <Tijuanense> Join
21:35:15 <Tijuanense> chimpout
21:35:16 <wo0kie> wtf
21:35:16 <Tijuanense> .com
21:35:18 <Tijuanense>  /forum
21:35:19 <Cale> flicker: because you want it to become garbage as that first sum is computed, and then have those elements be recomputed a second time
21:35:21 <Tijuanense> Join today!
21:35:22 <wo0kie> ban
21:35:23 --- mode: Cale set +b *!*@200.79.142.190.dsl.dyn.telnor.net
21:35:24 --- kick: Tijuanense was kicked by Cale (Tijuanense)
21:35:51 <Cale> man, the idiots are out in full force tonight
21:35:57 <flicker> Cale: That seems tough. Generating each element one at a time may not be super possible
21:36:04 <flicker> Cale: At least not with my limited Haskell background
21:36:10 <Cale> flicker: ?
21:36:37 <Cale> flicker: your allInRng is sort of fine (apart from your problem being *way* too large to approach in a brute force way like this)
21:36:58 <Cale> You can use it to make a program which runs in constant space, but you have to call it twice
21:37:06 <VergaDeGry> Are you sick of NIGGERS?
21:37:10 <VergaDeGry> We are too!
21:37:11 <VergaDeGry> Join
21:37:13 <VergaDeGry> chimpout
21:37:14 <VergaDeGry> .com
21:37:15 <VergaDeGry>  /forum
21:37:23 <VergaDeGry> At Chimpout WE ARE NOT WHITE SUPREMACISTS!
21:37:27 <VergaDeGry> I myself am a Mexican!
21:37:27 <flicker> Cale: I don't really understand where a second call to it would help
21:37:39 <VergaDeGry> Basically, if you are not a NIGGER and you hate NIGGERS, we welcome you with open arms!
21:37:40 <VergaDeGry> Join
21:37:42 <VergaDeGry> Chimpout
21:37:44 <VergaDeGry> .com
21:37:46 <VergaDeGry>  /forum
21:37:48 --- mode: Cale set +b *!*@200.79.132.243.dsl.dyn.telnor.net
21:37:48 --- kick: VergaDeGry was kicked by Cale (VergaDeGry)
21:38:12 <Cale> flicker: oh!
21:38:17 <Cale> flicker: I misread this, sorry
21:38:28 <Cale> yeah, then all you have to do is not bind it
21:39:05 <flicker> Cale: It still eats up all my memory, unfortunately
21:39:22 <Cale> oh, right
21:39:43 <Cale> heh, yeah, the other problem is that allInRng rng (n-1) is being held on to in the recursive call
21:39:49 <Cale> rather than being recomputed
21:39:55 <flicker> What if I replace it with this monster
21:40:03 <flicker> [[a, b, c, d, e, f, g, h, i, j] | a <- rng, b <- rng, c <- rng, d <- rng, e <- rng, f <- rng, g <- rng, h <- rng, i <- rng, j <-     rng]
21:40:14 <flicker> It still explodes, but my feeling is this should be fine
21:40:21 <flicker> But it's probably desugaring to something that kills me
21:40:34 <Recktum> Basically, if you are not a NIGGER and you hate NIGGERS, we welcome you with open arms!
21:40:37 <Recktum> Join
21:40:38 --- mode: Cale set +b *!*@201.170.60.15.dsl.dyn.telnor.net
21:40:39 --- kick: Recktum was kicked by Cale (Recktum)
21:40:48 <Cale> oh, I should just ban the ISP already
21:41:07 --- mode: Cale set +b *!*@*.dsl.dyn.telnor.net
21:41:18 <Cale> I'm sorry if anyone else has that ISP
21:41:39 --- mode: Cale set -bbbb *!*@201.170.60.15.dsl.dyn.telnor.net *!*@200.79.132.243.dsl.dyn.telnor.net *!*@200.79.142.190.dsl.dyn.telnor.net *!*@201.170.66.5.dsl.dyn.telnor.net
21:41:41 --- mode: Cale set -b *!*@201.170.98.88.dsl.dyn.telnor.net
21:42:03 <wo0kie> thanks for your help Cale :)
21:42:06 <wo0kie> much appreciated :)
21:42:10 <wo0kie> <3
21:42:17 <Cale> wo0kie: no problem
21:44:14 <flicker> Cale: Thanks for the help. I don't think I'm going to be able to solve my problem via this approach in a reasonable time frame, so I think I'll abandon this line of reasoning for now. I appreciate the lesson though.
21:44:20 <Cale> flicker: hmm, well, replicateM will work anyway...
21:45:06 <mdmarek> d
21:45:10 <Cale> allInRng rng n = replicateM n rng
21:45:34 <flicker> I see
21:45:44 <flicker> It will do the work and discard everything?
21:45:49 <Cale> er, oh, maybe not
21:45:54 <Cale> hum
21:47:29 <Cale> flicker: but in any case, the right solution is to approach this whole problem in a completely different way
21:48:26 <flicker> Cale: I mostly agree. The motivation is that I'm trying to define a probabilistic distribution meeting some requirement, and I thought I could do it easily by defining an arbitrary function meeting that requirement then doing this summation to normalize the result.
21:48:47 <flicker> Cale: But I'll probably have to go back to the drawing board and find something better.
21:49:05 <Cale> flicker: well, you're trying to sum over *way* too many things
21:49:19 <flicker> Cale: Yup.
21:49:45 <Cale> flicker: but because addition is associative and commutative, we can work out what this sum is by hand
21:50:13 <flicker> Cale: My math background is less than stellar :)
21:50:23 <Cale> flicker: just by working out how many times each value occurs
21:51:12 <Cale> btw, did you mean for rng to be [-10..10]
21:51:15 <Cale> or [0..10]?
21:52:11 <flicker> [-10..10]
21:52:19 <flicker> I used [0..10] in the problem as a way to cut down work
21:52:31 <flicker> Since all answers > [0  0] sum to the same as those < [0 .. 0]
21:52:35 <Cale> well, then the sum is quite obviously 0
21:52:35 <flicker> Thus the 2 * total - 1
21:52:40 <flicker> ...
21:52:47 <flicker> Sorry
21:52:50 <flicker> Absolute value!
21:52:58 <flicker> I should have mentioned, and I didn't code that in
21:53:33 <shachaf> I thought I was looking at ##math, but it turned out that it was just an op-the-Cale illusion.
21:53:41 <Cale> okay, so 0 occurs half as often as any other possible positive value then
21:54:05 <flicker> Yes
21:54:53 <Cale> oh, I see
21:55:04 <Cale> you're also doing this inversion
21:55:08 <Cale> yeah, hmm
21:55:21 <Cale> yeah, this is just too big :P
21:55:34 <flicker> I think I just need a distribution that has a property summation to 1
21:56:21 <Cale> actually...
21:56:30 <Cale> no, maybe we can do this
21:56:40 <Cale> We just need to count how many times each sum occurs
21:57:11 <flicker> As much as I appreciate the help, don't feel obligated to enter a combinatorics nightmare
21:58:51 <shergill> flicker: what's the question?
21:59:56 <flicker> shergill: I am trying to solve sum (1 / ( 1 + sum v)) for v in {set of all ten element vectors with integer values -10..10}
22:00:12 <Cale> oh, you're also adding 1?
22:00:23 <flicker> To avoid division by zero, yes
22:00:26 <flicker> Another implementation typo
22:00:34 <Cale> okay, also you're still missing the abs
22:00:39 <flicker> Yes
22:00:52 <flicker> shergill: I am trying to solve sum (abs (1 / ( 1 + sum v))) for v in {set of all ten element vectors with integer values -10..10}
22:00:56 <flicker> To correct myself
22:01:05 <shergill> what is sum v for a vector v? sum of the elements?
22:01:29 <Cale> okay, mathematica can totally solve this :)
22:01:33 <shergill> oh wait
22:01:37 <shergill> ok
22:01:42 * Cale uses generating series
22:01:50 <Cale> oh, actually, lol
22:01:53 <Cale> I can solve this too
22:02:04 <Cale> er...
22:02:17 <Cale> no, no, I really need it to do some of the grinding :)
22:02:40 <shergill> hmm no i'm confused. flicker, what is sum v. sum of all the elements in the vector?
22:02:51 <flicker> shergill: Yes, sorry. I was trying to be succint.
22:02:53 <Cale> We're looking for the coefficients of x^k in (1 + 2 ((x - x^11)/(1 - x)))^10
22:03:45 <Cale> and then we're going to take c_k/(1+k), where c_k is that coefficient :)
22:04:31 <Cale> another way to write that is (1 + 2 x + 2 x^2 + ... + 2 x^10)^10
22:04:56 <Cale> the coefficient of x^k in that is the number of ways to make an n-tuple with sum k
22:05:13 <Cale> So we just have to do a bunch of polynomial multiplication
22:05:24 <Cale> and then mess with the resulting coefficients :)
22:05:43 <tgeeky_> Cale: isn't that the partition problem?
22:05:58 <Cale> mmm, it's related
22:06:11 <tgeeky_> Cale: there is an algebraic solution for that
22:06:12 <Cale> we're doing weird double counting
22:06:19 * flicker gets lost in time and space
22:06:22 <Cale> which the partition problem doesn't have
22:06:33 <tgeeky_> Cale: because some of the n-tuples could have 0s?
22:06:50 <Cale> well, because we're taking the absolute values of the elements of the vector
22:06:58 <Cale> so each positive value occurs twice
22:07:10 <Cale> and yeah, 0's
22:07:26 <tgeeky_> Cale: nevertheless, that's still the partition problem, divided by two :o
22:07:27 <tgeeky_> hehehe
22:07:48 <Cale> so I get...
22:07:57 <Cale> Total[Table[1/(1 + SeriesCoefficient[(1 + 2 ((x - x^11)/(1 - x)))^10, {x, 0, k}]), {k, 0, 100}]]
22:08:13 <Cale> well... okay, I won't paste the rational number
22:08:14 <Cale> haha
22:08:21 <Cale> it's about 0.554636
22:08:28 <Cale> I can give more digits if you want
22:08:41 <flicker> That's surprising
22:08:44 <flicker> How can it be less than 1?
22:08:55 <flicker> Hmm
22:09:07 <flicker> Since one element of the sum should be (1/(1 + 0))
22:09:18 <Cale> er...
22:09:23 <Cale> oh, bah, messed it up
22:09:24 <tgeeky_> flicker: no
22:09:29 <Cale> (as you can see)
22:09:31 <tgeeky_> well, whatever he just pasted, plugged into mathematica
22:09:35 <tgeeky_> doesn't have a 1 term :)
22:09:48 <shergill> Cale: i thought we were taking absolute value of the total, and not absolute value of the elements of a vector
22:09:50 <Cale> Total[Table[SeriesCoefficient[(1 + 2 ((x - x^11)/(1 - x)))^10, {x, 0, k}]/(1 + k), {k, 0, 100}]]
22:09:54 <Cale> ^^ that's what I wanted
22:10:05 <Cale> 7123892323163164943647740684991902733858879346218409/22005493431878000605055983445207945810115
22:10:10 <flicker> Woah
22:10:10 <Cale> 3.23732*10^11
22:10:18 <Cale> better :)
22:10:18 <flicker> That's bigger than expected
22:11:11 <flicker> Thanks Cale
22:11:14 <tgeeky_> Cale: all of the divisors are prime?
22:11:30 <Cale> wat
22:11:31 <tgeeky_> nope, there's a 21
22:11:47 <tgeeky_> Cale: http://www.wolframalpha.com/input/?i=Total%5BTable%5BSeriesCoefficient%5B%281+%2B+2+%28%28x+-+x%5E11%29%2F%281+-+x%29%29%29%5E10%2C+%7Bx%2C+0%2C+k%7D%5D%2F%281+%2B+k%29%2C+%7Bk%2C+0%2C+100%7D%5D%5D
22:12:04 <tgeeky_> and a 9
22:12:15 <hpaste> Cale pasted “Expansion” at http://hpaste.org/66100
22:12:48 <Cale> tgeeky_: oh, it oddly ignored the Total
22:13:03 <tgeeky_> Cale: yes, hence the comment about the properties of the things being summed
22:13:15 <tgeeky_> Cale: this might be an interesting diophantine equation :o
22:16:06 <zmoazeni> Is anyone here familiar with yesod's way?
22:16:09 <zmoazeni> *wai
22:16:30 <zmoazeni> Actually, perhaps I should peg their specific channels irst
22:16:31 <tgeeky_> I was like... there's a way of the yesod already? That was fast.
22:16:33 <zmoazeni> *first
22:17:06 <zmoazeni> hehe
22:21:56 <yasar> what kind of applications do/did/will you write in haskell?
22:22:47 <Cale> I'm working on a game (engine) for iPhones and other mobile devices in Haskell :)
22:23:27 <zmoazeni> I'm experimenting with a small scale full text search engine. As much to learn haskell as to learn FTS concepts
22:24:24 <Cale> In the past, the largest program I'd written was probably the pipeline scheduler and register allocator for PPC+Altivec assembly that I wrote, as part of a project at McMaster University to produce a special purpose language + compiler for signal processing applications.
22:25:43 <yasar> Do you think haskell would suit for web applications or frameworks?
22:26:10 <Cale> yasar: yes, and there are a few such frameworks being worked on
22:29:41 <Pseudonym> zmoazeni, nice project.
22:30:01 <Pseudonym> You know a lot about text retrieval?
22:30:18 <zmoazeni> Pseudonym: Thanks. It's going slow. I don't, this was mostly to fix that
22:30:21 * Pseudonym nods
22:30:43 <Pseudonym> Here's my acid test for knowing how much you know: Would it impress you of I told you that Justin Zobel is my boss?
22:31:00 <zmoazeni> I'm slowly compiling my incremental experiments in https://github.com/zmoazeni/karkeze/
22:31:26 <tgeeky_> Pseudonym: it tells me that you're employed, which is currently impressive in its own right.
22:31:31 * Pseudonym laughs
22:31:53 <Pseudonym> My copy of Managing Gigabytes is signed.
22:32:26 <zmoazeni> Pseudonym: Sorry, it doesn't ring a bell. But a quick google search comes up with a list of research on text retrieval
22:32:44 <tgeeky_> I once saw Stephen Hawking sign a supermodel's exposed breast.
22:32:59 * Pseudonym can drop a bunch more names; used to be employed in text databases
22:33:47 <Cale> tgeeky_: lol, really?
22:33:47 <flicker> Cale: Thanks again for the help, I'm heading to bed
22:33:52 <Cale> flicker: no problem
22:33:56 --- mode: Cale set -o Cale
22:34:07 <tgeeky_> Cale: I'm embellishing that she was a supermodel, but she was quite attractive.
22:39:20 <zmoazeni> I don't suppose anyone here has worked with Network.Wai and Data.Conduit? I'm getting odd results trying to manually retrieve the request body within a new package http://hackage.haskell.org/package/scotty-0.0.1 http://hpaste.org/66102
22:45:31 <zmoazeni> For a bit more context, I pushed up the code to https://github.com/zmoazeni/karkeze/blob/master/src/Web.hs
22:59:11 <nyingen> @quote
22:59:11 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
22:59:17 <nyingen> @quote
22:59:17 <lambdabot> ghci.debugger says: http://haskell.org/haskellwiki/Ghci/Debugger
22:59:55 <nyingen> @quote
22:59:56 <lambdabot> <lament> says: syntaxfree: ouch
23:00:22 <nyingen> that's 3 lame quotes in a row, unless that last quote was referring to lisp
23:03:38 <Enigmagic> zmoazeni: looks like more of a scotty question than wai or conduit
23:04:08 <zmoazeni> Enigmagic: I'm not so sure. Most of those functions are from wai and conduit
23:07:42 <Enigmagic> zmoazeni: try setting the post mime type to application/x-www-form-urlencoded
23:08:34 <zmoazeni> Enigmagic: I'm actually talking with someone in #yesod it may be since I'm using lazy byte strings, the resource is closed before I use it
23:09:24 <Enigmagic> zmoazeni: okay, well it looks from the scotty source that it does some form processing here http://hackage.haskell.org/packages/archive/scotty/0.2.0/doc/html/src/Web-Scotty.html#mkEnv
23:09:38 <Enigmagic> which would also read in the body
23:09:51 <Enigmagic> which would cause it to be empty ?
23:10:16 <zmoazeni> Yeah, they also refer to that body for parsing params too. I may have an issue where two different parts of the code is trying to slurp from the same stream of data
23:10:36 <zmoazeni> btw https://github.com/xich/scotty/blob/master/Web/Scotty.hs is more up to date than those docs. I've noticed some discrepencies
23:10:53 <Enigmagic> did you build it from hackage/cabal-install or git?
23:11:16 <zmoazeni> There is a getBody function on ActionEnv but it's not exported. I was going to try and fork and submit a pull request for it
23:11:43 <zmoazeni> I installed from cabal, but the code from cabal matches whats in git and is different than what those docs show
23:12:02 <zmoazeni> Wait, I'm wrong. I'm thinking about wai
23:12:51 <zmoazeni> Actually, ignore me altogether. I thought I saw a discrepancy, but it must be my mind playing tricks
23:13:06 <Enigmagic> :)
23:21:27 <yasar> What should I do when this happens? http://pastebin.com/6CY3eZfk
23:21:29 <mauke> The paste 6CY3eZfk has been copied to http://hpaste.org/66103
23:22:33 <kallisti> hm, I can't figure out how to go about automatically deriving MonadBase and MonadBaseControl
23:25:02 <kallisti> I guess I should just use liftBaseDefault
23:26:06 <DijkstraGroupie> Hello, just for the sake of making my code look shorter, is there any function that reverses a pair (a,b)?
23:26:20 <kallisti> :t swap
23:26:20 <lambdabot> Not in scope: `swap'
23:26:24 <kallisti> @hoogle swap
23:26:24 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
23:26:25 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
23:26:25 <lambdabot> Graphics.UI.GLUT.Window swapBuffers :: IO ()
23:26:31 <DijkstraGroupie> kallisti: Awesome! Thanks!
23:26:31 <kallisti> yes. in Data.Tuple
23:26:44 <kallisti> no problem.
23:27:24 <ykm> > \ (a,b) -> (b,a)
23:27:25 <lambdabot>   Overlapping instances for GHC.Show.Show ((t, t1) -> (t1, t))
23:27:25 <lambdabot>    arising fro...
23:27:32 <Enigmagic> kallisti: they can't be automatically derived anymore
23:28:13 <kallisti> are there any gotchas with the default implementations?
23:29:07 <DijkstraGroupie> kallisti: ghci complains that Data.Tuple does not export swap
23:29:26 <kallisti> > :m + Data.Tuple
23:29:28 <kallisti> Prelude Data.Tuple> :t swap
23:29:28 <kallisti> swap :: (a, b) -> (b, a)
23:29:28 <lambdabot>   <no location info>: parse error on input `:'
23:29:45 <ykm> DijkstraGroupie: lambda?  \ (a,b) -> (b,a)
23:29:49 <Enigmagic> kallisti: i haven't hit any, though i don't know enough to say for sure
23:30:08 <kallisti> oh wait, I'm dumb. My monad isn't even a transformer. it just needs an "id" instance.
23:30:28 <DijkstraGroupie> yhm: I know I can do that, but that would make my code look longer.
23:31:41 <kallisti> not sure what MonadBaseControl is supposed to look like though.
23:31:53 <yasar> This is the first time I am installing with cabal, where does stuff get installed?
23:32:23 <Enigmagic> kallisti: here's one of mine http://hackage.haskell.org/packages/archive/timeout-control/0.1/doc/html/src/System-Timeout-Control.html#line-66
23:32:39 <kallisti> I just need
23:32:47 <kallisti> instance MonadBaseControl (m a) (m a) where ...
23:32:52 <kallisti> for my particular m
23:33:20 <kallisti> but I don't really get this StM business.
23:33:32 <Enigmagic> I think the first parameter is supposed to be the base (like IO)
23:33:48 <kallisti> yes, my monad isn't a transformer
23:33:49 <kallisti> it's a base monad.
23:33:51 <kallisti> like IO.
23:34:07 <kallisti> (it does IO things)
23:34:15 <Enigmagic> then you'd want instance MonadBaseControl m m where
23:34:23 <ivanm> wasn't the Yesod book meant to be out around now?
23:34:24 <kallisti> ah
23:34:29 <Enigmagic> where m is your monad
23:34:33 <ivanm> could have sworn it was meant to be out end of march...
23:34:43 <kallisti> but what is StM here?
23:35:48 <kallisti> Enigmagic: I guess I could just use the defaults as you do?
23:36:28 <Enigmagic> kallisti: i think so
23:37:18 <kallisti> but...... what is StM supposed to be.
23:37:38 <kallisti> oh nevermind I see. :P
23:38:13 <Enigmagic> that's how restore works
23:38:52 <kallisti> one problem is that I have no m
23:39:04 <kallisti> ComposeSt T m a
23:39:06 <kallisti> for this type.
23:39:09 <kallisti> where T is my monad.
23:40:08 <kallisti> my monad is a newtype, so I guess I should just explicitly place the inner monad type?
23:41:24 <Enigmagic> kallisti: http://hackage.haskell.org/packages/archive/monad-control/0.3.1/doc/html/src/Control-Monad-Trans-Control.html#line-273
23:41:42 <kallisti> ...oh, I see
23:41:45 <kallisti> so I should just read more.
23:42:08 <kallisti> instead of being tired.
23:43:21 <Enigmagic> that's one option
23:47:16 <kallisti> does TypeFamilies do weird things to type inferrence?
23:47:27 <kallisti> as I got a whole host of unrelated type errors suddenly.
23:47:32 <kallisti> from adding those instances.
23:49:26 <Enigmagic> i haven't noticed anything in particular but i'm sure it changes type inference
23:49:58 <Enigmagic> (though the type checker is all based on type families as of 7.0 i believe)
23:50:00 <kallisti> perhaps I should move these instances to their own module so that I can avoid changing the rest of this code.
23:54:46 <kallisti> bah cyclic imports.
23:58:55 <lambda_zero_cool> noob question - can i map one element of a list to multiple elements of another list?
23:59:04 <kallisti> I really don't understand why these types can no longer be inferred...
