00:18:34 <dp_wiz> Is there a toLower for bytestrings?
00:19:05 <Twey> dp_wiz: I would be very surprised
00:19:43 <Twey> dp_wiz: A ByteString represents binary data; if you want something with the performance characteristics of ByteString but representing text, with all the text functions that entails, use Text
00:20:33 <Axman6> @hoogle (Char -> Char) -> Text -> Text
00:20:33 <lambdabot> Data.Text map :: (Char -> Char) -> Text -> Text
00:20:34 <lambdabot> Data.Text.Lazy map :: (Char -> Char) -> Text -> Text
00:20:34 <lambdabot> Data.Generics.Aliases mkT :: (Typeable a, Typeable b) => (b -> b) -> a -> a
00:20:49 <Axman6> @hoogle ByteString -> Text
00:20:49 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
00:20:50 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
00:20:50 <lambdabot> Data.Text.Encoding decodeUtf16BE :: ByteString -> Text
00:21:31 <dp_wiz> Twey: yep. I know. I just thought there would be something as simple as trivial ascii lowercase.
00:21:43 <Twey> dp_wiz: That's not what ByteStrings are for
00:22:47 * dp_wiz made a "B.map GHC.Unicode.toLower" contraption, but it smells...
00:23:49 <yitz> @type Data.ByteString.Char8.map toLower -- but really, don't use this dp_wiz, use Text.
00:23:50 <lambdabot> BSC.ByteString -> BSC.ByteString
00:26:06 <ehy_> snoc empty (ord 'c')
00:26:10 <ehy_> > snoc empty (ord 'c')
00:26:11 <lambdabot>   Not in scope: `snoc'Ambiguous occurrence `empty'
00:26:11 <lambdabot>  It could refer to either ...
00:26:19 <ehy_> > snoc empty (ord 'c')
00:26:20 <lambdabot>   Not in scope: `snoc'Ambiguous occurrence `empty'
00:26:20 <lambdabot>  It could refer to either ...
00:26:32 <ehy_> > Data.ByteString.snoc empty (ord 'c')
00:26:33 <lambdabot>   Not in scope: `Data.ByteString.snoc'Ambiguous occurrence `empty'
00:26:33 <lambdabot>  It could ...
00:26:34 <dp_wiz> i'm using attoparsec, and there's only bytestrings inside. But my data is in ASCII anyway.
00:26:38 <ehy_> > Data.Bytestring.snoc empty (ord 'c')
00:26:39 <lambdabot>   Not in scope: `Data.Bytestring.snoc'Ambiguous occurrence `empty'
00:26:39 <lambdabot>  It could ...
00:26:44 <ehy_> > cons empty (ord 'c')
00:26:45 <lambdabot>   Not in scope: `cons'Ambiguous occurrence `empty'
00:26:45 <lambdabot>  It could refer to either ...
00:26:57 <yitz> dp_wiz: no attoparsec supports Text too.
00:28:14 <ehy_> > snoc empty (fromIntegral $ ord 'c')
00:28:14 <lambdabot>   Not in scope: `snoc'Ambiguous occurrence `empty'
00:28:15 <lambdabot>  It could refer to either ...
00:28:15 <yitz> dp_wiz: usually if ASCII represents text, it is just a special case of UTF-8 encoded text, and you should use Text.
00:28:31 <qiqi> guys, a question regarding if-then-else within do blocks. my incorrect code:  do fileexists <- doesFileExist "test.in"; { if fileExists then content <- readFile "test.in" else content =""} do more stuff with content
00:28:39 <ehy_> ? fromList [1, 2, 3]
00:28:41 <ehy_> > fromList [1, 2, 3]
00:28:42 <lambdabot>   No instance for (GHC.Show.Show (m a))
00:28:42 <lambdabot>    arising from a use of `M9458743029...
00:28:53 <ehy_> > Data.Sequence.fromList [1, 2, 3]
00:28:54 <lambdabot>   Not in scope: `Data.Sequence.fromList'
00:29:06 <ehy_> > fromList [1, 2, 3] :: Seq
00:29:07 <lambdabot>   Not in scope: type constructor or class `Seq'
00:29:13 <qiqi> i understand why this is wrong, but don't see how to write correct code without having "do more stuff with content" repeated in both then and else branches of if
00:29:32 <qiqi> so help is greatly appreciated!
00:29:54 <qnikst> can I create one prepared statement in HDBC and then execute it many times?
00:30:18 <Veinor> qiqi: content <- {if fileExists then readFile "test.in" else return ""}
00:31:16 <yitz> without the {} brackets
00:31:19 <qiqi> Veinor: that's a good idea!
00:33:14 <yitz> @type Seq.empty
00:33:15 <lambdabot> forall a. Seq.Seq a
00:33:26 <yitz> @type Seq.fromList
00:33:27 <lambdabot> forall a. [a] -> Seq.Seq a
00:33:50 <yitz> ehy_: that's lambdabot-speak
00:37:36 <ChristianS> @type Data.ByteString.Char8.map Data.Char.toLower
00:37:37 <lambdabot> BSC.ByteString -> BSC.ByteString
00:37:54 <ChristianS> dp_wiz: that ^^ should work for all-ascii bytestrings.
00:38:20 * hackagebot data-ordlist 0.4.5 - Set and bag operations on ordered lists  http://hackage.haskell.org/package/data-ordlist-0.4.5 (LeonSmith)
00:38:22 * hackagebot xml-hamlet 0.2.0.2 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.2.0.2 (MichaelSnoyman)
00:56:25 <pdxleif> When I saw Reader had a "mapReader" method, I thought "huh - couldn't you just use fmap?"
00:56:52 <pdxleif> And sure enough, there's an fmap instance defined: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-Reader.html#mapReader
00:57:46 <pdxleif> Only difference looks like they eta-reduced the r out of the last part of mapReader's def?
01:00:40 <ChristianS> qnikst: sure: stmt <- prepare conn "INSERT INTO test VALUES (?, ?)"; execute stmt [toSql 1, toSql "one"];
01:02:05 <qnikst> ChristianS: I mean can I do stmt <- prepare conn .. ; execute stmt ; execute stmt ; execute stmt
01:02:22 <qnikst> and should I do explisit finish in this case?
01:02:27 <qnikst> *explicit
01:03:27 <ChristianS> qnikst: sure you can, that's what prepared statements are for. finally you need  commit conn  , nothing else, i think
01:04:28 <ChristianS> qnikst: there is a good chapter on databases and HDBC in RWH
01:04:34 <ChristianS> @where RWH
01:04:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:08:22 * hackagebot shelly 0.3.0.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.3.0.1 (GregWeber)
01:09:42 <qnikst> ChristianS: thanks
01:22:51 <ezyang> Why oh why are sequent rules upside down
01:33:32 <t7> @slap t7
01:33:33 * lambdabot is overcome by a sudden desire to hurt t7
01:43:22 * hackagebot uuagc 0.9.40.3 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.40.3 (ArieMiddelkoop)
02:05:02 <elemir> @slap lambdabot
02:05:03 * lambdabot would never hurt lambdabot!
02:06:03 <Guest26576> @slap lambdabot
02:06:03 <lambdabot> stop telling me what to do
02:06:16 <Guest26576> @beat lambdabot
02:06:16 <lambdabot> Maybe you meant: keal let read what
02:19:48 <ksf> @pl (\(y:ys) -> toLower y : ys)
02:19:48 <lambdabot> ap ((:) . toLower . head) tail
02:19:56 <ksf> ugh
02:31:39 <ksf> is there something like fclabels, but supporting equally-named fields in different records?
02:32:14 <ksf> frankly I'm surprised fclabels doesn't, as it should be just a wee bit of typeclass hackery away.
02:34:38 <ksf> two typeclasses per name, once fundep'd, once fully polymorphic.
02:35:46 <ksf> the problem, of course, becomes "where to define the class", but I think the name pain is painful enough to make people reserve a module for that.
02:36:40 <ksf> ...it's one of those things extensible record libraries just declare as a non-problem.
02:37:02 <mroman> I assume it is possible to implement linked lists *solely* on type level?
02:37:15 <mroman> i.e only using data and type constructors?
02:37:23 <mroman> Maybe GADT?
02:37:27 <t7> whats the 'safe' way to track sessions? Are cookies still ok?
02:39:39 <c_wraith> safe from what?
02:39:49 <t7> the hax0rs
02:39:57 <c_wraith> that's...  meaningless.
02:40:00 <c_wraith> Safe from what threats?
02:40:11 <dfletcher> your cookies are never safe from me muahahaha
02:40:47 <t7> mitm
02:40:53 <Tinned_Tuna> cookies are delivious. You can't stop me from getting them.
02:40:55 <t7> i guess i need ssl
02:41:14 <c_wraith> ssl is only sometimes-maybe good enough to stop mitm. :)
02:41:28 <Tinned_Tuna> Even a one-time-pad scheme won't stop me getting your cookies.
02:41:38 <dfletcher> http://weknowmemes.com/wp-content/uploads/2011/10/occupy-sesame-street-99-percent-of-the-cookies-are-eaten-by-1-percent-of-the-monsters.jpg
02:42:01 <ksf> mroman, sure it is.
02:42:18 <ksf> the type level is turing complete (thanks to -XUndecidableInstances)
02:42:31 <c_wraith> But you still haven't really said anything about the threats.  Do you want to stop people from impersonating other users?  From modifying their own state?  What's the threat?
02:43:24 * hackagebot graphicstools 0.2.1 - Tools for creating graphical UIs, based on wxHaskell.  http://hackage.haskell.org/package/graphicstools-0.2.1 (VilleTirronen)
02:43:46 <ksf> mroman, data :[]; data a ::: b; type MyList = Int ::: Bool ::: :[]
02:43:51 <t7> other users stealing sessions
02:44:14 <ksf> needs -XTypeOperators and -XEmptyDataDecls to work
02:44:24 <ksf> oh, and a fixity declaration.
02:44:46 <Tinned_Tuna> t7: would this help: https://www.owasp.org/index.php/Main_Page ?
02:44:53 <mroman> ::::?
02:45:06 <Tinned_Tuna> mroman: "is really of type... honestly."
02:45:28 <c_wraith> ok.  #1 vulnerability for that is unencrypted wireless.  No matter what you do with the mechanism for communicating state between browser and server, if it's not encrypted, it will be easily-stolen
02:46:04 <c_wraith> SSL protects pretty well at that level.
02:46:07 <ksf> mroman, well. : isn't a valid type level operator, :: even less, and ::: was the next one.
02:46:10 <Tinned_Tuna> t7: Vuln. #2 -- compromised user machine.
02:46:13 <ksf> :. is common, too.
02:47:08 <ksf> mroman, if you want to dive into type-level hackery, the oohaskell paper and "fun with type functions" are a good start.
02:47:20 <ksf> (for some value of "start")
02:48:48 <c_wraith> beyond that, if you want to use cookies, fine.  A few things to protect them:  Always set them with the secure option set to true.  Otherwise clever html-injection can trick your browser into revealing them, even if your site only uses https.
02:49:30 <c_wraith> second, store only a randomly-generated (preferably with crypto-quality entropy) identifier in the cookie, which is associated with a server-side session that stores all the actual data.
02:49:32 <Tinned_Tuna> t7: Also, if you're using Session cookies for authentication, be sure to guard against session fixation attacks
02:51:34 <c_wraith> the httponly flag isn't a bad idea either, even if some browsers get it wrong.
02:52:04 <c_wraith> it's primitive protection against running malicious javascript
02:54:46 <Tinned_Tuna> t7: basically web application security is hard.
02:55:06 <Tinned_Tuna> t7: if you can use a framework that's already tackled the majority of this, then do.
02:55:12 <t7> its only other peoples bitcoin...
02:58:14 <Tinned_Tuna> ahh, so it's not like people could suffer financial loss.
02:59:08 <t7> hehe
03:06:25 <norm2782> I'm trying to run quickcheck at runtime using hint. this all works fine when testing in GHCi in my project dir, but once I deploy my app to a testing server, I get this error: WontCompile [GhcError {errMsg = "Could not find module `Test.QuickCheck' Locations searched: Test/QuickCheck.hs Test/QuickCheck.lhs"}]
03:06:48 <norm2782> so then when I copy those source files to the proper locations, it can find them, but then I get this error: NotAllowed "module is not loaded: `Test.QuickCheck' (./Test/QuickCheck.hs)"
03:07:19 <norm2782> why can't it load the modules?
03:08:13 <geekosaur> NotAllowed makes me think that's ghc 7.2/7.4 with safe haskell enabled
03:08:28 <norm2782> hmm, yes, it is 7.2
03:09:19 <norm2782> although I did not specify safe haskell to be enabled
03:15:30 <t7> brb in 5 hours, building snap
03:18:34 <t7> ah it doesnt build
03:18:53 <t7> why wouldnt they test against the platform :(
03:27:48 <yitz> t7: could be you're experience cabal conflicts
03:27:56 <yitz> *experiencing
03:48:08 <Rc43> Hi, guys.
03:48:18 <Rc43> fix f = let x = f x in x
03:48:22 <Rc43> How it works?
03:48:29 <geekosaur> let is recursive
03:48:59 <Rc43> What is base of recursion?
03:49:05 <Twey> Rc43: None
03:49:08 <Twey> That's the point
03:49:31 <Rc43> ?
03:49:32 <Twey> It will recurse forever, unless at some point the value of ‚Äòf x‚Äô no longer depends on the value of x
03:49:46 <Rc43> It is expands to f $ f $ f $ .... right?
03:49:58 <Twey> Yes
03:50:10 <geekosaur> or, because it is lazy, until no more values are needed from it (thus it is one way to make an inifnite list from which a finite number of values can be "peeled" off the head
03:50:11 <geekosaur> )
03:51:17 <Rc43> Oh
03:51:38 <Rc43> so `f x` doesn't equal to `f $ f x` here?
03:51:59 <mrcarrot> while normal recursion is easy to understand, infinite recursion like this is in some way over my head. i can understan infinite lists, but how do you even get one single element when you have infinite calculations to get that single value
03:51:59 <Rc43> Firstly it computes f x, where x is lazt, then replace x with result?
03:52:07 <geekosaur> it does.. which then becomes f $ f $ x, which becomes f $ f $ f $ x ...
03:53:04 <mrcarrot> to me it looks like infinite steps to get even one value....
03:53:29 <srhb> mrcarrot: What is the code you're thinking about_
03:53:34 <Rc43> I mean, it works because x is lazy and infinite calculation will be dropped.
03:53:42 <Rc43> Ok, it seems I understood.
03:53:46 <geekosaur> > let { fix f = let x = f x in x } in take 3 $ fix (0:) -- I think
03:53:47 <lambdabot>   [0,0,0]
03:53:51 <geekosaur> yep
03:54:04 <Rc43> But the deep meaning is hidden for me any way.
03:54:08 <geekosaur> it only needed to "turn the crank" 3 times, so no infinite recursion
03:54:50 <geekosaur> because it's lazy, fix is only iterated *as needed*; the "take 3" there meant it only needed to be iterated 3 times
03:55:00 <Tinned_Tuna> @let fix f = f $ fix f
03:55:00 <lambdabot>  <local>:6:12:
03:55:00 <lambdabot>      Ambiguous occurrence `fix'
03:55:01 <lambdabot>      It could refer to either ...
03:55:11 <Tinned_Tuna> @let fixy f = f $ fixy f
03:55:12 <lambdabot>  Defined.
03:55:14 <Rc43> Anybody knows something about  fixed point application in algorithms on graph? Like here ftp://www.cs.indiana.edu/pub/techreports/TR330.pdf
03:55:16 <Tinned_Tuna> :t fixy
03:55:17 <lambdabot> forall b. (b -> b) -> b
03:55:34 <Tinned_Tuna> take 3 $ fixy (1:)
03:55:40 <Tinned_Tuna> > take 3 $ fixy (1:)
03:55:42 <lambdabot>   [1,1,1]
03:56:51 <Rc43> :source fixy
03:56:58 <Rc43> How to get source?
03:57:23 <qnikst> > fix (\k l -> if l>3 then l else k (l+1)) 1
03:57:24 <geekosaur> I don't think you can get it back
03:57:24 <lambdabot>   4
03:57:36 <Rc43> qnikst, hi
03:57:38 <Rc43> :D
03:57:56 <qnikst> fix also allowes you to run 'recursion' inplace
03:58:01 <mrcarrot> yeah, (:) is a function that i can get with this infinite recursion, actually
03:58:18 <yitz> Rc43: the logs of this IRC channel (see channel topic). that is a temporary function that Tinned_Tuna just defined in lambdabot here in the channel.
03:58:24 <mrcarrot> actually i created a similar infinite recursion for fibbonacci numbers
03:59:12 <qnikst> \whois Rc43
03:59:15 <qnikst> hi
03:59:18 <Rc43> Kirill
04:00:27 <hpaste> Rc43 pasted ‚ÄúFloyd‚Äù at http://hpaste.org/65186
04:00:58 <Rc43> Why I am asking about graphs and fix point? Just trying to find way to make my code faster. It is needed for training contest.
04:01:40 <Rc43> Firstly it was failing on some test with (time>2sec, memory>60mb), this solution is (>2sec,>2mb)
04:03:23 <hpaste> DxBlueIce pasted ‚ÄúlookAt - OpenGL‚Äù at http://hpaste.org/65187
04:03:40 <DxBlueIce> kann anyone check my code, dunno why its not working
04:03:41 <DxBlueIce> http://hpaste.org/65187
04:04:01 <DxBlueIce> its hopengl, trying to move a camera through a level (3d map)
04:04:45 <yitz> mrcarrot: these "inifinite recursions" always return a type with two components, with the recursion only in one of them. if you only demand the other component, the recursion never happens. even if you demand the other component, you can use the same trick again for two components it returns.
04:06:34 <yitz> mrcarrot: uh, s/other component, you can/recursive component, you can/
04:07:56 <jtobin> anyone - what is `the' procedure for iterating a monadic step?
04:08:33 * hackagebot Agda 2.3.0.1 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.3.0.1 (UlfNorell)
04:08:35 * hackagebot Agda-executable 2.3.0.1 - Command-line program for type-checking and compiling Agda programs  http://hackage.haskell.org/package/Agda-executable-2.3.0.1 (UlfNorell)
04:09:04 <jtobin> i've got an interesting persistent state and a plain old generator wrapped up as StateT Double (State StdGen) ()
04:09:12 <geekosaur> DxBlueIce, what "doesn't work" about it?
04:09:27 <DxBlueIce> src\Main.hs:35:3: parse error (possibly incorrect indentation)
04:09:53 <geekosaur> missing close paren on line 34?
04:10:24 <DxBlueIce> lol
04:10:28 <DxBlueIce> thank you very much :D
04:12:24 <srhb> I'm curious, why is there no Haskell 2011?
04:12:34 <srhb> Was the idea of Haskell' not to produce a standard each year?
04:12:47 <dmwit> I think that was the idea, yes.
04:13:13 <dmwit> Perhaps you should petition to be put on the committee. =)
04:13:21 <srhb> That would be a horrible idea. :-)
04:15:38 <DxBlueIce> can anyone link me a good haskell hopengl tutorial for moving in a 3d room/level?
04:15:46 <srhb> I guess the fact that GHC has the extensions, and GHC is the default choice means that there's little motivation to actually include things into the Haskell Standard as such, since the "GHC Standard" is, well, The Standard.
04:16:13 <geekosaur> not really true, the real standard is quite conservative
04:17:43 <geekosaur> which is why there was no 2011; there wasn't anything deemed worthy.  (keep in mind that even old stuff like MPTCs are not part of the official standard; admittedly that's because of the fundeps vs. type families discussion, where the latter are still too "new" and the former considered a poor if effective design)
04:17:44 <Twey> geekosaur: Which is part of why the GHC standard is The Standard.
04:19:03 <Botje> DxBlueIce: just glTranslate to your position and glRotate according to your rotation
04:19:04 <Twey> Most people are more inclined to code with something useful that has a fairly small possibility of changing later, and update their code if and when it becomes necessary, than to stick to a significantly less featureful subset of the language in the fear that their code might break some day.
04:19:14 <Twey> I would guess.
04:20:03 <Tinned_Tuna> Twey: I always avoid GHC extensions.
04:20:12 <Tinned_Tuna> but I'm just that kinda crazy
04:20:15 <Twey> I suppose industry usage might be different, but since one has to rely on community libraries most of the time anyway, it's a reasonably useless endeavour.
04:20:41 <Twey> Tinned_Tuna: Do you develop aeroplane control software?  ‚ò∫
04:20:54 <Tinned_Tuna> Well, that does raise a valid point. I may avoid them, but I'm fairly certain that the libraries I rely on don't ¨.¨
04:21:02 <Tinned_Tuna> Twey: I wish I was that cool.
04:21:56 <Tinned_Tuna> Twey: nope, I'm just that particular variation of paranoid. Plus I don't like the idea of one compiler community dictating the direction of the language to all of the language users, but that's by the by
04:21:59 <srhb> I think GHC extensions are a great way of pushing the language forward, no matter if we call it Haskell og GHC-lang, I was just curious if Haskell' had stagnated or was just, as geekosaur implied "comfortable"
04:22:17 <Twey> (actually, that's kind of a silly question: I guess if you did you'd worry more about losing the type-safety provided by extensions and having a mid-air breakdown than the possibility of the build breaking safely some day)
04:22:28 <srhb> (But I am also uncool)
04:23:02 <Twey> Tinned_Tuna: *nod* That's fairly valid, I suppose
04:23:13 <Twey> (the latter part)
04:23:22 <srhb> Indeed. What would it take for a Standard change in Haskell to mean your code would still compile, but do something wrong..
04:23:32 <srhb> Or in other words: How safe are extensions.
04:24:24 <Twey> I think that's very unlikely to ever happen
04:24:29 <srhb> Is it even possible to guarantee that a Standard Revision will never (excluding bugs) break a Haskell program, so that it still compiles but does something wrong?
04:24:32 <srhb> yes, I have the same feeling.
04:24:33 <Twey> The standards dictate interfaces rather than implementation
04:24:53 <geekosaur> I don't believe any such change wouldbe (intentionally) accepted
04:25:21 <geekosaur> which is part of why the standard is convervative; they like to make sure first
04:25:26 <srhb> No, I think you're right. I guess this is just part of the "rationalizing extensions" self-dialogue.
04:25:58 <geekosaur> (there have been changes which break programs, but as compile-time breakage that can be fixed, not as unexpected runtime behavior)
04:26:48 <srhb> And it is important that that is what happens, yes. I guess it's an implicit guarantee, ie. "We're not that stupid"
04:27:48 <ChristianS> srh: about "Haskell 2011", see here: http://www.haskell.org/pipermail/haskell/2011-January/022497.html
04:27:56 <geekosaur> (hm, with one possible exception, but the point there was it couldn;t be done as written... the brace insertion rule, which I think did vary between some compilers, and conceivably multuiple valid parses could exist... but that it could happen in the first place was the bug)
04:28:07 <srhb> ChristianS: Thanks!
04:28:38 <srhb> ChristianS: That really sums it up nicely.
04:29:05 <gregATio> quick question which i would like answered in the form of haiku if you dont mind
04:29:25 <geekosaur> uh
04:29:27 <gregATio> how can i get a buffer to auto update if the file behind it is changed
04:29:39 <srhb> gregATio: Is this a Haskell question?
04:29:50 <gregATio> oops wrong channel sorry
04:29:59 <srhb> gregATio: (M-x auto-revert-mode)
04:30:34 <ChristianS> gregATio: use vim, it'll ask.
04:31:00 <DxBlueIce> Botje: i want to move "myself", not a shape
04:31:38 <srhb> gregATio: No, it will ask on write. You need :set autoread if you want the behaviour he described. (but now we veered very much off topic :-))
04:31:45 <srhb> Oops, that was for ChristianS
04:32:21 <dmwit> ?index readLn
04:32:21 <lambdabot> System.IO, Prelude
04:42:02 <ChristianS> srhb: well, vim asks me (without autoread) immediately after the file has changed, not just before write, when it would be too late (not sure whether i set another option that triggered that specific behavior or whether it is default). but you're right about the off-topicness...
04:43:00 <yitz> gregATio: the type is not pure / the buffer is not lazy / it is not haskell
04:43:59 <dmwit> ?quote sorear default
04:43:59 <lambdabot> No quotes match. I am sorry.
04:45:03 <dmwit> Hm, that discussion appears to have occurred before I started keeping logs.
04:45:04 <dmwit> =/
04:45:24 <Axman6> @quote sorear
04:45:24 <lambdabot> sorear says: <sorear> Unfortunately, Coq *cannot* prove that your program will terminate before the heat-death of the universe. <psnively> Right. That's a software engineering problem, not a
04:45:25 <lambdabot> computer science problem. ;-)
04:45:37 <dmwit> Anybody with a mirror of the tunes logs want to grep for "maximal munch"? =)
04:45:58 <Axman6> @quote munch
04:45:58 <lambdabot> No quotes match. There are some things that I just don't know.
04:46:04 <Axman6> :(
04:48:37 <ksf> that haskell' is conservative is definitely a good thing.
04:49:06 <ksf> if you spec before you implement you're bound to come up with c++, that is.
04:50:41 <ksf> ChristianS, aucommand BufWrite? BufEnter?
04:50:48 <ksf> there's a gazillion of hooks.
04:51:34 <gregATio> does the value returned from a do block need to be the same type as returned by that function?
04:51:39 <ksf> nvm, I should actually read the discussion.
04:52:00 <ksf> a do block doesn't return anything
04:52:10 <ksf> ...its type is the type of the last statement.
04:52:11 <merijn> gregATio: The value on the last line should be the same type as the value produced by it's containing function
04:52:52 <Botje> @tell DxBlueIce glRotate and glTranslate affect the *camera*, so they are what you want.
04:52:52 <lambdabot> Consider it noted.
04:52:52 <merijn> If I have "foo :: IO String", then the last line of the do block should be ":: IO String"
04:52:59 <gregATio> thanks merijn
04:53:39 <merijn> Which, even though the function name seems to imply it, has nothing to do with the function "return"
04:57:58 <ksf> Botje, isn't that the old pipeline?
04:58:13 <ksf> (/me didn't use any modern gl version yet so he actually has no idea)
04:58:18 <Botje> yes
04:58:20 <Botje> and same here :)
05:00:05 <dmwit> aha, here we go
05:00:38 <dmwit> <sorear> for instance 'defaul x = 0; t = 2; main = Main.default' is valid Haskell [H98, I assume], but invalid GHC
05:01:14 <dmwit> from April 14, 2007, hence the H98 assumption there
05:02:17 <dmwit> geekosaur, srhb: Since you were discussing weird and unforseen compiler breakage. =)
05:02:28 <dmwit> s/unforseen/unforeseen/
05:03:25 <ksf> how can that be valid?
05:03:48 <ksf> unless someone defined Num a => IO a
05:04:08 <dmwit> Yes, it's a type error.
05:04:12 <dmwit> But not a parse error. =)
05:04:41 <ksf> ah, inconsequential technicalities. the best way to annoy any programmer.
05:05:21 <dmwit> The discussion immediately following this proclamation by sorear was *also* pointing out that "main = 0" was a crappy program. =P
05:06:15 <shachaf> Man, remember back when sorear was here?
05:06:16 <shachaf> Those were the days.
05:06:38 <dmwit> Yeah, it was a bit sad that he disappeared so abruptly.
05:07:10 <shachaf> Well, he's still on Freenode.
05:08:13 <dmwit> s/disappeared/disappeared from the Haskell world/
05:08:48 <shachaf> Yes.
05:10:19 <quicksilver> preflex: seen sorear
05:10:19 <preflex>  sorear was last seen on #perl6 7 hours, 25 minutes and 7 seconds ago, saying: not much better
05:18:23 <ksf> derive doesn't seem to support deriving binary for non-ground types.
05:24:06 <hpaste> srhb pasted ‚ÄúforM --> "Until empty"‚Äù at http://hpaste.org/65190
05:24:38 <srhb> This is part of some code using Data.Binary.Get, and it correctly gets three of those tuples for me, but how do I transform this to "while not empty.."?
05:27:57 <qnikst> srhb: do you want to load a list of tuples?
05:28:42 <srhb> I want to do the three <-..s in the above code for as long as they are actually more of those in the file.
05:29:20 <srhb> But my mindset is too imperative, so I choke on how to do it.. while (hasmorebytes...)
05:29:56 <quicksilver> if hasmore byte then <recurse> else <return complete data>
05:30:02 <quicksilver> does that help ^^ srhb
05:30:02 <qnikst> if I correctly understand you can use next aproach (https://gist.github.com/1924310)
05:30:38 <qnikst> I don't understand what type signature should be there
05:30:40 <srhb> quicksilver, qnikst: THanks, both do help. I was having trouble recursing with the Get monad, maybe I can figure it out.
05:31:37 <srhb> What I need to do is split the reading loop off from the header reading part of the code. That was my original issue. Hmm.
05:34:20 <qnikst> solution on gist do what you need just change getChunk to you function but it operates with lazy IO only
05:34:54 <srhb> Thanks. I will try to understand it.
05:38:20 <hpaste> quicksilver annotated ‚ÄúforM --> "Until empty"‚Äù with ‚ÄúforM --> "Until empty" (annotation)‚Äù at http://hpaste.org/65190#a65191
05:38:35 <quicksilver> srhb: ^^ annotation there, sorry got interrupted whilst writing it for you.
05:38:58 <quicksilver> that builds up the list backwards
05:39:11 <quicksilver> you may wish to replace 'return' with 'return . reverse'
05:39:28 <srhb> Oh, that's much closer to the approach I was trying to get working.
05:41:23 * DaveNull just discovered that n+k patterns have been removed
05:41:42 <dcoutts> DaveNull: {-# LANGUAGE NPlusKPatterns #-}
05:42:10 <dcoutts> they're there if you want them
05:42:24 <DaveNull> ok, thanks
05:43:44 <quicksilver> srhb: obviously you call it with "getAllData []"
05:44:03 <quicksilver> srhb: this pattern of replacing mutation/iteration with recursion/accumulating parameter is a common idiom.
05:44:16 <quicksilver> you could also write your own "whileM" combinator which does this for you
05:44:21 <quicksilver> and there is one somewhere on hacakge
05:44:31 <quicksilver> there are 3 or 4 slightly different ways you might write 'whileM' though.
05:44:38 <srhb> quicksilver: Yes, I've been able to apply the pattern outside monadic code, but I guess I choked on it now because of the do-notation
05:44:44 <quicksilver> :)
05:46:04 <quicksilver> of course (:)-accumulation is particularly natural/efficient
05:46:09 <quicksilver> due to the immutable tail-sharing of lists
05:46:20 <quicksilver> they are basically designed for this!
05:47:47 <hpaste> srhb annotated ‚ÄúforM --> "Until empty"‚Äù with ‚ÄúforM --> "Until empty" (annotation) (annotation)‚Äù at http://hpaste.org/65190#a65192
05:48:10 <srhb> This could probably be cleaned up a bit, but I think I'm doing the right thing, yes? Especially the loop function
05:53:02 <ChristianS> DaveNull: you you really need n+k patterns? they are no longer standard haskell (2010), and i could never figure out why somebody would want them...
05:54:05 <DaveNull> ChristianS, no, i don't "really" need them... But i remember using them back in my classes... Anyway, i'm reading the thread about the removal proposal
05:56:22 <quicksilver> yes that looks right srhb
05:56:27 <srhb> quicksilver: Thanks a ton!
06:02:34 <akosch_> when I try to select somewhat more than 4000 chars from a text field with HDBC / ODBC I get the error message "invalid descriptor index". Same works fine from python and php with the same datasource.
06:03:38 <akosch_> I guess it has to do something with truncating, but I'm not sure
06:04:44 <akosch_> has anyone here experience with this?
06:05:38 <srhb> What function are you using to get the chars?
06:06:47 <akosch_> srhb: fetchRow
06:07:23 <akosch_> srhb: I just found the following comment in the source code: TODO: This code does not deal well with data that is extremely large
06:07:45 <akosch_> I didn't know 4000 chars are extremely large... :(
06:07:56 <akosch_> but maybe it's another issue
06:09:53 <srhb> That must be another issue, I think. What's the statement?
06:10:22 <akosch_> srhb: http://hpaste.org/65193
06:10:42 <t7> re-installed the platform because snap broke it :3
06:10:57 <akosch_> srhb: this isn't actually my production code, but I could reproduce the issue with it
06:11:19 <akosch_> srhb: in production it happens with a text field
06:11:47 <srhb> Heh, okay, that might be the same issue I guess. Not that I could say, I have never needed to do what you're doing.
06:12:38 <akosch_> srhb: I wasn't aware of this limitation... maybe it should be advertised in the documentation
06:14:40 <akosch_> srhb: few thousand chars in a field shouldn't be that uncommon I guess :)
06:15:10 <srhb> akosch: I can't make it fail with sqlite3 at least.
06:15:49 <akosch_> srhb: sadly I'm using sql server with its native client
06:16:49 <srhb> akosch: And I'm guessing it's not a problem with the native interface to the sql server? Just with the Haskell ODBC bindings?
06:17:03 <BlankVerse> any script to convert a .hs into .lhs file?
06:17:13 <akosch_> srhb: yeah, I've tested both python and php with the same statement and same datasource
06:17:34 <srhb> akosch: What happens if you specify the driver explicitly in the connection string?
06:18:03 <akosch_> I can try... I'll get back to you in a minute
06:20:08 <srhb> It's probably the default anyway, but I'm just guessing here.
06:21:04 <akosch_> srhb: I get the same error
06:21:23 <akosch_> srhb: I also tried multiple versions (9 and 10) of the native client
06:21:40 <akosch_> srhb: I also traced the odbc calls made
06:22:00 <BlankVer1e> how to transform an hs file to lhs file?
06:22:05 <BlankVer1e> any support in ghc?
06:22:08 <srhb> akosch_: I think you're more on top of this than I am, by far, so I doubt I can give you any meaningful advice. Best of luck though.
06:22:31 <srhb> BlankVer1e: Prepend > to every line?
06:22:40 <DxBlueIce> hey, can anyone tell me how to use textures with hopengl? is there a good tutorial?
06:22:40 <roconnor> > foldl (flip const) undefined [0..]
06:22:40 <lambdabot> DxBlueIce: You have 1 new message. '/msg lambdabot @messages' to read it.
06:22:44 <lambdabot>   mueval-core: Time limit exceeded
06:22:47 <t7> bit offtopic; does anyone know how to set up an easy cluster so i can build stuff in parallel? is there an out of the box type solution
06:22:51 <t7> (gcc)
06:23:20 <akosch_> srhb: thanks for trying though :)
06:30:47 <mrcarrot> t7: distcc?
06:32:33 <akosch_> srhb: you might be interested in my "solution"
06:32:47 <srhb> akosch_: Do tell
06:33:26 <akosch_> srhb: in hdbc-odbc / Statement.hsc there is a colBufSizeDefault and colBufSizeMaximum defined
06:33:49 <akosch_> srhb: defaults were 1024 and 4096
06:33:49 * hackagebot memoize 0.3 - A memoization library  http://hackage.haskell.org/package/memoize-0.3 (JesseTov)
06:34:23 <akosch_> srhb: I just increased both to 8192, deployed again and it seems to work
06:34:50 <srhb> akosch_: Seems like you definitely need to throw a bug report then.
06:35:12 <akosch_> srhb: yeah, I will get to that :)
06:35:30 <akosch_> srhb: but for now it's an acceptable workaround
06:35:42 <srhb> akosch_: Indeed, and it appears you were right about that TODO-line.
06:35:52 <akosch_> srhb: thanks again for listening to my problems :)
06:35:53 <srhb> akosch_: Although it should probably have carried a way larger warning sign.
06:36:07 <akosch_> srhb: yes, not burried in the source code
06:36:35 <srhb> akosch_: Is this it? https://github.com/hdbc/hdbc-odbc/issues/4
06:36:42 <srhb> Ah no, not quite.
06:36:46 <srhb> But probably related.
06:36:59 <akosch_> srhb: yes, I think it's related
06:37:29 <akosch_> srhb: thanks again! have a nice day
06:37:44 <mrcarrot> the wonder of opensource :)
06:48:49 * hackagebot CV 0.3.5.1 - OpenCV based machine vision library  http://hackage.haskell.org/package/CV-0.3.5.1 (VilleTirronen)
06:53:51 <roconnor> @src liftM2
06:53:51 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:54:45 <mrcarrot> it would be great to get lamdabot integrated into vim :)
06:55:41 <quicksilver> it wouldn't be great if you just want @src
06:56:05 <quicksilver> that would be a terrible idea since @src is limited and also not always correct
06:56:12 <quicksilver> you're better off with real sources of source.
06:57:05 <Y_Less> Ok, I've found loads of documentation on using the FFI - I can call Haskell code from C, and can call C code from FFI, but in both instances the callee must be a dll loaded from the caller. How would I write a C application which can provide functions for Haskell to call, and also act as the entry point loading and launching a Haskell "script"? I.e. how would I link a C program that I can
06:57:05 <Y_Less> launch, with additional "native" functions defined, and from that program load a compiled Haskell program which can use the exported functions in the original app? Almost all the documentation assumes that Haskell will be the entry point and C just additional libraries.
06:59:15 <merijn> Y_Less: The haskell runtime is fairly elaborate, so I'm not sure how well it would play with a C entry point (I don't have enough experience to say). Why do you need a C entry point to begin with?
06:59:55 <quicksilver> it's fine
07:00:00 <quicksilver> you just need to call a couple of functions to set it up
07:00:09 <quicksilver> there shuold be some docs on it somewhere
07:00:25 <quicksilver> http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
07:00:43 <Y_Less> For interoperability with existing systems. Anyway, it's not even the entry point that's the problem - I can do that, it's just I'm not sure how to let Haskll call back to the original C code, rather than loading new DLLs with the functions
07:01:15 <quicksilver> export a C function which knows how to call a C function
07:01:34 <quicksilver> and pass C functions around as function pointers (opaque from haskell)
07:01:38 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#using-own-main
07:02:23 <TheLemonMan> is Control.Monad.Trans a standard package ?
07:02:58 <Y_Less> quicksilver: Interesting, I'll look in to that methods, hadn't considered it that way around
07:03:47 <geekosaur> yes and no.  it's not a bootlib any more but should be in "mtl"
07:04:21 <quicksilver> Y_Less: well, you can only ffi export functions with known names and types
07:04:31 <hpaste> osager pasted ‚Äúproblem with handle‚Äù at http://hpaste.org/65194
07:04:38 <quicksilver> Y_Less: so that means they have to be decided in advance - when the haskell is compiled.
07:04:48 <quicksilver> Y_Less: however by the magic of abstraction, you can call anything.
07:04:59 <t7>         Something is amiss; requested module  template-haskell-2.6.0.0:Language.Haskell.TH differs from name found in the interface file template-haskell:Language.Haskell.TH
07:05:01 <t7> :(
07:05:48 <Y_Less> That's not an issue, I have header files with the functions in
07:06:03 <quicksilver> well then FFI export them
07:06:50 <geekosaur> osager:  see http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/Control-Exception.html
07:07:25 <geekosaur> osager: you could use old-exceptions from Hackage or rewrite your code to modern extensible exceptions, which requires some extra type information
07:08:01 <osager> thank you, i saw that code from a blog
07:08:08 <geekosaur> t7: you have multiple versions of template-haskell?  (that's what that kind of error usually means... ands multiple versions of template haskell is BAD because the only one that will work is the one that came with your ghc)
07:08:21 <osager> any hints how i can change to a modern version ?
07:09:06 <geekosaur> osager, yeh, it's a bit out of date.  see the URL I sent earlier, scan forward to "Catching all exceptions"
07:09:28 <t7> geekosaur: not on purpose :|
07:09:57 <t7> i did pacman -Syu haskell cabal-install & cabal install snap
07:10:00 <geekosaur> trying to install some packages could cause cabal to do it, because it's still not smart enough to say "wait, thats a bootlib, FAIL"
07:10:08 <osager> thank you
07:11:08 <roconnor> @type either Right Left
07:11:11 <lambdabot> forall a a1. Either a a1 -> Either a1 a
07:11:12 <geekosaur> and if the Arch repo's version of snap hasn;t been updated to match the ghc yet (I believe arch is in the middle of transition to 7.4.1 right now) you could get weirdness
07:11:28 <t7> i got snap from cabal
07:12:53 <geekosaur> hm, right.  if snap wasn't updated for 7.4.1 yet, cabal could be trying to install template-haskell for whatever compiler version it does support (probably 7.0.4 or 7.2.1) and *boom*
07:13:21 <geekosaur> cabal really doesn't handle that situation at all sanely at the moment :/
07:13:31 <t7> the platform has dissapeared from arch :|
07:13:34 <Y_Less> OK, I don't think I've explained my problem very clearly. I know how to write a Haskell dll that a C application can launch, and I know how to write a C DLL that a Haskell application (or DLL) can launch. In the latter case I use "-optl-lWhatever" on the GHC command line to link a dll providing the functions to the Haskell code (which is then loaded automatically with the Haskell code), and
07:13:35 <Y_Less> have the relevant "foreign import ccall <include.h func> ..." included on the Haskell side. If I wanted the original C application to provide those exported functions, rather than the additional DLLs, would I simply keep the include.h reference and drop the "-optl-l" parameter from the command line, forcing the Haskell DLL to search for the functions elsewhere and find them in the main
07:13:36 <Y_Less> executable?
07:13:36 <t7> excuse my spelling
07:13:50 * hackagebot cabal2nix 1.28 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.28 (PeterSimons)
07:15:18 <td123> it's a good thing it was dropped because it was a mess
07:15:36 <geekosaur> t7: yes, 7.4.1 isn't quite 100% with the platform, the platform is still on 7.0.4
07:15:49 <td123> + latest ghc is not compatible with the latest haskell-platform
07:16:03 <t7> i dont think arch packages the platform anymore
07:16:07 <geekosaur> and trying to make it work just causes more problems (I've shoehorned it onto [an older] HEAD, it was ... cranky)
07:16:26 <geekosaur> exactly.  arch moved to ghc 7.4.1 which is not compatible with the platform
07:16:35 <geekosaur> which is what we just old you...
07:16:39 <geekosaur> told
07:16:58 <ChristianS> TheLemonMan: Control.Monad.Trans is part of the mtl package, which is pretty popular but not "standard" as in "comes with ghc", i think
07:17:14 <t7> how do i install the platform hten
07:17:16 <t7> from source?
07:17:32 <geekosaur> [12 14:17] <geekosaur> and trying to make it work just causes more problems (I've shoehorned it onto [an older] HEAD, it was ... cranky)
07:17:33 <TheLemonMan> ChristianS: just figured that, was thinking that my ghc install was borked
07:17:35 <geekosaur> meaning:  you don't
07:17:39 <ChristianS> TheLemonMan: in hackage, you can always click on the "Contents" link to find out which package a module belongs to.
07:17:50 <td123> t7: get the pkgs you need using cabal-install
07:18:12 <t7> td123: i tried but it wont install snap
07:18:24 <geekosaur> the platform /per se/ won';t work with ghc 7.4.1, which is why arch dropped it.  individual packages which are usually part of the platform may or may not have been ported, but no promises on it all working together...
07:18:53 <t7> holy crap windows was easier than this
07:18:56 <geekosaur> and as I said earlier snap appears to not be working on 7.4.1, as it tried to install and use a template-haskell that is not compatible with ghc 7.4.1
07:19:13 <geekosaur> frankly, I;ve thought this move by arch was stupid... this is *exactly* why
07:19:48 <geekosaur> they have given you a compiler that simply will not work with current versions of snap, or many other packages which are currently targeting the platform and not the bleeding edge
07:20:31 <td123> geekosaur: it's what most people said they wanted when asked
07:20:36 <t7> i started using arch back in the day because it was supposed to have great haskell support :)
07:20:38 <quicksilver> t7: ghc 7.4 is just not ready for general use.
07:21:03 <quicksilver> that is, it's not ready for people who want to use it with libraries (most libraries)
07:21:17 <quicksilver> after a GHC release there is a period of time during which library maintainers update their code
07:21:18 <srhb> t7: Well, it was a very bad move by arch. Now you need to get a generic binary ghc 7.0.4 and build your own haskell platform, really.
07:21:28 <quicksilver> after that period is the right time to upgrade.
07:21:29 <geekosaur> td123, the majority is not always right.  they shot themselves in the foot, big time
07:22:10 <geekosaur> they have a shiny new bleeding edge compiler that doesn't build many things
07:22:20 <roconnor> @type either (Left . Left) (either (Right . Left) Right)
07:22:20 <lambdabot> forall a b a1 b1. Either a (Either a1 (Either a1 b1)) -> Either (Either a b) (Either a1 b1)
07:22:36 <td123> geekosaur: hmm, what else doesn't work?
07:22:56 <geekosaur> anything that targets the platform and not the bleeding edge
07:23:06 <roconnor> @type either (Left . Left) (either (Left . Right) Right)
07:23:07 <lambdabot> forall b a a1. Either a1 (Either a b) -> Either (Either a1 a) b
07:23:13 <geekosaur> which is most stuff because most developers are trying to get work done, not chase rainbows
07:23:29 <td123> geekosaur: i get that, but what else targets the platform? just curious
07:24:09 <geekosaur> you can prbably coerce that information out of hackage somehow; I am not the walking hackage index, sorry
07:24:31 <roconnor> @free costrength :: f (Either a b) -> Either a (f b)
07:24:32 <lambdabot> Extra stuff at end of line
07:24:43 <roconnor> @free costrength :: F (Either a b) -> Either a (F b)
07:24:44 <lambdabot> $map_Either f ($map_F g) . costrength = costrength . $map_F ($map_Either f g)
07:25:25 <quicksilver> td123: almost everything, basically.
07:25:27 <td123> geekosaur: would providing the latest ghc compiler in the haskell-platform be smarter (but not actually providing the platform)?
07:25:32 <geekosaur> but my experience is the stuff that has been ported to 7.4.1 is the stuff that specifically wants/needs the enhancements in 7.4.1.  so I think yesod has been ported because it benefits from 7.4.1, but snap hasn't
07:25:44 <geekosaur> ...what?
07:25:49 <t7> what abotu happstack?
07:26:03 <t7> i guess that needs TH
07:26:17 <geekosaur> (also, may I please note I'm just playingthe messenger, I have zero involvement with any of this except as a user)
07:26:23 <t7> i wanted to use snap because i thought it _didnt_ use the TH stuff that yesod does
07:27:43 <geekosaur> (and as someone who thinks arch made a phenomenally stupid decision, users or no)
07:28:07 <td123> heh fair enough, but I'm asking how would you recommend fixing the problem :P
07:28:09 <geekosaur> in any case, 7.2 was experimental, 7.4 is too new for the platform to have revved to catch up yet
07:28:23 <geekosaur> if that was not clear yet...
07:28:49 <geekosaur> the platform is the official supported set of haskell compiler and libraries (that is *and*; the compiler is *part* of the platform)
07:29:19 <geekosaur> get a platform installer, if arch doesn't feel like shipping a usable platform
07:29:50 <t7> geekosaur: the link to the arch platform installer on the platform site 404s now
07:29:59 <lukish> How can I pattern match start of the string (not a single char)?
07:30:00 <lukish> processInputMessage text@("/me":_)
07:30:03 <lukish> Like that
07:30:20 <lukish> But it's obliously not works
07:30:31 <geekosaur> t7, I was thinking a generic linux one.  the arhc-specific one would point to the arch repository that they have explicitly removed and desupported
07:30:33 <t7> '/':'m':'e':_
07:30:47 <geekosaur> lukish, you can't
07:31:29 <geekosaur> not as a string at least; the string includes a terminal [] which is not valid in the middle of a list pattern.  see what t7 just sent
07:31:58 <geekosaur> (strings are not magic syntax, theyre just lists.  complete lists, including the trailing [])
07:32:10 <geekosaur> (well, they can be "magic syntax" but not usefully for this)
07:32:20 <lukish> But is there any isPrefix function?
07:32:25 <lukish> Ot startWith
07:32:25 <quicksilver> given that /':'m':'e':_ looks quite ugly, I nromally use "isPrefixOf" and a guard
07:32:40 <lukish> :t isPrefixOf
07:32:40 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
07:32:44 <lukish> Nice
07:32:45 <lukish> Thanks
07:33:01 <rwbarton> If you weren't misled by what you were trying to do, you'd see that ("/me":_) is obviously a pattern which matches a list whose first element is "/me". :)
07:33:25 <quicksilver> there is a function in some library called 'stripPrefix" which, together with pattern guards, lets you convenient match and strip the prefix and get the rest
07:33:34 <rwbarton> Or maybe this isn't so much a case of "why doesn't this work" but "how do I do this"...
07:33:51 <quicksilver> oh it's actually in Data.List now
07:33:56 <quicksilver> @hoogle stripPrefix
07:33:57 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
07:33:57 <lambdabot> Data.Text stripPrefix :: Text -> Text -> Maybe Text
07:33:57 <lambdabot> Data.Text.Lazy stripPrefix :: Text -> Text -> Maybe Text
07:34:15 <quicksilver> > stripPrefix "/me" "/me dances"
07:34:16 <lambdabot>   Just " dances"
07:34:21 <quicksilver> > stripPrefix "/me" "/you dances"
07:34:22 <lambdabot>   Nothing
07:34:49 <quicksilver> so you can write processInputMessage | Just rest <- stripPrefix "/me " = ....
07:34:55 <quicksilver> if you're happy with patternguards.
07:34:55 <merijn> quicksilver: Should've used "/me dance" so it'd say 'Just "dance"' </pop culture reference>
07:35:10 <quicksilver> :P
07:36:01 <quicksilver> > stripPrefix "Rais" "Raisin Timberlake"
07:36:02 <lambdabot>   Just "in Timberlake"
07:36:15 <quicksilver> </bad joke for merijn>
07:36:32 <merijn> Man, there must be ton of those...
07:36:44 <merijn> Now my productivity for the rest of the day is ruined as I try to come up with them
07:36:58 <quicksilver> > stripPrefix "Tint" "Tintin's House"
07:36:58 <lambdabot>   Just "in's House"
07:37:07 <quicksilver> that one is strictly for people with UK preschool children
07:37:13 <quicksilver> which, I suspect, isn't many in this channel.
07:38:34 <zhulikas> quicksilver> > stripPrefix "/me" "/you dances"
07:38:34 <zhulikas> <lambdabot>   Nothing
07:38:36 <zhulikas> that's kinda sad :D
07:38:38 <TheLemonMan> when im into a do block i'm into the IO monad, right ?
07:38:45 <zhulikas> no
07:38:51 <zhulikas> not necesarily in IO
07:38:54 <merijn> TheLemonMan: No, you're in a monad, not necessarily the IO one
07:39:08 <merijn> Could just as easily be Maybe, list or any other monad
07:39:32 <parcs`> @quote me
07:39:32 <lambdabot> me says: trololololo
07:39:32 <zhulikas> how to write it with a list :?
07:39:37 <TheLemonMan> silly question but how do i know ?
07:39:41 <parcs`> @quote /me
07:39:42 * lambdabot says: trololololo
07:39:57 <zhulikas> TheLemonMan, by function type definition
07:40:02 <zhulikas> and lots of compiler errors
07:40:02 <zhulikas> :D
07:40:39 <Saizan> TheLemonMan: it depends on the type of the overall expression
07:40:47 <TheLemonMan> hrm, so if i have IO (Maybe String) i'm into the maybe monad ?
07:40:54 <Saizan> no, IO
07:40:55 <zhulikas> :o
07:41:36 <zhulikas> @hoogle m a -> a
07:41:36 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
07:41:36 <lambdabot> Data.Monoid getDual :: Dual a -> a
07:41:37 <lambdabot> Control.Parallel.Strategies runEval :: Eval a -> a
07:41:42 <zhulikas> uhm, yeah
07:41:48 <zhulikas> I just wondered
07:41:55 <zhulikas> IO (Maybe String)
07:42:06 <TheLemonMan> so, if i have a do block into it and i do a return $ Just <val> isnt the return unneeded as the do block returns an IO action ?
07:42:10 <zhulikas> to get String value, I need to call <- in do two times?
07:42:42 <zhulikas> a <- s; b <- a;
07:42:45 <rwbarton> TheLemonMan: the return is needed as the do block returns an IO action
07:42:57 <geekosaur> no because those are different monads
07:43:06 <zhulikas> @hoogle liftIO
07:43:07 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
07:43:07 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
07:43:07 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
07:43:20 <zhulikas> ah, MonadIO
07:43:24 <rwbarton> the last line (I assume you are talking about) needs to be an IO action like the rest
07:45:56 <TheLemonMan> right, i didnt take into account that the last line needs to be an IO action too
07:46:56 <geekosaur> the ugly way is:  do Just s <- whatever -- don't do this, if it's Nothing it'll raise an exception
07:48:10 <geekosaur> the proper way you would fmap a use of (maybe) over it, or if you need to handle the Nothing case differently then you have no option but to use <- to get the Maybe String and then a case expression on that value
07:49:24 <lukish> How can I drop "abc" from "abcde" and get "ge"?
07:49:48 <geekosaur> a string is just afunny looking list
07:49:52 <geekosaur> > drop 3 "abcde"
07:49:53 <lambdabot>   "de"
07:50:24 <Clint> it's harder to get "ge"
07:50:31 <zhulikas> :))))
07:50:33 <zhulikas> true.
07:50:41 <geekosaur> I chose to ignore that...
07:50:52 <rostayob> > const "ge" "abcde"
07:50:53 <lambdabot>   "ge"
07:51:00 <zhulikas> haha
07:51:01 <zhulikas> cheater
07:51:14 <zhulikas> const is a shortcut to get whatever from anywhere
07:51:14 <lukish> Well, const looks nice
07:51:21 <lukish> It's actually what I nedd
07:51:23 <lukish> Thanks
07:51:28 <zhulikas> you are welcome:)
07:51:48 <zhulikas> @hoogle a -> b -> a
07:51:48 * geekosaur ...
07:51:48 <lambdabot> Prelude const :: a -> b -> a
07:51:49 <lambdabot> Data.Function const :: a -> b -> a
07:51:49 <lambdabot> Prelude seq :: a -> b -> b
07:51:54 * Clint claps.
07:53:21 * geekosaur then wonders what the `drop "abc"' was supposed to be about
07:54:43 <zhulikas> > (\a -> "ge") "abc"
07:54:44 <lambdabot>   "ge"
07:54:47 <zhulikas> works fine to me
08:07:34 <t7> > "ge" "abc"
08:07:35 <lambdabot>   Couldn't match expected type `t1 -> t'
08:07:35 <lambdabot>         against inferred type `[GHC....
08:08:03 <rostayob> t7: heuy
08:08:06 <rostayob> I've got something for you
08:08:19 <rostayob> t7: https://github.com/rostayob/ML-W , parser and type inference using W
08:08:22 <t7> :o
08:09:17 <t7> rostayob: this one doesnt use type constructors?
08:09:23 <rostayob> t7: no
08:10:05 <t7> cheers for that, il check it out when i get home
08:10:39 <rostayob> t7: no problem I wanted to have a minimal example anyways
08:10:48 <rostayob> I'll probably write a step evaluator as well
08:11:04 <rostayob> and I'll comment it better, they might make a little coursework based on this
08:11:53 <Na-Fiann> Hi, I came across the following the other day, and I have no idea why it does what it does: "aaa" >> "bcd" -- output: "bcdbcdbcd"
08:12:09 <rostayob> Na-Fiann: do you know how the list monad works?
08:12:13 <t7> Na-Fiann: it looks like a map
08:12:28 <srhb> It is a map.
08:12:45 <rostayob> @src >>= []
08:12:45 <lambdabot> Source not found. :(
08:12:48 <Na-Fiann> rostayob, not really no
08:12:52 <rostayob> @src (>>=) []
08:12:52 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:12:58 <rostayob> @src [] (>>=)
08:12:58 <lambdabot> xs >>= f     = concatMap f xs
08:13:03 <rostayob> Na-Fiann: ^^^
08:13:13 <rostayob> @src [] (>>)
08:13:14 <lambdabot> xs >> ys      = concatMap (const ys) xs
08:13:44 <srhb> If you know list comprehensions, perhaps that syntax will be more understandable: [a | b <- "aaa", a <- "bcd"]
08:14:02 <rostayob> srhb: yeah but that doesn't really explain why >> does that :P
08:14:07 <srhb> That is true.
08:15:05 <srhb> It helped me a lot in understanding the list monad to rewrite comprehensions to do-notation and then entirely unsugared, though.
08:15:14 <srhb> desugared*
08:15:32 <Na-Fiann> ahh thanks =) it's really weird when you first see it though
08:17:11 <lukish> Say I have typeclass data M = M A B C. How can A be called here?
08:17:22 <lukish> value?
08:17:43 <rwbarton> field
08:17:51 <rwbarton> also, s/typeclass//
08:18:02 <rwbarton> or s/typeclass/type/
08:18:07 <lukish> Ok
08:18:21 <lukish> Forget FIELD word, thanks.
08:37:08 <uniquenick> I'm trying to make my application use modules, but I am not sure what I need to do in my .cabal
08:37:40 <t7> @hoogle String -> ByteString
08:37:41 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
08:37:41 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
08:37:41 <lambdabot> Data.String fromString :: IsString a => String -> a
08:37:56 <uniquenick> I'd like src/ModuleA/Submodule.hs kind of setup, do I need to put dependencies on those modules in my .cabal?
08:38:20 <Saizan> uniquenick: you need hs-source-dirs: src
08:38:35 <uniquenick> ok, that's already there
08:38:41 <Saizan> uniquenick: and also put ModuleA.Submodule into other-modules:
08:39:07 <Tesseraction> what does _|_ mean on this page? http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-ST.html
08:39:09 <Saizan> (or in exposed-modules: if this is a lib and you want the user to be able to import it)
08:39:57 <pqmodn> Tesseraction: it's pronounced "bottom", a computation that doesn't produce a value (eg it doesn't terminate)
08:40:10 <Tesseraction> oh it's the bottom symbol?
08:40:14 <pqmodn> yep
08:40:19 <imc> an approximation :P
08:40:25 <uniquenick> so list out all of the submodules, but not ModuleA itself?
08:40:51 <Tesseraction> haha, yeah, I didn't recognise it as bottom but then it's not like keyboards have that symbol readily typable
08:41:42 <anatoly-hs> hi! Does anybody knows  how to fix this error message I get when trying to install yi package
08:41:44 <anatoly-hs> Resolving dependencies... cabal.EXE: cannot configure unix-2.5.1.0. It requires bytestring >=0.9.2.0 && <0.10 For the dependency on bytestring >=0.9.2.0 && <0.10 there are these packages: bytestring-0.9.2.0 and bytestring-0.9.2.1. However none of them are available bytestring-0.9.2.0 was excluded because process-1.0.1.5 requires bytestring ==0.9.1.10 bytestring-0.9.2.0 was excluded because hpc-0.5.0.6 requires bytestring ==0.9.1
08:41:51 <anatoly-hs> thanks
08:42:37 <anatoly-hs> OS: windows 7 64 bit, HP: 2011.4.0.0
08:43:51 <Tesseraction> you could probably try the inelegant method of installing bytestring 0.9.1 then hpc then installing bytestring 0.9.1.10
08:44:08 <Tesseraction> then process, then 0.9.2.0
08:44:32 <rostayob> anatoly-hs: I'm don't think that's your problem, but unix is not supported under windows
08:46:44 <anatoly-hs> rostayob: it's strange but for some reasons cabal trying to install it, actually, i dont undestand why this happens
08:46:54 <Tesseraction> what are you trying to install?
08:47:16 <anatoly-hs> yi
08:47:35 <anatoly-hs> http://hackage.haskell.org/package/yi
08:54:15 <Saizan> anatoly-hs: what does System.Info.os prints in ghci?
08:55:14 <anatoly-hs> Saizan:"mingw32"
08:57:18 <Saizan> anatoly-hs: unix-compat's .cabal file checks for os(windows) when deciding whether to depend on unix or not
08:57:25 <Saizan> anatoly-hs: so that's the problem
08:58:08 <uniquenick> can I export submodules from a module?  so that I can import Foo and then access Foo.Sub.func as just Sub.func?
08:58:42 <rwbarton> no
08:58:49 <rwbarton> there is no relation between Foo and Foo.Sub
08:59:04 <Saizan> you can export Foo.Sub from Foo
08:59:09 <rwbarton> (you can export modules from a module though, but that just means exporting all the names)
08:59:39 <Saizan> anatoly-hs: try "cabal install -fportable unix-compat yi"
09:00:32 <anatoly-hs> Saizan: cabal: dependencies conflict: ghc-7.0.4 requires bytestring ==0.9.2.1 however bytestring-0.9.2.1 was excluded because yi-0.6.4.0 requires bytestring ==0.9.1.*
09:00:42 <uniquenick> so, exporting Foo.Sub from Foo meaning export all the function in it, so import Foo would let me access Foo.Sub.func as just func?
09:01:09 <quicksilver> yes
09:01:16 <Saizan> anatoly-hs: seems like this version of yi is not meant to built with your version of ghc
09:01:24 <quicksilver> you can't re-export qualified, but you can re-export
09:01:34 <quicksilver> being able to re-export qualified might be handy
09:02:46 <Saizan> anatoly-hs: i guess you're building with -fghcAPI ??
09:02:54 <Saizan> s/??/?/
09:03:43 <anatoly-hs> Saizan: nope
09:04:57 <anatoly-hs> cabal install -fghcAPI -fportable unix-compat yi
09:05:02 <anatoly-hs> gives the same result
09:07:05 <Saizan> anatoly-hs: no, -fghcAPI would only make it worse, i now see that they depend on the ghc package anyway trough hint
09:07:55 <Saizan> anatoly-hs: anyway if you want to build yi on your version of ghc you'll have to hack the .cabal file hoping relaxing the version ranges for e.g. bytestring doesn't cause build failures
09:08:15 <Saizan> anatoly-hs: you could also try the darcs version, maybe that's updated
09:09:52 <anatoly-hs> Saizan: will try it later. thanks for help!
09:12:07 <Saizan> anatoly-hs: np
09:19:05 <cizra> Hi. I have a text file which is partly UTF-8 and partly broken. How could I read it into a String, discarding any broken junk? Right now I get an exception. If I handle the exception, my file pointer still stays on the bad line and I don't know how to push it over the bad part.
09:19:51 <dskippy1> I am getting "ExitFailure 1" from trying to "cabal install gd" on my machine (Ubuntu) and I tried a windows machine and got the same error. Google reveals a bug report on this issue. Is this just broken?
09:21:18 <Saizan> dskippy1: there should be a more informative error message earlier
09:21:25 <dskippy1> Sadly the bug report says it's fixed but it's still broken for me. I downloaded the most recent version of Haskell Platform just now.
09:21:41 <yitz> cizra: read it as a bytestring to begin with
09:21:53 <leoncamel> about conduit, how can I runResourceT on *multiple* file sources? I want merge several files into one.
09:22:13 <cizra> yitz: Thanks for the hint!
09:22:15 <dskippy1> Saizan: I am missing some C libraries apparently
09:22:25 <dskippy1> gd,png,z,jpeg...
09:23:18 <yitz> cizra: the text package then has a utf-8 decoder that throws an exception when something goes wrong. in this case, though, you may want to write your own utf-8 decoder. it's not that complicated.
09:23:58 <Saizan> cizra: utf8-string has a decoder which will insert a replacement char in the text rather than throw an exception
09:24:13 <cizra> Thanks! Sounds useful.
09:24:29 <yitz> cizra, Saizan: yeah, text has that option too, if it helps.
09:24:51 <Saizan> dskippy1: right, you've to install those yourself
09:25:20 <Saizan> dskippy1: in linux you'd do that through your distro's package manager
09:25:33 <dskippy1> Saizan: Got it. Thanks. Now I just need to figure out how to do that on Windows. :) I know on Linux but sadly I went to my Windows machine to try to see if it works here.
09:25:44 <dskippy1> I am googling for it right now.
09:26:45 <yitz> leoncamel: there is a combinator to concatenate sources. i don't know much about conduit though.
09:28:21 <yitz> leoncamel: try #yesod, or http://www.yesodweb.com/page/community
09:29:55 <kallisti> leoncamel: believe it's =$=
09:31:59 <t7> does anyone else still write code in an 80x25 window?
09:32:06 <ben> 80x24
09:32:15 <ben> Sometimes I make it taller, when I get tired of it.
09:32:18 <t7> tmux?
09:32:18 <ben> But never wider.
09:32:27 <kallisti> I don't write code in a particular window size.
09:32:39 <t7> i really need to install a window manager soon
09:32:42 <ben> Just a lot of random floating xterms
09:32:47 <kallisti> heh
09:32:58 * kallisti runs xmonad. emacs usually covers about half the screen.
09:33:15 <ben> On a laptop, so I just use my thumb to move the mouse pointer over wherever I want to type, without leaving the homerow~
09:33:22 <kallisti> I don't remember what my display resolution is. I'm a bad person.
09:33:28 <t7> im not sure how well it will run in Hyper-V over ethernet ...
09:34:16 <ben> kallisti: Apparently it's "two emacs windows"
09:34:24 <kallisti> indeed
09:34:28 <kallisti> hm, so all non-closed operations must be non-associative right?
09:34:42 <kallisti> or well, not just closed
09:34:58 <kallisti> the domain and codomain must be pairwise disjoint as well, I think?
09:35:06 <kallisti> or something lik that.
09:36:00 <kallisti> in Haskell in particular, if an operation isn't closed then it can't be associative
09:36:05 <kallisti> (==) for example.
09:36:47 <rwbarton> it's more that it doesn't make sense to ask whether it is associative
09:37:01 <kallisti> ...because it's not closed. :P
09:37:06 <t7> i have cabal installed snap and snap-core from git and they work fine, but when i cabal configure snap-auth it says i dont have snap > 0.5
09:37:14 <t7> wrong channel
09:37:21 <rwbarton> would you say that the string "hello" is "not even"
09:38:12 <quicksilver> I think you can perfectly well ask for not-everywhere-defined operations to be associative.
09:38:33 <quicksilver> (a # b) # c = a # (b # c) -- wherever both sides are defined
09:38:35 <kallisti> rwbarton: if you're talking about numeric parity, I would say, yes, it's not even. In the same way that negative numbers are not prime.
09:38:48 <kallisti> because they're not in the set in question.
09:38:59 <rwbarton> it would be better to say that the proposition '"hello" is even' is ill-formed
09:39:03 <rwbarton> this is why we have type systems :)
09:39:05 <kallisti> sure.
09:39:15 <HansLander> as salamu aleikum rahmatullahi barakatu
09:39:27 <kallisti> quicksilver: hmmm, I see.
09:39:40 <quicksilver> normally though it's sets which are closed (under operators) rather than operators which are closed, no?
09:39:52 <rwbarton> ah
09:39:53 <kallisti> that's not true associativity though, is it? Under that subset of the domain/codomain
09:39:57 <kallisti> it is
09:39:58 <rwbarton> I knew something was wrong with the terminology
09:39:59 <kallisti> but otherwise it's not.
09:40:07 <kallisti> quicksilver: yes.
09:40:34 <kallisti> hm, okay.
09:41:35 <quicksilver> > ((True == False) == False) == (True == (False == False))
09:41:36 <lambdabot>   True
09:41:46 <kallisti> still the domain and codomain must intersect in order to be associative, even if it's a proper subset of the type (a partial function)
09:42:05 <idnar> what is this "Safe Haskell" thing that appears on Hackage pages?
09:42:13 <quicksilver> xor is associative :)
09:42:26 <kallisti> :t xor
09:42:27 <lambdabot> forall a. (Bits a) => a -> a -> a
09:42:41 <kallisti> quicksilver: is that.. supposed to be surprising? I don't understand.
09:42:52 <rwbarton> and (a == b) is not (a xor b)
09:43:02 <exFalso1> associativity =/= transitivity
09:43:06 <rwbarton> so ((a == b) == c) is a xor b xor c which is associative
09:43:30 <rwbarton> of course, you clearly weren't talking about (==) :: Bool -> Bool -> Bool :)
09:43:42 <kallisti> rwbarton: not at all. ;)
09:44:52 <kallisti> what's a counterexample though
09:45:13 <kallisti> hmmm, I guess any curried function actually.
09:45:16 <quicksilver> well my point is that Bool is the only place the ternary form is type-correct
09:45:17 <kallisti> ...um
09:45:25 <quicksilver> that's why I showed the Bool case
09:45:26 <rwbarton> counterexample to what?
09:45:39 <kallisti> hold on.
09:46:02 <kallisti> I'm trying to formulate a rule you can make about it's impossible for an operation to be associative.
09:46:06 <kallisti> +when
09:46:10 <rwbarton> you're thinking about this backwards
09:46:26 <rwbarton> in order to even use the word "associative" you need a function of type a -> a -> a for some a
09:46:42 <kallisti> yes.
09:46:44 <rwbarton> if f doesn't have such a type, then I guess you want to say it's not associative
09:46:54 <rwbarton> but that's not even a logical implication--it's just a syntactic implication
09:46:55 <kallisti> can't be.
09:47:13 <kallisti> syntactic?
09:47:15 <rwbarton> (I don't really mean to make that last statement formal but you probably could)
09:47:27 <rwbarton> I mean, it is not like a theorem
09:47:36 <kallisti> associativity is a syntactic?
09:47:43 <kallisti> -a
09:47:45 <rwbarton> it's just... you are not even allowed to talk about whether or not it is associative
09:48:38 <rwbarton> assuming you are either working in an informal context, or in a nice typed formal system
09:48:42 <exFalso1> you -are-, everything is trivially associative which doesnt have the type a -> a -> a
09:48:56 <exFalso1> see ex falso quodlibet :D
09:49:09 <rwbarton> if you are trying to do everything in ZFC set theory then you will have problems like this
09:49:23 <rwbarton> and as exFalso1 points out you can get whatever answer you like by fiddling with your definitions
09:50:05 <kallisti> intuitively speaking, it would make the most sense to say that those operations are non-associativity.
09:50:12 <kallisti> or that it's undefined for those operations/
09:50:24 <srhb> Undefined, yes.
09:50:37 <srhb> Much like the taste of radio waves.
09:50:39 <rwbarton> undefined -- but not like "undefined" as the Haskell value, undefined as in a type error :)
09:50:43 <exFalso1> associativity is a logical property which starts with "given a function of type a -> a -> a"
09:51:05 <exFalso1> it is well defined for functions which dont have this type
09:51:16 <Lajla> ex phallo, semen libet
09:51:27 <srhb> Lajla: Ew.
09:51:27 <exFalso1> ...
09:51:51 * kallisti is associative, by the definition of associativity given by exFalso1.
09:52:03 <exFalso1> yep
09:52:15 <exFalso1> even your face
09:52:27 <pqmodn> perhaps i'm missing something, but (>>=) is associative and doesn't have the type a -> a -> a, right?
09:52:34 <Lajla> ex phallo, semen in faciem libet?
09:52:36 <srhb> pqmodn: Wrong.
09:52:36 <exFalso1> it is only -not- associative if it has that type and doesnt satisfy the equality
09:52:43 <kallisti> pqmodn: it's right associative
09:52:46 <rwbarton> pqmodn: yes
09:52:49 <kallisti> :t (>>=)
09:52:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:52:50 <quicksilver> that's a rather subtle variation of associativity, pqmodn
09:52:52 <rwbarton> composition in a category is also associative
09:53:01 <pqmodn> ah, not also left-associative
09:53:02 <quicksilver> it's not "exactly" >>= which is associativity
09:53:12 <quicksilver> but what people mean by it is clear enough
09:53:12 <exFalso1> >=> is
09:53:18 <quicksilver> it's more accurate to say >=> is
09:53:26 <quicksilver> which is a very closely related operator
09:53:28 --- mode: ChanServ set +o quicksilver
09:53:36 --- mode: quicksilver set +b *!*Lajla@*.speed.planet.nl
09:53:37 --- kick: Lajla was kicked by quicksilver (go away. never come back.)
09:53:42 <srhb> yes/no/maybe for some values of associativity.
09:53:43 <srhb> :-)
09:53:43 --- mode: quicksilver set -o quicksilver
09:53:46 <rwbarton> oh wait, i'm dumb, yeah (>>=) isn't associative really
09:54:09 <quicksilver> people do talk about the associativity of bind, but they're being slightly imprecise.
09:54:21 <rwbarton> (x >>= f) >>= g  =  x >>= (f >=> g)
09:55:08 <pqmodn> also, doesn't this hold? (x >> f) >> g = x >> (f >> g)
09:55:18 <kallisti> yes
09:56:54 <kallisti> x >>= (f >=> g) = const x >=> (f >=> g) $ undefined
09:57:10 <kallisti> ...I'm not sure what that has to do with anything
09:57:17 <kallisti> but there it is.
09:57:41 <pqmodn> i'm confused then by exFalso1's statement that the type is significant. isn't satisfying (a # b) # c = a # (b # c) sufficient to show associativity?
09:58:50 <parcs`> :t (?a >>= ?b) >>= ?c
09:58:51 <lambdabot> forall (m :: * -> *) a a1 b. (?a::m a, ?b::a -> m a1, Monad m, ?c::a1 -> m b) => m b
09:58:56 <parcs`> :t ?a >>= (?b >>= ?c)
09:58:57 <lambdabot> forall (m :: * -> *) a a1 b. (?a::m a, ?b::a -> a1, ?c::a1 -> a -> m b, Monad m) => m b
09:59:26 <parcs`> :t [ (?a >>= ?b) >>= ?c, ?a >>= (?b >>= ?c) ]
09:59:27 <lambdabot> Top level:
09:59:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
09:59:27 <lambdabot>       Expected type: a -> m b
10:00:19 <pqmodn> parcs`: i'm not sure what that means, that the instances of '>>=' are actually different operators?
10:00:20 <quicksilver> pqmodn: in order to examine that statement you need to make the types work. Which forces you to "domino types"
10:00:35 <quicksilver> whoever said it has to be "a -> a -> a" went too far
10:00:38 <parcs`> pqmodn: >>= is not associative
10:00:42 <quicksilver> it just has to be categorical composition
10:00:52 <pqmodn> quicksilver: ok, that's what i was confused about
10:01:01 <quicksilver> an example of a non-"a->a->a" associative operation is matrix multiplication
10:01:01 <kallisti> pqmodn: it's a proof by contradiction that >>= is not associative.
10:01:08 <quicksilver> which follows the so-called domino rule
10:01:29 <srhb> Well, that was the point. It can be associative or non-associative if it is a->a->a
10:01:39 <quicksilver> (and that's just a special case of categorical composition of course - categories are precisely the study of general associativity)
10:02:57 <pqmodn> parcs`: is the ?a syntax a lambdabot extension? i was looking for a feature like that last week
10:03:12 <kallisti> pqmodn: it's ImplicitParameters
10:03:12 <quicksilver> it's a GHC extension
10:03:17 <kallisti> basically dynamically scoped variabled
10:03:20 <kallisti> *s
10:03:25 <quicksilver> one which is strongly unrecommended for real coding
10:03:31 <quicksilver> but quite handy for type-checking hacks like the above
10:03:47 <pqmodn> yeah, i just need it to get some info from the type checker
10:03:58 <kallisti> quicksilver: but but, otherwise it's /impossible/ to thread implicit state through a program conveniently. you have to deal with all this monad stuff, ugh.
10:05:02 <quicksilver> kallisti: shall I laugh or cry?
10:05:12 <kallisti> laughcry. :_D
10:05:20 * quicksilver craughs.
10:05:23 <kallisti> heh
10:05:29 <jamiltron> Any known way on getting Crypto-4.2.4 to work with ghc 7.4?
10:05:53 <kallisti> quicksilver: if we didn't have implicit parameters, people might actually have to learn how to program in Haskell
10:05:56 <kallisti> !!!
10:06:29 <hpaste> ‚ÄúJustin Hamilton‚Äù pasted ‚ÄúCrypto error‚Äù at http://hpaste.org/65199
10:06:41 <bgamari> jamiltron: Yes, add Show instances to Num constraints
10:06:47 <bgamari> s/instances/constraints
10:07:08 <bgamari> jamiltron: Num no longer implies Show
10:07:45 <kallisti> bgamari: but if a type is only an instance of Num, what does it have to show for itself?
10:07:46 <jamiltron> Do I add that in SHA2.hs?
10:07:48 * kallisti is on a roll.
10:08:36 <c_wraith> jamiltron: wherever ghc tells you it's missing.
10:08:43 <kallisti> jamiltron: add it to any type signatures for functions which require a Show instance.
10:09:15 * hackagebot yaop 0.1.2 - Yet another option parser  http://hackage.haskell.org/package/yaop-0.1.2 (EugeneSmolanka)
10:09:25 <bgamari> jamiltron: Yes, SHA2.hs
10:09:34 <bgamari> Seems like everything else is fine
10:09:35 <jamiltron> bgamari: Thank you!
10:09:41 <bgamari> I'm about to send a patch to the maintainer
10:09:56 <bgamari> jamiltron: No worries!
10:10:42 <kallisti> I would almost make the argument that functions without top-level signatures are in some sense slightly more future proof.
10:11:27 <c_wraith> very slight.
10:11:28 <kallisti> unless, of course, the future of Haskell involves lots of explicit type signatures.
10:11:45 <c_wraith> however, they are a huge advantage for debugging and documentation
10:12:05 <kallisti> indeed.
10:12:34 <quicksilver> yes, it's a tradeoff even ignoring library changes
10:12:48 <quicksilver> not specifying signatures allows you to refactor the types in your code in certain ways
10:12:54 <quicksilver> and things keep working.
10:12:56 <c_wraith> partial signatures would add some middle ground
10:13:13 <quicksilver> On the other hand, it's more prudent to hide the bits you want to change behind a type name (which doesn't have to change)
10:13:20 * kallisti wants a ::: signature that tells GHC to automatically update the signature if it's incorrect. should be fun.
10:13:21 <c_wraith> But they don't seem likely.
10:13:30 <quicksilver> partial signatures are really important, c_wraith
10:13:46 <kallisti> what is this partial signature business.
10:13:47 <quicksilver> there are whole areas of design space which are a nightmare to explore without them
10:14:04 <c_wraith> kallisti: being able to specify a signature like :: _ Int
10:14:10 <quicksilver> matthew sackman's PhD for example
10:14:14 <kallisti> c_wraith: ah
10:14:15 <augur> can a where scope over two |'s?
10:14:32 <c_wraith> augur: where clauses scope over all guards with a particular equation
10:14:38 <augur> ok
10:14:38 <kallisti> c_wraith: you can do that for individual arguments I believe
10:14:42 <kallisti> f x (y :: Int)
10:14:49 <quicksilver> http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
10:14:51 <kallisti> but I'm guessing this is more general.
10:14:52 <c_wraith> kallisti: but that's not really the same thing
10:15:00 <quicksilver> ^^ type signatures in there are something to behold.
10:15:10 <quicksilver> and we don't really have the tools to control that well with current abstractions
10:15:16 <quicksilver> which is a shame, because the language handles them fine.
10:15:44 <hpaste> ‚ÄúJustin Hamilton‚Äù pasted ‚ÄúCrypto error 2‚Äù at http://hpaste.org/65200
10:16:13 <jamiltron> Hmm, fixed the Show errors, but now I'm getting something that seems a bit more complicated
10:16:25 <c_wraith> quicksilver: so why have partial signatures not made it into GHC?
10:16:50 <quicksilver> c_wraith: I don't think anyone has provided a good proposal.
10:17:32 <quicksilver> c_wraith: first class constraints is a step in teh right direction
10:17:45 <quicksilver> (to the extent that unmanageable type signatures often contain a substantial constraint portion)
10:18:02 <quicksilver> which is certainly true of the sessions ones.
10:19:04 <c_wraith> I like the MPTC with 11 parameters
10:19:18 <kallisti> what if we gave Haskell an exists keyword in types. You could use it for convenient existential quantification as well. :)
10:19:39 <c_wraith> there are some theoretical problems with exists.
10:19:45 <c_wraith> UHC has an exists keyword
10:19:49 <c_wraith> but it's not very useful
10:19:51 <rwbarton> quicksilver: that module looks really convenient indeed
10:20:19 <quicksilver> I would say there are *practical* problems with exists.
10:20:21 <c_wraith> Because there's no context to unpack class instances in
10:20:33 <c_wraith> unlike with GHC's approach to existentials
10:20:39 <quicksilver> the constructor in the GHC-style existential is an important delimeter
10:20:40 <c_wraith> where the case expression unpacks class instances
10:20:47 <quicksilver> it delimets the scope of the (unknown) type variable
10:21:03 <rwbarton> heck, we have the forall keyword but it doesn't even work all that well (impredicative types)
10:21:06 <quicksilver> without it, it's hard to get the type inference you want.
10:21:07 <kallisti> well I was considering exists as a way to do partial signatures as well.
10:21:26 <kallisti> forall b. exists a. a -> Int -> b
10:21:32 <kallisti> perhaps I don't understand partial signatures.
10:21:44 <c_wraith> No, that says something very different
10:21:59 <rwbarton> how about exists a. forall b. a -> Int -> b
10:21:59 <c_wraith> partial signatures are about saying "infer everything, except this part I want to specify directly"
10:22:06 <jamiltron> What is exit failure 11?
10:22:19 <kallisti> ah okay.
10:22:25 <c_wraith> throwing an exists in is very different from saying "infer this".  In fact, it's kind of saying "don't infer this"
10:22:32 <rwbarton> even that isn't really the same yeah
10:22:42 <quicksilver> partial signatures are like _ in patterns.
10:22:47 <quicksilver> but at the type level
10:22:56 <quicksilver> "something matches here, but you need to work out what it is"
10:23:07 <kallisti> that's what exists conveys to me...
10:23:09 <quicksilver> where "you" is the compiler
10:23:26 <quicksilver> with exists it's a different something each time it's unwrapped
10:23:35 <quicksilver> exists is a runtime "I don't know what this is"
10:23:43 <quicksilver> a partial signature is still determined at compile time
10:23:43 <Cale> rwbarton: That type would only contain undefined, but  forall b. exists a. a -> b  would have a defined value
10:23:49 <quicksilver> I don't think I said that very well.
10:23:56 <quicksilver> but there is a difference in stage, anyhow.
10:24:12 <rwbarton> sure, you'd have to make the example more reasonable also
10:24:15 <geekosaur> jamiltron, hard to say for certain but 11 makes me think something caught a segfault (which would explain lack of error messages before it)
10:24:16 <kallisti> quicksilver: I understand what you're saying.
10:24:25 <roconnor> @type Either
10:24:26 <lambdabot> Not in scope: data constructor `Either'
10:24:29 <roconnor> @type either
10:24:30 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
10:24:33 <Saizan> _ in a type signature would be like an existentially quantified META-variable
10:24:34 <roconnor> @type (|||)
10:24:35 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
10:24:41 <kallisti> you couldn't use exists for both existential quantification and partial signatures. and because there's already existentials, using an exists keyword for partial signatures is confusing.
10:24:57 <roconnor> @type right
10:24:58 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
10:25:23 <kallisti> infer a. Num a => a -> Int -> Bool
10:25:24 <kallisti> kind of lame.
10:25:39 <jamiltron> geekosaur: Thanks. Yeah I'm just getting an error saying its having problems compiling Codec.Encryption.BlowfishAux
10:26:15 <c_wraith> quicksilver: unfortunately, there's currently a performance hit with constraint kinds.
10:26:28 <quicksilver> c_wraith: that's interesting.
10:26:37 <c_wraith> quicksilver: They aren't expanded in time for inlining instances to happen
10:26:38 <quicksilver> c_wraith: still you see what I mean about it being a step in the right direction?
10:26:43 <c_wraith> definitely
10:27:14 <quicksilver> kallisti: an "infer" quantifier is not far off, yes
10:27:32 <quicksilver> it is a kind existential, but it's a meta-language existential not a haskell existential, I think?
10:29:01 <Saizan> yep
10:30:53 <geekosaur> jamiltron, yes, thing is "ExitFailure 11" just means some process called exit(11).  there is no general standard for what exit codes mean (<sysexits.h> is only useful for some servers).  things like "make" and "gcc" often pass on a signal exit of a subprocess as an exit() call though, which is what makes me think the 11 relates to signal 11 (traditionally SIGSEGV, segmentation violation)
10:31:57 <quicksilver> kallisti: having it that way allows you to specifically indicate that two of the missing parts are equal, as in "infer a. Either a a"
10:32:10 <quicksilver> which is not something I was suggesting
10:32:16 <quicksilver> but could possibly be occasionally helpful.
10:32:32 <kallisti> quicksilver: yes
10:32:41 <quicksilver> (versus a simple placeholder-style Either _ _)
10:32:59 <kallisti> I think infer is not bad actually.
10:37:36 <notrusty> I can't get ghc-mod working with emacs on ubuntu;  anybody have thoughts on troubleshooting?
10:38:05 <kallisti> notrusty: you mean haskell-mode?
10:38:13 <notrusty> kallisti, http://mew.org/~kazu/proj/ghc-mod/en/install.html
10:38:13 <kallisti> ah nevermind
10:38:24 <notrusty> haskell mode seems to be working as expected
10:38:28 <kallisti> are you getting any error output or is it just "not working"
10:39:04 <notrusty> no error output.  i believe it's running the init file (the flymake setup at the bottom of that link), but the keys just don't seem to be bound
10:40:18 <kallisti> notrusty: make sure you're using $HOME instead of ~ in PATH
10:41:06 <kallisti> and double check all the other stuff. that load-path can search ghc*.elc and such
10:41:51 <pozic> cabal install leksah
10:41:52 <pozic> Resolving dependencies...
10:41:53 <pozic> cabal: Couldn't read cabal file "leksah-server/0.12.0.3/leksah-server.cabal"
10:41:56 <notrusty> hmm, i used ~, but I think fish expanded it for me...
10:42:09 <pozic> How am I supposed to install leksah?
10:42:39 <kallisti> notrusty: it depends. some shells don't always expand in all possible locations in a word, and then some programs won't interpret the ~ to mean home, etc.
10:42:44 <kallisti> $HOME is just the safer option.
10:42:47 <notrusty> roger
10:45:04 <kallisti> also my init file is just called .emacs. I don't know much about emacs but I'm guessing it checks for either .emacs or .emacs.el?
10:45:25 <notrusty> kallisti, i'm on Ubuntu and using ~/.emacs.d/init.el
10:45:29 <ski> quicksilver,kallisti : in OCaml you can annotate types with `as a' with `a' a tyvar (not a `forall'-bound one) -- using that, one might say `Either (_ as a) a'
10:45:37 <notrusty> but it seems to be using it as expected
10:45:56 <ski> (.. or maybe s/a/_a/, to emphasize that `_a' will be bound to a concrete type)
10:46:36 <notrusty> heh, just for reference:  "The standard file name constructs, ë~í, ë.í, and ë..í, are interpreted as usual in exec-path, but environment variable substitutions (ë$HOMEí, etc.) are not recognized;"
10:46:52 <ski> (well, i suppose `a@_' might correspond more nicely with how value-level `as' corresponds to `@' in Haskell)
10:46:59 <geekosaur> ...
10:47:09 * kallisti would be interested in seeing arbitrary postfix/infix/prefix/unary/binary/ternary/circumfix operators in the distant future of Haskell.
10:47:13 <geekosaur> they bother to expand ~ but not envars.  wtf.
10:47:23 <kallisti> things that Perl 6 is doing.
10:47:45 <Saizan> ski: do you have a reference for interesting uses of that?
10:47:59 <kallisti> notrusty: that's okay because your shell should expand it anyway.
10:48:01 <rwbarton> agda has some large amount of those operator types
10:48:55 <kallisti> I think infix operators is one of the reasons Haskell excels at DSLs, at least as far as the syntactic presentation of these languages goes.
10:49:01 <kallisti> lazy evaluation helps with the semantics.
10:49:19 <kallisti> so other operator types would improve this capability, I think.
10:50:11 <ski> Saizan : "polymorphic variants" (which are extensible light-weight variant types), as well as object types in OCaml in general contain an implicit row variable. it's relatively common to use `as' to avoid mentioning it explicitly (when it prints types, it does this automatically in those cases)
10:50:12 <notrusty> hmm, how do i display my exec-path and load-path...  (vim user; struggling.)
10:50:55 <ski> Saizan : iirc, `Oo.copy' (see the manual on the OO system) is an example of this -- there's probably more exciting examples, though
10:51:59 <kallisti> notrusty: describe-variable
10:52:02 <kallisti> I helieve?
10:52:05 <kallisti> *b
10:52:11 <KorriX> hello
10:52:16 <notrusty> ah, good, thanks
10:52:58 <KorriX> is there any function that can convert [[a,b],[a,c],[b,d]] -> [(a,[b,c]), (b, [d])] ?
10:53:19 <notrusty> /home/rusty/.emacs.d isn't in load-path;  that must be my problem.  thanks.
10:53:38 <kallisti> headMap f (x:xs) = f x xs
10:53:53 <kallisti> headMap f [] = []
10:54:07 <KorriX> @headMap
10:54:07 <lambdabot> Unknown command, try @list
10:54:12 <kallisti> I made it up.
10:54:37 <kallisti> map (headMap (,)) [[a,b],[a,c],[b,d]]
10:55:05 <kallisti> KorriX: so, to answer your question, "no, but it's really simple to write one."
10:55:29 <KorriX> grouping ?
10:55:37 <KorriX> normally i use Data.Map
10:55:44 <kallisti> hm?
10:56:05 <kallisti> not that kind of map.
10:56:11 <kallisti> ???? (I'm totally confused)
10:56:40 <deech> Hi all, does anyone know if are any benchmarking studies done on Haskell's STM beyond the original paper?
10:57:11 <ski> @type comparing
10:57:12 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:57:21 <kallisti> > let headMap f [] = []; headMap f (x:xs) = f x xs in map (headMap (,)) [[a,b],[a,c],[b,d]]
10:57:22 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(t, [t])'
10:57:26 <ski> @let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating f = (==) `on` f
10:57:29 <lambdabot>  Defined.
10:57:39 <ski> > let frob = map ((fst . head) &&& (map snd)) . groupBy (equating fst) in frob [(a,b),(a,c),(b,d)]
10:57:40 <lambdabot>   [(a,[b,c]),(b,[d])]
10:57:47 <ski> KorriX ^
10:57:50 <KorriX> thanks
10:57:59 <geekosaur> deech, I'm under the impression that an optimized STM is pending, I presume benchmarks were involved
10:58:02 <rwbarton> if the pairs aren't guaranteed to be sorted/ordered nicely then you probably want Map.fromListWith
10:58:07 <ski> note that i had a list of *pairs* as input (instead of a list of dupletons)
10:58:21 <deech> geekosaur: Neat, I hadn't heard that. Is it in GHC head?
10:59:20 <kallisti> :t let headMap f [] = []; headMap f (x:xs) = f x xs in headMap (,)
10:59:21 <lambdabot>     Couldn't match expected type `[a]' against inferred type `(t, [t])'
10:59:21 <lambdabot>     In the first argument of `headMap', namely `(,)'
10:59:21 <lambdabot>     In the expression: headMap (,)
10:59:27 <kallisti> ??
10:59:37 <kallisti> ah
10:59:48 <kallisti> :t let headMap f (x:xs) = f x xs in headMap (,)
10:59:49 <lambdabot> forall t. [t] -> (t, [t])
11:00:36 <geekosaur> deech, I don't see STM in the ghc bootlibs at all
11:01:18 <deech> geekosaur: Crap, you're right. It was pulled out of GHC some time ago. My mistake, I'll check the stm package on hackage. Sorry to waste your time.
11:01:26 <kallisti> KorriX: oh, I completely misread.
11:01:38 <KorriX> :)
11:01:47 <kallisti> I was like "what does grouping have to do with anything?"
11:02:20 <geekosaur> the current version on hackage is 2.3, but I don't even know if that's the optimized version or if it's only in the stm repo
11:03:57 <dylukes> We've got Travis CI support guys :).
11:04:08 <dylukes> They've got slaves up with cabal and the HP 2011.4
11:04:35 <dylukes> (note, most of them have not been cabal update'd... so edit the install script to do cabal update)
11:05:48 <thoughtpolice> dylukes: very cool, i'll have to set it up for some of my older projects
11:05:56 <dylukes> I just REALLY hope it caches cabal pacages...;)
11:06:10 <dylukes> Because I'm installing ALL of EdwardK :P
11:06:21 <edwardk> =P
11:06:24 <scooty-puff> is there much work for an extensible record library?  HList looks like one, are there any others as well?
11:06:30 * edwardk downloaded himself a long time ago
11:06:40 <dylukes> http://travis-ci.org/#!/DylanLukes/Winchester-STG-Compiler
11:06:52 <dylukes> It KILLS my CPU though... So much AJAX >_<.
11:06:56 <DanBurton> "extensible record"?
11:07:00 <dylukes> Makes my browser run like molasses.
11:07:09 <dylukes> scooty-puff: I think what you want is called a Map.
11:07:13 <dylukes> :)
11:07:48 <scooty-puff> http://www.haskell.org/haskellwiki/Extensible_record
11:07:54 <dylukes> thoughtpolice: http://travis-ci.org/#!/DylanLukes/Winchester-STG-Compiler/builds/848217
11:07:57 <dylukes> 3000 line build log :D?
11:08:08 <scooty-puff> hlist just looked a little old, and would maybe benefit from non-* kinds
11:08:24 <scooty-puff> (not sure if the right term to use)
11:08:52 <geekosaur> HList is still the most commonly used one
11:08:58 <DanBurton> "higher" kinds I believe is the term
11:09:03 <dylukes> thoughtpolice: One tip btw, set it up to send notifications to say... myemai+travisci@gmail.com
11:09:13 <geekosaur> the latest argumnt over extensible records just wound down to the usual no-conclusion over the weekend
11:09:13 <dylukes> Then you can set up a rule to filter all the travis spam easily
11:09:27 <thoughtpolice> dylukes: i just use filters to do basically the same thing, looking at the send address
11:09:52 <thoughtpolice> considering i'm subscribed to about 10 mailing lists, this pays off quickly, yes :P
11:09:57 <dylukes> I prefer to use +rules because it mitigates any possible mistakes :).
11:10:22 <DanBurton> I suppose if you use a hash map for all fields, then you could sort of use Haskell as if it were Python
11:10:23 <dylukes> And I can just myemail+rust, myemail+ghc, myemail+misc...
11:11:38 <dylukes> agh... I still don't know how it handles cabal packages though...
11:11:50 <dylukes> I've had builds run on jvm-4 and jvm-5, and so it had to install everything on both...
11:13:10 <dylukes> I guess it's incentive to cut down on dependencies ^^;...
11:13:13 <Taneb> http://hpaste.org/65201 <-- any ideas
11:13:14 <Taneb> ?
11:13:21 <Taneb> (gtk2hs isn't working)
11:13:31 <dylukes> Taneb: Do you have GTK and Cairo installed?
11:13:41 <Taneb> Yes
11:13:43 <dylukes> It looks like it can't dylink to them
11:13:55 <dylukes> GHC is notoriously bad at finding libraries >_>.
11:14:11 <rwbarton> does your program work if you compile it?
11:14:12 <monochrom> "GTK and Cairo" as in the C-side libs
11:14:30 <rwbarton> I assume he must have the C libraries as he appears to have the cairo haskell package...
11:14:40 <Taneb> rwbarton, no
11:14:47 <monochrom> then again I guess if you built the haskell-side yourself, you had the C-side
11:14:49 <Taneb> It doesn't compile
11:15:48 <rwbarton> you're probably better off trying to get that to work first, ghci and dynamic libraries can be a bit fiddly
11:16:00 <Taneb> Same problem
11:16:31 <rwbarton> well I doubt the error message is identical; but I also don't know anything about windows
11:17:47 <rwbarton> so I won't be able to help regardless
11:19:28 <Taneb> Huh
11:19:34 <Taneb> Compiling suddenly works
11:19:40 <Taneb> I swear it didn't use to
11:22:12 <Taneb> Well, thanks anyway
11:23:13 <Taneb> When is a program generally regarded to be ready for putting it up somewhere on the internet?
11:23:55 <c_wraith> whenever you feel like it.
11:24:09 <Taneb> And what's the process for doing so?
11:24:19 <c_wraith> That depends on the purpose.
11:24:47 <c_wraith> If you mean releasing something on hackage, you need to get an account first.  Otherwise...  It's pretty completely open
11:24:48 <Taneb> Purpose for the program or for putting it up on the internet?
11:25:02 <c_wraith> either.
11:25:13 <ksf> if in doubt, roll a dice.
11:25:20 <c_wraith> Mostly the latter, though whether it's a standalone app or a library matters somewhat
11:25:50 <Taneb> It's... a library with an app that goes with it?
11:28:36 <andares> hey, is there a way to query the fixity of an operator in ghc?
11:29:49 <andares> also I was wondering if there's a shortcut to evaluating items of a list until some condition is met, then returninng Just some value otherwise nothing.
11:30:15 <Taneb> andares, the second sounds like lookup
11:30:17 <Taneb> :t lookup
11:30:18 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:30:23 <andares> I'm writing a prime factorization algorithm, so I was going to do lowestFactor = mod <$> ps <*> (pure n).
11:30:24 <Taneb> But not quite?
11:30:31 <Taneb> Hmm
11:30:34 <andares> doesn't seem exactly like lookup, unless I zipped or something.
11:30:40 <andares> well, head mod ...
11:30:47 <andares> I want a "safe" head I think.
11:30:54 <andares> hehe.. dirty mind.
11:32:47 <monochrom> in ghci, enter ":info <$>" to find the fixity of <$>. if none is shown, it is the default infixl 9.
11:32:59 <andares> ooh thanks monochrom.
11:33:16 <monochrom> enter ":info <$> <*> $ + *" to ask for many operators at once
11:33:27 <andares> hm.. so is associativity left by default?
11:33:28 <DanBurton> left associativity is the default? odd, I would've expected no associativity to be default
11:33:33 <andares> hah
11:33:39 <DanBurton> you beat me
11:33:54 <andares> I was making sure that a <$> b <*> c would work without problems.
11:34:14 <Ngevd> find :: [a] -> (a -> Bool) -> Maybe a; find [] _ = Nothing; find (x:xs) f | f x = Just x | otherwise = find xs f
11:34:32 <scooty-puff> DanBurton, geekosaur: thanks
11:38:54 <andares> no instance for enum arising from an arithmetic sequence?
11:38:57 <andares> that seems.. broken.
11:40:28 <DanBurton> andares: huh? (side note a <$> b <*> c is a common idiom in Haskell)
11:40:43 <andares> DanBurton, sorry, still learning.
11:40:48 <andares> anyway, class! thanks guys.
11:41:36 <monochrom> there is no conflict between "common idiom" and "I want to make sure"
11:43:15 <DanBurton> indeed, but "I want to make sure" suggests that one is unaware of the commonality of the thing
11:44:03 <DanBurton> anyways, when it comes to fixities, I usually just try it out and see if it works :P
11:44:24 <DanBurton> it makes me sad that `foo <| bar |> baz' doesn't work (Data.Sequence)
11:48:50 <paolino> hello, is there any relation between monoid and (+) ? I just miss a Negate class to use mappend to subtract.
11:49:15 <rwbarton> > Sum 3 `mappend` Sum 5
11:49:16 <lambdabot>   Sum {getSum = 8}
11:49:32 <rwbarton> Sum is a newtype that uses (+) for mappend
11:50:10 <copumpkin> paolino: negate would be group
11:50:26 <copumpkin> would probably be called invert in a more general setting
11:50:34 <paolino> rwbarton, I thought Monoid was useful for Num, not the other way around
11:50:39 <Taneb> What would mzero be for Negate?
11:51:07 <copumpkin> huh
11:51:15 <paolino> mzero is for Monoid , not Invert
11:52:10 <paolino> copumpkin, I have no idea of group , not enough math background
11:53:32 <sclv> ?google wikipedia group math
11:53:34 <lambdabot> http://en.wikipedia.org/wiki/Group_(mathematics)
11:53:34 <lambdabot> Title: Group (mathematics) - Wikipedia, the free encyclopedia
11:53:42 <paolino> copumpkin, it should be class Group with sum and difference ?
11:54:26 <rwbarton> in general the operations are called multiplication and inverse
11:56:11 <monochrom> Monoid does not have a method for subtraction.
11:56:36 <paolino> it seems group has it
11:56:44 <napping> Is there any convenient list of which base versions correspond to which GHC versions?
11:57:15 <napping> In particular, the earliest ghc with 4.*
11:57:34 <paolino> x `mappend` (inverse y)
11:58:01 <rwbarton> in general that might be different from (inverse y) `mappend` x
11:58:09 <_Mikey> > let a = getStdGen
11:58:10 <lambdabot>   not an expression: `let a = getStdGen'
11:58:15 <monochrom> I am guessing GHC 6.8 has base 4.0
11:58:19 <_Mikey> > a = getStdGen
11:58:20 <lambdabot>   <no location info>: parse error on input `='
11:58:22 <paolino> x `mappend` (inverse x) == mzero++
11:58:28 <k0ral> hi, I've got a String with obviously misinterpreted characters (\234 and so); it seems to be Latin1 charset, how can I decode it in Haskell ?
11:58:51 <paolino> rwbarton, mappend is not commutative ?
11:59:04 <rwbarton> it need not be
11:59:10 <rwbarton> > "x" `mappend` "y"
11:59:11 <lambdabot>   "xy"
11:59:21 <paolino> oh right
11:59:42 <paolino> still Num is overkill
11:59:58 <rwbarton> I don't know what you mean by that
12:00:15 <rwbarton> your original question was "is there a relationship between mappend and (+)", and (+) is a member function of the Num type class
12:01:15 <rwbarton> so I pointed out that if you have a type that's an instance of Num, you can get an instance of Monoid using Sum
12:03:40 <napping> I'm not sure where exactly in the repos to look, or how to slice it without downloading all of http://darcs.haskell.org/packages/base/ and http://darcs.haskell.org/ghc/
12:04:46 <paolino> rwbarton, implementing Num for a type with subtraction only is not correct, Num has multiplication
12:04:58 <rwbarton> you're going the wrong way
12:05:01 <paolino> but mappend is not enough
12:05:23 <rwbarton> or maybe this is your question, and you're answering it yourself
12:05:34 <thoughtpolice> napping: you can look at the release notes; every version has notes on the library changes (including version numbers)
12:05:42 <thoughtpolice> in particular I think it was ghc 6.10 that first shipped with base 4
12:06:20 <napping> thoughtpolice: yes, exactly
12:07:20 <napping> I'm considering updating some code that uses data-object and data-object-yaml to non-deprecated packages so it will build on 7.4.1, and I don't see anything stricter than base 4.*
12:15:59 <uniquenick> haskell doesn't have any sort of requirement on modules living in files with particular names right?  but cabal does?
12:17:20 <byorgey> uniquenick: the Haskell standard only talks about modules, and does not specify how they map onto files.
12:17:52 <byorgey> uniquenick: however, GHC requires the module Foo.Bar to be in  Foo/Bar.hs (or .lhs)
12:18:41 <kallisti> byorgey: it would be interesting to come up with some alternative systems to resolving module name -> file location
12:18:52 <kallisti> byorgey: perhaps with more flexibility.
12:19:02 <Taneb> I think in my family tree format I should move name and sex out from the generic attribute slot
12:19:04 <byorgey> yes, it would be.  For one, having multiple modules in the same file could be fun.
12:19:27 <monochrom> Hugs uses the same filename convention as GHC
12:19:33 <kallisti> I think you would need some sort of auxillary utility to manage those kinds of mapping though.
12:19:57 <tgeeky> kallisti: curl or wget, and just use URLs :O
12:20:00 <byorgey> my guess would be that most Haskell compilers use the same convention, but I only know what GHC does.
12:20:06 <tgeeky>  file:// for local, http://, etc -- for remote
12:20:11 <monochrom> someone once suggested a manifest file to hold the mapping between modules and files
12:20:15 <kallisti> tgeeky: erm...?
12:20:21 <kallisti> you mean, use URLs in Haskell source files?
12:20:25 <byorgey> import http://foo.com/Bar.Baz
12:20:28 <kallisti> heh
12:20:35 <kallisti> it's a possibility.
12:20:38 <tgeeky> kallisti: it fits the last few lines I've read
12:21:02 <kallisti> I meant keep the same module naming conventions but has a more flexible logical mapping, locally set.
12:21:10 <kallisti> it could be managed via cabal pretty easily.
12:21:12 <byorgey> hehe, but actually specifying the URL in the import declaration seems dirty.  I think what monochrom said (a manifest telling you where to find things) would make more sense.
12:21:34 <byorgey> then you could easily just change the manifest if you wanted to swap out one implementation of a module for another.
12:21:40 <tgeeky> byorgey: import qualified http://base.haskell.org/4.0.4.0/Prelude as Prelude
12:22:04 <byorgey> hopefully Derek Dreyer + Scott Kilpatrick's work on the module system will address this.
12:22:10 <kallisti> tgeeky: ah yes, and for a logical mapping you could just host a web server on localhost!
12:22:18 <tgeeky> kallisti: yes
12:22:36 <kallisti> Hapache.
12:22:41 <tgeeky> kallisti: might even get around some IO awkardness
12:23:00 <kallisti> "Failed to compile. 404."
12:24:03 <ahf> 21
12:24:10 <tgeeky> that's numberwang!
12:25:29 <byorgey> =D
12:25:42 <byorgey> two.  ...hundred!
12:25:53 <tgeeky> Oh, I'm sorry, that's not numberwang!
12:26:02 <byorgey> =(
12:26:18 <tgeeky> I especially love the huge collection of books for the home version of the game.
12:27:52 <hpaste> ‚Äú_Mikey‚Äù pasted ‚Äúrandom list‚Äù at http://hpaste.org/65202
12:28:03 <_Mikey> Hi
12:28:16 <_Mikey> can some one tell me where I'm going wrong
12:28:21 <_Mikey> I have my functions
12:28:33 <_Mikey> and I'm fmapping in getStdGen
12:28:58 <_Mikey> and I'm getting :: Num a => IO (a -> [Float] -> [Float])
12:29:20 <_Mikey> why can I not fmap in an integer and an empty list for my resulting list of floats?
12:32:53 <mauke> _Mikey: what?
12:34:33 <_Mikey> When I fmap StdGen into the function
12:34:41 <_Mikey> its in the IO monad
12:34:49 <_Mikey> so I would need to fmap the other parameters in right?
12:35:09 <_Mikey> but ghci says that's not the way
12:35:10 * ski wonders exactly what _Mikey's code looks like
12:35:21 <_Mikey> http://hpaste.org/65202
12:35:27 <mauke> _Mikey: I have no idea what you're talking about
12:35:29 <ski> oh, missed the paste
12:35:34 <_Mikey> no worries
12:36:02 <_Mikey> I'm calling randomFloats `fmap` getStdGen
12:36:06 <_Mikey> :t getStdGen
12:36:07 <lambdabot> IO StdGen
12:36:12 <mauke> why?
12:36:17 <_Mikey> cause its in the IO monad
12:36:23 <mauke> what
12:36:28 <mauke> lots of stuff is in the IO monad
12:36:28 <ski> you presumably want `return list' instead of `list' in the middle clause
12:36:32 <_Mikey> getStdGen is
12:36:34 <mauke> that doesn't mean I have to call it
12:36:42 <mauke> why are you using getStdGen?
12:37:10 * ski sees no use of `getStdGen' in the pasted code
12:37:11 <_Mikey> to generate ranomd numbers
12:37:30 <mauke> getStdGen doesn't generate random numbers
12:37:31 <ski> you usually want `newStdGen' rather then `getStdGen'
12:37:35 <_Mikey> I'm using getStdGen in ghci to supply the gen parameter
12:37:45 <ski> (but neither of those generates random numbers)
12:37:55 <_Mikey> pseudo random?
12:38:18 <mauke> _Mikey: your equations #1 and #3 for randomFloats are identical
12:38:25 <ski> (they fetch a *generator*, then `random' and friends can generate your actual numbers)
12:38:47 <ski> mauke : except `[]' vs. `list' in the head
12:38:58 <mauke> ski: yes. look at the code.
12:39:11 <ski> ah, right
12:39:18 <_Mikey> mauke, one is to stop stop it calling
12:39:24 <ski> (i.e. the last case includes the first case)
12:39:44 <_Mikey> oh
12:39:51 <_Mikey> I see
12:39:58 <mauke> _Mikey: that's #2
12:40:28 <_Mikey> #2 and could be called in #4 you mean?
12:40:38 <mauke> what
12:41:02 <_Mikey> sorry
12:41:02 <TheLemonMan> err, hackage Data.Text definition for split differs widely from the one i have
12:41:08 <ski> _Mikey : there's only three defining clauses/equations for `randomFloats' in the paste
12:41:14 <_Mikey> yea
12:41:18 <TheLemonMan> either my package is old or the docs are incorrect
12:41:27 <_Mikey> #1 and #3 are repeating
12:41:32 <_Mikey> I see it
12:42:08 <_Mikey> but as far as getting my Int into the function I'm stuck?
12:42:24 <mauke> _Mikey: any particular reason you're not just doing randomFloats n g = take n (randoms g) ?
12:43:10 <_Mikey> I wanted to see it was possible this way
12:43:18 <_Mikey> calling recursively
12:43:25 <ski> _Mikey : instead of `a = randomFloat gen' and then using `fst a' and `snd a', i'd say `(n,gen1) = randomFloat gen0' and use `n' and `gen1' instead of calling `fst' and `snd'
12:44:09 <_Mikey> ahh, ok.
12:44:15 <mauke> _Mikey: fmap (\g -> randomFloats 10 g []) getStdGen
12:44:18 <mauke> if you insist on using fmap
12:45:44 <_Mikey> ahhh
12:46:06 <_Mikey> so the lambda is supplied to the function and you map that across getStdGen
12:46:10 <_Mikey> cool
12:47:08 <_Mikey> mauke, do you think take the take n expression would be more efficient?
12:47:21 <mauke> who cares?
12:47:33 <_Mikey> curiousity
12:47:37 <mauke> benchmark it
12:47:52 <_Mikey> sounds like a plan
12:48:01 <mauke> the point is, take n . randoms is four words as opposed to your 13 lines
12:50:07 <t7> i feel like there is space on this earth for a lighting fast C++ web server/web engine
12:51:00 <t7> what are lenses and how do i use them?
12:51:24 * ski thinks "web engines" should support continuations
12:51:52 <companion_cube> t7: that exists, I think (look for wt)
12:52:04 <ski> lenses are a way to abstractly represent a "field" in a datastructure
12:52:09 <rostayob> ski: speaking of that, is there any continuation-based framework in haskell?
12:52:15 <t7> i saw wt but it looked horribly bloated
12:52:32 <ski> e.g. a record field, or a nested field, or the first element of a list, or the last element, &c.
12:53:01 <ski> rostayob : i'm not sure, i have done almost no web-y stuff
12:54:07 <ski> lenses are nice in that they compose : if you have a lens for the `b' field of an `a' datastructure, and a lense for the `c' field of that `b' data structure, you can compose them to get a lens for the `c' field inside that `b' part of the `a' data structure
12:54:33 <ski> a lens represents a "position", abastractly -- it is separate from the actual data structure
12:55:15 <roconnor> @type right
12:55:15 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
12:55:30 <ski> so if you have two lenses as above, you can first compose them, and then use that compound lens to access and modify the `c' field of all the `a's in a list (or whatever)
12:55:34 <t7> im not sure im sold, having everything in a StateT is kinda ugly
12:56:11 <ski> lenses are just a library (or several, rather), so there's no special syntax for them
12:56:36 <ski> but in some cases, it's much nicer dealing with them than with record syntax, which has limitations
12:56:36 <t7> (im only going on the examples on the hackage page)
13:07:52 <Taneb> Well, I've just went through my family tree program/library thing and changed all the type Person = (HashMap Text Text, Int, Int, IntSet) to Person = (Text, Sex, HashMap Text Text, (Int, Int, IntSet))
13:08:08 <everythingWorks> what smiley is this: \o/
13:08:16 <everythingWorks> a guy throwing up his hands?
13:08:19 <ben> yeah
13:08:23 <byorgey> everythingWorks: that means "hooray" as if... yes, exactly
13:08:39 <everythingWorks> :D
13:08:46 <ben> It's constructed from the high-five smilies, o/ \o
13:08:48 <byorgey> Taneb: I recommend using named data types rather than big tuples
13:09:11 <Taneb> byorgey, I don't really feel like defining the Aeson instances
13:09:29 <byorgey> Taneb: aha. but Aeson provides instances for tuples?
13:09:33 <Taneb> Yep
13:09:58 <byorgey> Taneb: that is probably the first legitimate reason to use a five-tuple I have ever heard.
13:10:02 * ski odly wonders whether `Aeson' provides a way to derive the instances
13:10:10 <Taneb> Four tuple with an inner three tuple
13:10:18 <Enigmagic> Taneb: if you're on 7.2 or 7.4 you can use the Generic instance for FromJSON/ToJSON
13:10:24 <Enigmagic> and have GHC derive Generic for you
13:10:30 <Taneb> I could do
13:10:32 <byorgey> hopefully someday generic programming technology will be common enough that libraries will provide mechanisms for automatically deriving instances of type classes they provide.
13:10:52 <byorgey> oh! it does!
13:11:11 <byorgey> \o/
13:11:14 <Taneb> I don't really know much about Template Haskell or Generic
13:11:47 <Enigmagic> Taneb: https://github.com/bos/aeson/blob/master/examples/Generic.hs
13:12:11 <byorgey> you shouldn't need to know much, if anything, about either one just to make use of it.
13:13:11 <tgeeky> byorgey: I think I should write a blog post about how one should be -damn- impressed and humbled to be using a language with a 'deriving' keyword in it
13:13:48 <monochrom> you are still better off with declaring "data Person = P { pf1::Text, ... }", if only for the benefit of field selectors pf1 etc
13:13:52 <morphles> It seems FranTk is dead?
13:14:07 <byorgey> tgeeky: yeah, the ideas of algebraic data types + generic programming together are really powerful.
13:15:24 <tgeeky> byorgey: yeah. I think the majesty of those features (and really, all of these new classes that have popped up in the last few years) are underappreciated by us a little bit.
13:15:49 <byorgey> I'm not sure what you mean by underappreciated
13:15:52 <tgeeky> it's hard to imagine a scripting language like Ruby or Python or ..., having a keyword which automatically builds code structure for you
13:16:09 <mauke> hahaha
13:16:19 <tgeeky> and expecting it to work
13:16:24 <mauke> guess what perl programmers routinely do
13:16:34 <tgeeky> mauke: I didn't list perl on purpose :o
13:16:54 <tgeeky> i've seen the dogfooding done by perl desciples.
13:18:09 <byorgey> if by "underappreciated" you mean "we are not constantly in awe", well, of course not.  No one can live that way.  If I was always properly "appreciating" everything I should be in awe of I would just sit in one place with my mouth hanging open amist a puddle of drool.
13:18:24 <tgeeky> byorgey: oh, you don't do that? :o
13:18:29 <byorgey> But a few minutes of that every now and then is always good =)
13:18:40 <monochrom> I don't know what perl programmers routinely do
13:19:52 <mauke> build code from code
13:20:02 <byorgey> tgeeky: all of which is to say, a blog post inciting people's sense of amazement would be wonderful.
13:20:42 * monochrom 's expression of awe is "this is evil"
13:21:49 <tgeeky> well, we know we're not sending monochrom out in our first time machine. We don't need any more people in awe of Hitler.
13:24:04 <Peaker> what do people mean in Haskell context by "generic programming"? Walking over reified ADT's in code?
13:24:30 <tgeeky> Peaker: and reifying them?
13:24:54 <sipa> Peaker: GADTs maybe?
13:24:57 <byorgey> Peaker: no, usually it refers to writing programs that work over the *structure* of types (units, sums, products, etc.)
13:25:29 <Peaker> byorgey: ah, that's what I meant (but perhaps not what I said)
13:25:33 <alpounet> Peaker, you'll have the most common approaches in these papers I think: http://www.haskell.org/haskellwiki/Research_papers/Generics
13:26:12 <byorgey> Peaker: oh, for some reason I thought you meant working with code reified as an ADT (a la Template Haskell)
13:26:21 <byorgey> but that isn't what you said either =)
13:26:41 <tgeeky> ... and that's *technically* correct, which is the best kind of correct.
13:27:10 <Peaker> I don't like the SYB approach -- it works on things like "all data with such and such type in an ADT" which is conceptually meaningless -- and can probably easily encode senseless transformations
13:27:50 <monochrom> I don't want to go through a time machine to the past. I don't want to go back to a time when Haskell was not widely available.
13:28:03 <ski> Peaker : yeah, or create mistakes/bugs easliy
13:30:19 <notrusty> `cabal install hoogle` gives me:  <command line>: cannot satisfy -package-id cmdargs-0.9.3-6290a305e97008521629e53413800b1f:
13:30:19 <notrusty>     cmdargs-0.9.3-6290a305e97008521629e53413800b1f is unusable due to missing or recursive dependencies:
13:30:41 <Taneb> Well, turns out I'm on GHC 7.04
13:31:11 <andares> hey, I'm trying to write a function to factor a number into prime factors.
13:31:16 <byorgey> notrusty: looks like you should reinstall cmdargs.
13:31:28 <andares> and I need to be able to extract the value from Maybe.
13:31:30 <notrusty> byorgey, already did, and process which it said was a broken dep
13:31:37 <andares> hold on, maybe I'll just hpaste it.
13:31:47 <Taneb> andares: Data.Maybe.fromMaybe?
13:31:56 <andares> ..d'oh. thanks.
13:32:03 <byorgey> andares: you can do a 'case' on the Maybe value, or use a function like 'maybe' or 'fromMaybe'
13:32:15 <ski> andares : `case' or `maybe' or ordinary pattern-matching in the head of defining equations (possibly in a helper function) ?
13:32:17 <notrusty> no broken packages...
13:32:23 <byorgey> andares: note that there is not necessarily a value to be extracted.  You must deal with the Nothing case somehow.
13:32:37 <andares> indeed, I was using a case, but it seems inelegant.
13:33:10 <bgamari> Is there a reason why FGL doesn't provide functor instances for its graphs?
13:33:16 <byorgey> notrusty: do you get that error message right away after typing 'cabal install hoogle'?
13:33:35 <byorgey> notrusty: it looks like it is complaining about some package that was already built against an older version of cmdargs which is now broken
13:33:43 <bgamari> It seems like you could have NodeWise and EdgeWise newtypes, and make Graph gr => NodeWise gr a functor
13:33:55 <notrusty> byorgey, it calculates dependencies, but that error comes up pretty quick
13:34:04 <bgamari> Moreover, you could do the same with foldable
13:34:48 <bgamari> and given Nodes have an Ord instance (being Integers), you could even give it a traversable instance
13:35:00 <bgamari> although perhaps that's a bit sketchy
13:35:41 <bgamari> On the whole, I've been quite surprised by how un-Haskellish FGL seems
13:36:07 <bgamari> admittedly it's an old library, but it's surprising there hasn't been anything new come in to fill the void
13:36:30 <dskippy1> I am having a hard time with the Windows cabal. I have installed GD, the graphics library on my machine. Cabal still says I am missing the foreign libraries to "cabal install gd" and suggests that I use "--extra-include-dirs" but adding that to the command is an invalid flag
13:37:30 <andares> byorgey: is there a function that will just throw an exception if I extract something from a Nothing?
13:37:37 <andares> I already handle the nothing case.
13:38:00 <Jafet> > fromJust Nothing
13:38:01 <lambdabot>   *Exception: Maybe.fromJust: Nothing
13:38:08 <andares> ooh
13:38:08 <byorgey> andares: there is, but you should not use it.
13:38:28 <byorgey> andares: at the place where you handle the nothing case you should already extract the value inside the Just.
13:38:28 <ski> @type fromMaybe
13:38:29 <lambdabot> forall a. a -> Maybe a -> a
13:38:44 <andares> byorgey: huh?
13:38:48 <byorgey> andares: don't just do a boolean test and then forget what you already know, and then have to re-extract from the Just later.
13:38:50 <ski> > fromMaybe (error "error in function `foo'") Nothing
13:38:51 <lambdabot>   *Exception: error in function `foo'
13:39:05 <byorgey> andares: sorry, I guess I'm not explaining this very well.  Do you have some code you can paste?
13:39:15 <ski> andares : better to use `fromMaybe' as above, if you must
13:39:28 <hpaste> andares pasted ‚Äúfactor‚Äù at http://hpaste.org/65203
13:39:36 <andares> byorgey: certainly! here you go.
13:39:44 <Jafet> Insert memetic boolean blindness link here
13:39:49 <byorgey> andares: right, don't check for equality with Nothing.
13:39:59 <byorgey> andares: do a case on f.
13:40:16 <andares> byorgey: like case f of Nothing -> ...
13:40:20 <byorgey> andares: right.
13:40:32 <andares> okay. I didn't think my code would work with maybe of fromMaybe though.
13:40:33 <acowley> bgamari: There are so many choices when it comes to representing graphs that I think nobody has really tried to make a canonical library that will satisfy all users. FGL is more an (successful) attempt at a graph rep. that is functional in style.
13:40:43 <byorgey> andares: if you just check for equality, in the case where f is not Nothing, *you* now know that f isn't Nothing but the compiler does not.
13:40:44 <andares> *or fromMaybe
13:41:02 <bgamari> acowley: I can see that might be true
13:41:24 <byorgey> andares: factors n = maybe n (: factors r)
13:41:30 <bgamari> acowley: I guess some folks tried to rewrite fgl at some point (source: http://www.haskell.org/haskellwiki/Libraries/WhenToRewriteOrRename)
13:41:37 <bgamari> Did this ever happen?
13:41:38 <byorgey> andares: I mean,  factors n = maybe n (: factors r) f  where ...
13:41:46 <andares> ah, huh.
13:41:59 <acowley> bgamari: I do wish there was something else, though. I use fgl for light things, but always have to pore over the haddocks, and then I go and use arrays and other nonsense for things that have to be faster.
13:42:33 <bgamari> acowley: I'm glad someone else agree here
13:42:35 <bgamari> agrees*
13:42:36 <acowley> bgamari: this was ivanm's work, right?
13:42:39 <Taneb> Heh, my solution to the Graph problem was likely the least Haskelly of all
13:43:08 <andares> byorgey: would you have any idea of why it complains about an infinite type where it adds to the list?
13:43:09 <Taneb> data Node a = Node a [IORef (Node a)]
13:43:32 <bgamari> acowley: It looks like it: http://ivanmiljenovic.wordpress.com/2010/06/12/pre-announce-for-the-new-fgl/
13:43:44 <acowley> bgamari: my understanding is that some of his attempts at a large-scale rething ran into some significant architectural complexity burdens, so he's since just focused on maintaining fgl.
13:43:50 <acowley> s/rething/rethink
13:44:55 <notrusty> hmm, looks like the only cmdargs in my dep tree is already 0.9.3...
13:45:08 <byorgey> andares: you can't do   r = n `mod` f   if f has a Maybe type
13:45:15 <andares> oh, of course. d'oh.
13:45:23 <andares> huh, this code is looking increasingly uglier.
13:45:43 <bgamari> acowley: Yep, it seems a rewrite would be a major undertaking but the only reasonable way forward
13:45:46 <andares> although I bet I could attach the where to one of the cases.
13:46:50 <byorgey> andares: you could say   maybe n (\f' -> f' : factors r (n `mod` f')) f
13:47:06 <byorgey> andares: since you can only do the division by f once you know that f is not Nothing
13:47:17 <byorgey> ah, sorry, delete that r
13:47:22 <byorgey> factors (n `mod` f')
13:47:50 <TheLemonMan> a liftIO in a monadless function shouldnt just return the content ?
13:48:02 <byorgey> andares: anyway, there are a lot of different ways to do this.  I recommend continuing to play around with it.
13:48:14 <byorgey> see if you can write three fundamentally different solutions.
13:48:36 <andares> byorgey: there do seem to be a lot of ways. I'm still getting infinite type errors though, oddly.
13:48:59 <lispy> restarting irssi feels like rebooting my computer
13:49:05 <hpaste> andares pasted ‚Äúmore factors‚Äù at http://hpaste.org/65204
13:49:24 <byorgey> andares: note you can also paste modifications to the code as annotations on the original paste
13:49:31 <andares> byorgey: ah, thanks.
13:49:37 <byorgey> makes it easier to compare versions
13:50:11 <hpc> lispy: haha, it really does
13:51:12 <byorgey> andares: what should the type of factors be?
13:51:19 <andares> anyway, it says the error is in the first argument of (:), which means k is infinite, which means my implementation of first is bugged? I'm not sure.
13:51:27 <andares> factors :: Int -> [Int]
13:51:35 <andares> ‚Ä¶oh! concat
13:51:36 <byorgey> andares: no, it's talking about an infinite type, not an infinite value
13:51:50 <jtobin> anyone have any advice on iterating a monadic step function?  trying to code up a simple metropolis sampler.
13:52:11 <tgeeky> jtobin: do it ... <puts on shades> ... one step at a time.
13:52:17 <byorgey> andares: by the way, I strongly recommend explicitly giving type signatures to your top-level functions
13:52:40 <notrusty> ah, i have two copies of process-1.1.0.1 installed, could that cause my problem?
13:52:40 <byorgey> andares: for example, if you put factors :: Int -> [Int]  above your implementation I think you will get a much easier-to-understand error.
13:52:45 * jtobin cues the CSI opening
13:52:47 <acowley> bgamari: One thing that I think makes it difficult is that a large chunk of the best work on graph-based algorithms relies heavily on pointer manipulation to perform little local surgeries on a graph with very modest algorithmic complexity. Then another large chunk of the best work leverages an adjacency matrix representation to bring various highly optimized linear algebra algorithms to bear. Then we've got us FP'ers with our
13:52:48 <acowley>  inductive graphs that allow easy snapshotting, but there's not as much compelling work out there that leans on that capability.
13:52:53 <byorgey> notrusty: yes, that is very bad
13:53:05 <byorgey> notrusty: try unregistering the one in your user DB
13:53:16 <andares> I was wondering why the error messages were rather confusing.
13:53:55 <jtobin> i've tried both wrapping up the parameter and generator as StateT Double (State StdGen) Double, then using variations of evalState, replicateM, etc.
13:54:01 <byorgey> andares: when you give a type signature, GHC can tell you how what you wrote does not match it.  If you don't give a type signature, GHC tries very hard to figure out *some* type signature which will make it work.  But it may be nothing like what you had in mind.
13:54:27 <jtobin> then i switched to just trying to `apply' the step function, as one would using iterate, when the step is just State StdGen Double
13:54:31 <jtobin> haven't had any success
13:54:44 <acowley> jtobin: how about the http://hackage.haskell.org/package/monadlist-0.0.2 package?
13:55:56 <quintessence> jtobin: you may also want to take a look at http://hackage.haskell.org/package/MonadRandom
13:55:58 <ski> jtobin : you could easily write an `iterateMaybeM :: Monad m => (a -> m (Maybe a)) -> (a -> m [a])' or an `unfoldM :: Monad m => (s -> m (Maybe (a,s))) -> (s -> m [a])', if you wanted to
13:56:28 <jtobin> acowley: i had looked into iteratee and pipe, but missed that one.  thx
13:57:17 <jtobin> ski: sure, just guessing there must be some existing way to go about it.
13:57:25 <ski> jtobin : in case you just want to iterate it a definite number of times, there's `replicateM'
13:57:44 <ski> jtobin : maybe some of those two other operations are already written, somewhere ..
13:57:50 <jtobin> ski: yes, replicateM seems not to work though.  or maybe it's just the way i've got it coded
13:57:52 <ski> @type replicateM
13:57:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
13:57:57 <danharaj> you know, considering how often fromIntegral can show up, I'm surprised Prelude doesn't have a short alias for it.
13:58:08 <bgamari> acowley: Fair enough
13:58:30 <ski> danharaj : i suppose you can always define one, locally
13:58:41 <danharaj> ski: yeah, I sometimes do, but really I can't be the only one who does that.
13:58:56 * ski has done that, a few times, as well
13:58:58 <jtobin> ski: when i tried replicateM with some evalStates on the StateT Double (State StdGen) function, i get output like this
13:59:12 <jtobin> [56.681788708890174,47.32610735130686,50.80851035519698,5.0,5.0,5.0,52.62695314322212,5.0]
13:59:47 <ski> danharaj : though it could maybe be argued that this is syntactic salt, suggesting that you attempt to rethink your code to not need it -- of course, this isn't always valid, just commonly valid for newbie code
13:59:48 <jtobin> ski: notice how the 5.0 (the initial state) keeps popping back up when the metropolis step rejects a proposal
14:00:12 <acowley> danharaj: I have defined "fi" many, many times
14:00:14 <ski> jtobin : how are you calling `replicateM' ?
14:00:21 <jtobin> runIdentity $ runStateT (replicateM numIterations $ execStateT (stepForward stats eps numLeapFrogs) theta0) gen
14:00:44 <jtobin> also tried fumbling around by moving the replicateM to the outside runStateT, but that seems misguided :)
14:01:15 <ski> jtobin : hm, are you sure you want `replicateM' outside the `execStateT' (keep in mind i have no idea what you're trying to achieve)
14:01:19 <ski> ?
14:02:50 <ski>   (runIdentity . (`runStateT`gen) . (`execStateT` theta0) . replicateM numIterations) (stepForward stats eps numLeapFrogs)
14:02:53 <jtobin> ski: hmm, i'm guessing not eh.  let me take a look..
14:02:53 <ski> mayhaps something like that
14:03:08 <ski> (that may be a type error, depending on the details of your code)
14:03:34 <jtobin> ski: cheers, it should be a fine place to start anyway.  i'll muck around with that a bit.
14:03:37 <jtobin> ski: thx
14:04:05 <notrusty> fixed, thanks byorgey
14:04:15 <byorgey> notrusty: excellent
14:04:42 <notrusty> 'directory' twice, too.  wonder how that happened
14:05:27 <bgamari> acowley: Honestly, performance isn't really even all that important to me; I'd just like a library with a sane interface
14:05:53 <bgamari> acowley: fgl makes even the simple task of filtering nodes unnecessarily difficult
14:08:59 <ski> jtobin : yw
14:11:52 <newhaskeller> hi, any suggestions for tab-completion in vi?
14:12:22 <acowley> bgamari: That's a fair point. We should probably ask ivanm for some reflections on undertaking this kind of thing in light of his experience.
14:14:30 <lispy> newhaskeller: I've been hearing godo things about ghc-mod but I didn't try it yet
14:14:47 <ski> newhaskeller : <http://www.haskell.org/haskellwiki/Editors> seems to mention SHIM ("Superior Haskell Interaction Mode") <http://www.vim.org/scripts/script.php?script_id=2356> re vim -- haven't tried it, so doesn't know whether it's good
14:14:53 <lispy> newhaskeller: http://www.mew.org/~kazu/proj/ghc-mod/en/
14:16:29 <newhaskeller> ski, lispy: thanks, Ill check them out!
14:17:09 <monochrom> ghc-mod is for emacs, isn't it?
14:17:38 <RichyB> vim too.
14:17:50 <monochrom> nice
14:17:52 <lispy> it's for all the cool kinds
14:17:54 <RichyB> https://github.com/eagletmt/ghcmod-vim
14:17:55 <lispy> kids*
14:17:59 <acowley> ghc-mod exposed my emacs noobishness
14:18:21 <acowley> it changed up my usual emacs configuration and I couldn't figure out how to fix it
14:18:44 <lispy> hmm...that's not good
14:18:53 <RichyB> acowley, keep your .emacs in some kind of source code repository. darcs or git or whatever.
14:19:11 <acowley> no, no, sorry. I don't mean it did permanent damage.
14:19:27 <acowley> I mean that it changes a lot of key bindings and whatnot, some of which I'd have rather it didn't change.
14:20:02 <acowley> For example, I use C-n and C-p (among others) to navigate quite often, but with ghc-mod enabled these motions extended a selection
14:20:07 <RichyB> Use SCM for your dotfiles anyway. :)
14:20:21 <acowley> RichyB: yes, it's good advice
14:20:24 <RichyB> acowley, wat?
14:20:31 <RichyB> Taking C-n and C-p away sounds inhumane.
14:20:57 <acowley> I mean, if I was at the front of line 3, and hit C-p, I'd get a highlighted region containing line 2
14:21:04 <acowley> RichyB: it also affected M-v
14:21:09 <acowley> but I think C-v was left alone
14:21:31 <andares> hey, is there any function that gets all possible sublists from a list?
14:21:32 <acowley> But I found that whole arrangement unusable. I kept accidentally deleting huge swathes of my file.
14:21:53 <RichyB> Yikes.
14:22:09 <andares> like for [2,2,3] would give [[2],[2],[3],[2,2],[2,2],[2,3],[2,2,3]]?
14:22:19 <ski> acowley : contiguous sublists, or sublists created by omitting some elements, or permutations or combinations ?
14:22:20 <TheLemonMan> so, <- implicitly promises that the do block will return something of the same monad
14:22:27 <TheLemonMan> how do i escape from the io monad ?
14:22:35 <mauke> you don't
14:22:38 <hpc> TheLemonMan: you don't
14:22:59 <hpc> TheLemonMan: a more helpful answer would be, "bring other stuff into the IO monad"
14:22:59 <andares> ski: so all possible combinations, I think.
14:23:02 <acowley> RichyB: while I had it active, I did kind of like the instantaneous hlint feedback even if the syntax highlighting had crossed over into "gaudy" territory at that point.
14:23:08 <andares> there should be 2^n of these.
14:23:10 <RichyB> andares, filterM (const [False, True])
14:23:11 <hpc> :t fmap reverse getLine -- like so
14:23:12 <lambdabot> IO [Char]
14:23:16 <ski> > filterM (const [False,True]) [2,2,3]
14:23:17 <lambdabot>   [[],[3],[2],[2,3],[2],[2,3],[2,2],[2,2,3]]
14:23:53 <acowley> I think that might be the best Haskell function.
14:23:55 <andares> ‚Ä¶ huh.
14:24:01 * andares tries to grok
14:24:27 <TheLemonMan> :O the main problem is that show doesnt like IO wrapped values
14:24:31 <mauke> s/const/return/ for extra fun
14:24:35 <ski> (andares : and no, this isn't combinations)
14:24:41 <mauke> TheLemonMan: that's not a problem and IO doesn't wrap values
14:24:46 <bgamari> acowley: Perhaps a message to haskell-libraries is in order
14:25:03 <ski> @quote /bin/ls
14:25:03 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:25:13 <ski> TheLemonMan ^
14:25:27 <acowley> bgamari: I think code is needed. People come to #haskell every once in a while complaining about the situation, so it's definitely an issue, but talk is cheap.
14:25:40 <bgamari> acowley: A fair point
14:25:41 <acowley> bgamari: it's also worth seeing if Data.Graph could support more operations that you want
14:26:05 <monochrom> TheLemonMan: if you describe the bigger picture of what job you're doing, some of us can show how to do it.
14:26:26 <acowley> bgamari: I think extending Data.Graph to support node filtering would require changing how it treats edges to avoid a full graph traversal on every removal.
14:26:32 <ski> andares : for each element, regardless of which element it is (the `const'), we nondeterministically decide ("we flip a coin", so to speak) whether to keep it or throw it away
14:26:36 <TheLemonMan> im trying to write a simple ls implementation just for learning purposes
14:27:02 <ski> andares : all the possibly ways of doing this is returned in the result list -- this is the list monad, which encodes (angelic) nondeterminism
14:27:08 <TheLemonMan> most of the times i find myself trapped into monads
14:27:53 <monochrom> alright, so supposedly you already use getDirectoryContents?
14:28:30 <andares> huh
14:28:33 <monochrom> do { x <- getDirectoryContents "."; mapM_ putStrLn x } is a good beginning
14:29:27 <monochrom> be sure to check the types of the above for maximum learning
14:29:56 <ski> andares : you agree that if we had filtered the list, randomly flipping a coin to decide for each element whether to keep it or not, then we'd get a random sublist of the original list, right ?
14:30:30 <andares> ski: I mean, I get it conceptually, I just don't understand how it all works.
14:30:34 <andares> like what is const?
14:30:51 <Saizan> @src const
14:30:52 <lambdabot> const x _ = x
14:31:03 <newhaskeller> i tried to install gtk2hs-buildtools  and I get the error: http://pastebin.com/7Rq44Zdn
14:31:05 <Jafet> monochrom: wizard a -> it -> did
14:31:05 <mauke> The paste 7Rq44Zdn has been copied to http://hpaste.org/65205
14:31:11 <andares> haha
14:31:17 <ski> andares : the list monad is a bit like this, except that instead of randomly deciding to keep (`True') or throw away (`False') each element, it determines the consequences of each possibly such choice, takes over all the choices made for all the elements -- and collects the possible result lists in a single resulting list)
14:31:24 <newhaskeller> I was sure to run an update before it
14:31:25 <TheLemonMan> i went a step ahead and wrote a function that checks if the path is a folder and adds [] around it if it is
14:31:29 <andares> @src filterM
14:31:29 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:31:36 <Saizan> newhaskeller: cabal install alex
14:31:38 <andares> I've never claimed that title.
14:31:45 <TheLemonMan> its just a do block with doesDirectoryExist and an if else
14:31:53 <Saizan> newhaskeller: and make sure $HOME/.cabal/bin is in your $PATH
14:31:58 <ski> andares : also note that writing code with `do' in the list monad is very similar to using list comprehensions (or using `concatMap',`concat',`map',`filter', if you prefer)
14:31:59 <hpc> andares: no, that was an order; you have to call yourself a rocket scientist now
14:32:05 <hpc> ;)
14:32:18 <andares|rocketsc> huh, nick cutoff.
14:33:39 <Mathnerd314> http://hackage.haskell.org/packages/archive/acme-realworld/0.1.1/doc/html/Acme-RealWorld.html - shouldn't hypothetically :: IO a -> a ?
14:33:45 <nolrai> Yo, so if I want a FIFO list what are the options?
14:34:19 <ski> > do x <- [0 .. 49]; y <- [0 .. 9]; guard (x == y*y); return (x,y)
14:34:20 <lambdabot>   [(0,0),(1,1),(4,2),(9,3),(16,4),(25,5),(36,6),(49,7)]
14:34:25 <ski> @undo do x <- [0 .. 49]; y <- [0 .. 9]; guard (x == y*y); return (x,y)
14:34:25 <lambdabot> [0 .. 49] >>= \ x -> [0 .. 9] >>= \ y -> guard (x == y * y) >> return (x, y)
14:34:37 <andares|rocketsc> huh, guard is interesting.
14:34:44 <ski> @undo [(x,y) | x <- [0 .. 49] , y <- [0 .. 9] , x == y*y]
14:34:45 <lambdabot> concatMap (\ x -> concatMap (\ y -> if x == y * y then [(x, y)] else []) [0 .. 9]) [0 .. 49]
14:34:51 <ski> > [(x,y) | x <- [0 .. 49] , y <- [0 .. 9] , x == y*y]
14:34:52 <lambdabot>   [(0,0),(1,1),(4,2),(9,3),(16,4),(25,5),(36,6),(49,7)]
14:35:02 <newhaskeller> Saizan, I get the following error for alex http://pastebin.com/EgRkWG07
14:35:03 <zhulikas> @hoogle pure
14:35:03 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
14:35:03 <lambdabot> package pure-fft
14:35:04 <lambdabot> package pure-priority-queue
14:35:04 <mauke> The paste EgRkWG07 has been copied to http://hpaste.org/65207
14:36:01 <acowley> nolrai: You could use Data.Sequence or the dequeue package among other options.
14:36:22 <andares> anyway, thanks ski and byorgey.
14:36:31 <nolrai> Aw, those sound familiar. Thanks!
14:37:03 <Saizan> newhaskeller: which version of ghc are you using?
14:37:12 <nolrai>  /s/Aw/Ah
14:37:24 <ski> > filter (\(x,y) -> x == y*y) (concatMap (\x -> map ((,) x) [0 .. 9]) [0 .. 49])  -- might be more idiomatic that the above `undo' expansions
14:37:25 <lambdabot>   [(0,0),(1,1),(4,2),(9,3),(16,4),(25,5),(36,6),(49,7)]
14:37:35 <ski> andares : yw
14:38:11 <ski> (assuming one wanted to avoid `do' and list comprehensions, i.e.)
14:38:33 <newhaskeller> Saizan, 6.12.1
14:38:46 <monochrom> avoiding both do-notation and list comprehension is rather fundamentalist :)
14:39:14 <ski> yeah -- the point here was what one could write *apart* from those two choices :)
14:39:29 <Saizan> newhaskeller: try cabal install alex-2.*
14:39:37 <monochrom> write ghc core code by hand! :)
14:39:39 <ski> (as a means to try to explain better what they, and their expansions do)
14:39:43 * ski grins
14:41:03 <andares> hey, is there a way to do dynamic programming-style problems in Haskell?
14:41:17 <andares> my traditional technique of keeping a list won't work, obviously.
14:41:24 <mauke> make a recursive array?
14:41:41 <Mathnerd314> monochrom: GHC Core has no type inference....
14:41:44 <andares> er, memo-izing, sorry. but yeah, that will actually do fine. d'oh
14:42:35 <monochrom> damn right, do that by hand, too!
14:43:14 <ski> andares : making cyclic data structures (lists, arrays, other stuff), is one common and nice method of doing dynamic programming in Haskell
14:43:15 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example has examples
14:43:41 <Mathnerd314> monochrom: why not use assembly? what makes GHC Core better?
14:43:45 <ski> (i.e. *cyclically defined* ones)
14:44:06 <ski> Mathnerd314 : easier to reason about ?
14:44:15 <monochrom> assembly would be fine if 100 registers were available
14:44:38 <Mathnerd314> also, there's no way to compile Core files...
14:44:48 <ski> andares : were you saying you *want* memoizing, or that you *don't* want it ?
14:44:58 <newhaskeller> Saizan, cabal list alex only returns alex and alex-meta (plus HaLex)
14:45:15 <andares> I was thinking I'd use memoizing instead of an array-style DP, but I think the latter would be better in Haskell.
14:45:27 <Saizan> newhaskeller: the -2.* part is the version
14:45:39 <ski> andares : well, note that when i say arrays, i mean of course *immutable* arrays :)
14:45:54 <andares> of course :)
14:46:08 <acowley> Mathnerd314: You have to encrypt your Core programs as Haskell code before compiling.
14:46:09 <newhaskeller> Saizan, that gives an unrecognized target
14:46:12 <Saizan> newhaskeller: though it's not the right syntax sorry
14:46:14 <Mathnerd314> ski: not really, you'll be too swamped with type signatures and namespaces to see the code
14:46:18 <ski> (which would rely on the elements being lazy thunks, which is a form of memoizing)
14:46:21 <Saizan> newhaskeller: cabal install "alex < 3"
14:46:34 <ski> Mathnerd314 : i meant as compared to assembler
14:46:56 <newhaskeller> Saizan, cool. thanks!
14:47:11 <Mathnerd314> acowley: seems pointless. why not just write in Haskell in the first place?
14:47:26 <acowley> Mathnerd314: out of concern for writing the wrong Haskell
14:47:55 <monochrom> ghc core is still easier to write than x86 assembly. I mean come on, 6 registers and they're assymetric and special-purpose in the 21st century?
14:48:28 * ski thinks 680x0 is relatively nice, for assembly code
14:48:38 <pdxleif> Or ARM
14:48:58 <monochrom> I wrote multi-precision division in x86 assembly. I'm sorry but it doesn't even have enough registers for loop counters.
14:48:59 <shachaf> monochrom: In the 21st century you get eight extra registers. :-)
14:49:19 <monochrom> 680x0 is symmetric enough, yes
14:49:28 <ski> register windows as in Sparc also sounds nice, though i've not tried it
14:49:54 <monochrom> anyway I hate special-purpose register set with a passion
14:50:19 <monochrom> to the point I'm ready to say writing Turing machines is still easier than x86 shit.
14:50:20 <ski> (6502 otoh is a bit austere with one accumulator register, and two index registers)
14:50:59 * ski is inclined to agree with monochrom
14:51:27 <Mathnerd314> ok, use LLVM.
14:51:41 <Mathnerd314> close enough to assembly
14:51:54 <monochrom> yeah, that should be nice enough
14:52:26 * ski idly wonders how easily LLVM could be typed
14:52:42 <c_wraith> ski: with or without capslock?
14:52:50 <monochrom> but with ghc core I can get eagerness and laziness where I want them with almost zero effort. with LLVM I only get eagerness with zero effort.
14:53:16 <ski> c_wraith : well, with or without inference might perhaps be a more appropriate question
14:53:32 <c_wraith> only if you don't misinterpret "typing"
14:53:45 * ski agrees
14:53:53 <monochrom> haha
14:56:09 * ski . o O ( "GJ: Making Java easier to type, and easier to type" <http://lampwww.epfl.ch/gj/>,<http://www.cs.umd.edu/class/spring2001/cmsc433-0101/gj-slides.pdf> )
14:56:24 <monochrom> haha
14:57:46 <cmccann> ah, so type inference is that thing word processors do where they helpfully replace what you typed with what they think you meant to type
14:58:15 <monochrom> I get that with LibreOffice :)
15:02:45 <hpc> cmccann: i turn that off; it rejects some well-formed typos
15:03:02 <c_wraith> hpc: like intentional use of "teh"?
15:03:06 * ski . o O ( <http://en.wikipedia.org/wiki/WordPerfect> )
15:03:09 <Mathnerd314> monochrom: you have no way to compile ghc core. you can compile (easily) LLVM
15:03:18 <hpc> ski: oh man, blast from the past
15:04:04 <hpc> o.o, last stable release 2010
15:04:27 <cmccann> hpc, yes. also, I don't think english terms have principal types, generally.
15:05:35 * monochrom used wordperfect around 1990
15:06:06 <edwardk> preflex: xseen ktklam6
15:06:06 <preflex>  Sorry, I haven't seen ktklam6
15:06:10 <hpc> lol, i didn't even exist until 1990 and i still used it
15:06:20 <hpc> (not in 1990)
15:06:30 <monochrom> haha
15:07:03 <newhaskeller> another noob question, what do I do when ghci cant load a module?
15:07:10 <newhaskeller> for example, right now:     Could not find module `Text.Regex':
15:07:14 <ski> (some person were saying they liked it better than Word and *Office)
15:07:17 <hpc> newhaskeller: how are you loading it?
15:07:18 <monochrom> install more packages
15:07:24 <hpc> also what monochrom said
15:07:32 <newhaskeller> monochrom, import Text.Regex
15:07:32 <newhaskeller> ?
15:07:42 <hpc> newhaskeller: yep, need to install it
15:07:46 <hpc> @hoogle Text.Regex
15:07:46 <lambdabot> Text.Regex.Posix.Wrap data Regex
15:07:46 <lambdabot> Text.Regex.Posix.String data Regex
15:07:46 <lambdabot> Text.Regex.Posix.Sequence data Regex
15:07:49 <monochrom> actually, modules in packages are not supposed to be "loaded" by you, i.e., not supposed to be ":load"
15:07:59 <newhaskeller> what packages to install?
15:08:26 <hpc> newhaskeller: there's a couple of choices it seems
15:08:38 <hpc> and im not gonna pretend to know which regex package is best
15:08:54 <monochrom> I guess we should first find one whether the package is installed or not
15:09:04 <hpc> http://www.haskell.org/haskellwiki/Applications_and_libraries/Data_structures#Regular_expressions
15:09:16 <dmwit> Does template-haskell come with GHC?
15:09:17 <ski> @quote regex
15:09:17 <lambdabot> pjscott says: If you really want to see something ridiculous, try looking at the auto-generated library documentation for anything involving regular expressions. The type declarations in Text.Regex.
15:09:17 <lambdabot> TDFA are like something H. P. Lovecraft might write about.
15:09:28 <monochrom> what does "ghc-pkg list" show? does it show a package name like "regex"?
15:09:37 <ski> @where uninstall
15:09:38 <lambdabot> I know nothing about uninstall.
15:09:49 <monochrom> template-haskell comes with GHC
15:09:55 <dmwit> thanks
15:11:22 <ski> @where+ uninstall Uninstall, what's that ? -- Also see <http://www.vex.net/~trebla/haskell/sicp.xhtml#remove>
15:11:22 <lambdabot> Nice!
15:11:31 <monochrom> yikes
15:12:41 <ski> (you're free to change it to anything you deem more appropriate)
15:13:04 <monochrom> oh, it's fine, I'm just awed by my own fame :)
15:13:15 <ski> (:
15:13:17 <monochrom> s/awed by/in awe of/
15:15:56 <newhaskeller> monochrom, here is the result of "ghc-pkg list | grep regex"
15:15:57 <newhaskeller>     regex-base-0.93.2
15:15:57 <newhaskeller>     regex-posix-0.95.1
15:15:57 <newhaskeller>     regex-tdfa-1.1.8
15:16:13 <newhaskeller> (i just installed regex posix)
15:16:15 <monochrom> ok, you have the relevant packages. ":module + Text.Regex"
15:16:51 <newhaskeller> it cannot find the module
15:17:18 <bgamari> acowley: The problem I have with Data.Graph is the lack of annotations
15:17:26 <monochrom> oh, sorry, Text.Regex belongs to regex-compat or something
15:17:31 <bgamari> I suppose tuples work in the case of nodes
15:17:41 <bgamari> but edge annotations aren't at all natural
15:17:58 <dmwit> ":m + Text.Regex.TDFA", perhaps?
15:18:02 <bgamari> acowley: This was the whole reason for my starting to use Data.Graph
15:18:05 <dmwit> Dunno which thing you're trying to bring into scope.
15:19:32 <newhaskeller> monochrom,  that worked! thanks.
15:21:07 <pfn> hmm, interesting, how do I use hoogle to find something like a string splitting function?  like a -> [a] -> [[a]] ?
15:21:35 <monochrom> would this work?
15:21:42 <monochrom> @hoogle a -> [a] -> [[a]]
15:21:42 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:21:42 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
15:21:42 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
15:21:52 <pfn> yeah, it returns [a] at the end, not [[a]]
15:21:52 <monochrom> or swap the two parameters?
15:22:03 <dmwit> ?hoogle Eq a => a -> [a] -> [[a]]
15:22:03 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
15:22:03 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
15:22:03 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:22:16 <dmwit> anyway
15:22:23 <monochrom> @hoogle [a] -> a -> [[a]]
15:22:23 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:22:23 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
15:22:23 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
15:22:42 <dmwit> http://www.haskell.org/hoogle/?q=a+-%3E+%5Ba%5D+-%3E+%5B%5Ba%5D%5D+%2Bsplit
15:22:44 <monochrom> string splitting? we can be more specific
15:22:53 <newhaskeller> another noob question...
15:23:00 <monochrom> @hoogle Char -> [Char] -> [[Char]]
15:23:01 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:23:01 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
15:23:01 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
15:23:20 <newhaskeller> what is the difference between "runhaskell prog.hs" and "ghci prog.hs"
15:23:35 <monochrom> anyway, we happen to know that the "split" package on hackage is awesome
15:23:42 <dmwit> ?hackage split
15:23:43 <lambdabot> http://hackage.haskell.org/package/split
15:23:48 <newhaskeller> (the ghci one did not give a hello worls output while the other did)
15:24:05 <ski> `runhaskell' executes `main'
15:24:07 <dmwit> newhaskeller: The former runs a program. The latter doesn't, but lets you evaluate expressions as if all the definitions in the file had already been made.
15:24:08 <c_wraith> newhaskeller: the former interprets it as if it is a standalone program and runs it (interpreted).  The latter loads it in an interactive interpreter
15:25:21 <pfn> monochrom, yeah, still wrong
15:25:56 <pfn> maybe @hoogle Char -> String -> [String]
15:26:01 <pfn> er
15:26:11 <pfn> @hoogle Char -> String -> [String]
15:26:11 <lambdabot> Text.XHtml.Strict renderHtmlWithLanguage :: HTML html => String -> html -> String
15:26:12 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
15:26:12 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
15:26:38 <monochrom> lambdabot's hoogle doesn't know all that much
15:26:54 <monochrom> or it knows but doesn't show all in public
15:27:17 <ski> @hoogle (Char -> Bool) -> String -> [String]
15:27:17 <lambdabot> Network.URI escapeURIString :: (Char -> Bool) -> String -> String
15:27:17 <lambdabot> Network.URI escapeString :: String -> (Char -> Bool) -> String
15:27:17 <lambdabot> Network.URI escapeURIChar :: (Char -> Bool) -> Char -> String
15:27:21 <pfn> nothing shows up searching for that either
15:27:25 <ski> @hoogle+
15:27:25 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
15:27:25 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
15:27:25 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
15:27:28 <ski> mhm
15:27:47 <pfn> failing that, what's the string splitting function in haskell?
15:27:47 <pfn> heh
15:27:55 <pfn> either splitting on a character or a regex
15:27:58 <newhaskeller> so, if i get it right "ghci prog.hs " is equivalent to "ghci" then "Prelude> :l prog.hs"
15:28:04 <Botje> pfn: check Data.List.Split or Text.Regex
15:28:07 <c_wraith> newhaskeller: correct
15:28:10 <ski> have you checked the `split' package above yet ?
15:28:21 <pfn> what split package
15:28:23 <newhaskeller> ok. thanks all.
15:28:25 <pfn> oh
15:28:27 <ski> newhaskeller : no, `runhaskell' also executes `main'
15:28:28 <pfn> that link
15:28:41 <ski> newhaskeller : .. er, misread
15:28:50 <statusfailed> Is hmatrix the best option for matrices / linear algebra / etc. ?
15:33:26 <bgamari> acowley: Naturally, edwardk has a graphs library
15:33:37 <edwardk> of course
15:33:58 <edwardk> bgamari: building one for bayesian models now too, though thats more your schtick ;)
15:34:38 <edwardk> statusfailed: hmatrix is good for just getting stuff done, since you can link out to gsl through it.
15:36:42 <bgamari> edwardk: heh, you could say that
15:36:49 <bgamari> we're finishing up that paper as we speak
15:36:54 <edwardk> nice
15:37:18 <edwardk> bgamari: been playing with hamiltonian monte carlo a lot lately
15:37:34 <statusfailed> edwardk: thanks, I guess i'll stick with it then
15:37:42 <edwardk> in particular because it is a nice way for me to abuse AD
15:38:17 <bgamari> edwardk: very nice
15:39:03 <bgamari> edwardk: I'll admit, you've left my range of expertise
15:39:09 <edwardk> decided to start playing with graphics again for fun, and realized that nobody who does metropolis light transport uses any sampling techniques that were designed after 1998
15:39:10 <bgamari> edwardk: Is there code?
15:39:34 <lispy> heh
15:39:39 <lispy> edwardk: well put
15:39:50 <edwardk> i have a few gists of various metropolis hastings combinators lying around, haven't formulated a coherent api yet
15:39:59 <bgamari> How do annotations work in graphs
15:40:04 <lispy> edwardk: I was describing your ideas to a co-worker and the first thing he said was, "where is he going to publish?"
15:40:08 <bgamari> edwardk: I'd be interested to see what sort of interfaces you settle on
15:40:13 <edwardk> lispy: hah
15:40:32 <edwardk> lispy: i usually license rather than publish
15:40:41 <edwardk> ;)
15:40:48 <bgamari> edwardk: Although I'm still struggling on the nice interfaces/nice performance trade-off
15:41:02 <edwardk> my current approach is for code generation anyways
15:41:06 <lispy> edwardk: the student t light rendering algorithm :)
15:41:29 <bgamari> edwardk: I may go that way myself
15:41:32 <lispy> edwardk: That comment assumse you know the history of the student t distribution
15:41:35 <edwardk> so i have a bunch of simple implementations in haskell to make sure i get the right general feel for the api, then i'm looking at spitting out cuda
15:41:37 <edwardk> lispy: yep
15:41:38 <bgamari> it's getting difficult to justify the pain of the current approach
15:42:17 * lispy goes back to rooting around in the gcc sources
15:42:22 <edwardk> rather i should say spitting out a dsl that will spit out said cuda
15:42:46 <bgamari> edwardk: Ahh, but you have nice independence
15:42:59 <edwardk> in graphics?
15:43:03 <bgamari> Yes
15:43:09 <bgamari> Or do you not?
15:43:18 <edwardk> well, folks assume they do.
15:43:24 <edwardk> ;)
15:43:29 <bgamari> heh
15:44:03 <edwardk> but ultimately your angle of impact changes based on previous bounces, so there are quite a few cascading derivatives
15:44:40 <bgamari> ahh
15:44:41 <edwardk> and there are annoying |cos d theta| terms in all the lighting equations, which are usually not eliminated
15:45:01 <edwardk> so being able to 'rock' from one side of the cosine to the other using hamiltonian methods could pay off quite well
15:45:56 <cheater_> hi
15:46:09 <cheater_> is there something like regex but for trees rather than strings?
15:46:21 <edwardk> thats why i keep playing with riemann manifold hamiltonian and NUTS sampling, to see if i can tease out which will work better, the riemann manifold hamiltonian method also looks nice because of the structure of how the derivatives only feed forward
15:46:31 <bgamari> Any pointers on these "new tricks for annotated structures" used in graphs? (http://www.mail-archive.com/haskell-cafe@haskell.org/msg73509.html)
15:47:12 <edwardk> well, the idea at the time was to use a graph as a product comonad of the annotations/data and the graph structure, sharing a phantom type
15:47:36 <edwardk> i reorganized it somewhat, the graphs library is me switching form that comonadic graph structure to one that lives in a monad
15:48:44 <edwardk> then i bolted a bunch of boost graph library -like traversals on top, because i needed them at the time ;)
15:49:17 <bgamari> edwardk: ahhh, alright; so I take it that things are still a bit fluid?
15:49:45 <edwardk> well fluid in that i'm not entirely wedded to the api, but then i haven't touched it since august
15:50:11 <edwardk> ivanm had spent some time banging together alternate graph representations and algorithms, but I don't know if I have a patch from him yet
15:50:23 <edwardk> rather i'm pretty sure i don't.
15:50:36 <edwardk> i was going to use that to inform any future changes in the shape of that library
15:51:42 <stulli> z[5~/quit
15:51:57 <stulli> ups... well good night all :)
15:52:56 <newhaskeller> after a long stream of text, i get an exit failure when attempting to install package "gloss"
15:53:06 <edwardk> bgamari: anyways i can simulate the HMC step in a split mode, where i use the derivatives aussming you remain within all the same surfaces for the NUTS traversal, then check the real pdf for the final sample
15:53:28 <edwardk> this lets me exploit the nice smooth space, and still maintain detailed balance
15:54:58 <edwardk> HMC = the usual metropolis hastings sampling, except to define the proposal distribution you basically 'flick' the current sample on the surface of the log probability distribution, and simulate it moving along using hamiltonian mechanics
15:55:28 <byorgey> newhaskeller: the exit failure at the very end is not helpful, you need to look back through the stream of text to find the error.  alternatively, if you try 'cabal install gloss' again it will fail more quickly this time and you can see what the error is more easily.
15:55:30 <edwardk> NUTS = doing that until the simulated point starts to turn around using a fully tree-like construction
15:56:04 <edwardk> that way you don't need to pick a magic number of integration steps for the physics simulation used in each candidate proposal
15:56:09 <newhaskeller> Graphics/Gloss/Internals/Interface/Backend/GLUT.hs:126:15:
15:56:09 <newhaskeller>     Not in scope: `void'
15:56:09 <newhaskeller> cabal: Error: some packages failed to install:
15:56:09 <newhaskeller> gloss-1.6.2.1 failed during the building phase. The exception was:
15:56:09 <newhaskeller> ExitFailure 1
15:56:16 <edwardk> er s/fully/funny/
15:58:06 <bgamari> damn you aaai submission script
15:58:08 <byorgey> newhaskeller: what version of GHC do you have?
15:58:38 <edwardk> bgamari: its goal is to make you submit. ;) either by admitting your inferiority or submitting a manuscript. either way it wins ;)
15:59:04 <edwardk> strange game, the only way to way to win is not to play
15:59:14 <newhaskeller> byorgey, 6.12.1
15:59:57 <byorgey> newhaskeller: ah, that's why.  6.12.1 is fairly old, and the version of the 'base' library that comes with it did not have the 'void' function
16:00:06 <newhaskeller> k
16:00:08 <byorgey> newhaskeller: how did you install it?
16:00:16 <byorgey> GHC, that is
16:00:18 * hackagebot sendfile 0.7.5 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.7.5 (JeremyShaw)
16:00:33 <newhaskeller> byorgey, from the repos (I am using ubuntu lucid)
16:01:25 <bgamari> edwardk: hah
16:01:39 <bgamari> edwardk: Finally getting back to reading you discussion of HMC
16:02:22 <byorgey> newhaskeller: you may want to install the latest release of the Haskell Platform yourself, http://hackage.haskell.org/platform/
16:02:37 <byorgey> or perhaps upgrade ubuntu
16:02:44 <edwardk> bgamari: there are 3 hidden subproblems that come up in HMC, figuring out how big of a step size to use for the discrete approximation of the integral, determining how many steps to take, and determining 'how hard to flick'
16:02:48 <byorgey> oh, lucid is the LTS release
16:03:05 <newhaskeller> byorgey, thanks. ill install from hackage
16:03:43 <newhaskeller> (not upgrading Ubuntu, downgraded from all future versions because of unity/gnome3)
16:04:08 <edwardk> bgamari: NUTS provides answers for the first, the second and part of the third. "Riemann Manifold HMC" provides a good answer to the third, but at the cost of an expensive matrix inversion
16:04:33 <edwardk> that and it doesn't do discrete stuff at all, so its probably useless to you ;)
16:06:05 <acowley> I missed the hot graph talk :(
16:06:20 <acowley> my scrollback buffer is such a tease
16:06:37 <bgamari> edwardk: I see
16:06:48 <edwardk> bgamari: another reason its good is that i already need to calculate all those derivatives anyways for dealing with ray differentials in the first place ;)
16:07:15 <edwardk> otherwise when i hit a texture i have no idea what kind of sampling to do
16:08:09 <edwardk> acowley: http://tunes.org/~nef/logs/haskell/
16:09:05 <acowley> edwardk: I've been contemplating cooperative path planning (on a grid/graph) and have several notions that all seem to come with tremendous drawbacks. One is to compute individual paths, then fit splines to them, then use ad to push the spline control points around.
16:09:09 <bgamari> perhaps some day I'll finally sit down and write a ray-tracer
16:09:22 <bgamari> This is a right of passage I have yet to make
16:09:33 <edwardk> how many cooperative agents?
16:10:13 <acowley> edwardk: as many as I can support, really. I'd like to be able to handle at least 10 to begin with.
16:10:43 <edwardk> acowley: the ad approach actually could work rather well. if you swapped out the splines for circlines you could reduce the parameter space considerably and borrow the tricks from the train track dsl for much of it ;)
16:10:46 <Ralith> bgamari: it is easier than it sounds!
16:11:03 <pedr0> hi all
16:11:16 <edwardk> that and it could model plans where you walked in straight lines or turned on a circle with constant radius at all times
16:11:24 <acowley> edwardk: the intriguing aspect to the problem is that an initial, independent plan for each agent gives you quite a good heuristic for the cooperative case. You've also got these 3D trajectories through a 2D map, but if you naively do graph exploration you immediately run into exponential blowup.
16:12:04 <acowley> edwardk: ah, we call thouse Dubins curves
16:13:02 <edwardk> i did a quick write up for the dsl workshop last summer and included code. but i wasn't trying to path plan with them, just describe tracks
16:13:34 <acowley> Well the splines is somewhat orthogonal anyway. Considering the polylines you get from A* is a natural starting point, but if you make each visited node a control point for the optimization, it seems like too many parameters. That on top of the fact that some sort of relaxation or curve fitting is usually desired in any case.
16:14:11 <acowley> edwardk: I think I'd just start with a polyline, but we'd be talking, say, 100 nodes per agent
16:14:29 <bgamari> edwardk: By the way, I stumbled upon an interesting approach to CSG not so long ago
16:14:39 <edwardk> bgamari: oh?
16:14:54 <Goosey124> acowley, What are you discussing?
16:14:56 <edwardk> acowley: makes sense
16:15:11 <acowley> Goosey124: path planning on graphs
16:15:33 <bgamari> edwardk: http://christopherolah.wordpress.com/2011/11/06/manipulation-of-implicit-functions-with-an-eye-on-cad/
16:15:42 <Goosey124> I see, then I'll be stalking your chat.
16:15:44 <acowley> I haven't banged ad on something hard for a while, so I feel like I'm overdue
16:15:53 <bgamari> edwardk: Complete with implementation
16:15:59 <edwardk> the usual video game ai path-planning approach is pretty close to that, usually with something like http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.6352 on top iirc
16:16:04 <bgamari> http://christopherolah.wordpress.com/2011/11/06/manipulation-of-implicit-functions-with-an-eye-on-cad/
16:16:24 <bgamari> Not quite the same problem I was trying to tackle (doesn't need to deal with piles of triangle)
16:16:52 <edwardk> bgamari: sure. signed distance formulas are a pretty handy trick
16:17:00 <bgamari> but definitely gave a fresh perspective on how to frame these problems
16:17:14 <edwardk> lemme give you a reference
16:17:21 <bgamari> apparently; if only I had thought of it :)
16:17:27 <acowley> edwardk: the trouble with most such methods is that they almost all give up completeness, and in a cooperative setting one does not have to be so conservative with predicting the motion of a dynamic obstacle
16:17:27 <edwardk> http://www.amazon.com/Introduction-Implicit-Surfaces-Kaufmann-Computer/dp/155860233X
16:18:32 <acowley> edwardk: I'm interested in augmenting my search with loads of application specific transition constraints, but I thought just thinking about traditional path planning on graphs would be a good test for whatever methods I try.
16:18:47 <edwardk> bgamari: they get used a lot in ray-marching because if you set up that function such that it represents a conservative estimate of the distance to any surface, you can 'jump' the ray by a distance equal to the current SDF value without risking collision, and you can use samples of it backwards along the ray near the point of impact for ambient occlusion
16:18:49 <bgamari> edwardk: Looks excellent\
16:19:22 <edwardk> acowley: hrmm
16:20:00 <edwardk> bgamari: i've read through that book a good dozen times. so if you grab it and need help, lemme know. =)
16:20:01 <acowley> I'd never thought of sampling a distance function like that for ambient occlusion. That's a great idea.
16:20:31 <bgamari> edwardk: Thanks!
16:20:32 <edwardk> acowley: yeah, gives a good looking but admittedly biased and incorrect result ;)
16:21:37 <acowley> edwardk: the usual story with dynamic obstacle avoidance is that whatever avoidance maneuvers your algorithm generates *usually* work, and if they don't work, then, hey, it's not your fault the obstacle was moving
16:21:53 <ClaudiusMaximus> is there an existing haskell ray-tracer that supports solids of revolution as well as CSG operations?
16:21:56 <edwardk> i think it comes up in http://iquilezles.org/www/material/nvscene2008/rwwtt.pdf
16:22:17 <edwardk> acowley yeah, whereas when you are cooperating it is your fault ;)
16:23:04 <acowley> edwardk: exactly. The opportunity for coordination is a burden, but I think it's an interesting one if you can dance the line between tractability and combinatorial explosion.
16:25:22 <edwardk> ClaudiusMaximus: not that i know of
16:26:34 <dylukes> So yep.
16:26:39 <dylukes> If anyone didn't hear earlier,
16:26:46 <dylukes> Travis CI has Haskell support now.
16:26:52 <edwardk> travis CI?
16:26:54 <ClaudiusMaximus> edwardk: hayoo agrees (though shady-graphics has something called revolve)
16:31:17 <dylukes> edwardk: It's sort of an open/free buildbot.
16:31:30 <edwardk> dylukes: ah
16:31:45 <dylukes> however, thanks to you (almost singlehandedly),
16:31:49 <dylukes> it takes 5 minutes to build >_>
16:32:04 <edwardk> =(
16:32:15 <dylukes> Well, I'm still not sure yet if it saves cabal packages between builds.
16:32:34 <dylukes> Because my three builds have been on separate slaves so far.
16:32:43 <dylukes> and I'm one of the first haskell projects up.
16:33:41 <dylukes> gah, on another one again...
16:33:51 <dylukes> http://travis-ci.org/#!/DylanLukes/Winchester-STG-Compiler
16:33:59 <dylukes> It's gonna do a 3000+ line install log now >.>
16:35:01 <edwardk> nice. i take it the path is the same as github or can you tune to another hosting provider, etc?
16:42:05 <dobblego> System.FilePath.takeExtension "abc.hs" gives me ".hs" -- can I get just "hs" (without (drop 1))
16:47:44 <hpc> dobblego: doesn't look like
16:47:53 <dobblego> yeah it's cool, I'll just drop 1
16:47:55 <dobblego> thanks
16:48:14 <dylukes> edwardk: It's integrated with github, sorta.
16:48:25 <dylukes> You can sign on with github auth, and then just flick an on/off switch for a repo.
16:48:33 <dylukes> But, ostensibly you can push from wherever.
16:48:46 <acowley> My question after seeing the story on reddit is how is Travis CI free?
16:49:14 <dylukes> It has a *lot* of sponsors.
16:49:16 <dylukes> Big name sponsors.
16:49:23 <ozgura> dobblego: last . splitOn "." -- splitOn from Data.List.Split
16:49:27 <dylukes> https://love.travis-ci.org/sponsors
16:49:35 <dobblego> ozgura: oh yeah cheers
16:49:52 <hpc> oh neat
16:50:10 <dylukes> Soundcloud, Heroku, Wooga, Xing, Stripe, Basho, Rails, etc
16:50:24 <ozgura> hpc: not really, as it is not total
16:50:33 <hpc> ozgura: except "yourTakeExtension "cat"" would break
16:50:35 <ozgura> but I guess takeExtension wouldn't be total either.
16:50:38 <dylukes> Heroku basically donates service for the frontend.
16:50:49 <ozgura> exactly
16:51:44 <ozgura> hmm System.FilePath.takeExtension returns "" instead of undefined
16:52:38 <ozgura> dobblego: lastDef "" . splitOn "." may be better, however it adds two package dependencies :)
16:52:46 <ozgura> lastDef from safe, splitOn from split
16:53:00 <dobblego> yeah thanks
16:53:50 <dylukes> acowley: Does that sufficiently answer your question :P?
16:54:46 <acowley> dylukes: yes, thanks! It's an impressive list, and I'm still surprised that such a service exists!
16:54:59 <dylukes> It's one of those things that gives me some faith in the Rails community.
16:55:24 <dylukes> For all the bickering and inanity, they do take care of their own and put out some very nice services here and there.
16:55:56 <dylukes> It's one of those "we're a bunch of successful Rails-based sites, so we'll donate to this little project to help smaller Rails projects (initially)
16:56:06 <dylukes> They then expanded to PHP/Erlang... and here we are now at 11 languages.
16:56:11 <dylukes> I was using it for Erlang a while back.
16:56:19 <dylukes> Pretty sure that got started because of Basho.
16:56:20 <dylukes> And Mongo.
16:56:34 <majuscule> I've been struggling with Data.ConfigFile to check first a default file, then a user file. Can anyone perhaps point me towards a working example of this that I can tear to pieces? I'm still having trouble wrapping my mind around the functional way of dealing with IO
16:57:10 <gaze__> is there any way to dream up a datatype based on a function's arguments? I'm trying to serialize continuations
16:57:14 <acowley> I was so disappointed when one day a while ago I had this idea to start a company called Basho, and then found that it already existed.
16:57:52 <acowley> I didn't know what the company would do, mind you, just its name, which I think is the most important part of a business plan. I'm not a rich man.
16:58:12 <dylukes> It just means "place" or "position" :|
16:58:24 <dylukes> Er well, I guess it could also have the sumo connotation.
16:58:34 <monochrom> gaze__: could be yes or no depending on disambiguation of your question
17:00:10 <gaze__> monochrom: I'd like to ultimately store function calls in a database.
17:01:01 <monochrom> you need to spell out a lot on where those functions come from, are they arbitrary or not so arbitrary etc
17:01:43 <acowley> dylukes: sumo?!? I was thinking of http://en.wikipedia.org/wiki/Matsuo_Bash%C5%8D by way of the Simpsons
17:02:09 <dylukes> That's „Å∞„Åó„Çá„ÅÜ, basho would be written „Å∞„Åó„Çá
17:02:28 <dylukes> The ≈ç is distinct from o.
17:02:32 <dylukes> (it's longer)
17:03:10 <acowley> Sorry, but I operate with an ASCII equivalence class dictated by my keyboard most of the time
17:03:38 <Absbeg> mapM_ putStrLn $ zipWith (++) (zipWith (++) (map show [1..]) (repeat ".) ")) ["P1", "P2"] <--  this works, but doesn't look right to me, any hints to make it better?
17:05:23 <Absbeg> this is just for printing a list like 1.) P1\n2.) P2\n
17:05:29 * hackagebot hashtables 1.0.1.3 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.0.1.3 (GregoryCollins)
17:05:47 <hpc> :t zipWith (++)
17:05:48 <lambdabot> forall a. (Monoid a) => [a] -> [a] -> [a]
17:07:02 <hpc> Absbeg: you can use (.)
17:07:11 <hpc> ie, turn f $ g (h x) into f . g . h $ x
17:07:42 <Absbeg> ok
17:07:44 <hpc> further refinements might be easier to spot with that changed
17:07:53 <gaze___> monochrom; http://hpaste.org/65208 is sort of a skeleton for what I'm trying to do. There are various steps like... download file via FTP that get spooled off by a file finishing downloading on a remote machine
17:08:23 <Absbeg> hpc: i'll paste the result :) can take some time though :)
17:08:26 <gaze___> and if the program or computer crashes at any point, I want to be able to restart the program and have it resume where it left off... or just before
17:09:25 <gaze___> problem is, let's say one function in the lowest portion of the program (user defined) wants to pass arguments to the next step, in addition to the FTPDownload or whatever
17:09:37 <gaze___> FTPDownload has a rigidly defined state
17:09:46 <gaze___> so it's easy to serialize
17:10:01 <gaze___> but what about the function call that comes next?
17:10:30 * hackagebot FilePather 0.1.6 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.1.6 (TonyMorris)
17:11:01 <ski> > zipWith (\n s -> show n ++ ".) " ++ s) [1..] ["P1", "P2"]
17:11:02 <ski> > [ show n ++ ".) " ++ s | n <- [1 ..] | s <- ["P1","P2"]]
17:11:03 <lambdabot>   ["1.) P1","2.) P2"]
17:11:04 <lambdabot>   ["1.) P1","2.) P2"]
17:11:11 <ski> Absbeg : looking for something like that ^ ?
17:12:10 <gaze___> err actually... encoded into the state of an FTPDownload needs to be a closure for whatever step wants to happen next
17:12:30 <Absbeg> ski: ahh list comprehensions, didn't thought about that, thanks i'll have a look
17:12:50 <ski> Absbeg : the latter one is using the extension of parallel list comprehensions
17:13:01 <gaze___> if I didn't want to pass arguments, it'd be pretty trivial I figure. You just make a lookup table from names to functions and encode the name
17:13:31 <gaze___> but arguments can of course have whatever type the user has specified the function as
17:13:31 <ski> Absbeg : in any case, i think one `zipWith' is more readable than two nested ones -- one input was just a `repeat' so i could pull that constant into the lambda
17:15:05 <Absbeg> ski: thanks i like your zipwith version it's very readable imho, i'll probably give that lambda an own function
17:15:21 <ski> s/an own function/a name of its own/ ?
17:15:40 <Absbeg> ehh yes
17:16:00 * ski would probably not bother with naming it, since it's only used once, and probably can be given no very sensible name
17:16:06 <Absbeg> you're right my sentence doesn't make much sense :)
17:16:20 <Absbeg> hmm point taken
17:16:58 <ski> (in an imperative language it would correspond to the body of a loop construct, and you don't typically name those either)
17:18:03 <Absbeg> thank you
17:18:54 <ski> yw
17:19:33 <Mathnerd314> ski: is your nick a reference to the calculus or to the snow?
17:19:38 <ski> the former
17:19:53 <ski> (.. and it's really an algebra, not a calculus)
17:20:53 <Mathnerd314> http://en.wikipedia.org/wiki/SKI_combinator_calculus edit it yourself :p
17:21:29 <ski> (see <http://lambda-the-ultimate.org/node/533#comment-7712>)
17:22:16 <gaze___> I guess I'll bug the rest of the folks again. Does anyone know how you might serialize a function call?
17:22:38 * ski doesn't understand the question
17:23:47 <gaze___> user defines some function f :: a -> b -> c, this machinery should figure out a and b, dump it to a file along with a way to get back to f
17:23:57 <Axman6> gaze___: the question doesn make much sense, but however, you might want to look at the work done for Cloud Haskell
17:24:30 <Axman6> gaze___: do you mean serialise a closure? you're not making much sense
17:24:38 <gaze___> yes
17:25:01 <Axman6> but if you have a, b and f, why not just serialise c?
17:25:14 <Mathnerd314> ski: "1. Systems like combinatory logic which contain no variables do not come under either term."
17:25:30 <Mathnerd314> so that means... it's not an algebra, or a calculus
17:25:52 <Mathnerd314> and thus we have no way to reference it...
17:26:52 <gaze___> cloud haskell seems like a really good place to start
17:27:10 <gaze___> it seems to mention sending function identifiers
17:27:19 <gaze___> so i have to be close :D
17:28:18 <Axman6> gaze___: what does this mean: "this machinery should figure out a and b, dump it to a file along with a way to get back to f"
17:29:22 <gaze___> I mean I want it to figure out the types of the arguments of f so it can serialize them, as well as an identifier for f
17:29:32 <gaze___> so later on we can call f with the stored arguments
17:29:55 <gaze___> but I'm beginning to see there's also the environment and all that other stuff, so yes
17:29:59 <gaze___> I'm trying to serialize a closure
17:30:11 <Axman6> oh, that's completely different from serialising functions isn;t it? that's just serialising the arguments, which is usually easy
17:30:16 <nart> hi :)
17:30:44 <dobblego> hi nart!
17:31:01 <gaze___> it is?
17:31:01 <Mathnerd314> Axman6: unless the function is higher-order...
17:31:22 <Axman6> Mathnerd314: yes, that's what i was thinking of when i said 'usually' =)
17:31:45 <nart> what is the most "idiomatic" way to develop an algorithm that involves backtracking ? is there some black magic i should now of ? =)
17:31:49 <DoctorSmaug> Can someone give me an example of a double precision sum which demonstrates haskell's precision errors?  I'm trying to document a potential bug in my program and for some reason can't make it happen now...
17:32:06 <Axman6> gaze___: well, you haven't said anything about actually storing functions. I think you're looking for a way to do RPC's, is this correct?
17:32:27 <Axman6> nart: well, there's things like the Alternative class
17:32:38 <gaze___> Axman6 Honestly it'd be the exact same machinery. I'm looking for a way to resume a function if it dies mid-computation.
17:32:48 <Axman6> > [0.1,0.2..1.0]
17:32:49 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600000...
17:33:20 <DoctorSmaug> cheers Axman6
17:33:21 <gaze___> at least, I think it'd be the same machinery
17:33:30 <Axman6> gaze___: you'd do well to start be telling us what problem you're actually trying to solve. that's a much more useful thing you've just told us than "how do I serialise a function call"
17:33:39 <nart> Axman6: ty, i'll check it out
17:33:50 <Axman6> :t (<|>)
17:33:51 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
17:33:53 <gaze___>  http://hpaste.org/65208 is sort of a skeleton for what I'm trying to do. There are various steps like... download file via FTP that get spooled off by a file finishing downloading on a remote machine
17:34:14 <td123> DoctorSmaug: http://hackage.haskell.org/trac/ghc/ticket/5856 dunno if this is what you're looking for
17:36:18 <gaze___> Axman6: but consider that when FTPDownload finishes, it may spit back the length of time it took for the file to download, other things. These bits should be passed to the next "doContinueFromTorrent" in the chain
17:36:42 <gaze___> but "doContinueFromTorrent" may want to ALSO pass arguments to the nxt "doContinueFromTorrent" in the chain
17:36:59 <gaze___> these arguments need to be encoded in the state of FTPDownload
17:37:10 <gaze___> so when FTPDownload completes, it can call the next function in the chain
17:37:36 <gaze___> with those arguments in addition to the completed state of the function.
17:37:48 <gaze___> hopefully that makes some sense.
17:38:25 <gaze___> the reason for this serialization is so that if the computer loses power or something, it should be able to resume or restart the download that was in progress.
17:38:37 <gaze___> it'll always resume at the point that it finished or before... it won't not download something.
17:38:53 <gaze___> *at the point that it lost power
17:41:51 <gaze___> wow this Cloud haskell stuff is exactly what I need
17:43:18 <twobitsprite> good evenning
17:43:51 <twobitsprite> what would you all recommend for a configuration file format? I'm looking at YAML, but wondering what other options are available
17:45:01 <twobitsprite> or, I guess my question is... what are some other well supported standard markup/serialization formats for haskell?
17:45:25 <aristid> twobitsprite: JSON?
17:46:52 <Axman6> gaze___: seems like a quite strange way to do things to me. using threads and exceptions seems like a much more sane way to go about things. for off a thread for each action you need to perform, giving it an MVar that contains Either SomeException (retType, Maybe dataForNextCall), and catch exceptions in the thread and write those to the MVar in case of error. that way the forking thread can do things like worry about writing things out to di
17:47:13 <Axman6> hmm, i think that may have been cut short, can someone tell me where it got cut?
17:47:21 <twobitsprite> aristid: I was looking at that too
17:47:43 <gaze___> worry about writing things out to di
17:47:58 <acowley> what's the best way to send a short message to edwardk when he's not on irc?
17:48:11 <Axman6> out to disk before forking the computations so it can restart if it crashes etc (you might  want to use some kind of journal format that keeps you safe from reading incomplete data on disk)
17:48:17 <gaze___> Axman6: Yeah, I was just trying to get something down, your way makes much more sense
17:48:21 <acowley> Should I publically disparage the utility of semigroups? Would that summon him?
17:49:01 <Axman6> acowley: there's always @tell... but you could also try being wrong about category theory, that might work too
17:49:40 <acowley> hmm. Any monoid can represent the forgetful functor U:Mon->Set
17:50:04 <acowley> (if that had worked I'd actually be rather frightened)
17:50:22 <gaze___> Axman6: But what about the serialization?
17:52:42 <Axman6> gaze___: Data.Binary
17:53:30 <gaze___> Right, That's simple for a data structure
17:53:47 <gaze___> I mean clearly cloud haskell has tons of machinery
17:58:24 <Mathnerd314> Axman6: which IRC client are you using, that cuts things short?
17:58:29 <gaze___> I mean, I don't mean to be rude but I had mensioned what I was posting was a skeleton
17:59:03 <Axman6> Mathnerd314: irssi
17:59:12 <gaze___> I'm really only interested in the serialization of function calls... or closures... I'm still not sure how much of the environment is req'd
17:59:26 <gaze___> rather than how to do the rest of the program right.
17:59:54 <mauke> Axman6: http://mauke.hopto.org/stuff/irssi/splitmsg.pl ?
17:59:54 <Axman6> why do you need to serialise more than the arguments to the functions? and possibly some kind of tag that tells you what function you're calling on those arguments on
18:01:10 <Axman6> mauke: installing now =)
18:01:27 <Axman6> I had looked for such  a script in the past, but not very hard
18:01:28 <Mathnerd314> I'd use http://scripts.irssi.org/scripts/splitlong.pl
18:01:43 <Mathnerd314> (purely since the version # is higher)
18:02:05 <gaze___> let's say just tag/args
18:04:51 <Vespakoen> Hey guys! Anyone using CQRS in here?
18:05:57 <mauke> Mathnerd314: I wouldn't, mainly because it wasn't written by me
18:06:13 <mauke> but also because splitlong.pl will happily break your unicode text
18:06:36 <Mathnerd314> so does that script work on channels, or only on privmsg's?
18:06:58 <mauke> which one?
18:07:13 <Mathnerd314> either (afaict they're basically the same)
18:07:39 <mauke> mine is low-leveler
18:07:41 * edwardk waves hello.
18:07:58 * ion waves cosine
18:08:10 <mauke> presumably it will work on all PRIVMSGs
18:08:45 <Mathnerd314> but will it work on things like Axman6's problem?
18:09:06 <mauke> ?
18:10:14 <Mathnerd314> I don't think sending to a channel uses privmsg's...
18:10:39 <c_wraith> Mathnerd314: it does
18:10:47 <monochrom> enter /msg #haskell hello
18:10:55 <mauke> what else? NOTICE?
18:11:02 -mauke(~mauke@p3m/member/mauke)- o hai
18:11:04 <monochrom> of course, you need a second client to verify the result
18:11:22 <Mathnerd314> hello
18:11:42 <monochrom> your hello comes out as a normal channel message
18:11:51 <mauke> monochrom: there's one in the topic :-)
18:12:12 <Mathnerd314> hmm, guess you're right...
18:12:24 <monochrom> if your software supports it, you should actually ask it for "raw log", showing what happens at the protocol level
18:12:39 <Mathnerd314> but then why is it *PRIV* MSG, instead of just MSG?
18:12:47 <Ralith> just read the IRC RFC a bit
18:12:58 <Ralith> spend ten minutes and you should be able to run a session from telnet
18:12:59 <monochrom> because names like "privmsg" are not meaningful names?
18:14:00 <monochrom> I mean, seriously, it's just a computer protocol. they can call it "meow" as far as I'm concerned.
18:14:02 <mauke> Mathnerd314: because it's only replicated to users who are on the channel, not everyone
18:15:39 <Jafet> You say 221, I say EHLO
18:16:11 <Mathnerd314> hmm, I knew everyone should switch to Jabber... now I know why...
18:17:08 <sohum> what, because the underlying protocol calls it PRIVMSG rather than MSG?
18:17:15 <sohum> rather than any of the actual issues with IRC? :P
18:18:18 <Mathnerd314> no, because it takes 10 minutes to run a session from telnet...
18:18:20 <monochrom> people can be so hung up on "meaningful" names
18:18:47 <sohum> ah! of course, any protocol needs to be run from telnet
18:18:50 <monochrom> it only takes 30 seconds for me. or 15 seconds
18:19:05 <shachaf> Sometimes it takes monochrom 7.5 seconds.
18:19:05 <monochrom> and 15 seconds just because I type slowly
18:19:33 <shachaf> Mathnerd314: Jabber-through-telnet is obviously much faster, what with all the XML tags and everything!
18:20:14 <monochrom> oh, then it takes me 2 minutes to do jabber
18:20:30 <Jafet> Modern TCP stacks have accelerated "trucker friendly" code for XML.
18:20:32 <dylukes> Why are you bragging about how quickly you can write in a protocol by hand.
18:20:39 <dylukes> That seems really silly :P.
18:20:49 <monochrom> haha
18:20:51 <dolio> The elders tell of a young ball much like you. He bounced 3 meters in the air. Then he bounced 1.8 meters in the air. Then he bounced 4 meters in the air. Do I make myself clear?
18:21:25 <monochrom> I'm just saying "10 minutes" is too exaggerated, even for hyperbole
18:22:13 <hpc> dolio: and then the great prophet Feynmann came down from the mountain with 3 stone tablets, each holding a law of thermodynamics
18:23:01 <Mathnerd314> should this go to #haskell-blah?
18:23:02 <Jafet> Some historians believe that they were bongos.
18:23:26 <Jafet> With standing waves on them
18:25:38 <edwardk> jafet: if it was feynmann i think they just didn't understand what they were seeing and how it correlated to what they were hearing. There must have been Tuvan throat singing involved.
18:29:03 <edwardk> (http://www.amazon.com/Tuva-Bust-Richard-Feynmans-Journey/dp/0393320693)
18:38:11 <dfletcher> heh awesome http://www.haskell.org/ghc/download_ghc_7_0_4 tells me "Stop! For most users, we recommend installing the Haskell Platform instead of GHC" .. and the source drop of Haskell Platform says it can't continue without 7.0.4. help, infinite loop!
18:38:48 <mauke> so don't get the source
18:39:02 <monochrom> my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml tells how to exit that loop
18:39:52 <dfletcher> aha okay so it's actually okay to get 7.0.4 and build that first. man that was confusing =)
18:40:14 <dfletcher> thanks monochrom
18:40:19 <monochrom> the "stop!" is for windows, os x, some but not all linux distros
18:40:48 <dfletcher> yeah centos was horribly outdated, would not build haskell platform
18:40:57 <dfletcher> so I uninstalled the package, starting from source
18:44:09 <Glorious> hey
18:44:15 <Glorious> im wondering why this is the case with this
18:44:16 <Glorious> http://hpaste.org/65212
18:45:00 <Glorious> im just adding another variable and calling it recursively
18:45:22 <geekosaur> Glorious, you do not wrap parameters in () in Haskell the way you do in other languages
18:45:39 <geekosaur> co1 (lnColors-1) (lnVertices+1)
18:45:57 <geekosaur> the extra parentheses mean you're invoking it with a single argument which is a tuple
18:46:01 <geekosaur> instead of two arguments
18:46:18 <mauke> stop being wrong on the internet
18:46:20 <monochrom> in general, x (y z) vs (x y) z. you want (x y) z.
18:46:39 <monochrom> "x y z" is shorthand for "(x y) z"
18:47:22 <rwbarton> "((lnColours-1) (lnVertices+1))" isn't even a tuple, it's the application of the "function" (lnColours-1) (which is not a function at all but an Int, of course) to the value (lnVertices+1)
18:47:41 <monochrom> you want "(x y) z" because co1's type is "Int -> (Int -> [String])"
18:47:51 <geekosaur> hm, sorry, yes
18:49:05 <Glorious> i tried co lnColours lnVertices = [ x:y | x <- [head (colours !! (lnColours-1))], y <- co lnColours-1 lnVertices+1]  and (co lnColours-1) lnVertices+1 and they dont work
18:49:28 <mauke> <geekosaur> co1 (lnColors-1) (lnVertices+1)
18:49:36 <monochrom> "f x+y" is shorthand for "(f x) + y"
18:50:12 <monochrom> use http://bm380.user.srcf.net/prettyparsetree.cgi to see hidden parentheses! bgamari's awesome invention!
18:50:30 <Glorious> i wont work even with geeks solution
18:50:37 <monochrom> for example http://bm380.user.srcf.net/prettyparsetree.cgi?exp=f+x+%2B+y
18:50:49 <Glorious> o instance for (Num (Int -> [String]))arising from the literal `1' at a3.hs:24:93    Possible fix:     add an instance declaration for (Num (Int -> [String]))
18:52:04 <Glorious> this is frustrating
18:52:09 <monochrom> what is the type of colours?
18:52:30 <rwbarton> can you paste your new code?
18:53:04 <dfletcher> oh heh actually needed that old ghc for bootstrapping. heh tricky tricky.
18:53:45 <monochrom> you shouldn't need to build your own ghc
18:54:01 <dfletcher> well the 6.x one would not build the haskell platform, as I said
18:54:02 <monochrom> but I understand than centos is strange
18:54:19 <dfletcher> but 7.0.4 is busy building now, so hopefully I'll be rocking shortly.
18:55:00 <dfletcher> I'll just do the rpm erase just before doing sudo make install. should be okay.
18:56:04 <monochrom> if colours :: [String], geekosaur's code works for me
18:56:20 <rwbarton> probably it is some other code entirely with the error
18:57:58 <monochrom> what is really frustrating: a person agreeing "I am new to this" and yet so sure about his/her blame assignment.
18:58:27 * shachaf is new to blame assignment.
19:00:42 <hpc> shachaf: it's always the other guy
19:00:47 * hackagebot zoom-cache 1.2.1.2 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-1.2.1.2 (ConradParker)
19:01:20 <monochrom> or, if you like to be friendly to humans, you can say it's always the stupid programming language
19:01:30 <dfletcher> you can all blame me if it makes you feel better. everyone else does =)
19:01:48 <monochrom> I blame you for choosing centos! :)
19:01:54 <dfletcher> hehe
19:02:03 <dfletcher> its just whats on my file server of old
19:02:10 <dfletcher> don't want to mess with the os
19:02:45 <monochrom> I am sympathetic to those who can't get recent software to work on centos, actually
19:03:31 <dfletcher> well after a minor hiccup (sudo yum install zlib-devel ncurses-devel) it seems to be still cranking away without issues. fingers crossed.
19:07:47 <dfletcher> hmm who posted that nvidia demo paper earlier? scrolled off my buffer and too lazy to look in logs. anyway thanks that was good.
19:07:59 <bgamari> acowley: You know of any good graph layout code?
19:08:12 <bgamari> bah, you aren't here
19:10:01 <monochrom> maybe the "diagrams" package
19:12:12 <byorgey> diagrams doesn't do graph layout
19:12:56 <mgsloan> well,  to be fair, there is force-layout, but yeah, no proper graph layout
19:13:02 <Glorious> it works but i m stuck I am trying to make all possible permutations of the color according to how many vertices of my graph i have: lets say i have 3 vertices 2 colours (red,yellow) i want to display rrr,rry,ryr,ryy..and so on so far i have this maybe some1 can help me with this
19:13:04 <Glorious> http://hpaste.org/65214
19:13:40 <byorgey> mgsloan: true
19:19:16 <byorgey> Glorious: I think you need to break the problem down into much more primitive pieces.  I suggest trying to write a function  choices :: Int -> [a] -> [[a]]  which gives you all the possible ways to make n choices out of the given list
19:19:49 <byorgey> Glorious: for example,  choices 3 ['r', 'y'] would be  ["rrr", "rry", "ryr", "ryy" ...]
19:20:16 <byorgey> Glorious: and you should implement choices without using the (!!) operator.
19:21:24 <scooty-puff> how do you represent (:) as a kind?
19:21:26 <NemesisD> can anyone explain to me the type signature of atomicModifyIORef? IORef a -> (a -> (a,b)) -> IORef b, what's up with the (a,b) bit?
19:21:27 <scooty-puff> i know [] is
19:21:29 <scooty-puff> '[]
19:22:11 <rwbarton> IO b, not IORef b.
19:22:40 <rwbarton> the first component of the (a,b) is used for the new value of the IORef, the second component for the result of the action
19:23:46 <NemesisD> ohh
19:24:01 <NemesisD> and modifyIORef isn't atomic?
19:24:06 <monochrom> example: atomicModifyIORef v (\x -> (x+1, cos x)) increments v and tells you the cos of the old value
19:24:07 <NemesisD> i don't actually need the value
19:24:37 <monochrom> you can atomicModifyIORef v (\x -> (x+1, ()))
19:25:10 <byorgey> scooty-puff: doesn't ': work?
19:25:31 <Glorious> yes byorgey i canot make it with choices because I  have to backtrack the vertices and see if 2 vertices are adjacent then they cannot be the same colours
19:25:43 <Glorious> colour*
19:25:49 <monochrom> modifyIORef isn't atomic. it's just a pair of readIORef and writeIORef. can has race condition if two threads do it
19:29:01 <andares> hey, I'm trying to write a program to calculate the collatz path lengths for a bunch of numbers.
19:29:19 <andares> I was going to use dynamic programming, iterating from [1..] and using an array.
19:29:20 <mauke> project euler?
19:29:23 <andares> yup!
19:29:29 <mauke> which problem id?
19:29:35 <andares> uh, 14 I think.
19:29:42 <mauke> yep, got that one
19:30:01 <monochrom> first you need to estimate the size of the array. which is like the collatz conjecture itself
19:30:43 <andares> monochrom: huh, I could use a map instead.
19:30:45 <monochrom> but if you are unallergic to binary search trees, you could use an infinite but lazy one
19:30:53 <mauke> want me to post my version?
19:31:12 <andares> mauke: I'd rather try to figure it out on my own, although I'll probably have to ask for help a bit.
19:31:31 <andares> my idea was to dynamic program working up, but that probably won't work.
19:31:38 <andares> monochrom's right, I can't use a straight array.
19:31:48 <monochrom> alternatively, PE problems have bounds. from those bounds, first find out (though expensively) how large an array you need for those bounds
19:31:53 <mauke> I used an array
19:32:03 <andares> mauke: how'd you estimate the upper bound?
19:32:12 <byorgey> you can also just use an array of a fixed size, and recalculate anything larger than the array
19:32:12 <scooty-puff> byorgey, it did not last time i tried - ended up just doing Nil | Con a (List a)
19:32:13 <mauke> I don't remember
19:32:16 <mauke> I probably guessed
19:32:35 <byorgey> in practice that should not be too bad I think.
19:33:01 <andares> mauke: so for a number k, you know its distance is the length of the number k/2 (+1) if it's even, but if it's odd you haven't calculated that yet.
19:33:01 <mauke> yeah, takes like 1.5s to run
19:33:02 <scooty-puff-sr> byorgey, would it be used as a ': b, or (':) a b?
19:33:12 <scooty-puff-sr> meh, xchat..
19:33:14 <andares> so that's why I'm stuck.
19:33:23 <byorgey> scooty-puff-sr: the former
19:33:34 <scooty-puff> k - sorry about the jumbling of names..
19:33:37 <byorgey> scooty-puff: at any rate that's the syntax in our paper.  I've no idea what actually got implemented.
19:33:42 <scooty-puff> k
19:33:44 <mauke> andares: why haven't I calculated that yet?
19:34:00 <andares> mauke: if you're just iterating from 1 to n.
19:34:04 <mauke> I'm not
19:34:13 <mauke> it's an immutable array
19:34:20 <mauke> I can't modify it piece by piece
19:34:36 <andares> can you return a new array modified?
19:34:45 <andares> or!
19:34:53 <andares> you could fill it with functions.
19:35:05 <andares> and then count. but that'd take forever because it won't cache results.
19:35:08 <monochrom> you don't need mutable array. you're looking at write-once read-many-times. that's an immutable lazy array
19:35:25 <monochrom> mutable = write at least twice
19:35:47 <andares> monochrom: don't I have to write once for each number I stick in it?
19:36:02 <mauke> no, you just compute all the numbers beforehand
19:36:13 <mauke> except not because we're lazy
19:36:22 <andares> I'm rather confused.
19:36:46 <monochrom> did you read my "you're looking at write-once read-many-times. that's an immutable lazy array" and "mutable = write at least twice"?
19:36:53 <mauke> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
19:36:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:37:08 <andares> monochrom: I did.
19:37:14 <mauke> have an infinite list
19:37:31 <monochrom> so, you have you write once, and no more, that's immutable
19:38:20 <andares> so I know that a!k | odd k = a!(3*k+1) | even k = a!(k`div`2)
19:38:37 <andares> I don't understand how I'd build an immutable list representing that.
19:39:28 <monochrom> > let a = listArray (1,3) [1, (a!!1) + 1, (a!!2) + 1] in [a!!1, a!!2, a!!3]
19:39:29 <lambdabot>   Couldn't match expected type `[a]'
19:39:29 <lambdabot>         against inferred type `GHC.Arr.A...
19:39:37 <mauke> !
19:39:37 <monochrom> hrm
19:39:41 <monochrom> @type listArray
19:39:42 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
19:40:05 <andares> how does starting from a list help? if anything it seems like that'd be worse.
19:40:17 <monochrom> > let a = listArray (1,3) [1, (a!1) + 1, (a!2) + 1] in [a!1, a!2, a!3]
19:40:18 <lambdabot>   [1,2,3]
19:40:34 <monochrom> there, an array defined in terms of itself, write-once
19:41:04 <andares> the.. oh.
19:47:27 <NemesisD> monochrom: what's the point of modifyIORef if its not atomic then?
19:48:21 <geekosaur> passing data between different parts of a non-threaded program
19:48:28 <monochrom> remember there was a time when every program had just one thread?
19:48:50 <monochrom> in fact, I still write and use such programs sometimes
19:49:29 <dolio> Trip on this....
19:49:36 <dolio> I was at a conference on Friday...
19:49:47 <dfletcher> heh crazy. while that ghc is building (still!) on that centos box I managed to get and build SDL and hackage SDL on windows. this is the opposite of my normal experience where building things on linux is easier :)
19:50:03 <dolio> And a fellow gave a talk on using the Java equivalent of epoll for concurrency.
19:50:16 <dolio> (I think that's right.)
19:50:19 <NemesisD> me too. its called ruby
19:50:46 <dolio> Why would you do that anymore?
19:51:18 <parcs`> dfletcher: because it takes long means that it's not easy? :P
19:51:33 <dfletcher> parcs`, heh well I had to do more jiggery to get it working as well
19:51:35 <andares> > let a = listArray (1,2000000) $ fmap f [1..] where f = \n -> a!(cnext n)
19:51:36 <lambdabot>   not an expression: `let a = listArray (1,2000000) $ fmap f [1..] where f = ...
19:52:00 <andares> let a = listArray (1,2000000) $ fmap f [1..]; where f = \n -> a!(cnext n)
19:52:20 <andares> it won't even calculate a!1, which is odd.
19:52:25 <andares> since a.. oh
19:53:25 <monochrom> I carefully gave it [1, (a!1) + 1, (a!2) + 1]. note the first item, 1. it is there fore bootstrapping.
19:53:31 <monochrom> s/fore/for/
19:54:02 <monochrom> of course, [(a!2)-1, a(!3)-1, 3] also works
19:54:15 <andares> I gave it 1 this time, but it's doing crazy things.
19:54:48 <monochrom> get a small example to work first. (1,10) instead of (1,20000000000)
19:55:04 <andares> it doesn't work, but I don't know how to debug.
19:55:08 <monochrom> I mean, are you going to actually verify the complete content of a 20000000000000-item array?
19:55:09 <andares> is there a "stack trace"?
19:57:16 <monochrom> perhaps import Debug.Trace and use [trace "A" 1, trace "B" ((a!1)+1), trace "C" ((a!2)+1)]
19:59:23 <monochrom> oh, you need a large array because it's collatz
20:00:20 <andares> monochrom: cnext 3 gives me 10, but a!(cnext 3) throws an exception saying the index 16 is out of bounds.
20:00:23 <monochrom> ok, use a large array, but never ask for all of its contents. only ask for like "map (a !) [1..10]", ever.
20:00:56 <andares> that seems rather weird, right?
20:01:16 <andares> apparently a!10 makes it complain about index 16..
20:01:17 <monochrom> what is collatz again? cnext (even number n) = n/2? cnext (odd number n) = 3n+1?
20:01:22 <andares> yeah.
20:01:53 <monochrom> a!10 = a!5 = a!(3*5+1) that's collatz for you
20:02:58 <andares> yeah. it works now. it's.. hard to think this way.
20:03:06 <monochrom> @let cnext n | even n = n `div` 2 | True = 3*n+1
20:03:06 <lambdabot>  Defined.
20:03:38 <andares> aren't you supposed to use otherwise? O:)
20:04:54 <hpaste> scooty-puff pasted ‚ÄúRecords‚Äù at http://hpaste.org/65216
20:05:03 <monochrom> > let a = listArray (1,1000) (1 : map (\n -> a!(cnext n)) [2..1000]) in map (a !) [1,2,3,4]
20:05:05 <lambdabot>   [1,1,1,1]
20:05:20 <monochrom> of course, this code doesn't count length
20:05:27 <scooty-puff> is there a reason (other than the overlapping instances) that records are often implemented as lists?
20:05:49 <scooty-puff> er, /often implemented as lists/not implemented like in the paste/
20:06:22 <monochrom> > let a = listArray (1,1000) (0 : map (\n -> a!(cnext n)  + 1) [2..1000]) in map (a !) [1,2,3,4]
20:06:24 <lambdabot>   [0,1,7,2]
20:06:33 <monochrom> this counts length
20:07:28 <andares> ooh, map (a!) that's what I was wondering about.
20:07:38 <scooty-puff> also, just how unsafe is unsafeCoerce?
20:07:52 <scooty-puff> if i have other static guarantees about the type, could it be considered safe?
20:07:59 <scooty-puff> well, i guess not static, but comparing TypeReps
20:08:00 <monochrom> it's a shorthand for [a!1, a!2, a!3, a!4]
20:08:01 <andares> monochrom: also, does ghci know not to recalculate a!k if a!k has already been calculated?
20:08:09 <scooty-puff> and only if the Typeable instance is bad..
20:08:11 <monochrom> it knows
20:08:38 <andares> but it's slow. supposed to only take like 2 seconds.
20:10:21 <monochrom> you're calculating a!100? a!200? or which one?
20:12:24 <andares> I'm supposed to find the maximum length path with starting number < 1000000
20:15:51 <andares> I can't find a reasonable bound. continuing to extend it crashed my computer.
20:15:59 * hackagebot shelltestrunner 1.2.1 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-1.2.1 (SimonMichael)
20:16:21 <andares> mauke: what bound did you use if I may ask?
20:17:35 <mauke> 399999
20:22:20 <monochrom> it takes more than a few seconds (to reach array-out-of-bound!) in ghci, i.e., interpreted code. if you compile, it's much faster
20:22:46 <monochrom> also pinning the types as Int helps. default is Integer
20:23:37 <mauke> Integer is fast enough
20:23:55 <monochrom> good to know
20:28:22 <andares> mauke: mine's overflowing with that number. also that seems suspect, since you're starting at 1000000.
20:28:46 <mauke> ?
20:29:27 <andares> problem 14 of project euler is to find the number that makes the longest chain with starting numbers 1 to 1 million.
20:29:57 <mauke> how am I starting at 1000000?
20:30:11 <andares> well, you have to find the collatz number of 1000000.
20:30:17 <mauke> no
20:30:35 <andares> if you bounded the numbers for which you compute collatz numbers at 399999, then that seems unlikely to work.
20:30:51 <mauke> http://hpaste.org/65217
20:31:03 <andares> mauke: "Which starting number, under one million, produces the longest chain?" from projecteuler.net
20:31:08 <mauke> under
20:31:41 <andares> huh, ours are rather different.
20:32:20 <monochrom> ah, if it steps outside the array, re-compute manually
20:33:54 <andares> http://hpaste.org/65218
20:34:00 <monochrom> <byorgey> you can also just use an array of a fixed size, and recalculate anything larger than the array
20:34:05 <andares> this is mine.
20:34:41 <andares> the problem is that there is no bound I can use with my code that works reasonably.
20:35:01 <monochrom> right, I find that too. so it comes to that.
20:35:06 <applicative> uh oh collatz battle on irc
20:35:45 <monochrom> if n<=3999999, use the array; otherwise, just compute the hard way
20:35:49 <andares> right.
20:36:07 <monochrom> of course, if you arrange it right, "just compute the hard way" can still use the array at suitable points
20:46:28 <andares> hm. I keep getting errors about stack overflows when I compile. is this normal?
20:48:25 <dfletcher> yay! working ghc 7.0.4 on centos :) now lets see about plaform.
20:50:12 <andares> hey mauke, did you run into stack overflow issues with your code?
20:50:58 <mauke> no
20:51:32 <mauke> but I compiled with -O2
20:51:49 <andares> huh, odd. maybe I should try that.
20:52:14 <andares> nope. I don't know what would be leaking in mine.
20:54:21 <monochrom> stack overflow is due to a long chain of 1+1+1+... but apparently PE14 does not lead to such a long chain
20:54:30 <monochrom> or rather mauke's code does not
20:54:40 <mauke> I get a stack overflow without -O2
20:54:51 <mauke> not during compilation, though
20:54:59 <monochrom> heh
20:55:28 <monochrom> exercise: write a program that causes the compiler to stack-overflow :)
20:56:13 <mauke> ... in the type checker
21:01:03 <parcs`> that's easy!
21:01:30 <parcs`> {-# LANGUAGE TypeFamilies, UndecidableInstances #-} type family Foo a; type instance Foo a = Foo a;
21:04:53 <applicative> hm, sure enough:  "Context reduction stack overflow; ..."
21:05:07 <andares> huh.
21:05:26 <applicative> :t undefined :: Foo Int  following parcs`
21:05:26 <lambdabot> parse error (possibly incorrect indentation)
21:05:55 <applicative> Why doesn't t the compiler know better than to accepts parcs` type
21:06:40 <elliott> |it does
21:06:50 <elliott> but parcs` demanded undecidableinstances
21:07:03 <applicative> ah, of course
21:07:17 <elliott> you can tweak the size of the context stack btw
21:07:18 <applicative> it's a simple undecidable instance.
21:07:23 <elliott> so its not some internal error
21:07:41 <applicative> yeah it says,
21:07:53 <applicative> Use -fcontext-stack=N to increase stack size to N
21:11:22 <mdmarek> Anyone know if there is a Haskell module that emulates Erlang's concurrency model?
21:13:41 <elliott> tons
21:13:56 <elliott> we even have erlang style distributed computing
21:14:01 <elliott> (cloudhaskell)
21:14:57 <mdmarek> cloudhaskell? let me check that one...
21:16:21 <mdmarek> do you know if cloudhaskell implements (more or less) the actors model of concurrency?
21:17:40 <Glorious> I have to permutate all posible colours according to the vertices of a graph so if I have 4 vertices and 3 colours i have to have smt like rrrr, rrrb, rrrry, rrryr and so on... bbbbr ...so on i have to make this with list comprehension and I cannot make it work, can sm1 guide me in the right direction heres my code so far : http://hpaste.org/65221
21:18:28 <mdmarek> reading the doc of cloudhaskell it seems that it does allow for the actors model...
21:19:20 <rasfar> colours !! n isn't a list, so you don
21:19:28 <rasfar> 't want to be taking the head of that
21:19:31 <elliott> what is erlang style if not actors
21:20:42 <strager> Actually colours !! n :: [Char] from what I see
21:20:58 <Glorious> its working
21:20:59 <rasfar> mmm could be (looks again...)
21:21:03 <Glorious> the result is *Main> permute 3 5
21:21:03 <Glorious> ["bbbbb\n"]
21:21:20 <Glorious> but the thing is after i do bbbbb i have to go bbbbr and bbbby
21:21:23 <Glorious> and im stuck
21:21:37 <mdmarek> indeed, erlang is very much actors
21:21:54 <Glorious> i dont have the termination code there sorry it is permute _ 0 = ["\n"]
21:22:12 <rasfar> still don't think you want head in the comprehension
21:22:21 <Glorious> i just cant wrap my head around that
21:22:21 <strager> I don't see lnVertices used a--  oh
21:22:29 <Glorious> what else should i use
21:22:55 <mdmarek> that is what I was hoping to find
21:22:59 <strager> Use take 1 x, instead of [head x]
21:23:08 <Glorious> ok thank you
21:23:17 <Glorious> but how would i make it work recursively
21:23:33 <strager> Make what work recursively?
21:23:35 <Glorious> so it does rrrr, rrrb, rrry ...rrby.. bbry
21:24:02 <Glorious> all permutations
21:24:06 <Glorious> of all possible colours
21:24:12 <Glorious> that all nodes can have
21:24:37 <ion> > replicateM 4 "rby"
21:24:38 <lambdabot>   ["rrrr","rrrb","rrry","rrbr","rrbb","rrby","rryr","rryb","rryy","rbrr","rbr...
21:24:39 <dfletcher> \o/ ghc + platform on centos! /me does a little dance of success.
21:25:08 <Glorious> I need to use list comprehansion
21:25:21 <ion> > [ c | c <- replicateM 4 "rby" ] -- :-P
21:25:22 <lambdabot>   ["rrrr","rrrb","rrry","rrbr","rrbb","rrby","rryr","rryb","rryy","rbrr","rbr...
21:26:13 <ion> > [ [a,b] | a <- [0,1], b <- [0,1] ]
21:26:14 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
21:26:16 <ion> Does this give you a hint?
21:26:17 <Glorious> the thing is i was trying to understand how to make this because after that i need to do backtracking where on the grap if 2 vertices are adjacent they cannot be the same colour
21:26:38 <Glorious> but i need to understand how to do all permutations first
21:26:55 <Glorious> by calling the function recursively so i can modify it after
21:27:02 <andares> hey, what would cause an undefined array element error?
21:27:27 <rasfar> andares: aren't all elements undefined initially?
21:27:34 <strager> Glorious: Can you not filter after permutating using replicateM?
21:27:55 <Glorious> i need to have a backtracking solution
21:27:57 <andares> rasfar: I guess not if they're defined in funky ways?
21:27:58 <Glorious> so i wont be able to
21:28:20 <Glorious> because when i get r for node 0 and the node 1 is adjacent to node 0 [0,1] then
21:28:37 <Glorious> i cannot have 2 r therfore, all my rrxx branches will be false
21:28:41 <rasfar> i mean, it's been a long time (>5 years) since I used arrays in Haskell, but initially all elements are undefined, right?
21:28:41 <Glorious> so i dont have to compute that much
21:28:56 <rasfar> So if you're reading an element that didn't get initiallised, bingo
21:29:00 <strager> Sounds like you can filter that easily Glorious
21:29:50 <Glorious> in order to filter i need to do all permutations first,, i dont want to do all permutations, i want to do the permutations that are only valid -> not 2 adjacent vertices can have the same colour
21:30:19 <strager> Is "i dont want" a requirement, or do you just think filters are unreasonable?
21:30:33 <rwbarton> well it's less efficient
21:30:36 <Glorious> is a requirement.
21:30:46 <rwbarton> potentially much less efficient
21:31:21 <Glorious> yes but it is a requirement and i need to while i recurse i need to block entire branches if it is the case
21:34:36 <strager> Well I don't know if you can do early guards with comprehensions (I haven't used comprehensions), but you can with the do notation
21:34:47 <strager> do a <- colours' ; b <- colours' ; guard (a /= b) ; c <- colours' ; d <- colours' ; return [a,b,c,d
21:34:58 <strager> colours' = map head colours
21:35:11 <Glorious> i need to use list comprehansion that why this is so complicated for me
21:35:51 <jamiltron> Has anyone had any luck installing Crypto with GHC 7.4?
21:36:21 <strager> Apparently guards are part of the list comprehension syntax: [ [a,b,c,d] | a <- colours', b <- colours', a /= b, c <- colours', d <- colours' ]
21:36:58 <elliott> jamiltron: what's the problem?
21:38:17 <Glorious> off i cant wrap my head around this
21:39:08 <jamiltron> elliott: I was originally get issues with the various Hex types not having show, as Integral no longer has implicit Show. After modifying those, I now get an Exit 11 when trying to compile BlowfishAux. Let me give you the error log.
21:39:32 <jamiltron> http://hpaste.org/65200
21:40:14 <rasfar> Glorious, i think strager has given you a good lead with the guards ... the remaining problem, you need to work in your graph connectivity info someplace
21:40:27 <monochrom> you can translate do-notation to list comprehension. do { x<-m; guard p; y<-n; return (f x y) } = [f x y | x<-m, p, y<-n]
21:41:19 <andares> is there a way to set breakpoints in ghci or something? I want to play around with functions inside of a where clause.
21:41:26 <elliott> jamiltron: no errors there. only warnings. show the entire output of cabal?
21:42:12 <Glorious> hmm
21:42:18 * dfletcher sees an error but not much details about what happened.
21:42:44 <elliott> dfletcher: well, yes :)
21:42:53 <Glorious> strager what is ' from colours'?
21:43:18 <jamiltron> elliot: Lines 22-24
21:43:22 <strager> 00:34 < strager> colours' = map head colours
21:43:26 <strager> Just the rgby
21:43:38 <strager> ryb rather
21:43:47 <Glorious> ok
21:43:52 <Glorious> im working on it
21:43:55 <jamiltron> elliott: Sorry, mispelled your name. Lines 22-24
21:44:38 <elliott> jamiltron: no.
21:44:41 <elliott> that is just saying "something went wrong"
21:44:47 <elliott> it doesn't say what, that's earlier in cabal's output
21:45:40 <Glorious> so you have the list formed from 4 colours
21:46:22 <Glorious> and u say first letter of colour 1 does not equal with the first letter of colour 2
21:46:32 <dfletcher> it's probably something simple like bcrypt-dev(el) packages missing. jamiltron. just a wild random guess, not much else we can do without details ;)
21:46:35 <strager> Yes
21:46:44 <applicative> jamiltron: maybe cabal install -v3
21:46:49 <elliott> we don't need -v3
21:46:50 <jamiltron> elliott: That's its: http://hpaste.org/65222
21:46:53 <elliott> we just need the entire output :P
21:47:01 <elliott> jamiltron: huh.
21:47:06 <elliott> we do need -v3 then, I guess!
21:47:15 <elliott> that looks like a cabal-install bug to me
21:47:21 <Glorious> if i could have 5 colours how would i make this dynamically .. i could get the length of the colours
21:48:01 <jamiltron> elliott: So that's after modifying SHA2.hs to account for Integrals not having implicit Show.
21:48:52 <Glorious> the number of vertices ( the graph) and the number of colours provided can be dynamic
21:49:01 <Glorious> are*
21:49:11 <applicative> jamiltron: you are using ghc-7.4.X?
21:49:19 <jamiltron> elliott: If I try installing an unmodified version, I get this: http://hpaste.org/65223
21:49:25 <strager> Look at sequence
21:49:34 <jamiltron> applicative: Yes 7.4.1
21:50:39 <applicative> jamiltron: yes, that's a typical new error, but it's hard to see how correcting it by adding (Show a) would give the new error, at worst it would be something new about classes (I think)
21:51:22 <applicative> sorry, by the first 'new error' i meant ghc-7.4 error; by the second 'new error' I meant the one you got after changing the file
21:51:29 <jamiltron> applicative: Yeah, I don't think the errors are related (although I guess I wouldn't be suprised by anything at this point), I just thought I should note it.
21:51:33 <elliott> jamiltron: can we see the -v3 output w/ your modified version?
21:51:35 <rasfar> would running the install with --verbose=3 give us more?
21:51:50 <rasfar> (or is that -v3?)
21:51:56 <applicative> yeah
21:52:01 <rasfar> ah
21:52:25 <dfletcher> huh yes it does seem to be 7.4 specific, just tried installing Crypto on 7.0.4 and it worked fine on linux and windows.
21:52:43 <elliott> well that's not surprising
21:52:46 <elliott> the Num superclass change
21:52:51 <elliott> is what causes the original error, after all
21:53:24 <hpaste> jamiltron pasted ‚ÄúCrypto verbose‚Äù at http://hpaste.org/65224
21:53:44 <applicative> thats irritating.
21:54:46 <elliott> "Skipping"?
21:54:54 <elliott> i have no clue what's going on here
21:55:02 <elliott> throw away everything and start again :P
21:56:36 <jamiltron> elliott: Then I'm back to http://hpaste.org/65223 unless you suggest going back on ghc versions, which seems a bit complicated on Arch Linux at the moment.
21:57:00 <elliott> that error can't be fixed without modifying the code, but as you've seen that doesn't really help
21:57:15 <elliott> anyway
21:57:23 <elliott> surely every arch user is used to things breaking completely :)
21:57:32 <elliott> i'd ping the author
21:57:44 <jamiltron> elliott: Yep, everything :P Thanks for the help!
21:59:25 <Glorious> strager look what i have so far if u would like to http://hpaste.org/65225
22:00:08 <Glorious> now i could get to rrr with that,, but how do i get rry :
22:00:15 <strager> Glorious: I think you mean i <- [0..lengthColours]
22:01:15 <Glorious> it complains about Couldn't match expected type `[t0]' with actual type `Char'
22:01:55 <Glorious> i think i need somewhere an x:xs or smt to keep calling somehow so i can get to rry ryb so on
22:04:06 <applicative> jamiltron: did you do cabal clean before this last build.
22:04:23 <jamiltron> applicative: How do I do that?
22:04:50 <elliott> cabal clean
22:04:55 <strager> Glorious: Okay, so let me try to understand your problem.
22:05:40 <applicative> you are building from inside the source so to say, not just doing 'cabal install crypto', right?
22:06:03 <strager> Glorious: You have a list of units, and a list of pairs of indices.  You want all permutations of those units (of length L) where, for each pair, the units at the two indices do not match.
22:06:31 <jamiltron> applicative: I am installing from inside source. cabal clean followed by install gives the same error :(
22:06:53 <strager> If I understand your problem correctly, I highly recommend you write some unit tests first (perhaps with quickcheck), then take a TDD approach.
22:07:35 <applicative> just wondered.  i notice a lot of seemingly broken packages earlier on does ' ghc-pkg check ' show any unpleasantness?
22:07:47 <elliott> jamiltron: try unpacking the source again after removing it, making the adjustment before building, and then building?
22:08:28 <applicative> jamiltron: the error is a little wierd :)
22:09:22 <Glorious> right now I am just trying to recursively get all my possible vertices, so I i have a 4 vertix graph I could get "rrrr","rrrb","rrry","rrbr","rrbb","rrby","rryr","rryb","rryy","rbrr","rbr... and I have to do this with list comprehansion and I do not know how to call everything recursively so it generates them, and what is a TDD approach?
22:09:35 <Glorious> comprehension*
22:09:57 <bgamari> Could someone point me in the direction of some instructive comonad instances?
22:10:22 <strager> Glorious: As I said, look at the definition of sequence (and replicateM)
22:10:45 <applicative> Isn't this alarming, "package Cabal-1.14.0-03.. is shadowed by package Cabal-1.14.0-5862dd... package Cabal-1.14.0-5862d... is unusable due to missing or recursive dependencies:   directory-1.1.0.2-b2527...
22:11:51 <applicative> i feel if it were a problem jamiltron would be getting a more spectacular error
22:12:12 <elliott> yikes
22:12:17 <elliott> jamiltron: yeah ghc-pkg check
22:13:50 <jamiltron> Eh, in ghc-pkg check I'm getting that ghc is broken because it depends on a broken package :/
22:14:36 <elliott> hmm
22:14:37 <elliott> jamiltron!
22:14:42 <applicative> 'ghc' there means a particular package, not the ghc, but it's still bad
22:14:44 <elliott> I bet you upgraded GHC without removing your compiled libraries?
22:14:56 <elliott> you can't do that.
22:14:59 <elliott> must recompile everything with new GHC.
22:15:01 <applicative> no, this is overwriting the ones installed by arch
22:15:08 <elliott> hmm
22:15:16 <elliott> oh well, nuke it from orbit, etc. etc.
22:15:18 <applicative> or thats the way i've done it ")
22:15:32 <jamiltron> elliott: Is there a simple way to remove all packages and start clean?
22:15:46 <applicative> jamiltron: I'm afraid elliott is right, it is just to opaque to recover from
22:15:55 <elliott> jamiltron: i usually cp ~/.cabal/config out, nuke ~/.{cabal,ghc}, cabal update, and move the config back in
22:16:08 <elliott> there are probably equally-effective ways, but this one is the most satisfying :)
22:16:15 <applicative> hah
22:16:32 <applicative> also, make sure that cabal install is installing locally, you don't want to come near what arch installs
22:16:52 <elliott> right. never sudo cabal
22:17:18 <jamiltron> Nuking...
22:17:53 <mdmarek> New Haskell user question: are "pure" functions always thread safe?
22:17:59 <ezyang> Yes.
22:18:03 <jamiltron> Ok, reinstalling cabal and ghc from Arch
22:18:38 <mdmarek> ezyang: yes, the pure functions are always thread safe?
22:18:38 <elliott> mdmarek: If a function always gives the same outputs for the same inputs, it would require a rather spectacular feat to make two threads calling it break things :)
22:18:52 <elliott> Can you clarify what you mean by "thread safe"?
22:18:54 <ezyang> Unless unsafePerformIO is involved!
22:19:04 <elliott> What would you expect if they were thread safe, and what would you expect if they weren't, in terms of behaviour?
22:19:10 <shachaf> elliott++
22:19:37 <shachaf> ezyang: If unsafePerformIO is involved they might still be "pure" and in that case they would probably still be "thread safe".
22:19:47 <elliott> If "unsafePerformIO" is involved.
22:20:55 <rasfar> > everywhere (mkT (reverse::String->String)) "scrap your boilerplate"
22:20:56 <lambdabot>   "ca orbiepaetlrlo uyprs"
22:21:06 <rasfar> shachaf: i get it, neat, thanks
22:21:26 <mdmarek> I would expect that something like:
22:21:35 <applicative> jamiltron: to specify local install you can do ' cabal install blah --local '
22:21:43 <elliott> jamiltron: (but it's default)
22:21:51 <elliott> so unless you tweaked the config and aren't running cabal as root you're ok
22:22:00 <mdmarek> main = let l = [1,2,3] in forkIO (doWork1 l) >> forkIO (doWork2 l)
22:22:22 <elliott> doWork1 and doWork2 can't possibly be pure.
22:22:24 <applicative> does it default to --global if you do sudo cabal install  I think it doesn't
22:22:27 <jamiltron> elliott: I'm getting some problems installing ghc from the Arch repo :/ It's telling me that I can't install it because haddock is a dependency
22:22:29 <elliott> Since they have the type ... -> IO ().
22:22:37 <mdmarek> would not cause one thread to see the work of the other on the "shared" list "l"
22:22:49 <elliott> What work? Values never change.
22:23:01 <elliott> Neither doWork1 nor doWork2 can cause l to be anything other than [1,2,3].
22:23:13 <shachaf> mdmarek: There is no mutation ever*.
22:23:18 <shachaf> * except all the time, but ignore that
22:23:28 <elliott> Thanks, shachaf.
22:23:31 <elliott> Thachaf.
22:23:31 <mdmarek> Ahh, I get your point.
22:23:43 <mdmarek> They can "transform" the list into other lists....
22:23:48 <shachaf> doWork1 *can* mutate the thunk l, but it'll only mutate it in the exact same way that doWork2 would've. :-)
22:23:48 <elliott> Right.
22:23:56 <elliott> (shachaf is talking about implementation details.)
22:24:02 <applicative> jamiltron: is there a 'haskell platform' package
22:24:15 <elliott> (Basically, with GHC, whenever you evaluate a value, it gets overwritten with the result of evaluation.)
22:24:20 <jamiltron> applicative: Not anymore
22:24:40 <applicative> arch users are too sophisticated for that kind of nonsense
22:24:47 <shachaf> Implementation details are the future.
22:24:55 <applicative> but it wont install haddock?
22:25:00 <mdmarek> OK, hence thread safe in the same way that imutable objects in Smalltalk, Java, C#, etc are thread safe...
22:25:15 <applicative> or haskell-haddock or whatever
22:26:20 <mdmarek> thanks all, time to sleep...
22:27:05 <jamiltron> applicative: I'm not even trying to install haddock. I'm pretty confident its not even on my system :/
22:27:29 <applicative> oh, i think i misunderstood what you said earlier
22:27:38 * rasfar off also; until next time...
22:28:24 <elliott> doesn't haddock come with ghc
22:30:12 <geekosaur> oddly not
22:30:47 <elliott> oh but cabal-install does
22:31:06 <applicative> sounds like that too is separate on arch
22:31:42 <elliott> i am not convinced jamiltron actually has a problem at this point
22:32:08 <applicative> oh, sounded like he couldn't rebuild the ghc?
22:32:15 * applicative is missing something
22:32:31 <jamiltron> Yep, ghc not reinstalling
22:32:47 <jamiltron> I'm going to hit the hay and try to figure it out tomorrow. Thanks for all the help.
22:32:58 <applicative> darn.
22:33:09 <jamiltron> I may have to just move all my haskell work to my ubuntu vps
22:33:30 <elliott> fwiw i use ghc 7.4 and have few troubles
22:33:37 <elliott> but i'm hardened to these kinds of problems :P
22:33:43 <applicative> geekosaur: do you use arch?
22:33:46 <jamiltron> Thanks for the help!
22:33:50 <Absbeg> when docu says "The operation may fail with:", does that mean it throws exceptions i can catch with catch?
22:34:15 <applicative> it would be good to have an arch expert around when you reinstall
22:34:19 <geekosaur> applicative, no, sorry.  do know a bit about it because we field a bunch of arch questions in #xmonad
22:34:29 <applicative> i see
22:34:39 <elliott> Absbeg: Depends what the docu is. Link?
22:34:48 <Absbeg> http://www.haskell.org/ghc/docs/latest/html/libraries/directory-1.1.0.2/System-Directory.html
22:34:53 <Absbeg> like this :)
22:35:53 <elliott> Yes.
22:36:04 <Absbeg> the source is kinda hard to understand for me :/
22:36:06 <Absbeg> ok thanks
22:36:11 * hackagebot github-backup 1.20120313 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20120313 (JoeyHess)
22:37:54 <Absbeg> or either i don't see exceptions being thrown anywhere, so i guess that comes from functions used (that probably are that strange callCC thingies)
22:38:17 <hpaste> dfletcher pasted ‚Äúlambdabot err‚Äù at http://hpaste.org/65227
22:38:30 <dfletcher> geekosaur ^^ am I just being stupid?
22:40:10 <dfletcher> maybe freenode is disconnecting it? hmm.
22:41:50 <elliott> dfletcher: looks like it to me
22:41:58 <elliott> perhaps its nick is set to "lambdabot" or such
22:42:02 <elliott> which is obviously taken and thus cannot be connected with
22:42:11 <dfletcher> I thought that was the last arg of @irc-connect
22:42:21 <dfletcher> lets see if haxskell is taken :P
22:43:01 <dfletcher> hmm
22:43:26 <dfletcher> well someone does own it but they're not online. I'll try something more unique.
22:46:11 * hackagebot couchdb-enumerator 0.3.7 - Couch DB client library using http-enumerator and aeson  http://hackage.haskell.org/package/couchdb-enumerator-0.3.7 (JohnLenz)
22:47:23 <geekosaur> hrm
22:48:43 <geekosaur> Im not the best person to ask about problems with lambdabot
22:48:59 <geekosaur> considering that I run wone (based on an older version) and it has Major Issues I have not worked out yet
22:49:55 <dfletcher> heh alright just found your name on a list of commands sorry to bug ya :) I'll try running it from a different host, see if my network is to blame.
22:50:07 <geekosaur> (like, to get it started, I must launch to REPL, "rc online.rc", then repeatedly run some command from the irc module like @listchans until it finishes setting up the connection, then @quit the REPL; otherwise it times out and gets dropped.  And sometimes get sdropped like that anyway.)
22:50:39 <geekosaur> yeh, I did what might be one of the more complete (if containing plugins that aren;t in the stock LB codebase) help listings for lambdabot
22:51:02 <geekosaur> ...also omits the plugins I didn't need for my installation, notably @run and friends
22:57:31 <flebron> Hi! Could anyone explain why, if I have an f : (a -> b) -> F a -> F b, such that f id = id, it must follow that f (g . h) = (f g) . (f h)?
22:58:09 <tommd> Is there a big list of GHC primitive/unboxed types? (ex: Int#)
22:59:24 <elliott> tommd: yes, in GHC.Prim
22:59:32 <elliott> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
23:00:53 <tommd> thanks
23:04:37 <mauke> @free f :: (a -> b) -> F a -> F b
23:04:38 <lambdabot> h . k = p . g => $map_F h . f k = f p . $map_F g
23:07:14 <flebron> mauke, why?
23:08:00 <flebron> (And what is it assuming about $map_F?)
23:10:01 <Pseudonym> It's assuming that $map_F is fmap on the functor F.
23:10:31 * Pseudonym apologises for the $map_X notation; still not happy with it
23:11:17 <Pseudonym> flebron: If it helps, consider this.
23:11:27 <Pseudonym> @free naturalTransformation :: F a -> G a
23:11:27 <lambdabot> $map_G f . naturalTransformation = naturalTransformation . $map_F f
23:11:39 <Pseudonym> That basically says "naturalTransformation is a natural transformation".
23:12:08 <flebron> Ok, since it's a morphism of functors.
23:12:15 <Pseudonym> Yup.
23:12:45 <Pseudonym> The way you should interpret a free theorem is that "forall" in the type system is a real forall.
23:13:19 <Pseudonym> In the sense that the function commutes with a type substitution.
23:13:53 <Pseudonym> @free sortBy :: forall a. (a -> a -> Bool) -> [a] -> [a]
23:13:53 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
23:13:57 <Pseudonym> My personal favourite.
23:14:17 <flebron> But for the conclusion of f (g . h) being f g . f h, it mentions the fmap of F - I never said f was the fmap of F, that's actually what I'm trying to prove.
23:14:18 <Pseudonym> If you undo the composition on the left-hand side, it's this:
23:14:29 <flebron> (That if f has the right type, and f id = id, then f is fmap.)
23:14:42 <Pseudonym> (forall x y. g x y = h (f x) (f y)) => $map f . sortBy g = sortBy h . $map f
23:15:27 <Pseudonym> Sorry, I came in late. You're trying to prove f (g . h) = f g . f h?
23:15:43 <Pseudonym> What the free theorem assumes is that the type has a fmap.
23:15:56 <flebron> Ok, assume the type has a fmap.
23:16:04 <Pseudonym> That's not a given, though.
23:16:08 <elliott> Pseudonym: that sortBy theorem is awesome
23:16:24 <Pseudonym> The @free command assumes it because otherwise it can't do anything.
23:16:29 <flebron> Yeah, sure. I can live with it - what I want to prove assumes F is a functor, so it has a fmap.
23:16:30 <Pseudonym> It's a notational convenience.
23:16:35 <Pseudonym> Right.
23:17:11 <Pseudonym> So.
23:17:30 <Pseudonym> @free f :: (a -> b) -> F a -> F b
23:17:30 <lambdabot> h . k = p . g => $map_F h . f k = f p . $map_F g
23:17:49 <Pseudonym> Set h = id.
23:18:21 <Pseudonym> Then k = p . h, and so:
23:18:31 <Pseudonym> Sorry.
23:18:33 <Pseudonym> k = p . g
23:18:34 <flebron> k = p . g *, yeah.
23:18:35 <Pseudonym> So:
23:18:48 <Pseudonym> $map_F id . f (p . g) = f p . $map_F g
23:18:57 <Pseudonym> That is. f (p . g) = f p . $map_F g
23:19:03 <Pseudonym> That's the most you can get from the free theorem.
23:19:11 <flebron> Ok, yeah, that I see.
23:19:35 <flebron> Why must f p . fmap g = f p . f g_
23:19:36 <flebron> ?
23:19:45 <Pseudonym> It doesn't have to.
23:19:55 <Pseudonym> I think.
23:20:48 <Pseudonym> Set g = id, and you have $map_F h . f k = f (h . k)
23:20:53 <Pseudonym> So you can also prove that.
23:20:55 <Pseudonym> Hmm.
23:20:58 <Pseudonym> Oh, of course.
23:20:58 <flebron> What I wanted to prove was that, if F is a functor in the Haskell sense, and we have an f : (a -> b) -> F a -> F b, and additionally f id = id, then f (g . h) = f g . f h.
23:21:02 <Pseudonym> Now set k = id.
23:21:17 <Pseudonym> Then you have: $map_F h . f id = f h
23:21:23 <Pseudonym> And since f id = id, $map_F = f
23:21:36 <Pseudonym> QED
23:21:40 <flebron> Huh. Nice.
23:26:12 * hackagebot graphicstools 0.2.2 - Tools for creating graphical UIs, based on wxHaskell.  http://hackage.haskell.org/package/graphicstools-0.2.2 (VilleTirronen)
23:27:24 <flebron> Hrm, Pseudonym, one question. We set k, g, and h to id. And we talk about forall h, k, p, g such that h . k = p . g.
23:27:42 <flebron> But then the only thing we are left with is p = id, and we proved that f id = fmap id, which we already knew.
23:28:00 <Pseudonym> Yes.
23:28:21 <flebron> That is, if we set those variables to id, the theorem loses pretty much all its power, since we are reduced to f id = id which we assumed,.
23:28:32 <Pseudonym> Yes, that's right.
23:28:44 <Pseudonym> The free theorem is the most general theorem that you can get from the fact that f is polymorphic.
23:28:55 <flebron> So am I right in saying that the proof must be wrong, since we only proved f id = id?
23:28:56 <Pseudonym> It's universal in the category theory sense.
23:29:27 <Pseudonym> The fact that you can make degenerate deductions from that is irrelevant.
23:29:37 <Pseudonym> FWIW, you can also prove f = f.
23:29:49 <Pseudonym> That isn't a wrong conclusion.
23:29:56 <flebron> What I'm saying is, did we actually prove that forall suitable functions g and h, f (g . h) = f g . f h_
23:29:56 <flebron> ?
23:30:00 <Pseudonym> Yes.
23:30:04 <elliott> you can prove true from it, too!
23:30:06 <Pseudonym> I think.
23:30:10 <Pseudonym> Yes.
23:30:29 <Pseudonym> That's a valid deduction from the general free theorem.
23:30:35 <flebron> As I read it, we only proved that f id = id, because the theorem talks about all functions h, k, p, g such that h . k = p . g, but we also assumed h = k = g = id.
23:31:04 <flebron> I think our conclusion is just f id = id, which we already knew, and not what we wanted to prove.
23:31:07 <Pseudonym> No, we selectively set h = id, and then simplified.
23:31:20 <Pseudonym> Or we selectively set g = id, then simplified.
23:31:25 <flebron> But your conclusion is $map_F h . f id = f h.
23:31:36 <flebron> Having said h = id.
23:31:40 <Pseudonym> No.
23:31:46 <Pseudonym> Step back a moment.
23:32:06 <Pseudonym> h . k = p . g => $map_F h . f k = f p . $map_F g
23:32:19 <Pseudonym> And we also know f id = id.
23:32:23 <flebron> Yes.
23:32:26 <Pseudonym> So pick one of k or p and set it to id.
23:32:35 <Pseudonym> Let's pick k. We get:
23:32:46 <Pseudonym> h = p . g => $map_F h . f id = f p . $map_F g
23:32:53 <Pseudonym> Erm.
23:33:07 <Pseudonym> No, wrong one. Let's pick h instead.
23:33:21 <Pseudonym> k = p . g => $map_F id . f k = f p . $map_F g
23:33:26 <Pseudonym> which implies:
23:33:34 <Pseudonym> f (p . g) = f p . $map_F g
23:33:48 <Pseudonym> Still true for all p and g.
23:34:03 <Pseudonym> If you also set p = id, then:
23:34:07 <Pseudonym> f g = f id . $map_F g
23:34:09 <Pseudonym> True for all g.
23:34:16 <Pseudonym> And since f id = id, we have:
23:34:18 <Pseudonym> f = $map_F
23:34:25 <Pseudonym> So this is actually a stronger theorem.
23:34:53 <Pseudonym> If F is a Functor and f :: (a -> b) -> F a -> F b and f id = id, then f = fmap.
23:35:33 <Pseudonym> From which it follows that f (g . h) = f g . f h, since this is obviously true of fmap.
23:35:51 <shachaf> Except if f _ = unsafeCoerce
23:36:02 <flebron> Sorry, got DC'd.
23:36:14 <Pseudonym> shachaf: Then the forall is not a real forall.
23:36:24 <flebron> Last transmission: f (p . g) = f p . $map_F g
23:36:42 <Pseudonym> That's true for all functions p and g, correct?
23:36:52 <flebron> What we know is f id = id, and forall h, p, g such that k = p . g, it holds that $map_F id . f k = f p . $map_F g.
23:36:56 <Pseudonym> So set p = id, and we have:
23:37:08 <Pseudonym> f g = f id . $map_F g
23:37:11 <Pseudonym> True for all g.
23:37:15 <flebron> Let me recheck.
23:37:19 <Pseudonym> And since we know f id = id, then:
23:37:21 <Pseudonym> f = $map_F
23:37:22 <flebron> I get lost when we ignore the quantifiers.
23:37:25 <Pseudonym> Right.
23:37:36 <Pseudonym> I left them out of @free because I wrote it for IRC use.
23:37:39 <flebron> (And the hundred thousand join/part messages.)
23:37:57 <Pseudonym> @ft f :: (Functor f, Functor g) -> (a -> b) -> (f a -> f b)
23:37:58 <lambdabot> Done.
23:38:01 <Pseudonym> Erm.
23:38:10 <Pseudonym> OK, @ft has been removed.
23:38:21 <Pseudonym> That's the version I didn't write. :-)
23:39:14 <flebron> Yes, I agree that for all functions p, g, it holds that f (p . g) = f p . $map_F g.
23:39:21 <Pseudonym> Right.
23:39:26 <Pseudonym> In particular, it holds for p = id.
23:39:57 <flebron> Ok, yes, for all functions g, it holds that f g = fmap g. Ok.
23:40:08 <flebron> Ok, yeah, I believe it then. Thanks :)
23:40:26 <Pseudonym> Cool.
23:40:34 <Pseudonym> So this is actually a stronger theorem.
23:46:12 * hackagebot CV 0.3.5.2 - OpenCV based machine vision library  http://hackage.haskell.org/package/CV-0.3.5.2 (VilleTirronen)
