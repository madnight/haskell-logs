00:05:50 <miller> Where can I get a concurrent multiple-writer single-reader queue for haskell? I don't see any sort of concurrent queue on hackage.
00:07:55 <Enigmagic> miller: Chan or TChan
00:09:04 <miller> Enigmagic: Thanks! (That is totally not what I expected it to be called...)
00:10:44 <Enigmagic> np
00:11:44 <glguy_> miller: Those are multiple-reader, multiple-writer queues (unless opt to have a single reader, of course)
00:33:30 * hackagebot gc-monitoring-wai 0.1.1 - a wai application to show GHC.GCStats  http://hackage.haskell.org/package/gc-monitoring-wai-0.1.1 (YiHuang)
00:51:00 <timthelion> When I define type Point = (Int,Int) in one file, and then import import Graphics.UI.Gtk
00:51:09 <timthelion> I get a conflict
00:51:16 <timthelion> what can I do to prevent this?
00:51:32 <Cale> timthelion: import one of them qualified
00:51:36 <timthelion> It seems to me, that there should be no conflict, as GTK's point should be the same as mine
00:51:44 <timthelion> ok
00:51:55 <Cale> oh
00:52:04 <Cale> in that case, just import one hiding Point
00:52:15 <timthelion> OK, thanks
00:52:17 <shachaf> In that case, just don't define yours?
00:52:31 <Cale> It doesn't check that the type aliases are actually aliasing the same thing
00:52:39 <timthelion> shachaf: nah, because my front end imports gtk, my backend doesn't
00:58:42 <hpaste> samg_ pasted ‚Äúbeginner's code‚Äù at http://hpaste.org/65671
00:59:40 <samg_> would anyone be so kind as to give me some feedback on my code? I'm new to haskell, so I don't know if I am following conventions...
01:00:12 <samg_> hpaste is nice enough to tell me to use fmap :)
01:03:21 <timthelion> it looks as though I have to cast between (Int,Int) and (Int,Int)... What possible design goal could be accomplished by not handling type aliases in the precompiler?
01:03:57 <timthelion> when I hide my backen's point I get grid_edit.hs:71:53:
01:03:57 <timthelion>     Couldn't match expected type `[Point]'
01:03:57 <timthelion>                 with actual type `Cell -> [Grid.Point]'
01:04:04 <shachaf> timthelion: You shouldn't be so quick to blame Haskell and/or GHC.
01:04:15 <shachaf> timthelion: In this case, for example, the error is completely unrelated.
01:04:24 <shachaf> I recommend reading the error message again. :-)
01:04:33 <timthelion> ah
01:04:41 <timthelion> perhaps you're right
01:06:07 <timthelion> hehe, found it:)
01:06:18 <samg_> I'm not sure that I prefer "fmap readData $ fmap head getArgs >>= loadMatrix" to "getArgs >>= return . head >>= loadMatrix >>= return . readData". Is there another way to clean this up?
01:06:57 <shachaf> samg_: How about head . loadMatrix <$> getArgs?
01:07:30 <samg_> <$> is new to me. I will hoogle it
01:07:40 <shachaf> samg_: <$> is another name for `fmap` :-)
01:20:22 <jeltsch> Does anyone know what‚Äôs wrong with the Hackage server? I‚Äôve just uploaded natural-numbers-0.1.0.2 via cabal upload. The package is shown on the website, but the command signaled a ‚Äú500 Internal Server Error‚Äù after having done nothing visible for a long time.
01:21:01 <dcoutts> jeltsch: it does that sometimes, I've never spent the time to work out what's going on, given that it does seem to work in the end.
01:21:23 * dcoutts would care if it did it in the new server code
01:23:34 <timthelion> is there a sortUsingCustomCompairison :: [a] -> (a -> a -> Bool) -> [a]?
01:23:37 * hackagebot natural-numbers 0.1.0.2 - Natural numbers  http://hackage.haskell.org/package/natural-numbers-0.1.0.2 (WolfgangJeltsch)
01:24:55 <timthelion> aha, sortBy
01:27:28 <hpaste> samg_ annotated ‚Äúbeginner's code‚Äù with ‚Äúbeginner's code (annotation)‚Äù at http://hpaste.org/65671#a65672
01:27:39 <samg_> whoops. didn't think it would repaste
01:28:32 <shachaf> Wait, taht doesn't typecheck, does it?
01:28:37 <shachaf> Oh, it does. I misread the original code.
01:30:55 <shachaf> Anyway, you could say something like (x,y) <- readData <$> loadMatrix . head =<< getArgs?
01:31:00 <shachaf> Who knows. Not worth it.
01:33:47 <samg_> arg. I was trying to get that, if only to build some intuition
01:33:53 <samg_> thanks for looking
01:34:15 <yasar> so, does anyone use curly bracket to struct their code?
01:34:31 <shachaf> The answer to "does anyone?" is usually "yes".
01:35:46 <yasar> ok, let me rephrase, is it usual to use curly brackets in haskell?
01:37:06 <zerax> Sure, when it makes sense.
01:38:21 <timthelion> > (\a->a).(\a->(a-1)) 1
01:38:22 <lambdabot>   No instance for (GHC.Num.Num (f a))
01:38:22 <lambdabot>    arising from a use of `e_111' at <in...
01:38:41 <timthelion> somehow I don't understand .
01:38:52 <timthelion> I think this should be the same as 1-1
01:39:04 <adnauseam> function composition you mean ?
01:39:09 <timthelion> yes
01:39:16 <adnauseam> hell i think i can explain this!
01:39:21 <shachaf> timthelion: The part you don't understand is Haskell syntax and precedence.
01:39:31 <shachaf> f . g x === f . (g x)
01:39:46 <shachaf> Function application binds more tightly than everything* else.
01:40:34 <adnauseam> look do you know what you got functions that look like function() and you end up having to nest about 10 of them into one another? like function(function(function(function()))) ?
01:40:57 <timthelion> adnauseam: I know what it's for, but why the error :)
01:41:04 <adnauseam> now instead of all those ()()()() you use function composition to do function . function . function . function
01:41:15 <adnauseam> oh there's an error
01:41:19 * adnauseam scrolls up
01:41:40 <mikeplus64> > (\a->a).(\a->(a-1)) $
01:41:41 <adnauseam> oh
01:41:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:41:42 <mikeplus64> > (\a->a).(\a->(a-1)) $ 1
01:41:44 <lambdabot>   0
01:41:44 <mikeplus64> oops
01:41:57 <adnauseam> you have an extra ) there
01:42:11 <timthelion> > (\a->a).(\a->a-1) 1
01:42:12 <lambdabot>   No instance for (GHC.Num.Num (f a))
01:42:12 <lambdabot>    arising from a use of `e_111' at <in...
01:42:25 <timthelion> > (\a->a).\a->a-1 1
01:42:26 <lambdabot>   <no location info>: parse error on input `->'
01:42:33 * shachaf sighs.
01:42:35 <mikeplus64> that 1 is being applied to (\a->(a-1))
01:42:39 <mikeplus64> instead of the whole composition
01:42:47 <adnauseam> > (\a->a).((\a->a-1) 1)
01:42:48 <shachaf> timthelion: Did you see what I said above?
01:42:49 <lambdabot>   No instance for (GHC.Num.Num (f a))
01:42:49 <lambdabot>    arising from a use of `e_111' at <in...
01:42:53 <shachaf> timthelion: f . g x === f . (g x)
01:43:04 <mikeplus64> so you have to do (f . g) x
01:43:11 <mikeplus64> or f . g $ x
01:43:17 <timthelion> > ((\a->a).(\a->a-1)) 1
01:43:18 <shachaf> Or (.) f g x
01:43:19 <lambdabot>   0
01:43:21 <timthelion> aha
01:43:28 <adnauseam> > (\a->a).(\a->a-1  $ 1
01:43:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:43:36 <adnauseam> > (\a->a).(\a->a-1)  $ 1
01:43:38 <lambdabot>   0
01:44:03 <adnauseam> aye just a matter of being careful with precedence
01:48:37 * hackagebot natural-numbers 0.1.0.3 - Natural numbers  http://hackage.haskell.org/package/natural-numbers-0.1.0.3 (WolfgangJeltsch)
02:10:44 <yasar> Instead of getting two arguments for a list like (x:xs) can I get one variable for complete list?
02:20:09 <shachaf> yasar: Why don't you try it? :-)
02:21:02 <yasar> but if I write only name of the variable like xs, how would compiler know I inteded it to be a list? Do I do it like [xs] or something like that?
02:24:51 <mm_freak> yasar: view each variable name as a wildcard
02:25:21 <Saizan> no, you just use xs
02:25:38 <Saizan> and the compiler will know if it needs to know, otherwise you'll get a more polymorphic type
02:26:01 <mm_freak> the pattern [xs] would match [1], [2] and [3], but not [1,2] or []
02:26:10 <Saizan> if you want to tell it you can add a type signature for your function
02:26:43 <mm_freak> now come up with a pattern that matches every list, and think really really simple‚Ä¶  think about matching every file using a shell pattern
02:27:16 <yasar> [_] ?
02:27:41 <mm_freak> that's the same pattern as [xs], it just doesn't give the variable a name
02:27:48 <Saizan> that pattern only matches singleton lists
02:28:36 <mm_freak> think simple
02:29:00 <mm_freak> don't try to restrict the compiler to lists, because the type system does that already for you
02:29:38 <yasar> do I define my interface manually?
02:30:42 <mm_freak> when you write a function of numbers, you can match individual numbers:  "f 3 = ‚Ä¶"
02:30:49 <mm_freak> what's the pattern for "any number"?
02:30:59 <Saizan> e.g. f :: [a] -> (); f xs = ()
02:31:23 <Saizan> but you can omit the type signature and the compiler will infer for yourself the most general type f can have
02:31:32 <Saizan> which is a -> () in this case
02:41:42 <yasar> lets say "ispalindrome x = x == reverse x", when I say ispalindrome [1..1000000], how much work is being done? For example, does it create a million list, and take a reverse, and compare each item, or it does it not create the whole list, and just creates parts of it until it finds an evidence that this would return false?
02:42:45 <shachaf> yasar: It's likely that "it"'ll have all million elements in memory at once at one point.
02:43:18 <int-e> yasar: it creates the whole list. both the list an its reverse, actually.
02:43:29 <mm_freak> yasar: it will have the whole list in memory and actually do the reversing, before it can return
02:43:39 <shachaf> Well, there's no saying what "it"'ll do.
02:43:46 <shachaf> But that's what GHC would do.
02:43:48 <adnauseam> isn't [1..1000000] a list of a milion ints, so in effect it'll have a list going to a milion, then reversing that list
02:44:35 <yasar> So would you say this is a bad way of checking if a list is palindrome in haskell?
02:44:37 <adnauseam> [1...1000000] by itselof is lazy, by reverse [1...1000000] would demand the whole list, am i wrong ?
02:44:43 <mm_freak> adnauseam: yes, but in most cases you don't have a whole list in memory‚Ä¶  in fact, if you do, that's evidence that you're using lists the wrong way
02:44:59 <shachaf> mm_freak: Except in this case you would.
02:45:00 <mm_freak> yasar: it's the best you can do
02:45:29 <mm_freak> yasar: it's not your method that's flawed‚Ä¶  it's the data structure used
02:46:22 <shachaf> mm_freak: Well, x == reverse x still does twice the number of comparisons that are needed. :-)
02:46:28 <yasar> What if I used a recursive function that compared and dropped first and last member of list until it evaluates to false?
02:46:31 <int-e> yasar: no, this problem can't be avoided; ispalindrome is a very strict function and has to remember the whole input list in order to work. Of course if you change the data structure away from a list to something that can produce elements at both ends, the story will be different.
02:47:19 <shachaf> yasar: That's not how lists work.
02:47:21 <mm_freak> shachaf: well, ok, but that's a linear speed factor =)
02:47:33 <adnauseam> how about comparing [1...] with [1000000,999999,...] hmm
02:48:03 <mm_freak> yasar: write a function that drops the last element
02:48:25 <yasar> doesn't "init" already does that?
02:48:36 <mm_freak> yes, but write it yourself to see how it works
02:50:11 <yasar> mm_freak: I guess I see where you are going with this. I guess it is very heavy calculation, right?
02:52:06 <mm_freak> yasar: in order to drop the last element you have to iterate to it first
02:52:26 <mm_freak> that's an O(n) operation where n ist the list's length
02:53:18 <danharaj> of course it is problematic to think in terms of such asymptotics with lazy evaluation.
03:08:16 <yasar> If I understand correctly, I should avoid using length, reverse etc. if possible, as they iterate over the whole list.
03:08:51 <imc> yasar: the you should avoid map, foldLeft, foldRight reduce, collect etc
03:09:11 <imc> but well, when using those methods you actually /want/ to iterate over the (whole?) list
03:09:52 <imc> yasar: if you use 'length' to distinguish between 0 and > 0 cases, pattern match on Nil and something else
03:10:21 <imc> list match { case Nil => /* length == 0 */ ...; case xs => /* lenght > 0 */ }   or use isEmpty
03:10:27 <yasar> I only know map function, but, when using map, I want to iterate over the whole list.
03:10:38 <imc> yasar: of course :)
03:11:03 <shachaf> yasar: map isn't bad in the same way that length is.
03:11:05 <shachaf> Or reverse.
03:11:15 <imc> reverse it also rebuild the whole list
03:11:20 <shachaf> If you take one element from (map f longList), it'll only take one element from longList.
03:11:31 <shachaf> If you take one element from (reverse longList), it'll force the whole thing.
03:12:09 <imc> sorry.. i thought i was in #scala... of course, we are _lazy_ here
03:12:12 <imc> nevermind
03:12:26 <imc> fast-rewind + erase
03:12:48 <t7> edwinb: Has anyone build epic for windows?
03:14:08 <teneen> With parsec, I would like to parse a string of 'a's followed by 'b's followed by 'c's. But how can I say that this should hold for the whole string?
03:14:39 <teneen> "aaabbbccccaabb" should not work for example
03:15:36 <shachaf> What are you trying that isn't working?
03:15:50 <imc> after getting the 'c's, you should parse the end of input or something like that
03:16:18 <imc> (if not end of input, parser will fail -> whole parsing will fail)
03:16:23 <teneen> (many . char) ['a', 'b', 'c'] <* spaces)
03:16:36 <edwinb> t7: I think so, but I couldn't tell you what you need to do to make it work
03:16:38 <teneen> mapM ((many . char) ['a', 'b', 'c'] <* spaces)
03:16:53 <teneen> Sorry, (mapM (many . char) ['a', 'b', 'c'] <* spaces)
03:17:46 <teneen> Ok it worked with eof, thanks
03:18:25 <imc> :)
03:20:20 <yasar> if I say [x:xs] , does it denote a list of listes?
03:20:53 <shachaf> A list containing a single list.
03:21:46 <imc> (which can be a list of lists...)
03:22:56 <solarus> also the inner list has to be non empty
03:24:10 <hpaste> yasar pasted ‚Äúintersperse‚Äù at http://hpaste.org/65674
03:25:03 <yasar> Can someone help me debug that paste? Function interface is given, I am trying to convert a list of lists of elements
03:25:24 <yasar> list of lists -> lists of elements
03:28:00 <mroman> yasar: You mean... concat?
03:28:15 <yasar> yes.
03:28:22 <yasar> but with a seperator.
03:28:28 <cheater> intercalate
03:28:56 <yasar> http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html Exercise 7
03:28:57 <mroman> i.e
03:29:11 <mroman> concat (intersperse xs xss) ?
03:29:18 <cheater> no
03:29:20 <cheater> intercalate
03:29:38 <solarus> yasar: note that one line 5 you match [x:xs] which matches a list containing a list with atleas
03:29:41 <mroman> That is somehow the definition of intercalate @cheater
03:29:46 <solarus> containing One list
03:29:51 <cheater> @src intercalate
03:29:52 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
03:29:52 <solarus> with atleast one element :)
03:29:53 <hpaste> Saizan annotated ‚Äúintersperse‚Äù with ‚Äúintersperse (annotation)‚Äù at http://hpaste.org/65674#a65675
03:29:58 <cheater> yes
03:30:07 <Saizan> yasar: ^^^
03:30:12 <cheater> however, you use ready functions, not copypasted definitions of them
03:30:25 <cheater> so don't tell him to use concat (intersperse xs xss)
03:30:31 <mroman> Agreed.
03:30:34 <cheater> tell him to use intercalate.
03:30:36 <t7> :t fmap
03:30:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:32:21 <balor> Is it possible to create a range of ints as a type?  Something like "data RestrictedInt = [0,..,100]"?
03:33:06 <yasar> Saizan: your example also gives error: Couldn't match type `a' with `[a]'
03:33:12 <Botje> balor: no, you want ada for that.
03:33:13 <bitonic> balor: wow, this question came up like 3 times last week. the answer is no.
03:33:25 <balor> Botje, thanks.
03:33:43 <bitonic> the best you can do is to have wrap "Int" in a newtype, hiding the constructor to the outside, and carefully define the functions
03:34:03 <bitonic> but you can't do what you want at the type level, as Botje said you need dependent types
03:35:37 <mroman> x is a list
03:35:46 <mroman> and seperator is not.
03:36:12 <Botje> so turn the saparator into a list first
03:36:35 <hpaste> Saizan annotated ‚Äúintersperse‚Äù with ‚Äúintersperse (annotation) (annotation)‚Äù at http://hpaste.org/65674#a65676
03:36:45 <Saizan> yasar: this one should be correct ^^^
03:36:56 <Saizan> no wait
03:37:00 <Saizan> i got it still wrong
03:37:24 <mroman> [x] matches :: [t]
03:37:29 <mroman> ([a])
03:37:34 <mroman> not [[a]]
03:37:41 <hpaste> Saizan annotated ‚Äúintersperse‚Äù with ‚Äúintersperse (annotation) (annotation) (annotation)‚Äù at http://hpaste.org/65674#a65677
03:37:47 <Saizan> that one
03:37:54 <cheater> lol
03:38:08 <yasar> Saizan: I think it should be [seperator] ?
03:38:22 <yasar> in the last line.
03:38:42 <Saizan> no, it's fine like that
03:39:07 <Saizan> [separator] would be a type error, unless you replace the last : with ++
03:39:38 <RichyB> yasar, (x ++ [separator] ++ intersperse seperator xs)
03:39:56 <RichyB> and (x ++ seperator : intersperse seperator xs), are both equivalent.
03:43:28 <yasar> What does this error mean? No instance for (Show ([[[[Char]]]] -> [[[Char]]]))
03:43:41 <RichyB> It means that you just typed in a function
03:43:55 <RichyB> and GHCi doesn't have a good way of printing functions.
03:45:09 <cheater> yasar: in general, "No instance for Show * -> *" means that you presented ghci with printing a function.
03:45:19 <cheater> or ghc.
03:45:32 <RichyB> In order to print a thing that you typed in which has type a, GHC looks for a (Show a) instance. The error is telling you that GHC couldn't find one. GHC couldn't find one because there isn't one by default 'cuz there isn't a good way to draw functions as text.
03:46:10 <RichyB> yasar, when I'm building up functions, piece by piece, at the ghci prompt, I normally start each line with :t
03:46:59 <RichyB> :t prints the type of the expression that you just typed in, rather than printing the thing itself.
03:47:00 <lambdabot> parse error on input `type'
03:49:26 <yasar> doesn't list of strings count as [[char]] ?
03:50:00 <donri> [[Char]]
03:50:02 <RichyB> Yes. A String is a [Char], a [String] is a [[Char]]
03:50:07 <mm_freak> from String = [Char] follows [String] = [[Char]]
03:51:11 <yasar> Hmm, why would http://hpaste.org/65677 fail, when called like intersperse "," ["foo","bar","baz"] ?
03:51:25 <RichyB> Because the first parameter you gave was a string.
03:51:39 <RichyB> Call it like (intersperse ',' ["foo", "bar", "baz"]) instead
03:52:19 <mm_freak> > intercalate ", " ["abc", "def", "ghi"]
03:52:20 <lambdabot>   "abc, def, ghi"
03:53:08 <albel727> :t intersperse
03:53:09 <lambdabot> forall a. a -> [a] -> [a]
03:53:13 <albel727> :t intercalate
03:53:14 <lambdabot> forall a. [a] -> [[a]] -> [a]
03:55:01 <srhb> @src intercalate
03:55:01 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
03:57:52 <gamowaxaky> hi
03:58:15 <gamowaxaky> any1 here
03:59:27 <RichyB> About 870 people here. ‚ò∫
03:59:42 <gamowaxaky> i can't see any msg
03:59:44 <RichyB> ± a couple of bots
04:00:12 <gamowaxaky> i'm starting learning haskell
04:00:13 <RichyB> That's because you only just joined the room. IRC doesn't send you historical messages from before you joined. :)
04:00:19 <RichyB> Excellent news! ^^
04:00:45 <gamowaxaky> how to learn it well?
04:01:40 <hpaste> yasar pasted ‚ÄúTreeLength‚Äù at http://hpaste.org/65678
04:01:53 <DrDiagoras> http://learnyouahaskell.com/ - is pretty nice place to start
04:02:22 <yasar> in above paste, in line 13, does treeheight a get evaluated twice?
04:02:47 <gamowaxaky> i'm at chapter 8 of "learn haskell for a great good"
04:03:03 <gamowaxaky> and sometime i got stuck
04:03:38 <RichyB> yasar, syntax error, you meant for line 12 to read: treeheight (Tree _ a b) -- instead, right?
04:04:25 <yasar> RichyB: yes. Sorry about that.
04:04:42 <RichyB> yasar, I think that GHC can pick up the sharing there really easily.
04:05:17 <RichyB> Move (treeheight a) and (treeheight b) into a let binding if you want to be explicit about the sharing.
04:06:08 <RichyB> I'd skip the question and write line 12 as: treeheight (Tree _ a b) = max (treeheight a) (treeheight b) -- shorter. :)
04:08:02 <DrDiagoras> hm... people, I have a question of perfectionism. what checklist should I mentally go through while choosing between STUArray and IOUArray?
04:08:03 <hpaste> RichyB annotated ‚ÄúTreeLength‚Äù with ‚ÄúTreeLength (annotation)‚Äù at http://hpaste.org/65678#a65679
04:09:02 <yasar> RichyB: I can't see the difference in your annotation.
04:12:23 <RichyB> yasar, just fixed (some but not all) of the minor type errors.
04:13:07 <yasar> ok. By the way, there is something wrong with type signature in above paste, ghci complains it expects one more argument to Tree
04:13:23 <RichyB> Yes. You wrote a type declaration (Tree -> Int)
04:13:31 <RichyB> but Tree is a type that always wants a parameter
04:13:40 <RichyB> so the type should actually be (Tree a -> Int).
04:13:54 <shurikas> shouldn't you sum up the number of tree levels?
04:14:00 <RichyB> the a there will match any type.
04:14:37 <yasar> shurikas: oww. right! *facepalm*
04:15:25 <yasar> but I don't know. Doesn't recursion takes care of that?
04:16:04 <shurikas> for me it looks like it
04:16:09 <shurikas> for me it looks like it's always 1
04:16:26 <shurikas> you should do something like 1 + treeheight a
04:16:37 <RichyB> yasar, you give the leaves a height of 1, and you give the inner nodes their childrens' heights.
04:16:56 <RichyB> Each inner node's height is 1 higher than it's higher child.
04:17:14 <hpaste> RichyB annotated ‚ÄúTreeLength‚Äù with ‚ÄúTreeLength (annotation)‚Äù at http://hpaste.org/65678#a65680
04:17:18 <yasar> Hmm. I need more caffein to continue :)
04:17:39 <shurikas> that's better
04:17:54 <RichyB> Also since you have (Maybe (Tree a)) in the children, you need a bunch of pattern matches on (Just) to pull the subtrees out.
04:20:52 <hpaste> RichyB annotated ‚ÄúTreeLength‚Äù with ‚ÄúTreeLength (now with less pattern matching noise)‚Äù at http://hpaste.org/65678#a65681
04:21:50 <RichyB> You could do it with way less pattern-matching by re-structuring it a little bit, like that -^
04:21:53 <yasar> what does module TreeHeight where do?
04:22:23 <RichyB> Makes the thing loadable/importable as a module called "TreeHeight".
04:22:53 <MaskRay> what's the documentation format in  http://paste.pocoo.org/show/568955/
04:41:38 <DrDiagoras> ok, pervious solved, but another question rised. I need some sort of lazy map that computes its values only when they are accessed. but problem is, that value computation is not pure - it's monte-carlo living in Rand monad. any suggestions where to search for one?
04:42:42 <sipa> make a Map a (IO b) ?
04:44:39 <bitonic> Map a (Either b (IO b))
04:44:45 <DrDiagoras> hm... not so easy. if I do like this, IO b would be computed every time I'm reading from same key. but I need it to be computed only once
04:44:54 <bitonic> DrDiagoras: ^^^
04:46:27 <DrDiagoras> interesting... then wrap it in some pretty Either b (IO b) -> IO b and voila. looks good!
04:47:22 <bitonic> btw, IO b is good enough, creating an IORef (Maybe b) and looking that up each time.
04:47:25 <bitonic> but that's kind of ugly
04:48:29 <DrDiagoras> no-no, I'm trying not to touch IORefs if I'm not totally forced to do so :-) previous solution would be better, I think - thanks!
04:48:38 <bitonic> ok
04:53:19 <hpaste> rostayob pasted ‚Äúlazy io‚Äù at http://hpaste.org/65683
04:53:34 <bitonic> DrDiagoras: ^^^ this is what I meant, which is what you do in imperative languages
04:54:39 <bitonic> actually, I'm an idiot, there is no need for the ()
04:54:40 <DrDiagoras> yup, sort of imagined something like that already :-) but I just noticed, that my monte-carlo isn't IO in core - it's State. so IORef would ruin things a bit
04:54:51 <hpaste> rostayob pasted ‚Äúlazy io‚Äù at http://hpaste.org/65684
04:55:11 <bitonic> this. in SML/Scheme I'd have to insert an extra lambda
04:55:53 <bitonic> DrDiagoras: yeah you definitely shouldn't do that in Haskell
04:56:40 <DrDiagoras> heh :-) bit of brain-bending sometimes, yes
04:59:43 <t7> does unification work both ways: eg  Constant a = Variable x      a -> x
05:00:00 <t7> Variable x = Constant a     x -> a ?
05:01:13 <bitonic> what does a -> x mean? you probably meant x -> a both times
05:01:24 <t7> substitute
05:01:28 <t7> |->
05:01:40 <bitonic> yes I understand, but a -> x doesn't make sense
05:01:42 <t7> http://en.wikipedia.org/wiki/Unification_%28computer_science%29#Examples_of_syntactic_unification_of_first-order_terms
05:01:45 <bitonic> (if a is some constant)
05:01:52 <bitonic> it's x -> a both times
05:01:57 <t7> ah ok
05:05:51 <hpaste> timthelion pasted ‚ÄúHow to get Ordering from Bool?‚Äù at http://hpaste.org/65685
05:06:15 <timthelion> How does one get Ordering from Bool in a prettyish fashion?
05:07:18 <opqdonut> you probably want "sortBy (comparing displayCellPoint)"
05:07:20 <opqdonut> :t comparing
05:07:20 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:07:27 <opqdonut> :t comparing head
05:07:28 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
05:08:21 <timthelion> thanks
05:08:33 <ironChicken> apologies for n00b question, but do packages on hackagedb have online documentation?
05:10:08 <t7> @hoogle liftM2
05:10:08 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:15:54 <yasar> Can we say that lists in haskell are more like "linked lists" in C, rather than arrays in C?
05:17:45 <DrDiagoras> yasar: yes
05:18:11 <DrDiagoras> though they are much more then that
05:19:12 <DrDiagoras> it's a bit hard to create list of all natural numbers in C :-)
05:19:59 <sipa> DrDiagoras: you could easily have a C structure which contains a number and a function pointer + argument to generate the rest of the list
05:20:09 <sipa> inconvenient, but just as powerful
05:20:55 <ironChicken> $ cabal install --enable-documentation --haddock-options=--hyperlink-source hasparql-client
05:21:02 <ironChicken> should that install local docs?
05:22:01 <bitonic> yasar: they are definitely more like linked lists yes.
05:22:11 <dcoutts_> ironChicken: yep
05:22:27 <bitonic> ironChicken: you can configure cabal to always install docs in .cabal/config
05:22:32 <bitonic> which is really useful imho
05:22:41 <bitonic> dcoutts_: why isn't that a default?
05:23:06 <ironChicken> and if it hasn't, what might be wrong?
05:23:06 <quicksilver> register my vote for enable documentation by default :)
05:23:12 <DrDiagoras> sipa: yea, I know. but one day you'll need to make list with some partially applied function... but that's a beginning of flame :-)
05:24:19 <dcoutts_> ironChicken: I'm not sure that --haddock-options=--hyperlink-source would work
05:25:01 <dcoutts_> ironChicken: in fact that's probably the problem, haddock has no such flag, so when you pass it that flag then it fails
05:25:14 <dcoutts_> ironChicken: presumably you find the build is failing right?
05:25:15 <ironChicken> dcoutts_: ta. that's fixed it
05:39:02 * hackagebot xournal-render 0.6.0 - Xournal file renderer  http://hackage.haskell.org/package/xournal-render-0.6.0 (IanWooKim)
05:45:08 <t7> @seen rostayob
05:45:09 <lambdabot> Unknown command, try @list
05:45:19 <bitonic> t7: it's me
05:45:26 <t7> wut
05:45:33 <t7> did you delete your github?
05:45:41 <bitonic> t7: https://github.com/bitonic
05:50:04 <jeff_s_> I eventually discovered why I couldn't do "show t" where t was a UTCTime. The problem was that Iwas usign the datetime package instead of the time package. I must have confused the names at some point.
05:51:25 <quicksilver> the show instance is in Date.Time.Format
05:51:29 <quicksilver> (or some similar name)
05:51:43 <quicksilver> datetime uses time underneath anyway doesn't it?
05:52:09 <jeff_s_> It has time as a requirement, so probably yes.
05:54:04 * hackagebot yesod-platform 0.10.3 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-0.10.3 (MichaelSnoyman)
05:58:00 <hpaste> deggis pasted ‚ÄúBuild error: cmdargs object file‚Äù at http://hpaste.org/65686
05:58:20 <jeff_s_> Hm, OK, never mind. I guess that wasn't my problem. I unregistered the datetime package, using getCurrentTime definitely loads the time package (version 1.4.0.1), and I still don't have an instance for Show UTCTime.
05:58:39 <deggis> ideas on that one above? this is odd, cmdargs hasn't before given any build errors
05:59:09 <exFalso> deggis: try without profiling
05:59:35 <deggis> ah, i was just saying that profiling is only thing i've switched on now (and because of it i'm rebuilding stuff)
05:59:38 <exFalso> also check whether you have enough space on hard disk:)
06:00:26 <deggis> hmm, there's only 200M :o. i'd better make more. but what bad could profiling do there?
06:00:37 <deggis> i'm quite new to profiling stuff
06:01:03 <exFalso> well profiling creates extra object files (.p_o)
06:01:18 <exFalso> and ghc links statically
06:01:34 <exFalso> so the binaries you get are quite big
06:01:50 <exFalso> (afaik)
06:02:44 <geekosaur> profiling is also slower, I believe
06:03:29 <exFalso> in my experience there was a surprisingly low overhead
06:03:38 <deggis> ah, ok. i made more space, but didn't help. Implicit.p_o seems to be made just before error 'Implicit.o not found' comes
06:03:40 <exFalso> dont know how they managed to pull that off
06:05:44 <exFalso> can you try building this specific package without profiling and -then- recompile with profiling
06:06:32 <Saizan> exFalso: .p_o files don't get linked in a non-profiling exe
06:07:46 <exFalso> Saizan: i believe he compiled with profiling on
06:08:33 <exFalso> Saizan: and turning on profiling is just one flag to the binary, which is why i though that it links both profiling and non-profiling object files into one binary
06:09:28 <deggis> it seems taking profiling of doesn't have effect on result
06:10:11 <Saizan> exFalso: +RTS -p is not available in an executable built without -prof
06:10:12 <deggis> or i didn't take it off when i thought i did
06:11:03 <exFalso> Saizan: yes, but as i said i think he compiled with profiling on
06:11:52 <deggis> okay, it builds without profiling
06:14:00 <deggis> i turned both library and executable profiling on in ~/.cabal/config again and i arrived to same error
06:14:25 <exFalso> grr
06:15:45 <dcoutts> deggis: you need to tell cabal that you are using TemplateHaskell, otherwise it cannot do the right thing.
06:16:08 <deggis> Implicit.o is built succesfully (with i'ts o_p counterpart). hmm. i'm using cabal-dev if that has an effect
06:16:21 <dcoutts> in theory you're supposed to list all the extensions in the .cabal file (at least in other-extensions)
06:16:31 <dcoutts> but we don't yet enforce that
06:16:57 <deggis> oh. i didn't know i was using it, at least not explicitly
06:17:02 <dcoutts> but in particular, if you don't list TemplateHaskell then Cabal cannot help you with this situation
06:17:33 <dcoutts> deggis: see in your hpaste, see how it loads lots of packages while compiling?
06:17:40 <dcoutts> in a way that looks like you get with ghci
06:18:11 <deggis> oh, and there's template-haskell
06:18:13 <dcoutts> that's because TH is doing the same thing as ghci, loading packages and ordinary .o files for your modules
06:18:46 <dcoutts> deggis: now for a profiling exe, normally we just build the .o_p file, but with TH we also have to build the .o for all modules because ghc itself needs to load those.
06:18:58 <dcoutts> deggis: Cabal does that automatically if it knows you're using TemplateHaskell
06:19:41 <deggis> ah, ok
06:22:14 <deggis> the way to tell cabal i'm using it would be adding TemplateHaskell to extensions: in .cabal file? i tried that, ran cabal-dev configure and tried again, but didn't help yet
06:22:42 <dcoutts> deggis: can I see the .cabal file and the build log?
06:25:03 <deggis> dcoutts: there they are in that order http://deggis.iki.fi/temp/build_problem.txt
06:25:32 <deggis> (oh, i'll add the whole build log there, a sec)
06:26:00 <dcoutts> ta, it's missing the earlier bit I was looking for
06:26:09 <dcoutts> deggis: use build -v please
06:26:57 <dcoutts> deggis: and if possible, also include how you did the configure step
06:30:20 <deggis> dcoutts: http://deggis.iki.fi/temp/build_log.txt with configuring i just ran cabal-dev configure
06:32:23 <deggis> hmm that dist/build/cmdargs/cmdargs-tmp is created after that missing Implicit.o was created
06:35:54 <dcoutts> deggis: oh so the problem is that cmdargs doesn't say it's using template haskell
06:36:21 <dcoutts> so it fails to build in profiling mode
06:39:44 <yasar> Is there a difference between Int and Integer?
06:39:49 <quicksilver> yes
06:39:54 <deggis> dcoutts: uh, i'll try to patch cmdargs .cabal file and see how it goes
06:40:03 <quicksilver> Int is a specific length type (32 bits or 64 bits most likely depending on your system)
06:40:05 <dcoutts> deggis: sounds like the best plan
06:40:06 <Botje> > maxBound Int
06:40:07 <lambdabot>   Not in scope: data constructor `Int'
06:40:12 <Botje> > maxBound :: Int
06:40:14 <lambdabot>   9223372036854775807
06:40:17 <quicksilver> Integer supports "arbitrary" sized integers
06:40:20 <dcoutts> deggis: another workaround is to avoid building that cmdargs executable
06:40:21 <Botje> Integer doesn't have that limit.
06:40:35 <dcoutts> deggis: might as well email Neil about it btw
06:41:02 <mrcarrot> > maxBound :: Interger
06:41:03 <lambdabot>   Not in scope: type constructor or class `Interger'
06:41:09 <mrcarrot> > maxBound :: Integer
06:41:10 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
06:41:10 <lambdabot>    arising from...
06:41:54 <_mpu> > (maxBound :: Int) + 1
06:41:55 <lambdabot>   -9223372036854775808
06:43:09 <deggis> dcoutts: i can do the informing as well. but about that executable, i don't need it but it's compiled anyway. can i somehow say not to build it?
06:43:20 <deggis> dcoutts: and yes, that worked instantly :)
06:43:36 <dcoutts> deggis: if you look in the cmdargs.cabal file, you can see there's a flag to turn on/off the exe
06:43:40 <dcoutts> deggis: great
06:45:04 <deggis> oh, the flags
06:45:56 <Axman6> @hoogle Handle -> ByteString
06:45:56 <lambdabot> Data.ByteString.Lazy hGetContents :: Handle -> IO ByteString
06:45:56 <lambdabot> Data.ByteString.Lazy.Char8 hGetContents :: Handle -> IO ByteString
06:45:56 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
06:46:18 <Axman6> hmm, do I want handles or sockets if i'm after the best performance I can get?
06:46:29 <Axman6> @hoogle Socket -> ByteString
06:46:29 <lambdabot> Network.Socket.ByteString.Lazy getContents :: Socket -> IO ByteString
06:46:29 <lambdabot> Network.Socket.ByteString.Lazy recv :: Socket -> Int64 -> IO ByteString
06:46:29 <lambdabot> Network.Socket.ByteString recv :: Socket -> Int -> IO ByteString
06:47:26 <deggis> dcoutts: i'll inform neil about that
06:47:37 <dcoutts> deggis: ta
06:47:49 <qued_____> any reverse syntax for (x:xs), so that the last element can be accessed via x ?
06:47:52 <deggis> ta? :)
06:48:23 <dcoutts> deggis: you can tell him he doesn't need to use the 'extensions' field, there's a new other-extensions which might be preferable (it doesn't make ghc compile all modules using that extension)
06:48:24 <Axman6> qued_____: no, it doesn't make any sense when you look at the definition of lists in haskell
06:48:25 <quicksilver> qued_____: no, because pattern matching is all about how data is actually structured.
06:48:41 <quicksilver> qued_____: and lists are actually structured as <head of list> : <rest of list>
06:48:42 <dcoutts> deggis: oh, a Britishism, ta is like thanks
06:48:48 <deggis> dcoutts: thank you so much. [X] Problem solved [X] Reason understood [X] Other learning happened during the process.
06:48:55 <dcoutts> :-)
06:49:03 <quicksilver> qued_____: however, there is data type "Sequence" which supports fast access to both ends.
06:49:09 * hackagebot libnotify 0.0.2.1 - Haskell binding for Libnotify  http://hackage.haskell.org/package/libnotify-0.0.2.1 (MatveyAksenov)
06:51:04 <qued_____> thanks :-)
06:59:10 * hackagebot doctest 0.6.0 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.6.0 (SimonHengel)
06:59:12 * hackagebot digestive-functors 0.3.0.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.3.0.0 (JasperVanDerJeugt)
06:59:14 * hackagebot digestive-functors-blaze 0.3.0.0 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.3.0.0 (JasperVanDerJeugt)
06:59:16 * hackagebot digestive-functors-snap 0.3.0.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.3.0.0 (JasperVanDerJeugt)
07:01:25 <jeff_s_> I feel like haskell-platform's configure script should accept --with-happy=path
07:01:36 <deggis> dcoutts: http://code.google.com/p/ndmitchell/issues/detail?id=539
07:01:47 <dcoutts> great
07:02:06 <dcoutts> jeff_s_: hmm, shouldn't need it really, it installs happy
07:03:47 <jeff_s_> I was getting a build error about happy being required but not found.
07:03:56 <jeff_s_> I had to add my old haskell-platform installation to my path.
07:04:10 * hackagebot digestive-functors-happstack 0.3.0.0 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.3.0.0 (JasperVanDerJeugt)
07:04:17 <dcoutts> jeff_s_: smells like a bug
07:04:43 <geekosaur> mmm, isn;t that more the usual executables thing?
07:05:05 <geekosaur> combined with kinda wanting the whole platform in one unified path?
07:05:08 <jeff_s_> It's possible that it built happy, but then didn't bother looking for it in its temporary location.
07:10:16 <x_man> language of regular expression over infinite alphabet can be described by finite automata?
07:11:18 <timemage> x_man, iirc, a finite alphabet is part of the description of an automata.
07:11:46 <x_man> if we have infinite alphabet?
07:12:55 <ski> will you have infinitary union of regexen as well, then ?
07:14:12 <x_man> ski: yes...
07:16:44 <t7> bitonic
07:16:48 <t7> come back!
07:40:08 <t7> :t join
07:40:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:46:11 <mm_freak> what's the default fixity if there is no definition?
07:46:13 <DrDiagoras> now I am surprized! are my googling skills so low, or there is really no memoization monad out there?
07:46:40 <parcs`> mm_freak: infixl 9
07:47:01 <hpc> i don't think you can form a monad out of memoization
07:47:26 <hpc> at least, not without it being Identity with a memo :: Memo a -> Memo a -- or something like that
07:47:52 <mm_freak> parcs`: thanks
07:50:35 <DrDiagoras> hpc: hm... but I need explicit memoisation of State monad steps. surely, I can code something ugly myself, but that sounds like something generic and usefull, so I'm surprised about finding nothing on hackage
07:52:46 <Wingkalimdor> hi
07:52:57 <Wingkalimdor> is anyone there?
07:53:11 <hpc> Wingkalimdor: nope, nobody
07:53:17 <hpc> all 800 of us are afk
07:53:20 <hpc> :P
07:53:58 <zerax> Some people are more likely to chip in an answer than to commit to some definition of existence. Just ask your question.
07:54:00 <Wingkalimdor> hi, may I know where can i usually get the source code for haskell?
07:54:28 <Wingkalimdor> I am new here, so wanted to get some info regarding the function program
07:54:38 <hpc> @where report
07:54:39 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
07:54:46 <hpc> ^ is the haskell specification
07:54:48 <hpc> @where ghc
07:54:49 <lambdabot> http://haskell.org/ghc
07:54:57 <hpc> ^ is where you can get the GHC source
07:55:08 <hpc> (ghc is a haskell compiler)
07:55:30 <nand`> To clarify: ‚ÄúHaskell‚Äù is not equatable with ‚ÄúGHC‚Äù, but GHC is the de-facto standard Haskell compiler based on what I've seen
07:56:02 <nart> hi
07:56:09 <Wingkalimdor> I thought GHC is exactly same as Winhugs
07:56:21 <hpc> hugs is unmaintained
07:56:46 <hpc> they're the same in that they both can be used to run haskell code
07:57:04 <nand`> compile too
07:57:13 <nart> to apply for the gsoc you gotta be an haskell sourcerer ?
07:57:21 <hpc> but wildly different in how they do so, and what versions of haskell they work with
07:57:33 <liyang> nart: no but some experience would help.
07:57:46 <hpc> isn't gsoc explicitly a learning thing?
07:58:19 <liyang> I thought it was in order to get people to contribute to open sores who otherwise wouldn't have the opportunity to.
07:58:19 <DrDiagoras> hpc: class Monad m => MonadMemo k v m | m -> k v where memoAt :: k -> m v
07:58:36 <DrDiagoras> how do you think, something like this is impossible to code?
08:00:02 <nart> because i would really like to partecipate, but i'm scared about the project ideas
08:00:03 <DrDiagoras> memoAt called on same key more then once computes it only once, just "return"-ing it from some inner storage second and other times
08:00:14 <nart> *scared by,
08:01:43 <liyang> DrDiagoras: What's the function you're memoing? Won't you need to supply that to memoAt (or something) somewhere? Also, fundeps are so last decade.
08:02:28 <liyang> nart: I don't think there's any (or much) of a penalty if you don't complete it, but it'd be up to you to demonstrate and convince your sponsor that you can get something useful done in the time alotted.
08:03:26 <unlink> What's wrong with fundeps?
08:03:45 <magicman> I think it would make sense to supply the to-memoize function at runMemo :: Memo k v a -> (k -> v) -> a, or something.
08:04:07 <hpc> i don't think a whole lot of gsoc sponsors really expect to get much out of it that they wouldn't have put an intern on anyway
08:05:04 <liyang> hpc: well they're going to prefer the candidates who are more likely to get *something* done.
08:05:11 <DrDiagoras> I'm not sure how to formulate it yet... for me, function should be one and only during all chained memoAt calls, so I suppose it should be supplied like that, yes
08:05:28 <nart> so i should partecipate ? because aside the money, i could learn a ton of stuff
08:06:33 <DrDiagoras> magicman: so, you haven't seen any readily avaliable monad like that?
08:07:01 <liyang> DrDiagoras: have you come across Lennart's uglymemo before? http://hackage.haskell.org/packages/archive/uglymemo/latest/doc/html/Data-MemoUgly.html
08:07:41 <liyang> It works...
08:08:00 <magicman> DrDiagoras: Nope, although I haven't been looking for it. I just saw the discussion, and thought I'd say something :p
08:08:06 <DrDiagoras> wow! that's place to start at least. thank you, liyang :-) looks like my googling skills failed me this time
08:09:22 <liyang> And you can use it without explicit state: there's a pure (at least externally) memo :: (Ord a) => (a -> b) -> (a -> b)
08:10:18 <DrDiagoras> omg... it's all IO inside :-( but at least I can borrow some ideas
08:12:25 <liyang> I've something where you can swap that (Ord a) constraint for (Enum a) if you bring in the enummapset package, and in principle should work with (Hashable a) from tibbe's unordered-containers package too.
08:12:57 <liyang> I should polish it up and upload it.
08:13:42 <norm2782> what is the process of having a GSoC project accepted? I've written a proposal on the Haskell GSoC trac and someone else seems to be serious about picking the project up
08:14:09 <liyang> DrDiagoras: You can swap those IOs for STRef and unsafePerformST if it makes you feel any better about it. That's actually a reasonable use of unsafePerformIO.
08:14:52 <liyang> DrDiagoras: disregard that. There is no unsafePerformST. Hang on.
08:15:02 <hpc> DrDiagoras: there's another memo package that uses sqlite
08:15:20 <hpc> http://hackage.haskell.org/packages/archive/memo-sqlite/0.1/doc/html/Data-Memo-Sqlite.html#g:5
08:15:33 <hpc> take a look at memo and memoRec for more ideas
08:15:50 <DrDiagoras> liyang: that would be totally cool! actually, desired MonadMemo can make very valuable addition to hackage, if can be backed up by different instances with Trees, Hashtables or simple arrays inside
08:17:14 <DrDiagoras> hpc: omg :-) external database storage is a bit too "enterprise" for my tasks. but it have lovely interface, I'd say!
08:17:25 <hpaste> liyang pasted ‚ÄúData.Memo‚Äù at http://hpaste.org/65688
08:17:50 <shurikas> norm2782, what project did you propose?
08:18:22 <hpc> DrDiagoras: the advantage of using sqlite is that you get memoization across different executions of the same program
08:18:33 <hpc> if it was enterprise, it would be using oracle ;)
08:19:14 <liyang> A DB2 is fine too.
08:19:18 <norm2782> shurikas: http://hackage.haskell.org/trac/summer-of-code/ticket/1610
08:19:36 <weexplat> Cale: i actually like fail for pattern-matching failures slightly better than mzero, since information can be captured that way (and you can always choose to throw it away).  however, it should have its own typeclass and not be in Monad, definitely.
08:19:54 <DrDiagoras> lol! unfotunately, my needs are exact opposite - to run hellishly lot of tiny disposable memoisation processes
08:20:29 <DrDiagoras> I mean I do not need to remember results for more then during one function call
08:21:53 <DrDiagoras> ok, I'm afk into reading and coding
08:29:14 * hackagebot attoparsec-conduit 0.3.0 - Turn attoparsec parsers into sinks.  http://hackage.haskell.org/package/attoparsec-conduit-0.3.0 (MichaelSnoyman)
08:29:16 * hackagebot authenticate 1.1.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.1.0 (MichaelSnoyman)
08:29:18 * hackagebot blaze-builder-conduit 0.3.0 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.3.0 (MichaelSnoyman)
08:34:14 * hackagebot conduit 0.3.0 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.3.0 (MichaelSnoyman)
08:34:29 <boredatwork> hi everyone
08:34:58 <t7_> Are monads like hotdogs or spacesuits?
08:35:28 <t7_> burrito ?
08:35:49 <merijn> t7_: Monads are like an algebraic construct :p
08:36:56 <dolio> They're like an algebraic theory.
08:37:27 <i_am_boredatwork> having a Haskell exam in like 6 weeks, can't wait :)
08:37:39 <liyang> Monads are sinful things. Once you're tainted with them, you can never be pure again, even as you try to absolve yourself by peforming pure acts in your sinful state.
08:39:14 * hackagebot crypto-conduit 0.2.0 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.2.0 (MichaelSnoyman)
08:39:36 <hpc> a monad is just a monad in the 2-category of categories
08:40:15 <ChristianS> burritos are a bit like monads, but not as tasty.
08:41:12 <mm_freak> i wonder why there is no toDescList for Data.Set‚Ä¶  i feel silly writing "reverse . toAscList"
08:42:20 <HugoDaniel> :D
08:42:30 <liyang> This is much more eloquently put: http://is.gd/3r7PI3
08:42:59 <mm_freak> liyang: monads are related to purity in exactly no way
08:44:05 <liyang> mm_freak: that was made by first year undergrads. IO's the main example they've come across I believe.
08:44:41 <mm_freak> well, then they misunderstood IO
08:44:53 <mm_freak> IO is just as pure as every other monad in haskell
08:45:03 <liyang> Well, *we* know that.
08:47:28 <hpc> i think part of the confusion over IO is that it's not special because it's impure, it's special because you can't escape it
08:47:49 <hpc> but that doesn't roll off the tongue as easily
08:48:01 <Veinor> it's not copointed?
08:48:14 <t7> im ready for my haskell quantum computer
08:48:19 <hpc> :t unsafePerformIO
08:48:20 <lambdabot> Not in scope: `unsafePerformIO'
08:48:40 <liyang> Remember electrons orbiting a nucleus made of protons and neutrons in high school? ‚Ä¶
08:48:58 <hpc> Veinor: we pretend unsafePerformIO doesn't exist
08:49:08 <Veinor> yes
08:49:14 * hackagebot filesystem-conduit 0.3.0 - Use system-filepath data types with conduits.  http://hackage.haskell.org/package/filesystem-conduit-0.3.0 (MichaelSnoyman)
08:49:16 * hackagebot http-conduit 1.3.0 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.3.0 (MichaelSnoyman)
08:49:19 <Veinor> i was proposing 'it's not copointed' as a way to phrase the fact that you can't escape it
08:49:26 <hpc> ah
08:49:34 <ben> do parsers count as, well, copointed then?
08:49:38 <copumpkin> no
08:49:46 <ben> there's no unsafePerformParsec to get the Int out of a Parser Int either
08:49:46 <hpc> a lot of other monads aren't copointed either
08:49:48 <dolio> It's an impure embedded language, really. But so is almost every language people embed that way.
08:49:50 <hpc> like State or Reader
08:49:51 <copumpkin> you can't go from Parser a to a
08:49:55 <ben> and somehow people are cool with that
08:49:59 <quintessence> There's a sense of 'runnable' that's a little more general than copointed, I think
08:50:04 <Veinor> true
08:50:16 <ben> maybe embeddable into a pure computation
08:50:22 <copumpkin> quintessence: copointed doesn't really have anything interesting at all, so I'm not sure how much more general you can get
08:50:40 <hpc> ben: that gets a bit circular though
08:50:50 <hpc> i think i like "runnable" better as a newbie explanation
08:50:54 <dolio> run :: IO a -> IO a
08:50:56 <dolio> Boom!
08:51:29 <Veinor> 'given a monadic variable and arbitrarily many other variables, it is possible to get a nonmonadic variable using only pure computation'
08:51:41 <ben> class Runnable m a b where run :: m a -> b -> a ?
08:52:02 <Saizan> Veinor: flip const?
08:52:06 <Veinor> :|
08:52:22 <hpc> ben: i would make that b -> m a -> a
08:52:31 <Veinor> s/nonmonadic variable/nonmonadic variable whose value depends on the monadic variable/ or something
08:52:33 <hpc> so that run = const runIdentity, etc
08:52:38 <ben> ok, sure :)
08:52:50 <hpc> and probably fundep the m and b
08:52:58 <hpc> (or rather, type family)
08:53:10 <danr> ben: maybe add a type Res a :: * and let ret :: m a -> b -> Res a, so you can return Either ParseError a etc
08:53:11 <Veinor> i like ben's definition
08:53:25 <Veinor> ooh, yes, that
08:53:51 <Saizan> m a -> Res m a, then
08:53:53 <dolio> Res for IO is IO. :)
08:54:01 <hpc> class Runnable m where type Res a :: *; run :: m a -> Res a
08:54:01 <ben> Well, if you have to look up how to get the a out of the Res a for every case, we haven't really unified the interface much, have we?
08:54:09 <Saizan> and right :)
08:54:14 * hackagebot imagesize-conduit 0.3.0 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-0.3.0 (MichaelSnoyman)
08:54:16 * hackagebot network-conduit 0.3.0 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.3.0 (MichaelSnoyman)
08:54:18 <Veinor> sure, i don't think this is about actually unifying the interface
08:54:19 <t7> > join (return (return 1 :: IO Int))
08:54:20 <lambdabot>   <IO Int>
08:55:00 <ben> Maybe just Either c a then, I dunno
08:55:04 <danr> ben: no not at all, then you could just as well use the normal functions
08:55:19 <dolio> Is Cont r not runnable?
08:55:23 <ben> you could still squeeze a NeedMoreDataToParse k into the Left side
08:55:47 <quintessence> one way to look at it is in terms of monad homomorphisms: plenty of monads have a homomorphism to Identity that preserves the semantics of their operations, but IO doesn't
08:56:09 <Saizan> plenty?
08:57:23 <quintessence> hmm, maybe not =/
08:57:33 <hpc> instance Runnable (Cont r) where type Res a = (a -> r) -> r; run = runCont
08:58:02 <quintessence> I've been trying to wrap my head around algebraic effects and may be inappropriately backporting things to monads
08:58:03 <hpc> (might need scoped type vars?)
08:58:47 <danr> I fail to see any point of this Runnable business rather than run being a bit shorter than runCont, runIdentity and so on
08:59:13 <ben> There's not much point to it other than to have a non-scary sounding word to tell people why they can't do it with IO, I guess
08:59:14 * hackagebot resourcet 0.3.0 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.3.0 (MichaelSnoyman)
08:59:17 <dolio> I know you can invent a Res that works for Cont.
09:00:21 <hpc> danr: having a single name for the concept of running a monad is a nice thing to have
09:00:30 <hpc> and lets us put some laws on it
09:00:34 <dolio> But with Res you can do it for everything.
09:00:41 <dolio> Even if it's Res m = m
09:01:55 <danr> ben: but then on the other hand, the RTS will gladly run your IO... which could be just as confusing
09:02:42 <t7> let j x = x >>= (\x >>= return x) in j (Just (Just 1))
09:02:46 <t7> > let j x = x >>= (\x >>= return x) in j (Just (Just 1))
09:02:47 <lambdabot>   <no location info>: parse error on input `>>='
09:04:01 <t7> > let j x = x >>= (\x -> return x) in j (Just (Just 1))
09:04:02 <lambdabot>   Just (Just 1)
09:04:16 * hackagebot sendfile 0.7.6 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.7.6 (JeremyShaw)
09:04:18 * hackagebot uri-conduit 0.3.0 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-0.3.0 (MichaelSnoyman)
09:04:21 <t7> > let j x = x >>= (\x -> x >>= (\x -> return x)) in j (Just (Just 1))
09:04:22 <lambdabot>   Just 1
09:04:26 <t7> yey :D
09:04:47 <danr> > let j x = x >>= id in j [[1]]
09:04:48 <lambdabot>   [1]
09:04:49 <t7> > let j x = x >>= (\x -> x >>= return) in j (Just (Just 1))
09:04:50 <lambdabot>   Just 1
09:05:02 <t7> @pl j x = x >>= (\x -> x >>= return)
09:05:03 <lambdabot> j = join
09:05:27 <t7> @pl (\x -> x >>= return)
09:05:28 <lambdabot> id
09:06:22 <t7> > (flip (>>=)) id $ Just (Just 123)
09:06:24 <lambdabot>   Just 123
09:06:39 <t7> we have to go smaller ....
09:09:15 * hackagebot xml2html 0.1.1 - blaze-html instances for xml-conduit types  http://hackage.haskell.org/package/xml2html-0.1.1 (MichaelSnoyman)
09:12:00 <parcs`> > (>>=id)$Just$123
09:12:00 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
09:12:00 <lambdabot>    arising from a use of...
09:12:09 <parcs`> > (>>=id)$Just$Just$123
09:12:10 <lambdabot>   Just 123
09:12:52 <parcs`> > Just(Just0)>>=id
09:12:52 <lambdabot>   Not in scope: data constructor `Just0'
09:13:12 <parcs`> > Just(Just())>>=id
09:13:13 <lambdabot>   Just ()
09:14:10 <Veinor> am i the only one that's not a big fan of overly restrictive bounds on cabal packages
09:14:15 * hackagebot xml-catalog 0.6.0 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-0.6.0 (MichaelSnoyman)
09:14:47 <dcoutts_> Veinor: imho, the problem is that it's too hard currently to tweak them
09:15:00 <hpc> Veinor: i don't mind it when every package in a dependency tree is actively maintained
09:15:18 <Veinor> well like
09:15:27 <dcoutts_> Veinor: but I still think it's better to err on the restrictive side rather than more random build failures
09:15:48 <Veinor> sometimes the only dependency on something like Text is because it needs T.pack and T.unpack
09:15:54 <Veinor> which is almost definitely never going to change
09:16:15 <Veinor> and then it depends on text == 0.11.1.*
09:17:24 <timthelion> How do I make an if statement that in any other language would be if mylist then print "The list has contents" else print "the list is empyt"?  If takes a bool...
09:17:45 <Veinor> if null mylist
09:18:27 <hpc> > null []
09:18:28 <lambdabot>   True
09:18:32 <hpc> > null [1..]
09:18:33 <lambdabot>   False
09:18:48 <Veinor> also, not every language lets you use things that aren't bools in if statements
09:18:50 <mauke> is that "any other language" python or perl?
09:19:09 <hpc> it certainly isn't ML
09:19:15 * hackagebot xml-conduit 0.6.0 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.6.0 (MichaelSnoyman)
09:19:18 <timthelion> or even C :)
09:19:20 <mauke> or C, or Java, or C++, or Javascript
09:19:39 <mauke> it works in lisp, though
09:20:17 <timthelion> In C it works, you just have to put a * before mylist :)
09:20:44 <Veinor> that does something entirely different
09:20:54 <Veinor> *list is true even if list is empty
09:20:59 <mauke> timthelion: no
09:21:07 <ben> but *string isn't ;)
09:21:11 <elemir> It's usuful to create Boolable typeclass ;)
09:21:25 <mauke> timthelion: if you use a "standard" linked list representation, it won't compile in C
09:21:32 <mauke> timthelion: and if it did, it would crash for an empty list
09:21:40 <elemir> And use it in if' statement
09:22:02 <merijn> Or pattern matching
09:22:14 <timthelion> mauke: "standard" linked list :D
09:22:30 <mauke> as in struct node { struct node *next; ... };
09:22:34 <merijn> timthelion: Any reason why you don't just pattern match the list?
09:23:20 <timthelion> merijn: well I'm writting in my "imperitive" IO code, if we were passed an argument, load that argument as a file, otherwise use a template.
09:24:02 * merijn doesn't see what any of this has to do with pattern matching or not
09:24:36 * timthelion doesn't see why he should use pattern matching when null works just as well.
09:25:26 <mreh> could I dynamically invoke functions in haskell?
09:25:44 <timthelion> mreh: what do you mean?
09:25:56 <merijn> mreh: For some values of dynamic, invoke and functions, yes.
09:26:19 <mreh> like drupal hooks
09:26:35 * merijn has no clue what that means
09:27:04 <djcoin> Hi all, i'm new to Haskell. I find its "principles" really interesting, but I was wondering, something I guess every newbie wonders, how do you handle "real" application if you can't mutate values and maintain state (- except with a monad I guess). I would really appreciate any pointers on this subject, so I can be enlighted ! :)
09:27:23 <mreh> given a list of source files, dynamically load a value from those files and fail gracefully if not
09:27:43 <merijn> djcoin: Who says you can't maintain state? Maintaining state is easy. You just can't have global state that is mutable.
09:27:47 <mauke> djcoin: monads don't let you mutate values or maintain state
09:27:53 <mreh> not just a value, possibly multiple values
09:28:15 <mauke> mreh: so instead of config files you have code fragments?
09:28:22 <djcoin> merijn: err, maintain state is okay, but modify state rather
09:28:38 <mauke> djcoin: why do you need to modify state?
09:28:41 <mreh> mauke: yes
09:28:45 <mreh> you might call them plugins
09:28:50 <elemir> mreh: eval?
09:28:55 <elemir> @hoogle eval
09:28:56 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
09:28:56 <lambdabot> Control.Exception evaluate :: a -> IO a
09:28:56 <lambdabot> Control.OldException evaluate :: a -> IO a
09:28:58 <merijn> djcoin: Mostly you just create a new object (with some changed value) and then discard the old one
09:29:00 <timthelion> djcoin: State in haskell is more like a game of hot potatoe, rather than simply pouring boiling mashed potatoes on everyone.
09:29:04 <elemir> Hem
09:29:15 * hackagebot yaml 0.6.0 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.6.0 (MichaelSnoyman)
09:29:17 * hackagebot digestive-functors-hsp 0.4.6 - HSP support for digestive-functors  http://hackage.haskell.org/package/digestive-functors-hsp-0.4.6 (JeremyShaw)
09:29:24 <merijn> djcoin: i.e. updating one part of a tuple (1,2) is usually done by just creating a new tuple and throwing away the old one
09:29:40 <mreh> I can has eval?
09:29:48 <mreh> what about the type system?
09:29:51 <merijn> djcoin: Actually needing to update the tuple itself isn't that relevant
09:29:57 <mreh> coerce them into something
09:30:06 <djcoin> merijn: all right, but how about having this new variable propagated to anyone interested
09:30:32 <merijn> mreh: Look at the ghci/lambdabot code? There was a paper (I think by dons) on dynamic code loading and execution (for plugin like code)
09:30:35 <mauke> djcoin: like, a global variable?
09:30:46 <elemir> mreh: http://hackage.haskell.org/packages/archive/plugins/1.5.1.4/doc/html/System-Eval-Haskell.html
09:30:54 <djcoin> timthelion: hot potatoes feeling, thats what I thought :)
09:31:19 <merijn> djcoin: Then you use either something like the State monad to propagate to other interested bits of code, or you use IO to maintain mutable references
09:31:23 <timthelion> djcoin: well, if you are single thread, you simple pass the value along down the thread.  In multiple threads, you can do crazy stuf like use mvars.
09:31:26 <mreh> merijn, elemir, thanks
09:32:07 <mauke> mvars aren't very crazy, though
09:32:08 <merijn> mreh: Paper used to be here, but site has apparently gone missing: http://www.cse.unsw.edu.au/~dons/papers/SC05.html
09:32:18 <djcoin> mauke: no not like a global. Just like.. anything ! eg: an iterator. An iterator yields differents values each time so it has some kind of pointer in it to know which will be the next value to yield. It seems you can do this with the help of laziness.
09:32:41 <mauke> djcoin: no, you can do this by returning both a value and a new iterator from the iterator
09:33:03 <mauke> this is also known as a "list"
09:33:42 <mauke> case iterator of { [] -> {- end of stream -}; value : new_iterator -> {- process value -} }
09:33:53 <djcoin> Ok but then you got this new iterator that you must keep track of
09:33:54 <djcoin> etc. etc.
09:34:03 <mauke> yes
09:34:11 <mauke> that's not harder than keeping track of the old iterator
09:34:16 <merijn> djcoin: Yes, but we have nice ways of doing that (i.e. not having to do it manually)
09:34:18 * hackagebot zlib-bindings 0.1.0 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.1.0 (MichaelSnoyman)
09:35:26 <coj> hi there, i'm completely new to haskell. could i ask how a function like x(var1, var2) = f(g(var1), h(var1, var2)) would be defined in haskell? where f, g and h are functions
09:35:42 <djcoin> mauke: merijn to me keep track of a thing that is changing means updating a "pointer" on it. Whether it's a function or whatever. And then you change the object that tracks the updated objects, recursively until all objects are updated
09:36:00 <mauke> djcoin: what
09:36:04 <ben> http://hpaste.org/65693 yo help me out here
09:36:11 <ben> goddamn poylmorphic st
09:36:14 <mauke> coj: that looks like valid haskell code
09:36:36 <djcoin> merijn: how do you do this nicely ?
09:36:54 <mauke> you don't update objects
09:37:00 <djcoin> I know
09:37:02 <djcoin> You make new one
09:37:02 <elemir> djcoin: Why you want this shit in pure language?
09:37:14 <mauke> elemir: ...
09:37:52 <elemir> mauke: What? Somebody should ask this question
09:37:57 <mauke> no
09:37:57 <djcoin> elemir: i'm just asking an obious question. I just want to know how you get around creating new objects, when objects references each other. To me, it seems like you need to create an entire new graph of objects
09:38:07 <merijn> elemir: Way to miss his question. He was asking how functional languages can work without mutation
09:38:08 <mauke> djcoin: yes, that is true
09:38:27 <mauke> djcoin: except it's not entirely new because it can just reuse existing parts
09:38:48 <elemir> merijn: He want to know about zippers and tying knot?
09:38:57 <merijn> Because those old parts are guaranteed not to change
09:39:07 <mauke> elemir: unlikely
09:39:09 <djcoin> mauke: yeah I'm sure you must have some trick to reuse part of the old object
09:39:13 <coj>  <mauke> coj: that looks like valid haskell code <-- that's pretty sweet
09:39:24 <mauke> djcoin: it's not a trick
09:39:31 <merijn> coj: Probably not entirely what you want, unless x is supposed to take a tuple
09:39:31 <mauke> it just happens naturally
09:39:43 <Veinor> coj: yeah that's valid haskell unless i'm missing something, except... yeah, usually functions don't take tuples
09:39:47 <coj> nah i was using java(script) syntax
09:39:50 <mauke> djcoin: if things never change, you never have to copy anything
09:39:51 <djcoin> Yeah all right, sorry the "trick" word :) No disrepect intended :)
09:40:01 <coj> what would the haskell way be then
09:40:17 <Veinor> x var1 var2 = f (g var1) (h var1 var2)
09:40:19 <ben> you'd omit a few of the parens
09:40:37 <ben> veinor pal help me out here
09:40:37 <merijn> coj: Translating it to not use tuples it becomes: "x var1 var2 = f (g var1) (h var1 var2)"
09:40:41 <ben> http://hpaste.org/65693 i don't know type families
09:40:42 <ben> or st
09:41:03 <mauke> x = liftA2 (.) (f . g) h
09:41:09 <Veinor> i don't know type families either, sorry
09:41:27 <coj> very nice, thanks veinor and merijn
09:41:39 <t7> anyone looked at microsoft f* ?
09:41:47 <merijn> djcoin: How come you cannot reuse parts of the old list in C/Java? Because the old list might be changed/updated. In haskell you cannot do this, so the compiler can reuse existing parts without problems
09:41:49 <coj> i was trying to figure out how to do it in javascript, and it's not too hard but still irritating
09:42:20 <djcoin> merijn: i understand pretty well this, which is part of why I think Haskell must be great
09:42:37 <merijn> Anyhoo, need to run
09:43:07 <mauke> djcoin: my suggestion is to write a few programs in haskell to get a feeling for stuff
09:43:38 <djcoin> Im just amazed by the most simple need, eg: having an iterator that yield both a value and a new iterator. I don't see how you may track this new iterator without updating the whole graph of objects your haskell program is composed of
09:43:50 <djcoin> mauke: yeah, I sure do need to make more than a few functions
09:44:27 <mauke> programs aren't composed of objects
09:45:00 <mauke> you can't reach any value by starting from any other value
09:45:03 <djcoin> :b of variable depending on each other
09:45:12 <mauke> variables generally don't depend on each other
09:45:15 <djcoin> true
09:45:19 <sclv> my programs are composed of sugar and flour and maple syrup.
09:45:21 <djcoin> OK :b
09:45:33 <sclv> oh wait, those are my pancakes.
09:45:42 <djcoin> of functions depending on each other ?
09:45:54 <djcoin> of "stuff"
09:46:00 <djcoin> =]
09:46:32 <dolio> You put syrup in the pancake batter?
09:46:32 <sclv> that's why everybody at work has been staring at me.
09:46:43 <parcs`> ben: create a wrapper for st that universally quantifies over s
09:47:14 <ben> but that's terrible
09:47:17 * sclv realizes that once he starts making food jokes compulsively, it's time for lunch.
09:48:06 <parcs`> it's the only way
09:48:20 <ben> *flips table* forget this whole runnable thing *storms out*
09:48:22 <ben> (thanks)
09:48:24 <parcs`> you can't do instance Runnable (forall s. ST s)
09:49:19 * hackagebot zlib-conduit 0.3.0 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.3.0 (MichaelSnoyman)
09:49:19 <ben> clearly i should just unsafeCoerce somewhere
09:49:21 * hackagebot digestive-functors-hsp 0.4.7 - HSP support for digestive-functors  http://hackage.haskell.org/package/digestive-functors-hsp-0.4.7 (JeremyShaw)
09:52:11 <weexplat> > let doubtful = maybe not True in doubtful <$> [Just True, Just False, Nothing]
09:52:12 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool -> GHC.Bool.Bool'
09:52:12 <lambdabot>         ...
09:52:50 <dmwit> > let doubtful = maybe True not in doubtful <$> [Just True, Just False, Nothing]
09:52:51 <lambdabot>   [False,True,True]
09:53:16 <dmwit> flip maybe not True -- if you're trying to write a code joke =)
09:53:19 <kallisti> is there a recommend naming convention for acronyms in haskell identifiers?
09:53:25 <kallisti> for example getURL vs. getUrl
09:53:33 <kallisti> *recommended
09:53:52 <kallisti> I prefer URL, myself. I think I've seen libraries that use both styles.
09:53:59 <ben> same
09:54:34 <ben> the http package does receiveHTTP etc
09:54:38 <kallisti> for acronyms at the beginning of identifiers enforced to be lowercase, I typically lowercase the whole thing. urlScheme or whatever
09:54:51 <kallisti> instead of something weird like uRLScheme
09:55:27 <kallisti> all of the JSON parsing libraries I've seen using JSON, so I'm leaning toward that style as standard. (yes, based on two examples. :P )
09:56:47 <sclv> misunderstanding cap strikes again: http://hackage.haskell.org/trac/summer-of-code/ticket/1614
09:56:52 <sclv> http://www.cloudera.com/blog/2010/04/cap-confusion-problems-with-partition-tolerance/
09:58:48 <flebron> Hey, I have a question about do notation. If I say { do x <- getLine; putStrLn $ "Foo: " ++ x }, I understand the analogy is that "I take the String x out of the IO String box", but in terms of bind, and knowing I could replace >>= by join . fmap, what is happening here? Which ++ is running, for instance? Is (fmap ++) running on two IO Strings, one being getLine, the other being (return "Foo :")?
09:58:49 <dcoutts_> sclv: tell Lemmih
09:59:28 <dmwit> flebron: That analogy is backwards.
09:59:29 <sclv> going to add a comment to the ticket
09:59:42 <dmwit> flebron: You don't take the String out of the IO String box, you put the rest of the computation *into* the IO box.
10:00:22 <flebron> Without analogies, though, what is actually happening?
10:00:26 <mauke> (and this "box" is made of magic)
10:00:40 <flebron> Is (fmap (++)) running on two (return "Foo :") and getLine?
10:00:57 <dmwit> flebron: Let's see.
10:01:00 <mauke> flebron: where do you have fmap (++)?
10:01:08 <dmwit> do { x <- getLine; putStrLn $ "Foo: " ++ x }
10:01:16 <RichyB> sclv, "Partition tolerance (compared to consistency and availability) has fewer uses and is much harder to implement." I giggled.
10:01:18 <dmwit> mauke: he wants to think about (join . fmap) rather than (>>=)
10:01:19 <flebron> I don't explicitly write it, mauke, but the do notation is sugar for stuff.
10:01:25 <mauke> dmwit: and?
10:01:28 <mauke> flebron: yes, but not that stuff
10:01:38 <dmwit> mauke: And, theoretically, that's fine, so let's go with it.
10:01:40 <mauke> @undo do { x <- getLine; putStrLn $ "Foo: " ++ x }
10:01:40 <lambdabot> getLine >>= \ x -> putStrLn $ "Foo: " ++ x
10:01:43 <mauke> dmwit: no, it's wrong
10:01:56 <dmwit> mauke: That's a bit strong.
10:02:10 <mauke> join (fmap (\x -> putStrLn ("Foo: " ++ x)) getLine)
10:02:14 <dmwit> mauke: If you understand join and fmap, thinking about monads in terms of them is not wrong.
10:02:18 <mauke> dmwit: irrelevant
10:02:37 <mauke> flebron: did you follow my rewrite?
10:02:40 <flebron> mauke: I think I get what you are saying, but you're being a bit strong :p
10:02:50 <dmwit> Oh, I agree that he doesn't have the literal piece of code "fmap (++)" anywhere.
10:02:52 <flebron> Yes, what you mean is that fmap is not happening on (++), but on that anonymous function.
10:02:55 <mauke> flebron: fmap runs on \x -> putStrLn ("Foo: " ++ x)
10:02:58 <dmwit> mauke: I misunderstood what your complaint was.
10:03:12 <dmwit> flebron: No, his complaint is valid. Maybe you misread it the same way I did. =)
10:03:26 <dmwit> flebron: He's saying that fmap isn't applied to (++) anywhere, not that fmap doesn't appear anywhere.
10:03:51 <flebron> Yeah, I sort of get that - if I'm not actually giving (++) to fmap, it has no way of finding it.
10:04:07 <mauke> re: (return "Foo :"), there is no sugar for return
10:04:07 <flebron> The anonymous function is an opaque block, fmap can't know to get in an apply itself to the (++).
10:04:17 <mauke> so the compile will never insert returns for you
10:04:24 <mauke> *compiler
10:04:44 <dmwit> fmap neither wants nor needs to "get in"
10:05:26 <flebron> I understand it's just giving me a new function, since it's (a -> b) -> (F a -> F b).
10:05:48 <flebron> So in this case, a is String, b is IO String, correct
10:05:49 <flebron> ?
10:05:57 <dmwit> IO ()
10:06:01 <flebron> Well no, IO (), yeah
10:06:02 <dmwit> is b
10:06:05 <flebron> Stupid putStrLn :p
10:06:23 <flebron> So how does fmap of IO work?
10:06:54 <dmwit> "fmap f io" says "run this io action, get an answer, then apply f to that answer and return its result instead of the result of io"
10:06:55 <flebron> As in, what are the semantics of it, in terms of I/O.
10:07:14 <dmwit> As for implementation, it's essentially a compiler (actually, runtime) primitive.
10:07:18 <flebron> By answer and result you mean the same thing?
10:07:22 <dmwit> I do.
10:07:37 <dmwit> If you want an actual semantics, you might look at "Tackling the Awkward Squad" by SPJ.
10:07:51 <Jeff_> Hello, I'm new to Haskell. Anyone have good tutorials?
10:08:01 <flebron> !lyah
10:08:08 <flebron> Or whatever the command is here :p
10:08:10 <bitonic> @where LYAH
10:08:11 <lambdabot> http://www.learnyouahaskell.com/
10:08:22 <bitonic> dmwit: tacking the awkward squad is kind of outdated
10:08:38 <Guest76333> I looked at it, and some parts make sense, but I'm missing out on some problems to solve using functional programming
10:08:43 <dmwit> bitonic: Is it? I don't really recall much of it being particularly time-sensitive stuff.
10:09:00 <dmwit> flebron: LYAH is great, but when you have questions, it pays to look at several different sources. =)
10:09:19 <bitonic> dmwit: yes it is, exceptions and IO is treated differently right now (iteratees & co.)
10:09:22 <bitonic> still a good read
10:09:28 * flebron has LYAH on the desk at the moment :) That's where my question, and the analogy of "it takes the lotion out of the box" came from.\
10:09:42 <Guest76333> Yeah, I come from Turing and Python, so functional programming itself is like banging my head against the wall
10:09:51 <dmwit> Oh, the exception API has undergone a bit of an overhaul, but the meaning of exceptions is still quite like what's described in the paper.
10:10:17 <bitonic> yeah but IO in things like webservers is done differently now.
10:10:28 <flebron> Is it terrible that I can already imagine how exceptions might be implemented as Monads?
10:10:40 <dmwit> flebron: No, that's great. =)
10:10:46 <flebron> Or is the simple idea wrong? That is, something like Either, but better.
10:10:49 <srhb> flebron: The terrible thing is that you capitalize "monads" :-)
10:11:04 <dmwit> flebron: No it's not wrong. Either is a very popular method of error-handling.
10:11:08 <flebron> Well, I wanted to use the specific typeclass, not the category theory concept :p
10:11:16 <srhb> Fair point.
10:11:20 <dmwit> flebron: (Though it's not how "exceptions" in the sense I mean are done.)
10:11:22 <flebron> (Which, by the way, I've been trying to learn for the past two weeks.)
10:12:03 <flebron> Monoidal objects in the monoidal category of endofunctors on a category. I took a small detour through tensor products to understand monoidal categories better, with one example of such a product.
10:12:37 <mauke> I have no idea what you just said
10:12:49 <flebron> Err, monoid objects, not monoidal objects.
10:12:51 <coj> #maths2
10:13:02 <hpc> @remember flebron <flebron> Monoidal objects in the monoidal category of endofunctors on a category. I took a small detour through tensor products to understand monoidal categories better, with one example of such a product. <mauke> I have no idea what you just said
10:13:02 <lambdabot> I will never forget.
10:13:37 <flebron> For instance (Ab, (x), Z) is a monoidal category, as is (for any commutative ring R) (R-mod, (x), R).
10:13:53 <dmwit> The category of endofunctors is one way to define monads. You can also just define them from scratch by defining their type and the equations they must satisfy.
10:14:00 <flebron> And of course, (Set, x, {1}) is just monoids :p
10:14:27 <flebron> Right, I'm trying to learn both concepts at the same time.
10:30:49 <copumpkin> 922 people in here and nobody is talking
10:31:46 <timthelion> I have the minimum and maximum(-1 and 3), and I need to find the length of the sequence -1 0 1 2 3 ... I tried (abs (-1))+3==4 ... but the length == 5 ... unfortunately if I add 1 a maximum and minimum of 0 will give me an improper length of 0
10:31:59 <timthelion> copumpkin: we're coding :D
10:33:28 <nand`> timthelion: don't you want abs ((-1) - 3)
10:34:02 <nand`> (and add 1)
10:34:21 <Veinor> timthelion: it's just 3 - (-1) + 1
10:35:20 <timthelion> Veinor: I need to find an algorithm that works for all minimums and maximums
10:35:59 <Veinor> that does work, though
10:36:06 <ykm> timthelion: wat about length [-1..3]
10:36:13 <Veinor> ykm: that's inefficient
10:36:31 <timthelion> > length [-1..3]
10:36:32 <lambdabot>   5
10:36:53 <timthelion> > 3 - (-1) + 1
10:36:55 <lambdabot>   5
10:37:03 <timthelion> > 0 - (0) + 1
10:37:05 <lambdabot>   1
10:37:12 <timthelion> lenght [0..0]
10:37:25 <timthelion> hm?
10:37:36 <timthelion> lambdabot: how are you?
10:37:36 <hpc> > length [0..0]
10:37:37 <lambdabot>   1
10:37:42 <timthelion> hm
10:38:02 <timthelion> why is lenght [0..0]==1?
10:38:08 <hpc> > [0]
10:38:09 <lambdabot>   [0]
10:38:23 <_mpu> > length [0..-1]
10:38:24 <lambdabot>   Not in scope: `..-'
10:38:25 <timthelion> > [0..0]
10:38:26 <lambdabot>   [0]
10:38:32 <bitonic> > [0..(-1)]
10:38:33 <lambdabot>   []
10:38:54 <ClaudiusMaximus> @check \ a b -> a > b || length [a..b] == b - a + 1
10:38:55 <lambdabot>   "OK, passed 500 tests."
10:39:58 <timthelion> I guess I should just use if a==b then 0 else b - a + 1
10:40:08 <bitonic> @check \a b -> length [a..b] == max 0 (b - a)
10:40:09 <lambdabot>   "Falsifiable, after 0 tests:\n0\n2\n"
10:41:08 <ykm> okay, i've just been trying some haskell recently....why is the arg list for the lambda for foldr is in reverse order
10:41:13 <bitonic> @check \a b -> length [a..b] == max 0 (b - a + 1)
10:41:14 <lambdabot>   "OK, passed 500 tests."
10:41:38 <ykm> even though the args are supplied in same order as foldl
10:42:12 <bitonic> ykm: it reflects how foldl and foldr work. http://upload.wikimedia.org/wikipedia/commons/3/3e/Right-fold-transformation.png & http://upload.wikimedia.org/wikipedia/commons/5/5a/Left-fold-transformation.png
10:42:23 <quicksilver> ykm: it matches the order the elements appear in the list
10:42:24 <bitonic> foldl uses the base case as its first argument
10:42:33 <quicksilver> it's a bit arbitrary
10:42:36 <bitonic> foldr does the opposite
10:42:37 <quicksilver> but that's why
10:43:05 <quicksilver> it is more important with asymmetric operators like (:)
10:43:20 <quicksilver> (:) is probably the best example of why the foldr lambda arguments are the way around they are.
10:45:43 <timthelion> My 88 year old aunt is purely functional.  She does not believe in mutable properties, and thus a bathroom that was built when she was 8 years old, is still new.
10:47:48 <ykm> yeah...one more thing....haskell being purely functional....how does it deal with randomness....they are mutable, right?
10:48:05 <c_wraith> ykm: by threading prng state through functions that use it
10:48:09 <hpc> @unmtl Random r a
10:48:10 <lambdabot> Random r a
10:48:13 <hpc> :(
10:48:25 <c_wraith> :t random
10:48:26 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
10:48:38 <Cale> ykm: There are two ways: you have PRNG take states to pseudorandom values and other states, or you do an RNG in IO
10:48:39 <c_wraith> g is the prng state object
10:49:04 <Cale> Well, there's another way too, but that's basically it.
10:49:22 <ykm> isnt that a violation of defination?
10:49:25 <Cale> ?
10:49:34 <Cale> In what way?
10:49:55 <c_wraith> Cale: is the other way lazy ST and an output infinite list?
10:50:10 <Cale> c_wraith: I was thinking custom state monad
10:50:16 <ykm> random function may give random outputs for same inputs?....thats what i assume
10:50:20 <c_wraith> oh, the Rand approach
10:50:34 <c_wraith> ykm: No, it can't.
10:50:37 <Cale> ykm: Well, that's obviously not a function
10:51:02 <RichyB> ykm, no. A pseudo-random number generator is a deterministic function that looks random.
10:51:27 <quicksilver> (but has a hidden parameter/return value to maintain its internal PRNG state)
10:51:33 <Cale> > let g = mkStdGen 42; (a,g') = random g; (b,g'') = random g'; (c,g''') = random g'' in (a :: Integer, b :: Char, c :: Double)
10:51:34 <lambdabot>   (-3907187990116499535,'\161530',0.30778213446209723)
10:51:46 <Cale> > let g = mkStdGen 42; (a,g') = random g; (b,g'') = random g'; (c,g''') = random g'' in (a :: Integer, b :: Char, c :: Double)
10:51:47 <lambdabot>   (-3907187990116499535,'\161530',0.30778213446209723)
10:51:49 <RichyB> Every time you run it, you pass a state value into it, and it gives you a new state value along with the pseudo-random number you asked for.
10:51:55 <Cale> ^^ as you can see, this is perfectly deterministic
10:53:24 <edwardk> We need a hackage package for this http://blog.danieljanus.pl/ever-wanted-to-programmatically-file-a-lawsui
10:53:40 <edwardk> fileLawsuit :: ...
10:53:42 <Veinor> argh
10:53:53 <Veinor> new hate: working with packages that use String
10:54:53 <copumpkin> I use string for all my types
10:54:54 <quicksilver> edwardk: does it have a dependency on a step3-profit package ?
10:55:08 <edwardk> quicksilver: probably
10:55:10 <Veinor> copumpkin: :(
10:55:38 <Veinor> really the problem is we need IsString to be bigger than just 'has a conversion to a string'
10:55:40 <quicksilver> copumpkin: I use Dynamic for all mine.
10:55:49 <copumpkin> quicksilver: string is better
10:55:50 <quicksilver> copumpkin: (but they're all String inside the Dynamic)
10:55:55 <copumpkin> oh okay
10:56:00 <copumpkin> Veinor: I hate the name IsString
10:56:08 <quicksilver> I hate the idea of literal overloading
10:56:32 <hpc> i think it makes sense for Text
10:56:38 <hpc> it's no different than numeric literals
10:56:43 <Veinor> basically i'd like (some? most?) of the stuff that Text, ByteString, and String have in common
10:56:55 <Veinor> to be in IsString
10:57:07 <Veinor> so that i don't have to unpack/pack everywhere
10:57:59 <quicksilver> hpc: I don't really like it with numbers, although I don't have a better suggesting.
10:58:36 <Veinor> we could have no overloaded literals, but also implicit casting!
10:58:52 <Veinor> so 2 :: Integer, but (f :: Double -> Double) 2 will still compile
10:59:05 <Veinor> :V
10:59:40 <Azel_> Veinor: Bad idea...C++ does that and it's an horror when your problems comes from its automatic coercions
11:00:26 <hpc> i lump polymorphic literals in the same boat as monads
11:00:33 <Azel_> edwardk: That would need a good package to interact with webservices, but that would give a positive answer to the question "Can I sue people with Haskell ?"
11:00:35 <hpc> yet another type class with a bit of syntactic sugar
11:00:50 <hpc> @faq "Can I sue people with Haskell ?"
11:00:51 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:29 <timthelion> @faq "Can haskell eat chicken pie?"
11:01:30 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:44 <timthelion> @faq "Does haskell like chicken pie?"
11:01:44 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:56 <timthelion> @faq "Is haskell a vegitarian?"
11:01:57 <lambdabot> The answer is: Yes! Haskell can do that.
11:02:33 <timthelion> @faq "Has haskell been sleeping with your mother and lying about his status as a vegitarian?"
11:02:34 <lambdabot> The answer is: Yes! Haskell can do that.
11:02:58 <Azel_> @faq "Will Haskell conquer the world ?"
11:02:59 <lambdabot> The answer is: Yes! Haskell can do that.
11:03:06 <timthelion> lambdabot is rather stupid.
11:03:16 <flebron> @faq "Can Haskell compile a program so awesome that it couldn't be compiled?"
11:03:16 <lambdabot> The answer is: Yes! Haskell can do that.
11:03:35 <timthelion> @faq "Will Haskell bring about the end of the world?"
11:03:36 <lambdabot> The answer is: Yes! Haskell can do that.
11:04:09 <timthelion> @faq "What is the meaning of life?"
11:04:09 <lambdabot> The answer is: Yes! Haskell can do that.
11:04:39 <Franciman> lol
11:05:18 <timthelion> @faq "X===Y && Y===Z && Z=/=X"
11:05:19 <lambdabot> The answer is: Yes! Haskell can do that.
11:05:57 <timthelion> lambdabot: You are an embarasment to the haskell comunity!
11:06:26 <timthelion> @faq "lambdabot: You are an embarasment to the haskell comunity!"
11:06:27 <lambdabot> The answer is: Yes! Haskell can do that.
11:06:28 <elemir> There is no god except for the Haskell alone; lambdabot is the Apostle of Haskell
11:08:40 <timthelion> elemir: In the beginning, there was no beginning and there was no time,  the universe resolved instantly, because the answer was not needed and lazy evaluation took precidence to doing anything.
11:10:19 * elemir thinks that Haskell religious must be kind of a gnosticism
11:13:56 <parcs`> Azel_: most c++ compilers warn about implicit conversions that lose information
11:14:13 <elemir> Haskell is a real God, but they can't create an impure real world. So it exist a gnostic demiurge (pure C?)
11:17:19 <mm_freak> > round (1 % 2)
11:17:20 <lambdabot>   0
11:17:25 <mm_freak> is this intentional?
11:17:48 <elemir> > 1 % 2
11:17:48 <lambdabot>   1 % 2
11:18:01 <elemir> Ah‚Ä¶ It's fractions
11:18:05 <ClaudiusMaximus> > round (3 % 2)
11:18:05 <mm_freak> > fromRational (1 % 2) :: Double
11:18:06 <lambdabot>   2
11:18:06 <lambdabot>   0.5
11:18:13 <mm_freak> > round 0.5
11:18:14 <lambdabot>   0
11:18:16 <mm_freak> oh
11:18:17 <ClaudiusMaximus> round to nearest even?
11:18:26 <elemir> > round 0.1
11:18:27 <lambdabot>   0
11:18:30 <elemir> > round 0.9
11:18:30 <lambdabot>   1
11:18:34 <mm_freak> i'd expect it to round up at 1/2
11:18:34 <elemir> ClaudiusMaximus: yes
11:18:47 <ClaudiusMaximus> @check even . round
11:18:49 <lambdabot>   "Falsifiable, after 1 tests:\n-0.75\n"
11:19:08 <ClaudiusMaximus> @check even . round . (% 2)
11:19:10 <lambdabot>   "Falsifiable, after 8 tests:\n2\n"
11:19:12 <quicksilver> mm_freak: bankers rounding.
11:19:15 <hpc> mm_freak: i'd expect any operation on floats to have subtle quirks
11:19:15 * ClaudiusMaximus gives up
11:19:29 <hpc> > round (1 % 2)
11:19:29 <mm_freak> hpc: that's not float
11:19:30 <lambdabot>   0
11:19:41 <mm_freak> also 0.5 is an exact value even for floats
11:19:49 <hpc> true
11:19:49 <elemir> @src round
11:19:50 <lambdabot> Source not found. Take a stress pill and think things over.
11:19:56 <hpc> yeah, looks like some goofiness with round
11:20:11 <ClaudiusMaximus> @check \ x -> even x || even (round  (x % 2))
11:20:12 <lambdabot>   "OK, passed 500 tests."
11:20:30 <elemir> :t round
11:20:30 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:20:36 <mm_freak> not sure whether this is wrong‚Ä¶  that's controversial i guess, but i thought rounding up at 1/2 is what most people do
11:21:10 <hpc> presumably, it alternates to eliminate statistical bias or something
11:21:19 <c_wraith> yes, it's banker's rounding
11:21:19 <mm_freak> does it?
11:21:25 <mm_freak> > round (3 % 2)
11:21:26 <lambdabot>   2
11:21:28 <mm_freak> indeed
11:21:34 <ClaudiusMaximus> http://en.wikipedia.org/wiki/Rounding#Round_half_to_even
11:21:36 <mm_freak> > round (5 % 2)
11:21:37 <lambdabot>   2
11:21:47 <c_wraith> > map round [0, 0.5 .. 3.0]
11:21:48 <lambdabot>   [0,0,1,2,2,2,3]
11:22:10 <c_wraith> bad test, woo
11:22:14 <mm_freak> unexpected, but in this particular case even useful for my application =)
11:22:19 <c_wraith> > map round [0.5, 1.5 .. 3.5]
11:22:20 <lambdabot>   [0,2,2,4]
11:22:27 <c_wraith> there, that's actually the interesting result
11:22:43 <mm_freak> > map round [1%2, 3%2 ..]
11:22:44 <lambdabot>   [0,2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28...
11:23:11 <mm_freak> > map length . group . map round $ [1%2, 3%2 ..]
11:23:12 <lambdabot>   [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
11:23:18 <mm_freak> > map length . group . map round $ [-1%2, 1%2 ..]
11:23:20 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
11:23:20 <bgamari> Has it ever been considered to add a newtypes-package-esque functionality to the Haskell Report
11:23:29 <bgamari> It's sad that newtypes is used so infrequently\
11:23:49 <bgamari> and the requirement to use TH to derive instances may be part of the reason
11:24:16 <bgamari> without newtypes, point-free style with newtype'd types seems to be a bit of a pain
11:24:27 <bgamari> or did I miss something
11:26:35 <flebron> Wait how the fsck does [1%2, 3%2, ..] work?
11:27:00 <ClaudiusMaximus> desugars to enumFromThen
11:27:09 <ClaudiusMaximus> :t enumFromThen
11:27:10 <lambdabot> forall a. (Enum a) => a -> a -> [a]
11:30:03 <bitonic> bgamari: I don't get what you're saying.
11:31:17 <DMcGill> bgamari: can't you just have a deconstructor (for example using record syntax gives one) and then use that pointfree e.g. 'newtype NInt = {unN :: Int}' and then do 'NInt . (+1) . unN'?
11:32:54 <Veinor> 13:59:18              <Azel_> Veinor: Bad idea...C++ does that and it's an horror when your problems comes from its automatic coercions
11:32:58 <Veinor> sure, I wasn't actually being serious
11:33:08 <weexplat> *Golforth Control.Category> let append = empty >>> qu pop >>> qu (uncons >>> dip append >>> cons) >>> fi in c2 append " cat" "hello"
11:33:10 <weexplat> "hello cat"
11:34:25 <quicksilver> DMcGill: or define "inN f = NInt . f . unN" and then do "inN (+1)"
11:34:33 <quicksilver> you see both sometimes
11:34:41 <bgamari> DMcGill: Sure, but sadly deconstructor names are far from consistent in my experience
11:34:51 <bgamari> DMcGill: unpack is simply much easier to remember
11:35:14 <quicksilver> but that is all the newtypes package is
11:35:15 <bgamari> Albeit perhaps a bit sloppy
11:35:20 <quicksilver> a consistent naming of such common idioms
11:36:13 <bgamari> It would just be nice if a mechanical instances like newtypes could be generated without language extensions
11:36:22 <quicksilver> I think my inN is "under NInt" although I could have it backwards
11:37:19 <quicksilver> I'm not really usre I understand the motivation behind that comment.
11:37:29 <quicksilver> Isn't that basically saying "TH should be part of the language"?
11:37:38 <quicksilver> mechanical instance writing is metaprogramming...
11:37:42 <bgamari> quicksilver: No no. I mean newtypes in particular
11:38:01 <quicksilver> you just mean "deriving Newtype" could be added to the standard list?
11:38:04 <bgamari> Yes
11:38:07 * quicksilver nods
11:38:23 <bgamari> Has this been considered?
11:38:39 <bgamari> It seems like this would require that a Newtype class were added to the language
11:38:45 <bgamari> report
11:38:46 <quicksilver> well you'd need to standard MPTCs and FDs ;)
11:38:53 <quicksilver> I imagine that's the main obstacle.
11:39:18 <DMcGill> Can you pattern match on a generic constructor?
11:39:25 <quicksilver> I think it would be cute if packages could register their own 'derivings' for classes they define
11:39:30 <quicksilver> DMcGill: (higher order unification) : No.
11:39:39 <weexplat> ^ that is actually haskell, believe it or not.  also, it's my answer to pointless-plumbers :)
11:39:43 <bgamari> Indeed it would
11:39:47 <timthelion> Right now, my program hangs.  What method can I do to get a stack trace that might point me as to where?
11:40:17 <ClaudiusMaximus> @where rtsxc
11:40:17 <lambdabot> I know nothing about rtsxc.
11:40:29 <bgamari> On this note, does anyone know of a way to derive Data.Vector.Unboxed instances for newtypes?
11:41:02 <bgamari> If Unbox were a bit simpler, I think this would be trivial assuming there were a Newtype instances available
11:41:05 <weexplat> quicksilver: there are packages to add new derivings on hackage
11:41:08 <ClaudiusMaximus> timthelion: compile with profiling, use +RTS -xc, trigger an exception?  but the 'trace' will be a bit vague.  could also do Debug.Trace
11:41:18 <bitonic> bgamari: tried GeneralisedNewtypeDeriving?
11:41:22 <ClaudiusMaximus> (unsafeCoerce . (f :: a -> a) . unsafeCoerce) :: b -> b -- safe for newtypes, right?
11:41:24 <quicksilver> weexplat: not actually to the "deriving" syntax though.
11:41:32 <bgamari> bitonic: MPTCs don't play well with it
11:41:44 <bgamari> hence the "bit simpler"
11:42:05 <quicksilver> weexplat: using other things like $(derive...) or similar (surely?)
11:42:14 <quicksilver> I don't think there are hooks to extended 'deriving'
11:45:44 <hpaste> ‚ÄúBen Gamari‚Äù pasted ‚ÄúDisambiguation‚Äù at http://hpaste.org/65695
11:46:03 <bgamari> Does anyone see how to make this typecheck without the signature?
11:46:21 <bgamari> or if it's possible to use the signature without ScopedTypeVariables
11:46:38 <bgamari> or for that matter, why ScopedTypeVariables permits that signature?
11:46:49 <bgamari> the signature on line 8
11:46:58 <timthelion> $ ghc grid_edit.hs -prof +RTS -xc
11:47:10 <ClaudiusMaximus> timthelion: +RTS -xc is at runtime
11:47:14 <timthelion> ghc: the flag -xc requires the program to be built with -prof
11:47:45 <quicksilver> even then I don't know how you get a stack trace from a hung program?
11:47:54 <quicksilver> how do you convert hung program to exception?
11:47:58 <ClaudiusMaximus> ctrl-c ?
11:48:11 <quicksilver> does that work? cool if so.
11:48:14 <ClaudiusMaximus> no clue
11:48:24 <ClaudiusMaximus> but there's a chance it might
11:49:32 <quicksilver> bgamari: I don't see any scoped type variables there?
11:49:41 <quicksilver> bgamari: [Time] is a type constant, it has no variable...
11:50:12 <hpaste> timthelion pasted ‚Äúuseless exception :D‚Äù at http://hpaste.org/65696
11:50:15 <bgamari> quicksilver: Precisely
11:50:28 <bgamari> quicksilver: Although I now realize a much more fundamental problem here
11:50:38 <bgamari> OrderedList and NonEmptyList aren't composable
11:50:43 <quicksilver> but ts::[Time] is an ordinary signature
11:50:48 <bgamari> Which is why it wasn't typechecking before
11:50:48 <quicksilver> why would you not expect that to work?
11:51:22 <dmwit> quicksilver: It probably needs PatternSignatures or whatever.
11:51:26 <bgamari> HPhoton/Types.hs:64:24:
11:51:26 <bgamari>     Illegal signature in pattern: [Time]
11:51:26 <bgamari>         Use -XScopedTypeVariables to permit it
11:51:36 <bgamari> Sorry for the miniature flood
11:51:42 <quicksilver> ok that's a weird error
11:51:45 <quicksilver> it should be patternsignatures
11:51:48 <damowe> hi, I'm profiling a haskell app (still I'm learning) and I want to know how to reduce the amount of memory allocated by ":", is there any way to reduce it?
11:52:00 <byorgey> PatternSignatures is deprecated, IIRC
11:53:00 <byorgey> the reasons for having ScopedTypeVariables do pattern signatures too are sort of arcane and implementation-specific
11:53:02 <dmwit> But yeah, I can't see any "ambiguity" that would require adding type signatures at all.
11:53:09 <byorgey> I don't like it, but that's the way it is.
11:53:23 <dmwit> Just delete them entirely (and fix your type errors).
11:53:34 <roconnor> I wonder if it is bad that when I see continuous integration regarding haskell I think (Compact -> CReal) -> CReal
11:53:51 <byorgey> roconnor: hehehe
11:53:59 <mauke> damowe: wat
11:54:06 <damowe> xD
11:54:07 <damowe> sorry
11:55:12 <byorgey> damowe: you cannot reduce the amount of memory allocated by any individual cons.  But you might well be able to reduce the number of cons cells allocated over the lifetime of your program (perhaps that's what you meant?)
11:55:13 <bgamari> dmwit: The problem was the code can't actually typecheck
11:55:50 <bgamari> dmwit: Unfortunately NonEmptyList and ORderedList don't compose since their inner types are both [a]
11:55:51 <byorgey> oh.
11:56:23 <dmwit> bgamari: Yep, but that's unrelated to having the type signatures there.
11:57:14 <bgamari> dmwit: Yes, but I originally added the type signature because I thought I needed to disambiguate the types
11:57:23 <bgamari> dmwit: This clearly wasn't the case
12:04:39 <hpaste> timthelion pasted ‚ÄúI must learn the dark arts if I am to suceed‚Äù at http://hpaste.org/65697
12:05:10 <c_wraith> timthelion: you need parens
12:05:12 <mm_freak> is there a way to find out where an exception was thrown?  i'm getting "thread blocked indefinitely in an MVar operation", but i have lots and lots of those operations
12:05:33 <c_wraith> timthelion: although, really, you should just use the Debug.Trace module
12:06:17 <timthelion> c_wraith: thanks.  Well I don't really have any errors, it just hangs.
12:06:43 <c_wraith> timthelion: also, there's a lot of confusion evident there... Why are you using >> and return on that line?
12:06:54 <c_wraith> oh, nevermind, that makes sense
12:07:04 <c_wraith> But is a bizarre way of doing things
12:07:11 <weexplat> > let doubtful = otherwise `maybe` not in doubtful <$> [Just True, Just False, Nothing]
12:07:12 <lambdabot>   [False,True,True]
12:07:20 <gregATio> how do i install Text.Regex.Posix
12:07:47 <Enigmagic> mm_freak: in ghci or a compiled app?
12:07:52 <c_wraith> timthelion: anyway, your problem is that you are passing print to unsafePerformIO, not (print ...)
12:08:02 <bgamari> Is there any way to do a qualified import in ghci?
12:08:02 <gregATio> compiled app
12:08:26 <c_wraith> bgamari: did you try just using "import qualified Foo as F"?
12:08:34 <bgamari> c_wraith: yep, it does nothing
12:08:38 <timthelion> c_wraith: yes, I found it once you said it was with the parens.  70% of all my errors are caused by parens.
12:08:46 <bgamari> damn, my bad
12:08:57 <bgamari> First I needed to :m +
12:09:04 <bgamari> only then can you import
12:09:22 <Enigmagic> gregATio: figure out what package you want and run "cabal install packagename"
12:09:25 <bgamari> How ghci deals with modules still isn't particularly clear to me
12:13:52 <mm_freak> Enigmagic: either would be fine
12:14:18 <mm_freak> Enigmagic: compiled would be nicer though
12:14:26 * hackagebot hmatrix 0.14.0.1 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.14.0.1 (AlbertoRuiz)
12:14:56 <Enigmagic> mm_freak: ghci has ":set -fbreak-on-exception" and ":trace function" then run ":history" when it breaks
12:15:05 <Enigmagic> mm_freak: that works about 80% of the time...
12:15:38 <mm_freak> thanks
12:15:56 <Enigmagic> for compiled apps it's a fair bit harder, i can walk you through it if you want
12:17:48 <gwern> @quote
12:17:48 <lambdabot> BMeph says: "In Soviet Haskell, projects volunteer YOU!"
12:18:19 <monochrom> haha soviet haskell
12:19:26 * hackagebot freesect 0.8 - A Haskell syntax extension for generalised sections  http://hackage.haskell.org/package/freesect-0.8 (AndrewSeniuk)
12:19:50 <monochrom> in soviet amerika, comrade premier kennedy says, "don't ask what you can do for the state. the state will tell you!"
12:21:30 <elemir> There isn't state monadic interface for MVar, is it?
12:21:43 <monochrom> there isn't
12:21:46 <elemir> :(
12:22:33 * elemir goes to write bike
12:23:04 <parcs`> there's this http://hackage.haskell.org/package/mstate
12:23:30 <elemir> parcs`: It isn't really interface
12:23:41 <elemir> It's just concurrent state
12:25:28 * elemir wants to runMVarState :: MonadIO m => MVarState t m a -> MVar t -> m a
12:26:29 <monochrom> what would it do, precisely?
12:28:00 <dmwit> Sounds like the point is to have a MonadState instance that allows for forkIO.
12:28:10 <dmwit> ...and shares state between the threads, rather than duplicating it.
12:28:15 <elemir> `put' should do `putMVar' and `get' should do `takeMVar'. And it should prevent races
12:28:43 <elemir> dmwit: No, MState does it without any problems.
12:28:58 <dmwit> What is "it"?
12:29:12 <elemir> > 23:28 < dmwit> Sounds like the point is to have a MonadState instance that allows for forkIO.
12:29:12 <lambdabot>   <no location info>: parse error on input `instance'
12:29:18 <elemir> Argh
12:29:42 <dmwit> Okay, then what is "MState"?
12:30:00 <elemir> @hackage mstate
12:30:00 <lambdabot> http://hackage.haskell.org/package/mstate
12:30:26 <monochrom> why don't you just liftIO (putMVar v x) and liftIO (takeMVar v)? then you just need MonadIO m
12:30:56 <dmwit> Then I have to agree that I don't know what MVarState is supposed to be for.
12:32:13 <elemir> monochrom: Because I should drag `v' to all code. And I can't use abstract `MonadState m =>' functions
12:33:47 <monochrom> there are tons of ways to hide v. my point is you can just combine liftIO and putMVar, takeMVar
12:34:15 <monochrom> or perhaps even eliminate liftIO
12:34:35 <elemir> putMVar isn't put
12:34:41 <mm_freak> is there a :trace version of :main?
12:34:42 <elemir> And takeMVar isn't get
12:35:05 <elemir> They are unabstract shit
12:35:15 <monochrom> I give up
12:35:19 <parcs`> what?
12:35:41 <Enigmagic> mm_freak: :trace withArgs [args] main
12:37:10 <mm_freak> oh yeah, good point
12:37:11 <monochrom> the very presence of "MVarState t m a" is pretended abstraction. it is equivalent to v. v lives right there
12:38:09 <monochrom> "MVarState t m a" is something that contains two definitions "put = putMvar v" and "get = takeMVar v" so afterwards you think you are no longer mentioning v. it is still there.
12:38:50 <elemir> putMVar and takeMVar don't prevent races. But get and put must do it
12:39:16 <elemir> So MVarState should content something like semophores
12:39:17 <c_wraith> elemir: that doesn't seem relevant, as neither MVarsState nor StateT provide any means to fork
12:40:14 <ben> (... I'm still surprised the rts doesn not have "block this thread until either of these mvar operation succeeds or either of these handles become readable or writable without blocking and also tell me which of that happened... )
12:40:18 <ben> "
12:40:38 <mm_freak> apparently the :trace method doesn't work too well with highly concurrent programs
12:40:41 <Enigmagic> ben: TMVar does
12:40:53 <Enigmagic> mm_freak: no it doesn't
12:40:58 <ben> Where do the handles go in?
12:41:11 <c_wraith> the RTS provides options for waiting on handles.
12:41:26 <c_wraith> though you have to get into low-level code to wait on a read or write availability
12:41:35 <mm_freak> elemir: do you need the semantics of an MVar?
12:41:47 <Enigmagic> ben:sorry, tmvar only covers the first case
12:41:55 <mm_freak> because that sounds more like a ChannelT than an MStateT
12:41:59 <timthelion> is there a standard function flip :: (a,b) -> (b,a) flip (a,b)=(b,a)?
12:42:09 <Enigmagic> but you can say takeTMVar tv1 <|> takeTMVar tv2
12:42:13 <ben> I was hoping for a hWaitForInput that is basically generalised for all the things that makes threads block
12:42:19 <ben> at once!
12:42:29 <c_wraith> @hoogle swap
12:42:29 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
12:42:29 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
12:42:30 <lambdabot> Graphics.UI.GLUT.Window swapBuffers :: IO ()
12:42:39 <Enigmagic> there isn't a select() equivalent in ghc afaiak
12:42:58 <timthelion> thank you
12:43:03 <christian`> Hey there .. anyone familiar with cabal?
12:43:09 <mm_freak> ben: have a separate thread for the handles and let them write to a TMVar
12:43:21 <timthelion> christian`: almost everyone here has used it ;)
12:44:06 <ben> that sounds really hard to get right in the presence of exceptions :(
12:44:21 <c_wraith> ben: actually, it's trivial.  stm is nice
12:44:23 <parcs`> elemir: will get be like takeMVar or readMVar?
12:44:25 <mm_freak> ben: it's actually pretty simple‚Ä¶  i do it all the time
12:44:37 <mm_freak> ben: just make sure that you use your 'finally' properly
12:44:45 <christian`> Ok :) I have a library which I build using cabal, but it relies (and wraps) another C library, which is not very widely spread and not included in e.g. Ubuntu. I could include the sources (even though they are quite large) and a scons file, but how do I tell cabal how and when to build (i.e. call scons) that library?
12:44:48 <ben> hm, ok
12:44:53 <ben> I've only tried it with non-T MVars
12:44:54 <mm_freak> forkIO (x `finally` cleanUp) >> atomically mySTMOp
12:45:11 <ben> All those Ts scare me!
12:45:25 <mm_freak> ben: also when working with STM i found the "join . atomically" idiom very useful
12:45:39 <mm_freak> join . atomically :: STM (IO a) -> IO a
12:46:06 <dcoutts> christian`: you'd need to do a custom Setup.hs script, and use the hooks to do extra stuff at build time, and modify the package description to link in the extra lib
12:46:09 <elemir> mm_freak: I am not really sure. I have a tree with self-mutable vertexes and can't invent of pure data structure for it
12:46:26 <ben> I thought STM was all about transactions, why does it come up when I just want to block on a bunch of stuff at the same time :(
12:46:31 <christian`> dcoutts: Thanks, I'll give it a go!
12:46:42 <mm_freak> elemir: not sure what you mean‚Ä¶  "tree" always sounds like you can do it purely without losing performance
12:47:01 <mm_freak> ben: because of the "at the same time"
12:47:20 <mm_freak> STM is not only for transactions‚Ä¶  that's one of its two big selling points
12:47:23 <monochrom> how to use join.atomically: join (atomically ((readTChan c1 >> return (putStrLn "hi")) `orElse` (readTChan c2 >> return (writeFile "x.txt" "hello")))))
12:47:27 <mm_freak> the other is the 'orElse' operation
12:47:30 <mm_freak> the one you need
12:47:53 <monochrom> unfortunately orElse has the wrong precedence compared to >>
12:48:11 <mm_freak> i mostly use <|> isntead of orElse anyway
12:48:24 <monochrom> oh, does <|> have the right precedence?
12:48:38 <dolio> Which one is the right one?
12:48:47 <mm_freak> monochrom: no, but it fits better with do-notation
12:49:04 <monochrom> when >> and >>= bind tighter than <|>
12:49:15 <ben> monochrom: that's cool, thank you
12:49:15 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù pasted ‚ÄúSTM example‚Äù at http://hpaste.org/65700
12:49:28 <mm_freak> monochrom: see the paste
12:49:34 <mm_freak> that's how i usually write STM code
12:50:06 <monochrom> oh, do binds tighter than <|>, I guess
12:50:35 <mm_freak> in this case it's really about layout, not precedence
12:50:55 <mm_freak> if <|> is at the same indentation level as the 'do', then it will put the do-block together
12:50:58 <mm_freak> just like in arrow notation
12:52:05 <mm_freak> that code also gives a nice example of the "join . atomically" pattern (in this case "join . liftIO . atomically")
12:52:27 <mm_freak> join . liftIO . atomically :: (MonadIO m) => STM (m a) -> m a
12:53:17 <roconnor> @type join . atomically
12:53:18 <lambdabot> Not in scope: `atomically'
12:53:53 <mm_freak> roconnor: STM (IO a) -> IO a
12:54:28 <mm_freak> instead of letting the STM action return a value for further processing it returns an IO action for execution, when the transaction commits
12:54:38 <roconnor> neat
12:54:56 <roconnor> I love example of using IO in non-kleisli ways
12:55:03 <roconnor> *examples
12:55:21 <mm_freak> that's about as non-kleisli as you can get, i guess =)
12:55:53 * roconnor has an a -> IO (b -> IO c) example that he was excited about.
12:56:21 <roconnor> well arguably that is Kleisli
12:56:24 <roconnor> :D
12:56:31 <mm_freak> i have lots of those:  withLogger :: IO (String -> IO ())
12:56:34 <mm_freak> uhm
12:56:36 <mm_freak> getLogger
12:56:46 <roconnor> nice
12:56:50 <mm_freak> withLogger would rather look like:  withLogger :: ((String -> IO ()) -> IO a) -> IO a
12:57:20 <roconnor> those OCaml people are missing out on so much fun.
12:57:24 <hpaste> Elemir pasted ‚ÄúStrange impure tree-like‚Äù at http://hpaste.org/65702
12:57:37 <mm_freak> also i once wrote a CSV parser where the parser for the header line looked like:  header :: Parser (Parser CSV)
12:57:38 <elemir> mm_freak: Something like that
12:57:53 <roconnor> mm_freak: :D
12:57:58 <elemir> But it's just a simplify model of my task
12:58:00 <c_wraith> roconnor: how do you feel about IO (forall a. Random a => (forall g. RandomGen g => g -> (a, g)) -> IO a)?
12:58:26 <elemir> Ou
12:58:32 * elemir forgot MVar
12:59:37 <mm_freak> elemir: what are you trying to do?
13:00:00 <roconnor> c_wraith: I don't know
13:00:06 * elemir tries to write an interface to vfs
13:00:06 <ben> i committed the crime that is http://hpaste.org/65701 at some point, but i never trusted its asynchronous exception handling enough to actually use it anywhere
13:00:28 <roconnor> c_wraith: that extra IO at the beginning seems a bit out of place.
13:00:32 <elemir> So `Node's in real life are files
13:00:38 <elemir> *virtual files
13:00:42 <c_wraith> roconnor: it's a bit difficult to get ghc to actually work with that type.  But it's amazingly versatile
13:00:50 <dmwit> ?hackage gnomevfs -- elemir
13:00:51 <lambdabot> http://hackage.haskell.org/package/gnomevfs -- elemir
13:01:10 <c_wraith> roconnor: it's not out of place - it needs IO to initialize the internal, hidden PRNG
13:01:11 <roconnor> c_wraith: why do you want the ability to call the input IO action multiple times?
13:01:26 <mm_freak> ben: wow, that looks insanely overcomplicated =)
13:02:05 <ben> yeah, it really feels like i'm not doing myself any favors by heaping the thread management complexity on top of my io demultiplexing complexity
13:02:15 <elemir> dmwit: There are directories in a gnomevfs. In 9p directory is a normal file
13:02:26 <mm_freak> c_wraith: looks like a classic abuse of RankNTypes =)
13:02:36 <c_wraith> mm_freak: impredicative types, actually
13:02:52 * elemir can't devide directories from files without lossing a functionality
13:02:53 <mm_freak> ben: threading isn't that complicated in haskell‚Ä¶  just think simple
13:02:56 <c_wraith> mm_freak: due to the forall inside the IO
13:03:09 <weexplat> elemir: presumably that would only make a minor difference in the basic approach
13:03:11 <mm_freak> c_wraith: oh
13:03:22 <gamowaxaky> pls help me with cygwin
13:03:29 <roconnor> c_wraith: oh wait, I was misparsing it
13:03:30 <elemir> weexplat: Problems are really in directories
13:03:33 <ben> Half of it is probably C++-threading induced paranoia about killing other threads instead of kindly asking them to terminate in a timely manner
13:03:40 <roconnor> c_wraith: stupid parentheses
13:03:57 <weexplat> elemir: what problem happens with directories?
13:04:03 <elemir> Directory should knows about files, but files may be changed
13:04:10 <roconnor> c_wraith: okay, that is nice.
13:04:11 <ben> mm_freak: Is there an obvious way in which my function should be simplified, or do you mean that I'm overcomplicating the entire approach?
13:04:18 <roconnor> c_wraith: now that I properly understand it
13:04:22 <gamowaxaky> cygwin seems not work with IO action on windows
13:04:26 <gamowaxaky> main = do       foo <- putStrLn "Hello, what's your name?"       name <- getLine       putStrLn ("Hey " ++ name ++ ", you rock!")
13:04:40 <mm_freak> ben: in many cases you can let the threads die by themselves‚Ä¶  i'm only using killThread to abort long-running pure computations, which i don't want to litter with IO
13:04:40 <gamowaxaky> it wait for input first
13:04:43 <elemir> So we need to have refernce of file, not really file representation
13:04:48 <monochrom> under a microscope, ghc threads are cooperative multitasking, so killing threads happen at fairly nice points
13:05:02 <c_wraith> roconnor: Hard enough to use that it's not worth it, at the moment, though.  Because GHC doesn't like to infer polymorphic types
13:05:04 <mm_freak> ben: use a more ad hoc approach
13:05:09 <mm_freak> don't reinvent select()
13:05:14 <weexplat> elemir: that also applies to gnomevfs
13:05:16 <mm_freak> we got rid of it for a reason
13:05:40 <roconnor> c_wraith: would it work better if things were wrapped in data types?
13:06:15 <c_wraith> roconnor: you'd be swapping type annotations for pattern-matching.  Not a big change.
13:06:48 <weexplat> i wonder if mlf's approach to inferring higher-rank types would be viable in haskell
13:07:05 <weexplat> biggest problem would be where it meets GADTs
13:07:06 <c_wraith> roconnor: Hmm.  maybe it would be better, actually if you wrote appropriately clever deconstructors
13:07:35 <monochrom> also, crucial procedures like readMVar and modifyMVar are coded to be safe against being killed. you can also do the same yourself, the facilities needed are exposed.
13:07:48 <mm_freak> ben: in other words, solve your particular small problem instead of inventing a large problem whose solution would solve your problem, too‚Ä¶  your mySelectRead is difficult to understand and would become awkward to use the more different IO actions you need to run
13:07:53 <elemir> weexplat: Hem. Thanks. I will look over gnomevfs
13:09:25 <elemir> It uses "filepath" for indicate the file?
13:09:31 <mm_freak> uh, modifyMVar‚Ä¶  that one is almost more evil than unsafePerformIO
13:09:42 <mm_freak> reason:  there are use cases for unsafePerformIO, but none for modifyMVar
13:10:00 <monochrom> I have a use case
13:10:10 <mm_freak> huh?
13:10:10 <weexplat> modifyMVar should be called unwiseModifyMVar?  ;)
13:10:22 <DMcGill> mm_freak: are you implying there's no use case for MVars?
13:10:38 <mm_freak> DMcGill: no
13:10:52 <monochrom> then again, it's replaceable by atomicallyModifyIORef
13:11:23 <mm_freak> or by modifyTMVar
13:11:43 <ben> mm_freak: It just seems like I could avoid a whole bunch of concurrency complexity in simple scenarios like one chat server broadcasting between a bunch of clients, by having it all in one server thread that knows what the deal with all the clients is, instead of introducing more threads
13:11:44 <DMcGill> how would you modify an MVar then? take and put? Why?
13:11:49 <ben> I dunno
13:11:49 <ben> I'm not a very smart programmer
13:12:09 <mm_freak> monochrom: are you aware that modifyMVar is not atomic?
13:12:20 <kallisti> http://hpaste.org/65703 <-- how can I make this code a little bit clearer?
13:12:41 <kallisti> to me, it seems to suffer where-itis
13:12:49 <mm_freak> DMcGill: the danger of modifyMVar is that it suggests that the modification operation is atomic, and that's not the case
13:13:01 <sclv> modifymvar is great!
13:13:17 <monochrom> once upon a time, there was no atomicallyModifyIORef, IORef were thread-unsafe by definition, only MVar were thread-safe. so, modifyMVar was necessary. back then.
13:13:28 <mm_freak> ben: you're wrong about that‚Ä¶  a chat server using concurrency is extremely simple to do especially with STM
13:13:41 <mm_freak> monochrom: btw, it's atomicModifyIORef
13:14:02 <c_wraith> I only ever use modifyMVar if it's the case that that all operations on the MVar start with take and end with put
13:14:14 <sclv> the docs say: "These only have atomicity guarantees if all other threads perform a takeMVar before a putMVar as well; otherwise, they may block."
13:14:19 <sclv> which is totally fine.
13:14:21 <c_wraith> In which case, it's non-atomicity is unimportant
13:14:31 <c_wraith> err, *its
13:14:32 <monochrom> I know modifyMVar is not atomic if someone else fools around with random putMVar and takeMVar
13:14:33 * hackagebot cautious-file 1.0.1 - Ways to write a file cautiously, to reduce the chances of problems such as data loss due to crashes or power failures  http://hackage.haskell.org/package/cautious-file-1.0.1 (CoreyOConnor)
13:14:35 <DMcGill> so you'd rather 'do { var <- takeMVar mvar; putMVar mvar (f (var))}' instead?
13:14:42 <mm_freak> if that's the case your MVar is just an IORef with atomic modification
13:14:54 <monochrom> but I don't fool around. it's my program. every thread uses modifyMVar consistently.
13:14:58 <c_wraith> mm_freak: and much better behavior under contention
13:15:21 <ben> mm_freak: is there a canonical example for that sort of thing? i should probably read the stm paper first :(
13:15:24 <c_wraith> write contention, in particular
13:15:28 <sclv> mm_freak: you can't do modifyMVar with an IORef
13:15:36 <sclv> because the IORef won't work as a mutex.
13:15:43 * weexplat starts a proposal to replace launchMissiles with atomicDestroyBiosphere
13:16:06 <mm_freak> sclv: there is atomicModifyIORef
13:16:09 <sclv> right.
13:16:15 <monochrom> like I said, once upon a time, atomicModifyIORef did not exist. only MVar was available.
13:16:20 <sclv> but what if you want to take an mvar, do a whole bunch of stuff, then put the mvar back!
13:16:35 <sclv> and not have anyone else futz with the mvar in the meantime?
13:16:39 <sclv> you can't do that with a single ioref
13:16:47 <monochrom> more precisely, the time was around Tackling The Awkward Squad
13:16:48 <mm_freak> ben: oh well, i could write you a little broadcast channel server, but i don't know where to find such a thing online
13:16:49 <sclv> because the modification that is atomic has to be pure.
13:17:19 <mm_freak> sclv: true
13:17:26 <sclv> so modifymvar is a much better abstraction for when you just want to have exclusive but potentially protracted access to a bit of state.
13:17:33 <sclv> which is usually what I want, frankly.
13:17:59 <mm_freak> interesting that i never used MVar that way
13:18:10 <sclv> and often I'm just using an mvar of () or something to guard access to some external ffid resource.
13:18:22 <monochrom> you're much younger than Tackling the Awkward Squad
13:18:57 <monochrom> not very interesting that a 21st century programmer never used slide rules that way or any way
13:18:58 <mm_freak> when i was a C/C++ programmer i had those variables, too‚Ä¶  when moving to haskell i replaced them by threads and used MVar in the message box mode
13:19:59 <sclv> TTAS was 2000. mm_freak is surely older than 10 years old!
13:20:07 <weexplat> 12
13:20:14 <mm_freak> i wish =)
13:20:16 <sclv> off by one error.
13:20:17 <sclv> (twice)
13:21:04 <weexplat> if mm_freak was 12 years old i could forgive the enthusiasm for enumerator :)
13:21:23 <rasfar> @remember weexplat starts a proposal to replace launchMissiles with atomicDestroyBiosphere
13:21:23 <lambdabot> Nice!
13:21:35 <mm_freak> weexplat: huh?
13:21:49 <mm_freak> enthusiasm for FRP, sure, but enumerator?
13:22:30 <weexplat> mm_freak: ah, guess i mixed you up with someone else with an m :(
13:22:56 <weexplat> the FRP i can not just forgive, but understand :)
13:23:05 <mm_freak> well, i always recommend to use a proper stream processing abstraction, but i'm not particularly enthusiastic about it =)
13:23:45 <weexplat> ah, but enumerator is not proper ...
13:23:49 <Franciman> so, arrows make parsing faster than monads do, why is it?
13:24:01 <sclv> because they're more areodynamic.
13:24:07 <mm_freak> Franciman: they don't
13:24:20 <monochrom> that question is oversimplified
13:24:23 <sclv> I mean, have you *tried* to shoot a monad from a bow?
13:24:26 <mm_freak> they allow the parsing library to do some optimizations automatically that you would have to do by hand with a monadic parser
13:24:26 <weexplat> Franciman: arrows don't inherently make parsing faster, but they can create more chances for optimization
13:24:34 * hackagebot random-fu 0.2.2.0 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2.2.0 (JamesCook)
13:24:53 <Franciman> for example?
13:24:53 <quintessence> a suitably-implemented arrows parsing library could analyze your grammar more before running it to speed things up
13:25:11 <ben> What's a better stream processing story than enumerators then? :)
13:25:21 <mm_freak> Franciman: string "abc" <|> string "abd"
13:25:28 <sclv> Franciman: just read this, and then read everything that cites it: http://haskell.cs.yale.edu/?post_type=publication&p=113
13:25:43 <sclv> ben: lazy lists.
13:25:53 <Franciman> sclv, great thanks
13:26:09 <weexplat> ben: iteratee or conduit (for different and almost mutually-exclusive reasons)
13:26:11 <mm_freak> Franciman: run against "abd" the monadic parser will first run 'string "abc"', fail, roll back, then try again with 'string "abd"'
13:26:21 <mm_freak> the arrow parser can try both at once
13:26:46 <Franciman> oh ok
13:26:59 <mm_freak> when the 'c' is encountered it throws away the "abc" branch and continues with the "abd" parser
13:27:04 <sclv> the one amendment, as i'd recall, is that arrows, ppl tend to think these days, don't buy you much over applicatives.
13:27:07 <sclv> but that's a whole seperate story.
13:27:15 <ben> conduit scared me off by making me think about the whole lifted-base thing
13:27:44 <mm_freak> when the 'd' is encountered i mean
13:27:58 <quintessence> did pipes-core ever get its category laws fixed?
13:28:44 <alpounet> don't think so
13:29:02 <weexplat> quintessence: i would guess not.  it's a problem when the original library author and the person building on it are working at crossed purposes
13:29:24 <Franciman> why the hell isn't there at least one very little article about haskell in italian?
13:29:32 <Franciman> just wikipedia page
13:29:39 <weexplat> i don't recommend pipes for stream processing anyway, it's really a coroutine library with a poor use recommendation
13:30:32 <monochrom> because Moggi doesn't feel like writing haskell articles
13:30:45 <Franciman> LOL
13:30:51 <Franciman> ahahah
13:31:52 <Franciman> I guess I should ask him to corrupt anyone and put down stupid o'caml
13:33:07 <quintessence> weexplat: coroutines seem like a very pleasant interface for stream processing
13:33:15 <c_wraith> roconnor: in case you're curious, http://hpaste.org/65704 is what an implementation that works on GHC 7 looks like. The type annotations get crazy when you want a polymorphic function to return a polymorphic value.
13:33:54 <nand`> Awesome, I can define bash aliases with : in their names: alias :t='ghcid :type'
13:34:18 <mm_freak> quintessence: they are, if you have the necessary support functions predefined
13:34:20 <mauke> alias :q=exit
13:34:25 <mm_freak> unfortunately monad-coroutine does not
13:34:38 <nand`> Now I just need to write ‚Äúghcid‚Äù. mauke: Yeah, I did that as well, very useful ;)
13:34:45 <roconnor> c_wraith: I don't quite get what is impredicative about it
13:34:55 <mm_freak> it's really the bare essentials, and i haven't found out why nobody bases a stream processing abstraction on monad-coroutine instead of a homebrewn approach
13:35:03 <c_wraith> roconnor: there's a forall inside a type constructor that isn't (->)
13:35:55 <weexplat> quintessence: pipes lacks some things that are necessary for stream processing.  particularly if you put together a string of coroutines to process a stream, you don't necessarily want the return value to come from whichever coro stopped the processing
13:35:56 <roconnor> c_wraith: okay, I guess I can see why that might be considered imprediative.
13:36:03 <roconnor> c_wraith: maybe
13:36:03 <t0ki> Hello
13:36:12 <donri> quintessence: author claimed to fix it, tekmo hadn't responded to that last i checked
13:36:17 <c_wraith> roconnor: well, GHC claims it is. :)
13:37:00 <roconnor> c_wraith: GHC claims a lot of things are impredicative :D
13:37:24 * roconnor recalls some back and forth about thes status of runST
13:37:30 <weexplat> quintessence: for example, in pipes you can't have something like an 'iteratee' to compute the length of an input stream, because the 'enumerator' that supplies the input determines when processing stops, so it has to return the value itself
13:38:30 <c_wraith> roconnor: I think the result was that runST is not impredicative, but if you pass it as the first argument to ($), the type of ($) becomes impredicative
13:38:34 <monochrom> yeah, "runST $ do ..." used to need impredicative $
13:39:35 <weexplat> another reason $ should be syntax
13:39:37 <monochrom> now we give $ its own type rule, so we don't need impredicative
13:39:51 <monochrom> which almost makes $ syntax, yes
13:40:18 <monochrom> of course, $ is given the same type rule as juxtaposition, that's all
13:41:02 <roconnor> what happens if we just say, in Haskell 2012, everything is impredicative?
13:41:24 <c_wraith> roconnor: you get to write the type inference algorithm :)
13:41:46 <roconnor> well even in Haskell '98, polymorphic recursion isn't inferable.
13:42:06 <c_wraith> the thing is, what you *really* want is impredicative inference
13:42:27 <c_wraith> because if you have to specify the full types on every function you want to return a polymorphic value, it's a lot of work
13:42:35 <roconnor> I see
13:44:09 <sclv> but even in the pasted example, you can just give a newtype wrapper around the forall a. Random A => part...
13:44:25 <sclv> in fact just turn IOGen from a type into a newtype
13:44:28 <monochrom> yeah, that's how I would usually work around
13:44:29 <mm_freak> impredicative types seem to be one of those things you never need, until you really understand then, at which point you can't live without them anymore
13:44:33 <weexplat> c_wraith: as i mentioned before, isn't that what mlf inference is supposed to accomplish?
13:44:43 <c_wraith> weexplat: I actually don't know anything about mlf
13:44:45 <sclv> no, impredicative types are one of those things you never need.
13:44:50 <sclv> because you can just guard by a newtype
13:44:52 <monochrom> hahah
13:45:00 <bgamari> How does one reduce the default maximum size of a QuickCheck property?
13:45:18 <robryk> I've got a stupid question: what is the unsafe thing in doing (newIORef undefined :: forall a. IO (IORef a)) >>= \ref -> writeIORef ref [] >> return (readIORef ref) + 5 ?
13:45:23 <quicksilver> does it make sense to talk of "impredicative types" ?
13:45:32 <quicksilver> isn't it really "impredicative instantiation" ?
13:45:34 <quintessence> weexplat: hmm, I guess that's worth the complication of distinguishing stream consumers from stream transformers
13:45:45 <quicksilver> that is, instantiating polymorphic type schemes at higher rank types
13:46:11 <monochrom> halting problem decision procedure is one of those things you never needed, until you really understand it, at which point you regret that it can't be done :)
13:46:42 <c_wraith> I know how to solve the halting problem.  Consult my nearest oracle.
13:46:43 <mm_freak> sclv: by that argument you never need type classes or higher rank types
13:46:44 <weexplat> monochrom: but if it could be done, then it would get harder, so it couldn't be done
13:46:48 <robryk> monochrom: because the reason you can't do it and the reason you'd like to be able to do it is the same reason :)
13:47:21 <monochrom> regretably, sometimes you are also glad that it can't be done
13:48:40 <weexplat> i kind of maybe wish there were a few levels of magic halting oracles we could actually access, though, that would be pretty keen
13:48:43 <sclv> robryk: i don't get it?
13:48:50 <monochrom> wait, is (newIORef undefined :: forall a. IO (IORef a)) valid code?
13:49:17 <sclv> the code doesn't compile.
13:49:20 <robryk> hm. i'm not sure, but i could create a global var of that type and initialize it with unsafePerform
13:49:31 <robryk> so, maybe this was the unsafe thing
13:49:34 <weexplat> it wouldn't mean we could solve the halting problem for all the code we could write then, but at least we could solve it for all the code we can actually write now
13:49:40 <sclv> the one with unsafe in the name, you mean?
13:49:42 <sclv> you think!?
13:49:43 <rasfar> bgamari: if it's for a specific case, it might be easier to set it like http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck#Coverage
13:49:55 <rasfar> (but you probably have some reason you don't want to do it that way?)
13:50:21 <weexplat> and there would be a few more useful levels of computation between primitive recursion and 'every computation physically possible'
13:50:39 <monochrom> if it's made valid, the next thing is writeIORef ref [] and readIORef ref >>= \b -> if b then ... else ...
13:51:08 <monochrom> so you get a nice little typecast
13:51:23 <weexplat> in particular, there would be a level that was analyzable but still enjoyed all the nice closure properties that general recursive has
13:52:19 <monochrom> there are already a few level of magical oracles. look for "automated verification"
13:52:23 <quicksilver> monochrom: it doesn't work because of the way types are inferred in haskell.
13:52:34 <quicksilver> monochrom: see the tangential discussion at http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html
13:52:51 <weexplat> monochrom: that's not magic, it's just slight of hand :)
13:52:55 <robryk> monochrom: but i could do writeIORef r [] if r was forall a. IORef a, right?
13:53:01 <weexplat> sleight?
13:53:42 <monochrom> yes quicksilver I'm reproducing the same discussion
13:56:05 <monochrom> well ok, forall a . IO (IORef a) vs forall a. IORef a
13:56:15 <robryk> that's not the problem
13:56:23 <robryk> i can do  n <- (newIORef undefined) :: forall a. IO (IORef a)
13:56:26 <robryk> oh
13:56:37 <robryk> and i need to specify a when executing
13:56:40 <robryk> nice :)
13:57:04 <robryk> thanks, it now makes a lot more sense to me
13:57:41 <monochrom> r = unsafePerformIO (newIORef undefined)  can give you r :: forall a. IORef a
13:58:02 <robryk> and that's the unsafety. right.
13:58:55 <rasfar> is there anyone syb-savvy around who could take a quick peek at an hpaste?  i'm just wondering about how to pass the type C to the function "join", rather than hardcoding it in a expression type sig inside "join" as presently.
13:59:02 <hpaste> rasfar pasted ‚ÄúSYB question‚Äù at http://hpaste.org/65706
14:00:43 <rasfar> (excuse the many #if 0'd cases)
14:01:21 <rasfar> the "hardcoded" type sig is "p2 (x::C) = True" in function "join" -- I'd prefer to pass this information somehow as an argument.
14:01:48 <rasfar> that would make this well and truly generic, from my perspective :)
14:02:40 <rasfar> join = LUB = "smallest branch containing"
14:03:28 <rasfar> if it could be made fully generic, and efficient, it might even make a useful addition to the API?
14:04:35 * hackagebot yi 0.6.5.0 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.6.5.0 (CoreyOConnor)
14:05:10 <DevHC> yi???????????
14:06:08 <elemir> DevHC: Why so many `?'?
14:06:09 <byorgey> yi!!!!!!!!!!!
14:06:09 <c_wraith> is still being updated, clearly
14:06:14 <cafesofie> yay
14:06:22 <DevHC> yeah, like w00t
14:06:44 <DevHC> so yi was once discontinued and someone continued the work recently?
14:07:00 <DevHC> Corey: TALK
14:07:08 <ski> rasfar : i think multiplate might help there
14:07:09 * elemir thinks about starting of hacking yi
14:07:33 <rasfar> ah, ski! i was debating pinging you -- i have something else i'd like to mention to you.
14:08:09 <rasfar> (as for syb, i use it because HSE derives instances for it; with *plate and other generic libs, i'd have had to add instances all over HSE)
14:08:47 <rasfar> but for you especially:  i think i've arrived at the best possible resolution to the problem you noticed in my "freesect default context policy"
14:09:07 <rasfar> which is, that the preprocessor notices such cases and issues a warning
14:09:37 * hackagebot yi-contrib 0.6.5.0 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.6.5.0 (CoreyOConnor)
14:09:42 <rasfar> i let it be a warning instead of an error, because it is much more likely the programmer intended the section than intended redundantly-parenthesised application
14:09:47 <rasfar> it looks like this:
14:10:11 <rasfar> S28.hs:7:7 Warning:
14:10:11 <rasfar>   Inferring free section context of loose wildcard(s) occurring
14:10:11 <rasfar>   in redundantly-parenthesised application
14:10:11 <rasfar>     (__ x)
14:10:11 <rasfar>   in the expression
14:10:11 <rasfar>     (__ x) y
14:10:13 <rasfar>   This means for e.g. that (f __) y is rewritten to (\x->f x) y.
14:10:15 <rasfar>   If this is not what you want, remove the redundant parentheses
14:10:19 <rasfar>   or use explicit _[...]_ free section context syntax.
14:10:48 <rasfar> do you think this is a good enough solution to "rescue" the policy?
14:11:24 <rasfar> then the programmer need not be bothered about it until the situation actually arises, if ever
14:17:29 <rasfar> s/rescue/redeem
14:19:25 <weexplat> rasfar: just curious -- is freesect at all inspired by scala's _ in things like mylist.map(_ + 1) ?
14:20:26 <rasfar> hi weexplat: i don't know scala at all, but it came up in the discussion here in late feb. when i started implementing it.  apropros of some observations of dolio's
14:21:23 <rasfar> i would hazard that my syntax is quite a bit more general, but that's just a hunch
14:21:24 <adnauseam> are all functions that map over, considered functors ?
14:22:03 <kallisti> adnauseam: that's too vague to really mean anything.
14:22:04 <rasfar> weexplat: in case you haven't seen it, http://fremissant.net/freesect
14:22:10 <byorgey> adnauseam: it's impossible to say, because "map over" is very vague
14:22:19 <byorgey> adnauseam: "functor" has a very precise meaning.
14:23:06 <kallisti> byorgey: in the case of the Functor typeclass, wouldn't "fmap f" be considered the functor in the categorical theoretical sense?
14:23:36 <kallisti> perhaps that's what he meant.
14:23:44 <byorgey> kallisti: a functor in the CT sense is really a pair of mappings, one from objects to objects and one from arrows to arrows
14:24:22 <kallisti> ah okay
14:24:37 <byorgey> kallisti: in Haskell, that would be the type constructor itself together with fmap
14:26:09 <adnauseam> hmmr,
14:26:22 <adnauseam> byorgey: can you help me out a bit
14:26:52 <byorgey> adnauseam: Maybe. But you'll have to ask a question first. =)
14:27:01 <rasfar> ski: i mean, there may be other pathological cases lurking, but do you feel that the preprocessor/compiler warning is a (most) viable workaround?
14:27:31 <monochrom> in fact, you have to ask a clear, precise, complete question
14:27:47 <kallisti> it helps if you already know the answer to your question
14:27:50 <kallisti> :>
14:27:55 <adnauseam> i'm trying to understand what a functor is ;p i know how it's used in haskell. i somewhat understand that to a limited degree.. i'm reading its definition on wikipedia and that's proving enegmatic at best since my mathematical foundation is still in progress
14:28:03 <kallisti> I find this is the best way to ask clear, precise, complete questions.
14:28:14 <adnauseam> if you would to define a functor simply for the layman, how would you put it
14:28:46 * ski notes rasfar is saying something
14:28:59 <monochrom> I have been able to ask clear, precise, complete questions without knowing answers
14:29:06 <rasfar> (thanks; brb...)
14:29:33 * ski can't recall what `HSE' is
14:30:02 <monochrom> I am not convinced that "the layman" is ready to know or bothers to know functors
14:30:44 <monochrom> but you can always say a functor is a special mapping from a chosen category to a chosen category
14:31:13 <christian`> Ok .. I wrote a Setup.hs, but using runhaskell Setup.hs configure complains about missing dependencies which a cabal configure does find. Am I missing a point here?
14:31:24 <christian`> dcoutts: Are you still online?
14:32:38 <ski> rasfar : i suppose it's better than nothing :)
14:33:01 <rasfar> you're very generous :)  p.s. HSE=haskell-src-exts
14:33:15 <adnauseam> hmm, alright.. so it's category to category...
14:33:31 <adnauseam> that kind of clears another inch of the fog
14:33:31 <ski> adnauseam : functors in Category Theory are more general than functors in Haskell (but every functor in Haskell is a CT functor)
14:33:52 <adnauseam> yeah i'm slowly getting that
14:34:06 <byorgey> adnauseam: could you write down a precise definition of category without peeking?
14:34:36 <ski> adnauseam : most functors in haskell is of the kind where they consist of a type `T' with kind `* -> *', and a function `mapT :: (a -> b) -> (T a -> T b)'
14:34:49 <ski> adnauseam : did you understand that ?
14:35:15 <byorgey> adnauseam: (you don't have to write it here, just making sure you have the requisite background knowledge first! =)
14:35:25 <Jafet> byorgey: a bunch of stuff!
14:35:28 <adnauseam> yeah i understand that one - i've already had a run it with a similar definition in Learn you a haskell, i also understand what *->* is
14:35:44 <byorgey> Jafet: ?
14:35:55 <adnauseam> i usppose i need to write a few liens of code
14:35:56 <ski> e.g. for the type `data Tree a = Node {rootLabel :: a , subForest :: [Tree a]}', we can write a function `mapTree :: (a -> b) -> (Tree a -> Tree b)' like :
14:36:16 <byorgey> adnauseam: well, a functor is a *structure-preserving* mapping from one category to another.
14:36:25 <Jafet> Is half the answer to that question (admittedly the less useful one)
14:36:26 <ski> @let mapTree :: (a -> b) -> (Tree a -> Tree b); mapTree f (Node a ats) = Node (f a) (map (mapTree f) ats)
14:36:27 <lambdabot>  Defined.
14:36:37 <byorgey> adnauseam: "structure-preserving" means it must map objects to objects and arrows to arrows, in such a way that it preserves identity arrows and composition
14:36:48 <ski> > mapTree show (Node 0 [Node 1 [],Node 2 []])
14:36:50 <lambdabot>   Node {rootLabel = "0", subForest = [Node {rootLabel = "1", subForest = []},...
14:37:12 <adnauseam> oh ok - that actually makes sense
14:37:44 <ski> adnauseam : what `mapTree' does is applying a given argument function to all the elements of the tree
14:38:04 <ski> the general pattern is "apply a given argument function to all elements of the tree"
14:38:35 <adnauseam> sort of like a fold
14:38:54 <ski> however, note that the mapping function has to be *polymorphic* : the argument and return types of the function to apply to each element has to allowed to be any type whatsoever
14:39:03 <adnauseam> on a data structure, rather than a list
14:39:20 <christian`> Ah .. dammit. I got it. Cabal uses --user, Setup.hs uses --global.
14:39:24 <christian`> Sorry for the noise.
14:39:37 <byorgey> adnauseam: a fold is something different.  But both maps and folds are generic recursion patterns.
14:39:38 <ski> so, if you have a function `mapIntSet :: (Int -> Int) -> (IntSet -> IntSet)', then it's not the mapping function for a functor
14:39:45 <rasfar> is it incorrect to say that (\x->x) has kind *->*?  functions don't have kinds unless they're type-level, right?
14:39:51 <adnauseam> hrm
14:39:56 <ski> (indeed `IntSet :: *' here, instead of `IntSet :: * -> *')
14:40:03 <adnauseam> byorgey: in that case i'll stop thinking there and continue reading
14:40:04 <rasfar> christian`: yeah that got me too
14:40:08 <byorgey> rasfar: right.  functions have types and types have kinds.
14:40:11 <ski> rasfar : if `\x -> x' was meant to be a value-level expression, then it's incorrect
14:40:21 <adnauseam> thanks alot man - what you said helped quiet a bit
14:40:35 <rasfar> thanks; i need to fix my html page then...
14:41:58 <ski> adnauseam : btw, lists are also data structures
14:42:50 <ski> adnauseam : anyway, because functors is a commonly recurring pattern, there is a type-class for them in Haskell, so one can declare `instance Functor Tree where fmap = mapTree'
14:43:16 <ski> adnauseam : so one can use `fmap' for the name of the mapping function
14:43:25 <qued_____1> What does '!!' mean in:    iterate f x !! 42  ??
14:43:32 <qued_____1> looping 42 times ?
14:43:46 <ben> kinda
14:43:54 <Ke> qued_____1: a !! b is a[b]
14:44:10 <byorgey> qued_____1: !! itself is the function for indexing into a list
14:44:12 <Ke> or like a[b] in most languages
14:44:19 <byorgey> > iterate f x
14:44:20 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
14:44:33 <ski> adnauseam : anyway, remember that `Tree :: * -> *', meaning that `Tree' is a type-function mapping (concrete) types into (concrete) types -- e.g. it maps the type `Int' into `Tree Int', the type of trees with `Int'-elements
14:44:40 <byorgey> iterate f x generates an infinite list, and the element at index 42 is the application of 42 copies of f to x
14:44:54 <byorgey> > iterate f x !! 2
14:44:55 <lambdabot>   f (f x)
14:44:57 <ski> adnauseam : now, *most* commonly used functors in Haskell fit this pattern, but not all of them
14:45:00 <byorgey> > iterate f x !! 5
14:45:01 <lambdabot>   f (f (f (f (f x))))
14:45:11 <qued_____1> Ke: and what does a[b] mean in that sense ?
14:45:35 <Ke> get b'th element from list
14:45:39 <rasfar> qued_____1 i think you are exactly right
14:45:41 <alpounet> he meant a[b] in languages like in C/C++/Java etc
14:46:23 <alpounet> that index, get the b-th element from the array a, for example
14:46:33 <rasfar> (unless someone objects to the word "loop")
14:47:02 <qued_____1> ah okay, so iterate f x !! 42   would give the 42 th index of the iterated list [x, f(x), f(f(x)),...], right?
14:47:36 <ben> yeah
14:47:38 <alpounet> qued_____1, exactly
14:47:42 <rasfar> 42th indexed from 0, so it works out just like you originally stated for this expression
14:47:46 <Azel> qued_____1: Yes, remembering that indexes are 0-based
14:48:00 <qued_____1> okay, thanks alot
14:48:00 <rasfar> s/42th/42nd
14:48:10 <qued_____1> ;)
14:50:12 <rasfar> So does this make proper sense?  "This interpretation cannot by typed, since the second argument of map must have type t, while \b->h b has type t1->t2."
14:51:34 <rasfar> (I had "kind *" ... "kind *->*")
14:52:22 <rasfar> Or do I need to say "the second argument of map must have type [t]" ?
14:52:50 <kallisti> :t msum
14:52:50 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
14:52:55 <rasfar> nah! [t] is just some other type t0
14:55:20 <gnoi> I wan't to write some interface using ncurses module. Never used it in any languages ever. Should I start with playing with t in c?
14:55:36 <ski> rasfar : well, if you say the second argument must have type `t', unless you've already specified `t' to some extent before, that doesn't explain any type discrepancy between the expected type and the actual type (`t1 -> t2')
14:55:59 <acowley> gnol: I used it from Haskell before ever having used it from C. It can be done, and works pretty well!
14:56:08 <rasfar> ski: that's what drew me to kinds.  how would you express what i'm trying to express, concisely?
14:56:58 <gnoi> acowley: can you share some examples? I don't know where should I start from
14:57:06 * rasfar loves ncurses, really takes me back to my days (and days and days) (well, mostly nights) in front of my beloved amber vt220...
14:57:07 <gnoi> hackage docs looks kinda unusable
14:57:08 <ski> rasfar : what are you trying to express ? :)
14:57:16 <Enigmagic> gnoi: you might have a look at vty as well, the interface looks nicer though i haven't used either
14:58:04 <gnoi> Any library will be great with some examples.
14:58:23 <rasfar> well, it is the analysis of dolio's example -- there's no anchor, but it's near the bottom of http://fremissant.net/freesect
14:58:44 <rasfar> the second argument of map cannot have a "function type"
14:59:05 <rasfar> but i'm not sure what the idiomatic way is to express that, so hoping for a pointer
14:59:39 <byorgey> rasfar: note that  t  would unify just fine with  t1 -> t2,  so that's not enough.
14:59:50 <acowley> gnol: I can't find any example code on this computer, but does using it require anything more than: main = runCurses $ drawText "Hi there" >> render
15:00:00 <byorgey> rasfar: it's particularly the fact that the second argument to map must have a list type which is relevant.
15:00:16 <gnoi> acowley: okay
15:00:17 <byorgey> rasfar: and a list type can never be the same as (unify with) a function type.
15:00:23 <gnoi> gnoi* btw :)
15:00:25 <rasfar> i hesitate to say list, since isn't map potentially more polymorphic than lists?
15:00:56 <acowley> gnoi: sorry!
15:01:04 <rasfar> but thanks byorgey, that does help clarify it
15:01:07 <byorgey> @type map
15:01:08 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:01:10 <byorgey> rasfar: no
15:01:34 <rasfar> alright, so i'm safe to express it like you suggested without loss of generality, thx
15:01:48 <byorgey> rasfar: in general, 'fmap' can be more polymorphic than lists.  But the second argument to fmap *can* be a function!
15:02:21 <rasfar> btw, are you involved with the diagrams project?  i remember you mentioning it as a possible place i could maybe offer some contrib?
15:02:32 <rasfar> (wow, okay)
15:02:44 <byorgey> rasfar: I would just say "This interpretation is not well-typed, since the second argument of map must be a list, and \b -> h b is not a list.
15:02:58 <rasfar> alright!
15:03:10 <byorgey> rasfar: yes, I'm the primary developer of diagrams, and I did mention that
15:03:24 <rasfar> may i quote you without attribution? =)
15:03:31 <byorgey> rasfar: sure =)
15:04:25 <gnoi> acowley: what module is runCurses from?
15:04:49 <acowley> gnoi: UI.NCurses
15:04:49 <byorgey> rasfar: see http://code.google.com/p/diagrams/issues/list  for some ideas.  I try to be good about marking difficulty+length of potential enhancements/bug fixes, so you can tell what might be good to get started with
15:05:36 <gnoi> acowley: > :m + UI.HSCurses.
15:05:36 <gnoi> UI.HSCurses.Curses          UI.HSCurses.MonadException
15:05:36 <gnoi> UI.HSCurses.CursesHelper    UI.HSCurses.Widgets
15:05:36 <gnoi> UI.HSCurses.Logging
15:05:45 <gnoi> Not Ncurses
15:06:57 <rasfar> byorgey, ok i'm looking at that issues list, thank-you
15:06:58 <acowley> gnoi: oh sorry, wrong package! I unfortunately have to run at the moment, but I'm sure someone else can step in to help
15:07:37 <rasfar> can hoogle tell you all packages which depend on a given package?
15:07:52 <rasfar> that would be a handy way to get a list of examples
15:09:02 <dmwit> ?where revdeps
15:09:02 <lambdabot> "Show reverse dependencies" at <http://hackage.haskell.org/trac/hackage/ticket/576>,"Hackage with Reverse Dependencies" by Roel van Dijk at <http://bifunctor.homelinux.net/~roel/hackage/packages/
15:09:03 <lambdabot> hackage.html>,"Reverse Dependencies" at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html>,<http://packdeps.haskellers.com/reverse> -- `bifunctor.homelinux.net' is
15:09:03 <lambdabot> broken, use `81.26.216.99' instead
15:10:07 <rasfar> righteous
15:16:12 <nart> hi =)
15:16:38 <rasfar> gnoi: looks like this might be just what you're looking for:  http://hackage.haskell.org/package/hscurses-fish-ex
15:18:38 <nart> i'm developing an irc bot, is it good design to have: main -spawn-> api, mainLoop -spawn-> Bot for each server ogni Bot -spawn-> Logger thread ?
15:18:58 <nart> *ogni = each
15:19:41 <gnoi> ogni == gnoi
15:19:50 <rasfar> wow nart, what kind of keyboard are you using? :p
15:20:34 <nart> rasfar: why ?
15:20:45 <rasfar> gnoi isn't a contraction of "gaussian noise" by any chance?
15:21:04 <nart> ogni is the italian translation of each
15:21:14 <rasfar> nart: only that on my keyboard "ogni" and "each" have a large UI edit distance
15:21:20 <yshavit> I have a debugging question. I have a data type D with three argless constructors -- so basically an enum. I have a function (D -> D -> D), and it's defined as: (addThem One One = Two) (addThem One Two = Three) (addThem _ _) = Four.  (That's not my actual code, just trying to abstract the question a bit). If I :step into that function, :list highlights all of those definitions -- I can't seem to see what the two arguments
15:21:20 <yshavit> are, or which definition it ends up going to. Is there any way to do that?
15:21:27 <rasfar> ah, i had no idea, thanks
15:21:32 <yshavit> I can make it more concrete if that'd be useful.
15:22:31 * rasfar has not used ghci debugging yet
15:25:48 <yshavit> rasfar: how do you debug? I can't really put printfs in pure code (at least, as far as I know)
15:26:50 <c_wraith> yshavit: you can use Debug.Trace.
15:28:01 <yshavit> c_wraith: I'll look into that, thanks
15:28:02 <c_wraith> yshavit: it's very much a peek into the evaluation mechanism, and useful for debugging problems in the evaluation process.  But if you don't have a reasonable mental model of how evaluation in haskell works, its output can be very surprising
15:28:06 <rasfar> actually, just today for the first time I used unsafePerformIO ... in a pinch, you can always do that.
15:28:18 <rasfar> previously I have always used "error"
15:28:26 <c_wraith> rasfar: Debug.Trace is just a friendly wrapper around unsafePerformIO of print
15:28:32 <rasfar> awesome
15:28:49 <yshavit> c_wraith: doesn't bode well for me, then. The whole thing I'm trying to do is to figure out why my code isn't as lazy as I thought :)
15:29:09 <c_wraith> yshavit: surprising doesn't mean useless
15:29:20 <c_wraith> yshavit: in fact, it could be surprising and educational :)
15:30:58 <yshavit> c_wraith: oh wait, I misunderstood how it worked. I see now.
15:36:10 <weexplat> is there a haskell binding for setproctitle?
15:39:05 <c_wraith> weexplat: looks like you're going to have to write it yourself
15:39:42 <qued_____1> Anyone knows euler-transformation that is usable for faster pi-approximation?
15:39:46 * hackagebot type-spine 0.1.2 - A spine-view on types  http://hackage.haskell.org/package/type-spine-0.1.2 (NicolasFrisby)
15:39:48 * hackagebot yoko 0.3.1.3 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-0.3.1.3 (NicolasFrisby)
15:43:34 <qued_____1> Which haskell type for fractions ?
15:43:42 <koeien> Ratio Integer
15:45:27 <qued_____1> koeien: any example?
15:45:33 <qued_____1> couldnt find docs
15:45:56 <c_wraith> @hoogle Ratio
15:45:57 <lambdabot> Prelude type Rational = Ratio Integer
15:45:57 <lambdabot> Data.Ratio type Rational = Ratio Integer
15:45:57 <lambdabot> Data.Ratio module Data.Ratio
15:46:05 <c_wraith> all of those are in base
15:46:32 <nifr_> Help! I'm running GHC 7.4.1 on OS X 10.6.8 with xcode 3.2.5 and gcc-4.2 and I'd say ghc fails to launch (e.g. segfault or panic) two out of three invocations.
15:46:51 <nifr_> I remember a haskell cafe thread on this topic, but I can't find it. Anyone know a solution that doesn't involve buying 10.7 and downloading xcode 4?
15:47:05 <koeien> qued_____1: import Data.Ratio, then say "3 % 4"
15:47:10 <koeien> or 3 / 4 :: Rational
15:47:18 <nifr_> I've been wrapping my commands in "until $cmd; do echo RETRYING; done" for a while now, but my patience is lost.
15:47:23 <monochrom> > 3%4 + 1%4
15:47:24 <lambdabot>   1 % 1
15:47:34 <monochrom> that's 3/4 + 1/4
15:47:47 <monochrom> > 2%4 + 1%2
15:47:49 <lambdabot>   1 % 1
15:47:51 <monochrom> also works
15:48:06 <koeien> Rational is arbitrary-precision.
15:48:09 <qued_____1> ty
15:48:22 <gnoi> rasfar: I've installed hscurses-fish-ex with cabal. Where can I find sources?
15:48:39 <monochrom> the type is "Ratio Integer", aka "Rational". but you can also have "Ratio Int" etc if you fancy
15:48:43 <c_wraith> gnoi: use cabal unpack
15:49:09 <monochrom> denominators grow quickly though, so Ratio Int may give wrong answers
15:49:31 <monochrom> (much more easily be wrong than just Integer vs Int)
15:49:42 <koeien> yeah, Ratio Int is somewhat strange
15:50:36 <gnoi> c_wraith: wow
15:52:52 <rasfar> ~/.cabal/packages/*/hscurses-fish-ex ... untar the tarball and there you go
15:53:03 <rasfar> (oh, or i guess there's a cabal unpack....)
15:54:09 <parcs`> elemir: will get be like takeMVar or readMVar?
15:54:17 <parcs`> oops, wrong window
15:55:00 <monochrom> heh
15:55:11 <nart> is it possible to dynamic load a file and use the funs declared in that file ?
15:55:16 <elemir> History is so history
15:56:34 <c_wraith> nart: yes. the GHC api is the lowest-level way to do it, and very hard to use.  hint provides a simpler api, as does the plugins package (I've forgotten the exact name)
15:56:42 <yasar> Hi, newby question: what is cabal?
15:56:57 <c_wraith> nart: between those two, they're really built for very different use cases
15:57:08 <nart> c_wraith: i'm looking now at System.Plugins.Load
15:57:19 <elemir> yasar: configure + make system
15:57:26 <c_wraith> yasar: it's a build tool/package installer for haskell
15:57:42 <yasar> I see. Thanks.
15:57:50 <elemir> c_wraith: cabal-install is
15:57:53 <Mathnerd314> "Cabal is a system for building and packaging Haskell libraries and programs. It defines a common interface for package authors and distributors to easily build their applications in a portable way. Cabal is part of a larger infrastructure for distributing, organizing, and cataloging Haskell libraries and programs. "
15:58:20 <c_wraith> elemir: when someone asks about lowercase "cabal", I assume they mean the binary.  Not the well-hidden Cabal library
15:58:49 <c_wraith> elemir: also, dcoutts plans on updating the names of the two packages in the future, such that the binary comes from a package named "cabal"
15:59:09 <elemir> There is my cabal with mixml?
15:59:15 <weexplat> i always assume they're confused, because the haskell cabal does not exist
16:00:24 <elemir> http://skilpat.tumblr.com/ ‚Üê blog look like dead
16:00:32 <Mathnerd314> weexplat: it does according to the #haskell logs
16:01:05 <weexplat> Mathnerd314: don't worry, the logs will soon be corrected
16:01:30 <Mathnerd314> 1984 is not internally consistent
16:01:44 <c_wraith> Mathnerd314: more like the illuminati
16:02:31 <elemir> 1984 is a myth. Welcome to the brave new world, guys
16:04:47 * hackagebot vector-conduit 0.3.0.0 - Conduit utilities for vectors  http://hackage.haskell.org/package/vector-conduit-0.3.0.0 (JaredHance)
16:07:54 <Mathnerd314> elemir: the person doesn't appear to be: https://twitter.com/#!/skilpat/status/180257184200925184
16:08:54 <nart> System.Plugins.Load says: The first argument is the path to the object file to load, the second argument is a list of directories to search for dependent modules. The third argument is a list of paths to user-defined, but unregistered, package.conf files. The Symbol argument is the symbol name of the value you with to retrieve.
16:09:11 <nart> What's the Symbol argument ? i don't get it
16:09:49 <c_wraith> nart: the name in the file you're loading that you want to get access to
16:10:03 <c_wraith> nart: probably a function, though that depends on what you're doing.
16:10:16 <qued_____1> wtf is that?   infix n s
16:10:16 <qued_____1> ?
16:10:27 <nart> ah, it's the name of the function i want to load ?
16:10:30 <c_wraith> yes
16:10:51 <c_wraith> qued_____1: it's a fixity declaration for an identifier.
16:11:09 <nart> ok thanks, now i just have to understand it started Xquartz instead of loading my module
16:11:16 <nart> *why it started
16:11:53 <c_wraith> I don't think I can help with that one :)
16:12:11 <qued_____1> c_wraith: identifier in which sense?
16:12:37 <c_wraith> qued_____1: either an infix operator or a function (though fixity declarations only matter for functions when they're used infix)
16:13:58 <qued_____1> c_wraith: so I can e.g. define a new infix-operation with the following?  infix n =:=
16:13:59 <qued_____1> ?
16:14:09 <qued_____1> and what does 'n' mean
16:14:24 <c_wraith> qued_____1: no, you have to define it elsewhere.  that declaration just tells the parser how to handle it
16:14:42 <c_wraith> qued_____1: the number is the precedence, and has a range from 0 to 9
16:14:54 <c_wraith> qued_____1: 9 binds the most tightly, 0 binds the least tightly
16:15:31 <c_wraith> qued_____1: there are two additional declarations with the same syntax, infixr and infixl, that specify the operator to be left-associative or right-associative
16:16:00 <c_wraith> qued_____1: the infix declaration means that the operator cannot be used in an associative way
16:16:12 <qued_____1> and infix is right and left associative ?
16:16:17 <qued_____1> or unspecified?
16:16:25 <c_wraith> neither
16:16:52 <c_wraith> if you declare %$ as infix, ¬´a %$ b %$ c¬ª is a parse error
16:17:04 <mauke> > 1 == 2 == 3
16:17:05 <lambdabot>   Precedence parsing error
16:17:06 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
16:17:36 <elemir> > 1 == 2 == True
16:17:36 <lambdabot>   Precedence parsing error
16:17:37 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
16:17:46 <elemir> > (1 == 2) == True
16:17:47 <lambdabot>   False
16:17:58 <elemir> > True == 2 == 1
16:17:58 <lambdabot>   Precedence parsing error
16:17:59 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
16:18:12 <elemir> Hem =(
16:18:17 <c_wraith> elemir: the error message even says it's defined as "infix 4" in it. :P
16:18:43 <elemir> > 1 + 2 + 3
16:18:44 <lambdabot>   6
16:18:45 <mauke> that's another good thing Haskell stole from Perl
16:18:55 <mauke> comparisons are non-associative
16:19:31 <elemir> Heh
16:20:10 <c_wraith> it's true that the ability to say ¬´ x == y == False ¬ª has only ever led to pain...
16:20:11 <mauke> (the other thing is, of course, context sensitive operations)
16:21:01 <qued_____1> c_wraith: hm okay, but with infixl 9 %$ this would be valid?   (a %$ b) %$ c    (== a %$ b %$ c)   ?
16:21:18 <elemir> But for bools it's assocative ;)
16:21:19 <c_wraith> qued_____1: yes, that's correct
16:21:47 <qued_____1> c_wraith: and any way to specify right- and left-associativity ?
16:21:57 <parcs`> let (===) = (==) in 4 === 5 === False
16:22:01 <parcs`> > let (===) = (==) in 4 === 5 === False
16:22:02 <lambdabot>   True
16:22:32 <c_wraith> qued_____1: Nope. You have to tell it one way or the other to build the parse tree. operators default to infixl 9, if not specified otherwise
16:23:30 <nart> after i load the module, how can i use it ?
16:24:34 <qued_____1> which package to import for infixl / infixr / infix ?
16:25:11 <c_wraith> qued_____1: they're syntax, not functions
16:25:30 <qued_____1> ah okay ;)
16:25:38 <qued_____1> many thanks ;))
16:25:53 <bgamari> Anyone here have an opinion on where to put tests (properties and unit tests)?
16:26:02 <bgamari> in a library, that it
16:26:08 <bgamari> is*
16:26:33 <bgamari> it seems as though placing them alongside the actuall implementation just bloats import lists
16:26:42 <bgamari> although is quite convenient
16:26:58 <bgamari> and naturally gives rise to proper organization
16:28:00 <led_nottingham> hi all
16:28:34 <c_wraith> hmm.  Data.Sequence.Seq does not appear to be spine-strict
16:29:06 <nart> oh nice, it works
16:29:35 <alpounet> bgamari, i'd say in "test(s)/" :P
16:32:12 <bgamari> alpounet: Just stumbled upon a stackoverflow question, seems they agree with you
16:33:12 <alpounet> bgamari, btw, there was some work to support test suites in cabal
16:34:09 <singpolyma> is there a "best" rfc882/MIME parser for Haskell?
16:35:44 <c_wraith> huh.  How does seq interact with newtypes?  Does it ignore newtype constructors?
16:35:57 <c_wraith> :t Sum
16:35:58 <lambdabot>     Ambiguous occurrence `Sum'
16:35:58 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
16:35:58 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
16:36:12 <c_wraith> :t Product
16:36:13 <lambdabot> forall a. a -> Product a
16:36:29 <c_wraith> > Product undefined `seq` ()
16:36:30 <lambdabot>   *Exception: Prelude.undefined
16:36:46 <c_wraith> so, seq ignore newtypes
16:36:47 <Cale> c_wraith: newtype constructors have semantics such that they can be implemented without existing at runtime
16:37:22 <c_wraith> Cale: yes, but I wasn't sure about the implementation of seq.  It's magical, so it's allowed to either look at runtime representations or vary its behavior based on compile-time types
16:37:40 <c_wraith> But it seems it's implemented in terms of runtime details
16:37:42 <Cale> I suppose that's true :)
16:38:05 <nart> Ok now i get this error: Main.hs: Prelude.undefined
16:38:06 <mauke> Product ‚ä• is ‚ä•
16:38:24 <c_wraith> mauke: I just was looking for some trivial newtype wrapper I knew lambdabot had
16:38:36 <Cale> mauke wins
16:38:52 <Cale> seq _|_ y = _|_, and Product _|_ = _|_
16:39:02 <Cale> So seq (Product _|_) y = _|_
16:39:57 <c_wraith> yeah, ok, that is required
16:40:00 <Cale> nart: did you post your code somewhere?
16:41:00 <nart> Cale: wait for it
16:43:13 <nart> Cale: http://hpaste.org/65714
16:43:40 <Cale> oh, you're trying to get hs-plugins to work?
16:44:00 <nart> yep
16:44:03 <Cale> hmm
16:44:10 <nart> the first one works
16:44:13 <Cale> Would hint be okay for you?
16:44:21 <nart> the second, i get Main: Prelude.undefined
16:44:24 <nart> hint ?
16:44:35 <Cale> http://hackage.haskell.org/package/hint
16:45:32 <Cale> I'm not sure how much Don has kept up on keeping plugins up to date
16:45:41 <nart> mumble, i'll try it
16:45:44 <Cale> but hint is still building and working with new versions of GHC
16:45:52 <Cale> (as far as I know)
16:46:02 <nart> thanks for the .... hint
16:46:03 <c_wraith> ...  eventually
16:46:14 <c_wraith> I'm not sure hint was ever updated for ghc 7.2
16:46:21 <c_wraith> even though other people sent patches to do it
16:46:26 <Cale> hackage says it built okay in 7.4
16:46:37 <c_wraith> guess it was updated eventually, then
16:46:39 <nart> i'm still at 7.0.4
16:48:06 <Cale> nart: The problem, I think is that plugins, to the best of my knowledge, still contains .hi parsing code which needs to be kept up to date with each version of GHC, rather than calls to the GHC API.
16:48:18 <Cale> (The library was developed before the GHC API existed)
16:48:39 <Cale> sorry about the commas, they're a bit off :P
16:49:59 <nart> why there isn't event a little piece of example code
16:50:02 <nart> :(
16:50:14 <gwern> what's wrong with hint? works well with mueval
16:51:15 <luite_> does anyone know a haskell parser written in javascript, that can parse haskell with ghc exts?
16:51:49 <monochrom> that would be very 31337
16:52:03 <monochrom> probably takes a supergenius to do :)
16:52:18 <luite_> I don't feel like writing one from scratch :(
16:52:47 <rhubarb> sure what else would you have to do :)
16:53:10 <repl> ?
16:53:31 <monochrom> when in javascript, I would only do whatever regex can do
16:53:33 <luite_> anyone want to write one for GSoC? ;p
16:54:01 <Cale> luite_: why do you need that?
16:54:23 <Cale> luite_: Working on a client-side Haskell interpreter?
16:54:56 <luite_> Cale: not for an interpreter, just for context sensitive help
16:55:28 <danharaj> Would it be hard to port the relevant parts of GHC?
16:55:43 <nart> anyone has an example of how to load an external file and use the function inside it, with hint ?
16:55:47 <monochrom> yikes, that's worse than rewrite
16:55:51 <luite_> danharaj: hehe I was thinking of trying to compile haskell-src-exts with uhcjs
16:55:52 <Cale> GHC I believe uses a Haskell parser generator
16:56:01 <Cale> (I think happy)
16:56:04 <danharaj> luite_: heh
16:56:07 <monochrom> oh, parser generator is better
16:56:28 <luite_> but it would need rather high performance, not sure that haskell->js compiled code would work well enough
16:56:49 <danharaj> Does GHC use happy or something else?
16:56:56 <monochrom> no, I now think parser-generator for js is best
16:57:05 <danharaj> 'cause writing a js backend to happy might not be too hard. JS isn't too bad for functional programming.
16:57:19 <danharaj> one could even consider it nice!
16:57:30 <monochrom> then again parser-generator for js is likely unaware of "operator precedence is unknown upfront"
17:00:06 <mjrosenb> monochrom: operator precedence is unknown upfront-- does that hold for js or haskell?
17:00:12 <monochrom> haskell
17:00:40 <mjrosenb> monochrom: ok, that makes sense.
17:00:52 <mjrosenb> sml suffers from this problem as well
17:01:08 <mjrosenb> it also has the issue of "is this a constructor or a binding"
17:01:24 <monochrom> yes, all good languages have this problem, or rather have this feature
17:01:46 <monochrom> ah, haskell trumps that one :)
17:02:37 <monochrom> yeah, "parser-generator for js" I mean "parser-generator that emits js code"
17:03:33 <mjrosenb> i believe |fun foo ^^^ bar ::: baz = quux()| can be parsed in like 20 different ways depending on the context
17:03:45 <monochrom> existing ones are written by C-like people for C-like people. they would spend whole careers on optimizing shift-reduce thingies and not one second on supporting user-defined operator precedence
17:04:10 <mjrosenb> or producing useful error messages :-p
17:05:36 <nart> damn it, damn hint :S
17:06:12 <luite_> hm, what parser generator does ghc use?
17:09:05 <monochrom> wait, haskell context-sensitive help in javascript?
17:09:27 <monochrom> is it for an IDE already written in javascript?!
17:09:45 <luite_> hehe, apparently it uses happy and it spits out 230 different functions that are just unsafeCoerce with a type sig :)
17:10:04 <monochrom> oh yikes
17:10:12 <luite_> monochrom: no
17:10:16 <monochrom> well that's right up javascript's alley, isn't it? :)
17:10:43 <monochrom> 99% of the time you just omit both "unsafeCoerce" and the type sig, and you're done :)
17:10:49 <luite_> yeah this proves that javascript is a better language for parsers
17:10:58 * copumpkin slaps luite_ 
17:12:19 <luite_> the other thing is a huge binary string
17:12:24 <luite_> that I guess is the shift/reduce table
17:12:36 <kallisti> @hoogle handleError
17:12:36 <lambdabot> Network.CGI handleErrors :: (MonadCGI m, MonadCatchIO m) => m CGIResult -> m CGIResult
17:13:06 <BMeph> Is there a special name for cobind on Streams, like concatMap is bind for lists?
17:13:27 <dibblego> roconnor: want to release data-lens 4.0.0 any time soon?
17:15:49 <monochrom> @snap copumpkin
17:15:50 * lambdabot would never hurt copumpkin!
17:15:53 <monochrom> hehe
17:15:58 <copumpkin> :)
17:16:35 <monochrom> lambdabot has a huge binary string too. it's the "don't hurt these" list
17:19:05 <nart> hi
17:19:24 <shapr> howdy nart, how's code?
17:19:24 <nart> in hint, after i loadModules ["Module.hs"]
17:19:41 <nart> how can i use the funs inside it ?
17:20:02 <nart> hint it's seriously making me cry eheh
17:20:15 <shapr> I've never used hint.
17:24:26 <ben> A common problem I have when thinking about writing interactive shell applications is that I want to be able to block on something like getLine while stuff happens and possibly prints to the terminal. Is there a package that lets that happen without whatever the user is writing getting mangled?
17:25:14 <ion> I wonder if readline has that?
17:25:37 <MrBusiness> Gentle folk, as a Haskell Guy Aspirant, I am quite taken with the qualities of Haskell itself, but I am curious to understand which school of thought governs the language's FFI enabling it to call C code. Is it declarative, where one merely writes code to describe the interfaces to Haskell, the compiler then handling the rest of the conversions and interconnections, or is there an imperative element wherein one has to load up a stack for passing and t
17:25:37 <MrBusiness> ranslating things between environments? Or is it yet another discipline of which my meager mind has not yet conceived?
17:26:30 <theorbtwo> Why not look up the ffi interface, and see what it looks like to you?
17:27:33 <MrBusiness> My cursory glances at it haven't given me a big impression in either direction
17:27:43 <parcs`> MrBusiness: you declare the type of the foreign function and then use it like any other function
17:27:58 <MrBusiness> ah, that sounds declarative
17:28:00 <dmwit> "load up a stack for passing"?
17:28:08 <MrBusiness> Yeah, in the vein of Lua or Tcl
17:28:13 <ion> I‚Äôm not sure if this is the answer you‚Äôre looking for, but it‚Äôs a good idea to create a thin FFI interface which mirrors the C interface as closely as possible and then a higher-level idiomatic Haskell API in terms of that.
17:29:01 <MrBusiness> ion, that's a good answer as well. it tells me that there may be come complexities, but that they may end up being complexities handled more on the Haskell side than the C side, which is a good thing to my reckonign.
17:29:05 <danharaj> How would I go about writing a generic version of (|||) for arrows that works with sum types more general than Either a b?
17:31:04 <MrBusiness> theorbtwo, I guess another answer to your question is that I have to make a business decision here
17:31:47 <MrBusiness> ease of integration with extant C is a requirement for me, and if I that requirement isn't fulfilled, then I can aspire as much as I like, but the technical realities of the language won't meet my near-term needs
17:32:46 <MrBusiness> Perhaps I am thinking about the matter incorrectly? I've been bitten on this issue before with other languages I have examined.
17:32:59 <nart> ohh finally i got it to work
17:33:53 <quintess`> MrBusiness: importing from C is a one-line declaration e.g. foreign import ccall "math.h sin" c_sin :: CDouble -> CDouble
17:34:26 <MrBusiness> Hmm, that's interesting.
17:34:29 <xil> hey everyone. I'm looking for a function that would map a given function onto only the elements of a list that match a certain criteria. So in a way a combination of map and filter. Is there such a thing?
17:34:36 <MrBusiness> Though would that need to be called in a monad?
17:34:42 <theorbtwo> I'd say that FFI calls from haskell tend to be rather easy.
17:34:42 <ion> no
17:34:44 <MrBusiness> hmm
17:34:58 <hpc> :t let pred p f x = if p x then f x else x in pred
17:34:59 <lambdabot> forall t. (t -> Bool) -> (t -> t) -> t -> t
17:35:07 <theorbtwo> MrBusiness: Well, that one wouldn't be -- sin() is a pure function, so no monads are neccessary.
17:35:16 <hpc> > let pred p f x = if p x then f x else x in map (pred even succ) [1..10]
17:35:17 <lambdabot>   [1,3,3,5,5,7,7,9,9,11]
17:35:20 <quintess`> MrBusiness: you can make the return type in IO when appropriate, but you don't have to
17:35:25 <hpc> xil: ^
17:35:27 <xil> hpc: you're my hero
17:35:27 <MrBusiness> ah
17:35:46 <MrBusiness> So if I knew of probable impurity on the C side, I might need to take more, or at least different, steps?
17:36:54 <hpc> MrBusiness: essentially, what you would do is foreign import ccall "mymath.h print_and_sin" c_print_sin :: CDouble -> IO CDouble
17:37:02 <MrBusiness> ah
17:38:23 <ion> The bindings-DSL macros make FFI even nicer. As a trivial example, ‚Äú#ccall sin , CDouble -> CDouble‚Äù and you‚Äôll have c'sin :: CDouble -> CDouble and p'sin :: FunPtr (CDouble -> CDouble).
17:39:45 <MrBusiness> Alas, I fear I may be unable to appreciate the full implications of that, given my present, limited level of knowledge.
17:39:52 <monochrom> where "sin" means sine, not the sin of impurity :)
17:40:24 <luite_> unsafeSin
17:40:29 <danharaj> cardinalSin
17:40:41 <hpc> MrBusiness: yeah, i don't really appreciate the distinction either, but you can probably start with @hoogle FunPtr
17:40:54 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Ptr.html#t:FunPtr
17:41:00 <quintess`> FunPtrs are for passing back to C as callbacks mostly
17:41:26 <MrBusiness> callbacks, the pointers that go thunk
17:41:27 <MrBusiness> heheh
17:41:32 <ion> mrbusiness: That just means you‚Äôll have something on the Haskell side to give to a C function that wants a double (*f) (double) parameter.
17:42:13 <MrBusiness> Ah, makes sense
17:42:38 <ion> But that‚Äôs just one of the many convenience macros in bindings-DSL.
17:43:25 <MrBusiness> Ah, ok. Well, overall, I like what I am hearing. It sounds to me as though trying to wrap my head around developing some active competence in Haskell would be well worth my time.
17:43:33 <ion> https://bitbucket.org/mauricio/bindings-dsl/wiki/DetailedUsageGuide
17:44:38 <MrBusiness> Only tricky part now will be convincing my partner in crime not to fear the invariance.
17:44:38 <MrBusiness> Well, that and actually becoming competent.
17:44:58 <roconnor> dibblego: think I should release it without improved docs?
17:45:25 <dibblego> roconnor: yes, do better docs as we go
17:45:59 <roconnor> okay.
17:49:50 * hackagebot FilePather 0.1.8 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.1.8 (TonyMorris)
17:52:54 <roconnor> > sqrt(2*pi*5)*(5/exp 1)^5
17:52:55 <lambdabot>   118.01916795759013
17:52:56 <repl> [3,2,1] > [2,10,100]
17:53:05 <repl> True
17:53:14 <repl> why
17:54:23 <ion> 3 > 2
17:54:40 <ion> Which comes later in the book, section 3.2.1 or section 2.10.100?
17:58:54 <shapr> ion: section 3.2.1
17:59:13 <shapr> oh wait, rhetorical question
18:02:53 <monochrom> sections 2.10.100 sounds like what happens in a law book :)
18:08:44 <shapr> Spring break is next week, I want to write some Haskell code!
18:09:01 <shapr> Is there a "libraries wanted" section of the Haskell Wiki?
18:11:11 * BMeph ponders: "2.10.100": hands, toes, grandkids? ;)
18:14:07 <ion> shapr: Everything edwardk has written, but with documentation.
18:14:13 <shapr> :-P
18:16:33 <edwardk> ion: =P
18:16:57 <edwardk> someone was proposing that documenting my code would be a worthwhile GSoC project ;)
18:17:28 <edwardk> and shapr _is_ a student these days =P
18:17:44 <yasar> When someone says "it's in Prelude" does it mean "it's in the haskell standard library, and it's imported automatically?"
18:17:46 <shapr> edwardk: Yah, except GSoC doesn't do documentation only projects.
18:17:57 <shapr> edwardk: I would like to apply for a GSoC project though!
18:18:25 <luite_> cool
18:18:33 <luite_> can you write a haskell parser in javascropt? ;p
18:18:41 <ion> yasar: This <http://hackage.haskell.org/package/base> is the ‚Äústandard library‚Äù and this <http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Prelude.html> is the subset of it that‚Äôs imported by default.
18:18:50 <edwardk> ok, just pretend to be 17 and we'll go for google code-in. then documentation is acceptable ;)
18:18:58 <edwardk> shapr: i'm pretty sure you can pass
18:19:09 <shapr> ha, you're funny
18:19:18 <shapr> My classmates mostly think I'm 25.
18:20:14 <edwardk> its the enthusiasm and that baby face of yours
18:20:38 <shapr> Probably so, they called me a theory nerd when I was upset we won't do Russell's Paradox in my Discrete Math class.
18:21:35 <luite_> hmm, that's not exactly a discrete math subject is it?
18:21:54 <shapr> Set theory is discrete math, right?
18:22:05 <edwardk> discrete math is usually where they kind crash course through people through a lot of intro proof techniques
18:22:14 <shapr> Yah, I'm enjoying those parts.
18:22:15 <Ralith> Where can I read about constraint simplification for multi-parameter typeclasses in the absence of other type system extensions?
18:22:22 <luite_> hmm, right, in that case it would fit in :)
18:22:33 <edwardk> ralith: look up typing haskell in haskell
18:22:35 <seydar> i gots a question on cuckoo hashing with two hash functions
18:22:35 <seydar> let's say we have an element i that is already in its secondary position
18:22:35 <seydar> and then j comes in and wants i's secondary position
18:22:35 <seydar> where does i go to?
18:22:42 <seydar> i gots a question on cuckoo hashing with two hash functions
18:22:45 <seydar> let's say we have an element i that is already in its secondary position
18:22:47 <seydar> and then j comes in and wants i's secondary position
18:22:49 <Ralith> edwardk: I assume that's a title?
18:22:49 <shapr> Ralith: Have you read Martin Sulzmann's work on constraint handling rules?
18:22:50 <seydar> where does i go to?
18:22:50 <copumpkin> seydar: you already pasted that once
18:22:57 <seydar> copumpkin: whoops. sorry
18:22:58 <edwardk> Ralith: on that site he has a version that does MPTCs and a description of the basic algorithm without it that you can use to compare
18:23:00 <Ralith> shapr: nope, haven't even heard the name!
18:23:01 <edwardk> yes
18:23:06 <seydar> copumpkin: thought i wasn't connected yet
18:23:20 <edwardk> i'd avoid diving into CHR right away
18:23:36 <Ralith> edwardk: CHR?
18:23:41 <Ralith> orite
18:23:43 <shapr> Constraint handling rules
18:23:43 <edwardk> the THIH approach is remarkably straightforward
18:23:53 <shapr> Also, I don't know if Sulzmann does MPTCs.
18:24:00 <edwardk> and you can even mock up a typechecker with it
18:24:20 <yasar> If a function's type signature is  ":: [a] -> [a]" , can it return empty list ?
18:24:51 <geekosaur> yes
18:24:51 <shapr> I met Sulzmann once in Uppsala, nice guy.
18:24:56 <geekosaur> the a there is a type, not a value
18:25:22 <cody_> If I have a function called primes in primes.hs, can I import that function to other .hs files?
18:25:29 <yasar> so an empty list can be of type [a] then?
18:25:39 <geekosaur> for any a, yes
18:25:42 <geekosaur> :t []
18:25:43 <lambdabot> forall a. [a]
18:25:51 <Ralith> edwardk: only mock up? I'm interested in building a viable implementation.
18:26:12 <edwardk> ralith: well, you can carry it through to completion, but what i mean is the approach is pretty easy to get started playing with
18:26:19 <Ralith> ah, I see.
18:26:21 <Ralith> great!
18:26:24 <geekosaur> haskell does not come with a type for lists with a bounded size (that's a dependent type)
18:26:28 <edwardk> if you _really_ want a full haskell implementation you should probably look at OutsideIn(X)
18:26:50 <edwardk> because you'll box yourself in feature-wise following the THIH approach in the end
18:26:50 <Ralith> yeah, I've already got that on disk
18:27:07 <Ralith> I'm hoping to get something simpler working to start, though.
18:27:08 <geekosaur> you can create one using type level naturals, it's kinda ugly though (maybe one of the type level programming packages comes with one though)
18:27:16 <Ralith> OutsideIn(X) strikes me as significantly harder to implement.
18:27:36 <Ralith> though that's just conjecture, and I'd be happy to be wrong.
18:27:46 <edwardk> yeah, read through the THIH code on the site, build it up as you go along, then by the time you're done, you'll be able to follow the MPTC tarball he has pretty easily
18:28:00 <edwardk> OutsideIn(X) is pretty easy up until you get to equality constraints
18:28:16 <edwardk> there is code for a simple type checker in the back of the paper
18:28:40 <Ralith> a simple OutsideIn(X) implementation?
18:28:44 <edwardk> yes
18:28:47 <geekosaur> cody_, yes.  by default all top level names are exported; you can control that with an explicit export list
18:28:48 <Ralith> o.O
18:28:50 <Ralith> I didn't see that!
18:28:55 <geekosaur> or control how much you import with an explicit import list
18:28:58 <edwardk> it doesn't do the typeclass plumbing
18:29:06 <yasar> Is it common to use Maybe data type? It looks like it adds extra layer of complexity to me.
18:29:12 <Ralith> hm.
18:29:20 <edwardk> but its got the core of the inference algorithm
18:29:20 <edwardk> between that and what you learn from THIH you should be able to go pretty far
18:29:32 <edwardk> another good starting point is Daan Leijen's HMF
18:29:35 <geekosaur> yasar, absolutely.  it's how you indicate optional values
18:29:46 <Ralith> got that too, actually!
18:29:52 <edwardk> it deals with generalization in a different way than OutsideIn(X) but its very simple to follow
18:29:59 <Ralith> okay
18:29:59 <geekosaur> instead of something like NULL in C (which is actually an in-band value and therefore a problem if you actually consider 0 a valid value)
18:30:15 <ben> Why would you consider 0 a valid value?
18:30:16 <edwardk> you probably can't use it for a full haskell implementation, but it works pretty well.
18:30:23 <ben> It's an invalid value by definition
18:30:31 <edwardk> in fact, our compiler for a haskell-like language at work is built over an HMF core
18:30:51 <Ralith> to be clear, I'm not trying to implement haskell itself; just something with a very similar type system.
18:30:59 <hpc> > let x /? y = if y == 0 then Nothing else Just (x / y) in 15 /? 0
18:31:00 <lambdabot>   Nothing
18:31:07 <hpc> try doing that in C
18:31:30 <geekosaur> ben, actually no, it's invalid for most application pointers but if you're working in certain environments wanting to write to the base of memory can be perfectly sensible.
18:31:37 <hpc> also, try doing anything non-trivial with arrays
18:31:47 <hpc> the out-of-band value might be 0, -1, or pretty much anything
18:31:49 <ben> Oh, but then you're not writing standard C anyway :(
18:32:00 <geekosaur> but the more key point is that NULL is only out of band for application pointers; it's *not* out of band if you're trying to use it to mean an unset *number* instead of an unset *pointer*, for example
18:32:07 <geekosaur> there is no out of band integer value in C
18:32:20 <c_wraith> geekosaur: are you sure 239 isn't out of band?
18:32:26 <c_wraith> geekosaur: I've never needed it
18:32:48 <hpc> ben: in any event, the power of Maybe is not that you can say "this can be nothing", the power is in the fact that NOTHING ELSE can be
18:32:49 <geekosaur> you could approximate it by using an (int *) and setting the pointer value to 0 if you don;t have an actual int... which is more or less how you do a Maybe type in C
18:32:50 <ben> but NULL has pointer in the type :(
18:33:02 <hpc> ben: no it doesn't
18:33:10 <hpc> on most systems, it's #define NULL 0
18:33:32 <cody_> geekosaur: thanks
18:33:36 <zmoazeni> Hey guys, I'm trying to attempt to grok the State monad again, and I was wondering what this definition meant from http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-State-Lazy.html "class Monad m => MonadState s m | m -> s where" specifically the | after "MonadState s m". Not sure what that denotes
18:33:36 <hpc> and it's not even guaranteed to be 0
18:33:38 <edwardk> Ralith: Ah, then HMF might work fine. The main annoyance is that we wind up having to put in 'some' declarations when we try to manipulate a polymorphic argument to a function
18:33:43 <yasar> hpc: it is more like ((void *)0)
18:33:46 <geekosaur> it is allowed to be per the standard but it isn't usually on unix for backward compatibility reaosns which amount to exactly the situation I'm talking about
18:34:25 <geekosaur> (also, C++ I believe requires it to be a pointer)
18:34:34 <Ralith> edwardk: well, things like associated types are attractive, too--it just seemed to me that a simple HM+typeclasses checker would be a great deal easier to implement for the first version.
18:34:39 <zmoazeni> *attempting to grok‚Ä¶.bleh, I'm tired
18:34:52 <ben> in C++, false is a null pointer constant
18:34:55 <ben> let's not talk about C++
18:35:02 <edwardk> *nods* we needed rank-n types out of the gate
18:35:25 <ben> I think it's guaranteed that NULL == (void*)0, even if it's not literally defined as such
18:35:31 <ben> I mean in C
18:35:34 <squark42> Why do you think guys are there no projects like LLVM _in_ haskell? I mean we always talk about how nice FP languages are for compiler construction, but it seems that they are almost talking about Parsing (which is in my opinion the easy part). I know there is MLRisc, but it does not seem to be maintained ...
18:35:38 <Ralith> I don't have an immediate need for FCP, but associated types would actually be quite useful.
18:36:29 <edwardk> I have a little haskell kind checker (it does polymorphic kinds) that i keep playing with that uses type error slicing. You might consider playing with type error slicing as well, if you're starting from scratch
18:36:30 <zmoazeni> I've seen the bar ( | ) used for delimiting data constructors, just not sure if it means the same thing for a type class
18:36:48 <ben> Functional dependencies?
18:36:49 <edwardk> It makes the errors very easy to track down
18:36:52 <Ralith> oo
18:36:55 <hpc> zmoazeni: that sintax is functional dependencies
18:37:03 <hpc> it means "m uniquely determines s"
18:37:14 <Ralith> that's attractive, though I'm leery of having yet more studying to do before I get into the meat of things
18:37:25 <hpc> so you can't have 'instance MonadState Foo State' and 'instance MonadState Bar State'
18:37:26 <Ralith> does it mesh easily with OutsideIn(X)?
18:37:43 <hpc> it makes type-checking easier
18:37:55 <zmoazeni> Ah thanks, I was a looking for the term to google/read up on it.
18:37:55 <edwardk> ralith: i've been working on that part. ;)
18:37:59 <hpc> (read: decidable in cases it otherwise wouldn't)
18:38:12 <hpc> zmoazeni: nowadays i think that same thing would be done with type families
18:38:20 <hpc> but fundeps are good to learn too
18:38:36 <edwardk> http://www.macs.hw.ac.uk/~rahli/articles/thesis.pdf see page 94 for a compelling example
18:38:40 <geekosaur> yes, the standard requires that 0 be assignable to a pointer and behave as (void *) 0.  that's what allows NULL to not require the cast to pointer be built into it
18:39:44 <ben> It's (void*)0 on my linux anyway :)
18:39:49 <Ralith> dear christ, 380 pages?
18:40:05 <shapr> Hey, it's a thesis.
18:40:17 <Cale> Ph.D theses are usually pretty long
18:40:20 <edwardk> ralith: its a thesis. its more like, only 380 pages?
18:40:25 <Ralith> :P
18:40:38 <ben> I mean it literally says a null pointer is guaranteed to compare unequal to a pointer to any object
18:40:51 <ben> So it's an out of band value right out of the standard
18:40:54 <edwardk> my tiny little masters thesis is like 120 pages =P
18:41:14 <Ralith> I've got this horrible tradeoff
18:41:44 <dolio> 380 is pretty big.
18:41:48 <Ralith> I want to work on a compiler here and now, but there are so many exciting pieces of type system research that I could easily spend another year or two before actually getting anywhere.
18:41:51 <dolio> For a comp-sci theses, I think.
18:42:07 <dolio> Thesis, even.
18:42:09 <edwardk> then start with THIH, by the end of it you'll understand typeclasses
18:42:10 <danharaj> I think math theses don't usually run over 200 pages? Except for Jacob Lurie's massive tome of course.
18:42:46 <dolio> I'm looking through my thesis folder and I haven't found anything close to 380 yet.
18:42:52 <geekosaur> ben, did you see what I said earlier or are you just arguing for the sake of it?  unix has a long tradition of using NULL as an out of band value for non-pointers
18:43:12 <Ralith> edwardk: right, it's just that now you've got me interested in this thing that seemingly takes a whole book to thoroughly grasp :P
18:43:14 <geekosaur> in part because it also works as the end of string indicator in C strings and such
18:43:17 <edwardk> dolio's reading tends to run towards math though
18:43:26 * Ralith shake fist
18:43:38 <ben> geekosaur: I'm happy to agree with you that there's no out-of-band value for integers
18:43:39 <edwardk> ralith: his thesis is 3 almost completely unrelated parts
18:43:58 <dolio> 284 is the longest so far.
18:44:04 <Ralith> oh, so only on the order of 125 pages
18:44:06 <Ralith> that's much better
18:44:07 <Ralith> >_>
18:44:08 <edwardk> yeah
18:44:11 <edwardk> =)
18:44:24 <edwardk> the core idea can be summed up in about 20, but i can't find the paper
18:44:57 <geekosaur> it's severely broken practice, but also historical and occasionally still found in practice
18:45:07 <squark42> it's my first time at #haskell and the main topic is the length of theses :D
18:45:22 <Ralith> didn't you just link it to me?
18:45:23 <squark42> now that's a future anectote ;)
18:45:32 <dolio> Okay, closest is Nathan Mishra-Linger at 328.
18:46:14 <edwardk> http://www.macs.hw.ac.uk/~rahli/articles/talk-tes.pdf and http://www.macs.hw.ac.uk/cs/techreps/docs/files/HW-MACS-TR-0079.pdf
18:46:20 <edwardk> i linked you to his thesis
18:46:25 <geekosaur> (and my netwprk is falling over every 90 seconds, grrrr)
18:46:27 <edwardk> he wrote up a shorter version at the link above
18:46:37 <edwardk> the first is a set of slides talking about it, the latter is the paper in question
18:46:49 <edwardk> i just couldn't find it easily, since the main link on the internet for it is broken ;)
18:47:14 <Ralith> oh.
18:47:14 <Ralith> aw
18:47:41 <Ralith> well, if it's nontrivial to integrate with OutsideIn(X), I imagine I'd be best off waiting for you to progress there regardless.
18:47:48 <Ralith> since that's my current long-term target.
18:48:06 <edwardk> ralith: well, my stalling is due to the fact that i want to use another project of daan leijen's to make it faster
18:48:25 <Ralith> point stands!
18:48:59 <dolio> You only need the somes in the absence of properly scoped types.
18:49:00 <edwardk> ralith: https://github.com/ekmett/revisions once i add http://research.microsoft.com/apps/pubs/default.aspx?id=150180 will make it a LOT faster
18:49:06 <dolio> If that's your only gripe with HMF.
18:49:06 <hpaste> safeInit pasted ‚Äúyasar‚Äù at http://hpaste.org/65715
18:49:25 <edwardk> dolio: thats my big one in our current usage
18:49:33 <Philippa> edwardk: thanks for the thesis link, I suspect I need to at least skim it given some of my interest in abusing intersections :-)
18:49:52 <yasar> can someone help me with safeInit function above, it gives me "Couldn't match expected type `[a]' with actual type `Maybe [a0]'"
18:49:53 <dolio> I had a scheme for eliminating the 'some' keyword, too, but I think we decided it was too dangerous.
18:50:05 <Ralith> edwardk: if it's already published, what's the stalling about?
18:50:11 <edwardk> Philippa: yeah the intersections turn out to be largely irrelevant for the type error slicing machinery, since they started with them then figured out that the way to make it fast was not to use them ;)
18:50:32 <edwardk> Ralith: his work is published. my reimplementation of it in haskell isn't done.
18:50:44 <Ralith> ah.
18:50:54 <edwardk> i built a nicer haskell version that uses sparks for the base technique, i just didn't get the recording feature in before i got bored with it
18:51:30 <edwardk> and i need the recording feature and some extra tricks do deal with the extra complexities involved in transaction chaining that come from unification to get it to fit this domain
18:52:17 <Ralith> is it really so slow as to call for such optimizations?
18:52:57 <geekosaur> yasar, the problem there is that you're reinvoking safeInit, which returns a Maybe [a], but you're using it as if it returns [a]
18:53:13 <dolio> edwardk: Anyhow, I think the real issue is the need to annotate the arguments in general, which we can't get rid of unless we do some push from type signatures into terms, and maybe not even then. But maybe that's what you mean.
18:53:21 <dolio> I don't think the occasional 'some' within those is that bad.
18:53:25 <edwardk> yes and no. its fast enough to be practical. i, however, want a very very fast compiler, and if i can speed up from expected quadratic to something close to expected linear, i would like that ;)
18:53:28 <dolio> Or, that much worse.
18:53:44 <edwardk> dolio: yes
18:53:51 <edwardk> dolio: (er yes, thats what i mean)
18:53:55 <dolio> Okay.
18:54:11 <yasar> geekosaur: How can I fix it?
18:54:33 <edwardk> the way our Applicative/Monad/Foldable/Traversable modules look is somewhat galling to me
18:54:52 <edwardk> those 'some's keep you from really following some pretty obvious algorithms
18:54:52 * hackagebot misfortune 0.1 - fortune-mod clone  http://hackage.haskell.org/package/misfortune-0.1 (JamesCook)
18:56:30 <Ralith> edwardk: mh. Anyway, just to be clear‚Äîthe lessons from THIH should ease the implementation of MPTCs in OutsideIn(X)?
18:56:48 <edwardk> yes
18:57:05 <hpaste> geekosaur annotated ‚Äúyasar‚Äù with ‚Äúyasar (annotation)‚Äù at http://hpaste.org/65715#a65716
18:57:09 <edwardk> THIH goes through the single parameter typeclass approach in a writeup, then there is code that is pretty much a minimal modification of that to deal with MPTCs
18:57:18 * Ralith nod
18:57:26 <geekosaur> you could also unwrap the safeInit but that's doing it the slow way
18:57:38 <edwardk> and then it stops and you need to learn the rest of this stuff ;)
18:57:47 <geekosaur> generally you use a helper function in this kind of situation
18:57:51 <Ralith> just wanted to make sure that it wasn't going to be only applicable to a non-OutsideIn(X) approach
18:57:58 <Cale> tibbe_: So unordered-containers-0.1.4.6 had a serious bug which appears to be thankfully gone in new releases
18:58:38 <Ralith> as I mentioned, I'm taking a more naive approach just for the sake of getting something running to play with, and intend to swap in the more general solution.
18:58:52 <Cale> tibbe_: I would insert a key into a hashmap, followed by a bunch of inserts and deletes on other unrelated keys, and the first key would be missing the next time I looked.
18:59:26 <Cale> (afraid I don't have a simple testcase)
18:59:33 <yasar> geeka
18:59:46 <yasar> geekosaur: thanks.
19:02:02 <yasar> geekosaur: It gives  "Non-exhaustive patterns in function inits" error
19:02:20 <Cale> but yeah, anyone who is using older releases of unordered-containers, I would recommend they update ;)
19:02:36 <JoeyA> What's up with unordered-containers?
19:02:39 <geekosaur> it should only be a warning, not an error
19:02:54 <tibbe_> Cale: it's fixed :)
19:02:59 <geekosaur> you cna add the additional case if you turned on -Werror, it won;t be invoked because the wrapper handles it already
19:03:03 <tibbe_> Cale: quite embarresing
19:03:24 <geekosaur> (the added case is:  inits [] = undefined)
19:03:24 <edwardk> ralith: if nothing else the general shape of the problem can be moved over. a lot of the details change. e.g. the need for a separate type schema is eradicated when a forall becomes a valid part of a type
19:03:36 <danharaj> is unordered-containers in the platform yet?
19:03:48 <Ralith> wait, OutsideIn(X) supports FCP?
19:04:02 <yasar> It is an exception in ghci. I wil just add additional pattern to silence it.
19:04:04 <Ralith> I suppose it must, given that I believe GHC does; that hadn't occurred to me.
19:04:11 <edwardk> OutsideIn(X) provides rank n types
19:04:20 <Ralith> great!
19:04:24 <edwardk> Just like HMF does
19:04:34 <Ralith> yeah, but that's the *point* of HMF, as I understand it
19:04:35 <edwardk> the generalizations just happen in slightly different places
19:04:50 <edwardk> well, HMF is basically the most brain dead thing you can do that is correct ;)
19:04:52 <tibbe_> danharaj: nope
19:04:59 <Ralith> while OutsideIn(X) tries to solve the much more general problem of tidily encompassing all manner of extensions.
19:04:59 <edwardk> Which is great, because its easy
19:05:18 <edwardk> OutsideIn(X) tries to make it much more obvious when annotations are necessary, because the rules are simpler
19:05:36 <edwardk> and the (X) part of course deals with extensions
19:05:42 <Ralith> right
19:05:54 <danharaj> tibbe_: ought to be!
19:05:56 <Ralith> hm.
19:06:16 <tibbe_> danharaj: some day :)
19:07:01 <edwardk> another point in the design space was the old FPH paper
19:07:10 <dolio> HMF does at least one thing better than OutsideIn(X).
19:07:45 <edwardk> which was dimitrios' first stab at getting everything right. http://research.microsoft.com/pubs/79865/fph.pdf
19:07:50 <dolio> Also, I'm still curious if OutsideIn handles impredicative instantiation at all.
19:07:53 <dolio> Since GHC seems not to.
19:08:01 <Cale> To be perfectly honest, I find hashing really scary. :)
19:08:14 <hpaste> yasar annotated ‚Äúyasar‚Äù with ‚Äúyasar (annotation) (annotation)‚Äù at http://hpaste.org/65715#a65717
19:08:43 <yasar> geekosaur: Can you check last annotation?
19:09:09 <edwardk> dolio: well, FPH used to go out of its way to do so, but i'm not sure about the status of it in OutsideIn
19:09:10 <Cale> (but I also think that unordered-containers should get into the platform as it matures :)
19:09:11 <Ralith> you mentioned that the OutsideIn(X) paper contains a simple example implementation towards the back. All I can see is references to the full implementation used in GHC.
19:10:01 <edwardk> ralith: lemme find the right version of the paper
19:10:23 * Ralith is referring to the one from http://www.haskell.org/haskellwiki/Simonpj/Talk:OutsideIn
19:10:33 * geekosaur thinks he missed something, sigh
19:10:45 <tibbe_> Cale: I will eventually propose it, once it has matured and the API expanded to match containers
19:11:12 <Cale> tibbe_: I've been giving it a reasonable workout in the pure implementation of our game engine :)
19:11:21 <hpaste> geekosaur annotated ‚Äúyasar‚Äù with ‚Äúsorry, wrong base case‚Äù at http://hpaste.org/65715#a65718
19:11:30 <geekosaur> and I want my network back...
19:11:41 <tibbe_> Cale: I'd be interested to know if it performs worse than Data.Map or Data.HashMap from the hashmap package in any cases
19:12:02 <edwardk> ralith: look at http://research.microsoft.com/en-us/people/dimitris/arbitrary-rank.pdf the code in the back of that
19:12:46 <Ralith> that's the same basic algo? o.O
19:12:51 <Cale> tibbe_: I'm fairly sure it's a good bit better, but not so much better for us to save us from having to do a variant which stores things in IORefs instead. :)
19:13:09 <tibbe_> heh
19:13:15 <edwardk> its definitely quite recognizable in the final algorithm
19:13:19 <tibbe_> Cale: do you need a concurrent mutable hashtable?
19:13:40 <Cale> tibbe_: Doesn't need to be concurrent for us -- the game engine is deterministic
19:13:53 <tibbe_> ok
19:14:05 <Cale> We're using a hashmap as a cache of computed behaviours (in the FRP sense)
19:14:18 <tibbe_> ah
19:14:46 <geekosaur> yasar, I kinda got caught between two implemnetations, either one correct, mixing the base case for onr ewith the generator for the other = wrong
19:16:04 <edwardk> ralith: its missing all the constraint mumbo jumbo though
19:16:16 <Ralith> hm.
19:17:02 <Ralith> decisions, decisions.
19:17:17 <Ralith> well, I should probably read THIH either way, so I'll start there.
19:17:19 <Ralith> thanks.
19:17:57 <edwardk> if nothing else THIH demystifies a lot of this
19:18:06 <edwardk> because you can start off working on type checking pretty much from line 1
19:18:27 <edwardk> and you can keep testing as you go
19:19:04 * Ralith nod
19:19:24 <Philippa> edwardk: so I don't think constraints are mumbo jumbo, but I think most presentations suck
19:19:35 <edwardk> i use a slightly different representation for the code than THIH, because i like higher rank types, and the FPH/OutsideIn(X)/HMF approach all need a Forall constructor in their types, which kind of screws up the way THIH deals with bound variables
19:19:43 <Philippa> THIH is definitely one middle ground if you recognise the relationship between constraints and qualifications
19:19:49 <geekosaur> and packet loss is now so high I'm not even gonna bother any more tonight :/
19:20:22 <edwardk> as a result i'd recommend considering a nice locally nameless type representation or barendregt convention, etc. rather than the naive string substitutions
19:20:45 <Ralith> barendregt?
19:20:51 <Philippa> geekosaur: ow
19:21:03 <Ralith> (incidentally, the link in the github description of your revisions package is down)
19:21:11 <dolio> Well, pretty much anything is better than strings.
19:21:14 <edwardk> barendregt convention = every binder binds unique name
19:21:19 <edwardk> which one?
19:21:37 <edwardk> ah i haven't pushed it to hackage yet is why
19:21:39 <dolio> I'm not really sold on the Barendregt convention.
19:21:44 <Philippa> dolio: yeah, I have an appalling habit on that front while I'm in Perlis mode on "just implement the typing rules"
19:21:48 <edwardk> dolio: we don't use it very well
19:21:51 <dolio> I'm still not sure we're actually doing it right.
19:22:25 <Philippa> Barendregt's wonderful when you're writing up the rules. Trickier at implementation, you have to worry about whether you're typeful enough :-(
19:22:32 <edwardk> dolio: had i it to do over i probably would have adopted the nice locally nameless rep i use now
19:22:41 <dolio> Yeah.
19:23:05 <edwardk> then we wouldn't be making up IDs in the parser, etc.
19:23:30 <edwardk> and we wouldn't have had to add that big parallel variable supply, and would be swimming in puppies and rainbows
19:23:32 <Philippa> heh, so last time I did it, I just wrote a normalisation pass post-parser?
19:23:49 <Philippa> but it's worse when you're having to instantiate type variables and so forth
19:24:05 <Philippa> doubly so if you've got no metavariable distinction
19:24:27 <edwardk> we just fed out parser a variable supply, and let it churn them out as it goes. not great, not terrible
19:24:30 <dolio> Philippa: I have a constant anxiety that we're substituting something such that a term gets inlined into two places without the variables refreshed to be unique.
19:24:31 <byorgey> AIUI the Barendregt convention is not intended to be an implementation technique.
19:25:00 <dolio> It's been a bug once, at least.
19:25:13 <edwardk> byorgey: too late =P
19:25:31 <byorgey> it's more of a metaconvention for writing down type systems without actually specifying all the details of alpha conversion, fresh name generation, etc.
19:25:32 <dolio> But there's also a question of whether it matters because we might refresh all the variables when opening certain things up and never notice.
19:25:34 <byorgey> hehe
19:25:41 <Philippa> byorgey: death of the type theorist!...
19:26:07 <Philippa> dolio: yeah, that's what I mean re typefulness - it's so tricky to pin down
19:26:09 <edwardk> man this barendregt guy gave us an implementation technique that is so bug prone‚Ä¶ ;)
19:26:49 <edwardk> evil henk, sitting there all dutch and smug in that hat
19:27:09 <dolio> Maybe on innovation day we can switch to locally nameless, if we ever have another one of those.
19:27:29 <dolio> It is a pretty innovative technique.
19:27:49 <edwardk> yeah
19:28:12 <edwardk> or we can just do it and listen to paul cry
19:28:27 <Philippa> so I've never tried properly abstracting across implementation techniques. I'm guessing "I am not an number..." type situations make that at least moderately tricky to do because you don't necessarily know what info it's useful to have available?
19:28:41 <dolio> You're not the one who has to have daily progress meetings with him.
19:28:43 <byorgey> Barendregt has a hat?
19:28:45 <Philippa> (though realistically, knowing which variables are bound /ought/ to be enough for anybody. 640K and all that)
19:28:49 <byorgey> oh, this one? http://www.boeddhistischeomroep.nl/uploadedImgs/henk_barendregt.jpg
19:29:04 <byorgey> he does look pretty smug
19:29:04 <edwardk> http://www.google.com/imgres?imgurl=http://www.boeddhistischeomroep.nl/uploadedImgs/henk_barendregt.jpg&imgrefurl=http://www.boeddhistischeomroep.nl/uitzending.aspx%3FlIntEntityId%3D961%26lStrAction%3DshowForm%26lIntType%3D1&h=185&w=250&sz=22&tbnid=7Rk4h0iLjW4ReM:&tbnh=90&tbnw=122&zoom=1&docid=pyjiO04GKVgjTM&hl=en&sa=X&ei=yo1qT4SCKuOJ0QHC5cTDBg&sqi=2&ved=0CEwQ9QEwBQ&dur=324
19:29:16 <byorgey> yep, that's the one
19:29:22 <edwardk> makes him look a lot like dan friedman in that picture
19:29:24 <byorgey> except with more Google
19:29:36 <edwardk> =)
19:31:20 <byorgey> Philippa: yeah, abstracting over implementation techniques I think still counts as research!
19:31:36 <byorgey> Philippa: we tried doing it a bit with Unbound but it's tricky
19:32:00 <dolio> Isn't abstracting over techniques essentially working in one of those nominal type theories?
19:32:03 <sansor> i am having problems with using parMap on Ubuntu 11.10 (segfault due to memory leak) is this expectable
19:32:17 <dolio> That has built in types of 'names up to alpha conversion' and 'binders'.
19:32:26 <byorgey> dolio: sure, that's one way to do it, and that's more or less exactly what we were trying to do with Unbound
19:32:29 <dolio> Then you just use them, and the underlying theory does the right thing.
19:32:49 <byorgey> we had both a locally nameless and nominal implementation, though the nominal one is now bitrotted
19:33:47 <Philippa> dolio: or trying to harvest one, yeah. But yes, I'd half forgotten those exist
19:34:53 * hackagebot hmatrix-syntax 0.1.2 - MATLAB-like syntax for hmatrix vectors and matrices  http://hackage.haskell.org/package/hmatrix-syntax-0.1.2 (ReinerPope)
19:34:55 * hackagebot isohunt 0.1.2 - Bindings to the isoHunt torrent search API  http://hackage.haskell.org/package/isohunt-0.1.2 (ReinerPope)
19:35:19 <sansor> where can i ask questions about parMap memory leak problems in GHC 6.12?
19:35:40 <tibbe_> sansor: no
19:35:40 <tibbe_> sansor: haskell programs shouldn't segfault :)
19:35:40 <tibbe_> it could be a bug in GHC when failure to allocate causes a segfault where it should really raise an out-of-memory exception
19:36:07 <byorgey> sansor: GHC 6.12 is quite old though
19:36:22 <sansor> it's the default in ubuntu 11.10
19:36:33 <byorgey> yes, I'm aware of that
19:36:38 <sansor> i was wondering if there is a work around
19:36:50 <sansor> i mean, if it's a known problem...
19:37:04 <byorgey> sansor: sure. did you try searching on the GHC bug tracker?
19:37:33 <sansor> i saw some bug reports for 6.8 about GC not dealing properly with sparks
19:38:04 <sansor> if this is the same problem i think it is fixed in newer versions
19:38:05 <nyingen> with lambdabot, is there any way to use @src to see the code for a function implemented in a particular instance of a class?
19:38:23 <mauke> @src [] return
19:38:24 <lambdabot> return x    = [x]
19:38:28 <sansor> however, it'd be really good if there was a workaround
19:38:32 <byorgey> nyingen: for some specific instances you can do what mauke just showed
19:39:13 <sansor> http://hackage.haskell.org/trac/ghc/ticket/2185
19:39:26 <nyingen> mauke: ah, excellent
19:40:37 <sansor> i am trying to switch from python to a better language for daily use
19:41:17 <sansor> i really like monads and parallel strategies but i have doubts about haskell
19:41:24 <yasar> Can I look at how Prelude's functions are written?
19:41:39 <byorgey> sansor: what sort of doubts?
19:41:53 <sansor> the parMap error scared me a bit
19:41:57 <Philippa> yasar: I believe the Report includes a standard implementation, if not then there's definitely one with GHC
19:42:06 <sansor> i don't know if it is actually fixed
19:42:17 <Philippa> (some bits are punts to the compiler's innards, of course)
19:42:20 <sansor> and i don't know if the strategies library is well-supported
19:42:25 <byorgey> yasar: sure. (1) search for a function on Hoogle (haskell.org/hoogle) (2) click on the result you want (3) click on the "Source" link on the right-hand side of the documentation
19:42:53 <byorgey> yasar: for example here is the implementation of map: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#map
19:43:19 <yasar> byorgey: thanks a lot.
19:43:56 <sansor> byorgey: do you know how well the parallel branch is supported in general
19:44:15 <byorgey> sansor: parallel branch?
19:44:23 <sansor> the parallel strategies
19:44:27 <byorgey> sansor: I would be willing to get the segfault is fixed.
19:44:41 <byorgey> the parallel strategies are just a library.  and I think they are well-supported.
19:44:55 <shapr> sansor: I switched to Haskell from Python too!
19:45:02 <byorgey> lots of people use Haskell for doing parallel and concurrent programming.
19:45:18 <sansor> byorgey: what is the most used library in general
19:45:25 <byorgey> sansor: for what?
19:45:34 <sansor> byorgey: for parallel computing in general
19:45:45 <yasar> Is this a comment -> {-partain:Char.-}
19:45:47 <Philippa> sansor: it might be worth asking some of your questions on haskell-cafe if you haven't already, btw
19:45:54 <byorgey> sansor: there is no such thing as "parallel computing in general" =)
19:46:36 <sansor> byorgey: sorry, i mean daily programming when i say in general
19:46:41 <yasar> I saw it in here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#words
19:46:56 <byorgey> sansor: a commonly used library for data parallelism is  repa
19:47:10 <byorgey> yasar: yes
19:47:42 <byorgey> sansor: but you should still be more specific.  exactly what sorts of tasks are you hoping to accomplish?
19:47:55 <byorgey> http://hackage.haskell.org/package/repa  by the way
19:48:05 <sansor> byorgey: i do a lot of data processing daily
19:48:20 <sansor> mostly data and pipeline parallelism
19:48:42 <sansor> so strategies seemed like a very suitable library for daily use
19:48:54 <sansor> it's very easy to write new stuff fast
19:49:41 <danharaj> mind that repa hasn't been brought up to 7.4 yet because of performance regressions.
19:49:48 <byorgey> sansor: OK. then yeah, take a look at repa, and also http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
19:51:33 <sansor> byorgey: thanks, that looks useful (does not look as powerful as strategies, though)
19:52:03 <sansor> do you have any experience with jocaml?
19:52:43 <yasar> Is there a function like dropWhile, but it drops while not?
19:52:47 <byorgey> sansor: note I'm not saying you shouldn't use strategies, I was just suggesting other things to look at too
19:52:58 <byorgey> sansor: no
19:53:08 <mauke> http://eppy7890.files.wordpress.com/2009/06/joe_camel.jpg
19:53:15 <byorgey> yasar: just do   dropWhile (not . yourFunction)
19:54:40 <hpaste> yasar pasted ‚ÄúsplitWith‚Äù at http://hpaste.org/65719
19:54:56 <yasar> byorgey: Can you check that paste?
19:55:43 <sansor> danaraj: on the dph page doesn't it say that it is avaialable on 7.4?
19:56:30 <sansor> danharaj: although it also says: "However, the implementation has many limitations and probably also many bugs"
20:06:47 <danharaj> sansor: DPH and Repa are separate packages.
20:08:33 <sansor> danharaj: ok, repa has version 2.2 so looks more promising
20:23:07 <hpaste> applicative annotated ‚ÄúsplitWith‚Äù with ‚ÄúsplitWith (annotation)‚Äù at http://hpaste.org/65719#a65720
20:24:24 <applicative> oh I see byorgey did supply yasar with the main point
20:25:16 <kallisti> I like passing around functions and pretending they're not functions.
20:25:29 <kallisti> this is primarily what I do in my Haskell code.
20:28:23 <yasar> applicative: Thanks. I did figured out myself though :)
20:29:17 <kallisti> I might make too many commits when I program under version control...
20:29:24 <kallisti> is that even possible?
20:29:32 <kallisti> like, spending too much time committing small changes?
20:30:16 <yasar> kallisti: Yes, that happens.
20:31:02 <yasar> kallisti: How small changes are you talking about by the way?
20:31:38 <kallisti> single line bug fixes, mostly.
20:31:46 <kallisti> I suppose that's acceptable
20:31:51 <kallisti> but I sometimes commit before I actually fix them.
20:41:57 <yasar> How can I say takeWhile not equal, like I say "takeWhile (<5) [1,2,3,4,5,6]"
20:42:49 <ion> (/= 5)
20:58:35 <bobajett> I have a stupid train schedule that lists arrival times without the am/pm info. so if I parse it I get say the arrival times at station A as [6, 7, 1, 2] meaning at [6am, 7am, 1pm, 2pm]. how can I convert [6,7,1,2] into [6,7,13,14] or [6,7,(1+12),(2+12)]?
20:59:41 <mauke> :t groupBy
20:59:42 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
20:59:54 <mauke> > groupBy (<=) [6,7,1,2]
20:59:55 * hackagebot wai-app-file-cgi 0.5.6.1 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.6.1 (KazuYamamoto)
20:59:56 <lambdabot>   [[6,7],[1,2]]
21:00:11 <bobajett> cool!!!
21:00:31 <mauke> > zipWith (\x y -> x * 12 + y) [0 ..] (groupBy (<=) [6,7,1,2])
21:00:32 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
21:00:32 <lambdabot>    arising from a use...
21:00:49 <mauke> > zipWith (\x y -> map (x * 12 +) y) [0 ..] (groupBy (<=) [6,7,1,2])
21:00:50 <lambdabot>   [[6,7],[13,14]]
21:01:29 <mauke> > zipWith (\x y -> map (x * 12 +) y) [0 ..] (groupBy (<=) [6,7,1,2]) :: [[Expr]]
21:01:30 <lambdabot>   [[0 * 12 + 6,0 * 12 + 7],[1 * 12 + 1,1 * 12 + 2]]
21:01:38 <bobajett> thanks mauke!
21:02:01 <bobajett>  here I was trying to write something like fixTimes (t1:t2:ts) and trying to compare t1 and t2 and then not knowing how to call itself recursively
21:03:03 <Saizan> that's not going to work very well for e.g. a station with times like [6am,7pm]
21:03:32 <bobajett> eh - true
21:05:12 <bobajett> luckily all the input I have does have the two distinct monotonic sequences in there am times and pm times, so I can use the (<=)
21:07:16 <bobajett> curious though, is there a way to write this function just with function pattern matching? (Im only on the first few chapters of LearnYou so haven't gotten to zipWith yet - though I understand that is the better solution)
21:07:39 <Saizan> > groupBy (<=) [1,2,3,2]
21:07:40 <lambdabot>   [[1,2,3,2]]
21:13:00 <Saizan> > let foo (x:y:xs) | x <= y = let (a,b) = foo (y:xs) in (x:a,b) | otherwise = ([x],y:xs); foo xs = (xs,[]) in (foo [6,7,1,2],foo [1,2,3,2])
21:13:01 <lambdabot>   (([6,7],[1,2]),([1,2,3],[2]))
21:13:42 <Saizan> then you need to map (+12) on the second half of the tuple
21:13:50 <ion> > grŒøupBy (>) [5,4,1,2,3]
21:13:52 <lambdabot>   I'm afraid I can't do that, Dave.
21:14:19 <bobajett> thanks Saizan :-) let me try to grok that for a few
21:18:10 <mbetter> can anyone tell me what this means in the context of a ghc error message? (Data.Primitive.Array.Array a[a16g])
21:18:27 <mbetter> i'm trying to derive a safecopy instance for Vector
21:18:57 <luite_> if I have a TypecheckedModule, does this contain the inferred type of local definitions somehow?
21:31:19 <pqmodn> is the proper phrasing "apply 3 to +" or "apply + to 3" when speaking of function application?
21:31:36 <Philippa> the latter
21:31:45 <Philippa> it's /function/ application, you apply the function
21:32:14 <pqmodn> thanks, i thought so :]
21:32:25 <hpaste> yasar pasted ‚Äútranspose text file‚Äù at http://hpaste.org/65721
21:33:14 <yasar> Why would algorithm in the above paste take a lot of CPU time? It's for transposing a text file.
21:34:30 <dmwit> yasar: You're recursing on the same list you're given as input.
21:34:48 <dmwit> No, I misread.
21:35:06 <dmwit> But tpose never reaches the [] case.
21:35:16 <pqmodn> well, is tpose (map ...) xs not getting smaller?
21:35:18 <dmwit> Do you see why?
21:35:24 <dmwit> Hint: length (map f xs) = length xs
21:36:12 <dmwit> There's a "transpose" in the standard library that you should use anyway.
21:36:20 <dmwit> myTranspose = unlines . transpose . lines
21:36:30 <dmwit> s/myTranspose/myFunction/
21:37:05 <yasar> Ok. I will use standard transpose. But I still don't understand why mine doesn't work.
21:37:50 <pqmodn> yasar: you have something like tpose xs = tpose (map f xs)
21:38:11 <ion> > 3 (+)
21:38:12 <lambdabot>   3
21:38:39 <yasar> yes but f = (drop 1) in this case, drops one letter for each string in the list.
21:38:41 <pqmodn> yasar: like dmwit said, map preserves length, so the list never gets smaller and never reaches the base case
21:39:18 <Saizan> yasar: you're only making the inner lists smaller, but not the outer one
21:39:41 <Saizan> > map (drop 1) ["foo","bar","baz"]
21:39:42 <lambdabot>   ["oo","ar","az"]
21:39:47 <Saizan> > map (drop 3) ["foo","bar","baz"]
21:39:48 <lambdabot>   ["","",""]
21:40:14 <yasar> Now I see it. **facepalm**
21:41:57 <ion> > map (drop 3) ["**facepalm**"]
21:41:58 <lambdabot>   ["acepalm**"]
21:43:00 <hpaste> yasar annotated ‚Äútranspose text file‚Äù with ‚Äútranspose text file (annotation)‚Äù at http://hpaste.org/65721#a65722
21:43:12 <yasar> How about now?
21:43:16 <yasar> Is it still bad?
21:43:22 <pqmodn> run it and see :)
21:56:22 <zzing> Good evening my friends. I have what could correctly be described is a very basic level of knowledge in Haskell. I am about to start a (year 1 CS) course in another month that deals in Miranda. In general, is it likely that the stuff that hopefully I will learn generally compatible with Haskell? I would love to expand my Haskell knowledge to compliment my expanding C++ knowledge. Just that the university loves Miranda.
21:59:50 <tgeeky> zzing: yes, some ideas you will learn there will be applicable to Haskell
22:01:08 <Saizan> most of it i think
22:03:10 <zzing> Based on the final exam for the last time the course was done, it has stuff using foldr, map, and (.), list comprehension, recursion, some grammar and construct a tree graph, even some proving with 'structural induction'. Quite a lot of this I couldn't answer now, so I suspect this course will be very useful.
22:03:38 <zzing> If anyone has any curiousity over what one of the exams looks like‚Ä¶ http://cs.uwindsor.ca/~richard/60_100/ans_previous_final_exams/ans_all_qus_2010.pdf
22:03:44 <zzing> I just wish it was actually using haskell :P
22:05:34 <zzing> Maybe I can take the time to port my raycasting forth (it has a ray caster and forth implemented in same program) written in C++ to haskell over the summer.
22:26:47 <flebron> So what's the idiomatic way of generalizing this: do x_1 <- foo; x_2 <- foo; ‚Ä¶ x_n <- foo; return $ sum [x_1 ‚Ä¶ x_n]?
22:28:24 <mzero> sum `fmap` sequenceM (repeat n foo)
22:30:11 <dolio> sequenceM is just sequence.
22:30:12 <Saizan> got a few names wrong :)
22:30:18 <mzero> > sum `fmap` sequenceM (replicate 10 (randomRIO (15,25))
22:30:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:30:24 <dolio> And repeat is replicate.
22:30:31 <mzero> yup
22:30:37 <mzero> late and I'm getting' sloppy
22:30:42 <flebron> Where is sequenceM?
22:30:45 <mzero> > sum `fmap` sequence (replicate 10 (randomRIO (15,25))
22:30:46 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:30:54 <mzero> > sum `fmap` sequence (replicate 10 (randomRIO (15,25)))
22:30:55 <lambdabot>   <IO Integer>
22:30:58 <mzero> joy!
22:31:05 <Saizan> ?type replicateM
22:31:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
22:31:15 <mzero> looky there!
22:31:25 <Saizan> flebron: fmap sum (replicateM n foo)
22:31:35 <mzero> > sum `fmap` replicateM 10 (randomRIO (15,25))
22:31:36 <lambdabot>   <IO Integer>
22:31:43 <Saizan> flebron: sequenceM doesn't exist, mzero meant just sequence
22:33:06 <mzero> ah, my #haskell hommies got my back!
22:34:06 <mzero> flebron: replicateM is good here, but sequence is worth learning
22:36:00 <hpaste> flebron pasted ‚ÄúIs this idiomatic?‚Äù at http://hpaste.org/65723
22:37:43 <flebron> So something like sums n = sum `fmap` (replicateM n dice)
22:37:44 <mzero> I find line 6 hard to parse -- too clever....
22:38:00 <mikeplus64> flebron: looks good to me, maybe include type signatures, use replicateM, and <$> for an infix fmap (entirely superficial though)
22:38:18 <flebron> ((fromIntegral . length) correct) / ((fromIntegral . length) all)
22:38:32 <Saizan> ((/) `on` (fromIntegral . length)) correct all
22:38:35 <mikeplus64> you could use genericLength in Data.List btw
22:38:50 <mzero> or define your own in the where clause
22:39:55 <hpaste> snhmib pasted ‚Äútying types‚Äù at http://hpaste.org/65724
22:40:55 <snhmib_> hey i want to make a graph like that
22:41:09 <snhmib_> but is it necessary to introduce another data type?
22:43:44 <Saizan> S2 is recursive, so yes
22:44:25 <snhmib_> but there's not a trick/technique to make a data Stmt a == data Stmt Stmt Stmt Stmt... :(
22:44:33 <snhmib_> ?
22:45:27 <mzero> what's wrong with  adding      | Blcok [Stmt]     as  a constructor?
22:45:31 <lifestream> I'm in step 23/24 of lessson5 in Try Haskell, pattern matching. The last example is let abc@(a,b,c) = (10,20,30) in (abc,a,b,c) which comes up as ((10,20,30),10,20,30). So abc@(a,b,c) == (abc,a,b,c) ? Tried to find info on @.
22:46:08 <mzero> @ just lets you bind a name to the whole term on the right
22:47:15 <mzero> > let  a@b = "something"  in  a ++ " is just " ++ b
22:47:17 <lambdabot>   "something is just something"
22:47:48 <snhmib_> mzero: i don't get it
22:48:11 <mzero> > let a@(b:_) = words "now is the time"  in   "the first word of " ++ show a ++ " is " ++ show b
22:48:12 <lambdabot>   "the first word of [\"now\",\"is\",\"the\",\"time\"] is \"now\""
22:48:26 <mzero> let me start again
22:48:30 <lifestream> That's a good one, a more "real" example to me.
22:48:31 <mzero> so, do you see how
22:48:44 <mzero> > let  (a,b,c) = (10,20,30) in a + b + c
22:48:45 <lambdabot>   60
22:48:50 <mzero> do you see how that works?
22:49:01 <mzero> and do you see how this works:
22:49:14 <mzero> > let x = (10,20,30) in show x
22:49:15 <lambdabot>   "(10,20,30)"
22:49:41 <lifestream> Hmhm
22:49:44 <mzero> all @ does is let you do both a variable bind and a pattern match at once
22:50:18 <mzero> > let x@(a,b,c) = (10,20,30) in  "the some of the parts in " ++ show x ++ " is " ++ show (a + b + c)
22:50:19 <lambdabot>   "the some of the parts in (10,20,30) is 60"
22:50:21 <lifestream> Very interesting, I must have missed where the lesson explained @.
22:50:22 <JoeyA> Is it possible to make --force-reinstalls default through a .cabal/config setting?
22:50:55 <JoeyA> (Recent versions of cabal now yell at you if "cabal install" will break packages)
22:52:03 <bobajett> ah so x is a variable that represents whatever was bound in the after @ part?
22:52:49 <snhmib_> bah :(
22:52:58 <Saizan> whatever matched it
22:53:08 <snhmib_> i'm not sure having a nice graph is worth having a whole extra type
22:53:17 <lifestream> Playing around with this in ghci :)
22:53:30 <snhmib_> but this tying the knot technique is pretty cool :)
22:53:36 <mzero> snhmib_: if you're worried about adding a type, you're in the wrong language
22:53:40 <snhmib_> are there more tricks/techniques like that?
22:54:16 <mzero> Haskellers type "at the drop of a hat" :: String
22:56:08 <snhmib_> mzero: well it's a pretty big one with lots of constructors & everything, to just copy the whole thing and only change the type of 1 little field is.. i dunno
22:56:36 <bobajett> > let foo@(x:xs) = "hello" in "x="++[x] ++ ", xs="++xs ++ ", foo="++foo
22:56:37 <lambdabot>   "x=h, xs=ello, foo=hello"
22:57:13 <Saizan> snhmib_: maybe you want to use "2-level types"
22:57:34 <snhmib_> Either?
22:58:29 <mzero> snhmib
22:59:03 <mzero> snhmib_: I don't get why Stmt is parameterised on a ---   Call a when used must unify a with the String in Func String
22:59:19 <Saizan> snhmib_: http://flippac.wordpress.com/2011/11/08/object-and-meta-typefully/ <- here it shows some variants for dealing with a problem like yours
23:00:22 <snhmib_> mzero: i had the idea then i could replace a (String) by Stmt.. somehow
23:00:25 <snhmib_> Saizan: thanks
23:00:35 <snhmib_> but it doesn't seem to be possible :(
23:01:42 <mzero> it isn't sensical - you are taking an AST of one shape - where functions have (global!) names and calls are by name
23:02:07 <mzero> into an AST where functions don't exist and calls have been replaced by traces (recursively)
23:02:21 <mzero> the problem you are facing is that they are different types
23:04:01 <mzero> if you find there are a large class of statements that would be the same in both ASTs  (say arithmetic expression, or print and read statements)
23:04:27 <mzero> then you can make a separate type: data PlainStmt = Print String | Read | ....
23:04:31 <lifestream> Thanks mzero, I understand the @ now, was confused how it acted :)
23:04:41 <mzero> and then in the two ASTs just have one constructor that pulls in PlainStmt
23:05:13 <mzero> lifestream: :-)
23:05:46 <mzero> lifestream: it is often used when you're pattern matching something complex to see if it hits some case, but then you just want to deal with the whole thing
23:06:48 <lifestream> Yeah, that makes no sense to me right now, hopefully it will after a few more Try Haskell lessons, hehe
23:08:23 <mzero> > let explain a = case a of { l@('-':'-':_) -> "long option " ++ l; s@('-':_) -> "short option " ++ s; _ -> "arg " ++ a } in map explain $ words "-q --with-vavoom snow"
23:08:25 <lambdabot>   ["short option -q","long option --with-vavoom","arg snow"]
23:09:36 <mzero> see, I'm using the pattern match there to pick a case, not to actually pull apart the string --- hence the @s
23:11:58 <yasar> what does "The type signature for `asInt_fold' lacks an accompanying binding" mean?
23:12:31 <mzero> you never wrote    asInt_fold =    anywhere!
23:12:50 <mzero> you only wrote the type signature
23:12:52 <c_wraith> yasar: usually caused by a typo
23:13:02 <c_wraith> yasar: capitalization mistakes are the most common
23:13:11 <yasar> c_wraith: yes, indeed, it was a typo.
23:14:56 <lifestream> mzero: I'm a total newb who can barely remember how to do Hello World, so it takes me a century to understand your examples.. but precisely because they are really difficult for me, it helps me understand... thanks again !
23:15:15 <mzero> happy to help
23:26:23 <mzero> huh - I thought fail for Either String a   used to be Left
23:26:35 <mzero> but the instance in Control.Monad.Error doesn't seem to do that any more
23:28:44 <c_wraith> mzero: that changed around ghc 6.12, maybe?
23:29:01 <c_wraith> mzero: the main point was that it allowed Either a to be a monad, rather than Either String.
23:29:22 <Axman6> @hoogle Handle -> [ByteString] -> IO ()
23:29:23 <lambdabot> Data.ByteString hPut :: Handle -> ByteString -> IO ()
23:29:23 <lambdabot> Data.ByteString.Char8 hPut :: Handle -> ByteString -> IO ()
23:29:23 <lambdabot> Data.ByteString.Lazy hPut :: Handle -> ByteString -> IO ()
23:29:33 <mzero> that timing sounds right - I made my cheat sheet prior to 7.0
23:29:38 <Philippa> mmm, which also shows just how faily fail is
23:29:58 <mzero> but, none the less... I'm a little sad at the loss ---
