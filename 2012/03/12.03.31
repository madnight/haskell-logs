00:23:48 <xarch> what is the best implementation of heaps in hackage?
00:25:45 <roconnor> xarch: psqueue
01:09:22 * hackagebot morfette 0.3.4 - A tool for supervised learning of morphology  http://hackage.haskell.org/package/morfette-0.3.4 (GrzegorzChrupala)
01:18:28 <augur> @tell edwardk turns out the right pattern for what i need to enumerate those trees is Stirling2(n,k), which has a very nice, recursively structured generator
01:18:29 <lambdabot> Consider it noted.
01:20:41 <killy9999> how can I convert UTCTime to Int (like number of seconds since the Unix-epoch)?
01:21:39 <shachaf> @hoogle UTCTime
01:21:39 <lambdabot> Data.Time.Clock UTCTime :: Day -> DiffTime -> UTCTime
01:21:39 <lambdabot> Data.Time.Clock data UTCTime
01:21:40 <lambdabot> Data.Time.Clock.POSIX utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
01:22:27 <shachaf> Looks like that function would do it?
01:22:43 <killy9999> hm...
01:23:11 <killy9999> doesn't look like I can extract an Int from POSIXTime
01:23:14 <killy9999> "POSIX time, if you need to deal with timestamps and the like. Most people won't need this module. "
01:26:55 <xarch> roconnor: ok, thanks
01:32:37 <augur> @tell edwardk http://oeis.org/A008277 , http://hpaste.org/66276
01:32:38 <lambdabot> Consider it noted.
01:32:46 <augur> oh, edwardk, you're here!
01:32:48 <augur> hah :D
01:32:57 <edwardk> ?
01:32:58 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:33:01 <augur> x3
01:33:46 <cods> Haskell newbie here: why :type (-) show the type of the binary operator and not the type of the unary operator (negate)? Is the unary minus operator a special case in the Haskell parser? (transformed into negate at parsing time maybe.)
01:34:41 <timthelion> Hello, in ImplicitCAD, when I import Graphics.Implicit I can access the Rect3R ‚Ñù ‚Ñù3 ‚Ñù3 type, and do r a b c = Rect3R 0 (0,0,0) (0,0,0) but when I do r :: ‚Ñù ‚Ñù3 ‚Ñù3 ghc tells me ‚Ñù3 is not in scope... How is this possible???
01:34:44 <edwardk> cods: yes, unary minus is a bit of an odd case. for any other operator (-foo) would expand to \x -> x - foo which is generally not what users would expect
01:35:25 <edwardk> cods: (-) has to be one or the other, so it chooses to be consistent with binary -. unary minus only has the right section hack
01:35:42 <killy9999> ok, so no idea how to convert UTCTime to Int?
01:36:00 <edwardk> we have negate and subtract available though
01:36:03 <cods> edwardk: so the only way to denote the unary minus operator is to actually use negate instead?
01:36:12 <edwardk> cods: yes
01:36:17 <augur> or 0-!
01:36:24 <edwardk> or write it out \x -> - x
01:36:58 <edwardk> augur: that might have differing semantics depending on the borked Num instances out there
01:37:04 <augur> maybe
01:37:14 <augur> anyway, edwardk, those trees that i needed to generate
01:37:39 <augur> that sequence is essentially it
01:37:44 <edwardk> augur: nice
01:37:58 <augur> give or take some extra structure
01:38:13 <edwardk> or at least its a generating function for the number of nodes they have
01:38:37 <edwardk> so it probably gives you insight into how to put the actual thing together
01:38:48 <augur> the importnt thing is that the decision for what to insert into the tree is somewhat simpler to see now
01:38:58 <edwardk> *nods*
01:39:17 <augur> it gets a bit more complicated tho since its a tree, and you dont know how many slots of a given time you're going to end up with
01:39:36 <augur> im not actually sure i need to do it this way tho
01:39:43 <augur> but its an idea.
01:40:40 <edwardk> yeah like i said, its a generating function, which tells you something about the solution, just doesn't give you the solution directly
01:42:10 * Cale has been conditioned to wince every time someone uses the term "generating function" in place of "generating series" :)
01:42:34 <edwardk> cale: i know, but alas, i'm yet to be convinced to move from standard terminology ;)
01:42:49 <wtf911> wtf is haskell?
01:42:51 <ciaranm> generatingseriesology doesn't have the same ring to it
01:43:11 <edwardk> yeah, and it doesn't have my generatingfunctorology pun
01:43:38 <Skola> I'm playing with tokenization, and I want to recombine certain sequences of tokens to form properly tokenized contractions, ie. ["Couldn", "'", "t"] -> ["Could", "n't"]. What kind of function would I use for that?
01:43:39 <wtf911> shut up edward cullen bitchhhh
01:43:49 <wtf911> you guys are speaking like science shit lmao
01:43:53 <edwardk> can someone +b?
01:44:07 <wtf911> do it you won't
01:44:19 <shachaf> @where ops
01:44:19 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:44:33 <Skola> even better
01:44:38 <augur> whats klined mean
01:44:56 <ciaranm> it means kloeri went around to his house and broke his fingers
01:45:13 <shachaf> Hmm, @google is broken?
01:45:17 <shachaf> @google help
01:45:23 <lambdabot> http://www.youtube.com/watch?v=TU7JjJJZi1Q
01:45:23 <lambdabot> Title: The Beatles - Help - YouTube
01:45:41 <edwardk> augur: means the server ops actually blocked him
01:45:42 <augur> oh wow, server banned
01:45:43 <augur> awesome
01:45:49 <augur> thats nuts
01:45:54 <augur> i wonder what he's been doing. lol
01:45:59 <Cale> That generatingfunctionology is a really unfortunate book though :P
01:47:33 <ciaranm> my copy has something growing on the cover that won't die. it's rather strange.
01:47:53 <edwardk> meh. its nice in that it gets a lot of people to think about series who would otherwise never spot the connections
01:48:16 <Cale> It's popular because it's basically the only free book, but it completely misses the point in a lot of ways, and has really bad complicated proofs of simple results.
01:48:33 <edwardk> ciaranm: you should try to kill it and see if its regeneratingfunctionology.
01:48:57 <ciaranm> wasn't Wilf one of the "concrete mathematics" crowd?
01:49:07 <Cale> Its explanation of exponential generating series is terrible and confusing
01:49:07 <ciaranm> the kind who believed that you should do combinatorics without ever mentioning groups
01:49:24 <edwardk> oh whoa, he passed away. missed that
01:50:00 <augur> who did?
01:50:05 <edwardk> wilf
01:50:27 <augur> who's wilf
01:50:36 <edwardk> guy who wrote generatingfunctionology
01:50:58 <edwardk> http://www.math.upenn.edu/~wilf/DownldGF.html
01:50:58 <augur> oh wow i thought you were joking with that name
01:51:33 <edwardk> if you haven't learned generating functions its a worthwhile read as a starting point, despite cale's axe grinding ;)
01:52:14 <Cale> I should really write a better book, but I wouldn't have to if I could just get Jackson to release his course notes as a book. :P
01:52:34 <ciaranm> you should write a book on category theory etc using haskell
01:52:43 <augur> huh. this is an interesting looking book
01:52:48 <augur> also
01:52:49 <augur> http://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Andromeda_galaxy_Ssc2005-20a1.jpg/1024px-Andromeda_galaxy_Ssc2005-20a1.jpg
01:53:09 <edwardk> its also particularly relevant to your current obsession =P
01:54:00 <augur> edwardk: maybe!
01:54:14 <augur> i mean
01:54:26 <augur> my current obsession is really about porting lagrangian mechanics over into syntax :p
01:54:35 <augur> i had an epiphany today tho
01:54:36 <edwardk> good luck
01:55:24 <edwardk> this why you keep looking at derivatives of path algebras, etc?
01:55:35 <Cale> Okay, look at page 21-22 where he has a calculation of the generating series for the Bell numbers, which count the number of partitions of a set with n elements into nonempty subsets.
01:55:52 <augur> if have functions of type X -> Y, and you know that Y is a semiring, but you dont know anything else about it or about X, then you know that all functions of that type are sums of functions that send one element of X to something in Y, and everything else in X to 0
01:55:52 * edwardk set off Cale. I'd forgotten how strongly he felt ;)
01:56:26 <Cale> If you were doing this sanely, you'd at least mention the composition lemma for exponential generating series, and how they count labelled structures.
01:56:39 <augur> and you also know that the only generic differential operators you can define are ones that send f to a polynomial over f
01:56:51 <augur> since you cant inspect it, nor the argument to the derivative
01:56:53 <edwardk> augur: sure, its a free semiring module. though be careful it may not be a finite sum of X is infinite
01:57:05 <edwardk> in which case its an infinite free module
01:57:39 <edwardk> er 'if X is infinite'
01:59:01 <Cale> You'd then notice that you're counting sets of nonempty sets, and so you have a bijection from set partitions to U (*) (U \ {empty}), where U is the set of canonical finite sets {{},{1},{1,2},...}, and (*) is (star) composition.
01:59:08 <augur> but that means it's possible to define derivatives over functions out of arbitrary sets
01:59:09 <Cale> the e.g.s. for U is e^x
01:59:14 <augur> which is good!
01:59:20 <Cale> and the e.g.s. for U \ {empty} is then e^x - 1
01:59:34 <Cale> and so the e.g.s for set partitions is e^(e^x - 1)
01:59:37 <augur> just define it using the differential operator laws, plus polynomials at the bottom
02:00:07 <augur> and maybe some extra structure if you need it, but
02:00:26 <augur> at the least, you can always get a differential operator
02:00:35 <edwardk> augur: yes, you can take derivatives there just fine
02:00:38 <edwardk> i even have code for that
02:00:49 <augur> hah
02:00:49 <augur> :)
02:00:59 <augur> now the question is which of those is right for my purposes!
02:01:08 <levi_> hi all, i m new to irc and haskell. greet to meet you.
02:01:25 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-Module-AutomaticDifferentiation.html is old but it deals with doing AD for an arbitrary module over a semiring
02:01:29 <Cale> levi_: hello!
02:01:49 <edwardk> i removed it in later versions because i was planning on moving it and other stuff into more specific modules
02:01:52 <edwardk> but i never got around to it
02:02:42 <edwardk> augur: the usual AD can be seen as just choosing the module to be the ring itself
02:02:59 <levi_> Cale: hello, is there some useful tips for irc ?
02:03:04 <Skola> Sorry for spam, but :D I'm playing with tokenization, and I want to recombine certain sequences of tokens to form properly tokenized contractions, ie. ["Couldn", "'", "t"] -> ["Could", "n't"]. What kind of function would I use for that?
02:03:44 <augur> edwardk: hmm hmm
02:04:10 <ciaranm> Skola: are you talking about knowing the zillions of weird rules for english?
02:04:36 <Skola> no the rules are no problem
02:04:51 <Skola> just what kind of function to use for those tri-gram contractions
02:05:07 <Cale> levi_: I dunno :)  Feel free to ask any questions you might have about Haskell here
02:05:29 <Cale> levi_: We have lambdabot, which will do Haskell evaluation and a handful of other things
02:05:59 <Skola> a big zipWith could work, but it's kinda ugly
02:06:13 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
02:06:15 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:06:52 <levi_> thank you, Skola and Cale. i'll do so as soon as necessary.
02:07:27 <levi_> I have just install Colloquy and come for a try. see you then.
02:07:35 <ciaranm> Skola: pattern matching with guards? so you'd look for x : "'" : "t" : xs where x is something?
02:08:30 <Skola> possibly, but I have to drop the "'" as a single token
02:08:39 <Skola> but _not_ in places where it's not part of a contraction
02:09:05 <ciaranm> hence the pattern matching and the guards
02:09:41 <Skola> ok I'll give it a go
02:10:38 <Skola> I haven't yet used pattern matching with actual strings
02:11:31 <edwardk> contract (word : "'" : "t" : xs) | map toLower word `elem` ["could","would","should",‚Ä¶] = ‚Ä¶; | ‚Ä¶ = ...
02:12:02 <edwardk> > words "couldn't you use this"
02:12:03 <lambdabot>   ["couldn't","you","use","this"]
02:12:18 <edwardk> guess not, you'd need the break up on punctuation as well
02:12:25 <Skola> yeah
02:12:40 <Skola> well my initial tokenization step does this
02:12:41 <edwardk> but once you have that, some combinator like contract above would work
02:12:42 <ciaranm> > words "i wouldn't've chosen english"
02:12:43 <lambdabot>   ["i","wouldn't've","chosen","english"]
02:13:01 <Skola> ciaranm English is a piece of cake compared to other languages
02:13:13 <ciaranm> radioactive aids cake?
02:13:40 <edwardk> ciaranm what e'er do you mean?
02:13:51 <Skola> the radioactivity depends on your heuristics
02:14:04 <Skola> and indeed, on whether or not your corpus includes Shakespeare
02:17:56 <k0ral> what does "array-0.3.0.3:Data.Array can't be safely imported! The module itself isn't safe" mean ?
02:24:33 <killy9999> I'm doing an application that does some action based on its first commandline argument, which can be either a string representation of Int or a String. How to parse this in an ellegant manner?
02:25:09 <edwardk> killy9999: what version of ghc are you on?
02:25:15 <killy9999> 7.0.4
02:25:23 <killy9999> latest haskell platform in general
02:25:39 <edwardk> killy9999: re parsing the argument, you can always check to see if its made up of digits
02:25:48 <edwardk> :t all isDigit
02:25:49 <lambdabot> [Char] -> Bool
02:26:00 <killy9999> yes
02:26:09 <killy9999> but I'm wondering if there is an elegant way
02:26:18 <edwardk> seems pretty elegant to me ;)
02:26:33 <killy9999> to parse this without parsing ints separately
02:26:45 <killy9999> use a guard for this?
02:27:08 <killy9999> | all isDigit param
02:27:12 <killy9999> | otherwise = ...
02:27:13 <killy9999> ?
02:28:22 <killy9999> I'm learning how to do I/O in Haskell, so it's a bit confusing for me how to combine pure and impure code and how to handle stuff inside a do block
02:30:48 <ChristianS> killy9999: using a guard sounds fine to me.
02:31:00 <killy9999> mhm
02:31:18 <ChristianS> killy9999: as a general hint, try to separate pure from impure code, i.e. to keep as many functions pure as reasonably possible.
02:31:18 <mysticc> while installing installing reactive-banana-wx , I dont know why it starts installing deepseq although I have the same version already installed .. and then it fails saying "array-0.3.0.3:Data.Array can't be safely imported! The module itself isn't safe."
02:33:19 <killy9999> ChristianS: yes, I'm trying to do that, but some stuff isn't obvious for a newbie
02:33:52 <killy9999> e.g. I wanted to do getCurrentTime, but it's impure so I can only do it in a do block
02:34:00 <killy9999> and this forces me to rethink my program
02:34:25 <ChristianS> @quote mauke time
02:34:25 <lambdabot> mauke says: <mauke> sorry, the current time is not a constant <lukish> It's a pity
02:34:26 <killy9999> a minor thing, but something I didn't anticipate
02:34:44 <ChristianS> killy9999: yes, since the current time is not a constant, getting it cannot be a pure operation
02:35:46 <killy9999> and that's very reasonable
02:36:31 <killy9999> but being used to languages like Java and Matlab it's not a thing that's immedietly obvious :)
02:53:35 <killy9999> OK, I'm stuck
02:54:12 <killy9999> my program should accept parameters like "date:12-05-2012" or "priority:H"
02:54:31 <killy9999> and I have no idea how to create a function that parses it
02:54:43 <killy9999> I mean I know how to cut command line params
02:54:48 <killy9999> and compare them etc
02:55:13 <killy9999> but I don't know ho to creat a function that would return different types of data depending on the prefix before the ':'
02:55:21 <killy9999> because user can give params in any order
02:55:31 <ciaranm> you want a data type
02:55:53 <killy9999> hm.. let me think about it for a moment
02:56:05 <ciaranm> data Param = Date String | Priority Int
02:57:18 <killy9999> that partially helps
02:57:18 <edwardk> if you can control the nput format it may make sense to use GetOpt or CmdArgs or one of the other alternatives to just parse it for you
02:57:59 <edwardk> e.g. if foo --priority 12   or foo --date 12-05-2012 would be acceptable then you can use out of the box tools for this
02:58:35 <hpaste> stefanooldeman pasted ‚Äúfrom list to tuple with 2 lists‚Äù at http://hpaste.org/66279
02:58:39 <killy9999> I'll take a look at these packages, perhaps I could use them
02:59:38 <stefanooldeman> I can't seem to my params right.. it works when i split the function in 2 functions.. can someone help me an take a look at it
03:00:21 <killy9999> stefanooldeman: why the parentheses?
03:00:53 <stefanooldeman> yeah I see the warning..
03:01:20 <killy9999> f (x:xs) = f1 ([], x:xs)
03:01:35 <killy9999> no, wait
03:02:10 <killy9999> what is n?
03:02:21 <killy9999> in the first guard
03:03:00 <stefanooldeman> i use this f in a where clause. n is an Int
03:03:19 <quintessence> what exactly do you want f to do?
03:03:22 <stefanooldeman> clause sorry for using that word..
03:03:45 <killy9999> perhaps try passing n as a parameter?
03:04:15 <stefanooldeman> I want it to split a list into two lists. but the two lists needs to be a tuple
03:04:22 <stefanooldeman> *in a tuple
03:04:59 <stefanooldeman> so first i pas in a list xxs into f
03:06:02 <quintessence> > splitAt 2 "abcdef"
03:06:03 <lambdabot>   ("ab","cdef")
03:06:16 <stefanooldeman> oh noes!
03:07:45 <stefanooldeman> that is nice. thanks. if someone sees the change to change f and f1 into one function i would really like to get the point
03:09:11 <killy9999> edwardk: which is better: CmdArgs or GetOpt? GetOpt looks more accesible to me
03:09:28 <edwardk> GetOpt is much more accessible. CmdArgs is much less repetitive to code
03:10:53 <killy9999> I;ll stick to GetOpt I guess, I can't understand CmdArgs documentation...
03:11:40 <edwardk> killy9999: its deep magic
03:12:42 <killy9999> for a newbie certainly yes
03:14:41 <mkrs> heyy
03:14:44 <mkrs> anyone here
03:14:51 <quintessence> stefanooldeman: if you pass n as a parameter, you can write splitAt n (x:xs) in terms of splitAt (n - 1) xs without a helper function (and without reversing the first list)
03:16:18 <stefanooldeman> Hey quintessence! thanks allot :) i got it working now.
03:16:47 <stefanooldeman> still sad i was completely on the wrong track wrinting that func. but learned me allot
03:17:03 <stefanooldeman> %s/wrinting/writing
03:22:21 <Skola> edwardk, ciaranm: thanks for your suggestions on using pattern matching and guards for rewriting the contractions, it works really well!
03:22:46 <edwardk> np
03:24:04 <Skola> are there useful code analysis tools other than pointfree, hlint and scan?
03:31:12 <edwardk> @undo do x <- foo; y <- bar; return $ x y
03:31:12 <lambdabot> foo >>= \ x -> bar >>= \ y -> return $ x y
03:31:23 <edwardk> @do  foo >>= \ x -> bar >>= \ y -> return $ x y
03:31:23 <lambdabot> do { x <- foo; y <- bar; return $ x y}
03:31:37 <ion> scan?
03:31:44 <edwardk> @djinn a -> (a -> r) -> r
03:31:44 <lambdabot> f a b = b a
03:32:01 <ion> ok http://hackage.haskell.org/package/scan
03:32:08 <edwardk> @djinn (a -> (b -> r) -> r) -> ((a -> r) -> r) -> (b -> r) -> r
03:32:08 <lambdabot> f a b c = b (\ d -> a d c)
03:32:22 <Skola> can lambdabot be downloaded and used on the command-line?
03:32:22 <ion> @@ @djinn @type (<*>) `asAppliedTo` (undefined :: a -> b)
03:32:23 <lambdabot>  f a b c = a c (b c)
03:32:36 <edwardk> skola: there is a guide somewhere, but its horribly outdated
03:32:49 <edwardk> ion: sexy
03:33:02 <Skola> I'll go look it up, thx
03:33:42 <quintessence> djinn :: Analysis -> Code
03:47:22 <cheater_> @type (<*>) `asAppliedTo` (undefined :: a -> b)
03:47:23 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
03:47:38 <cheater_> @djinn forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
03:47:38 <lambdabot> f a b c = a c (b c)
03:47:45 <cheater_> interesting
03:52:20 <k0ral> hi, I'm trying to "cabal sdist" my project and I'm getting "cabal: dist/src/sdist.-672/myproject-version: does not exist"
03:52:30 <k0ral> what's the problem ?
03:52:43 <k0ral> btw it compiles and install fine
03:53:10 <dobblego> do you have a link to your source repository?
03:53:58 <k0ral> a symlink you mean ?
03:56:30 <k0ral> in this case the answer is no
04:05:17 <ClaudiusMaximus> k0ral: (via dcoutts in my irc logs) your cabal-install is built with the wrong version of the Cabal lib. You or someone has adjusted the .cabal file for cabal-install-0.10.x so that it'd build against Cabal-1.12 or later.
04:05:46 <timthelion> what function weaves a list like weave [1,2,3] [4,5,6]==[1,4,2,5,3,6]?
04:06:35 <ClaudiusMaximus> timthelion: some combination of concat and transpose and putting things in a list?
04:06:41 <adnauseam> zipWith
04:06:58 <adnauseam> > zipWith [1,2,3] [4,5,6]
04:06:59 <lambdabot>   Couldn't match expected type `a -> b -> c'
04:06:59 <lambdabot>         against inferred type `[...
04:07:06 <adnauseam> arr, fail, give me a second
04:07:47 <timthelion> >zipWith (\x y -> x:y:[]) [1,2,3][4,5,6]
04:07:54 <timthelion> > zipWith (\x y -> x:y:[]) [1,2,3][4,5,6]
04:07:55 <lambdabot>   [[1,4],[2,5],[3,6]]
04:08:11 <timthelion> > concat $ zipWith (\x y -> x:y:[]) [1,2,3][4,5,6]
04:08:12 <lambdabot>   [1,4,2,5,3,6]
04:08:33 <ClaudiusMaximus> > concat $ transpose [[1,2,3],[4,5,6]]
04:08:34 <lambdabot>   [1,4,2,5,3,6]
04:08:34 <timthelion> I would have thought there would be a standard function for that.
04:10:24 <ClaudiusMaximus> @check (\xs ys -> concat (transpose [xs,ys]) == concat (zipWith (\x y -> [x,y]) xs ys))
04:10:25 <lambdabot>   "Falsifiable, after 0 tests:\n[()]\n[]\n"
04:11:16 <edwardk> hrmm. i'm somewhat confused. if i have a mallocForeignPtr allocated foreignPtr does it support me adding an additional finalizer to it or not?
04:11:41 <edwardk> e.g. i have a mallocForeignPtr allocated region that contains a pointer to extra memory that i also want to have collected
04:11:49 <k0ral> ClaudiusMaximus: not sure this is related, but the closest thing I can see in my .cabal is "Cabal-version:       >=1.8"
04:12:34 <edwardk> the comments in GHC-ForeignPtr seem to indicate that it doesn't support finalizers, but the code in there seems to have a place to put them and to do something with them (haven't parsed what yet)
04:12:50 <bitonic> edwardk: mallocForeignPtr has a finalizer that frees the memory
04:12:55 <bitonic> afaiu
04:12:58 <edwardk> bitonic: that'll free the pointer itself
04:13:13 <edwardk> i have another pointer being stuffed in that memory that i also want to have its memory freed
04:13:17 <edwardk> er
04:13:24 <bitonic> edwardk: ok, I don't think you can using mallocForeignPtr.
04:13:31 <bitonic> can't you initialize with newForeignPtr?
04:13:37 <bitonic> oh wait
04:13:38 <edwardk> i mean s/ that'll free the pointer itself/it'll free the target of the pointer/
04:13:42 <bitonic> you can simply add a finaliser, no?
04:13:50 <bitonic> addForeignPtrFinalizer
04:13:58 <bitonic> which will be run before the finaliser the frees the memory
04:13:58 <edwardk> i'm just asking if I can use addForeignPtrFinalizer safely
04:13:59 <edwardk> yeah
04:14:12 <edwardk> i ask because
04:14:14 <edwardk> "
04:14:14 <edwardk> -- Attempts to add a finalizer to a ForeignPtr created this way, or to
04:14:14 <edwardk> -- finalize such a pointer, will throw an exception."
04:14:16 <bitonic> I don't see why it wouldn't be safe
04:14:31 <bitonic> edwardk: where's that comment?
04:14:36 <edwardk> and there is a bunch of nomixing comments
04:14:41 <edwardk> under mallocForeignPtrBytes
04:14:59 <edwardk> it looks like mallocForeignPtr may have dropped that comment
04:15:14 <edwardk> so i'm thinking this may just be a documentation error left over from when it wasnt supported
04:15:22 <edwardk> but it was sufficiently ambiguous that i thought i should ask
04:15:24 <bitonic> uhm. did you try?
04:15:28 <edwardk> no
04:15:40 <edwardk> i'm like 8 layers deep in a problem stack and haven't got a usable example right now
04:15:55 <bitonic> I don't think I can give you any certainty, sorry :P
04:16:18 <bitonic> it seems weird that it wouldnt be more documented
04:16:30 <k0ral> ClaudiusMaximus: using version 1.14.0 of the Cabal library
04:16:46 <edwardk> MallocPtr      (MutableByteArray# RealWorld) !(IORef (Finalizers, [IO ()])) makes me think its there
04:16:47 <k0ral> ClaudiusMaximus: isn't this fine ?
04:16:49 <ClaudiusMaximus> k0ral: it's not your .cabal, it's you cabal install binary
04:17:25 <k0ral> ClaudiusMaximus: cabal-install version 0.10.4
04:18:25 <ClaudiusMaximus> k0ral: right, you need a new one because yours is broken in the way i described  (ghc-7.4.1 requires cabal-install from darcs)
04:19:23 <k0ral> ClaudiusMaximus: ok, thank you
04:19:50 <bitonic> edwardk: maybe the people at #ghc will know :P
04:20:06 <edwardk> going by the code it looks like it works
04:20:09 <ClaudiusMaximus> k0ral: if you got your cabal-install from a distribution package, file a bug report
04:20:14 <edwardk> running with that
04:22:12 <k0ral> ClaudiusMaximus: I did, but the distribution package isn't supposed to come from darcs version so I can hardly blame them
04:33:34 <cheater_> a bug which does and does not exist until you actually run the program
04:33:43 <cheater_> i like that
04:54:39 * hackagebot Yampa 0.9.3 - Library for programming hybrid systems.  http://hackage.haskell.org/package/Yampa-0.9.3 (GeorgeGiorgidze)
05:01:52 <nart> ciao :)
05:02:04 <nart> bitonic: are you here ?
05:04:32 <bitonic> nart: yes
05:07:10 <statusfailed> How do I get data out of Accelerate?
05:07:34 <statusfailed> With the dotp example here https://github.com/mchakravarty/accelerate/wiki/Quick-Tour#wiki-simpleexample, how do I get the answer?
05:09:53 <shepheb> my gitit wiki can't seem to connect to git at all anymore. it can't git init a new repo, or read an existing one.
05:10:15 <shepheb> I reinstalled filestore and gitit from Hackage, wondering if a git version change broke it, but it's still not working.
05:10:20 <ClaudiusMaximus> statusfailed: http://www.haskell.org/hoogle/?hoogle=Acc+a+-%3E+a+%2Baccelerate
05:11:46 <statusfailed> ClaudiusMaximus: ah I see.. I gave hoogle two type arguments to Acc :)
05:11:49 <statusfailed> Thanks!
05:12:18 <ClaudiusMaximus> statusfailed: there's also a CUDA implementation https://github.com/mchakravarty/accelerate/blob/master/Data/Array/Accelerate/CUDA.hs#L49
05:13:03 <statusfailed> ClaudiusMaximus: I did that- CUDA.run- it's actually hanging, hehe
05:13:09 <statusfailed> i'll try the reference one first
05:15:45 <statusfailed> ClaudiusMaximus: the CUDA documentation on hackage seems broken, too
05:18:21 <ClaudiusMaximus> statusfailed: i doubt hackage has the cuda sdk installed, it's a shame that documentation building requires binary building (is that fixable?)
05:21:55 <ivanm> ClaudiusMaximus: I doubt it; if some if it is generated from the FFI stuff, then you kinda need to build it for it to be there...
05:22:13 <statusfailed> oh, the documentation is generated from the CUDA native code?
05:22:22 <Rc43> Hi, guys.
05:22:46 <husky__> hey bitches
05:22:47 <statusfailed> Hi :)
05:22:52 <statusfailed> >_>
05:23:04 <husky__> id like to fuck ya
05:23:28 <husky__> ye wanna blow my cock
05:23:46 <statusfailed> Mod! a mod! my kingdom for a mod!
05:23:59 <Rc43> I has a module which just exports other (sub)modules (like `module X.Y.Prelude ( .. module X.Y.A, module X.Y.B ..  ) ....... import X.Y.A .... import X.Y.B`).
05:24:03 <adnauseam> is the state monad important for most tasks ?
05:24:16 <husky__> no its not
05:24:21 <Rc43> And when I import this X.Y.Prelude, I can use everything inside X.Y.A.
05:24:39 <husky__> im gonna kill ye all
05:24:47 <Rc43> But when I try to use it with HInt (Language.Haskell.Interpreter), it can't see X.Y.A
05:24:59 <quintessence> @where ops
05:24:59 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
05:25:51 <Rc43> So, e.g. inside Interpreter monad I call `setImports [ ..., "X.Y.Prelude" ,... ] `
05:25:52 --- mode: ChanServ set +o Cale
05:25:58 --- mode: Cale set +b *!*@gateway/web/freenode/ip.92.228.7.110
05:25:59 --- kick: husky__ was kicked by Cale (husky__)
05:26:06 --- mode: Cale set -o Cale
05:26:12 <Rc43> And then I interpret with it function "undefined", which uses types from X.Y.A, and it fails.
05:26:25 <ivanm> @where ops
05:26:26 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
05:26:37 <jmcarthur> j?
05:26:41 <jmcarthur> *?
05:27:07 <Rc43> (error is `Not in scope: type constructor or class `X.Y.A.SomeType`)
05:29:15 <hpaste> Rc43 pasted ‚ÄúHInt strange behaviour‚Äù at http://hpaste.org/66281
05:29:24 <Rc43> It is concrete example.
05:30:05 <hpaste> Rc43 annotated ‚ÄúHInt strange behaviour‚Äù with ‚ÄúHInt strange behaviour (annotation)‚Äù at http://hpaste.org/66281#a66282
05:38:09 <hpaste> Skola pasted ‚ÄúContractions‚Äù at http://hpaste.org/66283
05:38:30 <Skola> if anyone feels like shooting at some code..
05:50:10 <shergill> edwardk: i'm curious. at clarifi you have an in-house language which shares some elements with haskell, correct? what was the reason behind not sticking with haskell?
05:50:33 <edwardk> shergill: needs to run on the jvm, and some of the changes were to cut corners on implementation time
05:50:42 <edwardk> and some were because we need things haskell doesn't do
05:51:39 <shergill> oh interesting. though reducing it to jvm bytecode would've been a pain
05:52:25 <edwardk> an example of something trivially different: we didn't implement haskell style fixity because the declarations they complicate the parser, but we did implement a shunting yard parser, this lets us have infix prefix and postfix operators at the cost of sections
05:52:44 <edwardk> > 1 - - 2
05:52:45 <lambdabot>   Precedence parsing error
05:52:45 <lambdabot>      cannot mix `GHC.Num.-' [infixl 6] and prefix ...
05:52:48 <edwardk> will actually parse there
05:52:58 <shergill> oh nice
05:53:33 <edwardk> we dont really compile at present, just interpret and have a nice ffi out to scala
05:54:01 <shergill> i take it performance issues aren't critical?
05:54:14 <edwardk> anywhere they are, thats where the ffi kicks in ;)
05:54:35 <edwardk> we can lift scala monads into our language more or less directly
05:54:43 <edwardk> so its pretty cheap
05:55:19 <shergill> as for the infix notation, i at times wish haskell had gone lisp style =/. they're pretty but require you to remember the fixity rules
05:55:40 <edwardk> i really don't like lisp style. one of the nice things about haskell syntax to me is how light it is
05:55:51 <bitonic> if you give up sections you can do crazy things - see agda
05:56:10 <edwardk> bitonic: we thought about mixfix, but we'd already blown out feature budget =)
05:56:15 <edwardk> er our
05:56:28 <shergill> heh
05:56:36 <bitonic> edwardk: is it that complicated?
05:56:46 <edwardk> bitonic: it really mucks with the parser
05:57:03 <edwardk> and to parse it efficiently you want a memoizing parser
05:57:15 <edwardk> which means adding a packrat layer, etc.
05:57:27 <edwardk> and writing parser combinator libraries in scala is no fun
05:57:31 <bitonic> uhm, ok
05:57:41 <shergill> edwardk: by light i take it you mean 'implicit'?
05:58:19 <edwardk> shergill: i mean most of the complexity of what you see is intrinsic complexity, not something foisted off on you by the vagaries of the language grammar
05:59:00 <edwardk> (((i) am) not (very good) at parsing) ((((these)))
06:00:36 <edwardk> (actually, i am, i just think that in the end the difference between (define (foo a b c)) and (define foo a b c) just move the need to track distinctions to another level
06:00:40 <Rc43> Anybody knows solution to my problem above? (http://hpaste.org/66281)
06:01:27 <shergill> hmm i'm not sure if i actually agree with you on that one. i mean sure, the syntax makes clever use of whitespace and in most cases just does the 'right' thing. but i feel there's a cost associated with the syntactic sugar which goes into making haskell pretty or have a low footprint in terms of non-whitespace syntactic cues
06:02:15 <edwardk> there is a cost in everything. its a matter of personal preference, i tend to like having the language give me more rope to hang myself with ;)
06:02:24 <shergill> heh
06:02:37 <shergill> can i recommend c++. i hear it's AMAZING for such stuff
06:02:41 <mun> hi
06:02:45 <mun> in logic, could retracting an axiom from a consistent theory potentially cause inconsistency?
06:02:49 <shergill> *c++?
06:02:52 <edwardk> can't make up new operators ;)
06:02:59 <bitonic> edwardk: what are the things you "needed" that haskell didn't give you?
06:03:59 <bitonic> because I would go and create a new language to have different parsing of operators :P
06:04:05 <edwardk> bitonic: row types, custom kinds, kind polymorphism
06:04:19 <bitonic> ok
06:04:31 <edwardk> the operators were an example of a trivial distinction, that came about because we didn't want to bother implementing all the haskell stuff
06:04:52 <edwardk> for a long time we didn't even have operators
06:04:57 <shergill> mun: i don't think so, but i'm no expert
06:05:06 <edwardk> then i was so embarassed by it i put something in ;)
06:05:24 <hpaste> ClaudiusMaximus annotated ‚ÄúHInt strange behaviour‚Äù with ‚ÄúHInt strange behaviour (annotation) (annotation)‚Äù at http://hpaste.org/66281#a66284
06:05:34 <bitonic> edwardk: still, I feel like I can get around not having custom kinds/kind polymorphism... while  you can't really get around not having dependent types, for example
06:06:00 <bitonic> but I guess the main motivation was to have something like haskell on the JVM anyways
06:06:18 <edwardk> the row types are a big part of it for us. we need good types and good user facing error messages from types that arise from type checking joins, etc. for talking to sql
06:06:32 <t7> i like agda's _+_ notation
06:06:35 <bitonic> edwardk: I didn't mentioned row types because I'm not sure about that
06:06:38 <t7> if_then_else_
06:07:13 <bitonic> edwardk: I haven't really used OCaml which is the only thing that makes good uses of them afaik
06:07:32 <edwardk> the row types give us extensible records without hlists, and most importantly since fields are commutative, you can't just mix and match them with type classes
06:07:56 <edwardk> so we wind up with some custom constraint types
06:09:00 <bitonic> yeah the problem of records-like structure is a long standing one in Haskell :P. I'd probably put something related to that when creating a language
06:09:11 <edwardk> an example of a good use of a row type is join :: forall a b c. (exists d e f. a <- (d,e), b <- (e,f), c <- (d,e,f)) => [..a] -> [..b] -> [..c]
06:09:40 <edwardk> where the... <- ‚Ä¶ is a 'can be partitioned into' constraint
06:09:46 <bitonic> wait, brb
06:10:00 <edwardk> this is the kind of row types we support, which are more than you can say in ocaml
06:10:34 * jmcarthur has been using ocaml for a while now and didn't even realize it had row types at all until now...
06:11:41 <edwardk> type inference for row types with disjointness was an open problem. (checking was solved by harper and pierce)
06:11:43 <jmcarthur> oh i guess that's just polymorphic variants?
06:11:49 <jmcarthur> doesn't sound right...
06:11:52 <edwardk> jmcarthur: in that setting
06:12:01 <edwardk> variants are dual to records
06:12:02 <jmcarthur> ah
06:12:10 <jmcarthur> makes sense
06:12:42 <edwardk> given a record of continuations you and a variant you can use the variant as a continuation selector. and given a record of values and a variant of continuations you can also cancel out
06:13:27 <edwardk> so if you have extensible records/variants you can also get extensible case
06:13:29 <jmcarthur> oh that's a pretty neat duality
06:14:12 <edwardk> MLPolyR uses a notion of explicitly extensible case, but I've wanted a language that actually just uses the record/variant duality to match
06:14:17 <bitonic> edwardk: ah, that is iteresting
06:14:29 <bitonic> what's the [..a]? I mean the two dots
06:14:47 <edwardk> thats a relation with a given row type in our setting
06:14:56 <edwardk> {..a} would be a tuple
06:15:21 <shergill> hmm variants as in?
06:15:27 <bitonic> how do you actually do the partitioning?
06:15:32 <edwardk> shergill: ADT constructors
06:15:38 <bitonic> shergill: variant = tagged unions
06:15:43 <shergill> ah ok
06:15:45 <edwardk> bitonic: thats where the magic happens ;)
06:16:06 <edwardk> bitonic: the constraints are declarative. they just say that such a partitioning has to be able to exist, not what it is
06:16:06 <bitonic> edwardk: mind to share :D?
06:16:27 <edwardk> bitonic: its not something easily conveyed over IRC. its a huge pile of resolution-style rules
06:16:55 <bitonic> can you at least give an example of an 'a' which would satisfy that constraint?
06:17:40 <bitonic> I think I'll look into ocaml soon anyways, I want to know if they solve this problem neatly
06:17:51 <bitonic> because I don't know any PL that does :P
06:18:07 <jmcarthur> if i'm understanding the problem, i think ocaml doesn't solve it very neatly
06:18:19 <edwardk> e.g. if you have a row partitioned into a <- (Foo,Bar,x)   and a <- (y,Bar,Baz) -- you can figure out that there exists z. x <- (Baz,z), y <- (Foo,z)  -- but more over that z lacks Bar as well
06:18:27 <edwardk> bitonic: oh, sure
06:18:43 <teneen> Whats the advantage of lenses over record syntax?
06:18:43 <lambdabot> teneen: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:18:52 <jmcarthur> teneen: lenses are composable
06:18:53 <bitonic> teneen: lenses are not about syntax
06:19:11 <edwardk> join applied to relations of type [Foo,Bar] and [Bar,Baz]  would give back a relation with fields [Foo,Bar,Baz]
06:19:38 <bitonic> yeah, makes sense, but is there a nice way to build and decompose rows?
06:19:42 <teneen> jmcarthur: But you can easily nest records and access them too
06:20:00 <edwardk> teneen: foo { bar = f (bar foo) } isn't bad, but when you nest them over and over the number of times you talk about the same constructors is quadratic
06:21:04 <bitonic> teneen: modifying nested records is really, really annoying
06:21:19 <bitonic> or stuff like Foo {bar :: Map a b}, and you want to modify the map
06:21:20 <edwardk> teneen: foo { bar = (bar foo) { baz = f (baz (bar foo)) } ‚Ä¶ notice the repetition starting?
06:21:44 <edwardk> vs. using (baz . bar)
06:22:26 <teneen> edwark: nice example, thanks a lot
06:22:26 <edwardk> bitonic: ocaml doesn't do partitioning like that
06:22:47 <edwardk> bitonic: they only have has and lacks constraints iirc
06:23:08 <edwardk> the partitioning is our way of encoding disjointness, union, has and lacks in a single kind of constraint.
06:24:12 <bitonic> yeah but I think that the effectiveness is mostly in how easy it is to use objects with constraints, so I'd really like to see that :). do you have plans on publishing this PL, or is it too specific?
06:24:49 * hackagebot hmatrix-syntax 0.1.2.1 - MATLAB-like syntax for hmatrix vectors and matrices  http://hackage.haskell.org/package/hmatrix-syntax-0.1.2.1 (ReinerPope)
06:24:58 <edwardk> if we get a few corner cases ironed out, we'll probably publish something even if its only a whitepaper
06:25:15 <bitonic> coolio
06:27:10 <edwardk> its interesting how many hoops i just had to jump through to add a haskell function as a finalizer to a foreignptr
06:27:28 <edwardk> @hpaste
06:27:28 <lambdabot> Haskell pastebin: http://hpaste.org/
06:27:55 <hpaste> edwardk pasted ‚ÄúaddForeignPtrHaskellFinalizer‚Äù at http://hpaste.org/66285
06:28:26 <mk> how can I get a list of types in a typeclass?
06:28:36 <bitonic> yeah good 'ol "wrapper"
06:28:43 <jmcarthur> ew, "newIORef undefined"...
06:28:43 <edwardk> mk: template haskell has a function
06:28:50 <jmcarthur> mfix is much nicer :)
06:28:56 <edwardk> jmcarthur: to be fair, i do ensure that i don't install the handler until after
06:28:59 <edwardk> i thought about it
06:29:01 <bitonic> mk: :info TypeClass
06:29:32 <mk> thanks
06:29:52 <bitonic> @info Num
06:29:52 <lambdabot> Num
06:29:58 <bitonic> tsk. doesn't work here.
06:30:00 <bitonic> :info Num
06:30:02 <jmcarthur> yeah that's a pretty complicated way to add a finalizer...
06:30:15 <edwardk> also fixIO is going to go off and make an MVar
06:31:07 <mk> where can I find the documentation/listing that includes both :t and :info (and presumably others)?
06:31:18 <bitonic> mk: ghc manual
06:31:31 <edwardk> oh, he just wants it for interactive use. yeah :info is your friend =)
06:31:47 <bitonic> mk: or in ghci, :help
06:32:20 <jmcarthur> edwardk: how about unsafeFixIO? :)
06:32:33 <mk> thank you
06:33:23 <mk> :k Int
06:33:24 <lambdabot> *
06:34:13 <hpaste> edwardk annotated ‚ÄúaddForeignPtrHaskellFinalizer‚Äù with ‚ÄúaddForeignPtrHaskellFinalizer (annotation) with Monad.Fix‚Äù at http://hpaste.org/66285#a66286
06:34:17 <bitonic> now, if only ghci had haddock support, you'd neve leave the terminal.
06:34:31 <edwardk> jmcarther: happier?
06:35:12 <jmcarthur> only if the mvar is acceptable, of course
06:35:26 <edwardk> meh, these are pretty uncommon in my current usage
06:35:46 <edwardk> i'd just use recursive do, but its an extra extension
06:37:33 <hpaste> edwardk annotated ‚ÄúaddForeignPtrHaskellFinalizer‚Äù with ‚Äúdorec‚Äù at http://hpaste.org/66285#a66287
06:37:59 <jmcarthur> i like dorec, but it does only save a few characters here
06:39:32 <jmcarthur> woah, unsafeFixIO uses unsafeDupableInterleaveIO. i was aware of this function, but i don't think i've ever used it before
06:39:38 <edwardk> hah
06:40:27 <bitonic> wut
06:40:35 <bitonic> what does that do?
06:40:41 <shergill> o.O
06:40:50 <jmcarthur> dupable means it's safe for ghc to inline it, meaning it could be executed more than once
06:40:59 <jmcarthur> interleave does the same as unsafeInterleaveIO
06:41:10 <bitonic> yeah it's the dupable that confused me ehe
06:41:27 <mk> what must :kind take in order to display something that isn't merely *?
06:41:49 <edwardk> :k Maybe
06:41:50 <lambdabot> * -> *
06:41:59 <bitonic> :k Mu
06:42:00 <lambdabot> (* -> *) -> *
06:42:03 <edwardk> if you have ConstraintKinds turned on you can :k Eq as well
06:42:04 <jmcarthur> *dupable means you are *claiming* that it's safe to inline it, of course :)
06:42:51 <mk> hmm, thanks
06:43:08 <bitonic> :k RWST
06:43:09 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
06:43:12 <bitonic> yeeee
06:43:24 <copumpkin> :k Monad
06:43:25 <lambdabot>     Class `Monad' used as a type
06:43:25 <lambdabot>     In the type `Monad'
06:43:26 <jmcarthur> i was wrong
06:43:36 <bitonic> I wonder what's the longest kind in base
06:44:09 <edwardk> dunno. i think i can find my longest one though
06:44:21 <bitonic> :k Kleisli
06:44:22 <lambdabot> (* -> *) -> * -> * -> *
06:44:27 <bitonic> I think it's Kleisli.
06:44:47 <edwardk> class HComposition
06:44:47 <edwardk> 	(o :: ((* -> *) -> * -> *) ->
06:44:47 <edwardk> 	      ((* -> *) -> * -> *) ->
06:44:48 <jmcarthur> bitonic: sorry, dupable means ghc can ignore the check to make sure it's only being executed in one thread. it's slightly easier for me to think about with unsafeDupablePerformIO then unsafeDupableInterleaveIO
06:44:49 <edwardk> 	      ((* -> *) -> * -> *))
06:45:09 <shergill> wtf
06:45:19 <bitonic> edwardk: that is quite a kind you have there.
06:45:21 <shergill> oh ok the name makes sense
06:45:25 <jmcarthur> woah
06:45:36 <edwardk> HComposition :: (((* -> *) -> * -> *) -> ((* -> *) -> * -> *) -> ((* -> *) -> * -> *))) -> Constraint
06:45:42 <bitonic> jmcarthur: yeah I was reading the docs now :)
06:46:01 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.3/doc/html/src/Control-Functor-HigherOrder-Composition.html
06:46:59 <edwardk> i have a left kan extension version of that somewhere as well
06:50:42 <osager> ‰Ω†
06:57:07 <gbacon> do type variables given in the type annotation of an inner (where) function relate to the type variables in the toplevel annotation?
06:58:13 <dobblego> not unless you used ScopedTypeVariables
06:58:50 <gbacon> how can I work around ìcould not deduce Öî errors from the typechecker?
06:59:04 <gbacon> is that particular extension the clearest way to express it?
06:59:11 <dobblego> type errors aren't really meant to be worked around
06:59:21 <dobblego> you mean you want to type-annotate with the outer type variables?
06:59:22 <gbacon> poor choice of words on my part
06:59:26 <gbacon> yes
06:59:33 <dobblego> use ScopedTypeVariables
07:00:21 <gbacon> can I also use a general type on the inner annotation but with different names for the type vars?
07:00:48 <dobblego> not really following you there
07:01:18 <gbacon> say the toplevel annotation is Ord a => t -> a
07:02:09 <gbacon> in the inner annotation, I really want to reuse the constrained a, but do I have to write Ord b => ... for the inner annotation?
07:02:21 <mysticc> what does this flag do .. -optc-O3
07:02:29 <gbacon> even there, won't the typechecker fail with could not deduce (a ~ b)?
07:03:30 <ClaudiusMaximus> hm, hint is confusing!  this doesn't work (hint error says "Ratio not in scope", wtf):   (print =<<) . runInterpreter $ setImports [ "Prelude" ] >> interpret "1/5" (as :: Rational)
07:03:50 <dobblego> gbacon: I believe you do iirc, try it
07:04:21 <gbacon> http://hackage.haskell.org/trac/haskell-prime/wiki/ScopedTypeVariables seems to suggest itís inexpressible in Haskell98
07:04:43 <Phlogistique> is there a function that applies a binary function over every couple in a list?
07:04:43 <mk> why are functions not in Eq?
07:04:45 <gbacon> ìThe argument type of cmp is the type a in the signature of sortImage, but there is no way to refer to it in a type signature. Quantification of type variables over expressions is needed.î
07:04:59 <dobblego> Phlogistique: zip `ap` tail
07:05:22 <Phlogistique> for example, f (,) [1,2,3] = [(1,2), (1,3), (2,3)]
07:05:33 <dobblego> gbacon: ScopedTypeVariables isn't H98
07:05:35 <Phlogistique> dobblego: every couple, not just consecutive ones
07:06:07 <gbacon> dobblego: indeed, I get the deduction failures
07:06:41 <gbacon> dobblego: right, the antecedent of it was ìa is the same type in the toplevel and inner annotationsî
07:07:30 <ClaudiusMaximus> > let xs = "Phlogistique" in [ (a,b) | a:bs <- tails xs, b <- bs ]
07:07:31 <lambdabot>   [('P','h'),('P','l'),('P','o'),('P','g'),('P','i'),('P','s'),('P','t'),('P'...
07:07:33 <dobblego> Phlogistique: liftA2 if you also want the pair swapped
07:07:55 <dobblego> otherwise, use tails
07:09:22 <sarfraz>  /quit
07:10:36 <Phlogistique> ClaudiusMaximus: uh, thanks
07:14:03 <dobblego> is there a paper that polyparse is based on?
07:14:21 <bitonic> dobblego: apaart from the usual Hutton-Meijer stuff?
07:14:37 <dobblego> what Hutton-Meijer stuff specifically?
07:14:39 <gbacon> dobblego: ok, it typechecks now, but it leaves me scratching my head
07:15:08 <bitonic> dobblego: eprints.nottingham.ac.uk/237/1/monparsing.pdf
07:15:12 <dobblego> ta
07:15:18 <gbacon> toplevel is :: forall a b. Ord b => (a -> b) -> [a] -> [[a]]
07:15:31 <gbacon> inner is go :: Map b [a] -> a -> Map b [a]
07:15:36 <bitonic> dobblego: but polyparse expands that. still, the core concepts are there
07:15:49 <dobblego> ok, I thought polyparse might be a bit more than that
07:16:02 <bitonic> it is
07:16:26 <dobblego> what is its essential difference to parsec?
07:16:44 <bitonic> <|> backtracks
07:16:56 <bitonic> also, it's not as general as parsec -> better error reporting
07:17:09 <dobblego> where is it not as general?
07:17:22 <bitonic> dobblego: it doesn't use a class like Stream
07:17:30 <dobblego> ok so it uses ByteString?
07:17:37 <bitonic> but it's built around the text type you're using
07:17:44 <bitonic> dobblego: it has modules for various text types
07:18:03 <dobblego> ok, so its specific to text rather than streams
07:18:08 <bitonic> yes
07:18:16 <dobblego> that would be handy for error-reporting
07:18:19 <dobblego> cheers
07:18:38 <bitonic> yw. on the other hand, <|> makes error reporting harder!
07:19:07 <bitonic> trifecta has <|> like parsec, and a parser tailored around ByteStrings => very good error reporting. but no documentation!
07:19:07 <dobblego> does it really from the user's perspective?
07:19:30 <dobblego> so named because it achieves all three desirable properties? :)
07:19:36 <edwardk> hah
07:19:52 <edwardk> well, trifecta was named from a talk a gave on something only vaguely related
07:19:53 <bitonic> dobblego: well if you take some care in annotating choices that use 'try' with <?> you get decent errors anyways
07:20:08 <bitonic> but with trifecta you "know" you're going to get good errors
07:20:14 <bitonic> (I haven't used it that much)
07:20:27 <edwardk> error reporting in trifecta is prety careful in the case of <|> to actually report all the errors in the correct places
07:20:33 <edwardk> unlike parsec
07:20:37 <edwardk> which will move your errors on try
07:21:14 <edwardk> in general in parsec, the <?> after a try like try foo <?> "bar" should be considered required
07:22:07 <edwardk> whereas trifecta will just tell you where that we failed to parse wherever the foo started because of an error wherever it failed inside foo, with what was expected at that nested location
07:22:23 <edwardk> with all of the possibilities across branches aggregated
07:24:54 * hackagebot cabal-debian 1.20 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-1.20 (DavidFox)
07:25:36 <Phlogistique> is .: defined anywhere standard?
07:25:55 <bitonic> what was that again
07:25:58 <bitonic> :type (.:)
07:26:05 <dobblego> @type fmap fmap fmap
07:26:06 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:26:13 <bitonic> @type (.:)
07:26:14 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
07:26:14 <Phlogistique> bitonic: .: = (.) . (.)
07:26:46 <ClaudiusMaximus> i conclude 'hint' + type synonym = pain.  i'm guessing it's down to  Data.Typeable.typeOf (undefined :: TypeSynonym) = "OriginalType" != "TypeSynonym"  or something equivalent
07:26:55 <hpc> the haskell wiki seems to be out of date on how to use hpc
07:27:58 <mk> why are functions not in Eq?
07:28:07 <dobblego> hpc: funny you mention it, I tried using hpc but the docs didn
07:28:10 <dobblego> 't line up
07:28:19 <dobblego> mk: what would such an instance look like?
07:28:55 <Phlogistique> dobblego: for finite types, it should be possible
07:29:04 <mk> dobblego: presumably two functions defined in the same way?
07:29:08 <hpc> does anyone know how to get a tix file for a module with hpc?
07:29:10 <dobblego> sure, so how would it look?
07:29:10 <bitonic> mk: how do you define that?
07:29:14 <hpc> i think i can get the rest of the way from there
07:29:32 <bitonic> mk: the best you can do is some extensional equality. comparing the code would be silly.
07:29:44 <mk> by looking at the definition, in some way
07:29:54 <bitonic> with extensional equality I mean actually trying all the possible input :P
07:30:01 <mk> bitonic: what do you mean by some extensional equality?
07:30:22 <mk> I see :)
07:31:06 <bitonic> mk: what you're asking is for intensional equality, which you can't express in haskell anyways
07:31:08 <mk> so in principle, they're in Eq?
07:31:16 <bitonic> no, in principle they're not
07:31:20 <dobblego> for finite types
07:31:25 <dobblego> (i.e. no)
07:32:13 * chazzha waves
07:32:21 <mk> many types are finite
07:32:42 <chazzha> anyone know of any place where there is some decent example code for gtk2hs signal handling
07:33:05 <chazzha> finding it hard to translate from badly documented c...
07:33:19 <bitonic> mk: you could extensional equality with a typeclass like 'class Finite a where; members :: [a]'
07:33:40 <bitonic> and then 'instance (Finite a, Eq b) => a -> b where ...'
07:34:30 <mk> I'm not sure I understand why they aren't in Eq - it seems that functions would need to be indeterministic for that to be the case
07:35:05 <dobblego> please enumerate all inputs of a function of this type: [()] -> ()
07:35:10 <bitonic> mk: because extensional equality in the general case is undecidable
07:35:19 <bitonic> I'm sure it's easy to see why
07:36:03 <bitonic> mk: is 'foo x = x' equal to 'baz = \x -> x'? you can't check without restricting the types
07:37:06 <Philonous> mk:  To determine whether two functions are equal you would have to tell whether they both terminate for a given input. That's impossible. (See http://en.wikipedia.org/wiki/Halting_problem)
07:37:24 <mysticc> @hoogle Data.Array.Parallel
07:37:25 <lambdabot> package parallel
07:37:25 <lambdabot> package parallel-io
07:37:25 <lambdabot> package parallel-tree-search
07:37:33 <mk> Philonous: ah
07:37:50 <bitonic> mk: oh yes, and of course even with finite domain you have the problem that Philonous mentioned
07:37:58 <mk> ok, that all makes sense
07:38:11 <mysticc> @hoogle Data.Array.Parallel.Prelude.Int
07:38:11 <lambdabot> package intel-aes
07:38:11 <lambdabot> package interleavableGen
07:38:11 <lambdabot> package interleavableIO
07:39:21 <mk> ...though I suspect that at least some attempt could be made, with an exception thrown when the attempt is not successful
07:39:51 <mk> not all ints can be added, but they're still in Num
07:39:55 <ClaudiusMaximus> eww, i was right. http://darcsden.com/jcpetruzza/hint/browse/src/Hint/Eval.hs#L-34
07:39:55 <Philonous> OTOH the same problem holds for ([1..] == [1..]), yet we do have Eq for Lists. So maybe that's a spurious reason
07:40:45 <mk> what are those [1..] lists?
07:40:50 <bitonic> mk: exception? how do you know when the function has diverged :P?
07:41:10 <bitonic> mk: and yes you can do what I said before, given some class that enumerates the member of the type (like Enum)
07:41:11 <Philonous> bitonic:  You don't but you might just let (==) diverge in those cases as well
07:41:29 <mk> diverged?
07:41:39 <bitonic> Philonous: yeah but mk mentioned throwing an exception when it diverges, or maybe I misunderstood
07:42:02 <Philonous> mk:  Those are (potentially) infinite lists, enumerating all integers.
07:42:50 <bitonic> mk: diverging function = non terminating
07:43:16 <koala_man> how can I write imperative flow like C  if (foo) return bar;  I tried callCC with "when foo $ c result" but it fails since the alternate value is () and I don't want that out
07:43:37 <mk> so diverged means taken in inputs for which it will not terminate?
07:44:07 <bitonic> mk: something that's diverging is something that's not going to produce a value
07:44:15 <bitonic> > let x = x in x
07:44:19 <lambdabot>   mueval-core: Time limit exceeded
07:44:40 <mk> hey, look, it already throws exceptions :)
07:45:12 <bitonic> well, how do you know it's not actually going to produce a value at some point :P?
07:45:42 <mk> bitonic: you don't, but can't an exception be thrown?
07:45:52 <bitonic> mk: I don't follow
07:46:04 <bitonic> you're saying "just stop after 10 seconds" or whatever?
07:46:05 <mk> or are exceptions only for cases where there *is* no defined value, like 1/0
07:46:48 <bitonic> mk: you can explicitly say "no value here" using 'undefined', or 'error'
07:47:02 <bitonic> which is more informative
07:47:35 <mk> bitonic: yep, for given inputs (I'm not saying this should actually be implemented, I'm just wondering how things would play out)
07:48:07 <bitonic> what should be implemented?
07:48:45 <mk> putting functions into Eq, and throwing exceptions
07:49:19 <bitonic> I don't get where you would throw exceptions
07:49:31 <mk> bitonic: after 10 seconds
07:49:42 <bitonic> mk: why? that doesn't make much sense
07:49:58 <mk> it's a failure to compute the value
07:50:16 <bitonic> it's not
07:50:20 <bitonic> maybe it's just a long computation
07:50:33 <bitonic> that's the point, you don't (and can't) know
07:50:40 <bitonic> unless you give up general recursion
07:51:16 <mk> hmm. So what counts as a failure to compute a value? Just non-halting?
07:51:24 <bitonic> yes
07:51:34 <Philonous> koala_man:  I think you want delimited continuations with answer-type modification. But that can't be expressed in a haskell monad, you need indexed monads for that.
07:51:51 <bitonic> mk: well it depends what you care about really :P
07:52:08 <mk> what's the proper term for when you try succ on the highest value of an enum?
07:52:41 <mk> (or division by zero, or addition of very big bounded ints)
07:52:58 <dobblego> _|_
07:53:09 <bitonic> mk: see http://en.wikipedia.org/wiki/Computability
07:53:11 <kowalej> bottom
07:53:14 <kowalej> ?
07:53:40 <mk> bitonic: which part?
07:53:58 <bitonic> mk: the whole page, for an answer "what's failure to compute a value"
07:54:01 <bitonic> an answer to
07:54:04 <Philonous> koala_man:  It might be easier (though uglier) to just transform you code by hand, instead of (when p $ cReturn (foo)) you write "if p then return foo else <..>"  where <..> is the rest of the action
07:54:11 <dobblego> there is probably a section on decidability
07:55:15 <dobblego> Types and Programming Languages (Pierce) is a good text on that too
07:55:16 <koala_man> Philonous: I have 7 levels. I just made my own mwhen that works like when but returns my default value
07:56:13 <mk> I understand that, but I'm not sure I understand the problem with throwing an exception for very long computations (which I think means I don't understand exceptions)
07:56:27 <dobblego> how long is very long?
07:56:34 <bitonic> mk: you can't know if it's non terminating or just a long computation!
07:56:38 <mk> dobblego: 10 seconds :)
07:56:47 <bitonic> you're going to throw away perfecly good, terminating programs :P
07:56:55 <dobblego> you just wiped out a pretty large class of perfectly decidable problems
07:57:00 <bitonic> of course you can argue that it's a compromise, but it's not a useful one
07:57:07 <mk> bitonic: right, but I'm not suggesting that the function needs to return _|_
07:57:32 <bitonic> mk: also, you can't write that function purely
07:57:51 <bitonic> mk: I'm not contesting the possiblity of writing that function. i'm just saying it's not that useful :P
07:58:19 <Philonous> koala_man:  With delimited continuations you might do something like (justWhen p c = shift $ \f -> if p then return c else f () >> return Nothing)
07:58:24 <dobblego> which is the ultimate answer to the question
07:58:57 <Philonous> koala_man:  sorry, I meant "return (Just c)"
07:59:32 <bitonic> mk: btw, there are languages that are normalising (always terminating). but as of 2012, they're not that useful for practical purposes
07:59:42 <bitonic> but mostly to have a consistent logic to prove theorems
07:59:53 <mk> bitonic: if we're dropping down from the clouds to practical utility, then it might be useful to compare if two functions are the same - that's essentially what unit tests do
07:59:58 <koala_man> Philonous: what's shift?
08:00:17 <bitonic> mk: in fact that's exactly what QuickCheck does. but calling it equality is wrong.
08:00:37 <dobblego> @check \x -> x + 1 == succ x
08:00:38 <lambdabot>   "OK, passed 500 tests."
08:00:50 <Philonous> koala_man:  It's like call/CC, but the continuation returns after you invoke it (and you can throw is away). It's a primitive of delimited continuations
08:01:12 <mk> bitonic: if it returns a value without throwing an exception, then I agree, but I'm still confused about exceptions, then
08:01:18 <dobblego> @check (==) <$> (1+) <*> succ
08:01:19 <lambdabot>   "OK, passed 500 tests."
08:01:44 <mk> is it the fact that for a function to be functional, it has to throw exceptions for all the same inputs?
08:01:44 <ClaudiusMaximus> mk: perhaps you want something like (==?) :: a -> a -> IO Result where data Result = Known Bool | UnknownSoFar{ tryForAnotherLittleWhile :: IO Result }
08:02:06 <bitonic> mk: what do you mean by "exceptions"?
08:02:19 <bitonic> because if you mean 'undefined', just treat that as a non-terminating function
08:03:15 <mk> ClaudiusMaximus: unsure - I'm not looking for a practical solution, I'm just trying to figure out what termination etc. means when it comes to exceptions and equality
08:03:33 <dobblego> TaPL covers that topic well, just sayin
08:03:36 <bitonic> mk: the practical solution exists already - QuickCheck, smallcheck
08:03:37 <mk> bitonic: right, I'm wondering what exceptions are
08:03:55 <bitonic> mk: ... is that a philosophical question? exception is just a term
08:04:02 <mk> my view was that you could throw an exception whenever the computation doesn't turn out
08:04:46 <bitonic> mk: that's vague. you usually want to throw exception when there are problems yes, but 'undefined' is a brutal way of doing that.
08:04:53 <kowalej> mk: how do you know the computation didn't "turn out"
08:04:57 <bitonic> there are much nicer ways, e.g. Control.Exception
08:05:27 * dobblego sings a tune about Chapter 14 of TaPL
08:05:41 <Yrogirg> Hi! When does (->) is associative?
08:05:47 <bitonic> you don't even need TaPL for this :P
08:05:59 <dobblego> it's a pretty robust answer though
08:06:13 <dobblego> in the meantime, we can just say "exception" is a synonym for _|_
08:06:15 <bitonic> yeah but it's a very broad field then
08:06:21 <bitonic> dobblego: I think that's very confusing
08:06:23 <copumpkin> Yrogirg: never
08:06:23 <mk> kowalej: 1) it is clearly _|_, like succ GT, 2) for some reason, you can't determine the value
08:06:56 <copumpkin> well, () -> (() -> ()) ~ (() -> ()) -> ()
08:06:59 <copumpkin> but that's not saying much
08:07:39 <Yrogirg> copumpkin when does such isomorphism exist?
08:08:02 <bitonic> mk: there are two issues here: one about when functions terminate and when extensional equality is decidable, which I believe we have solved
08:08:07 <dobblego> for values of x, y and z where x^(y^z) == (x^y)^z
08:08:09 <mk> ...where 2) can be split up into 2a) the function is deterministic with respect to exception-throwing, or 2b) it isn't
08:08:23 <dmwit> copumpkin, dobblego: You're not being careful of undefined.
08:08:42 <dobblego> dmwit: I solved the halting problem, I'm fine
08:08:48 <bitonic> mk: and one about how to think about partiality in haskell, which is something different, and calling 'undefined' an exception is confusing imho
08:08:58 <copumpkin> dmwit: yeah, fuck undefined :)
08:09:26 <copumpkin> dobblego: so for Bool, too
08:09:48 <copumpkin> Bool -> (Bool -> Bool) ~ (Bool -> Bool) -> Bool
08:09:51 <copumpkin> (again, fuck undefined)
08:10:22 <mk> bitonic: well, undefined itself is not an exception, but the computation of any function that is undef is exceptional
08:11:07 <dobblego> bitonic: I do not suggest calling undefined an exception
08:11:16 <Skola> when pattern matching one can use values like f (x:"foo":xs) = "bar" : f xs, but can one also use a range of values in the pattern?
08:11:32 <mauke> Skola: no
08:11:45 <dobblego> in teaching, I don't let the student make any excuses (they are not allowed to until they get their licence to fuck undefined) -- I find this useful
08:11:48 <Skola> ok :}
08:11:57 <bitonic> mk: what do you mean with "exceptional"? this is a pointless discussion :P
08:12:05 <dmwit> Skola: You may write any computation that returns a Bool as a guard.
08:12:20 <dobblego> I do this by attributing "exceptions", "non-termination", etc. to the same concept, which I might call "a big fat lie"
08:12:22 <dmwit> Skola: e.g. f (x:xs) | x `elem` ["foo", "bar"] = ...
08:12:53 <dobblego> bye
08:13:15 <Skola> yeah, my function currently looks like
08:13:17 <mk> bitonic: well, I don't know if it has a concrete point, but I'm finding it useful so far :)
08:13:17 <hpaste> Skola pasted ‚Äúguards/patterns‚Äù at http://hpaste.org/66290
08:13:33 <mk> by exceptional, I mean that it will always throw an exception in such a case
08:13:52 <bitonic> mk: well but I think that I said what I had to and we're just going in circles now
08:13:55 <Skola> but haven't used guards/pattern matching much yet, so am unsure if I'm doing things right
08:14:09 <copumpkin> you guys should stop talking about me
08:14:11 <copumpkin> I'm not that exceptional
08:14:19 <bitonic> copumpkin: yes you are
08:14:27 <copumpkin> oh okay, if you insist
08:14:48 <dmwit> Skola: I can't believe I'm saying this, but... have you considered using regexen?
08:14:59 <DeafRex> Anybody know if "Bonus" has been around these parts lately? I'll like to talk to him about http://stackoverflow.com/questions/9892814/confusion-regarding-a-passage-in-the-kinds-and-some-type-foo-section-of-learny
08:15:09 <Skola> yeah was considering it
08:15:10 <bitonic> preflex: seen BONUS
08:15:10 <preflex>  BONUS was last seen on #haskell 335 days, 19 hours, 47 minutes and 12 seconds ago, saying: yeah i think that's better as well
08:15:14 <bitonic> DeafRex: no.
08:15:16 <mauke> dmwit: regexes don't work on lists
08:15:18 <mk> bitonic: hmm. When is it appropriate to use an exception, why isn't it appropriate for succ GT, and why isn't it appropriate for the hypothetical function-equality function?
08:15:25 <dobblego> omg and here I was thinking dmwit was a carefully considerate kind of guy warning others of the dangers of undefined
08:15:25 <Skola> what mauke said
08:15:52 <dmwit> mauke: I bet he's getting that list by breaking up a String.
08:15:59 <dmwit> And even if not, concat works on lists.
08:16:06 <mauke> ew
08:16:10 <bitonic> mk: uff... the last part is not about exceptions. you want to stop after 10 seconds, which doesn't make *any* sense when talking about function equality
08:16:29 <Skola> sure, but I kinda like my current strategy; initial tokenization and then optionally transforming the token list
08:16:38 <bitonic> for what regard "when do I use exceptions", if by "exceptions" you mean 'undefined'/'error', almost never
08:16:39 <DeafRex> bitonic: His webpage says he might be found here. Oh well, thanks anyways.
08:16:48 <mk> bitonic: that's why it's an exception
08:17:15 <bitonic> DeafRex: if you have questions just ask :)
08:17:17 <Skola> and the function does what I want it to, but I'm just wondering if there's a more sensible way to write it down
08:17:39 <dmwit> bitonic: I think his question is "when will you fix it"...
08:17:43 <mk> if I have a very large computation (function) that I had to use the disk for, and the disk becomes non-deterministically corrupted, it seems right to throw an exception
08:18:23 <bitonic> mk: yes, but in a more sensible way, not through 'error'
08:18:27 <bitonic> see Control.Exception
08:18:40 <bitonic> and now I'm going to stop because I typed "exception" way too much in the past 15 mins :P
08:19:06 <mk> bitonic: sure, and thanks
08:19:34 <bitonic> mk: no problem
08:19:49 <bitonic> mk: for the most part, just forget that 'error' exists.
08:20:42 <bitonic> you might want to use it just when you have some set of functions that interact in some way internally and you *know* that things shouldn't go some way, and they do :P
08:20:44 <mk> is error the same as exception?
08:20:49 <DeafRex> bitonic: Well, its relating to the link I posted, regarding his book "Learn You A Haskell For Great Good!"
08:22:10 <Skola> dmwit are regexes preferable for tokenizing natural language?
08:22:52 <dmwit> I have no idea.
08:22:57 <tech2> Skola: no.
08:23:01 <dmwit> I'm not ultimately demanding you use them.
08:23:22 <dmwit> I have no idea which would be better in the end -- I just wanted to suggest them in case you hadn't thought of it and thought it might be clean.
08:23:28 <tech2> Skola: there are a number of toolkits/libraries for natural language tokenisation out there though.
08:23:41 <Skola> tech2 I usually use NLTK
08:24:26 <Skola> dmwit you might be right, but I want these functions to work on my initial token stream
08:24:41 <Skola> so post-tokenization actually
08:24:59 <Skola> but I should probably consider regexps if this is not flexible enough
08:25:22 <hpaste> ‚Äú@tell Rc43 from ClaudiusMaximus‚Äù annotated ‚ÄúHInt strange behaviour‚Äù with ‚ÄúHInt strange behaviour (annotation) (annotation) (annotation)‚Äù at http://hpaste.org/66281#a66291
08:25:35 <ClaudiusMaximus> aww.
08:26:02 <ClaudiusMaximus> @tell Rc43 http://hpaste.org/66281#a66291
08:26:02 <lambdabot> Consider it noted.
08:27:01 <JamesJRH> Is there a channel for Gitit? If not, how do I configure login priviledges? And how do I make it aware that it is being proxied on /gitit ?
08:38:06 <kowey> Skola: do you know about the Haskell NLP mailing list?
08:38:33 <kowey> I try to plug it every time I see somebody talk about Haskell and natural language http://projects.haskell.org/cgi-bin/mailman/listinfo/nlp
08:53:53 <angstrom> @pl \c -> c == 'a' || c == 'b'
08:53:53 <lambdabot> liftM2 (||) ('a' ==) ('b' ==)
08:59:57 * hackagebot snaplet-hdbc 0.7.2.2 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.7.2.2 (JurrienStutterheim)
09:19:45 <hpaste> killy9999 pasted ‚Äúparse error on input `='‚Äù at http://hpaste.org/66293
09:19:58 <killy9999> why do I get error on line 17?
09:20:20 <mauke> indentation
09:20:33 <killy9999> I'm trying all possible indentation I can
09:20:42 <killy9999> I'm using haskell mode for emacs btw
09:20:50 <killy9999> how should this be indented?
09:21:07 <mauke> it shouldn't be
09:21:58 <killy9999> when I remove indentation I get "multiple declaration" errors
09:22:27 <killy9999> ops...
09:22:46 <killy9999> yeah, I get multiple declaration errors but from different parts of the code
09:23:05 <killy9999> why can't I use the same names for fields in different data types?
09:23:28 <hpc> killy9999: data Foo {foo :: Int}
09:23:37 <hpc> killy9999: data Bar {foo :: Double}
09:23:47 <hpc> killy9999: what's the type of foo? (assume i used the right syntax there)
09:23:49 <hpaste> killy9999 pasted ‚Äúwhy can't I use same names in different data types?‚Äù at http://hpaste.org/66294
09:24:07 <killy9999> hm...
09:24:23 <killy9999> ok, so each time you do something like this you get a function?
09:24:32 <hpc> killy9999: desc :: Task -> String; desc :: CLOptions -> String
09:24:38 <hpc> yep
09:24:44 <killy9999> I see
09:24:59 <killy9999> not intuitive for a newbie
09:25:25 <mauke> that's just because newbies have bad intuition
09:26:51 <killy9999> not bad, just not haskell kind of intuition :)
09:27:10 <mauke> I didn't say haskell newbies
09:28:14 <killy9999> yes, but I'm a haskell newbie and I have a bad intuition for Haskell
09:29:09 <dmwit> To be fair, even some quite expert Haskell users think this is a bad state for records to be in.
09:29:20 <dmwit> Unfortunately, the discussion about how to fix them seems to never end in somebody fixing them.
09:29:38 <dmwit> never seems to end?
09:29:49 * dmwit not good in English
09:29:58 * hackagebot X11 1.6.0 - A binding to the X11 graphics library  http://hackage.haskell.org/package/X11-1.6.0 (DanielWagner)
09:30:40 <killy9999> OK, a different question I already asked today but got no answer
09:31:10 <killy9999> how to turn UTCTime into Int (like number of seconds from beginning of Unix epoch)
09:31:25 <killy9999> I want to make my Task an instance of Hashable
09:31:43 <killy9999> and construct hash based on unique creation time assigned to a task
09:32:22 <dmwit> Why would that involve turning a UTCTime into an Int?
09:32:59 <killy9999> because UTCTime isn't instance of Hashable
09:33:06 <killy9999> and can't be hashed just like that
09:33:25 <dmwit> Presumably the fix is to make it an instance of Hashable, not to turn it into a number of seconds since epoch.
09:33:41 <killy9999> if I can convert UTCTime to Int then I can use hashWithSalt to construct a hash based on time and other mandatory fields
09:34:04 <dmwit> I agree that converting UTCTime to Int is sufficient. I'm suggesting that it is, nevertheless, not necessary.
09:34:21 <killy9999> but then I would have to have access to internals of UTCTime, right?
09:34:24 <mauke> dmwit: and what does Hashable do?
09:34:36 <dmwit> Sorry, let me be more clear.
09:34:42 <mauke> killy9999: you do
09:34:43 <killy9999> it allows to create hash of a type
09:34:51 <dmwit> I agree that converting UTCTime into a number of seconds since epoch is sufficient. I'm suggesting that it is, nevertheless, not necessary.
09:34:53 <gbacon> dobblego: thanks for your help earlier; see http://stackoverflow.com/a/9950459/123109
09:34:58 * hackagebot hsql 1.8.2 - Database access from Haskell.  http://hackage.haskell.org/package/hsql-1.8.2 (NickRudnick)
09:35:09 <killy9999> http://hackage.haskell.org/packages/archive/hashable/1.1.2.3/doc/html/Data-Hashable.html
09:36:11 <killy9999> dmwit: if it's not necessary, then how can I make UTCTime an instance of Hashable?
09:36:22 <killy9999> I mean how should I define hash function for UTCTime?
09:36:31 <dmwit> Something like hash (UTCTime (ModifiedJulianDay day) diff) = hash day `xor` floor diff
09:36:34 <killy9999> I would have to get to internals of UTCTime that are hashable
09:37:05 <killy9999> gay is an Int?
09:37:08 <dmwit> or maybe `xor` hash (toRational diff)
09:37:17 <dmwit> day is an Integer
09:37:21 <shepheb> my gitit can't connect to git proprely. this seems to have started after an upgrade of git on arch linux, but I reinstalled gitit and all its dependencies hoping they would build against the new git.
09:37:22 <killy9999> xor is not necessary
09:37:25 <mauke> killy9999: http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#v:UTCTime
09:37:28 <killy9999> I can use hashWithSalt
09:38:13 <killy9999> mhm
09:38:24 <killy9999> ok, I'll experiment with that in a moment'
09:39:30 <dmwit> (To be clear: it is possible to convert between UTCTime and POSIX time, but it's more complicated than this is.)
09:41:18 <dmwit> Probably, the really right way is to make Day and DiffTime instances of Hashable and then use hash (UTCTime day diff) = hash (day, diff)
09:41:28 * ClaudiusMaximus agree
09:41:40 <dmwit> killy9999: (just saying your name so you see that this is aimed at you)
09:42:13 <killy9999> mhm
09:42:45 <killy9999> I'm having problems with DiffTime
09:43:39 <killy9999> with converting it to Int
09:43:50 <dmwit> Use the Ratio instance of Hashable.
09:43:57 <dmwit> hash diff = hash (toRational diff)
09:44:06 <dmwit> (which I did suggest above)
09:44:58 * hackagebot hsql-odbc 1.8.2 - A Haskell Interface to ODBC.  http://hackage.haskell.org/package/hsql-odbc-1.8.2 (NickRudnick)
09:45:00 * hackagebot hsql-postgresql 1.8.2 - A Haskell Interface to PostgreSQL via the PQ library.  http://hackage.haskell.org/package/hsql-postgresql-1.8.2 (NickRudnick)
09:46:49 <kartoffelbrei> killy99: isn't DiffTime an instance of Num ? if so you could use toIntegral and fromIntegral
09:48:08 <hpaste> killy9999 pasted ‚ÄúWorking code‚Äù at http://hpaste.org/66295
09:51:01 <killy9999> I've noticed that in Haskell there is a convention to place commas at the beginning of the line, instead of placing them at the end
09:51:15 <killy9999> is there a particular reason to do it or is it a matter of habit?
09:52:21 <parcs`> you can usually vertically align the commas with another symbol, like =, [ or {
09:52:44 <parcs`> some people think code looks better that way
09:52:58 <ykm> or even place ; at end of lines
09:54:17 <kowalej> Hey I'm trying to understand currying, could someone please give me an example of a function with type :: (Int -> Int) -> (Int -> Int)
09:54:58 * hackagebot hsql-sqlite3 1.8.2 - SQLite3 driver for HSQL.  http://hackage.haskell.org/package/hsql-sqlite3-1.8.2 (NickRudnick)
09:55:04 <killy9999> this would be a function that takes a function and returns a function
09:55:08 <hpc> @djinn (a -> b) -> (a -> b)
09:55:09 <lambdabot> f a = a
09:55:12 <hpc> voila!
09:55:44 <killy9999> kowalej: and I think the example you've given is not the best one to understand currying
09:57:15 <kowalej> killy9999: true, it's just an example from a book after the currying section
09:57:24 <killy9999> which book?
09:57:55 <kowalej> killy9999: Intro. to Functional Programming 1st edition - Richard Bird, Philip Wadler
09:58:11 <killy9999> nope,haven't seen it
09:58:18 <kowalej> killy9999: very old book
09:58:23 <killy9999> mhm
09:58:45 <kowalej> killy9999: uses Miranda which I guess was like a predecessor for Haskell
09:58:56 * killy9999 finally got his hands on Real World Haskell and Programming in Haskell by Hutton
09:59:08 <killy9999> wow, that must be old
09:59:32 <kowalej> 1988 lol
09:59:44 <kowalej> it's out of print
09:59:46 <ski> kowalej : `\f x -> - f (- x)' ?
10:00:38 <kowalej> ski: yes that works
10:01:07 <ski> > let kowalej :: (Int -> Int) -> (Int -> Int); kowalej = \f x -> - f (- x) in map kowalej [-9,-6,-3,0,3,6,9]
10:01:08 <lambdabot>   *Exception: showList: No overloading for function
10:01:12 <kowalej> also func x y = y
10:01:13 <ski> er
10:01:24 <ski> > let kowalej :: (Int -> Int) -> (Int -> Int); kowalej = \f x -> - f (- x) in map (kowalej (\x -> x + 10)) [-9,-6,-3,0,3,6,9]
10:01:25 <lambdabot>   [-19,-16,-13,-10,-7,-4,-1]
10:01:56 <ski> that's also an example of currying
10:02:02 <kowalej> ski: cool that's a good example
10:03:03 <killy9999> ski, how long have you been programming in Haskell?
10:03:17 <ski> killy9999 : um, since 1999 or something like that
10:03:43 <ski> (why ?)
10:04:01 <killy9999> I'm wondering how long it takes to get proficient
10:04:12 <killy9999> I started learning haskell like 6-7 weeks ago or so
10:04:43 <ski> well, it will probably take longer than learning an imperative language (assuming you have already learnt that paradigm)
10:04:48 <killy9999> and I must say I'm a bit frustrated
10:04:59 * hackagebot hsql-mysql 1.8.2 - MySQL driver for HSQL.  http://hackage.haskell.org/package/hsql-mysql-1.8.2 (NickRudnick)
10:05:12 <ski> learning a different programming paradigm (like functional programming) will be a little like learning to program all over again
10:05:17 <killy9999> yes, I've been programing since I was 12 years old, so that gives about 16 years of experience :)
10:05:23 <sm> killy9999: for many of us it takes several attempts. Brain needs some time off to reconfigure
10:05:26 <kowalej> killy9999: you should check out this book, it shows you the fundamentals
10:05:31 <ski> killy9999 : don't give up, it will come
10:05:37 <killy9999> I'm not giving up
10:05:45 <ski> killy9999 : i started when i was 6.5 years old :)
10:05:52 <kowalej> killy9999: it's really been helping me, starting at the basics
10:05:53 <killy9999> ski: nice :)
10:06:00 <ski> (not haskell, of course)
10:06:04 <killy9999> well, it's strange
10:06:19 <killy9999> I seem to understand the functional programming
10:06:32 <killy9999> of course, there are lots of thing I don't know or that surprise me
10:07:01 <killy9999> but when I'm faced with the task of writing whole program - not just a function that I'll call from ghci - I feel helpless...
10:07:42 <killy9999> recently I've read The Little Schemer. It's not about Haskell but it helped me to learn thinking recursively
10:07:42 <ski> well, it's common to write the program piecemeal, trying out the most recently written functions in the interactor before continuing
10:08:04 <ski> yeah, getting a good grip on recursion is important
10:08:08 <killy9999> yes, but I'm having problems construting a program as a whole
10:08:18 <killy9999> I mean figuring out the whole workflow
10:08:18 <ski> (and Scheme is a nice little language)
10:11:07 <killy9999> so, right now I'm reading LYAH and today I read the first chapter of RHW
10:11:19 <killy9999> hope this will help me better grip on Haskell
10:16:42 <roaldfre> Is Glasgow Parallel Haskell (GpH) still alive?
10:20:04 <BMeph> killy9999: As a perspective, imagine you've driven automatic transmission cars for fifteen years, and are now looking into driving a semi.
10:21:38 <BMeph> killy9999: It's still "driving," but a lot of what you've done before simply doesn't apply.
10:23:52 <killy9999> BMeph: yeah, I just hope I will be able to get a reasonable grip on Haskell in a year or two
10:24:18 <shergill> killy9999: your first functional language?
10:24:46 <killy9999> yes and no
10:25:15 <killy9999> I tried a bit of Prolog, Scala, Scheme and Erlang before diving into Haskell
10:25:29 <killy9999> so theoreticaly it's not the first one
10:25:58 <ski> Prolog is a logic programming language, though a lot of the ideas carry over
10:25:59 <killy9999> but I spend only about a week or so learning other of these languages, trying to see what the have to offer
10:26:11 <killy9999> ski: that's why I've mentioned it
10:26:30 <killy9999> I mean a week for each language
10:26:43 <ski> (specifically, pattern-matching, recursion, immutable variables)
10:26:56 <killy9999> I've been reading 7 langiages in 7 weeks, only I switched Clojure with Scheme :)
10:27:56 <killy9999> Prolog ans Scheme were extremely fun :)
10:28:02 <shergill> killy9999: ok that should make the transition easier. the major thing haskell adds is purity and lazy evaluation
10:28:14 <shergill> heh they are :)
10:28:59 <ski> .. and advanced types
10:29:07 <killy9999> I didn't like Scala though
10:29:14 <Twey> Hmn, I've recently installed base-4.5 as part of a routine OS update and it seems nothing is compatible with it yet
10:29:22 <Twey> cabal: cannot configure xhtml-3000.2.0.4. It requires base >=4.0 && <4.5
10:29:52 <killy9999> ski: I think types are the hardest part to grasp
10:30:00 <byorgey> Twey: xhtml-3000.2.0.5 is compatible with base 4.5.
10:30:04 <killy9999> but on the other hand I think they offer the most benefits
10:30:12 <byorgey> Twey: you need to figure out what is requiring xhtml-3000.2.0.4.
10:30:13 <ski> killy9999 : could well be
10:30:18 <kartoffelbrei> killy9999: but the most fun (at least for me)
10:30:22 <Twey> byorgey: Pandoc
10:30:33 <shergill> scala doesn't have types?
10:30:47 <shergill> or HM style types?
10:30:55 <byorgey> Twey: what version of pandoc?
10:31:19 <Twey> Ah, I think I forgot to ‚Äòcabal update‚Äô
10:31:21 * Twey tries it.
10:31:25 <byorgey> Twey: that would help =)
10:31:39 <byorgey> the lates pandoc supposedly builds fine under ghc 7.4
10:31:41 <byorgey> *latest
10:33:03 <byorgey> it would be cool if 'cabal update' ran periodically in the background, but in such a way that it aborts if it notices you trying to use the package database
10:33:27 <byorgey> just sticking it in a cron job wouldn't work very well.
10:33:47 <geekosaur> if cabal-install doesn't have a locking mechanism, it's buggy
10:33:57 <geekosaur> (if it does, then cron should work fine)
10:35:37 <monochrom> I use "cabal install --dry-run" first anyway. I get notification in time.
10:37:24 <byorgey> geekosaur: it does have a locking mechanism.  That's exactly why it wouldn't work very well.
10:37:46 <byorgey> geekosaur: because sometimes you would try to do 'cabal install foo' or whatever and it would say "sorry, the database is locked"
10:37:57 <byorgey> I just mean it would be annoying.
10:42:15 <nart> ciao :)
10:43:42 <geekosaur> byorgey, this is why you cron it to run at times when you're unlikely to be awake.  (admittedly for some of us that means cron might be the wrong tool...)  also, a simple interactivity heuristic and timestamp would avoid a number of such collisions
10:44:11 <shergill> byorgey: have the cron command in a shell wrapper. alias the cabal install command to kill the shell wrapper in addition
10:45:28 <byorgey> ah, both good ideas
10:45:41 <byorgey> hi nart
10:46:29 <hpaste> gob pasted ‚Äúgobs program‚Äù at http://hpaste.org/66297
10:49:56 <byorgey> gob seems to have misspelled "penis".
10:50:51 <djh_> it's a reference to this..http://www.youtube.com/watch?v=JbnjusltDHk
10:51:11 <kartoffelbrei> maybe he meant "pen us", which doesn't make sense either
10:51:22 <byorgey> djh_: ah, thanks =)
10:51:26 <parcs`> djh_: haha
10:52:36 <kartoffelbrei> djh_: lol
10:53:17 <monochrom> hahaha the comments have it implemented in many languages!
10:53:23 <Yarou> lol
10:54:28 <monochrom> oh hi, how may haskell help a korn shell?
10:54:31 <djh_> i highly recommend "arrested development" as a show to watch
10:56:02 <parcs`> this should be the new hello world
10:57:28 <Sfate> really.. lol)
11:01:24 <NemesisD> anyone have any ideas for compiling in a way thats most likely to work? I've got an app that uses libraries that depend on system libs. my dev env is x64 arch linux. my target env currently is 32bit centos (read: more out of date libraries that might be stored in different locations)
11:01:41 <NemesisD> is there a way to link the executable so it doesn't rely on the OS's libraries?
11:04:18 <otters> is there an IO action that is the equivalent of "sleep"?
11:04:48 <Saizan> there's threadDelay which is close
11:05:04 <geekosaur> (in Control.Concurrent)
11:05:11 <otters> yep, that's the one
11:05:12 <otters> thanks
11:05:13 <geekosaur> note that it's in microseconds...
11:05:22 <otters> okay
11:05:32 <NemesisD> note that it only takes an int :/
11:05:39 <otters> yeah, it's in microseconds
11:05:44 <otters> not sure what else you'd need
11:05:50 <geekosaur> (simgle most common error:  assuming it's seconds or milliseonds, wondering why it "doesn't work" because 500us is really not very long)\
11:06:45 <NemesisD> there's a library unbounded-delays that exports "delay" which takes Integer
11:08:41 <NemesisD> is dynamic linking what i want?
11:10:51 <mk> what is the type of (not)?
11:10:59 <otters> :t not
11:10:59 <lambdabot> Bool -> Bool
11:11:22 <mk> does that mean that it is Bool, or is it properly Bool->Bool?
11:11:35 <dmwit> WTF?
11:11:44 <dmwit> Why would "Bool -> Bool" not mean "Bool -> Bool"?
11:11:55 <monochrom> Bool -> Bool
11:12:20 <geekosaur> NemesisD, I suspect what you want is to use ghc -v to see what linker command line it builds, then do the final link yourself with a version of that modified to point at the 32bit libs
11:12:25 <monochrom> computer answers don't have subtexts for you to guess, don't worry :)
11:12:35 <mk> dmwit: because the left side might simply be irrelevant annotation, while the right side tells you precisely what the value of the function is (or something like that)
11:13:01 <mk> I mean: the type of the function
11:13:02 <geekosaur> dynamic linking would only work if the runtime libs are sufficiently compatible with the compile-time libs, which is unlikely in the case of 32 vs 64 bit
11:13:09 <monochrom> oh, sometimes it's the right side that's irrelevant
11:13:09 <dmwit> I have no idea what that means.
11:13:18 <zomg> mk: do you actually know what haskell type signatures mean? :P
11:13:28 <mk> zomg: do you? :P
11:13:32 <geekosaur> mk, you can get away with that kind of thinking in C but not Haskell, I think.  (heck, even C++ knows better)
11:13:43 <zomg> mk: somewhat. What you said just sounded pretty confusing..
11:13:43 <zomg> =)
11:14:12 <NemesisD> geekosaur: i'm fine with setting up a virtual machine that's 32 bit, i just dont want to try to set up a CentOS box in any shape or fashion
11:14:15 <geekosaur> mk, also, there is a distinction there:  expression type vs. result type
11:14:19 <monochrom> every part has an equal chance of being irrelevant, so you are not going anywhere
11:14:55 <mk> geekosaur: yeah, I suspect that... but I'm a bit confused, because once a function is evaluated, who cares what the stuff on the left is
11:14:58 <mk> zomg: :)
11:15:27 <mk> monochrom: what do you mean?
11:15:29 <monochrom> be careful of the wording "a function is evaluated". it's ambiguous
11:15:30 <geekosaur> mk, but you can't evaluate it without the stuff on theleft
11:15:56 <monochrom> to a traditional mathematician, it means evaluating "not False" or "not True"
11:16:05 <NemesisD> geekosaur: excuse my ignorance on the matter, but is it impossible to bundle the foreign libraries that would be linked against into the binary itself
11:16:06 <shergill> mk: we _apply_ functions
11:16:22 <geekosaur> NemesisD, if you;re trying to produce CentOS from Arch, you are probably not going to get very far or very reliable.
11:16:29 <monochrom> to a lambda calculist, it means evaluated "not", no adding True or False or any parameter. just "not"
11:16:41 <monochrom> s/evaluated/evaluating/
11:17:44 <NemesisD> geekosaur: i was planning on compiling on 32 bit debian squeeze
11:17:54 <geekosaur> NemesisD, Linux doesn't have any real concept of bundling; there are ways to do it but they are painful and fragile and you do not want to go there if at all possible
11:18:02 <geekosaur> that's not a whole lot better
11:18:14 <monochrom> indeed, "case 4 of 0 -> (\x -> x + 1); _ -> (\x -> x - 1)" is a function, and you have to evaluate it before you get the simpler (\x -> x - 1). that's "evaluating a function" for a lambda calculist
11:18:17 <mk> it's a bit confusing how the types of functions are just composites
11:18:47 <geekosaur> really I'd just spin a CentOS VM.  I'm not real fond of RH/Fedora/CentOS either, but they're less annoyimng than cross-distribution development
11:18:50 <NemesisD> geekosaur: all of this is painful, that I have to exactly replicate my target environment to produce an executable that runs on it
11:19:02 <geekosaur> NemesisD, welcome to Linux :)
11:19:19 <mk> are functions like lists?
11:19:21 <BMeph> mk: Tell us, please, what your idea of a function is? :)
11:19:52 <mk> BMeph: it's a mapping of typed values to other typed values
11:20:00 <geekosaur> mk, on a theoretical level they are often treated as sets
11:20:17 <mk> geekagent: of pairs?
11:20:29 <NemesisD> geekosaur, might be more worth it to just spin up a small debian instance in production and run it on there. i did try at one point to compile on a centos box with the same version as production
11:20:37 <Rotaerk> in the mathematical context, a function is a map from a set to another set... in the context of programming that concept is called a "pure function"
11:20:45 <Rotaerk> and "function" has more generalized meaning
11:20:54 <NemesisD> the long and short of it was that the system packages are so far behind that i couldn't get a modern version of ghc to work
11:20:55 <geekosaur> ^^ that, actually
11:21:38 <mk> polymorphic functions are impure?
11:21:44 <smop> mk: how are you
11:21:51 <geekosaur> NemesisD, I hear you there, but Debian stable has the second oldest GHC version I've encountered "current" in the wild.  (The oldest is from MacPorts)
11:22:00 <NemesisD> the state of most distros'package repositories is revolting.
11:22:17 <NemesisD> geekosaur: i was using debian squeeze and was able to get ghc 7 on it
11:22:35 <mk> smop: I'm well, how are you? Have we met before?
11:22:53 <geekosaur> I was able to as well, but it's not part of the standard repos
11:23:15 <NemesisD> that's fine with me, it was relatively painless to install
11:23:59 <NemesisD> this sort of thing makes me pretty hesitant to write haskell for production honestly. i now have to have a dedicated box i have to pay for just so it has the right libs for my code
11:24:35 <NemesisD> say what you will about dynamic languages, but the target OS/arch is almost never a factor so long as it isn't windows
11:24:36 <mk> are functions like lists, where the types that they take/yield are like the types that lists use?
11:24:46 <smop> mk: must be the wrong mk
11:25:19 <monochrom> no, functions are not like that
11:25:29 <shergill> NemesisD: just run your code with runhaskell
11:25:37 <mk> smop: there's also MK`, who is helpful and hangs out in linux or ubuntu :)
11:25:40 <NemesisD> in production.. :|
11:26:21 <mk> monochrom: but they depend on the types of other things for their existence, it seems
11:26:43 <NemesisD> and if i could get a sane version of GHC/required libraries set up in my production CentOS box, i might as well compile it there rather than run with runhaskell
11:26:50 <shergill> well if you can afford to use dynamic languages in production, then i don't see why you can't use ghci. otoh, if you can't, then your comparison to dynamic languages is kinda unfair =/. a comparison to jvm would perhaps be more at point
11:27:08 <monochrom> sure, doesn't mean "like lists"
11:28:15 <shergill> mk: the reason you see that common aspect is because lists are nothing but the result of application of Cons
11:28:16 <NemesisD> shergill: it was more of a tradeoff. speed/safety vs ease of deployment
11:28:19 <Sfate> damn.. haskell is awesome =_)
11:28:48 <mk> monochrom: well I don't mean "exactly like" - I think I'm just confused about composite types
11:29:43 <monochrom> are you confused about composite sentences in natural languages? like generalizing from "noun verb noun" to "that (noun verb noun) verb noun"
11:29:43 <mk> shergill: so... lists etc. depend on functions?
11:30:10 <monochrom> i.e., the first noun can be "that (noun verb noun)"
11:31:28 <mk> monochrom: like, uh, "that (bill kicked the ball) ran to the store"? Slightly confused, yes...
11:31:30 <shergill> mk: list is a value. values are constructed using ... a constructor. in the case of a list the constructor is Cons.
11:32:11 <mk> shergill: are literals like 'c' constructed?
11:32:40 <monochrom> noun verb noun -> that (noun verb noun) verb that (noun verb noun) -> that you don't get types does not mean that you don't get natural language sentences
11:33:54 <monochrom> but Bool -> Bool is still at the same level as "noun verb noun" so I don't think it's problematic yet
11:34:10 <shergill> mk: i see them as having an implicit constructor. someone can correct me if my view is misguided
11:35:33 <nomism> hey, i am trying to learn haskell. how can i do an elementwiese addition of two lists with the same length? i am aware that this could likely be solved by takeing more time rtfm...
11:35:38 <mk> monochrom: well... that's a bit confusing, because ran(bob the-store) is verb noun noun... -> isn't a verb
11:36:03 <byorgey> nomism: zipWith (+)
11:36:27 <geekosaur> mk, the function is the verb, (->) represents the function... it's a verb
11:36:54 <mk> geekagent: err, the function is (Bool -> Bool). It's not (->)...
11:37:07 <monochrom> if you say -> isn't a verb, that's fine, not arguing. the pattern is "X Y X"
11:37:18 <geekosaur> mk, trees, forest
11:37:32 <mk> geekagent: help me out, I don't see it yet :)
11:37:34 <geekosaur> maybe that's your problem; you're trying to micromanage your types and it works about as well as it does in business
11:37:47 <geekosaur> (also, check your nick completion)
11:37:55 <mk> oops :)
11:38:12 <geekosaur> (->) is not a function; it is the concept of function-ness
11:38:15 <mk> what do you mean by type micromanagement?
11:38:31 <nomism> byorgey: thanks!
11:38:42 <geekosaur> you need to step out a level perhaps to see how it is the notion of function-ness, not the individual function itself
11:38:57 <mk> geekagent: I thought -> is a bit of notation that we use when describing the types of functions...
11:39:11 <geekosaur> and?
11:39:39 <monochrom> ok, Bool->Bool is a function's type, agree or disagree?
11:39:44 <geekosaur> you may have just made my point.  it's a bit of notation that represents an important concept, not just a bit of noise
11:39:47 <kartoffelbrei> nomism: note that zipWith (+) doesn't check the list length ...
11:40:15 <mk> monochrom: "confused", or "don't disagree"
11:41:01 <mk> geekosaur: I know what a function is, I think, apart from the -> notation - it's a mapping of typed values to other typed values
11:41:04 <monochrom> ok, what is confusing? what is the conflict of information?
11:41:41 <monochrom> "Bool->Bool is a function's type" conflicts with _______ --- fill in the blanks?
11:42:22 <geekosaur> why is it apart from?
11:42:35 <geekosaur> -> can roughly be read as "maps to"
11:42:54 <mk> monochrom: because ... types usually depend on nothing, and then values depend on types. But function types are... nothing except specifications of what types the function "hangs out with", which seems not that different from [Int] (a list that hangs out with Ints) - and we don't call that a type
11:43:18 <mk> geekosaur: I don't think we disagree
11:43:20 <monochrom> [Int] is a type, too
11:43:21 <geekosaur> sometimes we do, actually
11:43:46 <geekosaur> because [Int] can be represented as function application (specifically, the Cons function)
11:43:58 <dmwit> Perhaps this is just a terminology thing, but values don't really depend on types. Perhaps "inhabit" is a better verb for that.
11:44:04 <dmwit> And we do call [Int] a type. =)
11:44:14 <mk> ok, hold up - what's [] without the Int?
11:44:17 <mk> is it a type?
11:44:28 <dmwit> You could call it a type with kind * -> *.
11:44:29 <monochrom> it is a "type constructor".
11:44:34 <geekosaur> unsaturated type, or type constructpr
11:44:42 <geekosaur> hm
11:44:44 <dmwit> "type constructor" is good if you want to distinguish it from a concrete type.
11:44:50 <monochrom> the Haskell Report calls it both a "type constructor" and a "type", actually
11:44:57 <geekosaur> maybe looking at (->) e is a good idea?
11:44:59 <mk> and functions are value constructors?
11:45:14 <geekosaur> (which uses the function arrow as a type constructor)
11:45:19 <dmwit> Functions are values.
11:45:21 <monochrom> both value constructors and values
11:45:36 <dmwit> Well, lambdas are values, I guess, if we're being precise.
11:45:50 <monochrom> "(\x -> x+1)" is a value. "(\x -> x+1) 5" is a value, too
11:45:52 <mk> (I don't see why type constructors can't be values, too, but alright)
11:45:54 <dmwit> "value" is a somewhat tricky term; it has a technical meaning and an informal meaning that don't really agree.
11:46:00 <monochrom> "not" is a value. "not True" is a value.
11:46:13 <mk> I understand that functions are values
11:46:44 <monochrom> type constructors are welcome to be values in another language
11:47:13 <mk> what I'm confused about is that the types of functions and lists are qualitatively different (and more similar to each other) than the types of typical values
11:47:19 <geekosaur> they are indeed values in languages such as Omega.  Haskell happens to restrict the scope of values
11:48:12 <BMeph> shapr!
11:48:26 <monochrom> sure, ground types (Int, Bool, Char) vs composing more complicated types
11:48:39 <mk> so, and this might be a pedantic worry, but this makes me think I don't understand types in some way
11:49:06 <monochrom> you could have said the same to expressions too. ground expressions (0, True, 'x') vs more complicated expressions
11:49:18 <geekosaur> mk, a function arrow can be treated as a type constructor.  ((->) e) is a type constructor describing functions from a type "e" to something unspecified; it's the basis of the Reader monad, and can be read naturally in a way quite similar to the "cons" operation on lists
11:49:27 <mk> monochrom: atomic vs composite, yeah?
11:49:44 <monochrom> except in the case of expressions, we're way past that debate after Fortran in the 1960s
11:50:23 <mk> geekosaur: hmm - is this like [] is a type constructor?
11:50:24 <monochrom> but I assure that before Fortran, in the 50s, some people did say "(x + y)*z is so confusing, why would you allow it in a programming language"
11:51:08 <monochrom> they only allowed "three-address instructions", i.e., "variable := variable op variable". no further compound expressions
11:51:41 <mk> monochrom: they were probably right for their time - it takes a while to get good models for thinking about that stuff worked out
11:52:09 <monochrom> Fortran is called Fortran because it does "formula translation". you write "x := sqrt(x*y)/(2-z+k)" and the computer tranlsates that to three-address instructions for you
11:52:46 <monochrom> so, it will be the year 2022 when you will do the same to type expressions, yes?
11:54:16 <mk> let's hope it doesn't take that long for complicated types to be that routine!
11:54:50 <shapr> BMeph: oh hai!
11:54:53 <shapr> BMeph: How's code?
11:56:01 <BMeph> shapr: Code is like my wife; it's happy for reasons I only sometimes understand. ;)
11:56:18 <mk> can the type Bool->Bool be given a name like [Char] is called String?
11:56:33 <monochrom> yes. type Hi = Bool->Bool
11:56:41 <edwardk> type BB = Bool -> Bool
11:56:52 <kartoffelbrei> mk: sure: type BoolFunc = Bool -> Bool
11:57:20 <mk> interesting
11:57:47 <mk> I'll think about this more, though more makes sense than it did before - thanks
12:01:24 <geekosaur> mk, so where I was going with that comparison is that a type can be thought of as an "embedded function".  for lists, that function is "cons".  so the function arrow is the more primitive operation, and other types can be unpacked to function arrows; they get fairly complex (see the Fortran example), which is why we prefer to bundle them up as types instead.  (or compare working with strings in C to with other languages)
12:04:33 <mk> geekosaur: what does the "embedded" part mean?
12:06:18 <Rc43> Hi, guys.
12:06:19 <lambdabot> Rc43: You have 1 new message. '/msg lambdabot @messages' to read it.
12:07:04 <geekosaur> mk:  built into the type in some sense.  there's a more formal notion
12:08:29 <mk> a type is like a function built into the type?
12:08:32 <Rc43> What to do with orphaned instances? Suppose we have two different libs, one provides some cool type X, other some cool type class A. Suddenly programmer understands, that X is A and wants to implement its instance.
12:08:37 <Rc43> But it is orphaned instance.
12:08:39 <geekosaur> so, a list is defined by two things:  an empty list [], and list construction ("cons") (x:xs).  any value of a list type can therefore be treated as if there were no list type, but instead just repeated applications of those two aspects of the definition of list
12:09:02 <dmwit> Rc43: Send a patch to one of the two libraries, or just deal with the orphan-ness.
12:09:22 <Rc43> dmwit, warning is annoying
12:09:37 <dmwit> -fno-warn-orphan-instances or whatever
12:09:51 <Rc43> dmwit, patch may be strange for both libs; it can be specific for your domain.
12:09:58 <Rc43> ooh
12:10:00 <Rc43> thanks
12:11:03 <mk> geekosaur: that's an interesting way of thinking of it... a bit like how integers can be defined via 0 and increment
12:11:38 <geekosaur> it is exactly like that, actually.
12:13:48 <mk> geekosaur: for a list type, it's a bit.. different? because when you do 1:[] the list type is inferred... I think you're talking about an operation such that type+[] = [type]?
12:14:20 <geekosaur> it's only different insofar as the function involved is different
12:15:17 <geekosaur> they're not only both creating types in terms of functions, they're both doing it in the same way (base case and single constructor), a pattern that is so common and fundamental that it has its own name:  monoid
12:15:42 <danharaj> Does anyone know why GHC has promotion of data to kinds instead of adding Kind declarations?
12:16:48 <mk> thogh 1:[] isn't creating a new type, the type [Int] has been created, and : is creating a new value of type [Int]
12:16:51 <dmwit> danharaj: Dunno for sure, but why have two syntaxes when you can have one?
12:17:02 <danharaj> dmwit: Because Data and Kinds are different :D
12:17:18 <kartoffelbrei> danharaj: -XDataKinds ?
12:17:31 <danharaj> kartoffelbrei: yes.
12:18:29 <geekosaur> mk, you're comparing the types of Peano numbers to those of lists?  yes, and that points up a specific shortcoming of Haskell's type system, and more generally of the typed lambda calculus.  (which, yes, is diving in pretty deep...)
12:19:21 <geekosaur> in a certain sense, imposing types on things adds restrictions that you then sometimes need to come up with ways to get around, which is why type systems tend to become fairly complex
12:19:49 <hpc> danharaj: it's to be as close to "dependent types" as possible
12:19:55 <hpc> (without actually being dependent types)
12:20:02 * hackagebot MemoTrie 0.4.11 - Trie-based memo functions  http://hackage.haskell.org/package/MemoTrie-0.4.11 (ConalElliott)
12:20:13 <geekosaur> on the flip side, the untyped lambda calculus is simpler but you have to deal with endless repetition of the functions that we call "types"
12:20:36 <newsham> how so endless repetition?
12:21:16 <newsham> all expressions in typed system are also expressions in untyped, no?
12:21:30 <geekosaur> newsham, I'm exaggerating a bit.  the reason types are helpful, relative to the untyped lambda calculus, is specifically that they represent extremely common patterns
12:21:40 <mk> geekosaur: hmm - in the last I just meant that in 1:[], the type [Int] gets "created" implicitly (and might have already been created), and 1:[] is just a function nList->n->nList
12:21:56 <danharaj> hpc: Ah. Hm. The namespace issue is a bit klunky though. 'Constructors are ugly.
12:22:36 <hpc> right now you're better off with agda --no-termination-check, plus haskell imports
12:22:39 <hpc> imo
12:22:44 <geekosaur> mk, yes.  Peano numbers do the same thing, though:  (S Z) is a new type, compared to Z
12:22:50 <reinoud> @hoogle !!
12:22:50 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:22:50 <lambdabot> Data.List (!!) :: [a] -> Int -> a
12:22:50 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
12:23:00 <danharaj> hpc: How does Agda compilation work? Does it emit Haskell code that gets optimized by GHC?
12:23:17 <newsham> the reason types are helpful is, as pierce said it, "attempting to prove *any* nontrivial theorem about your program will expose lots of bugs"
12:23:17 <hpc> danharaj: yes, except not
12:23:20 <mk> geekosaur: what are S and Z?
12:23:22 <clsmith> hey. i'm a little confused by the way that functor in haskell is a type class, so a list or a tree can be "a functor", and yet in category theory a functor is a (homo)morphism, not a category. what's the relationship between data structures and functions, categories and morphisms, in this sense?
12:23:23 <hpc> it uses haskell as an untyped core language
12:23:28 <newsham> [*] http://www.cis.upenn.edu/~bcpierce/papers/harmful-mfps.pdf slide 14
12:23:43 <danharaj> o.O
12:23:45 <hpc> which basically means it generates haskell with ugly names, then throws unsafeCoerce around everything
12:23:47 <geekosaur> [31 19:12] <mk> geekosaur: that's an interesting way of thinking of it... a bit like how integers can be defined via 0 and increment
12:23:57 <danharaj> grosss.
12:24:02 <hpc> there's better backends apparently, but that's the default
12:24:02 <geekosaur> Z is 0 and S is increment; this is the usual ways of represnting peano numbers in Haskell
12:24:23 <newsham> "zero" and "successor" easier to remember :)
12:24:29 <geekosaur> yes
12:24:39 <hpc> you can tell it to use existing haskell data types with pragmas
12:24:54 <hpc> which gets you some speed back
12:25:31 <narens> Hello.
12:25:48 <clsmith> also (completely unrelated to my question just then), what's the relationship between peano numbers and church numbers? is the latter just an 'implementation' of the former? :p
12:26:04 <narens> Does anyone know why ghc cannot find the System.Event module?
12:26:15 <hpc> @hoogle System.Event
12:26:16 <lambdabot> System.Event data Event
12:26:16 <lambdabot> System.Event data EventManager
12:26:16 <lambdabot> System.Event module System.Event
12:26:20 <mk> geekosaur: it doesn't seem like succ 0 yields a new type, just a new value. Or do you mean that there is no such thing as a value there - just leave it unevaluated, and the new "value" might as well just be (succ 0)?
12:26:31 <geekosaur> the distunction comes in the next step:  (x:(y:[])) is the same type as (y:[]) in Haksell, but Haskell's type system does not permit (S (S Z)) to be the same type as (S Z)
12:26:38 <newsham> clsmith: its a morphism that maps types to other types (ie. its in "the type system")
12:26:46 <monochrom> perhaps peano number is an implementation of church number
12:26:51 <newsham> clsmith: haskell's got the two languages, the haskell language and the haskell type language
12:27:14 <narens> hpc: could it be a conflict between the base package and haskell2010 package?
12:27:20 <monochrom> ok, CPSize peano number, get church number; defunctionalize church number, get peano number
12:27:32 <geekosaur> mk, that is because we hide it inside the type, because it's easier for people to work with that way
12:27:47 <monochrom> both CPSize and defunctionalize are considered implementation techniques
12:27:48 <newsham> mk: (succ 0) is haskell language.  (Succ Zero) is haskell type language.
12:28:15 <newsham> succ 0 :: Int,    Succ Zero :: Kind ?
12:28:24 <hpc> narens: do you have both packages installed?
12:28:43 <narens> hpc: yea, i don't like the way arch linux does that when i install ghc
12:28:53 <narens> hpc: i don't even know what the haskell2010 package does
12:29:06 <hpc> er actually, hoogle doesn't even say haskell2010 has that module
12:29:10 <geekosaur> mk, but we can unpack that and then you can see that in some sense a new "type" is generated.  we just have the ability to hide that under a type we call Int, just as we can hide the new type generated by (x:[]) under a type [x]
12:29:32 <narens> hpc: yea... i don't know who makes that. I guess i'll just remove it. I prefer installing everything through cabal
12:29:39 <clsmith> newsham: see, i've been seeing in my head a functor as a data structure which has holes, which hold values, and you can apply a function to values in those holes by mapping over it, leaving the structure intact. so my understanding was that a functor is something over which you can extend a given morphism to a homomorphism, using map.
12:29:44 <clsmith> how much of that is wrong?
12:29:45 <hpc> narens: oh, looks like it's from an older version of base
12:30:04 <hpc> narens: what version of base do you have? (ghc-pkg list | grep base)
12:30:23 <narens> hpc: 4.5.0.0
12:30:46 <newsham> clsmith: how about (IO x) ?
12:31:25 <reinoud> @help hoogle
12:31:25 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
12:31:27 <newsham> ?type fmap head (readFile "foo.txt")
12:31:28 <lambdabot> IO Char
12:31:39 <reinoud> @help haskellbot
12:31:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:31:51 <reinoud> @help list
12:31:52 <lambdabot> list [module|command]
12:31:52 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
12:32:41 <newsham> fmap just lifts an (a -> b) to some (F a -> F b)
12:32:43 <mk> geekosaur: so how does that work out for functions? (1:[]):(1:[]):(->) yields [Int]->[Int]?
12:32:44 <tomprince> clsmith: That is true of many functors, but not all.
12:32:48 <clsmith> newsham: i've been seeing that as a kind of 'todo' list, and each thing you 'do' can contain other things you 'do', which all join up into one big todo list by way of it being a monad.
12:32:49 <hpc> narens: yeah, it's not there anymore; it vanished after 4.3.1.0
12:32:51 <newsham> ie: String -> Char    to   IO String -> IO Char
12:33:06 <geekosaur> mk, I'm not sure what you're asking there
12:33:25 <narens> hpc: I just unregistered the haskell2010 package and ghci syas "Could not find module System.Event. Perhaps you meant System.Exit (from base)'
12:33:27 <hpc> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/System-Event.html
12:33:48 <geekosaur> "(1:[]):(1:[]):(->)" is not meaningful
12:34:02 <mk> geekosaur: how the creation of new function types work, if the creation of new other-types works via a weird use of :
12:34:10 <narens> hpc: so that module is no more? has it moved to hackage?
12:34:12 <mk> does*
12:34:26 <geekosaur> mk, : is not the general operation
12:34:30 <clsmith> this is the point when you tell me everything i thought i knew about monads is wrong ;)
12:34:52 <hpc> narens: the module is no more; im not sure if the functionality is moved or removed though :(
12:34:53 <geekosaur> mk, -> is the general operation.  : is a specific version of it (that is, a function)
12:35:11 <narens> hpc: damn. it's just what i wanted.
12:35:31 <newsham> clsmith:  the analogy to cat theory (I hope I'm getting this right, cause I havent studied cat theory :) is that  fmap is the morphism from haskell type to some (F (haskell type))
12:35:43 <mk> geekosaur: if -> exists before everything, how can I get the first numbers, and then a list of type [Int] ?
12:35:45 <geekosaur> in fact, if I reverse those... (1:[]) -> (1:[]) is [Int] -> [Int]
12:36:06 <hpc> narens: you can accomplish a similar API yourself with threads
12:36:08 <clsmith> newsham: but what is F in that? isn't F a functor, and doesn't that mean that it itself is a morphism?
12:36:20 <geekosaur> instead of your (1:[]) : (1:[])
12:36:36 <dmwit> newsham: (Basically right. Only quibble is that a "morphism" in Hask is a function, not a functor.)
12:36:38 <newsham> F are the various functor instances like IO, Maybe, List, Tree, ..
12:36:48 <dmwit> clsmith: Functors have two pieces: a type-level mapping (F) and a value-level mapping (fmap).
12:36:56 <hpc> narens: don't be afraid of making lots and lots and lots of forkIO threads; the GHC runtime is good at managing them :P
12:37:12 <narens> hpc: hey! it looks like its called GHC.Event now!
12:37:18 <dmwit> clsmith: Categorically, functors have two mappings, one for objects and one for arrows.
12:37:20 <hpc> narens: oh, neat
12:37:28 <hpc> that's definitely a better place for it
12:37:31 <hpc> have fun!
12:37:34 <narens> hpc: danke
12:37:57 <newsham> ?kind Maybe
12:37:58 <lambdabot> * -> *
12:38:25 <newsham> ?kind Int
12:38:26 <lambdabot> *
12:38:33 <newsham> ?kind Maybe Int
12:38:34 <lambdabot> *
12:38:41 <clsmith> dmwit: ah, i think this might be where my confusion stems from; i don't see how a haskell data structure can be a CT morphism
12:38:57 <newsham> ?type (+1)
12:38:58 <lambdabot> forall a. (Num a) => a -> a
12:39:01 <newsham> ?type fmap (+1)
12:39:02 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
12:39:04 <dmwit> clsmith: it isn't
12:39:56 <clsmith> dmwit: so how does our having a functor type class (so a list is "a functor"?) make sense in terms of morphisms?
12:39:59 <dmwit> clsmith: The category Hask has types as objects and functions as morphisms. A functor from Hask to Hask is a mapping from objects to objects (i.e. from types to types; in particular, a type constructor) and a compatible mapping from morphisms to morphisms (i.e. from functions to functions; in particular, fmap).
12:40:05 <newsham> clsmith: "Maybe" is parameterized by a type.  you apply a type to it (like Int) to get another type "Maybe Int"
12:40:57 <dmwit> There are plenty of functors from Hask to Hask that can't be represented as instances of our current Functor type class, but that's a bit beside the point, I think.
12:40:59 <newsham> thats what "?kind Maybe" above is showing with the "* -> *" its a type morphism
12:41:54 <clsmith> newsham: i (think i) get kinds
12:42:18 <dmwit> newsham: morphism is the wrong word
12:42:34 <newsham> i'm glad there are people here to correct me.
12:42:45 <newsham> whats the right word here?
12:42:53 <clsmith> dmwit: i see. well, ish.
12:43:09 <dmwit> newsham: Morphism might be fine, actually. Just in a different category. =)
12:43:13 <newsham> btw clsmith: did you see http://en.wikibooks.org/wiki/Haskell/Category_theory ?
12:43:30 <dmwit> Hask doesn't really have any terms for kinds.
12:43:42 <augur> so imma teach  friend some intro programming stuff using logo
12:43:45 <augur> anyone have suggestions?
12:44:06 <newsham> augur: why not throw em at scratch instead of logo?
12:44:24 <newsham> all the concepts minus the syntax headaches
12:44:24 <augur> newsham: does scratch have easy turtle graphics in a tile world?
12:44:35 <newsham> augur: yup
12:44:39 <augur> netlogo's syntax isnt so bad
12:44:41 <newsham> scratch.mit.edu check it out
12:44:41 <Phlogistique> newsham: Scratch is not open source though
12:45:00 <Phlogistique> (they don't want it to be used comercially)
12:45:09 <Phlogistique> (which is IMHO a shame but eh)
12:45:32 <Phlogistique> I was taught logo in primary school
12:45:34 <newsham> phlo: but still a great platform to teach non programmers what programming is like
12:45:38 <Phlogistique> it was pretty cool
12:45:56 <newsham> augur: the point being that it is impossible to make any syntax errors in scratch.
12:46:01 <Phlogistique> but at first they only taught us AVANCE, TOURNEGAUCHE and TOURNEDROITE
12:46:02 <newsham> which is a major headache for programming noobs
12:46:05 <Phlogistique> and not REPETE
12:46:18 <Phlogistique> (FORWARD, TURNLEFT, TURNRIGHT, but not REPEAT)
12:46:21 <augur> newsham: well, that might not be good for him then
12:46:40 <Phlogistique> so after doing the square, the triangle, and the octogon
12:46:48 <Phlogistique> I tried one polygon with 64 sides
12:46:53 <augur> im checking it out tho
12:46:59 <Phlogistique> and we typed the 128 lines of code
12:47:06 <Phlogistique> and then we were taught about REPETE
12:47:11 <tomprince> I wonder if processing might be a good alternative, if the licesence is a n issue.
12:47:34 <Phlogistique> tomprince: isn't Processing Java?
12:47:34 <hpc> Phlogistique: you could have made one where 60 of the sides have the same start and end points :P
12:47:38 <newsham> phlo: when i was learning machine language i wrote a program that loaded one letter into accumulator, called the output char function, then loaded the next letter into the accumulator, called putchar, ....
12:47:42 <newsham> for a whole line of text :)
12:47:48 <newsham> embarassing
12:47:51 <augur> Phlogistique: javascript
12:48:02 <Phlogistique> augur: oh
12:48:07 <clsmith> Phlogistique: have you read "lauren ipsum"? it has a nice chapter about exactly that :p
12:48:23 <Phlogistique> I actually thought of writing a simple turtle for coffeescript
12:48:41 <newsham> i have a hask turtle if you want :)
12:48:46 <Phlogistique> not sure indentation-as-syntax would be hard for newcomers
12:48:54 <newsham> http://www.thenewsh.com/~newsham/x/machine/turtle/
12:49:04 <newsham> would be really easy to make a .js turtle
12:49:07 <newsham> with html5 canvas
12:49:19 <clsmith> Phlogistique: i think indentation is more 'intuitive' than bracing
12:49:31 <Phlogistique> also one thing I thought of is that it would be nice to get a Lisp editor which draws nice color blocks instead of parens
12:49:41 <Phlogistique> In order to be intuitive for beginners
12:50:33 <Phlogistique> Doing that in the browser + getting a turtle in the mix would make a pretty nice platform for teaching programming
12:50:40 <newsham> http://www.thenewsh.com/~newsham/x/machine/turtle/square.hs
12:51:03 <newsham> phlo: mit's working on a web-based scratch.  should be done soonish
12:51:11 <newsham> unfort they're doing it in flash, not js. :(
12:51:23 <MHD0> A friend of mine is trying to install the Haskell Platform on a Macbook Pro running Lion, and it says she requires Xcode
12:51:25 <newsham> i think web-based will be a big educational win
12:51:28 <MHD0> Any way to get around that?
12:51:45 <geekosaur> MHD0, no
12:51:48 <MHD0> Because apparently Xcode 4 is shit and Xcode 3 is nonexistant anymore
12:51:55 <geekosaur> huh?
12:52:05 <geekosaur> double falseness
12:52:06 <clsmith> MHD0: you don't need to *use* xcode
12:52:10 <clsmith> only have it installed
12:52:10 <newsham> phlo: google says http://code.google.com/p/papert/
12:52:11 <MHD0> Okay
12:52:38 <geekosaur> (1) with free registration at developer.apple.com you can use connect.apple.com to get all current *and older* XCode releases
12:53:17 <newsham> http://logo.twentygototen.org/_REo_2F2
12:53:18 <MHD0> Okay, thanks for the info
12:53:19 <clsmith> i don't know about lisp. i worry that homoiconicity doesn't actually get you anything when you're dealing with something primitive like cons instead of some representation of the program semantically. it's like the reason implementations favour de bruijn indices over alpha-renaming.
12:53:22 <geekosaur> (2) XCode 4 has a number of changes.  they don';t make it "shit", they make it *different* in ways that various groups have had to adjust to.  The current Haskell Platform for OS X hasnt caught up with XCode 4.3.x, so you may prefer to stick to 4.2.1 or earlier
12:53:43 <geekosaur> or there are some edits you can make after installing the Haskell Platform that make it work
12:53:45 <Phlogistique> newsham: ...heh, I don't know Logo in english. What's the function for turning left >:
12:54:01 <newsham> "left"
12:54:07 <newsham> oh "lt"
12:54:10 <Phlogistique> oh
12:54:19 <newsham> and rt is right (droit?)
12:54:28 <MHD0> You Don't need to go defending Xcode to me, I get the willies when I don't have to compile with a bash command
12:54:32 <geekosaur> note also that XCode 3 does not work reliably on Lion
12:54:38 <MHD0> Thank you
12:54:43 <newsham> the bottom of the page has logo hints
12:55:04 <geekosaur> anyway, if the question you're really asking is "where can I get a development system that isn't Apple's", the answer is "you can't."
12:55:22 <clsmith> dmwit, newsham: thanks, http://en.wikibooks.org/wiki/Haskell/Category_theory#Functors_on_Hask explained the last few things i didn't understand
12:56:09 <newsham> clsmith: yay!  next time you can explain them to me
12:56:20 <clsmith> the problem i was struggling with was the two-part nature of factors (one at the type level, one at the function level), and the fact that in this case it was lifting to a subcategory of Hask, not a different unrelated category
12:56:31 <clsmith> s/factors/functors/
12:56:32 <geekosaur> (irony:  as of XCode 4.3 there is a command-line-only development environment from Apple.  very few OS X development environments know what to do with it yet, so don't bet on getting HP to use it without a fair amount of work)
13:00:03 * hackagebot hOpenPGP 0.0.0 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.0.0 (ClintAdams)
13:00:52 <clsmith> hmm. i don't know, i'm using osx lion right now, and after installing xcode i don't remember having any problems just installing haskell platform and it all working
13:01:13 <clsmith> and i mean just compiling with gcc & ghc from shell
13:06:11 <notthemessiah> Is there any examples of user software that is built on top of FRP?
13:06:24 <notthemessiah> Are* there...
13:06:38 <danharaj> I think iPwnStudios uses their own FRP framework to make games?
13:09:23 <notthemessiah> interesting to know. Seems that Haskell FRP libraries tend to be unstable/experimental.
13:11:15 <newsham> anyone know if you can pass functions as parameters in logo?
13:16:39 <dmwit> newsham: Logo is a lisp, I think.
13:16:58 <dmwit> So... almost certainly yes.
13:17:40 <newsham> yah it has "map" so it can be done but i cant figure out how to apply a function I pass in
13:18:28 <newsham> I would like to make tihs parametric: http://logo.twentygototen.org/LlUmeWwJ
13:18:36 <newsham> right now i had to wire in the function :(
13:20:19 <kallisti> so I'm getting this error when attempting to install wxHaskell
13:20:33 <kallisti> * Missing C library: wx_gtk2u_media-2.8
13:20:50 <kallisti> I'm running Debian. what package do I need?
13:21:00 <geekosaur> clsmith, HP has a hardcoded /Developer in it, whichd oesn't work with XCode 4.3.x
13:22:28 <reinoud> ugh... i am looking for a function that does [1,2,3,4,5,6,7,...] to [[1,2,3], [4,5,6], [7,8,9], ...] ....
13:22:44 <dmwit> ?hackage split
13:22:44 <lambdabot> http://hackage.haskell.org/package/split
13:22:53 <reinoud> thanks!!
13:23:06 <clsmith> geekosaur: ah, mine seems to be 4.2.1
13:23:14 <reinoud> @hoogle split
13:23:14 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
13:23:14 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
13:23:14 <lambdabot> Data.Typeable splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
13:23:15 <dmwit> kallisti: apt-cache search *wx*-dev
13:23:18 <t7> can i tell someone how to decrypt something without telling them how to encrypt something?
13:23:24 <clsmith> (also, it seems weird i can't get the version of an app without running it (?!))
13:23:37 <dmwit> kallisti: Might have to be .*wx.*-dev, I can never remember which of the two tools takes globs and which takes regexen.
13:24:01 <kallisti> dmwit: I've already installed everything that looks relevant. I think.
13:24:05 <kallisti> I'll double check
13:24:32 <geekosaur> clsmith, you can get it fromt he Info.plist in various bundles, or from running the xcodebuild command; it may also be buried in Apple's package stuff but I haven't tried to untangle pkgutil to that depth
13:24:45 <kallisti> dmwit: but yeah I've already installed the wx libs
13:24:49 <kallisti> dmwit: both base and gtk
13:25:50 <kallisti> ah here we go
13:25:54 <kallisti> build instructions on haskellwiki
13:26:23 <kallisti> it even mentions that library specifically
13:26:58 <kallisti> yeah so I have to add a new repo to my sources
13:27:09 <kallisti> tricky tricky
13:29:08 <geekosaur> you have the -dev libraries installed?  libwxgtk2.8-dev appears to be the debian prereq
13:30:03 <kallisti> geekosaur: yes
13:30:31 <kallisti> the installation instructions specifically mention that the Ubuntu/Debian library is misconfigured.
13:30:53 <geekosaur> doesn;t include media, sigh
13:31:00 <kallisti> hmm http://apt.wxwidgets.org/dists/  these are all Ubuntu versions..
13:31:00 <geekosaur> and that does sound like the issue, sadly
13:31:37 <geekosaur> ubuntu packages might work on debian; it should refuse to install them if they won't due to missing dependencies
13:31:47 <keep_learning> Hello All
13:31:49 <kallisti> but which version should I use
13:31:58 <kallisti> what's the most wheezy-like Ubuntu version? :P
13:32:58 <geekosaur> so actually I'd just add their debian repo, rather than try to download packages
13:32:59 <keep_learning> Can we use SIMD with Haskell code ( not dph library ) which consist of  Data.IntMap
13:32:59 <Phlogistique> is there a convention for marking a function as unsafe? For example I have f x = if x == 0 then Nothing else Just fUnsafe x; fUnsafe x = 3 / x
13:33:07 <geekosaur> that way you also get any bug fixes ec.
13:33:07 <Phlogistique> is there a better name for fUnsafe?
13:33:34 <kallisti> geekosaur: where is the debian repo?
13:33:52 <kallisti> oh squeeze
13:33:55 <kallisti> they have one
13:34:11 <parcs`> Phlogistique: f_ sometimes denotes an unsafe function
13:34:12 <geekosaur> http://wiki.wxpython.org/InstallingOnUbuntuOrDebian is pointed to by the main wxwidgets site
13:34:16 <notthemessiah> reinoud: splitEvery :: Int -> [e] -> [[e]]
13:34:42 <kallisti> geekosaur: yes I'm already doing all of that
13:34:50 <kallisti> I didn't see the squeeze distro listed
13:35:01 <kallisti> that's the only Debian distro available it seems
13:35:16 <parcs`> Phlogistique: i should say, f_ sometimes denotes an unsafe variant of f
13:36:02 <geekosaur> hm, yeh, no wheezy.  what you get for running testing :)  the squeeze packages might work as is
13:36:17 <Phlogistique> parcs`: thanks
13:36:20 <gusto> ha
13:36:39 <gusto> i believe fedora has the best haskell-platform packages
13:36:42 <Phlogistique> parcs`: though I thought people used a final _ mostly to denote discarding results
13:37:10 <hpc> "unsafeFoo" is what ive seen everywhere
13:38:12 <kallisti> er, well. that apparently did nothing
13:38:31 <kallisti> the packages that they wanted me to install were already installed from the Debian repos
13:38:49 <parcs`> Phlogistique: yeah, it's used for a variant that discards a result too
13:39:42 <geekosaur> kallisti, I expect that they have the same names, but are not necessarily the same contents.  you'd need to remove the distribution packages to install theirs
13:39:58 <gusto> on fedora you have "yum groupinstall haskell" - that's cool
13:39:59 <geekosaur> and probably make sure sources.list is ordered so their packages are seen first
13:40:11 <gusto> i miss that here on opensuse
13:40:35 <monochrom> fedora has the most fragmented haskell platform packages
13:40:45 <gusto> yes
13:41:04 <gusto> but you install them with groupinstall, so no problem how fragmented they are
13:41:08 <kallisti> geekosaur: ah
13:44:57 <kallisti> geekosaur: re-arranged the sources, ran update, then installed the wx packages, then attempted to cabal install wx
13:45:00 <kallisti> same error.
13:45:15 <kallisti> maybe there's a option to specify repo
13:48:39 <kallisti> I'll try again and run clean this time
13:52:05 <kallisti> bah. nothing seems to be working...
13:58:57 <greg`> hi
13:59:23 <hpaste> mewalz pasted ‚Äúenumeratee‚Äù at http://hpaste.org/66304
13:59:28 <kallisti> I may have to just compile wx by hand.
13:59:37 <mewalz> I can't figure out the enumeratee
14:00:18 <greg`> when i run ghc-pkg list i see haskell98 AND haskell2010 is this bad?
14:00:52 <mewalz> Speficially how can you compose an Enumerator with an Enumeratee to make a Enumerator?
14:05:51 <reinoud>  notthemessiah: tnx!
14:06:31 <Enigmagic> mewalz: =$ or $=
14:06:37 <Enigmagic> one of them..
14:06:47 <Saizan> greg`: nope, that's fine
14:07:22 <Enigmagic> mewalz: $= is the one you want
14:10:03 <mewalz> It says "
14:12:21 <reinoud> @hoogle splitEvery
14:12:21 <lambdabot> No results found
14:12:38 <mewalz> Enigmagic: Thanks, Zlib-enum was out of date! That is why it didn't work.
14:15:05 * hackagebot unfoldable 0.0.0 - Class of data structures that can be unfolded from a seed value.  http://hackage.haskell.org/package/unfoldable-0.0.0 (SjoerdVisscher)
14:19:47 <danharaj> edwardk: Been thinking of the type of Iterator some more today. Was wondering about the type of infinite coroutines that are always ready to consume input to produce output.
14:20:10 <edwardk> danharaj: there is a connection between that and pipes
14:20:31 <danharaj> edwardk: If you quantify over a in Iterator i o a, that gets you something like that, but now you can only run them by passing them a driver that eventually tosses out the Iterator. I was wondering if there's a nice way to derive a type of Iterator that passes the leftover computation as well.
14:20:55 <edwardk> the 'left over part' is what mucks it all up
14:21:02 <edwardk> otherewise you can work with free and cofree
14:21:41 <edwardk> The It type I use in trifecta is actually a cofree comonad, but it defers the 'left over part' to something above it
14:22:24 <kallisti> left over part? sounds like a job for continuations. :D
14:22:42 <edwardk> kallisti: thats the usual construction
14:23:39 <danbst> hello guys. have question on code simplify
14:23:49 <danbst> foreign import ccall unsafe "conio.h getch" c_getch :: IO Int
14:23:57 <danbst> foreign import ccall unsafe "conio.h kbhit" keyPressed :: IO Bool
14:24:06 <danbst> getKey = keyPressed >>= (\x -> if x then Just . chr <$> c_getch else return mzero)
14:24:24 <danbst> can getKey function be rewritten more shortly?
14:26:17 <hpc> foreign import ccall unsafe "conio.h getkey" getKey :: IO Whatever? :P
14:26:46 <kallisti> danbst: you can use guard instead of the if construct
14:26:50 <kallisti> :t guard
14:26:51 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:27:13 <kallisti> guard x >> (Just . chr <$> ...)
14:27:28 <danharaj> edwardk: Hmm. Now I'm thinking it shouldn't be too hard to derive the right type. Right now the driver you give to the Iterator can either give more input to it or throw it out. Perhaps the direction of control should be flipped, the Iterator asks the driver for more input and either gets an input or a halting value.
14:27:48 <byorgey> keyPressed >>= guard >> (Just . char <$> c_getch)
14:27:57 <byorgey> *chr
14:28:04 <edwardk> you can make it, its just not fundamental in any nice way
14:28:12 <danharaj> aww.
14:28:17 <danharaj> I was hoping it would be a comonad or something.
14:28:30 <kallisti> oh, you don't even use x after guard.
14:28:41 <edwardk> the comonad is the cofree version, which lacks the leftovers
14:29:00 <edwardk> basically you can always extract the result so far or feed it more input
14:29:11 <danbst> byorgrey -> No instance for (MonadPlus IO)  arising from a use of `guard'
14:32:47 * kallisti wonders why nothing seems to be working when install wxHaskell.
14:33:07 <danharaj> edwardk: one last thing: What extra stuff is there in Iterator if you derived it via Codensity instead of Yoneda?
14:34:09 <edwardk> its mostly just doing more work than it needs to
14:35:16 <edwardk> i'd have to work it out for that particular type though
14:35:27 <kallisti> @pl \x -> return $ guard x >> Just . chr <$> c_getch
14:35:28 <lambdabot> return . (>> Just . chr <$> c_getch) . guard
14:35:31 <danharaj> sounds like a good exercise for me.
14:35:49 <kallisti> oh wait
14:36:55 <byorgey> danharaj: ah, right, sorry, guard won't work there, I missed it was  return mzero  not  mzero
14:37:06 <byorgey> err, danbst
14:37:12 <augur> newsham: im going to stick with netlogo
14:39:08 <newsham> augur: requires a download?  boo :(
14:39:48 <danbst> kallisti: that gives long type error ...
14:40:00 <kallisti> danbst: yes that doesn't work
14:40:15 <kallisti> you want the Maybe instance of MonadPlus
14:40:17 <kallisti> not IO
14:40:43 <kallisti> so you'd have to bind the c_getch first, and then use guard
14:41:32 <danbst> that's a pity
14:42:16 <augur> newsham: ?
14:42:20 <kallisti> do { x <- keyPressed; y <- c_getch; return $ guard x >> Just (chr y) }
14:42:22 <kallisti> like this
14:42:39 <newsham> augur: ahh, i was comparing it with papert, but i guess you meant vs. scratch
14:42:45 <kallisti> @undo do { x <- keyPressed; y <- c_getch; return $ guard x >> Just (chr y) }
14:42:46 <lambdabot> keyPressed >>= \ x -> c_getch >>= \ y -> return $ guard x >> Just (chr y)
14:42:49 <kallisti> danbst: or like this if you prefer
14:43:29 <kallisti> @unpl \ y -> return $ guard x >> Just  (chr y)
14:43:29 <lambdabot> \ y -> return ((guard x) >> (Just (chr y)))
14:43:38 <kallisti> @pl \ y -> return $ guard x >> Just  (chr y)
14:43:39 <lambdabot> return . (guard x >>) . Just . chr
14:44:19 <kallisti> or like:   keyPressed >>= \x -> return . (guard x >>) . Just . chr <$> c_getch
14:44:31 <kallisti> ....minus the return .
14:44:44 <ion> That‚Äôs horrible. :-D
14:44:45 <kallisti> or like:   keyPressed >>= \x -> (guard x >>) . Just . chr <$> c_getch
14:45:39 <kallisti> looks like some pretty straightforward pointfree to me.
14:46:10 <danbst> wait a moment, it doesn't compile =)
14:47:24 <danbst> aa parents
14:47:29 <danbst> getKey = keyPressed >>= (\x -> (guard x >>) . Just . chr <$> c_getch)     compiled
14:48:21 <danbst> but another problem. side effects. c_getch is called always
14:48:38 <kallisti> truth
14:48:38 <danbst> so i am waiting for key always
14:48:49 <kallisti> @pl (\x -> (guard  x >>) . Just . chr <$> c_getch)
14:48:49 <lambdabot> (<$> c_getch) . (. (Just . chr)) . (>>) . guard
14:49:05 <byorgey> yeah, because you're doing the guard only in the Maybe monad
14:49:42 <byorgey> getKey has the form  keyPressed >>= (\x -> f <$> act), which will always run act
14:49:50 <kallisti> well, I guess we're done then. your original code works the best (except you want a return mzero or return Nothing instead of mzero)
14:50:08 <byorgey> danbst: honestly I think your first version was fine.
14:50:30 <kallisti> if you want it to look a little nicer you could use a where clause with a guarded function rather than the if.
14:50:59 <ion> How about something like: bool (return Nothing) (Just . chr <$> c_getch) =<< keyPressed
14:51:12 <ion> bool :: r -> r -> Bool -> r; bool f _ False = f; bool _ t True  = t
14:51:45 <ion> keyPressed >>= bool (return Nothing) (Just . chr <$> c_getch)
14:52:09 <byorgey> yeah, that's nice
14:52:22 <Phlogistique> liftA is just fmap, isn't it?
14:52:25 <kallisti> not shorter though. ;)
14:52:29 <danbst> ion: oh I was looking for this function! though it is not much more understandable then explicit if
14:52:34 <Phlogistique> is it there for a reason? (non-historical)
14:52:36 <danbst> thanks everybody
14:52:52 <notthemessiah> Any way to get a link to "Source" in Haddock documentation?
14:53:01 <ion> danbst: It follows the style of maybe and either.
14:53:03 <ion> @type maybe
14:53:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:53:05 <ion> @type either
14:53:06 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:53:21 <kallisti> notthemessiah: yes, just link the URL..?
14:54:59 <danbst> ion: there isn't something like guardM, just to eliminate (return Nothing) path?
14:55:52 <byorgey> danbst: no, but even if there was it wouldn't help since IO is not an instance of MonadPlus.
14:56:01 <reinoud> @hoogle split
14:56:01 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
14:56:01 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
14:56:01 <lambdabot> Data.Typeable splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
14:56:10 <danbst> oh yes...
14:56:20 <byorgey> @hackage split
14:56:20 <lambdabot> http://hackage.haskell.org/package/split
14:56:25 <byorgey> reinoud: ^^^
14:59:21 <danbst> @hoogle bool
14:59:21 <lambdabot> Prelude data Bool :: *
14:59:21 <lambdabot> Data.Bool data Bool :: *
14:59:21 <lambdabot> Data.Bool module Data.Bool
15:00:07 * hackagebot fix-imports 1.0.0 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-1.0.0 (EvanLaforge)
15:00:31 <Phlogistique> it would be nice to get a keyword equivalent tofor "case () of _"
15:00:38 <Phlogistique> s/tofor/to/
15:02:15 <Phlogistique> in the context of "case () of _ | a -> b | c -> d | otherwise -> e"
15:03:46 <kallisti> Philonous: yes guard expressions would be good
15:03:51 <kallisti> as well as case lambdas
15:04:13 <Philonous> kallisti:  I suppose you meant Phlogistique?
15:04:22 <kallisti> ...yes
15:05:24 <reinoud> @hoogle zip3
15:05:24 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
15:05:24 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
15:05:24 <lambdabot> Data.Sequence zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
15:08:02 <dmwit> Prelude?
15:08:10 <dmwit> huh!
15:08:22 <mk> what are some function typeclasses?
15:08:40 <dmwit> Strike the word "function" from that question.
15:08:51 <dmwit> Then, Eq, Ord, Show, Read, Num come to mind.
15:08:58 <chrisdone> Phlogistique: could call it 'cond'  a la lisp
15:09:17 <mk> dmwit: if functions have types, then why not function typeclasses?
15:09:18 <Phlogistique> chrisdone: indeed
15:09:45 <dmwit> mk: Everything has a type. But you don't say "list typeclasses".
15:09:53 <dmwit> It's just a typeclass.
15:09:55 <dmwit> It's a class of types.
15:09:56 <Ralith> How does GHC typecheck mutual recursion?
15:10:07 * hackagebot email-postmark 0.2 - A simple wrapper to send emails via the api of the service postmark (http://postmarkapp.com/)  http://hackage.haskell.org/package/email-postmark-0.2 (DanielPatterson)
15:10:09 * hackagebot fast-tags 0.0.1 - Fast incremental vi tags.  http://hackage.haskell.org/package/fast-tags-0.0.1 (EvanLaforge)
15:10:18 <Ralith> I was very surprised to discover that 'x z = y z; y z = xz' compilse
15:10:19 <Ralith> compiles
15:10:25 <Ralith> x z*
15:10:33 <byorgey> mk: if you're asking for type classes for which standard libraries define function instances, Monoid comes to mind
15:10:35 <ion> Why wouldn‚Äôt it?
15:11:07 <Ralith> ion: why would it?
15:11:08 <mk> dmwit: what's a typeclass? list?
15:11:09 <ion> > let x z = 'x' : y z; y z = 'y' : x z in x 42
15:11:10 <lambdabot>   "xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy...
15:11:17 <byorgey> Ralith: typechecking mutual recursion is not much harder than checking normal recursion.
15:11:37 <mk> I'm asking if there are any typeclasses which are sets of function-types
15:12:05 <ion> ralith: Is there a language in which the equivalent of x z = y z; y z = x z *doesn‚Äôt* compile?
15:12:20 <mk> Bool->Bool and Int->Int->Int are function types. Are there any typeclasses (sets of types) which contain either of those?
15:12:34 <dmwit> Yes.
15:12:40 <dmwit> However, no typeclasses are restricted to function types.
15:12:45 <byorgey> mk: any type class can contain those if you write an instance for it.
15:12:52 <Ralith> byorgey: all the papers I've read seem to do typechecking and generalization per-binding, though; to handle mutual recursion, don't you need to continue past the first binding without having determined a principle type?
15:13:05 <byorgey> and Monoid is an example of a class with function instances defined by a standard library module (Data.Monoid)
15:13:12 <dmwit> Ralith: Yes, you need to typecheck binding groups all at once.
15:13:15 <mk> dmwit: what do you mean by typeclasses being resptricted to function types
15:13:28 <dmwit> Ralith: Where a "binding group" is a strongly-connected component of the dependency graph or some such thing.
15:13:40 <Ralith> right.
15:13:53 <dmwit> mk: There is no typeclass for which all instances contain an (->).
15:13:55 <kallisti> exactly how aggressively does GHC inline ("factor") with full optimization flag?
15:14:07 <dmwit> s/all instances contain/all instances are required to contain/
15:14:20 <mk> dmwit: why is that?
15:14:28 <dmwit> There's just no mechanism for it.
15:15:07 * hackagebot certificate 1.1.1 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.1.1 (VincentHanquez)
15:15:45 <mk> ...is that simply like saying that there is no mechanism that prevents Booleans being made instances of Num?
15:16:03 <dmwit> Yes.
15:16:42 <dmwit> Also, modern GHC probably can express a typeclass for which all instances must be functions.
15:16:45 * dmwit tests
15:16:56 <mk> obviously that would be pointless, because a typeclass should be unified under a function
15:16:59 <dmwit> I'd look on such a class with a big question in my eyes, though.
15:17:38 <dmwit> Ah, yup, GHC doesn't allow that. So no mechanism.
15:17:54 <byorgey> "big question in my eyes" sounds the title of a country music song or something
15:18:40 <statusfailed> Does Accelerate have a corresponding matrix library?
15:18:51 <mk> why would such a typeclass be questionable?
15:19:42 <byorgey> "your love is like a typeclass / always open to other instances / so don't be surprised / at the big question in my eyes"
15:19:59 <dmwit> haha
15:20:31 <dmwit> Not necessarily questionable. Just very unusual, and there'd need to be a good reason to do it. So I'd be wondering what the good reason was.
15:23:29 <ski> dmwit : maybe `class (a -> b) ~ c => Foo c' ?
15:23:36 <dmwit> ski: That's exactly what I tried.
15:23:42 <dmwit> ski: But a and b aren't in scope. =)
15:23:45 <ski> and it complains about `a
15:23:48 <ski> ' and `b' ?
15:24:03 <dmwit> yes
15:24:18 * ski would have thought it complained about those not being mentioned in the class head ..
15:24:32 <mk> are polymorphic functions excluded from forming a typeclass?
15:24:38 <dmwit> ski: That's what "not in scope" means.
15:24:45 <ski> dmwit : i don't agree :)
15:24:50 <dmwit> It is here.
15:24:56 <dmwit> The only binding position is the instance head.
15:25:06 <byorgey> mk: no
15:25:07 * hackagebot intern 0.8.0.1 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.8.0.1 (EdwardKmett)
15:25:07 <ski> currently, yes
15:25:41 <ski> logically, there's nothing strange about a `foo(C) :- (A -> B) = C.' Prolog clause
15:25:44 <monochrom> what does "X form a type class" mean?
15:25:49 <mk> ...are typeclasses excluded from being in a typeclass?
15:26:09 <geekosaur> typeclasses are not types
15:26:18 <dmwit> Type classes are not types, so yes, they are excluded from being in a class of types.
15:26:22 <mk> monochrom: can be part of a typeclass
15:26:24 <geekosaur> you can require a typeclass context for anither typeclass
15:26:25 <edwardk> mk: you can pass constraints them as arguments to a typeclass now, but you can't make a typeclass locally within a type
15:26:25 <ski> (also, if we ever get rank-2 constraints, we could say `instance (forall a. Show a => Show (f a)) => Show (Foo f)')
15:26:46 <edwardk> ski: you can say that with the constraints package
15:27:13 <ski> edwardk : rephrased how ?
15:27:22 <mk> ok, so if typeclasses can't be types, and polymorphic functions operate on typeclasses, how is it that polymorphic functions count as types, and can be part of a typeclass?
15:27:45 <ski> mk : define "forming a typeclass"
15:27:47 <edwardk> ski: you use the Data.Constraint.Forall module
15:27:48 <dmwit> Typeclasses cannot be types.
15:27:56 <dmwit> Polymorphic functions do not operate on typeclasses.
15:28:06 <dmwit> Polymorphic functions do not count as types.
15:28:25 <mk> ski: (read up) they are part of a typeclass
15:28:25 <monochrom> polymorphic functions have types. not count as.
15:28:26 * ski suspects mk is using the wrong words to attempt to communicate her/his question
15:28:57 <ski> mk : by "part of", do you refer to the methods of the type class, or to the instances of the type class ?
15:29:08 <monochrom> "part of" is ambiguous. X is a method of a type class? X is an instance of a type class? both sound like "part of"
15:29:26 <monochrom> write some actual code and stop using natural languages?
15:29:53 <monochrom> or, at most, use formal symbolic logic if code is not enough
15:30:06 <monochrom> and define everything, too
15:30:06 <edwardk> hrmm, i think you might be able to do it without constraint kinds even, if you are willing to make a class each time you have that sort of constraint.
15:30:09 * hackagebot tls 0.9.2 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.9.2 (VincentHanquez)
15:30:24 <mk> ski: I wasn't thinking of methods as being in the set, and I've been thinking of typeclasses as a set of types
15:30:31 <ski> ok
15:30:55 <edwardk> class PowerShow f where liftShow :: Show a => (Show (f a) => r) -> r
15:31:25 <edwardk> instance PowerShow f => Show (Foo f)
15:31:26 <monochrom> we have had function types being instances of type classes
15:31:48 <edwardk> you have to manually use liftShow to discharge the obligation though
15:31:54 <ski> mk : then re "are polymorphic functions excluded from forming a typeclass?" corrected to "are *types* of polymorphic functions (aka universal types) excluded from being an instance of a type class", i think the answer is yes
15:31:56 <edwardk> with constraints you can do so without one-off combinators
15:31:57 <monochrom> "instance (Num a) => Num (b -> a)" is a pretty famous one
15:32:33 <monochrom> actually, Haskell 2010 probably doesn't allow it, but GHC extensions do
15:32:35 <mk> ski: though I think that all typeclasses are defined by (probably) a single function
15:32:57 <ski> mk : re "...are typeclasses excluded from being in a typeclass?" corrected to "are typeclasses excluded from being instances of typeclasses ?", i think the answer is no, with recent GHC extensions
15:33:04 <mk> ski: thanks - yes, that's what I meant
15:33:44 <ski> mk : hum, to clarify the answer for the last question, i think they are *not* excluded
15:34:37 <ski> edwardk : hm, possibly slightly better than `class Show1 f where showsPrec :: Show a => Prec -> f a -> ShowS', i suppose
15:34:48 <mk> ski: would tc1 instance tc2 just be an instruction to put all types in tc1 into tc2?
15:34:49 <ski> s/showsPrec/showsPrec1/
15:35:25 <ski> not sure what you mean by "though I think that all typeclasses are defined by (probably) a single function"
15:35:55 <ski> mk : no
15:37:00 <ski> `instance Tc1 a => Tc2 a' would be more or less that, though
15:38:00 <mk> ski: Ord is defined on the basis of >, and a few extra functions like >= are derived on the basis of both eq and ord
15:38:14 <geekosaur> ...don't look ay Num :p
15:38:28 <JoeyA> :i >=
15:38:31 <mk> geekagent: it's defined on the basis of (+)
15:38:33 * ski was just about to mention `Num' :)
15:38:41 <JoeyA> :t (>=)
15:38:42 <lambdabot> forall a. (Ord a) => a -> a -> Bool
15:38:51 <ski> mk : don't forget `(*)'
15:39:05 <mk> ski: * is defined on the basis of +
15:39:08 <ski> no
15:39:48 <geekosaur> mk, that only works for some possible instances of Num.  see:  matrices
15:39:53 <mk> we're not talking about the implementation, right?
15:39:57 <edwardk> mk: (*) is not build up iteratively by using (+). also (+) wouldn't determine the value of 0 or 1 for you
15:40:11 <ski> mk : i'm only talking about the class definition here, not the instances
15:40:50 <mk> edwardk: + operates on the fact that you have a unit interval - this gives you +, -, and *...
15:41:56 <edwardk> mk: FYI- your sideways intuition stems from the fact that it is _possible_ to define a class dispatch mechanism where you treat type constructors as data constructors, to infer them, and to keep them around to runtime and dispatch typeclass members using them. In fact this is more or less what the JHC haskell compiler does
15:42:01 <edwardk> however, it isn't what GHC does
15:42:31 <mauke> I don't have a unit interval
15:42:45 <edwardk> (+) is just a function carried around in a dictionary for the Num class. it can be anything. there are some laws we'd like to apply to it, but they aren't enforced and in theory aren't enforceable
15:42:50 <mk> edwardk: intuition regarding?
15:43:14 <edwardk> your flawed intuition regarding the way classes work
15:43:15 <mk> mauke: well you're not even a type
15:43:29 <mauke> I'm a Haskell coder
15:43:39 <edwardk> mauke: Num works on plenty of things where the 'unit interval' doesn't exist.
15:43:43 <edwardk> er s/mauke/mk/
15:43:54 <monochrom> I am a colour
15:43:59 <mk> edwardk: what's an example?
15:44:17 <monochrom> Complex Double
15:44:28 <ski> mk : see `Num' at <http://darcs.haskell.org/packages/base/GHC/Num.lhs> -- `(-)' is defined in terms of `(+)' and `negate'; and `negate' is defined in terms of `fromInteger' and `(-)' -- that's it
15:44:44 <monochrom> I'm recently playing with FFT, complex numbers come to mind easily :)
15:45:06 <mk> monochrom: perhaps a more familiar example?
15:45:42 <edwardk> mk: instance Num () where _ + _ = (); _ * _ = (); negate _ = (); abs _ = (); signum _ = (); fromInteger _ = ()   has a single value. Num a => Num (a -> b) is a class for the the 'ring' b^a. i put ring in scare quotes because Num does no enforcement of any laws
15:45:54 <monochrom> Complex Double is very familiar to me
15:46:01 <ski> the trivial ring :)
15:46:09 <edwardk> mk: Complex is a solid example complex numbers can't be sorted usefully
15:46:20 <edwardk> mk: you have a unit circle, but its not the same thing
15:46:38 <edwardk> and i can construct vector spaces for which i can't make an inner product space
15:46:59 <edwardk> there the notion of the norm that generalizes your unit interval to the unit circle falls apart
15:47:00 <monochrom> you're actually pretty welcome to define "familiar" so that "X has a unit interval iff X is familiar", therefore all "familiar" examples have unit intervals, and be delighted that you are right
15:47:49 <ski> (edwardk : s/is a class/is an instance/ :)
15:47:57 <edwardk> ski: sure
15:47:58 <monochrom> the same way we like saying "survival of the fittest". so what is "fittest?" "oh, those who survive"
15:48:13 <mk> monochrom: I'm not trying to be right when I'm wrong, I'm trying to understand why you think x, and the example you gave doesn't help with that :P
15:48:37 <monochrom> ok, I need to know what is familiar to you. upload your brain for a free anlaysis
15:49:01 <edwardk> mk: because your examples are too simple to see the problem, but you reject the more complicate examples that do show the problem
15:49:37 <aib> is there an alias for (\x -> [x]) or that mapped over a list? (i.e. \y -> map (\x -> [x]) y)
15:49:48 <monochrom> integers mod 12 has no unit interval
15:49:53 <mk> monochrom: you can make a guess, especially when I tell you what I'm familiar with
15:49:54 <edwardk> aib: return
15:49:59 <edwardk> monochrom: good example
15:50:20 <mk> edwardk: I'm not rejecting the examples, I'm asking for ones that I'm more familiar with. If there aren't any, let me know
15:50:47 <mk> hmm
15:50:56 <edwardk> mk: integers mod n form a usable instance of Num. pick an N. you can add numbers modulo 7. you can multiply numbers and take the remainder mod 7
15:51:12 <edwardk> you can convert from any integer by taking it mod 7
15:51:18 <edwardk> it makes a perfectly good Num
15:51:25 <edwardk> newtype Mod7 = Mod7 Int
15:51:34 <monochrom> unfortunately, integers mod (prime or special number) is also from FFT :)
15:51:36 <aib> edwardk: right. I'd forgotten about that. thanks
15:51:56 <edwardk> but the the only numbers in your 'unit interval' are 0 and 1, but if you go out far enough you wind up back in the unit interval. 7 and 8 are back in there!
15:52:08 <edwardk> since 7 % 7 = 0
15:52:40 <edwardk> and the interval you have doesn't have any nice properties, because it isn't respected by the operations
15:53:02 <edwardk> ideally you want some kind of ordered ring to talk about these things the way you've started to. (a unit interval needs some notion of an interval, 0 <= x <= 1
15:53:21 <monochrom> I'm going to make "instance WellOrdered Real"...
15:53:27 <edwardk> but to make that useful, you need to know that you have some laws relating the operations of the ring to the ordering
15:53:38 <edwardk> e.g. you want to know that if you have x <= y   then x + c <= y + c
15:53:53 <kallisti> is there anything life transformers-base where the functional dependency is removed?
15:54:03 <kallisti> so that you can lift to arbitrary monads within the stack?
15:54:10 <edwardk> or if z is positive then x <= z implies x * z <= y * z
15:55:04 <mk> I'm not sure that I follow why mod 7 doesn't have a unit interval. Perhaps I should use the word "unit" instead?
15:55:38 <edwardk> but there exist many many spaces for which this doesn't hold. in the modulo example, 3 mod 7 <= 6 mod 7 , but  but (3 mod 7 + 1 mod 7) = (4 mod 7) is not less than 6 mod 7 + 1 mod 7 = 7 mod 7 = 0 mod 7.
15:55:41 <kallisti> monochrom: good luck
15:56:11 <edwardk> you can put an arbitrary ordering on the numbers 0 to 6. but it doesn't mean that the operations of multiplication mod 7 respect that ordering
15:57:11 <monochrom> thank you!
15:57:45 <edwardk> to define a ring you need several things. you need a two operations (+) and (*) that have a distributive law between them, units for them, and they don't determine one another. there are odd ring structures out there using (+) and max for instance which get used a lot in graph algorithms and AI planning
15:58:02 <mk> edwardk: well, there's a cyclical ordering on them, to start. Weekdays are another example
15:58:20 <edwardk> mk: yes, but my point above is that while the cyclic ordering exists it doesn't help, because the operations don't respect it
15:58:21 <mk> but you can't multiply weekdays or add them, though you can succ
15:58:29 <edwardk> mk: sure
15:58:41 <mk> edwardk: +1 respects it
15:58:50 <edwardk> no it doesn't
15:58:54 <edwardk> let me show you
15:59:03 <edwardk> choose an ordering. pick which day starts the week
15:59:12 <mk> edwardk: none start the week. It's a cycle.
15:59:24 <edwardk> then how can i compare two days?
15:59:44 <edwardk> lessThan :: Day -> Day -> Bool
16:00:03 <edwardk> the moment you do that i can show you how succ breaks it
16:00:11 <mk> you don't. That's like asking "is monday after friday"? Yes, it is, but friday is also after monday.
16:00:17 <edwardk> correct!
16:00:32 <edwardk> the point is that there isn't an ordering you can put on them that succ preserves
16:00:41 <mk> that doesn't mean that succ does not work
16:00:53 <edwardk> correct
16:00:56 <mk> succ Wednesday is Thursday
16:00:58 <edwardk> but what is the 'unit interval' for your days?
16:01:06 <edwardk> the concept is nonsense
16:01:43 <mk> there isn't one, but there's something very close which is represented by succ
16:02:22 <mk> if you add the property of having a 0-value, then you have a different typeclass
16:02:29 <monochrom> "should succ be cyclic" is an open question
16:02:46 <mk> monochrom: s/succ/next
16:02:50 <edwardk> this 'succ' thing doesn't come close to defining a full 'Num' though
16:03:00 <edwardk> it gives you one operation, we have that packaged up as part of Enum
16:03:19 <edwardk> but Num is a lot more, I can't add just knowing how to use Succ
16:03:43 <edwardk> how do you add Wednesday to Tuesday? I can do that with the modular arithmetic, i just need to know which one is 0
16:03:49 <mk> edwardk: of course not. You need a function that returns the 0-value
16:04:06 <edwardk> correct, and now you've built a monoid
16:04:15 <edwardk> but it wasn't determined by a single function
16:04:44 <edwardk> well, we haven't built a monoid, we've built a unital magma we hope, then we can show we've built a monoid but the idea is the same
16:04:53 <kallisti> so what would happen if lifted-base was changed so that lifted-base worked not only with any MonadBase IO m instance
16:05:02 <kallisti> but (MonadIO b, MonadBase b m)
16:05:52 <mk> but still, the typeclass with this property of having a 0-value is defined by a single function
16:06:14 <edwardk> mk: but even knowing 0 and succ isn't enough to add them directly.
16:06:45 <edwardk> sure, you could decompose everything into single function typeclasses, but they would be very hard to work with
16:06:59 <edwardk> and many typeclasses you want are just to state that you know some law holds, and wouldn't even have a class
16:07:05 <edwardk> er wouldn't even have a function
16:07:20 <mk> (of course, we can have a typeclass that combines succ and get-0, but the point is that for any function, there is (as far as I've been able to think) a reasonable typeclass for it)
16:07:42 <mk> edwardk: such as?
16:08:21 <edwardk> class Zero a where zero :: a;  class Plus a where (+) :: a -> a -> a       but there is nothing that tells you that Zero and Plus for the same type are related.
16:08:45 <edwardk> so you probably want something like class (Zero a, Plus a) => Unital a
16:09:16 <edwardk> Unital didn't add any operations, it just merged the ones from Zero and Plus, but you don't want to make that instance magically you need someone to assert that zero and (+) have some connection
16:09:55 <edwardk> lest someone working in part of your program start working with zero = 1  because it was consistent with other operations around him
16:10:04 <edwardk> and you come along with a (+) based on addition
16:10:05 <mk> edwardk: I was imagining plus as a composite function that uses next(getzero), for example
16:10:20 <mk> s/composite/derived
16:10:35 <edwardk> how can i add 0.2 + 0.3 with just succ and zero?
16:11:42 <mk> edwardk: you don't. Those don't exist, because we're only dealing with integer addition at the moment (which is distinct, I would hope, from addition over other Numbers)
16:11:58 <edwardk> but why is it distinct?
16:12:01 <edwardk> > 0.2 + 0.3
16:12:02 <lambdabot>   0.5
16:12:04 <edwardk> > 1 + 1
16:12:05 <lambdabot>   2
16:12:22 <mauke> > (length + sum) [4, 5]
16:12:23 <lambdabot>   11
16:12:32 <honza> hello fine folk if haskell --- whats the most common oss license in this community?
16:12:33 <edwardk> note mauke was adding functions
16:13:00 <rasfar> i'd guess BSD3?
16:13:16 <edwardk> the 3 clause bsd license is pretty common here
16:13:52 <mk> edwardk: because it operates on different numbers. 1-9 is undefined for the naturals, but it is for the full integers
16:13:54 <edwardk> there are a few mit licenses and things that are effectively equivalent, and some applications licensed under the GPL, but thats about it
16:13:58 <honza> i like me some bsd, thanks
16:14:16 <honza> pandoc is gpl
16:14:35 <edwardk> yeah pandoc is hardly indicative of the community as a whole though =)
16:14:55 <honza> edwardk: oh yeah
16:15:02 <mk> the point is that the typeclass containing .2 and .3 is defined using (div), or (ratio), or somesuch
16:15:22 <aristid> cabal defaulting to BSD3 may help (when creating new projects)...
16:15:30 <mk> at least that's how I've been thinking of it
16:15:38 <mauke> what do you even mean by .2?
16:15:45 <edwardk> I'm going to let someone else pick up my side of the argument and go back to getting something done
16:15:50 <mk> mauke: 1/5
16:15:56 <mauke> why is 0.2 == 1/5?
16:16:13 <ski> mk : still the operations `(+)',`(*)' which is defined on the naturals are still defined on larger number structures, such as the integers, the rationals, the algebraic numbers, the reals, &c.
16:16:24 <mk> mauke: because both representations represent the same number, which is the rational 1/5
16:16:30 <elliott> ooh, a licensing argument?
16:16:36 <elliott> tell me more
16:16:41 <mauke> mk: I find that unconvincing
16:17:08 <ski> (.. `1/5', modulo `14', is `3')
16:17:26 <edwardk> aristid: I am very grateful for this fact
16:17:35 <mauke> > 1 + 1 :: Expr
16:17:36 <lambdabot>   1 + 1
16:17:43 <mk> mauke: I'm not sure I follow. I'm just telling you that when I wrote .2, I didn't mean it to refer to the .2 that exists in the set of e.g. complex numbers
16:17:58 <mauke> oh, I thought we were talking about haskell
16:18:20 <rasfar> elliott: nah, that was very much in passing
16:18:33 <edwardk> mk: the point we have is that if you step back there is a pretty well thought out set of operations that we can use to define these things. Num is a pretty bad mess, but there are numeric preludes with more rigorous foundations that may make you happier
16:18:54 <mk> mauke: well, haskell doesn't have nice rationals, but I'm sure that they could be implemented
16:19:05 <mauke> why do you think haskell doesn't have nice rationals?
16:19:09 <edwardk> mk: just because i can define addition on the naturals with succ and zero doesn't mean i should
16:19:28 <edwardk> > fromRational (2 % 5) :: Double
16:19:29 <lambdabot>   0.4
16:19:36 <edwardk> > 2 % 10
16:19:37 <lambdabot>   can't find file: L.hs
16:19:43 <edwardk> thats interesting
16:19:44 <ski> > 0.2 :: Rational
16:19:45 <lambdabot>   1 % 5
16:19:47 <dolio> Wat.
16:19:58 <dolio> > 2 % 10
16:19:59 <lambdabot>   1 % 5
16:20:02 <mauke> > 0.1 + 0.1 + 0.1 + 0.1 + 0.1 :: Rational
16:20:02 <lambdabot>   1 % 2
16:20:13 <aristid> edwardk: at least Num doesn't depend on Eq and Ord anymore:)
16:20:24 <mauke> it never Ord
16:20:25 <edwardk> aristid: yes =)
16:20:31 <edwardk> er Eq and Show
16:20:55 <aristid> uh yeah might've mixed those up :D
16:21:03 <rasfar> that may help to explain why my constraint lists are ridiculously long on most functions
16:21:18 <rasfar> (in the current project that is)
16:21:25 <mk> edwardk: maybe, but in any case, there are core functions that specify a typeclass, which lets us say things like "putting Bools and Weekdays into the same typeclass is nonsense"
16:21:47 <edwardk> depends on what the typeclass is for
16:21:50 <elliott> mk: what is not-nice about haskell's rationals
16:21:51 <mauke> mk: Read, Show, Eq, Ord, Enum, Bounded, Typeable, Data
16:22:00 <edwardk> instance Eq Bool   and instane Eq Weekday works fine
16:22:03 <elliott> edwardk: the L.hs thing is just a temporary error
16:22:06 <elliott> it works if you try again
16:22:16 <geekosaur> race condition?
16:22:21 <ski> possibly
16:22:21 <elliott> likely
16:22:23 <edwardk> elliott: yeah dolio got it to work right after
16:22:28 <mk> elliott: I might be wrong, but I understood that instances were backed by finite floats
16:22:37 <elliott> mk: "instances were backed by"?
16:22:39 <elliott> what does that mean?
16:23:19 <mk> edwardk: sorry, I should say a typeclass exclusively made up of bool and weekday, because of course eq covers quite a bit
16:24:04 <ski> typeclasses are open for all
16:24:44 <mk> elliott: it means that I thought that haskell uses doubles and floats to represent rationals, and those aren't rationals as far as I know
16:25:00 <mk> > (+) 0.1 0.2
16:25:00 <lambdabot>   0.30000000000000004
16:25:09 <mauke> > (+) 0.1 0.2 :: Rational
16:25:10 <lambdabot>   3 % 10
16:25:10 <geekosaur> mk, see Data.Ratio.  in partiular, Rational is a type alias for Ratio Integer
16:25:12 <elliott> mk: Why did you think that?
16:25:57 <geekosaur> it is common to use decimal literals to initialize Rationals, but that's something of an artifact
16:26:11 <mk> elliott: unsure - looks like I was wrong. Perhaps I was confusing them with Fractional?
16:26:22 <ski> could have been
16:26:36 <elliott> Well, Fractional is a typeclass. Float, Double and Rational are all instances of it.
16:26:37 <edwardk> mk: we have Rational which is based on ratios of gcd divided integers, and we have Float and Double for when folks want to actually get things done ;)
16:26:57 <edwardk> all of them are instances of Fractional
16:29:07 <mk> seems strange to have them all in the same place, when (.1+.2)*10 returns different things for doubles vs. rationals
16:29:30 <mauke> if it returned the same thing, why would it be a method?
16:30:00 <mk> mauke: values in the same set of isomorphic values
16:30:07 <mauke> wat
16:30:19 <mk> the double 3 is isomorphic with the ratio 3.
16:30:23 <mauke> prove it
16:30:25 * ski thinks mk is thinking about the natural inclusion from `Double' to `Rational'
16:30:36 <mk> even though they are entirely different numbers
16:31:33 <mk> mauke: double 3 is just succ succ succ getzero, and so is the ratio 3.
16:31:54 <mauke> what are succ and getzero?
16:32:34 <mk> mauke: read up, but basically they are functions that apply to types that have the properties of having successors, and a single 0-point
16:32:45 <mk> mauke: weekdays have succ, but not getzero
16:32:50 <mauke> mk: sunday
16:32:54 <ski> @let getZero :: Num a => a; getZero = fromInteger 0
16:32:55 <lambdabot>  Defined.
16:33:08 <mauke> mk: what's a successor?
16:33:09 <mk> mauke: succ sunday = monday
16:33:15 <mauke> mk: I know
16:33:34 <mk> mauke: ...succ saturday = sunday
16:33:50 <mauke> mk: I know
16:33:53 <elliott> Is this another cyclic Enum instance?
16:33:57 <elliott> Those aren't allowed, you know!
16:34:05 <mk> mauke: a successor is a single node that comes next in a directed graph
16:34:14 <mauke> mk: ok?
16:34:20 <mauke> elliott: it's not an Enum instance
16:34:23 <mauke> it is cyclic, though
16:34:25 <elliott> <mk> seems strange to have them all in the same place, when (.1+.2)*10 returns different things for doubles vs. rationals
16:34:38 <elliott> the point of typeclasses is not to have a bunch of instances that yield the exact same results
16:34:47 <mk> mauke: does that answer your question of what successor is?
16:34:47 <elliott> that would be rather pointless indeed
16:35:06 <mauke> mk: no, because you haven't defined the graphs in question
16:35:16 <mauke> mk: and you haven't explained why getzero isn't sunday
16:35:17 <mk> elliott: read down a bit from there, isomorphic etc.
16:35:32 <mauke> mk: and you haven't explained what you mean by isomorphic
16:35:34 <elliott> the point of typeclasses is not to have a bunch of instances that yield exactly isomorphic results
16:35:42 <elliott> nothing you've said makes much sense really
16:36:21 <mk> mauke: because weekdays don't have a start day... your calendar has a linebreak, but the days go on forever
16:36:38 <mauke> mk: non sequitur
16:36:54 <mk> mauke: another answer is: because it doesn't make sense to add monday to monday and get tuesday
16:36:59 <mauke> mk: non sequitur
16:37:33 <aristid> weeks start on monday not sunday :D
16:37:44 * Guest32898 seconds that
16:37:44 <elliott> aristid++
16:37:47 <monochrom> I like starting from Sunday. but ok.
16:37:48 <mauke> aristid: yeah, but monday = 1
16:37:51 <mk> mauke: it would help you you explained why. I also don't understand why people say things in response to my questions sometimes, but that doesn't mean that they're intentionally saying something unrelated
16:38:09 <mauke> mk: no, you have to explain why stuff is related to other stuff
16:38:11 <elliott> i agree with mauke that mk's responses seemed completely unrelated to the questions asked
16:38:19 * ski remembers calendars showing sunday as initial day of the week
16:38:20 <mauke> because stuff not being related to other stuff is the default
16:38:34 <aristid> ski: that must have been an illusion
16:38:53 <elliott> ski: you purchased a counterfeit calendar
16:38:58 * geekosaur *eyeroll*
16:39:13 <mk> elliott: again, it would help if (etc.) - you could mention such a response, and it would help me out
16:39:27 <elliott> e.g. <mk> mauke: another answer is: because it doesn't make sense to add monday to monday and get tuesday
16:39:29 <aristid> geekosaur: it's almost as funny as discussing whether foot or meter is the better unit!
16:39:35 <elliott> it might help if i knew exactly which thing mauke said that you're replying to
16:39:47 <elliott> aristid: you misspelled "metre"
16:40:10 <aristid> elliott: sorry. it's because i'm not a native speaker ;)
16:40:24 <ski> "Days of the week from the Roman period have been both named after the seven planets of classical astronomy and numbered, beginning with Sunday. In Slavic languages, a numbering system was adopted, but beginning with Monday."
16:40:27 <mk> elliott: I believe that the fact that it makes no sense to add days is related in an important way to the fact that days have no 0-value. That's not unrelated...
16:41:10 <mk> it doesn't matter where you start - pick a weekday. It's still true that whichever one you pick, say, tuesday, succ monday is still tuesday
16:41:26 <mk> unlike for example
16:41:29 <aristid> mk: so Weekday doesn't form a Monoid
16:41:29 <mk> > succ GT
16:41:30 <lambdabot>   *Exception: Prelude.Enum.Ordering.succ: bad argument
16:41:31 <aristid> ok
16:42:03 * ski isn't quite sure what the discussion is about atm
16:42:26 <aristid> ski: does it matter that much what the discussion is about?
16:42:35 <ion> Any preferences on a Haskell package that solves systems of linear equations?
16:42:35 <mk> ski: mauke wants to know what I mean by succ.
16:43:05 <elliott> how does this tie back to haskell exactly
16:43:08 <ion> Symbolic would be nice but numeric also suffices.
16:43:46 <ski> aristid : it might help with clarifying stuff, leaving unproductive arguments
16:44:05 <elliott> What would #haskell be without unproductive arguments?
16:44:12 <mk> elliott: typeclasses, and my (simple, I thought, but apparently not) point that typeclasses correspond to functions, which allows someone to say that the typeclass consisting of Bool and Weekday is nonsense
16:44:14 <rasfar> ion: you're not by any chance taking a shot at the ticket #12 for diagrams?...  (that would be a longshot i guess)
16:44:26 <elliott> how do typeclasses correspond to functions, exactly?
16:44:29 <ion> rasfar: nope
16:45:27 <ion> I guess i‚Äôll try http://hackage.haskell.org/packages/archive/hmatrix/0.14.0.1/doc/html/Numeric-LinearAlgebra-Algorithms.html
16:45:42 <elliott> ion: that's a c lib dep though
16:45:48 <mk> elliott: succ corresponds to the typeclass of values which have a sensible directed relation between values such that for (almost) all values, there is a single value that they point to as next
16:46:08 <rasfar> that sounds handy; never tried any Haskell numerics packages yet, i should check it out too
16:46:29 <ion> elliott: That‚Äôs not a problem in this case, just calculating some stuff for myself.
16:46:31 <elliott> mk: is that statement just a weird way of saying "you can define the typeclass class SensibleDirectedRelationBlah a where succ :: a -> a and it contains the function succ"?
16:47:27 <mk> elliott: no, what you said is a weird way of saying what I said :)
16:47:40 <mk> after all, typeclasses don't really "contain" functions
16:47:45 <ski> mk : "the typeclass consisting of Bool and Weekday is nonsense" is strange -- you can always add more types as instances to a type class
16:47:50 <ski> (and `Eq' was already mentioned)
16:47:52 <elliott> mk: sure they do
16:47:56 <elliott> typeclasses are composed of values
16:47:57 <elliott> called methods
16:48:05 <elliott> in this case, SensibleDirectedRelationBlah contains the method succ
16:48:07 <dmwit> Any type, functional or not, may be construed as an instance of a suitably generalized typeclass. But that doesn't seem like an interesting or useful fact.
16:48:55 <dmwit> ...more precisely, may be construed as the type of a method of a suitably generalized typeclass.
16:48:55 <mk> ski: "consisting" as in "my bike consists of this wheel and handlebar" suggests that that's all that's left of my bike
16:48:59 <ski> mk : also, rather than "typeclasses correspond to functions", i would say that each type class "corresponds" to a *collection* of operations/methods (usually, but not always, functions)
16:49:37 <ski> mk : yes, but given any class, we can always add new types, meaning that there is no sense in saying that it has *only* certain instances
16:49:51 <ski> a third-part library might add more
16:49:52 <monochrom> WeekDay should have Monday, Tuesday, Wednesday, Thursday, Friday, and that's it. :)
16:50:14 <monochrom> (so, I approve Monday being the start of weekdays :)
16:50:38 <mk> ski: but when you add new types to typeclasses, they should have certain properties
16:50:58 <ski> monochrom : s/Week/Calendar/ :)
16:51:05 <monochrom> \‚à©/
16:51:20 <ski> (apparently "veckodag" in swedish is "caledar day" in english)
16:51:31 <ion> There‚Äôs also http://hackage.haskell.org/package/sparse-lin-alg
16:51:38 <ski> mk : yes ?
16:51:44 <mk> if someone has a typeclass with Bool in it, and they add Weekday to it, and then they stop adding types, I don't understand why this wouldn't be considered garbage
16:52:09 <ski> consider the `Eq' example again ?
16:52:32 <mk> ski: they stop adding types
16:52:40 <elliott> there is no they
16:52:41 <mk> they aren't trying to reconstruct Eq
16:52:46 <ski> the "stop adding types" isn't well-defined
16:52:59 <ski> another part of the program can add more instances
16:53:01 <rasfar> ion: that could be handy too; doesn't appear to have C lib deps either
16:53:03 <elliott> so, now that we've back-tracked up a level... what is *this* actually about?
16:53:14 <elliott> i.e. why is this being discussed
16:54:19 <ski> elliott : afaiui, an attempt to better understand type classes
16:54:23 <ion> I think i‚Äôll try hmatrix for now.
16:54:33 <mk> elliott: because I suggested that typeclasses are defined by functions, or composite functions
16:54:36 <scooty-puff> has it ever been known that ghc may produce bad (as in illegal instructions, segmentation faults) code when compiling modules that use any of: GADTs, DataKinds, or OverlappingInstances?
16:55:00 <elliott> mk: right, which is incorrect. or, at least, a very weird way of stating things
16:55:03 <elliott> (what is a composite function?)
16:55:06 <ski> mk previously seemed to suggest that each type class should be definable by a single function
16:55:15 <elliott> scooty-puff: OverlappingInstances can cause that in combination with some other things
16:55:18 <elliott> perhaps GADTs is one of those things
16:55:18 <ski> (`(+)' in the case of `Num')
16:55:19 <elliott> (I think)
16:55:27 <scooty-puff> k
16:55:42 <elliott> ski: well, it's true, who uses multiplication? :)
16:56:06 <dmwit> elliott: Wait, what? OverlappingInstances + X yields segfaults when X doesn't?
16:56:09 <ski> scooty-puff : `OverlappingInstances' and `IncoherentInstances' are questionable -- do not use, if you can avoid
16:56:16 <elliott> dmwit: I think so, yes.
16:56:21 <dmwit> I thought GeneralizedNewtypeDeriving was the only truly dangerous extension.
16:56:24 <elliott> dmwit: Or was it IncoherentInstances?
16:56:27 <dmwit> Well, and FFI, of course.
16:56:34 <mk> ski: sure... all typeclasses can be defined in terms of atomic typeclasses/functions? I'm not sure that this is worth formalizing
16:56:35 <scooty-puff> dmwit, o.. did not know that one was too
16:56:36 <elliott> ISTR SomeFunkyInstanceThing + something like TypeFamilies or GADTs = unsafeCoerce.
16:56:40 <elliott> But it might have been a GHC bug.
16:56:56 <dmwit> elliott: I think you're thinking of GND.
16:57:07 <elliott> mk: You can turn an N-element typeclass into a 1-element one where the element is just an N-tuple, modulo rank-2 types.
16:57:13 <elliott> dmwit: Might be.
16:57:28 <ski> mk : each type class is defined in terms of a *collection* of operations/methods (and superclasses) -- it appeared you insisted on there only having to be *one* function for each type class
16:57:39 <mk> I'm also not sure why there's opposition to the suggestion that typeclass consisting entirely of Bool and Weekday (and not called Eq) is garbage
16:57:52 <dmwit> I'm not sure why you would think it was garbage.
16:58:02 <ski> elliott : with `FlexibleInstances', no ?
16:58:04 <elliott> mk: That is not a property of the typeclass.
16:58:19 <elliott> It is a property of the instances of the typeclass in a certain context.
16:58:21 <elliott> ski: Why?
16:58:22 <ski> mk : i think the word "entirely" there is meaningless
16:58:35 <elliott> mk: It sounds like you are unfamiliar with the open world assumption.
16:58:38 <mk> ski: compare isn't defined by <=, which is simply = and <
16:58:39 <elliott> It's fundamental to Haskell's typeclass design.
16:58:44 <mk> (have to step away)
16:58:52 <elliott> It's (==).
16:58:53 <ski> elliott : so that you can say `instance Monad m => MonadReader_ (r,Reader r m)'
16:59:02 <elliott> ski: Element, not parameter.
16:59:16 <elliott> i.e. if mk is saying "every typeclass is definable by a single member" then... well, yeah, duh.
16:59:25 <ski> elliott : oh -- then i misunderstood what you said
16:59:44 <ski> elliott : anyway, that doesn't play well with default implementations
17:00:11 <elliott> ski: Sure, sure. But that's just sugar :P
17:02:50 <ski> mk : `compare' is defined in terms `(==)' and `(<=)' -- and `(<=)' is defined in terms of `compare' -- see <http://darcs.haskell.org/packages/base/GHC/Classes.hs>
17:04:35 <dmwit> I think mk may be the most successful troll this channel has seen for a while.
17:04:41 <dmwit> Even feeling that way I couldn't resist joining in.
17:05:46 <elliott> I have to say, I am reminded of the person who pointed to a long extension pragma at the top of the file and insisted this was a flaw in Haskell because it didn't have macros.
17:05:54 <elliott> *of a Haskell file
17:06:45 <ben> We should change the {-# LANGUAGE #-} synstax to import GHC.Extension.TypeFamilies or whatever
17:06:51 <ben> it'd look neater!
17:06:54 <mk> dmwit: I'm not trolling
17:07:00 * ski just thinks mk doesn't fully understands type classes yet, trying to understand them
17:07:15 <dmwit> Sorry, trolling is probably the wrong word. "troll" implies being malicious, which I don't believe mk is.
17:07:21 <tgeeky> mk: for what it's worth, you don't get to decide that ;o
17:07:38 <ski> elliott : what was the perceived problem ?
17:07:53 <elliott> #haskell gets very, very few malicious trolls. It gets a huge deluge of people who are disruptive without active malicious intent.
17:08:17 <elliott> That might say something about #haskell.
17:08:19 <ski> elliott : .. with the "long extension pragma", i mean
17:08:32 <mk> tgeeky: nah, trolling implies intent. Any inefficiency in communication is wasting as much of my time as it is of everyone else's
17:09:00 <elliott> ski: Extensions were "ad-hoc" in some ill-defined sense... basically the problem is that Haskell wasn't Lisp. The fact that you can't implement, e.g. GADTs with a few Lisp macros was lost on them, because they didn't actually know what any of the extensions did.
17:09:09 <tgeeky> mk: I'm just commenting that, a person (who may|may not) be a troll, says, "I'm not a troll!", it does not change things much.
17:09:35 <elliott> ben: Like Python?
17:09:46 <mk> tgeeky: agreed
17:09:55 <dobblego> mk: shouldn't you be off writing instance Eq (a -> b) ?
17:09:56 <ben> i was thinking of perl, but i guess python might be closer
17:10:08 <elliott> dobblego: wat
17:10:11 <ski> elliott : well, macros are generally best for isolated things that don't interact in non-uniform ways
17:10:12 <mk> anyway, I do understand that types can be added to existing typeclasses
17:10:22 <elliott> ski: I don't mean to imply I, in any way, agree with the person in question :P
17:10:37 <dobblego> elliott: it was last night's (UTC+10) circular, non-progressive discussion
17:11:10 <ski> elliott : didn't think you did :)
17:11:11 <elliott> dobblego: was someone arguing Eq (a -> b) could be written or something? for all a, b?
17:11:27 <dobblego> elliott: worse than that, but yes
17:11:34 <elliott> _worse_ than that?
17:11:40 <dobblego> elliott: the point was the discussion went in circles
17:11:44 <elliott> my condolences
17:11:49 <mk> my point is (and has been) that typeclasess should as a rule bring together something in common among the types they contain, and that the commonality can be tracked via a function
17:12:17 <dmwit> To the first part: yes! To the second part: wat.
17:12:18 <ski> mk : i agree with that, except the "that the commonality can be tracked via a function" part at the end
17:12:23 <dmwit> ?hackage data-default
17:12:24 <lambdabot> http://hackage.haskell.org/package/data-default
17:12:26 <elliott> mk: So what, exactly, are you suggesting we change in Haskell?
17:12:36 <mk> ski: awesome - why not the function part?
17:12:42 <mauke> mk: ^ that link
17:12:44 <elliott> because it's incoherent
17:12:51 <irene-knapp> well, they're actually implemented in terms of dictionary functions, right
17:12:57 <geekosaur> it's not necessarily a single function
17:13:01 <ski> mk : i would have said "function*s*", or better, "operations/methods" (they don't have to be functions)
17:13:27 <aristid> and associated types :D
17:13:34 <ski> aristid :)
17:13:47 <mk> elliott: changing haskell would be dumb, but if there's really nothing wrong with using typeclasses to group arbitrary types then I'm totally missing what typeclasses are used for
17:14:05 <aristid> mk: most typeclasses do group related things
17:14:05 <dmwit> Actually, associated types aren't really a class-specific thing. They're only associated with type classes to give better error messages.
17:14:27 <dmwit> Anything you can do with associated types can be done with boring old type families, instead.
17:14:37 <ski> mk : the point of a type class is certainly to define some kind of common interface, usually with associated laws in terms of the methods, to which one can declare certain types (or combinations of types) to be instances
17:14:42 <mk> ski: yeah, functions are close enough. I don't see the difference between an operation or method and a function.
17:14:42 <elliott> mk: typeclasses offer generic interfaces so that implementations of the same concepts for different types and semantics can be unified
17:14:44 <aristid> mk: but it isn't obvious that there is no sensible way to have a typeclass that just happens to contain exactly Bool and Weekend. unlikely perhaps, but hard to rule out
17:14:49 <elliott> which also allows the authorship of code generic on these typeclasses
17:14:53 <elliott> that works on many concrete types
17:14:55 <elliott> does this help?
17:15:01 <elliott> yes, typeclasses are defined by their members.
17:15:02 <ski> mk : functions are things which take an argument, having a type like `... -> ...'
17:15:12 <elliott> ski is right about the function thing
17:15:22 <elliott> class Foo a where foo :: a  -- foo isn't necessarily a function at all, e.g. a = Int
17:15:41 <mk> aristid: yeah, agreed - but if someone's defining it, and they can't tell you what that commonality is, they're doing something dumb, yes?
17:16:11 <aristid> mk: i don't know of anybody having defined such a typeclass, so i don't know
17:16:24 <elliott> is mk's question simply "are typeclasses meant to mean something"?
17:16:40 <elliott> if so, then the answer is yes, there is no disagreement, and there is nothing to talk about.
17:17:00 <aristid> nothing in the language _forces_ you to write typeclasses with meaning
17:17:08 <elliott> thus "should"
17:17:11 <aristid> the same goes for functions and types and...
17:17:23 <ski> mk : however, you *do* need both `(+)' and `(*)' to define an instance of `Num'
17:17:40 <ski> mk : and for `Ord', you can define *either* of `compare' or `(<=)'
17:17:46 <mk> elliott: no, because I was trying to have a concrete answer to "what does it mean for a typeclass to mean something" (since a typeclass means something is useless otherwise), and what I came up with was "a certain function"
17:17:55 <elliott> mk: ok, then you are wrong
17:17:56 <ski> there isn't simply any *single* method which is required
17:18:04 <elliott> a typeclass represents a certain concept -- consider, e.g. a mathematical structure
17:18:07 <aristid> mk: or multiple functions that make sense to go together
17:18:07 <mauke> consider... Monad!
17:18:12 <elliott> we have lots of typeclasess for those
17:18:16 <elliott> Monoid, Functor, Category, and indeed Monad
17:18:29 <mauke> Functor only has a single method
17:18:30 <ski> mk : if you define `compare' then you don't have to define `(<=)' -- and vice versa
17:18:33 <elliott> we have a typeclass for things that have an equality relation, Eq
17:18:38 <elliott> that admit a total ordering, Ord
17:18:39 <elliott> and so on
17:19:09 <elliott> we have some numeric typeclasses which aren't very nice but are coherent (if overly vague) enough to cover the majority of numeric code in practice
17:19:10 <elliott> etc.
17:19:32 <elliott> anyway, a function has no inherent meaning either, so it's silly to say a typeclass gets its meaning from a function.
17:19:39 <thelastnode> what's the "right" way to find the maximum element in a list's index?
17:19:56 <geekosaur> there is, despite earlier attempts to show otherwise, no single function that defines a mathematical ring
17:20:41 <ben> what about the function that takes tuples of sets and functions and checks the ring laws :v
17:21:35 <ski> thelastnode : finding the indices of the maximum elements ?
17:24:11 <ski> > (fst . maximumBy (comparing snd) . zip [0 ..]) [2,8,5,7,1,4,2,8,5]
17:24:13 <lambdabot>   7
17:24:14 <ski> > (fst . maximumBy (comparing snd) . zip [0 ..]) [2,8,5,7,1,4,2]
17:24:16 <lambdabot>   1
17:24:30 <ski> interesting
17:25:55 <byorgey> huh, I wouldn't have expected that either
17:27:35 <thelastnode> ski: yes, the indices of all maximum elements
17:28:28 <dmwit> If you want all indices, then you'll need to do two passes over the list.
17:28:52 <dmwit> > let maxIndices xs = findIndices (maximum xs ==) xs in maxIndices [2,8,5,7,1,4,2,8,5]
17:28:53 <lambdabot>   [1,7]
17:29:25 <thelastnode> dmwit: ah, findIndicies, that's what I'm looking for, thanks
17:29:50 <ski> thelastnode : left as an exercise to define this in a single-pass way
17:30:27 <dmwit> Oh, I suppose a single pass is possible after all.
17:30:38 <dmwit> clever =)
17:30:57 <ski> well -- sortof
17:31:26 <thelastnode> ski: sort of?
17:31:43 <clsmith> sure it is
17:31:55 <elliott> it won't be any faster though, will it? just nicer on GC
17:31:56 <clsmith> just a quick foldl, surely
17:31:56 <ski> the obvious way would generate the indices on the way back -- which wouldn't allow traversing very long lists
17:32:01 <dmwit> Yeah, I'm curious what the caveat ski is thinking of is, too.
17:32:07 <Phlogistique> I think I hid haskell98 for a reason, but  http://sprunge.us/eAIX
17:32:17 <clsmith> ski: what?
17:32:23 <clsmith> i can think of a way with foldl
17:32:29 <ski> i suppose `foldl' would also do it
17:32:48 <dmwit> Phlogistique: Use System.Random instead.
17:32:58 <ski> but it won't be incremental, either way
17:33:11 <clsmith> you could do it incrementally, i think?
17:33:12 <elliott> an incremental algo that involves finding a maximum would be interesting
17:33:16 <elliott> no, you can't
17:33:21 <elliott> what if you see 3, 4, 5, 3, 4, 4
17:33:26 <elliott> but 500 terabytes later there's a 999
17:33:33 <Phlogistique> dmwit: thanks
17:33:39 <elliott> you can't produce any indices until you reach the end of the list, because otherwise there could always be bigger elements
17:33:54 <dmwit> elliott: You can, however, lazily produce a monotonically increasing subsequence.
17:33:56 <Phlogistique>     Could not find module `System.Random'
17:33:58 <Phlogistique> though
17:34:00 <dmwit> (And this is sometimes useful.)
17:34:02 <clsmith> elliott: so you just hang on to the max elem and ditch the list of indices if you find a bigger one
17:34:20 <Phlogistique> I'll just install it
17:34:22 <ski> elliott : with an improving-approximation type for the indices, one could do something slightly better ..
17:34:24 <clsmith> oh! you mean like, lazily?
17:34:36 <clsmith> misunderstood. yes then, i agree :p
17:34:37 <ski> hm, or could one ?
17:34:56 <ski> hm, no, i was confused
17:35:02 <dmwit> You could make a pretty lazy maximum out if your numbers are lazy, too. =)
17:35:08 <elliott> ski: well, sure
17:35:11 * Cale writes too-long comments on reddit: http://www.reddit.com/r/math/comments/rmvt2/so_how_on_earth_did_euler_discover_this/c473ji9
17:35:13 <elliott> dmwit: also true
17:35:21 <dmwit> Phlogistique: Can you double-check that you have the "random" package installed (and unhidden)?
17:35:25 <clsmith> dmwit: how so?
17:35:30 <ski> dmwit : improving interval types are interesting
17:35:57 <dmwit> clsmith: If you see a (Succ Zero) in your list, you can output a Succ before recursing. =)
17:36:12 <clsmith> oh, neat
17:36:33 <clsmith> (in a kind of pointless way :p)
17:36:52 <ben> That's what enables fix error though
17:36:54 <clsmith> although i guess if you used it for lazy Ord...
17:37:08 <ski> dmwit : i'd like a real number type like that -- would be useful for interval-halving stuff e.g.
17:37:33 * ski saw some paper about this, can't recall where :/
17:42:44 <scooty-puff> a pedantic question: when using ghc's "Any k" in some other type where i don't care about k, is forall k . MyType (Any k) or MyType (forall k . Any k) preferable?
17:42:56 <scooty-puff> i'm leaning towards the former
17:43:56 <scooty-puff> mostly because of what its suggestive of, even though the semantics of either way won't matter to unsafeCoerce i wouldn't think
17:44:21 <ski> @kind Data.Monoid.Any
17:44:22 <lambdabot> *
17:44:31 <scooty-puff> o, mean ghc.<...>.Any
17:44:43 <scooty-puff> GHC.Prim.Any
17:44:50 <scooty-puff> @kind GHC.Prim.Any
17:44:51 <lambdabot> *
17:44:55 <scooty-puff> uh wut
17:45:00 <scooty-puff> ok, nm
17:45:19 <dmwit> Thank goodness for Haskell's rich kind system!
17:45:29 <dmwit> That's sort of... half a joke.
17:45:48 <scooty-puff> i really do like where the new kind system is going, though probably not what you meant
17:45:54 <ski> polymorphic types for all !
17:46:12 <Cale> I like where it's going, but I really dislike how flaky the implementation seems to be at present
17:46:18 <scooty-puff> yes
17:46:41 * ski isn't sure he likes the automatic lifting stuff
17:46:52 <scooty-puff> i really need to not complain until i have a ticket opened..
17:48:36 <elliott> ski: i'm sure i don't :(
17:48:42 <elliott> but the rest of it is great
17:49:22 <scooty-puff> instead use a distinguished kind MyKind = ... or comparable?
17:49:36 <scooty-puff>  i have not read in to any of the other suggested methods, so a little ignorant here..
17:49:39 <elliott> oh, the lifting stuff is fine
17:49:40 <Cale> It's annoying that kind inference is now broken if you don't turn on PolyKinds, but PolyKinds + RankNTypes -> panic.
17:49:44 <elliott> i just don't like the fact that the ' is optional before it
17:49:51 <Cale> er, not RankNTypes sorry
17:49:51 <elliott> Cale: panic how?
17:49:55 <Cale> ScopedTypeVariables
17:50:02 <elliott> scooty-puff: in that it merges two namespaces that can and do have very common overlap
17:50:08 <elliott> ("newtype Foo = Foo ..." -- overlap)
17:50:11 <scooty-puff> yeah, that i have run in to a bit
17:50:21 <Cale> There're a couple tickets out for the thing I'm referring to
17:50:34 <elliott> oh, another benefit for requiring ' would be that it gives a nice syntax when we get lifting of some functions
17:50:39 <elliott> which i hear is coming
17:50:41 <scooty-puff> not a fan of the ' aesthetically, but i'd be more fine with it if it always had to be used
17:50:44 <elliott> 'foo 'Blah 'Blah
17:50:57 <scooty-puff> o wow
17:55:15 <Elemir> Guys, what is a easiest way of reading Int32 from Handle?
17:55:43 <Elemir> *the
17:56:55 <Elemir> hGetBuf?
17:57:41 <elliott> Depends what format you want to read it in.
17:57:43 <c_wraith> Elemir: the best way is read 4 bytes with read (the bytestring version), then unpacking it with something like cereal or binary
17:58:12 * Elemir thinks about binary too
17:58:25 <donri> i thought you wanted the file descriptor
17:58:59 <Elemir> No, I want size of package :)
18:00:35 <elliott> size of package?
18:01:05 <Elemir> Yes, some protocol specific
18:11:43 <taiyal> Is Haskell Platform 2011.4.0.0 on Windows reasonably up-to-date?
18:12:25 <elliott> the haskell platform is reasonably up to date
18:12:33 <elliott> and that is the latest platform
18:12:33 <elliott> so yes
18:12:34 <elliott> 3 months old
18:13:48 <monochrom> it's the best point between "new" and "compatible"
18:15:32 <ski> elliott : i never liked naming the data constructor the same as the type constructor, anyway :)
18:16:08 <elliott> i think it is best for newtypes
18:16:14 <elliott> in fact i think newtypes should do that automatically, perhaps
18:16:19 <elliott> for data types, no
18:16:20 <monochrom> it's a bother to think of a 2nd name
18:16:25 <elliott> except for tuples :p
18:16:27 <elliott> or records
18:16:30 <elliott> ok, i just disagree then
18:16:35 <scooty-puff> is there anything i can do to run ghc in a more memory protected mode to get maybe a stack trace on seg fault?
18:16:50 * ski uses `newtype Foo = MkFoo ...', if he can't think of a better name
18:16:50 <elliott> scooty-puff: really, you're not meant to get segfaults.
18:16:57 <elliott> unless you're using the FFI, whittle down a test case, and report a bug
18:17:32 <scooty-puff> yeah, thats whats so disheartening about it - and it didn't happen on this large project until a core data structure was changed around some
18:17:50 <scooty-puff> once it unnerves me enough, i'll see about getting a decent test case
18:20:27 <rasfar> scooty-puff: you have done a squeaky-clean rebuild?  maybe your makefiles or ghc --make is at fault.
18:20:41 <elliott> scooty-puff: well, you should report it even if it doesn't unnerve you: otherwise the GHC devs might never know of it, and the bug will continue to languish.
18:20:44 <elliott> hmph, already left
18:25:43 * rasfar 's gotta say, he soOOoooh loves this language.  among the many other things where it shines, it's really a joy for playing around with graphs/networks.  (all my instincts are still simple pattern-matching and combinator-oriented Haskell programmer though)  what a sheer joy it is!
18:30:10 <ion> Whee, using HMatrix (and the node method) to solve an electric circuit with a few MOSFETs approximated by input-controlled resistors and iterating over possible inputs was surprisingly easy.
18:30:34 <rasfar> =) case in point!
18:31:49 <ion> It worked the first time i tried running it. :-)
18:32:17 <ski> rasfar :)
18:32:25 <ion> The purpose of this exercise was to grasp the node method much better, and that did happen.
18:32:48 <rasfar> yeah -- once you managed to get it to compile, right?  so true what is said about strong statically typed languages (or at least this one)...
18:34:08 <ion> rasfar: I didn‚Äôt actually use a graph to represent the circuit, just some linear equations (encoded in matrix form) representing the node voltages in the circuit.
18:34:20 <ion> rasfar: The program was trivial enough and i was lucky enough for there not to be any type errors.
18:35:56 <ion> Oh, sorry, i forgot: i had to switch from Numeric.LinearAlgebra.linearSolve to Numeric.LinearAlgebra.linearSolveSVD before it worked. :-)
18:36:10 <rasfar> impressive.  i met a guy on a fountain-pen forum who claimed he could write huge assembly programs with no errors first try (b/c of some mental-model prowess) and had awards to prove it.  well, most of us would prefer strong type checking...
18:36:12 <ion> Another solver that handles the format of my matrix.
18:37:27 <rasfar> (if i actually scale up my current project to larger datasets i'll need to explore matrix representations, but for now it's just list-based)
18:40:44 <mk> are two IOs containing the same string ==?
18:41:23 <luite> there is no Eq instance for IO, you can't really make one either
18:41:39 <ski> @quote /bin/ls
18:41:39 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
18:41:41 <ski> mk ^
18:42:34 <luite> mk: (==) :: (Eq a) => a -> a -> Bool, if you wanted to compare the strings for IO String, you'd get an IO Bool instead of a Bool
18:42:35 <mk> luite: ski: all of that makes sense - thanks
18:43:16 <mk> luite: I see
18:43:48 <ski> @type liftM2 (==) :: Eq a => IO a -> IO a -> IO Bool
18:43:49 <lambdabot> forall a. (Eq a) => IO a -> IO a -> IO Bool
18:45:24 <taiyal> _800_ MB for the Haskell Platform!?
18:45:46 <mk> as far as I understand things, [] is similar to IO, but you can get the first value in a list without it being listy... is that right?
18:45:51 <elliott> no
18:45:51 <taiyal> what's in there that requires it to be bigger than a Debian install disc?
18:45:56 <elliott> mk: (IO a) is a description of some IO that could be done to produce a value of type a
18:46:01 <ion> @type liftA2 (==) `asAppliedTo` (undefined :: IO a)
18:46:02 <lambdabot> forall a. (Eq a) => IO a -> IO a -> IO Bool
18:46:09 <elliott> it might be executed zero, one, or fifty billion times during the course of a program
18:46:14 <elliott> it does not contain any "a"s at all
18:46:35 <elliott> for instance "print 'hello world', then ask the user for a line, and return that" is a description of some IO, in this case the type would be IO String
18:46:43 <geekosaur> taiyal, ghc and core libraries in multiple forms
18:46:56 <elliott> there's no string "inside" it
18:47:01 <elliott> but you can compose bigger IO computations out of it
18:47:14 <elliott> and indeed, one such IO computation, main, is actually executed by the runtime system, which is the whole point :)
18:47:48 <elliott> thus, just as /bin/ls contains description of some IO to do to produce a listing of files, but does not actually contain them, an IO String contains a description of some IO to produce a string, but not a String
18:47:59 <mk> elliott: is it merely inappropriate to think of IO as containing a value, or incorrect because Haskell doesn't even implement it that way?
18:48:25 <ski> it's incorrect
18:48:26 <elliott> it's inappropriate and incorrect
18:48:37 <elliott> (and haskell implements nothing, implementations of haskell do)
18:48:38 <ski> the value doesn't exist at the time the action does
18:48:42 <elliott> for instance getLine couldn't possibly contain one string
18:48:50 <ski> @type getLine
18:48:50 <elliott> getLine is a single value, but it would have to "contain" every string you could possibly enter
18:48:51 <lambdabot> IO String
18:48:52 <rasfar> lol #haskell = tough love :)
18:48:58 <elliott> which is, of course, nonsense
18:49:01 <danharaj> A decent way of thinking of (IO a) is a demand to the runtime for a value.
18:49:18 <elliott> the description model is nicer, no implementation details :)
18:49:23 * ion creates a Haskell implementation in which getLine contains one string.
18:49:29 <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'
18:49:36 <ski> the recipe is not the cake
18:49:54 <danharaj> Let's step away from food analogies
18:49:56 <elliott> @remember ski <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
18:49:57 <lambdabot> Good to know.
18:49:58 <danharaj> I don't want to end up in burrito-land.
18:51:17 <ski> mk : `IO' is similar to `[]' in that both are parameterized types -- however there aren't much more similarity than that
18:51:42 <mk> I think I understand how that works when it comes to a single input-output sequence - you define many things in your program, and then you "pull them into" IO... is that right enough?
18:51:52 <ski> mk : also, note that even if you have a value of type `[] String' (i.e. `[String]'), that doesn't necessarily contain a `String' either (it can be the empty list)
18:51:52 <elliott> depends what you mean by "pull them into"
18:52:04 <elliott> ski: they're similar in that neither of them necessarily contain the value they're parametrised on... in IO's case, it never does :P
18:52:06 <elliott> heh, snap
18:52:11 <elliott> *contain a value of the type
18:52:32 <ski> elliott : they are also similar in that they are both covariant functors (in fact monads)
18:52:42 <ski> (of course you know this)
18:52:58 <elliott> ski: their names are also both two unicode codepoints long!!!
18:53:08 <elliott> it's like some kind of conspiracy
18:53:16 <mk> elliott: it means that IO really does contain every single string possible from the perspective of the rest of haskell, but from the perspective of the single execution, it contains one
18:53:17 <ski> well, that's a more accidental similarity, no ?
18:53:32 <elliott> ski: that's what they want you to believe...
18:53:32 <danharaj> IO is not a container.
18:53:35 <ion> And both of the names consist of alphabetic characters, except []!
18:53:41 <elliott> mk: well, no, an (IO a) never contains an a, from any perspective
18:53:50 <ski> mk : no : consider `let foo = getLine in do x <- foo; y <- foo; return (x,y)'
18:53:50 <elliott> going with this example:
18:53:50 <elliott> <elliott> for instance "print 'hello world', then ask the user for a line, and return that" is a description of some IO, in this case the type would be IO String
18:54:02 <elliott> mk: what the runtime system does is look at main, which looks like a description like this
18:54:14 <elliott> it executes the IO it describes, then plumbs the result it gets on to further actions
18:54:22 <elliott> at no point does getLine ever start to contain a String
18:54:28 <ski> mk : this is a *single* `IO'-action `foo' (which is a value), which is *executed* twice to yield two (presumably) different `String's
18:54:38 <elliott> the RTS just executes the IO, turning it into a String
18:54:43 <danharaj> Think of your program as a coroutine with the rest of the world.
18:54:46 <elliott> turning as in, transforming, with an impure process
18:54:51 <elliott> not changing :)
18:55:18 <elliott> mk: similarly: /bin/ls does not contain the contents of the current directory from the perspective of a single /bin/ls process
18:55:27 <danharaj> your program asks the real world for values it needs to continue
18:55:38 <danharaj> sometimes you give the real world a value, like with print.
18:56:11 * ski . o O ( `main :: [Response] -> [Request]' )
18:56:35 <mk> ski: are those... backwards?
18:56:37 <elliott> ski: :(
18:56:46 <elliott> mk: no, ski is referencing an old and hideous method of IO haskell used to use
18:56:57 <ski> (with `data Request = PutChar Char | GetChar | ...' and `data Response = CharPut | CharGot Char | ...')
18:57:00 <elliott> i dearly hope he refuses to respond to any requests to explain it :)
18:57:02 <ski> mk : nope
18:57:56 <elliott> mk: (this model has _no_ relation to the current model of haskell IO)
18:58:00 <ski> (in this pre-monadic model of I/O, the program would generate a list of requests to the system, and the system would respond with a list of responses being passed back as input, in a cyclic way :)
18:58:28 * ski was just thinking of this due to danharaj's comments above
18:58:38 <mk> ski: (was that pure?)
18:58:43 <ski> mk : yes
18:58:54 <ski> but the monadic way composes and scales better
18:59:27 <donri> hey got any example code for that?
18:59:36 <elliott> donri: sure:
18:59:37 <donri> for people who are into horror movies
19:00:11 <elliott> donri: main rs0 = GetChar : case rs0 of CharGot c : rs1 -> PutChar c : case rs1 of CharPut : rs2 -> [Exit]
19:00:11 <scooty-puff> in case my internet was being flaky at the time: if you tried to evaluate an Any to whnf, would the underlying value be in whnf - for GHC.Prim.Any
19:00:13 <elliott> or such
19:00:22 <elliott> you just only look at the response after you push the request out
19:00:29 <elliott> or do you mean real example code?
19:00:34 <donri> yea
19:00:36 <elliott> I think everyone went through the continuation-based wrapper at the time
19:00:40 <elliott> though I don't actually know
19:00:44 <clsmith> hey. i'm trying (for fun) to write a data Nat = Zero | Succ Nat, but when i say "maximum [Zero ..] > Zero" it tries to evaluate all of [Zero ..]. i even wrote my own maximum to make sure it was defined as i'd expect. but it always hangs. any ideas? (should i paste the code?)
19:01:10 <elliott> clsmith: what's your def. of maximum? just write it on one line, no need to paste
19:01:14 <elliott> unless it's really long i guess :
19:01:15 <elliott> :p
19:01:42 <clsmith> maximum (x:xs) = f x xs where f y (x:xs) = f (max x y) xs; f y []     = y
19:01:57 <ski> well, typically you'd define `type Dialogue = [Response] -> [Request]', and then you could do `putChar :: Char -> Dialogue -> Dialogue; putChar c cont ~(CharPut:resps) = PutChar c : cont resps' and `getChar :: (Char -> Dialogue) -> Dialogue; getChar c_cont ~(CharGot c:resps) = GetChar : c_cont c'
19:02:12 <elliott> clsmith: ok, well that's easy
19:02:15 <ski> also defining `end :: Dialogue; end ~[] = []'
19:02:16 <elliott> clsmith: your f is tail-calling all the way
19:02:20 <elliott> how can it ever produce a value before it reaches the []?
19:02:25 <clsmith> oh, i need to actually say Succ in the maximum?
19:02:37 <elliott> clsmith: well, you're going to have to explicitly do that kind of thing, yes
19:02:40 <donri> i can sort of see how that lead to monads
19:02:42 <clsmith> i was hoping the max x y would lazily evaluate...
19:02:45 <elliott> it does
19:02:48 <elliott> but look
19:02:52 <elliott> f ... = f ...
19:02:59 <elliott> that can never produce a value until you reach a base-case, by definition
19:03:00 <ski> donri : however, now we can define `type IO a = (a -> Dialogue) -> Dialogue' and recover the monadic way :)
19:03:45 <clsmith> elliott: but, i don't know, by my logic y was .. i don't know, in retrospect i was expecting the compiler to be magical.
19:03:52 <clsmith> thanks ^^;
19:04:24 <elliott> i can't think of a nice definition for maximum on [Nat] :/
19:04:35 <elliott> ski: right, so CPSing
19:04:51 <elliott> (IO = Cont Dialogue there, obviously)
19:06:22 <ski> donri : see end of <http://code.haskell.org/~dons/code/gofer-prelude/Prelude/Gofer.hs> for some actual code
19:06:29 <ski> elliott : *nod*
19:06:33 <scooty-puff> answered my own question with "unsafeCoerce (trace "hi" True) :: Any `seq` ()"
19:06:53 <ski> scooty-puff : positively ?
19:07:28 <scooty-puff> yes
19:07:38 <scooty-puff> or to be completely explicit: it prints "hi"
19:07:42 <Elemir> Hem. How many IO concepts are there in haskell?
19:07:51 <copumpkin> one
19:08:10 * Elemir knows four
19:08:15 <Cale> Elemir: what do you mean by that?
19:08:20 <Elemir> Base IO monad, regions, iteratee and sink
19:08:29 <copumpkin> o.O
19:08:46 <ski> clsmith : `maximum [x] = x; maximum (x:xs) = max x (maximum xs)'
19:09:05 <Elemir> And base IO monad supports lazy and strict IO
19:09:11 <mauke> clsmith: that looks insufficiently lazy
19:09:16 <mauke> er, ski
19:09:21 <mauke> dammit
19:09:31 <Cale> Elemir: There are an unbounded number of libraries which use IO...
19:09:40 <ski> mauke : depends on `max'
19:09:53 <ski> hmm
19:10:07 <Cale> Elemir: but most of that stuff isn't part of the Haskell language itself
19:10:11 * Elemir says about concepts that provide interface for IO
19:10:30 <elliott> Elemir: Impossible to answer without a definition of "concept".
19:10:42 <elliott> Especially since Oleg-style regions are AFAIK not actually related to doing IO at all except that they're useful for it.
19:10:59 <elliott> ...and I don't know what "sink" is other than as part of conduit, which would seem to rather overlap with "iteratee" there somewhat
19:12:55 <ski> mauke : you're right
19:13:40 * Elemir understand regions as `divide et impera' principle for IO (not for I/O)
19:14:37 <clsmith> why *is* that insufficiently lazy?
19:15:18 <elliott> is it? i think with a sufficiently lazy max it's fine
19:15:31 <copumpkin> elliott: if max is really lazy
19:15:37 <elliott> well, that's the idea :)
19:15:41 <Elemir> @src max
19:15:41 <lambdabot> max x y = if x <= y then y else x
19:15:42 <ski> clsmith : well, for my one, `maximum [a0,a1,a2,...]' expands to `max a0 (max a1 (max a2 (...)))', and because `max' is strict in both arguments, this doesn't terminate
19:15:47 <elliott> max (Succ x) y = Succ (max x y) and such
19:15:49 <copumpkin> you might be able to get away with maximum (5:undefined)  = 5
19:15:53 <elliott> err, is that correct? w/e, you get the idea
19:16:04 <elliott> ski: right, but max doesn't have to be strict for Nat
19:16:06 <elliott> and it's part of Ord, iirc
19:16:08 <elliott> so you can override it
19:16:10 <clsmith> max x Zero = x; max Zero x = x; max (Succ x) (Succ y) = Succ $ max x y
19:16:15 <clsmith> that's my max
19:16:18 <elliott> clsmith: too strict
19:16:21 <elliott> strict in both arguments
19:16:26 <elliott> because you pattern-match them against Zero to start with
19:16:40 <elliott> you need to start producing constructors before you even look at your right argument
19:16:46 <copumpkin> > max GT LT
19:16:47 <lambdabot>   GT
19:16:47 <ski> elliott : yeah, i was pondering if one could make it non-strict
19:16:58 <ski> > max GT undefined
19:16:59 <lambdabot>   *Exception: Prelude.undefined
19:17:01 <copumpkin> so say you have a bounded thing where max (GT) doesn't check
19:17:07 <clsmith> ahh, is that because pattern matching is strict? (that's one of those things i've never really internalised)
19:17:19 <copumpkin> then you should be able to stop as soon as you find the upper bound
19:17:21 <elliott> clsmith: it has to be -- how can you tell what a value is before you've even got it? :)
19:17:26 <ski> clsmith : pattern-matching *is* what makes things strict
19:17:28 <copumpkin> thus avoiding a crash on maximum (5:undefined)
19:17:42 <elliott> right, pattern-matching is the only "benign" way you get strictness in the first place
19:17:57 <clsmith> i see, so we need maximum to be 'special' in and of itself?
19:18:01 <elliott> no
19:18:04 <elliott> you just need to fix max
19:18:12 <elliott> and use ski's maximum
19:18:27 <copumpkin> wait, did he fix it?
19:18:29 <clsmith> ohhh, i see how
19:18:30 <clsmith> right
19:18:42 * ski hasn't suggested any fixed `max' for `Natural'
19:18:44 <elliott> max Zero y = y; max (Succ x) y = Succ (case y of Zero -> x; Succ z -> max x z)
19:18:47 <elliott> or something like that
19:18:53 <copumpkin> I'm talking about the definition of maximum
19:19:01 <elliott> copumpkin: <ski> clsmith : `maximum [x] = x; maximum (x:xs) = max x (maximum xs)'
19:19:09 <copumpkin> yes, and that's too strict by what I've been saying :P
19:19:16 <elliott> why?
19:19:19 <ski> elliott : *nod*, looks like it could work
19:19:24 <copumpkin> [x] is pattern matching two levels deep
19:19:35 <elliott> does that matter?
19:19:42 <copumpkin> for the example I keep giving, yes
19:19:42 <elliott> the idea is that maximum [1, ...] will produce a Succ constructor immediately
19:19:45 <elliott> (for any ...)
19:19:51 <elliott> we don't care about (5:undefined)
19:19:53 <elliott> at least, I don't
19:20:07 <elliott> maximum [0..] should == fix Succ
19:20:10 <elliott> *===
19:20:14 <copumpkin> should it?
19:20:15 <ski> s/===/=/ :)
19:20:18 * hackagebot shelly 0.3.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.3.1 (GregWeber)
19:20:21 <elliott> copumpkin: well, that's the whole idea
19:20:21 <copumpkin> oh I geuss so
19:20:30 <elliott> ski: meh, = is used for definitions
19:20:32 <copumpkin> but I don't see why you don't care about the other case
19:20:37 <elliott> I like to try and keep =, ==, === straight
19:20:43 <ski> elliott : definitions is a special case of (semantic) equality
19:20:46 <copumpkin> why not terminate early where possible?
19:20:50 <elliott> (although I prefer IDENTICAL TO when not on such a rapid-fire medium as IRC)
19:21:04 * ski prefers using `=' for equality
19:21:14 <elliott> ski: well, sure -- but when I say "foo = bar", I mean that as an assertion/definition of foo as bar
19:21:23 <ski> elliott : depends on the context
19:21:24 <elliott> whereas "foo === bar" is a mere statement about foo and bar, it doesn't cause foo to be interpreted as bar in itself
19:21:26 <elliott> just states that it is
19:21:34 <elliott> ski: well, that's why I said "when I say" :) (modulo my inevitable inconsistency)
19:21:40 * copumpkin shrugs
19:22:00 <ski> `foo = bar' on it's own "doesn't cause foo to be interpreted as bar in itself", either
19:22:03 <clsmith> that works :) thanks all
19:22:04 <elliott> copumpkin: well, what maximum do you propose?
19:22:21 <copumpkin> a much trickier one to write! :P
19:22:37 <elliott> ski: well, for an example, if I said "succ x = x+1, therefore ..." what I mean is "I am asserting that 'succ x' is to be interpreted/defined as 'x+1', and therefore..."
19:22:40 * ski hates when texts write `:=' or `:<=>' or an `=' with three lines for definitions
19:23:00 <elliott> ski: if I said "succ x === x+1, therefore ...", what I mean is "I am asserting that the previously-established or hypothetical 'succ x' is equivalent to 'x+1', therefore ..."
19:23:14 <elliott> sdklfjhsdfjsdklf = (), therefore ... makes sense
19:23:23 <elliott> sdklfjhsdfjsdklf === (), therefore ... doesn't, unless sdklfjhsdfjsdklf has been previously-defined
19:23:33 <elliott> although "Assume we have sdklfjhsdfjsdklf such that sdklfjhsdfjsdklf === (). Then ..." does
19:23:49 <elliott> (consider "Assume we have f such that f (x+1) === x. Then ...")
19:24:49 <ski> yeah, that's shorthand for "Assume we have `f' such that `forall x. f (x+1) = x'. Then ..."
19:25:15 <ski> and because of the shape the the (universally quantified) equality, we can treat it as a definition, meaning it's a "free" assumption
19:25:23 <elliott> ski: no, it's shorthand for "forall x. f(x+1) === x" :)
19:25:31 <elliott> i agree that = is equality in most contexts
19:25:33 <ski> elliott : i'm claiming there's no difference
19:25:39 <elliott> yes - i'm disagreeing
19:25:46 <copumpkin> lol
19:25:54 <copumpkin> one does not simply disagree with ski
19:25:55 <elliott> "x = y" is not a proposition to me, "x === y" is
19:26:05 <elliott> "x = y" is a declaration or assertion
19:26:06 <ski> the difference is only that people often use `:=' or `===' or `:<=>' to hint that they are stating a definition
19:26:10 <elliott> (again, to me)
19:26:12 <kowalej> === as in equality?
19:26:41 <elliott> kowalej: yes (but not the (==) kind, the semantic kind)
19:28:38 <ski> in the case where one defines a Prolog predicate, like `member(A,[A|_]).  member(A,[_|As]) :- member(A,As).' there isn't even any `=' equality or `<=>' equivalence to attach the `:' sign hinting that this is a definition
19:29:13 <ski> elliott : so, i'm basically claiming that your declarations/assertions are special cases of propositions
19:29:36 <whittle> Haskell newb here, and wondering about linking: I was in GHCI, loaded the module System.Directory and called getTemporaryDirectory, at which point I got 5 messages about packages loading and linking. Is the fact that this happened only after I called the function a GHCI idiosyncrasy, or a more general Haskell strategy?
19:29:49 <clsmith> copumpkin: my Nat is unbounded, though i did add an explicit minimum (Zero:_) = Zero
19:29:58 <ski> and i want to highlight this by using `=' (alternatively `<=>' for relation-things) for both
19:29:58 <elliott> ski: well, "I assert P" is a declaration/assertion for any proposition P, and "'D' is a declaration that coheres with reality" is a proposition for any declaration/assertion D
19:30:03 <elliott> but I don't think they are the same thing
19:30:17 <elliott> clsmith: shouldn't need that with a similar min
19:30:33 <clsmith> really?
19:30:39 <clsmith> oh, ofc.
19:30:46 <BMeph> whittle: Yes! :)
19:31:17 <ski> the defining equations for an operation in a Haskell program are equalities, albeit equalities of a restricted shape -- i want to emphasize that they are true propositions about the program
19:31:33 <elliott> clsmith: min Zero _ = Zero; min (Succ x) Zero = Zero; min (Succ x) (Succ y) = Succ (min x y)
19:31:39 <elliott> or such.
19:31:47 <mauke> whittle: it's a ghci thing
19:31:54 <clsmith> elliott: i've got the same, except with min _ Zero
19:32:03 <elliott> clsmith: no, that's bad
19:32:09 <elliott> too strict... or, hmm
19:32:14 <elliott> it's ok if it's after the first clause
19:32:18 <elliott> but it's redundant anyway :)
19:32:41 <clsmith> i meant instead of min (Succ x) Zero
19:33:09 <elliott> ah
19:33:09 <whittle> BMeph, mauke: So that part would normally occur during the linking phase, not the execution phase, correct?
19:33:26 <whittle> I think maybe I‚Äôve been using interpreted languages too long.
19:33:27 <ski> elliott : ok, now i think you don't use "declaration/assertion" in the same sense as before (now you appear to mean the same as "judgement")
19:33:40 <mauke> whittle: "interpreted language" :-[
19:33:42 <clsmith> that's a question, though. why did we need max (Succ x) y = Succ $ case y of ...? would it otherwise be strict even if the match on the second argument isn't the first clause?
19:34:04 <elliott> ski: well, the way I see it, if I say "x = y" to you, you can't "disagree", because I'm setting parameters for the discussion -- if I say "x === y", then you can disagree with me, and disprove it
19:34:12 <whittle> mauke: But I‚Äôm willing to improve!
19:34:20 <elliott> clsmith: it's not strict, because max (Succ whatever) _|_ isn't _|_
19:34:21 <elliott> it's Succ _|_
19:34:28 <elliott> ski: I can assert foo, and I can be wrong, and you can prove me wrong
19:34:46 <elliott> but if I declare "x = y", that's not something that can be disagreed with, at least in my usage
19:34:52 <elliott> I think I might have mixed up my terminology by now though :)
19:35:07 * ski is certainly confused by it
19:36:03 <elliott> i'm probably too tired to meaningfully articulate what i mean :)
19:36:12 <ski> elliott : in my mind, a definition consists of two things : (a) a (new) name; (b) a proposition in terms of that name, that uniquely determines a value for it
19:36:57 <ski> there are several useful common syntactical shapes for (b) (leading to the definition of which expressions can be used as patterns)
19:36:58 * rasfar recalls ski's views on this from the proofreading of freesect docs
19:37:32 <nus-> elliott, don't you need to prove the interpretation rules to the other side first?-)
19:37:35 <elliott> ski: i agree that i can use such a proposition to create an undisagreeable-with definition-assertion-thingy
19:37:51 <elliott> so, if you wish, consider "x = y" shorthand for "I declare x to be the unique value s.t. x === y"
19:38:07 <elliott> that's a completely valid expansion (and probably I consider it canonical), but the two sides aren't equal
19:38:11 <ski> and we have standard conventions for deciding how to insert implicit quantifiers into a definition, and determining what is being defined -- at least for common shapes of definitions
19:38:25 <clsmith> elliott: you've confused me. isn't min (Succ x) Zero strict in the second argument, so wouldn't we have to do a second case of?
19:38:49 <elliott> i was replying to <clsmith> that's a question, though. why did we need max (Succ x) y = Succ $ case y of ...? would it otherwise be strict even if the match on the second argument isn't the first clause?
19:38:57 <elliott> clsmith: min (Succ x) is strict
19:38:58 <elliott> but min Zero isn't
19:39:04 <elliott> which is what's important
19:39:15 <elliott> (because we don't know minimum [1..])
19:39:28 <elliott> (thus minimum [0..] === min Zero _|_ === Zero)
19:39:32 <rasfar> since pattern syntax is not (in general) valid as expression syntax, you can't really substitute LHS for RHS right?
19:39:48 <elliott> so, yes, min Zero _ = Zero; min _ Zero = Zero; min (Succ x) (Succ y) = Succ (min x y) is fine
19:39:57 <elliott> rasfar: indeed
19:40:03 <elliott> ski would like to make them closer ;)
19:40:11 <elliott> (is there a reasonable interpretation of a@b as an expression?)
19:40:19 <rasfar> heck, me too!
19:40:24 <ski> elliott : well, that wouldn't work (as-in) for `f x = ..x..' :)
19:40:42 <clsmith> but if we say max Zero y = y; max x Zero = Succ x; max (Succ x) (Succ y) = Succ (max x y); (which looks equivalent?) then max is strict in y
19:40:54 <elliott> rasfar: yeah but would _you_ go so far as f (\42 -> 3:xs) = xs?
19:41:04 <ski> rasfar : you can do it, when the expression is a valid instance of the pattern
19:41:08 <elliott> ski: well, sure it would, you just end up inserting an implicit quantifier on the rhs
19:41:10 <clsmith> uh
19:41:16 <rasfar> this is like n+k on steroids or so?
19:41:19 <clsmith> that, only substitute what i said for what i meant.
19:41:23 <elliott> clsmith: it's _not_ equivalent
19:41:32 <elliott> clsmith: the whole point of moving the case inside the Succ is that you can peel off the succ before looking at y
19:41:36 <elliott> so if y is _|_, you can look at the Succ
19:41:38 <ski> elliott : and yes, i think one could have a (more or less) reasonable interpretation of `a@b' as an expression :)
19:41:46 <elliott> whereas there, you examine them _both_ before producing _any_ constructor
19:42:01 <elliott> so a _|_ will explode on you before you produce any Succ, and the non-strictness required for maximum [0..] is destroyed
19:42:04 <clsmith> elliott: ahh. so a "sufficiently advanced compiler" could work that out, but ghc doesn't?
19:42:08 <ski> however, the constructions `_' and `id@pat' in patterns are to be compared with side-effects in expressions
19:42:10 <elliott> ski: hmm, what would it be?
19:42:10 <elliott> clsmith: no
19:42:16 <elliott> clsmith: a sufficiently smart compiler is not allowed to change semantics
19:42:25 <elliott> _|_ is part of haskell's semantics, it is not permissible to make a program more terminating
19:42:39 <ski> elliott : `xs @ (0 : xs)' would be equal to `let xs = 0 : xs in xs'
19:42:41 <clsmith> psh, fair
19:42:43 <elliott> it's simply a case of writing what you mean: when _|_s are involved, that means you have to be careful about where you examine values
19:42:51 <elliott> ski: oh, right!
19:42:52 <rasfar> _ in expressions should be like "don't-care" in HDL's
19:42:53 <elliott> yes, i actually like that
19:42:58 <clsmith> but yeah, that makes sense, thanks
19:43:01 <elliott> like lisp's circular object syntax
19:43:09 <rasfar> except that i'm reserving it for free section syntax once get over the reduce/reduce conflicts ;)
19:43:09 <elliott> clsmith: yw :)
19:43:20 <ski> elliott : `xs @ foo (ys @ bar xs ys)' would be equal to `let xs = foo ys; ys = bar xs ys in xs'
19:43:35 <mauke> LC :: a@(a -> a)
19:43:46 <ski> mauke : O'Caml has that
19:44:12 <elliott> ski: what does ~e mean as an expression? :
19:44:13 <elliott> :p
19:44:56 <ski> i'm not sure if it would have any non-trivial meaning
19:45:29 <elliott> yeah i guess ~e and !e are both e
19:45:51 <ski> `~<pat>' has a strange context-dependent meaning, anyway
19:46:16 <rasfar> could be useful in speculative evaluation of conditional branches perhaps?
19:46:22 <ski> also, if we added disjunctive patterns in addition to `_' and `@', those would also be a kind of side-effectful patterns
19:46:26 <elliott> ski: does it?
19:46:44 <elliott> (disjunctive pattern = p|q?)
19:46:52 <ski> (yep)
19:46:56 <elliott> ((see, here I'm /questioning/ you about your implicit definitions... ;)))
19:47:09 * elliott wonders what you'd need to add to the language to make p|q a meaningful expression too
19:47:21 <ski> disjuctive expressions could be useful -- in fact Agda sortof has a nullary disjuctive expression
19:47:29 <elliott> hmm, what's that?
19:49:06 <ski> well, consider `atIndex : {A : Set} -> {n : Nat} -> Vector A n -> Fin n -> A' with an equation `atIndex {A} {Zero} Nil ()'
19:49:14 <rasfar> two expressions which may have very different evaluation efficiencies depending on argument values?  on a multicore, both evaluated in parallel and the first to produce a head is used, the other computations terminated
19:49:15 <elliott> oh, right, yes
19:49:21 <elliott> i know that one
19:49:34 <elliott> not really an expression though
19:49:36 <rasfar> (referring to p|q)
19:49:37 <elliott> since you can't embed it in other expressions
19:49:44 <elliott> rasfar: that's impure :(
19:49:52 <elliott> rasfar: that's just unamb though
19:49:53 <rasfar> really? how so?
19:50:01 <elliott> (with the precondition that they must be equal if not _|_)
19:50:08 * rasfar looks up unamb...
19:50:14 <elliott> @hackage unamb
19:50:14 <lambdabot> http://hackage.haskell.org/package/unamb
19:50:14 <ski> this is basically the same as writing `atIndex {A} {Zero} Nil ^ = ^', where `^' means the always failing pattern/expression, which is an identity element for `|' (just like `_' is the identity element for (the generalized) `@')
19:50:15 <elliott> also see
19:50:16 <elliott> @hackage lub
19:50:16 <lambdabot> http://hackage.haskell.org/package/lub
19:50:19 <elliott> based on it
19:50:26 <elliott> rasfar: (reallySlow `seq` OneThing) | Another
19:50:27 <rasfar> thanks! more reading...
19:50:32 <elliott> rasfar: that === OneThing sometimes, and === Another some other times
19:50:42 <elliott> which is impure, ofc
19:50:48 <ski> elliott ^
19:50:54 <elliott> ski: right
19:51:11 <rasfar> okay! this sounds worth understanding, i'm making it a priority.  thank you
19:52:15 <ski> elliott : one can also consider stuff like `factor :: Either (a,b) (a,c) -> (a,Either b c); factor (Left (a,b) | Right (a,c)) = (a,Left b | Right c)'
19:52:47 <elliott> rasfar: it's just as impure, though -- since the precondition cannot be checked at all
19:52:57 <elliott> rasfar: but it lets you write _really_ lazy definitions
19:53:08 <ski> elliott : to allow `|' in expressions (in a determinate way), it has to be statically clear under which conditions each alternative will be chosen (and one and only one must be possible to choose)
19:53:09 <elliott> rasfar: here's reading material:
19:53:16 <elliott> rasfar: http://conal.net/blog/posts/lazier-functional-programming-part-1 http://conal.net/blog/posts/lazier-functional-programming-part-2
19:53:51 <rasfar> also reminiscent of the Eq instance on functions, which i really don't want to go there...
19:53:52 <ski> (elliott : .. then one could also allow `let', lambda expressions, and `case' in patterns)
19:54:10 <elliott> <ski> elliott : one can also consider stuff like `factor :: Either (a,b) (a,c) -> (a,Either b c); factor (Left (a,b) | Right (a,c)) = (a,Left b | Right c)'
19:54:12 <elliott> oh, this is clever
19:54:18 <elliott> although i'm not sure i like that kind of dependence on the pattern
19:54:26 <ski> the pattern binds *either* `b' or `c'
19:54:29 <elliott> right
19:54:52 <ski> and since one expression disjunct uses `b' (and not `c') and the other `c' (and not `b'), there is no ambiguity
19:57:12 * ski . o O ( foo :: (Int -> a) -> (a,a); foo (\0 -> x)@(\1 -> y) = (x,y)' )
19:57:57 <rasfar> \me oh! elliott, i just realised you were C.E. hahaha
19:58:16 <davean> his exact word or phrase, whose sum of unicode code points is a mersenne prime:
19:58:16 <elliott> >_<
19:58:17 <elliott> i'm not
19:58:30 <elliott> he uses the nick "conal"
19:58:46 <ski> preflex: xseen conal
19:58:46 <preflex>  conal was last seen on freenode/#haskell 2 days, 4 hours, 24 minutes and 25 seconds ago, saying: elliott: oh, sneaky. thx. :)
19:58:49 <rasfar> oh! somehow i guess i must have sensed that, since otherwise it would be an obvious assumption ... er, or ... never mind!
19:59:02 <ski> elliott : you sneak ;)
19:59:34 <elliott> there's like five haskellers called elliott, it's ridiculous ... i feel like i say this every other day
20:00:03 <clsmith> lol
20:00:06 <rasfar> my apologies; please return to regular programming (pun)
20:02:26 <elliott> foo (\False -> Left x)|(\True -> Right y) = Right x | Left y
20:02:40 <elliott> foo (\False -> Left x)|(\True -> Right y) = xs@((Right x | Left y) : xs)
20:02:45 <elliott> ski: you're a monster :)
20:02:56 <elliott> patternskell
20:03:42 <ski> well, i just feel that patterns are a bit neglected, and need some more love :)
20:03:58 <ski> elliott : also, that definition is partial
20:04:07 <elliott> it's just one clause!
20:04:11 <ski> i know
20:04:19 <elliott> don't ask me what the second clause is, it has a pattern of several terabytse
20:04:21 <elliott> *terabytes
20:04:44 <ski> note that in my `foo', i had `@', not `|', in the pattern
20:05:47 <elliott> right
20:06:00 <elliott> shouldn't @ be renamed & for consistency? :p
20:06:55 <ski> could be
20:07:20 <ski> note that this would already be useful atm, since we have view patterns
20:09:49 <ski> @type let foo (Seq.viewl -> head :< tail)@(Seq.viewr -> front :> init) = (head,front,tail,init) in foo
20:09:50 <lambdabot> parse error on input `@'
20:10:31 <ski> @type let foo (id &&& id -> (Seq.viewl -> head :< tail,Seq.viewr -> front :> init)) = (head,front,tail,init) in foo
20:10:32 <lambdabot>     Illegal view pattern:  (id &&& id -> ((Seq.viewl -> head :< tail),
20:10:32 <lambdabot>                                           (Seq.viewr -> front :> init)))
20:10:32 <lambdabot>     Use -XViewPatterns to enable view patterns
20:10:35 <ski> bah
20:13:25 <ski> (btw, `|' for expressions is basically the same as McCarty's nondeterministic `amb' operation)
20:18:28 <elliott> ski: i already said that :p
20:18:51 <ski> you did ?
20:19:15 <elliott> <rasfar> could be useful in speculative evaluation of conditional branches perhaps?  <rasfar> two expressions which may have very different evaluation efficiencies depending on argument values?  on a multicore, both evaluated in parallel and the first to produce a head is used, the other computations terminated
20:19:18 <elliott> <elliott> rasfar: that's impure :(
20:19:18 <elliott> <elliott> rasfar: that's just unamb though
20:19:20 <elliott> etc
20:19:25 <killerswan> so, does anyone know a reason why cURL would send only the first packet of an HTTP POST request?
20:20:44 <ski> well, `amb' will compute both branches
20:20:57 <ski> (assuming you ask for all solutions, or enough of them)
20:25:11 <ski> see <http://community.schemewiki.org/?amb>,<http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_idx_4822>,<http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters#Monadic_Reflection>
20:32:28 <rasfar> ski has been hijacked by a spambot-cum-haskell-enthusiast
20:33:04 * ski stares blankly
20:40:54 <rasfar> maybe it's not a hijacking so much as a possession a la h.p. lovecraft
20:41:24 <rasfar> anyhow i'm into my second pint and should lay off the keyboard for the night; cheers #haskell
20:42:13 <ski> Cthulhu ftaghn !
20:42:31 * ski slithers away
20:43:29 <irene-knapp> Ia ia ftaghn!
21:05:21 * hackagebot fast-tags 0.0.2 - Fast incremental vi tags.  http://hackage.haskell.org/package/fast-tags-0.0.2 (EvanLaforge)
21:40:27 <zzo38> Can HPDF's typesetting stuff be used with DVI?
21:51:50 <copumpkin> oh nice, cabala is here
21:53:05 <zzo38> Perhaps, later on, after I post dvi-processing package then can also make another package having Graphics.DVI.Typesetting with the algorithms and codes from the Graphics.PDF.Typesetting in HPDF
21:53:27 <zzo38> (It can be separate package due to licensing; HPDF is LGPL and dvi-processing is public domain)
22:09:07 <zzo38> Is people who made HPDF package on here now?
22:14:49 <copumpkin> so there's an algorithm for enumerating all the rationals
22:15:07 <copumpkin> is there a way to enumerate all rationals within a given range?
22:15:56 <dmwit> There's a mapping from R to [0,1] that ought to help.
22:17:15 <kallisti> hm, are the rationals well-ordered?
22:17:23 <kallisti> I was told in my math class that they're not, but I'm skeptical.
22:17:31 <mk> copumpkin: sure - just use that function for enumerating the rationals, and add your < > checks
22:17:46 <copumpkin> mk: the function for enumerating them doesn't produce them in order
22:18:06 <kallisti> if it did, then the rationals would for sure be well-ordered.
22:18:12 <mk> copumpkin: there's no algorithm for producing them in order
22:18:15 <dmwit> Yes, it's not clear that a mere filter is productive enough to work.
22:18:44 <dmwit> ...or is it?
22:19:12 <mk> copumpkin: what comes after 1, for example?
22:20:08 <copumpkin> oh, I know
22:20:31 <kallisti> > tail [1..] :: [Rational]
22:20:31 <lambdabot>   [2 % 1,3 % 1,4 % 1,5 % 1,6 % 1,7 % 1,8 % 1,9 % 1,10 % 1,11 % 1,12 % 1,13 % ...
22:20:35 <kallisti> 2, duh
22:20:38 <copumpkin> lol
22:22:34 <kallisti> > tail [1%2..]
22:22:34 <lambdabot>   [3 % 2,5 % 2,7 % 2,9 % 2,11 % 2,13 % 2,15 % 2,17 % 2,19 % 2,21 % 2,23 % 2,2...
22:22:40 <kallisti> looks legit.
22:23:09 <kallisti> > tail [1%2, 1%3 ..]
22:23:10 <lambdabot>   [1 % 3,1 % 6,0 % 1,(-1) % 6,(-1) % 3,(-1) % 2,(-2) % 3,(-5) % 6,(-1) % 1,(-...
22:23:22 <kallisti> what
22:23:59 <kallisti> > tail [1%3, 1%2 ..]
22:24:00 <lambdabot>   [1 % 2,2 % 3,5 % 6,1 % 1,7 % 6,4 % 3,3 % 2,5 % 3,11 % 6,2 % 1,13 % 6,7 % 3,...
22:24:09 <kallisti> ah
22:24:28 <BMeph> kallisti: What, 'what'? 1/3 is smaller than 1/2, you know...or Do you? ;)
22:24:50 <kallisti> I do, but I wasn't sure what was happening until I made it go positively
22:25:22 * kallisti can program in Haskell, but is bad at fractions.
22:25:23 <ferreal> > iterate (+ 1/6) 0.5 :: [Rational]
22:25:24 <lambdabot>   [1 % 2,2 % 3,5 % 6,1 % 1,7 % 6,4 % 3,3 % 2,5 % 3,11 % 6,2 % 1,13 % 6,7 % 3,...
22:25:47 <mk> are you trying to enumerate them in order? Because you're missing a few.
22:28:37 <kallisti> > iterate (/2) 1
22:28:38 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
22:29:48 <mk> you might want to add a :: to that
22:30:06 <kallisti> nah
22:33:19 <kallisti> surely it will descend infinitely with no loss of accuracy.
23:18:38 <copumpkin> new records proposal
23:18:58 <copumpkin> seems pretty reasonable to me, and a lot more appealing than the other ones I've seen
23:19:08 <irene-knapp> oh!
23:19:10 <irene-knapp> where is it?
23:20:03 <copumpkin> on -cafe
23:20:15 <irene-knapp> looking
23:20:33 <kallisti> wow tower of hanoi is really simple once you figure it out.
23:20:42 <irene-knapp> yes
23:20:43 <irene-knapp> it is
23:22:48 * dmwit glances at the calendar
23:22:50 <dmwit> Already??
23:23:32 <irene-knapp> caution: objects in calendar are closer than they appear
23:24:16 <Cale> copumpkin: LOL
23:24:27 <copumpkin> "At first, I thought we could avoid providing any syntax for homotopies at all. Haskell is a language with type inference, so we should just be able to infer paths and homotopies behind the scenes by adding homotopies to the type system. That's a very nice answer in theory. But in the real world, when we're writing code that solves actual problems, theoretical niceties break down. What if a user wants to use a nonstandard homotopy?"
23:24:28 <dmwit> sclv++
23:24:30 <copumpkin> I love that bit
23:24:44 <copumpkin> well, I love the whole thing
23:25:06 <dmwit> I loved "It has produced more than one paper[4]. {- ... -} [4] http://arxiv.org"
23:26:10 <copumpkin> yep :)
23:26:49 <kallisti> you know you're doing good when the botton disk switches to the final peg (roughly) halfway through the minimum number of possible moves.
23:27:10 <kallisti> that's like.. a checkpoint.
23:27:29 <irene-knapp> or, of course, you could have miscounted
23:27:35 <irene-knapp> and have to move it to the wrong peg first ><
23:27:39 <dmwit> oh man I have a new favorite
23:27:47 <kallisti> I'm using a program that counts for me.
23:27:57 <kallisti> and shows the minimum number of moves.
23:28:00 <copumpkin> dmwit: which?
23:28:16 <dmwit> In an intuitionistic logic, the following simplification is possible: 1) Use your intuition.
23:28:23 <copumpkin> hah yeah
23:28:36 <copumpkin> I liked the proof that the diagram commutes, too
23:29:45 <dmwit> "I can only get away with my proof using Scott-free semantics." there's too many awesome lines to choose just one
23:29:48 <dmwit> =D
23:31:25 <kallisti> awww yeah, 6 disks in minimum number of moves.
23:31:30 * kallisti feels accomplished somehow.
23:31:55 <copumpkin> dmwit: and we get to work with him every day!
23:33:06 <copumpkin> in related news, who's enjoying the new reddit timeline?
23:35:24 <kallisti> ..wat
23:35:29 <kallisti> oh
23:36:01 <kallisti> it's pretty cool.
23:36:04 <kallisti> feels very Web 3.0
23:36:13 <dmh> buzzword
23:38:38 <kallisti> bah. I was off by one move on 7 disks.
23:38:45 <kallisti> how does that even happen?
23:38:56 <irene-knapp> fair question
23:40:42 <kallisti> > 2^7-1
23:40:43 <lambdabot>   127
