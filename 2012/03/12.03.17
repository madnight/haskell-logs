00:12:57 * hackagebot hspec-shouldbe 0.0.0 - Convenience wrapper and utilities for hspec  http://hackage.haskell.org/package/hspec-shouldbe-0.0.0 (SimonHengel)
00:13:13 <elliott> 0.1.0 followed by 0.0.0?
00:14:26 <shachaf> elliott: test followed by hspec?
00:14:46 <elliott> Oh.
00:17:59 * hackagebot snap-blaze 0.1.0.0 - blaze-html integration for Snap  http://hackage.haskell.org/package/snap-blaze-0.1.0.0 (JasperVanDerJeugt)
00:21:05 <augur> any good videos lately?
01:12:59 * hackagebot gd 3000.7.2 - A Haskell binding to a subset of the GD graphics library  http://hackage.haskell.org/package/gd-3000.7.2 (ChrisDone)
02:02:42 <ksf> is there some magic option to darcs diff that means "current repository against upstream"? that is, that shows unsend changes?
02:03:42 <ksf> there's always the possibility of using diff --last=N, but I might forget how many patches I wrote ;)
02:05:35 <m3ga> ksf: darcs push --dry ?
02:08:41 <hiptobecubic> I am trying to optimize a simple program that is numerically heavy. Right now i'm kind of randomly inserting bang patterns and checking the *.prof file for memory allocation, time spent in GC, and total runtime. Is this the usual way it's done? Seems kind of haphazard :/
02:09:54 <hiptobecubic> Also, these numbers seem really high, since /usr/bin/time says it uses roughly 21 megabytes.  Am i missing something fundamental? "504,467,336 bytes allocated in the heap      96,932,032 bytes copied during GC"
02:11:28 <c_wraith> hiptobecubic: those numbers aren't resident set, they're total over the lifetime of the program
02:12:25 <c_wraith> still, that's saying about 20% of your data survived one GC, which seems a bit high
02:12:44 <c_wraith> oh, well, it's not that strong a statement, because of multiple generations
02:13:59 <elliott> hiptobecubic: no, that's not the usual way
02:14:03 <elliott> and yeah, ignore the alloc figure
02:23:45 <Ke> how is this indentation wrong http://pastebin.com/CNZDLjaa
02:23:47 <mauke> The paste CNZDLjaa has been copied to http://hpaste.org/65449
02:24:12 <mauke> Ke: the '(' lines up with 'thisAction'
02:24:17 <mauke> it should be indented more
02:24:43 <c_wraith> Ke: since you didn't indent subsequent lines more than the first identifier after the let, it thinks those lines are new declarations, not a continuation
02:24:44 <mauke> 'length args < 1' better written as 'null args'
02:24:48 <Ke> ah, I thought let was the beginning of the line
02:25:12 <mauke> beginning of the line doesn't matter
02:25:26 <mauke> the base indentation level is determined by the thing after let/where/do/of
02:25:31 <mauke> in this case 'thisAction'
02:26:35 <Ke> thanks, worked just fine =o)
02:27:47 <hiptobecubic> c_wraith, i'm doing a lot of zipping of lists of function applications, so it's kind of trial and error for me using seq and bangs here and there.
02:28:01 * hackagebot websockets 0.6.0.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.6.0.0 (JasperVanDerJeugt)
02:28:31 <hiptobecubic> what is "bytes copied during GC" exactly? things which the garbage collecter was unable to get rid of?
02:30:38 <elliott> GHC uses copying GC
02:30:48 <elliott> so it's copying all the live objects once per GC, more or less
02:31:01 <elliott> (except not)
02:31:06 <elliott> (because it's also generational)
02:31:12 <elliott> (but whatever, it's copying live objects around at GC time)
02:31:26 <gaze___> Hey, I hate to ask a question like this... but say you have a function that needs to take the type Int -> (Int -> IO ()) -> IO () when matching a certain pattern, and Int -> (String -> IO ()) -> IO () when matching a different pattern? I know data.dynamic can manage something like this... but is there any way to do it with straight data.typeable?
02:31:30 <gaze___> or am I way off base?
02:31:55 <elliott> What does "when matching a certain pattern" mean?
02:31:59 <elliott> I doubt you need or want Typeable at all.
02:33:01 * hackagebot websockets-snap 0.6.0.0 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.6.0.0 (JasperVanDerJeugt)
02:33:29 <gaze___> long story short, I'm writing a library for serializable closures... each closure consists of a function name, some arguments, and then another function name and it's arguments that constitute a continuation that the first function is to call when it's done with its business
02:35:25 <gaze___> I have a function that decodes the closure stored on disk... but to give back the complete function, I also have to give it the associated closure
02:36:00 <gaze___> haha, if I send you an hpaste I think it'll make some sense
02:36:11 <hiptobecubic> elliott, So you want the bytes copied during GC to be low i would imagine
02:37:09 <gaze___> elliott: http://hpaste.org/65451 I can't figure out what type runClosure_ should take
02:39:21 <elliott> hiptobecubic: I don't think you should care.
02:39:40 <elliott> Ignore the stats, focus on more detailed profiling.
02:40:15 <elliott> gaze___: Yes, I suppose Dynamic would work there.
02:40:25 <elliott> Dynamic is just an existential Typeable, so there's no reason to avoid it.
02:40:33 <elliott> You realise you can use strings as patterns, right?
02:41:08 <gaze___> elliott: I saw this mentioned as an optimization.
02:41:18 <gaze___> perhaps it's BS
02:42:10 <elliott> Uh... yes, that's BS, and I'd advise not to take any advice from whoever told you that.
02:42:45 <elliott> By the way, you should really be importing HashMap qualified.
02:43:15 <gaze___> got it
02:43:30 <gaze___> is there any way to do what I'm doing while avoiding Dynamic?
02:46:08 <elliott> Why do you want to avoid Dynamic and not Typeable?
02:46:16 <elliott> Dynamic is literally equivalent to just
02:46:23 <elliott> data Dynamic = forall a. (Typeable a) => Dynamic a
02:46:25 <elliott> (except optimised)
02:47:39 <gaze___> typable or dynamic, I mean. I'm more curious about whether or not I'm thinking about this problem correctly
02:48:57 <elliott> Well, I don't know. I'd try to avoid doing what you're doing in the first place.
02:51:08 <gaze___> haha... at what level? Ultimately I'm trying to have a way to call stuff and have it stored how I called the thing so if the computer dies, I can restart that task... and do it all all CPSey so I don't have to worry about the stack
02:57:16 <elliott> Yes.
02:57:23 <elliott> A Haskell implementation could offer that.
02:57:27 <elliott> GHC is not such an implementation.
02:57:36 <elliott> I think you'll find it very annoying to code with such a construction.
03:07:07 <gaze___> well, it's certainly a pain in the ass to think about.
03:34:08 <Fifo> raichoo: Hello.
03:35:04 <raichoo> Fifo: hi
03:36:25 <Fifo> raichoo: If you want, you can /join ##iPhoneFifo.
03:36:52 <elliott> @where ops
03:36:52 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
03:37:10 <elliott> "If you want" doth not a non-spam make.
03:40:02 <Rc43> Hi, guys.
03:40:09 <elliott> hi
03:40:34 <Fifo> elliott: I'm NOT a spammer!
03:41:14 <Rc43> I know, probability is low, but maybe anybody tried to implement VST plugin in haskell?
03:48:06 <pozic> Rc43: define VST.
03:48:34 <Rc43> pozic, Virtual Studio Technology
03:48:54 <Rc43> pozic, plugins for diffferent audio programs
03:49:03 <gaze__> Rc43: I funny you should mention that...
03:49:09 <pozic> Rc43: writing a plugin in Haskell is not a problem anymore.
03:49:21 <pozic> Rc43: for whatever shiny system you want to connect to.
03:49:42 <gaze__> Rc43: I haven't but, I was planning on writing a haskell program that generated bytecode for an audio DSL
03:49:48 <Rc43> pozic, it must use VST framework or something, I think
03:49:58 <gaze__> and then a VM would run the bytecode
03:50:05 <gaze__> and the VM would be a VST plugin
03:50:28 <Rc43> gaze_, which VM?
03:50:48 <Rc43> gaze_, or it would be your own VM?
03:50:54 <gaze__> my own... nothing fancy of course
03:51:05 <gaze__> just something to shuttle audio buffers around
03:51:29 <gaze__> and then things like low pass filtering might be implemented in C, whatever
03:51:44 <gaze__> that way you could wire up filters and LFOs and whatever in whatever way you wanted
03:52:19 <gaze__> I don't love the idea of using haskell in something that needs to be real-timey
03:53:02 <gaze__> so figure you dream up some haskell program to figure out what the lifetime of each audio buffer is, statically allocate them all
03:53:12 <Rc43> gaze__, I thought about tricky EQ
03:53:24 <gaze__> what do you mean?
03:54:58 <Rc43> gaze__, I just used parametric EQ for accentic notes of my recorded guitar and every multiple note (220hz, 440hz, etc)
03:55:10 <Rc43> gaze__, and thought that it will be nice to automate it
03:55:22 <Rc43> gaze__, but autotune is similar thing, I think
03:55:35 <gaze__> autotune is a lot of different things
03:55:49 <gaze__> autotune is pitch shifting and pitch detection
03:56:27 <Rc43> gaze__, I really dont know what is autotune, I use `autotune` like name of a program that takes midi melody and adjusts sound to it
03:56:49 <gaze__> that's what I'm referring to
03:56:59 <gaze__> there isn't much filtering going on in autotune
03:57:03 <DaveNull> ho
03:57:12 <gaze__> I think it's using cepstral analysis or something to get the pitch
03:57:29 <gaze__> and then shifting it... well, everyone has their own secret sauce way of doing it
03:58:13 <Rc43> gaze__, hm, I am newbe in sound, five minutes ago I just used 6 parametrix EQs per a track with statically gained notes
03:59:10 <Rc43> gaze__, so If I coded a plugin, I did the same, without any analysis
03:59:23 <gaze__> I'd use the D vst api or the python one, and play with filters in matlab or something
03:59:34 <gaze__> I mean you could write a haskell vst api but haskell doesn't buy you anything here
04:01:06 <Rc43> gaze__, sry, didn't understand it `haskell doesn't buy you anything here`
04:11:32 <makkron> hi
04:11:44 <pokoko222> hello guys I am interested in working on haskell for gsoc :)
04:11:50 <pokoko222> any mentors here?
04:11:59 <makkron> heh, me too
04:12:59 <pokoko222> I see there is an idea for a project, machine learning library for haskell but no mentor is assigned. Someone knows more about it?
04:18:11 * hackagebot gd 3000.7.3 - A Haskell binding to a subset of the GD graphics library  http://hackage.haskell.org/package/gd-3000.7.3 (ChrisDone)
04:19:35 <anssik> I'm looking for a clean solution to terminate external process after timeout
04:19:41 <anssik> however, laziness makes me crazy
04:19:43 <anssik> https://gist.github.com/5f39b58dc56ce579a9a5
04:19:53 <elliott> forkIO (threadDelay blah >> terminateTheProcess)
04:20:11 <elliott> no need for System.Timeout.
04:20:11 <shachaf> anssik: Don't use hGetContents.
04:20:32 <shachaf> anssik: hGetContents purposely uses lazy I/O
04:21:10 <elliott> More like purposelessly.
04:24:03 <elemir> Hem… Does GHC work with µclibc as libc?
04:24:48 <arun1> can anyone point to a example how a function that returns a ADT be made callable from C using haskell FFI export?
04:26:02 <rostayob> arun1: it can't, afaik. You have to use the C types provided
04:26:15 <rostayob> I mean it can
04:26:24 <rostayob> but it wouldn't be of much use if you have to use the ADT in C
04:26:38 <opqdonut> it'd have to be completely evaluated etc
04:28:09 <arun1> can't be structs on C side?
04:28:19 <anssik> elliott, hmm, but that would keep the 'terminator' thread alive until threadDelay returns (I need to use rather long timeouts)
04:28:40 <rostayob> arun1: you can make C structs on Haskell side
04:28:48 <rostayob> but you can't represent ADT in C easily
04:29:48 <anssik> maybe it does not matter in practice, but I'd like to know if there a way to avoid it
04:31:42 <elliott> anssik: That absolutely does not matter.
04:31:45 <elliott> anssik: In fact, timeout uses a thread.
04:31:54 <elliott> GHC uses lightweight threads; the cost is much much much less than an OS thread.
04:32:14 <elliott> You can have a great many thousands of threads without any problems at all.
04:32:15 <anssik> oh, ok
04:32:55 <anssik> I'll implement it like that then, thanks
04:33:25 <arun1> rostayob, if I have data Position = Position Int Int Int that could be marshalled to a C struct right?
04:33:27 <Jafet> linux has bungee cords.
04:33:54 <Jafet> arun1: nope, C only takes Position !Int !Int !Int
04:34:37 <elliott> Not even that.
04:34:46 <elliott> You need UNPACK pragmas there at the very least.
04:34:56 <elliott> Of course, using GHC's memory like that would be completely unsupported...
04:35:01 <Jafet> Well, the values are (almost) the same.
04:36:28 <rostayob> arun1: yeah it could, but GHC won't do that for you. Also, would the Ints be boxed in C? What would be the fields names?
04:36:37 <rostayob> in short, you have to do this things manually
04:37:11 <elliott> anssik: btw, remember that threadDelay takes microseconds.
04:37:17 <rostayob> anssik: using this types http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html
04:37:19 <elliott> anssik: so your long timeout may overflow on 32-bit
04:37:20 <rostayob> oops, arun1
04:37:41 <elliott> anssik: the http://hackage.haskell.org/package/unbounded-delays package is useful if they're large enough
04:38:15 <PathFinder> Hello there!
04:39:08 <arun1> thanks jafet, rostayob, will check that.. is it also correct to say that I must write a instance of Storable for my type?
04:39:21 <elliott> hi PathFinder
04:39:50 <elemir> PathFinder is something like A*?
04:41:00 <PathFinder> <elemit> What is A* ?)
04:41:15 <elemir> Path finding algorithm
04:41:42 <elemir> *algorithm family
04:42:57 <PathFinder> <elemir> like eastern suffix *do
04:43:28 <elemir> "star"
04:44:02 <elemir>  In computer science, A* (pronounced "A star")
04:44:21 <PathFinder> i know this.)
04:44:43 <PathFinder> Kleeny Star
04:45:49 <PathFinder> PathFinder is something like Life style
04:47:46 <PathFinder> i'm from russia and I don't well speak in english.)
04:49:56 <PathFinder> Should I start learning Haskell?
04:50:14 <elliott> Yes.
04:50:46 <elemir> No. Start writing Agda!
04:51:13 <elliott> Oh dear.
04:51:29 <pokoko222> any gsoc mentors here?
04:52:08 <PathFinder> what is "gsoc"?
04:52:17 <elemir> Google summer of code
04:52:47 <hpaste> franco00 pasted “rigid type variable bound... error” at http://hpaste.org/65454
04:53:27 <franco00> I am having problems writing the signature in the hpaste above
04:55:15 <franco00> (if neede, I can paste the other functions as well)
04:55:23 <elemir> PathFinder: Capitalistic way to stimulate coding of OSS projects throw student exploitation
04:57:11 <PathFinder> At work I have to reinvent the wheel - making a lexical analyzer and parser to parse the command line in C + +. Haskell could handle this task in the manner flex+bison?
04:57:23 <shachaf> franco00: Why aren't you just using the StateT primitives?
04:57:51 <PathFinder> elemir: I'm undestand.)
04:58:14 * hackagebot OptDir 0.0.1 - The OptDir type for representing optimization directions.  http://hackage.haskell.org/package/OptDir-0.0.1 (MasahiroSakai)
04:59:13 <elemir> PathFinder: It isn't really to write parser of C++
04:59:17 <franco00> shachaf: because I don't know much about StateT (apart that State could come handy in those computations). Which function exactly?
04:59:51 <PathFinder> How easy is it to cross a program in C++ to Haskell?
05:00:39 <shachaf> franco00: Something like \a -> lift a >>= put?
05:00:51 <shachaf> Or something.
05:00:53 <shachaf> At least use put.
05:01:04 <solirc> Did someone already create a side-by-side comparison on what package versions are in what haskell-platform?
05:01:32 <elliott> PathFinder: Haskell is incredibly different to C++.
05:01:36 <franco00> thanks. but can you tell me why this particular sig is wrong? The error message left me really puzzled
05:01:45 <elliott> You might be able to translate a C++ program fairly directly to Haskell if you're experienced, but it would be incredibly unidiomatic.
05:01:56 <solirc> If not, I'm finally annoyed enough to do that...
05:02:08 <Jafet> elliott: and if you're not careful, it might even be fast
05:03:12 <PathFinder> elliot: This expression (\a -> ...) in the syntax of Haskell?
05:03:14 * hackagebot loch-th 0.2.1 - Support for precise error locations in source files (Template Haskell version)  http://hackage.haskell.org/package/loch-th-0.2.1 (TomasJanousek)
05:03:16 <elliott> solirc: Have you tried just ignoring the Haskell Platform?
05:03:25 <elliott> PathFinder: (\a -> ...) is Haskell syntax, yes.
05:03:31 <elliott> Well, apart from the "..." thing.
05:04:01 <elliott> PathFinder: The best way to learn Haskell is to read http://learnyouahaskell.com/... but maybe there's some Russian tutorial that would be more suitable.
05:05:22 <PathFinder> There are several books translated into Russian for Haskell
05:05:52 <solirc> elliott: how will that help?
05:06:18 <elliott> solirc: Well, it's what I do, and I don't have any Haskell Platform-related problems.
05:06:57 <PathFinder> ...but I like to read in the original. fewer translation errors (except their own).
05:07:39 <solirc> elliott: I still don't think that this will help with my question;)
05:08:26 <elliott> solirc: Well, I don't know what your question is, really.
05:09:17 <solirc> elliott: You did not understand my question?
05:09:41 <elliott> If you mean "Did someone already create a side-by-side comparison on what package versions are in what haskell-platform?", then the idea is that ignoring the Haskell Platform negates the need for any such comparison :P
05:10:32 <elemir> Haskell platform? Is it something for windows-g{a,u}ys?
05:10:36 <solirc> elliott: but it wont help people that are using a particular version of the hp and want to use your library/program..
05:11:11 <elliott> I don't have the problem known as "users" :)
05:11:36 <elemir> solirc: Nootropics may help this guys
05:11:39 <elliott> elemir: The Haskell Platform is cross-platform.
05:12:07 <elemir> Lie. It doesn't work at my OpenBSD
05:12:37 <solirc> elemir: the configure script wont run, or what is the issue?
05:13:03 <PathFinder> Haskell to mix with other languages ​​(like C + + for example), you need to put on the client computer platform Haskell?
05:13:08 <elliott> elemir: Sure it does.
05:13:12 <elemir> There is no port for haskell platform. So it doesn't works :3
05:13:23 <elliott> PathFinder: Haskell executables are standalone.
05:13:46 <elliott> (Well, apart from the GMP dependency, but that's just a compiler flag away from fixing -- except you'll probably want integer-simple depending on your license, but I digress.)
05:14:14 * elemir doesn't install left crap not integrated at my port system
05:17:50 <PathFinder> Haskell interpreter can be called from C/C++?
05:18:38 <elemir> system("hugs");
05:19:39 <elliott> PathFinder: You can use the FFI to interface with C in both directions, yes.
05:21:04 <PathFinder> elliott: ok
05:29:00 <elemir> Guys, is there some haskell indent style papers?
05:29:12 <ksf> elemir, ghc should work with ulibc.
05:29:15 <ksf> ...in principle.
05:30:01 <elliott> elemir: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
05:30:05 <ksf> the rts, and thus any haskell program basically only needs a way to get more memory, plus some signal stuff etc. at least if you're on posix.
05:30:16 <ksf> the vanilla posix libraries should work fine, too.
05:30:56 <ksf> cross-compiling to ulibc could get hairy, though.
05:31:43 <elemir> elliott: I want to read many papers and write my own :) As I done with C indent style.
05:32:03 <elemir> ksf: glibc makes me sad :(
05:32:24 <ksf> I try to ignore it.
05:33:39 <elemir> 12:55 <@elemir> # cave contents glibc | grep so$ | wc -l
05:33:39 <elemir> 12:55 <@elemir> 596
05:34:54 <elliott> elemir: Every large project that I know of basically keeps to that style.
05:35:13 <rostayob> elliott: you want to write papers about indentation styles?
05:35:14 <elliott> More or less, anyway.
05:35:17 <elliott> rostayob: No.
05:35:26 <elliott> elemir: One of us is going to have to change our name.
05:35:26 <rostayob> sorry, elemir
05:35:48 <elliott> (Okay, "large" makes that a bit fuzzy, but all Haskell code mostly looks alike as long as it uses layout and a semi-reasonable indentation style.)
05:36:11 <elliott> (The differences are mainly in smaller things like layout of "where" clauses and alignment of multi-line list literals.)
05:37:04 <rostayob> elliott: a lot of large projects don't follow precisely that style
05:37:09 <rostayob> most large projects indent with 4 spaces
05:37:29 <elemir> > Indent your code blocks with 4 spaces.
05:37:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:37:34 <rostayob> but there isn't much consensur regarding the rest of the rules
05:37:41 * elemir uses 2 spaces, for example
05:37:47 <elliott> rostayob: That's why I said: <elliott> (Okay, "large" makes that a bit fuzzy, but all Haskell code mostly looks alike as long as it uses layout and a semi-reasonable indentation style.)  <elliott> (The differences are mainly in smaller things like layout of "where" clauses and alignment of multi-line list literals.)
05:38:02 <elliott> Fair enough in that that style guide is basically nitpicking.
05:38:15 * hackagebot test-framework-th-prime 0.0.5 - Template Haskell for test framework  http://hackage.haskell.org/package/test-framework-th-prime-0.0.5 (KazuYamamoto)
05:38:29 <elliott> But there is a rather homogeneous Haskell style as far as mere textual layout goes these days, I would say.
05:38:33 <elemir> It isn't real to keep 80 chars at line with 4-spaces indent
05:38:35 <rostayob> yeah but that style guid is about small details.
05:38:48 <rostayob> of course most large haskell projects have reasonable layouts
05:38:53 <rostayob> *guide
05:38:59 <elliott> My point was that there isn't really much space for innovation.
05:39:10 <elliott> You'll either end up with something very close to what people already do, or be unraedable.
05:39:32 <PathFinder> is Haskell support TDD?
05:39:41 <elemir> TDD?
05:39:46 <elliott> PathFinder: Sure, but the type system means you probably don't want to.
05:40:17 <elliott> Many tests are subsumed by types, and those have the benefit that they're checked completely.
05:40:31 <PathFinder> elemir: test-driven development
05:40:52 <elliott> Again, Haskell is vastly different from almost all other programming languages.
05:41:02 <rostayob> elliott: still, some important projects use incredibly weird layouts
05:41:05 <ksf> elliott, ddc.
05:41:08 <elemir> Adga doesn't need tests at all!
05:41:30 <elemir> All adga code is a priori correct
05:41:34 <HugoDaniel> and coq ?
05:41:35 <elemir> *agda
05:41:36 <rostayob> elemir: no
05:41:38 <elliott> ksf: Miranda. What's your point?
05:41:40 <elliott> I said "almost" for a reason.
05:41:53 <ksf> ddc has a *highly* idiosyncratic code style.
05:42:05 <ksf> it starts with using tabs=8spaces but doesn't end there, by far.
05:42:13 <rostayob> most bode by ben lippmeier does
05:42:35 <PathFinder> elliott: American Dairy Goat Association?)
05:42:42 <rostayob> also, let's not forget utrecht style.
05:43:02 <rostayob> the centerpiece of haskell indentation
05:43:10 <rostayob> and layout in general
05:43:28 <snhmib> o_O
05:43:45 <elliott> PathFinder: what?
05:43:51 <ksf> ...uhc is hardly written in haskell in the first place.
05:43:55 <elliott> ksf: Oh, I see.
05:44:03 <geekosaur> e was trying to parse "adga"
05:44:05 <snhmib> utrecht style?
05:44:10 <geekosaur> (typoed "agda")
05:44:21 <elliott> ksf: Well, ddc is not really a popular Haskell project :P
05:44:34 <rostayob> snhmib: software by wouter swiestra & co.
05:44:43 * elliott tries to find DDC's source.
05:44:52 <rostayob> sorry, not wouter
05:44:57 <rostayob> some other swiestra
05:44:58 <ksf> disciple.orouborus.org
05:45:09 <ksf> http://disciple.ouroborus.net/
05:45:10 <elliott> ksf: got that far.
05:45:10 <rostayob> doaitse
05:45:25 <elliott> ah, http://code.ouroborus.net/ddc/ddc-head
05:45:46 <elliott> http://code.ouroborus.net/ddc/ddc-head/packages/ddc-core/DDC/Core/DataDef.hs ... doesn't look that bad
05:46:02 <elliott> wow, it actually uses 8 spaces.
05:46:12 <elemir> Combination of 4-space + 2-spaces is bad?
05:46:21 <rostayob> yeah that's ben lippmeier
05:46:26 <rostayob> gloss is the same style
05:47:06 <snhmib> uh i just jumped in.. it's software or a style of haskell indenting (i.e. k&r style in c)?
05:47:28 <elemir> How about using point-less style?
05:47:48 <rostayob> elemir: http://hackage.haskell.org/packages/archive/uu-parsinglib/2.7.3.2/doc/html/src/Text-ParserCombinators-UU-Core.html
05:47:55 <geekosaur> snhmib, they're talking about the haskell coding style popular at the university of utrecht
05:48:04 <rostayob> elemir: expecially, the Applicative instance for T.
05:48:05 <ksf> ben doesn't use pointless.
05:48:06 <elemir> "f . d $ x" or "f $ d $ x"?
05:48:16 <rostayob> well not only that
05:48:18 <elliott> The former.
05:48:23 <geekosaur> used in the UU parsing combinators, UHC, etc.
05:48:24 <elliott> Refactors better.
05:48:24 <ksf> it's hard to even find a single . in that source.
05:48:28 <elliott> (Less noisy, too.)
05:48:36 <snhmib> ok thanks :) i have a look
05:48:45 <elliott> Are you really going to crowdsource your Haskell indentation style? :)
05:48:46 <elemir> ksf: use conceal
05:49:22 <ksf> is that a bijection between ben's idiosyncracies and my ideosyncracies?
05:50:09 <rostayob> I actully like ben's code, it's very readable
05:50:21 <rostayob> both the code and the layout
05:50:35 <ksf> yeah, but it's not very writeable :)
05:51:05 <ksf> in general, I feel somewhat like reading c, reading it.
05:51:35 <elliott> i don't like it, it's way too bloated
05:51:46 <d-snp> how do you guys survive without record inheritance? it's driving me mad...
05:52:00 <ksf> that might be a ddc artifact, though, that is, ddc is possibly written to be portable to disciple itself asap.
05:52:07 <elemir> d-snp: Type classes?
05:52:12 <snhmib> elliott: well i just do what looks good to me.. might be good to look more at other haskell
05:52:18 <elliott> d-snp: Composition.
05:52:30 <d-snp> composition?
05:52:33 <elliott> Build bigger things out of smaller things rather than gluing them together.
05:52:41 <elliott> Include subparts as elements of larger structures.
05:52:49 <ksf> OOP is overrated
05:52:54 <elliott> snhmib: I was responding to elemir.
05:53:48 <ksf> ...most of what I'd do with objects is emulating closures, anyway.
05:54:02 * geekosaur notes that he likes the utrecht style, and as to writability, that's what smart code editors are for :)
05:54:10 <d-snp> you can hardly compare type classes to record inheritance :\
05:54:21 <elemir> OOP can be simulated with system f + type classes
05:54:32 <elemir> So OOP is very poor
05:54:50 <ksf> haskell *does* have a meta-object system, it's just that noone bothers to use it.
05:55:03 <elliott> Typeclasses are completely unrelated.
05:55:06 <ksf> multiple, in fact.
05:55:12 <elliott> And how on earth does that make OOP pure?
05:55:19 <elliott> *poor
05:55:26 <elliott> You can simulate lots of things in lots of other things.
05:55:36 <elemir> As type system
05:55:52 <hughfdjackson> i hear you can simulate life in the sims
05:56:03 <hughfdjackson> </trolltrolltroll>
05:56:07 <hughfdjackson> (sorry, couldn't resist)
05:56:20 <d-snp> it's surprisingly accurate hughfdjackson
05:56:23 <elemir> There are two parameteres of languages — speed of result of code and type system
05:56:46 <elemir> Syntax and so on are invated by Devil
05:56:46 <d-snp> if I had the discipline I imposed on my sims I would've been vice president of the usa by now too
05:56:52 <ksf> d-snp, we might possibly be more helpful if you told us what you're trying to do
05:56:55 <hughfdjackson> d-snp: :p the game, or the criticism by analogy?
05:57:27 <d-snp> ksf: well I received some nice criticism yesterday about the ugliness of my code here http://hpaste.org/65427
05:57:34 <d-snp> and I'm trying to clean it up
05:57:47 <elemir> Every type system is 2-category of types
05:58:09 <elliott> That's not even valid code.
05:58:13 <elliott> There's no "else" on your if.
05:58:25 <d-snp> woops sorry, I'll paste the compiling version :P
05:58:54 <ksf> that doesn't look to bad for the start
05:59:35 <ksf> oh. you're going to want to separate parsing and processing cleanly.
05:59:43 <hpaste> d-snp pasted “Ugly function” at http://hpaste.org/65455
05:59:56 <ksf> not doing that is inviting exploits
06:00:36 <ksf> ...because if you separate cleanly, you can easily make sure that your parser isn't accidentally turing-complete, which gives raise to strange machines and all kinds of hell.
06:00:51 <d-snp> I have the parsing in a separate file, I don't think it is exploitable, what kind of exploit are you thinking about?
06:01:26 <hpaste> elliott annotated “Ugly function” with “Ugly function (annotation)” at http://hpaste.org/65455#a65456
06:01:27 <d-snp> dmwit said he thought the nested if/then/elses were ugly, and that if my message type was more useful it could all be solved through pattern matching
06:01:35 <elliott> d-snp: there's a first attempt at a cleanup ^
06:01:41 <elliott> but yes, it sounds like you need some more general restructuring
06:01:44 <ksf> http://www.youtube.com/watch?v=3kEfedtQVOY
06:01:46 <ksf> those ones.
06:02:22 <d-snp> ohh thanks elliott
06:03:07 <elliott> You might want to flip the arguments of handleChunks so it partially applies better.
06:04:55 <d-snp> oh I don't think I can use your mapM_ thing, since the other case really still needs handling
06:05:06 <ksf> d-snp, with "parser" I mean a function that parses the raw input into something that doesn't include Word8's.
06:05:32 <ksf> data ChunkType = Cookie | ... | ...
06:05:33 <Botje> d-snp: use the maybe function then
06:05:49 <Botje> :t maybe
06:05:50 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:06:13 <elemir> :t fromMaybe
06:06:14 <lambdabot> forall a. a -> Maybe a -> a
06:06:16 <Botje> maybe handleException (flip handleChunks chunks) $ Map.lookup ...
06:07:05 <shergill> persistent users: how do you express foreign key constraint in persistent? more generally, is the syntax that the persistent quasiquoter accepts documented somewhere?
06:07:41 <elliott> i might use an explicit pattern match there rather than maybe.
06:07:46 <elliott> if handleException is large and only used once.
06:09:05 <ksf> I'd probably end up with yet another function called 'f', there.
06:13:53 <Franciman> hi all
06:14:48 <Franciman> who can explain me how this works : myFoldl f z xs = foldr step id xs z where step x g a = g ( f a x )
06:14:49 <Franciman> ?
06:15:00 <Franciman> how's it possible that foldr accepts 4 args?
06:16:44 <geekosaur> the simplest way is that 3-argument folds is returning a function that takes a single argument
06:16:57 <geekosaur> s/folds/foldr/
06:17:36 <Botje> Franciman: note how step accepts three parameters instead of two.
06:17:56 <Franciman> yes
06:17:59 <Botje> so if you pattern match that with a -> b -> b
06:18:07 <Botje> you can only make that work if b === (c -> d)
06:18:26 <Botje> so foldr receives a function a -> (c -> d) -> (c -> d)
06:18:39 <Botje> furthermore, you give it "id" as an empty element, so c == d
06:19:06 <Botje> so step :: a -> (c -> c) -> (c -> c)
06:19:29 <Botje> foldr step id xs :: c -> c
06:19:59 <Franciman> so as default value there is a function
06:20:04 <Botje> yes, id
06:20:06 <Botje> :t id
06:20:07 <lambdabot> forall a. a -> a
06:20:13 <Franciman> and that function is applied to z
06:20:20 <Franciman> hmm sorry
06:20:29 <Franciman> is applied to f a x
06:20:37 <Franciman> where a is bind to z
06:20:48 <Franciman> and x to the list
06:20:51 <Franciman> is it right?
06:21:06 <Botje> uhh..
06:21:24 <Franciman> no actually this is left
06:21:26 <Botje> you walk through the list
06:21:36 <Botje> and you construct a function that conceptually does a foldl
06:21:48 <Botje> this foldl already knows which function to apply
06:21:52 * Franciman gets depressed by his sentence
06:21:53 <Botje> it just needs a zero element to get started
06:22:05 <Botje> which is z, the original zero input to myFoldl
06:22:29 <Franciman> :t foldr
06:22:30 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:22:38 <Botje> Franciman: take a piece of paper and try to work out myFoldl for inputs of size 0,1 and 2
06:22:46 <elemir> :t f z xs -> foldr step id xs z where step x g a = g ( f a x )
06:22:47 <lambdabot> parse error on input `->'
06:22:47 <geekosaur> perhaps the simple reflection stuff in mueval applied to a sample input to myFoldL?
06:22:51 <elemir> :t \f z xs -> foldr step id xs z where step x g a = g ( f a x )
06:22:52 <lambdabot> parse error on input `where'
06:23:12 <elemir> :t \f z xs -> foldr (\x g a -> g $ f a x) id xs z
06:23:13 <lambdabot> forall a a1. (a1 -> a -> a1) -> a1 -> [a] -> a1
06:23:36 <Franciman> wth?
06:23:50 <elliott> > foldr f z [a,b,c,d]
06:23:50 <lambdabot>   f a (f b (f c (f d z)))
06:23:53 <elliott> > foldl f z [a,b,c,d]
06:23:54 <lambdabot>   f (f (f (f z a) b) c) d
06:24:00 <elliott> Perhaps that helps?
06:24:05 <Franciman> yes thanks
06:24:33 <Franciman> elliott but I don't understand how that call to foldr is valid
06:24:35 <elliott> shergill: probably the yesod book?
06:24:38 <Franciman> if it's type is
06:24:44 <Franciman> :t foldr
06:24:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:24:55 <geekosaur> Franciman, it's just how currying works
06:24:58 <elliott> Franciman: Because b = (c -> c).
06:25:03 <elliott> (a -> b -> b) -> b -> [a] -> b
06:25:04 <shergill> elliott: the chapter on persistent there is woefully inadequate =/
06:25:05 <elliott> substitute b = (c -> c)
06:25:10 <elemir> @pl \f z xs -> foldr (\x g a -> g $ f a x) id xs z
06:25:10 <lambdabot> flip . flip foldr id . (flip (.) .) . flip
06:25:14 <elliott> (a -> (c -> c) -> (c -> c)) -> (c -> c) -> [a] -> (c -> c)
06:25:17 <elliott> remove redundant parens
06:25:21 <elliott> (a -> (c -> c) -> c -> c) -> (c -> c) -> [a] -> c -> c
06:26:14 * geekosaur thinks Franciman is overthinking syntax; it's not parsing like there are invisible function-parameter parentheses
06:26:30 <elemir> > lambdabot can into $ symbolic computation
06:26:31 <lambdabot>   Not in scope: `lambdabot'Not in scope: `can'Not in scope: `into'Not in scop...
06:26:37 <elemir> :(
06:26:42 <Franciman> but it's always 3 args
06:26:46 <elemir> :t f
06:26:47 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
06:26:50 <Franciman> in that case there are 4
06:26:58 <elemir> Dou
06:27:02 <elemir> It's a cheat
06:27:06 <geekosaur> right, you are assuming that there are invisible function parameter brackets
06:27:08 <geekosaur> there are not
06:27:15 <Botje> Franciman: you can read it as (foldr step id xs) z
06:27:19 <geekosaur> it just absorbs following expressions as needed
06:27:28 <Botje> because foldr returns a function
06:27:37 <Franciman> ah
06:27:38 <Franciman> yes
06:27:44 <Franciman> now I have understood
06:27:45 <elliott> Franciman: remember that foldr's type is (a -> (b -> b)) -> (b -> ([a] -> b))
06:27:48 <geekosaur> and at the end of parsing the expression starting with folkdr, it is expectimg a parameter to pass to that expression, which it conveniently has right there
06:27:53 <elliott> "multiple parameters" are just a syntactic illusion :)
06:27:56 <Franciman> in the end it applies id to z
06:27:58 <Franciman> right?
06:28:04 <Botje> Franciman: no, the function it built up.
06:28:06 <elliott> no, it applies
06:28:13 <elliott> step a (step b (step c id))
06:28:13 <elliott> to z
06:28:15 <Franciman> yes
06:28:16 <elliott> if the list is [a,b,c]
06:28:16 <geekosaur> it applies (foldr step id xs) to z
06:28:20 <Franciman> sorry
06:28:28 <geekosaur> just that the folkdr happens to return a function
06:28:30 <Franciman> thanks so much
06:28:37 * geekosaur keeps mistyping foldr, sigh
06:28:49 <Franciman> brb lunch is ready
06:28:57 <elemir> > (\f z xs -> foldr (\x g a -> g $ f a x) id xs z) f z [a,b,c,d]
06:28:58 <lambdabot>   f (f (f (f z a) b) c) d
06:29:54 <elemir> > foldr (flip f) z [a,b,c,d]
06:29:56 <lambdabot>   f (f (f (f z d) c) b) a
06:30:02 <elemir> > foldr f z [a,b,c,d]
06:30:03 <lambdabot>   f a (f b (f c (f d z)))
06:30:27 <elemir> > foldl (flip f) z [a,b,c,d]
06:30:29 <lambdabot>   f d (f c (f b (f a z)))
06:30:53 <elemir> So this function foldr reversed list throw (flip f)?
06:31:03 <elliott> ?
06:31:13 <elliott> > foldr f z [a,b,c,d]
06:31:14 <lambdabot>   f a (f b (f c (f d z)))
06:31:22 <elliott> foldr f z [] = z; foldr f z (x:xs) = f x (foldr f z xs)
06:31:24 <elliott> that's all
06:32:16 <elemir> > foldr (flip f) z (reverse [a,b,c,d])
06:32:18 <lambdabot>   f (f (f (f z a) b) c) d
06:33:01 <elemir> > reverse [a,b,c,d]
06:33:01 <lambdabot>   [d,c,b,a]
06:33:05 <Botje> yes, that's an easier way of writing it.
06:33:40 * elemir confused
06:33:52 <elemir> > foldr (flip f) z [a,b,c,d]
06:33:54 <lambdabot>   f (f (f (f z d) c) b) a
06:34:02 <elemir> Aaaah
06:34:19 <elliott> elemir: foldr replaces all (:)s with the function and the [] with the value
06:34:30 <elliott> a : b : c : d : []
06:34:32 <elliott> ===
06:34:40 <d-snp> I can't use a class as a type? :'(
06:34:40 <elliott> (:) a ((:) b ((:) c ((:) d []))))
06:34:43 <elliott> -->
06:34:47 <elliott> f a (f b (f c (f d z))))
06:34:53 <Botje> d-snp: nope.
06:34:57 <geekosaur> d-snp, not directly
06:35:03 <elliott> d-snp: if you think typeclass is anything like OOP class, think again
06:35:04 <geekosaur> Class a => a
06:35:13 <d-snp> so.. I have to put all my records in one data type?
06:35:17 <elliott> eh?
06:35:27 <d-snp> like data Init {..} | Payload {..} | etc..?
06:35:33 <elliott> no
06:35:44 <geekosaur> but wanting to use a class as a type is indeed indicative of trying to use typeclasses as OOP classes; they are not, and trying to use them that way *will* bite you
06:35:48 <elliott> see http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
06:35:56 <elliott> d-snp: what is the contents of your typeclass?
06:36:06 <elliott> i will show you a data type that is much easier to work with, and just as general.
06:37:06 <d-snp> it just has a toChunk and a fromChunk function to convert it from and back to its slightly less parsed form
06:37:26 <elliott> ah, that one
06:37:37 <elliott> yes, that one uses both input and return-type polymorphism
06:37:42 <elliott> so it's not quite as easy
06:37:43 <elemir> Guys, did someone write already typeclasses records?
06:37:48 <elliott> d-snp: what makes you want to use it as a type?
06:37:54 <elliott> i.e. what specific situation are you in that makes you want that?
06:39:04 <d-snp> well my socketAccept gets these chunks, and then it wants to call fromChunk :: TheTypeItIss on them all, and then calling a handleTheTypeItIss function on it
06:39:28 <elliott> that's a bit too vague :)
06:39:30 <d-snp> but if I could just call fromChunk on them and they'd convert themselves, I could have a generic handleChunk function that uses pattern matching?
06:39:42 <elliott> you're not really making much sense
06:39:45 <geekosaur> no
06:39:48 <d-snp> I'm not am I :(
06:39:48 <elliott> after you call fromChunk, what on earth can you do with the values?
06:39:50 <elliott> they're just "t"
06:39:54 <elliott> you don't know what t is
06:39:54 <geekosaur> pattern matching cannot be used to select types
06:39:57 <elliott> so there's... nothing you can do
06:40:03 <elliott> d-snp: you can extend ChunkType with a
06:40:08 <geekosaur> again, typeclasses are not object oriented programming
06:40:11 <elliott> handle :: t -> IO () or the like
06:40:18 <elliott> but it's unlikely to be the best approach
06:40:22 <geekosaur> don;t think of them as such, dont try to use them as such, it will not work
06:40:27 <d-snp> hmm
06:40:30 <elliott> d-snp: in fact, you should probably remove that class entirely.
06:40:53 * elliott thinks haskell tutorials should order the readers not to define any typeclasses until they're experts :)
06:40:59 <d-snp> lol
06:41:19 * elemir thinks that TAPL is best haskell tutorial :3
06:41:27 * geekosaur suspects that would just cause all of them to try it
06:41:42 <elliott> geekosaur: yes, but here's part 2 to my devious plan
06:41:52 <elliott> we remove typeclass definition support from the haskell platform
06:42:05 <geekosaur> but "typeclasses are not what you think they are.  using them for OOP is an OOPs"?
06:42:07 <elliott> whenever it sees one, it emails spj
06:42:17 <elliott> "Some user has been exceedingly naughty."
06:42:21 <geekosaur> spj would hate it
06:42:26 <elemir> Btw OOP is not OOP!
06:42:31 <d-snp> https://github.com/d-snp/SCTP-in-Haskell/blob/master/sctp/types.hs <-- fromChunk and toChunk implementations if you're interested
06:42:39 <geekosaur> mail haskell-mockery@ ? :p
06:43:17 * hackagebot websockets-snap 0.6.0.1 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.6.0.1 (JasperVanDerJeugt)
06:43:22 <elliott> d-snp: yeah, this is the problem: it doesn't work :)
06:43:28 <elliott> "fromChunk chunk" always has a specific type
06:43:42 <elliott> the typeclass system will not do what you want it to
06:44:27 <d-snp> can't I force it to use a specific type?
06:44:36 <d-snp> like fromChunk chunk :: TheTypeIWant?
06:44:38 <elliott> Yes, you can pick a specific type.
06:44:53 <elliott> I assumed you wanted to have it pick a type (any type) at runtime, which makes no sense.
06:45:19 <elemir> Hem. Does agda support System F?
06:45:31 <geekosaur> but then you talk about doing pattern matching to match the type, which doesn't work
06:45:31 <d-snp> no that wouldn't work, it needs to read something to figure out what type of chunk the bytestream represents anyway
06:45:55 <geekosaur> that'd be backwards
06:46:09 <geekosaur> things like that decide which parser to invoke based on the requested type
06:46:19 <hpc> elemir: yes, if you limit yourself to only the types that can appear in System F
06:46:19 <geekosaur> they do not decide a return type at runtime based on what they parsed
06:46:36 <elemir> hpc: =(
06:46:48 <d-snp> alright, I'll cook something up and then come back here when I've built something :D
06:46:51 <elemir> As in haskell =\
06:47:21 <ksf> ...which you of course *can* do by switching on a tag you read, but you're not going to be able to get around making a sum type that captures all those different types.
06:47:42 <hpc> elemir: at least in agda, you get to say "if this type looks like System F, it is"
06:47:57 <hpc> in haskell, you can have System F-like types with non-terminating values
06:48:12 <ksf> ...at which point the typeclass becomes quite useless, because it's only useful for leaving the whole thing open to add other chunk types, which, otoh, you won't ever get into the original sum.
06:48:24 <elliott> you could create a proposition is_system_effy in agda, right?
06:48:25 * elemir wants to mix dependent types with systemf
06:48:29 <elliott> ranging over sets
06:48:47 <hpc> elliott: i wouldn't be surprised
06:48:56 <elliott> then you just need a dependent tuple of a set and a proof that it's system effy
06:49:02 <elliott> tada, system f in agda
06:49:02 <ksf> in other words: things can work the way you try iff you use Dynamic.
06:49:13 <elliott> ksf: i don't see how Dynamic would help here.
06:49:22 <elliott> you'd need a global Map TagThing Whatever anyway.
06:49:37 <ksf> yes, that'd be the typeclass.
06:49:47 <elliott> eh?
06:49:54 <elliott> no, since each instance corresponds to one Whatever.
06:50:06 <ksf> the dynamic is to allow switching on those types with instances.
06:50:23 <ksf> well, just add the tag to whatever, and make a list of all.
06:50:26 <ksf> it's the way shake works.
06:50:36 <elemir> Dynamic is a very stupid existential
06:50:36 <ksf> shake has a rationale, though, and that's extensibility.
06:50:59 <elliott> ksf: yes, the point is you need a global listing.
06:51:11 <elemir> Dynamic is something like "forall r. (forall a. a => a -> r) -> r"
06:51:17 <elliott> at which point the class becomes useless
06:51:19 <ksf> listing = unsafePerformIO TVar
06:51:23 <elliott> elemir: no, that is not Dynamic at all.
06:51:27 <elliott> that doesn't even make any sense.
06:51:34 <elemir> Why?
06:51:35 <Taslem> How do I ask lambdabot for point-free conversion?
06:51:38 <elliott> Dynamic is a Typeable existential.
06:51:40 <elliott> Taslem: @pl code
06:51:49 <Taslem> Thanks
06:51:53 <elemir> Ou.
06:51:58 <Taslem> @pl (\x -> which x == "a")
06:51:59 <lambdabot> ("a" ==) . which
06:52:00 <elemir> ok :)
06:52:10 <ksf> @info Dynamic
06:52:10 <lambdabot> Dynamic
06:52:13 <ksf> grrr
06:52:16 <elemir> @src Dynamic
06:52:17 <lambdabot> Source not found. That's something I cannot allow to happen.
06:52:26 <Taslem> @pl (\x -> not $ which x == "a")
06:52:26 <lambdabot> ("a" /=) . which
06:52:32 <Taslem> Oh, dur.
06:53:08 <elliott> elemir: data Dynamic = forall a. (Typeable a) => MkDynamic a
06:53:16 <elliott> Except it's implemented in a stupid, equivalent way for reasons I have no idea of.
06:53:17 * hackagebot palindromes 0.2.2 - Finding palindromes in strings  http://hackage.haskell.org/package/palindromes-0.2.2 (JohanJeuring)
06:53:43 <elemir> elliott: I already understand
06:53:49 <ksf> elliott, -XScopedTypeVariables
06:53:57 <elliott> ksf: What?
06:54:04 <ksf> at least in fromDynamic.
06:54:16 <elliott> I don't understand what you are saying.
06:55:15 <elemir> ksf: If you can use Dynamic so you can use more smart existential
06:55:21 <ksf> one half of the strangeness of Data.Typeable is typeOf
06:55:43 <ksf> that's true.
06:56:05 <elliott> My point is that it's implemented as
06:56:10 <elliott> data Dynamic = MkDynamic TypeRep Any
06:56:21 <elliott> which is just silly when an existential would work just fine and not be so gratuitously unportable.
06:56:33 <elliott> (Okay, possibly more things support Any and unsafeCoerce than existentials.)
06:56:33 <ksf> it's in GHCBase, isn't it?
06:56:36 <elliott> No.
06:56:39 <elliott> It's in Data.Dynamic.
06:56:49 <elliott> http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/src/Data-Dynamic.html
06:57:02 <ksf> ah. if*n*def hugs.
06:57:02 <ksf> duh.
06:57:07 <elliott> Oh, it uses "Obj".
06:57:13 <elliott> So it's not strictly Any-only.
06:57:23 <elliott> But still, ugh.
06:57:33 <ksf> elliott, that implementation doesn't need existential quantification, it's that simple.
06:57:44 <ksf> base is supposed to be cross-compiler.
06:57:58 <elliott> ksf: Yeah, instead of existential quantification it uses unsafeCoerce and has to have special checks for different implementation object models.
06:58:05 <elliott> That's much better for portability.
06:58:06 <elemir> @src TypeRep
06:58:06 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:58:31 <elliott> ksf: Also, existential quantification is already used in base.
06:58:38 <elliott> See Control.Exception.
06:58:44 <elliott> So portability is no excuse.
06:58:50 <elliott> I suspect it's for historical reasons or something.
07:06:39 <geekosaur> portability used to matter, actually, it's more recently that base stopped trying to be multicompiler
07:07:09 <geekosaur> there's still a fair amount of nhc compatibility stuff in there, I think, although it tends to get removed when individual files are modified for other reasons
07:10:25 <Taslem> @pl (\x -> if odd x then x + 1 else x)
07:10:25 <lambdabot> join (liftM2 if' odd (1 +))
07:11:59 <geekosaur> ...there's still no if' in base, right?
07:12:07 <dobblego> (1 +) = succ
07:13:07 <geekosaur> @pl \x -> x + x `mod` 2
07:13:07 <lambdabot> ap (+) (`mod` 2)
07:13:19 <elliott> (1 +) is not quite succ
07:13:22 <elliott> > succ maxBound :: Int
07:13:23 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
07:13:25 <elliott> > 1 + maxBound :: Int
07:13:26 <lambdabot>   -9223372036854775808
07:13:30 <dobblego> yeah good point
07:13:40 <elliott> (i think that succ behaviour is stupid)
07:13:49 <dobblego> same
07:13:55 <hpc> (1 +) = (+ 1) though, which is a flip that it did make
07:14:19 <elliott> I always feel uneasy about (+1), as I see no reason it shouldn't be the same as 1.
07:14:31 <gregATio`> im getting the error, the function listDir is applied to two arguments but its type [String] has none
07:14:36 <gregATio`> what does that mean?
07:14:57 <elliott> you applied listDir to two arguments, but it's a list of strings, not a function
07:14:58 <dobblego> gregATio`: it means listDir is a [String] but you're using it as a function by applying it to two arguments
07:15:00 <geekosaur> probably that you misdeclared listDir, if it's supposed to be a function
07:15:01 <elliott> so... exactly what it said
07:16:33 <gregATio`> ah i see
07:16:34 <gregATio`> thanks
07:20:26 <mekeor> so, what's the problem with 'type String = [Char]' and the reason for the existence of Data.Text ?
07:21:13 <hpc> mekeor: linked lists are slow for a lot of operations
07:21:19 <Taslem> "A time and space-efficient implementation of Unicode text. Suitable for performance critical use, both in terms of large data quantities and high speed.  "
07:21:45 <Taslem> It's faster at the expense of not being regular Haskell list.
07:22:27 <mekeor> ah
07:22:52 <elliott> mekeor: it's not only about the speed
07:22:54 <elliott> [Char] has massive overhead
07:23:05 <elliott> 5 words per character, IIRC
07:23:10 <Makoryu> mekeor: It's nice that [Char] works for pattern matching and the standard Data.List functions, but those are pretty much all the upsides. The downsides: It's not unrolled (every element requires two pointers), it's slow (lots of dereferencing)...
07:23:11 <elliott> and lots of thunks
07:23:35 <Taslem> Does regular [Char] support Unicode strings?
07:24:06 <opqdonut> Char is a Unicode Char
07:24:08 <mekeor> what do you mean by 'words'?
07:24:15 <opqdonut> > maxBound :: Char
07:24:15 <lambdabot>   '\1114111'
07:24:20 <Makoryu> mekeor: Groups of bytes in memory
07:24:42 <Makoryu> mekeor: Your processor's "bit width" is usually the word size
07:24:54 <mekeor> ah
07:24:57 <d-snp> what function do I use if I want to execute an IO() function for every element in a list?
07:24:58 <Taslem> Most are 16 now, right?
07:25:19 <mekeor> so, so [Char] is speed and space in-efficient. cool. just like Taslem said.
07:25:39 <opqdonut> d-snp: mapM_
07:25:40 <opqdonut> :t mapM_
07:25:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:25:42 <Makoryu> Taslem: Most processors Haskell works on are 64-bit, with eight byte words
07:25:52 <Taslem> Oh, okay.
07:26:07 <Makoryu> So a string of 100 characters takes up 4000 bytes
07:26:28 <d-snp> thanks opqdonut
07:29:18 <hpc> im trying to install ghc 7.4.1 in a VM and configure isn't finding libgmp.so.3
07:29:37 <hpc> ive installed the dependencies, and 'locate' is finding libgmp.so.4 and a bunch of others
07:29:39 <cwl> how to upgrade haskell-platform in archlinux?
07:29:40 <hpc> but no .so.3
07:30:10 <hpc> (the VM is 64-bit)
07:32:09 <geekosaur> hpc, "vm" is not significant, the linux distribution is
07:32:17 <geekosaur> (the one running inside the vm)
07:32:33 <hpc> ah, debian testing
07:32:36 <ClaudiusMaximus> hpc: afaik, that's because the ghc-7.4.1 binaries are linked to an old libgmp (as found in debian stable) - what i did on debian testing was install ghc-7.0.4 from the distro and build ghc-7.4.1 with it from source
07:33:11 <hpc> ClaudiusMaximus: neat, will try
07:33:36 <hpc> (on the bright side, i have a clone of this VM now, so if this breaks things horribly i can start over)
07:36:33 <hpc> compiling ghc seems simple enough
07:36:37 <hpc> configure, make, install
07:38:01 <ClaudiusMaximus> hpc: use make -j4 (or however many cores you have) to reduce waiting time
07:38:12 <hpc> ClaudiusMaximus: will do
07:38:24 * hpc adds some cores and reboots...
07:38:30 <geekosaur> btw, you should still have libgmp3-dev available in testing
07:38:40 <geekosaur> at least it is on mine...
07:38:42 <hpc> oh wow, ghc's configure script is cool
07:39:05 <hpc> it checks for everything
07:42:24 <snhmib> i can ask question about parsing with happy in here? -- i have problem with a reduce/reduce conflict, i know what is problem, but am not sure how to rewrite the grammar..
07:43:09 <td123> cwl: platform was dropped: http://mailman.archlinux.org/pipermail/arch-dev-public/2012-March/022643.html
07:44:51 <hpc> snhmib: the way i deal with those is to comment out the entire grammar and uncomment parts of it one-by-one from the top
07:47:32 <geekosaur> hpc, I think snhmib is already past that part?
07:47:45 <hpc> ah
07:47:59 <hpc> oh, dur
07:48:22 <hpc> i was taught to refactor recursion that goes the wrong way
07:48:26 <hpc> into foo, and foo-tail
07:48:30 <snhmib> hpc: that's how i found what is the problem.. i.e. i have a "stmt -> expr -> name" (variable-name) and a rule "stmt -> type -> name" (typedef'd-name)
07:49:28 <snhmib> i think solution is to make the lexer look up if it's a typedef name and add a token for that
07:49:54 <geekosaur> that's how I've generally dealt with it when parsing C
07:50:57 <Makoryu> I love it when C programmers bash Perl about stuff like that
07:51:55 <snhmib> geekosaur: thanks that settles it :)
07:52:00 * snhmib goes off to the happy docs
07:52:31 <geekosaur> (it has admittedly been a while, last time I dealt with a C parser was, hm, early-mid 1990s? :p )
07:54:58 <snhmib> explains your nick :P
07:57:13 <hpc> snhmib: haha, well played
07:57:15 <cwl> td123, should I remove haskell-platform and its dependencies and reinstall?
07:57:55 <cwl> td123: for many packages depends ghc-7.0.*, the current version is 7.4.
07:58:25 <franco00> http://hpaste.org/65454 <- found an alternative but still can't understand this error messages. Can somebody explain it to me?
07:58:45 <tsanhwa> hi, I can't create unicode directory with "createDirectory", it just create a directory name with unrecognizable symbol.
07:59:54 <td123> cwl: yes, remove all platform related pkgs, if you're going to need something, I recommend just using cabal
08:03:30 <geekosaur> tsanhwa, what ghc version?  in recent ones FilePath is locale-mapped so if you are in e.g. iso8859/1 locale it will create names with iso8859/1 characters
08:03:46 <hpaste> d-snp pasted “handler” at http://hpaste.org/65460
08:03:46 <quintess`> franco00: ms >>= f is going to give you something in the `m' monad no matter what f is, but your type signature says you're returning a StateT Screen m instead.
08:04:10 <tsanhwa> i tested inside ghci 7.0.3
08:04:11 <d-snp> what do you think guys? is there a better way to implement the handler function?
08:04:22 <tsanhwa> geekosaur:  i tested inside ghci 7.0.3
08:04:47 <geekosaur> oh, 7.0.3.  shouldn't be doing any translation there
08:04:57 <geekosaur> which has its own issues, as file paths are not in fasct utf8
08:05:12 <d-snp> elliott? :) ^^
08:05:34 <geekosaur> it's common to pretend they are but you can and shuld expect brokenness because they're not (and there are some security ramifications to pretending they are)
08:07:13 <elliott> d-snp: it looks ok to me
08:07:28 <tsanhwa> geekosaur: so I have to use a newer version ?
08:07:28 <elliott> i would suggest throwing an exception if checksum validation fails
08:07:34 <elliott> and explicitly catching it in the main loop if you want to ignore it
08:07:47 <tsanhwa> geekosaur: which version do you know works?
08:07:54 <elliott> (a) avoids a level of nesting, (b) it's yucky to mix the "policy" of dropping invalid messages into the handling code like that, throw an exception for everything and handle it if you want to ignore it
08:08:10 <d-snp> elliott: no, the RFC specifies that you MUST silently discard the packet if the checksum fails
08:08:13 <d-snp> their emphasis ;)
08:08:21 <geekosaur> *sigh* I suppose the appproved answer is forget I said anything, because it's only idiots who believe the filesystem isn't UTF-8 or who care about the secuirty implications of treating it as such
08:08:37 <d-snp> there's a lot of provisions for DoS vulnerabilities and such
08:09:17 <d-snp> things like it's not allowed to allocate any memory for Init requests that have not had their cookies acked
08:09:29 <ksf> utf8 is the only sensible thing aside from ascii.
08:09:45 <d-snp> I'm not at the point that I can go and check if I fulfull all these requirements, but at some point I will have to :P
08:09:54 <geekosaur> ksf, unix filesystems do not have encodings
08:09:56 <geekosaur> at all
08:10:00 <ksf> indeed.
08:10:11 <ksf> and so ascii/utf8 is the only sensible thing.
08:10:21 <geekosaur> pretending they do is common.  pretending they do means gtk+ and os x programs can be coerced to drop core or open the wrong files, trivially
08:10:38 <geekosaur> note, that is pretending they are utf8!
08:10:49 <geekosaur> utf8 is NOT the sensible thing
08:11:11 <d-snp> you mean sjis/utf8 ?
08:11:14 <ksf> a filename is a string of octets not containing / or \0
08:11:43 <ksf> if your program chokes on utf8, it'd choke on other non-ascii filenames, too.
08:12:12 <hpc> ksf: there's some strange circumstances where you can get a '/' into a filename
08:12:17 <ksf> there's of course presentation and normalisation issues, but tell you what, those have specs and again applying them is the sensible thing.
08:12:26 <hpc> but you have to write the file at a really low level
08:12:42 <ksf> I don't think linux lets you do that.
08:12:51 <ksf> osx, otoh, with its legacy...
08:13:07 <hpc> you skip the kernel and issue commands to the hard drive hardware directly
08:13:11 <ksf> ntfs can probably do it, too.
08:13:25 <geekosaur> osx doesn't either
08:13:28 <ksf> ...breaking the filesystem.
08:13:30 <ksf> gigo.
08:13:33 <franco00> thanks quintess` , now I clearly see it :)
08:13:35 <hpc> and now i can't find the article that talked about it...
08:13:56 <geekosaur> osx has a translation layer in the carbon and cocoa apis, which is not present in the lower level BSD/UNIX API
08:14:01 <geekosaur> (it swaps : and /)
08:14:25 <Makoryu> OS X does have a very weird user interface quirk where ':' becomes a slash in certain--yeah
08:14:49 <DrSyzygy> layover from MacOS <10 where : was the path separator.
08:15:05 <hpc> wacky fun
08:15:15 <geekosaur> Makoryu, it's because Carbon (the old MacOS API) uses : as the path separator.  for historical reasons so do Finder and Applescript
08:15:22 <Makoryu> Yeah
08:15:33 <geekosaur> so yeh, weird translation stuff going on
08:15:50 <Makoryu> From the point of view of someone who doesn't know the history it's totally ridiculous, of course
08:16:17 <ksf> in windows' case, knowing the history makes the thing even more ridiculous.
08:16:56 <ksf> DOS could already use / as separator and - as commandline switch, there was an undocumented flag to set it.
08:17:08 <Makoryu> Welp
08:17:25 <ksf> ...as the coders didn't like IBM's call to make the thing unnecessarily backwards-compatible.
08:17:25 <geekosaur> SWITCHAR in CONFIG.SYS :)
08:17:28 <hpc> ksf: i bet it broke everything
08:17:37 <ksf> I heard it worked flawlessly.
08:17:51 <hpc> huh
08:17:52 <ksf> well, at least until you tried to run cpm software.
08:18:08 <geekosaur> it worked with the procided programs and some others, bu ttoo many third party programs "knew" that / was the only acceptable SWITCHAR
08:18:08 <ksf> thing is, once IBM cought wind of it they made MS remove the flag.
08:18:15 <geekosaur> huh?
08:18:18 <geekosaur> no
08:18:29 <geekosaur> Microsoft removed the flag themselves
08:18:35 <ksf> ...yeah. because of IBM.
08:18:36 <geekosaur> also removed AVAILDEV
08:18:38 <geekosaur> ni
08:18:46 <geekosaur> they removed it when they decided that Unix was evil
08:18:59 <geekosaur> before that they actually had a migration plan from DOS to Xenix (!)
08:19:37 <elliott> "IBM told them to" ranks about 10x above the plausibility-o-meter than "they decided Unix is evil"
08:19:56 <ksf> hmm. can't find my source right now.
08:20:01 <geekosaur> I'm sure it does to youngsters who don't know Microsoft histirty
08:20:35 <ksf> ...back then, IBM was what apple is today.
08:20:50 <hpc> elliott: microsoft did abruptly decide that unix was evil though
08:20:58 <ksf> needs some kind of adjustment, not seeing ms as evil incarnated, as I learned in my formative years.
08:21:03 <hpc> and that attitude has carried over until even quite recently
08:21:11 <elliott> hpc: certainly, never said they didn't
08:21:37 <elliott> hpc: but ripping out an undocumented flag doesn't seem a very likely consequence of that.
08:21:40 <ksf> the thing is that they realised that relying on windows as a cash cow is a bad idea.
08:22:04 <elliott> anyway it's true, i'm an endless well of ignorance.
08:22:46 <hpc> elliott: ha, you should see me in #agda
08:22:56 <hpc> now THAT's an endless well of ignorance
08:25:04 <geekosaur> elliott, if it were just that one flag, you would have a point.  it was multiple flags and *an entire migration plan* that got ripped out
08:25:46 <ksf> well, they did switch to NT. which is a unix, albeit an *extremely* poor one.
08:25:47 <hpc> im still waiting for them to decide exchange is their cash cow and sendmail is evil
08:26:04 <ksf> (enough to slap POSIX on it for contracts but not enough to run programs)
08:26:10 <hpc> because then they would at least be correct :P
08:26:17 <ksf> exim.
08:26:38 * geekosaur wishes he still had that documentation, there was a roadmap for DOS development which had it gradually adopting Xenix features, such that around DOS 6 it would *be* Xenix with a different facade
08:30:53 <gentleben> in many ways the nt design is superior to unix
08:31:12 <hpc> just not the ways that make it actually superior
08:31:19 <gentleben> happens when you come along later
08:31:20 <elliott> ksf: that's not true
08:31:27 <elliott> in that there's a pretty good POSIX that runs on top of NT.
08:31:39 <elliott> it's the Win32 subsystem that's no good
08:31:59 <hpc> at least win32 is going away
08:32:03 <elliott> (I refer to the Unix subsystem, aka Interix)
08:32:12 <elliott> (There's an official Gentoo distribution for it.)
08:32:12 <gentleben> yes, the raw nt apis are really powerful
08:32:19 <elliott> (It's a lot faster than Cygwin.)
08:32:20 <gentleben> win32 will never go away
08:32:42 <copumpkin> interix and asterix?
08:34:34 <pozic> gentleben: it's already gone here.
08:34:51 <gentleben> well, were you ever using it
08:35:11 <pozic> gentleben: yes, I just found other (better) ways to solve problems.
08:35:49 <gentleben> the idea the win32 is dead as a platform is nuts, so much of the world depends on it
08:35:52 <pozic> I can likely switch OS in a week or so.
08:36:14 <gentleben> then you don't take advantage of your OS?
08:36:24 <pozic> gentleben: that notion is kind of outdated.
08:36:40 <pozic> gentleben: I can run the same system on my _phone_.
08:37:11 <ksf> elliott, it may be better nowadays, but back then it seriously sucked.
08:37:26 <gentleben> no, that notion is not outdated. By building cross platform code you must constrain yourself
08:37:33 <pozic> gentleben: er, no.
08:37:36 <elliott> ksf: nah, i think what sucked was the toolchain they shipped it with
08:37:40 <elliott> ksf: ancient ksh etc
08:37:48 <ksf> yeah, 2003 server+
08:37:51 <pozic> gentleben: because you always do platform specific optimizations, if you want.
08:37:55 <ksf> exactly.
08:37:55 <elliott> ksf: hm?
08:37:59 <elliott> no, it's available for XP too
08:38:04 <elliott> ksf: btw i think the "windows passed posix" thing wasn't for interix
08:38:15 <elliott> because i heard that they e.g. used a stubbed out fork() and the like
08:38:18 <gentleben> uh, yes. Platforms differ.
08:38:22 <elliott> whereas interix has fully-fledged fork() and so on
08:38:41 <elliott> and uh interix is barely windows, seeing as it completely skips all the windows parts of things
08:38:42 <pozic> gentleben: tell me just one thing for which I would need e.g. Windows.
08:38:48 <ksf> ...yeah, I'm misreading the wikipedia page.
08:38:55 <pozic> gentleben: or which has major performance advantages.
08:39:06 <gentleben> phones differ from PCs in a variety of ways which differ from servers
08:39:11 <gentleben> the async apis
08:39:17 <gentleben> linux async sucks
08:39:18 <ksf> the posix label was for contracts, virtually all of which had "posix-compatible operating system" written in it.
08:39:26 <pozic> gentleben: haha, sure it does.
08:39:33 <hpc> pozic: they let light into the house
08:39:38 <gentleben> specifically the way the kernel handles it
08:39:47 <hpc> ;)
08:39:51 <gentleben> sun got it more right with event ports
08:39:52 <pozic> gentleben: show me performance numbers, KTHX BYE.
08:39:55 <ksf> so ms had to make windows posix-compatible to get companies to consider writing windows apps for others
08:40:09 <gentleben> hehe
08:40:16 <gentleben> you want some contrived benchmarks
08:40:16 <elliott> i think this is getting off-topic :P
08:40:23 <geekosaur> specifically it was government contracts that had the POSIX compliance thing going on
08:40:38 <geekosaur> (US gov't)
08:40:56 <pozic> gentleben: you are just saying that you don't have a benchmark.
08:41:20 <pozic> gentleben: there are various async interfaces and there are all more or less equal.
08:41:33 <pozic> gentleben: that's why there are APIs that abstract over them.
08:41:48 <pozic> gentleben: which is the kind of API you would use (at zero run-time cost) to talk to them.
08:42:14 <gentleben> not, handy. We do have someone we consult with on these issues that does kernel work
08:42:25 <gentleben> to be clear we are a linux shop
08:42:37 <gentleben> but i still cry about the state of certain things
08:42:46 <gentleben> and wish they would catch up
08:42:54 <gentleben> there is nothing with 0 runtime cost
08:43:09 <pozic> gentleben: uhm, yes there is.
08:43:31 <pozic> gentleben: anyway, if Linux is your performance bottle neck... what are you doing?
08:44:02 <pozic> gentleben: You can get 40000 http requests on a Linux box per second.
08:44:13 <gentleben> linux is not our performance bottleneck. It lacks many features that I had become used to
08:44:20 <pozic> gentleben: like?
08:44:35 <elliott> this should probably go in -blah, guys.
08:44:43 <gentleben> like system wide performance counters what were easy to hook into
08:44:55 <gentleben> although we have something like this now for all our haskell code
08:45:11 <dobblego> hi there, mind taking it to #haskell-blah please?
08:45:14 <pozic> gentleben: #haskell-blah
08:45:19 <dobblego> thanks!
08:46:02 <ksf> pozic, http://www.returninfinity.com/baremetal.html
08:46:43 <ksf> should'nt be too hard to cross-compile haskell for it
08:46:54 <ksf> ...the runtime runs on xen too, after all.
08:47:00 <pozic> ksf: yeah, that kind of stuff is neato.
08:47:34 <pozic> ksf: http://qubes-os.org/Home.html
08:47:40 <pozic> ksf: more neato stuff.
08:48:23 <ksf> about the exact opposite.
08:49:02 <ksf> baremetalos is intended as a minimum os for cluster nodes, qubes is used to make a single box a cluster
08:49:10 <ksf> (fsvo "cluster")
08:50:33 <hpaste> savask pasted “Reactive Snake” at http://hpaste.org/65462
08:50:35 <savask> Hello. I'm writing a snake in reactive-banana, and I have one trouble here - a deadlock. I have a snake behaviour which relies on egot event which represents getting a fruit by snake. But egot uses esnake event to filter events which mark getting a fruit. How can I restructure events and behaviours so that it will work right?
08:51:24 <ksf> I don't know reactive-banana, but you might need a delay.
08:51:30 <elliott> reactive-banana has no delays.
08:52:17 <Chaze> I'm reading here that a function f :: () -> t would make no sense in haskell
08:52:21 <elliott> savask: http://stackoverflow.com/questions/7850389/can-reactive-banana-handle-cycles-in-the-network may help
08:52:23 <Chaze> i'm somehow doubting that
08:52:25 <elliott> Chaze: that's just the same as f :: t
08:52:30 <elliott> what are you reading?
08:52:39 <ksf> it definitely makes sense.
08:52:44 <Chaze> let f = \() -> 42
08:52:51 <Chaze> is not the same as let g = 42
08:52:54 <ksf> as f :: t would be a CAF, f :: () -> t isn't.
08:53:04 <savask> elliott: Ok, hope that will help.
08:53:05 <Chaze> CAF?
08:53:10 <hpc> Chaze: constant applicative form
08:53:12 <ksf> constant applicative form.
08:53:42 <Chaze> in non-lazy languages, those lambda functions with 0 arguments are quite useful
08:53:43 <elliott> Chaze: ksf is just talking about implementation details
08:53:45 <elliott> ntohing about Haskell itself
08:53:46 <ksf> http://stackoverflow.com/a/5032920/284593
08:53:50 <Chaze> i see
08:53:57 <ksf> THAT'S NOT AN IMPLEMENTATION DETAIL
08:53:57 <elliott> *nothing
08:53:58 <Chaze> but is it really useless to have these in haskell?
08:54:11 <elliott> ksf: yes it is.
08:54:16 <elliott> so is evaluation strategy
08:54:25 <hpc> Chaze: compare (f = \() -> reallyExpensive42) and (g = reallyExpensive42)
08:54:36 <hpc> Chaze: g will not be recalculated when you use it twice
08:54:42 <hpc> f () will
08:54:43 <elliott> (Again, in some implementations.)
08:54:53 <hpc> (assuming ghc, yeah)
08:54:59 <ksf> elliott, I think if you pursue that line of argument further you'll come up with "sufficiently dumb compiler"
08:54:59 <elliott> I don't think GHC guarantees that all the time.
08:55:13 <hpc> elliott: for top-level CAFs it does
08:55:15 <rwbarton> in practice GHC is very likely to share reallyExpensive42 in f as well
08:55:20 <elliott> ksf: What line of argument? Chaze is asking about Haskell. The Report doesn't talk about thunks or sharing or constant-applicative forms.
08:55:45 <elliott> I don't think operational details are really relevant to the question of whether (() -> t) is useful in Haskell as a separate entity with its own use-cases from t.
08:55:50 <ksf> yes, but is there a sensible way to do it differently?
08:55:51 <elliott> (To which the answer is basically no, of course.)
08:55:55 <ksf> well, at least without supercompilation.
08:56:07 <Chaze> the paper i'm reading claims it would be a senseless type because its equivalent to a value t
08:56:12 <Chaze> which it is clearly not
08:56:23 <elliott> Yes, it is.
08:56:26 <ksf> no, it isn't.
08:56:28 <elliott> (Modulo _|_ corner cases.)
08:56:34 <ksf> you have a bottom more exactly
08:56:34 <Philippa> you're arguing about /what the equivalence is/
08:56:36 <elliott> It's morally equivalent.
08:56:38 <Chaze> > const 42
08:56:39 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
08:56:39 <lambdabot>    arising from a use of `...
08:56:46 <Chaze> is not equivalent to 42 either
08:56:54 <elliott> You're misinterpreting "equivalent".
08:56:56 <magicman> > const 42 == 42
08:56:57 <lambdabot>   *Exception: (==): No overloading for function
08:57:01 <elliott> There's an isomorphism (modulo one extra _|_).
08:57:04 <ksf> it's isomorphic up to morally correct fast and loose reasoning.
08:57:16 <magicman> (I like how, in Caleskell, that's not even a type error :p)
08:57:16 <elliott> i.e., (() -> t) contains the *same information* as a t.
08:57:21 <hpc> in a language like agda, it would be isomorphic
08:57:23 <elliott> You can get a t out of () -> t, and stuff a t into a () -> t.
08:57:35 <elliott> So (() -> t) "is just" t.
08:57:42 <ksf> in disciple, the two make a hell a lot of difference.
08:57:55 <elliott> First Haskell is GHC, now Haskell is Disciple... sheesh :)
08:57:58 <ksf> ...because that arrow can carry an effect.
08:59:16 <Philippa> elliott: "implementation details" in Haskell have a suspiciously wider scope than in most languages. As in practice people care about little things like not running out of storage doing something that should fit in a small constant space, it's not unreasonable to discuss it. You might want to consider using different language to discuss the fact the Report doesn't actually mandate anything
08:59:17 <Philippa> about this
09:00:00 <ksf> yep.
09:00:16 <ksf> in the end, actually running your code is a implementation detail, too ;)
09:00:20 <elliott> Philippa: I think bringing up CAFs when the question is about someone stating the equivalence of (() -> t) and t is implementation detail territory.
09:00:26 <Philippa> especially as it's perfectly possible to describe issues like sharing /in terms/ of Haskell
09:00:27 <elliott> It's relative to the topic in question.
09:00:40 <elliott> I don't think it's over-academic in this case. When discussing e.g. implementation of actual algorithms, sure.
09:00:53 <ksf> is there a single haskell implementation that makes no operational difference between those two?
09:00:55 <Philippa> I think it's worth making it clear /what/ the equivalence is and how wide the wiggle room left is
09:01:02 <Chaze> my question was more related to the actual usefulness of a () -> t type from a programming pov
09:01:28 <ksf> for a theoretican, there is none, for a programmer, in practice, there is.
09:01:31 <ksf> or at least can be.
09:01:42 <Philippa> Chaze: quite. In Haskell, it's got operational uses. In an impure language? Big difference
09:01:44 <andares> what is the type of ()? I'm confused.
09:01:49 <Philippa> () :: ()
09:02:01 <andares> .. ?
09:02:03 <Chaze> read as "Unit" iirc
09:02:05 <ksf> :t ()
09:02:05 <elemir> :t ()
09:02:06 <lambdabot> ()
09:02:06 <lambdabot> ()
09:02:11 <geekosaur> () is both type constructor and data constructor
09:02:14 <ksf> @src ()
09:02:14 <lambdabot> data () = ()
09:02:17 <elliott> (Like [].)
09:02:20 <geekosaur> this is not uncommon in haskell
09:02:24 <elliott> (Except it has a different arity at each layer.)
09:02:27 <andares> ohhh
09:02:35 <andares> so what is it used for?
09:02:39 <Makoryu> andares: It's a bit like the type "void" in the C family.
09:02:55 <andares> so shouldn't () -> t be equivalent to t?
09:02:57 <ksf> but not really.
09:03:01 <Philippa> elliott: handwaving it away /is/ "over-academic", FWIW. Really, rephrase in future
09:03:02 <andares> or is that what this whole discussion is about.
09:03:02 <elliott> andares: It is (modulo _|_).
09:03:04 <ksf> denotationally, yes.
09:03:05 <Makoryu> Basically, for when you want to signify a side effect, or the equivalent of a side effect in certain contexts.
09:03:14 <rwbarton> no side effect
09:03:17 <Chaze> well in python (lambda: 42) and 42 are totally not the same
09:03:22 <andares> elliott: what's _|_?
09:03:24 <rwbarton> but an action that doesn't have a result value
09:03:26 <Chaze> but thats a different story, because its a non-lazy language
09:03:37 <ksf> andares, bottom, aka undefined.
09:03:40 <ksf> > undefined
09:03:41 <lambdabot>   *Exception: Prelude.undefined
09:03:42 <Philippa> Makoryu: or fill in a type parameter with "we aren't really using it"
09:03:50 <ksf> well, not only undefined, but also
09:03:55 <ksf> > let x = x in x
09:03:59 <lambdabot>   mueval-core: Time limit exceeded
09:04:02 <Philippa> Chaze: we embed strict and/or side-effecting languages into Haskell all the time, though
09:04:05 <elliott> Philippa: I wasn't handwaving it away - I just didn't think jumping straight to those operational details before covering the equivalence itself was helpful, like responding to a question about the famous mutually-recursive primes program by talking about the opcodes GHC produces.
09:04:09 <Makoryu> Philippa: Yeah I wasn't really gonna get into that, as such
09:04:16 <ksf> the value of all computations that don't return a value.
09:04:55 <Philippa> elliott: you'd stated the equivalence before anyone else mentioned CAFs
09:05:07 <Philippa> I suspect others may have been expecting you to continue covering it
09:05:12 <andares> so when elliott said modulo _|_, he meant it could return undefined or something?
09:05:21 <Philippa> andares: yep
09:05:28 <Philippa> or just recurse infinitely
09:05:29 <andares> ah
09:05:35 <elliott> Philippa: fair enough.
09:05:53 <rwbarton> well actually the issue is that f :: () -> a could either evaluate its argument, or not
09:06:09 <elliott> Philippa: I didn't mean "implementation details" pejoratively at all - implementations themselves are implementation details, after all - but I'll take it into account.
09:06:28 <Makoryu> Hey are there even all that many situations where () even needs a proper value
09:06:36 <ksf> ...though it can't even use the result of evaluating it in any meaningful way.
09:06:42 <Makoryu> > return undefined >> return True
09:06:43 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Bool.Bool))
09:06:44 <lambdabot>    arising from a use of ...
09:06:54 <Philippa> elliott: "just implementation details... nothing about Haskell itself" is likely to be read at least dismissively
09:07:13 <elliott> Philippa: yeah, fair enough
09:07:19 <Philippa> and it's not a good idea to assume that random people mean Report Haskell when they say Haskell
09:07:25 <Philippa> Haskell is a cluster concept
09:07:30 <elliott> ksf: well, it can: to withhold or supply the value it has based on whether the argument is _|_ or not :p
09:07:35 <Philippa> which could be worse
09:07:40 <Philippa> C++ is a clusterfuck concept
09:07:47 <Makoryu> （　≖‿≖）
09:08:13 <ksf> in ghc-land, it could go so far as to catch NonTermination
09:08:43 <Philippa> yoinking code out of a BlackHole?
09:09:22 <elliott> ksf: if we're talking about GHC land...
09:09:27 <elliott> then (() -> a) contains an awful lot of side effects
09:09:34 <elliott> many of them of a segfaulty nature
09:10:14 <ksf> the nice thing with disciple is that it actually types all of those.
09:10:18 <Philippa> remind me: isn't unsafePerformIO part of the FFI and thus in the Report these days?
09:10:25 <elliott> no
09:10:28 <elliott> they substituted unsafeLocalState
09:10:30 <ksf> ...or at least tries so. I'm not aware of it not being able to track all.
09:10:41 <elliott> which is just like unsafePerformIO, but invokes the god of Undefined Behaviour if you do anything other than a few things inside it
09:10:49 <elliott> (I think possibly enough to make it RT, but I'm not sure)
09:11:01 <elliott> totally wimpy :P
09:11:20 <ben> elliott: Is the undefind behavior coincidentally the same behavior as unsafePerformIO?
09:11:21 <ksf> instance MonadFix STM where fix = fixIO
09:11:30 <ksf> err, unsafeCoerce fixIO
09:11:32 <ben> I mean in current implementations
09:11:40 <ksf> *that actually works*
09:12:01 <Philippa> ben: it's /undefined/
09:12:06 <andares> :t unsafePerformIO
09:12:07 <lambdabot> Not in scope: `unsafePerformIO'
09:12:13 <ben> Philippa: But not unimplemented
09:12:16 <ksf> IO a -> a
09:12:19 <Philippa> so unsafePerformIO, nasal demons, 'sall up to the implementation
09:12:21 <elliott> ben: in GHC yes
09:12:39 <andares> is it ever needed?
09:12:45 <elliott> it would be nice if we could get it to play hanoi or something if you violated the rules
09:12:50 <elliott> nobody ever takes liberties with UB
09:12:55 <ksf> "need" is a harsh word.
09:13:06 <Philippa> elliott: one C compiler started Rogue for UB
09:13:07 <elliott> andares: yes. but very rarely.
09:13:20 <ksf> after all, you can express all of haskell in lazy-k, and lazy-k has no unsafePerformIO.
09:13:24 <elliott> Philippa: gcc used to try and start nethack then rogue then (tetris in emacs or something?) if you gave it a pragma
09:13:31 <elliott> but that's just implementation-defined behaviour, not UB :(
09:14:07 <ben> elliott: heh. and if someone asks what you are doing playing nethack on the job, you can say you're just waiting for the compiler to terminate. :)
09:14:08 <Philippa> andares: it's never /needed/ to do something that's just pure computation. You may have impure concerns
09:15:08 <Makoryu> andares: For certain APIs it's considered idiomatic to have global variables, and unsafePerformIO is pretty much the only way to get those
09:15:13 <elliott> not sure I agree -- you need unsafeCoerce to do "some" pure computations that have sufficiently complex types in the middle
09:15:25 <elliott> although ofc nothing's stopping you remodelling your problem in the untyped lambda calculus and bundling an interpreter
09:15:48 <elliott> (I guess the unsafeCoerce-through-unsafePerformIO trick isn't portable, but nothing much about unsafePerformIO is portable)
09:15:51 <Philippa> yeah, you get a Church vs Curry argument there
09:16:02 <ksf> "any sufficiently complicated haskell program comes with an underspecified, bug-ridden implementation of coq on the type level"
09:19:04 <magicman> ... and now I have a mental image of clergy getting angry at Indian restaurants. Thanks v_v
09:20:44 <elliott> magicman: Then a politician shows up.
09:20:52 <elliott> Church vs. Curry vs. State
09:21:02 <magicman> xD
09:21:05 <ksf> oh so that's why disciple has that religious name theme.
09:21:11 <ben> So what's the deal with vector-bytestring?
09:21:25 <ben> Are vector-based bytestrings THE FUTURE or rather a "hey, we can do this with not a lot of effort" curiosity
09:21:41 <elliott> ben: They should probably be the future. They're not yet; stick to bytestring.
09:22:00 <dolio> There's a problem with them currently, I think.
09:22:22 <dolio> Same problem as Text, I think, though.
09:22:34 <ben> Oh, what's the problem with Text?
09:22:49 <ben> I should probably some mailing list more often.
09:22:57 <dolio> Vectors are ByteArray# based, so to pass them out to C, you have to copy.
09:23:09 <dolio> So is Text, i think.
09:23:17 <dolio> ByteStrings are ForeignPtr based.
09:23:23 <ben> Cripes, the vector-bytestring blurb says "can be passed between C and Haskell with little effort."
09:23:25 <dolio> So you can pass them out to C easily.
09:23:34 <elliott> dolio: I don't think that's true.
09:23:37 <ben> I suppose they just copied that from the old bytestrings
09:23:37 <elliott> It uses Storable Vectors.
09:23:46 <dolio> Oh, it does? Okay.
09:23:57 <elliott> ben: No, I definitely remember C interaction being talked about when vector-bytestring came out.
09:24:06 <elliott> It wouldn't even be a remotely viable proposal if that wasn't doable.
09:24:11 <elliott> I could be wrong, but I'd be surprised.
09:24:30 <ben> Well, it does use Storable Vectors, so you are right about that.
09:24:31 <dolio> If it uses Storable vectors it's fine.
09:24:47 <dolio> Because those are ForeignPtr based for whatever reason.
09:24:59 <elliott> dolio: presumably because the Storable API is Ptr based
09:25:02 <dolio> Oh, I guess it's because Storable is ForeignPtr based.
09:25:04 <ksf> computers should have cow memory.
09:25:08 <ChristianS> "vector-bytestring-0.0.0.1: ByteStrings as type synonyms of Storable Vectors of Word8s"
09:25:11 <ben> ksf: moo
09:25:27 <ksf> would make a lot of stuff a lot easier.
09:25:39 <dolio> Anyhow, Text does have that problem, I believe.
09:25:45 <ksf> actually, that ought to be possible even now.
09:25:46 <ben> I suppose if all your strings are multiples of the page size you can implement that on some level?
09:25:55 <elliott> ksf: Cow memory as opposed to ram?
09:26:00 * elliott rimshot
09:26:04 <ksf> cow as in copy on write
09:26:06 <ben> oh dear
09:26:14 <ben> i retract my moo, i like your ram better
09:26:14 <elliott> SHHHHHHHHH YOU'RE RUINING MY JOKE
09:26:32 <ksf> hmm.
09:26:40 <ksf> lemme guess. ram = male sheep
09:26:47 * ksf isn't a native speaker.
09:26:51 <ben> So what's the tradeoff that is making the Text guys stick with their ByteArray#s?
09:26:56 <elliott> yep
09:27:19 <hpc> data Moo cow = Moo {ram :: cow (Moo cow)}
09:28:05 <ksf> ben, I don't think passing utf16 to c is a common operation.
09:28:30 <c_wraith> ksf: windows libraries mostly use utf16.
09:28:36 <ksf> text generally doesn't have that low-level thing like bytestring.
09:28:53 <c_wraith> but...  binding to windows libs isn't a common operation
09:29:03 <elliott> ksf: yes it does
09:29:04 <elliott> text-icu
09:29:13 <elliott> by the same author
09:29:24 <elliott> ksf: indeed, ICU and other C libs was one of the factors in keeping UTF-16 representation over UTF-8
09:29:47 <ben> but glib and libxml2 use utf-8 strings, don't they ;)
09:30:22 <ben> and of course folks like the posix API do at some level, but I guess this is only about heavy-duty unicode shenanigans
09:30:25 <dolio> ben: Byte arrays are nice, because they're totally managed by the garbage collector. And I think they may have been faster for some tests.
09:30:26 <ksf> well it dosn't make much sense to keep it if you have to copy, as copying and converting should have the same performance modulo statistical noise.
09:31:08 <elliott> ben: pfft, as if gtk2hs did Text
09:32:03 <dolio> ben: Byte arrays also have mutable and immutable versions, unless I'm mistaken. ForeignPtr libraries have inlinePerformIO sprinkled all over for immutable arrays.
09:32:14 <dolio> Although that's probably not a big deal.
09:35:00 <otters> :t inlinePerformIO
09:35:01 <lambdabot> Not in scope: `inlinePerformIO'
09:35:03 <ben> I'm still clinging to the idea that utf-8 is easier to use because you can pretend that it's ascii for a lot of operations and APIs :(
09:35:24 <ben> otters: "ust like unsafePerformIO, but we inline it." http://hackage.haskell.org/packages/archive/storablevector/latest/doc/html/src/Data-StorableVector-Base.html#inlinePerformIO
09:35:27 <ben> +J
09:35:57 <ben> I don't quite understand why it's unsafer, but I'll take their word for it
09:36:59 <geekosaur> because inlining something like newIORef means potentially getting a new one more or less often than you think you will?
09:37:47 <elliott> inlinePerformIO means that every little piece of your action inside can get scattered into a million pieces iirc
09:37:55 <ben> ah
09:38:07 <ben> that's neat, I never thought of unsafePerformIO as preventing that
09:38:16 <elliott> unsafeDupablePerformIO is enough to get the unwanted duplication, but inlinePerformIO can cause your action to explode everywhere, or something
09:38:29 <elliott> ben: unsafePerformIO gives you way more guarantees than you deserve :P
09:38:56 <ben> I like that the very unsafe variant doesn't have unsafe in the name, but I guess that's why nobody ever talks about it
09:39:18 <elliott> It should join the likes of reallyUnsafePtrEquality#.
09:39:26 <elliott> Which, ironically, is one of the safest "unsafe" operators!
09:39:41 <elliott> It's just not referentially transparent. No side effects, no segfaults, nothin'.
09:40:04 <rwbarton> I've never successfully gotten reallyUnsafePtrEquality# to return True
09:40:12 <rwbarton> so afaict it is referentially transparent as well
09:40:28 <ben> hahaha
09:42:08 <elliott> rwbarton: let x = () in x `seq` reallyUnsafePtrEquality# x x
09:42:16 <elliott> Guaranteed!
09:42:36 <ben> where's it from anyway? doesn't come up on hayoo
09:43:00 <ben> GHC.Prim I guess
09:43:42 <elliott> ben: GHC.Prim via GHC.Exts, yes.
09:43:48 <elliott> Hayoo wouldn't index such filth.
10:03:25 <gdoteof> if i `import Data.Time'  and do `now = getCurrentTime` now is being bound to something with type (IO UTCTime) when all i relaly want is the UTCTime (not a synonym for the function to get the current time)
10:03:25 <lambdabot> gdoteof: You have 1 new message. '/msg lambdabot @messages' to read it.
10:04:31 <jfhall> gdoteof: it's because getCurrentTime is an IO action, it has to access the real world (outside of the Haskell world) to get the current time
10:04:57 <gdoteof> jfhall: yeah i did get that.  i tried doing (_, now) = getCurrentTime
10:06:18 <gdoteof> (which i understand why it doesn't work)- i just don't know how to 'get' a UTCTime from that IO action
10:06:19 <jfhall> gdoteof: why would you do that? If you want to get the value without dealing with the monad, then just use unsafePerformIO
10:06:49 <gdoteof> jfhall: in plain english what i want to do is get the current time into a UTCTimew
10:07:08 <jfhall> gdoteof: I guess you should use unsafePerformIO then
10:07:14 <elliott> uh.
10:07:19 <elliott> no, gdoteof should not use unsafePerformIO.
10:07:21 <jfhall> it's not safe...
10:07:28 <elliott> gdoteof: main = do { now <- getCurrentTime; ... }
10:07:30 <c_wraith> if you want to do that, use Acme.Now
10:07:57 <c_wraith> the fact that it's named Acme.whatever should be a hint that it doesn't work right :)
10:07:59 <jfhall> elliott: he said he wants just the UTCTime, so I'm assuming he doesn't want to deal with IO
10:08:12 <elliott> jfhall: that seems like a rather bad-faith interpretation of gdoteof's question.
10:08:26 <elliott> it's the standard "How do I get an Int out of IO Int?" -- the answer is binding
10:08:28 <c_wraith> jfhall: seems *awfully* difficult to get the current time without doing IO.
10:08:49 <jfhall> c_wrath: that's what I was initially telling him
10:09:38 <jfhall> c_wraith: but he didn't seem to want to work inside the monad, which obviously is a problem...
10:09:55 <c_wraith> But having a value of UTCTime doesn't mean not using a value of type IO UTCTime..  It just means separating getting the current time from using it.
10:10:06 <jfhall> I know
10:10:12 <elliott> jfhall: don't you find it more likely they simply don't know _how_?
10:10:34 <Sgeo> jfhall, if someone doesn't understand IO, why would you point to unsafePerformIO?
10:10:40 <jfhall> elliott: thinking about it now, I overestimated what he probably understood
10:10:42 <Jafet> What is the "current" time? Oh wait, I thought this was ##philosophy.
10:10:58 <jfhall> Sgeo: I didn't know he didn't understand IO...
10:11:15 <ben> How do I get the Int out of a Text.Parsec.Parser Int?
10:11:24 <c_wraith> ben: unsafeCoerce
10:12:34 <elliott> gdoteof: *anyway*
10:12:37 <elliott> gdoteof: does main = do { now <- getCurrentTime; ... } help you?
10:12:46 <elliott> you can do that in any IO action that's part of your program, not just main, of course
10:13:04 <elliott> (btw, technically getCurrentTime is an "action", not a "function", but that doesn't really matter)
10:13:24 <ben> Isn't every value a function, some just don't take arguments? :)
10:13:35 <elliott> ben: No.
10:13:44 <elliott> ben: http://conal.net/blog/posts/everything-is-a-function-in-haskell
10:15:20 <Ke> is there some function that's equivalent to rm -rf
10:15:46 <Ke> ie. no exceptions, just remove whatever is on that path, if anything
10:16:30 <ClaudiusMaximus> @hoogle removeDirectoryRecursive
10:16:30 <lambdabot> System.Directory removeDirectoryRecursive :: FilePath -> IO ()
10:16:40 <ClaudiusMaximus> (read its docs, it's different to rm)
10:17:00 <Ke> ClaudiusMaximus: that a) does not work for files b) fails with exceptions
10:17:13 <Ke> that was my initial attempt
10:17:31 <elliott> not difficult to write one
10:17:33 <elliott> @hoogle isDirectory
10:17:33 <lambdabot> System.Posix.Files isDirectory :: FileStatus -> Bool
10:17:36 <elliott> ugh
10:17:38 <elliott> well it'll have some name
10:17:42 <elliott> @hoogle getDirectoryContents
10:17:42 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
10:17:44 <elliott> @hoogle remove
10:17:45 <lambdabot> Data.Graph.Inductive.Monad.IOArray removeDel :: IOArray Node Bool -> Adj b -> IO (Adj b)
10:17:45 <lambdabot> System.Posix.Directory removeDirectory :: FilePath -> IO ()
10:17:45 <lambdabot> System.Directory removeDirectory :: FilePath -> IO ()
10:17:48 <elliott> @hoogle delete
10:17:48 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
10:17:48 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
10:17:48 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:17:52 <elliott> meh
10:18:01 <Ke> I know, but I wouldn't expect to have to write everything myself
10:18:01 <gdoteof> elliott: it helps but doesn't solve.  i haven't actually ran it in main; i was trying to run it in ghci
10:18:09 <elliott> Ke: well, I don't think there'll be anything premade, since removeDirectoryRecursive *is* the premade
10:18:21 <elliott> if the standard thing doesn't suit your needs you'll have to roll your own
10:18:26 <elliott> gdoteof: ah
10:18:31 <elliott> gdoteof: then "now <- getCurrentTime" works.
10:18:35 <gdoteof> but i am getting 'last expression of do must be an expression'
10:18:37 <elliott> ghci is as if it was in a do block.
10:18:50 <elliott> can you hpaste the code you are having troubles with?
10:18:52 <elliott> @where hpaste
10:18:52 <lambdabot> http://hpaste.org/
10:19:02 <gdoteof> ohhhhhhh
10:19:10 <andares> is the source code for lambdabot available anywhere?
10:19:33 <gdoteof> ghci as if it were in a do block
10:19:38 <gdoteof> now it makes sense
10:19:42 <gdoteof> well, less unsense
10:19:48 <gdoteof> thanks
10:19:49 <ClaudiusMaximus> gdoteof: you might want to try   :set +s  in ghci, too (extrapolating...)
10:19:50 <andares> a do block for what kind of monad?
10:20:21 <elliott> IO
10:20:41 <andares> cool.
10:22:21 <elliott> gdoteof: andares: though, don't stretch the "as if" too far -- e.g. "2 + 2" works in ghci but not in a do block
10:22:29 <elliott> basically it adds "print" if you forget ;)
10:22:38 <andares> :p
10:23:02 <hpaste> a pasted “as” at http://hpaste.org/65464
10:24:06 <elliott> thanks, a
10:24:20 <gdoteof> great.  just a a knot untie in my head thanks elliott
10:24:32 <gdoteof> s/a a/had a/
10:24:51 <elliott> np :)
10:27:59 <gdoteof> another question; how can i go from NominalDiffTime to Integer; presumably as Seconds
10:28:37 <gdoteof> the whole thing i am trying to do here is get the time between two UTCTime in minutes
10:28:49 <gdoteof> as an Int
10:29:40 <parcs`> gdoteof: round
10:31:12 <elliott> gdoteof: yeah, you can use numeric typeclass methods like round, truncate, etc.
10:31:49 <gwern> @quote
10:31:49 <lambdabot> oklopol says: you shouldn't code haskell just before going to sleep, i had this nightmare where i couldn't get this program to compile
10:32:06 <gdoteof> ah and i "know" that because it's an instance of Num ?
10:32:22 <parcs`> RealFrac, rather
10:32:28 <parcs`> :t round
10:32:29 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
10:33:11 <elliott> gdoteof: the instances are listed in the docs... it can be a bit unintuitive with the time library
10:33:28 * hackagebot silently 1.1.5 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.1.5 (TrystanSpangler)
10:38:40 <gdoteof> thanks.  on ubuntu i have the packages ghc-doc and ghc-haddock installed.  where would i find those files so i can have a local copy of the docs?
10:39:21 <gdoteof> /usr/share/doc/ghc-* are all just readme files
10:40:37 <Sgeo> Can I give GHC an option such that it inlines none of the functions defined in a file?
10:40:59 <gdoteof> nm i am just wrong
10:41:00 <gdoteof> it is there
10:41:04 <elliott> No.
10:43:24 <gdoteof> well, it doesn't appear that the module Data is there
10:43:55 <geekosaur> gdoteof, perhaps "dpkg -l ghc-doc" and/or "dpkg -l ghc-haddock" will be helpful?
10:44:04 <elliott> There is no Data module.
10:44:18 <elliott> There's Data.Map and Data.Set and so on, but no Data.
10:44:24 <gdoteof> elliott: or time module?
10:44:28 <elliott> Try opening the index.html file in the documentation folder.
10:44:31 <elliott> gdoteof: That's System.Time.
10:44:52 <geekosaur> oh
10:44:58 <gdoteof> elliott: what am i looking at here http://www.haskell.org/ghc/docs/7.0.2/html/libraries/time-1.2.0.3/Data-Time.html
10:45:20 <geekosaur> Data isn' a module, that I know.  Data.Data is but possibly not provided in there
10:45:21 <elliott> Oh, Data.Time, sorry.
10:45:24 <elliott> System.Time was old-time.
10:45:28 <elliott> Back in the day.
10:45:42 <gdoteof> elliott: or more directly; where would i likelly find that locally? i am looking in the index.html file
10:46:19 <gdoteof> elliott: oh.  agin nm
10:46:47 <gdoteof> it is there if i just go to it in the address bar; but i didn't see how to 'navigate' there from the root index.html
10:47:04 <gdoteof> but its all clear now
10:52:40 <nolrai_portland> Hey, if one wants to _write_ svg files in Haskell is there a good library to use?
10:53:29 <hpc> nolrai_portland: look for a library that can write xml
10:53:39 <nolrai_portland> Okay.
10:53:52 <hpc> there's no library that's specifically for svg files
10:54:44 <ClaudiusMaximus> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=svg
10:56:14 <hpc> oh, i suppose there is
10:56:31 <Saizan> cairo can output svg files, not sure what it wants as input though
10:56:59 <nolrai_portland> hpc:?
10:57:10 <hpc> see what ClaudiusMaximus linked
10:59:14 <nolrai_portland> thanks!
11:17:10 <hpaste> asdasdsad pasted “asdasd” at http://hpaste.org/65465
11:18:34 <NemesisD> hi all. i keep running to an issue where i'm trying to use Maybe's monad instance inside of a monad, i.e. foo :: IO (Maybe Int), inside the monad I want to do sum <- fmap (+1) =<< foo
11:19:13 <hpc> :t \x -> fmap succ =<< x
11:19:13 <lambdabot> forall a (m :: * -> *). (Enum a, Functor m, Monad m) => m (m a) -> m a
11:20:34 <hpc> NemesisD: let (.:) = fmap . fmap
11:21:06 <hpc> > (+1) .: [Just 5]
11:21:08 <lambdabot>   [Just 6]
11:21:23 <NemesisD> ahhh, nice!
11:21:29 <Philonous> Is there a maintained list of reverse dependencies on hackage ?
11:21:33 <hpc> :t (.:)
11:21:34 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
11:22:22 <geekosaur> Philonous, not yet.  there's a hackage2 prototype which shows what they will look like but I don't think it's live-tracking hackage yet
11:24:39 <hpaste> Pedro pasted “orelha de porco” at http://hpaste.org/65466
11:24:42 <Philonous> geekosaur:  Ah, too bad. Is there maybe a script that extracts them from the cabal index file?
11:25:36 <jfischoff> is there a name for the function RoseTree a -> [(Path, a)] ?
11:27:12 <hpc> jfischoff: if there was one already, or what we would name it?
11:27:21 <hpc> i think i would name it "traverse" or "flatten" or something
11:27:34 <geekosaur> hrm.  Philonous, I don;t know how often this gets updated but http://packdeps.haskellers.com/ ?
11:27:48 <jfischoff> yeah, there is a flatten in Data.Tree that gives the node in preorder
11:28:11 <jfischoff> and there is a "levels" that gives the node based on their level
11:29:24 <jfischoff> I was hoping there was a common name for that operation and I could find an implementation
11:30:41 <Philonous> geekosaur:  It lists packages as new as "Thu Mar 15 ", so it should be fairly recent. That's do, thanks a bomb.
11:30:57 <Philonous> That'll*
11:46:19 <Taneb> Hello!
11:46:33 <dmh> hi
11:46:34 <zachk> hi Taneb
11:49:11 <Taneb> I've got something that's almost good enough to be a library
12:00:25 <guerrilla> I need to make a static (or dynamic) shared library that can be used by another static (or dynamic) shared library with GHC 7.0.4 on Linux but everything I do doesn't work (e.g. -dynamic and -fPIC for each obj and -shared to try and generate a .so pair or -static -shared to generate a .a pair).. what's the deal here? it's been a long time since i've done so w/ C (gcc), so i could be forgetting something critical.. any tips?
12:00:57 <guerrilla> (not using cabal)
12:03:00 <guerrilla> maybe -optl can help me..
12:05:48 * geekosaur is slightly lost, "static shared library" does not exist
12:06:12 <bxc> looking for a DNS library that is more in the direction of 'dig' rather than just looking up hostnames (specifically I want ot be able to specify which servers I'm querying, because i want to be implementing my own consistency checks) -- can anyone recommend which one to pick? hsdns?
12:07:24 <homie> rdns ?
12:07:29 <homie> reverse-lookup ?
12:08:03 <geekosaur> looks to me like http://hackage.haskell.org/packages/archive/dns/0.3.2/doc/html/Network-DNS.html
12:08:18 <geekosaur> hsdns might have some of the desired functionality but that's not its purpose
12:08:43 <guerrilla> geekosaur: i meant object archives by that (.a) , sorry for the confusion
12:10:02 <bxc> homie: i'll want to do some reverse DNS lokoups, but more than that. there's a bunch of ritualistic DNS diagnosis that I keep doing, that I want to script in haskell -- eg go to each name server, ask it what it thinks the other nameservers are, check they all match up; go to each nameserver, check that they all give the same values for an A record, etc
12:14:54 <bxc> network.dns looks nice. i want to be able to specify non-recursive lookups, though - maybe i'll have to add that.
12:17:07 <flebron> Hey, when we say that a monad is a monoid in End(Hask), do we mean that we have as a monoid (End(Hask), mu, eta) or some subset X of End(Hask) (perhaps a singleton), and the monoid is (X, mu, eta)?
12:20:54 <danharaj> flebron: A monoidal object in a category is an object with two morphisms.
12:21:10 <flebron> Oh, ok, so a monoidal object. Then a singleton :)
12:21:21 <danharaj> flebron: don't think of the objects of a category as sets.
12:21:46 <flebron> No no, I mean, a monoid has a set of objects, but here that set would be a singleton, correct?
12:21:52 <danharaj> No.
12:21:57 <danharaj> A monoid is an object.
12:22:14 <flebron> (X, *, e), where X is some set, is it not?
12:22:22 <dolio> Category theory can generalize the definition of monoid.
12:22:23 <danharaj> nope. Where X is an object in your category.
12:22:28 <JamesJRH> Hello, I'm new to Haskell. So Haskell is compiled? You don't need a compiler to run the program, right?
12:22:42 <flebron> Ok then we have different definitions of the word monoid.
12:22:43 <dolio> Where ordinary monoids are a special case for the category of sets.
12:22:54 <danharaj> JamesJRH: GHC can compile Haskell programs to native binaries and also comes with an interpreter.
12:22:57 <flebron> Oh, OK, so that's the generalization.
12:23:06 <JamesJRH> danharaj: Cool.
12:23:35 <danharaj> flebron: In the case of monads, the objects are functors. The product is functor composition, and the natural transformations are join and return.
12:24:47 <absence> if i have the latest haskell platform installed in windows, is there an easy way to get ghc 7.2 or later?
12:25:44 <flebron> So the category theoretical notion of a monoid _on a category C_ is a triple (X, *, e) where X is an object in my category, and * and e are what?
12:26:05 <dolio> flebron: First you need to know about monoidal categories.
12:26:19 <dolio> Those are categories with a functor (x) and object I....
12:26:39 <dolio> Such that A (x) I and I (x) A are isomorphic to A, in certain nice ways.
12:26:56 <dolio> And A (x) (B (x) C) is isomorphic to (A (x) B) (x) C
12:27:35 <dolio> So, a monoid object in a monoidal category is an object M together with * : M (x) M -> M and e : I -> M.
12:27:59 <dolio> With nice properties on those that represent associativity and commutativity.
12:27:59 <danharaj> In Set, a monoid is thought of as a set with a binary operation and unary operation. In general, you need to replace the notion of binary operation by defining a product functor on the category that satisfies the laws dolio alluded to.
12:28:37 <danharaj> In the case of End(Hask), the product is functor composition with unit the identity functor.
12:28:52 <flebron> Interesting.
12:29:04 <danharaj> Note that we have not required the product to be symmetric.
12:29:15 <dolio> Yes, and if you use product and singleton set in Set, you get ordinary monoids.
12:30:03 <dolio> Another interesting thing about the generalization is....
12:30:11 <dolio> If you take dual construction, you get comonoids.
12:30:20 * flebron is thinking, btw, not dead.
12:30:44 <dolio> In set, it looks like (M, e : M -> 1, d : M -> M x M).
12:31:06 <dolio> And the rules that those satisfy force d to be the diagonal, \x -> (x, x)
12:31:17 <dolio> So all sets are trivially comonoids.
12:31:37 <dolio> _But_, when you do it for endofunctors, you get comonads, which aren't trivial.
12:34:00 <danharaj> Probably because the unit in the case of End(Hask) is not a singleton but an entire universe of types :p
12:34:00 <dolio> Well, there are other situations where it's non-trivial, I think.
12:34:00 <flebron> Do I need to know about tensor products to understand what you called (x), dolio?
12:34:01 <danharaj> yes, like in the category of vector spaces over some field.
12:34:15 <dolio> Vector coalgebras are comonoids I think.
12:34:31 <danharaj> flebron: tensor products are an example of such a product.
12:34:53 <danharaj> If you know linear algebra it would be a nice example to work out to get another data point.
12:35:12 <Jambato> hum hi there
12:35:16 <danharaj> hello.
12:35:28 <dolio> flebron: Not really. It's just generalizing away from product and unit. The category has additional structure that is some abstract 'multiplication' of objects with a corresponding unit.
12:35:33 <guerrilla> so, i guess this is where i'm at: https://gist.github.com/2064645 .. i'm working the assumption GHC 7.0.4 can generate shared objects for links..
12:35:36 <Jambato> I'm currently doing some 99 Haskell Problems
12:35:44 <Jambato> the first one
12:35:48 <Jambato> the evry first one
12:36:00 <Jambato> and ghci is mean
12:36:03 <Jambato> https://gist.github.com/2064650
12:36:25 <dolio> flebron: So it makes the monoid construction as abstract as possible.
12:36:40 * cmccann notes that using the aforementioned trivial comonoid in contravariant position is what allows the Reader monad to exist
12:36:52 <dolio> For instance, you can't generalize groups the same way. They're usually presented in a category with actual products.
12:37:15 <dolio> Which is still more general than Set, but not as general as arbitrary monoidal categories.
12:37:53 <cmccann> otherwise you can't split a single argument to apply multiple functions to
12:37:54 <dolio> cmccann: Yeah, that's an amusing consequence.
12:38:10 * cmccann has been thinking about linear logic a lot recently :]
12:38:53 <cmccann> which makes the existence of dup :: a -> (a, a) feel a bit less trivial I guess
12:39:03 <dolio> Yeah.
12:40:15 <cmccann> was also thinking about how monads in Haskell often contain some sort of implicit monoid on the non-parametric part of the functor
12:40:48 <cmccann> like (State s) being function composition for (s -> s)
12:40:55 <cmccann> or Writer with the explicit Monoid constraint
12:41:17 <cmccann> so realizing that Reader was a contravariant comonoid was kind of amusing
12:41:17 <danharaj> I think that might be just because monoids are everywhere in programming.
12:41:47 <cmccann> danharaj, that's also true, but in this case the monoids in question relate very directly to the resulting monad
12:42:04 <danharaj> indeed, perhaps there is something deep to say here.
12:42:30 <cmccann> note that e.g. the reverse state monad is the same thing except that it composes the (s -> s) state change functions in the opposite direction
12:42:48 <cmccann> and lists are free monoids so that's kind of obvious
12:43:28 <danharaj> maybe there is a sort of categorification going on.
12:43:33 * hackagebot haskell-src-meta 0.5.1.1 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.5.1.1 (BenMillwood)
12:44:00 <cmccann> danharaj, I doubt there's anything non-trivial going on, really
13:48:38 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r ","GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops"]'
13:48:38 --- topic: set by glguy on [Tue Feb 21 17:16:07 2012]
13:48:47 * dcoutts disclaims all responsibility (despite having written that section of the user guide)
13:49:05 <td123> cmccann: interesting idea, I never thought about implementing a graph using a map
13:59:05 <danharaj> I feel like an asshole
13:59:10 <danharaj> I just wrote [1..l].
13:59:17 <danharaj> GOOD THING NO ONE ELSE WILL EVER READ THIS CODE
14:01:41 <xplat> wasn't bunnyhugs a special version of hugs created to offer better support for writing fibs?
14:03:46 <siracusa> danharaj: What's so bad about it?
14:06:27 <eyu> @pl fix
14:06:27 <lambdabot> fix
14:06:38 <eyu> @pl f g = g (f g)
14:06:39 <lambdabot> f = fix (ap id)
14:06:54 <eyu> @type ap
14:06:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:07:09 <mekeor> since when does the Num type class not require Eq ?  on hackage, it doesn't, while it does require Eq in my GHCI (':info Num')... wtf?
14:07:45 <ben> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/release-7-4-1.html :)
14:08:14 <mekeor> ben: interesting, thanks :)
14:08:20 <zachk> so people can do po-sets?
14:09:16 <mekeor> what's that?
14:10:23 <dmwit> zachk: What does Num have to do with posets?
14:10:28 <kallisti> is there any inherent benefit to message passing concurrency with ADTs over, say, simply passing a function or monadic type to the thread so that it can apply/run it?
14:11:10 <dmwit> kallisti: It's easier to observe ADTs than it is to observe functions or monadic actions.
14:11:15 <zachk> dmwit: it was the only math structure I could think of real fast that did not have a well defined equality relationship
14:11:58 <dmwit> Most math structures don't demand a well-defined (decidable) equality relationship.
14:12:28 <kallisti> dmwit: what do you mean by "observe"
14:13:08 <dmwit> kallisti: With monadic actions, there is basically exactly one operation you can perform on them: run them.
14:13:18 <kallisti> I suppose using functions/monads would be giving the sender control, whereas an ADT gives the receiver control.
14:13:25 <dmwit> kallisti: With ADTs, you can pattern match and munge in countless other ways before acting on them.
14:13:30 <kallisti> right
14:14:12 <kallisti> I think for my purposes all I really need is to send a StateT IO monad
14:14:52 <kallisti> as I have a single manager thread telling a bunch of worker threads to run actions.
14:15:33 <kallisti> however, the reply type may be an ADT, so each worker can communicate success, failure, etc.
14:16:09 <sajith>  /join #haskell-in-depth
14:16:25 <sajith> oops. :)
14:16:39 <tazjin> Does Haskell have a mascot?
14:17:39 <copumpkin> tazjin: someone tried to give it one but failed
14:17:49 <tazjin> Hm
14:17:53 <copumpkin> I quite liked it, but the community thought it was too cutesy
14:17:58 <copumpkin> or something like that
14:18:59 <Gracenotes> uh. Given a number and its modular multiplicative inverse, how easy is it to find the modulus..?
14:19:00 <dolio> I thought it wasn't goofy enough.
14:19:21 <danharaj> Gracenotes: is that even well defined?
14:19:23 <Gracenotes> you can get a multiple of the modulus, but possibly a huge one
14:19:41 <Gracenotes> danharaj: I couldn't tell you
14:19:42 <tazjin> I think it should be a sloth, because of their laziness
14:20:25 <kallisti> I like the mascot Real World Haskell uses.
14:20:33 <kallisti> Hercules beatle.
14:20:33 <Gracenotes> it's hurting my brain a little. although, I already have a headache, so, explains that.
14:20:38 <dmwit> Gracenotes: Multiply them, subtract one, prime-factorize?
14:21:03 <Gracenotes> dmwit: yeah, I need to figure out how feasible prime-factorizing is.
14:21:16 <dmwit> It's polynomial-time. Recently proven.
14:21:20 <danharaj> no it isn't.
14:21:21 <kallisti> oh wait it's a rhinocerous beatle.
14:21:27 <dmwit> Wait, what?
14:21:39 <danharaj> primality test is in P
14:21:42 <dmwit> oh
14:21:42 <danharaj> factoring is not known.
14:21:45 <dmwit> bleh
14:21:52 <danharaj> Unless you have a quantum computer ;)
14:22:09 <Gracenotes> additionally, the modulus itself may have plenty of factors
14:22:10 <monochrom> "factoring a prime" is polynomial time. recently proven.
14:22:30 <kallisti> The illustration on our cover is of a Hercules beetle. These beetles are among the largest in the world. They are also, in proportion to their size, the strongest animals on Earth, able to lift up to 850 times their own weight. Needless to say, we like the association with a creature that has such a high power-to-weight ratio.
14:22:31 <Gracenotes> lol
14:22:46 <danharaj> So this problem isn't well defined I think.
14:23:42 <tazjin> kallisti: I see what you did there; though I can't really think of a friendly way of drawing a Hercules beetle
14:24:00 <tazjin> kallisti: Mascots need to look friendly, imho. Consider tux :P
14:24:09 <danharaj> I think tux is obnoxious.
14:24:22 <kallisti> another example of cute gone wrong: Perl 6 mascot
14:25:03 <tazjin> kallisti: Just looked that one up. Ouch.
14:25:56 <danharaj> what is it
14:25:59 <danharaj> is it that butterfly thing
14:26:21 <kallisti> yes
14:26:29 <danharaj> Iunno it's kinda cute.
14:26:47 <danharaj> I shall call it the Obfuscation Fairy.
14:26:50 <kallisti> I don't really see a need for a cute mascot.
14:26:56 <danharaj> I agree.
14:27:11 <kallisti> if any mascot is needed, let it be an elegant mascot. :D
14:27:30 <kallisti> like a ballerina.
14:28:44 <danharaj> I like the hercules beetle.
14:30:16 <kaitocracy> what is the fastest way to build a list of divisors of an integer?
14:31:05 <tazjin> I still think it should be a sloth, kind of like this: http://klaud.tazj.in/F7We
14:31:24 <kaitocracy> right now I have this http://pastebin.com/jvLTV1ce
14:31:29 <mauke> The paste jvLTV1ce has been copied to http://hpaste.org/65474
14:31:40 <kaitocracy> to build half of the list, and I figure I can generate the other half easily
14:32:59 <danharaj> kaitocracy: You could find an integer that doesn't divide m, and then multiply it until you get it back modulo m, that will give you the integers coprime to m.
14:35:07 <kaitocracy> danharaj: interesting I'll look into it thanks
14:37:44 <gnoi> How can I simplify that http://hpaste.org/65475 ?
14:38:37 <copumpkin> it's not atomic
14:41:20 <dmwit> gnoi: do { fileExists <- ...; when fileExists (removeFile destination); createSymbolicLink file destination }
14:42:49 * cmccann notes, for what it's worth, that the Hercules beetle is a specific kind of rhinoceros beetle (notably, the largest)
14:43:34 <kallisti> ah
14:44:47 <benmachine> so I sent an e-mail to the bytestring maintainers in like, early january
14:44:55 <benmachine> don't think I ever got a response
14:44:56 <cmccann> rhinoceros beetles in general being various huge, beefy-looking beetles with glossy carapaces/wing covers and impressive-looking horns
14:45:08 <copumpkin> benmachine: who are they? dcoutts and dons?
14:45:29 <benmachine> copumpkin: that's what the cabal file says, at least
14:45:44 <benmachine> I know they're both busy people so I don't want to bother them too much
14:45:53 <benmachine> but also I don't want to be forgotten?
14:46:44 <copumpkin> from now on, we shall call you Benmachine the Forsaken
14:46:53 <benmachine> that's actually kind of cool
14:47:12 <benmachine> can I stand on clifftops looking mournfully into the distance while the wind ruffles my hair?
14:47:29 <copumpkin> yeah
14:47:31 <copumpkin> that's the main perk
14:48:08 <cmccann> man, I wish I had a dramatic epithet like that
14:50:49 <gnoi> dmwit: how can I avoid fileExists?
14:51:52 <geekosaur> gnoi, why do you think you need to?
14:51:59 <byorgey> Cmccan the Unepithetical
14:52:10 <dmwit> gnoi: Just always remove the file, why not.
14:52:18 <dmwit> Catch the resulting exception.
14:52:20 <byorgey> oops, Cmccann even
14:52:41 <dmwit> Checking that a file exists and then doing something to that file is a race condition anyway.
14:52:55 <gnoi> dmwit: no, I meand fileExists <- fileExist f; when fileExists
14:53:00 <dmwit> The best way is just to make a link, trying again if any exception gets thrown.
14:53:06 <gnoi> I use it twice
14:53:13 <guerrilla> dcoutts: still around? almost got this, i think, but the interfaces aren't matching up for some reason... http://hpaste.org/65477
14:53:30 <gnoi> fileExist f >>= ...?
14:53:33 <dmwit> gnoi: If what I said above doesn't answer the question, then I don't understand the question.
14:53:45 <byorgey> dmwit: I think gnoi wants to avoid giving 'fileExists' a name
14:53:48 <cmccann> byorgey, if you're going to capitalize it then "CMcCann" would be more appropriate
14:53:55 <dmwit> aha
14:54:11 <kallisti> fileXist f >>= (`when` ...)
14:54:13 <tauntaun> Question about Eq and multi-param typeclasses...
14:54:14 <byorgey> cmccann: ah, fair enough
14:54:15 <kallisti> *Exist
14:54:26 <tauntaun> Any takers?
14:54:28 <dmwit> Yep, what kallisti said.
14:54:42 <byorgey> Cmccann The inappropriately CAPITALIZED
14:55:02 <cmccann> Byorgey, ok, that works :P
14:55:10 <tauntaun> Given: class A a
14:55:21 <tauntaun> ...and instance (A a) => (Eq a) where a1 == a2 = True
14:55:31 <tauntaun> ...and class (A a) => T t a
14:55:47 <byorgey> tauntaun: that instance probably doesn't mean what you think it does.
14:55:48 <tauntaun> Why does ghci complain of overlapping instances when the following is also defined?
14:55:51 <gnoi> fileExist destination »= (flip when) $ removeFile destination
14:55:54 <gnoi> Got it
14:56:00 <geekosaur> fileExist f >>= flip when $ removeFile destinantion
14:56:00 <tauntaun> instance (T t a) => (Eq t) where t1 == t2 = False
14:56:04 <byorgey> tauntaun: it means "every type is an instance of Eq, and also it had better be an instance of A too"
14:56:10 <geekosaur> heh, yes
14:56:26 <geekosaur> note the parentheses are not needed in yours, the $ is "inside out parentheses"
14:56:29 <dmwit> I doubt the ($) is going to work here.
14:56:32 <byorgey> tauntaun: in particular it does NOT mean "every type which is an instance of A (and only such types) is an instance of Eq"
14:56:51 <tauntaun> OK...
14:56:54 <tauntaun> I'm puzzled, then.
14:56:57 <byorgey> tauntaun: more operationally, only the part to the right of the => is examined when picking an instance
14:57:30 <byorgey> tauntaun: so  two instances  ... => Eq a  will always overlap no matter what is to the left of the =>
14:57:32 <geekosaur> hm, right, $ wont work
14:57:56 <tauntaun> Well then let me phrase the question positively.
14:58:12 <tauntaun> How do I define Equality on A instances?
14:58:17 <tauntaun> (only)
14:58:41 <benmachine> tauntaun: usually, you don't, you just define it for each type
14:58:48 <kallisti> one alternative would be to make A a subclass of Eq.
14:58:48 <benmachine> tauntaun: alternatively, you can use a newtype wrapper
14:59:05 <kallisti> or that.
14:59:17 <benmachine> kallisti: well, that'll allow you to use equality in A-polymorphic functions, but it won't write any instances for you
14:59:24 <kallisti> yes
14:59:40 <kallisti> that's why there's deriving. ;)
14:59:45 <byorgey> tauntaun: yeah, I would suggest defining   class Eq a => A a where ...  and then provide   eqDefault :: A a => a -> a -> Bool
14:59:48 <benmachine> tauntaun: it's a bit of a nuisance, is the short version, but for good reason
15:00:01 <tauntaun> byorgey & benmachine: can you point me to some good reading on this, other than references?
15:00:05 <byorgey> then people can say  instance Eq MyType where (==) = eqDefault;   instance A MyType where ...
15:00:28 <guerrilla> dcoutts: i guess it's that -i takes precedence over the installed pkg?
15:00:35 <tauntaun> byorget: as you might have guessed, the whole point was *not* to presume Equality before defining the A class.
15:00:42 <byorgey> for example this is the approach taken by Traversable/Foldable/Functor
15:01:02 <benmachine> tauntaun: the reason why something like "generate an Eq instance for every A instance" doesn't work is that some type may have instances of both, in which case there is ambiguity; you can try to think of ways to fix this, but you tend to run into problems when e.g. the instances are in different modules
15:01:22 <byorgey> tauntaun: I don't see the difference.  I am suggesting that you require equality but give a way to define equality in terms of the A methods.
15:01:25 <tauntaun> <sigh> OK...
15:01:42 <benmachine> tauntaun: you're not the only person to think of this as a problem :)
15:01:44 <tauntaun> byorgey: that's a contradiction.
15:02:03 <tauntaun> benmachine: thanks; that was helpful ;)
15:02:13 <benmachine> tauntaun: there's some controversy about how to best deal with it
15:02:18 <benmachine> or if it needs dealing with at all :P
15:02:36 <tauntaun> I concede that it has an OO flavor to it.
15:02:58 <Saizan> tauntaun: why a contradiction?
15:03:04 <byorgey> tauntaun: let me say it a different way.  "class Eq a => A a where ..." does *not* presume equality before defining A.  In particular the instances for Eq and A can be defined in any order, referring to each other in any way you like.
15:03:54 <byorgey> if you are going to make every A instance an instance of Eq anyway there is not really any difference, it just shuffles the code around a bit, and requires a tiny bit of boilerplate from anyone defining an A instance.
15:04:14 <kallisti> I thikn byorgey's approach is likely the best. alternatively, you could remove the subclass dependency so that Eq is optional.
15:04:16 <parcs`> does anyone know good papers on row polymorphism? my tentative google search only brought up a single, fairly shallow paper
15:04:17 <JamesJRH> Haskell is compiled, but what can I compile it for? Can it do Arm? Can it do AVR chips on the Arduino? Can it do Pic? PowerPC? JavaVM / Dalvic for Android?
15:04:41 <mauke> JamesJRH: haskell is not compiled
15:04:57 <parcs`> well, it's actually a set of slides
15:04:59 <tauntaun> byorgey: what you said at 18:02 surprises me.
15:05:19 <JamesJRH> It's both compiled and interpreted, right?
15:05:27 <kallisti> parcs`: it simply requires that all instances of A be instances of Eq
15:05:32 <tauntaun> byorgey: and what you said at 18:03 just doesn't seem true.
15:05:41 <kallisti> it doesn't require that the Eq instance be unable to refer to the A instance.
15:05:48 <byorgey> JamesJRH: Haskell is a language.  There exist both compilers and interpreters for it.
15:05:50 <parcs`> kallisti: what
15:05:52 <tauntaun> It doesn't just shuffle the code around a bit; it obviates repetition.
15:06:11 <JamesJRH> GHC then.
15:06:24 <dmwit> tauntaun: "before" is such a tricky word
15:06:29 <kallisti> tauntaun: it adds one line of extra code.
15:06:37 <mikeplus64> JamesJRH: GHC compiles
15:06:41 <dmwit> tauntaun: If you write "instance A Foo", then an instance of "Eq" for "Foo" must be in scope at that moment.
15:06:42 <kallisti> instance Eq Whatever where (==) = eqDefault
15:06:52 <byorgey> tauntaun: for what it's worth, I do agree that it would be nice to be able to do what you were trying to do, and it would cut down on boilerplate repetition, yes.
15:06:52 <benmachine> tauntaun: why don't you think the thing is true? did you try it, and if so what went wrong?
15:07:06 <mikeplus64> although I think it can also interpret, but it isn't used to do so very much outside of GHCi afaik
15:07:07 <geekosaur> JamesJRH, GHC has support for x86/x86-64 and PPC, ARM is in development, JVM/Dalvik backend is *not* being developed (nor CLR)
15:07:09 <JamesJRH> Or rather: Does there exist compilers for those platforms?
15:07:18 <tauntaun> byorget: thanks, at least we're on the same wavelength.
15:07:27 <gentleben> JamesJRH: http://hackage.haskell.org/trac/ghc/wiki/Platforms
15:07:28 <lambdabot> gentleben: You have 1 new message. '/msg lambdabot @messages' to read it.
15:07:31 <kallisti> parcs`: what? :P
15:08:04 <rostayob> gentleben: people had GHC working already with ARM via LLVM
15:08:05 <benmachine> tauntaun: ignore my question, I'm confused
15:08:12 <rostayob> sorry, geekosaur
15:08:17 <tauntaun> benmachine: of course I tried it.  What I'm trying to is implement Equality in terms of A's 'interface', which would permit considerable code reuse and would reduce repetition.
15:08:27 <rostayob> today I always miss nicks. too much confidence in the completion
15:08:32 <mauke> does (\r f -> f (r r f)) (\r f -> f (r r f)) do what I think it does?
15:08:39 <tauntaun> Does anyone agree that what I'm trying to do smacks of OO?
15:08:53 <kallisti> tauntaun: what byorgey is suggesting allows you to do that with basically one line of code per instance.
15:08:58 <mikeplus64> mauke: obfuscate?
15:09:07 <byorgey> probably two lines.
15:09:21 <cmccann> mauke, looks like a fixed point combinator of some sort
15:09:37 <kallisti> byorgey: well, two if you indent the instance declaration. or are you referring to something I'm missing?
15:09:40 <benmachine> looks like it fails to type
15:09:41 <gentleben> rostayob: i know, and there could probably be more platform support via llvm in the future
15:09:51 <parcs`> kallisti: what requires that all instances of A be instances of Eq?
15:09:55 <benmachine> kallisti: two is basically one :P
15:10:09 <kallisti> parcs`: an explicit type constraint in a class declaration.
15:10:19 <byorgey> kallisti: yeah, I just mean if you write the method on a separate line from the 'instance Eq', which I would do even for something that simple.  But maybe I'm just weird =)
15:10:29 <kallisti> class (Eq a) => A a where ...
15:10:32 <JamesJRH> geekosaur: What about compiling into another language, say C, for which many other platforms are supported, such as tiny embedded AVR chips.
15:10:35 <JamesJRH> gentleben: Thanks.
15:11:15 <gentleben> JamesJRH: look into using LLVM to target other platforms
15:11:29 <monochrom> w00t! I caught an error in vector doc :)
15:11:35 <gentleben> JamesJRH: GHC now has an llvm backend
15:11:46 <parcs`> kallisti: ah. i'm not sure why you directed that to me though :P
15:11:59 <kallisti> parcs`: oh I did? that explains things..
15:12:03 <tauntaun> kallisti, byorget, benmachine, et al: where is the preferred place to paste a snippet of code?
15:12:10 <benmachine> hpaste.org
15:12:11 <parcs`> yeah, hehe. i thought you were talking about row polymorphism for a sec
15:12:19 <kallisti> tauntaun: sprunge.us  ;)
15:12:27 <kallisti> (real answer: hpaste. but I like sprunge)
15:13:39 <kallisti> byorgey: I'd probably use one. And hey, it drives the point even further to say "you only need one very trivial line of code"
15:13:48 <JamesJRH> gentleben: Oh? Wow, looks interesting. I wonder if I can program an Arduino using this. :-)
15:14:03 <byorgey> kallisti: fair enough =)
15:14:08 <gentleben> JamesJRH: Many things are possible
15:14:41 <JamesJRH> :-)
15:14:46 <JamesJRH> gentleben: Thanks.
15:15:16 <geekosaur> JamesJRH, there is a method to have it output portable ANSI C, but (a) performance utterly sucks (b) it is only guaranteed to work on the ghc source itself, as its purpose is to facilitate porting ghc to a new platform
15:16:05 <kallisti> the LLVM backend should be fairly portable I would think.
15:16:35 <copumpkin> what's the easiest time to write a "time literal" into a haskell program?
15:16:49 <kallisti> a what?
15:16:51 <copumpkin> there doesn't seem to be an easy way to construct a CalendarTime from a string
15:16:56 <kallisti> oh
15:17:07 <copumpkin> except the read instance that expects the massive record
15:17:14 <kallisti> NominalDiffTime is pretty easy, since it has a Num instance.
15:17:18 <geekosaur> JamesJRH, you might also want to look into jhc; it doesn't support as many extensions as ghc but it generates performant portable C code
15:17:21 <guerrilla> dcoutts: think i got it under control, but too tired to continue today :) thanks againf or the help
15:17:40 <JamesJRH> geekosaur: Performance is not an issue in this case. I just don't like C-like imperative languages, and want to program an Arduino in a high-level language with no side-effects.
15:18:01 <kallisti> copumpkin: I've always found the time libraries to be somewhat lacking..
15:18:31 <JamesJRH> geekosaur: I'll take a look, thanks.
15:18:51 <copumpkin> kallisti: yeah, I've found that in all languages I've used :/
15:19:02 <kallisti> well, Perl has excellent datetime libraries.
15:19:04 <kallisti> >_>
15:19:51 <kallisti> copumpkin: is ParseTime of any use to you?
15:20:06 <kallisti> http://hackage.haskell.org/packages/archive/time/1.4.0.1/doc/html/Data-Time-Format.html#t:ParseTime
15:20:10 <downloader> Stupid question: How do I load a library when using haskell-mode in emacs (inferior)
15:20:19 <downloader> ?
15:20:24 <copumpkin> yeah, that's more or less what I want, but it's frustrating that I need a separate module for it
15:20:25 <copumpkin> ah well
15:20:26 <copumpkin> thanks :)
15:20:56 <downloader> or change the search path for library binaries
15:21:34 <downloader> This is hugs but I don't mind using ghci
15:21:43 <kallisti> downloader: what kind of libraries? emacs libraries? Haskell libraries? with Haskell libraries you would use compiler options.
15:21:49 <JamesJRH> Wow, LLVM is ... wow! https://en.wikipedia.org/wiki/LLVM
15:22:06 <copumpkin> JamesJRH: profound
15:22:17 <kallisti> JamesJRH: yep
15:22:34 <copumpkin> the CalendarTime type seems kind of silly
15:22:35 <cmccann> @quote working.with.dates
15:22:35 <lambdabot> cmccann says: programming is a lot easier if you avoid working with dates/times, text, or numbers. I say stick to category theory, it's simpler
15:22:36 <JamesJRH> :-)
15:22:41 <downloader> kallisti: "import foo" Modules I guess is the right nomenclature for haskell
15:22:52 <gentleben> JamesJRH: LLVM is one of the most interesting things going on in software toady
15:23:24 <kallisti> downloader: yes you would add library paths via the -I compiler option. dunno about haskell-mode, I've never used it to build.
15:23:43 <downloader> kallisti: What do you do in an interactive session?
15:23:46 <hpaste> nomeata pasted “eval test” at http://hpaste.org/65478
15:23:53 <kallisti> downloader: I use the :load command
15:23:56 <kallisti> which takes a path
15:24:25 <downloader> kallisti: I read the docs. It takes a path to a source file, right?
15:24:26 <kallisti> but I usually just compile directly with GHC when testing.
15:24:30 <kallisti> I don't do much interactive stuff.
15:24:33 <kallisti> downloader: yep
15:24:45 <downloader> kallisti: What if the module consists of many source files?
15:24:49 <downloader> I have the binary built
15:25:24 <kallisti> downloader: you can load more than one file. also, any file that imports other modules will of course require compilation of those modules.
15:25:36 <kallisti> if you're trying to test a set of unrelated modules then you would have to load them individually.
15:26:07 <kallisti> and if you need to do this stuff a lot you could consider creating a ghci script.
15:26:39 <downloader> kallisti: I have a module that consists of many source files. I can compile it with cabal. Just to be clear: Can I load the compiled module or not?
15:26:42 <kallisti> but I don't really understand the problem. a "module" doesn't ever consist of more than one source file, as far as I know.
15:27:19 <downloader> Surely it can depend on other source files.
15:27:23 <kallisti> yes
15:27:35 <downloader> Which I don't want to specify individually
15:28:19 <kallisti> downloader: are the modules not in your library paths. current working directory is considered a library path...
15:28:22 <kallisti> for imports
15:28:57 <downloader> kallisti: No. They are not. How do I add to the search path in the interpreter?
15:30:39 <kallisti> downloader: not sure, actually.
15:30:44 <kallisti> I thought :load took paths but it doesn't.
15:30:50 <kallisti> shows how much I use ghci
15:31:01 <monochrom> the flag is -i
15:31:16 <dylukes> oookay... I have fun time now.
15:31:29 <monochrom> if you have installed ghc, the user guide is somewhere on your hard disk
15:31:29 <dylukes> It seems like, I installed GRUB to the MBR, not to the linux partition.
15:31:35 <dylukes> not how the hell do I get it *out*.
15:31:48 <downloader> monochrom: Can I not do it within the interpreter?
15:31:56 <dylukes> Not to mention:
15:31:56 <dylukes> https://gist.github.com/2065893
15:32:01 <dylukes> this is a bit... wrong?
15:32:13 <dylukes> So there's GRUB in my MBR, and the GPT/MBR tables don't match up at al.
15:32:27 <kallisti> monochrom: oh, indeed.
15:32:35 <kallisti> I think I'll just stop trying to help now.. :P
15:32:39 <downloader> monochrom: And isn't there a more direct way to load a module that is not in the search path?
15:32:55 <dylukes> Is there any way to clean out the MBR from my disk?
15:33:16 <monochrom> if you want to set -i at the ghci prompt, ":set -i/home/me/x"
15:33:16 <downloader> dylukes: Wrong chan?
15:33:21 <kallisti> > :set -ipath/to/stuff
15:33:22 <lambdabot>   <no location info>: parse error on input `:'
15:33:23 <dylukes> whoops.
15:33:29 <kallisti> downloader: what could be more direct than that? :P
15:33:53 <downloader> kallisti: How about ':load "/path/to/my/foo.o"'
15:34:01 <kallisti> nope.
15:34:22 <kallisti> for interactive use, just set the -i flag via :set and then use :load ModuleName
15:34:30 <kallisti> make a script if you want.
15:34:39 <monochrom> you can ":load /home/me/x/y/Z/T.hs" if you like
15:34:51 <downloader> monochrom: Except it won't find dependencies
15:34:55 <kallisti> right
15:34:58 <kallisti> setting the -i flag fixes this
15:35:01 <monochrom> that's :load for you
15:35:29 * downloader sighs a deep, heavy sigh
15:35:29 <monochrom> meditate on why "search path" is called "search path"
15:35:46 <kallisti> downloader: now I really don't understand the issue.
15:35:50 <JamesJRH> Naaaaice: http://sourceforge.net/projects/avr-llvm/
15:35:54 <JamesJRH> :-)
15:36:34 <downloader> JamesJRH: I doubt it's functional yet
15:36:42 <JamesJRH> So obviously I can compile Haskell code for my x86/x64 Linux manchines. Shouldn't be too difficult to compile for my Arm-based OpenWRT routers. Java is possible with LLVM, but whether it would work on Dalvic/Android, I don't know. And Arduino by using avr-llvm.
15:37:10 <JamesJRH> downloader: Maybe not, but it's nice to know it's in the pipeline. :-)
15:37:20 <monochrom> if /home/me/x.hs imports a "Whoa" and Whoa.hs is in /user/local/Whoa.hs, I am not sure why a rational person expects the mere command ":load /home/me/x.hs" contains enough information
15:37:34 <downloader> JamesJRH: At 3 years and counting the pipeline may be long still
15:37:58 <monochrom> perhaps you can explain to me an algorithm for do-what-I-mean
15:38:37 <downloader> monochrom: Since I am a rational person I don't expect that. I expected that I could use cabal to build the module (which would find dependencies for me) and then I could load the binary.
15:39:25 <monochrom> oh, sure, use cabal to install the module first. install. again, install.
15:40:28 <downloader> Like I said I don't want to install.
15:40:54 <monochrom> if you have only stopped right after "cabal build" you haven't installed. complete the procedure by either "cabal  register --inplace" or "cabal copy; cabal register"
15:41:39 <monochrom> there is a third way but it is better off done through the frontend called "cabal-dev"
15:41:58 <downloader> I stopped at "cabal build" because I don't want to install"
15:42:33 <monochrom> if you reject all of the above, you are asking the logical equivalent of how to boot windows without booting windows
15:42:56 <downloader> monochrom: You can do what I described in python
15:43:32 <kallisti> you can import a module without the interpreter having any clue where the dependencies are located?
15:43:33 <geekosaur> and?
15:43:39 <monochrom> I am sorry to hear that.
15:45:38 <downloader> No, in fact something similar to what you recommended with ":set" which I missed the first time around. Sorry
15:45:40 <geekosaur> downloader, python has different metadata and different *needs* for metadata (in particular it has nothing similar to .hi files which provide vital information)
15:45:43 <monochrom> and what kallisti says. if /home/me/x.py requires /media/CDROM/y.py, I don't know how any python environment can guess "/media/CDROM" based on merely "load /home/me/x.py"
15:46:27 <monochrom> again, perhaps explain to me an algorithm for do-what-I-mean
15:46:38 <kallisti> I think it's solved. he just missed my mention of being able to set the -i flag in ghci
15:46:46 <downloader> monochrom: That is the general case but in my situation all the files are part of the same module and within the same source directory
15:47:43 <kallisti> downloader: :set can set any GHC flag (as far as I know)
15:47:50 <monochrom> and mine too. <monochrom> if you want to set -i at the ghci prompt, ":set -i/home/me/x"
15:48:05 <kallisti> I typically just test with GHC itself.
15:48:16 <kallisti> perhaps I'm a weirdo though.
15:48:55 <unlink> Shouldn't Data.Lens.Lazy.access have the type ``MonadState a m => Lens a b -> m b'' rather than ``Monad m => Lens a b -> StateT a m b''?
15:49:25 <unlink> Or is there something about transformer libraries I don't that makes that prohibitive?
15:49:47 <kallisti> well since it returns StateT a m b
15:49:57 <kallisti> there's no need that the Monad m be a MonadState as well.
15:50:06 <kallisti> I think?
15:50:17 <benmachine> unlink: it's possible to do that, but it's reasonable to ask why you'd want to :P
15:50:20 <benmachine> oh wait
15:50:27 <benmachine> no it's not possible
15:50:33 <benmachine> because MonadState is mtl or monads-tf
15:50:40 <benmachine> whereas data-lens wants to be Haskell98
15:50:48 <unlink> oh.
15:50:51 <benmachine> mtl and monads-tf both require extensions
15:50:51 <kallisti> oh nevermind I see.
15:50:58 <unlink> yes, fundeps.
15:51:08 <benmachine> or type families, respectively :)
15:51:26 <unlink> of course.
15:51:39 * kallisti thinks that record declarations should come with free lenses. :D
15:52:07 <unlink> ok. so am I SOL? I have an (isomorphism to the) RWS monad. Can I ``access'' it?
15:52:12 <labo> hello
15:52:46 <benmachine> unlink: the definition of access is just 'gets (pos . f)'
15:52:50 <labo> does anyone know how could I include fortran code in a cabal library?
15:52:56 <benmachine> unlink: presumably if you jsut used the more general gets that'd Just Work
15:53:36 <labo> I have writting the binding, which I can compile and use manually
15:53:37 <benmachine> unlink: err, actually, I can't work out what pos is >_> but I'm sure it's not hard
15:53:42 <labo> writing a library is the probem
15:54:36 <benmachine> unlink: I suspect you can write the function you want yourself
15:56:12 <unlink> pos :: StoreT s w a -> s
15:56:35 <benmachine> oh right
15:56:40 <benmachine> well, whatever
15:56:45 <benmachine> you can use getL I think
15:57:07 <unlink> cc: roconnor
15:59:46 <unlink> yeah, you're right.
16:00:10 <unlink> I just need to reexport them with a different type.
16:01:04 <unlink> well, redefine
16:01:21 <benmachine> unlink: oh! http://hackage.haskell.org/package/data-lens-fd
16:01:53 <roconnor> unlink: re: Data.Lens.Lazy.access, ya we need to make a non-haskell 98 module to do that such as data-lens-fd
16:02:29 <roconnor> unlink: er, which appears to already exist
16:02:49 <unlink> by EdwardKmett, no less.
16:03:05 <roconnor> unlink: so ya, data-lens is cut up the same way transformers / mtl is.
16:07:47 <unlink> functional dependencies are a pretty OK extension in my book.
16:08:40 <benmachine> type families are better though :>
16:09:32 <kraghen> is there any way to suppress the "loading package foo-1.2.3..." output when compiling TH-using modules?
16:13:35 <d-snp> is it true that everyone who uses haskell is either in university or teaching at one? :P
16:15:32 <copumpkin> d-snp: no
16:15:42 <d-snp> so what do you do? :)
16:16:06 <unlink> roconnor: is someMapLens k %= const Nothing supposed to be how I delete something from a map irrespective of its corresponding value?
16:16:07 <copumpkin> d-snp: is everyone who uses IRC an acne-ridden teenage male who spends all his time in a basement?
16:16:40 <d-snp> copumpkin: I don't know, I used to be :P
16:16:48 <d-snp> well not in a basement
16:16:56 <copumpkin> stereotype breaker!
16:17:00 <copumpkin> I have half a mind to kick you right now
16:17:26 <d-snp> .. for what, asking a provocative question? :P
16:17:29 <copumpkin> d-snp: I guess my point was just that stereotypes like yours are really fucking annoying
16:17:38 <copumpkin> and just come across as trolling
16:17:49 <unlink> let's stop feeding the trolls and resume talking about lenses.
16:17:57 <copumpkin> d-snp: but I write financial software
16:18:45 <d-snp> ah that's cool, I can imagine haskell is nice for that
16:19:08 <copumpkin> I also use it for everything I write in my free time
16:19:12 <copumpkin> almost everything, anyway
16:19:23 <copumpkin> I don't actually use it at work, except for prototyping things
16:22:49 <d-snp> I'm going to google lenses so I can ask more non-programming related questions without unlink feeling I'm a troll :P
16:23:20 <kallisti> d-snp: I write Haskell programs for my work as a freelancer.
16:23:31 <kallisti> when I can make decisions about language.
16:26:11 <d-snp> kallisti: what do you use for frontend?
16:26:25 <copumpkin> d-snp: you actually interested in learning haskell?
16:26:54 <d-snp> yes.. I'm doing a haskell project right now, I was just seeking for some chat about how people use haskell
16:27:07 <d-snp> since everyone I know is in university and uses it for research related things
16:27:15 <kallisti> d-snp: "frontend"?
16:27:27 <copumpkin> cool :)
16:27:31 <kallisti> I don't understand the question.
16:27:49 <copumpkin> d-snp: do you know a guy who goes by Mqrius on IRC?
16:27:53 <copumpkin> (same university)
16:28:01 <kallisti> (most likely answer: I use Haskell!)
16:28:11 <d-snp> yeah, like UI? I do freelance projects too and they usually are webbased
16:28:46 <kallisti> d-snp: I haven't used it with a web-based project yet.
16:30:04 <d-snp> copumpkin: no.. but if he does CS I might know his face :P not so big university
16:38:50 * hackagebot hs-GeoIP 0.1.1 - Haskell bindings to the MaxMind GeoIPCity database via the C library  http://hackage.haskell.org/package/hs-GeoIP-0.1.1 (OzgunAtaman)
16:40:42 <roconnor> unlink: someMapLens k ~= Nothing
16:42:04 <roconnor> unlink: someMapLens k ~= Just something will add a value irrespective of whether it is already in there or not.
16:43:52 * hackagebot cassy 0.3.2 - A high level driver for the Cassandra datastore  http://hackage.haskell.org/package/cassy-0.3.2 (OzgunAtaman)
16:44:10 <roconnor> unlink: someMapPartialLens k (Data.Lens.Partial.Lazy.~=) something will replace a value in a map only if there already exists a value (note: this uses partial-lens package)
16:48:10 <d-snp> woah the stanford course on lenses has me sitting at the edge of my seat :D
17:15:33 <JamesJRH> gentleben: Hey, in addition to widespread sequential platforms, does LLVM work with combinational logic platforms such as FPGAs?
17:17:39 <JamesJRH> It would be great if a program written in a high-level language such as Haskell could be compiled/synthesised to both processors and FPGAs.
17:25:15 <Makoryu> JamesJRH: There are Haskell APIs for generating and running programs on GPUs... I don't see why the same couldn't be done for FPGAs.
17:27:16 <Makoryu> JamesJRH: Though I'm not sure if LLVM in its current state is useful for that.
17:28:51 <geekosaur> ...isn't Atom one such, if not one that does what JamesJRH is asking for?
17:33:39 <greg> what does (map (dir </>) a) mean
17:33:48 <greg> i know what map is
17:33:48 <kallisti> @hoogle dir
17:33:48 <lambdabot> Text.XHtml.Transitional dir :: Html -> Html
17:33:49 <lambdabot> package direct-daemonize
17:33:49 <lambdabot> package direct-fastcgi
17:34:02 <kallisti> I believe </> concatenates path names.
17:34:09 <kallisti> but it could mean something else in this context.
17:34:43 <kallisti> so it would append dir to the front of every path in the list a
17:34:57 <kallisti> (assuming that's the correct </> I'm thinking of)
17:35:07 <geekosaur> "prepend"... and it does look like the one from filepath
17:35:10 <kallisti> er, yes.
17:35:20 <kallisti> I have a bad habit of doing that. :P
17:35:37 <greg> thanks guys
17:36:46 <greg> what does dir do? hoogle just give me the types
17:37:14 <geekosaur> I suspect "dir" there is a string (or more precisely a FilePath), not a function
17:37:30 <Saizan> dir is likely a local variable from wherever you've taken that code
17:37:31 <greg> ...runs to check
17:38:11 <geekosaur> and </> is concatenation including a system-specific separator character (so '/' on unix and '\\' on DOS)
17:39:55 <greg> oh one more thing, how does one use hoogle from within ghci
17:40:16 <geekosaur> (aside, not sure why I said "DOS" instead of "Windows" there but the flshback did make e consider that filepath is not up to VMS paths :)
17:40:31 <ClaudiusMaximus> http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration
17:41:53 <greg> cool thanks geekosaur
17:41:54 <greg> thanks ClaudiusMaximus
17:51:39 <hpaste> shergill pasted “linking local stylesheet” at http://hpaste.org/65484
17:53:41 <d-snp> oh god, they define ^. as an operator :|
17:53:41 <jhtjhg> Has anyone had any luck building the latest version of HsOpenSSL?  I'm pretty sure I've got the prerequisite libraries installed, but the build keeps failing with some sort of syntax error inside of an *.hsc file. The full error is here: http://pastie.org/3618412. This is on version 0.10.1.4, pulled from Hackage.
17:53:57 <roconnor> d-snp: what are you watchin?
17:54:07 <roconnor> d-snp: ^. hails from Pascal.  I think it is cute.
17:54:24 <d-snp> just resumed reading the stanford course on lenses
17:54:29 <roconnor> where?
17:54:34 <d-snp> http://www.scs.stanford.edu/11au-cs240h/notes/zipper.html
17:54:41 <geekosaur> jhtjhg, sounds like someone omitted a language option, specifically CPP
17:54:43 <roconnor> thanks
17:55:15 * geekosaur amused at (^.)
17:55:34 <d-snp> how does it make sense?
17:55:38 <roconnor> I'm impressed lenses have made their way into course material.
17:55:47 <roconnor> what
17:55:51 <roconnor> they use Store!
17:56:08 <roconnor> who the hell is teaching this?
17:56:31 <roconnor> is edwardk an Stanford Prof?
17:57:03 <copumpkin> lol
17:57:07 <copumpkin> no
17:57:37 <d-snp> it's taught by the writer of real world haskell
17:57:38 <copumpkin> David Mazieres, Bryan O'Sullivan, and David Terei
17:57:54 <shachaf> And also one lecture by dpiponi, I think.
17:58:02 <shachaf> But those slides were bos.
17:58:20 <copumpkin> totally bos.
17:58:38 <JamesJRH> geekosaur: Yes, Atom looks very good, thanks.
17:58:41 <roconnor> but but ... I only coined Store less than 2 years ago.
17:58:49 <d-snp> hey that's cool you can actually look at the students' assignments
17:58:52 <roconnor> now it is being taught at stanford?
17:58:58 <d-snp> lol :D
17:59:24 <roconnor> ICFP shouldn't have rejected my paper :D
17:59:31 <d-snp> I want something I said be taught at stanford too :(
17:59:48 <roconnor> d-snp: If I can do it, so can you!
17:59:51 <shachaf> roconnor: I think you can blame edwardk for *that*.
18:00:12 <copumpkin> roconnor: does that reasoning apply to constructive real arithmetic in coq, too? or purecoin?
18:00:49 <roconnor> copumpkin: I haven't submitted papers on constructive reals or purecoin to ICFP.
18:01:01 <copumpkin> why not!
18:01:21 <roconnor> copumpkin: meh, the ACM probably wouldn't publishish it even if it were accepted.
18:02:14 <danharaj> Does anyone know what a typical footprint for the GHC RTS is?
18:02:22 <danharaj> Also if there are flags that can make it even smaller?
18:05:01 <JamesJRH> geekosaur: Although, I don't know why it has to be a DSL (https://en.wikipedia.org/wiki/Domain-specific_language). FPGAs are general purpose combinational, like CPUs are general purpose sequential. Surely general purpose programming languages should target both processors and FPGAs.
18:06:13 <davean> JamesJRH: They're rather different
18:08:00 <JamesJRH> davean: I know FPGAs and CPUs are very different, but high-level languages should surely be abstracted from the underlying hardware.
18:08:34 <davean> JamesJRH: abstrations leak to an extent, consider just how different they are
18:08:47 <davean> JamesJRH: you could also compile it to gears and clutches
18:09:11 <JamesJRH> Besides, Haskell is probably much better suited to combinational logic, being purely functional.
18:09:20 <davean> While both are general purpose, the fundimental primatives are entirely different
18:09:57 <koninkje> Anyone interested in helping me with some bikeshedding?
18:10:02 <d-snp> you can run a general high level language on a gpu too, doesn't mean it's smart ;)
18:11:03 <koninkje> In particular, I'm generalizing the functions on single terms in unification-fd to operate over Foldable/Traversable collections
18:11:18 <koninkje> question is: how to adjust the names?
18:11:49 <JamesJRH> d-snp: GPUs aren't general, they're designed for graphics. But they have useful computing when the graphics isn't needed.
18:12:15 <koninkje> The names in question here are: getFreeVars, applyBindings, freshen,...
18:12:21 <JamesJRH> d-snp: I think OpenCL can make use of this spare computing power.
18:13:07 <rasfar> there is http://hackage.haskell.org/package/lambda-bridge
18:13:30 <rasfar> (though i've not tried it)
18:16:43 <davean> JamesJRH: Have you ever looked at the theoretical efficienty of translating between machine specifications?
18:17:08 <JamesJRH> davean: No, what's that?
18:17:39 <davean> JamesJRH: for example, translating a lambda machine to a turing machine, etc
18:17:47 <davean> because that is basicly what you are asking
18:17:53 <JamesJRH> Yes.
18:17:54 <davean> and it is a very well understood area
18:18:05 <JamesJRH> Under what name?
18:18:05 <davean> and it makes it very clear why what you are suggesting isn't a good idea
18:20:24 <koninkje> davean: Any good overviews when it comes to things like FPGAs (or gears&clutches) ?
18:21:55 <Saizan> every haskell compiler has to translate lambda calculus to the pretty different von neumann architecture, so that's not really a good point
18:22:39 <davean> Saizan: They aren't really that different, the computational model is the same from a theory of computation perspective
18:22:53 <davean> JamesJRH: Well, I might start around Cobham's thesis
18:23:00 <Saizan> davean: turing tarpit?
18:23:21 <Saizan> also, aren't FPGA turing complete too?
18:23:23 <davean> Saizan: not relivent here
18:23:33 <davean> Saizan: they are, under a different machine model
18:23:34 <geekosaur> ladder logic?
18:23:52 <davean> Saizan: Some machines give you zero access time to a given address, others give you different considerations
18:24:05 <davean> these affect how things run a lot
18:24:18 <davean> FPGAs are entirely unlike CPUs in their considerations
18:24:27 <Saizan> lambda calculus doesn't even have a notion of address
18:24:46 <davean> Saizan: And, a lambda machine is one model of comutation
18:25:28 <davean> http://en.wikipedia.org/wiki/Theory_of_computation
18:25:33 <davean> er
18:25:35 <davean> http://en.wikipedia.org/wiki/Theory_of_computation#Models_of_computation
18:25:52 <copumpkin> davean: aren't you in the boston area?
18:25:57 <davean> copumpkin: yes
18:26:07 <copumpkin> I think edwardk mentioned you at some point
18:26:19 <Saizan> davean: yeah, but i don't see why it seems to you so much similar to von neumann and so different from FPGA
18:26:19 <davean> copumpkin: Would make sense
18:26:32 <davean> Saizan: it isn't that.
18:26:51 <davean> Saizan: The compiler would have to be entirely different, the code in the language would also if it was to be at all efficient
18:27:21 <Saizan> davean: i agree that the compiler would be different
18:27:42 <d-snp> oh I'm reminded, JamesJRH there is a compiler that compiles haskell to V(H)DL
18:27:51 <Saizan> and surely code like Foreign.Storable wouldn't apply or have to be different
18:27:58 <d-snp> I suppose it could compose haskell to an FPGa too
18:28:13 <d-snp> it's called clash, and is being developed by my professor :P
18:28:23 <d-snp> or well, by his student
18:28:25 <davean> Saizan: a lot more then that would differ in practice
18:28:38 <JamesJRH> davean: Yes, I've come across this before. But it not as bad as you make out. Changing between turing-complete models may only incur a polynomial change in time I think.
18:28:50 <Modius> Is cabal just for open sourcey/shared projects, or something you'd use as the backbone of a proprietary executable too?
18:28:55 <davean> JamesJRH: yes, and that is usually pretty notable
18:29:12 <davean> JamesJRH: For non-trivial systems you'd still not be able to just use it
18:29:20 <davean> JamesJRH: and that is in an infinite machine
18:29:25 <davean> JamesJRH: FPGAs are very limited
18:29:36 <davean> JamesJRH: you need to be very careful to keep in your functional unit count
18:29:52 <davean> JamesJRH: look at the size of "large" modern FPGAs
18:29:59 <davean> that leaks the abstraction a lot
18:30:21 <JamesJRH> davean: Right. that's the space complexity, isn't it.
18:30:45 <davean> Sorta
18:31:03 <davean> you're mostly talking about the space the PROGRAM takes here, not the data
18:31:35 <davean> Does it work? Yes. Can you just compile your program across? Not except in fairly trivial cases.
18:35:48 <Saizan> yeah, one can't expect code optimized for one backend to necessarily work well on others
18:36:59 <davean> Saizan: so, as you get experiance programming in a way oriented towards a different backend, what happens to your appreciation for specific features in the language?
18:39:11 <Saizan> davean: can you rephrase?:)
18:40:02 <davean> Saizan: Since the code you write for a given target is different, what language you want for writing that code is different
18:40:42 <d-snp> granted the targets differ significantly
18:40:49 <d-snp> or even fundamentally
18:41:01 <davean> Saizan: Maybe only at the sugar level mind you
18:41:05 <Saizan> davean: i don't agree
18:41:09 <d-snp> I don't write different code for arm than for x86
18:41:25 <Saizan> i mean, that might be the case, but i don't see it as a necessity
18:41:25 <d-snp> but I do want to write different code for gpu than for cpu
18:41:36 <Saizan> high level languages can be flexible enough
18:41:42 <davean> d-snp: they're the same computation model
18:41:48 <davean> (arm and x86)
18:42:12 <d-snp> I'll go read that wiki on computational models
18:45:10 <JamesJRH> davean: I wasn't saying everything /should/ be compiled to FPGAs, I was saying everything should /be able/ to compile to FPGAs.
18:45:44 <JamesJRH> davean: I think it's possible that one day the GPU will be replaced with the FPGA, allowing combinational computationally-intensive applications (including graphics) to be compiled to the FPGA, allowing for massively parallel computing, while largely sequencial applications and I/O bound applications remain on the CPU. Computers may one day be entirely software configurable and general-purpose, and consist of little more than I/O, storage, memory, CPU
18:46:26 <davean> JamesJRH: be able to in theory, the size limit of the FPGA means most things can't
18:47:11 <davean> Many things can
18:47:37 <Jafet> JamesJRH: don't roll your joints from Larrabee white papers
18:48:12 <JamesJRH> davean: Probably because FPGAs are lagging behind GPUs or whatever in fab technology, but they'll catch up.
18:48:23 <davean> JamesJRH: no
18:48:27 <Philippa> Modius: you can use cabal for proprietary stuff, yeah
18:48:34 <Philippa> just don't put the packages on Hackage
18:48:49 <davean> JamesJRH: Size is an inherant issue with FPGAs and programs are of virtually arbitrary size
18:48:53 <Philippa> JamesJRH: there's this thing called "overhead", it matters
18:48:54 <davean> JamesJRH: MORE will fit
18:49:06 <davean> JamesJRH: But size isn't fudgable like time is
18:49:14 <davean> JamesJRH: it is either large enough or not
18:49:24 <davean> You can play optimization games
18:49:31 <davean> you can shift parts to a standard CPU
18:49:38 <davean> Still, it comes down to size
18:50:05 <Philippa> FPGAs are really nifty, but they still cost for what you get. (GP)GPUs are likely to be better for anything that wants lots of FLOPs for a very long time because of that
18:50:49 <davean> JamesJRH: It may be interesting to compile very specific parts of a program to an FPGA, but that still leaves the FPGA as a (E)DSL
18:50:51 <JamesJRH> Philippa: Yeah, there's routing/configuring overhead, but they're still behind in transistor count, etc.
18:51:09 <davean> JamesJRH: Well, each block is many transistors
18:51:38 <Philippa> davean: yep, that's pretty much where you'd go - not least because it gives you some ways to hack around the space limit to some extent (so long as you don't choke on your bandwidth requirements)
18:52:04 <davean> Philippa: Yep, and this conversation started with why DSL not the language
18:52:38 <davean> I don't know why it has to be a DSL [link snipped]. FPGAs are general purpose"
18:52:45 <davean> "I don't know why it has to be a DSL [link snipped]. FPGAs are general purpose"
18:52:58 <Philippa> hah, yes. Slightly unusual notion of domain specific, but still
18:53:14 <Philippa> the State monad is a language for the domain of stateful programs
18:53:15 <Saizan> yeah, it's not so much about domain
18:53:25 <davean> Target specific
18:53:30 <davean> but the wording isn't mine :)
18:53:45 <Philippa> yeah, "problem domain" just got a bit wider, is all
18:53:47 <JamesJRH> davean: What's the E in (E)DSL?
18:53:50 <Philippa> Embedded
18:53:53 <davean> embeded
18:54:32 <JamesJRH> davean: Yes each block is many transistors, but as FPGAs are a smaller market, fab tech will also be a factor.
18:54:46 <JamesJRH> Philippa, davean: Right.
18:55:53 <davean> JamesJRH: go look at the actual fab tech, compair
18:55:58 <davean> JamesJRH: this is a very easy excersize
18:56:06 <davean> even if it *did* matter
18:56:13 <davean> but, fundimentally, it is basicly irrelivent
18:56:35 <davean> if it was using the tech a PPro was built on, it wouldn't change the underlying issue
18:57:40 <davean> JamesJRH: also, FPGAs don't just magically reconfigure
18:57:53 <davean> Not the most relivent practical issue, but there
18:57:53 <JamesJRH> No.
18:58:05 <Philippa> davean: pretty relevant if you like to multitask
18:58:43 <davean> Philippa: or want to page your program in to deal with size issues
18:58:59 <davean> Philippa: though it can, of course, only avoid specific types of program size issues
18:58:59 <JamesJRH> But multitasking could theoretically be implemented.
18:59:10 <davean> JamesJRH: no, really it couldn't!
18:59:16 <davean> JamesJRH: it isn't a possability in theory
18:59:22 <Philippa> JamesJRH: you think context switches are slow now?...
18:59:33 <Philippa> shit, my /head/ switches context faster than an FPGA would
18:59:45 <davean> JamesJRH: Ok, given you said that, I think it is time for you to go learn what an FPGA actually is
19:00:24 <davean> Philippa: well, I don't know, in some ways, a few ms is faster then I usually do it
19:00:41 <davean> Philippa: and there are ones that do that ... it is possible
19:00:43 <JamesJRH> Who says multitasking on an FPGA requires time-multiplexing? The area could be divided between tasks!
19:00:49 <Philippa> davean: fair enough
19:00:55 <davean> JamesJRH: except your issue is you already are area limited!
19:01:07 <JamesJRH> Ok.
19:01:09 <davean> JamesJRH: so now you can't run even more tihngs!
19:01:52 <tauntaun> Where does GHC define comparison of Ints to Floats?
19:02:22 <JamesJRH> davean: I what one /is/. That doesn't mean to say I have one or have used one.
19:02:29 <c_wraith> tauntaun: it doesn't
19:03:00 <tauntaun> c_wraith: then why are we able to do this:  1 < (1.0::Float)
19:03:22 <c_wraith> tauntaun: because numeric literals are polymorphic.
19:03:23 <danharaj_> :t 1
19:03:25 <lambdabot> forall t. (Num t) => t
19:03:54 <Saizan> @type let x = 1; _ = x < (1.0 :: Float) in x
19:03:55 <lambdabot> forall t. (Num t) => t
19:04:27 <Saizan> the MR is never there when you need it
19:04:46 <danharaj> The undependable monomorphism restriction?
19:05:05 <JamesJRH> davean: I didn't realise they were so limited. I thought they had millions of transistors! Even if each block has a few, there's still a lot of blocks.
19:05:38 <davean> JamesJRH: They have hundreds of thousands of blocks
19:05:47 <davean> JamesJRH: each block does almost nothing though
19:05:50 <Saizan> ?type 1 `asTypeIn` \x -> x < (1.0 :: Float)
19:05:51 <lambdabot> Float
19:06:03 <tauntaun> I'm pretty frustrated about the question I raised earlier.
19:06:42 <tauntaun> Shouldn't there be a way to make an instance of type A be also an instance of Eq?
19:06:46 <Saizan> tauntaun: if you want to compare an Int with a Float you've to convert one of the two explicitly, btw
19:07:19 <c_wraith> tauntaun: "instance of a type" doesn't even make sense.  types can be instances of classes.  But types and classes are distinct
19:07:27 <tauntaun> Let me run my problem by you guys in distilled form.
19:07:37 <tauntaun> (c_wraith: I mean "instance of a type class")
19:07:42 <rasfar> i think compiling functional languages to FPGA must be very interesting, regardless of limitations
19:07:47 <Saizan> tauntaun: not if you want instances for a given type to be globally unique
19:07:57 <Saizan> tauntaun: assuming separate compilation of modules
19:08:32 <JamesJRH> davean: Well that's a lot. If you run out of space, surely it's possible to split a function up and make it part-senquential, right?
19:09:14 <davean> JamesJRH: and then you have to reconfigure! If you can do it like that - which ok, you basicly can, but possibly negating the entire point of the excersize in the first place
19:09:33 <tauntaun> I want simply to say that instances of class C are also instances of Eq, so that if types T1 and T2 are instances of C, I can define equality on T1's and T2's only in terms of C's "interface".
19:09:40 <Saizan> tauntaun: the problem is you could use (==) on type X where you have in scope an instance A X, and somewhere else where that instance isn't in scope and so another would be picked
19:09:57 <JamesJRH> davean: Once or per step?
19:10:02 <tauntaun> Saizan: I don't understand why we're talking about scope.
19:10:38 <Saizan> tauntaun: because typechecking only considers instances from modules you (indirectly) import
19:10:38 <tauntaun> Saizan: I'm going to have to think carefully about your comment.
19:12:27 <Saizan> anyhow, the bottom line is that typeclasses don't offer that kind of inheritance, if you want it you can use records of functions
19:13:45 <tauntaun> Saizan: can you say a bit more about records of functions, or point me to a resource?
19:13:47 <Philippa> davean: I'd be interested in an FPGA that's rigged to run while reconfiguring, but it'd be a hell of a typing discipline involved
19:14:15 <davean> Philippa: And you'd need one that didn't wear out
19:14:31 <davean> I've been assuming hpaste
19:14:41 <davean> I've been assuming JamesJRH was just assuming that issue was solved though
19:14:58 <tauntaun> Saizan: do you mean use a record of functions to simulate an object with methods?
19:15:10 <Saizan> tauntaun: yeah, something like that
19:15:47 <Philippa> davean: yeah, what're typical lifetimes like at the moment?
19:15:59 <Philippa> (for comparison, I've not had a flash device fail on me yet)
19:16:30 <Saizan> ?type nubBy
19:16:31 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
19:16:57 <Saizan> ^^^ trivial example of a function taking such a record
19:17:14 <davean> Philippa: not sure
19:17:21 <davean> Philippa: I don't keep up on that
19:17:26 <JamesJRH> davean: I know there is an issue with dynamic reconfiguration, but I think some newer ones can 'partially reconfigure' some of the area while still running.
19:18:12 <JamesJRH> davean: Why would they wear out?
19:18:15 <rasfar> i think they've been dynamically reconfigurable for some time now
19:18:38 <JamesJRH> davean: Ram doesn't wear out.
19:19:06 <rasfar> Xilinx at least
19:19:14 <koninkje> well, no more than any other electronics...
19:19:17 <Philippa> FPGAs aren't ram. Flash, for comparison, /does/ wear out
19:20:07 <Saizan> memristors ftw
19:21:17 <hpaste> shergill pasted “cannot deduce (m ~ IO)” at http://hpaste.org/65486
19:21:41 <shergill> could someone help debug the above ^
19:22:04 <JamesJRH> Philippa: I thought it was volitile memory that is loaded from a configuration stored in a possible separate flash chip on boot.
19:22:07 <shergill> removing the type signature of getBOFHExcuses removes the error
19:22:07 <Saizan> shergill: you need to liftIO (readProcess "fortune")
19:22:34 <Saizan> shergill: and you can remove the liftIO in front of return
19:22:52 <JamesJRH> Philippa: But surely they don't have to have flash.
19:22:58 <shergill> Saizan: ah ok. thanks
19:24:12 <Philippa> JamesJRH: they use a lot of LUTs, but they're not just conventional ram or a close analogue thereof
19:28:02 <JamesJRH> Philippa: Hmm. I wasn't aware that LUTs are prone to burning out. :-\
19:28:59 * hackagebot majordomo 0.1.2 - Majordomo protocol for ZeroMQ  http://hackage.haskell.org/package/majordomo-0.1.2 (MarkWotton)
19:29:01 * hackagebot majordomo 0.1.3 - Majordomo protocol for ZeroMQ  http://hackage.haskell.org/package/majordomo-0.1.3 (MarkWotton)
19:31:41 <Philippa> JamesJRH: it's not a big deal for conventional use at present
19:40:31 <niteria> what's the preferred way to send pathes to a darcs repository?
19:43:00 <Saizan> darcs send if you have sendmail and the repo has an email address configured, or you can darcs send -O to get a file with the patch
19:43:12 <Saizan> s/patch/patches/
19:44:46 <xplat> @tell edwardk fwiw i think ><> is 'fish' and >><> is 'tropical fish'
19:44:47 <lambdabot> Consider it noted.
19:46:57 <koninkje> Is there any common naming convention for relating a family of A -> B functions to Traversable f => f A -> B' or Foldable f => f A -> B' functions?
19:47:14 <koninkje> In particular, when the A->B functions may already have plural sounding names?
19:47:27 <JamesJRH> Ok, maybe FPGAs won't replace GPUs. I said that because GPUs are specific to one type of rendering, and won't be much use when Real-Time Ray Tracing (RTRT) comes along. But it would be better to just make RTRT GPUs in that case due to the overhead of FPGAs that is more significant than I thought.
19:48:34 <JamesJRH> But still, it may be that one day general purpose computers have FPGAs.
19:49:49 <davean> JamesJRH: keyword:hypercomputer?
19:49:53 <Philippa> eh, we'll just see GPUs that put a bit more branching in place
19:50:29 <Philippa> then again, I say that having used a friend's all-in-cache software RTRT code to stress-test a CPU something like a decade ago
19:51:20 <JamesJRH> Philippa: Hey, wow!
19:51:33 <JamesJRH> A decade ago?
19:51:42 <Philippa> yeah. I didn't say the scene was hugely complex :-)
19:51:44 <xplat> cmccann: you're working on your own iterateeish thing?
19:52:01 <JamesJRH> Philippa: Oh, ok.
19:52:35 <niteria> Saizan: shall I just send darcs send -O output as an attachement?
19:53:07 <Philippa> JamesJRH: it was still moderately impressive at the time, in a "you still had to know your shit to make it work" kinda way
19:53:26 <JamesJRH> :-)
19:53:39 <Saizan> niteria: yeah
19:53:42 <davean> Philippa: did he have to worry about memory address selection to avoid associativity issues?
19:54:24 <Philippa> didn't talk through the details on it, it was just a quick "hey, you need a CPU burn test, right?" thing
19:55:04 <cmccann> xplat, only incidentally, there are enough iteratee-ish libraries as is. but yes, it overlaps with that. why?
19:56:14 <Saizan> xplat collects them
19:57:27 <JamesJRH> davean: Hypercomputer? Is computation beyond Turing-complete remotely feasible? Quantum maybe? Neural? I think dynamic use of FPGAs /is/ remotely feasible.
19:58:47 <Philippa> eh, so long as the One Rich Asshole doesn't get his hands on an actual oracle
19:58:48 <c_wraith> What makes people believe there *is* something beyond turing?
19:59:00 <c_wraith> I've never figured that one out.
19:59:13 <singpolyma> I have a question about Quantified datatypes and instances.  I'm using http://hackage.haskell.org/packages/archive/hastache/0.3.3/doc/html/Text-Hastache.html#t:MuType  (the MuType datatype), which as you can see uses forall.   I want to define an instance on this datatype (for the ToJSON class from Aeson), but I would need to add a constraint to the forall'd type variables... is that even possible?
19:59:28 <Philippa> c_wraith: it's not so unreasonable to consider that there might be. At which point you need a name just to say it doesn't exist
19:59:46 <Philippa> otherwise, I suspect it's mostly a debate about physically realisable infinities
20:00:11 <c_wraith> Philippa: sure.  But then people like Penrose come along and assume the human brain is magically more powerful than a turing machine without any kind of evidence for the claim.
20:00:26 <Philippa> yeah, that's something different
20:00:30 <Philippa> (butbut quantum woo!)
20:00:54 <cmccann> more like the human brain is magically less powerful than a turing machine
20:01:09 <c_wraith> human brain lacks an infinite tape
20:01:19 <cmccann> like a turing machine with a finite tape and also is made of gray jello
20:01:22 <Saizan> singpolyma: you can add constraints to the quatified vars only by editing the definition of MyType
20:01:33 <Philippa> yeah, the brain's actually emulated /in/ the TM
20:01:38 <Philippa> by the finite state machine
20:01:51 <JamesJRH> cmccann: Lol!
20:01:59 <Philippa> (the rest is an abstraction of a human computer working with pencil and paper)
20:02:04 <singpolyma> Saizan: ok, so if I'm in another module, there is no way at all to define such an instance on the dataype, because the type variable I would need to modify is hidden?
20:02:48 <Saizan> singpolyma: you can only work with what MuVar provides
20:03:24 <singpolyma> Saizan: ok
20:16:27 <byorgey> has anyone ever encountered the error "user error (error while writing to output stream)"
20:17:07 <byorgey> this is coming from an executable, compiled from Haskell source, which I swear was just working yesterday.
20:17:20 <sipa> phase of the moon
20:17:40 <dmwit> byorgey: disk full?
20:17:53 <dmwit> or permissions, maybe?
20:18:41 <byorgey> dmwit: hmm, permissions is a good thought.  disk is definitely not full.
20:19:15 <byorgey> aha, it was trying to create a file in a directory that did not exist =)
20:19:57 <koninkje> the only thing on google is at the bottom of http://itpro.nikkeibp.co.jp/article/COLUMN/20101207/354957/?ST=ittrend&P=4
20:21:55 <koninkje> that's their observation too. Seems an obscure error message though
20:29:49 <ion> I love how good these error messages are nowadays. h1p2.hs:3:8: Could not find module `Numeric.Dimensional.Prelude'. Perhaps you meant Numeric.Units.Dimensional.Prelude (from dimensional-0.10.2)
20:59:51 <xplat> cmccann: Saizan is right, i kind of do :)  i'd like to create an iteratee library with proper compositionality and resource handling.  if i can figure out what that is :)  but i'll be just as happy if someone else creates it, so i like to keep abreast of the field.
21:02:43 <xplat> cmccann: i'd actually be kind of interested in what your interface would look like even stubbed out with no implementation, it does sound interesting.
21:08:05 <cmccann> xplat, haha, ok. really busy with real life stuff for the next while which is why I don't have anything ready yet.
21:09:09 <shachaf> Wait, cmccann exists in real life?
21:09:24 <cmccann> supposedly.
21:09:24 <copumpkin> lol
21:10:41 <shachaf> I was at an event recently that kmc also went to, and he introduced me as "this is shachaf, from IRC. Well, I guess he's from real life too."
21:10:52 <cmccann> hahahaha
21:28:29 <Jafet> Real life is bad for solipsism
21:32:52 <dmwit> IRC is real.
21:34:35 <copumpkin> nuh uh
21:42:44 <gdoteof> if i install something with cabal does it come with documentation; and if so where do i get it?
21:42:50 <gdoteof> (ie locally)
21:44:39 <zzo38> How to do geometry in Haskell?
21:47:37 <koninkje> gdoteof: You need to add "documentation: True" to your ~/.cabal/config
21:48:43 <koninkje> gdoteof: after doing so, the documentation is installed at ~/.cabal/share/doc/index.html etc
21:49:14 * hackagebot osm-download 0.3.2 - Download Open Street Map tiles  http://hackage.haskell.org/package/osm-download-0.3.2 (ThomasDuBuisson)
21:50:53 <kallisti> zzo38: what kind?
21:51:54 <copumpkin> > snd $ mapAccumL (\x y -> (y, x + y)) 0 [1..]
21:51:55 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
21:52:13 <copumpkin> > snd $ mapAccumL (\x y -> (y, f x y)) 0 [1..] :: [Expr]
21:52:15 <lambdabot>   [f 0 1,f 1 2,f 2 3,f 3 4,f 4 5,f 5 6,f 6 7,f 7 8,f 8 9,f 9 10,f 10 11,f 11 ...
21:53:32 <shachaf> > (zipWith f <*> tail) [0..] :: [Expr]
21:53:34 <lambdabot>   [f 0 1,f 1 2,f 2 3,f 3 4,f 4 5,f 5 6,f 6 7,f 7 8,f 8 9,f 9 10,f 10 11,f 11 ...
21:54:28 <zzo38> kallisti: I mean, to calculate intersection, overlap, angles, line, circle, etc
21:54:39 <gdoteof> koninkje: ah thanks.  can i do something to tell it to grab all the documentation?
21:55:02 <kallisti> zzo38: if you want to perform those calculations only on specific shapes then I would define ADTs for each shape and then use typeclasses for the operations.
21:55:16 <shachaf> kallisti: :-(
21:55:34 <koninkje> gdoteof: I'm not sure. I don't think so; I think you just have to reinstall everything you want documentation for
21:55:39 <rwbarton> s/typeclasses/functions/
21:55:57 <kallisti> I suppose for shapes that are simply sets of lines you can use a set of lines.
21:56:06 <kallisti> the typeclass lets you use any particular representation you prefer.
21:56:22 <koninkje> Gothmog_: While you're at it, if you want to do profiling in the future, be sure to add "library-profiling: True" as well
21:56:24 <kallisti> *line segments
21:56:36 <kallisti> shachaf: ?
21:56:42 <zzo38> And I mean not only for Euclidean geometry but also for spherical geometry and so on.
21:56:47 <koninkje> gdoteof: Er, see my previous
21:59:57 <gdoteof> koninkje: thanks
22:14:17 * hackagebot hspec 0.9.2 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.9.2 (SimonHengel)
22:31:10 <pjdelport> i have a question regarding http://www.reddit.com/r/haskell/comments/qwklh/coexponentials/
22:31:33 <koninkje> yes?
22:34:11 <pjdelport> i understand the analogy between exponentiation of types and numbers; and i *roughly* follow the definition of coexponentials in that discussion
22:34:41 <pjdelport> is there a corresponding numeric interpretation of coexponentials?
22:35:16 <koninkje> I haven't found one that's especially intuitive
22:38:00 <pjdelport> it seems like it would be a valuable analogy
22:38:22 <koninkje> t'would indeed
22:38:56 <pjdelport> could you perhaps try to explain even an unintuitive one?
22:39:22 <pjdelport> or point me in the right direction? :)
22:40:08 <koninkje> Well, the right direction will be something dualizing exponentiation of numbers...
22:40:23 <koninkje> logarithms don't quite work out sensibly though IMO
22:49:46 <koninkje> You could try reading http://ncatlab.org/nlab/show/exponential+object
22:51:20 <sohum> @pl \a b -> (f a) + (g a b)
22:51:21 <lambdabot> ap ((.) . (+) . f) g
22:51:27 <sohum> ugh
22:51:38 <wagle> anyone tried representing complex numbers in the syntax "2 - 3i"?  i have this urge
22:51:57 <ion> > 2 - 3i
22:51:58 <lambdabot>   -1
22:52:01 <rwbarton> you can do that
22:52:13 <rwbarton> if you use a better Num instance
22:52:18 <copumpkin> o.O
22:52:24 <rwbarton> where 3x = 3*x
22:52:25 <copumpkin> lol
22:52:39 <ion> FSVO “better”
22:52:48 <wagle> too bad - is b0rked
22:52:56 <rwbarton> it's the one people actually use outside caleskell
22:53:05 <rwbarton> like, in math
22:53:16 <copumpkin> eww, math
22:53:29 <copumpkin> we do computers around these here parts
22:53:39 <ion> eww, computers
22:54:00 <wagle> eww reality
22:54:07 <pjdelport> koninkje: reading, thanks
22:55:09 <wagle> i was thinking of changing the reader so that i was a suffix to digits to make it imaginary
22:56:11 <wagle> seems like it should work, except for "-i" wouldn't be allowed
22:56:46 <Axman6> doesn't C++ now (or for a long time?) have syntax for numbers with units? so you can say 3m, and it will make a meters object with a value of 3?
22:57:18 <wagle> interesting..  i think f# might
22:58:06 <wagle> saw an article on dimensional analysis for f#, but didnt pay attention since I didnt have a windows box
22:58:57 <wagle> i dont know c++ enough to know the answer to the original question
22:59:50 <zzo38> kmc: I wrote another program for Haskell preprocessor, it is on Hackage. It might be usable in case is no good m4
22:59:58 <copumpkin> kmc isn't around
23:00:49 <JamesJRH> wagle: How are you doing complex numbers?
23:00:53 <koninkje> pjdelport: if we write the coexponential a<-b as b_a then we have that op(b^a) = b_a and op(b_a) = b^a, and we have that b_a is isomorphic to a*op(b)
23:00:53 <JamesJRH> > (-1)**0.5
23:00:54 <lambdabot>   NaN
23:01:41 <Axman6> > (-1)**0.5 :: Complex Double
23:01:42 <lambdabot>   6.123233995736766e-17 :+ (-1.0)
23:01:49 <Axman6> > (-1)**0.5 :: Complex CReal
23:01:50 <lambdabot>   0.0 :+ 1.0
23:02:04 <wagle> JamesJRH: not yet, playing at writing my own library to learn them before using a standard library
23:02:15 <zzo38> Do you know if there is any Haskell programs/libraries for things related to astronomy and/or astrology?
23:02:34 <wagle> need matrices of complex for quantum programming
23:02:37 <JamesJRH> Axman6: Ah, right.
23:03:09 <pjdelport> hmm
23:03:18 <wagle> :i CReal
23:03:26 <wagle> > :i CReal
23:03:27 <lambdabot>   <no location info>: parse error on input `:'
23:03:31 <wagle> awww
23:04:13 <koninkje> pjdelport: But then op(a*b) = a+b and op(1) = 0, which suggests that dualization is the logarithm
23:04:43 <wagle> @hoogle CReal
23:04:45 <lambdabot> No results found
23:04:53 <koninkje> except, somehow it's involutive :)
23:08:07 * wagle breaks down and uses the google
23:08:32 <koninkje> pjdelport: the thing to bear in mind, however, is that if a category is both cartesian closed and cocartesian closed then it's just a boolean algebra. Hence, if we have both exponentials and coexponentials then they become "uninteresting"; so there's only so far you can go with analogies. Coexponentials in general will be more interesting than what you get in a CCC
23:10:01 <wagle> Axman6: haskell has dimensional-tf for dimensional analysis
23:10:35 <ion> Hmm. I’ve been using just dimensional. Does the -tf version have some benefits for the end user?
23:10:53 <wagle> dunno..  uses type families
23:11:52 <wagle> was going to start using it once I had the physics software written/setup..
23:13:14 <Cackala> I'm a pluckin a louk bo peep
23:13:21 <Cackala> Shoematsu desu, niddle the hair bons with caution  Belgable wolf waffy.  Is anyone here a rubberty dugger?  Is anyone a reggy dick plegger?  Shoody spalooj moojer!  Mella murtasTcM.  Is this happy hour at the retard shack again?  ron ron reggatoon.  Walla julie malerf luck.  Weggerty wing yaing plucking time!
23:13:22 <Cackala> Gotta set up for the suicide slide  Gamma mareenmon.  I've got more scrap ass shit than you can balieve with.  Sally McDuffo whip.  after secv on a sp00ky stream F/\gga foo regga makegg mahoun.  Its all fun and games until the power goes out.  Mennima Pay Street.  Rubbity dib dadge pickard.  Lelly in ma kellar.
23:13:24 <Cackala> I'm on recky o gregor street.  Miggity ass raggan.  Boyar bod.  Pellicka pool wiss wall.  Watching bynum bukkake the smelts  Haggity ass mahown.  Trukkity rep roon, the kitz a kickel plujin.  Trellalickers and burb street.  Huck a dickin' dime.
23:13:26 <Cackala> Float a pelly plack ass.  You're a digital dumbass.  Smuggy jaloo meff jillahole.  Dick, dick, dick dickaloo!  Dick dickaloo my darling.  Haggity ma heggal hole.  nuriggerdy diggal.  Visi blurb cage.  O melon man mist meluhn mijohn.  Oh man mellajoram.  Hebble oh babble.
23:13:28 <Cackala> Two guns and a ruck roog.  Turned into a hollow loop.  scritch scratch the happy fog.  Is anyone here a fudge plucker.  I'm talking bout a rastal marry yo map.  Too many ruggerty dag datoes  Or are you fuck wappys out for kill gore!
23:13:30 <Cackala> Ploona lefflie ludge picking!  Haggy smith heddal, marry oh dettal.  Hannabalist, no cannibalist, no hannibalist balievar.  Ban dackoo.  Put on weight!  Wherr wiss fall, nudge plucking.  too many |\|igg/\s, that's my line.  I'm squirt with the worth of the mother plucking fine.  Hoomee missee  Mic daisy too.  Davey oh doubt.  Meggie mahoo middle.
23:13:32 <Cackala> Too many Romulan potatoers.  Matoonal dakkal.  Helly muhp, melly muhp, runna minuck taste-rum.  Wack ass weight!  Hellamanorf weg watthal.  I think I'll just start to try my McTasterums.  Rubbity boom ducking.  Hitchaleval exasht romice.  Up with jelly my humpfrins.  Uva devil miss tee pie.  She can't poo!
23:13:34 <Cackala> Shniqqen munuh lik leggal  perritolma penis pran chella  maloney day breeze  Paahster jam ban wikkle.   Hella mah lun mick hella malole.  Hella minull mic mella manoh.  The roadline, it's illegal.  Trully mulla mih nole.  I'm a relladge-o-melladge-o-ram.  Come on you fuckin dag asses.
23:13:36 <Cackala> Damned ram bastions.  McJellio oper Smelly gruthergrarin trilaxals.  withers ground ring air  Puggle dee maggle dee mack traggle  Jeremy sniqqle. Jeremy spoken, in next day  I brusht boyered, I kicked a ball!  mellaminorf  troll protectors, trolls on the road!  troll protectors, their stones of power glow!
23:13:38 <Cackala> Fleeberty dith bub, a hick now a hither they humpty tance Hunchell munch a reg uhl schoolio tress nael Chuck a lick a loon baby tunes Weerz mellicorp To the wack ann watching machine wells darilla raptor plexing
23:13:40 <Cackala> Shligga ligga millik hole Shligga ligga millik hole regamakio mathjul hah there Just like in Bart Simpson the Magazine! Ban ricky ban glicky jallo whip! menario mibs Pahorp pahilla thin meffrin slujjal jeggy moran magomorph baleener
23:13:42 <Cackala> I spell it throwt, you spell it throat, the real way to spell it is throwt throwt THROWT!  Hux a mex a lig dwarf  dudikolan mail street.  Rella manae, Rella Manae, Rye dut duh!  I'm living on budgy placky street.  Reggal dee deck shweener  Hicker trellalicker
23:13:43 <Cackala> What part of that doesn't make sense to you robo  I'm rang dang smacking it up to the reck a heek a horn drom.  Rag agg big chacka lo datey fifty.  Sniggital maggal  Shelly a jelly a jew lillaputan meglamarian necks booga man  Rejja mella mic jeggal  Baika looka reg tag
23:13:45 <Cackala> Throat a pelly proat raick axe.  It doesn't eat muggo whip.  It's a piece of paiper.  Scrubbity ass ragamahoun.  Raggity ass maga muffin.  Where's songy brother?  Where's spongy brother?  Jellanie mic flyer.  Paloody pluck bag ack.  Paloody pluck bag ack.
23:13:47 <Cackala> Whyn you call it throat throwt.  I'm a baffy hoe.  Flivvy a niv von neffran.  Purity and prudence  I'm suing for diaper damage.  Scragg a billy blunk rake  rast eye heeker, playmus guy  I don't know what a rubbity dabby is.  Scrunny maloo lef heel hole.  Scrunny maloo lef heel hole.
23:13:48 <shachaf> @where ops
23:13:49 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:13:49 <Cackala> Arthie shlellijge.  Arthie shlellidge.  Talking about a bee turning into a guano root.  today I'm doing pasta, i crumble it and pan fry it.  Fuckin frosty.  david hippa lappa pomprin.  Is anyone here a hemp hole?  Yeah, well shnijjy mc millicker: i know billy knalavolitz.
23:13:51 <Cackala> The Baby Faced Assassin pond.  yrummin!   Shmega melanie goetz  I'm smacking it up to the electrify beam, smacking it to the galactify beam!  Smackin the penis with the erectify beam!  When will another green skroan the horrified scream
23:13:53 <Cackala> Rubbity dag daggy dib dib, daggy daggy dib dib, daggy daggy diggy diggy dib, throwt a welly wheel wall  Reppity shcrep bam bam rep rep paranep  Shnubbity shnib up bam bam  Givin' me twice, i a molst a meeka pleck. Givin' me twice, a molst a meeka pleck.
23:13:55 <Cackala> Jeminee smucking smiggle.  Halittle halorst hamerrian sects nep tep hotep gargle dee gook mackie mchellic hole.  My niqqer dee dag sparky.  Ponto comical blessnor I'm dain dead.  Razor renzor manellik s-meg smeg you're all smegs.  We're hovvy hella pruss miss puss  Smelly mudga munaqqal  Posta wicka holma melancholy laggam
23:13:55 --- mode: ChanServ set +o copumpkin
23:13:57 <Cackala> Shmelly a mellac.  Cloaky active camoflauge mail bow  Warez into a whoop coup daddy deam, I filed a lawsuit with G.L.E.A.M.  Dag a ricka bleg nagg.  Richel reprezhnik rally mic hoe whip.
23:13:58 --- kick: Cackala was kicked by copumpkin (No.)
23:14:00 --- mode: copumpkin set +b *!~cacala@125.129.69.135
23:14:00 --- kick: Cackala was kicked by copumpkin (No.)
23:14:02 <shachaf> copumpkin++
23:14:20 <koninkje> copumpkin++
23:14:21 <zzo38> Cackala please stop What is all that mess?
23:14:32 <wagle> copumpkin**
23:14:48 <Veinor> copumpkin+-
23:14:50 <shachaf> copumpkin=A(copumpkin,copumpkin)
23:20:03 <ion> I think that bot has been here in the past, too.
23:20:42 <ion> lambdabot please stop What is all that mess?
23:21:03 <shachaf> ion: Well, that bot sure showed us.
23:21:19 <ion> Yeah, totally ruined my day.
23:25:34 <tswett> Ahh.  I just love spring.  It smells like functional programming.
23:26:37 <ion> I.e. full of tree sperm?
23:28:51 <zzo38> Do you know of any program/library in Haskell related to any astronomy and/or astrology?
23:30:17 <Axman6> those are tqo fairly unrelated areas
23:30:21 <Axman6> two*
23:30:28 <JamesJRH> Axman6: How do I import CReal?
23:30:51 <Axman6> i think it's in the numeric package on hackage. google can tell you though
23:30:58 <Axman6> @google Haskell CReal hackage
23:31:01 <lambdabot> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
23:31:02 <lambdabot> Title: Data.Number.CReal
23:31:20 <Axman6> numbers, not numeric it seems
23:33:52 <zzo38> So, do you know answer of my question? I can find absolutely nothing.
23:34:25 <JamesJRH> Axman6: On Ubuntu, for Python I usually install python-<package>, but I can't find anything for Haskell.
23:36:08 <zzo38> But the only thing I think of, is a possible typeclass for ephemeris calculations:   class Ephemeris x where { openEphemeris :: String -> IO x; closeEphemeris :: x -> IO (); accessEphemeris :: x -> Time -> Word16 -> Word32 -> IO (XYZ, XYZ, XYZ); };
23:37:16 <JamesJRH> How do I install Haskell modules on Ubuntu?
23:38:16 <wagle> depends..  how did you install haskell?
23:38:35 <JamesJRH> Apt.
23:39:48 <ion> cabal install packagename
23:39:52 * wagle waits for the 15 year old CRT to warm up on his ubuntu box
23:40:03 <ion> “on Ubuntu” is irrelevant.
23:41:16 --- mode: copumpkin set -o copumpkin
23:41:36 <wagle> actually, relevent..  but awww...  no creal ubuntu package for haskell (only for ocaml)
23:42:01 <wagle> use cabal, I guess
23:42:47 <wagle> doont know how well cabal plays with ubuntu's notion of haskell
23:42:55 <zzo38> Where the parameters in accessEphemeris are: (x) open ephemeris, (Time) date/time to compute positions, (Word16) major object number, (Word32) minor object number, (XYZ, XYZ, XYZ) coordinates of (center, north pole, zero longitude/zero latitude) of object.
23:44:50 <zzo38> Everything else could be computed from that, using geometry and physics calculations, such as apparent positions, refraction, sidereal time, ecliptic coordinates, equatorial coordinates, eclipses, lunar ascending node, azimuth coordinates, houses, and so on.
23:47:12 <wagle> JamesJRH: I use haskell-platform and cabal instead of the ubuntu packages
23:47:44 <wagle> cabal would have the creal
23:49:34 <wagle> ... or not..  (I'm not the best person for this info)
23:50:08 <JamesJRH> wagle: I've just used cabal. Impressed it doesn't require root and install system-wide. But I still can't import CReal.
23:50:27 <JamesJRH> import Data.Number.CReal
23:50:42 <JamesJRH> Is it case sensitive?
23:50:44 <wagle> yeah, i cant find it in cabal either
23:51:00 <JamesJRH> cabal install numbers
23:51:10 <wagle> yeah, but thats the case signature
23:51:15 <JamesJRH> ?
23:52:52 <wagle> not according to cabal info Numbers
23:53:58 <JamesJRH> "Cached: Yes"?
23:54:28 <JamesJRH> wagle: Case signature means it's the correct case?
23:54:48 <JamesJRH> I've not heard that term case signature before.
23:55:31 <wagle> sorry, i invent terms..   yes, thats the correct case for the letters
23:55:47 <JamesJRH> Do I have to 'reload' something in Haskell?
23:56:14 <wagle> you could just steal http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/src/Data-Number-CReal.html#CReal
23:56:48 <wagle> and install it somehow (I dont know how and I'm falling asleep)
23:57:11 <JamesJRH> wagle: No. It's installed.
23:57:22 <JamesJRH> wagle: New shells work.
23:57:50 <wagle> what installed it?
23:58:15 <JamesJRH> wagle: I must have to 'reload' some module list if I want to still use the existing shell.
23:58:32 <JamesJRH> wagle: cabal install numbers
